/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
void sub_274D4();
// int strcmp(const char *s1, const char *s2);
// int fprintf(FILE *stream, const char *format, ...);
int __get_eh_info(void); // weak
_DWORD __cdecl __frame_state_for(_DWORD, _DWORD); // weak
// void *malloc(size_t size);
int __sjthrow(void); // weak
// void abort(void);
_DWORD __cdecl __deregister_frame_info(_DWORD); // weak
int __unwinding_cleanup(void); // weak
// void *memcpy(void *dest, const void *src, size_t n);
// void free(void *ptr);
int __terminate(void); // weak
_DWORD __cdecl __register_frame_info_table(_DWORD, _DWORD); // weak
_DWORD __cdecl __register_frame_info(_DWORD, _DWORD); // weak
// int __gmon_start__(void); weak
void start();
int sub_27734();
void sub_27798();
void sub_277B4();
int sub_277B8();
void sub_277F0();
int BG_AnimParseError(char *format, ...); // idb
int __cdecl BG_AnimationIndexForString(char *src); // idb
char *__cdecl BG_AnimationForString(char *a1);
int __cdecl BG_IndexForString(char *a1, char **a2, int a3);
char *__cdecl BG_CopyStringIntoBuffer(char *src, int a2, int a3, int a4);
int BG_InitWeaponStrings();
int BG_FinalizePlayerAnims();
void __cdecl sub_280A0(int a1, int a2, int a3, void *s);
int __cdecl sub_2846C(char **a1, _DWORD *a2);
char *__cdecl BG_ParseCommands(char **a1, int *a2, int a3);
void __cdecl BG_AnimParseAnimScript(char *a1, int a2, int a3);
// void __usercall sub_28D10(char *a1@<ebx>, int a2@<ebp>);
// void __usercall sub_28FC0(char *a1@<ebx>, int a2@<ebp>);
void sub_29842();
int __cdecl BG_ExecuteCommand(_DWORD *a1, __int16 *a2, int a3, int a4, int a5);
int __cdecl BG_AnimScriptAnimation(_DWORD *a1, int a2, int a3, int a4);
int __cdecl BG_AnimScriptStateChange(_DWORD *a1, int a2, int a3);
int __cdecl BG_AnimScriptEvent(_DWORD *a1, int a2, int a3, int a4);
int __cdecl BG_GetAnimScriptEvent(int a1, int a2);
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1);
// void __usercall sub_2A600(unsigned __int16 a1@<di>, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5);
void __cdecl sub_2ABA0(_DWORD *a1, int a2, unsigned int a3, int a4);
void __cdecl sub_2AE00(float a1, float a2, float a3, float a4, int a5, int a6);
void __cdecl sub_2AF78(int a1, int a2);
int __cdecl sub_2B328(int a1, int a2);
int __cdecl BG_Player_DoControllers(_DWORD *a1, int a2, int a3, int a4);
int __cdecl BG_UpdatePlayerDObj(_DWORD *a1, int a2, int a3);
int __cdecl BG_PlayAnimName(int, char *src, int, int, int, int); // idb
char *__cdecl BG_GetAnimString(int a1, unsigned int a2);
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4);
char *__cdecl BG_GetAnimationForIndex(int a1, unsigned int a2);
int BG_FindAnims();
int BG_FindAnimTrees();
int BG_LoadAnimTreeInstances();
void __cdecl BG_PlayerAnimation(int a1, int a2, int a3);
int __cdecl BG_PlayAnim(int *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7);
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, unsigned int a2);
_BOOL4 __cdecl BG_IsProneAnim(int a1, unsigned int a2);
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3);
void __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3);
int __cdecl BG_EvaluateTrajectoryDelta(int a1, int a2, float *a3);
__int16 __cdecl BG_GetMarkDir(float *a1, float *a2, float *a3);
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3);
void __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4);
int __cdecl BG_CheckProneValid(int, int, float, float, float, int, int, int, int, int, int, int, int, int); // idb
int *__cdecl BG_FindItem(char *a1);
int *__cdecl BG_FindItemForWeapon(int a1);
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3);
int __cdecl BG_CheckProne(int, int, float, float, float, int, int, int, int, int, int, int, int, int); // idb
int __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3);
__int16 sub_2E460();
long double __cdecl sub_2E5BC(char *a1);
long double __cdecl sub_2E690(_BYTE *a1);
int sub_2E970();
int sub_2EB98();
__int16 sub_2EE6C();
int sub_2F03C();
int sub_2F258();
float *sub_2F700();
int sub_2F7A4();
int sub_2FA2C();
__int16 sub_2FD68();
int __cdecl sub_30214(int a1);
int sub_3037C();
int sub_30474();
int sub_30778();
long double __cdecl sub_308CC(int a1, int a2);
void sub_309D8();
void sub_316F4();
char __cdecl PM_FootstepEvent(char a1, char a2, int a3);
_BOOL4 PM_ShouldMakeFootsteps();
char sub_322C8();
int sub_328CC();
int sub_32A44();
__int16 __cdecl PM_UpdateLean(int a1, int a2, void (__stdcall *a3)(float *, float *, float *, float *));
__int16 __cdecl PM_UpdateViewAngles(int a1, int a2, void (__stdcall *a3)(float *, float *, float *, float *));
void PM_UpdatePronePitch();
int PM_UpdatePlayerWalkingFlag();
__int16 sub_336E8();
int PM_LadderMove();
char __cdecl PmoveSingle(int a1);
int PM_SetProneMovementOverride();
_DWORD *__cdecl Pmove(int a1);
long double __cdecl BG_GetSpeed(int a1, int a2);
int __cdecl PM_GetEffectiveStance(int a1);
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3);
int __cdecl PM_ClipVelocity(int, int, int, float); // idb
void __cdecl PM_AddTouchEnt(int a1);
int __cdecl PM_AddEvent(int a1);
int __cdecl PM_VerifyPronePosition(float *a1, float *a2);
_BOOL4 __cdecl PM_SlideMove(int a1);
__int16 __cdecl PM_StepSlideMove(int a1);
int __cdecl sub_35880(int, char *s1, int); // idb
char *__cdecl sub_35A54(int a1, char *src);
char *__cdecl sub_35ADC(int a1, int a2);
// int __usercall BG_FillInWeaponItems@<eax>(int result@<eax>);
int BG_SetupAmmoIndexes();
int BG_SetupSharedAmmoIndexes();
int BG_SetupClipIndexes();
int sub_3650C();
int BG_SetupWeaponInfo();
int __cdecl BG_GivePlayerWeapon(int a1, int a2);
int __cdecl BG_TakePlayerWeapon(int a1, int a2);
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3);
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2);
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2);
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3);
int PM_UpdateAimDownSightFlag();
__int16 PM_UpdateAimDownSightLerp();
int PM_InteruptWeaponWithProneMove();
int sub_37500();
int __cdecl sub_375D0(int a1);
int sub_377B8();
int sub_378BC();
int sub_379B8();
void __cdecl sub_37A9C(int a1, int a2);
int sub_37D84();
int sub_3803C();
int sub_380C0();
_BOOL4 __cdecl sub_3820C(int a1);
int sub_384D8();
__int16 PM_AdjustAimSpreadScale();
int sub_387C0();
void sub_38918();
int __cdecl sub_38A44(int a1);
int sub_38BBC();
int sub_38C80();
int __cdecl sub_38D28(int a1);
int sub_38EB4();
int __cdecl sub_38F68(int a1);
__int16 PM_Weapon();
int sub_39350();
int sub_39484();
__int16 __cdecl sub_39604(float *a1, float *a2);
__int16 __cdecl sub_3990C(float *a1, float *a2);
__int16 __cdecl sub_39A5C(float *a1, float *a2);
void __cdecl sub_39CE8(int a1, float *a2);
int __cdecl sub_39E14(float *a1, float *a2);
void __cdecl BG_CalculateWeaponAngles(float *a1, float *a2);
void __cdecl sub_3A2D4(int a1, float *a2);
__int16 __cdecl sub_3A3C4(float *a1, float *a2);
__int16 __cdecl BG_CalculateWeaponPosition_Sway(int a1, int a2, int a3, int a4, float a5, int a6);
__int16 __cdecl BG_CalculateViewAngles(float *a1, int a2);
int __cdecl BG_IsAimDownSightWeapon(int a1);
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3);
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3);
unsigned int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2);
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2);
int __cdecl BG_AmmoForWeapon(int a1);
int __cdecl BG_ClipForWeapon(int a1);
int __cdecl BG_WeaponIsClipOnly(int a1);
int __cdecl BG_WeaponAmmo(int a1, int a2);
int PM_ClearAimDownSightFlag();
int __cdecl PM_WeaponAmmoAvailable(int a1);
int __cdecl BG_GetWeaponSlotForName(char *s1); // idb
char *__cdecl BG_GetWeaponSlotNameForIndex(int a1);
int __cdecl BG_GetInfoForWeapon(int a1);
int __cdecl BG_GetWeaponForInfo(int a1);
int BG_GetNumWeapons();
int BG_GetNumAmmoTypes();
int __cdecl BG_GetAmmoTypeMax(int a1);
int BG_GetNumAmmoClips();
int __cdecl BG_GetAmmoClipSize(int a1);
int __cdecl BG_GetSharedAmmoCapSize(int a1);
int __cdecl BG_GetAmmoTypeName(int a1);
int __cdecl BG_GetAmmoClipName(int a1);
int __cdecl BG_GetAmmoTypeForName(char *a1);
int __cdecl BG_GetAmmoClipForName(char *a1);
int __cdecl BG_GetWeaponIndexForName(char *a1);
char *__cdecl BG_GetWeaponTypeName(int a1);
__int16 __cdecl sub_3AE30(int a1);
char *__cdecl sub_3AE70(int a1, char *src);
int compare_weaponfile_names(const void *, const void *); // idb
int __cdecl PM_WeaponUseAmmo(int a1, int a2);
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1);
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4);
int __cdecl RotatePointAroundVector(int, int, int, float); // idb
int __cdecl MakeNormalVectors(float *a1, float *a2, float *a3);
float *__cdecl AngleVectors(float *a1, float *a2, float *a3, float *a4);
__int16 __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, float *a4);
int __cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4);
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3);
float *__cdecl MatrixMultiplyEquals(float *a1, float *a2);
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3);
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3);
float *__cdecl MatrixInverse(float *a1, float *a2);
float *__cdecl MatrixInverse44(float *a1, float *a2);
int __cdecl ConvertQuatToMat(int a1);
long double __cdecl QuatRatioEigenTrace(float *a1, float *a2);
__int16 __cdecl AxisToAngles(float *a1, int a2);
__int16 __cdecl Axis4ToAngles(float *a1, int a2);
__int16 __cdecl AxisToSignedAngles(float *a1, int a2);
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4);
float *__cdecl VectorRotateAngles(float *a1, int a2, float *a3);
long double __cdecl RoundFloat(float a1, int a2);
long double __cdecl PitchForYawOnNormal(float a1, int a2);
int __cdecl Q_rand(int *a1);
long double __cdecl Q_random(int *a1);
long double __cdecl Q_crandom(int *a1);
int __cdecl Rand_Init(int a1);
long double __cdecl flrand(float a1, float a2);
int __cdecl irand(int a1, int a2);
float *__cdecl gunrandom(float *a1, float *a2);
int __cdecl Q_log2(int a1);
long double __cdecl Q_acos(float a1);
int __cdecl ClampChar(int a1);
int __cdecl ClampShort(int a1);
int __cdecl DirToByte(float *a1);
int __cdecl ByteToDir(unsigned int a1, float *a2);
long double __cdecl DotProduct(float *a1, float *a2);
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3);
float *__cdecl VectorAdd(float *a1, float *a2, float *a3);
float *__cdecl VectorCopy(float *a1, float *a2);
int __cdecl VectorScale(int, float, int); // idb
int __cdecl VectorMA(int, float, int, int); // idb
int __cdecl VectorCompareEpsilon(int a1, int a2);
long double __cdecl VectorDistance(float *a1, float *a2);
long double __cdecl VectorDistanceSquared(float *a1, float *a2);
float *__cdecl CrossProduct(float *a1, float *a2, float *a3);
int __cdecl CrossProductUp(float *a1, int a2);
long double __cdecl VectorNormalize(float *a1);
long double __cdecl VectorNormalize2D(float *a1);
long double __cdecl VectorNormalize4D(float *a1);
int __cdecl VectorNormalizeFast(float *a1);
long double __cdecl VectorNormalize2(float *a1, float *a2);
float *__cdecl VectorInverse(float *a1);
int __cdecl Vector4Scale(int, float, int); // idb
long double __cdecl VectorMax(float *a1);
float *__cdecl VectorRotate(float *a1, float *a2, float *a3);
long double __cdecl VectorDistance2D(float *a1, float *a2);
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2);
int __cdecl RotateAroundDirection(int, float); // idb
long double __cdecl vectoyaw(float *a1);
long double __cdecl vectosignedyaw(float *a1);
long double __cdecl vectopitch(float *a1);
long double __cdecl vectosignedpitch(float *a1);
__int16 __cdecl vectoangles(float *a1, int a2);
__int16 __cdecl vectosignedangles(float *a1, int a2);
float *__cdecl YawVectors(float a1, int a2, int a3);
__int16 __cdecl PerpendicularVector(float *a1, float *a2);
float *__cdecl MatrixTranspose(float *a1, float *a2);
float *__cdecl MatrixInverseOrthogonal43(float *a1, float *a2);
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransformVector43Equals(float *a1, float *a2);
float *__cdecl VectorAngleMultiply(int a1, float a2);
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3);
float *__cdecl QuatInverse(float *a1, float *a2);
long double __cdecl QuatEigenTrace(float *a1);
long double __cdecl AngleEigenTrace(float a1);
long double __cdecl RotationToYaw(float *a1);
int __cdecl PitchToQuaternion(float, int); // idb
int __cdecl YawToQuaternion(float, int); // idb
int __cdecl RollToQuaternion(float, int); // idb
int __cdecl ColorBytes3(float, float, float); // idb
int __cdecl ColorBytes4(float, float, float, float); // idb
long double __cdecl NormalizeColor(float *a1, float *a2);
long double __cdecl AngleMod(float a1);
long double __cdecl LerpAngle(float a1, float a2, float a3);
long double __cdecl AngleSubtract(float a1, float a2);
__int16 __cdecl AnglesSubtract(float *a1, float *a2, float *a3);
long double __cdecl AngleNormalize360(float a1);
long double __cdecl AngleNormalize180(float a1);
long double __cdecl AngleNormalize360Accurate(float a1);
long double __cdecl AngleNormalize180Accurate(float a1);
long double __cdecl AngleDelta(float a1, float a2);
long double __cdecl RadiusFromBounds(int a1, int a2);
float *__cdecl ClearBounds(float *a1, float *a2);
__int16 __cdecl AddPointToBounds(float *a1, float *a2, float *a3);
__int16 __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4);
_DWORD *__cdecl AxisClear(_DWORD *a1);
float *__cdecl AxisCopy(float *a1, float *a2);
float *__cdecl AnglesToAxis(float *a1, float *a2);
float *__cdecl YawToAxis(float a1, int a2);
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3);
__int16 __cdecl SetPlaneSignbits(int a1);
__int16 __cdecl NormalToLatLong(float *a1, _BYTE *a2);
float *__cdecl Vec10Copy(float *a1, float *a2);
long double __cdecl Q_rint(float a1);
long double __cdecl ColorNormalize(float *a1, float *a2);
float *__cdecl VectorPolar(int a1, float a2, float a3);
int __cdecl VectorSnap(float *a1);
float *__cdecl Vector53Copy(float *a1, float *a2);
int __cdecl Vector5Scale(int, float, int); // idb
float *__cdecl Vector5Add(float *a1, float *a2, float *a3);
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4);
long double __cdecl Q_rsqrt(float a1);
long double __cdecl VectorLength(float *a1);
void __cdecl P_DamageFeedback(int a1);
int __cdecl ClientImpacts(int *a1, int a2);
int __cdecl G_TouchTriggers(int a1);
int __cdecl SpectatorThink(int a1, const void *a2);
int __cdecl ClientInactivityTimer(int a1);
unsigned int __cdecl ClientEvents(int *a1, signed int a2);
int __cdecl ClientThink_real(int a1, int *a2);
void __cdecl G_RunClient(int a1);
int __cdecl SpectatorClientEndFrame(int a1);
int __cdecl StuckInClient(int a1);
int __cdecl ClientEndFrame(int a1);
_DWORD *__cdecl G_SetClientContents(int a1);
int __cdecl ClientThink(int a1);
int __cdecl GetFollowPlayerState(int a1, int a2);
int __cdecl G_SetClientSound(int a1);
int __cdecl ClientIntermissionThink(int a1);
int __cdecl IntermissionClientEndFrame(int a1);
int __cdecl sub_416C0(_DWORD *a1, int a2);
void __cdecl GScr_AddFieldsForClient(unsigned __int16 a1);
void __cdecl Scr_SetClientField(int a1, int a2);
int __cdecl Scr_GetClientField(int a1, int a2);
int __cdecl sub_41810(int a1, int a2, const char **a3);
void __cdecl sub_41838(int a1);
int __cdecl sub_418FC(int a1);
int __cdecl sub_41968(int a1);
int __cdecl sub_41A0C(int a1);
int __cdecl sub_41A78(_DWORD *a1);
void __cdecl sub_41AEC(int a1);
int __cdecl sub_41B14(int a1);
int __cdecl sub_41B50(int a1);
int __cdecl sub_41B7C(int a1);
int __cdecl sub_41BD4(int a1);
int __cdecl sub_41C14(int a1);
int __cdecl sub_41C84(int a1);
int __cdecl sub_41D3C(int a1);
int __cdecl sub_41DB8(int a1);
int __cdecl sub_41DFC(int a1);
int __cdecl SetClientViewAngle(int a1, float *a2);
int __cdecl ClientUserinfoChanged(int a1);
const char *__cdecl ClientConnect(int a1, __int16 a2);
int __cdecl ClientSpawn(int a1, float *a2, float *a3);
void __cdecl ClientDisconnect(int a1);
int __cdecl G_GetNonPVSFriendlyInfo(int a1, float *a2, int a3);
unsigned __int16 __cdecl G_AddLean(int a1, int a2);
int __cdecl ClientBegin(int a1);
void G_SetPlayerSize();
int __cdecl PlayerCmd_giveWeapon(unsigned int a1);
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1);
int __cdecl sub_43480(unsigned int a1);
int *__cdecl sub_43578(unsigned int a1);
int __cdecl sub_43684(unsigned int a1);
void __cdecl sub_4376C(unsigned int a1);
int __cdecl sub_43CF4(unsigned int a1);
int __cdecl sub_43DF4(unsigned int a1);
int __cdecl sub_43FF4(unsigned int a1);
int __cdecl sub_44130(unsigned int a1);
int __cdecl sub_442C8(unsigned int a1);
int __cdecl sub_443E4(unsigned int a1);
int __cdecl sub_4450C(unsigned int a1);
int __cdecl sub_446E0(unsigned int a1);
int __cdecl sub_44800(unsigned int a1);
int __cdecl Player_GetMethod(char **a1);
int __cdecl PlayerCmd_takeWeapon(unsigned int a1);
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1);
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1);
int __cdecl PlayerCmd_hasWeapon(unsigned int a1);
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1);
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1);
int __cdecl sub_44DF0(unsigned int a1);
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_isOnGround(unsigned int a1);
int __cdecl PlayerCmd_pingPlayer(unsigned int a1);
int __cdecl sub_4512C(unsigned int a1);
int __cdecl sub_451B4(unsigned int a1);
int __cdecl sub_45238(unsigned int a1);
int __cdecl sub_452A4(unsigned int a1);
int __cdecl sub_45358(unsigned int a1);
int __cdecl sub_453F4(unsigned int a1);
int __cdecl sub_454B4(unsigned int a1);
int __cdecl sub_45574(int a1);
int __cdecl sub_45594(int a1);
int __cdecl sub_455B0(int a1);
int __cdecl sub_455CC(unsigned int a1);
int __cdecl sub_45660(unsigned int a1);
int __cdecl sub_456DC(int a1);
int __cdecl sub_456EC(unsigned int a1);
int __cdecl sub_4576C(unsigned int a1);
int __cdecl sub_45800(unsigned int a1);
int __cdecl sub_45884(unsigned int a1);
int __cdecl sub_45920(unsigned int a1);
int __cdecl DeathmatchScoreboardMessage(int a1);
int __cdecl ClientNumberFromString(int, char *nptr); // idb
__int16 Cmd_Fogswitch_f();
void __cdecl Cmd_Give_f(int a1);
char __cdecl Cmd_Take_f(int a1);
int __cdecl StopFollowing(int a1);
int __cdecl G_Say(int, int, int, char *src); // idb
int __cdecl sub_47050(int a1, int a2, int a3);
int __cdecl sub_47210(int a1);
int __cdecl G_Voice(int a1, int a2, int a3, const char *a4, int a5);
int __cdecl sub_476C0(int a1, int a2, int a3, int a4);
int __cdecl Cmd_CallVote_f(int a1);
int __cdecl Cmd_Vote_f(int a1);
float *__cdecl Cmd_SetViewpos_f(int a1);
int __cdecl Cmd_Activate_f(int a1);
int __cdecl Cmd_MenuResponse_f(int *a1);
_DWORD __cdecl ClientCommand(_DWORD); // weak
int __cdecl Cmd_Score_f(int a1);
__int16 __cdecl G_setfog(char *s);
int __cdecl Cmd_FollowCycle_f(int a1, int a2);
_BOOL4 __cdecl G_IsPlaying(int a1);
int __cdecl CheatsOk(int a1);
char *__cdecl ConcatArgs(int a1);
void __cdecl SanitizeString(char *a1, _BYTE *a2);
int __cdecl Cmd_God_f(int a1);
int __cdecl Cmd_Notarget_f(int a1);
int __cdecl Cmd_Noclip_f(int a1);
int __cdecl Cmd_UFO_f(int a1);
int __cdecl Cmd_Kill_f(int a1);
void __cdecl G_SayTo(int a1, int a2, int a3, int a4, int a5, int a6);
unsigned int __cdecl Cmd_GameCommand_f(int a1);
int __cdecl Cmd_Where_f(int a1);
int Cmd_EntityCount_f();
char *__cdecl sub_49800(char *dest, char *src);
int G_ParseHitLocDmgTable();
int __cdecl player_die(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8);
void __cdecl G_Damage(int *a1, int *a2, int *a3, float *a4, float *a5, int a6, int a7, unsigned int a8, int a9);
long double __cdecl CanDamage(int a1, float *a2);
int __cdecl G_RadiusDamage(int, int, int, float, float, float, int, int); // idb
int __cdecl G_GetHitLocationString(int a1);
int __cdecl G_GetHitLocationIndexFromString(__int16 a1);
int __cdecl G_IndexForMeansOfDeath(char *a1);
void AddScore();
void __cdecl LookAtKiller(int a1, float *a2, float *a3);
void __cdecl G_DamageClient(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
int __cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4);
int __cdecl G_DebugLine(int a1, int a2, int a3);
int __cdecl G_DebugBox(int a1, int a2, int a3);
int __cdecl G_DebugCircle(int a1, float a2, int a3, int a4, int a5);
int __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5);
int __cdecl sub_4AF80(int a1, int a2, int a3, int a4);
int __cdecl sub_4B03C(_BYTE *a1);
int GScr_NewHudElem();
int GScr_NewClientHudElem();
int GScr_NewTeamHudElem();
int __cdecl sub_4B5B0(int a1);
int __cdecl sub_4B6C0(int a1, int a2, const char *a3);
__int16 __cdecl sub_4B8E4(int a1);
int __cdecl sub_4BA04(int a1);
__int16 __cdecl sub_4BAF4(int a1);
__int16 __cdecl sub_4BC14(int a1);
int __cdecl sub_4BD34(int a1);
int __cdecl HudElem_GetMethod(char **a1);
int __cdecl HudElem_UpdateClient(_DWORD *a1, int a2, int a3);
void GScr_AddFieldsForHudElems();
int __cdecl Scr_GetHudElemField(int a1, int a2);
void __cdecl Scr_SetHudElemField(int a1, int a2);
int __cdecl Scr_FreeHudElemConstStrings(int a1);
int __cdecl HudElem_ClientDisconnect(int *a1);
void HudElem_DestroyAll();
int __cdecl sub_4C1AC(unsigned __int8 *a1);
int __cdecl sub_4C1FC(int a1);
int __cdecl sub_4C27C(int a1);
int __cdecl sub_4C2A8(int a1);
int __cdecl sub_4C2F8(int a1, int a2);
int __cdecl sub_4C320(int a1, int a2);
int __cdecl sub_4C350(int a1, int a2);
int __cdecl sub_4C378(int a1, int a2);
int __cdecl sub_4C3A8(int a1, int a2);
int __cdecl sub_4C3D0(int a1, int a2);
int __cdecl sub_4C400(int a1, int a2);
int __cdecl sub_4C43C(int a1, int a2);
int *__cdecl HudElem_Alloc(int a1, int a2);
int __cdecl HudElem_Free(_DWORD *a1);
int __cdecl sub_4C590(int a1);
int __cdecl sub_4C644(int a1);
int __cdecl sub_4C664(int a1);
int __cdecl sub_4C684(int a1);
int __cdecl sub_4C720(int a1);
int __cdecl sub_4C7EC(int a1);
int __cdecl sub_4C8C0(int a1);
int __cdecl sub_4C9D0(int a1);
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4);
int __cdecl sub_4CCD8(int a1, int *a2, _DWORD *a3, int a4);
int __cdecl Pickup_Health(int *a1, int *a2);
void __cdecl Touch_Item(int a1, char *a2, int a3);
// __int16 __usercall sub_4D870@<ax>(_DWORD *a1@<ebx>, int a2@<ebp>, int a3@<esi>);
int GetFreeCueSpot();
int __cdecl LaunchItem(int a1, float *a2, float *a3, int a4);
int __cdecl Drop_Weapon(int a1, int a2, int a3);
void *__cdecl FinishSpawningItem(void *s);
void __cdecl RegisterItem(int a1, int a2);
int __cdecl G_SpawnItem(int a1, int a2);
int __cdecl G_BounceItem(int a1, int a2);
unsigned __int16 __cdecl G_RunItem(void *s);
int __cdecl RespawnItem(int a1);
int __cdecl Drop_Item(int, int, float, int); // idb
int __cdecl Fill_Clip(int a1, int a2);
void __cdecl Touch_Item_Auto(int a1, char *a2, int a3);
void ClearRegisteredItems();
int __cdecl IsItemRegistered(int a1);
int SaveRegisteredItems();
int __cdecl DroppedItemClearOwner(int a1);
int __cdecl Use_Item(int a1);
int G_Printf(char *format, ...); // idb
int G_DPrintf(char *format, ...); // idb
int G_Error(char *format, ...); // idb
int G_Error_Localized(char *format, ...); // idb
int __cdecl G_GetActivateEnt(int, void *base); // idb
int __cdecl G_CheckForCursorHints(int a1);
int __cdecl G_CheckForPreventFriendlyFire(int a1);
int G_FindTeams();
int __cdecl G_InitGame(int, unsigned int seed, int, int); // idb
int __cdecl G_ShutdownGame(int a1);
int Com_Error(int, char *format, ...); // idb
int Com_Printf(char *format, ...); // idb
int Com_DPrintf(char *format, ...); // idb
int sub_50078(const void *, const void *); // idb
int G_LogPrintf(char *format, ...); // idb
int CheckVote();
void __cdecl sub_502BC(void *s);
unsigned int __cdecl G_RunFrame(int a1);
void SendScoreboardMessageToAllIntermissionClients();
void CalculateRanks();
int __cdecl G_RunThink(int a1);
void G_UpdateCvars();
int __cdecl vmMain(int, int, unsigned int seed, int, int); // idb
int compar(const void *, const void *); // idb
int G_RegisterCvars();
void *G_FreeEntities();
int ExitLevel();
// int __usercall G_UpdateObjectiveToClients@<eax>(int result@<eax>);
int G_UpdateHudElemsToClients();
unsigned int DebugDumpAnims();
void __cdecl G_XAnimUpdateEnt(int a1);
int G_XAnimUpdate();
float *__cdecl TeleportPlayer(int a1, float *a2, float *a3);
int __cdecl sub_51488(_DWORD *a1, int a2, float *a3);
int __cdecl sub_515A8(int a1, int a2);
int __cdecl sub_5201C(int a1, int a2);
int __cdecl sub_521D4(int a1, int *a2);
int __cdecl turret_think_client(int a1);
int __cdecl sub_524CC(int a1, int a2, int a3);
__int16 __cdecl turret_think_init(int a1);
_BOOL4 __cdecl sub_52880(int a1, int a2);
_DWORD *__cdecl G_FreeTurret(int a1);
int __cdecl turret_use(int a1, int a2);
int __cdecl G_SpawnTurret(int a1, char *a2);
_DWORD *G_InitTurrets();
int __cdecl G_ClientStopUsingTurret(int a1);
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2);
int __cdecl SP_info_camp(int a1);
void *__cdecl SP_info_null(void *s);
int __cdecl SP_info_notnull(int a1);
void *__cdecl SP_light(void *s);
void SP_misc_teleporter_dest();
void *__cdecl SP_misc_model(void *s);
int __cdecl use_corona(int a1);
void *__cdecl SP_corona(void *s);
int __cdecl turret_think(int a1);
int __cdecl turret_controller(int a1, int a2);
int __cdecl SP_turret(int a1);
int __cdecl misc_spawner_think(int a1);
int __cdecl misc_spawner_use(int a1);
int __cdecl SP_misc_spawner(int a1);
__int16 __cdecl miscGunnerEnemyScan(int a1);
void __cdecl G_MissileLandAngles(int a1, float *a2, float *a3, int a4);
_BOOL4 __cdecl G_BounceMissile(int a1, int a2);
int __cdecl G_MissileImpact(int a1, int a2);
int __cdecl G_ExplodeMissile(int a1);
void *__cdecl G_RunMissile(void *s);
int __cdecl fire_grenade(_DWORD *a1, float *a2, float *a3, int a4);
int __cdecl fire_rocket(_DWORD *a1, float *a2, float *a3);
int __cdecl Concussive_think(int a1);
int __cdecl Concussive_fx(float *a1);
int __cdecl G_MissileDie(int a1, int a2);
int __cdecl DynaSink(int a1);
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, float *a4);
int __cdecl sub_550F0(int a1, float *a2, float *a3, _DWORD *a4);
void __cdecl G_MoverTeam(_DWORD *a1);
void __cdecl SetMoverState(int a1, int a2, int a3);
__int16 __cdecl Reached_BinaryMover(int a1);
int __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3);
void __cdecl Use_BinaryMover(int a1, int a2, float *a3);
__int16 __cdecl InitMover(int a1);
int __cdecl InitMoverRotate(int a1);
void __cdecl Blocked_DoorRotate(int a1, void *s);
int __cdecl sub_56A14(int a1);
int __cdecl SP_func_door(int a1);
int __cdecl SP_func_pendulum(int a1);
int __cdecl SP_func_door_rotating(int a1);
int __cdecl trigger_use(int a1);
void __cdecl G_RunMover(int a1);
void __cdecl G_Activate(int a1, float *a2);
void __cdecl G_TryDoor(int a1, int a2, int *a3);
void __cdecl MatchTeam(int a1, int a2, int a3);
int __cdecl Use_Func_Rotate(int a1);
void __cdecl Blocked_Door(int a1, void *s);
int *__cdecl G_TestEntityPosition(int a1, int a2);
float *__cdecl G_CreateRotationMatrix(float *a1, float *a2);
float *__cdecl G_TransposeMatrix(int a1, int a2);
float *__cdecl G_RotatePoint(float *a1, float *a2);
void __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3);
int __cdecl ReturnToPos1(int a1);
int __cdecl ReturnToPos2(int a1);
int __cdecl GotoPos3(int a1);
int __cdecl ReturnToPos1Rotate(int a1);
void __cdecl Touch_DoorTrigger(int a1, float *a2);
int __cdecl Think_SpawnNewDoorTrigger(int a1);
void __cdecl Think_SpawnNewAutoDoorTrigger(int a1);
void __cdecl Think_MatchTeam(int a1);
int __cdecl finishSpawningKeyedMover(int a1);
_BYTE *__cdecl Door_reverse_sounds(_BYTE *a1);
int __cdecl DoorSetSounds(_BYTE *a1);
int __cdecl Use_Static(int a1);
__int16 __cdecl Static_Pain(int a1);
int __cdecl SP_func_leaky(int a1);
__int16 __cdecl SP_func_static(int a1);
int __cdecl SP_func_rotating(int a1);
int __cdecl SP_func_bobbing(int a1);
char __cdecl use_trigger_use(int a1, int a2);
int GScr_LoadConsts();
int GScr_LoadGameTypeScript();
int GScr_LoadScripts();
int __cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4);
int sub_599F8();
int sub_59ACC();
int __cdecl sub_59BAC(unsigned int a1);
int __cdecl sub_59CC4(unsigned int a1);
int __cdecl sub_59EB8(unsigned int a1);
int __cdecl sub_5A0E4(unsigned int a1);
int __cdecl G_GetHintStringIndex(int, char *s1); // idb
int sub_5A2D0();
int sub_5A4F4();
int sub_5A5D8();
int *sub_5A6AC();
int sub_5A750();
int sub_5A834();
int sub_5A92C();
int sub_5AA08();
int sub_5AAE4();
int sub_5ABC4();
int sub_5ADC4();
int sub_5AEA4();
int sub_5AF70();
int sub_5B054();
int sub_5B148();
int sub_5B280();
int sub_5B3C0();
__int16 sub_5B5A8();
__int16 sub_5B774();
int sub_5B900();
int sub_5B9DC();
int sub_5BA90();
int __cdecl sub_5BB44(unsigned int a1);
int __cdecl sub_5BD54(unsigned int a1);
int __cdecl sub_5BEDC(unsigned int a1);
int sub_5C098();
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2);
int __cdecl sub_5C1C0(char **a1);
int Scr_ParseGameTypeList();
int Scr_LoadLevel();
int GScr_FreeScripts();
int __cdecl Scr_SetOrigin(int a1);
int __cdecl Scr_SetAngles(int a1);
int __cdecl Scr_SetHealth(_DWORD *a1);
int __cdecl GScr_AllocString(int a1);
int __cdecl GScr_AddEntity(int *a1);
_DWORD *G_InitObjectives();
int __cdecl GScr_GetScriptMenuIndex(char *a1);
int __cdecl Scr_LocalizationError(int, char *format); // idb
int __cdecl GScr_GetStatusIconIndex(char *a1);
int __cdecl GScr_GetHeadIconIndex(char *a1);
int __cdecl Scr_GetGameTypeNameForScript(char *a1);
_BOOL4 __cdecl Scr_IsValidGameType(char *a1);
int Scr_LoadGameType();
int Scr_StartupGameType();
int __cdecl Scr_PlayerConnect(int *a1);
int __cdecl Scr_PlayerDisconnect(int *a1);
int __cdecl Scr_PlayerDamage(int *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7, int a8, int a9, int a10);
int __cdecl Scr_PlayerKilled(int *a1, int *a2, int *a3, int a4, unsigned int a5, int a6, int a7, int a8);
int __cdecl sub_5CC20(int a1);
void sub_5CC38();
void sub_5CC80();
int __cdecl Scr_MakeGameMessage(int a1, const char *a2);
int sub_5CD28();
int sub_5CD74();
int sub_5CDC0();
int sub_5CE70();
void sub_5CF34();
int sub_5CF3C();
int sub_5CF8C();
int sub_5CFF4();
int sub_5D034();
int sub_5D05C();
int sub_5D088();
unsigned int sub_5D0A0();
int sub_5D0DC();
int sub_5D164();
int sub_5D1BC();
int sub_5D1FC();
int sub_5D268();
int __cdecl sub_5D334(unsigned int a1);
int __cdecl sub_5D3EC(unsigned int a1);
int __cdecl sub_5D430(unsigned int a1);
int __cdecl sub_5D48C(unsigned int a1);
int __cdecl sub_5D514(unsigned int a1);
void __cdecl sub_5D594(unsigned int a1);
int __cdecl sub_5D5D0(unsigned int a1);
int __cdecl sub_5D6B0(unsigned int a1);
int __cdecl sub_5D710(unsigned int a1);
int __cdecl sub_5D774(unsigned int a1);
int *__cdecl sub_5D7F4(unsigned int a1);
int *__cdecl sub_5D848(unsigned int a1);
int __cdecl sub_5D89C(unsigned int a1);
int __cdecl sub_5D910(unsigned int a1);
int __cdecl sub_5D980(unsigned int a1);
int *__cdecl sub_5D9D8(unsigned int a1);
int __cdecl sub_5DA14(unsigned int a1);
int __cdecl sub_5DABC(unsigned int a1);
int __cdecl sub_5DB24(unsigned int a1);
int __cdecl sub_5DBC0(unsigned int a1);
int *__cdecl ScrCmd_Show(unsigned int a1);
int *__cdecl ScrCmd_Hide(unsigned int a1);
int __cdecl sub_5DCEC(unsigned int a1);
int __cdecl sub_5DD58(unsigned int a1);
int __cdecl sub_5DE50(unsigned int a1);
int __cdecl GScr_EnableGrenadeTouchDamage(unsigned int a1);
int __cdecl GScr_DisableGrenadeTouchDamage(unsigned int a1);
int *__cdecl GScr_EnableGrenadeBounce(unsigned int a1);
int *__cdecl GScr_DisableGrenadeBounce(unsigned int a1);
_DWORD *__cdecl sub_5DFCC(_DWORD *a1);
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2);
int sub_5E058();
int sub_5E128();
int sub_5E230();
int sub_5E2C8();
int sub_5E38C();
int sub_5E440();
int sub_5E458();
int sub_5E470();
int sub_5E4BC();
int sub_5E4F0();
int sub_5E554();
int sub_5E5DC();
int sub_5E618();
int sub_5E654();
int sub_5E6D0();
int sub_5E768();
int sub_5E804();
int sub_5E848();
int sub_5E890();
int sub_5E8D8();
int sub_5E920();
int sub_5E960();
int sub_5E9D4();
int sub_5EA28();
int sub_5EA70();
int sub_5EAA8();
int sub_5EAE4();
int sub_5EB20();
int sub_5EB5C();
int sub_5EB8C();
int sub_5EC40();
int sub_5ECB8();
int sub_5ECF0();
void sub_5ED28();
int sub_5EDA8();
char *sub_5EE00();
int sub_5EE40();
int sub_5EEF4();
int sub_5EF6C();
int sub_5EF88();
int sub_5EFD4();
int sub_5F030();
int sub_5F064();
int sub_5F0F0();
int sub_5F134();
int sub_5F18C();
int sub_5F208();
int sub_5F258();
int GScr_GetNumParts();
int GScr_GetPartName();
float *sub_5F3D8();
int __cdecl sub_5F468(unsigned int a1);
int __cdecl sub_5F574(unsigned int a1);
int sub_5F618();
int sub_5F684();
int *sub_5F6E8();
int sub_5F704();
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2);
int __cdecl GScr_AddVector(int a1);
int Scr_LoadRead();
int __cdecl sub_5F7B0(int, int, float, float, float, int, int, int); // idb
void __cdecl Reached_ScriptMover(int a1);
void __cdecl sub_5FB38(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
void __cdecl sub_5FEB0(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
int __cdecl InitScriptMover(int a1);
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1);
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1);
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_RotateTo(unsigned int a1);
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1);
int __cdecl ScriptEnt_GetMethod(char **a1);
int __cdecl SP_script_brushmodel(int a1);
int __cdecl SP_script_model(int a1);
int __cdecl SP_script_origin(int a1);
__int16 __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3);
int __cdecl ScriptEntCmd_MoveX(unsigned int a1);
int __cdecl ScriptEntCmd_MoveY(unsigned int a1);
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1);
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1);
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1);
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1);
int __cdecl ScriptEntCmd_Solid(unsigned int a1);
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1);
int __cdecl G_SpawnString(char *s1, int, int); // idb
int __cdecl sub_61400(int, char *s, int); // idb
int G_CallSpawn();
_DWORD __cdecl G_CallSpawnEntity(_DWORD); // weak
int Scr_GetEnt();
int Scr_GetEntArray();
int G_ParseSpawnVars();
int SP_worldspawn();
int __cdecl Scr_AddEntity(int *a1);
int *__cdecl Scr_GetEntity(int a1);
int __cdecl Scr_ExecEntThread(int *a1, int a2, int a3);
int __cdecl Scr_AddExecEntThread(int *a1, int a2, int a3);
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3);
int __cdecl Scr_FreeEntityConstStrings(int a1);
int __cdecl Scr_FreeEntity(int *a1);
int __cdecl GScr_SetDynamicEntityField(int *a1, unsigned __int16 a2);
int __cdecl Scr_FreeHudElem(int a1);
int __cdecl Scr_AddHudElem(int a1);
int *__cdecl Scr_GetHudElem(int a1);
int __cdecl G_SpawnFloat(char *s1, int, int); // idb
int __cdecl G_SpawnInt(char *s1, int, int); // idb
int __cdecl G_SpawnVector(char *s1, int, int); // idb
char __cdecl G_DuplicateEntityFields(int a1, int a2);
int __cdecl G_DuplicateScriptFields(int *a1, int *a2);
int G_SpawnEntitiesFromString();
int __cdecl G_NewString(_BYTE *a1);
void GScr_AddFieldsForEntity();
int GScr_AddFieldsForRadiant();
int __cdecl Scr_GetGenericField(int a1, int a2, int a3);
void __cdecl Scr_SetGenericField(int a1, int a2, int a3);
int sub_6262C();
void __cdecl Scr_SetEntityField(int a1, int a2);
void __cdecl Scr_SetObjectField(int a1, int a2, int a3);
int __cdecl Scr_GetEntityField(int a1, int a2);
int __cdecl Scr_GetObjectField(int a1, int a2, int a3);
int G_SpawnGEntityFromSpawnVars();
char *__cdecl G_AddSpawnVarToken(void *src);
int __cdecl sub_62A90(const char *a1, _DWORD *a2);
int __cdecl G_FilterPacket(char *a1);
int __cdecl sub_62C10(const char *a1);
int Svcmd_RemoveIP_f();
void Svcmd_EntityList_f();
int __cdecl ClientForString(char *nptr); // idb
int ConsoleCommand();
char *G_ProcessIPBans();
int Svcmd_AddIP_f();
int __cdecl trap_Printf(int a1);
int __cdecl trap_Error(int a1);
int __cdecl trap_Error_Localized(int a1);
int trap_Milliseconds();
int trap_Argc();
int __cdecl trap_Argv(int a1, int a2, int a3);
int __cdecl trap_FS_FOpenFile(int a1, int a2, int a3);
int __cdecl trap_FS_Read(int a1, int a2, int a3);
int __cdecl trap_FS_Write(int a1, int a2, int a3);
int __cdecl trap_FS_Rename(int a1, int a2);
int __cdecl trap_FS_FCloseFile(int a1);
int __cdecl trap_FS_GetFileList(int a1, int a2, int a3);
int __cdecl trap_SendConsoleCommand(int a1, int a2);
int __cdecl trap_Cvar_Register(int a1, int a2, int a3);
int __cdecl trap_Cvar_Update(int a1);
int __cdecl trap_Cvar_Set(int a1, int a2);
int __cdecl trap_Cvar_VariableIntegerValue(int a1);
long double __cdecl trap_Cvar_VariableValue(int a1);
int __cdecl trap_Cvar_VariableStringBuffer(int a1, int a2, int a3);
int __cdecl trap_LocateGameData(int a1, int a2, int a3);
int __cdecl trap_DropClient(int a1, int a2);
int __cdecl trap_SendServerCommand(int a1, int a2, int a3);
int __cdecl trap_SetConfigstring(int a1, int a2);
int __cdecl trap_GetConfigstring(int a1, int a2, int a3);
int __cdecl trap_GetConfigstringConst(int a1);
int __cdecl trap_GetUserinfo(int a1, int a2, int a3);
int __cdecl trap_SetUserinfo(int a1, int a2);
int __cdecl trap_GetServerinfo(int a1, int a2);
int __cdecl trap_SetBrushModel(int a1);
int __cdecl trap_Trace(int a1, int a2, int a3);
int __cdecl trap_TraceCapsule(int a1, int a2, int a3);
int __cdecl trap_SightTrace(int a1, int a2, int a3);
int __cdecl trap_SightTraceCapsule(int a1, int a2, int a3);
int __cdecl trap_SightTraceToEntity(int a1, int a2, int a3);
int __cdecl trap_CM_BoxTrace(int a1, int a2, int a3);
int __cdecl trap_CM_CapsuleTrace(int a1, int a2, int a3);
int __cdecl trap_CM_BoxSightTrace(int a1, int a2, int a3);
int __cdecl trap_CM_CapsuleSightTrace(int a1, int a2, int a3);
int __cdecl trap_LocationalTrace(int a1, int a2, int a3);
int __cdecl trap_PointContents(int, int, int); // weak
int __cdecl trap_InPVS(int a1, int a2);
int __cdecl trap_InPVSIgnorePortals(int a1, int a2);
int __cdecl trap_InSnapshot(int a1, int a2);
int __cdecl trap_AdjustAreaPortalState(int a1, int a2);
int __cdecl trap_AreasConnected(int a1, int a2);
int __cdecl trap_LinkEntity(int a1);
int __cdecl trap_UnlinkEntity(int a1);
int __cdecl trap_EntitiesInBox(int a1, int a2, int a3);
int __cdecl trap_EntityContact(int a1, int a2, int a3);
int __cdecl trap_EntityContactCapsule(int a1, int a2, int a3);
int __cdecl trap_GetUsercmd(int a1, int a2);
int __cdecl trap_GetEntityToken(int a1, int a2);
int __cdecl trap_Com_SoundAliasString(int a1);
int __cdecl trap_Com_PickSoundAlias(int a1);
int __cdecl trap_Com_SoundAliasIndex(int a1);
int trap_AddTestClient();
int __cdecl trap_GetArchivedPlayerState(int a1, int a2, int a3);
int __cdecl trap_SurfaceTypeFromName(int a1);
int __cdecl trap_SurfaceTypeToName(int a1);
int __cdecl trap_SnapVector(int a1);
int __cdecl trap_AddDebugString(int a1, int a2, int a3);
int __cdecl trap_AddDebugLine(int a1, int a2, int a3);
int __cdecl trap_SetArchive(int a1);
int __cdecl trap_Z_MallocInternal(int a1);
int __cdecl trap_Z_FreeInternal(int a1);
int __cdecl trap_XAnimCreateTree(int a1);
int __cdecl trap_XAnimCreateSmallTree(int a1);
int __cdecl trap_XAnimFreeSmallTree(int a1);
int __cdecl trap_XModelExists(int a1);
int __cdecl trap_XModelGet(int a1);
int __cdecl trap_DObjCreate(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_SafeDObjFree(int a1, int a2);
int __cdecl trap_DObjExists(_DWORD *a1);
int __cdecl trap_XAnimGetAnims(int a1);
// _DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2);
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearTree(int a1);
int __cdecl trap_XAnimHasTime(unsigned int a1);
int __cdecl trap_XAnimIsPrimitive(unsigned int a1);
int __cdecl trap_XAnimGetLength(int a1, unsigned __int16 a2);
long double __cdecl trap_XAnimGetLengthSeconds(unsigned int a1);
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimCalcAbsDelta(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimCalcDelta(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimGetRelDelta(unsigned int a1, int a2);
int __cdecl trap_XAnimGetAbsDelta(unsigned int a1, int a2);
int __cdecl trap_XAnimIsLooped(unsigned int a1);
int __cdecl trap_XAnimNotetrackExists(unsigned int a1, unsigned __int16 a2);
long double __cdecl trap_XAnimGetTime(int a1, unsigned __int16 a2);
long double __cdecl trap_XAnimGetWeight(int a1, unsigned __int16 a2);
int __cdecl trap_DObjDumpInfo(_DWORD *a1);
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1, int a2);
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1, int a2);
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3);
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2);
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1, int a2, int a3);
int __cdecl trap_DObjCalcAnim(_DWORD *a1, int a2);
int __cdecl trap_DObjCalcSkel(_DWORD *a1, int a2);
int __cdecl trap_XAnimLoadAnimTree(int a1);
int __cdecl trap_XAnimSaveAnimTree(int a1);
int __cdecl trap_XAnimCloneAnimTree(int a1, int a2);
int __cdecl trap_DObjNumBones(_DWORD *a1);
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1, int a2);
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1);
int __cdecl trap_DObjDisplayAnim(_DWORD *a1);
int __cdecl trap_XAnimHasFinished(int a1, unsigned __int16 a2);
int __cdecl trap_XAnimGetNumChildren(unsigned int a1);
// _DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, unsigned int a2, int a3);
int __cdecl trap_XModelNumBones(int a1);
int __cdecl trap_XModelGetBoneNames(int a1);
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1);
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1, int a2, int a3);
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1, int a2, int a3);
int __cdecl trap_XAnimGetAnimName(unsigned int a1);
int __cdecl trap_DObjGetTree(_DWORD *a1);
int __cdecl trap_XAnimGetAnimTreeSize(int a1);
int __cdecl trap_XModelDebugBoxes(_DWORD *a1);
int __cdecl trap_GetWeaponInfoMemory(int a1, int a2);
int __cdecl trap_FreeWeaponInfoMemory(int a1);
int trap_FreeClientScriptPers();
int __cdecl trap_Hunk_AllocInternal(int a1);
int __cdecl trap_Hunk_AllocLowInternal(int a1);
int __cdecl trap_Hunk_AllocAlignInternal(int a1, int a2);
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1, int a2);
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1);
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1);
int (__stdcall *__cdecl dllEntry(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD)))(_DWORD, _DWORD, _DWORD, _DWORD);
int __cdecl PASSFLOAT(int a1);
int __cdecl trap_RealTime(int a1);
int trap_ResetEntityParsePoint();
void target_location_linkup();
int __cdecl SP_target_location(int a1);
int __cdecl Team_GetLocationMsg(int, char *s, size_t maxlen); // idb
int __cdecl TeamplayInfoMessage(int a1);
_BOOL4 __cdecl OnSameTeam(int a1, int a2);
int __cdecl Team_GetLocation(float *a1);
int CheckTeamStatus();
int __cdecl SP_trigger_multiple(int a1);
void __cdecl hurt_touch(int a1, int a2);
void __cdecl SP_trigger_hurt(int a1);
int __cdecl Respond_trigger_damage(int a1, int a2);
void __cdecl Activate_trigger_damage(int a1, int *a2, int a3, int a4);
int __cdecl SP_trigger_damage(int a1);
void __cdecl G_CheckHitTriggerDamage(int *a1, float *a2, float *a3, int a4, int a5);
void __cdecl G_GrenadeTouchTriggerDamage(int *a1, float *a2, float *a3, int a4, int a5);
int __cdecl G_Trigger(int *a1, int *a2);
int __cdecl InitTrigger(int a1);
int __cdecl InitSentientTrigger(int a1);
int __cdecl multi_wait(int a1);
int __cdecl multi_trigger(int a1, int a2);
int __cdecl Use_Multi(int a1, int a2, int a3);
int __cdecl Touch_Multi(int a1, int *a2);
unsigned __int16 __cdecl hurt_think(void *s);
__int16 __cdecl hurt_use(int a1);
int __cdecl SP_trigger_once(int a1);
void __cdecl Use_trigger_damage(int a1, int *a2);
void __cdecl Pain_trigger_damage(int a1, int *a2, int a3, int a4, int a5);
void __cdecl Die_trigger_damage(int a1, int a2, int *a3, int a4, int a5);
int __cdecl explosive_indicator_think(_DWORD *a1);
int __cdecl SP_trigger_lookat(int a1);
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl G_ShaderIndex(char *s2); // idb
int __cdecl G_EffectIndex(char *s2); // idb
int __cdecl G_DObjUpdate(int a1);
int __cdecl G_EntAttach(int, char *s2, int); // idb
int __cdecl sub_662E0(int a1, _DWORD *a2, _BYTE *a3);
float *__cdecl G_CalcTagAxis(int a1, int a2);
__int16 __cdecl G_SetFixedLink(int a1, int a2);
int __cdecl G_PickTarget(unsigned __int16 a1);
int G_Spawn();
void *__cdecl G_FreeEntity(void *s);
void __cdecl G_KillBox(int a1);
int __cdecl G_AnimScriptSound(int, char *s2); // idb
int __cdecl G_FindConfigstringIndex(char *s2, int, int, int, int); // idb
int __cdecl G_ModelIndex(char *s2); // idb
int __cdecl G_ModelName(int a1);
int __cdecl G_TagIndex(char *s2); // idb
int __cdecl G_SetModel(int, char *s2); // idb
int __cdecl G_SafeDObjFree(int *a1);
int __cdecl G_DObjUpdateServerTime(_DWORD *a1, int a2);
int __cdecl G_DObjSetLocalTag(_DWORD *a1, int a2, int a3, float *a4, float *a5);
int __cdecl G_DObjSetControlTagAngles(_DWORD *a1, int a2, int a3, float *a4);
int __cdecl G_DObjCalcPose(_DWORD *a1);
int __cdecl G_DObjCalcBone(_DWORD *a1, int a2);
int __cdecl G_DObjGetLocalTagMatrix(_DWORD *a1, int a2);
int __cdecl G_DObjGetWorldTagMatrix(int a1, int a2, int a3);
int __cdecl G_ShellShockIndex(char *s2); // idb
int __cdecl G_SoundAliasIndex(char *s2); // idb
int *__cdecl G_Find(int a1, int a2, __int16 a3);
int *__cdecl G_FindStr(int a1, int a2, char *a3);
unsigned __int16 __cdecl G_SetMovedir(float *a1, float *a2);
int __cdecl G_InitGentity(int a1);
int *G_SpawnPlayerClone();
_DWORD *__cdecl G_TempEntity(float *a1, int a2);
int __cdecl G_PlaySoundAliasAtPoint(float *a1, int a2);
int __cdecl G_PlaySoundAlias(_DWORD *a1, int a2);
char *__cdecl vtos(float *a1);
int __cdecl G_AddPredictableEvent(int a1, int a2, unsigned __int8 a3);
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3);
int __cdecl G_SetOrigin(int a1, float *a2);
int __cdecl G_SetAngle(int a1, float *a2);
_BOOL4 __cdecl infront(float *a1, float *a2);
int __cdecl G_SetConstString(_WORD *a1, int a2);
int __cdecl G_EntDetach(int, char *s2, int); // idb
int __cdecl G_EntDetachAll(int a1);
int __cdecl G_EntLinkTo(int a1, _DWORD *a2, _BYTE *a3);
int __cdecl G_EntLinkToWithOffset(int a1, _DWORD *a2, _BYTE *a3, float *a4, float *a5);
void __cdecl G_EntUnlink(int a1);
_BOOL4 __cdecl G_EntIsLinkedTo(int a1, int a2);
void __cdecl G_UpdateTagInfo(int a1, int a2);
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2);
float *__cdecl G_CalcTagParentAxis(int a1, float *a2);
float *__cdecl G_CalcTagParentRelAxis(int a1, float *a2);
int __cdecl G_GeneralLink(int a1);
int __cdecl Think_GeneralLink(int a1);
int __cdecl G_GetGameId(int *a1);
char *__cdecl vtosf(float *a1);
// int *__usercall G_FreeEntityRefs@<eax>(int *result@<eax>, int *a2);
int DebugLine();
void __cdecl Weapon_Melee(int *a1, float *a2);
void __cdecl Bullet_Fire_Extended(int a1, int *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8);
int __cdecl Weapon_RocketLauncher_Fire(int, float, int); // idb
void __cdecl FireWeapon(int a1);
void __cdecl Bullet_Fire(int a1, float a2, int a3, int a4, int a5);
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2);
int __cdecl CalcMuzzlePoint(int a1, float *a2);
__int16 __cdecl SnapVectorTowards(int a1, int a2);
float *__cdecl weapon_grenadelauncher_fire(_DWORD *a1, int a2, int a3);
int __cdecl CalcMuzzlePoints(int a1, float *a2);
void __cdecl FireWeaponMelee(int a1);
float *__cdecl Bullet_Endpos(float a1, int a2, int a3);
int Com_ScriptError(char *format, ...); // idb
int Com_ScriptWarning(char *format, ...); // idb
int __cdecl Com_Compress(_BYTE *a1);
char *__cdecl sub_69834(char **a1, int a2);
char *__cdecl sub_6990C(char **a1, int a2);
int __cdecl Com_MatchToken(int, char *s2, int); // idb
char *__cdecl Com_BeginParseSession(char *src);
char *Com_EndParseSession();
void Com_ResetParseSessions();
char *__cdecl Com_SetSpaceDelimited(int a1);
char *__cdecl Com_SetCSV(int a1);
char *__cdecl Com_SetParseNegativeNumbers(int a1);
int Com_GetCurrentParseLine();
char *__cdecl Com_Parse(char **a1);
char *__cdecl Com_ParseOnLine(char **a1);
char *__cdecl Com_ParseRestOfLine(char **a1);
int Com_GetLastTokenPos();
int Com_UngetToken();
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2);
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2);
int __cdecl Com_SkipBracedSection(char **a1, int a2);
void __cdecl Com_SkipRestOfLine(_BYTE **a1);
long double __cdecl Com_ParseFloat(char **a1);
int __cdecl Com_ParseInt(char **a1);
int __cdecl Com_Parse1DMatrix(char **a1, int a2, int a3);
int __cdecl Com_Parse2DMatrix(char **a1, int a2, int a3, int a4);
int __cdecl Com_Parse3DMatrix(char **a1, int a2, int a3, int a4, int a5);
int Com_sprintf(char *s, size_t maxlen, char *format, ...); // idb
char *va(char *format, ...);
char *__cdecl Info_ValueForKey(_BYTE *a1, char *a2);
char __cdecl Info_RemoveKey(char *dest, char *s);
char __cdecl Info_RemoveKey_Big(char *dest, char *s);
char __cdecl Info_SetValueForKey(char *dest, char *s, int a3);
char __cdecl Info_SetValueForKey_Big(char *dest, char *s, int a3);
int __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, _BYTE *a4, int a5, int (__cdecl *a6)(int, char *, _DWORD), void (__cdecl *a7)(int, char *));
long double __cdecl Com_Clamp(float a1, float a2, float a3);
_BYTE *__cdecl Com_SkipPath(_BYTE *a1);
char __cdecl Com_StripExtension(char *a1, _BYTE *a2);
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, int a3);
char *__cdecl Com_StripFilename(char *src, char *dest);
int __cdecl Com_BitCheck(int a1, int a2);
int __cdecl Com_BitSet(int a1, int a2);
int __cdecl Com_BitClear(int a1, int a2);
_BOOL4 __cdecl Q_isprint(int a1);
_BOOL4 __cdecl Q_islower(int a1);
_BOOL4 __cdecl Q_isupper(int a1);
_BOOL4 __cdecl Q_isalpha(int a1);
_BOOL4 __cdecl Q_isnumeric(int a1);
_BOOL4 __cdecl Q_isalphanumeric(int a1);
_BOOL4 __cdecl Q_isforfilename(int a1);
int __cdecl Q_stricmp(char *a1, char *a2);
int __cdecl Q_strncmp(char *a1, char *a2, int a3);
int __cdecl Q_stricmpn(char *a1, char *a2, int a3);
_BYTE *__cdecl Q_strlwr(_BYTE *a1);
_BYTE *__cdecl Q_strupr(_BYTE *a1);
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2);
char *__cdecl Q_strncpyz(char *dest, char *src, int a3);
char *__cdecl Q_strcat(int a1, int a2, char *src);
char *__cdecl Q_CleanStr(char *a1);
int __cdecl Q_CleanCharacter(char a1);
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3);
int __cdecl Q_strcasecmp(char *a1, char *a2);
int __cdecl BigShort(__int16 a1);
int __cdecl BigLong(int a1);
// _DWORD *__userpurge BigLong64@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge LittleLong64@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl BigFloat(float); // idb
int Swap_Init();
float *__cdecl tv(float a1, float a2, float a3);
_BOOL4 __cdecl Info_Validate(char *s);
char __cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3);
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3);
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3);
long double __cdecl GetLeanFraction(float a1);
long double __cdecl UnGetLeanFraction(float a1);
unsigned __int16 __cdecl AddLeanToPosition(int a1, float a2, float a3, float a4, float a5);
int __cdecl ShortSwap(__int16 a1);
int __cdecl ShortNoSwap(__int16 a1);
int __cdecl LongSwap(unsigned int a1);
int __cdecl LongNoSwap(int a1);
// unsigned int *__userpurge Long64Swap@<eax>(int a1@<edi>, int a2@<esi>, unsigned int *a3, unsigned int a4, unsigned int a5);
// _DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3);
// long double __usercall FloatSwap@<st0>(int a1@<ebx>, unsigned int a2);
long double __cdecl FloatNoSwap(float a1);
int __cdecl Scr_GetBool(int a1);
int __cdecl Scr_GetInt(int a1);
// _DWORD *__userpurge Scr_GetAnim@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge Scr_GetAnimTree@<eax>(_DWORD *a1, int a2);
double __cdecl Scr_GetFloat(_DWORD); // weak
int __cdecl Scr_GetString(int a1);
int __cdecl Scr_GetConstString(int a1);
int __cdecl Scr_GetDebugString(int a1);
int __cdecl Scr_GetIString(int a1);
int __cdecl Scr_GetConstIString(int a1);
int __cdecl Scr_GetVector(int a1, int a2);
int __cdecl Scr_GetFunc(int a1);
int __cdecl Scr_GetEntityNum(int a1, int a2);
int __cdecl Scr_GetType(int a1);
int __cdecl Scr_GetPointerType(int a1);
int Scr_GetNumParam();
int __cdecl Scr_AddBool(int a1);
int __cdecl Scr_AddInt(int a1);
int __cdecl Scr_AddFloat(float); // idb
int __cdecl Scr_AddAnim(int a1);
int Scr_AddUndefined();
int __cdecl Scr_AddEntityNum(int a1, int a2);
int Scr_AddStruct();
int __cdecl Scr_AddObject(unsigned __int16 a1);
int __cdecl Scr_AddString(int a1);
int __cdecl Scr_AddIString(int a1);
int __cdecl Scr_AddConstString(unsigned __int16 a1);
int __cdecl Scr_AddVector(int a1);
int Scr_AddArray();
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1);
int Scr_MakeArray();
int __cdecl Scr_AddExecThread(int a1, int a2);
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_ExecThread(int a1, int a2);
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1);
int __cdecl Scr_Error(int a1);
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2);
int __cdecl Scr_ParamError(int a1, int a2);
int __cdecl Scr_ObjectError(int a1);
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3);
int __cdecl Scr_FreeEntityNum(int a1, int a2);
int __cdecl Scr_GetEntityId(int a1, int a2);
int __cdecl Scr_SetClassMap(int a1, int a2);
int Scr_RemoveClassMap();
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3);
int __cdecl Scr_AddFields(int a1, int a2);
int __cdecl Scr_FindField(int a1, int a2);
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2);
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3);
int __cdecl Scr_Init(int a1, int a2);
int Scr_Shutdown();
int Scr_Abort();
int __cdecl Scr_SetLoading(int a1);
int __cdecl Scr_InitSystem(int a1, int a2);
int Scr_AllocGameVariable();
int __cdecl Scr_GetChecksum(int a1);
int Scr_HasSourceFiles();
int __cdecl Scr_SaveSource(int a1);
int __cdecl Scr_LoadSource(int a1);
int __cdecl Scr_SkipSource(int a1);
int __cdecl Scr_SavePre(int a1);
int __cdecl Scr_SavePost(int a1);
int Scr_SaveShutdown();
int __cdecl Scr_LoadPre(int a1, int a2);
int Scr_LoadShutdown();
int __cdecl Scr_SetString(int a1, unsigned __int16 a2);
int __cdecl Scr_AllocString(int a1, int a2);
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4);
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3);
int __cdecl SL_ConvertToString(unsigned __int16 a1);
int __cdecl SL_GetString(int a1, unsigned __int8 a2);
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2);
int __cdecl SL_FindLowercaseString(int a1);
int __cdecl Scr_CreateCanonicalFilename(int a1);
int __cdecl Scr_SetTime(int a1);
int Scr_RunCurrentThreads();
int Scr_ResetTimeout();
int __cdecl Scr_LoadScript(int a1);
// _DWORD *__userpurge Scr_FindAnimTree@<eax>(_DWORD *a1, int a2);
int __cdecl Scr_FindAnim(int a1, int a2, int a3);
int __cdecl Scr_GetFunctionHandle(int a1, int a2);
int __cdecl Scr_FreeThread(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1);
int Scr_BeginLoadScripts();
int Scr_BeginLoadAnimTrees();
int Scr_EndLoadScripts();
int Scr_EndLoadAnimTrees();
int __cdecl Scr_PrecacheAnimTrees(int a1);
int __cdecl Scr_FreeScripts(unsigned __int8 a1);
int __cdecl Scr_FreeGameVariable(int a1);
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1);
int __cdecl Scr_IsSystemActive(unsigned __int8 a1);
int __cdecl Scr_GetAnimsIndex(int a1);
int __cdecl Scr_GetAnims(int a1);
int __cdecl MT_Alloc(int a1, int a2);
int __cdecl MT_Free(int a1, int a2);
int *__cdecl Scr_FarHook(const void *a1);
void sub_6C740();
void __noreturn _default_terminate(); // weak
void sub_6C75C();
int _terminate();
void sub_6C784();
int __cdecl _throw_type_match(char *s1, char *s2, int); // idb
void _empty();
void sub_6C7C4();
_DWORD *sub_6C7C8();
void sub_6C814();
int _get_eh_context();
void sub_6C838();
int _get_eh_info();
void sub_6C860();
int *sub_6C864();
void sub_6C88C();
int *sub_6C890();
void sub_6C8E8();
int _get_dynamic_handler_chain();
void sub_6C910();
int _sjthrow();
void sub_6CA20();
void _sjpopnthrow();
void sub_6CB18();
_BOOL4 __cdecl _eh_rtime_match(int a1);
int __cdecl _get_eh_table_version(int a1);
int __cdecl _get_eh_table_language(int a1);
int __cdecl sub_6CB94(unsigned int a1, _DWORD *a2);
void sub_6CC28();
unsigned int __cdecl sub_6CC2C(int a1, int a2, _DWORD *a3, int a4, _DWORD *a5);
void sub_6CCFC();
int __cdecl sub_6CD00(int a1, _DWORD *a2);
void sub_6CD4C();
void *__cdecl sub_6CD50(int a1, _DWORD *a2, _DWORD *a3);
void sub_6CDB4();
_DWORD *__cdecl sub_6CDB8(int a1, _DWORD *a2, int a3);
void _unwinding_cleanup();
void sub_6CE30();
unsigned int __cdecl sub_6CE34(unsigned int *a1, int a2, _DWORD *a3, _DWORD *a4);
void sub_6D194();
unsigned int *__cdecl _throw(char a1);
void sub_6D254();
unsigned int *__cdecl _rethrow(unsigned int a1);
char *__cdecl sub_6D320(char *a1, int *a2);
char *__cdecl sub_6D36C(char *a1, _DWORD *a2);
_DWORD *__cdecl sub_6D3B4(_DWORD *a1, _DWORD *a2);
void sub_6D434();
int __cdecl sub_6D438(int *a1, int a2);
int __cdecl sub_6D628(_DWORD *a1);
unsigned int __cdecl sub_6D658(_DWORD *a1, _DWORD *a2, unsigned int *a3, unsigned int *a4);
void sub_6D6C4();
unsigned int __cdecl sub_6D6C8(int a1);
void sub_6D808();
int __cdecl sub_6D80C(unsigned int a1);
void sub_6D8A0();
char *__cdecl sub_6D8A4(int a1, int a2);
void sub_6D9F0();
char *__cdecl sub_6D9F4(unsigned __int8 *a1, int a2, int a3, _DWORD *a4);
void sub_6DDA0();
int __cdecl _register_frame_info(int a1, _DWORD *a2);
void sub_6DDEC();
int __cdecl _register_frame(int a1);
void sub_6DE24();
int __cdecl _register_frame_info_table(int a1, _DWORD *a2);
void sub_6DE6C();
int __cdecl _register_frame_table(int a1);
void sub_6DEA4();
int __cdecl _deregister_frame_info(int a1);
void sub_6DF0C();
void __cdecl _deregister_frame(int a1);
void sub_6DF40();
int *__cdecl _frame_state_for(unsigned int a1, int *a2);
int __cdecl sub_6E0C4(int *a1, _DWORD *a2);
void sub_6E1C0();
int sub_6E1C4();
void sub_6E1F8();
int term_proc();
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strcpy(char *dest, const char *src);
// void _bzero(void *s, size_t n);
// int _strtol_internal(const char *nptr, char **endptr, int base, int group);
// char *strstr(const char *haystack, const char *needle);
// int rand(void);
// int strcasecmp(const char *s1, const char *s2);
// int sprintf(char *s, const char *format, ...);
// char *strcat(char *dest, const char *src);
// int strncmp(const char *s1, const char *s2, size_t n);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double modf(double x, double *iptr);
// int strcmp(const char *s1, const char *s2);
// void *memcpy(void *dest, const void *src, size_t n);
// int sscanf(const char *s, const char *format, ...);
// char *strchr(const char *s, int c);
// double _strtod_internal(const char *nptr, char **endptr, int group);
// char *strncat(char *dest, const char *src, size_t n);
// void srand(unsigned int seed);
// void *memset(void *s, int c, size_t n);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strncpy(char *dest, const char *src, size_t n);

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
Elf32_Rel stru_14924[] = { { 293632u, 142338u } }; // weak
Elf32_Rel stru_1DA44[] = { { 400539u, 96513u } }; // weak
Elf32_Rel stru_1FA84 = { 429864u, 8u }; // weak
Elf32_Rel stru_20EAC = { 545688u, 8u }; // weak
Elf32_Rel stru_216BC = { 555008u, 8u }; // weak
_UNKNOWN loc_6C994; // weak
_UNKNOWN loc_6CAA0; // weak
_UNKNOWN loc_6D1EC; // weak
_UNKNOWN loc_6D240; // weak
_UNKNOWN loc_6D2B5; // weak
_UNKNOWN loc_6D305; // weak
const char byte_6E47D = '\x15'; // idb
const char byte_6E490 = '\x15'; // idb
const char byte_6E500 = '\x15'; // idb
char aNone[5] = "none"; // weak
const char byte_6E5C0 = '\x15'; // idb
const char byte_6E980 = '\x15'; // idb
const char byte_6EE20 = '\x15'; // idb
const char byte_6EE60 = '\x15'; // idb
const char byte_6F000 = '\x15'; // idb
const char byte_6FFC0 = '\x15'; // idb
const char byte_70000 = '\x15'; // idb
const char byte_70029 = '\x15'; // idb
const char byte_70060 = '\x15'; // idb
const char byte_700E0 = '\x15'; // idb
int bg_numItems = 70; // weak
float flt_70A40[] = {  0.0 }; // weak
float flt_70A44[] = {  0.0 }; // weak
float flt_70A48[] = {  1.0 }; // weak
char byte_71DC0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_71E00[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'c',
  'l',
  'a',
  's',
  's',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_71E40[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'l',
  'a',
  'y',
  ' ',
  'r',
  'e',
  't',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_71E80[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  'l',
  'o',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_71EC0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  't',
  'a',
  'n',
  'c',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
const char byte_71F00 = '\x15'; // idb
const char byte_71F2C = '\x15'; // idb
const char byte_71F60 = '\0'; // idb
const char aWeaponfile[] = "WEAPONFILE"; // idb
const char byte_71FA0 = '\x15'; // idb
const char byte_71FE0 = '\x15'; // idb
const char byte_72020 = '\x15'; // idb
const char byte_72060 = '\x15'; // idb
const char byte_720E0 = '\x15'; // idb
const char byte_72140 = '\x15'; // idb
const char byte_721C0 = '\x15'; // idb
const char byte_72220 = '\x15'; // idb
const char byte_72280 = '\x15'; // idb
const char byte_722E0 = '\x15'; // idb
const char byte_72320 = '\x15'; // idb
const char byte_72360 = '\x15'; // idb
const char byte_72400 = '\x15'; // idb
const char byte_72440 = '\x15'; // idb
const char byte_72460 = '\x15'; // idb
float vec3_origin =  0.0; // weak
_UNKNOWN unk_72E60; // weak
char *off_72ED4 = "name"; // weak
int dword_72ED8[] = { 8628 }; // weak
int dword_72EDC[] = { 2 }; // weak
int (__cdecl *funcs_41795)(int, int, int) = &sub_41810; // weak
int dword_72EE4[] = { 0 }; // weak
char *off_733DC = "giveweapon"; // weak
int (__cdecl *off_733E0)(int) = &PlayerCmd_giveWeapon; // weak
const char aEGameBadclient[21] = "e \"GAME_BADCLIENTSLOT"; // idb
const char aEGameClientnot_0[23] = "e \"GAME_CLIENTNOTACTIVE"; // idb
const char aEGameUsernoton[23] = "e \"GAME_USERNOTONSERVER"; // idb
const char aS_5[4] = "%s \""; // idb
const char byte_739AC = '\x15'; // idb
const char aS[3] = "%s("; // idb
__int16 aKlj[3] = { 107, 108, 106 }; // weak
_UNKNOWN unk_73A80; // weak
const char aE_0[3] = "e \""; // idb
_UNKNOWN unk_73C40; // weak
const char off_73CDD[] = { '%', 's', '\n', '\0' }; // idb
_UNKNOWN unk_73CFA; // weak
const char aGameVoteGamety[18] = "GAME_VOTE_GAMETYPE"; // idb
char aGameVoteMap[13] = "GAME_VOTE_MAP"; // weak
const char aGameVoteGamety_0[18] = "GAME_VOTE_GAMETYPE"; // idb
const char aGameVoteKick[14] = "GAME_VOTE_KICK"; // idb
const char byte_73E3B = '\x15'; // idb
const char aEGameCalledavo[19] = "e \"GAME_CALLEDAVOTE"; // idb
const char aE[3] = "e \""; // idb
const char aEGameUsage[13] = "e \"GAME_USAGE"; // idb
const char aLocdmgtable[] = "LOCDMGTABLE"; // idb
char byte_74140[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_74180[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'p',
  'p',
  'e',
  'a',
  'r',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'e',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_741C0[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'I',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'l',
  'o',
  'n',
  'g',
  ' ',
  'o',
  'f',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'a',
  'r',
  's',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
const char byte_74200 = '\x15'; // idb
int dword_74460[] = { 0 }; // weak
int dword_74464[] = { 1 }; // weak
char *off_744E0 = "x"; // weak
int dword_744E4[] = { 4 }; // weak
int dword_744E8[] = { 0 }; // weak
int dword_744EC[] = { 0 }; // weak
int dword_744F0[] = { 0 }; // weak
char *off_749B4 = "settext"; // weak
int (__cdecl *off_749B8)(int) = &sub_4C590; // weak
char aFGamePickupCli[28] = "f \"GAME_PICKUP_CLIPONLY_AMMO"; // weak
const char aFGamePickupAmm[19] = "f \"GAME_PICKUP_AMMO"; // idb
const char aFGamePickupHea[21] = "f \"GAME_PICKUP_HEALTH"; // idb
char aFGamePickupCan[32] = "f \"GAME_PICKUP_CANTCARRYMOREAMMO"; // weak
_UNKNOWN unk_7543E; // weak
const char aEGameServer[14] = "e \"GAME_SERVER"; // idb
const char off_756DF[] = { '%', 's', '\n', '\0' }; // idb
const char byte_75860 = '\x15'; // idb
const char byte_75960 = '\x15'; // idb
const char byte_759A0 = '\x15'; // idb
_UNKNOWN unk_759E4; // weak
const char byte_75A40 = '\x15'; // idb
_UNKNOWN unk_75BF3; // weak
_UNKNOWN unk_75C94; // weak
_UNKNOWN unk_75DA8; // weak
const char byte_75EA0 = '\x15'; // idb
_UNKNOWN unk_76629; // weak
const char off_76E2E[] = { '%', 's', '\n', '\0' }; // idb
_UNKNOWN unk_78B2C; // weak
char *off_78D40 = "moveto"; // weak
int (__cdecl *off_78D44)(int) = &ScriptEntCmd_MoveTo; // weak
char *off_78E68 = "classname"; // weak
int dword_78E6C[] = { 374 }; // weak
int dword_78E70[] = { 3 }; // weak
int (*off_78E74)() = &sub_6262C; // weak
_UNKNOWN unk_792F7; // weak
const char byte_79300 = '\x15'; // idb
const char aEGameServer_0[14] = "e \"GAME_SERVER"; // idb
const char byte_79904 = '\x15'; // idb
const char byte_79910 = '\x14'; // idb
_UNKNOWN unk_79940; // weak
_UNKNOWN unk_79BB9; // weak
const char byte_79D60 = '\x15'; // idb
const char byte_79DA0 = '\x15'; // idb
const char byte_79DC8 = '\x15'; // idb
const char byte_79E0B = '\x15'; // idb
const char off_79E3B[] = { ' ', '\0', '(', '\0' }; // idb
_UNKNOWN colorWhite; // weak
const char byte_7A025 = '\x15'; // idb
const char byte_7A060 = '\x15'; // idb
_UNKNOWN unk_7A08E; // weak
const char byte_7A0A0 = '\x15'; // idb
const char byte_7A0E0 = '\x15'; // idb
const char byte_7A120 = '\x15'; // idb
const char byte_7A160 = '\x15'; // idb
const char byte_7A1A0 = '\x15'; // idb
const char byte_7A1E0 = '\x15'; // idb
const char byte_7A220 = '\x15'; // idb
const char byte_7A260 = '\x15'; // idb
const char byte_7A2C0 = '\x15'; // idb
const char byte_7A308 = '\x15'; // idb
_UNKNOWN unk_7A390; // weak
int off_7B3A0[3] = { 581184, 0, 0 }; // weak
int dword_7B3A4 = 0; // weak
char *dest = &dword_0; // idb
char *off_7B3AC = "mp/playeranim.script"; // weak
int dword_7B3B0 = 0; // weak
int weaponStringsInited = 0; // weak
char *animStateStr = "RELAXED"; // weak
char *off_7B3E0 = "** UNUSED **"; // weak
char *off_7B478 = "PAIN"; // weak
char *animBodyPartsStr = "** UNUSED **"; // weak
char *off_7B5E0 = "WEAPONS"; // weak
int dword_7B630[] = { 0 }; // weak
int *off_7B634[2] = { &weaponStrings, &dword_0 }; // weak
int dword_7B638 = 0; // weak
int dword_7B640 = 1; // weak
int dword_7B650 = 1; // weak
int dword_7B658 = 1; // weak
int dword_7B660 = 1; // weak
int dword_7B668 = 1; // weak
int dword_7B670 = 1; // weak
char *off_7B678 = "defines"; // weak
void *pEventSingleClientList = &iSingleClientEvents; // weak
int bg_itemlist[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
int c_pmove = 0; // weak
int dword_7C730[] = { 0 }; // weak
float flt_7C734 =  60.0; // weak
int dword_7C738 = 0; // weak
_UNKNOWN unk_7C73C; // weak
int dword_7C79C[] = { 0 }; // weak
float flt_7C7A0 =  40.0; // weak
int dword_7C7A4 = 0; // weak
_UNKNOWN unk_7C7A8; // weak
int dword_7C808[] = { 0 }; // weak
float flt_7C80C =  40.0; // weak
int dword_7C810 = 0; // weak
_UNKNOWN unk_7C814; // weak
int dword_7C88C[] = { 0 }; // weak
float flt_7C890 =  40.0; // weak
int dword_7C894 = 0; // weak
_UNKNOWN unk_7C898; // weak
int dword_7C8B0[] = { 0 }; // weak
float flt_7C8B4 =  11.0; // weak
int dword_7C8B8 = 0; // weak
_UNKNOWN unk_7C8BC; // weak
void *off_7C910 = &unk_70F20; // weak
char *bg_szWeaponsFolder = "weapons/mp"; // weak
int dword_7C918 = 0; // weak
int dword_7C91C = 0; // weak
char *s2 = "bullet"; // idb
char *off_7C92C = "none"; // idb
char *off_7C940 = "none"; // idb
char *off_7C958 = "stand"; // idb
char *off_7C964 = "rifle"; // idb
char *off_7C984 = "grenade"; // idb
char *off_7C994 = "displayName"; // weak
int dword_7D534 = -1; // weak
int dword_7D538 = -1; // weak
float bytedirs[] = { -0.52573103 }; // weak
int dword_7DCD8 = -1985229329; // weak
float flt_7DCDC =  40.0; // weak
float flt_7DCE0 =  40.0; // weak
float flt_7DCE4 =  52.0; // weak
float playerMins[3] = { -15.0, -15.0,  0.0 }; // idb
float playerMaxs[3] = {  15.0,  15.0,  72.0 }; // idb
char *off_7DD00[7] =
{
  "GAME_GC_HOLDYOURPOSITION",
  "GAME_GC_HOLDTHISPOSITION",
  "GAME_GC_COMEHERE",
  "GAME_GC_COVERME",
  "GAME_GC_GUARDLOCATION",
  "GAME_GC_SEARCHDESTROY",
  "GAME_GC_REPORT"
}; // weak
char *off_7DD20[18] =
{
  "none",
  "helmet",
  "head",
  "neck",
  "torso_upper",
  "torso_lower",
  "right_arm_upper",
  "left_arm_upper",
  "right_arm_lower",
  "left_arm_lower",
  "right_hand",
  "left_hand",
  "right_leg_upper",
  "left_leg_upper",
  "right_leg_lower",
  "left_leg_lower",
  "right_foot",
  "left_foot"
}; // weak
char *modNames[34] =
{
  "MOD_UNKNOWN",
  "MOD_PISTOL_BULLET",
  "MOD_RIFLE_BULLET",
  "MOD_GRENADE",
  "MOD_GRENADE_SPLASH",
  "MOD_PROJECTILE",
  "MOD_PROJECTILE_SPLASH",
  "MOD_MELEE",
  "MOD_HEAD_SHOT",
  "MOD_MORTAR",
  "MOD_MORTAR_SPLASH",
  "MOD_KICKED",
  "MOD_GRABBER",
  "MOD_DYNAMITE",
  "MOD_DYNAMITE_SPLASH",
  "MOD_AIRSTRIKE",
  "MOD_WATER",
  "MOD_SLIME",
  "MOD_LAVA",
  "MOD_CRUSH",
  "MOD_TELEFRAG",
  "MOD_FALLING",
  "MOD_SUICIDE",
  "MOD_TRIGGER_HURT",
  "MOD_EXPLOSIVE",
  "default",
  "bigfixed",
  "smallfixed",
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
}; // weak
char *off_7DE04[9] =
{
  "default",
  "bigfixed",
  "smallfixed",
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
}; // weak
char *off_7DE10[6] = { "left", "center", "right", "top", "middle", "bottom" }; // weak
char *off_7DE1C[3] = { "top", "middle", "bottom" }; // weak
void *gameCvarTable = &g_cheats; // weak
int dword_7E4D0 = 71; // weak
void *hintStrings = &unk_75BF3; // weak
char *off_7E500[3] = { "entity", "hudelem", "print" }; // weak
char *functions = "print"; // weak
char *off_7EA00 = "attach"; // weak
int (__cdecl *off_7EA04)(int) = &sub_5D334; // weak
char *spawns = "info_null"; // weak
int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD) = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))0xFFFFFFFF; // weak
float flt_7EC14 =  0.0; // weak
float flt_7EC18 = -1.0; // weak
float flt_7EC1C =  0.0; // weak
float flt_7EC20 =  0.0; // weak
float flt_7EC24 =  0.0; // weak
float flt_7EC28 =  1.0; // weak
float flt_7EC2C =  0.0; // weak
float flt_7EC30 = -2.0; // weak
float flt_7EC34 =  0.0; // weak
float flt_7EC38 =  0.0; // weak
float flt_7EC3C =  0.0; // weak
float flt_7EC40 = -1.0; // weak
void *off_7EC60 = &unk_79D47; // weak
_UNKNOWN unk_7ECA0; // weak
char *off_83260 = &unk_7ECA0; // idb
int dword_83264 = 0; // weak
int dword_83268 = 0; // weak
int (*_terminate_func)(void) = &_default_terminate; // weak
int (*off_83270)(void) = &sub_6C864; // weak
_UNKNOWN unk_83278; // weak
_UNKNOWN unk_8B100; // weak
int dword_8DE34 = -1; // weak
_UNKNOWN unk_8DFA0; // weak
int dword_8DFC0[]; // weak
_UNKNOWN unk_8E000; // weak
int dword_90710; // weak
int dword_90720[]; // weak
int dword_90724[287]; // idb
int dword_90BA0[]; // weak
int dword_90BA4; // weak
int dword_91020; // weak
int dword_91024; // weak
int dword_91028; // weak
int dword_9102C; // weak
_BYTE byte_91040[42620]; // idb
int dword_9B6BC; // weak
int dword_9B6C0; // weak
int dword_9B6D0; // weak
int dword_9B6D4; // weak
int dword_A96E0[64]; // idb
int dword_A97E0[64]; // idb
int dword_A98E0; // weak
int dword_A9900[]; // weak
int dword_A9A00[]; // weak
int dword_A9B00; // weak
int dword_A9B20[64]; // idb
int dword_A9C20[64]; // idb
int dword_A9D20; // weak
int dword_A9D24; // weak
char nptr[1024]; // idb
__int16 word_AA140[]; // weak
int dword_AA180; // weak
_UNKNOWN unk_AA940; // weak
int dword_AA980; // weak
int dword_AA984; // weak
int dword_AA988; // weak
int dword_AA9A0[]; // weak
int dword_AA9A4[2002]; // idb
_UNKNOWN unk_AC8EC; // weak
int dword_AC9A0; // weak
int dword_AC9C0; // weak
_UNKNOWN unk_AC9E0; // weak
int dword_ACAE0; // weak
_UNKNOWN unk_ACB00; // weak
int dword_ACD00[256]; // idb
char byte_AD100; // weak
int dword_AD500; // weak
int dword_AD504; // weak
int dword_AD508; // weak
int dword_AD520; // weak
float flt_AD540[]; // weak
float flt_AD544[]; // weak
float flt_AD548[]; // weak
char s[31999]; // idb
char byte_B529F; // weak
_UNKNOWN unk_B52A0; // weak
_UNKNOWN unk_BCFA0; // weak
int (__stdcall *dword_C0FA0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_C0FA4; // weak
int (__stdcall *dword_C0FA8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_C0FAC; // weak
int (__stdcall *dword_C0FB0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FB4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FB8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_C0FBC; // weak
int (__stdcall *dword_C0FC0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FC4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FC8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FCC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FD0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FD4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FD8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FDC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FE0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FE4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FE8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FEC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FF0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FF4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C0FF8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C0FFC)(void); // weak
int (__stdcall *dword_C1000)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1004)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1008)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C100C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1010)(void); // weak
int (__stdcall *dword_C1014)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1018)(void); // weak
int (__stdcall *dword_C101C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1020)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1024)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1028)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C102C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1030)(void); // weak
int (__stdcall *dword_C1034)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1038)(void); // weak
int (*dword_C103C)(void); // weak
int (*dword_C1040)(void); // weak
int (*dword_C1044)(void); // weak
int (*dword_C1048)(void); // weak
int (__stdcall *dword_C104C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1050)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1054)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1058)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C105C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1060)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1064)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1068)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C106C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1070)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1074)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1078)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C107C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1080)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1084)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1088)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C108C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1090)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1094)(void); // weak
int (__stdcall *dword_C10A0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10A4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10A8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10AC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10B0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10B4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C10B8)(void); // weak
int (*dword_C10BC)(void); // weak
int (__stdcall *dword_C10C0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10C4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C10C8)(void); // weak
int (__stdcall *dword_C10CC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C10D0)(void); // weak
int (__stdcall *dword_C10D4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10D8)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10DC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10E0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C10E4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C10E8)(void); // weak
int (__stdcall *dword_C10F0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C10F4)(void); // weak
int (__stdcall *dword_C10FC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1100)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1104)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1108)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C110C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1110)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1114)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1118)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C111C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1120)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1124)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1128)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C112C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1130)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1134)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1138)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C113C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (*dword_C1140)(void); // weak
int (*dword_C1144)(void); // weak
int (__stdcall *dword_C1148)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C114C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1150)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__stdcall *dword_C1154)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int dword_C1158; // weak
int dword_C115C; // weak
int dword_C1160; // weak
int dword_C1164; // weak
int dword_C1168; // weak
int dword_C116C; // weak
int dword_C1170; // weak
int dword_C1174; // weak
int dword_C1178; // weak
int dword_C117C; // weak
_UNKNOWN unk_C1180; // weak
int dword_C1188; // weak
int weaponStrings[128]; // idb
int bg; // weak
int bgs[]; // weak
_UNKNOWN unk_C5000; // weak
float bg_viewheight_prone[72]; // idb
int bg_foliagesnd_slowinterval[72]; // idb
_DWORD bg_foliagesnd_fastinterval[72]; // idb
_DWORD bg_prone2duck_time[72]; // idb
int bg_foliagesnd_minspeed[72]; // idb
float bg_viewheight_crouched[72]; // idb
_DWORD bg_foliagesnd_resetinterval[72]; // idb
_DWORD bg_prone_softyawedge[72]; // idb
float bg_fallDamageMinHeight[72]; // idb
float bg_viewheight_standing[72]; // idb
_DWORD bg_duck2prone_time[72]; // idb
float pml[40]; // idb
int bg_ladder_yawcap[72]; // idb
_DWORD bg_foliagesnd_maxspeed[72]; // idb
float bg_fallDamageMaxHeight[72]; // idb
float bg_prone_yawcap[68]; // idb
int pm; // weak
_DWORD bg_debugWeaponState[72]; // idb
_DWORD bg_debugWeaponAnim[72]; // idb
float g_fHitLocDamageMult[24]; // idb
int g_hudelems[31744]; // idb
int itemRegistered[256]; // idb
char g_gametype[288]; // idb
_DWORD g_dedicated[72]; // idb
_DWORD g_listEntity[72]; // idb
int g_debugBullets[72]; // idb
float g_bounds_width[72]; // idb
_DWORD g_logSync[72]; // idb
_UNKNOWN g_motd; // weak
_DWORD pmove_fixed[72]; // idb
_DWORD g_inactivity[72]; // idb
float g_bounds_height_standing[72]; // idb
_DWORD g_dumpAnims[72]; // idb
_DWORD g_debugProneCheck[72]; // idb
_DWORD g_cheats[72]; // idb
_DWORD g_languagewarnings[72]; // idb
_DWORD g_debugLocDamage[72]; // idb
_DWORD g_developer[72]; // idb
float g_knockback[72]; // idb
_DWORD g_allowVote[72]; // idb
char g_password[288]; // idb
_DWORD pmove_msec[72]; // idb
int level[133]; // idb
float g_gravity[72]; // idb
_UNKNOWN g_clients; // weak
_UNKNOWN unk_200000; // weak
_UNKNOWN unk_200004; // weak
int g_entities[100392]; // idb
_DWORD g_synchronousClients[72]; // idb
_DWORD g_NoScriptSpam[72]; // idb
_DWORD g_complaintlimit[72]; // idb
float bg_swingSpeed[72]; // idb
_DWORD g_maxclients[72]; // idb
_DWORD g_voiceChatsAllowed[72]; // idb
_DWORD g_debugMove[72]; // idb
_DWORD g_weaponRespawn[72]; // idb
_DWORD bg_debugAnim[72]; // idb
float g_speed[72]; // idb
_DWORD g_filterBan[72]; // idb
_BYTE g_log[288]; // idb
_DWORD g_weaponAmmoPools[72]; // idb
char g_banIPs[288]; // idb
_DWORD g_debugDamage[72]; // idb
_DWORD g_smoothClients[72]; // idb
_DWORD g_languagewarningsaserrors[72]; // idb
_UNKNOWN pushed; // weak
int g_scr_data[112]; // idb
__int16 scr_const[128]; // idb
// extern int _ctype_tolower; weak
// extern int _ctype_b; weak
// extern int _ctype_toupper; weak
// extern struct _IO_FILE *stderr;


//----- (000274A4) --------------------------------------------------------
int init_proc()
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_277B8();
  return sub_6E1C4();
}
// 276F4: using guessed type int __gmon_start__(void);
// 277B8: using guessed type int sub_277B8(void);
// 6E1C4: using guessed type int sub_6E1C4(void);

//----- (000274D4) --------------------------------------------------------
void sub_274D4()
{
  __asm { jmp     dword ptr [ebx+8] }
}

//----- (00027730) --------------------------------------------------------
void start()
{
  ;
}

//----- (00027734) --------------------------------------------------------
int sub_27734()
{
  void (**v0)(void); // eax
  int result; // eax

  if ( !dword_7B3A4 )
  {
    while ( 1 )
    {
      result = off_7B3A0[0];
      if ( !*(_DWORD *)off_7B3A0[0] )
        break;
      v0 = (void (**)(void))off_7B3A0[0];
      off_7B3A0[0] += 4;
      (*v0)();
    }
    if ( _deregister_frame_info )
      result = __deregister_frame_info(&unk_83278);
    dword_7B3A4 = 1;
  }
  return result;
}
// 275B4: using guessed type _DWORD __cdecl __deregister_frame_info(_DWORD);
// 7B3A0: using guessed type int off_7B3A0[3];
// 7B3A4: using guessed type int dword_7B3A4;

//----- (00027798) --------------------------------------------------------
void sub_27798()
{
  ;
}

//----- (000277B4) --------------------------------------------------------
void sub_277B4()
{
  ;
}

//----- (000277B8) --------------------------------------------------------
int sub_277B8()
{
  int result; // eax

  if ( _register_frame_info )
    result = __register_frame_info(&unk_83278, &unk_8DFA0);
  return result;
}
// 276E4: using guessed type _DWORD __cdecl __register_frame_info(_DWORD, _DWORD);
// 6DDA4: using guessed type int __cdecl _register_frame_info(int, int);

//----- (000277F0) --------------------------------------------------------
void sub_277F0()
{
  ;
}

//----- (00027810) --------------------------------------------------------
int BG_AnimParseError(char *format, ...)
{
  int v1; // eax
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  if ( !off_7B3AC )
    return Com_Error(1, (char *)&byte_6E490, s);
  v1 = Com_GetCurrentParseLine();
  return Com_Error(1, (char *)&byte_6E47D, s, off_7B3AC, v1 + 1);
}
// 7B3AC: using guessed type char *off_7B3AC;

//----- (0002787C) --------------------------------------------------------
int __cdecl BG_AnimationIndexForString(char *src)
{
  int v1; // edi
  int v2; // ecx
  char *v3; // ebx
  int v4; // esi
  _DWORD *v5; // edi
  int v6; // ecx
  int v7; // ebx
  int v8; // ebx
  _DWORD *v9; // eax
  int v11; // [esp+24h] [ebp-4h]

  if ( dword_91028 )
  {
    v11 = 0;
    v5 = (_DWORD *)dword_9102C;
    v6 = 0;
    if ( *src )
    {
      do
      {
        v11 += (v6 + 119) * *(char *)(_ctype_tolower + 4 * src[v6]);
        ++v6;
      }
      while ( src[v6] );
    }
    if ( v11 == -1 )
      v11 = 0;
    v7 = dword_91028;
    v4 = 0;
    if ( *(int *)dword_9102C <= 0 )
    {
LABEL_19:
      v8 = dword_91028 + 72 * *v5;
      Scr_FindAnim((int)"multiplayer", (int)src, v8);
      strcpy((char *)(v8 + 8), src);
      v9 = (_DWORD *)dword_9102C;
      *(_DWORD *)(v8 + 4) = v11;
      ++*v9;
      return *(_DWORD *)dword_9102C - 1;
    }
    while ( v11 != *(_DWORD *)(v7 + 4) || Q_stricmp(src, (char *)(v7 + 8)) )
    {
      ++v4;
      v7 += 72;
      v5 = (_DWORD *)dword_9102C;
      if ( v4 >= *(_DWORD *)dword_9102C )
        goto LABEL_19;
    }
  }
  else
  {
    v1 = 0;
    v2 = 0;
    if ( *src )
    {
      do
      {
        v1 += (v2 + 119) * *(char *)(_ctype_tolower + 4 * src[v2]);
        ++v2;
      }
      while ( src[v2] );
    }
    if ( v1 == -1 )
      v1 = 0;
    v3 = dest;
    v4 = 0;
    if ( *((int *)dest + 11776) <= 0 )
    {
LABEL_10:
      BG_AnimParseError("BG_AnimationIndexForString: unknown player animation '%s'", src);
      return -1;
    }
    while ( v1 != *((_DWORD *)v3 + 19) || Q_stricmp(src, v3) )
    {
      ++v4;
      v3 += 92;
      if ( v4 >= *((_DWORD *)dest + 11776) )
        goto LABEL_10;
    }
  }
  return v4;
}
// 91028: using guessed type int dword_91028;
// 9102C: using guessed type int dword_9102C;
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00027A04) --------------------------------------------------------
char *__cdecl BG_AnimationForString(char *a1)
{
  int v1; // edi
  int v2; // ecx
  char *v3; // ebx
  int v4; // esi
  char *result; // eax

  v1 = 0;
  v2 = 0;
  if ( *a1 )
  {
    do
    {
      v1 += (v2 + 119) * *(char *)(_ctype_tolower + 4 * a1[v2]);
      ++v2;
    }
    while ( a1[v2] );
  }
  if ( v1 == -1 )
    v1 = 0;
  v3 = dest;
  v4 = 0;
  if ( *((int *)dest + 11776) <= 0 )
  {
LABEL_9:
    Com_Error(1, (char *)&byte_6E500, a1);
    result = 0;
  }
  else
  {
    while ( v1 != *((_DWORD *)v3 + 19) || Q_stricmp(a1, v3) )
    {
      ++v4;
      v3 += 92;
      if ( v4 >= *((_DWORD *)dest + 11776) )
        goto LABEL_9;
    }
    result = v3;
  }
  return result;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00027AAC) --------------------------------------------------------
int __cdecl BG_IndexForString(char *a1, char **a2, int a3)
{
  int v3; // ecx
  char **v4; // esi
  char *v5; // ebx
  char *v6; // edi
  int v7; // ecx
  int result; // eax
  char *v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = 0;
  v3 = 0;
  if ( *a1 )
  {
    do
    {
      v9 += (v3 + 119) * *(char *)(_ctype_tolower + 4 * a1[v3]);
      ++v3;
    }
    while ( a1[v3] );
  }
  if ( v9 == (char *)-1 )
    v9 = 0;
  v4 = a2;
  v10 = 0;
  if ( *a2 )
  {
    while ( 1 )
    {
      if ( v4[1] == (char *)-1 )
      {
        v5 = *v4;
        v6 = 0;
        v7 = 0;
        if ( **v4 )
        {
          do
          {
            v6 += (v7 + 119) * *(char *)(_ctype_tolower + 4 * v5[v7]);
            ++v7;
          }
          while ( v5[v7] );
        }
        if ( v6 == (char *)-1 )
          v6 = 0;
        v4[1] = v6;
      }
      if ( v9 == v4[1] && !Q_stricmp(a1, *v4) )
        break;
      v4 += 2;
      ++v10;
      if ( !*v4 )
        goto LABEL_16;
    }
    result = v10;
  }
  else
  {
LABEL_16:
    if ( !a3 )
      BG_AnimParseError("BG_IndexForString: unknown token '%s'", a1);
    result = -1;
  }
  return result;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00027BA8) --------------------------------------------------------
char *__cdecl BG_CopyStringIntoBuffer(char *src, int a2, int a3, int a4)
{
  char *v4; // eax
  int v5; // edx
  int v6; // edx
  char *v7; // esi
  char *v8; // eax
  int v9; // edx
  int v10; // edx

  v4 = src;
  v5 = (unsigned __int8)src & 3;
  if ( ((unsigned __int8)src & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)src & 3, 0) )
      goto LABEL_8;
    if ( v5 != 2 )
    {
      if ( *src == BYTE1(v5) )
        goto LABEL_17;
      v4 = src + 1;
    }
    if ( *v4 != BYTE1(v5) )
    {
      ++v4;
LABEL_8:
      if ( *v4 != BYTE1(v5) )
      {
        ++v4;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v6 = *(_DWORD *)v4;
      if ( !(unsigned __int8)*(_DWORD *)v4 )
        break;
      if ( !BYTE1(v6) )
        goto LABEL_16;
      if ( (v6 & 0xFF0000) == 0 )
        goto LABEL_15;
      v4 += 4;
      if ( (v6 & 0xFF000000) == 0 )
      {
        v4 -= 3;
LABEL_15:
        ++v4;
LABEL_16:
        ++v4;
        break;
      }
    }
  }
LABEL_17:
  if ( *(_DWORD *)a4 + v4 - src + 1 >= (unsigned int)a3 )
    BG_AnimParseError("BG_CopyStringIntoBuffer: out of buffer space");
  v7 = (char *)(*(_DWORD *)a4 + a2);
  strcpy(v7, src);
  v8 = src;
  v9 = (unsigned __int8)src & 3;
  if ( ((unsigned __int8)src & 3) != 0 )
  {
    if ( !__SETP__((unsigned __int8)src & 3, 0) )
    {
      if ( v9 != 2 )
      {
        if ( *src == BYTE1(v9) )
          goto LABEL_35;
        v8 = src + 1;
      }
      if ( *v8 == BYTE1(v9) )
        goto LABEL_35;
      ++v8;
    }
    if ( *v8 != BYTE1(v9) )
    {
      ++v8;
      goto LABEL_28;
    }
  }
  else
  {
LABEL_28:
    while ( 1 )
    {
      v10 = *(_DWORD *)v8;
      if ( !(unsigned __int8)*(_DWORD *)v8 )
        break;
      if ( !BYTE1(v10) )
        goto LABEL_34;
      if ( (v10 & 0xFF0000) == 0 )
        goto LABEL_33;
      v8 += 4;
      if ( (v10 & 0xFF000000) == 0 )
      {
        v8 -= 3;
LABEL_33:
        ++v8;
LABEL_34:
        ++v8;
        break;
      }
    }
  }
LABEL_35:
  *(_DWORD *)a4 += v8 - src + 1;
  return v7;
}

//----- (00027C7C) --------------------------------------------------------
int BG_InitWeaponStrings()
{
  int v0; // esi
  int i; // ecx
  int v2; // eax
  int v3; // edx
  int j; // edi
  _BYTE *v5; // ebx
  int v6; // esi
  int v7; // ecx
  int v8; // eax
  int v9; // edx
  int result; // eax

  _bzero(weaponStrings, 0x200u);
  weaponStrings[0] = (int)"none";
  v0 = 0;
  for ( i = 0; aNone[i]; v0 += v3 * *(char *)(_ctype_tolower + 4 * v2) )
  {
    v2 = aNone[i];
    v3 = i + 119;
    ++i;
  }
  if ( v0 == -1 )
    v0 = 0;
  weaponStrings[1] = v0;
  for ( j = 1; ; ++j )
  {
    result = BG_GetNumWeapons();
    if ( j > result )
      break;
    v5 = *(_BYTE **)(BG_GetInfoForWeapon(j) + 4);
    weaponStrings[2 * j] = (int)v5;
    v6 = 0;
    v7 = 0;
    if ( *v5 )
    {
      do
      {
        v8 = (char)v5[v7];
        v9 = v7 + 119;
        ++v7;
        v6 += v9 * *(char *)(_ctype_tolower + 4 * v8);
      }
      while ( v5[v7] );
    }
    if ( v6 == -1 )
      v6 = 0;
    weaponStrings[2 * j + 1] = v6;
  }
  weaponStringsInited = 1;
  return result;
}
// 7B3B4: using guessed type int weaponStringsInited;
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00027D70) --------------------------------------------------------
int BG_FinalizePlayerAnims()
{
  char *v0; // ebx
  char *v1; // ebx
  unsigned int v2; // edi
  char *v3; // edx
  int v4; // esi
  char *v5; // esi
  char *v6; // eax
  int v7; // esi
  int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int result; // eax
  char *v13; // edi
  int v14; // edx
  int v15; // edx
  int v16; // esi
  int v17; // ebx
  char *v18; // ecx
  _WORD *v19; // edx
  int v20; // [esp+20h] [ebp-48h]
  int v21; // [esp+24h] [ebp-44h]
  _DWORD *v22; // [esp+30h] [ebp-38h]
  unsigned __int16 v23; // [esp+34h] [ebp-34h]
  int v24; // [esp+34h] [ebp-34h]
  int v25; // [esp+38h] [ebp-30h]
  int v26; // [esp+3Ch] [ebp-2Ch]
  char v27[8]; // [esp+40h] [ebp-28h] BYREF
  int v28; // [esp+48h] [ebp-20h]
  __int16 v29; // [esp+4Ch] [ebp-1Ch]
  __int16 v30; // [esp+4Eh] [ebp-1Ah]
  float v31; // [esp+58h] [ebp-10h]
  float v32; // [esp+5Ch] [ebp-Ch]
  float v33; // [esp+60h] [ebp-8h]
  float v34; // [esp+64h] [ebp-4h]

  v0 = dest;
  v25 = *(int *)((char *)&dword_9B6C0 + (_DWORD)dest);
  v24 = (Scr_GetAnimsIndex(v25) << 16) | v23;
  v26 = trap_XAnimGetAnimTreeSize(v25);
  *((_DWORD *)dest + 11776) = v26;
  *((_DWORD *)v0 + 20) |= 0x101u;
  Q_strncpyz(v0, "root", 64);
  *((_DWORD *)v0 + 19) = 0;
  v1 = v0 + 92;
  v2 = 1;
  if ( v26 > 1 )
  {
    do
    {
      LOWORD(v24) = v2;
      if ( v2 >= *((_DWORD *)dest + 11776) )
        Com_Error(1, (char *)&byte_6E5C0, v2, *((_DWORD *)dest + 11776));
      v3 = (char *)dword_91028;
      v4 = 0;
      v20 = v2 + 1;
      if ( *(int *)dword_9102C <= 0 )
      {
LABEL_7:
        v5 = 0;
      }
      else
      {
        while ( v2 != *(unsigned __int16 *)v3 )
        {
          ++v4;
          v3 += 72;
          if ( v4 >= *(_DWORD *)dword_9102C )
            goto LABEL_7;
        }
        v5 = v3;
      }
      if ( v5 )
      {
        if ( trap_XAnimIsPrimitive(v24) )
        {
          v6 = (char *)trap_XAnimGetAnimName(v24);
          Q_strncpyz(v1, v6, 64);
          v7 = 0;
          v8 = 0;
          if ( *v1 )
          {
            do
            {
              v9 = v1[v8];
              v10 = v8 + 119;
              ++v8;
              v7 += v10 * *(char *)(_ctype_tolower + 4 * v9);
            }
            while ( v1[v8] );
          }
          if ( v7 == -1 )
            v7 = 0;
          *((_DWORD *)v1 + 19) = v7;
          if ( !*((_DWORD *)v1 + 16) )
            *((_DWORD *)v1 + 16) = -1;
          v11 = trap_XAnimGetLength(v25, v2);
          *((_DWORD *)v1 + 18) = v11;
          if ( v11
            && (trap_XAnimGetRelDelta(v24, (int)v27),
                v31 = sqrt(v32 * v32 + v33 * v33 + v34 * v34),
                v29 = v30 | 0xC00,
                (v28 = (int)v31) != 0) )
          {
            *((_DWORD *)v1 + 17) = 1000 * v28 / *((_DWORD *)v1 + 18);
          }
          else
          {
            *((_DWORD *)v1 + 17) = 0;
          }
          if ( *((int *)v1 + 18) <= 499 )
            *((_DWORD *)v1 + 18) = 500;
          if ( trap_XAnimIsLooped(v24) )
            v1[80] |= 0x80u;
        }
        else
        {
          v1[80] |= 1u;
          Q_strncpyz(v1, v5 + 8, 64);
          *((_DWORD *)v1 + 19) = *((_DWORD *)v5 + 1);
          if ( !*((_DWORD *)v1 + 16) )
            *((_DWORD *)v1 + 16) = -1;
          *((_DWORD *)v1 + 18) = 0;
          *((_DWORD *)v1 + 17) = 0;
        }
      }
      else
      {
        v1[81] |= 1u;
        Q_strncpyz(v1, "unused", 64);
        *((_DWORD *)v1 + 19) = 0;
      }
      ++v2;
      v1 += 92;
    }
    while ( v20 < v26 );
  }
  BG_AnimParseAnimScript(dest, 0, 0);
  v13 = dest;
  v14 = 0;
  if ( *((int *)dest + 11776) > 0 )
  {
    result = (int)(dest + 88);
    do
    {
      *(_DWORD *)result = 0;
      result += 92;
      ++v14;
    }
    while ( v14 < *((_DWORD *)v13 + 11776) );
  }
  v22 = (unsigned __int32 *)((char *)&stru_20EAC.r_offset + (_DWORD)v13);
  v15 = 0;
  if ( *(int *)((char *)&stru_20EAC.r_offset + (_DWORD)v13) > 0 )
  {
    do
    {
      result = (int)(v22 + 1);
      v16 = 0;
      v17 = v22[v15 + 1];
      v21 = v15 + 1;
      if ( *(int *)(v17 + 112) > 0 )
      {
        v18 = v13 + 88;
        v19 = (_WORD *)(v17 + 116);
        do
        {
          if ( *v19 )
          {
            result = 92 * (__int16)v19[2];
            *(_DWORD *)&v18[result] = 1;
          }
          if ( v19[1] )
          {
            result = 92 * (__int16)v19[3];
            *(_DWORD *)&v18[result] = 1;
          }
          v19 += 8;
          ++v16;
        }
        while ( v16 < *(_DWORD *)(v17 + 112) );
      }
      v15 = v21;
    }
    while ( v21 < *v22 );
  }
  return result;
}
// 27D9D: variable 'v23' is possibly undefined
// 20EAC: using guessed type Elf32_Rel stru_20EAC;
// 91028: using guessed type int dword_91028;
// 9102C: using guessed type int dword_9102C;
// 9B6C0: using guessed type int dword_9B6C0;
// 2ECD44: using guessed type int _ctype_tolower;

//----- (000280A0) --------------------------------------------------------
void __cdecl sub_280A0(int a1, int a2, int a3, void *s)
{
  char *v4; // esi
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // edx
  _DWORD *v8; // eax
  int v9; // edx
  int v10; // edx
  int *v11; // eax
  int v12; // edx
  int *v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  char *v18; // eax
  int *v19; // eax
  int v20; // ecx
  int v21; // [esp+28h] [ebp-50h]
  int v22; // [esp+2Ch] [ebp-4Ch]
  int v23; // [esp+30h] [ebp-48h] BYREF
  int v24; // [esp+34h] [ebp-44h]
  char v25[64]; // [esp+38h] [ebp-40h] BYREF

  v22 = 0;
  v21 = 0;
  v25[0] = 0;
  _bzero(s, 4u);
  _bzero(&v23, 8u);
LABEL_84:
  while ( !v22 )
  {
    do
    {
      v18 = Com_ParseOnLine((char **)a1);
      v4 = v18;
      if ( !v18 || !*v18 )
      {
        Com_UngetToken();
        v22 = 1;
        v19 = (int *)v25;
        while ( 1 )
        {
          v20 = *v19;
          if ( !(unsigned __int8)*v19 )
            break;
          if ( !BYTE1(v20) )
            goto LABEL_94;
          if ( (v20 & 0xFF0000) == 0 )
            goto LABEL_93;
          ++v19;
          if ( (v20 & 0xFF000000) == 0 )
          {
            v19 = (int *)((char *)v19 - 3);
LABEL_93:
            v19 = (int *)((char *)v19 + 1);
LABEL_94:
            v19 = (int *)((char *)v19 + 1);
            break;
          }
        }
        if ( v19 == (int *)v25 )
          return;
      }
      if ( !Q_stricmp(v4, ",") )
        v22 = 1;
      if ( !Q_stricmp(v4, "none") )
      {
        Com_BitSet((int)s, 0);
        goto LABEL_84;
      }
      if ( !Q_stricmp(v4, "none,") )
      {
        Com_BitSet((int)s, 0);
        v22 = 1;
        goto LABEL_84;
      }
      if ( !Q_stricmp(v4, "NOT") )
        v4 = "MINUS";
      if ( !v22 && Q_stricmp(v4, "AND") && Q_stricmp(v4, "MINUS") )
      {
        v5 = v4;
        v6 = (unsigned __int8)v4 & 3;
        if ( ((unsigned __int8)v4 & 3) == 0 )
          goto LABEL_22;
        if ( __SETP__((unsigned __int8)v4 & 3, 0) )
          goto LABEL_20;
        if ( v6 == 2 )
          goto LABEL_18;
        if ( *v4 != BYTE1(v6) )
        {
          v5 = v4 + 1;
LABEL_18:
          if ( *(_BYTE *)v5 != BYTE1(v6) )
          {
            v5 = (_DWORD *)((char *)v5 + 1);
LABEL_20:
            if ( *(_BYTE *)v5 != BYTE1(v6) )
            {
              v5 = (_DWORD *)((char *)v5 + 1);
LABEL_22:
              while ( 1 )
              {
                v7 = *v5;
                if ( !(unsigned __int8)*v5 )
                  break;
                if ( !BYTE1(v7) )
                  goto LABEL_28;
                if ( (v7 & 0xFF0000) == 0 )
                  goto LABEL_27;
                ++v5;
                if ( (v7 & 0xFF000000) == 0 )
                {
                  v5 = (_DWORD *)((char *)v5 - 3);
LABEL_27:
                  v5 = (_DWORD *)((char *)v5 + 1);
LABEL_28:
                  v5 = (_DWORD *)((char *)v5 + 1);
                  break;
                }
              }
            }
          }
        }
        if ( *((_BYTE *)v5 - 1) == 44 )
        {
          v22 = 1;
          v8 = v4;
          v9 = (unsigned __int8)v4 & 3;
          if ( ((unsigned __int8)v4 & 3) == 0 )
            goto LABEL_39;
          if ( __SETP__((unsigned __int8)v4 & 3, 0) )
            goto LABEL_37;
          if ( v9 == 2 )
            goto LABEL_35;
          if ( *v4 != BYTE1(v9) )
          {
            v8 = v4 + 1;
LABEL_35:
            if ( *(_BYTE *)v8 != BYTE1(v9) )
            {
              v8 = (_DWORD *)((char *)v8 + 1);
LABEL_37:
              if ( *(_BYTE *)v8 != BYTE1(v9) )
              {
                v8 = (_DWORD *)((char *)v8 + 1);
LABEL_39:
                while ( 1 )
                {
                  v10 = *v8;
                  if ( !(unsigned __int8)*v8 )
                    break;
                  if ( !BYTE1(v10) )
                    goto LABEL_45;
                  if ( (v10 & 0xFF0000) == 0 )
                    goto LABEL_44;
                  ++v8;
                  if ( (v10 & 0xFF000000) == 0 )
                  {
                    v8 = (_DWORD *)((char *)v8 - 3);
LABEL_44:
                    v8 = (_DWORD *)((char *)v8 + 1);
LABEL_45:
                    v8 = (_DWORD *)((char *)v8 + 1);
                    break;
                  }
                }
              }
            }
          }
          *((_BYTE *)v8 - 1) = 0;
        }
        v11 = (int *)v25;
        while ( 1 )
        {
          v12 = *v11;
          if ( !(unsigned __int8)*v11 )
            break;
          if ( !BYTE1(v12) )
            goto LABEL_54;
          if ( (v12 & 0xFF0000) == 0 )
            goto LABEL_53;
          ++v11;
          if ( (v12 & 0xFF000000) == 0 )
          {
            v11 = (int *)((char *)v11 - 3);
LABEL_53:
            v11 = (int *)((char *)v11 + 1);
LABEL_54:
            v11 = (int *)((char *)v11 + 1);
            break;
          }
        }
        if ( v11 != (int *)v25 )
          Q_strcat((int)v25, 64, " ");
        Q_strcat((int)v25, 64, v4);
      }
    }
    while ( Q_stricmp(v4, "AND") && Q_stricmp(v4, "MINUS") && !v22 );
    v13 = (int *)v25;
    while ( 1 )
    {
      v14 = *v13;
      if ( !(unsigned __int8)*v13 )
        break;
      if ( !BYTE1(v14) )
        goto LABEL_68;
      if ( (v14 & 0xFF0000) == 0 )
        goto LABEL_67;
      ++v13;
      if ( (v14 & 0xFF000000) == 0 )
      {
        v13 = (int *)((char *)v13 - 3);
LABEL_67:
        v13 = (int *)((char *)v13 + 1);
LABEL_68:
        v13 = (int *)((char *)v13 + 1);
        break;
      }
    }
    if ( v13 == (int *)v25 )
    {
      if ( v22 )
      {
        BG_AnimParseError("BG_ParseConditionBits: unexpected end of condition");
        goto LABEL_74;
      }
      if ( Q_stricmp(v4, "MINUS") )
      {
        BG_AnimParseError("BG_ParseConditionBits: unexpected '%s'", v4);
        goto LABEL_74;
      }
LABEL_83:
      v21 = 1;
      goto LABEL_84;
    }
LABEL_74:
    if ( Q_stricmp(v25, "all") )
    {
      v15 = BG_IndexForString(v25, (char **)&dword_90720[32 * a3], 1);
      if ( v15 < 0 )
      {
        v17 = BG_IndexForString(v25, (char **)a2, 0);
        Com_BitSet((int)&v23, v17);
      }
      else
      {
        v16 = (a3 << 7) + 8 * v15;
        v23 = *(int *)((char *)&dword_90BA0 + v16);
        v24 = *(int *)((char *)&dword_90BA4 + v16);
      }
    }
    else
    {
      v23 = -1;
      v24 = -1;
    }
    if ( v21 )
    {
      *(_DWORD *)s &= ~v23;
      *((_DWORD *)s + 1) &= ~v24;
    }
    else
    {
      *(_DWORD *)s |= v23;
      *((_DWORD *)s + 1) |= v24;
    }
    v25[0] = 0;
    if ( !Q_stricmp(v4, "MINUS") )
      goto LABEL_83;
  }
}
// 90720: using guessed type int dword_90720[];
// 90BA0: using guessed type int dword_90BA0;
// 90BA4: using guessed type int dword_90BA4;

//----- (0002846C) --------------------------------------------------------
int __cdecl sub_2846C(char **a1, _DWORD *a2)
{
  int v2; // esi
  int v3; // eax
  char *v4; // eax
  char *v5; // ebx
  _BYTE *v6; // eax
  int v7; // edx
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // edx
  char *v12; // eax
  char *v13; // ebx
  int s; // [esp+20h] [ebp-8h] BYREF
  int i; // [esp+24h] [ebp-4h]

  s = 0;
  for ( i = 0; ; a2[3 * (*a2)++ + 3] = i )
  {
    v12 = Com_ParseOnLine(a1);
    v13 = v12;
    if ( !v12 || !*v12 )
      break;
    if ( !Q_stricmp(v12, "default") )
      return 1;
    v2 = BG_IndexForString(v13, &off_7B5E0, 0);
    v3 = dword_7B630[2 * v2];
    if ( !v3 )
    {
      sub_280A0((int)a1, (int)off_7B634[2 * v2], v2, &s);
      goto LABEL_47;
    }
    if ( v3 == 1 )
    {
      if ( off_7B634[2 * v2] )
      {
        v4 = Com_ParseOnLine(a1);
        v5 = v4;
        if ( !v4 || !*v4 )
          BG_AnimParseError("BG_ParseConditions: expected condition value, found end of line");
        v6 = v5;
        v7 = (unsigned __int8)v5 & 3;
        if ( ((unsigned __int8)v5 & 3) != 0 )
        {
          if ( __SETP__((unsigned __int8)v5 & 3, 0) )
          {
LABEL_18:
            if ( *v6 != BYTE1(v7) )
            {
              ++v6;
              goto LABEL_20;
            }
          }
          else
          {
            if ( v7 == 2 )
              goto LABEL_16;
            if ( *v5 != BYTE1(v7) )
            {
              v6 = v5 + 1;
LABEL_16:
              if ( *v6 != BYTE1(v7) )
              {
                ++v6;
                goto LABEL_18;
              }
            }
          }
        }
        else
        {
LABEL_20:
          while ( 1 )
          {
            v8 = *(_DWORD *)v6;
            if ( !(unsigned __int8)*(_DWORD *)v6 )
              break;
            if ( !BYTE1(v8) )
              goto LABEL_26;
            if ( (v8 & 0xFF0000) == 0 )
              goto LABEL_25;
            v6 += 4;
            if ( (v8 & 0xFF000000) == 0 )
            {
              v6 -= 3;
LABEL_25:
              ++v6;
LABEL_26:
              ++v6;
              break;
            }
          }
        }
        if ( *(v6 - 1) == 44 )
        {
          v9 = v5;
          v10 = (unsigned __int8)v5 & 3;
          if ( ((unsigned __int8)v5 & 3) == 0 )
            goto LABEL_37;
          if ( __SETP__((unsigned __int8)v5 & 3, 0) )
            goto LABEL_35;
          if ( v10 == 2 )
            goto LABEL_33;
          if ( *v5 != BYTE1(v10) )
          {
            v9 = v5 + 1;
LABEL_33:
            if ( *(_BYTE *)v9 != BYTE1(v10) )
            {
              v9 = (_DWORD *)((char *)v9 + 1);
LABEL_35:
              if ( *(_BYTE *)v9 != BYTE1(v10) )
              {
                v9 = (_DWORD *)((char *)v9 + 1);
LABEL_37:
                while ( 1 )
                {
                  v11 = *v9;
                  if ( !(unsigned __int8)*v9 )
                    break;
                  if ( !BYTE1(v11) )
                    goto LABEL_43;
                  if ( (v11 & 0xFF0000) == 0 )
                    goto LABEL_42;
                  ++v9;
                  if ( (v11 & 0xFF000000) == 0 )
                  {
                    v9 = (_DWORD *)((char *)v9 - 3);
LABEL_42:
                    v9 = (_DWORD *)((char *)v9 + 1);
LABEL_43:
                    v9 = (_DWORD *)((char *)v9 + 1);
                    break;
                  }
                }
              }
            }
          }
          *((_BYTE *)v9 - 1) = 0;
        }
        s = BG_IndexForString(v5, (char **)off_7B634[2 * v2], 0);
        goto LABEL_47;
      }
      s = 1;
    }
LABEL_47:
    a2[3 * *a2 + 1] = v2;
    a2[3 * *a2 + 2] = s;
  }
  if ( !*a2 )
    BG_AnimParseError("BG_ParseConditions: no conditions found");
  return 1;
}
// 7B5E0: using guessed type char *off_7B5E0;
// 7B630: using guessed type int dword_7B630[];
// 7B634: using guessed type int *off_7B634[2];

//----- (00028650) --------------------------------------------------------
char *__cdecl BG_ParseCommands(char **a1, int *a2, int a3)
{
  _DWORD *v3; // eax
  int v4; // edx
  int v5; // edx
  char *result; // eax
  __int16 v7; // ax
  int v8; // esi
  char *v9; // eax
  char *v10; // ebx
  __int16 v11; // ax
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // edi
  char *v18; // eax
  char *v19; // ebx
  char *v20; // eax
  const char *v21; // ebx
  char *v22; // eax
  const char *v23; // ebx
  int v24; // eax
  _BYTE *v25; // eax
  int v26; // edx
  int v27; // edx
  char *v28; // eax
  const char *v29; // ebx
  char *v30; // eax
  const char *v31; // ebx
  char *v32; // ebx
  _DWORD *v33; // [esp+24h] [ebp-14h]
  int v34; // [esp+2Ch] [ebp-Ch]
  int v35; // [esp+30h] [ebp-8h]
  int *v36; // [esp+34h] [ebp-4h]

  v36 = 0;
  v35 = 0;
  v34 = a3 + 80;
LABEL_98:
  result = Com_Parse(a1);
LABEL_100:
  v32 = result;
  if ( result && *result )
  {
    if ( !Q_stricmp(result, "}") )
    {
      v3 = v32;
      v4 = (unsigned __int8)v32 & 3;
      if ( ((unsigned __int8)v32 & 3) == 0 )
        goto LABEL_12;
      if ( __SETP__((unsigned __int8)v32 & 3, 0) )
      {
LABEL_10:
        if ( *(_BYTE *)v3 != BYTE1(v4) )
        {
          v3 = (_DWORD *)((char *)v3 + 1);
LABEL_12:
          while ( 1 )
          {
            v5 = *v3;
            if ( !(unsigned __int8)*v3 )
              break;
            if ( !BYTE1(v5) )
              goto LABEL_18;
            if ( (v5 & 0xFF0000) == 0 )
              goto LABEL_17;
            ++v3;
            if ( (v5 & 0xFF000000) == 0 )
            {
              v3 = (_DWORD *)((char *)v3 - 3);
LABEL_17:
              v3 = (_DWORD *)((char *)v3 + 1);
LABEL_18:
              v3 = (_DWORD *)((char *)v3 + 1);
              goto LABEL_19;
            }
          }
        }
        goto LABEL_19;
      }
      if ( v4 != 2 )
      {
        if ( *v32 == BYTE1(v4) )
          goto LABEL_19;
        v3 = v32 + 1;
      }
      if ( *(_BYTE *)v3 != BYTE1(v4) )
      {
        v3 = (_DWORD *)((char *)v3 + 1);
        goto LABEL_10;
      }
LABEL_19:
      result = (char *)((char *)v3 - v32);
      *a1 -= (int)result;
      return result;
    }
    if ( !v35 )
    {
      if ( a2[28] > 7 )
        BG_AnimParseError("BG_ParseCommands: exceeded maximum number of animations (%i)", 8);
      v36 = &a2[4 * a2[28]++ + 29];
      _bzero(v36, 4u);
    }
    v7 = BG_IndexForString(v32, &animBodyPartsStr, 1);
    *((_WORD *)v36 + v35) = v7;
    v8 = 2 * v35;
    if ( v7 > 0 )
    {
      v9 = Com_ParseOnLine(a1);
      v10 = v9;
      if ( !v9 || !*v9 )
        BG_AnimParseError("BG_ParseCommands: expected animation");
      v11 = BG_AnimationIndexForString(v10);
      *(_WORD *)((char *)v36 + v8 + 4) = v11;
      *(_WORD *)((char *)v36 + v8 + 8) = *(_WORD *)(92 * v11 + a3 + 72);
      v33 = v36 + 1;
      if ( !dword_91028 )
      {
        v12 = dword_91020;
        if ( dword_91020 && *(_WORD *)((char *)v36 + v8) != 2 )
        {
          *(_DWORD *)(92 * *(__int16 *)((char *)v36 + v8 + 4) + a3 + 84) |= 1 << dword_91020;
          if ( (unsigned int)(v12 - 16) <= 1 )
          {
            v13 = 92 * *(__int16 *)((char *)v33 + v8);
            if ( *(_DWORD *)(v13 + a3 + 68) )
              *(_BYTE *)(v13 + v34) |= 2u;
          }
          v14 = 0;
          if ( *a2 > 0 )
          {
            v15 = 0;
            while ( a2[v15 + 1] != 8 )
            {
              v15 += 3;
              if ( ++v14 >= *a2 )
                goto LABEL_42;
            }
            v16 = a2[v15 + 2];
            if ( v16 == 1 )
            {
              *(_BYTE *)(92 * *(__int16 *)((char *)v33 + v8) + v34) |= 0x10u;
            }
            else if ( v16 == 2 )
            {
              *(_BYTE *)(92 * *(__int16 *)((char *)v33 + v8) + a3 + 80) |= 0x20u;
            }
          }
        }
LABEL_42:
        if ( dword_91024 == 2 )
        {
          *(_BYTE *)(92 * *(__int16 *)((char *)v33 + v8) + v34) |= 8u;
          *(_DWORD *)(92 * *(__int16 *)((char *)v33 + v8) + a3 + 64) = 30;
        }
        else if ( dword_91024 == 1 )
        {
          *(_DWORD *)(92 * *(__int16 *)((char *)v33 + v8) + a3 + 68) = 0;
          *(_BYTE *)(92 * *(__int16 *)((char *)v33 + v8) + v34) |= 0x40u;
        }
        goto LABEL_46;
      }
      while ( 1 )
      {
LABEL_46:
        v17 = 0;
        v18 = Com_ParseOnLine(a1);
        v19 = v18;
        if ( v18 && *v18 )
        {
          if ( !Q_stricmp(v18, "duration") )
          {
            v17 = 1;
            v20 = Com_ParseOnLine(a1);
            v21 = v20;
            if ( !v20 || !*v20 )
              BG_AnimParseError("BG_ParseCommands: expected duration value");
            *(_WORD *)((char *)v36 + v8 + 8) = _strtol_internal(v21, 0, 10, 0);
            goto LABEL_65;
          }
          if ( !Q_stricmp(v19, "turretanim") )
          {
            v17 = 1;
            if ( !dword_91028 )
              *(_BYTE *)(92 * *(__int16 *)((char *)v33 + v8) + v34) |= 4u;
            if ( *(_WORD *)((char *)v36 + v8) != 3 )
              BG_AnimParseError("BG_ParseCommands: Turret animations can only be played on the 'both' body part");
            goto LABEL_65;
          }
          if ( !Q_stricmp(v19, "blendtime") )
          {
            v17 = 1;
            v22 = Com_ParseOnLine(a1);
            v23 = v22;
            if ( !v22 || !*v22 )
              BG_AnimParseError("BG_ParseCommands: expected blendtime value");
            if ( !dword_91028 )
              *(_DWORD *)(92 * *(__int16 *)((char *)v33 + v8) + a3 + 64) = _strtol_internal(v23, 0, 10, 0);
            goto LABEL_65;
          }
        }
        Com_UngetToken();
LABEL_65:
        if ( !v17 )
        {
          if ( *(_WORD *)((char *)v36 + v8) == 3 || (v24 = v35, ++v35, v24 > 0) )
          {
LABEL_94:
            while ( 1 )
            {
              v30 = Com_ParseOnLine(a1);
              v31 = v30;
              if ( !v30 || !*v30 )
                break;
              if ( Q_stricmp(v30, "sound") )
              {
                BG_AnimParseError("BG_ParseCommands: unknown parameter '%s'", v31);
              }
              else
              {
                v28 = Com_ParseOnLine(a1);
                v29 = v28;
                if ( !v28 || !*v28 )
                  BG_AnimParseError("BG_ParseCommands: expected sound");
                if ( strstr(v29, ".wav") )
                  BG_AnimParseError("BG_ParseCommands: wav files not supported, only sound scripts");
                v36[3] = (*(int (__cdecl **)(const char *))((char *)&dword_9B6D0 + (_DWORD)dest))(v29);
              }
            }
            v35 = 0;
          }
          if ( v35 <= 0 )
            goto LABEL_98;
          result = Com_ParseOnLine(a1);
          goto LABEL_100;
        }
      }
    }
    v25 = v32;
    v26 = (unsigned __int8)v32 & 3;
    if ( ((unsigned __int8)v32 & 3) == 0 )
      goto LABEL_78;
    if ( !__SETP__((unsigned __int8)v32 & 3, 0) )
    {
      if ( v26 != 2 )
      {
        if ( *v32 == BYTE1(v26) )
          goto LABEL_85;
        v25 = v32 + 1;
      }
      if ( *v25 == BYTE1(v26) )
        goto LABEL_85;
      ++v25;
    }
    if ( *v25 != BYTE1(v26) )
    {
      ++v25;
      do
      {
LABEL_78:
        v27 = *(_DWORD *)v25;
        if ( !(unsigned __int8)*(_DWORD *)v25 )
          goto LABEL_85;
        if ( !BYTE1(v27) )
          goto LABEL_84;
        if ( (v27 & 0xFF0000) == 0 )
          goto LABEL_83;
        v25 += 4;
      }
      while ( (v27 & 0xFF000000) != 0 );
      v25 -= 3;
LABEL_83:
      ++v25;
LABEL_84:
      ++v25;
    }
LABEL_85:
    *a1 -= v25 - v32;
    goto LABEL_94;
  }
  return result;
}
// 7B4F0: using guessed type char *animBodyPartsStr;
// 91020: using guessed type int dword_91020;
// 91024: using guessed type int dword_91024;
// 91028: using guessed type int dword_91028;
// 9B6D0: using guessed type int dword_9B6D0;

//----- (00028B88) --------------------------------------------------------
void __cdecl BG_AnimParseAnimScript(char *a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // ecx
  char *v5; // eax
  int v6; // [esp+44h] [ebp-104h] BYREF
  char v7; // [esp+50h] [ebp-F8h] BYREF

  if ( !dword_7B3B0 )
  {
    v3 = trap_FS_FOpenFile((int)off_7B3AC, (int)&v6, 0);
    if ( v3 <= 0 )
      Com_Error(1, (char *)&byte_6E980, off_7B3AC);
    if ( (unsigned int)v3 > 0x1869E )
      Com_Error(1, (char *)&byte_6E980, off_7B3AC);
    trap_FS_Read((int)byte_91040, v3, v6);
    byte_91040[v3] = 0;
    trap_FS_FCloseFile(v6);
    dword_7B3B0 = 1;
  }
  dest = a1;
  dword_91028 = a2;
  dword_9102C = a3;
  if ( !weaponStringsInited )
    BG_InitWeaponStrings();
  _bzero(dword_90720, 0x480u);
  _bzero(&unk_8E000, 0x2710u);
  _bzero(dword_8DFC0, 0x24u);
  dword_90710 = 0;
  v4 = 2;
  v5 = &v7;
  do
  {
    *(_DWORD *)v5 = -1;
    v5 -= 4;
    --v4;
  }
  while ( v4 >= 0 );
  Com_BeginParseSession("BG_AnimParseAnimScript");
  JUMPOUT(0x29850);
}
// 28D07: control flows out of bounds to 29850
// 7B3AC: using guessed type char *off_7B3AC;
// 7B3B0: using guessed type int dword_7B3B0;
// 7B3B4: using guessed type int weaponStringsInited;
// 8DFC0: using guessed type int dword_8DFC0[];
// 90710: using guessed type int dword_90710;
// 90720: using guessed type int dword_90720[];
// 91028: using guessed type int dword_91028;
// 9102C: using guessed type int dword_9102C;

//----- (00028D10) --------------------------------------------------------
void __usercall sub_28D10(char *a1@<ebx>, int a2@<ebp>)
{
  int v2; // edi
  char *v3; // eax
  char *v4; // ebx
  int v5; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // edi
  int v9; // edx
  int v10; // ecx
  int v11; // esi
  int v12; // ebx
  int v13; // eax
  int v14; // edx
  char *v15; // ebx
  char *v17; // ebx
  int v18; // edi
  char *v19; // ebx
  int v20; // ebx
  char **v21; // eax
  char *v22; // eax
  int v23; // eax
  int v24; // ecx
  _DWORD *v25; // eax
  int v26; // edx
  int v27; // edx
  char *v28; // eax
  _DWORD *v29; // edx
  int v30; // ecx
  int v31; // ecx
  _BYTE *v32; // eax
  int v33; // edx
  int v34; // edx
  char *v35; // eax
  _DWORD *v36; // edx
  int v37; // ecx
  int v38; // ecx
  char *v39; // eax
  const char *v40; // [esp-8h] [ebp-Ch]

  while ( 2 )
  {
    v2 = BG_IndexForString(a1, &off_7B678, 1);
    if ( v2 >= 0 )
    {
      if ( *(_DWORD *)(a2 - 280) )
        BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
      *(_DWORD *)(a2 - 268) = v2;
      dword_91020 = 0;
      dword_91024 = -1;
      goto LABEL_130;
    }
    switch ( *(_DWORD *)(a2 - 268) )
    {
      case 0:
        if ( !Q_stricmp(a1, "set") )
        {
          v3 = Com_ParseOnLine(*(char ***)(a2 - 288));
          v4 = v3;
          if ( !v3 || !*v3 )
            BG_AnimParseError("BG_AnimParseAnimScript: expected condition type string");
          v5 = BG_IndexForString(v4, &off_7B5E0, 0);
          *(_DWORD *)(a2 - 284) = v5;
          if ( dword_7B630[2 * v5] )
            BG_AnimParseError("BG_AnimParseAnimScript: can not make a define of type '%s'", v4);
          v6 = Com_ParseOnLine(*(char ***)(a2 - 288));
          v7 = v6;
          if ( !v6 || !*v6 )
            BG_AnimParseError("BG_AnimParseAnimScript: expected condition define string");
          v8 = BG_CopyStringIntoBuffer(v7, (int)&unk_8E000, 10000, (int)&dword_90710);
          v9 = *(_DWORD *)(a2 - 284);
          v10 = *(_DWORD *)(a2 - 284) << 7;
          *(int *)((char *)&dword_90720[2 * dword_8DFC0[v9]] + v10) = (int)v8;
          v11 = 0;
          v12 = 0;
          *(_DWORD *)(a2 - 300) = 8 * *(_DWORD *)(a2 - 284);
          *(_DWORD *)(a2 - 296) = v9 * 4;
          *(_DWORD *)(a2 - 304) = v10;
          if ( *v8 )
          {
            do
            {
              v13 = v8[v12];
              v14 = v12 + 119;
              ++v12;
              v11 += v14 * *(char *)(_ctype_tolower + 4 * v13);
            }
            while ( v8[v12] );
          }
          if ( v11 == -1 )
            v11 = 0;
          *(int *)((char *)&dword_90724[2 * *(int *)((char *)dword_8DFC0 + *(_DWORD *)(a2 - 296))]
                 + *(_DWORD *)(a2 - 304)) = v11;
          v15 = Com_ParseOnLine(*(char ***)(a2 - 288));
          if ( !v15 )
            BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found end of line");
          if ( Q_stricmp(v15, "=") )
            BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found '%s'", v15);
          sub_280A0(
            *(_DWORD *)(a2 - 288),
            *(int *)((char *)off_7B634 + *(_DWORD *)(a2 - 300)),
            *(_DWORD *)(a2 - 284),
            (char *)&dword_90BA0[2 * *(int *)((char *)dword_8DFC0 + *(_DWORD *)(a2 - 296))] + *(_DWORD *)(a2 - 304));
          ++*(int *)((char *)dword_8DFC0 + *(_DWORD *)(a2 - 296));
        }
        goto LABEL_130;
      case 1:
      case 2:
        if ( Q_stricmp(a1, "{") )
        {
          sub_28FC0(a1, a2);
          return;
        }
        if ( *(int *)(a2 - 280) > 2 )
          BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
        if ( *(int *)(*(_DWORD *)(a2 - 292) + 4 * *(_DWORD *)(a2 - 280)) < 0 )
          goto LABEL_33;
        goto LABEL_34;
      case 3:
      case 4:
        if ( Q_stricmp(a1, "{") )
        {
          if ( !Q_stricmp(a1, "}") )
          {
            if ( --*(_DWORD *)(a2 - 280) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
            if ( !*(_DWORD *)(a2 - 280) )
              *(_DWORD *)(a2 - 272) = 0;
            *(_DWORD *)(*(_DWORD *)(a2 - 292) + 4 * *(_DWORD *)(a2 - 280)) = -1;
            goto LABEL_130;
          }
          if ( !*(_DWORD *)(a2 - 280) && *(int *)(a2 - 256) < 0 )
          {
            if ( *(_DWORD *)(a2 - 268) == 3 )
            {
              if ( Q_stricmp(a1, "statechange") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected 'statechange', got '%s'", a1);
              v17 = Com_ParseOnLine(*(char ***)(a2 - 288));
              if ( !v17 )
                BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>");
              v18 = BG_IndexForString(v17, &animStateStr, 0);
              v19 = Com_ParseOnLine(*(char ***)(a2 - 288));
              if ( !v19 )
                BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>");
              v20 = BG_IndexForString(v19, &animStateStr, 0);
              *(_DWORD *)(a2 - 272) = (char *)&stru_1DA44[258 * v18] + 516 * v20 + *(_DWORD *)(a2 + 8);
              v21 = *(char ***)(a2 - 288);
              *(_DWORD *)(a2 - 256) = v20;
              v22 = Com_Parse(v21);
              if ( !v22 || Q_stricmp(v22, "{") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected '{'");
              ++*(_DWORD *)(a2 - 280);
            }
            else
            {
              v23 = BG_IndexForString(a1, &off_7B478, 0);
              v24 = *(_DWORD *)(a2 + 8);
              *(_DWORD *)(a2 - 256) = v23;
              *(_DWORD *)(a2 - 272) = (char *)&stru_1FA84 + 516 * v23 + v24;
              dword_91024 = v23;
            }
            _bzero(*(void **)(a2 - 272), 0x204u);
            goto LABEL_130;
          }
          if ( *(_DWORD *)(a2 - 280) == 1 && *(int *)(a2 - 252) < 0 )
          {
            v25 = a1;
            v26 = (unsigned __int8)a1 & 3;
            if ( ((unsigned __int8)a1 & 3) == 0 )
              goto LABEL_67;
            if ( __SETP__((unsigned __int8)a1 & 3, 0) )
              goto LABEL_65;
            if ( v26 == 2 )
              goto LABEL_63;
            if ( *a1 != BYTE1(v26) )
            {
              v25 = a1 + 1;
LABEL_63:
              if ( *(_BYTE *)v25 != BYTE1(v26) )
              {
                v25 = (_DWORD *)((char *)v25 + 1);
LABEL_65:
                if ( *(_BYTE *)v25 != BYTE1(v26) )
                {
                  v25 = (_DWORD *)((char *)v25 + 1);
                  do
                  {
LABEL_67:
                    v27 = *v25;
                    if ( !(unsigned __int8)*v25 )
                      goto LABEL_74;
                    if ( !BYTE1(v27) )
                      goto LABEL_73;
                    if ( (v27 & 0xFF0000) == 0 )
                      goto LABEL_72;
                    ++v25;
                  }
                  while ( (v27 & 0xFF000000) != 0 );
                  v25 = (_DWORD *)((char *)v25 - 3);
LABEL_72:
                  v25 = (_DWORD *)((char *)v25 + 1);
LABEL_73:
                  v25 = (_DWORD *)((char *)v25 + 1);
                }
              }
            }
LABEL_74:
            v28 = (char *)(*(_DWORD *)(a2 - 264) - ((char *)v25 - a1));
            *(_DWORD *)(a2 - 264) = v28;
            v29 = a1;
            v30 = (unsigned __int8)a1 & 3;
            if ( ((unsigned __int8)a1 & 3) == 0 )
              goto LABEL_83;
            if ( __SETP__((unsigned __int8)a1 & 3, 0) )
            {
LABEL_81:
              if ( *(_BYTE *)v29 != BYTE1(v30) )
              {
                v29 = (_DWORD *)((char *)v29 + 1);
                do
                {
LABEL_83:
                  v31 = *v29;
                  if ( !(unsigned __int8)*v29 )
                    goto LABEL_90;
                  if ( !BYTE1(v31) )
                    goto LABEL_89;
                  if ( (v31 & 0xFF0000) == 0 )
                    goto LABEL_88;
                  ++v29;
                }
                while ( (v31 & 0xFF000000) != 0 );
                v29 = (_DWORD *)((char *)v29 - 3);
LABEL_88:
                v29 = (_DWORD *)((char *)v29 + 1);
LABEL_89:
                v29 = (_DWORD *)((char *)v29 + 1);
              }
            }
            else
            {
              if ( v30 == 2 )
                goto LABEL_79;
              if ( *a1 != BYTE1(v30) )
              {
                v29 = a1 + 1;
LABEL_79:
                if ( *(_BYTE *)v29 != BYTE1(v30) )
                {
                  v29 = (_DWORD *)((char *)v29 + 1);
                  goto LABEL_81;
                }
              }
            }
LABEL_90:
            if ( Q_strncmp(v28, a1, (char *)v29 - a1) )
              BG_AnimParseError("BG_AnimParseAnimScript: internal error");
            _bzero((void *)(a2 - 244), 0xF4u);
            *(_DWORD *)(a2 - 252) = sub_2846C(*(char ***)(a2 - 288), (_DWORD *)(a2 - 244));
            JUMPOUT(0x296BF);
          }
          if ( *(_DWORD *)(a2 - 280) != 2 )
          {
            sub_29842();
            return;
          }
          v32 = a1;
          v33 = (unsigned __int8)a1 & 3;
          if ( ((unsigned __int8)a1 & 3) == 0 )
            goto LABEL_104;
          if ( !__SETP__((unsigned __int8)a1 & 3, 0) )
          {
            if ( v33 != 2 )
            {
              if ( *a1 == BYTE1(v33) )
                goto LABEL_111;
              v32 = a1 + 1;
            }
            if ( *v32 == BYTE1(v33) )
            {
LABEL_111:
              v35 = (char *)(*(_DWORD *)(a2 - 264) - (v32 - a1));
              *(_DWORD *)(a2 - 264) = v35;
              v36 = a1;
              v37 = (unsigned __int8)a1 & 3;
              if ( ((unsigned __int8)a1 & 3) == 0 )
                goto LABEL_120;
              if ( __SETP__((unsigned __int8)a1 & 3, 0) )
              {
LABEL_118:
                if ( *(_BYTE *)v36 != BYTE1(v37) )
                {
                  v36 = (_DWORD *)((char *)v36 + 1);
LABEL_120:
                  while ( 1 )
                  {
                    v38 = *v36;
                    if ( !(unsigned __int8)*v36 )
                      break;
                    if ( !BYTE1(v38) )
                      goto LABEL_126;
                    if ( (v38 & 0xFF0000) == 0 )
                      goto LABEL_125;
                    ++v36;
                    if ( (v38 & 0xFF000000) == 0 )
                    {
                      v36 = (_DWORD *)((char *)v36 - 3);
LABEL_125:
                      v36 = (_DWORD *)((char *)v36 + 1);
LABEL_126:
                      v36 = (_DWORD *)((char *)v36 + 1);
                      goto LABEL_127;
                    }
                  }
                }
                goto LABEL_127;
              }
              if ( v37 != 2 )
              {
                if ( *a1 == BYTE1(v37) )
                  goto LABEL_127;
                v36 = a1 + 1;
              }
              if ( *(_BYTE *)v36 != BYTE1(v37) )
              {
                v36 = (_DWORD *)((char *)v36 + 1);
                goto LABEL_118;
              }
LABEL_127:
              if ( Q_strncmp(v35, a1, (char *)v36 - a1) )
                BG_AnimParseError("BG_AnimParseAnimScript: internal error");
              BG_ParseCommands(*(char ***)(a2 - 288), *(int **)(a2 - 276), *(_DWORD *)(a2 + 8));
              goto LABEL_130;
            }
            ++v32;
          }
          if ( *v32 != BYTE1(v33) )
          {
            ++v32;
LABEL_104:
            while ( 1 )
            {
              v34 = *(_DWORD *)v32;
              if ( !(unsigned __int8)*(_DWORD *)v32 )
                break;
              if ( !BYTE1(v34) )
                goto LABEL_110;
              if ( (v34 & 0xFF0000) == 0 )
                goto LABEL_109;
              v32 += 4;
              if ( (v34 & 0xFF000000) == 0 )
              {
                v32 -= 3;
LABEL_109:
                ++v32;
LABEL_110:
                ++v32;
                goto LABEL_111;
              }
            }
          }
          goto LABEL_111;
        }
        if ( *(int *)(a2 - 280) > 2 )
          BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
        if ( *(int *)(*(_DWORD *)(a2 - 292) + 4 * *(_DWORD *)(a2 - 280)) < 0 )
LABEL_33:
          BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
LABEL_34:
        ++*(_DWORD *)(a2 - 280);
LABEL_130:
        v39 = Com_Parse(*(char ***)(a2 - 288));
        a1 = v39;
        if ( v39 && *v39 )
          continue;
        if ( *(_DWORD *)(a2 - 280) )
          BG_AnimParseError("BG_AnimParseAnimScript: unexpected end of file: %s", v40);
        off_7B3AC = 0;
        Com_EndParseSession();
        return;
      default:
        goto LABEL_130;
    }
  }
}
// 296B9: control flows out of bounds to 296BF
// 29885: variable 'v40' is possibly undefined
// 1DA44: using guessed type Elf32_Rel stru_1DA44[];
// 1FA84: using guessed type Elf32_Rel stru_1FA84;
// 7B3AC: using guessed type char *off_7B3AC;
// 7B3B8: using guessed type char *animStateStr;
// 7B478: using guessed type char *off_7B478;
// 7B5E0: using guessed type char *off_7B5E0;
// 7B630: using guessed type int dword_7B630[];
// 7B634: using guessed type int *off_7B634[2];
// 7B678: using guessed type char *off_7B678;
// 8DFC0: using guessed type int dword_8DFC0[];
// 90710: using guessed type int dword_90710;
// 90720: using guessed type int dword_90720[];
// 90BA0: using guessed type int dword_90BA0[];
// 91020: using guessed type int dword_91020;
// 91024: using guessed type int dword_91024;
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00028FC0) --------------------------------------------------------
void __usercall sub_28FC0(char *a1@<ebx>, int a2@<ebp>)
{
  char *v3; // ebx
  int v4; // eax
  char **v5; // ecx
  char *v6; // eax
  int v7; // ecx
  _BYTE *v8; // eax
  int v9; // edx
  int v10; // edx
  char *v11; // eax
  _DWORD *v12; // edx
  int v13; // ecx
  int v14; // ecx
  _BYTE *v15; // eax
  int v16; // edx
  int v17; // edx
  char *v18; // eax
  _DWORD *v19; // edx
  int v20; // ecx
  int v21; // ecx
  int *v22; // ecx
  int v23; // edx
  int v24; // ebx
  int *v25; // edx
  int v26; // eax
  char *v27; // eax
  const char *v28; // [esp-4h] [ebp-Ch]

  if ( Q_stricmp(a1, "}") )
  {
    if ( !*(_DWORD *)(a2 - 280) && *(int *)(a2 - 256) < 0 )
    {
      if ( Q_stricmp(a1, "state") )
        BG_AnimParseError("BG_AnimParseAnimScript: expected 'state'");
      v3 = Com_ParseOnLine(*(char ***)(a2 - 288));
      if ( !v3 )
        BG_AnimParseError("BG_AnimParseAnimScript: expected state type");
      v4 = BG_IndexForString(v3, &animStateStr, 0);
      v5 = *(char ***)(a2 - 288);
      *(_DWORD *)(a2 - 256) = v4;
      v6 = Com_Parse(v5);
      if ( !v6 || Q_stricmp(v6, "{") )
        JUMPOUT(0x293D2);
      JUMPOUT(0x293DA);
    }
    if ( *(_DWORD *)(a2 - 280) == 1 && *(int *)(a2 - 252) < 0 )
    {
      v7 = BG_IndexForString(a1, &off_7B3E0, 0);
      *(_DWORD *)(a2 - 252) = v7;
      if ( *(_DWORD *)(a2 - 268) == 1 )
      {
        *(_DWORD *)(a2 - 272) = *(_DWORD *)(a2 + 8) + 9288 * *(_DWORD *)(a2 - 256) + 47108 + 516 * v7;
        dword_91020 = v7;
      }
      else if ( *(_DWORD *)(a2 - 268) == 2 )
      {
        *(_DWORD *)(a2 - 272) = (char *)&stru_14924[1161 * *(_DWORD *)(a2 - 256)] + 516 * v7 + *(_DWORD *)(a2 + 8);
      }
      _bzero(*(void **)(a2 - 272), 0x204u);
      goto LABEL_101;
    }
    if ( *(_DWORD *)(a2 - 280) == 2 && *(int *)(a2 - 248) < 0 )
    {
      v8 = a1;
      v9 = (unsigned __int8)a1 & 3;
      if ( ((unsigned __int8)a1 & 3) == 0 )
        goto LABEL_34;
      if ( !__SETP__((unsigned __int8)a1 & 3, 0) )
      {
        if ( v9 != 2 )
        {
          if ( *a1 == BYTE1(v9) )
            goto LABEL_41;
          v8 = a1 + 1;
        }
        if ( *v8 == BYTE1(v9) )
        {
LABEL_41:
          v11 = (char *)(*(_DWORD *)(a2 - 264) - (v8 - a1));
          *(_DWORD *)(a2 - 264) = v11;
          v12 = a1;
          v13 = (unsigned __int8)a1 & 3;
          if ( ((unsigned __int8)a1 & 3) == 0 )
            goto LABEL_50;
          if ( __SETP__((unsigned __int8)a1 & 3, 0) )
          {
LABEL_48:
            if ( *(_BYTE *)v12 != BYTE1(v13) )
            {
              v12 = (_DWORD *)((char *)v12 + 1);
LABEL_50:
              while ( 1 )
              {
                v14 = *v12;
                if ( !(unsigned __int8)*v12 )
                  break;
                if ( !BYTE1(v14) )
                  goto LABEL_56;
                if ( (v14 & 0xFF0000) == 0 )
                  goto LABEL_55;
                ++v12;
                if ( (v14 & 0xFF000000) == 0 )
                {
                  v12 = (_DWORD *)((char *)v12 - 3);
LABEL_55:
                  v12 = (_DWORD *)((char *)v12 + 1);
LABEL_56:
                  v12 = (_DWORD *)((char *)v12 + 1);
                  goto LABEL_57;
                }
              }
            }
            goto LABEL_57;
          }
          if ( v13 != 2 )
          {
            if ( *a1 == BYTE1(v13) )
              goto LABEL_57;
            v12 = a1 + 1;
          }
          if ( *(_BYTE *)v12 != BYTE1(v13) )
          {
            v12 = (_DWORD *)((char *)v12 + 1);
            goto LABEL_48;
          }
LABEL_57:
          if ( Q_strncmp(v11, a1, (char *)v12 - a1) )
            BG_AnimParseError("BG_AnimParseAnimScript: internal error");
          _bzero((void *)(a2 - 244), 0xF4u);
          *(_DWORD *)(a2 - 248) = sub_2846C(*(char ***)(a2 - 288), (_DWORD *)(a2 - 244));
          if ( **(int **)(a2 - 272) > 127 )
            BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
          if ( *(int *)((char *)&dword_9B6BC + *(_DWORD *)(a2 + 8)) > 2047 )
            BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 2048);
          v22 = *(int **)(a2 - 272);
          v23 = *(_DWORD *)(a2 + 8);
          v24 = *v22++;
          v22[v24] = (int)&stru_216BC + 244 * (*(int *)((char *)&dword_9B6BC + v23))++ + v23;
          v25 = *(int **)(a2 - 272);
          v26 = *v25;
          *(_DWORD *)(a2 - 276) = v22[*v25];
          *v25 = v26 + 1;
          qmemcpy(*(void **)(a2 - 276), (const void *)(a2 - 244), 0xF4u);
          goto LABEL_101;
        }
        ++v8;
      }
      if ( *v8 != BYTE1(v9) )
      {
        ++v8;
LABEL_34:
        while ( 1 )
        {
          v10 = *(_DWORD *)v8;
          if ( !(unsigned __int8)*(_DWORD *)v8 )
            break;
          if ( !BYTE1(v10) )
            goto LABEL_40;
          if ( (v10 & 0xFF0000) == 0 )
            goto LABEL_39;
          v8 += 4;
          if ( (v10 & 0xFF000000) == 0 )
          {
            v8 -= 3;
LABEL_39:
            ++v8;
LABEL_40:
            ++v8;
            goto LABEL_41;
          }
        }
      }
      goto LABEL_41;
    }
    if ( *(_DWORD *)(a2 - 280) != 3 )
    {
      sub_29842();
      return;
    }
    v15 = a1;
    v16 = (unsigned __int8)a1 & 3;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_70;
    if ( !__SETP__((unsigned __int8)a1 & 3, 0) )
    {
      if ( v16 != 2 )
      {
        if ( *a1 == BYTE1(v16) )
          goto LABEL_77;
        v15 = a1 + 1;
      }
      if ( *v15 == BYTE1(v16) )
      {
LABEL_77:
        v18 = (char *)(*(_DWORD *)(a2 - 264) - (v15 - a1));
        *(_DWORD *)(a2 - 264) = v18;
        v19 = a1;
        v20 = (unsigned __int8)a1 & 3;
        if ( ((unsigned __int8)a1 & 3) == 0 )
          goto LABEL_86;
        if ( __SETP__((unsigned __int8)a1 & 3, 0) )
        {
LABEL_84:
          if ( *(_BYTE *)v19 != BYTE1(v20) )
          {
            v19 = (_DWORD *)((char *)v19 + 1);
LABEL_86:
            while ( 1 )
            {
              v21 = *v19;
              if ( !(unsigned __int8)*v19 )
                break;
              if ( !BYTE1(v21) )
                goto LABEL_92;
              if ( (v21 & 0xFF0000) == 0 )
                goto LABEL_91;
              ++v19;
              if ( (v21 & 0xFF000000) == 0 )
              {
                v19 = (_DWORD *)((char *)v19 - 3);
LABEL_91:
                v19 = (_DWORD *)((char *)v19 + 1);
LABEL_92:
                v19 = (_DWORD *)((char *)v19 + 1);
                goto LABEL_93;
              }
            }
          }
          goto LABEL_93;
        }
        if ( v20 != 2 )
        {
          if ( *a1 == BYTE1(v20) )
            goto LABEL_93;
          v19 = a1 + 1;
        }
        if ( *(_BYTE *)v19 != BYTE1(v20) )
        {
          v19 = (_DWORD *)((char *)v19 + 1);
          goto LABEL_84;
        }
LABEL_93:
        if ( Q_strncmp(v18, a1, (char *)v19 - a1) )
          BG_AnimParseError("BG_AnimParseAnimScript: internal error");
        BG_ParseCommands(*(char ***)(a2 - 288), *(int **)(a2 - 276), *(_DWORD *)(a2 + 8));
        goto LABEL_101;
      }
      ++v15;
    }
    if ( *v15 != BYTE1(v16) )
    {
      ++v15;
LABEL_70:
      while ( 1 )
      {
        v17 = *(_DWORD *)v15;
        if ( !(unsigned __int8)*(_DWORD *)v15 )
          break;
        if ( !BYTE1(v17) )
          goto LABEL_76;
        if ( (v17 & 0xFF0000) == 0 )
          goto LABEL_75;
        v15 += 4;
        if ( (v17 & 0xFF000000) == 0 )
        {
          v15 -= 3;
LABEL_75:
          ++v15;
LABEL_76:
          ++v15;
          goto LABEL_77;
        }
      }
    }
    goto LABEL_77;
  }
  if ( --*(_DWORD *)(a2 - 280) < 0 )
    BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", a1);
  if ( *(_DWORD *)(a2 - 280) == 1 )
    *(_DWORD *)(a2 - 272) = 0;
  *(_DWORD *)(*(_DWORD *)(a2 - 292) + 4 * *(_DWORD *)(a2 - 280)) = -1;
LABEL_101:
  v27 = Com_Parse(*(char ***)(a2 - 288));
  if ( v27 && *v27 )
  {
    sub_28D10();
  }
  else
  {
    if ( *(_DWORD *)(a2 - 280) )
      BG_AnimParseError("BG_AnimParseAnimScript: unexpected end of file: %s", v28);
    off_7B3AC = 0;
    Com_EndParseSession();
  }
}
// 290D6: control flows out of bounds to 293D2
// 290C8: control flows out of bounds to 293DA
// 29885: variable 'v28' is possibly undefined
// 14924: using guessed type Elf32_Rel stru_14924[];
// 216BC: using guessed type Elf32_Rel stru_216BC;
// 28D10: using guessed type int sub_28D10(void);
// 69E60: using guessed type int Com_EndParseSession(void);
// 7B3AC: using guessed type char *off_7B3AC;
// 7B3B8: using guessed type char *animStateStr;
// 7B3E0: using guessed type char *off_7B3E0;
// 91020: using guessed type int dword_91020;
// 9B6BC: using guessed type int dword_9B6BC;

//----- (00029842) --------------------------------------------------------
void sub_29842()
{
  const char *v0; // [esp+0h] [ebp-Ch]

  BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", v0);
  JUMPOUT(0x29850);
}
// 2984B: control flows out of bounds to 29850
// 2984B: variable 'v0' is possibly undefined

//----- (000298AC) --------------------------------------------------------
int __cdecl BG_ExecuteCommand(_DWORD *a1, __int16 *a2, int a3, int a4, int a5)
{
  __int16 v5; // dx
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // esi
  unsigned int v15; // edi
  int v16; // ecx
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // edx
  int v21; // esi
  unsigned int v22; // edi
  int v23; // ecx
  int v24; // edx
  int v25; // eax
  int v26; // edx
  int v27; // eax
  int v28; // edx
  int v29; // eax
  int v30; // esi
  unsigned int v31; // edi
  int v32; // ecx
  int v33; // edx
  int v34; // eax
  int v35; // edx
  int v36; // eax
  int v37; // edx
  int result; // eax
  int v39; // [esp-8h] [ebp-40h]
  int v40; // [esp-4h] [ebp-3Ch]
  int v41; // [esp+18h] [ebp-20h]
  int v42; // [esp+1Ch] [ebp-1Ch]
  int v43; // [esp+20h] [ebp-18h]
  int v44; // [esp+24h] [ebp-14h]
  int v45; // [esp+28h] [ebp-10h]
  int v46; // [esp+2Ch] [ebp-Ch]
  _BOOL4 v47; // [esp+30h] [ebp-8h]
  int v48; // [esp+34h] [ebp-4h]

  v48 = -1;
  v47 = 0;
  v5 = *a2;
  if ( !*a2 )
    goto LABEL_63;
  v48 = a2[4] + 50;
  if ( v5 == 1 || v5 == 3 )
  {
    v6 = a2[2];
    v7 = *a2;
    v8 = v6;
    v46 = 0;
    if ( a2[4] == -50 )
      v45 = *(_DWORD *)&dest[92 * v6 + 72] + 50;
    else
      v45 = a2[4] + 50;
    if ( v7 != 2 )
    {
      if ( v7 > 2 )
      {
        if ( v7 != 3 )
        {
LABEL_32:
          v13 = v45;
          if ( !v46 )
            v13 = -1;
          v47 = v13 >= 0;
          goto LABEL_63;
        }
      }
      else if ( v7 != 1 )
      {
        goto LABEL_32;
      }
      if ( (int)a1[27] <= 49 || a5 )
      {
        if ( a4 && (v9 = a1[28], BYTE1(v9) &= 0xFDu, v9 == v6) )
        {
          if ( a3 && dest[92 * v6 + 80] < 0 )
            a1[27] = v45;
        }
        else
        {
          v46 = 1;
          v10 = a1[28] & 0x200;
          BYTE1(v10) ^= 2u;
          a1[28] = v6 | v10;
          if ( a3 )
            a1[27] = v45;
        }
      }
      if ( v7 != 3 )
        goto LABEL_32;
      v8 = 0;
    }
    if ( (int)a1[29] <= 49 || a5 )
    {
      if ( a4 && (v11 = a1[30], BYTE1(v11) &= 0xFDu, v11 == v8) )
      {
        if ( a3 && dest[92 * v8 + 80] < 0 )
          a1[29] = v45;
      }
      else
      {
        v12 = a1[30] & 0x200;
        BYTE1(v12) ^= 2u;
        a1[30] = v8 | v12;
        if ( a3 )
          a1[29] = v45;
      }
    }
    goto LABEL_32;
  }
  v14 = a2[2];
  v15 = *a2;
  v16 = v14;
  if ( a2[4] == -50 )
    v44 = *(_DWORD *)&dest[92 * v14 + 72] + 50;
  else
    v44 = a2[4] + 50;
  if ( v15 == 2 )
    goto LABEL_54;
  if ( v15 > 2 )
  {
    if ( v15 != 3 )
      goto LABEL_63;
  }
  else if ( v15 != 1 )
  {
    goto LABEL_63;
  }
  if ( (int)a1[27] <= 49 || a5 )
  {
    if ( a4 && (v17 = a1[28], BYTE1(v17) &= 0xFDu, v17 == v14) )
    {
      if ( a3 && dest[92 * v14 + 80] < 0 )
        a1[27] = v44;
    }
    else
    {
      v18 = a1[28] & 0x200;
      BYTE1(v18) ^= 2u;
      a1[28] = v14 | v18;
      if ( a3 )
        a1[27] = v44;
    }
  }
  if ( v15 == 3 )
  {
    v16 = 0;
LABEL_54:
    if ( (int)a1[29] <= 49 || a5 )
    {
      if ( a4 && (v19 = a1[30], BYTE1(v19) &= 0xFDu, v19 == v16) )
      {
        if ( a3 && dest[92 * v16 + 80] < 0 )
          a1[29] = v44;
      }
      else
      {
        v20 = a1[30] & 0x200;
        BYTE1(v20) ^= 2u;
        a1[30] = v16 | v20;
        if ( a3 )
          a1[29] = v44;
      }
    }
  }
LABEL_63:
  if ( !a2[1] )
    goto LABEL_125;
  v48 = a2[4] + 50;
  if ( *a2 == 1 || *a2 == 3 )
  {
    v21 = a2[3];
    v22 = a2[1];
    v23 = v21;
    v43 = 0;
    if ( a2[4] == -50 )
      v24 = *(_DWORD *)&dest[92 * v21 + 72] + 50;
    else
      v24 = a2[4] + 50;
    v42 = v24;
    if ( v22 != 2 )
    {
      if ( v22 > 2 )
      {
        if ( v22 != 3 )
        {
LABEL_94:
          v29 = v42;
          if ( !v43 )
            v29 = -1;
          v47 = v29 >= 0;
          goto LABEL_125;
        }
      }
      else if ( v22 != 1 )
      {
        goto LABEL_94;
      }
      if ( (int)a1[27] <= 49 || a5 )
      {
        if ( a4 && (v25 = a1[28], BYTE1(v25) &= 0xFDu, v25 == v21) )
        {
          if ( a3 && dest[92 * v21 + 80] < 0 )
            a1[27] = v24;
        }
        else
        {
          v43 = 1;
          v26 = a1[28] & 0x200;
          BYTE1(v26) ^= 2u;
          a1[28] = v21 | v26;
          if ( a3 )
            a1[27] = v42;
        }
      }
      if ( v22 != 3 )
        goto LABEL_94;
      v23 = 0;
    }
    if ( (int)a1[29] <= 49 || a5 )
    {
      if ( a4 && (v27 = a1[30], BYTE1(v27) &= 0xFDu, v27 == v23) )
      {
        if ( a3 && dest[92 * v23 + 80] < 0 )
          a1[29] = v42;
      }
      else
      {
        v28 = a1[30] & 0x200;
        BYTE1(v28) ^= 2u;
        a1[30] = v23 | v28;
        if ( a3 )
          a1[29] = v42;
      }
    }
    goto LABEL_94;
  }
  v30 = a2[3];
  v31 = a2[1];
  v32 = v30;
  if ( a2[4] == -50 )
    v33 = *(_DWORD *)&dest[92 * v30 + 72] + 50;
  else
    v33 = a2[4] + 50;
  v41 = v33;
  if ( v31 == 2 )
    goto LABEL_116;
  if ( v31 > 2 )
  {
    if ( v31 != 3 )
      goto LABEL_125;
  }
  else if ( v31 != 1 )
  {
    goto LABEL_125;
  }
  if ( (int)a1[27] <= 49 || a5 )
  {
    if ( a4 && (v34 = a1[28], BYTE1(v34) &= 0xFDu, v34 == v30) )
    {
      if ( a3 && dest[92 * v30 + 80] < 0 )
        a1[27] = v33;
    }
    else
    {
      v35 = a1[28] & 0x200;
      BYTE1(v35) ^= 2u;
      a1[28] = v30 | v35;
      if ( a3 )
        a1[27] = v41;
    }
  }
  if ( v31 == 3 )
  {
    v32 = 0;
LABEL_116:
    if ( (int)a1[29] <= 49 || a5 )
    {
      if ( a4 && (v36 = a1[30], BYTE1(v36) &= 0xFDu, v36 == v32) )
      {
        if ( a3 && dest[92 * v32 + 80] < 0 )
          a1[29] = v41;
      }
      else
      {
        v37 = a1[30] & 0x200;
        BYTE1(v37) ^= 2u;
        a1[30] = v32 | v37;
        if ( a3 )
          a1[29] = v41;
      }
    }
  }
LABEL_125:
  if ( *((_DWORD *)a2 + 3) )
    (*(void (__stdcall **)(_DWORD, _DWORD, int, int))((char *)&dword_9B6D4 + (_DWORD)dest))(
      a1[43],
      *((_DWORD *)a2 + 3),
      v39,
      v40);
  if ( v47 )
    result = v48;
  else
    result = -1;
  return result;
}
// 29D93: variable 'v39' is possibly undefined
// 29D93: variable 'v40' is possibly undefined
// 9B6D4: using guessed type int dword_9B6D4;

//----- (00029DB0) --------------------------------------------------------
int __cdecl BG_AnimScriptAnimation(_DWORD *a1, int a2, int a3, int a4)
{
  int *v4; // edi
  int v5; // esi
  _DWORD *v6; // ecx
  int *v7; // ebx
  unsigned int v8; // edx
  int v9; // eax
  int v10; // ebx
  int v12; // [esp+18h] [ebp-20h]
  _DWORD *v13; // [esp+28h] [ebp-10h]
  int v14; // [esp+2Ch] [ebp-Ch]
  char *v15; // [esp+34h] [ebp-4h]

  if ( (int)a1[1] > 5 || a2 < 0 )
    return -1;
  v12 = 9288 * a2 + 47108;
  while ( 2 )
  {
    v15 = &dest[516 * a3 + v12];
    if ( !*(_DWORD *)v15 )
      goto LABEL_21;
    v14 = 0;
    v13 = v15 + 4;
    if ( *(int *)v15 <= 0 )
      goto LABEL_19;
    v4 = &bgs[274 * a1[43] + 159163];
    do
    {
      v5 = 0;
      v6 = (_DWORD *)(*v13 + 4);
      if ( *(int *)*v13 <= 0 )
      {
LABEL_17:
        v10 = *v13;
        goto LABEL_20;
      }
      v7 = v4 + 254;
      while ( 1 )
      {
        v8 = 2 * *v6;
        v9 = dword_7B630[v8];
        if ( !v9 )
          break;
        if ( v9 == 1 && v7[v8] != v6[1] )
          goto LABEL_18;
LABEL_16:
        ++v5;
        v6 += 3;
        if ( v5 >= *(_DWORD *)*v13 )
          goto LABEL_17;
      }
      if ( (v6[1] & v7[v8]) != 0 || (v6[2] & v4[v8 + 255]) != 0 )
        goto LABEL_16;
LABEL_18:
      ++v14;
      ++v13;
    }
    while ( v14 < *(_DWORD *)v15 );
LABEL_19:
    v10 = 0;
LABEL_20:
    if ( !v10 )
    {
LABEL_21:
      v12 -= 9288;
      if ( --a2 < 0 )
        return -1;
      continue;
    }
    break;
  }
  if ( !*(_DWORD *)(v10 + 112) )
    return -1;
  BG_UpdateConditionValue(a1[43], 3, a3, 1);
  return BG_ExecuteCommand(a1, (__int16 *)(v10 + 16 * (a1[43] % *(_DWORD *)(v10 + 112)) + 116), 0, a4, 0) != -1;
}
// 29EC9: conditional instruction was optimized away because of 'ebx.4==0'
// 29ED7: conditional instruction was optimized away because of 'ebx.4==0'
// 7B630: using guessed type int dword_7B630[];
// C13C0: using guessed type int bgs[];

//----- (00029F38) --------------------------------------------------------
int __cdecl BG_AnimScriptStateChange(_DWORD *a1, int a2, int a3)
{
  int v3; // esi
  _DWORD *v4; // edx
  int *v5; // ebx
  unsigned int v6; // ecx
  int v7; // eax
  int v8; // ebx
  int v10; // eax
  int *v11; // [esp+28h] [ebp-10h]
  _DWORD *v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+30h] [ebp-8h]
  int *v14; // [esp+34h] [ebp-4h]

  if ( (int)a1[1] > 5 )
    return -1;
  v14 = (int *)((char *)stru_1DA44 + 516 * a2 + (_DWORD)&dest[2064 * a3]);
  if ( !*v14 )
    return -1;
  v13 = 0;
  v12 = v14 + 1;
  if ( *v14 <= 0 )
    goto LABEL_17;
  v11 = &bgs[274 * a1[43] + 159163];
  do
  {
    v3 = 0;
    v4 = (_DWORD *)(*v12 + 4);
    if ( *(int *)*v12 <= 0 )
    {
LABEL_15:
      v8 = *v12;
      goto LABEL_18;
    }
    v5 = v11 + 254;
    while ( 1 )
    {
      v6 = 2 * *v4;
      v7 = dword_7B630[v6];
      if ( !v7 )
        break;
      if ( v7 == 1 && v5[v6] != v4[1] )
        goto LABEL_16;
LABEL_14:
      ++v3;
      v4 += 3;
      if ( v3 >= *(_DWORD *)*v12 )
        goto LABEL_15;
    }
    if ( (v4[1] & v5[v6]) != 0 || (v4[2] & v11[v6 + 255]) != 0 )
      goto LABEL_14;
LABEL_16:
    ++v13;
    ++v12;
  }
  while ( v13 < *v14 );
LABEL_17:
  v8 = 0;
LABEL_18:
  if ( !v8 )
    return -1;
  if ( !*(_DWORD *)(v8 + 112) )
    return -1;
  v10 = rand();
  return BG_ExecuteCommand(a1, (__int16 *)(v8 + 16 * (v10 % *(_DWORD *)(v8 + 112)) + 116), 1, 0, 0);
}
// 1DA44: using guessed type Elf32_Rel stru_1DA44[];
// 7B630: using guessed type int dword_7B630[];
// C13C0: using guessed type int bgs[];

//----- (0002A084) --------------------------------------------------------
int __cdecl BG_AnimScriptEvent(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // esi
  _DWORD *v5; // ecx
  int *v6; // ebx
  unsigned int v7; // edx
  int v8; // eax
  int v9; // ebx
  int v11; // eax
  int *v12; // [esp+28h] [ebp-10h]
  _DWORD *v13; // [esp+2Ch] [ebp-Ch]
  int v14; // [esp+30h] [ebp-8h]
  int *v15; // [esp+34h] [ebp-4h]

  if ( a2 != 1 && (int)a1[1] > 5 )
    return -1;
  v15 = (int *)((char *)&stru_1FA84 + (_DWORD)&dest[516 * a2]);
  if ( !*v15 )
    return -1;
  v14 = 0;
  v13 = v15 + 1;
  if ( *v15 <= 0 )
    goto LABEL_18;
  v12 = &bgs[274 * a1[43] + 159163];
  do
  {
    v4 = 0;
    v5 = (_DWORD *)(*v13 + 4);
    if ( *(int *)*v13 <= 0 )
    {
LABEL_16:
      v9 = *v13;
      goto LABEL_19;
    }
    v6 = v12 + 254;
    while ( 1 )
    {
      v7 = 2 * *v5;
      v8 = dword_7B630[v7];
      if ( !v8 )
        break;
      if ( v8 == 1 && v6[v7] != v5[1] )
        goto LABEL_17;
LABEL_15:
      ++v4;
      v5 += 3;
      if ( v4 >= *(_DWORD *)*v13 )
        goto LABEL_16;
    }
    if ( (v5[1] & v6[v7]) != 0 || (v5[2] & v12[v7 + 255]) != 0 )
      goto LABEL_15;
LABEL_17:
    ++v14;
    ++v13;
  }
  while ( v14 < *v15 );
LABEL_18:
  v9 = 0;
LABEL_19:
  if ( !v9 )
    return -1;
  if ( !*(_DWORD *)(v9 + 112) )
    return -1;
  v11 = rand();
  return BG_ExecuteCommand(a1, (__int16 *)(v9 + 16 * (v11 % *(_DWORD *)(v9 + 112)) + 116), 1, a3, a4);
}
// 1FA84: using guessed type Elf32_Rel stru_1FA84;
// 7B630: using guessed type int dword_7B630[];
// C13C0: using guessed type int bgs[];

//----- (0002A1C8) --------------------------------------------------------
int __cdecl BG_GetAnimScriptEvent(int a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // ecx
  int *v4; // ebx
  unsigned int v5; // edx
  int v6; // eax
  int v7; // ebx
  int *v9; // [esp+28h] [ebp-10h]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]
  int *v12; // [esp+34h] [ebp-4h]

  if ( a2 != 1 && *(int *)(a1 + 4) > 5 )
    return -1;
  v12 = (int *)((char *)&stru_1FA84 + (_DWORD)&dest[516 * a2]);
  if ( !*v12 )
    return -1;
  v11 = 0;
  v10 = v12 + 1;
  if ( *v12 <= 0 )
    goto LABEL_18;
  v9 = &bgs[274 * *(_DWORD *)(a1 + 172) + 159163];
LABEL_6:
  v2 = 0;
  v3 = (_DWORD *)(*v10 + 4);
  if ( *(int *)*v10 > 0 )
  {
    v4 = v9 + 254;
    do
    {
      v5 = 2 * *v3;
      v6 = dword_7B630[v5];
      if ( v6 )
      {
        if ( v6 == 1 && v4[v5] != v3[1] )
          goto LABEL_17;
      }
      else if ( (v3[1] & v4[v5]) == 0 && (v3[2] & v9[v5 + 255]) == 0 )
      {
LABEL_17:
        ++v11;
        ++v10;
        if ( v11 >= *v12 )
        {
LABEL_18:
          v7 = 0;
          goto LABEL_19;
        }
        goto LABEL_6;
      }
      ++v2;
      v3 += 3;
    }
    while ( v2 < *(_DWORD *)*v10 );
  }
  v7 = *v10;
LABEL_19:
  if ( v7 && *(_DWORD *)(v7 + 112) )
    return *(__int16 *)(v7 + 16 * (rand() % *(_DWORD *)(v7 + 112)) + 120);
  return -1;
}
// 1FA84: using guessed type Elf32_Rel stru_1FA84;
// 7B630: using guessed type int dword_7B630[];
// C13C0: using guessed type int bgs[];

//----- (0002A2EC) --------------------------------------------------------
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // eax
  char v22; // fps^1
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  int v26; // eax
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int result; // eax
  int v33; // eax
  int v34; // edx
  int v35; // eax

  v1 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(*(_DWORD *)a1 + 172);
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 176);
  if ( dword_7B630[0] )
  {
    bgs[274 * v2 + 159417] = v3;
  }
  else
  {
    v4 = 274 * v2;
    bgs[v4 + 159417] = 0;
    bgs[v4 + 159418] = 0;
    Com_BitSet((int)&bgs[v4 + 159417], v3);
  }
  v5 = BG_GetInfoForWeapon(*(_DWORD *)(v1 + 176));
  v6 = *(_DWORD *)(v1 + 172);
  v7 = *(_DWORD *)(v5 + 116);
  if ( dword_7B638 )
  {
    bgs[274 * v6 + 159419] = v7;
  }
  else
  {
    v8 = 274 * v6;
    v9 = v8 * 4 + 8;
    *(int *)((char *)&bgs[159417] + v9) = 0;
    *(int *)((char *)&bgs[159418] + v9) = 0;
    Com_BitSet((int)&bgs[v8 + 159419], v7);
  }
  if ( (*(_BYTE *)(v1 + 129) & 2) != 0 )
  {
    v10 = *(_DWORD *)(v1 + 172);
    if ( dword_7B668 )
    {
      bgs[274 * v10 + 159431] = 1;
    }
    else
    {
      v11 = 274 * v10;
      v12 = 1096 * v10 + 56;
      *(int *)((char *)&bgs[159417] + v12) = 0;
      *(int *)((char *)&bgs[159418] + v12) = 0;
      Com_BitSet((int)&bgs[v11 + 159431], 1);
    }
  }
  else
  {
    v13 = *(_DWORD *)(v1 + 172);
    if ( dword_7B668 )
    {
      bgs[274 * v13 + 159431] = 0;
    }
    else
    {
      v14 = 274 * v13;
      v15 = 1096 * v13 + 56;
      *(int *)((char *)&bgs[159417] + v15) = 0;
      *(int *)((char *)&bgs[159418] + v15) = 0;
      Com_BitSet((int)&bgs[v14 + 159431], 0);
    }
  }
  if ( (*(_BYTE *)(v1 + 129) & 0xC0) != 0 )
  {
    v16 = *(_DWORD *)(v1 + 172);
    if ( dword_7B640 )
    {
      bgs[274 * v16 + 159421] = 1;
    }
    else
    {
      v17 = 274 * v16;
      v18 = 1096 * v16 + 16;
      *(int *)((char *)&bgs[159417] + v18) = 0;
      *(int *)((char *)&bgs[159418] + v18) = 0;
      Com_BitSet((int)&bgs[v17 + 159421], 1);
    }
  }
  else
  {
    v19 = *(_DWORD *)(v1 + 172);
    if ( dword_7B640 )
    {
      bgs[274 * v19 + 159421] = 0;
    }
    else
    {
      v20 = 274 * v19;
      v21 = 1096 * v19 + 16;
      *(int *)((char *)&bgs[159417] + v21) = 0;
      *(int *)((char *)&bgs[159418] + v21) = 0;
      Com_BitSet((int)&bgs[v20 + 159421], 0);
    }
  }
  v23 = *(float *)(v1 + 192) > 0.0;
  v24 = 0;
  v25 = 0.0 == *(float *)(v1 + 192);
  v26 = *(_DWORD *)(v1 + 172);
  if ( dword_7B650 )
  {
    bgs[274 * v26 + 159425] = (v22 & 0x45) == 1;
  }
  else
  {
    v27 = 274 * v26;
    v28 = 1096 * v26 + 32;
    *(int *)((char *)&bgs[159417] + v28) = 0;
    *(int *)((char *)&bgs[159418] + v28) = 0;
    Com_BitSet((int)&bgs[v27 + 159425], (v22 & 0x45) == 1);
  }
  if ( (a1[8] & 1) != 0 )
  {
    v29 = *(_DWORD *)(v1 + 172);
    if ( dword_7B660 )
    {
      result = 1096 * v29;
      *(int *)((char *)&bgs[159429] + result) = 1;
    }
    else
    {
      v30 = 274 * v29;
      v31 = 1096 * v29 + 48;
      *(int *)((char *)&bgs[159417] + v31) = 0;
      *(int *)((char *)&bgs[159418] + v31) = 0;
      result = Com_BitSet((int)&bgs[v30 + 159429], 1);
    }
  }
  else
  {
    v33 = *(_DWORD *)(v1 + 172);
    if ( dword_7B660 )
    {
      result = 1096 * v33;
      *(int *)((char *)&bgs[159429] + result) = 0;
    }
    else
    {
      v34 = 274 * v33;
      v35 = 1096 * v33 + 48;
      *(int *)((char *)&bgs[159417] + v35) = 0;
      *(int *)((char *)&bgs[159418] + v35) = 0;
      result = Com_BitSet((int)&bgs[v34 + 159429], 0);
    }
  }
  return result;
}
// 2A4FE: variable 'v22' is possibly undefined
// 7B630: using guessed type int dword_7B630[];
// 7B638: using guessed type int dword_7B638;
// 7B640: using guessed type int dword_7B640;
// 7B650: using guessed type int dword_7B650;
// 7B660: using guessed type int dword_7B660;
// 7B668: using guessed type int dword_7B668;
// C13C0: using guessed type int bgs[];

//----- (0002A600) --------------------------------------------------------
void __usercall sub_2A600(unsigned __int16 a1@<di>, _DWORD *a2, _DWORD *a3, unsigned int a4, int a5)
{
  unsigned int v5; // eax
  unsigned int v6; // eax
  int v7; // edi
  int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // ebx
  _BOOL4 v11; // esi
  int v12; // eax
  const char *v13; // edx
  int v14; // [esp-8h] [ebp-50h]
  _BOOL4 v15; // [esp+28h] [ebp-20h]
  int v16; // [esp+2Ch] [ebp-1Ch]
  float v17; // [esp+34h] [ebp-14h]
  unsigned int v18; // [esp+38h] [ebp-10h]
  int v19; // [esp+3Ch] [ebp-Ch]
  int *v20; // [esp+40h] [ebp-8h]
  unsigned int v21; // [esp+58h] [ebp+10h]

  v17 = 0.0;
  v19 = a3[5];
  v5 = a4;
  v18 = a3[4];
  a3[4] = a4;
  BYTE1(v5) = BYTE1(a4) & 0xFD;
  v21 = v5;
  v6 = bgs[11776];
  if ( v21 >= v6 )
    Com_Error(1, (char *)&byte_6EE60, v6, v21);
  v16 = a2[272];
  v7 = (Scr_GetAnimsIndex(bgs[159152]) << 16) | a1;
  if ( v21 )
  {
    v20 = &bgs[23 * v21];
    a3[5] = v20;
    a3[6] = bgs[23 * v21 + 16];
  }
  else
  {
    v20 = 0;
    a3[5] = 0;
    a3[6] = 200;
  }
  if ( !v19 && a3 == a2 + 223 )
  {
    a3[6] = 0;
    goto LABEL_32;
  }
  v8 = a3[6];
  if ( !v20 )
    goto LABEL_27;
  if ( v8 > 0 )
    goto LABEL_32;
  if ( a3 != a2 + 223 )
    goto LABEL_26;
  v9 = v21 & 0xFFFFFDFF;
  if ( (v21 & 0xFFFFFDFF) >= *((_DWORD *)dest + 11776) )
    Com_Error(1, (char *)&byte_6EE20);
  v10 = v18;
  v15 = (dest[92 * v9 + 84] & 0xC4) != 0;
  BYTE1(v10) = BYTE1(v18) & 0xFD;
  if ( v10 >= *((_DWORD *)dest + 11776) )
    Com_Error(1, (char *)&byte_6EE20);
  if ( v15 == ((dest[92 * v10 + 84] & 0xC4) != 0) )
  {
    if ( v9 >= *((_DWORD *)dest + 11776) )
      Com_Error(1, (char *)&byte_6EE20);
    v11 = (*(_DWORD *)&dest[92 * v9 + 84] & 0x308) != 0;
    if ( v10 >= *((_DWORD *)dest + 11776) )
      Com_Error(1, (char *)&byte_6EE20);
    v8 = a3[6];
    if ( v11 == ((*(_DWORD *)&dest[92 * v10 + 84] & 0x308) != 0) )
    {
LABEL_26:
      v12 = 120;
      if ( v20[17] )
        goto LABEL_30;
LABEL_27:
      v12 = 170;
      if ( v19 && *(_DWORD *)(v19 + 68) )
        v12 = 250;
      goto LABEL_30;
    }
  }
  if ( v20[17] || (*((_BYTE *)v20 + 85) & 0xC0) != 0 )
  {
    v12 = 200;
    v8 = a3[6];
  }
  else
  {
    v12 = 250;
    v8 = a3[6];
  }
LABEL_30:
  if ( v8 < v12 )
    a3[6] = v12;
LABEL_32:
  if ( v20 )
  {
    if ( v20[17] )
    {
      LOWORD(v7) = v21;
      if ( trap_XAnimIsLooped(v7) )
      {
        LOWORD(v7) = v18 & 0xFDFF;
        if ( v19 && *(_DWORD *)(v19 + 68) && trap_XAnimIsLooped(v7) )
          v17 = trap_XAnimGetTime(v16, v7);
        else
          v17 = (long double)((bg / 100 + 360 * a2[2]) % 1000) * 0.001;
      }
    }
  }
  if ( v19 )
  {
    *(float *)&v14 = (long double)(int)a3[6] * 0.001;
    trap_XAnimClearGoalWeight(v16, v18 & 0xFDFF, v14);
  }
  if ( v21 )
  {
    if ( a3 != a2 + 223 )
    {
      a2[252] = 0;
      a2[253] = 1;
    }
    LOWORD(v7) = v21;
    if ( (v20[20] & 0x40) != 0 )
    {
      if ( trap_XAnimIsLooped(v7) )
        Com_Error(1, "death animation '%s' is looping", (const char *)v20);
      if ( a5 )
      {
        trap_XAnimSetCompleteGoalWeight(v16, v21, 1065353216);
      }
      else
      {
        trap_XAnimSetCompleteGoalWeightKnobAll(v16, v21, bgs[159159]);
        trap_XAnimSetTime(v16, v21, 1065353216);
      }
    }
    else
    {
      trap_XAnimSetCompleteGoalWeight(v16, v21, 1065353216);
      if ( v20[17] )
        trap_XAnimSetTime(v16, v21, SLODWORD(v17));
    }
    if ( a3 != a2 + 223 )
    {
      trap_XAnimSetCompleteGoalWeight(v16, bgs[159153], 1065353216);
      trap_XAnimSetCompleteGoalWeight(v16, bgs[159154], COERCE_INT(0.0099999998));
    }
  }
  else if ( a3 != a2 + 223 )
  {
    trap_XAnimSetCompleteGoalWeight(v16, bgs[159153], 0);
    trap_XAnimSetCompleteGoalWeight(v16, bgs[159154], 1065353216);
  }
  if ( bg_debugAnim[3] == 1 )
  {
    v13 = "torso";
    if ( a3 == a2 + 223 )
      v13 = "legs ";
    Com_Printf("Anim-%s: %i, %s\n", v13, v21, (const char *)&bgs[23 * v21]);
  }
}
// 2A825: conditional instruction was optimized away because of '%var_8.4!=0'
// C13A0: using guessed type int bg;
// C13C0: using guessed type int bgs[];

//----- (0002ABA0) --------------------------------------------------------
void __cdecl sub_2ABA0(_DWORD *a1, int a2, unsigned int a3, int a4)
{
  int v4; // eax
  int v5; // esi
  int v6; // eax
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst6
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst6
  char v18; // fps^1
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  int v22; // eax
  char v23; // fps^1
  long double v24; // fst5
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  unsigned __int16 v28; // ax
  unsigned int v29; // [esp+14h] [ebp-24h]
  int v30; // [esp+1Ch] [ebp-1Ch]
  _BOOL4 v31; // [esp+20h] [ebp-18h]

  v31 = 0;
  v4 = *(_DWORD *)(a2 + 20);
  if ( v4 )
    v31 = (*(_BYTE *)(v4 + 80) & 2) != 0;
  v30 = a1[272];
  Scr_GetAnimsIndex(bgs[159152]);
  v29 = a3;
  BYTE1(v29) = BYTE1(a3) & 0xFD;
  if ( a3 == *(_DWORD *)(a2 + 16) )
  {
    if ( *(_DWORD *)(a2 + 20) )
      goto LABEL_7;
    if ( !v29 )
      return;
  }
  sub_2A600(a4, a1, (_DWORD *)a2, a3, (*(_DWORD *)(a4 + 8) >> 11) & 1);
LABEL_7:
  if ( !v29 )
    return;
  v5 = *(_DWORD *)(a2 + 20);
  if ( *(_DWORD *)(v5 + 68) && (v6 = *(_DWORD *)(a2 + 44)) != 0 )
  {
    if ( *(&bg + 1) != v6 )
    {
      if ( v31 )
        v7 = fabs(*(float *)(a2 + 36) - *(float *)(a4 + 32));
      else
        v7 = VectorDistance((float *)(a2 + 28), (float *)(a4 + 24));
      v8 = v7 / ((long double)(*(&bg + 1) - *(_DWORD *)(a2 + 44)) * 0.001);
      v9 = v8 / (long double)*(int *)(v5 + 68);
      *(float *)(a2 + 40) = v9;
      *(_DWORD *)(a2 + 44) = *(&bg + 1);
      *(float *)(a2 + 28) = *(float *)(a4 + 24);
      *(float *)(a2 + 32) = *(float *)(a4 + 28);
      *(float *)(a2 + 36) = *(float *)(a4 + 32);
      v11 = v9 < 0.1;
      v12 = 0;
      v13 = v9 == 0.1;
      if ( (v10 & 0x45) == 1 )
      {
        v14 = v9 < 0.0099999998;
        v15 = 0;
        v16 = v9 == 0.0099999998;
        if ( (v10 & 0x45) == 1 && v31 )
        {
          *(_DWORD *)(a2 + 40) = 0;
          goto LABEL_30;
        }
        v17 = 0.1;
        goto LABEL_29;
      }
      v19 = v9 > 2.0;
      v20 = 0;
      v21 = 2.0 == v9;
      if ( (v18 & 0x45) != 1 )
        goto LABEL_30;
      if ( (*(_BYTE *)(v5 + 80) & 2) != 0 )
      {
        v24 = 4.0;
      }
      else
      {
        v22 = *(_DWORD *)(v5 + 68);
        if ( v22 > 150 )
        {
          v17 = 2.0;
LABEL_29:
          *(float *)(a2 + 40) = v17;
LABEL_30:
          if ( bg_debugAnim[3] == 2 )
            Com_Printf(
              "MoveSpeed: %s, %i, %4.4f : %1.4f\n",
              (const char *)&bgs[23 * v29],
              bgs[23 * v29 + 17],
              (double)v8,
              *(float *)(a2 + 40));
          goto LABEL_33;
        }
        if ( v22 > 19 )
          v24 = 3.0 - (long double)(v22 - 20) / 130.0;
        else
          v24 = 3.0;
      }
      v25 = v24 < v9;
      v26 = 0;
      v27 = v24 == v9;
      v17 = v24;
      if ( (v23 & 0x45) != 1 )
        goto LABEL_30;
      goto LABEL_29;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 40) = 1065353216;
    *(_DWORD *)(a2 + 44) = *(&bg + 1);
    *(float *)(a2 + 28) = *(float *)(a4 + 24);
    *(float *)(a2 + 32) = *(float *)(a4 + 28);
    *(float *)(a2 + 36) = *(float *)(a4 + 32);
  }
LABEL_33:
  if ( *(_DWORD *)(a2 + 16) )
  {
    v28 = *(_WORD *)(a2 + 16);
    HIBYTE(v28) &= 0xFDu;
    trap_XAnimSetAnimRate(v30, v28, COERCE_INT(*(float *)(a2 + 40)));
  }
}
// 2ACC2: variable 'v10' is possibly undefined
// 2AD02: variable 'v18' is possibly undefined
// 2AD53: variable 'v23' is possibly undefined
// C13A0: using guessed type int bg;
// C13C0: using guessed type int bgs[];

//----- (0002AE00) --------------------------------------------------------
void __cdecl sub_2AE00(float a1, float a2, float a3, float a4, int a5, int a6)
{
  long double v6; // fst7
  char v7; // fps^1
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  long double v11; // fst7
  long double v12; // fst6
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst6
  char v18; // fps^1
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst7
  long double v23; // fst7
  float v24; // [esp-10h] [ebp-48h]
  float v25; // [esp-10h] [ebp-48h]

  if ( !*(_DWORD *)a6 )
  {
    v6 = AngleSubtract(*(float *)a5, a1);
    v8 = a2 < v6;
    v9 = 0;
    v10 = a2 == v6;
    if ( (v7 & 0x45) == 1 || -a2 > v6 )
      *(_DWORD *)a6 = 1;
    if ( !*(_DWORD *)a6 )
      return;
  }
  v11 = AngleSubtract(a1, *(float *)a5);
  v12 = fabs(v11) * 0.050000001;
  if ( v12 < 0.5 )
    v12 = 0.5;
  v14 = v11 > 0.0;
  v15 = 0;
  v16 = 0.0 == v11;
  if ( (unsigned __int8)((v13 & 0x45) - 1) < 0x40u )
  {
    v17 = v12 * (long double)*(&bg + 2) * a4;
    if ( v17 < v11 )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( v11 < 0.0 )
  {
    v17 = v12 * (long double)*(&bg + 2) * -a4;
    v19 = v17 < v11;
    v20 = 0;
    v21 = v17 == v11;
    if ( (unsigned __int8)((v18 & 0x45) - 1) >= 0x40u )
    {
LABEL_14:
      v11 = v17;
      *(_DWORD *)a6 = 1;
      goto LABEL_15;
    }
LABEL_13:
    *(_DWORD *)a6 = 0;
LABEL_15:
    v24 = v11 + *(float *)a5;
    *(float *)a5 = AngleMod(v24);
  }
  v22 = AngleSubtract(a1, *(float *)a5);
  if ( v22 <= a3 )
  {
    if ( -a3 <= v22 )
      return;
    v23 = a3 - 1.0 + a1;
  }
  else
  {
    v23 = a1 - (a3 - 1.0);
  }
  v25 = v23;
  *(float *)a5 = AngleMod(v25);
}
// 2AE36: variable 'v7' is possibly undefined
// 2AE9D: variable 'v13' is possibly undefined
// 2AEDC: variable 'v18' is possibly undefined
// C13A0: using guessed type int bg;

//----- (0002AF78) --------------------------------------------------------
void __cdecl sub_2AF78(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // ebx
  long double v5; // fst7
  long double v6; // fst6
  int v7; // eax
  long double v8; // fst7
  int v9; // eax
  int v10; // eax
  long double v11; // fst7
  long double v12; // fst7
  long double v13; // fst7
  long double v14; // fst7
  float v15; // [esp-20h] [ebp-78h]
  float v16; // [esp-20h] [ebp-78h]
  float v17; // [esp-1Ch] [ebp-74h]
  float v18; // [esp-18h] [ebp-70h]
  float v19; // [esp-18h] [ebp-70h]
  float v20; // [esp-14h] [ebp-6Ch]
  int v21; // [esp-10h] [ebp-68h]
  int v22; // [esp-Ch] [ebp-64h]
  int v23; // [esp+20h] [ebp-38h]
  int v24; // [esp+24h] [ebp-34h]
  int v25; // [esp+28h] [ebp-30h]
  int v26; // [esp+2Ch] [ebp-2Ch]
  float v27; // [esp+30h] [ebp-28h]
  float v28; // [esp+34h] [ebp-24h]
  float v29; // [esp+38h] [ebp-20h]
  float v30; // [esp+44h] [ebp-14h]
  float v31; // [esp+50h] [ebp-8h]

  GetLeanFraction(*(float *)(a2 + 992));
  v27 = *(float *)(a2 + 988);
  v28 = *(float *)(a2 + 996);
  v29 = AngleMod(*(float *)(a2 + 1000));
  if ( (*(_BYTE *)(a1 + 9) & 0xC0) != 0 || (v2 = *(_DWORD *)(a2 + 1040), (v2 & 0x30000) != 0) || (v2 & 6) == 0 )
  {
    *(_DWORD *)(a2 + 944) = 1;
    *(_DWORD *)(a2 + 952) = 1;
    *(_DWORD *)(a2 + 896) = 1;
    v25 = a2 + 944;
    v26 = a2 + 940;
    v23 = a2 + 952;
    v24 = a2 + 948;
  }
  else
  {
    v3 = *(_DWORD *)(a2 + 1064);
    if ( dword_7B660 )
    {
      v25 = a2 + 944;
      v26 = a2 + 940;
      v23 = a2 + 952;
      v24 = a2 + 948;
    }
    else
    {
      v4 = 0;
      v25 = a2 + 944;
      v26 = a2 + 940;
      v23 = a2 + 952;
      v24 = a2 + 948;
      while ( !Com_BitCheck(a2 + 1064, v4) )
      {
        if ( (unsigned int)++v4 > 0x3F )
          goto LABEL_14;
      }
      v3 = v4;
    }
    if ( v3 )
    {
      *(_DWORD *)(a2 + 944) = 1;
      *(_DWORD *)(a2 + 952) = 1;
    }
  }
LABEL_14:
  v5 = v29;
  v6 = v29 + v27;
  v31 = v6;
  v7 = *(_DWORD *)(a1 + 8);
  if ( (v7 & 1) != 0 )
  {
    v31 = v29;
LABEL_22:
    v30 = v5;
    v8 = 90.0;
    goto LABEL_24;
  }
  if ( (*(_BYTE *)(a2 + 1042) & 3) != 0 )
  {
    v30 = v6;
    v8 = 0.0;
    goto LABEL_24;
  }
  if ( (v7 & 0x40) != 0 )
    goto LABEL_22;
  if ( (v7 & 0x400) == 0 )
  {
    if ( (v7 & 0x200) == 0 )
      v5 = v5 + v27 * 0.30000001;
    goto LABEL_22;
  }
  v30 = v29;
  v8 = 45.0;
LABEL_24:
  v18 = v8;
  sub_2AE00(v30, 0.0, v18, bg_swingSpeed[2], v26, v25);
  v9 = *(_DWORD *)(a1 + 8);
  if ( (v9 & 1) != 0 )
    goto LABEL_30;
  if ( (v9 & 0x40) != 0 )
  {
    *(_DWORD *)(a2 + 896) = 0;
    *(float *)(a2 + 892) = v27 + v29;
    goto LABEL_34;
  }
  v10 = *(_DWORD *)(a1 + 204);
  BYTE1(v10) &= 0xFDu;
  if ( (bgs[23 * v10 + 20] & 0x30) == 0 )
  {
    if ( !*(_DWORD *)(a2 + 896) )
    {
      v22 = a2 + 896;
      v21 = a2 + 892;
      v20 = bg_swingSpeed[2];
      v19 = 150.0;
      v17 = 40.0;
      goto LABEL_32;
    }
LABEL_30:
    v22 = a2 + 896;
    v21 = a2 + 892;
    v20 = bg_swingSpeed[2];
    v19 = 150.0;
    v17 = 0.0;
LABEL_32:
    v11 = v31;
    goto LABEL_33;
  }
  *(_DWORD *)(a2 + 896) = 0;
  v22 = a2 + 896;
  v21 = a2 + 892;
  v20 = bg_swingSpeed[2];
  v11 = v29;
  v19 = 150.0;
  v17 = 0.0;
LABEL_33:
  v15 = v11;
  sub_2AE00(v15, v17, v19, v20, v21, v22);
LABEL_34:
  if ( (*(_BYTE *)(a1 + 9) & 0xC0) != 0 )
  {
    v12 = v29;
LABEL_38:
    *(float *)(a2 + 940) = v12;
    *(float *)(a2 + 892) = v12;
    goto LABEL_39;
  }
  if ( (*(_BYTE *)(a2 + 1042) & 3) != 0 )
  {
    v12 = v27 + v29;
    goto LABEL_38;
  }
LABEL_39:
  if ( (*(_BYTE *)(a1 + 8) & 1) != 0 || (*(_BYTE *)(a1 + 9) & 0xC0) != 0 || (*(_BYTE *)(a2 + 1042) & 3) != 0 )
  {
    v13 = 0.0;
  }
  else
  {
    v14 = v28;
    if ( v28 > 180.0 )
      v14 = v14 + -360.0;
    v13 = v14 * 0.60000002;
  }
  v16 = v13;
  sub_2AE00(v16, 0.0, 45.0, 0.15000001, v24, v23);
}
// 7B660: using guessed type int dword_7B660;
// C13C0: using guessed type int bgs[];

//----- (0002B328) --------------------------------------------------------
int __cdecl sub_2B328(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // edx
  int v21; // eax
  char v22; // fps^1
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  int v26; // eax
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // edx
  int v31; // eax
  int v32; // eax
  int v33; // edx
  int v34; // eax
  int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // eax
  int v39; // edx
  int v40; // eax
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int v44; // eax
  int v45; // edx
  int v46; // eax
  int result; // eax
  int v48; // eax
  int v49; // edx
  int v50; // eax
  int v51; // eax
  int v52; // edx
  int v53; // eax

  v2 = *(_DWORD *)(a1 + 144);
  v3 = *(_DWORD *)(a1 + 200);
  if ( dword_7B630[0] )
  {
    bgs[274 * v2 + 159417] = v3;
  }
  else
  {
    v4 = 274 * v2;
    bgs[v4 + 159417] = 0;
    bgs[v4 + 159418] = 0;
    Com_BitSet((int)&bgs[v4 + 159417], v3);
  }
  v5 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
  v6 = *(_DWORD *)(a1 + 144);
  v7 = *(_DWORD *)(v5 + 116);
  if ( dword_7B638 )
  {
    bgs[274 * v6 + 159419] = v7;
  }
  else
  {
    v8 = 274 * v6;
    v9 = v8 * 4 + 8;
    *(int *)((char *)&bgs[159417] + v9) = 0;
    *(int *)((char *)&bgs[159418] + v9) = 0;
    Com_BitSet((int)&bgs[v8 + 159419], v7);
  }
  if ( (*(_BYTE *)(a1 + 9) & 2) != 0 )
  {
    v10 = *(_DWORD *)(a1 + 144);
    if ( dword_7B668 )
    {
      bgs[274 * v10 + 159431] = 1;
    }
    else
    {
      v11 = 274 * v10;
      v12 = 1096 * v10 + 56;
      *(int *)((char *)&bgs[159417] + v12) = 0;
      *(int *)((char *)&bgs[159418] + v12) = 0;
      Com_BitSet((int)&bgs[v11 + 159431], 1);
    }
  }
  else
  {
    v13 = *(_DWORD *)(a1 + 144);
    if ( dword_7B668 )
    {
      bgs[274 * v13 + 159431] = 0;
    }
    else
    {
      v14 = 274 * v13;
      v15 = 1096 * v13 + 56;
      *(int *)((char *)&bgs[159417] + v15) = 0;
      *(int *)((char *)&bgs[159418] + v15) = 0;
      Com_BitSet((int)&bgs[v14 + 159431], 0);
    }
  }
  if ( (*(_BYTE *)(a1 + 9) & 0xC0) != 0 )
  {
    v16 = *(_DWORD *)(a1 + 144);
    if ( dword_7B640 )
    {
      bgs[274 * v16 + 159421] = 1;
    }
    else
    {
      v17 = 274 * v16;
      v18 = 1096 * v16 + 16;
      *(int *)((char *)&bgs[159417] + v18) = 0;
      *(int *)((char *)&bgs[159418] + v18) = 0;
      Com_BitSet((int)&bgs[v17 + 159421], 1);
    }
  }
  else
  {
    v19 = *(_DWORD *)(a1 + 144);
    if ( dword_7B640 )
    {
      bgs[274 * v19 + 159421] = 0;
    }
    else
    {
      v20 = 274 * v19;
      v21 = 1096 * v19 + 16;
      *(int *)((char *)&bgs[159417] + v21) = 0;
      *(int *)((char *)&bgs[159418] + v21) = 0;
      Com_BitSet((int)&bgs[v20 + 159421], 0);
    }
  }
  v23 = *(float *)(a2 + 996) > 0.0;
  v24 = 0;
  v25 = 0.0 == *(float *)(a2 + 996);
  v26 = *(_DWORD *)(a1 + 144);
  if ( dword_7B650 )
  {
    bgs[274 * v26 + 159425] = (v22 & 0x45) == 1;
  }
  else
  {
    v27 = 274 * v26;
    v28 = 1096 * v26 + 32;
    *(int *)((char *)&bgs[159417] + v28) = 0;
    *(int *)((char *)&bgs[159418] + v28) = 0;
    Com_BitSet((int)&bgs[v27 + 159425], (v22 & 0x45) == 1);
  }
  if ( (*(_BYTE *)(a1 + 8) & 0x20) != 0 )
  {
    v29 = *(_DWORD *)(a1 + 144);
    if ( dword_7B658 )
    {
      bgs[274 * v29 + 159427] = 1;
    }
    else
    {
      v30 = 274 * v29;
      v31 = 1096 * v29 + 40;
      *(int *)((char *)&bgs[159417] + v31) = 0;
      *(int *)((char *)&bgs[159418] + v31) = 0;
      Com_BitSet((int)&bgs[v30 + 159427], 1);
    }
  }
  else
  {
    v32 = *(_DWORD *)(a1 + 144);
    if ( dword_7B658 )
    {
      bgs[274 * v32 + 159427] = 0;
    }
    else
    {
      v33 = 274 * v32;
      v34 = 1096 * v32 + 40;
      *(int *)((char *)&bgs[159417] + v34) = 0;
      *(int *)((char *)&bgs[159418] + v34) = 0;
      Com_BitSet((int)&bgs[v33 + 159427], 0);
    }
  }
  if ( (*(_BYTE *)(a1 + 9) & 4) != 0 )
  {
    v35 = *(_DWORD *)(a1 + 144);
    if ( dword_7B660 )
    {
      bgs[274 * v35 + 159429] = 1;
    }
    else
    {
      v36 = 274 * v35;
      v37 = 1096 * v35 + 48;
      *(int *)((char *)&bgs[159417] + v37) = 0;
      *(int *)((char *)&bgs[159418] + v37) = 0;
      Com_BitSet((int)&bgs[v36 + 159429], 1);
    }
  }
  else
  {
    v38 = *(_DWORD *)(a1 + 144);
    if ( dword_7B660 )
    {
      bgs[274 * v38 + 159429] = 0;
    }
    else
    {
      v39 = 274 * v38;
      v40 = 1096 * v38 + 48;
      *(int *)((char *)&bgs[159417] + v40) = 0;
      *(int *)((char *)&bgs[159418] + v40) = 0;
      Com_BitSet((int)&bgs[v39 + 159429], 0);
    }
  }
  v41 = *(_DWORD *)(a1 + 204);
  BYTE1(v41) &= 0xFDu;
  v42 = bgs[23 * v41 + 21];
  if ( v42 )
    bgs[274 * *(_DWORD *)(a1 + 144) + 159423] = v42;
  v43 = bgs[23 * v41 + 20];
  if ( (v43 & 0x10) != 0 )
  {
    v44 = *(_DWORD *)(a1 + 144);
    if ( dword_7B670 )
    {
      result = 1096 * v44;
      *(int *)((char *)&bgs[159433] + result) = 1;
    }
    else
    {
      v45 = 274 * v44;
      v46 = 1096 * v44 + 64;
      *(int *)((char *)&bgs[159417] + v46) = 0;
      *(int *)((char *)&bgs[159418] + v46) = 0;
      result = Com_BitSet((int)&bgs[v45 + 159433], 1);
    }
  }
  else if ( (v43 & 0x20) != 0 )
  {
    v48 = *(_DWORD *)(a1 + 144);
    if ( dword_7B670 )
    {
      result = 1096 * v48;
      *(int *)((char *)&bgs[159433] + result) = 2;
    }
    else
    {
      v49 = 274 * v48;
      v50 = 1096 * v48 + 64;
      *(int *)((char *)&bgs[159417] + v50) = 0;
      *(int *)((char *)&bgs[159418] + v50) = 0;
      result = Com_BitSet((int)&bgs[v49 + 159433], 2);
    }
  }
  else
  {
    v51 = *(_DWORD *)(a1 + 144);
    if ( dword_7B670 )
    {
      result = 1096 * v51;
      *(int *)((char *)&bgs[159433] + result) = 0;
    }
    else
    {
      v52 = 274 * v51;
      v53 = 1096 * v51 + 64;
      *(int *)((char *)&bgs[159417] + v53) = 0;
      *(int *)((char *)&bgs[159418] + v53) = 0;
      result = Com_BitSet((int)&bgs[v52 + 159433], 0);
    }
  }
  return result;
}
// 2B531: variable 'v22' is possibly undefined
// 7B630: using guessed type int dword_7B630[];
// 7B638: using guessed type int dword_7B638;
// 7B640: using guessed type int dword_7B640;
// 7B650: using guessed type int dword_7B650;
// 7B658: using guessed type int dword_7B658;
// 7B660: using guessed type int dword_7B660;
// 7B668: using guessed type int dword_7B668;
// 7B670: using guessed type int dword_7B670;
// C13C0: using guessed type int bgs[];

//----- (0002B7F8) --------------------------------------------------------
int __cdecl BG_Player_DoControllers(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst5
  long double v14; // fst6
  int v15; // eax
  long double v16; // fst6
  long double v17; // fst6
  int v18; // eax
  char v19; // fps^1
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst6
  char v24; // fps^1
  long double v25; // fst6
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  char v29; // fps^1
  long double v30; // fst5
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  long double v34; // fst7
  long double v35; // fst7
  long double v36; // fst6
  char v37; // fps^1
  long double v38; // fst6
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  char v42; // fps^1
  long double v43; // fst5
  bool v44; // c0
  char v45; // c2
  bool v46; // c3
  long double v47; // fst7
  long double v48; // fst7
  char v49; // fps^1
  long double v50; // fst6
  bool v51; // c0
  char v52; // c2
  bool v53; // c3
  char v54; // fps^1
  long double v55; // fst5
  bool v56; // c0
  char v57; // c2
  bool v58; // c3
  long double v59; // fst7
  float v60; // [esp-10h] [ebp-88h]
  float v61; // [esp-10h] [ebp-88h]
  float v62; // [esp-10h] [ebp-88h]
  float v63; // [esp-10h] [ebp-88h]
  long double v64; // [esp+18h] [ebp-60h]
  float v65; // [esp+3Ch] [ebp-3Ch] BYREF
  float v66; // [esp+40h] [ebp-38h]
  float v67; // [esp+44h] [ebp-34h]
  float v68; // [esp+48h] [ebp-30h] BYREF
  float v69; // [esp+4Ch] [ebp-2Ch]
  float v70; // [esp+50h] [ebp-28h]
  float v71; // [esp+54h] [ebp-24h] BYREF
  float v72; // [esp+58h] [ebp-20h]
  float v73; // [esp+5Ch] [ebp-1Ch]
  float v74; // [esp+60h] [ebp-18h] BYREF
  float v75; // [esp+64h] [ebp-14h]
  float v76; // [esp+68h] [ebp-10h]
  int v77; // [esp+6Ch] [ebp-Ch] BYREF
  float v78; // [esp+70h] [ebp-8h]
  float v79; // [esp+74h] [ebp-4h]

  result = a2;
  if ( (*(_BYTE *)(a2 + 9) & 0xC0) == 0 )
  {
    v73 = 0.0;
    v71 = 0.0;
    v70 = 0.0;
    v68 = 0.0;
    v65 = *(float *)(a4 + 996);
    v66 = *(float *)(a4 + 1000);
    v67 = *(float *)(a4 + 1004);
    v72 = *(float *)(a4 + 892);
    v69 = *(float *)(a4 + 940);
    if ( (*(_BYTE *)(a4 + 1042) & 3) == 0 )
    {
      v5 = *(float *)(a4 + 948);
      v68 = *(float *)(a4 + 948);
      if ( (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
      {
        v60 = v5;
        v6 = AngleNormalize180(v60);
        v68 = v6;
        if ( v6 <= 0.0 )
          v7 = v6 * 0.25;
        else
          v7 = v6 * 0.5;
        v68 = v7;
      }
    }
    AnglesSubtract(&v65, &v68, &v65);
    AnglesSubtract(&v68, &v71, &v68);
    v77 = 0;
    v78 = 0.0;
    v79 = *(float *)(a2 + 228);
    v8 = GetLeanFraction(*(float *)(a4 + 992));
    v10 = v8 > 0.0;
    v11 = 0;
    v12 = 0.0 == v8;
    if ( (v9 & 0x45) == 64 )
    {
      v70 = 0.0;
      v67 = 0.0;
    }
    else
    {
      v13 = v8 * 50.0 * 0.92500001;
      v70 = v13;
      if ( (*(_BYTE *)(a2 + 8) & 0x20) != 0 )
      {
        if ( v8 <= 0.0 )
          v14 = v13 * 1.8;
        else
          v14 = v13 * 1.5;
        v70 = v14;
      }
      v15 = *(_DWORD *)(a2 + 8);
      if ( (v15 & 0x40) != 0 )
      {
        v16 = -v8 * 2.5;
      }
      else if ( (v15 & 0x20) != 0 )
      {
        v16 = -v8 * 1.5;
      }
      else
      {
        v16 = -v8;
      }
      v78 = v16;
      v17 = v8 * 50.0 * 0.92500001;
      v67 = v17;
      v18 = *(_DWORD *)(a2 + 8);
      if ( (v18 & 0x20) != 0 )
      {
        v20 = v8 > 0.0;
        v21 = 0;
        v22 = 0.0 == v8;
        if ( (v19 & 0x45) == 1 )
          v23 = v17 * 1.5;
        else
          v23 = v17 * 1.8;
        v67 = v23;
      }
      else if ( (v18 & 0x40) != 0 )
      {
        v67 = v17 * 0.5;
      }
    }
    if ( (*(_BYTE *)(a2 + 8) & 1) == 0 )
    {
      v64 = v8;
      v72 = AngleSubtract(v72, *(float *)(a4 + 1000));
      v8 = v64;
    }
    if ( (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
      v71 = v71 + *(float *)(a2 + 232);
    else
      v73 = v8 * 50.0 * 0.075000003 + v73;
    G_DObjSetLocalTag(a1, a3, (int)"tag_origin", (float *)&v77, &v71);
    if ( (*(_BYTE *)(a2 + 8) & 0x40) != 0 )
    {
      v74 = 0.0;
      v76 = v70 * 0.30000001;
      v75 = v70 * -1.2;
      v25 = *(float *)(a2 + 232);
      v26 = v25 < 0.0;
      v27 = 0;
      v28 = v25 == 0.0;
      if ( (v24 & 0x44) != 0x40 )
      {
        v34 = *(float *)(a2 + 232);
      }
      else
      {
        v30 = *(float *)(a2 + 236);
        v31 = v30 < 0.0;
        v32 = 0;
        v33 = v30 == 0.0;
        v34 = *(float *)(a2 + 232);
        if ( (v29 & 0x45) == 64 )
        {
LABEL_38:
          G_DObjSetControlTagAngles(a1, a3, (int)"back_low", &v74);
          v36 = v70 * 0.2;
          v74 = 0.0;
          v76 = v36;
          v75 = v69 * 0.1 - v36;
          G_DObjSetControlTagAngles(a1, a3, (int)"back_mid", &v74);
          v74 = v68;
          v76 = v70 * -0.2;
          v75 = v69 * 0.80000001 - -v70;
          goto LABEL_45;
        }
      }
      v61 = v34;
      v35 = AngleSubtract(v61, *(float *)(a2 + 236));
      v74 = v35 + v74;
      goto LABEL_38;
    }
    v74 = v68 * 0.2;
    v75 = v69 * 0.40000001;
    v76 = v70 * 0.5;
    v38 = *(float *)(a2 + 232);
    v39 = v38 < 0.0;
    v40 = 0;
    v41 = v38 == 0.0;
    if ( (v37 & 0x44) != 0x40 )
    {
      v47 = *(float *)(a2 + 232);
    }
    else
    {
      v43 = *(float *)(a2 + 236);
      v44 = v43 < 0.0;
      v45 = 0;
      v46 = v43 == 0.0;
      v47 = *(float *)(a2 + 232);
      if ( (v42 & 0x45) == 64 )
      {
LABEL_44:
        G_DObjSetControlTagAngles(a1, a3, (int)"back_low", &v74);
        v74 = v68 * 0.30000001;
        v75 = v69 * 0.40000001;
        v76 = v70 * 0.5;
        G_DObjSetControlTagAngles(a1, a3, (int)"back_mid", &v74);
        v75 = v69 * 0.2;
        v74 = 0.5 * v68;
        v76 = v70 * -0.60000002;
LABEL_45:
        G_DObjSetControlTagAngles(a1, a3, (int)"back_up", &v74);
        v76 = 0.0;
        v74 = v65 * 0.30000001;
        v75 = 0.30000001 * v66;
        G_DObjSetControlTagAngles(a1, a3, (int)"neck", &v74);
        v75 = 0.69999999 * v66;
        v74 = v65 * 0.69999999;
        v76 = v67 * -0.30000001;
        G_DObjSetControlTagAngles(a1, a3, (int)"head", &v74);
        v67 = 0.0;
        v66 = 0.0;
        v65 = 0.0;
        v50 = *(float *)(a2 + 236);
        v51 = v50 < 0.0;
        v52 = 0;
        v53 = v50 == 0.0;
        if ( (v49 & 0x44) != 0x40 )
        {
          v59 = *(float *)(a2 + 236);
        }
        else
        {
          v55 = *(float *)(a2 + 232);
          v56 = v55 < 0.0;
          v57 = 0;
          v58 = v55 == 0.0;
          v59 = *(float *)(a2 + 236);
          if ( (v54 & 0x45) == 64 )
            return G_DObjSetControlTagAngles(a1, a3, (int)"pelvis", &v65);
        }
        v63 = v59;
        v65 = AngleSubtract(v63, *(float *)(a2 + 232));
        return G_DObjSetControlTagAngles(a1, a3, (int)"pelvis", &v65);
      }
    }
    v62 = v47;
    v48 = AngleSubtract(v62, *(float *)(a2 + 236));
    v74 = v48 + v74;
    goto LABEL_44;
  }
  return result;
}
// 2B90D: variable 'v9' is possibly undefined
// 2B9A8: variable 'v19' is possibly undefined
// 2BAB4: variable 'v24' is possibly undefined
// 2BAC6: variable 'v29' is possibly undefined
// 2BBB5: variable 'v37' is possibly undefined
// 2BBCA: variable 'v42' is possibly undefined
// 2BD18: variable 'v49' is possibly undefined
// 2BD2D: variable 'v54' is possibly undefined

//----- (0002BD80) --------------------------------------------------------
int __cdecl BG_UpdatePlayerDObj(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // edi
  int v6; // esi
  int v7; // ebx
  int v8; // [esp+1Ch] [ebp-7Ch]
  unsigned __int16 v9; // [esp+28h] [ebp-70h]
  int v10; // [esp+2Ch] [ebp-6Ch]
  int i; // [esp+30h] [ebp-68h]
  int v12; // [esp+34h] [ebp-64h]
  int v13; // [esp+38h] [ebp-60h] BYREF
  int v14; // [esp+3Ch] [ebp-5Ch]
  __int16 v15[44]; // [esp+40h] [ebp-58h]

  v3 = trap_DObjExists(a1);
  v12 = *(_DWORD *)(a2 + 200);
  if ( (*(_BYTE *)(a2 + 9) & 0xC0) != 0 )
    v12 = 0;
  if ( !*(_DWORD *)a3 || !*(_BYTE *)(a3 + 60) )
    return trap_SafeDObjFree(*(_DWORD *)a2, 1);
  if ( v3 )
  {
    result = a3;
    if ( *(_DWORD *)(a3 + 1092) == v12 && !*(_DWORD *)(a3 + 1012) )
      return result;
    trap_SafeDObjFree(*(_DWORD *)a2, 0);
  }
  v10 = *(_DWORD *)(a3 + 1088);
  v15[0] = 0;
  v13 = trap_XModelGet(a3 + 60);
  v14 = 0;
  v9 = 1;
  v5 = a3 + 508;
  v6 = a3 + 124;
  v8 = 0;
  v7 = 6;
  for ( i = 5; i >= 0; --i )
  {
    if ( *(_BYTE *)(a3 + 124 + v8) )
    {
      v15[v7] = 0;
      *(int *)((char *)&v13 + v7 * 2) = trap_XModelGet(v6);
      *(int *)((char *)&v14 + v7 * 2) = v5;
      v7 += 6;
      ++v9;
    }
    v5 += 64;
    v6 += 64;
    v8 += 64;
  }
  trap_DObjCreate((int)&v13, v9, v10);
  result = a3;
  *(_DWORD *)(a3 + 1092) = v12;
  *(_DWORD *)(a3 + 1012) = 0;
  return result;
}

//----- (0002BEF0) --------------------------------------------------------
int __cdecl BG_PlayAnimName(int a1, char *src, int a3, int a4, int a5, int a6)
{
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int result; // eax
  int v13; // [esp+14h] [ebp-4h]

  v6 = BG_AnimationIndexForString(src);
  v13 = 0;
  v7 = *(_DWORD *)&dest[92 * v6 + 72] + 50;
  if ( a3 != 2 )
  {
    if ( (unsigned int)a3 > 2 )
    {
      if ( a3 != 3 )
        goto LABEL_26;
    }
    else if ( a3 != 1 )
    {
      goto LABEL_26;
    }
    if ( *(int *)(a1 + 108) > 49 && !a6 )
      goto LABEL_15;
    if ( a5 && (v8 = *(_DWORD *)(a1 + 112), BYTE1(v8) &= 0xFDu, v8 == v6) )
    {
      if ( !a4 || dest[92 * v6 + 80] >= 0 )
        goto LABEL_15;
    }
    else
    {
      v13 = 1;
      v9 = *(_DWORD *)(a1 + 112) & 0x200;
      BYTE1(v9) ^= 2u;
      *(_DWORD *)(a1 + 112) = v6 | v9;
      if ( !a4 )
      {
LABEL_15:
        if ( a3 != 3 )
          goto LABEL_26;
        v6 = 0;
        goto LABEL_17;
      }
    }
    *(_DWORD *)(a1 + 108) = v7;
    goto LABEL_15;
  }
LABEL_17:
  if ( *(int *)(a1 + 116) > 49 && !a6 )
    goto LABEL_26;
  if ( a5 && (v10 = *(_DWORD *)(a1 + 120), BYTE1(v10) &= 0xFDu, v10 == v6) )
  {
    if ( !a4 || dest[92 * v6 + 80] >= 0 )
      goto LABEL_26;
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 120) & 0x200;
    BYTE1(v11) ^= 2u;
    *(_DWORD *)(a1 + 120) = v6 | v11;
    if ( !a4 )
      goto LABEL_26;
  }
  *(_DWORD *)(a1 + 116) = v7;
LABEL_26:
  result = v7;
  if ( !v13 )
    result = -1;
  return result;
}

//----- (0002C008) --------------------------------------------------------
char *__cdecl BG_GetAnimString(int a1, unsigned int a2)
{
  if ( a2 >= *((_DWORD *)dest + 11776) )
    BG_AnimParseError("BG_GetAnimString: anim index is out of range");
  return &dest[92 * a2];
}

//----- (0002C03C) --------------------------------------------------------
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  if ( !a4 || dword_7B630[2 * a2] )
  {
    result = 1096 * a1;
    bgs[274 * a1 + 159417 + 2 * a2] = a3;
  }
  else
  {
    v4 = 1096 * a1 + 8 * a2;
    *(int *)((char *)&bgs[159417] + v4) = 0;
    *(int *)((char *)&bgs[159418] + v4) = 0;
    result = Com_BitSet((int)&bgs[159417] + v4, a3);
  }
  return result;
}
// 7B630: using guessed type int dword_7B630[];
// C13C0: using guessed type int bgs[];

//----- (0002C0A8) --------------------------------------------------------
char *__cdecl BG_GetAnimationForIndex(int a1, unsigned int a2)
{
  if ( a2 >= *((_DWORD *)dest + 11776) )
    Com_Error(1, (char *)&byte_6EE20);
  return &dest[92 * a2];
}

//----- (0002C0E0) --------------------------------------------------------
int BG_FindAnims()
{
  Scr_FindAnim((int)"multiplayer", (int)"root", (int)&bgs[159159]);
  Scr_FindAnim((int)"multiplayer", (int)"torso", (int)&bgs[159160]);
  Scr_FindAnim((int)"multiplayer", (int)"legs", (int)&bgs[159161]);
  return Scr_FindAnim((int)"multiplayer", (int)"turning", (int)&bgs[159162]);
}
// C13C0: using guessed type int bgs[];

//----- (0002C14C) --------------------------------------------------------
int BG_FindAnimTrees()
{
  int v0; // ebx
  int result; // eax
  int v2; // [esp+14h] [ebp-4h] BYREF

  Scr_FindAnimTree(&v2, (int)"multiplayer");
  v0 = v2;
  if ( !v2 )
    Com_Error(1, (char *)&byte_6F000, "multiplayer");
  bgs[159153] = bgs[159160];
  bgs[159154] = bgs[159161];
  result = bgs[159162];
  bgs[159158] = v0;
  bgs[159152] = v0;
  bgs[159155] = result;
  return result;
}
// C13C0: using guessed type int bgs[];

//----- (0002C1B4) --------------------------------------------------------
int BG_LoadAnimTreeInstances()
{
  int v0; // esi
  int *v1; // ebx
  int result; // eax

  v0 = bgs[159158];
  v1 = &bgs[159435];
  do
  {
    result = trap_XAnimCreateTree(v0);
    *v1 = result;
    v1 += 274;
  }
  while ( (int)v1 <= (int)&bgs[176697] );
  return result;
}
// C13C0: using guessed type int bgs[];

//----- (0002C1F4) --------------------------------------------------------
void __cdecl BG_PlayerAnimation(int a1, int a2, int a3)
{
  unsigned __int16 v3; // ax
  long double v4; // fst7
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  unsigned __int16 v9; // ax
  long double v10; // fst7
  char v11; // fps^1
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  int v15; // [esp+14h] [ebp-4h]

  sub_2AF78(a2, a3);
  sub_2B328(a2, a3);
  v15 = *(_DWORD *)(a3 + 1088);
  Scr_GetAnimsIndex(bgs[159152]);
  if ( *(_DWORD *)(a3 + 908) )
  {
    v3 = *(_WORD *)(a3 + 908);
    HIBYTE(v3) &= 0xFDu;
    v4 = trap_XAnimGetWeight(v15, v3);
    v6 = v4 > 0.0;
    v7 = 0;
    v8 = 0.0 == v4;
    if ( (v5 & 0x44) == 0x40 )
    {
      *(_DWORD *)(a3 + 908) = 0;
      *(_DWORD *)(a3 + 912) = 0;
      *(_DWORD *)(a3 + 916) = 150;
    }
  }
  Scr_GetAnimsIndex(bgs[159152]);
  if ( *(_DWORD *)(a3 + 956) )
  {
    v9 = *(_WORD *)(a3 + 956);
    HIBYTE(v9) &= 0xFDu;
    v10 = trap_XAnimGetWeight(v15, v9);
    v12 = v10 > 0.0;
    v13 = 0;
    v14 = 0.0 == v10;
    if ( (v11 & 0x44) == 0x40 )
    {
      *(_DWORD *)(a3 + 956) = 0;
      *(_DWORD *)(a3 + 960) = 0;
      *(_DWORD *)(a3 + 964) = 150;
    }
  }
  sub_2ABA0((_DWORD *)a3, a3 + 892, *(_DWORD *)(a2 + 204), a2);
  sub_2ABA0((_DWORD *)a3, a3 + 940, *(_DWORD *)(a2 + 208), a2);
}
// 2C26B: variable 'v5' is possibly undefined
// 2C2D6: variable 'v11' is possibly undefined
// C13C0: using guessed type int bgs[];

//----- (0002C338) --------------------------------------------------------
int __cdecl BG_PlayAnim(int *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  int v7; // ecx
  int v8; // esi
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int result; // eax
  int v14; // [esp+14h] [ebp-4h]

  v7 = a2;
  v14 = 0;
  if ( a4 )
    v8 = a4;
  else
    v8 = *(_DWORD *)&dest[92 * a2 + 72] + 50;
  if ( a3 != 2 )
  {
    if ( a3 > 2 )
    {
      if ( a3 != 3 )
        goto LABEL_29;
    }
    else if ( a3 != 1 )
    {
      goto LABEL_29;
    }
    if ( a1[27] > 49 && !a7 )
      goto LABEL_18;
    if ( a6 && (v9 = a1[28], BYTE1(v9) &= 0xFDu, v9 == a2) )
    {
      if ( !a5 || dest[92 * a2 + 80] >= 0 )
        goto LABEL_18;
    }
    else
    {
      v14 = 1;
      v10 = a1[28] & 0x200;
      BYTE1(v10) ^= 2u;
      a1[28] = a2 | v10;
      if ( !a5 )
      {
LABEL_18:
        if ( a3 != 3 )
          goto LABEL_29;
        v7 = 0;
        goto LABEL_20;
      }
    }
    a1[27] = v8;
    goto LABEL_18;
  }
LABEL_20:
  if ( a1[29] > 49 && !a7 )
    goto LABEL_29;
  if ( a6 && (v11 = a1[30], BYTE1(v11) &= 0xFDu, v11 == v7) )
  {
    if ( !a5 || dest[92 * v7 + 80] >= 0 )
      goto LABEL_29;
  }
  else
  {
    v12 = a1[30] & 0x200;
    BYTE1(v12) ^= 2u;
    a1[30] = v7 | v12;
    if ( !a5 )
      goto LABEL_29;
  }
  a1[29] = v8;
LABEL_29:
  if ( v14 )
    result = v8;
  else
    result = -1;
  return result;
}

//----- (0002C450) --------------------------------------------------------
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, unsigned int a2)
{
  unsigned int v2; // ebx

  v2 = a2;
  BYTE1(v2) = BYTE1(a2) & 0xFD;
  if ( v2 >= *((_DWORD *)dest + 11776) )
    Com_Error(1, (char *)&byte_6EE20);
  return (dest[92 * v2 + 84] & 0xC4) != 0;
}

//----- (0002C49C) --------------------------------------------------------
_BOOL4 __cdecl BG_IsProneAnim(int a1, unsigned int a2)
{
  unsigned int v2; // ebx

  v2 = a2;
  BYTE1(v2) = BYTE1(a2) & 0xFD;
  if ( v2 >= *((_DWORD *)dest + 11776) )
    Com_Error(1, (char *)&byte_6EE20);
  return (*(_DWORD *)&dest[92 * v2 + 84] & 0x308) != 0;
}

//----- (0002C4F0) --------------------------------------------------------
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  int v4; // ebx
  int v5; // eax

  v3 = *(_DWORD *)(a1 + 140);
  if ( v3 <= 0 || v3 >= bg_numItems )
    Com_Error(1, (char *)&byte_70000);
  v4 = 12 * *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) == a2[43] )
    return 0;
  v5 = bg_itemlist[v4 + 8];
  switch ( v5 )
  {
    case 1:
      if ( !Com_BitCheck((int)(a2 + 195), bg_itemlist[v4 + 9]) )
        return !a3;
      return BG_GetMaxPickupableAmmo((int)a2, bg_itemlist[v4 + 9]) > 0;
    case 0:
      Com_Error(1, (char *)&byte_70029);
      return 0;
    case 2:
      if ( !Com_BitCheck((int)(a2 + 195), bg_itemlist[v4 + 9]) && !BG_WeaponIsClipOnly(bg_itemlist[v4 + 9]) )
        return 0;
      return BG_GetMaxPickupableAmmo((int)a2, bg_itemlist[v4 + 9]) > 0;
  }
  return v5 == 3 && a2[61] < a2[63];
}
// 70804: using guessed type int bg_numItems;

//----- (0002C600) --------------------------------------------------------
void __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3)
{
  int v3; // eax
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst5
  long double v10; // fst6
  long double v11; // fst7
  long double v12; // fst7
  int v13; // ecx
  int v14; // edi
  long double v15; // fst7
  long double v16; // fst6
  int v17; // ecx
  int v18; // edi
  long double v19; // fst6
  long double v20; // fst4
  long double v21; // fst5
  long double v22; // rt1
  long double v23; // fst6
  long double v24; // [esp+18h] [ebp-40h]
  long double v25; // [esp+18h] [ebp-40h]
  float v26; // [esp+44h] [ebp-14h]
  float v27; // [esp+44h] [ebp-14h]
  float v28; // [esp+44h] [ebp-14h]

  v3 = a2;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 8:
      *a3 = *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 20);
      return;
    case 2:
      v4 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      goto LABEL_9;
    case 3:
      if ( a2 > *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4) )
        v3 = *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4);
      v4 = (long double)(v3 - *(_DWORD *)(a1 + 4)) * 0.001;
      if ( v4 < 0.0 )
        v4 = 0.0;
      goto LABEL_9;
    case 4:
      v5 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(int *)(a1 + 8) * 3.141592653589793;
      v26 = sin(v5 + v5);
      v4 = v26;
LABEL_9:
      *a3 = *(float *)(a1 + 24) * v4 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v4 + *(float *)(a1 + 16);
      v6 = v4 * *(float *)(a1 + 32);
      goto LABEL_18;
    case 5:
      v7 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v7 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v7 + *(float *)(a1 + 16);
      v8 = v7 * 400.0;
      goto LABEL_12;
    case 6:
      v7 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v7 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v7 + *(float *)(a1 + 16);
      v8 = v7 * 120.00001;
LABEL_12:
      v9 = v8;
      v10 = *(float *)(a1 + 32) * v7;
      v11 = v7 * v9;
      goto LABEL_14;
    case 7:
      v12 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v12 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v12 + *(float *)(a1 + 16);
      v10 = *(float *)(a1 + 32) * v12;
      v11 = v12 * 80.0;
LABEL_14:
      a3[2] = v10 + *(float *)(a1 + 20) - v11;
      break;
    case 9:
      v13 = *(_DWORD *)(a1 + 4);
      v14 = *(_DWORD *)(a1 + 8);
      if ( a2 > v14 + v13 )
        v3 = v14 + v13;
      v27 = sqrt(
              *(float *)(a1 + 32) * *(float *)(a1 + 32)
            + *(float *)(a1 + 24) * *(float *)(a1 + 24)
            + *(float *)(a1 + 28) * *(float *)(a1 + 28));
      v24 = (long double)(v3 - v13) * 0.001;
      VectorNormalize2((float *)(a1 + 24), a3);
      v15 = v27 / (0.001 * (long double)v14) * 0.5 * v24 * v24;
      *a3 = *a3 * v15 + *(float *)(a1 + 12);
      v16 = a3[1] * v15;
      v6 = v15 * a3[2];
      a3[1] = v16 + *(float *)(a1 + 16);
LABEL_18:
      a3[2] = v6 + *(float *)(a1 + 20);
      break;
    case 0xA:
      v17 = *(_DWORD *)(a1 + 4);
      v18 = *(_DWORD *)(a1 + 8);
      if ( a2 > v18 + v17 )
        v3 = v18 + v17;
      v28 = sqrt(
              *(float *)(a1 + 32) * *(float *)(a1 + 32)
            + *(float *)(a1 + 24) * *(float *)(a1 + 24)
            + *(float *)(a1 + 28) * *(float *)(a1 + 28));
      v25 = (long double)(v3 - v17) * 0.001;
      VectorNormalize2((float *)(a1 + 24), a3);
      v19 = v25 * (-(v28 / (0.001 * (long double)v18)) * 0.5 * v25);
      v20 = *(float *)(a1 + 32) * v25 + *(float *)(a1 + 20);
      v21 = *(float *)(a1 + 24) * v25 + *(float *)(a1 + 12) + *a3 * v19;
      v22 = v19 * a3[2];
      v23 = a3[1] * v19 + *(float *)(a1 + 28) * v25 + *(float *)(a1 + 16);
      *a3 = v21;
      a3[1] = v23;
      a3[2] = v22 + v20;
      break;
    default:
      Com_Error(1, (char *)&byte_70060, *(_DWORD *)(a1 + 4));
      break;
  }
}

//----- (0002C8E8) --------------------------------------------------------
int __cdecl BG_EvaluateTrajectoryDelta(int a1, int a2, float *a3)
{
  int result; // eax
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+20h] [ebp-8h]

  result = *(_DWORD *)a1;
  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
      goto LABEL_13;
    case 2:
      goto LABEL_4;
    case 3:
      result = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      if ( a2 > result )
        goto LABEL_13;
LABEL_4:
      *a3 = *(float *)(a1 + 24);
      a3[1] = *(float *)(a1 + 28);
      a3[2] = *(float *)(a1 + 32);
      return result;
    case 4:
      v4 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(int *)(a1 + 8) * 3.141592653589793;
      v8 = cos(v4 + v4);
      v5 = v8 * 0.5;
      goto LABEL_11;
    case 5:
      v6 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001 * 800.0;
      goto LABEL_8;
    case 6:
      v6 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001 * 240.00002;
      goto LABEL_8;
    case 7:
      v6 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001 * 160.0;
LABEL_8:
      *a3 = *(float *)(a1 + 24);
      a3[1] = *(float *)(a1 + 28);
      a3[2] = *(float *)(a1 + 32) - v6;
      return result;
    case 9:
      result = *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4);
      if ( a2 > result )
        goto LABEL_13;
      v5 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001 * ((long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001);
LABEL_11:
      *a3 = *(float *)(a1 + 24) * v5;
      a3[1] = *(float *)(a1 + 28) * v5;
      a3[2] = v5 * *(float *)(a1 + 32);
      break;
    case 0xA:
      result = *(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 4);
      if ( a2 <= result )
      {
        v7 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
        *a3 = *(float *)(a1 + 24) * v7;
        a3[1] = *(float *)(a1 + 28) * v7;
        a3[2] = v7 * *(float *)(a1 + 32);
      }
      else
      {
LABEL_13:
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    default:
      result = Com_Error(1, (char *)&byte_700E0, *(_DWORD *)(a1 + 4));
      break;
  }
  return result;
}

//----- (0002CA5C) --------------------------------------------------------
__int16 __cdecl BG_GetMarkDir(float *a1, float *a2, float *a3)
{
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst4
  long double v10; // fst5
  long double v11; // fst3
  long double v12; // fst2
  __int16 v13; // fps
  long double v14; // fst1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  __int16 result; // ax
  __int16 v19; // fps
  long double v20; // fst1
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  float v24; // [esp+1Ch] [ebp-2Ch]
  float v25; // [esp+2Ch] [ebp-1Ch]
  float v26; // [esp+30h] [ebp-18h]
  float v27; // [esp+34h] [ebp-14h]
  float v28; // [esp+38h] [ebp-10h]
  float v29; // [esp+3Ch] [ebp-Ch] BYREF
  float v30; // [esp+40h] [ebp-8h]
  float v31; // [esp+44h] [ebp-4h]

  v24 = 0.30000001;
  v25 = sqrt(a2[1] * a2[1] + *a2 * *a2 + a2[2] * a2[2]);
  if ( v25 >= 1.0 )
  {
    v26 = *a2;
    v27 = a2[1];
    v28 = a2[2];
  }
  else
  {
    v26 = 0.0;
    v27 = 0.0;
    v28 = 1.0;
  }
  v29 = -*a1;
  v30 = -a1[1];
  v31 = -a1[2];
  VectorNormalize(&v29);
  v4 = a2[2] > 0.80000001;
  v5 = 0;
  v6 = 0.80000001 == a2[2];
  if ( (v3 & 0x45) == 1 )
    v24 = 0.69999999;
  v7 = v29;
  v8 = v26;
  v9 = v30;
  v10 = v27;
  v11 = v31;
  v12 = v28;
  v14 = v31 * v28 + v30 * v27 + v29 * v26;
  v15 = v14 < v24;
  v16 = 0;
  v17 = v14 == v24;
  LOBYTE(result) = v13;
  HIBYTE(result) = HIBYTE(v13) & 0x45;
  if ( (HIBYTE(v13) & 0x45) == 1 )
  {
    do
    {
      v29 = v8 * 0.5 + v7;
      v30 = v10 * 0.5 + v9;
      v31 = v12 * 0.5 + v11;
      VectorNormalize(&v29);
      v7 = v29;
      v8 = v26;
      v9 = v30;
      v10 = v27;
      v11 = v31;
      v12 = v28;
      v20 = v31 * v28 + v30 * v27 + v29 * v26;
      v21 = v20 < v24;
      v22 = 0;
      v23 = v20 == v24;
      LOBYTE(result) = v19;
      HIBYTE(result) = HIBYTE(v19) & 0x45;
    }
    while ( (HIBYTE(v19) & 0x45) == 1 );
  }
  *a3 = v29;
  a3[1] = v30;
  a3[2] = v31;
  return result;
}
// 2CB05: variable 'v3' is possibly undefined

//----- (0002CBE8) --------------------------------------------------------
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst5
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst5
  int v9; // eax
  long double v10; // fst7
  long double v11; // fst7
  long double v12; // fst6
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  int v17; // edx
  int v18; // ebx
  int v19; // eax
  int v20; // eax
  int v21; // edx
  int result; // eax
  long double v23; // [esp+18h] [ebp-30h]
  int v24; // [esp+2Ch] [ebp-1Ch]
  int *v25; // [esp+30h] [ebp-18h]
  unsigned __int8 v26; // [esp+3Fh] [ebp-9h]

  if ( (*(_BYTE *)(a1 + 14) & 5) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  *(_DWORD *)(a2 + 12) = 1;
  v3 = *(float *)(a1 + 20);
  *(float *)(a2 + 24) = *(float *)(a1 + 20);
  v4 = *(float *)(a1 + 24);
  *(float *)(a2 + 28) = *(float *)(a1 + 24);
  v5 = *(float *)(a1 + 28);
  *(float *)(a2 + 32) = *(float *)(a1 + 28);
  if ( a3 )
  {
    *(float *)(a2 + 24) = (float)(int)v3;
    *(float *)(a2 + 28) = (float)(int)v4;
    *(float *)(a2 + 32) = (float)(int)v5;
  }
  *(_DWORD *)(a2 + 48) = 1;
  v6 = *(float *)(a1 + 192);
  *(float *)(a2 + 60) = *(float *)(a1 + 192);
  v7 = *(float *)(a1 + 196);
  *(float *)(a2 + 64) = *(float *)(a1 + 196);
  v8 = *(float *)(a1 + 200);
  *(float *)(a2 + 68) = *(float *)(a1 + 200);
  if ( a3 )
  {
    *(float *)(a2 + 60) = (float)(int)v6;
    *(float *)(a2 + 64) = (float)(int)v7;
    *(float *)(a2 + 68) = (float)(int)v8;
  }
  v9 = *(_DWORD *)(a1 + 124);
  if ( v9 <= 128 )
    v10 = (long double)v9;
  else
    v10 = (long double)v9 - 256.0;
  *(float *)(a2 + 108) = v10;
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 128);
  if ( (*(_BYTE *)(a1 + 129) & 0xC0) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 888);
  if ( *(int *)(a1 + 4) <= 5 )
    *(_BYTE *)(a2 + 8) &= 0xFEu;
  else
    *(_BYTE *)(a2 + 8) |= 1u;
  if ( (*(_BYTE *)(a1 + 12) & 0x20) != 0 )
    *(_BYTE *)(a2 + 9) |= 2u;
  else
    *(_BYTE *)(a2 + 9) &= 0xFDu;
  *(float *)(a2 + 212) = *(float *)(a1 + 64);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    if ( *(_DWORD *)(a1 + 212) )
    {
      v11 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 212))
          / (long double)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
      v12 = 0.0;
      if ( v11 < 0.0 || (v12 = 1.0, v14 = v11 > 1.0, v15 = 0, v16 = 1.0 == v11, (v13 & 0x45) == 1) )
        v11 = v12;
      if ( !*(_DWORD *)(a1 + 220) )
        v11 = 1.0 - v11;
    }
    else
    {
      v11 = 1.0;
    }
    *(float *)(a2 + 228) = *(float *)(a1 + 964) * v11;
    v23 = v11;
    *(float *)(a2 + 232) = AngleNormalize180(*(float *)(a1 + 968)) * v11;
    *(float *)(a2 + 236) = AngleNormalize180(*(float *)(a1 + 972)) * v23;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
  v17 = *(_DWORD *)(a1 + 132);
  if ( *(_DWORD *)(a1 + 976) - v17 >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( v17 - *(_DWORD *)(a1 + 976) > 4 )
      *(_DWORD *)(a1 + 976) = v17 - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 152 + 4 * ((*(_DWORD *)(a1 + 976))++ & 3));
  }
  v18 = *(_DWORD *)(a1 + 168);
  v19 = *(_DWORD *)(a1 + 132);
  if ( v18 != v19 )
  {
    v25 = (int *)pEventSingleClientList;
    do
    {
      v26 = *(_BYTE *)(a1 + 136 + 4 * (v18 & 3));
      v20 = 0;
      v24 = v18 + 1;
      if ( *v25 > 0 && *v25 != v26 )
      {
        do
          v21 = v25[++v20];
        while ( v21 > 0 && v21 != v26 );
      }
      if ( v25[v20] < 0 )
      {
        *(_DWORD *)(a2 + 168 + 4 * (*(_DWORD *)(a2 + 164) & 3)) = v26;
        *(_DWORD *)(a2 + 184 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3)) = *(unsigned __int8 *)(a1 + 152 + 4 * (v18 & 3));
      }
      ++v18;
      v19 = *(_DWORD *)(a1 + 132);
    }
    while ( v24 != v19 );
  }
  *(_DWORD *)(a1 + 168) = v19;
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 176);
  result = *(unsigned __int16 *)(a1 + 84);
  *(_DWORD *)(a2 + 124) = result;
  return result;
}
// 2CE36: variable 'v13' is possibly undefined
// 7B9D4: using guessed type void *pEventSingleClientList;

//----- (0002D004) --------------------------------------------------------
void __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4)
{
  int v4; // edx
  int v5; // edx
  int v6; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // edx
  long double v10; // fst7
  long double v11; // fst6
  char v12; // fps^1
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  long double v16; // [esp+18h] [ebp-30h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int *v18; // [esp+30h] [ebp-18h]
  unsigned __int8 v19; // [esp+3Fh] [ebp-9h]

  *(_DWORD *)(a2 + 12) = 3;
  *(float *)(a2 + 24) = *(float *)(a1 + 20);
  *(float *)(a2 + 28) = *(float *)(a1 + 24);
  *(float *)(a2 + 32) = *(float *)(a1 + 28);
  *(float *)(a2 + 36) = *(float *)(a1 + 32);
  *(float *)(a2 + 40) = *(float *)(a1 + 36);
  *(float *)(a2 + 44) = *(float *)(a1 + 40);
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = 50;
  *(_DWORD *)(a2 + 48) = 1;
  *(float *)(a2 + 60) = *(float *)(a1 + 192);
  *(float *)(a2 + 64) = *(float *)(a1 + 196);
  *(float *)(a2 + 68) = *(float *)(a1 + 200);
  *(float *)(a2 + 108) = (float)*(int *)(a1 + 124);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 128);
  v4 = *(_DWORD *)(a1 + 132);
  if ( *(_DWORD *)(a1 + 976) - v4 >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( v4 - *(_DWORD *)(a1 + 976) > 4 )
      *(_DWORD *)(a1 + 976) = v4 - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 152 + 4 * ((*(_DWORD *)(a1 + 976))++ & 3));
  }
  v5 = *(_DWORD *)(a1 + 132);
  if ( *(_DWORD *)(a1 + 168) - v5 > 0 )
    *(_DWORD *)(a1 + 168) = v5;
  v6 = *(_DWORD *)(a1 + 168);
  v7 = *(_DWORD *)(a1 + 132);
  if ( v6 != v7 )
  {
    v18 = (int *)pEventSingleClientList;
    do
    {
      v19 = *(_BYTE *)(a1 + 136 + 4 * (v6 & 3));
      v8 = 0;
      v17 = v6 + 1;
      if ( *v18 > 0 && *v18 != v19 )
      {
        do
          v9 = v18[++v8];
        while ( v9 > 0 && v9 != v19 );
      }
      if ( v18[v8] < 0 )
      {
        *(_DWORD *)(a2 + 168 + 4 * (*(_DWORD *)(a2 + 164) & 3)) = v19;
        *(_DWORD *)(a2 + 184 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3)) = *(unsigned __int8 *)(a1 + 152 + 4 * (v6 & 3));
      }
      ++v6;
      v7 = *(_DWORD *)(a1 + 132);
    }
    while ( v17 != v7 );
  }
  *(_DWORD *)(a1 + 168) = v7;
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 176);
  *(_DWORD *)(a2 + 124) = *(unsigned __int16 *)(a1 + 84);
  if ( (*(_BYTE *)(a1 + 14) & 5) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  if ( a4 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 172);
  if ( (*(_BYTE *)(a1 + 129) & 0xC0) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 888);
  if ( *(int *)(a1 + 4) <= 5 )
    *(_BYTE *)(a2 + 8) &= 0xFEu;
  else
    *(_BYTE *)(a2 + 8) |= 1u;
  if ( (*(_BYTE *)(a1 + 12) & 0x20) != 0 )
    *(_BYTE *)(a2 + 9) |= 2u;
  else
    *(_BYTE *)(a2 + 9) &= 0xFDu;
  *(float *)(a2 + 212) = *(float *)(a1 + 64);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    v10 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 212))
        / (long double)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
    v11 = 0.0;
    if ( v10 < 0.0 || (v11 = 1.0, v13 = v10 > 1.0, v14 = 0, v15 = 1.0 == v10, (v12 & 0x45) == 1) )
      v10 = v11;
    if ( !*(_DWORD *)(a1 + 220) )
      v10 = 1.0 - v10;
    *(float *)(a2 + 228) = *(float *)(a1 + 964) * v10;
    v16 = v10;
    *(float *)(a2 + 232) = AngleNormalize180(*(float *)(a1 + 968)) * v10;
    *(float *)(a2 + 236) = AngleNormalize180(*(float *)(a1 + 972)) * v16;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
}
// 2D38C: variable 'v12' is possibly undefined
// 7B9D4: using guessed type void *pEventSingleClientList;

//----- (0002D428) --------------------------------------------------------
int __cdecl BG_CheckProneValid(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  long double v14; // fst7
  long double v15; // fst6
  long double v16; // fst4
  long double v17; // fst5
  long double v18; // fst7
  long double v19; // fst6
  long double v20; // fst5
  long double v21; // fst7
  long double v22; // fst5
  long double v23; // fst6
  long double v24; // fst4
  long double v25; // fst5
  long double v26; // fst4
  char v27; // fps^1
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  long double v31; // fst6
  long double v32; // fst6
  char v33; // fps^1
  bool v34; // c0
  char v35; // c2
  bool v36; // c3
  long double v37; // fst7
  char v38; // fps^1
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  long double v42; // fst7
  long double v43; // fst6
  long double v44; // fst7
  char v45; // fps^1
  bool v46; // c0
  char v47; // c2
  bool v48; // c3
  char v49; // fps^1
  bool v50; // c0
  char v51; // c2
  bool v52; // c3
  long double v53; // fst7
  long double v54; // fst5
  char v55; // fps^1
  bool v56; // c0
  char v57; // c2
  bool v58; // c3
  long double v59; // fst7
  bool v60; // c0
  char v61; // c2
  bool v62; // c3
  char v63; // fps^1
  long double v65; // fst7
  long double v66; // fst7
  float v67; // [esp-2Ch] [ebp-148h]
  float v68; // [esp-2Ch] [ebp-148h]
  float v69; // [esp-1Ch] [ebp-138h]
  long double v70; // [esp+1Ch] [ebp-100h]
  float v71; // [esp+38h] [ebp-E4h]
  float v72; // [esp+3Ch] [ebp-E0h]
  int v73; // [esp+54h] [ebp-C8h]
  float v74; // [esp+58h] [ebp-C4h]
  float v75; // [esp+5Ch] [ebp-C0h]
  float v76; // [esp+60h] [ebp-BCh]
  int v77; // [esp+64h] [ebp-B8h]
  int v78; // [esp+68h] [ebp-B4h] BYREF
  float v79; // [esp+6Ch] [ebp-B0h]
  float v80; // [esp+70h] [ebp-ACh]
  int v81; // [esp+74h] [ebp-A8h] BYREF
  float v82; // [esp+78h] [ebp-A4h]
  float v83; // [esp+7Ch] [ebp-A0h]
  int v84; // [esp+80h] [ebp-9Ch] BYREF
  float v85; // [esp+84h] [ebp-98h]
  float v86; // [esp+88h] [ebp-94h]
  int v87[3]; // [esp+8Ch] [ebp-90h] BYREF
  int v88[3]; // [esp+98h] [ebp-84h] BYREF
  float v89; // [esp+A4h] [ebp-78h] BYREF
  float v90; // [esp+A8h] [ebp-74h]
  float v91; // [esp+ACh] [ebp-70h]
  float v92; // [esp+B0h] [ebp-6Ch] BYREF
  float v93; // [esp+B4h] [ebp-68h]
  float v94; // [esp+B8h] [ebp-64h]
  float v95; // [esp+BCh] [ebp-60h] BYREF
  float v96; // [esp+C0h] [ebp-5Ch]
  float v97; // [esp+C4h] [ebp-58h]
  float v98; // [esp+C8h] [ebp-54h] BYREF
  float v99; // [esp+CCh] [ebp-50h]
  float v100; // [esp+D0h] [ebp-4Ch]
  int v101; // [esp+D4h] [ebp-48h] BYREF
  float v102; // [esp+D8h] [ebp-44h]
  float v103; // [esp+DCh] [ebp-40h]
  int v104; // [esp+E0h] [ebp-3Ch] BYREF
  float v105; // [esp+E4h] [ebp-38h]
  float v106; // [esp+E8h] [ebp-34h]
  float v107; // [esp+ECh] [ebp-30h] BYREF
  int v108; // [esp+F0h] [ebp-2Ch] BYREF
  float v109; // [esp+F4h] [ebp-28h]
  float v110; // [esp+F8h] [ebp-24h]
  char v111; // [esp+11Ah] [ebp-2h]

  v14 = -a3;
  v73 = 0;
  v15 = *(float *)a2;
  v98 = v15 - a3;
  v16 = *(float *)(a2 + 4);
  v99 = v16 - a3;
  v17 = *(float *)(a2 + 8);
  v100 = v17 + 0.0;
  v95 = v15 + a3;
  v96 = v16 + a3;
  v97 = v17 + a4;
  if ( g_debugProneCheck[3] )
    G_DebugBox(&v98, &v95, &colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
  v77 = 8519697;
  if ( !a14 )
    v77 = 8454161;
  if ( !a9 )
  {
    v98 = v14;
    v99 = v14;
    v100 = 0.0;
    v95 = a3;
    v96 = a3;
    v97 = a4;
    v18 = *(float *)a2;
    v104 = *(int *)a2;
    v19 = *(float *)(a2 + 4);
    v105 = *(float *)(a2 + 4);
    v20 = *(float *)(a2 + 8);
    v106 = *(float *)(a2 + 8);
    *(float *)&v101 = v18;
    v102 = v19;
    v103 = v20 + 10.0;
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a13)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    if ( v111 )
      return 0;
  }
  if ( a10 && a11 && *(float *)(a11 + 8) < 0.69999999 )
    return 0;
  v98 = -6.0;
  v99 = -6.0;
  v100 = -6.0;
  v95 = 6.0;
  v96 = 6.0;
  v97 = 6.0;
  *(float *)&v101 = 0.0;
  v103 = 0.0;
  v102 = a5 - 180.0;
  AngleVectors(&v101, &v89, v88, v87);
  v21 = a4 - 6.0;
  v75 = v21;
  v22 = *(float *)a2;
  v104 = *(int *)a2;
  v23 = 54.0 * v89 + v22;
  v24 = *(float *)(a2 + 4);
  v105 = *(float *)(a2 + 4);
  v25 = 54.0 * v90 + v24;
  v26 = v21 + *(float *)(a2 + 8);
  v106 = v26;
  *(float *)&v101 = v23;
  v102 = v25;
  v103 = 54.0 * v91 + v26;
  ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v104, 6.0, (int)v88, (int)&colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v104, 6.0, (int)v87, (int)&colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
  v28 = v107 < 1.0;
  v29 = 0;
  v30 = v107 == 1.0;
  if ( (v27 & 0x45) == 1 )
  {
    if ( !a10 )
      goto LABEL_53;
    v74 = v107 * 54.0 + 6.0;
    v73 = 1;
    if ( a3 + 2.0 > v74 )
      goto LABEL_53;
    v31 = v75 * 0.69999999 + 24.0;
    v72 = v31;
    if ( v31 <= v74 )
    {
LABEL_24:
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v104, &v108, &colorYellow, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      goto LABEL_29;
    }
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v104, &v108, &colorRed, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
    v32 = v103 + 22.0;
    v73 = 0;
    v103 = v32;
    v92 = *(float *)&v101 - *(float *)&v104;
    v93 = v102 - v105;
    v94 = v32 - v106;
    v70 = VectorNormalize2(&v92, &v89);
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    v34 = v107 < 1.0;
    v35 = 0;
    v36 = v107 == 1.0;
    if ( (v33 & 0x45) == 1 )
    {
      v37 = v70 * v107 + 6.0;
      v73 = 1;
      v74 = v37;
      v39 = v37 < v72;
      v40 = 0;
      v41 = v37 == v72;
      if ( (v38 & 0x45) == 1 )
        goto LABEL_53;
      goto LABEL_24;
    }
  }
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v104, &v108, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
  v74 = 60.0;
LABEL_29:
  v78 = v108;
  v79 = v109;
  v80 = v110;
  if ( a10 )
  {
    *(float *)&v104 = v89 * 24.0 + *(float *)a2;
    v105 = v90 * 24.0 + *(float *)(a2 + 4);
    v42 = 24.0 * v91 + *(float *)(a2 + 8);
    v102 = v105;
    v101 = v104;
    v43 = v42 + v75;
    v44 = a3 * 2.5 + v75 - 6.0;
    v106 = v43;
    v103 = v43 - v44;
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    v46 = v107 < 1.0;
    v47 = 0;
    v48 = v107 == 1.0;
    if ( (v45 & 0x45) == 64 )
      goto LABEL_53;
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v104, &v108, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
    v81 = v108;
    v82 = v109;
    v83 = v110;
    if ( v73 )
    {
      v71 = v44;
      if ( (v71 * v107 + 6.0) * -0.75 > v74 - (v71 * v107 + 6.0) )
      {
        if ( g_debugProneCheck[3] )
          G_DebugLine(&v78, &v81, &colorRed, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
        return 0;
      }
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v78, &v81, &colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      v92 = 6.0 * v89 + *(float *)&v78 - *(float *)&v81;
      v93 = 6.0 * v90 + v79 - v82;
      v94 = 6.0 * v91 + v80 - v83 + 6.0;
      VectorNormalize(&v92);
      v103 = 30.0 * v94 + v106;
      *(float *)&v101 = (v92 * 30.0 + *(float *)&v104 + v89 * 54.0 + *(float *)a2) * 0.5;
      v102 = 0.5 * (v93 * 30.0 + v105 + 54.0 * v90 + *(float *)(a2 + 4));
      ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(
        &v107,
        &v104,
        &v98,
        &v95,
        &v101,
        a1,
        v77);
      if ( v107 < 1.0 )
      {
LABEL_53:
        if ( g_debugProneCheck[3] )
          G_DebugLine(&v104, &v108, &colorRed, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
        return 0;
      }
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v104, &v108, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      v78 = v108;
      v79 = v109;
      v80 = v110;
    }
    v105 = v79;
    v102 = v79;
    v104 = v78;
    v106 = v80;
    v101 = v78;
    v103 = v80 - (v80 - v83 + v80 - v83 + a3);
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    v50 = v107 < 1.0;
    v51 = 0;
    v52 = v107 == 1.0;
    if ( (v49 & 0x45) == 64 )
      goto LABEL_53;
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v104, &v108, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
    v78 = v108;
    v79 = v109;
    v80 = v110;
    v53 = *(float *)a2;
    v104 = *(int *)a2;
    v105 = *(float *)(a2 + 4);
    v54 = *(float *)(a2 + 8);
    v106 = v54 + v75;
    *(float *)&v101 = v53;
    v102 = v105;
    v103 = v54 - a3 * 1.5;
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    v56 = v107 < 1.0;
    v57 = 0;
    v58 = v107 == 1.0;
    if ( (v55 & 0x44) == 0x40 )
      goto LABEL_53;
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v104, &v108, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
    v84 = v108;
    v85 = v109;
    v86 = v110;
    v92 = *(float *)&v81 - *(float *)&v108;
    v93 = v82 - v109;
    v94 = v83 - v110;
    v76 = vectopitch(&v92);
    v92 = *(float *)&v78 - *(float *)&v81;
    v93 = v79 - v82;
    v94 = v80 - v83;
    v59 = vectopitch(&v92);
    v69 = v59;
    AngleSubtract(v69, v76);
    v60 = v59 < -50.0;
    v61 = 0;
    v62 = v59 == -50.0;
    if ( (v63 & 0x45) == 1 || v59 > 70.0 )
    {
      if ( g_debugProneCheck[3] )
      {
        G_DebugLine(&v84, &v81, &colorMagenta, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
        if ( g_debugProneCheck[3] )
          G_DebugLine(&v81, &v78, &colorMagenta, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      }
      return 0;
    }
    v98 = -0.0;
    v99 = -0.0;
    v100 = -0.0;
    v95 = 0.0;
    v104 = v84;
    v105 = v85;
    v96 = 0.0;
    v97 = 0.0;
    v106 = v86 + 5.0;
    v101 = v81;
    v102 = v82;
    v103 = v83 + 5.0;
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    if ( v107 < 1.0 )
      goto LABEL_88;
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v104, &v101, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
    v104 = v101;
    v105 = v102;
    v106 = v103;
    v101 = v78;
    v102 = v79;
    v103 = v80 + 5.0;
    ((void (__cdecl *)(float *, int *, float *, float *, int *, int, int))a12)(&v107, &v104, &v98, &v95, &v101, a1, v77);
    if ( v107 < 1.0 )
    {
LABEL_88:
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v104, &v101, &colorRed, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      return 0;
    }
    if ( g_debugProneCheck[3] )
    {
      G_DebugLine(&v104, &v101, &colorGreen, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
      if ( g_debugProneCheck[3] )
      {
        G_DebugCircleEx((int)&v84, 6.0, (int)v88, (int)&colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
        if ( g_debugProneCheck[3] )
        {
          G_DebugCircleEx((int)&v84, 6.0, (int)v87, (int)&colorMdCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
          if ( g_debugProneCheck[3] )
          {
            G_DebugCircleEx(
              (int)&v81,
              6.0,
              (int)v88,
              (int)&colorMdCyan,
              *((_DWORD *)&g_debugProneCheckDepthCheck + 3),
              1);
            if ( g_debugProneCheck[3] )
            {
              G_DebugCircleEx(
                (int)&v81,
                6.0,
                (int)v87,
                (int)&colorMdCyan,
                *((_DWORD *)&g_debugProneCheckDepthCheck + 3),
                1);
              if ( g_debugProneCheck[3] )
              {
                G_DebugCircleEx(
                  (int)&v78,
                  6.0,
                  (int)v88,
                  (int)&colorMdCyan,
                  *((_DWORD *)&g_debugProneCheckDepthCheck + 3),
                  1);
                if ( g_debugProneCheck[3] )
                {
                  G_DebugCircleEx(
                    (int)&v78,
                    6.0,
                    (int)v87,
                    (int)&colorMdCyan,
                    *((_DWORD *)&g_debugProneCheckDepthCheck + 3),
                    1);
                  if ( g_debugProneCheck[3] )
                  {
                    G_DebugLine(&v84, &v81, &colorCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
                    if ( g_debugProneCheck[3] )
                      G_DebugLine(&v81, &v78, &colorCyan, *((_DWORD *)&g_debugProneCheckDepthCheck + 3), 1);
                  }
                }
              }
            }
          }
        }
      }
    }
    if ( a6 )
      *(float *)a6 = v86 - *(float *)(a2 + 8) - 6.0;
    if ( a7 )
    {
      v92 = *(float *)&v84 - *(float *)&v81;
      v93 = v85 - v82;
      v94 = v86 - v83;
      v65 = vectopitch(&v92);
      v67 = v65;
      AngleNormalize180(v67);
      *(float *)a7 = v65;
    }
    if ( a8 )
    {
      v92 = *(float *)&v81 - *(float *)&v78;
      v93 = v82 - v79;
      v94 = v83 - v80;
      v66 = vectopitch(&v92);
      v68 = v66;
      AngleNormalize180(v68);
      *(float *)a8 = v66;
    }
  }
  else
  {
    if ( a6 )
      *(_DWORD *)a6 = 0;
    if ( a7 )
      *(_DWORD *)a7 = 0;
    if ( a8 )
      *(_DWORD *)a8 = 0;
  }
  return 1;
}
// 2D6D6: variable 'v27' is possibly undefined
// 2D802: variable 'v33' is possibly undefined
// 2D82C: variable 'v38' is possibly undefined
// 2D98B: variable 'v45' is possibly undefined
// 2DC11: variable 'v49' is possibly undefined
// 2DCBD: variable 'v55' is possibly undefined
// 2DDCC: variable 'v63' is possibly undefined
// 3B228: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 3D8D8: using guessed type double __cdecl VectorNormalize(_DWORD);
// 3DA68: using guessed type double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 3DD7C: using guessed type double __cdecl vectopitch(_DWORD);
// 4ACB0: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4ACE0: using guessed type _DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002E214) --------------------------------------------------------
int *__cdecl BG_FindItem(char *a1)
{
  int v1; // ebx
  int *v2; // edi
  int *v3; // esi
  int v4; // eax
  int v6; // [esp+20h] [ebp-8h]
  char **v7; // [esp+24h] [ebp-4h]

  v1 = 1;
  if ( bg_numItems > 1 )
  {
    v7 = (char **)&bg_itemlist[18];
    v2 = &bg_itemlist[12];
    v6 = 12;
    v3 = &bg_itemlist[12];
    do
    {
      if ( v1 > BG_GetNumWeapons() )
      {
        if ( !Q_stricmp(*v7, a1) || !Q_stricmp((char *)bg_itemlist[v6], a1) )
          return v2;
      }
      else
      {
        v4 = BG_GetInfoForWeapon(v1);
        if ( !Q_stricmp(a1, *(char **)(v4 + 4)) )
          return v3;
      }
      v7 += 12;
      v2 += 12;
      v6 += 12;
      v3 += 12;
      ++v1;
    }
    while ( v1 < bg_numItems );
  }
  return 0;
}
// 70804: using guessed type int bg_numItems;

//----- (0002E2D8) --------------------------------------------------------
int *__cdecl BG_FindItemForWeapon(int a1)
{
  if ( a1 < 0 || a1 > BG_GetNumWeapons() )
    Com_Error(1, (char *)&byte_6FFC0, a1);
  return &bg_itemlist[12 * a1];
}

//----- (0002E314) --------------------------------------------------------
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)(a3 + 136 + 4 * (*(_DWORD *)(a3 + 132) & 3)) = (unsigned __int8)a1;
    result = a2;
    *(_DWORD *)(a3 + 152 + 4 * ((*(_DWORD *)(a3 + 132))++ & 3)) = a2;
  }
  return result;
}

//----- (0002E358) --------------------------------------------------------
int __cdecl BG_CheckProne(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  return BG_CheckProneValid(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

//----- (0002E3BC) --------------------------------------------------------
int __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3)
{
  long double v3; // fst7
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst5
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  char v13; // fps^1
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int result; // eax
  float v19[3]; // [esp+Ch] [ebp-Ch] BYREF

  BG_EvaluateTrajectory(a2 + 12, a3, v19);
  v3 = a1[5] - v19[0];
  v5 = v3 > 36.0;
  v6 = 0;
  v7 = 36.0 == v3;
  if ( (v4 & 0x45) == 1 )
    goto LABEL_7;
  if ( v3 < -36.0 )
    goto LABEL_7;
  v8 = a1[6] - v19[1];
  if ( v8 > 36.0
    || (v10 = v8 < -36.0, v11 = 0, v12 = v8 == -36.0, (v9 & 0x45) == 1)
    || (v14 = a1[7] - v19[2], v14 > 18.0)
    || (v15 = v14 < -88.0, v16 = 0, v17 = v14 == -88.0, (v13 & 0x45) == 1) )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}
// 2E3ED: variable 'v4' is possibly undefined
// 2E41B: variable 'v9' is possibly undefined
// 2E43E: variable 'v13' is possibly undefined

//----- (0002E460) --------------------------------------------------------
__int16 sub_2E460()
{
  float *v0; // edx
  long double v1; // fst7
  __int16 v2; // fps
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  __int16 result; // ax
  long double v7; // fst6
  int v8; // ebx
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst5
  long double v14; // rtt
  long double v15; // fst5
  long double v16; // fst5
  long double v17; // rt0
  long double v18; // fst5
  long double v19; // rt1
  __int16 v20; // fps
  long double v21; // fst6
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  long double v25; // fst7
  float v26; // [esp+18h] [ebp-10h]
  float v27; // [esp+24h] [ebp-4h]

  v0 = (float *)(*(_DWORD *)pm + 32);
  v27 = *(float *)(*(_DWORD *)pm + 40);
  if ( LODWORD(pml[11]) )
    v27 = 0.0;
  v26 = sqrt(
          *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
        + *(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36)
        + v27 * v27);
  v1 = v26;
  v3 = v26 > 1.0;
  v4 = 0;
  v5 = 1.0 == v26;
  LOBYTE(result) = v2;
  HIBYTE(result) = HIBYTE(v2) & 0x45;
  if ( v26 >= 1.0 )
  {
    v7 = 0.0;
    if ( *(_BYTE *)(pm + 217) <= 1u )
    {
      if ( LODWORD(pml[11]) )
      {
        if ( (LOBYTE(pml[20]) & 2) == 0 )
        {
          v8 = *(_DWORD *)(*(_DWORD *)pm + 12);
          if ( (v8 & 0x200) == 0 )
          {
            v10 = v1 < 100.0;
            v11 = 0;
            v12 = v1 == 100.0;
            if ( (v9 & 0x45) == 1 )
            {
              v13 = v26;
              v1 = 100.0;
            }
            else
            {
              v13 = v26;
            }
            if ( (v8 & 0x100) != 0 )
            {
              v14 = v13;
              v15 = v1;
              v1 = v14;
              v16 = v15 * 0.30000001;
            }
            else if ( (v8 & 0x2000) != 0 )
            {
              v17 = v13;
              v18 = v1;
              v1 = v17;
              v16 = v18 + v18;
            }
            else
            {
              v19 = v13;
              v16 = v1;
              v1 = v19;
            }
            v7 = v16 * 5.5 * pml[9] + 0.0;
          }
        }
      }
    }
    if ( *(_BYTE *)(pm + 217) )
      v7 = v7 + v1 * (long double)*(unsigned __int8 *)(pm + 217) * pml[9];
    if ( *(_DWORD *)(*(_DWORD *)pm + 4) == 4 )
      v7 = v7 + v1 * 5.0 * pml[9];
    v21 = v1 - v7;
    v22 = v21 > 0.0;
    v23 = 0;
    v24 = 0.0 == v21;
    LOBYTE(result) = v20;
    HIBYTE(result) = HIBYTE(v20) & 0x45;
    if ( v21 < 0.0 )
      v21 = 0.0;
    v25 = v21 / v1;
    *v0 = *v0 * v25;
    v0[1] = v0[1] * v25;
    v0[2] = v25 * v0[2];
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)pm + 32) = 0;
    v0[1] = 0.0;
  }
  return result;
}
// 2E50C: variable 'v9' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002E5BC) --------------------------------------------------------
long double __cdecl sub_2E5BC(char *a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  int v5; // edx
  long double result; // fst7
  int v7; // eax
  long double v8; // fst7
  int v9; // eax
  float v10; // [esp+10h] [ebp-8h]

  v1 = a1[20];
  if ( v1 < 0 )
    v1 = -v1;
  v2 = a1[21];
  v3 = v2;
  if ( v2 < 0 )
    v2 = -v2;
  if ( v2 > v1 )
  {
    v1 = a1[21];
    if ( v3 < 0 )
      v1 = -v3;
  }
  v4 = a1[22];
  v5 = v4;
  if ( v4 < 0 )
    v4 = -v4;
  if ( v4 > v1 )
  {
    v1 = a1[22];
    if ( v5 < 0 )
      v1 = -v5;
  }
  if ( !v1 )
    return 0.0;
  v10 = sqrt((long double)(v5 * v5 + v3 * v3 + a1[20] * a1[20]));
  v7 = *(_DWORD *)pm;
  v8 = (long double)v1 * (long double)*(int *)(*(_DWORD *)pm + 68) / (v10 * 127.0);
  if ( *(char *)(*(_DWORD *)pm + 12) >= 0 )
    result = v8 * *(float *)(v7 + 848);
  else
    result = v8 * *(float *)(v7 + 844);
  v9 = *(_DWORD *)(*(_DWORD *)pm + 4);
  if ( v9 == 2 )
    result = result * 3.0;
  if ( v9 == 3 )
    result = result * 6.0;
  return result;
}
// 16EE30: using guessed type int pm;

//----- (0002E690) --------------------------------------------------------
long double __cdecl sub_2E690(_BYTE *a1)
{
  long double v1; // fst7
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  long double result; // fst7
  float *v12; // edx
  long double v13; // fst7
  long double v14; // fst7
  long double v15; // fst6
  char v16; // fps^1
  long double v17; // fst5
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  int v21; // eax
  int v22; // edx
  int v23; // edx
  int v24; // ecx
  int v25; // ebx
  long double v26; // fst7
  char v27; // fps^1
  long double v28; // fst5
  bool v29; // c0
  char v30; // c2
  bool v31; // c3
  long double v32; // fst6
  long double v33; // fst5
  long double v34; // fst7
  char v35; // fps^1
  long double v36; // fst5
  bool v37; // c0
  char v38; // c2
  bool v39; // c3
  int v40; // edx
  char v41; // fps^1
  bool v42; // c0
  char v43; // c2
  bool v44; // c3
  long double v45; // [esp+18h] [ebp-20h]
  float v46; // [esp+30h] [ebp-8h]
  float v47; // [esp+30h] [ebp-8h]

  if ( (char)a1[20] >= 0 )
  {
    v46 = fabs((long double)(char)a1[20]);
    v1 = v46;
  }
  else
  {
    v1 = fabs((long double)(char)a1[20] * *(float *)(*(_DWORD *)pm + 864));
  }
  v3 = fabs((long double)(char)a1[21] * *(float *)(*(_DWORD *)pm + 860));
  v4 = v3 < v1;
  v5 = 0;
  v6 = v3 == v1;
  if ( (v2 & 0x45) != 1 )
    v1 = v3;
  v8 = v1 > 0.0;
  v9 = 0;
  v10 = 0.0 == v1;
  if ( (v7 & 0x44) == 0x40 )
    return 0.0;
  v47 = sqrt((long double)((char)a1[21] * (char)a1[21] + (char)a1[20] * (char)a1[20]));
  v12 = *(float **)pm;
  v13 = v1 * (long double)*(int *)(*(_DWORD *)pm + 68) / (v47 * 127.0);
  if ( *(char *)(*(_DWORD *)pm + 12) >= 0 )
  {
    v15 = v13 * v12[212];
    v17 = v12[16];
    v18 = v17 < 0.0;
    v19 = 0;
    v20 = v17 == 0.0;
    v14 = v15;
    if ( (v16 & 0x45) != 64 )
      v14 = v15 * v12[217];
  }
  else
  {
    v14 = v13 * v12[211];
  }
  v21 = *(_DWORD *)pm;
  v22 = *(_DWORD *)(*(_DWORD *)pm + 4);
  if ( v22 == 2 )
  {
    result = v14 * 3.0;
    goto LABEL_38;
  }
  if ( v22 != 3 )
  {
    if ( (*(_BYTE *)(v21 + 12) & 1) != 0
      || (v23 = *(_DWORD *)(v21 + 216), v23 == *(_DWORD *)(v21 + 828))
      || (v24 = *(_DWORD *)(v21 + 212)) != 0 && v23 == *(_DWORD *)(v21 + 832) && !*(_DWORD *)(v21 + 220) )
    {
      v25 = 1;
    }
    else if ( (*(_BYTE *)(v21 + 12) & 2) != 0 || v24 && v23 == *(_DWORD *)(v21 + 832) )
    {
      v25 = 2;
    }
    else
    {
      v25 = 0;
    }
    v45 = v14;
    v26 = sub_308CC(*(_DWORD *)(*(_DWORD *)pm + 832), *(_DWORD *)(*(_DWORD *)pm + 828));
    v28 = v26;
    result = v45;
    v29 = v28 < 0.0;
    v30 = 0;
    v31 = v28 == 0.0;
    if ( (v27 & 0x45) == 64 )
    {
      v34 = sub_308CC(*(_DWORD *)(*(_DWORD *)pm + 828), *(_DWORD *)(*(_DWORD *)pm + 832));
      v36 = v34;
      result = v45;
      v37 = v36 < 0.0;
      v38 = 0;
      v39 = v36 == 0.0;
      if ( (v35 & 0x45) == 64 )
      {
        if ( v25 == 1 )
        {
          result = v45 * *(float *)(*(_DWORD *)pm + 852);
        }
        else if ( v25 == 2 )
        {
          result = v45 * *(float *)(*(_DWORD *)pm + 856);
        }
        goto LABEL_36;
      }
      v32 = v36 * *(float *)(*(_DWORD *)pm + 856);
      v33 = (1.0 - v36) * *(float *)(*(_DWORD *)pm + 852);
    }
    else
    {
      v32 = v28 * *(float *)(*(_DWORD *)pm + 852);
      v33 = (1.0 - v28) * *(float *)(*(_DWORD *)pm + 856);
    }
    result = result * (v32 + v33);
LABEL_36:
    if ( *(_BYTE *)(pm + 217) )
      result = result * (1.0 - (long double)*(unsigned __int8 *)(pm + 217) / 3.0 * 0.5);
    goto LABEL_38;
  }
  result = v14 * 6.0;
LABEL_38:
  if ( *(_DWORD *)(*(_DWORD *)pm + 176) )
  {
    v40 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm + 176));
    v42 = *(float *)(v40 + 532) > 0.0;
    v43 = 0;
    v44 = 0.0 == *(float *)(v40 + 532);
    if ( (v41 & 0x45) == 1 )
      result = result * *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm + 176)) + 532);
  }
  if ( (a1[5] & 4) != 0 )
    result = result * 0.40000001;
  return result;
}
// 2E6F4: variable 'v2' is possibly undefined
// 2E708: variable 'v7' is possibly undefined
// 2E767: variable 'v16' is possibly undefined
// 2E823: variable 'v27' is possibly undefined
// 2E87B: variable 'v35' is possibly undefined
// 2E930: variable 'v41' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002E970) --------------------------------------------------------
int sub_2E970()
{
  int v0; // edx
  long double v1; // fst7
  int v2; // ecx
  int v3; // eax
  int v4; // eax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst5
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  long double v19; // fst7
  int v20; // eax
  int result; // eax
  float v22; // [esp-10h] [ebp-48h]
  float v23; // [esp-10h] [ebp-48h]
  float v24; // [esp-Ch] [ebp-44h]
  float v25[5]; // [esp+Ch] [ebp-2Ch] BYREF
  float v26; // [esp+20h] [ebp-18h]
  int v27; // [esp+24h] [ebp-14h]
  __int16 v28; // [esp+28h] [ebp-10h]
  __int16 v29; // [esp+2Ah] [ebp-Eh]
  float v30[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v0 = *(_DWORD *)pm;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0 && (*(_BYTE *)(v0 + 129) & 0xC0) == 0 )
  {
    v24 = *(float *)(v0 + 196);
    v1 = *(float *)(*(_DWORD *)pm + 872);
    goto LABEL_4;
  }
  v4 = *(_DWORD *)pm;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 0x10) != 0 )
  {
    v1 = vectoyaw((float *)(v4 + 88)) + 180.0;
LABEL_4:
    v22 = v1;
    v28 = v29 | 0xC00;
    v27 = (int)AngleDelta(v22, v24);
    LOBYTE(v2) = v27;
    v3 = v27;
    if ( v27 < 0 )
      v3 = -v27;
    if ( v3 <= 90 )
      goto LABEL_23;
    if ( v27 <= 0 )
      goto LABEL_22;
    goto LABEL_21;
  }
  v5 = *(float *)(v4 + 20) - pml[26];
  v30[0] = v5;
  v6 = *(float *)(*(_DWORD *)pm + 24) - pml[27];
  v30[1] = v6;
  v7 = *(float *)(*(_DWORD *)pm + 28) - pml[28];
  v30[2] = v7;
  if ( *(_WORD *)(pm + 24) )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm + 84) != 1023 )
    {
      v26 = sqrt(v6 * v6 + v5 * v5 + v7 * v7);
      v8 = v26;
      v10 = v26 > 0.0;
      v11 = 0;
      v12 = 0.0 == v26;
      if ( (v9 & 0x45) != 64 )
      {
        v14 = pml[9] * 5.0;
        v15 = v14 < v8;
        v16 = 0;
        v17 = v14 == v8;
        if ( (v13 & 0x45) == 1 )
        {
          VectorNormalize2(v30, v25);
          vectoangles(v25, (int)v25);
          v18 = AngleDelta(v25[1], *(float *)(*(_DWORD *)pm + 196));
          v28 = v29 | 0xC00;
          v27 = (int)v18;
          v2 = (int)v18;
          if ( *(char *)(pm + 24) < 0 )
          {
            v27 = (int)v18;
            v23 = (long double)v2 + 180.0;
            v19 = AngleNormalize180(v23);
            v28 = v29 | 0xC00;
            v27 = (int)v19;
            v2 = (int)v19;
          }
          v20 = v2;
          if ( v2 < 0 )
            v20 = -v2;
          if ( v20 <= 90 )
            goto LABEL_23;
          if ( v2 <= 0 )
          {
LABEL_22:
            LOBYTE(v2) = -90;
            goto LABEL_23;
          }
LABEL_21:
          LOBYTE(v2) = 90;
LABEL_23:
          result = (char)v2;
          *(_DWORD *)(*(_DWORD *)pm + 124) = (char)v2;
          return result;
        }
      }
    }
  }
  result = *(_DWORD *)pm;
  *(_DWORD *)(*(_DWORD *)pm + 124) = 0;
  return result;
}
// 2E9AA: variable 'v24' is possibly undefined
// 2EA85: variable 'v9' is possibly undefined
// 2EAA1: variable 'v13' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002EB98) --------------------------------------------------------
int sub_2EB98()
{
  _DWORD *v0; // ecx
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // esi
  long double v6; // fst7
  long double v7; // fst3
  int v8; // edx
  int v9; // edx
  float v10; // eax
  unsigned int v11; // eax
  int *v12; // edx
  int v13; // edx
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  float v18; // [esp+10h] [ebp-28h] BYREF
  float v19; // [esp+14h] [ebp-24h]
  float v20; // [esp+18h] [ebp-20h]
  float v21; // [esp+1Ch] [ebp-1Ch] BYREF
  float v22; // [esp+20h] [ebp-18h]
  float v23; // [esp+24h] [ebp-14h]

  v0 = *(_DWORD **)pm;
  v1 = pm;
  if ( *(_DWORD *)(pm + 4) - *(_DWORD *)(*(_DWORD *)pm + 100) <= 499 )
    return 0;
  v2 = v0[3];
  if ( (v2 & 0x800) != 0 )
    return 0;
  if ( (v2 & 0x2000) != 0 )
    return 0;
  if ( (v2 & 1) != 0 )
    return 0;
  v3 = v0[54];
  if ( v3 == v0[207] )
    return 0;
  v4 = v0[53];
  if ( v4 )
  {
    if ( v3 == v0[208] && !v0[55] )
      return 0;
  }
  if ( (v2 & 2) != 0 || v4 && v3 == v0[208] || *(char *)(pm + 26) <= 9 )
    return 0;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 8) != 0 )
  {
    *(_BYTE *)(pm + 26) = 0;
    return 0;
  }
  pml[12] = 0.0;
  pml[11] = 0.0;
  *(_BYTE *)(*(_DWORD *)v1 + 12) |= 8u;
  *(_DWORD *)(*(_DWORD *)v1 + 84) = 1023;
  *(float *)(*(_DWORD *)v1 + 40) = sqrt((long double)*(int *)(*(_DWORD *)v1 + 60) * 78.0);
  *(float *)(*(_DWORD *)v1 + 104) = *(float *)(*(_DWORD *)v1 + 28) + 39.0;
  if ( (*(_BYTE *)(*(_DWORD *)v1 + 12) & 0x10) == 0 )
    goto LABEL_22;
  *(float *)(*(_DWORD *)v1 + 40) = *(float *)(*(_DWORD *)v1 + 40) * 0.75;
  v18 = pml[0];
  v19 = pml[1];
  v20 = 0.0;
  VectorNormalize(&v18);
  v6 = *(float *)(*(_DWORD *)pm + 88);
  if ( *(float *)(*(_DWORD *)pm + 92) * pml[1] + v6 * pml[0] + *(float *)(*(_DWORD *)pm + 96) * pml[2] >= 0.0 )
  {
    v21 = v18;
    v22 = v19;
    v23 = v20;
  }
  else
  {
    v7 = (*(float *)(*(_DWORD *)pm + 96) * v20 + *(float *)(*(_DWORD *)pm + 92) * v19 + v18 * v6) * -2.0;
    v21 = v6 * v7 + v18;
    v22 = v19 + *(float *)(*(_DWORD *)pm + 92) * v7;
    v23 = v20 + v7 * *(float *)(*(_DWORD *)pm + 96);
    VectorNormalize(&v21);
  }
  v8 = pm;
  *(float *)(*(_DWORD *)pm + 32) = v21 * 128.0;
  *(float *)(*(_DWORD *)v8 + 36) = 128.0 * v22;
  *(_BYTE *)(*(_DWORD *)v8 + 12) &= 0xEFu;
  if ( (*(_BYTE *)(*(_DWORD *)v8 + 12) & 0x10) != 0 )
  {
    v9 = 83;
  }
  else
  {
LABEL_22:
    v10 = pml[20];
    if ( (BYTE1(v10) & 0x20) == 0 && (v11 = (LODWORD(v10) & 0x1F00000u) >> 20) != 0 )
      v9 = v11 + 70;
    else
      v9 = 0;
  }
  BG_AddPredictableEventToPlayerstate(v9, 0, *(_DWORD *)pm);
  v12 = (int *)pm;
  *(float *)(*(_DWORD *)pm + 984) = *(float *)(*(_DWORD *)pm + 984) + 64.0;
  v13 = *v12;
  v15 = *(float *)(v13 + 984) > 255.0;
  v16 = 0;
  v17 = 255.0 == *(float *)(v13 + 984);
  if ( (v14 & 0x45) == 1 )
    *(float *)(v13 + 984) = 255.0;
  if ( *(char *)(pm + 24) < 0 )
    BG_AnimScriptEvent(*(_DWORD *)pm, 4, 0, 1);
  else
    BG_AnimScriptEvent(*(_DWORD *)pm, 3, 0, 1);
  if ( *(_DWORD *)(pm + 56) )
    Com_Printf(
      "%i:jump base =%.1f top=%.1f vel=%.1f\n",
      c_pmove,
      *(float *)(*(_DWORD *)pm + 28),
      *(float *)(*(_DWORD *)pm + 104),
      *(float *)(*(_DWORD *)pm + 40));
  return 1;
}
// 2EDEB: variable 'v14' is possibly undefined
// 2A084: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 2E314: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 3D8D8: using guessed type double __cdecl VectorNormalize(_DWORD);
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (0002EE6C) --------------------------------------------------------
__int16 sub_2EE6C()
{
  long double v0; // fst7
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  int v5; // ecx
  int v6; // edx
  int v7; // ebx
  long double v8; // fst7
  long double v9; // fst7
  int v10; // ecx
  char v11; // fps^1
  long double v12; // fst4
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  char v16; // fps^1
  long double v17; // fst7
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  int v24; // ecx
  _DWORD *v25; // ebx
  int v26; // edx
  int v27; // eax
  long double v28; // fst6
  int v30; // [esp+18h] [ebp-20h]
  float v31; // [esp+20h] [ebp-18h] BYREF
  float v32; // [esp+24h] [ebp-14h]
  float v33; // [esp+28h] [ebp-10h]
  float v34; // [esp+2Ch] [ebp-Ch]
  float v35; // [esp+30h] [ebp-8h]
  float v36; // [esp+34h] [ebp-4h]

  sub_2E460();
  v0 = sub_2E5BC((char *)(pm + 4));
  v2 = v0 > 0.0;
  v3 = 0;
  v4 = 0.0 == v0;
  if ( (v1 & 0x44) != 0x40 )
  {
    v5 = pm;
    v6 = 0;
    v7 = 2;
    do
    {
      *(float *)((char *)&v34 + v6 * 4) = (long double)*(char *)(v5 + 24) * (v0 * pml[v6])
                                        + v0 * pml[v6 + 3] * (long double)*(char *)(v5 + 25);
      ++v6;
      --v7;
    }
    while ( v7 >= 0 );
    v36 = v0 * (long double)*(char *)(pm + 26) + v36;
  }
  else
  {
    v34 = 0.0;
    v35 = 0.0;
    v36 = 0.0;
  }
  v8 = v36 - (long double)(16 * (*(_BYTE *)(pm + 9) & 0x20));
  v36 = v8;
  v30 = 16 * (*(_BYTE *)(pm + 9) & 0x10);
  v31 = v34;
  v32 = v35;
  v36 = v8 + (long double)v30;
  v33 = v36;
  v9 = VectorNormalize(&v31);
  v10 = *(_DWORD *)pm;
  v12 = v9
      - (*(float *)(*(_DWORD *)pm + 40) * v33
       + *(float *)(*(_DWORD *)pm + 32) * v31
       + *(float *)(*(_DWORD *)pm + 36) * v32);
  v13 = v12 < 0.0;
  v14 = 0;
  v15 = v12 == 0.0;
  if ( (unsigned __int8)((v11 & 0x45) - 1) >= 0x40u )
  {
    if ( v9 < 100.0 )
      v9 = 100.0;
    v17 = v9 * (8.0 * pml[9]);
    v18 = v12 < v17;
    v19 = 0;
    v20 = v12 == v17;
    if ( (v16 & 0x45) == 1 )
      v17 = v12;
    if ( *(_DWORD *)(v10 + 84) != 1023 )
      v17 = v17 * (1.0 / *(float *)(v10 + 892));
    v21 = v12 < v17;
    v22 = 0;
    v23 = v12 == v17;
    if ( (v16 & 0x45) == 1 )
      v17 = v12;
    v24 = 0;
    v25 = (_DWORD *)pm;
    do
    {
      v26 = 4 * v24;
      v27 = *v25 + 32;
      v28 = v17 * *(&v31 + v24) + *(float *)(4 * v24 + v27);
      ++v24;
      *(float *)(v26 + v27) = v28;
    }
    while ( v24 <= 2 );
  }
  return PM_StepSlideMove(0);
}
// 2EE94: variable 'v1' is possibly undefined
// 2EF9D: variable 'v11' is possibly undefined
// 2EFCE: variable 'v16' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002F03C) --------------------------------------------------------
int sub_2F03C()
{
  int v0; // eax
  int v1; // ecx
  long double v2; // fst7
  int v3; // ecx
  long double v4; // fst6
  long double v5; // fst7
  long double v6; // fst6
  int v7; // ecx
  _DWORD *v8; // esi
  int v9; // edx
  int v10; // eax
  long double v11; // fst6
  float *v12; // edx
  char v13; // fps^1
  long double v14; // fst5
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  int v19; // eax
  float v21; // [esp+18h] [ebp-40h]
  float v22; // [esp+1Ch] [ebp-3Ch]
  float v23; // [esp+20h] [ebp-38h]
  char v24[24]; // [esp+28h] [ebp-30h] BYREF
  float v25; // [esp+40h] [ebp-18h] BYREF
  float v26; // [esp+44h] [ebp-14h]
  float v27; // [esp+48h] [ebp-10h]
  float v28[3]; // [esp+4Ch] [ebp-Ch]

  sub_2E460();
  v23 = (float)*(char *)(pm + 24);
  v22 = (float)*(char *)(pm + 25);
  qmemcpy(v24, (const void *)(pm + 4), sizeof(v24));
  v21 = sub_2E5BC(v24);
  pml[2] = 0.0;
  pml[5] = 0.0;
  VectorNormalize(pml);
  VectorNormalize(&pml[3]);
  v0 = 0;
  v1 = 1;
  do
  {
    v28[v0] = v23 * pml[v0] + v22 * pml[v0 + 3];
    ++v0;
    --v1;
  }
  while ( v1 >= 0 );
  v28[2] = 0.0;
  v25 = v28[0];
  v26 = v28[1];
  v27 = 0.0;
  v2 = VectorNormalize(&v25);
  v3 = *(_DWORD *)pm;
  v4 = v2 * v21;
  v5 = v4
     - (*(float *)(*(_DWORD *)pm + 40) * v27
      + *(float *)(*(_DWORD *)pm + 32) * v25
      + *(float *)(*(_DWORD *)pm + 36) * v26);
  if ( v5 > 0.0 )
  {
    if ( v4 < 100.0 )
      v4 = 100.0;
    v6 = v4 * pml[9];
    if ( v6 > v5 )
      v6 = v5;
    if ( *(_DWORD *)(v3 + 84) != 1023 )
      v6 = v6 * (1.0 / *(float *)(v3 + 892));
    if ( v6 <= v5 )
      v5 = v6;
    v7 = 0;
    v8 = (_DWORD *)pm;
    do
    {
      v9 = 4 * v7;
      v10 = *v8 + 32;
      v11 = v5 * *(&v25 + v7) + *(float *)(4 * v7 + v10);
      ++v7;
      *(float *)(v9 + v10) = v11;
    }
    while ( v7 <= 2 );
  }
  if ( LODWORD(pml[12]) )
  {
    v12 = (float *)(*(_DWORD *)pm + 32);
    v14 = *(float *)(*(_DWORD *)pm + 36) * pml[18] + *v12 * pml[17] + *(float *)(*(_DWORD *)pm + 40) * pml[19];
    v15 = v14 < 0.0;
    v16 = 0;
    v17 = v14 == 0.0;
    if ( (v13 & 0x45) == 1 )
      v18 = 1.001 * v14;
    else
      v18 = v14 / 1.001;
    v19 = 0;
    do
    {
      v12[v19] = v12[v19] - pml[v19 + 17] * v18;
      ++v19;
    }
    while ( v19 <= 2 );
  }
  PM_StepSlideMove(1);
  return sub_2E970();
}
// 2F213: variable 'v13' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002F258) --------------------------------------------------------
int sub_2F258()
{
  int result; // eax
  long double v1; // fst6
  long double v2; // fst5
  char v3; // fps^1
  long double v4; // fst5
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst7
  int v9; // eax
  char v10; // fps^1
  long double v11; // fst5
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst7
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  long double v19; // fst7
  int v20; // eax
  long double v21; // fst7
  int v22; // edx
  int v23; // ecx
  int v24; // edx
  long double v25; // fst6
  int v26; // ecx
  long double v27; // fst5
  long double v28; // rt0
  long double v29; // fst5
  long double v30; // fst6
  char v31; // fps^1
  long double v32; // fst7
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  bool v36; // c0
  char v37; // c2
  bool v38; // c3
  int v39; // ecx
  _DWORD *v40; // esi
  int v41; // edx
  int v42; // eax
  long double v43; // fst6
  float *v44; // edx
  char v45; // fps^1
  long double v46; // fst5
  bool v47; // c0
  char v48; // c2
  bool v49; // c3
  long double v50; // fst7
  int v51; // eax
  long double v52; // fst7
  char v53; // fps^1
  bool v54; // c0
  char v55; // c2
  bool v56; // c3
  int v57; // edx
  char v58; // fps^1
  long double v59; // fst6
  bool v60; // c0
  char v61; // c2
  bool v62; // c3
  char v63; // fps^1
  long double v64; // fst6
  bool v65; // c0
  char v66; // c2
  bool v67; // c3
  float v68; // [esp+18h] [ebp-60h]
  float v69; // [esp+1Ch] [ebp-5Ch]
  float v70; // [esp+20h] [ebp-58h]
  float v71; // [esp+24h] [ebp-54h]
  char v72[24]; // [esp+3Ch] [ebp-3Ch] BYREF
  float v73; // [esp+54h] [ebp-24h] BYREF
  float v74; // [esp+58h] [ebp-20h]
  float v75; // [esp+5Ch] [ebp-1Ch]
  float v76; // [esp+60h] [ebp-18h]
  float v77; // [esp+64h] [ebp-14h]
  float v78; // [esp+68h] [ebp-10h]
  float v79[3]; // [esp+6Ch] [ebp-Ch]

  if ( sub_2EB98() )
  {
    sub_2F03C();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*(_DWORD *)pm + 100) = result;
  }
  else
  {
    sub_2E460();
    v71 = (float)*(char *)(pm + 24);
    v70 = (float)*(char *)(pm + 25);
    qmemcpy(v72, (const void *)(pm + 4), sizeof(v72));
    v69 = sub_2E690(v72);
    v1 = pml[1] * pml[18] + pml[0] * pml[17];
    v2 = pml[19] * 0.0;
    pml[2] = 0.0;
    pml[5] = 0.0;
    v4 = v1 + v2;
    v5 = v4 < 0.0;
    v6 = 0;
    v7 = v4 == 0.0;
    if ( (v3 & 0x45) == 1 )
      v8 = v4 * 1.001;
    else
      v8 = v4 / 1.001;
    v9 = 0;
    do
    {
      pml[v9] = pml[v9] - pml[v9 + 17] * v8;
      ++v9;
    }
    while ( v9 <= 2 );
    v11 = pml[3] * pml[17] + pml[4] * pml[18] + pml[5] * pml[19];
    v12 = v11 < 0.0;
    v13 = 0;
    v14 = v11 == 0.0;
    if ( (v10 & 0x45) == 1 )
      v15 = 1.001 * v11;
    else
      v15 = v11 / 1.001;
    v16 = 0;
    do
    {
      pml[v16 + 3] = pml[v16 + 3] - pml[v16 + 17] * v15;
      ++v16;
    }
    while ( v16 <= 2 );
    VectorNormalize(pml);
    VectorNormalize(&pml[3]);
    v17 = 0;
    v18 = 2;
    do
    {
      v79[v17] = v71 * pml[v17] + v70 * pml[v17 + 3];
      ++v17;
      --v18;
    }
    while ( v18 >= 0 );
    v73 = v79[0];
    v74 = v79[1];
    v75 = v79[2];
    v19 = VectorNormalize(&v73);
    v20 = *(_DWORD *)pm;
    v21 = v19 * v69;
    if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0
      || (v22 = *(_DWORD *)(v20 + 216), v22 == *(_DWORD *)(v20 + 828))
      || (v23 = *(_DWORD *)(v20 + 212)) != 0 && v22 == *(_DWORD *)(v20 + 832) && !*(_DWORD *)(v20 + 220) )
    {
      v24 = 1;
    }
    else if ( (*(_BYTE *)(v20 + 12) & 2) != 0 || v23 && v22 == *(_DWORD *)(v20 + 832) )
    {
      v24 = 2;
    }
    else
    {
      v24 = 0;
    }
    if ( (LOBYTE(pml[20]) & 2) != 0 || (*(_BYTE *)(*(_DWORD *)pm + 13) & 2) != 0 )
    {
      v25 = 1.0;
    }
    else
    {
      v25 = 19.0;
      if ( v24 != 1 )
      {
        v25 = 9.0;
        if ( v24 == 2 )
          v25 = 12.0;
      }
    }
    v26 = *(_DWORD *)pm;
    if ( (*(_BYTE *)(*(_DWORD *)pm + 13) & 1) != 0 )
      v25 = v25 * 0.25;
    v27 = v21 - (*(float *)(v26 + 40) * v75 + *(float *)(v26 + 32) * v73 + *(float *)(v26 + 36) * v74);
    if ( v27 > 0.0 )
    {
      if ( v21 < 100.0 )
        v21 = 100.0;
      v28 = v27;
      v29 = v25;
      v30 = v28;
      v32 = v21 * (v29 * pml[9]);
      v33 = v28 < v32;
      v34 = 0;
      v35 = v28 == v32;
      if ( (v31 & 0x45) == 1 )
        v32 = v30;
      if ( *(_DWORD *)(v26 + 84) != 1023 )
        v32 = v32 * (1.0 / *(float *)(v26 + 892));
      v36 = v30 < v32;
      v37 = 0;
      v38 = v30 == v32;
      if ( (v31 & 0x45) == 1 )
        v32 = v30;
      v39 = 0;
      v40 = (_DWORD *)pm;
      do
      {
        v41 = 4 * v39;
        v42 = *v40 + 32;
        v43 = v32 * *(&v73 + v39) + *(float *)(4 * v39 + v42);
        ++v39;
        *(float *)(v41 + v42) = v43;
      }
      while ( v39 <= 2 );
    }
    if ( (LOBYTE(pml[20]) & 2) != 0 || (*(_BYTE *)(*(_DWORD *)pm + 13) & 2) != 0 )
      *(float *)(*(_DWORD *)pm + 40) = *(float *)(*(_DWORD *)pm + 40)
                                     - (long double)*(int *)(*(_DWORD *)pm + 60) * pml[9];
    v68 = sqrt(
            *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
          + *(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36)
          + *(float *)(*(_DWORD *)pm + 40) * *(float *)(*(_DWORD *)pm + 40));
    v76 = *(float *)(*(_DWORD *)pm + 32);
    v77 = *(float *)(*(_DWORD *)pm + 36);
    v78 = *(float *)(*(_DWORD *)pm + 40);
    v44 = (float *)(*(_DWORD *)pm + 32);
    v46 = *(float *)(*(_DWORD *)pm + 36) * pml[18] + *v44 * pml[17] + *(float *)(*(_DWORD *)pm + 40) * pml[19];
    v47 = v46 < 0.0;
    v48 = 0;
    v49 = v46 == 0.0;
    if ( (v45 & 0x45) == 1 )
      v50 = 1.001 * v46;
    else
      v50 = v46 / 1.001;
    v51 = 0;
    do
    {
      v44[v51] = v44[v51] - pml[v51 + 17] * v50;
      ++v51;
    }
    while ( v51 <= 2 );
    v52 = *(float *)(*(_DWORD *)pm + 32) * v76
        + *(float *)(*(_DWORD *)pm + 36) * v77
        + *(float *)(*(_DWORD *)pm + 40) * v78;
    v54 = v52 > 0.0;
    v55 = 0;
    v56 = 0.0 == v52;
    if ( (v53 & 0x45) == 1 )
    {
      VectorNormalize((float *)(*(_DWORD *)pm + 32));
      v57 = pm;
      *(float *)(*(_DWORD *)pm + 32) = v68 * *(float *)(*(_DWORD *)pm + 32);
      *(float *)(*(_DWORD *)v57 + 36) = v68 * *(float *)(*(_DWORD *)v57 + 36);
      *(float *)(*(_DWORD *)v57 + 40) = v68 * *(float *)(*(_DWORD *)v57 + 40);
    }
    v59 = *(float *)(*(_DWORD *)pm + 32);
    v60 = v59 < 0.0;
    v61 = 0;
    v62 = v59 == 0.0;
    if ( (v58 & 0x44) != 0x40
      || (v64 = *(float *)(*(_DWORD *)pm + 36), v65 = v64 < 0.0, v66 = 0, v67 = v64 == 0.0, (v63 & 0x45) != 64) )
    {
      PM_StepSlideMove(0);
    }
    result = sub_2E970();
  }
  return result;
}
// 2F316: variable 'v3' is possibly undefined
// 2F389: variable 'v10' is possibly undefined
// 2F532: variable 'v31' is possibly undefined
// 2F626: variable 'v45' is possibly undefined
// 2F676: variable 'v53' is possibly undefined
// 2F6C6: variable 'v58' is possibly undefined
// 2F6D5: variable 'v63' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002F700) --------------------------------------------------------
float *sub_2F700()
{
  char v0; // fps^1
  long double v1; // fst6
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  float *result; // eax
  int v6; // edx
  float v7; // [esp+24h] [ebp-4h]

  if ( LODWORD(pml[11]) )
  {
    v7 = sqrt(
           *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
         + *(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36)
         + *(float *)(*(_DWORD *)pm + 40) * *(float *)(*(_DWORD *)pm + 40));
    v1 = v7 - 20.0;
    v2 = v1 < 0.0;
    v3 = 0;
    v4 = v1 == 0.0;
    if ( (unsigned __int8)((v0 & 0x45) - 1) >= 0x40u )
    {
      VectorNormalize((float *)(*(_DWORD *)pm + 32));
      v6 = pm;
      *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 32) * v1;
      *(float *)(*(_DWORD *)v6 + 36) = *(float *)(*(_DWORD *)v6 + 36) * v1;
      result = *(float **)v6;
      *(float *)(*(_DWORD *)v6 + 40) = v1 * *(float *)(*(_DWORD *)v6 + 40);
    }
    else
    {
      result = *(float **)pm;
      result[10] = 0.0;
      result[9] = 0.0;
      result[8] = 0.0;
    }
  }
  return result;
}
// 2F748: variable 'v0' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0002F7A4) --------------------------------------------------------
int sub_2F7A4()
{
  int v0; // ecx
  long double v1; // fst7
  int v2; // eax
  long double v3; // fst7
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst4
  long double v9; // rtt
  long double v10; // fst4
  long double v11; // fst7
  long double v12; // fst6
  char v13; // fps^1
  long double v14; // fst5
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  int v19; // ecx
  long double v20; // fst7
  long double v21; // fst6
  int v22; // eax
  long double v23; // fst7
  int v24; // ecx
  long double v25; // fst6
  char v26; // fps^1
  long double v27; // fst4
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  long double v31; // fst7
  long double v32; // fst6
  int v33; // ecx
  _DWORD *v34; // ebx
  int v35; // edx
  int v36; // eax
  long double v37; // fst6
  int v38; // edx
  int result; // eax
  float v40; // [esp+18h] [ebp-30h]
  __int16 v41; // [esp+1Eh] [ebp-2Ah]
  float v42; // [esp+2Ch] [ebp-1Ch]
  float v43; // [esp+30h] [ebp-18h] BYREF
  float v44; // [esp+34h] [ebp-14h]
  float v45; // [esp+38h] [ebp-10h]
  float v46[2]; // [esp+3Ch] [ebp-Ch]
  float v47; // [esp+44h] [ebp-4h]

  v0 = pm;
  *(float *)(*(_DWORD *)pm + 204) = bg_viewheight_standing[3];
  *(float *)(*(_DWORD *)v0 + 836) = bg_viewheight_standing[3];
  v42 = sqrt(
          *(float *)(*(_DWORD *)v0 + 32) * *(float *)(*(_DWORD *)v0 + 32)
        + *(float *)(*(_DWORD *)v0 + 36) * *(float *)(*(_DWORD *)v0 + 36)
        + *(float *)(*(_DWORD *)v0 + 40) * *(float *)(*(_DWORD *)v0 + 40));
  v1 = v42;
  if ( v42 >= 1.0 )
  {
    v5 = v1 < 100.0;
    v6 = 0;
    v7 = v1 == 100.0;
    if ( (v4 & 0x45) == 1 )
    {
      v8 = v42;
      v1 = 100.0;
    }
    else
    {
      v8 = v42;
    }
    v9 = v8;
    v10 = v1;
    v11 = v9;
    v12 = 0.0;
    v14 = v9 - (8.25 * v10 * pml[9] + 0.0);
    v15 = v14 < 0.0;
    v16 = 0;
    v17 = v14 == 0.0;
    if ( (v13 & 0x45) != 1 )
      v12 = v14;
    v18 = v12 / v11;
    *(float *)(*(_DWORD *)v0 + 32) = *(float *)(*(_DWORD *)v0 + 32) * v18;
    *(float *)(*(_DWORD *)v0 + 36) = *(float *)(*(_DWORD *)v0 + 36) * v18;
    v2 = *(_DWORD *)v0;
    v3 = v18 * *(float *)(*(_DWORD *)v0 + 40);
  }
  else
  {
    *(float *)(*(_DWORD *)v0 + 32) = 0.0;
    *(float *)(*(_DWORD *)v0 + 36) = *(&vec3_origin + 1);
    v2 = *(_DWORD *)v0;
    v3 = *(&vec3_origin + 2);
  }
  *(float *)(v2 + 40) = v3;
  v40 = sub_2E5BC((char *)(pm + 4));
  v19 = 2;
  v20 = (long double)*(char *)(pm + 24);
  v21 = (long double)*(char *)(pm + 25);
  v22 = 0;
  do
  {
    v46[v22] = pml[v22] * v20 + pml[v22 + 3] * v21;
    ++v22;
    --v19;
  }
  while ( v19 >= 0 );
  v41 = *(char *)(pm + 26);
  v43 = v46[0];
  v44 = v46[1];
  v47 = (long double)v41 + v47;
  v45 = v47;
  v23 = VectorNormalize(&v43);
  v24 = *(_DWORD *)pm;
  v25 = v23 * v40;
  v27 = v25
      - (*(float *)(*(_DWORD *)pm + 40) * v45
       + *(float *)(*(_DWORD *)pm + 36) * v44
       + *(float *)(*(_DWORD *)pm + 32) * v43);
  v28 = v27 < 0.0;
  v29 = 0;
  v30 = v27 == 0.0;
  if ( (unsigned __int8)((v26 & 0x45) - 1) >= 0x40u )
  {
    if ( v25 < 100.0 )
      v25 = 100.0;
    v31 = v27;
    v32 = v25 * (9.0 * pml[9]);
    if ( v32 > v27 )
      v32 = v27;
    if ( *(_DWORD *)(v24 + 84) != 1023 )
      v32 = v32 * (1.0 / *(float *)(v24 + 892));
    if ( v32 <= v27 )
      v31 = v32;
    v33 = 0;
    v34 = (_DWORD *)pm;
    do
    {
      v35 = 4 * v33;
      v36 = *v34 + 32;
      v37 = v31 * *(&v43 + v33) + *(float *)(4 * v33 + v36);
      ++v33;
      *(float *)(v35 + v36) = v37;
    }
    while ( v33 <= 2 );
  }
  v38 = pm;
  *(float *)(*(_DWORD *)pm + 20) = *(float *)(*(_DWORD *)pm + 32) * pml[9] + *(float *)(*(_DWORD *)pm + 20);
  *(float *)(*(_DWORD *)v38 + 24) = *(float *)(*(_DWORD *)v38 + 36) * pml[9] + *(float *)(*(_DWORD *)v38 + 24);
  result = *(_DWORD *)v38;
  *(float *)(*(_DWORD *)v38 + 28) = *(float *)(*(_DWORD *)v38 + 40) * pml[9] + *(float *)(*(_DWORD *)v38 + 28);
  return result;
}
// 2F834: variable 'v4' is possibly undefined
// 2F85E: variable 'v13' is possibly undefined
// 2F963: variable 'v26' is possibly undefined
// 72910: using guessed type float vec3_origin;
// 16EE30: using guessed type int pm;

//----- (0002FA2C) --------------------------------------------------------
int sub_2FA2C()
{
  _BYTE *v0; // edx
  int v1; // ecx
  long double v2; // fst7
  char v3; // fps^1
  long double v4; // fst6
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // eax
  long double v12; // fst7
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst4
  long double v18; // rt0
  long double v19; // fst4
  long double v20; // fst7
  long double v21; // fst6
  char v22; // fps^1
  long double v23; // fst5
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  long double v27; // fst7
  int v28; // edx
  __int16 v29; // ax
  int v30; // eax
  int v31; // ecx
  long double v32; // fst7
  int v33; // ecx
  long double v34; // fst6
  char v35; // fps^1
  long double v36; // fst4
  bool v37; // c0
  char v38; // c2
  bool v39; // c3
  long double v40; // fst7
  long double v41; // fst6
  int v42; // ecx
  _DWORD *v43; // ebx
  int v44; // edx
  int v45; // eax
  long double v46; // fst6
  int v47; // edx
  int result; // eax
  float v49; // [esp+1Ch] [ebp-4Ch]
  float v50; // [esp+20h] [ebp-48h]
  float v51; // [esp+24h] [ebp-44h]
  float v52[3]; // [esp+28h] [ebp-40h] BYREF
  int v53[5]; // [esp+34h] [ebp-34h] BYREF
  float v54; // [esp+48h] [ebp-20h]
  __int16 v55; // [esp+4Eh] [ebp-1Ah]
  float v56; // [esp+50h] [ebp-18h] BYREF
  float v57; // [esp+54h] [ebp-14h]
  float v58; // [esp+58h] [ebp-10h]
  float v59[2]; // [esp+5Ch] [ebp-Ch]
  float v60; // [esp+64h] [ebp-4h]

  v0 = (_BYTE *)pm;
  *(float *)(*(_DWORD *)pm + 204) = bg_viewheight_standing[3];
  *(float *)(*(_DWORD *)v0 + 836) = bg_viewheight_standing[3];
  v0[26] -= 127 * (v0[9] & 0x20);
  *(_BYTE *)(pm + 26) += 127 * (*(_BYTE *)(pm + 9) & 0x10);
  v1 = pm;
  if ( *(_WORD *)(pm + 24) )
  {
    v54 = sqrt(
            *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
          + *(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36)
          + *(float *)(*(_DWORD *)pm + 40) * *(float *)(*(_DWORD *)pm + 40));
    v2 = v54;
  }
  else
  {
    v2 = 0.0;
    v55 = *(char *)(pm + 26);
    v4 = (long double)v55;
    v5 = v4 < 0.0;
    v6 = 0;
    v7 = v4 == 0.0;
    if ( (v3 & 0x45) != 64 )
    {
      v8 = *(_DWORD *)pm;
      *(_DWORD *)(v8 + 36) = 0;
      *(_DWORD *)(v8 + 32) = 0;
      v9 = *(_DWORD *)v1;
      v55 = *(char *)(v1 + 26);
      v2 = 127.0;
      *(float *)(v9 + 40) = (float)v55;
    }
  }
  if ( v2 >= 1.0 )
  {
    v14 = v2 < 100.0;
    v15 = 0;
    v16 = v2 == 100.0;
    if ( (v13 & 0x45) == 1 )
    {
      v17 = v2;
      v2 = 100.0;
    }
    else
    {
      v17 = v2;
    }
    v18 = v17;
    v19 = v2;
    v20 = v18;
    v21 = 0.0;
    v23 = v18 - (8.25 * v19 * pml[9] + 0.0);
    v24 = v23 < 0.0;
    v25 = 0;
    v26 = v23 == 0.0;
    if ( (v22 & 0x45) != 1 )
      v21 = v23;
    v27 = v21 / v20;
    v28 = pm;
    *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 32) * v27;
    *(float *)(*(_DWORD *)v28 + 36) = *(float *)(*(_DWORD *)v28 + 36) * v27;
    v11 = *(_DWORD *)v28;
    v12 = v27 * *(float *)(*(_DWORD *)v28 + 40);
  }
  else
  {
    v10 = pm;
    *(float *)(*(_DWORD *)pm + 32) = 0.0;
    *(float *)(*(_DWORD *)v10 + 36) = *(&vec3_origin + 1);
    v11 = *(_DWORD *)v10;
    v12 = *(&vec3_origin + 2);
  }
  *(float *)(v11 + 40) = v12;
  v49 = sub_2E5BC((char *)(pm + 4));
  v55 = *(char *)(pm + 24);
  v51 = (float)v55;
  v29 = *(char *)(pm + 25);
  v53[1] = 0;
  v53[0] = 0;
  v55 = v29;
  v53[2] = 1065353216;
  v50 = (float)v29;
  CrossProduct((float *)v53, &pml[3], v52);
  v30 = 0;
  v31 = 2;
  do
  {
    v59[v30] = v51 * v52[v30] + v50 * pml[v30 + 3];
    ++v30;
    --v31;
  }
  while ( v31 >= 0 );
  v55 = *(char *)(pm + 26);
  v56 = v59[0];
  v57 = v59[1];
  v60 = (long double)v55 + (long double)v55 + v60;
  v58 = v60;
  v32 = VectorNormalize(&v56);
  v33 = *(_DWORD *)pm;
  v34 = v32 * v49;
  v36 = v34
      - (*(float *)(*(_DWORD *)pm + 40) * v58
       + *(float *)(*(_DWORD *)pm + 36) * v57
       + *(float *)(*(_DWORD *)pm + 32) * v56);
  v37 = v36 < 0.0;
  v38 = 0;
  v39 = v36 == 0.0;
  if ( (unsigned __int8)((v35 & 0x45) - 1) >= 0x40u )
  {
    if ( v34 < 100.0 )
      v34 = 100.0;
    v40 = v36;
    v41 = v34 * (9.0 * pml[9]);
    if ( v41 > v36 )
      v41 = v36;
    if ( *(_DWORD *)(v33 + 84) != 1023 )
      v41 = v41 * (1.0 / *(float *)(v33 + 892));
    if ( v41 <= v36 )
      v40 = v41;
    v42 = 0;
    v43 = (_DWORD *)pm;
    do
    {
      v44 = 4 * v42;
      v45 = *v43 + 32;
      v46 = v40 * *(&v56 + v42) + *(float *)(4 * v42 + v45);
      ++v42;
      *(float *)(v44 + v45) = v46;
    }
    while ( v42 <= 2 );
  }
  v47 = pm;
  *(float *)(*(_DWORD *)pm + 20) = *(float *)(*(_DWORD *)pm + 32) * pml[9] + *(float *)(*(_DWORD *)pm + 20);
  *(float *)(*(_DWORD *)v47 + 24) = *(float *)(*(_DWORD *)v47 + 36) * pml[9] + *(float *)(*(_DWORD *)v47 + 24);
  result = *(_DWORD *)v47;
  *(float *)(*(_DWORD *)v47 + 28) = *(float *)(*(_DWORD *)v47 + 40) * pml[9] + *(float *)(*(_DWORD *)v47 + 28);
  return result;
}
// 2FA9E: variable 'v3' is possibly undefined
// 2FB3A: variable 'v13' is possibly undefined
// 2FB64: variable 'v22' is possibly undefined
// 2FC9E: variable 'v35' is possibly undefined
// 72910: using guessed type float vec3_origin;
// 16EE30: using guessed type int pm;

//----- (0002FD68) --------------------------------------------------------
__int16 sub_2FD68()
{
  __int16 result; // ax
  long double v1; // fst7
  long double v2; // fst5
  __int16 v3; // fps
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  long double v7; // rt1
  long double v8; // fst7
  long double v9; // fst6
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst5
  int v13; // esi
  long double v14; // fst5
  long double v15; // fst7
  long double v16; // rt2
  long double v17; // rtt
  long double v18; // fst5
  long double v19; // fst6
  int v20; // eax
  int v21; // ecx
  int v22; // ebx
  __int16 v23; // fps
  long double v24; // fst6
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  int v28; // ebx
  long double v29; // fst7
  int v30; // edx
  int v31; // eax
  long double v32; // fst7
  int v33; // edx
  float v34; // eax
  unsigned int v35; // eax
  bool v36; // c0
  char v37; // c2
  bool v38; // c3
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  float v42; // eax
  unsigned int v43; // eax
  int v44; // edx
  bool v45; // c0
  char v46; // c2
  bool v47; // c3
  float v48; // eax
  unsigned int v49; // eax
  int *v50; // edx
  float v51; // eax
  unsigned int v52; // eax
  float v53; // [esp+40h] [ebp-8h]

  result = pm;
  if ( *(_BYTE *)(pm + 217) != 3 )
  {
    if ( !*(_DWORD *)(*(_DWORD *)pm + 108) && pml[31] < -220.0 )
      BG_AnimScriptEvent(*(_DWORD **)pm, 5, 0, 1);
    v1 = -(long double)*(int *)(*(_DWORD *)pm + 60);
    v2 = pml[31] * pml[31] - (pml[28] - *(float *)(*(_DWORD *)pm + 28)) * (v1 * 0.5 * 4.0);
    v4 = v2 > 0.0;
    v5 = 0;
    v6 = 0.0 == v2;
    LOBYTE(result) = v3;
    HIBYTE(result) = HIBYTE(v3) & 0x45;
    if ( v2 >= 0.0 )
    {
      v7 = pml[31];
      v53 = (-v7 - sqrt(v2)) / (v1 * 0.5 + v1 * 0.5);
      v8 = -(v1 * v53 + v7);
      v9 = v8 * v8 / ((long double)*(int *)(*(_DWORD *)pm + 60) + (long double)*(int *)(*(_DWORD *)pm + 60));
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("landing vel: %.1f fall height: %.1f\n", (double)v8, (double)v9);
      v10 = v9;
      v11 = bg_fallDamageMaxHeight[2];
      v12 = bg_fallDamageMinHeight[2];
      if ( v12 < v11 && v12 >= 0.0 )
      {
        if ( v12 >= v10 || (LOBYTE(pml[20]) & 1) != 0 || *(int *)(*(_DWORD *)pm + 4) > 5 )
        {
          v13 = 0;
        }
        else
        {
          v14 = v10;
          v15 = bg_fallDamageMinHeight[2];
          if ( v14 < v11 )
          {
            v16 = v11 - v15;
            v17 = v14;
            v18 = v14 - v15;
            v10 = v17;
            v19 = v18 / v16 * 100.0;
            if ( (int)v19 < 0 )
            {
              v20 = 0;
            }
            else
            {
              v20 = (int)v19;
              if ( (int)v19 > 100 )
                v20 = 100;
            }
            v13 = v20;
          }
          else
          {
            v10 = v14;
            v13 = 100;
          }
        }
      }
      else
      {
        Com_Printf("bg_fallDamageMaxHeight and bg_fallDamageMinHeight have bad values\n");
        v13 = 0;
      }
      if ( *(_BYTE *)(pm + 217) == 2 )
        v13 = (int)((long double)v13 * 0.5);
      if ( v10 > 12.0 )
        v21 = (int)((v10 - 12.0) / 26.0 * 4.0 + 4.0);
      else
        v21 = 0;
      if ( v21 > 24 )
        LOBYTE(v21) = 24;
      v22 = pm;
      v24 = *(float *)(*(_DWORD *)pm + 104);
      v25 = v24 < -0.001;
      v26 = 0;
      v27 = v24 == -0.001;
      if ( (HIBYTE(v23) & 0x45) == 1 || v24 > 0.001 )
      {
        *(_DWORD *)(*(_DWORD *)pm + 16) = 200;
        *(_BYTE *)(*(_DWORD *)v22 + 13) |= 0x20u;
      }
      if ( v13 )
      {
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("falling damage: %i\n", v13);
        if ( v13 > 99 || (LOBYTE(pml[20]) & 2) != 0 )
        {
          v33 = pm;
          *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 32) * 0.67000002;
          *(float *)(*(_DWORD *)v33 + 36) = *(float *)(*(_DWORD *)v33 + 36) * 0.67000002;
          v31 = *(_DWORD *)v33;
          v32 = 0.67000002 * *(float *)(*(_DWORD *)v33 + 40);
        }
        else
        {
          v28 = 35 * v13 + 500;
          if ( v28 > 2000 )
            v28 = 2000;
          if ( v28 > 500 )
          {
            if ( v28 <= 1499 )
              v29 = 0.5 - ((long double)v28 - 500.0) / 1000.0 * 0.30000001;
            else
              v29 = 0.2;
          }
          else
          {
            v29 = 0.5;
          }
          if ( *(int *)(pm + 56) > 1 )
            Com_Printf("landing stun time: %i speed mult: %.2f\n", v28, (double)v29);
          v30 = pm;
          *(_DWORD *)(*(_DWORD *)pm + 16) = v28;
          *(_BYTE *)(*(_DWORD *)v30 + 13) |= 1u;
          *(float *)(*(_DWORD *)v30 + 32) = *(float *)(*(_DWORD *)v30 + 32) * v29;
          *(float *)(*(_DWORD *)v30 + 36) = *(float *)(*(_DWORD *)v30 + 36) * v29;
          v31 = *(_DWORD *)v30;
          v32 = v29 * *(float *)(*(_DWORD *)v30 + 40);
        }
        *(float *)(v31 + 40) = v32;
        v34 = pml[20];
        if ( (BYTE1(v34) & 0x20) != 0 )
          v35 = 0;
        else
          v35 = (LODWORD(v34) & 0x1F00000u) >> 20;
        return BG_AddPredictableEventToPlayerstate(v35 + 116, v13, *(_DWORD *)pm);
      }
      v36 = v10 < 4.0;
      v37 = 0;
      v38 = v10 == 4.0;
      LOBYTE(result) = v23;
      HIBYTE(result) = HIBYTE(v23) & 0x45;
      if ( v10 <= 4.0 )
        return result;
      v39 = v10 < 8.0;
      v40 = 0;
      v41 = v10 == 8.0;
      if ( (HIBYTE(v23) & 0x45) == 1 )
      {
        v42 = pml[20];
        if ( (BYTE1(v42) & 0x20) == 0 )
        {
          v43 = (LODWORD(v42) & 0x1F00000u) >> 20;
          if ( v43 )
          {
            v44 = v43 + 24;
            return BG_AddPredictableEventToPlayerstate(v44, 0, *(_DWORD *)pm);
          }
        }
      }
      else
      {
        v45 = v10 < 12.0;
        v46 = 0;
        v47 = v10 == 12.0;
        if ( (HIBYTE(v23) & 0x45) != 1 )
        {
          v50 = (int *)pm;
          *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 32) * 0.67000002;
          *(float *)(*v50 + 36) = *(float *)(*v50 + 36) * 0.67000002;
          *(float *)(*v50 + 40) = 0.67000002 * *(float *)(*v50 + 40);
          v51 = pml[20];
          if ( (BYTE1(v51) & 0x20) != 0 )
            v52 = 0;
          else
            v52 = (LODWORD(v51) & 0x1F00000u) >> 20;
          return BG_AddPredictableEventToPlayerstate(v52 + 93, v21, *v50);
        }
        v48 = pml[20];
        if ( (BYTE1(v48) & 0x20) == 0 )
        {
          v49 = (LODWORD(v48) & 0x1F00000u) >> 20;
          if ( v49 )
          {
            v44 = v49 + 1;
            return BG_AddPredictableEventToPlayerstate(v44, 0, *(_DWORD *)pm);
          }
        }
      }
      v44 = 0;
      return BG_AddPredictableEventToPlayerstate(v44, 0, *(_DWORD *)pm);
    }
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (00030214) --------------------------------------------------------
int __cdecl sub_30214(int a1)
{
  unsigned int v1; // edi
  int v2; // esi
  int v3; // edx
  int v4; // edx
  int v6; // eax
  int v7; // [esp-4h] [ebp-2Ch]
  float v8; // [esp+1Ch] [ebp-Ch] BYREF
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+24h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  do
  {
    v8 = *(float *)(*(_DWORD *)pm + 20) + flt_70A40[v2];
    v9 = *(float *)(*(_DWORD *)pm + 24) + flt_70A44[v2];
    v10 = *(float *)(*(_DWORD *)pm + 28) + flt_70A48[v2];
    (*(void (__cdecl **)(int, float *, int, int, float *, _DWORD, _DWORD))(pm + 232))(
      a1,
      &v8,
      pm + 192,
      pm + 204,
      &v8,
      *(_DWORD *)(*(_DWORD *)pm + 172),
      *(_DWORD *)(pm + 52));
    if ( !*(_BYTE *)(a1 + 47) )
    {
      v3 = pm;
      *(float *)(*(_DWORD *)pm + 20) = v8;
      *(float *)(*(_DWORD *)v3 + 24) = v9;
      *(float *)(*(_DWORD *)v3 + 28) = v10;
      v8 = *(float *)(*(_DWORD *)v3 + 20);
      v9 = *(float *)(*(_DWORD *)v3 + 24);
      v10 = *(float *)(*(_DWORD *)v3 + 28) - 1.0;
      (*(void (__stdcall **)(int, int, int, int, float *, _DWORD, _DWORD, int))(v3 + 232))(
        a1,
        *(_DWORD *)v3 + 20,
        v3 + 192,
        v3 + 204,
        &v8,
        *(_DWORD *)(*(_DWORD *)v3 + 172),
        *(_DWORD *)(v3 + 52),
        v7);
      qmemcpy(&pml[13], (const void *)a1, 0x30u);
      v4 = pm;
      *(float *)(*(_DWORD *)pm + 20) = *(float *)(a1 + 4);
      *(float *)(*(_DWORD *)v4 + 24) = *(float *)(a1 + 8);
      *(float *)(*(_DWORD *)v4 + 28) = *(float *)(a1 + 12);
      return 1;
    }
    v2 += 3;
    ++v1;
  }
  while ( v1 <= 0x19 );
  v6 = pm;
  *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
  pml[12] = 0.0;
  pml[11] = 0.0;
  *(_DWORD *)(*(_DWORD *)v6 + 104) = 0;
  return 0;
}
// 30300: variable 'v7' is possibly undefined
// 70A40: using guessed type float flt_70A40[];
// 70A44: using guessed type float flt_70A44[];
// 70A48: using guessed type float flt_70A48[];
// 16EE30: using guessed type int pm;

//----- (0003037C) --------------------------------------------------------
int sub_3037C()
{
  char v0; // fps^1
  bool v1; // c0
  char v2; // c2
  bool v3; // c3
  int result; // eax
  float v5[3]; // [esp+1Ch] [ebp-3Ch] BYREF
  float v6[12]; // [esp+28h] [ebp-30h] BYREF

  if ( *(_DWORD *)(*(_DWORD *)pm + 84) != 1023 )
  {
    if ( *(_DWORD *)(pm + 56) )
      Com_Printf("%i:lift\n", c_pmove);
    v5[0] = *(float *)(*(_DWORD *)pm + 20);
    v5[1] = *(float *)(*(_DWORD *)pm + 24);
    v5[2] = *(float *)(*(_DWORD *)pm + 28) - 64.0;
    (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(pm + 232))(
      v6,
      *(_DWORD *)pm + 20,
      pm + 192,
      pm + 204,
      v5,
      *(_DWORD *)(*(_DWORD *)pm + 172),
      *(_DWORD *)(pm + 52));
    v1 = v6[0] > 1.0;
    v2 = 0;
    v3 = 1.0 == v6[0];
    if ( (v0 & 0x44) == 0x40 )
    {
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*(_DWORD **)pm, 4, 0, 1);
      else
        BG_AnimScriptEvent(*(_DWORD **)pm, 3, 0, 1);
    }
  }
  result = *(_DWORD *)pm;
  *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
  pml[12] = 0.0;
  pml[11] = 0.0;
  return result;
}
// 30417: variable 'v0' is possibly undefined
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (00030474) --------------------------------------------------------
int sub_30474()
{
  int v0; // eax
  int v1; // eax
  long double v2; // fst7
  int result; // eax
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  float **v8; // edx
  float *v9; // ecx
  _DWORD *v10; // edx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  float v14[12]; // [esp+30h] [ebp-48h] BYREF
  float v15[3]; // [esp+60h] [ebp-18h] BYREF
  float v16[2]; // [esp+6Ch] [ebp-Ch] BYREF
  float v17; // [esp+74h] [ebp-4h]

  v16[0] = *(float *)(*(_DWORD *)pm + 20);
  v16[1] = *(float *)(*(_DWORD *)pm + 24);
  v15[0] = *(float *)(*(_DWORD *)pm + 20);
  v15[1] = *(float *)(*(_DWORD *)pm + 24);
  v0 = *(_DWORD *)pm;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 129) & 0xC0) != 0 )
  {
    v17 = *(float *)(v0 + 28);
    v1 = *(_DWORD *)pm;
    v2 = 1.0;
  }
  else
  {
    v2 = 0.25;
    v17 = *(float *)(v0 + 28) + 0.25;
    v1 = *(_DWORD *)pm;
  }
  v15[2] = *(float *)(v1 + 28) - v2;
  (*(void (__cdecl **)(float *, float *, int, int, float *, _DWORD, _DWORD))(pm + 232))(
    v14,
    v16,
    pm + 192,
    pm + 204,
    v15,
    *(_DWORD *)(*(_DWORD *)pm + 172),
    *(_DWORD *)(pm + 52));
  qmemcpy(&pml[13], v14, 0x30u);
  if ( !BYTE2(v14[11]) || (result = sub_30214((int)v14)) != 0 )
  {
    if ( HIBYTE(v14[11]) )
    {
      v17 = *(float *)(*(_DWORD *)pm + 28) - 0.001;
      (*(void (__cdecl **)(float *, float *, int, int, float *, _DWORD, _DWORD))(pm + 232))(
        v14,
        v16,
        pm + 192,
        pm + 204,
        v15,
        *(_DWORD *)(*(_DWORD *)pm + 172),
        *(_DWORD *)(pm + 52));
      if ( HIBYTE(v14[11]) )
      {
LABEL_19:
        result = *(_DWORD *)pm;
        *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
        goto LABEL_20;
      }
      qmemcpy(&pml[13], v14, 0x30u);
    }
    v5 = v14[0] > 1.0;
    v6 = 0;
    v7 = 1.0 == v14[0];
    if ( (v4 & 0x44) == 0x40 )
    {
      result = sub_3037C();
LABEL_20:
      pml[12] = 0.0;
      pml[11] = 0.0;
      return result;
    }
    v8 = (float **)pm;
    *(_DWORD *)(*(_DWORD *)pm + 104) = 0;
    v9 = *v8;
    if ( ((_BYTE)(*v8)[3] & 0x10) == 0 && v9[10] > 0.0 && v9[9] * v14[5] + v9[8] * v14[4] + v9[10] * v14[6] > 10.0 )
    {
      if ( v8[14] )
        Com_Printf("%i:kickoff\n", c_pmove);
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*(_DWORD **)pm, 4, 0, 0);
      else
        BG_AnimScriptEvent(*(_DWORD **)pm, 3, 0, 0);
      goto LABEL_19;
    }
    if ( v14[6] >= 0.69999999 )
    {
      v10 = (_DWORD *)pm;
      LODWORD(pml[12]) = 1;
      LODWORD(pml[11]) = 1;
      if ( *(_DWORD *)(*v10 + 84) == 1023 )
      {
        if ( v10[14] )
          Com_Printf("%i:Land\n", c_pmove);
        sub_2FD68();
      }
      v11 = pm;
      result = LOWORD(v14[10]);
      *(_DWORD *)(*(_DWORD *)pm + 84) = LOWORD(v14[10]);
      v12 = v11;
      if ( LOWORD(v14[10]) != 1022 )
      {
        v13 = *(_DWORD *)(v11 + 60);
        if ( v13 != 32 )
        {
          result = 0;
          if ( v13 <= 0 )
          {
LABEL_34:
            result = 4 * *(_DWORD *)(v12 + 60);
            *(_DWORD *)(result + v12 + 64) = LOWORD(v14[10]);
            ++*(_DWORD *)(v12 + 60);
          }
          else
          {
            while ( *(_DWORD *)(v12 + 64 + 4 * result) != LOWORD(v14[10]) )
            {
              if ( ++result >= v13 )
                goto LABEL_34;
            }
          }
        }
      }
    }
    else
    {
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("%i:steep\n", c_pmove);
      result = *(_DWORD *)pm;
      *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
      LODWORD(pml[12]) = 1;
      pml[11] = 0.0;
    }
  }
  return result;
}
// 305AE: variable 'v4' is possibly undefined
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (00030778) --------------------------------------------------------
int sub_30778()
{
  int result; // eax
  int v1; // esi
  int v2; // [esp-4h] [ebp-2Ch]
  float v3[2]; // [esp+1Ch] [ebp-Ch] BYREF
  float v4; // [esp+24h] [ebp-4h]

  *(_BYTE *)(pm + 217) = 0;
  *(_BYTE *)(pm + 216) = 0;
  v3[0] = *(float *)(*(_DWORD *)pm + 20);
  v3[1] = *(float *)(*(_DWORD *)pm + 24);
  v4 = *(float *)(*(_DWORD *)pm + 28) + *(float *)(*(_DWORD *)pm + 812) + 1.0;
  result = (*(int (__cdecl **)(float *, _DWORD, int))(pm + 244))(v3, *(_DWORD *)(*(_DWORD *)pm + 172), 32);
  if ( result )
  {
    v1 = (int)(*(float *)(*(_DWORD *)pm + 208) - *(float *)(*(_DWORD *)pm + 812));
    *(_BYTE *)(pm + 216) = result;
    *(_BYTE *)(pm + 217) = 1;
    v4 = *(float *)(*(_DWORD *)pm + 28) + *(float *)(*(_DWORD *)pm + 812) + (long double)(v1 / 2);
    result = (*(int (__cdecl **)(float *, _DWORD, int))(pm + 244))(v3, *(_DWORD *)(*(_DWORD *)pm + 172), 32);
    if ( result )
    {
      *(_BYTE *)(pm + 217) = 2;
      v4 = *(float *)(*(_DWORD *)pm + 28) + *(float *)(*(_DWORD *)pm + 812) + (long double)v1;
      result = (*(int (__stdcall **)(float *, _DWORD, int, int))(pm + 244))(
                 v3,
                 *(_DWORD *)(*(_DWORD *)pm + 172),
                 32,
                 v2);
      if ( result )
      {
        result = pm;
        *(_BYTE *)(pm + 217) = 3;
      }
    }
  }
  return result;
}
// 308AC: variable 'v2' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (000308CC) --------------------------------------------------------
long double __cdecl sub_308CC(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // eax
  int v4; // edx
  int v5; // edx
  long double result; // fst7
  long double v7; // fst6
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3

  v2 = *(_DWORD **)pm;
  if ( !*(_DWORD *)(*(_DWORD *)pm + 212)
    || a1 != -1
    && a2 != -1
    && (a2 != v2[54] || a2 == v2[208] && (a1 != v2[207] || v2[55]) && (a1 != v2[209] || !v2[55])) )
  {
    return 0.0;
  }
  v3 = *(_DWORD *)pm;
  v4 = *(_DWORD *)(*(_DWORD *)pm + 216);
  if ( v4 == *(_DWORD *)(*(_DWORD *)pm + 828) )
  {
    v5 = 200;
    if ( (*(_BYTE *)(v3 + 12) & 4) == 0 )
      v5 = bg_duck2prone_time[3];
  }
  else if ( v4 == *(_DWORD *)(v3 + 832) )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm + 220) )
    {
      v5 = 150;
      if ( (*(_BYTE *)(v3 + 12) & 4) != 0 )
        v5 = 100;
    }
    else
    {
      v5 = bg_prone2duck_time[3];
    }
  }
  else
  {
    v5 = 200;
  }
  result = (long double)(*(_DWORD *)(pm + 4) - *(_DWORD *)(*(_DWORD *)pm + 212)) / (long double)v5;
  v7 = 0.0;
  if ( result < 0.0 || (v7 = 1.0, v9 = result > 1.0, v10 = 0, v11 = 1.0 == result, (v8 & 0x45) == 1) )
    result = v7;
  return result;
}
// 309BD: variable 'v8' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (000309D8) --------------------------------------------------------
void sub_309D8()
{
  int v0; // ecx
  int v1; // ebx
  int v2; // edx
  char v3; // fps^1
  long double v4; // fst6
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst7
  char v9; // fps^1
  long double v10; // fst6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  _DWORD *v14; // eax
  int v15; // edx
  int v16; // edx
  char v17; // fps^1
  long double v18; // fst7
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  int v22; // ecx
  _DWORD *v23; // esi
  int v24; // eax
  int v25; // edi
  int v26; // ebx
  int v27; // edx
  int v28; // ecx
  int v29; // eax
  int v30; // edx
  long double v31; // fst7
  int v32; // edx
  int v33; // eax
  long double v34; // fst7
  long double v35; // fst6
  long double v36; // fst6
  int *v37; // esi
  int v38; // edi
  char *v39; // ecx
  int v40; // edx
  long double v41; // fst7
  int v42; // edx
  int v43; // eax
  long double v44; // fst6
  int v45; // edi
  char *v46; // ecx
  int v47; // edx
  int v48; // edx
  int v49; // eax
  long double v50; // fst6
  int v51; // edi
  char *v52; // ecx
  int v53; // edx
  int v54; // edx
  int v55; // eax
  long double v56; // fst6
  int v57; // edi
  char *v58; // ecx
  int v59; // edx
  int v60; // edx
  int v61; // eax
  long double v62; // fst6
  int v63; // edi
  char *v64; // ecx
  int v65; // edx
  long double v66; // fst7
  long double v67; // fst7
  int v68; // eax
  int v69; // eax
  _DWORD *v70; // ecx
  int v71; // edx
  int v72; // eax
  _DWORD *v73; // edx
  int v74; // ebx
  _DWORD *v75; // edx
  int v76; // eax
  int v77; // eax
  int v78; // eax
  int v79; // edx
  int v80; // ecx
  int v81; // ecx
  int v82; // esi
  int v83; // edi
  int v84; // edi
  int v85; // edx
  int v86; // eax
  int v87; // edx
  int v88; // eax
  int *v89; // ecx
  int v90; // edi
  int *v91; // esi
  int v92; // edx
  long double v93; // fst7
  int *v94; // ecx
  int v95; // edi
  int *v96; // esi
  int v97; // edx
  int *v98; // ecx
  int v99; // edi
  int *v100; // esi
  int v101; // edx
  int v102; // eax
  int v103; // edx
  int v104; // eax
  long double v105; // fst7
  long double v106; // fst6
  int v107; // edx
  int v108; // eax
  long double v109; // fst7
  long double v110; // fst6
  int v111; // edx
  int v112; // eax
  long double v113; // fst7
  long double v114; // fst6
  int v115; // eax
  int v116; // edx
  int v117; // eax
  long double v118; // fst7
  long double v119; // fst6
  int *v120; // ecx
  int v121; // edi
  int *v122; // esi
  int v123; // edx
  int v124; // edx
  long double v125; // fst7
  char v126; // fps^1
  long double v127; // fst6
  bool v128; // c0
  char v129; // c2
  bool v130; // c3
  int v131; // ecx
  int v132; // edx
  int v133; // edx
  char v134; // fps^1
  long double v135; // fst7
  bool v136; // c0
  char v137; // c2
  bool v138; // c3
  int v139; // eax
  char v140; // fps^1
  long double v141; // fst7
  bool v142; // c0
  char v143; // c2
  bool v144; // c3
  long double v145; // [esp+18h] [ebp-70h]
  float v146; // [esp+50h] [ebp-38h]
  float v147; // [esp+50h] [ebp-38h]
  float v148; // [esp+58h] [ebp-30h] BYREF
  float v149; // [esp+5Ch] [ebp-2Ch]
  float v150; // [esp+60h] [ebp-28h]
  float v151; // [esp+64h] [ebp-24h]
  float v152; // [esp+68h] [ebp-20h]
  float v153; // [esp+6Ch] [ebp-1Ch]
  int v154; // [esp+80h] [ebp-8h]
  int v155; // [esp+84h] [ebp-4h]

  v0 = pm;
  v1 = *(_DWORD *)pm;
  v2 = *(_DWORD *)(*(_DWORD *)pm + 204);
  if ( !v2 || (v4 = *(float *)(v1 + 208), v5 = v4 < 0.0, v6 = 0, v7 = v4 == 0.0, (v3 & 0x44) == 0x40) )
  {
    if ( *(_DWORD *)(v1 + 4) == 4 )
    {
      *(_DWORD *)(v1 + 208) = 0;
    }
    else
    {
      v155 = *(_DWORD *)(*(_DWORD *)pm + 204);
      *(float *)(v1 + 208) = (float)v2;
    }
    return;
  }
  v155 = *(_DWORD *)(*(_DWORD *)pm + 204);
  v8 = (long double)v2;
  v10 = *(float *)(v1 + 208);
  v11 = v10 < v8;
  v12 = 0;
  v13 = v10 == v8;
  if ( (v9 & 0x44) != 0x40 || *(_DWORD *)(*(_DWORD *)pm + 212) )
  {
    v14 = *(_DWORD **)pm;
    v15 = *(_DWORD *)(*(_DWORD *)pm + 204);
    if ( v15 != *(_DWORD *)(*(_DWORD *)pm + 828) && v15 != v14[208] && v15 != v14[209] )
    {
      v14[53] = 0;
      if ( (long double)*(int *)(*(_DWORD *)v0 + 204) <= *(float *)(*(_DWORD *)v0 + 208) )
      {
        *(float *)(*(_DWORD *)v0 + 208) = *(float *)(*(_DWORD *)v0 + 208) - pml[9] * 180.0;
        v16 = *(_DWORD *)v0;
        if ( (long double)*(int *)(*(_DWORD *)v0 + 204) < *(float *)(*(_DWORD *)v0 + 208) )
          return;
      }
      else
      {
        *(float *)(*(_DWORD *)v0 + 208) = pml[9] * 180.0 + *(float *)(*(_DWORD *)v0 + 208);
        v16 = *(_DWORD *)v0;
        v18 = (long double)*(int *)(*(_DWORD *)v0 + 204);
        v19 = v18 < *(float *)(*(_DWORD *)v0 + 208);
        v20 = 0;
        v21 = v18 == *(float *)(*(_DWORD *)v0 + 208);
        if ( (unsigned __int8)((v17 & 0x45) - 1) >= 0x40u )
          return;
      }
      *(float *)(v16 + 208) = (float)*(int *)(v16 + 204);
      return;
    }
    v22 = *(_DWORD *)pm;
    v23 = (_DWORD *)pm;
    if ( *(_DWORD *)(*(_DWORD *)pm + 212) )
    {
      v24 = *(_DWORD *)(v22 + 216);
      if ( v24 == *(_DWORD *)(v22 + 828) )
      {
        v25 = 200;
        if ( (*(_BYTE *)(v22 + 12) & 4) == 0 )
          v25 = bg_duck2prone_time[3];
      }
      else if ( v24 == *(_DWORD *)(v22 + 832) )
      {
        if ( *(_DWORD *)(v22 + 220) )
        {
          v25 = 150;
          if ( (*(_BYTE *)(v22 + 12) & 4) != 0 )
            v25 = 100;
        }
        else
        {
          v25 = bg_prone2duck_time[3];
        }
      }
      else
      {
        v25 = 200;
      }
      v26 = 100 * (*(_DWORD *)(pm + 4) - *(_DWORD *)(*(_DWORD *)pm + 212)) / v25;
      if ( v26 >= 0 )
      {
        if ( v26 > 100 )
          v26 = 100;
      }
      else
      {
        v26 = 0;
      }
      if ( v26 == 100 )
      {
        v27 = pm;
        v28 = *(_DWORD *)pm;
        v155 = *(_DWORD *)(*(_DWORD *)pm + 216);
        *(float *)(v28 + 208) = (float)v155;
        *(_DWORD *)(*(_DWORD *)v27 + 212) = 0;
        *(_DWORD *)(*(_DWORD *)v27 + 224) = 0;
      }
      else
      {
        v29 = *(_DWORD *)pm;
        v30 = *(_DWORD *)(*(_DWORD *)pm + 216);
        if ( v30 == *(_DWORD *)(*(_DWORD *)pm + 828) )
        {
          if ( (*(_BYTE *)(v29 + 12) & 4) != 0 )
          {
            if ( v26 )
            {
              v37 = (int *)&unk_7C898;
              v38 = 1;
              v39 = (char *)&unk_7C898;
              v40 = 3;
              do
              {
                if ( v26 == *v37 )
                {
                  v154 = v37[2];
                  v31 = (long double)v154;
                  goto LABEL_79;
                }
                if ( *v37 > v26 )
                {
                  v32 = 12 * v38 - 12;
                  v33 = *(int *)((char *)dword_7C88C + v32);
                  v154 = v26 - v33;
                  v154 = *v37 - v33;
                  v34 = (long double)(v26 - v33) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C894 + v32);
                  v35 = (long double)v154;
                  v154 = v37[2] - v154;
                  v146 = v35 + (long double)v154 * v34;
                  v36 = *(float *)((char *)&flt_7C890 + v32);
                  goto LABEL_81;
                }
                v39 += 12;
                v40 += 3;
                ++v38;
                v37 = (int *)v39;
              }
              while ( dword_7C88C[v40] != -1 );
              v154 = dword_7C894;
              v146 = (float)dword_7C894;
            }
            else
            {
              v154 = dword_7C894;
              v146 = (float)dword_7C894;
            }
            v41 = flt_7C890;
          }
          else
          {
            if ( v26 )
            {
              v37 = (int *)&unk_7C814;
              v45 = 1;
              v46 = (char *)&unk_7C814;
              v47 = 3;
              do
              {
                if ( v26 == *v37 )
                {
                  v154 = v37[2];
                  v31 = (long double)v154;
                  goto LABEL_79;
                }
                if ( *v37 > v26 )
                {
                  v42 = 12 * v45 - 12;
                  v43 = *(int *)((char *)dword_7C808 + v42);
                  v154 = v26 - v43;
                  v154 = *v37 - v43;
                  v34 = (long double)(v26 - v43) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C810 + v42);
                  v44 = (long double)v154;
                  v154 = v37[2] - v154;
                  v146 = v44 + (long double)v154 * v34;
                  v36 = *(float *)((char *)&flt_7C80C + v42);
                  goto LABEL_81;
                }
                v46 += 12;
                v47 += 3;
                ++v45;
                v37 = (int *)v46;
              }
              while ( dword_7C808[v47] != -1 );
              v154 = dword_7C810;
              v146 = (float)dword_7C810;
            }
            else
            {
              v154 = dword_7C810;
              v146 = (float)dword_7C810;
            }
            v41 = flt_7C80C;
          }
        }
        else if ( v30 == *(_DWORD *)(v29 + 832) )
        {
          if ( *(_DWORD *)(v29 + 220) )
          {
            if ( v26 )
            {
              v37 = (int *)&unk_7C73C;
              v51 = 1;
              v52 = (char *)&unk_7C73C;
              v53 = 3;
              do
              {
                if ( v26 == *v37 )
                {
                  v154 = v37[2];
                  v31 = (long double)v154;
                  goto LABEL_79;
                }
                if ( *v37 > v26 )
                {
                  v48 = 12 * v51 - 12;
                  v49 = *(int *)((char *)dword_7C730 + v48);
                  v154 = v26 - v49;
                  v154 = *v37 - v49;
                  v34 = (long double)(v26 - v49) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C738 + v48);
                  v50 = (long double)v154;
                  v154 = v37[2] - v154;
                  v146 = v50 + (long double)v154 * v34;
                  v36 = *(float *)((char *)&flt_7C734 + v48);
                  goto LABEL_81;
                }
                v52 += 12;
                v53 += 3;
                ++v51;
                v37 = (int *)v52;
              }
              while ( dword_7C730[v53] != -1 );
              v154 = dword_7C738;
              v146 = (float)dword_7C738;
            }
            else
            {
              v154 = dword_7C738;
              v146 = (float)dword_7C738;
            }
            v41 = flt_7C734;
          }
          else
          {
            if ( v26 )
            {
              v37 = (int *)&unk_7C8BC;
              v57 = 1;
              v58 = (char *)&unk_7C8BC;
              v59 = 3;
              do
              {
                if ( v26 == *v37 )
                {
                  v154 = v37[2];
                  v31 = (long double)v154;
                  goto LABEL_79;
                }
                if ( *v37 > v26 )
                {
                  v54 = 12 * v57 - 12;
                  v55 = *(int *)((char *)dword_7C8B0 + v54);
                  v154 = v26 - v55;
                  v154 = *v37 - v55;
                  v34 = (long double)(v26 - v55) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C8B8 + v54);
                  v56 = (long double)v154;
                  v154 = v37[2] - v154;
                  v146 = v56 + (long double)v154 * v34;
                  v36 = *(float *)((char *)&flt_7C8B4 + v54);
                  goto LABEL_81;
                }
                v58 += 12;
                v59 += 3;
                ++v57;
                v37 = (int *)v58;
              }
              while ( dword_7C8B0[v59] != -1 );
              v154 = dword_7C8B8;
              v146 = (float)dword_7C8B8;
            }
            else
            {
              v154 = dword_7C8B8;
              v146 = (float)dword_7C8B8;
            }
            v41 = flt_7C8B4;
          }
        }
        else if ( v26 )
        {
          v37 = (int *)&unk_7C7A8;
          v63 = 1;
          v64 = (char *)&unk_7C7A8;
          v65 = 3;
          while ( 1 )
          {
            if ( v26 == *v37 )
            {
              v154 = v37[2];
              v31 = (long double)v154;
LABEL_79:
              v146 = v31;
              v41 = *((float *)v37 + 1);
              goto LABEL_88;
            }
            if ( *v37 > v26 )
              break;
            v64 += 12;
            v65 += 3;
            ++v63;
            v37 = (int *)v64;
            if ( dword_7C79C[v65] == -1 )
            {
              v154 = dword_7C7A4;
              v146 = (float)dword_7C7A4;
              goto LABEL_87;
            }
          }
          v60 = 12 * v63 - 12;
          v61 = *(int *)((char *)dword_7C79C + v60);
          v154 = v26 - v61;
          v154 = *v37 - v61;
          v34 = (long double)(v26 - v61) / (long double)v154;
          v154 = *(int *)((char *)&dword_7C7A4 + v60);
          v62 = (long double)v154;
          v154 = v37[2] - v154;
          v146 = v62 + (long double)v154 * v34;
          v36 = *(float *)((char *)&flt_7C7A0 + v60);
LABEL_81:
          v41 = v34 * (*((float *)v37 + 1) - v36) + v36;
        }
        else
        {
          v154 = dword_7C7A4;
          v146 = (float)dword_7C7A4;
LABEL_87:
          v41 = flt_7C7A0;
        }
LABEL_88:
        *(float *)(*(_DWORD *)pm + 208) = v41;
        if ( fabs(*(float *)(*(_DWORD *)pm + 224) - v146) > 0.05000000074505806 )
        {
          v151 = *(float *)(*(_DWORD *)pm + 32);
          v152 = *(float *)(*(_DWORD *)pm + 36);
          v153 = *(float *)(*(_DWORD *)pm + 40);
          v66 = v146 - *(float *)(*(_DWORD *)pm + 224);
          if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 )
            v66 = v66 * 0.5;
          v67 = v66 / pml[9];
          v148 = pml[0];
          v149 = pml[1];
          v150 = 0.0;
          v145 = v67;
          VectorNormalize(&v148);
          v68 = pm;
          *(float *)(*(_DWORD *)pm + 32) = v148 * v145;
          *(float *)(*(_DWORD *)v68 + 36) = v149 * v145;
          *(float *)(*(_DWORD *)v68 + 40) = v145 * v150;
          PM_StepSlideMove(1);
          v69 = pm;
          *(float *)(*(_DWORD *)pm + 32) = v151;
          *(float *)(*(_DWORD *)v69 + 36) = v152;
          *(float *)(*(_DWORD *)v69 + 40) = v153;
          *(float *)(*(_DWORD *)v69 + 224) = v146;
        }
      }
      v70 = *(_DWORD **)pm;
      v23 = (_DWORD *)pm;
      if ( *(_DWORD *)(*(_DWORD *)pm + 212) )
      {
        v71 = v70[51];
        v72 = v70[54];
        if ( v71 == v72 || (v71 >= v72 || v70[55]) && (v71 <= v72 || !v70[55]) )
          return;
        v73 = (_DWORD *)pm;
        v74 = 100 - v26;
        *(_BYTE *)(*(_DWORD *)pm + 220) ^= 1u;
        v75 = (_DWORD *)*v73;
        if ( v75[55] )
        {
          v76 = v75[54];
          if ( v76 != v75[209] )
          {
            if ( v76 != v75[208] )
              goto LABEL_107;
            v77 = v75[207];
            goto LABEL_106;
          }
        }
        else
        {
          v78 = v75[54];
          if ( v78 != v75[207] )
          {
            if ( v78 != v75[208] )
              goto LABEL_107;
            v77 = v75[209];
LABEL_106:
            v75[54] = v77;
LABEL_107:
            if ( v74 == 100 )
            {
              v79 = pm;
              v80 = *(_DWORD *)pm;
              v155 = *(_DWORD *)(*(_DWORD *)pm + 216);
              *(float *)(v80 + 208) = (float)v155;
              *(_DWORD *)(*(_DWORD *)v79 + 212) = 0;
              *(_DWORD *)(*(_DWORD *)v79 + 224) = 0;
              return;
            }
            v81 = *(_DWORD *)pm;
            v82 = pm;
            v83 = *(_DWORD *)(*(_DWORD *)pm + 216);
            if ( v83 == *(_DWORD *)(*(_DWORD *)pm + 828) )
            {
              v84 = 200;
              if ( (*(_BYTE *)(v81 + 12) & 4) == 0 )
                v84 = bg_duck2prone_time[3];
            }
            else if ( v83 == *(_DWORD *)(v81 + 832) )
            {
              if ( *(_DWORD *)(*(_DWORD *)pm + 220) )
              {
                v84 = 150;
                if ( (*(_BYTE *)(v81 + 12) & 4) != 0 )
                  v84 = 100;
              }
              else
              {
                v84 = bg_prone2duck_time[3];
              }
            }
            else
            {
              v84 = 200;
            }
            v85 = *(_DWORD *)pm;
            v155 = (int)((long double)v74 * 0.0099999998 * (long double)v84);
            *(_DWORD *)(v85 + 212) = *(_DWORD *)(pm + 4) - v155;
            v86 = *(_DWORD *)v82;
            v87 = *(_DWORD *)(*(_DWORD *)v82 + 216);
            if ( v87 == *(_DWORD *)(*(_DWORD *)v82 + 828) )
            {
              if ( v74 )
              {
                v89 = (int *)&unk_7C814;
                v90 = 1;
                v91 = (int *)&unk_7C814;
                v92 = 3;
                while ( 1 )
                {
                  if ( v74 == *v89 )
                  {
                    v154 = v89[2];
                    v147 = (float)v154;
                    goto LABEL_161;
                  }
                  if ( *v89 > v74 )
                    break;
                  v91 += 3;
                  v92 += 3;
                  ++v90;
                  v89 = v91;
                  if ( dword_7C808[v92] == -1 )
                  {
                    v154 = dword_7C810;
                    v93 = (long double)dword_7C810;
                    goto LABEL_160;
                  }
                }
                v103 = 12 * v90 - 12;
                v104 = *(int *)((char *)dword_7C808 + v103);
                v154 = v74 - v104;
                v154 = *v89 - v104;
                v105 = (long double)(v74 - v104) / (long double)v154;
                v154 = *(int *)((char *)&dword_7C810 + v103);
                v106 = (long double)v154;
                v154 = v89[2] - v154;
                v147 = v105 * (long double)v154 + v106;
                goto LABEL_161;
              }
              v88 = dword_7C810;
            }
            else if ( v87 == *(_DWORD *)(v86 + 832) )
            {
              if ( *(_DWORD *)(v86 + 220) )
              {
                if ( v74 )
                {
                  v94 = (int *)&unk_7C73C;
                  v95 = 1;
                  v96 = (int *)&unk_7C73C;
                  v97 = 3;
                  while ( 1 )
                  {
                    if ( v74 == *v94 )
                    {
                      v154 = v94[2];
                      v93 = (long double)v154;
                      goto LABEL_160;
                    }
                    if ( *v94 > v74 )
                      break;
                    v96 += 3;
                    v97 += 3;
                    ++v95;
                    v94 = v96;
                    if ( dword_7C730[v97] == -1 )
                    {
                      v154 = dword_7C738;
                      v147 = (float)dword_7C738;
                      goto LABEL_161;
                    }
                  }
                  v107 = 12 * v95 - 12;
                  v108 = *(int *)((char *)dword_7C730 + v107);
                  v154 = v74 - v108;
                  v154 = *v94 - v108;
                  v109 = (long double)(v74 - v108) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C738 + v107);
                  v110 = (long double)v154;
                  v154 = v94[2] - v154;
                  v147 = v109 * (long double)v154 + v110;
                  goto LABEL_161;
                }
                v88 = dword_7C738;
              }
              else
              {
                if ( v74 )
                {
                  v98 = (int *)&unk_7C8BC;
                  v99 = 1;
                  v100 = (int *)&unk_7C8BC;
                  v101 = 3;
                  while ( 1 )
                  {
                    if ( v74 == *v98 )
                    {
                      v102 = v98[2];
                      goto LABEL_150;
                    }
                    if ( *v98 > v74 )
                      break;
                    v100 += 3;
                    v101 += 3;
                    ++v99;
                    v98 = v100;
                    if ( dword_7C8B0[v101] == -1 )
                    {
                      v102 = dword_7C8B8;
LABEL_150:
                      v154 = v102;
                      v93 = (long double)v102;
                      goto LABEL_160;
                    }
                  }
                  v111 = 12 * v99 - 12;
                  v112 = *(int *)((char *)dword_7C8B0 + v111);
                  v154 = v74 - v112;
                  v154 = *v98 - v112;
                  v113 = (long double)(v74 - v112) / (long double)v154;
                  v154 = *(int *)((char *)&dword_7C8B8 + v111);
                  v114 = (long double)v154;
                  v154 = v98[2] - v154;
                  v147 = v113 * (long double)v154 + v114;
                  goto LABEL_161;
                }
                v88 = dword_7C8B8;
              }
            }
            else
            {
              if ( v74 )
              {
                v120 = (int *)&unk_7C7A8;
                v121 = 1;
                v122 = (int *)&unk_7C7A8;
                v123 = 3;
                do
                {
                  if ( v74 == *v120 )
                  {
                    v115 = v120[2];
                    goto LABEL_159;
                  }
                  if ( *v120 > v74 )
                  {
                    v116 = 12 * v121 - 12;
                    v117 = *(int *)((char *)dword_7C79C + v116);
                    v154 = v74 - v117;
                    v154 = *v120 - v117;
                    v118 = (long double)(v74 - v117) / (long double)v154;
                    v154 = *(int *)((char *)&dword_7C7A4 + v116);
                    v119 = (long double)v154;
                    v154 = v120[2] - v154;
                    v147 = v118 * (long double)v154 + v119;
                    goto LABEL_161;
                  }
                  v122 += 3;
                  v123 += 3;
                  ++v121;
                  v120 = v122;
                }
                while ( dword_7C79C[v123] != -1 );
                v115 = dword_7C7A4;
LABEL_159:
                v154 = v115;
                v93 = (long double)v115;
LABEL_160:
                v147 = v93;
                goto LABEL_161;
              }
              v88 = dword_7C7A4;
            }
            v154 = v88;
            v147 = (float)v88;
LABEL_161:
            *(float *)(*(_DWORD *)pm + 224) = v147;
            return;
          }
        }
        v77 = v75[208];
        goto LABEL_106;
      }
    }
    v124 = *v23;
    v155 = *(_DWORD *)(*v23 + 204);
    v125 = (long double)v155;
    v127 = *(float *)(v124 + 208);
    v128 = v127 < v125;
    v129 = 0;
    v130 = v127 == v125;
    if ( (v126 & 0x45) == 64 )
      return;
    *(_DWORD *)(*v23 + 212) = v23[1];
    v131 = *v23;
    v132 = *(_DWORD *)(*v23 + 204);
    if ( v132 == *(_DWORD *)(*v23 + 828) )
    {
      *(_DWORD *)(v131 + 220) = 1;
      v133 = *v23;
      v135 = (long double)*(int *)(*v23 + 832);
      v136 = v135 < *(float *)(*v23 + 208);
      v137 = 0;
      v138 = v135 == *(float *)(*v23 + 208);
      if ( (v134 & 0x45) != 1 )
      {
        v133 = *v23;
        v139 = *(_DWORD *)(*v23 + 828);
LABEL_175:
        *(_DWORD *)(v133 + 216) = v139;
        return;
      }
    }
    else if ( v132 == *(_DWORD *)(v131 + 832) )
    {
      v155 = *(_DWORD *)(*v23 + 204);
      v141 = (long double)v132;
      v142 = v141 < *(float *)(v131 + 208);
      v143 = 0;
      v144 = v141 == *(float *)(v131 + 208);
      *(_DWORD *)(*v23 + 220) = (v140 & 0x45) == 1;
      v133 = *(_DWORD *)pm;
    }
    else
    {
      if ( v132 != *(_DWORD *)(v131 + 836) )
        return;
      *(_DWORD *)(v131 + 220) = 0;
      v133 = *v23;
      if ( (long double)*(int *)(*v23 + 832) <= *(float *)(*v23 + 208) )
      {
        v133 = *v23;
        v139 = *(_DWORD *)(*v23 + 836);
        goto LABEL_175;
      }
    }
    v139 = *(_DWORD *)(v133 + 832);
    goto LABEL_175;
  }
}
// 309FF: variable 'v3' is possibly undefined
// 30A41: variable 'v9' is possibly undefined
// 30ACD: variable 'v17' is possibly undefined
// 3160A: variable 'v126' is possibly undefined
// 3164B: variable 'v134' is possibly undefined
// 31676: variable 'v140' is possibly undefined
// 7C730: using guessed type int dword_7C730[];
// 7C734: using guessed type float flt_7C734;
// 7C738: using guessed type int dword_7C738;
// 7C79C: using guessed type int dword_7C79C[];
// 7C7A0: using guessed type float flt_7C7A0;
// 7C7A4: using guessed type int dword_7C7A4;
// 7C808: using guessed type int dword_7C808[];
// 7C80C: using guessed type float flt_7C80C;
// 7C810: using guessed type int dword_7C810;
// 7C88C: using guessed type int dword_7C88C[];
// 7C890: using guessed type float flt_7C890;
// 7C894: using guessed type int dword_7C894;
// 7C8B0: using guessed type int dword_7C8B0[];
// 7C8B4: using guessed type float flt_7C8B4;
// 7C8B8: using guessed type int dword_7C8B8;
// 16EE30: using guessed type int pm;

//----- (000316F4) --------------------------------------------------------
void sub_316F4()
{
  int v0; // ecx
  int v1; // edx
  char v2; // al
  int v3; // edx
  int v4; // eax
  int v5; // esi
  _BOOL4 v6; // edi
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // eax
  char v11; // al
  int v12; // edx
  char v13; // al
  int *v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  int v20; // eax
  float *v21; // edx
  int v22; // eax
  int v23; // ecx
  float *v24; // ecx
  int v25; // edx
  long double v26; // fst7
  char v27; // fps^1
  long double v28; // fst6
  bool v29; // c0
  char v30; // c2
  bool v31; // c3
  int v32; // eax
  long double v33; // fst7
  int v34; // edx
  int v35; // eax
  long double v36; // fst7
  int v37; // edx
  long double v38; // fst7
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  char v42; // fps^1
  char v43; // fps^1
  bool v44; // c0
  char v45; // c2
  bool v46; // c3
  int v47; // eax
  int v48; // ecx
  int v49; // eax
  float v50; // [esp+2Ch] [ebp-4Ch] BYREF
  float v51; // [esp+30h] [ebp-48h]
  float v52; // [esp+34h] [ebp-44h]
  float v53[3]; // [esp+38h] [ebp-40h] BYREF
  int v54; // [esp+44h] [ebp-34h]
  float v55; // [esp+48h] [ebp-30h] BYREF
  float v56; // [esp+4Ch] [ebp-2Ch]
  float v57; // [esp+50h] [ebp-28h]
  float v58; // [esp+54h] [ebp-24h]
  int v59[7]; // [esp+58h] [ebp-20h] BYREF
  char v60; // [esp+76h] [ebp-2h]
  char v61; // [esp+77h] [ebp-1h]

  v0 = pm;
  v1 = *(_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 4) == 4 )
  {
    *(float *)(pm + 192) = -8.0;
    *(float *)(v0 + 196) = -8.0;
    *(float *)(v0 + 200) = -8.0;
    *(float *)(v0 + 204) = 8.0;
    *(float *)(v0 + 208) = 8.0;
    *(float *)(v0 + 212) = 16.0;
    *(_BYTE *)(v1 + 12) &= 0xFCu;
    v2 = *(_BYTE *)(v0 + 9);
    if ( (v2 & 0x40) != 0 )
    {
      *(_BYTE *)(v0 + 9) = v2 & 0xBF;
      BG_AddPredictableEventToPlayerstate(140, 0, *(_DWORD *)pm);
    }
    v3 = pm;
    *(_DWORD *)(pm + 232) = *(_DWORD *)(pm + 240);
    *(_BYTE *)(*(_DWORD *)v3 + 128) |= 0x10u;
    *(_DWORD *)(*(_DWORD *)v3 + 204) = 0;
    *(_DWORD *)(*(_DWORD *)v3 + 208) = 0;
    return;
  }
  v4 = *(_DWORD *)(v1 + 12);
  *(float *)(pm + 192) = *(float *)(v1 + 804);
  *(float *)(v0 + 196) = *(float *)(v1 + 808);
  *(float *)(v0 + 204) = *(float *)(v1 + 816);
  *(float *)(v0 + 208) = *(float *)(v1 + 820);
  *(float *)(v0 + 200) = *(float *)(v1 + 812);
  v5 = v4 & 1;
  v6 = (v4 & 3) == 0;
  if ( *(int *)(v1 + 4) > 5 )
  {
    *(float *)(v0 + 212) = *(float *)(v1 + 824);
    *(_DWORD *)(v1 + 204) = *(_DWORD *)(v1 + 840);
    v7 = *(_DWORD *)v0;
    if ( (*(_BYTE *)(*(_DWORD *)v0 + 12) & 1) != 0 )
      v8 = *(_DWORD *)(v0 + 236);
    else
      v8 = *(_DWORD *)(v0 + 240);
    *(_DWORD *)(v0 + 232) = v8;
    *(_BYTE *)(v7 + 128) |= 0x10u;
    sub_309D8();
    return;
  }
  if ( (*(_BYTE *)(v1 + 129) & 0xC0) != 0 )
  {
    v9 = *(_DWORD *)(v1 + 128) & 0xC000;
    if ( v9 == 0x4000 )
    {
      *(_BYTE *)(v1 + 12) |= 1u;
      *(_BYTE *)(*(_DWORD *)v0 + 12) &= 0xFDu;
    }
    else if ( v9 == 0x8000 )
    {
      *(_BYTE *)(v1 + 12) |= 2u;
      *(_BYTE *)(*(_DWORD *)v0 + 12) &= 0xFEu;
    }
    else
    {
      *(_BYTE *)(v1 + 12) &= 0xFCu;
    }
    goto LABEL_45;
  }
  v10 = *(_DWORD *)(v1 + 12);
  if ( (v10 & 0x4000) == 0 )
  {
    if ( (v10 & 0x10) != 0 )
    {
      v11 = *(_BYTE *)(v0 + 9);
      if ( (v11 & 0xC0) != 0 )
      {
        *(_BYTE *)(v0 + 9) = v11 & 0x3F;
        BG_AddPredictableEventToPlayerstate(140, 0, *(_DWORD *)pm);
      }
    }
    v12 = pm;
    v13 = *(_BYTE *)(pm + 9);
    if ( (v13 & 0x40) != 0 )
    {
      if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0
        || BG_CheckProne(
             *(_DWORD *)(*(_DWORD *)pm + 172),
             *(_DWORD *)pm + 20,
             *(float *)(pm + 204),
             30.0,
             *(float *)(*(_DWORD *)pm + 196),
             *(_DWORD *)pm + 964,
             *(_DWORD *)pm + 968,
             *(_DWORD *)pm + 972,
             0,
             *(_DWORD *)(*(_DWORD *)pm + 84) != 1023,
             0,
             *(_DWORD *)(pm + 240),
             *(_DWORD *)(pm + 236),
             0) )
      {
        *(_BYTE *)(*(_DWORD *)pm + 12) |= 1u;
        goto LABEL_45;
      }
      v14 = (int *)pm;
      *(_BYTE *)(*(_DWORD *)pm + 13) |= 0x80u;
      *(_BYTE *)(*v14 + 12) &= 0xFBu;
      if ( (*((_BYTE *)v14 + 9) & 2) != 0 )
        goto LABEL_45;
      v15 = *v14;
      if ( (*(_BYTE *)(*v14 + 12) & 2) == 0 )
      {
        BG_AddPredictableEventToPlayerstate(140, 0, *v14);
        goto LABEL_45;
      }
LABEL_44:
      BG_AddPredictableEventToPlayerstate(141, 0, v15);
      goto LABEL_45;
    }
    if ( v13 >= 0 )
    {
      *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xFBu;
      v17 = *(_DWORD *)v12;
      v18 = *(_DWORD *)(*(_DWORD *)v12 + 12);
      if ( (v18 & 1) == 0 )
      {
        if ( (v18 & 2) == 0 )
          goto LABEL_45;
        *(float *)(v12 + 212) = *(float *)(v17 + 824);
        (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, _DWORD))(v12 + 240))(
          &v55,
          *(_DWORD *)v12 + 20,
          v12 + 192,
          v12 + 204,
          *(_DWORD *)v12 + 20,
          *(_DWORD *)(*(_DWORD *)v12 + 172),
          *(_DWORD *)(v12 + 52));
        if ( !v60 )
        {
          *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xFDu;
          goto LABEL_45;
        }
        if ( (*(_BYTE *)(pm + 9) & 2) != 0 )
          goto LABEL_45;
        v15 = *(_DWORD *)pm;
        goto LABEL_44;
      }
      *(float *)(v12 + 212) = *(float *)(v17 + 824);
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, _DWORD))(v12 + 240))(
        &v55,
        *(_DWORD *)v12 + 20,
        v12 + 192,
        v12 + 204,
        *(_DWORD *)v12 + 20,
        *(_DWORD *)(*(_DWORD *)v12 + 172),
        *(_DWORD *)(v12 + 52));
      if ( !v60 )
      {
        *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xFCu;
        goto LABEL_45;
      }
      v19 = pm;
      *(float *)(pm + 212) = 50.0;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, _DWORD))(v19 + 240))(
        &v55,
        *(_DWORD *)v19 + 20,
        v19 + 192,
        v19 + 204,
        *(_DWORD *)v19 + 20,
        *(_DWORD *)(*(_DWORD *)v19 + 172),
        *(_DWORD *)(v19 + 52));
      if ( v60 )
      {
LABEL_37:
        if ( (*(_BYTE *)(pm + 9) & 2) == 0 )
          BG_AddPredictableEventToPlayerstate(142, 0, *(_DWORD *)pm);
        goto LABEL_45;
      }
    }
    else
    {
      *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xFBu;
      v16 = *(_DWORD *)(*(_DWORD *)v12 + 12);
      if ( (v16 & 1) == 0 )
      {
        LOBYTE(v16) = v16 | 2;
        *(_DWORD *)(*(_DWORD *)v12 + 12) = v16;
        goto LABEL_45;
      }
      *(float *)(v12 + 212) = 50.0;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, _DWORD))(v12 + 240))(
        &v55,
        *(_DWORD *)v12 + 20,
        v12 + 192,
        v12 + 204,
        *(_DWORD *)v12 + 20,
        *(_DWORD *)(*(_DWORD *)v12 + 172),
        *(_DWORD *)(v12 + 52));
      if ( v60 )
        goto LABEL_37;
    }
    v20 = pm;
    *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xFEu;
    *(_BYTE *)(*(_DWORD *)v20 + 12) |= 2u;
  }
LABEL_45:
  v21 = (float *)pm;
  v22 = *(_DWORD *)pm;
  v23 = *(_DWORD *)(*(_DWORD *)pm + 12);
  if ( (v23 & 1) != 0 )
  {
    if ( g_debugProneCheck[3] == 2 )
      BG_CheckProne(
        *(_DWORD *)(*(_DWORD *)pm + 172),
        *(_DWORD *)pm + 20,
        *(float *)(pm + 204),
        30.0,
        *(float *)(*(_DWORD *)pm + 196),
        0,
        0,
        0,
        0,
        *(_DWORD *)(*(_DWORD *)pm + 84) != 1023,
        0,
        *(_DWORD *)(pm + 240),
        *(_DWORD *)(pm + 236),
        0);
    v24 = (float *)pm;
    *(_BYTE *)(*(_DWORD *)pm + 128) |= 0x40u;
    *(_BYTE *)(*(_DWORD *)v24 + 128) &= 0xDFu;
    *(_DWORD *)(*(_DWORD *)v24 + 204) = *(_DWORD *)(*(_DWORD *)v24 + 828);
    v25 = *(_DWORD *)v24;
    v54 = *(_DWORD *)(*(_DWORD *)v24 + 204);
    v26 = (long double)v54;
    v28 = *(float *)(v25 + 208);
    v29 = v28 < v26;
    v30 = 0;
    v31 = v28 == v26;
    if ( (v27 & 0x44) != 0x40 )
    {
      if ( sub_308CC(-1, -1) <= 0.5 )
      {
        v32 = pm;
        v33 = 50.0;
      }
      else
      {
        v32 = pm;
        v33 = 30.0;
      }
      *(float *)(v32 + 212) = v33;
    }
    else
    {
      v24[53] = 30.0;
    }
    if ( !v5 )
    {
      if ( *(_WORD *)(pm + 24) )
      {
        *(_BYTE *)(*(_DWORD *)pm + 13) &= 0xFBu;
        PM_ClearAimDownSightFlag();
      }
      v34 = pm;
      v35 = *(_DWORD *)(*(_DWORD *)pm + 12);
      if ( (v35 & 0x20) == 0 && *(_BYTE *)(pm + 24) )
      {
        LOBYTE(v35) = v35 | 4;
        *(_DWORD *)(*(_DWORD *)pm + 12) = v35;
        if ( *(_DWORD *)(*(_DWORD *)v34 + 84) != 1023 )
        {
          v36 = 24.0;
          if ( v6 )
            v36 = 34.0;
          *(float *)(*(_DWORD *)v34 + 40) = sqrt((v36 + v36) * (long double)*(int *)(*(_DWORD *)v34 + 60));
          pml[12] = 0.0;
          pml[11] = 0.0;
          *(_DWORD *)(*(_DWORD *)v34 + 84) = 1023;
        }
        *(float *)(*(_DWORD *)pm + 984) = 255.0;
      }
      v50 = *(float *)(*(_DWORD *)pm + 20);
      v51 = *(float *)(*(_DWORD *)pm + 24);
      v52 = *(float *)(*(_DWORD *)pm + 28) + 10.0;
      (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(pm + 236))(
        &v55,
        *(_DWORD *)pm + 20,
        pm + 192,
        pm + 204,
        &v50,
        *(_DWORD *)(*(_DWORD *)pm + 172),
        *(_DWORD *)(pm + 52));
      v50 = v56;
      v51 = v57;
      v52 = v58;
      (*(void (__cdecl **)(float *, float *, int, int, int, _DWORD, _DWORD))(pm + 236))(
        &v55,
        &v50,
        pm + 192,
        pm + 204,
        *(_DWORD *)pm + 20,
        *(_DWORD *)(*(_DWORD *)pm + 172),
        *(_DWORD *)(pm + 52));
      v37 = pm;
      *(float *)(*(_DWORD *)pm + 20) = v56;
      *(float *)(*(_DWORD *)v37 + 24) = v57;
      *(float *)(*(_DWORD *)v37 + 28) = v58;
      *(float *)(*(_DWORD *)v37 + 872) = *(float *)(*(_DWORD *)v37 + 196);
      v53[0] = *(float *)(*(_DWORD *)v37 + 20);
      v53[1] = *(float *)(*(_DWORD *)v37 + 24);
      v53[2] = *(float *)(*(_DWORD *)v37 + 28) - 0.25;
      (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(v37 + 236))(
        &v55,
        *(_DWORD *)v37 + 20,
        v37 + 192,
        v37 + 204,
        v53,
        *(_DWORD *)(*(_DWORD *)v37 + 172),
        *(_DWORD *)(v37 + 52));
      if ( v61 || v55 >= 1.0 )
        *(_DWORD *)(*(_DWORD *)pm + 876) = 0;
      else
        *(float *)(*(_DWORD *)pm + 876) = PitchForYawOnNormal(*(float *)(*(_DWORD *)pm + 872), (int)v59);
      v38 = AngleDelta(*(float *)(*(_DWORD *)pm + 876), *(float *)(*(_DWORD *)pm + 192));
      v39 = v38 < -45.0;
      v40 = 0;
      v41 = v38 == -45.0;
      if ( (v42 & 0x45) == 1 )
      {
        *(float *)(*(_DWORD *)pm + 880) = *(float *)(*(_DWORD *)pm + 192) - 45.0;
      }
      else
      {
        v44 = v38 > 45.0;
        v45 = 0;
        v46 = 45.0 == v38;
        if ( (v43 & 0x45) == 1 )
          *(float *)(*(_DWORD *)pm + 880) = *(float *)(*(_DWORD *)pm + 192) + 45.0;
        else
          *(float *)(*(_DWORD *)pm + 880) = *(float *)(*(_DWORD *)pm + 876);
      }
    }
  }
  else if ( (v23 & 2) != 0 )
  {
    *(_BYTE *)(v22 + 128) |= 0x20u;
    *(_BYTE *)(*(_DWORD *)v21 + 128) &= 0xBFu;
    v21[53] = 50.0;
    *(_DWORD *)(*(_DWORD *)v21 + 204) = *(_DWORD *)(*(_DWORD *)v21 + 832);
  }
  else
  {
    *(_BYTE *)(v22 + 128) &= 0x9Fu;
    v47 = *(_DWORD *)v21;
    v21[53] = *(float *)(*(_DWORD *)v21 + 824);
    *(_DWORD *)(v47 + 204) = *(_DWORD *)(v47 + 836);
  }
  v48 = *(_DWORD *)pm;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0 )
    v49 = *(_DWORD *)(pm + 236);
  else
    v49 = *(_DWORD *)(pm + 240);
  *(_DWORD *)(pm + 232) = v49;
  *(_BYTE *)(v48 + 128) |= 0x10u;
  sub_309D8();
}
// 31C43: variable 'v27' is possibly undefined
// 31EE6: variable 'v42' is possibly undefined
// 31F1A: variable 'v43' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (00031FE4) --------------------------------------------------------
char __cdecl PM_FootstepEvent(char a1, char a2, int a3)
{
  char result; // al
  char v4; // dl
  int v5; // edx
  long double v6; // fst7
  long double v7; // fst4
  long double v8; // fst7
  long double v9; // fst5
  long double v10; // fst4
  long double v11; // fst3
  long double v12; // fst4
  int v13; // ecx
  char v14; // fps^1
  unsigned int v15; // edx
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  int v19; // eax
  float v20; // edx
  unsigned int v21; // edx
  int v22; // ecx
  int v23; // eax
  float v24[12]; // [esp+14h] [ebp-54h] BYREF
  float v25[3]; // [esp+44h] [ebp-24h] BYREF
  float v26; // [esp+50h] [ebp-18h] BYREF
  float v27; // [esp+54h] [ebp-14h]
  float v28; // [esp+58h] [ebp-10h]
  float v29[3]; // [esp+5Ch] [ebp-Ch] BYREF

  result = (a2 + 64) ^ (a1 + 64);
  if ( result >= 0 )
    return result;
  v4 = *(_BYTE *)(pm + 217);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      v23 = *(_DWORD *)pm;
      if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) == 0 )
      {
        if ( *(char *)(v23 + 12) >= 0 )
          return BG_AddPredictableEventToPlayerstate(21, 0, *(_DWORD *)pm);
        return BG_AddPredictableEventToPlayerstate(44, 0, v23);
      }
    }
    else
    {
      if ( v4 != 2 )
        return result;
      v23 = *(_DWORD *)pm;
      if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) == 0 )
      {
        if ( *(char *)(v23 + 12) >= 0 )
          return BG_AddPredictableEventToPlayerstate(21, 0, *(_DWORD *)pm);
        return BG_AddPredictableEventToPlayerstate(44, 0, v23);
      }
    }
    return BG_AddPredictableEventToPlayerstate(67, 0, v23);
  }
  v5 = *(_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 )
  {
    if ( a3 && (*(_BYTE *)(v5 + 12) & 0x10) != 0 )
    {
      v6 = *(float *)(pm + 192);
      v29[0] = *(float *)(pm + 192);
      v7 = v6;
      v8 = *(float *)(pm + 196) + 6.0;
      v29[2] = 8.0;
      v29[0] = v7 + 6.0;
      v29[1] = v8;
      v9 = *(float *)(pm + 204);
      v26 = *(float *)(pm + 204);
      v10 = *(float *)(pm + 208);
      v27 = *(float *)(pm + 208);
      v11 = v10;
      v12 = *(float *)(pm + 212);
      v28 = *(float *)(pm + 212);
      v26 = v9 - 6.0;
      v27 = v11 - 6.0;
      if ( v12 < 8.0 )
        v28 = 8.0;
      v13 = *(_DWORD *)(pm + 52);
      v25[0] = *(float *)(*(_DWORD *)pm + 88) * -31.0 + *(float *)(*(_DWORD *)pm + 20);
      v25[1] = *(float *)(*(_DWORD *)pm + 92) * -31.0 + *(float *)(*(_DWORD *)pm + 24);
      v25[2] = -31.0 * *(float *)(*(_DWORD *)pm + 96) + *(float *)(*(_DWORD *)pm + 28);
      (*(void (__cdecl **)(float *, int, float *, float *, float *, _DWORD, unsigned int))(pm + 232))(
        v24,
        *(_DWORD *)pm + 20,
        v29,
        &v26,
        v25,
        *(_DWORD *)(*(_DWORD *)pm + 172),
        v13 & 0xFDFEFFFF);
      v15 = (LODWORD(v24[7]) & 0x1F00000u) >> 20;
      v16 = v24[0] > 1.0;
      v17 = 0;
      v18 = 1.0 == v24[0];
      if ( (v14 & 0x45) == 64 || !v15 )
        v15 = 13;
      result = BG_AddPredictableEventToPlayerstate(v15 + 1, 0, *(_DWORD *)pm);
    }
  }
  else if ( a3 )
  {
    v19 = *(_DWORD *)(v5 + 12);
    v20 = pml[20];
    if ( (BYTE1(v20) & 0x20) == 0 && (v21 = (LODWORD(v20) & 0x1F00000u) >> 20) != 0 )
    {
      if ( (v19 & 1) != 0 )
      {
        v22 = v21 + 47;
      }
      else
      {
        v22 = v21 + 1;
        if ( (v19 & 0x80u) != 0 )
          v22 = v21 + 24;
      }
    }
    else
    {
      v22 = 0;
    }
    result = BG_AddPredictableEventToPlayerstate(v22, 0, *(_DWORD *)pm);
  }
  return result;
}
// 32129: variable 'v14' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (0003221C) --------------------------------------------------------
_BOOL4 PM_ShouldMakeFootsteps()
{
  int v0; // edx
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v0 = *(_DWORD *)pm;
  if ( (*(_DWORD *)(*(_DWORD *)pm + 12) & 1) != 0
    || (v1 = *(_DWORD *)(v0 + 216), v1 == *(_DWORD *)(v0 + 828))
    || (v2 = *(_DWORD *)(v0 + 212)) != 0 && v1 == *(_DWORD *)(v0 + 832) && !*(_DWORD *)(v0 + 220) )
  {
    v3 = 1;
  }
  else if ( (*(_BYTE *)(v0 + 12) & 2) != 0 || v2 && v1 == *(_DWORD *)(v0 + 832) )
  {
    v3 = 2;
  }
  else
  {
    v3 = 0;
  }
  return v3 != 1 && v3 != 2 && (*(_DWORD *)(*(_DWORD *)pm + 12) & 0x80) == 0;
}
// 16EE30: using guessed type int pm;

//----- (000322C8) --------------------------------------------------------
char sub_322C8()
{
  _DWORD **v0; // eax
  int v1; // esi
  int v2; // edx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  long double v6; // fst7
  long double v7; // fst6
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  int v12; // ecx
  int v13; // ebx
  char v14; // fps^1
  long double v15; // fst7
  int v16; // edi
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  int v20; // ecx
  long double v21; // fst7
  char v22; // dl
  long double v23; // fst5
  int v24; // eax
  char v25; // bl
  int v26; // eax
  long double v27; // fst7
  long double v28; // fst7
  char v29; // fps^1
  long double v30; // fst5
  long double v31; // fst7
  bool v32; // c0
  char v33; // c2
  bool v34; // c3
  float *v35; // edx
  long double v36; // fst6
  long double v37; // fst5
  long double v38; // fst7
  char v39; // fps^1
  long double v40; // fst5
  bool v41; // c0
  char v42; // c2
  bool v43; // c3
  long double v44; // fst7
  int v45; // eax
  long double v46; // fst7
  float *v47; // ecx
  int v48; // ebx
  __int16 v49; // fps
  bool v50; // c0
  char v51; // c2
  bool v52; // c3
  _DWORD *v53; // edx
  int v55; // [esp-8h] [ebp-50h]
  int v56; // [esp-8h] [ebp-50h]
  int v57; // [esp-8h] [ebp-50h]
  int v58; // [esp+14h] [ebp-34h]
  long double v59; // [esp+18h] [ebp-30h]
  int v60; // [esp+28h] [ebp-20h]
  float v61; // [esp+2Ch] [ebp-1Ch]
  float v62; // [esp+2Ch] [ebp-1Ch]

  v0 = (_DWORD **)pm;
  v1 = -1;
  if ( *(int *)(*(_DWORD *)pm + 4) > 5 )
    return (char)v0;
  v2 = *(_DWORD *)pm;
  *(float *)(pm + 220) = sqrt(
                           *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
                         + *(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36));
  if ( (*(_BYTE *)(v2 + 129) & 0xC0) != 0 )
  {
    v3 = *(_DWORD *)(v2 + 12);
    if ( (v3 & 1) != 0 )
    {
      LOBYTE(v0) = BG_AnimScriptAnimation(*v0, 3, 3, 1);
    }
    else
    {
      if ( (v3 & 2) != 0 )
        v55 = 2;
      else
        v55 = 1;
      LOBYTE(v0) = BG_AnimScriptAnimation(*v0, 3, v55, 1);
    }
    return (char)v0;
  }
  if ( (*(_BYTE *)(v2 + 12) & 1) != 0
    || (v0 = *(_DWORD ***)(v2 + 216), v0 == *(_DWORD ***)(v2 + 828))
    || (v4 = *(_DWORD *)(v2 + 212)) != 0 && v0 == *(_DWORD ***)(v2 + 832) && !*(_DWORD *)(v2 + 220) )
  {
    v60 = 1;
  }
  else if ( (*(_BYTE *)(v2 + 12) & 2) != 0 || v4 && v0 == *(_DWORD ***)(v2 + 832) )
  {
    v60 = 2;
  }
  else
  {
    v60 = 0;
  }
  v5 = *(_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 )
  {
    if ( (*(_BYTE *)(v5 + 12) & 0x10) != 0 )
    {
      v0 = (_DWORD **)(*(_DWORD *)(pm + 4) - *(_DWORD *)(v5 + 100));
      if ( (int)v0 > 299 )
      {
        v6 = *(float *)(v5 + 40);
        if ( *(char *)(v5 + 12) >= 0 )
          v7 = v6 / (95.25 * *(float *)(v5 + 848)) * 0.44999999;
        else
          v7 = v6 / (95.25 * *(float *)(v5 + 844)) * 0.34999999;
        v9 = v6 > 0.0;
        v10 = 0;
        v11 = 0.0 == v6;
        if ( (unsigned __int8)((v8 & 0x45) - 1) >= 0x40u )
          BG_AnimScriptAnimation(*(_DWORD **)pm, 3, 17, 1);
        else
          BG_AnimScriptAnimation(*(_DWORD **)pm, 3, 16, 1);
        v12 = pm;
        v13 = *(_DWORD *)(*(_DWORD *)pm + 8);
        v61 = v7;
        *(_DWORD *)(*(_DWORD *)pm + 8) = (unsigned __int8)(int)((long double)SLODWORD(pml[10]) * v61 + (long double)v13);
        LOBYTE(v0) = PM_FootstepEvent(v13, *(_DWORD *)(*(_DWORD *)v12 + 8), 1);
      }
    }
    return (char)v0;
  }
  v15 = *(float *)(pm + 220);
  v16 = *(_DWORD *)(v5 + 12) & 0x80;
  v17 = v15 < 10.0;
  v18 = 0;
  v19 = v15 == 10.0;
  if ( (v14 & 0x45) == 1 )
  {
    if ( v15 < 1.0 )
      *(_DWORD *)(v5 + 8) = 0;
    LOBYTE(v0) = pm;
    v20 = *(_DWORD *)(*(_DWORD *)pm + 216);
    if ( v20 == *(_DWORD *)(*(_DWORD *)pm + 828) )
    {
      v56 = 3;
    }
    else
    {
      if ( v20 != *(_DWORD *)(*(_DWORD *)pm + 832) )
        goto LABEL_97;
      v56 = 2;
    }
    v0 = *(_DWORD ***)pm;
    goto LABEL_95;
  }
  v21 = (long double)*(int *)(v5 + 68);
  v22 = *(_BYTE *)(pm + 24);
  if ( v22 )
  {
    if ( *(_BYTE *)(pm + 25) )
    {
      v23 = ((*(float *)(*(_DWORD *)pm + 860) - 1.0) * 0.75 + 1.0 + 1.0) * 0.5 * v21;
      if ( v22 >= 0 )
        v21 = v23;
      else
        v21 = 0.5 * (*(float *)(*(_DWORD *)pm + 864) + 1.0) * v23;
    }
    else if ( v22 < 0 )
    {
      v21 = v21 * *(float *)(*(_DWORD *)pm + 864);
    }
    v57 = 0;
    v24 = *(_DWORD *)pm;
    goto LABEL_50;
  }
  v25 = *(_BYTE *)(pm + 25);
  if ( v25 )
  {
    v24 = *(_DWORD *)pm;
    v21 = v21 * ((*(float *)(*(_DWORD *)pm + 860) - 1.0) * 0.75 + 1.0);
    if ( v25 <= 0 )
    {
      v57 = 1;
LABEL_50:
      v26 = *(_DWORD *)(v24 + 172);
      BG_UpdateConditionValue(v26, 8, v57, 1);
      goto LABEL_52;
    }
    BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm + 172), 8, 2, 1);
  }
LABEL_52:
  if ( v16 )
    v27 = v21 * *(float *)(*(_DWORD *)pm + 844);
  else
    v27 = v21 * *(float *)(*(_DWORD *)pm + 848);
  v59 = v27;
  v28 = sub_308CC(*(_DWORD *)(*(_DWORD *)pm + 832), *(_DWORD *)(*(_DWORD *)pm + 828));
  v30 = v28;
  v31 = v59;
  v32 = v30 < 0.0;
  v33 = 0;
  v34 = v30 == 0.0;
  if ( (v29 & 0x45) != 64 )
  {
    v35 = (float *)pm;
    v36 = v30 * *(float *)(*(_DWORD *)pm + 852);
    v37 = (1.0 - v30) * *(float *)(*(_DWORD *)pm + 856);
LABEL_59:
    v31 = v31 * (v36 + v37);
    goto LABEL_64;
  }
  v38 = sub_308CC(*(_DWORD *)(*(_DWORD *)pm + 828), *(_DWORD *)(*(_DWORD *)pm + 832));
  v40 = v38;
  v31 = v59;
  v41 = v40 < 0.0;
  v42 = 0;
  v43 = v40 == 0.0;
  if ( (v39 & 0x45) != 64 )
  {
    v35 = (float *)pm;
    v36 = v40 * *(float *)(*(_DWORD *)pm + 856);
    v37 = (1.0 - v40) * *(float *)(*(_DWORD *)pm + 852);
    goto LABEL_59;
  }
  if ( v60 == 1 )
  {
    v35 = (float *)pm;
    v31 = v59 * *(float *)(*(_DWORD *)pm + 852);
  }
  else
  {
    v35 = (float *)pm;
    if ( v60 == 2 )
      v31 = v59 * *(float *)(*(_DWORD *)pm + 856);
  }
LABEL_64:
  if ( v60 == 1 )
  {
    if ( v16 )
      v44 = v35[55] / v31 * 0.23999999;
    else
      v44 = v35[55] / v31 * 0.25;
    v62 = v44;
    if ( (*(_BYTE *)(*(_DWORD *)v35 + 12) & 0x40) != 0 )
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 9, 1);
    else
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 8, 1);
  }
  else if ( v60 == 2 )
  {
    if ( v16 )
      v46 = v35[55] / v31 * 0.315;
    else
      v46 = v35[55] / v31 * 0.34;
    v62 = v46;
    if ( (*(_BYTE *)(*(_DWORD *)v35 + 12) & 0x40) != 0 )
    {
      if ( v16 )
        v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 7, 1);
      else
        v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 13, 1);
    }
    else if ( v16 )
    {
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 6, 1);
    }
    else
    {
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 12, 1);
    }
  }
  else if ( (*(_BYTE *)(*(_DWORD *)v35 + 12) & 0x40) != 0 )
  {
    if ( v16 )
    {
      v62 = v35[55] / v31 * 0.32499999;
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 5, 1);
    }
    else
    {
      v62 = v35[55] / v31 * 0.36000001;
      v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 11, 1);
    }
  }
  else if ( v16 )
  {
    v62 = v35[55] / v31 * 0.30500001;
    v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 4, 1);
  }
  else
  {
    v62 = v35[55] / v31 * 0.33500001;
    v45 = BG_AnimScriptAnimation(*(_DWORD **)v35, 3, 10, 1);
  }
  v1 = v45;
  v58 = PM_ShouldMakeFootsteps();
  v47 = (float *)pm;
  v48 = *(_DWORD *)(*(_DWORD *)pm + 8);
  *(_DWORD *)(*(_DWORD *)pm + 8) = (unsigned __int8)(int)((long double)SLODWORD(pml[10]) * v62 + (long double)v48);
  if ( !*((_WORD *)v47 + 12) )
  {
    v50 = v47[55] > 120.0;
    v51 = 0;
    v52 = 120.0 == v47[55];
    LOBYTE(v0) = v49;
    if ( (HIBYTE(v49) & 0x45) == 1 )
      return (char)v0;
    v0 = *(_DWORD ***)v47;
    v53 = *(_DWORD **)(*(_DWORD *)v47 + 216);
    if ( v53 == *(_DWORD **)(*(_DWORD *)v47 + 828) )
    {
      v0 = (_DWORD **)BG_AnimScriptAnimation(v0, 3, 3, 1);
LABEL_96:
      v1 = (int)v0;
LABEL_97:
      if ( v1 < 0 )
        LOBYTE(v0) = BG_AnimScriptAnimation(*(_DWORD **)pm, 3, 1, 1);
      return (char)v0;
    }
    if ( v53 != v0[208] )
      goto LABEL_97;
    v56 = 2;
LABEL_95:
    v0 = (_DWORD **)BG_AnimScriptAnimation(v0, 3, v56, 1);
    goto LABEL_96;
  }
  if ( v1 < 0 )
    BG_AnimScriptAnimation(*(_DWORD **)v47, 3, 1, 1);
  LOBYTE(v0) = PM_FootstepEvent(v48, *(_DWORD *)(*(_DWORD *)pm + 8), v58);
  return (char)v0;
}
// 32409: variable 'v8' is possibly undefined
// 324A7: variable 'v14' is possibly undefined
// 3260E: variable 'v29' is possibly undefined
// 32667: variable 'v39' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (000328CC) --------------------------------------------------------
int sub_328CC()
{
  long double v0; // fst7
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  int result; // eax
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  float v12[2]; // [esp+20h] [ebp-48h] BYREF
  float v13; // [esp+28h] [ebp-40h]
  float v14[3]; // [esp+2Ch] [ebp-3Ch] BYREF
  char v15[48]; // [esp+38h] [ebp-30h] BYREF

  v0 = (long double)bg_foliagesnd_minspeed[3];
  v2 = *(float *)(pm + 220);
  v3 = v2 < v0;
  v4 = 0;
  v5 = v2 == v0;
  if ( (v1 & 0x45) == 1 )
  {
    result = *(_DWORD *)(*(_DWORD *)pm + 56) + bg_foliagesnd_resetinterval[3];
    if ( result < *(_DWORD *)(pm + 4) )
      *(_DWORD *)(*(_DWORD *)pm + 56) = 0;
  }
  else
  {
    v7 = (v2 - v0) / (long double)(bg_foliagesnd_maxspeed[3] - bg_foliagesnd_minspeed[3]);
    v9 = v7 > 1.0;
    v10 = 0;
    v11 = 1.0 == v7;
    if ( (v8 & 0x45) == 1 )
      v7 = 1.0;
    result = *(_DWORD *)(*(_DWORD *)pm + 56)
           + (int)(v7 * (long double)(bg_foliagesnd_fastinterval[3] - bg_foliagesnd_slowinterval[3])
                 + (long double)bg_foliagesnd_slowinterval[3]);
    if ( result < *(_DWORD *)(pm + 4) )
    {
      v14[0] = *(float *)(pm + 192) * 0.75;
      v14[1] = *(float *)(pm + 196) * 0.75;
      v14[2] = *(float *)(pm + 200) * 0.75;
      v12[0] = *(float *)(pm + 204) * 0.75;
      v12[1] = *(float *)(pm + 208) * 0.75;
      v13 = 0.75 * *(float *)(pm + 212);
      v13 = *(float *)(pm + 212) * 0.89999998;
      result = (*(int (__cdecl **)(char *, int, float *, float *, int, _DWORD, int))(pm + 232))(
                 v15,
                 *(_DWORD *)pm + 20,
                 v14,
                 v12,
                 *(_DWORD *)pm + 20,
                 *(_DWORD *)(*(_DWORD *)pm + 172),
                 2);
      if ( v15[47] )
      {
        BG_AddPredictableEventToPlayerstate(139, 0, *(_DWORD *)pm);
        result = *(_DWORD *)(pm + 4);
        *(_DWORD *)(*(_DWORD *)pm + 56) = result;
      }
    }
  }
  return result;
}
// 328EF: variable 'v1' is possibly undefined
// 32937: variable 'v8' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (00032A44) --------------------------------------------------------
int sub_32A44()
{
  int v0; // ebx
  int v1; // ecx
  int v2; // edx
  float v3; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // ecx
  int result; // eax

  v0 = pm;
  v1 = *(_DWORD *)pm;
  v2 = *(_DWORD *)(*(_DWORD *)pm + 16);
  if ( v2 )
  {
    v3 = pml[10];
    if ( SLODWORD(v3) < v2 )
    {
      *(_DWORD *)(v1 + 16) = v2 - LODWORD(v3);
    }
    else
    {
      *(_BYTE *)(v1 + 13) &= 0xDCu;
      *(_DWORD *)(*(_DWORD *)v0 + 16) = 0;
    }
  }
  v4 = pm;
  v5 = *(_DWORD *)(*(_DWORD *)pm + 108);
  if ( v5 > 0 )
  {
    *(_DWORD *)(*(_DWORD *)pm + 108) = v5 - LODWORD(pml[10]);
    if ( *(int *)(*(_DWORD *)v4 + 108) < 0 )
      *(_DWORD *)(*(_DWORD *)v4 + 108) = 0;
  }
  v6 = pm;
  result = *(_DWORD *)(*(_DWORD *)pm + 116);
  if ( result > 0 )
  {
    *(_DWORD *)(*(_DWORD *)pm + 116) = result - LODWORD(pml[10]);
    result = *(_DWORD *)v6;
    if ( *(int *)(*(_DWORD *)v6 + 116) < 0 )
      *(_DWORD *)(result + 116) = 0;
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (00032AC8) --------------------------------------------------------
__int16 __cdecl PM_UpdateLean(int a1, int a2, void (__stdcall *a3)(float *, float *, float *, float *))
{
  int v3; // ebx
  char v4; // dl
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  long double v10; // fst7
  char v11; // fps^1
  long double v12; // fst6
  char v13; // fps^1
  long double v14; // fst5
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst4
  char v19; // fps^1
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  char v26; // fps^1
  bool v27; // c0
  char v28; // c2
  bool v29; // c3
  char v30; // fps^1
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  __int16 v34; // fps
  bool v35; // c0
  char v36; // c2
  bool v37; // c3
  int v38; // eax
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  long double v42; // fst7
  long double v43; // fst5
  long double v44; // fst7
  long double v45; // fst7
  __int16 v46; // fps
  long double v47; // fst5
  bool v48; // c0
  char v49; // c2
  bool v50; // c3
  float v52; // [esp-18h] [ebp-A0h]
  float v53[12]; // [esp+28h] [ebp-60h] BYREF
  float v54[3]; // [esp+58h] [ebp-30h] BYREF
  float v55[3]; // [esp+64h] [ebp-24h] BYREF
  int v56[3]; // [esp+70h] [ebp-18h] BYREF
  float v57; // [esp+7Ch] [ebp-Ch] BYREF
  int v58; // [esp+80h] [ebp-8h]
  int v59; // [esp+84h] [ebp-4h]

  v3 = 0;
  v4 = *(_BYTE *)(a2 + 5);
  if ( (v4 & 0x30) != 0 && (*(_BYTE *)(a1 + 13) & 0x40) == 0 )
  {
    v5 = *(_DWORD *)(a1 + 4);
    if ( v5 <= 5 && (*(_DWORD *)(a1 + 84) != 1023 || v5 == 1) )
    {
      if ( (v4 & 0x10) != 0 )
        v3 = -1;
      if ( (v4 & 0x20) != 0 )
        ++v3;
    }
  }
  if ( (*(_BYTE *)(a1 + 129) & 0xC0) != 0 )
    v3 = 0;
  v6 = *(_DWORD *)(a1 + 12);
  if ( (v6 & 1) != 0
    || (v7 = *(_DWORD *)(a1 + 216), v7 == *(_DWORD *)(a1 + 828))
    || (v8 = *(_DWORD *)(a1 + 212)) != 0 && v7 == *(_DWORD *)(a1 + 832) && !*(_DWORD *)(a1 + 220) )
  {
    v9 = 1;
  }
  else if ( (v6 & 2) != 0 || v8 && v7 == *(_DWORD *)(a1 + 832) )
  {
    v9 = 2;
  }
  else
  {
    v9 = 0;
  }
  v10 = 0.25;
  if ( v9 != 1 )
  {
    v10 = 1.0;
    if ( v9 == 2 )
      v10 = 0.5;
  }
  v12 = *(float *)(a1 + 64);
  if ( v3 )
  {
    if ( v3 > 0 )
    {
      v23 = v12 < v10;
      v24 = 0;
      v25 = v12 == v10;
      if ( (v11 & 0x45) == 1 )
        v12 = v12 + (long double)SLODWORD(pml[10]) / 350.0 * v10;
      if ( v12 <= v10 )
        goto LABEL_42;
      goto LABEL_43;
    }
    v14 = -v10;
    v27 = -v10 < v12;
    v28 = 0;
    v29 = -v10 == v12;
    if ( (v26 & 0x45) != 1 )
    {
      v10 = v14;
LABEL_41:
      v31 = v12 < v10;
      v32 = 0;
      v33 = v12 == v10;
      if ( (v30 & 0x45) != 1 )
        goto LABEL_42;
      goto LABEL_43;
    }
    v18 = (long double)SLODWORD(pml[10]) / 350.0;
LABEL_39:
    v12 = v12 - v10 * v18;
    v10 = v14;
    goto LABEL_41;
  }
  v14 = 0.0;
  v15 = v12 > 0.0;
  v16 = 0;
  v17 = 0.0 == v12;
  if ( (v13 & 0x45) == 1 )
  {
    v18 = (long double)SLODWORD(pml[10]) / 280.0;
    goto LABEL_39;
  }
  if ( v12 >= 0.0 )
  {
LABEL_42:
    v10 = v12;
    goto LABEL_43;
  }
  v10 = v10 * ((long double)SLODWORD(pml[10]) / 280.0) + *(float *)(a1 + 64);
  v20 = v10 > 0.0;
  v21 = 0;
  v22 = 0.0 == v10;
  if ( (v19 & 0x45) == 1 )
    v10 = 0.0;
LABEL_43:
  *(float *)(a1 + 64) = v10;
  v35 = v10 < 0.0;
  v36 = 0;
  v37 = v10 == 0.0;
  LOBYTE(v38) = v34;
  BYTE1(v38) = HIBYTE(v34) & 0x45;
  if ( (HIBYTE(v34) & 0x45) != 64 && *(_DWORD *)(a1 + 4) != 1 )
  {
    v39 = v10 < 0.0;
    v40 = 0;
    v41 = v10 == 0.0;
    v42 = *(float *)(a1 + 20);
    v57 = *(float *)(a1 + 20);
    v58 = *(int *)(a1 + 24);
    v43 = v42;
    v44 = *(float *)(a1 + 28) + *(float *)(a1 + 208);
    *(float *)v56 = v43;
    v56[1] = v58;
    *(float *)&v59 = v44;
    v56[2] = v59;
    v52 = (float)(-2 * ((HIBYTE(v34) & 0x45) == 1) + 1);
    AddLeanToPosition((int)v56, *(float *)(a1 + 196), v52, 16.0, 20.0);
    v55[0] = -8.0;
    v55[1] = -8.0;
    v55[2] = -8.0;
    v54[0] = 8.0;
    v54[1] = 8.0;
    v54[2] = 8.0;
    a3(v53, &v57, v55, v54);
    v45 = v53[0];
    UnGetLeanFraction(v53[0]);
    v47 = fabs(*(float *)(a1 + 64));
    v48 = v47 < v45;
    v49 = 0;
    v50 = v47 == v45;
    LOBYTE(v38) = v46;
    BYTE1(v38) = HIBYTE(v46) & 0x45;
    if ( v47 > v45 )
    {
      v38 = -2 * (*(float *)(a1 + 64) < 0.0) + 1;
      *(float *)(a1 + 64) = v45 * (long double)v38;
    }
  }
  return v38;
}
// 32B9B: variable 'v13' is possibly undefined
// 32BD4: variable 'v19' is possibly undefined
// 32BEA: variable 'v11' is possibly undefined
// 32C18: variable 'v26' is possibly undefined
// 32C3C: variable 'v30' is possibly undefined

//----- (00032D7C) --------------------------------------------------------
__int16 __cdecl PM_UpdateViewAngles(int a1, int a2, void (__stdcall *a3)(float *, float *, float *, float *))
{
  int v3; // eax
  __int16 v4; // ax
  int v5; // ecx
  int v6; // edx
  __int16 v7; // ax
  long double v8; // fst7
  long double v9; // fst7
  int v10; // edx
  long double v11; // fst6
  long double v12; // fst6
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst7
  long double v18; // fst5
  long double v19; // fst7
  float v20; // edx
  char v21; // fps^1
  long double v22; // fst6
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  char v26; // fps^1
  bool v27; // c0
  char v28; // c2
  bool v29; // c3
  long double v30; // fst6
  long double v31; // fst6
  char v32; // fps^1
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  char v36; // fps^1
  long double v37; // fst6
  bool v38; // c0
  char v39; // c2
  bool v40; // c3
  int v41; // edx
  char v42; // fps^1
  long double v43; // fst6
  bool v44; // c0
  char v45; // c2
  bool v46; // c3
  bool v47; // c0
  char v48; // c2
  bool v49; // c3
  long double v50; // fst7
  char v51; // fps^1
  bool v52; // c0
  char v53; // c2
  bool v54; // c3
  long double v55; // fst7
  long double v56; // fst7
  char v57; // fps^1
  long double v58; // fst6
  bool v59; // c0
  char v60; // c2
  bool v61; // c3
  char v62; // fps^1
  bool v63; // c0
  char v64; // c2
  bool v65; // c3
  bool v66; // c0
  char v67; // c2
  bool v68; // c3
  long double v69; // fst7
  char v70; // fps^1
  bool v71; // c0
  char v72; // c2
  bool v73; // c3
  long double v74; // fst7
  float v76; // [esp-30h] [ebp-C8h]
  float v77; // [esp-20h] [ebp-B8h]
  float v78; // [esp-20h] [ebp-B8h]
  float v79; // [esp-20h] [ebp-B8h]
  float v80; // [esp-18h] [ebp-B0h]
  float v81; // [esp-14h] [ebp-ACh]
  float v82; // [esp-10h] [ebp-A8h]
  float v83; // [esp-10h] [ebp-A8h]
  float v84; // [esp-10h] [ebp-A8h]
  long double v85; // [esp+18h] [ebp-80h]
  float v86[3]; // [esp+6Ch] [ebp-2Ch] BYREF
  float v87[3]; // [esp+78h] [ebp-20h] BYREF
  int v88; // [esp+84h] [ebp-14h] BYREF
  float v89; // [esp+88h] [ebp-10h]
  float v90; // [esp+8Ch] [ebp-Ch]
  int v91; // [esp+90h] [ebp-8h]
  __int16 v92; // [esp+94h] [ebp-4h]
  __int16 v93; // [esp+96h] [ebp-2h]

  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 == 5 )
    return v3;
  if ( v3 > 5 )
  {
    v4 = *(_WORD *)(a2 + 12) + *(_WORD *)(a1 + 76);
    if ( *(_DWORD *)(a1 + 248) == 999 )
    {
      v93 = *(_WORD *)(a2 + 12) + *(_WORD *)(a1 + 76);
      v92 = v4 | 0xC00;
      *(_DWORD *)(a1 + 248) = (int)((long double)v4 * 0.0054931641);
    }
    LOWORD(v3) = PM_UpdateLean(a1, a2, a3);
    return v3;
  }
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = *(_WORD *)(a2 + 8 + v6) + *(_WORD *)(a1 + 72 + v6);
    if ( !v5 )
    {
      if ( v7 <= 16000 )
      {
        if ( v7 < -16000 )
        {
          *(_DWORD *)(a1 + 72) = -16000 - *(_DWORD *)(a2 + 8);
          v7 = -16000;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 72) = 16000 - *(_DWORD *)(a2 + 8);
        v7 = 16000;
      }
    }
    v93 = v7;
    ++v5;
    *(float *)(a1 + 192 + v6) = (long double)v7 * 0.0054931641;
    v6 += 4;
  }
  while ( v5 <= 2 );
  if ( (*(_BYTE *)(a1 + 12) & 0x10) != 0 && *(_DWORD *)(a1 + 84) == 1023 )
  {
    if ( bg_ladder_yawcap[3] )
    {
      v8 = vectoyaw((float *)(a1 + 88)) + 180.0;
      v77 = v8;
      v85 = v8;
      v9 = AngleDelta(v77, *(float *)(a1 + 196));
      v10 = bg_ladder_yawcap[3];
      v11 = (long double)v10;
      if ( v9 > v11 || (v91 = -v10, (long double)-v10 > v9) )
      {
        if ( v9 <= v11 )
          v12 = v11 + v9;
        else
          v12 = v9 - v11;
        v92 = v93 | 0xC00;
        v91 = (int)(v12 * 182.04445);
        *(_DWORD *)(a1 + 76) += (unsigned __int16)v91;
        v14 = v12 > 0.0;
        v15 = 0;
        v16 = 0.0 == v12;
        if ( (v13 & 0x45) == 1 )
          v17 = v85 - (long double)bg_ladder_yawcap[3];
        else
          v17 = v85 + (long double)bg_ladder_yawcap[3];
        v82 = v17;
        *(float *)(a1 + 196) = AngleNormalize360(v82);
      }
    }
  }
  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 && (*(_BYTE *)(a1 + 129) & 0xC0) == 0 )
  {
    if ( g_debugProneCheck[3] )
    {
      v88 = *(int *)(a1 + 20);
      v89 = *(float *)(a1 + 24);
      v90 = (long double)*(int *)(a1 + 828) + *(float *)(a1 + 28);
      AngleVectors((float *)(a1 + 192), v86, 0, 0);
      v87[0] = v86[0] * 18.0 + *(float *)&v88;
      v87[1] = v86[1] * 18.0 + v89;
      v87[2] = 18.0 * v86[2] + v90;
      G_DebugLine((int)&v88, (int)v87, (int)&colorWhite);
      v18 = bg_prone_yawcap[2];
      v81 = *(float *)(a1 + 872) + v18;
      v80 = *(float *)(a1 + 872) - v18;
      G_DebugArc((int)&v88, 16.0, v80, v81, (int)&colorWhite);
    }
    v78 = AngleDelta(*(float *)(a1 + 872), *(float *)(a1 + 196));
    v19 = AngleNormalize180(v78);
    if ( bg_prone_softyawedge[3] )
    {
      v20 = bg_prone_yawcap[3];
      v91 = LODWORD(v20) - 5;
      v22 = (long double)(LODWORD(v20) - 5);
      v23 = v22 < v19;
      v24 = 0;
      v25 = v22 == v19;
      if ( (v21 & 0x45) == 1 )
        goto LABEL_34;
      v91 = 5 - LODWORD(v20);
      if ( (long double)(5 - LODWORD(v20)) > v19 )
        goto LABEL_34;
    }
    if ( *(_WORD *)(a2 + 20) )
    {
      v27 = v19 > 0.0;
      v28 = 0;
      v29 = 0.0 == v19;
      if ( (v26 & 0x45) != 64 )
      {
LABEL_34:
        v30 = pml[9] * 55.0;
        if ( v30 <= fabs(v19) )
        {
          v33 = v19 > 0.0;
          v34 = 0;
          v35 = 0.0 == v19;
          if ( (v32 & 0x45) == 1 )
            v31 = *(float *)(a1 + 872) - v30;
          else
            v31 = v30 + *(float *)(a1 + 872);
        }
        else
        {
          v31 = *(float *)(a1 + 196);
        }
        v76 = v31;
        if ( BG_CheckProne(
               *(_DWORD *)(a1 + 172),
               a1 + 20,
               *(float *)(a1 + 816),
               30.0,
               v76,
               a1 + 964,
               a1 + 968,
               a1 + 972,
               1,
               *(_DWORD *)(a1 + 84) != 1023,
               0,
               (int)a3,
               0,
               0) )
        {
          *(float *)(a1 + 872) = v31;
        }
        else
        {
          v37 = (long double)SLODWORD(bg_prone_yawcap[3]) + 0.1;
          v38 = v37 < v19;
          v39 = 0;
          v40 = v37 == v19;
          if ( (v36 & 0x45) == 1 || -v37 > v19 )
            *(_BYTE *)(a1 + 13) |= 0x80u;
        }
      }
    }
    v41 = LODWORD(bg_prone_yawcap[3]);
    v91 = v41;
    v43 = (long double)v41;
    v44 = v43 < v19;
    v45 = 0;
    v46 = v43 == v19;
    if ( (v42 & 0x45) == 1 || (v91 = -v41, (long double)-v41 > v19) )
    {
      v47 = v43 < v19;
      v48 = 0;
      v49 = v43 == v19;
      if ( (v42 & 0x45) == 1 )
        v50 = v19 - v43;
      else
        v50 = v19 + v43;
      v92 = v93 | 0xC00;
      v91 = (int)(v50 * 182.04445);
      *(_DWORD *)(a1 + 76) += (unsigned __int16)v91;
      v52 = v50 > 0.0;
      v53 = 0;
      v54 = 0.0 == v50;
      if ( (v51 & 0x45) == 1 )
        v55 = *(float *)(a1 + 872) - (long double)SLODWORD(bg_prone_yawcap[3]);
      else
        v55 = (long double)SLODWORD(bg_prone_yawcap[3]) + *(float *)(a1 + 872);
      v83 = v55;
      *(float *)(a1 + 196) = AngleNormalize360(v83);
    }
    v79 = AngleDelta(*(float *)(a1 + 880), *(float *)(a1 + 192));
    v56 = AngleNormalize180(v79);
    v58 = 45.0;
    v59 = v56 > 45.0;
    v60 = 0;
    v61 = 45.0 == v56;
    if ( (v57 & 0x45) != 1 )
    {
      v63 = v56 < -45.0;
      v64 = 0;
      v65 = v56 == -45.0;
      if ( (v62 & 0x45) != 1 )
        goto LABEL_63;
      v58 = 45.0;
    }
    v66 = v58 < v56;
    v67 = 0;
    v68 = v58 == v56;
    if ( (v57 & 0x45) == 1 )
      v69 = v56 - v58;
    else
      v69 = v56 + v58;
    v92 = v93 | 0xC00;
    v91 = (int)(v69 * 182.04445);
    *(_DWORD *)(a1 + 72) += (unsigned __int16)v91;
    v71 = v69 > 0.0;
    v72 = 0;
    v73 = 0.0 == v69;
    if ( (v70 & 0x45) == 1 )
      v74 = *(float *)(a1 + 880) - 45.0;
    else
      v74 = *(float *)(a1 + 880) + 45.0;
    v84 = v74;
    *(float *)(a1 + 192) = AngleNormalize180(v84);
  }
LABEL_63:
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 != 3 && v3 != 2 && v3 != 4 )
    LOWORD(v3) = PM_UpdateLean(a1, a2, a3);
  return v3;
}
// 32F44: variable 'v13' is possibly undefined
// 3309F: variable 'v21' is possibly undefined
// 330D1: variable 'v26' is possibly undefined
// 33108: variable 'v32' is possibly undefined
// 331AD: variable 'v36' is possibly undefined
// 331D8: variable 'v42' is possibly undefined
// 33239: variable 'v51' is possibly undefined
// 332B4: variable 'v57' is possibly undefined
// 332C6: variable 'v62' is possibly undefined
// 33318: variable 'v70' is possibly undefined

//----- (0003338C) --------------------------------------------------------
void PM_UpdatePronePitch()
{
  float *v0; // eax
  long double v1; // fst7
  long double v2; // fst7
  long double v3; // fst6
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst4
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  long double v12; // fst6
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst4
  long double v18; // fst7
  float v19; // [esp-10h] [ebp-38h]
  float v20; // [esp-10h] [ebp-38h]

  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) == 0 )
    return;
  if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 )
  {
    v0 = 0;
    if ( LODWORD(pml[12]) )
      v0 = &pml[17];
    if ( !BG_CheckProne(
            *(_DWORD *)(*(_DWORD *)pm + 172),
            *(_DWORD *)pm + 20,
            *(float *)(*(_DWORD *)pm + 816),
            30.0,
            *(float *)(*(_DWORD *)pm + 872),
            *(_DWORD *)pm + 964,
            *(_DWORD *)pm + 968,
            *(_DWORD *)pm + 972,
            1,
            *(_DWORD *)(*(_DWORD *)pm + 84) != 1023,
            (int)v0,
            *(_DWORD *)(pm + 240),
            *(_DWORD *)(pm + 236),
            0) )
    {
      BG_AddPredictableEventToPlayerstate(141, 0, *(_DWORD *)pm);
      *(_BYTE *)(*(_DWORD *)pm + 13) |= 0x80u;
    }
  }
  else
  {
    if ( !LODWORD(pml[12]) )
    {
LABEL_12:
      v1 = 0.0;
      goto LABEL_13;
    }
    if ( pml[19] < 0.69999999 )
      BG_AddPredictableEventToPlayerstate(141, 0, *(_DWORD *)pm);
  }
  if ( !LODWORD(pml[12]) )
    goto LABEL_12;
  v1 = PitchForYawOnNormal(*(float *)(*(_DWORD *)pm + 872), (int)&pml[17]);
LABEL_13:
  v19 = v1;
  v2 = AngleDelta(v19, *(float *)(*(_DWORD *)pm + 876));
  v3 = v2;
  v5 = v2 > 0.0;
  v6 = 0;
  v7 = 0.0 == v2;
  if ( (v4 & 0x45) != 64 )
  {
    v8 = v2;
    v9 = pml[9] * 70.0;
    if ( fabs(v8) <= v9 )
      *(float *)(*(_DWORD *)pm + 876) = v3 + *(float *)(*(_DWORD *)pm + 876);
    else
      *(float *)(*(_DWORD *)pm + 876) = v9 * (long double)(-2 * (v3 < 0.0) + 1) + *(float *)(*(_DWORD *)pm + 876);
    *(float *)(*(_DWORD *)pm + 876) = AngleNormalize180(*(float *)(*(_DWORD *)pm + 876));
  }
  if ( LODWORD(pml[12]) )
    v10 = PitchForYawOnNormal(*(float *)(*(_DWORD *)pm + 196), (int)&pml[17]);
  else
    v10 = 0.0;
  v20 = v10;
  v11 = AngleDelta(v20, *(float *)(*(_DWORD *)pm + 880));
  v12 = v11;
  v14 = v11 > 0.0;
  v15 = 0;
  v16 = 0.0 == v11;
  if ( (v13 & 0x45) != 64 )
  {
    v17 = v11;
    v18 = pml[9] * 70.0;
    if ( fabs(v17) <= v18 )
      *(float *)(*(_DWORD *)pm + 880) = v12 + *(float *)(*(_DWORD *)pm + 880);
    else
      *(float *)(*(_DWORD *)pm + 880) = v18 * (long double)(-2 * (v12 < 0.0) + 1) + *(float *)(*(_DWORD *)pm + 880);
    *(float *)(*(_DWORD *)pm + 880) = AngleNormalize180(*(float *)(*(_DWORD *)pm + 880));
  }
}
// 334F2: variable 'v4' is possibly undefined
// 335EF: variable 'v13' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (00033694) --------------------------------------------------------
int PM_UpdatePlayerWalkingFlag()
{
  _BYTE *v0; // edx
  int result; // eax
  int v2; // ecx
  int v3; // edx

  v0 = (_BYTE *)pm;
  result = *(_DWORD *)pm;
  *(_BYTE *)(*(_DWORD *)pm + 12) &= 0x7Fu;
  v2 = *(_DWORD *)v0;
  if ( *(int *)(*(_DWORD *)v0 + 4) <= 5 && (v0[8] & 0x10) != 0 )
  {
    v3 = *(_DWORD *)(v2 + 12);
    if ( (v3 & 1) == 0 && (v3 & 0x20) != 0 )
    {
      result = *(_DWORD *)(v2 + 180);
      if ( result != 5 && result != 7 && result != 9 && result != 8 && result != 6 )
      {
        LOBYTE(v3) = v3 | 0x80;
        *(_DWORD *)(v2 + 12) = v3;
      }
    }
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (000336E8) --------------------------------------------------------
__int16 sub_336E8()
{
  int v0; // eax
  long double v1; // fst7
  int v2; // edx
  int v3; // edx
  int v4; // ecx
  long double v5; // fst6
  long double v6; // fst3
  long double v7; // fst6
  long double v8; // fst4
  long double v9; // fst3
  long double v10; // fst2
  long double v11; // fst3
  __int16 v12; // fps
  int v13; // edx
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  int v18; // [esp-4h] [ebp-7Ch]
  long double v19; // [esp+8h] [ebp-70h]
  float v20[7]; // [esp+18h] [ebp-60h] BYREF
  char v21; // [esp+34h] [ebp-44h]
  float v22; // [esp+48h] [ebp-30h] BYREF
  float v23; // [esp+4Ch] [ebp-2Ch]
  float v24; // [esp+50h] [ebp-28h]
  float v25[3]; // [esp+54h] [ebp-24h] BYREF
  float v26; // [esp+60h] [ebp-18h] BYREF
  float v27; // [esp+64h] [ebp-14h]
  float v28; // [esp+68h] [ebp-10h]
  float v29[3]; // [esp+6Ch] [ebp-Ch] BYREF

  v0 = *(_DWORD *)pm;
  if ( !*(_DWORD *)(*(_DWORD *)pm + 16) )
  {
    v1 = 30.0;
    if ( LODWORD(pml[11]) )
      v1 = 8.0;
    if ( (*(_BYTE *)(v0 + 12) & 0x10) != 0 && *(_DWORD *)(v0 + 84) == 1023 )
    {
      v26 = -*(float *)(v0 + 88);
      v27 = -*(float *)(*(_DWORD *)pm + 92);
      v28 = -*(float *)(*(_DWORD *)pm + 96);
    }
    else
    {
      v26 = pml[0];
      v27 = pml[1];
      v28 = 0.0;
      v19 = v1;
      VectorNormalize(&v26);
      v1 = v19;
    }
    v2 = pm;
    *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xEFu;
    v0 = *(_DWORD *)v2;
    if ( *(int *)(*(_DWORD *)v2 + 4) <= 5 )
    {
      if ( (*(_BYTE *)(v0 + 12) & 1) != 0
        || (v3 = *(_DWORD *)(v0 + 216), v3 == *(_DWORD *)(v0 + 828))
        || (v4 = *(_DWORD *)(v0 + 212)) != 0 && v3 == *(_DWORD *)(v0 + 832) && !*(_DWORD *)(v0 + 220) )
      {
        v0 = 1;
      }
      else if ( (*(_BYTE *)(v0 + 12) & 2) != 0 || v4 && v3 == *(_DWORD *)(v0 + 832) )
      {
        v0 = 2;
      }
      else
      {
        v0 = 0;
      }
      if ( v0 != 1 )
      {
        v0 = *(_DWORD *)(pm + 4) - *(_DWORD *)(*(_DWORD *)pm + 100);
        if ( v0 > 299 )
        {
          v5 = *(float *)(pm + 192);
          v25[0] = *(float *)(pm + 192);
          v6 = v5;
          v7 = *(float *)(pm + 196) + 6.0;
          v25[2] = 8.0;
          v25[0] = v6 + 6.0;
          v25[1] = v7;
          v8 = *(float *)(pm + 204);
          v22 = *(float *)(pm + 204);
          v9 = *(float *)(pm + 208);
          v23 = *(float *)(pm + 208);
          v10 = v9;
          v11 = *(float *)(pm + 212);
          v24 = *(float *)(pm + 212);
          v22 = v8 - 6.0;
          v23 = v10 - 6.0;
          if ( v11 < 8.0 )
            v24 = 8.0;
          v29[0] = v26 * v1 + *(float *)(*(_DWORD *)pm + 20);
          v29[1] = v27 * v1 + *(float *)(*(_DWORD *)pm + 24);
          v29[2] = v1 * v28 + *(float *)(*(_DWORD *)pm + 28);
          (*(void (__stdcall **)(float *, int, float *, float *, float *, _DWORD, _DWORD, int))(pm + 232))(
            v20,
            *(_DWORD *)pm + 20,
            v25,
            &v22,
            v29,
            *(_DWORD *)(*(_DWORD *)pm + 172),
            *(_DWORD *)(pm + 52),
            v18);
          v13 = pm;
          v14 = v20[0] > 1.0;
          v15 = 0;
          v16 = 1.0 == v20[0];
          LOBYTE(v0) = v12;
          BYTE1(v0) = HIBYTE(v12) & 0x45;
          if ( v20[0] < 1.0 && (v21 & 8) != 0 && (!LODWORD(pml[11]) || *(char *)(pm + 24) > 0) )
          {
            *(float *)(*(_DWORD *)pm + 88) = v20[4];
            *(float *)(*(_DWORD *)v13 + 92) = v20[5];
            *(float *)(*(_DWORD *)v13 + 96) = v20[6];
            v0 = *(_DWORD *)v13;
            *(_BYTE *)(*(_DWORD *)v13 + 12) |= 0x10u;
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(v0 + 84) = 1023;
      pml[12] = 0.0;
      pml[11] = 0.0;
    }
  }
  return v0;
}
// 338F4: variable 'v18' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (00033944) --------------------------------------------------------
int PM_LadderMove()
{
  int result; // eax
  char v1; // fps^1
  long double v2; // fst7
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  int v9; // ecx
  char v10; // fps^1
  long double v11; // fst4
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  char v15; // fps^1
  long double v16; // fst7
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  int v23; // ecx
  _DWORD *v24; // ebx
  int v25; // edx
  int v26; // eax
  long double v27; // fst6
  int *v28; // edx
  int v29; // ecx
  char v30; // fps^1
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  int v34; // edx
  char v35; // fps^1
  int v36; // edx
  bool v37; // c0
  char v38; // c2
  bool v39; // c3
  int v40; // edx
  char v41; // fps^1
  long double v42; // fst4
  bool v43; // c0
  char v44; // c2
  bool v45; // c3
  long double v46; // fst5
  long double v47; // rtt
  char v48; // fps^1
  long double v49; // fst3
  bool v50; // c0
  char v51; // c2
  bool v52; // c3
  char v53; // fps^1
  bool v54; // c0
  char v55; // c2
  bool v56; // c3
  long double v57; // fst6
  int v58; // edx
  long double v59; // fst5
  char v60; // fps^1
  long double v61; // fst7
  bool v62; // c0
  char v63; // c2
  bool v64; // c3
  long double v65; // fst7
  int v66; // ecx
  int v67; // eax
  float v68; // [esp-10h] [ebp-68h]
  float v69; // [esp+10h] [ebp-48h]
  float v70; // [esp+10h] [ebp-48h]
  float v71; // [esp+14h] [ebp-44h] BYREF
  float v72; // [esp+18h] [ebp-40h]
  __int16 v73; // [esp+1Eh] [ebp-3Ah]
  int v74; // [esp+2Ch] [ebp-2Ch]
  __int16 v75; // [esp+32h] [ebp-26h]
  float v76[3]; // [esp+34h] [ebp-24h] BYREF
  float v77; // [esp+40h] [ebp-18h] BYREF
  float v78; // [esp+44h] [ebp-14h]
  float v79; // [esp+48h] [ebp-10h]
  float v80[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( sub_2EB98() )
  {
    sub_2F03C();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*(_DWORD *)pm + 100) = result;
  }
  else
  {
    v69 = (pml[2] + 0.25) * 2.5;
    v2 = 1.0;
    v3 = v69 > 1.0;
    v4 = 0;
    v5 = 1.0 == v69;
    if ( (v1 & 0x45) == 1 || (v2 = -1.0, v69 < -1.0) )
      v69 = v2;
    pml[2] = 0.0;
    VectorNormalize(pml);
    pml[5] = 0.0;
    VectorNormalize2(&pml[3], v76);
    ProjectPointOnPlane(&pml[3], v76, (float *)(*(_DWORD *)pm + 88));
    v6 = sub_2E5BC((char *)(pm + 4));
    v79 = 0.0;
    v78 = 0.0;
    v77 = 0.0;
    if ( *(_BYTE *)(pm + 24) )
    {
      v70 = v69 * 0.5 * v6;
      v75 = *(char *)(pm + 24);
      v79 = (long double)v75 * v70;
    }
    if ( *(_BYTE *)(pm + 25) )
    {
      v7 = v6 * 0.2;
      v75 = *(char *)(pm + 25);
      v77 = (long double)v75 * v7 * pml[3] + v77;
      v75 = *(char *)(pm + 25);
      v78 = v7 * (long double)v75 * pml[4] + v78;
      v75 = *(char *)(pm + 25);
      v79 = v7 * (long double)v75 * pml[5] + v79;
    }
    v8 = VectorNormalize2(&v77, v80);
    v9 = *(_DWORD *)pm;
    v11 = v8
        - (*(float *)(*(_DWORD *)pm + 40) * v80[2]
         + *(float *)(*(_DWORD *)pm + 32) * v80[0]
         + *(float *)(*(_DWORD *)pm + 36) * v80[1]);
    v12 = v11 < 0.0;
    v13 = 0;
    v14 = v11 == 0.0;
    if ( (unsigned __int8)((v10 & 0x45) - 1) >= 0x40u )
    {
      if ( v8 < 100.0 )
        v8 = 100.0;
      v16 = v8 * (9.0 * pml[9]);
      v17 = v11 < v16;
      v18 = 0;
      v19 = v11 == v16;
      if ( (v15 & 0x45) == 1 )
        v16 = v11;
      if ( *(_DWORD *)(v9 + 84) != 1023 )
        v16 = v16 * (1.0 / *(float *)(v9 + 892));
      v20 = v11 < v16;
      v21 = 0;
      v22 = v11 == v16;
      if ( (v15 & 0x45) == 1 )
        v16 = v11;
      v23 = 0;
      v24 = (_DWORD *)pm;
      do
      {
        v25 = 4 * v23;
        v26 = *v24 + 32;
        v27 = v16 * v80[v23] + *(float *)(4 * v23 + v26);
        ++v23;
        *(float *)(v25 + v26) = v27;
      }
      while ( v23 <= 2 );
    }
    v28 = (int *)pm;
    if ( !*(_BYTE *)(pm + 24) )
    {
      v29 = *(_DWORD *)pm;
      v31 = *(float *)(*(_DWORD *)pm + 40) > 0.0;
      v32 = 0;
      v33 = 0.0 == *(float *)(*(_DWORD *)pm + 40);
      if ( (v30 & 0x45) == 1 )
      {
        *(float *)(v29 + 40) = *(float *)(v29 + 40) - (long double)*(int *)(v29 + 60) * pml[9];
        v34 = *v28;
        if ( *(float *)(v34 + 40) < 0.0 )
          *(float *)(v34 + 40) = 0.0;
      }
      else
      {
        *(float *)(v29 + 40) = (long double)*(int *)(v29 + 60) * pml[9] + *(float *)(v29 + 40);
        v36 = *v28;
        v37 = *(float *)(v36 + 40) > 0.0;
        v38 = 0;
        v39 = 0.0 == *(float *)(v36 + 40);
        if ( (v35 & 0x45) == 1 )
          *(_DWORD *)(v36 + 40) = 0;
      }
    }
    if ( !*(_BYTE *)(pm + 25) )
    {
      v71 = pml[3];
      v72 = pml[4];
      VectorNormalize2D(&v71);
      v40 = pm;
      v42 = v72 * *(float *)(*(_DWORD *)pm + 36) + v71 * *(float *)(*(_DWORD *)pm + 32);
      v43 = v42 < 0.0;
      v44 = 0;
      v45 = v42 == 0.0;
      if ( (v41 & 0x45) != 64 )
      {
        *(float *)(*(_DWORD *)pm + 32) = v71 * -v42 + *(float *)(*(_DWORD *)pm + 32);
        *(float *)(*(_DWORD *)v40 + 36) = -v42 * v72 + *(float *)(*(_DWORD *)v40 + 36);
        v46 = v42 * pml[9] * 16.0;
        v47 = fabs(v42);
        v49 = fabs(v46);
        v50 = v49 < v47;
        v51 = 0;
        v52 = v49 == v47;
        if ( (v48 & 0x45) == 1 )
        {
          if ( v49 >= 1.0 )
          {
            v57 = v46;
          }
          else
          {
            v54 = v46 < 0.0;
            v55 = 0;
            v56 = v46 == 0.0;
            v74 = -2 * ((v53 & 0x45) == 1) + 1;
            v57 = (long double)v74;
          }
          *(float *)(*(_DWORD *)v40 + 32) = v71 * (v42 - v57) + *(float *)(*(_DWORD *)v40 + 32);
          *(float *)(*(_DWORD *)v40 + 36) = (v42 - v57) * v72 + *(float *)(*(_DWORD *)v40 + 36);
        }
      }
    }
    if ( !LODWORD(pml[11]) )
    {
      v58 = pm;
      v59 = -(*(float *)(*(_DWORD *)pm + 92) * *(float *)(*(_DWORD *)pm + 36)
            + *(float *)(*(_DWORD *)pm + 88) * *(float *)(*(_DWORD *)pm + 32));
      *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 88) * v59 + *(float *)(*(_DWORD *)pm + 32);
      *(float *)(*(_DWORD *)v58 + 36) = v59 * *(float *)(*(_DWORD *)v58 + 92) + *(float *)(*(_DWORD *)v58 + 36);
      v61 = -250.0;
      v62 = v79 > 0.0;
      v63 = 0;
      v64 = 0.0 == v79;
      if ( (v60 & 0x45) == 1 )
        v61 = -500.0;
      *(float *)(*(_DWORD *)v58 + 32) = *(float *)(*(_DWORD *)v58 + 88) * v61 + *(float *)(*(_DWORD *)v58 + 32);
      *(float *)(*(_DWORD *)v58 + 36) = v61 * *(float *)(*(_DWORD *)v58 + 92) + *(float *)(*(_DWORD *)v58 + 36);
    }
    PM_StepSlideMove(0);
    v68 = vectoyaw((float *)(*(_DWORD *)pm + 88)) + 180.0;
    v65 = AngleDelta(v68, *(float *)(*(_DWORD *)pm + 196));
    v73 = v75 | 0xC00;
    v74 = (int)v65;
    v66 = (int)v65;
    v67 = (int)v65;
    if ( (int)v65 < 0 )
      v67 = -v67;
    if ( v67 > 75 )
    {
      if ( v66 <= 0 )
        LOBYTE(v66) = -75;
      else
        LOBYTE(v66) = 75;
    }
    result = (char)v66;
    *(_DWORD *)(*(_DWORD *)pm + 124) = (char)v66;
  }
  return result;
}
// 3398C: variable 'v1' is possibly undefined
// 33B04: variable 'v10' is possibly undefined
// 33B35: variable 'v15' is possibly undefined
// 33BAA: variable 'v30' is possibly undefined
// 33BE8: variable 'v35' is possibly undefined
// 33C51: variable 'v41' is possibly undefined
// 33C97: variable 'v48' is possibly undefined
// 33CB0: variable 'v53' is possibly undefined
// 33D3D: variable 'v60' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (00033DFC) --------------------------------------------------------
char __cdecl PmoveSingle(int a1)
{
  _BYTE *v1; // edx
  int v2; // eax
  long double v3; // fst7
  char v4; // fps^1
  long double v5; // fst6
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  long double v9; // fst7
  char v10; // fps^1
  long double v11; // fst6
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  int v15; // eax
  int v16; // ecx
  unsigned int v17; // edx
  int *v18; // edx
  int v19; // edx
  int v20; // eax
  char v21; // dl
  int v22; // eax
  int v23; // edx
  char v24; // dl
  int v25; // eax
  int v26; // edx
  long double v27; // fst7
  long double v28; // fst6
  long double v29; // fst4
  float v31; // [esp+18h] [ebp-10h]
  float v32; // [esp+1Ch] [ebp-Ch]

  BG_AnimUpdatePlayerStateConditions((_BYTE *)a1);
  pm = a1;
  ++c_pmove;
  *(_BYTE *)(a1 + 216) = 0;
  *(_BYTE *)(pm + 217) = 0;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 13) & 0x40) != 0 )
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  v1 = (_BYTE *)pm;
  *(_BYTE *)(*(_DWORD *)pm + 13) &= 0x7Fu;
  if ( *(int *)(*(_DWORD *)v1 + 4) > 5 )
    v1[55] &= 0xFDu;
  v2 = *(_DWORD *)(*(_DWORD *)pm + 12);
  if ( (v2 & 1) != 0 )
  {
    if ( *(_BYTE *)(pm + 24) != *(_BYTE *)(pm + 48) )
    {
      v3 = fabs((long double)*(char *)(pm + 24));
      v5 = fabs((long double)*(char *)(pm + 48));
      v6 = v5 < v3;
      v7 = 0;
      v8 = v5 == v3;
      if ( (v4 & 0x45) == 1 )
        goto LABEL_77;
    }
    if ( *(_BYTE *)(pm + 25) == *(_BYTE *)(pm + 49)
      || (v9 = fabs((long double)*(char *)(pm + 25)),
          v11 = fabs((long double)*(char *)(pm + 49)),
          v12 = v11 < v9,
          v13 = 0,
          v14 = v11 == v9,
          (v10 & 0x45) != 1) )
    {
      v15 = *(_DWORD *)pm;
      v16 = *(_DWORD *)(*(_DWORD *)pm + 12);
      if ( (v16 & 0x20) == 0 )
      {
        v17 = *(_DWORD *)(v15 + 180);
        if ( v17 <= 2 || v17 == 5 )
        {
          BYTE1(v16) &= 0xFBu;
          *(_DWORD *)(v15 + 12) = v16;
        }
      }
    }
    else
    {
LABEL_77:
      if ( PM_InteruptWeaponWithProneMove() )
      {
        *(_BYTE *)(*(_DWORD *)pm + 13) &= 0xFBu;
        PM_ClearAimDownSightFlag();
      }
    }
  }
  else
  {
    BYTE1(v2) &= 0xFBu;
    *(_DWORD *)(*(_DWORD *)pm + 12) = v2;
  }
  LODWORD(pml[33]) = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm + 176));
  if ( (*(_DWORD *)(*(_DWORD *)pm + 12) & 0x21) == 33 )
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
  }
  if ( (*(_BYTE *)(pm + 8) & 2) != 0 )
    *(_BYTE *)(*(_DWORD *)pm + 130) |= 4u;
  else
    *(_BYTE *)(*(_DWORD *)pm + 130) &= 0xFBu;
  v18 = (int *)pm;
  *(_BYTE *)(*(_DWORD *)pm + 129) &= 0xFBu;
  v19 = *v18;
  if ( *(_DWORD *)(v19 + 4) == 5 )
    goto LABEL_31;
  if ( (*(_BYTE *)(v19 + 13) & 8) == 0 )
  {
    v20 = *(_DWORD *)(v19 + 180);
    if ( !v20 || v20 == 3 )
    {
      if ( PM_WeaponAmmoAvailable(*(_DWORD *)(v19 + 176)) )
      {
        v21 = *(_BYTE *)(pm + 8);
        if ( (v21 & 1) != 0 && (v21 & 2) == 0 )
          *(_BYTE *)(*(_DWORD *)pm + 129) |= 4u;
      }
    }
  }
  if ( *(int *)(*(_DWORD *)pm + 4) <= 5 )
  {
LABEL_31:
    if ( (*(_BYTE *)(pm + 8) & 1) == 0 )
      *(_BYTE *)(*(_DWORD *)pm + 13) &= 0xF7u;
  }
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
  {
    *(_BYTE *)(a1 + 8) = 2;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  _bzero(pml, 0x88u);
  v22 = *(_DWORD *)(a1 + 4) - **(_DWORD **)pm;
  LODWORD(pml[10]) = v22;
  if ( v22 > 0 )
  {
    if ( v22 > 200 )
      LODWORD(pml[10]) = 200;
  }
  else
  {
    LODWORD(pml[10]) = 1;
  }
  v23 = pm;
  **(_DWORD **)pm = *(_DWORD *)(a1 + 4);
  pml[26] = *(float *)(*(_DWORD *)v23 + 20);
  pml[27] = *(float *)(*(_DWORD *)v23 + 24);
  pml[28] = *(float *)(*(_DWORD *)v23 + 28);
  pml[29] = *(float *)(*(_DWORD *)v23 + 32);
  pml[30] = *(float *)(*(_DWORD *)v23 + 36);
  pml[31] = *(float *)(*(_DWORD *)v23 + 40);
  pml[9] = (long double)SLODWORD(pml[10]) * 0.001;
  LODWORD(pml[33]) = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)v23 + 176));
  PM_AdjustAimSpreadScale();
  PM_UpdateViewAngles(*(_DWORD *)pm, pm + 4, *(void (__stdcall **)(float *, float *, float *, float *))(pm + 240));
  AngleVectors((float *)(*(_DWORD *)pm + 192), pml, &pml[3], &pml[6]);
  if ( *(char *)(pm + 26) <= 9 )
    *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xF7u;
  v24 = *(_BYTE *)(pm + 24);
  if ( v24 >= 0 )
  {
    if ( v24 > 0 || *(_BYTE *)(pm + 25) )
      *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xBFu;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)pm + 12) |= 0x40u;
  }
  if ( *(int *)(*(_DWORD *)pm + 4) > 5 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
    *(_BYTE *)(pm + 26) = 0;
  }
  if ( (*(_DWORD *)(*(_DWORD *)pm + 12) & 0x401) == 1025 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
  }
  LOBYTE(v25) = pm;
  switch ( *(_DWORD *)(*(_DWORD *)pm + 4) )
  {
    case 1:
    case 7:
      *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
      pml[12] = 0.0;
      pml[11] = 0.0;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_316F4();
      sub_32A44();
      PM_Weapon();
      v25 = *(_DWORD *)pm;
      if ( (*(_BYTE *)(*(_DWORD *)pm + 129) & 0xC0) != 0 )
        LOBYTE(v25) = sub_322C8();
      break;
    case 2:
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_2F7A4();
      LOBYTE(v25) = sub_32A44();
      break;
    case 3:
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_2FA2C();
      LOBYTE(v25) = sub_32A44();
      break;
    case 4:
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_316F4();
      sub_2EE6C();
      LOBYTE(v25) = sub_32A44();
      break;
    case 5:
      return v25;
    default:
      if ( (*(_BYTE *)(*(_DWORD *)pm + 129) & 0xC0) != 0 )
      {
        *(_DWORD *)(*(_DWORD *)pm + 84) = 1023;
        pml[12] = 0.0;
        pml[11] = 0.0;
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        sub_316F4();
        sub_32A44();
        LOBYTE(v25) = sub_322C8();
      }
      else
      {
        sub_30778();
        LODWORD(pml[32]) = *(unsigned __int8 *)(a1 + 217);
        sub_316F4();
        sub_30474();
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        PM_UpdatePronePitch();
        if ( *(_DWORD *)(*(_DWORD *)pm + 4) == 6 )
          sub_2F700();
        sub_336E8();
        sub_32A44();
        if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 0x10) != 0 )
        {
          PM_LadderMove();
        }
        else if ( LODWORD(pml[11]) )
        {
          sub_2F258();
        }
        else
        {
          sub_2F03C();
        }
        sub_30474();
        sub_30778();
        PM_Weapon();
        sub_322C8();
        sub_328CC();
        if ( LODWORD(pml[32]) )
          goto LABEL_78;
        if ( *(_BYTE *)(pm + 217) )
          BG_AddPredictableEventToPlayerstate(144, 0, *(_DWORD *)pm);
        if ( LODWORD(pml[32]) )
        {
LABEL_78:
          if ( !*(_BYTE *)(pm + 217) )
            BG_AddPredictableEventToPlayerstate(145, 0, *(_DWORD *)pm);
        }
        v26 = pm;
        v27 = *(float *)(*(_DWORD *)pm + 20) - pml[26];
        v28 = *(float *)(*(_DWORD *)pm + 24) - pml[27];
        v29 = *(float *)(*(_DWORD *)pm + 28) - pml[28];
        if ( (*(float *)(*(_DWORD *)pm + 36) * *(float *)(*(_DWORD *)pm + 36)
            + *(float *)(*(_DWORD *)pm + 32) * *(float *)(*(_DWORD *)pm + 32)
            + *(float *)(*(_DWORD *)pm + 40) * *(float *)(*(_DWORD *)pm + 40))
           * 0.25 > (v29 * v29 + v28 * v28 + v27 * v27) / (pml[9] * pml[9]) )
        {
          *(float *)(*(_DWORD *)pm + 32) = 1.0 / pml[9] * v27;
          v31 = v28;
          *(float *)(*(_DWORD *)v26 + 36) = 1.0 / pml[9] * v31;
          v32 = v29;
          *(float *)(*(_DWORD *)v26 + 40) = 1.0 / pml[9] * v32;
        }
        LOBYTE(v25) = trap_SnapVector(*(_DWORD *)pm + 32);
      }
      break;
  }
  return v25;
}
// 34154: conditional instruction was optimized away because of 'dl.1==0'
// 33EA9: variable 'v4' is possibly undefined
// 33EDD: variable 'v10' is possibly undefined
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (00034460) --------------------------------------------------------
int PM_SetProneMovementOverride()
{
  int result; // eax
  int v1; // edx

  result = *(_DWORD *)pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 12);
  if ( (v1 & 1) != 0 )
  {
    BYTE1(v1) |= 4u;
    *(_DWORD *)(result + 12) = v1;
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (0003447C) --------------------------------------------------------
_DWORD *__cdecl Pmove(int a1)
{
  int v1; // esi
  _DWORD *result; // eax
  int v3; // edx

  v1 = *(_DWORD *)(a1 + 4);
  result = **(_DWORD ***)a1;
  if ( v1 >= (int)result )
  {
    if ( v1 > (int)(result + 250) )
      **(_DWORD **)a1 = v1 - 1000;
    result = *(_DWORD **)a1;
    pm = a1;
    *(_DWORD *)(a1 + 60) = 0;
    if ( *result != v1 )
    {
      do
      {
        v3 = v1 - **(_DWORD **)a1;
        if ( *(_DWORD *)(a1 + 224) )
        {
          if ( v3 > *(_DWORD *)(a1 + 228) )
            v3 = *(_DWORD *)(a1 + 228);
        }
        else if ( v3 > 66 )
        {
          v3 = 66;
        }
        *(_DWORD *)(a1 + 4) = **(_DWORD **)a1 + v3;
        PmoveSingle(a1);
        if ( (*(_BYTE *)(*(_DWORD *)a1 + 12) & 8) != 0 )
          *(_BYTE *)(a1 + 26) = 20;
        result = *(_DWORD **)a1;
      }
      while ( **(_DWORD **)a1 != v1 );
    }
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (0003450C) --------------------------------------------------------
long double __cdecl BG_GetSpeed(int a1, int a2)
{
  long double result; // fst7
  float v3; // [esp+14h] [ebp-4h]

  if ( (*(_BYTE *)(a1 + 12) & 0x10) != 0 )
  {
    if ( a2 - *(_DWORD *)(a1 + 100) > 499 )
      result = *(float *)(a1 + 40);
    else
      result = 0.0;
  }
  else
  {
    v3 = sqrt(*(float *)(a1 + 32) * *(float *)(a1 + 32) + *(float *)(a1 + 36) * *(float *)(a1 + 36));
    result = v3;
  }
  return result;
}

//----- (00034554) --------------------------------------------------------
int __cdecl PM_GetEffectiveStance(int a1)
{
  int v1; // edx
  int v2; // ecx

  if ( (*(_BYTE *)(a1 + 12) & 1) != 0 )
    return 1;
  v1 = *(_DWORD *)(a1 + 216);
  if ( v1 == *(_DWORD *)(a1 + 828) )
    return 1;
  v2 = *(_DWORD *)(a1 + 212);
  if ( v2 )
  {
    if ( v1 == *(_DWORD *)(a1 + 832) && !*(_DWORD *)(a1 + 220) )
      return 1;
  }
  if ( (*(_BYTE *)(a1 + 12) & 2) != 0 || v2 && v1 == *(_DWORD *)(a1 + 832) )
    return 2;
  return 0;
}

//----- (000345B8) --------------------------------------------------------
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3)
{
  if ( a2 == *(_DWORD *)(a1 + 828) )
  {
    if ( (*(_BYTE *)(a1 + 12) & 4) == 0 )
      return bg_duck2prone_time[3];
    return 200;
  }
  if ( a2 != *(_DWORD *)(a1 + 832) )
    return 200;
  if ( !a3 )
    return bg_prone2duck_time[3];
  if ( (*(_BYTE *)(a1 + 12) & 4) != 0 )
    return 100;
  return 150;
}

//----- (0003460C) --------------------------------------------------------
int __cdecl PM_ClipVelocity(int a1, int a2, int a3, float a4)
{
  char v4; // fps^1
  long double v5; // fst5
  long double v6; // fst7
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  int result; // eax

  v5 = *(float *)a1 * *(float *)a2 + *(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)(a1 + 8) * *(float *)(a2 + 8);
  v6 = a4;
  v7 = v5 < 0.0;
  v8 = 0;
  v9 = v5 == 0.0;
  if ( (v4 & 0x45) == 1 )
    v10 = v6 * v5;
  else
    v10 = v5 / v6;
  result = 0;
  do
  {
    *(float *)(a3 + 4 * result) = *(float *)(a1 + 4 * result) - *(float *)(a2 + 4 * result) * v10;
    ++result;
  }
  while ( result <= 2 );
  return result;
}
// 3463C: variable 'v4' is possibly undefined

//----- (0003466C) --------------------------------------------------------
void __cdecl PM_AddTouchEnt(int a1)
{
  int v1; // ecx
  int v2; // edx
  int v3; // eax

  if ( a1 != 1022 )
  {
    v1 = pm;
    v2 = *(_DWORD *)(pm + 60);
    if ( v2 != 32 )
    {
      v3 = 0;
      if ( v2 <= 0 )
      {
LABEL_6:
        *(_DWORD *)(4 * *(_DWORD *)(pm + 60) + pm + 64) = a1;
        ++*(_DWORD *)(v1 + 60);
      }
      else
      {
        while ( *(_DWORD *)(pm + 64 + 4 * v3) != a1 )
        {
          if ( ++v3 >= v2 )
            goto LABEL_6;
        }
      }
    }
  }
}
// 16EE30: using guessed type int pm;

//----- (000346B4) --------------------------------------------------------
int __cdecl PM_AddEvent(int a1)
{
  return BG_AddPredictableEventToPlayerstate(a1, 0, *(_DWORD *)pm);
}
// 16EE30: using guessed type int pm;

//----- (000346E0) --------------------------------------------------------
int __cdecl PM_VerifyPronePosition(float *a1, float *a2)
{
  int v2; // ecx
  int v3; // edx

  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) == 0 )
    return 1;
  v2 = BG_CheckProne(
         *(_DWORD *)(*(_DWORD *)pm + 172),
         *(_DWORD *)pm + 20,
         *(float *)(*(_DWORD *)pm + 816),
         30.0,
         *(float *)(*(_DWORD *)pm + 872),
         *(_DWORD *)pm + 964,
         *(_DWORD *)pm + 968,
         *(_DWORD *)pm + 972,
         1,
         1,
         0,
         *(_DWORD *)(pm + 240),
         *(_DWORD *)(pm + 236),
         0);
  if ( !v2 )
  {
    v3 = pm;
    *(float *)(*(_DWORD *)pm + 20) = *a1;
    *(float *)(*(_DWORD *)v3 + 24) = a1[1];
    *(float *)(*(_DWORD *)v3 + 28) = a1[2];
    *(float *)(*(_DWORD *)v3 + 32) = *a2;
    *(float *)(*(_DWORD *)v3 + 36) = a2[1];
    *(float *)(*(_DWORD *)v3 + 40) = a2[2];
  }
  return v2;
}
// 16EE30: using guessed type int pm;

//----- (000347C0) --------------------------------------------------------
_BOOL4 __cdecl PM_SlideMove(int a1)
{
  _DWORD *v1; // edx
  long double v2; // fst7
  long double v3; // fst7
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  int v9; // edx
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  _DWORD *v14; // eax
  int v15; // ecx
  int v16; // edx
  long double v17; // fst7
  long double v18; // fst7
  int *v19; // edi
  long double v20; // fst7
  char v21; // fps^1
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  long double v25; // fst3
  int v26; // edx
  long double v27; // fst2
  long double v28; // fst1
  long double v29; // fst5
  long double v30; // fst6
  long double v31; // rtt
  long double v32; // fst2
  long double v33; // rt0
  long double v34; // fst2
  long double v35; // rt1
  long double v36; // fst2
  long double v37; // fst5
  long double v38; // fst3
  long double v39; // fst6
  int v40; // edx
  int v41; // eax
  int v42; // edx
  int v43; // [esp+20h] [ebp-118h]
  int v44; // [esp+24h] [ebp-114h]
  int *v45; // [esp+28h] [ebp-110h]
  unsigned int v46; // [esp+2Ch] [ebp-10Ch]
  int v47; // [esp+30h] [ebp-108h]
  float v48; // [esp+3Ch] [ebp-FCh]
  int v49; // [esp+40h] [ebp-F8h]
  int v50; // [esp+44h] [ebp-F4h]
  int v51; // [esp+44h] [ebp-F4h]
  int v52; // [esp+48h] [ebp-F0h]
  int v53; // [esp+48h] [ebp-F0h]
  int v54; // [esp+4Ch] [ebp-ECh]
  int v55; // [esp+60h] [ebp-D8h] BYREF
  float v56; // [esp+64h] [ebp-D4h]
  float v57; // [esp+68h] [ebp-D0h]
  int v58; // [esp+6Ch] [ebp-CCh] BYREF
  float v59; // [esp+70h] [ebp-C8h]
  float v60; // [esp+74h] [ebp-C4h]
  float v61[3]; // [esp+78h] [ebp-C0h] BYREF
  float v62[4]; // [esp+84h] [ebp-B4h] BYREF
  float v63; // [esp+94h] [ebp-A4h]
  float v64; // [esp+98h] [ebp-A0h]
  float v65; // [esp+9Ch] [ebp-9Ch]
  unsigned __int16 v66; // [esp+ACh] [ebp-8Ch]
  char v67; // [esp+B2h] [ebp-86h]
  int v68; // [esp+B4h] [ebp-84h] BYREF
  float v69; // [esp+B8h] [ebp-80h]
  float v70; // [esp+BCh] [ebp-7Ch]
  float v71; // [esp+C0h] [ebp-78h]
  float v72; // [esp+C4h] [ebp-74h]
  float v73; // [esp+C8h] [ebp-70h]
  int v74; // [esp+CCh] [ebp-6Ch] BYREF
  float v75; // [esp+D0h] [ebp-68h] BYREF
  float v76[22]; // [esp+D4h] [ebp-64h] BYREF
  float v77; // [esp+12Ch] [ebp-Ch] BYREF
  float v78; // [esp+130h] [ebp-8h]
  float v79; // [esp+134h] [ebp-4h]

  v1 = (_DWORD *)pm;
  v71 = *(float *)(*(_DWORD *)pm + 32);
  v72 = *(float *)(*(_DWORD *)pm + 36);
  v73 = *(float *)(*(_DWORD *)pm + 40);
  if ( a1 )
  {
    v58 = *(int *)(*(_DWORD *)pm + 32);
    v59 = *(float *)(*(_DWORD *)pm + 36);
    v2 = *(float *)(*(_DWORD *)pm + 40);
    v60 = *(float *)(*(_DWORD *)pm + 40);
    v3 = v2 - (long double)*(int *)(*(_DWORD *)pm + 60) * pml[9];
    v60 = v3;
    *(float *)(*(_DWORD *)pm + 40) = (v3 + *(float *)(*(_DWORD *)pm + 40)) * 0.5;
    v73 = v60;
    if ( LODWORD(pml[12]) )
      PM_ClipVelocity(*v1 + 32, (int)&pml[17], *v1 + 32, 1.001);
  }
  v48 = pml[9];
  if ( LODWORD(pml[12]) )
  {
    v74 = SLODWORD(pml[17]);
    v75 = pml[18];
    v76[0] = pml[19];
    v52 = 1;
  }
  else
  {
    v52 = 0;
  }
  VectorNormalize2((float *)(*(_DWORD *)pm + 32), (float *)&v74 + 3 * v52);
  v53 = v52 + 1;
  v54 = 0;
  v44 = 3 * v53;
  do
  {
    v61[0] = v48 * *(float *)(*(_DWORD *)pm + 32) + *(float *)(*(_DWORD *)pm + 20);
    v61[1] = v48 * *(float *)(*(_DWORD *)pm + 36) + *(float *)(*(_DWORD *)pm + 24);
    v61[2] = v48 * *(float *)(*(_DWORD *)pm + 40) + *(float *)(*(_DWORD *)pm + 28);
    (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(pm + 232))(
      v62,
      *(_DWORD *)pm + 20,
      pm + 192,
      pm + 204,
      v61,
      *(_DWORD *)(*(_DWORD *)pm + 172),
      *(_DWORD *)(pm + 52));
    if ( v67 )
    {
      *(_DWORD *)(*(_DWORD *)pm + 40) = 0;
      return 1;
    }
    v6 = v62[0] > 0.0;
    v7 = 0;
    v8 = 0.0 == v62[0];
    if ( (v5 & 0x45) == 1 )
    {
      v9 = pm;
      *(float *)(*(_DWORD *)pm + 20) = v62[1];
      *(float *)(*(_DWORD *)v9 + 24) = v62[2];
      *(float *)(*(_DWORD *)v9 + 28) = v62[3];
    }
    v11 = v62[0] < 1.0;
    v12 = 0;
    v13 = v62[0] == 1.0;
    if ( (v10 & 0x45) == 64 )
      break;
    PM_AddTouchEnt(v66);
    v48 = v48 - v48 * v62[0];
    if ( v53 > 7 )
    {
      if ( *(int *)(pm + 56) > 1 )
        Com_Printf("%i:MAX_CLIP_PLANES\n", c_pmove);
LABEL_16:
      v14 = *(_DWORD **)pm;
      v14[10] = 0;
      v14[9] = 0;
      v14[8] = 0;
      return 1;
    }
    v50 = 0;
    if ( v53 <= 0 )
      goto LABEL_52;
    v15 = 0;
    while ( v64 * *(float *)((char *)&v75 + v15 * 4) + v63 * *(float *)((char *)&v74 + v15 * 4) + v65 * v76[v15] <= 0.99900001 )
    {
      v15 += 3;
      if ( ++v50 >= v53 )
        goto LABEL_24;
    }
    if ( *(int *)(pm + 56) > 1 )
      Com_Printf("%i:recollided with plane normal (%.2f, %.2f, %.2f)\n", c_pmove, v63, v64, v65);
    v16 = pm;
    *(float *)(*(_DWORD *)pm + 32) = v63 + *(float *)(*(_DWORD *)pm + 32);
    *(float *)(*(_DWORD *)v16 + 36) = v64 + *(float *)(*(_DWORD *)v16 + 36);
    *(float *)(*(_DWORD *)v16 + 40) = v65 + *(float *)(*(_DWORD *)v16 + 40);
LABEL_24:
    if ( v50 >= v53 )
    {
LABEL_52:
      *(float *)((char *)&v74 + v44 * 4) = v63;
      *(float *)((char *)&v75 + v44 * 4) = v64;
      v76[v44] = v65;
      v44 += 3;
      ++v53;
      v51 = 0;
      if ( v53 > 0 )
      {
        v46 = 0;
        v45 = &v74;
        while ( 1 )
        {
          v17 = *(float *)(*(_DWORD *)pm + 32) * *(float *)((char *)&v74 + v46)
              + *(float *)(*(_DWORD *)pm + 36) * *(float *)((char *)&v75 + v46)
              + *(float *)(*(_DWORD *)pm + 40) * v76[v46 / 4];
          if ( v17 < 0.1 )
            break;
          v46 += 12;
          v45 += 3;
          if ( ++v51 >= v53 )
            goto LABEL_44;
        }
        v18 = -v17;
        if ( v18 > pml[25] )
          pml[25] = v18;
        PM_ClipVelocity(*(_DWORD *)pm + 32, (int)v45, (int)&v68, 1.001);
        PM_ClipVelocity((int)&v58, (int)v45, (int)&v55, 1.001);
        v49 = 0;
        v19 = &v74;
        v47 = 0;
        while ( 1 )
        {
          if ( v49 != v51
            && *(float *)&v68 * *(float *)((char *)&v74 + v47 * 4)
             + v69 * *(float *)((char *)&v75 + v47 * 4)
             + v70 * v76[v47] < 0.1 )
          {
            PM_ClipVelocity((int)&v68, (int)v19, (int)&v68, 1.001);
            PM_ClipVelocity((int)&v55, (int)v19, (int)&v55, 1.001);
            v20 = *(float *)&v68 * *(float *)((char *)&v74 + v46)
                + v69 * *(float *)((char *)&v75 + v46)
                + v70 * v76[v46 / 4];
            v22 = v20 > 0.0;
            v23 = 0;
            v24 = 0.0 == v20;
            if ( (unsigned __int8)((v21 & 0x45) - 1) >= 0x40u )
              break;
          }
LABEL_41:
          v19 += 3;
          v47 += 3;
          if ( ++v49 >= v53 )
          {
            v40 = pm;
            *(float *)(*(_DWORD *)pm + 32) = *(float *)&v68;
            *(float *)(*(_DWORD *)v40 + 36) = v69;
            *(float *)(*(_DWORD *)v40 + 40) = v70;
            v58 = v55;
            v59 = v56;
            v60 = v57;
            goto LABEL_44;
          }
        }
        CrossProduct((float *)v45, (float *)v19, &v77);
        VectorNormalize(&v77);
        v25 = v79 * *(float *)(*(_DWORD *)pm + 40)
            + v78 * *(float *)(*(_DWORD *)pm + 36)
            + v77 * *(float *)(*(_DWORD *)pm + 32);
        v26 = 0;
        v27 = v78 * v59 + v77 * *(float *)&v58 + v79 * v60;
        v28 = v77 * v25;
        *(float *)&v68 = v28;
        v29 = v77 * v27;
        v30 = v78 * v27;
        v31 = v27 * v79;
        v32 = v78 * v25;
        v69 = v32;
        v33 = v32;
        v34 = v25 * v79;
        v70 = v34;
        v35 = v34;
        v36 = v29;
        v37 = v35;
        *(float *)&v55 = v36;
        v38 = v30;
        v39 = v33;
        v56 = v38;
        v57 = v31;
        v43 = 0;
        while ( v26 == v51
             || v26 == v49
             || v28 * *(float *)((char *)&v74 + v43 * 4) + v39 * *(float *)((char *)&v75 + v43 * 4) + v37 * v76[v43] >= 0.1 )
        {
          v43 += 3;
          if ( ++v26 >= v53 )
            goto LABEL_41;
        }
        goto LABEL_16;
      }
    }
LABEL_44:
    ++v54;
  }
  while ( v54 < 4 );
  if ( a1 )
  {
    v41 = pm;
    *(float *)(*(_DWORD *)pm + 32) = *(float *)&v58;
    *(float *)(*(_DWORD *)v41 + 36) = v59;
    *(float *)(*(_DWORD *)v41 + 40) = v60;
  }
  v42 = pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 16) )
  {
    *(float *)(*(_DWORD *)pm + 32) = v71;
    *(float *)(*(_DWORD *)v42 + 36) = v72;
    *(float *)(*(_DWORD *)v42 + 40) = v73;
  }
  return v54 != 0;
}
// 34CB0: conditional instruction was optimized away because of '%var_F0.4>=1'
// 34E40: conditional instruction was optimized away because of '%var_F0.4>=1'
// 349AA: variable 'v5' is possibly undefined
// 349E5: variable 'v10' is possibly undefined
// 34D77: variable 'v21' is possibly undefined
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (00034FBC) --------------------------------------------------------
__int16 __cdecl PM_StepSlideMove(int a1)
{
  int v1; // edi
  _BOOL4 v2; // ebx
  int v3; // ecx
  int v4; // edx
  char v5; // fps^1
  long double v6; // fst7
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  long double v11; // fst6
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst6
  __int16 v16; // fps
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  int v20; // eax
  int v21; // edx
  __int16 v22; // fps
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  long double v26; // fst7
  long double v27; // fst6
  long double v28; // fst6
  char v29; // fps^1
  bool v30; // c0
  char v31; // c2
  bool v32; // c3
  _DWORD *v33; // edx
  char v34; // fps^1
  bool v35; // c0
  char v36; // c2
  bool v37; // c3
  long double v38; // fst7
  int v39; // edx
  int v40; // edx
  char v41; // fps^1
  bool v42; // c0
  char v43; // c2
  bool v44; // c3
  int *v45; // edx
  float *v46; // ecx
  char v47; // fps^1
  long double v48; // fst7
  bool v49; // c0
  char v50; // c2
  bool v51; // c3
  int v52; // edx
  int v53; // ecx
  char v54; // fps^1
  long double v55; // fst7
  bool v56; // c0
  char v57; // c2
  bool v58; // c3
  char v59; // fps^1
  bool v60; // c0
  char v61; // c2
  bool v62; // c3
  __int16 v63; // fps
  long double v64; // fst6
  bool v65; // c0
  char v66; // c2
  bool v67; // c3
  long double v68; // fst7
  int v69; // esi
  int v70; // ebx
  int v71; // ebx
  int v72; // edx
  long double v73; // fst7
  bool v74; // sf
  int v75; // ebx
  int v76; // edx
  int v77; // ebx
  int v78; // ecx
  long double v79; // fst7
  char v80; // bl
  float v82; // [esp+24h] [ebp-C4h]
  float v83; // [esp+28h] [ebp-C0h]
  float v84; // [esp+2Ch] [ebp-BCh]
  float v85; // [esp+34h] [ebp-B4h]
  float v86; // [esp+38h] [ebp-B0h]
  float v87; // [esp+3Ch] [ebp-ACh]
  __int16 v88; // [esp+5Ah] [ebp-8Eh]
  float v89; // [esp+70h] [ebp-78h] BYREF
  float v90; // [esp+74h] [ebp-74h]
  float v91; // [esp+78h] [ebp-70h]
  float v92; // [esp+7Ch] [ebp-6Ch] BYREF
  float v93; // [esp+80h] [ebp-68h]
  float v94; // [esp+84h] [ebp-64h]
  float v95; // [esp+88h] [ebp-60h] BYREF
  float v96; // [esp+8Ch] [ebp-5Ch]
  float v97; // [esp+90h] [ebp-58h]
  float v98; // [esp+94h] [ebp-54h]
  int v99[6]; // [esp+98h] [ebp-50h] BYREF
  unsigned __int16 v100; // [esp+B0h] [ebp-38h]
  float v101; // [esp+B8h] [ebp-30h]
  float v102; // [esp+BCh] [ebp-2Ch]
  float v103; // [esp+C0h] [ebp-28h]
  float v104; // [esp+C4h] [ebp-24h]
  float v105; // [esp+C8h] [ebp-20h]
  float v106; // [esp+CCh] [ebp-1Ch]
  float v107; // [esp+D0h] [ebp-18h] BYREF
  float v108; // [esp+D4h] [ebp-14h]
  float v109; // [esp+D8h] [ebp-10h]
  float v110; // [esp+DCh] [ebp-Ch] BYREF
  float v111; // [esp+E0h] [ebp-8h]
  float v112; // [esp+E4h] [ebp-4h]

  v83 = 0.0;
  v1 = 0;
  v2 = 0;
  if ( LODWORD(pml[12]) )
    v2 = (*(_BYTE *)(*(_DWORD *)pm + 12) & 0x10) == 0;
  v110 = *(float *)(*(_DWORD *)pm + 20);
  v111 = *(float *)(*(_DWORD *)pm + 24);
  v112 = *(float *)(*(_DWORD *)pm + 28);
  v107 = *(float *)(*(_DWORD *)pm + 32);
  v108 = *(float *)(*(_DWORD *)pm + 36);
  v109 = *(float *)(*(_DWORD *)pm + 40);
  v3 = PM_SlideMove(a1);
  v4 = *(_DWORD *)pm;
  v84 = 18.0;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0 )
    v84 = 10.0;
  if ( !v3 )
    goto LABEL_13;
  v6 = *(float *)(v4 + 104);
  v7 = v6 < -0.001;
  v8 = 0;
  v9 = v6 == -0.001;
  if ( (v5 & 0x45) != 1 && v6 <= 0.001 )
    goto LABEL_13;
  if ( *(_DWORD *)(v4 + 84) != 1023 )
    goto LABEL_16;
  v11 = v112;
  v12 = v112 < v6;
  v13 = 0;
  v14 = v112 == v6;
  if ( (v10 & 0x45) == 1 )
  {
    v84 = 18.0;
    if ( v11 + (float)18.0 > v6 )
    {
      v15 = v6 - v11;
      v84 = v15;
      v17 = v15 < 1.0;
      v18 = 0;
      v19 = v15 == 1.0;
      LOBYTE(v20) = v16;
      BYTE1(v20) = HIBYTE(v16) & 0x45;
      if ( (HIBYTE(v16) & 0x45) == 1 )
        return v20;
    }
    v1 = 1;
  }
  else
  {
LABEL_13:
    LOWORD(v20) = pm;
    v21 = *(_DWORD *)pm;
    if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 )
    {
      if ( (*(_BYTE *)(v21 + 12) & 0x10) == 0 )
        return v20;
      v23 = *(float *)(v21 + 40) > 0.0;
      v24 = 0;
      v25 = 0.0 == *(float *)(v21 + 40);
      LOBYTE(v20) = v22;
      BYTE1(v20) = HIBYTE(v22) & 0x45;
      if ( (HIBYTE(v22) & 0x45) != 1 )
        return v20;
    }
  }
LABEL_16:
  v26 = *(float *)(*(_DWORD *)pm + 20);
  v104 = *(float *)(*(_DWORD *)pm + 20);
  v27 = *(float *)(*(_DWORD *)pm + 24);
  v105 = *(float *)(*(_DWORD *)pm + 24);
  v106 = *(float *)(*(_DWORD *)pm + 28);
  v101 = *(float *)(*(_DWORD *)pm + 32);
  v102 = *(float *)(*(_DWORD *)pm + 36);
  v103 = *(float *)(*(_DWORD *)pm + 40);
  v86 = v26 - v110;
  v87 = v27 - v111;
  if ( v3 )
  {
    v93 = v111;
    v92 = v110;
    v94 = v112 + v84 + 1.0;
    (*(void (__cdecl **)(float *, float *, int, int, float *, _DWORD, _DWORD))(pm + 232))(
      &v95,
      &v110,
      pm + 192,
      pm + 204,
      &v92,
      *(_DWORD *)(*(_DWORD *)pm + 172),
      *(_DWORD *)(pm + 52));
    v28 = (v84 + 1.0) * v95 - 1.0;
    v83 = v28;
    v30 = v28 < 1.0;
    v31 = 0;
    v32 = v28 == 1.0;
    if ( (v29 & 0x45) == 1 )
    {
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("%i:not enough step room\n", c_pmove);
      v83 = 0.0;
    }
    else
    {
      v33 = (_DWORD *)pm;
      *(float *)(*(_DWORD *)pm + 20) = v92;
      *(float *)(*v33 + 24) = v93;
      *(float *)(*v33 + 28) = v83 + v112;
      *(float *)(*v33 + 32) = v107;
      *(float *)(*v33 + 36) = v108;
      *(float *)(*v33 + 40) = v109;
      if ( v33[14] && v1 )
        Com_Printf("%i:jump step to:%.2f jump peak at:%.2f\n", c_pmove, *(float *)(*v33 + 28), *(float *)(*v33 + 104));
      PM_SlideMove(a1);
    }
  }
  if ( v2 || (v35 = v83 < 0.0, v36 = 0, v37 = v83 == 0.0, (v34 & 0x45) != 64) )
  {
    v89 = *(float *)(*(_DWORD *)pm + 20);
    v90 = *(float *)(*(_DWORD *)pm + 24);
    v38 = *(float *)(*(_DWORD *)pm + 28) - v83;
    v91 = v38;
    if ( v2 )
      v91 = v38 - v84 * 0.5;
    (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(pm + 232))(
      &v95,
      *(_DWORD *)pm + 20,
      pm + 192,
      pm + 204,
      &v89,
      *(_DWORD *)(*(_DWORD *)pm + 172),
      *(_DWORD *)(pm + 52));
    if ( v100 <= 0x3Fu )
    {
      v39 = pm;
      *(float *)(*(_DWORD *)pm + 20) = v104;
      *(float *)(*(_DWORD *)v39 + 24) = v105;
      *(float *)(*(_DWORD *)v39 + 28) = v106;
      *(float *)(*(_DWORD *)v39 + 32) = v101;
      *(float *)(*(_DWORD *)v39 + 36) = v102;
      v20 = *(_DWORD *)v39;
      *(float *)(*(_DWORD *)v39 + 40) = v103;
      return v20;
    }
    if ( v95 >= 1.0 )
    {
      v42 = v83 < 0.0;
      v43 = 0;
      v44 = v83 == 0.0;
      if ( (v41 & 0x45) != 64 )
        *(float *)(*(_DWORD *)pm + 28) = *(float *)(*(_DWORD *)pm + 28) - v83;
    }
    else
    {
      v40 = pm;
      *(float *)(*(_DWORD *)pm + 20) = v96;
      *(float *)(*(_DWORD *)v40 + 24) = v97;
      *(float *)(*(_DWORD *)v40 + 28) = v98;
      PM_ClipVelocity(*(_DWORD *)v40 + 32, (int)v99, *(_DWORD *)v40 + 32, 1.001);
    }
  }
  v45 = (int *)pm;
  v46 = *(float **)pm;
  v85 = *(float *)(*(_DWORD *)pm + 24) - v111;
  if ( *(float *)(*(_DWORD *)pm + 36) * v87 + *(float *)(*(_DWORD *)pm + 32) * v86 + 0.001 >= (*(float *)(*(_DWORD *)pm + 20)
                                                                                             - v110)
                                                                                            * *(float *)(*(_DWORD *)pm + 32)
                                                                                            + *(float *)(*(_DWORD *)pm + 36)
                                                                                            * v85 )
    goto LABEL_38;
  if ( v1 )
  {
    v48 = v46[26];
    v49 = v48 < v46[7];
    v50 = 0;
    v51 = v48 == v46[7];
    if ( (unsigned __int8)((v47 & 0x45) - 1) >= 0x40u )
    {
LABEL_46:
      if ( v1 )
      {
        v53 = *(_DWORD *)pm;
        if ( *(float *)(*(_DWORD *)pm + 28) - v106 > 0.0 )
        {
          v55 = *(float *)(v53 + 104) - *(float *)(*(_DWORD *)pm + 28);
          v56 = v55 < 0.1;
          v57 = 0;
          v58 = v55 == 0.1;
          if ( (v54 & 0x45) == 1 )
          {
            *(_DWORD *)(v53 + 40) = 0;
          }
          else
          {
            v82 = sqrt((v55 + v55) * (long double)*(int *)(v53 + 60));
            v60 = v82 < (long double)*(float *)(*(_DWORD *)pm + 40);
            v61 = 0;
            v62 = v82 == *(float *)(*(_DWORD *)pm + 40);
            if ( (v59 & 0x45) == 1 )
            {
              if ( *(_DWORD *)(pm + 56) )
                Com_Printf("%i:adjusted jump vel: %.1f -> %.1f\n", c_pmove, *(float *)(*(_DWORD *)pm + 40), v82);
              *(float *)(*(_DWORD *)pm + 40) = v82;
            }
          }
        }
      }
      goto LABEL_54;
    }
LABEL_38:
    v46[5] = v104;
    *(float *)(*v45 + 24) = v105;
    *(float *)(*v45 + 28) = v106;
    *(float *)(*v45 + 32) = v101;
    *(float *)(*v45 + 36) = v102;
    *(float *)(*v45 + 40) = v103;
    if ( v45[14] > 1 )
    {
      if ( v1 )
        Com_Printf("%i:didn't use jump step results because it went too high\n", c_pmove);
      else
        Com_Printf("%i:didn't use step results\n", c_pmove);
    }
    if ( v2 )
    {
      v89 = *(float *)(*(_DWORD *)pm + 20);
      v90 = *(float *)(*(_DWORD *)pm + 24);
      v91 = *(float *)(*(_DWORD *)pm + 28) - v84 * 0.5;
      (*(void (__cdecl **)(float *, int, int, int, float *, _DWORD, _DWORD))(pm + 232))(
        &v95,
        *(_DWORD *)pm + 20,
        pm + 192,
        pm + 204,
        &v89,
        *(_DWORD *)(*(_DWORD *)pm + 172),
        *(_DWORD *)(pm + 52));
      if ( v95 < 1.0 )
      {
        v52 = pm;
        *(float *)(*(_DWORD *)pm + 20) = v96;
        *(float *)(*(_DWORD *)v52 + 24) = v97;
        *(float *)(*(_DWORD *)v52 + 28) = v98;
        PM_ClipVelocity(*(_DWORD *)v52 + 32, (int)v99, *(_DWORD *)v52 + 32, 1.001);
        if ( *(int *)(pm + 56) > 1 )
          Com_Printf("%i:did down step after not using step results\n", c_pmove);
      }
    }
    goto LABEL_46;
  }
LABEL_54:
  v20 = *(_DWORD *)pm;
  if ( *(int *)(*(_DWORD *)pm + 4) <= 5 )
  {
    v20 = PM_VerifyPronePosition(&v110, &v107);
    if ( v20 )
    {
      v64 = fabs(*(float *)(*(_DWORD *)pm + 28) - v106);
      v65 = v64 < 0.5;
      v66 = 0;
      v67 = v64 == 0.5;
      LOBYTE(v20) = v63;
      BYTE1(v20) = HIBYTE(v63) & 0x45;
      if ( v64 > 0.5 )
      {
        v68 = *(float *)(*(_DWORD *)pm + 28) - v106 + 0.5;
        LOWORD(v20) = v88 | 0xC00;
        v69 = (int)v68;
        v70 = (int)v68;
        if ( (int)v68 )
        {
          if ( *(_DWORD *)(pm + 56) )
          {
            if ( v1 )
              Com_Printf("%i:jump step %2i\n", c_pmove, (int)v68);
            else
              Com_Printf("%i:stepped %2i\n", c_pmove, (int)v68);
          }
          if ( v69 >= -16 )
          {
            if ( v69 > 24 )
              v70 = 24;
          }
          else
          {
            v70 = -16;
          }
          v71 = v70 + 128;
          BG_AddPredictableEventToPlayerstate(143, v71, *(_DWORD *)pm);
          v72 = pm;
          v73 = (1.0 - fabs(*(float *)(*(_DWORD *)pm + 28) - v112) / v84) * 0.80000001 + 0.19999999;
          *(float *)(*(_DWORD *)pm + 32) = *(float *)(*(_DWORD *)pm + 32) * v73;
          *(float *)(*(_DWORD *)v72 + 36) = *(float *)(*(_DWORD *)v72 + 36) * v73;
          v74 = v71 - 128 < 0;
          v75 = v71 - 128;
          *(float *)(*(_DWORD *)v72 + 40) = v73 * *(float *)(*(_DWORD *)v72 + 40);
          v20 = v75;
          if ( v74 )
            v20 = -v75;
          if ( v20 > 3 )
          {
            v20 = *(_DWORD *)v72;
            if ( *(_DWORD *)(*(_DWORD *)v72 + 84) != 1023 )
            {
              v20 = PM_ShouldMakeFootsteps();
              if ( v20 )
              {
                v76 = v75;
                if ( v75 < 0 )
                  v76 = -v75;
                v77 = v76 / 2;
                if ( v76 / 2 > 4 )
                  v77 = 4;
                v78 = pm;
                v79 = (long double)v77 * 1.25;
                v80 = *(_DWORD *)(*(_DWORD *)pm + 8);
                *(_DWORD *)(*(_DWORD *)pm + 8) = (unsigned __int8)(int)((long double)*(int *)(*(_DWORD *)pm + 8)
                                                                      + v79
                                                                      + 7.0);
                LOWORD(v20) = PM_FootstepEvent(v80, *(_DWORD *)(*(_DWORD *)v78 + 8), 1);
              }
            }
          }
        }
      }
    }
  }
  return v20;
}
// 3506A: variable 'v5' is possibly undefined
// 35093: variable 'v10' is possibly undefined
// 351E2: variable 'v29' is possibly undefined
// 352B4: variable 'v34' is possibly undefined
// 353DC: variable 'v41' is possibly undefined
// 35460: variable 'v47' is possibly undefined
// 355DA: variable 'v54' is possibly undefined
// 3560C: variable 'v59' is possibly undefined
// 356C2: variable 'v88' is possibly undefined
// 2E314: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 31FE4: using guessed type _DWORD __cdecl PM_FootstepEvent(char, char, _DWORD);
// 3221C: using guessed type int PM_ShouldMakeFootsteps(void);
// 346E0: using guessed type _DWORD __cdecl PM_VerifyPronePosition(_DWORD, _DWORD);
// 347C0: using guessed type _DWORD __cdecl PM_SlideMove(_DWORD);
// 7C72C: using guessed type int c_pmove;
// 16EE30: using guessed type int pm;

//----- (00035880) --------------------------------------------------------
int __cdecl sub_35880(int a1, char *s1, int a3)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v7; // ebx
  int v8; // ebx

  switch ( a3 )
  {
    case 8:
      v3 = 0;
      break;
    case 9:
      v4 = 0;
      while ( 2 )
      {
        if ( v4 <= 7 )
        {
          if ( strcasecmp(s1, (&off_7C964)[v4]) )
          {
            ++v4;
            continue;
          }
          *(_DWORD *)(a1 + 116) = v4;
        }
        break;
      }
      if ( v4 == 8 )
        Com_Error(1, byte_71E00, s1, *(_DWORD *)(a1 + 4));
      return 1;
    case 10:
      v5 = 0;
      while ( 2 )
      {
        if ( v5 <= 4 )
        {
          if ( strcasecmp(s1, (&off_7C92C)[v5]) )
          {
            ++v5;
            continue;
          }
          *(_DWORD *)(a1 + 552) = v5;
        }
        break;
      }
      if ( v5 == 5 )
        Com_Error(1, byte_71E40, s1, *(_DWORD *)(a1 + 4));
      return 1;
    case 11:
      v6 = 0;
      while ( 2 )
      {
        if ( v6 <= 5 )
        {
          if ( strcasecmp(s1, (&off_7C940)[v6]) )
          {
            ++v6;
            continue;
          }
          *(_DWORD *)(a1 + 120) = v6;
        }
        break;
      }
      if ( v6 == 6 )
        Com_Error(1, byte_71E80, s1, *(_DWORD *)(a1 + 4));
      return 1;
    case 12:
      v7 = 0;
      while ( 2 )
      {
        if ( v7 <= 2 )
        {
          if ( strcasecmp(s1, (&off_7C958)[v7]) )
          {
            ++v7;
            continue;
          }
          *(_DWORD *)(a1 + 128) = v7;
        }
        break;
      }
      if ( v7 == 3 )
        Com_Error(1, byte_71EC0, s1, *(_DWORD *)(a1 + 4));
      return 1;
    case 13:
      v8 = 0;
      while ( 2 )
      {
        if ( v8 <= 3 )
        {
          if ( strcasecmp(s1, (&off_7C984)[v8]) )
          {
            ++v8;
            continue;
          }
          *(_DWORD *)(a1 + 800) = v8;
        }
        break;
      }
      if ( v8 == 4 )
        Com_Error(1, (char *)&byte_71F00, s1, *(_DWORD *)(a1 + 4));
      return 1;
    default:
      Com_Error(1, (char *)&byte_71F2C, a3, *(_DWORD *)(a1 + 4));
      return 0;
  }
  while ( 1 )
  {
    if ( v3 > 2 )
      goto LABEL_7;
    if ( !strcasecmp(s1, (&s2)[v3]) )
      break;
    ++v3;
  }
  *(_DWORD *)(a1 + 112) = v3;
LABEL_7:
  if ( v3 == 3 )
    Com_Error(1, byte_71DC0, s1, *(_DWORD *)(a1 + 4));
  return 1;
}

//----- (00035A54) --------------------------------------------------------
char *__cdecl sub_35A54(int a1, char *src)
{
  char *result; // eax
  char *v3; // eax
  int v4; // edx
  int v5; // edx
  char *v6; // ebx

  if ( !*src )
  {
    result = (char *)dword_A9D24;
    *(_DWORD *)a1 = dword_A9D24;
    return result;
  }
  v3 = src;
  v4 = (unsigned __int8)src & 3;
  if ( ((unsigned __int8)src & 3) == 0 )
    goto LABEL_12;
  if ( __SETP__((unsigned __int8)src & 3, 0) )
    goto LABEL_10;
  if ( v4 != 2 )
  {
    if ( *src == BYTE1(v4) )
      goto LABEL_19;
    v3 = src + 1;
  }
  if ( *v3 != BYTE1(v4) )
  {
    ++v3;
LABEL_10:
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_12:
      while ( 1 )
      {
        v5 = *(_DWORD *)v3;
        if ( !(unsigned __int8)*(_DWORD *)v3 )
          break;
        if ( !BYTE1(v5) )
          goto LABEL_18;
        if ( (v5 & 0xFF0000) == 0 )
          goto LABEL_17;
        v3 += 4;
        if ( (v5 & 0xFF000000) == 0 )
        {
          v3 -= 3;
LABEL_17:
          ++v3;
LABEL_18:
          ++v3;
          break;
        }
      }
    }
  }
LABEL_19:
  v6 = (char *)trap_Hunk_AllocLowAlignInternal(v3 - src + 1, 1);
  result = strcpy(v6, src);
  *(_DWORD *)a1 = v6;
  return result;
}
// A9D24: using guessed type int dword_A9D24;

//----- (00035ADC) --------------------------------------------------------
char *__cdecl sub_35ADC(int a1, int a2)
{
  const char *v2; // edx
  unsigned int v3; // eax
  int v4; // eax
  _DWORD *v5; // esi
  char **v6; // ebx
  int i; // edi
  char *result; // eax
  int v9; // ebx
  char **v10; // ebx
  int j; // esi
  int v12; // ebx
  size_t v13; // eax
  int v14; // ebx
  int v15; // edx
  int v16; // [esp+24h] [ebp-2054h]
  int *v17; // [esp+28h] [ebp-2050h]
  size_t n; // [esp+2Ch] [ebp-204Ch]
  int v19; // [esp+30h] [ebp-2048h]
  int v20; // [esp+34h] [ebp-2044h] BYREF
  char s1[8192]; // [esp+38h] [ebp-2040h] BYREF
  char v22[64]; // [esp+2038h] [ebp-40h] BYREF

  v2 = "WEAPONFILE";
  v3 = (unsigned int)"WEAPONFILE" & 3;
  if ( ((unsigned int)"WEAPONFILE" & 3) != 0 )
  {
    if ( !__SETP__((unsigned int)"WEAPONFILE" & 3, 0) )
    {
      if ( v3 != 2 )
      {
        if ( aWeaponfile[0] == BYTE1(v3) )
          goto LABEL_17;
        v2 = "EAPONFILE";
      }
      if ( *v2 == BYTE1(v3) )
        goto LABEL_17;
      ++v2;
    }
    if ( *v2 != BYTE1(v3) )
    {
      ++v2;
      goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      if ( !(unsigned __int8)*(_DWORD *)v2 )
        break;
      if ( !BYTE1(v4) )
        goto LABEL_16;
      if ( (v4 & 0xFF0000) == 0 )
        goto LABEL_15;
      v2 += 4;
      if ( (v4 & 0xFF000000) == 0 )
      {
        v2 -= 3;
LABEL_15:
        ++v2;
LABEL_16:
        ++v2;
        break;
      }
    }
  }
LABEL_17:
  n = v2 - "WEAPONFILE";
  dword_A9D24 = trap_Hunk_AllocLowAlignInternal(1, 1);
  *(_BYTE *)dword_A9D24 = 0;
  v5 = (_DWORD *)trap_Hunk_AllocLowInternal(1052);
  *(_DWORD *)dword_7C91C = v5;
  *v5 = 0;
  sub_35A54((int)(v5 + 1), (char *)&byte_71F60);
  v6 = &off_7C994;
  for ( i = 247; i >= 0; --i )
  {
    if ( !v6[2] )
      sub_35A54((int)v5 + (_DWORD)v6[1], (char *)&byte_71F60);
    v6 += 3;
  }
  result = sub_35A54((int)(v5 + 1), "none");
  dword_7C918 = 0;
  v19 = 0;
  if ( a2 > 0 )
  {
    do
    {
      v9 = ++dword_7C918;
      v17 = (int *)trap_Hunk_AllocLowInternal(1052);
      *(_DWORD *)(dword_7C91C + 4 * v9) = v17;
      *v17 = v9;
      sub_35A54((int)(v17 + 1), (char *)&byte_71F60);
      v10 = &off_7C994;
      v16 = v19 + 1;
      for ( j = 247; j >= 0; --j )
      {
        if ( !v10[2] )
          sub_35A54((int)v17 + (_DWORD)v10[1], (char *)&byte_71F60);
        v10 += 3;
      }
      sprintf(v22, "%s/", bg_szWeaponsFolder);
      strcat(v22, *(const char **)(a1 + 4 * v19));
      Com_DPrintf("Parsing weapon file \"%s\"...\n", v22);
      v12 = trap_FS_FOpenFile((int)v22, (int)&v20, 0);
      if ( v12 <= 0 )
        Com_Error(1, (char *)&byte_71FA0, v22);
      trap_FS_Read((int)s1, n, v20);
      v13 = n;
      s1[n] = 0;
      if ( strncmp(s1, "WEAPONFILE", v13) )
        Com_Error(1, (char *)&byte_71FE0, v22);
      v14 = v12 - n;
      if ( v14 > 0x1FFF )
        Com_Error(1, (char *)&byte_72020, v22);
      _bzero(s1, 0x2000u);
      trap_FS_Read((int)s1, v14, v20);
      s1[v14] = 0;
      trap_FS_FCloseFile(v20);
      if ( !Info_Validate(s1) )
        Com_Error(1, (char *)&byte_72060, v22);
      sub_35A54((int)(v17 + 1), *(char **)(a1 + 4 * v19));
      result = (char *)ParseConfigStringToStruct(
                         (int)v17,
                         (int)&off_7C994,
                         248,
                         s1,
                         14,
                         sub_35880,
                         (void (__cdecl *)(int, char *))sub_3AE70);
      if ( !result )
      {
        v15 = dword_7C918;
        result = (char *)dword_7C91C;
        *(_DWORD *)(dword_7C91C + 4 * dword_7C918) = 0;
        dword_7C918 = v15 - 1;
      }
      v19 = v16;
    }
    while ( v16 < a2 );
  }
  return result;
}
// 7C914: using guessed type char *bg_szWeaponsFolder;
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// 7C994: using guessed type char *off_7C994;
// A9D24: using guessed type int dword_A9D24;

//----- (00035E74) --------------------------------------------------------
int __usercall BG_FillInWeaponItems@<eax>(int result@<eax>)
{
  int v1; // ecx
  int *v2; // esi
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // ebx
  int i; // edi
  int v7; // ebx
  _BYTE *v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ebx
  int v12; // [esp+24h] [ebp-4h]

  v1 = dword_7C918;
  v2 = &bg_itemlist[12];
  v3 = 1;
  if ( dword_7C918 >= 1 )
  {
    v4 = dword_7C91C;
    do
    {
      v5 = *(_DWORD **)(v4 + 4 * v3);
      *v2 = v5[97];
      v2[1] = v5[35];
      v2[2] = v5[98];
      v2[3] = 0;
      v2[4] = v5[99];
      v2[5] = v5[101];
      v2[6] = v5[2];
      v2[7] = v5[102];
      v2[8] = 1;
      v2[9] = v3;
      v2[10] = v5[104];
      result = v5[106];
      v2[11] = result;
      ++v3;
      v2 += 12;
    }
    while ( v3 <= v1 );
  }
  while ( v3 < bg_numItems )
  {
    v12 = v3 + 1;
    result = (int)(v2 + 12);
    if ( v2[8] != 2 )
      goto LABEL_29;
    for ( i = 1; i <= dword_7C918; ++i )
    {
      v7 = *(_DWORD *)(dword_7C91C + 4 * i);
      v8 = *(_BYTE **)(v7 + 4);
      v9 = (unsigned __int8)v8 & 3;
      if ( ((unsigned __int8)v8 & 3) == 0 )
        goto LABEL_18;
      if ( __SETP__(*(_DWORD *)(v7 + 4) & 3, 0) )
        goto LABEL_16;
      if ( v9 != 2 )
      {
        if ( *v8 == BYTE1(v9) )
          goto LABEL_25;
        ++v8;
      }
      if ( *v8 != BYTE1(v9) )
      {
        ++v8;
LABEL_16:
        if ( *v8 != BYTE1(v9) )
        {
          ++v8;
LABEL_18:
          while ( 1 )
          {
            v10 = *(_DWORD *)v8;
            if ( !(unsigned __int8)*(_DWORD *)v8 )
              break;
            if ( !BYTE1(v10) )
              goto LABEL_24;
            if ( (v10 & 0xFF0000) == 0 )
              goto LABEL_23;
            v8 += 4;
            if ( (v10 & 0xFF000000) == 0 )
            {
              v8 -= 3;
LABEL_23:
              ++v8;
LABEL_24:
              ++v8;
              break;
            }
          }
        }
      }
LABEL_25:
      result = Q_stricmpn((char *)v2[6], *(char **)(v7 + 4), (int)&v8[-*(_DWORD *)(v7 + 4)]);
      if ( !result )
      {
        v2[9] = i;
        v2[10] = *(_DWORD *)(v7 + 416);
        result = *(_DWORD *)(v7 + 424);
        v2[11] = result;
        break;
      }
    }
    if ( v2[9] == -1 )
    {
      Com_Printf("^3WARNING^7: Could not find weapon for ammo item %s\n", (const char *)v2[6]);
      v11 = *(_DWORD *)(dword_7C91C + 4);
      v2[9] = 1;
      v2[10] = *(_DWORD *)(v11 + 416);
      result = *(_DWORD *)(v11 + 424);
      v2[11] = result;
    }
LABEL_29:
    v3 = v12;
    v2 += 12;
  }
  return result;
}
// 70804: using guessed type int bg_numItems;
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;

//----- (0003600C) --------------------------------------------------------
int BG_SetupAmmoIndexes()
{
  int result; // eax
  int v1; // esi
  int i; // edi
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v9 = 1;
  result = 1;
  if ( dword_7C918 >= 1 )
  {
    do
    {
      v1 = *(_DWORD *)(dword_7C91C + 4 * v9);
      Q_strlwr(*(_BYTE **)(v1 + 412));
      v8 = 0;
      v7 = v9 + 1;
      if ( dword_A98E0 > 0 )
      {
        v6 = 0;
        while ( Q_stricmp((char *)dword_A96E0[v6], *(char **)(v1 + 412)) )
        {
          ++v8;
          ++v6;
          if ( v8 >= dword_A98E0 )
            goto LABEL_14;
        }
        *(_DWORD *)(v1 + 416) = v8;
        if ( dword_A97E0[v6] != *(_DWORD *)(v1 + 428) )
        {
          if ( v8 )
          {
            for ( i = 1; i < v9; ++i )
            {
              v3 = *(_DWORD *)(dword_7C91C + 4 * i);
              if ( !Q_stricmp((char *)dword_A96E0[v6], *(char **)(v3 + 412)) )
              {
                v4 = *(_DWORD *)(v3 + 428);
                if ( v4 == dword_A97E0[v6] )
                  Com_Error(
                    1,
                    (char *)&byte_720E0,
                    *(_DWORD *)(v1 + 412),
                    *(_DWORD *)(v1 + 4),
                    *(_DWORD *)(v1 + 428),
                    *(_DWORD *)(v3 + 4),
                    v4);
              }
            }
          }
        }
      }
LABEL_14:
      if ( v8 == dword_A98E0 )
      {
        v5 = v8;
        dword_A96E0[v5] = *(_DWORD *)(v1 + 412);
        dword_A97E0[v5] = *(_DWORD *)(v1 + 428);
        *(_DWORD *)(v1 + 416) = v8;
        dword_A98E0 = v8 + 1;
      }
      result = ++v9;
    }
    while ( v7 <= dword_7C918 );
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// A98E0: using guessed type int dword_A98E0;

//----- (000361AC) --------------------------------------------------------
int BG_SetupSharedAmmoIndexes()
{
  int result; // eax
  int v1; // esi
  const char *v2; // eax
  int i; // edi
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]

  v10 = 1;
  result = 1;
  if ( dword_7C918 >= 1 )
  {
    do
    {
      v1 = *(_DWORD *)(dword_7C91C + 4 * v10);
      *(_DWORD *)(v1 + 440) = -1;
      v2 = *(const char **)(v1 + 436);
      v8 = v10 + 1;
      if ( *v2 )
      {
        Com_DPrintf("%s: %s\n", *(const char **)(v1 + 4), v2);
        Q_strlwr(*(_BYTE **)(v1 + 436));
        v9 = 0;
        if ( dword_A9B00 > 0 )
        {
          v7 = 0;
          while ( Q_stricmp((char *)dword_A9900[v7], *(char **)(v1 + 436)) )
          {
            ++v9;
            ++v7;
            if ( v9 >= dword_A9B00 )
              goto LABEL_15;
          }
          *(_DWORD *)(v1 + 440) = v9;
          if ( dword_A9A00[v7] != *(_DWORD *)(v1 + 444) )
          {
            if ( v9 )
            {
              for ( i = 1; i < v10; ++i )
              {
                v4 = *(_DWORD *)(dword_7C91C + 4 * i);
                if ( !Q_stricmp((char *)dword_A9900[v7], *(char **)(v4 + 436)) )
                {
                  v5 = *(_DWORD *)(v4 + 444);
                  if ( v5 == dword_A9A00[v7] )
                    Com_Error(
                      1,
                      (char *)&byte_72140,
                      *(_DWORD *)(v1 + 436),
                      *(_DWORD *)(v1 + 4),
                      *(_DWORD *)(v1 + 444),
                      *(_DWORD *)(v4 + 4),
                      v5);
                }
              }
            }
          }
        }
LABEL_15:
        if ( v9 == dword_A9B00 )
        {
          v6 = v9;
          dword_A9900[v6] = *(_DWORD *)(v1 + 436);
          dword_A9A00[v6] = *(_DWORD *)(v1 + 444);
          *(_DWORD *)(v1 + 440) = v9;
          dword_A9B00 = v9 + 1;
        }
      }
      result = ++v10;
    }
    while ( v8 <= dword_7C918 );
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// A9900: using guessed type int dword_A9900[];
// A9A00: using guessed type int dword_A9A00[];
// A9B00: using guessed type int dword_A9B00;

//----- (00036370) --------------------------------------------------------
int BG_SetupClipIndexes()
{
  int result; // eax
  int v1; // esi
  int i; // edi
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  v9 = 1;
  result = 1;
  if ( dword_7C918 >= 1 )
  {
    do
    {
      v1 = *(_DWORD *)(dword_7C91C + 4 * v9);
      Q_strlwr(*(_BYTE **)(v1 + 420));
      v8 = 0;
      v7 = v9 + 1;
      if ( dword_A9D20 > 0 )
      {
        v6 = 0;
        while ( Q_stricmp((char *)dword_A9B20[v6], *(char **)(v1 + 420)) )
        {
          ++v8;
          ++v6;
          if ( v8 >= dword_A9D20 )
            goto LABEL_14;
        }
        *(_DWORD *)(v1 + 424) = v8;
        if ( dword_A9C20[v6] != *(_DWORD *)(v1 + 432) )
        {
          if ( v8 )
          {
            for ( i = 1; i < v9; ++i )
            {
              v3 = *(_DWORD *)(dword_7C91C + 4 * i);
              if ( !Q_stricmp((char *)dword_A9B20[v6], *(char **)(v3 + 420)) )
              {
                v4 = *(_DWORD *)(v3 + 432);
                if ( v4 == dword_A9C20[v6] )
                  Com_Error(
                    1,
                    (char *)&byte_721C0,
                    *(_DWORD *)(v1 + 412),
                    *(_DWORD *)(v1 + 4),
                    *(_DWORD *)(v1 + 432),
                    *(_DWORD *)(v3 + 4),
                    v4);
              }
            }
          }
        }
      }
LABEL_14:
      if ( v8 == dword_A9D20 )
      {
        v5 = v8;
        dword_A9B20[v5] = *(_DWORD *)(v1 + 420);
        dword_A9C20[v5] = *(_DWORD *)(v1 + 432);
        *(_DWORD *)(v1 + 424) = v8;
        dword_A9D20 = v8 + 1;
      }
      result = ++v9;
    }
    while ( v7 <= dword_7C918 );
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// A9D20: using guessed type int dword_A9D20;

//----- (0003650C) --------------------------------------------------------
int sub_3650C()
{
  int result; // eax
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // edi
  int v6; // esi
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  result = dword_7C918;
  v1 = 1;
  if ( dword_7C918 >= 1 )
  {
    v2 = dword_7C91C;
    do
      *(_DWORD *)(*(_DWORD *)(v2 + 4 * v1++) + 764) = 0;
    while ( v1 <= result );
  }
  v3 = 1;
  if ( dword_7C918 >= 1 )
  {
    do
    {
      result = *(_DWORD *)(dword_7C91C + 4 * v3);
      v8 = result;
      v7 = v3 + 1;
      if ( !*(_DWORD *)(result + 764) )
      {
        result = *(_DWORD *)(result + 760);
        if ( *(_BYTE *)result )
        {
          v4 = v8;
          do
          {
            v5 = 1;
            if ( dword_7C918 >= 1 )
            {
              while ( 1 )
              {
                v6 = *(_DWORD *)(dword_7C91C + 4 * v5);
                if ( !strcasecmp(*(const char **)(v4 + 760), *(const char **)(v6 + 4)) )
                  break;
                if ( ++v5 > dword_7C918 )
                  goto LABEL_15;
              }
              *(_DWORD *)(v4 + 764) = v5;
              if ( *(_DWORD *)(v4 + 120) != *(_DWORD *)(v6 + 120) )
                Com_Error(1, (char *)&byte_72220, *(_DWORD *)(v4 + 4), *(_DWORD *)(v6 + 4));
              if ( *(_DWORD *)(v4 + 124) != *(_DWORD *)(v6 + 124) )
                Com_Error(1, (char *)&byte_72280, *(_DWORD *)(v4 + 4), *(_DWORD *)(v6 + 4));
            }
LABEL_15:
            if ( !*(_DWORD *)(v4 + 764) )
              Com_Error(1, (char *)&byte_722E0, *(_DWORD *)(v4 + 760), *(_DWORD *)(v4 + 4));
            result = dword_7C91C;
            v4 = *(_DWORD *)(dword_7C91C + 4 * v5);
          }
          while ( !*(_DWORD *)(v4 + 764) );
          if ( v4 != v8 )
            result = Com_Error(1, (char *)&byte_72320, *(_DWORD *)(v8 + 4), *(_DWORD *)(v8 + 760));
        }
      }
      v3 = v7;
    }
    while ( v7 <= dword_7C918 );
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;

//----- (00036674) --------------------------------------------------------
int BG_SetupWeaponInfo()
{
  char *v0; // edi
  int v1; // esi
  int *v2; // ebx
  int v3; // eax
  int v4; // eax
  int i; // esi
  int v6; // esi
  int v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // ebx
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int j; // ebx
  int v16; // eax
  int nmemb; // [esp+20h] [ebp-3108h]
  int v19; // [esp+24h] [ebp-3104h] BYREF
  int v20; // [esp+28h] [ebp-3100h]
  char v21[8192]; // [esp+2Ch] [ebp-30FCh] BYREF
  char v22[4096]; // [esp+202Ch] [ebp-10FCh] BYREF
  int s[63]; // [esp+302Ch] [ebp-FCh] BYREF

  Com_DPrintf("----------------------\n");
  Com_DPrintf("Game: BG_SetupWeaponInfo\n");
  dword_7C91C = trap_GetWeaponInfoMemory(256, (int)&v19);
  if ( !dword_7C91C )
    Com_Error(1, (char *)&byte_72400);
  _bzero(dword_A96E0, 0x100u);
  _bzero(dword_A97E0, 4u);
  dword_A96E0[0] = (int)"none";
  dword_A98E0 = 1;
  _bzero(dword_A9B20, 0x100u);
  _bzero(dword_A9C20, 4u);
  dword_A9B20[0] = (int)"none";
  dword_A9D20 = 1;
  _bzero(s, 0xFCu);
  if ( v19 )
  {
    dword_7C918 = 0;
    v6 = 1;
    if ( *(_DWORD *)(dword_7C91C + 4) )
    {
      v7 = 0;
      do
      {
        ++v7;
        ++v6;
      }
      while ( v6 <= 63 && *(_DWORD *)(dword_7C91C + 4 * v6) );
      dword_7C918 = v7;
    }
  }
  else
  {
    nmemb = trap_FS_GetFileList((int)bg_szWeaponsFolder, (int)&byte_71F60, (int)v22);
    v0 = v22;
    if ( nmemb <= 0 )
      Com_Error(1, (char *)&byte_72440, bg_szWeaponsFolder);
    if ( nmemb > 63 )
      Com_Error(1, (char *)&byte_72460, 63, nmemb);
    v1 = 0;
    if ( nmemb > 0 )
    {
      do
      {
        v2 = (int *)v0;
        v3 = (unsigned __int8)v0 & 3;
        if ( ((unsigned __int8)v0 & 3) == 0 )
          goto LABEL_18;
        if ( __SETP__((unsigned __int8)v0 & 3, 0) )
          goto LABEL_16;
        if ( v3 != 2 )
        {
          if ( *v0 == BYTE1(v3) )
            goto LABEL_25;
          v2 = (int *)(v0 + 1);
        }
        if ( *(_BYTE *)v2 != BYTE1(v3) )
        {
          v2 = (int *)((char *)v2 + 1);
LABEL_16:
          if ( *(_BYTE *)v2 != BYTE1(v3) )
          {
            v2 = (int *)((char *)v2 + 1);
LABEL_18:
            while ( 1 )
            {
              v4 = *v2;
              if ( !(unsigned __int8)*v2 )
                break;
              if ( !BYTE1(v4) )
                goto LABEL_24;
              if ( (v4 & 0xFF0000) == 0 )
                goto LABEL_23;
              ++v2;
              if ( (v4 & 0xFF000000) == 0 )
              {
                v2 = (int *)((char *)v2 - 3);
LABEL_23:
                v2 = (int *)((char *)v2 + 1);
LABEL_24:
                v2 = (int *)((char *)v2 + 1);
                break;
              }
            }
          }
        }
LABEL_25:
        Com_DPrintf("Getting weapon file \"%s/%s\" for parsing\n", bg_szWeaponsFolder, v0);
        s[v1++] = (int)v0;
        v0 = (char *)v2 + 1;
      }
      while ( v1 < nmemb && v1 <= 62 );
    }
    qsort(s, nmemb, 4u, compare_weaponfile_names);
    v21[0] = 0;
    for ( i = 0; i < nmemb; ++i )
    {
      if ( i > 0 )
        strcat(v21, " ");
      strcat(v21, (const char *)s[i]);
    }
    trap_SetConfigstring(7, (int)v21);
    sub_35ADC((int)s, nmemb);
  }
  v8 = 1;
  if ( dword_7C918 >= 1 )
  {
    v9 = dword_7C91C;
    v10 = dword_7C918;
    do
    {
      v11 = *(_DWORD *)(v9 + 4 * v8);
      v12 = *(_DWORD *)(v11 + 616);
      if ( v12 <= 0 )
      {
        *(float *)(v11 + 1044) = 0.0033333334;
      }
      else
      {
        v20 = *(_DWORD *)(v11 + 616);
        *(float *)(v11 + 1044) = 1.0 / (long double)v12;
      }
      v13 = *(_DWORD *)(v11 + 620);
      if ( v13 <= 0 )
      {
        *(float *)(v11 + 1048) = 0.0020000001;
      }
      else
      {
        v20 = *(_DWORD *)(v11 + 620);
        *(float *)(v11 + 1048) = 1.0 / (long double)v13;
      }
      ++v8;
    }
    while ( v8 <= v10 );
  }
  BG_SetupAmmoIndexes();
  BG_SetupSharedAmmoIndexes();
  v14 = BG_SetupClipIndexes();
  BG_FillInWeaponItems(v14);
  sub_3650C();
  for ( j = 1; j <= dword_7C918; ++j )
  {
    v16 = *(_DWORD *)(dword_7C91C + 4 * j);
    if ( **(_BYTE **)(v16 + 1032) && !G_GetHintStringIndex(v16 + 1036, *(char **)(v16 + 1032)) )
      Com_Error(1, (char *)&byte_72360, 32);
  }
  return Com_DPrintf("----------------------\n");
}
// 7C914: using guessed type char *bg_szWeaponsFolder;
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// A98E0: using guessed type int dword_A98E0;
// A9D20: using guessed type int dword_A9D20;

//----- (00036A38) --------------------------------------------------------
int __cdecl BG_GivePlayerWeapon(int a1, int a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  unsigned int v5; // eax
  int i; // ebx

  if ( Com_BitCheck(a1 + 780, a2) )
    return 0;
  v2 = *(_DWORD **)(dword_7C91C + 4 * a2);
  v3 = v2[29];
  if ( v3 == 6 || v3 == 7 )
    return 0;
  RegisterItem(a2, 1);
  Com_BitSet(a1 + 780, a2);
  Com_BitClear(a1 + 796, a2);
  v5 = v2[30];
  if ( v5 )
  {
    if ( v5 <= 2 )
    {
      if ( *(_BYTE *)(a1 + 789) )
      {
        if ( !*(_BYTE *)(a1 + 790) )
          *(_BYTE *)(a1 + 790) = a2;
      }
      else
      {
        *(_BYTE *)(a1 + 789) = a2;
      }
    }
    else if ( v5 <= 5 && !*(_BYTE *)(v5 + a1 + 788) )
    {
      *(_BYTE *)(v5 + a1 + 788) = a2;
    }
  }
  for ( i = v2[191]; i && !Com_BitCheck(a1 + 780, i); i = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * i) + 764) )
  {
    RegisterItem(i, 1);
    Com_BitSet(a1 + 780, i);
    Com_BitClear(a1 + 796, a2);
  }
  return 1;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (00036B78) --------------------------------------------------------
int __cdecl BG_TakePlayerWeapon(int a1, int a2)
{
  int v3; // eax
  int v4; // edi
  int v5; // esi
  int v6; // ebx
  int v7; // edx
  int i; // ebx
  _DWORD *v9; // [esp+14h] [ebp-4h]

  if ( !Com_BitCheck(a1 + 780, a2) )
    return 0;
  v9 = *(_DWORD **)(dword_7C91C + 4 * a2);
  v3 = BG_IsPlayerWeaponInSlot(a1, a2, 1);
  v4 = v3;
  v5 = a1 + 780;
  if ( v3 )
  {
    if ( v9[31] )
    {
      v6 = 1;
      if ( dword_7C918 < 1 )
        goto LABEL_13;
      while ( 1 )
      {
        v7 = *(_DWORD *)(dword_7C91C + 4 * a2);
        if ( *(_DWORD *)(v7 + 124) )
        {
          if ( *(_DWORD *)(v7 + 120) == v9[30] && Com_BitCheck(v5, v6) && !BG_IsPlayerWeaponInSlot(a1, v6, 1) )
            break;
        }
        if ( ++v6 > dword_7C918 )
          goto LABEL_12;
      }
      *(_BYTE *)(v4 + a1 + 788) = v6;
LABEL_12:
      if ( v6 > dword_7C918 )
LABEL_13:
        *(_BYTE *)(v4 + a1 + 788) = 0;
    }
    else
    {
      *(_BYTE *)(v3 + a1 + 788) = 0;
    }
  }
  Com_BitClear(v5, a2);
  for ( i = v9[191]; i && Com_BitCheck(v5, i); i = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * i) + 764) )
    Com_BitClear(v5, i);
  return 1;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;

//----- (00036CC8) --------------------------------------------------------
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3)
{
  int v3; // edx
  unsigned int v4; // edx

  v3 = *(_DWORD *)(dword_7C91C + 4 * a2);
  if ( *(_DWORD *)(v3 + 124) )
  {
    v4 = *(_DWORD *)(v3 + 120);
    if ( v4 )
    {
      if ( v4 <= 2 )
      {
        if ( (unsigned int)(a3 - 1) <= 1
          && (!*(_BYTE *)(a3 + a1 + 788) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(char *)(a3 + a1 + 788)) + 124)) )
        {
          return a3;
        }
        if ( !*(_BYTE *)(a1 + 789) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(char *)(a1 + 789)) + 124) )
          return 1;
        if ( !*(_BYTE *)(a1 + 790) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(char *)(a1 + 790)) + 124) )
          return 2;
      }
      else if ( v4 <= 5
             && (!*(_BYTE *)(v4 + a1 + 788) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(char *)(v4 + a1 + 788)) + 124)) )
      {
        return v4;
      }
    }
  }
  return 0;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (00036D98) --------------------------------------------------------
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2)
{
  int v2; // eax
  int v3; // ebx
  int i; // esi
  int v5; // edx
  int v6; // eax
  int v8; // [esp+1Ch] [ebp-20Ch]
  int v9; // [esp+20h] [ebp-208h]
  int v10; // [esp+24h] [ebp-204h]
  int v11[64]; // [esp+28h] [ebp-200h] BYREF
  int s[64]; // [esp+128h] [ebp-100h] BYREF

  v9 = BG_AmmoForWeapon(a2);
  v8 = BG_ClipForWeapon(a2);
  _bzero(s, 0x100u);
  _bzero(v11, 0x100u);
  v10 = *(_DWORD *)(dword_7C91C + 4 * a2);
  v2 = *(_DWORD *)(v10 + 440);
  if ( v2 < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
      v3 = dword_A9C20[v8] - *(_DWORD *)(a1 + 4 * v8 + 524);
    else
      v3 = dword_A97E0[v9] - *(_DWORD *)(a1 + 4 * v9 + 268);
  }
  else
  {
    v3 = dword_A9A00[v2];
    for ( i = 1; i <= dword_7C918; ++i )
    {
      if ( !Com_BitCheck(a1 + 780, i) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * i) + 440) != *(_DWORD *)(v10 + 440) )
        continue;
      if ( BG_WeaponIsClipOnly(i) )
      {
        if ( !v11[BG_ClipForWeapon(i)] )
        {
          v11[BG_ClipForWeapon(i)] = 1;
          v5 = BG_ClipForWeapon(i);
          v6 = a1 + 524;
LABEL_10:
          v3 -= *(_DWORD *)(v6 + 4 * v5);
          continue;
        }
      }
      else if ( !s[BG_AmmoForWeapon(i)] )
      {
        s[BG_AmmoForWeapon(i)] = 1;
        v5 = BG_AmmoForWeapon(i);
        v6 = a1 + 268;
        goto LABEL_10;
      }
    }
  }
  return v3;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// A9A00: using guessed type int dword_A9A00[];

//----- (00036F60) --------------------------------------------------------
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2)
{
  int v2; // edi
  int i; // ebx
  int v4; // edx
  int v5; // eax
  int v7; // [esp+1Ch] [ebp-20Ch]
  int v8; // [esp+20h] [ebp-208h]
  int v9; // [esp+24h] [ebp-204h]
  _DWORD v10[64]; // [esp+28h] [ebp-200h] BYREF
  int s[64]; // [esp+128h] [ebp-100h] BYREF

  v8 = BG_AmmoForWeapon(a2);
  v7 = BG_ClipForWeapon(a2);
  _bzero(s, 0x100u);
  _bzero(v10, 0x100u);
  v2 = 0;
  v9 = *(_DWORD *)(dword_7C91C + 4 * a2);
  if ( *(int *)(v9 + 440) < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
      v2 = *(_DWORD *)(a1 + 524 + 4 * v7);
    else
      v2 = *(_DWORD *)(a1 + 268 + 4 * v8);
  }
  else
  {
    for ( i = 1; i <= dword_7C918; ++i )
    {
      if ( !Com_BitCheck(a1 + 780, i) || *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * i) + 440) != *(_DWORD *)(v9 + 440) )
        continue;
      if ( BG_WeaponIsClipOnly(i) )
      {
        if ( !v10[BG_ClipForWeapon(i)] )
        {
          v10[BG_ClipForWeapon(i)] = 1;
          v4 = BG_ClipForWeapon(i);
          v5 = a1 + 524;
LABEL_10:
          v2 += *(_DWORD *)(v5 + 4 * v4);
          continue;
        }
      }
      else if ( !s[BG_AmmoForWeapon(i)] )
      {
        s[BG_AmmoForWeapon(i)] = 1;
        v4 = BG_AmmoForWeapon(i);
        v5 = a1 + 268;
        goto LABEL_10;
      }
    }
  }
  return v2;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;

//----- (00037114) --------------------------------------------------------
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3)
{
  float *v3; // ebx
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  int v10; // eax
  long double result; // fst7
  long double v12; // fst7
  long double v13; // fst6
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int v18; // eax
  long double v19; // fst6
  long double v20; // fst5

  v3 = *(float **)(dword_7C91C + 4 * a2);
  v4 = (long double)*(int *)(a1 + 216);
  v6 = *(float *)(a1 + 208);
  v7 = v6 < v4;
  v8 = 0;
  v9 = v6 == v4;
  if ( (v5 & 0x45) != 64 && *(_DWORD *)(a1 + 212) )
  {
    v12 = (long double)(a3 - *(_DWORD *)(a1 + 212))
        / (long double)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
    v13 = 0.0;
    if ( v12 < 0.0 || (v13 = 1.0, v15 = v12 > 1.0, v16 = 0, v17 = 1.0 == v12, (v14 & 0x45) == 1) )
      v12 = v13;
    v18 = *(_DWORD *)(a1 + 216);
    if ( v18 == *(_DWORD *)(a1 + 828) )
    {
      v19 = v3[144];
      v20 = v3[145];
    }
    else if ( v18 == *(_DWORD *)(a1 + 836) )
    {
      v19 = v3[144];
      v20 = v3[143];
    }
    else
    {
      if ( *(_DWORD *)(a1 + 220) )
        v19 = v3[143];
      else
        v19 = v3[145];
      v20 = v3[144];
    }
    result = v12 * (v20 - v19) + v19;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 12);
    if ( (v10 & 1) != 0 )
    {
      result = v3[145];
    }
    else if ( (v10 & 2) != 0 )
    {
      result = v3[144];
    }
    else
    {
      result = v3[143];
    }
  }
  return result;
}
// 37144: variable 'v5' is possibly undefined
// 371B9: variable 'v14' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (00037230) --------------------------------------------------------
int PM_UpdateAimDownSightFlag()
{
  int v0; // edx
  int v1; // ecx
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int result; // eax

  v0 = pm;
  v1 = *(_DWORD *)pm;
  v2 = *(_DWORD *)(*(_DWORD *)pm + 4);
  if ( v2 > 5
    || (*(_BYTE *)(pm + 8) & 0x10) == 0
    || !*(_DWORD *)(LODWORD(pml[33]) + 716)
    || (v3 = *(_DWORD *)(v1 + 180), v3 == 2)
    || v3 == 1
    || v3 == 10
    || v3 == 11
    || !LODWORD(pml[12]) && v2 != 1 )
  {
    *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xDFu;
  }
  else
  {
    v4 = *(_DWORD *)(v1 + 12);
    if ( (v4 & 1) != 0 )
    {
      if ( (*(_BYTE *)(pm + 32) & 0x10) == 0 || !*(_WORD *)(pm + 24) )
      {
        LOBYTE(v4) = v4 | 0x20;
        *(_DWORD *)(v1 + 12) = v4;
        *(_BYTE *)(*(_DWORD *)v0 + 13) |= 4u;
      }
    }
    else
    {
      LOBYTE(v4) = v4 | 0x20;
      *(_DWORD *)(v1 + 12) = v4;
    }
  }
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 0x20) != 0 )
    result = BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm + 172), 7, 1, 1);
  else
    result = BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm + 172), 7, 0, 1);
  return result;
}
// 16EE30: using guessed type int pm;

//----- (000372FC) --------------------------------------------------------
__int16 PM_UpdateAimDownSightLerp()
{
  int v0; // edi
  float v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  __int16 v5; // fps
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  __int16 v10; // fps
  long double v11; // fst6
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst7
  long double v16; // fst7
  __int16 v17; // fps
  long double v18; // fst6
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst7
  __int16 v23; // fps
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  bool v27; // zf

  v0 = 0;
  v1 = pml[33];
  if ( !*(_DWORD *)(LODWORD(v1) + 716) )
  {
    v2 = *(_DWORD *)pm;
    *(_DWORD *)(*(_DWORD *)pm + 184) = 0;
    return v2;
  }
  if ( *(_DWORD *)(LODWORD(v1) + 748) )
  {
    v3 = pm;
    v4 = *(_DWORD *)(*(_DWORD *)pm + 180);
    if ( (unsigned int)(v4 - 5) > 3
      && (v4 != 9 || *(_DWORD *)(*(_DWORD *)pm + 44) - *(_DWORD *)(LODWORD(v1) + 980) <= 0) )
    {
LABEL_11:
      if ( (*(_BYTE *)(*(_DWORD *)v3 + 12) & 0x20) != 0 )
        v0 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    v3 = pm;
    if ( *(_DWORD *)(*(_DWORD *)pm + 180) != 5 || *(_DWORD *)(*(_DWORD *)pm + 44) - *(_DWORD *)(LODWORD(v1) + 980) <= 0 )
      goto LABEL_11;
  }
  v0 = 0;
LABEL_13:
  if ( *(_DWORD *)(LODWORD(v1) + 732) && *(_DWORD *)(*(_DWORD *)v3 + 48) && *(_DWORD *)(*(_DWORD *)v3 + 180) == 3 )
    v0 = 1;
  if ( v0 )
  {
    v6 = *(float *)(*(_DWORD *)v3 + 184);
    v7 = v6 < 1.0;
    v8 = 0;
    v9 = v6 == 1.0;
    LOBYTE(v2) = v5;
    BYTE1(v2) = HIBYTE(v5) & 0x44 ^ 0x40;
    if ( !BYTE1(v2) )
      return v2;
  }
  else
  {
    v11 = *(float *)(*(_DWORD *)v3 + 184);
    v12 = v11 < 0.0;
    v13 = 0;
    v14 = v11 == 0.0;
    LOBYTE(v2) = v10;
    BYTE1(v2) = HIBYTE(v10) & 0x45;
    if ( (HIBYTE(v10) & 0x45) == 64 )
      return v2;
  }
  if ( v0 )
    v15 = (long double)SLODWORD(pml[10]) * *(float *)(LODWORD(pml[33]) + 1044) + *(float *)(*(_DWORD *)pm + 184);
  else
    v15 = *(float *)(*(_DWORD *)pm + 184) - (long double)SLODWORD(pml[10]) * *(float *)(LODWORD(pml[33]) + 1048);
  *(float *)(*(_DWORD *)pm + 184) = v15;
  v16 = 1.0;
  v18 = *(float *)(*(_DWORD *)pm + 184);
  v19 = v18 < 1.0;
  v20 = 0;
  v21 = v18 == 1.0;
  LOBYTE(v2) = v17;
  BYTE1(v2) = HIBYTE(v17) & 5;
  if ( v18 >= 1.0 )
    goto LABEL_26;
  v22 = *(float *)(*(_DWORD *)pm + 184);
  v24 = v22 > 0.0;
  v25 = 0;
  v26 = 0.0 == v22;
  LOBYTE(v2) = v23;
  BYTE1(v2) = HIBYTE(v23) & 5;
  v27 = v22 <= 0.0;
  v16 = 0.0;
  if ( v27 )
LABEL_26:
    *(float *)(*(_DWORD *)pm + 184) = v16;
  return v2;
}
// 16EE30: using guessed type int pm;

//----- (00037488) --------------------------------------------------------
int PM_InteruptWeaponWithProneMove()
{
  int v0; // edx
  unsigned int v1; // eax

  v0 = pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( v1 <= 2 || v1 == 5 || v1 == 7 || v1 == 9 || v1 == 8 || v1 == 6 )
    return 1;
  if ( v1 == 3 || v1 == 11 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm + 44) = 0;
  *(_DWORD *)(*(_DWORD *)v0 + 48) = 0;
  *(_DWORD *)(*(_DWORD *)v0 + 180) = 0;
  sub_3AE30(0);
  return 1;
}
// 16EE30: using guessed type int pm;

//----- (00037500) --------------------------------------------------------
int sub_37500()
{
  int result; // eax
  int v1; // ebx
  float v2; // edi
  int v3; // eax
  int v4; // edx
  _DWORD *v5; // [esp+18h] [ebp-10h]
  unsigned int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  result = pm;
  v1 = *(_DWORD *)pm;
  v6 = *(_DWORD *)(*(_DWORD *)pm + 180) - 7;
  v5 = (_DWORD *)pm;
  v2 = pml[33];
  if ( v6 > 1 || *(_DWORD *)(LODWORD(v2) + 756) )
  {
    v3 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v1 + 176));
    v8 = *(_DWORD *)(v3 + 416);
    v7 = *(_DWORD *)(v3 + 424);
    v4 = dword_A9C20[v7] - *(_DWORD *)(4 * v7 + v1 + 524);
    if ( v4 > *(_DWORD *)(v1 + 268 + 4 * v8) )
      v4 = *(_DWORD *)(v1 + 268 + 4 * v8);
    if ( v6 > 1 )
    {
      result = *(_DWORD *)(LODWORD(v2) + 752);
      if ( !result )
      {
LABEL_11:
        if ( v4 )
        {
          *(_DWORD *)(*(_DWORD *)pm + 268 + 4 * v8) -= v4;
          result = *v5 + 524;
          *(_DWORD *)(result + 4 * v7) += v4;
        }
        return result;
      }
    }
    else
    {
      result = *(_DWORD *)(LODWORD(v2) + 756);
    }
    if ( result < dword_A9C20[v7] && v4 > result )
      v4 = result;
    goto LABEL_11;
  }
  return result;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000375D0) --------------------------------------------------------
int __cdecl sub_375D0(int a1)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int v5; // eax
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  int v10; // eax
  int v11; // ebx
  float v12; // eax
  int v13; // ecx

  if ( *(_DWORD *)(LODWORD(pml[33]) + 712) && Com_BitCheck(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176)) )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm + 180) == 4 )
    {
      if ( a1 )
      {
        Com_BitClear(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176));
        PM_AddEvent(163);
        if ( *(_DWORD *)(*(_DWORD *)pm + 44) )
          return 1;
      }
    }
    v2 = *(_DWORD *)pm;
    if ( !*(_DWORD *)(*(_DWORD *)pm + 44)
      || (v3 = *(_DWORD *)(v2 + 180), (unsigned int)(v3 - 3) > 1) && v3 != 10 && v3 != 11 && !*(_DWORD *)(v2 + 48) )
    {
      v4 = *(_DWORD *)(v2 + 180);
      if ( v4 == 4 )
      {
        if ( *(_BYTE *)(pm + 10) && (*(_DWORD *)(v2 + 980) & 0xFFFFFDFF) != 0 && *(int *)(v2 + 4) <= 5 )
        {
          v5 = *(_DWORD *)(v2 + 980) & 0x200;
          BYTE1(v5) ^= 2u;
          *(_DWORD *)(v2 + 980) = v5;
        }
        *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
        return 0;
      }
      if ( !v4 )
      {
        v7 = *(float *)(v2 + 184) > 0.75;
        v8 = 0;
        v9 = 0.75 == *(float *)(v2 + 184);
        if ( (v6 & 0x45) == 1 )
        {
          if ( *(int *)(v2 + 4) > 5 || !*(_BYTE *)(pm + 10) )
            goto LABEL_27;
          v10 = *(_DWORD *)(v2 + 980) & 0x200;
          BYTE1(v10) ^= 2u;
          LOBYTE(v10) = 7;
        }
        else
        {
          if ( *(int *)(v2 + 4) > 5 || !*(_BYTE *)(pm + 10) )
            goto LABEL_27;
          v10 = *(_DWORD *)(v2 + 980) & 0x200;
          BYTE1(v10) ^= 2u;
          LOBYTE(v10) = 4;
        }
        *(_DWORD *)(v2 + 980) = v10;
LABEL_27:
        v11 = pm;
        *(_DWORD *)(*(_DWORD *)pm + 180) = 4;
        *(_DWORD *)(*(_DWORD *)v11 + 44) = *(_DWORD *)(LODWORD(pml[33]) + 472);
        v12 = pml[33];
        v13 = *(_DWORD *)(LODWORD(v12) + 476);
        if ( v13 && v13 < *(_DWORD *)(LODWORD(v12) + 472) )
          *(_DWORD *)(*(_DWORD *)v11 + 48) = v13;
        else
          *(_DWORD *)(*(_DWORD *)pm + 48) = 1;
        PM_AddEvent(162);
        return 0;
      }
    }
  }
  return 0;
}
// 37706: variable 'v6' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (000377B8) --------------------------------------------------------
int sub_377B8()
{
  int result; // eax
  float v1; // ecx
  int v2; // edx
  int v3; // ebx

  if ( (unsigned int)(*(_DWORD *)(*(_DWORD *)pm + 180) - 7) > 1 )
  {
    v1 = pml[33];
    if ( *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176)) + 424)
                   + *(_DWORD *)pm
                   + 524)
      || *(_DWORD *)(LODWORD(v1) + 112) )
    {
      v3 = *(_DWORD *)(LODWORD(v1) + 488);
    }
    else
    {
      v3 = *(_DWORD *)(LODWORD(v1) + 492);
    }
    result = *(_DWORD *)(LODWORD(v1) + 496);
    if ( result && result < v3 )
      v3 = *(_DWORD *)(LODWORD(v1) + 496);
  }
  else
  {
    result = LODWORD(pml[33]);
    v1 = *(float *)&result;
    v2 = *(_DWORD *)(result + 504);
    if ( v2 )
    {
      v3 = *(_DWORD *)(result + 500);
      if ( v2 < v3 )
        v3 = *(_DWORD *)(result + 504);
    }
    else
    {
      v3 = 0;
    }
  }
  if ( *(_DWORD *)(LODWORD(v1) + 712)
    && (result = Com_BitCheck(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176))) != 0 )
  {
    if ( !v3 )
      v3 = *(_DWORD *)(*(_DWORD *)pm + 44);
    if ( *(_DWORD *)(LODWORD(pml[33]) + 476) >= v3 )
      v3 = 1;
    else
      v3 = *(_DWORD *)(LODWORD(pml[33]) + 476);
    if ( !v3 )
      v3 = 1;
    result = *(_DWORD *)pm;
  }
  else
  {
    if ( !v3 )
      return result;
    result = *(_DWORD *)pm;
  }
  *(_DWORD *)(result + 48) = v3;
  return result;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000378BC) --------------------------------------------------------
int sub_378BC()
{
  int v0; // ecx
  int v1; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax

  v0 = *(_DWORD *)pm;
  if ( *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176)) + 424)
                 + *(_DWORD *)pm
                 + 524)
    || *(_DWORD *)(LODWORD(pml[33]) + 112) )
  {
    v2 = *(_DWORD *)pm;
    if ( *(int *)(*(_DWORD *)pm + 4) <= 5 && *(_BYTE *)(pm + 10) )
    {
      v3 = *(_DWORD *)(v2 + 980) & 0x200;
      BYTE1(v3) ^= 2u;
      LOBYTE(v3) = 11;
      *(_DWORD *)(v2 + 980) = v3;
    }
    *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(pml[33]) + 488);
    PM_AddEvent(151);
  }
  else
  {
    if ( *(int *)(v0 + 4) <= 5 && *(_BYTE *)(pm + 10) )
    {
      v1 = *(_DWORD *)(v0 + 980) & 0x200;
      BYTE1(v1) ^= 2u;
      LOBYTE(v1) = 12;
      *(_DWORD *)(v0 + 980) = v1;
    }
    *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(pml[33]) + 492);
    PM_AddEvent(152);
  }
  v4 = *(_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 180) == 8 )
    *(_DWORD *)(v4 + 180) = 6;
  else
    *(_DWORD *)(v4 + 180) = 5;
  return sub_377B8();
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000379B8) --------------------------------------------------------
int sub_379B8()
{
  int result; // eax
  int v1; // ecx
  float v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // ecx

  result = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( !result || result == 3 || result == 4 )
  {
    result = *(_DWORD *)pm;
    v1 = *(_DWORD *)(*(_DWORD *)pm + 176);
    if ( v1 )
    {
      if ( v1 <= dword_7C918 )
      {
        if ( !*(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v1) + 724) )
          BG_AnimScriptEvent(*(_DWORD **)pm, 10, 0, 1);
        v2 = pml[33];
        if ( *(_DWORD *)(LODWORD(v2) + 748) && *(_DWORD *)(LODWORD(v2) + 500) )
        {
          v3 = *(_DWORD *)pm;
          if ( *(int *)(*(_DWORD *)pm + 4) <= 5 )
          {
            if ( *(_BYTE *)(pm + 10) )
            {
              v4 = *(_DWORD *)(v3 + 980) & 0x200;
              BYTE1(v4) ^= 2u;
              LOBYTE(v4) = 13;
              *(_DWORD *)(v3 + 980) = v4;
            }
          }
          v5 = pm;
          *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(pml[33]) + 500);
          *(_DWORD *)(*(_DWORD *)v5 + 180) = 7;
          PM_AddEvent(153);
          result = sub_377B8();
        }
        else
        {
          result = sub_378BC();
        }
      }
    }
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00037A9C) --------------------------------------------------------
void __cdecl sub_37A9C(int a1, int a2)
{
  _DWORD *v2; // edx
  int v3; // edx
  int v4; // edx
  _BOOL4 v5; // esi
  _DWORD *v6; // ebx
  _BOOL4 v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // eax
  int v11; // esi
  int v12; // ebx
  int v13; // ecx
  int v14; // ebx
  unsigned int v15; // eax
  int v16; // esi
  unsigned int v17; // eax

  if ( a2 < 0 || a2 > dword_7C918 || a2 && !Com_BitCheck(*(_DWORD *)pm + 780, a2) )
    return;
  v2 = (_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 180) == 2 )
    return;
  *(_DWORD *)(*(_DWORD *)pm + 48) = 0;
  if ( !a1 || !Com_BitCheck(*v2 + 780, a1) || (v3 = *(_DWORD *)pm, *(int *)(*(_DWORD *)pm + 52) > 0) )
  {
    v4 = pm;
    *(_DWORD *)(*(_DWORD *)pm + 44) = 0;
    *(_DWORD *)(*(_DWORD *)v4 + 180) = 2;
    *(_DWORD *)(*(_DWORD *)v4 + 52) = 0;
    PM_SetProneMovementOverride();
    return;
  }
  v5 = 0;
  v6 = *(_DWORD **)(dword_7C91C + 4 * a1);
  if ( a2 )
    v5 = a2 == v6[191];
  v7 = 1;
  if ( v6[181] )
    v7 = *(_DWORD *)(4 * v6[106] + v3 + 524) != 0;
  *(_DWORD *)(v3 + 52) = 0;
  if ( v5 )
  {
    PM_AddEvent(157);
    v8 = *(_DWORD *)pm;
    if ( *(int *)(*(_DWORD *)pm + 4) > 5 || !*(_BYTE *)(pm + 10) )
      goto LABEL_23;
    v9 = *(_DWORD *)(v8 + 980) & 0x200;
    BYTE1(v9) ^= 2u;
    LOBYTE(v9) = 15;
  }
  else
  {
    if ( !v7 )
      goto LABEL_23;
    PM_AddEvent(156);
    v8 = *(_DWORD *)pm;
    if ( *(int *)(*(_DWORD *)pm + 4) > 5 || !*(_BYTE *)(pm + 10) )
      goto LABEL_23;
    v9 = *(_DWORD *)(v8 + 980) & 0x200;
    BYTE1(v9) ^= 2u;
    LOBYTE(v9) = 9;
  }
  *(_DWORD *)(v8 + 980) = v9;
LABEL_23:
  if ( !v5 )
    BG_AnimScriptEvent(*(_DWORD **)pm, 6, 0, 0);
  *(_DWORD *)(*(_DWORD *)pm + 180) = 2;
  PM_SetProneMovementOverride();
  if ( v5 )
    v10 = v6[130];
  else
    v10 = v6[128];
  *(_DWORD *)(*(_DWORD *)pm + 44) = v10;
  if ( v5 )
  {
    v11 = *(_DWORD *)pm;
    if ( Com_BitCheck(*(_DWORD *)pm + 780, a1) )
    {
      v13 = a1;
      do
      {
        v14 = *(_DWORD *)(dword_7C91C + 4 * v13);
        v15 = *(_DWORD *)(v14 + 120);
        if ( !v15 )
          return;
        if ( v15 > 2 )
        {
          if ( v15 > 5 )
            return;
          if ( *(char *)(*(_DWORD *)(v14 + 120) + v11 + 788) == v13 )
          {
            v12 = *(_DWORD *)(v14 + 120);
            goto LABEL_45;
          }
        }
        else
        {
          if ( *(char *)(v11 + 789) == v13 )
          {
            v12 = 1;
            goto LABEL_46;
          }
          if ( *(char *)(v11 + 790) == v13 )
          {
            v12 = 2;
            goto LABEL_46;
          }
        }
        if ( *(_DWORD *)(v14 + 764) )
          v13 = *(_DWORD *)(v14 + 764);
      }
      while ( v13 != a1 );
      v12 = 0;
LABEL_45:
      if ( !v12 )
        return;
LABEL_46:
      v16 = *(_DWORD *)pm;
      if ( Com_BitCheck(*(_DWORD *)pm + 780, a2) )
      {
        v17 = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a2) + 120);
        if ( v17 )
        {
          if ( v17 <= 2 )
          {
            if ( (unsigned int)(v12 - 1) > 1 )
              return;
            goto LABEL_53;
          }
          if ( v17 <= 5 && v12 == v17 )
          {
LABEL_53:
            *(_BYTE *)(v12 + v16 + 788) = a2;
            return;
          }
        }
      }
    }
  }
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00037D84) --------------------------------------------------------
int sub_37D84()
{
  int v0; // ebx
  _BYTE *v1; // ecx
  int v2; // esi
  int v3; // edx
  int v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  _BOOL4 v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // edx
  int v13; // eax
  _BYTE *v14; // edx
  int v15; // ecx
  int v16; // eax

  if ( *(_DWORD *)(*(_DWORD *)pm + 180) != 2 )
    return 0;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 0x10) != 0
    || !Com_BitCheck(*(_DWORD *)pm + 780, *(unsigned __int8 *)(pm + 10))
    || (v0 = *(unsigned __int8 *)(pm + 10), v0 > dword_7C918) )
  {
    v0 = 0;
  }
  if ( !Com_BitCheck(*(_DWORD *)pm + 780, v0) )
    v0 = 0;
  v1 = (_BYTE *)pm;
  v2 = *(_DWORD *)(*(_DWORD *)pm + 176);
  *(_DWORD *)(*(_DWORD *)pm + 176) = v0;
  v3 = dword_7C91C;
  pml[33] = *(float *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)v1 + 176));
  if ( v2 == v0 )
  {
    *(_DWORD *)(*(_DWORD *)v1 + 180) = 0;
    v4 = *(_DWORD *)v1;
    if ( *(int *)(*(_DWORD *)v1 + 4) <= 5 )
    {
      if ( v1[10] )
      {
        v5 = *(_DWORD *)(v4 + 980) & 0x200;
        BYTE1(v5) ^= 2u;
        *(_DWORD *)(v4 + 980) = v5;
      }
    }
  }
  else if ( v2 )
  {
    *(_DWORD *)(*(_DWORD *)v1 + 180) = 1;
    PM_SetProneMovementOverride();
    v9 = 0;
    if ( v0 )
      v9 = v0 == *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v2) + 764);
    if ( v9 )
    {
      v10 = *(_DWORD *)pm;
      v11 = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v0) + 524);
    }
    else
    {
      PM_AddEvent(155);
      v10 = *(_DWORD *)pm;
      v11 = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v0) + 516);
    }
    *(_DWORD *)(v10 + 44) = v11;
    BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm + 172), 0, v0, 1);
    BG_UpdateConditionValue(
      *(_DWORD *)(*(_DWORD *)pm + 172),
      1,
      *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v0) + 116),
      1);
    if ( v0 && v0 == *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v2) + 764) )
    {
      if ( *(float *)(*(_DWORD *)pm + 984) < 128.0 )
        *(float *)(*(_DWORD *)pm + 984) = 128.0;
      v12 = *(_DWORD *)pm;
      if ( *(int *)(*(_DWORD *)pm + 4) <= 5 && *(_BYTE *)(pm + 10) )
      {
        v13 = *(_DWORD *)(v12 + 980) & 0x200;
        BYTE1(v13) ^= 2u;
        LOBYTE(v13) = 16;
        *(_DWORD *)(v12 + 980) = v13;
      }
    }
    else
    {
      BG_AnimScriptEvent(*(_DWORD **)pm, 7, 0, 0);
      v14 = (_BYTE *)pm;
      *(float *)(*(_DWORD *)pm + 984) = 255.0;
      v15 = *(_DWORD *)v14;
      if ( *(int *)(*(_DWORD *)v14 + 4) <= 5 && v14[10] )
      {
        v16 = *(_DWORD *)(v15 + 980) & 0x200;
        BYTE1(v16) ^= 2u;
        LOBYTE(v16) = 10;
        *(_DWORD *)(v15 + 980) = v16;
      }
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)v1 + 180) = 1;
    *(_DWORD *)(*(_DWORD *)v1 + 44) = *(_DWORD *)(*(_DWORD *)(v3 + 4 * v0) + 516);
    *(float *)(*(_DWORD *)v1 + 984) = 255.0;
    v6 = *(_DWORD *)v1;
    if ( *(int *)(*(_DWORD *)v1 + 4) <= 5 && v1[10] )
    {
      v7 = *(_DWORD *)(v6 + 980) & 0x200;
      BYTE1(v7) ^= 2u;
      LOBYTE(v7) = 10;
      *(_DWORD *)(v6 + 980) = v7;
    }
    PM_SetProneMovementOverride();
  }
  return 1;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (0003803C) --------------------------------------------------------
int sub_3803C()
{
  int v0; // eax
  int v1; // edx
  int v2; // ecx
  int v3; // eax
  float v4; // edx
  int v5; // edx

  v0 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176));
  v1 = *(_DWORD *)(v0 + 424);
  if ( *(_DWORD *)(4 * *(_DWORD *)(v0 + 416) + *(_DWORD *)pm + 268) )
  {
    v2 = dword_A9C20[v1];
    v3 = *(_DWORD *)(4 * v1 + *(_DWORD *)pm + 524);
    if ( v3 < v2 )
    {
      v4 = pml[33];
      if ( !*(_DWORD *)(LODWORD(v4) + 744) )
        return 1;
      v5 = *(_DWORD *)(LODWORD(v4) + 752);
      if ( v5 && v5 < v2 )
      {
        if ( v2 - v3 >= v5 )
          return 1;
      }
      else if ( !v3 )
      {
        return 1;
      }
    }
  }
  return 0;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000380C0) --------------------------------------------------------
int sub_380C0()
{
  int v0; // ebx
  int v1; // edx
  unsigned int v2; // edx
  bool v3; // cf
  int result; // eax
  float v5; // eax
  float v6; // ecx
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // edx

  if ( !*(_DWORD *)(LODWORD(pml[33]) + 712) || !Com_BitCheck(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176)) )
    return sub_37500();
  Com_BitClear(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176));
  PM_AddEvent(163);
  v0 = *(_DWORD *)pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 180);
  v3 = v1 == 7;
  v2 = v1 - 7;
  if ( !v3 && v2 != 1 || (result = LODWORD(pml[33]), *(_DWORD *)(result + 504)) )
  {
    if ( *(_DWORD *)(v0 + 44) )
    {
      if ( v2 > 1 )
      {
        v6 = pml[33];
        if ( *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v0 + 176)) + 424) + v0 + 524)
          || *(_DWORD *)(LODWORD(v6) + 112) )
        {
          v7 = *(_DWORD *)(LODWORD(v6) + 488);
        }
        else
        {
          v7 = *(_DWORD *)(LODWORD(v6) + 492);
        }
        v8 = *(_DWORD *)(LODWORD(v6) + 496);
        if ( v8 && v8 < v7 )
          v7 = *(_DWORD *)(LODWORD(v6) + 496);
      }
      else
      {
        v5 = pml[33];
        v6 = v5;
        v7 = *(_DWORD *)(LODWORD(v5) + 500);
        if ( *(_DWORD *)(LODWORD(v5) + 504) < v7 )
          v7 = *(_DWORD *)(LODWORD(v5) + 504);
      }
      v9 = *(_DWORD *)(LODWORD(v6) + 476);
      v10 = 1;
      if ( v9 < v7 )
        v10 = v9;
      v11 = v7 - v10;
      if ( v11 > 0 )
      {
        result = *(_DWORD *)pm;
        *(_DWORD *)(*(_DWORD *)pm + 48) = v11;
        return result;
      }
    }
    return sub_37500();
  }
  return result;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (0003820C) --------------------------------------------------------
_BOOL4 __cdecl sub_3820C(int a1)
{
  _BYTE *v1; // ecx
  int v2; // ebx
  int v3; // edx
  int v4; // ecx
  _BYTE *v5; // edx
  int v6; // ecx
  int v7; // eax
  _BYTE *v8; // edx
  int v9; // ecx
  int v10; // eax
  int v12; // edx
  int v13; // eax
  _BYTE *v14; // edx
  int v15; // ecx
  int v16; // eax
  _BYTE *v17; // edx
  int v18; // ecx
  int v19; // eax

  v1 = (_BYTE *)pm;
  v2 = *(_DWORD *)pm;
  v3 = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( (unsigned int)(v3 - 7) > 1 )
  {
    if ( v3 == 9 )
    {
      *(_DWORD *)(v2 + 180) = 0;
      v12 = *(_DWORD *)v1;
      if ( *(int *)(*(_DWORD *)v1 + 4) <= 5 && v1[10] )
      {
        v13 = *(_DWORD *)(v12 + 980) & 0x200;
        BYTE1(v13) ^= 2u;
        *(_DWORD *)(v12 + 980) = v13;
      }
      return 0;
    }
    if ( (unsigned int)(v3 - 5) > 1 )
      return 0;
    if ( a1 )
    {
      sub_380C0();
      if ( *(_DWORD *)(*(_DWORD *)pm + 44) )
        return 1;
    }
    else if ( *(_DWORD *)(v2 + 44) )
    {
      return a1 != 0;
    }
    Com_BitClear(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176));
    if ( *(_DWORD *)(LODWORD(pml[33]) + 748) )
    {
      if ( *(_DWORD *)(*(_DWORD *)pm + 180) != 6 && sub_3803C() )
      {
LABEL_29:
        sub_378BC();
        return 1;
      }
      if ( *(_DWORD *)(LODWORD(pml[33]) + 508) )
      {
        v14 = (_BYTE *)pm;
        *(_DWORD *)(*(_DWORD *)pm + 180) = 9;
        v15 = *(_DWORD *)v14;
        if ( *(int *)(*(_DWORD *)v14 + 4) <= 5 && v14[10] )
        {
          v16 = *(_DWORD *)(v15 + 980) & 0x200;
          BYTE1(v16) ^= 2u;
          LOBYTE(v16) = 14;
          *(_DWORD *)(v15 + 980) = v16;
        }
        *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(pml[33]) + 508);
        PM_AddEvent(154);
        return 1;
      }
    }
    v17 = (_BYTE *)pm;
    *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
    v18 = *(_DWORD *)v17;
    if ( *(int *)(*(_DWORD *)v17 + 4) <= 5 && v17[10] )
    {
      v19 = *(_DWORD *)(v18 + 980) & 0x200;
      BYTE1(v19) ^= 2u;
      *(_DWORD *)(v18 + 980) = v19;
    }
    return a1 != 0;
  }
  if ( a1 )
    sub_380C0();
  v4 = *(_DWORD *)pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 44) )
    return 1;
  if ( (*(_DWORD *)(v4 + 180) != 8
     || !*(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v4 + 176)) + 424) + v4 + 524))
    && sub_3803C() )
  {
    goto LABEL_29;
  }
  Com_BitClear(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176));
  if ( *(_DWORD *)(LODWORD(pml[33]) + 508) )
  {
    v5 = (_BYTE *)pm;
    *(_DWORD *)(*(_DWORD *)pm + 180) = 9;
    v6 = *(_DWORD *)v5;
    if ( *(int *)(*(_DWORD *)v5 + 4) <= 5 )
    {
      if ( v5[10] )
      {
        v7 = *(_DWORD *)(v6 + 980) & 0x200;
        BYTE1(v7) ^= 2u;
        LOBYTE(v7) = 14;
        *(_DWORD *)(v6 + 980) = v7;
      }
    }
    *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(pml[33]) + 508);
    PM_AddEvent(154);
    return 1;
  }
  v8 = (_BYTE *)pm;
  *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
  v9 = *(_DWORD *)v8;
  if ( *(int *)(*(_DWORD *)v8 + 4) <= 5 && v8[10] )
  {
    v10 = *(_DWORD *)(v9 + 980) & 0x200;
    BYTE1(v10) ^= 2u;
    *(_DWORD *)(v9 + 980) = v10;
  }
  return 0;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000384D8) --------------------------------------------------------
int sub_384D8()
{
  int v0; // edi
  int v1; // ecx
  int v2; // eax
  int result; // eax
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // edx
  int v8; // [esp+14h] [ebp-4h]

  v8 = *(_BYTE *)(pm + 9) & 8;
  v0 = 0;
  if ( *(_DWORD *)(LODWORD(pml[33]) + 748) )
  {
    v1 = *(_DWORD *)pm;
    v2 = *(_DWORD *)(*(_DWORD *)pm + 180);
    if ( (v2 == 7 || v2 == 5) && (*(_BYTE *)(pm + 8) & 1) != 0 && (*(_BYTE *)(pm + 32) & 1) == 0 )
    {
      if ( v2 == 7 )
        *(_DWORD *)(v1 + 180) = 8;
      else
        *(_DWORD *)(v1 + 180) = 6;
    }
  }
  result = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( result < 1 || result > 2 && (result > 11 || result < 5) )
  {
    v4 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176));
    v5 = *(_DWORD *)(v4 + 424);
    v6 = *(_DWORD *)(v4 + 416);
    if ( v8 && sub_3803C() )
      v0 = 1;
    v7 = *(_DWORD *)pm;
    result = *(_DWORD *)pm + 524;
    if ( !*(_DWORD *)(result + 4 * v5) )
    {
      result = v7 + 268;
      if ( *(_DWORD *)(v7 + 268 + 4 * v6) )
      {
        if ( *(_DWORD *)(v7 + 180) != 3 && ((*(_BYTE *)(v7 + 12) & 1) == 0 || !*(_WORD *)(pm + 24)) )
          v0 = 1;
      }
    }
    if ( v0 )
      result = sub_379B8();
  }
  return result;
}
// 38534: conditional instruction was optimized away because of 'eax.4==5'
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (000385E8) --------------------------------------------------------
__int16 PM_AdjustAimSpreadScale()
{
  float v0; // ebx
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  int v7; // ecx
  int v8; // eax
  char v9; // fps^1
  long double v10; // fst6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double v14; // fst7
  long double v15; // fst7
  char v16; // fps^1
  long double v17; // fst6
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  int v21; // ebx
  char v22; // fps^1
  long double v23; // fst5
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  int v27; // ebx
  long double v28; // fst5
  long double v29; // fst7
  long double v30; // fst6
  int v31; // edx
  __int16 v32; // fps
  long double v33; // fst5
  bool v34; // c0
  char v35; // c2
  bool v36; // c3
  __int16 result; // ax
  __int16 v38; // fps
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  float v42; // [esp-10h] [ebp-58h]
  float v43; // [esp-Ch] [ebp-54h]
  float v44; // [esp+34h] [ebp-14h]

  v0 = pml[33];
  v2 = *(float *)(LODWORD(v0) + 588);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  v6 = v2;
  if ( (v1 & 0x45) == 64 )
  {
    v14 = 0.0;
    v44 = 1.0;
    v7 = pm;
    goto LABEL_23;
  }
  v7 = pm;
  if ( *(_DWORD *)(*(_DWORD *)pm + 84) != 1023 || *(_DWORD *)(*(_DWORD *)pm + 4) == 1 )
  {
    v8 = *(_DWORD *)(*(_DWORD *)pm + 128);
    if ( (v8 & 0x40) != 0 )
    {
      v6 = v2 * *(float *)(LODWORD(v0) + 608);
    }
    else if ( (v8 & 0x20) != 0 )
    {
      v6 = v2 * *(float *)(LODWORD(v0) + 604);
    }
  }
  else
  {
    v6 = v2 * 0.5;
  }
  v44 = v6 * pml[9];
  v10 = *(float *)(*(_DWORD *)pm + 184);
  v11 = v10 < 1.0;
  v12 = 0;
  v13 = v10 == 1.0;
  if ( (v9 & 0x44) == 0x40 )
  {
    v14 = 0.0;
LABEL_23:
    v30 = v14;
    v29 = 255.0;
    goto LABEL_24;
  }
  v15 = 0.0;
  v17 = *(float *)(LODWORD(v0) + 596);
  v18 = v17 < 0.0;
  v19 = 0;
  v20 = v17 == 0.0;
  if ( (v16 & 0x45) != 64 )
  {
    v21 = 0;
    do
    {
      v43 = (long double)*(int *)(4 * v21 + pm + 36) * 0.0054931641;
      v42 = (long double)*(int *)(4 * v21++ + pm + 12) * 0.0054931641;
      v15 = fabs(AngleSubtract(v42, v43)) * 0.0099999998 * *(float *)(LODWORD(pml[33]) + 596) / pml[9] + v15;
    }
    while ( v21 <= 1 );
  }
  v7 = pm;
  v23 = *(float *)(LODWORD(pml[33]) + 600);
  v24 = v23 < 0.0;
  v25 = 0;
  v26 = v23 == 0.0;
  if ( (v22 & 0x45) != 64 && *(_WORD *)(pm + 24) )
    v15 = v15 + v23;
  if ( *(_DWORD *)(*(_DWORD *)pm + 84) == 1023 && *(_DWORD *)(*(_DWORD *)pm + 4) != 1 )
  {
    v27 = 1;
    do
    {
      v15 = v15 + 1.28;
      --v27;
    }
    while ( v27 >= 0 );
  }
  v28 = v15;
  v29 = 255.0;
  v30 = pml[9] * v28;
LABEL_24:
  *(float *)(*(_DWORD *)v7 + 984) = (v30 - v44) * v29 + *(float *)(*(_DWORD *)v7 + 984);
  v31 = *(_DWORD *)v7;
  v33 = *(float *)(*(_DWORD *)v7 + 984);
  v34 = v33 < 0.0;
  v35 = 0;
  v36 = v33 == 0.0;
  LOBYTE(result) = v32;
  HIBYTE(result) = HIBYTE(v32) & 0x45;
  if ( (HIBYTE(v32) & 0x45) == 1 )
  {
    *(float *)(v31 + 984) = 0.0;
  }
  else
  {
    v39 = v33 < v29;
    v40 = 0;
    v41 = v33 == v29;
    LOBYTE(result) = v38;
    HIBYTE(result) = HIBYTE(v38) & 0x45;
    if ( v33 > v29 )
      *(float *)(v31 + 984) = v29;
  }
  return result;
}
// 38602: variable 'v1' is possibly undefined
// 38665: variable 'v9' is possibly undefined
// 38680: variable 'v16' is possibly undefined
// 38708: variable 'v22' is possibly undefined
// 16EE30: using guessed type int pm;

//----- (000387C0) --------------------------------------------------------
int sub_387C0()
{
  _BYTE *v0; // ebx
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int v10; // eax

  v0 = (_BYTE *)pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 44);
  if ( v1 )
  {
    *(_DWORD *)(*(_DWORD *)pm + 44) = v1 - LODWORD(pml[10]);
    v2 = *(_DWORD *)v0;
    if ( *(int *)(*(_DWORD *)v0 + 44) <= 0 )
    {
      if ( !*(_DWORD *)(LODWORD(pml[33]) + 708)
        || (v0[8] & 1) == 0
        || (v3 = *(_DWORD *)(v2 + 176), v3 != (unsigned __int8)v0[10])
        || !*(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * v3) + 424) + v2 + 524) )
      {
        *(_DWORD *)(*(_DWORD *)pm + 44) = 0;
        goto LABEL_21;
      }
      *(_DWORD *)(v2 + 44) = 1;
      v4 = *(_DWORD *)v0;
      v5 = *(_DWORD *)(*(_DWORD *)v0 + 180);
      if ( v5 == 4 )
      {
        if ( v0[10] && (*(_DWORD *)(v4 + 980) & 0xFFFFFDFF) != 0 && *(int *)(v4 + 4) <= 5 )
        {
          v6 = *(_DWORD *)(v4 + 980) & 0x200;
          BYTE1(v6) ^= 2u;
          *(_DWORD *)(v4 + 980) = v6;
        }
LABEL_19:
        *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
        goto LABEL_21;
      }
      if ( (unsigned int)(v5 - 3) <= 1 || v5 == 10 || v5 == 11 )
      {
        if ( *(_BYTE *)(pm + 10) )
        {
          v7 = *(_DWORD *)pm;
          if ( (*(_DWORD *)(*(_DWORD *)pm + 980) & 0xFFFFFDFF) != 0 && *(int *)(v7 + 4) <= 5 )
          {
            v8 = *(_DWORD *)(*(_DWORD *)pm + 980) & 0x200;
            BYTE1(v8) ^= 2u;
            *(_DWORD *)(v7 + 980) = v8;
          }
        }
        goto LABEL_19;
      }
    }
  }
LABEL_21:
  v9 = pm;
  v10 = *(_DWORD *)(*(_DWORD *)pm + 48);
  if ( !v10 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm + 48) = v10 - LODWORD(pml[10]);
  if ( *(int *)(*(_DWORD *)v9 + 48) > 0 )
    return 0;
  *(_DWORD *)(*(_DWORD *)v9 + 48) = 0;
  return 1;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00038918) --------------------------------------------------------
void sub_38918()
{
  int v0; // ebx
  int v1; // ecx
  int v2; // edx
  int v3; // eax
  int v4; // edx
  int v5; // eax

  v0 = *(_DWORD *)pm;
  v1 = pm;
  if ( !*(_DWORD *)(*(_DWORD *)pm + 44)
    || (v2 = *(_DWORD *)(v0 + 180), v2 == 5)
    || v2 == 7
    || v2 == 9
    || v2 == 8
    || v2 == 6
    || v2 == 4
    || (unsigned int)(v2 - 3) > 1 && v2 != 10 && v2 != 11 && !*(_DWORD *)(v0 + 48) )
  {
    v3 = *(_DWORD *)pm;
    v4 = *(_DWORD *)(*(_DWORD *)pm + 12);
    if ( (v4 & 0x10) != 0 )
    {
      if ( !*(_DWORD *)(v3 + 176) )
        return;
LABEL_23:
      sub_37A9C(*(_DWORD *)(*(_DWORD *)pm + 176), 0);
      return;
    }
    v5 = *(_DWORD *)(v3 + 176);
    if ( v5 != *(unsigned __int8 *)(pm + 10) )
    {
      if ( (v4 & 0x4000) != 0 && v5 )
        goto LABEL_22;
      if ( !*(_BYTE *)(pm + 10) || Com_BitCheck(*(_DWORD *)pm + 780, *(unsigned __int8 *)(pm + 10)) )
      {
        sub_37A9C(*(_DWORD *)(*(_DWORD *)pm + 176), *(unsigned __int8 *)(pm + 10));
        return;
      }
    }
    v1 = pm;
    if ( !*(_DWORD *)(*(_DWORD *)pm + 176) )
      return;
LABEL_22:
    if ( Com_BitCheck(*(_DWORD *)v1 + 780, *(_DWORD *)(*(_DWORD *)v1 + 176)) )
      return;
    goto LABEL_23;
  }
}
// 16EE30: using guessed type int pm;

//----- (00038A44) --------------------------------------------------------
int __cdecl sub_38A44(int a1)
{
  float v1; // esi
  _BYTE *v2; // ebx
  int v3; // edx
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  float v7; // eax

  v1 = pml[33];
  if ( *(_DWORD *)(LODWORD(v1) + 112) == 1 )
  {
    if ( !a1 )
    {
      v2 = (_BYTE *)pm;
      if ( *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176)) + 424)
                     + *(_DWORD *)pm
                     + 524) )
      {
        *(_DWORD *)(*(_DWORD *)pm + 52) = *(_DWORD *)(LODWORD(v1) + 528);
        v3 = *(_DWORD *)v2;
        if ( *(int *)(*(_DWORD *)v2 + 4) <= 5 && v2[10] )
        {
          v4 = *(_DWORD *)(v3 + 980) & 0x200;
          BYTE1(v4) ^= 2u;
          LOBYTE(v4) = 17;
          *(_DWORD *)(v3 + 980) = v4;
        }
        PM_AddEvent(158);
      }
      v5 = pm;
      *(_DWORD *)(*(_DWORD *)pm + 48) = *(_DWORD *)(LODWORD(pml[33]) + 480);
      *(_DWORD *)(*(_DWORD *)v5 + 44) = 0;
    }
  }
  else
  {
    v6 = pm;
    *(_DWORD *)(*(_DWORD *)pm + 48) = *(_DWORD *)(LODWORD(v1) + 460);
    *(_DWORD *)(*(_DWORD *)v6 + 44) = *(_DWORD *)(LODWORD(pml[33]) + 468);
    v7 = pml[33];
    if ( *(_DWORD *)(LODWORD(v7) + 732) )
      *(_DWORD *)(*(_DWORD *)v6 + 48) = (int)(1.0
                                            / *(float *)(LODWORD(v7) + 1044)
                                            * (1.0 - *(float *)(*(_DWORD *)v6 + 184)));
    BG_AnimScriptEvent(*(_DWORD **)pm, 2, 0, 1);
    if ( *(_DWORD *)(LODWORD(pml[33]) + 712) )
      Com_BitSet(*(_DWORD *)pm + 796, *(_DWORD *)(*(_DWORD *)pm + 176));
  }
  *(_DWORD *)(*(_DWORD *)pm + 180) = 3;
  return PM_SetProneMovementOverride();
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00038BBC) --------------------------------------------------------
int sub_38BBC()
{
  int v0; // edx
  _BOOL4 v1; // ebx
  int v2; // edx
  int v3; // eax

  v0 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176));
  if ( *(int *)(4 * *(_DWORD *)(v0 + 424) + *(_DWORD *)pm + 524) < 1 )
  {
    v1 = *(_DWORD *)(4 * *(_DWORD *)(v0 + 416) + *(_DWORD *)pm + 268) >= 1;
    if ( *(_DWORD *)(LODWORD(pml[33]) + 112) != 1 )
    {
      if ( *(int *)(4 * *(_DWORD *)(v0 + 416) + *(_DWORD *)pm + 268) >= 1 )
        goto LABEL_6;
      PM_AddEvent(149);
    }
    if ( !v1 )
    {
      if ( *(_BYTE *)(pm + 10) )
      {
        v2 = *(_DWORD *)pm;
        if ( (*(_DWORD *)(*(_DWORD *)pm + 980) & 0xFFFFFDFF) != 0 && *(int *)(v2 + 4) <= 5 )
        {
          v3 = *(_DWORD *)(*(_DWORD *)pm + 980) & 0x200;
          BYTE1(v3) ^= 2u;
          *(_DWORD *)(v2 + 980) = v3;
        }
      }
      *(_DWORD *)(*(_DWORD *)pm + 44) += 500;
      return 0;
    }
LABEL_6:
    sub_379B8();
    return 0;
  }
  return 1;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00038C80) --------------------------------------------------------
int sub_38C80()
{
  int v0; // ecx
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  int v5; // ebx
  int result; // eax
  int v7; // edx
  int v8; // eax

  v0 = *(_DWORD *)pm;
  v2 = *(float *)(*(_DWORD *)pm + 184) > 0.75;
  v3 = 0;
  v4 = 0.75 == *(float *)(*(_DWORD *)pm + 184);
  if ( (v1 & 0x45) == 1 )
  {
    v5 = 5;
    result = 4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v0 + 176)) + 424);
    if ( !*(_DWORD *)(result + v0 + 524) )
      v5 = 6;
  }
  else
  {
    v5 = 2;
    result = 4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v0 + 176)) + 424);
    if ( !*(_DWORD *)(result + v0 + 524) )
      v5 = 3;
  }
  v7 = *(_DWORD *)pm;
  if ( *(int *)(*(_DWORD *)pm + 4) <= 5 )
  {
    if ( *(_BYTE *)(pm + 10) )
    {
      v8 = *(_DWORD *)(v7 + 980) & 0x200;
      BYTE1(v8) ^= 2u;
      result = v5 | v8;
      *(_DWORD *)(v7 + 980) = result;
    }
  }
  return result;
}
// 38C9C: variable 'v1' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00038D28) --------------------------------------------------------
int __cdecl sub_38D28(int a1)
{
  int result; // eax
  int v2; // ecx
  int v3; // ebx
  int v4; // eax
  float v5; // ecx
  int v6; // ecx
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  char v12; // fps^1
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  int v16; // ecx
  _DWORD *v17; // edx

  sub_38A44(a1);
  result = sub_38BBC();
  if ( result )
  {
    result = pm;
    v2 = *(_DWORD *)pm;
    if ( !*(_DWORD *)(*(_DWORD *)pm + 48) )
    {
      v3 = 4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(v2 + 176)) + 424);
      v4 = *(_DWORD *)(v3 + v2 + 524);
      if ( v4 != -1 && (*(_BYTE *)(v2 + 129) & 0xC0) == 0 )
        *(_DWORD *)(v3 + v2 + 524) = v4 - 1;
      v5 = pml[33];
      if ( *(_DWORD *)(LODWORD(v5) + 112) == 1 )
        *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(v5) + 468);
      sub_38C80();
      if ( *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176)) + 424)
                     + *(_DWORD *)pm
                     + 524) )
        PM_AddEvent(159);
      else
        PM_AddEvent(161);
      v6 = pm;
      v8 = *(float *)(*(_DWORD *)pm + 184);
      v9 = v8 < 1.0;
      v10 = 0;
      v11 = v8 == 1.0;
      if ( (v7 & 0x45) != 64 )
      {
        *(float *)(*(_DWORD *)pm + 984) = *(float *)(LODWORD(pml[33]) + 592) * 255.0 + *(float *)(*(_DWORD *)pm + 984);
        v13 = *(float *)(*(_DWORD *)v6 + 984) > 255.0;
        v14 = 0;
        v15 = 255.0 == *(float *)(*(_DWORD *)v6 + 984);
        if ( (v12 & 0x45) == 1 )
          *(float *)(*(_DWORD *)v6 + 984) = 255.0;
      }
      v16 = *(_DWORD *)pm;
      result = dword_7C91C;
      v17 = *(_DWORD **)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)pm + 176));
      if ( v17[181] )
      {
        result = 4 * v17[106];
        if ( !*(_DWORD *)(result + v16 + 524) )
        {
          result = 4 * v17[104];
          if ( !*(_DWORD *)(result + v16 + 268) )
          {
            BG_TakePlayerWeapon(*(_DWORD *)pm, *(_DWORD *)(*(_DWORD *)pm + 176));
            result = PM_AddEvent(149);
          }
        }
      }
    }
  }
  return result;
}
// 38E07: variable 'v7' is possibly undefined
// 38E38: variable 'v12' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (00038EB4) --------------------------------------------------------
int sub_38EB4()
{
  int *v0; // ecx
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // eax

  v0 = *(int **)pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( v1 == 10 )
  {
    v2 = *(_DWORD *)(LODWORD(pml[33]) + 484) - *(_DWORD *)(LODWORD(pml[33]) + 464);
    if ( v0[11] < v2 )
      v0[11] = v2;
    PM_AddEvent(165);
    *(_DWORD *)(*(_DWORD *)pm + 180) = 11;
    PM_SetProneMovementOverride();
    result = 1;
  }
  else if ( v1 == 11 )
  {
    if ( *(_BYTE *)(pm + 10) && (v0[245] & 0xFFFFFDFF) != 0 && v0[1] <= 5 )
    {
      v4 = v0[245] & 0x200;
      BYTE1(v4) ^= 2u;
      v0[245] = v4;
    }
    *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (00038F68) --------------------------------------------------------
int __cdecl sub_38F68(int a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // edx
  int v4; // edx
  int v5; // eax
  float v6; // ebx
  int v7; // edx
  int v8; // edx

  result = LODWORD(pml[33]);
  if ( *(_DWORD *)(result + 452) )
  {
    if ( !a1 )
    {
      result = pm;
      v2 = pm;
      if ( !*(_DWORD *)(*(_DWORD *)pm + 48)
        || (result = *(_DWORD *)(*(_DWORD *)pm + 180), result == 5)
        || result == 7
        || result == 9
        || result == 8
        || result == 6 )
      {
        if ( (*(_BYTE *)(pm + 8) & 0x20) != 0 )
        {
          v3 = *(_DWORD *)(*(_DWORD *)pm + 12);
          if ( (v3 & 0x1000) == 0 )
          {
            BYTE1(v3) |= 0x10u;
            *(_DWORD *)(*(_DWORD *)pm + 12) = v3;
            result = *(_DWORD *)(*(_DWORD *)v2 + 180);
            if ( result < 1 || result > 2 && (result > 11 || result < 10) )
            {
              BG_AnimScriptEvent(*(_DWORD **)pm, 13, 0, 1);
              v4 = *(_DWORD *)pm;
              if ( *(int *)(*(_DWORD *)pm + 4) <= 5 && *(_BYTE *)(pm + 10) )
              {
                v5 = *(_DWORD *)(v4 + 980) & 0x200;
                BYTE1(v5) ^= 2u;
                LOBYTE(v5) = 8;
                *(_DWORD *)(v4 + 980) = v5;
              }
              PM_AddEvent(164);
              v6 = pml[33];
              if ( *(_DWORD *)(LODWORD(v6) + 464) )
              {
                v7 = pm;
                *(_DWORD *)(*(_DWORD *)pm + 44) = *(_DWORD *)(LODWORD(v6) + 484);
                *(_DWORD *)(*(_DWORD *)v7 + 48) = *(_DWORD *)(LODWORD(pml[33]) + 464);
                *(_DWORD *)(*(_DWORD *)v7 + 180) = 10;
                result = PM_SetProneMovementOverride();
              }
              else
              {
                v8 = *(_DWORD *)(LODWORD(v6) + 484);
                if ( *(_DWORD *)(*(_DWORD *)pm + 44) < v8 )
                  *(_DWORD *)(*(_DWORD *)pm + 44) = v8;
                PM_AddEvent(165);
                *(_DWORD *)(*(_DWORD *)pm + 180) = 11;
                result = PM_SetProneMovementOverride();
              }
            }
          }
        }
        else
        {
          result = *(_DWORD *)pm;
          *(_BYTE *)(*(_DWORD *)pm + 13) &= 0xEFu;
        }
      }
    }
  }
  return result;
}
// 16EE30: using guessed type int pm;

//----- (000390E0) --------------------------------------------------------
__int16 PM_Weapon()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax
  float v3; // ecx
  int v4; // edx
  int v5; // ebx
  _DWORD **v6; // ecx
  float v7; // edx
  int v8; // ebx
  int *v9; // edx
  int v10; // ecx
  int v11; // edx
  int v12; // eax

  v0 = *(_DWORD *)pm;
  if ( (*(_BYTE *)(*(_DWORD *)pm + 13) & 8) == 0 )
  {
    if ( *(int *)(v0 + 4) <= 5 )
    {
      if ( (*(_BYTE *)(v0 + 129) & 0xC0) == 0 )
      {
        v1 = bg_debugWeaponState[3];
        if ( v1 && v1 != 2 )
          sub_39350();
        v2 = bg_debugWeaponAnim[3];
        if ( v2 && v2 != 2 )
          sub_39484();
        PM_UpdateAimDownSightLerp();
        v3 = pml[33];
        if ( *(_DWORD *)(LODWORD(v3) + 112) == 1 )
        {
          v4 = *(_DWORD *)(*(_DWORD *)pm + 52);
          if ( v4 > 0 )
          {
            if ( *(_DWORD *)(LODWORD(v3) + 720) )
              *(_DWORD *)(*(_DWORD *)pm + 52) = v4 - LODWORD(pml[10]);
            v5 = *(_DWORD *)pm;
            v6 = (_DWORD **)pm;
            if ( *(int *)(*(_DWORD *)pm + 52) <= 50 )
            {
              *(_DWORD *)(v5 + 52) = 50;
              PM_AddEvent(159);
              v0 = *(_DWORD *)pm;
              *(_DWORD *)(*(_DWORD *)pm + 44) = 1600;
              return v0;
            }
            if ( (*(_BYTE *)(pm + 8) & 1) == 0 )
              goto LABEL_21;
            v7 = pml[10];
            if ( *(_DWORD *)(v5 + 48) - LODWORD(v7) <= 0 )
              *(_DWORD *)(v5 + 48) = LODWORD(v7) + 1;
            v6 = (_DWORD **)pm;
            if ( (*(_BYTE *)(pm + 8) & 1) == 0 )
            {
LABEL_21:
              if ( (*v6)[12] - LODWORD(pml[10]) <= 0 )
                BG_AnimScriptEvent(*v6, 2, 0, 1);
            }
          }
        }
        v8 = sub_387C0();
        sub_38918();
        sub_384D8();
        sub_38F68(v8);
        v0 = sub_375D0(v8);
        if ( !v0 )
        {
          if ( (*(_BYTE *)(*(_DWORD *)pm + 12) & 1) != 0 && *(_WORD *)(pm + 24)
            || (unsigned int)(*(_DWORD *)(*(_DWORD *)pm + 180) - 10) <= 1 )
          {
            *(float *)(*(_DWORD *)pm + 984) = 255.0;
          }
          if ( v8 || (v0 = *(_DWORD *)pm, !*(_DWORD *)(*(_DWORD *)pm + 44)) && !*(_DWORD *)(v0 + 48) )
          {
            v0 = sub_3820C(v8);
            if ( !v0 )
            {
              v0 = sub_38EB4();
              if ( !v0 )
              {
                v0 = sub_37D84();
                if ( !v0 )
                {
                  v0 = pm;
                  v9 = *(int **)pm;
                  v10 = *(_DWORD *)(*(_DWORD *)pm + 180);
                  if ( v10 == 1 )
                  {
                    v9[45] = 0;
                    v11 = *(_DWORD *)v0;
                    if ( *(int *)(*(_DWORD *)v0 + 4) <= 5 && *(_BYTE *)(v0 + 10) )
                    {
                      v0 = *(_DWORD *)(v11 + 980) & 0x200;
                      BYTE1(v0) ^= 2u;
                      *(_DWORD *)(v11 + 980) = v0;
                    }
                  }
                  else if ( v9[44] )
                  {
                    if ( (*(_BYTE *)(pm + 8) & 1) != 0 || v8 )
                    {
                      LOWORD(v0) = sub_38D28(v8);
                    }
                    else
                    {
                      if ( v10 == 3 && *(_BYTE *)(pm + 10) && (v9[245] & 0xFFFFFDFF) != 0 && v9[1] <= 5 )
                      {
                        v12 = v9[245] & 0x200;
                        BYTE1(v12) ^= 2u;
                        v9[245] = v12;
                      }
                      v0 = *(_DWORD *)pm;
                      *(_DWORD *)(*(_DWORD *)pm + 180) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(v0 + 176) = 0;
    }
  }
  return v0;
}
// 16EE30: using guessed type int pm;

//----- (00039350) --------------------------------------------------------
int sub_39350()
{
  int result; // eax
  int v1; // ebx

  result = *(_DWORD *)pm;
  v1 = *(_DWORD *)(*(_DWORD *)pm + 180);
  if ( dword_7D534 != v1 )
  {
    Com_Printf(" %i %s_", *(_DWORD *)(pm + 4), (const char *)off_7C910);
    dword_7D534 = v1;
    Com_Printf("WEAP_STATE -- ");
    switch ( v1 )
    {
      case 0:
        result = Com_Printf("WEAPON_READY\n");
        break;
      case 1:
        result = Com_Printf("WEAPON_RAISING\n");
        break;
      case 2:
        result = Com_Printf("WEAPON_DROPPING\n");
        break;
      case 3:
        result = Com_Printf("WEAPON_FIRING\n");
        break;
      case 4:
        result = Com_Printf("WEAPON_RECHAMBERING\n");
        break;
      case 5:
        result = Com_Printf("WEAPON_RELOADING\n");
        break;
      case 6:
        result = Com_Printf("WEAPON_RELOADING_INTERUPT\n");
        break;
      case 7:
        result = Com_Printf("WEAPON_RELOAD_START\n");
        break;
      case 8:
        result = Com_Printf("WEAPON_RELOAD_START_INTERUPT\n");
        break;
      case 9:
        result = Com_Printf("WEAPON_RELOAD_END\n");
        break;
      case 10:
        result = Com_Printf("WEAPON_MELEE_WINDUP\n");
        break;
      case 11:
        result = Com_Printf("WEAPON_MELEE_RELAX\n");
        break;
      default:
        result = Com_Printf("UNKNOWN\n");
        break;
    }
  }
  return result;
}
// 7C910: using guessed type void *off_7C910;
// 7D534: using guessed type int dword_7D534;
// 16EE30: using guessed type int pm;

//----- (00039484) --------------------------------------------------------
int sub_39484()
{
  int v0; // ebx
  int result; // eax

  v0 = *(_DWORD *)(*(_DWORD *)pm + 980);
  BYTE1(v0) &= 0xFDu;
  Com_Printf(" %i %s_", *(_DWORD *)(pm + 4), (const char *)off_7C910);
  dword_7D538 = v0;
  Com_Printf("WEAP_ANIM -- ");
  switch ( v0 )
  {
    case 0:
      result = Com_Printf("WEAP_IDLE\n");
      break;
    case 2:
      result = Com_Printf("WEAP_ATTACK\n");
      break;
    case 3:
      result = Com_Printf("WEAP_ATTACK_LASTSHOT\n");
      break;
    case 4:
      result = Com_Printf("WEAP_RECHAMBER\n");
      break;
    case 5:
      result = Com_Printf("WEAP_ADS_ATTACK\n");
      break;
    case 6:
      result = Com_Printf("WEAP_ADS_ATTACK_LASTSHOT\n");
      break;
    case 7:
      result = Com_Printf("WEAP_ADS_RECHAMBER\n");
      break;
    case 8:
      result = Com_Printf("WEAP_MELEE_ATTACK\n");
      break;
    case 9:
      result = Com_Printf("WEAP_DROP\n");
      break;
    case 10:
      result = Com_Printf("WEAP_RAISE\n");
      break;
    case 11:
      result = Com_Printf("WEAP_RELOAD\n");
      break;
    case 12:
      result = Com_Printf("WEAP_RELOAD_EMPTY\n");
      break;
    case 13:
      result = Com_Printf("WEAP_RELOAD_START\n");
      break;
    case 14:
      result = Com_Printf("WEAP_RELOAD_END\n");
      break;
    case 15:
      result = Com_Printf("WEAP_ALTSWITCHFROM\n");
      break;
    case 16:
      result = Com_Printf("WEAP_ALTSWITCHTO\n");
      break;
    default:
      result = Com_Printf("UNKNOWN\n");
      break;
  }
  return result;
}
// 7C910: using guessed type void *off_7C910;
// 7D538: using guessed type int dword_7D538;
// 16EE30: using guessed type int pm;

//----- (00039604) --------------------------------------------------------
__int16 __cdecl sub_39604(float *a1, float *a2)
{
  int v2; // esi
  float *v3; // ebx
  int v4; // eax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  int v12; // eax
  long double v13; // fst6
  char v14; // fps^1
  long double v15; // fst6
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  long double v19; // fst7
  float *v20; // ecx
  int v21; // edx
  long double v22; // fst7
  char v23; // fps^1
  long double v24; // fst6
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  long double v28; // fst6
  char v29; // fps^1
  long double v30; // fst5
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  long double v34; // fst6
  long double v35; // fst7
  long double v36; // fst6
  long double v37; // fst5
  char v38; // fps^1
  long double v39; // fst4
  bool v40; // c0
  char v41; // c2
  bool v42; // c3
  long double v43; // fst7
  long double v44; // fst6
  char v45; // fps^1
  bool v46; // c0
  char v47; // c2
  bool v48; // c3
  long double v49; // fst6
  char v50; // fps^1
  bool v51; // c0
  char v52; // c2
  bool v53; // c3
  char v54; // fps^1
  long double v55; // fst6
  bool v56; // c0
  char v57; // c2
  bool v58; // c3
  __int16 v60; // fps
  bool v61; // c0
  char v62; // c2
  bool v63; // c3
  float *v64; // eax
  long double v65; // fst7
  long double v66; // fst7
  float *v68; // [esp+20h] [ebp-18h]
  int v69; // [esp+24h] [ebp-14h]
  float v70; // [esp+2Ch] [ebp-Ch]
  float v71; // [esp+30h] [ebp-8h]
  float v72; // [esp+34h] [ebp-4h]

  v2 = *(_DWORD *)a1;
  v3 = *(float **)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176));
  v4 = *(_DWORD *)(*(_DWORD *)a1 + 128);
  if ( (v4 & 0x40) != 0 )
  {
    v5 = v3[96];
  }
  else if ( (v4 & 0x20) != 0 )
  {
    v5 = v3[95];
  }
  else
  {
    v5 = v3[94];
  }
  v6 = a1[1];
  if ( v6 <= v5 || *(_DWORD *)(v2 + 180) == 5 )
  {
    v72 = 0.0;
    v71 = 0.0;
    v70 = 0.0;
  }
  else
  {
    v7 = (v6 - v5) / ((long double)*(int *)(v2 + 68) - v5);
    if ( v7 >= 0.0 && (v9 = v7 > 1.0, v10 = 0, v11 = 1.0 == v7, (v8 & 0x45) == 1) )
    {
      v7 = 1.0;
    }
    else if ( v7 < 0.0 )
    {
      v7 = 0.0;
    }
    v12 = *(_DWORD *)(v2 + 128);
    if ( (v12 & 0x40) != 0 )
    {
      v70 = v3[84] * v7;
      v71 = v3[85] * v7;
      v13 = v3[86];
    }
    else if ( (v12 & 0x20) != 0 )
    {
      v70 = v3[75] * v7;
      v71 = v3[76] * v7;
      v13 = v3[77];
    }
    else
    {
      v70 = v3[66] * v7;
      v71 = v3[67] * v7;
      v13 = v3[68];
    }
    v72 = v7 * v13;
  }
  v15 = *(float *)(v2 + 184);
  v16 = v15 < 0.0;
  v17 = 0;
  v18 = v15 == 0.0;
  if ( (v14 & 0x45) != 64 )
  {
    v19 = 1.0 - *(float *)(v2 + 184);
    v70 = v70 * v19;
    v71 = v71 * v19;
    v72 = v19 * v72;
  }
  v20 = a1 + 3;
  v68 = a1 + 3;
  v21 = 0;
  v69 = 2;
  do
  {
    v22 = *(float *)((char *)&v70 + v21 * 4);
    v24 = v68[v21];
    v25 = v24 < v22;
    v26 = 0;
    v27 = v24 == v22;
    if ( (v23 & 0x45) == 64 )
      goto LABEL_36;
    v28 = (long double)*(int *)(v2 + 828);
    v30 = *(float *)(v2 + 208);
    v31 = v30 < v28;
    v32 = 0;
    v33 = v30 == v28;
    v34 = (*(float *)((char *)&v70 + v21 * 4) - v68[v21]) * a1[2];
    v35 = a1[2];
    if ( (v29 & 0x44) != 0x40 )
      v36 = v34 * v3[92];
    else
      v36 = v34 * v3[93];
    v37 = *(float *)((char *)&v70 + v21 * 4);
    v39 = v68[v21];
    v40 = v39 < v37;
    v41 = 0;
    v42 = v39 == v37;
    if ( (v38 & 0x45) == 1 )
    {
      if ( v35 * 0.1 > v36 )
        v36 = v35 * 0.1;
      v43 = *(float *)((char *)&v70 + v21 * 4);
      v44 = v36 + v68[v21];
      v20[v21] = v44;
      if ( v44 > v43 )
        goto LABEL_35;
    }
    else
    {
      v46 = v35 * -0.1 < v36;
      v47 = 0;
      v48 = v35 * -0.1 == v36;
      if ( (v45 & 0x45) == 1 )
        v36 = v35 * -0.1;
      v43 = *(float *)((char *)&v70 + v21 * 4);
      v49 = v36 + v68[v21];
      v20[v21] = v49;
      v51 = v49 < v43;
      v52 = 0;
      v53 = v49 == v43;
      if ( (v50 & 0x45) == 1 )
      {
LABEL_35:
        v20[v21] = v43;
        goto LABEL_36;
      }
    }
LABEL_36:
    ++v21;
    --v69;
  }
  while ( v69 >= 0 );
  v55 = *(float *)(v2 + 184);
  v56 = v55 < 0.0;
  v57 = 0;
  v58 = v55 == 0.0;
  if ( (v54 & 0x45) == 64 )
  {
    *a2 = *a2 + a1[3];
    a2[1] = a2[1] + a1[4];
    v66 = a2[2] + a1[5];
    v64 = a2;
LABEL_41:
    v64[2] = v66;
  }
  else
  {
    v61 = v55 < 0.5;
    v62 = 0;
    v63 = v55 == 0.5;
    LOBYTE(v64) = v60;
    BYTE1(v64) = HIBYTE(v60) & 0x45;
    if ( (HIBYTE(v60) & 0x45) == 1 )
    {
      v65 = 1.0 - (v55 + v55);
      *a2 = a1[3] * v65 + *a2;
      a2[1] = a1[4] * v65 + a2[1];
      v64 = a2;
      v66 = v65 * a1[5] + a2[2];
      goto LABEL_41;
    }
  }
  return (__int16)v64;
}
// 39684: variable 'v8' is possibly undefined
// 3973A: variable 'v14' is possibly undefined
// 3978E: variable 'v23' is possibly undefined
// 397B2: variable 'v29' is possibly undefined
// 397F8: variable 'v38' is possibly undefined
// 3983C: variable 'v45' is possibly undefined
// 39855: variable 'v50' is possibly undefined
// 3987C: variable 'v54' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (0003990C) --------------------------------------------------------
__int16 __cdecl sub_3990C(float *a1, float *a2)
{
  int v2; // ecx
  int v3; // edx
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst5
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  int v10; // eax
  long double v11; // fst6
  __int16 v12; // fps
  long double v13; // fst5
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  __int16 result; // ax
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst5
  __int16 v22; // fps
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  long double v26; // fst5
  __int16 v27; // fps
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  long double v31; // rt2
  float v32; // [esp+20h] [ebp-8h]
  float v33; // [esp+20h] [ebp-8h]
  float v34; // [esp+20h] [ebp-8h]

  v2 = *(_DWORD *)a1;
  v3 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( *(_DWORD *)(v3 + 716) )
  {
    v4 = *(float *)(v3 + 628) + (*(float *)(v3 + 624) - *(float *)(v3 + 628)) * *(float *)(v2 + 184);
  }
  else
  {
    v6 = *(float *)(v3 + 628);
    v7 = v6 < 0.0;
    v8 = 0;
    v9 = v6 == 0.0;
    v4 = v6;
    if ( (v5 & 0x45) == 64 )
      v4 = 80.0;
  }
  v10 = *(_DWORD *)(v2 + 128);
  if ( (v10 & 0x40) != 0 )
  {
    v11 = *(float *)(v3 + 636);
  }
  else
  {
    v11 = 1.0;
    if ( (v10 & 0x20) != 0 )
      v11 = *(float *)(v3 + 632);
  }
  v13 = a1[6];
  v14 = v13 < v11;
  v15 = 0;
  v16 = v13 == v11;
  LOBYTE(result) = v12;
  HIBYTE(result) = HIBYTE(v12) & 0x45;
  if ( (HIBYTE(v12) & 0x45) != 64 )
  {
    v18 = v13 < v11;
    v19 = 0;
    v20 = v13 == v11;
    if ( (HIBYTE(v12) & 0x45) == 1 )
    {
      v21 = v13 + a1[2] * 0.5;
      a1[6] = v21;
      v23 = v21 < v11;
      v24 = 0;
      v25 = v21 == v11;
      LOBYTE(result) = v22;
      HIBYTE(result) = HIBYTE(v22) & 0x45;
      if ( v21 > v11 )
        goto LABEL_14;
    }
    else
    {
      v26 = v13 - a1[2] * 0.5;
      a1[6] = v26;
      v28 = v26 < v11;
      v29 = 0;
      v30 = v26 == v11;
      LOBYTE(result) = v27;
      HIBYTE(result) = HIBYTE(v27) & 0x45;
      if ( (HIBYTE(v27) & 0x45) == 1 )
      {
LABEL_14:
        a1[6] = v11;
        goto LABEL_15;
      }
    }
  }
LABEL_15:
  v31 = v4 * a1[6];
  v32 = sin((long double)*((int *)a1 + 7) * 0.00050000002);
  a2[2] = v32 * v31 * 0.039999999 + a2[2];
  v33 = sin((long double)*((int *)a1 + 7) * 0.00069999998);
  a2[1] = v33 * v31 * 0.0099999998 + a2[1];
  v34 = sin((long double)*((int *)a1 + 7) * 0.001);
  *a2 = v31 * v34 * 0.0099999998 + *a2;
  return result;
}
// 39964: variable 'v5' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (00039A5C) --------------------------------------------------------
__int16 __cdecl sub_39A5C(float *a1, float *a2)
{
  int v2; // ebx
  long double v3; // fst7
  long double v4; // fst6
  int v5; // eax
  long double v6; // fst5
  long double v7; // fst4
  long double v8; // fst4
  long double v9; // rt0
  long double v10; // fst5
  long double v11; // fst6
  long double v12; // fst4
  long double v13; // fst5
  int v14; // eax
  long double v15; // fst4
  long double v16; // fst4
  long double v17; // fst7
  long double v18; // fst6
  int v19; // eax
  long double v20; // fst4
  int v21; // eax
  long double v22; // fst5
  long double v23; // fst6
  long double v24; // fst5
  long double v25; // fst5
  long double v26; // fst7
  long double v27; // fst6
  __int16 v28; // fps
  long double v29; // fst5
  bool v30; // c0
  char v31; // c2
  bool v32; // c3
  __int16 result; // ax
  long double v34; // fst7
  float v35; // [esp+24h] [ebp-24h]
  float v36; // [esp+24h] [ebp-24h]
  float v37; // [esp+24h] [ebp-24h]
  float v38; // [esp+24h] [ebp-24h]
  float v39; // [esp+24h] [ebp-24h]
  float v40; // [esp+34h] [ebp-14h]
  float v41; // [esp+34h] [ebp-14h]
  float v42; // [esp+34h] [ebp-14h]
  float v43; // [esp+3Ch] [ebp-Ch]
  float v44; // [esp+40h] [ebp-8h]
  float v45; // [esp+44h] [ebp-4h]

  v2 = *(_DWORD *)a1;
  v40 = (long double)*(unsigned __int8 *)(*(_DWORD *)a1 + 8) / 255.0 * 3.141592653589793
      + (long double)*(unsigned __int8 *)(*(_DWORD *)a1 + 8) / 255.0 * 3.141592653589793
      + 6.283185307179586;
  v41 = v40 + 0.7853981633974483 + 6.283185307179586;
  v3 = v41;
  v4 = 10.0;
  v5 = *(_DWORD *)(*(_DWORD *)a1 + 204);
  v6 = a1[1] * 0.16;
  if ( v5 == *(_DWORD *)(*(_DWORD *)a1 + 828) )
  {
    v7 = v6 * 0.029999999;
  }
  else if ( v5 == *(_DWORD *)(v2 + 832) )
  {
    v7 = v6 * 0.0074999998;
  }
  else
  {
    v7 = v6 * 0.0070000002;
  }
  if ( v7 <= 10.0 )
    v4 = v7;
  v35 = sin(v3 + v3);
  v8 = v35;
  v36 = sin(v3 * 4.0 + 1.570796326794897);
  v9 = v6;
  v10 = v4 * ((v8 + v36 * 0.2) * 0.75);
  v11 = v9;
  v12 = -v10;
  v13 = 10.0;
  v43 = v12;
  v14 = *(_DWORD *)(v2 + 204);
  if ( v14 == *(_DWORD *)(v2 + 828) )
  {
    v15 = v11 * 0.029999999;
  }
  else if ( v14 == *(_DWORD *)(v2 + 832) )
  {
    v15 = v11 * 0.0074999998;
  }
  else
  {
    v15 = v11 * 0.0070000002;
  }
  if ( v15 <= 10.0 )
    v13 = v15;
  v37 = sin(v3);
  v16 = v3 - 0.4712389167638204;
  v17 = 10.0;
  v42 = v16;
  v18 = v11 * 1.5;
  v44 = -(v13 * v37);
  v19 = *(_DWORD *)(v2 + 204);
  if ( v19 == *(_DWORD *)(v2 + 828) )
  {
    v20 = v18 * 0.029999999;
  }
  else if ( v19 == *(_DWORD *)(v2 + 832) )
  {
    v20 = v18 * 0.0074999998;
  }
  else
  {
    v20 = v18 * 0.0070000002;
  }
  if ( v20 <= 10.0 )
    v17 = v20;
  v38 = sin(v42);
  if ( v17 * v38 >= 0.0 )
  {
    v26 = 0.0;
  }
  else
  {
    v21 = *(_DWORD *)(v2 + 204);
    if ( v21 == *(_DWORD *)(v2 + 828) )
    {
      v22 = v18;
      v23 = 10.0;
      v24 = v22 * 0.029999999;
    }
    else
    {
      v25 = v18;
      v23 = 10.0;
      if ( v21 == *(_DWORD *)(v2 + 832) )
        v24 = v25 * 0.0074999998;
      else
        v24 = v25 * 0.0070000002;
    }
    if ( v24 <= v23 )
      v23 = v24;
    v39 = sin(v42);
    v26 = v23 * v39;
  }
  v27 = v26;
  v45 = v26;
  v29 = *(float *)(v2 + 184);
  v30 = v29 < 0.0;
  v31 = 0;
  v32 = v29 == 0.0;
  LOBYTE(result) = v28;
  HIBYTE(result) = HIBYTE(v28) & 0x45;
  if ( (HIBYTE(v28) & 0x45) != 64 )
  {
    v34 = 1.0
        - *(float *)(v2 + 184)
        * (1.0 - *(float *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176)) + 564));
    v43 = v43 * v34;
    v45 = v27 * v34;
    v44 = v34 * v44;
  }
  *a2 = *a2 + v43;
  a2[1] = a2[1] + v44;
  a2[2] = a2[2] + v45;
  return result;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (00039CE8) --------------------------------------------------------
void __cdecl sub_39CE8(int a1, float *a2)
{
  long double v2; // fst6
  long double v3; // fst4
  char v4; // fps^1
  long double v5; // fst3
  long double v6; // fst7
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst5
  char v11; // fps^1
  long double v12; // fst4
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  long double v16; // fst7
  long double v17; // fst7
  char v18; // fps^1
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst7
  float v23; // [esp-10h] [ebp-38h]
  float v24; // [esp-10h] [ebp-38h]
  long double v25; // [esp+18h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 32) )
  {
    v2 = *(float *)(*(_DWORD *)a1 + 184) * 0.5 + 0.5;
    v3 = v2 * 100.0;
    v5 = *(float *)(*(_DWORD *)a1 + 184);
    v6 = v2 * 400.0;
    v7 = v5 < 0.0;
    v8 = 0;
    v9 = v5 == 0.0;
    if ( (v4 & 0x45) == 64 || !*(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176)) + 552) )
    {
      v10 = v3;
    }
    else
    {
      v10 = v3;
      v2 = v2 * (1.0 - *(float *)(*(_DWORD *)a1 + 184) * 0.75);
    }
    v12 = (long double)(*(_DWORD *)(a1 + 28) - *(_DWORD *)(a1 + 32));
    v13 = v12 < v10;
    v14 = 0;
    v15 = v12 == v10;
    if ( (v11 & 0x45) == 1 )
    {
      v23 = v12 / v10;
      v25 = v2;
      v16 = GetLeanFraction(v23);
    }
    else
    {
      v17 = 1.0 - (v12 - v10) / v6;
      v19 = v17 > 0.0;
      v20 = 0;
      v21 = 0.0 == v17;
      if ( (v18 & 0x45) != 1 )
        return;
      v24 = 1.0 - v17;
      v25 = v2;
      v16 = 1.0 - GetLeanFraction(v24);
    }
    v22 = v16 * v25;
    *a2 = v22 * *(float *)(a1 + 36) * 0.5 + *a2;
    a2[1] = a2[1] - v22 * *(float *)(a1 + 40);
    a2[2] = 0.5 * (v22 * *(float *)(a1 + 40)) + a2[2];
  }
}
// 39D40: variable 'v4' is possibly undefined
// 39D79: variable 'v11' is possibly undefined
// 39DAE: variable 'v18' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (00039E14) --------------------------------------------------------
int __cdecl sub_39E14(float *a1, float *a2)
{
  int result; // eax
  int v3; // esi
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst5
  long double v8; // rtt
  long double v9; // fst4
  long double v10; // fst4
  long double v11; // fst3
  char v12; // fps^1
  long double v13; // fst2
  float *v14; // edx
  float *v15; // ecx
  int v16; // edi
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  long double v20; // fst2
  long double v21; // fst2
  long double v22; // fst3
  char v23; // fps^1
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  long double v27; // fst3
  long double v28; // fst2
  char v29; // fps^1
  long double v30; // fst2
  long double v31; // fst3
  bool v32; // c0
  char v33; // c2
  bool v34; // c3
  long double v35; // fst2
  long double v36; // fst2
  char v37; // fps^1
  bool v38; // c0
  char v39; // c2
  bool v40; // c3
  long double v41; // fst2
  long double v42; // fst3
  long double v43; // fst3
  char v44; // fps^1
  long double v45; // fst2
  float *v46; // edx
  bool v47; // c0
  char v48; // c2
  bool v49; // c3
  long double v50; // fst2
  char v51; // fps^1
  long double v52; // fst3
  bool v53; // c0
  char v54; // c2
  bool v55; // c3
  long double v56; // fst3
  char v57; // fps^1
  long double v58; // fst2
  float *v59; // eax
  long double v60; // fst3
  bool v61; // c0
  char v62; // c2
  bool v63; // c3
  long double v64; // fst2
  long double v65; // fst3
  char v66; // fps^1
  bool v67; // c0
  char v68; // c2
  bool v69; // c3
  long double v70; // fst5
  long double v71; // fst3
  long double v72; // fst4
  long double v73; // rt0
  long double v74; // fst5
  long double v75; // fst6
  long double v76; // rt1
  char v77; // fps^1
  bool v78; // c0
  char v79; // c2
  bool v80; // c3
  float *v81; // [esp+1Ch] [ebp-2Ch]
  float v82; // [esp+20h] [ebp-28h]
  float v83; // [esp+24h] [ebp-24h]
  float v84; // [esp+44h] [ebp-4h]

  result = dword_7C91C;
  v3 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( *(_DWORD *)(v3 + 716) )
  {
    v4 = *(float *)(*(_DWORD *)a1 + 184);
    v82 = (*(float *)(v3 + 864) - *(float *)(v3 + 928)) * v4 + *(float *)(v3 + 928);
    v5 = (*(float *)(v3 + 868) - *(float *)(v3 + 932)) * v4 + *(float *)(v3 + 932);
    v83 = *(float *)(v3 + 936) + (*(float *)(v3 + 872) - *(float *)(v3 + 936)) * v4;
    v6 = v4 * (*(float *)(v3 + 876) - *(float *)(v3 + 940)) + *(float *)(v3 + 940);
    v7 = a1[2];
    if ( v7 > 0.0 )
    {
      while ( 1 )
      {
        v9 = v7;
        if ( v7 <= 0.005 )
        {
          v10 = 0.0;
        }
        else
        {
          v7 = 0.0049999999;
          v84 = v9 - 0.005;
          v10 = v84;
        }
        v11 = *(float *)(v3 + 640);
        v13 = fabs(a1[11]);
        v14 = a1 + 11;
        v15 = a1 + 14;
        v16 = 0;
        v17 = v13 < 0.25;
        v18 = 0;
        v19 = v13 == 0.25;
        if ( (v12 & 0x45) == 1 && fabs(a1[14]) < 1.0 )
        {
          a1[11] = 0.0;
          a1[14] = 0.0;
          v16 = 1;
          goto LABEL_31;
        }
        v20 = *v15 * v7 + *v14;
        *v14 = v20;
        if ( v20 > v11 )
          break;
        v27 = -v11;
        if ( v27 > v20 )
        {
          v28 = v27;
          v22 = 0.0;
          *v14 = v28;
          if ( *v15 < 0.0 )
            goto LABEL_16;
        }
LABEL_17:
        v30 = *v14;
        if ( v30 > 0.0 )
        {
          v31 = *v15 - v82 * v7;
LABEL_21:
          *v15 = v31;
          goto LABEL_22;
        }
        v32 = v30 < 0.0;
        v33 = 0;
        v34 = v30 == 0.0;
        if ( (v29 & 0x45) == 1 )
        {
          v31 = v82 * v7 + *v15;
          goto LABEL_21;
        }
LABEL_22:
        v35 = *v15 - *v15 * v83 * v7;
        *v15 = v35;
        if ( v35 <= 0.0 )
        {
          v41 = v35 + v6 * v7;
          *v15 = v41;
          if ( v41 > 0.0 )
            *v15 = 0.0;
        }
        else
        {
          v36 = v35 - v6 * v7;
          *v15 = v36;
          v38 = v36 < 0.0;
          v39 = 0;
          v40 = v36 == 0.0;
          if ( (v37 & 0x45) == 1 )
            *v15 = 0.0;
        }
        v42 = *v15;
        if ( v42 > v5 )
        {
          *v15 = v5;
        }
        else if ( -v5 > v42 )
        {
          *v15 = -v5;
        }
LABEL_31:
        v81 = a1 + 15;
        v43 = *(float *)(v3 + 644);
        v45 = fabs(a1[12]);
        v46 = a1 + 12;
        v47 = v45 < 0.25;
        v48 = 0;
        v49 = v45 == 0.25;
        if ( (v44 & 0x45) != 1 || fabs(a1[15]) >= 1.0 )
        {
          v50 = *v81 * v7 + *v46;
          *v46 = v50;
          if ( v50 <= v43 )
          {
            v56 = -v43;
            if ( v56 > v50 )
            {
              *v46 = v56;
              v52 = 0.0;
              if ( *v81 < 0.0 )
LABEL_39:
                *v81 = v52;
            }
          }
          else
          {
            *v46 = v43;
            v52 = 0.0;
            v53 = *v81 > 0.0;
            v54 = 0;
            v55 = 0.0 == *v81;
            if ( (v51 & 0x45) == 1 )
              goto LABEL_39;
          }
          v58 = *v46;
          if ( v58 > 0.0 )
          {
            v59 = a1 + 15;
            v60 = *v81 - v82 * v7;
            goto LABEL_44;
          }
          v61 = v58 < 0.0;
          v62 = 0;
          v63 = v58 == 0.0;
          if ( (v57 & 0x45) == 1 )
          {
            v59 = a1 + 15;
            v60 = v82 * v7 + *v81;
LABEL_44:
            *v59 = v60;
          }
          v64 = *v81 - *v81 * v83 * v7;
          *v81 = v64;
          if ( v64 <= 0.0 )
          {
            v71 = v7 * v6 + v64;
            *v81 = v71;
            v70 = v10;
            if ( v71 > 0.0 )
              *v81 = 0.0;
          }
          else
          {
            v65 = v64 - v7 * v6;
            *v81 = v65;
            v67 = v65 < 0.0;
            v68 = 0;
            v69 = v65 == 0.0;
            v70 = v10;
            if ( (v66 & 0x45) == 1 )
              *v81 = 0.0;
          }
          v72 = *v81;
          if ( v72 <= v5 )
          {
            if ( -v5 > v72 )
              *v81 = -v5;
            v76 = v70;
            v74 = v5;
            v75 = v76;
          }
          else
          {
            v73 = v70;
            v74 = v5;
            v75 = v73;
            *v81 = v74;
          }
          goto LABEL_57;
        }
        a1[12] = 0.0;
        a1[15] = 0.0;
        if ( v16 )
          goto LABEL_58;
        v74 = v5;
        v75 = v10;
LABEL_57:
        v78 = v75 > 0.0;
        v79 = 0;
        v80 = 0.0 == v75;
        if ( (v77 & 0x45) != 1 )
          goto LABEL_58;
        v8 = v74;
        v7 = v75;
        v5 = v8;
      }
      v21 = v11;
      v22 = 0.0;
      *v14 = v21;
      v24 = *v15 > 0.0;
      v25 = 0;
      v26 = 0.0 == *v15;
      if ( (v23 & 0x45) != 1 )
        goto LABEL_17;
LABEL_16:
      *v15 = v22;
      goto LABEL_17;
    }
LABEL_58:
    result = (int)a2;
    *a2 = *a2 + a1[11];
    a2[1] = a2[1] + a1[12];
    a2[2] = a2[2] + a1[13];
  }
  return result;
}
// 39EF6: variable 'v12' is possibly undefined
// 39F45: variable 'v23' is possibly undefined
// 39F94: variable 'v29' is possibly undefined
// 39FCB: variable 'v37' is possibly undefined
// 3A03A: variable 'v44' is possibly undefined
// 3A091: variable 'v51' is possibly undefined
// 3A0E9: variable 'v57' is possibly undefined
// 3A12B: variable 'v66' is possibly undefined
// 3A1AC: variable 'v77' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A1E4) --------------------------------------------------------
void __cdecl BG_CalculateWeaponAngles(float *a1, float *a2)
{
  int v2; // eax
  char v3; // fps^1
  long double v4; // fst6
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst7
  int v9; // eax

  v2 = *(_DWORD *)a1;
  a2[2] = 0.0;
  a2[1] = 0.0;
  *a2 = 0.0;
  v4 = *(float *)(v2 + 64);
  v5 = v4 < 0.0;
  v6 = 0;
  v7 = v4 == 0.0;
  if ( (v3 & 0x45) != 64 )
  {
    v8 = GetLeanFraction(*(float *)(v2 + 64));
    a2[2] = a2[2] - (v8 + v8);
  }
  v9 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( *(_DWORD *)(v9 + 716) )
    *a2 = *(float *)(*(_DWORD *)a1 + 184) * *(float *)(v9 + 836) + *a2;
  sub_39604(a1, a2);
  sub_3990C(a1, a2);
  sub_39A5C(a1, a2);
  sub_39CE8((int)a1, a2);
  sub_39E14(a1, a2);
  *a2 = AngleSubtract(*a2, a1[17]);
  a2[1] = AngleSubtract(a2[1], a1[18]);
}
// 3A205: variable 'v3' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A2D4) --------------------------------------------------------
void __cdecl sub_3A2D4(int a1, float *a2)
{
  long double v2; // fst7
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double v14; // fst7
  float v15; // [esp-10h] [ebp-28h]
  float v16; // [esp-10h] [ebp-28h]
  float v17; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 4) )
  {
    v2 = *(float *)(*(_DWORD *)a1 + 184);
    v17 = 1.0 - v2 * 0.5;
    v4 = v2 > 0.0;
    v5 = 0;
    v6 = 0.0 == v2;
    if ( (v3 & 0x45) != 64 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176)) + 552) )
        v17 = (v2 * 0.5 + 1.0) * v17;
    }
    v7 = (long double)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4));
    if ( v7 >= 100.0 )
    {
      v9 = 1.0 - (v7 - 100.0) / 400.0;
      v11 = v9 > 0.0;
      v12 = 0;
      v13 = 0.0 == v9;
      if ( (v10 & 0x45) != 1 )
        return;
      v16 = 1.0 - v9;
      v8 = 1.0 - GetLeanFraction(v16);
    }
    else
    {
      v15 = v7 / 100.0;
      v8 = GetLeanFraction(v15);
    }
    v14 = v8 * v17;
    *a2 = v14 * *(float *)(a1 + 12) + *a2;
    a2[2] = v14 * *(float *)(a1 + 16) + a2[2];
  }
}
// 3A31B: variable 'v3' is possibly undefined
// 3A382: variable 'v10' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A3C4) --------------------------------------------------------
__int16 __cdecl sub_3A3C4(float *a1, float *a2)
{
  int v2; // ecx
  __int16 result; // ax
  int v4; // edx
  __int16 v5; // fps
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  __int16 v10; // fps
  long double v11; // fst6
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst7
  long double v16; // fst6
  long double v17; // fst5
  int v18; // eax
  long double v19; // fst5
  long double v20; // fst5
  long double v21; // fst6
  long double v22; // fst5
  int v23; // eax
  __int16 v24; // fps
  long double v25; // fst5
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  float v29; // [esp+24h] [ebp-14h]
  float v30; // [esp+24h] [ebp-14h]
  float v31; // [esp+24h] [ebp-14h]
  float v32; // [esp+30h] [ebp-8h]

  v2 = *(_DWORD *)a1;
  result = dword_7C91C;
  v4 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( (*(_BYTE *)(*(_DWORD *)a1 + 129) & 0xC0) == 0 )
  {
    v6 = *(float *)(v2 + 184);
    v7 = v6 < 0.0;
    v8 = 0;
    v9 = v6 == 0.0;
    LOBYTE(result) = v5;
    HIBYTE(result) = HIBYTE(v5) & 0x45;
    if ( (HIBYTE(v5) & 0x45) != 64 )
    {
      v11 = *(float *)(v4 + 568);
      v12 = v11 < 0.0;
      v13 = 0;
      v14 = v11 == 0.0;
      LOBYTE(result) = v10;
      HIBYTE(result) = HIBYTE(v10) & 0x45;
      if ( (HIBYTE(v10) & 0x45) != 64 )
      {
        v15 = 45.0;
        v32 = (long double)*(unsigned __int8 *)(v2 + 8) / 255.0 * 3.141592653589793
            + (long double)*(unsigned __int8 *)(v2 + 8) / 255.0 * 3.141592653589793
            + 6.283185307179586;
        v16 = v32;
        v17 = a1[5];
        v18 = *(_DWORD *)(v2 + 204);
        if ( v18 == *(_DWORD *)(v2 + 828) )
        {
          v19 = v17 * 0.029999999;
        }
        else if ( v18 == *(_DWORD *)(v2 + 832) )
        {
          v19 = v17 * 0.0074999998;
        }
        else
        {
          v19 = v17 * 0.0070000002;
        }
        if ( v19 <= 45.0 )
          v15 = v19;
        v29 = sin(v16 + v16);
        v20 = v29;
        v30 = sin(v16 * 4.0 + 1.570796326794897);
        v21 = 45.0;
        *a2 = *a2 - v15 * ((v20 + v30 * 0.2) * 0.75) * (*(float *)(v2 + 184) * *(float *)(v4 + 568));
        v22 = a1[5];
        v23 = *(_DWORD *)(v2 + 204);
        if ( v23 == *(_DWORD *)(v2 + 828) )
        {
          v25 = v22 * 0.029999999;
        }
        else if ( v23 == *(_DWORD *)(v2 + 832) )
        {
          v25 = v22 * 0.0074999998;
        }
        else
        {
          v25 = v22 * 0.0070000002;
        }
        v26 = v25 < 45.0;
        v27 = 0;
        v28 = v25 == 45.0;
        LOBYTE(result) = v24;
        HIBYTE(result) = HIBYTE(v24) & 0x45;
        if ( v25 <= 45.0 )
          v21 = v25;
        v31 = sin(v32);
        a2[1] = a2[1] - v21 * v31 * (*(float *)(v2 + 184) * *(float *)(v4 + 568));
      }
    }
  }
  return result;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A548) --------------------------------------------------------
__int16 __cdecl BG_CalculateWeaponPosition_Sway(int a1, int a2, int a3, int a4, float a5, int a6)
{
  int v6; // edx
  long double v7; // fst7
  long double v8; // fst6
  __int16 v9; // fps
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  __int16 result; // ax
  long double v14; // fst5
  long double v15; // fst4
  long double v16; // fst3
  long double v17; // fst2
  long double v18; // fst6
  long double v19; // fst6
  long double v20; // fst3
  char v21; // fps^1
  long double v22; // fst7
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  char v26; // fps^1
  bool v27; // c0
  char v28; // c2
  bool v29; // c3
  long double v30; // fst6
  long double v31; // fst5
  long double v32; // fst3
  long double v33; // fst4
  long double v34; // fst2
  long double v35; // fst5
  long double v36; // fst3
  long double v37; // fst2
  long double v38; // fst4
  long double v39; // fst2
  long double v40; // fst6
  long double v41; // fst5
  char v42; // fps^1
  bool v43; // c0
  char v44; // c2
  bool v45; // c3
  long double v46; // fst7
  long double v47; // fst5
  long double v48; // fst6
  char v49; // fps^1
  bool v50; // c0
  char v51; // c2
  bool v52; // c3
  long double v53; // fst7
  long double v54; // fst5
  long double v55; // fst4
  long double v56; // fst6
  long double v57; // fst4
  long double v58; // fst7
  long double v59; // fst5
  long double v60; // fst4
  long double v61; // fst6
  long double v62; // fst4
  long double v63; // [esp+18h] [ebp-80h]
  long double v64; // [esp+28h] [ebp-70h]
  long double v65; // [esp+48h] [ebp-50h]
  long double v66; // [esp+58h] [ebp-40h]
  float v67; // [esp+6Ch] [ebp-2Ch]
  float v68; // [esp+88h] [ebp-10h]
  float v69; // [esp+8Ch] [ebp-Ch] BYREF
  float v70; // [esp+90h] [ebp-8h]

  v6 = *(_DWORD *)(dword_7C91C + 4 * *(_DWORD *)(a1 + 176));
  v7 = a5;
  v8 = *(float *)(a1 + 184);
  if ( *(_DWORD *)(v6 + 716) )
  {
    v10 = v8 > 0.0;
    v11 = 0;
    v12 = 0.0 == v8;
    LOBYTE(result) = v9;
    HIBYTE(result) = HIBYTE(v9) & 0x45;
    if ( (HIBYTE(v9) & 0x45) == 1 && *(_DWORD *)(v6 + 552) )
      return result;
    v14 = *(float *)(v6 + 648) + (*(float *)(v6 + 676) - *(float *)(v6 + 648)) * v8;
    v67 = *(float *)(v6 + 652) + (*(float *)(v6 + 680) - *(float *)(v6 + 652)) * v8;
    v15 = *(float *)(v6 + 656) + (*(float *)(v6 + 684) - *(float *)(v6 + 656)) * v8;
    v16 = *(float *)(v6 + 660) + (*(float *)(v6 + 688) - *(float *)(v6 + 660)) * v8;
    v17 = *(float *)(v6 + 664) + (*(float *)(v6 + 692) - *(float *)(v6 + 664)) * v8;
    v18 = v8 * (*(float *)(v6 + 696) - *(float *)(v6 + 668)) + *(float *)(v6 + 668);
  }
  else
  {
    v67 = *(float *)(v6 + 652);
    v18 = *(float *)(v6 + 668);
    v14 = *(float *)(v6 + 648);
    v15 = *(float *)(v6 + 656);
    v17 = *(float *)(v6 + 664);
    v16 = *(float *)(v6 + 660);
  }
  v66 = v7 * v18;
  v65 = v17 * v7;
  v64 = v16 * v7;
  v63 = v15 * v7;
  AnglesSubtract((float *)(a1 + 192), (float *)a2, &v69);
  v19 = v14;
  v20 = -v14;
  v22 = -v14;
  v23 = v69 < v22;
  v24 = 0;
  v25 = v69 == v22;
  if ( (v21 & 0x45) != 1 )
  {
    v22 = v14;
    if ( v69 <= v14 )
      v22 = v69;
  }
  v69 = v22;
  v27 = v70 < v20;
  v28 = 0;
  v29 = v70 == v20;
  if ( (v26 & 0x45) == 1 )
  {
    v30 = v64;
  }
  else
  {
    if ( v70 <= v14 )
      v19 = v70;
    v20 = v19;
    v30 = v64;
  }
  v70 = v20;
  v31 = v65 * v20;
  v68 = v66 * v69;
  v32 = *(float *)(a3 + 4);
  v33 = (long double)a6 * 0.001 * (v67 * (v31 - v32));
  v34 = fabs(v31 - v32);
  if ( v34 > 0.001000000047497451 && fabs(v33) <= v34 )
    v31 = v32 + v33;
  *(float *)(a3 + 4) = v31;
  v35 = v68;
  v36 = *(float *)(a3 + 8);
  v37 = v68 - v36;
  v38 = (long double)a6 * 0.001 * (v67 * v37);
  v39 = fabs(v37);
  if ( v39 > 0.001000000047497451 && fabs(v38) <= v39 )
    v35 = v36 + v38;
  *(float *)(a3 + 8) = v35;
  v70 = v30 * v70;
  v40 = v63 * v69;
  v69 = v40;
  v41 = *(float *)a4;
  v43 = v40 - v41 > 180.0;
  v44 = 0;
  v45 = 180.0 == v40 - v41;
  if ( (v42 & 0x45) == 1 )
  {
    do
      v40 = v40 - 360.0;
    while ( v40 - v41 > 180.0 );
    v69 = v40;
  }
  v46 = v70;
  v47 = *(float *)(a4 + 4);
  v48 = v70 - v47;
  v50 = v48 > 180.0;
  v51 = 0;
  v52 = 180.0 == v48;
  if ( (v49 & 0x45) == 1 )
  {
    do
      v46 = v46 - 360.0;
    while ( v46 - v47 > 180.0 );
    v70 = v46;
  }
  v53 = v69;
  v54 = *(float *)a4;
  v55 = v69 - v54;
  v56 = (long double)a6 * 0.001 * (v67 * v55);
  v57 = fabs(v55);
  if ( v57 > 0.001000000047497451 && fabs(v56) <= v57 )
    v53 = v54 + v56;
  *(float *)a4 = v53;
  v58 = v70;
  v59 = *(float *)(a4 + 4);
  v60 = v70 - v59;
  v61 = (long double)a6 * 0.001 * (v67 * v60);
  v62 = fabs(v60);
  if ( v62 > 0.001000000047497451 && fabs(v61) <= v62 )
    v58 = v59 + v61;
  *(float *)(a4 + 4) = v58;
  *(float *)a4 = AngleNormalize180(*(float *)a4);
  *(float *)(a4 + 4) = AngleNormalize180(*(float *)(a4 + 4));
  result = a2;
  *(float *)a2 = *(float *)(a1 + 192);
  *(float *)(a2 + 4) = *(float *)(a1 + 196);
  *(float *)(a2 + 8) = *(float *)(a1 + 200);
  return result;
}
// 3A6AF: variable 'v21' is possibly undefined
// 3A6D8: variable 'v26' is possibly undefined
// 3A7C6: variable 'v42' is possibly undefined
// 3A80A: variable 'v49' is possibly undefined
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A930) --------------------------------------------------------
__int16 __cdecl BG_CalculateViewAngles(float *a1, int a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  sub_3A2D4((int)a1, (float *)a2);
  return sub_3A3C4(a1, (float *)a2);
}

//----- (0003A970) --------------------------------------------------------
int __cdecl BG_IsAimDownSightWeapon(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 716);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A98C) --------------------------------------------------------
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3)
{
  unsigned int v3; // eax

  if ( !Com_BitCheck(a1 + 780, a3) )
    return 0;
  v3 = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a3) + 120);
  if ( !v3 )
    return 0;
  if ( v3 > 2 )
  {
    if ( v3 > 5 || a2 != v3 )
      return 0;
  }
  else if ( (unsigned int)(a2 - 1) > 1 )
  {
    return 0;
  }
  *(_BYTE *)(a2 + a1 + 788) = a3;
  return 1;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003A9F4) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3)
{
  int v4; // ecx
  int v5; // ebx
  unsigned int v6; // eax

  if ( Com_BitCheck(a1 + 780, a2) )
  {
    v4 = a2;
    do
    {
      v5 = *(_DWORD *)(dword_7C91C + 4 * v4);
      v6 = *(_DWORD *)(v5 + 120);
      if ( !v6 )
        break;
      if ( v6 > 2 )
      {
        if ( v6 > 5 )
          return 0;
        if ( *(char *)(*(_DWORD *)(v5 + 120) + a1 + 788) == v4 )
          return *(_DWORD *)(v5 + 120);
      }
      else
      {
        if ( *(char *)(a1 + 789) == v4 )
          return 1;
        if ( *(char *)(a1 + 790) == v4 )
          return 2;
      }
      if ( a3 )
      {
        if ( *(_DWORD *)(v5 + 764) )
          v4 = *(_DWORD *)(v5 + 764);
      }
    }
    while ( v4 != a2 );
  }
  return 0;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AAAC) --------------------------------------------------------
unsigned int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2)
{
  unsigned int result; // eax

  result = *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a2) + 120);
  if ( !result )
    return 0;
  if ( result <= 2 )
  {
    if ( !*(_BYTE *)(a1 + 789) )
      return 1;
    if ( !*(_BYTE *)(a1 + 790) )
      return 2;
    return 0;
  }
  if ( result > 5 || *(_BYTE *)(result + a1 + 788) )
    return 0;
  return result;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AB04) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2)
{
  int i; // eax
  int v4; // eax

  for ( i = *(_DWORD *)(dword_7C91C + 4 * a1); ; i = *(_DWORD *)(dword_7C91C + 4 * v4) )
  {
    v4 = *(_DWORD *)(i + 764);
    if ( !v4 )
      break;
    if ( v4 == a2 )
      return 1;
    if ( v4 == a1 )
      break;
  }
  return 0;
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AB48) --------------------------------------------------------
int __cdecl BG_AmmoForWeapon(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 416);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AB64) --------------------------------------------------------
int __cdecl BG_ClipForWeapon(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 424);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AB80) --------------------------------------------------------
int __cdecl BG_WeaponIsClipOnly(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 724);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AB9C) --------------------------------------------------------
int __cdecl BG_WeaponAmmo(int a1, int a2)
{
  return *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a2) + 416) + a1 + 268)
       + *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a2) + 424) + a1 + 524);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003ABD4) --------------------------------------------------------
int PM_ClearAimDownSightFlag()
{
  int result; // eax

  result = *(_DWORD *)pm;
  *(_BYTE *)(*(_DWORD *)pm + 12) &= 0xDFu;
  return result;
}
// 16EE30: using guessed type int pm;

//----- (0003ABE8) --------------------------------------------------------
int __cdecl PM_WeaponAmmoAvailable(int a1)
{
  return *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 424) + *(_DWORD *)pm + 524);
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (0003AC14) --------------------------------------------------------
int __cdecl BG_GetWeaponSlotForName(char *s1)
{
  int i; // ebx

  for ( i = 0; i <= 5; ++i )
  {
    if ( !strcasecmp(s1, (&off_7C940)[i]) )
      return i;
  }
  return 0;
}

//----- (0003AC54) --------------------------------------------------------
char *__cdecl BG_GetWeaponSlotNameForIndex(int a1)
{
  return (&off_7C940)[a1];
}

//----- (0003AC68) --------------------------------------------------------
int __cdecl BG_GetInfoForWeapon(int a1)
{
  return *(_DWORD *)(dword_7C91C + 4 * a1);
}
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AC7C) --------------------------------------------------------
int __cdecl BG_GetWeaponForInfo(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0003AC88) --------------------------------------------------------
int BG_GetNumWeapons()
{
  return dword_7C918;
}
// 7C918: using guessed type int dword_7C918;

//----- (0003AC94) --------------------------------------------------------
int BG_GetNumAmmoTypes()
{
  return dword_A98E0;
}
// A98E0: using guessed type int dword_A98E0;

//----- (0003ACA0) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeMax(int a1)
{
  return dword_A97E0[a1];
}

//----- (0003ACB4) --------------------------------------------------------
int BG_GetNumAmmoClips()
{
  return dword_A9D20;
}
// A9D20: using guessed type int dword_A9D20;

//----- (0003ACC0) --------------------------------------------------------
int __cdecl BG_GetAmmoClipSize(int a1)
{
  return dword_A9C20[a1];
}

//----- (0003ACD4) --------------------------------------------------------
int __cdecl BG_GetSharedAmmoCapSize(int a1)
{
  return dword_A9A00[a1];
}
// A9A00: using guessed type int dword_A9A00[];

//----- (0003ACE8) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeName(int a1)
{
  return dword_A96E0[a1];
}

//----- (0003ACFC) --------------------------------------------------------
int __cdecl BG_GetAmmoClipName(int a1)
{
  return dword_A9B20[a1];
}

//----- (0003AD10) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeForName(char *a1)
{
  int v1; // ebx
  int result; // eax

  v1 = 0;
  if ( dword_A98E0 <= 0 )
  {
LABEL_4:
    Com_DPrintf("Couldn't find ammo type \"%s\"\n", a1);
    result = 0;
  }
  else
  {
    while ( Q_stricmp((char *)dword_A96E0[v1], a1) )
    {
      if ( ++v1 >= dword_A98E0 )
        goto LABEL_4;
    }
    result = v1;
  }
  return result;
}
// A98E0: using guessed type int dword_A98E0;

//----- (0003AD64) --------------------------------------------------------
int __cdecl BG_GetAmmoClipForName(char *a1)
{
  int v1; // ebx
  int result; // eax

  v1 = 0;
  if ( dword_A9D20 <= 0 )
  {
LABEL_4:
    Com_DPrintf("Couldn't find ammo clip \"%s\"\n", a1);
    result = 0;
  }
  else
  {
    while ( Q_stricmp((char *)dword_A9B20[v1], a1) )
    {
      if ( ++v1 >= dword_A9D20 )
        goto LABEL_4;
    }
    result = v1;
  }
  return result;
}
// A9D20: using guessed type int dword_A9D20;

//----- (0003ADC0) --------------------------------------------------------
int __cdecl BG_GetWeaponIndexForName(char *a1)
{
  int v1; // ebx
  int result; // eax

  v1 = 0;
  if ( dword_7C918 < 0 )
  {
LABEL_4:
    Com_DPrintf("Couldn't find weapon \"%s\"\n", a1);
    result = 0;
  }
  else
  {
    while ( Q_stricmp(a1, *(char **)(*(_DWORD *)(dword_7C91C + 4 * v1) + 4)) )
    {
      if ( ++v1 > dword_7C918 )
        goto LABEL_4;
    }
    result = (unsigned __int8)v1;
  }
  return result;
}
// 7C918: using guessed type int dword_7C918;
// 7C91C: using guessed type int dword_7C91C;

//----- (0003AE1C) --------------------------------------------------------
char *__cdecl BG_GetWeaponTypeName(int a1)
{
  return (&s2)[a1];
}

//----- (0003AE30) --------------------------------------------------------
__int16 __cdecl sub_3AE30(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edx

  LOWORD(v1) = pm;
  if ( *(_BYTE *)(pm + 10) )
  {
    v2 = *(_DWORD *)pm;
    v3 = *(_DWORD *)(*(_DWORD *)pm + 980);
    v1 = v3;
    BYTE1(v1) = BYTE1(v3) & 0xFD;
    if ( v1 != a1 && *(int *)(v2 + 4) <= 5 )
    {
      v4 = v3 & 0x200;
      BYTE1(v4) ^= 2u;
      *(_DWORD *)(v2 + 980) = a1 | v4;
    }
  }
  return v1;
}
// 16EE30: using guessed type int pm;

//----- (0003AE70) --------------------------------------------------------
char *__cdecl sub_3AE70(int a1, char *src)
{
  return sub_35A54(a1, src);
}

//----- (0003AE8C) --------------------------------------------------------
int __cdecl compare_weaponfile_names(const void *a1, const void *a2)
{
  return Q_stricmp(*(char **)a1, *(char **)a2);
}

//----- (0003AEAC) --------------------------------------------------------
int __cdecl PM_WeaponUseAmmo(int a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int result; // eax

  v2 = 4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 424);
  v3 = *(_DWORD *)pm + 524;
  result = *(_DWORD *)(v2 + v3) - a2;
  *(_DWORD *)(v2 + v3) = result;
  return result;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (0003AEE0) --------------------------------------------------------
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1)
{
  return *(_DWORD *)(4 * *(_DWORD *)(*(_DWORD *)(dword_7C91C + 4 * a1) + 424) + *(_DWORD *)pm + 524) == 0;
}
// 7C91C: using guessed type int dword_7C91C;
// 16EE30: using guessed type int pm;

//----- (0003AF1C) --------------------------------------------------------
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4)
{
  int v4; // eax
  long double v5; // fst7
  long double v6; // fst6
  float v8; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD *)(a1 + 204);
  if ( v4 == *(_DWORD *)(a1 + 828) )
  {
    v5 = a4;
    v6 = a3 * 0.029999999;
  }
  else
  {
    v5 = a4;
    if ( v4 == *(_DWORD *)(a1 + 832) )
      v6 = a3 * 0.0074999998;
    else
      v6 = a3 * 0.0070000002;
  }
  if ( v6 <= v5 )
    v5 = v6;
  v8 = sin(a2);
  return v5 * v8;
}

//----- (0003AF80) --------------------------------------------------------
int __cdecl RotatePointAroundVector(int a1, int a2, int a3, float a4)
{
  int v4; // edx
  int result; // eax
  long double v6; // fst7
  float v7; // [esp+1Ch] [ebp-ECh]
  float v8; // [esp+30h] [ebp-D8h]
  float v9; // [esp+34h] [ebp-D4h]
  float v10; // [esp+38h] [ebp-D0h]
  float v11; // [esp+3Ch] [ebp-CCh]
  float v12; // [esp+40h] [ebp-C8h]
  float v13; // [esp+44h] [ebp-C4h]
  float v14; // [esp+48h] [ebp-C0h] BYREF
  float v15; // [esp+4Ch] [ebp-BCh]
  float v16; // [esp+50h] [ebp-B8h]
  float v17[9]; // [esp+54h] [ebp-B4h] BYREF
  float v18[9]; // [esp+78h] [ebp-90h] BYREF
  float s; // [esp+9Ch] [ebp-6Ch] BYREF
  float v20; // [esp+A0h] [ebp-68h]
  float v21; // [esp+A8h] [ebp-60h]
  float v22; // [esp+ACh] [ebp-5Ch]
  float v23; // [esp+BCh] [ebp-4Ch]
  float v24[9]; // [esp+C0h] [ebp-48h] BYREF
  float v25[9]; // [esp+E4h] [ebp-24h] BYREF

  v8 = *(float *)a2;
  v9 = *(float *)(a2 + 4);
  v10 = *(float *)(a2 + 8);
  PerpendicularVector(&v14, (float *)a2);
  v25[0] = v14;
  v25[3] = v15;
  v25[6] = v16;
  v25[2] = v8;
  v11 = v15 * v10 - v16 * v9;
  v25[1] = v11;
  v12 = v16 * v8 - v14 * v10;
  v25[4] = v12;
  v25[5] = v9;
  v25[8] = v10;
  v13 = v14 * v9 - v8 * v15;
  v25[7] = v13;
  qmemcpy(v24, v25, sizeof(v24));
  v24[1] = v15;
  v24[2] = v16;
  v24[3] = v11;
  v24[5] = v13;
  v24[6] = v8;
  v24[7] = v9;
  _bzero(&s, 0x24u);
  v23 = 1.0;
  v7 = 3.141592653589793 * a4 / 180.0;
  s = cos(v7);
  v20 = sin(v7);
  v21 = -v20;
  v22 = s;
  MatrixMultiply(v25, &s, v18);
  MatrixMultiply(v18, v24, v17);
  v4 = 0;
  result = 0;
  do
  {
    v6 = v17[result] * *(float *)a3 + v17[result + 1] * *(float *)(a3 + 4) + v17[result + 2] * *(float *)(a3 + 8);
    result += 3;
    *(float *)(a1 + 4 * v4++) = v6;
  }
  while ( v4 <= 2 );
  return result * 4;
}

//----- (0003B140) --------------------------------------------------------
int __cdecl MakeNormalVectors(float *a1, float *a2, float *a3)
{
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst5
  long double v6; // fst3
  long double v7; // fst4
  long double v8; // rtt
  long double v9; // fst4
  long double v10; // fst7
  long double v11; // fst5
  long double v12; // fst4
  long double v13; // fst6
  __int16 v14; // fps
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int result; // eax
  long double v19; // fst4
  float v20; // [esp+24h] [ebp-4h]

  v3 = -*a1;
  a2[1] = v3;
  v4 = a1[1];
  a2[2] = a1[1];
  v5 = a1[2];
  *a2 = a1[2];
  v6 = -(v5 * *a1 + v3 * a1[1] + v4 * a1[2]);
  v7 = *a1 * v6 + v5;
  *a2 = v7;
  v8 = v7;
  v9 = v3 + a1[1] * v6;
  v10 = v8;
  a2[1] = v9;
  v11 = v9;
  v12 = v6 * a1[2] + v4;
  a2[2] = v12;
  v13 = v12;
  v20 = sqrt(v11 * v11 + v8 * v8 + v12 * v12);
  v15 = v20 > 0.0;
  v16 = 0;
  v17 = 0.0 == v20;
  LOBYTE(result) = v14;
  BYTE1(result) = HIBYTE(v14) & 0x45;
  if ( (HIBYTE(v14) & 0x45) != 64 )
  {
    v19 = 1.0 / v20;
    *a2 = v10 * v19;
    a2[1] = v11 * v19;
    a2[2] = v13 * v19;
  }
  *a3 = a2[1] * a1[2] - a2[2] * a1[1];
  a3[1] = a2[2] * *a1 - *a2 * a1[2];
  a3[2] = *a2 * a1[1] - a2[1] * *a1;
  return result;
}

//----- (0003B228) --------------------------------------------------------
float *__cdecl AngleVectors(float *a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  long double v5; // fst6
  long double v6; // fst7
  long double v7; // fst0
  long double v8; // fst1
  long double v9; // fst6
  long double v10; // fst0
  long double v11; // fst1
  long double v12; // fst6
  float v13; // [esp+14h] [ebp-34h]
  float v14; // [esp+18h] [ebp-30h]
  float v15; // [esp+1Ch] [ebp-2Ch] BYREF
  float v16; // [esp+20h] [ebp-28h]
  float v17; // [esp+24h] [ebp-24h]
  float v18; // [esp+28h] [ebp-20h] BYREF
  float v19; // [esp+2Ch] [ebp-1Ch]
  float v20; // [esp+30h] [ebp-18h]
  float v21; // [esp+34h] [ebp-14h]

  v19 = 0.0174532925199433 * a1[1];
  v20 = cos(v19);
  v21 = sin(v19);
  result = &v18;
  v16 = 0.0174532925199433 * *a1;
  v17 = cos(v16);
  v18 = sin(v16);
  if ( a2 )
  {
    v5 = v17;
    *a2 = v17 * v20;
    a2[1] = v5 * v21;
    a2[2] = -v18;
  }
  if ( a3 || a4 )
  {
    result = &v15;
    v13 = 0.0174532925199433 * a1[2];
    v14 = cos(v13);
    v15 = sin(v13);
    if ( a3 )
    {
      v6 = -v15;
      v7 = -v14;
      v8 = v6 * v18;
      v9 = v8 * v20 + -v21 * v7;
      a3[1] = v21 * v8 + v7 * v20;
      *a3 = v9;
      a3[2] = v6 * v17;
    }
    if ( a4 )
    {
      v10 = -v15;
      v11 = v14 * v18;
      v12 = -v21 * v10 + v11 * v20;
      result = a4;
      a4[1] = v21 * v11 + v10 * v20;
      *a4 = v12;
      a4[2] = v14 * v17;
    }
  }
  return result;
}

//----- (0003B34C) --------------------------------------------------------
__int16 __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst4
  long double v6; // fst5
  long double v7; // fst6
  long double v8; // rt0
  long double v9; // fst4
  long double v10; // fst5
  long double v11; // rt1
  long double v12; // fst4
  long double v13; // fst6
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst4
  long double v19; // fst7
  long double v20; // fst4
  long double v21; // fst5
  long double v22; // fst6
  long double v23; // rt0
  long double v24; // fst4
  long double v25; // fst5
  long double v26; // rt1
  long double v27; // fst4
  long double v28; // fst6
  char v29; // fps^1
  bool v30; // c0
  char v31; // c2
  bool v32; // c3
  long double v33; // fst4
  long double v34; // fst3
  long double v35; // fst6
  long double v36; // fst4
  long double v37; // fst5
  long double v38; // rt0
  long double v39; // fst4
  long double v40; // fst6
  long double v41; // rt1
  long double v42; // fst4
  long double v43; // fst5
  __int16 v44; // fps
  bool v45; // c0
  char v46; // c2
  bool v47; // c3
  __int16 result; // ax
  long double v49; // fst4
  float v50; // [esp+1Ch] [ebp-1Ch]
  float v51; // [esp+1Ch] [ebp-1Ch]
  float v52; // [esp+1Ch] [ebp-1Ch]
  float v53; // [esp+20h] [ebp-18h]
  float v54; // [esp+24h] [ebp-14h]
  float v55; // [esp+28h] [ebp-10h]
  float v56; // [esp+2Ch] [ebp-Ch]
  float v57; // [esp+30h] [ebp-8h]
  float v58; // [esp+34h] [ebp-4h]

  v4 = *a1 - *a2;
  v56 = v4;
  v5 = a1[1] - a2[1];
  v57 = v5;
  v6 = a1[2] - a2[2];
  v7 = v5 * v5 + v4 * v4 + v6 * v6;
  v8 = v5;
  v9 = v6;
  v10 = v8;
  v58 = v9;
  v11 = v9;
  v12 = v7;
  v13 = v11;
  v50 = sqrt(v12);
  v15 = v50 > 0.0;
  v16 = 0;
  v17 = 0.0 == v50;
  if ( (v14 & 0x45) != 64 )
  {
    v18 = 1.0 / v50;
    v56 = v4 * v18;
    v57 = v10 * v18;
    v58 = v13 * v18;
  }
  v19 = *a1 - *a3;
  v53 = v19;
  v20 = a1[1] - a3[1];
  v54 = v20;
  v21 = a1[2] - a3[2];
  v22 = v20 * v20 + v19 * v19 + v21 * v21;
  v23 = v20;
  v24 = v21;
  v25 = v23;
  v55 = v24;
  v26 = v24;
  v27 = v22;
  v28 = v26;
  v51 = sqrt(v27);
  v30 = v51 > 0.0;
  v31 = 0;
  v32 = 0.0 == v51;
  if ( (v29 & 0x45) != 64 )
  {
    v33 = 1.0 / v51;
    v53 = v19 * v33;
    v54 = v25 * v33;
    v55 = v28 * v33;
  }
  v34 = v57 * v55 - v58 * v54;
  *a4 = v34;
  v35 = v58 * v53 - v55 * v56;
  v36 = v54 * v56 - v53 * v57;
  v37 = v35 * v35 + v34 * v34 + v36 * v36;
  a4[2] = v36;
  v38 = v36;
  v39 = v35;
  v40 = v38;
  a4[1] = v39;
  v41 = v39;
  v42 = v37;
  v43 = v41;
  v52 = sqrt(v42);
  v45 = v52 > 0.0;
  v46 = 0;
  v47 = 0.0 == v52;
  LOBYTE(result) = v44;
  HIBYTE(result) = HIBYTE(v44) & 0x45;
  if ( (HIBYTE(v44) & 0x45) != 64 )
  {
    v49 = 1.0 / v52;
    *a4 = v34 * v49;
    a4[1] = v43 * v49;
    a4[2] = v40 * v49;
  }
  return result;
}
// 3B3A2: variable 'v14' is possibly undefined
// 3B40E: variable 'v29' is possibly undefined

//----- (0003B4C8) --------------------------------------------------------
int __cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst5
  long double v7; // rt1
  long double v8; // fst5
  long double v9; // fst6
  long double v10; // fst4
  long double v11; // fst7
  long double v12; // rt1
  long double v13; // fst4
  long double v14; // fst7
  __int16 v15; // fps
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  int result; // eax
  long double v20; // fst4
  long double v21; // fst4
  float v22; // [esp+1Ch] [ebp-1Ch]
  float v23; // [esp+20h] [ebp-18h]
  float v24; // [esp+24h] [ebp-14h]
  float v25; // [esp+28h] [ebp-10h]
  float v26; // [esp+2Ch] [ebp-Ch]
  float v27; // [esp+30h] [ebp-8h]
  float v28; // [esp+34h] [ebp-4h]

  HIWORD(result) = HIWORD(a1);
  v4 = *a2;
  v26 = *a1 - v4;
  v5 = a2[1];
  v27 = a1[1] - v5;
  v6 = *a3 - v4;
  v23 = v6;
  v7 = v6;
  v8 = a3[1] - v5;
  v9 = v7;
  v24 = v8;
  v10 = a3[2] - a2[2];
  v11 = v7 * v7 + v8 * v8 + v10 * v10;
  v25 = v10;
  v12 = v10;
  v13 = v11;
  v14 = v12;
  v22 = sqrt(v13);
  v16 = v22 > 0.0;
  v17 = 0;
  v18 = 0.0 == v22;
  LOBYTE(result) = v15;
  BYTE1(result) = HIBYTE(v15) & 0x45;
  if ( (HIBYTE(v15) & 0x45) != 64 )
  {
    v20 = 1.0 / v22;
    v23 = v9 * v20;
    v24 = v8 * v20;
    v25 = v14 * v20;
  }
  v28 = a1[2] - a2[2];
  v21 = v27 * v24 + v26 * v23 + v28 * v25;
  *a4 = v23 * v21 + *a2;
  a4[1] = v24 * v21 + a2[1];
  a4[2] = v21 * v25 + a2[2];
  return result;
}

//----- (0003B5A8) --------------------------------------------------------
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (0003B6B8) --------------------------------------------------------
float *__cdecl MatrixMultiplyEquals(float *a1, float *a2)
{
  float *result; // eax
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // fst4
  long double v6; // fst3
  long double v7; // fst6
  float v8; // [esp+14h] [ebp-24h]
  float v9; // [esp+14h] [ebp-24h]
  float v10; // [esp+18h] [ebp-20h]
  float v11; // [esp+18h] [ebp-20h]
  float v12; // [esp+1Ch] [ebp-1Ch]
  float v13; // [esp+20h] [ebp-18h]
  float v14; // [esp+2Ch] [ebp-Ch]
  float v15; // [esp+30h] [ebp-8h]

  result = a2;
  v3 = a1[2];
  v13 = a1[1] * a2[3] + *a1 * *a2 + v3 * a2[6];
  v4 = *a1 * a2[1] + a1[1] * a2[4] + v3 * a2[7];
  v12 = *a1 * a2[2] + a1[1] * a2[5] + v3 * a2[8];
  v5 = a1[5];
  v14 = a1[4] * a2[3] + a1[3] * *a2 + v5 * a2[6];
  v15 = a1[3] * a2[1] + a1[4] * a2[4] + v5 * a2[7];
  v6 = v5 * a2[8] + a1[4] * a2[5] + a1[3] * a2[2];
  a2[6] = *a2 * a1[6] + a2[3] * a1[7] + a2[6] * a1[8];
  v10 = a2[1] * a1[6];
  v11 = a2[4] * a1[7] + v10;
  a2[7] = a2[7] * a1[8] + v11;
  v8 = a2[2] * a1[6];
  v9 = a2[5] * a1[7] + v8;
  v7 = a2[8] * a1[8] + v9;
  *a2 = v13;
  a2[1] = v4;
  a2[8] = v7;
  a2[2] = v12;
  a2[3] = v14;
  a2[4] = v15;
  a2[5] = v6;
  return result;
}

//----- (0003B7FC) --------------------------------------------------------
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a1;
  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9];
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10];
  a3[3] = *a1 * a2[3] + a1[1] * a2[7] + a1[2] * a2[11] + a1[3];
  a3[4] = a1[4] * *a2 + a1[5] * a2[4] + a1[6] * a2[8];
  a3[5] = a1[4] * a2[1] + a1[5] * a2[5] + a1[6] * a2[9];
  a3[6] = a1[4] * a2[2] + a1[5] * a2[6] + a1[6] * a2[10];
  a3[7] = a1[4] * a2[3] + a1[5] * a2[7] + a1[6] * a2[11] + a1[7];
  a3[8] = a1[8] * *a2 + a1[9] * a2[4] + a1[10] * a2[8];
  a3[9] = a1[8] * a2[1] + a1[9] * a2[5] + a1[10] * a2[9];
  a3[10] = a1[8] * a2[2] + a1[9] * a2[6] + a1[10] * a2[10];
  a3[11] = a1[8] * a2[3] + a1[9] * a2[7] + a1[10] * a2[11] + a1[11];
  return result;
}

//----- (0003B96C) --------------------------------------------------------
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  a3[9] = a1[9] * *a2 + a1[10] * a2[3] + a1[11] * a2[6] + a2[9];
  a3[10] = a1[9] * a2[1] + a1[10] * a2[4] + a1[11] * a2[7] + a2[10];
  a3[11] = a1[9] * a2[2] + a1[10] * a2[5] + a1[11] * a2[8] + a2[11];
  return result;
}

//----- (0003BADC) --------------------------------------------------------
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  a3[6] = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  a3[7] = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  a3[8] = a1[8] * a2[2] + a1[9] * a2[5] + a1[10] * a2[8];
  a3[9] = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  a3[10] = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  a3[11] = a1[12] * a2[2] + a1[13] * a2[5] + a1[14] * a2[8] + a2[11];
  return result;
}

//----- (0003BC4C) --------------------------------------------------------
float *__cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3)
{
  float *result; // eax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7

  result = a2;
  *(float *)a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  *(float *)(a3 + 16) = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  *(float *)(a3 + 32) = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  *(float *)(a3 + 4) = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  *(float *)(a3 + 20) = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  *(float *)(a3 + 36) = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  *(float *)(a3 + 8) = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  *(float *)(a3 + 24) = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  v5 = a1[8] * result[2] + a1[9] * result[5];
  v6 = a1[10] * a2[8];
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 44) = 0;
  *(float *)(a3 + 40) = v5 + v6;
  *(float *)(a3 + 48) = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  *(float *)(a3 + 52) = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  v7 = a1[12] * result[2] + a1[13] * result[5] + a1[14] * result[8] + result[11];
  *(_DWORD *)(a3 + 60) = 1065353216;
  *(float *)(a3 + 56) = v7;
  return result;
}

//----- (0003BDD8) --------------------------------------------------------
float *__cdecl MatrixInverse(float *a1, float *a2)
{
  float *result; // eax
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // rt2

  result = a1;
  v3 = a1[4];
  v4 = a1[8] * v3 - a1[7] * a1[5];
  v5 = 1.0 / ((a1[1] * a1[5] - v3 * a1[2]) * a1[6] + *a1 * v4 - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]);
  *a2 = v4 * v5;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v5;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v5;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v5;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v5;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v5;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v5;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v5;
  a2[8] = v5 * (a1[4] * *a1 - a1[3] * a1[1]);
  return result;
}

//----- (0003BEF8) --------------------------------------------------------
float *__cdecl MatrixInverse44(float *a1, float *a2)
{
  float *result; // eax
  int i; // ecx
  long double v5; // fst5
  long double v6; // fst4
  long double v7; // fst3
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst4
  long double v11; // rt1
  long double v12; // fst4
  long double v13; // rt2
  long double v14; // fst4
  long double v15; // fst3
  int v16; // ecx
  long double v17; // fst7
  float v18; // [esp+10h] [ebp-C8h]
  float v19; // [esp+14h] [ebp-C4h]
  float v20; // [esp+18h] [ebp-C0h]
  float v21; // [esp+1Ch] [ebp-BCh]
  float v22; // [esp+20h] [ebp-B8h]
  float v23; // [esp+24h] [ebp-B4h]
  float v24; // [esp+28h] [ebp-B0h]
  float v25; // [esp+2Ch] [ebp-ACh]
  float v26; // [esp+30h] [ebp-A8h]
  float v27; // [esp+34h] [ebp-A4h]
  float v28; // [esp+38h] [ebp-A0h]
  float v29; // [esp+3Ch] [ebp-9Ch]
  float v30; // [esp+3Ch] [ebp-9Ch]
  float v31; // [esp+3Ch] [ebp-9Ch]
  float v32; // [esp+3Ch] [ebp-9Ch]
  float v33; // [esp+40h] [ebp-98h]
  float v34; // [esp+40h] [ebp-98h]
  float v35; // [esp+40h] [ebp-98h]
  float v36; // [esp+44h] [ebp-94h]
  float v37; // [esp+44h] [ebp-94h]
  float v38; // [esp+44h] [ebp-94h]
  float v39; // [esp+48h] [ebp-90h]
  float v40; // [esp+48h] [ebp-90h]
  float v41; // [esp+48h] [ebp-90h]
  float v42; // [esp+48h] [ebp-90h]
  float v43; // [esp+4Ch] [ebp-8Ch]
  float v44; // [esp+50h] [ebp-88h]
  float v45; // [esp+54h] [ebp-84h]
  float v46; // [esp+58h] [ebp-80h]
  float v47; // [esp+5Ch] [ebp-7Ch]
  float v48; // [esp+60h] [ebp-78h]
  float v49; // [esp+64h] [ebp-74h]
  float v50; // [esp+68h] [ebp-70h] BYREF
  float v51; // [esp+6Ch] [ebp-6Ch]
  float v52; // [esp+70h] [ebp-68h]
  float v53; // [esp+74h] [ebp-64h]
  float v54; // [esp+78h] [ebp-60h]
  float v55; // [esp+7Ch] [ebp-5Ch]
  float v56; // [esp+80h] [ebp-58h]
  float v57; // [esp+84h] [ebp-54h]
  float v58; // [esp+88h] [ebp-50h]
  float v59; // [esp+8Ch] [ebp-4Ch]
  float v60; // [esp+90h] [ebp-48h]
  float v61; // [esp+94h] [ebp-44h]
  float v62; // [esp+98h] [ebp-40h]
  float v63; // [esp+9Ch] [ebp-3Ch]
  float v64; // [esp+A0h] [ebp-38h]
  float v65; // [esp+A4h] [ebp-34h]
  float v66; // [esp+A8h] [ebp-30h]
  float v67; // [esp+ACh] [ebp-2Ch]
  float v68; // [esp+B0h] [ebp-28h]
  float v69; // [esp+B4h] [ebp-24h]
  float v70; // [esp+B8h] [ebp-20h]
  float v71; // [esp+BCh] [ebp-1Ch]
  float v72; // [esp+C0h] [ebp-18h]
  float v73; // [esp+C4h] [ebp-14h]
  float v74; // [esp+C8h] [ebp-10h]
  float v75; // [esp+CCh] [ebp-Ch]
  float v76; // [esp+D0h] [ebp-8h]
  float v77; // [esp+D4h] [ebp-4h]

  result = &v50;
  for ( i = 3; i >= 0; --i )
  {
    *result = *a1;
    result[4] = a1[1];
    result[8] = a1[2];
    result[12] = a1[3];
    a1 += 4;
    ++result;
  }
  v49 = v59 * v65;
  v48 = v58 * v65;
  v47 = v61 * v62;
  v46 = v58 * v64;
  v45 = v60 * v62;
  v5 = v60 * v65;
  v44 = v58 * v63;
  v6 = v61 * v63;
  v39 = v5 * v55;
  v7 = v61 * v64;
  v8 = v59 * v64;
  v43 = v59 * v62;
  v9 = v60 * v63;
  v40 = v6 * v56 + v39;
  v41 = v8 * v57 + v40;
  v42 = v41 - (v7 * v55 + v49 * v56 + v9 * v57);
  *a2 = v42;
  v36 = v48 * v56 + v7 * v54;
  v37 = v45 * v57 + v36;
  v38 = v37 - (v5 * v54 + v47 * v56 + v46 * v57);
  a2[1] = v38;
  v33 = v47 * v55 + v49 * v54;
  v34 = v44 * v57 + v33;
  v35 = v34 - (v6 * v54 + v48 * v55 + v43 * v57);
  a2[2] = v35;
  v29 = v9 * v54;
  v30 = v46 * v55 + v29;
  v31 = v43 * v56 + v30;
  v32 = v31 - (v8 * v54 + v45 * v55 + v44 * v56);
  a2[3] = v32;
  v27 = v52;
  v28 = v51;
  v26 = v53;
  a2[4] = v9 * v53 + v7 * v51 + v49 * v52 - (v5 * v51 + v6 * v52 + v8 * v53);
  a2[5] = v46 * v26 + v5 * v50 + v47 * v27 - (v7 * v50 + v48 * v27 + v45 * v26);
  a2[6] = v43 * v26 + v6 * v50 + v48 * v28 - (v49 * v50 + v47 * v28 + v44 * v26);
  a2[7] = v44 * v27 + v45 * v28 + v8 * v50 - (v46 * v28 + v9 * v50 + v43 * v27);
  v25 = v26 * v56;
  v67 = v25;
  v24 = v28 * v57;
  v68 = v24;
  v23 = v26 * v55;
  v69 = v23;
  v22 = v28 * v56;
  v70 = v22;
  v21 = v27 * v55;
  v71 = v21;
  v20 = v26 * v54;
  v73 = v20;
  v10 = v27 * v57;
  v66 = v10;
  v11 = v10;
  v12 = v50 * v57;
  v72 = v12;
  v13 = v12;
  v14 = v50 * v56;
  v74 = v14;
  v19 = v27 * v54;
  v75 = v19;
  v18 = v28 * v54;
  v77 = v18;
  v15 = v50 * v55;
  v76 = v15;
  a2[8] = v22 * v65 + v11 * v63 + v23 * v64 - (v21 * v65 + v25 * v63 + v24 * v64);
  a2[9] = v19 * v65 + v13 * v64 + v25 * v62 - (v11 * v62 + v20 * v64 + v14 * v65);
  a2[10] = v24 * v62 + v20 * v63 + v15 * v65 - (v23 * v62 + v13 * v63 + v18 * v65);
  a2[11] = v18 * v64 + v21 * v62 + v14 * v63 - (v22 * v62 + v19 * v63 + v15 * v64);
  a2[12] = v24 * v60 + v21 * v61 + v25 * v59 - (v22 * v61 + v11 * v59 + v23 * v60);
  a2[13] = v20 * v60 + v11 * v58 + v14 * v61 - (v13 * v60 + v19 * v61 + v25 * v58);
  a2[14] = v23 * v58 + v18 * v61 + v13 * v59 - (v15 * v61 + v24 * v58 + v20 * v59);
  a2[15] = v19 * v59 + v22 * v58 + v15 * v60 - (v18 * v60 + v14 * v59 + v21 * v58);
  v16 = 0;
  v17 = 1.0 / (v27 * v35 + v28 * v38 + v50 * v42 + v26 * v32);
  do
  {
    a2[v16] = a2[v16] * v17;
    ++v16;
  }
  while ( v16 <= 15 );
  return result;
}

//----- (0003C59C) --------------------------------------------------------
int __cdecl ConvertQuatToMat(int a1)
{
  long double v1; // fst5
  long double v2; // fst4
  long double v3; // fst3
  __int16 v4; // fps
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  int result; // eax
  long double v9; // fst3
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst2
  long double v13; // fst1
  long double v14; // fst5
  long double v15; // fst4
  long double v16; // fst3
  long double v17; // rt1
  long double v18; // rt2
  float v19; // [esp+18h] [ebp-10h]
  float v20; // [esp+1Ch] [ebp-Ch]
  float v21; // [esp+1Ch] [ebp-Ch]
  float v22; // [esp+20h] [ebp-8h]
  float v23; // [esp+24h] [ebp-4h]
  float v24; // [esp+24h] [ebp-4h]
  float v25; // [esp+24h] [ebp-4h]

  v23 = *(float *)a1 * *(float *)a1;
  v20 = *(float *)(a1 + 4) * *(float *)(a1 + 4);
  v19 = *(float *)(a1 + 8);
  v1 = *(float *)(a1 + 12);
  v2 = v19 * v19;
  v3 = v1 * v1 + v23 + v20 + v2;
  v5 = v3 > 0.0;
  v6 = 0;
  v7 = 0.0 == v3;
  LOBYTE(result) = v4;
  BYTE1(result) = HIBYTE(v4) & 0x45;
  if ( (HIBYTE(v4) & 0x45) == 64 )
  {
    *(_DWORD *)a1 = 1065353216;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 1065353216;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 1065353216;
  }
  else
  {
    v9 = 2.0 / v3;
    v24 = v23 * v9;
    v21 = v20 * v9;
    v10 = *(float *)a1 * v9;
    v11 = v10 * *(float *)(a1 + 4);
    v12 = *(float *)(a1 + 4) * v9;
    v13 = v10 * v1;
    v14 = v12 * v1;
    v22 = v13;
    v15 = v2 * v9;
    v16 = v9 * (*(float *)(a1 + 12) * v19);
    v17 = v10 * v19;
    v18 = v12 * v19;
    *(float *)a1 = 1.0 - (v21 + v15);
    *(float *)(a1 + 4) = v11 + v16;
    *(float *)(a1 + 12) = v11 - v16;
    *(float *)(a1 + 8) = v17 - v14;
    *(float *)(a1 + 16) = 1.0 - (v15 + v24);
    *(float *)(a1 + 24) = v14 + v17;
    *(float *)(a1 + 20) = v18 + v22;
    *(float *)(a1 + 28) = v18 - v22;
    v25 = v24 + v21;
    *(float *)(a1 + 32) = 1.0 - v25;
  }
  return result;
}

//----- (0003C6E4) --------------------------------------------------------
long double __cdecl QuatRatioEigenTrace(float *a1, float *a2)
{
  long double v2; // fst7
  long double v3; // fst1
  long double v4; // fst3
  long double v5; // fst0
  long double v6; // fst7
  long double v7; // fst6
  long double v8; // fst4
  long double v9; // rt2
  long double v10; // fst7
  char v11; // fps^1
  long double v12; // fst5
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  long double result; // fst7
  float v17; // [esp+8h] [ebp-30h]
  float v18; // [esp+10h] [ebp-28h]
  float v19; // [esp+14h] [ebp-24h]
  float v20; // [esp+34h] [ebp-4h]

  v19 = -*a2;
  v18 = -a2[1];
  v2 = -a2[2];
  v20 = a2[3];
  v17 = *a1;
  v3 = v17 * v2 + a1[1] * v20 - a1[2] * v19 + a1[3] * v18;
  v4 = a1[2] * v2;
  v5 = a1[2] * v18 + a1[3] * v19 + v17 * v20 - a1[1] * v2;
  v6 = v2 * a1[3] + a1[2] * v20 + a1[1] * v19 - v17 * v18;
  v7 = v3 * v3;
  v8 = v5 * v5;
  v9 = a1[3] * v20 - v17 * v19 - a1[1] * v18 - v4;
  v10 = v6 * v6;
  v12 = v9 * v9 + v8 + v7 + v10;
  v13 = v12 > 0.0;
  v14 = 0;
  v15 = 0.0 == v12;
  if ( (v11 & 0x45) == 64 )
    result = 0.0;
  else
    result = v7 * (1.0 / v12) + v8 * (1.0 / v12) + 1.0 / v12 * v10;
  return result;
}
// 3C7D9: variable 'v11' is possibly undefined

//----- (0003C808) --------------------------------------------------------
__int16 __cdecl AxisToAngles(float *a1, int a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  char v12; // fps^1
  long double v13; // fst6
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  long double v19; // fst6
  char v20; // fps^1
  long double v21; // fst3
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  char v25; // fps^1
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  long double v29; // rt2
  long double v30; // fst5
  long double v31; // fst7
  long double v32; // fst4
  long double v33; // fst7
  long double v34; // fst5
  char v35; // fps^1
  bool v36; // c0
  char v37; // c2
  bool v38; // c3
  char v39; // fps^1
  long double v40; // rt1
  long double v41; // fst5
  long double v42; // fst7
  bool v43; // c0
  char v44; // c2
  bool v45; // c3
  long double v46; // fst5
  long double v47; // fst7
  __int16 v48; // fps
  bool v49; // c0
  char v50; // c2
  bool v51; // c3
  __int16 result; // ax
  bool v53; // c0
  char v54; // c2
  bool v55; // c3
  long double v56; // fst7
  float v57; // [esp+18h] [ebp-40h]
  float v58; // [esp+1Ch] [ebp-3Ch]
  float v59; // [esp+20h] [ebp-38h]
  float v60; // [esp+20h] [ebp-38h]
  float v61; // [esp+24h] [ebp-34h]
  float v62; // [esp+24h] [ebp-34h]
  float v63; // [esp+48h] [ebp-10h]
  float v64; // [esp+48h] [ebp-10h]
  float v65; // [esp+48h] [ebp-10h]
  float v66; // [esp+48h] [ebp-10h]
  float v67; // [esp+48h] [ebp-10h]
  float v68; // [esp+4Ch] [ebp-Ch]
  float v69; // [esp+4Ch] [ebp-Ch]
  float v70; // [esp+50h] [ebp-8h]
  float v71; // [esp+50h] [ebp-8h]
  float v72; // [esp+54h] [ebp-4h]
  float v73; // [esp+54h] [ebp-4h]

  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, v7 & 0x44 ^ 0x40) )
  {
    v63 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v21 = v63;
    v22 = v63 < 0.0;
    v23 = 0;
    v24 = v63 == 0.0;
    if ( (v20 & 0x45) == 1 )
      v21 = v21 + 360.0;
    v13 = v21;
    v64 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v65 = (double)atan2(a1[2], v64) * -180.0 / 3.141592653589793;
    v26 = v65 < 0.0;
    v27 = 0;
    v28 = v65 == 0.0;
    v14 = v65;
    if ( (v25 & 0x45) == 1 )
    {
      v18 = v21;
      v19 = v65 + 360.0;
      goto LABEL_9;
    }
  }
  else
  {
    v13 = 0.0;
    v14 = 90.0;
    v15 = a1[2] > 0.0;
    v16 = 0;
    v17 = 0.0 == a1[2];
    if ( (v12 & 0x45) == 1 )
    {
      v18 = 0.0;
      v19 = 270.0;
LABEL_9:
      v29 = v19;
      v13 = v18;
      v14 = v29;
      goto LABEL_10;
    }
  }
LABEL_10:
  *(float *)a2 = v14;
  *(float *)(a2 + 4) = v13;
  *(_DWORD *)(a2 + 8) = 0;
  v68 = a1[3];
  v70 = a1[4];
  v72 = a1[5];
  v58 = 3.141592653589793 * -v13 / 180.0;
  v59 = cos(v58);
  v61 = sin(v58);
  v30 = v61 * v70;
  v71 = v59 * v70 + v61 * v68;
  v31 = v68 * v59 - v30;
  v57 = 3.141592653589793 * -*(float *)a2 / 180.0;
  v60 = cos(v57);
  v62 = sin(v57);
  v32 = v62 * v31;
  v33 = v31 * v60 + v72 * v62;
  v34 = v60 * v72 - v32;
  v73 = v34;
  v69 = v33;
  v36 = v71 < 0.0;
  v37 = 0;
  v38 = v71 == 0.0;
  if ( (v35 & 0x44) != 0x40
    || (v40 = v34, v41 = v33, v42 = v40, v43 = v41 < 0.0, v44 = 0, v45 = v41 == 0.0, v39 & 0x44 ^ 0x40) )
  {
    v66 = sqrt(v69 * v69 + v71 * v71);
    v67 = (double)atan2(v73, v66) * -180.0 / 3.141592653589793;
    v47 = v67;
  }
  else
  {
    v46 = v42;
    v47 = 90.0;
    if ( v46 > 0.0 )
      v47 = -90.0;
  }
  v49 = v71 > 0.0;
  v50 = 0;
  v51 = 0.0 == v71;
  LOBYTE(result) = v48;
  HIBYTE(result) = HIBYTE(v48) & 0x45;
  if ( v71 >= 0.0 )
  {
    v56 = -v47;
  }
  else
  {
    v53 = v47 > 0.0;
    v54 = 0;
    v55 = 0.0 == v47;
    LOBYTE(result) = v48;
    HIBYTE(result) = HIBYTE(v48) & 0x45;
    if ( v47 >= 0.0 )
      v56 = v47 + -180.0;
    else
      v56 = v47 + 180.0;
  }
  *(float *)(a2 + 8) = v56;
  return result;
}
// 3C81E: variable 'v2' is possibly undefined
// 3C82C: variable 'v7' is possibly undefined
// 3C841: variable 'v12' is possibly undefined
// 3C88D: variable 'v20' is possibly undefined
// 3C8D0: variable 'v25' is possibly undefined
// 3C9A3: variable 'v35' is possibly undefined
// 3C9B1: variable 'v39' is possibly undefined

//----- (0003CA44) --------------------------------------------------------
__int16 __cdecl Axis4ToAngles(float *a1, int a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  char v12; // fps^1
  long double v13; // fst6
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  long double v19; // fst6
  char v20; // fps^1
  long double v21; // fst3
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  char v25; // fps^1
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  long double v29; // rt2
  long double v30; // fst5
  long double v31; // fst7
  long double v32; // fst4
  long double v33; // fst7
  long double v34; // fst5
  char v35; // fps^1
  bool v36; // c0
  char v37; // c2
  bool v38; // c3
  char v39; // fps^1
  long double v40; // rt1
  long double v41; // fst5
  long double v42; // fst7
  bool v43; // c0
  char v44; // c2
  bool v45; // c3
  long double v46; // fst5
  long double v47; // fst7
  __int16 v48; // fps
  bool v49; // c0
  char v50; // c2
  bool v51; // c3
  __int16 result; // ax
  bool v53; // c0
  char v54; // c2
  bool v55; // c3
  long double v56; // fst7
  float v57; // [esp+18h] [ebp-40h]
  float v58; // [esp+1Ch] [ebp-3Ch]
  float v59; // [esp+20h] [ebp-38h]
  float v60; // [esp+20h] [ebp-38h]
  float v61; // [esp+24h] [ebp-34h]
  float v62; // [esp+24h] [ebp-34h]
  float v63; // [esp+48h] [ebp-10h]
  float v64; // [esp+48h] [ebp-10h]
  float v65; // [esp+48h] [ebp-10h]
  float v66; // [esp+48h] [ebp-10h]
  float v67; // [esp+48h] [ebp-10h]
  float v68; // [esp+4Ch] [ebp-Ch]
  float v69; // [esp+4Ch] [ebp-Ch]
  float v70; // [esp+50h] [ebp-8h]
  float v71; // [esp+50h] [ebp-8h]
  float v72; // [esp+54h] [ebp-4h]
  float v73; // [esp+54h] [ebp-4h]

  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, v7 & 0x44 ^ 0x40) )
  {
    v63 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v21 = v63;
    v22 = v63 < 0.0;
    v23 = 0;
    v24 = v63 == 0.0;
    if ( (v20 & 0x45) == 1 )
      v21 = v21 + 360.0;
    v13 = v21;
    v64 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v65 = (double)atan2(a1[2], v64) * -180.0 / 3.141592653589793;
    v26 = v65 < 0.0;
    v27 = 0;
    v28 = v65 == 0.0;
    v14 = v65;
    if ( (v25 & 0x45) == 1 )
    {
      v18 = v21;
      v19 = v65 + 360.0;
      goto LABEL_9;
    }
  }
  else
  {
    v13 = 0.0;
    v14 = 90.0;
    v15 = a1[2] > 0.0;
    v16 = 0;
    v17 = 0.0 == a1[2];
    if ( (v12 & 0x45) == 1 )
    {
      v18 = 0.0;
      v19 = 270.0;
LABEL_9:
      v29 = v19;
      v13 = v18;
      v14 = v29;
      goto LABEL_10;
    }
  }
LABEL_10:
  *(float *)a2 = v14;
  *(float *)(a2 + 4) = v13;
  *(_DWORD *)(a2 + 8) = 0;
  v68 = a1[4];
  v70 = a1[5];
  v72 = a1[6];
  v58 = 3.141592653589793 * -v13 / 180.0;
  v59 = cos(v58);
  v61 = sin(v58);
  v30 = v61 * v70;
  v71 = v59 * v70 + v61 * v68;
  v31 = v68 * v59 - v30;
  v57 = 3.141592653589793 * -*(float *)a2 / 180.0;
  v60 = cos(v57);
  v62 = sin(v57);
  v32 = v62 * v31;
  v33 = v31 * v60 + v72 * v62;
  v34 = v60 * v72 - v32;
  v73 = v34;
  v69 = v33;
  v36 = v71 < 0.0;
  v37 = 0;
  v38 = v71 == 0.0;
  if ( (v35 & 0x44) != 0x40
    || (v40 = v34, v41 = v33, v42 = v40, v43 = v41 < 0.0, v44 = 0, v45 = v41 == 0.0, v39 & 0x44 ^ 0x40) )
  {
    v66 = sqrt(v69 * v69 + v71 * v71);
    v67 = (double)atan2(v73, v66) * -180.0 / 3.141592653589793;
    v47 = v67;
  }
  else
  {
    v46 = v42;
    v47 = 90.0;
    if ( v46 > 0.0 )
      v47 = -90.0;
  }
  v49 = v71 > 0.0;
  v50 = 0;
  v51 = 0.0 == v71;
  LOBYTE(result) = v48;
  HIBYTE(result) = HIBYTE(v48) & 0x45;
  if ( v71 >= 0.0 )
  {
    v56 = -v47;
  }
  else
  {
    v53 = v47 > 0.0;
    v54 = 0;
    v55 = 0.0 == v47;
    LOBYTE(result) = v48;
    HIBYTE(result) = HIBYTE(v48) & 0x45;
    if ( v47 >= 0.0 )
      v56 = v47 + -180.0;
    else
      v56 = v47 + 180.0;
  }
  *(float *)(a2 + 8) = v56;
  return result;
}
// 3CA5A: variable 'v2' is possibly undefined
// 3CA68: variable 'v7' is possibly undefined
// 3CA7D: variable 'v12' is possibly undefined
// 3CAC9: variable 'v20' is possibly undefined
// 3CB0C: variable 'v25' is possibly undefined
// 3CBDF: variable 'v35' is possibly undefined
// 3CBED: variable 'v39' is possibly undefined

//----- (0003CC84) --------------------------------------------------------
__int16 __cdecl AxisToSignedAngles(float *a1, int a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  char v12; // fps^1
  long double v13; // fst6
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  long double v19; // fst6
  long double v20; // rtt
  long double v21; // fst5
  long double v22; // fst7
  long double v23; // fst4
  long double v24; // fst7
  long double v25; // fst5
  char v26; // fps^1
  bool v27; // c0
  char v28; // c2
  bool v29; // c3
  char v30; // fps^1
  long double v31; // rt2
  long double v32; // fst5
  long double v33; // fst7
  bool v34; // c0
  char v35; // c2
  bool v36; // c3
  long double v37; // fst5
  long double v38; // fst7
  __int16 v39; // fps
  bool v40; // c0
  char v41; // c2
  bool v42; // c3
  __int16 result; // ax
  bool v44; // c0
  char v45; // c2
  bool v46; // c3
  long double v47; // fst7
  float v48; // [esp+18h] [ebp-40h]
  float v49; // [esp+1Ch] [ebp-3Ch]
  float v50; // [esp+20h] [ebp-38h]
  float v51; // [esp+20h] [ebp-38h]
  float v52; // [esp+24h] [ebp-34h]
  float v53; // [esp+24h] [ebp-34h]
  float v54; // [esp+48h] [ebp-10h]
  float v55; // [esp+48h] [ebp-10h]
  float v56; // [esp+48h] [ebp-10h]
  float v57; // [esp+48h] [ebp-10h]
  float v58; // [esp+48h] [ebp-10h]
  float v59; // [esp+4Ch] [ebp-Ch]
  float v60; // [esp+4Ch] [ebp-Ch]
  float v61; // [esp+50h] [ebp-8h]
  float v62; // [esp+50h] [ebp-8h]
  float v63; // [esp+54h] [ebp-4h]
  float v64; // [esp+54h] [ebp-4h]

  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, v7 & 0x44 ^ 0x40) )
  {
    v54 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v18 = v54;
    v55 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v56 = (double)atan2(a1[2], v55) * -180.0 / 3.141592653589793;
    v19 = v56;
    goto LABEL_6;
  }
  v13 = 0.0;
  v14 = 90.0;
  v15 = a1[2] > 0.0;
  v16 = 0;
  v17 = 0.0 == a1[2];
  if ( (v12 & 0x45) == 1 )
  {
    v18 = 0.0;
    v19 = -90.0;
LABEL_6:
    v20 = v19;
    v13 = v18;
    v14 = v20;
  }
  *(float *)a2 = v14;
  *(float *)(a2 + 4) = v13;
  *(_DWORD *)(a2 + 8) = 0;
  v59 = a1[3];
  v61 = a1[4];
  v63 = a1[5];
  v49 = 3.141592653589793 * -v13 / 180.0;
  v50 = cos(v49);
  v52 = sin(v49);
  v21 = v52 * v61;
  v62 = v50 * v61 + v52 * v59;
  v22 = v59 * v50 - v21;
  v48 = 3.141592653589793 * -*(float *)a2 / 180.0;
  v51 = cos(v48);
  v53 = sin(v48);
  v23 = v53 * v22;
  v24 = v22 * v51 + v63 * v53;
  v25 = v51 * v63 - v23;
  v64 = v25;
  v60 = v24;
  v27 = v62 < 0.0;
  v28 = 0;
  v29 = v62 == 0.0;
  if ( (v26 & 0x44) != 0x40
    || (v31 = v25, v32 = v24, v33 = v31, v34 = v32 < 0.0, v35 = 0, v36 = v32 == 0.0, v30 & 0x44 ^ 0x40) )
  {
    v57 = sqrt(v60 * v60 + v62 * v62);
    v58 = (double)atan2(v64, v57) * -180.0 / 3.141592653589793;
    v38 = v58;
  }
  else
  {
    v37 = v33;
    v38 = 90.0;
    if ( v37 > 0.0 )
      v38 = -90.0;
  }
  v40 = v62 > 0.0;
  v41 = 0;
  v42 = 0.0 == v62;
  LOBYTE(result) = v39;
  HIBYTE(result) = HIBYTE(v39) & 0x45;
  if ( v62 >= 0.0 )
  {
    v47 = -v38;
  }
  else
  {
    v44 = v38 > 0.0;
    v45 = 0;
    v46 = 0.0 == v38;
    LOBYTE(result) = v39;
    HIBYTE(result) = HIBYTE(v39) & 0x45;
    if ( v38 >= 0.0 )
      v47 = v38 + -180.0;
    else
      v47 = v38 + 180.0;
  }
  *(float *)(a2 + 8) = v47;
  return result;
}
// 3CC9A: variable 'v2' is possibly undefined
// 3CCA8: variable 'v7' is possibly undefined
// 3CCBD: variable 'v12' is possibly undefined
// 3CDEA: variable 'v26' is possibly undefined
// 3CDF8: variable 'v30' is possibly undefined

//----- (0003CE8C) --------------------------------------------------------
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4)
{
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst5
  long double v7; // fst4
  long double v8; // fst3
  long double v9; // rt0
  long double v10; // rt1
  long double v11; // rt2
  long double v12; // fst2
  long double v13; // fst3
  long double v14; // fst7
  long double v15; // fst5
  long double v16; // fst6
  long double v17; // fst4
  char v18; // fps^1
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst7
  long double v23; // fst4
  long double v24; // fst6
  long double v25; // fst5
  long double v26; // fst7
  char v27; // fps^1
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  int result; // eax
  float v32; // [esp+1Ch] [ebp-1Ch]

  v4 = *a2;
  v5 = *a3 - v4;
  v6 = a2[1];
  v7 = a3[1] - v6;
  v8 = a2[2];
  v9 = a3[2] - v8;
  v10 = *a4 - v4;
  v11 = a4[1] - v6;
  v12 = a4[2] - v8;
  v13 = v11 * v9 - v12 * v7;
  v14 = v5 * v12 - v9 * v10;
  v15 = v7 * v10 - v11 * v5;
  *a1 = v13;
  a1[2] = v15;
  a1[1] = v14;
  v16 = v14;
  v32 = sqrt(v15 * v15 + v13 * v13 + v14 * v14);
  v17 = v32;
  v19 = v32 > 0.0;
  v20 = 0;
  v21 = 0.0 == v32;
  if ( (v18 & 0x45) == 64 )
  {
    v24 = v32;
    v26 = 0.0;
  }
  else
  {
    v22 = v15 * (1.0 / v17);
    *a1 = v13 * (1.0 / v17);
    v23 = v16 * (1.0 / v17);
    v24 = v32;
    a1[1] = v23;
    v25 = v22;
    v26 = 0.0;
    a1[2] = v25;
  }
  v28 = v24 < v26;
  v29 = 0;
  v30 = v24 == v26;
  if ( (v27 & 0x45) == 64 )
    return 0;
  result = 1;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return result;
}
// 3CF31: variable 'v18' is possibly undefined
// 3CF5D: variable 'v27' is possibly undefined

//----- (0003CF90) --------------------------------------------------------
float *__cdecl VectorRotateAngles(float *a1, int a2, float *a3)
{
  int v3; // esi
  int *v4; // ecx
  long double v5; // fst7
  long double v6; // fst5
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  long double v13; // rt1
  long double v14; // fst6
  long double v15; // fst6
  long double v16; // fst7
  float *result; // eax
  int v18; // [esp+28h] [ebp-30h]
  int v19[5]; // [esp+2Ch] [ebp-2Ch] BYREF
  float v20; // [esp+40h] [ebp-18h] BYREF
  float v21; // [esp+44h] [ebp-14h]
  float v22; // [esp+48h] [ebp-10h]
  float v23; // [esp+4Ch] [ebp-Ch] BYREF
  float v24; // [esp+50h] [ebp-8h]
  float v25; // [esp+54h] [ebp-4h]

  v3 = 0;
  v4 = v19;
  v5 = *a1;
  v20 = *a1;
  v21 = a1[1];
  v6 = a1[2];
  v22 = a1[2];
  v23 = v5;
  v24 = v21;
  v25 = v6;
  v18 = 1;
  v19[0] = 2;
  v19[1] = 2;
  v19[2] = 0;
  v19[3] = 0;
  v19[4] = 1;
  do
  {
    v8 = *(float *)(a2 + 4 * v3);
    v9 = v8 < 0.0;
    v10 = 0;
    v11 = v8 == 0.0;
    if ( (v7 & 0x45) != 64 )
    {
      v12 = *(float *)(a2 + 4 * v3) * 3.141592653589793 / 180.0;
      v13 = sin(v12);
      v14 = cos(v12);
      *(&v23 + *(v4 - 1)) = v14 * *(&v20 + *(v4 - 1)) - v13 * *(&v20 + *v4);
      *(&v23 + *v4) = v13 * *(&v20 + *(v4 - 1)) + v14 * *(&v20 + *v4);
    }
    v20 = v23;
    v15 = v24;
    v21 = v24;
    v22 = v25;
    v4 += 2;
    ++v3;
  }
  while ( v3 <= 2 );
  v16 = v25;
  result = a3;
  *a3 = v23;
  a3[1] = v15;
  a3[2] = v16;
  return result;
}
// 3D001: variable 'v7' is possibly undefined

//----- (0003D098) --------------------------------------------------------
long double __cdecl RoundFloat(float a1, int a2)
{
  long double v2; // fst7
  int v3; // edx
  int v4; // ecx
  char v5; // fps^1
  long double v6; // fst5
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst7
  long double v14; // fst7
  char v15; // fps^1
  long double v16; // fst7
  long double v17; // fst7
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst7
  int v22; // edx
  int v23; // ecx
  char v24; // fps^1
  long double v25; // fst5
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  long double v29; // fst7
  long double v30; // fst6
  long double v31; // fst7
  long double v33; // fst7
  double iptr[2]; // [esp+10h] [ebp-48h] BYREF
  double v37; // [esp+3Ch] [ebp-1Ch]
  __int64 v38; // [esp+48h] [ebp-10h]
  __int16 v39; // [esp+50h] [ebp-8h]
  __int16 v40; // [esp+52h] [ebp-6h]
  int v41; // [esp+54h] [ebp-4h]

  v2 = (long double)a2;
  v39 = v40 | 0xC00;
  v4 = (unsigned __int64)(__int64)v2 >> 32;
  v3 = (__int64)v2;
  v38 = (__int64)v2;
  v6 = (long double)(__int64)v2;
  v7 = v6 < v2;
  v8 = 0;
  v9 = v6 == v2;
  if ( (v5 & 0x44) != 0x40 )
  {
    _FST6 = v2 * __FYL2X__(10.0, 1.0);
    v14 = _FST6;
    __asm { frndint }
    v37 = __F2XM1__(v14 - _FST6) + 1.0;
    v12 = v37;
  }
  else
  {
    v10 = 10.0;
    v11 = 1.0;
    if ( __PAIR64__(v4, v3) )
    {
      if ( v4 < 0 )
      {
        v10 = 0.1;
        v3 = -v3;
        v4 = (unsigned __int64)-__SPAIR64__(v4, v3) >> 32;
      }
      while ( 1 )
      {
        if ( (v3 & 1) != 0 )
          v11 = v11 * v10;
        v3 = __PAIR64__(v4, v3) >> 1;
        v4 >>= 1;
        if ( !__PAIR64__(v4, v3) )
          break;
        v10 = v10 * v10;
      }
      v37 = v11;
      v12 = (double)v11;
    }
    else
    {
      v12 = 1.0;
    }
  }
  iptr[0] = v12 * a1;
  v16 = modf(iptr[0], iptr);
  if ( v16 < 0.5 )
  {
    v18 = v16 < -0.5;
    v19 = 0;
    v20 = v16 == -0.5;
    if ( (unsigned __int8)((v15 & 0x45) - 1) >= 0x40u )
      goto LABEL_17;
    v17 = iptr[0] + -1.0;
  }
  else
  {
    v17 = iptr[0] + 1.0;
  }
  iptr[0] = v17;
LABEL_17:
  v41 = a2;
  v21 = (long double)a2;
  v39 = v40 | 0xC00;
  v23 = (unsigned __int64)(__int64)v21 >> 32;
  v22 = (__int64)v21;
  v38 = (__int64)v21;
  v25 = (long double)(__int64)v21;
  v26 = v25 < v21;
  v27 = 0;
  v28 = v25 == v21;
  if ( (v24 & 0x44) != 0x40 )
  {
    _FST6 = v21 * __FYL2X__(0.1, 1.0);
    v33 = _FST6;
    __asm { frndint }
    v30 = __F2XM1__(v33 - _FST6) + 1.0;
LABEL_27:
    v37 = v30;
    v31 = (double)v30;
    return (float)(v31 * iptr[0]);
  }
  v29 = 0.1;
  v30 = 1.0;
  if ( __PAIR64__(v23, v22) )
  {
    if ( v23 < 0 )
    {
      v29 = 10.0;
      v22 = -v22;
      v23 = (unsigned __int64)-__SPAIR64__(v23, v22) >> 32;
    }
    while ( 1 )
    {
      if ( (v22 & 1) != 0 )
        v30 = v30 * v29;
      v22 = __PAIR64__(v23, v22) >> 1;
      v23 >>= 1;
      if ( !__PAIR64__(v23, v22) )
        break;
      v29 = v29 * v29;
    }
    goto LABEL_27;
  }
  v31 = 1.0;
  return (float)(v31 * iptr[0]);
}
// 3D0D9: variable 'v5' is possibly undefined
// 3D198: variable 'v15' is possibly undefined
// 3D1E7: variable 'v24' is possibly undefined

//----- (0003D274) --------------------------------------------------------
long double __cdecl PitchForYawOnNormal(float a1, int a2)
{
  long double v3; // fst3
  long double v4; // fst6
  long double v5; // fst5
  long double v6; // fst4
  char v7; // fps^1
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double result; // fst7
  float v15; // [esp+18h] [ebp-50h]
  float v16; // [esp+1Ch] [ebp-4Ch]
  float v17; // [esp+20h] [ebp-48h]
  float v18; // [esp+24h] [ebp-44h]
  float v19; // [esp+3Ch] [ebp-2Ch]
  float v20; // [esp+3Ch] [ebp-2Ch]
  float v21; // [esp+50h] [ebp-18h]
  float v22; // [esp+58h] [ebp-10h]

  v16 = 0.0174532925199433 * a1;
  v17 = cos(v16);
  v18 = sin(v16);
  v3 = 1.0
     / (*(float *)(a2 + 8) * *(float *)(a2 + 8) + *(float *)(a2 + 4) * *(float *)(a2 + 4) + *(float *)a2 * *(float *)a2);
  v4 = (*(float *)(a2 + 4) * v18 + *(float *)a2 * v17 + *(float *)(a2 + 8) * 0.0) * v3;
  v15 = v18 - v4 * (*(float *)(a2 + 4) * v3);
  v5 = v17 - v4 * (*(float *)a2 * v3);
  v6 = 0.0 - v4 * (v3 * *(float *)(a2 + 8));
  v8 = v15 < 0.0;
  v9 = 0;
  v10 = v15 == 0.0;
  if ( (v7 & 0x44) != 0x40 || (v11 = v5 < 0.0, v12 = 0, v13 = v5 == 0.0, v7 & 0x44 ^ 0x40) )
  {
    v21 = v5;
    v19 = sqrt(v21 * v21 + v15 * v15);
    v22 = v6;
    v20 = (double)atan2(v22, v19) * -180.0 / 3.141592653589793;
    result = v20;
    if ( v20 < 0.0 )
      result = result + 360.0;
  }
  else
  {
    result = 90.0;
    if ( v6 > 0.0 )
      result = 270.0;
  }
  return result;
}
// 3D33E: variable 'v7' is possibly undefined

//----- (0003D3C0) --------------------------------------------------------
int __cdecl Q_rand(int *a1)
{
  int result; // eax

  result = 69069 * *a1 + 1;
  *a1 = result;
  return result;
}

//----- (0003D3D4) --------------------------------------------------------
long double __cdecl Q_random(int *a1)
{
  int v1; // eax

  v1 = 69069 * *a1 + 1;
  *a1 = v1;
  return (long double)(unsigned __int16)v1 * 0.000015258789;
}

//----- (0003D3FC) --------------------------------------------------------
long double __cdecl Q_crandom(int *a1)
{
  int v1; // eax

  v1 = 69069 * *a1 + 1;
  *a1 = v1;
  return (long double)(unsigned __int16)v1 * 0.000015258789
       - 0.5
       + (long double)(unsigned __int16)v1 * 0.000015258789
       - 0.5;
}

//----- (0003D42C) --------------------------------------------------------
int __cdecl Rand_Init(int a1)
{
  int result; // eax

  result = a1;
  dword_7DCD8 = a1;
  return result;
}
// 7DCD8: using guessed type int dword_7DCD8;

//----- (0003D43C) --------------------------------------------------------
long double __cdecl flrand(float a1, float a2)
{
  dword_7DCD8 = 214013 * dword_7DCD8 + 2531011;
  return a1 + (long double)((unsigned int)dword_7DCD8 >> 17) * (a2 - a1) * 0.000030517578;
}
// 7DCD8: using guessed type int dword_7DCD8;

//----- (0003D47C) --------------------------------------------------------
int __cdecl irand(int a1, int a2)
{
  dword_7DCD8 = 214013 * dword_7DCD8 + 2531011;
  return ((int)((a2 - a1) * ((unsigned int)dword_7DCD8 >> 17)) >> 15) + a1;
}
// 7DCD8: using guessed type int dword_7DCD8;

//----- (0003D4AC) --------------------------------------------------------
float *__cdecl gunrandom(float *a1, float *a2)
{
  float *result; // eax
  long double v3; // rt0
  long double v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+2Ch] [ebp-1Ch]
  float v6; // [esp+30h] [ebp-18h]
  float v7; // [esp+34h] [ebp-14h] BYREF
  int v8; // [esp+44h] [ebp-4h]

  v4 = (long double)rand() * -4.6566129e-10 * 360.0;
  v8 = rand();
  result = &v7;
  v3 = (long double)v8 * -4.6566129e-10;
  v5 = 3.141592653589793 * v4 / 180.0;
  v6 = cos(v5);
  v7 = sin(v5);
  *a1 = v3 * v6;
  *a2 = v3 * v7;
  return result;
}
// 3D4F1: returning address of temporary local variable '%var_14'

//----- (0003D520) --------------------------------------------------------
int __cdecl Q_log2(int a1)
{
  int result; // eax

  for ( result = 0; ; ++result )
  {
    a1 >>= 1;
    if ( !a1 )
      break;
  }
  return result;
}

//----- (0003D53C) --------------------------------------------------------
long double __cdecl Q_acos(float a1)
{
  long double result; // fst7
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  float v7; // [esp+34h] [ebp-4h]

  v7 = atan2(sqrt(1.0 - a1 * a1), a1);
  result = v7;
  v3 = v7;
  if ( v7 > 3.141592653589793 || (v4 = v3 < -3.141592653589793, v5 = 0, v6 = v3 == -3.141592653589793, (v2 & 0x45) == 1) )
    result = 3.1415927;
  return result;
}
// 3D576: variable 'v2' is possibly undefined

//----- (0003D590) --------------------------------------------------------
int __cdecl ClampChar(int a1)
{
  if ( a1 < -128 )
    return -128;
  if ( a1 > 127 )
    return 127;
  return (char)a1;
}

//----- (0003D5BC) --------------------------------------------------------
int __cdecl ClampShort(int a1)
{
  if ( a1 < -32768 )
    return -32768;
  if ( a1 > 0x7FFF )
    return 0x7FFF;
  return (__int16)a1;
}

//----- (0003D5EC) --------------------------------------------------------
int __cdecl DirToByte(float *a1)
{
  long double v2; // fst7
  unsigned __int8 v3; // cl
  unsigned __int8 i; // dl
  long double v5; // fst3

  if ( !a1 )
    return 0;
  v2 = 0.0;
  v3 = 0;
  for ( i = 0; i <= 0xA1u; ++i )
  {
    v5 = *a1 * bytedirs[3 * i] + a1[1] * bytedirs[3 * i + 1] + a1[2] * bytedirs[3 * i + 2];
    if ( v5 > v2 )
    {
      v2 = v5;
      v3 = i;
    }
  }
  return v3;
}
// 7D540: using guessed type float bytedirs[];

//----- (0003D66C) --------------------------------------------------------
int __cdecl ByteToDir(unsigned int a1, float *a2)
{
  int result; // eax
  long double v3; // fst7

  result = a1;
  if ( a1 <= 0xA1 )
  {
    result = 12 * a1;
    *a2 = bytedirs[3 * a1];
    a2[1] = bytedirs[3 * a1 + 1];
    v3 = bytedirs[3 * a1 + 2];
  }
  else
  {
    *a2 = 0.0;
    a2[1] = *(&vec3_origin + 1);
    v3 = *(&vec3_origin + 2);
  }
  a2[2] = v3;
  return result;
}
// 72910: using guessed type float vec3_origin;
// 7D540: using guessed type float bytedirs[];

//----- (0003D6BC) --------------------------------------------------------
long double __cdecl DotProduct(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (0003D6E4) --------------------------------------------------------
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (0003D70C) --------------------------------------------------------
float *__cdecl VectorAdd(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (0003D734) --------------------------------------------------------
float *__cdecl VectorCopy(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  return result;
}

//----- (0003D754) --------------------------------------------------------
int __cdecl VectorScale(int a1, float a2, int a3)
{
  int result; // eax

  result = a3;
  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = a2 * *(float *)(a1 + 8);
  return result;
}

//----- (0003D778) --------------------------------------------------------
int __cdecl VectorMA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  result = a3;
  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (0003D7A8) --------------------------------------------------------
int __cdecl VectorCompareEpsilon(int a1, int a2)
{
  int i; // ebx
  long double v3; // fst6

  for ( i = 0; i <= 2; ++i )
  {
    v3 = *(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i);
    if ( v3 * v3 > 0.0000010000001 )
      return 0;
  }
  return 1;
}

//----- (0003D7EC) --------------------------------------------------------
long double __cdecl VectorDistance(float *a1, float *a2)
{
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst5

  v2 = *a2 - *a1;
  v3 = a2[1] - a1[1];
  v4 = a2[2] - a1[2];
  return (float)sqrt(v3 * v3 + v2 * v2 + v4 * v4);
}

//----- (0003D830) --------------------------------------------------------
long double __cdecl VectorDistanceSquared(float *a1, float *a2)
{
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst5

  v2 = *a2 - *a1;
  v3 = a2[1] - a1[1];
  v4 = a2[2] - a1[2];
  return v3 * v3 + v2 * v2 + v4 * v4;
}

//----- (0003D86C) --------------------------------------------------------
float *__cdecl CrossProduct(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (0003D8B8) --------------------------------------------------------
int __cdecl CrossProductUp(float *a1, int a2)
{
  int result; // eax
  long double v3; // fst7

  result = a2;
  *(float *)a2 = a1[1];
  v3 = -*a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(float *)(a2 + 4) = v3;
  return result;
}

//----- (0003D8D8) --------------------------------------------------------
long double __cdecl VectorNormalize(float *a1)
{
  long double v1; // fst4
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst5
  long double v7; // fst6
  long double result; // fst7
  float v9; // [esp+14h] [ebp-4h]

  v9 = sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  v1 = v9;
  v3 = v9 > 0.0;
  v4 = 0;
  v5 = 0.0 == v9;
  if ( (v2 & 0x45) == 64 )
    return v9;
  v6 = a1[1] * (1.0 / v1);
  v7 = a1[2] * (1.0 / v1);
  result = v9;
  *a1 = *a1 * (1.0 / v1);
  a1[1] = v6;
  a1[2] = v7;
  return result;
}
// 3D90D: variable 'v2' is possibly undefined

//----- (0003D938) --------------------------------------------------------
long double __cdecl VectorNormalize2D(float *a1)
{
  long double v1; // fst5
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst6
  long double result; // fst7
  float v8; // [esp+14h] [ebp-4h]

  v8 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
  v1 = v8;
  v3 = v8 > 0.0;
  v4 = 0;
  v5 = 0.0 == v8;
  if ( (v2 & 0x45) == 64 )
    return v8;
  v6 = a1[1] * (1.0 / v1);
  result = v8;
  *a1 = *a1 * (1.0 / v1);
  a1[1] = v6;
  return result;
}
// 3D964: variable 'v2' is possibly undefined

//----- (0003D988) --------------------------------------------------------
long double __cdecl VectorNormalize4D(float *a1)
{
  long double v1; // fst3
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst5
  long double v7; // fst6
  long double v8; // fst4
  long double result; // fst7
  float v10; // [esp+14h] [ebp-4h]

  v10 = sqrt(a1[2] * a1[2] + a1[1] * a1[1] + *a1 * *a1 + a1[3] * a1[3]);
  v1 = v10;
  v3 = v10 > 0.0;
  v4 = 0;
  v5 = 0.0 == v10;
  if ( (v2 & 0x45) == 64 )
    return v10;
  v6 = a1[1] * (1.0 / v1);
  v7 = a1[2] * (1.0 / v1);
  v8 = a1[3] * (1.0 / v1);
  result = v10;
  *a1 = *a1 * (1.0 / v1);
  a1[1] = v6;
  a1[2] = v7;
  a1[3] = v8;
  return result;
}
// 3D9C8: variable 'v2' is possibly undefined

//----- (0003D9FC) --------------------------------------------------------
int __cdecl VectorNormalizeFast(float *a1)
{
  long double v1; // fst5
  long double v2; // fst6
  long double v3; // fst4
  int result; // eax
  long double v5; // fst4
  int v6; // [esp+14h] [ebp-4h]

  v1 = a1[1];
  v2 = a1[2];
  v3 = v1 * v1 + *a1 * *a1 + v2 * v2;
  *(float *)&v6 = v3;
  result = 1597463007 - (v6 >> 1);
  v5 = *(float *)&result * (1.5 - v3 * 0.5 * *(float *)&result * *(float *)&result);
  *a1 = *a1 * v5;
  a1[1] = v1 * v5;
  a1[2] = v2 * v5;
  return result;
}

//----- (0003DA68) --------------------------------------------------------
long double __cdecl VectorNormalize2(float *a1, float *a2)
{
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  long double v7; // fst6
  long double result; // fst7
  float v9; // [esp+14h] [ebp-4h]

  v9 = sqrt(a1[1] * a1[1] + *a1 * *a1 + a1[2] * a1[2]);
  v3 = v9 > 0.0;
  v4 = 0;
  v5 = 0.0 == v9;
  if ( (v2 & 0x45) == 64 )
  {
    result = v9;
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    v6 = 1.0 / v9;
    *a2 = *a1 * v6;
    a2[1] = a1[1] * v6;
    v7 = v6;
    result = v9;
    a2[2] = v7 * a1[2];
  }
  return result;
}
// 3DA98: variable 'v2' is possibly undefined

//----- (0003DAD8) --------------------------------------------------------
float *__cdecl VectorInverse(float *a1)
{
  float *result; // eax

  result = a1;
  *a1 = -*a1;
  a1[1] = -a1[1];
  a1[2] = -a1[2];
  return result;
}

//----- (0003DAF8) --------------------------------------------------------
int __cdecl Vector4Scale(int a1, float a2, int a3)
{
  int result; // eax

  result = a3;
  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  *(float *)(a3 + 12) = a2 * *(float *)(a1 + 12);
  return result;
}

//----- (0003DB24) --------------------------------------------------------
long double __cdecl VectorMax(float *a1)
{
  long double result; // fst7
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3

  result = *a1;
  v3 = a1[1];
  v4 = v3 < result;
  v5 = 0;
  v6 = v3 == result;
  if ( (unsigned __int8)((v2 & 0x45) - 1) >= 0x40u )
    result = a1[1];
  v8 = a1[2];
  v9 = v8 < result;
  v10 = 0;
  v11 = v8 == result;
  if ( (unsigned __int8)((v7 & 0x45) - 1) >= 0x40u )
    result = a1[2];
  return result;
}
// 3DB33: variable 'v2' is possibly undefined
// 3DB4A: variable 'v7' is possibly undefined

//----- (0003DB60) --------------------------------------------------------
float *__cdecl VectorRotate(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (0003DBC4) --------------------------------------------------------
long double __cdecl VectorDistance2D(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-18h]
  float v4; // [esp+14h] [ebp-14h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  return (float)sqrt(v3 * v3 + v4 * v4);
}

//----- (0003DBFC) --------------------------------------------------------
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2)
{
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  return v3 * v3 + v4 * v4;
}

//----- (0003DC2C) --------------------------------------------------------
int __cdecl RotateAroundDirection(int a1, float a2)
{
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst6
  long double v7; // fst7
  int result; // eax
  int v9[3]; // [esp+1Ch] [ebp-Ch] BYREF

  PerpendicularVector((float *)(a1 + 12), (float *)a1);
  v3 = a2 < 0.0;
  v4 = 0;
  v5 = a2 == 0.0;
  if ( (v2 & 0x45) != 64 )
  {
    v9[0] = *(int *)(a1 + 12);
    v9[1] = *(int *)(a1 + 16);
    v9[2] = *(int *)(a1 + 20);
    RotatePointAroundVector(a1 + 12, a1, (int)v9, a2);
  }
  v6 = *(float *)(a1 + 8) * *(float *)(a1 + 12);
  v7 = *(float *)a1;
  *(float *)(a1 + 24) = *(float *)(a1 + 4) * *(float *)(a1 + 20) - *(float *)(a1 + 8) * *(float *)(a1 + 16);
  result = a1 + 24;
  *(float *)(a1 + 28) = v6 - v7 * *(float *)(a1 + 20);
  *(float *)(a1 + 32) = *(float *)a1 * *(float *)(a1 + 16) - *(float *)(a1 + 4) * *(float *)(a1 + 12);
  return result;
}
// 3DC50: variable 'v2' is possibly undefined

//----- (0003DCCC) --------------------------------------------------------
long double __cdecl vectoyaw(float *a1)
{
  long double result; // fst7
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  float v12; // [esp+24h] [ebp-4h]

  result = 0.0;
  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, (v7 & 0x45) != 64) )
  {
    v12 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    result = v12;
    if ( v12 < 0.0 )
      result = result + 360.0;
  }
  return result;
}
// 3DCDE: variable 'v2' is possibly undefined
// 3DCEC: variable 'v7' is possibly undefined

//----- (0003DD2C) --------------------------------------------------------
long double __cdecl vectosignedyaw(float *a1)
{
  long double result; // fst7
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  float v12; // [esp+24h] [ebp-4h]

  result = 0.0;
  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, (v7 & 0x45) != 64) )
  {
    v12 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    result = v12;
  }
  return result;
}
// 3DD3E: variable 'v2' is possibly undefined
// 3DD4C: variable 'v7' is possibly undefined

//----- (0003DD7C) --------------------------------------------------------
long double __cdecl vectopitch(float *a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  long double v7; // fst6
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  char v11; // fps^1
  long double result; // fst7
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  float v16; // [esp+24h] [ebp-4h]
  float v17; // [esp+24h] [ebp-4h]

  v2 = a1[1];
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) != 0x40 || (v7 = *a1, v8 = v7 < 0.0, v9 = 0, v10 = v7 == 0.0, v6 & 0x44 ^ 0x40) )
  {
    v16 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v17 = (double)atan2(a1[2], v16) * -180.0 / 3.141592653589793;
    result = v17;
    if ( v17 < 0.0 )
      result = result + 360.0;
  }
  else
  {
    result = 90.0;
    v13 = a1[2] > 0.0;
    v14 = 0;
    v15 = 0.0 == a1[2];
    if ( (v11 & 0x45) == 1 )
      result = 270.0;
  }
  return result;
}
// 3DD8E: variable 'v1' is possibly undefined
// 3DD9C: variable 'v6' is possibly undefined
// 3DDB1: variable 'v11' is possibly undefined

//----- (0003DE10) --------------------------------------------------------
long double __cdecl vectosignedpitch(float *a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  long double v7; // fst6
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  char v11; // fps^1
  long double result; // fst7
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  float v16; // [esp+24h] [ebp-4h]
  float v17; // [esp+24h] [ebp-4h]

  v2 = a1[1];
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) != 0x40 || (v7 = *a1, v8 = v7 < 0.0, v9 = 0, v10 = v7 == 0.0, v6 & 0x44 ^ 0x40) )
  {
    v16 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v17 = (double)atan2(a1[2], v16) * -180.0 / 3.141592653589793;
    result = v17;
  }
  else
  {
    result = 90.0;
    v13 = a1[2] > 0.0;
    v14 = 0;
    v15 = 0.0 == a1[2];
    if ( (v11 & 0x45) == 1 )
      result = -90.0;
  }
  return result;
}
// 3DE22: variable 'v1' is possibly undefined
// 3DE30: variable 'v6' is possibly undefined
// 3DE45: variable 'v11' is possibly undefined

//----- (0003DE94) --------------------------------------------------------
__int16 __cdecl vectoangles(float *a1, int a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  __int16 v12; // fps
  long double v13; // fst6
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  __int16 result; // ax
  long double v19; // fst7
  long double v20; // fst6
  char v21; // fps^1
  long double v22; // fst3
  bool v23; // c0
  char v24; // c2
  bool v25; // c3
  __int16 v26; // fps
  bool v27; // c0
  char v28; // c2
  bool v29; // c3
  long double v30; // rt2
  float v31; // [esp+24h] [ebp-4h]
  float v32; // [esp+24h] [ebp-4h]
  float v33; // [esp+24h] [ebp-4h]

  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = *a1, v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, v7 & 0x44 ^ 0x40) )
  {
    v31 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v22 = v31;
    v23 = v31 < 0.0;
    v24 = 0;
    v25 = v31 == 0.0;
    if ( (v21 & 0x45) == 1 )
      v22 = v22 + 360.0;
    v13 = v22;
    v32 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v33 = (double)atan2(a1[2], v32) * -180.0 / 3.141592653589793;
    v27 = v33 < 0.0;
    v28 = 0;
    v29 = v33 == 0.0;
    LOBYTE(result) = v26;
    HIBYTE(result) = HIBYTE(v26) & 0x45;
    v14 = v33;
    if ( (HIBYTE(v26) & 0x45) == 1 )
    {
      v19 = v22;
      v20 = v33 + 360.0;
      goto LABEL_9;
    }
  }
  else
  {
    v13 = 0.0;
    v14 = 90.0;
    v15 = a1[2] > 0.0;
    v16 = 0;
    v17 = 0.0 == a1[2];
    LOBYTE(result) = v12;
    HIBYTE(result) = HIBYTE(v12) & 0x45;
    if ( (HIBYTE(v12) & 0x45) == 1 )
    {
      v19 = 0.0;
      v20 = 270.0;
LABEL_9:
      v30 = v20;
      v13 = v19;
      v14 = v30;
      goto LABEL_10;
    }
  }
LABEL_10:
  *(float *)a2 = v14;
  *(float *)(a2 + 4) = v13;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}
// 3DEA9: variable 'v2' is possibly undefined
// 3DEB7: variable 'v7' is possibly undefined
// 3DF18: variable 'v21' is possibly undefined

//----- (0003DF84) --------------------------------------------------------
__int16 __cdecl vectosignedangles(float *a1, int a2)
{
  __int16 v2; // fps
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  __int16 result; // ax
  __int16 v8; // fps
  long double v9; // fst6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  __int16 v13; // fps
  long double v14; // fst6
  long double v15; // fst7
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  long double v19; // fst7
  long double v20; // fst6
  long double v21; // rtt
  float v22; // [esp+24h] [ebp-4h]
  float v23; // [esp+24h] [ebp-4h]
  float v24; // [esp+24h] [ebp-4h]

  v3 = a1[1];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  LOBYTE(result) = v2;
  HIBYTE(result) = HIBYTE(v2) & 0x44 ^ 0x40;
  if ( HIBYTE(result)
    || (v9 = *a1,
        v10 = v9 < 0.0,
        v11 = 0,
        v12 = v9 == 0.0,
        LOBYTE(result) = v8,
        (HIBYTE(result) = HIBYTE(v8) & 0x44 ^ 0x40) != 0) )
  {
    v22 = (double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v19 = v22;
    v23 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v24 = (double)atan2(a1[2], v23) * -180.0 / 3.141592653589793;
    v20 = v24;
    goto LABEL_6;
  }
  v14 = 0.0;
  v15 = 90.0;
  v16 = a1[2] > 0.0;
  v17 = 0;
  v18 = 0.0 == a1[2];
  LOBYTE(result) = v13;
  HIBYTE(result) = HIBYTE(v13) & 0x45;
  if ( (HIBYTE(v13) & 0x45) == 1 )
  {
    v19 = 0.0;
    v20 = -90.0;
LABEL_6:
    v21 = v20;
    v14 = v19;
    v15 = v21;
  }
  *(float *)a2 = v15;
  *(float *)(a2 + 4) = v14;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (0003E03C) --------------------------------------------------------
float *__cdecl YawVectors(float a1, int a2, int a3)
{
  float *result; // eax
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h] BYREF

  result = &v6;
  v4 = 0.0174532925199433 * a1;
  v5 = cos(v4);
  v6 = sin(v4);
  if ( a2 )
  {
    *(float *)a2 = v5;
    *(float *)(a2 + 4) = v6;
    *(_DWORD *)(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *(float *)a3 = v6;
    *(_DWORD *)(a3 + 8) = 0;
    *(float *)(a3 + 4) = -v5;
  }
  return result;
}

//----- (0003E09C) --------------------------------------------------------
__int16 __cdecl PerpendicularVector(float *a1, float *a2)
{
  long double v2; // fst7
  int v3; // edx
  int i; // edi
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst5
  long double v11; // fst6
  __int16 v12; // fps
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  __int16 result; // ax
  long double v17; // fst4
  float v18; // [esp+2Ch] [ebp-1Ch]
  float v19; // [esp+38h] [ebp-10h]
  int v20[3]; // [esp+3Ch] [ebp-Ch] BYREF

  v2 = 1.0;
  v3 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v6 = fabs(a2[i]);
    v7 = v6 < v2;
    v8 = 0;
    v9 = v6 == v2;
    if ( (v5 & 0x45) == 1 )
    {
      v19 = v6;
      v2 = v19;
      v3 = i;
    }
  }
  v20[2] = 0;
  v20[1] = 0;
  v20[0] = 0;
  v20[v3] = 1065353216;
  ProjectPointOnPlane(a1, (float *)v20, a2);
  v10 = a1[1];
  v11 = a1[2];
  v18 = sqrt(v10 * v10 + *a1 * *a1 + v11 * v11);
  v13 = v18 > 0.0;
  v14 = 0;
  v15 = 0.0 == v18;
  LOBYTE(result) = v12;
  HIBYTE(result) = HIBYTE(v12) & 0x45;
  if ( (HIBYTE(v12) & 0x45) != 64 )
  {
    v17 = 1.0 / v18;
    *a1 = *a1 * v17;
    a1[1] = v10 * v17;
    a1[2] = v11 * v17;
  }
  return result;
}
// 3E0BD: variable 'v5' is possibly undefined

//----- (0003E160) --------------------------------------------------------
float *__cdecl MatrixTranspose(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  a2[8] = a1[8];
  return result;
}

//----- (0003E1A4) --------------------------------------------------------
float *__cdecl MatrixInverseOrthogonal43(float *a1, float *a2)
{
  float v3[3]; // [esp+Ch] [ebp-Ch] BYREF

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  a2[8] = a1[8];
  v3[0] = 0.0 - a1[9];
  v3[1] = *(&vec3_origin + 1) - a1[10];
  v3[2] = *(&vec3_origin + 2) - a1[11];
  return MatrixTransformVector(v3, a2, a2 + 9);
}
// 72910: using guessed type float vec3_origin;

//----- (0003E220) --------------------------------------------------------
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (0003E284) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (0003E2E8) --------------------------------------------------------
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  return result;
}

//----- (0003E354) --------------------------------------------------------
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (0003E3C0) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst5

  result = a2;
  v4 = *a1 - a2[9];
  v5 = a1[1] - a2[10];
  v6 = a1[2] - a2[11];
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  a3[2] = v5 * a2[7] + v4 * a2[6] + v6 * a2[8];
  return result;
}

//----- (0003E438) --------------------------------------------------------
float *__cdecl MatrixTransformVector43Equals(float *a1, float *a2)
{
  float *result; // eax
  long double v3; // fst7
  long double v4; // fst6

  result = a2;
  v3 = a1[2] * a2[6] + a1[1] * a2[3] + *a1 * *a2 + a2[9];
  v4 = a1[1] * a2[4] + *a1 * a2[1] + a1[2] * a2[7] + a2[10];
  a1[2] = a1[2] * a2[8] + a1[1] * a2[5] + *a1 * a2[2] + a2[11];
  *a1 = v3;
  a1[1] = v4;
  return result;
}

//----- (0003E4B0) --------------------------------------------------------
float *__cdecl VectorAngleMultiply(int a1, float a2)
{
  float *result; // eax
  long double v3; // fst7
  float v4; // [esp+Ch] [ebp-1Ch]
  float v5; // [esp+10h] [ebp-18h]
  float v6; // [esp+14h] [ebp-14h] BYREF

  result = &v6;
  v4 = 0.0174532925199433 * a2;
  v5 = cos(v4);
  v6 = sin(v4);
  v3 = v5 * *(float *)a1 - *(float *)(a1 + 4) * v6;
  *(float *)(a1 + 4) = *(float *)a1 * v6 + *(float *)(a1 + 4) * v5;
  *(float *)a1 = v3;
  return result;
}
// 3E4C3: returning address of temporary local variable '%var_14'

//----- (0003E504) --------------------------------------------------------
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (0003E5A0) --------------------------------------------------------
float *__cdecl QuatInverse(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = -*a1;
  a2[1] = -a1[1];
  a2[2] = -a1[2];
  a2[3] = a1[3];
  return result;
}

//----- (0003E5CC) --------------------------------------------------------
long double __cdecl QuatEigenTrace(float *a1)
{
  long double v1; // fst5
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst4
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  long double result; // fst7

  v1 = *a1 * *a1;
  v2 = a1[1] * a1[1];
  v3 = a1[2] * a1[2];
  v4 = a1[3] * a1[3] + v1 + v2 + v3;
  v6 = v4 > 0.0;
  v7 = 0;
  v8 = 0.0 == v4;
  if ( (v5 & 0x45) == 64 )
    result = 0.0;
  else
    result = v2 * (1.0 / v4) + v1 * (1.0 / v4) + v3 * (1.0 / v4);
  return result;
}
// 3E5FB: variable 'v5' is possibly undefined

//----- (0003E624) --------------------------------------------------------
long double __cdecl AngleEigenTrace(float a1)
{
  long double v1; // fst7

  v1 = sin(0.0174532925199433 * a1);
  return (float)(v1 * v1);
}

//----- (0003E644) --------------------------------------------------------
long double __cdecl RotationToYaw(float *a1)
{
  long double v1; // fst3
  long double v2; // fst7

  v1 = *a1 * *a1;
  v2 = 2.0 / (a1[1] * a1[1] + v1);
  return (float)((double)atan2(v2 * (a1[1] * *a1), 1.0 - v1 * v2) * 57.29577951308232);
}

//----- (0003E690) --------------------------------------------------------
int __cdecl PitchToQuaternion(float a1, int a2)
{
  int result; // eax
  float v3; // [esp+14h] [ebp-14h]

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  result = a2 + 4;
  v3 = 0.008726646259971648 * a1;
  *(float *)(a2 + 12) = cos(v3);
  *(float *)(a2 + 4) = sin(v3);
  return result;
}

//----- (0003E6CC) --------------------------------------------------------
int __cdecl YawToQuaternion(float a1, int a2)
{
  int result; // eax
  float v3; // [esp+14h] [ebp-14h]

  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  result = a2 + 8;
  v3 = 0.008726646259971648 * a1;
  *(float *)(a2 + 12) = cos(v3);
  *(float *)(a2 + 8) = sin(v3);
  return result;
}

//----- (0003E708) --------------------------------------------------------
int __cdecl RollToQuaternion(float a1, int a2)
{
  int result; // eax
  float v3; // [esp+14h] [ebp-14h]

  result = a2;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  v3 = 0.008726646259971648 * a1;
  *(float *)(a2 + 12) = cos(v3);
  *(float *)a2 = sin(v3);
  return result;
}

//----- (0003E740) --------------------------------------------------------
int __cdecl ColorBytes3(float a1, float a2, float a3)
{
  int v4; // [esp+Ch] [ebp-Ch]

  LOBYTE(v4) = (int)(a1 * 255.0);
  BYTE1(v4) = (int)(a2 * 255.0);
  BYTE2(v4) = (int)(255.0 * a3);
  HIBYTE(v4) = -1;
  return v4;
}

//----- (0003E7C8) --------------------------------------------------------
int __cdecl ColorBytes4(float a1, float a2, float a3, float a4)
{
  int v5; // [esp+Ch] [ebp-Ch]

  LOBYTE(v5) = (int)(a1 * 255.0);
  BYTE1(v5) = (int)(a2 * 255.0);
  BYTE2(v5) = (int)(a3 * 255.0);
  HIBYTE(v5) = (int)(255.0 * a4);
  return v5;
}

//----- (0003E870) --------------------------------------------------------
long double __cdecl NormalizeColor(float *a1, float *a2)
{
  long double result; // fst7
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3

  result = *a1;
  if ( a1[1] > result )
    result = a1[1];
  if ( a1[2] > result )
    result = a1[2];
  v4 = result > 0.0;
  v5 = 0;
  v6 = 0.0 == result;
  if ( (v3 & 0x44) != 0x40 )
  {
    *a2 = *a1 / result;
    a2[1] = a1[1] / result;
    a2[2] = a1[2] / result;
  }
  else
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  return result;
}
// 3E8A5: variable 'v3' is possibly undefined

//----- (0003E8D4) --------------------------------------------------------
long double __cdecl AngleMod(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (0003E914) --------------------------------------------------------
long double __cdecl LerpAngle(float a1, float a2, float a3)
{
  long double v3; // fst7
  long double v4; // fst6
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3

  v3 = a2;
  v4 = a1;
  if ( a2 - a1 > 180.0 )
    v3 = v3 - 360.0;
  v6 = v3 - v4 < -180.0;
  v7 = 0;
  v8 = v3 - v4 == -180.0;
  if ( (v5 & 0x45) == 1 )
    v3 = v3 + 360.0;
  return (v3 - v4) * a3 + v4;
}
// 3E946: variable 'v5' is possibly undefined

//----- (0003E968) --------------------------------------------------------
long double __cdecl AngleSubtract(float a1, float a2)
{
  long double v2; // fst5
  long double v3; // fst4
  long double v4; // rt1
  long double v5; // rt2
  long double v6; // fst4
  long double v7; // fst5
  char v8; // fps^1
  long double v9; // fst6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst5
  long double v14; // rtt
  char v15; // fps^1
  long double v16; // rt0
  long double v17; // fst5
  long double v18; // fst6
  bool v19; // c0
  char v20; // c2
  bool v21; // c3

  v2 = a1 - a2;
  if ( v2 > 180.0 )
  {
    v3 = 360.0;
    while ( 1 )
    {
      v5 = v3;
      v6 = v2 - v3;
      v7 = v5;
      if ( v6 <= 180.0 )
        break;
      v4 = v6;
      v3 = v7;
      v2 = v4;
    }
    v2 = v6;
  }
  v9 = v2;
  v10 = v2 < -180.0;
  v11 = 0;
  v12 = v2 == -180.0;
  if ( (v8 & 0x45) == 1 )
  {
    v13 = 360.0;
    while ( 1 )
    {
      v16 = v13;
      v17 = v9 + v13;
      v18 = v16;
      v19 = v17 < -180.0;
      v20 = 0;
      v21 = v17 == -180.0;
      if ( (v15 & 0x45) != 1 )
        break;
      v14 = v17;
      v13 = v18;
      v9 = v14;
    }
    v9 = v17;
  }
  return v9;
}
// 3E9A7: variable 'v8' is possibly undefined
// 3E9C8: variable 'v15' is possibly undefined

//----- (0003E9D8) --------------------------------------------------------
__int16 __cdecl AnglesSubtract(float *a1, float *a2, float *a3)
{
  long double v3; // fst5
  long double v4; // fst4
  long double v5; // rt1
  long double v6; // rt2
  long double v7; // fst4
  long double v8; // fst5
  char v9; // fps^1
  long double v10; // fst6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double v14; // fst5
  long double v15; // rtt
  char v16; // fps^1
  long double v17; // rt0
  long double v18; // fst5
  long double v19; // fst6
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst7
  char v24; // fps^1
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  long double v28; // fst5
  long double v29; // rt1
  long double v30; // rt2
  long double v31; // fst5
  long double v32; // fst7
  long double v33; // fst5
  long double v34; // rtt
  char v35; // fps^1
  long double v36; // rt0
  long double v37; // fst5
  long double v38; // fst7
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  long double v42; // fst7
  char v43; // fps^1
  bool v44; // c0
  char v45; // c2
  bool v46; // c3
  long double v47; // fst5
  long double v48; // rt1
  long double v49; // rt2
  long double v50; // fst5
  long double v51; // fst7
  __int16 v52; // fps
  bool v53; // c0
  char v54; // c2
  bool v55; // c3
  __int16 result; // ax
  long double v57; // fst5
  long double v58; // rtt
  __int16 v59; // fps
  long double v60; // rt0
  long double v61; // fst5
  long double v62; // fst7
  bool v63; // c0
  char v64; // c2
  bool v65; // c3

  v3 = *a1 - *a2;
  if ( v3 > 180.0 )
  {
    v4 = 360.0;
    while ( 1 )
    {
      v6 = v4;
      v7 = v3 - v4;
      v8 = v6;
      if ( v7 <= 180.0 )
        break;
      v5 = v7;
      v4 = v8;
      v3 = v5;
    }
    v3 = v7;
  }
  v10 = v3;
  v11 = v3 < -180.0;
  v12 = 0;
  v13 = v3 == -180.0;
  if ( (v9 & 0x45) == 1 )
  {
    v14 = 360.0;
    while ( 1 )
    {
      v17 = v14;
      v18 = v10 + v14;
      v19 = v17;
      v20 = v18 < -180.0;
      v21 = 0;
      v22 = v18 == -180.0;
      if ( (v16 & 0x45) != 1 )
        break;
      v15 = v18;
      v14 = v19;
      v10 = v15;
    }
    v10 = v18;
  }
  *a3 = v10;
  v23 = a1[1] - a2[1];
  v25 = v23 > 180.0;
  v26 = 0;
  v27 = 180.0 == v23;
  if ( (v24 & 0x45) == 1 )
  {
    v28 = 360.0;
    while ( 1 )
    {
      v30 = v28;
      v31 = v23 - v28;
      v32 = v30;
      if ( v31 <= 180.0 )
        break;
      v29 = v31;
      v28 = v32;
      v23 = v29;
    }
    v23 = v31;
  }
  if ( v23 < -180.0 )
  {
    v33 = 360.0;
    while ( 1 )
    {
      v36 = v33;
      v37 = v23 + v33;
      v38 = v36;
      v39 = v37 < -180.0;
      v40 = 0;
      v41 = v37 == -180.0;
      if ( (v35 & 0x45) != 1 )
        break;
      v34 = v37;
      v33 = v38;
      v23 = v34;
    }
    v23 = v37;
  }
  a3[1] = v23;
  v42 = a1[2] - a2[2];
  v44 = v42 > 180.0;
  v45 = 0;
  v46 = 180.0 == v42;
  if ( (v43 & 0x45) == 1 )
  {
    v47 = 360.0;
    while ( 1 )
    {
      v49 = v47;
      v50 = v42 - v47;
      v51 = v49;
      if ( v50 <= 180.0 )
        break;
      v48 = v50;
      v47 = v51;
      v42 = v48;
    }
    v42 = v50;
  }
  v53 = v42 > -180.0;
  v54 = 0;
  v55 = -180.0 == v42;
  LOBYTE(result) = v52;
  HIBYTE(result) = HIBYTE(v52) & 0x45;
  if ( v42 < -180.0 )
  {
    v57 = 360.0;
    while ( 1 )
    {
      v60 = v57;
      v61 = v42 + v57;
      v62 = v60;
      v63 = v61 < -180.0;
      v64 = 0;
      v65 = v61 == -180.0;
      LOBYTE(result) = v59;
      HIBYTE(result) = HIBYTE(v59) & 0x45;
      if ( (HIBYTE(v59) & 0x45) != 1 )
        break;
      v58 = v61;
      v57 = v62;
      v42 = v58;
    }
    v42 = v61;
  }
  a3[2] = v42;
  return result;
}
// 3EA25: variable 'v9' is possibly undefined
// 3EA3F: variable 'v16' is possibly undefined
// 3EA5D: variable 'v24' is possibly undefined
// 3EAA8: variable 'v35' is possibly undefined
// 3EACB: variable 'v43' is possibly undefined

//----- (0003EB30) --------------------------------------------------------
long double __cdecl AngleNormalize360(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (0003EB70) --------------------------------------------------------
long double __cdecl AngleNormalize180(float a1)
{
  long double result; // fst7

  result = (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
  if ( result > 180.0 )
    result = result - 360.0;
  return result;
}

//----- (0003EBC4) --------------------------------------------------------
long double __cdecl AngleNormalize360Accurate(float a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst5
  long double v7; // rt0
  char v8; // fps^1
  long double v9; // rt1
  long double v10; // fst5
  long double v11; // fst6
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double result; // fst7
  char v16; // fps^1
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  char v20; // fps^1
  bool v21; // c0
  char v22; // c2
  bool v23; // c3

  v2 = a1;
  v3 = a1 < 0.0;
  v4 = 0;
  v5 = a1 == 0.0;
  if ( (v1 & 0x45) == 1 )
  {
    v6 = 360.0;
    while ( 1 )
    {
      v9 = v6;
      v10 = v2 + v6;
      v11 = v9;
      v12 = v10 < 0.0;
      v13 = 0;
      v14 = v10 == 0.0;
      if ( (v8 & 0x45) != 1 )
        break;
      v7 = v10;
      v6 = v11;
      v2 = v7;
    }
    result = v10;
  }
  else
  {
    result = a1;
    v17 = a1 > 360.0;
    v18 = 0;
    v19 = 360.0 == a1;
    if ( (unsigned __int8)((v16 & 0x45) - 1) < 0x40u )
    {
      do
      {
        result = result - 360.0;
        v21 = result > 360.0;
        v22 = 0;
        v23 = 360.0 == result;
      }
      while ( (unsigned __int8)((v20 & 0x45) - 1) < 0x40u );
    }
  }
  return result;
}
// 3EBD0: variable 'v1' is possibly undefined
// 3EBEA: variable 'v8' is possibly undefined
// 3EC04: variable 'v16' is possibly undefined
// 3EC16: variable 'v20' is possibly undefined

//----- (0003EC28) --------------------------------------------------------
long double __cdecl AngleNormalize180Accurate(float a1)
{
  long double result; // fst7
  long double v2; // fst5
  long double v3; // rt0
  char v4; // fps^1
  long double v5; // rt1
  long double v6; // fst5
  long double v7; // fst7
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  char v11; // fps^1
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst5
  long double v16; // rt2
  long double v17; // rtt
  long double v18; // fst5
  long double v19; // fst7

  result = a1;
  if ( a1 > -180.0 )
  {
    v12 = result > 180.0;
    v13 = 0;
    v14 = 180.0 == result;
    if ( (v11 & 0x45) == 1 )
    {
      v15 = 360.0;
      while ( 1 )
      {
        v17 = v15;
        v18 = result - v15;
        v19 = v17;
        if ( v18 <= 180.0 )
          break;
        v16 = v18;
        v15 = v19;
        result = v16;
      }
      result = v18;
    }
  }
  else
  {
    v2 = 360.0;
    while ( 1 )
    {
      v5 = v2;
      v6 = result + v2;
      v7 = v5;
      v8 = v6 < -180.0;
      v9 = 0;
      v10 = v6 == -180.0;
      if ( (unsigned __int8)((v4 & 0x45) - 1) >= 0x40u )
        break;
      v3 = v6;
      v2 = v7;
      result = v3;
    }
    result = v6;
  }
  return result;
}
// 3EC4F: variable 'v4' is possibly undefined
// 3EC6B: variable 'v11' is possibly undefined

//----- (0003EC9C) --------------------------------------------------------
long double __cdecl AngleDelta(float a1, float a2)
{
  long double result; // fst7

  result = (long double)(unsigned __int16)(int)((a1 - a2) * 182.04445) * 0.0054931641;
  if ( result > 180.0 )
    result = result - 360.0;
  return result;
}

//----- (0003ECF4) --------------------------------------------------------
long double __cdecl RadiusFromBounds(int a1, int a2)
{
  int v2; // edi
  int i; // ecx
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  float v12; // [esp+2Ch] [ebp-Ch]
  float v13; // [esp+30h] [ebp-8h]
  float v14; // [esp+34h] [ebp-4h]

  v2 = 0;
  for ( i = 2; i >= 0; --i )
  {
    v4 = fabs(*(float *)(a1 + v2));
    v6 = fabs(*(float *)(a2 + v2));
    v7 = v6 < v4;
    v8 = 0;
    v9 = v6 == v4;
    if ( (v5 & 0x45) != 1 )
      v4 = v6;
    *(float *)((char *)&v12 + v2) = v4;
    v2 += 4;
  }
  return (float)sqrt(v12 * v12 + v13 * v13 + v14 * v14);
}
// 3ED22: variable 'v5' is possibly undefined

//----- (0003ED60) --------------------------------------------------------
float *__cdecl ClearBounds(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  a1[2] = 262144.0;
  a1[1] = 262144.0;
  *a1 = 262144.0;
  a2[2] = -262144.0;
  a2[1] = -262144.0;
  *a2 = -262144.0;
  return result;
}

//----- (0003ED8C) --------------------------------------------------------
__int16 __cdecl AddPointToBounds(float *a1, float *a2, float *a3)
{
  char v3; // fps^1
  long double v4; // fst7
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  char v8; // fps^1
  long double v9; // fst7
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  char v13; // fps^1
  long double v14; // fst7
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  __int16 v18; // fps
  long double v19; // fst7
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  __int16 result; // ax

  v4 = *a1;
  v5 = v4 < *a2;
  v6 = 0;
  v7 = v4 == *a2;
  if ( (v3 & 0x45) == 1 )
    *a2 = *a1;
  if ( *a1 > (long double)*a3 )
    *a3 = *a1;
  v9 = a1[1];
  v10 = v9 < a2[1];
  v11 = 0;
  v12 = v9 == a2[1];
  if ( (v8 & 0x45) == 1 )
    a2[1] = a1[1];
  if ( a1[1] > (long double)a3[1] )
    a3[1] = a1[1];
  v14 = a1[2];
  v15 = v14 < a2[2];
  v16 = 0;
  v17 = v14 == a2[2];
  if ( (v13 & 0x45) == 1 )
    a2[2] = a1[2];
  v19 = a1[2];
  v20 = v19 < a3[2];
  v21 = 0;
  v22 = v19 == a3[2];
  LOBYTE(result) = v18;
  HIBYTE(result) = HIBYTE(v18) & 0x45;
  if ( v19 > a3[2] )
    a3[2] = a1[2];
  return result;
}
// 3ED9F: variable 'v3' is possibly undefined
// 3EDC6: variable 'v8' is possibly undefined
// 3EDF1: variable 'v13' is possibly undefined

//----- (0003EE1C) --------------------------------------------------------
__int16 __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4)
{
  char v4; // fps^1
  long double v5; // fst7
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  char v9; // fps^1
  long double v10; // fst7
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  char v14; // fps^1
  long double v15; // fst7
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  __int16 v19; // fps
  long double v20; // fst7
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  __int16 result; // ax

  v5 = *a1;
  v6 = v5 < *a3;
  v7 = 0;
  v8 = v5 == *a3;
  if ( (v4 & 0x45) == 1 )
    *a3 = *a1;
  if ( *a2 > (long double)*a4 )
    *a4 = *a2;
  v10 = a1[1];
  v11 = v10 < a3[1];
  v12 = 0;
  v13 = v10 == a3[1];
  if ( (v9 & 0x45) == 1 )
    a3[1] = a1[1];
  if ( a2[1] > (long double)a4[1] )
    a4[1] = a2[1];
  v15 = a1[2];
  v16 = v15 < a3[2];
  v17 = 0;
  v18 = v15 == a3[2];
  if ( (v14 & 0x45) == 1 )
    a3[2] = a1[2];
  v20 = a2[2];
  v21 = v20 < a4[2];
  v22 = 0;
  v23 = v20 == a4[2];
  LOBYTE(result) = v19;
  HIBYTE(result) = HIBYTE(v19) & 0x45;
  if ( v20 > a4[2] )
    a4[2] = a2[2];
  return result;
}
// 3EE33: variable 'v4' is possibly undefined
// 3EE5A: variable 'v9' is possibly undefined
// 3EE85: variable 'v14' is possibly undefined

//----- (0003EEB0) --------------------------------------------------------
_DWORD *__cdecl AxisClear(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = 1065353216;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  a1[8] = 1065353216;
  return result;
}

//----- (0003EEF8) --------------------------------------------------------
float *__cdecl AxisCopy(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  return result;
}

//----- (0003EF3C) --------------------------------------------------------
float *__cdecl AnglesToAxis(float *a1, float *a2)
{
  float *result; // eax
  float v3[3]; // [esp+Ch] [ebp-Ch] BYREF

  result = AngleVectors(a1, a2, v3, a2 + 6);
  a2[3] = 0.0 - v3[0];
  a2[4] = *(&vec3_origin + 1) - v3[1];
  a2[5] = *(&vec3_origin + 2) - v3[2];
  return result;
}
// 72910: using guessed type float vec3_origin;

//----- (0003EF84) --------------------------------------------------------
float *__cdecl YawToAxis(float a1, int a2)
{
  float *result; // eax
  long double v3; // fst6
  long double v4; // rt1
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  float v8; // [esp+10h] [ebp-28h]
  float v9; // [esp+14h] [ebp-24h]
  float v10[8]; // [esp+18h] [ebp-20h] BYREF

  result = v10;
  v8 = 0.0174532925199433 * a1;
  v9 = cos(v8);
  v10[0] = sin(v8);
  if ( a2 )
  {
    *(float *)a2 = v9;
    *(float *)(a2 + 4) = v10[0];
    *(_DWORD *)(a2 + 8) = 0;
  }
  v10[5] = v10[0];
  v3 = -v9;
  v10[6] = v3;
  v4 = *(&vec3_origin + 1) - v3;
  v10[7] = 0.0;
  v5 = 0.0 - v10[0];
  *(float *)(a2 + 16) = v4;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  v6 = v5;
  v7 = *(&vec3_origin + 2) - 0.0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(float *)(a2 + 12) = v6;
  *(float *)(a2 + 20) = v7;
  return result;
}
// 72910: using guessed type float vec3_origin;

//----- (0003F01C) --------------------------------------------------------
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3)
{
  float *result; // eax
  long double v4; // fst4
  long double v5; // fst7
  long double v6; // fst2
  long double v7; // fst6
  long double v8; // fst4

  result = a3;
  v4 = 1.0 / (a3[2] * a3[2] + a3[1] * a3[1] + *a3 * *a3);
  v5 = (a3[1] * a2[1] + *a3 * *a2 + a3[2] * a2[2]) * v4;
  v6 = *a3 * v4;
  v7 = a3[1] * v4;
  v8 = v4 * a3[2];
  *a1 = *a2 - v5 * v6;
  a1[1] = a2[1] - v5 * v7;
  a1[2] = a2[2] - v5 * v8;
  return result;
}

//----- (0003F0A4) --------------------------------------------------------
__int16 __cdecl SetPlaneSignbits(int a1)
{
  __int16 v1; // fps
  char v2; // dl
  int i; // ecx
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7; // eax

  v2 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    v4 = *(float *)(a1 + 4 * i) > 0.0;
    v5 = 0;
    v6 = 0.0 == *(float *)(a1 + 4 * i);
    LOBYTE(v7) = v1;
    BYTE1(v7) = HIBYTE(v1) & 0x45;
    if ( *(float *)(a1 + 4 * i) < 0.0 )
    {
      v7 = 1 << i;
      v2 |= 1 << i;
    }
  }
  *(_BYTE *)(a1 + 17) = v2;
  return v7;
}

//----- (0003F0D8) --------------------------------------------------------
__int16 __cdecl NormalToLatLong(float *a1, _BYTE *a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  __int16 v7; // fps
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  int v15; // eax
  int v16; // edx

  v3 = *a1;
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  if ( (v2 & 0x44) != 0x40 || (v8 = a1[1], v9 = v8 < 0.0, v10 = 0, v11 = v8 == 0.0, HIBYTE(v7) & 0x44 ^ 0x40) )
  {
    v16 = (int)((double)atan2(a1[1], *a1) * 180.0 / 3.141592653589793 * 0.7083333134651184);
    v15 = (int)(0.7083333134651184 * (180.0 * (double)atan2(sqrt(1.0 - a1[2] * a1[2]), a1[2]) / 3.141592653589793));
    *a2 = v15;
    a2[1] = v16;
  }
  else
  {
    v12 = a1[2] > 0.0;
    v13 = 0;
    v14 = 0.0 == a1[2];
    LOBYTE(v15) = v7;
    BYTE1(v15) = HIBYTE(v7) & 0x45;
    if ( (HIBYTE(v7) & 0x45) == 1 )
      *a2 = 0;
    else
      *a2 = 0x80;
    a2[1] = 0;
  }
  return v15;
}
// 3F0EE: variable 'v2' is possibly undefined

//----- (0003F1B4) --------------------------------------------------------
float *__cdecl Vec10Copy(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  a2[9] = a1[9];
  return result;
}

//----- (0003F1FC) --------------------------------------------------------
long double __cdecl Q_rint(float a1)
{
  _FST7 = a1 + 0.5;
  __asm { frndint }
  return (float)_FST7;
}

//----- (0003F238) --------------------------------------------------------
long double __cdecl ColorNormalize(float *a1, float *a2)
{
  long double result; // fst7
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3

  result = *a1;
  if ( a1[1] > result )
    result = a1[1];
  if ( a1[2] > result )
    result = a1[2];
  v4 = result > 0.0;
  v5 = 0;
  v6 = 0.0 == result;
  if ( (v3 & 0x45) == 64 )
  {
    a2[2] = 1.0;
    a2[1] = 1.0;
    *a2 = 1.0;
    result = 0.0;
  }
  else
  {
    *a2 = *a1 * (1.0 / result);
    a2[1] = a1[1] * (1.0 / result);
    a2[2] = 1.0 / result * a1[2];
  }
  return result;
}
// 3F26D: variable 'v3' is possibly undefined

//----- (0003F2A4) --------------------------------------------------------
float *__cdecl VectorPolar(int a1, float a2, float a3)
{
  float *result; // eax
  float v4; // [esp+14h] [ebp-14h]
  float v5[2]; // [esp+18h] [ebp-10h] BYREF
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  v5[1] = a3;
  v6 = cos(a3);
  v7 = sin(a3);
  result = v5;
  v4 = v6;
  v5[0] = v7;
  *(float *)a1 = a2 * v6 * v6;
  *(float *)(a1 + 4) = v4 * (a2 * v7);
  *(float *)(a1 + 8) = a2 * v5[0];
  return result;
}
// 3F2D5: returning address of temporary local variable '%var_10'

//----- (0003F304) --------------------------------------------------------
int __cdecl VectorSnap(float *a1)
{
  int result; // eax
  unsigned __int16 v5; // [esp+16h] [ebp-12h]

  _FST7 = *a1 + 0.5;
  __asm { frndint }
  *a1 = _FST7;
  _FST7 = a1[1] + 0.5;
  __asm { frndint }
  a1[1] = _FST7;
  _FST7 = a1[2] + 0.5;
  result = v5;
  BYTE1(result) = HIBYTE(v5) & 0xF3 | 4;
  __asm { frndint }
  a1[2] = _FST7;
  return result;
}
// 3F376: variable 'v5' is possibly undefined

//----- (0003F39C) --------------------------------------------------------
float *__cdecl Vector53Copy(float *a1, float *a2)
{
  float *result; // eax

  result = a1;
  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  return result;
}

//----- (0003F3BC) --------------------------------------------------------
int __cdecl Vector5Scale(int a1, float a2, int a3)
{
  int result; // eax

  result = a3;
  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  *(float *)(a3 + 12) = *(float *)(a1 + 12) * a2;
  *(float *)(a3 + 16) = a2 * *(float *)(a1 + 16);
  return result;
}

//----- (0003F3F0) --------------------------------------------------------
float *__cdecl Vector5Add(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  a3[3] = a1[3] + a2[3];
  a3[4] = a1[4] + a2[4];
  return result;
}

//----- (0003F42C) --------------------------------------------------------
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5[3]; // [esp+10h] [ebp-18h] BYREF
  float v6[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v6[0] = *a1 - *a3;
  v6[1] = a1[1] - a3[1];
  v6[2] = a1[2] - a3[2];
  result = VectorRotateAngles(v6, a2, v5);
  *a4 = v5[0] + *a3;
  a4[1] = v5[1] + a3[1];
  a4[2] = v5[2] + a3[2];
  return result;
}

//----- (0003F48C) --------------------------------------------------------
long double __cdecl Q_rsqrt(float a1)
{
  return COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1))
       * (1.5
        - a1 * 0.5 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (0003F4C8) --------------------------------------------------------
long double __cdecl VectorLength(float *a1)
{
  return (float)sqrt(*a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2]);
}

//----- (0003F500) --------------------------------------------------------
void __cdecl P_DamageFeedback(int a1)
{
  int v1; // ebx
  int v2; // esi
  int v3; // ecx
  int v4; // esi
  long double v5; // fst7
  long double v6; // fst5
  long double v7; // fst7
  long double v8; // fst6
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst7
  long double v14; // fst5
  long double v15; // fst6
  int v16; // eax
  long double v17; // [esp+18h] [ebp-50h]
  float v18[9]; // [esp+38h] [ebp-30h] BYREF
  float v19[3]; // [esp+5Ch] [ebp-Ch] BYREF

  v1 = *(_DWORD *)(a1 + 344);
  if ( *(int *)(v1 + 4) <= 5 )
  {
    v2 = *(_DWORD *)(v1 + 8724);
    if ( v2 > 0 )
    {
      v3 = *(_DWORD *)(v1 + 8528);
      if ( v3 > 0 )
      {
        v4 = 100 * v2 / v3;
        if ( v4 > 127 )
          v4 = 127;
        v5 = (long double)v4;
        v6 = *(float *)(v1 + 984) + v5;
        *(float *)(v1 + 984) = v6;
        if ( v6 > 255.0 )
          *(float *)(v1 + 984) = 255.0;
        v7 = v5 * 0.2;
        v8 = 5.0;
        if ( v7 < 5.0 || (v8 = 90.0, v10 = v7 > 90.0, v11 = 0, v12 = 90.0 == v7, (v9 & 0x45) == 1) )
          v7 = v8;
        if ( *(_DWORD *)(v1 + 8740) )
        {
          *(_DWORD *)(v1 + 8816) = 0;
          *(_DWORD *)(v1 + 236) = 255;
          *(_DWORD *)(v1 + 232) = 255;
          *(_DWORD *)(v1 + 8740) = 0;
          *(float *)(v1 + 8820) = -v7;
        }
        else
        {
          v17 = v7;
          vectoangles((float *)(v1 + 8728), (int)v19);
          AnglesToAxis((float *)(v1 + 192), v18);
          v13 = *(float *)(v1 + 8728);
          v14 = *(float *)(v1 + 8732);
          v15 = *(float *)(v1 + 8736);
          *(float *)(v1 + 8816) = -v17 * (v15 * v18[5] + v14 * v18[4] + v13 * v18[3]);
          *(float *)(v1 + 8820) = v17 * (v14 * v18[1] + v13 * v18[0] + v15 * v18[2]);
          *(_DWORD *)(v1 + 236) = (int)(v19[0] / 360.0 * 256.0);
          *(_DWORD *)(v1 + 232) = (int)(256.0 * (v19[1] / 360.0));
        }
        if ( level[122] > *(_DWORD *)(a1 + 548) && (*(_BYTE *)(a1 + 380) & 1) == 0 )
        {
          v16 = (int)((long double)*(int *)(v1 + 244) / (long double)*(int *)(v1 + 252) * 100.0);
          if ( v16 >= 0 )
          {
            if ( v16 > 100 )
              v16 = 100;
          }
          else
          {
            v16 = 0;
          }
          G_AddEvent((_DWORD *)a1, 187, v16);
          *(_DWORD *)(a1 + 548) = level[122] + 700;
        }
        ++*(_DWORD *)(v1 + 228);
        *(_DWORD *)(v1 + 8812) = level[122] - 20;
        *(_DWORD *)(v1 + 240) = v4;
        *(_DWORD *)(v1 + 8724) = 0;
      }
    }
  }
}
// 3F59C: variable 'v9' is possibly undefined

//----- (0003F780) --------------------------------------------------------
int __cdecl ClientImpacts(int *a1, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // ecx
  int *v5; // ebx
  void (__cdecl *v6)(int *, int *, int); // eax
  void (__cdecl *v7)(int *, int *, int); // eax
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]

  result = a2;
  v3 = 0;
  if ( *(int *)(a2 + 60) > 0 )
  {
    v9 = a2 + 64;
    do
    {
      v4 = 0;
      v8 = v3 + 1;
      if ( v3 > 0 && *(_DWORD *)(a2 + 64) != *(_DWORD *)(4 * v3 + v9) )
      {
        do
          ++v4;
        while ( v4 < v3 && *(_DWORD *)(a2 + 64 + 4 * v4) != *(_DWORD *)(4 * v3 + a2 + 64) );
      }
      if ( v4 == v3 )
      {
        v5 = &g_entities[197 * *(_DWORD *)(v9 + 4 * v3)];
        if ( Scr_IsSystemActive(1u) )
        {
          Scr_AddEntity(v5);
          Scr_Notify(a1, scr_const[72], 1);
          Scr_AddEntity(a1);
          Scr_Notify(v5, scr_const[72], 1);
        }
        v6 = (void (__cdecl *)(int *, int *, int))v5[131];
        if ( v6 )
          v6(v5, a1, 1);
        v7 = (void (__cdecl *)(int *, int *, int))a1[131];
        if ( v7 )
          v7(a1, v5, 1);
      }
      result = a2;
      ++v3;
    }
    while ( v8 < *(_DWORD *)(a2 + 60) );
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (0003F88C) --------------------------------------------------------
int __cdecl G_TouchTriggers(int a1)
{
  int result; // eax
  float *v2; // eax
  long double v3; // fst7
  int v4; // eax
  int *v5; // ebx
  void (__cdecl *v7)(int *, int, int); // eax
  int v8; // [esp+18h] [ebp-1020h]
  int v9; // [esp+1Ch] [ebp-101Ch]
  float v10; // [esp+20h] [ebp-1018h] BYREF
  float v11; // [esp+24h] [ebp-1014h]
  float i; // [esp+28h] [ebp-1010h]
  float v13; // [esp+2Ch] [ebp-100Ch] BYREF
  float v14; // [esp+30h] [ebp-1008h]
  float v15; // [esp+34h] [ebp-1004h]
  int v16[1024]; // [esp+38h] [ebp-1000h] BYREF

  result = *(_DWORD *)(a1 + 344);
  if ( result )
  {
    if ( *(int *)(result + 4) <= 1 )
    {
      v13 = *(float *)(result + 20) - flt_7DCDC;
      v14 = *(float *)(result + 24) - flt_7DCE0;
      v15 = *(float *)(result + 28) - flt_7DCE4;
      v10 = flt_7DCDC + *(float *)(result + 20);
      v11 = flt_7DCE0 + *(float *)(result + 24);
      i = flt_7DCE4 + *(float *)(result + 28);
      v8 = trap_EntitiesInBox((int)&v13, (int)&v10, (int)v16);
      v2 = *(float **)(a1 + 344);
      v13 = v2[5] + *(float *)(a1 + 256);
      v14 = v2[6] + *(float *)(a1 + 260);
      v15 = v2[7] + *(float *)(a1 + 264);
      v10 = v2[5] + *(float *)(a1 + 268);
      v11 = v2[6] + *(float *)(a1 + 272);
      v3 = v2[7] + *(float *)(a1 + 276);
      result = v8;
      v9 = 0;
      for ( i = v3; v9 < v8; ++v9 )
      {
        v4 = 197 * v16[v9];
        v5 = &g_entities[v4];
        if ( g_entities[v4 + 131] || *(_DWORD *)(a1 + 524) )
        {
          if ( g_entities[v4 + 1] == 3 ? BG_PlayerTouchesItem(*(float **)(a1 + 344), (int)&g_entities[v4], level[122]) : trap_EntityContact((int)&v13, (int)&v10, (int)&g_entities[v4]) )
          {
            if ( Scr_IsSystemActive(1u) )
            {
              Scr_AddEntity((int *)a1);
              Scr_Notify(v5, scr_const[72], 1);
              Scr_AddEntity(v5);
              Scr_Notify((int *)a1, scr_const[72], 1);
            }
            v7 = (void (__cdecl *)(int *, int, int))v5[131];
            if ( v7 )
              v7(v5, a1, 1);
          }
        }
        result = v8;
      }
    }
  }
  return result;
}
// 7DCDC: using guessed type float flt_7DCDC;
// 7DCE0: using guessed type float flt_7DCE0;
// 7DCE4: using guessed type float flt_7DCE4;
// 21DF80: using guessed type int g_entities[];

//----- (0003FAB8) --------------------------------------------------------
int __cdecl SpectatorThink(int a1, const void *a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // eax
  int result; // eax
  int v6; // [esp+1Ch] [ebp-FCh]
  int s; // [esp+20h] [ebp-F8h] BYREF
  char v8[24]; // [esp+24h] [ebp-F4h] BYREF
  int v9; // [esp+54h] [ebp-C4h]
  int (__cdecl *v10)(int, int, int); // [esp+108h] [ebp-10h]
  int (__cdecl *v11)(int, int, int); // [esp+10Ch] [ebp-Ch]
  int (__cdecl *v12)(int, int, int); // [esp+110h] [ebp-8h]
  int (__cdecl *v13)(int, int, int); // [esp+114h] [ebp-4h]

  v6 = *(_DWORD *)(a1 + 344);
  v2 = *(_DWORD *)(v6 + 8680);
  *(_DWORD *)(v6 + 8684) = v2;
  v3 = *(unsigned __int8 *)(v6 + 8436);
  *(_DWORD *)(v6 + 8680) = v3;
  *(_DWORD *)(v6 + 8696) = *(_DWORD *)(v6 + 8692);
  *(_DWORD *)(v6 + 8692) = *(unsigned __int8 *)(v6 + 8437);
  if ( *(int *)(v6 + 8404) < 0 && *(int *)(v6 + 8660) >= 0 && (v3 & 0x10) != (v2 & 0x10) )
    StopFollowing(a1);
  v4 = *(_DWORD *)(v6 + 8680);
  if ( (v4 & 1) == 0 || (*(_BYTE *)(v6 + 8684) & 1) != 0 )
  {
    if ( (v4 & 0x20) != 0 && (*(_BYTE *)(v6 + 8684) & 0x20) == 0 )
      Cmd_FollowCycle_f(a1, -1);
  }
  else
  {
    Cmd_FollowCycle_f(a1, 1);
  }
  result = v6;
  if ( (*(_BYTE *)(v6 + 14) & 1) == 0 )
  {
    *(_DWORD *)(v6 + 4) = 4;
    *(_DWORD *)(v6 + 68) = 400;
    _bzero(&s, 0xF8u);
    s = v6;
    qmemcpy(v8, a2, sizeof(v8));
    v9 = 8388625;
    v10 = trap_TraceCapsule;
    v11 = trap_TraceCapsule;
    v12 = trap_TraceCapsule;
    v13 = trap_PointContents;
    Pmove((int)&s);
    *(float *)(a1 + 308) = *(float *)(v6 + 20);
    *(float *)(a1 + 312) = *(float *)(v6 + 24);
    *(float *)(a1 + 316) = *(float *)(v6 + 28);
    result = trap_UnlinkEntity(a1);
  }
  return result;
}
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (0003FC44) --------------------------------------------------------
int __cdecl ClientInactivityTimer(int a1)
{
  int v1; // ecx
  int v2; // eax
  int v3; // ecx
  int v4; // eax

  v1 = g_inactivity[3];
  if ( !v1 )
  {
    v2 = level[122] + 60000;
LABEL_6:
    *(_DWORD *)(a1 + 8756) = v2;
    *(_DWORD *)(a1 + 8760) = 0;
    return 1;
  }
  if ( (*(_DWORD *)(a1 + 8452) & 0xFFFFFF) != 0 || (*(_BYTE *)(a1 + 8436) & 1) != 0 )
  {
    v2 = level[122] + 1000 * v1;
    goto LABEL_6;
  }
  if ( !*(_DWORD *)(a1 + 8480) )
  {
    v3 = level[122];
    v4 = *(_DWORD *)(a1 + 8756);
    if ( v3 > v4 )
    {
      trap_DropClient((-1893646255 * (a1 - level[0])) >> 2, (int)"GAME_DROPPEDFORINACTIVITY");
      return 0;
    }
    if ( v3 > v4 - 10000 && !*(_DWORD *)(a1 + 8760) )
    {
      *(_DWORD *)(a1 + 8760) = 1;
      trap_SendServerCommand((-1893646255 * (a1 - level[0])) >> 2, 0, (int)"c \"GAME_INACTIVEDROPWARNING\"");
    }
  }
  return 1;
}

//----- (0003FD24) --------------------------------------------------------
unsigned int __cdecl ClientEvents(int *a1, signed int a2)
{
  unsigned int result; // eax
  signed int v3; // ecx
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  int v13; // eax
  int v14; // eax
  unsigned int v15; // [esp+1Ch] [ebp-1Ch]
  unsigned int v16; // [esp+20h] [ebp-18h]

  result = a2;
  v15 = a1[86];
  v3 = *(_DWORD *)(v15 + 132);
  if ( a2 < v3 - 4 )
    result = v3 - 4;
  v16 = result;
  if ( (int)result < v3 )
  {
    v4 = 4 * (result & 3);
    v5 = *(_DWORD *)(v4 + v15 + 136);
    v6 = *(_DWORD *)(v4 + v15 + 152);
    for ( result = v5 - 116; ; result = v5 - 116 )
    {
      if ( result > 0x16 )
      {
        switch ( v5 )
        {
          case 159:
          case 160:
          case 161:
          case 168:
            FireWeapon((int)a1);
            break;
          case 165:
            FireWeaponMelee((int)a1);
            break;
          case 196:
            v13 = a1[86];
            if ( *(_DWORD *)(v13 + 176) && Com_BitCheck(v13 + 780, *(_DWORD *)(v13 + 176)) )
              Drop_Weapon((int)a1, *(_DWORD *)(a1[86] + 176), (int)"tag_weapon_right");
            break;
          default:
            break;
        }
      }
      else
      {
        if ( a1[1] != 1 )
          return result;
        if ( v6 <= 99 )
          v7 = (long double)v6 * 0.0099999998;
        else
          v7 = 1.1;
        v9 = v7 > 0.0;
        v10 = 0;
        v11 = 0.0 == v7;
        if ( (v8 & 0x45) != 64 )
        {
          v12 = v7 * (long double)*(int *)(v15 + 252);
          a1[137] = level[122] + 200;
          G_Damage(a1, 0, 0, 0, 0, (int)v12, 0, 0x15u, 0);
        }
      }
      result = v15;
      if ( (signed int)++v16 >= *(_DWORD *)(v15 + 132) )
        return result;
      v14 = 4 * (v16 & 3);
      v5 = *(_DWORD *)(v14 + v15 + 136);
      v6 = *(_DWORD *)(v14 + v15 + 152);
    }
  }
  return result;
}
// 3FDA2: variable 'v8' is possibly undefined

//----- (0003FEE0) --------------------------------------------------------
int __cdecl ClientThink_real(int a1, int *a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // ecx
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  float *v18; // eax
  int v19; // [esp+38h] [ebp-1F0h]
  int v20; // [esp+3Ch] [ebp-1ECh]
  char v21[36]; // [esp+44h] [ebp-1E4h] BYREF
  char v22[36]; // [esp+68h] [ebp-1C0h] BYREF
  char v23[36]; // [esp+8Ch] [ebp-19Ch] BYREF
  float v24[3]; // [esp+B0h] [ebp-178h] BYREF
  float v25; // [esp+BCh] [ebp-16Ch] BYREF
  float v26; // [esp+C0h] [ebp-168h]
  float v27; // [esp+C4h] [ebp-164h]
  int v28[3]; // [esp+C8h] [ebp-160h] BYREF
  float v29; // [esp+D4h] [ebp-154h]
  float v30; // [esp+D8h] [ebp-150h]
  float v31; // [esp+DCh] [ebp-14Ch]
  float v32; // [esp+E0h] [ebp-148h]
  int v33; // [esp+E4h] [ebp-144h]
  int v34; // [esp+E8h] [ebp-140h]
  float v35; // [esp+ECh] [ebp-13Ch]
  float v36; // [esp+F0h] [ebp-138h]
  float v37; // [esp+F4h] [ebp-134h]
  float v38; // [esp+F8h] [ebp-130h]
  float v39; // [esp+FCh] [ebp-12Ch]
  float v40; // [esp+100h] [ebp-128h]
  float v41; // [esp+104h] [ebp-124h]
  float v42; // [esp+108h] [ebp-120h]
  float v43; // [esp+10Ch] [ebp-11Ch]
  float v44; // [esp+110h] [ebp-118h]
  float v45; // [esp+114h] [ebp-114h]
  int v46[2]; // [esp+118h] [ebp-110h] BYREF
  int v47; // [esp+120h] [ebp-108h]
  float v48; // [esp+124h] [ebp-104h]
  float v49; // [esp+128h] [ebp-100h]
  int v50; // [esp+12Ch] [ebp-FCh]
  int s; // [esp+130h] [ebp-F8h] BYREF
  char v52[24]; // [esp+134h] [ebp-F4h] BYREF
  char v53[24]; // [esp+14Ch] [ebp-DCh] BYREF
  int v54; // [esp+164h] [ebp-C4h]
  int v55; // [esp+168h] [ebp-C0h]
  float v56; // [esp+1F0h] [ebp-38h]
  float v57; // [esp+1F4h] [ebp-34h]
  float v58; // [esp+1F8h] [ebp-30h]
  float v59; // [esp+1FCh] [ebp-2Ch]
  float v60; // [esp+200h] [ebp-28h]
  float v61; // [esp+204h] [ebp-24h]
  char v62; // [esp+208h] [ebp-20h]
  char v63; // [esp+209h] [ebp-1Fh]
  int v64; // [esp+210h] [ebp-18h]
  int v65; // [esp+214h] [ebp-14h]
  int (__cdecl *v66)(int, int, int, int, int, int, int); // [esp+218h] [ebp-10h]
  int (__cdecl *v67)(int, int, int, int, int, int, int); // [esp+21Ch] [ebp-Ch]
  int (__cdecl *v68)(int, int, int, int, int, int, int); // [esp+220h] [ebp-8h]
  int (__cdecl *v69)(int, int, int); // [esp+224h] [ebp-4h]

  result = a1;
  v3 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v3 + 8428) == 2 )
  {
    v4 = level[122] + 200;
    if ( *a2 > v4 )
      *a2 = v4;
    v5 = level[122] - 1000;
    if ( *a2 < v5 )
      *a2 = v5;
    v19 = *a2 - *(_DWORD *)v3;
    if ( v19 > 0 || (result = (1024687629 * (a1 - (int)&g_entities)) >> 2, *(_DWORD *)(v3 + 172) != result) )
    {
      if ( v19 > 200 )
        v19 = 200;
      v6 = pmove_msec[3];
      if ( v6 > 7 )
      {
        if ( v6 > 33 )
          trap_Cvar_Set("pmove_msec", "33");
      }
      else
      {
        trap_Cvar_Set("pmove_msec", &unk_72D1C);
      }
      if ( pmove_fixed[3] || *(_DWORD *)(v3 + 8488) )
        *a2 = pmove_msec[3] * ((*a2 + pmove_msec[3] - 1) / pmove_msec[3]);
      v7 = *(_DWORD *)(v3 + 8400);
      if ( v7 == 3 )
      {
        result = *(_DWORD *)(a1 + 344);
        *(_DWORD *)(result + 8684) = *(_DWORD *)(result + 8680);
        v8 = *(_DWORD *)(result + 8692);
        *(_DWORD *)(result + 8680) = *(unsigned __int8 *)(result + 8436);
        *(_DWORD *)(result + 8696) = v8;
        *(_DWORD *)(result + 8692) = *(unsigned __int8 *)(result + 8437);
      }
      else if ( v7 == 2 )
      {
        result = SpectatorThink(a1, a2);
      }
      else
      {
        result = ClientInactivityTimer(v3);
        if ( result )
        {
          v20 = *(_DWORD *)(v3 + 132);
          _bzero(&s, 0xF8u);
          s = v3;
          qmemcpy(v52, a2, sizeof(v52));
          qmemcpy(v53, (const void *)(v3 + 8456), sizeof(v53));
          if ( *(int *)(v3 + 4) <= 5 )
            v54 = 42008593;
          else
            v54 = 8454161;
          v66 = trap_TraceCapsule;
          v67 = trap_TraceCapsule;
          v68 = trap_TraceCapsule;
          v69 = trap_PointContents;
          v55 = g_debugMove[3];
          v64 = *(_DWORD *)(v3 + 8488) | pmove_fixed[3];
          v65 = pmove_msec[3];
          *(float *)(v3 + 8704) = *(float *)(v3 + 20);
          *(float *)(v3 + 8708) = *(float *)(v3 + 24);
          *(float *)(v3 + 8712) = *(float *)(v3 + 28);
          v9 = *(_DWORD *)(v3 + 8680);
          *(_DWORD *)(v3 + 8684) = v9;
          v10 = *(unsigned __int8 *)(v3 + 8436);
          *(_DWORD *)(v3 + 8688) = v10 & ~v9;
          v11 = *(_DWORD *)(v3 + 8692);
          *(_DWORD *)(v3 + 8680) = v10;
          *(_DWORD *)(v3 + 8696) = v11;
          v12 = *(unsigned __int8 *)(v3 + 8437);
          *(_DWORD *)(v3 + 8692) = v12;
          *(_DWORD *)(v3 + 8700) = v12 & ~v11;
          v46[0] = v3;
          v46[1] = *(_DWORD *)(v3 + 8812);
          v47 = level[122];
          v48 = *(float *)(v3 + 8820);
          v49 = *(float *)(v3 + 8816);
          *(float *)&v50 = BG_GetSpeed(v3, v47);
          BG_CalculateViewAngles(v46, v24);
          v25 = *(float *)(v3 + 192) + v24[0];
          v26 = *(float *)(v3 + 196) + v24[1];
          v27 = *(float *)(v3 + 200) + v24[2];
          BG_GetInfoForWeapon(*(_DWORD *)(v3 + 176));
          BG_CalculateWeaponPosition_Sway(v3, v3 + 8824, v3 + 8836, v3 + 8848, 1.0, v19);
          v28[1] = v50;
          v28[0] = v46[0];
          *(float *)&v28[2] = (long double)v19 * 0.001;
          v29 = *(float *)(v3 + 8860);
          v30 = *(float *)(v3 + 8864);
          v31 = *(float *)(v3 + 8868);
          v32 = *(float *)(v3 + 8872);
          v33 = v47;
          v34 = *(_DWORD *)(v3 + 8812);
          v35 = *(float *)(v3 + 8820);
          v36 = *(float *)(v3 + 8816);
          v37 = *(float *)(v3 + 8876);
          v38 = *(float *)(v3 + 8880);
          v39 = *(float *)(v3 + 8884);
          v40 = *(float *)(v3 + 8888);
          v41 = *(float *)(v3 + 8892);
          v42 = *(float *)(v3 + 8896);
          v43 = *(float *)(v3 + 8848);
          v44 = *(float *)(v3 + 8852);
          v45 = *(float *)(v3 + 8856);
          BG_CalculateWeaponAngles(v28, v24);
          if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v28[0] + 176)) )
          {
            v14 = *(float *)(v28[0] + 184);
            v15 = v14 < 0.0;
            v16 = 0;
            v17 = v14 == 0.0;
            if ( (v13 & 0x45) != 64 )
            {
              AnglesToAxis(v24, v23);
              AnglesToAxis(&v25, v22);
              MatrixMultiply(v23, v22, v21);
              AxisToAngles(v21, &v25);
            }
          }
          *(float *)(v3 + 8860) = v29;
          *(float *)(v3 + 8864) = v30;
          *(float *)(v3 + 8868) = v31;
          *(float *)(v3 + 8872) = v32;
          *(float *)(v3 + 8876) = v37;
          *(float *)(v3 + 8880) = v38;
          *(float *)(v3 + 8884) = v39;
          *(float *)(v3 + 8888) = v40;
          *(float *)(v3 + 8892) = v41;
          *(float *)(v3 + 8896) = v42;
          *(float *)(v3 + 8716) = v25;
          *(float *)(v3 + 8720) = v26;
          Pmove(&s);
          *(_DWORD *)(a1 + 224) = (*(_BYTE *)(*(_DWORD *)(a1 + 344) + 12) & 2) != 0;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 132) != v20 )
          {
            *(_DWORD *)(a1 + 384) = level[122];
            *(_DWORD *)(a1 + 336) = level[122];
          }
          if ( g_smoothClients[3] )
            BG_PlayerStateToEntityStateExtrapolate(*(_DWORD *)(a1 + 344), a1, **(_DWORD **)(a1 + 344), 1);
          else
            BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 344), a1, 1);
          *(float *)(a1 + 308) = *(float *)(a1 + 24);
          *(float *)(a1 + 312) = *(float *)(a1 + 28);
          *(float *)(a1 + 316) = *(float *)(a1 + 32);
          *(float *)(a1 + 256) = v56;
          *(float *)(a1 + 260) = v57;
          *(float *)(a1 + 264) = v58;
          *(float *)(a1 + 268) = v59;
          *(float *)(a1 + 272) = v60;
          *(float *)(a1 + 276) = v61;
          *(_BYTE *)(a1 + 368) = v63;
          *(_BYTE *)(a1 + 367) = v62;
          ClientEvents(a1, v20);
          trap_LinkEntity(a1);
          if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8664) )
            G_TouchTriggers(a1);
          v18 = *(float **)(a1 + 344);
          *(float *)(a1 + 308) = v18[5];
          *(float *)(a1 + 312) = v18[6];
          *(float *)(a1 + 316) = v18[7];
          *(_DWORD *)(a1 + 328) = 0;
          *(_DWORD *)(a1 + 324) = 0;
          *(_DWORD *)(a1 + 320) = 0;
          *(float *)(a1 + 324) = v18[49];
          ClientImpacts(a1, &s);
          result = *(_DWORD *)(a1 + 344);
          if ( *(_DWORD *)(result + 132) != v20 )
          {
            result = level[122];
            *(_DWORD *)(a1 + 384) = result;
          }
          if ( (*(_BYTE *)(v3 + 8688) & 0x40) != 0 )
            result = Cmd_Activate_f(a1);
        }
      }
    }
  }
  return result;
}
// 40365: variable 'v13' is possibly undefined
// 2CBE8: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 2D004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 3447C: using guessed type _DWORD __cdecl Pmove(_DWORD);
// 3450C: using guessed type double __cdecl BG_GetSpeed(_DWORD, _DWORD);
// 3A1E4: using guessed type _DWORD __cdecl BG_CalculateWeaponAngles(_DWORD, _DWORD);
// 3A930: using guessed type _DWORD __cdecl BG_CalculateViewAngles(_DWORD, _DWORD);
// 3A970: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);
// 3AC68: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 3B5A8: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 3C808: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 3EF3C: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 3F780: using guessed type _DWORD __cdecl ClientImpacts(_DWORD, _DWORD);
// 3F88C: using guessed type _DWORD __cdecl G_TouchTriggers(_DWORD);
// 3FAB8: using guessed type _DWORD __cdecl SpectatorThink(_DWORD, _DWORD);
// 3FC44: using guessed type _DWORD __cdecl ClientInactivityTimer(_DWORD);
// 3FD24: using guessed type _DWORD __cdecl ClientEvents(_DWORD, _DWORD);
// 48468: using guessed type _DWORD __cdecl Cmd_Activate_f(_DWORD);
// 63574: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 63778: using guessed type int __cdecl trap_TraceCapsule(int, int, int, int, int, int, int);
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);
// 63A40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 21DF80: using guessed type int g_entities;

//----- (00040660) --------------------------------------------------------
void __cdecl G_RunClient(int a1)
{
  _DWORD *v1; // edx
  int v2; // eax
  int v3; // eax

  if ( g_synchronousClients[3] )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8432) = level[122];
    ClientThink_real(a1, (int *)(*(_DWORD *)(a1 + 344) + 8432));
  }
  v1 = *(_DWORD **)(a1 + 344);
  if ( !v1[2166] )
  {
    if ( *(_DWORD *)(a1 + 740) )
    {
      v2 = 1;
      if ( v1[2100] == 1 )
        v2 = 7;
      v1[1] = v2;
      G_SetFixedLink(a1, 2);
      G_SetOrigin(a1, (float *)(a1 + 308));
      G_SetAngle(a1, (float *)(a1 + 320));
      *(_DWORD *)(a1 + 12) = 1;
      *(_DWORD *)(a1 + 48) = 1;
      trap_LinkEntity(a1);
      *(float *)(*(_DWORD *)(a1 + 344) + 20) = *(float *)(a1 + 308);
      *(float *)(*(_DWORD *)(a1 + 344) + 24) = *(float *)(a1 + 312);
      *(float *)(*(_DWORD *)(a1 + 344) + 28) = *(float *)(a1 + 316);
    }
    else
    {
      v3 = v1[1];
      if ( v3 == 1 || v3 == 7 )
        v1[1] = v3 - 1;
    }
  }
}

//----- (00040760) --------------------------------------------------------
int __cdecl SpectatorClientEndFrame(int a1)
{
  int v1; // edx
  int v2; // eax
  int v3; // edx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // edx
  _DWORD *v10; // edi
  unsigned int v11; // ebx
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  int result; // eax
  int v16[2100]; // [esp+18h] [ebp-20D0h] BYREF

  v1 = *(_DWORD *)(a1 + 344);
  v2 = *(_DWORD *)(a1 + 244);
  LOBYTE(v2) = v2 & 0xFD | 1;
  *(_DWORD *)(a1 + 244) = v2;
  *(_BYTE *)(a1 + 369) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_DWORD *)(v1 + 8716) = 0;
  *(_DWORD *)(v1 + 8720) = 0;
  *(_DWORD *)(v1 + 188) = 0;
  *(_BYTE *)(v1 + 14) &= 0xFBu;
  v3 = *(_DWORD *)(a1 + 344);
  v4 = *(_DWORD *)(v3 + 8404);
  if ( v4 < 0 )
  {
LABEL_9:
    v8 = *(_DWORD *)(a1 + 344);
    v9 = *(_DWORD *)(v8 + 8660);
    if ( v9 < 0 || !trap_GetArchivedPlayerState(v9, v8 + 8412, (int)v16) )
      return StopFollowing(a1);
  }
  else
  {
    *(_DWORD *)(v3 + 8660) = v4;
    while ( 1 )
    {
      v5 = *(_DWORD *)(a1 + 344);
      if ( *(int *)(v5 + 8412) < 0 )
        *(_DWORD *)(v5 + 8412) = 0;
      if ( trap_GetArchivedPlayerState(
             *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8404),
             *(_DWORD *)(a1 + 344) + 8412,
             (int)v16) )
      {
        break;
      }
      v6 = *(_DWORD *)(a1 + 344);
      v7 = *(_DWORD *)(v6 + 8412);
      if ( !v7 )
      {
        *(_DWORD *)(v6 + 8404) = -1;
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8660) = -1;
        goto LABEL_9;
      }
      *(_DWORD *)(v6 + 8412) = v7 - 50;
    }
  }
  v10 = *(_DWORD **)(a1 + 344);
  v11 = v16[32] & 0xFFFDFFFF;
  v12 = v10[32];
  qmemcpy(v10, v16, 0x20D0u);
  v13 = v12 & 0x20000 | v11;
  HudElem_UpdateClient(*(_DWORD **)(a1 + 344), *(_DWORD *)a1, 2);
  *(_BYTE *)(*(_DWORD *)(a1 + 344) + 14) &= 0xFBu;
  *(_BYTE *)(*(_DWORD *)(a1 + 344) + 14) |= 1u;
  v14 = *(_DWORD *)(a1 + 344);
  if ( *(int *)(v14 + 8404) >= 0 )
    *(_BYTE *)(v14 + 14) |= 2u;
  else
    *(_BYTE *)(v14 + 14) &= 0xFDu;
  result = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(result + 128) = v13;
  return result;
}

//----- (00040934) --------------------------------------------------------
int __cdecl StuckInClient(int a1)
{
  int v1; // eax
  int v2; // eax
  int *v3; // esi
  int v4; // eax
  int v5; // eax
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst5
  long double v10; // fst4
  long double v11; // fst2
  long double v12; // fst1
  long double v13; // fst0
  long double v14; // rt2
  long double v15; // fst0
  long double v16; // rtt
  long double v17; // fst0
  long double v18; // fst4
  long double v19; // fst0
  char v20; // fps^1
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  long double v24; // rt1
  long double v25; // fst1
  long double v26; // fst6
  char v27; // fps^1
  long double v28; // rt2
  long double v29; // fst2
  long double v30; // fst4
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  char v34; // fps^1
  bool v35; // c0
  char v36; // c2
  bool v37; // c3
  long double v38; // rt0
  long double v39; // fst6
  long double v40; // fst7
  long double v41; // rt0
  long double v42; // fst6
  char v43; // fps^1
  long double v44; // fst7
  bool v45; // c0
  char v46; // c2
  bool v47; // c3
  long double v48; // fst7
  long double v49; // fst7
  char v50; // fps^1
  long double v51; // fst6
  bool v52; // c0
  char v53; // c2
  bool v54; // c3
  long double v55; // fst7
  long double v56; // fst7
  char v57; // fps^1
  long double v58; // fst6
  bool v59; // c0
  char v60; // c2
  bool v61; // c3
  int v62; // edx
  char v63; // fps^1
  bool v64; // c0
  char v65; // c2
  bool v66; // c3
  long double v67; // fst7
  int v68; // edx
  char v69; // fps^1
  bool v70; // c0
  char v71; // c2
  bool v72; // c3
  long double v73; // fst6
  float v75; // [esp+38h] [ebp-80h]
  float v76; // [esp+3Ch] [ebp-7Ch]
  float v77; // [esp+40h] [ebp-78h]
  float v78; // [esp+44h] [ebp-74h]
  float v79; // [esp+48h] [ebp-70h]
  float v80; // [esp+4Ch] [ebp-6Ch]
  float v81; // [esp+50h] [ebp-68h]
  float v82; // [esp+54h] [ebp-64h]
  float v83; // [esp+58h] [ebp-60h]
  float v84; // [esp+5Ch] [ebp-5Ch]
  int v85; // [esp+60h] [ebp-58h]
  float v86; // [esp+64h] [ebp-54h] BYREF
  float v87; // [esp+68h] [ebp-50h]
  float v88; // [esp+6Ch] [ebp-4Ch] BYREF
  float v89; // [esp+70h] [ebp-48h]
  int v90; // [esp+74h] [ebp-44h]
  float v91; // [esp+84h] [ebp-34h]
  float v92; // [esp+88h] [ebp-30h]
  float v93; // [esp+8Ch] [ebp-2Ch]
  float v94; // [esp+90h] [ebp-28h]
  float v95; // [esp+94h] [ebp-24h]
  float v96; // [esp+98h] [ebp-20h]
  float v97; // [esp+9Ch] [ebp-1Ch]
  float v98; // [esp+A0h] [ebp-18h]
  float v99; // [esp+A4h] [ebp-14h]
  float v100; // [esp+A8h] [ebp-10h]
  float v101; // [esp+ACh] [ebp-Ch]
  float v102; // [esp+B0h] [ebp-8h]
  float v103; // [esp+B4h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 344);
  if ( (*(_BYTE *)(v1 + 14) & 4) == 0 )
    return 0;
  if ( *(_DWORD *)(v1 + 8400) )
    return 0;
  v2 = *(_DWORD *)(a1 + 280);
  if ( v2 != 0x2000000 && v2 != 0x4000000 )
    return 0;
  v85 = 0;
  v3 = g_entities;
  if ( level[120] <= 0 )
    return 0;
  while ( 1 )
  {
    if ( !*((_BYTE *)v3 + 352) )
      goto LABEL_40;
    v4 = v3[86];
    if ( (*(_BYTE *)(v4 + 14) & 4) == 0 )
      return 0;
    if ( *(_DWORD *)(v4 + 8400) )
      goto LABEL_40;
    if ( v3 == (int *)a1 )
      goto LABEL_40;
    if ( !v4 )
      goto LABEL_40;
    if ( v3[140] <= 0 )
      goto LABEL_40;
    v5 = v3[70];
    if ( v5 != 0x2000000 && v5 != 0x4000000 )
      goto LABEL_40;
    v84 = *((float *)v3 + 77);
    v83 = v84 + *((float *)v3 + 64);
    v101 = v83;
    v82 = *((float *)v3 + 78);
    v81 = v82 + *((float *)v3 + 65);
    v102 = v81;
    v6 = *((float *)v3 + 79);
    v80 = v6 + *((float *)v3 + 66);
    v103 = v80;
    v79 = *((float *)v3 + 67);
    v78 = v84 + v79;
    v98 = v78;
    v77 = v82 + *((float *)v3 + 68);
    v99 = v77;
    v76 = v6 + *((float *)v3 + 69);
    v100 = v76;
    v7 = *(float *)(a1 + 308);
    v8 = v7 + *(float *)(a1 + 256);
    v95 = v8;
    v75 = *(float *)(a1 + 312);
    v9 = v75 + *(float *)(a1 + 260);
    v96 = v9;
    v10 = *(float *)(a1 + 316);
    v11 = v10 + *(float *)(a1 + 264);
    v97 = v11;
    v12 = *(float *)(a1 + 268);
    v13 = v7 + v12;
    v92 = v13;
    v14 = v13;
    v15 = v75 + *(float *)(a1 + 272);
    v93 = v15;
    v16 = v15;
    v17 = v10;
    v18 = v16;
    v19 = v17 + *(float *)(a1 + 276);
    v94 = v19;
    v21 = v14 < v83;
    v22 = 0;
    v23 = v14 == v83;
    if ( (v20 & 0x45) == 1 )
      goto LABEL_40;
    v24 = v12;
    v25 = v8;
    v26 = v24;
    if ( v25 > v78 )
      goto LABEL_40;
    v28 = v11;
    v29 = v18;
    v30 = v28;
    v31 = v29 < v81;
    v32 = 0;
    v33 = v29 == v81;
    if ( (v27 & 0x45) == 1 )
      goto LABEL_40;
    if ( v9 > v77 )
      goto LABEL_40;
    v35 = v19 < v80;
    v36 = 0;
    v37 = v19 == v80;
    if ( (v34 & 0x45) == 1 || v30 > v76 )
      goto LABEL_40;
    if ( (*(_BYTE *)(a1 + 245) & 2) == 0 )
      break;
    if ( (*((_BYTE *)v3 + 245) & 2) != 0 )
    {
      v88 = v84 - v7;
      v38 = v26;
      v39 = v82 - v75;
      v89 = v39;
      v40 = v38 + v79;
      v41 = v39 * v39;
      v42 = v40 * v40;
      v44 = v41 + v88 * v88;
      v45 = v42 < v44;
      v46 = 0;
      v47 = v42 == v44;
      if ( (v43 & 0x45) != 1 )
        goto LABEL_30;
    }
    else
    {
      v88 = v84 - v7;
      v89 = v82 - v75;
      v86 = v88;
      v87 = v89;
      VectorNormalize2D(&v86);
      v48 = -*(float *)(a1 + 268);
      v88 = v86 * v48 + v88;
      v89 = v48 * v87 + v89;
      v49 = fabs(v88);
      v51 = *((float *)v3 + 67);
      v52 = v51 < v49;
      v53 = 0;
      v54 = v51 == v49;
      if ( (v50 & 0x45) != 1 || fabs(v89) <= *((float *)v3 + 68) )
        goto LABEL_30;
    }
LABEL_40:
    ++v85;
    v3 += 197;
    if ( v85 >= level[120] )
      return 0;
  }
  if ( (*((_BYTE *)v3 + 245) & 2) != 0 )
  {
    v88 = v7 - v84;
    v89 = v75 - v82;
    v86 = v88;
    v87 = v89;
    VectorNormalize2D(&v86);
    v55 = -*((float *)v3 + 67);
    v88 = v86 * v55 + v88;
    v89 = v55 * v87 + v89;
    v56 = fabs(v88);
    v58 = *(float *)(a1 + 268);
    v59 = v58 < v56;
    v60 = 0;
    v61 = v58 == v56;
    if ( (v57 & 0x45) == 1 && fabs(v89) > *(float *)(a1 + 272) )
      goto LABEL_40;
  }
LABEL_30:
  v88 = *((float *)v3 + 77) - *(float *)(a1 + 308);
  v89 = *((float *)v3 + 78) - *(float *)(a1 + 312);
  v90 = rand();
  v88 = (long double)v90 * -4.6566129e-10 + (long double)v90 * -4.6566129e-10 - 1.0 + v88;
  v90 = rand();
  v89 = (long double)v90 * -4.6566129e-10 + (long double)v90 * -4.6566129e-10 - 1.0 + v89;
  VectorNormalize2D(&v88);
  v62 = v3[86];
  v91 = sqrt(*(float *)(v62 + 32) * *(float *)(v62 + 32) + *(float *)(v62 + 36) * *(float *)(v62 + 36));
  v64 = v91 > 0.0;
  v65 = 0;
  v66 = 0.0 == v91;
  if ( (v63 & 0x45) == 1 )
  {
    v90 = *(_DWORD *)(v62 + 68);
    v67 = (long double)v90;
  }
  else
  {
    v67 = 0.0;
  }
  v68 = *(_DWORD *)(a1 + 344);
  v91 = sqrt(*(float *)(v68 + 32) * *(float *)(v68 + 32) + *(float *)(v68 + 36) * *(float *)(v68 + 36));
  v70 = v91 > 0.0;
  v71 = 0;
  v72 = 0.0 == v91;
  if ( (v69 & 0x45) == 1 )
  {
    v90 = *(_DWORD *)(v68 + 68);
    v73 = (long double)v90;
  }
  else
  {
    v73 = 0.0;
  }
  if ( v67 < 0.000099999997 && v73 < 0.000099999997 )
  {
    v90 = *(_DWORD *)(v3[86] + 68);
    v67 = (long double)v90;
    v90 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 68);
    v73 = (long double)v90;
  }
  *(float *)(v3[86] + 32) = v88 * v67;
  *(float *)(v3[86] + 36) = v67 * v89;
  *(_DWORD *)(v3[86] + 16) = 300;
  *(_BYTE *)(v3[86] + 13) |= 1u;
  *(float *)(*(_DWORD *)(a1 + 344) + 32) = v88 * -v73;
  *(float *)(*(_DWORD *)(a1 + 344) + 36) = -v73 * v89;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 16) = 300;
  *(_BYTE *)(*(_DWORD *)(a1 + 344) + 13) |= 1u;
  return 1;
}
// 40AD8: variable 'v20' is possibly undefined
// 40AFB: variable 'v27' is possibly undefined
// 40B1E: variable 'v34' is possibly undefined
// 40B86: variable 'v43' is possibly undefined
// 40C02: variable 'v50' is possibly undefined
// 40CA1: variable 'v57' is possibly undefined
// 40D64: variable 'v63' is possibly undefined
// 40D9D: variable 'v69' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (00040E98) --------------------------------------------------------
int __cdecl ClientEndFrame(int a1)
{
  int result; // eax
  int v2; // edi
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // eax
  long double v10; // fst7
  long double v11; // fst7
  int v12; // eax
  int v13; // eax
  char *v14; // ebx
  char *v15; // ebx
  char *v16; // ebx
  int v17; // [esp+1Ch] [ebp-5Ch]
  int v18; // [esp+20h] [ebp-58h]
  char *s1; // [esp+24h] [ebp-54h]
  int v20; // [esp+28h] [ebp-50h]
  int v21; // [esp+2Ch] [ebp-4Ch]
  int v22; // [esp+30h] [ebp-48h]
  int v23; // [esp+34h] [ebp-44h]
  int v24; // [esp+38h] [ebp-40h]
  int *v25; // [esp+3Ch] [ebp-3Ch]
  int v26[3]; // [esp+54h] [ebp-24h] BYREF
  float v27[3]; // [esp+60h] [ebp-18h] BYREF
  float v28[2]; // [esp+6Ch] [ebp-Ch] BYREF
  float v29; // [esp+74h] [ebp-4h]

  result = a1;
  v2 = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(a1 + 544) = 0;
  *(_DWORD *)(v2 + 8396) = 0;
  if ( *(_DWORD *)(v2 + 8428) == 2 )
  {
    v3 = *(_DWORD *)(v2 + 8400);
    if ( v3 == 3 )
    {
      *(_BYTE *)(a1 + 369) = 0;
      *(_DWORD *)(a1 + 280) = 0;
      v4 = *(_DWORD *)(a1 + 344);
      result = *(_DWORD *)(a1 + 244);
      LOBYTE(result) = result & 0xFD | 1;
      *(_DWORD *)(a1 + 244) = result;
      *(_DWORD *)(v4 + 4) = 5;
      *(_DWORD *)(v4 + 188) = 0;
      *(_BYTE *)(v4 + 14) &= 0xFBu;
      *(_DWORD *)(v4 + 128) &= 0xFFFBFBFF;
    }
    else if ( v3 == 2 )
    {
      result = SpectatorClientEndFrame(a1);
    }
    else if ( *(_DWORD *)(v2 + 172) == *(_DWORD *)a1 )
    {
      *(_BYTE *)(a1 + 369) = 1;
      v5 = *(_DWORD *)(a1 + 244);
      LOBYTE(v5) = (v5 | 2) & 0xFE;
      *(_DWORD *)(a1 + 244) = v5;
      v6 = *(_DWORD *)(v2 + 8560);
      *(_BYTE *)(v2 + 14) |= 4u;
      *(_DWORD *)(v2 + 188) = v6;
      v7 = *(_DWORD **)(a1 + 344);
      if ( v7[2166] )
      {
        *(_DWORD *)(a1 + 280) = 0;
      }
      else if ( v7[2167] )
      {
        *(_DWORD *)(a1 + 280) = 0;
      }
      else if ( v7[2100] == 1 )
      {
        *(_DWORD *)(a1 + 280) = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 280) = 0x2000000;
      }
      *(_DWORD *)(v2 + 8780) = 0;
      if ( *(_DWORD *)(v2 + 8808) <= level[122] )
        *(_BYTE *)(v2 + 130) &= 0xF7u;
      if ( *(_DWORD *)(v2 + 8664) )
      {
        *(_DWORD *)(v2 + 4) = 2;
      }
      else if ( *(_DWORD *)(v2 + 8668) )
      {
        *(_DWORD *)(v2 + 4) = 3;
      }
      else if ( *(_DWORD *)(v2 + 8400) == 1 )
      {
        v8 = 6;
        if ( *(_DWORD *)(a1 + 740) )
          v8 = 7;
        *(_DWORD *)(v2 + 4) = v8;
        *(_BYTE *)(a1 + 369) = 0;
        v9 = *(_DWORD *)(a1 + 244);
        LOBYTE(v9) = (v9 | 1) & 0xFD;
        *(_DWORD *)(a1 + 244) = v9;
      }
      else
      {
        *(_DWORD *)(v2 + 4) = *(_DWORD *)(a1 + 740) != 0;
      }
      *(_DWORD *)(v2 + 60) = (int)g_gravity[2];
      v10 = *(float *)(v2 + 984) / 255.0;
      *(_DWORD *)(v2 + 68) = (int)g_speed[2];
      *(float *)(v2 + 8768) = v10;
      G_CheckForPreventFriendlyFire(a1);
      G_CheckForCursorHints(a1);
      P_DamageFeedback(a1);
      if ( level[122] - *(_DWORD *)(v2 + 8676) <= 1000 )
        *(_BYTE *)(a1 + 9) &= 0xEFu;
      else
        *(_BYTE *)(a1 + 9) |= 0x10u;
      *(_DWORD *)(v2 + 244) = *(_DWORD *)(a1 + 560);
      *(_DWORD *)(a1 + 132) = 0;
      if ( g_smoothClients[3] )
        BG_PlayerStateToEntityStateExtrapolate(v2, a1, *(_DWORD *)v2, 1);
      else
        BG_PlayerStateToEntityState(v2, a1, 1);
      if ( *(int *)(a1 + 560) > 0 && StuckInClient(a1) )
        *(_DWORD *)(a1 + 280) = 0x4000000;
      v28[0] = *(float *)(v2 + 20);
      v28[1] = *(float *)(v2 + 24);
      v11 = *(float *)(v2 + 28);
      v29 = *(float *)(v2 + 28);
      v29 = v11 + *(float *)(v2 + 208);
      G_AddLean(a1, v28);
      result = G_GetNonPVSFriendlyInfo(a1, v28, *(_DWORD *)(v2 + 8804));
      *(_DWORD *)(v2 + 960) = result;
      if ( result )
      {
        v12 = result & 0x3F;
        *(_DWORD *)(v2 + 8804) = v12;
        result = 788 * v12;
        if ( (*((_BYTE *)&g_entities + result + 10) & 8) != 0 )
          *(_BYTE *)(v2 + 130) |= 0x10u;
        else
          *(_BYTE *)(v2 + 130) &= 0xEFu;
      }
      else
      {
        *(_DWORD *)(v2 + 8804) = 1023;
      }
      if ( *(_DWORD *)(a1 + 4) == 1 )
      {
        v13 = 274 * *(_DWORD *)(a1 + 144);
        *(_DWORD *)(a1 + 544) = sub_416C0;
        v25 = &bgs[v13 + 159163];
        v25[247] = *(int *)(a1 + 108);
        v25[248] = *(int *)(a1 + 212);
        v25[249] = *(int *)(v2 + 192);
        v25[250] = *(int *)(v2 + 196);
        v25[251] = *(int *)(v2 + 200);
        v23 = 0;
        v14 = (char *)G_ModelName(*(unsigned __int8 *)(a1 + 373));
        *(_DWORD *)(v2 + 8576) = *(unsigned __int8 *)(a1 + 373);
        if ( strcmp((const char *)v25 + 60, v14) )
        {
          v23 = 1;
          Q_strncpyz((char *)v25 + 60, v14, 64);
        }
        v22 = a1 + 748;
        v24 = 0;
        v21 = v2 + 8580;
        v20 = v2 + 8604;
        s1 = (char *)(v25 + 31);
        v18 = 0;
        v17 = 0;
        do
        {
          if ( *(_BYTE *)(v24 + v22) )
          {
            v15 = (char *)G_ModelName(*(unsigned __int8 *)(v24 + v22));
            *(_DWORD *)(v21 + v17) = *(unsigned __int8 *)(v24 + v22);
            if ( strcmp(s1, v15) )
            {
              v23 = 1;
              Q_strncpyz(s1, v15, 64);
            }
            v16 = (char *)SL_ConvertToString(*(_WORD *)(a1 + 754 + 2 * v24));
            *(_DWORD *)(v17 + v20) = G_TagIndex(v16);
            if ( strcmp((const char *)&v25[v18 + 127], v16) )
            {
              v23 = 1;
              Q_strncpyz((char *)&v25[v18 + 127], v16, 64);
            }
          }
          else
          {
            LOBYTE(v25[v18 + 31]) = 0;
            LOBYTE(v25[v18 + 127]) = 0;
            *(_DWORD *)(v21 + v17) = 0;
            *(_DWORD *)(v20 + v17) = 0;
          }
          s1 += 64;
          v18 += 16;
          v17 += 4;
          ++v24;
        }
        while ( v24 <= 5 );
        if ( v23 )
          G_SafeDObjFree(a1);
        BG_UpdatePlayerDObj(a1, a1, v25);
        result = BG_PlayerAnimation(a1, a1, v25);
        if ( (*(_BYTE *)(v2 + 14) & 4) != 0 && (*(_BYTE *)(v2 + 129) & 0xC0) != 0 )
          result = turret_think_client(level[1] + 788 * *(_DWORD *)(v2 + 888));
        if ( g_debugLocDamage[3] )
        {
          result = trap_DObjExists(a1);
          if ( result )
          {
            G_DObjCalcPose(a1);
            result = trap_XModelDebugBoxes(a1);
          }
        }
      }
    }
    else
    {
      v27[0] = *(float *)(v2 + 20);
      v27[1] = *(float *)(v2 + 24);
      v27[2] = *(float *)(v2 + 28);
      v26[0] = 0;
      v26[1] = *(int *)(v2 + 196);
      v26[2] = 0;
      result = ClientSpawn(a1, v27, v26);
    }
  }
  return result;
}
// 2BD80: using guessed type _DWORD __cdecl BG_UpdatePlayerDObj(_DWORD, _DWORD, _DWORD);
// 2C1F4: using guessed type _DWORD __cdecl BG_PlayerAnimation(_DWORD, _DWORD, _DWORD);
// 2CBE8: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 2D004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 3F500: using guessed type _DWORD __cdecl P_DamageFeedback(_DWORD);
// 40760: using guessed type _DWORD __cdecl SpectatorClientEndFrame(_DWORD);
// 40934: using guessed type _DWORD __cdecl StuckInClient(_DWORD);
// 416C0: using guessed type int __cdecl sub_416C0(int, int);
// 4268C: using guessed type _DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD);
// 42C30: using guessed type _DWORD __cdecl G_GetNonPVSFriendlyInfo(_DWORD, _DWORD, _DWORD);
// 42F3C: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 4F59C: using guessed type _DWORD __cdecl G_CheckForCursorHints(_DWORD);
// 4F88C: using guessed type _DWORD __cdecl G_CheckForPreventFriendlyFire(_DWORD);
// 52340: using guessed type _DWORD __cdecl turret_think_client(_DWORD);
// 63DAC: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 64528: using guessed type _DWORD __cdecl trap_XModelDebugBoxes(_DWORD);
// 66F8C: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 670E0: using guessed type _DWORD __cdecl G_SafeDObjFree(_DWORD);
// 67314: using guessed type _DWORD __cdecl G_DObjCalcPose(_DWORD);
// 6C400: using guessed type _DWORD __cdecl SL_ConvertToString(__int16);
// C13C0: using guessed type int bgs[];
// 21DF80: using guessed type int g_entities;

//----- (000414F8) --------------------------------------------------------
_DWORD *__cdecl G_SetClientContents(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 344);
  if ( result[2166] || result[2167] || result[2100] == 1 )
    *(_DWORD *)(a1 + 280) = 0;
  else
    *(_DWORD *)(a1 + 280) = 0x2000000;
  return result;
}

//----- (00041540) --------------------------------------------------------
int __cdecl ClientThink(int a1)
{
  int *v1; // ebx
  int result; // eax

  v1 = &g_entities[197 * a1];
  qmemcpy((void *)(v1[86] + 8456), (const void *)(v1[86] + 8432), 0x18u);
  trap_GetUsercmd(a1, v1[86] + 8432);
  result = level[122];
  *(_DWORD *)(v1[86] + 8676) = result;
  if ( !g_synchronousClients[3] )
    result = ClientThink_real((int)v1, (int *)(v1[86] + 8432));
  return result;
}

//----- (000415C4) --------------------------------------------------------
int __cdecl GetFollowPlayerState(int a1, int a2)
{
  _BYTE *v2; // esi

  v2 = (_BYTE *)g_entities[197 * a1 + 86];
  if ( (v2[14] & 4) == 0 )
    return 0;
  qmemcpy((void *)a2, v2, 0x20D0u);
  _bzero((void *)(a2 + 1448), 0xD90u);
  return 1;
}
// 21DF80: using guessed type int g_entities[];

//----- (00041614) --------------------------------------------------------
int __cdecl G_SetClientSound(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (00041628) --------------------------------------------------------
int __cdecl ClientIntermissionThink(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(result + 8684) = *(_DWORD *)(result + 8680);
  *(_DWORD *)(result + 8680) = *(unsigned __int8 *)(result + 8436);
  *(_DWORD *)(result + 8696) = *(_DWORD *)(result + 8692);
  *(_DWORD *)(result + 8692) = *(unsigned __int8 *)(result + 8437);
  return result;
}

//----- (0004166C) --------------------------------------------------------
int __cdecl IntermissionClientEndFrame(int a1)
{
  int result; // eax
  int v2; // ecx

  result = a1;
  *(_BYTE *)(a1 + 369) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  v2 = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a1 + 244) & 0xFFFFFFFD | 1;
  *(_DWORD *)(v2 + 4) = 5;
  *(_DWORD *)(v2 + 188) = 0;
  *(_BYTE *)(v2 + 14) &= 0xFBu;
  *(_DWORD *)(v2 + 128) &= 0xFFFBFBFF;
  return result;
}

//----- (000416C0) --------------------------------------------------------
int __cdecl sub_416C0(_DWORD *a1, int a2)
{
  return BG_Player_DoControllers(a1, (int)a1, a2, (int)&bgs[274 * a1[36] + 159163]);
}
// C13C0: using guessed type int bgs[];

//----- (00041700) --------------------------------------------------------
void __cdecl GScr_AddFieldsForClient(unsigned __int16 a1)
{
  int *v1; // ebx
  unsigned int v2; // eax
  int v3; // eax

  v1 = (int *)&off_72ED4;
  if ( "name" )
  {
    do
    {
      v2 = v1[2];
      if ( v2 <= 5 || v2 == 7 )
      {
        v3 = (-858993459 * ((char *)v1 - (char *)&off_72ED4)) >> 2;
        BYTE1(v3) |= 0xC0u;
        Scr_AddClassField(a1, *v1, v3);
      }
      v1 += 5;
    }
    while ( *v1 );
  }
}
// 72ED4: using guessed type char *off_72ED4;

//----- (00041768) --------------------------------------------------------
void __cdecl Scr_SetClientField(int a1, int a2)
{
  void (__cdecl *v2)(int, int, const char **); // eax

  v2 = (void (__cdecl *)(int, int, const char **))*(&funcs_41795 + 5 * a2);
  if ( v2 )
    v2(a1, a1, (const char **)&(&off_72ED4)[5 * a2]);
  else
    Scr_SetGenericField(a1, dword_72EDC[5 * a2], dword_72ED8[5 * a2]);
}
// 72ED4: using guessed type char *off_72ED4;
// 72ED8: using guessed type int dword_72ED8[];
// 72EDC: using guessed type int dword_72EDC[];
// 72EE0: using guessed type int (__cdecl *funcs_41795)(int, int, int);

//----- (000417C0) --------------------------------------------------------
int __cdecl Scr_GetClientField(int a1, int a2)
{
  int (__cdecl *v2)(int, int, char **); // eax
  int result; // eax

  v2 = (int (__cdecl *)(int, int, char **))dword_72EE4[5 * a2];
  if ( v2 )
    result = v2(a1, a1, &(&off_72ED4)[5 * a2]);
  else
    result = Scr_GetGenericField(a1, dword_72EDC[5 * a2], dword_72ED8[5 * a2]);
  return result;
}
// 72ED4: using guessed type char *off_72ED4;
// 72ED8: using guessed type int dword_72ED8[];
// 72EDC: using guessed type int dword_72EDC[];
// 72EE4: using guessed type int dword_72EE4[];

//----- (00041810) --------------------------------------------------------
int __cdecl sub_41810(int a1, int a2, const char **a3)
{
  char *v3; // eax

  v3 = va("player field %s is read-only\n", *a3);
  return Scr_Error((int)v3);
}

//----- (00041838) --------------------------------------------------------
void __cdecl sub_41838(int a1)
{
  unsigned __int16 v1; // ax
  const char *v2; // eax
  char *v3; // eax

  v1 = Scr_GetConstString(0);
  if ( v1 == scr_const[4] )
  {
    *(_DWORD *)(a1 + 8572) = 1;
  }
  else if ( v1 == scr_const[2] )
  {
    *(_DWORD *)(a1 + 8572) = 2;
  }
  else if ( v1 == scr_const[62] )
  {
    *(_DWORD *)(a1 + 8572) = 3;
  }
  else if ( v1 == scr_const[124] )
  {
    *(_DWORD *)(a1 + 8572) = 0;
  }
  else
  {
    v2 = (const char *)SL_ConvertToString(v1);
    v3 = va("'%s' is an illegal sessionteam string. Must be allies, axis, none, or spectator.", v2);
    Scr_Error((int)v3);
  }
  ClientUserinfoChanged((-1893646255 * (a1 - level[0])) >> 2);
  CalculateRanks();
}

//----- (000418FC) --------------------------------------------------------
int __cdecl sub_418FC(int a1)
{
  int result; // eax
  unsigned __int16 v2; // ax

  result = *(_DWORD *)(a1 + 8572);
  switch ( result )
  {
    case 1:
      v2 = scr_const[4];
      return Scr_AddConstString(v2);
    case 0:
      return Scr_AddConstString(scr_const[124]);
    case 2:
      v2 = scr_const[2];
      return Scr_AddConstString(v2);
    case 3:
      v2 = scr_const[62];
      return Scr_AddConstString(v2);
  }
  return result;
}

//----- (00041968) --------------------------------------------------------
int __cdecl sub_41968(int a1)
{
  int result; // eax
  const char *v2; // eax
  char *v3; // eax

  result = Scr_GetConstString(0);
  if ( (_WORD)result == scr_const[104] )
  {
    *(_DWORD *)(a1 + 8400) = 0;
  }
  else if ( (_WORD)result == scr_const[125] )
  {
    *(_DWORD *)(a1 + 8400) = 1;
  }
  else if ( (_WORD)result == scr_const[62] )
  {
    *(_DWORD *)(a1 + 8400) = 2;
  }
  else if ( (_WORD)result == scr_const[91] )
  {
    *(_DWORD *)(a1 + 8400) = 3;
  }
  else
  {
    v2 = (const char *)SL_ConvertToString(result);
    v3 = va("'%s' is an illegal sessionstate string. Must be playing, dead, spectator, or intermission.", v2);
    result = Scr_Error((int)v3);
  }
  return result;
}

//----- (00041A0C) --------------------------------------------------------
int __cdecl sub_41A0C(int a1)
{
  int result; // eax
  unsigned __int16 v2; // ax

  result = *(_DWORD *)(a1 + 8400);
  switch ( result )
  {
    case 1:
      v2 = scr_const[125];
      return Scr_AddConstString(v2);
    case 0:
      v2 = scr_const[104];
      return Scr_AddConstString(v2);
    case 2:
      v2 = scr_const[62];
      return Scr_AddConstString(v2);
    case 3:
      result = Scr_AddConstString(scr_const[91]);
      break;
  }
  return result;
}

//----- (00041A78) --------------------------------------------------------
int __cdecl sub_41A78(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  v1 = Scr_GetInt(0);
  a1[2132] = v1;
  if ( v1 <= 0 )
    a1[2132] = 1;
  v2 = a1[2132];
  if ( a1[61] > v2 )
    a1[61] = v2;
  g_entities[197 * ((-1893646255 * ((int)a1 - level[0])) >> 2) + 140] = a1[61];
  result = a1[2132];
  a1[63] = result;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00041AEC) --------------------------------------------------------
void __cdecl sub_41AEC(int a1)
{
  *(_DWORD *)(a1 + 8416) = Scr_GetInt(0);
  CalculateRanks();
}

//----- (00041B14) --------------------------------------------------------
int __cdecl sub_41B14(int a1)
{
  int v1; // ebx
  int result; // eax

  v1 = Scr_GetInt(0);
  if ( (unsigned int)(v1 + 1) > 0x40 )
    Scr_Error((int)"spectatorclient can only be set to -1, or a valid client number");
  result = a1;
  *(_DWORD *)(a1 + 8404) = v1;
  return result;
}

//----- (00041B50) --------------------------------------------------------
int __cdecl sub_41B50(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = (char *)Scr_GetString(0);
  result = GScr_GetStatusIconIndex(v1);
  *(_DWORD *)(a1 + 8408) = result;
  return result;
}

//----- (00041B7C) --------------------------------------------------------
int __cdecl sub_41B7C(int a1)
{
  int result; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  result = *(_DWORD *)(a1 + 8408);
  if ( !result )
    return Scr_AddString((int)&unk_72E60);
  if ( result <= 8 )
  {
    trap_GetConfigstring(result + 20, (int)v2, 1024);
    result = Scr_AddString((int)v2);
  }
  return result;
}

//----- (00041BD4) --------------------------------------------------------
int __cdecl sub_41BD4(int a1)
{
  int v1; // ebx
  char *v2; // eax
  int result; // eax

  v1 = 197 * ((-1893646255 * (a1 - level[0])) >> 2);
  v2 = (char *)Scr_GetString(0);
  result = GScr_GetHeadIconIndex(v2);
  g_entities[v1 + 37] = result;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00041C14) --------------------------------------------------------
int __cdecl sub_41C14(int a1)
{
  int result; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  result = g_entities[197 * ((-1893646255 * (a1 - level[0])) >> 2) + 37];
  if ( !result )
    return Scr_AddString((int)&unk_72E60);
  if ( result <= 15 )
  {
    trap_GetConfigstring(result + 28, (int)v2, 1024);
    result = Scr_AddString((int)v2);
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00041C84) --------------------------------------------------------
int __cdecl sub_41C84(int a1)
{
  int v1; // ebx
  int result; // eax
  const char *v3; // eax
  char *v4; // eax

  v1 = 197 * ((-1893646255 * (a1 - level[0])) >> 2);
  result = Scr_GetConstString(0);
  if ( (_WORD)result == scr_const[124] )
  {
    g_entities[v1 + 38] = 0;
  }
  else if ( (_WORD)result == scr_const[2] )
  {
    g_entities[v1 + 38] = 2;
  }
  else if ( (_WORD)result == scr_const[4] )
  {
    g_entities[v1 + 38] = 1;
  }
  else if ( (_WORD)result == scr_const[62] )
  {
    v3 = (const char *)SL_ConvertToString(result);
    v4 = va("'%s' is an illegal head icon team string. Must be none, allies, axis, or spectator.", v3);
    result = Scr_Error((int)v4);
  }
  else
  {
    g_entities[v1 + 38] = 3;
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00041D3C) --------------------------------------------------------
int __cdecl sub_41D3C(int a1)
{
  int v1; // eax
  unsigned __int16 v2; // ax

  v1 = g_entities[197 * ((-1893646255 * (a1 - level[0])) >> 2) + 38];
  if ( v1 == 2 )
  {
    v2 = scr_const[2];
    return Scr_AddConstString(v2);
  }
  if ( v1 > 2 )
  {
    if ( v1 != 3 )
      return Scr_AddConstString(scr_const[124]);
    v2 = scr_const[62];
    return Scr_AddConstString(v2);
  }
  if ( v1 == 1 )
  {
    v2 = scr_const[4];
    return Scr_AddConstString(v2);
  }
  return Scr_AddConstString(scr_const[124]);
}
// 21DF80: using guessed type int g_entities[];

//----- (00041DB8) --------------------------------------------------------
int __cdecl sub_41DB8(int a1)
{
  int result; // eax

  result = (int)(Scr_GetFloat(0) * 1000.0);
  *(_DWORD *)(a1 + 8412) = result;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00041DFC) --------------------------------------------------------
int __cdecl sub_41DFC(int a1)
{
  float v2; // [esp-10h] [ebp-28h]

  v2 = (long double)*(int *)(a1 + 8412) * 0.001;
  return Scr_AddFloat(v2);
}

//----- (00041E30) --------------------------------------------------------
int __cdecl SetClientViewAngle(int a1, float *a2)
{
  long double v2; // fst7
  int v3; // eax
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst7
  char v18; // fps^1
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst7
  long double v23; // fst7
  char v24; // fps^1
  long double v25; // fst6
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  char v29; // fps^1
  bool v30; // c0
  char v31; // c2
  bool v32; // c3
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  long double v36; // fst7
  char v37; // fps^1
  bool v38; // c0
  char v39; // c2
  bool v40; // c3
  long double v41; // fst7
  int v42; // ecx
  int v43; // ebx
  long double v44; // fst7
  int result; // eax
  float v46; // [esp-20h] [ebp-48h]
  float v47; // [esp-20h] [ebp-48h]
  float v48; // [esp-10h] [ebp-38h]
  float v49; // [esp-10h] [ebp-38h]
  float v50; // [esp-Ch] [ebp-34h]
  float v51; // [esp+1Ch] [ebp-Ch]
  float v52; // [esp+20h] [ebp-8h]
  float v53; // [esp+24h] [ebp-4h]

  v51 = *a2;
  v2 = a2[1];
  v52 = a2[1];
  v53 = a2[2];
  v3 = *(_DWORD *)(a1 + 344);
  if ( (*(_BYTE *)(v3 + 12) & 1) == 0 || (*(_BYTE *)(v3 + 129) & 0xC0) != 0 )
    goto LABEL_23;
  v50 = v2;
  v46 = AngleDelta(*(float *)(v3 + 872), v50);
  v4 = AngleNormalize180(v46);
  v6 = 45.0;
  v7 = v4 > 45.0;
  v8 = 0;
  v9 = 45.0 == v4;
  if ( (v5 & 0x45) == 1 )
    goto LABEL_6;
  v11 = v4 < -45.0;
  v12 = 0;
  v13 = v4 == -45.0;
  if ( (v10 & 0x45) == 1 )
  {
    v6 = 45.0;
LABEL_6:
    v14 = v6 < v4;
    v15 = 0;
    v16 = v6 == v4;
    if ( (v5 & 0x45) == 1 )
      v17 = v4 - v6;
    else
      v17 = v4 + v6;
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 76) += (unsigned __int16)(int)(v17 * 182.04445);
    v19 = v17 > 0.0;
    v20 = 0;
    v21 = 0.0 == v17;
    if ( (v18 & 0x45) == 1 )
      v22 = *(float *)(*(_DWORD *)(a1 + 344) + 872) - 45.0;
    else
      v22 = *(float *)(*(_DWORD *)(a1 + 344) + 872) + 45.0;
    v48 = v22;
    v52 = AngleNormalize360(v48);
  }
  v47 = AngleDelta(*(float *)(*(_DWORD *)(a1 + 344) + 880), v51);
  v23 = AngleNormalize180(v47);
  v25 = 45.0;
  v26 = v23 > 45.0;
  v27 = 0;
  v28 = 45.0 == v23;
  if ( (v24 & 0x45) != 1 )
  {
    v30 = v23 < -15.0;
    v31 = 0;
    v32 = v23 == -15.0;
    if ( (v29 & 0x45) != 1 )
      goto LABEL_23;
    v25 = 45.0;
  }
  v33 = v25 < v23;
  v34 = 0;
  v35 = v25 == v23;
  if ( (v24 & 0x45) == 1 )
    v36 = v23 - v25;
  else
    v36 = v23 + 15.0;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 72) += (unsigned __int16)(int)(v36 * 182.04445);
  v38 = v36 > 0.0;
  v39 = 0;
  v40 = 0.0 == v36;
  if ( (v37 & 0x45) == 1 )
    v41 = *(float *)(*(_DWORD *)(a1 + 344) + 880) - 45.0;
  else
    v41 = *(float *)(*(_DWORD *)(a1 + 344) + 880) + 15.0;
  v49 = v41;
  v51 = AngleNormalize180(v49);
LABEL_23:
  v42 = 0;
  v43 = 2;
  do
  {
    *(_DWORD *)(v42 + *(_DWORD *)(a1 + 344) + 72) = (unsigned __int16)(int)(*(float *)((char *)&v51 + v42) * 182.04445)
                                                  - *(_DWORD *)(v42 + *(_DWORD *)(a1 + 344) + 8440);
    v42 += 4;
    --v43;
  }
  while ( v43 >= 0 );
  v44 = v51;
  *(float *)(a1 + 320) = v51;
  *(float *)(a1 + 324) = v52;
  *(float *)(a1 + 328) = v53;
  *(float *)(*(_DWORD *)(a1 + 344) + 192) = v44;
  *(float *)(*(_DWORD *)(a1 + 344) + 196) = *(float *)(a1 + 324);
  result = *(_DWORD *)(a1 + 344);
  *(float *)(result + 200) = *(float *)(a1 + 328);
  return result;
}
// 41EA2: variable 'v5' is possibly undefined
// 41EB4: variable 'v10' is possibly undefined
// 41F0C: variable 'v18' is possibly undefined
// 41F92: variable 'v24' is possibly undefined
// 41FA4: variable 'v29' is possibly undefined
// 42002: variable 'v37' is possibly undefined

//----- (000420F4) --------------------------------------------------------
int __cdecl ClientUserinfoChanged(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // edx
  _BYTE *v4; // ecx
  int v5; // ebx
  char *v6; // edi
  int v7; // esi
  _BYTE *v8; // ecx
  char v9; // al
  char *v10; // edx
  _BYTE *v11; // ecx
  int v12; // ebx
  char *v13; // edi
  int v14; // esi
  _BYTE *v15; // ecx
  char v16; // al
  char *v17; // eax
  int v18; // eax
  int result; // eax
  char *src; // [esp+20h] [ebp-818h]
  int v21; // [esp+28h] [ebp-810h]
  int v22; // [esp+2Ch] [ebp-80Ch]
  int v23; // [esp+30h] [ebp-808h]
  int v24; // [esp+34h] [ebp-804h]
  char dest[1024]; // [esp+38h] [ebp-800h] BYREF
  char v26[1024]; // [esp+438h] [ebp-400h] BYREF

  v24 = g_entities[197 * a1 + 86];
  trap_GetUserinfo(a1, (int)dest, 1024);
  if ( !Info_Validate(dest) )
    strcpy(dest, "\\name\\badinfo");
  v1 = Info_ValueForKey(dest, "ip");
  if ( v1 && !strcmp(v1, "localhost") )
    *(_DWORD *)(v24 + 8480) = 1;
  v2 = Info_ValueForKey(dest, "cg_predictItems");
  if ( _strtol_internal(v2, 0, 10, 0) )
    *(_DWORD *)(v24 + 8484) = 1;
  else
    *(_DWORD *)(v24 + 8484) = 0;
  if ( *(_DWORD *)(v24 + 8428) == 2 && level[132] )
  {
    v3 = Info_ValueForKey(dest, "name");
    v4 = (_BYTE *)(v24 + 8492);
    v5 = 0;
    v23 = 0;
    v6 = (char *)(v24 + 8492);
    *(_BYTE *)(v24 + 8492) = 0;
    v7 = 0;
    src = (char *)(v24 + 8628);
    v21 = 274 * a1;
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          v9 = *v3++;
          if ( !v9 )
          {
LABEL_27:
            *v4 = 0;
            if ( !*v6 || !v23 )
              Q_strncpyz(v6, "UnnamedPlayer", 31);
            goto LABEL_50;
          }
        }
        while ( !*v6 && v9 == 32 );
        if ( v9 != 94 )
          break;
        if ( !*v3 )
          goto LABEL_27;
        if ( (*v3 & 7) != 0 )
        {
          if ( v5 > 29 )
            goto LABEL_27;
          *v4 = 94;
          v8 = v4 + 1;
          *v8 = *v3++;
          v4 = v8 + 1;
          v5 += 2;
        }
        else
        {
          ++v3;
        }
      }
      if ( v9 != 32 )
        break;
      if ( ++v7 <= 3 )
      {
LABEL_17:
        if ( v5 > 30 )
          goto LABEL_27;
        *v4++ = v9;
        ++v23;
        ++v5;
      }
    }
    v7 = 0;
    goto LABEL_17;
  }
  Q_strncpyz(v26, (char *)(v24 + 8628), 1024);
  v10 = Info_ValueForKey(dest, "name");
  v11 = (_BYTE *)(v24 + 8628);
  v12 = 0;
  v22 = 0;
  v13 = (char *)(v24 + 8628);
  *(_BYTE *)(v24 + 8628) = 0;
  v14 = 0;
  src = (char *)(v24 + 8628);
  v21 = 274 * a1;
  while ( 1 )
  {
    v16 = *v10++;
    if ( !v16 )
      break;
    if ( *v13 || v16 != 32 )
    {
      if ( v16 == 94 )
      {
        if ( !*v10 )
          break;
        if ( (*v10 & 7) != 0 )
        {
          if ( v12 > 29 )
            break;
          *v11 = 94;
          v15 = v11 + 1;
          *v15 = *v10++;
          v11 = v15 + 1;
          v12 += 2;
        }
        else
        {
          ++v10;
        }
      }
      else
      {
        if ( v16 != 32 )
        {
          v14 = 0;
          goto LABEL_36;
        }
        if ( ++v14 <= 3 )
        {
LABEL_36:
          if ( v12 > 30 )
            break;
          *v11++ = v16;
          ++v22;
          ++v12;
        }
      }
    }
  }
  *v11 = 0;
  if ( !*v13 || !v22 )
    Q_strncpyz(v13, "UnnamedPlayer", 31);
  Q_strncpyz((char *)(v24 + 8492), src, 32);
LABEL_50:
  v17 = Info_ValueForKey(dest, "handicap");
  v18 = _strtol_internal(v17, 0, 10, 0);
  *(_DWORD *)(v24 + 8524) = v18;
  if ( (unsigned int)(v18 - 1) > 0x63 )
    *(_DWORD *)(v24 + 8524) = 100;
  bgs[v21 + 159165] = a1;
  Q_strncpyz((char *)&bgs[v21 + 159166], src, 32);
  result = *(_DWORD *)(v24 + 8572);
  bgs[v21 + 159174] = result;
  return result;
}
// C13C0: using guessed type int bgs[];
// 21DF80: using guessed type int g_entities[];

//----- (0004246C) --------------------------------------------------------
const char *__cdecl ClientConnect(int a1, __int16 a2)
{
  int v2; // ebx
  int v3; // edi
  int *v4; // esi
  char *v5; // ebx
  const char *result; // eax
  int v7; // [esp+1Ch] [ebp-40Ch]
  int *s; // [esp+20h] [ebp-408h]
  char v9[1024]; // [esp+28h] [ebp-400h] BYREF

  s = &g_entities[197 * a1];
  v2 = level[0] + 8900 * a1;
  _bzero((void *)v2, 0x22C4u);
  v3 = 274 * a1;
  v4 = &bgs[274 * a1 + 159163];
  v7 = v4[272];
  _bzero(v4, 0x448u);
  v4[272] = v7;
  bgs[v3 + 159163] = 1;
  bgs[v3 + 159164] = 1;
  *(_DWORD *)(v2 + 8428) = 1;
  *(_WORD *)(v2 + 8424) = a2;
  *(_DWORD *)(v2 + 8572) = 3;
  *(_DWORD *)(v2 + 8400) = 2;
  *(_DWORD *)(v2 + 8660) = -1;
  *(_DWORD *)(v2 + 8404) = -1;
  G_InitGentity((int)s);
  s[131] = 0;
  s[133] = 0;
  s[86] = v2;
  *(_DWORD *)(v2 + 8568) = a1;
  *(_DWORD *)(v2 + 172) = a1;
  *(_DWORD *)(v2 + 128) = 16;
  g_entities[197 * a1 + 61] = 512;
  *(_DWORD *)(v2 + 8552) = -1;
  *(_DWORD *)(v2 + 8556) = -1;
  ClientUserinfoChanged(a1);
  trap_GetUserinfo(a1, (int)v9, 1024);
  if ( !strcmp(Info_ValueForKey(v9, "ip"), "localhost")
    || (v5 = Info_ValueForKey(v9, "password"), !g_password[16])
    || !Q_stricmp(&g_password[16], "none")
    || !strcmp(&g_password[16], v5) )
  {
    Scr_PlayerConnect(s);
    CalculateRanks();
    result = 0;
  }
  else
  {
    G_FreeEntity(s);
    result = "GAME_INVALIDPASSWORD";
  }
  return result;
}
// C13C0: using guessed type int bgs[];

//----- (0004268C) --------------------------------------------------------
int __cdecl ClientSpawn(int a1, float *a2, float *a3)
{
  int v3; // eax
  int v4; // ebx
  long double v5; // fst7
  _DWORD *s; // [esp+1Ch] [ebp-12Ch]
  int v8; // [esp+20h] [ebp-128h]
  int v9; // [esp+24h] [ebp-124h]
  int v10[6]; // [esp+2Ch] [ebp-11Ch] BYREF
  char v11[260]; // [esp+44h] [ebp-104h] BYREF

  v9 = (1024687629 * (a1 - (int)g_entities)) >> 2;
  v3 = *(_DWORD *)(a1 + 344);
  s = (_DWORD *)v3;
  if ( (*(_BYTE *)(v3 + 14) & 4) != 0 && (*(_BYTE *)(v3 + 129) & 0xC0) != 0 )
    G_ClientStopUsingTurret(level[1] + 788 * *(_DWORD *)(v3 + 888));
  G_EntUnlink(a1);
  if ( *(_DWORD *)(a1 + 240) )
    trap_UnlinkEntity(a1);
  *(_DWORD *)(a1 + 124) = 1023;
  Scr_SetString(a1 + 374, scr_const[49]);
  *(_DWORD *)(a1 + 400) = 42008593;
  *(_BYTE *)(a1 + 369) = 0;
  *(_BYTE *)(a1 + 244) |= 1u;
  G_SetClientContents(a1);
  *(_DWORD *)(a1 + 536) = player_die;
  *(_BYTE *)(a1 + 368) = 0;
  *(_BYTE *)(a1 + 367) = 0;
  *(_DWORD *)(a1 + 380) = 0x2000;
  *(float *)(a1 + 256) = playerMins[0];
  *(float *)(a1 + 260) = playerMins[1];
  *(float *)(a1 + 264) = playerMins[2];
  *(float *)(a1 + 268) = playerMaxs[0];
  *(float *)(a1 + 272) = playerMaxs[1];
  *(float *)(a1 + 276) = playerMaxs[2];
  v8 = s[32] & 0x20008;
  qmemcpy(v11, s + 2100, sizeof(v11));
  v4 = s[66];
  _bzero(s, 0x22C4u);
  qmemcpy(s + 2100, v11, 0x104u);
  s[2165] = -1;
  s[66] = v4 + 1;
  s[63] = s[2132];
  s[32] = v8 | 0x10;
  s[2142] = v9;
  s[43] = v9;
  trap_GetUsercmd((-1893646255 * ((int)s - level[0])) >> 2, (int)(s + 2108));
  *((_BYTE *)s + 128) ^= 8u;
  *((float *)s + 201) = *(float *)(a1 + 256);
  *((float *)s + 202) = *(float *)(a1 + 260);
  *((float *)s + 203) = *(float *)(a1 + 264);
  *((float *)s + 204) = *(float *)(a1 + 268);
  *((float *)s + 205) = *(float *)(a1 + 272);
  *((float *)s + 206) = *(float *)(a1 + 276);
  s[207] = LODWORD(bg_viewheight_prone[3]);
  s[208] = LODWORD(bg_viewheight_crouched[3]);
  s[209] = LODWORD(bg_viewheight_standing[3]);
  s[210] = 8;
  s[51] = LODWORD(bg_viewheight_standing[3]);
  v5 = (long double)SLODWORD(bg_viewheight_standing[3]);
  s[56] = 0;
  *((float *)s + 211) = 0.40000001;
  s[53] = 0;
  *((float *)s + 52) = v5;
  s[212] = 1065353216;
  *((float *)s + 213) = 0.15000001;
  *((float *)s + 214) = 0.64999998;
  *((float *)s + 215) = 0.80000001;
  *((float *)s + 216) = 0.69999999;
  *((float *)s + 217) = 0.40000001;
  s[223] = 1065353216;
  G_SetOrigin(a1, a2);
  *((float *)s + 5) = *a2;
  *((float *)s + 6) = a2[1];
  *((float *)s + 7) = a2[2];
  *((_BYTE *)s + 13) |= 8u;
  SetClientViewAngle(a1, a3);
  s[2189] = level[122] + 1000 * g_inactivity[3];
  s[2172] = 0;
  s[2175] = 0;
  _bzero(v10, 0x18u);
  v10[0] = level[122];
  v10[2] = -s[18];
  v10[3] = -s[19];
  v10[4] = -s[20];
  *s = v10[0] - 100;
  ClientEndFrame(a1);
  ClientThink_real(a1, v10);
  return BG_PlayerStateToEntityState((int)s, a1, 1);
}

//----- (00042AAC) --------------------------------------------------------
void __cdecl ClientDisconnect(int a1)
{
  int v1; // ebx
  int *v2; // edi
  int v3; // esi
  int i; // ebx
  int v5; // edx
  int v6; // [esp+20h] [ebp-8h]
  int *s; // [esp+24h] [ebp-4h]

  v6 = level[0] + 8900 * a1;
  s = &g_entities[197 * a1];
  Scr_AddString((int)"disconnect");
  Scr_AddString((int)"-1");
  Scr_Notify(s, scr_const[93], 2);
  v1 = 0;
  if ( level[120] > 0 )
  {
    v2 = g_entities;
    v3 = 0;
    do
    {
      if ( *(_DWORD *)(level[0] + v3 + 8428)
        && *(_DWORD *)(level[0] + v3 + 8400) == 2
        && *(_DWORD *)(level[0] + v3 + 8660) == a1
        && !Cmd_FollowCycle_f((int)v2, 1) )
      {
        StopFollowing((int)v2);
      }
      v2 += 197;
      v3 += 8900;
      ++v1;
    }
    while ( v1 < level[120] );
  }
  for ( i = 0; i < level[120]; ++i )
  {
    v5 = 8900 * i;
    if ( *(_DWORD *)(level[0] + 8900 * i + 8552) == a1 )
    {
      *(_DWORD *)(level[0] + v5 + 8552) = -1;
      *(_DWORD *)(level[0] + v5 + 8556) = 0;
      trap_SendServerCommand(i, 1, (int)"m -2");
      break;
    }
  }
  HudElem_ClientDisconnect(s);
  Scr_PlayerDisconnect(s);
  G_FreeEntity(s);
  *(_DWORD *)(v6 + 8428) = 0;
  _bzero((void *)(v6 + 8568), 0x5Cu);
  CalculateRanks();
}

//----- (00042C30) --------------------------------------------------------
int __cdecl G_GetNonPVSFriendlyInfo(int a1, float *a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  long double v9; // fst7
  long double v10; // fst6
  long double v11; // fst7
  long double v12; // fst6
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  char v17; // fps^1
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  int v21; // eax
  unsigned int v22; // edx
  int v23; // eax
  int v25; // [esp+20h] [ebp-28h]
  float *v26; // [esp+24h] [ebp-24h]
  float v27; // [esp+28h] [ebp-20h]
  float v28; // [esp+2Ch] [ebp-1Ch]
  float v29; // [esp+30h] [ebp-18h]
  float v30; // [esp+34h] [ebp-14h]
  int v31; // [esp+38h] [ebp-10h]
  int v32; // [esp+3Ch] [ebp-Ch]

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572);
  v25 = v3;
  if ( !v3 || v3 == 3 )
    return 0;
  v32 = a3 + 1;
  if ( a3 == 1023 )
    v32 = 0;
  v31 = 0;
  while ( 1 )
  {
    v4 = v31 + v32 + (v31 + v32 < 0 ? 0x3F : 0);
    LOBYTE(v4) = v4 & 0xC0;
    v5 = 197 * (v31 + v32 - v4);
    v26 = (float *)&g_entities[v5];
    if ( LOBYTE(g_entities[v5 + 88]) )
    {
      if ( g_entities[v5 + 1] == 1 && (g_entities[v5 + 2] & 1) == 0 )
      {
        v6 = g_entities[v5 + 86];
        if ( v6 )
        {
          if ( *(_DWORD *)(v6 + 8572) == v25 && !trap_InSnapshot((int)a2, g_entities[v5]) )
            break;
        }
      }
    }
    if ( ++v31 > 63 )
      return 0;
  }
  v29 = v26[77] - *a2;
  v27 = 1.0;
  v30 = v26[78] - a2[1];
  v28 = 1.0;
  v7 = (int)(v29 + 0.5);
  v8 = (int)(v30 + 0.5);
  if ( v7 <= 1024 )
  {
    if ( v7 >= -1022 )
      goto LABEL_17;
    v9 = (long double)v7;
    v10 = -1022.0;
  }
  else
  {
    v9 = (long double)v7;
    v10 = 1024.0;
  }
  v27 = v10 / v9;
LABEL_17:
  if ( v8 <= 1024 )
  {
    if ( v8 >= -1022 )
      goto LABEL_22;
    v11 = (long double)v8;
    v12 = -1022.0;
  }
  else
  {
    v11 = (long double)v8;
    v12 = 1024.0;
  }
  v28 = v12 / v11;
LABEL_22:
  if ( v27 < 1.0 || v28 < 1.0 )
  {
    v14 = v27 < (long double)v28;
    v15 = 0;
    v16 = v27 == v28;
    if ( (v13 & 0x45) == 1 )
    {
      v8 = (int)((long double)v8 * v27);
    }
    else
    {
      v18 = v28 < (long double)v27;
      v19 = 0;
      v20 = v28 == v27;
      if ( (v17 & 0x45) == 1 )
        v7 = (int)((long double)v7 * v28);
    }
  }
  if ( v7 <= 1024 )
  {
    if ( v7 < -1022 )
      v7 = -1022;
  }
  else
  {
    v7 = 1024;
  }
  if ( v8 <= 1024 )
  {
    if ( v8 < -1022 )
      v8 = -1022;
  }
  else
  {
    v8 = 1024;
  }
  v21 = v7 + 2;
  if ( v7 + 2 < 0 )
    v21 = v7 + 5;
  v22 = (g_entities[v5] & 0xFFFF803F | ((((unsigned __int16)(v21 >> 2) + 255) & 0x1FF) << 6)) & 0xFF007FFF;
  v23 = v8 + 2;
  if ( v8 + 2 < 0 )
    v23 = v8 + 5;
  return ((int)(v26[81] * 0.71111113) << 24) | (((((unsigned __int16)(v23 >> 2) + 255) & 0x1FF) << 15) | v22) & 0xFFFFFF;
}
// 42E01: variable 'v13' is possibly undefined
// 42E38: variable 'v17' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (00042F3C) --------------------------------------------------------
unsigned __int16 __cdecl G_AddLean(int a1, int a2)
{
  return AddLeanToPosition(
           a2,
           *(float *)(*(_DWORD *)(a1 + 344) + 196),
           *(float *)(*(_DWORD *)(a1 + 344) + 64),
           16.0,
           20.0);
}

//----- (00042F88) --------------------------------------------------------
int __cdecl ClientBegin(int a1)
{
  *(_DWORD *)(level[0] + 8900 * a1 + 8428) = 2;
  CalculateRanks();
  return Scr_Notify(&g_entities[197 * a1], scr_const[81], 0);
}

//----- (00042FD4) --------------------------------------------------------
void G_SetPlayerSize()
{
  long double v0; // fst6
  long double v1; // fst7

  v0 = g_bounds_width[2] * 0.5;
  v1 = g_bounds_width[2] * -0.5;
  playerMaxs[1] = v0;
  playerMaxs[0] = v0;
  playerMaxs[2] = g_bounds_height_standing[2];
  playerMins[1] = v1;
  playerMins[0] = v1;
}

//----- (00043020) --------------------------------------------------------
int __cdecl PlayerCmd_giveWeapon(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  int v6; // edi
  int v7; // ecx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  v6 = Com_BitCheck(v1[86] + 780, v5);
  if ( !BG_GetEmptySlotForWeapon(v1[86], v5) )
    Scr_ParamError(0, (int)"Can not give player weapon without having an empty weapon slot\n");
  BG_GivePlayerWeapon(v1[86], v5);
  v7 = BG_GetInfoForWeapon(v5);
  result = *(_DWORD *)(4 * *(_DWORD *)(v7 + 416) + v1[86] + 268);
  if ( *(_DWORD *)(v7 + 408) - result > 0 )
    result = Add_Ammo((int)v1, v5, *(_DWORD *)(v7 + 408) - result, v6 == 0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00043134) --------------------------------------------------------
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1)
{
  int *v1; // edi
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  int result; // eax
  int v7; // ebx
  int v8; // ecx
  int v9; // ecx

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  result = Com_BitCheck(v1[86] + 780, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    v8 = BG_GetAmmoTypeMax(*(_DWORD *)(v7 + 416));
    result = v1[86] + 268;
    v9 = v8 - *(_DWORD *)(4 * *(_DWORD *)(v7 + 416) + result);
    if ( v9 > 0 )
      result = Add_Ammo((int)v1, v5, v9, 0);
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00043218) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  float v10; // [esp-10h] [ebp-28h]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  if ( !Com_BitCheck(v1[86] + 780, v5) )
    return Scr_AddFloat(1.0);
  v6 = BG_GetInfoForWeapon(v5);
  v7 = v6;
  if ( *(int *)(v6 + 408) <= 0 )
    return Scr_AddFloat(1.0);
  v8 = *(_DWORD *)(4 * *(_DWORD *)(v6 + 416) + v1[86] + 268);
  if ( v8 <= 0 )
    return Scr_AddFloat(0.0);
  v10 = (long double)v8 / (long double)*(int *)(v7 + 408);
  return Scr_AddFloat(v10);
}
// 21DF80: using guessed type int g_entities[];

//----- (00043338) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // ebx
  int v6; // ebx
  float v8; // [esp-20h] [ebp-38h]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  if ( !Com_BitCheck(v1[86] + 780, v5) )
    return Scr_AddFloat(1.0);
  v6 = BG_GetInfoForWeapon(v5);
  if ( BG_GetAmmoTypeMax(*(_DWORD *)(v6 + 416)) <= 0 )
    return Scr_AddFloat(1.0);
  if ( *(int *)(v1[86] + 268 + 4 * *(_DWORD *)(v6 + 416)) <= 0 )
    return Scr_AddFloat(0.0);
  v8 = (long double)*(int *)(4 * *(_DWORD *)(v6 + 416) + v1[86] + 268)
     / (long double)BG_GetAmmoTypeMax(*(_DWORD *)(v6 + 416));
  return Scr_AddFloat(v8);
}
// 21DF80: using guessed type int g_entities[];

//----- (00043480) --------------------------------------------------------
int __cdecl sub_43480(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  float *v4; // eax
  float v6[3]; // [esp+Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  Scr_GetVector(0, (int)v6);
  trap_UnlinkEntity((int)v1);
  *(float *)(v1[86] + 20) = v6[0];
  *(float *)(v1[86] + 24) = v6[1];
  *(float *)(v1[86] + 28) = v6[2];
  *(float *)(v1[86] + 28) = *(float *)(v1[86] + 28) + 1.0;
  *(_BYTE *)(v1[86] + 128) ^= 8u;
  BG_PlayerStateToEntityState(v1[86], (int)v1, 1);
  v4 = (float *)v1[86];
  v1[77] = *((int *)v4 + 5);
  v1[78] = *((int *)v4 + 6);
  v1[79] = *((int *)v4 + 7);
  return trap_LinkEntity((int)v1);
}
// 21DF80: using guessed type int g_entities[];

//----- (00043578) --------------------------------------------------------
int *__cdecl sub_43578(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int *result; // eax
  int *v5; // esi
  char *v6; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  result = Scr_GetEntity(0);
  v5 = result;
  if ( v1 != result )
  {
    if ( *(_DWORD *)(result[86] + 8480) )
    {
      result = (int *)trap_SendServerCommand((1024687629 * ((char *)v1 - (char *)g_entities)) >> 2, 1, (int)"m -4");
    }
    else
    {
      v6 = va("m %i", *result);
      trap_SendServerCommand((1024687629 * ((char *)v1 - (char *)g_entities)) >> 2, 1, (int)v6);
      *(_DWORD *)(v1[86] + 8552) = v5[36];
      result = (int *)v1[86];
      result[2139] = level[122] + 20500;
    }
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00043684) --------------------------------------------------------
int __cdecl sub_43684(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  unsigned __int8 v5; // al
  int v6; // edi
  const char *v7; // eax
  int *v8; // eax
  int *v9; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = BG_GetWeaponIndexForName(v4);
  v6 = v5;
  if ( v5 )
  {
    if ( (unsigned int)Scr_GetNumParam() <= 1 )
      v7 = "tag_weapon_right";
    else
      v7 = (const char *)Scr_GetString(1);
    v8 = (int *)Drop_Weapon((int)v1, v6, (int)v7);
  }
  else
  {
    v9 = BG_FindItem(v4);
    if ( v9 )
      v8 = (int *)Drop_Item((int)v1, (int)v9, 0.0, 0);
    else
      v8 = 0;
  }
  return GScr_AddEntity(v8);
}
// 21DF80: using guessed type int g_entities[];

//----- (0004376C) --------------------------------------------------------
void __cdecl sub_4376C(unsigned int a1)
{
  int *v1; // edi
  char *v2; // eax
  char *v3; // eax
  char v4; // si
  char *v5; // eax
  char *v6; // eax
  __int16 v7; // ax
  long double v8; // fst7
  int v9; // eax
  int v10; // edx
  long double v11; // fst7
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // edx
  _DWORD *v16; // esi
  int v17; // eax
  int v18; // edx
  _DWORD *v19; // esi
  int v20; // eax
  void (__stdcall *v21)(int *, int *, int, float *, int, float *, int, int); // edx
  int v22; // [esp-4h] [ebp-7Ch]
  int v23; // [esp+20h] [ebp-58h]
  int v24; // [esp+24h] [ebp-54h]
  int v25; // [esp+28h] [ebp-50h]
  int v26; // [esp+2Ch] [ebp-4Ch]
  float *v27; // [esp+30h] [ebp-48h]
  float *v28; // [esp+34h] [ebp-44h]
  int *v29; // [esp+38h] [ebp-40h]
  int *v30; // [esp+3Ch] [ebp-3Ch]
  float v31; // [esp+4Ch] [ebp-2Ch]
  float v32; // [esp+50h] [ebp-28h]
  float v33; // [esp+54h] [ebp-24h] BYREF
  float v34; // [esp+58h] [ebp-20h]
  float v35; // [esp+5Ch] [ebp-1Ch]
  float v36[3]; // [esp+60h] [ebp-18h] BYREF
  char v37[12]; // [esp+6Ch] [ebp-Ch] BYREF

  v29 = &g_entities[201334];
  v30 = &g_entities[201334];
  v28 = 0;
  v27 = 0;
  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v26 = Scr_GetInt(2);
  if ( v26 > 0 )
  {
    if ( Scr_GetType(0) && Scr_GetPointerType(0) == 13 )
      v30 = Scr_GetEntity(1);
    if ( Scr_GetType(1) && Scr_GetPointerType(1) == 13 )
      v29 = Scr_GetEntity(1);
    v4 = Scr_GetInt(3);
    v5 = (char *)Scr_GetString(4);
    v25 = G_IndexForMeansOfDeath(v5);
    v6 = (char *)Scr_GetString(5);
    v24 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
    if ( Scr_GetType(6) )
    {
      Scr_GetVector(6, (int)v36);
      v27 = v36;
    }
    if ( Scr_GetType(7) )
    {
      Scr_GetVector(7, (int)v37);
      v28 = (float *)v37;
    }
    v7 = Scr_GetConstString(8);
    v23 = G_GetHitLocationIndexFromString(v7);
    if ( v28 )
    {
      VectorNormalize2(v28, &v33);
    }
    else
    {
      v35 = 0.0;
      v34 = 0.0;
      v33 = 0.0;
    }
    if ( (v1[95] & 8) == 0 && (v4 & 4) == 0 )
    {
      v8 = 0.30000001;
      v9 = *(_DWORD *)(v1[86] + 12);
      if ( (v9 & 1) != 0 )
      {
        v8 = 0.02;
      }
      else if ( (v9 & 2) != 0 )
      {
        v8 = 0.15000001;
      }
      v10 = (int)(v8 * (long double)v26);
      if ( v10 > 60 )
        v10 = 60;
      if ( v10 )
      {
        v11 = (long double)v10 * g_knockback[2] / 250.0;
        v31 = v34 * v11;
        v32 = v11 * v35;
        *(float *)(v1[86] + 32) = v33 * v11 + *(float *)(v1[86] + 32);
        *(float *)(v1[86] + 36) = *(float *)(v1[86] + 36) + v31;
        *(float *)(v1[86] + 40) = *(float *)(v1[86] + 40) + v32;
        v12 = v1[86];
        if ( !*(_DWORD *)(v12 + 16) )
        {
          v13 = 2 * v10;
          if ( 2 * v10 <= 49 )
            v13 = 50;
          if ( v13 > 200 )
            v13 = 200;
          *(_DWORD *)(v12 + 16) = v13;
          *(_BYTE *)(v1[86] + 13) |= 2u;
        }
      }
    }
    if ( (v1[95] & 1) == 0 )
    {
      if ( v24 && !*(_DWORD *)(BG_GetInfoForWeapon(v24) + 112) )
      {
        v14 = BG_GetInfoForWeapon(v24);
        v15 = 173;
        if ( *(_DWORD *)(v14 + 704) )
          v15 = 174;
        v16 = G_TempEntity(v36, v15);
        v16[40] = (unsigned __int8)DirToByte(&v33);
        v16[54] = (unsigned __int8)DirToByte(&v33);
        v16[34] = 7;
        v16[29] = *v29;
        *((_BYTE *)v16 + 245) |= 0x20u;
        v16[62] = *(_DWORD *)(v1[86] + 172);
        v17 = BG_GetInfoForWeapon(v24);
        v18 = 175;
        if ( *(_DWORD *)(v17 + 704) )
          v18 = 176;
        v19 = G_TempEntity(v36, v18);
        v19[34] = 7;
        v19[29] = *v29;
        v19[36] = *(_DWORD *)(v1[86] + 172);
        v19[61] = 2048;
        v19[62] = *(_DWORD *)(v1[86] + 172);
      }
      *(_DWORD *)(v1[86] + 8724) += v26;
      if ( v28 )
      {
        *(float *)(v1[86] + 8728) = v33;
        *(float *)(v1[86] + 8732) = v34;
        *(float *)(v1[86] + 8736) = v35;
        *(_DWORD *)(v1[86] + 8740) = 0;
      }
      else
      {
        *(float *)(v1[86] + 8728) = *((float *)v1 + 77);
        *(float *)(v1[86] + 8732) = *((float *)v1 + 78);
        *(float *)(v1[86] + 8736) = *((float *)v1 + 79);
        *(_DWORD *)(v1[86] + 8740) = 1;
      }
      v1[140] -= v26;
      Scr_AddEntity(v29);
      Scr_AddInt(v26);
      Scr_Notify(v1, scr_const[13], 2);
      v20 = v1[140];
      if ( v20 > 0 )
      {
        v21 = (void (__stdcall *)(int *, int *, int, float *, int, float *, int, int))v1[133];
        if ( v21 )
          v21(v1, v29, v26, v27, v25, &v33, v23, v22);
        goto LABEL_54;
      }
      if ( v20 < -999 )
        v1[140] = -999;
      v1[150] = (int)v29;
      if ( v1[134] )
        ((void (__stdcall *)(int *, int *, int *, int, int, int, float *, int))v1[134])(
          v1,
          v30,
          v29,
          v26,
          v25,
          v24,
          &v33,
          v23);
      if ( *((_BYTE *)v1 + 352) )
      {
LABEL_54:
        *(_DWORD *)(v1[86] + 244) = v1[140];
        return;
      }
    }
  }
}
// 43CD6: variable 'v22' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (00043CF4) --------------------------------------------------------
int __cdecl sub_43CF4(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  unsigned __int16 v4; // bx
  char *v5; // eax
  int v6; // edi
  const char *v7; // eax
  char *v8; // eax
  int v10; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 8400) )
    return Scr_AddConstString(scr_const[124]);
  v4 = Scr_GetConstString(0);
  v5 = (char *)SL_ConvertToString(v4);
  v6 = BG_GetWeaponSlotForName(v5);
  if ( !v6 )
  {
    v7 = (const char *)SL_ConvertToString(v4);
    v8 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v7);
    Scr_ParamError(0, (int)v8);
  }
  if ( !*(_BYTE *)(v6 + v1[86] + 788) )
    return Scr_AddConstString(scr_const[124]);
  v10 = BG_GetInfoForWeapon(*(char *)(v6 + v1[86] + 788));
  return Scr_AddString(*(_DWORD *)(v10 + 4));
}
// 21DF80: using guessed type int g_entities[];

//----- (00043DF4) --------------------------------------------------------
int __cdecl sub_43DF4(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // bx
  char *v4; // eax
  int v5; // edi
  const char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  unsigned __int8 v9; // al
  char *v10; // eax
  int v11; // esi
  int v12; // eax
  char *v13; // eax
  char *v14; // eax
  int result; // eax
  int v16; // eax
  char *v17; // [esp-1Ch] [ebp-44h]
  int *v18; // [esp+1Ch] [ebp-Ch]
  int v19; // [esp+20h] [ebp-8h]
  int v20; // [esp+24h] [ebp-4h]

  v19 = 0;
  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v2);
    v18 = 0;
  }
  else
  {
    v18 = &g_entities[197 * a1];
    if ( !v18[86] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error((int)v1);
    }
  }
  v3 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v3);
  v5 = BG_GetWeaponSlotForName(v4);
  if ( !v5 )
  {
    v6 = (const char *)SL_ConvertToString(v3);
    v7 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v6);
    Scr_ParamError(0, (int)v7);
  }
  v8 = (char *)Scr_GetString(1);
  if ( Q_stricmp(v8, "none") )
  {
    v9 = BG_GetWeaponIndexForName(v8);
    v20 = v9;
    if ( !v9 )
    {
      v10 = va("Unknown weapon %s.", v8);
      Scr_ParamError(1, (int)v10);
    }
    v11 = BG_GetInfoForWeapon(v20);
    v12 = *(_DWORD *)(v11 + 120);
    if ( v12 != v5 && ((unsigned int)(v12 - 1) > 1 || (unsigned int)(v5 - 1) > 1) )
    {
      v17 = BG_GetWeaponSlotNameForIndex(v5);
      v13 = BG_GetWeaponSlotNameForIndex(*(_DWORD *)(v11 + 120));
      v14 = va("Weapon %s goes in the %s weaponslot, not the %s weaponslot.", v8, v13, v17);
      Scr_ParamError(1, (int)v14);
    }
  }
  else
  {
    v20 = 0;
  }
  result = v18[86];
  if ( *(_BYTE *)(v5 + result + 788) )
    result = BG_TakePlayerWeapon(result, *(char *)(v5 + result + 788));
  if ( v20 )
  {
    v16 = v18[86];
    if ( v5 == 2 && !*(_BYTE *)(v16 + 789) )
      v19 = 1;
    result = BG_GivePlayerWeapon(v16, v20);
    if ( v19 )
    {
      *(_BYTE *)(v18[86] + 790) = *(_BYTE *)(v18[86] + 789);
      result = v18[86];
      *(_BYTE *)(result + 789) = 0;
    }
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00043FF4) --------------------------------------------------------
int __cdecl sub_43FF4(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  unsigned __int16 v4; // bx
  char *v5; // eax
  int v6; // edi
  const char *v7; // eax
  char *v8; // eax
  int v9; // eax
  int v10; // ebx
  int result; // eax
  int v12; // eax
  int v13; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 8400) )
    return Scr_AddInt(0);
  v4 = Scr_GetConstString(0);
  v5 = (char *)SL_ConvertToString(v4);
  v6 = BG_GetWeaponSlotForName(v5);
  if ( !v6 )
  {
    v7 = (const char *)SL_ConvertToString(v4);
    v8 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v7);
    Scr_ParamError(0, (int)v8);
  }
  v9 = v1[86] + 788;
  v10 = *(char *)(v6 + v9);
  if ( !*(_BYTE *)(v6 + v9) )
    return Scr_AddInt(0);
  if ( BG_WeaponIsClipOnly(*(char *)(v6 + v9)) )
  {
    v12 = BG_ClipForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v1[86] + 524 + 4 * v12));
  }
  else
  {
    v13 = BG_AmmoForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v1[86] + 268 + 4 * v13));
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044130) --------------------------------------------------------
int __cdecl sub_44130(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned __int16 v3; // bx
  char *v4; // eax
  int v5; // edi
  const char *v6; // eax
  char *v7; // eax
  int v8; // esi
  int result; // eax
  int v10; // ebx
  int v11; // ebx
  int *v12; // [esp+14h] [ebp-4h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v2);
    v12 = 0;
  }
  else
  {
    v12 = &g_entities[197 * a1];
    if ( !v12[86] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error((int)v1);
    }
  }
  v3 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v3);
  v5 = BG_GetWeaponSlotForName(v4);
  if ( !v5 )
  {
    v6 = (const char *)SL_ConvertToString(v3);
    v7 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v6);
    Scr_ParamError(0, (int)v7);
  }
  v8 = Scr_GetInt(1);
  result = v12[86] + 788;
  v10 = *(char *)(v5 + result);
  if ( *(_BYTE *)(v5 + result) )
  {
    if ( BG_WeaponIsClipOnly(*(char *)(v5 + result)) )
    {
      result = BG_ClipForWeapon(v10);
      v11 = result;
      if ( !result )
        return result;
      if ( v8 >= 0 )
      {
        if ( v8 > BG_GetAmmoClipSize(result) )
          v8 = BG_GetAmmoClipSize(v11);
      }
      else
      {
        v8 = 0;
      }
      result = v12[86] + 524;
    }
    else
    {
      result = BG_AmmoForWeapon(v10);
      v11 = result;
      if ( !result )
        return result;
      if ( v8 >= 0 )
      {
        if ( v8 > BG_GetAmmoTypeMax(result) )
          v8 = BG_GetAmmoTypeMax(v11);
      }
      else
      {
        v8 = 0;
      }
      result = v12[86] + 268;
    }
    *(_DWORD *)(result + 4 * v11) = v8;
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (000442C8) --------------------------------------------------------
int __cdecl sub_442C8(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  unsigned __int16 v4; // bx
  char *v5; // eax
  int v6; // edi
  const char *v7; // eax
  char *v8; // eax
  int v9; // edx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 8400) )
    goto LABEL_10;
  v4 = Scr_GetConstString(0);
  v5 = (char *)SL_ConvertToString(v4);
  v6 = BG_GetWeaponSlotForName(v5);
  if ( !v6 )
  {
    v7 = (const char *)SL_ConvertToString(v4);
    v8 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v7);
    Scr_ParamError(0, (int)v8);
  }
  if ( *(_BYTE *)(v6 + v1[86] + 788) && (v9 = BG_ClipForWeapon(*(char *)(v6 + v1[86] + 788))) != 0 )
    result = Scr_AddInt(*(_DWORD *)(v1[86] + 524 + 4 * v9));
  else
LABEL_10:
    result = Scr_AddInt(0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (000443E4) --------------------------------------------------------
int __cdecl sub_443E4(unsigned int a1)
{
  int *v1; // edi
  char *v2; // eax
  char *v3; // eax
  unsigned __int16 v4; // bx
  char *v5; // eax
  const char *v6; // eax
  char *v7; // eax
  int v8; // esi
  int result; // eax
  int v10; // ebx
  int v11; // [esp+14h] [ebp-4h]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = Scr_GetConstString(0);
  v5 = (char *)SL_ConvertToString(v4);
  v11 = BG_GetWeaponSlotForName(v5);
  if ( !v11 )
  {
    v6 = (const char *)SL_ConvertToString(v4);
    v7 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v6);
    Scr_ParamError(0, (int)v7);
  }
  v8 = Scr_GetInt(1);
  if ( !*(_BYTE *)(v11 + v1[86] + 788) )
    return Scr_AddInt(0);
  result = BG_ClipForWeapon(*(char *)(v11 + v1[86] + 788));
  v10 = result;
  if ( result )
  {
    if ( v8 < 0 )
      v8 = 0;
    if ( v8 > BG_GetAmmoClipSize(result) )
      v8 = BG_GetAmmoClipSize(v10);
    result = v1[86] + 524;
    *(_DWORD *)(result + 4 * v10) = v8;
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (0004450C) --------------------------------------------------------
int __cdecl sub_4450C(unsigned int a1)
{
  int *v1; // edi
  char *v2; // eax
  char *v3; // eax
  int *v4; // ebx
  int *v5; // esi
  int v6; // edx
  int v7; // eax
  int v8; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (int *)v1[86];
  v5 = G_SpawnPlayerClone();
  v6 = v5[2] & 8;
  v5[36] = v4[43];
  v7 = v4[32];
  LOBYTE(v7) = v7 & 0xF7;
  v8 = v6 | v7;
  BYTE1(v8) |= 8u;
  v5[2] = v8;
  G_SetOrigin((int)v5, (float *)v1 + 77);
  G_SetAngle((int)v5, (float *)v1 + 80);
  v5[3] = 5;
  v5[4] = level[122];
  v5[9] = v4[8];
  v5[10] = v4[9];
  v5[11] = v4[10];
  v5[1] = 2;
  *((_BYTE *)v5 + 353) = 1;
  v5[31] = 1023;
  v5[61] = 512;
  v5[64] = v1[64];
  v5[65] = v1[65];
  v5[66] = v1[66];
  v5[67] = v1[67];
  v5[68] = v1[68];
  v5[69] = v1[69];
  v5[71] = v1[71];
  v5[72] = v1[72];
  v5[73] = v1[73];
  v5[74] = v1[74];
  v5[75] = v1[75];
  v5[76] = v1[76];
  v5[51] = v4[28];
  v5[52] = v4[30];
  v5[100] = 65537;
  trap_LinkEntity((int)v5);
  v5[127] = level[122] + 250;
  v5[128] = (int)sub_456DC;
  return GScr_AddEntity(v5);
}
// 21DF80: using guessed type int g_entities[];

//----- (000446E0) --------------------------------------------------------
int __cdecl sub_446E0(unsigned int a1)
{
  char *v1; // eax
  char *v2; // edi
  char *v3; // ebx
  int v4; // esi
  char v5; // al
  char *v6; // eax
  const char *v8; // [esp+14h] [ebp-804h]
  char s[1024]; // [esp+18h] [ebp-800h] BYREF
  char v10[1024]; // [esp+418h] [ebp-400h] BYREF

  if ( a1 > 0x3FF )
  {
    v1 = va("%i is not a valid entity number", a1);
  }
  else
  {
    if ( g_entities[197 * a1 + 86] )
      goto LABEL_6;
    v1 = va("entity %i is not a player", a1);
  }
  Scr_Error((int)v1);
LABEL_6:
  v8 = (const char *)Scr_GetString(0);
  if ( Scr_GetType(1) == 2 )
  {
    Scr_ConstructMessageString(1, v10, 1024, 4);
    v2 = v10;
  }
  else
  {
    v2 = (char *)Scr_GetString(1);
  }
  v3 = s;
  _bzero(s, 0x400u);
  v4 = 0;
  if ( *v2 )
  {
    do
    {
      v5 = Q_CleanCharacter(v2[v4]);
      *v3 = v5;
      if ( v5 == 34 )
        *v3 = 39;
      ++v4;
      ++v3;
    }
    while ( v4 <= 0x1FFF && v2[v4] );
  }
  v6 = va("v %s \"%s\"", v8, s);
  return trap_SendServerCommand(a1, 1, (int)v6);
}
// 21DF80: using guessed type int g_entities[];

//----- (00044800) --------------------------------------------------------
int __cdecl sub_44800(unsigned int a1)
{
  char *v1; // eax
  unsigned int v2; // eax
  const char *v3; // eax
  char *v4; // eax
  float v6; // [esp+10h] [ebp-18h]
  float v7; // [esp+14h] [ebp-14h]

  if ( a1 > 0x3FF )
  {
    v1 = va("%i is not a valid entity number", a1);
  }
  else
  {
    if ( g_entities[197 * a1 + 86] )
      goto LABEL_6;
    v1 = va("entity %i is not a player", a1);
  }
  Scr_Error((int)v1);
LABEL_6:
  v6 = 0.0;
  v7 = 0.5;
  v2 = Scr_GetNumParam();
  if ( v2 == 2 )
  {
LABEL_12:
    v7 = Scr_GetFloat(1);
    goto LABEL_13;
  }
  if ( v2 <= 2 )
  {
    if ( v2 != 1 )
      return Scr_Error((int)"USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
                            "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
LABEL_13:
    v3 = (const char *)Scr_GetString(0);
    v4 = va("r \"%s\" %g %g", v3, v7, v6);
    return trap_SendServerCommand(a1, 1, (int)v4);
  }
  if ( v2 == 3 )
  {
    v6 = Scr_GetFloat(2);
    goto LABEL_12;
  }
  return Scr_Error((int)"USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
                        "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 21DF80: using guessed type int g_entities[];

//----- (000448E4) --------------------------------------------------------
int __cdecl Player_GetMethod(char **a1)
{
  unsigned int v1; // edi
  int v2; // esi
  const char *v3; // ebx
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  s1 = *a1;
  do
  {
    v3 = (&off_733DC)[v2];
    if ( !strcmp(s1, v3) )
    {
      *a1 = (char *)v3;
      return *(int *)((char *)&off_733E0 + v2 * 4);
    }
    v2 += 2;
    ++v1;
  }
  while ( v1 <= 0x2D );
  return 0;
}
// 733DC: using guessed type char *off_733DC;
// 733E0: using guessed type int (__cdecl *off_733E0)(int);

//----- (0004493C) --------------------------------------------------------
int __cdecl PlayerCmd_takeWeapon(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // ebx

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  *(_DWORD *)(v1[86] + 268 + 4 * BG_AmmoForWeapon(v5)) = 0;
  *(_DWORD *)(v1[86] + 524 + 4 * BG_ClipForWeapon(v5)) = 0;
  return BG_TakePlayerWeapon(v1[86], v5);
}
// 21DF80: using guessed type int g_entities[];

//----- (00044A0C) --------------------------------------------------------
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  int i; // ebx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  *(_DWORD *)(v1[86] + 176) = 0;
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    *(_DWORD *)(v1[86] + 268 + 4 * BG_AmmoForWeapon(i)) = 0;
    *(_DWORD *)(v1[86] + 524 + 4 * BG_ClipForWeapon(i)) = 0;
    BG_TakePlayerWeapon(v1[86], i);
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044AE8) --------------------------------------------------------
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(int *)(v1[86] + 176) <= 0 )
    return Scr_AddString((int)"none");
  v4 = BG_GetInfoForWeapon(*(_DWORD *)(v1[86] + 176));
  return Scr_AddString(*(_DWORD *)(v4 + 4));
}
// 21DF80: using guessed type int g_entities[];

//----- (00044B84) --------------------------------------------------------
int __cdecl PlayerCmd_hasWeapon(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  unsigned __int8 v5; // al
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = BG_GetWeaponIndexForName(v4);
  if ( Com_BitCheck(v1[86] + 780, v5) )
    result = Scr_AddBool(1);
  else
    result = Scr_AddBool(0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044C34) --------------------------------------------------------
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  char *v6; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  if ( !Com_BitCheck(v1[86] + 780, v5) )
    return Scr_AddBool(0);
  v6 = va("a %i", v5);
  trap_SendServerCommand((1024687629 * ((char *)v1 - (char *)g_entities)) >> 2, 1, (int)v6);
  return Scr_AddBool(1);
}
// 21DF80: using guessed type int g_entities[];

//----- (00044D14) --------------------------------------------------------
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // ebx
  int result; // eax
  int v7; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  result = Com_BitCheck(v1[86] + 780, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    result = *(_DWORD *)(v7 + 408) - *(_DWORD *)(4 * *(_DWORD *)(v7 + 416) + v1[86] + 268);
    if ( result > 0 )
      result = Add_Ammo((int)v1, v5, result, 0);
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044DF0) --------------------------------------------------------
int __cdecl sub_44DF0(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  float v5[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  Scr_GetVector(0, (int)v5);
  return SetClientViewAngle((int)v1, v5);
}
// 21DF80: using guessed type int g_entities[];

//----- (00044E70) --------------------------------------------------------
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( (*(_BYTE *)(v1[86] + 8680) & 0x40) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044EF8) --------------------------------------------------------
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( (*(_BYTE *)(v1[86] + 8680) & 1) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00044F84) --------------------------------------------------------
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( (*(_BYTE *)(v1[86] + 8680) & 0x20) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00045014) --------------------------------------------------------
int __cdecl PlayerCmd_isOnGround(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 84) == 1023 )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (000450A4) --------------------------------------------------------
int __cdecl PlayerCmd_pingPlayer(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  *(_BYTE *)(v1[86] + 130) |= 8u;
  result = v1[86];
  *(_DWORD *)(result + 8808) = level[122] + 3000;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (0004512C) --------------------------------------------------------
int __cdecl sub_4512C(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // edx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = G_ModelIndex(v4);
  result = v1[86];
  *(_DWORD *)(result + 8560) = v5;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (000451B4) --------------------------------------------------------
int __cdecl sub_451B4(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = G_ModelName(*(_DWORD *)(v1[86] + 8560));
  return Scr_AddString(v4);
}
// 21DF80: using guessed type int g_entities[];

//----- (00045238) --------------------------------------------------------
int __cdecl sub_45238(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  return Cmd_Score_f((int)v1);
}
// 21DF80: using guessed type int g_entities[];

//----- (000452A4) --------------------------------------------------------
int __cdecl sub_452A4(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // esi
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = (char *)Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v4);
  result = Com_BitCheck(v1[86] + 780, v5);
  if ( result )
  {
    *(_DWORD *)(v1[86] + 176) = v5;
    result = v1[86];
    *(_DWORD *)(result + 180) = 0;
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00045358) --------------------------------------------------------
int __cdecl sub_45358(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = v1[86];
  *((_BYTE *)v1 + 380) &= 0xFEu;
  v1[140] = 0;
  *(_DWORD *)(v4 + 244) = 0;
  return player_die((int)v1, (int)v1, (int)v1, 100000, 0x16u, 0, 0, 0);
}
// 21DF80: using guessed type int g_entities[];

//----- (000453F4) --------------------------------------------------------
int __cdecl sub_453F4(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 8428) != 2 )
    return Scr_AddInt(0);
  v4 = (char *)Scr_GetString(0);
  v5 = GScr_GetScriptMenuIndex(v4);
  v6 = va("t %i", v5);
  trap_SendServerCommand(a1, 1, (int)v6);
  return Scr_AddInt(1);
}
// 21DF80: using guessed type int g_entities[];

//----- (000454B4) --------------------------------------------------------
int __cdecl sub_454B4(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  int v5; // eax
  char *v6; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  if ( *(_DWORD *)(v1[86] + 8428) != 2 )
    return Scr_AddInt(0);
  v4 = (char *)Scr_GetString(0);
  v5 = GScr_GetScriptMenuIndex(v4);
  v6 = va("t %i 1", v5);
  trap_SendServerCommand(a1, 1, (int)v6);
  return Scr_AddInt(1);
}
// 21DF80: using guessed type int g_entities[];

//----- (00045574) --------------------------------------------------------
int __cdecl sub_45574(int a1)
{
  return trap_SendServerCommand(a1, 1, (int)"u");
}

//----- (00045594) --------------------------------------------------------
int __cdecl sub_45594(int a1)
{
  return Scr_MakeGameMessage(a1, "f");
}

//----- (000455B0) --------------------------------------------------------
int __cdecl sub_455B0(int a1)
{
  return Scr_MakeGameMessage(a1, "g");
}

//----- (000455CC) --------------------------------------------------------
int __cdecl sub_455CC(unsigned int a1)
{
  int *v1; // edi
  char *v2; // eax
  char *v3; // eax
  float v5[3]; // [esp+20h] [ebp-18h] BYREF
  float v6[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  Scr_GetVector(0, (int)v6);
  Scr_GetVector(1, (int)v5);
  return ClientSpawn((int)v1, v6, v5);
}

//----- (00045660) --------------------------------------------------------
int __cdecl sub_45660(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // edx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = Scr_GetInt(0);
  result = v1[86];
  *(_DWORD *)(result + 8532) = v4;
  return result;
}

//----- (000456DC) --------------------------------------------------------
int __cdecl sub_456DC(int a1)
{
  int result; // eax

  result = a1;
  *(_BYTE *)(a1 + 9) &= 0xF7u;
  return result;
}

//----- (000456EC) --------------------------------------------------------
int __cdecl sub_456EC(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int v4; // edx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = Scr_GetBool(0);
  result = v1[86];
  *(_DWORD *)(result + 8672) = v4;
  return result;
}

//----- (0004576C) --------------------------------------------------------
int __cdecl sub_4576C(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int *v4; // eax

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  v4 = Scr_GetEntity(0);
  return Scr_AddInt(*(_DWORD *)(v1[86] + 8800) == (_DWORD)v4);
}

//----- (00045800) --------------------------------------------------------
int __cdecl sub_45800(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax
  unsigned __int8 v3; // al
  char *v4; // eax

  if ( a1 > 0x3FF )
  {
    v1 = va("%i is not a valid entity number", a1);
    goto LABEL_5;
  }
  if ( !g_entities[197 * a1 + 86] )
  {
    v1 = va("entity %i is not a player", a1);
LABEL_5:
    Scr_Error((int)v1);
  }
  v2 = (char *)Scr_GetString(0);
  v3 = G_SoundAliasIndex(v2);
  v4 = va("s %i", v3);
  return trap_SendServerCommand(a1, 0, (int)v4);
}

//----- (00045884) --------------------------------------------------------
int __cdecl sub_45884(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char src; // [esp+18h] [ebp-400h] BYREF
  char v6[1023]; // [esp+19h] [ebp-3FFh] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v1, 0, 0, &src);
}

//----- (00045920) --------------------------------------------------------
int __cdecl sub_45920(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  char *v3; // eax
  char src; // [esp+18h] [ebp-400h] BYREF
  char v6[1023]; // [esp+19h] [ebp-3FFh] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    if ( !v1[86] )
    {
      v2 = va("entity %i is not a player", a1);
      Scr_Error((int)v2);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v1, 0, 1, &src);
}

//----- (000459C0) --------------------------------------------------------
int __cdecl DeathmatchScoreboardMessage(int a1)
{
  int *v1; // edi
  _DWORD *v2; // edx
  int v3; // ecx
  char *v4; // eax
  int v5; // edx
  int v6; // esi
  char *v7; // eax
  int v9; // [esp+24h] [ebp-984h]
  int v10; // [esp+28h] [ebp-980h]
  int v11; // [esp+2Ch] [ebp-97Ch]
  char v12[1400]; // [esp+30h] [ebp-978h] BYREF
  char src[1024]; // [esp+5A8h] [ebp-400h] BYREF

  v12[0] = 0;
  v11 = 0;
  v9 = level[133];
  if ( v9 > 64 )
    v9 = 64;
  v10 = 0;
  if ( v9 > 0 )
  {
    v1 = &level[134];
    do
    {
      v2 = (_DWORD *)(level[0] + 8900 * *v1);
      v3 = -1;
      if ( v2[2107] != 1 )
      {
        v3 = v2[2098];
        if ( v3 > 999 )
          v3 = 999;
      }
      Com_sprintf(src, 0x400u, " %i %i %i %i %i", *v1, v2[2104], v3, v2[2105], v2[2102]);
      v4 = src;
      while ( 1 )
      {
        v5 = *(_DWORD *)v4;
        if ( !(unsigned __int8)*(_DWORD *)v4 )
          break;
        if ( !BYTE1(v5) )
          goto LABEL_15;
        if ( (v5 & 0xFF0000) == 0 )
          goto LABEL_14;
        v4 += 4;
        if ( (v5 & 0xFF000000) == 0 )
        {
          v4 -= 3;
LABEL_14:
          ++v4;
LABEL_15:
          ++v4;
          break;
        }
      }
      v6 = v4 - src + v11;
      if ( v6 > 1024 )
        break;
      strcpy(&v12[v11], src);
      v11 = v6;
      ++v1;
      ++v10;
    }
    while ( v10 < v9 );
  }
  v7 = va("b %i %i %i%s", v10, level[127], level[128], v12);
  return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 1, (int)v7);
}
// 21DF80: using guessed type int g_entities[];

//----- (00045B54) --------------------------------------------------------
int __cdecl ClientNumberFromString(int a1, char *nptr)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // edx
  char *v6; // ecx
  int v7; // ebx
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  char *v11; // edx
  char *v12; // ecx
  int v13; // edi
  int v14; // eax
  char *v15; // eax
  char s1[1024]; // [esp+18h] [ebp-800h] BYREF
  char v17[1024]; // [esp+418h] [ebp-400h] BYREF

  if ( (unsigned __int8)(*nptr - 48) > 9u )
  {
    v5 = nptr;
    v6 = v17;
    if ( *nptr )
    {
      v7 = _ctype_tolower;
      do
      {
        if ( *v5 == 27 )
        {
          v5 += 2;
        }
        else if ( *v5 > 31 )
        {
          v8 = *v5++;
          *v6++ = *(_DWORD *)(v7 + 4 * v8);
        }
        else
        {
          ++v5;
        }
      }
      while ( *v5 );
    }
    *v6 = 0;
    v9 = level[0];
    v10 = 0;
    if ( level[120] <= 0 )
    {
LABEL_28:
      v15 = va(aEGameUsernoton, nptr);
      trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v15);
      result = -1;
    }
    else
    {
      while ( 1 )
      {
        if ( *(_DWORD *)(v9 + 8428) == 2 )
        {
          v11 = (char *)(v9 + 8628);
          v12 = s1;
          if ( *(_BYTE *)(v9 + 8628) )
          {
            v13 = _ctype_tolower;
            do
            {
              if ( *v11 == 27 )
              {
                v11 += 2;
              }
              else if ( *v11 > 31 )
              {
                v14 = *v11++;
                *v12++ = *(_DWORD *)(v13 + 4 * v14);
              }
              else
              {
                ++v11;
              }
            }
            while ( *v11 );
          }
          *v12 = 0;
          if ( !strcmp(s1, v17) )
            break;
        }
        ++v10;
        v9 += 8900;
        if ( v10 >= level[120] )
          goto LABEL_28;
      }
      result = v10;
    }
  }
  else
  {
    result = _strtol_internal(nptr, 0, 10, 0);
    if ( result >= 0 && result < level[120] )
    {
      if ( *(_DWORD *)(level[0] + 8900 * result + 8428) != 2 )
      {
        v4 = va(aEGameClientnot_0, result);
        trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v4);
        result = -1;
      }
    }
    else
    {
      v3 = va(aEGameBadclient, result);
      trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v3);
      result = -1;
    }
  }
  return result;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (00045D30) --------------------------------------------------------
__int16 Cmd_Fogswitch_f()
{
  size_t v0; // edi
  char *v1; // edx
  int v2; // eax
  size_t v3; // edx
  size_t v4; // ebx
  int v5; // eax
  __int16 v6; // fps
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  int i; // [esp+30h] [ebp-418h]
  int v13; // [esp+34h] [ebp-414h]
  char v14; // [esp+38h] [ebp-410h] BYREF
  float v15; // [esp+3Ch] [ebp-40Ch] BYREF
  float v16; // [esp+40h] [ebp-408h] BYREF
  char v17; // [esp+44h] [ebp-404h] BYREF
  char src[1024]; // [esp+48h] [ebp-400h] BYREF

  v0 = 0;
  v13 = trap_Argc();
  for ( i = 1; i < v13; ++i )
  {
    trap_Argv(i, (int)src, 1024);
    v1 = src;
    while ( 1 )
    {
      v2 = *(_DWORD *)v1;
      if ( !(unsigned __int8)*(_DWORD *)v1 )
        break;
      if ( !BYTE1(v2) )
        goto LABEL_13;
      if ( (v2 & 0xFF0000) == 0 )
        goto LABEL_12;
      v1 += 4;
      if ( (v2 & 0xFF000000) == 0 )
      {
        v1 -= 3;
LABEL_12:
        ++v1;
LABEL_13:
        ++v1;
        break;
      }
    }
    v3 = v1 - src;
    v4 = v3 + v0;
    if ( (int)(v3 + v0) > 1022 )
      break;
    memcpy(&nptr[v0], src, v3);
    v0 = v4;
    if ( i != v13 - 1 )
    {
      nptr[v4] = 32;
      v0 = v4 + 1;
    }
  }
  nptr[v0] = 0;
  trap_SetConfigstring(12, (int)nptr);
  *(float *)&level[1911] = 3.4028235e38;
  *(float *)&level[1912] = 3.4028235e38;
  v5 = sscanf(nptr, "%f %f %f %f %f %f %f", &v14, &v15, &v16, src, &src[4], &src[8], &v17);
  if ( v5 == 7 )
  {
    v7 = v16 > 1.0;
    v8 = 0;
    v9 = 1.0 == v16;
    LOBYTE(v5) = v6;
    BYTE1(v5) = (HIBYTE(v6) & 0x45) - 1;
    if ( BYTE1(v5) < 0x40u )
    {
      v10 = v15 * 0.82800001;
      *(float *)&level[1911] = v10;
      *(float *)&level[1912] = v10 * v10;
    }
  }
  return v5;
}

//----- (00045EDC) --------------------------------------------------------
void __cdecl Cmd_Give_f(int a1)
{
  char *v1; // eax
  int v2; // eax
  size_t v3; // edi
  char *v4; // edx
  int v5; // eax
  size_t v6; // edx
  size_t v7; // esi
  size_t v8; // edi
  char *v9; // edx
  int v10; // eax
  size_t v11; // edx
  size_t v12; // esi
  char *v13; // eax
  unsigned int v14; // edx
  int v15; // edx
  bool v16; // al
  _BOOL4 v17; // esi
  int k; // ebx
  int v19; // eax
  int l; // ebx
  int m; // ebx
  int *v22; // esi
  int v23; // ebx
  int j; // [esp+20h] [ebp-418h]
  int v25; // [esp+24h] [ebp-414h]
  int v26; // [esp+28h] [ebp-410h]
  int i; // [esp+30h] [ebp-408h]
  int v28; // [esp+34h] [ebp-404h]
  char src[1024]; // [esp+38h] [ebp-400h] BYREF

  if ( g_cheats[3] )
  {
    if ( *(int *)(a1 + 560) > 0 )
    {
      v2 = 1;
      goto LABEL_7;
    }
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
  }
  trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
  v2 = 0;
LABEL_7:
  if ( v2 )
  {
    v3 = 0;
    v28 = trap_Argc();
    for ( i = 2; i < v28; ++i )
    {
      trap_Argv(i, (int)src, 1024);
      v4 = src;
      while ( 1 )
      {
        v5 = *(_DWORD *)v4;
        if ( !(unsigned __int8)*(_DWORD *)v4 )
          break;
        if ( !BYTE1(v5) )
          goto LABEL_20;
        if ( (v5 & 0xFF0000) == 0 )
          goto LABEL_19;
        v4 += 4;
        if ( (v5 & 0xFF000000) == 0 )
        {
          v4 -= 3;
LABEL_19:
          ++v4;
LABEL_20:
          ++v4;
          break;
        }
      }
      v6 = v4 - src;
      v7 = v6 + v3;
      if ( (int)(v6 + v3) > 1022 )
        break;
      memcpy(&nptr[v3], src, v6);
      v3 = v7;
      if ( i != v28 - 1 )
      {
        nptr[v7] = 32;
        v3 = v7 + 1;
      }
    }
    nptr[v3] = 0;
    v26 = _strtol_internal(nptr, 0, 10, 0);
    v8 = 0;
    v25 = trap_Argc();
    for ( j = 1; j < v25; ++j )
    {
      trap_Argv(j, (int)src, 1024);
      v9 = src;
      while ( 1 )
      {
        v10 = *(_DWORD *)v9;
        if ( !(unsigned __int8)*(_DWORD *)v9 )
          break;
        if ( !BYTE1(v10) )
          goto LABEL_34;
        if ( (v10 & 0xFF0000) == 0 )
          goto LABEL_33;
        v9 += 4;
        if ( (v10 & 0xFF000000) == 0 )
        {
          v9 -= 3;
LABEL_33:
          ++v9;
LABEL_34:
          ++v9;
          break;
        }
      }
      v11 = v9 - src;
      v12 = v11 + v8;
      if ( (int)(v11 + v8) > 1022 )
        break;
      memcpy(&nptr[v8], src, v11);
      v8 = v12;
      if ( j != v25 - 1 )
      {
        nptr[v12] = 32;
        v8 = v12 + 1;
      }
    }
    nptr[v8] = 0;
    if ( nptr )
    {
      v13 = nptr;
      v14 = (unsigned int)nptr & 3;
      if ( ((unsigned int)nptr & 3) == 0 )
        goto LABEL_46;
      if ( __SETP__(v14, 0) )
      {
LABEL_44:
        if ( *v13 != BYTE1(v14) )
        {
          ++v13;
LABEL_46:
          while ( 1 )
          {
            v15 = *(_DWORD *)v13;
            if ( !(unsigned __int8)*(_DWORD *)v13 )
              break;
            if ( !BYTE1(v15) )
              goto LABEL_52;
            if ( (v15 & 0xFF0000) == 0 )
              goto LABEL_51;
            v13 += 4;
            if ( (v15 & 0xFF000000) == 0 )
            {
              v13 -= 3;
LABEL_51:
              ++v13;
LABEL_52:
              ++v13;
              goto LABEL_53;
            }
          }
        }
        goto LABEL_53;
      }
      if ( v14 != 2 )
      {
        if ( nptr[0] == BYTE1(v14) )
          goto LABEL_53;
        v13 = &nptr[1];
      }
      if ( *v13 != BYTE1(v14) )
      {
        ++v13;
        goto LABEL_44;
      }
LABEL_53:
      if ( v13 != nptr )
      {
        if ( (v16 = Q_stricmp(nptr, "all") == 0, !(v17 = v16)) && Q_stricmpn(nptr, "health", 6)
          || (!v26 ? (*(_DWORD *)(a1 + 560) = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 252)) : (*(_DWORD *)(a1 + 560) += v26),
              v17) )
        {
          if ( !v17 && Q_stricmp(nptr, "weapons") )
            goto LABEL_90;
          level[7] = 1;
          for ( k = 1; k <= BG_GetNumWeapons(); BG_GivePlayerWeapon(*(_DWORD *)(a1 + 344), k++) )
            ;
          level[7] = 0;
          if ( v17 )
          {
LABEL_90:
            if ( !v17 && Q_stricmpn(nptr, "ammo", 4) )
              goto LABEL_88;
            if ( v26 )
            {
              v19 = *(_DWORD *)(a1 + 344);
              if ( *(_DWORD *)(v19 + 176) )
                Add_Ammo(a1, *(_DWORD *)(v19 + 176), v26, 1);
            }
            else
            {
              for ( l = 1; l <= BG_GetNumWeapons(); Add_Ammo(a1, l++, 998, 1) )
                ;
            }
            if ( v17 )
            {
LABEL_88:
              if ( Q_stricmpn(nptr, "allammo", 7) )
                goto LABEL_89;
              if ( !v26 )
                goto LABEL_89;
              for ( m = 1; m <= BG_GetNumWeapons(); Add_Ammo(a1, m++, v26, 1) )
                ;
              if ( v17 )
              {
LABEL_89:
                if ( !v17 )
                {
                  v22 = BG_FindItem(nptr);
                  if ( v22 )
                  {
                    level[7] = 1;
                    v23 = G_Spawn();
                    *(float *)(v23 + 308) = *(float *)(a1 + 308);
                    *(float *)(v23 + 312) = *(float *)(a1 + 312);
                    *(float *)(v23 + 316) = *(float *)(a1 + 316);
                    G_SetConstString((_WORD *)(v23 + 374), *v22);
                    G_SpawnItem(v23, (int)v22);
                    *(_BYTE *)(v23 + 370) = 1;
                    Touch_Item(v23, (char *)a1, 1);
                    *(_BYTE *)(v23 + 370) = 0;
                    if ( *(_BYTE *)(v23 + 352) )
                      G_FreeEntity((void *)v23);
                    level[7] = 0;
                  }
                }
              }
            }
          }
        }
      }
      return;
    }
  }
}

//----- (000463B4) --------------------------------------------------------
char __cdecl Cmd_Take_f(int a1)
{
  char *v1; // eax
  int v2; // eax
  size_t v3; // edi
  char *v4; // edx
  int v5; // eax
  size_t v6; // edx
  size_t v7; // esi
  size_t v8; // edi
  char *v9; // edx
  int v10; // ecx
  size_t v11; // edx
  size_t v12; // esi
  unsigned int v13; // edx
  int v14; // edx
  int v15; // edi
  int k; // esi
  int v17; // eax
  int v18; // esi
  int v19; // eax
  int v20; // ebx
  int v21; // ebx
  int v22; // ebx
  int v23; // edx
  int v24; // esi
  int v25; // eax
  int l; // esi
  int v27; // eax
  int v28; // ebx
  int v29; // ebx
  int v30; // ebx
  int j; // [esp+20h] [ebp-418h]
  int v33; // [esp+24h] [ebp-414h]
  int v34; // [esp+28h] [ebp-410h]
  int i; // [esp+30h] [ebp-408h]
  int v36; // [esp+34h] [ebp-404h]
  char src[1024]; // [esp+38h] [ebp-400h] BYREF

  if ( g_cheats[3] )
  {
    if ( *(int *)(a1 + 560) > 0 )
    {
      v2 = 1;
      goto LABEL_7;
    }
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
  }
  trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
  v2 = 0;
LABEL_7:
  if ( v2 )
  {
    v3 = 0;
    v36 = trap_Argc();
    for ( i = 2; i < v36; ++i )
    {
      trap_Argv(i, (int)src, 1024);
      v4 = src;
      while ( 1 )
      {
        v5 = *(_DWORD *)v4;
        if ( !(unsigned __int8)*(_DWORD *)v4 )
          break;
        if ( !BYTE1(v5) )
          goto LABEL_20;
        if ( (v5 & 0xFF0000) == 0 )
          goto LABEL_19;
        v4 += 4;
        if ( (v5 & 0xFF000000) == 0 )
        {
          v4 -= 3;
LABEL_19:
          ++v4;
LABEL_20:
          ++v4;
          break;
        }
      }
      v6 = v4 - src;
      v7 = v6 + v3;
      if ( (int)(v6 + v3) > 1022 )
        break;
      memcpy(&nptr[v3], src, v6);
      v3 = v7;
      if ( i != v36 - 1 )
      {
        nptr[v7] = 32;
        v3 = v7 + 1;
      }
    }
    nptr[v3] = 0;
    v34 = _strtol_internal(nptr, 0, 10, 0);
    v8 = 0;
    v33 = trap_Argc();
    for ( j = 1; j < v33; ++j )
    {
      trap_Argv(j, (int)src, 1024);
      v9 = src;
      while ( 1 )
      {
        v10 = *(_DWORD *)v9;
        if ( !(unsigned __int8)*(_DWORD *)v9 )
          break;
        if ( !BYTE1(v10) )
          goto LABEL_34;
        if ( (v10 & 0xFF0000) == 0 )
          goto LABEL_33;
        v9 += 4;
        if ( (v10 & 0xFF000000) == 0 )
        {
          v9 -= 3;
LABEL_33:
          ++v9;
LABEL_34:
          ++v9;
          break;
        }
      }
      v11 = v9 - src;
      v12 = v11 + v8;
      if ( (int)(v11 + v8) > 1022 )
        break;
      memcpy(&nptr[v8], src, v11);
      v8 = v12;
      if ( j != v33 - 1 )
      {
        nptr[v12] = 32;
        v8 = v12 + 1;
      }
    }
    nptr[v8] = 0;
    v2 = (int)nptr;
    if ( nptr )
    {
      v13 = (unsigned int)nptr & 3;
      if ( ((unsigned __int8)nptr & 3) == 0 )
        goto LABEL_46;
      if ( __SETP__((unsigned int)nptr & 3, 0) )
      {
LABEL_44:
        if ( *(_BYTE *)v2 != BYTE1(v13) )
        {
          ++v2;
LABEL_46:
          while ( 1 )
          {
            v14 = *(_DWORD *)v2;
            if ( !(unsigned __int8)*(_DWORD *)v2 )
              break;
            if ( !BYTE1(v14) )
              goto LABEL_52;
            if ( (v14 & 0xFF0000) == 0 )
              goto LABEL_51;
            v2 += 4;
            if ( (v14 & 0xFF000000) == 0 )
            {
              v2 -= 3;
LABEL_51:
              ++v2;
LABEL_52:
              ++v2;
              goto LABEL_53;
            }
          }
        }
        goto LABEL_53;
      }
      if ( v13 != 2 )
      {
        if ( nptr[0] == BYTE1(v13) )
          goto LABEL_53;
        v2 = (int)&nptr[1];
      }
      if ( *(_BYTE *)v2 != BYTE1(v13) )
      {
        ++v2;
        goto LABEL_44;
      }
LABEL_53:
      if ( (char *)v2 != nptr )
      {
        LOBYTE(v2) = Q_stricmp(nptr, "all") == 0;
        v15 = (unsigned __int8)v2;
        if ( !(_BYTE)v2 )
        {
          v2 = Q_stricmpn(nptr, "health", 6);
          if ( v2 )
            goto LABEL_68;
        }
        if ( v34 )
        {
          v2 = *(_DWORD *)(a1 + 560) - v34;
          *(_DWORD *)(a1 + 560) = v2;
          if ( v2 <= 0 )
            *(_DWORD *)(a1 + 560) = 1;
        }
        else
        {
          *(_DWORD *)(a1 + 560) = 1;
        }
        if ( v15 )
        {
LABEL_68:
          if ( !v15 && Q_stricmp(nptr, "weapons") )
            goto LABEL_79;
          for ( k = 1; k <= BG_GetNumWeapons(); ++k )
          {
            BG_TakePlayerWeapon(*(_DWORD *)(a1 + 344), k);
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * BG_AmmoForWeapon(k)) = 0;
            v17 = BG_ClipForWeapon(k);
            *(_DWORD *)(*(_DWORD *)(a1 + 344) + 524 + 4 * v17) = 0;
          }
          v2 = *(_DWORD *)(a1 + 344);
          if ( *(_DWORD *)(v2 + 176) )
          {
            *(_DWORD *)(v2 + 176) = 0;
            LOBYTE(v2) = trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 1, (int)"a 0");
          }
          if ( v15 )
          {
LABEL_79:
            if ( !v15 && Q_stricmpn(nptr, "ammo", 4) )
              goto LABEL_80;
            if ( v34 )
            {
              v2 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 176);
              if ( v2 )
              {
                v18 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 176);
                v19 = BG_AmmoForWeapon(v18);
                *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * v19) -= v34;
                v20 = *(_DWORD *)(a1 + 344);
                v2 = BG_AmmoForWeapon(v18);
                if ( *(int *)(v20 + 268 + 4 * v2) < 0 )
                {
                  v21 = BG_ClipForWeapon(v18);
                  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 524 + 4 * v21) += *(_DWORD *)(*(_DWORD *)(a1 + 344)
                                                                                  + 268
                                                                                  + 4 * BG_AmmoForWeapon(v18));
                  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * BG_AmmoForWeapon(v18)) = 0;
                  v22 = *(_DWORD *)(a1 + 344);
                  v2 = BG_ClipForWeapon(v18);
                  if ( *(int *)(v22 + 524 + 4 * v2) < 0 )
                  {
                    v23 = BG_ClipForWeapon(v18);
                    v2 = *(_DWORD *)(a1 + 344) + 524;
                    *(_DWORD *)(v2 + 4 * v23) = 0;
                  }
                }
              }
            }
            else
            {
              v24 = 1;
              while ( 1 )
              {
                v2 = BG_GetNumWeapons();
                if ( v24 > v2 )
                  break;
                *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * BG_AmmoForWeapon(v24)) = 0;
                v25 = BG_ClipForWeapon(v24++);
                *(_DWORD *)(*(_DWORD *)(a1 + 344) + 524 + 4 * v25) = 0;
              }
            }
            if ( v15 )
            {
LABEL_80:
              v2 = Q_stricmpn(nptr, "allammo", 7);
              if ( !v2 && v34 )
              {
                for ( l = 1; ; ++l )
                {
                  v2 = BG_GetNumWeapons();
                  if ( l > v2 )
                    break;
                  v27 = BG_AmmoForWeapon(l);
                  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * v27) -= v34;
                  v28 = *(_DWORD *)(a1 + 344);
                  if ( *(int *)(v28 + 268 + 4 * BG_AmmoForWeapon(l)) < 0 )
                  {
                    v29 = BG_ClipForWeapon(l);
                    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 524 + 4 * v29) += *(_DWORD *)(*(_DWORD *)(a1 + 344)
                                                                                    + 268
                                                                                    + 4 * BG_AmmoForWeapon(l));
                    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 268 + 4 * BG_AmmoForWeapon(l)) = 0;
                    v30 = *(_DWORD *)(a1 + 344);
                    if ( *(int *)(v30 + 524 + 4 * BG_ClipForWeapon(l)) < 0 )
                      *(_DWORD *)(*(_DWORD *)(a1 + 344) + 524 + 4 * BG_ClipForWeapon(l)) = 0;
                  }
                }
              }
            }
          }
        }
      }
      return v2;
    }
  }
  return v2;
}

//----- (00046A28) --------------------------------------------------------
int __cdecl StopFollowing(int a1)
{
  int result; // eax
  int v2; // edi
  long double v3; // fst7
  char v4[4]; // [esp+14h] [ebp-84h] BYREF
  float v5; // [esp+18h] [ebp-80h]
  float v6; // [esp+1Ch] [ebp-7Ch]
  float v7; // [esp+20h] [ebp-78h]
  float v8; // [esp+44h] [ebp-54h]
  float v9; // [esp+48h] [ebp-50h]
  float v10; // [esp+4Ch] [ebp-4Ch]
  float v11[6]; // [esp+50h] [ebp-48h] BYREF
  float v12[3]; // [esp+68h] [ebp-30h] BYREF
  float v13[3]; // [esp+74h] [ebp-24h] BYREF
  float v14; // [esp+80h] [ebp-18h] BYREF
  float v15; // [esp+84h] [ebp-14h]
  float v16; // [esp+88h] [ebp-10h]
  float v17[3]; // [esp+8Ch] [ebp-Ch] BYREF

  result = a1;
  v2 = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(v2 + 8404) = -1;
  *(_DWORD *)(v2 + 8660) = -1;
  if ( (*(_BYTE *)(v2 + 14) & 1) != 0 )
  {
    v17[0] = *(float *)(v2 + 192);
    v17[1] = *(float *)(v2 + 196);
    v17[2] = *(float *)(v2 + 200);
    AngleVectors(v17, v13, 0, v12);
    v17[0] = v17[0] + 15.0;
    v14 = *(float *)(v2 + 20);
    v15 = *(float *)(v2 + 24);
    v3 = *(float *)(v2 + 28);
    v16 = *(float *)(v2 + 28);
    v16 = v3 + *(float *)(v2 + 208);
    G_AddLean(a1, (int)&v14);
    v11[3] = v12[0] * 10.0 + v13[0] * -40.0 + v14;
    v11[0] = -8.0;
    v11[1] = -8.0;
    v11[2] = -8.0;
    v8 = 8.0;
    v9 = 8.0;
    v10 = 8.0;
    v11[4] = v13[1] * -40.0 + v15 + v12[1] * 10.0;
    v11[5] = 10.0 * v12[2] + -40.0 * v13[2] + v16;
    trap_TraceCapsule((int)v4, (int)&v14, (int)v11);
    v14 = v5;
    v15 = v6;
    v16 = v7;
    *(_DWORD *)(v2 + 184) = 0;
    *(_DWORD *)(v2 + 172) = (1024687629 * (a1 - (int)g_entities)) >> 2;
    *(_BYTE *)(v2 + 129) &= 0x3Fu;
    *(_DWORD *)(v2 + 884) = 0;
    *(_DWORD *)(v2 + 888) = 1023;
    *(_DWORD *)(v2 + 896) = 0;
    *(_DWORD *)(v2 + 12) &= 0xFFFEFFDF;
    G_SetOrigin(a1, &v14);
    *(float *)(v2 + 20) = v14;
    *(float *)(v2 + 24) = v15;
    *(float *)(v2 + 28) = v16;
    result = SetClientViewAngle(a1, v17);
    *(_DWORD *)(v2 + 988) = 0;
    *(_DWORD *)(v2 + 992) = 0;
    *(_DWORD *)(v2 + 996) = 0;
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00046C14) --------------------------------------------------------
int __cdecl G_Say(int a1, int a2, int a3, char *src)
{
  int v4; // eax
  const char *v5; // esi
  int result; // eax
  const char *v7; // eax
  int v8; // eax
  int v9; // esi
  int *v10; // ebx
  const char *v11; // eax
  int v12; // eax
  char *v13; // [esp-18h] [ebp-210h]
  char *v14; // [esp-18h] [ebp-210h]
  const char *v15; // [esp-10h] [ebp-208h]
  char *v16; // [esp-8h] [ebp-200h]
  char *v17; // [esp-8h] [ebp-200h]
  char *v18; // [esp-4h] [ebp-1FCh]
  int v19; // [esp+1Ch] [ebp-1DCh]
  char v20[64]; // [esp+20h] [ebp-1D8h] BYREF
  char v21[152]; // [esp+60h] [ebp-198h] BYREF
  char s[64]; // [esp+F8h] [ebp-100h] BYREF
  char v23[128]; // [esp+138h] [ebp-C0h] BYREF
  char dest[64]; // [esp+1B8h] [ebp-40h] BYREF

  if ( a3 == 1 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572);
    if ( v4 != 1 && v4 != 2 )
      a3 = 0;
  }
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 344) + 8628), 64);
  Q_CleanStr(dest);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572) == 3 )
  {
    v16 = (char *)&unk_73989;
  }
  else if ( *(int *)(a1 + 560) > 0 )
  {
    v16 = (char *)&byte_739AC;
  }
  else
  {
    v16 = (char *)&unk_7399D;
  }
  Com_sprintf(s, 0x40u, v16);
  if ( a3 == 1 )
  {
    v5 = "GAME_ALLIES";
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572) == 1 )
      v5 = "GAME_AXIS";
    G_LogPrintf("sayteam: %s: %s\n", dest, src);
    if ( Team_GetLocationMsg(a1, v20, 0x40u) )
    {
      v18 = v20;
      v15 = v5;
      v13 = (char *)&unk_739EE;
    }
    else
    {
      v15 = v5;
      v13 = aS;
    }
    Com_sprintf(v23, 0x80u, v13, s, v15, dest, "^7", v18);
    v19 = 53;
  }
  else if ( a3 > 1 && a3 == 2 )
  {
    if ( a2
      && *(_DWORD *)(*(_DWORD *)(a2 + 344) + 8572) == *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572)
      && Team_GetLocationMsg(a1, v20, 0x40u) )
    {
      v17 = v20;
      v14 = "%s[%s]%s (%s): ";
    }
    else
    {
      v14 = "%s[%s]%s: ";
    }
    Com_sprintf(v23, 0x80u, v14, s, dest, "^7", v17);
    v19 = 51;
  }
  else
  {
    G_LogPrintf("say: %s: %s\n", dest, src);
    Com_sprintf(v23, 0x80u, "%s%s%s: ", s, dest, "^7");
    v19 = 55;
  }
  result = Q_strncpyz(v21, src, 150);
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 352) )
    {
      result = *(_DWORD *)(a2 + 344);
      if ( result )
      {
        if ( *(_DWORD *)(result + 8428) == 2 && (a3 != 1 || (result = OnSameTeam(a1, a2)) != 0) )
        {
          if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8400)
            || (result = *(_DWORD *)(a2 + 344), *(_DWORD *)(result + 8400)) )
          {
            v7 = "h";
            if ( a3 == 1 )
              v7 = "i";
            v8 = va(aS_5, v7, v23, 94, v19, v21);
            result = trap_SendServerCommand((1024687629 * (a2 - (int)&g_entities)) >> 2, 0, v8);
          }
        }
      }
    }
  }
  else
  {
    if ( g_dedicated[3] )
      result = G_Printf("%s%s\n", v23, v21);
    v9 = 0;
    if ( level[120] > 0 )
    {
      v10 = &g_entities;
      do
      {
        if ( v10 )
        {
          if ( *((_BYTE *)v10 + 352) )
          {
            result = v10[86];
            if ( result )
            {
              if ( *(_DWORD *)(result + 8428) == 2 && (a3 != 1 || (result = OnSameTeam(a1, v10)) != 0) )
              {
                if ( !*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8400) || (result = v10[86], *(_DWORD *)(result + 8400)) )
                {
                  v11 = "h";
                  if ( a3 == 1 )
                    v11 = "i";
                  v12 = va(aS_5, v11, v23, 94, v19, v21);
                  result = trap_SendServerCommand((1024687629 * ((char *)v10 - (char *)&g_entities)) >> 2, 0, v12);
                }
              }
            }
          }
        }
        v10 += 197;
        ++v9;
      }
      while ( v9 < level[120] );
    }
  }
  return result;
}
// 46DAC: variable 'v18' is possibly undefined
// 46E3C: variable 'v17' is possibly undefined
// 63648: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 64AEC: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);
// 6B544: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 21DF80: using guessed type int g_entities;

//----- (00047050) --------------------------------------------------------
int __cdecl sub_47050(int a1, int a2, int a3)
{
  int result; // eax
  size_t v4; // edi
  char *v5; // edx
  int v6; // eax
  size_t v7; // edx
  size_t v8; // esi
  char *v9; // edx
  int v10; // eax
  size_t v11; // edx
  size_t v12; // esi
  int j; // [esp+24h] [ebp-414h]
  int v14; // [esp+28h] [ebp-410h]
  int i; // [esp+30h] [ebp-408h]
  int v16; // [esp+34h] [ebp-404h]
  char src[1024]; // [esp+38h] [ebp-400h] BYREF

  result = trap_Argc();
  if ( result > 1 || a3 )
  {
    if ( a3 )
    {
      v4 = 0;
      v16 = trap_Argc();
      for ( i = 0; i < v16; ++i )
      {
        trap_Argv(i, src, 1024);
        v5 = src;
        while ( 1 )
        {
          v6 = *(_DWORD *)v5;
          if ( !(unsigned __int8)*(_DWORD *)v5 )
            break;
          if ( !BYTE1(v6) )
            goto LABEL_16;
          if ( (v6 & 0xFF0000) == 0 )
            goto LABEL_15;
          v5 += 4;
          if ( (v6 & 0xFF000000) == 0 )
          {
            v5 -= 3;
LABEL_15:
            ++v5;
LABEL_16:
            ++v5;
            break;
          }
        }
        v7 = v5 - src;
        v8 = v7 + v4;
        if ( (int)(v7 + v4) > 1022 )
          break;
        memcpy(&nptr[v4], src, v7);
        v4 = v8;
        if ( i != v16 - 1 )
        {
          nptr[v8] = 32;
          v4 = v8 + 1;
        }
      }
    }
    else
    {
      v4 = 0;
      v14 = trap_Argc();
      for ( j = 1; j < v14; ++j )
      {
        trap_Argv(j, src, 1024);
        v9 = src;
        while ( 1 )
        {
          v10 = *(_DWORD *)v9;
          if ( !(unsigned __int8)*(_DWORD *)v9 )
            break;
          if ( !BYTE1(v10) )
            goto LABEL_31;
          if ( (v10 & 0xFF0000) == 0 )
            goto LABEL_30;
          v9 += 4;
          if ( (v10 & 0xFF000000) == 0 )
          {
            v9 -= 3;
LABEL_30:
            ++v9;
LABEL_31:
            ++v9;
            break;
          }
        }
        v11 = v9 - src;
        v12 = v11 + v4;
        if ( (int)(v11 + v4) > 1022 )
          break;
        memcpy(&nptr[v4], src, v11);
        v4 = v12;
        if ( j != v14 - 1 )
        {
          nptr[v12] = 32;
          v4 = v12 + 1;
        }
      }
    }
    nptr[v4] = 0;
    result = G_Say(a1, 0, a2, nptr);
  }
  return result;
}
// 6340C: using guessed type int trap_Argc(void);
// 63424: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);

//----- (00047210) --------------------------------------------------------
int __cdecl sub_47210(int a1)
{
  int result; // eax
  int v2; // eax
  bool v3; // zf
  size_t v4; // edi
  char *v5; // edx
  int v6; // eax
  size_t v7; // edx
  size_t v8; // esi
  int i; // [esp+1Ch] [ebp-80Ch]
  int v10; // [esp+20h] [ebp-808h]
  int v11; // [esp+24h] [ebp-804h]
  char src[1024]; // [esp+28h] [ebp-800h] BYREF
  char nptr[1024]; // [esp+428h] [ebp-400h] BYREF

  result = trap_Argc();
  if ( result > 1 )
  {
    trap_Argv(1, (int)nptr, 1024);
    result = _strtol_internal(nptr, 0, 10, 0);
    if ( result >= 0 && result < level[120] )
    {
      v2 = 197 * result;
      v3 = &g_entities[v2] == 0;
      result = (int)&g_entities[v2];
      v11 = result;
      if ( !v3 && *(_BYTE *)(result + 352) && *(_DWORD *)(result + 344) )
      {
        v4 = 0;
        v10 = trap_Argc();
        for ( i = 2; i < v10; ++i )
        {
          trap_Argv(i, (int)src, 1024);
          v5 = src;
          while ( 1 )
          {
            v6 = *(_DWORD *)v5;
            if ( !(unsigned __int8)*(_DWORD *)v5 )
              break;
            if ( !BYTE1(v6) )
              goto LABEL_19;
            if ( (v6 & 0xFF0000) == 0 )
              goto LABEL_18;
            v5 += 4;
            if ( (v6 & 0xFF000000) == 0 )
            {
              v5 -= 3;
LABEL_18:
              ++v5;
LABEL_19:
              ++v5;
              break;
            }
          }
          v7 = v5 - src;
          v8 = v7 + v4;
          if ( (int)(v7 + v4) > 1022 )
            break;
          memcpy(&::nptr[v4], src, v7);
          v4 = v8;
          if ( i != v10 - 1 )
          {
            ::nptr[v8] = 32;
            v4 = v8 + 1;
          }
        }
        ::nptr[v4] = 0;
        G_LogPrintf(
          "tell: %s to %s: %s\n",
          (const char *)(*(_DWORD *)(a1 + 344) + 8628),
          (const char *)(*(_DWORD *)(v11 + 344) + 8628),
          ::nptr);
        G_Say(a1, v11, 2, ::nptr);
        result = G_Say(a1, a1, 2, ::nptr);
      }
    }
  }
  return result;
}

//----- (000473B8) --------------------------------------------------------
int __cdecl G_Voice(int a1, int a2, int a3, const char *a4, int a5)
{
  int v5; // edx
  int result; // eax
  int v7; // ecx
  int v8; // edi
  int v9; // edx
  __int16 *v10; // ecx
  int v11; // edi
  int *i; // esi
  int v13; // edx
  __int16 *v14; // ecx
  char *v15; // eax
  int v16; // [esp-8h] [ebp-30h]

  v5 = *(_DWORD *)(a1 + 776) - (level[122] - *(_DWORD *)(a1 + 780));
  *(_DWORD *)(a1 + 776) = v5;
  result = level[122];
  *(_DWORD *)(a1 + 780) = result;
  if ( v5 < 0 )
    *(_DWORD *)(a1 + 776) = 0;
  v7 = *(_DWORD *)(a1 + 776);
  if ( v7 > 29999 )
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)&unk_73A80);
  v8 = g_voiceChatsAllowed[3];
  if ( !v8 )
    return result;
  result = 34000 / v8;
  *(_DWORD *)(a1 + 776) = 34000 / v8 + v7;
  if ( !a2 )
  {
    if ( g_dedicated[3] )
      result = G_Printf("voice: %s %s\n", (const char *)(*(_DWORD *)(a1 + 344) + 8628), a4);
    v11 = 0;
    if ( level[120] <= 0 )
      return result;
    for ( i = g_entities; ; i += 197 )
    {
      if ( !i )
        goto LABEL_33;
      if ( !*((_BYTE *)i + 352) )
        goto LABEL_33;
      result = i[86];
      if ( !result || *(_DWORD *)(result + 8428) != 2 )
        goto LABEL_33;
      if ( a3 != 1 )
        break;
      result = OnSameTeam(a1, (int)i);
      if ( result )
      {
        v13 = 53;
        v14 = aKlj;
LABEL_32:
        v15 = va(
                "%s %d %d %d %s %i %i %i",
                (const char *)v14,
                a5,
                *(_DWORD *)a1,
                v13,
                a4,
                (int)*(float *)(a1 + 24),
                (int)*(float *)(a1 + 28),
                (int)*(float *)(a1 + 32));
        result = trap_SendServerCommand((1024687629 * ((char *)i - (char *)g_entities)) >> 2, 0, (int)v15);
      }
LABEL_33:
      if ( ++v11 >= level[120] )
        return result;
    }
    if ( a3 == 2 )
    {
      v13 = 54;
      v14 = &aKlj[1];
    }
    else
    {
      v13 = 50;
      v14 = &aKlj[2];
    }
    goto LABEL_32;
  }
  if ( *(_BYTE *)(a2 + 352) )
  {
    result = *(_DWORD *)(a2 + 344);
    if ( result )
    {
      if ( *(_DWORD *)(result + 8428) == 2 )
      {
        if ( a3 == 1 )
        {
          result = OnSameTeam(a1, a2);
          if ( !result )
            return result;
          v9 = 53;
          v10 = aKlj;
        }
        else if ( a3 == 2 )
        {
          v9 = 54;
          v10 = &aKlj[1];
        }
        else
        {
          v9 = 50;
          v10 = &aKlj[2];
        }
        va(
          "%s %d %d %d %s %i %i %i",
          (const char *)v10,
          a5,
          *(_DWORD *)a1,
          v9,
          a4,
          (int)*(float *)(a1 + 24),
          (int)*(float *)(a1 + 28),
          (int)*(float *)(a1 + 32));
        result = trap_SendServerCommand((1024687629 * (a2 - (int)g_entities)) >> 2, 0, v16);
      }
    }
  }
  return result;
}
// 4754C: variable 'v16' is possibly undefined
// 73A48: using guessed type __int16 aKlj[3];

//----- (000476C0) --------------------------------------------------------
int __cdecl sub_476C0(int a1, int a2, int a3, int a4)
{
  int result; // eax
  size_t v5; // edi
  char *v6; // edx
  int v7; // eax
  size_t v8; // edx
  size_t v9; // esi
  char *v10; // edx
  int v11; // eax
  size_t v12; // edx
  size_t v13; // esi
  int j; // [esp+24h] [ebp-414h]
  int v15; // [esp+28h] [ebp-410h]
  int i; // [esp+30h] [ebp-408h]
  int v17; // [esp+34h] [ebp-404h]
  char src[1024]; // [esp+38h] [ebp-400h] BYREF

  result = trap_Argc();
  if ( result > 1 || a3 )
  {
    if ( a3 )
    {
      v5 = 0;
      v17 = trap_Argc();
      for ( i = 0; i < v17; ++i )
      {
        trap_Argv(i, (int)src, 1024);
        v6 = src;
        while ( 1 )
        {
          v7 = *(_DWORD *)v6;
          if ( !(unsigned __int8)*(_DWORD *)v6 )
            break;
          if ( !BYTE1(v7) )
            goto LABEL_16;
          if ( (v7 & 0xFF0000) == 0 )
            goto LABEL_15;
          v6 += 4;
          if ( (v7 & 0xFF000000) == 0 )
          {
            v6 -= 3;
LABEL_15:
            ++v6;
LABEL_16:
            ++v6;
            break;
          }
        }
        v8 = v6 - src;
        v9 = v8 + v5;
        if ( (int)(v8 + v5) > 1022 )
          break;
        memcpy(&nptr[v5], src, v8);
        v5 = v9;
        if ( i != v17 - 1 )
        {
          nptr[v9] = 32;
          v5 = v9 + 1;
        }
      }
    }
    else
    {
      v5 = 0;
      v15 = trap_Argc();
      for ( j = 1; j < v15; ++j )
      {
        trap_Argv(j, (int)src, 1024);
        v10 = src;
        while ( 1 )
        {
          v11 = *(_DWORD *)v10;
          if ( !(unsigned __int8)*(_DWORD *)v10 )
            break;
          if ( !BYTE1(v11) )
            goto LABEL_31;
          if ( (v11 & 0xFF0000) == 0 )
            goto LABEL_30;
          v10 += 4;
          if ( (v11 & 0xFF000000) == 0 )
          {
            v10 -= 3;
LABEL_30:
            ++v10;
LABEL_31:
            ++v10;
            break;
          }
        }
        v12 = v10 - src;
        v13 = v12 + v5;
        if ( (int)(v12 + v5) > 1022 )
          break;
        memcpy(&nptr[v5], src, v12);
        v5 = v13;
        if ( j != v15 - 1 )
        {
          nptr[v13] = 32;
          v5 = v13 + 1;
        }
      }
    }
    nptr[v5] = 0;
    result = G_Voice(a1, 0, a2, nptr, a4);
  }
  return result;
}

//----- (00047888) --------------------------------------------------------
int __cdecl Cmd_CallVote_f(int a1)
{
  int v1; // eax
  int v3; // ebx
  char *v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // esi
  char *v9; // eax
  int v10; // ecx
  int v11; // edx
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  int v15; // [esp-14h] [ebp-47Ch]
  int v16; // [esp-14h] [ebp-47Ch]
  const char *v17; // [esp-8h] [ebp-470h]
  int v18; // [esp+14h] [ebp-454h]
  char v19[16]; // [esp+18h] [ebp-450h] BYREF
  char v20[256]; // [esp+28h] [ebp-440h] BYREF
  char v21[256]; // [esp+128h] [ebp-340h] BYREF
  char dest[64]; // [esp+228h] [ebp-240h] BYREF
  char nptr[256]; // [esp+268h] [ebp-200h] BYREF
  char s[256]; // [esp+368h] [ebp-100h] BYREF

  if ( !g_allowVote[3] )
  {
    v17 = "e \"GAME_VOTINGNOTENABLED\"";
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
  }
  if ( level[710] )
  {
    v17 = "e \"GAME_VOTEALREADYINPROGRESS\"";
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
  }
  v1 = *(_DWORD *)(a1 + 344);
  if ( *(int *)(v1 + 8540) > 2 )
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)"e \"GAME_MAXVOTESCALLED\"");
  if ( *(_DWORD *)(v1 + 8572) == 3 )
  {
    v17 = "e \"GAME_NOSPECTATORCALLVOTE\"";
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
  }
  trap_Argv(1, (int)s, 256);
  trap_Argv(2, (int)nptr, 256);
  if ( strchr(s, 59) || strchr(nptr, 59) )
  {
    v17 = "e \"GAME_INVALIDVOTESTRING\"";
    return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
  }
  if ( Q_stricmp(s, "map_restart")
    && Q_stricmp(s, "map_rotate")
    && Q_stricmp(s, "typemap")
    && Q_stricmp(s, "map")
    && Q_stricmp(s, "g_gametype")
    && Q_stricmp(s, "kick")
    && Q_stricmp(s, "clientkick") )
  {
    v3 = (1024687629 * (a1 - (int)g_entities)) >> 2;
    trap_SendServerCommand(v3, 0, (int)"e \"GAME_INVALIDVOTESTRING\"");
    return trap_SendServerCommand(v3, 0, (int)&unk_73C40);
  }
  if ( level[711] )
  {
    level[711] = 0;
    v4 = va((char *)off_73CDD, &level[198]);
    trap_SendConsoleCommand(2, (int)v4);
  }
  if ( Q_stricmp(s, "typemap") )
  {
    if ( Q_stricmp(s, "g_gametype") )
    {
      if ( Q_stricmp(s, "map_restart") )
      {
        if ( Q_stricmp(s, "map_rotate") )
        {
          if ( Q_stricmp(s, "map") )
          {
            if ( Q_stricmp(s, "kick") && Q_stricmp(s, "clientkick") )
            {
              Com_sprintf((char *)&level[198], 0x400u, "%s \"%s\"", s, nptr);
              Com_sprintf((char *)&level[454], 0x400u, (char *)&byte_73E3B, &level[198]);
            }
            else
            {
              v18 = 64;
              if ( Q_stricmp(s, "kick") )
              {
                v18 = _strtol_internal(nptr, 0, 10, 0);
                if ( (v18 || !Q_stricmp(nptr, "0"))
                  && v18 >= 0
                  && v18 <= 63
                  && *(_DWORD *)(level[0] + 8900 * v18 + 8428) == 2 )
                {
                  Q_strncpyz(dest, (char *)(8900 * v18 + level[0] + 8628), 64);
                  Q_CleanStr(dest);
                }
                else
                {
                  v18 = 64;
                }
              }
              else
              {
                v7 = 0;
                v8 = 0;
                do
                {
                  if ( *(_DWORD *)(level[0] + v8 + 8428) == 2 )
                  {
                    Q_strncpyz(dest, (char *)(v8 + level[0] + 8628), 64);
                    Q_CleanStr(dest);
                    if ( !Q_stricmp(dest, nptr) )
                      v18 = v7;
                  }
                  v8 += 8900;
                  ++v7;
                }
                while ( v7 <= 63 );
              }
              if ( v18 == 64 )
              {
                v17 = "e \"GAME_CLIENTNOTONSERVER\"";
                return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
              }
              Com_sprintf((char *)&level[198], 0x400u, "clientkick \"%d\"", v18);
              Com_sprintf((char *)&level[454], 0x400u, aGameVoteKick, v18, level[0] + 8900 * v18 + 8628);
            }
          }
          else
          {
            Com_sprintf((char *)&level[198], 0x400u, "%s %s", s, nptr);
            Com_sprintf((char *)&level[454], 0x400u, aGameVoteMap, nptr);
          }
        }
        else
        {
          Com_sprintf((char *)&level[198], 0x400u, "%s", s);
          Com_sprintf((char *)&level[454], 0x400u, "GAME_VOTE_NEXTMAP", v15);
        }
      }
      else
      {
        Com_sprintf((char *)&level[198], 0x400u, "%s", s);
        Com_sprintf((char *)&level[454], 0x400u, "GAME_VOTE_MAPRESTART", v15);
      }
    }
    else
    {
      if ( !Scr_IsValidGameType(nptr) )
      {
        v17 = "e \"GAME_INVALIDGAMETYPE\"";
        return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
      }
      Com_sprintf((char *)&level[198], 0x400u, "%s %s; map_restart", s, nptr);
      v16 = Scr_GetGameTypeNameForScript(nptr);
      Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety_0, v16);
    }
  }
  else
  {
    if ( !Scr_IsValidGameType(nptr) )
    {
      v17 = "e \"GAME_INVALIDGAMETYPE\"";
      return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
    }
    if ( !Q_stricmp(nptr, &g_gametype[16]) )
      nptr[0] = 0;
    trap_Argv(3, (int)v21, 256);
    trap_Cvar_Register((int)v19, (int)"mapname", (int)&unk_73CFA);
    if ( !Q_stricmp(v21, v20) )
      v21[0] = 0;
    if ( nptr[0] )
    {
      if ( !v21[0] )
      {
        Com_sprintf((char *)&level[198], 0x400u, "g_gametype %s; map_restart", nptr);
        v6 = Scr_GetGameTypeNameForScript(nptr);
        Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety_0, v6);
        goto LABEL_73;
      }
    }
    else if ( !v21[0] )
    {
      v17 = "e \"GAME_TYPEMAP_NOCHANGE\"";
      return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v17);
    }
    if ( nptr[0] )
      Com_sprintf((char *)&level[198], 0x400u, "g_gametype %s; map %s", nptr, v21);
    else
      Com_sprintf((char *)&level[198], 0x400u, "map %s", v21);
    if ( nptr[0] )
    {
      v5 = Scr_GetGameTypeNameForScript(nptr);
      Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety, v5, v21);
    }
    else
    {
      Com_sprintf((char *)&level[454], 0x400u, aGameVoteMap, v21);
    }
  }
LABEL_73:
  v9 = va(aEGameCalledavo, *(_DWORD *)(a1 + 344) + 8628);
  trap_SendServerCommand(-1, 0, (int)v9);
  level[710] = level[122] + 30000;
  level[712] = 1;
  level[713] = 0;
  v10 = 0;
  if ( level[120] > 0 )
  {
    v11 = 0;
    do
    {
      ++v10;
      *(_BYTE *)(level[0] + v11 + 130) &= 0xFDu;
      v11 += 8900;
    }
    while ( v10 < level[120] );
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 344) + 130) |= 2u;
  v12 = va("%i", level[710]);
  trap_SetConfigstring(15, (int)v12);
  trap_SetConfigstring(16, (int)&level[454]);
  v13 = va("%i", level[712]);
  trap_SetConfigstring(17, (int)v13);
  v14 = va("%i", level[713]);
  return trap_SetConfigstring(18, (int)v14);
}
// 47CD2: variable 'v15' is possibly undefined

//----- (00048088) --------------------------------------------------------
int __cdecl Cmd_Vote_f(int a1)
{
  int v1; // edx
  int result; // eax
  int *v3; // esi
  int v4; // edx
  int v5; // edx
  int v6; // eax
  char *v7; // eax
  int v8; // eax
  int v9; // edx
  char *v10; // eax
  int v11; // edx
  char *v12; // eax
  int v13; // [esp-Ch] [ebp-64h]
  const char *v14; // [esp-8h] [ebp-60h]
  char v15; // [esp+18h] [ebp-40h] BYREF
  char v16; // [esp+19h] [ebp-3Fh]

  v1 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v1 + 8556) <= level[122] )
  {
    *(_DWORD *)(v1 + 8556) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8552) = -1;
    if ( level[710] )
    {
      v8 = *(_DWORD *)(a1 + 344);
      if ( (*(_BYTE *)(v8 + 130) & 2) != 0 )
      {
        v6 = 1024687629 * (a1 - (_DWORD)g_entities);
        v14 = "e \"GAME_VOTEALREADYCAST\"";
      }
      else
      {
        if ( *(_DWORD *)(v8 + 8572) != 3 )
        {
          trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)"e \"GAME_VOTECAST\"");
          *(_BYTE *)(*(_DWORD *)(a1 + 344) + 130) |= 2u;
          trap_Argv(1, (int)&v15, 64);
          if ( v15 == 121 || v16 == 89 || v16 == 49 )
          {
            v9 = level[712] + 1;
            level[712] = v9;
            v10 = va("%i", v9);
            result = trap_SetConfigstring(17, (int)v10);
          }
          else
          {
            v11 = level[713] + 1;
            level[713] = v11;
            v12 = va("%i", v11);
            result = trap_SetConfigstring(18, (int)v12);
          }
          return result;
        }
        v6 = 1024687629 * (a1 - (_DWORD)g_entities);
        v14 = "e \"GAME_NOSPECTATORVOTE\"";
      }
    }
    else
    {
      v6 = 1024687629 * (a1 - (_DWORD)g_entities);
      v14 = "e \"GAME_NOVOTEINPROGRESS\"";
    }
    v13 = 0;
    return trap_SendServerCommand(v6 >> 2, v13, (int)v14);
  }
  result = 788 * *(_DWORD *)(v1 + 8552);
  v3 = *(int **)((char *)&g_entities[86] + result);
  if ( v3 && v3[2107] == 2 )
  {
    if ( v3[2120] )
      return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 1, (int)"m -3");
    *(_DWORD *)(v1 + 8556) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8552) = -1;
    trap_Argv(1, (int)&v15, 64);
    if ( v15 != 121 && v16 != 89 && v16 != 49 )
      return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 1, (int)"m -2");
    v4 = v3[2137] + 1;
    v3[2137] = v4;
    v5 = g_complaintlimit[3] - v4;
    if ( v5 > 0 || v3[2120] )
    {
      v7 = va(aE, v5);
      trap_SendServerCommand(v3[43], 0, (int)v7);
      return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 1, (int)"m -1");
    }
    trap_DropClient((-1893646255 * ((int)v3 - level[0])) >> 2, (int)"GAME_KICKEDFROMCOMPLAINTS");
    v6 = 1024687629 * (a1 - (_DWORD)g_entities);
    return trap_SendServerCommand(v6 >> 2, v13, (int)v14);
  }
  return result;
}
// 48278: variable 'v13' is possibly undefined
// 48278: variable 'v14' is possibly undefined

//----- (00048334) --------------------------------------------------------
float *__cdecl Cmd_SetViewpos_f(int a1)
{
  char *v1; // eax
  int i; // esi
  char nptr[1024]; // [esp+30h] [ebp-418h] BYREF
  int v5; // [esp+430h] [ebp-18h] BYREF
  float v6; // [esp+434h] [ebp-14h]
  int v7; // [esp+438h] [ebp-10h]
  float v8[3]; // [esp+43Ch] [ebp-Ch] BYREF

  if ( !g_cheats[3] )
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
    return (float *)trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
  }
  if ( trap_Argc() != 5 )
  {
    v1 = va(aEGameUsage);
    return (float *)trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
  }
  v7 = 0;
  v6 = 0.0;
  v5 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    trap_Argv(i + 1, (int)nptr, 1024);
    v8[i] = _strtod_internal(nptr, 0, 0);
  }
  trap_Argv(4, (int)nptr, 1024);
  v6 = _strtod_internal(nptr, 0, 0);
  return TeleportPlayer(a1, v8, (float *)&v5);
}

//----- (00048468) --------------------------------------------------------
int __cdecl Cmd_Activate_f(int a1)
{
  int v1; // edi
  int v3; // eax
  int v4; // eax
  int *v5; // ebx
  __int16 v6; // dx
  int v7; // eax
  void (__cdecl *v8)(int *, int, _DWORD); // eax
  int v9; // eax
  __int16 v10; // ax
  void (__cdecl *v11)(int *, int, int); // eax
  char s[48]; // [esp+18h] [ebp-30h] BYREF

  v1 = 1;
  if ( !Scr_IsSystemActive(1u) )
    return 0;
  if ( !*(_BYTE *)(a1 + 370) )
  {
    G_CheckForCursorHints(a1);
    v3 = *(_DWORD *)(a1 + 344);
    if ( *(_WORD *)(v3 + 952) != 1023 )
    {
      v4 = 197 * *(unsigned __int16 *)(v3 + 952);
      v5 = &g_entities[v4];
      v6 = HIWORD(g_entities[v4 + 93]);
      if ( !v6 )
        return v1;
      if ( v6 == scr_const[26] || v6 == scr_const[27] )
      {
        G_TryDoor((int)&g_entities[v4], a1, (int *)a1);
        return v1;
      }
      if ( v6 == scr_const[74] )
      {
        Scr_AddEntity((int *)a1);
        Scr_Notify(v5, scr_const[73], 1);
LABEL_20:
        ((void (__cdecl *)(int *, int, int))v5[132])(v5, a1, a1);
        return v1;
      }
      v7 = g_entities[v4 + 1];
      if ( v7 == 3 )
      {
        _bzero(s, 0x30u);
        Scr_AddEntity((int *)a1);
        Scr_Notify(v5, scr_const[72], 1);
        v8 = (void (__cdecl *)(int *, int, _DWORD))v5[131];
        if ( v8 )
        {
          *((_BYTE *)v5 + 370) = 1;
          v8(v5, a1, 0);
          return v1;
        }
        return 0;
      }
      if ( v7 != 11 )
      {
        if ( v6 != scr_const[38] || *((_BYTE *)v5 + 370) )
        {
          v10 = *((_WORD *)v5 + 187);
          if ( v10 != scr_const[57] )
          {
            if ( v10 == scr_const[115] && v5[148] != *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8572) )
              ++v5[140];
            return v1;
          }
          Scr_AddEntity((int *)a1);
          Scr_Notify(v5, scr_const[73], 1);
          v11 = (void (__cdecl *)(int *, int, int))v5[132];
          if ( v11 )
          {
            v11(v5, a1, a1);
            return v1;
          }
        }
        else if ( !infront((float *)v5, (float *)a1) && !*(_DWORD *)(level[0] + 8900 * *(_DWORD *)(a1 + 144) + 52) )
        {
          *((_BYTE *)v5 + 370) = 1;
          v9 = *(_DWORD *)a1;
          *(_BYTE *)(a1 + 370) = 1;
          v5[163] = v5[80];
          v5[164] = v5[81];
          v5[165] = v5[82];
          v5[83] = v9;
          return v1;
        }
        return 0;
      }
      if ( G_IsTurretUsable((int)v5, a1) )
        goto LABEL_20;
    }
    return 0;
  }
  if ( (*(_BYTE *)(*(_DWORD *)(a1 + 344) + 129) & 0xC0) != 0 )
    *(_BYTE *)(a1 + 370) = 2;
  else
    *(_BYTE *)(a1 + 370) = 0;
  return 1;
}
// 21DF80: using guessed type int g_entities[];

//----- (000486D8) --------------------------------------------------------
int __cdecl Cmd_MenuResponse_f(int *a1)
{
  int v1; // ebx
  int result; // eax
  unsigned int v3; // eax
  int v4[256]; // [esp+18h] [ebp-C00h] BYREF
  char v5[1024]; // [esp+418h] [ebp-800h] BYREF
  char nptr[1024]; // [esp+818h] [ebp-400h] BYREF

  if ( trap_Argc() == 4 )
  {
    trap_Argv(1, (int)nptr, 1024);
    v1 = _strtol_internal(nptr, 0, 10, 0);
    result = trap_Cvar_VariableIntegerValue((int)"sv_serverId");
    if ( v1 != result )
      return result;
    trap_Argv(2, (int)v5, 1024);
    v3 = _strtol_internal(v5, 0, 10, 0);
    if ( v3 <= 0x1F )
      trap_GetConfigstring(v3 + 1180, (int)v5, 1024);
    trap_Argv(3, (int)v4, 1024);
  }
  else
  {
    v5[0] = 0;
    v4[0] = 6578530;
  }
  Scr_AddString((int)v4);
  Scr_AddString((int)v5);
  return Scr_Notify(a1, scr_const[93], 2);
}

//----- (000487EC) --------------------------------------------------------
#error "48DD2: positive sp value has been found (funcsize=554)"

//----- (00048F8C) --------------------------------------------------------
int __cdecl Cmd_Score_f(int a1)
{
  return DeathmatchScoreboardMessage(a1);
}

//----- (00048FA4) --------------------------------------------------------
__int16 __cdecl G_setfog(char *s)
{
  int v1; // eax
  __int16 v2; // fps
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  char v8; // [esp+Ch] [ebp-1Ch] BYREF
  float v9; // [esp+10h] [ebp-18h] BYREF
  float v10; // [esp+14h] [ebp-14h] BYREF
  char v11; // [esp+18h] [ebp-10h] BYREF
  char v12; // [esp+1Ch] [ebp-Ch] BYREF
  char v13; // [esp+20h] [ebp-8h] BYREF
  char v14; // [esp+24h] [ebp-4h] BYREF

  trap_SetConfigstring(12, (int)s);
  *(float *)&level[1911] = 3.4028235e38;
  *(float *)&level[1912] = 3.4028235e38;
  v1 = sscanf(s, "%f %f %f %f %f %f %f", &v8, &v9, &v10, &v12, &v13, &v14, &v11);
  if ( v1 == 7 )
  {
    v3 = v10 > 1.0;
    v4 = 0;
    v5 = 1.0 == v10;
    LOBYTE(v1) = v2;
    BYTE1(v1) = (HIBYTE(v2) & 0x45) - 1;
    if ( BYTE1(v1) < 0x40u )
    {
      v6 = v9 * 0.82800001;
      *(float *)&level[1911] = v6;
      *(float *)&level[1912] = v6 * v6;
    }
  }
  return v1;
}

//----- (0004902C) --------------------------------------------------------
int __cdecl Cmd_FollowCycle_f(int a1, int a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // eax
  int v6; // [esp+14h] [ebp-20D4h]
  char v7[8400]; // [esp+18h] [ebp-20D0h] BYREF

  if ( a2 != 1 && a2 != -1 )
    G_Error("Cmd_FollowCycle_f: bad dir %i", a2);
  v2 = *(_DWORD *)(a1 + 344);
  if ( *(int *)(v2 + 8404) >= 0 )
    return 0;
  v3 = *(_DWORD *)(v2 + 8660);
  if ( v3 < 0 )
    v3 = 0;
  v6 = v3;
  while ( 1 )
  {
    v4 = level[120];
    v3 += a2;
    if ( v3 >= v4 )
      v3 = 0;
    if ( v3 < 0 )
      v3 = v4 - 1;
    if ( trap_GetArchivedPlayerState(v3, *(_DWORD *)(a1 + 344) + 8412, (int)v7) )
      break;
    if ( v3 == v6 )
      return 0;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8660) = v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8400) = 2;
  return 1;
}

//----- (000490F4) --------------------------------------------------------
_BOOL4 __cdecl G_IsPlaying(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8400) == 0;
}

//----- (00049114) --------------------------------------------------------
int __cdecl CheatsOk(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax

  if ( g_cheats[3] )
  {
    if ( *(int *)(a1 + 560) > 0 )
    {
      result = 1;
    }
    else
    {
      v3 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
      trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v3);
      result = 0;
    }
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
    trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
    result = 0;
  }
  return result;
}

//----- (00049194) --------------------------------------------------------
char *__cdecl ConcatArgs(int a1)
{
  char *v2; // edx
  int v3; // eax
  size_t v4; // edx
  size_t v5; // esi
  size_t v7; // [esp+20h] [ebp-408h]
  int v8; // [esp+24h] [ebp-404h]
  char src[1024]; // [esp+28h] [ebp-400h] BYREF

  v7 = 0;
  v8 = trap_Argc();
  while ( a1 < v8 )
  {
    trap_Argv(a1, (int)src, 1024);
    v2 = src;
    while ( 1 )
    {
      v3 = *(_DWORD *)v2;
      if ( !(unsigned __int8)*(_DWORD *)v2 )
        break;
      if ( !BYTE1(v3) )
        goto LABEL_13;
      if ( (v3 & 0xFF0000) == 0 )
        goto LABEL_12;
      v2 += 4;
      if ( (v3 & 0xFF000000) == 0 )
      {
        v2 -= 3;
LABEL_12:
        ++v2;
LABEL_13:
        ++v2;
        break;
      }
    }
    v4 = v2 - src;
    v5 = v4 + v7;
    if ( (int)(v4 + v7) > 1022 )
      break;
    memcpy(&nptr[v7], src, v4);
    v7 = v5;
    if ( a1 != v8 - 1 )
    {
      nptr[v5] = 32;
      v7 = v5 + 1;
    }
    ++a1;
  }
  nptr[v7] = 0;
  return nptr;
}

//----- (00049278) --------------------------------------------------------
void __cdecl SanitizeString(char *a1, _BYTE *a2)
{
  int v4; // eax

  while ( *a1 )
  {
    if ( *a1 == 27 )
    {
      a1 += 2;
    }
    else if ( *a1 > 31 )
    {
      v4 = *a1++;
      *a2++ = *(_DWORD *)(_ctype_tolower + 4 * v4);
    }
    else
    {
      ++a1;
    }
  }
  *a2 = 0;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (000492BC) --------------------------------------------------------
int __cdecl Cmd_God_f(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // eax
  const char *v4; // edx
  char *v5; // eax

  if ( !g_cheats[3] )
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
LABEL_5:
    trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
    result = 0;
    goto LABEL_7;
  }
  if ( *(int *)(a1 + 560) <= 0 )
  {
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
    goto LABEL_5;
  }
  result = 1;
LABEL_7:
  if ( result )
  {
    v3 = *(_DWORD *)(a1 + 380);
    LOBYTE(v3) = v3 ^ 1;
    *(_DWORD *)(a1 + 380) = v3;
    v4 = "GAME_GODMODEON";
    if ( (v3 & 1) == 0 )
      v4 = "GAME_GODMODEOFF";
    v5 = va("e \"%s\"", v4);
    result = trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v5);
  }
  return result;
}

//----- (00049378) --------------------------------------------------------
int __cdecl Cmd_Notarget_f(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // eax
  const char *v4; // edx
  char *v5; // eax

  if ( !g_cheats[3] )
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
LABEL_5:
    trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
    result = 0;
    goto LABEL_7;
  }
  if ( *(int *)(a1 + 560) <= 0 )
  {
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
    goto LABEL_5;
  }
  result = 1;
LABEL_7:
  if ( result )
  {
    v3 = *(_DWORD *)(a1 + 380);
    LOBYTE(v3) = v3 ^ 2;
    *(_DWORD *)(a1 + 380) = v3;
    v4 = "GAME_NOTARGETON";
    if ( (v3 & 2) == 0 )
      v4 = "GAME_NOTARGETOFF";
    v5 = va("e \"%s\"", v4);
    result = trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v5);
  }
  return result;
}

//----- (00049428) --------------------------------------------------------
int __cdecl Cmd_Noclip_f(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // edx
  const char *v4; // ecx
  int v5; // eax
  char *v6; // eax

  if ( !g_cheats[3] )
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
LABEL_5:
    trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
    result = 0;
    goto LABEL_7;
  }
  if ( *(int *)(a1 + 560) <= 0 )
  {
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
    goto LABEL_5;
  }
  result = 1;
LABEL_7:
  if ( result )
  {
    v3 = *(_DWORD *)(a1 + 344);
    v4 = "GAME_NOCLIPON";
    v5 = *(_DWORD *)(v3 + 8664);
    if ( v5 )
      v4 = "GAME_NOCLIPOFF";
    *(_DWORD *)(v3 + 8664) = v5 == 0;
    v6 = va("e \"%s\"", v4);
    result = trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v6);
  }
  return result;
}

//----- (000494F8) --------------------------------------------------------
int __cdecl Cmd_UFO_f(int a1)
{
  char *v1; // eax
  int result; // eax
  int v3; // edx
  const char *v4; // ecx
  int v5; // eax
  char *v6; // eax

  if ( !g_cheats[3] )
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"");
LABEL_5:
    trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v1);
    result = 0;
    goto LABEL_7;
  }
  if ( *(int *)(a1 + 560) <= 0 )
  {
    v1 = va("e \"GAME_MUSTBEALIVECOMMAND\"");
    goto LABEL_5;
  }
  result = 1;
LABEL_7:
  if ( result )
  {
    v3 = *(_DWORD *)(a1 + 344);
    v4 = "GAME_UFOON";
    v5 = *(_DWORD *)(v3 + 8668);
    if ( v5 )
      v4 = "GAME_UFOOFF";
    *(_DWORD *)(v3 + 8668) = v5 == 0;
    v6 = va("e \"%s\"", v4);
    result = trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v6);
  }
  return result;
}

//----- (000495C8) --------------------------------------------------------
int __cdecl Cmd_Kill_f(int a1)
{
  int result; // eax
  int v2; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 344);
  if ( !*(_DWORD *)(v2 + 8400) )
  {
    *(_BYTE *)(a1 + 380) &= 0xFEu;
    *(_DWORD *)(a1 + 560) = 0;
    *(_DWORD *)(v2 + 244) = 0;
    result = player_die(a1, a1, a1, 100000, 0x16u, 0, 0, 0);
  }
  return result;
}

//----- (00049614) --------------------------------------------------------
void __cdecl G_SayTo(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  const char *v7; // eax
  char *v8; // eax

  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 352) )
    {
      v6 = *(_DWORD *)(a2 + 344);
      if ( v6 )
      {
        if ( *(_DWORD *)(v6 + 8428) == 2
          && (a3 != 1 || OnSameTeam(a1, a2))
          && (!*(_DWORD *)(*(_DWORD *)(a1 + 344) + 8400) || *(_DWORD *)(*(_DWORD *)(a2 + 344) + 8400)) )
        {
          v7 = "h";
          if ( a3 == 1 )
            v7 = "i";
          v8 = va(aS_5, v7, a5, 94, a4, a6);
          trap_SendServerCommand((1024687629 * (a2 - (int)g_entities)) >> 2, 0, (int)v8);
        }
      }
    }
  }
}

//----- (000496D8) --------------------------------------------------------
unsigned int __cdecl Cmd_GameCommand_f(int a1)
{
  unsigned int v1; // edi
  unsigned int result; // eax
  unsigned int v3; // esi
  char nptr[1024]; // [esp+18h] [ebp-400h] BYREF

  trap_Argv(1, (int)nptr, 1024);
  v1 = _strtol_internal(nptr, 0, 10, 0);
  trap_Argv(2, (int)nptr, 1024);
  result = _strtol_internal(nptr, 0, 10, 0);
  if ( v1 <= 0x3F && result <= 7 )
  {
    v3 = result;
    G_Say(a1, (int)&g_entities[197 * v1], 2, off_7DD00[result]);
    result = G_Say(a1, a1, 2, off_7DD00[v3]);
  }
  return result;
}
// 7DD00: using guessed type char *off_7DD00[7];

//----- (00049780) --------------------------------------------------------
int __cdecl Cmd_Where_f(int a1)
{
  char *v1; // eax
  char *v2; // eax

  v1 = vtos((float *)(a1 + 308));
  v2 = va(aE_0, v1);
  return trap_SendServerCommand((1024687629 * (a1 - (int)g_entities)) >> 2, 0, (int)v2);
}

//----- (000497CC) --------------------------------------------------------
int Cmd_EntityCount_f()
{
  int result; // eax

  if ( g_cheats[3] )
    result = G_Printf("entity count = %i\n", level[3]);
  return result;
}

//----- (00049800) --------------------------------------------------------
char *__cdecl sub_49800(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (0004981C) --------------------------------------------------------
int G_ParseHitLocDmgTable()
{
  const char *v0; // edx
  unsigned int v1; // eax
  int v2; // eax
  int v3; // edi
  int v4; // esi
  int v5; // ebx
  char *v6; // eax
  int v7; // ebx
  int result; // eax
  int v9; // ebx
  size_t n; // [esp+2Ch] [ebp-20ECh]
  int v11; // [esp+30h] [ebp-20E8h] BYREF
  char v12[228]; // [esp+34h] [ebp-20E4h] BYREF
  char s1[8192]; // [esp+118h] [ebp-2000h] BYREF

  v0 = "LOCDMGTABLE";
  v1 = (unsigned int)"LOCDMGTABLE" & 3;
  if ( ((unsigned int)"LOCDMGTABLE" & 3) != 0 )
  {
    if ( !__SETP__((unsigned int)"LOCDMGTABLE" & 3, 0) )
    {
      if ( v1 != 2 )
      {
        if ( aLocdmgtable[0] == BYTE1(v1) )
          goto LABEL_17;
        v0 = "OCDMGTABLE";
      }
      if ( *v0 == BYTE1(v1) )
        goto LABEL_17;
      ++v0;
    }
    if ( *v0 != BYTE1(v1) )
    {
      ++v0;
      goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v2 = *(_DWORD *)v0;
      if ( !(unsigned __int8)*(_DWORD *)v0 )
        break;
      if ( !BYTE1(v2) )
        goto LABEL_16;
      if ( (v2 & 0xFF0000) == 0 )
        goto LABEL_15;
      v0 += 4;
      if ( (v2 & 0xFF000000) == 0 )
      {
        v0 -= 3;
LABEL_15:
        ++v0;
LABEL_16:
        ++v0;
        break;
      }
    }
  }
LABEL_17:
  n = v0 - "LOCDMGTABLE";
  v3 = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    g_fHitLocDamageMult[v5] = 1.0;
    v6 = off_7DD20[v5];
    *(_DWORD *)&v12[v4] = v6;
    *(_DWORD *)&v12[v4 + 4] = 4 * v3;
    *(_DWORD *)&v12[v4 + 8] = 6;
    word_AA140[v5] = Scr_AllocString((int)v6, 1);
    v4 += 12;
    ++v5;
    ++v3;
  }
  while ( v3 <= 18 );
  g_fHitLocDamageMult[18] = 0.0;
  v7 = trap_FS_FOpenFile((int)"info/mp_lochit_dmgtable", (int)&v11, 0);
  if ( v7 <= 0 )
    return Com_Error(1, byte_74140, "info/mp_lochit_dmgtable");
  trap_FS_Read((int)s1, n, v11);
  s1[n] = 0;
  if ( strncmp(s1, "LOCDMGTABLE", n) )
    return Com_Error(1, byte_74180, "info/mp_lochit_dmgtable");
  v9 = v7 - n;
  if ( v9 > 0x1FFF )
    return Com_Error(1, byte_741C0, "info/mp_lochit_dmgtable");
  trap_FS_Read((int)s1, v9, v11);
  s1[v9] = 0;
  trap_FS_FCloseFile(v11);
  if ( !Info_Validate(s1) )
    return Com_Error(1, (char *)&byte_74200, "info/mp_lochit_dmgtable");
  result = ParseConfigStringToStruct(
             (int)g_fHitLocDamageMult,
             (int)v12,
             19,
             s1,
             0,
             0,
             (void (__cdecl *)(int, char *))sub_49800);
  if ( !result )
    result = G_Error("Error parsing hitloc damage table %s\n", "info/mp_lochit_dmgtable");
  return result;
}
// 7DD20: using guessed type char *off_7DD20[18];
// AA140: using guessed type __int16 word_AA140[];

//----- (00049A48) --------------------------------------------------------
int __cdecl player_die(int a1, int a2, int a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  int result; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // ebx
  int *v16; // edi
  int v17; // edx
  long double v18; // fst7
  int v19; // [esp+18h] [ebp-40h]
  float v20; // [esp+30h] [ebp-28h] BYREF
  float v21; // [esp+34h] [ebp-24h]
  float v22; // [esp+38h] [ebp-20h]
  int v23; // [esp+3Ch] [ebp-1Ch]
  float v24[3]; // [esp+40h] [ebp-18h] BYREF
  float v25; // [esp+4Ch] [ebp-Ch] BYREF
  float v26; // [esp+50h] [ebp-8h]
  float v27; // [esp+54h] [ebp-4h]

  result = *(_DWORD *)(a1 + 344);
  v9 = a6;
  if ( *(int *)(result + 4) <= 5 )
  {
    Scr_AddEntity((int *)a3);
    Scr_Notify((int *)a1, scr_const[14], 1);
    if ( a6 )
    {
      v10 = *(_DWORD *)(a3 + 344);
      if ( v10 )
      {
        if ( (*(_BYTE *)(v10 + 129) & 0xC0) != 0 )
        {
          v11 = 197 * *(_DWORD *)(a3 + 116);
          if ( g_entities[v11 + 1] == 11 )
            v9 = g_entities[v11 + 50];
        }
      }
    }
    v12 = *(_DWORD *)(a1 + 344);
    *(_DWORD *)(a1 + 600) = a3;
    if ( *(_DWORD *)(v12 + 52) )
    {
      v13 = rand();
      v25 = (long double)v13 * -4.6566129e-10 + (long double)v13 * -4.6566129e-10 - 1.0;
      v14 = rand();
      v26 = (long double)v14 * -4.6566129e-10 + (long double)v14 * -4.6566129e-10 - 1.0;
      v23 = rand();
      v25 = v25 * 160.0;
      v26 = v26 * 160.0;
      v27 = 160.0 * ((long double)v23 * -4.6566129e-10);
      v24[0] = *(float *)(a1 + 308);
      v24[1] = *(float *)(a1 + 312);
      v24[2] = *(float *)(a1 + 316) + 40.0;
      fire_grenade((_DWORD *)a1, v24, &v25, *(_DWORD *)(a1 + 200));
    }
    BG_AnimScriptEvent(*(_DWORD **)(a1 + 344), 1, 0, 1);
    G_AddEvent((_DWORD *)a1, 189, 0);
    Scr_PlayerKilled((int *)a1, (int *)a2, (int *)a3, a4, a5, v9, a7, a8);
    v15 = 0;
    if ( level[120] > 0 )
    {
      v16 = g_entities;
      v19 = 0;
      do
      {
        v17 = level[0] + v19;
        if ( *(_DWORD *)(level[0] + v19 + 8428) == 2
          && *(_DWORD *)(v17 + 8400) == 2
          && *(_DWORD *)(v17 + 8660) == *(_DWORD *)a1 )
        {
          Cmd_Score_f((int)v16);
        }
        v16 += 197;
        v19 += 8900;
        ++v15;
      }
      while ( v15 < level[120] );
    }
    *(_DWORD *)(a1 + 328) = 0;
    *(_BYTE *)(a1 + 369) = 1;
    *(_DWORD *)(a1 + 280) = 0x4000000;
    if ( !a3 || a3 == a1 )
    {
      if ( !a2 || a2 == a1 )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 344) + 248) = (int)*(float *)(a1 + 324);
        goto LABEL_24;
      }
      v20 = *(float *)(a2 + 308) - *(float *)(a1 + 308);
      v21 = *(float *)(a2 + 312) - *(float *)(a1 + 312);
      v18 = *(float *)(a2 + 316);
    }
    else
    {
      v20 = *(float *)(a3 + 308) - *(float *)(a1 + 308);
      v21 = *(float *)(a3 + 312) - *(float *)(a1 + 312);
      v18 = *(float *)(a3 + 316);
    }
    v22 = v18 - *(float *)(a1 + 316);
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 248) = (int)vectoyaw(&v20);
    vectoyaw(&v20);
LABEL_24:
    *(float *)(*(_DWORD *)(a1 + 344) + 192) = *(float *)(a1 + 320);
    *(float *)(*(_DWORD *)(a1 + 344) + 196) = *(float *)(a1 + 324);
    *(float *)(*(_DWORD *)(a1 + 344) + 200) = *(float *)(a1 + 328);
    *(_DWORD *)(a1 + 132) = 0;
    trap_UnlinkEntity(a1);
    *(float *)(a1 + 276) = 30.0;
    trap_LinkEntity(a1);
    *(_DWORD *)(a1 + 560) = 0;
    *(_DWORD *)(a1 + 536) = 0;
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00049DAC) --------------------------------------------------------
void __cdecl G_Damage(int *a1, int *a2, int *a3, float *a4, float *a5, int a6, int a7, unsigned int a8, int a9)
{
  int *v9; // edi
  _DWORD *v10; // eax
  int v11; // eax
  int v12; // eax
  void (__stdcall *v13)(int *, int *, int *, int, unsigned int, int, float *, int, int, int, int, int, int, int, int); // edx
  int v14; // [esp-4h] [ebp-2Ch]
  int v15; // [esp+0h] [ebp-28h]
  int v16; // [esp+4h] [ebp-24h]
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+Ch] [ebp-1Ch]
  int v19; // [esp+10h] [ebp-18h]
  int v20; // [esp+14h] [ebp-14h]
  int v21; // [esp+18h] [ebp-10h]
  float v22; // [esp+1Ch] [ebp-Ch] BYREF
  float v23; // [esp+20h] [ebp-8h]
  float v24; // [esp+24h] [ebp-4h]
  int savedregs; // [esp+28h] [ebp+0h]

  v9 = a3;
  v10 = (_DWORD *)a1[86];
  if ( v10 )
  {
    if ( *((_BYTE *)a1 + 369) && !v10[2166] && !v10[2167] && v10[2107] == 2 )
    {
      if ( a2 )
      {
        v11 = a2[50];
      }
      else
      {
        v11 = 0;
        if ( a3 )
          v11 = a3[50];
      }
      Scr_PlayerDamage(a1, a2, a3, (int)((long double)a6 * g_fHitLocDamageMult[a9]), a7, a8, v11, (int)a5, (int)a4, a9);
    }
  }
  else if ( *((_BYTE *)a1 + 369) )
  {
    if ( !a2 )
      a2 = &g_entities[201334];
    if ( !a3 )
      v9 = &g_entities[201334];
    if ( a1[1] == 5 )
    {
      if ( a1[132] && !*((_BYTE *)a1 + 372) )
      {
        Scr_AddEntity(v9);
        Scr_Notify(a1, scr_const[73], 1);
        ((void (__stdcall *)(int *, int *, int *, int, int, int, int, int, int, int, int, float, float, float, int))a1[132])(
          a1,
          a2,
          v9,
          v14,
          v15,
          v16,
          v17,
          v18,
          v19,
          v20,
          v21,
          COERCE_FLOAT(LODWORD(v22)),
          COERCE_FLOAT(LODWORD(v23)),
          COERCE_FLOAT(LODWORD(v24)),
          savedregs);
      }
    }
    else
    {
      VectorNormalize2(a4, &v22);
      if ( (a1[95] & 1) == 0 )
      {
        if ( a6 <= 0 )
          a6 = 1;
        if ( g_debugDamage[3] )
          G_Printf("target:%i health:%i damage:%i\n", *a1, a1[140], a6);
        a1[140] -= a6;
        Scr_AddEntity(v9);
        Scr_AddInt(a6);
        Scr_Notify(a1, scr_const[13], 2);
        v12 = a1[140];
        if ( v12 > 0 )
        {
          if ( a1[133] )
          {
            if ( a4 )
            {
              *((float *)a1 + 160) = v22;
              *((float *)a1 + 161) = v23;
              *((float *)a1 + 162) = v24;
              a1[111] = *(int *)a5;
              a1[112] = *((int *)a5 + 1);
              a1[113] = *((int *)a5 + 2);
            }
            else
            {
              a1[162] = 0;
              a1[161] = 0;
              a1[160] = 0;
              a1[113] = 0;
              a1[112] = 0;
              a1[111] = 0;
            }
            ((void (__stdcall *)(int *, int *, int, float *, unsigned int, float *, int, int))a1[133])(
              a1,
              v9,
              a6,
              a5,
              a8,
              &v22,
              a9,
              v14);
          }
        }
        else
        {
          if ( v12 < -999 )
            a1[140] = -999;
          Scr_AddEntity(v9);
          Scr_Notify(a1, scr_const[14], 1);
          v13 = (void (__stdcall *)(int *, int *, int *, int, unsigned int, int, float *, int, int, int, int, int, int, int, int))a1[134];
          a1[150] = (int)v9;
          if ( v13 )
            v13(a1, a2, v9, a6, a8, a2[50], &v22, a9, v15, v16, v17, v18, v19, v20, v21);
        }
      }
    }
  }
}
// 49EE1: variable 'v14' is possibly undefined
// 49EE1: variable 'v15' is possibly undefined
// 49EE1: variable 'v16' is possibly undefined
// 49EE1: variable 'v17' is possibly undefined
// 49EE1: variable 'v18' is possibly undefined
// 49EE1: variable 'v19' is possibly undefined
// 49EE1: variable 'v20' is possibly undefined
// 49EE1: variable 'v21' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (0004A098) --------------------------------------------------------
long double __cdecl CanDamage(int a1, float *a2)
{
  int v2; // eax
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst3
  long double v6; // fst4
  long double v7; // fst7
  long double v8; // fst5
  long double v9; // fst2
  int v10; // edi
  float *v11; // ebx
  int v12; // esi
  long double v13; // fst6
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int v19; // esi
  long double v20; // fst7
  long double v21; // fst4
  long double v22; // fst5
  float *v23; // ebx
  char v24; // fps^1
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  float v28; // [esp+30h] [ebp-A8h]
  float v29; // [esp+48h] [ebp-90h] BYREF
  float v30; // [esp+4Ch] [ebp-8Ch]
  float v31; // [esp+50h] [ebp-88h]
  float v32; // [esp+54h] [ebp-84h]
  float v33; // [esp+58h] [ebp-80h]
  float v34; // [esp+5Ch] [ebp-7Ch]
  float v35; // [esp+60h] [ebp-78h] BYREF
  float v36; // [esp+64h] [ebp-74h]
  float v37; // [esp+68h] [ebp-70h]
  float v38[12]; // [esp+6Ch] [ebp-6Ch] BYREF
  float v39; // [esp+9Ch] [ebp-3Ch] BYREF
  float v40; // [esp+A0h] [ebp-38h]
  float v41; // [esp+A4h] [ebp-34h]
  float v42; // [esp+A8h] [ebp-30h]
  float v43; // [esp+ACh] [ebp-2Ch]
  float v44; // [esp+B0h] [ebp-28h]
  float v45; // [esp+B4h] [ebp-24h]
  float v46; // [esp+B8h] [ebp-20h]
  float v47; // [esp+BCh] [ebp-1Ch]
  float v48; // [esp+C0h] [ebp-18h]
  float v49; // [esp+C4h] [ebp-14h]
  float v50; // [esp+C8h] [ebp-10h]
  float v51; // [esp+CCh] [ebp-Ch]
  float v52; // [esp+D0h] [ebp-8h]
  float v53; // [esp+D4h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 344);
  if ( !v2 )
  {
    v19 = 0;
    v20 = 0.5 * (*(float *)(a1 + 292) + *(float *)(a1 + 304));
    v21 = (*(float *)(a1 + 284) + *(float *)(a1 + 296)) * 0.5;
    v22 = (*(float *)(a1 + 288) + *(float *)(a1 + 300)) * 0.5;
    v23 = &v39;
    v39 = v21;
    v40 = v22;
    v41 = v20;
    v44 = v41;
    v47 = v20;
    v50 = v47;
    v53 = v47;
    v46 = v22 - 15.0;
    v48 = v21 - 15.0;
    v51 = v48;
    v52 = v46;
    v42 = v21 + 15.0;
    v43 = v22 + 15.0;
    v45 = v42;
    v49 = v43;
    while ( 1 )
    {
      trap_LocationalTrace((int)v38, (int)v23, (int)a2);
      v25 = v38[0] > 1.0;
      v26 = 0;
      v27 = 1.0 == v38[0];
      if ( (v24 & 0x45) == 64 )
        break;
      v23 += 3;
      if ( ++v19 > 4 )
        return 0.0;
    }
    return 1.0;
  }
  v29 = *(float *)(a1 + 308);
  v30 = *(float *)(a1 + 312);
  v3 = *(float *)(a1 + 316);
  v31 = *(float *)(a1 + 316);
  v31 = v3 + *(float *)(v2 + 208);
  G_AddLean(a1, (int)&v29);
  v28 = (v31 - *(float *)(a1 + 316)) * 0.5;
  v35 = *a2 - *(float *)(a1 + 308);
  v4 = a2[1] - *(float *)(a1 + 312);
  v37 = 0.0;
  v36 = v4;
  VectorNormalize(&v35);
  v33 = v35;
  v34 = v37;
  v5 = -v36;
  v32 = v5;
  v6 = (v29 + *(float *)(a1 + 308)) * 0.5;
  v7 = (v30 + *(float *)(a1 + 312)) * 0.5;
  v8 = 0.5 * (v31 + *(float *)(a1 + 316));
  v9 = 15.0 * v37 + v8;
  v39 = v6;
  v40 = v7;
  v41 = v8;
  v47 = v9 - v28;
  v44 = v9 + v28;
  v42 = v5 * 15.0 + v6;
  v45 = v42;
  v43 = v35 * 15.0 + v7;
  v46 = v43;
  v48 = v5 * -15.0 + v6;
  v49 = v35 * -15.0 + v7;
  v10 = 0;
  v11 = &v39;
  v12 = 4;
  v51 = v48;
  v52 = v49;
  v13 = v8 + -15.0 * v37;
  v53 = v13 - v28;
  v50 = v13 + v28;
  do
  {
    trap_LocationalTrace((int)v38, (int)v11, (int)a2);
    v15 = v38[0] > 1.0;
    v16 = 0;
    v17 = 1.0 == v38[0];
    if ( (v14 & 0x44) == 0x40 )
      ++v10;
    v11 += 3;
    --v12;
  }
  while ( v12 >= 0 );
  if ( !v10 )
    return 0.0;
  if ( v10 > 3 )
    return 1.0;
  return (long double)v10 / 3.0;
}
// 4A2B0: variable 'v14' is possibly undefined
// 4A3D0: variable 'v24' is possibly undefined

//----- (0004A3F4) --------------------------------------------------------
int __cdecl G_RadiusDamage(int a1, int a2, int a3, float a4, float a5, float a6, int a7, int a8)
{
  long double v9; // fst7
  unsigned int v10; // eax
  int v11; // ecx
  long double v12; // fst6
  int v13; // edx
  int v14; // eax
  int *v15; // ebx
  int v16; // ecx
  long double v17; // fst7
  long double v18; // fst6
  long double v19; // fst7
  char v20; // fps^1
  long double v21; // fst6
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  long double v25; // fst5
  long double v26; // fst6
  long double v27; // fst7
  long double v28; // fst5
  long double v29; // fst6
  char v30; // fps^1
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  long double v34; // fst6
  long double v35; // fst5
  long double v36; // rt1
  long double v37; // fst5
  int v38; // [esp+14h] [ebp-10C4h]
  long double v39; // [esp+18h] [ebp-10C0h]
  int v40; // [esp+38h] [ebp-10A0h]
  int v41; // [esp+40h] [ebp-1098h]
  int v42; // [esp+44h] [ebp-1094h]
  float v43; // [esp+5Ch] [ebp-107Ch]
  float v44; // [esp+5Ch] [ebp-107Ch]
  float v45; // [esp+5Ch] [ebp-107Ch]
  float v46; // [esp+5Ch] [ebp-107Ch]
  float v47; // [esp+5Ch] [ebp-107Ch]
  float v48; // [esp+64h] [ebp-1074h]
  float v49[12]; // [esp+6Ch] [ebp-106Ch] BYREF
  float v50; // [esp+9Ch] [ebp-103Ch]
  float v51; // [esp+A0h] [ebp-1038h]
  float v52; // [esp+A4h] [ebp-1034h]
  float v53; // [esp+A8h] [ebp-1030h] BYREF
  float v54; // [esp+ACh] [ebp-102Ch]
  float v55; // [esp+B0h] [ebp-1028h]
  float v56; // [esp+B4h] [ebp-1024h]
  float v57; // [esp+B8h] [ebp-1020h]
  float v58; // [esp+BCh] [ebp-101Ch]
  char v59[12]; // [esp+C0h] [ebp-1018h] BYREF
  float v60[3]; // [esp+CCh] [ebp-100Ch] BYREF
  _DWORD v61[1024]; // [esp+D8h] [ebp-1000h] BYREF

  v41 = 0;
  if ( !a3 )
    return 0;
  if ( a6 < 1.0 )
    a6 = 1.0;
  v9 = a6 * 1.4142135;
  v10 = 0;
  v11 = 2;
  do
  {
    v12 = *(float *)(a1 + v10) + v9;
    v60[v10 / 4] = *(float *)(a1 + v10) - v9;
    *(float *)&v59[v10] = v12;
    v10 += 4;
    --v11;
  }
  while ( v11 >= 0 );
  v42 = trap_EntitiesInBox((int)v60, (int)v59, (int)v61);
  v13 = 0;
  if ( v42 > 0 )
  {
    while ( 1 )
    {
      v14 = 197 * v61[v13];
      v15 = &g_entities[v14];
      v40 = v13 + 1;
      if ( &g_entities[v14] == (int *)a7 || !*((_BYTE *)v15 + 369) )
        goto LABEL_33;
      if ( g_entities[v14 + 63] )
        break;
      v56 = *((float *)v15 + 77) - *(float *)a1;
      v57 = *((float *)v15 + 78) - *(float *)(a1 + 4);
      v58 = *((float *)v15 + 79) - *(float *)(a1 + 8);
LABEL_20:
      v43 = sqrt(v56 * v56 + v57 * v57 + v58 * v58);
      if ( v43 >= (long double)a6 || v15[86] && level[2685] )
        goto LABEL_33;
      v39 = (1.0 - v43 / a6) * (a4 - a5) + a5;
      v25 = CanDamage((int)v15, (float *)a1);
      if ( v25 <= 0.0 )
      {
        v44 = 0.5 * (*((float *)v15 + 71) + *((float *)v15 + 74));
        v28 = v44;
        v45 = (*((float *)v15 + 72) + *((float *)v15 + 75)) * 0.5;
        v29 = v45;
        v46 = (*((float *)v15 + 73) + *((float *)v15 + 76)) * 0.5;
        v50 = v28;
        v48 = v29;
        v51 = v48;
        v52 = v46;
        trap_Trace((int)v49, a1, (int)&vec3_origin);
        v31 = v49[0] < 1.0;
        v32 = 0;
        v33 = v49[0] == 1.0;
        if ( (v30 & 0x45) != 1 )
          goto LABEL_33;
        v34 = v50 - *(float *)a1;
        v50 = v34;
        v35 = v51 - *(float *)(a1 + 4);
        v51 = v35;
        v36 = v35 * v35;
        v37 = v52 - *(float *)(a1 + 8);
        v52 = v37;
        v47 = sqrt(v36 + v34 * v34 + v37 * v37);
        if ( a6 * 0.2 <= v47 )
          goto LABEL_33;
        if ( LogAccuracyHit((int)v15, a3) )
          v41 = 1;
        v53 = *((float *)v15 + 77) - *(float *)a1;
        v54 = *((float *)v15 + 78) - *(float *)(a1 + 4);
        v26 = *((float *)v15 + 79) - *(float *)(a1 + 8) + 24.0;
        v27 = v39 * 0.1;
      }
      else
      {
        if ( LogAccuracyHit((int)v15, a3) )
          v41 = 1;
        v53 = *((float *)v15 + 77) - *(float *)a1;
        v54 = *((float *)v15 + 78) - *(float *)(a1 + 4);
        v26 = *((float *)v15 + 79) - *(float *)(a1 + 8) + 24.0;
        v27 = v25 * v39;
      }
      v55 = v26;
      G_Damage(v15, (int *)a2, (int *)a3, &v53, (float *)a1, (int)v27, 1, a8, 0);
LABEL_33:
      v13 = v40;
      if ( v40 >= v42 )
        return v41;
    }
    v38 = 0;
    v16 = 2;
    while ( 1 )
    {
      v17 = *(float *)(a1 + v38 * 4);
      v18 = *(float *)&v15[v38 + 71];
      if ( v18 <= v17 )
      {
        v21 = *(float *)&v15[v38 + 74];
        v22 = v21 < v17;
        v23 = 0;
        v24 = v21 == v17;
        if ( (v20 & 0x45) != 1 )
        {
          *(float *)((char *)&v56 + v38 * 4) = 0.0;
          goto LABEL_19;
        }
        v19 = v17 - v21;
      }
      else
      {
        v19 = v18 - v17;
      }
      *(float *)((char *)&v56 + v38 * 4) = v19;
LABEL_19:
      ++v38;
      if ( --v16 < 0 )
        goto LABEL_20;
    }
  }
  return v41;
}
// 4A55E: variable 'v20' is possibly undefined
// 4A758: variable 'v30' is possibly undefined
// 72910: using guessed type float vec3_origin;
// 21DF80: using guessed type int g_entities[];

//----- (0004A8B0) --------------------------------------------------------
int __cdecl G_GetHitLocationString(int a1)
{
  return (unsigned __int16)word_AA140[a1];
}
// AA140: using guessed type __int16 word_AA140[];

//----- (0004A8C4) --------------------------------------------------------
int __cdecl G_GetHitLocationIndexFromString(__int16 a1)
{
  int result; // eax

  result = 0;
  while ( word_AA140[result] != a1 )
  {
    if ( ++result > 18 )
      return 0;
  }
  return result;
}
// AA140: using guessed type __int16 word_AA140[];

//----- (0004A8E4) --------------------------------------------------------
int __cdecl G_IndexForMeansOfDeath(char *a1)
{
  int v1; // ebx

  v1 = 0;
  while ( Q_stricmp(a1, modNames[v1]) )
  {
    if ( ++v1 > 24 )
    {
      Com_Printf("Unknown means of death string '%s'\n", a1);
      return 0;
    }
  }
  return v1;
}
// 7DDA0: using guessed type char *modNames[34];

//----- (0004A930) --------------------------------------------------------
void AddScore()
{
  ;
}

//----- (0004A938) --------------------------------------------------------
void __cdecl LookAtKiller(int a1, float *a2, float *a3)
{
  long double v3; // fst7
  float v4; // [esp+2Ch] [ebp-Ch] BYREF
  float v5; // [esp+30h] [ebp-8h]
  float v6; // [esp+34h] [ebp-4h]

  if ( a3 && a3 != (float *)a1 )
  {
    v4 = a3[77] - *(float *)(a1 + 308);
    v5 = a3[78] - *(float *)(a1 + 312);
    v3 = a3[79];
LABEL_7:
    v6 = v3 - *(float *)(a1 + 316);
    *(_DWORD *)(*(_DWORD *)(a1 + 344) + 248) = (int)vectoyaw(&v4);
    vectoyaw(&v4);
    return;
  }
  if ( a2 && a2 != (float *)a1 )
  {
    v4 = a2[77] - *(float *)(a1 + 308);
    v5 = a2[78] - *(float *)(a1 + 312);
    v3 = a2[79];
    goto LABEL_7;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 248) = (int)*(float *)(a1 + 324);
}

//----- (0004AA38) --------------------------------------------------------
void __cdecl G_DamageClient(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  _DWORD *v9; // eax
  int v10; // edx

  if ( *(_BYTE *)(a1 + 369) )
  {
    v9 = *(_DWORD **)(a1 + 344);
    if ( !v9[2166] && !v9[2167] && v9[2107] == 2 )
    {
      if ( a2 )
      {
        v10 = a2[50];
      }
      else
      {
        v10 = 0;
        if ( a3 )
          v10 = a3[50];
      }
      Scr_PlayerDamage((int *)a1, a2, a3, (int)((long double)a6 * g_fHitLocDamageMult[a9]), a7, a8, v10, a5, a4, a9);
    }
  }
}

//----- (0004AAF0) --------------------------------------------------------
int __cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4)
{
  int v4; // edx
  long double v5; // fst6
  unsigned int v6; // edx
  unsigned int v7; // ebx
  int result; // eax
  int v9; // [esp+18h] [ebp-110h]
  float v10; // [esp+30h] [ebp-F8h]
  float v11; // [esp+34h] [ebp-F4h]
  float v12; // [esp+34h] [ebp-F4h]
  float v13; // [esp+38h] [ebp-F0h]
  float v14; // [esp+38h] [ebp-F0h]
  float v15[3]; // [esp+44h] [ebp-E4h] BYREF
  float v16[3]; // [esp+50h] [ebp-D8h] BYREF
  float v17[51]; // [esp+5Ch] [ebp-CCh] BYREF

  VectorNormalize2((float *)a3, v17);
  PerpendicularVector(v16, v17);
  CrossProduct(v17, v16, v15);
  v4 = 0;
  v9 = 0;
  do
  {
    v10 = (long double)v4 * 0.3926990816987241;
    v11 = cos(v10);
    v13 = sin(v10);
    v5 = a2 * v13;
    v14 = v5;
    v12 = a2 * v11;
    v17[v9 + 3] = v5 * v15[0] + *(float *)a1;
    v17[v9 + 4] = v15[1] * v14 + *(float *)(a1 + 4);
    v17[v9 + 5] = v15[2] * v14 + *(float *)(a1 + 8);
    v17[v9 + 3] = v16[0] * v12 + v17[v9 + 3];
    v17[v9 + 4] = v16[1] * v12 + v17[v9 + 4];
    ++v4;
    v17[v9 + 5] = v16[2] * v12 + v17[v9 + 5];
    v9 += 3;
  }
  while ( (unsigned int)v4 <= 0xF );
  v6 = 0;
  do
  {
    v7 = v6 + 1;
    result = trap_AddDebugLine((int)&v17[3 * v6 + 3], (int)&v17[3 * (((_BYTE)v6 + 1) & 0xF) + 3], a4);
    v6 = v7;
  }
  while ( v7 <= 0xF );
  return result;
}

//----- (0004ACB0) --------------------------------------------------------
int __cdecl G_DebugLine(int a1, int a2, int a3)
{
  return trap_AddDebugLine(a1, a2, a3);
}

//----- (0004ACE0) --------------------------------------------------------
int __cdecl G_DebugBox(int a1, int a2, int a3)
{
  int v3; // ebx
  int v4; // esi
  signed int v5; // edx
  int v6; // eax
  unsigned int v8; // ebx
  int v9; // esi
  int result; // eax
  char v11[96]; // [esp+18h] [ebp-60h] BYREF

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = 0;
    v6 = v4;
    do
    {
      if ( !_bittest(&v3, v5) )
        a2 = a1;
      *(float *)&v11[v6] = *(float *)(a2 + 4 * v5);
      v6 += 4;
      ++v5;
    }
    while ( v5 <= 2 );
    v4 += 12;
    ++v3;
  }
  while ( v3 <= 7 );
  v8 = 0;
  v9 = 0;
  do
  {
    result = trap_AddDebugLine((int)&v11[12 * dword_74460[v9]], (int)&v11[12 * dword_74464[v9]], a3);
    v9 += 2;
    ++v8;
  }
  while ( v8 <= 0xB );
  return result;
}
// 74460: using guessed type int dword_74460[];
// 74464: using guessed type int dword_74464[];

//----- (0004AD68) --------------------------------------------------------
int __cdecl G_DebugCircle(int a1, float a2, int a3, int a4, int a5)
{
  long double v5; // fst6
  long double v6; // fst5
  int v8; // [esp+1Ch] [ebp-Ch] BYREF
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+24h] [ebp-4h]

  if ( a5 )
  {
    *(float *)&v8 = 0.0;
    v9 = 0.0;
    v10 = 1.0;
  }
  else
  {
    v5 = *(float *)(level[0] + 24);
    v6 = *(float *)(level[0] + 28) + *(float *)(level[0] + 208);
    *(float *)&v8 = *(float *)a1 - *(float *)(level[0] + 20);
    v9 = *(float *)(a1 + 4) - v5;
    v10 = *(float *)(a1 + 8) - v6;
  }
  return G_DebugCircleEx(a1, a2, (int)&v8, a3);
}

//----- (0004ADEC) --------------------------------------------------------
int __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5)
{
  long double v5; // fst5
  char v6; // fps^1
  long double v7; // fst2
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst4
  long double v13; // fst7
  char *v14; // ebx
  int v15; // edi
  int result; // eax
  int v17; // [esp+20h] [ebp-F8h]
  int v18; // [esp+28h] [ebp-F0h]
  unsigned int v19; // [esp+28h] [ebp-F0h]
  float v20; // [esp+3Ch] [ebp-DCh]
  float v21; // [esp+40h] [ebp-D8h]
  float v22; // [esp+44h] [ebp-D4h]
  char v23[192]; // [esp+58h] [ebp-C0h] BYREF

  v5 = a3;
  v7 = (a4 - a3) / 15.0;
  v8 = a2;
  v9 = v7 < 0.0;
  v10 = 0;
  v11 = v7 == 0.0;
  if ( (v6 & 0x45) == 1 )
  {
    v12 = a4 - (v5 - 360.0);
    v5 = v5 - 360.0;
    v13 = v12 / 15.0;
  }
  else
  {
    v13 = v7;
  }
  v18 = 0;
  v17 = 0;
  do
  {
    v20 = ((long double)v18 * v13 + v5) * 3.141592653589793 / 180.0;
    v21 = cos(v20);
    v22 = sin(v20);
    *(float *)&v23[v17] = v21 * v8 + *(float *)a1;
    *(float *)&v23[v17 + 4] = v22 * v8 + *(float *)(a1 + 4);
    *(float *)&v23[v17 + 8] = *(float *)(a1 + 8);
    v17 += 12;
    ++v18;
  }
  while ( (unsigned int)v18 <= 0xF );
  v19 = 0;
  v14 = v23;
  v15 = 0;
  do
  {
    result = trap_AddDebugLine((int)v14, (int)&v23[v15 + 12], a5);
    v14 += 12;
    v15 += 12;
    ++v19;
  }
  while ( v19 <= 0xE );
  return result;
}
// 4AE18: variable 'v6' is possibly undefined

//----- (0004AF80) --------------------------------------------------------
int __cdecl sub_4AF80(int a1, int a2, int a3, int a4)
{
  char *v4; // ebx
  int v5; // esi
  int result; // eax
  int i; // esi
  char *v8; // eax
  char s[2048]; // [esp+18h] [ebp-800h] BYREF

  v4 = (char *)Scr_GetString(0);
  v5 = 0;
  if ( a4 <= 0 )
  {
LABEL_5:
    sprintf(s, "\"%s\" is not a valid value for hudelem field \"%s\"\nShould be one of:", v4, *(const char **)a2);
    for ( i = 0; i < a4; ++i )
    {
      v8 = va(" %s", *(const char **)(a3 + 4 * i));
      strncat(s, v8, 0x800u);
      s[2047] = 0;
    }
    result = Scr_Error((int)s);
  }
  else
  {
    while ( Q_stricmp(v4, *(char **)(a3 + 4 * v5)) )
    {
      if ( ++v5 >= a4 )
        goto LABEL_5;
    }
    result = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(result + a1) = v5;
  }
  return result;
}

//----- (0004B03C) --------------------------------------------------------
int __cdecl sub_4B03C(_BYTE *a1)
{
  long double v1; // fst6
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  int result; // eax
  float v8; // [esp+1Ch] [ebp-Ch] BYREF
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+24h] [ebp-4h]

  Scr_GetVector(0, (int)&v8);
  v1 = v8;
  if ( v8 <= 1.0 && v1 < 0.0 )
  {
    v2 = 0.0;
  }
  else if ( v1 <= 1.0 )
  {
    v2 = v1 * 255.0;
  }
  else
  {
    v2 = 255.0;
  }
  a1[28] = (int)(v2 + 0.5);
  v3 = v9;
  if ( v9 <= 1.0 && v3 < 0.0 )
  {
    v4 = 0.0;
  }
  else if ( v3 <= 1.0 )
  {
    v4 = v3 * 255.0;
  }
  else
  {
    v4 = 255.0;
  }
  a1[29] = (int)(v4 + 0.5);
  v5 = v10;
  if ( v10 <= 1.0 && v5 < 0.0 )
  {
    v6 = 0.0;
  }
  else if ( v5 <= 1.0 )
  {
    v6 = v5 * 255.0;
  }
  else
  {
    v6 = 255.0;
  }
  result = (int)(v6 + 0.5);
  a1[30] = result;
  return result;
}

//----- (0004B184) --------------------------------------------------------
int GScr_NewHudElem()
{
  unsigned int v0; // edx
  int *v1; // eax
  int v2; // ebx

  v0 = 0;
  v1 = g_hudelems;
  do
  {
    if ( !*v1 )
    {
      v1[3] = 1065353216;
      v1[27] = 0;
      v1[25] = 0;
      *v1 = 1;
      v1[1] = 0;
      v1[2] = 0;
      v1[4] = 0;
      v1[5] = 0;
      v1[6] = 0;
      v1[7] = -1;
      v1[8] = 0;
      v1[9] = 0;
      v1[10] = 0;
      v1[11] = 0;
      v1[30] = 1;
      v1[12] = 0;
      v1[13] = 0;
      v1[14] = 0;
      v1[15] = 0;
      v1[16] = 0;
      v1[17] = 0;
      v1[18] = 0;
      v1[23] = 0;
      v1[24] = 0;
      v1[26] = 0;
      v1[28] = 1023;
      v1[29] = 0;
      v2 = (int)v1;
      goto LABEL_6;
    }
    v1 += 31;
    ++v0;
  }
  while ( v0 <= 0x3FF );
  v2 = 0;
LABEL_6:
  if ( !v2 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem(v2);
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004B298) --------------------------------------------------------
int GScr_NewClientHudElem()
{
  int *v0; // ebx
  int v1; // eax
  unsigned int v2; // ecx
  int *v3; // edx
  int v4; // ebx

  v0 = Scr_GetEntity(0);
  if ( !v0[86] )
    Scr_ParamError(0, (int)"not a client");
  v1 = *v0;
  v2 = 0;
  v3 = g_hudelems;
  do
  {
    if ( !*v3 )
    {
      v3[3] = 1065353216;
      v3[27] = 0;
      v3[25] = 0;
      *v3 = 1;
      v3[1] = 0;
      v3[2] = 0;
      v3[4] = 0;
      v3[5] = 0;
      v3[6] = 0;
      v3[7] = -1;
      v3[8] = 0;
      v3[9] = 0;
      v3[10] = 0;
      v3[11] = 0;
      v3[30] = 1;
      v3[12] = 0;
      v3[13] = 0;
      v3[14] = 0;
      v3[15] = 0;
      v3[16] = 0;
      v3[17] = 0;
      v3[18] = 0;
      v3[23] = 0;
      v3[24] = 0;
      v3[26] = 0;
      v3[28] = v1;
      v3[29] = 0;
      v4 = (int)v3;
      goto LABEL_8;
    }
    v3 += 31;
    ++v2;
  }
  while ( v2 <= 0x3FF );
  v4 = 0;
LABEL_8:
  if ( !v4 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem(v4);
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004B3D0) --------------------------------------------------------
int GScr_NewTeamHudElem()
{
  __int16 v0; // ax
  int v1; // ebx
  int *v2; // ebx
  const char *v3; // eax
  char *v4; // eax
  unsigned int v5; // ecx
  int *v6; // edx
  int v7; // eax

  v0 = Scr_GetConstString(0);
  if ( v0 == scr_const[2] )
  {
    v1 = 2;
  }
  else if ( v0 == scr_const[4] )
  {
    v1 = 1;
  }
  else if ( v0 == scr_const[62] )
  {
    v1 = 3;
  }
  else
  {
    v3 = (const char *)Scr_GetString(0);
    v4 = va("team \"%s\" should be \"allies\", \"axis\", or \"spectator\"", v3);
    Scr_ParamError(0, (int)v4);
    v1 = 0;
  }
  v5 = 0;
  v6 = g_hudelems;
  v7 = 0;
  do
  {
    if ( !*v6 )
    {
      g_hudelems[v7 + 3] = 1065353216;
      g_hudelems[v7 + 27] = 0;
      g_hudelems[v7 + 25] = 0;
      g_hudelems[v7] = 1;
      g_hudelems[v7 + 1] = 0;
      g_hudelems[v7 + 2] = 0;
      g_hudelems[v7 + 4] = 0;
      g_hudelems[v7 + 5] = 0;
      g_hudelems[v7 + 6] = 0;
      g_hudelems[v7 + 7] = -1;
      g_hudelems[v7 + 8] = 0;
      g_hudelems[v7 + 9] = 0;
      g_hudelems[v7 + 10] = 0;
      g_hudelems[v7 + 11] = 0;
      g_hudelems[v7 + 30] = 1;
      g_hudelems[v7 + 12] = 0;
      g_hudelems[v7 + 13] = 0;
      g_hudelems[v7 + 14] = 0;
      g_hudelems[v7 + 15] = 0;
      g_hudelems[v7 + 16] = 0;
      g_hudelems[v7 + 17] = 0;
      g_hudelems[v7 + 18] = 0;
      g_hudelems[v7 + 23] = 0;
      g_hudelems[v7 + 24] = 0;
      g_hudelems[v7 + 26] = 0;
      g_hudelems[v7 + 28] = 1023;
      g_hudelems[v7 + 29] = v1;
      v2 = &g_hudelems[v7];
      goto LABEL_13;
    }
    v6 += 31;
    v7 += 31;
    ++v5;
  }
  while ( v5 <= 0x3FF );
  v2 = 0;
LABEL_13:
  if ( !v2 )
    Scr_Error((int)"out of hudelems");
  return Scr_AddHudElem((int)v2);
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004B5B0) --------------------------------------------------------
int __cdecl sub_4B5B0(int a1)
{
  int v1; // eax
  int v2; // esi
  int *v3; // ebx
  char *v4; // eax
  int v5; // edi
  int v6; // esi
  int v7; // eax
  char *v8; // eax
  int v9; // eax
  char *v10; // eax
  int result; // eax
  int v12; // [esp+14h] [ebp-4h]

  v1 = Scr_GetNumParam();
  v2 = v1;
  if ( v1 != 1 && v1 != 3 )
    Scr_Error((int)"USAGE: <hudelem> setShader(\"shadername\"[, optional_width, optional_height]);");
  v3 = &g_hudelems[31 * a1];
  v4 = (char *)Scr_GetString(0);
  v12 = G_ShaderIndex(v4);
  if ( v2 == 1 )
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v7 = Scr_GetInt(1);
    v5 = v7;
    if ( v7 < 0 )
    {
      v8 = va("width %i < 0", v7);
      Scr_ParamError(1, (int)v8);
    }
    v9 = Scr_GetInt(2);
    v6 = v9;
    if ( v9 < 0 )
    {
      v10 = va("height %i < 0", v9);
      Scr_ParamError(2, (int)v10);
    }
  }
  v3[25] = 0;
  v3[15] = 0;
  v3[16] = 0;
  v3[17] = 0;
  v3[18] = 0;
  v3[23] = 0;
  v3[24] = 0;
  v3[26] = 0;
  *v3 = 3;
  result = v12;
  v3[14] = v12;
  v3[12] = v5;
  v3[13] = v6;
  return result;
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004B6C0) --------------------------------------------------------
int __cdecl sub_4B6C0(int a1, int a2, const char *a3)
{
  int v3; // eax
  int v4; // esi
  char *v5; // eax
  int *v6; // ebx
  char *v8; // eax
  char *v10; // eax
  char *v11; // eax
  int v12; // edi
  int v13; // esi
  int v14; // eax
  char *v15; // eax
  int v16; // eax
  char *v17; // eax
  int result; // eax
  int v19; // [esp+14h] [ebp-44h]
  int v20; // [esp+18h] [ebp-40h]
  int v21; // [esp+1Ch] [ebp-3Ch]

  v3 = Scr_GetNumParam();
  v4 = v3;
  if ( v3 != 3 && v3 != 5 )
  {
    v5 = va("USAGE: <hudelem> %s(time_in_seconds, total_clock_time_in_seconds, shadername[, width, height]);\n", a3);
    Scr_Error((int)v5);
  }
  v6 = &g_hudelems[31 * a1];
  _FST7 = Scr_GetFloat(0) * 1000.0;
  __asm { frndint }
  v20 = (int)(double)_FST7;
  if ( v20 <= 0 && a2 != 9 )
  {
    v8 = va("time %g should be > 0", (double)((long double)v20 * 0.001));
    Scr_ParamError(0, (int)v8);
  }
  _FST7 = Scr_GetFloat(1) * 1000.0;
  __asm { frndint }
  v19 = (int)(double)_FST7;
  if ( v19 <= 0 )
  {
    v10 = va("duration %g should be > 0", (double)((long double)v19 * 0.001));
    Scr_ParamError(1, (int)v10);
  }
  v11 = (char *)Scr_GetString(2);
  v21 = G_ShaderIndex(v11);
  if ( v4 == 3 )
  {
    v12 = 0;
    v13 = 0;
  }
  else
  {
    v14 = Scr_GetInt(3);
    v12 = v14;
    if ( v14 < 0 )
    {
      v15 = va("width %i < 0", v14);
      Scr_ParamError(3, (int)v15);
    }
    v16 = Scr_GetInt(4);
    v13 = v16;
    if ( v16 < 0 )
    {
      v17 = va("height %i < 0", v16);
      Scr_ParamError(4, (int)v17);
    }
  }
  v6[25] = 0;
  v6[15] = 0;
  v6[16] = 0;
  v6[17] = 0;
  v6[18] = 0;
  v6[26] = 0;
  *v6 = a2;
  v6[23] = level[122] + v20;
  v6[24] = v19;
  result = v21;
  v6[14] = v21;
  v6[12] = v12;
  v6[13] = v13;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004B8E4) --------------------------------------------------------
__int16 __cdecl sub_4B8E4(int a1)
{
  char *v1; // eax
  int *v2; // ebx
  __int16 result; // ax
  int v5; // esi
  char *v6; // eax
  __int16 v7; // [esp+26h] [ebp-22h]

  if ( Scr_GetNumParam() != 1 )
  {
    v1 = va("USAGE: <hudelem> %s(time_in_seconds);\n", "setTimer");
    Scr_Error((int)v1);
  }
  v2 = &g_hudelems[31 * a1];
  _FST7 = Scr_GetFloat(0) * 1000.0;
  __asm { frndint }
  result = v7 | 0xC00;
  v5 = (int)(double)_FST7;
  if ( v5 <= 0 )
  {
    v6 = va("time %g should be > 0", (double)((long double)v5 * 0.001));
    result = Scr_ParamError(0, (int)v6);
  }
  v2[25] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 0;
  v2[24] = 0;
  v2[26] = 0;
  *v2 = 4;
  v2[23] = level[122] + v5;
  return result;
}
// 4B961: variable 'v7' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004BA04) --------------------------------------------------------
int __cdecl sub_4BA04(int a1)
{
  char *v1; // eax
  int *v3; // ebx
  int result; // eax

  if ( Scr_GetNumParam() != 1 )
  {
    v1 = va("USAGE: <hudelem> %s(time_in_seconds);\n", "setTimerUp");
    Scr_Error((int)v1);
  }
  _FST7 = Scr_GetFloat(0) * 1000.0;
  v3 = &g_hudelems[31 * a1];
  __asm { frndint }
  v3[25] = 0;
  v3[12] = 0;
  v3[13] = 0;
  v3[14] = 0;
  v3[15] = 0;
  v3[16] = 0;
  v3[17] = 0;
  v3[18] = 0;
  v3[24] = 0;
  v3[26] = 0;
  *v3 = 5;
  result = level[122] + (int)(double)_FST7;
  v3[23] = result;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004BAF4) --------------------------------------------------------
__int16 __cdecl sub_4BAF4(int a1)
{
  char *v1; // eax
  int *v2; // ebx
  __int16 result; // ax
  int v5; // esi
  char *v6; // eax
  __int16 v7; // [esp+26h] [ebp-22h]

  if ( Scr_GetNumParam() != 1 )
  {
    v1 = va("USAGE: <hudelem> %s(time_in_seconds);\n", "setTenthsTimer");
    Scr_Error((int)v1);
  }
  v2 = &g_hudelems[31 * a1];
  _FST7 = Scr_GetFloat(0) * 1000.0;
  __asm { frndint }
  result = v7 | 0xC00;
  v5 = (int)(double)_FST7;
  if ( v5 <= 0 )
  {
    v6 = va("time %g should be > 0", (double)((long double)v5 * 0.001));
    result = Scr_ParamError(0, (int)v6);
  }
  v2[25] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 0;
  v2[24] = 0;
  v2[26] = 0;
  *v2 = 6;
  v2[23] = level[122] + v5;
  return result;
}
// 4BB71: variable 'v7' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004BC14) --------------------------------------------------------
__int16 __cdecl sub_4BC14(int a1)
{
  char *v1; // eax
  int *v2; // ebx
  __int16 result; // ax
  int v5; // esi
  char *v6; // eax
  __int16 v7; // [esp+26h] [ebp-22h]

  if ( Scr_GetNumParam() != 1 )
  {
    v1 = va("USAGE: <hudelem> %s(time_in_seconds);\n", "setTenthsTimerUp");
    Scr_Error((int)v1);
  }
  v2 = &g_hudelems[31 * a1];
  _FST7 = Scr_GetFloat(0) * 1000.0;
  __asm { frndint }
  result = v7 | 0xC00;
  v5 = (int)(double)_FST7;
  if ( v5 <= 0 )
  {
    v6 = va("time %g should be > 0", (double)((long double)v5 * 0.001));
    result = Scr_ParamError(0, (int)v6);
  }
  v2[25] = 0;
  v2[12] = 0;
  v2[13] = 0;
  v2[14] = 0;
  v2[15] = 0;
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 0;
  v2[24] = 0;
  v2[26] = 0;
  *v2 = 7;
  v2[23] = level[122] + v5;
  return result;
}
// 4BC91: variable 'v7' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004BD34) --------------------------------------------------------
int __cdecl sub_4BD34(int a1)
{
  int *v1; // ebx
  char *v2; // eax
  int v3; // esi
  int v4; // edx
  int result; // eax
  float v6; // [esp+1Ch] [ebp-1Ch]

  v1 = &g_hudelems[31 * a1];
  if ( Scr_GetNumParam() != 3 )
    Scr_Error((int)"hudelem scaleOverTime(time_in_seconds, new_width, new_height)");
  v6 = Scr_GetFloat(0);
  if ( v6 <= 0.0 )
  {
    v2 = va("scale time %g <= 0", v6);
LABEL_7:
    Scr_ParamError(0, (int)v2);
    goto LABEL_8;
  }
  if ( v6 > 60.0 )
  {
    v2 = va("scale time %g > 60", v6);
    goto LABEL_7;
  }
LABEL_8:
  v3 = Scr_GetInt(1);
  v4 = Scr_GetInt(2);
  v1[17] = level[122];
  v1[18] = (int)(v6 * 1000.0 + 0.5);
  v1[15] = v1[12];
  result = v1[13];
  v1[16] = result;
  v1[12] = v3;
  v1[13] = v4;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004BE38) --------------------------------------------------------
int __cdecl HudElem_GetMethod(char **a1)
{
  unsigned int v1; // edi
  int v2; // esi
  const char *v3; // ebx
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  s1 = *a1;
  do
  {
    v3 = (&off_749B4)[v2];
    if ( !strcmp(s1, v3) )
    {
      *a1 = (char *)v3;
      return *(int *)((char *)&off_749B8 + v2 * 4);
    }
    v2 += 2;
    ++v1;
  }
  while ( v1 <= 0xD );
  return 0;
}
// 749B4: using guessed type char *off_749B4;
// 749B8: using guessed type int (__cdecl *off_749B8)(int);

//----- (0004BE8C) --------------------------------------------------------
int __cdecl HudElem_UpdateClient(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int *v4; // edx
  int *v5; // edi
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  unsigned int v10; // [esp+24h] [ebp-4h]

  result = a3;
  if ( (a3 & 1) != 0 )
    _bzero(a1 + 1230, 0xD90u);
  if ( (a3 & 2) != 0 )
    _bzero(a1 + 362, 0xD90u);
  v9 = 0;
  v8 = 0;
  v4 = &g_hudelems;
  v10 = 0;
  v7 = 362;
  v6 = 1230;
  do
  {
    if ( *v4 )
    {
      result = v4[29];
      if ( !result || result == a1[2143] )
      {
        result = v4[28];
        if ( result == 1023 || result == a2 )
        {
          if ( v4[30] )
          {
            result = a3;
            if ( (a3 & 1) != 0 )
            {
              v5 = &a1[v6];
              v6 += 28;
              if ( ++v9 <= 31 )
                goto LABEL_17;
            }
          }
          else if ( (a3 & 2) != 0 )
          {
            v5 = &a1[v7];
            v7 += 28;
            if ( ++v8 <= 31 )
            {
LABEL_17:
              qmemcpy(v5, v4, 0x70u);
              goto LABEL_18;
            }
          }
        }
      }
    }
LABEL_18:
    ++v10;
    v4 += 31;
  }
  while ( v10 <= 0x3FF );
  return result;
}
// 16F0E0: using guessed type int g_hudelems;

//----- (0004BF84) --------------------------------------------------------
void GScr_AddFieldsForHudElems()
{
  unsigned __int16 v0; // si
  int *v1; // ebx
  unsigned int v2; // eax

  v0 = g_scr_data[107];
  v1 = (int *)&off_744E0;
  if ( "x" )
  {
    do
    {
      v2 = v1[2];
      if ( v2 <= 5 || v2 <= 8 && v2 >= 7 )
        Scr_AddClassField(v0, *v1, (-858993459 * ((char *)v1 - (char *)&off_744E0)) >> 2);
      v1 += 5;
    }
    while ( *v1 );
  }
}
// 744E0: using guessed type char *off_744E0;

//----- (0004BFEC) --------------------------------------------------------
int __cdecl Scr_GetHudElemField(int a1, int a2)
{
  int (__cdecl *v2)(int *, int); // eax
  int result; // eax

  v2 = (int (__cdecl *)(int *, int))dword_744F0[5 * a2];
  if ( v2 )
    result = v2(&g_hudelems[31 * a1], a2);
  else
    result = Scr_GetGenericField((int)&g_hudelems[31 * a1], dword_744E8[5 * a2], dword_744E4[5 * a2]);
  return result;
}
// 744E4: using guessed type int dword_744E4[];
// 744E8: using guessed type int dword_744E8[];
// 744F0: using guessed type int dword_744F0[];

//----- (0004C044) --------------------------------------------------------
void __cdecl Scr_SetHudElemField(int a1, int a2)
{
  void (__cdecl *v2)(int *, int); // eax

  v2 = (void (__cdecl *)(int *, int))dword_744EC[5 * a2];
  if ( v2 )
    v2(&g_hudelems[31 * a1], a2);
  else
    Scr_SetGenericField((int)&g_hudelems[31 * a1], dword_744E8[5 * a2], dword_744E4[5 * a2]);
}
// 744E4: using guessed type int dword_744E4[];
// 744E8: using guessed type int dword_744E8[];
// 744EC: using guessed type int dword_744EC[];

//----- (0004C0A0) --------------------------------------------------------
int __cdecl Scr_FreeHudElemConstStrings(int a1)
{
  char **v1; // ebx
  int result; // eax

  v1 = &off_744E0;
  if ( "x" )
  {
    do
    {
      if ( v1[2] == (_BYTE *)&dword_0 + 3 )
        result = Scr_SetString((int)&v1[1][a1], 0);
      v1 += 5;
    }
    while ( *v1 );
  }
  return result;
}
// 0: using guessed type int dword_0;
// 744E0: using guessed type char *off_744E0;

//----- (0004C0EC) --------------------------------------------------------
int __cdecl HudElem_ClientDisconnect(int *a1)
{
  int *v1; // esi
  int *v2; // edi
  int v3; // ebx
  int result; // eax
  unsigned int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  v1 = g_hudelems;
  v2 = &g_hudelems[28];
  v3 = 0;
  do
  {
    if ( g_hudelems[v3] )
    {
      result = *a1;
      if ( *v2 == *a1 )
      {
        result = Scr_FreeHudElem((int)v1);
        g_hudelems[v3] = 0;
      }
    }
    v1 += 31;
    v2 += 31;
    v3 += 31;
    ++v5;
  }
  while ( v5 <= 0x3FF );
  return result;
}

//----- (0004C150) --------------------------------------------------------
void HudElem_DestroyAll()
{
  unsigned int v0; // edi
  int *v1; // esi
  int v2; // ebx

  v0 = 0;
  v1 = g_hudelems;
  v2 = 0;
  do
  {
    if ( g_hudelems[v2] )
    {
      Scr_FreeHudElem((int)v1);
      g_hudelems[v2] = 0;
    }
    v1 += 31;
    v2 += 31;
    ++v0;
  }
  while ( v0 <= 0x3FF );
  _bzero(g_hudelems, 0x1F000u);
}

//----- (0004C1AC) --------------------------------------------------------
int __cdecl sub_4C1AC(unsigned __int8 *a1)
{
  float v2[3]; // [esp+Ch] [ebp-Ch] BYREF

  v2[0] = (long double)a1[28] * 0.0039215689;
  v2[1] = (long double)a1[29] * 0.0039215689;
  v2[2] = 0.0039215689 * (long double)a1[30];
  return Scr_AddVector((int)v2);
}

//----- (0004C1FC) --------------------------------------------------------
int __cdecl sub_4C1FC(int a1)
{
  long double v1; // fst7
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  long double v9; // fst7
  int result; // eax

  v1 = Scr_GetFloat(0);
  v3 = v1 > 1.0;
  v4 = 0;
  v5 = 1.0 == v1;
  if ( (v2 & 0x45) == 1 || v1 >= 0.0 )
  {
    v6 = v1 > 1.0;
    v7 = 0;
    v8 = 1.0 == v1;
    if ( (v2 & 0x45) == 1 )
      v9 = 255.0;
    else
      v9 = v1 * 255.0;
  }
  else
  {
    v9 = 0.0;
  }
  result = a1;
  *(_BYTE *)(a1 + 31) = (int)(v9 + 0.5);
  return result;
}
// 4C212: variable 'v2' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0004C27C) --------------------------------------------------------
int __cdecl sub_4C27C(int a1)
{
  float v2; // [esp-10h] [ebp-28h]

  v2 = (long double)*(unsigned __int8 *)(a1 + 31) * 0.0039215689;
  return Scr_AddFloat(v2);
}

//----- (0004C2A8) --------------------------------------------------------
int __cdecl sub_4C2A8(int a1)
{
  char *v1; // eax
  int result; // eax
  float v3; // [esp+14h] [ebp-14h]

  v3 = Scr_GetFloat(0);
  if ( v3 <= 0.0 )
  {
    v1 = va("font scale was %g; should be > 0", v3);
    Scr_Error((int)v1);
  }
  result = a1;
  *(float *)(a1 + 12) = v3;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0004C2F8) --------------------------------------------------------
int __cdecl sub_4C2F8(int a1, int a2)
{
  return sub_4AF80(a1, (int)&(&off_744E0)[5 * a2], (int)off_7DE04, 3);
}
// 744E0: using guessed type char *off_744E0;
// 7DE04: using guessed type char *off_7DE04[9];

//----- (0004C320) --------------------------------------------------------
int __cdecl sub_4C320(int a1, int a2)
{
  return Scr_AddString((int)off_7DE04[*(_DWORD *)(dword_744E4[5 * a2] + a1)]);
}
// 744E4: using guessed type int dword_744E4[];
// 7DE04: using guessed type char *off_7DE04[9];

//----- (0004C350) --------------------------------------------------------
int __cdecl sub_4C350(int a1, int a2)
{
  return sub_4AF80(a1, (int)&(&off_744E0)[5 * a2], (int)off_7DE10, 3);
}
// 744E0: using guessed type char *off_744E0;
// 7DE10: using guessed type char *off_7DE10[6];

//----- (0004C378) --------------------------------------------------------
int __cdecl sub_4C378(int a1, int a2)
{
  return Scr_AddString((int)off_7DE10[*(_DWORD *)(dword_744E4[5 * a2] + a1)]);
}
// 744E4: using guessed type int dword_744E4[];
// 7DE10: using guessed type char *off_7DE10[6];

//----- (0004C3A8) --------------------------------------------------------
int __cdecl sub_4C3A8(int a1, int a2)
{
  return sub_4AF80(a1, (int)&(&off_744E0)[5 * a2], (int)off_7DE1C, 3);
}
// 744E0: using guessed type char *off_744E0;
// 7DE1C: using guessed type char *off_7DE1C[3];

//----- (0004C3D0) --------------------------------------------------------
int __cdecl sub_4C3D0(int a1, int a2)
{
  return Scr_AddString((int)off_7DE1C[*(_DWORD *)(dword_744E4[5 * a2] + a1)]);
}
// 744E4: using guessed type int dword_744E4[];
// 7DE1C: using guessed type char *off_7DE1C[3];

//----- (0004C400) --------------------------------------------------------
int __cdecl sub_4C400(int a1, int a2)
{
  char *v2; // eax
  int v3; // edx
  int result; // eax

  v2 = (char *)Scr_GetIString(0);
  v3 = G_LocalizedStringIndex(v2);
  result = dword_744E4[5 * a2];
  *(_DWORD *)(result + a1) = v3;
  return result;
}
// 744E4: using guessed type int dword_744E4[];

//----- (0004C43C) --------------------------------------------------------
int __cdecl sub_4C43C(int a1, int a2)
{
  int v2; // edx
  int result; // eax

  v2 = Scr_GetBool(0);
  result = dword_744E4[5 * a2];
  *(_DWORD *)(result + a1) = v2;
  return result;
}
// 744E4: using guessed type int dword_744E4[];

//----- (0004C470) --------------------------------------------------------
int *__cdecl HudElem_Alloc(int a1, int a2)
{
  unsigned int v2; // edx
  int *v3; // eax
  int *v4; // ebx
  int v5; // ecx

  v2 = 0;
  v3 = g_hudelems;
  v4 = g_hudelems;
  v5 = 0;
  do
  {
    if ( !g_hudelems[v5] )
    {
      v3[3] = 1065353216;
      v3[27] = 0;
      v3[25] = 0;
      *v3 = 1;
      v3[1] = 0;
      v3[2] = 0;
      v3[4] = 0;
      v3[5] = 0;
      v3[6] = 0;
      v3[7] = -1;
      v3[8] = 0;
      v3[9] = 0;
      v3[10] = 0;
      v3[11] = 0;
      v3[30] = 1;
      v3[12] = 0;
      v3[13] = 0;
      v3[14] = 0;
      v3[15] = 0;
      v3[16] = 0;
      v3[17] = 0;
      v3[18] = 0;
      v3[23] = 0;
      v3[24] = 0;
      v3[26] = 0;
      g_hudelems[v5 + 28] = a1;
      g_hudelems[v5 + 29] = a2;
      return v4;
    }
    v3 += 31;
    v4 += 31;
    v5 += 31;
    ++v2;
  }
  while ( v2 <= 0x3FF );
  return 0;
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C570) --------------------------------------------------------
int __cdecl HudElem_Free(_DWORD *a1)
{
  int result; // eax

  result = Scr_FreeHudElem((int)a1);
  *a1 = 0;
  return result;
}

//----- (0004C590) --------------------------------------------------------
int __cdecl sub_4C590(int a1)
{
  char *v1; // eax
  int v2; // ebx
  int result; // eax

  v1 = (char *)Scr_GetIString(0);
  v2 = 31 * a1;
  g_hudelems[v2 + 25] = 0;
  g_hudelems[v2 + 12] = 0;
  g_hudelems[v2 + 13] = 0;
  g_hudelems[v2 + 14] = 0;
  g_hudelems[v2 + 15] = 0;
  g_hudelems[v2 + 16] = 0;
  g_hudelems[v2 + 17] = 0;
  g_hudelems[v2 + 18] = 0;
  g_hudelems[v2 + 23] = 0;
  g_hudelems[v2 + 24] = 0;
  g_hudelems[v2 + 26] = 0;
  g_hudelems[v2] = 1;
  result = G_LocalizedStringIndex(v1);
  g_hudelems[v2 + 26] = result;
  return result;
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C644) --------------------------------------------------------
int __cdecl sub_4C644(int a1)
{
  return sub_4B6C0(a1, 8, "setClock");
}

//----- (0004C664) --------------------------------------------------------
int __cdecl sub_4C664(int a1)
{
  return sub_4B6C0(a1, 9, "setClockUp");
}

//----- (0004C684) --------------------------------------------------------
int __cdecl sub_4C684(int a1)
{
  long double v1; // fst7
  int result; // eax

  v1 = Scr_GetFloat(0);
  result = 31 * a1;
  *(float *)&g_hudelems[result + 25] = v1;
  g_hudelems[result + 12] = 0;
  g_hudelems[result + 13] = 0;
  g_hudelems[result + 14] = 0;
  g_hudelems[result + 15] = 0;
  g_hudelems[result + 16] = 0;
  g_hudelems[result + 17] = 0;
  g_hudelems[result + 18] = 0;
  g_hudelems[result + 23] = 0;
  g_hudelems[result + 24] = 0;
  g_hudelems[result + 26] = 0;
  g_hudelems[result] = 2;
  return result * 4;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C720) --------------------------------------------------------
int __cdecl sub_4C720(int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  float v5; // [esp+Ch] [ebp-1Ch]

  v1 = &g_hudelems[31 * a1];
  v5 = Scr_GetFloat(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v3 = va("fade time %g > 60", v5);
      Scr_ParamError(0, (int)v3);
    }
  }
  else
  {
    v2 = va("fade time %g <= 0", v5);
    Scr_ParamError(0, (int)v2);
  }
  v1[9] = level[122];
  v1[10] = (int)(v5 * 1000.0 + 0.5);
  result = v1[7];
  v1[8] = result;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C7EC) --------------------------------------------------------
int __cdecl sub_4C7EC(int a1)
{
  int *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  float v5; // [esp+Ch] [ebp-1Ch]

  v1 = &g_hudelems[31 * a1];
  v5 = Scr_GetFloat(0);
  if ( v5 > 0.0 )
  {
    if ( v5 > 60.0 )
    {
      v3 = va("move time %g > 60", v5);
      Scr_ParamError(0, (int)v3);
    }
  }
  else
  {
    v2 = va("move time %g <= 0", v5);
    Scr_ParamError(0, (int)v2);
  }
  v1[21] = level[122];
  v1[22] = (int)(v5 * 1000.0 + 0.5);
  v1[19] = v1[1];
  result = v1[2];
  v1[20] = result;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C8C0) --------------------------------------------------------
int __cdecl sub_4C8C0(int a1)
{
  int result; // eax

  result = 31 * a1;
  g_hudelems[result + 3] = 1065353216;
  g_hudelems[result + 27] = 0;
  g_hudelems[result + 25] = 0;
  g_hudelems[result] = 1;
  g_hudelems[result + 1] = 0;
  g_hudelems[result + 2] = 0;
  g_hudelems[result + 4] = 0;
  g_hudelems[result + 5] = 0;
  g_hudelems[result + 6] = 0;
  g_hudelems[result + 7] = -1;
  g_hudelems[result + 8] = 0;
  g_hudelems[result + 9] = 0;
  g_hudelems[result + 10] = 0;
  g_hudelems[result + 11] = 0;
  g_hudelems[result + 30] = 1;
  g_hudelems[result + 12] = 0;
  g_hudelems[result + 13] = 0;
  g_hudelems[result + 14] = 0;
  g_hudelems[result + 15] = 0;
  g_hudelems[result + 16] = 0;
  g_hudelems[result + 17] = 0;
  g_hudelems[result + 18] = 0;
  g_hudelems[result + 23] = 0;
  g_hudelems[result + 24] = 0;
  g_hudelems[result + 26] = 0;
  return result * 4;
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (0004C9D0) --------------------------------------------------------
int __cdecl sub_4C9D0(int a1)
{
  int result; // eax

  result = Scr_FreeHudElem((int)&g_hudelems[31 * a1]);
  g_hudelems[31 * a1] = 0;
  return result;
}

//----- (0004CA10) --------------------------------------------------------
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // ebx
  int v8; // eax
  int v9; // edx
  int v10; // edi
  int v11; // esi
  int v12; // ebx
  int v13; // esi
  int v14; // esi
  int v15; // eax
  int v17; // eax
  int v18; // [esp+18h] [ebp-20h]
  int v19; // [esp+1Ch] [ebp-1Ch]
  int v20; // [esp+20h] [ebp-18h]
  int v21; // [esp+24h] [ebp-14h]
  int v22; // [esp+28h] [ebp-10h]
  int v23; // [esp+2Ch] [ebp-Ch]
  int v24; // [esp+30h] [ebp-8h]
  int v25; // [esp+34h] [ebp-4h]

  v25 = BG_AmmoForWeapon(a2);
  v24 = BG_ClipForWeapon(a2);
  v23 = 0;
  v4 = *(_DWORD *)(a1 + 344);
  v22 = *(_DWORD *)(4 * v25 + v4 + 268);
  v21 = *(_DWORD *)(v4 + 524 + 4 * v24);
  *(_DWORD *)(4 * v25 + v4 + 268) = v22 + a3;
  if ( BG_WeaponIsClipOnly(a2) )
  {
    BG_GivePlayerWeapon(*(_DWORD *)(a1 + 344), a2);
    v23 = 1;
  }
  if ( !a4 && !v23 )
    goto LABEL_13;
  v5 = *(_DWORD *)(a1 + 344);
  v20 = v5;
  v19 = BG_AmmoForWeapon(a2);
  v18 = BG_ClipForWeapon(a2);
  if ( a2 > 0 && a2 <= BG_GetNumWeapons() )
  {
    v6 = v5 + 524;
    v7 = *(_DWORD *)(4 * v18 + v5 + 524);
    v8 = BG_GetAmmoClipSize(v18) - v7;
    v9 = *(_DWORD *)(4 * v19 + v20 + 268);
    if ( v8 > v9 )
      v8 = *(_DWORD *)(4 * v19 + v20 + 268);
    if ( v8 )
    {
      *(_DWORD *)(4 * v19 + v20 + 268) = v9 - v8;
      *(_DWORD *)(4 * v18 + v6) += v8;
    }
  }
  if ( v23 )
  {
    v10 = 4 * v25;
    *(_DWORD *)(4 * v25 + *(_DWORD *)(a1 + 344) + 268) = 0;
  }
  else
  {
LABEL_13:
    v11 = *(_DWORD *)(a1 + 344) + 268;
    v10 = 4 * v25;
    if ( *(_DWORD *)(4 * v25 + v11) > BG_GetAmmoTypeMax(v25) )
      *(_DWORD *)(v10 + *(_DWORD *)(a1 + 344) + 268) = BG_GetAmmoTypeMax(v25);
  }
  v12 = 4 * v24;
  v13 = *(_DWORD *)(a1 + 344) + 524;
  if ( *(_DWORD *)(4 * v24 + v13) > BG_GetAmmoClipSize(v24) )
    *(_DWORD *)(v12 + *(_DWORD *)(a1 + 344) + 524) = BG_GetAmmoClipSize(v24);
  if ( *(int *)(BG_GetInfoForWeapon(a2) + 440) >= 0 )
  {
    v14 = BG_GetMaxPickupableAmmo(*(_DWORD *)(a1 + 344), a2);
    if ( v14 < 0 )
    {
      if ( BG_WeaponIsClipOnly(a2) )
      {
        *(_DWORD *)(v12 + *(_DWORD *)(a1 + 344) + 524) += v14;
        v15 = *(_DWORD *)(a1 + 344) + 524;
        if ( *(int *)(v12 + v15) <= 0 )
        {
          *(_DWORD *)(v12 + v15) = 0;
          BG_TakePlayerWeapon(*(_DWORD *)(a1 + 344), a2);
          return 0;
        }
      }
      else
      {
        *(_DWORD *)(v10 + *(_DWORD *)(a1 + 344) + 268) += v14;
        v17 = *(_DWORD *)(a1 + 344) + 268;
        if ( *(int *)(v10 + v17) < 0 )
          *(_DWORD *)(v10 + v17) = 0;
      }
    }
  }
  return *(_DWORD *)(v10 + *(_DWORD *)(a1 + 344) + 268) - v22 + *(_DWORD *)(v12 + *(_DWORD *)(a1 + 344) + 524) - v21;
}

//----- (0004CCD8) --------------------------------------------------------
int __cdecl sub_4CCD8(int a1, int *a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int result; // eax
  int v23; // eax
  int v24; // eax
  int v25; // edx
  int *v26; // eax
  int v27; // esi
  int v28; // ebx
  int v29; // eax
  int v30; // edx
  char *v31; // eax
  char *v32; // eax
  int v33; // ebx
  char *v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  int v39; // eax
  int v40; // [esp+14h] [ebp-34h]
  _DWORD *v41; // [esp+18h] [ebp-30h]
  int *v42; // [esp+1Ch] [ebp-2Ch]
  int v43; // [esp+20h] [ebp-28h]
  int v44; // [esp+28h] [ebp-20h]
  int v45; // [esp+2Ch] [ebp-1Ch]
  int v46; // [esp+2Ch] [ebp-1Ch]
  float v47[3]; // [esp+30h] [ebp-18h] BYREF
  int v48; // [esp+3Ch] [ebp-Ch]
  __int16 v49; // [esp+40h] [ebp-8h]
  __int16 v50; // [esp+42h] [ebp-6h]
  int v51; // [esp+44h] [ebp-4h]

  v42 = 0;
  v43 = *(_DWORD *)(*(_DWORD *)(a1 + 664) + 36);
  v41 = (_DWORD *)BG_GetInfoForWeapon(v43);
  v4 = *(_DWORD *)(a1 + 592);
  if ( v4 < 0 )
  {
    v45 = 0;
    goto LABEL_19;
  }
  if ( !v4 )
  {
    v5 = v41[193];
    v6 = v41[192];
    v7 = v5;
    if ( v5 < v6 )
    {
      v5 = v41[192];
      v6 = v7;
    }
    if ( v5 || v6 )
    {
      if ( v5 >= 0 )
      {
        if ( v5 == v6 )
          *(_DWORD *)(a1 + 592) = v6;
        else
          *(_DWORD *)(a1 + 592) = v6 + rand() % (v5 - v6);
        v10 = a1;
        if ( *(int *)(a1 + 592) > 0 )
          goto LABEL_16;
      }
      else
      {
        v10 = a1;
      }
      *(_DWORD *)(v10 + 592) = 0;
    }
    else
    {
      v8 = rand();
      v9 = BG_ClipForWeapon(v43);
      v51 = BG_GetAmmoClipSize(v9) - 1;
      v49 = v50 | 0xC00;
      v48 = (int)(((long double)v8 * -4.6566129e-10 + 1.0) * 0.5 * (long double)v51 + 0.5);
      *(_DWORD *)(a1 + 592) = v48 + 1;
    }
  }
LABEL_16:
  v11 = BG_AmmoForWeapon(v43);
  if ( *(_DWORD *)(a1 + 592) > BG_GetAmmoTypeMax(v11) )
  {
    v12 = BG_AmmoForWeapon(v43);
    *(_DWORD *)(a1 + 592) = BG_GetAmmoTypeMax(v12);
  }
  v45 = *(_DWORD *)(a1 + 592);
LABEL_19:
  v13 = *(_DWORD *)(a1 + 716);
  if ( v13 >= 0 )
  {
    if ( !v13 )
    {
      if ( *(int *)(a1 + 592) >= 0 )
      {
        v14 = BG_ClipForWeapon(v43);
        v15 = BG_GetAmmoClipSize(v14);
        *(_DWORD *)(a1 + 716) = v15;
        v16 = *(_DWORD *)(a1 + 592);
        if ( v15 > v16 )
          *(_DWORD *)(a1 + 716) = v16;
        v17 = *(_DWORD *)(a1 + 592) - *(_DWORD *)(a1 + 716);
        *(_DWORD *)(a1 + 592) = v17;
        v45 = v17;
      }
      else
      {
        *(_DWORD *)(a1 + 716) = 0;
      }
    }
    v18 = BG_ClipForWeapon(v43);
    if ( *(_DWORD *)(a1 + 716) > BG_GetAmmoClipSize(v18) )
    {
      v19 = BG_ClipForWeapon(v43);
      *(_DWORD *)(a1 + 716) = BG_GetAmmoClipSize(v19);
    }
    v44 = *(_DWORD *)(a1 + 716);
  }
  else
  {
    v44 = 0;
  }
  if ( !Com_BitCheck(a2[86] + 780, v43) )
  {
    v20 = a2[86];
    if ( *(_DWORD *)(v20 + 176) )
    {
      if ( !Com_BitCheck(v20 + 780, *(_DWORD *)(v20 + 176)) )
        return 0;
      if ( !BG_IsPlayerWeaponInSlot(a2[86], *(_DWORD *)(a2[86] + 176), 1) )
      {
        v21 = BG_GetInfoForWeapon(*(_DWORD *)(a2[86] + 176));
        if ( !BG_GetStackSlotForWeapon(a2[86], *(_DWORD *)(a2[86] + 176), *(_DWORD *)(v21 + 120))
          && !BG_GetEmptySlotForWeapon(a2[86], v43) )
        {
          Com_Printf("WARNING: cannot swap out a debug weapon (can result from too many weapons given to the player)\n");
          return 0;
        }
      }
    }
    if ( BG_GetEmptySlotForWeapon(a2[86], v43) )
      goto LABEL_54;
    v23 = BG_GetInfoForWeapon(*(_DWORD *)(a2[86] + 176));
    if ( BG_GetStackSlotForWeapon(a2[86], v43, *(_DWORD *)(v23 + 120)) )
      goto LABEL_54;
    v24 = BG_GetInfoForWeapon(*(_DWORD *)(a2[86] + 176));
    v25 = v41[30];
    if ( v25 == *(_DWORD *)(v24 + 120) )
    {
      v26 = (int *)Drop_Weapon(a2, *(_DWORD *)(a2[86] + 176), 0);
    }
    else
    {
      if ( (unsigned int)(v25 - 3) > 2 )
      {
        v27 = 1;
        while ( 1 )
        {
          v40 = *(char *)(v27 + a2[86] + 788);
          v28 = BG_AmmoForWeapon(v43);
          v29 = BG_ClipForWeapon(v43);
          v30 = a2[86];
          if ( !*(_DWORD *)(v30 + 268 + 4 * v28) && !*(_DWORD *)(v30 + 524 + 4 * v29) )
            break;
          if ( ++v27 > 2 )
            goto LABEL_50;
        }
        v42 = (int *)Drop_Weapon(a2, v40, 0);
LABEL_50:
        if ( v27 > 2 )
        {
          v31 = va("f \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"");
          trap_SendServerCommand((1024687629 * ((char *)a2 - (char *)g_entities)) >> 2, 0, (int)v31);
          return 0;
        }
        goto LABEL_52;
      }
      v26 = (int *)Drop_Weapon(a2, *(char *)(v41[30] + a2[86] + 788), 0);
    }
    v42 = v26;
LABEL_52:
    if ( !v42 )
      return 0;
    v47[0] = *(float *)(a1 + 308);
    v47[1] = *(float *)(a1 + 312);
    v47[2] = *(float *)(a1 + 316);
    G_SetOrigin((int)v42, v47);
    G_SetAngle((int)v42, (float *)(a1 + 320));
    trap_LinkEntity((int)v42);
LABEL_54:
    BG_GivePlayerWeapon(a2[86], v43);
    if ( !a4 )
    {
      v32 = va("a %i", v43);
      trap_SendServerCommand((1024687629 * ((char *)a2 - (char *)g_entities)) >> 2, 1, (int)v32);
    }
    if ( v44 >= 0 )
    {
      v37 = BG_ClipForWeapon(v43);
      if ( v44 > BG_GetAmmoClipSize(v37) )
      {
        v38 = BG_ClipForWeapon(v43);
        v45 += v44 - BG_GetAmmoClipSize(v38);
        v39 = BG_ClipForWeapon(v43);
        v44 = BG_GetAmmoClipSize(v39);
      }
      *(_DWORD *)(a2[86] + 524 + 4 * BG_ClipForWeapon(v43)) = v44;
    }
    Add_Ammo((int)a2, v43, v45, v44 == -1);
    goto LABEL_75;
  }
  *a3 = 148;
  v46 = v44 + v45;
  v33 = Add_Ammo((int)a2, v43, v46, 0);
  if ( v33 )
  {
    if ( BG_WeaponIsClipOnly(v43) )
      v34 = va(aFGamePickupCli, v41[2]);
    else
      v34 = va(aFGamePickupAmm, v41[2]);
    trap_SendServerCommand((1024687629 * ((char *)a2 - (char *)g_entities)) >> 2, 0, (int)v34);
  }
  if ( v33 != v46 )
  {
    v35 = *(_DWORD *)(a1 + 592) - v33;
    *(_DWORD *)(a1 + 592) = v35;
    if ( v35 > 0 )
      goto LABEL_83;
    v36 = *(_DWORD *)(a1 + 716) + v35;
    *(_DWORD *)(a1 + 716) = v36;
    *(_DWORD *)(a1 + 592) = -1;
    if ( v36 <= 0 )
      *(_DWORD *)(a1 + 716) = -1;
    if ( *(int *)(a1 + 592) > 0 || *(int *)(a1 + 716) > 0 )
    {
LABEL_83:
      if ( g_weaponAmmoPools[3] )
        return 0;
    }
  }
LABEL_75:
  if ( v42 )
    Scr_AddEntity(v42);
  else
    Scr_AddUndefined();
  Scr_AddEntity(a2);
  Scr_Notify((int *)a1, scr_const[73], 2);
  if ( (*(_BYTE *)(a1 + 376) & 8) != 0 )
    result = g_weaponRespawn[3];
  else
    result = -1;
  return result;
}
// 4D20F: conditional instruction was optimized away because of '%var_24.4==0'
// 4DD40: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 21DF80: using guessed type int g_entities[];

//----- (0004D400) --------------------------------------------------------
int __cdecl Pickup_Health(int *a1, int *a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  char *v11; // eax
  int v13; // [esp+18h] [ebp-10h]

  v2 = *(_DWORD *)(a1[166] + 28);
  if ( v2 == 5 || v2 == 100 )
    v3 = 2 * *(_DWORD *)(a2[86] + 252);
  else
    v3 = *(_DWORD *)(a2[86] + 252);
  if ( a1[148] )
    v4 = a1[148];
  else
    v4 = *(_DWORD *)(a1[166] + 28);
  v13 = a2[140];
  v5 = a2[86];
  v6 = (int)((long double)v4 * (long double)*(int *)(v5 + 252) * 0.0099999998) + v13;
  a2[140] = v6;
  if ( v6 > v3 )
    goto LABEL_19;
  v7 = (int)((long double)(100 * v6) / (long double)*(int *)(v5 + 252));
  if ( v7 > 0 )
  {
    if ( v7 > 100 )
      v7 = 100;
  }
  else
  {
    v7 = 1;
  }
  v8 = a2[86];
  v9 = (int)((long double)(100 * v13) / (long double)*(int *)(v8 + 252));
  if ( v9 <= 0 )
    v9 = 1;
  v10 = v4 + v9;
  if ( v10 > 100 )
    v10 = 100;
  if ( v7 != v10 )
  {
    v3 = *(_DWORD *)(v8 + 252) * v10 / 100;
LABEL_19:
    a2[140] = v3;
  }
  *(_DWORD *)(a2[86] + 244) = a2[140];
  v11 = va(aFGamePickupHea, v4);
  trap_SendServerCommand((1024687629 * ((char *)a2 - (char *)g_entities)) >> 2, 0, (int)v11);
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[73], 1);
  return -1;
}
// 21DF80: using guessed type int g_entities[];

//----- (0004D5CC) --------------------------------------------------------
void __cdecl Touch_Item(int a1, char *a2, int a3)
{
  _DWORD *v3; // eax
  int v4; // eax
  char *v5; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // edx
  unsigned int v9; // eax
  int v10; // eax
  char *v11; // eax
  char *v12; // [esp-24h] [ebp-4Ch]
  int v13; // [esp-20h] [ebp-48h]
  int v14; // [esp-20h] [ebp-48h]
  int v15; // [esp-20h] [ebp-48h]
  int v16[3]; // [esp+1Ch] [ebp-Ch] BYREF
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  v16[0] = 146;
  if ( *(_BYTE *)(a1 + 370) )
  {
    *(_BYTE *)(a1 + 370) = 0;
    v3 = (_DWORD *)*((_DWORD *)a2 + 86);
    if ( v3 )
    {
      if ( *((int *)a2 + 140) > 0 )
      {
        if ( BG_CanItemBeGrabbed(a1, v3, a3) )
        {
          v6 = *(_DWORD *)(a1 + 664);
          if ( *(_DWORD *)(v6 + 32) == 1 )
          {
            v7 = BG_GetInfoForWeapon(*(_DWORD *)(v6 + 36));
            G_LogPrintf("Weapon: %i %s\n", *(_DWORD *)a2, *(const char **)(v7 + 4));
          }
          else
          {
            G_LogPrintf("Item: %i %s\n", *(_DWORD *)a2, *(const char **)v6);
          }
          v8 = *(_DWORD **)(a1 + 664);
          v9 = v8[8];
          if ( v9 == 2 )
          {
            v10 = *(_DWORD *)(a1 + 592);
            if ( !v10 )
              v10 = v8[7];
            if ( Add_Ammo((int)a2, v8[9], v10, 0) )
            {
              if ( BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)(a1 + 664) + 36)) )
              {
                v14 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 664) + 36)) + 8);
                v11 = va(aFGamePickupCli, v14);
              }
              else
              {
                v15 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 664) + 36)) + 8);
                v11 = va(aFGamePickupAmm, v15);
              }
              trap_SendServerCommand((1024687629 * (a2 - (char *)g_entities)) >> 2, 0, (int)v11);
              Scr_AddEntity((int *)a2);
              Scr_Notify((int *)a1, scr_const[73], 1);
              JUMPOUT(0x4D87F);
            }
          }
          else if ( v9 > 2 )
          {
            if ( v9 == 3 )
              sub_4D870(a2, (int)&savedregs, a1);
          }
          else if ( v9 == 1 )
          {
            sub_4CCD8(a1, (int *)a2, v16, a3);
            JUMPOUT(0x4D87A);
          }
        }
        else if ( !a3 && *(_DWORD *)(a1 + 144) != *(_DWORD *)a2 )
        {
          v4 = *(_DWORD *)(a1 + 664);
          if ( *(_DWORD *)(v4 + 32) == 1 )
          {
            if ( Com_BitCheck(*((_DWORD *)a2 + 86) + 780, *(_DWORD *)(v4 + 36)) )
            {
              v13 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 664) + 36)) + 8);
              v5 = va(aFGamePickupCan, v13);
LABEL_12:
              trap_SendServerCommand((1024687629 * (a2 - (char *)g_entities)) >> 2, 0, (int)v5);
            }
            else
            {
              switch ( *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 664) + 36)) + 120) )
              {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  v5 = va(v12);
                  goto LABEL_12;
                default:
                  return;
              }
            }
          }
        }
      }
    }
  }
}
// 4D79D: control flows out of bounds to 4D87A
// 4D869: control flows out of bounds to 4D87F
// 4D6FB: variable 'v12' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (0004D870) --------------------------------------------------------
__int16 __usercall sub_4D870@<ax>(_DWORD *a1@<ebx>, int a2@<ebp>, int a3@<esi>)
{
  int v3; // eax
  int v4; // edi
  long double v5; // fst7
  __int16 v6; // fps
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double v14; // fst6
  long double v15; // fst7
  char v16; // fps^1
  long double v17; // fst6
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst6
  long double v22; // fst7
  int *v24; // [esp+0h] [ebp-10h]
  int *v25; // [esp+4h] [ebp-Ch]

  v3 = Pickup_Health(v24, v25);
  v4 = v3;
  if ( v3 )
  {
    if ( *(_BYTE *)(a3 + 366) )
    {
      *(_DWORD *)(a2 - 12) = 147;
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a3 + 366));
    }
    if ( *(_DWORD *)(a1[86] + 8484) )
      G_AddPredictableEvent((int)a1, *(_DWORD *)(a2 - 12), *(_DWORD *)(a3 + 140));
    else
      G_AddEvent(a1, *(_DWORD *)(a2 - 12), *(_DWORD *)(a3 + 140));
    v5 = *(float *)(a3 + 616);
    v7 = v5 > -1.0;
    v8 = 0;
    v9 = -1.0 == v5;
    LOBYTE(v3) = v6;
    BYTE1(v3) = HIBYTE(v6) & 0x44 ^ 0x40;
    if ( BYTE1(v3) )
    {
      v11 = v5 > 0.0;
      v12 = 0;
      v13 = 0.0 == v5;
      if ( (v10 & 0x45) == 64 )
      {
        v15 = 0.0;
      }
      else
      {
        v14 = *(float *)(a3 + 616);
        v15 = 0.0;
        *(_WORD *)(a2 - 4) = *(_WORD *)(a2 - 2) | 0xC00;
        *(_DWORD *)(a2 - 8) = (int)v14;
        v4 = *(_DWORD *)(a2 - 8);
      }
      v17 = *(float *)(a3 + 620);
      v18 = v17 < v15;
      v19 = 0;
      v20 = v17 == v15;
      if ( (v16 & 0x45) != 64 )
      {
        *(_DWORD *)(a2 - 8) = rand();
        v21 = (long double)*(int *)(a2 - 8) * -4.6566129e-10;
        v22 = (v21 + v21 - 1.0) * *(float *)(a3 + 620);
        *(_WORD *)(a2 - 4) = *(_WORD *)(a2 - 2) | 0xC00;
        *(_DWORD *)(a2 - 8) = (int)v22;
        v4 += *(_DWORD *)(a2 - 8);
        if ( v4 <= 0 )
          v4 = 1;
      }
      if ( (*(_BYTE *)(a3 + 380) & 0x10) != 0 )
        *(_DWORD *)(a3 + 388) = 1;
      *(_BYTE *)(a3 + 244) |= 1u;
      *(_BYTE *)(a3 + 381) |= 0x10u;
      *(_DWORD *)(a3 + 280) = 0;
      if ( v4 > 0 )
      {
        *(_DWORD *)(a3 + 508) = level[122] + 1000 * v4;
        *(_DWORD *)(a3 + 512) = RespawnItem;
      }
      else
      {
        *(_DWORD *)(a3 + 508) = 0;
        *(_DWORD *)(a3 + 512) = 0;
      }
      if ( (*(_BYTE *)(a3 + 380) & 0x10) != 0 )
      {
        *(_DWORD *)(a3 + 512) = G_FreeEntity;
        *(_DWORD *)(a3 + 508) = level[122] + 100;
      }
      LOWORD(v3) = trap_LinkEntity(a3);
    }
    else
    {
      *(_BYTE *)(a3 + 381) |= 0x10u;
      *(_BYTE *)(a3 + 9) |= 1u;
      *(_DWORD *)(a3 + 280) = 0;
      *(_DWORD *)(a3 + 392) = 1;
    }
  }
  return v3;
}
// 4D875: variable 'v24' is possibly undefined
// 4D875: variable 'v25' is possibly undefined
// 4D92B: variable 'v10' is possibly undefined
// 4D95F: variable 'v16' is possibly undefined

//----- (0004DA44) --------------------------------------------------------
int GetFreeCueSpot()
{
  long double v0; // fst7
  int v1; // eax
  int *v3; // ebx
  long double v4; // fst6
  float *v5; // esi
  int v6; // edi
  long double v7; // fst7
  char v8; // fps^1
  long double v9; // fst5
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  int *v13; // ebx
  long double v14; // [esp+18h] [ebp-30h]
  int v15; // [esp+38h] [ebp-10h]
  int v16; // [esp+3Ch] [ebp-Ch]
  int v17; // [esp+40h] [ebp-8h]
  int v18; // [esp+44h] [ebp-4h]

  v0 = 0.0;
  v16 = 0;
  v18 = 0;
  do
  {
    v1 = level[v18 + 1879];
    if ( !v1 )
      return v18;
    v3 = &g_entities[197 * v1];
    if ( !*((_BYTE *)v3 + 352) )
    {
      level[v18 + 1879] = 0;
      return v18;
    }
    v4 = 99999.0;
    v17 = 0;
    v15 = v18 + 1;
    if ( level[120] > 0 )
    {
      v5 = (float *)&g_entities[77];
      v6 = 0;
      do
      {
        if ( *(_DWORD *)(level[0] + v6 + 8428) == 2 && *(_DWORD *)(level[0] + v6 + 4) == 5 )
        {
          v14 = v0;
          v7 = VectorDistance(v5, (float *)v3 + 77);
          v9 = v7;
          v0 = v14;
          v10 = v9 < v4;
          v11 = 0;
          v12 = v9 == v4;
          if ( (v8 & 0x45) == 1 )
            v4 = v9;
        }
        ++v17;
        v5 += 197;
        v6 += 8900;
      }
      while ( v17 < level[120] );
    }
    if ( v4 > v0 )
    {
      v0 = v4;
      v16 = v18;
    }
    ++v18;
  }
  while ( v15 <= 31 );
  v13 = &g_entities[197 * level[v16 + 1879]];
  v13[128] = (int)G_FreeEntity;
  v13[127] = level[122] + 1;
  return v16;
}
// 4DB12: variable 'v8' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (0004DB98) --------------------------------------------------------
int __cdecl LaunchItem(int a1, float *a2, float *a3, int a4)
{
  int v4; // esi

  RegisterItem((-1431655765 * (a1 - (int)bg_itemlist)) >> 4, 1);
  v4 = G_Spawn();
  level[GetFreeCueSpot() + 1879] = (1024687629 * (v4 - (int)g_entities)) >> 2;
  *(_DWORD *)(v4 + 4) = 3;
  *(_DWORD *)(v4 + 140) = (-1431655765 * (a1 - (int)bg_itemlist)) >> 4;
  G_SetConstString((_WORD *)(v4 + 374), *(_DWORD *)a1);
  *(_DWORD *)(v4 + 664) = a1;
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    *(float *)(v4 + 256) = -1.0;
    *(float *)(v4 + 260) = -1.0;
    *(float *)(v4 + 264) = -1.0;
    *(_DWORD *)(v4 + 268) = 1065353216;
    *(_DWORD *)(v4 + 272) = 1065353216;
    *(_DWORD *)(v4 + 276) = 1065353216;
  }
  else
  {
    *(float *)(v4 + 256) = -1.0;
    *(float *)(v4 + 260) = -1.0;
    *(_DWORD *)(v4 + 264) = 0;
    *(_DWORD *)(v4 + 268) = 1065353216;
    *(_DWORD *)(v4 + 272) = 1065353216;
    *(float *)(v4 + 276) = 2.0;
  }
  *(_BYTE *)(v4 + 245) |= 2u;
  *(_BYTE *)(v4 + 8) |= 0x10u;
  *(_DWORD *)(v4 + 280) = 1081868552;
  *(_DWORD *)(v4 + 400) = 129;
  *(_DWORD *)(v4 + 144) = a4;
  G_SetModel(v4, *(char **)(a1 + 8));
  G_DObjUpdate(v4);
  *(_DWORD *)(v4 + 524) = Touch_Item_Auto;
  G_SetOrigin(v4, a2);
  *(_DWORD *)(v4 + 12) = 5;
  *(_DWORD *)(v4 + 16) = level[122];
  *(float *)(v4 + 36) = *a3;
  *(float *)(v4 + 40) = a3[1];
  *(float *)(v4 + 44) = a3[2];
  *(_DWORD *)(v4 + 512) = DroppedItemClearOwner;
  *(_DWORD *)(v4 + 508) = level[122] + 1000;
  *(_DWORD *)(v4 + 380) = 16;
  trap_LinkEntity(v4);
  return v4;
}
// 21DF80: using guessed type int g_entities[];

//----- (0004DD40) --------------------------------------------------------
int __cdecl Drop_Weapon(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  int v5; // edx
  long double v7; // fst7
  int v8; // edi
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // ebx
  int v15; // esi
  int v16; // ebx
  int v17; // ebx
  long double v18; // fst7
  int v19; // esi
  int v20; // eax
  int v21; // ebx
  long double v22; // fst6
  long double v23; // fst4
  int v24; // [esp+18h] [ebp-A0h]
  char v25[4]; // [esp+1Ch] [ebp-9Ch] BYREF
  float v26; // [esp+20h] [ebp-98h]
  float v27; // [esp+24h] [ebp-94h]
  float v28; // [esp+28h] [ebp-90h]
  float v29[12]; // [esp+4Ch] [ebp-6Ch] BYREF
  int v30; // [esp+8Ch] [ebp-2Ch]
  float v31; // [esp+90h] [ebp-28h]
  float v32; // [esp+94h] [ebp-24h] BYREF
  float v33; // [esp+98h] [ebp-20h]
  float v34; // [esp+9Ch] [ebp-1Ch] BYREF
  float v35; // [esp+A0h] [ebp-18h] BYREF
  float v36; // [esp+A4h] [ebp-14h]
  float v37; // [esp+A8h] [ebp-10h] BYREF
  float v38; // [esp+ACh] [ebp-Ch] BYREF
  float v39; // [esp+B0h] [ebp-8h]
  float v40; // [esp+B4h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 344);
  if ( v3 && !Com_BitCheck(v3 + 780, a2) )
  {
    BG_TakePlayerWeapon(*(_DWORD *)(a1 + 344), a2);
    return 0;
  }
  v4 = BG_AmmoForWeapon(a2);
  v24 = BG_ClipForWeapon(a2);
  if ( *(_DWORD *)(BG_GetInfoForWeapon(a2) + 724) )
  {
    v5 = *(_DWORD *)(a1 + 344);
    if ( !*(_DWORD *)(v5 + 524 + 4 * v24) )
    {
      BG_TakePlayerWeapon(v5, a2);
      return 0;
    }
  }
  v7 = *(float *)(a1 + 324) + 0.0;
  v35 = 0.0;
  v37 = 0.0;
  v36 = v7;
  AngleVectors(&v35, &v38, 0, 0);
  v38 = v38 * 150.0;
  v39 = v39 * 150.0;
  v40 = 150.0 * v40;
  v31 = COERCE_FLOAT(rand());
  v40 = ((long double)SLODWORD(v31) * -4.6566129e-10 + (long double)SLODWORD(v31) * -4.6566129e-10 - 1.0) * 50.0
      + 200.0
      + v40;
  v32 = *(float *)(a1 + 308);
  v33 = *(float *)(a1 + 312);
  v34 = (*(float *)(a1 + 276) - *(float *)(a1 + 264)) * 0.5 + *(float *)(a1 + 316);
  v8 = LaunchItem((int)&bg_itemlist[12 * a2], &v32, &v38, *(_DWORD *)a1);
  v9 = *(_DWORD *)(a1 + 344);
  if ( !v9 )
  {
    v15 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 772);
    v16 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 768);
    if ( v15 < v16 )
    {
      v15 = v16;
      v16 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 772);
    }
    if ( v15 || v16 )
    {
      if ( v15 < 0 || (v15 == v16 ? (v19 = v16) : (v19 = v16 + rand() % (v15 - v16)), v19 <= 0) )
      {
        v12 = 0;
        v14 = 0;
        goto LABEL_27;
      }
      v21 = BG_GetAmmoClipSize(v24);
      if ( v21 )
        v14 = rand() % v21;
      else
        v14 = 0;
      if ( v14 >= v19 )
      {
        v14 = v19;
        v12 = 0;
        goto LABEL_27;
      }
    }
    else
    {
      v17 = rand();
      v18 = ((long double)v17 * -4.6566129e-10 + 1.0) * 0.5 * (long double)(BG_GetAmmoClipSize(v24) - 1) + 0.5;
      LOWORD(v32) = HIWORD(v32) | 0xC00;
      v19 = (int)v18 + 1;
      v20 = rand();
      v30 = v19;
      LOWORD(v32) = HIWORD(v32) | 0xC00;
      LODWORD(v31) = (int)((long double)v19 * ((long double)v20 * -4.6566129e-10 * 0.5 + 0.25) + 0.5);
      v14 = LODWORD(v31);
    }
    v12 = v19 - v14;
    goto LABEL_27;
  }
  v10 = 4 * v4;
  v11 = v9 + 268;
  v12 = *(_DWORD *)(4 * v4 + v11);
  *(_DWORD *)(v10 + v11) = 0;
  v13 = *(_DWORD *)(a1 + 344) + 524;
  v14 = *(_DWORD *)(4 * v24 + v13);
  *(_DWORD *)(4 * v24 + v13) = 0;
  BG_TakePlayerWeapon(*(_DWORD *)(a1 + 344), a2);
LABEL_27:
  *(_DWORD *)(v8 + 592) = v12;
  *(_DWORD *)(v8 + 716) = v14;
  if ( !v12 )
    *(_DWORD *)(v8 + 592) = -1;
  if ( !*(_DWORD *)(v8 + 716) )
    *(_DWORD *)(v8 + 716) = -1;
  if ( a3 )
  {
    if ( G_DObjGetWorldTagMatrix(a1, a3, (int)v29) )
    {
      v22 = (*(float *)(a1 + 260) + *(float *)(a1 + 272)) * 0.5;
      v23 = *(float *)(a1 + 264) + *(float *)(a1 + 276);
      v37 = (*(float *)(a1 + 256) + *(float *)(a1 + 268)) * 0.5 + *(float *)(a1 + 308);
      v38 = v22 + *(float *)(a1 + 312);
      v39 = 0.5 * v23 + *(float *)(a1 + 316);
      trap_TraceCapsule((int)v25, (int)&v37, v8 + 256);
      *(float *)(v8 + 24) = v26;
      *(float *)(v8 + 28) = v27;
      *(float *)(v8 + 32) = v28;
      *(float *)(v8 + 308) = v26;
      *(float *)(v8 + 312) = v27;
      *(float *)(v8 + 316) = v28;
      *(_DWORD *)(v8 + 16) = level[122];
      Axis4ToAngles(v29, (int)&v34);
    }
    else
    {
      v34 = *(float *)(a1 + 320);
      v35 = *(float *)(a1 + 324);
      v36 = *(float *)(a1 + 328);
    }
    v36 = v36 + 90.0;
    G_SetAngle(v8, (float *)(a1 + 320));
    v30 = rand();
    v31 = ((long double)v30 * -4.6566129e-10 + (long double)v30 * -4.6566129e-10 - 1.0) * 50.0;
    v30 = rand();
    v32 = ((long double)v30 * -4.6566129e-10 + (long double)v30 * -4.6566129e-10 - 1.0) * 40.0;
    v30 = rand();
    v33 = ((long double)v30 * -4.6566129e-10 + (long double)v30 * -4.6566129e-10 - 1.0) * 60.0;
    *(_DWORD *)(v8 + 48) = 2;
    *(_DWORD *)(v8 + 52) = level[122];
    *(float *)(v8 + 72) = v31;
    *(float *)(v8 + 76) = v32;
    *(float *)(v8 + 80) = v33;
  }
  return v8;
}

//----- (0004E284) --------------------------------------------------------
void *__cdecl FinishSpawningItem(void *s)
{
  long double v1; // fst7
  long double v2; // fst7
  long double v3; // fst6
  long double v4; // fst5
  const char *v5; // eax
  char *v7; // [esp-18h] [ebp-D0h]
  float v8[3]; // [esp+28h] [ebp-90h] BYREF
  float v9[3]; // [esp+34h] [ebp-84h] BYREF
  float v10[3]; // [esp+40h] [ebp-78h] BYREF
  float v11[2]; // [esp+4Ch] [ebp-6Ch] BYREF
  float v12; // [esp+54h] [ebp-64h]
  float v13[3]; // [esp+58h] [ebp-60h] BYREF
  int v14; // [esp+64h] [ebp-54h]
  int v15; // [esp+68h] [ebp-50h]
  float v16; // [esp+6Ch] [ebp-4Ch]
  float v17; // [esp+70h] [ebp-48h] BYREF
  float v18; // [esp+74h] [ebp-44h]
  float v19; // [esp+78h] [ebp-40h]
  float v20; // [esp+7Ch] [ebp-3Ch]
  float v21; // [esp+80h] [ebp-38h]
  float v22; // [esp+84h] [ebp-34h]
  float v23; // [esp+88h] [ebp-30h] BYREF
  float v24[9]; // [esp+8Ch] [ebp-2Ch] BYREF
  unsigned __int16 v25; // [esp+B0h] [ebp-8h]
  char v26; // [esp+B7h] [ebp-1h]

  if ( (*((_BYTE *)s + 376) & 1) != 0 )
  {
    G_SetOrigin((int)s, (float *)s + 77);
  }
  else
  {
    if ( *(_DWORD *)(*((_DWORD *)s + 166) + 32) == 1 )
    {
      v17 = -1.0;
      v18 = -1.0;
      v19 = -1.0;
      v14 = 1065353216;
      v15 = 1065353216;
      v16 = 1.0;
    }
    else
    {
      v17 = -1.0;
      v18 = -1.0;
      v19 = 0.0;
      v14 = 1065353216;
      v15 = 1065353216;
      v16 = 2.0;
    }
    v1 = *((float *)s + 77);
    *((_BYTE *)s + 245) |= 2u;
    *((_BYTE *)s + 8) |= 0x10u;
    v20 = v1;
    v21 = *((float *)s + 78);
    v22 = *((float *)s + 79) - 4096.0;
    trap_TraceCapsule((int)&v23, (int)s + 308, (int)&v17);
    if ( v26 )
    {
      v2 = *((float *)s + 77);
      v13[0] = *((float *)s + 77);
      v3 = *((float *)s + 78);
      v13[1] = *((float *)s + 78);
      v4 = *((float *)s + 79);
      v20 = v2;
      v21 = v3;
      v22 = v4 - 4096.0;
      v13[2] = v4 - 15.0;
      trap_TraceCapsule((int)&v23, (int)v13, (int)&v17);
      if ( v26 )
      {
        v7 = vtos((float *)s + 77);
        v5 = (const char *)SL_ConvertToString(*((_WORD *)s + 187));
        G_Printf("FinishSpawningItem: %s startsolid at %s\n", v5, v7);
        return G_FreeEntity(s);
      }
    }
    *((_DWORD *)s + 31) = v25;
    G_SetOrigin((int)s, v24);
    if ( v23 < 1.0 )
    {
      v10[0] = v24[3];
      v10[1] = v24[4];
      v10[2] = v24[5];
      AngleVectors((float *)s + 80, v8, 0, 0);
      CrossProduct(v10, v8, v9);
      CrossProduct(v9, v10, v8);
      AxisToAngles(v8, (int)v11);
      if ( bg_itemlist[12 * *((_DWORD *)s + 35) + 8] == 1 )
        v12 = v12 + 90.0;
      G_SetAngle((int)s, v11);
    }
  }
  return (void *)trap_LinkEntity((int)s);
}

//----- (0004E504) --------------------------------------------------------
void __cdecl RegisterItem(int a1, int a2)
{
  const char *v2; // ebx
  char *v3; // eax
  int v4; // eax
  int v5; // ebx

  if ( !itemRegistered[a1] )
  {
    if ( !level[7] )
    {
      v2 = (const char *)bg_itemlist[12 * a1 + 6];
      if ( (!v2 || !*v2) && a1 <= BG_GetNumWeapons() )
        v2 = *(const char **)(BG_GetInfoForWeapon(a1) + 4);
      if ( !v2 || !*v2 )
        v2 = "<<unknown>>";
      v3 = va("game tried to register the item '%s' after initialization finished\n", v2);
      Scr_Error((int)v3);
    }
    itemRegistered[a1] = 1;
    if ( bg_itemlist[12 * a1 + 8] == 1 )
    {
      v4 = a1;
      do
      {
        itemRegistered[v4] = 1;
        v5 = BG_GetInfoForWeapon(v4);
        G_ModelIndex(*(char **)(v5 + 392));
        G_ModelIndex(*(char **)(v5 + 796));
        v4 = *(_DWORD *)(v5 + 764);
      }
      while ( v4 && v4 != a1 );
    }
    else
    {
      if ( bg_itemlist[12 * a1 + 2] )
        G_ModelIndex((char *)bg_itemlist[12 * a1 + 2]);
      if ( bg_itemlist[12 * a1 + 3] )
        G_ModelIndex((char *)bg_itemlist[12 * a1 + 3]);
    }
    if ( a2 )
      level[2692] = 1;
  }
}

//----- (0004E634) --------------------------------------------------------
int __cdecl G_SpawnItem(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  char *s2; // [esp+14h] [ebp-4h] BYREF

  G_SpawnFloat("random", (int)"0", a1 + 620);
  G_SpawnFloat("wait", (int)"0", a1 + 616);
  RegisterItem((-1431655765 * (a2 - (int)bg_itemlist)) >> 4, 0);
  *(_DWORD *)(a1 + 664) = a2;
  G_SetModel(a1, *(char **)(a2 + 8));
  if ( G_SpawnString("noise", 0, (int)&s2) )
    *(_BYTE *)(a1 + 366) = G_SoundAliasIndex(s2);
  *(_DWORD *)(a1 + 396) = 0;
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    *(float *)(a1 + 256) = -1.0;
    *(float *)(a1 + 260) = -1.0;
    *(float *)(a1 + 264) = -1.0;
    *(_DWORD *)(a1 + 268) = 1065353216;
    *(_DWORD *)(a1 + 272) = 1065353216;
    *(_DWORD *)(a1 + 276) = 1065353216;
  }
  else
  {
    *(float *)(a1 + 256) = -1.0;
    *(float *)(a1 + 260) = -1.0;
    *(_DWORD *)(a1 + 264) = 0;
    *(_DWORD *)(a1 + 268) = 1065353216;
    *(_DWORD *)(a1 + 272) = 1065353216;
    *(float *)(a1 + 276) = 2.0;
  }
  v2 = -1431655765 * (*(_DWORD *)(a1 + 664) - (_DWORD)bg_itemlist);
  *(_BYTE *)(a1 + 245) |= 2u;
  *(_BYTE *)(a1 + 8) |= 0x10u;
  *(_DWORD *)(a1 + 280) = 1081868552;
  *(_DWORD *)(a1 + 524) = Touch_Item_Auto;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 140) = v2 >> 4;
  G_DObjUpdate(a1);
  *(_DWORD *)(a1 + 144) = 1022;
  *(_DWORD *)(a1 + 528) = Use_Item;
  *(_BYTE *)(a1 + 381) |= 0x20u;
  if ( level[1233] )
  {
    G_SetAngle(a1, (float *)(a1 + 320));
    result = level[122] + 200;
    *(_DWORD *)(a1 + 508) = result;
    *(_DWORD *)(a1 + 512) = FinishSpawningItem;
  }
  else
  {
    if ( (*(_BYTE *)(a1 + 376) & 1) == 0 )
    {
      *(_DWORD *)(a1 + 124) = 1023;
      if ( *(_DWORD *)(a2 + 32) == 1 )
        *(float *)(a1 + 328) = *(float *)(a1 + 328) + 90.0;
    }
    G_SetAngle(a1, (float *)(a1 + 320));
    G_SetOrigin(a1, (float *)(a1 + 308));
    result = trap_LinkEntity(a1);
  }
  return result;
}

//----- (0004E858) --------------------------------------------------------
int __cdecl G_BounceItem(int a1, int a2)
{
  int v2; // edx
  long double v3; // fst7
  long double v4; // fst5
  long double v5; // fst6
  long double v6; // fst3
  long double v7; // fst4
  long double v8; // rtt
  long double v9; // fst4
  long double v10; // rt0
  long double v11; // fst4
  long double v12; // fst3
  long double v13; // fst6
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int result; // eax
  long double v19; // fst6
  long double v20; // fst7
  long double v21; // rt0
  long double v22; // fst5
  long double v23; // fst6
  long double v24; // fst7
  float v25[2]; // [esp+18h] [ebp-50h] BYREF
  float v26; // [esp+20h] [ebp-48h]
  float v27[3]; // [esp+24h] [ebp-44h] BYREF
  float v28[3]; // [esp+30h] [ebp-38h] BYREF
  float v29[6]; // [esp+3Ch] [ebp-2Ch] BYREF
  __int16 v30; // [esp+54h] [ebp-14h]
  __int16 v31; // [esp+56h] [ebp-12h]
  int v32; // [esp+58h] [ebp-10h]
  float v33; // [esp+5Ch] [ebp-Ch] BYREF
  float v34; // [esp+60h] [ebp-8h]
  float v35; // [esp+64h] [ebp-4h]

  v2 = level[123];
  v3 = (long double)(level[122] - v2) * *(float *)a2;
  v30 = v31 | 0xC00;
  v32 = (int)v3;
  BG_EvaluateTrajectoryDelta(a1 + 12, (int)v3 + v2, &v33);
  v4 = v34;
  v5 = v35;
  v6 = (v34 * *(float *)(a2 + 20) + v33 * *(float *)(a2 + 16) + v35 * *(float *)(a2 + 24)) * -2.0;
  v7 = *(float *)(a2 + 16) * v6 + v33;
  *(float *)(a1 + 36) = v7;
  v8 = v7;
  v9 = v4 + *(float *)(a2 + 20) * v6;
  *(float *)(a1 + 40) = v9;
  v10 = v9;
  v11 = v6 * *(float *)(a2 + 24);
  v12 = v5;
  v13 = *(float *)(a1 + 396);
  *(float *)(a1 + 36) = v8 * v13;
  *(float *)(a1 + 40) = v10 * v13;
  *(float *)(a1 + 44) = v13 * (v11 + v12);
  if ( *(_BYTE *)(a2 + 47) )
  {
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    v29[3] = *(float *)(a1 + 308);
    v29[4] = *(float *)(a1 + 312);
    v29[5] = *(float *)(a1 + 316) - 128.0;
    if ( (*(_BYTE *)(a1 + 8) & 0x10) != 0 )
      trap_TraceCapsule(a2, a1 + 308, a1 + 256);
    else
      trap_Trace(a2, a1 + 308, a1 + 256);
  }
  v15 = *(float *)(a2 + 24) > 0.0;
  v16 = 0;
  v17 = 0.0 == *(float *)(a2 + 24);
  if ( (v14 & 0x45) == 1 && *(float *)(a1 + 44) < 40.0 )
  {
    v32 = rand();
    *(float *)(a2 + 12) = (long double)v32 * -4.6566129e-10 * 0.5 + 0.5 + *(float *)(a2 + 12);
    G_SetOrigin(a1, (float *)(a2 + 4));
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
    v29[0] = *(float *)(a2 + 16);
    v29[1] = *(float *)(a2 + 20);
    v29[2] = *(float *)(a2 + 24);
    AngleVectors((float *)(a1 + 320), v27, 0, 0);
    CrossProduct(v29, v27, v28);
    CrossProduct(v28, v29, v27);
    AxisToAngles(v27, (int)v25);
    if ( bg_itemlist[12 * *(_DWORD *)(a1 + 140) + 8] == 1 )
      v26 = v26 + 90.0;
    G_SetAngle(a1, v25);
    result = trap_LinkEntity(a1);
  }
  else
  {
    v19 = *(float *)(a1 + 308) + *(float *)(a2 + 16);
    v20 = *(float *)(a1 + 312);
    *(float *)(a1 + 308) = v19;
    v21 = v19;
    v22 = v20 + *(float *)(a2 + 20);
    v23 = *(float *)(a1 + 316);
    *(float *)(a1 + 312) = v22;
    v24 = v23 + *(float *)(a2 + 24);
    *(float *)(a1 + 24) = v21;
    *(float *)(a1 + 28) = v22;
    *(float *)(a1 + 316) = v24;
    *(float *)(a1 + 32) = v24;
    result = level[122];
    *(_DWORD *)(a1 + 16) = result;
  }
  return result;
}
// 4E9C2: variable 'v14' is possibly undefined

//----- (0004EB18) --------------------------------------------------------
unsigned __int16 __cdecl G_RunItem(void *s)
{
  int v1; // eax
  unsigned __int16 result; // ax
  __int16 v3; // fps
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7[11]; // [esp+1Ch] [ebp-3Ch] BYREF
  char v8; // [esp+4Bh] [ebp-Dh]
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( *((_DWORD *)s + 31) == 1023 && *((_DWORD *)s + 3) != 5 )
  {
    *((_DWORD *)s + 3) = 5;
    *((_DWORD *)s + 4) = level[122];
  }
  v1 = *((_DWORD *)s + 3);
  if ( !v1 || v1 == 8 )
    return G_RunThink((int)s);
  BG_EvaluateTrajectory((int)s + 12, level[122], v9);
  if ( (*((_BYTE *)s + 8) & 0x10) != 0 )
    trap_TraceCapsule((int)v7, (int)s + 308, (int)s + 256);
  else
    trap_Trace((int)v7, (int)s + 308, (int)s + 256);
  *((float *)s + 77) = *(float *)&v7[1];
  *((float *)s + 78) = *(float *)&v7[2];
  *((float *)s + 79) = *(float *)&v7[3];
  if ( v8 )
    v7[0] = 0;
  trap_LinkEntity((int)s);
  result = G_RunThink((int)s);
  if ( *((_BYTE *)s + 352) )
  {
    v4 = *(float *)v7 < 1.0;
    v5 = 0;
    v6 = *(float *)v7 == 1.0;
    LOBYTE(result) = v3;
    HIBYTE(result) = HIBYTE(v3) & 0x45;
    if ( (HIBYTE(v3) & 0x45) != 64 )
    {
      if ( trap_PointContents((int)s + 308, -1, 0x80000000) )
        result = (unsigned __int16)G_FreeEntity(s);
      else
        result = G_BounceItem((int)s, (int)v7);
    }
  }
  return result;
}
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (0004EC7C) --------------------------------------------------------
int __cdecl RespawnItem(int a1)
{
  int v1; // ebx
  int v2; // edi
  int v3; // esi
  int i; // ebx
  int v5; // edx
  int v6; // esi
  int result; // eax

  v1 = a1;
  if ( *(_WORD *)(a1 + 472) )
  {
    if ( !*(_DWORD *)(a1 + 612) )
      G_Error("RespawnItem: bad teammaster");
    v2 = *(_DWORD *)(a1 + 612);
    v3 = 0;
    for ( i = v2; i; ++v3 )
      i = *(_DWORD *)(i + 608);
    v5 = rand() % v3;
    v1 = v2;
    if ( v5 > 0 )
    {
      v6 = v5;
      do
      {
        v1 = *(_DWORD *)(v1 + 608);
        --v6;
      }
      while ( v6 );
    }
  }
  *(_DWORD *)(v1 + 280) = 1081868296;
  *(_BYTE *)(v1 + 381) &= 0xEFu;
  *(_BYTE *)(v1 + 244) &= 0xFEu;
  trap_LinkEntity(v1);
  result = G_AddEvent((_DWORD *)v1, 197, 0);
  *(_DWORD *)(v1 + 508) = 0;
  return result;
}

//----- (0004ED30) --------------------------------------------------------
int __cdecl Drop_Item(int a1, int a2, float a3, int a4)
{
  long double v4; // fst7
  int v6; // [esp+10h] [ebp-28h]
  float v7[3]; // [esp+14h] [ebp-24h] BYREF
  int v8[3]; // [esp+20h] [ebp-18h] BYREF
  float v9; // [esp+2Ch] [ebp-Ch] BYREF
  float v10; // [esp+30h] [ebp-8h]
  float v11; // [esp+34h] [ebp-4h]

  v4 = *(float *)(a1 + 324) + a3;
  v8[0] = 0;
  v8[2] = 0;
  *(float *)&v8[1] = v4;
  if ( a4 )
  {
    v11 = 0.0;
    v10 = 0.0;
    v9 = 0.0;
  }
  else
  {
    AngleVectors((float *)v8, &v9, 0, 0);
    v9 = v9 * 150.0;
    v10 = v10 * 150.0;
    v11 = 150.0 * v11;
    v6 = rand();
    v11 = ((long double)v6 * -4.6566129e-10 + (long double)v6 * -4.6566129e-10 - 1.0) * 50.0 + 200.0 + v11;
  }
  v7[0] = *(float *)(a1 + 308);
  v7[1] = *(float *)(a1 + 312);
  v7[2] = (*(float *)(a1 + 276) - *(float *)(a1 + 264)) * 0.5 + *(float *)(a1 + 316);
  return LaunchItem(a2, v7, &v9, *(_DWORD *)a1);
}

//----- (0004EE20) --------------------------------------------------------
int __cdecl Fill_Clip(int a1, int a2)
{
  int result; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+24h] [ebp-4h]

  v6 = BG_AmmoForWeapon(a2);
  result = BG_ClipForWeapon(a2);
  v5 = result;
  if ( a2 > 0 )
  {
    result = BG_GetNumWeapons();
    if ( a2 <= result )
    {
      v3 = *(_DWORD *)(4 * v5 + a1 + 524);
      result = BG_GetAmmoClipSize(v5) - v3;
      v4 = *(_DWORD *)(4 * v6 + a1 + 268);
      if ( result > v4 )
        result = *(_DWORD *)(4 * v6 + a1 + 268);
      if ( result )
      {
        *(_DWORD *)(4 * v6 + a1 + 268) = v4 - result;
        *(_DWORD *)(4 * v5 + a1 + 524) += result;
      }
    }
  }
  return result;
}

//----- (0004EEA4) --------------------------------------------------------
void __cdecl Touch_Item_Auto(int a1, char *a2, int a3)
{
  *(_BYTE *)(a1 + 370) = 1;
  Touch_Item(a1, a2, a3);
}

//----- (0004EECC) --------------------------------------------------------
void ClearRegisteredItems()
{
  _bzero(&itemRegistered, 0x400u);
  itemRegistered = 1;
}
// 18E0E0: using guessed type int itemRegistered;

//----- (0004EEF4) --------------------------------------------------------
int __cdecl IsItemRegistered(int a1)
{
  return itemRegistered[a1];
}

//----- (0004EF08) --------------------------------------------------------
int SaveRegisteredItems()
{
  int v0; // edi
  int v1; // edx
  int v2; // ecx
  int i; // esi
  int v4; // eax
  char v5; // dl
  int v6; // eax
  char v7; // dl
  char v9[260]; // [esp+24h] [ebp-104h] BYREF

  level[2692] = 0;
  v0 = 0;
  v1 = 0;
  v2 = 0;
  for ( i = 0; i < bg_numItems; ++i )
  {
    if ( itemRegistered[i] )
      v1 += 1 << v2;
    if ( ++v2 == 4 )
    {
      v4 = v0++;
      if ( v1 > 9 )
        v5 = v1 + 87;
      else
        v5 = v1 + 48;
      v9[v4] = v5;
      v1 = 0;
      v2 = 0;
    }
  }
  if ( v2 )
  {
    v6 = v0++;
    if ( v1 > 9 )
      v7 = v1 + 87;
    else
      v7 = v1 + 48;
    v9[v6] = v7;
  }
  v9[v0] = 0;
  return trap_SetConfigstring(8, (int)v9);
}
// 70804: using guessed type int bg_numItems;

//----- (0004EFB4) --------------------------------------------------------
int __cdecl DroppedItemClearOwner(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 144) = 1022;
  return result;
}

//----- (0004EFC8) --------------------------------------------------------
int __cdecl Use_Item(int a1)
{
  int v1; // ebx
  int v2; // edi
  int v3; // esi
  int i; // ebx
  int v5; // edx
  int v6; // esi
  int result; // eax

  v1 = a1;
  if ( *(_WORD *)(a1 + 472) )
  {
    if ( !*(_DWORD *)(a1 + 612) )
      G_Error("RespawnItem: bad teammaster");
    v2 = *(_DWORD *)(a1 + 612);
    v3 = 0;
    for ( i = v2; i; ++v3 )
      i = *(_DWORD *)(i + 608);
    v5 = rand() % v3;
    v1 = v2;
    if ( v5 > 0 )
    {
      v6 = v5;
      do
      {
        v1 = *(_DWORD *)(v1 + 608);
        --v6;
      }
      while ( v6 );
    }
  }
  *(_DWORD *)(v1 + 280) = 1081868296;
  *(_BYTE *)(v1 + 381) &= 0xEFu;
  *(_BYTE *)(v1 + 244) &= 0xFEu;
  trap_LinkEntity(v1);
  result = G_AddEvent((_DWORD *)v1, 197, 0);
  *(_DWORD *)(v1 + 508) = 0;
  return result;
}

//----- (0004F070) --------------------------------------------------------
int G_Printf(char *format, ...)
{
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return trap_Printf((int)s);
}

//----- (0004F0A4) --------------------------------------------------------
int G_DPrintf(char *format, ...)
{
  int result; // eax
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  if ( g_developer[3] )
  {
    vsprintf(s, format, __varargs);
    result = trap_Printf((int)s);
  }
  return result;
}

//----- (0004F0E4) --------------------------------------------------------
int G_Error(char *format, ...)
{
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return trap_Error((int)s);
}

//----- (0004F118) --------------------------------------------------------
int G_Error_Localized(char *format, ...)
{
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return trap_Error_Localized((int)s);
}

//----- (0004F14C) --------------------------------------------------------
int __cdecl G_GetActivateEnt(int a1, void *base)
{
  float *v2; // esi
  int v3; // edx
  int *v4; // ebx
  long double v5; // fst7
  long double v6; // fst5
  long double v7; // rt0
  long double v8; // fst4
  long double v9; // fst5
  long double v10; // rt2
  long double v11; // fst5
  long double v12; // fst7
  long double v13; // fst6
  long double v14; // fst7
  int v15; // ebx
  int v16; // edi
  long double v17; // fst7
  long double v18; // fst6
  long double v19; // rt1
  long double v20; // fst6
  int v22; // [esp+28h] [ebp-10D0h]
  int v23; // [esp+2Ch] [ebp-10CCh]
  size_t nmemb; // [esp+30h] [ebp-10C8h]
  signed int nmemba; // [esp+30h] [ebp-10C8h]
  int v26; // [esp+34h] [ebp-10C4h]
  signed int i; // [esp+34h] [ebp-10C4h]
  int v28; // [esp+38h] [ebp-10C0h]
  char v29[48]; // [esp+40h] [ebp-10B8h] BYREF
  float v30; // [esp+70h] [ebp-1088h]
  float v31; // [esp+74h] [ebp-1084h]
  float v32; // [esp+78h] [ebp-1080h]
  float v33; // [esp+80h] [ebp-1078h] BYREF
  float v34; // [esp+84h] [ebp-1074h]
  float v35; // [esp+88h] [ebp-1070h]
  float v36; // [esp+8Ch] [ebp-106Ch]
  float v37; // [esp+90h] [ebp-1068h]
  float v38; // [esp+94h] [ebp-1064h]
  float v39; // [esp+98h] [ebp-1060h] BYREF
  float v40; // [esp+9Ch] [ebp-105Ch]
  float v41; // [esp+A0h] [ebp-1058h]
  float v42[3]; // [esp+A4h] [ebp-1054h] BYREF
  float v43[3]; // [esp+B0h] [ebp-1048h] BYREF
  int v44[1024]; // [esp+BCh] [ebp-103Ch] BYREF
  float v45[3]; // [esp+10BCh] [ebp-3Ch] BYREF
  char v46[40]; // [esp+10C8h] [ebp-30h] BYREF
  __int16 v47; // [esp+10F0h] [ebp-8h]

  nmemb = 0;
  v23 = 0;
  AngleVectors((float *)(*(_DWORD *)(a1 + 344) + 192), v45, 0, 0);
  CalcMuzzlePoint(a1, &v39);
  v43[0] = v39 - 192.0;
  v42[0] = v39 + 192.0;
  v43[1] = v40 - 192.0;
  v42[1] = v40 + 192.0;
  v42[2] = v41 + 96.0;
  v43[2] = v41 - 96.0;
  v28 = trap_EntitiesInBox((int)v43, (int)v42, (int)v44);
  v26 = 0;
  if ( v28 > 0 )
  {
    v2 = (float *)base;
    do
    {
      v3 = 197 * v44[v26];
      v22 = v3 * 4;
      v4 = &g_entities[v3];
      if ( (int *)a1 != &g_entities[v3] && (g_entities[v3 + 1] == 3 || (*((_BYTE *)v4 + 282) & 0x20) != 0) )
      {
        v5 = *((float *)v4 + 71) + *((float *)v4 + 74);
        v36 = v5;
        v6 = *((float *)v4 + 72) + *((float *)v4 + 75);
        v37 = v6;
        v7 = v6 * 0.5;
        v8 = *((float *)v4 + 73) + *((float *)v4 + 76);
        v9 = v5 * 0.5;
        v36 = v9;
        v10 = v9 - v39;
        v37 = v7;
        v11 = 0.5 * v8;
        v38 = v11;
        v33 = v10;
        v34 = v7 - v40;
        v35 = v11 - v41;
        v12 = VectorNormalize(&v33);
        if ( v12 <= 128.0 )
        {
          v13 = v33 * v45[0] + v34 * v45[1] + v35 * v45[2];
          if ( v13 > 0.0 && v13 >= 0.75999999 )
          {
            v2[1] = (1.0 - (v13 - 0.75999999) / 0.24000001) * 256.0;
            if ( *(int *)((char *)&g_entities[1] + v22) == 3 && !BG_CanItemBeGrabbed((int)v4, *(_DWORD **)(a1 + 344), 0) )
            {
              v2[1] = v2[1] + 10000.0;
              ++v23;
            }
            v14 = v12 + v2[1];
            *(_DWORD *)v2 = v4;
            v2[1] = v14;
            v2 += 2;
            ++nmemb;
          }
        }
      }
      ++v26;
    }
    while ( v26 < v28 );
  }
  qsort(base, nmemb, 8u, compar);
  nmemba = nmemb - v23;
  v15 = 0;
  for ( i = 0; i < nmemba; ++i )
  {
    v16 = *((_DWORD *)base + 2 * i);
    v17 = *(float *)(v16 + 284) + *(float *)(v16 + 296);
    v36 = v17;
    v18 = *(float *)(v16 + 288) + *(float *)(v16 + 300);
    v37 = v18;
    v19 = v18 * 0.5;
    v20 = (*(float *)(v16 + 292) + *(float *)(v16 + 304)) * 0.5;
    v36 = v17 * 0.5;
    v37 = v19;
    v38 = v20;
    if ( *(_DWORD *)(v16 + 4) == 11 && G_DObjGetWorldTagMatrix(v16, (int)"tag_aim", (int)v29) )
    {
      v36 = v30;
      v37 = v31;
      v38 = v32;
    }
    trap_Trace((int)v46, (int)&v39, (int)&vec3_origin);
    if ( v47 != 1022 )
      break;
    ++v15;
    *((float *)base + 2 * i + 1) = *((float *)base + 2 * i + 1) + 100000.0;
  }
  qsort(base, nmemba, 8u, compar);
  return nmemba - v15;
}
// 72910: using guessed type float vec3_origin;
// 21DF80: using guessed type int g_entities[];

//----- (0004F59C) --------------------------------------------------------
int __cdecl G_CheckForCursorHints(int a1)
{
  int result; // eax
  int v2; // edi
  int v3; // ebx
  int v4; // esi
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  __int16 v8; // ax
  char v9; // al
  char v10; // al
  int v11; // [esp+1Ch] [ebp-200Ch]
  int v12; // [esp+20h] [ebp-2008h]
  int v13; // [esp+24h] [ebp-2004h]
  _DWORD base[2048]; // [esp+28h] [ebp-2000h] BYREF

  result = *(_DWORD *)(a1 + 344);
  v12 = result;
  *(_DWORD *)(result + 900) = 0;
  *(_DWORD *)(result + 904) = 0;
  *(_WORD *)(result + 952) = 1023;
  if ( *(int *)(a1 + 560) > 0 && !*(_BYTE *)(a1 + 370) )
  {
    *(_DWORD *)(result + 900) = 0;
    v2 = 0;
    *(_DWORD *)(result + 904) = 0;
    *(_DWORD *)(result + 908) = -1;
    v13 = -1;
    result = G_GetActivateEnt(a1, base);
    v11 = result;
    if ( result )
    {
      v3 = 0;
      if ( result > 0 )
      {
        while ( 1 )
        {
          v4 = base[2 * v3];
          *(_WORD *)(v12 + 952) = *(_WORD *)v4;
          if ( !v4 )
            break;
          if ( *(_DWORD *)v4 == 1022 )
          {
            if ( (*(_BYTE *)(v12 + 940) & 8) != 0 && (*(_BYTE *)(v12 + 12) & 0x10) == 0 )
              v2 = 8;
            break;
          }
          if ( *(_DWORD *)(v4 + 344) )
            break;
          v5 = *(_DWORD *)(v4 + 4);
          if ( !v5 )
          {
            if ( *(_WORD *)(v4 + 374) == scr_const[74] )
            {
              v2 = *(_DWORD *)(v4 + 220);
              if ( !v2 )
                break;
              if ( *(_DWORD *)(v4 + 216) != 255 )
                v13 = *(_DWORD *)(v4 + 216);
            }
            goto LABEL_40;
          }
          if ( v5 != 11 )
          {
            if ( v5 == 3 )
            {
              v6 = 12 * ((-1431655765 * (*(_DWORD *)(v4 + 664) - (int)bg_itemlist)) >> 4);
              v7 = bg_itemlist[v6 + 8];
              if ( v7 == 1 )
              {
                if ( Com_BitCheck(*(_DWORD *)(a1 + 344) + 780, bg_itemlist[v6 + 9]) )
                  goto LABEL_28;
                v2 = bg_itemlist[v6 + 9] + 9;
              }
              else if ( v7 )
              {
                if ( v7 != 2 )
                {
                  if ( v7 == 3 )
                    v2 = 7;
                  goto LABEL_40;
                }
LABEL_28:
                v2 = bg_itemlist[v6 + 9] + 73;
              }
LABEL_40:
              if ( *(int *)(v4 + 220) > 0 && v2 )
                v2 = *(_DWORD *)(v4 + 220);
              break;
            }
            if ( v5 != 5 )
              goto LABEL_40;
            v8 = *(_WORD *)(v4 + 374);
            if ( v8 == scr_const[27] )
            {
              v9 = *(_BYTE *)(v4 + 372);
              if ( v9 != 7 )
              {
                if ( v9 != 8 )
                  goto LABEL_40;
LABEL_37:
                if ( *(char *)(v4 + 380) >= 0 )
                  goto LABEL_40;
              }
            }
            else
            {
              if ( v8 != scr_const[26] )
                goto LABEL_40;
              v10 = *(_BYTE *)(v4 + 372);
              if ( v10 )
              {
                if ( v10 != 1 )
                  goto LABEL_40;
                goto LABEL_37;
              }
            }
            v2 = 4;
            if ( *(_DWORD *)(v4 + 680) )
              v2 = 5;
            goto LABEL_40;
          }
          result = G_IsTurretUsable(v4, a1);
          if ( result )
          {
            v2 = 6;
            if ( **(_BYTE **)(BG_GetInfoForWeapon(*(_DWORD *)(v4 + 200)) + 1032) )
              v13 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(v4 + 200)) + 1036);
            goto LABEL_40;
          }
          if ( ++v3 >= v11 )
            return result;
        }
        result = v12;
        *(_DWORD *)(v12 + 900) = v2;
        *(_DWORD *)(v12 + 904) = 0;
        *(_DWORD *)(v12 + 908) = v13;
        if ( !v2 )
          *(_WORD *)(v12 + 952) = 1023;
      }
    }
  }
  return result;
}

//----- (0004F88C) --------------------------------------------------------
int __cdecl G_CheckForPreventFriendlyFire(int a1)
{
  int result; // eax
  int *v2; // edx
  float v3[9]; // [esp+1Ch] [ebp-7Ch] BYREF
  float v4[7]; // [esp+40h] [ebp-58h] BYREF
  float v5[3]; // [esp+5Ch] [ebp-3Ch] BYREF
  char v6[40]; // [esp+68h] [ebp-30h] BYREF
  unsigned __int16 v7; // [esp+90h] [ebp-8h]

  result = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(result + 8800) = 0;
  if ( !*(_BYTE *)(a1 + 370) )
  {
    CalcMuzzlePoints(a1, v3);
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 344) + 176) )
      BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 344) + 176));
    v5[0] = v3[0] * 8192.0 + v4[0];
    v5[1] = v3[1] * 8192.0 + v4[1];
    v5[2] = 8192.0 * v3[2] + v4[2];
    result = trap_LocationalTrace((int)v6, (int)v4, (int)v5);
    if ( v7 <= 0x3FDu )
    {
      result = trap_LocationalTrace((int)v6, (int)v4, (int)v5);
      if ( v7 <= 0x3FDu )
      {
        v2 = &g_entities[197 * v7];
        result = (unsigned __int16)scr_const[76];
        if ( *((_WORD *)v2 + 187) == (_WORD)result )
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 344) + 8800) = v2;
          result = G_Trigger(v2, (int *)a1);
        }
      }
    }
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (0004F9C4) --------------------------------------------------------
int G_FindTeams()
{
  int v0; // edx
  int v1; // ecx
  int *v2; // esi
  int v3; // edi
  int v4; // ebx
  __int16 v5; // ax
  int *i; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h]

  v10 = 0;
  v9 = 0;
  v0 = level[3];
  v1 = 1;
  v2 = &g_entities[197];
  if ( v0 > 1 )
  {
    while ( 1 )
    {
      v8 = v1 + 1;
      i = v2 + 197;
      if ( *((_BYTE *)v2 + 352) )
      {
        if ( *((_WORD *)v2 + 236) && (v2[95] & 4) == 0 )
        {
          if ( *((_WORD *)v2 + 187) != scr_const[29] )
            goto LABEL_8;
          if ( (v2[94] & 8) != 0 )
            break;
        }
      }
LABEL_16:
      v1 = v8;
      v2 = i;
      if ( v8 >= v0 )
        return G_Printf("%i teams with %i entities\n", v10, v9);
    }
    v2[153] = (int)v2;
LABEL_8:
    ++v10;
    ++v9;
    v0 = level[3];
    v3 = v1 + 1;
    v4 = (int)(v2 + 197);
    v8 = v1 + 1;
    for ( i = v2 + 197; v3 < v0; v4 += 788 )
    {
      if ( *(_BYTE *)(v4 + 352) )
      {
        v5 = *(_WORD *)(v4 + 472);
        if ( v5 )
        {
          if ( (*(_BYTE *)(v4 + 380) & 4) == 0 && *((_WORD *)v2 + 236) == v5 )
          {
            ++v9;
            *(_DWORD *)(v4 + 608) = v2[152];
            v2[152] = v4;
            *(_DWORD *)(v4 + 612) = v2;
            *(_BYTE *)(v4 + 380) |= 4u;
            if ( *(_WORD *)(v4 + 374) == scr_const[29] )
              trap_UnlinkEntity(v4);
          }
        }
      }
      v0 = level[3];
      ++v3;
    }
    goto LABEL_16;
  }
  return G_Printf("%i teams with %i entities\n", v10, v9);
}

//----- (0004FB14) --------------------------------------------------------
int __cdecl G_InitGame(int a1, unsigned int seed, int a3, int a4)
{
  int v4; // eax
  int v5; // esi
  int *i; // ebx
  int v7; // eax
  int v8; // eax
  int *v9; // ecx
  char *v10; // edx
  int result; // eax
  char v12[1024]; // [esp+18h] [ebp-800h] BYREF
  char dest[1024]; // [esp+418h] [ebp-400h] BYREF

  Swap_Init();
  G_Printf("------- Game Initialization -------\n");
  G_Printf("gamename: %s\n", "main");
  G_Printf("gamedate: %s\n", "Nov 13 2003");
  srand(seed);
  v4 = trap_Milliseconds();
  Rand_Init(v4);
  Scr_ParseGameTypeList();
  if ( !a4 )
  {
    v5 = 0;
    for ( i = (int *)&gameCvarTable; v5 < dword_7E4D0; i += 6 )
    {
      trap_Cvar_Register(*i, i[1], i[2]);
      if ( *i )
        i[4] = *(_DWORD *)(*i + 4);
      ++v5;
    }
    if ( !Scr_IsValidGameType(&g_gametype[16]) )
    {
      G_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", &g_gametype[16]);
      trap_Cvar_Set((int)"g_gametype", (int)"dm");
      trap_Cvar_Update((int)g_gametype);
    }
  }
  G_ProcessIPBans();
  G_SetPlayerSize();
  _bzero(level, 0x2A14u);
  _bzero(&bg, 0xCu);
  _bzero(bgs, (size_t)&unk_AC8EC);
  level[7] = 1;
  level[122] = a1;
  level[125] = a1;
  bgs[159156] = (int)trap_Com_SoundAliasString;
  bgs[159157] = (int)G_AnimScriptSound;
  if ( g_log[16] )
  {
    if ( g_logSync[3] )
      trap_FS_FOpenFile((int)&g_log[16], (int)&level[6], 3);
    else
      trap_FS_FOpenFile((int)&g_log[16], (int)&level[6], 2);
    if ( level[6] )
    {
      trap_GetServerinfo((int)v12, 1024);
      G_LogPrintf("------------------------------------------------------------\n");
      G_LogPrintf("InitGame: %s\n", v12);
    }
    else
    {
      G_Printf("WARNING: Couldn't open logfile: %s\n", &g_log[16]);
    }
  }
  else
  {
    G_Printf("Not logging to disk.\n");
  }
  BG_SetupWeaponInfo();
  GScr_LoadScripts();
  GScr_LoadConsts();
  trap_GetConfigstring(20, (int)dest, 1024);
  Info_SetValueForKey(dest, "winner", (int)"0");
  trap_SetConfigstring(20, (int)dest);
  _bzero(g_entities, (size_t)&unk_C5000);
  v7 = g_maxclients[3];
  level[1] = (int)g_entities;
  level[120] = v7;
  _bzero(&g_clients, (size_t)&unk_8B100);
  v8 = level[120];
  level[0] = (int)&g_clients;
  if ( v8 > 0 )
  {
    v9 = &g_entities[86];
    v10 = (char *)&g_clients;
    do
    {
      *v9 = (int)v10;
      v9 += 197;
      v10 += 8900;
      --v8;
    }
    while ( v8 );
  }
  level[3] = 72;
  level[4] = 0;
  level[5] = 0;
  trap_LocateGameData(level[1], 72, 788);
  G_ParseHitLocDmgTable();
  if ( !a3 )
    ClearRegisteredItems();
  G_InitTurrets();
  G_SpawnEntitiesFromString();
  G_FindTeams();
  SaveRegisteredItems();
  G_setfog("0");
  G_InitObjectives();
  G_Printf("-----------------------------------\n");
  Scr_InitSystem(1, level[122]);
  Scr_SetLoading(1);
  Scr_AllocGameVariable();
  Scr_LoadGameType();
  Scr_LoadLevel();
  result = Scr_StartupGameType();
  level[7] = 0;
  return result;
}
// 7DE28: using guessed type void *gameCvarTable;
// 7E4D0: using guessed type int dword_7E4D0;
// C13A0: using guessed type int bg;
// C13C0: using guessed type int bgs[];

//----- (0004FE98) --------------------------------------------------------
int __cdecl G_ShutdownGame(int a1)
{
  int *v1; // ebx
  int i; // esi

  if ( a1 )
    G_Printf("==== RestartGame ====\n");
  else
    G_Printf("==== ShutdownGame ====\n");
  if ( level[6] )
  {
    if ( a1 )
      G_LogPrintf("RestartGame:\n");
    else
      G_LogPrintf("ShutdownGame:\n");
    G_LogPrintf("------------------------------------------------------------\n");
    trap_FS_FCloseFile(level[6]);
  }
  v1 = g_entities;
  for ( i = 0; i < level[3]; v1 += 197 )
  {
    if ( *((_BYTE *)v1 + 352) )
      G_FreeEntity(v1);
    ++i;
  }
  if ( LOBYTE(g_entities[201422]) )
    G_FreeEntity(&g_entities[201334]);
  HudElem_DestroyAll();
  if ( Scr_IsSystemActive(1u) )
  {
    if ( !level[1876] )
      trap_FreeClientScriptPers();
    Scr_FreeGameVariable(level[1876] == 0);
    Scr_ShutdownSystem(1u);
  }
  GScr_FreeScripts();
  Scr_FreeScripts(1u);
  return trap_FreeWeaponInfoMemory(0);
}

//----- (0004FFBC) --------------------------------------------------------
int Com_Error(int a1, char *format, ...)
{
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+428h] [ebp+10h] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return G_Error("%s", s);
}

//----- (0004FFF8) --------------------------------------------------------
int Com_Printf(char *format, ...)
{
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return G_Printf("%s", s);
}

//----- (00050034) --------------------------------------------------------
int Com_DPrintf(char *format, ...)
{
  int result; // eax
  char s[1024]; // [esp+18h] [ebp-400h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  if ( g_developer[3] )
  {
    vsprintf(s, format, __varargs);
    result = G_Printf("%s", s);
  }
  return result;
}

//----- (00050078) --------------------------------------------------------
int __cdecl sub_50078(const void *a1, const void *a2)
{
  _DWORD *v2; // ebx
  _DWORD *v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  int v7; // eax

  v2 = (_DWORD *)(8900 * *(_DWORD *)a1 + level[0]);
  v3 = (_DWORD *)(level[0] + 8900 * *(_DWORD *)a2);
  if ( v2[2107] == 1 )
    return 1;
  if ( v3[2107] == 1 )
    return -1;
  if ( v2[2143] == 3 )
  {
    if ( v3[2143] != 3 )
      return 1;
    if ( v2 >= v3 )
      return v2 > v3;
    return -1;
  }
  if ( v3[2143] == 3 )
    return -1;
  v4 = v2[2104];
  v5 = v3[2104];
  if ( v4 > v5 )
    return -1;
  if ( v4 < v5 )
    return 1;
  v6 = v2[2105];
  v7 = v3[2105];
  if ( v6 < v7 )
    return -1;
  return v6 > v7;
}

//----- (0005010C) --------------------------------------------------------
int G_LogPrintf(char *format, ...)
{
  int result; // eax
  char *v2; // eax
  int v3; // ebx
  char v4[7]; // [esp+18h] [ebp-400h] BYREF
  char s[1017]; // [esp+1Fh] [ebp-3F9h] BYREF
  va_list __varargs; // [esp+424h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  Com_sprintf(v4, 0x400u, "%3i:%i%i ", level[122] / 1000 / 60, level[122] / 1000 % 60 / 10, level[122] / 1000 % 60 % 10);
  vsprintf(s, format, __varargs);
  result = level[6];
  if ( result )
  {
    v2 = v4;
    while ( 1 )
    {
      v3 = *(_DWORD *)v2;
      if ( !(unsigned __int8)*(_DWORD *)v2 )
        break;
      if ( !BYTE1(v3) )
        goto LABEL_9;
      if ( (v3 & 0xFF0000) == 0 )
        goto LABEL_8;
      v2 += 4;
      if ( (v3 & 0xFF000000) == 0 )
      {
        v2 -= 3;
LABEL_8:
        ++v2;
LABEL_9:
        ++v2;
        break;
      }
    }
    result = trap_FS_Write((int)v4, v2 - v4, level[6]);
  }
  return result;
}

//----- (000501F0) --------------------------------------------------------
int CheckVote()
{
  int v0; // eax
  char *v1; // eax
  int result; // eax

  v0 = level[711];
  if ( v0 )
  {
    if ( v0 < level[122] )
    {
      level[711] = 0;
      v1 = va((char *)off_756DF, &level[198]);
      trap_SendConsoleCommand(2, (int)v1);
    }
  }
  result = level[710];
  if ( result )
  {
    if ( level[122] - result < 0 )
    {
      result = level[714] / 2;
      if ( level[712] > result )
      {
        trap_SendServerCommand(-1, 0, (int)"e \"GAME_VOTEPASSED\"");
        level[711] = level[122] + 3000;
LABEL_10:
        level[710] = 0;
        return trap_SetConfigstring(15, (int)&unk_7543E);
      }
      if ( level[713] < result )
        return result;
    }
    trap_SendServerCommand(-1, 0, (int)"e \"GAME_VOTEFAILED\"");
    goto LABEL_10;
  }
  return result;
}

//----- (000502BC) --------------------------------------------------------
void __cdecl sub_502BC(void *s)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // [esp-Ch] [ebp-24h]
  int v6; // [esp-8h] [ebp-20h]
  int v7; // [esp-4h] [ebp-1Ch]
  int v8; // [esp+0h] [ebp-18h]
  int v9; // [esp+4h] [ebp-14h]
  int v10; // [esp+8h] [ebp-10h]
  int v11; // [esp+Ch] [ebp-Ch]
  int v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]
  int savedregs; // [esp+18h] [ebp+0h]

  v1 = level[121];
  if ( *((_DWORD *)s + 101) != v1 )
  {
    *((_DWORD *)s + 101) = v1;
    if ( !*((_DWORD *)s + 86) )
    {
      if ( (*((_BYTE *)s + 381) & 0x10) != 0 )
        *((_BYTE *)s + 9) |= 1u;
      else
        *((_BYTE *)s + 9) &= 0xFEu;
    }
    if ( level[122] - *((_DWORD *)s + 96) > 300 )
    {
      if ( *((_DWORD *)s + 97) )
      {
        G_FreeEntity(s);
        return;
      }
      if ( *((_DWORD *)s + 98) )
      {
        *((_DWORD *)s + 98) = 0;
        trap_UnlinkEntity((int)s);
      }
    }
    if ( (*((_BYTE *)s + 8) & 0x10) != 0 )
      *((_BYTE *)s + 245) |= 2u;
    else
      *((_BYTE *)s + 245) &= 0xFDu;
    if ( !*((_DWORD *)s + 97) )
    {
      v2 = *((_DWORD *)s + 1);
      if ( v2 == 4 )
      {
        G_RunMissile(s);
        return;
      }
      if ( v2 == 3 )
      {
        if ( *((_DWORD *)s + 185) )
        {
          G_GeneralLink((int)s);
          v3 = *((_DWORD *)s + 127);
          if ( v3 > 0 && v3 <= level[122] )
          {
            *((_DWORD *)s + 127) = 0;
            if ( !*((_DWORD *)s + 128) )
              G_Error("NULL ent->think");
            (*((void (__stdcall **)(void *, int, int, int, int, int, int, int, int, int, int))s + 128))(
              s,
              v5,
              v6,
              v7,
              v8,
              v9,
              v10,
              v11,
              v12,
              v13,
              savedregs);
          }
          return;
        }
LABEL_25:
        G_RunItem(s);
        return;
      }
      if ( *((_BYTE *)s + 353) )
        goto LABEL_25;
      if ( v2 == 5 || v2 == 8 )
      {
        G_RunMover((int)s);
      }
      else if ( *((_DWORD *)s + 86) )
      {
        G_RunClient((int)s);
      }
      else
      {
        v4 = *((_DWORD *)s + 127);
        if ( v4 > 0 && v4 <= level[122] )
        {
          *((_DWORD *)s + 127) = 0;
          if ( !*((_DWORD *)s + 128) )
            G_Error("NULL ent->think");
          (*((void (__stdcall **)(void *, int, int, int))s + 128))(s, v5, v6, v7);
        }
      }
    }
  }
}
// 503E1: variable 'v5' is possibly undefined
// 503E1: variable 'v6' is possibly undefined
// 503E1: variable 'v7' is possibly undefined
// 503E1: variable 'v8' is possibly undefined
// 503E1: variable 'v9' is possibly undefined
// 503E1: variable 'v10' is possibly undefined
// 503E1: variable 'v11' is possibly undefined
// 503E1: variable 'v12' is possibly undefined
// 503E1: variable 'v13' is possibly undefined
// 503E1: variable 'savedregs' is possibly undefined

//----- (00050478) --------------------------------------------------------
unsigned int __cdecl G_RunFrame(int a1)
{
  int v1; // ecx
  int v2; // esi
  void **i; // ebx
  char *v4; // eax
  void *v5; // edx
  int v6; // eax
  int *v7; // ebx
  int v8; // ecx
  int *v9; // esi
  int *v10; // edx
  int v11; // eax
  int *v12; // esi
  int j; // ebx
  int *v14; // esi
  int k; // ebx
  long double v16; // fst7
  char v17; // fps^1
  long double v18; // fst6
  bool v19; // c0
  char v20; // c2
  bool v21; // c3
  long double v22; // fst6
  char v23; // fps^1
  long double v24; // fst5
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  int *v28; // esi
  long double v29; // fst7
  long double v30; // fst7
  char v31; // fps^1
  long double v32; // fst6
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  long double v36; // fst6
  char v37; // fps^1
  long double v38; // fst5
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  long double v42; // fst6
  char v43; // fps^1
  long double v44; // fst5
  bool v45; // c0
  char v46; // c2
  bool v47; // c3
  int *v48; // esi
  int *l; // esi
  void **v50; // eax
  int v51; // eax
  int v52; // edx
  int v53; // eax
  int v54; // ebx
  int *v55; // edx
  int v56; // ebx
  int v57; // esi
  int v58; // edx
  int *v59; // esi
  int v60; // ebx
  int *v61; // esi
  int v62; // edi
  __int16 *v63; // ebx
  const char *v64; // eax
  unsigned int result; // eax
  float v66; // [esp-Ch] [ebp-454h]
  int *v67; // [esp+1Ch] [ebp-42Ch]
  int *v68; // [esp+20h] [ebp-428h]
  int v69; // [esp+24h] [ebp-424h]
  int v70; // [esp+28h] [ebp-420h]
  int v71; // [esp+30h] [ebp-418h]
  int v72; // [esp+34h] [ebp-414h]
  _BYTE v73[5]; // [esp+3Bh] [ebp-40Dh]
  int v74; // [esp+40h] [ebp-408h]
  int v75; // [esp+40h] [ebp-408h]
  int v76; // [esp+40h] [ebp-408h]
  int v77; // [esp+40h] [ebp-408h]
  int v78; // [esp+40h] [ebp-408h]
  int v79; // [esp+40h] [ebp-408h]
  char v80[1024]; // [esp+48h] [ebp-400h] BYREF

  v1 = level[122];
  ++level[121];
  level[123] = v1;
  level[122] = a1;
  level[124] = a1 - v1;
  bg = a1;
  *(&bg + 1) = a1;
  *(&bg + 2) = a1 - v1;
  v2 = 0;
  for ( i = &gameCvarTable; v2 < dword_7E4D0; i += 6 )
  {
    if ( *i )
    {
      trap_Cvar_Update(*i);
      v4 = (char *)*i;
      v5 = (void *)*((_DWORD *)*i + 1);
      if ( i[4] != v5 )
      {
        i[4] = v5;
        if ( i[5] )
        {
          v6 = va(aEGameServer, i[1], v4 + 16);
          trap_SendServerCommand(-1, 0, v6);
        }
      }
    }
    ++v2;
  }
  _bzero(v80, 0x400u);
  v73[0] = 0;
  do
  {
    v74 = 0;
    v73[4] = 0;
    *(_DWORD *)v73 = (unsigned __int8)(v73[0] + 1);
    if ( level[2683] > 0 )
    {
      v7 = &level[1915];
      while ( 1 )
      {
        v68 = v7;
        v8 = *(unsigned __int16 *)v7;
        v9 = &g_entities[197 * v8];
        if ( v9[192] != v7[1] )
          goto LABEL_15;
        v10 = &g_entities[197 * *((unsigned __int16 *)v7 + 1)];
        if ( v10[192] != v7[2] )
          goto LABEL_15;
        if ( v80[v8] != v73[0] )
          break;
        *(_DWORD *)&v73[1] = 1;
LABEL_16:
        ++v74;
        v7 += 3;
        if ( v74 >= level[2683] )
          goto LABEL_17;
      }
      v80[v8] = v73[0];
      Scr_AddEntity(v10);
      Scr_Notify(v9, scr_const[73], 1);
LABEL_15:
      --level[2683];
      --v74;
      v11 = 3 * level[2683];
      *v7 = level[v11 + 1915];
      v7[1] = level[v11 + 1916];
      v7 -= 3;
      v68[2] = level[v11 + 1917];
      goto LABEL_16;
    }
LABEL_17:
    Scr_RunCurrentThreads();
  }
  while ( *(_DWORD *)&v73[1] );
  level[2683] = 0;
  v12 = g_entities;
  for ( j = 0; j < level[3]; v12 += 197 )
  {
    if ( *((_BYTE *)v12 + 352) )
    {
      v66 = (long double)level[124] * 0.001;
      trap_DObjInitServerTime(v12, LODWORD(v66));
    }
    ++j;
  }
  v14 = g_entities;
  for ( k = 0; k < level[3]; v14 += 197 )
  {
    ++k;
    while ( *((_BYTE *)v14 + 352) && (*((_BYTE *)v14 + 381) & 0x40) == 0 && G_DObjUpdateServerTime(v14, 1) )
      Scr_RunCurrentThreads();
  }
  Scr_SetTime(level[122]);
  v16 = *(float *)&level[2687];
  v18 = g_bounds_width[2];
  v19 = v18 < v16;
  v20 = 0;
  v21 = v18 == v16;
  if ( (v17 & 0x44) != 0x40
    || (v22 = *(float *)&level[2688],
        v24 = g_bounds_height_standing[2],
        v25 = v24 < v22,
        v26 = 0,
        v27 = v24 == v22,
        (v23 & 0x45) != 64) )
  {
    level[2687] = SLODWORD(g_bounds_width[2]);
    level[2688] = SLODWORD(g_bounds_height_standing[2]);
    G_SetPlayerSize();
    v28 = g_entities;
    v75 = 63;
    do
    {
      if ( *((_BYTE *)v28 + 352) )
      {
        v29 = playerMins[0];
        v28[64] = SLODWORD(playerMins[0]);
        v28[65] = SLODWORD(playerMins[1]);
        v28[66] = SLODWORD(playerMins[2]);
        v28[67] = SLODWORD(playerMaxs[0]);
        v28[68] = SLODWORD(playerMaxs[1]);
        v28[69] = SLODWORD(playerMaxs[2]);
        *(float *)(v28[86] + 804) = v29;
        *(float *)(v28[86] + 808) = *((float *)v28 + 65);
        *(float *)(v28[86] + 812) = *((float *)v28 + 66);
        *(float *)(v28[86] + 816) = *((float *)v28 + 67);
        *(float *)(v28[86] + 820) = *((float *)v28 + 68);
        *(float *)(v28[86] + 824) = *((float *)v28 + 69);
        trap_LinkEntity(v28);
      }
      v28 += 197;
      --v75;
    }
    while ( v75 >= 0 );
  }
  v30 = *(float *)&level[2689];
  v32 = bg_viewheight_standing[2];
  v33 = v32 < v30;
  v34 = 0;
  v35 = v32 == v30;
  if ( (v31 & 0x44) != 0x40 )
    goto LABEL_38;
  v36 = *(float *)&level[2690];
  v38 = bg_viewheight_crouched[2];
  v39 = v38 < v36;
  v40 = 0;
  v41 = v38 == v36;
  if ( (v37 & 0x44) != 0x40
    || (v42 = *(float *)&level[2691],
        v44 = bg_viewheight_prone[2],
        v45 = v44 < v42,
        v46 = 0,
        v47 = v44 == v42,
        (v43 & 0x45) != 64) )
  {
LABEL_38:
    level[2689] = SLODWORD(bg_viewheight_standing[2]);
    level[2690] = SLODWORD(bg_viewheight_crouched[2]);
    level[2691] = SLODWORD(bg_viewheight_prone[2]);
    v48 = g_entities;
    v76 = 63;
    do
    {
      if ( *((_BYTE *)v48 + 352) )
      {
        *(float *)(v48[86] + 828) = bg_viewheight_prone[3];
        *(float *)(v48[86] + 832) = bg_viewheight_crouched[3];
        *(float *)(v48[86] + 836) = bg_viewheight_standing[3];
      }
      v48 += 197;
      --v76;
    }
    while ( v76 >= 0 );
  }
  v77 = 0;
  for ( l = g_entities; v77 < level[3]; l += 197 )
  {
    if ( *((_BYTE *)l + 352) )
    {
      v50 = (void **)l[185];
      if ( v50 )
        sub_502BC(*v50);
      sub_502BC(l);
    }
    ++v77;
  }
  v51 = level[120];
  v52 = 0;
  if ( v51 > 0 )
  {
    do
    {
      v53 = level[1] + 788 * v52;
      v70 = v52 + 1;
      if ( *(_BYTE *)(v53 + 352) )
      {
        v54 = *(_DWORD *)(v53 + 344);
        v55 = &level[13];
        v72 = *(_DWORD *)(v54 + 8572);
        v67 = &level[8];
        v69 = 0;
        v71 = 15;
        do
        {
          if ( *(v55 - 5) && (!*v55 || *v55 == v72) )
            qmemcpy((void *)(v69 + v54 + 1000), v67, 0x1Cu);
          else
            *(_DWORD *)(v54 + v69 + 1000) = 0;
          v55 += 7;
          v67 += 7;
          v69 += 28;
          --v71;
        }
        while ( v71 >= 0 );
      }
      v52 = v70;
      v51 = level[120];
    }
    while ( v70 < v51 );
  }
  v56 = 0;
  if ( v51 > 0 )
  {
    v57 = 0;
    do
    {
      v58 = level[1] + v57;
      if ( *(_BYTE *)(v58 + 352) )
        HudElem_UpdateClient(*(_DWORD *)(v58 + 344), *(_DWORD *)v58, 3);
      v51 = level[120];
      v57 += 788;
      ++v56;
    }
    while ( v56 < v51 );
  }
  v59 = g_entities;
  v78 = 0;
  if ( v51 > 0 )
  {
    do
    {
      if ( *((_BYTE *)v59 + 352) )
        ClientEndFrame((int)v59);
      ++v78;
      v59 += 197;
    }
    while ( v78 < level[120] );
  }
  CheckTeamStatus();
  CheckVote();
  if ( level[131] )
  {
    v60 = 0;
    if ( level[120] > 0 )
    {
      v61 = g_entities;
      v62 = 0;
      do
      {
        if ( *(_DWORD *)(level[0] + v62 + 8428) == 2 && *(_DWORD *)(level[0] + v62 + 4) == 5 )
          DeathmatchScoreboardMessage(v61);
        v61 += 197;
        v62 += 8900;
        ++v60;
      }
      while ( v60 < level[120] );
    }
    level[131] = 0;
  }
  if ( g_listEntity[3] )
  {
    v79 = 0;
    v63 = (__int16 *)&g_entities[93] + 1;
    do
    {
      v64 = (const char *)SL_ConvertToString(*v63);
      G_Printf("%4i: %s\n", v79, v64);
      v63 += 394;
      ++v79;
    }
    while ( v79 <= 1023 );
    trap_Cvar_Set("g_listEntity", "0");
  }
  if ( level[2692] )
    SaveRegisteredItems();
  result = g_dumpAnims[3];
  if ( result <= 0x3FF )
    result = trap_DObjDisplayAnim(level[1] + 788 * result);
  return result;
}
// 50724: variable 'v17' is possibly undefined
// 5073E: variable 'v23' is possibly undefined
// 5085D: variable 'v31' is possibly undefined
// 50877: variable 'v37' is possibly undefined
// 5088F: variable 'v43' is possibly undefined
// 42FD4: using guessed type int G_SetPlayerSize(void);
// 459C0: using guessed type _DWORD __cdecl DeathmatchScoreboardMessage(_DWORD);
// 4BE8C: using guessed type _DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD);
// 4EF08: using guessed type int SaveRegisteredItems(void);
// 501F0: using guessed type int CheckVote(void);
// 61EA8: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 61F54: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, __int16, _DWORD);
// 63558: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 63574: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 63648: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 63A40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 6425C: using guessed type _DWORD __cdecl trap_DObjInitServerTime(_DWORD, _DWORD);
// 64390: using guessed type _DWORD __cdecl trap_DObjDisplayAnim(_DWORD);
// 64BE4: using guessed type int CheckTeamStatus(void);
// 670FC: using guessed type _DWORD __cdecl G_DObjUpdateServerTime(_DWORD, _DWORD);
// 6C400: using guessed type _DWORD __cdecl SL_ConvertToString(__int16);
// 6C4AC: using guessed type int Scr_RunCurrentThreads(void);
// 7DE28: using guessed type void *gameCvarTable;
// 7E4D0: using guessed type int dword_7E4D0;
// C13A0: using guessed type int bg;
// 21DF80: using guessed type int g_entities[];

//----- (00050BF0) --------------------------------------------------------
void SendScoreboardMessageToAllIntermissionClients()
{
  int v0; // ebx
  int *v1; // esi
  int v2; // edi

  if ( level[131] )
  {
    v0 = 0;
    if ( level[120] > 0 )
    {
      v1 = g_entities;
      v2 = 0;
      do
      {
        if ( *(_DWORD *)(level[0] + v2 + 8428) == 2 && *(_DWORD *)(level[0] + v2 + 4) == 5 )
          DeathmatchScoreboardMessage((int)v1);
        v1 += 197;
        v2 += 8900;
        ++v0;
      }
      while ( v0 < level[120] );
    }
    level[131] = 0;
  }
}

//----- (00050C60) --------------------------------------------------------
void CalculateRanks()
{
  int v0; // ecx
  int v1; // edx
  int v2; // eax

  level[133] = 0;
  level[714] = 0;
  v0 = 0;
  if ( level[120] > 0 )
  {
    v1 = 0;
    do
    {
      if ( *(_DWORD *)(level[0] + v1 + 8428) )
      {
        level[level[133] + 134] = v0;
        v2 = level[0];
        ++level[133];
        if ( *(_DWORD *)(v2 + v1 + 8572) != 3 && *(_DWORD *)(v2 + v1 + 8428) == 2 )
          ++level[714];
      }
      v1 += 8900;
      ++v0;
    }
    while ( v0 < level[120] );
  }
  qsort(&level[134], level[133], 4u, sub_50078);
  level[131] = 1;
}

//----- (00050D08) --------------------------------------------------------
int __cdecl G_RunThink(int a1)
{
  int result; // eax
  int v2; // [esp-Ch] [ebp-24h]
  int v3; // [esp-8h] [ebp-20h]
  int v4; // [esp-4h] [ebp-1Ch]

  result = *(_DWORD *)(a1 + 508);
  if ( result > 0 && result <= level[122] )
  {
    *(_DWORD *)(a1 + 508) = 0;
    if ( !*(_DWORD *)(a1 + 512) )
      G_Error("NULL ent->think");
    result = (*(int (__stdcall **)(int, int, int, int))(a1 + 512))(a1, v2, v3, v4);
  }
  return result;
}
// 50D51: variable 'v2' is possibly undefined
// 50D51: variable 'v3' is possibly undefined
// 50D51: variable 'v4' is possibly undefined

//----- (00050D5C) --------------------------------------------------------
void G_UpdateCvars()
{
  int v0; // esi
  int *i; // ebx
  int v2; // eax
  int v3; // edx
  char *v4; // eax

  v0 = 0;
  for ( i = (int *)&gameCvarTable; v0 < dword_7E4D0; i += 6 )
  {
    if ( *i )
    {
      trap_Cvar_Update(*i);
      v2 = *i;
      v3 = *(_DWORD *)(*i + 4);
      if ( i[4] != v3 )
      {
        i[4] = v3;
        if ( i[5] )
        {
          v4 = va(aEGameServer, i[1], v2 + 16);
          trap_SendServerCommand(-1, 0, (int)v4);
        }
      }
    }
    ++v0;
  }
}
// 7DE28: using guessed type void *gameCvarTable;
// 7E4D0: using guessed type int dword_7E4D0;

//----- (00050DD4) --------------------------------------------------------
int __cdecl vmMain(int a1, int a2, unsigned int seed, int a4, int a5)
{
  int v5; // esi

  v5 = 0;
  switch ( a1 )
  {
    case 0:
      G_InitGame(a2, seed, a4, a5);
      break;
    case 1:
      G_ShutdownGame(a2);
      break;
    case 2:
      v5 = (int)ClientConnect(a2, seed);
      break;
    case 3:
      ClientBegin(a2);
      break;
    case 4:
      ClientUserinfoChanged(a2);
      break;
    case 5:
      ClientDisconnect(a2);
      break;
    case 6:
      ClientCommand(a2);
      break;
    case 7:
      ClientThink(a2);
      break;
    case 8:
      v5 = GetFollowPlayerState(a2, seed);
      break;
    case 9:
      G_UpdateCvars();
      break;
    case 10:
      G_RunFrame(a2);
      break;
    case 11:
      v5 = ConsoleCommand();
      break;
    case 12:
      v5 = (int)Scr_FarHook((const void *)a2);
      break;
    case 13:
      G_DObjCalcPose((_DWORD *)(level[1] + 788 * a2));
      break;
    case 14:
      v5 = a2 >= 0 && a2 <= BG_GetNumWeapons();
      break;
    case 15:
      level[1876] = a2;
      break;
    case 16:
      v5 = level[1876];
      break;
    case 17:
      v5 = level[0] + 8900 * a2 + 8568;
      break;
    case 18:
      v5 = *(_DWORD *)(level[0] + 8900 * a2 + 8412);
      break;
    case 19:
      *(_DWORD *)(level[0] + 8900 * a2 + 8412) = seed;
      break;
    case 20:
      v5 = *(_DWORD *)(level[0] + 8900 * a2 + 8416);
      break;
    default:
      v5 = -1;
      break;
  }
  return v5;
}
// 487EC: using guessed type _DWORD __cdecl ClientCommand(_DWORD);

//----- (00050F88) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  return (int)(*((float *)a1 + 1) - *((float *)a2 + 1));
}

//----- (00050FBC) --------------------------------------------------------
int G_RegisterCvars()
{
  int v0; // esi
  int *i; // ebx
  int result; // eax

  v0 = 0;
  for ( i = (int *)&gameCvarTable; v0 < dword_7E4D0; i += 6 )
  {
    trap_Cvar_Register(*i, i[1], i[2]);
    if ( *i )
      i[4] = *(_DWORD *)(*i + 4);
    ++v0;
  }
  result = Scr_IsValidGameType(&g_gametype[16]);
  if ( !result )
  {
    G_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", &g_gametype[16]);
    trap_Cvar_Set((int)"g_gametype", (int)"dm");
    result = trap_Cvar_Update((int)g_gametype);
  }
  return result;
}
// 7DE28: using guessed type void *gameCvarTable;
// 7E4D0: using guessed type int dword_7E4D0;

//----- (00051054) --------------------------------------------------------
void *G_FreeEntities()
{
  int *v0; // ebx
  int i; // esi
  void *result; // eax

  v0 = g_entities;
  for ( i = 0; i < level[3]; v0 += 197 )
  {
    if ( *((_BYTE *)v0 + 352) )
      result = G_FreeEntity(v0);
    ++i;
  }
  if ( LOBYTE(g_entities[201422]) )
    result = G_FreeEntity(&g_entities[201334]);
  return result;
}

//----- (000510B4) --------------------------------------------------------
int ExitLevel()
{
  int v0; // ecx
  int v1; // edx
  int v2; // ecx
  int v3; // edx

  trap_SendConsoleCommand(2, (int)"map_rotate\n");
  level[127] = 0;
  level[128] = 0;
  v0 = 0;
  if ( (int)g_maxclients[3] > 0 )
  {
    v1 = 0;
    do
    {
      if ( *(_DWORD *)(level[0] + v1 + 8428) == 2 )
        *(_DWORD *)(level[0] + v1 + 8416) = 0;
      v1 += 8900;
      ++v0;
    }
    while ( v0 < g_maxclients[3] );
  }
  v2 = 0;
  if ( (int)g_maxclients[3] > 0 )
  {
    v3 = 0;
    do
    {
      if ( *(_DWORD *)(level[0] + v3 + 8428) == 2 )
        *(_DWORD *)(level[0] + v3 + 8428) = 1;
      v3 += 8900;
      ++v2;
    }
    while ( v2 < g_maxclients[3] );
  }
  return G_LogPrintf("ExitLevel: executed\n");
}

//----- (00051160) --------------------------------------------------------
int __usercall G_UpdateObjectiveToClients@<eax>(int result@<eax>)
{
  int v1; // edx
  int v2; // ebx
  int *v3; // edx
  int *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v1 = 0;
  if ( level[120] > 0 )
  {
    do
    {
      result = level[1] + 788 * v1;
      v6 = v1 + 1;
      if ( *(_BYTE *)(result + 352) )
      {
        v2 = *(_DWORD *)(result + 344);
        v3 = &level[13];
        v7 = *(_DWORD *)(v2 + 8572);
        v4 = &level[8];
        v5 = 0;
        for ( i = 15; i >= 0; --i )
        {
          if ( *(v3 - 5) && ((result = *v3) == 0 || result == v7) )
          {
            qmemcpy((void *)(v5 + v2 + 1000), v4, 0x1Cu);
          }
          else
          {
            result = v5;
            *(_DWORD *)(v2 + v5 + 1000) = 0;
          }
          v3 += 7;
          v4 += 7;
          v5 += 28;
        }
      }
      v1 = v6;
    }
    while ( v6 < level[120] );
  }
  return result;
}

//----- (0005121C) --------------------------------------------------------
int G_UpdateHudElemsToClients()
{
  int v0; // ebx
  int v1; // esi
  int v2; // edx
  int result; // eax

  v0 = 0;
  if ( level[120] > 0 )
  {
    v1 = 0;
    do
    {
      v2 = level[1] + v1;
      if ( *(_BYTE *)(v2 + 352) )
        result = HudElem_UpdateClient(*(_DWORD **)(v2 + 344), *(_DWORD *)v2, 3);
      v1 += 788;
      ++v0;
    }
    while ( v0 < level[120] );
  }
  return result;
}

//----- (00051270) --------------------------------------------------------
unsigned int DebugDumpAnims()
{
  unsigned int result; // eax

  result = g_dumpAnims[3];
  if ( result <= 0x3FF )
    result = trap_DObjDisplayAnim((_DWORD *)(level[1] + 788 * result));
  return result;
}

//----- (0005129C) --------------------------------------------------------
void __cdecl G_XAnimUpdateEnt(int a1)
{
  while ( *(_BYTE *)(a1 + 352) && (*(_BYTE *)(a1 + 381) & 0x40) == 0 && G_DObjUpdateServerTime((_DWORD *)a1, 1) )
    Scr_RunCurrentThreads();
}

//----- (000512D8) --------------------------------------------------------
int G_XAnimUpdate()
{
  int result; // eax
  int *v1; // esi
  int i; // ebx
  int *v3; // esi
  int v4; // ebx
  int v5; // [esp-Ch] [ebp-24h]

  result = level[3];
  v1 = g_entities;
  for ( i = 0; i < result; v1 += 197 )
  {
    if ( *((_BYTE *)v1 + 352) )
    {
      *(float *)&v5 = (long double)level[124] * 0.001;
      trap_DObjInitServerTime(v1, v5);
    }
    result = level[3];
    ++i;
  }
  v3 = g_entities;
  v4 = 0;
  if ( result > 0 )
  {
    do
    {
      ++v4;
      while ( *((_BYTE *)v3 + 352) )
      {
        if ( (*((_BYTE *)v3 + 381) & 0x40) != 0 )
          break;
        result = G_DObjUpdateServerTime(v3, 1);
        if ( !result )
          break;
        result = Scr_RunCurrentThreads();
      }
      v3 += 197;
    }
    while ( v4 < level[3] );
  }
  return result;
}

//----- (00051380) --------------------------------------------------------
float *__cdecl TeleportPlayer(int a1, float *a2, float *a3)
{
  int v3; // eax
  int v4; // ebx
  float *result; // eax

  v3 = *(_DWORD *)(a1 + 344);
  if ( !*(_DWORD *)(v3 + 8400) )
  {
    G_TempEntity((float *)(v3 + 20), 200)[36] = *(_DWORD *)(a1 + 144);
    G_TempEntity(a2, 199)[36] = *(_DWORD *)(a1 + 144);
  }
  v4 = *(_DWORD *)(a1 + 240);
  trap_UnlinkEntity(a1);
  *(float *)(*(_DWORD *)(a1 + 344) + 20) = *a2;
  *(float *)(*(_DWORD *)(a1 + 344) + 24) = a2[1];
  *(float *)(*(_DWORD *)(a1 + 344) + 28) = a2[2];
  *(float *)(*(_DWORD *)(a1 + 344) + 28) = *(float *)(*(_DWORD *)(a1 + 344) + 28) + 1.0;
  *(_BYTE *)(*(_DWORD *)(a1 + 344) + 128) ^= 8u;
  SetClientViewAngle(a1, a3);
  BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 344), a1, 1);
  result = *(float **)(a1 + 344);
  *(float *)(a1 + 308) = result[5];
  *(float *)(a1 + 312) = result[6];
  *(float *)(a1 + 316) = result[7];
  if ( v4 )
    result = (float *)trap_LinkEntity(a1);
  return result;
}

//----- (00051488) --------------------------------------------------------
int __cdecl sub_51488(_DWORD *a1, int a2, float *a3)
{
  int result; // eax
  long double v4; // fst7
  long double v5; // rt1
  const char *v6; // [esp-14h] [ebp-BCh]
  const char *v7; // [esp-14h] [ebp-BCh]
  float v8[3]; // [esp+1Ch] [ebp-8Ch] BYREF
  char v9[48]; // [esp+28h] [ebp-80h] BYREF
  float v10; // [esp+58h] [ebp-50h]
  float v11; // [esp+5Ch] [ebp-4Ch]
  float v12; // [esp+60h] [ebp-48h]
  char v13[48]; // [esp+68h] [ebp-40h] BYREF
  float v14; // [esp+98h] [ebp-10h]
  float v15; // [esp+9Ch] [ebp-Ch]
  float v16; // [esp+A0h] [ebp-8h]

  if ( !G_DObjGetWorldTagMatrix((int)a1, (int)"tag_flash", (int)v13) )
  {
    v6 = (const char *)SL_ConvertToString(*((_WORD *)a1 + 187));
    Com_Printf("Couldn't find %s on turret (entity %d, classname '%s').\n", "tag_flash", *a1, v6);
    return 0;
  }
  if ( !G_DObjGetWorldTagMatrix((int)a1, (int)"tag_player", (int)v9) )
  {
    v7 = (const char *)SL_ConvertToString(*((_WORD *)a1 + 187));
    Com_Printf("Couldn't find %s on turret (entity %d, classname '%s').\n", "tag_player", *a1, v7);
    return 0;
  }
  AngleVectors((float *)(*(_DWORD *)(a2 + 344) + 192), a3, a3 + 3, a3 + 6);
  a3[12] = *a3;
  a3[13] = a3[1];
  a3[14] = a3[2];
  v8[0] = v14 - v10;
  v8[1] = v15 - v11;
  v8[2] = v16 - v12;
  v4 = VectorNormalize(v8);
  a3[9] = *a3 * v4 + v10;
  v5 = v4 * a3[2];
  a3[10] = a3[1] * v4 + v11;
  result = 1;
  a3[11] = v5 + v12;
  return result;
}

//----- (000515A8) --------------------------------------------------------
int __cdecl sub_515A8(int a1, int a2)
{
  int result; // eax
  char *v3; // ebx
  __int16 v4; // ax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst5
  long double v8; // rt0
  long double v9; // fst5
  long double v10; // rt1
  long double v11; // fst5
  long double v12; // fst7
  long double v13; // rt1
  long double v14; // fst5
  long double v15; // fst6
  int v16; // eax
  int v17; // esi
  int v18; // ebx
  int v19; // eax
  long double v20; // fst7
  char v21; // fps^1
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  int v25; // ebx
  unsigned __int16 v26; // di
  char v27; // fps^1
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  char v31; // fps^1
  bool v32; // c0
  char v33; // c2
  bool v34; // c3
  int v35; // esi
  unsigned __int16 v36; // di
  char v37; // fps^1
  bool v38; // c0
  char v39; // c2
  bool v40; // c3
  float *v41; // eax
  float *v42; // eax
  float v43; // [esp-20h] [ebp-1B8h]
  int v44; // [esp-18h] [ebp-1B0h]
  int v45; // [esp-18h] [ebp-1B0h]
  int v46; // [esp+30h] [ebp-168h]
  unsigned __int16 v47; // [esp+34h] [ebp-164h]
  unsigned __int16 v48; // [esp+34h] [ebp-164h]
  unsigned __int16 v49; // [esp+38h] [ebp-160h]
  int v50; // [esp+38h] [ebp-160h]
  int v51; // [esp+3Ch] [ebp-15Ch]
  float *v52; // [esp+40h] [ebp-158h]
  int v53; // [esp+44h] [ebp-154h]
  float v54; // [esp+48h] [ebp-150h]
  int v55; // [esp+48h] [ebp-150h]
  float v56; // [esp+4Ch] [ebp-14Ch]
  float v57; // [esp+4Ch] [ebp-14Ch]
  int v58; // [esp+4Ch] [ebp-14Ch]
  float v59; // [esp+50h] [ebp-148h]
  float v60; // [esp+54h] [ebp-144h]
  float v61; // [esp+58h] [ebp-140h]
  float v62; // [esp+5Ch] [ebp-13Ch]
  int v63; // [esp+60h] [ebp-138h]
  int v64; // [esp+64h] [ebp-134h]
  int v65; // [esp+68h] [ebp-130h]
  int v66; // [esp+6Ch] [ebp-12Ch]
  int v67; // [esp+70h] [ebp-128h] BYREF
  int v68; // [esp+74h] [ebp-124h] BYREF
  int v69; // [esp+78h] [ebp-120h] BYREF
  float v70[2]; // [esp+7Ch] [ebp-11Ch] BYREF
  int v71; // [esp+84h] [ebp-114h] BYREF
  int v72; // [esp+88h] [ebp-110h] BYREF
  int v73[5]; // [esp+8Ch] [ebp-10Ch] BYREF
  __int16 v74; // [esp+A0h] [ebp-F8h]
  __int16 v75; // [esp+A2h] [ebp-F6h]
  int v76; // [esp+A4h] [ebp-F4h]
  float v77[15]; // [esp+A8h] [ebp-F0h] BYREF
  float v78[2]; // [esp+E4h] [ebp-B4h] BYREF
  float v79; // [esp+ECh] [ebp-ACh]
  float v80; // [esp+F0h] [ebp-A8h]
  float v81; // [esp+F4h] [ebp-A4h]
  float v82; // [esp+F8h] [ebp-A0h]
  float v83[12]; // [esp+FCh] [ebp-9Ch] BYREF
  int v84[12]; // [esp+12Ch] [ebp-6Ch] BYREF
  float v85[12]; // [esp+15Ch] [ebp-3Ch] BYREF
  float v86[2]; // [esp+18Ch] [ebp-Ch] BYREF
  float v87; // [esp+194h] [ebp-4h]

  result = 1096 * *(_DWORD *)(a1 + 144);
  v3 = (char *)&bgs[159163] + result;
  if ( *((_DWORD *)v3 + 227) )
  {
    result = *((_DWORD *)v3 + 228);
    if ( result )
    {
      if ( (*(_BYTE *)(result + 80) & 4) != 0 )
      {
        v52 = (float *)G_DObjGetLocalTagMatrix((_DWORD *)a2, (int)"tag_weapon");
        if ( !v52 )
          return Com_Printf("WARNING: aborting player positioning on turret since 'tag_weapon' does not exist\n");
        v63 = BG_GetInfoForWeapon(*(_DWORD *)(a2 + 200));
        v51 = *((_DWORD *)v3 + 272);
        v50 = (Scr_GetAnimsIndex(bgs[159152]) << 16) | v49;
        v4 = *((_WORD *)v3 + 454);
        HIBYTE(v4) &= 0xFDu;
        LOWORD(v50) = v4;
        v62 = vectosignedyaw(v52);
        AnglesToAxis((float *)(a2 + 320), v85);
        v5 = *(float *)(a2 + 308);
        v85[9] = *(float *)(a2 + 308);
        v6 = *(float *)(a2 + 312);
        v85[10] = *(float *)(a2 + 312);
        v7 = *(float *)(a2 + 316);
        v85[11] = *(float *)(a2 + 316);
        v8 = v7;
        v9 = *(float *)(a1 + 308) - v5;
        v80 = v9;
        v10 = v9;
        v11 = *(float *)(a1 + 312) - v6;
        v81 = v11;
        v12 = v10 * v85[6];
        v13 = v11 * v85[7];
        v14 = *(float *)(a1 + 316) - v8;
        v82 = v14;
        v15 = v12 + v13 + v14 * v85[8];
        v61 = v15 - v52[14];
        trap_XAnimClearTreeGoalWeightsStrict(v51, v50, 0);
        v60 = 0.0;
        v59 = 0.0;
        v65 = trap_XAnimGetNumChildren(v50);
        v64 = 0;
        v47 = 0;
        if ( !v65 )
        {
          v16 = trap_XAnimGetAnimName(v50);
          Com_Error(1, (char *)&byte_75860, v16);
        }
        v66 = 0;
        do
        {
          trap_XAnimGetChildAt(v73, v50, v66);
          v17 = v73[0];
          trap_XAnimSetGoalWeight(v51, v73[0], 1065353216);
          v18 = trap_XAnimGetNumChildren(v17);
          if ( !v18 )
          {
            v19 = trap_XAnimGetAnimName(v17);
            Com_Error(1, (char *)&byte_75860, v19);
          }
          v76 = v18;
          v56 = (long double)v18 * 0.5;
          v57 = v56 - v62 / *(float *)(v63 + 1024);
          v20 = 0.0;
          if ( v57 < 0.0
            || (v76 = v18 - 1,
                v20 = (long double)(v18 - 1),
                v22 = v20 < v57,
                v23 = 0,
                v24 = v20 == v57,
                (unsigned __int8)((v21 & 0x45) - 1) < 0x40u) )
          {
            v57 = v20;
          }
          v74 = v75 | 0xC00;
          v25 = (int)v57;
          v76 = v25;
          *(float *)&v58 = v57 - (long double)v25;
          trap_XAnimGetChildAt(&v72, v17, v25);
          v26 = v72;
          *(float *)&v46 = 1.0 - *(float *)&v58;
          trap_XAnimSetGoalWeight(v51, v72, v46);
          v28 = *(float *)&v58 < 0.0;
          v29 = 0;
          v30 = *(float *)&v58 == 0.0;
          if ( (v27 & 0x45) != 64 )
          {
            trap_XAnimGetChildAt(&v71, v17, v25 + 1);
            v47 = v71;
            trap_XAnimSetGoalWeight(v51, v71, v58);
          }
          trap_XAnimCalcAbsDelta(v51, v17, (int)v70);
          if ( v87 >= (long double)v61 )
            break;
          v60 = v87;
          v59 = *(float *)&v58;
          v64 = v25;
          ++v66;
        }
        while ( v66 < v65 );
        trap_XAnimClearTreeGoalWeightsStrict(v51, v50, 0);
        trap_XAnimGetWeight(v51, v26);
        v76 = level[124];
        trap_XAnimSetGoalWeight(v51, v26, v46);
        v32 = *(float *)&v58 < 0.0;
        v33 = 0;
        v34 = *(float *)&v58 == 0.0;
        if ( (v31 & 0x45) != 64 )
        {
          trap_XAnimGetWeight(v51, v47);
          trap_XAnimSetGoalWeight(v51, v47, v58);
        }
        if ( v66 && v66 != v65 )
        {
          v54 = v61 - v60;
          *(float *)&v55 = v54 / (v87 - v60);
          trap_XAnimGetWeight(v51, v17);
          trap_XAnimSetGoalWeight(v51, v17, v55);
          trap_XAnimGetChildAt(&v69, v50, v66 - 1);
          v35 = v69;
          trap_XAnimGetWeight(v51, v69);
          v76 = level[124];
          *(float *)&v44 = 1.0 - *(float *)&v55;
          trap_XAnimSetGoalWeight(v51, v35, v44);
          trap_XAnimGetChildAt(&v68, v35, v64);
          v36 = v68;
          trap_XAnimGetWeight(v51, v68);
          *(float *)&v45 = 1.0 - v59;
          trap_XAnimSetGoalWeight(v51, v36, v45);
          v38 = v59 < 0.0;
          v39 = 0;
          v40 = v59 == 0.0;
          if ( (v37 & 0x45) != 64 )
          {
            trap_XAnimGetChildAt(&v67, v35, v64 + 1);
            v48 = v67;
            trap_XAnimGetWeight(v51, v67);
            trap_XAnimSetGoalWeight(v51, v48, SLODWORD(v59));
          }
        }
        else
        {
          if ( !G_DObjGetLocalTagMatrix((_DWORD *)a2, (int)"tag_aim") )
            return Com_Printf("WARNING: aborting player positioning on turret since 'tag_aim' does not exist\n");
          trap_XAnimGetWeight(v51, v17);
          trap_XAnimSetGoalWeight(v51, v17, COERCE_INT(1.0));
        }
        trap_XAnimCalcAbsDelta(v51, v50, (int)v70);
        VectorAngleMultiply((int)v86, v62);
        *(float *)&v84[9] = v86[0] + v52[12];
        *(float *)&v84[10] = v86[1] + v52[13];
        *(float *)&v53 = v15;
        v84[11] = v53;
        v43 = RotationToYaw(v70) + v62;
        YawToAxis(v43, (int)v84);
        MatrixMultiply43((float *)v84, v85, v83);
        *(float *)(*(_DWORD *)(a1 + 344) + 20) = v83[9];
        *(float *)(*(_DWORD *)(a1 + 344) + 24) = v83[10];
        *(float *)(*(_DWORD *)(a1 + 344) + 28) = v83[11];
        v41 = *(float **)(a1 + 344);
        v78[0] = v41[5];
        v78[1] = v41[6];
        v79 = v41[7];
        v77[12] = v41[5];
        v77[13] = v41[6];
        v77[14] = v41[7];
        v79 = *(float *)(a2 + 316);
        trap_Trace((int)v77, (int)v78, 0);
        if ( v77[0] < 1.0 )
          *(float *)(*(_DWORD *)(a1 + 344) + 28) = v77[3];
        BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 344), a1, 1);
        v42 = *(float **)(a1 + 344);
        *(float *)(a1 + 308) = v42[5];
        *(float *)(a1 + 312) = v42[6];
        *(float *)(a1 + 316) = v42[7];
        AxisToAngles(v83, a1 + 320);
        result = trap_LinkEntity(a1);
      }
    }
  }
  return result;
}
// 5165E: variable 'v49' is possibly undefined
// 518A6: variable 'v21' is possibly undefined
// 5196F: variable 'v27' is possibly undefined
// 51ABC: variable 'v31' is possibly undefined
// 51DBC: variable 'v37' is possibly undefined
// C13C0: using guessed type int bgs[];

//----- (0005201C) --------------------------------------------------------
int __cdecl sub_5201C(int a1, int a2)
{
  int v2; // esi
  float *v3; // edi
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  bool v10; // zf
  long double v11; // fst7
  int v12; // ebx
  long double v13; // fst7
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  long double v18; // fst7
  int result; // eax
  long double v20; // fst7
  int v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+20h] [ebp-28h]
  int v23; // [esp+24h] [ebp-24h]
  float v24; // [esp+28h] [ebp-20h] BYREF
  float v25; // [esp+2Ch] [ebp-1Ch]
  float v26[3]; // [esp+3Ch] [ebp-Ch] BYREF

  v2 = 0;
  v21 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(*(_DWORD *)(a2 + 344) + 884) = 1;
  *(_DWORD *)(*(_DWORD *)(a2 + 344) + 888) = *(_DWORD *)a1;
  v3 = &v24;
  *(_DWORD *)(*(_DWORD *)(a2 + 344) + 896) = 0;
  v22 = 0;
  v23 = 1;
  do
  {
    v4 = AngleSubtract(*(float *)(v2 + *(_DWORD *)(a2 + 344) + 192), *(float *)(v2 + a1 + 320));
    *v3 = v4;
    v6 = *(float *)(v2 + v21 + 20);
    v7 = v6 < v4;
    v8 = 0;
    v9 = v6 == v4;
    if ( (v5 & 0x45) == 1 )
    {
      v11 = *(float *)(v2 + v21 + 20);
    }
    else
    {
      v10 = *(float *)(v2 + v21 + 12) > v4;
      v11 = *(float *)(v2 + v21 + 12);
      if ( !v10 )
        goto LABEL_7;
    }
    v22 = 1;
    *v3 = v11;
LABEL_7:
    v12 = a1 + 104;
    v13 = AngleSubtract(*v3, *(float *)(v2 + a1 + 104));
    if ( fabs(v13) > 15.0 )
    {
      v22 = 1;
      v15 = v13 > 0.0;
      v16 = 0;
      v17 = 0.0 == v13;
      if ( (v14 & 0x45) == 1 )
        v18 = *(float *)(v2 + v12) + 15.0;
      else
        v18 = *(float *)(v2 + v12) - 15.0;
      *v3 = v18;
    }
    ++v3;
    v2 += 4;
    --v23;
  }
  while ( v23 >= 0 );
  *(float *)(a1 + 104) = v24;
  *(float *)(a1 + 108) = v25;
  *(_DWORD *)(a1 + 112) = 0;
  result = *(_DWORD *)(v21 + 4);
  if ( (result & 0x800) != 0 )
  {
    BYTE1(result) &= 0xF7u;
    *(_DWORD *)(v21 + 4) = result;
    *(_BYTE *)(a1 + 8) ^= 8u;
  }
  if ( v22 )
  {
    v26[0] = v24 + *(float *)(a1 + 320);
    v20 = v25 + *(float *)(a1 + 324);
    v26[2] = 0.0;
    v26[1] = v20;
    result = SetClientViewAngle(a2, v26);
  }
  return result;
}
// 520BF: variable 'v5' is possibly undefined
// 5212C: variable 'v14' is possibly undefined

//----- (000521D4) --------------------------------------------------------
int __cdecl sub_521D4(int a1, int *a2)
{
  int v2; // esi
  int v3; // edx
  int result; // eax
  int *v5; // [esp+20h] [ebp-48h]
  int v6; // [esp+24h] [ebp-44h]
  int v7[15]; // [esp+28h] [ebp-40h] BYREF
  int v8; // [esp+64h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 348);
  sub_5201C(a1, (int)a2);
  sub_515A8((int)a2, a1);
  v3 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
  *(_DWORD *)(a2[86] + 884) = 1;
  *(_BYTE *)(a1 + 9) &= 0xFBu;
  result = *(_DWORD *)(v2 + 8) - 50;
  *(_DWORD *)(v2 + 8) = result;
  if ( result <= 0 )
  {
    *(_DWORD *)(v2 + 8) = 0;
    result = a2[86];
    if ( (*(_BYTE *)(result + 8680) & 1) != 0 )
    {
      *(_DWORD *)(v2 + 8) = *(_DWORD *)(v3 + 468);
      result = 3 * *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200)) + 468);
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 40) = result;
      if ( a2[86] )
      {
        v6 = *(_DWORD *)(a1 + 568);
        v5 = &g_entities[201334];
        if ( a2 != &g_entities[201531] )
          v5 = a2;
        if ( sub_51488((_DWORD *)a1, (int)v5, (float *)v7) )
        {
          v8 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
          if ( *(_DWORD *)(v8 + 112) )
            Weapon_RocketLauncher_Fire(a1, 0.0, (int)v7);
          else
            Bullet_Fire((int)v5, 0.0, v6, (int)v7, a1);
          G_AddEvent((_DWORD *)a1, 168, 0);
        }
        result = a2[86];
        *(_DWORD *)(result + 884) = 2;
      }
      *(_BYTE *)(a1 + 9) |= 4u;
    }
  }
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00052340) --------------------------------------------------------
int __cdecl turret_think_client(int a1)
{
  int *v1; // edx
  int result; // eax
  int v3; // edx
  int v4; // esi
  int *v5; // ebx
  int v6; // eax

  v1 = &g_entities[197 * *(_DWORD *)(a1 + 332)];
  if ( *((_BYTE *)v1 + 370) != 1 || *(_DWORD *)(v1[86] + 8400) )
  {
    v4 = *(_DWORD *)(a1 + 348);
    v5 = &g_entities[197 * *(_DWORD *)(a1 + 332)];
    *(_DWORD *)(v4 + 40) = 0;
    *(_DWORD *)(a1 + 132) = 0;
    v6 = *(_DWORD *)(v4 + 36);
    if ( v6 != -1 )
    {
      if ( v6 == 2 )
      {
        G_AddEvent(v5, 142, 0);
      }
      else if ( v6 == 1 )
      {
        G_AddEvent(v5, 141, 0);
      }
      else
      {
        G_AddEvent(v5, 140, 0);
      }
      *(_DWORD *)(v4 + 36) = -1;
    }
    TeleportPlayer((int)v5, (float *)(v4 + 44), (float *)v5 + 80);
    *(_BYTE *)(v5[86] + 129) &= 0x3Fu;
    *(_DWORD *)(v5[86] + 884) = 0;
    *(_DWORD *)(v5[86] + 888) = 1023;
    result = v5[86];
    *((_BYTE *)v5 + 370) = 0;
    *(_DWORD *)(result + 896) = 0;
    v5[29] = 0;
    *(_BYTE *)(a1 + 370) = 0;
    *(_DWORD *)(a1 + 332) = 1023;
    *(_BYTE *)(v4 + 5) &= 0xF7u;
  }
  else
  {
    result = sub_521D4(a1, &g_entities[197 * *(_DWORD *)(a1 + 332)]);
    v3 = *(_DWORD *)(a1 + 348);
    *(_DWORD *)(a1 + 132) = 0;
    if ( *(int *)(v3 + 40) > 0 )
    {
      *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(v3 + 60);
      result = *(_DWORD *)(v3 + 40) - 50;
      *(_DWORD *)(v3 + 40) = result;
      if ( result <= 0 )
      {
        if ( *(_BYTE *)(v3 + 61) )
        {
          *(_DWORD *)(a1 + 132) = 0;
          result = G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(v3 + 61));
        }
      }
    }
  }
  return result;
}

//----- (000524CC) --------------------------------------------------------
int __cdecl sub_524CC(int a1, int a2, int a3)
{
  int v3; // ebx
  long double v4; // fst7
  char v5; // fps^1
  long double v6; // fst6
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  int v11; // ecx
  char v12; // fps^1
  long double v13; // fst6
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  long double v17; // fst7
  char v18; // fps^1
  long double v19; // fst6
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst7
  float v25; // [esp-10h] [ebp-48h]
  float v26; // [esp+20h] [ebp-18h]
  int v27; // [esp+24h] [ebp-14h]
  int v28; // [esp+28h] [ebp-10h]
  int v29; // [esp+2Ch] [ebp-Ch]
  float v30[2]; // [esp+30h] [ebp-8h]
  float v31; // [esp+34h] [ebp-4h]

  v28 = *(_DWORD *)(a1 + 348);
  v27 = 1;
  v26 = *(float *)(a1 + 104);
  *(float *)(a1 + 104) = v26 + *(float *)(a1 + 112);
  if ( a3 )
  {
    v30[0] = *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200)) + 1008);
    v31 = *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200)) + 1012);
  }
  else
  {
    v30[0] = 200.0;
    v31 = 200.0;
  }
  if ( (*(_DWORD *)(v28 + 4) & 0x300) == 768 && v30[0] < 360.0 )
    v30[0] = 360.0;
  v3 = 0;
  v29 = 1;
  do
  {
    v30[v3] = v30[v3] * 0.050000001;
    v4 = AngleSubtract(*(float *)(a2 + v3 * 4), *(float *)(a1 + 104 + v3 * 4));
    v6 = v30[v3];
    v7 = v6 < v4;
    v8 = 0;
    v9 = v6 == v4;
    if ( (v5 & 0x45) == 1 || (v6 = -v6, v6 > v4) )
    {
      v4 = v6;
      v27 = 0;
    }
    *(float *)(a1 + 104 + v3 * 4) = v4 + *(float *)(a1 + 104 + v3 * 4);
    ++v3;
    --v29;
  }
  while ( v29 >= 0 );
  v10 = *(float *)(a1 + 104);
  *(float *)(a1 + 112) = *(float *)(a1 + 104);
  v11 = *(_DWORD *)(v28 + 4);
  if ( (v11 & 0x200) != 0 )
  {
    if ( (v11 & 0x400) != 0 )
    {
      v13 = *(float *)(v28 + 56);
      if ( v13 <= v10 )
      {
LABEL_18:
        BYTE1(v11) &= 0xFEu;
        *(_DWORD *)(v28 + 4) = v11;
        goto LABEL_19;
      }
    }
    else
    {
      v13 = *(float *)(v28 + 56);
      v14 = v13 < v10;
      v15 = 0;
      v16 = v13 == v10;
      if ( (v12 & 0x45) != 1 )
        goto LABEL_18;
    }
    v10 = v13;
  }
LABEL_19:
  v25 = v10;
  v17 = AngleSubtract(v25, v26);
  v19 = v30[0];
  v20 = v30[0] < v17;
  v21 = 0;
  v22 = v30[0] == v17;
  if ( (v18 & 0x45) == 1 || (v19 = -v19, v19 > v17) )
  {
    v17 = v19;
    v27 = 0;
  }
  v23 = v17 + v26;
  *(float *)(a1 + 104) = v23;
  *(float *)(a1 + 112) = *(float *)(a1 + 112) - v23;
  return v27;
}
// 525BE: variable 'v5' is possibly undefined
// 5260E: variable 'v12' is possibly undefined
// 5264E: variable 'v18' is possibly undefined
// 524CC: using guessed type float var_8[2];

//----- (0005268C) --------------------------------------------------------
__int16 __cdecl turret_think_init(int a1)
{
  int v1; // eax
  float *v2; // edi
  float *v3; // ebx
  __int16 v4; // fps
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  int v9; // [esp+2Ch] [ebp-CCh]
  int v10; // [esp+30h] [ebp-C8h]
  float v11[12]; // [esp+38h] [ebp-C0h] BYREF
  float v12[3]; // [esp+68h] [ebp-90h] BYREF
  float v13[3]; // [esp+74h] [ebp-84h] BYREF
  float v14; // [esp+80h] [ebp-78h] BYREF
  float v15; // [esp+84h] [ebp-74h]
  float v16; // [esp+88h] [ebp-70h]
  float v17[3]; // [esp+8Ch] [ebp-6Ch] BYREF
  float v18[3]; // [esp+98h] [ebp-60h] BYREF
  float v19[9]; // [esp+A4h] [ebp-54h] BYREF
  float v20[12]; // [esp+C8h] [ebp-30h] BYREF

  v10 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(a1 + 512) = turret_think;
  *(_DWORD *)(a1 + 508) = level[122] + 50;
  v1 = G_DObjGetLocalTagMatrix((_DWORD *)a1, (int)"tag_aim");
  v2 = (float *)v1;
  if ( v1 )
  {
    v1 = G_DObjGetLocalTagMatrix((_DWORD *)a1, (int)"tag_butt");
    v3 = (float *)v1;
    if ( v1 )
    {
      AnglesToAxis((float *)(a1 + 320), v20);
      v20[9] = *(float *)(a1 + 308);
      v20[10] = *(float *)(a1 + 312);
      v20[11] = *(float *)(a1 + 316);
      v17[0] = v3[12] - v2[12];
      v17[1] = v3[13] - v2[13];
      v17[2] = v3[14] - v2[14];
      MatrixTransformVector43(v2 + 12, v20, v13);
      v9 = 0;
      while ( 1 )
      {
        v18[1] = 0.0;
        v18[2] = 0.0;
        v18[0] = (long double)v9 * -3.0;
        AnglesToAxis(v18, v19);
        MatrixTransformVector(v17, v19, &v14);
        v14 = v2[12] + v14;
        v15 = v2[13] + v15;
        v16 = v2[14] + v16;
        MatrixTransformVector43(&v14, v20, v12);
        trap_LocationalTrace((int)v11, (int)v13, (int)v12);
        v5 = v11[0] > 1.0;
        v6 = 0;
        v7 = 1.0 == v11[0];
        LOBYTE(v1) = v4;
        BYTE1(v1) = HIBYTE(v4) & 0x45;
        if ( v11[0] < 1.0 )
          break;
        if ( ++v9 > 30 )
          return v1;
      }
      *(float *)(v10 + 28) = v18[0];
    }
  }
  return v1;
}

//----- (00052880) --------------------------------------------------------
_BOOL4 __cdecl sub_52880(int a1, int a2)
{
  int v2; // eax
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst7
  float v8; // [esp-20h] [ebp-78h]
  float v9; // [esp-10h] [ebp-68h]
  float v10; // [esp-10h] [ebp-68h]
  float v11; // [esp+1Ch] [ebp-3Ch]
  float v12; // [esp+1Ch] [ebp-3Ch]
  float v13; // [esp+2Ch] [ebp-2Ch]
  int v14[3]; // [esp+40h] [ebp-18h] BYREF
  float v15; // [esp+4Ch] [ebp-Ch] BYREF
  float v16; // [esp+50h] [ebp-8h]
  float v17; // [esp+54h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 348);
  v3 = *(float *)(v2 + 16);
  v4 = *(float *)(a1 + 324) + v3;
  v11 = fabs(v3);
  v5 = (fabs(*(float *)(v2 + 24)) + v11) * 0.5;
  v12 = v5;
  v9 = v4 + v5;
  v8 = AngleNormalize180(v9);
  YawVectors(v8, (int)v14, 0);
  VectorNormalize((float *)v14);
  v15 = *(float *)(a1 + 308) - *(float *)(a2 + 308);
  v6 = *(float *)(a1 + 312) - *(float *)(a2 + 312);
  v17 = 0.0;
  v16 = v6;
  VectorNormalize(&v15);
  v10 = *(float *)v14 * v15 + *(float *)&v14[1] * v16 + *(float *)&v14[2] * v17;
  v13 = Q_acos(v10) * 180.0 / 3.141592653589793;
  return v13 <= (long double)v12;
}

//----- (0005297C) --------------------------------------------------------
_DWORD *__cdecl G_FreeTurret(int a1)
{
  int *v1; // ebx
  int v2; // esi
  int v3; // eax
  int v4; // eax
  _DWORD *result; // eax

  v1 = &g_entities[197 * *(_DWORD *)(a1 + 332)];
  if ( v1[86] )
  {
    v2 = *(_DWORD *)(a1 + 348);
    *(_DWORD *)(v2 + 40) = 0;
    *(_DWORD *)(a1 + 132) = 0;
    v3 = *(_DWORD *)(v2 + 36);
    if ( v3 != -1 )
    {
      if ( v3 == 2 )
      {
        G_AddEvent(v1, 142, 0);
      }
      else if ( v3 == 1 )
      {
        G_AddEvent(v1, 141, 0);
      }
      else
      {
        G_AddEvent(v1, 140, 0);
      }
      *(_DWORD *)(v2 + 36) = -1;
    }
    TeleportPlayer((int)v1, (float *)(v2 + 44), (float *)v1 + 80);
    *(_BYTE *)(v1[86] + 129) &= 0x3Fu;
    *(_DWORD *)(v1[86] + 884) = 0;
    *(_DWORD *)(v1[86] + 888) = 1023;
    v4 = v1[86];
    *((_BYTE *)v1 + 370) = 0;
    *(_DWORD *)(v4 + 896) = 0;
    v1[29] = 0;
    *(_BYTE *)(a1 + 370) = 0;
    *(_DWORD *)(a1 + 332) = 1023;
    *(_BYTE *)(v2 + 5) &= 0xF7u;
  }
  result = *(_DWORD **)(a1 + 348);
  *(_BYTE *)(a1 + 370) = 0;
  *result = 0;
  *(_DWORD *)(a1 + 348) = 0;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00052A9C) --------------------------------------------------------
int __cdecl turret_use(int a1, int a2)
{
  int v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // esi
  int v6; // ebx
  long double v7; // fst7
  char v8; // fps^1
  long double v9; // fst6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  bool v13; // zf
  long double v14; // fst7
  long double v15; // fst7
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  float v19[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v2 = *(_DWORD *)(a1 + 348);
  *(_BYTE *)(a2 + 370) = 1;
  *(_BYTE *)(a1 + 370) = 1;
  *(_DWORD *)(a1 + 332) = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)(a2 + 344) + 884) = 1;
  *(_DWORD *)(*(_DWORD *)(a2 + 344) + 888) = *(_DWORD *)a1;
  *(_BYTE *)(v2 + 5) |= 8u;
  *(float *)(v2 + 44) = *(float *)(a2 + 308);
  *(float *)(v2 + 48) = *(float *)(a2 + 312);
  *(float *)(v2 + 52) = *(float *)(a2 + 316);
  *(_DWORD *)(a2 + 116) = *(_DWORD *)a1;
  v3 = *(_DWORD *)(*(_DWORD *)(a2 + 344) + 12);
  if ( (v3 & 1) != 0 )
    *(_DWORD *)(v2 + 36) = 2;
  else
    *(_DWORD *)(v2 + 36) = (v3 & 2) != 0;
  v4 = *(_DWORD *)(v2 + 32);
  if ( v4 == 2 )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 344) + 129) |= 0x40u;
    *(_BYTE *)(*(_DWORD *)(a2 + 344) + 129) &= 0x7Fu;
  }
  else if ( v4 == 1 )
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 344) + 129) |= 0x80u;
    *(_BYTE *)(*(_DWORD *)(a2 + 344) + 129) &= 0xBFu;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a2 + 344) + 129) |= 0xC0u;
  }
  v5 = a1 + 104;
  v6 = 0;
  *(float *)(a1 + 652) = *(float *)(a1 + 320);
  *(float *)(a1 + 656) = *(float *)(a1 + 324);
  *(float *)(a1 + 660) = *(float *)(a1 + 328);
  v17 = v2 + 20;
  v18 = 1;
  do
  {
    v7 = AngleSubtract(*(float *)(v6 + *(_DWORD *)(a2 + 344) + 192), *(float *)(a1 + 320 + v6));
    *(float *)(v5 + v6) = v7;
    v9 = *(float *)(v17 + v6);
    v10 = v9 < v7;
    v11 = 0;
    v12 = v9 == v7;
    if ( (v8 & 0x45) == 1 )
    {
      v14 = *(float *)(v17 + v6);
    }
    else
    {
      v13 = *(float *)(v6 + v2 + 12) > v7;
      v14 = *(float *)(v6 + v2 + 12);
      if ( !v13 )
        goto LABEL_17;
    }
    *(float *)(v5 + v6) = v14;
LABEL_17:
    v6 += 4;
    --v18;
  }
  while ( v18 >= 0 );
  v19[0] = *(float *)(a1 + 104) + *(float *)(a1 + 320);
  v15 = *(float *)(a1 + 108) + *(float *)(a1 + 324);
  v19[2] = 0.0;
  v19[1] = v15;
  return SetClientViewAngle(a2, v19);
}
// 52C1C: variable 'v8' is possibly undefined

//----- (00052C84) --------------------------------------------------------
int __cdecl G_SpawnTurret(int a1, char *a2)
{
  int v2; // eax
  int *v3; // ebx
  int *v4; // edx
  unsigned __int8 v5; // al
  int v6; // edi
  char *v7; // eax
  _BYTE *v8; // eax
  _BYTE *v9; // eax
  long double v10; // fst6
  long double v11; // fst6

  v2 = 0;
  v3 = &dword_AA180;
  if ( dword_AA180 )
  {
    v4 = &dword_AA180;
    do
    {
      v4 += 16;
      if ( ++v2 > 31 )
        break;
      v3 = v4;
    }
    while ( *v4 );
  }
  if ( v2 == 32 )
    Com_Error(1, (char *)&byte_75960, 32);
  _bzero(v3, 0x40u);
  *(_DWORD *)(a1 + 348) = v3;
  *v3 = 1;
  v5 = BG_GetWeaponIndexForName(a2);
  *(_DWORD *)(a1 + 200) = v5;
  if ( !v5 )
    Com_Error(1, (char *)&byte_759A0, a2);
  v6 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
  if ( !level[7] && !IsItemRegistered(*(_DWORD *)(a1 + 200)) )
  {
    v7 = va("turret '%s' not precached", a2);
    Scr_Error((int)v7);
  }
  RegisterItem(*(_DWORD *)(a1 + 200), 1);
  v3[2] = 0;
  v3[8] = *(_DWORD *)(v6 + 128);
  v3[9] = -1;
  v3[10] = 0;
  v8 = *(_BYTE **)(v6 + 160);
  if ( v8 && *v8 )
    *((_BYTE *)v3 + 60) = G_SoundAliasIndex(*(char **)(v6 + 160));
  else
    *((_BYTE *)v3 + 60) = 0;
  v9 = *(_BYTE **)(v6 + 164);
  if ( v9 && *v9 )
    *((_BYTE *)v3 + 61) = G_SoundAliasIndex(*(char **)(v6 + 164));
  else
    *((_BYTE *)v3 + 61) = 0;
  if ( !G_SpawnFloat("rightarc", (int)&unk_759E4, (int)(v3 + 4)) )
    v3[4] = *(int *)(v6 + 992);
  v10 = -*((float *)v3 + 4);
  *((float *)v3 + 4) = v10;
  if ( v10 > 0.0 )
    *((float *)v3 + 4) = 0.0;
  if ( !G_SpawnFloat("leftarc", (int)&unk_759E4, (int)(v3 + 6)) )
    v3[6] = *(int *)(v6 + 988);
  if ( *((float *)v3 + 6) < 0.0 )
    *((float *)v3 + 6) = 0.0;
  if ( !G_SpawnFloat("toparc", (int)&unk_759E4, (int)(v3 + 3)) )
    v3[3] = *(int *)(v6 + 996);
  v11 = -*((float *)v3 + 3);
  *((float *)v3 + 3) = v11;
  if ( v11 > 0.0 )
    *((float *)v3 + 3) = 0.0;
  if ( !G_SpawnFloat("bottomarc", (int)&unk_759E4, (int)(v3 + 5)) )
    v3[5] = *(int *)(v6 + 1000);
  if ( *((float *)v3 + 5) < 0.0 )
    *((float *)v3 + 5) = 0.0;
  *((float *)v3 + 7) = -90.0;
  if ( !*(_DWORD *)(a1 + 560) )
    *(_DWORD *)(a1 + 560) = 100;
  if ( !G_SpawnInt("damage", (int)"0", a1 + 568) )
    *(_DWORD *)(a1 + 568) = *(_DWORD *)(v6 + 448);
  if ( *(int *)(a1 + 568) < 0 )
    *(_DWORD *)(a1 + 568) = 0;
  v3[1] = 3;
  *(_DWORD *)(a1 + 400) = 1;
  *(_DWORD *)(a1 + 280) = &unk_200004;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 11;
  *(_BYTE *)(a1 + 381) |= 0x20u;
  G_DObjUpdate(a1);
  *(float *)(a1 + 256) = -32.0;
  *(float *)(a1 + 260) = -32.0;
  *(_DWORD *)(a1 + 264) = 0;
  *(float *)(a1 + 268) = 32.0;
  *(float *)(a1 + 272) = 32.0;
  *(float *)(a1 + 276) = 56.0;
  G_SetOrigin(a1, (float *)(a1 + 308));
  G_SetAngle(a1, (float *)(a1 + 320));
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 512) = turret_think_init;
  *(_DWORD *)(a1 + 508) = level[122] + 100;
  *(_DWORD *)(a1 + 544) = turret_controller;
  *(_DWORD *)(a1 + 528) = turret_use;
  *(_DWORD *)(a1 + 48) = 3;
  *(_BYTE *)(a1 + 369) = 1;
  return trap_LinkEntity(a1);
}
// AA180: using guessed type int dword_AA180;

//----- (00053034) --------------------------------------------------------
_DWORD *G_InitTurrets()
{
  int v0; // ecx
  _DWORD *result; // eax

  v0 = 31;
  result = &unk_AA940;
  do
  {
    *result = 0;
    result -= 16;
    --v0;
  }
  while ( v0 >= 0 );
  return result;
}

//----- (00053054) --------------------------------------------------------
int __cdecl G_ClientStopUsingTurret(int a1)
{
  int v1; // esi
  int *v2; // ebx
  int v3; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 348);
  v2 = &g_entities[197 * *(_DWORD *)(a1 + 332)];
  *(_DWORD *)(v1 + 40) = 0;
  *(_DWORD *)(a1 + 132) = 0;
  v3 = *(_DWORD *)(v1 + 36);
  if ( v3 != -1 )
  {
    if ( v3 == 2 )
    {
      G_AddEvent(v2, 142, 0);
    }
    else if ( v3 == 1 )
    {
      G_AddEvent(v2, 141, 0);
    }
    else
    {
      G_AddEvent(v2, 140, 0);
    }
    *(_DWORD *)(v1 + 36) = -1;
  }
  TeleportPlayer((int)v2, (float *)(v1 + 44), (float *)v2 + 80);
  *(_BYTE *)(v2[86] + 129) &= 0x3Fu;
  *(_DWORD *)(v2[86] + 884) = 0;
  *(_DWORD *)(v2[86] + 888) = 1023;
  result = v2[86];
  *((_BYTE *)v2 + 370) = 0;
  *(_DWORD *)(result + 896) = 0;
  v2[29] = 0;
  *(_BYTE *)(a1 + 370) = 0;
  *(_DWORD *)(a1 + 332) = 1023;
  *(_BYTE *)(v1 + 5) &= 0xF7u;
  return result;
}

//----- (0005314C) --------------------------------------------------------
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2)
{
  int v2; // eax
  _BOOL4 result; // eax

  result = 0;
  if ( !*(_BYTE *)(a1 + 370) )
  {
    if ( *(_DWORD *)(a1 + 348) )
    {
      if ( *(_BYTE *)(a1 + 369) )
      {
        if ( sub_52880(a1, a2) )
        {
          v2 = *(_DWORD *)(a2 + 344);
          if ( !*(_DWORD *)(v2 + 52) && *(_DWORD *)(v2 + 84) != 1023 )
            result = 1;
        }
      }
    }
  }
  return result;
}

//----- (000531AC) --------------------------------------------------------
int __cdecl SP_info_camp(int a1)
{
  return G_SetOrigin(a1, (float *)(a1 + 308));
}

//----- (000531CC) --------------------------------------------------------
void *__cdecl SP_info_null(void *s)
{
  return G_FreeEntity(s);
}

//----- (000531E4) --------------------------------------------------------
int __cdecl SP_info_notnull(int a1)
{
  return G_SetOrigin(a1, (float *)(a1 + 308));
}

//----- (00053204) --------------------------------------------------------
void *__cdecl SP_light(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005321C) --------------------------------------------------------
void SP_misc_teleporter_dest()
{
  ;
}

//----- (00053224) --------------------------------------------------------
void *__cdecl SP_misc_model(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005323C) --------------------------------------------------------
int __cdecl use_corona(int a1)
{
  if ( *(_DWORD *)(a1 + 240) )
    return trap_UnlinkEntity(a1);
  *(_BYTE *)(a1 + 370) = 0;
  return trap_LinkEntity(a1);
}

//----- (00053274) --------------------------------------------------------
void *__cdecl SP_corona(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005328C) --------------------------------------------------------
int __cdecl turret_think(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // eax
  int v4; // eax
  float v5[2]; // [esp+10h] [ebp-8h] BYREF

  *(_DWORD *)(a1 + 508) = level[122] + 50;
  if ( *(_DWORD *)(a1 + 740) )
    G_GeneralLink(a1);
  result = 788 * *(_DWORD *)(a1 + 332);
  if ( !*(int *)((char *)&g_entities[86] + result) )
  {
    v2 = *(_DWORD *)(a1 + 348);
    *(_DWORD *)(a1 + 132) = 0;
    if ( *(int *)(v2 + 40) > 0 )
    {
      *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(v2 + 60);
      v3 = *(_DWORD *)(v2 + 40) - 50;
      *(_DWORD *)(v2 + 40) = v3;
      if ( v3 <= 0 )
      {
        if ( *(_BYTE *)(v2 + 61) )
        {
          *(_DWORD *)(a1 + 132) = 0;
          G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(v2 + 61));
        }
      }
    }
    v4 = *(_DWORD *)(a1 + 348);
    *(_BYTE *)(a1 + 9) &= 0xFBu;
    v5[0] = *(float *)(v4 + 28);
    v5[1] = 0.0;
    result = sub_524CC(a1, (int)v5, 0);
  }
  return result;
}

//----- (00053348) --------------------------------------------------------
int __cdecl turret_controller(int a1, int a2)
{
  float v3; // [esp+1Ch] [ebp-Ch] BYREF
  float v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  v4 = *(float *)(a1 + 108);
  v3 = *(float *)(a1 + 104);
  v5 = 0;
  G_DObjSetControlTagAngles((_DWORD *)a1, a2, (int)"tag_aim", &v3);
  G_DObjSetControlTagAngles((_DWORD *)a1, a2, (int)"tag_aim_animated", &v3);
  v3 = *(float *)(a1 + 112);
  v4 = 0.0;
  return G_DObjSetControlTagAngles((_DWORD *)a1, a2, (int)"tag_flash", &v3);
}

//----- (000533B0) --------------------------------------------------------
int __cdecl SP_turret(int a1)
{
  int v2; // [esp+14h] [ebp-4h] BYREF

  if ( !G_SpawnString("weaponinfo", (int)&unk_759E4, (int)&v2) )
    Com_Error(1, (char *)&byte_75A40);
  return G_SpawnTurret(a1, (char *)v2);
}

//----- (000533FC) --------------------------------------------------------
int __cdecl misc_spawner_think(int a1)
{
  char *v1; // eax
  int *v2; // eax
  int result; // eax
  char *v4; // eax

  v1 = (char *)SL_ConvertToString(*(_WORD *)(a1 + 712));
  v2 = BG_FindItem(v1);
  result = Drop_Item(a1, (int)v2, 0.0, 0);
  if ( !result )
  {
    G_Printf("-----> WARNING <-------\n");
    v4 = vtos((float *)(a1 + 308));
    result = G_Printf("misc_spawner used at %s failed to drop!\n", v4);
  }
  return result;
}

//----- (00053468) --------------------------------------------------------
int __cdecl misc_spawner_use(int a1)
{
  *(_DWORD *)(a1 + 512) = misc_spawner_think;
  *(_DWORD *)(a1 + 508) = level[122] + 100;
  return trap_LinkEntity(a1);
}

//----- (00053498) --------------------------------------------------------
int __cdecl SP_misc_spawner(int a1)
{
  char *v1; // eax
  int result; // eax

  if ( *(_WORD *)(a1 + 712) )
  {
    *(_DWORD *)(a1 + 528) = misc_spawner_use;
    result = trap_LinkEntity(a1);
  }
  else
  {
    G_Printf("-----> WARNING <-------\n");
    v1 = vtos((float *)(a1 + 308));
    result = G_Printf("misc_spawner at loc %s has no spawnitem!\n", v1);
  }
  return result;
}

//----- (000534F4) --------------------------------------------------------
__int16 __cdecl miscGunnerEnemyScan(int a1)
{
  int *v1; // ebx
  int *v2; // eax
  long double v3; // fst7
  char v4; // fps^1
  long double v5; // fst6
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  char v10[12]; // [esp+20h] [ebp-18h] BYREF
  float v11[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v1 = g_entities;
  v2 = &g_entities[197 * level[120]];
  if ( g_entities < v2 )
  {
    while ( 1 )
    {
      if ( *((_BYTE *)v1 + 352) )
      {
        if ( v1[140] >= 0 )
        {
          v3 = VectorDistance((float *)(a1 + 308), (float *)v1 + 77);
          v5 = (long double)*(int *)(a1 + 624);
          v6 = v5 < v3;
          v7 = 0;
          v8 = v5 == v3;
          if ( (v4 & 0x45) != 1 )
            break;
        }
      }
      v1 += 197;
      v2 = &g_entities[197 * level[120]];
      if ( v1 >= v2 )
        return (__int16)v2;
    }
    v11[0] = *((float *)v1 + 77) - *(float *)(a1 + 308);
    v11[1] = *((float *)v1 + 78) - *(float *)(a1 + 312);
    v11[2] = *((float *)v1 + 79) - *(float *)(a1 + 316);
    LOWORD(v2) = vectoangles(v11, (int)v10);
    *(_DWORD *)(a1 + 600) = v1;
  }
  return (__int16)v2;
}
// 53557: variable 'v4' is possibly undefined

//----- (000535D0) --------------------------------------------------------
void __cdecl G_MissileLandAngles(int a1, float *a2, float *a3, int a4)
{
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst7
  long double v14; // fst7
  char v15; // fps^1
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  long double v19; // fst7
  char v20; // fps^1
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  float v24; // [esp-10h] [ebp-58h]
  float v25; // [esp-10h] [ebp-58h]
  float v26; // [esp+18h] [ebp-30h]
  float v27; // [esp+1Ch] [ebp-2Ch]
  float v28; // [esp+20h] [ebp-28h]
  int v29; // [esp+24h] [ebp-24h]

  v29 = (int)((long double)(level[122] - level[123]) * *a2) + level[123];
  BG_EvaluateTrajectory(a1 + 48, v29, a3);
  v5 = a2[6] > 0.1;
  v6 = 0;
  v7 = 0.1 == a2[6];
  if ( (v4 & 0x45) == 1 )
  {
    v28 = PitchForYawOnNormal(a3[1], (int)(a2 + 4));
    v8 = AngleSubtract(v28, *a3);
    v27 = v8;
    v26 = fabs(v8);
    if ( !a4 )
    {
      *(float *)(a1 + 60) = *a3;
      *(float *)(a1 + 64) = a3[1];
      *(float *)(a1 + 68) = a3[2];
      *(_DWORD *)(a1 + 52) = v29;
      v10 = v26 < 80.0;
      v11 = 0;
      v12 = v26 == 80.0;
      if ( (v9 & 0x45) == 1 )
        v13 = -(((long double)rand() * -4.6566129e-10 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72));
      else
        v13 = ((long double)rand() * -4.6566129e-10 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
      *(float *)(a1 + 72) = v13;
    }
    v14 = AngleNormalize180(*a3);
    *a3 = v14;
    if ( a4 || (v16 = v26 < 45.0, v17 = 0, v18 = v26 == 45.0, (v15 & 0x45) == 1) )
    {
      if ( fabs(v14) <= 90.0 )
      {
        v19 = AngleNormalize360(v28);
LABEL_15:
        *a3 = v19;
        return;
      }
      v14 = v28 + 180.0;
    }
    else
    {
      v21 = v26 < 80.0;
      v22 = 0;
      v23 = v26 == 80.0;
      if ( (v20 & 0x45) == 1 )
        v14 = v14 + v27 * 0.25;
    }
    v24 = v14;
    v19 = AngleNormalize360(v24);
    goto LABEL_15;
  }
  if ( !a4 )
  {
    v25 = (long double)((rand() & 0x7F) - 63) + *(float *)(a1 + 72);
    *(float *)(a1 + 72) = AngleNormalize360(v25);
  }
}
// 53645: variable 'v4' is possibly undefined
// 536AC: variable 'v9' is possibly undefined
// 53721: variable 'v15' is possibly undefined
// 53763: variable 'v20' is possibly undefined

//----- (000537C0) --------------------------------------------------------
_BOOL4 __cdecl G_BounceMissile(int a1, int a2)
{
  int v2; // ebx
  long double v3; // fst5
  long double v4; // fst6
  long double v5; // fst3
  long double v6; // fst7
  int v7; // eax
  long double v8; // fst7
  long double v9; // fst6
  long double v10; // fst5
  long double v11; // rt0
  long double v12; // fst7
  long double v13; // fst4
  long double v14; // rt1
  long double v15; // fst4
  long double v16; // fst7
  long double v17; // fst7
  long double v18; // fst6
  char v19; // fps^1
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v24; // fst6
  long double v25; // fst6
  long double v26; // fst7
  long double v27; // rtt
  long double v28; // fst5
  long double v29; // fst6
  long double v30; // rt2
  long double v31; // fst7
  long double v32; // fst6
  long double v33; // fst5
  float v34; // [esp+28h] [ebp-30h]
  float v35; // [esp+28h] [ebp-30h]
  float v36[3]; // [esp+34h] [ebp-24h] BYREF
  float v37; // [esp+40h] [ebp-18h]
  float v38; // [esp+44h] [ebp-14h]
  float v39; // [esp+48h] [ebp-10h]
  float v40; // [esp+4Ch] [ebp-Ch] BYREF
  float v41; // [esp+50h] [ebp-8h]
  float v42; // [esp+54h] [ebp-4h]

  v2 = trap_PointContents(a1 + 308, -1, 32);
  BG_EvaluateTrajectoryDelta(a1 + 12, (int)((long double)(level[122] - level[123]) * *(float *)a2) + level[123], &v40);
  v3 = v41;
  v4 = v42;
  v5 = v41 * *(float *)(a2 + 20) + v40 * *(float *)(a2 + 16) + v42 * *(float *)(a2 + 24);
  v6 = v5 * -2.0;
  *(float *)(a1 + 36) = *(float *)(a2 + 16) * v6 + v40;
  *(float *)(a1 + 40) = v3 + *(float *)(a2 + 20) * v6;
  *(float *)(a1 + 44) = v4 + v6 * *(float *)(a2 + 24);
  if ( *(float *)(a2 + 24) > 0.7 )
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
  v7 = *(_DWORD *)(a1 + 8);
  if ( (v7 & 0x2000000) == 0 )
    goto LABEL_15;
  if ( v2 || (*(_BYTE *)(a2 + 35) & 2) != 0 )
  {
    v8 = 0.125;
LABEL_10:
    *(float *)(a1 + 36) = *(float *)(a1 + 36) * v8;
    v18 = *(float *)(a1 + 40) * v8;
    v17 = v8 * *(float *)(a1 + 44);
    *(float *)(a1 + 40) = v18;
    goto LABEL_11;
  }
  if ( (v7 & 0x1000000) == 0 )
  {
    v8 = 0.5;
    goto LABEL_10;
  }
  v9 = *(float *)(a2 + 16) * v5 + *(float *)(a1 + 36);
  *(float *)(a1 + 36) = v9;
  v10 = *(float *)(a2 + 20) * v5 + *(float *)(a1 + 40);
  *(float *)(a1 + 40) = v10;
  v11 = v9 * 0.75;
  v12 = 0.75 * (*(float *)(a2 + 24) * v5 + *(float *)(a1 + 44));
  *(float *)(a1 + 36) = v11;
  v13 = v10 * 0.75;
  *(float *)(a1 + 40) = v13;
  v14 = v13;
  v15 = v12;
  v16 = -(v5 * 0.30000001);
  *(float *)(a1 + 44) = v15;
  *(float *)(a1 + 36) = v11 + *(float *)(a2 + 16) * v16;
  *(float *)(a1 + 40) = v14 + *(float *)(a2 + 20) * v16;
  v17 = v15 + v16 * *(float *)(a2 + 24);
LABEL_11:
  *(float *)(a1 + 44) = v17;
  if ( *(float *)(a2 + 24) > 0.7 )
  {
    v34 = sqrt(
            *(float *)(a1 + 36) * *(float *)(a1 + 36)
          + *(float *)(a1 + 40) * *(float *)(a1 + 40)
          + *(float *)(a1 + 44) * *(float *)(a1 + 44));
    v20 = v34 < 20.0;
    v21 = 0;
    v22 = v34 == 20.0;
    if ( (v19 & 0x45) == 1 )
    {
      G_SetOrigin(a1, (float *)(a1 + 308));
      G_MissileLandAngles(a1, (float *)a2, v36, 1);
      G_SetAngle(a1, v36);
      return 0;
    }
  }
LABEL_15:
  v37 = *(float *)(a2 + 16) * 0.1;
  v38 = *(float *)(a2 + 20) * 0.1;
  v24 = 0.1 * *(float *)(a2 + 24);
  v39 = v24;
  if ( v24 > 0.0 )
    v39 = 0.0;
  v25 = *(float *)(a1 + 308) + v37;
  v26 = *(float *)(a1 + 312);
  *(float *)(a1 + 308) = v25;
  v27 = v25;
  v28 = v26 + v38;
  v29 = *(float *)(a1 + 316);
  *(float *)(a1 + 312) = v28;
  v30 = v29 + v39;
  *(float *)(a1 + 24) = v27;
  *(float *)(a1 + 28) = v28;
  *(float *)(a1 + 316) = v30;
  *(float *)(a1 + 32) = v30;
  *(_DWORD *)(a1 + 16) = level[122];
  G_MissileLandAngles(a1, (float *)a2, v36, 0);
  *(float *)(a1 + 60) = v36[0];
  *(float *)(a1 + 64) = v36[1];
  *(float *)(a1 + 68) = v36[2];
  *(_DWORD *)(a1 + 52) = level[122];
  if ( v2 )
    return 0;
  v31 = *(float *)(a1 + 36) - v40;
  v40 = v31;
  v32 = *(float *)(a1 + 40) - v41;
  v41 = v32;
  v33 = *(float *)(a1 + 44) - v42;
  v42 = v33;
  v35 = sqrt(v32 * v32 + v31 * v31 + v33 * v33);
  return v35 > 100.0;
}
// 5397C: variable 'v19' is possibly undefined
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (00053AB4) --------------------------------------------------------
int __cdecl G_MissileImpact(int a1, int a2)
{
  int result; // eax
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7; // eax
  int *v8; // eax
  int v9; // edx
  int v10; // eax
  int *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // [esp-18h] [ebp-60h]
  float v15; // [esp-14h] [ebp-5Ch]
  float v16; // [esp-10h] [ebp-58h]
  float v17; // [esp-Ch] [ebp-54h]
  int v18; // [esp+20h] [ebp-28h]
  int v19; // [esp+24h] [ebp-24h]
  int *v20; // [esp+28h] [ebp-20h]
  float v21; // [esp+38h] [ebp-10h]
  float v22; // [esp+3Ch] [ebp-Ch] BYREF
  float v23; // [esp+40h] [ebp-8h]
  float v24; // [esp+44h] [ebp-4h]

  v19 = 0;
  v20 = &g_entities[197 * *(unsigned __int16 *)(a2 + 40)];
  if ( *((_BYTE *)v20 + 369) )
  {
    if ( !*(_DWORD *)(a1 + 568) )
      return G_BounceMissile(a1, a2);
    if ( LogAccuracyHit((int)v20, (int)&g_entities[197 * *(_DWORD *)(a1 + 332)]) )
      v19 = 1;
    BG_EvaluateTrajectoryDelta(a1 + 12, level[122], &v22);
    v21 = sqrt(v22 * v22 + v23 * v23 + v24 * v24);
    v4 = v21 > 0.0;
    v5 = 0;
    v6 = 0.0 == v21;
    if ( (v3 & 0x44) == 0x40 )
      v24 = 1.0;
    v7 = *(_DWORD *)(a1 + 332);
    if ( v7 == 1023 )
      v8 = 0;
    else
      v8 = &g_entities[197 * v7];
    G_Damage(v20, (int *)a1, v8, &v22, (float *)(a1 + 308), *(_DWORD *)(a1 + 568), 0, *(_DWORD *)(a1 + 584), 0);
  }
  else if ( (*(_BYTE *)(a1 + 11) & 3) != 0 )
  {
    result = G_BounceMissile(a1, a2);
    if ( result )
    {
      if ( !*(_BYTE *)(a2 + 47) )
      {
        result = *(unsigned __int16 *)(a1 + 374);
        if ( (_WORD)result != scr_const[122] )
        {
          if ( (_WORD)result == scr_const[24] )
            result = G_AddEvent((_DWORD *)a1, 194, 0);
          else
            result = G_AddEvent((_DWORD *)a1, 177, (*(_DWORD *)(a2 + 28) & 0x1F00000u) >> 20);
        }
      }
    }
    return result;
  }
  v9 = *(_DWORD *)(a1 + 568);
  if ( v9 )
  {
    v10 = *(_DWORD *)(a1 + 332);
    if ( v10 == 1023 )
      v11 = &g_entities[201334];
    else
      v11 = &g_entities[197 * v10];
    G_CheckHitTriggerDamage(v11, (float *)(a1 + 308), (float *)(a2 + 4), v9, *(_DWORD *)(a1 + 584));
  }
  v18 = 0;
  if ( v19 || *(_WORD *)(a2 + 42) )
    v18 = 1;
  v14 = (unsigned __int8)DirToByte((float *)(a2 + 16));
  v12 = 179;
  if ( v18 )
    v12 = 180;
  G_AddEvent((_DWORD *)a1, v12, v14);
  *(_DWORD *)(a1 + 136) = (*(_DWORD *)(a2 + 28) & 0x1F00000u) >> 20;
  *(_DWORD *)(a1 + 388) = 1;
  *(_DWORD *)(a1 + 4) = 0;
  SnapVectorTowards(a2 + 4, a1 + 24);
  G_SetOrigin(a1, (float *)(a2 + 4));
  v13 = *(_DWORD *)(a1 + 572);
  if ( v13 )
  {
    v17 = (float)*(int *)(a1 + 580);
    v16 = (float)*(int *)(a1 + 576);
    v15 = (float)v13;
    G_RadiusDamage(a2 + 4, a1, *(_DWORD *)(a1 + 408), v15, v16, v17, (int)v20, *(_DWORD *)(a1 + 588));
  }
  return trap_LinkEntity(a1);
}
// 53BCB: variable 'v3' is possibly undefined

//----- (00053D6C) --------------------------------------------------------
int __cdecl G_ExplodeMissile(int a1)
{
  int result; // eax
  unsigned __int8 v2; // al
  int v3; // edx
  float v4; // [esp-14h] [ebp-8Ch]
  float v5; // [esp-10h] [ebp-88h]
  float v6; // [esp-Ch] [ebp-84h]
  char v7[16]; // [esp+24h] [ebp-54h] BYREF
  float v8[11]; // [esp+34h] [ebp-44h] BYREF
  float v9; // [esp+60h] [ebp-18h] BYREF
  float v10; // [esp+64h] [ebp-14h]
  float v11; // [esp+68h] [ebp-10h]
  int v12; // [esp+6Ch] [ebp-Ch]
  int v13; // [esp+70h] [ebp-8h]
  int v14; // [esp+74h] [ebp-4h]

  BG_EvaluateTrajectory(a1 + 12, level[122], &v9);
  v9 = (float)(int)v9;
  v10 = (float)(int)v10;
  v11 = (float)(int)v11;
  G_SetOrigin(a1, &v9);
  v13 = 0;
  v12 = 0;
  v14 = 1065353216;
  *(_DWORD *)(a1 + 4) = 0;
  *(_BYTE *)(a1 + 9) |= 1u;
  *(_BYTE *)(a1 + 381) |= 0x10u;
  *(_BYTE *)(a1 + 244) |= 8u;
  if ( *(_WORD *)(a1 + 374) == scr_const[24] )
  {
    *(_DWORD *)(a1 + 388) = 1;
    result = trap_LinkEntity(a1);
  }
  else
  {
    v8[8] = *(float *)(a1 + 308);
    v8[9] = *(float *)(a1 + 312);
    v8[10] = *(float *)(a1 + 316) - 16.0;
    trap_Trace((int)v7, a1 + 308, (int)&vec3_origin);
    v2 = DirToByte(v8);
    G_AddEvent((_DWORD *)a1, 178, v2);
    if ( trap_PointContents(a1 + 308, -1, 32) )
      *(_DWORD *)(a1 + 136) = 20;
    else
      *(_DWORD *)(a1 + 136) = (LODWORD(v8[3]) & 0x1F00000u) >> 20;
    v3 = *(_DWORD *)(a1 + 572);
    *(_DWORD *)(a1 + 388) = 1;
    if ( v3 )
    {
      v6 = (float)*(int *)(a1 + 580);
      v5 = (float)*(int *)(a1 + 576);
      v4 = (float)v3;
      G_RadiusDamage(a1 + 308, a1, *(_DWORD *)(a1 + 408), v4, v5, v6, a1, *(_DWORD *)(a1 + 588));
    }
    trap_LinkEntity(a1);
    result = G_Spawn();
    *(float *)(result + 308) = *(float *)(a1 + 308);
    *(float *)(result + 312) = *(float *)(a1 + 312);
    *(float *)(result + 316) = *(float *)(a1 + 316);
    *(_DWORD *)(result + 512) = Concussive_think;
    *(_DWORD *)(result + 508) = level[122] + 100;
    *(float *)(result + 628) = (long double)level[122] + 500.0;
  }
  return result;
}
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);
// 72910: using guessed type float vec3_origin;

//----- (00053FCC) --------------------------------------------------------
void *__cdecl G_RunMissile(void *s)
{
  long double v1; // fst7
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  char v5; // fps^1
  void *result; // eax
  char v7; // fps^1
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  _DWORD *v11; // ebx
  int v12; // eax
  int *v13; // ebx
  int v14; // esi
  char v15; // fps^1
  long double v16; // fst6
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  char v23; // fps^1
  bool v24; // c0
  char v25; // c2
  bool v26; // c3
  char v27; // fps^1
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  long double v31; // fst7
  char v32; // fps^1
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  char v36; // fps^1
  bool v37; // c0
  char v38; // c2
  bool v39; // c3
  float *v40; // [esp+18h] [ebp-70h]
  float v41[2]; // [esp+1Ch] [ebp-6Ch] BYREF
  float v42; // [esp+24h] [ebp-64h]
  float v43; // [esp+30h] [ebp-58h]
  float v44[3]; // [esp+34h] [ebp-54h] BYREF
  float v45; // [esp+40h] [ebp-48h] BYREF
  float v46; // [esp+44h] [ebp-44h]
  float v47; // [esp+48h] [ebp-40h]
  float v48; // [esp+4Ch] [ebp-3Ch]
  float v49[2]; // [esp+50h] [ebp-38h] BYREF
  float v50; // [esp+58h] [ebp-30h]
  int v51; // [esp+5Ch] [ebp-2Ch]
  unsigned __int16 v52; // [esp+68h] [ebp-20h]
  char v53; // [esp+6Fh] [ebp-19h]
  float v54[3]; // [esp+70h] [ebp-18h] BYREF
  float v55; // [esp+7Ch] [ebp-Ch] BYREF
  float v56; // [esp+80h] [ebp-8h]
  float v57; // [esp+84h] [ebp-4h]

  v44[0] = *((float *)s + 77);
  v44[1] = *((float *)s + 78);
  v44[2] = *((float *)s + 79);
  BG_EvaluateTrajectory((int)s + 12, level[122], &v55);
  v54[0] = v55 - *((float *)s + 77);
  v54[1] = v56 - *((float *)s + 78);
  v54[2] = v57 - *((float *)s + 79);
  v1 = VectorNormalize(v54);
  v2 = v1 < 0.001;
  v3 = 0;
  v4 = v1 == 0.001;
  if ( (v5 & 0x45) == 1 )
    return (void *)G_RunThink((int)s);
  v40 = (float *)((char *)s + 308);
  if ( fabs(*((float *)s + 11)) > 30.0 )
    trap_PointContents((int)v40, -1, 32);
  trap_LocationalTrace((int)&v45, (int)v40, (int)&v55);
  if ( (v51 & 0x1F00000) == 20971520 )
  {
    VectorNormalize2((float *)s + 9, v41);
    v8 = v42 < 0.0;
    v9 = 0;
    v10 = v42 == 0.0;
    if ( (v7 & 0x45) == 1 )
      v42 = -v42;
    v11 = G_TempEntity(v40, 173);
    v11[40] = (unsigned __int8)DirToByte(v49);
    v11[54] = (unsigned __int8)DirToByte(v41);
    v11[34] = (v51 & 0x1F00000u) >> 20;
    v11[29] = *(_DWORD *)s;
    trap_LocationalTrace((int)&v45, (int)v40, (int)&v55);
  }
  if ( *((_DWORD *)s + 146) == 3 )
  {
    v12 = 197 * v52;
    if ( (g_entities[v12 + 95] & 0x10000) != 0 )
    {
      v13 = &g_entities[v12];
      v14 = g_entities[v12 + 70];
      g_entities[v12 + 70] = 0;
      trap_LocationalTrace((int)&v45, (int)v40, (int)&v55);
      v13[70] = v14;
    }
  }
  *((float *)s + 77) = v46;
  *((float *)s + 78) = v47;
  *((float *)s + 79) = v48;
  if ( v53 )
    v45 = 0.0;
  if ( (*((_BYTE *)s + 11) & 3) != 0 )
  {
    v16 = v45;
    v17 = v45 < 1.0;
    v18 = 0;
    v19 = v45 == 1.0;
    if ( (v15 & 0x45) == 64
      || (v20 = v16 < 1.0, v21 = 0, v22 = v16 == 1.0, (v15 & 0x45) == 1)
      && (v24 = v50 > 0.69999999, v25 = 0, v26 = 0.69999999 == v50, (v23 & 0x45) == 1) )
    {
      v55 = *((float *)s + 77);
      v56 = *((float *)s + 78);
      v57 = *((float *)s + 79) - 1.5;
      trap_LocationalTrace((int)&v45, (int)v40, (int)&v55);
      v28 = v45 < 1.0;
      v29 = 0;
      v30 = v45 == 1.0;
      if ( (v27 & 0x45) != 64 )
      {
        v31 = v48 + 1.5;
        *((float *)s + 8) = v31 - *((float *)s + 79) + *((float *)s + 8);
        *((float *)s + 77) = v46;
        *((float *)s + 78) = v47;
        *((float *)s + 79) = v31;
      }
    }
  }
  trap_LinkEntity((int)s);
  if ( *((_DWORD *)s + 146) == 3 )
    G_GrenadeTouchTriggerDamage((int *)s, v44, v40, *((_DWORD *)s + 143), 3);
  v33 = v45 < 1.0;
  v34 = 0;
  v35 = v45 == 1.0;
  if ( (v32 & 0x45) == 64 )
  {
    v43 = sqrt(
            *((float *)s + 9) * *((float *)s + 9)
          + *((float *)s + 10) * *((float *)s + 10)
          + *((float *)s + 11) * *((float *)s + 11));
    v37 = v43 > 0.0;
    v38 = 0;
    v39 = 0.0 == v43;
    if ( (v36 & 0x45) != 64 )
      *((_DWORD *)s + 31) = 1023;
    return (void *)G_RunThink((int)s);
  }
  if ( (v51 & 0x10) != 0 )
    return G_FreeEntity(s);
  result = (void *)G_MissileImpact((int)s, (int)&v45);
  if ( *((_DWORD *)s + 1) == 4 )
    return (void *)G_RunThink((int)s);
  return result;
}
// 54044: variable 'v5' is possibly undefined
// 540FF: variable 'v7' is possibly undefined
// 5422C: variable 'v15' is possibly undefined
// 5424F: variable 'v23' is possibly undefined
// 542B5: variable 'v27' is possibly undefined
// 54327: variable 'v32' is possibly undefined
// 54385: variable 'v36' is possibly undefined
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (000543AC) --------------------------------------------------------
int __cdecl fire_grenade(_DWORD *a1, float *a2, float *a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // esi
  long double v10; // fst7
  long double v11; // fst7
  float v13; // [esp-20h] [ebp-48h]
  int v14; // [esp+20h] [ebp-8h]

  v4 = G_Spawn();
  v5 = a1[86];
  if ( v5 && (v6 = *(_DWORD *)(v5 + 52)) != 0 )
    v7 = level[122] + v6;
  else
    v7 = level[122] + 2500;
  *(_DWORD *)(v4 + 508) = v7;
  v8 = a1[86];
  if ( v8 )
    *(_DWORD *)(v8 + 52) = 0;
  *(_DWORD *)(v4 + 512) = G_ExplodeMissile;
  *(_DWORD *)(v4 + 4) = 4;
  *(_DWORD *)(v4 + 244) = 136;
  *(_DWORD *)(v4 + 200) = a4;
  *(_DWORD *)(v4 + 332) = *a1;
  *(_DWORD *)(v4 + 408) = a1;
  v9 = (_DWORD *)BG_GetInfoForWeapon(a4);
  Scr_SetString(v4 + 374, scr_const[31]);
  *(_DWORD *)(v4 + 568) = v9[112];
  *(_DWORD *)(v4 + 572) = v9[195];
  *(_DWORD *)(v4 + 576) = v9[196];
  *(_DWORD *)(v4 + 580) = v9[194];
  *(_DWORD *)(v4 + 584) = 3;
  *(_DWORD *)(v4 + 588) = 4;
  *(_DWORD *)(v4 + 8) = 50331648;
  *(_DWORD *)(v4 + 400) = 41951377;
  *(_DWORD *)(v4 + 12) = 5;
  *(_DWORD *)(v4 + 16) = level[122];
  *(float *)(v4 + 24) = *a2;
  *(float *)(v4 + 28) = a2[1];
  *(float *)(v4 + 32) = a2[2];
  v10 = *a3;
  *(float *)(v4 + 36) = *a3;
  *(float *)(v4 + 40) = a3[1];
  *(float *)(v4 + 44) = a3[2];
  *(float *)(v4 + 36) = (float)(int)v10;
  *(float *)(v4 + 40) = (float)(int)*(float *)(v4 + 40);
  v14 = (int)*(float *)(v4 + 44);
  *(_DWORD *)(v4 + 48) = 2;
  *(float *)(v4 + 44) = (float)v14;
  *(_DWORD *)(v4 + 52) = level[122];
  vectoangles(a3, v4 + 60);
  v13 = *(float *)(v4 + 60) - 120.0;
  *(float *)(v4 + 60) = AngleNormalize360(v13);
  v11 = flrand(-45.0, 45.0);
  *(_DWORD *)(v4 + 76) = 0;
  *(float *)(v4 + 72) = v11 + 720.0;
  *(float *)(v4 + 80) = flrand(-45.0, 45.0) + 360.0;
  *(float *)(v4 + 308) = *a2;
  *(float *)(v4 + 312) = a2[1];
  *(float *)(v4 + 316) = a2[2];
  *(float *)(v4 + 320) = *(float *)(v4 + 60);
  *(float *)(v4 + 324) = *(float *)(v4 + 64);
  *(float *)(v4 + 328) = *(float *)(v4 + 68);
  return v4;
}

//----- (00054614) --------------------------------------------------------
int __cdecl fire_rocket(_DWORD *a1, float *a2, float *a3)
{
  _DWORD *v3; // esi
  int v4; // edi

  VectorNormalize(a3);
  v3 = (_DWORD *)BG_GetInfoForWeapon(a1[50]);
  v4 = G_Spawn();
  Scr_SetString(v4 + 374, scr_const[55]);
  *(_DWORD *)(v4 + 508) = level[122] + 30000;
  *(_DWORD *)(v4 + 512) = G_ExplodeMissile;
  *(_DWORD *)(v4 + 4) = 4;
  *(_BYTE *)(v4 + 10) |= 1u;
  *(_DWORD *)(v4 + 244) = 136;
  *(_DWORD *)(v4 + 200) = a1[50];
  *(_DWORD *)(v4 + 332) = *a1;
  *(_DWORD *)(v4 + 408) = a1;
  *(_DWORD *)(v4 + 568) = v3[112];
  *(_DWORD *)(v4 + 572) = v3[195];
  *(_DWORD *)(v4 + 576) = v3[196];
  *(_DWORD *)(v4 + 580) = v3[194];
  *(_DWORD *)(v4 + 584) = 5;
  *(_DWORD *)(v4 + 588) = 6;
  *(_DWORD *)(v4 + 400) = 41951377;
  *(_DWORD *)(v4 + 12) = 2;
  *(_DWORD *)(v4 + 16) = level[122] - 50;
  *(float *)(v4 + 24) = *a2;
  *(float *)(v4 + 28) = a2[1];
  *(float *)(v4 + 32) = a2[2];
  *(float *)(v4 + 36) = (long double)(int)v3[197] * *a3;
  *(float *)(v4 + 40) = (long double)(int)v3[197] * a3[1];
  *(float *)(v4 + 44) = (long double)(int)v3[197] * a3[2];
  *(float *)(v4 + 36) = (float)(int)*(float *)(v4 + 36);
  *(float *)(v4 + 40) = (float)(int)*(float *)(v4 + 40);
  *(float *)(v4 + 44) = (float)(int)*(float *)(v4 + 44);
  *(float *)(v4 + 308) = *a2;
  *(float *)(v4 + 312) = a2[1];
  *(float *)(v4 + 316) = a2[2];
  vectoangles((float *)(v4 + 36), v4 + 320);
  G_SetAngle(v4, (float *)(v4 + 320));
  return v4;
}

//----- (00054808) --------------------------------------------------------
int __cdecl Concussive_think(int a1)
{
  int result; // eax

  if ( (long double)level[122] > *(float *)(a1 + 628) )
    *(_DWORD *)(a1 + 512) = G_FreeEntity;
  result = level[122] + 100;
  *(_DWORD *)(a1 + 508) = result;
  return result;
}

//----- (00054840) --------------------------------------------------------
int __cdecl Concussive_fx(float *a1)
{
  int result; // eax

  result = G_Spawn();
  *(float *)(result + 308) = *a1;
  *(float *)(result + 312) = a1[1];
  *(float *)(result + 316) = a1[2];
  *(_DWORD *)(result + 512) = Concussive_think;
  *(_DWORD *)(result + 508) = level[122] + 100;
  *(float *)(result + 628) = (long double)level[122] + 500.0;
  return result;
}

//----- (0005489C) --------------------------------------------------------
int __cdecl G_MissileDie(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a2 != a1 )
  {
    *(_BYTE *)(a1 + 369) = 0;
    *(_DWORD *)(a1 + 512) = G_ExplodeMissile;
    *(_DWORD *)(a1 + 508) = level[122] + 10;
  }
  return result;
}

//----- (000548CC) --------------------------------------------------------
int __cdecl DynaSink(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  if ( *(_DWORD *)(a1 + 460) >= level[122] )
  {
    *(float *)(a1 + 32) = *(float *)(a1 + 32) - 0.5;
    result = level[122] + 50;
  }
  else
  {
    *(_DWORD *)(a1 + 512) = G_FreeEntity;
    result = level[122] + 100;
  }
  *(_DWORD *)(a1 + 508) = result;
  return result;
}

//----- (00054930) --------------------------------------------------------
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, float *a4)
{
  int v4; // ecx
  int v5; // ebx
  float *v6; // edx
  float *v7; // eax
  int v8; // ecx
  long double v9; // fst4
  long double v10; // fst5
  long double v11; // fst4
  long double v12; // fst6
  long double v13; // fst0
  long double v14; // fst1
  long double v15; // rt1
  long double v16; // fst1
  long double v17; // fst3
  long double v18; // rt0
  long double v19; // fst3
  int v20; // esi
  int *v21; // eax
  long double v22; // fst7
  long double v23; // fst6
  long double v24; // fst5
  int v25; // edx
  int v26; // eax
  long double v27; // fst7
  long double v28; // fst7
  char v29; // fps^1
  bool v30; // c0
  char v31; // c2
  bool v32; // c3
  long double v33; // fst7
  char v34; // fps^1
  long double v35; // fst6
  bool v36; // c0
  char v37; // c2
  bool v38; // c3
  long double v39; // fst5
  char v40; // fps^1
  long double v41; // fst4
  bool v42; // c0
  char v43; // c2
  bool v44; // c3
  long double v45; // fst3
  char v46; // fps^1
  long double v47; // fst2
  bool v48; // c0
  char v49; // c2
  bool v50; // c3
  long double v51; // rtt
  long double v52; // fst2
  long double v53; // fst3
  long double v54; // rt0
  long double v55; // fst2
  long double v56; // rt1
  long double v57; // fst2
  long double v58; // rt2
  long double v59; // fst2
  long double v60; // rtt
  long double v61; // fst1
  long double v62; // fst4
  long double v63; // rt1
  long double v64; // fst1
  long double v65; // fst2
  long double v66; // rt2
  long double v67; // fst1
  long double v68; // fst4
  long double v69; // fst7
  long double v70; // fst6
  long double v71; // fst5
  long double v72; // fst4
  long double v73; // fst3
  long double v74; // fst2
  long double v76; // fst7
  long double v77; // fst6
  long double v78; // fst5
  int v79; // edx
  char v81; // fps^1
  long double v82; // rt1
  long double v83; // fst2
  bool v84; // c0
  char v85; // c2
  bool v86; // c3
  long double v87; // rt2
  long double v88; // fst3
  long double v89; // rtt
  long double v90; // fst3
  long double v91; // rt0
  long double v92; // fst2
  long double v93; // fst3
  char v94; // fps^1
  long double v95; // fst2
  bool v96; // c0
  char v97; // c2
  bool v98; // c3
  char v99; // fps^1
  bool v100; // c0
  char v101; // c2
  bool v102; // c3
  long double v103; // fst4
  long double v104; // fst5
  char v105; // fps^1
  long double v106; // fst4
  bool v107; // c0
  char v108; // c2
  bool v109; // c3
  char v110; // fps^1
  bool v111; // c0
  char v112; // c2
  bool v113; // c3
  char v114; // fps^1
  bool v115; // c0
  char v116; // c2
  bool v117; // c3
  long double v118; // fst6
  long double v119; // fst7
  char v120; // fps^1
  long double v121; // fst6
  bool v122; // c0
  char v123; // c2
  bool v124; // c3
  long double v126; // [esp+18h] [ebp-130h]
  long double v127; // [esp+18h] [ebp-130h]
  long double v128; // [esp+28h] [ebp-120h]
  long double v129; // [esp+38h] [ebp-110h]
  long double v130; // [esp+48h] [ebp-100h]
  char v131[40]; // [esp+94h] [ebp-B4h] BYREF
  unsigned __int16 v132; // [esp+BCh] [ebp-8Ch]
  char v133; // [esp+C3h] [ebp-85h]
  float v134; // [esp+C4h] [ebp-84h]
  float v135; // [esp+C8h] [ebp-80h]
  float v136; // [esp+CCh] [ebp-7Ch]
  float v137; // [esp+D0h] [ebp-78h] BYREF
  float v138; // [esp+D4h] [ebp-74h]
  float v139; // [esp+D8h] [ebp-70h]
  float v140[3]; // [esp+DCh] [ebp-6Ch] BYREF
  float v141[3]; // [esp+E8h] [ebp-60h] BYREF
  float v142[3]; // [esp+F4h] [ebp-54h] BYREF
  float v143[9]; // [esp+100h] [ebp-48h] BYREF
  float v144; // [esp+124h] [ebp-24h]
  float v145; // [esp+128h] [ebp-20h]
  float v146; // [esp+12Ch] [ebp-1Ch]
  float v147; // [esp+130h] [ebp-18h] BYREF
  float v148; // [esp+134h] [ebp-14h]
  float v149; // [esp+138h] [ebp-10h]
  float v150; // [esp+13Ch] [ebp-Ch]
  float v151; // [esp+140h] [ebp-8h]
  float v152; // [esp+144h] [ebp-4h]

  if ( (*(_BYTE *)(a2 + 11) & 4) != 0 && *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
    return 0;
  v137 = *(float *)(a1 + 308) + *a3;
  v138 = *(float *)(a1 + 312) + a3[1];
  v139 = *(float *)(a1 + 316) + a3[2];
  AngleVectors(a4, v140, v141, v142);
  VectorInverse(v141);
  v4 = 0;
  do
  {
    v5 = v4 + 1;
    v6 = &v143[3 * v4];
    v7 = &v140[v4];
    v8 = 2;
    do
    {
      *v6++ = *v7;
      v7 += 3;
      --v8;
    }
    while ( v8 >= 0 );
    v4 = v5;
  }
  while ( v5 <= 2 );
  v9 = v137 - *(float *)(a2 + 308);
  v150 = v9;
  v10 = v9;
  v11 = v138 - *(float *)(a2 + 312);
  v151 = v11;
  v12 = v139 - *(float *)(a2 + 316);
  v134 = v10;
  v135 = v11;
  v152 = v12;
  v13 = v143[2] * v12 + v143[1] * v11 + v143[0] * v10;
  v147 = v13;
  v136 = v12;
  v14 = v13 - v10;
  v144 = v14;
  v15 = v14;
  v16 = v143[5] * v12 + v143[3] * v10 + v143[4] * v11;
  v148 = v16;
  v17 = v16 - v11;
  v145 = v17;
  v18 = v17;
  v19 = v143[7] * v11 + v143[6] * v10 + v143[8] * v12;
  v149 = v19;
  v137 = v15 + v137;
  v146 = v19 - v12;
  v138 = v18 + v138;
  v139 = v139 + v19 - v12;
  if ( *(_DWORD *)(a1 + 400) && *(_DWORD *)(a1 + 280) == 0x4000000
    || ((v20 = a1 + 256, *(_DWORD *)(a1 + 4) != 4) ? trap_Trace((int)v131, (int)&v137, a1 + 256) : trap_Trace(
                                                                                                     (int)v131,
                                                                                                     (int)&v137,
                                                                                                     a1 + 256),
        !v133 ? (v21 = 0) : (v21 = &g_entities[197 * v132]),
        !v21) )
  {
    if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
      *(_DWORD *)(a1 + 124) = 1023;
    v22 = v137;
    *(float *)(a1 + 308) = v137;
    v23 = v138;
    *(float *)(a1 + 312) = v138;
    v24 = v139;
    *(float *)(a1 + 316) = v139;
    *(float *)(a1 + 24) = v22;
    *(float *)(a1 + 28) = v23;
    *(float *)(a1 + 32) = v24;
    v25 = *(_DWORD *)(a1 + 344);
    if ( v25 )
    {
      *(_DWORD *)(v25 + 76) += (unsigned __int16)(int)(a4[1] * 182.04445);
      *(float *)(*(_DWORD *)(a1 + 344) + 20) = v137;
      *(float *)(*(_DWORD *)(a1 + 344) + 24) = v138;
      v26 = *(_DWORD *)(a1 + 344);
      v27 = v139;
LABEL_42:
      *(float *)(v26 + 28) = v27;
    }
LABEL_43:
    dword_AA980 += 32;
    return 1;
  }
  v28 = *(float *)(a1 + 268) * 0.5;
  if ( v28 > 4.0 )
  {
    v150 = v137;
    v151 = v138;
    v152 = v139;
    v30 = v28 > 0.0;
    v31 = 0;
    v32 = 0.0 == v28;
    v33 = 0.0;
    if ( (v29 & 0x45) == 1 )
    {
      while ( 1 )
      {
        v35 = -v33;
        v36 = -v33 < v33;
        v37 = 0;
        v38 = -v33 == v33;
        if ( (unsigned __int8)((v34 & 0x45) - 1) < 0x40u )
          break;
LABEL_51:
        v118 = v33;
        v119 = *(float *)(a1 + 268) * 0.5;
        v121 = v118 + 4.0;
        v122 = v121 < v119;
        v123 = 0;
        v124 = v121 == v119;
        v33 = v121;
        if ( (v120 & 0x45) != 1 )
          goto LABEL_52;
      }
      while ( 1 )
      {
        v39 = 4.0;
        if ( *(float *)(a1 + 268) * 0.5 > 4.0 )
          break;
LABEL_49:
        v111 = v35 > 0.0;
        v112 = 0;
        v113 = 0.0 == v35;
        if ( (v110 & 0x45) != 64 )
        {
          v35 = v35 + v33 + v33;
          v115 = v35 < v33;
          v116 = 0;
          v117 = v35 == v33;
          if ( (unsigned __int8)((v114 & 0x45) - 1) < 0x40u )
            continue;
        }
        goto LABEL_51;
      }
      while ( 1 )
      {
        v41 = -v39;
        v42 = -v39 < v39;
        v43 = 0;
        v44 = -v39 == v39;
        if ( (unsigned __int8)((v40 & 0x45) - 1) < 0x40u )
          break;
LABEL_48:
        v103 = v39;
        v104 = *(float *)(a1 + 268) * 0.5;
        v106 = v103 + 4.0;
        v107 = v106 < v104;
        v108 = 0;
        v109 = v106 == v104;
        v39 = v106;
        if ( (v105 & 0x45) != 1 )
          goto LABEL_49;
      }
      while ( 1 )
      {
        v45 = 4.0;
        if ( *(float *)(a1 + 268) * 0.5 > 4.0 )
          break;
LABEL_47:
        v41 = v41 + v39 + v39;
        v100 = v41 < v39;
        v101 = 0;
        v102 = v41 == v39;
        if ( (unsigned __int8)((v99 & 0x45) - 1) >= 0x40u )
          goto LABEL_48;
      }
      while ( 1 )
      {
        v47 = -v45;
        v48 = -v45 < v45;
        v49 = 0;
        v50 = -v45 == v45;
        if ( (unsigned __int8)((v46 & 0x45) - 1) < 0x40u )
          break;
LABEL_46:
        v92 = v45;
        v93 = *(float *)(a1 + 268) * 0.5;
        v95 = v92 + 4.0;
        v96 = v95 < v93;
        v97 = 0;
        v98 = v95 == v93;
        v45 = v95;
        if ( (v94 & 0x45) != 1 )
          goto LABEL_47;
      }
      while ( 1 )
      {
        v147 = v150 + v41;
        v61 = v41;
        v62 = v151 + v47;
        v144 = v61;
        v63 = v61;
        v64 = v47;
        v65 = v63;
        v145 = v64;
        v66 = v64;
        v67 = v62;
        v68 = v66;
        v148 = v67;
        v146 = v35;
        v149 = v152 + v35;
        if ( *(_DWORD *)(a1 + 400) )
        {
          if ( *(_DWORD *)(a1 + 280) == 0x4000000 )
            break;
        }
        v130 = v35;
        if ( *(_DWORD *)(a1 + 4) == 4 )
        {
          v128 = v39;
          v126 = v33;
          trap_Trace((int)v131, (int)&v147, v20);
          v69 = v68;
          v70 = v65;
          v71 = v130;
          v72 = v45;
          v73 = v128;
          v74 = v126;
        }
        else
        {
          v129 = v45;
          v127 = v33;
          trap_Trace((int)v131, (int)&v147, v20);
          v69 = v68;
          v70 = v65;
          v73 = v39;
          v71 = v130;
          v74 = v127;
          v72 = v129;
        }
        if ( !(v133 ? &g_entities[197 * v132] : 0) )
          break;
        v82 = v74;
        v83 = v69 + v72 + v72;
        v33 = v82;
        v84 = v83 < v72;
        v85 = 0;
        v86 = v83 == v72;
        if ( (unsigned __int8)((v81 & 0x45) - 1) >= 0x40u )
        {
          v87 = v73;
          v88 = v71;
          v39 = v87;
          v89 = v88;
          v90 = v70;
          v35 = v89;
          v91 = v90;
          v45 = v72;
          v41 = v91;
          goto LABEL_46;
        }
        v51 = v83;
        v52 = v73;
        v53 = v51;
        v54 = v52;
        v55 = v71;
        v39 = v54;
        v56 = v55;
        v57 = v70;
        v35 = v56;
        v58 = v57;
        v59 = v72;
        v41 = v58;
        v60 = v59;
        v47 = v53;
        v45 = v60;
      }
      if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
        *(_DWORD *)(a1 + 124) = 1023;
      v76 = v147;
      *(float *)(a1 + 308) = v147;
      v77 = v148;
      *(float *)(a1 + 312) = v148;
      v78 = v149;
      *(float *)(a1 + 316) = v149;
      *(float *)(a1 + 24) = v76;
      *(float *)(a1 + 28) = v77;
      *(float *)(a1 + 32) = v78;
      v79 = *(_DWORD *)(a1 + 344);
      if ( v79 )
      {
        *(_DWORD *)(v79 + 76) += (unsigned __int16)(int)(a4[1] * 182.04445);
        *(float *)(*(_DWORD *)(a1 + 344) + 20) = v147;
        *(float *)(*(_DWORD *)(a1 + 344) + 24) = v148;
        v26 = *(_DWORD *)(a1 + 344);
        v27 = v149;
        goto LABEL_42;
      }
      goto LABEL_43;
    }
  }
LABEL_52:
  if ( !*(_DWORD *)(a1 + 400) || *(_DWORD *)(a1 + 280) != 0x4000000 )
  {
    trap_Trace((int)v131, a1 + 308, v20);
    if ( v133 ? &g_entities[197 * v132] : 0 )
      return 0;
  }
  *(_DWORD *)(a1 + 124) = 1023;
  return 1;
}
// 54C5F: variable 'v29' is possibly undefined
// 54C78: variable 'v34' is possibly undefined
// 54CB8: variable 'v40' is possibly undefined
// 54CF8: variable 'v46' is possibly undefined
// 54F5E: variable 'v81' is possibly undefined
// 54F93: variable 'v94' is possibly undefined
// 54FAD: variable 'v99' is possibly undefined
// 54FD8: variable 'v105' is possibly undefined
// 54FEE: variable 'v110' is possibly undefined
// 55000: variable 'v114' is possibly undefined
// 5502B: variable 'v120' is possibly undefined
// AA980: using guessed type int dword_AA980;

//----- (000550F0) --------------------------------------------------------
int __cdecl sub_550F0(int a1, float *a2, float *a3, _DWORD *a4)
{
  char v4; // fps^1
  long double v5; // fst6
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  char v9; // fps^1
  long double v10; // fst6
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  char v14; // fps^1
  long double v15; // fst6
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  char v19; // fps^1
  long double v20; // fst6
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  char v24; // fps^1
  long double v25; // fst6
  bool v26; // c0
  char v27; // c2
  bool v28; // c3
  char v29; // fps^1
  long double v30; // fst6
  bool v31; // c0
  char v32; // c2
  bool v33; // c3
  long double v34; // fst7
  int v35; // ebx
  int v36; // eax
  int v37; // ecx
  long double v38; // fst5
  long double v39; // fst6
  long double v40; // fst4
  int v41; // eax
  int v42; // ecx
  long double v43; // fst7
  int v44; // edi
  int v45; // ecx
  long double v46; // fst6
  int v47; // eax
  int v48; // ebx
  char *v49; // edi
  int v50; // esi
  int v51; // eax
  int *v52; // ebx
  int v53; // edx
  char v54; // fps^1
  bool v55; // c0
  char v56; // c2
  bool v57; // c3
  char v58; // fps^1
  bool v59; // c0
  char v60; // c2
  bool v61; // c3
  char v62; // fps^1
  bool v63; // c0
  char v64; // c2
  bool v65; // c3
  int *v66; // eax
  int i; // esi
  int j; // esi
  int v69; // edi
  float *v70; // eax
  int k; // esi
  int v73; // [esp+24h] [ebp-2064h]
  char v74[40]; // [esp+28h] [ebp-2060h] BYREF
  unsigned __int16 v75; // [esp+50h] [ebp-2038h]
  char v76; // [esp+57h] [ebp-2031h]
  float v77[3]; // [esp+58h] [ebp-2030h] BYREF
  float v78[1027]; // [esp+64h] [ebp-2024h] BYREF
  char v79[4096]; // [esp+1070h] [ebp-1018h] BYREF
  float v80; // [esp+2070h] [ebp-18h]
  float v81; // [esp+2074h] [ebp-14h]
  float v82; // [esp+2078h] [ebp-10h]
  float v83[3]; // [esp+207Ch] [ebp-Ch]

  *a4 = 0;
  v5 = *(float *)(a1 + 320);
  v6 = v5 < 0.0;
  v7 = 0;
  v8 = v5 == 0.0;
  if ( (v4 & 0x44) != 0x40 )
    goto LABEL_7;
  v10 = *(float *)(a1 + 324);
  v11 = v10 < 0.0;
  v12 = 0;
  v13 = v10 == 0.0;
  if ( (v9 & 0x44) != 0x40 )
    goto LABEL_7;
  v15 = *(float *)(a1 + 328);
  v16 = v15 < 0.0;
  v17 = 0;
  v18 = v15 == 0.0;
  if ( (v14 & 0x44) != 0x40 )
    goto LABEL_7;
  v20 = *a3;
  v21 = v20 < 0.0;
  v22 = 0;
  v23 = v20 == 0.0;
  if ( (v19 & 0x44) != 0x40 )
    goto LABEL_7;
  v25 = a3[1];
  v26 = v25 < 0.0;
  v27 = 0;
  v28 = v25 == 0.0;
  if ( (v24 & 0x44) != 0x40 || (v30 = a3[2], v31 = v30 < 0.0, v32 = 0, v33 = v30 == 0.0, (v29 & 0x45) != 64) )
  {
LABEL_7:
    v34 = RadiusFromBounds(a1 + 256, a1 + 268);
    v35 = a1 + 308;
    v36 = 0;
    v37 = 2;
    do
    {
      v38 = *(float *)(v35 + v36 * 4) - v34;
      v39 = a2[v36];
      v40 = *(float *)(v35 + v36 * 4) + v34;
      v83[v36] = v38 + v39;
      *(float *)((char *)&v80 + v36 * 4) = v39 + v40;
      v78[v36] = v38;
      v77[v36++] = v40;
      --v37;
    }
    while ( v37 >= 0 );
  }
  else
  {
    v41 = 0;
    v42 = 2;
    do
    {
      v43 = a2[v41];
      v83[v41] = *(float *)(a1 + 284 + v41 * 4) + v43;
      *(float *)((char *)&v80 + v41 * 4) = v43 + *(float *)(a1 + 296 + v41 * 4);
      ++v41;
      --v42;
    }
    while ( v42 >= 0 );
    v78[0] = *(float *)(a1 + 284);
    v78[1] = *(float *)(a1 + 288);
    v78[2] = *(float *)(a1 + 292);
    v77[0] = *(float *)(a1 + 296);
    v77[1] = *(float *)(a1 + 300);
    v77[2] = *(float *)(a1 + 304);
  }
  v44 = 0;
  v45 = 2;
  do
  {
    v46 = a2[v44];
    if ( v46 <= 0.0 )
      v78[v44] = v46 + v78[v44];
    else
      v77[v44] = v46 + v77[v44];
    ++v44;
    --v45;
  }
  while ( v45 >= 0 );
  trap_UnlinkEntity(a1);
  v47 = trap_EntitiesInBox((int)v78, (int)v77, (int)v79);
  *(float *)(a1 + 308) = *(float *)(a1 + 308) + *a2;
  *(float *)(a1 + 312) = *(float *)(a1 + 312) + a2[1];
  *(float *)(a1 + 316) = *(float *)(a1 + 316) + a2[2];
  *(float *)(a1 + 320) = *(float *)(a1 + 320) + *a3;
  v48 = v47;
  *(float *)(a1 + 324) = *(float *)(a1 + 324) + a3[1];
  *(float *)(a1 + 328) = *(float *)(a1 + 328) + a3[2];
  trap_LinkEntity(a1);
  v73 = 0;
  if ( v48 > 0 )
  {
    v49 = v79;
    v50 = v48;
    do
    {
      v51 = 197 * *(_DWORD *)v49;
      v52 = &g_entities[v51];
      v53 = g_entities[v51 + 1];
      if ( (unsigned int)(v53 - 3) <= 1 || v53 == 1 || *((_BYTE *)v52 + 353) )
      {
        if ( v52[31] == *(_DWORD *)a1 )
          goto LABEL_36;
        v55 = v80 < (long double)*((float *)v52 + 71);
        v56 = 0;
        v57 = v80 == *((float *)v52 + 71);
        if ( (unsigned __int8)((v54 & 0x45) - 1) >= 0x40u )
        {
          v59 = v81 < (long double)*((float *)v52 + 72);
          v60 = 0;
          v61 = v81 == *((float *)v52 + 72);
          if ( (unsigned __int8)((v58 & 0x45) - 1) >= 0x40u )
          {
            v63 = v82 < (long double)*((float *)v52 + 73);
            v64 = 0;
            v65 = v82 == *((float *)v52 + 73);
            if ( (unsigned __int8)((v62 & 0x45) - 1) >= 0x40u
              && v83[0] < (long double)*((float *)v52 + 74)
              && v83[1] < (long double)*((float *)v52 + 75)
              && v83[2] < (long double)*((float *)v52 + 76) )
            {
              if ( v52[100] && v52[70] == 0x4000000 || (trap_Trace((int)v74, (int)(v52 + 77), (int)(v52 + 64)), !v76) )
                v66 = 0;
              else
                v66 = &g_entities[197 * v75];
              if ( v66 == (int *)a1 )
LABEL_36:
                v78[v73++ + 3] = *(float *)v49;
            }
          }
        }
      }
      v49 += 4;
      --v50;
    }
    while ( v50 );
  }
  for ( i = 0; i < v73; ++i )
    trap_UnlinkEntity((int)&g_entities[197 * LODWORD(v78[i + 3])]);
  for ( j = 0; j < v73; ++j )
  {
    v69 = 197 * LODWORD(v78[j + 3]);
    v70 = (float *)dword_AA980;
    *(_DWORD *)dword_AA980 = &g_entities[v69];
    v70[1] = *(float *)&g_entities[v69 + 77];
    v70[2] = *(float *)&g_entities[v69 + 78];
    v70[3] = *(float *)&g_entities[v69 + 79];
    v70[7] = a3[1];
    if ( G_TryPushingEntity((int)&g_entities[v69], a1, a2, a3) || g_entities[v69 + 1] == 3 )
    {
      trap_LinkEntity((int)&g_entities[v69]);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 12) != 4 && *(_DWORD *)(a1 + 48) != 4 )
      {
        *a4 = &g_entities[v69];
        return 0;
      }
      G_Damage(&g_entities[v69], (int *)a1, (int *)a1, 0, 0, 99999, 0, 0x13u, 0);
    }
  }
  for ( k = 0; k < v73; ++k )
    trap_LinkEntity((int)&g_entities[197 * LODWORD(v78[k + 3])]);
  return 1;
}
// 55114: variable 'v4' is possibly undefined
// 55126: variable 'v9' is possibly undefined
// 55138: variable 'v14' is possibly undefined
// 55149: variable 'v19' is possibly undefined
// 55158: variable 'v24' is possibly undefined
// 55167: variable 'v29' is possibly undefined
// 55419: variable 'v54' is possibly undefined
// 55432: variable 'v58' is possibly undefined
// 5544B: variable 'v62' is possibly undefined
// AA980: using guessed type int dword_AA980;

//----- (00055684) --------------------------------------------------------
void __cdecl G_MoverTeam(_DWORD *a1)
{
  int v1; // ebx
  unsigned int v2; // ebx
  int v3; // edx
  int v4; // ecx
  long double v5; // fst7
  int v6; // ebx
  void (__stdcall *v7)(_DWORD *, int, int, int); // edx
  _DWORD *i; // ebx
  void (__cdecl *v9)(_DWORD *); // eax
  void (__cdecl *v10)(_DWORD *); // eax
  int v11; // [esp-8h] [ebp-60h]
  int v12; // [esp-4h] [ebp-5Ch]
  int v13[2]; // [esp+1Ch] [ebp-3Ch] BYREF
  __int16 v14; // [esp+24h] [ebp-34h]
  __int16 v15; // [esp+26h] [ebp-32h]
  float v16[3]; // [esp+28h] [ebp-30h] BYREF
  float v17[3]; // [esp+34h] [ebp-24h] BYREF
  float v18[3]; // [esp+40h] [ebp-18h] BYREF
  float v19[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v13[0] = 0;
  dword_AA980 = (int)&pushed;
  v1 = (int)a1;
  if ( a1 )
  {
    while ( 1 )
    {
      BG_EvaluateTrajectory(v1 + 12, level[122], v17);
      BG_EvaluateTrajectory(v1 + 48, level[122], v16);
      v19[0] = v17[0] - *(float *)(v1 + 308);
      v19[1] = v17[1] - *(float *)(v1 + 312);
      v19[2] = v17[2] - *(float *)(v1 + 316);
      v18[0] = v16[0] - *(float *)(v1 + 320);
      v18[1] = v16[1] - *(float *)(v1 + 324);
      v18[2] = v16[2] - *(float *)(v1 + 328);
      if ( !sub_550F0(v1, v19, v18, v13) )
        break;
      v1 = *(_DWORD *)(v1 + 608);
      if ( !v1 )
        goto LABEL_13;
    }
    v2 = dword_AA980;
    while ( 1 )
    {
      v2 -= 32;
      if ( v2 < (unsigned int)&pushed )
        break;
      v3 = *(_DWORD *)v2;
      *(float *)(v3 + 308) = *(float *)(v2 + 4);
      *(float *)(v3 + 312) = *(float *)(v2 + 8);
      *(float *)(v3 + 316) = *(float *)(v2 + 12);
      *(float *)(v3 + 24) = *(float *)(v2 + 4);
      *(float *)(v3 + 28) = *(float *)(v2 + 8);
      *(float *)(v3 + 32) = *(float *)(v2 + 12);
      v4 = *(_DWORD *)(v3 + 344);
      if ( v4 )
      {
        v5 = *(float *)(v2 + 28) * 182.04445;
        v14 = v15 | 0xC00;
        v13[1] = (int)v5;
        *(_DWORD *)(v4 + 76) -= (unsigned __int16)(int)v5;
        *(float *)(*(_DWORD *)(v3 + 344) + 20) = *(float *)(v2 + 4);
        *(float *)(*(_DWORD *)(v3 + 344) + 24) = *(float *)(v2 + 8);
        *(float *)(*(_DWORD *)(v3 + 344) + 28) = *(float *)(v2 + 12);
      }
      trap_LinkEntity(v3);
    }
    v6 = (int)a1;
    do
    {
      *(_DWORD *)(v6 + 16) += level[122] - level[123];
      *(_DWORD *)(v6 + 52) += level[122] - level[123];
      BG_EvaluateTrajectory(v6 + 12, level[122], (float *)(v6 + 308));
      BG_EvaluateTrajectory(v6 + 48, level[122], (float *)(v6 + 320));
      trap_LinkEntity(v6);
      v6 = *(_DWORD *)(v6 + 608);
    }
    while ( v6 );
    v7 = (void (__stdcall *)(_DWORD *, int, int, int))a1[130];
    if ( v7 )
      v7(a1, v13[0], v11, v12);
  }
  else
  {
LABEL_13:
    for ( i = a1; i; i = (_DWORD *)i[152] )
    {
      if ( i[3] )
      {
        if ( level[122] >= i[4] + i[5] )
        {
          v9 = (void (__cdecl *)(_DWORD *))i[129];
          if ( v9 )
            v9(i);
        }
      }
      if ( i[12] )
      {
        if ( level[122] >= i[13] + i[14] )
        {
          v10 = (void (__cdecl *)(_DWORD *))i[129];
          if ( v10 )
            v10(i);
        }
      }
    }
  }
}
// 557F9: conditional instruction was optimized away because of '%arg_0.4!=0'
// 55881: variable 'v11' is possibly undefined
// 55881: variable 'v12' is possibly undefined
// AA980: using guessed type int dword_AA980;

//----- (00055904) --------------------------------------------------------
void __cdecl SetMoverState(int a1, int a2, int a3)
{
  int v3; // ecx
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // rt0
  long double v8; // fst6
  long double v9; // fst5
  long double v10; // fst7
  long double v11; // fst6
  long double v12; // fst5
  long double v13; // fst7
  long double v14; // fst6
  long double v15; // rt0
  long double v16; // fst6
  long double v17; // fst5
  long double v18; // fst4
  long double v19; // fst7
  long double v20; // fst6
  long double v21; // rt0
  long double v22; // fst6
  long double v23; // fst5
  int v24; // eax
  long double v25; // fst4
  long double v26; // fst7
  long double v27; // fst6
  long double v28; // rt1
  long double v29; // fst6
  long double v30; // fst5
  char v31; // fps^1
  long double v32; // fst6
  bool v33; // c0
  char v34; // c2
  bool v35; // c3
  int v36; // eax
  long double v37; // fst7
  long double v38; // fst7
  long double v39; // fst6
  int v40; // eax
  long double v41; // fst7
  long double v42; // fst6
  long double v43; // fst7
  long double v44; // fst6
  long double v45; // fst7
  long double v46; // rt0
  int v47; // eax
  long double v48; // fst7
  long double v49; // fst7
  long double v50; // fst6
  int v51; // [esp+18h] [ebp-10h]
  float v52; // [esp+1Ch] [ebp-Ch]
  float v53; // [esp+20h] [ebp-8h]
  float v54; // [esp+24h] [ebp-4h]

  *(_BYTE *)(a1 + 372) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 52) = a3;
  v3 = *(_DWORD *)(a1 + 380) & 0x100;
  switch ( a2 )
  {
    case 0:
      *(float *)(a1 + 24) = *(float *)(a1 + 420);
      *(float *)(a1 + 28) = *(float *)(a1 + 424);
      *(float *)(a1 + 32) = *(float *)(a1 + 428);
      *(_DWORD *)(a1 + 12) = 0;
      *(_BYTE *)(a1 + 370) = 0;
      break;
    case 1:
      *(float *)(a1 + 24) = *(float *)(a1 + 432);
      *(float *)(a1 + 28) = *(float *)(a1 + 436);
      v4 = *(float *)(a1 + 440);
      goto LABEL_5;
    case 2:
      *(float *)(a1 + 24) = *(float *)(a1 + 444);
      *(float *)(a1 + 28) = *(float *)(a1 + 448);
      v4 = *(float *)(a1 + 452);
LABEL_5:
      *(float *)(a1 + 32) = v4;
      *(_DWORD *)(a1 + 12) = 0;
      break;
    case 3:
      v19 = *(float *)(a1 + 420);
      *(float *)(a1 + 24) = *(float *)(a1 + 420);
      v20 = *(float *)(a1 + 424);
      *(float *)(a1 + 28) = *(float *)(a1 + 424);
      v21 = v20;
      v22 = *(float *)(a1 + 432) - v19;
      v23 = *(float *)(a1 + 428);
      *(float *)(a1 + 32) = *(float *)(a1 + 428);
      v10 = v22;
      v11 = *(float *)(a1 + 436) - v21;
      v12 = *(float *)(a1 + 440) - v23;
      v24 = *(_DWORD *)(a1 + 500);
      *(_DWORD *)(a1 + 20) = v24;
      v18 = (long double)v24;
      goto LABEL_10;
    case 4:
      v26 = *(float *)(a1 + 432);
      *(float *)(a1 + 24) = *(float *)(a1 + 432);
      v27 = *(float *)(a1 + 436);
      *(float *)(a1 + 28) = *(float *)(a1 + 436);
      v28 = v27;
      v29 = *(float *)(a1 + 420) - v26;
      v30 = *(float *)(a1 + 440);
      *(float *)(a1 + 32) = *(float *)(a1 + 440);
      v52 = v29;
      v53 = *(float *)(a1 + 424) - v28;
      v54 = *(float *)(a1 + 428) - v30;
      v32 = *(float *)(a1 + 484);
      v33 = v32 < 0.0;
      v34 = 0;
      v35 = v32 == 0.0;
      if ( (v31 & 0x45) == 64 )
        v36 = *(_DWORD *)(a1 + 500);
      else
        v36 = *(_DWORD *)(a1 + 504);
      *(_DWORD *)(a1 + 20) = v36;
      v37 = 1000.0 / (long double)v36;
      *(float *)(a1 + 36) = v52 * v37;
      *(float *)(a1 + 40) = v53 * v37;
      *(_DWORD *)(a1 + 12) = 3;
      *(float *)(a1 + 44) = v37 * v54;
      break;
    case 5:
      v5 = *(float *)(a1 + 432);
      *(float *)(a1 + 24) = *(float *)(a1 + 432);
      v6 = *(float *)(a1 + 436);
      *(float *)(a1 + 28) = *(float *)(a1 + 436);
      v7 = v6;
      v8 = *(float *)(a1 + 444) - v5;
      v9 = *(float *)(a1 + 440);
      *(float *)(a1 + 32) = *(float *)(a1 + 440);
      v10 = v8;
      v11 = *(float *)(a1 + 448) - v7;
      v12 = *(float *)(a1 + 452) - v9;
      goto LABEL_8;
    case 6:
      v13 = *(float *)(a1 + 444);
      *(float *)(a1 + 24) = *(float *)(a1 + 444);
      v14 = *(float *)(a1 + 448);
      *(float *)(a1 + 28) = *(float *)(a1 + 448);
      v15 = v14;
      v16 = *(float *)(a1 + 432) - v13;
      v17 = *(float *)(a1 + 452);
      *(float *)(a1 + 32) = *(float *)(a1 + 452);
      v10 = v16;
      v11 = *(float *)(a1 + 436) - v15;
      v12 = *(float *)(a1 + 440) - v17;
LABEL_8:
      v18 = (long double)*(int *)(a1 + 20);
LABEL_10:
      v25 = 1000.0 / v18;
      *(_DWORD *)(a1 + 12) = 3;
      *(float *)(a1 + 36) = v10 * v25;
      *(float *)(a1 + 40) = v11 * v25;
      *(float *)(a1 + 44) = v12 * v25;
      break;
    case 7:
    case 8:
      *(float *)(a1 + 60) = *(float *)(a1 + 320);
      *(float *)(a1 + 64) = *(float *)(a1 + 324);
      *(float *)(a1 + 68) = *(float *)(a1 + 328);
      *(_DWORD *)(a1 + 48) = 0;
      break;
    case 9:
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 60) = 0;
      if ( v3 )
      {
        v38 = 500.0;
        v51 = *(_DWORD *)(a1 + 500);
        v39 = (long double)v51;
        v40 = 2 * v51;
      }
      else
      {
        v40 = *(_DWORD *)(a1 + 500);
        v39 = (long double)v40;
        v38 = 1000.0;
      }
      *(_DWORD *)(a1 + 56) = v40;
      v41 = v38 / v39 * *(float *)(a1 + 464);
      *(float *)(a1 + 72) = *(float *)(a1 + 640) * v41;
      v42 = v41;
      v43 = *(float *)(a1 + 644) * v41;
      v44 = v42 * *(float *)(a1 + 648);
      *(_DWORD *)(a1 + 48) = 3;
      goto LABEL_23;
    case 10:
      v45 = *(float *)(a1 + 464);
      *(float *)(a1 + 60) = *(float *)(a1 + 640) * v45;
      v46 = v45 * *(float *)(a1 + 648);
      v47 = *(_DWORD *)(a1 + 500);
      *(float *)(a1 + 64) = *(float *)(a1 + 644) * v45;
      *(float *)(a1 + 68) = v46;
      *(_DWORD *)(a1 + 56) = v47;
      v48 = 1000.0 / (long double)v47;
      if ( v3 )
      {
        v48 = v48 * 0.5;
        *(_DWORD *)(a1 + 56) = 2 * v47;
      }
      v49 = -v48;
      *(float *)(a1 + 72) = *(float *)(a1 + 60) * v49;
      v50 = v49;
      v43 = *(float *)(a1 + 64) * v49;
      v44 = v50 * *(float *)(a1 + 68);
      *(_DWORD *)(a1 + 48) = 3;
      *(_BYTE *)(a1 + 370) = 0;
LABEL_23:
      *(float *)(a1 + 76) = v43;
      *(float *)(a1 + 80) = v44;
      break;
    default:
      break;
  }
  BG_EvaluateTrajectory(a1 + 12, level[122], (float *)(a1 + 308));
  if ( (*(_BYTE *)(a1 + 244) & 1) == 0 || *(_DWORD *)(a1 + 280) )
    trap_LinkEntity(a1);
}
// 55AFA: variable 'v31' is possibly undefined

//----- (00055C9C) --------------------------------------------------------
__int16 __cdecl Reached_BinaryMover(int a1)
{
  int v1; // esi
  char v2; // al
  int v3; // eax
  long double v4; // fst7
  __int16 v5; // fps
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  int v9; // eax
  __int16 v10; // fps
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  int v14; // edi
  int *v15; // edx
  int v16; // eax

  *(_DWORD *)(a1 + 132) = 0;
  v1 = *(_BYTE *)(a1 + 381) & 1;
  v2 = *(_BYTE *)(a1 + 372);
  switch ( v2 )
  {
    case 3:
      SetMoverState(a1, 1, level[122]);
      if ( v1 )
        LOWORD(v3) = G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 363));
      else
        LOWORD(v3) = G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 357));
      if ( !*(_DWORD *)(a1 + 604) )
        *(_DWORD *)(a1 + 604) = a1;
      if ( *(char *)(a1 + 380) < 0 )
      {
        *(_BYTE *)(a1 + 370) = 0;
        *(_DWORD *)(a1 + 512) = ReturnToPos1;
        *(_DWORD *)(a1 + 508) = 0;
        return v3;
      }
      v4 = *(float *)(a1 + 616);
      v6 = v4 > -1000.0;
      v7 = 0;
      v8 = -1000.0 == v4;
      LOBYTE(v3) = v5;
      BYTE1(v3) = HIBYTE(v5) & 0x45;
      if ( (HIBYTE(v5) & 0x45) == 64 )
        return v3;
      *(_DWORD *)(a1 + 512) = ReturnToPos1;
LABEL_26:
      v3 = level[122] + (int)v4;
      *(_DWORD *)(a1 + 508) = v3;
      return v3;
    case 4:
      SetMoverState(a1, 0, level[122]);
      if ( v1 )
        v9 = *(unsigned __int8 *)(a1 + 365);
      else
        v9 = *(unsigned __int8 *)(a1 + 354);
      G_PlaySoundAlias((_DWORD *)a1, v9);
      v3 = *(_DWORD *)(a1 + 612);
      break;
    case 9:
      SetMoverState(a1, 8, level[122]);
      if ( v1 )
        LOWORD(v3) = G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 363));
      else
        LOWORD(v3) = G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 357));
      if ( !*(_DWORD *)(a1 + 604) )
        *(_DWORD *)(a1 + 604) = a1;
      if ( *(char *)(a1 + 380) < 0 )
      {
        *(_BYTE *)(a1 + 370) = 0;
        *(_DWORD *)(a1 + 512) = ReturnToPos1Rotate;
        *(_DWORD *)(a1 + 508) = 0;
        return v3;
      }
      v4 = *(float *)(a1 + 616);
      v11 = v4 > -1000.0;
      v12 = 0;
      v13 = -1000.0 == v4;
      LOBYTE(v3) = v10;
      BYTE1(v3) = HIBYTE(v10) & 0x45;
      if ( (HIBYTE(v10) & 0x45) == 64 )
        return v3;
      *(_DWORD *)(a1 + 512) = ReturnToPos1Rotate;
      goto LABEL_26;
    case 10:
      SetMoverState(a1, 7, level[122]);
      v14 = 0;
      v15 = G_Find(0, 374, scr_const[49]);
      if ( v15 )
        v14 = trap_InPVS((int)(v15 + 77), a1 + 308);
      if ( v14 )
      {
        if ( v1 )
          v16 = *(unsigned __int8 *)(a1 + 365);
        else
          v16 = *(unsigned __int8 *)(a1 + 354);
        G_PlaySoundAlias((_DWORD *)a1, v16);
      }
      v3 = *(_DWORD *)(a1 + 612);
      *(_BYTE *)(a1 + 381) &= 0xFEu;
      break;
    default:
      LOWORD(v3) = G_Error("Reached_BinaryMover: bad moverState");
      return v3;
  }
  if ( v3 == a1 || !v3 )
    LOWORD(v3) = trap_AdjustAreaPortalState(a1, 0);
  return v3;
}

//----- (00055F54) --------------------------------------------------------
int __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3)
{
  long double v3; // fst5
  long double v4; // fst4
  long double v5; // fst6
  long double v6; // rt2
  long double v7; // fst5
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  char v18; // fps^1
  long double v19; // fst6
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst7
  char v24; // fps^1
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  int result; // eax
  float v29[3]; // [esp+1Ch] [ebp-3Ch] BYREF
  float v30; // [esp+28h] [ebp-30h] BYREF
  float v31; // [esp+2Ch] [ebp-2Ch]
  float v32; // [esp+30h] [ebp-28h]
  float v33; // [esp+34h] [ebp-24h]
  float v34; // [esp+38h] [ebp-20h]
  float v35; // [esp+3Ch] [ebp-1Ch]
  float v36; // [esp+40h] [ebp-18h] BYREF
  float v37; // [esp+44h] [ebp-14h]
  float v38; // [esp+48h] [ebp-10h]
  float v39[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( *(_WORD *)(a1 + 374) != scr_const[27] || (*(_BYTE *)(a1 + 376) & 0x20) != 0 )
    goto LABEL_11;
  v3 = (*(float *)(a1 + 284) + *(float *)(a1 + 296)) * 0.5;
  v4 = *(float *)(a1 + 292) + *(float *)(a1 + 304);
  v5 = (*(float *)(a1 + 288) + *(float *)(a1 + 300)) * 0.5;
  v33 = v3;
  v6 = v3;
  v34 = v5;
  v7 = 0.5 * v4;
  v35 = v7;
  v39[0] = v6 - *(float *)(a1 + 308);
  v39[1] = v5 - *(float *)(a1 + 312);
  v39[2] = v7 - *(float *)(a1 + 316);
  vectoangles(v39, (int)&v36);
  v8 = *(float *)(a1 + 644);
  v10 = v8 > 0.0;
  v11 = 0;
  v12 = 0.0 == v8;
  if ( (v9 & 0x45) == 64 )
  {
    v14 = *(float *)(a1 + 640);
    v15 = v14 < 0.0;
    v16 = 0;
    v17 = v14 == 0.0;
    if ( (v13 & 0x45) == 64 )
    {
      v19 = *(float *)(a1 + 648);
      v20 = v19 < 0.0;
      v21 = 0;
      v22 = v19 == 0.0;
      if ( (v18 & 0x45) != 64 )
        v38 = v38 + *(float *)(a1 + 464);
    }
    else
    {
      v36 = v36 + *(float *)(a1 + 464);
    }
  }
  else
  {
    v37 = v37 + *(float *)(a1 + 464);
  }
  AngleVectors(&v36, v29, 0, 0);
  v30 = a3[77] - v33;
  v31 = a3[78] - v34;
  v32 = a3[79] - v35;
  VectorNormalize(&v30);
  v23 = v30 * v29[0] + v31 * v29[1] + v32 * v29[2];
  v25 = v23 > 0.0;
  v26 = 0;
  v27 = 0.0 == v23;
  if ( (unsigned __int8)((v24 & 0x45) - 1) >= 0x40u )
LABEL_11:
    result = 0;
  else
    result = 1;
  return result;
}
// 5600D: variable 'v9' is possibly undefined
// 56031: variable 'v13' is possibly undefined
// 5605A: variable 'v18' is possibly undefined
// 560CE: variable 'v24' is possibly undefined

//----- (000560EC) --------------------------------------------------------
void __cdecl Use_BinaryMover(int a1, int a2, float *a3)
{
  int v3; // ecx
  int v4; // edi
  char v5; // al
  int i; // ebx
  int v7; // edx
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  char v13; // al
  int v14; // edi
  int j; // ebx
  int k; // ebx
  int v17; // eax
  int v18; // eax
  long double v19; // fst7
  char v20; // fps^1
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  int v24; // eax
  int v25; // [esp+14h] [ebp-14h]
  int v26; // [esp+18h] [ebp-10h]
  _BOOL4 v27; // [esp+1Ch] [ebp-Ch]

  v3 = 0;
  v4 = (*(_DWORD *)(a1 + 380) >> 8) & 1;
  v27 = level[122] <= 4000;
  if ( (*(_DWORD *)(a1 + 380) & 4) != 0 )
  {
    if ( v4 )
      *(_BYTE *)(*(_DWORD *)(a1 + 612) + 381) |= 1u;
    Use_BinaryMover(*(_DWORD *)(a1 + 612), a2, a3);
    return;
  }
  v5 = *(_BYTE *)(a1 + 372);
  if ( !v5 || v5 == 7 )
    v3 = IsBinaryMoverBlocked(a1, a2, a3);
  if ( v3 )
  {
    v26 = level[122] + 50;
    for ( i = a1; i; i = *(_DWORD *)(i + 608) )
    {
      *(float *)(i + 464) = -*(float *)(i + 464);
      if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
        *(_BYTE *)(i + 381) |= 1u;
      SetMoverState(i, 9, v26);
    }
    goto LABEL_30;
  }
  v7 = *(_DWORD *)(a1 + 412);
  *(_DWORD *)(a1 + 604) = a3;
  if ( v7 )
  {
    v8 = *(float *)(v7 + 616);
    v10 = v8 > -1.0;
    v11 = 0;
    v12 = -1.0 == v8;
    if ( (v9 & 0x44) == 0x40 && *(_DWORD *)(v7 + 592) == 1 )
    {
      *(_DWORD *)(v7 + 592) = 0;
      return;
    }
  }
  v13 = *(_BYTE *)(a1 + 372);
  if ( !v13 )
  {
    v14 = level[122] + 50;
    for ( j = a1; j; j = *(_DWORD *)(j + 608) )
    {
      if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
        *(_BYTE *)(j + 381) |= 1u;
      SetMoverState(j, 3, v14);
    }
    if ( v27 )
      goto LABEL_35;
    goto LABEL_33;
  }
  if ( v13 == 7 )
  {
    v25 = level[122] + 50;
    for ( k = a1; k; k = *(_DWORD *)(k + 608) )
    {
      if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
        *(_BYTE *)(k + 381) |= 1u;
      SetMoverState(k, 9, v25);
    }
LABEL_30:
    if ( v27 )
    {
LABEL_35:
      *(_DWORD *)(a1 + 132) = 0;
      if ( !v27 )
        *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 359);
      v18 = *(_DWORD *)(a1 + 612);
      if ( v18 == a1 || !v18 )
        trap_AdjustAreaPortalState(a1, 1);
      return;
    }
    if ( v4 )
    {
      v17 = *(unsigned __int8 *)(a1 + 362);
LABEL_34:
      G_PlaySoundAlias((_DWORD *)a1, v17);
      goto LABEL_35;
    }
LABEL_33:
    v17 = *(unsigned __int8 *)(a1 + 355);
    goto LABEL_34;
  }
  if ( v13 != 1 )
  {
    switch ( v13 )
    {
      case 8:
        if ( *(char *)(a1 + 380) < 0 )
        {
          *(_DWORD *)(a1 + 508) = level[122] + 50;
          return;
        }
        v19 = *(float *)(a1 + 616);
        goto LABEL_49;
      case 4:
        Blocked_Door(a1, 0);
LABEL_57:
        if ( v27 )
          return;
        v24 = *(unsigned __int8 *)(a1 + 355);
        break;
      case 3:
        Blocked_Door(a1, 0);
        if ( v27 )
          return;
        v24 = *(unsigned __int8 *)(a1 + 356);
        break;
      case 10:
        Blocked_DoorRotate(a1, 0);
        goto LABEL_57;
      case 9:
        Blocked_DoorRotate(a1, 0);
        if ( v27 )
          return;
        if ( !v4 )
        {
          G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 356));
          return;
        }
        v24 = *(unsigned __int8 *)(a1 + 364);
        break;
      default:
        return;
    }
    G_PlaySoundAlias((_DWORD *)a1, v24);
    return;
  }
  if ( *(char *)(a1 + 380) < 0 )
  {
    *(_DWORD *)(a1 + 508) = level[122] + 50;
    return;
  }
  v19 = *(float *)(a1 + 616);
  v21 = v19 > -1000.0;
  v22 = 0;
  v23 = -1000.0 == v19;
  if ( (v20 & 0x45) != 64 )
LABEL_49:
    *(_DWORD *)(a1 + 508) = level[122] + (int)v19;
}
// 561F0: variable 'v9' is possibly undefined
// 56346: variable 'v20' is possibly undefined

//----- (00056454) --------------------------------------------------------
__int16 __cdecl InitMover(int a1)
{
  int v1; // esi
  int v2; // eax
  int v3; // edx
  int v4; // esi
  int v5; // ecx
  int v6; // eax
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // rt1
  long double v10; // fst5
  long double v11; // rt2
  long double v12; // fst5
  long double v13; // fst6
  long double v14; // fst7
  char v15; // fps^1
  long double v16; // fst5
  bool v17; // c0
  char v18; // c2
  bool v19; // c3
  long double v20; // fst6
  long double v21; // fst5
  int v22; // eax
  __int16 v23; // fps
  long double v24; // fst5
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  __int16 result; // ax
  int v29; // [esp+20h] [ebp-38h] BYREF
  char *s2; // [esp+24h] [ebp-34h] BYREF
  float v31; // [esp+34h] [ebp-24h]
  int v32; // [esp+38h] [ebp-20h]
  __int16 v33; // [esp+3Ch] [ebp-1Ch]
  __int16 v34; // [esp+3Eh] [ebp-1Ah]
  int v35[6]; // [esp+40h] [ebp-18h] BYREF

  if ( G_SpawnString("noise", (int)&unk_75C94, (int)&s2) )
    *(_DWORD *)(a1 + 132) = (unsigned __int8)G_SoundAliasIndex(s2);
  v1 = G_SpawnFloat("light", (int)&unk_75C94, (int)&v29);
  v2 = G_SpawnVector("color", (int)"1 1 1", (int)v35);
  if ( v1 || v2 )
  {
    v33 = v34 | 0xC00;
    v32 = (int)(*(float *)v35 * 255.0);
    v3 = v32;
    if ( v32 > 255 )
      v3 = 255;
    v33 = v34 | 0xC00;
    v32 = (int)(*(float *)&v35[1] * 255.0);
    v4 = v32;
    if ( v32 > 255 )
      v4 = 255;
    v33 = v34 | 0xC00;
    v32 = (int)(255.0 * *(float *)&v35[2]);
    v5 = v32;
    if ( v32 > 255 )
      v5 = 255;
    v33 = v34 | 0xC00;
    v32 = (int)(*(float *)&v29 * 0.25);
    v6 = v32;
    if ( v32 > 255 )
      v6 = 255;
    *(_DWORD *)(a1 + 128) = (v6 << 24) | (v5 << 16) | (v4 << 8) | v3;
  }
  if ( *(_WORD *)(a1 + 374) == scr_const[28] )
  {
    *(_DWORD *)(a1 + 528) = Use_Func_Rotate;
    *(_DWORD *)(a1 + 516) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 528) = Use_BinaryMover;
    *(_DWORD *)(a1 + 516) = Reached_BinaryMover;
  }
  *(float *)(a1 + 308) = *(float *)(a1 + 420);
  *(float *)(a1 + 312) = *(float *)(a1 + 424);
  *(float *)(a1 + 316) = *(float *)(a1 + 428);
  *(_BYTE *)(a1 + 372) = 0;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  trap_LinkEntity(a1);
  v7 = *(float *)(a1 + 420);
  *(float *)(a1 + 24) = *(float *)(a1 + 420);
  v8 = *(float *)(a1 + 424);
  *(float *)(a1 + 28) = *(float *)(a1 + 424);
  v9 = *(float *)(a1 + 432) - v7;
  v10 = *(float *)(a1 + 428);
  *(float *)(a1 + 32) = *(float *)(a1 + 428);
  v11 = v10;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)&v35[3] = v9;
  v12 = *(float *)(a1 + 436) - v8;
  *(float *)&v35[4] = v12;
  v13 = *(float *)(a1 + 440) - v11;
  *(float *)&v35[5] = v13;
  v31 = sqrt(v13 * v13 + v12 * v12 + v9 * v9);
  v14 = v31;
  v16 = *(float *)(a1 + 480);
  v17 = v16 < 0.0;
  v18 = 0;
  v19 = v16 == 0.0;
  if ( (v15 & 0x44) == 0x40 )
    *(float *)(a1 + 480) = 100.0;
  v20 = v14 * 1000.0;
  v21 = v14 * 1000.0 / *(float *)(a1 + 480);
  v33 = v34 | 0xC00;
  v32 = (int)v21;
  *(_DWORD *)(a1 + 20) = (int)v21;
  if ( (int)v21 <= 0 )
    *(_DWORD *)(a1 + 20) = 1;
  v22 = *(_DWORD *)(a1 + 20);
  v24 = *(float *)(a1 + 484);
  *(_DWORD *)(a1 + 500) = v22;
  *(_DWORD *)(a1 + 504) = v22;
  v25 = v24 < 0.0;
  v26 = 0;
  v27 = v24 == 0.0;
  LOBYTE(result) = v23;
  HIBYTE(result) = HIBYTE(v23) & 0x45;
  if ( (HIBYTE(v23) & 0x45) != 64 )
  {
    v33 = v34 | 0xC00;
    v32 = (int)(v20 / v24);
    result = v32;
    *(_DWORD *)(a1 + 504) = v32;
    if ( (int)(v20 / v24) <= 0 )
      *(_DWORD *)(a1 + 504) = 1;
  }
  return result;
}
// 56696: variable 'v15' is possibly undefined

//----- (0005674C) --------------------------------------------------------
int __cdecl InitMoverRotate(int a1)
{
  int v1; // ebx
  int v2; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // ecx
  int v6; // eax
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  int result; // eax
  int v14; // [esp+20h] [ebp-18h] BYREF
  int v15; // [esp+24h] [ebp-14h]
  __int16 v16; // [esp+28h] [ebp-10h]
  __int16 v17; // [esp+2Ah] [ebp-Eh]
  int v18[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v1 = G_SpawnFloat("light", (int)&unk_75C94, (int)&v14);
  v2 = G_SpawnVector("color", (int)"1 1 1", (int)v18);
  if ( v1 || v2 )
  {
    v16 = v17 | 0xC00;
    v15 = (int)(*(float *)v18 * 255.0);
    v3 = v15;
    if ( v15 > 255 )
      v3 = 255;
    v16 = v17 | 0xC00;
    v15 = (int)(*(float *)&v18[1] * 255.0);
    v4 = v15;
    if ( v15 > 255 )
      v4 = 255;
    v16 = v17 | 0xC00;
    v15 = (int)(255.0 * *(float *)&v18[2]);
    v5 = v15;
    if ( v15 > 255 )
      v5 = 255;
    v16 = v17 | 0xC00;
    v15 = (int)(*(float *)&v14 * 0.25);
    v6 = v15;
    if ( v15 > 255 )
      v6 = 255;
    *(_DWORD *)(a1 + 128) = (v6 << 24) | (v5 << 16) | (v4 << 8) | v3;
  }
  *(_DWORD *)(a1 + 528) = Use_BinaryMover;
  if ( (*(_BYTE *)(a1 + 376) & 0x40) == 0 )
    *(_DWORD *)(a1 + 516) = Reached_BinaryMover;
  *(_BYTE *)(a1 + 372) = 7;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  trap_LinkEntity(a1);
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  v8 = *(float *)(a1 + 480);
  *(_DWORD *)(a1 + 12) = 0;
  v9 = v8 < 0.0;
  v10 = 0;
  v11 = v8 == 0.0;
  if ( (v7 & 0x44) == 0x40 )
    *(float *)(a1 + 480) = 100.0;
  v12 = *(float *)(a1 + 480);
  v16 = v17 | 0xC00;
  v15 = (int)v12;
  *(_DWORD *)(a1 + 56) = (int)v12;
  if ( (int)v12 <= 0 )
    *(_DWORD *)(a1 + 56) = 1;
  result = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 504) = result;
  *(_DWORD *)(a1 + 500) = result;
  return result;
}
// 568D5: variable 'v7' is possibly undefined

//----- (00056934) --------------------------------------------------------
void __cdecl Blocked_DoorRotate(int a1, void *s)
{
  int v2; // eax
  int i; // ebx
  int v4; // edx

  if ( s )
  {
    if ( !*((_DWORD *)s + 86) )
    {
      G_TempEntity((float *)s + 77, 198);
      G_FreeEntity(s);
      return;
    }
    if ( *((int *)s + 140) <= 0 )
      G_Damage((int *)s, (int *)a1, (int *)a1, 0, 0, 99999, 0, 0x13u, 0);
    v2 = *(_DWORD *)(a1 + 568);
    if ( v2 )
      G_Damage((int *)s, (int *)a1, (int *)a1, 0, 0, v2, 0, 0x13u, 0);
  }
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    v4 = *(_DWORD *)(i + 56) - (level[122] - *(_DWORD *)(i + 52));
    if ( *(_BYTE *)(i + 372) == 9 )
      SetMoverState(i, 10, level[122] - v4);
    else
      SetMoverState(i, 9, level[122] - v4);
    trap_LinkEntity(i);
  }
}

//----- (00056A14) --------------------------------------------------------
int __cdecl sub_56A14(int a1)
{
  int i; // ebx
  int j; // ebx
  int v3; // edi
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // ebx
  int v8; // esi
  int k; // edi
  int v11; // [esp+28h] [ebp-20h]
  float v12; // [esp+30h] [ebp-18h] BYREF
  float v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+38h] [ebp-10h]
  float v15; // [esp+3Ch] [ebp-Ch] BYREF
  float v16; // [esp+40h] [ebp-8h]
  float v17; // [esp+44h] [ebp-4h]

  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
    *(_BYTE *)(i + 369) = 1;
  v15 = *(float *)(a1 + 284);
  v16 = *(float *)(a1 + 288);
  v17 = *(float *)(a1 + 292);
  v12 = *(float *)(a1 + 296);
  v13 = *(float *)(a1 + 300);
  v14 = *(float *)(a1 + 304);
  for ( j = *(_DWORD *)(a1 + 608); j; j = *(_DWORD *)(j + 608) )
  {
    AddPointToBounds((float *)(j + 284), &v15, &v12);
    AddPointToBounds((float *)(j + 296), &v15, &v12);
  }
  v3 = 0;
  v4 = 1;
  v5 = 4;
  do
  {
    if ( *(&v12 + v3) - *(&v15 + v3) > *(float *)((char *)&v12 + v5) - *(float *)((char *)&v15 + v5) )
      v3 = v4;
    v5 += 4;
    ++v4;
  }
  while ( v4 <= 2 );
  v6 = 4 * v3;
  *(float *)((char *)&v12 + v6) = *(&v12 + v3) + 120.0;
  *(float *)((char *)&v15 + v6) = *(&v15 + v3) - 120.0;
  v7 = G_Spawn();
  *(float *)(v7 + 256) = v15;
  *(float *)(v7 + 260) = v16;
  *(float *)(v7 + 264) = v17;
  *(float *)(v7 + 268) = v12;
  *(float *)(v7 + 272) = v13;
  *(float *)(v7 + 276) = v14;
  *(_DWORD *)(v7 + 408) = a1;
  *(_DWORD *)(v7 + 280) = 0x40000000;
  *(_DWORD *)(v7 + 524) = Touch_DoorTrigger;
  trap_LinkEntity(v7);
  v8 = a1;
  v11 = *(unsigned __int8 *)(a1 + 372);
  for ( k = level[122]; v8; v8 = *(_DWORD *)(v8 + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(v8 + 381) |= 1u;
    SetMoverState(v8, v11, k);
  }
  return v7;
}

//----- (00056BD4) --------------------------------------------------------
int __cdecl SP_func_door(int a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  long double v7; // fst6
  bool v8; // c0
  char v9; // c2
  bool v10; // c3
  long double v11; // fst7
  long double v12; // fst6
  long double v13; // fst5
  long double v14; // fst4
  long double v15; // fst3
  long double v16; // fst2
  long double v17; // rt1
  long double v18; // fst2
  long double v19; // fst1
  long double v20; // fst5
  long double v21; // fst7
  long double v22; // rt1
  long double v23; // fst4
  long double v24; // fst3
  long double v25; // fst5
  long double v26; // fst6
  long double v27; // fst7
  long double v28; // fst4
  long double v29; // rt0
  long double v30; // fst5
  long double v31; // rt1
  long double v32; // fst5
  long double v33; // fst7
  long double v34; // rt2
  long double v35; // fst5
  long double v36; // fst6
  char v37; // fps^1
  long double v38; // fst6
  bool v39; // c0
  char v40; // c2
  bool v41; // c3
  long double v42; // fst7
  char v43; // dl
  char v44; // dl
  char v45; // dl
  char v46; // dl
  char v47; // dl
  int result; // eax
  float v49; // [esp+14h] [ebp-44h]
  int v50; // [esp+18h] [ebp-40h] BYREF
  int v51; // [esp+1Ch] [ebp-3Ch] BYREF
  int v52[14]; // [esp+20h] [ebp-38h] BYREF

  *(_BYTE *)(a1 + 355) = G_SoundAliasIndex("door_opening");
  *(_BYTE *)(a1 + 357) = G_SoundAliasIndex("door_open_end");
  *(_BYTE *)(a1 + 356) = G_SoundAliasIndex("door_closing");
  *(_BYTE *)(a1 + 354) = G_SoundAliasIndex("door_close_end");
  *(_BYTE *)(a1 + 359) = G_SoundAliasIndex("door_open_loop");
  *(_BYTE *)(a1 + 360) = G_SoundAliasIndex("door_close_loop");
  *(_BYTE *)(a1 + 361) = G_SoundAliasIndex("door_locked");
  *(_BYTE *)(a1 + 362) = G_SoundAliasIndex("door_opening_quiet");
  *(_BYTE *)(a1 + 363) = G_SoundAliasIndex("door_open_quiet_end");
  *(_BYTE *)(a1 + 364) = G_SoundAliasIndex("door_closing_quiet");
  *(_BYTE *)(a1 + 365) = G_SoundAliasIndex("door_close_quiet_end");
  *(_DWORD *)(a1 + 520) = Blocked_Door;
  v2 = *(float *)(a1 + 480);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) == 0x40 )
    *(float *)(a1 + 480) = 400.0;
  v7 = *(float *)(a1 + 616);
  v8 = v7 < 0.0;
  v9 = 0;
  v10 = v7 == 0.0;
  if ( (v6 & 0x44) == 0x40 )
    *(float *)(a1 + 616) = 2.0;
  *(float *)(a1 + 616) = *(float *)(a1 + 616) * 1000.0;
  if ( G_SpawnInt("key", (int)&unk_75BF3, (int)v52) )
    *(_DWORD *)(a1 + 680) = 1;
  else
    *(_DWORD *)(a1 + 680) = 0;
  G_SpawnFloat("lip", (int)"8", (int)&v51);
  G_SpawnInt("dmg", (int)"2", a1 + 568);
  *(float *)(a1 + 420) = *(float *)(a1 + 308);
  *(float *)(a1 + 424) = *(float *)(a1 + 312);
  *(float *)(a1 + 428) = *(float *)(a1 + 316);
  trap_SetBrushModel(a1);
  G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  v49 = *(float *)(a1 + 488);
  v11 = fabs(v49);
  *(float *)&v52[11] = v11;
  v12 = *(float *)(a1 + 492);
  v13 = fabs(v12);
  *(float *)&v52[12] = v13;
  v14 = *(float *)(a1 + 496);
  v15 = fabs(v14);
  *(float *)&v52[13] = v15;
  v16 = *(float *)(a1 + 268) - *(float *)(a1 + 256);
  *(float *)&v52[8] = v16;
  v17 = v16 * v11;
  v18 = *(float *)(a1 + 272) - *(float *)(a1 + 260);
  *(float *)&v52[9] = v18;
  v19 = v13;
  v20 = *(float *)(a1 + 276) - *(float *)(a1 + 264);
  v21 = v15 * v20 + v18 * v19 + v17;
  v22 = v14;
  v23 = v21 - *(float *)&v51;
  v24 = v20;
  v25 = v49 * v23;
  *(float *)&v52[10] = v24;
  v26 = v12 * v23;
  v27 = v22 * v23;
  v28 = *(float *)(a1 + 428);
  v29 = v25 + *(float *)(a1 + 420);
  v30 = v26 + *(float *)(a1 + 424);
  *(float *)(a1 + 436) = v30;
  v31 = v30;
  v32 = v27 + v28;
  v33 = v31;
  *(float *)(a1 + 440) = v32;
  v34 = v32;
  v35 = v29;
  v36 = v34;
  *(float *)(a1 + 432) = v29;
  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
  {
    *(float *)&v52[1] = v35;
    *(float *)&v52[2] = v33;
    *(float *)&v52[3] = v36;
    *(float *)(a1 + 432) = *(float *)(a1 + 308);
    *(float *)(a1 + 436) = *(float *)(a1 + 312);
    *(float *)(a1 + 440) = *(float *)(a1 + 316);
    *(float *)(a1 + 420) = v35;
    *(float *)(a1 + 424) = v33;
    *(float *)(a1 + 428) = v36;
    v38 = *(float *)(a1 + 484);
    v39 = v38 < 0.0;
    v40 = 0;
    v41 = v38 == 0.0;
    if ( (v37 & 0x45) != 64 )
    {
      v42 = *(float *)(a1 + 480);
      *(float *)(a1 + 480) = *(float *)(a1 + 484);
      *(float *)(a1 + 484) = v42;
    }
    v43 = *(_BYTE *)(a1 + 355);
    *(_BYTE *)(a1 + 355) = *(_BYTE *)(a1 + 356);
    *(_BYTE *)(a1 + 356) = v43;
    v44 = *(_BYTE *)(a1 + 354);
    *(_BYTE *)(a1 + 354) = *(_BYTE *)(a1 + 357);
    *(_BYTE *)(a1 + 357) = v44;
    v45 = *(_BYTE *)(a1 + 359);
    *(_BYTE *)(a1 + 359) = *(_BYTE *)(a1 + 360);
    *(_BYTE *)(a1 + 360) = v45;
    v46 = *(_BYTE *)(a1 + 362);
    *(_BYTE *)(a1 + 362) = *(_BYTE *)(a1 + 364);
    *(_BYTE *)(a1 + 364) = v46;
    v47 = *(_BYTE *)(a1 + 363);
    *(_BYTE *)(a1 + 363) = *(_BYTE *)(a1 + 365);
    *(_BYTE *)(a1 + 365) = v47;
  }
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 380) |= 0x80u;
  InitMover(a1);
  if ( (*(_BYTE *)(a1 + 380) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v50);
    if ( v50 )
      *(_BYTE *)(a1 + 369) = 1;
  }
  result = level[122] + 100;
  *(_DWORD *)(a1 + 508) = result;
  *(_DWORD *)(a1 + 512) = finishSpawningKeyedMover;
  return result;
}
// 56CD7: variable 'v1' is possibly undefined
// 56CF5: variable 'v6' is possibly undefined
// 56ECF: variable 'v37' is possibly undefined

//----- (00056FE0) --------------------------------------------------------
int __cdecl SP_func_pendulum(int a1)
{
  long double v1; // fst7
  int v2; // ebx
  int result; // eax
  int v4; // [esp+18h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-1Ch] BYREF
  int v6; // [esp+20h] [ebp-18h]
  __int16 v7; // [esp+24h] [ebp-14h]
  __int16 v8; // [esp+26h] [ebp-12h]
  float v9; // [esp+34h] [ebp-4h]

  G_SpawnFloat("speed", (int)"30", (int)&v5);
  G_SpawnInt("dmg", (int)"2", a1 + 568);
  G_SpawnFloat("phase", (int)"0", (int)&v4);
  trap_SetBrushModel(a1);
  v1 = fabs(*(float *)(a1 + 264));
  if ( v1 < 8.0 )
    v1 = 8.0;
  v9 = sqrt(g_gravity[2] / (v1 * 3.0));
  v9 = v9 * 0.1591549430918953;
  v7 = v8 | 0xC00;
  v6 = (int)(1000.0 / v9);
  v2 = v6;
  *(_DWORD *)(a1 + 20) = v6;
  InitMover(a1);
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  *(float *)(a1 + 60) = *(float *)(a1 + 320);
  *(float *)(a1 + 64) = *(float *)(a1 + 324);
  *(float *)(a1 + 68) = *(float *)(a1 + 328);
  *(_DWORD *)(a1 + 56) = v2;
  result = (int)((long double)v2 * *(float *)&v4);
  *(_DWORD *)(a1 + 52) = result;
  *(_DWORD *)(a1 + 48) = 4;
  *(float *)(a1 + 80) = *(float *)&v5;
  return result;
}

//----- (00057124) --------------------------------------------------------
int __cdecl SP_func_door_rotating(int a1)
{
  int v1; // eax
  char v2; // al
  long double v3; // fst7
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  char v8; // fps^1
  long double v9; // fst6
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  int v13; // edx
  char v14; // fps^1
  long double v15; // fst6
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  int result; // eax
  int v20; // [esp+10h] [ebp-18h] BYREF
  int v21[4]; // [esp+14h] [ebp-14h] BYREF
  float v22; // [esp+24h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 376);
  if ( (v1 & 1) != 0 )
  {
    LOBYTE(v1) = v1 | 2;
    *(_DWORD *)(a1 + 376) = v1;
  }
  *(_BYTE *)(a1 + 376) &= 0xBFu;
  *(_BYTE *)(a1 + 355) = G_SoundAliasIndex("door_opening");
  *(_BYTE *)(a1 + 357) = G_SoundAliasIndex("door_open_end");
  *(_BYTE *)(a1 + 356) = G_SoundAliasIndex("door_closing");
  *(_BYTE *)(a1 + 354) = G_SoundAliasIndex("door_close_end");
  *(_BYTE *)(a1 + 359) = G_SoundAliasIndex("door_open_loop");
  *(_BYTE *)(a1 + 360) = G_SoundAliasIndex("door_close_loop");
  *(_BYTE *)(a1 + 361) = G_SoundAliasIndex("door_locked");
  *(_BYTE *)(a1 + 362) = G_SoundAliasIndex("door_opening_quiet");
  *(_BYTE *)(a1 + 363) = G_SoundAliasIndex("door_open_quiet_end");
  *(_BYTE *)(a1 + 364) = G_SoundAliasIndex("door_closing_quiet");
  v2 = G_SoundAliasIndex("door_close_quiet_end");
  v3 = *(float *)(a1 + 480);
  *(_BYTE *)(a1 + 365) = v2;
  v5 = v3 > 0.0;
  v6 = 0;
  v7 = 0.0 == v3;
  if ( (v4 & 0x44) == 0x40 )
    *(float *)(a1 + 480) = 1000.0;
  v9 = *(float *)(a1 + 464);
  v10 = v9 < 0.0;
  v11 = 0;
  v12 = v9 == 0.0;
  if ( (v8 & 0x44) == 0x40 )
    *(float *)(a1 + 464) = 90.0;
  if ( (*(_BYTE *)(a1 + 376) & 0x10) != 0 )
    *(float *)(a1 + 464) = -*(float *)(a1 + 464);
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 380) |= 0x80u;
  if ( G_SpawnInt("key", (int)&unk_75BF3, (int)v21) )
    *(_DWORD *)(a1 + 680) = 1;
  else
    *(_DWORD *)(a1 + 680) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  *(_DWORD *)(a1 + 644) = 0;
  *(_DWORD *)(a1 + 640) = 0;
  v13 = *(_DWORD *)(a1 + 376);
  if ( (v13 & 0xC) == 12 )
    goto LABEL_19;
  if ( (v13 & 4) != 0 )
  {
    *(_DWORD *)(a1 + 648) = 1065353216;
    goto LABEL_20;
  }
  if ( (v13 & 8) == 0 )
LABEL_19:
    *(_DWORD *)(a1 + 644) = 1065353216;
  else
    *(_DWORD *)(a1 + 640) = 1065353216;
LABEL_20:
  v22 = sqrt(
          *(float *)(a1 + 640) * *(float *)(a1 + 640)
        + *(float *)(a1 + 644) * *(float *)(a1 + 644)
        + *(float *)(a1 + 648) * *(float *)(a1 + 648));
  if ( v22 > 1.0 )
  {
    G_Error("Too many axis marked in func_door_rotating entity.  Only choose one axis of rotation. (defaulting to standar"
            "d door rotation)");
    *(_DWORD *)(a1 + 648) = 0;
    *(_DWORD *)(a1 + 640) = 0;
    *(_DWORD *)(a1 + 644) = 1065353216;
  }
  v15 = *(float *)(a1 + 616);
  v16 = v15 < 0.0;
  v17 = 0;
  v18 = v15 == 0.0;
  if ( (v14 & 0x44) == 0x40 )
    *(float *)(a1 + 616) = 2.0;
  *(float *)(a1 + 616) = *(float *)(a1 + 616) * 1000.0;
  trap_SetBrushModel(a1);
  InitMoverRotate(a1);
  if ( (*(_BYTE *)(a1 + 380) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v20);
    if ( v20 )
      *(_BYTE *)(a1 + 369) = 1;
  }
  result = level[122] + 100;
  *(_DWORD *)(a1 + 508) = result;
  *(_DWORD *)(a1 + 512) = finishSpawningKeyedMover;
  *(_DWORD *)(a1 + 520) = Blocked_DoorRotate;
  return result;
}
// 57236: variable 'v4' is possibly undefined
// 57256: variable 'v8' is possibly undefined
// 5739A: variable 'v14' is possibly undefined

//----- (0005742C) --------------------------------------------------------
int __cdecl trigger_use(int a1)
{
  long double v1; // fst7
  int result; // eax
  unsigned int i; // edi
  int j; // edi
  char *s1; // [esp+14h] [ebp-404h] BYREF
  char s2[1024]; // [esp+18h] [ebp-400h] BYREF

  trap_SetBrushModel(a1);
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 280) = &unk_200000;
  *(_DWORD *)(a1 + 244) = 1;
  *(_DWORD *)(a1 + 528) = use_trigger_use;
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  v1 = *(float *)(a1 + 628) * 1000.0;
  *(_DWORD *)(a1 + 220) = 2;
  *(float *)(a1 + 628) = v1;
  if ( G_SpawnString("cursorhint", (int)&unk_75BF3, (int)&s1) )
  {
    if ( Q_strcasecmp(s1, "HINT_INHERIT") )
    {
      for ( i = 1; i <= 0xA; ++i )
      {
        if ( !Q_strcasecmp(s1, (char *)*(&hintStrings + i)) )
        {
          *(_DWORD *)(a1 + 220) = i;
          break;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 220) = -1;
    }
  }
  *(_DWORD *)(a1 + 216) = 255;
  result = G_SpawnString("hintstring", (int)&unk_75BF3, (int)&s1);
  if ( result )
  {
    for ( j = 0; j <= 31; ++j )
    {
      trap_GetConfigstring(j + 1212, (int)s2, 1024);
      if ( !s2[0] )
      {
        trap_SetConfigstring(j + 1212, (int)s1);
        result = (unsigned __int8)j;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)j;
        break;
      }
      result = strcmp(s1, s2);
      if ( !result )
      {
        result = (unsigned __int8)j;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)j;
        break;
      }
    }
    if ( j == 32 )
      result = Com_Error(1, (char *)&byte_75EA0, 32);
  }
  return result;
}
// 7E4D4: using guessed type void *hintStrings;

//----- (0005760C) --------------------------------------------------------
void __cdecl G_RunMover(int a1)
{
  __int16 v1; // ax

  if ( *(_DWORD *)(a1 + 740) )
  {
    G_GeneralLink(a1);
LABEL_11:
    G_RunThink(a1);
    return;
  }
  if ( (*(_BYTE *)(a1 + 380) & 4) == 0 )
  {
    if ( *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 48) )
      G_MoverTeam((_DWORD *)a1);
    goto LABEL_11;
  }
  if ( *(_DWORD *)(a1 + 240) )
  {
    v1 = *(_WORD *)(a1 + 374);
    if ( v1 == scr_const[29] || v1 == scr_const[28] )
      trap_UnlinkEntity(a1);
  }
}

//----- (00057690) --------------------------------------------------------
void __cdecl G_Activate(int a1, float *a2)
{
  int v2; // eax

  if ( !*(_DWORD *)(a1 + 48) && !*(_DWORD *)(a1 + 12) && !*(_BYTE *)(a1 + 370) && !*(_DWORD *)(a1 + 680) )
  {
    v2 = *(_DWORD *)(a1 + 612);
    if ( v2 && *(_WORD *)(a1 + 472) && a1 != v2 )
    {
      *(_BYTE *)(v2 + 370) = 1;
      Use_BinaryMover(*(_DWORD *)(a1 + 612), (int)a2, a2);
    }
    else
    {
      *(_BYTE *)(a1 + 370) = 1;
      Use_BinaryMover(a1, (int)a2, a2);
    }
  }
}

//----- (00057718) --------------------------------------------------------
void __cdecl G_TryDoor(int a1, int a2, int *a3)
{
  int v3; // edi
  int v4; // eax

  v3 = *(_DWORD *)(a1 + 380) & 0x100;
  if ( !*(_DWORD *)(a1 + 48) && !*(_DWORD *)(a1 + 12) && !*(_BYTE *)(a1 + 370) )
  {
    if ( *(_DWORD *)(a1 + 680) )
    {
      G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 361));
    }
    else
    {
      Scr_AddEntity(a3);
      Scr_Notify((int *)a1, scr_const[73], 1);
      v4 = *(_DWORD *)(a1 + 612);
      if ( v4 && *(_WORD *)(a1 + 472) && a1 != v4 )
      {
        *(_BYTE *)(v4 + 370) = 1;
        if ( v3 )
          *(_BYTE *)(*(_DWORD *)(a1 + 612) + 381) |= 1u;
        Use_BinaryMover(*(_DWORD *)(a1 + 612), (int)a3, (float *)a3);
      }
      else
      {
        *(_BYTE *)(a1 + 370) = 1;
        if ( v3 )
          *(_BYTE *)(a1 + 381) |= 1u;
        Use_BinaryMover(a1, (int)a3, (float *)a3);
      }
    }
  }
}

//----- (000577FC) --------------------------------------------------------
void __cdecl MatchTeam(int a1, int a2, int a3)
{
  int i; // ebx

  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, a2, a3);
  }
}

//----- (00057848) --------------------------------------------------------
int __cdecl Use_Func_Rotate(int a1)
{
  int v1; // edx

  v1 = *(_DWORD *)(a1 + 376);
  if ( (v1 & 4) != 0 )
  {
    *(float *)(a1 + 80) = *(float *)(a1 + 480);
  }
  else if ( (v1 & 8) != 0 )
  {
    *(float *)(a1 + 72) = *(float *)(a1 + 480);
  }
  else
  {
    *(float *)(a1 + 76) = *(float *)(a1 + 480);
  }
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 380) &= 0xFBu;
  return trap_LinkEntity(a1);
}

//----- (000578A0) --------------------------------------------------------
void __cdecl Blocked_Door(int a1, void *s)
{
  int v2; // eax
  int i; // ebx
  int v4; // edx

  if ( s )
  {
    if ( !*((_DWORD *)s + 86) )
    {
      G_TempEntity((float *)s + 77, 198);
      G_FreeEntity(s);
      return;
    }
    v2 = *(_DWORD *)(a1 + 568);
    if ( v2 )
      G_Damage((int *)s, (int *)a1, (int *)a1, 0, 0, v2, 0, 0x13u, 0);
  }
  if ( (*(_BYTE *)(a1 + 376) & 4) == 0 )
  {
    for ( i = a1; i; i = *(_DWORD *)(i + 608) )
    {
      v4 = *(_DWORD *)(i + 20) - (level[122] - *(_DWORD *)(i + 16));
      if ( *(_BYTE *)(i + 372) == 3 )
        SetMoverState(i, 4, level[122] - v4);
      else
        SetMoverState(i, 3, level[122] - v4);
      trap_LinkEntity(i);
    }
  }
}

//----- (00057964) --------------------------------------------------------
int *__cdecl G_TestEntityPosition(int a1, int a2)
{
  int *result; // eax
  char v3[40]; // [esp+8h] [ebp-30h] BYREF
  unsigned __int16 v4; // [esp+30h] [ebp-8h]
  char v5; // [esp+37h] [ebp-1h]

  if ( *(_DWORD *)(a1 + 400) && *(_DWORD *)(a1 + 280) == 0x4000000 || (trap_Trace((int)v3, a2, a1 + 256), !v5) )
    result = 0;
  else
    result = &g_entities[197 * v4];
  return result;
}

//----- (000579FC) --------------------------------------------------------
float *__cdecl G_CreateRotationMatrix(float *a1, float *a2)
{
  AngleVectors(a1, a2, a2 + 3, a2 + 6);
  return VectorInverse(a2 + 3);
}

//----- (00057A28) --------------------------------------------------------
float *__cdecl G_TransposeMatrix(int a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  float *v4; // edx
  float *result; // eax
  int i; // ecx

  v2 = 0;
  do
  {
    v3 = v2 + 1;
    v4 = (float *)(a2 + 12 * v2);
    result = (float *)(a1 + 4 * v2);
    for ( i = 2; i >= 0; --i )
    {
      *v4++ = *result;
      result += 3;
    }
    v2 = v3;
  }
  while ( v3 <= 2 );
  return result;
}

//----- (00057A64) --------------------------------------------------------
float *__cdecl G_RotatePoint(float *a1, float *a2)
{
  float *result; // eax
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst5

  result = a2;
  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  *a1 = *a2 * v3 + a2[1] * v4 + a2[2] * v5;
  a1[1] = a2[3] * v3 + a2[4] * v4 + a2[5] * v5;
  a1[2] = v4 * a2[7] + v3 * a2[6] + v5 * a2[8];
  return result;
}

//----- (00057AD0) --------------------------------------------------------
void __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3)
{
  int i; // ebx

  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    *(float *)(i + 464) = -*(float *)(i + 464);
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, a2, a3);
  }
}

//----- (00057B28) --------------------------------------------------------
int __cdecl ReturnToPos1(int a1)
{
  int v1; // edi
  int i; // ebx
  int result; // eax

  v1 = level[122];
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, 4, v1);
  }
  G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 356));
  result = *(unsigned __int8 *)(a1 + 360);
  *(_DWORD *)(a1 + 132) = result;
  return result;
}

//----- (00057B94) --------------------------------------------------------
int __cdecl ReturnToPos2(int a1)
{
  int v1; // edi
  int i; // ebx

  v1 = level[122];
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, 6, v1);
  }
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 358);
  return G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 360));
}

//----- (00057C04) --------------------------------------------------------
int __cdecl GotoPos3(int a1)
{
  int v1; // edi
  int i; // ebx

  v1 = level[122];
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, 5, v1);
  }
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 358);
  return G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 359));
}

//----- (00057C74) --------------------------------------------------------
int __cdecl ReturnToPos1Rotate(int a1)
{
  int v1; // edi
  int i; // ebx
  int *v3; // edx
  int result; // eax
  int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  v1 = level[122];
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(i + 381) |= 1u;
    SetMoverState(i, 10, v1);
  }
  v3 = G_Find(0, 374, scr_const[49]);
  if ( v3 )
    v5 = trap_InPVS((int)(v3 + 77), a1 + 308);
  if ( v5 )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 364));
    else
      G_PlaySoundAlias((_DWORD *)a1, *(unsigned __int8 *)(a1 + 356));
  }
  result = *(unsigned __int8 *)(a1 + 360);
  *(_DWORD *)(a1 + 132) = result;
  return result;
}

//----- (00057D48) --------------------------------------------------------
void __cdecl Touch_DoorTrigger(int a1, float *a2)
{
  int v2; // eax
  char v3; // al

  v2 = *(_DWORD *)(a1 + 408);
  if ( !*(_DWORD *)(v2 + 680) )
  {
    v3 = *(_BYTE *)(v2 + 372);
    if ( !v3 || v3 == 7 || v3 == 10 )
      Use_BinaryMover(*(_DWORD *)(a1 + 408), a1, a2);
  }
}

//----- (00057D8C) --------------------------------------------------------
int __cdecl Think_SpawnNewDoorTrigger(int a1)
{
  return sub_56A14(a1);
}

//----- (00057DA4) --------------------------------------------------------
void __cdecl Think_SpawnNewAutoDoorTrigger(int a1)
{
  long double v1; // fst7
  int v2; // eax

  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
  {
    v1 = *(float *)(a1 + 324) + *(float *)(a1 + 464);
    *(_DWORD *)(a1 + 512) = ReturnToPos1Rotate;
    *(float *)(a1 + 324) = v1;
    SetMoverState(a1, 8, level[122]);
    v2 = *(_DWORD *)(a1 + 612);
    if ( v2 == a1 || !v2 )
      trap_AdjustAreaPortalState(a1, 1);
  }
}

//----- (00057E08) --------------------------------------------------------
void __cdecl Think_MatchTeam(int a1)
{
  int v1; // ebx
  int i; // edi
  int v3; // [esp+14h] [ebp-4h]

  v1 = a1;
  v3 = *(unsigned __int8 *)(a1 + 372);
  for ( i = level[122]; v1; v1 = *(_DWORD *)(v1 + 608) )
  {
    if ( (*(_BYTE *)(a1 + 381) & 1) != 0 )
      *(_BYTE *)(v1 + 381) |= 1u;
    SetMoverState(v1, v3, i);
  }
}

//----- (00057E68) --------------------------------------------------------
int __cdecl finishSpawningKeyedMover(int a1)
{
  int result; // eax
  int i; // edx

  result = level[122] + 100;
  *(_DWORD *)(a1 + 508) = result;
  if ( (*(_BYTE *)(a1 + 380) & 4) != 0 )
    return result;
  if ( *(_BYTE *)(a1 + 369) )
    goto LABEL_7;
  result = (unsigned __int16)scr_const[27];
  if ( *(_WORD *)(a1 + 374) == (_WORD)result )
  {
    *(_DWORD *)(a1 + 512) = Think_SpawnNewAutoDoorTrigger;
    goto LABEL_8;
  }
  if ( (*(_BYTE *)(a1 + 376) & 8) == 0 )
LABEL_7:
    *(_DWORD *)(a1 + 512) = Think_MatchTeam;
  else
    *(_DWORD *)(a1 + 512) = Think_SpawnNewDoorTrigger;
LABEL_8:
  for ( i = a1; i; i = *(_DWORD *)(i + 608) )
  {
    if ( i != a1 )
    {
      result = *(_DWORD *)(a1 + 680);
      *(_DWORD *)(i + 680) = result;
    }
  }
  return result;
}

//----- (00057EF4) --------------------------------------------------------
_BYTE *__cdecl Door_reverse_sounds(_BYTE *a1)
{
  _BYTE *result; // eax
  char v2; // cl
  char v3; // cl
  char v4; // cl
  char v5; // cl
  char v6; // cl

  result = a1;
  v2 = a1[355];
  a1[355] = a1[356];
  a1[356] = v2;
  v3 = a1[354];
  a1[354] = a1[357];
  a1[357] = v3;
  v4 = a1[359];
  a1[359] = a1[360];
  a1[360] = v4;
  v5 = a1[362];
  a1[362] = a1[364];
  a1[364] = v5;
  v6 = a1[363];
  a1[363] = a1[365];
  a1[365] = v6;
  return result;
}

//----- (00057F7C) --------------------------------------------------------
int __cdecl DoorSetSounds(_BYTE *a1)
{
  int result; // eax

  a1[355] = G_SoundAliasIndex("door_opening");
  a1[357] = G_SoundAliasIndex("door_open_end");
  a1[356] = G_SoundAliasIndex("door_closing");
  a1[354] = G_SoundAliasIndex("door_close_end");
  a1[359] = G_SoundAliasIndex("door_open_loop");
  a1[360] = G_SoundAliasIndex("door_close_loop");
  a1[361] = G_SoundAliasIndex("door_locked");
  a1[362] = G_SoundAliasIndex("door_opening_quiet");
  a1[363] = G_SoundAliasIndex("door_open_quiet_end");
  a1[364] = G_SoundAliasIndex("door_closing_quiet");
  result = G_SoundAliasIndex("door_close_quiet_end");
  a1[365] = result;
  return result;
}

//----- (00058070) --------------------------------------------------------
int __cdecl Use_Static(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 240) )
    result = trap_UnlinkEntity(a1);
  else
    result = trap_LinkEntity(a1);
  return result;
}

//----- (000580A0) --------------------------------------------------------
__int16 __cdecl Static_Pain(int a1)
{
  __int16 v1; // fps
  long double v2; // fst7
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  int v6; // eax
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst5
  long double v10; // fst7
  __int16 v11; // fps
  long double v12; // fst7
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  float v17; // [esp+10h] [ebp-18h]
  float v18; // [esp+14h] [ebp-14h]

  if ( (*(_BYTE *)(a1 + 376) & 4) != 0 )
  {
    v18 = (float)level[122];
    v2 = *(float *)(a1 + 616) + *(float *)(a1 + 628) + (long double)(rand() % 1000) + 500.0;
    v3 = v2 < v18;
    v4 = 0;
    v5 = v2 == v18;
    LOBYTE(v6) = v1;
    BYTE1(v6) = HIBYTE(v1) & 0x45;
    if ( (HIBYTE(v1) & 0x45) == 1 )
    {
      v6 = level[122];
      v7 = *(float *)(a1 + 308);
      *(float *)(a1 + 616) = (float)v6;
      v8 = *(float *)(a1 + 312);
      v9 = v7;
      v10 = *(float *)(a1 + 316);
      *(float *)(a1 + 308) = v9;
      *(float *)(a1 + 312) = v8;
      *(float *)(a1 + 316) = v10;
    }
  }
  else
  {
    v17 = (float)level[122];
    v12 = *(float *)(a1 + 616) + *(float *)(a1 + 628) + (long double)(rand() % 1000) + 500.0;
    v13 = v12 < v17;
    v14 = 0;
    v15 = v12 == v17;
    LOBYTE(v6) = v11;
    BYTE1(v6) = HIBYTE(v11) & 0x45;
    if ( (HIBYTE(v11) & 0x45) == 1 )
    {
      v6 = level[122];
      *(float *)(a1 + 616) = (float)v6;
    }
  }
  return v6;
}

//----- (000581C4) --------------------------------------------------------
int __cdecl SP_func_leaky(int a1)
{
  int result; // eax

  trap_SetBrushModel(a1);
  result = trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  return result;
}

//----- (0005820C) --------------------------------------------------------
__int16 __cdecl SP_func_static(int a1)
{
  __int16 result; // ax
  __int16 v2; // fps
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  long double v7; // fst7
  int v8; // [esp+14h] [ebp-4h] BYREF

  trap_SetBrushModel(a1);
  result = InitMover(a1);
  *(_DWORD *)(a1 + 528) = Use_Static;
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
    result = trap_UnlinkEntity(a1);
  if ( (*(_BYTE *)(a1 + 380) & 4) == 0 )
  {
    result = G_SpawnInt("health", (int)"0", (int)&v8);
    if ( v8 )
      *(_BYTE *)(a1 + 369) = 1;
  }
  if ( (*(_BYTE *)(a1 + 376) & 6) != 0 )
  {
    v3 = *(float *)(a1 + 628);
    *(_DWORD *)(a1 + 532) = Static_Pain;
    v4 = v3 < 0.0;
    v5 = 0;
    v6 = v3 == 0.0;
    LOBYTE(result) = v2;
    HIBYTE(result) = HIBYTE(v2) & 0x44 ^ 0x40;
    if ( HIBYTE(result) )
      v7 = v3 * 1000.0;
    else
      v7 = 1000.0;
    *(float *)(a1 + 628) = v7;
    *(_BYTE *)(a1 + 369) = 1;
    *(_DWORD *)(a1 + 560) = 9999;
    if ( !*(_DWORD *)(a1 + 592) )
      *(_DWORD *)(a1 + 592) = 4;
  }
  return result;
}

//----- (000582FC) --------------------------------------------------------
int __cdecl SP_func_rotating(int a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  int v6; // eax

  v2 = *(float *)(a1 + 480);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) == 0x40 )
    *(float *)(a1 + 480) = 100.0;
  v6 = *(_DWORD *)(a1 + 376);
  *(_DWORD *)(a1 + 48) = 2;
  if ( (v6 & 1) != 0 )
  {
    if ( (v6 & 4) != 0 )
    {
      *(float *)(a1 + 80) = *(float *)(a1 + 480);
    }
    else if ( (v6 & 8) != 0 )
    {
      *(float *)(a1 + 72) = *(float *)(a1 + 480);
    }
    else
    {
      *(float *)(a1 + 76) = *(float *)(a1 + 480);
    }
  }
  if ( !*(_DWORD *)(a1 + 568) )
    *(_DWORD *)(a1 + 568) = 2;
  trap_SetBrushModel(a1);
  InitMover(a1);
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  if ( (*(_BYTE *)(a1 + 376) & 2) == 0 )
    return trap_LinkEntity(a1);
  *(_BYTE *)(a1 + 380) |= 4u;
  return trap_UnlinkEntity(a1);
}
// 58312: variable 'v1' is possibly undefined

//----- (000583D0) --------------------------------------------------------
int __cdecl SP_func_bobbing(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+18h] [ebp-10h] BYREF
  int v4; // [esp+1Ch] [ebp-Ch] BYREF
  int v5; // [esp+20h] [ebp-8h]
  __int16 v6; // [esp+24h] [ebp-4h]
  __int16 v7; // [esp+26h] [ebp-2h]

  G_SpawnFloat("speed", (int)&unk_75DA8, a1 + 480);
  G_SpawnFloat("height", (int)"32", (int)&v4);
  G_SpawnInt("dmg", (int)"2", a1 + 568);
  G_SpawnFloat("phase", (int)"0", (int)&v3);
  trap_SetBrushModel(a1);
  InitMover(a1);
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  v5 = (int)(*(float *)(a1 + 480) * 1000.0);
  v1 = v5;
  *(_DWORD *)(a1 + 20) = v5;
  v6 = v7 | 0xC00;
  v5 = (int)((long double)v1 * *(float *)&v3);
  *(_DWORD *)(a1 + 16) = v5;
  result = *(_DWORD *)(a1 + 376);
  *(_DWORD *)(a1 + 12) = 4;
  if ( (result & 1) != 0 )
  {
    *(float *)(a1 + 36) = *(float *)&v4;
  }
  else if ( (result & 2) != 0 )
  {
    *(float *)(a1 + 40) = *(float *)&v4;
  }
  else
  {
    *(float *)(a1 + 44) = *(float *)&v4;
  }
  return result;
}

//----- (000584F0) --------------------------------------------------------
char __cdecl use_trigger_use(int a1, int a2)
{
  char v2; // fps
  long double v3; // fst7
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7; // eax

  v3 = (long double)level[122];
  v4 = v3 < *(float *)(a1 + 616);
  v5 = 0;
  v6 = v3 == *(float *)(a1 + 616);
  LOBYTE(v7) = v2;
  if ( v3 > *(float *)(a1 + 616) )
  {
    *(float *)(a1 + 616) = v3 + *(float *)(a1 + 628);
    LOBYTE(v7) = a2;
    if ( !*(_DWORD *)(a2 + 344) )
    {
      v7 = *(_DWORD *)(a1 + 376);
      if ( (v7 & 1) != 0 )
        LOBYTE(v7) = v7 & 0xFE;
      else
        LOBYTE(v7) = v7 | 1;
      *(_DWORD *)(a1 + 376) = v7;
    }
  }
  return v7;
}

//----- (00058550) --------------------------------------------------------
int GScr_LoadConsts()
{
  int result; // eax

  scr_const[0] = Scr_AllocString((int)"active", 1);
  scr_const[1] = Scr_AllocString((int)"air strike", 1);
  scr_const[2] = Scr_AllocString((int)"allies", 1);
  scr_const[3] = Scr_AllocString((int)"animdone", 1);
  scr_const[4] = Scr_AllocString((int)"axis", 1);
  scr_const[5] = Scr_AllocString((int)"bodyque", 1);
  scr_const[6] = Scr_AllocString((int)"combat", 1);
  scr_const[7] = Scr_AllocString((int)"connected", 1);
  scr_const[8] = Scr_AllocString((int)"connecting", 1);
  scr_const[9] = Scr_AllocString((int)"count", 1);
  scr_const[11] = Scr_AllocString((int)"crouch", 1);
  scr_const[12] = Scr_AllocString((int)"crowbar", 1);
  scr_const[10] = Scr_AllocString((int)"current", 1);
  scr_const[13] = Scr_AllocString((int)"damage", 1);
  scr_const[14] = Scr_AllocString((int)"death", 1);
  scr_const[15] = Scr_AllocString((int)"disconnected", 1);
  scr_const[16] = Scr_AllocString((int)"dlight", 1);
  scr_const[17] = Scr_AllocString((int)"done", 1);
  scr_const[18] = Scr_AllocString((int)"empty", 1);
  scr_const[19] = Scr_AllocString((int)"enemy", 1);
  scr_const[20] = Scr_AllocString((int)"enemyhidden", 1);
  scr_const[21] = Scr_AllocString((int)"enemyvisible", 1);
  scr_const[22] = Scr_AllocString((int)"entity", 1);
  scr_const[23] = Scr_AllocString((int)"failed", 1);
  scr_const[24] = Scr_AllocString((int)"flamebarrel", 1);
  scr_const[25] = Scr_AllocString((int)"fraction", 1);
  scr_const[26] = Scr_AllocString((int)"func_door", 1);
  scr_const[27] = Scr_AllocString((int)"func_door_rotating", 1);
  scr_const[28] = Scr_AllocString((int)"func_rotating", 1);
  scr_const[29] = Scr_AllocString((int)"func_tramcar", 1);
  scr_const[30] = Scr_AllocString((int)"goal", 1);
  scr_const[31] = Scr_AllocString((int)"grenade", 1);
  scr_const[32] = Scr_AllocString((int)"info_notnull", 1);
  scr_const[33] = Scr_AllocString((int)"invisible", 1);
  scr_const[34] = Scr_AllocString((int)"key1", 1);
  scr_const[35] = Scr_AllocString((int)"key2", 1);
  scr_const[36] = Scr_AllocString((int)"killanimscript", 1);
  scr_const[37] = Scr_AllocString((int)"left", 1);
  scr_const[38] = Scr_AllocString((int)"misc_flak", 1);
  scr_const[39] = Scr_AllocString((int)"misc_mg42", 1);
  scr_const[40] = Scr_AllocString((int)"misc_tagemitter", 1);
  scr_const[41] = Scr_AllocString((int)"mortar", 1);
  scr_const[42] = Scr_AllocString((int)"movedone", 1);
  scr_const[43] = Scr_AllocString((int)"noclass", 1);
  scr_const[44] = Scr_AllocString((int)"noenemy", 1);
  scr_const[45] = Scr_AllocString((int)"noncombat", 1);
  scr_const[46] = Scr_AllocString((int)"normal", 1);
  scr_const[47] = Scr_AllocString((int)"pistol", 1);
  scr_const[48] = Scr_AllocString((int)"plane_waypoint", 1);
  scr_const[49] = Scr_AllocString((int)"player", 1);
  scr_const[50] = Scr_AllocString((int)"position", 1);
  scr_const[51] = Scr_AllocString((int)"primary", 1);
  scr_const[52] = Scr_AllocString((int)"primaryb", 1);
  scr_const[53] = Scr_AllocString((int)"prone", 1);
  scr_const[54] = Scr_AllocString((int)"right", 1);
  scr_const[55] = Scr_AllocString((int)"rocket", 1);
  scr_const[56] = Scr_AllocString((int)"rotatedone", 1);
  scr_const[57] = Scr_AllocString((int)"script_brushmodel", 1);
  scr_const[58] = Scr_AllocString((int)"script_model", 1);
  scr_const[59] = Scr_AllocString((int)"script_origin", 1);
  scr_const[60] = Scr_AllocString((int)"scriptcamera", 1);
  scr_const[61] = Scr_AllocString((int)"spawned", 1);
  scr_const[62] = Scr_AllocString((int)"spectator", 1);
  scr_const[63] = Scr_AllocString((int)"stand", 1);
  scr_const[64] = Scr_AllocString((int)"surfacetype", 1);
  scr_const[65] = Scr_AllocString((int)"tag_engine1", 1);
  scr_const[66] = Scr_AllocString((int)"tag_engine2", 1);
  scr_const[67] = Scr_AllocString((int)"target_location", 1);
  scr_const[68] = Scr_AllocString((int)"target_script_trigger", 1);
  scr_const[69] = Scr_AllocString((int)"tempEntity", 1);
  scr_const[70] = Scr_AllocString((int)"muzzleEntity", 1);
  scr_const[71] = Scr_AllocString((int)"smokegrenade", 1);
  scr_const[72] = Scr_AllocString((int)"touch", 1);
  scr_const[73] = Scr_AllocString((int)"trigger", 1);
  scr_const[74] = Scr_AllocString((int)"trigger_use", 1);
  scr_const[75] = Scr_AllocString((int)"trigger_damage", 1);
  scr_const[76] = Scr_AllocString((int)"trigger_lookat", 1);
  scr_const[77] = Scr_AllocString((int)"truck_cam", 1);
  scr_const[79] = Scr_AllocString((int)"xmodel/airborne", 1);
  scr_const[80] = Scr_AllocString((int)"xmodel/wehrmacht", 1);
  scr_const[78] = Scr_AllocString((int)"worldspawn", 1);
  scr_const[81] = Scr_AllocString((int)"begin", 1);
  scr_const[82] = Scr_AllocString((int)"dynamite", 1);
  scr_const[83] = Scr_AllocString((int)"explosive_indicator", 1);
  scr_const[84] = Scr_AllocString((int)"flamechunk", 1);
  scr_const[85] = Scr_AllocString((int)"follow", 1);
  scr_const[86] = Scr_AllocString((int)"free", 1);
  scr_const[87] = Scr_AllocString((int)"freed", 1);
  scr_const[88] = Scr_AllocString((int)"func_leaky", 1);
  scr_const[89] = Scr_AllocString((int)"info_player_checkpoint", 1);
  scr_const[90] = Scr_AllocString((int)"initialize", 1);
  scr_const[91] = Scr_AllocString((int)"intermission", 1);
  scr_const[92] = Scr_AllocString((int)"item_stamina_brandy", 1);
  scr_const[93] = Scr_AllocString((int)"menuresponse", 1);
  scr_const[94] = Scr_AllocString((int)"misc_gunner_gun", 1);
  scr_const[95] = Scr_AllocString((int)"misc_gunner_ring", 1);
  scr_const[96] = Scr_AllocString((int)"mp_info_player_deathmatch", 1);
  scr_const[97] = Scr_AllocString((int)"mp_info_player_intermission", 1);
  scr_const[98] = Scr_AllocString((int)"mp_team_alliedplayer_respawn", 1);
  scr_const[99] = Scr_AllocString((int)"mp_team_alliedplayer_start", 1);
  scr_const[100] = Scr_AllocString((int)"mp_team_axisplayer_respawn", 1);
  scr_const[101] = Scr_AllocString((int)"mp_team_axisplayer_start", 1);
  scr_const[102] = Scr_AllocString((int)"nail", 1);
  scr_const[103] = Scr_AllocString((int)"not", 1);
  scr_const[104] = Scr_AllocString((int)"playing", 1);
  scr_const[105] = Scr_AllocString((int)"prox_mine", 1);
  scr_const[106] = Scr_AllocString((int)"reset", 1);
  scr_const[107] = Scr_AllocString((int)"script_mover", 1);
  scr_const[108] = Scr_AllocString((int)"script_multiplayer", 1);
  scr_const[109] = Scr_AllocString((int)"spear", 1);
  scr_const[110] = Scr_AllocString((int)"tag_hand", 1);
  scr_const[111] = Scr_AllocString((int)"tag_rider", 1);
  scr_const[112] = Scr_AllocString((int)"tag_ring", 1);
  scr_const[113] = Scr_AllocString((int)"team_CTF_blueflag", 1);
  scr_const[114] = Scr_AllocString((int)"team_CTF_redflag", 1);
  scr_const[115] = Scr_AllocString((int)"team_WOLF_checkpoint", 1);
  scr_const[116] = Scr_AllocString((int)"team_WOLF_objective", 1);
  scr_const[117] = Scr_AllocString((int)"trigger_aidoor", 1);
  scr_const[118] = Scr_AllocString((int)"trigger_flagonly", 1);
  scr_const[119] = Scr_AllocString((int)"trigger_multiple", 1);
  scr_const[120] = Scr_AllocString((int)"trigger_objective_info", 1);
  scr_const[121] = Scr_AllocString((int)"waiting_for_players", 1);
  scr_const[122] = Scr_AllocString((int)"WP", 1);
  scr_const[123] = Scr_AllocString((int)"zombiespit", 1);
  scr_const[124] = Scr_AllocString((int)"none", 1);
  scr_const[125] = Scr_AllocString((int)"dead", 1);
  scr_const[126] = Scr_AllocString((int)"auto_change", 1);
  result = Scr_AllocString((int)"manual_change", 1);
  scr_const[127] = result;
  return result;
}

//----- (00059158) --------------------------------------------------------
int GScr_LoadGameTypeScript()
{
  int v0; // esi
  int v1; // ebx
  int v2; // ebx
  int v3; // ebx
  int v4; // ebx
  int result; // eax
  int v6; // ebx
  char s[64]; // [esp+18h] [ebp-40h] BYREF

  Com_sprintf(s, 0x40u, "maps/mp/gametypes/%s", &g_gametype[16]);
  if ( !Scr_LoadScript((int)s) )
    G_Error("Could not find script '%s'", s);
  v0 = Scr_GetFunctionHandle((int)s, (int)"main");
  if ( !v0 )
    G_Error("Could not find label '%s' in script '%s'", "main", s);
  g_scr_data[2] = v0;
  if ( !Scr_LoadScript((int)"maps/mp/gametypes/_callbacksetup") )
    G_Error("Could not find script '%s'", "maps/mp/gametypes/_callbacksetup");
  v1 = Scr_GetFunctionHandle((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_StartGameType");
  if ( !v1 )
    G_Error(
      "Could not find label '%s' in script '%s'",
      "CodeCallback_StartGameType",
      "maps/mp/gametypes/_callbacksetup");
  g_scr_data[3] = v1;
  if ( !Scr_LoadScript((int)"maps/mp/gametypes/_callbacksetup") )
    G_Error("Could not find script '%s'", "maps/mp/gametypes/_callbacksetup");
  v2 = Scr_GetFunctionHandle((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerConnect");
  if ( !v2 )
    G_Error(
      "Could not find label '%s' in script '%s'",
      "CodeCallback_PlayerConnect",
      "maps/mp/gametypes/_callbacksetup");
  g_scr_data[4] = v2;
  if ( !Scr_LoadScript((int)"maps/mp/gametypes/_callbacksetup") )
    G_Error("Could not find script '%s'", "maps/mp/gametypes/_callbacksetup");
  v3 = Scr_GetFunctionHandle((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerDisconnect");
  if ( !v3 )
    G_Error(
      "Could not find label '%s' in script '%s'",
      "CodeCallback_PlayerDisconnect",
      "maps/mp/gametypes/_callbacksetup");
  g_scr_data[5] = v3;
  if ( !Scr_LoadScript((int)"maps/mp/gametypes/_callbacksetup") )
    G_Error("Could not find script '%s'", "maps/mp/gametypes/_callbacksetup");
  v4 = Scr_GetFunctionHandle((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerDamage");
  if ( !v4 )
    G_Error("Could not find label '%s' in script '%s'", "CodeCallback_PlayerDamage", "maps/mp/gametypes/_callbacksetup");
  g_scr_data[6] = v4;
  if ( !Scr_LoadScript((int)"maps/mp/gametypes/_callbacksetup") )
    G_Error("Could not find script '%s'", "maps/mp/gametypes/_callbacksetup");
  result = Scr_GetFunctionHandle((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerKilled");
  v6 = result;
  if ( !result )
    result = G_Error(
               "Could not find label '%s' in script '%s'",
               "CodeCallback_PlayerKilled",
               "maps/mp/gametypes/_callbacksetup");
  g_scr_data[7] = v6;
  return result;
}

//----- (000593C8) --------------------------------------------------------
int GScr_LoadScripts()
{
  int v0; // edx
  bool v1; // cf
  int v3; // [esp+14h] [ebp-9154h] BYREF
  char v4[16]; // [esp+18h] [ebp-9150h] BYREF
  char v5[256]; // [esp+28h] [ebp-9140h] BYREF
  char s[64]; // [esp+128h] [ebp-9040h] BYREF
  char v7[36864]; // [esp+168h] [ebp-9000h] BYREF

  v3 = 0;
  Scr_BeginLoadScripts();
  GScr_LoadGameTypeScript();
  trap_Cvar_Register((int)v4, (int)"mapname", (int)&unk_76629);
  Com_sprintf(s, 0x40u, "maps/mp/%s", v5);
  Scr_LoadScript((int)s);
  g_scr_data[0] = Scr_GetFunctionHandle((int)s, (int)"main");
  v0 = 0;
  do
  {
    g_scr_data[2 * v0 + 106] = (int)off_7E500[v0];
    v1 = v0++ == -1;
  }
  while ( v1 || v0 == 1 );
  Scr_SetClassMap((int)&g_scr_data[105], 2);
  GScr_AddFieldsForEntity();
  GScr_AddFieldsForHudElems();
  GScr_AddFieldsForRadiant();
  Scr_EndLoadScripts();
  BG_FindAnims();
  BG_AnimParseAnimScript((char *)bgs, (int)v7, (int)&v3);
  Scr_PrecacheAnimTrees((int)sub_5CC20);
  BG_FindAnimTrees();
  Scr_EndLoadAnimTrees();
  BG_FinalizePlayerAnims();
  return BG_LoadAnimTreeInstances();
}
// 7E500: using guessed type char *off_7E500[3];
// C13C0: using guessed type int bgs[];

//----- (000594D0) --------------------------------------------------------
int __cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4)
{
  int result; // eax
  int v5; // eax
  const char *v6; // ebx
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v11; // esi
  char *v12; // eax
  char *v13; // eax
  int *v14; // ebx
  _BYTE *v15; // edi
  int v16; // eax
  int v17; // eax
  char *v18; // eax
  _DWORD *v19; // edi
  int v20; // eax
  int v21; // eax
  int v22; // esi
  char *v23; // eax
  char *v24; // eax
  char *v25; // eax
  int j; // esi
  char v27; // dl
  char *v28; // eax
  int i; // [esp+20h] [ebp-28h]
  int v30; // [esp+2Ch] [ebp-1Ch]
  const char *v31; // [esp+30h] [ebp-18h]
  int v32; // [esp+34h] [ebp-14h]
  int v33; // [esp+38h] [ebp-10h]
  int v34; // [esp+3Ch] [ebp-Ch]
  int v35; // [esp+40h] [ebp-8h]
  int v36; // [esp+44h] [ebp-4h]

  v32 = 1;
  switch ( a4 )
  {
    case 0:
      v31 = "Game Message";
      break;
    case 1:
      v31 = "Cvar Value";
      break;
    case 2:
      v31 = "Hint String";
      break;
    case 3:
      v31 = "Announcement String";
      break;
    case 4:
      v31 = "Client Cvar Value";
      break;
    case 5:
      v31 = "Client Chat Message";
      break;
    default:
      v31 = "BAD";
      break;
  }
  v34 = 0;
  *a2 = 0;
  result = Scr_GetNumParam();
  v35 = result;
  v36 = a1;
  if ( a1 < result )
  {
    do
    {
      v5 = Scr_GetType(v36);
      v33 = 0;
      if ( v5 != 2 )
      {
        if ( v5 != 7 || Scr_GetPointerType(v36) != 13 )
        {
          v30 = 0;
          v6 = (const char *)Scr_GetString(v36);
          v19 = v6;
          v20 = (unsigned __int8)v6 & 3;
          if ( ((unsigned __int8)v6 & 3) == 0 )
            goto LABEL_75;
          if ( __SETP__(v20, 0) )
            goto LABEL_73;
          if ( v20 == 2 )
            goto LABEL_71;
          if ( *v6 != BYTE1(v20) )
          {
            v19 = v6 + 1;
LABEL_71:
            if ( *(_BYTE *)v19 != BYTE1(v20) )
            {
              v19 = (_DWORD *)((char *)v19 + 1);
LABEL_73:
              if ( *(_BYTE *)v19 != BYTE1(v20) )
              {
                v19 = (_DWORD *)((char *)v19 + 1);
LABEL_75:
                while ( 1 )
                {
                  v21 = *v19;
                  if ( !(unsigned __int8)*v19 )
                    break;
                  if ( !BYTE1(v21) )
                    goto LABEL_81;
                  if ( (v21 & 0xFF0000) == 0 )
                    goto LABEL_80;
                  ++v19;
                  if ( (v21 & 0xFF000000) == 0 )
                  {
                    v19 = (_DWORD *)((char *)v19 - 3);
LABEL_80:
                    v19 = (_DWORD *)((char *)v19 + 1);
LABEL_81:
                    v19 = (_DWORD *)((char *)v19 + 1);
                    break;
                  }
                }
              }
            }
          }
          v10 = (char *)v19 - v6;
          v22 = 0;
          for ( i = v36 + 1; v22 < v10; ++v22 )
          {
            if ( (unsigned __int8)(v6[v22] - 20) <= 2u )
            {
              v23 = va("bad escape character (%i) present in string", v6[v22]);
              Scr_ParamError(v36, (int)v23);
            }
            if ( (*(_BYTE *)(_ctype_b + 2 * v6[v22] + 1) & 4) != 0 )
            {
              if ( !v30 && g_languagewarnings[3] )
              {
                if ( g_languagewarningsaserrors[3] )
                {
                  v24 = va("non-localized %s strings are not allowed to have letters in them: \"%s\"", v31, v6);
                  Com_Error(7, v24);
                }
                else
                {
                  Com_Printf(
                    "^3WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a l"
                    "ocalized string: \"%s\"\n",
                    v31,
                    v6);
                }
              }
              v30 = 1;
            }
          }
          if ( v30 )
          {
            if ( v34 )
LABEL_97:
              v33 = 1;
          }
          else if ( v32 )
          {
            goto LABEL_97;
          }
          if ( v33 + v10 + v34 >= a3 )
          {
            v25 = va("%s is too long. Max length is %i\n", v31, a3);
            Scr_ParamError(v36, (int)v25);
          }
          if ( v30 )
          {
            if ( v33 )
            {
              a2[v34] = 20;
              a2[v34 + 1] = 0;
              v34 += v33;
            }
          }
          else if ( v33 )
          {
            a2[v34] = 21;
            a2[v34 + 1] = 0;
            v34 += v33;
          }
          v32 = 0;
          goto LABEL_106;
        }
        v14 = Scr_GetEntity(v36);
        if ( !v14[86] )
          Scr_ParamError(v36, (int)"Entity is not a player");
        v6 = va("%s^7", (const char *)(v14[86] + 8628));
        v15 = v6;
        v16 = (unsigned __int8)v6 & 3;
        if ( ((unsigned __int8)v6 & 3) != 0 )
        {
          if ( __SETP__(v16, 0) )
          {
LABEL_50:
            if ( *v15 != BYTE1(v16) )
            {
              ++v15;
              goto LABEL_52;
            }
          }
          else
          {
            if ( v16 == 2 )
              goto LABEL_48;
            if ( *v6 != BYTE1(v16) )
            {
              v15 = v6 + 1;
LABEL_48:
              if ( *v15 != BYTE1(v16) )
              {
                ++v15;
                goto LABEL_50;
              }
            }
          }
        }
        else
        {
LABEL_52:
          while ( 1 )
          {
            v17 = *(_DWORD *)v15;
            if ( !(unsigned __int8)*(_DWORD *)v15 )
              break;
            if ( !BYTE1(v17) )
              goto LABEL_58;
            if ( (v17 & 0xFF0000) == 0 )
              goto LABEL_57;
            v15 += 4;
            if ( (v17 & 0xFF000000) == 0 )
            {
              v15 -= 3;
LABEL_57:
              ++v15;
LABEL_58:
              ++v15;
              break;
            }
          }
        }
        v10 = v15 - v6;
        if ( v32 )
          v33 = 1;
        if ( v33 + v10 + v34 >= a3 )
        {
          v18 = va("%s is too long. Max length is %i\n", v31, a3);
          Scr_ParamError(v36, (int)v18);
        }
        if ( v33 )
        {
          a2[v34] = 21;
          a2[v34 + 1] = 0;
          v34 += v33;
        }
        v32 = 0;
        i = v36 + 1;
        goto LABEL_106;
      }
      v6 = (const char *)Scr_GetIString(v36);
      v7 = v6;
      v8 = (unsigned __int8)v6 & 3;
      if ( ((unsigned __int8)v6 & 3) == 0 )
        goto LABEL_20;
      if ( __SETP__(v8, 0) )
        goto LABEL_18;
      if ( v8 != 2 )
      {
        if ( *v6 == BYTE1(v8) )
          goto LABEL_27;
        v7 = v6 + 1;
      }
      if ( *(_BYTE *)v7 != BYTE1(v8) )
      {
        v7 = (_DWORD *)((char *)v7 + 1);
LABEL_18:
        if ( *(_BYTE *)v7 != BYTE1(v8) )
        {
          v7 = (_DWORD *)((char *)v7 + 1);
LABEL_20:
          while ( 1 )
          {
            v9 = *v7;
            if ( !(unsigned __int8)*v7 )
              break;
            if ( !BYTE1(v9) )
              goto LABEL_26;
            if ( (v9 & 0xFF0000) == 0 )
              goto LABEL_25;
            ++v7;
            if ( (v9 & 0xFF000000) == 0 )
            {
              v7 = (_DWORD *)((char *)v7 - 3);
LABEL_25:
              v7 = (_DWORD *)((char *)v7 + 1);
LABEL_26:
              v7 = (_DWORD *)((char *)v7 + 1);
              break;
            }
          }
        }
      }
LABEL_27:
      v10 = (char *)v7 - v6;
      v11 = 0;
      for ( i = v36 + 1; v11 < v10; ++v11 )
      {
        if ( (*(_BYTE *)(_ctype_b + 2 * v6[v11]) & 8) == 0 && v6[v11] != 95 )
        {
          v12 = va(
                  "Illegal localized string reference: %s (must contain only alpha-numeric characters and underscores",
                  v6);
          Scr_ParamError(v36, (int)v12);
        }
      }
      if ( v34 )
        v33 = 1;
      if ( v33 + v10 + v34 >= a3 )
      {
        v13 = va("%s is too long. Max length is %i\n", v31, a3);
        Scr_ParamError(v36, (int)v13);
      }
      if ( v33 )
      {
        a2[v34] = 20;
        a2[v34 + 1] = 0;
        v34 += v33;
      }
      v32 = 1;
LABEL_106:
      for ( j = 0; j < v10; ++j )
      {
        v27 = v6[j];
        if ( (unsigned __int8)(v27 - 1) <= 0x1Eu || (unsigned __int8)v27 > 0x7Eu )
        {
          v28 = va("Illegal character '%c'(ascii %i) in %s: %s\n", v6[j], (unsigned __int8)v6[j], v6, v31);
          Scr_ParamError(v36, (int)v28);
        }
      }
      strcpy(&a2[v34], v6);
      result = i;
      v34 += v10;
      v36 = i;
    }
    while ( i < v35 );
  }
  if ( v32 )
  {
    result = (int)a2;
    a2[v34] = 21;
    a2[v34 + 1] = 0;
  }
  return result;
}
// 2ECD90: using guessed type int _ctype_b;

//----- (000599F8) --------------------------------------------------------
int sub_599F8()
{
  char *v0; // edi
  char *v1; // ebx
  int v2; // esi
  char v3; // al
  int v5; // [esp+14h] [ebp-804h]
  char s[1024]; // [esp+18h] [ebp-800h] BYREF
  char v7[1024]; // [esp+418h] [ebp-400h] BYREF

  v5 = Scr_GetString(0);
  if ( Scr_GetType(1) == 2 )
  {
    Scr_ConstructMessageString(1, v7, 1024, 1);
    v0 = v7;
  }
  else
  {
    v0 = (char *)Scr_GetString(1);
  }
  v1 = s;
  _bzero(s, 0x400u);
  v2 = 0;
  if ( *v0 )
  {
    do
    {
      v3 = Q_CleanCharacter(v0[v2]);
      *v1 = v3;
      if ( v3 == 34 )
        *v1 = 39;
      ++v2;
      ++v1;
    }
    while ( v2 <= 0x1FFF && v0[v2] );
  }
  trap_Cvar_Register(0, v5, (int)v0);
  return trap_Cvar_Set(v5, (int)v0);
}

//----- (00059ACC) --------------------------------------------------------
int sub_59ACC()
{
  char *v0; // edi
  unsigned __int8 v1; // al
  int v2; // esi
  char *v3; // eax
  int result; // eax
  int v5; // eax
  int v6; // ebx
  char *v7; // eax

  v0 = (char *)Scr_GetString(0);
  v1 = BG_GetWeaponIndexForName(v0);
  v2 = v1;
  if ( v1 )
  {
    v6 = v1;
    do
    {
      if ( **(_BYTE **)(BG_GetInfoForWeapon(v6) + 388) )
      {
        v5 = BG_GetInfoForWeapon(v6);
        return Scr_AddString(*(_DWORD *)(v5 + 388));
      }
      v6 = *(_DWORD *)(BG_GetInfoForWeapon(v6) + 764);
    }
    while ( v6 && v6 != v2 );
    v7 = va("^3WARNING^7: no Radiant name found for weapon '%s' in getWeaponClassname\n", v0);
    Com_Printf(v7);
    result = Scr_AddUndefined();
  }
  else
  {
    if ( *v0 )
    {
      if ( Q_stricmp(v0, "none") )
      {
        v3 = va("unknown weapon '%s' in getWeaponClassname\n", v0);
        Com_Printf(v3);
      }
    }
    result = Scr_AddUndefined();
  }
  return result;
}

//----- (00059BAC) --------------------------------------------------------
int __cdecl sub_59BAC(unsigned int a1)
{
  int *v1; // edi
  int result; // eax
  int v3; // ebx
  int *v4; // esi
  const char *v5; // eax
  char *v6; // eax
  const char *v7; // [esp-18h] [ebp-40h]
  const char *v8; // [esp+20h] [ebp-8h]
  char *s2; // [esp+24h] [ebp-4h]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
  {
    v8 = (const char *)&unk_76629;
    result = G_EntDetach((int)v1, s2, (int)&unk_76629);
  }
  else
  {
    v8 = (const char *)Scr_GetString(1);
    result = G_EntDetach((int)v1, s2, (int)v8);
  }
  if ( !result )
  {
    Com_Printf("Current attachments:\n");
    v3 = 0;
    v4 = v1 + 187;
    do
    {
      if ( *((_BYTE *)v4 + v3) )
      {
        if ( *((_WORD *)v1 + v3 + 377) )
        {
          v7 = (const char *)SL_ConvertToString(*((_WORD *)v1 + v3 + 377));
          v5 = (const char *)G_ModelName(*((unsigned __int8 *)v4 + v3));
          Com_Printf("model: '%s', tag: '%s'\n", v5, v7);
        }
      }
      ++v3;
    }
    while ( v3 <= 5 );
    v6 = va("failed to detach model '%s' from tag '%s'", s2, v8);
    result = Scr_Error((int)v6);
  }
  return result;
}

//----- (00059CC4) --------------------------------------------------------
int __cdecl sub_59CC4(unsigned int a1)
{
  const char *v1; // eax
  char *v2; // eax
  int *v3; // edi
  int v4; // ebx
  int result; // eax
  const char *v6; // eax
  char *v7; // eax
  const char *v8; // eax
  char *v9; // eax
  _BYTE *v10; // [esp+18h] [ebp-20h]
  int *v11; // [esp+1Ch] [ebp-1Ch]
  float v12[3]; // [esp+20h] [ebp-18h] BYREF
  float v13[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v11 = 0;
  }
  else
  {
    v11 = &g_entities[197 * a1];
  }
  if ( Scr_GetType(0) != 7 || Scr_GetPointerType(0) != 13 )
    Scr_ParamError(0, (int)"not an entity");
  if ( (*((_BYTE *)v11 + 381) & 0x20) == 0 )
  {
    v1 = (const char *)SL_ConvertToString(*((_WORD *)v11 + 187));
    v2 = va("entity (classname: '%s') does not currently support linkTo", v1);
    Scr_ObjectError((int)v2);
  }
  v3 = Scr_GetEntity(0);
  v4 = Scr_GetNumParam();
  if ( v4 <= 1 )
    v10 = &unk_76629;
  else
    v10 = (_BYTE *)Scr_GetString(1);
  if ( v4 > 2 )
  {
    Scr_GetVector(2, (int)v13);
    Scr_GetVector(3, (int)v12);
    result = G_EntLinkToWithOffset((int)v11, v3, v10, v13, v12);
  }
  else
  {
    result = G_EntLinkTo((int)v11, v3, v10);
  }
  if ( !result )
  {
    if ( !trap_DObjExists(v3) )
    {
      if ( !*((_BYTE *)v3 + 373) )
        Scr_Error((int)"failed to link entity since parent has no model");
      v6 = (const char *)G_ModelName(*((unsigned __int8 *)v3 + 373));
      v7 = va("failed to link entity since parent model '%s' is invalid", v6);
      Scr_Error((int)v7);
    }
    if ( *v10 )
    {
      if ( trap_DObjGetBoneIndex(v3, (int)v10) < 0 )
      {
        trap_DObjDumpInfo(v3);
        v8 = (const char *)G_ModelName(*((unsigned __int8 *)v3 + 373));
        v9 = va("failed to link entity since tag '%s' does not exist in parent model '%s'", v10, v8);
        Scr_Error((int)v9);
      }
    }
    result = Scr_Error((int)"failed to link entity due to link cycle");
  }
  return result;
}

//----- (00059EB8) --------------------------------------------------------
int __cdecl sub_59EB8(unsigned int a1)
{
  int v1; // edi
  int *v2; // ebx
  int *v3; // eax
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst5
  long double v7; // fst4
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  float v16; // [esp+18h] [ebp-40h]
  float v17; // [esp+1Ch] [ebp-3Ch]
  float v18; // [esp+20h] [ebp-38h]
  float v19; // [esp+24h] [ebp-34h]
  float v20[3]; // [esp+40h] [ebp-18h] BYREF
  float v21[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v1 = 0;
  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v2 = 0;
  }
  else
  {
    v2 = &g_entities[197 * a1];
  }
  if ( v2[63] )
  {
    v2 = Scr_GetEntity(0);
    if ( a1 > 0x3FF )
    {
      Scr_ObjectError((int)"not an entity");
      v3 = 0;
    }
    else
    {
      v3 = &g_entities[197 * a1];
    }
  }
  else
  {
    v3 = Scr_GetEntity(0);
  }
  v19 = *((float *)v2 + 77) + *((float *)v2 + 64);
  v21[0] = v19;
  v18 = *((float *)v2 + 78) + *((float *)v2 + 65);
  v21[1] = v18;
  v17 = *((float *)v2 + 79) + *((float *)v2 + 66);
  v21[2] = v17;
  v16 = *((float *)v2 + 77) + *((float *)v2 + 67);
  v20[0] = v16;
  v4 = *((float *)v2 + 78) + *((float *)v2 + 68);
  v20[1] = v4;
  v5 = *((float *)v2 + 79) + *((float *)v2 + 69);
  v20[2] = v5;
  if ( v2[63] && v3[63] )
  {
    v6 = *((float *)v3 + 77) + *((float *)v3 + 64);
    v7 = *((float *)v3 + 78) + *((float *)v3 + 65);
    if ( *((float *)v3 + 77) + *((float *)v3 + 67) > (long double)v19 )
      return Scr_AddInt(1);
    if ( *((float *)v3 + 78) + *((float *)v3 + 68) > (long double)v18 )
      return Scr_AddInt(1);
    if ( *((float *)v3 + 79) + *((float *)v3 + 69) > (long double)v17 )
      return Scr_AddInt(1);
    v9 = v6 < v16;
    v10 = 0;
    v11 = v6 == v16;
    if ( (v8 & 0x45) == 1 )
      return Scr_AddInt(1);
    v12 = v7 < v4;
    v13 = 0;
    v14 = v7 == v4;
    if ( (v8 & 0x45) == 1 || v5 > *((float *)v3 + 79) + *((float *)v3 + 66) )
      return Scr_AddInt(1);
  }
  else if ( (*((_BYTE *)v2 + 245) & 2) != 0 )
  {
    if ( trap_EntityContactCapsule((int)v21, (int)v20, (int)v3) )
      return Scr_AddInt(1);
  }
  else if ( trap_EntityContact((int)v21, (int)v20, (int)v3) )
  {
    v1 = 1;
  }
  if ( v1 )
    return Scr_AddInt(1);
  return Scr_AddInt(0);
}
// 5A047: variable 'v8' is possibly undefined

//----- (0005A0E4) --------------------------------------------------------
int __cdecl sub_5A0E4(unsigned int a1)
{
  int *v1; // edi
  int result; // eax
  int v3; // esi
  char **v4; // ebx
  int v5; // esi
  void **v6; // ebx
  char *v7; // eax
  char *v8; // [esp+14h] [ebp-4h]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v8 = (char *)Scr_GetString(0);
  if ( *((_WORD *)v1 + 187) != scr_const[74] || (result = Q_strcasecmp(v8, "HINT_INHERIT")) != 0 )
  {
    v3 = 1;
    if ( *(&hintStrings + 1) )
    {
      v4 = (char **)(&hintStrings + 1);
      while ( 1 )
      {
        result = Q_strcasecmp(v8, *v4);
        if ( !result )
          break;
        ++v4;
        if ( ++v3 > 137 || !*v4 )
          goto LABEL_13;
      }
      v1[55] = v3;
    }
    else
    {
LABEL_13:
      Com_Printf("List of valid hint type strings\n");
      if ( *((_WORD *)v1 + 187) == scr_const[74] )
        Com_Printf("HINT_INHERIT (for trigger_use entities only)\n");
      v5 = 1;
      if ( *(&hintStrings + 1) )
      {
        v6 = &hintStrings + 1;
        do
        {
          Com_Printf((char *)off_76E2E, *v6++);
          ++v5;
        }
        while ( v5 <= 137 && *v6 );
      }
      v7 = va("%s is not a valid hint type. See above for list of valid hint types\n", v8);
      result = Scr_Error((int)v7);
    }
  }
  else
  {
    v1[55] = -1;
  }
  return result;
}
// 7E4D4: using guessed type void *hintStrings;

//----- (0005A238) --------------------------------------------------------
int __cdecl G_GetHintStringIndex(int a1, char *s1)
{
  int i; // esi
  char s2[1024]; // [esp+18h] [ebp-400h] BYREF

  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1212, (int)s2, 1024);
    if ( !s2[0] )
    {
      trap_SetConfigstring(i + 1212, (int)s1);
      *(_DWORD *)a1 = i;
      return 1;
    }
    if ( !strcmp(s1, s2) )
    {
      *(_DWORD *)a1 = i;
      return 1;
    }
  }
  *(_DWORD *)a1 = -1;
  return 0;
}

//----- (0005A2D0) --------------------------------------------------------
int sub_5A2D0()
{
  int v0; // esi
  unsigned int v1; // eax
  unsigned int v2; // ebx
  char *v3; // eax
  int v4; // edx
  int *v5; // edi
  int v6; // edx
  int result; // eax
  int v8; // ebx
  const char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  int v12; // esi
  char *v13; // eax
  char *v14; // eax

  v0 = Scr_GetNumParam();
  if ( v0 <= 1 )
    Scr_Error((int)"objective_add needs at least the first two parameters out of its parameter list of: index state [stri"
                   "ng] [position]\n");
  v1 = Scr_GetInt(0);
  v2 = v1;
  if ( v1 > 0xF )
  {
    v3 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v1, 15);
    Scr_ParamError(0, (int)v3);
  }
  v4 = level[7 * v2 + 12];
  v5 = &level[7 * v2 + 8];
  if ( v4 != 1023 )
  {
    v6 = 197 * v4;
    if ( LOBYTE(g_entities[v6 + 88]) )
      LOBYTE(g_entities[v6 + 61]) &= 0xEFu;
    level[7 * v2 + 12] = 1023;
  }
  result = Scr_GetConstString(1);
  if ( (_WORD)result == scr_const[18] )
  {
    v8 = 0;
  }
  else if ( (_WORD)result == scr_const[33] )
  {
    v8 = 2;
  }
  else
  {
    v8 = 4;
    if ( (_WORD)result != scr_const[10] )
    {
      v8 = 0;
      v9 = (const char *)SL_ConvertToString(result);
      v10 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v9);
      result = Scr_ParamError(1, (int)v10);
    }
  }
  *v5 = v8;
  if ( v0 > 2 )
  {
    Scr_GetVector(2, (int)(v5 + 1));
    *((float *)v5 + 1) = (float)(int)*((float *)v5 + 1);
    *((float *)v5 + 2) = (float)(int)*((float *)v5 + 2);
    result = (int)*((float *)v5 + 3);
    v5[4] = 1023;
    *((float *)v5 + 3) = (float)result;
    if ( v0 > 3 )
    {
      v11 = (char *)Scr_GetString(3);
      v12 = 0;
      if ( *v11 )
      {
        do
        {
          if ( (unsigned __int8)(v11[v12] - 32) > 0x5Eu )
          {
            v13 = va(
                    "Illegal character '%c'(ascii %i) in objective icon name: %s\n",
                    v11[v12],
                    (unsigned __int8)v11[v12],
                    v11);
            Scr_ParamError(3, (int)v13);
          }
          ++v12;
        }
        while ( v11[v12] );
      }
      if ( v12 > 63 )
      {
        v14 = va("Objective icon name is too long (> %i): %s\n", 63, v11);
        Scr_ParamError(3, (int)v14);
      }
      result = G_ShaderIndex(v11);
      v5[6] = result;
    }
  }
  v5[5] = 0;
  return result;
}

//----- (0005A4F4) --------------------------------------------------------
int sub_5A4F4()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int *v3; // esi
  int result; // eax
  int v5; // ebx
  const char *v6; // eax
  char *v7; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = &level[7 * v1 + 8];
  result = Scr_GetConstString(1);
  if ( (_WORD)result == scr_const[18] )
  {
    v5 = 0;
  }
  else if ( (_WORD)result == scr_const[33] )
  {
    v5 = 2;
  }
  else
  {
    v5 = 4;
    if ( (_WORD)result != scr_const[10] )
    {
      v5 = 0;
      v6 = (const char *)Scr_GetString(1);
      v7 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v6);
      result = Scr_ParamError(1, (int)v7);
    }
  }
  *v3 = v5;
  if ( !v5 || v5 == 2 )
  {
    result = v3[4];
    if ( result != 1023 )
    {
      result *= 788;
      if ( *((_BYTE *)&g_entities[88] + result) )
        *((_BYTE *)&g_entities[61] + result) &= 0xEFu;
      v3[4] = 1023;
    }
  }
  return result;
}

//----- (0005A5D8) --------------------------------------------------------
int sub_5A5D8()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int *v3; // edi
  char *v4; // ebx
  int v5; // esi
  char *v6; // eax
  char *v7; // eax
  int result; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = &level[7 * v1 + 8];
  v4 = (char *)Scr_GetString(1);
  v5 = 0;
  if ( *v4 )
  {
    do
    {
      if ( (unsigned __int8)(v4[v5] - 32) > 0x5Eu )
      {
        v6 = va("Illegal character '%c'(ascii %i) in objective icon name: %s\n", v4[v5], (unsigned __int8)v4[v5], v4);
        Scr_ParamError(3, (int)v6);
      }
      ++v5;
    }
    while ( v4[v5] );
  }
  if ( v5 > 63 )
  {
    v7 = va("Objective icon name is too long (> %i): %s\n", 63, v4);
    Scr_ParamError(3, (int)v7);
  }
  result = G_ShaderIndex(v4);
  v3[6] = result;
  return result;
}

//----- (0005A6AC) --------------------------------------------------------
int *sub_5A6AC()
{
  int v0; // edi
  int i; // esi
  unsigned int v2; // eax
  unsigned int v3; // ebx
  char *v4; // eax
  int v5; // ebx
  int *result; // eax
  int s[16]; // [esp+18h] [ebp-40h] BYREF

  v0 = Scr_GetNumParam();
  _bzero(s, 0x40u);
  for ( i = 0; i < v0; ++i )
  {
    v2 = Scr_GetInt(i);
    v3 = v2;
    if ( v2 > 0xF )
    {
      v4 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2, 15);
      Scr_ParamError(i, (int)v4);
    }
    s[v3] = 1;
  }
  v5 = 0;
  result = &level[8];
  do
  {
    if ( s[v5] )
    {
      *result = 4;
    }
    else if ( *result == 4 )
    {
      *result = 1;
    }
    result += 7;
    ++v5;
  }
  while ( v5 <= 15 );
  return result;
}

//----- (0005A750) --------------------------------------------------------
int sub_5A750()
{
  char *v0; // eax
  int v1; // edi
  char *v2; // eax
  int v3; // ebx
  _DWORD *v4; // esi
  int result; // eax

  v0 = (char *)Scr_GetString(2);
  v1 = (unsigned __int8)BG_GetWeaponIndexForName(v0);
  v2 = (char *)Scr_GetString(3);
  v3 = G_IndexForMeansOfDeath(v2);
  v4 = G_TempEntity(&vec3_origin, 201);
  v4[29] = *Scr_GetEntity(0);
  if ( Scr_GetType(1) == 7 && Scr_GetPointerType(1) == 13 )
    v4[30] = *Scr_GetEntity(1);
  else
    v4[30] = 1022;
  v4[61] = 8;
  result = v3 - 7;
  if ( (unsigned int)(v3 - 7) <= 1 || v3 == 22 || v3 == 21 || v3 == 19 || v3 == 16 || v3 == 17 )
  {
    LOBYTE(v3) = v3 | 0x80;
    v4[40] = v3;
  }
  else
  {
    v4[40] = v1;
  }
  return result;
}
// 72910: using guessed type float vec3_origin;

//----- (0005A834) --------------------------------------------------------
int sub_5A834()
{
  int v0; // ecx
  int v1; // edx
  int v2; // eax
  float v4; // [esp+14h] [ebp-1024h] BYREF
  float v5; // [esp+18h] [ebp-1020h]
  float v6; // [esp+1Ch] [ebp-101Ch]
  float v7[3]; // [esp+20h] [ebp-1018h] BYREF
  float v8[3]; // [esp+2Ch] [ebp-100Ch] BYREF
  _DWORD v9[1024]; // [esp+38h] [ebp-1000h] BYREF

  Scr_GetVector(0, (int)&v4);
  v8[0] = v4 + playerMins[0];
  v8[1] = v5 + playerMins[1];
  v8[2] = v6 + playerMins[2];
  v7[0] = v4 + playerMaxs[0];
  v7[1] = v5 + playerMaxs[1];
  v7[2] = v6 + playerMaxs[2];
  v0 = trap_EntitiesInBox((int)v8, (int)v7, (int)v9);
  v1 = 0;
  if ( v0 <= 0 )
    return Scr_AddInt(0);
  while ( 1 )
  {
    v2 = g_entities[197 * v9[v1] + 86];
    if ( v2 )
    {
      if ( *(int *)(v2 + 4) <= 5 )
        break;
    }
    if ( ++v1 >= v0 )
      return Scr_AddInt(0);
  }
  return Scr_AddInt(1);
}

//----- (0005A92C) --------------------------------------------------------
int sub_5A92C()
{
  int i; // ebx
  int j; // ebx
  char *v3; // eax
  char *v4; // [esp+14h] [ebp-404h]
  char v5[1024]; // [esp+18h] [ebp-400h] BYREF

  v4 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1180, (int)v5, 1024);
    if ( !Q_stricmp(v5, v4) )
      return Com_DPrintf("Script tried to precache the menu '%s' more than once\n", v4);
  }
  for ( j = 0; j <= 31; ++j )
  {
    trap_GetConfigstring(j + 1180, (int)v5, 1024);
    if ( !v5[0] )
      break;
  }
  if ( j == 32 )
  {
    v3 = va("Too many menus precached. Max allowed menus is %i", 32);
    Scr_Error((int)v3);
  }
  return trap_SetConfigstring(j + 1180, (int)v4);
}

//----- (0005AA08) --------------------------------------------------------
int sub_5AA08()
{
  int i; // ebx
  int j; // ebx
  char *v3; // eax
  char *v4; // [esp+14h] [ebp-404h]
  char v5[1024]; // [esp+18h] [ebp-400h] BYREF

  v4 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 7; ++i )
  {
    trap_GetConfigstring(i + 21, (int)v5, 1024);
    if ( !Q_stricmp(v5, v4) )
      return Com_DPrintf("Script tried to precache the player status icon '%s' more than once\n", v4);
  }
  for ( j = 0; j <= 7; ++j )
  {
    trap_GetConfigstring(j + 21, (int)v5, 1024);
    if ( !v5[0] )
      break;
  }
  if ( j == 8 )
  {
    v3 = va("Too many player status icons precached. Max allowed is %i", 8);
    Scr_Error((int)v3);
  }
  return trap_SetConfigstring(j + 21, (int)v4);
}

//----- (0005AAE4) --------------------------------------------------------
int sub_5AAE4()
{
  int i; // ebx
  int j; // ebx
  char *v3; // eax
  char *v4; // [esp+14h] [ebp-404h]
  char v5[1024]; // [esp+18h] [ebp-400h] BYREF

  v4 = (char *)Scr_GetString(0);
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 29, (int)v5, 1024);
    if ( !Q_stricmp(v5, v4) )
      return Com_DPrintf("Script tried to precache the player head icon '%s' more than once\n", v4);
  }
  for ( j = 0; j <= 14; ++j )
  {
    trap_GetConfigstring(j + 29, (int)v5, 1024);
    if ( !v5[0] )
      break;
  }
  if ( j == 15 )
  {
    v3 = va("Too many player head icons precached. Max allowed is %i", 15);
    Scr_Error((int)v3);
  }
  return trap_SetConfigstring(j + 29, (int)v4);
}

//----- (0005ABC4) --------------------------------------------------------
int sub_5ABC4()
{
  int v0; // eax
  int result; // eax
  float v2[3]; // [esp+24h] [ebp-54h] BYREF
  float v3; // [esp+30h] [ebp-48h] BYREF
  char v4[12]; // [esp+34h] [ebp-44h] BYREF
  char v5[12]; // [esp+40h] [ebp-38h] BYREF
  int v6; // [esp+4Ch] [ebp-2Ch]
  int v7; // [esp+58h] [ebp-20h]
  float v8[3]; // [esp+60h] [ebp-18h] BYREF
  float v9[3]; // [esp+6Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v9);
  Scr_GetVector(1, (int)v8);
  Scr_GetBool(2);
  if ( Scr_GetType(3) == 7 && Scr_GetPointerType(3) == 13 )
    Scr_GetEntity(3);
  trap_LocationalTrace((int)&v3, (int)v9, (int)v8);
  Scr_MakeArray();
  Scr_AddFloat(v3);
  Scr_AddArrayStringIndexed(scr_const[25]);
  Scr_AddVector((int)v4);
  Scr_AddArrayStringIndexed(scr_const[50]);
  if ( (unsigned __int16)(v7 - 1022) > 1u )
    Scr_AddEntity(&g_entities[197 * (unsigned __int16)v7]);
  else
    Scr_AddUndefined();
  Scr_AddArrayStringIndexed(scr_const[22]);
  if ( v3 >= 1.0 )
  {
    v2[0] = v8[0] - v9[0];
    v2[1] = v8[1] - v9[1];
    v2[2] = v8[2] - v9[2];
    VectorNormalize(v2);
    Scr_AddVector((int)v2);
    Scr_AddArrayStringIndexed(scr_const[46]);
    Scr_AddConstString(scr_const[124]);
    result = Scr_AddArrayStringIndexed(scr_const[64]);
  }
  else
  {
    Scr_AddVector((int)v5);
    Scr_AddArrayStringIndexed(scr_const[46]);
    v0 = trap_SurfaceTypeToName((v6 & 0x1F00000u) >> 20);
    Scr_AddString(v0);
    result = Scr_AddArrayStringIndexed(scr_const[64]);
  }
  return result;
}

//----- (0005ADC4) --------------------------------------------------------
int sub_5ADC4()
{
  int v0; // ebx
  int v1; // eax
  const char *v2; // eax
  const char *v3; // esi
  char *v4; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax

  v0 = 0;
  v1 = Scr_GetNumParam();
  if ( v1 != 1 )
  {
    if ( v1 != 2 )
    {
      v4 = va("USAGE: ambientPlay(alias_name, <fadetime>);\n");
      return Scr_Error((int)v4);
    }
    v0 = (int)(Scr_GetFloat(1) * 1000.0 + 0.5);
  }
  v2 = (const char *)Scr_GetString(0);
  v3 = v2;
  if ( !*v2 )
  {
    v6 = va("ambientPlay: alias name cannot be the empty string... use stop or fade version\n");
    Scr_Error((int)v6);
  }
  if ( v0 < 0 )
  {
    v7 = va("ambientPlay: fade time must be >= 0\n");
    Scr_Error((int)v7);
  }
  v8 = va("n\\%s\\t\\%i", v3, level[122] + v0);
  return trap_SetConfigstring(3, (int)v8);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005AEA4) --------------------------------------------------------
int sub_5AEA4()
{
  _DWORD *v0; // eax
  _DWORD *v1; // esi
  char v3[28]; // [esp+18h] [ebp-60h] BYREF
  int v4; // [esp+34h] [ebp-44h]
  float v5; // [esp+48h] [ebp-30h]
  float v6; // [esp+4Ch] [ebp-2Ch]
  float v7; // [esp+50h] [ebp-28h]
  float v8; // [esp+54h] [ebp-24h] BYREF
  float v9; // [esp+58h] [ebp-20h]
  float v10; // [esp+5Ch] [ebp-1Ch]
  int v11[3]; // [esp+60h] [ebp-18h] BYREF
  float v12[3]; // [esp+6Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v12);
  v8 = v12[0];
  v9 = v12[1];
  v10 = v12[2] + 1.0;
  v0 = G_TempEntity(&v8, 178);
  v11[0] = 0;
  v11[1] = 0;
  v11[2] = 1065353216;
  v1 = v0;
  v0[40] = (unsigned __int8)DirToByte((float *)v11);
  v5 = v8;
  v6 = v9;
  v7 = v10 - 17.0;
  trap_Trace((int)v3, (int)&v8, (int)&vec3_origin);
  v1[34] = (v4 & 0x1F00000u) >> 20;
  return Concussive_fx(&v8);
}
// 72910: using guessed type float vec3_origin;

//----- (0005AF70) --------------------------------------------------------
int sub_5AF70()
{
  int v0; // eax
  long double v1; // fst7
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  float v15; // [esp+18h] [ebp-20h]
  float v16; // [esp+1Ch] [ebp-1Ch]
  char v17[8]; // [esp+20h] [ebp-18h] BYREF
  unsigned int v18; // [esp+28h] [ebp-10h] BYREF
  char v19[12]; // [esp+2Ch] [ebp-Ch] BYREF

  v0 = Scr_GetNumParam();
  if ( v0 != 1 )
  {
    if ( v0 != 2 )
    {
      v1 = Scr_GetFloat(2);
      v15 = v1;
      v3 = v1 < 0.0;
      v4 = 0;
      v5 = v1 == 0.0;
      if ( (v2 & 0x45) == 1 || (v7 = v15 > 1.0, v8 = 0, v9 = 1.0 == v15, (v6 & 0x45) == 1) )
        Scr_ParamError(2, (int)"end time must be between 0 and 1");
    }
    v16 = Scr_GetFloat(1);
    if ( v16 < 0.0 || (v11 = v16 > 1.0, v12 = 0, v13 = 1.0 == v16, (v10 & 0x45) == 1) )
      Scr_ParamError(1, (int)"start time must be between 0 and 1");
  }
  Scr_GetAnim(&v18, 0, 0);
  trap_XAnimGetRelDelta(v18, (int)v17);
  return Scr_AddVector((int)v19);
}
// 5AFAD: variable 'v2' is possibly undefined
// 5AFBC: variable 'v6' is possibly undefined
// 5AFF9: variable 'v10' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005B054) --------------------------------------------------------
int sub_5B054()
{
  int v0; // eax
  long double v1; // fst7
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  float v15; // [esp-20h] [ebp-58h]
  float v16; // [esp+18h] [ebp-20h]
  float v17; // [esp+1Ch] [ebp-1Ch]
  float v18[2]; // [esp+20h] [ebp-18h] BYREF
  unsigned int v19; // [esp+28h] [ebp-10h] BYREF

  v0 = Scr_GetNumParam();
  if ( v0 != 1 )
  {
    if ( v0 != 2 )
    {
      v1 = Scr_GetFloat(2);
      v16 = v1;
      v3 = v1 < 0.0;
      v4 = 0;
      v5 = v1 == 0.0;
      if ( (v2 & 0x45) == 1 || (v7 = v16 > 1.0, v8 = 0, v9 = 1.0 == v16, (v6 & 0x45) == 1) )
        Scr_ParamError(2, (int)"end time must be between 0 and 1");
    }
    v17 = Scr_GetFloat(1);
    if ( v17 < 0.0 || (v11 = v17 > 1.0, v12 = 0, v13 = 1.0 == v17, (v10 & 0x45) == 1) )
      Scr_ParamError(1, (int)"start time must be between 0 and 1");
  }
  Scr_GetAnim(&v19, 0, 0);
  trap_XAnimGetRelDelta(v19, (int)v18);
  v15 = RotationToYaw(v18);
  return Scr_AddFloat(v15);
}
// 5B091: variable 'v2' is possibly undefined
// 5B0A0: variable 'v6' is possibly undefined
// 5B0DD: variable 'v10' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005B148) --------------------------------------------------------
int sub_5B148()
{
  int v0; // esi
  long double v1; // fst7
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char *v6; // eax
  _DWORD *v7; // ebx
  int result; // eax
  _DWORD *v9; // ebx
  char dest[1024]; // [esp+20h] [ebp-418h] BYREF
  float v11[3]; // [esp+420h] [ebp-18h] BYREF
  float v12[3]; // [esp+42Ch] [ebp-Ch] BYREF

  if ( (unsigned int)Scr_GetNumParam() <= 1 || (unsigned int)Scr_GetNumParam() > 3 )
    Scr_Error((int)"USAGE: playFx <effect id from loadFx> <vector position of effect> <optional forward vector>");
  v0 = Scr_GetInt(0);
  Scr_GetVector(1, (int)v12);
  if ( Scr_GetNumParam() == 3 )
  {
    Scr_GetVector(2, (int)v11);
    v1 = VectorNormalize(v11);
    v3 = v1 > 0.0;
    v4 = 0;
    v5 = 0.0 == v1;
    if ( (v2 & 0x44) == 0x40 )
    {
      if ( v0 )
        trap_GetConfigstring(v0 + 780, (int)dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v6 = va("playFx called with (0 0 0) forward direction (effect = %s)\n", dest);
      Scr_Error((int)v6);
    }
    v7 = G_TempEntity(v12, 192);
    v7[40] = (unsigned __int8)v0;
    result = (unsigned __int8)DirToByte(v11);
    v7[54] = (unsigned __int8)result;
  }
  else
  {
    v9 = G_TempEntity(v12, 191);
    result = (unsigned __int8)v0;
    v9[40] = (unsigned __int8)v0;
  }
  return result;
}
// 5B1C5: variable 'v2' is possibly undefined

//----- (0005B280) --------------------------------------------------------
int sub_5B280()
{
  int v0; // edi
  char *v1; // eax
  int *v2; // esi
  const char *v3; // ebx
  const char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v7; // eax

  if ( Scr_GetNumParam() != 3 )
    Scr_Error((int)"USAGE: playFxOnTag <effect id from loadFx> <entity> <tag name>");
  v0 = Scr_GetInt(0);
  if ( (unsigned int)(v0 - 1) > 0x3E )
  {
    v1 = va("effect id %i is invalid\n", v0);
    Scr_ParamError(0, (int)v1);
  }
  v2 = Scr_GetEntity(1);
  if ( !*((_BYTE *)v2 + 373) )
    Scr_ParamError(1, (int)"cannot play fx on entity with no model");
  v3 = (const char *)Scr_GetString(2);
  if ( strchr(v3, 34) )
    Scr_ParamError(2, (int)"cannot use \" characters in tag names\n");
  if ( trap_DObjGetBoneIndex(v2, (int)v3) < 0 )
  {
    trap_DObjDumpInfo(v2);
    v4 = (const char *)G_ModelName(*((unsigned __int8 *)v2 + 373));
    v5 = va("tag '%s' does not exist on entity with model '%s'", v3, v4);
    Scr_ParamError(2, (int)v5);
  }
  v6 = va("%02d%s", v0, v3);
  v7 = G_FindConfigstringIndex(v6, 844, 256, 1, 0);
  return G_AddEvent(v2, 193, v7);
}

//----- (0005B3C0) --------------------------------------------------------
int sub_5B3C0()
{
  int v0; // eax
  long double v1; // fst7
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char *v6; // eax
  int v7; // esi
  int v8; // edi
  float v10; // [esp+1Ch] [ebp-42Ch]
  int v11; // [esp+20h] [ebp-428h]
  char dest[1024]; // [esp+30h] [ebp-418h] BYREF
  float v13; // [esp+430h] [ebp-18h] BYREF
  float v14; // [esp+434h] [ebp-14h]
  float v15; // [esp+438h] [ebp-10h]
  float v16[3]; // [esp+43Ch] [ebp-Ch] BYREF

  if ( (unsigned int)Scr_GetNumParam() <= 2 || (unsigned int)Scr_GetNumParam() > 5 )
    Scr_Error((int)"USAGE: playLoopedFx <effect id from loadFx> <repeat delay> <vector position of effect> <optional cull"
                   " distance (0 = never cull)> <optional forward vector>");
  v15 = 0.0;
  v14 = 0.0;
  v13 = 0.0;
  v10 = 0.0;
  v11 = Scr_GetInt(0);
  v0 = Scr_GetNumParam();
  if ( v0 == 4 )
    goto LABEL_11;
  if ( v0 == 5 )
  {
    Scr_GetVector(4, (int)&v13);
    v1 = VectorNormalize(&v13);
    v3 = v1 > 0.0;
    v4 = 0;
    v5 = 0.0 == v1;
    if ( (v2 & 0x44) == 0x40 )
    {
      if ( v11 )
        trap_GetConfigstring(v11 + 780, (int)dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v6 = va("playLoopedFx called with (0 0 0) forward direction (effect = %s)\n", dest);
      Scr_Error((int)v6);
    }
LABEL_11:
    v10 = Scr_GetFloat(3);
  }
  Scr_GetVector(2, (int)v16);
  v7 = (int)(Scr_GetFloat(1) * 1000.0 + 0.5);
  v8 = G_Spawn();
  *(_DWORD *)(v8 + 4) = 10;
  *(_BYTE *)(v8 + 244) |= 8u;
  *(_DWORD *)(v8 + 216) = (unsigned __int8)v11;
  G_SetOrigin(v8, v16);
  *(float *)(v8 + 92) = v13;
  *(float *)(v8 + 96) = v14;
  *(float *)(v8 + 100) = v15;
  *(float *)(v8 + 104) = v10;
  *(float *)(v8 + 108) = (float)v7;
  trap_LinkEntity(v8);
  return Scr_AddEntity((int *)v8);
}
// 5B45D: variable 'v2' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005B5A8) --------------------------------------------------------
__int16 sub_5B5A8()
{
  char *v0; // eax
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  char *v5; // eax
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  float v22; // [esp+10h] [ebp-28h]
  float v23; // [esp+14h] [ebp-24h]
  float v24; // [esp+18h] [ebp-20h]
  float v25; // [esp+1Ch] [ebp-1Ch]
  float v26; // [esp+20h] [ebp-18h]
  float v27; // [esp+24h] [ebp-14h]

  if ( Scr_GetNumParam() != 6 )
    Scr_Error((int)"USAGE: setCullFog(near distance, far distance, red, green, blue, transition time);\n");
  v27 = Scr_GetFloat(0);
  v26 = Scr_GetFloat(1);
  v25 = Scr_GetFloat(2);
  v24 = Scr_GetFloat(3);
  v23 = Scr_GetFloat(4);
  v22 = Scr_GetFloat(5);
  if ( v27 < 0.0 )
  {
    v0 = va("%s: near distance must be >= 0", "setCullFog");
    Scr_Error((int)v0);
  }
  v2 = v26 < (long double)v27;
  v3 = 0;
  v4 = v26 == v27;
  if ( (unsigned __int8)((v1 & 0x45) - 1) < 0x40u )
  {
    v5 = va("%s: near distance must be less than far distance", "setCullFog");
    Scr_Error((int)v5);
  }
  if ( v25 < 0.0 )
    goto LABEL_13;
  v7 = v25 > 1.0;
  v8 = 0;
  v9 = 1.0 == v25;
  if ( (v6 & 0x45) == 1
    || v24 < 0.0
    || (v11 = v24 > 1.0, v12 = 0, v13 = 1.0 == v24, (v10 & 0x45) == 1)
    || v23 < 0.0
    || (v15 = v23 > 1.0, v16 = 0, v17 = 1.0 == v23, (v14 & 0x45) == 1) )
  {
LABEL_13:
    v18 = va("%s: red/green/blue color components must be in the range [0, 1]", "setCullFog");
    Scr_Error((int)v18);
  }
  if ( v22 < 0.0 )
  {
    v19 = va("%s: transition time must be >= 0 seconds", "setCullFog");
    Scr_Error((int)v19);
  }
  v20 = va("%g %g %g %g %g %g %.0f", v27, v26, 1.0, v25, v24, v23, (double)(v22 * 1000.0));
  return G_setfog(v20);
}
// 5B651: variable 'v1' is possibly undefined
// 5B68C: variable 'v6' is possibly undefined
// 5B6A7: variable 'v10' is possibly undefined
// 5B6C0: variable 'v14' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005B774) --------------------------------------------------------
__int16 sub_5B774()
{
  char v0; // fps^1
  bool v1; // c0
  char v2; // c2
  bool v3; // c3
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  char v12; // fps^1
  bool v13; // c0
  char v14; // c2
  bool v15; // c3
  char *v16; // eax
  char *v17; // eax
  char *v18; // eax
  float v20; // [esp+14h] [ebp-24h]
  float v21; // [esp+18h] [ebp-20h]
  float v22; // [esp+1Ch] [ebp-1Ch]
  float v23; // [esp+20h] [ebp-18h]
  float v24; // [esp+24h] [ebp-14h]

  if ( Scr_GetNumParam() != 5 )
    Scr_Error((int)"USAGE: setExpFog(density, red, green, blue, transition time);\n"
                   "Density must be greater than 0 and less than 1, and typically less than .001.  For example, .0002 mea"
                   "ns the fog gets .02%% more dense for every 1 unit of distance (about 1%% thicker every 50 units of distance)\n");
  v24 = Scr_GetFloat(0);
  v23 = Scr_GetFloat(1);
  v22 = Scr_GetFloat(2);
  v21 = Scr_GetFloat(3);
  v20 = Scr_GetFloat(4);
  if ( v24 <= 0.0 || (v1 = v24 > 1.0, v2 = 0, v3 = 1.0 == v24, (unsigned __int8)((v0 & 0x45) - 1) < 0x40u) )
    Scr_Error((int)"setExpFog: distance must be greater than 0 and less than 1");
  if ( v23 < 0.0 )
    goto LABEL_12;
  v5 = v23 > 1.0;
  v6 = 0;
  v7 = 1.0 == v23;
  if ( (v4 & 0x45) == 1
    || v22 < 0.0
    || (v9 = v22 > 1.0, v10 = 0, v11 = 1.0 == v22, (v8 & 0x45) == 1)
    || v21 < 0.0
    || (v13 = v21 > 1.0, v14 = 0, v15 = 1.0 == v21, (v12 & 0x45) == 1) )
  {
LABEL_12:
    v16 = va("%s: red/green/blue color components must be in the range [0, 1]", "setExpFog");
    Scr_Error((int)v16);
  }
  if ( v20 < 0.0 )
  {
    v17 = va("%s: transition time must be >= 0 seconds", "setExpFog");
    Scr_Error((int)v17);
  }
  v18 = va("%g %g %g %g %g %g %.0f", 0.0, 1.0, v24, v23, v22, v21, (double)(v20 * 1000.0));
  return G_setfog(v18);
}
// 5B7F1: variable 'v0' is possibly undefined
// 5B81E: variable 'v4' is possibly undefined
// 5B839: variable 'v8' is possibly undefined
// 5B852: variable 'v12' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005B900) --------------------------------------------------------
int sub_5B900()
{
  unsigned __int16 v0; // ax
  int v1; // esi
  const char *v2; // eax
  char *v3; // eax
  int result; // eax
  char *v5; // esi
  char *v6; // eax
  char dest[1024]; // [esp+18h] [ebp-400h] BYREF

  v0 = Scr_GetConstString(0);
  if ( v0 == scr_const[2] )
  {
    v1 = -2;
  }
  else if ( v0 == scr_const[4] )
  {
    v1 = -1;
  }
  else
  {
    if ( v0 != scr_const[124] )
    {
      v2 = (const char *)SL_ConvertToString(v0);
      v3 = va("Illegal team string '%s'. Must be allies, axis, or none.", v2);
      return Scr_ParamError(0, (int)v3);
    }
    v1 = 0;
  }
  trap_GetConfigstring(20, (int)dest, 1024);
  v5 = va("%i", v1);
  v6 = Info_ValueForKey(dest, "winner");
  result = Q_stricmp(v6, v5);
  if ( result )
  {
    Info_SetValueForKey(dest, "winner", (int)v5);
    result = trap_SetConfigstring(20, (int)dest);
  }
  return result;
}

//----- (0005B9DC) --------------------------------------------------------
int sub_5B9DC()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // bx
  const char *v2; // eax
  char *v3; // eax
  int v4; // eax
  char *v5; // eax
  int result; // eax
  char *v7; // eax

  v0 = Scr_GetConstString(0);
  v1 = v0;
  if ( v0 != scr_const[2] && v0 != scr_const[4] )
  {
    v2 = (const char *)SL_ConvertToString(v0);
    v3 = va("Illegal team string '%s'. Must be allies, or axis.", v2);
    Scr_Error((int)v3);
  }
  v4 = Scr_GetInt(1);
  if ( v1 == scr_const[2] )
  {
    level[128] = v4;
    v5 = va("%i", v4);
    result = trap_SetConfigstring(6, (int)v5);
  }
  else
  {
    level[127] = v4;
    v7 = va("%i", v4);
    result = trap_SetConfigstring(5, (int)v7);
  }
  level[131] = 1;
  return result;
}

//----- (0005BA90) --------------------------------------------------------
int sub_5BA90()
{
  int v0; // esi
  int result; // eax
  int v2; // [esp+14h] [ebp-24h]
  char dest[32]; // [esp+18h] [ebp-20h] BYREF

  if ( !level[132] )
    Scr_Error((int)"Only works in [manual_change] mode");
  v2 = 0;
  v0 = level[0];
  for ( result = 0; v2 < level[120]; v0 += 8900 )
  {
    if ( *(_DWORD *)(v0 + 8428) == 2 )
    {
      if ( strcmp((const char *)(v0 + 8628), (const char *)(v0 + 8492)) )
      {
        Q_strncpyz(dest, (char *)(v0 + 8628), 32);
        Q_strncpyz((char *)(v0 + 8628), (char *)(v0 + 8492), 32);
        ClientUserinfoChanged(v2);
      }
    }
    result = ++v2;
  }
  return result;
}

//----- (0005BB44) --------------------------------------------------------
int __cdecl sub_5BB44(unsigned int a1)
{
  int *v1; // esi
  const char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int v5; // edi
  int v6; // ebx
  char *v7; // eax
  int result; // eax
  char *v9; // eax
  const char *v10; // [esp-18h] [ebp-450h]
  char *s2; // [esp+14h] [ebp-424h]
  char s1[1024]; // [esp+38h] [ebp-400h] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( !v1[86] )
  {
    if ( *((_WORD *)v1 + 235) )
      v2 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 235));
    else
      v2 = "<undefined>";
    v10 = v2;
    v3 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 187));
    v4 = va(
           "only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n",
           a1,
           *((float *)v1 + 77),
           *((float *)v1 + 78),
           *((float *)v1 + 79),
           v3,
           v10);
    Scr_Error((int)v4);
  }
  if ( Scr_GetNumParam() != 2 )
    Scr_Error((int)"USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  s2 = (char *)Scr_GetString(0);
  v5 = 1;
  while ( 1 )
  {
    trap_GetConfigstring(v5 + 1100, (int)s1, 1024);
    if ( !strcasecmp(s1, s2) )
      break;
    if ( ++v5 > 15 )
    {
      v9 = va("shellshock '%s' was not precached\n", s2);
      return Scr_Error((int)v9);
    }
  }
  v6 = (int)(Scr_GetFloat(1) * 1000.0 + 0.5);
  if ( (unsigned int)v6 > 0xEA60 )
  {
    v7 = va("duration %g should be >= 0 and <= 60", (double)((long double)v6 * 0.001));
    Scr_ParamError(1, (int)v7);
  }
  *(_DWORD *)(v1[86] + 988) = v5;
  *(_DWORD *)(v1[86] + 992) = level[122];
  result = v1[86];
  *(_DWORD *)(result + 996) = v6;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005BD54) --------------------------------------------------------
int __cdecl sub_5BD54(unsigned int a1)
{
  int *v1; // ebx
  const char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  long double v5; // fst7
  char *v6; // eax
  int result; // eax
  const char *v8; // [esp-18h] [ebp-50h]
  float v9[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( !v1[86] )
  {
    if ( *((_WORD *)v1 + 235) )
      v2 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 235));
    else
      v2 = "<undefined>";
    v8 = v2;
    v3 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 187));
    v4 = va(
           "only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n",
           a1,
           *((float *)v1 + 77),
           *((float *)v1 + 78),
           *((float *)v1 + 79),
           v3,
           v8);
    Scr_Error((int)v4);
  }
  if ( Scr_GetNumParam() != 2 )
    Scr_Error((int)"USAGE: <player> viewkick <force 0-127> <source position>\n");
  *(_DWORD *)(v1[86] + 8724) = (v1[141] * Scr_GetInt(0) + 50) / 100;
  if ( *(int *)(v1[86] + 8724) < 0 )
  {
    v5 = Scr_GetFloat(0);
    v6 = va("viewkick: damage %g < 0\n", (double)v5);
    Scr_Error((int)v6);
  }
  Scr_GetVector(1, (int)v9);
  *(float *)(v1[86] + 8728) = *(float *)(v1[86] + 20) - v9[0];
  *(float *)(v1[86] + 8732) = *(float *)(v1[86] + 24) - v9[1];
  result = v1[86];
  *(float *)(result + 8736) = *(float *)(result + 28) - v9[2];
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005BEDC) --------------------------------------------------------
int __cdecl sub_5BEDC(unsigned int a1)
{
  int *v1; // edi
  float v3; // [esp+2Ch] [ebp-3Ch] BYREF
  float v4; // [esp+30h] [ebp-38h]
  float v5; // [esp+34h] [ebp-34h]
  char v6[4]; // [esp+38h] [ebp-30h] BYREF
  float v7; // [esp+3Ch] [ebp-2Ch] BYREF
  float v8; // [esp+40h] [ebp-28h]
  float v9; // [esp+44h] [ebp-24h]
  unsigned __int16 v10; // [esp+60h] [ebp-8h]
  char v11; // [esp+66h] [ebp-2h]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v3 = *((float *)v1 + 77);
  v4 = *((float *)v1 + 78);
  v5 = *((float *)v1 + 79);
  trap_TraceCapsule((int)v6, (int)&v3, (int)playerMins);
  v3 = v7;
  v4 = v8;
  v5 = v9;
  trap_TraceCapsule((int)v6, (int)&v3, (int)playerMins);
  v1[31] = v10;
  v3 = v7;
  v4 = v8;
  v5 = v9;
  trap_TraceCapsule((int)v6, (int)&v3, (int)playerMins);
  if ( v11 )
    Com_Printf(
      "WARNING: Spawn point entity %i is in solid at (%i, %i, %i)\n",
      *v1,
      (int)*((float *)v1 + 77),
      (int)*((float *)v1 + 78),
      (int)*((float *)v1 + 79));
  return G_SetOrigin((int)v1, &v7);
}

//----- (0005C098) --------------------------------------------------------
int sub_5C098()
{
  char *v0; // edi
  char *v1; // ebx
  int v2; // esi
  char v3; // al
  int v5; // [esp+14h] [ebp-804h]
  char s[1024]; // [esp+18h] [ebp-800h] BYREF
  char v7[1024]; // [esp+418h] [ebp-400h] BYREF

  v5 = Scr_GetString(0);
  if ( Scr_GetType(1) == 2 )
  {
    Scr_ConstructMessageString(1, v7, 1024, 1);
    v0 = v7;
  }
  else
  {
    v0 = (char *)Scr_GetString(1);
  }
  v1 = s;
  _bzero(s, 0x400u);
  v2 = 0;
  if ( *v0 )
  {
    do
    {
      v3 = Q_CleanCharacter(v0[v2]);
      *v1 = v3;
      if ( v3 == 34 )
        *v1 = 39;
      ++v2;
      ++v1;
    }
    while ( v2 <= 0x1FFF && v0[v2] );
  }
  return trap_Cvar_Register(0, v5, (int)v0);
}

//----- (0005C15C) --------------------------------------------------------
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2)
{
  unsigned int v2; // edi
  char **v3; // esi
  int v4; // ebx
  char *s1; // [esp+14h] [ebp-4h]

  v2 = 0;
  v3 = &functions + 1;
  v4 = 0;
  s1 = *a1;
  do
  {
    if ( !strcmp(s1, (&functions)[v4]) )
    {
      *a1 = (&functions)[v4];
      *a2 = v3[1];
      return *v3;
    }
    v3 += 3;
    v4 += 3;
    ++v2;
  }
  while ( v2 <= 0x69 );
  return 0;
}
// 7E508: using guessed type char *functions;

//----- (0005C1C0) --------------------------------------------------------
int __cdecl sub_5C1C0(char **a1)
{
  unsigned int v1; // esi
  int v2; // ebx
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  s1 = *a1;
  do
  {
    if ( !strcmp(s1, (&off_7EA00)[v2]) )
    {
      *a1 = (&off_7EA00)[v2];
      return *(int *)((char *)&off_7EA04 + v2 * 4);
    }
    v2 += 2;
    ++v1;
  }
  while ( v1 <= 0x25 );
  return 0;
}
// 7EA00: using guessed type char *off_7EA00;
// 7EA04: using guessed type int (__cdecl *off_7EA04)(int);

//----- (0005C21C) --------------------------------------------------------
int Scr_ParseGameTypeList()
{
  int result; // eax
  char *v1; // edi
  _BYTE *v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // ebx
  _DWORD *v6; // eax
  int v7; // edx
  int v8; // edx
  char *v9; // eax
  _BYTE *v10; // ecx
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  const char *v14; // esi
  int v15; // edx
  int v16; // edx
  char *v17; // eax
  char *v18; // eax
  int v19; // [esp+24h] [ebp-1424h]
  int *v20; // [esp+2Ch] [ebp-141Ch]
  int v21; // [esp+30h] [ebp-1418h]
  int v22; // [esp+34h] [ebp-1414h]
  int v23; // [esp+38h] [ebp-1410h]
  int v24; // [esp+3Ch] [ebp-140Ch]
  char *v25; // [esp+40h] [ebp-1408h] BYREF
  int v26; // [esp+44h] [ebp-1404h] BYREF
  char v27[1024]; // [esp+48h] [ebp-1400h] BYREF
  char src[4096]; // [esp+448h] [ebp-1000h] BYREF

  v22 = 0;
  _bzero(&g_scr_data[9], 0x180u);
  result = trap_FS_GetFileList((int)"maps/mp/gametypes", (int)"gsc", (int)src);
  v21 = result;
  v1 = src;
  v24 = 0;
  if ( result > 0 )
  {
    while ( 1 )
    {
      v20 = &g_scr_data[3 * v22 + 9];
      v2 = v1;
      v3 = (unsigned __int8)v1 & 3;
      if ( ((unsigned __int8)v1 & 3) == 0 )
        goto LABEL_11;
      if ( __SETP__((unsigned __int8)v1 & 3, 0) )
        goto LABEL_9;
      if ( v3 != 2 )
      {
        if ( *v1 == BYTE1(v3) )
          goto LABEL_18;
        v2 = v1 + 1;
      }
      if ( *v2 != BYTE1(v3) )
        break;
LABEL_18:
      v5 = v2 - v1;
      if ( *v1 != 95 )
      {
        if ( !Q_stricmp(&v1[v5 - 4], ".gsc") )
          v1[v5 - 4] = 0;
        if ( v22 == 32 )
        {
          result = G_Printf("Too many game type scripts found! Only loading the first %i\n", 31);
          goto LABEL_72;
        }
        v6 = v1;
        v7 = (unsigned __int8)v1 & 3;
        if ( ((unsigned __int8)v1 & 3) == 0 )
          goto LABEL_33;
        if ( __SETP__((unsigned __int8)v1 & 3, 0) )
        {
LABEL_31:
          if ( *(_BYTE *)v6 != BYTE1(v7) )
          {
            v6 = (_DWORD *)((char *)v6 + 1);
LABEL_33:
            while ( 1 )
            {
              v8 = *v6;
              if ( !(unsigned __int8)*v6 )
                break;
              if ( !BYTE1(v8) )
                goto LABEL_39;
              if ( (v8 & 0xFF0000) == 0 )
                goto LABEL_38;
              ++v6;
              if ( (v8 & 0xFF000000) == 0 )
              {
                v6 = (_DWORD *)((char *)v6 - 3);
LABEL_38:
                v6 = (_DWORD *)((char *)v6 + 1);
LABEL_39:
                v6 = (_DWORD *)((char *)v6 + 1);
                break;
              }
            }
          }
        }
        else
        {
          if ( v7 == 2 )
            goto LABEL_29;
          if ( *v1 != BYTE1(v7) )
          {
            v6 = v1 + 1;
LABEL_29:
            if ( *(_BYTE *)v6 != BYTE1(v7) )
            {
              v6 = (_DWORD *)((char *)v6 + 1);
              goto LABEL_31;
            }
          }
        }
        v9 = (char *)trap_Hunk_AllocLowInternal((char *)v6 - v1);
        g_scr_data[3 * v22 + 9] = (int)v9;
        strcpy(v9, v1);
        v10 = (_BYTE *)g_scr_data[3 * v22 + 9];
        v19 = v24 + 1;
        if ( v10 && *v10 )
        {
          do
          {
            *v10 = *(_DWORD *)(_ctype_tolower + 4 * (char)*v10);
            ++v10;
          }
          while ( *v10 );
        }
        v11 = va("maps/mp/gametypes/%s.txt", v1);
        v23 = trap_FS_FOpenFile((int)v11, (int)&v26, 0);
        if ( (unsigned int)(v23 - 1) > 0x3FE )
        {
          v12 = va("maps/mp/gametypes/%s.txt", v1);
          if ( v23 > 0 )
            Com_Printf("WARNING: GameType description file %s is too big to load.\n", v12);
          else
            Com_Printf("WARNING: Could not load GameType description file %s for gametype %s\n", v12, v1);
          v20[2] = 0;
          v20[1] = *v20;
          goto LABEL_68;
        }
        _bzero(v27, 0x400u);
        trap_FS_Read((int)v27, v23, v26);
        v25 = v27;
        v13 = Com_Parse(&v25);
        v14 = v13;
        v15 = (unsigned __int8)v13 & 3;
        if ( ((unsigned __int8)v13 & 3) == 0 )
          goto LABEL_57;
        if ( __SETP__((unsigned __int8)v13 & 3, 0) )
        {
LABEL_55:
          if ( *v13 != BYTE1(v15) )
          {
            ++v13;
LABEL_57:
            while ( 1 )
            {
              v16 = *(_DWORD *)v13;
              if ( !(unsigned __int8)*(_DWORD *)v13 )
                break;
              if ( !BYTE1(v16) )
                goto LABEL_63;
              if ( (v16 & 0xFF0000) == 0 )
                goto LABEL_62;
              v13 += 4;
              if ( (v16 & 0xFF000000) == 0 )
              {
                v13 -= 3;
LABEL_62:
                ++v13;
LABEL_63:
                ++v13;
                break;
              }
            }
          }
        }
        else
        {
          if ( v15 == 2 )
            goto LABEL_53;
          if ( *v13 != BYTE1(v15) )
          {
            ++v13;
LABEL_53:
            if ( *v13 != BYTE1(v15) )
            {
              ++v13;
              goto LABEL_55;
            }
          }
        }
        v17 = (char *)trap_Hunk_AllocLowInternal(v13 - v14);
        v20[1] = (int)v17;
        strcpy(v17, v14);
        v18 = Com_Parse(&v25);
        v20[2] = v18 && !Q_stricmp(v18, "team");
LABEL_68:
        if ( v23 > 0 )
          trap_FS_FCloseFile(v26);
        ++v22;
        v1 += v5 + 1;
        goto LABEL_71;
      }
      v1 += v5 + 1;
      v19 = v24 + 1;
LABEL_71:
      result = v21;
      v24 = v19;
      if ( v19 >= v21 )
        goto LABEL_72;
    }
    ++v2;
LABEL_9:
    if ( *v2 != BYTE1(v3) )
    {
      ++v2;
LABEL_11:
      while ( 1 )
      {
        v4 = *(_DWORD *)v2;
        if ( !(unsigned __int8)*(_DWORD *)v2 )
          break;
        if ( !BYTE1(v4) )
          goto LABEL_17;
        if ( (v4 & 0xFF0000) == 0 )
          goto LABEL_16;
        v2 += 4;
        if ( (v4 & 0xFF000000) == 0 )
        {
          v2 -= 3;
LABEL_16:
          ++v2;
LABEL_17:
          ++v2;
          goto LABEL_18;
        }
      }
    }
    goto LABEL_18;
  }
LABEL_72:
  g_scr_data[8] = v22;
  return result;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (0005C5E0) --------------------------------------------------------
int Scr_LoadLevel()
{
  int result; // eax
  unsigned __int16 v1; // ax

  result = g_scr_data[0];
  if ( g_scr_data[0] )
  {
    v1 = Scr_ExecThread(g_scr_data[0], 0);
    result = Scr_FreeThread(v1);
  }
  return result;
}

//----- (0005C60C) --------------------------------------------------------
int GScr_FreeScripts()
{
  return Scr_RemoveClassMap();
}

//----- (0005C61C) --------------------------------------------------------
int __cdecl Scr_SetOrigin(int a1)
{
  int result; // eax
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  result = G_SetOrigin(a1, v2);
  if ( *(_DWORD *)(a1 + 240) )
    result = trap_LinkEntity(a1);
  return result;
}

//----- (0005C660) --------------------------------------------------------
int __cdecl Scr_SetAngles(int a1)
{
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  return G_SetAngle(a1, v2);
}

//----- (0005C68C) --------------------------------------------------------
int __cdecl Scr_SetHealth(_DWORD *a1)
{
  int result; // eax
  int v2; // edx

  result = Scr_GetInt(0);
  v2 = a1[86];
  if ( v2 )
  {
    a1[140] = result;
    *(_DWORD *)(v2 + 244) = result;
  }
  else
  {
    a1[141] = result;
    a1[140] = result;
  }
  return result;
}

//----- (0005C6CC) --------------------------------------------------------
int __cdecl GScr_AllocString(int a1)
{
  return (unsigned __int16)Scr_AllocString(a1, 1);
}

//----- (0005C6E8) --------------------------------------------------------
int __cdecl GScr_AddEntity(int *a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddEntity(a1);
  else
    result = Scr_AddUndefined();
  return result;
}

//----- (0005C70C) --------------------------------------------------------
_DWORD *G_InitObjectives()
{
  int *v0; // esi
  int i; // ebx
  _DWORD *result; // eax

  v0 = &level[8];
  for ( i = 15; i >= 0; --i )
  {
    result = sub_5DFCC(v0);
    v0 += 7;
  }
  return result;
}

//----- (0005C73C) --------------------------------------------------------
int __cdecl GScr_GetScriptMenuIndex(char *a1)
{
  int v1; // ebx
  char *v2; // eax
  char v4[1024]; // [esp+18h] [ebp-400h] BYREF

  v1 = 0;
  while ( 1 )
  {
    trap_GetConfigstring(v1 + 1180, (int)v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      break;
    if ( ++v1 > 31 )
    {
      v2 = va("Menu '%s' was not precached\n", a1);
      Scr_Error((int)v2);
      return 0;
    }
  }
  return v1;
}

//----- (0005C7B0) --------------------------------------------------------
int __cdecl Scr_LocalizationError(int a1, char *format)
{
  return Com_Error(7, format);
}

//----- (0005C7C8) --------------------------------------------------------
int __cdecl GScr_GetStatusIconIndex(char *a1)
{
  int v2; // ebx
  char *v3; // eax
  char v4[1024]; // [esp+18h] [ebp-400h] BYREF

  if ( !*a1 )
    return 0;
  v2 = 0;
  while ( 1 )
  {
    trap_GetConfigstring(v2 + 21, (int)v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      break;
    if ( ++v2 > 7 )
    {
      v3 = va("Status icon '%s' was not precached\n", a1);
      Scr_Error((int)v3);
      return 0;
    }
  }
  return v2 + 1;
}

//----- (0005C840) --------------------------------------------------------
int __cdecl GScr_GetHeadIconIndex(char *a1)
{
  int v2; // ebx
  char *v3; // eax
  char v4[1024]; // [esp+18h] [ebp-400h] BYREF

  if ( !*a1 )
    return 0;
  v2 = 0;
  while ( 1 )
  {
    trap_GetConfigstring(v2 + 29, (int)v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      break;
    if ( ++v2 > 14 )
    {
      v3 = va("Head icon '%s' was not precached\n", a1);
      Scr_Error((int)v3);
      return 0;
    }
  }
  return v2 + 1;
}

//----- (0005C8B4) --------------------------------------------------------
int __cdecl Scr_GetGameTypeNameForScript(char *a1)
{
  int v1; // esi
  int *i; // ebx

  v1 = 0;
  if ( g_scr_data[8] <= 0 )
    return 0;
  for ( i = &g_scr_data[10]; Q_stricmp((char *)*(i - 1), a1); i += 3 )
  {
    if ( ++v1 >= g_scr_data[8] )
      return 0;
  }
  return *i;
}

//----- (0005C900) --------------------------------------------------------
_BOOL4 __cdecl Scr_IsValidGameType(char *a1)
{
  int v1; // esi
  char **v2; // edi
  int v3; // eax
  int v5; // [esp+14h] [ebp-4h]

  v1 = 0;
  if ( g_scr_data[8] <= 0 )
  {
LABEL_5:
    v3 = 0;
  }
  else
  {
    v2 = (char **)&g_scr_data[9];
    v5 = 0;
    while ( Q_stricmp(*v2, a1) )
    {
      v2 += 3;
      v5 += 3;
      if ( ++v1 >= g_scr_data[8] )
        goto LABEL_5;
    }
    v3 = g_scr_data[v5 + 10];
  }
  return v3 != 0;
}

//----- (0005C970) --------------------------------------------------------
int Scr_LoadGameType()
{
  unsigned __int16 v0; // ax

  v0 = Scr_ExecThread(g_scr_data[2], 0);
  return Scr_FreeThread(v0);
}

//----- (0005C998) --------------------------------------------------------
int Scr_StartupGameType()
{
  unsigned __int16 v0; // ax

  v0 = Scr_ExecThread(g_scr_data[3], 0);
  return Scr_FreeThread(v0);
}

//----- (0005C9C0) --------------------------------------------------------
int __cdecl Scr_PlayerConnect(int *a1)
{
  unsigned __int16 v1; // ax

  v1 = Scr_ExecEntThread(a1, g_scr_data[4], 0);
  return Scr_FreeThread(v1);
}

//----- (0005C9EC) --------------------------------------------------------
int __cdecl Scr_PlayerDisconnect(int *a1)
{
  unsigned __int16 v1; // ax

  v1 = Scr_ExecEntThread(a1, g_scr_data[5], 0);
  return Scr_FreeThread(v1);
}

//----- (0005CA18) --------------------------------------------------------
int __cdecl Scr_PlayerDamage(int *a1, int *a2, int *a3, int a4, int a5, unsigned int a6, int a7, int a8, int a9, int a10)
{
  unsigned __int16 v10; // ax
  int v11; // eax
  unsigned __int16 v12; // ax

  v10 = G_GetHitLocationString(a10);
  Scr_AddConstString(v10);
  if ( a9 )
    Scr_AddVector(a9);
  else
    Scr_AddUndefined();
  if ( a8 )
    Scr_AddVector(a8);
  else
    Scr_AddUndefined();
  v11 = BG_GetInfoForWeapon(a7);
  Scr_AddString(*(_DWORD *)(v11 + 4));
  if ( a6 <= 0x18 )
    Scr_AddString((int)modNames[a6]);
  else
    Scr_AddString((int)"badMOD");
  Scr_AddInt(a5);
  Scr_AddInt(a4);
  if ( a3 )
    Scr_AddEntity(a3);
  else
    Scr_AddUndefined();
  if ( a2 )
    Scr_AddEntity(a2);
  else
    Scr_AddUndefined();
  v12 = Scr_ExecEntThread(a1, g_scr_data[6], 9);
  return Scr_FreeThread(v12);
}
// 7DDA0: using guessed type char *modNames[34];

//----- (0005CB30) --------------------------------------------------------
int __cdecl Scr_PlayerKilled(int *a1, int *a2, int *a3, int a4, unsigned int a5, int a6, int a7, int a8)
{
  unsigned __int16 v8; // ax
  int v9; // eax
  unsigned __int16 v10; // ax

  v8 = G_GetHitLocationString(a8);
  Scr_AddConstString(v8);
  if ( a7 )
    Scr_AddVector(a7);
  else
    Scr_AddUndefined();
  v9 = BG_GetInfoForWeapon(a6);
  Scr_AddString(*(_DWORD *)(v9 + 4));
  if ( a5 <= 0x18 )
    Scr_AddString((int)modNames[a5]);
  else
    Scr_AddString((int)"badMOD");
  Scr_AddInt(a4);
  if ( a3 )
    Scr_AddEntity(a3);
  else
    Scr_AddUndefined();
  if ( a2 )
    Scr_AddEntity(a2);
  else
    Scr_AddUndefined();
  v10 = Scr_ExecEntThread(a1, g_scr_data[7], 7);
  return Scr_FreeThread(v10);
}
// 7DDA0: using guessed type char *modNames[34];

//----- (0005CC20) --------------------------------------------------------
int __cdecl sub_5CC20(int a1)
{
  return trap_Hunk_AllocLowInternal(a1);
}

//----- (0005CC38) --------------------------------------------------------
void sub_5CC38()
{
  int v0; // esi
  int i; // ebx
  const char *v2; // eax

  if ( !g_NoScriptSpam[3] )
  {
    v0 = Scr_GetNumParam();
    for ( i = 0; i < v0; ++i )
    {
      v2 = (const char *)Scr_GetDebugString(i);
      Com_Printf("%s", v2);
    }
  }
}

//----- (0005CC80) --------------------------------------------------------
void sub_5CC80()
{
  int v0; // esi
  int i; // ebx
  const char *v2; // eax

  if ( !g_NoScriptSpam[3] )
  {
    v0 = Scr_GetNumParam();
    for ( i = 0; i < v0; ++i )
    {
      v2 = (const char *)Scr_GetDebugString(i);
      Com_Printf("%s", v2);
    }
    Com_Printf("\n");
  }
}

//----- (0005CCD8) --------------------------------------------------------
int __cdecl Scr_MakeGameMessage(int a1, const char *a2)
{
  char *v2; // eax
  char v4[1024]; // [esp+18h] [ebp-400h] BYREF

  Scr_ConstructMessageString(0, v4, 1024, 0);
  v2 = va("%s \"%s\"", a2, v4);
  return trap_SendServerCommand(a1, 0, (int)v2);
}

//----- (0005CD28) --------------------------------------------------------
int sub_5CD28()
{
  char *v0; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  Scr_ConstructMessageString(0, v2, 1024, 0);
  v0 = va("%s \"%s\"", (const char *)L"fg", v2);
  return trap_SendServerCommand(-1, 0, (int)v0);
}
// 7694C: using guessed type __int16 aFg[3];

//----- (0005CD74) --------------------------------------------------------
int sub_5CD74()
{
  char *v0; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  Scr_ConstructMessageString(0, v2, 1024, 0);
  v0 = va("%s \"%s\"", (const char *)L"g", v2);
  return trap_SendServerCommand(-1, 0, (int)v0);
}
// 7694C: using guessed type __int16 aFg[3];

//----- (0005CDC0) --------------------------------------------------------
int sub_5CDC0()
{
  unsigned int v0; // eax
  float v2; // [esp+1Ch] [ebp-2Ch]
  float v3[3]; // [esp+20h] [ebp-28h] BYREF
  float v4; // [esp+2Ch] [ebp-1Ch] BYREF
  float v5; // [esp+30h] [ebp-18h]
  float v6; // [esp+34h] [ebp-14h]
  float v7; // [esp+38h] [ebp-10h]
  char v8[12]; // [esp+3Ch] [ebp-Ch] BYREF

  v2 = 1.0;
  v4 = 1.0;
  v5 = 1.0;
  v6 = 1.0;
  v7 = 1.0;
  v0 = Scr_GetNumParam();
  if ( v0 == 3 )
    goto LABEL_8;
  if ( v0 > 3 )
  {
    if ( v0 == 4 )
    {
LABEL_7:
      v7 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, (int)v3);
      v4 = v3[0];
      v5 = v3[1];
      v6 = v3[2];
      goto LABEL_9;
    }
LABEL_6:
    v2 = Scr_GetFloat(4);
    goto LABEL_7;
  }
  if ( v0 != 2 )
    goto LABEL_6;
LABEL_9:
  Scr_GetString(1);
  Scr_GetVector(0, (int)v8);
  return trap_AddDebugString((int)v8, (int)&v4, SLODWORD(v2));
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005CE70) --------------------------------------------------------
int sub_5CE70()
{
  unsigned int v0; // eax
  float v2[3]; // [esp+14h] [ebp-34h] BYREF
  float v3; // [esp+20h] [ebp-28h] BYREF
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+28h] [ebp-20h]
  float v6; // [esp+2Ch] [ebp-1Ch]
  char v7[12]; // [esp+30h] [ebp-18h] BYREF
  char v8[12]; // [esp+3Ch] [ebp-Ch] BYREF

  v3 = 1.0;
  v4 = 1.0;
  v5 = 1.0;
  v6 = 1.0;
  v0 = Scr_GetNumParam();
  if ( v0 == 3 )
    goto LABEL_8;
  if ( v0 > 3 )
  {
    if ( v0 == 4 )
    {
LABEL_7:
      v6 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, (int)v2);
      v3 = v2[0];
      v4 = v2[1];
      v5 = v2[2];
      goto LABEL_9;
    }
LABEL_6:
    Scr_GetInt(4);
    goto LABEL_7;
  }
  if ( v0 != 2 )
    goto LABEL_6;
LABEL_9:
  Scr_GetVector(1, (int)v7);
  Scr_GetVector(0, (int)v8);
  return trap_AddDebugLine((int)v8, (int)v7, (int)&v3);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005CF34) --------------------------------------------------------
void sub_5CF34()
{
  ;
}

//----- (0005CF3C) --------------------------------------------------------
int sub_5CF3C()
{
  int v0; // eax
  int v1; // eax

  v0 = Scr_GetType(0);
  if ( v0 != 7 )
    return Scr_AddInt(v0 != 0);
  v1 = Scr_GetPointerType(0);
  return Scr_AddInt(v1 <= 15);
}

//----- (0005CF8C) --------------------------------------------------------
int sub_5CF8C()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && Scr_GetEntity(0)[140] > 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (0005CFF4) --------------------------------------------------------
int sub_5CFF4()
{
  int v0; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  v0 = Scr_GetString(0);
  trap_Cvar_VariableStringBuffer(v0, (int)v2, 1024);
  return Scr_AddString((int)v2);
}

//----- (0005D034) --------------------------------------------------------
int sub_5D034()
{
  int v0; // eax
  int v1; // eax

  v0 = Scr_GetString(0);
  v1 = trap_Cvar_VariableIntegerValue(v0);
  return Scr_AddInt(v1);
}

//----- (0005D05C) --------------------------------------------------------
int sub_5D05C()
{
  int v0; // eax
  float v2; // [esp-30h] [ebp-38h]

  v0 = Scr_GetString(0);
  v2 = trap_Cvar_VariableValue(v0);
  return Scr_AddFloat(v2);
}

//----- (0005D088) --------------------------------------------------------
int sub_5D088()
{
  return Scr_AddInt(level[122]);
}

//----- (0005D0A0) --------------------------------------------------------
unsigned int sub_5D0A0()
{
  unsigned int result; // eax

  result = Scr_GetInt(0);
  if ( result <= 0x3FF )
  {
    result = (unsigned int)&g_entities[197 * result];
    if ( *(_BYTE *)(result + 352) )
      result = Scr_AddEntity((int *)result);
  }
  return result;
}

//----- (0005D0DC) --------------------------------------------------------
int sub_5D0DC()
{
  char *v0; // ebx
  unsigned __int8 v1; // al
  char *v2; // eax
  int result; // eax
  int v4; // eax

  v0 = (char *)Scr_GetString(0);
  v1 = BG_GetWeaponIndexForName(v0);
  if ( v1 )
  {
    v4 = BG_GetInfoForWeapon(v1);
    result = Scr_AddString(*(_DWORD *)(v4 + 392));
  }
  else
  {
    if ( *v0 )
    {
      if ( Q_stricmp(v0, "none") )
      {
        v2 = va("unknown weapon '%s' in getWeaponModel\n", v0);
        Com_Printf(v2);
      }
    }
    result = Scr_AddString((int)&unk_76629);
  }
  return result;
}

//----- (0005D164) --------------------------------------------------------
int sub_5D164()
{
  unsigned int v0; // ebx
  float v2; // [esp-20h] [ebp-38h]
  unsigned int v3; // [esp+14h] [ebp-4h] BYREF

  Scr_GetAnim(&v3, 0, 0);
  v0 = v3;
  if ( !trap_XAnimIsPrimitive(v3) )
    Scr_ParamError(0, (int)"non-primitive animation has no concept of length");
  v2 = trap_XAnimGetLengthSeconds(v0);
  return Scr_AddFloat(v2);
}

//----- (0005D1BC) --------------------------------------------------------
int sub_5D1BC()
{
  unsigned int v0; // ebx
  unsigned __int16 v1; // ax
  int v2; // eax
  unsigned int v4; // [esp+14h] [ebp-4h] BYREF

  Scr_GetAnim(&v4, 0, 0);
  v0 = v4;
  v1 = Scr_GetConstString(1);
  v2 = trap_XAnimNotetrackExists(v0, v1);
  return Scr_AddBool(v2);
}

//----- (0005D1FC) --------------------------------------------------------
int sub_5D1FC()
{
  float *v0; // eax
  long double v1; // fst7
  long double v2; // fst5
  long double v3; // fst4
  float v5; // [esp+Ch] [ebp-Ch] BYREF
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v0 = (float *)Scr_GetEntity(0);
  v1 = v0[71] + v0[74];
  v5 = v1;
  v2 = v0[72] + v0[75];
  v6 = v2;
  v3 = v0[73] + v0[76];
  v5 = v1 * 0.5;
  v6 = v2 * 0.5;
  v7 = 0.5 * v3;
  return Scr_AddVector((int)&v5);
}

//----- (0005D268) --------------------------------------------------------
int sub_5D268()
{
  unsigned __int16 v0; // di
  int v1; // esi
  int v2; // ebx
  const char *v4; // eax
  char *v5; // eax
  float v6[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v0 = Scr_GetConstString(0);
  Scr_GetVector(1, (int)v6);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v1 = 0;
  else
    v1 = Scr_GetInt(2);
  v2 = G_Spawn();
  Scr_SetString(v2 + 374, v0);
  *(float *)(v2 + 308) = v6[0];
  *(float *)(v2 + 312) = v6[1];
  *(float *)(v2 + 316) = v6[2];
  *(_DWORD *)(v2 + 376) = v1;
  if ( G_CallSpawnEntity(v2) )
    return Scr_AddEntity((int *)v2);
  v4 = (const char *)SL_ConvertToString(v0);
  v5 = va("unable to spawn \"%s\" entity", v4);
  return Scr_Error((int)v5);
}
// 617D4: using guessed type _DWORD __cdecl G_CallSpawnEntity(_DWORD);

//----- (0005D334) --------------------------------------------------------
int __cdecl sub_5D334(unsigned int a1)
{
  int *v1; // edi
  char *v2; // esi
  const char *v3; // ebx
  char *v4; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v3 = (const char *)&unk_76629;
  else
    v3 = (const char *)Scr_GetString(1);
  if ( G_EntDetach((int)v1, v2, (int)v3) )
  {
    v4 = va("model '%s' already attached to tag '%s'", v2, v3);
    Scr_Error((int)v4);
  }
  result = G_EntAttach((int)v1, v2, (int)v3);
  if ( !result )
    result = Scr_Error((int)"maximum attached models exceeded");
  return result;
}

//----- (0005D3EC) --------------------------------------------------------
int __cdecl sub_5D3EC(unsigned int a1)
{
  int *v1; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  return G_EntDetachAll((int)v1);
}

//----- (0005D430) --------------------------------------------------------
int __cdecl sub_5D430(unsigned int a1)
{
  int *v1; // eax
  int v2; // edx
  int *v3; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = 0;
  if ( *((_BYTE *)v1 + 748) )
  {
    v3 = v1 + 187;
    do
      ++v2;
    while ( v2 <= 5 && *((_BYTE *)v3 + v2) );
  }
  return Scr_AddInt(v2);
}

//----- (0005D48C) --------------------------------------------------------
int __cdecl sub_5D48C(unsigned int a1)
{
  int *v1; // esi
  unsigned int v2; // eax
  unsigned int v3; // ebx
  int *v4; // esi
  int v5; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = Scr_GetInt(0);
  v3 = v2;
  v4 = v1 + 187;
  if ( v2 > 5 || !*((_BYTE *)v4 + v2) )
    Scr_ParamError(0, (int)"bad index");
  v5 = G_ModelName(*((unsigned __int8 *)v4 + v3));
  return Scr_AddString(v5);
}

//----- (0005D514) --------------------------------------------------------
int __cdecl sub_5D514(unsigned int a1)
{
  int *v1; // esi
  unsigned int v2; // eax
  unsigned int v3; // ebx

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = Scr_GetInt(0);
  v3 = v2;
  if ( v2 > 5 || !*((_BYTE *)v1 + v2 + 748) )
    Scr_ParamError(0, (int)"bad index");
  return Scr_AddConstString(*((_WORD *)v1 + v3 + 377));
}

//----- (0005D594) --------------------------------------------------------
void __cdecl sub_5D594(unsigned int a1)
{
  int *v1; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  G_EntUnlink((int)v1);
}

//----- (0005D5D0) --------------------------------------------------------
int __cdecl sub_5D5D0(unsigned int a1)
{
  int *v1; // ebx
  const char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( (*((_BYTE *)v1 + 381) & 0x20) != 0 )
    Scr_ObjectError((int)"entity already has linkTo enabled");
  if ( v1[1]
    || *((_BYTE *)v1 + 353)
    || (v1[127] || v1[128])
    && (v2 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 187)), strcasecmp(v2, "trigger_multiple")) )
  {
    v3 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 187));
    v4 = va("entity (classname: '%s') does not currently support enableLinkTo", v3);
    Scr_ObjectError((int)v4);
  }
  result = level[122];
  v1[127] = result;
  v1[128] = (int)Think_GeneralLink;
  *((_BYTE *)v1 + 381) |= 0x20u;
  return result;
}

//----- (0005D6B0) --------------------------------------------------------
int __cdecl sub_5D6B0(unsigned int a1)
{
  float *v1; // eax
  float v3[3]; // [esp+Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = (float *)&g_entities[197 * a1];
  }
  v3[0] = v1[77];
  v3[1] = v1[78];
  v3[2] = v1[79];
  return Scr_AddVector((int)v3);
}

//----- (0005D710) --------------------------------------------------------
int __cdecl sub_5D710(unsigned int a1)
{
  float *v1; // eax
  float v3[3]; // [esp+Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = (float *)&g_entities[197 * a1];
  }
  v3[0] = v1[77];
  v3[1] = v1[78];
  v3[2] = v1[79] + 40.0;
  return Scr_AddVector((int)v3);
}

//----- (0005D774) --------------------------------------------------------
int __cdecl sub_5D774(unsigned int a1)
{
  int *v1; // ebx
  int *v2; // esi
  int result; // eax
  int v4; // [esp-4h] [ebp-1Ch]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = Scr_GetEntity(0);
  Scr_AddEntity(v2);
  result = Scr_Notify(v1, scr_const[73], 1);
  if ( v1[132] )
    result = ((int (__stdcall *)(int *, int *, int *, int))v1[132])(v1, v2, v2, v4);
  return result;
}
// 5D7E9: variable 'v4' is possibly undefined

//----- (0005D7F4) --------------------------------------------------------
int *__cdecl sub_5D7F4(unsigned int a1)
{
  int *result; // eax
  __int16 v2; // dx

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  v2 = *((_WORD *)result + 187);
  if ( v2 == scr_const[27] || v2 == scr_const[26] )
    result[170] = 1;
  return result;
}

//----- (0005D848) --------------------------------------------------------
int *__cdecl sub_5D848(unsigned int a1)
{
  int *result; // eax
  __int16 v2; // dx

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  v2 = *((_WORD *)result + 187);
  if ( v2 == scr_const[27] || v2 == scr_const[26] )
    result[170] = 0;
  return result;
}

//----- (0005D89C) --------------------------------------------------------
int __cdecl sub_5D89C(unsigned int a1)
{
  int *v1; // eax
  __int16 v2; // dx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = *((_WORD *)v1 + 187);
  if ( (v2 == scr_const[27] || v2 == scr_const[26]) && v1[170] )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (0005D910) --------------------------------------------------------
int __cdecl sub_5D910(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  unsigned __int8 v3; // dl
  int v4; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = (char *)Scr_GetString(0);
  v3 = G_SoundAliasIndex(v2);
  v4 = v1[61];
  LOBYTE(v4) = v4 & 0xFE | 8;
  v1[61] = v4;
  return G_PlaySoundAlias(v1, v3);
}

//----- (0005D980) --------------------------------------------------------
int __cdecl sub_5D980(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = (char *)Scr_GetString(0);
  result = (unsigned __int8)G_SoundAliasIndex(v2);
  v1[33] = (unsigned __int8)result;
  return result;
}

//----- (0005D9D8) --------------------------------------------------------
int *__cdecl sub_5D9D8(unsigned int a1)
{
  int *result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  result[33] = 0;
  return result;
}

//----- (0005DA14) --------------------------------------------------------
int __cdecl sub_5DA14(unsigned int a1)
{
  int *v1; // ebx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( v1[86] )
    Scr_Error((int)"Cannot delete a client entity");
  Scr_AddEntity(v1);
  Scr_Notify(v1, scr_const[14], 1);
  trap_UnlinkEntity((int)v1);
  v1[132] = 0;
  v1[131] = 0;
  v1[128] = (int)G_FreeEntity;
  result = level[122] + 100;
  v1[127] = result;
  return result;
}

//----- (0005DABC) --------------------------------------------------------
int __cdecl sub_5DABC(unsigned int a1)
{
  int *v1; // ebx
  char *v2; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = (char *)Scr_GetString(0);
  G_SetModel((int)v1, v2);
  G_DObjUpdate((int)v1);
  return trap_LinkEntity((int)v1);
}

//----- (0005DB24) --------------------------------------------------------
int __cdecl sub_5DB24(unsigned int a1)
{
  int *v1; // eax
  int v2; // edx
  int result; // eax
  float v4; // [esp-10h] [ebp-28h]
  float v5; // [esp-10h] [ebp-28h]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( v1[86] )
  {
    v2 = v1[140];
    if ( v2 )
    {
      v4 = (long double)v2 / (long double)*(int *)(v1[86] + 8528);
      result = Scr_AddFloat(v4);
    }
    else
    {
      result = Scr_AddFloat(0.0);
    }
  }
  else
  {
    v5 = (float)v1[140];
    result = Scr_AddFloat(v5);
  }
  return result;
}

//----- (0005DBC0) --------------------------------------------------------
int __cdecl sub_5DBC0(unsigned int a1)
{
  int *v1; // ebx
  long double v2; // fst7
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7; // eax
  long double v8; // fst6
  int v9; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = Scr_GetFloat(0);
  v4 = v2 > 1.0;
  v5 = 0;
  v6 = 1.0 == v2;
  if ( (v3 & 0x45) == 1 )
    v2 = 1.0;
  v7 = v1[86];
  if ( v7 )
  {
    v8 = (long double)*(int *)(v7 + 8528);
  }
  else
  {
    v9 = v1[141];
    if ( !v9 )
      goto LABEL_11;
    v8 = (long double)v9;
  }
  v2 = v2 * v8;
LABEL_11:
  result = (int)v2;
  if ( (int)v2 <= 0 )
    return Com_Printf("ERROR: Cannot setnormalhealth to 0 or below.\n");
  v1[140] = result;
  return result;
}
// 5DC05: variable 'v3' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005DC74) --------------------------------------------------------
int *__cdecl ScrCmd_Show(unsigned int a1)
{
  int *result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  *((_BYTE *)result + 381) &= 0xEFu;
  return result;
}

//----- (0005DCAC) --------------------------------------------------------
int *__cdecl ScrCmd_Hide(unsigned int a1)
{
  int *result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  *((_BYTE *)result + 381) |= 0x10u;
  return result;
}

//----- (0005DCEC) --------------------------------------------------------
int __cdecl sub_5DCEC(unsigned int a1)
{
  int *v1; // ebx
  int v2; // esi

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  v2 = Scr_GetInt(0);
  Scr_AddInt(v1[70]);
  v1[70] = v2;
  return trap_LinkEntity((int)v1);
}

//----- (0005DD58) --------------------------------------------------------
int __cdecl sub_5DD58(unsigned int a1)
{
  int *v1; // esi
  char *v2; // eax
  int result; // eax
  char *v4; // eax
  int v5; // [esp+14h] [ebp-404h] BYREF
  char s1[1024]; // [esp+18h] [ebp-400h] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( *((_WORD *)v1 + 187) != scr_const[74] )
    Scr_Error((int)"The setHintString command only works on trigger_use entities.\n");
  if ( Scr_GetType(0) != 1 || (v2 = (char *)Scr_GetString(0), (result = Q_stricmp(v2, (char *)&unk_76629)) != 0) )
  {
    Scr_ConstructMessageString(0, s1, 1024, 2);
    if ( !G_GetHintStringIndex((int)&v5, s1) )
    {
      v4 = va("Too many different hintstring values. Max allowed is %i different strings", 32);
      Scr_Error((int)v4);
    }
    result = (unsigned __int8)v5;
    v1[54] = (unsigned __int8)v5;
  }
  else
  {
    v1[54] = 255;
  }
  return result;
}

//----- (0005DE50) --------------------------------------------------------
int __cdecl sub_5DE50(unsigned int a1)
{
  int *v1; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  return Scr_AddInt(*v1);
}

//----- (0005DE94) --------------------------------------------------------
int __cdecl GScr_EnableGrenadeTouchDamage(unsigned int a1)
{
  int *v1; // ebx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  result = (unsigned __int16)scr_const[75];
  if ( *((_WORD *)v1 + 187) != (_WORD)result )
    result = Scr_Error((int)"Currently on supported on damage triggers");
  *((_BYTE *)v1 + 381) |= 0x80u;
  return result;
}

//----- (0005DEF0) --------------------------------------------------------
int __cdecl GScr_DisableGrenadeTouchDamage(unsigned int a1)
{
  int *v1; // ebx
  int result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  result = (unsigned __int16)scr_const[75];
  if ( *((_WORD *)v1 + 187) != (_WORD)result )
    result = Scr_Error((int)"Currently on supported on damage triggers");
  *((_BYTE *)v1 + 381) &= 0x7Fu;
  return result;
}

//----- (0005DF50) --------------------------------------------------------
int *__cdecl GScr_EnableGrenadeBounce(unsigned int a1)
{
  int *result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  *((_BYTE *)result + 382) &= 0xFEu;
  return result;
}

//----- (0005DF8C) --------------------------------------------------------
int *__cdecl GScr_DisableGrenadeBounce(unsigned int a1)
{
  int *result; // eax

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    result = 0;
  }
  else
  {
    result = &g_entities[197 * a1];
  }
  *((_BYTE *)result + 382) |= 1u;
  return result;
}

//----- (0005DFCC) --------------------------------------------------------
_DWORD *__cdecl sub_5DFCC(_DWORD *a1)
{
  _DWORD *result; // eax

  result = a1;
  a1[3] = 0;
  a1[2] = 0;
  a1[1] = 0;
  *a1 = 0;
  a1[4] = 1023;
  a1[5] = 0;
  a1[6] = 0;
  return result;
}

//----- (0005E008) --------------------------------------------------------
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2)
{
  if ( a2 == scr_const[18] )
  {
    *a1 = 0;
  }
  else if ( a2 == scr_const[33] )
  {
    *a1 = 2;
  }
  else
  {
    if ( a2 != scr_const[10] )
    {
      *a1 = 0;
      return 0;
    }
    *a1 = 4;
  }
  return 1;
}

//----- (0005E058) --------------------------------------------------------
int sub_5E058()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int v3; // ecx
  int v4; // ecx
  int result; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = level[7 * v1 + 12];
  if ( v3 != 1023 )
  {
    v4 = 197 * v3;
    if ( LOBYTE(g_entities[v4 + 88]) )
      LOBYTE(g_entities[v4 + 61]) &= 0xEFu;
    level[7 * v1 + 12] = 1023;
  }
  result = 7 * v1;
  level[result + 11] = 0;
  level[result + 10] = 0;
  level[result + 9] = 0;
  level[result + 8] = 0;
  level[result + 12] = 1023;
  level[result + 13] = 0;
  level[result + 14] = 0;
  return result * 4;
}

//----- (0005E128) --------------------------------------------------------
int sub_5E128()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int v3; // eax
  int v4; // edx
  float *v5; // ebx
  int v6; // edx
  int result; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = 7 * v1;
  v4 = level[7 * v1 + 12];
  v5 = (float *)&level[7 * v1 + 8];
  if ( v4 != 1023 )
  {
    v6 = 197 * v4;
    if ( LOBYTE(g_entities[v6 + 88]) )
      LOBYTE(g_entities[v6 + 61]) &= 0xEFu;
    level[v3 + 12] = 1023;
  }
  Scr_GetVector(1, (int)(v5 + 1));
  v5[1] = (float)(int)v5[1];
  v5[2] = (float)(int)v5[2];
  result = (int)v5[3];
  v5[3] = (float)result;
  return result;
}

//----- (0005E230) --------------------------------------------------------
int sub_5E230()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int v3; // eax
  int v4; // edx
  int *v5; // ebx
  int v6; // edx
  int *v7; // eax
  int result; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = 7 * v1;
  v4 = level[7 * v1 + 12];
  v5 = &level[7 * v1 + 8];
  if ( v4 != 1023 )
  {
    v6 = 197 * v4;
    if ( LOBYTE(g_entities[v6 + 88]) )
      LOBYTE(g_entities[v6 + 61]) &= 0xEFu;
    level[v3 + 12] = 1023;
  }
  v7 = Scr_GetEntity(1);
  *((_BYTE *)v7 + 244) |= 0x10u;
  result = *v7;
  v5[4] = result;
  return result;
}

//----- (0005E2C8) --------------------------------------------------------
int sub_5E2C8()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  char *v2; // eax
  int v3; // ebx
  int result; // eax
  const char *v5; // eax
  char *v6; // eax

  v0 = Scr_GetInt(0);
  v1 = v0;
  if ( v0 > 0xF )
  {
    v2 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v0, 15);
    Scr_ParamError(0, (int)v2);
  }
  v3 = 7 * v1;
  result = Scr_GetConstString(1);
  if ( (_WORD)result == scr_const[2] )
  {
    level[v3 + 13] = 2;
  }
  else if ( (_WORD)result == scr_const[4] )
  {
    level[v3 + 13] = 1;
  }
  else if ( (_WORD)result == scr_const[124] )
  {
    level[v3 + 13] = 0;
  }
  else
  {
    v5 = (const char *)SL_ConvertToString(result);
    v6 = va("Illegal team string '%s'. Must be allies, axis, or none.", v5);
    result = Scr_ParamError(1, (int)v6);
  }
  return result;
}

//----- (0005E38C) --------------------------------------------------------
int sub_5E38C()
{
  int v0; // ebx
  int i; // esi
  int v2; // eax
  const char *v3; // ecx
  int v4; // edx
  int v5; // edx
  int v7; // [esp+14h] [ebp-404h]
  char dest[1024]; // [esp+18h] [ebp-400h] BYREF

  dest[0] = 0;
  v0 = 0;
  v7 = Scr_GetNumParam();
  for ( i = 0; i < v7; ++i )
  {
    v2 = Scr_GetString(i);
    v3 = (const char *)v2;
    v4 = v2 & 3;
    if ( (v2 & 3) == 0 )
      goto LABEL_12;
    if ( __SETP__(v2 & 3, 0) )
      goto LABEL_10;
    if ( v4 != 2 )
    {
      if ( *(_BYTE *)v2 == BYTE1(v4) )
        goto LABEL_19;
      ++v2;
    }
    if ( *(_BYTE *)v2 != BYTE1(v4) )
    {
      ++v2;
LABEL_10:
      if ( *(_BYTE *)v2 != BYTE1(v4) )
      {
        ++v2;
LABEL_12:
        while ( 1 )
        {
          v5 = *(_DWORD *)v2;
          if ( !(unsigned __int8)*(_DWORD *)v2 )
            break;
          if ( !BYTE1(v5) )
            goto LABEL_18;
          if ( (v5 & 0xFF0000) == 0 )
            goto LABEL_17;
          v2 += 4;
          if ( (v5 & 0xFF000000) == 0 )
          {
            v2 -= 3;
LABEL_17:
            ++v2;
LABEL_18:
            ++v2;
            break;
          }
        }
      }
    }
LABEL_19:
    v0 += v2 - (_DWORD)v3;
    if ( v0 > 1023 )
      return G_LogPrintf(dest);
    strcat(dest, v3);
  }
  return G_LogPrintf(dest);
}

//----- (0005E440) --------------------------------------------------------
int sub_5E440()
{
  return Scr_AddInt(1022);
}

//----- (0005E458) --------------------------------------------------------
int sub_5E458()
{
  return Scr_AddInt(level[125]);
}

//----- (0005E470) --------------------------------------------------------
int sub_5E470()
{
  int v0; // eax
  int result; // eax
  int v2; // eax

  v0 = Scr_GetInt(0);
  if ( v0 > 0 )
  {
    v2 = irand(0, v0);
    result = Scr_AddInt(v2);
  }
  else
  {
    Com_Printf("RandomInt parm: %d  ", v0);
    result = Scr_Error((int)"RandomInt parm must be positive integer.\n");
  }
  return result;
}

//----- (0005E4BC) --------------------------------------------------------
int sub_5E4BC()
{
  float v1; // [esp-30h] [ebp-38h]
  float v2; // [esp-28h] [ebp-30h]

  v2 = Scr_GetFloat(0);
  v1 = flrand(0.0, v2);
  return Scr_AddFloat(v1);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E4F0) --------------------------------------------------------
int sub_5E4F0()
{
  int v0; // esi
  int v1; // eax
  int v2; // ebx
  int v3; // eax

  v0 = Scr_GetInt(0);
  v1 = Scr_GetInt(1);
  v2 = v1;
  if ( v1 <= v0 )
  {
    Com_Printf("RandomIntRange parms: %d %d ", v0, v1);
    Scr_Error((int)"RandomIntRange range must be positive integer.\n");
  }
  v3 = irand(v0, v2);
  return Scr_AddInt(v3);
}

//----- (0005E554) --------------------------------------------------------
int sub_5E554()
{
  long double v0; // fst7
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  float v6; // [esp-20h] [ebp-48h]
  float v7; // [esp+10h] [ebp-18h]
  float v8; // [esp+14h] [ebp-14h]

  v8 = Scr_GetFloat(0);
  v0 = Scr_GetFloat(1);
  v2 = v0 < v8;
  v3 = 0;
  v4 = v0 == v8;
  if ( (unsigned __int8)((v1 & 0x45) - 1) < 0x40u )
  {
    Com_Printf(
      "Scr_RandomFloatRange parms: %d %d ",
      (unsigned int)COERCE_UNSIGNED_INT64(v8),
      (_DWORD)HIDWORD(COERCE_UNSIGNED_INT64(v8)));
    Scr_Error((int)"Scr_RandomFloatRange range must be positive float.\n");
  }
  v7 = v0;
  v6 = flrand(v8, v7);
  return Scr_AddFloat(v6);
}
// 5E57C: variable 'v1' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E5DC) --------------------------------------------------------
int sub_5E5DC()
{
  float v1; // [esp+14h] [ebp-4h]

  v1 = sin(Scr_GetFloat(0) * 3.141592653589793 / 180.0);
  return Scr_AddFloat(v1);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E618) --------------------------------------------------------
int sub_5E618()
{
  float v1; // [esp+14h] [ebp-4h]

  v1 = cos(Scr_GetFloat(0) * 3.141592653589793 / 180.0);
  return Scr_AddFloat(v1);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E654) --------------------------------------------------------
int sub_5E654()
{
  char v0; // fps^1
  bool v1; // c0
  char v2; // c2
  bool v3; // c3
  float v5; // [esp-10h] [ebp-48h]
  float v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+24h] [ebp-14h]

  v6 = Scr_GetFloat(0) * 3.141592653589793 / 180.0;
  v7 = cos(v6);
  v8 = sin(v6);
  v1 = v7 < 0.0;
  v2 = 0;
  v3 = v7 == 0.0;
  if ( (v0 & 0x44) == 0x40 )
    Scr_Error((int)"divide by 0");
  v5 = v8 / v7;
  return Scr_AddFloat(v5);
}
// 5E699: variable 'v0' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E6D0) --------------------------------------------------------
int sub_5E6D0()
{
  long double v0; // fst7
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  char *v9; // eax
  float v11; // [esp+14h] [ebp-34h]
  float v12; // [esp+44h] [ebp-4h]
  float v13; // [esp+44h] [ebp-4h]

  v0 = Scr_GetFloat(0);
  v11 = v0;
  v2 = v0 < -1.0;
  v3 = 0;
  v4 = v0 == -1.0;
  if ( (v1 & 0x45) == 1 || (v6 = v11 > 1.0, v7 = 0, v8 = 1.0 == v11, (v5 & 0x45) == 1) )
  {
    v9 = va("%g out of range", v11);
    Scr_Error((int)v9);
  }
  v12 = atan2(v11, sqrt(1.0 - v11 * v11));
  v13 = v12 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(v13);
}
// 5E6EE: variable 'v1' is possibly undefined
// 5E6FD: variable 'v5' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E768) --------------------------------------------------------
int sub_5E768()
{
  long double v0; // fst7
  char v1; // fps^1
  bool v2; // c0
  char v3; // c2
  bool v4; // c3
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  char *v9; // eax
  float v11; // [esp+14h] [ebp-34h]
  float v12; // [esp+44h] [ebp-4h]
  float v13; // [esp+44h] [ebp-4h]

  v0 = Scr_GetFloat(0);
  v11 = v0;
  v2 = v0 < -1.0;
  v3 = 0;
  v4 = v0 == -1.0;
  if ( (v1 & 0x45) == 1 || (v6 = v11 > 1.0, v7 = 0, v8 = 1.0 == v11, (v5 & 0x45) == 1) )
  {
    v9 = va("%g out of range", v11);
    Scr_Error((int)v9);
  }
  v12 = atan2(sqrt(1.0 - v11 * v11), v11);
  v13 = v12 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(v13);
}
// 5E786: variable 'v1' is possibly undefined
// 5E795: variable 'v5' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E804) --------------------------------------------------------
int sub_5E804()
{
  float v1; // [esp+14h] [ebp-4h]
  float v2; // [esp+14h] [ebp-4h]

  v1 = atan2(Scr_GetFloat(0), 1.0);
  v2 = v1 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(v2);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005E848) --------------------------------------------------------
int sub_5E848()
{
  float v1; // [esp-20h] [ebp-48h]
  float v2[3]; // [esp+10h] [ebp-18h] BYREF
  float v3[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v3);
  Scr_GetVector(1, (int)v2);
  v1 = VectorDistance(v3, v2);
  return Scr_AddFloat(v1);
}

//----- (0005E890) --------------------------------------------------------
int sub_5E890()
{
  float v1; // [esp-20h] [ebp-48h]
  float v2[3]; // [esp+10h] [ebp-18h] BYREF
  float v3[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v3);
  Scr_GetVector(1, (int)v2);
  v1 = VectorDistanceSquared(v3, v2);
  return Scr_AddFloat(v1);
}

//----- (0005E8D8) --------------------------------------------------------
int sub_5E8D8()
{
  float v1; // [esp+18h] [ebp-10h]
  float v2; // [esp+1Ch] [ebp-Ch] BYREF
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+24h] [ebp-4h]

  Scr_GetVector(0, (int)&v2);
  v1 = sqrt(v2 * v2 + v3 * v3 + v4 * v4);
  return Scr_AddFloat(v1);
}

//----- (0005E920) --------------------------------------------------------
int sub_5E920()
{
  float v1; // [esp-20h] [ebp-38h]
  float v2; // [esp+Ch] [ebp-Ch] BYREF
  float v3; // [esp+10h] [ebp-8h]
  float v4; // [esp+14h] [ebp-4h]

  Scr_GetVector(0, (int)&v2);
  v1 = v2 * v2 + v3 * v3 + v4 * v4;
  return Scr_AddFloat(v1);
}

//----- (0005E960) --------------------------------------------------------
int sub_5E960()
{
  long double v0; // fst7
  float v2; // [esp+20h] [ebp-28h]
  float v3[3]; // [esp+24h] [ebp-24h] BYREF
  float v4[3]; // [esp+30h] [ebp-18h] BYREF
  float v5[3]; // [esp+3Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v5);
  Scr_GetVector(1, (int)v4);
  Scr_GetVector(2, (int)v3);
  v2 = VectorDistanceSquared(v4, v5);
  v0 = VectorDistanceSquared(v3, v5);
  return Scr_AddInt(v0 > v2);
}

//----- (0005E9D4) --------------------------------------------------------
int sub_5E9D4()
{
  float v1; // [esp-10h] [ebp-38h]
  float v2[3]; // [esp+10h] [ebp-18h] BYREF
  float v3[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v3);
  Scr_GetVector(1, (int)v2);
  v1 = v3[0] * v2[0] + v3[1] * v2[1] + v3[2] * v2[2];
  return Scr_AddFloat(v1);
}

//----- (0005EA28) --------------------------------------------------------
int sub_5EA28()
{
  float v1[3]; // [esp+10h] [ebp-18h] BYREF
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  v1[0] = v2[0];
  v1[1] = v2[1];
  v1[2] = v2[2];
  VectorNormalize(v1);
  return Scr_AddVector((int)v1);
}

//----- (0005EA70) --------------------------------------------------------
int sub_5EA70()
{
  char v1[12]; // [esp+10h] [ebp-18h] BYREF
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  vectoangles(v2, (int)v1);
  return Scr_AddVector((int)v1);
}

//----- (0005EAA8) --------------------------------------------------------
int sub_5EAA8()
{
  float v1[3]; // [esp+10h] [ebp-18h] BYREF
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  AngleVectors(v2, 0, 0, v1);
  return Scr_AddVector((int)v1);
}

//----- (0005EAE4) --------------------------------------------------------
int sub_5EAE4()
{
  float v1[3]; // [esp+10h] [ebp-18h] BYREF
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  AngleVectors(v2, 0, v1, 0);
  return Scr_AddVector((int)v1);
}

//----- (0005EB20) --------------------------------------------------------
int sub_5EB20()
{
  float v1[3]; // [esp+10h] [ebp-18h] BYREF
  float v2[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v2);
  AngleVectors(v2, v1, 0, 0);
  return Scr_AddVector((int)v1);
}

//----- (0005EB5C) --------------------------------------------------------
int sub_5EB5C()
{
  const char *v0; // eax
  char *v1; // eax

  v0 = (const char *)Scr_GetString(0);
  v1 = va("o %s", v0);
  return trap_SendServerCommand(-1, 1, (int)v1);
}

//----- (0005EB8C) --------------------------------------------------------
int sub_5EB8C()
{
  int v0; // eax
  long double v1; // fst7
  int v2; // ebx
  char *v3; // eax
  char *v5; // eax
  char *v6; // eax

  v0 = Scr_GetNumParam();
  if ( v0 )
  {
    if ( v0 != 1 )
    {
      v3 = va("USAGE: musicStop([fadetime]);\n");
      return Scr_Error((int)v3);
    }
    v1 = Scr_GetFloat(0);
    v2 = (int)(v1 * 1000.0 + 0.5);
    if ( (int)(v1 * 1000.0 + 0.5) < 0 )
    {
      v5 = va("musicStop: fade time must be >= 0\n");
      Scr_Error((int)v5);
    }
  }
  else
  {
    v2 = 0;
  }
  v6 = va("p %i", v2);
  return trap_SendServerCommand(-1, 1, (int)v6);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005EC40) --------------------------------------------------------
int sub_5EC40()
{
  int v0; // eax
  char *v1; // eax
  float v3; // [esp+Ch] [ebp-1Ch]

  v3 = Scr_GetFloat(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v0 = 0;
  else
    v0 = (int)(Scr_GetFloat(1) * 1000.0);
  v1 = va("q %f %i\n", v3, v0);
  return trap_SendServerCommand(-1, 1, (int)v1);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005ECB8) --------------------------------------------------------
int sub_5ECB8()
{
  char *v0; // eax

  if ( !level[7] )
    Scr_Error((int)"precacheModel must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ModelIndex(v0);
}

//----- (0005ECF0) --------------------------------------------------------
int sub_5ECF0()
{
  char *v0; // eax

  if ( !level[7] )
    Scr_Error((int)"precacheShellShock must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ShellShockIndex(v0);
}

//----- (0005ED28) --------------------------------------------------------
void sub_5ED28()
{
  char *v0; // esi
  int *v1; // ebx
  char *v2; // eax

  if ( !level[7] )
    Scr_Error((int)"precacheItem must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  v1 = BG_FindItem(v0);
  if ( !v1 )
  {
    v2 = va("unknown item '%s'", v0);
    Scr_ParamError(0, (int)v2);
  }
  RegisterItem((-1431655765 * ((char *)v1 - (char *)bg_itemlist)) >> 4, 1);
}

//----- (0005EDA8) --------------------------------------------------------
int sub_5EDA8()
{
  char *v0; // ebx

  if ( !level[7] )
    Scr_Error((int)"precacheShader must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  if ( !*v0 )
    Scr_ParamError(0, (int)"Shader name string is empty");
  return G_ShaderIndex(v0);
}

//----- (0005EE00) --------------------------------------------------------
char *sub_5EE00()
{
  char *result; // eax

  if ( !level[7] )
    Scr_Error((int)"precacheString must be called before any wait statements in the gametype or level script\n");
  result = (char *)Scr_GetIString(0);
  if ( *result )
    result = (char *)G_LocalizedStringIndex(result);
  return result;
}

//----- (0005EE40) --------------------------------------------------------
int sub_5EE40()
{
  int v0; // eax
  long double v1; // fst7
  int v2; // ebx
  char *v3; // eax
  char *v5; // eax
  char *v6; // eax

  v0 = Scr_GetNumParam();
  if ( v0 )
  {
    if ( v0 != 1 )
    {
      v3 = va("USAGE: ambientStop(<fadetime>);\n");
      return Scr_Error((int)v3);
    }
    v1 = Scr_GetFloat(0);
    v2 = (int)(v1 * 1000.0 + 0.5);
    if ( (int)(v1 * 1000.0 + 0.5) < 0 )
    {
      v5 = va("ambientStop: fade time must be >= 0\n");
      Scr_Error((int)v5);
    }
  }
  else
  {
    v2 = 0;
  }
  v6 = va("t\\%i", level[122] + v2);
  return trap_SetConfigstring(3, (int)v6);
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005EEF4) --------------------------------------------------------
int sub_5EEF4()
{
  long double v0; // fst7
  int result; // eax
  float v2; // [esp-10h] [ebp-38h]
  float v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+18h] [ebp-10h]
  int v5[3]; // [esp+1Ch] [ebp-Ch] BYREF

  Scr_GetVector(0, (int)v5);
  v4 = Scr_GetFloat(1);
  v3 = Scr_GetFloat(2);
  v0 = Scr_GetFloat(3);
  level[2685] = level[2686];
  v2 = v0;
  result = G_RadiusDamage((int)v5, 0, (int)&g_entities[201334], v3, v2, v4, 0, 24);
  level[2685] = 0;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005EF6C) --------------------------------------------------------
int sub_5EF6C()
{
  int result; // eax

  result = Scr_GetBool(0);
  level[2686] = result;
  return result;
}

//----- (0005EF88) --------------------------------------------------------
int sub_5EF88()
{
  char *v0; // eax
  int v1; // ebx

  v0 = (char *)Scr_GetString(0);
  v1 = G_EffectIndex(v0);
  if ( !v1 && !level[7] )
    Scr_Error((int)"loadFx must be called before any wait statements in the gametype or level script, or on an already loaded effect\n");
  return Scr_AddInt(v1);
}

//----- (0005EFD4) --------------------------------------------------------
int sub_5EFD4()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && Scr_GetEntity(0)[86] )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (0005F030) --------------------------------------------------------
int sub_5F030()
{
  int result; // eax

  if ( (unsigned int)Scr_GetInt(0) <= 0x3F )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}

//----- (0005F064) --------------------------------------------------------
int sub_5F064()
{
  int v0; // ebx
  char *v1; // ebx
  char *v2; // eax
  int result; // eax
  char dest[1024]; // [esp+18h] [ebp-400h] BYREF

  v0 = *Scr_GetEntity(0) + 1;
  trap_GetConfigstring(20, (int)dest, 1024);
  v1 = va("%i", v0);
  v2 = Info_ValueForKey(dest, "winner");
  result = Q_stricmp(v2, v1);
  if ( result )
  {
    Info_SetValueForKey(dest, "winner", (int)v1);
    result = trap_SetConfigstring(20, (int)dest);
  }
  return result;
}

//----- (0005F0F0) --------------------------------------------------------
int sub_5F0F0()
{
  char *v0; // eax
  char v2[1024]; // [esp+18h] [ebp-400h] BYREF

  Scr_ConstructMessageString(0, v2, 1024, 3);
  v0 = va("c \"%s\" 2", v2);
  return trap_SendServerCommand(-1, 0, (int)v0);
}

//----- (0005F134) --------------------------------------------------------
int sub_5F134()
{
  int *v0; // esi
  char *v1; // eax
  char v3[1024]; // [esp+18h] [ebp-400h] BYREF

  v0 = Scr_GetEntity(0);
  Scr_ConstructMessageString(1, v3, 1024, 3);
  v1 = va("c \"%s\" 2", v3);
  return trap_SendServerCommand(*v0, 0, (int)v1);
}

//----- (0005F18C) --------------------------------------------------------
int sub_5F18C()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // bx
  const char *v2; // eax
  char *v3; // eax
  int v4; // eax

  v0 = Scr_GetConstString(0);
  v1 = v0;
  if ( v0 != scr_const[2] && v0 != scr_const[4] )
  {
    v2 = (const char *)SL_ConvertToString(v0);
    v3 = va("Illegal team string '%s'. Must be allies, or axis.", v2);
    Scr_Error((int)v3);
  }
  if ( v1 == scr_const[2] )
    v4 = level[128];
  else
    v4 = level[127];
  return Scr_AddInt(v4);
}

//----- (0005F208) --------------------------------------------------------
int sub_5F208()
{
  int result; // eax

  result = Scr_GetConstString(0);
  if ( (_WORD)result == scr_const[126] )
  {
    level[132] = 0;
  }
  else if ( (_WORD)result == scr_const[127] )
  {
    level[132] = 1;
  }
  else
  {
    result = Scr_Error((int)"Unknown mode");
  }
  return result;
}

//----- (0005F258) --------------------------------------------------------
int sub_5F258()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // bx
  const char *v2; // eax
  char *v3; // eax
  int v4; // esi
  int v5; // ebx
  int *v6; // edx
  int v7; // ecx

  v0 = Scr_GetConstString(0);
  v1 = v0;
  if ( v0 != scr_const[2] && v0 != scr_const[4] )
  {
    v2 = (const char *)SL_ConvertToString(v0);
    v3 = va("Illegal team string '%s'. Must be allies, or axis.", v2);
    Scr_Error((int)v3);
  }
  v4 = 1;
  if ( v1 == scr_const[2] )
    v4 = 2;
  v5 = 0;
  if ( (int)g_maxclients[3] > 0 )
  {
    v6 = g_entities;
    v7 = g_maxclients[3];
    do
    {
      if ( *((_BYTE *)v6 + 352) && *(_DWORD *)(v6[86] + 8572) == v4 && v6[140] > 0 )
        ++v5;
      v6 += 197;
      --v7;
    }
    while ( v7 );
  }
  return Scr_AddInt(v5);
}

//----- (0005F30C) --------------------------------------------------------
int GScr_GetNumParts()
{
  int v0; // eax
  int v1; // eax
  int v2; // eax

  v0 = Scr_GetString(0);
  v1 = trap_XModelGet(v0);
  v2 = trap_XModelNumBones(v1);
  return Scr_AddInt(v2);
}

//----- (0005F340) --------------------------------------------------------
int GScr_GetPartName()
{
  int v0; // eax
  int v1; // esi
  unsigned int v2; // ebx
  unsigned int v3; // eax
  char *v4; // eax
  unsigned __int16 v5; // bx

  v0 = Scr_GetString(0);
  v1 = trap_XModelGet(v0);
  v2 = Scr_GetInt(1);
  v3 = trap_XModelNumBones(v1);
  if ( v2 >= v3 )
  {
    v4 = va("index out of range (0 - %d)", v3 - 1);
    Scr_ParamError(1, (int)v4);
  }
  v5 = *(_WORD *)(trap_XModelGetBoneNames(v1) + 2 * v2);
  if ( !v5 )
    Scr_ParamError(0, (int)"bad model");
  return Scr_AddConstString(v5);
}

//----- (0005F3D8) --------------------------------------------------------
float *sub_5F3D8()
{
  int v0; // esi
  float *result; // eax
  float v2; // [esp+1Ch] [ebp-1Ch]
  float v3; // [esp+20h] [ebp-18h]
  float v4[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v3 = Scr_GetFloat(0);
  v0 = (int)(Scr_GetFloat(1) * 1000.0 + 0.5);
  Scr_GetVector(2, (int)v4);
  v2 = Scr_GetFloat(3);
  result = (float *)G_TempEntity(v4, 195);
  result[26] = v3;
  *((_DWORD *)result + 21) = v0;
  result[27] = v2;
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0005F468) --------------------------------------------------------
int __cdecl sub_5F468(unsigned int a1)
{
  int *v1; // ebx
  const char *v2; // eax
  const char *v3; // eax
  char *v4; // eax
  int result; // eax
  const char *v6; // [esp-18h] [ebp-40h]

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
  }
  if ( !v1[86] )
  {
    if ( *((_WORD *)v1 + 235) )
      v2 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 235));
    else
      v2 = "<undefined>";
    v6 = v2;
    v3 = (const char *)SL_ConvertToString(*((_WORD *)v1 + 187));
    v4 = va(
           "only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n",
           a1,
           *((float *)v1 + 77),
           *((float *)v1 + 78),
           *((float *)v1 + 79),
           v3,
           v6);
    Scr_Error((int)v4);
  }
  if ( Scr_GetNumParam() )
    Scr_Error((int)"USAGE: <player> stopshellshock()\n");
  *(_DWORD *)(v1[86] + 988) = 0;
  *(_DWORD *)(v1[86] + 992) = 0;
  result = v1[86];
  *(_DWORD *)(result + 996) = 0;
  return result;
}

//----- (0005F574) --------------------------------------------------------
int __cdecl sub_5F574(unsigned int a1)
{
  float *v1; // esi
  float v3[9]; // [esp+1Ch] [ebp-3Ch] BYREF
  float v4; // [esp+40h] [ebp-18h] BYREF
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+48h] [ebp-10h]
  float v7[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    Scr_ObjectError((int)"not an entity");
    v1 = 0;
  }
  else
  {
    v1 = (float *)&g_entities[197 * a1];
  }
  Scr_GetVector(0, (int)v7);
  AnglesToAxis(v1 + 80, v3);
  MatrixTransformVector(v7, v3, &v4);
  v4 = v4 + v1[77];
  v5 = v5 + v1[78];
  v6 = v6 + v1[79];
  return Scr_AddVector((int)&v4);
}

//----- (0005F618) --------------------------------------------------------
int sub_5F618()
{
  int v0; // eax
  const char *v1; // edx

  v0 = level[2684];
  if ( v0 )
  {
    v1 = "exitlevel already called";
    if ( v0 == 1 )
      v1 = "map_restart already called";
    Scr_Error((int)v1);
  }
  level[2684] = 1;
  level[1876] = 0;
  if ( Scr_GetNumParam() )
    level[1876] = Scr_GetInt(0);
  return trap_SendConsoleCommand(2, (int)"map_restart\n");
}

//----- (0005F684) --------------------------------------------------------
int sub_5F684()
{
  int v0; // eax
  const char *v1; // edx

  v0 = level[2684];
  if ( v0 )
  {
    v1 = "exitlevel already called";
    if ( v0 == 1 )
      v1 = "map_restart already called";
    Scr_Error((int)v1);
  }
  level[2684] = 2;
  level[1876] = 0;
  if ( Scr_GetNumParam() )
    level[1876] = Scr_GetInt(0);
  return ExitLevel();
}

//----- (0005F6E8) --------------------------------------------------------
int *sub_5F6E8()
{
  int *result; // eax

  result = (int *)trap_AddTestClient();
  if ( result )
    result = (int *)Scr_AddEntity(result);
  return result;
}

//----- (0005F704) --------------------------------------------------------
int sub_5F704()
{
  int v0; // eax

  v0 = Scr_GetBool(0);
  return trap_SetArchive(v0);
}

//----- (0005F724) --------------------------------------------------------
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2)
{
  int result; // eax

  *a2 = 0;
  result = Player_GetMethod(a1);
  if ( !result )
  {
    result = ScriptEnt_GetMethod(a1);
    if ( !result )
    {
      result = HudElem_GetMethod(a1);
      if ( !result )
        result = sub_5C1C0(a1);
    }
  }
  return result;
}

//----- (0005F778) --------------------------------------------------------
int __cdecl GScr_AddVector(int a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddVector(a1);
  else
    result = Scr_AddUndefined();
  return result;
}

//----- (0005F79C) --------------------------------------------------------
int Scr_LoadRead()
{
  return 0;
}

//----- (0005F7B0) --------------------------------------------------------
int __cdecl sub_5F7B0(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8)
{
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst6
  long double v14; // fst5
  long double v15; // fst4
  long double v16; // fst3
  bool v17; // zf
  long double v18; // fst7
  char v19; // fps^1
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst5
  long double v24; // rt0
  long double v25; // fst5
  long double v26; // rt1
  long double v27; // fst5
  float v29; // [esp+1Ch] [ebp-Ch] BYREF
  float v30; // [esp+20h] [ebp-8h]
  float v31; // [esp+24h] [ebp-4h]

  v8 = a4;
  if ( *(_DWORD *)a1 != 9 )
  {
    v18 = a5;
    goto LABEL_7;
  }
  v10 = v8 > 0.0;
  v11 = 0;
  v12 = 0.0 == v8;
  if ( (v9 & 0x45) == 1 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(v8 * 1000.0);
    *(float *)(a1 + 12) = *(float *)a6;
    *(float *)(a1 + 16) = *(float *)(a6 + 4);
    *(float *)(a1 + 20) = *(float *)(a6 + 8);
    v13 = *(float *)a7 - *(float *)a6;
    v29 = v13;
    v14 = *(float *)(a7 + 4) - *(float *)(a6 + 4);
    v30 = v14;
    v15 = *(float *)(a7 + 8) - *(float *)(a6 + 8);
    v16 = (long double)(int)(v8 * 1000.0);
    v31 = v15;
    *(_DWORD *)a1 = 3;
    *(float *)(a1 + 24) = v13 * (1000.0 / v16);
    *(float *)(a1 + 28) = v14 * (1000.0 / v16);
    *(float *)(a1 + 32) = 1000.0 / v16 * v15;
    return 0;
  }
  v17 = v8 <= 0.0;
  v18 = a5;
  if ( !v17 )
  {
LABEL_7:
    if ( *(_DWORD *)a1 != 3 )
      goto LABEL_10;
  }
  v20 = v18 > 0.0;
  v21 = 0;
  v22 = 0.0 == v18;
  if ( (v19 & 0x45) == 1 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(v18 * 1000.0);
    *(float *)(a1 + 12) = *(float *)a7;
    *(float *)(a1 + 16) = *(float *)(a7 + 4);
    *(float *)(a1 + 20) = *(float *)(a7 + 8);
    v29 = *(float *)a8 - *(float *)a7;
    v30 = *(float *)(a8 + 4) - *(float *)(a7 + 4);
    v31 = *(float *)(a8 + 8) - *(float *)(a7 + 8);
    VectorNormalize(&v29);
    v23 = a3 * v29;
    v29 = v23;
    v24 = v23;
    v25 = a3 * v30;
    v30 = v25;
    v26 = v25;
    v27 = a3 * v31;
    v31 = v27;
    *(float *)(a1 + 24) = v24;
    *(float *)(a1 + 28) = v26;
    *(float *)(a1 + 32) = v27;
    *(_DWORD *)a1 = 10;
    return 0;
  }
LABEL_10:
  if ( *(_DWORD *)a1 == 5 )
  {
    BG_EvaluateTrajectory(a1, level[122], (float *)(a1 + 12));
  }
  else
  {
    *(float *)(a1 + 12) = *(float *)a8;
    *(float *)(a1 + 16) = *(float *)(a8 + 4);
    *(float *)(a1 + 20) = *(float *)(a8 + 8);
  }
  *(_DWORD *)(a1 + 4) = level[122];
  *(_DWORD *)a1 = 0;
  return 1;
}
// 5F7D9: variable 'v9' is possibly undefined
// 5F88E: variable 'v19' is possibly undefined

//----- (0005F98C) --------------------------------------------------------
void __cdecl Reached_ScriptMover(int a1)
{
  int v1; // [esp+14h] [ebp-4h]
  int v2; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 12) )
  {
    if ( *(_DWORD *)(a1 + 16) + *(_DWORD *)(a1 + 20) <= level[122] )
    {
      v1 = sub_5F7B0(
             a1 + 12,
             a1 + 308,
             *(float *)(a1 + 480),
             *(float *)(a1 + 616),
             *(float *)(a1 + 628),
             a1 + 420,
             a1 + 432,
             a1 + 444);
      BG_EvaluateTrajectory(a1 + 12, level[122], (float *)(a1 + 308));
      trap_LinkEntity(a1);
      if ( v1 )
        Scr_Notify((int *)a1, scr_const[42], 0);
    }
  }
  if ( *(_DWORD *)(a1 + 48) && *(_DWORD *)(a1 + 52) + *(_DWORD *)(a1 + 56) <= level[122] )
  {
    v2 = sub_5F7B0(
           a1 + 48,
           a1 + 320,
           *(float *)(a1 + 484),
           *(float *)(a1 + 464),
           *(float *)(a1 + 620),
           a1 + 488,
           a1 + 640,
           a1 + 652);
    BG_EvaluateTrajectory(a1 + 48, level[122], (float *)(a1 + 320));
    trap_LinkEntity(a1);
    if ( v2 )
    {
      *(float *)(a1 + 320) = AngleNormalize180(*(float *)(a1 + 320));
      *(float *)(a1 + 324) = AngleNormalize360(*(float *)(a1 + 324));
      *(float *)(a1 + 328) = AngleNormalize180(*(float *)(a1 + 328));
      Scr_Notify((int *)a1, scr_const[56], 0);
    }
  }
}

//----- (0005FB38) --------------------------------------------------------
void __cdecl sub_5FB38(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  long double v12; // fst7
  long double v13; // fst6
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst7
  long double v22; // fst7
  long double v23; // fst3
  long double v24; // fst6
  long double v25; // fst5
  long double v26; // fst3
  long double v27; // rt0
  long double v28; // fst3
  long double v29; // fst6
  long double v30; // rt1
  long double v31; // fst3
  long double v32; // fst5
  char v33; // fps^1
  long double v34; // fst7
  bool v35; // c0
  char v36; // c2
  bool v37; // c3
  int v38; // eax
  char v39; // fps^1
  long double v40; // fst3
  bool v41; // c0
  char v42; // c2
  bool v43; // c3
  int v44; // eax
  long double v45; // fst3
  long double v46; // fst5
  long double v47; // fst4
  long double v48; // fst6
  long double v49; // rt1
  long double v50; // fst4
  float v51; // [esp+44h] [ebp-24h]
  float v52; // [esp+50h] [ebp-18h] BYREF
  float v53; // [esp+54h] [ebp-14h]
  float v54; // [esp+58h] [ebp-10h]
  float v55; // [esp+5Ch] [ebp-Ch] BYREF
  float v56; // [esp+60h] [ebp-8h]
  float v57; // [esp+64h] [ebp-4h]

  v55 = *(float *)a2 - *(float *)a6;
  v12 = a3;
  v56 = *(float *)(a2 + 4) - *(float *)(a6 + 4);
  v13 = a5;
  v57 = *(float *)(a2 + 8) - *(float *)(a6 + 8);
  if ( *(_DWORD *)a1 )
  {
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
    v13 = a5;
    v12 = a3;
  }
  v15 = a4 < 0.0;
  v16 = 0;
  v17 = a4 == 0.0;
  if ( (v14 & 0x44) != 0x40 || (v18 = v13 > 0.0, v19 = 0, v20 = 0.0 == v13, v14 & 0x44 ^ 0x40) )
  {
    *(float *)a8 = v12 - a4 - v13;
    *(float *)a9 = v13;
    v51 = sqrt(v55 * v55 + v56 * v56 + v57 * v57);
    *(float *)a7 = (v51 + v51) / (v12 + v12 - a4 - v13);
    VectorNormalize2(&v55, &v52);
    v23 = *(float *)a7;
    v24 = v53 * v23;
    v25 = v54 * v23;
    v26 = v52 * v23;
    v52 = v26;
    v27 = v26;
    v28 = v24;
    v29 = v27;
    v53 = v28;
    v30 = v28;
    v31 = v25;
    v32 = v30;
    v54 = v31;
    v34 = v31;
    v35 = a4 < 0.0;
    v36 = 0;
    v37 = a4 == 0.0;
    if ( (v33 & 0x45) == 64 )
    {
      *(float *)a10 = *(float *)a6;
      *(float *)(a10 + 4) = *(float *)(a6 + 4);
      *(float *)(a10 + 8) = *(float *)(a6 + 8);
      v40 = *(float *)a8;
      v41 = v40 < 0.0;
      v42 = 0;
      v43 = v40 == 0.0;
      *(_DWORD *)(a1 + 4) = level[122];
      if ( (v39 & 0x45) == 64 )
      {
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a9 * 1000.0);
        *(float *)(a1 + 12) = *(float *)a6;
        *(float *)(a1 + 16) = *(float *)(a6 + 4);
        *(float *)(a1 + 20) = *(float *)(a6 + 8);
        *(float *)(a1 + 24) = v29;
        *(float *)(a1 + 28) = v32;
        *(float *)(a1 + 32) = v34;
        *(_DWORD *)a1 = 10;
      }
      else
      {
        v44 = (int)(*(float *)a8 * 1000.0);
        *(_DWORD *)(a1 + 8) = v44;
        *(float *)(a1 + 12) = *(float *)a6;
        *(float *)(a1 + 16) = *(float *)(a6 + 4);
        *(float *)(a1 + 20) = *(float *)(a6 + 8);
        v45 = *(float *)a8;
        v46 = v32 * v45;
        v47 = v29 * v45;
        v48 = 1000.0 / (long double)v44;
        v55 = v47;
        v49 = v47;
        v56 = v46;
        v50 = v34 * v45;
        v57 = v50;
        *(_DWORD *)a1 = 3;
        *(float *)(a1 + 24) = v49 * v48;
        *(float *)(a1 + 28) = v46 * v48;
        *(float *)(a1 + 32) = v48 * v50;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[122];
      v38 = (int)(a4 * 1000.0);
      *(_DWORD *)(a1 + 8) = v38;
      *(float *)(a1 + 12) = *(float *)a6;
      *(float *)(a1 + 16) = *(float *)(a6 + 4);
      *(float *)(a1 + 20) = *(float *)(a6 + 8);
      *(float *)(a1 + 24) = v29;
      *(float *)(a1 + 28) = v32;
      *(float *)(a1 + 32) = v31;
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[122] + v38, (float *)a10);
    }
    *(float *)a11 = v52 * *(float *)a8 + *(float *)a10;
    *(float *)(a11 + 4) = v53 * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 8) = v54 * *(float *)a8 + *(float *)(a10 + 8);
    *(float *)a12 = *(float *)a2;
    *(float *)(a12 + 4) = *(float *)(a2 + 4);
    *(float *)(a12 + 8) = *(float *)(a2 + 8);
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(v12 * 1000.0);
    *(float *)a8 = v12;
    *(_DWORD *)a9 = 0;
    *(float *)a12 = *(float *)a2;
    *(float *)(a12 + 4) = *(float *)(a2 + 4);
    *(float *)(a12 + 8) = *(float *)(a2 + 8);
    *(float *)(a1 + 12) = *(float *)a6;
    *(float *)(a1 + 16) = *(float *)(a6 + 4);
    *(float *)(a1 + 20) = *(float *)(a6 + 8);
    v21 = 1000.0 / (long double)*(int *)(a1 + 8);
    *(float *)(a1 + 24) = v55 * v21;
    *(float *)(a1 + 28) = v56 * v21;
    v22 = v21 * v57;
    *(_DWORD *)a1 = 3;
    *(float *)(a1 + 32) = v22;
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
  }
}
// 5FBA1: variable 'v14' is possibly undefined
// 5FCE8: variable 'v33' is possibly undefined
// 5FD78: variable 'v39' is possibly undefined

//----- (0005FEB0) --------------------------------------------------------
void __cdecl sub_5FEB0(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  long double v12; // fst7
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  char v17; // fps^1
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  char v21; // fps^1
  bool v22; // c0
  char v23; // c2
  bool v24; // c3
  int v25; // eax
  char v26; // fps^1
  long double v27; // fst6
  bool v28; // c0
  char v29; // c2
  bool v30; // c3
  long double v31; // fst7
  long double v32; // fst7
  long double v33; // fst7
  long double v34; // fst6
  long double v35; // fst4
  char v36; // fps^1
  long double v37; // fst3
  bool v38; // c0
  char v39; // c2
  bool v40; // c3
  int v41; // eax
  int v42[13]; // [esp+2Ch] [ebp-3Ch] BYREF
  int v43; // [esp+60h] [ebp-8h]
  __int16 v44; // [esp+64h] [ebp-4h]
  __int16 v45; // [esp+66h] [ebp-2h]

  v12 = a4;
  if ( *(_DWORD *)a1 )
  {
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
    v12 = a4;
  }
  v14 = v12 > 0.0;
  v15 = 0;
  v16 = 0.0 == v12;
  if ( (v13 & 0x44) != 0x40 || (v18 = a5 < 0.0, v19 = 0, v20 = a5 == 0.0, v17 & 0x44 ^ 0x40) )
  {
    *(float *)a8 = a3 - v12 - a5;
    *(float *)a9 = a5;
    *(float *)a7 = sqrt(
                     *(float *)a2 * *(float *)a2
                   + *(float *)(a2 + 4) * *(float *)(a2 + 4)
                   + *(float *)(a2 + 8) * *(float *)(a2 + 8));
    v22 = v12 > 0.0;
    v23 = 0;
    v24 = 0.0 == v12;
    if ( (v21 & 0x45) == 64 )
    {
      *(float *)a10 = *(float *)a6;
      *(float *)(a10 + 4) = *(float *)(a6 + 4);
      *(float *)(a10 + 8) = *(float *)(a6 + 8);
      v27 = *(float *)a8;
      v28 = v27 < 0.0;
      v29 = 0;
      v30 = v27 == 0.0;
      *(_DWORD *)(a1 + 4) = level[122];
      if ( (v26 & 0x45) == 64 )
      {
        v32 = *(float *)a9 * 1000.0;
        v44 = v45 | 0xC00;
        v43 = (int)v32;
        *(_DWORD *)(a1 + 8) = (int)v32;
        *(float *)(a1 + 12) = *(float *)a6;
        *(float *)(a1 + 16) = *(float *)(a6 + 4);
        *(float *)(a1 + 20) = *(float *)(a6 + 8);
        *(float *)(a1 + 24) = *(float *)a2;
        *(float *)(a1 + 28) = *(float *)(a2 + 4);
        *(float *)(a1 + 32) = *(float *)(a2 + 8);
        *(_DWORD *)a1 = 10;
      }
      else
      {
        v31 = *(float *)a8 * 1000.0;
        v44 = v45 | 0xC00;
        v43 = (int)v31;
        *(_DWORD *)(a1 + 8) = (int)v31;
        *(float *)(a1 + 12) = *(float *)a6;
        *(float *)(a1 + 16) = *(float *)(a6 + 4);
        *(float *)(a1 + 20) = *(float *)(a6 + 8);
        *(float *)(a1 + 24) = *(float *)a2;
        *(float *)(a1 + 28) = *(float *)(a2 + 4);
        *(float *)(a1 + 32) = *(float *)(a2 + 8);
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[122];
      v44 = v45 | 0xC00;
      v43 = (int)(v12 * 1000.0);
      v25 = v43;
      *(_DWORD *)(a1 + 8) = v43;
      *(float *)(a1 + 12) = *(float *)a6;
      *(float *)(a1 + 16) = *(float *)(a6 + 4);
      *(float *)(a1 + 20) = *(float *)(a6 + 8);
      *(float *)(a1 + 24) = *(float *)a2;
      *(float *)(a1 + 28) = *(float *)(a2 + 4);
      *(float *)(a1 + 32) = *(float *)(a2 + 8);
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[122] + v25, (float *)a10);
    }
    v33 = *(float *)a2 * *(float *)a8 + *(float *)a10;
    *(float *)a11 = v33;
    v34 = *(float *)(a2 + 4) * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 4) = v34;
    v35 = *(float *)(a2 + 8) * *(float *)a8 + *(float *)(a10 + 8);
    *(float *)(a11 + 8) = v35;
    v37 = *(float *)a9;
    v38 = v37 < 0.0;
    v39 = 0;
    v40 = v37 == 0.0;
    if ( (v36 & 0x45) == 64 )
    {
      *(float *)a12 = v33;
      *(float *)(a12 + 4) = *(float *)(a11 + 4);
      *(float *)(a12 + 8) = *(float *)(a11 + 8);
    }
    else
    {
      v42[0] = 10;
      v41 = level[122];
      *(float *)&v42[3] = v33;
      *(float *)&v42[4] = v34;
      *(float *)&v42[5] = v35;
      v42[1] = v41;
      v44 = v45 | 0xC00;
      v43 = (int)(v37 * 1000.0);
      v42[2] = v43;
      v42[6] = *(int *)a2;
      v42[7] = *(int *)(a2 + 4);
      v42[8] = *(int *)(a2 + 8);
      BG_EvaluateTrajectory((int)v42, v43 + v41, (float *)a12);
    }
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
  }
  else
  {
    *(_DWORD *)(a1 + 4) = level[122];
    v44 = v45 | 0xC00;
    v43 = (int)(a3 * 1000.0);
    *(_DWORD *)(a1 + 8) = v43;
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    *(float *)(a1 + 12) = *(float *)a6;
    *(float *)(a1 + 16) = *(float *)(a6 + 4);
    *(float *)(a1 + 20) = *(float *)(a6 + 8);
    *(float *)(a1 + 24) = *(float *)a2;
    *(float *)(a1 + 28) = *(float *)(a2 + 4);
    *(float *)(a1 + 32) = *(float *)(a2 + 8);
    *(_DWORD *)a1 = 3;
    BG_EvaluateTrajectory(a1, level[122], (float *)a6);
    BG_EvaluateTrajectory(a1, level[122] + *(_DWORD *)(a1 + 8), (float *)a12);
  }
}
// 5FEE9: variable 'v13' is possibly undefined
// 5FEFC: variable 'v17' is possibly undefined
// 5FFDB: variable 'v21' is possibly undefined
// 60074: variable 'v26' is possibly undefined
// 60169: variable 'v36' is possibly undefined

//----- (00060214) --------------------------------------------------------
int __cdecl InitScriptMover(int a1)
{
  int v1; // ebx
  int result; // eax
  int v3; // edx
  int v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // [esp+20h] [ebp-18h] BYREF
  int v8; // [esp+24h] [ebp-14h]
  __int16 v9; // [esp+28h] [ebp-10h]
  __int16 v10; // [esp+2Ah] [ebp-Eh]
  int v11[3]; // [esp+2Ch] [ebp-Ch] BYREF

  v1 = G_SpawnFloat("light", (int)&unk_78B2C, (int)&v7);
  result = G_SpawnVector("color", (int)"1 1 1", (int)v11);
  if ( v1 || result )
  {
    v9 = v10 | 0xC00;
    v8 = (int)(*(float *)v11 * 255.0);
    v3 = v8;
    if ( v8 > 255 )
      v3 = 255;
    v9 = v10 | 0xC00;
    v8 = (int)(*(float *)&v11[1] * 255.0);
    v4 = v8;
    if ( v8 > 255 )
      v4 = 255;
    v9 = v10 | 0xC00;
    v8 = (int)(255.0 * *(float *)&v11[2]);
    v5 = v8;
    if ( v8 > 255 )
      v5 = 255;
    v9 = v10 | 0xC00;
    v8 = (int)(*(float *)&v7 * 0.25);
    v6 = v8;
    if ( v8 > 255 )
      v6 = 255;
    result = v6 << 24;
    *(_DWORD *)(a1 + 128) = result | (v5 << 16) | (v4 << 8) | v3;
  }
  *(float *)(a1 + 24) = *(float *)(a1 + 308);
  *(float *)(a1 + 28) = *(float *)(a1 + 312);
  *(float *)(a1 + 32) = *(float *)(a1 + 316);
  *(float *)(a1 + 60) = *(float *)(a1 + 320);
  *(float *)(a1 + 64) = *(float *)(a1 + 324);
  *(float *)(a1 + 68) = *(float *)(a1 + 328);
  *(_DWORD *)(a1 + 516) = Reached_ScriptMover;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 8;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 381) |= 0x20u;
  return result;
}

//----- (000603A0) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1)
{
  int *v1; // esi
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  long double v5; // fst7
  int v6; // ebx
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  float v17; // [esp+20h] [ebp-18h]
  float v18; // [esp+24h] [ebp-14h]
  float v19; // [esp+28h] [ebp-10h]
  int v20[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v4 = va("%i is not a valid entity number", a1);
    result = Scr_Error((int)v4);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    result = *((unsigned __int16 *)v1 + 187);
    if ( (_WORD)result != scr_const[57] && (_WORD)result != scr_const[58] && (_WORD)result != scr_const[59] )
    {
      v3 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      result = Scr_Error((int)v3);
    }
  }
  if ( (v1[95] & 4) == 0 )
  {
    Scr_GetVector(0, (int)v20);
    v5 = Scr_GetFloat(1);
    v19 = v5;
    if ( v5 <= 0.0 )
      Scr_ParamError(1, (int)"total time must be positive");
    v6 = Scr_GetNumParam();
    if ( v6 <= 2 )
    {
      v18 = 0.0;
    }
    else
    {
      v7 = Scr_GetFloat(2);
      v18 = v7;
      v9 = v7 < 0.0;
      v10 = 0;
      v11 = v7 == 0.0;
      if ( (v8 & 0x45) == 1 )
        Scr_ParamError(2, (int)"accel time must be nonnegative");
      if ( v6 > 3 )
      {
        v12 = Scr_GetFloat(3);
        v17 = v12;
        v14 = v12 < 0.0;
        v15 = 0;
        v16 = v12 == 0.0;
        if ( (v13 & 0x45) == 1 )
          Scr_ParamError(3, (int)"decel time must be nonnegative");
        goto LABEL_18;
      }
    }
    v17 = 0.0;
LABEL_18:
    if ( v18 + v17 > (long double)v19 )
      Scr_Error((int)"accel time plus decel time is greater than total time");
    sub_5FB38(
      (int)(v1 + 3),
      (int)v20,
      v19,
      v18,
      v17,
      (int)(v1 + 77),
      (int)(v1 + 120),
      (int)(v1 + 154),
      (int)(v1 + 157),
      (int)(v1 + 105),
      (int)(v1 + 108),
      (int)(v1 + 111));
    result = trap_LinkEntity((int)v1);
  }
  return result;
}
// 6049A: variable 'v8' is possibly undefined
// 604D1: variable 'v13' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00060590) --------------------------------------------------------
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1)
{
  int *v1; // ebx
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  long double v5; // fst7
  float v6[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v4 = va("%i is not a valid entity number", a1);
    result = Scr_Error((int)v4);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    result = *((unsigned __int16 *)v1 + 187);
    if ( (_WORD)result != scr_const[57] && (_WORD)result != scr_const[58] && (_WORD)result != scr_const[59] )
    {
      v3 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      result = Scr_Error((int)v3);
    }
  }
  if ( (v1[95] & 4) == 0 )
  {
    Scr_GetVector(0, (int)v6);
    v5 = Scr_GetFloat(1);
    v1[4] = level[122];
    v1[5] = (int)(v5 * 1000.0);
    v1[6] = v1[77];
    v1[7] = v1[78];
    v1[8] = v1[79];
    v1[9] = SLODWORD(v6[0]);
    v1[10] = SLODWORD(v6[1]);
    v1[11] = SLODWORD(v6[2]);
    v1[3] = 5;
    BG_EvaluateTrajectory((int)(v1 + 3), level[122], (float *)v1 + 77);
    result = trap_LinkEntity((int)v1);
  }
  return result;
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (000606C0) --------------------------------------------------------
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2)
{
  int *v2; // ebx
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  long double v6; // fst7
  int v7; // esi
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst7
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  float v18; // [esp+1Ch] [ebp-1Ch]
  float v19; // [esp+20h] [ebp-18h]
  float v20; // [esp+24h] [ebp-14h]
  float v21; // [esp+28h] [ebp-10h]
  int v22[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v5 = va("%i is not a valid entity number", a1);
    result = Scr_Error((int)v5);
    v2 = 0;
  }
  else
  {
    v2 = &g_entities[197 * a1];
    result = *((unsigned __int16 *)v2 + 187);
    if ( (_WORD)result != scr_const[57] && (_WORD)result != scr_const[58] && (_WORD)result != scr_const[59] )
    {
      v4 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      result = Scr_Error((int)v4);
    }
  }
  if ( (v2[95] & 4) == 0 )
  {
    v18 = Scr_GetFloat(0);
    v6 = Scr_GetFloat(1);
    v21 = v6;
    if ( v6 <= 0.0 )
      Scr_ParamError(1, (int)"total time must be positive");
    v7 = Scr_GetNumParam();
    if ( v7 <= 2 )
    {
      v20 = 0.0;
    }
    else
    {
      v8 = Scr_GetFloat(2);
      v20 = v8;
      v10 = v8 < 0.0;
      v11 = 0;
      v12 = v8 == 0.0;
      if ( (v9 & 0x45) == 1 )
        Scr_ParamError(2, (int)"accel time must be nonnegative");
      if ( v7 > 3 )
      {
        v13 = Scr_GetFloat(3);
        v19 = v13;
        v15 = v13 < 0.0;
        v16 = 0;
        v17 = v13 == 0.0;
        if ( (v14 & 0x45) == 1 )
          Scr_ParamError(3, (int)"decel time must be nonnegative");
        goto LABEL_18;
      }
    }
    v19 = 0.0;
LABEL_18:
    if ( v20 + v19 > (long double)v21 )
      Scr_Error((int)"accel time plus decel time is greater than total time");
    v22[0] = v2[77];
    v22[1] = v2[78];
    v22[2] = v2[79];
    *(float *)&v22[a2] = v18 + *(float *)&v22[a2];
    sub_5FB38(
      (int)(v2 + 3),
      (int)v22,
      v21,
      v20,
      v19,
      (int)(v2 + 77),
      (int)(v2 + 120),
      (int)(v2 + 154),
      (int)(v2 + 157),
      (int)(v2 + 105),
      (int)(v2 + 108),
      (int)(v2 + 111));
    result = trap_LinkEntity((int)v2);
  }
  return result;
}
// 607B9: variable 'v9' is possibly undefined
// 607F0: variable 'v14' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (000608DC) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateTo(unsigned int a1)
{
  __int16 v1; // ax
  char *v2; // eax
  char *v3; // eax
  int result; // eax
  long double v5; // fst7
  int v6; // esi
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  int v17; // ebx
  int v18; // edi
  int *v19; // [esp+40h] [ebp-28h]
  float v20; // [esp+44h] [ebp-24h]
  float v21; // [esp+48h] [ebp-20h]
  float v22; // [esp+4Ch] [ebp-1Ch]
  char v23[12]; // [esp+50h] [ebp-18h] BYREF
  float v24[3]; // [esp+5Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v3);
    v19 = 0;
  }
  else
  {
    v19 = &g_entities[197 * a1];
    v1 = *((_WORD *)v19 + 187);
    if ( v1 != scr_const[57] && v1 != scr_const[58] && v1 != scr_const[59] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error((int)v2);
    }
  }
  result = (int)v19;
  if ( (v19[95] & 4) == 0 )
  {
    Scr_GetVector(0, (int)v24);
    v5 = Scr_GetFloat(1);
    v22 = v5;
    if ( v5 <= 0.0 )
      Scr_ParamError(1, (int)"total time must be positive");
    v6 = Scr_GetNumParam();
    if ( v6 <= 2 )
    {
      v21 = 0.0;
    }
    else
    {
      v7 = Scr_GetFloat(2);
      v21 = v7;
      v9 = v7 < 0.0;
      v10 = 0;
      v11 = v7 == 0.0;
      if ( (v8 & 0x45) == 1 )
        Scr_ParamError(2, (int)"accel time must be nonnegative");
      if ( v6 > 3 )
      {
        v12 = Scr_GetFloat(3);
        v20 = v12;
        v14 = v12 < 0.0;
        v15 = 0;
        v16 = v12 == 0.0;
        if ( (v13 & 0x45) == 1 )
          Scr_ParamError(3, (int)"decel time must be nonnegative");
        goto LABEL_18;
      }
    }
    v20 = 0.0;
LABEL_18:
    if ( v21 + v20 > (long double)v22 )
      Scr_Error((int)"accel time plus decel time is greater than total time");
    v17 = 0;
    v18 = 2;
    do
    {
      *(float *)&v23[v17 * 4] = AngleSubtract(v24[v17], *(float *)&v19[v17 + 80]) + *(float *)&v19[v17 + 80];
      ++v17;
      --v18;
    }
    while ( v18 >= 0 );
    sub_5FB38(
      (int)(v19 + 12),
      (int)v23,
      v22,
      v21,
      v20,
      (int)(v19 + 80),
      (int)(v19 + 121),
      (int)(v19 + 116),
      (int)(v19 + 155),
      (int)(v19 + 122),
      (int)(v19 + 160),
      (int)(v19 + 163));
    result = trap_LinkEntity((int)v19);
  }
  return result;
}
// 609E2: variable 'v8' is possibly undefined
// 60A19: variable 'v13' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00060B5C) --------------------------------------------------------
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2)
{
  int *v2; // ebx
  int result; // eax
  char *v4; // eax
  char *v5; // eax
  long double v6; // fst7
  int v7; // esi
  long double v8; // fst7
  char v9; // fps^1
  bool v10; // c0
  char v11; // c2
  bool v12; // c3
  long double v13; // fst7
  char v14; // fps^1
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  float v18; // [esp+1Ch] [ebp-1Ch]
  float v19; // [esp+20h] [ebp-18h]
  float v20; // [esp+24h] [ebp-14h]
  float v21; // [esp+28h] [ebp-10h]
  int v22[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v5 = va("%i is not a valid entity number", a1);
    result = Scr_Error((int)v5);
    v2 = 0;
  }
  else
  {
    v2 = &g_entities[197 * a1];
    result = *((unsigned __int16 *)v2 + 187);
    if ( (_WORD)result != scr_const[57] && (_WORD)result != scr_const[58] && (_WORD)result != scr_const[59] )
    {
      v4 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      result = Scr_Error((int)v4);
    }
  }
  if ( (v2[95] & 4) == 0 )
  {
    v18 = Scr_GetFloat(0);
    v6 = Scr_GetFloat(1);
    v21 = v6;
    if ( v6 <= 0.0 )
      Scr_ParamError(1, (int)"total time must be positive");
    v7 = Scr_GetNumParam();
    if ( v7 <= 2 )
    {
      v20 = 0.0;
    }
    else
    {
      v8 = Scr_GetFloat(2);
      v20 = v8;
      v10 = v8 < 0.0;
      v11 = 0;
      v12 = v8 == 0.0;
      if ( (v9 & 0x45) == 1 )
        Scr_ParamError(2, (int)"accel time must be nonnegative");
      if ( v7 > 3 )
      {
        v13 = Scr_GetFloat(3);
        v19 = v13;
        v15 = v13 < 0.0;
        v16 = 0;
        v17 = v13 == 0.0;
        if ( (v14 & 0x45) == 1 )
          Scr_ParamError(3, (int)"decel time must be nonnegative");
        goto LABEL_18;
      }
    }
    v19 = 0.0;
LABEL_18:
    if ( v20 + v19 > (long double)v21 )
      Scr_Error((int)"accel time plus decel time is greater than total time");
    v22[0] = v2[80];
    v22[1] = v2[81];
    v22[2] = v2[82];
    *(float *)&v22[a2] = v18 + *(float *)&v22[a2];
    sub_5FB38(
      (int)(v2 + 12),
      (int)v22,
      v21,
      v20,
      v19,
      (int)(v2 + 80),
      (int)(v2 + 121),
      (int)(v2 + 116),
      (int)(v2 + 155),
      (int)(v2 + 122),
      (int)(v2 + 160),
      (int)(v2 + 163));
    result = trap_LinkEntity((int)v2);
  }
  return result;
}
// 60C50: variable 'v9' is possibly undefined
// 60C87: variable 'v14' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00060D70) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1)
{
  int *v1; // esi
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  long double v5; // fst7
  int v6; // ebx
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  float v17; // [esp+20h] [ebp-18h]
  float v18; // [esp+24h] [ebp-14h]
  float v19; // [esp+28h] [ebp-10h]
  int v20[3]; // [esp+2Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v4 = va("%i is not a valid entity number", a1);
    result = Scr_Error((int)v4);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    result = *((unsigned __int16 *)v1 + 187);
    if ( (_WORD)result != scr_const[57] && (_WORD)result != scr_const[58] && (_WORD)result != scr_const[59] )
    {
      v3 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      result = Scr_Error((int)v3);
    }
  }
  if ( (v1[95] & 4) == 0 )
  {
    Scr_GetVector(0, (int)v20);
    v5 = Scr_GetFloat(1);
    v19 = v5;
    if ( v5 <= 0.0 )
      Scr_ParamError(1, (int)"total time must be positive");
    v6 = Scr_GetNumParam();
    if ( v6 <= 2 )
    {
      v18 = 0.0;
    }
    else
    {
      v7 = Scr_GetFloat(2);
      v18 = v7;
      v9 = v7 < 0.0;
      v10 = 0;
      v11 = v7 == 0.0;
      if ( (v8 & 0x45) == 1 )
        Scr_ParamError(2, (int)"accel time must be nonnegative");
      if ( v6 > 3 )
      {
        v12 = Scr_GetFloat(3);
        v17 = v12;
        v14 = v12 < 0.0;
        v15 = 0;
        v16 = v12 == 0.0;
        if ( (v13 & 0x45) == 1 )
          Scr_ParamError(3, (int)"decel time must be nonnegative");
        goto LABEL_18;
      }
    }
    v17 = 0.0;
LABEL_18:
    if ( v18 + v17 > (long double)v19 )
      Scr_Error((int)"accel time plus decel time is greater than total time");
    sub_5FEB0(
      (int)(v1 + 12),
      (int)v20,
      v19,
      v18,
      v17,
      (int)(v1 + 80),
      (int)(v1 + 121),
      (int)(v1 + 116),
      (int)(v1 + 155),
      (int)(v1 + 122),
      (int)(v1 + 160),
      (int)(v1 + 163));
    result = trap_LinkEntity((int)v1);
  }
  return result;
}
// 60E6A: variable 'v8' is possibly undefined
// 60EA1: variable 'v13' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00060F60) --------------------------------------------------------
int __cdecl ScriptEnt_GetMethod(char **a1)
{
  unsigned int v1; // edi
  int v2; // esi
  const char *v3; // ebx
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  s1 = *a1;
  do
  {
    v3 = (&off_78D40)[v2];
    if ( !strcmp(s1, v3) )
    {
      *a1 = (char *)v3;
      return *(int *)((char *)&off_78D44 + v2 * 4);
    }
    v2 += 2;
    ++v1;
  }
  while ( v1 <= 0xB );
  return 0;
}
// 78D40: using guessed type char *off_78D40;
// 78D44: using guessed type int (__cdecl *off_78D44)(int);

//----- (00060FB8) --------------------------------------------------------
int __cdecl SP_script_brushmodel(int a1)
{
  trap_SetBrushModel(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 280) = 1;
  return trap_LinkEntity(a1);
}

//----- (00060FF4) --------------------------------------------------------
int __cdecl SP_script_model(int a1)
{
  G_DObjUpdate(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 280) = 8320;
  *(_BYTE *)(a1 + 244) |= 4u;
  return trap_LinkEntity(a1);
}

//----- (00061034) --------------------------------------------------------
int __cdecl SP_script_origin(int a1)
{
  int result; // eax

  InitScriptMover(a1);
  *(_DWORD *)(a1 + 280) = 0;
  result = trap_LinkEntity(a1);
  if ( *(_DWORD *)(a1 + 128) )
    *(_BYTE *)(a1 + 9) |= 1u;
  else
    *(_BYTE *)(a1 + 244) |= 1u;
  return result;
}

//----- (00061080) --------------------------------------------------------
__int16 __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3)
{
  long double v3; // fst7
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  int v8; // ebx
  long double v9; // fst7
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3
  long double v14; // fst7
  char v15; // fps^1
  bool v16; // c0
  char v17; // c2
  bool v18; // c3
  __int16 v19; // fps
  long double v20; // fst7
  bool v21; // c0
  char v22; // c2
  bool v23; // c3
  __int16 result; // ax

  v3 = Scr_GetFloat(1);
  *a1 = v3;
  v5 = v3 < 0.0;
  v6 = 0;
  v7 = v3 == 0.0;
  if ( (unsigned __int8)((v4 & 0x45) - 1) < 0x40u )
    Scr_ParamError(1, (int)"total time must be positive");
  v8 = Scr_GetNumParam();
  if ( v8 <= 2 )
  {
    *a2 = 0.0;
LABEL_10:
    *a3 = 0.0;
    goto LABEL_11;
  }
  v9 = Scr_GetFloat(2);
  *a2 = v9;
  v11 = v9 < 0.0;
  v12 = 0;
  v13 = v9 == 0.0;
  if ( (v10 & 0x45) == 1 )
    Scr_ParamError(2, (int)"accel time must be nonnegative");
  if ( v8 <= 3 )
    goto LABEL_10;
  v14 = Scr_GetFloat(3);
  *a3 = v14;
  v16 = v14 < 0.0;
  v17 = 0;
  v18 = v14 == 0.0;
  if ( (v15 & 0x45) == 1 )
    Scr_ParamError(3, (int)"decel time must be nonnegative");
LABEL_11:
  v20 = *a2 + *a3;
  v21 = v20 < *a1;
  v22 = 0;
  v23 = v20 == *a1;
  LOBYTE(result) = v19;
  HIBYTE(result) = HIBYTE(v19) & 0x45;
  if ( v20 > *a1 )
    result = Scr_Error((int)"accel time plus decel time is greater than total time");
  return result;
}
// 610A9: variable 'v4' is possibly undefined
// 610E8: variable 'v10' is possibly undefined
// 6111E: variable 'v15' is possibly undefined
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (00061174) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveX(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 0);
}

//----- (0006118C) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveY(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 1);
}

//----- (000611A4) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 2);
}

//----- (000611BC) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 0);
}

//----- (000611D4) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 1);
}

//----- (000611EC) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 2);
}

//----- (00061204) --------------------------------------------------------
int __cdecl ScriptEntCmd_Solid(unsigned int a1)
{
  int *v1; // ebx
  __int16 v2; // ax
  char *v3; // eax
  char *v4; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v4 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v4);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    v2 = *((_WORD *)v1 + 187);
    if ( v2 != scr_const[57] && v2 != scr_const[58] )
    {
      if ( v2 == scr_const[59] )
        return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity");
      v3 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error((int)v3);
    }
  }
  result = *((unsigned __int16 *)v1 + 187);
  if ( (_WORD)result == scr_const[59] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity");
  if ( (_WORD)result == scr_const[58] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity");
  v1[70] = 1;
  return result;
}

//----- (000612CC) --------------------------------------------------------
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1)
{
  int *v1; // ebx
  __int16 v2; // ax
  char *v3; // eax
  char *v4; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v4 = va("%i is not a valid entity number", a1);
    Scr_Error((int)v4);
    v1 = 0;
  }
  else
  {
    v1 = &g_entities[197 * a1];
    v2 = *((_WORD *)v1 + 187);
    if ( v2 != scr_const[57] && v2 != scr_const[58] )
    {
      if ( v2 == scr_const[59] )
        return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity");
      v3 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error((int)v3);
    }
  }
  result = *((unsigned __int16 *)v1 + 187);
  if ( (_WORD)result == scr_const[59] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity");
  if ( (_WORD)result == scr_const[58] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity");
  v1[70] = 0;
  return result;
}

//----- (00061390) --------------------------------------------------------
int __cdecl G_SpawnString(char *s1, int a2, int a3)
{
  int v3; // esi
  int result; // eax

  if ( !level[1233] )
    *(_DWORD *)a3 = a2;
  v3 = 0;
  if ( level[1234] <= 0 )
  {
LABEL_7:
    *(_DWORD *)a3 = a2;
    result = 0;
  }
  else
  {
    while ( strcmp(s1, (const char *)level[2 * v3 + 1235]) )
    {
      if ( ++v3 >= level[1234] )
        goto LABEL_7;
    }
    *(_DWORD *)a3 = level[2 * v3 + 1236];
    result = 1;
  }
  return result;
}

//----- (00061400) --------------------------------------------------------
int __cdecl sub_61400(int a1, char *s, int a3)
{
  char **v3; // ebx
  int result; // eax
  __int16 v5; // dx
  int v6; // edx
  long double v7; // fst7
  unsigned __int16 v8; // bx
  int v9; // eax
  int v10; // [esp+20h] [ebp-18h] BYREF
  float v11; // [esp+24h] [ebp-14h]
  float v12; // [esp+2Ch] [ebp-Ch] BYREF
  float v13; // [esp+30h] [ebp-8h] BYREF
  float v14; // [esp+34h] [ebp-4h] BYREF

  dword_AA984 = a1;
  dword_AA988 = (int)s;
  v3 = &off_78E68;
  if ( !"classname" )
  {
LABEL_11:
    result = Scr_FindField(a1, (int)&v10);
    v8 = result;
    if ( !(_WORD)result )
      return result;
    result = v10;
    if ( v10 == 4 )
    {
      v11 = _strtod_internal(s, 0, 0);
      Scr_AddFloat(v11);
    }
    else if ( v10 > 4 )
    {
      if ( v10 != 5 )
        return result;
      v9 = _strtol_internal(s, 0, 10, 0);
      Scr_AddInt(v9);
    }
    else
    {
      if ( v10 != 1 )
        return result;
      Scr_AddString((int)s);
    }
    return GScr_SetDynamicEntityField((int *)a3, v8);
  }
  while ( Q_stricmp(*v3, (char *)a1) )
  {
    v3 += 4;
    if ( !*v3 )
      goto LABEL_11;
  }
  result = (int)v3[2];
  switch ( result )
  {
    case 0:
      v6 = _strtol_internal(s, 0, 10, 0);
      result = (int)v3[1];
      *(_DWORD *)(result + a3) = v6;
      break;
    case 1:
      v7 = _strtod_internal(s, 0, 0);
      result = (int)v3[1];
      *(float *)(result + a3) = v7;
      break;
    case 3:
      Scr_SetString((int)&v3[1][a3], 0);
      v5 = G_NewString(s);
      result = (int)v3[1];
      *(_WORD *)(result + a3) = v5;
      break;
    case 4:
      sscanf(s, "%f %f %f", &v12, &v13, &v14);
      *(float *)&v3[1][a3] = v12;
      *(float *)&v3[1][a3 + 4] = v13;
      result = (int)v3[1];
      *(float *)(result + a3 + 8) = v14;
      break;
    case 8:
      if ( *s == 42 )
      {
        result = (unsigned __int16)_strtol_internal(s + 1, 0, 10, 0);
        *(_DWORD *)(a3 + 140) = (unsigned __int16)result;
      }
      else
      {
        result = G_ModelIndex(s);
        *(_BYTE *)(a3 + 373) = result;
      }
      break;
    default:
      return result;
  }
  return result;
}
// 78E68: using guessed type char *off_78E68;
// AA984: using guessed type int dword_AA984;
// AA988: using guessed type int dword_AA988;

//----- (000615E4) --------------------------------------------------------
int G_CallSpawn()
{
  int result; // eax
  const char **v1; // edi
  int v2; // ebx
  int i; // esi
  char **v4; // edi
  int v5; // ebx
  int j; // esi
  int v7; // ebx
  int k; // esi
  char *s2; // [esp+14h] [ebp-4h] BYREF

  G_SpawnString("classname", (int)&unk_792F7, (int)&s2);
  if ( !s2 )
    return G_Printf("G_CallSpawn: NULL classname\n");
  v1 = (const char **)&bg_itemlist[12];
  if ( bg_itemlist[12] )
  {
    while ( strcmp(*v1, s2) )
    {
      v1 += 12;
      if ( !*v1 )
        goto LABEL_9;
    }
    v2 = G_Spawn();
    for ( i = 0; i < level[1234]; ++i )
      sub_61400(level[2 * i + 1235], (char *)level[2 * i + 1236], v2);
    G_SetOrigin(v2, (float *)(v2 + 308));
    G_SetAngle(v2, (float *)(v2 + 320));
    result = G_SpawnItem(v2, (int)v1);
  }
  else
  {
LABEL_9:
    v4 = &spawns;
    if ( spawns )
    {
      while ( strcmp(*v4, s2) )
      {
        v4 += 2;
        if ( !*v4 )
          goto LABEL_15;
      }
      v5 = G_Spawn();
      for ( j = 0; j < level[1234]; ++j )
        sub_61400(level[2 * j + 1235], (char *)level[2 * j + 1236], v5);
      G_SetOrigin(v5, (float *)(v5 + 308));
      G_SetAngle(v5, (float *)(v5 + 320));
      result = ((int (__cdecl *)(int))v4[1])(v5);
    }
    else
    {
LABEL_15:
      v7 = G_Spawn();
      for ( k = 0; k < level[1234]; ++k )
        sub_61400(level[2 * k + 1235], (char *)level[2 * k + 1236], v7);
      G_SetOrigin(v7, (float *)(v7 + 308));
      result = G_SetAngle(v7, (float *)(v7 + 320));
    }
  }
  return result;
}
// 7EB30: using guessed type char *spawns;

//----- (000617D4) --------------------------------------------------------
#error "6189F: positive sp value has been found (funcsize=75)"

//----- (000618B8) --------------------------------------------------------
int Scr_GetEnt()
{
  int v0; // eax
  int result; // eax
  char *v2; // edi
  int v3; // edx
  int *v4; // ecx
  int v5; // esi
  int *i; // ebx
  __int16 v7; // [esp+16h] [ebp-2h]

  v7 = Scr_GetConstString(0);
  v0 = Scr_GetString(1);
  result = Scr_GetOffset(g_scr_data[105], v0);
  if ( result >= 0 )
  {
    result *= 16;
    v2 = (char *)&off_78E68 + result;
    if ( *(int *)((char *)dword_78E70 + result) == 3 )
    {
      v3 = level[3];
      v4 = 0;
      v5 = 0;
      for ( i = g_entities; v5 < v3; i += 197 )
      {
        if ( *((_BYTE *)i + 352) )
        {
          result = *(unsigned __int16 *)((char *)i + *((_DWORD *)v2 + 1));
          if ( (_WORD)result )
          {
            if ( (_WORD)result == v7 )
            {
              if ( v4 )
                result = Scr_Error((int)"getent used with more than one entity");
              v3 = level[3];
              v4 = i;
            }
          }
        }
        ++v5;
      }
      if ( v4 )
        result = Scr_AddEntityNum(*v4, 0);
    }
  }
  return result;
}
// 78E68: using guessed type char *off_78E68;
// 78E70: using guessed type int dword_78E70[];

//----- (00061980) --------------------------------------------------------
int Scr_GetEntArray()
{
  int result; // eax
  int v1; // esi
  int *j; // ebx
  int v3; // eax
  char *v4; // edi
  int v5; // esi
  int *i; // ebx
  __int16 v7; // [esp+16h] [ebp-2h]

  if ( Scr_GetNumParam() )
  {
    v7 = Scr_GetConstString(0);
    v3 = Scr_GetString(1);
    result = Scr_GetOffset(g_scr_data[105], v3);
    if ( result >= 0 )
    {
      result *= 16;
      v4 = (char *)&off_78E68 + result;
      if ( *(int *)((char *)dword_78E70 + result) == 3 )
      {
        result = Scr_MakeArray();
        v5 = 0;
        for ( i = g_entities; v5 < level[3]; i += 197 )
        {
          if ( *((_BYTE *)i + 352) )
          {
            result = *(unsigned __int16 *)((char *)i + *((_DWORD *)v4 + 1));
            if ( (_WORD)result )
            {
              if ( (_WORD)result == v7 )
              {
                Scr_AddEntityNum(*i, 0);
                result = Scr_AddArray();
              }
            }
          }
          ++v5;
        }
      }
    }
  }
  else
  {
    result = Scr_MakeArray();
    v1 = 0;
    for ( j = g_entities; v1 < level[3]; j += 197 )
    {
      if ( *((_BYTE *)j + 352) )
      {
        Scr_AddEntityNum(*j, 0);
        result = Scr_AddArray();
      }
      ++v1;
    }
  }
  return result;
}
// 78E68: using guessed type char *off_78E68;
// 78E70: using guessed type int dword_78E70[];

//----- (00061A8C) --------------------------------------------------------
int G_ParseSpawnVars()
{
  char *v1; // esi
  unsigned int v2; // eax
  int v3; // eax
  int v4; // esi
  char *v5; // ebx
  char *v6; // esi
  unsigned int v7; // eax
  int v8; // eax
  int v9; // esi
  char *v10; // ebx
  char v11; // [esp+18h] [ebp-800h] BYREF
  _BYTE v12[3]; // [esp+19h] [ebp-7FFh] BYREF
  char src; // [esp+418h] [ebp-400h] BYREF
  _BYTE v14[3]; // [esp+419h] [ebp-3FFh] BYREF

  level[1234] = 0;
  level[1363] = 0;
  if ( !trap_GetEntityToken((int)&v11, 1024) )
    return 0;
  if ( v11 != 123 )
    G_Error("G_ParseSpawnVars: found %s when expecting {", &v11);
  while ( 1 )
  {
    if ( !trap_GetEntityToken((int)&src, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace");
    if ( src == 125 )
      return 1;
    if ( !trap_GetEntityToken((int)&v11, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace");
    if ( v11 == 125 )
      G_Error("G_ParseSpawnVars: closing brace without data");
    if ( level[1234] == 64 )
      G_Error("G_ParseSpawnVars: MAX_SPAWN_VARS");
    v1 = &src;
    v2 = (unsigned int)&src & 3;
    if ( ((unsigned __int8)&src & 3) != 0 )
    {
      if ( __SETP__((unsigned int)&src & 3, 0) )
        goto LABEL_19;
      if ( v2 != 2 )
      {
        if ( src == BYTE1(v2) )
          goto LABEL_28;
        v1 = v14;
      }
      if ( *v1 != BYTE1(v2) )
      {
        ++v1;
LABEL_19:
        if ( *v1 != BYTE1(v2) )
        {
          ++v1;
          goto LABEL_21;
        }
        goto LABEL_28;
      }
    }
    else
    {
LABEL_21:
      while ( 1 )
      {
        v3 = *(_DWORD *)v1;
        if ( !(unsigned __int8)*(_DWORD *)v1 )
          break;
        if ( !BYTE1(v3) )
          goto LABEL_27;
        if ( (v3 & 0xFF0000) == 0 )
          goto LABEL_26;
        v1 += 4;
        if ( (v3 & 0xFF000000) == 0 )
        {
          v1 -= 3;
LABEL_26:
          ++v1;
LABEL_27:
          ++v1;
          break;
        }
      }
    }
LABEL_28:
    v4 = v1 - &src;
    if ( level[1363] + v4 + 1 > 2048 )
      G_Error("G_AddSpawnVarToken: MAX_SPAWN_VARS");
    v5 = (char *)&level[1364] + level[1363];
    memcpy(v5, &src, v4 + 1);
    level[1363] += v4 + 1;
    level[2 * level[1234] + 1235] = (int)v5;
    v6 = &v11;
    v7 = (unsigned int)&v11 & 3;
    if ( ((unsigned int)&v11 & 3) != 0 )
    {
      if ( __SETP__((unsigned int)&v11 & 3, 0) )
        goto LABEL_37;
      if ( v7 != 2 )
      {
        if ( v11 == BYTE1(v7) )
          goto LABEL_46;
        v6 = v12;
      }
      if ( *v6 != BYTE1(v7) )
      {
        ++v6;
LABEL_37:
        if ( *v6 != BYTE1(v7) )
        {
          ++v6;
          goto LABEL_39;
        }
        goto LABEL_46;
      }
    }
    else
    {
LABEL_39:
      while ( 1 )
      {
        v8 = *(_DWORD *)v6;
        if ( !(unsigned __int8)*(_DWORD *)v6 )
          break;
        if ( !BYTE1(v8) )
          goto LABEL_45;
        if ( (v8 & 0xFF0000) == 0 )
          goto LABEL_44;
        v6 += 4;
        if ( (v8 & 0xFF000000) == 0 )
        {
          v6 -= 3;
LABEL_44:
          ++v6;
LABEL_45:
          ++v6;
          break;
        }
      }
    }
LABEL_46:
    v9 = v6 - &v11;
    if ( level[1363] + v9 + 1 > 2048 )
      G_Error("G_AddSpawnVarToken: MAX_SPAWN_VARS");
    v10 = (char *)&level[1364] + level[1363];
    memcpy(v10, &v11, v9 + 1);
    level[1363] += v9 + 1;
    level[2 * level[1234]++ + 1236] = (int)v10;
  }
}

//----- (00061CEC) --------------------------------------------------------
int SP_worldspawn()
{
  char *v0; // eax
  char *v1; // eax
  int v2; // eax
  int result; // eax
  char *nptr; // [esp+14h] [ebp-4h] BYREF

  G_SpawnString("classname", (int)&unk_792F7, (int)&nptr);
  if ( Q_stricmp(nptr, "worldspawn") )
    G_Error("SP_worldspawn: The first entity isn't 'worldspawn'");
  trap_SetConfigstring(2, (int)"cod");
  v0 = va("%i", level[125]);
  trap_SetConfigstring(13, (int)v0);
  G_SpawnString("ambienttrack", (int)&unk_792F7, (int)&nptr);
  if ( *nptr )
  {
    v1 = va("n\\%s", nptr);
    trap_SetConfigstring(3, (int)v1);
  }
  else
  {
    trap_SetConfigstring(3, (int)&unk_792F7);
  }
  G_SpawnString("message", (int)&unk_792F7, (int)&nptr);
  trap_SetConfigstring(4, (int)nptr);
  trap_SetConfigstring(14, (int)&g_motd + 16);
  G_SpawnString("gravity", (int)"800", (int)&nptr);
  trap_Cvar_Set((int)"g_gravity", (int)nptr);
  G_SpawnString("northyaw", (int)&unk_792F7, (int)&nptr);
  if ( *nptr )
    trap_SetConfigstring(11, (int)nptr);
  else
    trap_SetConfigstring(11, (int)"0");
  G_SpawnString("spawnflags", (int)"0", (int)&nptr);
  v2 = _strtol_internal(nptr, 0, 10, 0);
  g_entities[201428] = v2;
  g_entities[201419] = v2;
  g_entities[201334] = 1022;
  result = Scr_SetString((int)&g_entities[201427] + 2, scr_const[78]);
  LOBYTE(g_entities[201422]) = 1;
  return result;
}

//----- (00061EA8) --------------------------------------------------------
int __cdecl Scr_AddEntity(int *a1)
{
  return Scr_AddEntityNum(*a1, 0);
}

//----- (00061EC4) --------------------------------------------------------
int *__cdecl Scr_GetEntity(int a1)
{
  unsigned int v1; // eax
  int v3; // [esp+14h] [ebp-4h] BYREF

  v1 = Scr_GetEntityNum(a1, (int)&v3);
  if ( !v3 && v1 <= 0x3FF )
    return &g_entities[197 * v1];
  Scr_ParamError(a1, (int)"not an entity");
  return 0;
}
// 21DF80: using guessed type int g_entities[];

//----- (00061F10) --------------------------------------------------------
int __cdecl Scr_ExecEntThread(int *a1, int a2, int a3)
{
  return (unsigned __int16)Scr_ExecEntThreadNum(*a1, 0, a2, a3);
}

//----- (00061F34) --------------------------------------------------------
int __cdecl Scr_AddExecEntThread(int *a1, int a2, int a3)
{
  return Scr_AddExecEntThreadNum(*a1, 0, a2, a3);
}

//----- (00061F54) --------------------------------------------------------
int __cdecl Scr_Notify(int *a1, unsigned __int16 a2, int a3)
{
  return Scr_NotifyNum(*a1, 0, a2, a3);
}

//----- (00061F74) --------------------------------------------------------
int __cdecl Scr_FreeEntityConstStrings(int a1)
{
  char **v1; // ebx
  int v2; // esi
  int v3; // ebx
  int result; // eax

  v1 = &off_78E68;
  if ( "classname" )
  {
    do
    {
      if ( v1[2] == (_BYTE *)&dword_0 + 3 )
        Scr_SetString((int)&v1[1][a1], 0);
      v1 += 4;
    }
    while ( *v1 );
  }
  v2 = 0;
  v3 = a1 + 754;
  do
  {
    *(_BYTE *)(v2 + a1 + 748) = 0;
    result = Scr_SetString(v3, 0);
    v3 += 2;
    ++v2;
  }
  while ( v2 <= 5 );
  return result;
}
// 0: using guessed type int dword_0;
// 78E68: using guessed type char *off_78E68;

//----- (00061FEC) --------------------------------------------------------
int __cdecl Scr_FreeEntity(int *a1)
{
  char **v1; // ebx
  int v2; // esi
  int v3; // ebx

  v1 = &off_78E68;
  if ( "classname" )
  {
    do
    {
      if ( v1[2] == (_BYTE *)&dword_0 + 3 )
        Scr_SetString((int)a1 + (_DWORD)v1[1], 0);
      v1 += 4;
    }
    while ( *v1 );
  }
  v2 = 0;
  v3 = (int)a1 + 754;
  do
  {
    *((_BYTE *)a1 + v2 + 748) = 0;
    Scr_SetString(v3, 0);
    v3 += 2;
    ++v2;
  }
  while ( v2 <= 5 );
  return Scr_FreeEntityNum(*a1, 0);
}
// 0: using guessed type int dword_0;
// 78E68: using guessed type char *off_78E68;

//----- (00062078) --------------------------------------------------------
int __cdecl GScr_SetDynamicEntityField(int *a1, unsigned __int16 a2)
{
  return Scr_SetDynamicEntityField(*a1, 0, a2);
}

//----- (00062098) --------------------------------------------------------
int __cdecl Scr_FreeHudElem(int a1)
{
  Scr_FreeHudElemConstStrings(a1);
  return Scr_FreeEntityNum((-1108378657 * (a1 - (int)g_hudelems)) >> 2, 1);
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (000620CC) --------------------------------------------------------
int __cdecl Scr_AddHudElem(int a1)
{
  return Scr_AddEntityNum((-1108378657 * (a1 - (int)g_hudelems)) >> 2, 1);
}
// 16F0E0: using guessed type int g_hudelems[];

//----- (000620F4) --------------------------------------------------------
int *__cdecl Scr_GetHudElem(int a1)
{
  unsigned int v1; // eax
  int v3; // [esp+14h] [ebp-4h] BYREF

  v1 = Scr_GetEntityNum(a1, (int)&v3);
  if ( v3 == 1 && v1 <= 0x3FF )
    return &g_hudelems[31 * v1];
  Scr_ParamError(a1, (int)"not a hudelem");
  return 0;
}

//----- (00062148) --------------------------------------------------------
int __cdecl G_SpawnFloat(char *s1, int a2, int a3)
{
  int v3; // esi
  char *nptr; // [esp+10h] [ebp-8h] BYREF

  v3 = G_SpawnString(s1, a2, (int)&nptr);
  *(float *)a3 = _strtod_internal(nptr, 0, 0);
  return v3;
}

//----- (0006218C) --------------------------------------------------------
int __cdecl G_SpawnInt(char *s1, int a2, int a3)
{
  int v3; // esi
  char *nptr; // [esp+14h] [ebp-4h] BYREF

  v3 = G_SpawnString(s1, a2, (int)&nptr);
  *(_DWORD *)a3 = _strtol_internal(nptr, 0, 10, 0);
  return v3;
}

//----- (000621CC) --------------------------------------------------------
int __cdecl G_SpawnVector(char *s1, int a2, int a3)
{
  int v3; // esi
  char *s; // [esp+14h] [ebp-4h] BYREF

  v3 = G_SpawnString(s1, a2, (int)&s);
  sscanf(s, "%f %f %f", a3, a3 + 4, a3 + 8);
  return v3;
}

//----- (00062214) --------------------------------------------------------
char __cdecl G_DuplicateEntityFields(int a1, int a2)
{
  char **v2; // ebx
  char *v3; // eax
  char *v4; // edx
  char *v5; // edx

  v2 = &off_78E68;
  if ( "classname" )
  {
    do
    {
      v3 = v2[2];
      switch ( (unsigned int)v3 )
      {
        case 0u:
          v4 = v2[1];
          v3 = *(char **)&v4[a2];
          *(_DWORD *)&v4[a1] = v3;
          break;
        case 1u:
          v3 = v2[1];
          *(float *)&v3[a1] = *(float *)&v3[a2];
          break;
        case 3u:
          LOBYTE(v3) = Scr_SetString((int)&v2[1][a1], *(_WORD *)&v2[1][a2]);
          break;
        case 4u:
          *(float *)&v2[1][a1] = *(float *)&v2[1][a2];
          *(float *)&v2[1][a1 + 4] = *(float *)&v2[1][a2 + 4];
          v3 = v2[1];
          *(float *)&v3[a1 + 8] = *(float *)&v3[a2 + 8];
          break;
        case 8u:
          v5 = v2[1];
          LOBYTE(v3) = v5[a2];
          v5[a1] = (char)v3;
          break;
        default:
          break;
      }
      v2 += 4;
    }
    while ( *v2 );
  }
  return (char)v3;
}
// 622B4: variable 'v3' is possibly undefined
// 78E68: using guessed type char *off_78E68;

//----- (000622BC) --------------------------------------------------------
int __cdecl G_DuplicateScriptFields(int *a1, int *a2)
{
  return Scr_CopyEntityNum(*a2, *a1, 0);
}

//----- (000622DC) --------------------------------------------------------
int G_SpawnEntitiesFromString()
{
  int result; // eax

  level[1233] = 1;
  level[1234] = 0;
  if ( !G_ParseSpawnVars() )
    G_Error("SpawnEntities: no entities");
  SP_worldspawn();
  while ( 1 )
  {
    result = G_ParseSpawnVars();
    if ( !result )
      break;
    G_CallSpawn();
  }
  level[1233] = 0;
  return result;
}

//----- (00062334) --------------------------------------------------------
int __cdecl G_NewString(_BYTE *a1)
{
  _BYTE *v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // ebx
  int v5; // esi
  char *v6; // eax
  int i; // ecx
  char v8; // dl
  char v10[65536]; // [esp+18h] [ebp-10000h] BYREF

  v1 = a1;
  v2 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)a1 & 3, 0) )
      goto LABEL_8;
    if ( v2 != 2 )
    {
      if ( *a1 == BYTE1(v2) )
        goto LABEL_17;
      v1 = a1 + 1;
    }
    if ( *v1 != BYTE1(v2) )
    {
      ++v1;
LABEL_8:
      if ( *v1 != BYTE1(v2) )
      {
        ++v1;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v3 = *(_DWORD *)v1;
      if ( !(unsigned __int8)*(_DWORD *)v1 )
        break;
      if ( !BYTE1(v3) )
        goto LABEL_16;
      if ( (v3 & 0xFF0000) == 0 )
        goto LABEL_15;
      v1 += 4;
      if ( (v3 & 0xFF000000) == 0 )
      {
        v1 -= 3;
LABEL_15:
        ++v1;
LABEL_16:
        ++v1;
        break;
      }
    }
  }
LABEL_17:
  v4 = v1 - a1;
  v5 = v4 + 1;
  if ( (unsigned int)(v4 + 1) > 0x10000 )
    G_Error("G_NewString: len = %i > %i\n", v4 + 1, 0x10000);
  v6 = v10;
  for ( i = 0; i < v5; ++i )
  {
    v8 = a1[i];
    if ( v8 == 92 && i < v4 )
    {
      if ( a1[++i] == 110 )
        *v6 = 10;
      else
        *v6 = 92;
    }
    else
    {
      *v6 = v8;
    }
    ++v6;
  }
  return (unsigned __int16)SL_GetString((int)v10, 0);
}

//----- (00062400) --------------------------------------------------------
void GScr_AddFieldsForEntity()
{
  unsigned __int16 v0; // si
  int *v1; // ebx
  unsigned int v2; // eax

  v0 = g_scr_data[105];
  v1 = (int *)&off_78E68;
  if ( "classname" )
  {
    do
    {
      v2 = v1[2];
      if ( v2 <= 5 || v2 <= 8 && v2 >= 7 )
        Scr_AddClassField(v0, *v1, ((char *)v1 - (char *)&off_78E68) >> 4);
      v1 += 4;
    }
    while ( *v1 );
  }
  GScr_AddFieldsForClient(v0);
}
// 78E68: using guessed type char *off_78E68;

//----- (00062470) --------------------------------------------------------
int GScr_AddFieldsForRadiant()
{
  return Scr_AddFields((int)"radiant", (int)".txt");
}

//----- (0006248C) --------------------------------------------------------
int __cdecl Scr_GetGenericField(int a1, int a2, int a3)
{
  int result; // eax
  int *v4; // eax
  int v5; // eax
  int v6[3]; // [esp+Ch] [ebp-Ch] BYREF

  result = a3;
  switch ( a2 )
  {
    case 0:
      result = Scr_AddInt(*(_DWORD *)(a3 + a1));
      break;
    case 1:
      result = Scr_AddFloat(*(float *)(a3 + a1));
      break;
    case 2:
      result = Scr_AddString(a1 + a3);
      break;
    case 3:
      result = *(unsigned __int16 *)(a3 + a1);
      if ( (_WORD)result )
        result = Scr_AddConstString(result);
      break;
    case 4:
      v4 = (int *)(a1 + a3);
      goto LABEL_9;
    case 5:
      result = *(_DWORD *)(a3 + a1);
      if ( result )
        result = Scr_AddEntity((int *)result);
      break;
    case 6:
      v6[0] = 0;
      v6[1] = *(int *)(a3 + a1);
      v6[2] = 0;
      v4 = v6;
LABEL_9:
      result = Scr_AddVector((int)v4);
      break;
    case 7:
      result = *(unsigned __int16 *)(a3 + a1);
      if ( (_WORD)result )
        result = Scr_AddObject(result);
      break;
    case 8:
      v5 = G_ModelName(*(unsigned __int8 *)(a3 + a1));
      result = Scr_AddString(v5);
      break;
    default:
      return result;
  }
  return result;
}

//----- (0006257C) --------------------------------------------------------
void __cdecl Scr_SetGenericField(int a1, int a2, int a3)
{
  unsigned __int16 v3; // ax
  int *v4; // eax
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  switch ( a2 )
  {
    case 0:
      v4 = (int *)Scr_GetInt(0);
      goto LABEL_8;
    case 1:
      *(float *)(a3 + a1) = Scr_GetFloat(0);
      break;
    case 3:
      v3 = Scr_GetConstString(0);
      Scr_SetString(a3 + a1, v3);
      break;
    case 4:
      Scr_GetVector(0, (int)&v5);
      *(float *)(a3 + a1) = v5;
      *(float *)(a3 + a1 + 4) = v6;
      *(float *)(a3 + a1 + 8) = v7;
      break;
    case 5:
      v4 = Scr_GetEntity(0);
LABEL_8:
      *(_DWORD *)(a3 + a1) = v4;
      break;
    case 6:
      Scr_GetVector(0, (int)&v5);
      *(float *)(a3 + a1) = v6;
      break;
    default:
      return;
  }
}
// 6BD28: using guessed type double __cdecl Scr_GetFloat(_DWORD);

//----- (0006262C) --------------------------------------------------------
int sub_6262C()
{
  return Scr_Error((int)"Tried to set a read only entity field");
}

//----- (00062644) --------------------------------------------------------
void __cdecl Scr_SetEntityField(int a1, int a2)
{
  int v2; // ebx
  int *v3; // esi
  char *v4; // eax
  void (__cdecl *v5)(int *, int); // eax
  int v6; // [esp+14h] [ebp-4h] BYREF

  v2 = a2;
  v3 = &g_entities[197 * a1];
  if ( (a2 & 0xC000) == 49152 )
  {
    if ( !v3[86] )
    {
      if ( level[1233] )
      {
        G_SpawnString("classname", (int)&unk_792F7, (int)&v6);
        v4 = va((char *)&byte_79300, v6, dword_AA984, dword_AA988, "field must be applied to a player");
        Com_Error(1, v4);
      }
      Scr_ObjectError((int)"field must be applied to a player");
    }
    BYTE1(v2) = BYTE1(a2) & 0x3F;
    Scr_SetClientField(v3[86], v2);
  }
  else
  {
    v5 = (void (__cdecl *)(int *, int))*(&off_78E74 + 4 * a2);
    if ( v5 )
      v5(&g_entities[197 * a1], a2);
    else
      Scr_SetGenericField((int)&g_entities[197 * a1], dword_78E70[4 * a2], dword_78E6C[4 * a2]);
  }
}
// 78E6C: using guessed type int dword_78E6C[];
// 78E70: using guessed type int dword_78E70[];
// 78E74: using guessed type int (*off_78E74)();
// AA984: using guessed type int dword_AA984;
// AA988: using guessed type int dword_AA988;

//----- (00062720) --------------------------------------------------------
void __cdecl Scr_SetObjectField(int a1, int a2, int a3)
{
  int v3; // ebx
  int *v4; // esi
  char *v5; // eax
  void (__stdcall *v6)(int *, int, int, int, int, int, int, int, int, int, int); // eax
  int v7; // [esp-8h] [ebp-20h]
  int v8; // [esp-4h] [ebp-1Ch]
  int v9; // [esp+0h] [ebp-18h]
  int v10; // [esp+4h] [ebp-14h]
  int v11; // [esp+8h] [ebp-10h]
  int v12; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+14h] [ebp-4h] BYREF
  int savedregs; // [esp+18h] [ebp+0h]

  v3 = a3;
  if ( a1 )
  {
    if ( a1 == 1 )
      Scr_SetHudElemField(a2, a3);
  }
  else
  {
    v4 = &g_entities[197 * a2];
    if ( (a3 & 0xC000) == 49152 )
    {
      if ( !v4[86] )
      {
        if ( level[1233] )
        {
          G_SpawnString("classname", (int)&unk_792F7, (int)&v14);
          v5 = va((char *)&byte_79300, v14, dword_AA984, dword_AA988, "field must be applied to a player");
          Com_Error(1, v5);
        }
        Scr_ObjectError((int)"field must be applied to a player");
      }
      BYTE1(v3) = BYTE1(a3) & 0x3F;
      Scr_SetClientField(v4[86], v3);
    }
    else
    {
      v6 = (void (__stdcall *)(int *, int, int, int, int, int, int, int, int, int, int))*(&off_78E74 + 4 * a3);
      if ( v6 )
        v6(v4, a3, v7, v8, v9, v10, v11, v12, v13, v14, savedregs);
      else
        Scr_SetGenericField((int)v4, dword_78E70[4 * a3], dword_78E6C[4 * a3]);
    }
  }
}
// 627F4: variable 'v7' is possibly undefined
// 627F4: variable 'v8' is possibly undefined
// 627F4: variable 'v9' is possibly undefined
// 627F4: variable 'v10' is possibly undefined
// 627F4: variable 'v11' is possibly undefined
// 627F4: variable 'v12' is possibly undefined
// 627F4: variable 'v13' is possibly undefined
// 78E6C: using guessed type int dword_78E6C[];
// 78E70: using guessed type int dword_78E70[];
// 78E74: using guessed type int (*off_78E74)();
// AA984: using guessed type int dword_AA984;
// AA988: using guessed type int dword_AA988;

//----- (00062824) --------------------------------------------------------
int __cdecl Scr_GetEntityField(int a1, int a2)
{
  int v2; // ebx
  int *v3; // esi
  char *v4; // eax
  int v6; // [esp+14h] [ebp-4h] BYREF

  v2 = a2;
  v3 = &g_entities[197 * a1];
  if ( (a2 & 0xC000) != 49152 )
    return Scr_GetGenericField((int)&g_entities[197 * a1], dword_78E70[4 * a2], dword_78E6C[4 * a2]);
  if ( !v3[86] )
  {
    if ( level[1233] )
    {
      G_SpawnString("classname", (int)&unk_792F7, (int)&v6);
      v4 = va((char *)&byte_79300, v6, dword_AA984, dword_AA988, "field must be applied to a player");
      Com_Error(1, v4);
    }
    Scr_ObjectError((int)"field must be applied to a player");
  }
  BYTE1(v2) = BYTE1(a2) & 0x3F;
  return Scr_GetClientField(v3[86], v2);
}
// 78E6C: using guessed type int dword_78E6C[];
// 78E70: using guessed type int dword_78E70[];
// AA984: using guessed type int dword_AA984;
// AA988: using guessed type int dword_AA988;

//----- (000628EC) --------------------------------------------------------
int __cdecl Scr_GetObjectField(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // ebx
  int *v5; // esi
  char *v6; // eax
  int v7; // [esp+14h] [ebp-4h] BYREF

  result = a2;
  v4 = a3;
  if ( a1 )
  {
    if ( a1 == 1 )
      result = Scr_GetHudElemField(a2, a3);
  }
  else
  {
    v5 = &g_entities[197 * a2];
    if ( (a3 & 0xC000) == 49152 )
    {
      if ( !v5[86] )
      {
        if ( level[1233] )
        {
          G_SpawnString("classname", (int)&unk_792F7, (int)&v7);
          v6 = va((char *)&byte_79300, v7, dword_AA984, dword_AA988, "field must be applied to a player");
          Com_Error(1, v6);
        }
        Scr_ObjectError((int)"field must be applied to a player");
      }
      BYTE1(v4) = BYTE1(a3) & 0x3F;
      result = Scr_GetClientField(v5[86], v4);
    }
    else
    {
      result = Scr_GetGenericField((int)v5, dword_78E70[4 * a3], dword_78E6C[4 * a3]);
    }
  }
  return result;
}
// 78E6C: using guessed type int dword_78E6C[];
// 78E70: using guessed type int dword_78E70[];
// AA984: using guessed type int dword_AA984;
// AA988: using guessed type int dword_AA988;

//----- (000629D8) --------------------------------------------------------
int G_SpawnGEntityFromSpawnVars()
{
  return G_CallSpawn();
}

//----- (000629E8) --------------------------------------------------------
char *__cdecl G_AddSpawnVarToken(void *src)
{
  _BYTE *v1; // ebx
  int v2; // eax
  int v3; // eax
  int v4; // ebx
  char *v5; // esi

  v1 = src;
  v2 = (unsigned __int8)src & 3;
  if ( ((unsigned __int8)src & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)src & 3, 0) )
      goto LABEL_8;
    if ( v2 != 2 )
    {
      if ( *(_BYTE *)src == BYTE1(v2) )
        goto LABEL_17;
      v1 = (char *)src + 1;
    }
    if ( *v1 != BYTE1(v2) )
    {
      ++v1;
LABEL_8:
      if ( *v1 != BYTE1(v2) )
      {
        ++v1;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v3 = *(_DWORD *)v1;
      if ( !(unsigned __int8)*(_DWORD *)v1 )
        break;
      if ( !BYTE1(v3) )
        goto LABEL_16;
      if ( (v3 & 0xFF0000) == 0 )
        goto LABEL_15;
      v1 += 4;
      if ( (v3 & 0xFF000000) == 0 )
      {
        v1 -= 3;
LABEL_15:
        ++v1;
LABEL_16:
        ++v1;
        break;
      }
    }
  }
LABEL_17:
  v4 = v1 - (_BYTE *)src;
  if ( level[1363] + v4 + 1 > 2048 )
    G_Error("G_AddSpawnVarToken: MAX_SPAWN_VARS");
  v5 = (char *)&level[1364] + level[1363];
  memcpy(v5, src, v4 + 1);
  level[1363] += v4 + 1;
  return v5;
}

//----- (00062A90) --------------------------------------------------------
int __cdecl sub_62A90(const char *a1, _DWORD *a2)
{
  int i; // esi
  int j; // esi
  int v6; // ecx
  char v7; // al
  int v8; // [esp+20h] [ebp-88h] BYREF
  int v9; // [esp+24h] [ebp-84h] BYREF
  char nptr[128]; // [esp+28h] [ebp-80h] BYREF

  for ( i = 0; i <= 3; ++i )
  {
    *((_BYTE *)&v9 + i) = 0;
    *((_BYTE *)&v8 + i) = 0;
  }
  for ( j = 0; j <= 3; ++j )
  {
    if ( (unsigned __int8)(*a1 - 48) > 9u )
    {
      G_Printf("Bad filter address: %s\n", a1);
      return 0;
    }
    v6 = 0;
    do
      nptr[v6++] = *a1++;
    while ( (unsigned __int8)(*a1 - 48) <= 9u );
    nptr[v6] = 0;
    v7 = _strtol_internal(nptr, 0, 10, 0);
    *((_BYTE *)&v9 + j) = v7;
    if ( v7 )
      *((_BYTE *)&v8 + j) = -1;
    if ( !*a1 )
      break;
    ++a1;
  }
  *a2 = v8;
  a2[1] = v9;
  return 1;
}

//----- (00062B64) --------------------------------------------------------
int __cdecl G_FilterPacket(char *a1)
{
  char *v1; // ecx
  int v2; // esi
  char v3; // dl
  char v4; // bl
  int v5; // edi
  int v6; // esi
  int *v7; // edx
  int result; // eax
  int v9; // [esp+24h] [ebp-4h] BYREF

  v1 = a1;
  v2 = 0;
  if ( *a1 )
  {
    do
    {
      *((_BYTE *)&v9 + v2) = 0;
      v3 = *v1;
      if ( (unsigned __int8)(*v1 - 48) <= 9u )
      {
        v4 = 0;
        do
        {
          v4 = 10 * v4 + v3 - 48;
          v3 = *++v1;
        }
        while ( (unsigned __int8)(*v1 - 48) <= 9u );
        *((_BYTE *)&v9 + v2) = v4;
      }
      if ( !*v1 )
        break;
      if ( *v1 == 58 )
        break;
      ++v2;
      if ( !*++v1 )
        break;
    }
    while ( v2 <= 3 );
  }
  v5 = g_filterBan[3];
  v6 = 0;
  if ( dword_AC9A0 <= 0 )
  {
LABEL_15:
    LOBYTE(result) = v5 == 0;
  }
  else
  {
    v7 = &dword_AA9A0;
    while ( (*v7 & v9) != v7[1] )
    {
      v7 += 2;
      if ( ++v6 >= dword_AC9A0 )
        goto LABEL_15;
    }
    LOBYTE(result) = v5 != 0;
  }
  return (unsigned __int8)result;
}
// AA9A0: using guessed type int dword_AA9A0;
// AC9A0: using guessed type int dword_AC9A0;

//----- (00062C10) --------------------------------------------------------
int __cdecl sub_62C10(const char *a1)
{
  int v1; // eax
  int v3; // ebx
  int i; // esi
  int v5; // eax
  char *v6; // edx
  int v7; // eax
  char *v8; // eax
  int v9; // edx
  size_t v10; // [esp-1Ch] [ebp-444h]
  int v11; // [esp-14h] [ebp-43Ch]
  char s[1024]; // [esp+28h] [ebp-400h] BYREF

  v1 = 0;
  if ( dword_AC9A0 > 0 && dword_AA9A4[0] != -1 )
  {
    do
      ++v1;
    while ( v1 < dword_AC9A0 && dword_AA9A4[2 * v1] != -1 );
  }
  if ( v1 == dword_AC9A0 )
  {
    if ( v1 == 1024 )
      return G_Printf("IP filter list is full\n");
    dword_AC9A0 = v1 + 1;
  }
  v3 = 2 * v1;
  if ( !sub_62A90(a1, &dword_AA9A0[2 * v1]) )
    dword_AA9A4[v3] = -1;
  s[0] = 0;
  for ( i = 0; i < dword_AC9A0; ++i )
  {
    v5 = dword_AA9A4[2 * i];
    if ( v5 != -1 )
    {
      v11 = (unsigned __int8)v5;
      v6 = s;
      while ( 1 )
      {
        v7 = *(_DWORD *)v6;
        if ( !(unsigned __int8)*(_DWORD *)v6 )
          break;
        if ( !BYTE1(v7) )
          goto LABEL_20;
        if ( (v7 & 0xFF0000) == 0 )
          goto LABEL_19;
        v6 += 4;
        if ( (v7 & 0xFF000000) == 0 )
        {
          v6 -= 3;
LABEL_19:
          ++v6;
LABEL_20:
          ++v6;
          break;
        }
      }
      v10 = 1024 - (v6 - s);
      v8 = s;
      while ( 1 )
      {
        v9 = *(_DWORD *)v8;
        if ( !(unsigned __int8)*(_DWORD *)v8 )
          break;
        if ( !BYTE1(v9) )
          goto LABEL_28;
        if ( (v9 & 0xFF0000) == 0 )
          goto LABEL_27;
        v8 += 4;
        if ( (v9 & 0xFF000000) == 0 )
        {
          v8 -= 3;
LABEL_27:
          ++v8;
LABEL_28:
          ++v8;
          break;
        }
      }
      Com_sprintf(
        v8,
        v10,
        "%i.%i.%i.%i ",
        v11,
        BYTE1(dword_AA9A4[2 * i]),
        (unsigned __int8)BYTE2(dword_AA9A4[2 * i]),
        HIBYTE(dword_AA9A4[2 * i]));
    }
  }
  return trap_Cvar_Set((int)"g_banIPs", (int)s);
}
// AA9A0: using guessed type int dword_AA9A0[];
// AC9A0: using guessed type int dword_AC9A0;

//----- (00062D88) --------------------------------------------------------
int Svcmd_RemoveIP_f()
{
  int result; // eax
  int v1; // ebx
  int v2; // edx
  int i; // esi
  int v4; // eax
  char *v5; // eax
  int v6; // edx
  char *v7; // eax
  int v8; // edx
  size_t v9; // [esp-1Ch] [ebp-854h]
  int v10; // [esp-14h] [ebp-84Ch]
  int v11[2]; // [esp+30h] [ebp-808h] BYREF
  char s[1024]; // [esp+38h] [ebp-800h] BYREF
  char v13[1024]; // [esp+438h] [ebp-400h] BYREF

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  sv removeip <ip-mask>\n");
  trap_Argv(1, (int)v13, 1024);
  result = sub_62A90(v13, v11);
  if ( result )
  {
    v1 = 0;
    if ( dword_AC9A0 <= 0 )
    {
LABEL_30:
      result = G_Printf("Didn't find %s.\n", v13);
    }
    else
    {
      v2 = 0;
      while ( dword_AA9A0[v2] != v11[0] || dword_AA9A4[v2] != v11[1] )
      {
        v2 += 2;
        if ( ++v1 >= dword_AC9A0 )
          goto LABEL_30;
      }
      dword_AA9A4[v2] = -1;
      G_Printf("Removed.\n");
      s[0] = 0;
      for ( i = 0; i < dword_AC9A0; ++i )
      {
        v4 = dword_AA9A4[2 * i];
        if ( v4 != -1 )
        {
          v10 = (unsigned __int8)v4;
          v5 = s;
          while ( 1 )
          {
            v6 = *(_DWORD *)v5;
            if ( !(unsigned __int8)*(_DWORD *)v5 )
              break;
            if ( !BYTE1(v6) )
              goto LABEL_17;
            if ( (v6 & 0xFF0000) == 0 )
              goto LABEL_16;
            v5 += 4;
            if ( (v6 & 0xFF000000) == 0 )
            {
              v5 -= 3;
LABEL_16:
              ++v5;
LABEL_17:
              ++v5;
              break;
            }
          }
          v9 = 1024 - (v5 - s);
          v7 = s;
          while ( 1 )
          {
            v8 = *(_DWORD *)v7;
            if ( !(unsigned __int8)*(_DWORD *)v7 )
              break;
            if ( !BYTE1(v8) )
              goto LABEL_25;
            if ( (v8 & 0xFF0000) == 0 )
              goto LABEL_24;
            v7 += 4;
            if ( (v8 & 0xFF000000) == 0 )
            {
              v7 -= 3;
LABEL_24:
              ++v7;
LABEL_25:
              ++v7;
              break;
            }
          }
          Com_sprintf(
            v7,
            v9,
            "%i.%i.%i.%i ",
            v10,
            BYTE1(dword_AA9A4[2 * i]),
            (unsigned __int8)BYTE2(dword_AA9A4[2 * i]),
            HIBYTE(dword_AA9A4[2 * i]));
        }
      }
      result = trap_Cvar_Set((int)"g_banIPs", (int)s);
    }
  }
  return result;
}
// AA9A0: using guessed type int dword_AA9A0[];
// AC9A0: using guessed type int dword_AC9A0;

//----- (00062F44) --------------------------------------------------------
void Svcmd_EntityList_f()
{
  int *v0; // ebx
  int i; // esi
  const char *v2; // eax
  int v3; // [esp-Ch] [ebp-24h]

  v0 = &g_entities[197];
  for ( i = 1; i < level[3]; v0 += 197 )
  {
    if ( *((_BYTE *)v0 + 352) )
    {
      G_Printf("%3i:", i);
      switch ( v0[1] )
      {
        case 0:
          G_Printf("ET_GENERAL          ", v3);
          break;
        case 1:
          G_Printf("ET_PLAYER           ", v3);
          break;
        case 3:
          G_Printf("ET_ITEM             ", v3);
          break;
        case 4:
          G_Printf("ET_MISSILE          ", v3);
          break;
        case 5:
          G_Printf("ET_MOVER            ", v3);
          break;
        case 6:
          G_Printf("ET_PORTAL           ", v3);
          break;
        case 7:
          G_Printf("ET_INVISIBLE        ", v3);
          break;
        case 8:
          G_Printf("ET_SCRIPTMOVER      ");
          break;
        default:
          G_Printf("%3i                 ", v0[1]);
          break;
      }
      if ( *((_WORD *)v0 + 187) )
      {
        v2 = (const char *)SL_ConvertToString(*((_WORD *)v0 + 187));
        G_Printf("%s", v2);
      }
      G_Printf("\n");
    }
    ++i;
  }
}
// 62F9B: variable 'v3' is possibly undefined

//----- (0006307C) --------------------------------------------------------
int __cdecl ClientForString(char *nptr)
{
  int v1; // eax
  int result; // eax
  int v3; // esi
  int v4; // edi
  int v5; // ebx

  if ( (unsigned __int8)(*nptr - 48) > 9u )
  {
    v3 = 0;
    if ( level[120] <= 0 )
    {
LABEL_13:
      G_Printf("User %s is not on the server\n", nptr);
      result = 0;
    }
    else
    {
      v4 = 0;
      while ( 1 )
      {
        v5 = level[0] + v4;
        if ( *(_DWORD *)(level[0] + v4 + 8428) )
        {
          if ( !Q_stricmp((char *)(v5 + 8628), nptr) )
            break;
        }
        v4 += 8900;
        if ( ++v3 >= level[120] )
          goto LABEL_13;
      }
      result = v5;
    }
  }
  else
  {
    v1 = _strtol_internal(nptr, 0, 10, 0);
    if ( v1 >= 0 && v1 < level[120] )
    {
      if ( *(_DWORD *)(level[0] + 8900 * v1 + 8428) )
      {
        result = level[0] + 8900 * v1;
      }
      else
      {
        G_Printf("Client %i is not connected\n", v1);
        result = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v1);
      result = 0;
    }
  }
  return result;
}

//----- (0006315C) --------------------------------------------------------
int ConsoleCommand()
{
  int result; // eax
  char *v1; // eax
  char *v2; // eax
  char v3[1024]; // [esp+18h] [ebp-800h] BYREF
  char v4[1024]; // [esp+418h] [ebp-400h] BYREF

  trap_Argv(0, (int)v4, 1024);
  if ( !Q_stricmp(v4, "entitylist") )
  {
    Svcmd_EntityList_f();
    return 1;
  }
  if ( !Q_stricmp(v4, "addip") )
  {
    if ( trap_Argc() > 1 )
    {
      trap_Argv(1, (int)v3, 1024);
      sub_62C10(v3);
    }
    else
    {
      G_Printf("Usage:  addip <ip-mask>\n");
    }
    return 1;
  }
  if ( !Q_stricmp(v4, "removeip") )
  {
    Svcmd_RemoveIP_f();
    return 1;
  }
  if ( Q_stricmp(v4, "listip") )
  {
    if ( g_dedicated[3] )
    {
      if ( Q_stricmp(v4, "say") )
        v1 = ConcatArgs(0);
      else
        v1 = ConcatArgs(1);
      v2 = va(aEGameServer_0, v1);
      trap_SendServerCommand(-1, 0, (int)v2);
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    trap_SendConsoleCommand(1, (int)"g_banIPs\n");
    result = 1;
  }
  return result;
}

//----- (000632CC) --------------------------------------------------------
char *G_ProcessIPBans()
{
  char *result; // eax
  const char *v1; // ebx
  const char *i; // esi
  char dest[1024]; // [esp+18h] [ebp-400h] BYREF

  dword_AC9A0 = 0;
  result = Q_strncpyz(dest, &g_banIPs[16], 1024);
  v1 = &g_banIPs[16];
  for ( i = &g_banIPs[16]; *v1; i = v1 )
  {
    result = strchr(v1, 32);
    v1 = result;
    if ( !result )
      break;
    while ( *v1 == 32 )
      *v1++ = 0;
    if ( *i )
      result = (char *)sub_62C10(i);
  }
  return result;
}
// AC9A0: using guessed type int dword_AC9A0;

//----- (00063348) --------------------------------------------------------
int Svcmd_AddIP_f()
{
  char v1[1024]; // [esp+18h] [ebp-400h] BYREF

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  addip <ip-mask>\n");
  trap_Argv(1, (int)v1, 1024);
  return sub_62C10(v1);
}

//----- (000633A0) --------------------------------------------------------
int __cdecl trap_Printf(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(0, a1, v2, v3);
}
// 633B4: variable 'v2' is possibly undefined
// 633B4: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000633BC) --------------------------------------------------------
int __cdecl trap_Error(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(1, a1, v2, v3);
}
// 633D0: variable 'v2' is possibly undefined
// 633D0: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000633D8) --------------------------------------------------------
int __cdecl trap_Error_Localized(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(2, a1, v2, v3);
}
// 633EC: variable 'v2' is possibly undefined
// 633EC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000633F4) --------------------------------------------------------
int trap_Milliseconds()
{
  int v1; // [esp-Ch] [ebp-14h]
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(3, v1, v2, v3);
}
// 63404: variable 'v1' is possibly undefined
// 63404: variable 'v2' is possibly undefined
// 63404: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006340C) --------------------------------------------------------
int trap_Argc()
{
  int v1; // [esp-Ch] [ebp-14h]
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(10, v1, v2, v3);
}
// 6341C: variable 'v1' is possibly undefined
// 6341C: variable 'v2' is possibly undefined
// 6341C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063424) --------------------------------------------------------
int __cdecl trap_Argv(int a1, int a2, int a3)
{
  return dword_7EC10(11, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063444) --------------------------------------------------------
int __cdecl trap_FS_FOpenFile(int a1, int a2, int a3)
{
  return dword_7EC10(18, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063464) --------------------------------------------------------
int __cdecl trap_FS_Read(int a1, int a2, int a3)
{
  return dword_7EC10(19, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063484) --------------------------------------------------------
int __cdecl trap_FS_Write(int a1, int a2, int a3)
{
  return dword_7EC10(20, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000634A4) --------------------------------------------------------
int __cdecl trap_FS_Rename(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(21, a1, a2, v3);
}
// 634BC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000634C4) --------------------------------------------------------
int __cdecl trap_FS_FCloseFile(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(22, a1, v2, v3);
}
// 634D8: variable 'v2' is possibly undefined
// 634D8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000634E0) --------------------------------------------------------
int __cdecl trap_FS_GetFileList(int a1, int a2, int a3)
{
  return dword_7EC10(56, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006350C) --------------------------------------------------------
int __cdecl trap_SendConsoleCommand(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(23, a1, a2, v3);
}
// 63524: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006352C) --------------------------------------------------------
int __cdecl trap_Cvar_Register(int a1, int a2, int a3)
{
  return dword_7EC10(4, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063558) --------------------------------------------------------
int __cdecl trap_Cvar_Update(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(5, a1, v2, v3);
}
// 6356C: variable 'v2' is possibly undefined
// 6356C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063574) --------------------------------------------------------
int __cdecl trap_Cvar_Set(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(6, a1, a2, v3);
}
// 6358C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063594) --------------------------------------------------------
int __cdecl trap_Cvar_VariableIntegerValue(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(7, a1, v2, v3);
}
// 635A8: variable 'v2' is possibly undefined
// 635A8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000635B0) --------------------------------------------------------
long double __cdecl trap_Cvar_VariableValue(int a1)
{
  int v2; // [esp-4h] [ebp-1Ch]
  float v3; // [esp+14h] [ebp-4h] BYREF

  dword_7EC10(8, a1, &v3, v2);
  return v3;
}
// 635C8: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000635D4) --------------------------------------------------------
int __cdecl trap_Cvar_VariableStringBuffer(int a1, int a2, int a3)
{
  return dword_7EC10(9, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000635F4) --------------------------------------------------------
int __cdecl trap_LocateGameData(int a1, int a2, int a3)
{
  return dword_7EC10(24, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063628) --------------------------------------------------------
int __cdecl trap_DropClient(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(25, a1, a2, v3);
}
// 63640: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063648) --------------------------------------------------------
int __cdecl trap_SendServerCommand(int a1, int a2, int a3)
{
  return dword_7EC10(26, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063668) --------------------------------------------------------
int __cdecl trap_SetConfigstring(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(27, a1, a2, v3);
}
// 63680: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063688) --------------------------------------------------------
int __cdecl trap_GetConfigstring(int a1, int a2, int a3)
{
  return dword_7EC10(28, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000636A8) --------------------------------------------------------
int __cdecl trap_GetConfigstringConst(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(29, a1, v2, v3);
}
// 636BC: variable 'v2' is possibly undefined
// 636BC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000636C4) --------------------------------------------------------
int __cdecl trap_GetUserinfo(int a1, int a2, int a3)
{
  return dword_7EC10(30, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000636E4) --------------------------------------------------------
int __cdecl trap_SetUserinfo(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(31, a1, a2, v3);
}
// 636FC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063704) --------------------------------------------------------
int __cdecl trap_GetServerinfo(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(32, a1, a2, v3);
}
// 6371C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063724) --------------------------------------------------------
int __cdecl trap_SetBrushModel(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(33, a1, v2, v3);
}
// 63738: variable 'v2' is possibly undefined
// 63738: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063740) --------------------------------------------------------
int __cdecl trap_Trace(int a1, int a2, int a3)
{
  return dword_7EC10(34, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063778) --------------------------------------------------------
int __cdecl trap_TraceCapsule(int a1, int a2, int a3)
{
  return dword_7EC10(35, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000637B0) --------------------------------------------------------
int __cdecl trap_SightTrace(int a1, int a2, int a3)
{
  return dword_7EC10(36, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000637F0) --------------------------------------------------------
int __cdecl trap_SightTraceCapsule(int a1, int a2, int a3)
{
  return dword_7EC10(37, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063830) --------------------------------------------------------
int __cdecl trap_SightTraceToEntity(int a1, int a2, int a3)
{
  return dword_7EC10(38, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063868) --------------------------------------------------------
int __cdecl trap_CM_BoxTrace(int a1, int a2, int a3)
{
  return dword_7EC10(39, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000638A0) --------------------------------------------------------
int __cdecl trap_CM_CapsuleTrace(int a1, int a2, int a3)
{
  return dword_7EC10(40, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000638D8) --------------------------------------------------------
int __cdecl trap_CM_BoxSightTrace(int a1, int a2, int a3)
{
  return dword_7EC10(41, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063910) --------------------------------------------------------
int __cdecl trap_CM_CapsuleSightTrace(int a1, int a2, int a3)
{
  return dword_7EC10(42, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063948) --------------------------------------------------------
int __cdecl trap_LocationalTrace(int a1, int a2, int a3)
{
  return dword_7EC10(43, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063980) --------------------------------------------------------
int __cdecl trap_PointContents(int a1, int a2, int a3)
{
  return dword_7EC10(44, a1, a2, a3);
}
// 63980: using guessed type int __cdecl trap_PointContents(int, int, int);
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000639A0) --------------------------------------------------------
int __cdecl trap_InPVS(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(45, a1, a2, v3);
}
// 639B8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000639C0) --------------------------------------------------------
int __cdecl trap_InPVSIgnorePortals(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(46, a1, a2, v3);
}
// 639D8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000639E0) --------------------------------------------------------
int __cdecl trap_InSnapshot(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(47, a1, a2, v3);
}
// 639F8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063A00) --------------------------------------------------------
int __cdecl trap_AdjustAreaPortalState(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(48, a1, a2, v3);
}
// 63A18: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063A20) --------------------------------------------------------
int __cdecl trap_AreasConnected(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(49, a1, a2, v3);
}
// 63A38: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063A40) --------------------------------------------------------
int __cdecl trap_LinkEntity(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(50, a1, v2, v3);
}
// 63A54: variable 'v2' is possibly undefined
// 63A54: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063A5C) --------------------------------------------------------
int __cdecl trap_UnlinkEntity(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(51, a1, v2, v3);
}
// 63A70: variable 'v2' is possibly undefined
// 63A70: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063A78) --------------------------------------------------------
int __cdecl trap_EntitiesInBox(int a1, int a2, int a3)
{
  return dword_7EC10(52, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063AAC) --------------------------------------------------------
int __cdecl trap_EntityContact(int a1, int a2, int a3)
{
  return dword_7EC10(53, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063ACC) --------------------------------------------------------
int __cdecl trap_EntityContactCapsule(int a1, int a2, int a3)
{
  return dword_7EC10(59, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063AEC) --------------------------------------------------------
int __cdecl trap_GetUsercmd(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(54, a1, a2, v3);
}
// 63B04: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063B0C) --------------------------------------------------------
int __cdecl trap_GetEntityToken(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(55, a1, a2, v3);
}
// 63B24: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063B2C) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasString(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(60, a1, v2, v3);
}
// 63B40: variable 'v2' is possibly undefined
// 63B40: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063B48) --------------------------------------------------------
int __cdecl trap_Com_PickSoundAlias(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(61, a1, v2, v3);
}
// 63B5C: variable 'v2' is possibly undefined
// 63B5C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063B64) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasIndex(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(62, a1, v2, v3);
}
// 63B78: variable 'v2' is possibly undefined
// 63B78: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063B80) --------------------------------------------------------
int trap_AddTestClient()
{
  int v0; // eax
  int result; // eax
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  v0 = dword_7EC10(65, v2, v3, v4);
  if ( v0 < 0 )
    result = 0;
  else
    result = level[1] + 788 * v0;
  return result;
}
// 63B90: variable 'v2' is possibly undefined
// 63B90: variable 'v3' is possibly undefined
// 63B90: variable 'v4' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063BAC) --------------------------------------------------------
int __cdecl trap_GetArchivedPlayerState(int a1, int a2, int a3)
{
  return dword_7EC10(66, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063BCC) --------------------------------------------------------
int __cdecl trap_SurfaceTypeFromName(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(63, a1, v2, v3);
}
// 63BE0: variable 'v2' is possibly undefined
// 63BE0: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063BE8) --------------------------------------------------------
int __cdecl trap_SurfaceTypeToName(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(64, a1, v2, v3);
}
// 63BFC: variable 'v2' is possibly undefined
// 63BFC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063C04) --------------------------------------------------------
int __cdecl trap_SnapVector(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(58, a1, v2, v3);
}
// 63C18: variable 'v2' is possibly undefined
// 63C18: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063C20) --------------------------------------------------------
int __cdecl trap_AddDebugString(int a1, int a2, int a3)
{
  return dword_7EC10(67, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063C48) --------------------------------------------------------
int __cdecl trap_AddDebugLine(int a1, int a2, int a3)
{
  return dword_7EC10(68, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063C7C) --------------------------------------------------------
int __cdecl trap_SetArchive(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(69, a1, v2, v3);
}
// 63C90: variable 'v2' is possibly undefined
// 63C90: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063C98) --------------------------------------------------------
int __cdecl trap_Z_MallocInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(70, a1, v2, v3);
}
// 63CAC: variable 'v2' is possibly undefined
// 63CAC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063CB4) --------------------------------------------------------
int __cdecl trap_Z_FreeInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(71, a1, v2, v3);
}
// 63CC8: variable 'v2' is possibly undefined
// 63CC8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063CD0) --------------------------------------------------------
int __cdecl trap_XAnimCreateTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(72, a1, v2, v3);
}
// 63CE4: variable 'v2' is possibly undefined
// 63CE4: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063CEC) --------------------------------------------------------
int __cdecl trap_XAnimCreateSmallTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(73, a1, v2, v3);
}
// 63D00: variable 'v2' is possibly undefined
// 63D00: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063D08) --------------------------------------------------------
int __cdecl trap_XAnimFreeSmallTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(74, a1, v2, v3);
}
// 63D1C: variable 'v2' is possibly undefined
// 63D1C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063D24) --------------------------------------------------------
int __cdecl trap_XModelExists(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(75, a1, v2, v3);
}
// 63D38: variable 'v2' is possibly undefined
// 63D38: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063D40) --------------------------------------------------------
int __cdecl trap_XModelGet(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(76, a1, v2, v3);
}
// 63D54: variable 'v2' is possibly undefined
// 63D54: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063D5C) --------------------------------------------------------
int __cdecl trap_DObjCreate(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(77, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063D8C) --------------------------------------------------------
int __cdecl trap_SafeDObjFree(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(79, a1, a2, v3);
}
// 63DA4: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063DAC) --------------------------------------------------------
int __cdecl trap_DObjExists(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(78, *a1, v2, v3);
}
// 63DC2: variable 'v2' is possibly undefined
// 63DC2: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063DC8) --------------------------------------------------------
int __cdecl trap_XAnimGetAnims(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(80, a1, v2, v3);
}
// 63DDC: variable 'v2' is possibly undefined
// 63DDC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063DE4) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2)
{
  int v2; // eax
  int v4; // [esp-14h] [ebp-2Ch]
  int v5; // [esp-10h] [ebp-28h]

  v2 = dword_7EC10(80, a2, v4, v5);
  *a1 = Scr_GetAnimsIndex(v2) << 16;
  return a1;
}
// 63E03: variable 'v4' is possibly undefined
// 63E03: variable 'v5' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063E28) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(82, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063E48) --------------------------------------------------------
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(83, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063E68) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(84, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063E88) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(85, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063EBC) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  return dword_7EC10(86, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063EF8) --------------------------------------------------------
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(87, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063F18) --------------------------------------------------------
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(88, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063F38) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(89, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063F6C) --------------------------------------------------------
int __cdecl trap_XAnimClearTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(90, a1, v2, v3);
}
// 63F80: variable 'v2' is possibly undefined
// 63F80: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063F88) --------------------------------------------------------
int __cdecl trap_XAnimHasTime(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-Ch]

  return dword_7EC10(91, HIWORD(a1), (unsigned __int16)a1, v2);
}
// 63FA3: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063FAC) --------------------------------------------------------
int __cdecl trap_XAnimIsPrimitive(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-Ch]

  return dword_7EC10(92, HIWORD(a1), (unsigned __int16)a1, v2);
}
// 63FC7: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063FD0) --------------------------------------------------------
int __cdecl trap_XAnimGetLength(int a1, unsigned __int16 a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(93, a1, a2, v3);
}
// 63FE9: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00063FF0) --------------------------------------------------------
long double __cdecl trap_XAnimGetLengthSeconds(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-1Ch]

  return COERCE_FLOAT(dword_7EC10(94, HIWORD(a1), (unsigned __int16)a1, v2));
}
// 6400B: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064018) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(95, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006404C) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(96, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064080) --------------------------------------------------------
int __cdecl trap_XAnimCalcAbsDelta(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(97, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000640A8) --------------------------------------------------------
int __cdecl trap_XAnimCalcDelta(int a1, unsigned __int16 a2, int a3)
{
  return dword_7EC10(98, a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000640D8) --------------------------------------------------------
int __cdecl trap_XAnimGetRelDelta(unsigned int a1, int a2)
{
  return dword_7EC10(99, HIWORD(a1), (unsigned __int16)a1, a2);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064110) --------------------------------------------------------
int __cdecl trap_XAnimGetAbsDelta(unsigned int a1, int a2)
{
  return dword_7EC10(100, HIWORD(a1), (unsigned __int16)a1, a2);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064144) --------------------------------------------------------
int __cdecl trap_XAnimIsLooped(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-Ch]

  return dword_7EC10(101, HIWORD(a1), (unsigned __int16)a1, v2);
}
// 6415F: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064168) --------------------------------------------------------
int __cdecl trap_XAnimNotetrackExists(unsigned int a1, unsigned __int16 a2)
{
  return dword_7EC10(102, HIWORD(a1), (unsigned __int16)a1, a2);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006418C) --------------------------------------------------------
long double __cdecl trap_XAnimGetTime(int a1, unsigned __int16 a2)
{
  int v3; // [esp-4h] [ebp-1Ch]

  return COERCE_FLOAT(dword_7EC10(103, a1, a2, v3));
}
// 641A5: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000641B4) --------------------------------------------------------
long double __cdecl trap_XAnimGetWeight(int a1, unsigned __int16 a2)
{
  int v3; // [esp-4h] [ebp-1Ch]

  return COERCE_FLOAT(dword_7EC10(104, a1, a2, v3));
}
// 641CD: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000641DC) --------------------------------------------------------
int __cdecl trap_DObjDumpInfo(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(105, *a1, v2, v3);
}
// 641F2: variable 'v2' is possibly undefined
// 641F2: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000641F8) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(106, *a1, a2, v3);
}
// 64212: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064218) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(107, *a1, a2, v3);
}
// 64232: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064238) --------------------------------------------------------
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3)
{
  return dword_7EC10(108, *a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006425C) --------------------------------------------------------
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(109, *a1, a2, v3);
}
// 64276: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006427C) --------------------------------------------------------
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1, int a2, int a3)
{
  return dword_7EC10(110, *a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000642A0) --------------------------------------------------------
int __cdecl trap_DObjCalcAnim(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(111, *a1, a2, v3);
}
// 642BA: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000642C0) --------------------------------------------------------
int __cdecl trap_DObjCalcSkel(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(112, *a1, a2, v3);
}
// 642DA: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000642E0) --------------------------------------------------------
int __cdecl trap_XAnimLoadAnimTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(113, a1, v2, v3);
}
// 642F4: variable 'v2' is possibly undefined
// 642F4: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000642FC) --------------------------------------------------------
int __cdecl trap_XAnimSaveAnimTree(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(114, a1, v2, v3);
}
// 64310: variable 'v2' is possibly undefined
// 64310: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064318) --------------------------------------------------------
int __cdecl trap_XAnimCloneAnimTree(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(115, a1, a2, v3);
}
// 64330: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064338) --------------------------------------------------------
int __cdecl trap_DObjNumBones(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(116, *a1, v2, v3);
}
// 6434E: variable 'v2' is possibly undefined
// 6434E: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064354) --------------------------------------------------------
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(117, *a1, a2, v3);
}
// 6436E: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064374) --------------------------------------------------------
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(118, *a1, v2, v3);
}
// 6438A: variable 'v2' is possibly undefined
// 6438A: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064390) --------------------------------------------------------
int __cdecl trap_DObjDisplayAnim(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(119, *a1, v2, v3);
}
// 643A6: variable 'v2' is possibly undefined
// 643A6: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000643AC) --------------------------------------------------------
int __cdecl trap_XAnimHasFinished(int a1, unsigned __int16 a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(120, a1, a2, v3);
}
// 643C5: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000643CC) --------------------------------------------------------
int __cdecl trap_XAnimGetNumChildren(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-Ch]

  return dword_7EC10(121, HIWORD(a1), (unsigned __int16)a1, v2);
}
// 643E7: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000643F0) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, unsigned int a2, int a3)
{
  int v3; // ebx

  HIWORD(v3) = HIWORD(a2);
  LOWORD(v3) = dword_7EC10(122, HIWORD(a2), (unsigned __int16)a2, a3);
  *a1 = v3;
  return a1;
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064428) --------------------------------------------------------
int __cdecl trap_XModelNumBones(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(123, a1, v2, v3);
}
// 6443C: variable 'v2' is possibly undefined
// 6443C: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064444) --------------------------------------------------------
int __cdecl trap_XModelGetBoneNames(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(124, a1, v2, v3);
}
// 64458: variable 'v2' is possibly undefined
// 64458: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064460) --------------------------------------------------------
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(125, *a1, v2, v3);
}
// 64476: variable 'v2' is possibly undefined
// 64476: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006447C) --------------------------------------------------------
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1, int a2, int a3)
{
  return dword_7EC10(126, *a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000644A0) --------------------------------------------------------
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1, int a2, int a3)
{
  return dword_7EC10(127, *a1, a2, a3);
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000644C4) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimName(unsigned int a1)
{
  int v2; // [esp-4h] [ebp-Ch]

  return dword_7EC10(128, HIWORD(a1), (unsigned __int16)a1, v2);
}
// 644E2: variable 'v2' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000644E8) --------------------------------------------------------
int __cdecl trap_DObjGetTree(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(129, *a1, v2, v3);
}
// 64501: variable 'v2' is possibly undefined
// 64501: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064508) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimTreeSize(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(130, a1, v2, v3);
}
// 6451F: variable 'v2' is possibly undefined
// 6451F: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064528) --------------------------------------------------------
int __cdecl trap_XModelDebugBoxes(_DWORD *a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(131, *a1, v2, v3);
}
// 64541: variable 'v2' is possibly undefined
// 64541: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064548) --------------------------------------------------------
int __cdecl trap_GetWeaponInfoMemory(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(132, a1, a2, v3);
}
// 64563: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006456C) --------------------------------------------------------
int __cdecl trap_FreeWeaponInfoMemory(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(133, a1, v2, v3);
}
// 64583: variable 'v2' is possibly undefined
// 64583: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006458C) --------------------------------------------------------
int trap_FreeClientScriptPers()
{
  int v1; // [esp-Ch] [ebp-14h]
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(134, v1, v2, v3);
}
// 6459F: variable 'v1' is possibly undefined
// 6459F: variable 'v2' is possibly undefined
// 6459F: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000645A8) --------------------------------------------------------
int __cdecl trap_Hunk_AllocInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(12, a1, v2, v3);
}
// 645BC: variable 'v2' is possibly undefined
// 645BC: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000645C4) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(13, a1, v2, v3);
}
// 645D8: variable 'v2' is possibly undefined
// 645D8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000645E0) --------------------------------------------------------
int __cdecl trap_Hunk_AllocAlignInternal(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(14, a1, a2, v3);
}
// 645F8: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064600) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1, int a2)
{
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(15, a1, a2, v3);
}
// 64618: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064620) --------------------------------------------------------
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(16, a1, v2, v3);
}
// 64634: variable 'v2' is possibly undefined
// 64634: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006463C) --------------------------------------------------------
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(17, a1, v2, v3);
}
// 64650: variable 'v2' is possibly undefined
// 64650: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064658) --------------------------------------------------------
int (__stdcall *__cdecl dllEntry(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD, _DWORD)))(_DWORD, _DWORD, _DWORD, _DWORD)
{
  int (__stdcall *result)(_DWORD, _DWORD, _DWORD, _DWORD); // eax

  result = a1;
  dword_7EC10 = a1;
  return result;
}
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064668) --------------------------------------------------------
int __cdecl PASSFLOAT(int a1)
{
  return a1;
}

//----- (00064674) --------------------------------------------------------
int __cdecl trap_RealTime(int a1)
{
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(57, a1, v2, v3);
}
// 64688: variable 'v2' is possibly undefined
// 64688: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00064690) --------------------------------------------------------
int trap_ResetEntityParsePoint()
{
  int v1; // [esp-Ch] [ebp-14h]
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  return dword_7EC10(135, v1, v2, v3);
}
// 646A3: variable 'v1' is possibly undefined
// 646A3: variable 'v2' is possibly undefined
// 646A3: variable 'v3' is possibly undefined
// 7EC10: using guessed type int (__stdcall *dword_7EC10)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000646B0) --------------------------------------------------------
void target_location_linkup()
{
  int v0; // edi
  int *v1; // ebx
  int i; // esi
  int v3; // eax

  if ( !level[1877] )
  {
    level[1877] = 1;
    level[1878] = 0;
    trap_SetConfigstring(44, (int)"unknown");
    v0 = 0;
    v1 = g_entities;
    for ( i = 1; v0 < level[3]; v1 += 197 )
    {
      if ( *((_WORD *)v1 + 187) == scr_const[67] )
      {
        v1[140] = i;
        v3 = SL_ConvertToString(*((_WORD *)v1 + 228));
        trap_SetConfigstring(i + 44, v3);
        ++i;
        v1[103] = level[1878];
        level[1878] = (int)v1;
      }
      ++v0;
    }
  }
}

//----- (00064764) --------------------------------------------------------
int __cdecl SP_target_location(int a1)
{
  Scr_SetString(a1 + 374, scr_const[67]);
  *(_DWORD *)(a1 + 512) = target_location_linkup;
  *(_DWORD *)(a1 + 508) = level[122] + 200;
  return G_SetOrigin(a1, (float *)(a1 + 308));
}

//----- (000647C0) --------------------------------------------------------
int __cdecl Team_GetLocationMsg(int a1, char *s, size_t maxlen)
{
  long double v3; // fst7
  int v4; // esi
  int i; // ebx
  long double v6; // fst5
  long double v7; // rtt
  long double v8; // fst5
  long double v9; // fst6
  long double v10; // fst5
  long double v11; // fst6
  int v13; // eax
  int v14; // eax
  int v15; // eax
  long double v16; // [esp+18h] [ebp-30h]
  float v17; // [esp+3Ch] [ebp-Ch] BYREF
  float v18; // [esp+40h] [ebp-8h]
  float v19; // [esp+44h] [ebp-4h]

  v3 = 201326590.0;
  v4 = 0;
  v17 = *(float *)(a1 + 308);
  v18 = *(float *)(a1 + 312);
  v19 = *(float *)(a1 + 316);
  for ( i = level[1878]; i; i = *(_DWORD *)(i + 412) )
  {
    v6 = v17 - *(float *)(i + 308);
    v7 = v6 * v6;
    v8 = v18 - *(float *)(i + 312);
    v9 = v7 + v8 * v8;
    v10 = v19 - *(float *)(i + 316);
    v11 = v9 + v10 * v10;
    if ( v11 <= v3 )
    {
      v16 = v3;
      v3 = v11;
      if ( trap_InPVS((int)&v17, i + 308) )
        v4 = i;
      else
        v3 = v16;
    }
  }
  if ( !v4 )
    return 0;
  v13 = *(_DWORD *)(v4 + 592);
  if ( v13 )
  {
    if ( v13 < 0 )
      *(_DWORD *)(v4 + 592) = 0;
    if ( *(int *)(v4 + 592) > 7 )
      *(_DWORD *)(v4 + 592) = 7;
    v14 = SL_ConvertToString(*(_WORD *)(v4 + 456));
    Com_sprintf(s, maxlen, (char *)&byte_79904, 94, *(_DWORD *)(v4 + 592) + 48, v14);
  }
  else
  {
    v15 = SL_ConvertToString(*(_WORD *)(v4 + 456));
    Com_sprintf(s, maxlen, (char *)&byte_79910, v15);
  }
  return 1;
}

//----- (00064910) --------------------------------------------------------
int __cdecl TeamplayInfoMessage(int a1)
{
  int v1; // edx
  int result; // eax
  long double v3; // fst7
  char v4; // fps^1
  long double v5; // fst6
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  int v9; // esi
  int v10; // edx
  float v11[9]; // [esp+14h] [ebp-94h] BYREF
  float v12; // [esp+38h] [ebp-70h]
  float v13; // [esp+3Ch] [ebp-6Ch]
  float v14; // [esp+40h] [ebp-68h]
  char v15[40]; // [esp+54h] [ebp-54h] BYREF
  unsigned __int16 v16; // [esp+7Ch] [ebp-2Ch]
  float v17; // [esp+84h] [ebp-24h]
  float v18; // [esp+88h] [ebp-20h]
  float v19; // [esp+8Ch] [ebp-1Ch]
  float v20; // [esp+90h] [ebp-18h] BYREF
  float v21; // [esp+94h] [ebp-14h]
  float v22; // [esp+98h] [ebp-10h]
  float v23[3]; // [esp+9Ch] [ebp-Ch] BYREF

  v1 = *(_DWORD *)(a1 + 344);
  if ( *(_DWORD *)(v1 + 8400) )
  {
    AngleVectors((float *)(v1 + 192), v23, 0, 0);
    CalcMuzzlePoint(a1, &v20);
    v5 = *(float *)(*(_DWORD *)(a1 + 344) + 208);
    v6 = v5 < 8.0;
    v7 = 0;
    v8 = v5 == 8.0;
    if ( (v4 & 0x45) == 1 )
      v22 = 8.0 - v5 + v22;
    v17 = v23[0] * 8192.0 + v20;
    v3 = 8192.0 * v23[2] + v22;
    v18 = v23[1] * 8192.0 + v21;
  }
  else
  {
    if ( !*(_DWORD *)(v1 + 8572) )
    {
      *(_DWORD *)(v1 + 256) = -1;
      result = *(_DWORD *)(a1 + 344);
      *(_DWORD *)(result + 260) = 0;
      return result;
    }
    CalcMuzzlePoints(a1, v11);
    v17 = v11[0] * 8192.0 + v12;
    v20 = v12;
    v18 = v11[1] * 8192.0 + v13;
    v21 = v13;
    v3 = v14 + 8192.0 * v11[2];
    v22 = v14;
  }
  v19 = v3;
  trap_Trace((int)v15, (int)&v20, (int)&vec3_origin);
  v9 = v16;
  if ( v16 <= 0x3Fu
    && g_entities[197 * v16 + 86]
    && (!G_IsPlaying(a1) || LOWORD(g_entities[197 * v9 + 118]) == *(_WORD *)(a1 + 472)) )
  {
    v10 = g_entities[197 * v9 + 140];
  }
  else
  {
    v9 = -1;
    v10 = 0;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 344) + 256) = v9;
  result = *(_DWORD *)(a1 + 344);
  *(_DWORD *)(result + 260) = v10;
  return result;
}
// 64A0C: variable 'v4' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (00064AEC) --------------------------------------------------------
_BOOL4 __cdecl OnSameTeam(int a1, int a2)
{
  int v2; // edx
  int v3; // ecx
  int v4; // eax
  _BOOL4 result; // eax

  v2 = *(_DWORD *)(a1 + 344);
  result = 0;
  if ( v2 )
  {
    v3 = *(_DWORD *)(a2 + 344);
    if ( v3 )
    {
      v4 = *(_DWORD *)(v2 + 8572);
      if ( v4 )
      {
        if ( v4 == *(_DWORD *)(v3 + 8572) )
          result = 1;
      }
    }
  }
  return result;
}

//----- (00064B2C) --------------------------------------------------------
int __cdecl Team_GetLocation(float *a1)
{
  long double v1; // fst7
  int v2; // esi
  int i; // ebx
  long double v4; // fst5
  long double v5; // rtt
  long double v6; // fst5
  long double v7; // fst6
  long double v8; // fst5
  long double v9; // fst6
  long double v11; // [esp+18h] [ebp-30h]
  float v12; // [esp+3Ch] [ebp-Ch] BYREF
  float v13; // [esp+40h] [ebp-8h]
  float v14; // [esp+44h] [ebp-4h]

  v1 = 201326590.0;
  v2 = 0;
  v12 = a1[77];
  v13 = a1[78];
  v14 = a1[79];
  for ( i = level[1878]; i; i = *(_DWORD *)(i + 412) )
  {
    v4 = v12 - *(float *)(i + 308);
    v5 = v4 * v4;
    v6 = v13 - *(float *)(i + 312);
    v7 = v5 + v6 * v6;
    v8 = v14 - *(float *)(i + 316);
    v9 = v7 + v8 * v8;
    if ( v9 <= v1 )
    {
      v11 = v1;
      v1 = v9;
      if ( trap_InPVS((int)&v12, i + 308) )
        v2 = i;
      else
        v1 = v11;
    }
  }
  return v2;
}

//----- (00064BE4) --------------------------------------------------------
int CheckTeamStatus()
{
  int result; // eax
  int v1; // esi
  int *v2; // ebx

  result = level[122] - level[130];
  if ( result > 0 )
  {
    level[130] = level[122];
    v1 = 0;
    if ( (int)g_maxclients[3] > 0 )
    {
      v2 = g_entities;
      do
      {
        if ( *((_BYTE *)v2 + 352) )
        {
          result = v2[86];
          if ( (*(_BYTE *)(result + 14) & 1) == 0 )
            result = TeamplayInfoMessage((int)v2);
        }
        v2 += 197;
        ++v1;
      }
      while ( v1 < g_maxclients[3] );
    }
  }
  return result;
}

//----- (00064C50) --------------------------------------------------------
int __cdecl SP_trigger_multiple(int a1)
{
  char v1; // fps^1
  long double v2; // fst7
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  char v11; // fps^1
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst7
  char v16; // fps^1
  long double v17; // fst6
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst7
  char v22; // fps^1
  long double v23; // fst6
  bool v24; // c0
  char v25; // c2
  bool v26; // c3

  G_SpawnFloat("wait", (int)&unk_79940, a1 + 616);
  G_SpawnFloat("random", (int)"0", a1 + 620);
  v2 = *(float *)(a1 + 616);
  v3 = v2 < *(float *)(a1 + 620);
  v4 = 0;
  v5 = v2 == *(float *)(a1 + 620);
  if ( (unsigned __int8)((v1 & 0x45) - 1) < 0x40u )
  {
    v7 = v2 > 0.0;
    v8 = 0;
    v9 = 0.0 == v2;
    if ( (unsigned __int8)((v6 & 0x45) - 1) < 0x40u )
    {
      *(float *)(a1 + 620) = v2 - 100.0;
      G_Printf("trigger_multiple has random >= wait\n");
    }
  }
  v10 = *(float *)(a1 + 320);
  *(_DWORD *)(a1 + 524) = Touch_Multi;
  *(_DWORD *)(a1 + 528) = Use_Multi;
  v12 = v10 > 0.0;
  v13 = 0;
  v14 = 0.0 == v10;
  if ( (v11 & 0x44) != 0x40 )
    goto LABEL_7;
  v15 = *(float *)(a1 + 324);
  v17 = *(&vec3_origin + 1);
  v18 = v17 < v15;
  v19 = 0;
  v20 = v17 == v15;
  if ( (v16 & 0x44) != 0x40
    || (v21 = *(float *)(a1 + 328),
        v23 = *(&vec3_origin + 2),
        v24 = v23 < v21,
        v25 = 0,
        v26 = v23 == v21,
        (v22 & 0x45) != 64) )
  {
LABEL_7:
    G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  }
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  *(_DWORD *)(a1 + 280) = 0;
  if ( (*(_BYTE *)(a1 + 376) & 8) == 0 )
    *(_DWORD *)(a1 + 280) = 0x40000000;
  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
    *(_BYTE *)(a1 + 282) |= 4u;
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 282) |= 8u;
  if ( (*(_BYTE *)(a1 + 376) & 4) != 0 )
    *(_BYTE *)(a1 + 282) |= 0x10u;
  return trap_LinkEntity(a1);
}
// 64C9D: variable 'v1' is possibly undefined
// 64CAD: variable 'v6' is possibly undefined
// 64CFB: variable 'v11' is possibly undefined
// 64D13: variable 'v16' is possibly undefined
// 64D2B: variable 'v22' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (00064DC4) --------------------------------------------------------
void __cdecl hurt_touch(int a1, int a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  if ( *(_BYTE *)(a2 + 369) && *(_DWORD *)(a1 + 460) <= level[122] )
  {
    if ( Scr_IsSystemActive(1u) )
    {
      v2 = level[2683];
      if ( v2 == 256 )
      {
        Scr_AddEntity((int *)a2);
        Scr_Notify((int *)a1, scr_const[73], 1);
      }
      else
      {
        level[2683] = v2 + 1;
        v3 = 3 * v2;
        LOWORD(level[v3 + 1915]) = *(_WORD *)a1;
        HIWORD(level[v3 + 1915]) = *(_WORD *)a2;
        level[v3 + 1916] = *(_DWORD *)(a1 + 768);
        level[v3 + 1917] = *(_DWORD *)(a2 + 768);
      }
    }
    if ( (*(_BYTE *)(a1 + 376) & 0x10) != 0 )
      v4 = level[122] + 1000;
    else
      v4 = level[122] + 100;
    *(_DWORD *)(a1 + 460) = v4;
    if ( (*(_BYTE *)(a1 + 376) & 4) == 0 )
      G_PlaySoundAliasAtPoint((float *)(a2 + 308), *(unsigned __int8 *)(a1 + 366));
    G_Damage(
      (int *)a2,
      (int *)a1,
      (int *)a1,
      0,
      0,
      *(_DWORD *)(a1 + 568),
      16 * ((*(_BYTE *)(a1 + 376) & 8) != 0),
      0x17u,
      0);
    if ( (*(_BYTE *)(a1 + 376) & 0x20) != 0 )
      *(_DWORD *)(a1 + 524) = 0;
  }
}

//----- (00064EF8) --------------------------------------------------------
void __cdecl SP_trigger_hurt(int a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  char *nptr; // [esp+Ch] [ebp-Ch] BYREF
  char *s2; // [esp+10h] [ebp-8h] BYREF

  v2 = *(float *)(a1 + 320);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) != 0x40 )
    goto LABEL_4;
  v6 = *(float *)(a1 + 324);
  v8 = *(&vec3_origin + 1);
  v9 = v8 < v6;
  v10 = 0;
  v11 = v8 == v6;
  if ( (v7 & 0x44) != 0x40
    || (v12 = *(float *)(a1 + 328),
        v14 = *(&vec3_origin + 2),
        v15 = v14 < v12,
        v16 = 0,
        v17 = v14 == v12,
        (v13 & 0x45) != 64) )
  {
LABEL_4:
    G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  }
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 280) = 1079771144;
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  G_SpawnString("sound", (int)"world_hurt_me", (int)&s2);
  *(_BYTE *)(a1 + 366) = G_SoundAliasIndex(s2);
  if ( !*(_DWORD *)(a1 + 568) )
    *(_DWORD *)(a1 + 568) = 5;
  *(_DWORD *)(a1 + 280) = 1079771144;
  *(_DWORD *)(a1 + 528) = hurt_use;
  if ( (*(_BYTE *)(a1 + 376) & 1) == 0 )
    *(_DWORD *)(a1 + 524) = hurt_touch;
  G_SpawnString("life", (int)"0", (int)&nptr);
  *(float *)(a1 + 628) = _strtod_internal(nptr, 0, 0);
}
// 64F12: variable 'v1' is possibly undefined
// 64F2A: variable 'v7' is possibly undefined
// 64F42: variable 'v13' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (00065024) --------------------------------------------------------
int __cdecl Respond_trigger_damage(int a1, int a2)
{
  int v2; // eax

  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 && a2 == 1 )
    return 0;
  v2 = *(_DWORD *)(a1 + 376);
  if ( (v2 & 2) != 0 && a2 == 2 )
    return 0;
  if ( (v2 & 4) != 0 && a2 <= 6 && a2 >= 3 )
    return 0;
  if ( (v2 & 8) != 0 )
  {
    switch ( a2 )
    {
      case 3:
      case 4:
      case 5:
      case 6:
      case 9:
      case 10:
      case 13:
      case 14:
      case 15:
      case 24:
        return 0;
      default:
        break;
    }
  }
  if ( (v2 & 0x10) != 0 )
  {
    if ( a2 != 6 )
    {
      if ( a2 > 6 )
      {
        if ( a2 != 10 && a2 != 14 )
          goto LABEL_17;
      }
      else if ( a2 != 4 )
      {
        goto LABEL_17;
      }
    }
    return 0;
  }
LABEL_17:
  if ( (v2 & 0x20) != 0 && a2 == 7 || (v2 & 0x40) != 0 && a2 == 18 )
    return 0;
  if ( (v2 & 0x100) != 0 )
  {
    switch ( a2 )
    {
      case 0:
      case 11:
      case 12:
      case 16:
      case 17:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
        return 0;
      default:
        return 1;
    }
  }
  return 1;
}

//----- (000650C0) --------------------------------------------------------
void __cdecl Activate_trigger_damage(int a1, int *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // eax
  int v7; // edx
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  int v12; // eax

  if ( !*(_DWORD *)(a1 + 508) || *(int (__cdecl **)(int))(a1 + 512) == Think_GeneralLink )
  {
    v4 = *(_DWORD *)(a1 + 680);
    if ( v4 <= 0 || a3 >= v4 )
    {
      if ( Respond_trigger_damage(a1, a4) )
      {
        v5 = *(_DWORD *)(a1 + 592);
        if ( !v5 || 32000 - *(_DWORD *)(a1 + 560) >= v5 )
        {
          *(_DWORD *)(a1 + 604) = a2;
          if ( a4 != -1 && Scr_IsSystemActive(1u) )
          {
            v6 = level[2683];
            if ( v6 == 256 )
            {
              Scr_AddEntity(a2);
              Scr_Notify((int *)a1, scr_const[73], 1);
            }
            else
            {
              level[2683] = v6 + 1;
              v7 = 3 * v6;
              LOWORD(level[v7 + 1915]) = *(_WORD *)a1;
              HIWORD(level[v7 + 1915]) = *(_WORD *)a2;
              level[v7 + 1916] = *(_DWORD *)(a1 + 768);
              level[v7 + 1917] = a2[192];
            }
          }
          if ( *(int (__cdecl **)(int))(a1 + 512) != Think_GeneralLink )
          {
            v9 = *(float *)(a1 + 616) > 0.0;
            v10 = 0;
            v11 = 0.0 == *(float *)(a1 + 616);
            if ( (v8 & 0x45) == 1 )
            {
              *(_DWORD *)(a1 + 512) = multi_wait;
              v12 = rand();
              *(_DWORD *)(a1 + 508) = level[122]
                                    + (int)((((long double)v12 * -4.6566129e-10 + (long double)v12 * -4.6566129e-10 - 1.0)
                                           * *(float *)(a1 + 620)
                                           + *(float *)(a1 + 616))
                                          * 1000.0);
            }
            else
            {
              *(_DWORD *)(a1 + 524) = 0;
              *(_DWORD *)(a1 + 508) = level[122] + 100;
              *(_DWORD *)(a1 + 512) = G_FreeEntity;
            }
          }
          *(_DWORD *)(a1 + 560) = 32000;
        }
      }
    }
  }
}
// 651D2: variable 'v8' is possibly undefined

//----- (00065278) --------------------------------------------------------
int __cdecl SP_trigger_damage(int a1)
{
  char v1; // fps^1
  long double v2; // fst7
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  char v6; // fps^1
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  long double v10; // fst7
  char v11; // fps^1
  bool v12; // c0
  char v13; // c2
  bool v14; // c3
  long double v15; // fst7
  char v16; // fps^1
  long double v17; // fst6
  bool v18; // c0
  char v19; // c2
  bool v20; // c3
  long double v21; // fst7
  char v22; // fps^1
  long double v23; // fst6
  bool v24; // c0
  char v25; // c2
  bool v26; // c3

  G_SpawnFloat("wait", (int)&unk_79940, a1 + 616);
  G_SpawnFloat("random", (int)"0", a1 + 620);
  v2 = *(float *)(a1 + 616);
  v3 = v2 < *(float *)(a1 + 620);
  v4 = 0;
  v5 = v2 == *(float *)(a1 + 620);
  if ( (unsigned __int8)((v1 & 0x45) - 1) < 0x40u )
  {
    v7 = v2 > 0.0;
    v8 = 0;
    v9 = 0.0 == v2;
    if ( (unsigned __int8)((v6 & 0x45) - 1) < 0x40u )
    {
      *(float *)(a1 + 620) = v2 - 100.0;
      G_Printf("trigger_damage has random >= wait\n");
    }
  }
  G_SpawnInt("accumulate", (int)"0", a1 + 592);
  G_SpawnInt("threshold", (int)"0", a1 + 680);
  v10 = *(float *)(a1 + 320);
  *(_DWORD *)(a1 + 560) = 32000;
  *(_BYTE *)(a1 + 369) = 1;
  *(_DWORD *)(a1 + 528) = Use_trigger_damage;
  *(_DWORD *)(a1 + 532) = Pain_trigger_damage;
  *(_DWORD *)(a1 + 536) = Die_trigger_damage;
  v12 = v10 > 0.0;
  v13 = 0;
  v14 = 0.0 == v10;
  if ( (v11 & 0x44) != 0x40 )
    goto LABEL_7;
  v15 = *(float *)(a1 + 324);
  v17 = *(&vec3_origin + 1);
  v18 = v17 < v15;
  v19 = 0;
  v20 = v17 == v15;
  if ( (v16 & 0x44) != 0x40
    || (v21 = *(float *)(a1 + 328),
        v23 = *(&vec3_origin + 2),
        v24 = v23 < v21,
        v25 = 0,
        v26 = v23 == v21,
        (v22 & 0x45) != 64) )
  {
LABEL_7:
    G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  }
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 280) = 1079771144;
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  return trap_LinkEntity(a1);
}
// 652C5: variable 'v1' is possibly undefined
// 652D5: variable 'v6' is possibly undefined
// 65373: variable 'v11' is possibly undefined
// 6538B: variable 'v16' is possibly undefined
// 653A3: variable 'v22' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (000653F8) --------------------------------------------------------
void __cdecl G_CheckHitTriggerDamage(int *a1, float *a2, float *a3, int a4, int a5)
{
  long double v5; // fst7
  long double v6; // fst5
  int i; // edi
  int *v8; // esi
  int v9; // [esp+14h] [ebp-1034h]
  float v10[3]; // [esp+30h] [ebp-1018h] BYREF
  float v11; // [esp+3Ch] [ebp-100Ch] BYREF
  float v12; // [esp+40h] [ebp-1008h]
  float v13; // [esp+44h] [ebp-1004h]
  _DWORD v14[1024]; // [esp+48h] [ebp-1000h] BYREF

  v5 = *a2;
  v11 = *a2;
  v12 = a2[1];
  v6 = a2[2];
  v13 = a2[2];
  v10[0] = v5;
  v10[1] = v12;
  v10[2] = v6;
  AddPointToBounds(a3, &v11, v10);
  v9 = trap_EntitiesInBox((int)&v11, (int)v10, (int)v14);
  for ( i = 0; i < v9; ++i )
  {
    v8 = &g_entities[197 * v14[i]];
    if ( *((_WORD *)v8 + 187) == scr_const[75] && trap_SightTraceToEntity((int)a2, (int)&vec3_origin, (int)&vec3_origin) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v8, scr_const[13], 2);
      Activate_trigger_damage((int)v8, a1, a4, a5);
      if ( !v8[148] )
        v8[140] = 32000;
    }
  }
}
// 72910: using guessed type float vec3_origin;
// 21DF80: using guessed type int g_entities[];

//----- (000655A0) --------------------------------------------------------
void __cdecl G_GrenadeTouchTriggerDamage(int *a1, float *a2, float *a3, int a4, int a5)
{
  long double v5; // fst7
  long double v6; // fst5
  int i; // edi
  int *v8; // esi
  int v9; // [esp+1Ch] [ebp-101Ch]
  float v10[3]; // [esp+20h] [ebp-1018h] BYREF
  float v11; // [esp+2Ch] [ebp-100Ch] BYREF
  float v12; // [esp+30h] [ebp-1008h]
  float v13; // [esp+34h] [ebp-1004h]
  _DWORD v14[1024]; // [esp+38h] [ebp-1000h] BYREF

  v5 = *a2;
  v11 = *a2;
  v12 = a2[1];
  v6 = a2[2];
  v13 = a2[2];
  v10[0] = v5;
  v10[1] = v12;
  v10[2] = v6;
  AddPointToBounds(a3, &v11, v10);
  v9 = trap_EntitiesInBox((int)&v11, (int)v10, (int)v14);
  for ( i = 0; i < v9; ++i )
  {
    v8 = &g_entities[197 * v14[i]];
    if ( *((_WORD *)v8 + 187) == scr_const[75]
      && *((__int16 *)v8 + 190) < 0
      && trap_SightTraceToEntity((int)a2, (int)&vec3_origin, (int)&vec3_origin) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v8, scr_const[13], 2);
      Activate_trigger_damage((int)v8, a1, a4, a5);
      if ( !v8[148] )
        v8[140] = 32000;
    }
  }
}
// 72910: using guessed type float vec3_origin;

//----- (000656F0) --------------------------------------------------------
int __cdecl G_Trigger(int *a1, int *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx

  result = Scr_IsSystemActive(1u);
  if ( result )
  {
    v3 = level[2683];
    if ( v3 == 256 )
    {
      Scr_AddEntity(a2);
      result = Scr_Notify(a1, scr_const[73], 1);
    }
    else
    {
      level[2683] = v3 + 1;
      v4 = 3 * v3;
      LOWORD(level[v4 + 1915]) = *(_WORD *)a1;
      HIWORD(level[v4 + 1915]) = *(_WORD *)a2;
      level[v4 + 1916] = a1[192];
      result = a2[192];
      level[v4 + 1917] = result;
    }
  }
  return result;
}

//----- (00065784) --------------------------------------------------------
int __cdecl InitTrigger(int a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3
  int result; // eax

  v2 = *(float *)(a1 + 320);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) != 0x40 )
    goto LABEL_4;
  v6 = *(float *)(a1 + 324);
  v8 = *(&vec3_origin + 1);
  v9 = v8 < v6;
  v10 = 0;
  v11 = v8 == v6;
  if ( (v7 & 0x44) != 0x40
    || (v12 = *(float *)(a1 + 328),
        v14 = *(&vec3_origin + 2),
        v15 = v14 < v12,
        v16 = 0,
        v17 = v14 == v12,
        (v13 & 0x45) != 64) )
  {
LABEL_4:
    G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  }
  result = trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 280) = 1079771144;
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  return result;
}
// 6579E: variable 'v1' is possibly undefined
// 657B6: variable 'v7' is possibly undefined
// 657CE: variable 'v13' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (00065818) --------------------------------------------------------
int __cdecl InitSentientTrigger(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 280) = 0;
  if ( (*(_BYTE *)(a1 + 376) & 8) == 0 )
    *(_DWORD *)(a1 + 280) = 0x40000000;
  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
    *(_BYTE *)(a1 + 282) |= 4u;
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 282) |= 8u;
  if ( (*(_BYTE *)(a1 + 376) & 4) != 0 )
    *(_BYTE *)(a1 + 282) |= 0x10u;
  return result;
}

//----- (00065870) --------------------------------------------------------
int __cdecl multi_wait(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 508) = 0;
  return result;
}

//----- (00065884) --------------------------------------------------------
int __cdecl multi_trigger(int a1, int a2)
{
  int result; // eax
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  int v7; // eax

  result = a2;
  *(_DWORD *)(a1 + 604) = a2;
  if ( *(int (__cdecl **)(int))(a1 + 512) != Think_GeneralLink && !*(_DWORD *)(a1 + 508) )
  {
    v4 = *(float *)(a1 + 616) > 0.0;
    v5 = 0;
    v6 = 0.0 == *(float *)(a1 + 616);
    if ( (v3 & 0x45) == 1 )
    {
      *(_DWORD *)(a1 + 512) = multi_wait;
      v7 = rand();
      result = level[122]
             + (int)((((long double)v7 * -4.6566129e-10 + (long double)v7 * -4.6566129e-10 - 1.0) * *(float *)(a1 + 620)
                    + *(float *)(a1 + 616))
                   * 1000.0);
      *(_DWORD *)(a1 + 508) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 524) = 0;
      result = level[122] + 100;
      *(_DWORD *)(a1 + 508) = result;
      *(_DWORD *)(a1 + 512) = G_FreeEntity;
    }
  }
  return result;
}
// 658BE: variable 'v3' is possibly undefined

//----- (0006594C) --------------------------------------------------------
int __cdecl Use_Multi(int a1, int a2, int a3)
{
  int result; // eax
  char v4; // fps^1
  bool v5; // c0
  char v6; // c2
  bool v7; // c3
  int v8; // eax

  result = a3;
  *(_DWORD *)(a1 + 604) = a3;
  if ( *(int (__cdecl **)(int))(a1 + 512) != Think_GeneralLink && !*(_DWORD *)(a1 + 508) )
  {
    v5 = *(float *)(a1 + 616) > 0.0;
    v6 = 0;
    v7 = 0.0 == *(float *)(a1 + 616);
    if ( (v4 & 0x45) == 1 )
    {
      *(_DWORD *)(a1 + 512) = multi_wait;
      v8 = rand();
      result = level[122]
             + (int)((((long double)v8 * -4.6566129e-10 + (long double)v8 * -4.6566129e-10 - 1.0) * *(float *)(a1 + 620)
                    + *(float *)(a1 + 616))
                   * 1000.0);
      *(_DWORD *)(a1 + 508) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 524) = 0;
      result = level[122] + 100;
      *(_DWORD *)(a1 + 508) = result;
      *(_DWORD *)(a1 + 512) = G_FreeEntity;
    }
  }
  return result;
}
// 65986: variable 'v4' is possibly undefined

//----- (00065A18) --------------------------------------------------------
int __cdecl Touch_Multi(int a1, int *a2)
{
  int result; // eax
  int v3; // eax
  int v4; // edx
  char v5; // fps^1
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  int v9; // eax

  result = Scr_IsSystemActive(1u);
  if ( result )
  {
    v3 = level[2683];
    if ( v3 == 256 )
    {
      Scr_AddEntity(a2);
      result = Scr_Notify((int *)a1, scr_const[73], 1);
    }
    else
    {
      level[2683] = v3 + 1;
      v4 = 3 * v3;
      LOWORD(level[v4 + 1915]) = *(_WORD *)a1;
      HIWORD(level[v4 + 1915]) = *(_WORD *)a2;
      level[v4 + 1916] = *(_DWORD *)(a1 + 768);
      result = a2[192];
      level[v4 + 1917] = result;
    }
  }
  *(_DWORD *)(a1 + 604) = a2;
  if ( *(int (__cdecl **)(int))(a1 + 512) != Think_GeneralLink && !*(_DWORD *)(a1 + 508) )
  {
    v6 = *(float *)(a1 + 616) > 0.0;
    v7 = 0;
    v8 = 0.0 == *(float *)(a1 + 616);
    if ( (v5 & 0x45) == 1 )
    {
      *(_DWORD *)(a1 + 512) = multi_wait;
      v9 = rand();
      result = level[122]
             + (int)((((long double)v9 * -4.6566129e-10 + (long double)v9 * -4.6566129e-10 - 1.0) * *(float *)(a1 + 620)
                    + *(float *)(a1 + 616))
                   * 1000.0);
      *(_DWORD *)(a1 + 508) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 524) = 0;
      result = level[122] + 100;
      *(_DWORD *)(a1 + 508) = result;
      *(_DWORD *)(a1 + 512) = G_FreeEntity;
    }
  }
  return result;
}
// 65AC9: variable 'v5' is possibly undefined

//----- (00065B5C) --------------------------------------------------------
unsigned __int16 __cdecl hurt_think(void *s)
{
  __int16 v1; // fps
  long double v2; // fst7
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  unsigned __int16 result; // ax

  *((_DWORD *)s + 127) = level[122] + 100;
  v2 = (long double)level[122];
  v3 = v2 < *((float *)s + 154);
  v4 = 0;
  v5 = v2 == *((float *)s + 154);
  LOBYTE(result) = v1;
  HIBYTE(result) = HIBYTE(v1) & 0x45;
  if ( v2 > *((float *)s + 154) )
    result = (unsigned __int16)G_FreeEntity(s);
  return result;
}

//----- (00065B94) --------------------------------------------------------
__int16 __cdecl hurt_use(int a1)
{
  __int16 v1; // fps
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  int v6; // eax

  if ( *(_DWORD *)(a1 + 524) )
    *(_DWORD *)(a1 + 524) = 0;
  else
    *(_DWORD *)(a1 + 524) = hurt_touch;
  v2 = *(float *)(a1 + 628);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  LOBYTE(v6) = v1;
  BYTE1(v6) = HIBYTE(v1) & 0x45;
  if ( (HIBYTE(v1) & 0x45) != 64 )
  {
    *(_DWORD *)(a1 + 508) = level[122] + 50;
    *(_DWORD *)(a1 + 512) = hurt_think;
    v6 = level[122];
    *(float *)(a1 + 616) = v2 * 1000.0 + (long double)v6;
  }
  return v6;
}

//----- (00065C0C) --------------------------------------------------------
int __cdecl SP_trigger_once(int a1)
{
  char v1; // fps^1
  long double v2; // fst6
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  long double v6; // fst7
  char v7; // fps^1
  long double v8; // fst6
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  char v13; // fps^1
  long double v14; // fst6
  bool v15; // c0
  char v16; // c2
  bool v17; // c3

  *(float *)(a1 + 616) = -1.0;
  *(_DWORD *)(a1 + 524) = Touch_Multi;
  *(_DWORD *)(a1 + 528) = Use_Multi;
  v2 = *(float *)(a1 + 320);
  v3 = v2 < 0.0;
  v4 = 0;
  v5 = v2 == 0.0;
  if ( (v1 & 0x44) != 0x40 )
    goto LABEL_4;
  v6 = *(float *)(a1 + 324);
  v8 = *(&vec3_origin + 1);
  v9 = v8 < v6;
  v10 = 0;
  v11 = v8 == v6;
  if ( (v7 & 0x44) != 0x40
    || (v12 = *(float *)(a1 + 328),
        v14 = *(&vec3_origin + 2),
        v15 = v14 < v12,
        v16 = 0,
        v17 = v14 == v12,
        (v13 & 0x45) != 64) )
  {
LABEL_4:
    G_SetMovedir((float *)(a1 + 320), (float *)(a1 + 488));
  }
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  *(_DWORD *)(a1 + 280) = 0;
  if ( (*(_BYTE *)(a1 + 376) & 8) == 0 )
    *(_DWORD *)(a1 + 280) = 0x40000000;
  if ( (*(_BYTE *)(a1 + 376) & 1) != 0 )
    *(_BYTE *)(a1 + 282) |= 4u;
  if ( (*(_BYTE *)(a1 + 376) & 2) != 0 )
    *(_BYTE *)(a1 + 282) |= 8u;
  if ( (*(_BYTE *)(a1 + 376) & 4) != 0 )
    *(_BYTE *)(a1 + 282) |= 0x10u;
  return trap_LinkEntity(a1);
}
// 65C46: variable 'v1' is possibly undefined
// 65C5E: variable 'v7' is possibly undefined
// 65C76: variable 'v13' is possibly undefined
// 72910: using guessed type float vec3_origin;

//----- (00065D10) --------------------------------------------------------
void __cdecl Use_trigger_damage(int a1, int *a2)
{
  Activate_trigger_damage(a1, a2, *(_DWORD *)(a1 + 592) + 1, -1);
}

//----- (00065D34) --------------------------------------------------------
void __cdecl Pain_trigger_damage(int a1, int *a2, int a3, int a4, int a5)
{
  Activate_trigger_damage(a1, a2, a3, a5);
  if ( !*(_DWORD *)(a1 + 592) )
    *(_DWORD *)(a1 + 560) = 32000;
}

//----- (00065D6C) --------------------------------------------------------
void __cdecl Die_trigger_damage(int a1, int a2, int *a3, int a4, int a5)
{
  Activate_trigger_damage(a1, a3, a4, a5);
  if ( !*(_DWORD *)(a1 + 592) )
    *(_DWORD *)(a1 + 560) = 32000;
}

//----- (00065DA4) --------------------------------------------------------
int __cdecl explosive_indicator_think(_DWORD *a1)
{
  int *v1; // edx
  int result; // eax

  v1 = &g_entities[197 * a1[83]];
  if ( !*((_BYTE *)v1 + 352) || *((_WORD *)v1 + 187) != scr_const[120] )
    a1[128] = G_FreeEntity;
  result = level[122] + 100;
  a1[127] = result;
  return result;
}

//----- (00065DF0) --------------------------------------------------------
int __cdecl SP_trigger_lookat(int a1)
{
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 280) = 0x20000000;
  *(_DWORD *)(a1 + 244) = 1;
  *(_BYTE *)(a1 + 8) |= 2u;
  return trap_LinkEntity(a1);
}

//----- (00065E30) --------------------------------------------------------
int __cdecl G_LocalizedStringIndex(char *s2)
{
  int v1; // edi
  int i; // ebx
  const char *v3; // eax
  char *v4; // eax

  if ( !*s2 )
    return 0;
  v1 = level[7];
  if ( !s2 )
    return 0;
  for ( i = 1; i < 256; ++i )
  {
    v3 = (const char *)trap_GetConfigstringConst(i + 1244);
    if ( !*v3 )
      break;
    if ( !strcasecmp(v3, s2) )
      return i;
  }
  if ( !v1 )
  {
    if ( "localized string" )
    {
      v4 = va("%s \"%s\" not precached", "localized string", s2);
      Scr_Error((int)v4);
    }
    return 0;
  }
  if ( i == 256 )
    G_Error("G_FindConfigstringIndex: overflow");
  trap_SetConfigstring(i + 1244, (int)s2);
  return i;
}

//----- (00065EE8) --------------------------------------------------------
int __cdecl G_ShaderIndex(char *s2)
{
  int v1; // edi
  int i; // ebx
  const char *v3; // eax
  char *v4; // eax

  v1 = level[7];
  if ( s2 && *s2 )
  {
    for ( i = 1; i < 128; ++i )
    {
      v3 = (const char *)trap_GetConfigstringConst(i + 1500);
      if ( !*v3 )
        break;
      if ( !strcasecmp(v3, s2) )
        return i;
    }
    if ( v1 )
    {
      if ( i == 128 )
        G_Error("G_FindConfigstringIndex: overflow");
      trap_SetConfigstring(i + 1500, (int)s2);
      return i;
    }
    if ( "shader" )
    {
      v4 = va("%s \"%s\" not precached", "shader", s2);
      Scr_Error((int)v4);
    }
  }
  return 0;
}

//----- (00065FA4) --------------------------------------------------------
int __cdecl G_EffectIndex(char *s2)
{
  int v1; // edi
  int i; // ebx
  const char *v3; // eax
  char *v4; // eax

  v1 = level[7];
  if ( s2 && *s2 )
  {
    for ( i = 1; i < 64; ++i )
    {
      v3 = (const char *)trap_GetConfigstringConst(i + 780);
      if ( !*v3 )
        break;
      if ( !strcasecmp(v3, s2) )
        return i;
    }
    if ( v1 )
    {
      if ( i == 64 )
        G_Error("G_FindConfigstringIndex: overflow");
      trap_SetConfigstring(i + 780, (int)s2);
      return i;
    }
    if ( "effect" )
    {
      v4 = va("%s \"%s\" not precached", "effect", s2);
      Scr_Error((int)v4);
    }
  }
  return 0;
}

//----- (00066054) --------------------------------------------------------
int __cdecl G_DObjUpdate(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // eax
  int v4; // edi
  int v5; // ebx
  int v6; // esi
  int v7; // [esp+20h] [ebp-68h]
  unsigned __int16 v8; // [esp+24h] [ebp-64h]
  int v9; // [esp+28h] [ebp-60h] BYREF
  int v10; // [esp+2Ch] [ebp-5Ch]
  __int16 v11[44]; // [esp+30h] [ebp-58h]

  result = a1;
  if ( !*(_DWORD *)(a1 + 344) )
  {
    G_SafeDObjFree((int *)a1);
    v2 = *(unsigned __int8 *)(a1 + 373);
    if ( *(_BYTE *)(a1 + 373) )
    {
      Scr_GetEntityId(*(_DWORD *)a1, 0);
      v9 = dword_ACD00[v2];
      v10 = 0;
      v11[0] = -(__int16)v2;
      v8 = 1;
      v3 = *(_DWORD *)(a1 + 4);
      if ( !v3 || v3 == 8 || v3 == 11 )
        *(_DWORD *)(a1 + 140) = v2;
      v4 = 0;
      v7 = a1 + 748;
      v5 = 6;
      do
      {
        v6 = *(unsigned __int8 *)(v4 + v7);
        if ( *(_BYTE *)(v4 + v7) )
        {
          *(int *)((char *)&v9 + v5 * 2) = dword_ACD00[v6];
          *(int *)((char *)&v10 + v5 * 2) = SL_ConvertToString(*(_WORD *)(a1 + 754 + 2 * v4));
          v11[v5] = -(__int16)v6;
          v5 += 6;
          ++v8;
        }
        ++v4;
      }
      while ( v4 <= 5 );
      trap_DObjCreate((int)&v9, v8, 0);
      result = G_UpdateTagInfoOfChildren(a1, 1);
    }
    else
    {
      result = G_UpdateTagInfoOfChildren(a1, 0);
    }
  }
  return result;
}

//----- (00066190) --------------------------------------------------------
int __cdecl G_EntAttach(int a1, char *s2, int a3)
{
  int v3; // edi
  char v4; // al
  int v5; // ebx
  const char *v6; // eax
  char *v7; // eax
  int v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v3 = 0;
  v11 = a1 + 748;
  while ( *(_BYTE *)(v3 + v11) )
  {
    if ( ++v3 > 5 )
      return 0;
  }
  if ( *s2 )
  {
    v5 = 1;
    v10 = 2 * v3;
    v9 = a1 + 754;
    while ( v5 <= 255 )
    {
      v6 = (const char *)trap_GetConfigstringConst(v5 + 268);
      if ( !*v6 )
        break;
      if ( !strcasecmp(v6, s2) )
      {
        v4 = v5;
        goto LABEL_16;
      }
      ++v5;
    }
    if ( !level[7] )
    {
      v7 = va("model '%s' not precached", s2);
      Scr_Error((int)v7);
    }
    if ( v5 == 256 )
      G_Error("G_ModelIndex: overflow");
    dword_ACD00[v5] = trap_XModelGet((int)s2);
    trap_SetConfigstring(v5 + 268, (int)s2);
    v4 = v5;
  }
  else
  {
    v4 = 0;
    v10 = 2 * v3;
    v9 = a1 + 754;
  }
LABEL_16:
  *(_BYTE *)(v3 + v11) = v4;
  *(_WORD *)(v10 + v9) = SL_GetLowercaseString(a3, 0);
  G_DObjUpdate(a1);
  return 1;
}

//----- (000662E0) --------------------------------------------------------
int __cdecl sub_662E0(int a1, _DWORD *a2, _BYTE *a3)
{
  int v3; // esi
  int *i; // eax
  int v5; // eax
  int v6; // ebx
  __int16 v7; // ax

  G_EntUnlink(a1);
  if ( *a3 )
  {
    if ( !trap_DObjExists(a2) )
      return 0;
    v3 = trap_DObjGetBoneIndex(a2, (int)a3);
    if ( v3 < 0 )
      return 0;
  }
  else
  {
    v3 = -1;
  }
  if ( a2 == (_DWORD *)a1 )
    return 0;
  for ( i = (int *)a2[185]; i; i = *(int **)(v5 + 740) )
  {
    v5 = *i;
    if ( v5 == a1 )
      return 0;
  }
  v6 = MT_Alloc(112, 16);
  *(_DWORD *)v6 = a2;
  if ( *a3 )
    v7 = SL_GetLowercaseString((int)a3, 0);
  else
    v7 = 0;
  *(_WORD *)(v6 + 8) = v7;
  *(_DWORD *)(v6 + 4) = a2[186];
  *(_DWORD *)(v6 + 12) = v3;
  _bzero((void *)(v6 + 16), 0x30u);
  a2[186] = a1;
  *(_DWORD *)(a1 + 740) = v6;
  _bzero((void *)(v6 + 64), 0x30u);
  return 1;
}

//----- (000663D4) --------------------------------------------------------
float *__cdecl G_CalcTagAxis(int a1, int a2)
{
  int *v2; // edi
  int v3; // esi
  int v4; // eax
  int v5; // edi
  float *result; // eax
  float v7[12]; // [esp+18h] [ebp-C0h] BYREF
  float v8[12]; // [esp+48h] [ebp-90h] BYREF
  float v9[12]; // [esp+78h] [ebp-60h] BYREF
  float v10[12]; // [esp+A8h] [ebp-30h] BYREF

  v2 = *(int **)(a1 + 740);
  v3 = *v2;
  if ( v2[3] < 0 )
  {
    AnglesToAxis((float *)(v3 + 320), v9);
    v9[9] = *(float *)(v3 + 308);
    v9[10] = *(float *)(v3 + 312);
    v9[11] = *(float *)(v3 + 316);
  }
  else
  {
    AnglesToAxis((float *)(v3 + 320), v7);
    v7[9] = *(float *)(v3 + 308);
    v7[10] = *(float *)(v3 + 312);
    v7[11] = *(float *)(v3 + 316);
    G_DObjCalcBone((_DWORD *)v3, v2[3]);
    v4 = trap_DObjGetMatrixArray((_DWORD *)v3);
    DObjSkelMatrixMultiply43((float *)(v4 + (v2[3] << 6)), v7, v9);
  }
  AnglesToAxis((float *)(a1 + 320), v10);
  v5 = *(_DWORD *)(a1 + 740);
  if ( a2 )
  {
    MatrixTranspose(v9, v8);
    result = MatrixMultiply(v10, v8, (float *)(v5 + 16));
  }
  else
  {
    MatrixInverseOrthogonal43(v9, v8);
    v10[9] = *(float *)(a1 + 308);
    v10[10] = *(float *)(a1 + 312);
    v10[11] = *(float *)(a1 + 316);
    result = MatrixMultiply43(v10, v8, (float *)(v5 + 16));
  }
  return result;
}

//----- (00066540) --------------------------------------------------------
__int16 __cdecl G_SetFixedLink(int a1, int a2)
{
  int *v2; // edi
  int v3; // esi
  int v4; // eax
  __int16 result; // ax
  int v6; // edx
  long double v7; // fst7
  float v8[12]; // [esp+18h] [ebp-90h] BYREF
  float v9[12]; // [esp+48h] [ebp-60h] BYREF
  float v10[9]; // [esp+78h] [ebp-30h] BYREF
  float v11; // [esp+9Ch] [ebp-Ch] BYREF
  float v12; // [esp+A0h] [ebp-8h]
  float v13; // [esp+A4h] [ebp-4h]

  v2 = *(int **)(a1 + 740);
  v3 = *v2;
  if ( v2[3] < 0 )
  {
    AnglesToAxis((float *)(v3 + 320), v9);
    v9[9] = *(float *)(v3 + 308);
    v9[10] = *(float *)(v3 + 312);
    v9[11] = *(float *)(v3 + 316);
  }
  else
  {
    AnglesToAxis((float *)(v3 + 320), v8);
    v8[9] = *(float *)(v3 + 308);
    v8[10] = *(float *)(v3 + 312);
    v8[11] = *(float *)(v3 + 316);
    G_DObjCalcBone((_DWORD *)v3, v2[3]);
    v4 = trap_DObjGetMatrixArray((_DWORD *)v3);
    DObjSkelMatrixMultiply43((float *)(v4 + (v2[3] << 6)), v8, v9);
  }
  result = a1;
  v6 = *(_DWORD *)(a1 + 740);
  if ( a2 == 1 )
  {
    MatrixMultiply43((float *)(v6 + 16), v9, v10);
    *(float *)(a1 + 308) = v11;
    *(float *)(a1 + 312) = v12;
    *(float *)(a1 + 316) = v13;
    v7 = vectoyaw(v10);
    result = a1;
    *(float *)(a1 + 324) = v7;
  }
  else if ( a2 > 1 )
  {
    if ( a2 == 2 )
    {
      MatrixTransformVector43((float *)(v6 + 52), v9, &v11);
      result = a1;
      *(float *)(a1 + 308) = v11;
      *(float *)(a1 + 312) = v12;
      *(float *)(a1 + 316) = v13;
    }
  }
  else if ( !a2 )
  {
    MatrixMultiply43((float *)(v6 + 16), v9, v10);
    *(float *)(a1 + 308) = v11;
    *(float *)(a1 + 312) = v12;
    *(float *)(a1 + 316) = v13;
    result = AxisToAngles(v10, a1 + 320);
  }
  return result;
}

//----- (00066714) --------------------------------------------------------
int __cdecl G_PickTarget(unsigned __int16 a1)
{
  int *v1; // edx
  int v2; // ebx
  int *v4; // edi
  int *v5; // ecx
  __int16 v6; // dx
  const char *v7; // eax
  _DWORD v8[32]; // [esp+18h] [ebp-80h]

  v1 = 0;
  v2 = 0;
  if ( !a1 )
    return 0;
  v4 = &g_entities[197 * level[3]];
  do
  {
    v5 = v1 + 197;
    if ( !v1 )
      v5 = g_entities;
    if ( v5 >= v4 )
    {
LABEL_12:
      v1 = 0;
    }
    else
    {
      while ( 1 )
      {
        if ( *((_BYTE *)v5 + 352) )
        {
          v6 = *((_WORD *)v5 + 235);
          if ( v6 )
          {
            if ( v6 == a1 )
              break;
          }
        }
        v5 += 197;
        if ( v5 >= &g_entities[197 * level[3]] )
          goto LABEL_12;
      }
      v1 = v5;
    }
    if ( !v1 )
      break;
    v8[v2++] = v1;
  }
  while ( v2 != 32 );
  if ( v2 )
    return v8[rand() % v2];
  v7 = (const char *)SL_ConvertToString(a1);
  G_Printf("G_PickTarget: target %s not found\n", v7);
  return 0;
}

//----- (000667E0) --------------------------------------------------------
int G_Spawn()
{
  int v0; // ebx
  int v1; // esi
  int v2; // ebx
  const char *v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  double v8; // [esp-24h] [ebp-4Ch]
  double v9; // [esp-1Ch] [ebp-44h]
  double v10; // [esp-14h] [ebp-3Ch]

  v0 = level[4];
  if ( v0 )
  {
    v6 = *(_DWORD *)(v0 + 772);
    level[4] = v6;
    if ( !v6 )
      level[5] = 0;
    *(_DWORD *)(v0 + 772) = 0;
  }
  else
  {
    if ( level[3] == 1022 )
    {
      v1 = 0;
      v2 = 0;
      do
      {
        v10 = *(float *)&g_entities[v2 + 79];
        v9 = *(float *)&g_entities[v2 + 78];
        v8 = *(float *)&g_entities[v2 + 77];
        if ( HIWORD(g_entities[v2 + 93]) )
          v3 = (const char *)SL_ConvertToString(HIWORD(g_entities[v2 + 93]));
        else
          v3 = (const char *)&unk_79BB9;
        G_Printf("%4i: '%s', origin: %f %f %f\n", v1, v3, v8, v9, v10);
        v2 += 197;
        ++v1;
      }
      while ( v1 < level[3] );
      G_Error("G_Spawn: no free entities");
    }
    v4 = level[3];
    v5 = level[1];
    v0 = 788 * v4 + v5;
    level[3] = v4 + 1;
    trap_LocateGameData(v5, v4 + 1, 788);
  }
  *(_BYTE *)(v0 + 352) = 1;
  Scr_SetString(v0 + 374, scr_const[43]);
  *(_DWORD *)v0 = (1024687629 * (v0 - (int)g_entities)) >> 2;
  *(_DWORD *)(v0 + 332) = 1023;
  *(_DWORD *)(v0 + 384) = 0;
  *(_DWORD *)(v0 + 388) = 0;
  return v0;
}
// 21DF80: using guessed type int g_entities[];

//----- (00066948) --------------------------------------------------------
void *__cdecl G_FreeEntity(void *s)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // edx
  _DWORD *i; // eax
  int j; // ebx
  _DWORD *v5; // esi
  int v6; // edx
  int k; // eax
  int v8; // ecx
  int v9; // edx
  int *v10; // eax
  int *v11; // edx
  int v12; // eax
  int v13; // ebx
  int v14; // eax
  void *result; // eax

  v1 = (_DWORD *)*((_DWORD *)s + 185);
  if ( v1 )
  {
    G_SetOrigin((int)s, (float *)s + 77);
    G_SetAngle((int)s, (float *)s + 80);
    v2 = 0;
    for ( i = *(_DWORD **)(*v1 + 744); i != s; i = *(_DWORD **)(i[185] + 4) )
      v2 = i;
    if ( v2 )
      *(_DWORD *)(v2[185] + 4) = v1[1];
    else
      *(_DWORD *)(*v1 + 744) = v1[1];
    *((_DWORD *)s + 185) = 0;
    Scr_SetString((int)(v1 + 2), 0);
    MT_Free((int)v1, 112);
  }
  for ( j = *((_DWORD *)s + 186); j; j = *((_DWORD *)s + 186) )
  {
    v5 = *(_DWORD **)(j + 740);
    if ( v5 )
    {
      G_SetOrigin(j, (float *)(j + 308));
      G_SetAngle(j, (float *)(j + 320));
      v6 = 0;
      for ( k = *(_DWORD *)(*v5 + 744); k != j; k = *(_DWORD *)(*(_DWORD *)(k + 740) + 4) )
        v6 = k;
      if ( v6 )
        *(_DWORD *)(*(_DWORD *)(v6 + 740) + 4) = v5[1];
      else
        *(_DWORD *)(*v5 + 744) = v5[1];
      *(_DWORD *)(j + 740) = 0;
      Scr_SetString((int)(v5 + 2), 0);
      MT_Free((int)v5, 112);
    }
  }
  trap_UnlinkEntity((int)s);
  trap_SafeDObjFree(*(_DWORD *)s, 1);
  v8 = *(_DWORD *)s;
  v9 = level[3];
  if ( v9 > 0 )
  {
    v10 = g_entities;
    do
    {
      if ( *((_BYTE *)v10 + 352) )
      {
        if ( (void *)v10[102] == s )
          v10[102] = 0;
        if ( v10[83] == v8 )
        {
          v10[83] = 1023;
          if ( v10[1] == 11 )
            *((_BYTE *)v10 + 370) = 0;
        }
        if ( v10[31] == v8 )
          v10[31] = 1023;
      }
      v10 += 197;
      --v9;
    }
    while ( v9 );
  }
  v11 = g_entities;
  do
  {
    if ( *((_BYTE *)v11 + 352) )
    {
      v12 = v11[86];
      if ( *(void **)(v12 + 8800) == s )
        *(_DWORD *)(v12 + 8800) = 0;
    }
    v11 += 197;
  }
  while ( (int)v11 <= (int)&g_entities[12411] );
  if ( *((_DWORD *)s + 87) )
    G_FreeTurret((int)s);
  Scr_FreeEntity((int *)s);
  v13 = *((_DWORD *)s + 192);
  _bzero(s, 0x314u);
  if ( (1024687629 * ((int)s - level[1])) >> 2 > 71 )
  {
    v14 = level[5];
    if ( v14 )
      *(_DWORD *)(v14 + 772) = s;
    else
      level[4] = (int)s;
    level[5] = (int)s;
    *((_DWORD *)s + 193) = 0;
  }
  result = s;
  *((_DWORD *)s + 192) = v13 + 1;
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00066BF8) --------------------------------------------------------
void __cdecl G_KillBox(int a1)
{
  float *v1; // eax
  int i; // esi
  int v3; // eax
  int v4; // [esp+1Ch] [ebp-101Ch]
  float v5[3]; // [esp+20h] [ebp-1018h] BYREF
  float v6[3]; // [esp+2Ch] [ebp-100Ch] BYREF
  _DWORD v7[1024]; // [esp+38h] [ebp-1000h] BYREF

  v1 = *(float **)(a1 + 344);
  v6[0] = v1[5] + *(float *)(a1 + 256);
  v6[1] = v1[6] + *(float *)(a1 + 260);
  v6[2] = v1[7] + *(float *)(a1 + 264);
  v5[0] = v1[5] + *(float *)(a1 + 268);
  v5[1] = v1[6] + *(float *)(a1 + 272);
  v5[2] = v1[7] + *(float *)(a1 + 276);
  v4 = trap_EntitiesInBox((int)v6, (int)v5, (int)v7);
  for ( i = 0; i < v4; ++i )
  {
    v3 = 197 * v7[i];
    if ( g_entities[v3 + 86] )
    {
      if ( g_entities[v3 + 60] )
        G_Damage(&g_entities[v3], (int *)a1, (int *)a1, 0, 0, 100000, 16, 0x14u, 0);
    }
  }
}

//----- (00066CF4) --------------------------------------------------------
int __cdecl G_AnimScriptSound(int a1, char *s2)
{
  int v2; // edi
  int result; // eax
  int v4; // ebx
  const char *v5; // eax
  unsigned __int8 v6; // dl
  int *v7; // ecx
  int v8; // eax

  if ( s2 && *s2 )
  {
    v4 = 1;
    v2 = 197 * a1;
    while ( v4 < 256 )
    {
      v5 = (const char *)trap_GetConfigstringConst(v4 + 524);
      if ( !*v5 )
        break;
      if ( !strcasecmp(v5, s2) )
        goto LABEL_12;
      ++v4;
    }
    if ( v4 == 256 )
      G_Error("G_FindConfigstringIndex: overflow");
    trap_SetConfigstring(v4 + 524, (int)s2);
LABEL_12:
    LOBYTE(result) = v4;
  }
  else
  {
    v2 = 197 * a1;
    LOBYTE(result) = 0;
  }
  result = (unsigned __int8)result;
  v6 = result;
  v7 = &g_entities[v2];
  if ( (_BYTE)result )
  {
    v8 = v7[86];
    if ( v8 )
    {
      *(_DWORD *)(v8 + 136 + 4 * (*(_DWORD *)(v8 + 132) & 3)) = 172;
      *(_DWORD *)(v7[86] + 152 + 4 * ((*(_DWORD *)(v7[86] + 132))++ & 3)) = v6;
    }
    else
    {
      v7[(v7[41] & 3) + 42] = 172;
      v7[(v7[41]++ & 3) + 46] = v6;
    }
    v7[96] = level[122];
    result = level[122];
    v7[84] = result;
  }
  return result;
}

//----- (00066E30) --------------------------------------------------------
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, int a5)
{
  int i; // ebx
  const char *v6; // eax
  char *v7; // eax

  if ( s2 && *s2 )
  {
    for ( i = 1; i < a3; ++i )
    {
      v6 = (const char *)trap_GetConfigstringConst(i + a2);
      if ( !*v6 )
        break;
      if ( !strcasecmp(v6, s2) )
        return i;
    }
    if ( a4 )
    {
      if ( i == a3 )
        G_Error("G_FindConfigstringIndex: overflow");
      trap_SetConfigstring(i + a2, (int)s2);
      return i;
    }
    if ( a5 )
    {
      v7 = va("%s \"%s\" not precached", (const char *)a5, s2);
      Scr_Error((int)v7);
    }
  }
  return 0;
}

//----- (00066ED8) --------------------------------------------------------
int __cdecl G_ModelIndex(char *s2)
{
  int i; // ebx
  const char *v3; // eax
  char *v4; // eax

  if ( !*s2 )
    return 0;
  for ( i = 1; i <= 255; ++i )
  {
    v3 = (const char *)trap_GetConfigstringConst(i + 268);
    if ( !*v3 )
      break;
    if ( !strcasecmp(v3, s2) )
      return i;
  }
  if ( !level[7] )
  {
    v4 = va("model '%s' not precached", s2);
    Scr_Error((int)v4);
  }
  if ( i == 256 )
    G_Error("G_ModelIndex: overflow");
  dword_ACD00[i] = trap_XModelGet((int)s2);
  trap_SetConfigstring(i + 268, (int)s2);
  return i;
}

//----- (00066F8C) --------------------------------------------------------
int __cdecl G_ModelName(int a1)
{
  return trap_GetConfigstringConst(a1 + 268);
}

//----- (00066FA8) --------------------------------------------------------
int __cdecl G_TagIndex(char *s2)
{
  int i; // ebx
  const char *v3; // eax

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < 32; ++i )
  {
    v3 = (const char *)trap_GetConfigstringConst(i + 108);
    if ( !*v3 )
      break;
    if ( !strcasecmp(v3, s2) )
      return i;
  }
  if ( i == 32 )
    G_Error("G_FindConfigstringIndex: overflow");
  trap_SetConfigstring(i + 108, (int)s2);
  return i;
}

//----- (00067020) --------------------------------------------------------
int __cdecl G_SetModel(int a1, char *s2)
{
  int result; // eax
  int i; // ebx
  const char *v4; // eax
  char *v5; // eax

  if ( *s2 )
  {
    for ( i = 1; i <= 255; ++i )
    {
      v4 = (const char *)trap_GetConfigstringConst(i + 268);
      if ( !*v4 )
        break;
      if ( !strcasecmp(v4, s2) )
        goto LABEL_13;
    }
    if ( !level[7] )
    {
      v5 = va("model '%s' not precached", s2);
      Scr_Error((int)v5);
    }
    if ( i == 256 )
      G_Error("G_ModelIndex: overflow");
    dword_ACD00[i] = trap_XModelGet((int)s2);
    trap_SetConfigstring(i + 268, (int)s2);
LABEL_13:
    result = a1;
    *(_BYTE *)(a1 + 373) = i;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 373) = 0;
  }
  return result;
}

//----- (000670E0) --------------------------------------------------------
int __cdecl G_SafeDObjFree(int *a1)
{
  return trap_SafeDObjFree(*a1, 0);
}

//----- (000670FC) --------------------------------------------------------
int __cdecl G_DObjUpdateServerTime(_DWORD *a1, int a2)
{
  int v3; // [esp-Ch] [ebp-24h]

  *(float *)&v3 = (long double)level[124] * 0.001;
  return trap_DObjUpdateServerTime(a1, v3, a2);
}

//----- (00067128) --------------------------------------------------------
int __cdecl G_DObjSetLocalTag(_DWORD *a1, int a2, int a3, float *a4, float *a5)
{
  int v5; // eax
  int v6; // ebx
  int v8; // [esp+24h] [ebp-44h]
  float v9[4]; // [esp+28h] [ebp-40h] BYREF
  int v10[4]; // [esp+38h] [ebp-30h] BYREF
  int v11[4]; // [esp+48h] [ebp-20h] BYREF
  int v12[4]; // [esp+58h] [ebp-10h] BYREF

  v5 = trap_DObjGetBoneIndex(a1, a3);
  v6 = v5;
  if ( v5 < 0 || !trap_DObjSetRotTransIndex(a1, a2, v5) )
    return 0;
  v8 = trap_DObjGetRotTransArray(a1) + 32 * v6;
  YawToQuaternion(a5[1], (int)v12);
  PitchToQuaternion(*a5, (int)v10);
  RollToQuaternion(a5[2], (int)v11);
  QuatMultiply((float *)v10, (float *)v12, v9);
  QuatMultiply((float *)v11, v9, (float *)v8);
  *(_DWORD *)(v8 + 16) = 0;
  *(float *)(v8 + 20) = *a4;
  *(float *)(v8 + 24) = a4[1];
  *(float *)(v8 + 28) = a4[2];
  return 1;
}

//----- (0006721C) --------------------------------------------------------
int __cdecl G_DObjSetControlTagAngles(_DWORD *a1, int a2, int a3, float *a4)
{
  int v4; // eax
  int v5; // ebx
  int v7; // [esp+24h] [ebp-44h]
  float v8[4]; // [esp+28h] [ebp-40h] BYREF
  int v9[4]; // [esp+38h] [ebp-30h] BYREF
  int v10[4]; // [esp+48h] [ebp-20h] BYREF
  int v11[4]; // [esp+58h] [ebp-10h] BYREF

  v4 = trap_DObjGetBoneIndex(a1, a3);
  v5 = v4;
  if ( v4 < 0 || !trap_DObjSetControlRotTransIndex(a1, a2, v4) )
    return 0;
  v7 = trap_DObjGetRotTransArray(a1) + 32 * v5;
  YawToQuaternion(a4[1], (int)v11);
  PitchToQuaternion(*a4, (int)v9);
  RollToQuaternion(a4[2], (int)v10);
  QuatMultiply((float *)v9, (float *)v11, v8);
  QuatMultiply((float *)v10, v8, (float *)v7);
  *(_DWORD *)(v7 + 16) = 0;
  *(float *)(v7 + 20) = 0.0;
  *(float *)(v7 + 24) = *(&vec3_origin + 1);
  *(float *)(v7 + 28) = *(&vec3_origin + 2);
  return 1;
}
// 72910: using guessed type float vec3_origin;

//----- (00067314) --------------------------------------------------------
int __cdecl G_DObjCalcPose(_DWORD *a1)
{
  int result; // eax
  void (__cdecl *v2)(_DWORD *, char *); // eax
  char s[16]; // [esp+18h] [ebp-10h] BYREF

  memset(s, 255, sizeof(s));
  result = trap_DObjCreateSkelForBones(a1, (int)s);
  if ( !result )
  {
    trap_DObjCalcAnim(a1, (int)s);
    v2 = (void (__cdecl *)(_DWORD *, char *))a1[136];
    if ( v2 )
      v2(a1, s);
    result = trap_DObjCalcSkel(a1, (int)s);
  }
  return result;
}

//----- (0006737C) --------------------------------------------------------
int __cdecl G_DObjCalcBone(_DWORD *a1, int a2)
{
  int result; // eax
  void (__cdecl *v3)(_DWORD *, char *); // eax
  char v4[16]; // [esp+18h] [ebp-10h] BYREF

  result = trap_DObjCreateSkelForBone(a1, a2);
  if ( !result )
  {
    trap_DObjGetHierarchyBits(a1, a2, (int)v4);
    trap_DObjCalcAnim(a1, (int)v4);
    v3 = (void (__cdecl *)(_DWORD *, char *))a1[136];
    if ( v3 )
      v3(a1, v4);
    result = trap_DObjCalcSkel(a1, (int)v4);
  }
  return result;
}

//----- (000673E0) --------------------------------------------------------
int __cdecl G_DObjGetLocalTagMatrix(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // esi
  void (__cdecl *v5)(_DWORD *, char *); // eax
  char v6[16]; // [esp+18h] [ebp-10h] BYREF

  v2 = trap_DObjGetBoneIndex(a1, a2);
  v3 = v2;
  if ( v2 < 0 )
    return 0;
  if ( !trap_DObjCreateSkelForBone(a1, v2) )
  {
    trap_DObjGetHierarchyBits(a1, v3, (int)v6);
    trap_DObjCalcAnim(a1, (int)v6);
    v5 = (void (__cdecl *)(_DWORD *, char *))a1[136];
    if ( v5 )
      v5(a1, v6);
    trap_DObjCalcSkel(a1, (int)v6);
  }
  return (v3 << 6) + trap_DObjGetMatrixArray(a1);
}

//----- (0006746C) --------------------------------------------------------
int __cdecl G_DObjGetWorldTagMatrix(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // esi
  void (__cdecl *v5)(int, char *); // eax
  float *v6; // esi
  char v8[16]; // [esp+18h] [ebp-40h] BYREF
  float v9[12]; // [esp+28h] [ebp-30h] BYREF

  v3 = trap_DObjGetBoneIndex((_DWORD *)a1, a2);
  v4 = v3;
  if ( v3 < 0 )
    return 0;
  if ( !trap_DObjCreateSkelForBone((_DWORD *)a1, v3) )
  {
    trap_DObjGetHierarchyBits((_DWORD *)a1, v4, (int)v8);
    trap_DObjCalcAnim((_DWORD *)a1, (int)v8);
    v5 = *(void (__cdecl **)(int, char *))(a1 + 544);
    if ( v5 )
      v5(a1, v8);
    trap_DObjCalcSkel((_DWORD *)a1, (int)v8);
  }
  v6 = (float *)(trap_DObjGetMatrixArray((_DWORD *)a1) + (v4 << 6));
  if ( !v6 )
    return 0;
  AnglesToAxis((float *)(a1 + 320), v9);
  v9[9] = *(float *)(a1 + 308);
  v9[10] = *(float *)(a1 + 312);
  v9[11] = *(float *)(a1 + 316);
  DObjSkel2MatrixMultiply43(v6, v9, a3);
  return 1;
}

//----- (00067540) --------------------------------------------------------
int __cdecl G_ShellShockIndex(char *s2)
{
  int i; // ebx
  const char *v3; // eax

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < 16; ++i )
  {
    v3 = (const char *)trap_GetConfigstringConst(i + 1100);
    if ( !*v3 )
      break;
    if ( !strcasecmp(v3, s2) )
      return i;
  }
  if ( i == 16 )
    G_Error("G_FindConfigstringIndex: overflow");
  trap_SetConfigstring(i + 1100, (int)s2);
  return i;
}

//----- (000675C0) --------------------------------------------------------
int __cdecl G_SoundAliasIndex(char *s2)
{
  int result; // eax
  int i; // ebx
  const char *v3; // eax

  if ( s2 && *s2 )
  {
    for ( i = 1; i < 256; ++i )
    {
      v3 = (const char *)trap_GetConfigstringConst(i + 524);
      if ( !*v3 )
        break;
      if ( !strcasecmp(v3, s2) )
        goto LABEL_12;
    }
    if ( i == 256 )
      G_Error("G_FindConfigstringIndex: overflow");
    trap_SetConfigstring(i + 524, (int)s2);
LABEL_12:
    LOBYTE(result) = i;
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return (unsigned __int8)result;
}

//----- (0006764C) --------------------------------------------------------
int *__cdecl G_Find(int a1, int a2, __int16 a3)
{
  int *v3; // ecx
  int *v5; // eax
  __int16 v6; // dx

  if ( a1 )
    v3 = (int *)(a1 + 788);
  else
    v3 = g_entities;
  v5 = &g_entities[197 * level[3]];
  if ( v3 >= v5 )
    return 0;
  while ( 1 )
  {
    if ( *((_BYTE *)v3 + 352) )
    {
      v6 = *(_WORD *)((char *)v3 + a2);
      if ( v6 )
      {
        if ( v6 == a3 )
          break;
      }
    }
    v3 += 197;
    if ( v3 >= v5 )
      return 0;
  }
  return v3;
}
// 21DF80: using guessed type int g_entities[];

//----- (000676BC) --------------------------------------------------------
int *__cdecl G_FindStr(int a1, int a2, char *a3)
{
  int *v3; // ebx
  int v5; // eax
  char *v6; // eax

  if ( a1 )
    v3 = (int *)(a1 + 788);
  else
    v3 = g_entities;
  v5 = 197 * level[3];
  while ( v3 < &g_entities[v5] )
  {
    if ( *((_BYTE *)v3 + 352) )
    {
      v6 = *(char **)((char *)v3 + a2);
      if ( v6 )
      {
        if ( !Q_stricmp(v6, a3) )
          return v3;
      }
    }
    v5 = 197 * level[3];
    v3 += 197;
  }
  return 0;
}

//----- (0006773C) --------------------------------------------------------
unsigned __int16 __cdecl G_SetMovedir(float *a1, float *a2)
{
  char v2; // fps^1
  long double v3; // fst6
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  long double v7; // fst7
  char v8; // fps^1
  bool v9; // c0
  char v10; // c2
  bool v11; // c3
  long double v12; // fst7
  __int16 v13; // fps
  bool v14; // c0
  char v15; // c2
  bool v16; // c3
  unsigned __int16 result; // ax
  long double v18; // fst7
  char v19; // fps^1
  bool v20; // c0
  char v21; // c2
  bool v22; // c3
  long double v23; // fst7
  char v24; // fps^1
  bool v25; // c0
  char v26; // c2
  bool v27; // c3
  long double v28; // fst7
  __int16 v29; // fps
  bool v30; // c0
  char v31; // c2
  bool v32; // c3

  v3 = *a1;
  v4 = v3 < flt_7EC14;
  v5 = 0;
  v6 = v3 == flt_7EC14;
  if ( (v2 & 0x44) != 0x40 )
    goto LABEL_5;
  v7 = a1[1];
  v9 = flt_7EC18 < v7;
  v10 = 0;
  v11 = flt_7EC18 == v7;
  if ( (v8 & 0x44) != 0x40
    || (v12 = a1[2],
        v14 = flt_7EC1C < v12,
        v15 = 0,
        v16 = flt_7EC1C == v12,
        LOBYTE(result) = v13,
        (HIBYTE(result) = HIBYTE(v13) & 0x44 ^ 0x40) != 0) )
  {
LABEL_5:
    v18 = *a1;
    v20 = flt_7EC2C < v18;
    v21 = 0;
    v22 = flt_7EC2C == v18;
    if ( (v19 & 0x44) != 0x40 )
      goto LABEL_9;
    v23 = a1[1];
    v25 = flt_7EC30 < v23;
    v26 = 0;
    v27 = flt_7EC30 == v23;
    if ( (v24 & 0x44) != 0x40
      || (v28 = a1[2],
          v30 = flt_7EC34 < v28,
          v31 = 0,
          v32 = flt_7EC34 == v28,
          LOBYTE(result) = v29,
          (HIBYTE(result) = HIBYTE(v29) & 0x44 ^ 0x40) != 0) )
    {
LABEL_9:
      result = (unsigned __int16)AngleVectors(a1, a2, 0, 0);
    }
    else
    {
      *a2 = flt_7EC38;
      a2[1] = flt_7EC3C;
      a2[2] = flt_7EC40;
    }
  }
  else
  {
    *a2 = flt_7EC20;
    a2[1] = flt_7EC24;
    a2[2] = flt_7EC28;
  }
  a1[2] = 0.0;
  a1[1] = 0.0;
  *a1 = 0.0;
  return result;
}
// 67755: variable 'v2' is possibly undefined
// 6776A: variable 'v8' is possibly undefined
// 677AF: variable 'v19' is possibly undefined
// 677C4: variable 'v24' is possibly undefined
// 7EC14: using guessed type float flt_7EC14;
// 7EC18: using guessed type float flt_7EC18;
// 7EC1C: using guessed type float flt_7EC1C;
// 7EC20: using guessed type float flt_7EC20;
// 7EC24: using guessed type float flt_7EC24;
// 7EC28: using guessed type float flt_7EC28;
// 7EC2C: using guessed type float flt_7EC2C;
// 7EC30: using guessed type float flt_7EC30;
// 7EC34: using guessed type float flt_7EC34;
// 7EC38: using guessed type float flt_7EC38;
// 7EC3C: using guessed type float flt_7EC3C;
// 7EC40: using guessed type float flt_7EC40;

//----- (00067828) --------------------------------------------------------
int __cdecl G_InitGentity(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 352) = 1;
  Scr_SetString(a1 + 374, scr_const[43]);
  result = (1024687629 * (a1 - (int)g_entities)) >> 2;
  *(_DWORD *)a1 = result;
  *(_DWORD *)(a1 + 332) = 1023;
  *(_DWORD *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 388) = 0;
  return result;
}

//----- (00067888) --------------------------------------------------------
int *G_SpawnPlayerClone()
{
  int v0; // ecx
  int *v1; // ebx
  int v2; // eax
  int v3; // esi

  v0 = level[1914];
  v1 = (int *)(level[1] + 788 * v0 + 50432);
  v2 = v0 + 1;
  if ( v0 + 1 < 0 )
    v2 = v0 + 8;
  LOBYTE(v2) = v2 & 0xF8;
  level[1914] = v0 + 1 - v2;
  v3 = v1[2] & 8 ^ 8;
  if ( *((_BYTE *)v1 + 352) )
    G_FreeEntity(v1);
  *((_BYTE *)v1 + 352) = 1;
  Scr_SetString((int)v1 + 374, scr_const[43]);
  *v1 = (1024687629 * ((char *)v1 - (char *)g_entities)) >> 2;
  v1[83] = 1023;
  v1[96] = 0;
  v1[97] = 0;
  v1[2] = v3;
  return v1;
}
// 21DF80: using guessed type int g_entities[];

//----- (00067938) --------------------------------------------------------
_DWORD *__cdecl G_TempEntity(float *a1, int a2)
{
  _DWORD *v2; // edi
  long double v3; // fst6
  long double v4; // fst7
  float v6[3]; // [esp+1Ch] [ebp-Ch] BYREF

  v2 = (_DWORD *)G_Spawn();
  v2[1] = a2 + 12;
  Scr_SetString((int)v2 + 374, scr_const[69]);
  v2[96] = level[122];
  v2[84] = level[122];
  v2[97] = 1;
  v3 = a1[1];
  v4 = a1[2];
  v6[0] = (float)(int)*a1;
  v6[1] = (float)(int)v3;
  v6[2] = (float)(int)v4;
  G_SetOrigin((int)v2, v6);
  trap_LinkEntity((int)v2);
  return v2;
}

//----- (00067A2C) --------------------------------------------------------
int __cdecl G_PlaySoundAliasAtPoint(float *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // ebx
  long double v4; // fst6
  long double v5; // fst7
  float v6[3]; // [esp+1Ch] [ebp-Ch] BYREF

  result = a2;
  if ( (_BYTE)a2 )
  {
    v3 = (_DWORD *)G_Spawn();
    v3[1] = 184;
    Scr_SetString((int)v3 + 374, scr_const[69]);
    v3[96] = level[122];
    v3[84] = level[122];
    v3[97] = 1;
    v4 = a1[1];
    v5 = a1[2];
    v6[0] = (float)(int)*a1;
    v6[1] = (float)(int)v4;
    v6[2] = (float)(int)v5;
    G_SetOrigin((int)v3, v6);
    trap_LinkEntity((int)v3);
    result = (unsigned __int8)a2;
    v3[40] = (unsigned __int8)a2;
  }
  return result;
}

//----- (00067B30) --------------------------------------------------------
int __cdecl G_PlaySoundAlias(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // eax

  result = a2;
  if ( (_BYTE)a2 )
  {
    v3 = a1[86];
    if ( v3 )
    {
      *(_DWORD *)(v3 + 136 + 4 * (*(_DWORD *)(v3 + 132) & 3)) = 172;
      *(_DWORD *)(a1[86] + 152 + 4 * ((*(_DWORD *)(a1[86] + 132))++ & 3)) = (unsigned __int8)a2;
    }
    else
    {
      a1[(a1[41] & 3) + 42] = 172;
      a1[(a1[41]++ & 3) + 46] = (unsigned __int8)a2;
    }
    a1[96] = level[122];
    result = level[122];
    a1[84] = result;
  }
  return result;
}

//----- (00067BDC) --------------------------------------------------------
char *__cdecl vtos(float *a1)
{
  char *v1; // ebx

  v1 = (char *)&unk_AC9E0 + 32 * dword_AC9C0;
  dword_AC9C0 = ((_BYTE)dword_AC9C0 + 1) & 7;
  Com_sprintf(v1, 0x20u, "(%i %i %i)", (int)*a1, (int)a1[1], (int)a1[2]);
  return v1;
}
// AC9C0: using guessed type int dword_AC9C0;

//----- (00067C7C) --------------------------------------------------------
int __cdecl G_AddPredictableEvent(int a1, int a2, unsigned __int8 a3)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 344);
  if ( result )
    result = BG_AddPredictableEventToPlayerstate(a2, a3, *(_DWORD *)(a1 + 344));
  return result;
}

//----- (00067CA4) --------------------------------------------------------
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax

  v3 = a1[86];
  if ( v3 )
  {
    *(_DWORD *)(v3 + 136 + 4 * (*(_DWORD *)(v3 + 132) & 3)) = a2;
    *(_DWORD *)(a1[86] + 152 + 4 * ((*(_DWORD *)(a1[86] + 132))++ & 3)) = a3;
  }
  else
  {
    a1[(a1[41] & 3) + 42] = a2;
    a1[(a1[41]++ & 3) + 46] = a3;
  }
  a1[96] = level[122];
  result = level[122];
  a1[84] = result;
  return result;
}

//----- (00067D38) --------------------------------------------------------
int __cdecl G_SetOrigin(int a1, float *a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 24) = *a2;
  *(float *)(a1 + 28) = a2[1];
  *(float *)(a1 + 32) = a2[2];
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(float *)(a1 + 308) = *a2;
  *(float *)(a1 + 312) = a2[1];
  *(float *)(a1 + 316) = a2[2];
  return result;
}

//----- (00067D9C) --------------------------------------------------------
int __cdecl G_SetAngle(int a1, float *a2)
{
  int result; // eax

  result = a1;
  *(float *)(a1 + 60) = *a2;
  *(float *)(a1 + 64) = a2[1];
  *(float *)(a1 + 68) = a2[2];
  *(_DWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(float *)(a1 + 320) = *a2;
  *(float *)(a1 + 324) = a2[1];
  *(float *)(a1 + 328) = a2[2];
  return result;
}

//----- (00067E00) --------------------------------------------------------
_BOOL4 __cdecl infront(float *a1, float *a2)
{
  long double v2; // fst7
  char v3; // fps^1
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  float v8[3]; // [esp+20h] [ebp-18h] BYREF
  float v9; // [esp+2Ch] [ebp-Ch] BYREF
  float v10; // [esp+30h] [ebp-8h]
  float v11; // [esp+34h] [ebp-4h]

  AngleVectors(a1 + 80, v8, 0, 0);
  v9 = a2[77] - a1[77];
  v10 = a2[78] - a1[78];
  v11 = a2[79] - a1[79];
  VectorNormalize(&v9);
  v2 = v9 * v8[0] + v10 * v8[1] + v11 * v8[2];
  v4 = v2 > 0.0;
  v5 = 0;
  v6 = 0.0 == v2;
  return (v3 & 0x45) == 1;
}
// 67E7D: variable 'v3' is possibly undefined

//----- (00067EA0) --------------------------------------------------------
int __cdecl G_SetConstString(_WORD *a1, int a2)
{
  int result; // eax

  Scr_SetString((int)a1, 0);
  result = SL_GetString(a2, 0);
  *a1 = result;
  return result;
}

//----- (00067ED0) --------------------------------------------------------
int __cdecl G_EntDetach(int a1, char *s2, int a3)
{
  __int16 v3; // si
  int v5; // edi
  const char *v6; // eax
  int v7; // ecx
  int v8; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+24h] [ebp-4h]

  v3 = SL_FindLowercaseString(a3);
  if ( !v3 )
    return 0;
  v5 = 0;
  v10 = a1 + 754;
  for ( i = 0; ; i += 2 )
  {
    if ( *(_WORD *)(v10 + i) == v3 )
    {
      v6 = (const char *)trap_GetConfigstringConst(*(unsigned __int8 *)(v5 + a1 + 748) + 268);
      v11 = a1 + 748;
      if ( !strcasecmp(v6, s2) )
        break;
    }
    if ( ++v5 > 5 )
      return 0;
  }
  *(_BYTE *)(v5 + a1 + 748) = 0;
  Scr_SetString(a1 + i + 754, 0);
  if ( v5 <= 4 )
  {
    v7 = v5 + 1;
    do
    {
      *(_BYTE *)(v11 + v7 - 1) = *(_BYTE *)(v11 + v7);
      v8 = v7;
      *(_WORD *)(v10 + 2 * v7 - 2) = *(_WORD *)(v10 + 2 * v7);
      i += 2;
      ++v7;
      v5 = v8;
    }
    while ( v8 <= 4 );
  }
  *(_BYTE *)(v5 + v11) = 0;
  *(_WORD *)(v10 + i) = 0;
  G_DObjUpdate(a1);
  return 1;
}

//----- (00067FDC) --------------------------------------------------------
int __cdecl G_EntDetachAll(int a1)
{
  int v1; // esi
  int v2; // ebx

  v1 = 0;
  v2 = a1 + 754;
  do
  {
    *(_BYTE *)(v1 + a1 + 748) = 0;
    Scr_SetString(v2, 0);
    v2 += 2;
    ++v1;
  }
  while ( v1 <= 5 );
  return G_DObjUpdate(a1);
}

//----- (00068034) --------------------------------------------------------
int __cdecl G_EntLinkTo(int a1, _DWORD *a2, _BYTE *a3)
{
  if ( !sub_662E0(a1, a2, a3) )
    return 0;
  G_CalcTagAxis(a1, 0);
  return 1;
}

//----- (00068074) --------------------------------------------------------
int __cdecl G_EntLinkToWithOffset(int a1, _DWORD *a2, _BYTE *a3, float *a4, float *a5)
{
  float *v5; // ebx

  if ( !sub_662E0(a1, a2, a3) )
    return 0;
  v5 = *(float **)(a1 + 740);
  AnglesToAxis(a5, v5 + 4);
  v5[13] = *a4;
  v5[14] = a4[1];
  v5[15] = a4[2];
  return 1;
}

//----- (000680D4) --------------------------------------------------------
void __cdecl G_EntUnlink(int a1)
{
  _DWORD *v1; // esi
  int v2; // edx
  int i; // eax

  v1 = *(_DWORD **)(a1 + 740);
  if ( v1 )
  {
    G_SetOrigin(a1, (float *)(a1 + 308));
    G_SetAngle(a1, (float *)(a1 + 320));
    v2 = 0;
    for ( i = *(_DWORD *)(*v1 + 744); i != a1; i = *(_DWORD *)(*(_DWORD *)(i + 740) + 4) )
      v2 = i;
    if ( v2 )
      *(_DWORD *)(*(_DWORD *)(v2 + 740) + 4) = v1[1];
    else
      *(_DWORD *)(*v1 + 744) = v1[1];
    *(_DWORD *)(a1 + 740) = 0;
    Scr_SetString((int)(v1 + 2), 0);
    MT_Free((int)v1, 112);
  }
}

//----- (00068178) --------------------------------------------------------
_BOOL4 __cdecl G_EntIsLinkedTo(int a1, int a2)
{
  _DWORD *v2; // edx
  _BOOL4 result; // eax

  v2 = *(_DWORD **)(a1 + 740);
  result = 0;
  if ( v2 )
    result = *v2 == a2;
  return result;
}

//----- (0006819C) --------------------------------------------------------
void __cdecl G_UpdateTagInfo(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // edx
  int i; // eax

  v2 = *(_DWORD *)(a1 + 740);
  if ( *(_WORD *)(v2 + 8) )
  {
    if ( !a2
      || (v3 = SL_ConvertToString(*(_WORD *)(v2 + 8)),
          v4 = trap_DObjGetBoneIndex(*(_DWORD **)v2, v3),
          *(_DWORD *)(v2 + 12) = v4,
          v4 < 0) )
    {
      v5 = *(_DWORD **)(a1 + 740);
      if ( v5 )
      {
        G_SetOrigin(a1, (float *)(a1 + 308));
        G_SetAngle(a1, (float *)(a1 + 320));
        v6 = 0;
        for ( i = *(_DWORD *)(*v5 + 744); i != a1; i = *(_DWORD *)(*(_DWORD *)(i + 740) + 4) )
          v6 = i;
        if ( v6 )
          *(_DWORD *)(*(_DWORD *)(v6 + 740) + 4) = v5[1];
        else
          *(_DWORD *)(*v5 + 744) = v5[1];
        *(_DWORD *)(a1 + 740) = 0;
        Scr_SetString((int)(v5 + 2), 0);
        MT_Free((int)v5, 112);
      }
    }
  }
  else
  {
    *(_DWORD *)(v2 + 12) = -1;
  }
}

//----- (00068294) --------------------------------------------------------
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // ebx
  int v5; // eax
  _DWORD *v6; // ebx
  int v7; // edx
  int i; // eax
  int v9; // [esp+14h] [ebp-4h]

  result = a1;
  v3 = *(_DWORD *)(a1 + 744);
  if ( v3 )
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 740);
      result = *(_DWORD *)(v4 + 4);
      v9 = result;
      if ( *(_WORD *)(v4 + 8) )
      {
        if ( !a2
          || (v5 = SL_ConvertToString(*(_WORD *)(v4 + 8)),
              result = trap_DObjGetBoneIndex(*(_DWORD **)v4, v5),
              *(_DWORD *)(v4 + 12) = result,
              result < 0) )
        {
          v6 = *(_DWORD **)(v3 + 740);
          if ( v6 )
          {
            G_SetOrigin(v3, (float *)(v3 + 308));
            G_SetAngle(v3, (float *)(v3 + 320));
            v7 = 0;
            for ( i = *(_DWORD *)(*v6 + 744); i != v3; i = *(_DWORD *)(*(_DWORD *)(i + 740) + 4) )
              v7 = i;
            if ( v7 )
              *(_DWORD *)(*(_DWORD *)(v7 + 740) + 4) = v6[1];
            else
              *(_DWORD *)(*v6 + 744) = v6[1];
            *(_DWORD *)(v3 + 740) = 0;
            Scr_SetString((int)(v6 + 2), 0);
            result = MT_Free((int)v6, 112);
          }
        }
      }
      else
      {
        *(_DWORD *)(v4 + 12) = -1;
      }
      v3 = v9;
    }
    while ( v9 );
  }
  return result;
}

//----- (000683A4) --------------------------------------------------------
float *__cdecl G_CalcTagParentAxis(int a1, float *a2)
{
  int *v2; // edi
  int v3; // esi
  int v4; // eax
  float *result; // eax
  float v6[12]; // [esp+18h] [ebp-30h] BYREF

  v2 = *(int **)(a1 + 740);
  v3 = *v2;
  if ( v2[3] < 0 )
  {
    AnglesToAxis((float *)(v3 + 320), a2);
    result = a2;
    a2[9] = *(float *)(v3 + 308);
    a2[10] = *(float *)(v3 + 312);
    a2[11] = *(float *)(v3 + 316);
  }
  else
  {
    AnglesToAxis((float *)(v3 + 320), v6);
    v6[9] = *(float *)(v3 + 308);
    v6[10] = *(float *)(v3 + 312);
    v6[11] = *(float *)(v3 + 316);
    G_DObjCalcBone((_DWORD *)v3, v2[3]);
    v4 = trap_DObjGetMatrixArray((_DWORD *)v3);
    result = DObjSkelMatrixMultiply43((float *)(v4 + (v2[3] << 6)), v6, a2);
  }
  return result;
}

//----- (0006845C) --------------------------------------------------------
float *__cdecl G_CalcTagParentRelAxis(int a1, float *a2)
{
  float *v2; // edi
  float v3; // esi
  int v4; // eax
  float v6[12]; // [esp+18h] [ebp-60h] BYREF
  float v7[12]; // [esp+48h] [ebp-30h] BYREF

  v2 = *(float **)(a1 + 740);
  v3 = *v2;
  if ( *((int *)v2 + 3) < 0 )
  {
    AnglesToAxis((float *)(LODWORD(v3) + 320), v7);
    v7[9] = *(float *)(LODWORD(v3) + 308);
    v7[10] = *(float *)(LODWORD(v3) + 312);
    v7[11] = *(float *)(LODWORD(v3) + 316);
  }
  else
  {
    AnglesToAxis((float *)(LODWORD(v3) + 320), v6);
    v6[9] = *(float *)(LODWORD(v3) + 308);
    v6[10] = *(float *)(LODWORD(v3) + 312);
    v6[11] = *(float *)(LODWORD(v3) + 316);
    G_DObjCalcBone((_DWORD *)LODWORD(v3), *((_DWORD *)v2 + 3));
    v4 = trap_DObjGetMatrixArray((_DWORD *)LODWORD(v3));
    DObjSkelMatrixMultiply43((float *)(v4 + (*((_DWORD *)v2 + 3) << 6)), v6, v7);
  }
  return MatrixMultiply43(v2 + 16, v7, a2);
}

//----- (00068530) --------------------------------------------------------
int __cdecl G_GeneralLink(int a1)
{
  G_SetFixedLink(a1, 0);
  G_SetOrigin(a1, (float *)(a1 + 308));
  G_SetAngle(a1, (float *)(a1 + 320));
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  return trap_LinkEntity(a1);
}

//----- (00068588) --------------------------------------------------------
int __cdecl Think_GeneralLink(int a1)
{
  int result; // eax

  result = level[122] + 50;
  *(_DWORD *)(a1 + 508) = result;
  if ( *(_DWORD *)(a1 + 740) )
  {
    G_SetFixedLink(a1, 0);
    G_SetOrigin(a1, (float *)(a1 + 308));
    G_SetAngle(a1, (float *)(a1 + 320));
    *(_DWORD *)(a1 + 12) = 1;
    *(_DWORD *)(a1 + 48) = 1;
    result = trap_LinkEntity(a1);
  }
  return result;
}

//----- (000685F8) --------------------------------------------------------
int __cdecl G_GetGameId(int *a1)
{
  return (unsigned __int16)Scr_GetEntityId(*a1, 0);
}

//----- (00068618) --------------------------------------------------------
char *__cdecl vtosf(float *a1)
{
  int v1; // eax
  char *v2; // ebx

  v1 = dword_ACAE0;
  dword_ACAE0 = ((_BYTE)dword_ACAE0 + 1) & 7;
  v2 = (char *)&unk_ACB00 + 64 * v1;
  Com_sprintf(v2, 0x40u, "(%f %f %f)", *a1, a1[1], a1[2]);
  return v2;
}
// ACAE0: using guessed type int dword_ACAE0;

//----- (00068670) --------------------------------------------------------
int *__usercall G_FreeEntityRefs@<eax>(int *result@<eax>, int *a2)
{
  int v2; // edx
  int v3; // ecx
  int *v4; // edx

  v2 = level[3];
  v3 = *a2;
  if ( v2 > 0 )
  {
    result = g_entities;
    do
    {
      if ( *((_BYTE *)result + 352) )
      {
        if ( (int *)result[102] == a2 )
          result[102] = 0;
        if ( result[83] == v3 )
        {
          result[83] = 1023;
          if ( result[1] == 11 )
            *((_BYTE *)result + 370) = 0;
        }
        if ( result[31] == v3 )
          result[31] = 1023;
      }
      result += 197;
      --v2;
    }
    while ( v2 );
  }
  v4 = g_entities;
  do
  {
    if ( *((_BYTE *)v4 + 352) )
    {
      result = (int *)v4[86];
      if ( (int *)result[2200] == a2 )
        result[2200] = 0;
    }
    v4 += 197;
  }
  while ( (int)v4 <= (int)&g_entities[12411] );
  return result;
}
// 21DF80: using guessed type int g_entities[];

//----- (00068710) --------------------------------------------------------
int DebugLine()
{
  return 0;
}

//----- (00068720) --------------------------------------------------------
void __cdecl Weapon_Melee(int *a1, float *a2)
{
  char v2; // fps^1
  bool v3; // c0
  char v4; // c2
  bool v5; // c3
  int *v6; // ebx
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  int v9; // eax
  int v10; // [esp-10h] [ebp-68h]
  int v11; // [esp+18h] [ebp-40h]
  float v12[3]; // [esp+1Ch] [ebp-3Ch] BYREF
  float v13; // [esp+28h] [ebp-30h] BYREF
  float v14[3]; // [esp+2Ch] [ebp-2Ch] BYREF
  float v15[3]; // [esp+38h] [ebp-20h] BYREF
  char v16; // [esp+44h] [ebp-14h]
  unsigned __int16 v17; // [esp+50h] [ebp-8h]
  unsigned __int16 v18; // [esp+54h] [ebp-4h]

  v12[0] = *a2 * 64.0 + a2[9];
  v12[1] = a2[1] * 64.0 + a2[10];
  v12[2] = 64.0 * a2[2] + a2[11];
  trap_LocationalTrace((int)&v13, (int)(a2 + 9), (int)v12);
  v11 = *(_DWORD *)(BG_GetInfoForWeapon(a1[50]) + 452);
  G_CheckHitTriggerDamage(a1, a2 + 9, v14, v11, 7);
  if ( (v16 & 0x10) == 0 )
  {
    v3 = v13 < 1.0;
    v4 = 0;
    v5 = v13 == 1.0;
    if ( (v2 & 0x45) != 64 )
    {
      v6 = &g_entities[197 * v17];
      if ( v6[86] )
        v7 = G_TempEntity(v14, 166);
      else
        v7 = G_TempEntity(v14, 167);
      v8 = v7;
      v7[29] = v17;
      v7[40] = (unsigned __int8)DirToByte(v15);
      v8[50] = a1[50];
      if ( v17 != 1022 )
      {
        if ( *((_BYTE *)v6 + 369) )
        {
          v10 = v18;
          v9 = rand();
          G_Damage(v6, a1, a1, a2, v14, v9 % 5 + v11, 0, 7u, v10);
        }
      }
    }
  }
}
// 687BC: variable 'v2' is possibly undefined
// 21DF80: using guessed type int g_entities[];

//----- (00068890) --------------------------------------------------------
void __cdecl Bullet_Fire_Extended(int a1, int *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8)
{
  float *v8; // eax
  int *v9; // esi
  long double v10; // fst7
  long double v11; // fst5
  long double v12; // fst6
  float *v13; // eax
  long double v14; // fst1
  int v15; // edx
  _DWORD *v16; // ebx
  long double v17; // fst7
  long double v18; // fst7
  int v19; // [esp+1Ch] [ebp-5Ch]
  int v20; // [esp+20h] [ebp-58h]
  float v21; // [esp+24h] [ebp-54h] BYREF
  float v22; // [esp+28h] [ebp-50h]
  float v23; // [esp+2Ch] [ebp-4Ch]
  float v24[3]; // [esp+30h] [ebp-48h] BYREF
  float v25; // [esp+3Ch] [ebp-3Ch] BYREF
  float v26; // [esp+40h] [ebp-38h]
  float v27; // [esp+44h] [ebp-34h]
  char v28[4]; // [esp+48h] [ebp-30h] BYREF
  float v29; // [esp+4Ch] [ebp-2Ch] BYREF
  float v30; // [esp+50h] [ebp-28h]
  float v31; // [esp+54h] [ebp-24h]
  float v32; // [esp+58h] [ebp-20h] BYREF
  float v33; // [esp+5Ch] [ebp-1Ch]
  float v34; // [esp+60h] [ebp-18h]
  int v35; // [esp+64h] [ebp-14h]
  char v36; // [esp+68h] [ebp-10h]
  unsigned __int16 v37; // [esp+70h] [ebp-8h]
  unsigned __int16 v38; // [esp+74h] [ebp-4h]

  v20 = 0;
  if ( a6 <= 12 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 704) )
    {
      v19 = 2;
      v20 = 32;
    }
    else
    {
      v19 = 1;
    }
    trap_LocationalTrace((int)v28, (int)a3, (int)a4);
    if ( (g_debugBullets[3] & 1) != 0 )
    {
      v8 = (float *)G_TempEntity(a3, 185);
      v8[23] = v29;
      v8[24] = v30;
      v8[25] = v31;
      *((_DWORD *)v8 + 30) = *a2;
    }
    G_CheckHitTriggerDamage(a2, a3, &v29, a5, v19);
    v9 = &g_entities[197 * v37];
    if ( g_debugBullets[3] < -1 )
    {
      v10 = *((float *)v9 + 77);
      v11 = *((float *)v9 + 78);
      v12 = *((float *)v9 + 79);
      v24[0] = v10 + *((float *)v9 + 64);
      v24[1] = v11 + *((float *)v9 + 65);
      v24[2] = v12 + *((float *)v9 + 66);
      v21 = v10 + *((float *)v9 + 67);
      v22 = v11 + *((float *)v9 + 68);
      v23 = v12 + *((float *)v9 + 69);
      v13 = (float *)G_TempEntity(v24, 185);
      v13[23] = v21;
      v13[24] = v22;
      v13[25] = v23;
      *((_DWORD *)v13 + 55) = 2;
    }
    v25 = *a4 - *a3;
    v26 = a4[1] - a3[1];
    v27 = a4[2] - a3[2];
    VectorNormalize(&v25);
    v14 = (v27 * v34 + v26 * v33 + v25 * v32) * -2.0;
    v25 = v32 * v14 + v25;
    v26 = v33 * v14 + v26;
    v27 = v34 * v14 + v27;
    if ( (v35 & 4) == 0 && !v9[86] )
    {
      v15 = 173;
      if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 704) )
        v15 = 174;
      v16 = G_TempEntity(&v29, v15);
      v16[40] = (unsigned __int8)DirToByte(&v32);
      v16[54] = (unsigned __int8)DirToByte(&v25);
      v16[34] = (v35 & 0x1F00000u) >> 20;
      v16[29] = *a8;
    }
    if ( (v36 & 0x10) != 0 )
    {
      v21 = *a4 - *a3;
      v22 = a4[1] - a3[1];
      v23 = a4[2] - a3[2];
      VectorNormalize(&v21);
      v17 = -(v32 * v21 + v33 * v22 + v34 * v23);
      if ( v17 < 0.125 )
        v18 = 0.0;
      else
        v18 = 0.25 / v17;
      *a3 = v21 * v18 + v29;
      a3[1] = v22 * v18 + v30;
      a3[2] = v18 * v23 + v31;
      Bullet_Fire_Extended(a1, a2, a3, a4, a5, a6 + 1, a7, a8);
    }
    else if ( *((_BYTE *)v9 + 369) )
    {
      G_Damage(v9, a2, a2, (float *)a7, &v29, a5, v20, v19, v38);
      if ( v9[86] )
      {
        if ( v20 && a5 / 2 > 0 )
          Bullet_Fire_Extended(v9, a2, &v29, a4, a5 / 2, a6 + 1, a7, a8);
      }
    }
  }
  else
  {
    Com_DPrintf("Bullet_Fire_Extended: Too many resursions, bullet aborted\n");
  }
}
// 21DF80: using guessed type int g_entities[];

//----- (00068C40) --------------------------------------------------------
int __cdecl Weapon_RocketLauncher_Fire(int a1, float a2, int a3)
{
  long double v4; // fst7
  long double v5; // fst5
  long double v6; // rtt
  long double v7; // fst5
  long double v8; // fst4
  long double v9; // fst6
  long double v10; // fst7
  int result; // eax
  long double v12; // [esp+28h] [ebp-50h]
  float v13; // [esp+40h] [ebp-38h] BYREF
  float v14; // [esp+44h] [ebp-34h] BYREF
  double v15; // [esp+48h] [ebp-30h]
  float v16; // [esp+5Ch] [ebp-1Ch]
  float v17[3]; // [esp+60h] [ebp-18h] BYREF
  float v18[3]; // [esp+6Ch] [ebp-Ch] BYREF

  v4 = tan(3.141592653589793 * a2 / 180.0);
  v15 = v4;
  v16 = v4;
  v12 = v16 * 16.0;
  gunrandom(&v13, &v14);
  v5 = v13 * v12;
  v13 = v5;
  v6 = v5;
  v7 = v12 * v14;
  v14 = v7;
  v8 = *(float *)(a3 + 4) * 16.0 + *(float *)(a3 + 16) * v6;
  v9 = 16.0 * *(float *)(a3 + 8);
  v10 = v6 * *(float *)(a3 + 20);
  v18[0] = *(float *)(a3 + 12) * v6 + *(float *)a3 * 16.0 + *(float *)(a3 + 24) * v7;
  v18[1] = v8 + *(float *)(a3 + 28) * v7;
  v18[2] = v10 + v9 + v7 * *(float *)(a3 + 32);
  VectorNormalize(v18);
  v17[0] = *(float *)(a3 + 36);
  v17[1] = *(float *)(a3 + 40);
  v17[2] = *(float *)(a3 + 44);
  fire_rocket((_DWORD *)a1, v17, v18);
  result = *(_DWORD *)(a1 + 344);
  if ( result )
  {
    *(float *)(result + 32) = *(float *)a3 * -64.0 + *(float *)(result + 32);
    *(float *)(*(_DWORD *)(a1 + 344) + 36) = *(float *)(a3 + 4) * -64.0 + *(float *)(*(_DWORD *)(a1 + 344) + 36);
    result = *(_DWORD *)(a1 + 344);
    *(float *)(result + 40) = -64.0 * *(float *)(a3 + 8) + *(float *)(result + 40);
  }
  return result;
}

//----- (00068D68) --------------------------------------------------------
void __cdecl FireWeapon(int a1)
{
  float *v1; // eax
  long double v2; // fst7
  int v3; // edx
  char v4; // fps^1
  long double v5; // fst6
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  long double v9; // fst7
  long double v10; // fst7
  int v11; // eax
  int v12; // ebx
  long double v13; // fst6
  long double v14; // fst7
  long double v15; // fst3
  int v16; // eax
  long double v17; // fst7
  float *v18; // esi
  long double v19; // rtt
  float v20; // [esp-Ch] [ebp-C4h]
  long double v21; // [esp+28h] [ebp-90h]
  float v22; // [esp+34h] [ebp-84h]
  float v23; // [esp+38h] [ebp-80h] BYREF
  float v24; // [esp+3Ch] [ebp-7Ch] BYREF
  double v25; // [esp+40h] [ebp-78h] BYREF
  float v26; // [esp+48h] [ebp-70h]
  float v27; // [esp+4Ch] [ebp-6Ch]
  float v28; // [esp+54h] [ebp-64h]
  float v29[3]; // [esp+58h] [ebp-60h] BYREF
  int v30; // [esp+64h] [ebp-54h]
  __int16 v31; // [esp+68h] [ebp-50h]
  __int16 v32; // [esp+6Ah] [ebp-4Eh]
  float v33; // [esp+6Ch] [ebp-4Ch] BYREF
  float v34; // [esp+70h] [ebp-48h]
  float v35; // [esp+74h] [ebp-44h]
  int v36; // [esp+78h] [ebp-40h] BYREF
  float v37; // [esp+7Ch] [ebp-3Ch]
  float v38; // [esp+80h] [ebp-38h]
  float v39[3]; // [esp+84h] [ebp-34h] BYREF
  float v40[3]; // [esp+90h] [ebp-28h] BYREF
  float v41; // [esp+9Ch] [ebp-1Ch] BYREF
  float v42; // [esp+A0h] [ebp-18h]
  float v43; // [esp+A4h] [ebp-14h]
  int v44; // [esp+B4h] [ebp-4h]

  if ( (*(_BYTE *)(*(_DWORD *)(a1 + 344) + 129) & 0xC0) == 0 || !*(_BYTE *)(a1 + 370) )
  {
    v44 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    v1 = *(float **)(a1 + 344);
    v33 = v1[48];
    v34 = v1[49];
    v35 = v1[50];
    v33 = v1[2179];
    v34 = v1[2180];
    AngleVectors(&v33, (float *)&v36, v39, v40);
    v41 = *(float *)(a1 + 308);
    v42 = *(float *)(a1 + 312);
    v2 = *(float *)(a1 + 316);
    v43 = *(float *)(a1 + 316);
    v43 = v2 + *(float *)(*(_DWORD *)(a1 + 344) + 208);
    G_AddLean(a1, (int)&v41);
    v41 = (float)(int)v41;
    v42 = (float)(int)v42;
    v31 = v32 | 0xC00;
    v30 = (int)v43;
    v43 = (float)v30;
    v3 = *(_DWORD *)(a1 + 344);
    v22 = *(float *)(v3 + 8768);
    v5 = *(float *)(v3 + 184);
    v6 = v5 < 1.0;
    v7 = 0;
    v8 = v5 == 1.0;
    if ( (v4 & 0x44) != 0x40 )
      v9 = BG_GetMinSpreadForWeapon(v3, *(_DWORD *)(a1 + 200), level[122]);
    else
      v9 = *(float *)(v44 + 908);
    v10 = v9 + (*(float *)(v44 + 584) - v9) * v22;
    v11 = *(_DWORD *)(v44 + 112);
    if ( v11 )
    {
      if ( v11 == 1 )
      {
        v16 = *(_DWORD *)(a1 + 200);
        *((float *)&v25 + 1) = (long double)*(int *)(v44 + 788) * *(float *)&v36;
        v26 = (long double)*(int *)(v44 + 788) * v37;
        v17 = (long double)*(int *)(v44 + 788) * v38;
        v27 = v17;
        v27 = v17 + (long double)*(int *)(v44 + 792);
        v18 = (float *)fire_grenade((_DWORD *)a1, &v41, (float *)&v25 + 1, v16);
        VectorNormalize((float *)&v25 + 1);
        v19 = *(float *)(*(_DWORD *)(a1 + 344) + 32) * *((float *)&v25 + 1)
            + *(float *)(*(_DWORD *)(a1 + 344) + 36) * v26
            + *(float *)(*(_DWORD *)(a1 + 344) + 40) * v27;
        v18[9] = *((float *)&v25 + 1) * v19 + v18[9];
        v18[10] = v26 * v19 + v18[10];
        v18[11] = v19 * v27 + v18[11];
      }
      else if ( v11 == 2 )
      {
        v20 = v10;
        Weapon_RocketLauncher_Fire(a1, v20, (int)&v36);
      }
      else
      {
        G_Error("Unknown weapon type %i for %s\n", *(_DWORD *)(v44 + 112), *(const char **)(v44 + 4));
      }
    }
    else
    {
      v12 = *(_DWORD *)(v44 + 448);
      v13 = tan(v10 * 3.141592653589793 / 180.0);
      v25 = v13;
      v28 = v13;
      v21 = v28 * 8192.0;
      gunrandom(&v23, &v24);
      v14 = v23 * v21;
      v15 = v21 * v24;
      v23 = v14;
      v24 = v15;
      v29[0] = v40[0] * v15 + v39[0] * v14 + *(float *)&v36 * 8192.0 + v41;
      v29[1] = v40[1] * v15 + v39[1] * v14 + v37 * 8192.0 + v42;
      v29[2] = v15 * v40[2] + v14 * v39[2] + 8192.0 * v38 + v43;
      Bullet_Fire_Extended(a1, (int *)a1, &v41, v29, v12, 0, (int)&v36, (_DWORD *)a1);
    }
  }
}
// 68EC3: variable 'v4' is possibly undefined

//----- (000690DC) --------------------------------------------------------
void __cdecl Bullet_Fire(int a1, float a2, int a3, int a4, int a5)
{
  long double v6; // fst6
  long double v7; // fst5
  long double v8; // rtt
  long double v9; // fst5
  long double v10; // fst4
  long double v11; // fst6
  long double v12; // rt0
  long double v13; // [esp+28h] [ebp-40h]
  float v14; // [esp+3Ch] [ebp-2Ch] BYREF
  float v15; // [esp+40h] [ebp-28h] BYREF
  double v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+58h] [ebp-10h]
  float v18[3]; // [esp+5Ch] [ebp-Ch] BYREF

  v6 = tan(3.141592653589793 * a2 / 180.0);
  v16 = v6;
  v17 = v6;
  v13 = v17 * 8192.0;
  gunrandom(&v14, &v15);
  v7 = v14 * v13;
  v14 = v7;
  v8 = v7;
  v9 = v13 * v15;
  v15 = v9;
  v10 = *(float *)(a4 + 16) * v8 + *(float *)(a4 + 4) * 8192.0 + *(float *)(a4 + 40);
  v11 = 8192.0 * *(float *)(a4 + 8) + *(float *)(a4 + 44);
  v12 = v8 * *(float *)(a4 + 20);
  v18[0] = *(float *)(a4 + 24) * v9 + *(float *)(a4 + 12) * v8 + *(float *)a4 * 8192.0 + *(float *)(a4 + 36);
  v18[1] = v10 + *(float *)(a4 + 28) * v9;
  v18[2] = v12 + v11 + v9 * *(float *)(a4 + 32);
  Bullet_Fire_Extended(a5, (int *)a1, (float *)(a4 + 36), v18, a3, 0, a4, (_DWORD *)a5);
}

//----- (000691C4) --------------------------------------------------------
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2)
{
  int v2; // eax
  _BOOL4 result; // eax

  result = 0;
  if ( *(_BYTE *)(a1 + 369) )
  {
    if ( a1 != a2 )
    {
      v2 = *(_DWORD *)(a1 + 344);
      if ( v2 )
      {
        if ( *(_DWORD *)(a2 + 344) && *(int *)(v2 + 4) <= 5 && !OnSameTeam(a1, a2) )
          result = 1;
      }
    }
  }
  return result;
}

//----- (00069218) --------------------------------------------------------
int __cdecl CalcMuzzlePoint(int a1, float *a2)
{
  long double v2; // fst7
  int result; // eax

  *a2 = *(float *)(a1 + 308);
  a2[1] = *(float *)(a1 + 312);
  v2 = *(float *)(a1 + 316);
  a2[2] = *(float *)(a1 + 316);
  a2[2] = v2 + *(float *)(*(_DWORD *)(a1 + 344) + 208);
  G_AddLean(a1, (int)a2);
  *a2 = (float)(int)*a2;
  a2[1] = (float)(int)a2[1];
  result = (int)a2[2];
  a2[2] = (float)result;
  return result;
}

//----- (000692D8) --------------------------------------------------------
__int16 __cdecl SnapVectorTowards(int a1, int a2)
{
  int i; // ecx
  __int16 result; // ax
  char v5; // [esp+26h] [ebp-12h]
  char v6; // [esp+27h] [ebp-11h]

  for ( i = 0; i <= 2; ++i )
  {
    _FST7 = *(float *)(a1 + 4 * i);
    LOBYTE(result) = v5;
    if ( _FST7 < *(float *)(a2 + 4 * i) )
    {
      HIBYTE(result) = v6 & 0xF3 | 8;
      __asm { frndint }
    }
    else
    {
      HIBYTE(result) = v6 & 0xF3 | 4;
      __asm { frndint }
    }
    *(float *)(a1 + 4 * i) = _FST7;
  }
  return result;
}
// 69300: variable 'v5' is possibly undefined
// 69304: variable 'v6' is possibly undefined

//----- (00069348) --------------------------------------------------------
float *__cdecl weapon_grenadelauncher_fire(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  long double v4; // fst7
  float *v5; // edi
  long double v6; // rt2
  float *result; // eax
  float v8; // [esp+1Ch] [ebp-Ch] BYREF
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+24h] [ebp-4h]

  v3 = *(_DWORD *)(a3 + 60);
  v8 = (long double)*(int *)(v3 + 788) * *(float *)a3;
  v9 = (long double)*(int *)(v3 + 788) * *(float *)(a3 + 4);
  v4 = (long double)*(int *)(v3 + 788) * *(float *)(a3 + 8);
  v10 = v4;
  v10 = v4 + (long double)*(int *)(v3 + 792);
  v5 = (float *)fire_grenade(a1, (float *)(a3 + 36), &v8, a2);
  VectorNormalize(&v8);
  v6 = *(float *)(a1[86] + 32) * v8 + *(float *)(a1[86] + 36) * v9 + *(float *)(a1[86] + 40) * v10;
  v5[9] = v8 * v6 + v5[9];
  v5[10] = v9 * v6 + v5[10];
  result = v5;
  v5[11] = v6 * v10 + v5[11];
  return result;
}

//----- (000693F4) --------------------------------------------------------
int __cdecl CalcMuzzlePoints(int a1, float *a2)
{
  float *v2; // eax
  long double v3; // fst7
  int result; // eax
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]

  v2 = *(float **)(a1 + 344);
  v5 = v2[48];
  v6 = v2[49];
  v7 = v2[50];
  v5 = v2[2179];
  v6 = v2[2180];
  AngleVectors(&v5, a2, a2 + 3, a2 + 6);
  a2[9] = *(float *)(a1 + 308);
  a2[10] = *(float *)(a1 + 312);
  v3 = *(float *)(a1 + 316);
  a2[11] = *(float *)(a1 + 316);
  a2[11] = v3 + *(float *)(*(_DWORD *)(a1 + 344) + 208);
  G_AddLean(a1, (int)(a2 + 9));
  a2[9] = (float)(int)a2[9];
  a2[10] = (float)(int)a2[10];
  result = (int)a2[11];
  a2[11] = (float)result;
  return result;
}

//----- (00069504) --------------------------------------------------------
void __cdecl FireWeaponMelee(int a1)
{
  long double v1; // fst7
  float v2[3]; // [esp+18h] [ebp-40h] BYREF
  float v3[3]; // [esp+24h] [ebp-34h] BYREF
  float v4[3]; // [esp+30h] [ebp-28h] BYREF
  float v5; // [esp+3Ch] [ebp-1Ch] BYREF
  float v6; // [esp+40h] [ebp-18h]
  float v7; // [esp+44h] [ebp-14h]
  int v8; // [esp+54h] [ebp-4h]

  if ( (*(_BYTE *)(*(_DWORD *)(a1 + 344) + 129) & 0xC0) == 0 || !*(_BYTE *)(a1 + 370) )
  {
    v8 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    AngleVectors((float *)(*(_DWORD *)(a1 + 344) + 192), v2, v3, v4);
    v5 = *(float *)(a1 + 308);
    v6 = *(float *)(a1 + 312);
    v1 = *(float *)(a1 + 316);
    v7 = *(float *)(a1 + 316);
    v7 = v1 + *(float *)(*(_DWORD *)(a1 + 344) + 208);
    G_AddLean(a1, (int)&v5);
    v5 = (float)(int)v5;
    v6 = (float)(int)v6;
    v7 = (float)(int)v7;
    Weapon_Melee((int *)a1, v2);
  }
}

//----- (00069624) --------------------------------------------------------
float *__cdecl Bullet_Endpos(float a1, int a2, int a3)
{
  long double v4; // fst6
  float *result; // eax
  long double v6; // fst5
  long double v7; // rtt
  long double v8; // fst5
  long double v9; // fst4
  long double v10; // fst3
  long double v11; // rt0
  long double v12; // fst3
  long double v13; // rt1
  long double v14; // fst3
  long double v15; // rt2
  long double v16; // fst3
  long double v17; // fst4
  long double v18; // [esp+18h] [ebp-40h]
  float v19; // [esp+38h] [ebp-20h] BYREF
  float v20; // [esp+3Ch] [ebp-1Ch] BYREF
  double v21; // [esp+40h] [ebp-18h]
  float v22; // [esp+54h] [ebp-4h]

  v4 = tan(3.141592653589793 * a1 / 180.0);
  v21 = v4;
  v22 = v4;
  v18 = v22 * 8192.0;
  result = gunrandom(&v19, &v20);
  v6 = v19 * v18;
  v19 = v6;
  v7 = v6;
  v8 = v18 * v20;
  v20 = v8;
  v9 = *(float *)a3 * 8192.0 + *(float *)(a3 + 36);
  *(float *)a2 = v9;
  v10 = *(float *)(a3 + 4) * 8192.0 + *(float *)(a3 + 40);
  *(float *)(a2 + 4) = v10;
  v11 = v10;
  v12 = 8192.0 * *(float *)(a3 + 8) + *(float *)(a3 + 44);
  *(float *)(a2 + 8) = v12;
  v13 = v12;
  v14 = v9 + *(float *)(a3 + 12) * v7;
  *(float *)a2 = v14;
  v15 = v14;
  v16 = v11 + *(float *)(a3 + 16) * v7;
  *(float *)(a2 + 4) = v16;
  v17 = v13 + v7 * *(float *)(a3 + 20);
  *(float *)(a2 + 8) = v17;
  *(float *)a2 = v15 + *(float *)(a3 + 24) * v8;
  *(float *)(a2 + 4) = v16 + *(float *)(a3 + 28) * v8;
  *(float *)(a2 + 8) = v17 + v8 * *(float *)(a3 + 32);
  return result;
}

//----- (00069700) --------------------------------------------------------
int Com_ScriptError(char *format, ...)
{
  char s[32000]; // [esp+18h] [ebp-7D00h] BYREF
  va_list __varargs; // [esp+7D24h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return Com_Error(1, (char *)&byte_79DC8, off_83260 + 1052, *((_DWORD *)off_83260 + 256), s);
}

//----- (00069750) --------------------------------------------------------
int Com_ScriptWarning(char *format, ...)
{
  char s[32000]; // [esp+18h] [ebp-7D00h] BYREF
  va_list __varargs; // [esp+7D24h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  vsprintf(s, format, __varargs);
  return Com_Printf("File %s, line %i: %s", off_83260 + 1052, *((_DWORD *)off_83260 + 256), s);
}

//----- (00069798) --------------------------------------------------------
int __cdecl Com_Compress(_BYTE *a1)
{
  _BYTE *v1; // ebx
  int v2; // esi
  char *v3; // ecx
  char v4; // al
  char v5; // dl

  v1 = a1;
  v2 = 0;
  v3 = a1;
  if ( a1 )
  {
    v4 = *a1;
    if ( *a1 )
    {
      do
      {
        if ( v4 == 13 || v4 == 10 )
        {
          *v1++ = v4;
          ++v3;
        }
        else
        {
          if ( v4 == 47 )
          {
            v5 = v3[1];
            if ( v5 == 47 )
            {
              while ( *v3 && *v3 != 10 )
                ++v3;
              goto LABEL_22;
            }
            if ( v5 == 42 )
            {
              if ( *v3 )
              {
                while ( *++v3 )
                {
                  if ( *v3 == 42 && v3[1] == 47 )
                  {
                    v3 += 2;
                    goto LABEL_22;
                  }
                }
              }
              goto LABEL_22;
            }
          }
          *v1++ = v4;
          ++v3;
        }
        ++v2;
LABEL_22:
        v4 = *v3;
      }
      while ( *v3 );
    }
  }
  *v1 = 0;
  return v2;
}

//----- (00069834) --------------------------------------------------------
char *__cdecl sub_69834(char **a1, int a2)
{
  int v2; // ebx
  char *v3; // ecx
  char v4; // dl
  char v5; // al

  v2 = 0;
  v3 = *a1;
  *off_83260 = 0;
  if ( a2 )
  {
    while ( *v3 == 13 || *v3 == 10 )
      ++v3;
  }
  else if ( *v3 == 13 || *v3 == 10 )
  {
    return off_83260;
  }
  dword_AD508 = dword_AD504;
  dword_AD504 = (int)v3;
  while ( 1 )
  {
    v5 = *v3;
    if ( !*v3 )
    {
      *a1 = 0;
      goto LABEL_29;
    }
    if ( v5 == 44 || v5 == 10 )
      break;
    v4 = *v3;
    if ( *v3 != 13 )
    {
      if ( v4 == 34 )
      {
        while ( 1 )
        {
          ++v3;
          while ( *v3 == 34 )
          {
            if ( v3[1] != 34 )
              goto LABEL_21;
            if ( v2 <= 1022 )
              off_83260[v2++] = 34;
            v3 += 2;
          }
          if ( v2 <= 1022 )
            off_83260[v2++] = *v3;
        }
      }
      if ( v2 <= 1022 )
        off_83260[v2++] = v4;
    }
LABEL_21:
    ++v3;
  }
  if ( v5 != 10 )
    ++v3;
  *a1 = v3;
LABEL_29:
  off_83260[v2] = 0;
  return off_83260;
}
// 698E7: conditional instruction was optimized away because of 'al.1 in (==A|==2C)'
// AD504: using guessed type int dword_AD504;
// AD508: using guessed type int dword_AD508;

//----- (0006990C) --------------------------------------------------------
char *__cdecl sub_6990C(char **a1, int a2)
{
  int v2; // ebx
  char *v3; // ecx
  char *v5; // eax
  char *v6; // esi
  int v7; // eax
  char *v8; // edx
  char v9; // dl
  char v10; // al
  char *v11; // edx
  char *v12; // ecx
  char v13; // dl
  char v14; // al
  char v15; // al
  char v16; // dl
  char **v17; // eax
  char *v18; // esi
  signed int v19; // ebx
  _BYTE *v20; // ecx
  int v21; // edx
  int v22; // edx
  int v23; // ecx
  _BYTE *v24; // edi
  void **v25; // [esp+20h] [ebp-8h]
  int v26; // [esp+24h] [ebp-4h]

  v26 = 0;
  if ( !a1 )
    Com_Error(0, (char *)&byte_79E0B);
  v2 = 0;
  v3 = *a1;
  *off_83260 = 0;
  if ( !v3 )
  {
    *a1 = 0;
    return off_83260;
  }
  v5 = off_83260;
  *((_DWORD *)off_83260 + 261) = *((_DWORD *)off_83260 + 256);
  *((_DWORD *)v5 + 262) = *a1;
  if ( *((_DWORD *)v5 + 259) )
    return sub_69834(a1, a2);
  while ( 1 )
  {
    while ( 1 )
    {
LABEL_7:
      v6 = v3;
      v7 = *v3;
      if ( v7 <= 32 )
      {
        v8 = off_83260;
        while ( v7 )
        {
          if ( v7 == 10 )
          {
            ++*((_DWORD *)v8 + 256);
            v26 = 1;
          }
          v7 = *++v6;
          if ( v7 > 32 )
            goto LABEL_13;
        }
LABEL_14:
        *a1 = 0;
        return off_83260;
      }
LABEL_13:
      v3 = v6;
      if ( !v6 )
        goto LABEL_14;
      if ( v26 && !a2 )
      {
        *a1 = v6;
        return off_83260;
      }
      v9 = *v6;
      if ( *v6 != 47 )
        goto LABEL_30;
      v10 = v6[1];
      if ( v10 != 47 )
        break;
      do
        ++v3;
      while ( *v3 && *v3 != 10 );
    }
    if ( v10 != 42 )
      break;
    v11 = off_83260;
    while ( 1 )
    {
      if ( *v3 == 10 )
        ++*((_DWORD *)v11 + 256);
      if ( !*++v3 )
        break;
      if ( *v3 == 42 && v3[1] == 47 )
      {
        v3 += 2;
        goto LABEL_7;
      }
    }
  }
LABEL_30:
  dword_AD508 = dword_AD504;
  dword_AD504 = (int)v6;
  if ( v9 == 34 )
  {
    v12 = v6 + 1;
    while ( 1 )
    {
      v13 = *v12++;
      if ( v13 == 92 && *v12 == 34 )
      {
        v13 = 34;
        ++v12;
      }
      else
      {
        if ( v13 == 34 || !v13 )
        {
          off_83260[v2] = 0;
          *a1 = v12;
          return off_83260;
        }
        if ( *v12 == 10 )
          ++*((_DWORD *)off_83260 + 256);
      }
      if ( v2 <= 1022 )
        off_83260[v2++] = v13;
    }
  }
  if ( *((_DWORD *)off_83260 + 258) )
  {
    do
    {
      if ( v2 <= 1022 )
        off_83260[v2++] = v9;
      v9 = *++v3;
    }
    while ( *v3 > 32 );
    if ( v2 == 1024 )
      v2 = 0;
    off_83260[v2] = 0;
    *a1 = v3;
    return off_83260;
  }
  if ( (unsigned __int8)(v9 - 48) <= 9u
    || *((_DWORD *)off_83260 + 260) && v9 == 45 && (v14 = v6[1], v14 > 47) && v14 <= 57
    || v9 == 46 && (v15 = v6[1], v15 > 47) && v15 <= 57 )
  {
    do
    {
      if ( v2 <= 1022 )
        off_83260[v2++] = v9;
      v9 = *++v3;
    }
    while ( (unsigned __int8)(*v3 - 48) <= 9u || v9 == 46 );
    if ( v9 == 101 || v9 == 69 )
    {
      if ( v2 <= 1022 )
        off_83260[v2++] = v9;
      v16 = *++v3;
      if ( *v3 == 45 || v16 == 43 )
      {
        if ( v2 <= 1022 )
          off_83260[v2++] = v16;
        v16 = *++v3;
      }
      do
      {
        if ( v2 <= 1022 )
          off_83260[v2++] = v16;
        v16 = *++v3;
      }
      while ( (unsigned __int8)(*v3 - 48) <= 9u );
    }
    if ( v2 == 1024 )
      v2 = 0;
    off_83260[v2] = 0;
    *a1 = v3;
    return off_83260;
  }
  if ( (unsigned __int8)(v9 - 97) <= 0x19u || (unsigned __int8)(v9 - 65) <= 0x19u || v9 == 95 || v9 == 47 || v9 == 92 )
  {
    do
    {
      if ( v2 <= 1022 )
        off_83260[v2++] = v9;
      v9 = *++v3;
    }
    while ( (unsigned __int8)(*v3 - 97) <= 0x19u
         || (unsigned __int8)(v9 - 65) <= 0x19u
         || v9 == 95
         || (unsigned __int8)(v9 - 48) <= 9u
         || v9 == 47
         || v9 == 92
         || v9 == 58
         || v9 == 46 );
    if ( v2 == 1024 )
      v2 = 0;
    off_83260[v2] = 0;
    *a1 = v3;
    return off_83260;
  }
  v25 = &off_7EC60;
  if ( off_7EC60 )
  {
    do
    {
      v19 = 0;
      v20 = *v25;
      v21 = (unsigned int)*v25 & 3;
      if ( !v21 )
        goto LABEL_106;
      if ( !__SETP__((unsigned int)*v25 & 3, 0) )
      {
        if ( v21 != 2 )
        {
          if ( *v20 == BYTE1(v21) )
            goto LABEL_113;
          ++v20;
        }
        if ( *v20 == BYTE1(v21) )
          goto LABEL_113;
        ++v20;
      }
      if ( *v20 != BYTE1(v21) )
      {
        ++v20;
LABEL_106:
        while ( 1 )
        {
          v22 = *(_DWORD *)v20;
          if ( !(unsigned __int8)*(_DWORD *)v20 )
            break;
          if ( !BYTE1(v22) )
            goto LABEL_112;
          if ( (v22 & 0xFF0000) == 0 )
            goto LABEL_111;
          v20 += 4;
          if ( (v22 & 0xFF000000) == 0 )
          {
            v20 -= 3;
LABEL_111:
            ++v20;
LABEL_112:
            ++v20;
            break;
          }
        }
      }
LABEL_113:
      v23 = v20 - (_BYTE *)*v25;
      v24 = *v25;
      if ( v23 > 0 && *v6 == *v24 )
      {
        do
          ++v19;
        while ( v19 < v23 && v6[v19] == v24[v19] );
      }
      if ( v19 == v23 )
      {
        memcpy(off_83260, v24, v19);
        off_83260[v19] = 0;
        v17 = a1;
        v18 = &v6[v19];
        goto LABEL_120;
      }
      ++v25;
    }
    while ( *v25 );
  }
  *off_83260 = *v6;
  off_83260[1] = 0;
  v17 = a1;
  v18 = v6 + 1;
LABEL_120:
  *v17 = v18;
  return off_83260;
}
// 7EC60: using guessed type void *off_7EC60;
// AD504: using guessed type int dword_AD504;
// AD508: using guessed type int dword_AD508;

//----- (00069D48) --------------------------------------------------------
int __cdecl Com_MatchToken(int a1, char *s2, int a3)
{
  char *v3; // eax
  char *v4; // ebx
  int result; // eax

  v3 = off_83260;
  if ( *((_DWORD *)off_83260 + 257) )
  {
    *((_DWORD *)off_83260 + 257) = 0;
    *(_DWORD *)a1 = *((_DWORD *)v3 + 262);
    *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
  }
  v4 = sub_6990C((char **)a1, 1);
  result = strcmp(v4, s2);
  if ( result )
  {
    if ( a3 )
      result = Com_ScriptWarning("MatchToken: %s != %s", v4, s2);
    else
      result = Com_ScriptError("MatchToken: %s != %s", v4, s2);
  }
  return result;
}

//----- (00069DD8) --------------------------------------------------------
char *__cdecl Com_BeginParseSession(char *src)
{
  int v1; // eax
  char *v2; // edx

  if ( dword_AD500 == 15 )
    Com_Error(0, (char *)&byte_79D60);
  v1 = dword_AD500++;
  v2 = (char *)&unk_7ECA0 + 1116 * v1 + 1116;
  off_83260 = v2;
  *((_DWORD *)v2 + 256) = 1;
  *((_DWORD *)v2 + 257) = 0;
  *((_DWORD *)v2 + 258) = 1;
  *((_DWORD *)v2 + 259) = 0;
  return Q_strncpyz(v2 + 1052, src, 64);
}
// AD500: using guessed type int dword_AD500;

//----- (00069E60) --------------------------------------------------------
char *Com_EndParseSession()
{
  char *result; // eax

  if ( !dword_AD500 )
    Com_Error(0, (char *)&byte_79DA0);
  --dword_AD500;
  result = (char *)&unk_7ECA0 + 1116 * dword_AD500;
  off_83260 = result;
  return result;
}
// AD500: using guessed type int dword_AD500;

//----- (00069EA4) --------------------------------------------------------
void Com_ResetParseSessions()
{
  dword_AD500 = 0;
  off_83260 = (char *)&unk_7ECA0;
}
// AD500: using guessed type int dword_AD500;

//----- (00069EC0) --------------------------------------------------------
char *__cdecl Com_SetSpaceDelimited(int a1)
{
  char *result; // eax

  result = off_83260;
  *((_DWORD *)off_83260 + 258) = a1;
  return result;
}

//----- (00069ED8) --------------------------------------------------------
char *__cdecl Com_SetCSV(int a1)
{
  char *result; // eax

  result = off_83260;
  *((_DWORD *)off_83260 + 259) = a1;
  return result;
}

//----- (00069EF0) --------------------------------------------------------
char *__cdecl Com_SetParseNegativeNumbers(int a1)
{
  char *result; // eax

  result = off_83260;
  *((_DWORD *)off_83260 + 260) = a1;
  return result;
}

//----- (00069F08) --------------------------------------------------------
int Com_GetCurrentParseLine()
{
  return *((_DWORD *)off_83260 + 256);
}

//----- (00069F1C) --------------------------------------------------------
char *__cdecl Com_Parse(char **a1)
{
  char *v1; // eax

  v1 = off_83260;
  if ( *((_DWORD *)off_83260 + 257) )
  {
    *((_DWORD *)off_83260 + 257) = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
  }
  return sub_6990C(a1, 1);
}

//----- (00069F68) --------------------------------------------------------
char *__cdecl Com_ParseOnLine(char **a1)
{
  char *result; // eax

  result = off_83260;
  if ( *((_DWORD *)off_83260 + 257) )
  {
    *((_DWORD *)off_83260 + 257) = 0;
    if ( !*((_DWORD *)result + 258) )
      return result;
    *a1 = (char *)*((_DWORD *)result + 262);
    *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
  }
  return sub_6990C(a1, 0);
}

//----- (00069FBC) --------------------------------------------------------
char *__cdecl Com_ParseRestOfLine(char **a1)
{
  char *v1; // eax
  char *v2; // ebx

  for ( byte_AD100 = 0; ; Q_strcat((int)&byte_AD100, 1024, v2) )
  {
    v1 = off_83260;
    if ( *((_DWORD *)off_83260 + 257) )
    {
      *((_DWORD *)off_83260 + 257) = 0;
      if ( !*((_DWORD *)v1 + 258) )
      {
        v2 = v1;
        goto LABEL_10;
      }
      *a1 = (char *)*((_DWORD *)v1 + 262);
      *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
    }
    v2 = sub_6990C(a1, 0);
LABEL_10:
    if ( !*v2 )
      break;
    if ( byte_AD100 )
      Q_strcat((int)&byte_AD100, 1024, (char *)off_79E3B);
  }
  return &byte_AD100;
}
// AD100: using guessed type char byte_AD100;

//----- (0006A074) --------------------------------------------------------
int Com_GetLastTokenPos()
{
  return dword_AD504;
}
// AD504: using guessed type int dword_AD504;

//----- (0006A080) --------------------------------------------------------
int Com_UngetToken()
{
  int result; // eax

  if ( *((_DWORD *)off_83260 + 257) )
    Com_ScriptError("UngetToken called twice");
  *((_DWORD *)off_83260 + 257) = 1;
  result = dword_AD508;
  dword_AD504 = dword_AD508;
  return result;
}
// AD504: using guessed type int dword_AD504;
// AD508: using guessed type int dword_AD508;

//----- (0006A0C0) --------------------------------------------------------
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2)
{
  char *v2; // edx
  int result; // eax

  v2 = off_83260;
  *a2 = *((_DWORD *)off_83260 + 256);
  a2[1] = *a1;
  a2[2] = *((_DWORD *)v2 + 257);
  a2[3] = *((_DWORD *)v2 + 261);
  result = *((_DWORD *)v2 + 262);
  a2[4] = result;
  return result;
}

//----- (0006A100) --------------------------------------------------------
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2)
{
  char *v2; // edx
  int result; // eax

  *((_DWORD *)off_83260 + 256) = *a2;
  *a1 = a2[1];
  v2 = off_83260;
  *((_DWORD *)off_83260 + 257) = a2[2];
  *((_DWORD *)v2 + 261) = a2[3];
  result = a2[4];
  *((_DWORD *)v2 + 262) = result;
  return result;
}

//----- (0006A144) --------------------------------------------------------
int __cdecl Com_SkipBracedSection(char **a1, int a2)
{
  int v2; // edi
  int v3; // ebx
  char *v4; // eax
  char *v5; // eax
  char v6; // al

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = off_83260;
    if ( *((_DWORD *)off_83260 + 257) )
    {
      *((_DWORD *)off_83260 + 257) = 0;
      *a1 = (char *)*((_DWORD *)v4 + 262);
      *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
    }
    v5 = sub_6990C(a1, 1);
    if ( !v5[1] )
    {
      v6 = *v5;
      if ( v6 == 123 )
      {
        if ( v3 == a2 )
          v2 = 1;
        else
          ++v3;
      }
      else if ( v6 == 125 )
      {
        --v3;
      }
    }
  }
  while ( v3 && *a1 );
  return v2;
}

//----- (0006A1CC) --------------------------------------------------------
void __cdecl Com_SkipRestOfLine(_BYTE **a1)
{
  _BYTE *v1; // edx
  int v2; // eax

  v1 = *a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = (char)*v1;
      if ( !*v1 )
        break;
      ++v1;
      if ( v2 == 10 )
      {
        ++*((_DWORD *)off_83260 + 256);
        break;
      }
    }
    *a1 = v1;
  }
}

//----- (0006A1FC) --------------------------------------------------------
long double __cdecl Com_ParseFloat(char **a1)
{
  char *v1; // eax
  char *v2; // eax

  v1 = off_83260;
  if ( *((_DWORD *)off_83260 + 257) )
  {
    *((_DWORD *)off_83260 + 257) = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
  }
  v2 = sub_6990C(a1, 1);
  if ( !*v2 )
    return 0.0;
  return (float)_strtod_internal(v2, 0, 0);
}

//----- (0006A268) --------------------------------------------------------
int __cdecl Com_ParseInt(char **a1)
{
  char *v1; // eax
  char *v2; // eax
  int result; // eax

  v1 = off_83260;
  if ( *((_DWORD *)off_83260 + 257) )
  {
    *((_DWORD *)off_83260 + 257) = 0;
    *a1 = (char *)*((_DWORD *)v1 + 262);
    *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
  }
  v2 = sub_6990C(a1, 1);
  if ( *v2 )
    result = _strtol_internal(v2, 0, 10, 0);
  else
    result = 0;
  return result;
}

//----- (0006A2CC) --------------------------------------------------------
int __cdecl Com_Parse1DMatrix(char **a1, int a2, int a3)
{
  int i; // ebx
  char *v4; // eax
  char *v5; // eax

  Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
  for ( i = 0; i < a2; ++i )
  {
    v4 = off_83260;
    if ( *((_DWORD *)off_83260 + 257) )
    {
      *((_DWORD *)off_83260 + 257) = 0;
      *a1 = (char *)*((_DWORD *)v4 + 262);
      *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
    }
    v5 = sub_6990C(a1, 1);
    *(float *)(a3 + 4 * i) = _strtod_internal(v5, 0, 0);
  }
  return Com_MatchToken((int)a1, ")", 0);
}

//----- (0006A36C) --------------------------------------------------------
int __cdecl Com_Parse2DMatrix(char **a1, int a2, int a3, int a4)
{
  int i; // esi
  int j; // ebx
  char *v6; // eax
  char *v7; // eax
  int v9; // [esp+20h] [ebp-8h]

  Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
  for ( i = 0; i < a2; ++i )
  {
    v9 = a4 + 4 * a3 * i;
    Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
    for ( j = 0; j < a3; ++j )
    {
      v6 = off_83260;
      if ( *((_DWORD *)off_83260 + 257) )
      {
        *((_DWORD *)off_83260 + 257) = 0;
        *a1 = (char *)*((_DWORD *)v6 + 262);
        *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
      }
      v7 = sub_6990C(a1, 1);
      *(float *)(v9 + 4 * j) = _strtod_internal(v7, 0, 0);
    }
    Com_MatchToken((int)a1, ")", 0);
  }
  return Com_MatchToken((int)a1, ")", 0);
}

//----- (0006A454) --------------------------------------------------------
int __cdecl Com_Parse3DMatrix(char **a1, int a2, int a3, int a4, int a5)
{
  int i; // esi
  int v6; // ebx
  int v7; // esi
  char *v8; // eax
  char *v9; // eax
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]

  Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
  for ( i = 0; i < a2; i = v11 )
  {
    v13 = a5 + 4 * a3 * a4 * i;
    Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
    v6 = 0;
    v11 = i + 1;
    while ( v6 < a3 )
    {
      v12 = v13 + 4 * a4 * v6;
      Com_MatchToken((int)a1, (char *)&off_79E3B[2], 0);
      v7 = 0;
      ++v6;
      if ( a4 > 0 )
      {
        do
        {
          v8 = off_83260;
          if ( *((_DWORD *)off_83260 + 257) )
          {
            *((_DWORD *)off_83260 + 257) = 0;
            *a1 = (char *)*((_DWORD *)v8 + 262);
            *((_DWORD *)off_83260 + 256) = *((_DWORD *)off_83260 + 261);
          }
          v9 = sub_6990C(a1, 1);
          *(float *)(v12 + 4 * v7++) = _strtod_internal(v9, 0, 0);
        }
        while ( v7 < a4 );
      }
      Com_MatchToken((int)a1, ")", 0);
    }
    Com_MatchToken((int)a1, ")", 0);
  }
  return Com_MatchToken((int)a1, ")", 0);
}

//----- (0006A5A0) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list __varargs; // [esp+2Ch] [ebp+14h] BYREF

  va_start(__varargs, format);
  result = vsnprintf(s, maxlen, format, __varargs);
  s[maxlen - 1] = 0;
  return result;
}

//----- (0006A5CC) --------------------------------------------------------
char *va(char *format, ...)
{
  unsigned int v1; // ebx
  char *v2; // esi
  va_list __varargs; // [esp+24h] [ebp+Ch] BYREF

  va_start(__varargs, format);
  v1 = vsnprintf(s, 0x7D00u, format, __varargs);
  byte_B529F = 0;
  if ( v1 > 0x7CFF )
    Com_Error(1, (char *)&byte_7A060);
  if ( (int)(dword_83264 + v1) > 31998 )
    dword_83264 = 0;
  v2 = (char *)&unk_B52A0 + dword_83264;
  memcpy((char *)&unk_B52A0 + dword_83264, s, v1 + 1);
  dword_83264 += v1 + 1;
  return v2;
}
// 83264: using guessed type int dword_83264;
// B529F: using guessed type char byte_B529F;

//----- (0006A660) --------------------------------------------------------
char *__cdecl Info_ValueForKey(_BYTE *a1, char *a2)
{
  char *v2; // ebx
  _DWORD *v4; // eax
  int v5; // edx
  int v6; // edx
  char *v7; // edx
  _BYTE *v8; // ebx
  _BYTE *v9; // edx
  char *v10; // edi
  char *v11; // esi
  int v12; // edx
  int v13; // ecx
  int v15; // eax
  int v16; // [esp+24h] [ebp-2004h]
  char v17[8192]; // [esp+28h] [ebp-2000h] BYREF

  v2 = a1;
  if ( !a1 || !a2 )
    return (char *)&unk_7A08E;
  v4 = a1;
  v5 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) == 0 )
    goto LABEL_14;
  if ( __SETP__((unsigned __int8)a1 & 3, 0) )
    goto LABEL_12;
  if ( v5 != 2 )
  {
    if ( *a1 == BYTE1(v5) )
      goto LABEL_21;
    v4 = a1 + 1;
  }
  if ( *(_BYTE *)v4 != BYTE1(v5) )
  {
    v4 = (_DWORD *)((char *)v4 + 1);
LABEL_12:
    if ( *(_BYTE *)v4 != BYTE1(v5) )
    {
      v4 = (_DWORD *)((char *)v4 + 1);
LABEL_14:
      while ( 1 )
      {
        v6 = *v4;
        if ( !(unsigned __int8)*v4 )
          break;
        if ( !BYTE1(v6) )
          goto LABEL_20;
        if ( (v6 & 0xFF0000) == 0 )
          goto LABEL_19;
        ++v4;
        if ( (v6 & 0xFF000000) == 0 )
        {
          v4 = (_DWORD *)((char *)v4 - 3);
LABEL_19:
          v4 = (_DWORD *)((char *)v4 + 1);
LABEL_20:
          v4 = (_DWORD *)((char *)v4 + 1);
          break;
        }
      }
    }
  }
LABEL_21:
  if ( (unsigned int)((char *)v4 - a1) > 0x1FFF )
    Com_Error(1, (char *)&byte_7A0A0);
  LOBYTE(dword_83268) = dword_83268 ^ 1;
  if ( *a1 == 92 )
    v2 = a1 + 1;
  while ( 1 )
  {
    v7 = v17;
    if ( *v2 != 92 )
      break;
LABEL_28:
    *v7 = 0;
    v8 = v2 + 1;
    v9 = (char *)&unk_BCFA0 + 0x2000 * dword_83268;
    while ( *v8 != 92 && *v8 )
      *v9++ = *v8++;
    *v9 = 0;
    v10 = a2;
    v11 = v17;
    v16 = 99999;
    while ( 1 )
    {
      v12 = *v10++;
      v13 = *v11++;
      if ( v16-- == 0 )
      {
LABEL_43:
        v15 = 0;
        goto LABEL_44;
      }
      if ( v12 != v13 )
      {
        if ( (unsigned int)(v12 - 97) <= 0x19 )
          v12 -= 32;
        if ( (unsigned int)(v13 - 97) <= 0x19 )
          v13 -= 32;
        if ( v12 != v13 )
          break;
      }
      if ( !v12 )
        goto LABEL_43;
    }
    v15 = 1;
    if ( v12 < v13 )
      v15 = -1;
LABEL_44:
    if ( !v15 )
      return (char *)&unk_BCFA0 + 0x2000 * dword_83268;
    if ( !*v8 )
      return (char *)&unk_7A08E;
    v2 = v8 + 1;
  }
  while ( *v2 )
  {
    *v7++ = *v2++;
    if ( *v2 == 92 )
      goto LABEL_28;
  }
  return (char *)&unk_7A08E;
}
// 6A74F: conditional instruction was optimized away because of '%arg_4.4!=0'
// 83268: using guessed type int dword_83268;

//----- (0006A7D4) --------------------------------------------------------
char __cdecl Info_RemoveKey(char *dest, char *s)
{
  char *v2; // ebx
  char *v3; // eax
  int v4; // edx
  int v5; // edx
  char *v6; // eax
  char *v7; // esi
  char *v8; // edx
  char *v9; // edx
  char v11; // [esp+18h] [ebp-800h] BYREF
  char s2[1024]; // [esp+418h] [ebp-400h] BYREF

  v2 = dest;
  v3 = dest;
  v4 = (unsigned __int8)dest & 3;
  if ( ((unsigned __int8)dest & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_8;
    if ( v4 != 2 )
    {
      if ( *dest == BYTE1(v4) )
        goto LABEL_17;
      v3 = dest + 1;
    }
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_8:
      if ( *v3 != BYTE1(v4) )
      {
        ++v3;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)v3;
      if ( !(unsigned __int8)*(_DWORD *)v3 )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      v3 += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        v3 -= 3;
LABEL_15:
        ++v3;
LABEL_16:
        ++v3;
        break;
      }
    }
  }
LABEL_17:
  if ( (unsigned int)(v3 - dest) > 0x3FF )
    Com_Error(1, (char *)&byte_7A0E0);
  v6 = strchr(s, 92);
  if ( !v6 )
  {
    while ( 1 )
    {
      v7 = v2;
      if ( *v2 == 92 )
        ++v2;
      v8 = s2;
      if ( *v2 != 92 )
        break;
LABEL_25:
      *v8 = 0;
      ++v2;
      v9 = &v11;
      while ( *v2 != 92 && *v2 )
        *v9++ = *v2++;
      *v9 = 0;
      v6 = (char *)strcmp(s, s2);
      if ( !v6 )
      {
        LOBYTE(v6) = (unsigned __int8)strcpy(v7, v2);
        return (char)v6;
      }
      if ( !*v2 )
        return (char)v6;
    }
    while ( 1 )
    {
      LOBYTE(v6) = *v2;
      if ( !*v2 )
        break;
      *v8 = (char)v6;
      ++v2;
      ++v8;
      if ( *v2 == 92 )
        goto LABEL_25;
    }
  }
  return (char)v6;
}

//----- (0006A8D4) --------------------------------------------------------
char __cdecl Info_RemoveKey_Big(char *dest, char *s)
{
  char *v2; // ebx
  char *v3; // eax
  int v4; // edx
  int v5; // edx
  char *v6; // eax
  char *v7; // esi
  char *v8; // edx
  char *v9; // edx
  char v11; // [esp+18h] [ebp-4000h] BYREF
  char s2[8192]; // [esp+2018h] [ebp-2000h] BYREF

  v2 = dest;
  v3 = dest;
  v4 = (unsigned __int8)dest & 3;
  if ( ((unsigned __int8)dest & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_8;
    if ( v4 != 2 )
    {
      if ( *dest == BYTE1(v4) )
        goto LABEL_17;
      v3 = dest + 1;
    }
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_8:
      if ( *v3 != BYTE1(v4) )
      {
        ++v3;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)v3;
      if ( !(unsigned __int8)*(_DWORD *)v3 )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      v3 += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        v3 -= 3;
LABEL_15:
        ++v3;
LABEL_16:
        ++v3;
        break;
      }
    }
  }
LABEL_17:
  if ( (unsigned int)(v3 - dest) > 0x1FFF )
    Com_Error(1, (char *)&byte_7A120);
  v6 = strchr(s, 92);
  if ( !v6 )
  {
    while ( 1 )
    {
      v7 = v2;
      if ( *v2 == 92 )
        ++v2;
      v8 = s2;
      if ( *v2 != 92 )
        break;
LABEL_25:
      *v8 = 0;
      ++v2;
      v9 = &v11;
      while ( *v2 != 92 && *v2 )
        *v9++ = *v2++;
      *v9 = 0;
      v6 = (char *)strcmp(s, s2);
      if ( !v6 )
      {
        LOBYTE(v6) = (unsigned __int8)strcpy(v7, v2);
        return (char)v6;
      }
      if ( !*v2 )
        return (char)v6;
    }
    while ( 1 )
    {
      LOBYTE(v6) = *v2;
      if ( !*v2 )
        break;
      *v8 = (char)v6;
      ++v2;
      ++v8;
      if ( *v2 == 92 )
        goto LABEL_25;
    }
  }
  return (char)v6;
}

//----- (0006A9D4) --------------------------------------------------------
char __cdecl Info_SetValueForKey(char *dest, char *s, int a3)
{
  char *v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  char i; // al
  char result; // al
  char *v10; // eax
  int v11; // edx
  int v12; // eax
  char *v13; // edx
  int v14; // ecx
  int v15; // ecx
  char v16[1024]; // [esp+28h] [ebp-800h] BYREF
  char src[1024]; // [esp+428h] [ebp-400h] BYREF

  v3 = dest;
  v4 = (unsigned __int8)dest & 3;
  if ( ((unsigned __int8)dest & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_8;
    if ( v4 != 2 )
    {
      if ( *dest == BYTE1(v4) )
        goto LABEL_17;
      v3 = dest + 1;
    }
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_8:
      if ( *v3 != BYTE1(v4) )
      {
        ++v3;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)v3;
      if ( !(unsigned __int8)*(_DWORD *)v3 )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      v3 += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        v3 -= 3;
LABEL_15:
        ++v3;
LABEL_16:
        ++v3;
        break;
      }
    }
  }
LABEL_17:
  if ( (unsigned int)(v3 - dest) > 0x3FF )
    Com_Error(1, (char *)&byte_7A160);
  v6 = 0;
  v7 = 0;
  for ( i = *(_BYTE *)a3; i; i = *(_BYTE *)(v7 + a3) )
  {
    if ( i != 92 && i != 59 && i != 34 )
      v16[v6++] = i;
    if ( ++v7 > 1022 )
      break;
  }
  v16[v6] = 0;
  if ( strchr(s, 92) )
    Com_Error(1, (char *)&byte_7A1A0, s, a3);
  if ( strchr(s, 59) )
    Com_Error(1, (char *)&byte_7A1E0, s, a3);
  if ( strchr(s, 34) )
    Com_Error(1, (char *)&byte_7A220, s, a3);
  result = Info_RemoveKey(dest, s);
  if ( v16[0] )
  {
    Com_sprintf(src, 0x400u, "\\%s\\%s", s, v16);
    v10 = src;
    while ( 1 )
    {
      v11 = *(_DWORD *)v10;
      if ( !(unsigned __int8)*(_DWORD *)v10 )
        break;
      if ( !BYTE1(v11) )
        goto LABEL_40;
      if ( (v11 & 0xFF0000) == 0 )
        goto LABEL_39;
      v10 += 4;
      if ( (v11 & 0xFF000000) == 0 )
      {
        v10 -= 3;
LABEL_39:
        ++v10;
LABEL_40:
        ++v10;
        break;
      }
    }
    v12 = v10 - src;
    v13 = dest;
    v14 = (unsigned __int8)dest & 3;
    if ( ((unsigned __int8)dest & 3) == 0 )
      goto LABEL_50;
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_48;
    if ( v14 != 2 )
    {
      if ( *dest == BYTE1(v14) )
        goto LABEL_57;
      v13 = dest + 1;
    }
    if ( *v13 != BYTE1(v14) )
    {
      ++v13;
LABEL_48:
      if ( *v13 != BYTE1(v14) )
      {
        ++v13;
LABEL_50:
        while ( 1 )
        {
          v15 = *(_DWORD *)v13;
          if ( !(unsigned __int8)*(_DWORD *)v13 )
            break;
          if ( !BYTE1(v15) )
            goto LABEL_56;
          if ( (v15 & 0xFF0000) == 0 )
            goto LABEL_55;
          v13 += 4;
          if ( (v15 & 0xFF000000) == 0 )
          {
            v13 -= 3;
LABEL_55:
            ++v13;
LABEL_56:
            ++v13;
            break;
          }
        }
      }
    }
LABEL_57:
    if ( (unsigned int)(v13 - dest + v12) > 0x400 )
      Com_Error(1, (char *)&byte_7A260, s, a3, dest);
    result = (unsigned __int8)strcat(dest, src);
  }
  return result;
}

//----- (0006ABE8) --------------------------------------------------------
char __cdecl Info_SetValueForKey_Big(char *dest, char *s, int a3)
{
  char *v3; // eax
  int v4; // edx
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  char i; // al
  char result; // al
  char *v10; // eax
  int v11; // edx
  int v12; // eax
  char *v13; // edx
  int v14; // ecx
  int v15; // ecx
  char v16[8192]; // [esp+28h] [ebp-4000h] BYREF
  char src[8192]; // [esp+2028h] [ebp-2000h] BYREF

  v3 = dest;
  v4 = (unsigned __int8)dest & 3;
  if ( ((unsigned __int8)dest & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_8;
    if ( v4 != 2 )
    {
      if ( *dest == BYTE1(v4) )
        goto LABEL_17;
      v3 = dest + 1;
    }
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_8:
      if ( *v3 != BYTE1(v4) )
      {
        ++v3;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)v3;
      if ( !(unsigned __int8)*(_DWORD *)v3 )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      v3 += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        v3 -= 3;
LABEL_15:
        ++v3;
LABEL_16:
        ++v3;
        break;
      }
    }
  }
LABEL_17:
  if ( (unsigned int)(v3 - dest) > 0x1FFF )
    Com_Error(1, (char *)&byte_7A160);
  v6 = 0;
  v7 = 0;
  for ( i = *(_BYTE *)a3; i; i = *(_BYTE *)(v7 + a3) )
  {
    if ( i != 92 && i != 59 && i != 34 )
      v16[v6++] = i;
    if ( ++v7 > 8190 )
      break;
  }
  v16[v6] = 0;
  if ( strchr(s, 92) )
    Com_Error(1, (char *)&byte_7A1A0, s, a3);
  if ( strchr(s, 59) )
    Com_Error(1, (char *)&byte_7A1E0, s, a3);
  if ( strchr(s, 34) )
    Com_Error(1, (char *)&byte_7A220, s, a3);
  result = Info_RemoveKey_Big(dest, s);
  if ( v16[0] )
  {
    Com_sprintf(src, 0x2000u, "\\%s\\%s", s, v16);
    v10 = src;
    while ( 1 )
    {
      v11 = *(_DWORD *)v10;
      if ( !(unsigned __int8)*(_DWORD *)v10 )
        break;
      if ( !BYTE1(v11) )
        goto LABEL_40;
      if ( (v11 & 0xFF0000) == 0 )
        goto LABEL_39;
      v10 += 4;
      if ( (v11 & 0xFF000000) == 0 )
      {
        v10 -= 3;
LABEL_39:
        ++v10;
LABEL_40:
        ++v10;
        break;
      }
    }
    v12 = v10 - src;
    v13 = dest;
    v14 = (unsigned __int8)dest & 3;
    if ( ((unsigned __int8)dest & 3) == 0 )
      goto LABEL_50;
    if ( __SETP__((unsigned __int8)dest & 3, 0) )
      goto LABEL_48;
    if ( v14 != 2 )
    {
      if ( *dest == BYTE1(v14) )
        goto LABEL_57;
      v13 = dest + 1;
    }
    if ( *v13 != BYTE1(v14) )
    {
      ++v13;
LABEL_48:
      if ( *v13 != BYTE1(v14) )
      {
        ++v13;
LABEL_50:
        while ( 1 )
        {
          v15 = *(_DWORD *)v13;
          if ( !(unsigned __int8)*(_DWORD *)v13 )
            break;
          if ( !BYTE1(v15) )
            goto LABEL_56;
          if ( (v15 & 0xFF0000) == 0 )
            goto LABEL_55;
          v13 += 4;
          if ( (v15 & 0xFF000000) == 0 )
          {
            v13 -= 3;
LABEL_55:
            ++v13;
LABEL_56:
            ++v13;
            break;
          }
        }
      }
    }
LABEL_57:
    if ( (unsigned int)(v13 - dest + v12) > 0x2000 )
      Com_Error(1, (char *)&byte_7A2C0, s, a3, dest);
    result = (unsigned __int8)strcat(dest, src);
  }
  return result;
}

//----- (0006ADF8) --------------------------------------------------------
int __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, _BYTE *a4, int a5, int (__cdecl *a6)(int, char *, _DWORD), void (__cdecl *a7)(int, char *))
{
  char *v8; // eax
  int v9; // edx
  char *v10; // ebx
  char *v11; // ebx
  char *v12; // ebx
  int result; // eax
  int i; // [esp+18h] [ebp-10h]
  float v15; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a3; a2 += 12 )
  {
    v8 = Info_ValueForKey(a4, *(char **)a2);
    if ( *v8 )
    {
      v9 = *(_DWORD *)(a2 + 8);
      if ( *v8 > 0 )
      {
        if ( a5 <= 0 || v9 >= a5 )
        {
          Com_Error(1, (char *)&byte_7A308, *(_DWORD *)(a2 + 8));
        }
        else if ( !a6(a1, v8, *(_DWORD *)(a2 + 8)) )
        {
          goto LABEL_21;
        }
      }
      else
      {
        switch ( v9 )
        {
          case 0:
            a7(*(_DWORD *)(a2 + 4) + a1, v8);
            break;
          case 1:
            v10 = (char *)(*(_DWORD *)(a2 + 4) + a1);
            strncpy(v10, v8, 0x3FFu);
            v10[1023] = 0;
            break;
          case 2:
            v11 = (char *)(*(_DWORD *)(a2 + 4) + a1);
            strncpy(v11, v8, 0x3Fu);
            v11[63] = 0;
            break;
          case 3:
            v12 = (char *)(*(_DWORD *)(a2 + 4) + a1);
            strncpy(v12, v8, 0xFFu);
            v12[255] = 0;
            break;
          case 4:
            *(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) = _strtol_internal(v8, 0, 10, 0);
            break;
          case 5:
            *(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) = _strtol_internal(v8, 0, 10, 0) != 0;
            break;
          case 6:
            *(float *)(*(_DWORD *)(a2 + 4) + a1) = _strtod_internal(v8, 0, 0);
            break;
          case 7:
            v15 = _strtod_internal(v8, 0, 0);
            *(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) = (int)(v15 * 1000.0);
            break;
          default:
            break;
        }
      }
    }
    ++i;
  }
  if ( i == a3 )
    result = 1;
  else
LABEL_21:
    result = 0;
  return result;
}

//----- (0006AFD0) --------------------------------------------------------
long double __cdecl Com_Clamp(float a1, float a2, float a3)
{
  long double result; // fst7
  long double v4; // fst6
  char v5; // fps^1
  long double v6; // fst5
  bool v7; // c0
  char v8; // c2
  bool v9; // c3
  char v10; // fps^1
  bool v11; // c0
  char v12; // c2
  bool v13; // c3

  result = a1;
  v4 = a2;
  v6 = a3;
  v7 = a3 < (long double)a1;
  v8 = 0;
  v9 = a3 == a1;
  if ( (v5 & 0x45) != 1 )
  {
    result = a3;
    v11 = v4 < v6;
    v12 = 0;
    v13 = v4 == v6;
    if ( (v10 & 0x45) == 1 )
      result = a2;
  }
  return result;
}
// 6AFE0: variable 'v5' is possibly undefined
// 6AFEE: variable 'v10' is possibly undefined

//----- (0006B004) --------------------------------------------------------
_BYTE *__cdecl Com_SkipPath(_BYTE *a1)
{
  _BYTE *v1; // ecx
  _BYTE *v2; // edx
  _BYTE *v3; // eax

  v1 = a1;
  v2 = a1;
  if ( *a1 )
  {
    do
    {
      v3 = v2 + 1;
      if ( *v2 == 47 )
        v1 = v2 + 1;
      ++v2;
    }
    while ( *v3 );
  }
  return v1;
}

//----- (0006B028) --------------------------------------------------------
char __cdecl Com_StripExtension(char *a1, _BYTE *a2)
{
  char result; // al

  while ( 1 )
  {
    result = *a1;
    if ( !*a1 || result == 46 )
      break;
    *a2++ = *a1++;
  }
  *a2 = 0;
  return result;
}

//----- (0006B04C) --------------------------------------------------------
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen, int a3)
{
  char *result; // eax
  int v4; // edx
  int v5; // edx
  char *v6; // edx
  char dest[64]; // [esp+18h] [ebp-40h] BYREF

  result = s;
  v4 = (unsigned __int8)s & 3;
  if ( ((unsigned __int8)s & 3) != 0 )
  {
    if ( !__SETP__((unsigned __int8)s & 3, 0) )
    {
      if ( v4 != 2 )
      {
        if ( *s == BYTE1(v4) )
          goto LABEL_17;
        result = s + 1;
      }
      if ( *result == BYTE1(v4) )
        goto LABEL_17;
      ++result;
    }
    if ( *result != BYTE1(v4) )
    {
      ++result;
      goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)result;
      if ( !(unsigned __int8)*(_DWORD *)result )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      result += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        result -= 3;
LABEL_15:
        ++result;
LABEL_16:
        ++result;
        break;
      }
    }
  }
LABEL_17:
  v6 = result - 1;
  if ( *(result - 1) == 47 || v6 == s )
  {
LABEL_22:
    Q_strncpyz(dest, s, 64);
    result = (char *)Com_sprintf(s, maxlen, "%s%s", dest, (const char *)a3);
  }
  else
  {
    while ( *v6 != 46 )
    {
      if ( *--v6 == 47 || v6 == s )
        goto LABEL_22;
    }
  }
  return result;
}

//----- (0006B0E4) --------------------------------------------------------
char *__cdecl Com_StripFilename(char *src, char *dest)
{
  char *v2; // eax
  int v3; // ecx
  int v4; // ecx
  char *result; // eax
  char *v6; // edx
  char *v7; // ecx

  v2 = src;
  v3 = (unsigned __int8)src & 3;
  if ( ((unsigned __int8)src & 3) != 0 )
  {
    if ( __SETP__((unsigned __int8)src & 3, 0) )
      goto LABEL_8;
    if ( v3 != 2 )
    {
      if ( *src == BYTE1(v3) )
        goto LABEL_17;
      v2 = src + 1;
    }
    if ( *v2 != BYTE1(v3) )
    {
      ++v2;
LABEL_8:
      if ( *v2 != BYTE1(v3) )
      {
        ++v2;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v4 = *(_DWORD *)v2;
      if ( !(unsigned __int8)*(_DWORD *)v2 )
        break;
      if ( !BYTE1(v4) )
        goto LABEL_16;
      if ( (v4 & 0xFF0000) == 0 )
        goto LABEL_15;
      v2 += 4;
      if ( (v4 & 0xFF000000) == 0 )
      {
        v2 -= 3;
LABEL_15:
        ++v2;
LABEL_16:
        ++v2;
        break;
      }
    }
  }
LABEL_17:
  result = Q_strncpyz(dest, src, v2 - src);
  v6 = dest;
  v7 = dest;
  if ( *dest )
  {
    do
    {
      result = v6 + 1;
      if ( *v6 == 47 )
        v7 = v6 + 1;
      ++v6;
    }
    while ( *result );
  }
  *v7 = 0;
  return result;
}

//----- (0006B164) --------------------------------------------------------
int __cdecl Com_BitCheck(int a1, int a2)
{
  return (*(int *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (0006B188) --------------------------------------------------------
int __cdecl Com_BitSet(int a1, int a2)
{
  int result; // eax

  result = 1 << (a2 & 0x1F);
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) |= result;
  return result;
}

//----- (0006B1AC) --------------------------------------------------------
int __cdecl Com_BitClear(int a1, int a2)
{
  int result; // eax

  result = __ROL4__(-2, a2 & 0x1F);
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) &= result;
  return result;
}

//----- (0006B1D0) --------------------------------------------------------
_BOOL4 __cdecl Q_isprint(int a1)
{
  return (unsigned int)(a1 - 32) <= 0x5E;
}

//----- (0006B1EC) --------------------------------------------------------
_BOOL4 __cdecl Q_islower(int a1)
{
  return (unsigned int)(a1 - 97) <= 0x19;
}

//----- (0006B20C) --------------------------------------------------------
_BOOL4 __cdecl Q_isupper(int a1)
{
  return (unsigned int)(a1 - 65) <= 0x19;
}

//----- (0006B22C) --------------------------------------------------------
_BOOL4 __cdecl Q_isalpha(int a1)
{
  return (unsigned int)(a1 - 97) <= 0x19 || (unsigned int)(a1 - 65) <= 0x19;
}

//----- (0006B258) --------------------------------------------------------
_BOOL4 __cdecl Q_isnumeric(int a1)
{
  return (unsigned int)(a1 - 48) <= 9;
}

//----- (0006B27C) --------------------------------------------------------
_BOOL4 __cdecl Q_isalphanumeric(int a1)
{
  return (unsigned int)(a1 - 97) <= 0x19 || (unsigned int)(a1 - 65) <= 0x19 || (unsigned int)(a1 - 48) <= 9;
}

//----- (0006B2A8) --------------------------------------------------------
_BOOL4 __cdecl Q_isforfilename(int a1)
{
  return ((unsigned int)(a1 - 97) <= 0x19
       || (unsigned int)(a1 - 65) <= 0x19
       || (unsigned int)(a1 - 48) <= 9
       || a1 == 95
       || a1 == 45)
      && a1 != 32;
}

//----- (0006B2E8) --------------------------------------------------------
int __cdecl Q_stricmp(char *a1, char *a2)
{
  char *v2; // esi
  char *v3; // ebx
  int v4; // edi
  int v5; // edx
  int v6; // ecx
  int result; // eax

  if ( a1 && a2 )
  {
    v2 = a1;
    v3 = a2;
    v4 = 99999;
    while ( 1 )
    {
      v5 = *v2++;
      v6 = *v3++;
      if ( v4-- == 0 )
        return 0;
      if ( v5 != v6 )
      {
        if ( (unsigned int)(v5 - 97) <= 0x19 )
          v5 -= 32;
        if ( (unsigned int)(v6 - 97) <= 0x19 )
          v6 -= 32;
        if ( v5 != v6 )
          break;
      }
      if ( !v5 )
        return 0;
    }
    result = 1;
    if ( v5 >= v6 )
      return result;
  }
  return -1;
}

//----- (0006B35C) --------------------------------------------------------
int __cdecl Q_strncmp(char *a1, char *a2, int a3)
{
  int v6; // edx
  int v7; // ecx
  int result; // eax

  while ( 1 )
  {
    v6 = *a1++;
    v7 = *a2++;
    if ( a3-- == 0 )
      return 0;
    if ( v6 != v7 )
      break;
    if ( !v6 )
      return 0;
  }
  result = 1;
  if ( v6 < v7 )
    result = -1;
  return result;
}

//----- (0006B3A0) --------------------------------------------------------
int __cdecl Q_stricmpn(char *a1, char *a2, int a3)
{
  int v6; // edx
  int v7; // ecx
  int result; // eax

  while ( 1 )
  {
    v6 = *a1++;
    v7 = *a2++;
    if ( a3-- == 0 )
      return 0;
    if ( v6 != v7 )
    {
      if ( (unsigned int)(v6 - 97) <= 0x19 )
        v6 -= 32;
      if ( (unsigned int)(v7 - 97) <= 0x19 )
        v7 -= 32;
      if ( v6 != v7 )
        break;
    }
    if ( !v6 )
      return 0;
  }
  result = 1;
  if ( v6 < v7 )
    result = -1;
  return result;
}

//----- (0006B400) --------------------------------------------------------
_BYTE *__cdecl Q_strlwr(_BYTE *a1)
{
  _BYTE *i; // ecx

  for ( i = a1; *i; ++i )
    *i = *(_DWORD *)(_ctype_tolower + 4 * (char)*i);
  return a1;
}
// 2ECD44: using guessed type int _ctype_tolower;

//----- (0006B42C) --------------------------------------------------------
_BYTE *__cdecl Q_strupr(_BYTE *a1)
{
  _BYTE *i; // ecx

  for ( i = a1; *i; ++i )
    *i = *(_DWORD *)(_ctype_toupper + 4 * (char)*i);
  return a1;
}
// 2ECDA0: using guessed type int _ctype_toupper;

//----- (0006B45C) --------------------------------------------------------
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2)
{
  _BYTE *v2; // eax
  _BYTE *i; // ecx

  v2 = a1;
  for ( i = 0; *v2; ++v2 )
  {
    if ( *v2 == a2 )
      i = v2;
  }
  if ( !a2 )
    i = v2;
  return i;
}

//----- (0006B488) --------------------------------------------------------
char *__cdecl Q_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  result = strncpy(dest, src, a3 - 1);
  dest[a3 - 1] = 0;
  return result;
}

//----- (0006B4B8) --------------------------------------------------------
char *__cdecl Q_strcat(int a1, int a2, char *src)
{
  _BYTE *v3; // ebx
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // esi
  char *v8; // ebx
  char *result; // eax

  v3 = (_BYTE *)a1;
  v4 = a1 & 3;
  if ( (a1 & 3) != 0 )
  {
    if ( __SETP__(a1 & 3, 0) )
      goto LABEL_8;
    if ( v4 != 2 )
    {
      if ( *(_BYTE *)a1 == BYTE1(v4) )
        goto LABEL_17;
      v3 = (_BYTE *)(a1 + 1);
    }
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_8:
      if ( *v3 != BYTE1(v4) )
      {
        ++v3;
        goto LABEL_10;
      }
      goto LABEL_17;
    }
  }
  else
  {
LABEL_10:
    while ( 1 )
    {
      v5 = *(_DWORD *)v3;
      if ( !(unsigned __int8)*(_DWORD *)v3 )
        break;
      if ( !BYTE1(v5) )
        goto LABEL_16;
      if ( (v5 & 0xFF0000) == 0 )
        goto LABEL_15;
      v3 += 4;
      if ( (v5 & 0xFF000000) == 0 )
      {
        v3 -= 3;
LABEL_15:
        ++v3;
LABEL_16:
        ++v3;
        break;
      }
    }
  }
LABEL_17:
  v6 = (int)&v3[-a1];
  if ( v6 >= a2 )
    Com_Error(0, (char *)&byte_7A025);
  v7 = a2 - v6;
  v8 = (char *)(a1 + v6);
  result = strncpy(v8, src, v7 - 1);
  v8[v7 - 1] = 0;
  return result;
}

//----- (0006B544) --------------------------------------------------------
char *__cdecl Q_CleanStr(char *a1)
{
  char *v1; // edx
  char *v2; // ebx
  char i; // cl
  char v4; // al

  v1 = a1;
  v2 = a1;
  for ( i = *a1; *v1; i = *v1 )
  {
    if ( v1 && *v1 == 94 && (v4 = v1[1]) != 0 && v4 != 94 && v4 > 47 && v4 <= 55 )
    {
      ++v1;
    }
    else if ( (unsigned __int8)(i - 32) <= 0x5Eu )
    {
      *v2++ = i;
    }
    ++v1;
  }
  *v2 = 0;
  return a1;
}

//----- (0006B594) --------------------------------------------------------
int __cdecl Q_CleanCharacter(char a1)
{
  if ( a1 == -110 )
    return 39;
  if ( a1 < 0 )
    return 46;
  return a1;
}

//----- (0006B5BC) --------------------------------------------------------
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3)
{
  int v6; // ecx
  int v7; // edx

  do
  {
    v6 = *a1++;
    v7 = *a2++;
    if ( a3-- == 0 )
      break;
    if ( v6 != v7 )
    {
      if ( (unsigned int)(v6 - 97) <= 0x19 )
        v6 -= 32;
      if ( (unsigned int)(v7 - 97) <= 0x19 )
        v7 -= 32;
      if ( v6 != v7 )
        return -1;
    }
  }
  while ( v6 );
  return 0;
}

//----- (0006B610) --------------------------------------------------------
int __cdecl Q_strcasecmp(char *a1, char *a2)
{
  int v4; // edi
  int v5; // ecx
  int v6; // edx

  v4 = 99999;
  do
  {
    v5 = *a1++;
    v6 = *a2++;
    if ( v4-- == 0 )
      break;
    if ( v5 != v6 )
    {
      if ( (unsigned int)(v5 - 97) <= 0x19 )
        v5 -= 32;
      if ( (unsigned int)(v6 - 97) <= 0x19 )
        v6 -= 32;
      if ( v5 != v6 )
        return -1;
    }
  }
  while ( v5 );
  return 0;
}

//----- (0006B660) --------------------------------------------------------
int __cdecl BigShort(__int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (__int16)dword_C0FA0(a1, v2, v3, v4);
}
// 6B673: variable 'v2' is possibly undefined
// 6B673: variable 'v3' is possibly undefined
// 6B673: variable 'v4' is possibly undefined
// C0FA0: using guessed type int (__stdcall *dword_C0FA0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006B67C) --------------------------------------------------------
int __cdecl BigLong(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FA8(a1, v2, v3, v4);
}
// 6B68E: variable 'v2' is possibly undefined
// 6B68E: variable 'v3' is possibly undefined
// 6B68E: variable 'v4' is possibly undefined
// C0FA8: using guessed type int (__stdcall *dword_C0FA8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006B694) --------------------------------------------------------
_DWORD *__userpurge BigLong64@<eax>(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v5; // [esp-4h] [ebp-1Ch]
  int v6[2]; // [esp+10h] [ebp-8h] BYREF

  dword_C0FB0(v6, a2, a3, v5);
  v3 = v6[1];
  *a1 = v6[0];
  a1[1] = v3;
  return a1;
}
// 6B6B2: variable 'v5' is possibly undefined
// C0FB0: using guessed type int (__stdcall *dword_C0FB0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006B6CC) --------------------------------------------------------
_DWORD *__userpurge LittleLong64@<eax>(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v5; // [esp-4h] [ebp-1Ch]
  int v6[2]; // [esp+10h] [ebp-8h] BYREF

  dword_C0FB4(v6, a2, a3, v5);
  v3 = v6[1];
  *a1 = v6[0];
  a1[1] = v3;
  return a1;
}
// 6B6EA: variable 'v5' is possibly undefined
// C0FB4: using guessed type int (__stdcall *dword_C0FB4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006B704) --------------------------------------------------------
int __cdecl BigFloat(float a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FB8(LODWORD(a1), v2, v3, v4);
}
// 6B71B: variable 'v2' is possibly undefined
// 6B71B: variable 'v3' is possibly undefined
// 6B71B: variable 'v4' is possibly undefined
// C0FB8: using guessed type int (__stdcall *dword_C0FB8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006B724) --------------------------------------------------------
int Swap_Init()
{
  int result; // eax

  result = 1;
  dword_C0FA0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))ShortSwap;
  dword_C0FA4 = (int)ShortNoSwap;
  dword_C0FA8 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))LongSwap;
  dword_C0FAC = (int)LongNoSwap;
  dword_C0FB0 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))Long64Swap;
  dword_C0FB4 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))Long64NoSwap;
  dword_C0FB8 = (int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))FloatSwap;
  dword_C0FBC = (int)FloatNoSwap;
  return result;
}
// C0FA0: using guessed type int (__stdcall *dword_C0FA0)(_DWORD, _DWORD, _DWORD, _DWORD);
// C0FA4: using guessed type int dword_C0FA4;
// C0FA8: using guessed type int (__stdcall *dword_C0FA8)(_DWORD, _DWORD, _DWORD, _DWORD);
// C0FAC: using guessed type int dword_C0FAC;
// C0FB0: using guessed type int (__stdcall *dword_C0FB0)(_DWORD, _DWORD, _DWORD, _DWORD);
// C0FB4: using guessed type int (__stdcall *dword_C0FB4)(_DWORD, _DWORD, _DWORD, _DWORD);
// C0FB8: using guessed type int (__stdcall *dword_C0FB8)(_DWORD, _DWORD, _DWORD, _DWORD);
// C0FBC: using guessed type int dword_C0FBC;

//----- (0006B7D8) --------------------------------------------------------
float *__cdecl tv(float a1, float a2, float a3)
{
  char v3; // al
  int v4; // edx

  v3 = dword_AD520;
  v4 = 3 * dword_AD520;
  flt_AD540[v4] = a1;
  flt_AD544[v4] = a2;
  flt_AD548[v4] = a3;
  dword_AD520 = (v3 + 1) & 7;
  return &flt_AD540[v4];
}
// AD520: using guessed type int dword_AD520;
// AD540: using guessed type float flt_AD540[];
// AD544: using guessed type float flt_AD544[];
// AD548: using guessed type float flt_AD548[];

//----- (0006B818) --------------------------------------------------------
_BOOL4 __cdecl Info_Validate(char *s)
{
  return !strchr(s, 34) && !strchr(s, 59);
}

//----- (0006B85C) --------------------------------------------------------
char __cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *v3; // edx
  _BYTE *i; // ecx
  char result; // al

  v3 = *a1;
  if ( **a1 == 92 )
    ++v3;
  *a2 = 0;
  *a3 = 0;
  i = a2;
  if ( *v3 == 92 )
  {
LABEL_6:
    *i = 0;
    ++v3;
    for ( i = a3; ; ++i )
    {
      result = *v3;
      if ( *v3 == 92 || !result )
        break;
      *i = *v3++;
    }
  }
  else
  {
    while ( 1 )
    {
      result = *v3;
      if ( !*v3 )
        break;
      *i = result;
      ++v3;
      ++i;
      if ( *v3 == 92 )
        goto LABEL_6;
    }
  }
  *i = 0;
  *a1 = v3;
  return result;
}

//----- (0006B8B4) --------------------------------------------------------
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a1;
  *a3 = a2[1] * a1[6] + *a2 * a1[3] + *a1 + a2[2] * a1[9];
  a3[1] = a2[1] * a1[7] + *a2 * a1[4] + a1[1] + a2[2] * a1[10];
  a3[2] = a2[1] * a1[8] + *a2 * a1[5] + a1[2] + a2[2] * a1[11];
  return result;
}

//----- (0006B91C) --------------------------------------------------------
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a2 * a1[3] + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a2[1] * a1[7] + a2[2] * a1[10];
  a3[2] = *a2 * a1[5] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (0006B980) --------------------------------------------------------
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax
  long double v4; // fst7
  long double v5; // fst6
  long double v6; // fst3

  result = a2;
  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  *a3 = v4 * a1[3] + v5 * a1[4] + v6 * a1[5];
  a3[1] = v5 * a1[7] + v4 * a1[6] + v6 * a1[8];
  a3[2] = v5 * a1[10] + v4 * a1[9] + v6 * a1[11];
  return result;
}

//----- (0006BA00) --------------------------------------------------------
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = *a2 * a1[3] + a2[1] * a1[4] + a2[2] * a1[5];
  a3[1] = *a2 * a1[6] + a2[1] * a1[7] + a2[2] * a1[8];
  a3[2] = *a2 * a1[9] + a2[1] * a1[10] + a2[2] * a1[11];
  return result;
}

//----- (0006BA64) --------------------------------------------------------
long double __cdecl GetLeanFraction(float a1)
{
  return a1 * (2.0 - fabs(a1));
}

//----- (0006BA80) --------------------------------------------------------
long double __cdecl UnGetLeanFraction(float a1)
{
  float v2; // [esp+14h] [ebp-4h]

  v2 = sqrt(1.0 - a1);
  return 1.0 - v2;
}

//----- (0006BA9C) --------------------------------------------------------
unsigned __int16 __cdecl AddLeanToPosition(int a1, float a2, float a3, float a4, float a5)
{
  __int16 v5; // fps
  bool v6; // c0
  char v7; // c2
  bool v8; // c3
  unsigned __int16 result; // ax
  long double v10; // fst7
  long double v11; // fst7
  float v12[3]; // [esp+40h] [ebp-18h] BYREF
  float v13[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v6 = a3 < 0.0;
  v7 = 0;
  v8 = a3 == 0.0;
  LOBYTE(result) = v5;
  HIBYTE(result) = HIBYTE(v5) & 0x45;
  if ( (HIBYTE(v5) & 0x45) != 64 )
  {
    v10 = a3 * (2.0 - fabs(a3));
    v12[0] = 0.0;
    v12[1] = a2;
    v12[2] = v10 * a4;
    result = (unsigned __int16)AngleVectors(v12, 0, v13, 0);
    v11 = v10 * a5;
    *(float *)a1 = v13[0] * v11 + *(float *)a1;
    *(float *)(a1 + 4) = v13[1] * v11 + *(float *)(a1 + 4);
    *(float *)(a1 + 8) = v11 * v13[2] + *(float *)(a1 + 8);
  }
  return result;
}

//----- (0006BB1C) --------------------------------------------------------
int __cdecl ShortSwap(__int16 a1)
{
  return (__int16)(HIBYTE(a1) + (a1 << 8));
}

//----- (0006BB38) --------------------------------------------------------
int __cdecl ShortNoSwap(__int16 a1)
{
  return a1;
}

//----- (0006BB44) --------------------------------------------------------
int __cdecl LongSwap(unsigned int a1)
{
  return HIBYTE(a1) + ((a1 >> 8) & 0xFF00) + ((a1 << 8) & 0xFF0000) + (a1 << 24);
}

//----- (0006BB74) --------------------------------------------------------
int __cdecl LongNoSwap(int a1)
{
  return a1;
}

//----- (0006BB80) --------------------------------------------------------
unsigned int *__userpurge Long64Swap@<eax>(int a1@<edi>, int a2@<esi>, unsigned int *a3, unsigned int a4, unsigned int a5)
{
  int v6; // ebx
  unsigned int v7; // esi
  int v9; // ebx
  unsigned int *result; // eax

  LOBYTE(a2) = HIBYTE(a5);
  v6 = a2;
  BYTE1(v6) = 0;
  v7 = (a5 << 24) | ((a5 << 8) & 0xFF0000 | ((a5 >> 8) & 0xFF00 | v6) & 0xFF00FFFF) & 0xFFFFFF;
  LOBYTE(a1) = HIBYTE(a4);
  v9 = a1;
  BYTE1(v9) = 0;
  result = a3;
  *a3 = v7;
  a3[1] = (a4 << 24) | ((a4 << 8) & 0xFF0000 | ((a4 >> 8) & 0xFF00 | v9) & 0xFF00FFFF) & 0xFFFFFF;
  return result;
}

//----- (0006BC2C) --------------------------------------------------------
_DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3)
{
  *a1 = a2;
  a1[1] = a3;
  return a1;
}

//----- (0006BC48) --------------------------------------------------------
long double __usercall FloatSwap@<st0>(int a1@<ebx>, unsigned int a2)
{
  LOWORD(a1) = HIBYTE(a2);
  return COERCE_FLOAT((a2 << 24) | ((a2 << 8) & 0xFF0000 | ((a2 >> 8) & 0xFF00 | a1) & 0xFF00FFFF) & 0xFFFFFF);
}

//----- (0006BC90) --------------------------------------------------------
long double __cdecl FloatNoSwap(float a1)
{
  return a1;
}

//----- (0006BC9C) --------------------------------------------------------
int __cdecl Scr_GetBool(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FC0(a1, v2, v3, v4);
}
// 6BCAE: variable 'v2' is possibly undefined
// 6BCAE: variable 'v3' is possibly undefined
// 6BCAE: variable 'v4' is possibly undefined
// C0FC0: using guessed type int (__stdcall *dword_C0FC0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BCB4) --------------------------------------------------------
int __cdecl Scr_GetInt(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FC4(a1, v2, v3, v4);
}
// 6BCC6: variable 'v2' is possibly undefined
// 6BCC6: variable 'v3' is possibly undefined
// 6BCC6: variable 'v4' is possibly undefined
// C0FC4: using guessed type int (__stdcall *dword_C0FC4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BCCC) --------------------------------------------------------
_DWORD *__userpurge Scr_GetAnim@<eax>(_DWORD *a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-1Ch]
  int v5; // [esp+14h] [ebp-4h] BYREF

  dword_C0FC8(&v5, a2, a3, v4);
  *a1 = v5;
  return a1;
}
// 6BCEA: variable 'v4' is possibly undefined
// C0FC8: using guessed type int (__stdcall *dword_C0FC8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BCFC) --------------------------------------------------------
_DWORD *__userpurge Scr_GetAnimTree@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp-8h] [ebp-20h]
  int v4; // [esp-4h] [ebp-1Ch]
  int v5; // [esp+14h] [ebp-4h] BYREF

  dword_C0FCC(&v5, a2, v3, v4);
  *a1 = v5;
  return a1;
}
// 6BD16: variable 'v3' is possibly undefined
// 6BD16: variable 'v4' is possibly undefined
// C0FCC: using guessed type int (__stdcall *dword_C0FCC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BD28) --------------------------------------------------------
int __cdecl Scr_GetFloat(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FD0(a1, v2, v3, v4);
}
// 6BD3A: variable 'v2' is possibly undefined
// 6BD3A: variable 'v3' is possibly undefined
// 6BD3A: variable 'v4' is possibly undefined
// C0FD0: using guessed type int (__stdcall *dword_C0FD0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BD40) --------------------------------------------------------
int __cdecl Scr_GetString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FD4(a1, v2, v3, v4);
}
// 6BD52: variable 'v2' is possibly undefined
// 6BD52: variable 'v3' is possibly undefined
// 6BD52: variable 'v4' is possibly undefined
// C0FD4: using guessed type int (__stdcall *dword_C0FD4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BD58) --------------------------------------------------------
int __cdecl Scr_GetConstString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C0FD8(a1, v2, v3, v4);
}
// 6BD6A: variable 'v2' is possibly undefined
// 6BD6A: variable 'v3' is possibly undefined
// 6BD6A: variable 'v4' is possibly undefined
// C0FD8: using guessed type int (__stdcall *dword_C0FD8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BD74) --------------------------------------------------------
int __cdecl Scr_GetDebugString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FDC(a1, v2, v3, v4);
}
// 6BD86: variable 'v2' is possibly undefined
// 6BD86: variable 'v3' is possibly undefined
// 6BD86: variable 'v4' is possibly undefined
// C0FDC: using guessed type int (__stdcall *dword_C0FDC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BD8C) --------------------------------------------------------
int __cdecl Scr_GetIString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FE0(a1, v2, v3, v4);
}
// 6BD9E: variable 'v2' is possibly undefined
// 6BD9E: variable 'v3' is possibly undefined
// 6BD9E: variable 'v4' is possibly undefined
// C0FE0: using guessed type int (__stdcall *dword_C0FE0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BDA4) --------------------------------------------------------
int __cdecl Scr_GetConstIString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C0FE4(a1, v2, v3, v4);
}
// 6BDB6: variable 'v2' is possibly undefined
// 6BDB6: variable 'v3' is possibly undefined
// 6BDB6: variable 'v4' is possibly undefined
// C0FE4: using guessed type int (__stdcall *dword_C0FE4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BDC0) --------------------------------------------------------
int __cdecl Scr_GetVector(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FE8(a1, a2, v3, v4);
}
// 6BDD6: variable 'v3' is possibly undefined
// 6BDD6: variable 'v4' is possibly undefined
// C0FE8: using guessed type int (__stdcall *dword_C0FE8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BDDC) --------------------------------------------------------
int __cdecl Scr_GetFunc(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FEC(a1, v2, v3, v4);
}
// 6BDEE: variable 'v2' is possibly undefined
// 6BDEE: variable 'v3' is possibly undefined
// 6BDEE: variable 'v4' is possibly undefined
// C0FEC: using guessed type int (__stdcall *dword_C0FEC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BDF4) --------------------------------------------------------
int __cdecl Scr_GetEntityNum(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FF8(a1, a2, v3, v4);
}
// 6BE0A: variable 'v3' is possibly undefined
// 6BE0A: variable 'v4' is possibly undefined
// C0FF8: using guessed type int (__stdcall *dword_C0FF8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BE10) --------------------------------------------------------
int __cdecl Scr_GetType(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FF0(a1, v2, v3, v4);
}
// 6BE22: variable 'v2' is possibly undefined
// 6BE22: variable 'v3' is possibly undefined
// 6BE22: variable 'v4' is possibly undefined
// C0FF0: using guessed type int (__stdcall *dword_C0FF0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BE28) --------------------------------------------------------
int __cdecl Scr_GetPointerType(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C0FF4(a1, v2, v3, v4);
}
// 6BE3A: variable 'v2' is possibly undefined
// 6BE3A: variable 'v3' is possibly undefined
// 6BE3A: variable 'v4' is possibly undefined
// C0FF4: using guessed type int (__stdcall *dword_C0FF4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BE40) --------------------------------------------------------
int Scr_GetNumParam()
{
  return dword_C0FFC();
}
// C0FFC: using guessed type int (*dword_C0FFC)(void);

//----- (0006BE54) --------------------------------------------------------
int __cdecl Scr_AddBool(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1000(a1, v2, v3, v4);
}
// 6BE66: variable 'v2' is possibly undefined
// 6BE66: variable 'v3' is possibly undefined
// 6BE66: variable 'v4' is possibly undefined
// C1000: using guessed type int (__stdcall *dword_C1000)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BE6C) --------------------------------------------------------
int __cdecl Scr_AddInt(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1004(a1, v2, v3, v4);
}
// 6BE7E: variable 'v2' is possibly undefined
// 6BE7E: variable 'v3' is possibly undefined
// 6BE7E: variable 'v4' is possibly undefined
// C1004: using guessed type int (__stdcall *dword_C1004)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BE84) --------------------------------------------------------
int __cdecl Scr_AddFloat(float a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1008(LODWORD(a1), v2, v3, v4);
}
// 6BE9B: variable 'v2' is possibly undefined
// 6BE9B: variable 'v3' is possibly undefined
// 6BE9B: variable 'v4' is possibly undefined
// C1008: using guessed type int (__stdcall *dword_C1008)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BEA4) --------------------------------------------------------
int __cdecl Scr_AddAnim(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C100C(a1, v2, v3, v4);
}
// 6BEB6: variable 'v2' is possibly undefined
// 6BEB6: variable 'v3' is possibly undefined
// 6BEB6: variable 'v4' is possibly undefined
// C100C: using guessed type int (__stdcall *dword_C100C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BEBC) --------------------------------------------------------
int Scr_AddUndefined()
{
  return dword_C1010();
}
// C1010: using guessed type int (*dword_C1010)(void);

//----- (0006BED0) --------------------------------------------------------
int __cdecl Scr_AddEntityNum(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1014(a1, a2, v3, v4);
}
// 6BEE6: variable 'v3' is possibly undefined
// 6BEE6: variable 'v4' is possibly undefined
// C1014: using guessed type int (__stdcall *dword_C1014)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BEEC) --------------------------------------------------------
int Scr_AddStruct()
{
  return dword_C1018();
}
// C1018: using guessed type int (*dword_C1018)(void);

//----- (0006BF00) --------------------------------------------------------
int __cdecl Scr_AddObject(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C102C(a1, v2, v3, v4);
}
// 6BF13: variable 'v2' is possibly undefined
// 6BF13: variable 'v3' is possibly undefined
// 6BF13: variable 'v4' is possibly undefined
// C102C: using guessed type int (__stdcall *dword_C102C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BF1C) --------------------------------------------------------
int __cdecl Scr_AddString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C101C(a1, v2, v3, v4);
}
// 6BF2E: variable 'v2' is possibly undefined
// 6BF2E: variable 'v3' is possibly undefined
// 6BF2E: variable 'v4' is possibly undefined
// C101C: using guessed type int (__stdcall *dword_C101C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BF34) --------------------------------------------------------
int __cdecl Scr_AddIString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1020(a1, v2, v3, v4);
}
// 6BF46: variable 'v2' is possibly undefined
// 6BF46: variable 'v3' is possibly undefined
// 6BF46: variable 'v4' is possibly undefined
// C1020: using guessed type int (__stdcall *dword_C1020)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BF4C) --------------------------------------------------------
int __cdecl Scr_AddConstString(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1024(a1, v2, v3, v4);
}
// 6BF5F: variable 'v2' is possibly undefined
// 6BF5F: variable 'v3' is possibly undefined
// 6BF5F: variable 'v4' is possibly undefined
// C1024: using guessed type int (__stdcall *dword_C1024)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BF68) --------------------------------------------------------
int __cdecl Scr_AddVector(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1028(a1, v2, v3, v4);
}
// 6BF7A: variable 'v2' is possibly undefined
// 6BF7A: variable 'v3' is possibly undefined
// 6BF7A: variable 'v4' is possibly undefined
// C1028: using guessed type int (__stdcall *dword_C1028)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BF80) --------------------------------------------------------
int Scr_AddArray()
{
  return dword_C1030();
}
// C1030: using guessed type int (*dword_C1030)(void);

//----- (0006BF94) --------------------------------------------------------
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1034(a1, v2, v3, v4);
}
// 6BFA7: variable 'v2' is possibly undefined
// 6BFA7: variable 'v3' is possibly undefined
// 6BFA7: variable 'v4' is possibly undefined
// C1034: using guessed type int (__stdcall *dword_C1034)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BFB0) --------------------------------------------------------
int Scr_MakeArray()
{
  return dword_C1038();
}
// C1038: using guessed type int (*dword_C1038)(void);

//----- (0006BFC4) --------------------------------------------------------
int __cdecl Scr_AddExecThread(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1060(a1, a2, v3, v4);
}
// 6BFDA: variable 'v3' is possibly undefined
// 6BFDA: variable 'v4' is possibly undefined
// C1060: using guessed type int (__stdcall *dword_C1060)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006BFE0) --------------------------------------------------------
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return dword_C1064(a1, a2, a3, a4);
}
// C1064: using guessed type int (__stdcall *dword_C1064)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C008) --------------------------------------------------------
int __cdecl Scr_ExecThread(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1068(a1, a2, v3, v4);
}
// 6C01E: variable 'v3' is possibly undefined
// 6C01E: variable 'v4' is possibly undefined
// C1068: using guessed type int (__stdcall *dword_C1068)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C028) --------------------------------------------------------
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return (unsigned __int16)dword_C106C(a1, a2, a3, a4);
}
// C106C: using guessed type int (__stdcall *dword_C106C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C050) --------------------------------------------------------
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1070(a1, v2, v3, v4);
}
// 6C063: variable 'v2' is possibly undefined
// 6C063: variable 'v3' is possibly undefined
// 6C063: variable 'v4' is possibly undefined
// C1070: using guessed type int (__stdcall *dword_C1070)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C06C) --------------------------------------------------------
int __cdecl Scr_Error(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1074(a1, v2, v3, v4);
}
// 6C07E: variable 'v2' is possibly undefined
// 6C07E: variable 'v3' is possibly undefined
// 6C07E: variable 'v4' is possibly undefined
// C1074: using guessed type int (__stdcall *dword_C1074)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C084) --------------------------------------------------------
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1078(a1, a2, v3, v4);
}
// 6C09A: variable 'v3' is possibly undefined
// 6C09A: variable 'v4' is possibly undefined
// C1078: using guessed type int (__stdcall *dword_C1078)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C0A0) --------------------------------------------------------
int __cdecl Scr_ParamError(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C107C(a1, a2, v3, v4);
}
// 6C0B6: variable 'v3' is possibly undefined
// 6C0B6: variable 'v4' is possibly undefined
// C107C: using guessed type int (__stdcall *dword_C107C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C0BC) --------------------------------------------------------
int __cdecl Scr_ObjectError(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1080(a1, v2, v3, v4);
}
// 6C0CE: variable 'v2' is possibly undefined
// 6C0CE: variable 'v3' is possibly undefined
// 6C0CE: variable 'v4' is possibly undefined
// C1080: using guessed type int (__stdcall *dword_C1080)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C0D4) --------------------------------------------------------
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3)
{
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1084(a1, a2, a3, v4);
}
// 6C0EF: variable 'v4' is possibly undefined
// C1084: using guessed type int (__stdcall *dword_C1084)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C0F8) --------------------------------------------------------
int __cdecl Scr_FreeEntityNum(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1088(a1, a2, v3, v4);
}
// 6C10E: variable 'v3' is possibly undefined
// 6C10E: variable 'v4' is possibly undefined
// C1088: using guessed type int (__stdcall *dword_C1088)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C114) --------------------------------------------------------
int __cdecl Scr_GetEntityId(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C108C(a1, a2, v3, v4);
}
// 6C12A: variable 'v3' is possibly undefined
// 6C12A: variable 'v4' is possibly undefined
// C108C: using guessed type int (__stdcall *dword_C108C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C134) --------------------------------------------------------
int __cdecl Scr_SetClassMap(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1090(a1, a2, v3, v4);
}
// 6C14A: variable 'v3' is possibly undefined
// 6C14A: variable 'v4' is possibly undefined
// C1090: using guessed type int (__stdcall *dword_C1090)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C150) --------------------------------------------------------
int Scr_RemoveClassMap()
{
  return dword_C1094();
}
// C1094: using guessed type int (*dword_C1094)(void);

//----- (0006C164) --------------------------------------------------------
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3)
{
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10A0(a1, a2, a3, v4);
}
// 6C180: variable 'v4' is possibly undefined
// C10A0: using guessed type int (__stdcall *dword_C10A0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C188) --------------------------------------------------------
int __cdecl Scr_AddFields(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10A4(a1, a2, v3, v4);
}
// 6C19E: variable 'v3' is possibly undefined
// 6C19E: variable 'v4' is possibly undefined
// C10A4: using guessed type int (__stdcall *dword_C10A4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C1A4) --------------------------------------------------------
int __cdecl Scr_FindField(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C10A8(a1, a2, v3, v4);
}
// 6C1BA: variable 'v3' is possibly undefined
// 6C1BA: variable 'v4' is possibly undefined
// C10A8: using guessed type int (__stdcall *dword_C10A8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C1C4) --------------------------------------------------------
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10AC(a1, a2, v3, v4);
}
// 6C1DB: variable 'v3' is possibly undefined
// 6C1DB: variable 'v4' is possibly undefined
// C10AC: using guessed type int (__stdcall *dword_C10AC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C1E4) --------------------------------------------------------
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10B0(a1, a2, a3, v4);
}
// 6C1FE: variable 'v4' is possibly undefined
// C10B0: using guessed type int (__stdcall *dword_C10B0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C204) --------------------------------------------------------
int __cdecl Scr_Init(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10B4(a1, a2, v3, v4);
}
// 6C21A: variable 'v3' is possibly undefined
// 6C21A: variable 'v4' is possibly undefined
// C10B4: using guessed type int (__stdcall *dword_C10B4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C220) --------------------------------------------------------
int Scr_Shutdown()
{
  return dword_C10B8();
}
// C10B8: using guessed type int (*dword_C10B8)(void);

//----- (0006C234) --------------------------------------------------------
int Scr_Abort()
{
  return dword_C10BC();
}
// C10BC: using guessed type int (*dword_C10BC)(void);

//----- (0006C248) --------------------------------------------------------
int __cdecl Scr_SetLoading(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10C0(a1, v2, v3, v4);
}
// 6C25A: variable 'v2' is possibly undefined
// 6C25A: variable 'v3' is possibly undefined
// 6C25A: variable 'v4' is possibly undefined
// C10C0: using guessed type int (__stdcall *dword_C10C0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C260) --------------------------------------------------------
int __cdecl Scr_InitSystem(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10C4(a1, a2, v3, v4);
}
// 6C276: variable 'v3' is possibly undefined
// 6C276: variable 'v4' is possibly undefined
// C10C4: using guessed type int (__stdcall *dword_C10C4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C27C) --------------------------------------------------------
int Scr_AllocGameVariable()
{
  return dword_C10C8();
}
// C10C8: using guessed type int (*dword_C10C8)(void);

//----- (0006C290) --------------------------------------------------------
int __cdecl Scr_GetChecksum(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10CC(a1, v2, v3, v4);
}
// 6C2A2: variable 'v2' is possibly undefined
// 6C2A2: variable 'v3' is possibly undefined
// 6C2A2: variable 'v4' is possibly undefined
// C10CC: using guessed type int (__stdcall *dword_C10CC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C2A8) --------------------------------------------------------
int Scr_HasSourceFiles()
{
  return dword_C10D0();
}
// C10D0: using guessed type int (*dword_C10D0)(void);

//----- (0006C2BC) --------------------------------------------------------
int __cdecl Scr_SaveSource(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10D4(a1, v2, v3, v4);
}
// 6C2CE: variable 'v2' is possibly undefined
// 6C2CE: variable 'v3' is possibly undefined
// 6C2CE: variable 'v4' is possibly undefined
// C10D4: using guessed type int (__stdcall *dword_C10D4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C2D4) --------------------------------------------------------
int __cdecl Scr_LoadSource(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10D8(a1, v2, v3, v4);
}
// 6C2E6: variable 'v2' is possibly undefined
// 6C2E6: variable 'v3' is possibly undefined
// 6C2E6: variable 'v4' is possibly undefined
// C10D8: using guessed type int (__stdcall *dword_C10D8)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C2EC) --------------------------------------------------------
int __cdecl Scr_SkipSource(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10DC(a1, v2, v3, v4);
}
// 6C2FE: variable 'v2' is possibly undefined
// 6C2FE: variable 'v3' is possibly undefined
// 6C2FE: variable 'v4' is possibly undefined
// C10DC: using guessed type int (__stdcall *dword_C10DC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C304) --------------------------------------------------------
int __cdecl Scr_SavePre(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10E0(a1, v2, v3, v4);
}
// 6C316: variable 'v2' is possibly undefined
// 6C316: variable 'v3' is possibly undefined
// 6C316: variable 'v4' is possibly undefined
// C10E0: using guessed type int (__stdcall *dword_C10E0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C31C) --------------------------------------------------------
int __cdecl Scr_SavePost(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10E4(a1, v2, v3, v4);
}
// 6C32E: variable 'v2' is possibly undefined
// 6C32E: variable 'v3' is possibly undefined
// 6C32E: variable 'v4' is possibly undefined
// C10E4: using guessed type int (__stdcall *dword_C10E4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C334) --------------------------------------------------------
int Scr_SaveShutdown()
{
  return dword_C10E8();
}
// C10E8: using guessed type int (*dword_C10E8)(void);

//----- (0006C348) --------------------------------------------------------
int __cdecl Scr_LoadPre(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10F0(a1, a2, v3, v4);
}
// 6C35E: variable 'v3' is possibly undefined
// 6C35E: variable 'v4' is possibly undefined
// C10F0: using guessed type int (__stdcall *dword_C10F0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C364) --------------------------------------------------------
int Scr_LoadShutdown()
{
  return dword_C10F4();
}
// C10F4: using guessed type int (*dword_C10F4)(void);

//----- (0006C378) --------------------------------------------------------
int __cdecl Scr_SetString(int a1, unsigned __int16 a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1118(a1, a2, v3, v4);
}
// 6C38F: variable 'v3' is possibly undefined
// 6C38F: variable 'v4' is possibly undefined
// C1118: using guessed type int (__stdcall *dword_C1118)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C398) --------------------------------------------------------
int __cdecl Scr_AllocString(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C111C(a1, a2, v3, v4);
}
// 6C3AE: variable 'v3' is possibly undefined
// 6C3AE: variable 'v4' is possibly undefined
// C111C: using guessed type int (__stdcall *dword_C111C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C3B8) --------------------------------------------------------
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4)
{
  return dword_C1120(a1, a2, a3, a4);
}
// C1120: using guessed type int (__stdcall *dword_C1120)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C3DC) --------------------------------------------------------
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3)
{
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1124(a1, a2, a3, v4);
}
// 6C3F8: variable 'v4' is possibly undefined
// C1124: using guessed type int (__stdcall *dword_C1124)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C400) --------------------------------------------------------
int __cdecl SL_ConvertToString(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1128(a1, v2, v3, v4);
}
// 6C413: variable 'v2' is possibly undefined
// 6C413: variable 'v3' is possibly undefined
// 6C413: variable 'v4' is possibly undefined
// C1128: using guessed type int (__stdcall *dword_C1128)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C41C) --------------------------------------------------------
int __cdecl SL_GetString(int a1, unsigned __int8 a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C112C(a1, a2, v3, v4);
}
// 6C433: variable 'v3' is possibly undefined
// 6C433: variable 'v4' is possibly undefined
// C112C: using guessed type int (__stdcall *dword_C112C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C43C) --------------------------------------------------------
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1130(a1, a2, v3, v4);
}
// 6C453: variable 'v3' is possibly undefined
// 6C453: variable 'v4' is possibly undefined
// C1130: using guessed type int (__stdcall *dword_C1130)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C45C) --------------------------------------------------------
int __cdecl SL_FindLowercaseString(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1134(a1, v2, v3, v4);
}
// 6C46E: variable 'v2' is possibly undefined
// 6C46E: variable 'v3' is possibly undefined
// 6C46E: variable 'v4' is possibly undefined
// C1134: using guessed type int (__stdcall *dword_C1134)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C478) --------------------------------------------------------
int __cdecl Scr_CreateCanonicalFilename(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1138(a1, v2, v3, v4);
}
// 6C48A: variable 'v2' is possibly undefined
// 6C48A: variable 'v3' is possibly undefined
// 6C48A: variable 'v4' is possibly undefined
// C1138: using guessed type int (__stdcall *dword_C1138)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C494) --------------------------------------------------------
int __cdecl Scr_SetTime(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C113C(a1, v2, v3, v4);
}
// 6C4A6: variable 'v2' is possibly undefined
// 6C4A6: variable 'v3' is possibly undefined
// 6C4A6: variable 'v4' is possibly undefined
// C113C: using guessed type int (__stdcall *dword_C113C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C4AC) --------------------------------------------------------
int Scr_RunCurrentThreads()
{
  return dword_C1140();
}
// C1140: using guessed type int (*dword_C1140)(void);

//----- (0006C4C0) --------------------------------------------------------
int Scr_ResetTimeout()
{
  return dword_C1144();
}
// C1144: using guessed type int (*dword_C1144)(void);

//----- (0006C4D4) --------------------------------------------------------
int __cdecl Scr_LoadScript(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C10FC(a1, v2, v3, v4);
}
// 6C4E6: variable 'v2' is possibly undefined
// 6C4E6: variable 'v3' is possibly undefined
// 6C4E6: variable 'v4' is possibly undefined
// C10FC: using guessed type int (__stdcall *dword_C10FC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C4EC) --------------------------------------------------------
_DWORD *__userpurge Scr_FindAnimTree@<eax>(_DWORD *a1, int a2)
{
  int v3; // [esp-8h] [ebp-20h]
  int v4; // [esp-4h] [ebp-1Ch]
  int v5; // [esp+14h] [ebp-4h] BYREF

  dword_C1100(&v5, a2, v3, v4);
  *a1 = v5;
  return a1;
}
// 6C506: variable 'v3' is possibly undefined
// 6C506: variable 'v4' is possibly undefined
// C1100: using guessed type int (__stdcall *dword_C1100)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C518) --------------------------------------------------------
int __cdecl Scr_FindAnim(int a1, int a2, int a3)
{
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1104(a1, a2, a3, v4);
}
// 6C532: variable 'v4' is possibly undefined
// C1104: using guessed type int (__stdcall *dword_C1104)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C538) --------------------------------------------------------
int __cdecl Scr_GetFunctionHandle(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1108(a1, a2, v3, v4);
}
// 6C54E: variable 'v3' is possibly undefined
// 6C54E: variable 'v4' is possibly undefined
// C1108: using guessed type int (__stdcall *dword_C1108)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C554) --------------------------------------------------------
int __cdecl Scr_FreeThread(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C110C(a1, v2, v3, v4);
}
// 6C567: variable 'v2' is possibly undefined
// 6C567: variable 'v3' is possibly undefined
// 6C567: variable 'v4' is possibly undefined
// C110C: using guessed type int (__stdcall *dword_C110C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C570) --------------------------------------------------------
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1110(a1, v2, v3, v4);
}
// 6C583: variable 'v2' is possibly undefined
// 6C583: variable 'v3' is possibly undefined
// 6C583: variable 'v4' is possibly undefined
// C1110: using guessed type int (__stdcall *dword_C1110)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C58C) --------------------------------------------------------
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return (unsigned __int16)dword_C1114(a1, v2, v3, v4);
}
// 6C59F: variable 'v2' is possibly undefined
// 6C59F: variable 'v3' is possibly undefined
// 6C59F: variable 'v4' is possibly undefined
// C1114: using guessed type int (__stdcall *dword_C1114)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C5A8) --------------------------------------------------------
int Scr_BeginLoadScripts()
{
  return dword_C103C();
}
// C103C: using guessed type int (*dword_C103C)(void);

//----- (0006C5BC) --------------------------------------------------------
int Scr_BeginLoadAnimTrees()
{
  return dword_C1040();
}
// C1040: using guessed type int (*dword_C1040)(void);

//----- (0006C5D0) --------------------------------------------------------
int Scr_EndLoadScripts()
{
  return dword_C1044();
}
// C1044: using guessed type int (*dword_C1044)(void);

//----- (0006C5E4) --------------------------------------------------------
int Scr_EndLoadAnimTrees()
{
  return dword_C1048();
}
// C1048: using guessed type int (*dword_C1048)(void);

//----- (0006C5F8) --------------------------------------------------------
int __cdecl Scr_PrecacheAnimTrees(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C104C(a1, v2, v3, v4);
}
// 6C60A: variable 'v2' is possibly undefined
// 6C60A: variable 'v3' is possibly undefined
// 6C60A: variable 'v4' is possibly undefined
// C104C: using guessed type int (__stdcall *dword_C104C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C610) --------------------------------------------------------
int __cdecl Scr_FreeScripts(unsigned __int8 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1050(a1, v2, v3, v4);
}
// 6C623: variable 'v2' is possibly undefined
// 6C623: variable 'v3' is possibly undefined
// 6C623: variable 'v4' is possibly undefined
// C1050: using guessed type int (__stdcall *dword_C1050)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C62C) --------------------------------------------------------
int __cdecl Scr_FreeGameVariable(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1054(a1, v2, v3, v4);
}
// 6C63E: variable 'v2' is possibly undefined
// 6C63E: variable 'v3' is possibly undefined
// 6C63E: variable 'v4' is possibly undefined
// C1054: using guessed type int (__stdcall *dword_C1054)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C644) --------------------------------------------------------
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1058(a1, v2, v3, v4);
}
// 6C657: variable 'v2' is possibly undefined
// 6C657: variable 'v3' is possibly undefined
// 6C657: variable 'v4' is possibly undefined
// C1058: using guessed type int (__stdcall *dword_C1058)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C660) --------------------------------------------------------
int __cdecl Scr_IsSystemActive(unsigned __int8 a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C105C(a1, v2, v3, v4);
}
// 6C673: variable 'v2' is possibly undefined
// 6C673: variable 'v3' is possibly undefined
// 6C673: variable 'v4' is possibly undefined
// C105C: using guessed type int (__stdcall *dword_C105C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C67C) --------------------------------------------------------
int __cdecl Scr_GetAnimsIndex(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1148(a1, v2, v3, v4);
}
// 6C68E: variable 'v2' is possibly undefined
// 6C68E: variable 'v3' is possibly undefined
// 6C68E: variable 'v4' is possibly undefined
// C1148: using guessed type int (__stdcall *dword_C1148)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C694) --------------------------------------------------------
int __cdecl Scr_GetAnims(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C114C(a1, v2, v3, v4);
}
// 6C6A6: variable 'v2' is possibly undefined
// 6C6A6: variable 'v3' is possibly undefined
// 6C6A6: variable 'v4' is possibly undefined
// C114C: using guessed type int (__stdcall *dword_C114C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C6AC) --------------------------------------------------------
int __cdecl MT_Alloc(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1150(a1, a2, v3, v4);
}
// 6C6C2: variable 'v3' is possibly undefined
// 6C6C2: variable 'v4' is possibly undefined
// C1150: using guessed type int (__stdcall *dword_C1150)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C6C8) --------------------------------------------------------
int __cdecl MT_Free(int a1, int a2)
{
  int v3; // [esp-8h] [ebp-10h]
  int v4; // [esp-4h] [ebp-Ch]

  return dword_C1154(a1, a2, v3, v4);
}
// 6C6DE: variable 'v3' is possibly undefined
// 6C6DE: variable 'v4' is possibly undefined
// C1154: using guessed type int (__stdcall *dword_C1154)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C6E4) --------------------------------------------------------
int *__cdecl Scr_FarHook(const void *a1)
{
  int *result; // eax

  if ( a1 )
    qmemcpy(&dword_C0FC0, a1, 0x198u);
  result = &dword_C1158;
  dword_C1158 = (int)Scr_GetFunction;
  dword_C115C = (int)Scr_GetMethod;
  dword_C1160 = (int)Scr_SetObjectField;
  dword_C1164 = (int)Scr_GetObjectField;
  dword_C1168 = (int)Scr_LoadRead;
  return result;
}
// C0FC0: using guessed type int (__stdcall *dword_C0FC0)(_DWORD, _DWORD, _DWORD, _DWORD);
// C1158: using guessed type int dword_C1158;
// C115C: using guessed type int dword_C115C;
// C1160: using guessed type int dword_C1160;
// C1164: using guessed type int dword_C1164;
// C1168: using guessed type int dword_C1168;

//----- (0006C740) --------------------------------------------------------
void sub_6C740()
{
  ;
}

//----- (0006C744) --------------------------------------------------------
void __noreturn _default_terminate()
{
  abort();
}
// 6C744: using guessed type void __noreturn _default_terminate();

//----- (0006C75C) --------------------------------------------------------
void sub_6C75C()
{
  ;
}

//----- (0006C760) --------------------------------------------------------
int _terminate()
{
  return _terminate_func();
}
// 8326C: using guessed type int (*_terminate_func)(void);

//----- (0006C784) --------------------------------------------------------
void sub_6C784()
{
  ;
}

//----- (0006C788) --------------------------------------------------------
int __cdecl _throw_type_match(char *s1, char *s2, int a3)
{
  int result; // eax

  if ( !strcmp(s1, s2) )
    result = a3;
  else
    result = 0;
  return result;
}

//----- (0006C7BC) --------------------------------------------------------
void _empty()
{
  ;
}

//----- (0006C7C4) --------------------------------------------------------
void sub_6C7C4()
{
  ;
}

//----- (0006C7C8) --------------------------------------------------------
_DWORD *sub_6C7C8()
{
  _DWORD *v0; // esi

  v0 = malloc(0x18u);
  if ( !v0 )
    __terminate();
  memset(v0, 0, 0x18u);
  v0[1] = v0 + 4;
  return v0;
}
// 27694: using guessed type int __terminate(void);

//----- (0006C814) --------------------------------------------------------
void sub_6C814()
{
  ;
}

//----- (0006C818) --------------------------------------------------------
int _get_eh_context()
{
  return off_83270();
}
// 83270: using guessed type int (*off_83270)(void);

//----- (0006C838) --------------------------------------------------------
void sub_6C838()
{
  ;
}

//----- (0006C83C) --------------------------------------------------------
int _get_eh_info()
{
  return off_83270() + 8;
}
// 83270: using guessed type int (*off_83270)(void);

//----- (0006C860) --------------------------------------------------------
void sub_6C860()
{
  ;
}

//----- (0006C864) --------------------------------------------------------
int *sub_6C864()
{
  off_83270 = (int (*)(void))sub_6C890;
  return sub_6C890();
}
// 83270: using guessed type int (*off_83270)(void);

//----- (0006C88C) --------------------------------------------------------
void sub_6C88C()
{
  ;
}

//----- (0006C890) --------------------------------------------------------
int *sub_6C890()
{
  if ( !dword_C117C )
  {
    dword_C117C = 1;
    dword_C116C = 0;
    dword_C1174 = 0;
    dword_C1178 = 0;
    dword_C1170 = (int)&unk_C1180;
  }
  return &dword_C116C;
}
// C116C: using guessed type int dword_C116C;
// C1170: using guessed type int dword_C1170;
// C1174: using guessed type int dword_C1174;
// C1178: using guessed type int dword_C1178;
// C117C: using guessed type int dword_C117C;

//----- (0006C8E8) --------------------------------------------------------
void sub_6C8E8()
{
  ;
}

//----- (0006C8EC) --------------------------------------------------------
int _get_dynamic_handler_chain()
{
  return off_83270() + 4;
}
// 83270: using guessed type int (*off_83270)(void);

//----- (0006C910) --------------------------------------------------------
void sub_6C910()
{
  ;
}

//----- (0006C914) --------------------------------------------------------
int _sjthrow()
{
  _DWORD *v0; // esi
  void (__cdecl *v1)(int, int); // ecx
  int v2; // edx
  _DWORD **v3; // eax
  int v5; // [esp+0h] [ebp-668h] BYREF
  int *v6; // [esp+18h] [ebp-650h]
  _DWORD **v7; // [esp+1Ch] [ebp-64Ch]
  int *v8; // [esp+20h] [ebp-648h]
  int v9; // [esp+24h] [ebp-644h]
  int v10[400]; // [esp+28h] [ebp-640h] BYREF
  int savedregs; // [esp+668h] [ebp+0h] BYREF

  v9 = off_83270();
  v8 = (int *)(v9 + 4);
  v7 = (_DWORD **)(*(_DWORD *)(v9 + 4) + 4);
  if ( *v7 )
  {
    v6 = v10;
    v10[1] = 0;
    v10[0] = *(_DWORD *)(v9 + 4);
    v10[2] = (int)&savedregs;
    v10[3] = (int)&loc_6C994;
    v10[4] = (int)&v5;
    *v8 = (int)v10;
    if ( *v7 )
    {
      do
      {
        v0 = v7;
        v1 = (void (__cdecl *)(int, int))(*v7)[1];
        v2 = (*v7)[2];
        *v7 = (_DWORD *)**v7;
        v1(v2, 2);
      }
      while ( *v0 );
    }
    *v8 = *v6;
  }
  if ( !*(_DWORD *)(v9 + 8) || !*(_DWORD *)*v8 )
    __terminate();
  v3 = (_DWORD **)*v8;
  *v8 = *(_DWORD *)*v8;
  return ((int (*)(void))v3[3])();
}
// 27694: using guessed type int __terminate(void);
// 83270: using guessed type int (*off_83270)(void);

//----- (0006CA20) --------------------------------------------------------
void sub_6CA20()
{
  ;
}

//----- (0006CA24) --------------------------------------------------------
void _sjpopnthrow()
{
  int v0; // edx
  _DWORD *v1; // esi
  void (__cdecl *v2)(int, int); // ecx
  int v3; // edx
  int v4; // [esp+0h] [ebp-668h] BYREF
  int *v5; // [esp+1Ch] [ebp-64Ch]
  _DWORD **v6; // [esp+20h] [ebp-648h]
  int *v7; // [esp+24h] [ebp-644h]
  int v8[400]; // [esp+28h] [ebp-640h] BYREF
  int savedregs; // [esp+668h] [ebp+0h] BYREF

  v0 = off_83270();
  v7 = (int *)(v0 + 4);
  v6 = (_DWORD **)(*(_DWORD *)(v0 + 4) + 4);
  if ( *v6 )
  {
    v5 = v8;
    v8[1] = 0;
    v8[0] = *(_DWORD *)(v0 + 4);
    v8[2] = (int)&savedregs;
    v8[3] = (int)&loc_6CAA0;
    v8[4] = (int)&v4;
    *v7 = (int)v8;
    if ( *v6 )
    {
      do
      {
        v1 = v6;
        v2 = (void (__cdecl *)(int, int))(*v6)[1];
        v3 = (*v6)[2];
        *v6 = (_DWORD *)**v6;
        v2(v3, 2);
      }
      while ( *v1 );
    }
    *v7 = *v5;
  }
  *v7 = *(_DWORD *)*v7;
  __sjthrow();
  sub_6CB18();
}
// 27594: using guessed type int __sjthrow(void);
// 83270: using guessed type int (*off_83270)(void);

//----- (0006CB18) --------------------------------------------------------
void sub_6CB18()
{
  ;
}

//----- (0006CB1C) --------------------------------------------------------
_BOOL4 __cdecl _eh_rtime_match(int a1)
{
  _DWORD *v1; // eax
  int (__cdecl *v2)(_DWORD, int, _DWORD); // ecx

  v1 = (_DWORD *)__get_eh_info();
  v2 = *(int (__cdecl **)(_DWORD, int, _DWORD))*v1;
  if ( v2 )
    return v2(*v1, a1, 0) != 0;
  fprintf(stderr, "Internal Compiler Bug: No runtime type matcher.");
  return 0;
}
// 27564: using guessed type int __get_eh_info(void);

//----- (0006CB74) --------------------------------------------------------
int __cdecl _get_eh_table_version(int a1)
{
  return *(__int16 *)(a1 + 6);
}

//----- (0006CB84) --------------------------------------------------------
int __cdecl _get_eh_table_language(int a1)
{
  return *(__int16 *)(a1 + 4);
}

//----- (0006CB94) --------------------------------------------------------
int __cdecl sub_6CB94(unsigned int a1, _DWORD *a2)
{
  int i; // edi
  unsigned int v3; // ecx
  unsigned int v4; // edx
  int result; // eax
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  if ( !a2 )
    goto LABEL_15;
  v6 = -1;
  v7 = 0;
  if ( *a2 != -1 )
  {
    for ( i = 0; a2[i] != -1; i += 3 )
    {
      v3 = a2[i];
      if ( v3 > a1 || (v4 = a2[i + 1], v4 <= a1) )
      {
        if ( v6 >= 0 && a2[i] > a1 )
          break;
      }
      else if ( v6 == -1 || v4 <= a2[3 * v6 + 1] && v3 >= a2[3 * v6] )
      {
        v6 = v7;
      }
      ++v7;
    }
  }
  if ( v6 == -1 )
LABEL_15:
    result = 0;
  else
    result = a2[3 * v6 + 2];
  return result;
}

//----- (0006CC28) --------------------------------------------------------
void sub_6CC28()
{
  ;
}

//----- (0006CC2C) --------------------------------------------------------
unsigned int __cdecl sub_6CC2C(int a1, int a2, _DWORD *a3, int a4, _DWORD *a5)
{
  int v5; // edx
  int v6; // ecx
  int v7; // edx
  unsigned int v8; // edi
  unsigned int *v9; // esi
  unsigned int v10; // edx
  unsigned int v12; // [esp+14h] [ebp-4h]

  v12 = 0;
  *a5 = 1;
  if ( !a2 )
    return v12;
  v5 = 0;
  v6 = a2 + 8;
  if ( a4 )
  {
    v7 = (a1 - v6) >> 4;
    v8 = *(_DWORD *)(a1 + 4) - 1;
    if ( *(_DWORD *)(v6 + 16 * v7) == -1 )
      return v12;
    v5 = v7 + 1;
  }
  else
  {
    v8 = a1 - 1;
  }
  if ( *(_DWORD *)(v6 + 16 * v5) == -1 )
    return v12;
  v9 = (unsigned int *)(v6 + 16 * v5);
  while ( 1 )
  {
    if ( *v9 <= v8 && v9[1] > v8 )
    {
      v10 = v9[3];
      if ( !v10 )
      {
        if ( !v12 )
          v12 = v9[2];
        goto LABEL_18;
      }
      if ( *a3 && ((int (__cdecl *)(_DWORD *, unsigned int, int))*a3)(a3, v10, a2) )
        break;
    }
LABEL_18:
    v9 += 4;
    if ( *v9 == -1 )
      return v12;
  }
  if ( !v12 )
    v12 = v9[2];
  *a5 = 0;
  return v12;
}

//----- (0006CCFC) --------------------------------------------------------
void sub_6CCFC()
{
  ;
}

//----- (0006CD00) --------------------------------------------------------
int __cdecl sub_6CD00(int a1, _DWORD *a2)
{
  int i; // edx

  for ( i = a1; *((_BYTE *)a2 + i + 92) == 2; i = a2[i + 4] )
    ;
  if ( *((_BYTE *)a2 + i + 92) != 1 )
    abort();
  return *a2 + a2[i + 4];
}

//----- (0006CD4C) --------------------------------------------------------
void sub_6CD4C()
{
  ;
}

//----- (0006CD50) --------------------------------------------------------
void *__cdecl sub_6CD50(int a1, _DWORD *a2, _DWORD *a3)
{
  const void *v3; // edi
  void *v4; // eax
  size_t v5; // edx

  v3 = (const void *)sub_6CD00(a1, a2);
  v4 = (void *)sub_6CD00(a1, a3);
  v5 = 4;
  if ( (unsigned int)(a1 - 11) <= 7 )
    v5 = 12;
  return memcpy(v4, v3, v5);
}

//----- (0006CDB4) --------------------------------------------------------
void sub_6CDB4()
{
  ;
}

//----- (0006CDB8) --------------------------------------------------------
_DWORD *__cdecl sub_6CDB8(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  _DWORD *v4; // esi
  int v6; // eax
  int v7; // eax

  v3 = __frame_state_for(a1, a3);
  v4 = (_DWORD *)v3;
  if ( !v3 )
    return 0;
  v6 = *(unsigned __int16 *)(v3 + 88);
  if ( *((_BYTE *)a2 + v6 + 92) )
    v7 = *(_DWORD *)sub_6CD00(v6, a2);
  else
    v7 = *a2;
  *v4 = v7;
  *v4 += v4[2];
  return v4;
}
// 27574: using guessed type _DWORD __cdecl __frame_state_for(_DWORD, _DWORD);

//----- (0006CE28) --------------------------------------------------------
void _unwinding_cleanup()
{
  ;
}

//----- (0006CE30) --------------------------------------------------------
void sub_6CE30()
{
  ;
}

//----- (0006CE34) --------------------------------------------------------
unsigned int __cdecl sub_6CE34(unsigned int *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  _DWORD *v4; // edx
  _BOOL4 v5; // eax
  char *v6; // edi
  int i; // esi
  int v9; // [esp+20h] [ebp-188h]
  char *v10; // [esp+24h] [ebp-184h]
  _DWORD *v11; // [esp+28h] [ebp-180h]
  int v12; // [esp+2Ch] [ebp-17Ch]
  int v13; // [esp+30h] [ebp-178h]
  _BOOL4 v14; // [esp+34h] [ebp-174h]
  int v15; // [esp+38h] [ebp-170h]
  int v16; // [esp+3Ch] [ebp-16Ch]
  unsigned int v17; // [esp+40h] [ebp-168h]
  unsigned int v18; // [esp+44h] [ebp-164h]
  int v19; // [esp+48h] [ebp-160h]
  char *v20; // [esp+4Ch] [ebp-15Ch]
  char *v21; // [esp+50h] [ebp-158h]
  int v22; // [esp+54h] [ebp-154h] BYREF
  char v23[112]; // [esp+58h] [ebp-150h] BYREF
  char v24; // [esp+C8h] [ebp-E0h] BYREF
  char v25[112]; // [esp+138h] [ebp-70h] BYREF
  int v26; // [esp+1B4h] [ebp+Ch]

  v21 = v25;
  v20 = &v24;
  v19 = a2;
  v22 = 0;
  v15 = 0;
  v13 = 0;
  v11 = (_DWORD *)a1[2];
  v14 = a1[3] != 0;
  qmemcpy(v25, a3, sizeof(v25));
  v18 = 0;
  while ( 1 )
  {
    v10 = v21;
    v21 = (char *)sub_6CDB8(a2, v21, (int)v20);
    v20 = v10;
    if ( !v21 )
      break;
    v4 = (_DWORD *)*((_DWORD *)v21 + 1);
    if ( v4 )
      v5 = *v4 == -2;
    else
      v5 = 0;
    if ( v14 )
    {
      v14 = 0;
      v18 = sub_6CC2C(a1[3], (int)v4, v11, 1, &v22);
      a1[3] = 0;
    }
    else if ( v5 )
    {
      v18 = sub_6CC2C(a2, (int)v4, v11, 0, &v22);
    }
    else
    {
      v18 = sub_6CB94(a2, *((_DWORD **)v21 + 1));
    }
    if ( v18 )
    {
      if ( !v22 )
      {
        v15 = 0;
        break;
      }
      if ( !v13 )
      {
        qmemcpy(v23, v21, sizeof(v23));
        v17 = v18;
        v16 = a2;
        v13 = 1;
        v15 = 1;
      }
    }
    a2 = *(_DWORD *)sub_6CD00(*((unsigned __int16 *)v21 + 45), v21) - 1;
  }
  if ( v13 )
  {
    v21 = v23;
    v18 = v17;
    a2 = v16;
    if ( v15 )
      __unwinding_cleanup();
  }
  if ( !v18 )
    __terminate();
  *a1 = v18;
  v12 = *((_DWORD *)v21 + 3);
  if ( a2 == v19 )
  {
    v21 = (char *)a3;
  }
  else
  {
    v9 = a2;
    v26 = v19;
    qmemcpy(v21, a3, 0x70u);
    if ( v19 != v9 )
    {
      do
      {
        v6 = v21;
        v21 = (char *)sub_6CDB8(v26, v21, (int)v20);
        v20 = v6;
        for ( i = 0; i <= 16; ++i )
        {
          if ( i != *((unsigned __int16 *)v21 + 45) && v21[i + 92] )
            sub_6CD50(i, v21, a3);
        }
        v26 = *(_DWORD *)sub_6CD00(*((unsigned __int16 *)v21 + 45), v21) - 1;
      }
      while ( v26 != v9 );
    }
  }
  *a4 = v12 + *(_DWORD *)v21 - *a3;
  return v18;
}
// 6D04F: variable 'v17' is possibly undefined
// 6D055: variable 'v16' is possibly undefined
// 275C4: using guessed type int __unwinding_cleanup(void);
// 27694: using guessed type int __terminate(void);

//----- (0006D194) --------------------------------------------------------
void sub_6D194()
{
  ;
}

//----- (0006D198) --------------------------------------------------------
unsigned int *__cdecl _throw(char a1)
{
  unsigned int *result; // eax
  _DWORD *v2; // [esp+2Ch] [ebp-7Ch]
  unsigned int *v3; // [esp+30h] [ebp-78h]
  int v4; // [esp+34h] [ebp-74h] BYREF
  char v5[112]; // [esp+38h] [ebp-70h] BYREF
  void *retaddr; // [esp+ACh] [ebp+4h]

  v3 = (unsigned int *)off_83270();
  if ( !v3[2] )
    __terminate();
  v2 = (_DWORD *)__frame_state_for(&loc_6D1EC, v5);
  if ( !v2 )
    __terminate();
  *v2 = &a1;
  sub_6CE34(v3, (int)retaddr - 1, v2, &v4);
  result = v3;
  retaddr = &loc_6D240;
  return result;
}
// 27574: using guessed type _DWORD __cdecl __frame_state_for(_DWORD, _DWORD);
// 27694: using guessed type int __terminate(void);
// 83270: using guessed type int (*off_83270)(void);

//----- (0006D254) --------------------------------------------------------
void sub_6D254()
{
  ;
}

//----- (0006D258) --------------------------------------------------------
unsigned int *__cdecl _rethrow(unsigned int a1)
{
  unsigned int *result; // eax
  unsigned int **v2; // [esp+2Ch] [ebp-7Ch]
  unsigned int *v3; // [esp+30h] [ebp-78h]
  int v4; // [esp+34h] [ebp-74h] BYREF
  char v5[112]; // [esp+38h] [ebp-70h] BYREF
  void *retaddr; // [esp+ACh] [ebp+4h]

  v3 = (unsigned int *)off_83270();
  if ( !v3[2] )
    __terminate();
  v3[3] = a1;
  v2 = (unsigned int **)__frame_state_for(&loc_6D2B5, v5);
  if ( !v2 )
    __terminate();
  *v2 = &a1;
  sub_6CE34(v3, (int)retaddr - 1, v2, &v4);
  result = v3;
  retaddr = &loc_6D305;
  return result;
}
// 27574: using guessed type _DWORD __cdecl __frame_state_for(_DWORD, _DWORD);
// 27694: using guessed type int __terminate(void);
// 83270: using guessed type int (*off_83270)(void);

//----- (0006D320) --------------------------------------------------------
char *__cdecl sub_6D320(char *a1, int *a2)
{
  int v2; // edi
  char v3; // al
  int v4; // esi
  char v5; // dl
  char *v7; // [esp+10h] [ebp+8h]

  v2 = 0;
  v3 = *a1;
  v7 = a1 + 1;
  v4 = v3 & 0x7F;
  if ( v3 < 0 )
  {
    do
    {
      v2 += 7;
      v5 = *v7++;
      v4 |= (v5 & 0x7F) << v2;
    }
    while ( v5 < 0 );
  }
  *a2 = v4;
  return v7;
}

//----- (0006D36C) --------------------------------------------------------
char *__cdecl sub_6D36C(char *a1, _DWORD *a2)
{
  unsigned int v2; // esi
  int v3; // edi
  char v4; // cl
  char v5; // dl

  v2 = 0;
  v3 = 0;
  do
  {
    v4 = v2;
    v2 += 7;
    v5 = *a1++;
    v3 |= (v5 & 0x7F) << v4;
  }
  while ( v5 < 0 );
  if ( v2 <= 0x1F && (v5 & 0x40) != 0 )
    v3 |= -1 << v2;
  *a2 = v3;
  return a1;
}

//----- (0006D3B4) --------------------------------------------------------
_DWORD *__cdecl sub_6D3B4(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int v3; // edi
  int v4; // esi
  int i; // [esp+14h] [ebp-4h]

  result = a2;
  v3 = a2[1];
  if ( v3 )
  {
    v4 = a1[1];
    do
    {
      --v3;
      for ( i = *(_DWORD *)(*a2 + 4 * v3); v4; --v4 )
      {
        if ( *(_DWORD *)(*(_DWORD *)(*a1 + 4 * v4 - 4) + 8) - *(_DWORD *)(i + 8) <= 0 )
          break;
        *(_DWORD *)(*a1 + 4 * (v3 + v4)) = *(_DWORD *)(*a1 + 4 * v4 - 4);
      }
      *(_DWORD *)(*a1 + 4 * (v3 + v4)) = i;
    }
    while ( v3 );
    result = (_DWORD *)a2[1];
    a1[1] += result;
  }
  return result;
}

//----- (0006D434) --------------------------------------------------------
void sub_6D434()
{
  ;
}

//----- (0006D438) --------------------------------------------------------
int __cdecl sub_6D438(int *a1, int a2)
{
  int v2; // edi
  int *v3; // edi
  int v4; // edx
  int v5; // esi
  int v6; // edx
  int v7; // edx
  int v8; // esi
  int v10; // [esp+14h] [ebp-24h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+20h] [ebp-18h]
  int v14; // [esp+24h] [ebp-14h]
  int v15; // [esp+2Ch] [ebp-Ch]
  unsigned int v16; // [esp+30h] [ebp-8h]
  unsigned int v17; // [esp+34h] [ebp-4h]

  v2 = a1[1];
  if ( v2 != a2 )
    abort();
  sub_6E0C4(a1, a1 + 2);
  if ( a1[1] + a1[3] != v2 )
    abort();
  v3 = (int *)a1[2];
  v17 = a1[3];
  v16 = v17;
  while ( v16 )
  {
    v4 = --v16;
    while ( 2 * v4 + 1 < v17 )
    {
      v12 = v3[2 * v4 + 1];
      v5 = v3[v4];
      if ( 2 * v4 + 2 >= v17
        || (v15 = v3[2 * v4 + 2], v10 = *(_DWORD *)(v15 + 8), v10 - *(_DWORD *)(v12 + 8) <= 0)
        || v10 - *(_DWORD *)(v5 + 8) <= 0 )
      {
        if ( *(_DWORD *)(v12 + 8) - *(_DWORD *)(v5 + 8) <= 0 )
          break;
        v3[v4] = v12;
        v3[2 * v4 + 1] = v5;
        v4 = 2 * v4 + 1;
      }
      else
      {
        v3[v4] = v15;
        v3[2 * v4 + 2] = v5;
        v4 = 2 * v4 + 2;
      }
    }
  }
LABEL_24:
  while ( v17 > 1 )
  {
    --v17;
    v6 = *v3;
    *v3 = v3[v17];
    v3[v17] = v6;
    v7 = 0;
    if ( v17 > 1 )
    {
      do
      {
        v13 = v3[2 * v7 + 1];
        v8 = v3[v7];
        if ( 2 * v7 + 2 >= v17
          || (v14 = v3[2 * v7 + 2], v11 = *(_DWORD *)(v14 + 8), v11 - *(_DWORD *)(v13 + 8) <= 0)
          || v11 - *(_DWORD *)(v8 + 8) <= 0 )
        {
          if ( *(_DWORD *)(v13 + 8) - *(_DWORD *)(v8 + 8) <= 0 )
            goto LABEL_24;
          v3[v7] = v13;
          v3[2 * v7 + 1] = v8;
          v7 = 2 * v7 + 1;
        }
        else
        {
          v3[v7] = v14;
          v3[2 * v7 + 2] = v8;
          v7 = 2 * v7 + 2;
        }
      }
      while ( 2 * v7 + 1 < v17 );
    }
  }
  sub_6D3B4(a1, a1 + 2);
  free((void *)a1[2]);
  return *a1;
}

//----- (0006D628) --------------------------------------------------------
int __cdecl sub_6D628(_DWORD *a1)
{
  _DWORD *v1; // edx
  int i; // ecx

  v1 = a1;
  for ( i = 0; *v1; v1 = (_DWORD *)((char *)v1 + *v1 + 4) )
  {
    if ( v1[1] && v1[2] )
      ++i;
  }
  return i;
}

//----- (0006D658) --------------------------------------------------------
unsigned int __cdecl sub_6D658(_DWORD *a1, _DWORD *a2, unsigned int *a3, unsigned int *a4)
{
  _DWORD *v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int result; // eax
  unsigned int i; // [esp+14h] [ebp-4h]

  v4 = a1;
  v5 = *a3;
  for ( i = *a4; *v4; v4 = (_DWORD *)((char *)v4 + *v4 + 4) )
  {
    if ( v4[1] && v4[2] )
    {
      *(_DWORD *)(*a2 + 4 * a2[1]++) = v4;
      v6 = v4[2];
      if ( v6 < v5 )
        v5 = v4[2];
      v7 = v4[3] + v6;
      if ( v7 > i )
        i = v7;
    }
  }
  *a3 = v5;
  result = i;
  *a4 = i;
  return result;
}

//----- (0006D6C4) --------------------------------------------------------
void sub_6D6C4()
{
  ;
}

//----- (0006D6C8) --------------------------------------------------------
unsigned int __cdecl sub_6D6C8(int a1)
{
  _DWORD **v1; // esi
  _DWORD *v2; // eax
  _DWORD **v3; // esi
  unsigned int result; // eax
  int i; // [esp+1Ch] [ebp-1Ch]
  unsigned int v6; // [esp+20h] [ebp-18h] BYREF
  unsigned int v7; // [esp+24h] [ebp-14h] BYREF
  int v8[4]; // [esp+28h] [ebp-10h] BYREF

  if ( *(_DWORD *)(a1 + 12) )
  {
    v1 = *(_DWORD ***)(a1 + 12);
    for ( i = 0; *v1; ++v1 )
      i += sub_6D628(*v1);
  }
  else
  {
    i = sub_6D628(*(_DWORD **)(a1 + 8));
  }
  *(_DWORD *)(a1 + 16) = i;
  v8[0] = (int)malloc(4 * i);
  v8[2] = (int)malloc(4 * i);
  v8[1] = 0;
  v8[3] = 0;
  v6 = -1;
  v7 = 0;
  v2 = *(_DWORD **)(a1 + 12);
  if ( v2 )
  {
    v3 = *(_DWORD ***)(a1 + 12);
    if ( *v2 )
    {
      do
        sub_6D658(*v3++, v8, &v6, &v7);
      while ( *v3 );
    }
  }
  else
  {
    sub_6D658(*(_DWORD **)(a1 + 8), v8, &v6, &v7);
  }
  *(_DWORD *)(a1 + 12) = sub_6D438(v8, i);
  *(_DWORD *)a1 = v6;
  result = v7;
  *(_DWORD *)(a1 + 4) = v7;
  return result;
}

//----- (0006D808) --------------------------------------------------------
void sub_6D808()
{
  ;
}

//----- (0006D80C) --------------------------------------------------------
int __cdecl sub_6D80C(unsigned int a1)
{
  unsigned int *i; // esi
  int result; // eax
  unsigned int v3; // edi
  unsigned int v4; // esi
  unsigned int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // [esp+14h] [ebp-4h]

  for ( i = (unsigned int *)dword_C1188; ; i = (unsigned int *)i[5] )
  {
    if ( !i )
      return 0;
    if ( !*i )
      sub_6D6C8((int)i);
    if ( a1 >= *i && a1 < i[1] )
      break;
  }
  v7 = 0;
  v3 = i[4];
  if ( v3 )
  {
    v4 = i[3];
    do
    {
      v5 = (v3 + v7) >> 1;
      result = *(_DWORD *)(v4 + 4 * v5);
      v6 = *(_DWORD *)(result + 8);
      if ( a1 >= v6 )
      {
        if ( a1 < *(_DWORD *)(result + 12) + v6 )
          return result;
        v7 = v5 + 1;
      }
      else
      {
        v3 = (v3 + v7) >> 1;
      }
    }
    while ( v7 < v3 );
  }
  return 0;
}
// 6D84E: conditional instruction was optimized away because of 'esi.4!=0'
// C1188: using guessed type int dword_C1188;

//----- (0006D8A0) --------------------------------------------------------
void sub_6D8A0()
{
  ;
}

//----- (0006D8A4) --------------------------------------------------------
char *__cdecl sub_6D8A4(int a1, int a2)
{
  _BYTE *v3; // edx
  int v4; // eax
  int v5; // eax
  char *v6; // edx
  char *v7; // eax
  char *v8; // eax
  char *v9; // edx
  char *v10; // eax
  _BYTE *v11; // [esp+14h] [ebp-14h]
  int v12; // [esp+20h] [ebp-8h]
  int v13; // [esp+24h] [ebp-4h] BYREF

  v12 = a1 - (*(_DWORD *)(a1 + 4) - 4);
  *(_DWORD *)a2 = v12 + 9;
  if ( strcmp((const char *)(v12 + 9), (const char *)&unk_7A390)
    && strcmp((const char *)(v12 + 9), "eh")
    && *(_BYTE *)(v12 + 9) != 122 )
  {
    return 0;
  }
  v3 = *(_BYTE **)a2;
  v4 = *(_DWORD *)a2 & 3;
  if ( !v4 )
    goto LABEL_14;
  if ( __SETP__(*(_DWORD *)a2 & 3, 0) )
    goto LABEL_12;
  if ( v4 != 2 )
  {
    if ( *v3 == BYTE1(v4) )
      goto LABEL_21;
    ++v3;
  }
  if ( *v3 != BYTE1(v4) )
  {
    ++v3;
LABEL_12:
    if ( *v3 != BYTE1(v4) )
    {
      ++v3;
LABEL_14:
      while ( 1 )
      {
        v5 = *(_DWORD *)v3;
        if ( !(unsigned __int8)*(_DWORD *)v3 )
          break;
        if ( !BYTE1(v5) )
          goto LABEL_20;
        if ( (v5 & 0xFF0000) == 0 )
          goto LABEL_19;
        v3 += 4;
        if ( (v5 & 0xFF000000) == 0 )
        {
          v3 -= 3;
LABEL_19:
          ++v3;
LABEL_20:
          ++v3;
          break;
        }
      }
    }
  }
LABEL_21:
  v11 = v3;
  v6 = v3 + 1;
  if ( !strcmp(*(const char **)a2, "eh") )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v11 + 1);
    v6 = v11 + 5;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = 0;
  }
  v7 = sub_6D320(v6, (int *)(a2 + 8));
  v8 = sub_6D36C(v7, (_DWORD *)(a2 + 12));
  *(_DWORD *)(a2 + 16) = (unsigned __int8)*v8;
  v9 = v8 + 1;
  if ( **(_BYTE **)a2 == 122 )
  {
    v10 = sub_6D320(v9, &v13);
    v9 = &v10[v13];
  }
  return v9;
}

//----- (0006D9F0) --------------------------------------------------------
void sub_6D9F0()
{
  ;
}

//----- (0006D9F4) --------------------------------------------------------
char *__cdecl sub_6D9F4(unsigned __int8 *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // eax
  char *v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int v13; // ecx
  char *v14; // eax
  void *v15; // edx
  void *v16; // edx
  int v17; // eax
  int v18; // edx
  char *result; // eax
  int v20; // [esp+1Ch] [ebp-Ch] BYREF
  int v21; // [esp+20h] [ebp-8h] BYREF
  int v22; // [esp+24h] [ebp-4h] BYREF
  char *v23; // [esp+30h] [ebp+8h]

  v4 = *a1;
  v23 = (char *)(a1 + 1);
  if ( (v4 & 0x40) != 0 )
  {
    *a4 += *(_DWORD *)(a3 + 8) * (v4 & 0x3F);
  }
  else if ( (v4 & 0x80u) == 0 )
  {
    if ( (v4 & 0xC0) == 0 )
    {
      switch ( v4 )
      {
        case 0:
        case 7:
        case 8:
          return v23;
        case 1:
          *a4 = *(_DWORD *)v23;
          v23 += 4;
          return v23;
        case 2:
          *a4 += (unsigned __int8)*v23++;
          return v23;
        case 3:
          *a4 += *(unsigned __int16 *)v23;
          v23 += 2;
          return v23;
        case 4:
          *a4 += *(_DWORD *)v23;
          v23 += 4;
          return v23;
        case 5:
          v9 = sub_6D320(v23, &v21);
          v10 = sub_6D320(v9, &v22);
          v6 = *(_DWORD *)(a3 + 12) * v22;
          v7 = v21;
          v23 = v10;
          v22 = v6;
          *(_BYTE *)(v21 + a2 + 92) = 1;
          v8 = a2;
          goto LABEL_13;
        case 6:
          v23 = sub_6D320(v23, &v21);
          *(_BYTE *)(v21 + a2 + 92) = 0;
          return v23;
        case 9:
          v11 = sub_6D320(v23, &v21);
          v12 = sub_6D320(v11, &v20);
          v13 = v21;
          v23 = v12;
          *(_BYTE *)(v21 + a2 + 92) = 2;
          *(_DWORD *)(a2 + 16 + 4 * v13) = v20;
          return v23;
        case 10:
          v15 = malloc(0x74u);
          qmemcpy(v15, (const void *)a2, 0x74u);
          *(_DWORD *)(a2 + 112) = v15;
          return v23;
        case 11:
          v16 = *(void **)(a2 + 112);
          qmemcpy((void *)a2, v16, 0x74u);
          free(v16);
          return v23;
        case 12:
          v14 = sub_6D320(v23, &v21);
          v23 = sub_6D320(v14, &v22);
          *(_WORD *)(a2 + 88) = v21;
          *(_DWORD *)(a2 + 8) = v22;
          return v23;
        case 13:
          v23 = sub_6D320(v23, &v21);
          *(_WORD *)(a2 + 88) = v21;
          return v23;
        case 14:
          v23 = sub_6D320(v23, &v22);
          *(_DWORD *)(a2 + 8) = v22;
          return v23;
        case 45:
          v21 = 16;
          v17 = 16;
          do
          {
            *(_BYTE *)(v17 + a2 + 92) = 1;
            v18 = v21;
            *(_DWORD *)(a2 + 16 + 4 * v21) = 4 * v21 - 64;
            v17 = v18 + 1;
            v21 = v18 + 1;
          }
          while ( (unsigned int)(v18 + 1) <= 0x1F );
          return v23;
        case 46:
          v23 = sub_6D320(v23, &v22);
          *(_DWORD *)(a2 + 12) = v22;
          return v23;
        default:
          abort();
          return result;
      }
    }
    *(_BYTE *)((v4 & 0x3F) + a2 + 92) = 0;
  }
  else
  {
    v21 = v4 & 0x3F;
    v5 = sub_6D320(v23, &v22);
    v6 = *(_DWORD *)(a3 + 12) * v22;
    v7 = v21;
    v23 = v5;
    v8 = a2;
    v22 = v6;
    *(_BYTE *)(v21 + a2 + 92) = 1;
LABEL_13:
    *(_DWORD *)(v8 + 16 + 4 * v7) = v6;
  }
  return v23;
}

//----- (0006DDA0) --------------------------------------------------------
void sub_6DDA0()
{
  ;
}

//----- (0006DDA4) --------------------------------------------------------
int __cdecl _register_frame_info(int a1, _DWORD *a2)
{
  int result; // eax

  a2[2] = a1;
  result = dword_C1188;
  a2[1] = 0;
  *a2 = 0;
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = result;
  dword_C1188 = (int)a2;
  return result;
}
// C1188: using guessed type int dword_C1188;

//----- (0006DDEC) --------------------------------------------------------
void sub_6DDEC()
{
  ;
}

//----- (0006DDF0) --------------------------------------------------------
int __cdecl _register_frame(int a1)
{
  void *v1; // eax

  v1 = malloc(0x18u);
  return __register_frame_info(a1, v1);
}
// 276E4: using guessed type _DWORD __cdecl __register_frame_info(_DWORD, _DWORD);

//----- (0006DE24) --------------------------------------------------------
void sub_6DE24()
{
  ;
}

//----- (0006DE28) --------------------------------------------------------
int __cdecl _register_frame_info_table(int a1, _DWORD *a2)
{
  int result; // eax

  a2[2] = a1;
  a2[3] = a1;
  result = dword_C1188;
  a2[1] = 0;
  *a2 = 0;
  a2[4] = 0;
  a2[5] = result;
  dword_C1188 = (int)a2;
  return result;
}
// C1188: using guessed type int dword_C1188;

//----- (0006DE6C) --------------------------------------------------------
void sub_6DE6C()
{
  ;
}

//----- (0006DE70) --------------------------------------------------------
int __cdecl _register_frame_table(int a1)
{
  void *v1; // eax

  v1 = malloc(0x18u);
  return __register_frame_info_table(a1, v1);
}
// 276D4: using guessed type _DWORD __cdecl __register_frame_info_table(_DWORD, _DWORD);

//----- (0006DEA4) --------------------------------------------------------
void sub_6DEA4()
{
  ;
}

//----- (0006DEA8) --------------------------------------------------------
int __cdecl _deregister_frame_info(int a1)
{
  int *v1; // edx
  int v2; // esi

  v1 = &dword_C1188;
  if ( !dword_C1188 )
LABEL_7:
    abort();
  while ( 1 )
  {
    v2 = *v1;
    if ( *(_DWORD *)(*v1 + 8) == a1 )
      break;
    v1 = (int *)(v2 + 20);
    if ( !*(_DWORD *)(v2 + 20) )
      goto LABEL_7;
  }
  *v1 = *(_DWORD *)(v2 + 20);
  if ( *(_DWORD *)v2 )
    free(*(void **)(v2 + 12));
  return v2;
}
// C1188: using guessed type int dword_C1188;

//----- (0006DF0C) --------------------------------------------------------
void sub_6DF0C()
{
  ;
}

//----- (0006DF10) --------------------------------------------------------
void __cdecl _deregister_frame(int a1)
{
  void *v1; // eax

  v1 = (void *)__deregister_frame_info(a1);
  free(v1);
}
// 275B4: using guessed type _DWORD __cdecl __deregister_frame_info(_DWORD);

//----- (0006DF40) --------------------------------------------------------
void sub_6DF40()
{
  ;
}

//----- (0006DF44) --------------------------------------------------------
int *__cdecl _frame_state_for(unsigned int a1, int *a2)
{
  unsigned int i; // edi
  char *v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned __int8 *v7; // [esp+20h] [ebp-98h]
  unsigned __int8 *v8; // [esp+20h] [ebp-98h]
  int v9; // [esp+24h] [ebp-94h]
  unsigned int j; // [esp+28h] [ebp-90h] BYREF
  int v11; // [esp+2Ch] [ebp-8Ch] BYREF
  int v12[29]; // [esp+30h] [ebp-88h] BYREF
  int v13[4]; // [esp+A4h] [ebp-14h] BYREF
  int v14; // [esp+B4h] [ebp-4h]

  v9 = sub_6D80C(a1);
  if ( !v9 )
    return 0;
  v7 = (unsigned __int8 *)sub_6D8A4(v9, (int)v13);
  if ( !v7 )
    return 0;
  memset(v12, 0, sizeof(v12));
  HIWORD(v12[22]) = v14;
  v12[1] = v13[1];
  for ( i = *(_DWORD *)(v9 - (*(_DWORD *)(v9 + 4) - 4)) + v9 - (*(_DWORD *)(v9 + 4) - 4) + 4;
        (unsigned int)v7 < i;
        v7 = (unsigned __int8 *)sub_6D9F4(v7, (int)v12, (int)v13, 0) )
  {
    ;
  }
  v8 = (unsigned __int8 *)(v9 + 16);
  if ( *(_BYTE *)v13[0] == 122 )
  {
    v4 = sub_6D320((char *)(v9 + 16), &v11);
    v8 = (unsigned __int8 *)&v4[v11];
  }
  v5 = *(_DWORD *)v9 + v9 + 4;
  v6 = *(_DWORD *)(v9 + 8);
  for ( j = v6; (unsigned int)v8 < v5 && j <= a1; v8 = (unsigned __int8 *)sub_6D9F4(v8, (int)v12, (int)v13, &j) )
    ;
  qmemcpy(a2, v12, 0x70u);
  return a2;
}

//----- (0006E0C4) --------------------------------------------------------
int __cdecl sub_6E0C4(int *a1, _DWORD *a2)
{
  unsigned int v2; // edx
  int result; // eax
  void *v4; // esp
  unsigned int v5; // esi
  unsigned int v6; // eax
  int v7; // edx
  int i; // esi
  int v9; // eax
  int v10; // [esp+0h] [ebp-28h] BYREF
  unsigned int v11; // [esp+14h] [ebp-14h]
  unsigned int v12; // [esp+18h] [ebp-10h]
  unsigned int v13; // [esp+1Ch] [ebp-Ch]
  int *v14; // [esp+20h] [ebp-8h]
  unsigned int v15; // [esp+24h] [ebp-4h]

  v2 = -1;
  v15 = a1[1];
  result = (((4 * v15) & 0x1FFFFFFF) + 15) & 0x3FFFFFF0;
  v4 = alloca(result);
  v14 = &v10;
  v13 = 0;
  if ( v15 )
  {
    do
    {
      v5 = v2;
      v11 = 4 * v13;
      v12 = v13 + 1;
      if ( v2 != -1 )
      {
        v6 = v13;
        v7 = *a1;
        while ( *(_DWORD *)(*(_DWORD *)(v7 + 4 * v6) + 8) - *(_DWORD *)(*(_DWORD *)(v7 + 4 * v5) + 8) < 0 )
        {
          *(_DWORD *)(*a2 + 4 * a2[1]++) = *(_DWORD *)(v7 + 4 * v5);
          *(_DWORD *)(*a1 + 4 * v5) = 0;
          v5 = v14[v5];
          if ( v5 == -1 )
            break;
          v7 = *a1;
          v6 = v13;
        }
      }
      v14[v11 / 4] = v5;
      v2 = v13;
      result = v12;
      v13 = v12;
    }
    while ( v12 < v15 );
  }
  v13 = 0;
  for ( i = 0; v13 < v15; ++v13 )
  {
    v9 = *(_DWORD *)(*a1 + 4 * v13);
    if ( v9 )
      *(_DWORD *)(*a1 + 4 * i++) = v9;
    result = v15;
  }
  a1[1] = i;
  return result;
}

//----- (0006E1C0) --------------------------------------------------------
void sub_6E1C0()
{
  ;
}

//----- (0006E1C4) --------------------------------------------------------
int sub_6E1C4()
{
  int (**v0)(void); // esi
  int result; // eax

  v0 = (int (**)(void))&dword_8DE34;
  if ( dword_8DE34 != -1 )
  {
    do
      result = (*v0--)();
    while ( *v0 != (int (*)(void))-1 );
  }
  return result;
}
// 8DE34: using guessed type int dword_8DE34;

//----- (0006E1F8) --------------------------------------------------------
void sub_6E1F8()
{
  ;
}

//----- (0006E228) --------------------------------------------------------
int term_proc()
{
  return sub_27734();
}

// nfuncs=1433 queued=1369 decompiled=1369 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 1369 function(s)"
