/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void (*init_proc())(void);
void sub_16764();
int GScr_AddFieldsForHudElems(void); // weak
_DWORD __cdecl trap_DObjCreateSkelForBones(_DWORD, _DWORD); // weak
int __cdecl G_SpawnFloat(char *s1, int, int); // idb
int G_Spawn(void); // weak
double __cdecl BG_GetMinSpreadForWeapon(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl BG_CalculateWeaponPosition_Sway(int, int, int, int, float, int); // idb
_DWORD __cdecl G_IsVehicleOccupantInvulnerable(_DWORD); // weak
_DWORD __cdecl Scr_AddFields(_DWORD, _DWORD); // weak
_DWORD __cdecl MatrixTransposeTransformVector43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl irand(_DWORD, _DWORD); // weak
_DWORD __cdecl GScr_GetHeadIconIndex(char); // weak
int G_SetUICvars(void); // weak
_DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl turret_think_client(_DWORD); // weak
_DWORD __cdecl G_EntLinkTo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetAmmoTypeMax(_DWORD); // weak
_DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD); // weak
_DWORD __cdecl Q_isalphanumeric(_DWORD); // weak
_DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int GScr_FreeScripts(void); // weak
// double cos(double x);
_DWORD __cdecl trap_XAnimSetCompleteGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
long double __cdecl vectoyaw(_DWORD); // weak
int PM_InteruptWeaponWithProneMove(void); // weak
_DWORD __cdecl ClientUserinfoChanged(_DWORD); // weak
_DWORD __cdecl weapon_grenadelauncher_fire(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetStackSlotForWeapon(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Error(_DWORD); // weak
_DWORD __cdecl MatrixInverseOrthogonal43(_DWORD, _DWORD); // weak
int PM_SetProneMovementOverride(void); // weak
_DWORD __cdecl BG_GetAmmoClipSize(_DWORD); // weak
_DWORD __cdecl ClientEvents(_DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjUpdateServerTime(_DWORD, _DWORD); // weak
int PM_UpdatePlayerWalkingFlag(void); // weak
int G_SetupScrVehicles(void); // weak
_DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_FlameDamageClient_f(_DWORD); // weak
_DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD); // weak
_DWORD __cdecl G_VehSetSwitchNode(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD); // weak
_DWORD __cdecl Weapon_Melee(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FarHook(_DWORD); // weak
_DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD); // weak
_DWORD __cdecl VEH_GetMinsMaxs(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnims(_DWORD); // weak
int BG_SetupAmmoIndexes(void); // weak
int PM_UpdatePlayerSprintingFlag(void); // weak
_DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD); // weak
_DWORD __cdecl Com_Parse(_DWORD); // weak
_DWORD __cdecl G_DObjGetLocalBoneIndexMatrix(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_MatchTimeout_f(_DWORD); // weak
_DWORD __cdecl G_EntDetachAll(_DWORD); // weak
// char *strncat(char *dest, const char *src, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
int __cdecl G_FreeEntity(void *s); // idb
_DWORD __cdecl Cmd_Where_f(_DWORD); // weak
_DWORD __cdecl Scr_FreeScripts(_DWORD); // weak
long double __cdecl vectopitch(_DWORD); // weak
int __cdecl BG_AnimationIndexForString(char *src); // idb
_DWORD __cdecl AxisToAngles(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjGetBounds(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_BackupSpawnVars(_DWORD); // weak
_DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerDisconnect(_DWORD); // weak
int ConsoleCommand(void); // weak
_DWORD __cdecl BG_IsProneAnim(_DWORD, _DWORD); // weak
int __cdecl Q_strncpyz(char *dest, char *src, int); // idb
_DWORD __cdecl PM_UpdateViewAngles(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetIString(_DWORD); // weak
int __cdecl G_EntAttach(int, char *s2, int, int); // idb
int __cdecl G_RadiusDamage(int, int, int, float, float, float, int, int); // idb
long double __cdecl Scr_Vehicle_DamageScale(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
double __cdecl BG_GetBobCycle(_DWORD); // weak
// double atan(double x);
_DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_DebugArc(int, float, float, float, int, int, int); // idb
_DWORD __cdecl BG_WeaponIsClipOnly(_DWORD); // weak
_DWORD __cdecl Respond_trigger_damage(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(_DWORD, __int16, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_Error(_DWORD); // weak
_DWORD __cdecl ClientInactivityTimer(_DWORD); // weak
int __cdecl trap_GetGuid(int a1);
_DWORD __cdecl Q_CleanStr(_DWORD); // weak
int __cdecl Scr_LocalizationError(int, char *format); // idb
_DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD); // weak
int CalculateRanks(void); // weak
_DWORD __cdecl PM_FootstepEvent(char, char, _DWORD); // weak
_DWORD __cdecl SP_trigger_mount_no_brush(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_CalcTagAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl G_TransposeMatrix(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_Score_f(_DWORD); // weak
int Scr_BeginLoadScripts(void); // weak
_DWORD __cdecl G_SetAngle(_DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjSetLocalBoneIndex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl VEH_PlayerDamage(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntityField(_DWORD, _DWORD); // weak
int Scr_RemoveClassMap(void); // weak
_DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl GScr_AddVector(_DWORD); // weak
_DWORD __cdecl BG_AnimUpdatePlayerStateConditions(_DWORD); // weak
int G_InitTurrets(void); // weak
int __cdecl Bullet_Fire(int, float, int, int, int); // idb
_DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_EntDetach(int, char *s2, int); // idb
_DWORD __cdecl InitMoverRotate(_DWORD); // weak
int CheckVote(void); // weak
_DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_GetEffectiveStance(_DWORD); // weak
_DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl VP_GetNodeIndex(unsigned __int16, float *); // idb
int __cdecl G_Say(int, int, int, char *src); // idb
_DWORD __cdecl BG_PlayerTouchesItem(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjCalcPose(_DWORD); // weak
_DWORD __cdecl tv(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_ClientStopUsingTurret(_DWORD); // weak
_DWORD __cdecl FireWeaponMelee(_DWORD); // weak
int __cdecl G_DPrintf(char *format, char); // idb
int __cdecl Com_Printf(char *format, char); // idb
int Scr_LoadLevel(void); // weak
_DWORD __cdecl PM_UpdateLean(_DWORD, _DWORD, _DWORD); // weak
int BG_LoadAnimTreeInstances(void); // weak
int __cdecl BG_LerpOffset(int, float, int); // idb
_DWORD __cdecl trap_GetServerinfo(_DWORD, _DWORD); // weak
int __cdecl G_ModelIndex(char *s2); // idb
_DWORD __cdecl BG_GetVehiclePosOffset(_DWORD, _DWORD); // weak
// int strcmp(const char *s1, const char *s2);
_DWORD __cdecl trap_SightTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int ExitLevel(void); // weak
_DWORD __cdecl PM_WeaponUseAmmo(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char); // weak
int __cdecl Info_RemoveKey(char *s, char *s1); // idb
_DWORD __cdecl VEH_SetupCollmap(_DWORD); // weak
_DWORD __cdecl Scr_PlayerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_IsCrouchingAnim(_DWORD, _DWORD); // weak
int PM_InteruptWeaponWithSprintMove(void); // weak
// double asin(double x);
_DWORD __cdecl DObjSkelMatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeHudElemConstStrings(_DWORD); // weak
int __cdecl Info_ValueForKey(char *s, int); // idb
int Scr_EndLoadAnimTrees(void); // weak
int GScr_AddFieldsForEntity(void); // weak
_DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD); // weak
_DWORD __cdecl InitSentientTrigger(_DWORD); // weak
_DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD); // weak
_DWORD __cdecl LaunchItem(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_GetHitLocationIndexFromString(_DWORD); // weak
_DWORD __cdecl Com_Parse1DMatrix(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_SetModel(int, char *s2); // idb
int Scr_AddUndefined(void); // weak
_DWORD __cdecl Q_CleanCharacter(_DWORD); // weak
int __cdecl G_SpawnVehicle(int, char *s1, int); // idb
_DWORD __cdecl trap_GetEntityToken(_DWORD, _DWORD); // weak
int __cdecl Info_Validate(char *s); // idb
_DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl MT_Free(_DWORD, _DWORD); // weak
_DWORD __cdecl G_IsVehicleImmune(_DWORD, _DWORD); // weak
int trap_AddTestClient(void); // weak
_DWORD __cdecl G_UpdateTagInfoOfChildren(_DWORD, _DWORD); // weak
int __cdecl G_RunMissile(void *s); // idb
_DWORD __cdecl trap_Printf(_DWORD); // weak
_DWORD __cdecl RegisterItem(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetType(_DWORD); // weak
_DWORD __cdecl Cmd_GameCommand_f(_DWORD); // weak
_DWORD __cdecl Cmd_CallVote_f(_DWORD); // weak
int BG_SetupWeaponInfo(void); // weak
_DWORD __cdecl G_CheckForCursorHints(_DWORD); // weak
// int __cdecl __cxa_finalize(void *);
_DWORD __cdecl trap_XAnimClearTreeGoalWeightsStrict(_DWORD, __int16, _DWORD); // weak
_DWORD __cdecl trap_GetClientPing(_DWORD); // weak
int __cdecl VectorAngleMultiply(int, float); // idb
_DWORD __cdecl IsItemRegistered(_DWORD); // weak
int Svcmd_RemoveIP_f(void); // weak
int GScr_LoadGameTypeScript(void); // weak
_DWORD __cdecl G_SetConstString(_DWORD, _DWORD); // weak
_DWORD __cdecl OnSameTeam(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntity(_DWORD); // weak
int BG_GetNumWeapons(void); // weak
_DWORD __cdecl Scr_FreeHudElem(_DWORD); // weak
int BG_FinalizePlayerAnims(void); // weak
int __cdecl AngleNormalize360Accurate(float); // idb
int __cdecl LerpAngle(float, int, float); // idb
_DWORD __cdecl G_DObjUpdate(_DWORD); // weak
int __cdecl Com_DPrintf(char *format, char); // idb
_DWORD __cdecl Cmd_UFO_f(_DWORD); // weak
_DWORD __cdecl SpectatorThink(_DWORD, _DWORD); // weak
int __cdecl Blocked_DoorRotate(int, void *s); // idb
int trap_Milliseconds(void); // weak
_DWORD __cdecl ClientThink_real(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl Scr_Vehicle_Touch(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Com_SkipPath(_DWORD); // weak
_DWORD __cdecl G_ModelName(_DWORD); // weak
_DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD); // weak
int __cdecl YawToAxis(float, int); // idb
_DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int CheckMatchTimeout(void); // weak
long double __cdecl VectorNormalize(_DWORD); // weak
_DWORD __cdecl Scr_AddConstString(_DWORD); // weak
int BG_FillInWeaponItems(void); // weak
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
_DWORD __cdecl Com_BitCheck(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl GScr_GetVehicleNodeIndex(_DWORD); // weak
_DWORD __cdecl trap_DObjExists(_DWORD); // weak
_DWORD __cdecl GScr_SetDynamicEntityField(_DWORD, _DWORD); // weak
_DWORD __cdecl QuatInverse(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int PM_UpdateAimDownSightFlag(void); // weak
int __cdecl BG_AnimParseError(char *format, char); // idb
_DWORD __cdecl G_FreeTurret(_DWORD); // weak
int DebugDumpAnims(void); // weak
_DWORD __cdecl BG_FindItem(_DWORD); // weak
_DWORD __cdecl Cmd_God_f(_DWORD); // weak
_DWORD __cdecl PM_WeaponClipEmpty(_DWORD); // weak
_DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl DObjSkel2MatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl IntermissionClientEndFrame(_DWORD); // weak
int G_UpdateHudElemsToClients(void); // weak
int G_CallSpawn(void); // weak
int __cdecl BG_GetHorizontalBobFactor(int, float, float, float); // idb
int __cdecl Cmd_TraceProfile_f(_DWORD); // weak
_DWORD __cdecl G_RunMover(_DWORD); // weak
_DWORD __cdecl HudElem_GetMethod(_DWORD); // weak
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
_DWORD __cdecl ClientSpectatorInactivityTimer(_DWORD); // weak
_DWORD __cdecl trap_XAnimCreateTree(_DWORD); // weak
_DWORD __cdecl trap_FS_FCloseFile(_DWORD); // weak
_DWORD __cdecl Cmd_Kill_f(_DWORD); // weak
_DWORD __cdecl Scr_FindField(_DWORD, _DWORD); // weak
_DWORD __cdecl StopFollowing(_DWORD); // weak
// double pow(double x, double y);
int SendScoreboardMessageToAllIntermissionClients(void); // weak
_DWORD __cdecl Scr_LoadScript(_DWORD); // weak
_DWORD __cdecl G_TryPushingEntity(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Cvar_Update(_DWORD); // weak
int __cdecl Com_ScriptWarning(char *format, char); // idb
_DWORD __cdecl Scr_GetVector(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_WeaponFireRecoil(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_isnumeric(_DWORD); // weak
_DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_VehInitPathPos(_DWORD); // weak
_DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetInfoForWeapon(_DWORD); // weak
_DWORD __cdecl Scr_GetDebugString(_DWORD); // weak
int G_ParseScrVehicleInfo(void); // weak
_DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD); // weak
int Scr_AddArray(void); // weak
_DWORD __cdecl vtos(_DWORD); // weak
_DWORD __cdecl G_VEH_FireGunner(_DWORD, _DWORD); // weak
int G_SetPlayerSize(void); // weak
// int tolower(int c);
_DWORD __cdecl Q_rand(_DWORD); // weak
_DWORD __cdecl SL_GetString(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_LinkEntity(_DWORD); // weak
_DWORD __cdecl G_SafeDObjFree(_DWORD); // weak
int __cdecl Weapon_Artillery_Fire(int, float, int); // idb
_DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_IsSystemActive(_DWORD); // weak
_DWORD __cdecl G_SpawnItem(_DWORD, _DWORD); // weak
_DWORD __cdecl Q_isalpha(_DWORD); // weak
int __cdecl BG_CheckProne(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float, int); // idb
_DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCreateSkelForBone(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl InitTrigger(_DWORD); // weak
_DWORD __cdecl Cmd_Killcam_f(_DWORD); // weak
int __cdecl G_SpawnVector(char *s1, int, int); // idb
_DWORD __cdecl VectorNormalize2D(_DWORD); // weak
int __cdecl G_ShaderIndex(char *s2); // idb
_DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl PM_ClipVelocity(int, int, int, float); // idb
int __cdecl Blocked_Door(int, void *s); // idb
_DWORD __cdecl Cmd_Give_f(_DWORD); // weak
int G_FindTeams(void); // weak
_DWORD __cdecl InSameSquad(_DWORD, _DWORD); // weak
_DWORD __cdecl ColorIndex(_DWORD); // weak
_DWORD __cdecl Cmd_MatchTimein_f(_DWORD); // weak
_DWORD __cdecl Scr_AddInt(_DWORD); // weak
_DWORD __cdecl G_Trigger(_DWORD, _DWORD); // weak
_DWORD __cdecl ClientDisconnect(_DWORD); // weak
int __cdecl G_ShellShockIndex(char *s2); // idb
_DWORD __cdecl trap_DObjInitServerTime(_DWORD, _DWORD); // weak
int SP_worldspawn(void); // weak
_DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetAnimsIndex(_DWORD); // weak
int __cdecl BG_CheckProneValid(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float, int, int); // idb
_DWORD __cdecl PM_AddEvent(_DWORD); // weak
_DWORD __cdecl G_VehUpdatePathPos(_DWORD, _DWORD); // weak
_DWORD __cdecl Pmove(_DWORD); // weak
_DWORD __cdecl MatchTeamReverseAngleOnSlaves(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl SL_FindLowercaseString(_DWORD); // weak
_DWORD __cdecl G_GetHitLocationString(_DWORD); // weak
_DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD); // weak
int PM_ClearAimDownSightFlag(void); // weak
_DWORD __cdecl Scr_NotifyNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_strncasecmp(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl VEH_PhysicsNotRequired(_DWORD, _DWORD); // weak
int PM_Weapon(void); // weak
_DWORD __cdecl G_AddPredictableEvent(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_SetViewpos_f(_DWORD); // weak
_DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD); // weak
int G_ParseSpawnVars(void); // weak
_DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XModelDebugBoxes(_DWORD); // weak
_DWORD __cdecl ClientThink(_DWORD); // weak
int G_ParseHitLocDmgTable(void); // weak
_DWORD __cdecl G_CheckFlameDamage(_DWORD); // weak
int __cdecl G_SpawnInt(char *s1, int, int); // idb
_DWORD __cdecl SP_info_vehicle_node(_DWORD); // weak
_DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl InitMover(_DWORD); // weak
_DWORD __cdecl trap_GetWeaponInfoMemory(_DWORD, _DWORD); // weak
int __cdecl AddLeanToPosition(int, int, float, float, float); // idb
int GScr_LoadScripts(void); // weak
int Com_EndParseSession(void); // weak
_DWORD __cdecl Cmd_NextVehSlot_f(_DWORD); // weak
_DWORD __cdecl Cmd_Noclip_f(_DWORD); // weak
int __cdecl G_DebugCircle(int, float, int, int, int, int); // idb
int __cdecl AngleDelta(float, float); // idb
int PM_UpdateFatigue(void); // weak
_DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_GetTankIndex(_DWORD); // weak
_DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_CalculateWeaponAngles(_DWORD, _DWORD); // weak
int __cdecl Weapon_RocketLauncher_Fire(int, float, int); // idb
_DWORD __cdecl G_DoTouchTriggers(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeEntity(_DWORD); // weak
_DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD); // weak
_DWORD __cdecl G_BounceMissile(_DWORD, _DWORD); // weak
_DWORD __cdecl G_GetGameId(_DWORD); // weak
int __cdecl Damage_Falloff(float, int, float, int, int); // idb
_DWORD __cdecl Rand_Init(_DWORD); // weak
long double __cdecl Scr_GetFloat(_DWORD); // weak
int PM_PlayFatigueSound(void); // weak
_DWORD __cdecl BG_CalculateViewAngles(_DWORD, _DWORD); // weak
int __cdecl va(char *format, char); // idb
_DWORD __cdecl Q_islower(_DWORD); // weak
_DWORD __cdecl G_CheckForPreventFriendlyFire(_DWORD); // weak
_DWORD __cdecl DirToByte(_DWORD); // weak
_DWORD __cdecl multi_trigger(_DWORD, _DWORD); // weak
int __cdecl G_LogPrintf(char *format, char); // idb
_DWORD __cdecl LookAtKiller(_DWORD, _DWORD, _DWORD); // weak
int GScr_AddFieldsForRadiant(void); // weak
_DWORD __cdecl Scr_AddFloat(_DWORD); // weak
_DWORD __cdecl trap_DropClient(_DWORD, _DWORD); // weak
int __cdecl G_SoundAliasIndex(char *s2); // idb
_DWORD __cdecl CheatsOk(_DWORD); // weak
_DWORD __cdecl Scr_GetBool(_DWORD); // weak
long double __cdecl trap_XAnimGetWeight(_DWORD, __int16); // weak
long double __cdecl G_VehicleOccupantRadiusDamageScale(_DWORD); // weak
_DWORD __cdecl Scr_ShutdownSystem(_DWORD); // weak
_DWORD __cdecl G_RunThink(_DWORD); // weak
int G_FreeEntities(void); // weak
_DWORD __cdecl gunrandom(_DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileImpact(_DWORD, _DWORD); // weak
_DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetEntityField(_DWORD, _DWORD); // weak
int CheckTeamStatus(void); // weak
_DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD); // weak
double __cdecl vectosignedyaw(_DWORD); // weak
_DWORD __cdecl Scr_ParamError(_DWORD, _DWORD); // weak
int __cdecl flrand(float, float); // idb
_DWORD __cdecl BG_ParseCommands(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl TeamplayInfoMessage(_DWORD); // weak
_DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD); // weak
int __cdecl Q_strcat(char *s, int, char *src); // idb
_DWORD __cdecl SL_ConvertToString(_DWORD); // weak
_DWORD __cdecl Scr_GetInt(_DWORD); // weak
_DWORD __cdecl Scr_GetPointerType(_DWORD); // weak
int __cdecl G_EffectIndex(char *s2); // idb
int __cdecl BG_Bullet_Endpos(float, int, int); // idb
int Svcmd_AddIP_f(void); // weak
_DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_AddSpawnVarToken(char *s); // idb
_DWORD __cdecl G_FreeVehicle(_DWORD); // weak
int Scr_ParseGameTypeList(void); // weak
int __cdecl AngleSubtract(float, float); // idb
_DWORD __cdecl Scr_SetClassMap(_DWORD, _DWORD); // weak
_DWORD __cdecl G_InitGentity(_DWORD); // weak
_DWORD __cdecl trap_UnlinkEntity(_DWORD); // weak
int G_SetupVehiclePaths(void); // weak
_DWORD __cdecl PmoveSingle(_DWORD); // weak
int trap_Argc(void); // weak
_DWORD __cdecl VEH_InitPhysics(_DWORD); // weak
_DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetDynamicEntityField(_DWORD, _DWORD, _DWORD); // weak
int G_FreeScrVehicles(void); // weak
_DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD); // weak
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
int ClearRegisteredItems(void); // weak
_DWORD __cdecl Axis4ToAngles(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_IsLocalClient(_DWORD); // weak
_DWORD __cdecl G_CreateRotationMatrix(_DWORD, _DWORD); // weak
_DWORD __stdcall Scr_FindAnimTree(_DWORD); // weak
_DWORD __cdecl trap_GetConfigstringConst(_DWORD); // weak
_DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntityId(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_ObjectError(_DWORD); // weak
_DWORD __cdecl BG_GetVehiclePosTag(_DWORD); // weak
_DWORD __cdecl MatrixTranspose(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SetBrushModel(_DWORD); // weak
_DWORD __cdecl trap_DObjUpdateServerTime(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Com_MatchToken(int, char *s2, int); // idb
_DWORD __cdecl trap_XAnimSetAnimRate(_DWORD, __int16, _DWORD); // weak
_DWORD __cdecl Cmd_Notarget_f(_DWORD); // weak
_DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl PM_SlideMove(_DWORD); // weak
_DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD); // weak
_DWORD __cdecl G_AddLean(_DWORD, _DWORD); // weak
int __cdecl Drop_Item(int, int, float, int); // idb
int __cdecl Q_acos(float); // idb
_DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD); // weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
_DWORD __cdecl G_IsPlaying(_DWORD); // weak
int __cdecl PitchToQuaternion(float, int); // idb
int __cdecl G_NewString(char *s); // idb
// double atof(const char *nptr);
// double atan2(double y, double x);
_DWORD __cdecl Scr_GetClientField(_DWORD, _DWORD); // weak
_DWORD __cdecl G_VehSetUpPathPos(_DWORD, _DWORD); // weak
_DWORD __cdecl IsBinaryMoverBlocked(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl PASSFLOAT(_DWORD); // weak
_DWORD __cdecl G_DamageClient(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_SetClientContents(_DWORD); // weak
_DWORD __cdecl trap_Hunk_AllocAlignInternal(_DWORD, _DWORD); // weak
int __cdecl Com_sprintf(char *s, size_t maxlen, char *format, char); // idb
int __cdecl BG_GetWeaponSlotForName(char *s1); // idb
_DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD); // weak
int BG_FindAnimTrees(void); // weak
int G_UpdateObjectiveToClients(void); // weak
_DWORD __cdecl G_XAnimUpdateEnt(_DWORD); // weak
_DWORD __cdecl VectorInverse(_DWORD); // weak
int __cdecl G_RunItem(void *s); // idb
_DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl fire_artillery(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntityContactCapsule(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_IsValidGameType(_DWORD); // weak
int G_InitVehiclePaths(void); // weak
_DWORD __cdecl G_RunFrame(_DWORD); // weak
int G_UpdateCvars(void); // weak
int __cdecl G_InitGame(int, unsigned int seed, int, int); // idb
_DWORD __cdecl GScr_GetStatusIconIndex(char); // weak
_DWORD __cdecl trap_DObjGetRotTransArray(_DWORD); // weak
_DWORD __cdecl ClientBegin(_DWORD); // weak
// int strncmp(const char *s1, const char *s2, size_t n);
int BG_SetupSharedAmmoIndexes(void); // weak
_DWORD __cdecl StuckInClient(_DWORD); // weak
_DWORD __cdecl G_MoverTeam(_DWORD); // weak
_DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_GetActivateEnt(int, void *base); // idb
_DWORD __cdecl G_FreeEntityRefs(_DWORD); // weak
_DWORD __cdecl trap_InPVS(_DWORD, _DWORD); // weak
// double floor(double x);
double __cdecl CanDamage(_DWORD, _DWORD); // weak
_DWORD __cdecl G_IsVehicleUsable(_DWORD, _DWORD); // weak
int G_ProcessIPBans(void); // weak
_DWORD __cdecl trap_DObjGetMatrixArray(_DWORD); // weak
_DWORD __cdecl G_RotatePoint(_DWORD, _DWORD); // weak
int Scr_RunCurrentThreads(void); // weak
_DWORD __cdecl trap_MapExists(_DWORD); // weak
_DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimIsLooped(_DWORD); // weak
_DWORD __cdecl SanitizeString(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnimName(_DWORD); // weak
_DWORD __cdecl GScr_AddEntity(_DWORD); // weak
_DWORD __cdecl G_TouchTriggers(_DWORD); // weak
_DWORD __cdecl trap_XModelNumBones(_DWORD); // weak
_DWORD __cdecl BG_UpdatePlayerDObj(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Com_BitClear(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD); // weak
int __cdecl GetLeanFraction(float); // idb
_DWORD __cdecl trap_XAnimGetNumChildren(_DWORD); // weak
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
_DWORD __cdecl Scr_SetLoading(_DWORD); // weak
int sub_1869F(); // weak
_DWORD __cdecl G_GeneralLink(_DWORD); // weak
_DWORD __cdecl BG_ClipForWeapon(_DWORD); // weak
_DWORD __cdecl ClientConnect(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimClearGoalWeight(_DWORD, __int16, _DWORD); // weak
int G_SpawnSoundBlend(void); // weak
_DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD); // weak
int G_InitObjectives(void); // weak
_DWORD __cdecl trap_XModelGet(_DWORD); // weak
_DWORD __cdecl SpectatorClientEndFrame(_DWORD); // weak
_DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl Team_GetLocationMsg(int, char *s, size_t maxlen); // idb
_DWORD __cdecl PM_AddTouchEnt(_DWORD); // weak
_DWORD __cdecl Scr_FreeEntityConstStrings(_DWORD); // weak
_DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD); // weak
// int toupper(int c);
_DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl vectosignedangles(_DWORD, _DWORD); // weak
_DWORD __cdecl RespawnItem(_DWORD); // weak
_DWORD __cdecl G_VehFreePathPos(_DWORD); // weak
_DWORD __cdecl ClientCommand(_DWORD); // weak
_DWORD __cdecl infront(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD); // weak
int BG_InitWeaponStrings(void); // weak
// char *strcat(char *dest, const char *src);
int PM_UpdatePronePitch(void); // weak
_DWORD __cdecl SetClientOrigin(_DWORD, _DWORD); // weak
int __cdecl G_GetHintStringIndex(int, char *s1); // idb
_DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD); // weak
_DWORD __cdecl VEH_PlayerCollision(_DWORD, _DWORD); // weak
_DWORD __cdecl fire_rocket(_DWORD, _DWORD, _DWORD); // weak
// double tan(double x);
int Svcmd_EntityList_f(void); // weak
_DWORD __cdecl trap_AddDebugString(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_TryDoor(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_InSnapshot(_DWORD, _DWORD); // weak
int BG_FindAnims(void); // weak
_DWORD __cdecl G_UpdateVehicleTags(_DWORD); // weak
int __cdecl Info_RemoveKey_Big(char *s, char *s1); // idb
_DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int SaveRegisteredItems(void); // weak
_DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_setfog(char *s); // idb
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
long double __cdecl VectorNormalize2(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddString(_DWORD); // weak
_DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerConnect(_DWORD); // weak
_DWORD __cdecl GScr_GetVehicleNodeField(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetClientField(_DWORD, _DWORD); // weak
_DWORD __cdecl G_SetClientSound(_DWORD); // weak
_DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetWeaponSlotNameForIndex(_DWORD); // weak
_DWORD __cdecl ConcatArgs(_DWORD); // weak
int __cdecl G_FindConfigstringIndex(char *s2, int, int, int, char); // idb
_DWORD __cdecl BG_GetSharedAmmoCapSize(_DWORD); // weak
_DWORD __cdecl G_ShutdownGame(_DWORD); // weak
_DWORD __cdecl trap_SetArchive(_DWORD); // weak
_DWORD __cdecl GetFollowPlayerState(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PrecacheAnimTrees(_DWORD); // weak
int trap_FreeClientScriptPers(void); // weak
_DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl GScr_AddFieldsForClient(_DWORD); // weak
_DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int G_VehicleClientThink(void); // weak
int Swap_Init(void); // weak
_DWORD __cdecl Q_strncmp(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_stricmp(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetHudElemField(_DWORD, _DWORD); // weak
int __cdecl G_SpawnString(char *s1, int, int); // idb
_DWORD __cdecl Scr_GetString(_DWORD); // weak
_DWORD __cdecl G_GrenadeTouchTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimNotetrackExists(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl ClientIntermissionThink(_DWORD); // weak
_DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char); // weak
_DWORD __cdecl G_DObjSetLocalTag(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_PlayerAnimation(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD); // weak
double __cdecl vectosignedpitch(_DWORD); // weak
_DWORD __cdecl BG_GetWeaponForInfo(_DWORD); // weak
_DWORD __cdecl Scr_AddArrayStringIndexed(_DWORD); // weak
_DWORD __stdcall Scr_GetAnim(_DWORD); // weak
_DWORD __cdecl Scr_GetFunctionHandle(_DWORD, _DWORD); // weak
// void srand(unsigned int seed);
_DWORD __cdecl trap_Error_Localized(_DWORD); // weak
_DWORD __cdecl DoorSetSounds(_DWORD); // weak
_DWORD __cdecl SP_sound_blend(_DWORD); // weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
int BG_SetupClipIndexes(void); // weak
double __cdecl Q_random(_DWORD); // weak
_DWORD __cdecl HudElem_ClientDisconnect(_DWORD); // weak
_DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD); // weak
_DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD); // weak
double __cdecl VectorDistanceSquared(_DWORD, _DWORD); // weak
int __cdecl G_TagIndex(char *s2); // idb
_DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD); // weak
double __cdecl RadiusFromBounds(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddVector(_DWORD); // weak
int G_XAnimUpdate(void); // weak
_DWORD __stdcall trap_XAnimGetChildAt(_DWORD); // weak
_DWORD __cdecl G_CheckPointInsideTriggerMount(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD); // weak
_DWORD __cdecl G_SetMovedir(_DWORD, _DWORD); // weak
_DWORD __cdecl SnapVectorTowards(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnimTreeSize(_DWORD); // weak
int G_SpawnPlayerClone(void); // weak
int Com_GetCurrentParseLine(void); // weak
_DWORD __cdecl G_RunClient(_DWORD); // weak
int Scr_AllocGameVariable(void); // weak
_DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD); // weak
long double __cdecl BG_GetSpeed(_DWORD, _DWORD); // weak
double __cdecl QuatEigenTrace(_DWORD); // weak
// int strcasecmp(const char *s1, const char *s2);
_DWORD __cdecl Scr_AddBool(_DWORD); // weak
_DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_UpdateClientInfo(_DWORD); // weak
_DWORD __cdecl Scr_SetTime(_DWORD); // weak
int __cdecl RollToQuaternion(float, int); // idb
_DWORD __cdecl Scr_SetString(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_PrevVehSlot_f(_DWORD); // weak
int __cdecl Com_ScriptError(char *format, char); // idb
_DWORD __cdecl trap_XAnimCalcAbsDelta(_DWORD, __int16, _DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Weapon_ArtilleryStrike_Fire(int, float, int); // idb
// int atoi(const char *nptr);
int __cdecl Com_BeginParseSession(char *src); // idb
int G_SpawnGEntityFromSpawnVars(void); // weak
_DWORD __cdecl Scr_GetHudElemField(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddEntity(_DWORD); // weak
_DWORD __cdecl Cmd_Take_f(_DWORD); // weak
_DWORD __cdecl PM_VerifyPronePosition(_DWORD, _DWORD); // weak
_DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Q_rsqrt(float); // idb
_DWORD __cdecl BG_AnimScriptAnimation(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Player_GetMethod(_DWORD); // weak
_DWORD __cdecl G_UpdateTagInfo(_DWORD, _DWORD); // weak
_DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int HudElem_DestroyAll(void); // weak
_DWORD __cdecl GScr_GetScriptMenuIndex(char); // weak
int __cdecl BG_CopyStringIntoBuffer(char *s, int, int, int); // idb
_DWORD __cdecl VEH_FindValidDismountSpot(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_Player_DoControllers(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// int sscanf(const char *s, const char *format, ...);
_DWORD __cdecl G_PlayerVehiclePositionAndBlend(_DWORD); // weak
long double __cdecl VectorDistance(_DWORD, _DWORD); // weak
int G_FreeVehiclePaths(void); // weak
double __cdecl RotationToYaw(_DWORD); // weak
int PM_AdjustAimSpreadScale(void); // weak
_DWORD __cdecl trap_DObjDumpInfo(_DWORD); // weak
_DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddHudElem(_DWORD); // weak
int __cdecl YawVectors(float, int, int); // idb
int __cdecl AngleNormalize360(float); // idb
int Scr_GetNumParam(void); // weak
_DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl Info_SetValueForKey(char *s, char *s1, int); // idb
// double acos(double x);
// void *memset(void *s, int c, size_t n);
_DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD); // weak
_DWORD __cdecl G_TempEntity(_DWORD, _DWORD); // weak
int __cdecl BG_GetVerticalBobFactor(int, float, float, float); // idb
int __cdecl Q_GetDecimalDelimiter(_DWORD); // weak
int __cdecl PitchForYawOnNormal(float, int); // idb
_DWORD __cdecl AnglesToAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl VEH_GroundFriction(_DWORD); // weak
_DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl DeathmatchScoreboardMessage(_DWORD); // weak
long double __cdecl trap_Cvar_VariableValue(_DWORD); // weak
int GScr_LoadConsts(void); // weak
_DWORD __cdecl G_BounceItem(_DWORD, _DWORD); // weak
int __cdecl Com_Error(int, char *format, char); // idb
_DWORD __cdecl fire_artillery_barrage(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD); // weak
int Scr_StartupGameType(void); // weak
_DWORD __cdecl Scr_GetConstString(_DWORD); // weak
_DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_SurfaceTypeToName(_DWORD); // weak
_DWORD __cdecl InitScriptMover(_DWORD); // weak
_DWORD __cdecl Door_reverse_sounds(_DWORD); // weak
long double __cdecl trap_XAnimGetTime(_DWORD, __int16); // weak
long double __cdecl trap_XAnimGetLengthSeconds(_DWORD); // weak
_DWORD __cdecl HudElem_Free(_DWORD); // weak
_DWORD __cdecl Scr_InitSystem(_DWORD, _DWORD); // weak
// char *strncpy(char *dest, const char *src, size_t n);
_DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjSetControlRotTransIndex(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_FreeVehicleRefs(_DWORD); // weak
_DWORD __cdecl Cmd_MenuResponse_f(_DWORD); // weak
int __cdecl AngleNormalize180Accurate(float); // idb
_DWORD __cdecl G_UpdateTags(_DWORD, _DWORD); // weak
_DWORD __cdecl G_IndexForMeansOfDeath(char); // weak
_DWORD __cdecl VectorRotateAngles(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileLandAngles(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_Printf(char *format, char); // idb
_DWORD __cdecl trap_DObjSetRotTransIndex(_DWORD, _DWORD, _DWORD); // weak
int Scr_LoadGameType(void); // weak
int G_SpawnEntitiesFromString(void); // weak
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl G_DebugCircleEx(int, float, int, int, int, int); // idb
_DWORD __cdecl ClientImpacts(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddObject(_DWORD); // weak
_DWORD __cdecl Scr_AllocString(_DWORD, _DWORD); // weak
_DWORD __cdecl MT_Alloc(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD); // weak
_DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD); // weak
_DWORD __cdecl FireWeapon(_DWORD); // weak
_DWORD __cdecl BG_AmmoForWeapon(_DWORD); // weak
_DWORD __cdecl GScr_AllocString(_DWORD); // weak
_DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD); // weak
_DWORD __cdecl Fill_Clip(_DWORD, _DWORD); // weak
_DWORD __cdecl VEH_SlideMove(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_StepSlideMove(_DWORD); // weak
_DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Pickup_Health(_DWORD, _DWORD); // weak
_DWORD __cdecl G_SetSoundBlend(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetWeaponIndexForName(char); // weak
int G_RegisterCvars(void); // weak
_DWORD __cdecl Cmd_Activate_f(_DWORD); // weak
_DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl RotatePointAroundVector(int, int, int, float); // idb
int PM_ShouldMakeFootsteps(void); // weak
_DWORD __cdecl trap_XModelGetBoneNames(_DWORD); // weak
int Scr_MakeArray(void); // weak
_DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FreeWeaponInfoMemory(_DWORD); // weak
int G_InitScrVehicles(void); // weak
_DWORD __cdecl G_SpawnTurret(_DWORD, char); // weak
_DWORD __cdecl trap_XAnimIsPrimitive(_DWORD); // weak
_DWORD __cdecl ScriptEnt_GetMethod(_DWORD); // weak
_DWORD __cdecl G_EntUnlink(_DWORD); // weak
int G_IsInMatchTimeout(void); // weak
// int sprintf(char *s, const char *format, ...);
int __cdecl ParseConfigStringToStruct(int, int, int, char *s, int, int, int); // idb
_DWORD __cdecl trap_XAnimSetTime(_DWORD, __int16, _DWORD); // weak
int __cdecl G_Error(char *format, char); // idb
_DWORD __cdecl trap_XAnimSetGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_Write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl UnGetLeanFraction(float); // idb
_DWORD __cdecl G_GetNonPVSFriendlyInfo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl vectoangles(_DWORD, _DWORD); // weak
_DWORD __cdecl ScriptVehicle_GetMethod(_DWORD); // weak
_DWORD __cdecl Scr_CopyEntityNum(_DWORD, _DWORD, _DWORD); // weak
// double sin(double x);
_DWORD __cdecl Com_ParseOnLine(_DWORD); // weak
_DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD); // weak
int __cdecl Cmd_EntityCount_f(_DWORD); // weak
_DWORD __cdecl Com_Parse2DMatrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int Com_UngetToken(void); // weak
// int __cdecl _Jv_RegisterClasses(_DWORD); weak
_DWORD __cdecl G_IsVehicleUnusable(_DWORD); // weak
int PM_LadderMove(void); // weak
// double modf(double x, double *iptr);
int __cdecl AngleMod(float); // idb
_DWORD __cdecl trap_DObjDisplayAnim(_DWORD); // weak
_DWORD __cdecl G_VEH_CycleSlot(_DWORD, _DWORD); // weak
_DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeThread(_DWORD); // weak
_DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_SetPlayerWeaponForSlot(_DWORD, _DWORD, _DWORD); // weak
// int rand(void);
_DWORD __cdecl P_DamageFeedback(_DWORD); // weak
_DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjGetHierarchyBits(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerKilled(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int Scr_EndLoadScripts(void); // weak
_DWORD __cdecl ClientEndFrame(_DWORD); // weak
_DWORD __cdecl Scr_MakeGameMessage(_DWORD, char); // weak
_DWORD __cdecl G_CallSpawnEntity(_DWORD); // weak
_DWORD __cdecl Com_BitSet(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeGameVariable(_DWORD); // weak
_DWORD __cdecl PerpendicularVector(_DWORD, _DWORD); // weak
_DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD); // weak
_DWORD __cdecl Team_GetLocation(_DWORD); // weak
_DWORD __cdecl trap_SnapVector(_DWORD); // weak
int __cdecl AngleNormalize180(float); // idb
_DWORD __cdecl Cmd_Vote_f(_DWORD); // weak
_DWORD __cdecl G_GetNonPVSTankInfo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_SetOrigin(_DWORD, _DWORD); // weak
// int __gmon_start__(void); weak
int __cdecl YawToQuaternion(float, int); // idb
// double ceil(double x);
int PM_UpdateAimDownSightLerp(void); // weak
// char *strcpy(char *dest, const char *src);
_DWORD __cdecl Scr_ExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_strlwr(_DWORD); // weak
int start();
void *sub_199B0();
void sub_19A26();
int __cdecl sub_19A2C(int a1);
int BG_AnimParseError(char *format, ...);
int __cdecl BG_AnimationIndexForString(char *src); // idb
int __cdecl BG_AnimationForString(int a1);
int __cdecl BG_IndexForString(int a1, int *a2, int a3);
char *__cdecl BG_CopyStringIntoBuffer(char *s, int a2, int a3, int a4);
int BG_InitWeaponStrings();
unsigned __int16 *__cdecl sub_19F5B(unsigned int a1);
int __cdecl sub_19FFA(int a1);
int BG_FinalizePlayerAnims();
void *__cdecl sub_1A41E(int a1, int a2, int a3, void *s);
int __cdecl sub_1A7D0(int a1, _DWORD *a2);
size_t __cdecl BG_ParseCommands(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl BG_AnimParseAnimScript(int a1, int a2, int a3);
int __cdecl sub_1BE6C(int a1, _DWORD *a2);
_DWORD *__cdecl sub_1BF35(int a1, _DWORD *a2);
int __cdecl BG_PlayAnim(_DWORD *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7);
int __cdecl BG_PlayAnimName(int, char *src, int, int, int, int); // idb
int __cdecl BG_ExecuteCommand(int a1, __int16 *a2, int a3, int a4, int a5);
int __cdecl BG_AnimScriptAnimation(int a1, int a2, int a3, int a4);
int __cdecl BG_AnimScriptStateChange(int a1, int a2, int a3);
int __cdecl BG_AnimScriptEvent(int a1, int a2, int a3, int a4);
int __cdecl BG_GetAnimString(int a1, unsigned int a2);
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_1C7CE(int a1, int a2, int a3);
int __cdecl BG_GetAnimScriptEvent(int a1, int a2);
int __cdecl BG_GetAnimationForIndex(int a1, unsigned int a2);
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1);
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, int a2);
_BOOL4 __cdecl BG_IsProneAnim(int a1, int a2);
_DWORD *__cdecl sub_1CE5F(int *a1, int *a2, int a3, int a4);
unsigned int __cdecl sub_1D56D(int *a1, unsigned int a2, int a3, int a4);
void __cdecl sub_1D922(int a1, _DWORD *a2);
// void __usercall sub_1D9B4(long double a1@<st0>, float a2, float a3, float a4, float a5, int a6, int a7);
// void __usercall sub_1DBAC(long double a1@<st0>, _DWORD *a2, int a3);
int __cdecl sub_1E194(_DWORD *a1, int a2);
int sub_1E6EC();
int __cdecl sub_1E6F6(int a1);
int __cdecl sub_1E719(int a1, unsigned __int16 a2, int a3, int a4);
// int __usercall sub_1E761@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6);
int *__cdecl sub_1F107(int a1, float a2, int a3);
void __cdecl BG_LerpOffset(int a1, float a2, int a3);
// int __usercall BG_Player_DoControllers@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5);
// unsigned int __usercall BG_PlayerAnimation@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int *a4);
_BYTE *__cdecl BG_UpdatePlayerDObj(int a1, int *a2, int a3, _BYTE *a4);
int BG_FindAnims();
// _DWORD *__userpurge sub_1F8E8@<eax>(_DWORD *a1, char a2, int a3);
int BG_FindAnimTrees();
int *BG_LoadAnimTreeInstances();
float *__cdecl sub_1FA4D(float a1, float *a2, float *a3);
void sub_1FA65();
char *__cdecl BG_FindItemForWeapon(int a1);
char *__cdecl BG_FindItem(int a1);
_BOOL4 __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3);
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3);
int __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3);
int __cdecl BG_EvaluateTrajectoryDelta(float *a1, int a2, float *a3);
int __cdecl BG_GetMarkDir(_DWORD *a1, float *a2, float *a3);
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3);
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3);
int __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4);
int __cdecl BG_CheckProneValid(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float, int, int); // idb
int __cdecl BG_CheckProne(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float, int); // idb
int __cdecl BG_GetVehiclePosTag(int a1);
void *__cdecl BG_GetVehiclePosOffset(int a1, int a2);
_BOOL4 __cdecl BG_AllowPlayerWeaponAtVehiclePos(int a1, int a2);
void sub_2316F();
int __cdecl PM_trace(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl PM_AddEvent(int a1);
int __cdecl PM_AddTouchEnt(int a1);
void __cdecl PM_ClipVelocity(int a1, int a2, int a3, float a4);
int __cdecl PM_GetEffectiveStance(_DWORD *a1);
long double sub_2342D();
long double sub_2348E();
float *sub_234EF();
void __cdecl sub_2379E(int a1, float a2, float a3);
long double __cdecl sub_23905(char *a1);
long double __cdecl sub_23AF5(_BYTE *a1);
// int __usercall sub_23F62@<eax>(long double a1@<st0>);
int sub_242B2();
int sub_24328();
int __cdecl sub_24380(float); // idb
int sub_24483();
int sub_24838();
int sub_249CC();
int sub_24B7C();
float *sub_25246();
int sub_2538B();
int sub_256ED();
int __cdecl sub_25B9B(int a1);
int sub_25C34();
int sub_25C5F();
int sub_25C88();
int sub_25C9E();
void sub_25CB4();
int __cdecl sub_262B7(int a1);
float *sub_2656D();
float *sub_26823();
int sub_26CF1();
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3);
long double __cdecl sub_26F47(int a1, int a2, float *a3);
long double __cdecl sub_2706E(int a1, int a2);
void sub_271F8();
void sub_27E16();
char __cdecl PM_FootstepEvent(char a1, char a2, int a3);
_BOOL4 PM_ShouldMakeFootsteps();
void sub_297E4();
int sub_2A550();
float *sub_2A7B9();
int sub_2A829();
int PM_PlayFatigueSound();
void PM_UpdateFatigue();
void __cdecl PM_UpdateLean(int a1, int a2, void (__cdecl *a3)(float *, int *, int *, int *, int *, _DWORD, int));
// int __usercall sub_2B031@<eax>(long double a1@<st0>, int a2, float a3, int a4);
// int __usercall PM_UpdateViewAngles@<eax>(long double a1@<st0>, int a2, int a3, int a4);
// void __usercall PM_UpdatePronePitch(long double a1@<st0>);
int PM_SetProneMovementOverride();
char PM_UpdatePlayerWalkingFlag();
void PM_UpdatePlayerSprintingFlag();
void sub_2C9A6();
int PM_LadderMove();
void __cdecl PmoveSingle(int a1);
_DWORD *__cdecl Pmove(int a1);
long double __cdecl BG_GetSpeed(int a1, int a2);
long double __cdecl sub_2E342(float a1);
int __cdecl sub_2E35B(float); // idb
_BOOL4 __cdecl sub_2E381(float a1);
void sub_2E3A9();
int __cdecl PM_VerifyPronePosition(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl PM_SlideMove(int a1);
void __cdecl PM_StepSlideMove(int a1);
int __cdecl sub_300A5(float); // idb
long double __cdecl sub_300E3(float a1);
void sub_300FC();
int __cdecl BG_GetWeaponTypeName(int a1);
int __cdecl BG_Bullet_Endpos(float, int, int); // idb
int __cdecl sub_30263(int a1, char *s1, int a3);
char *__cdecl sub_30610(int a1, char *s);
char *__cdecl sub_30676(int a1, char *s);
_DWORD *__cdecl sub_30690(int a1, int a2, int a3);
int __cdecl sub_3073B(int a1, int a2);
int sub_30AB4();
int BG_FillInWeaponItems();
int BG_SetupAmmoIndexes();
int BG_SetupSharedAmmoIndexes();
int BG_SetupClipIndexes();
int sub_3138E();
int sub_315C3();
int __cdecl compare_weaponfile_names(_DWORD *a1, _DWORD *a2);
int BG_SetupWeaponInfo();
int __cdecl BG_GetInfoForWeapon(int a1);
int __cdecl BG_GetWeaponForInfo(int a1);
int BG_GetNumWeapons();
int BG_GetNumAmmoTypes();
int __cdecl BG_GetAmmoTypeMax(int a1);
int BG_GetNumAmmoClips();
int __cdecl BG_GetAmmoClipSize(int a1);
int __cdecl BG_GetSharedAmmoCapSize(int a1);
int __cdecl BG_GetAmmoTypeName(int a1);
int __cdecl BG_GetAmmoClipName(int a1);
int __cdecl BG_GetAmmoTypeForName(int a1);
int __cdecl BG_GetAmmoClipForName(int a1);
int __cdecl BG_GetWeaponSlotForName(char *s1); // idb
int __cdecl BG_GetWeaponSlotNameForIndex(int a1);
int __cdecl BG_GetWeaponIndexForName(int a1);
int __cdecl BG_IsAimDownSightWeapon(int a1);
int __cdecl BG_GivePlayerWeapon(int a1, int a2);
int __cdecl BG_TakePlayerWeapon(int a1, int a2);
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3);
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3);
int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2);
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3);
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2);
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2);
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2);
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3, int a4);
int PM_UpdateAimDownSightFlag();
unsigned int PM_ClearAimDownSightFlag();
void PM_UpdateAimDownSightLerp();
int PM_InteruptWeaponWithProneMove();
int PM_InteruptWeaponWithSprintMove();
int __cdecl BG_ClipForWeapon(int a1);
int __cdecl BG_AmmoForWeapon(int a1);
int __cdecl BG_WeaponIsClipOnly(int a1);
int __cdecl BG_WeaponAmmo(int a1, int a2);
int sub_33C78();
int __cdecl PM_WeaponUseAmmo(int a1, int a2);
int __cdecl PM_WeaponAmmoAvailable(int a1);
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1);
int __cdecl sub_33F9C(int a1);
unsigned int __cdecl sub_34024(int a1);
int sub_34073();
int __cdecl sub_340AB(int a1);
int sub_34320();
int sub_3454B();
int sub_34659();
int sub_347AA();
int sub_3484C();
void __cdecl sub_348EE(int a1, int a2);
int sub_34C14();
int sub_35064();
int sub_350C2();
int sub_35120();
int sub_3517E();
int sub_352D2();
int __cdecl sub_35564(int a1);
void sub_358B2();
void sub_35B66();
int sub_35CE8();
void PM_AdjustAimSpreadScale();
int sub_360FA();
void sub_362EA();
int __cdecl sub_366B2(int a1);
int __cdecl sub_3679B(int a1);
int sub_36997();
int sub_369A1();
int sub_36ACC();
void sub_36B6A();
void __cdecl sub_36C0E(int a1);
int sub_36E91();
int sub_36F38();
char __cdecl sub_36FB7(int a1);
void PM_Weapon();
int sub_377CC();
int sub_3793A();
long double __cdecl BG_GetBobCycle(int a1);
long double __cdecl BG_GetVerticalBobFactor(int a1, float a2, float a3, float a4);
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4);
void __cdecl sub_37CFB(float *a1, float *a2);
void __cdecl sub_381E9(float *a1, float *a2);
float *__cdecl sub_38264(float *a1, float *a2);
float *__cdecl sub_38498(float *a1, float *a2);
void __cdecl sub_38687(float *a1, float *a2);
int __cdecl sub_388A0(int, int, float, float, float, float, float, float); // idb
float *__cdecl sub_38AC6(float *a1, float *a2);
int __cdecl BG_CalculateWeaponAngles(float *a1, int a2);
void __cdecl sub_38E76(float *a1, float *a2);
void __cdecl sub_39062(float *a1, float *a2);
void __cdecl BG_CalculateViewAngles(float *a1, int a2);
long double __cdecl sub_39236(float a1, float a2, float a3, int a4);
int __cdecl BG_CalculateWeaponPosition_Sway(int, int, int, int, float, int); // idb
float *__cdecl BG_WeaponFireRecoil(int a1, float *a2, int a3);
void sub_3995C();
int __cdecl Q_rand(int a1);
long double __cdecl Q_random(int a1);
long double __cdecl Q_crandom(int a1);
float *__cdecl gunrandom(float *a1, float *a2);
long double __cdecl Q_rsqrt(float a1);
int __cdecl Q_log2(int a1);
long double __cdecl Q_acos(float a1);
int __cdecl ClampChar(int a1);
int __cdecl ClampShort(int a1);
int __cdecl DirToByte(float *a1);
int __cdecl ByteToDir(int a1, int a2);
long double __cdecl DotProduct(float *a1, float *a2);
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3);
float *__cdecl VectorAdd(float *a1, float *a2, float *a3);
int __cdecl VectorCopy(_DWORD *a1, _DWORD *a2);
int __cdecl VectorScale(int, float, int); // idb
int __cdecl VectorMA(int, float, int, int); // idb
int __cdecl VectorCompareEpsilon(int a1, int a2);
long double __cdecl VectorLength(float *a1);
long double __cdecl VectorDistance(float *a1, float *a2);
long double __cdecl VectorDistanceSquared(float *a1, float *a2);
long double __cdecl VectorDistance2D(float *a1, float *a2);
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2);
float *__cdecl CrossProduct(float *a1, float *a2, float *a3);
_DWORD *__cdecl CrossProductUp(_DWORD *a1, _DWORD *a2);
long double __cdecl VectorNormalize(float *a1);
long double __cdecl VectorNormalize2D(float *a1);
long double __cdecl VectorNormalize4D(float *a1);
float *__cdecl VectorNormalizeFast(float *a1);
long double __cdecl VectorNormalize2(float *a1, float *a2);
unsigned int __cdecl VectorInverse(_DWORD *a1);
int __cdecl Vector4Scale(int, float, int); // idb
long double __cdecl VectorMax(float *a1);
float *__cdecl VectorRotate(float *a1, float *a2, float *a3);
int *__cdecl RotatePointAroundVector(int a1, int a2, int a3, float a4);
int __cdecl RotateAroundDirection(int, float); // idb
int __cdecl MakeNormalVectors(float *a1, float *a2, int a3);
long double __cdecl vectoyaw(float *a1);
long double __cdecl vectosignedyaw(float *a1);
long double __cdecl vectopitch(float *a1);
long double __cdecl vectosignedpitch(float *a1);
int __cdecl vectoangles(float *a1, int a2);
int __cdecl vectosignedangles(float *a1, int a2);
float *__cdecl AngleVectors(float *a1, int a2, float *a3, float *a4);
float *__cdecl YawVectors(float a1, int a2, int a3);
void __cdecl PerpendicularVector(int a1, int a2);
void __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, int a4);
float *__cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4);
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3);
int __cdecl MatrixMultiplyEquals(float *a1, float *a2);
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3);
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3);
int __cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3);
int __cdecl MatrixTranspose(_DWORD *a1, _DWORD *a2);
float *__cdecl MatrixInverse(float *a1, float *a2);
int __cdecl MatrixInverseOrthogonal43(float *a1, int a2);
int *__cdecl MatrixInverse44(int a1, float *a2);
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3);
int __cdecl MatrixTransformVector43Equals(float *a1, float *a2);
int __cdecl VectorAngleMultiply(int, float); // idb
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3);
unsigned int __cdecl QuatInverse(_DWORD *a1, unsigned int *a2);
int __cdecl ConvertQuatToMat(int a1);
long double __cdecl QuatEigenTrace(float *a1);
long double __cdecl AngleEigenTrace(float a1);
void __cdecl QuatRatioEigenTrace(int a1, int a2);
long double __cdecl RotationToYaw(float *a1);
float *__cdecl PitchToQuaternion(float a1, int a2);
float *__cdecl YawToQuaternion(float a1, int a2);
float *__cdecl RollToQuaternion(float a1, int a2);
int __cdecl ColorBytes3(float, float, float); // idb
int __cdecl ColorBytes4(float, float, float, float); // idb
long double __cdecl NormalizeColor(float *a1, float *a2);
long double __cdecl AngleMod(float a1);
long double __cdecl LerpAngle(float a1, int a2, float a3);
long double __cdecl AngleSubtract(float a1, float a2);
// float *__usercall AnglesSubtract@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4);
long double __cdecl AngleNormalize360(float a1);
// long double __usercall AngleNormalize180@<st0>(long double a1@<st0>, float a2);
long double __cdecl AngleNormalize360Accurate(float a1);
long double __cdecl AngleNormalize180Accurate(float a1);
int __cdecl AngleDelta(float, float); // idb
long double __cdecl RadiusFromBounds(int a1, int a2);
int __cdecl ClearBounds(_DWORD *a1, _DWORD *a2);
void __cdecl AddPointToBounds(float *a1, float *a2, float *a3);
void __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4);
_DWORD *__cdecl AxisClear(_DWORD *a1);
int __cdecl AxisCopy(_DWORD *a1, _DWORD *a2);
float *__cdecl AnglesToAxis(int a1, float *a2);
float *__cdecl YawToAxis(float a1, int a2);
int __cdecl AxisToAngles(int *a1, int a2);
int __cdecl Axis4ToAngles(int *a1, int a2);
int __cdecl AxisToSignedAngles(int *a1, int a2);
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4);
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3);
int __cdecl SetPlaneSignbits(int a1);
_BOOL4 __cdecl BoxDistSqrdExceeds(int a1, int a2, int a3, float a4);
_BYTE *__cdecl NormalToLatLong(float *a1, _BYTE *a2);
int __cdecl Vec10Copy(_DWORD *a1, _DWORD *a2);
long double __cdecl Q_rint(float a1);
long double __cdecl ColorNormalize(float *a1, float *a2);
int __cdecl VectorRotateAngles(int *a1, int a2, _DWORD *a3);
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4);
int __cdecl VectorPolar(int, float, int); // idb
void __cdecl VectorSnap(float *a1);
float *__cdecl Vector5Add(float *a1, float *a2, float *a3);
int __cdecl Vector5Scale(int, float, int); // idb
int __cdecl Vector53Copy(_DWORD *a1, _DWORD *a2);
long double __cdecl RoundFloat(float a1, int a2);
void __cdecl PitchForYawOnNormal(float a1, int a2);
int __cdecl Rand_Init(int a1);
long double __cdecl flrand(float a1, float a2);
int __cdecl irand(int a1, int a2);
long double __cdecl Q_SwayRand(float a1, float a2, float a3);
float *__cdecl sub_3F464(float a1, float *a2, float *a3);
double *__cdecl sub_3F47C(double a1, double *a2, double *a3);
void sub_3F4CE();
_DWORD *__cdecl G_CheckFlameDamage(_DWORD *a1);
int __cdecl P_DamageFeedback(_DWORD *a1);
int __cdecl G_SetClientSound(int a1);
int __cdecl ClientImpacts(int a1, int a2);
int __cdecl G_TouchTriggers(int a1);
int __cdecl G_EntityType(int); // weak
int __cdecl SpectatorThink(_DWORD *a1, int *a2);
int __cdecl ClientInactivityTimer(int a1);
int __cdecl ClientSpectatorInactivityTimer(int a1);
int __cdecl ClientIntermissionThink(int a1);
int __cdecl G_DoTouchTriggers(int a1, float *a2);
_DWORD *__cdecl ClientEvents(_DWORD *a1, int a2);
int __cdecl G_SetClientContents(int a1);
int __cdecl ClientThink_real(int a1, int *a2);
_DWORD *__cdecl ClientThink(int a1);
int __cdecl G_RunClient(_DWORD *a1);
int __cdecl IntermissionClientEndFrame(int a1);
_DWORD *__cdecl SpectatorClientEndFrame(int a1);
int __cdecl G_ClientCanSpectateTeam(int a1, char a2);
int __cdecl GetFollowPlayerState(int a1, _DWORD *a2);
int __cdecl StuckInClient(int a1);
int __cdecl sub_42C26(int a1, int a2);
int __cdecl G_UpdateClientInfo(int a1);
float *__cdecl ClientEndFrame(_DWORD *a1);
int __cdecl G_PlayerEvent(int a1, int a2);
void sub_43640();
int __cdecl sub_43644(int a1, int a2, _DWORD *a3);
int __cdecl sub_4367B(int a1);
int __cdecl sub_43771(int a1);
int __cdecl sub_43803(int a1);
int __cdecl sub_438D2(int a1);
int __cdecl sub_43956(int a1);
int __cdecl sub_43A2F(int a1);
int __cdecl sub_43AC7(_DWORD *a1);
int __cdecl sub_43B82(int a1);
int __cdecl sub_43C05(int a1);
int __cdecl sub_43C3D(int a1);
int __cdecl sub_43C8C(int a1);
int __cdecl sub_43CC9(int a1);
int __cdecl sub_43D43(int a1);
_DWORD *__cdecl sub_43DA9(int a1);
_DWORD *__cdecl sub_43E4C(int a1);
int __cdecl sub_43F48(int a1);
__int16 __cdecl sub_44005(int a1);
int __cdecl sub_44051(int a1);
char **__cdecl GScr_AddFieldsForClient(unsigned __int16 a1);
int __cdecl Scr_SetClientField(int a1, int a2);
int __cdecl Scr_GetClientField(int a1, int a2);
void sub_4420C();
int __cdecl SetClientOrigin(_DWORD *a1, _DWORD *a2);
// int __usercall SetClientViewAngle@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_44692(char *a1, char *a2, int a3);
char *__cdecl ClientUserinfoChanged(int a1);
const char *__cdecl ClientConnect(int a1, __int16 a2);
int __cdecl ClientBegin(int a1);
int __cdecl ClientSpawn(int a1, _DWORD *a2, int a3);
int __cdecl ClientDisconnect(int a1);
int G_SetPlayerSize();
int __cdecl G_AddLean(int a1, int a2);
unsigned int __cdecl G_GetNonPVSFriendlyInfo(_DWORD *a1, float *a2, int a3);
void sub_45ACB();
int __cdecl PlayerCmd_giveWeapon(unsigned int a1);
int __cdecl PlayerCmd_takeWeapon(unsigned int a1);
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1);
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1);
int __cdecl PlayerCmd_hasWeapon(unsigned int a1);
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1);
int __cdecl PlayerCmd_giveClipAmmo(unsigned int a1);
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1);
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1);
int __cdecl sub_467A4(unsigned int a1);
int __cdecl sub_46920(unsigned int a1);
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_isAds(unsigned int a1);
int __cdecl PlayerCmd_isInVehicle(unsigned int a1);
int __cdecl PlayerCmd_isOnGround(unsigned int a1);
int __cdecl PlayerCmd_pingPlayer(unsigned int a1);
int __cdecl sub_46ECA(unsigned int a1);
int __cdecl sub_46F7F(unsigned int a1);
int __cdecl sub_4702A(unsigned int a1);
int __cdecl sub_4718A(unsigned int a1);
int __cdecl sub_4721B(unsigned int a1);
int __cdecl sub_47307(unsigned int a1);
int __cdecl sub_47442(unsigned int a1);
int __cdecl sub_47C68(unsigned int a1);
int __cdecl sub_47D64(unsigned int a1);
int __cdecl sub_47E59(unsigned int a1);
int __cdecl sub_47F4E(int a1);
_BOOL4 __cdecl sub_47F83(int a1);
int __cdecl sub_47F9E(unsigned int a1);
int __cdecl sub_480F9(unsigned int a1);
int __cdecl sub_4838A(unsigned int a1);
int __cdecl sub_4851A(unsigned int a1);
int __cdecl sub_486F3(unsigned int a1);
int __cdecl sub_4885D(unsigned int a1);
int __cdecl sub_489D0(int a1);
int __cdecl sub_489FD(int a1);
int __cdecl sub_48A2A(unsigned int a1);
int __cdecl sub_48AEF(unsigned int a1);
int __cdecl sub_48B92(int a1);
int __cdecl sub_48BA9(unsigned int a1);
int __cdecl sub_48E90(unsigned int a1);
int __cdecl sub_49043(unsigned int a1);
int __cdecl sub_490E6(unsigned int a1);
unsigned int __cdecl sub_49189(unsigned int a1);
int __cdecl sub_4922C(unsigned int a1);
int __cdecl sub_4935B(unsigned int a1);
int __cdecl sub_4940C(unsigned int a1);
int __cdecl sub_494D8(unsigned int a1);
int __cdecl sub_495A4(unsigned int a1);
int __cdecl sub_4968F(unsigned int a1);
int __cdecl sub_4977A(unsigned int a1);
int __cdecl sub_49865(unsigned int a1);
int __cdecl sub_499DD(unsigned int a1);
int __cdecl sub_49A8D(unsigned int a1);
int __cdecl sub_49B41(unsigned int a1);
int __cdecl sub_49C48(unsigned int a1);
int __cdecl sub_49D22(unsigned int a1);
int __cdecl sub_49DFC(unsigned int a1);
int __cdecl Player_GetMethod(char **a1);
void sub_49F51();
int __cdecl DeathmatchScoreboardMessage(int a1);
int __cdecl Cmd_Score_f(int a1);
int __cdecl CheatsOk(int a1);
_BYTE *__cdecl ConcatArgs(int a1);
_BYTE *__cdecl SanitizeString(char *a1, _BYTE *a2);
int __cdecl ClientNumberFromString(int, char *nptr); // idb
void __cdecl G_setfog(char *s);
int Cmd_Fogswitch_f();
_DWORD *__cdecl Cmd_Give_f(_DWORD *a1);
int __cdecl Cmd_Take_f(int a1);
int __cdecl Cmd_God_f(int a1);
int __cdecl Cmd_Notarget_f(int a1);
int __cdecl Cmd_Noclip_f(int a1);
int __cdecl Cmd_UFO_f(int a1);
int __cdecl Cmd_Kill_f(_DWORD *a1);
int __cdecl StopFollowing(int a1);
int __cdecl Cmd_FollowCycle_f(int a1, int a2);
int __cdecl Cmd_Killcam_f(int a1);
_BOOL4 __cdecl G_IsPlaying(int a1);
void __cdecl sub_4B80B(int a1, int a2, int a3);
void __cdecl G_Say(int a1, int a2, int a3, char *src);
int __cdecl sub_4C037(int a1, int a2, int a3);
_DWORD *__cdecl sub_4C0A8(int *a1);
int __cdecl sub_4C284(int a1);
void G_Voice();
_DWORD *__cdecl Cmd_GameCommand_f(int a1);
int __cdecl Cmd_Where_f(int a1);
int __cdecl Cmd_CallVote_f(int a1);
_DWORD *__cdecl Cmd_Vote_f(int a1);
int __cdecl Cmd_SetViewpos_f(int a1);
int __cdecl Cmd_Activate_f(int a1);
_DWORD *Cmd_EntityCount_f();
int __cdecl Cmd_MatchTimeout_f(int a1);
int __cdecl Cmd_MatchTimein_f(int a1);
int __cdecl Cmd_MenuResponse_f(int a1);
int __cdecl Cmd_NextVehSlot_f(int a1);
int __cdecl Cmd_PrevVehSlot_f(int a1);
void Cmd_TraceProfile_f();
int __cdecl Cmd_FlameDamageClient_f(int a1);
int *__cdecl ClientCommand(int a1);
void sub_4F4B9();
char *__cdecl sub_4F4C0(char *dest, char *src);
int G_ParseHitLocDmgTable();
void AddScore();
void __cdecl LookAtKiller(int a1, float *a2, float *a3);
int __cdecl G_IndexForMeansOfDeath(int a1);
int __cdecl player_die(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
_DWORD *__cdecl G_DamageClient(int a1, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl G_Damage(int a1, char *a2, char *a3, int a4, _DWORD *a5, int a6, int a7, int a8, int a9);
long double __cdecl CanDamage(float *a1, float *a2);
int __cdecl G_RadiusDamage(int, int, int, float, float, float, int, int); // idb
int __cdecl G_GetHitLocationString(int a1);
int __cdecl G_GetHitLocationIndexFromString(__int16 a1);
void sub_51251();
int __cdecl G_DebugLine(int a1, int a2, int a3, int a4, int a5);
int *__cdecl G_DebugBox(int a1, int a2, int a3, int a4, int a5);
int __cdecl G_DebugCircle(int, float, int, int, int, int); // idb
unsigned int *__cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4, int a5, int a6);
void __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5, int a6, int a7);
float *__cdecl sub_518EC(float a1, float *a2, float *a3);
void sub_51904();
_DWORD *__cdecl sub_51908(_DWORD *a1);
_DWORD *__cdecl sub_5197B(_DWORD *a1);
char *__cdecl HudElem_Alloc(int a1, int a2);
_DWORD *__cdecl HudElem_Free(_DWORD *a1);
unsigned int *__cdecl HudElem_ClientDisconnect(_DWORD *a1);
void *HudElem_DestroyAll();
int __cdecl sub_51C38(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_51D43(int a1, int a2, int a3);
int *__cdecl sub_51D81(int a1, int a2);
int __cdecl sub_51DDC(int a1, int a2);
int __cdecl sub_51E2F(_BYTE *a1);
int __cdecl sub_51FAD(unsigned __int8 *a1);
int __cdecl sub_5201E(int a1);
int __cdecl sub_520B6(int a1);
int __cdecl sub_520ED(int a1);
int __cdecl sub_5214C(int a1, int a2);
int __cdecl sub_5219E(int a1, int a2);
int __cdecl sub_521F0(int a1, int a2);
int __cdecl sub_52242(int a1, int a2);
int __cdecl sub_52294(int a1, int a2);
int __cdecl sub_522E6(int a1, int a2);
int __cdecl Scr_GetHudElemField(int a1, int a2);
int __cdecl Scr_SetHudElemField(int a1, int a2);
void **__cdecl Scr_FreeHudElemConstStrings(int a1);
int GScr_NewHudElem();
int GScr_NewClientHudElem();
int GScr_NewTeamHudElem();
void **GScr_AddFieldsForHudElems();
int __cdecl sub_526F0(int a1);
int __cdecl sub_52779(int a1);
int __cdecl sub_528EA(int a1, int a2, char a3);
int __cdecl sub_529C5(int a1, int a2, char a3);
int __cdecl sub_52BC1(int a1);
int __cdecl sub_52BF6(int a1);
int __cdecl sub_52C2B(int a1);
int __cdecl sub_52C60(int a1);
int __cdecl sub_52C95(int a1);
int __cdecl sub_52CCA(int a1);
int __cdecl sub_52CFF(int a1);
int __cdecl sub_52D7E(int a1);
int __cdecl sub_52E6C(int a1);
int __cdecl sub_52FAE(int a1);
_DWORD *__cdecl sub_530A8(int a1);
int __cdecl sub_530E1(int a1);
int __cdecl HudElem_GetMethod(char **a1);
_DWORD *__cdecl HudElem_UpdateClient(_DWORD *a1, int a2, char a3);
int __cdecl sub_53335(float); // idb
int __cdecl sub_53373(float); // idb
void sub_533B1();
int __cdecl Fill_Clip(int a1, int a2);
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4);
int __cdecl sub_53772(int a1, int a2);
int __cdecl sub_538E7(_DWORD *a1, int a2, _DWORD *a3, int a4);
int __cdecl Pickup_Health(int a1, int a2);
int __cdecl RespawnItem(int a1);
int __cdecl Touch_Item_Auto(int a1, int a2, int a3);
unsigned int __cdecl Touch_Item(int a1, int *a2, int a3);
int sub_54D84();
int __cdecl DroppedItemClearOwner(int a1);
_DWORD *__cdecl LaunchItem(int a1, int a2, _DWORD *a3, int a4);
int __cdecl Drop_Item(int, int, float, int); // idb
int __cdecl Drop_Weapon(int a1, int a2, int a3);
int __cdecl Use_Item(int a1);
int __cdecl FinishSpawningItem(void *s); // idb
_DWORD *ClearRegisteredItems();
int SaveRegisteredItems();
_DWORD *__cdecl RegisterItem(int a1, int a2);
int __cdecl IsItemRegistered(int a1);
int (__cdecl *__cdecl G_SpawnItem(int a1, int a2))(void *s);
int __cdecl G_BounceItem(int a1, int a2);
void __cdecl G_RunItem(void *s);
int __cdecl sub_56A7D(float); // idb
void sub_56ABB();
int __cdecl vmMain(int, int, unsigned int seed, int, int); // idb
int G_Printf(char *format, ...);
_DWORD *G_DPrintf(char *format, ...);
int G_Error(char *format, ...);
int G_Error_Localized(char *format, ...);
int __cdecl sub_56E4A(int a1, int a2);
int __cdecl G_GetActivateEnt(int, void *base); // idb
int __cdecl G_CheckForCursorHints(int a1);
_DWORD *__cdecl G_CheckForPreventFriendlyFire(_DWORD *a1);
int G_FindTeams();
int G_RegisterCvars();
int G_UpdateCvars();
int G_SetUICvars();
_DWORD *G_FreeEntities();
_DWORD *__cdecl G_InitGame(int a1, unsigned int seed, int a3, int a4);
int __cdecl G_ShutdownGame(int a1);
int Com_Error(int a1, char *format, ...);
int Com_Printf(char *format, ...);
_DWORD *Com_DPrintf(char *format, ...);
_DWORD *SendScoreboardMessageToAllIntermissionClients();
int __cdecl sub_58E44(_DWORD *a1, _DWORD *a2);
_DWORD *CalculateRanks();
int ExitLevel();
_DWORD *G_LogPrintf(char *format, ...);
_DWORD *CheckVote();
_DWORD *CheckMatchTimeout();
int G_UpdateObjectiveToClients();
int G_UpdateHudElemsToClients();
int __cdecl G_RunThink(int a1);
int *DebugDumpAnims();
int __cdecl G_XAnimUpdateEnt(int a1);
int G_XAnimUpdate();
void *__cdecl sub_59A35(void *s);
int __cdecl G_RunFrame(int a1);
void sub_5A2CF();
int __cdecl SP_info_camp(int a1);
int __cdecl SP_info_null(void *s); // idb
int __cdecl SP_info_notnull(int a1);
int __cdecl SP_light(void *s); // idb
int __cdecl TeleportPlayer(_DWORD *a1, _DWORD *a2, int a3);
void SP_misc_teleporter_dest();
int __cdecl SP_sound_blend(_DWORD *a1);
int G_SpawnSoundBlend();
int __cdecl G_SetSoundBlend(_DWORD *a1, int a2, int a3, int a4);
int __cdecl G_SetSoundBlendAndPitch(int, int, int, float, float); // idb
int __cdecl SP_misc_model(void *s); // idb
int __cdecl use_corona(int a1);
int __cdecl SP_corona(void *s); // idb
_BOOL4 G_IsInMatchTimeout();
int *G_InitTurrets();
int __cdecl sub_5A8B0(int a1, int a2, int a3);
_DWORD *__cdecl sub_5AAA9(int a1, char *a2, int a3);
int __cdecl sub_5AC06(int a1, float *a2);
int __cdecl sub_5B950(int a1, int a2);
_DWORD *__cdecl sub_5BAD3(_DWORD *a1, _DWORD *a2);
int __cdecl sub_5BB49(int a1, _DWORD *a2);
int __cdecl sub_5BC29(int a1);
int __cdecl G_ClientStopUsingTurret(int a1);
int __cdecl turret_think_client(int a1);
int __cdecl sub_5BEDF(int a1, int a2, int a3);
int __cdecl sub_5C18E(int a1, int a2);
int __cdecl turret_think(_DWORD *a1);
float *__cdecl turret_think_init(_DWORD *a1);
int __cdecl turret_controller(_DWORD *a1, int a2);
_BOOL4 __cdecl sub_5C693(int a1, float *a2);
int __cdecl G_FreeTurret(int a1);
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2);
// int __usercall turret_use@<eax>(long double a1@<st0>, int a2, int a3, int a4);
int __cdecl G_SpawnTurret(int a1, char a2);
int __cdecl SP_turret(int a1);
int __cdecl misc_spawner_think(int a1);
int __cdecl misc_spawner_use(int a1);
int __cdecl SP_misc_spawner(int a1);
float *__cdecl miscGunnerEnemyScan(int a1);
long double __cdecl sub_5D425(float a1);
void sub_5D43E();
void __cdecl G_MissileLandAngles(int a1, float *a2, int a3, int a4);
_BOOL4 __cdecl G_BounceMissile(int a1, int a2);
int __cdecl G_MissileImpact(int a1, int a2);
int __cdecl Concussive_think(int a1);
_DWORD *__cdecl Concussive_fx(float *a1);
int __cdecl G_ExplodeMissile(float *a1);
int (__cdecl *__cdecl G_BarrageThink(int a1))(void *s);
int __cdecl G_DropArtillery(_DWORD *a1);
int __cdecl G_MissileDie(int a1, int a2);
int __cdecl G_ExplodeSmokeGrenade(float *a1);
void __cdecl G_MissileTrace(int a1, float *a2, float *a3, int a4, int a5);
void *__cdecl G_RunMissile(void *s);
int __cdecl DynaSink(int a1);
int __cdecl G_GrenadeDie(int a1);
int (__cdecl *__cdecl G_GrenadeLeaveOwnerThink(int (__cdecl *a1)(float *a1)))(float *a1);
int __cdecl fire_grenade(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl fire_rocket(_DWORD *a1, _DWORD *a2, float *a3);
int __cdecl fire_artillery(_DWORD *a1, int *a2, int a3);
_DWORD *__cdecl fire_artillery_barrage(_DWORD *a1, _DWORD *a2, int a3);
void sub_60371();
_DWORD *__cdecl G_TestEntityPosition(_DWORD *a1, int a2);
int __cdecl G_CreateRotationMatrix(int a1, int a2);
int *__cdecl G_TransposeMatrix(int a1, int a2);
float *__cdecl G_RotatePoint(float *a1, float *a2);
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, int a4);
int __cdecl sub_60C1B(int a1, float *a2, float *a3, _DWORD *a4);
int __cdecl G_MoverTeam(int a1);
int __cdecl G_RunMover(int a1);
int __cdecl SetMoverState(int a1, int a2, int a3);
int __cdecl MatchTeam(int a1, int a2, int a3);
int __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3);
int __cdecl ReturnToPos1(int a1);
int __cdecl ReturnToPos2(int a1);
int __cdecl GotoPos3(int a1);
int __cdecl ReturnToPos1Rotate(int a1);
void __cdecl Reached_BinaryMover(int a1);
_BOOL4 __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3);
void __cdecl Use_BinaryMover(int a1, int a2, int a3);
void __cdecl InitMover(int a1);
int __cdecl InitMoverRotate(int a1);
int __cdecl Blocked_Door(int, void *s); // idb
int __cdecl Blocked_DoorRotate(int, void *s); // idb
int __cdecl Touch_DoorTrigger(int a1, int a2);
int __cdecl sub_6378C(int a1);
int __cdecl Think_SpawnNewDoorTrigger(int a1);
int __cdecl sub_639A6(int a1);
int __cdecl Think_SpawnNewAutoDoorTrigger(int a1);
int __cdecl Think_MatchTeam(int a1);
int __cdecl finishSpawningKeyedMover(int a1);
int __cdecl Door_reverse_sounds(_BYTE *a1);
int __cdecl DoorSetSounds(_BYTE *a1);
int __cdecl G_TryDoor(int a1, int a2, int a3);
int (__cdecl *__cdecl SP_func_door(int a1))(int a1);
int __cdecl Use_Static(int a1);
void __cdecl Static_Pain(int a1);
int __cdecl SP_func_leaky(_DWORD *a1);
int __cdecl SP_func_static(int a1);
int __cdecl Use_Func_Rotate(_DWORD *a1);
int __cdecl SP_func_rotating(float *a1);
int __cdecl SP_func_bobbing(int a1);
int __cdecl SP_func_pendulum(int a1);
int (__cdecl *__cdecl SP_func_door_rotating(int a1))(int, void *s);
void __cdecl use_trigger_use(int a1, int a2);
int __cdecl trigger_use(int a1);
int __cdecl G_Activate(int a1, int a2);
void sub_6529F();
int __cdecl GScr_AllocString(int a1);
int GScr_LoadConsts();
_WORD *Scr_LoadLevel();
int __cdecl sub_66340(int a1, int a2, int a3);
int GScr_LoadGameTypeScript();
int sub_664F9();
int sub_66592();
int __cdecl sub_66605(int a1);
int GScr_LoadScripts();
int GScr_FreeScripts();
_DWORD *__cdecl sub_666E7(unsigned int a1);
_DWORD *__cdecl sub_66739(unsigned int a1);
_DWORD *sub_66800();
_DWORD *sub_66863();
int __cdecl Scr_LocalizationError(int, char *format); // idb
int *__cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4);
int __cdecl Scr_MakeGameMessage(int a1, char a2);
int sub_66E58();
int sub_66E86();
int sub_66EB4();
int sub_66F96();
void sub_67084();
int sub_67089();
int sub_670EB();
int sub_67176();
int sub_6721F();
int sub_67277();
int sub_672B1();
int sub_672EB();
int sub_6749E();
_DWORD *sub_674CA();
int sub_67523();
int sub_675C8();
int sub_676C6();
int sub_67733();
int sub_67793();
int sub_6782E();
int sub_67885();
int sub_67974();
int sub_67AA0();
int sub_67B4B();
int __cdecl sub_67BB6(unsigned int a1);
int __cdecl sub_67CB0(unsigned int a1);
int __cdecl sub_67DE6(unsigned int a1);
int __cdecl sub_67E17(unsigned int a1);
int __cdecl sub_67E71(unsigned int a1);
int __cdecl sub_67EF2(unsigned int a1);
int __cdecl sub_67F6A(unsigned int a1);
int __cdecl sub_67FE7(unsigned int a1);
int __cdecl sub_681FF(unsigned int a1);
int __cdecl sub_68230(unsigned int a1);
int __cdecl sub_68338(unsigned int a1);
_DWORD *__cdecl sub_6838D(unsigned int a1);
int __cdecl sub_68590(unsigned int a1);
int __cdecl sub_68635(unsigned int a1);
int __cdecl sub_68698(unsigned int a1);
int __cdecl sub_68727(unsigned int a1);
_DWORD *__cdecl sub_6897F(unsigned int a1);
_DWORD *__cdecl sub_689E0(unsigned int a1);
int __cdecl sub_68A41(unsigned int a1);
int __cdecl sub_68ABB(unsigned int a1);
int __cdecl sub_68B2E(unsigned int a1);
_DWORD *__cdecl sub_68B8D(unsigned int a1);
int __cdecl sub_68BDA(unsigned int a1);
int __cdecl sub_68C92(unsigned int a1);
int __cdecl sub_68CEF(unsigned int a1);
int __cdecl sub_68D70(unsigned int a1);
int __cdecl sub_68E67(unsigned int a1);
int __cdecl sub_69042(unsigned int a1);
int __cdecl sub_691D2(unsigned int a1);
unsigned int __cdecl sub_6922C(unsigned int a1);
int __cdecl sub_69259(unsigned int a1);
int __cdecl sub_69286(unsigned int a1);
int __cdecl sub_692B7(unsigned int a1);
int __cdecl ScrCmd_VerifyPosition(unsigned int a1);
int *__cdecl sub_6950E(unsigned int a1);
int __cdecl sub_696B9(unsigned int a1);
int __cdecl sub_69716(unsigned int a1);
_DWORD *__cdecl sub_69777(unsigned int a1);
int __cdecl G_GetHintStringIndex(int, char *s1); // idb
_DWORD *__cdecl sub_699B6(unsigned int a1);
int __cdecl sub_69AB9(unsigned int a1);
int __cdecl sub_69AEC(unsigned int a1);
int __cdecl sub_69B60(unsigned int a1);
_DWORD *__cdecl sub_69BD4(unsigned int a1);
_DWORD *__cdecl sub_69C39(unsigned int a1);
unsigned int __cdecl sub_69C9E(unsigned int a1);
int __cdecl sub_69CCB(unsigned int a1);
int *G_InitObjectives();
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2);
int __cdecl sub_69DD7(int a1);
_DWORD *__cdecl sub_69E3F(_DWORD *a1);
int __cdecl sub_69E92(int a1, int a2);
float *sub_69F70();
_DWORD *sub_6A132();
int sub_6A1DE();
int sub_6A2D6();
int sub_6A365();
int sub_6A477();
char *sub_6A533();
_DWORD *sub_6A635();
int sub_6A74C();
int sub_6A7F5();
_DWORD *sub_6A819();
int sub_6A964();
int sub_6ABC2();
int sub_6ABEE();
int __cdecl GScr_GetScriptMenuIndex(int a1);
int sub_6ADAB();
int __cdecl GScr_GetStatusIconIndex(_BYTE *a1);
int sub_6AF78();
int __cdecl GScr_GetHeadIconIndex(_BYTE *a1);
int sub_6B145();
int sub_6B397();
int sub_6B404();
int sub_6B446();
int sub_6B4C8();
int sub_6B551();
int sub_6B59B();
int sub_6B5E5();
int sub_6B667();
int sub_6B6FE();
int sub_6B795();
int sub_6B7E5();
int sub_6B83D();
int sub_6B895();
int sub_6B8EC();
int sub_6B935();
int sub_6B9CB();
int sub_6BA27();
int sub_6BA7C();
int sub_6BAC4();
int sub_6BB1C();
int sub_6BB74();
int sub_6BBCC();
int sub_6BC1A();
int sub_6BCD3();
int sub_6BD6D();
int sub_6BDB3();
int sub_6BDF9();
int sub_6BE9D();
char *sub_6BF07();
int sub_6BF5B();
int sub_6C053();
int sub_6C110();
_DWORD *sub_6C229();
int sub_6C348();
int sub_6C37A();
int sub_6C499();
int sub_6C5C0();
int sub_6C620();
int sub_6C6A2();
int sub_6C808();
int sub_6C9A4();
int sub_6CA27();
int sub_6CABE();
int __cdecl sub_6CCA8(char, float, float, float, float, float, float, float); // idb
int sub_6CE1E();
int sub_6CEE8();
int sub_6CFD6();
int sub_6D045();
int sub_6D094();
int sub_6D16A();
int sub_6D2B3();
int sub_6D327();
int sub_6D3AB();
_DWORD *sub_6D454();
_DWORD *sub_6D56D();
int sub_6D5ED();
int sub_6D6DB();
int GScr_GetNumParts();
int GScr_GetPartName();
int sub_6D8DD();
int __cdecl sub_6D976(unsigned int a1);
int __cdecl sub_6DADF(unsigned int a1);
int __cdecl sub_6DB55(unsigned int a1);
int __cdecl sub_6DC79(unsigned int a1);
void __cdecl sub_6DD1A(unsigned int a1);
void __cdecl sub_6DDA0(unsigned int a1);
void __cdecl sub_6DE19(unsigned int a1);
void __cdecl sub_6DE9F(unsigned int a1);
int __cdecl sub_6DF18(unsigned int a1);
int sub_6E11C();
int sub_6E179();
int sub_6E227();
int __cdecl sub_6E2C4(unsigned int a1);
int sub_6E47D();
int sub_6E4AE();
int sub_6E5EE();
void Scr_Prof_Begin();
void Scr_Prof_End();
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2);
int __cdecl sub_6E6E4(char **a1);
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2);
int __cdecl Scr_SetOrigin(int a1);
int __cdecl Scr_SetAngles(int a1);
int __cdecl Scr_SetHealth(_DWORD *a1);
int __cdecl GScr_AddVector(int a1);
int __cdecl GScr_AddEntity(int a1);
int Scr_ParseGameTypeList();
int __cdecl Scr_GetGameTypeNameForScript(int a1);
_BOOL4 __cdecl Scr_IsValidGameType(int a1);
int Scr_LoadGameType();
int Scr_StartupGameType();
int __cdecl Scr_PlayerConnect(int a1);
int __cdecl Scr_PlayerDisconnect(int a1);
int __cdecl Scr_PlayerDamage(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl Scr_PlayerKilled(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int Scr_LoadRead();
int __cdecl sub_6F0B9(float); // idb
float *__cdecl sub_6F0F7(float a1, float *a2, float *a3);
_BYTE *__cdecl sub_6F10F(_BYTE *a1);
void sub_6F163();
int __cdecl sub_6F168(int, int, float, float, float, int, int, int); // idb
// _DWORD *__usercall Reached_ScriptMover@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_6F662(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_6FB7A(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_700CA(int, int, float, float, float); // idb
int __cdecl sub_7016B(int, int, float); // idb
int __cdecl sub_70253(int, int, float, float, float); // idb
int __cdecl sub_702F4(int, int, float, float, float); // idb
int __cdecl InitScriptMover(_DWORD *a1);
int __cdecl SP_script_brushmodel(int a1);
int __cdecl SP_script_model(int a1);
_DWORD *__cdecl SP_script_origin(_DWORD *a1);
void __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3);
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1);
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1);
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_MoveX(unsigned int a1);
int __cdecl ScriptEntCmd_MoveY(unsigned int a1);
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1);
// int __usercall ScriptEntCmd_RotateTo@<eax>(long double a1@<st0>, unsigned int a2);
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1);
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1);
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1);
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1);
int __cdecl ScriptEntCmd_Solid(unsigned int a1);
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1);
int __cdecl ScriptEnt_GetMethod(char **a1);
void sub_712DD();
int __cdecl G_SpawnString(char *s1, int, int); // idb
int __cdecl G_SpawnFloat(char *s1, int, int); // idb
int __cdecl G_SpawnInt(char *s1, int, int); // idb
int __cdecl G_SpawnVector(char *s1, int, int); // idb
int sub_71480();
int __cdecl sub_714A6(int a1, int a2);
int __cdecl sub_71537(int, char *nptr, int); // idb
void __cdecl sub_715DE(int a1, char *s, int a3);
int __cdecl sub_717A5(int a1);
char **__cdecl G_DuplicateEntityFields(int a1, int a2);
int __cdecl G_DuplicateScriptFields(_DWORD *a1, _DWORD *a2);
int G_CallSpawn();
int __cdecl G_CallSpawnEntity(int a1);
int __cdecl G_NewString(char *s); // idb
int GScr_AddFieldsForEntity();
int GScr_AddFieldsForRadiant();
int __cdecl Scr_SetEntityField(int a1, int a2);
int __cdecl Scr_SetGenericField(int a1, int a2, int a3);
int __cdecl Scr_SetObjectField(int a1, int a2, int a3);
int __cdecl Scr_GetEntityField(int a1, int a2);
int __cdecl Scr_GetGenericField(int a1, int a2, int a3);
int __cdecl Scr_GetObjectField(int a1, int a2, int a3);
int *__cdecl Scr_FreeEntityConstStrings(int a1);
int __cdecl Scr_FreeEntity(_DWORD *a1);
int __cdecl Scr_AddEntity(_DWORD *a1);
_DWORD *__cdecl Scr_GetEntity(int a1);
int __cdecl Scr_FreeHudElem(int a1);
int __cdecl Scr_AddHudElem(int a1);
_DWORD *__cdecl Scr_GetHudElem(int a1);
int __cdecl Scr_ExecEntThread(_DWORD *a1, int a2, int a3);
int __cdecl Scr_AddExecEntThread(_DWORD *a1, int a2, int a3);
int __cdecl Scr_Notify(_DWORD *a1, unsigned __int16 a2, int a3);
int Scr_GetEnt();
int Scr_GetEntArray();
int __cdecl GScr_SetDynamicEntityField(_DWORD *a1, unsigned __int16 a2);
int G_SpawnGEntityFromSpawnVars();
char *__cdecl G_AddSpawnVarToken(char *s);
int G_ParseSpawnVars();
_DWORD *SP_worldspawn();
_DWORD *G_SpawnEntitiesFromString();
void sub_72DD7();
int __cdecl sub_72DDC(char *a1, _DWORD *a2);
int sub_72F54();
_BOOL4 __cdecl G_FilterPacket(char *a1);
int __cdecl sub_73138(char *a1);
char *G_ProcessIPBans();
int Svcmd_AddIP_f();
int Svcmd_RemoveIP_f();
int Svcmd_EntityList_f();
int __cdecl ClientForString(char *nptr); // idb
int ConsoleCommand();
void sub_73898();
int (__cdecl *__cdecl dllEntry(int (__cdecl *a1)(_DWORD, _DWORD)))(_DWORD, _DWORD);
long double __cdecl sub_738B7(float a1);
int __cdecl PASSFLOAT(int a1);
int __cdecl trap_Printf(int a1);
int __cdecl trap_Error(int a1);
int __cdecl trap_Error_Localized(int a1);
int trap_Milliseconds();
int trap_Argc();
int __cdecl trap_Argv(int a1);
int __cdecl trap_Hunk_AllocInternal(int a1);
int __cdecl trap_Hunk_AllocLowInternal(int a1);
int __cdecl trap_Hunk_AllocAlignInternal(int a1);
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1);
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1);
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1);
int __cdecl trap_FS_FOpenFile(int a1);
int __cdecl trap_FS_Read(int a1);
int __cdecl trap_FS_Write(int a1);
int __cdecl trap_FS_Rename(int a1);
int __cdecl trap_FS_FCloseFile(int a1);
int __cdecl trap_FS_GetFileList(int a1);
int __cdecl trap_MapExists(int a1);
int __cdecl trap_SendConsoleCommand(int a1);
int __cdecl trap_Cvar_Register(int a1);
int __cdecl trap_Cvar_Update(int a1);
int __cdecl trap_Cvar_Set(int a1);
int __cdecl trap_Cvar_VariableIntegerValue(int a1);
long double __cdecl trap_Cvar_VariableValue(int a1);
int __cdecl trap_Cvar_VariableStringBuffer(int a1);
int __cdecl trap_LocateGameData(int a1);
int __cdecl trap_GetGuid(int a1);
int __cdecl trap_DropClient(int a1);
int __cdecl trap_SendServerCommand(int a1);
int __cdecl trap_SetConfigstring(int a1);
int __cdecl trap_GetConfigstring(int a1);
int __cdecl trap_GetConfigstringConst(int a1);
int __cdecl trap_IsLocalClient(int a1);
int __cdecl trap_GetClientPing(int a1);
int __cdecl trap_GetUserinfo(int a1);
int __cdecl trap_SetUserinfo(int a1);
int __cdecl trap_GetServerinfo(int a1);
int __cdecl trap_SetBrushModel(int a1);
int __cdecl trap_Trace(int a1);
int __cdecl trap_TraceCapsule(int a1);
int __cdecl trap_SightTrace(int a1);
int __cdecl trap_SightTraceCapsule(int a1);
int __cdecl trap_SightTraceToEntity(int a1);
int __cdecl trap_CM_BoxTrace(int a1);
int __cdecl trap_CM_CapsuleTrace(int a1);
int __cdecl trap_CM_BoxSightTrace(int a1);
int __cdecl trap_CM_CapsuleSightTrace(int a1);
int __cdecl trap_LocationalTrace(int a1);
int __cdecl trap_PointContents(int a1);
int __cdecl trap_InPVS(int a1);
int __cdecl trap_InPVSIgnorePortals(int a1);
int __cdecl trap_InSnapshot(int a1);
int __cdecl trap_AdjustAreaPortalState(int a1);
int __cdecl trap_AreasConnected(int a1);
int __cdecl trap_LinkEntity(int a1);
int __cdecl trap_UnlinkEntity(int a1);
int __cdecl trap_EntitiesInBox(int a1);
int __cdecl trap_EntityContact(int a1);
int __cdecl trap_EntityContactCapsule(int a1);
int __cdecl trap_GetUsercmd(int a1);
int __cdecl trap_GetEntityToken(int a1);
int __cdecl trap_AddDebugString(int a1, int a2, int a3, int a4);
int __cdecl trap_AddDebugLine(int a1);
int __cdecl trap_SetArchive(int a1);
int __cdecl trap_RealTime(int a1);
int __cdecl trap_SnapVector(int a1);
int __cdecl trap_Com_SoundAliasString(int); // weak
int __cdecl trap_Com_PickSoundAlias(int a1);
int __cdecl trap_Com_SoundAliasIndex(int a1);
int __cdecl trap_SurfaceTypeFromName(int a1);
int __cdecl trap_SurfaceTypeToName(int a1);
int __cdecl trap_Z_MallocInternal(int a1);
int __cdecl trap_Z_FreeInternal(int a1);
int trap_AddTestClient();
int __cdecl trap_GetArchivedClientInfo(int a1);
int __cdecl trap_XAnimCreateTree(int a1);
int __cdecl trap_XAnimCreateSmallTree(int a1);
int __cdecl trap_XAnimFreeSmallTree(int a1);
int __cdecl trap_XModelExists(int a1);
int __cdecl trap_XModelGet(int a1);
int __cdecl trap_DObjCreate(int a1);
int __cdecl trap_SafeDObjFree(int a1);
int __cdecl trap_DObjExists(_DWORD *a1);
int __cdecl trap_XAnimGetAnims(int a1);
// _DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2);
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4, int a5, int a6, unsigned __int16 a7, int a8);
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimClearTree(int a1);
int __cdecl trap_XAnimHasTime(int a1);
int __cdecl trap_XAnimIsPrimitive(int a1);
int __cdecl trap_XAnimGetLength(int a1);
long double __cdecl trap_XAnimGetLengthSeconds(int a1);
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimCalcAbsDelta(int a1);
int __cdecl trap_XAnimCalcDelta(int a1);
int __cdecl trap_XAnimGetRelDelta(int a1, int a2, int a3, int a4, int a5);
int __cdecl trap_XAnimGetAbsDelta(int a1, int a2, int a3, int a4);
int __cdecl trap_XAnimIsLooped(int a1);
int __cdecl trap_XAnimNotetrackExists(int a1);
long double __cdecl trap_XAnimGetTime(int a1);
long double __cdecl trap_XAnimGetWeight(int a1);
int __cdecl trap_DObjDumpInfo(_DWORD *a1);
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1);
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1);
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3);
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2);
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1);
int __cdecl trap_DObjCalcAnim(_DWORD *a1);
int __cdecl trap_DObjCalcSkel(_DWORD *a1);
int __cdecl trap_XAnimLoadAnimTree(int a1);
int __cdecl trap_XAnimSaveAnimTree(int a1);
int __cdecl trap_XAnimCloneAnimTree(int a1);
int __cdecl trap_DObjNumBones(_DWORD *a1);
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1);
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1);
int __cdecl trap_DObjDisplayAnim(_DWORD *a1);
int __cdecl trap_XAnimHasFinished(int a1);
int __cdecl trap_XAnimGetNumChildren(int a1);
// _DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, int a2);
int __cdecl trap_XModelNumBones(int a1);
int __cdecl trap_XModelGetBoneNames(int a1);
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1);
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1);
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1);
int __cdecl trap_DObjGetBounds(_DWORD *a1);
int __cdecl trap_XAnimGetAnimName(int a1);
int __cdecl trap_DObjGetTree(_DWORD *a1);
int __cdecl trap_XAnimGetAnimTreeSize(int a1);
int __cdecl trap_XModelDebugBoxes(_DWORD *a1);
int __cdecl trap_GetWeaponInfoMemory(int a1);
int __cdecl trap_FreeWeaponInfoMemory(int a1);
int trap_FreeClientScriptPers();
int trap_ResetEntityParsePoint();
void sub_75A2E();
_DWORD *target_location_linkup();
int __cdecl SP_target_location(int a1);
void sub_75BBC();
_BOOL4 __cdecl OnSameTeam(int a1, int a2);
_BOOL4 __cdecl InSameSquad(int a1, int a2);
int __cdecl Team_GetLocation(int *a1);
int __cdecl Team_GetLocationMsg(int, char *s, size_t maxlen); // idb
int __cdecl TeamplayInfoMessage(int a1);
int CheckTeamStatus();
void sub_76212();
int __cdecl G_Trigger(int a1, int a2);
int __cdecl InitTrigger(int a1);
int __cdecl InitSentientTrigger(int a1);
int __cdecl multi_wait(int a1);
int (__cdecl *__cdecl multi_trigger(int a1, int a2))(int);
int __cdecl Use_Multi(int a1, int a2, int a3);
int __cdecl Touch_Multi(int a1, int a2);
int __cdecl SP_trigger_multiple(int a1);
int __cdecl hurt_touch(int a1, int a2);
void __cdecl hurt_think(void *s);
void __cdecl hurt_use(int a1);
int __cdecl SP_trigger_hurt(int a1);
int __cdecl SP_trigger_once(_DWORD *a1);
int __cdecl Respond_trigger_damage(int a1, int a2);
int (__cdecl *__cdecl Activate_trigger_damage(int a1, int a2, int (__cdecl *a3)(int), int a4))(int);
int __cdecl Use_trigger_damage(int a1, int a2);
int __cdecl Pain_trigger_damage(int a1, int a2, int a3, int a4, int a5);
int __cdecl Die_trigger_damage(int a1, int a2, int a3, int a4, int a5);
int __cdecl SP_trigger_damage(int a1);
int __cdecl G_CheckHitTriggerDamage(int a1, int *a2, int a3, int a4, int a5);
int __cdecl G_GrenadeTouchTriggerDamage(int a1, int *a2, int a3, int a4, int a5);
int __cdecl explosive_indicator_think(_DWORD *a1);
int __cdecl SP_trigger_lookat(_DWORD *a1);
int __cdecl Touch_trigger_mount(int a1, int a2);
int __cdecl SP_trigger_mount(_DWORD *a1);
int __cdecl SP_trigger_mount_no_brush(_DWORD *a1, int a2);
int __cdecl G_CheckPointInsideTriggerMount(int a1, float *a2, _DWORD *a3);
void sub_77997();
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, int a5);
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl G_ShaderIndex(char *s2); // idb
int __cdecl G_ModelIndex(char *s2); // idb
int __cdecl sub_77C2E(int a1);
int __cdecl G_ModelName(int a1);
int __cdecl G_TagIndex(char *s2); // idb
int __cdecl G_EffectIndex(char *s2); // idb
int __cdecl G_ShellShockIndex(char *s2); // idb
int __cdecl G_SoundAliasIndex(char *s2); // idb
int __cdecl G_GetGameId(_DWORD *a1);
int __cdecl G_UpdateTags(int a1, int a2);
int __cdecl G_DObjUpdate(int a1);
int __cdecl G_SetModel(int, char *s2); // idb
int __cdecl G_EntAttach(int, char *s2, int, int); // idb
int __cdecl G_EntDetach(int, char *s2, int); // idb
int __cdecl G_EntDetachAll(int a1);
int __cdecl sub_783C7(int a1, int a2, _BYTE *a3);
int __cdecl G_EntLinkTo(int a1, int a2, _BYTE *a3);
int __cdecl G_EntLinkToWithOffset(int a1, int a2, _BYTE *a3, _DWORD *a4, int a5);
_DWORD *__cdecl G_EntUnlink(int a1);
int __cdecl G_EntIsLinkedTo(int a1, int a2);
int __cdecl G_UpdateTagInfo(int a1, int a2);
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2);
int __cdecl G_CalcTagParentAxis(int a1, _DWORD *a2);
int __cdecl G_CalcTagParentRelAxis(int a1, int a2);
int __cdecl G_CalcTagAxis(_DWORD *a1, int a2);
void __cdecl G_SetFixedLink(int a1, int a2);
int __cdecl G_GeneralLink(int a1);
int __cdecl Think_GeneralLink(int); // weak
int __cdecl G_SafeDObjFree(_DWORD *a1);
int __cdecl G_DObjUpdateServerTime(int a1, int a2);
int __cdecl sub_78CF6(int a1, _DWORD *a2, float *a3, int a4);
int __cdecl G_DObjSetLocalBoneIndex(int a1, int a2, int a3, _DWORD *a4, float *a5);
int __cdecl G_DObjSetLocalTag(int a1, int a2, int a3, _DWORD *a4, float *a5);
int __cdecl G_DObjSetControlTagAngles(int a1, int a2, int a3, float *a4);
int __cdecl G_DObjCalcPose(int a1);
int __cdecl G_DObjCalcBone(int a1, int a2);
int __cdecl G_DObjGetLocalBoneIndexMatrix(int a1, int a2);
int __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD *a1, int a2, int a3);
int __cdecl G_DObjGetLocalTagMatrix(int a1, int a2);
int __cdecl G_DObjGetWorldTagMatrix(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl G_Find(int a1, int a2, __int16 a3);
_DWORD *__cdecl G_FindStr(int a1, int a2, int a3);
int __cdecl G_PickTarget(unsigned __int16 a1);
char *__cdecl vtos(float *a1);
char *__cdecl vtosf(float *a1);
int __cdecl G_SetMovedir(float *a1, _DWORD *a2);
int __cdecl G_InitGentity(int a1);
int G_Spawn();
_DWORD *G_SpawnPlayerClone();
int *__cdecl G_FreeEntityRefs(int *a1);
int __cdecl G_FreeEntity(void *s); // idb
_DWORD *__cdecl G_TempEntity(int *a1, int a2);
int __cdecl G_KillBox(int a1);
int __cdecl G_AddPredictableEvent(int a1, int a2, char a3);
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3);
int __cdecl G_PlaySoundAliasAtPoint(int a1, unsigned __int8 a2);
int __cdecl G_PlaySoundAlias(int a1, int a2);
int __cdecl G_AnimScriptSound(int, char *s2); // idb
int __cdecl G_SetOrigin(_DWORD *a1, _DWORD *a2);
int __cdecl G_SetAngle(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl infront(float *a1, float *a2);
int DebugLine();
_WORD *__cdecl G_SetConstString(_WORD *a1, int a2);
int __cdecl G_BackupSpawnVars(int a1);
void sub_7A51D();
void __cdecl Weapon_Melee(_DWORD *a1, float *a2);
int *__cdecl SnapVectorTowards(int a1, int a2);
long double __cdecl Damage_Falloff(float a1, int a2, float a3, int a4, int a5);
int __cdecl Bullet_Fire(int, float, int, int, int); // idb
int __cdecl Bullet_Fire_Extended(_DWORD *a1, _DWORD *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8);
float *__cdecl weapon_grenadelauncher_fire(int a1, int a2, int a3);
int __cdecl Weapon_RocketLauncher_Fire(int, float, int); // idb
int __cdecl Weapon_Artillery_Fire(int, float, int); // idb
int __cdecl Weapon_ArtilleryStrike_Fire(int, float, int); // idb
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2);
void __cdecl CalcMuzzlePoint(_DWORD *a1, float *a2);
int __cdecl CalcMuzzlePoints(int a1, int a2);
int __cdecl FireWeapon(int a1);
int __cdecl FireWeaponMelee(int a1);
void sub_7BFA1();
char *__cdecl sub_7BFA8(char *dest, char *src);
int __cdecl sub_7BFD2(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_7C02C(int, float, int, int, int); // idb
int __cdecl sub_7C110(int, float, float, int, int, int); // idb
int __cdecl VEH_ParseSpecificField(int a1, char *s1, int a3);
_DWORD *__cdecl sub_7C280(int a1);
int __cdecl sub_7C33F(char *s1); // idb
_DWORD *__cdecl sub_7C3CE(char *s2);
int __cdecl sub_7C488(int a1, int a2, _DWORD *a3);
long double __cdecl sub_7C525(float a1, float a2, float a3);
long double __cdecl sub_7C5C5(float a1, float a2, float a3);
int __cdecl sub_7C63C(float, float, float); // idb
int __cdecl sub_7C6CF(float, float, float); // idb
void __cdecl sub_7C762(int a1, float *a2, float *a3);
char *__cdecl sub_7C935(int a1, int a2, __int16 a3);
int __cdecl VEH_InitPhysics(_DWORD *a1);
void __cdecl sub_7CEBF(int a1, int a2, __int16 a3);
_DWORD *__cdecl VEH_SetupCollmap(int a1);
int __cdecl sub_7D492(int, int, float, float, int); // idb
int __cdecl sub_7D709(int a1, char *a2, float *a3, float *a4);
void __cdecl sub_7F932(float *a1, float *a2, float *a3);
int __cdecl sub_7FAAA(_DWORD *a1, int a2);
void __cdecl sub_7FC99(_DWORD *a1);
void __cdecl VEH_GroundFriction(int a1);
_BOOL4 __cdecl VEH_SlideMove(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_80D93(_DWORD *a1, int a2);
void __cdecl sub_81175(_DWORD *a1);
void __cdecl sub_812C4(_DWORD *a1);
_DWORD *__cdecl sub_81331(_DWORD *a1);
void *__cdecl sub_81F2E(_DWORD *a1);
int __cdecl VEH_PlayerDamage(int a1, int a2, int a3);
void __cdecl VEH_PlayerCollision(_DWORD *a1, int a2);
int __cdecl sub_827AB(float *a1, int a2);
void __cdecl sub_85B32(int a1);
int __cdecl sub_86285(int a1);
_DWORD *__cdecl sub_86735(_DWORD *a1);
unsigned int __cdecl sub_86A29(unsigned int a1);
int __cdecl sub_86AA1(int a1);
void __cdecl sub_86C57(_DWORD *a1);
char __cdecl sub_871A6(int a1);
char *__cdecl sub_87480(_DWORD *a1);
int __cdecl VEH_PhysicsNotRequired(int a1, int a2);
_DWORD *__cdecl sub_87CD3(int a1);
void __cdecl sub_88561(int a1);
int __cdecl sub_88C78(int a1, int a2, int a3);
int __cdecl sub_88D5C(int a1, unsigned int a2);
_BOOL4 __cdecl VEH_FindValidDismountSpot(float *a1, float *a2, int a3, float *a4, float *a5, int a6);
void __cdecl sub_8998D(int a1, _DWORD *a2, int a3);
int __cdecl VEH_UnlinkPlayer(_DWORD *a1, int a2);
int G_ParseScrVehicleInfo();
void *G_InitScrVehicles();
void G_SetupScrVehicles();
int G_FreeScrVehicles();
void __cdecl G_SpawnVehicle(int a1, char *s1, int a3);
int __cdecl G_FreeVehicle(int a1);
int *__cdecl G_FreeVehicleRefs(_DWORD *a1);
int *G_VehicleClientThink();
int *__cdecl G_UpdateVehicleTags(int a1);
int __cdecl G_GetVehicleInfoIndex(char *s1); // idb
char *__cdecl G_GetVehicleInfoName(__int16 a1);
int GScr_GetNumVehicles();
char *GScr_PrecacheVehicle();
int __cdecl G_IsVehicleUsable(int a1, int a2);
_DWORD *__cdecl G_IsVehicleUnusable(int a1);
_BOOL4 __cdecl G_IsVehicleImmune(int a1, int a2);
_BOOL4 __cdecl G_IsVehicleOccupantInvulnerable(int a1);
long double __cdecl G_VehicleOccupantRadiusDamageScale(int a1);
_DWORD *__cdecl G_VehiclePopOut(_DWORD *a1);
int __cdecl G_GetTankIndex(int a1);
int __cdecl G_GetTankEntNum(int a1);
unsigned int __cdecl G_GetNonPVSTankInfo(_DWORD *a1, float *a2, int a3);
int __cdecl Scr_Vehicle_Controller(int *a1, int a2);
int __cdecl Scr_Vehicle_Init(int); // weak
_DWORD *__cdecl Scr_Vehicle_Think(_DWORD *a1);
long double __cdecl Scr_Vehicle_DamageScale(int a1, int a2, int a3, float *a4, int a5);
_DWORD *__cdecl Scr_Vehicle_Pain(int a1, int a2, int a3, float *a4, int a5, int a6);
int __cdecl Scr_Vehicle_PushAway(int a1, int a2);
void Scr_Vehicle_Touch();
int __cdecl VEH_GetMinsMaxs(int a1, float *a2, float *a3);
int __cdecl VEH_CheckPushClients(int a1);
int __cdecl G_VEH_CycleSlot(_DWORD *a1, int a2);
_DWORD *__cdecl Scr_Vehicle_Use(int a1, _DWORD *a2);
int *__cdecl Scr_Vehicle_Die(int a1, int a2, int *a3, int a4, int a5, int a6, int a7);
int __cdecl SP_script_vehicle(int a1);
int __cdecl SP_script_vehicle_collmap(int a1);
int __cdecl ScriptVehicle_GetMethod(char **a1);
int __cdecl CMD_VEH_AttachPath(int a1);
_DWORD *__cdecl CMD_VEH_StartPath(int a1);
int __cdecl CMD_VEH_SetSwitchNode(int a1);
int __cdecl CMD_VEH_SetWaitNode(int a1);
void __cdecl CMD_VEH_SetWaitSpeed(int a1);
void __cdecl CMD_VEH_SetSpeed(int a1);
void __cdecl CMD_VEH_ResumeSpeed(int a1);
int __cdecl CMD_VEH_JoltBody(int a1);
int __cdecl CMD_VEH_FreeVehicle(int a1);
int __cdecl CMD_VEH_GetWheelSurface(int a1);
int __cdecl CMD_VEH_GetSpeedMPH(int a1);
_DWORD *__cdecl CMD_VEH_GetVehicleOwner(int a1);
int __cdecl CMD_VEH_MakeVehicleUsable(int a1);
unsigned int __cdecl CMD_VEH_MakeVehicleUnusable(int a1);
int __cdecl CMD_VEH_AddVehicleToCompass(int a1);
int __cdecl CMD_VEH_RemoveVehicleFromCompass(int a1);
int __cdecl CMD_VEH_StartEngineSound(int a1);
int __cdecl CMD_VEH_StopEngineSound(int a1);
_DWORD *__cdecl CMD_VEH_SetTurretTargetVec(int a1);
int __cdecl CMD_VEH_SetTurretTargetEnt(int a1);
_DWORD *__cdecl CMD_VEH_ClearTurretTarget(int a1);
int __cdecl CMD_VEH_FireTurret(int a1);
int __cdecl CMD_VEH_FireAltTurret(int a1);
int __cdecl G_VEH_FireGunner(int a1, int a2);
int __cdecl CMD_VEH_FireGunner(int a1);
int __cdecl CMD_VEH_IsTurretReady(int a1);
int __cdecl CMD_VEH_GetFireTime(int a1);
int __cdecl CMD_VEH_GetAltHeat(int a1);
int __cdecl CMD_VEH_GetAltOverheating(int a1);
int __cdecl CMD_VEH_GetGunnerOverheating(int a1);
int __cdecl CMD_VEH_GetGunnerHeat(int a1);
int __cdecl CMD_VEH_GetDismountSpot(int a1);
int __cdecl G_PlayerVehiclePositionAndBlend(int *a1);
int __cdecl script_vehicle_owner_enable(int a1);
int __cdecl SP_script_vehicle_owner_icon(_DWORD *a1);
void sub_91A40();
int __cdecl Com_BeginParseSession(char *src); // idb
char *Com_EndParseSession();
void *Com_ResetParseSessions();
int __cdecl Com_SetSpaceDelimited(int a1);
int __cdecl Com_SetCSV(int a1);
int __cdecl Com_SetParseNegativeNumbers(int a1);
int Com_GetCurrentParseLine();
int Com_ScriptError(char *format, ...);
int Com_ScriptWarning(char *format, ...);
int Com_UngetToken();
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2);
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl sub_91E20(_BYTE *a1, _DWORD *a2);
int __cdecl Com_Compress(_BYTE *a1);
int Com_GetLastTokenPos();
void *__cdecl sub_91FD8(_BYTE **a1, int a2);
void *__cdecl sub_9216A(char **a1, int a2);
void *__cdecl Com_Parse(char **a1);
void *__cdecl Com_ParseOnLine(char **a1);
int __cdecl Com_MatchToken(int, char *s2, int); // idb
int __cdecl Com_SkipBracedSection(_DWORD *a1, int a2);
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1);
char *__cdecl Com_ParseRestOfLine(int a1);
long double __cdecl Com_ParseFloat(int a1);
int __cdecl Com_ParseInt(int a1);
int __cdecl Com_Parse1DMatrix(int a1, int a2, int a3);
int __cdecl Com_Parse2DMatrix(int a1, int a2, int a3, int a4);
int __cdecl Com_Parse3DMatrix(int a1, int a2, int a3, int a4, int a5);
void sub_92C98();
int __cdecl ColorIndex(char a1);
long double __cdecl Com_Clamp(float a1, float a2, float a3);
_BYTE *__cdecl Com_SkipPath(_BYTE *a1);
_BYTE *__cdecl Com_StripExtension(_BYTE *a1, _BYTE *a2);
_BYTE *__cdecl Com_StripFilename(char *s, char *dest);
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen);
int __cdecl Com_BitCheck(int a1, int a2);
int __cdecl Com_BitSet(int a1, int a2);
int __cdecl Com_BitClear(int a1, int a2);
int __cdecl BigShort(__int16 a1);
int __cdecl BigLong(int a1);
// int __userpurge BigLong64@<eax>(int a1, int a2, int a3);
// int __userpurge LittleLong64@<eax>(int a1, int a2, int a3);
int __cdecl BigFloat(int a1);
int __cdecl ShortSwap(__int16 a1);
int __cdecl ShortNoSwap(__int16 a1);
int __cdecl LongSwap(int a1);
int __cdecl LongNoSwap(int a1);
// _DWORD *__userpurge Long64Swap@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3);
long double __cdecl FloatSwap(int a1);
long double __cdecl FloatNoSwap(float a1);
long double (__cdecl *Swap_Init())(float a1);
_BOOL4 __cdecl Q_isprint(int a1);
_BOOL4 __cdecl Q_islower(int a1);
_BOOL4 __cdecl Q_isupper(int a1);
_BOOL4 __cdecl Q_isalpha(int a1);
_BOOL4 __cdecl Q_isnumeric(int a1);
_BOOL4 __cdecl Q_isalphanumeric(int a1);
_BOOL4 __cdecl Q_isforfilename(int a1);
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2);
char *__cdecl Q_strncpyz(char *dest, char *src, int a3);
int __cdecl Q_stricmpn(char *a1, char *a2, int a3);
int __cdecl Q_strncmp(char *a1, char *a2, int a3);
int __cdecl Q_stricmp(int a1, int a2);
_BYTE *__cdecl Q_strlwr(_BYTE *a1);
_BYTE *__cdecl Q_strupr(_BYTE *a1);
int __cdecl Q_strcat(char *s, int, char *src); // idb
int __cdecl Q_DrawStrlen(_BYTE *a1);
char *__cdecl Q_CleanStr(char *a1);
int __cdecl Q_CleanCharacter(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3);
int __cdecl Q_strcasecmp(int a1, int a2);
char *va(char *format, ...);
_DWORD *__cdecl tv(int a1, int a2, int a3);
char *__cdecl Info_ValueForKey(char *s, int a2);
_BYTE *__cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3);
char *__cdecl Info_RemoveKey(char *s, char *s1);
char *__cdecl Info_RemoveKey_Big(char *s, char *s1);
_BOOL4 __cdecl Info_Validate(char *s);
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3);
char *__cdecl Info_SetValueForKey_Big(char *s, char *s1, int a3);
_BOOL4 __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, char *s, int a5, int a6, int a7);
long double __cdecl GetLeanFraction(float a1);
long double __cdecl UnGetLeanFraction(float a1);
void __cdecl AddLeanToPosition(int a1, int a2, float a3, float a4, float a5);
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3);
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3);
int Q_GetDecimalDelimiter();
int __cdecl Q_LocalizedFloatToString(float, char *s, int, int, int); // idb
long double __cdecl sub_94A75(float a1);
void sub_94A8E();
int __cdecl Scr_GetBool(int a1);
int __cdecl Scr_GetInt(int a1);
// int __userpurge Scr_GetAnim@<eax>(int a1, int a2, int a3);
// int __userpurge Scr_GetAnimTree@<eax>(int a1, int a2);
int __cdecl Scr_GetFloat(int a1);
int __cdecl Scr_GetString(int a1);
int __cdecl Scr_GetConstString(int a1);
int __cdecl Scr_GetDebugString(int a1);
int __cdecl Scr_GetIString(int a1);
int __cdecl Scr_GetConstIString(int a1);
int __cdecl Scr_GetVector(int a1, int a2);
int __cdecl Scr_GetFunc(int a1);
int __cdecl Scr_GetEntityNum(int a1, int a2);
int __cdecl Scr_GetType(int a1);
int __cdecl Scr_GetPointerType(int a1);
int Scr_GetNumParam();
int __cdecl Scr_AddBool(int a1);
int __cdecl Scr_AddInt(int a1);
int __cdecl Scr_AddFloat(int a1);
int __cdecl Scr_AddAnim(int a1);
int Scr_AddUndefined();
int __cdecl Scr_AddEntityNum(int a1, int a2);
int Scr_AddStruct();
int __cdecl Scr_AddString(int a1);
int __cdecl Scr_AddIString(int a1);
int __cdecl Scr_AddConstString(unsigned __int16 a1);
int __cdecl Scr_AddVector(int a1);
int __cdecl Scr_AddObject(unsigned __int16 a1);
int Scr_MakeArray();
int Scr_AddArray();
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1);
int __cdecl Scr_Error(int a1);
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2);
int __cdecl Scr_ParamError(int a1, int a2);
int __cdecl Scr_ObjectError(int a1);
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3);
int __cdecl Scr_FreeEntityNum(int a1, int a2);
int __cdecl Scr_GetEntityId(int a1, int a2);
int __cdecl Scr_SetClassMap(int a1, int a2);
int Scr_RemoveClassMap();
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3);
int __cdecl Scr_AddFields(int a1, int a2);
int __cdecl Scr_FindField(int a1, int a2);
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2);
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3);
int __cdecl Scr_Init(int a1, int a2, int a3);
int Scr_Shutdown();
int Scr_Abort();
int __cdecl Scr_SetLoading(int a1);
int Scr_AllocGameVariable();
int __cdecl Scr_InitSystem(int a1, int a2);
int __cdecl Scr_GetChecksum(int a1);
int Scr_HasSourceFiles();
int __cdecl Scr_SaveSource(int a1);
int __cdecl Scr_LoadSource(int a1);
int __cdecl Scr_SkipSource(int a1);
int __cdecl Scr_SavePre(int a1);
int __cdecl Scr_SavePost(int a1);
int Scr_SaveShutdown();
int __cdecl Scr_LoadPre(int a1, int a2);
int Scr_LoadShutdown();
int __cdecl Scr_LoadScript(int a1);
// int __userpurge Scr_FindAnimTree@<eax>(int a1, int a2);
int __cdecl Scr_FindAnim(int a1, int a2, int a3);
int __cdecl Scr_GetFunctionHandle(int a1, int a2);
int Scr_BeginLoadScripts();
int Scr_BeginLoadAnimTrees();
int Scr_EndLoadScripts();
int Scr_EndLoadAnimTrees();
int __cdecl Scr_PrecacheAnimTrees(int a1);
int __cdecl Scr_FreeScripts(unsigned __int8 a1);
int __cdecl Scr_FreeGameVariable(int a1);
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1);
int __cdecl Scr_IsSystemActive(unsigned __int8 a1);
int __cdecl Scr_ExecThread(int a1, int a2);
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_AddExecThread(int a1, int a2);
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1);
int __cdecl Scr_FreeThread(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1);
int __cdecl Scr_SetString(int a1, unsigned __int16 a2);
int __cdecl Scr_AllocString(int a1, int a2);
int __cdecl Scr_SetTime(int a1);
int Scr_RunCurrentThreads();
int Scr_ResetTimeout();
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4);
int __cdecl SL_ConvertToString(unsigned __int16 a1);
int __cdecl SL_GetString(int a1, unsigned __int8 a2);
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2);
int __cdecl SL_FindLowercaseString(int a1);
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3);
int __cdecl Scr_CreateCanonicalFilename(int a1);
int __cdecl Scr_GetAnimsIndex(int a1);
int __cdecl Scr_GetAnims(int a1);
int __cdecl MT_Alloc(int a1, int a2);
int __cdecl MT_Free(int a1, int a2);
int *__cdecl Scr_FarHook(int (__cdecl **a1)(_DWORD));
void sub_95B8B();
int __cdecl sub_95B90(float *a1, float *a2, int a3);
int __cdecl sub_95D7E(int, char *nptr, int); // idb
// void __usercall sub_95E32(long double a1@<st0>, int a2, char *s, int a4);
// int __usercall sub_96028@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_96094(int a1, __int16 a2);
int __cdecl sub_96178(unsigned __int16 *a1, int a2);
int __cdecl VP_GetNodeIndex(unsigned __int16 a1, float *a2);
long double __cdecl sub_9636C(__int16 a1);
long double __cdecl sub_965B8(__int16 a1);
int __cdecl sub_96804(__int16 a1, float *a2);
long double __cdecl sub_96CC2(float *a1);
long double __cdecl sub_96D3E(float *a1);
long double __cdecl sub_96DBC(float *a1);
// __int16 *__usercall sub_96E9A@<eax>(long double a1@<st0>, float *a2, int *a3);
__int16 *__cdecl sub_9707E(float *a1, float *a2);
int __cdecl sub_97194(float *a1, float *a2, __int16 a3);
int __cdecl sub_973E0(int a1);
int __cdecl sub_9743E(int a1);
__int16 *__cdecl sub_9749C(__int16 *a1);
void G_InitVehiclePaths();
int G_FreeVehiclePaths();
int G_FreeVehiclePathsScriptInfo();
int G_SetupVehiclePaths();
__int16 *G_DrawVehiclePaths();
int __cdecl G_VehInitPathPos(int a1);
int __cdecl G_VehFreePathPos(int a1);
int __cdecl G_VehSetUpPathPos(int a1, __int16 a2);
int __cdecl G_VehUpdatePathPos(int a1, __int16 a2);
void __cdecl G_VehSetSwitchNode(int a1, __int16 a2, __int16 a3);
// void __usercall SP_info_vehicle_node(long double a1@<st0>, int a2);
int __cdecl GScr_GetVehicleNodeIndex(int a1);
char **GScr_AddFieldsForVehicleNode();
int __cdecl GScr_GetVehicleNodeField(int a1, int a2);
int GScr_GetVehicleNode();
int GScr_GetVehicleNodeArray();
int GScr_GetAllVehicleNodes();
void sub_9878A();
void (*sub_98790())(void);
void sub_987D0();
int term_proc();
// int __cdecl _cxa_finalize(void *);

//-------------------------------------------------------------------------
// Data declarations

int dword_0[] = { 1179403647 }; // weak
char byte_5 = '\x01'; // weak
int elf_hash_bucket[1031] =
{
  729,
  465,
  0,
  176,
  1003,
  0,
  1324,
  0,
  782,
  1357,
  809,
  0,
  0,
  186,
  795,
  915,
  0,
  933,
  0,
  0,
  0,
  519,
  1241,
  0,
  640,
  952,
  356,
  0,
  0,
  0,
  1074,
  0,
  0,
  857,
  1376,
  1433,
  0,
  259,
  1155,
  1112,
  251,
  558,
  975,
  925,
  1403,
  1002,
  1137,
  1309,
  1289,
  1058,
  610,
  425,
  1104,
  677,
  1056,
  663,
  1266,
  0,
  0,
  985,
  0,
  60,
  0,
  1377,
  904,
  455,
  1017,
  1022,
  44,
  145,
  704,
  1174,
  553,
  1428,
  183,
  1429,
  1251,
  934,
  1290,
  1375,
  0,
  1139,
  402,
  0,
  1287,
  0,
  533,
  1209,
  580,
  605,
  0,
  1077,
  0,
  0,
  0,
  1228,
  0,
  0,
  777,
  796,
  1268,
  427,
  1160,
  0,
  1138,
  346,
  528,
  410,
  0,
  868,
  1166,
  1402,
  887,
  1359,
  733,
  31,
  142,
  626,
  1382,
  1100,
  1285,
  0,
  950,
  914,
  513,
  1386,
  916,
  1425,
  1430,
  0,
  447,
  706,
  103,
  0,
  0,
  1302,
  0,
  1092,
  0,
  1329,
  970,
  1013,
  0,
  0,
  1318,
  438,
  972,
  1238,
  92,
  0,
  0,
  750,
  347,
  0,
  1230,
  681,
  87,
  456,
  0,
  1391,
  1319,
  1420,
  500,
  0,
  0,
  0,
  913,
  506,
  198,
  1185,
  579,
  1346,
  131,
  1198,
  1110,
  0,
  0,
  124,
  0,
  1081,
  592,
  1258,
  672,
  910,
  0,
  0,
  1208,
  765,
  0,
  0,
  461,
  994,
  0,
  565,
  951,
  1069,
  1317,
  629,
  1148,
  585,
  1314,
  0,
  690,
  531,
  0,
  768,
  678,
  0,
  1326,
  349,
  214,
  1396,
  1390,
  1401,
  1218,
  1087,
  321,
  1406,
  576,
  0,
  1431,
  0,
  1014,
  1270,
  905,
  814,
  0,
  0,
  1344,
  514,
  1162,
  1265,
  1186,
  1141,
  0,
  1107,
  0,
  0,
  1153,
  936,
  1419,
  65,
  1183,
  703,
  1284,
  0,
  1252,
  718,
  0,
  0,
  0,
  722,
  919,
  62,
  0,
  624,
  899,
  971,
  598,
  1345,
  1378,
  0,
  1271,
  182,
  1342,
  900,
  1130,
  0,
  1234,
  1169,
  0,
  1372,
  0,
  0,
  1167,
  1244,
  0,
  638,
  757,
  751,
  1353,
  866,
  0,
  630,
  1182,
  0,
  286,
  1413,
  1394,
  50,
  1362,
  0,
  354,
  717,
  1223,
  0,
  1298,
  841,
  817,
  907,
  1366,
  1416,
  811,
  1349,
  1297,
  134,
  0,
  0,
  0,
  1168,
  0,
  0,
  1210,
  267,
  0,
  0,
  767,
  0,
  1315,
  0,
  1367,
  0,
  625,
  1200,
  0,
  228,
  1384,
  1149,
  831,
  0,
  0,
  1059,
  0,
  1103,
  791,
  403,
  0,
  863,
  327,
  1256,
  278,
  0,
  1374,
  1072,
  1067,
  1253,
  34,
  45,
  0,
  1355,
  1109,
  0,
  0,
  1423,
  650,
  483,
  780,
  792,
  1079,
  962,
  216,
  0,
  1065,
  0,
  0,
  328,
  1117,
  948,
  46,
  1255,
  1280,
  986,
  1086,
  1224,
  1113,
  1371,
  1197,
  654,
  220,
  1024,
  41,
  1108,
  756,
  1142,
  378,
  1292,
  1300,
  1181,
  1233,
  0,
  1250,
  1101,
  921,
  851,
  527,
  0,
  0,
  0,
  1216,
  927,
  1232,
  627,
  1176,
  1011,
  1158,
  977,
  1262,
  1399,
  33,
  1288,
  0,
  988,
  292,
  247,
  1434,
  0,
  877,
  63,
  441,
  1313,
  538,
  0,
  0,
  0,
  1124,
  1257,
  0,
  1177,
  998,
  73,
  1350,
  1001,
  609,
  858,
  253,
  358,
  842,
  318,
  401,
  0,
  0,
  634,
  969,
  771,
  958,
  111,
  1306,
  170,
  848,
  177,
  633,
  0,
  367,
  1360,
  1356,
  1341,
  662,
  0,
  1261,
  784,
  0,
  697,
  0,
  1283,
  0,
  836,
  266,
  660,
  0,
  772,
  1340,
  939,
  1418,
  1303,
  106,
  769,
  1202,
  0,
  649,
  1119,
  758,
  329,
  1278,
  1144,
  420,
  1150,
  368,
  776,
  534,
  1294,
  1348,
  1049,
  603,
  1085,
  0,
  1235,
  937,
  0,
  761,
  596,
  932,
  1296,
  643,
  1412,
  702,
  0,
  1034,
  808,
  0,
  0,
  1030,
  460,
  1126,
  665,
  0,
  0,
  180,
  589,
  0,
  0,
  504,
  1009,
  993,
  922,
  639,
  775,
  1236,
  0,
  1421,
  789,
  37,
  436,
  330,
  1055,
  1397,
  0,
  1229,
  1427,
  1400,
  705,
  1219,
  1274,
  0,
  1277,
  956,
  0,
  888,
  870,
  1032,
  875,
  700,
  873,
  0,
  976,
  1033,
  918,
  602,
  1323,
  824,
  0,
  1328,
  0,
  51,
  759,
  0,
  315,
  454,
  1330,
  849,
  0,
  285,
  0,
  516,
  1068,
  1407,
  894,
  439,
  0,
  1364,
  104,
  36,
  938,
  0,
  763,
  1248,
  1226,
  1159,
  0,
  0,
  89,
  464,
  0,
  338,
  1389,
  686,
  0,
  0,
  947,
  929,
  0,
  1195,
  741,
  673,
  753,
  1094,
  0,
  895,
  0,
  1038,
  620,
  1408,
  0,
  1276,
  1308,
  0,
  883,
  964,
  345,
  1264,
  0,
  1243,
  1175,
  1245,
  0,
  1385,
  992,
  942,
  0,
  1334,
  1147,
  53,
  1321,
  714,
  1392,
  874,
  0,
  0,
  517,
  205,
  1199,
  494,
  1080,
  0,
  509,
  636,
  1301,
  586,
  0,
  1404,
  738,
  0,
  322,
  865,
  901,
  1151,
  582,
  622,
  1363,
  995,
  924,
  0,
  0,
  1269,
  389,
  325,
  1436,
  1122,
  1316,
  452,
  1247,
  1398,
  0,
  0,
  0,
  807,
  566,
  0,
  1414,
  1207,
  1184,
  1381,
  1037,
  1180,
  816,
  1310,
  957,
  1312,
  710,
  0,
  210,
  97,
  1231,
  0,
  1057,
  0,
  890,
  1426,
  785,
  1093,
  755,
  0,
  1046,
  881,
  783,
  1205,
  1220,
  0,
  730,
  199,
  826,
  1050,
  711,
  0,
  0,
  779,
  0,
  348,
  774,
  1060,
  1192,
  909,
  1143,
  387,
  0,
  1299,
  551,
  498,
  723,
  0,
  1152,
  991,
  0,
  0,
  0,
  1422,
  0,
  0,
  1331,
  0,
  522,
  1191,
  896,
  0,
  0,
  554,
  1286,
  0,
  1417,
  1161,
  1102,
  1047,
  481,
  612,
  658,
  0,
  0,
  552,
  981,
  0,
  0,
  0,
  1373,
  0,
  1279,
  1042,
  1091,
  1325,
  1170,
  0,
  0,
  0,
  0,
  748,
  0,
  1383,
  1369,
  930,
  0,
  1127,
  959,
  0,
  355,
  1380,
  0,
  386,
  202,
  1000,
  854,
  882,
  0,
  728,
  1027,
  563,
  1066,
  1387,
  999,
  1212,
  0,
  1214,
  644,
  794,
  1254,
  1347,
  1295,
  0,
  752,
  1225,
  0,
  1335,
  0,
  1070,
  1045,
  1097,
  898,
  0,
  715,
  0,
  926,
  1388,
  850,
  0,
  1275,
  0,
  1035,
  1435,
  1293,
  793,
  0,
  1395,
  645,
  845,
  0,
  350,
  1120,
  813,
  1025,
  562,
  0,
  546,
  732,
  0,
  871,
  1021,
  0,
  211,
  1246,
  0,
  1016,
  1096,
  1336,
  984,
  0,
  1282,
  1393,
  0,
  903,
  1015,
  965,
  1338,
  0,
  1239,
  61,
  1204,
  1352,
  581,
  399,
  669,
  830,
  0,
  786,
  1370,
  1432,
  99,
  1249,
  802,
  0,
  0,
  1405,
  521,
  559,
  1193,
  1358,
  0,
  1004,
  1178,
  529,
  91,
  0,
  0,
  0,
  1089,
  407,
  1311,
  0,
  536,
  0,
  547,
  1018,
  1129,
  819,
  0,
  799,
  997,
  1095,
  165,
  1281,
  661,
  482,
  607,
  828,
  0,
  1133,
  708,
  331,
  487,
  340,
  1163,
  569,
  1307,
  1194,
  664,
  194,
  1365,
  1128,
  1259,
  621,
  0,
  897,
  0,
  1332,
  1221,
  1291,
  451,
  0,
  692,
  0,
  966,
  667,
  1411,
  35,
  990,
  511,
  1073,
  928,
  0,
  139,
  843,
  1044,
  766,
  945,
  0,
  1415,
  507,
  1123,
  655,
  298,
  0,
  0,
  138,
  1333,
  291,
  0,
  1337,
  0,
  1028,
  862,
  0,
  1116,
  0,
  0,
  1157,
  1026,
  1164,
  200,
  1322,
  1206,
  0,
  0,
  961,
  1260,
  0,
  0,
  1215,
  1106,
  805,
  1125,
  861,
  70,
  853,
  0,
  501,
  0,
  0,
  941,
  1114,
  250,
  0,
  0,
  821,
  1410,
  1088,
  557,
  0,
  1132,
  736,
  497,
  0,
  1351,
  656,
  0,
  0,
  0,
  0,
  721,
  58,
  0,
  852,
  394,
  1146,
  1222,
  653,
  823,
  0,
  982,
  1217,
  1327,
  279,
  0,
  1409,
  1053,
  0
}; // weak
char byte_98B00[19] =
{
  '\x15',
  '%',
  's',
  ':',
  ' ',
  '(',
  '%',
  's',
  ',',
  ' ',
  'l',
  'i',
  'n',
  'e',
  ' ',
  '%',
  'i',
  ')',
  '\0'
}; // idb
char byte_98B13[13] = { '\x15', '%', 's', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
char byte_98B80[64] =
{
  '\x15',
  'B',
  'G',
  '_',
  'A',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  'F',
  'o',
  'r',
  'S',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'p',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_98C40[48] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  '%',
  'i',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  '0',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  '\0'
}; // idb
char byte_99000[43] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  'n',
  '\'',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'p',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  's',
  'c',
  'r',
  'i',
  'p',
  't',
  ' ',
  '%',
  's',
  '\n',
  '\0'
}; // idb
char byte_994A0[64] =
{
  '\x15',
  'B',
  'G',
  '_',
  'G',
  'e',
  't',
  'A',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  'F',
  'o',
  'r',
  'I',
  'n',
  'd',
  'e',
  'x',
  ':',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'b',
  'o',
  'u',
  'n',
  'd',
  's',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_994E0[64] =
{
  '\x15',
  'B',
  'G',
  '_',
  'A',
  'n',
  'i',
  'm',
  'U',
  'p',
  'd',
  'a',
  't',
  'e',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  'S',
  't',
  'a',
  't',
  'e',
  'C',
  'o',
  'n',
  'd',
  'i',
  't',
  'i',
  'o',
  'n',
  's',
  ':',
  ' ',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_99540[64] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  ' ',
  '(',
  '%',
  'i',
  ')',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_99680[52] =
{
  '\x15',
  'B',
  'G',
  '_',
  'A',
  'n',
  'i',
  'm',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  'C',
  'o',
  'n',
  'd',
  'i',
  't',
  'i',
  'o',
  'n',
  's',
  ':',
  ' ',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0'
}; // idb
char byte_99780[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'i',
  'n',
  'd',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  't',
  'r',
  'e',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9A7E0[48] =
{
  '\x15',
  'B',
  'G',
  '_',
  'F',
  'i',
  'n',
  'd',
  'I',
  't',
  'e',
  'm',
  'F',
  'o',
  'r',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ':',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9A820[41] =
{
  '\x15',
  'B',
  'G',
  '_',
  'C',
  'a',
  'n',
  'I',
  't',
  'e',
  'm',
  'B',
  'e',
  'G',
  'r',
  'a',
  'b',
  'b',
  'e',
  'd',
  ':',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  '\0'
}; // idb
char byte_9A849[55] =
{
  '\x15',
  'B',
  'G',
  '_',
  'C',
  'a',
  'n',
  'I',
  't',
  'e',
  'm',
  'B',
  'e',
  'G',
  'r',
  'a',
  'b',
  'b',
  'e',
  'd',
  ':',
  ' ',
  'I',
  'T',
  '_',
  'B',
  'A',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9A880[44] =
{
  '\x15',
  'B',
  'G',
  '_',
  'E',
  'v',
  'a',
  'l',
  'u',
  'a',
  't',
  'e',
  'T',
  'r',
  'a',
  'j',
  'e',
  'c',
  't',
  'o',
  'r',
  'y',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  't',
  'r',
  'T',
  'y',
  'p',
  'e',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0'
}; // idb
char byte_9A900[48] =
{
  '\x15',
  'B',
  'G',
  '_',
  'E',
  'v',
  'a',
  'l',
  'u',
  'a',
  't',
  'e',
  'T',
  'r',
  'a',
  'j',
  'e',
  'c',
  't',
  'o',
  'r',
  'y',
  'D',
  'e',
  'l',
  't',
  'a',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  't',
  'r',
  'T',
  'y',
  'p',
  'e',
  ':',
  ' ',
  '%',
  'i',
  '\0'
}; // idb
_UNKNOWN bg_numItems; // weak
_UNKNOWN pm_ladderJumpTime; // weak
_UNKNOWN pm_prone_accelerate; // weak
_UNKNOWN pm_ducked_accelerate; // weak
_UNKNOWN pm_accelerate; // weak
_UNKNOWN pm_airaccelerate; // weak
_UNKNOWN pm_fatigueRegenDelay; // weak
float flt_9B6C0[78] =
{
   0.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   1.0,
   0.0,
   1.0,
   0.0,
   1.0,
   1.0,
  -1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
  -1.0,
   0.0,
  -1.0,
   0.0,
  -1.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0
}; // idb
_UNKNOWN bg_iNumWeaponInfoFields; // weak
char byte_9CD20[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CD60[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'c',
  'l',
  'a',
  's',
  's',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CDA0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CDE0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'l',
  'a',
  'y',
  ' ',
  'r',
  'e',
  't',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CE20[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  'l',
  'o',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CE60[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  't',
  'a',
  'n',
  'c',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CEA0[44] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'p',
  'r',
  'o',
  'j',
  'e',
  'c',
  't',
  'i',
  'l',
  'e',
  ' ',
  'e',
  'x',
  'p',
  'l',
  'o',
  's',
  'i',
  'o',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0'
}; // idb
char byte_9CECC[28] =
{
  '\x15',
  'B',
  'a',
  'd',
  ' ',
  'f',
  'i',
  'e',
  'l',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '%',
  'i',
  ' ',
  'i',
  'n',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_9CF04; // weak
void *off_9CF10 = &unk_2F7325; // weak
char byte_9CF40[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CF80[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'p',
  'p',
  'e',
  'a',
  'r',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'e',
  ' ',
  'a',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9CFC0[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'I',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'l',
  'o',
  'n',
  'g',
  ' ',
  'o',
  'f',
  ' ',
  'a',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'a',
  'r',
  's',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D000[36] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  'v',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D080[85] =
{
  '\x15',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0'
}; // idb
char byte_9D0E0[128] =
{
  '\x15',
  'S',
  'h',
  'a',
  'r',
  'e',
  'd',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'c',
  'a',
  'p',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  's',
  'h',
  'a',
  'r',
  'e',
  'd',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'c',
  'a',
  'p',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D160[96] =
{
  '\x15',
  'C',
  'l',
  'i',
  'p',
  ' ',
  'S',
  'i',
  'z',
  'e',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'c',
  'l',
  'i',
  'p',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D1C0[96] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'h',
  'a',
  'v',
  'e',
  ' ',
  's',
  'a',
  'm',
  'e',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'S',
  'l',
  'o',
  't',
  ' ',
  's',
  'e',
  't',
  't',
  'i',
  'n',
  'g',
  ' ',
  'a',
  's',
  ' ',
  'i',
  't',
  's',
  ' ',
  'a',
  'l',
  't',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D220[96] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'h',
  'a',
  'v',
  'e',
  ' ',
  's',
  'a',
  'm',
  'e',
  ' ',
  's',
  'l',
  'o',
  't',
  'S',
  't',
  'a',
  'c',
  'k',
  'a',
  'b',
  'l',
  'e',
  ' ',
  's',
  'e',
  't',
  't',
  'i',
  'n',
  'g',
  ' ',
  'a',
  's',
  ' ',
  'i',
  't',
  's',
  ' ',
  'a',
  'l',
  't',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D280[64] =
{
  '\x15',
  'c',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'i',
  'n',
  'd',
  ' ',
  'a',
  'l',
  't',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D2C0[64] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'a',
  ' ',
  'b',
  'a',
  'd',
  ' ',
  'a',
  'l',
  't',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D300[86] =
{
  '\x15',
  'T',
  'o',
  'o',
  ' ',
  'm',
  'a',
  'n',
  'y',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  'h',
  'i',
  'n',
  't',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  's',
  ' ',
  'o',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  's',
  '.',
  ' ',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  's',
  '\0'
}; // idb
char byte_9D3A0[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'c',
  'a',
  't',
  'e',
  ' ',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  'a',
  'r',
  'r',
  'a',
  'y',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9D3E0[32] =
{
  '\x15',
  'N',
  'o',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  's',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  'i',
  'n',
  ' ',
  '%',
  's',
  '.',
  '\n',
  '\0',
  '\0'
}; // idb
char byte_9D400[64] =
{
  '\x15',
  'M',
  'a',
  'x',
  ' ',
  'n',
  'u',
  'm',
  'b',
  'e',
  'r',
  ' ',
  'o',
  'f',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  's',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
float vec3_origin[3] = {  0.0,  0.0,  0.0 }; // idb
char aFlamethrowerMp[16] = "flamethrower_mp"; // weak
_UNKNOWN unk_9DD0C; // weak
_UNKNOWN unk_9DFE0; // weak
char aEGameBadclient[21] = "e \"GAME_BADCLIENTSLOT"; // weak
char aEGameClientnot_0[23] = "e \"GAME_CLIENTNOTACTIVE"; // weak
char aEGameUsernoton[23] = "e \"GAME_USERNOTONSERVER"; // weak
_UNKNOWN unk_9E960; // weak
void *off_9E980 = &unk_302061; // weak
char aGameGodmodeoff[16] = "GAME_GODMODEOFF"; // weak
char aGameGodmodeon[15] = "GAME_GODMODEON"; // weak
char aGameNotargetof[17] = "GAME_NOTARGETOFF"; // weak
char aGameNotargeton[16] = "GAME_NOTARGETON"; // weak
char aI[2] = "i"; // weak
char asc_9EA31[2] = "h"; // weak
char aS_3[4] = "%s \""; // weak
_UNKNOWN unk_9EA42; // weak
_UNKNOWN unk_9EA45; // weak
_UNKNOWN unk_9EA48; // weak
char byte_9EA49[20] =
{
  '\x15',
  '(',
  '\x14',
  'G',
  'A',
  'M',
  'E',
  '_',
  'S',
  'P',
  'E',
  'C',
  'T',
  'A',
  'T',
  'O',
  'R',
  '\x15',
  ')',
  '\0'
}; // idb
char byte_9EA5D[17] =
{
  '\x15',
  '%',
  's',
  '(',
  '\x14',
  'G',
  'A',
  'M',
  'E',
  '_',
  'D',
  'E',
  'A',
  'D',
  '\x15',
  ')',
  '\0'
}; // idb
char byte_9EA6E[4] = { '\x15', '%', 's', '\0' }; // idb
char aGameAxis[10] = "GAME_AXIS"; // weak
char aGameAllies[12] = "GAME_ALLIES"; // weak
char aS_5[3] = "%s("; // weak
char aS_4[3] = "%s("; // weak
char aS_7[3] = "%s("; // weak
char aS_6[3] = "%s("; // weak
char aE_0[3] = "e \""; // weak
char aClientkick[11] = "clientkick"; // weak
char aTempbanclient[14] = "tempBanClient"; // weak
_UNKNOWN unk_9ED60; // weak
void *off_9EE69 = (void *)0xA7325; // weak
_UNKNOWN unk_9EEA0; // weak
char aGameVoteGamety_0[18] = "GAME_VOTE_GAMETYPE"; // weak
char aGameVoteMap[13] = "GAME_VOTE_MAP"; // weak
char aGameVoteGamety[18] = "GAME_VOTE_GAMETYPE"; // weak
char aGameVoteKick[14] = "GAME_VOTE_KICK"; // weak
_UNKNOWN unk_9F00B; // weak
char aEPatch15VoteAr[30] = "e \"PATCH_1_5_VOTE_ARG_NOTVALID"; // weak
char aMenuOn[8] = "MENU_ON"; // weak
char aMenuOff[9] = "MENU_OFF"; // weak
char aPatch15VoteDra[25] = "PATCH_1_5_VOTE_DRAWFRIEND"; // weak
char aPatch15VoteKil[22] = "PATCH_1_5_VOTE_KILLCAM"; // weak
char aPatch15VoteFri[27] = "PATCH_1_5_VOTE_FRIENDLYFIRE"; // weak
_UNKNOWN unk_9F19F; // weak
char aMenuReflect[13] = "MENU_REFLECT"; // weak
char aMenuShared[12] = "MENU_SHARED"; // weak
char aEGameCalledavo[19] = "e \"GAME_CALLEDAVOTE"; // weak
char aE_1[3] = "e \""; // weak
char aEGameUsage[13] = "e \"GAME_USAGE"; // weak
char aEPatch15Timeou_5[30] = "e \"PATCH_1_5_TIMEOUT_MAXCALLED"; // weak
char aEPatch15Timeou_6[32] = "e \"PATCH_1_5_TIMEOUT_MAXTIMEUSED"; // weak
char aPatch15Timeout[24] = "PATCH_1_5_TIMEOUT_CALLED"; // weak
char aEPatch15Timeou_7[38] = "e \"PATCH_1_5_TIMEOUT_CALLED_PLAYERNAME"; // weak
char aPatch15Timeout_0[24] = "PATCH_1_5_TIMEOUT_ENDING"; // weak
char aEPatch15Timein_1[37] = "e \"PATCH_1_5_TIMEIN_CALLED_PLAYERNAME"; // weak
char aEGameUnknowncl[28] = "e \"GAME_UNKNOWNCLIENTCOMMAND"; // weak
char byte_9F880[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9F8C0[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'p',
  'p',
  'e',
  'a',
  'r',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'e',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9F900[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'I',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'l',
  'o',
  'n',
  'g',
  ' ',
  'o',
  'f',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'a',
  'r',
  's',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_9F940[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  'v',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_9FC00 = 0; // weak
int dword_9FC04 = 1; // weak
char aFGamePickupCli[28] = "f \"GAME_PICKUP_CLIPONLY_AMMO"; // weak
char aFGamePickupAmm[19] = "f \"GAME_PICKUP_AMMO"; // weak
char aFGamePickupHea[21] = "f \"GAME_PICKUP_HEALTH"; // weak
char aFGamePickupCan[32] = "f \"GAME_PICKUP_CANTCARRYMOREAMMO"; // weak
_UNKNOWN unk_A058A; // weak
char aCodUnitedOffen[21] = "CoD:United Offensive"; // weak
char aFeb102005[12] = "Feb 10 2005"; // weak
char aEGameServer[14] = "e \"GAME_SERVER"; // weak
void *off_A1341 = (void *)0xA7325; // weak
char aPatch15Timeout_1[24] = "PATCH_1_5_TIMEOUT_ENDING"; // weak
char aTagFlash[10] = "tag_flash"; // weak
char aTagPlayer_0[11] = "tag_player"; // weak
char byte_A14E0[34] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'o',
  ' ',
  'c',
  'h',
  'i',
  'l',
  'd',
  'r',
  'e',
  'n',
  '\0'
}; // idb
char byte_A15E0[64] =
{
  '\x15',
  'G',
  '_',
  'S',
  'p',
  'a',
  'w',
  'n',
  'T',
  'u',
  'r',
  'r',
  'e',
  't',
  ':',
  ' ',
  'm',
  'a',
  'x',
  ' ',
  'n',
  'u',
  'm',
  'b',
  'e',
  'r',
  ' ',
  'o',
  'f',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  's',
  ' ',
  '(',
  '%',
  'd',
  ')',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A1620[42] =
{
  '\x15',
  'b',
  'a',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'i',
  'n',
  'f',
  'o',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  's',
  'p',
  'e',
  'c',
  'i',
  'f',
  'i',
  'e',
  'd',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  '\0'
}; // idb
_UNKNOWN unk_A1664; // weak
char byte_A16C0[36] =
{
  '\x15',
  'n',
  'o',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'i',
  'n',
  'f',
  'o',
  ' ',
  's',
  'p',
  'e',
  'c',
  'i',
  'f',
  'i',
  'e',
  'd',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  '\0'
}; // idb
_UNKNOWN unk_A1840; // weak
void *off_A1978 = &unk_303031; // weak
_UNKNOWN unk_A1A98; // weak
_UNKNOWN unk_A1AB4; // weak
char byte_A1BA0[88] =
{
  '\x15',
  'T',
  'o',
  'o',
  ' ',
  'm',
  'a',
  'n',
  'y',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  'h',
  'i',
  'n',
  't',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'k',
  'e',
  'y',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  's',
  ' ',
  'o',
  'n',
  ' ',
  't',
  'r',
  'i',
  'g',
  'g',
  'e',
  'r',
  '_',
  'u',
  's',
  'e',
  ' ',
  'e',
  'n',
  't',
  'i',
  't',
  'i',
  'e',
  's',
  '.',
  ' ',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_A248E; // weak
void *off_A2E8E = (void *)0xA7325; // weak
char aSetcullfog[11] = "setCullFog"; // weak
char aSetexpfog[10] = "setExpFog"; // weak
void *off_A4EFC = &unk_303031; // weak
_UNKNOWN unk_A5487; // weak
char byte_A54A0[44] =
{
  '\x15',
  'c',
  'l',
  'a',
  's',
  's',
  'n',
  'a',
  'm',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ',',
  ' ',
  'k',
  'e',
  'y',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ',',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ':',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0'
}; // idb
void *off_A58CC = &unk_303038; // weak
char aEGameServer_0[14] = "e \"GAME_SERVER"; // weak
char byte_A5BA7[12] = { '\x15', '%', 'c', '%', 'c', '\x14', '%', 's', '\x15', '^', '7', '\0' }; // idb
char byte_A5BB3[13] =
{
  '\x14',
  '%',
  's',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
void *off_A5BD0 = &unk_352E30; // weak
char aLocalizedStrin[17] = "localized string"; // weak
float vehCheckSolidOffsets[24] =
{
   1.2,
  -1.0,
   0.0,
   1.3,
   0.0,
   0.0,
   1.2,
   1.0,
   0.0,
  -1.25,
   1.0,
   0.0,
  -1.35,
   0.0,
   0.0,
  -1.25,
  -1.0,
   0.0,
   0.0,
   0.0,
   0.0,
   0.0,
   0.0,
   0.0
}; // idb
float flt_A66C0[78] =
{
   0.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   1.0,
   0.0,
   1.0,
   0.0,
   1.0,
   1.0,
  -1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
  -1.0,
   0.0,
  -1.0,
   0.0,
  -1.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0
}; // idb
char byte_A67FC[27] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '[',
  's',
  ']',
  '\n',
  '\0'
}; // idb
char byte_A6817[41] =
{
  '\x15',
  'B',
  'a',
  'd',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'e',
  'l',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '%',
  'i',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A68E0[36] =
{
  '\x15',
  'S',
  'c',
  'r',
  'i',
  'p',
  't',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  ' ',
  'n',
  'e',
  'e',
  'd',
  's',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6CA8[56] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'o',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6CE0[36] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'o',
  ' ',
  't',
  'a',
  'g',
  '_',
  'b',
  'a',
  'r',
  'r',
  'e',
  'l',
  '\n',
  '\0',
  '\0'
}; // idb
char byte_A6D80[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'A',
  't',
  't',
  'a',
  'c',
  'h',
  'B',
  'o',
  'n',
  'e',
  'I',
  'n',
  'd',
  'e',
  'x',
  'F',
  'o',
  'r',
  'P',
  'o',
  's',
  'i',
  't',
  'i',
  'o',
  'n',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'p',
  'o',
  's',
  'i',
  't',
  'i',
  'o',
  'n',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6E40[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'i',
  's',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'u',
  's',
  'i',
  'n',
  'g',
  ' ',
  'a',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6E80[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'a',
  'n',
  ' ',
  'o',
  'w',
  'n',
  'e',
  'r',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6EE0[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'i',
  's',
  ' ',
  'f',
  'u',
  'l',
  'l',
  ',',
  ' ',
  's',
  'h',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'b',
  'e',
  ' ',
  'u',
  's',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6F20[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'A',
  't',
  't',
  'a',
  'c',
  'h',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  'i',
  'n',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '(',
  '%',
  's',
  ')',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6F60[96] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'T',
  'r',
  'y',
  'i',
  'n',
  'g',
  ' ',
  't',
  'o',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'w',
  'i',
  't',
  'h',
  'o',
  'u',
  't',
  ' ',
  'a',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  't',
  'a',
  'g',
  '_',
  'p',
  'l',
  'a',
  'y',
  'e',
  'r',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A6FC0[96] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'T',
  'r',
  'y',
  'i',
  'n',
  'g',
  ' ',
  't',
  'o',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'w',
  'i',
  't',
  'h',
  'o',
  'u',
  't',
  ' ',
  'a',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  't',
  'a',
  'g',
  '_',
  's',
  'e',
  'c',
  'o',
  'n',
  'd',
  'a',
  'r',
  'y',
  '_',
  'g',
  'u',
  'n',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7020[96] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'T',
  'r',
  'y',
  'i',
  'n',
  'g',
  ' ',
  't',
  'o',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'w',
  'i',
  't',
  'h',
  'o',
  'u',
  't',
  ' ',
  'a',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  't',
  'a',
  'g',
  '_',
  'b',
  'o',
  'd',
  'y',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7080[51] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'L',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'C',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'l',
  'i',
  'n',
  'k',
  ' ',
  't',
  'o',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0'
}; // idb
char byte_A70E0[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'U',
  'n',
  'l',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'u',
  's',
  'i',
  'n',
  'g',
  ' ',
  'a',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7120[64] =
{
  '\x15',
  'V',
  'E',
  'H',
  '_',
  'U',
  'n',
  'l',
  'i',
  'n',
  'k',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ':',
  ' ',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'd',
  'o',
  'e',
  's',
  'n',
  '\'',
  't',
  ' ',
  'h',
  'a',
  'v',
  'e',
  ' ',
  'a',
  'n',
  ' ',
  'o',
  'w',
  'n',
  'e',
  'r',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_A71B0; // weak
char byte_A71C0[45] =
{
  '\x15',
  'M',
  'a',
  'x',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  's',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0'
}; // idb
char byte_A7200[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7240[34] =
{
  '\x15',
  'F',
  'i',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  '\n',
  '\0'
}; // idb
char byte_A7262[30] =
{
  '\x15',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  ' ',
  'i',
  's',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'i',
  'g',
  '\n',
  '\0'
}; // idb
char byte_A7280[33] =
{
  '\x15',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'v',
  'a',
  'l',
  'i',
  'd',
  '\n',
  '\0'
}; // idb
char byte_A72BC[36] =
{
  '\x15',
  'H',
  'i',
  't',
  ' ',
  'm',
  'a',
  'x',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'c',
  'o',
  'u',
  'n',
  't',
  ' ',
  '[',
  '%',
  'd',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A72E0[42] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'f',
  'i',
  'n',
  'd',
  ' ',
  'i',
  'n',
  'f',
  'o',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  's',
  'c',
  'r',
  'i',
  'p',
  't',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0'
}; // idb
char byte_A74C0[35] =
{
  '\x15',
  'G',
  '_',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  'P',
  'o',
  'p',
  'O',
  'u',
  't',
  ':',
  ' ',
  'P',
  'o',
  'p',
  'o',
  'u',
  't',
  ' ',
  'd',
  'i',
  's',
  'a',
  'b',
  'l',
  'e',
  'd',
  '\n',
  '\0'
}; // idb
char byte_A7500[64] =
{
  '\x15',
  'G',
  '_',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  'P',
  'o',
  'p',
  'O',
  'u',
  't',
  ':',
  ' ',
  'T',
  'r',
  'y',
  'i',
  'n',
  'g',
  ' ',
  't',
  'o',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'w',
  'i',
  't',
  'h',
  'o',
  'u',
  't',
  ' ',
  'a',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7540[52] =
{
  '\x15',
  'G',
  '_',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  'P',
  'o',
  'p',
  'O',
  'u',
  't',
  ':',
  ' ',
  'C',
  'a',
  'n',
  'n',
  'o',
  't',
  ' ',
  'l',
  'i',
  'n',
  'k',
  ' ',
  't',
  'o',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'b',
  'o',
  'n',
  'e',
  ' ',
  '[',
  '%',
  's',
  ']',
  '\n',
  '\0'
}; // idb
char byte_A7A80[64] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'o',
  ' ',
  'c',
  'h',
  'i',
  'l',
  'd',
  'r',
  'e',
  'n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char aWarn[4] = "WARN"; // weak
int dword_A7AC4 = 977751625; // weak
int dword_A7AC8 = 1868718368; // weak
int dword_A7ACC = 1852404850; // weak
int dword_A7AD0 = 1819287655; // weak
int dword_A7AD4 = 1919252833; // weak
int dword_A7AD8 = 1936683040; // weak
int dword_A7ADC = 1869182057; // weak
int dword_A7AE0 = 1735289198; // weak
int dword_A7AE4 = 544108320; // weak
int dword_A7AE8 = 1920103796; // weak
int dword_A7AEC = 1931506789; // weak
int dword_A7AF0 = 1701015145; // weak
char aSDoesNotExist[22] = " '%s' does not exist\n"; // weak
char byte_A7B80[64] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'B',
  'e',
  'g',
  'i',
  'n',
  'P',
  'a',
  'r',
  's',
  'e',
  'S',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ':',
  ' ',
  's',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7BC0[40] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'E',
  'n',
  'd',
  'P',
  'a',
  'r',
  's',
  'e',
  'S',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ':',
  ' ',
  's',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ' ',
  'u',
  'n',
  'd',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  '\0'
}; // idb
char byte_A7BE8[22] =
{
  '\x15',
  'F',
  'i',
  'l',
  'e',
  ' ',
  '%',
  's',
  ',',
  ' ',
  'l',
  'i',
  'n',
  'e',
  ' ',
  '%',
  'i',
  ':',
  ' ',
  '%',
  's',
  '\0'
}; // idb
char byte_A7C2B[27] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'P',
  'a',
  'r',
  's',
  'e',
  'E',
  'x',
  't',
  ':',
  ' ',
  'N',
  'U',
  'L',
  'L',
  ' ',
  'd',
  'a',
  't',
  'a',
  '_',
  'p',
  '\0'
}; // idb
void *off_A7C64 = &unk_290028; // weak
_UNKNOWN colorRed; // weak
_UNKNOWN colorGreen; // weak
_UNKNOWN colorYellow; // weak
_UNKNOWN colorMagenta; // weak
_UNKNOWN colorCyan; // weak
_UNKNOWN colorMdCyan; // weak
_UNKNOWN colorWhite; // weak
char byte_A7DB5[43] =
{
  '\x15',
  'Q',
  '_',
  's',
  't',
  'r',
  'c',
  'a',
  't',
  ':',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  'e',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7DE0[46] =
{
  '\x15',
  'A',
  't',
  't',
  'e',
  'm',
  'p',
  't',
  'e',
  'd',
  ' ',
  't',
  'o',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'r',
  'u',
  'n',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'i',
  'n',
  ' ',
  'c',
  'a',
  'l',
  'l',
  ' ',
  't',
  'o',
  ' ',
  'v',
  'a',
  '(',
  ')',
  '\n',
  '\0'
}; // idb
_UNKNOWN unk_A7E0E; // weak
char byte_A7E20[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'V',
  'a',
  'l',
  'u',
  'e',
  'F',
  'o',
  'r',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7E60[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'R',
  'e',
  'm',
  'o',
  'v',
  'e',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7EA0[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'R',
  'e',
  'm',
  'o',
  'v',
  'e',
  'K',
  'e',
  'y',
  '_',
  'B',
  'i',
  'g',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7EE0[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'S',
  'e',
  't',
  'V',
  'a',
  'l',
  'u',
  'e',
  'F',
  'o',
  'r',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A7F20[60] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'k',
  'e',
  'y',
  's',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'a',
  ' ',
  '\\',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_A7F5C[] = { 0 }; // weak
int dword_A7F60 = 1851867925; // weak
char byte_A7FA0[24] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'k',
  'e',
  'y',
  's',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'a',
  ' ',
  '\"'
}; // idb
char aKeySValueS[23] = "\nkey: '%s'\nvalue: '%s'"; // weak
char byte_A7FE0[96] =
{
  '\x15',
  'S',
  'e',
  'r',
  'v',
  'e',
  'r',
  ' ',
  'i',
  'n',
  'f',
  'o',
  ' ',
  'b',
  'u',
  'f',
  'f',
  'e',
  'r',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  ',',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'i',
  'n',
  'c',
  'l',
  'u',
  'd',
  'i',
  'n',
  'g',
  ' ',
  'k',
  'e',
  'y',
  '/',
  'v',
  'a',
  'l',
  'u',
  'e',
  ' ',
  'p',
  'a',
  'i',
  'r',
  ' ',
  'i',
  'n',
  ' ',
  'r',
  'e',
  's',
  'p',
  'o',
  'n',
  's',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A8040[96] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  '\n',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A80A0[72] =
{
  '\x15',
  'B',
  'I',
  'G',
  ' ',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  '\n',
  '%',
  's',
  '\n',
  '\0'
}; // idb
char byte_A80E8[20] =
{
  '\x15',
  'B',
  'a',
  'd',
  ' ',
  'f',
  'i',
  'e',
  'l',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '%',
  'i',
  '\n',
  '\0'
}; // idb
char byte_A8220[56] =
{
  '\x15',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'p',
  'a',
  't',
  'h',
  ' ',
  'n',
  'o',
  'd',
  'e',
  ' ',
  'a',
  't',
  '(',
  ' ',
  '%',
  'f',
  ',',
  ' ',
  '%',
  'f',
  ',',
  ' ',
  '%',
  'f',
  ' ',
  ')',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'e',
  'g',
  'a',
  't',
  'i',
  'v',
  'e',
  ' ',
  's',
  'p',
  'e',
  'e',
  'd',
  '\n',
  '\0'
}; // idb
char byte_A8280[64] =
{
  '\x15',
  'H',
  'i',
  't',
  ' ',
  'm',
  'a',
  'x',
  ' ',
  'v',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'p',
  'a',
  't',
  'h',
  ' ',
  'n',
  'o',
  'd',
  'e',
  ' ',
  'c',
  'o',
  'u',
  'n',
  't',
  ' ',
  '[',
  '%',
  'd',
  ']',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_A82C0[56] =
{
  '\x15',
  'V',
  'e',
  'h',
  'i',
  'c',
  'l',
  'e',
  ' ',
  'p',
  'a',
  't',
  'h',
  ' ',
  'n',
  'o',
  'd',
  'e',
  '(',
  ' ',
  '%',
  'f',
  ',',
  ' ',
  '%',
  'f',
  ',',
  ' ',
  '%',
  'f',
  ' ',
  ')',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'n',
  'o',
  ' ',
  'n',
  'a',
  'm',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
void *off_A9000 = &off_A9000; // weak
int off_A9004[7] = { 735248, 0, 0, 0, 0, 0, 0 }; // weak
int dword_A9008 = 0; // weak
int dword_A900C = 0; // weak
char *off_A9020 = "mp/playeranim.script"; // weak
char *animStateStr = "RELAXED"; // weak
char *off_A9080 = "** UNUSED **"; // weak
char *off_A9120 = "PAIN"; // weak
char *animBodyPartsStr = "** UNUSED **"; // weak
char *off_A93C0 = "WEAPONS"; // weak
char *off_A9420[6] = { "back_low", "back_mid", "back_up", "neck", "head", "pelvis" }; // weak
char *off_A9440 = "defines"; // weak
int dword_A9480 = 0; // weak
int (*off_A9484)[256] = &weaponStrings; // weak
_UNKNOWN unk_A94E0; // weak
_UNKNOWN unk_A94EC; // weak
_UNKNOWN unk_A94F8; // weak
void *pEventSingleClientList = &iSingleClientEvents; // weak
_DWORD bg_itemlist[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
_UNKNOWN c_pmove; // weak
_UNKNOWN unk_AB200; // weak
_UNKNOWN unk_AB280; // weak
_UNKNOWN unk_AB300; // weak
_UNKNOWN unk_AB3E0; // weak
int dword_AB444 = 0; // weak
int dword_AB448 = 0; // weak
int dword_AB44C = -1; // weak
int dword_AB450 = -1; // weak
char *bg_szWeaponsFolder[11] =
{
  "weapons/mp",
  "bullet",
  "grenade",
  "projectile",
  "spotter",
  "gas",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "Gewehr43"
}; // weak
char *off_AB468[10] =
{
  "bullet",
  "grenade",
  "projectile",
  "spotter",
  "gas",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "Gewehr43"
}; // weak
char *off_AB47C[5] = { "none", "crosshair", "FG42", "Springfield", "Gewehr43" }; // weak
char *off_AB4A0[11] =
{
  "none",
  "primary",
  "primaryb",
  "pistol",
  "grenade",
  "smokegrenade",
  "satchel",
  "binocular",
  "stand",
  "duck",
  "prone"
}; // weak
char *off_AB4C0[3] = { "stand", "duck", "prone" }; // weak
char *off_AB4E0[17] =
{
  "rifle",
  "mg",
  "smg",
  "lmg",
  "pistol",
  "grenade",
  "rocketlauncher",
  "turret",
  "spotter",
  "non-player",
  "flamethrower",
  "smg",
  "pistol",
  "rifle",
  "lmg",
  "hmg",
  "umg"
}; // weak
char *off_AB50C[6] = { "smg", "pistol", "rifle", "lmg", "hmg", "umg" }; // weak
char *off_AB540[9] =
{
  "grenade",
  "smoke",
  "rocket",
  "molotov",
  "artillery",
  "mortar",
  "tank",
  &off_9BCB6,
  "none"
}; // weak
char *off_AB580 = "displayName"; // weak
float bytedirs[486] =
{
  -0.52573103,
   0.0,
   0.85065103,
  -0.44286299,
   0.238856,
   0.86418802,
  -0.29524201,
   0.0,
   0.955423,
  -0.309017,
   0.5,
   0.809017,
  -0.16246,
   0.26286599,
   0.951056,
   0.0,
   0.0,
   1.0,
   0.0,
   0.85065103,
   0.52573103,
  -0.14762101,
   0.71656698,
   0.68171799,
   0.14762101,
   0.71656698,
   0.68171799,
   0.0,
   0.52573103,
   0.85065103,
   0.309017,
   0.5,
   0.809017,
   0.52573103,
   0.0,
   0.85065103,
   0.29524201,
   0.0,
   0.955423,
   0.44286299,
   0.238856,
   0.86418802,
   0.16246,
   0.26286599,
   0.951056,
  -0.68171799,
   0.14762101,
   0.71656698,
  -0.809017,
   0.309017,
   0.5,
  -0.58778501,
   0.42532501,
   0.688191,
  -0.85065103,
   0.52573103,
   0.0,
  -0.86418802,
   0.44286299,
   0.238856,
  -0.71656698,
   0.68171799,
   0.14762101,
  -0.688191,
   0.58778501,
   0.42532501,
  -0.5,
   0.809017,
   0.309017,
  -0.238856,
   0.86418802,
   0.44286299,
  -0.42532501,
   0.688191,
   0.58778501,
  -0.71656698,
   0.68171799,
  -0.14762101,
  -0.5,
   0.809017,
  -0.309017,
  -0.52573103,
   0.85065103,
   0.0,
   0.0,
   0.85065103,
  -0.52573103,
  -0.238856,
   0.86418802,
  -0.44286299,
   0.0,
   0.955423,
  -0.29524201,
  -0.26286599,
   0.951056,
  -0.16246,
   0.0,
   1.0,
   0.0,
   0.0,
   0.955423,
   0.29524201,
  -0.26286599,
   0.951056,
   0.16246,
   0.238856,
   0.86418802,
   0.44286299,
   0.26286599,
   0.951056,
   0.16246,
   0.5,
   0.809017,
   0.309017,
   0.238856,
   0.86418802,
  -0.44286299,
   0.26286599,
   0.951056,
  -0.16246,
   0.5,
   0.809017,
  -0.309017,
   0.85065103,
   0.52573103,
   0.0,
   0.71656698,
   0.68171799,
   0.14762101,
   0.71656698,
   0.68171799,
  -0.14762101,
   0.52573103,
   0.85065103,
   0.0,
   0.42532501,
   0.688191,
   0.58778501,
   0.86418802,
   0.44286299,
   0.238856,
   0.688191,
   0.58778501,
   0.42532501,
   0.809017,
   0.309017,
   0.5,
   0.68171799,
   0.14762101,
   0.71656698,
   0.58778501,
   0.42532501,
   0.688191,
   0.955423,
   0.29524201,
   0.0,
   1.0,
   0.0,
   0.0,
   0.951056,
   0.16246,
   0.26286599,
   0.85065103,
  -0.52573103,
   0.0,
   0.955423,
  -0.29524201,
   0.0,
   0.86418802,
  -0.44286299,
   0.238856,
   0.951056,
  -0.16246,
   0.26286599,
   0.809017,
  -0.309017,
   0.5,
   0.68171799,
  -0.14762101,
   0.71656698,
   0.85065103,
   0.0,
   0.52573103,
   0.86418802,
   0.44286299,
  -0.238856,
   0.809017,
   0.309017,
  -0.5,
   0.951056,
   0.16246,
  -0.26286599,
   0.52573103,
   0.0,
  -0.85065103,
   0.68171799,
   0.14762101,
  -0.71656698,
   0.68171799,
  -0.14762101,
  -0.71656698,
   0.85065103,
   0.0,
  -0.52573103,
   0.809017,
  -0.309017,
  -0.5,
   0.86418802,
  -0.44286299,
  -0.238856,
   0.951056,
  -0.16246,
  -0.26286599,
   0.14762101,
   0.71656698,
  -0.68171799,
   0.309017,
   0.5,
  -0.809017,
   0.42532501,
   0.688191,
  -0.58778501,
   0.44286299,
   0.238856,
  -0.86418802,
   0.58778501,
   0.42532501,
  -0.688191,
   0.688191,
   0.58778501,
  -0.42532501,
  -0.14762101,
   0.71656698,
  -0.68171799,
  -0.309017,
   0.5,
  -0.809017,
   0.0,
   0.52573103,
  -0.85065103,
  -0.52573103,
   0.0,
  -0.85065103,
  -0.44286299,
   0.238856,
  -0.86418802,
  -0.29524201,
   0.0,
  -0.955423,
  -0.16246,
   0.26286599,
  -0.951056,
   0.0,
   0.0,
  -1.0,
   0.29524201,
   0.0,
  -0.955423,
   0.16246,
   0.26286599,
  -0.951056,
  -0.44286299,
  -0.238856,
  -0.86418802,
  -0.309017,
  -0.5,
  -0.809017,
  -0.16246,
  -0.26286599,
  -0.951056,
   0.0,
  -0.85065103,
  -0.52573103,
  -0.14762101,
  -0.71656698,
  -0.68171799,
   0.14762101,
  -0.71656698,
  -0.68171799,
   0.0,
  -0.52573103,
  -0.85065103,
   0.309017,
  -0.5,
  -0.809017,
   0.44286299,
  -0.238856,
  -0.86418802,
   0.16246,
  -0.26286599,
  -0.951056,
   0.238856,
  -0.86418802,
  -0.44286299,
   0.5,
  -0.809017,
  -0.309017,
   0.42532501,
  -0.688191,
  -0.58778501,
   0.71656698,
  -0.68171799,
  -0.14762101,
   0.688191,
  -0.58778501,
  -0.42532501,
   0.58778501,
  -0.42532501,
  -0.688191,
   0.0,
  -0.955423,
  -0.29524201,
   0.0,
  -1.0,
   0.0,
   0.26286599,
  -0.951056,
  -0.16246,
   0.0,
  -0.85065103,
   0.52573103,
   0.0,
  -0.955423,
   0.29524201,
   0.238856,
  -0.86418802,
   0.44286299,
   0.26286599,
  -0.951056,
   0.16246,
   0.5,
  -0.809017,
   0.309017,
   0.71656698,
  -0.68171799,
   0.14762101,
   0.52573103,
  -0.85065103,
   0.0,
  -0.238856,
  -0.86418802,
  -0.44286299,
  -0.5,
  -0.809017,
  -0.309017,
  -0.26286599,
  -0.951056,
  -0.16246,
  -0.85065103,
  -0.52573103,
   0.0,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.68171799,
   0.14762101,
  -0.52573103,
  -0.85065103,
   0.0,
  -0.5,
  -0.809017,
   0.309017,
  -0.238856,
  -0.86418802,
   0.44286299,
  -0.26286599,
  -0.951056,
   0.16246,
  -0.86418802,
  -0.44286299,
   0.238856,
  -0.809017,
  -0.309017,
   0.5,
  -0.688191,
  -0.58778501,
   0.42532501,
  -0.68171799,
  -0.14762101,
   0.71656698,
  -0.44286299,
  -0.238856,
   0.86418802,
  -0.58778501,
  -0.42532501,
   0.688191,
  -0.309017,
  -0.5,
   0.809017,
  -0.14762101,
  -0.71656698,
   0.68171799,
  -0.42532501,
  -0.688191,
   0.58778501,
  -0.16246,
  -0.26286599,
   0.951056,
   0.44286299,
  -0.238856,
   0.86418802,
   0.16246,
  -0.26286599,
   0.951056,
   0.309017,
  -0.5,
   0.809017,
   0.14762101,
  -0.71656698,
   0.68171799,
   0.0,
  -0.52573103,
   0.85065103,
   0.42532501,
  -0.688191,
   0.58778501,
   0.58778501,
  -0.42532501,
   0.688191,
   0.688191,
  -0.58778501,
   0.42532501,
  -0.955423,
   0.29524201,
   0.0,
  -0.951056,
   0.16246,
   0.26286599,
  -1.0,
   0.0,
   0.0,
  -0.85065103,
   0.0,
   0.52573103,
  -0.955423,
  -0.29524201,
   0.0,
  -0.951056,
  -0.16246,
   0.26286599,
  -0.86418802,
   0.44286299,
  -0.238856,
  -0.951056,
   0.16246,
  -0.26286599,
  -0.809017,
   0.309017,
  -0.5,
  -0.86418802,
  -0.44286299,
  -0.238856,
  -0.951056,
  -0.16246,
  -0.26286599,
  -0.809017,
  -0.309017,
  -0.5,
  -0.68171799,
   0.14762101,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.85065103,
   0.0,
  -0.52573103,
  -0.688191,
   0.58778501,
  -0.42532501,
  -0.58778501,
   0.42532501,
  -0.688191,
  -0.42532501,
   0.688191,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.58778501,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.688191,
  -0.58778501,
  -0.42532501
}; // idb
int dword_ACAD8 = -1985229329; // weak
int dword_ACADC = -1; // weak
float flt_ACAE0 =  40.0; // weak
float flt_ACAE4 =  40.0; // weak
float flt_ACAE8 =  52.0; // weak
char *off_ACB00 = "name"; // weak
_DWORD playerMins[3] = { -1049624576, -1049624576, 0 }; // idb
_DWORD playerMaxs[8] = { 1097859072, 1097859072, 1116733440, 0, 0, 0, 0, 0 }; // idb
char *off_ACC80 = "giveweapon"; // weak
int (__cdecl *off_ACC84)(char) = &PlayerCmd_giveWeapon; // weak
char *off_ACE60[7] =
{
  "GAME_GC_HOLDYOURPOSITION",
  "GAME_GC_HOLDTHISPOSITION",
  "GAME_GC_COMEHERE",
  "GAME_GC_COVERME",
  "GAME_GC_GUARDLOCATION",
  "GAME_GC_SEARCHDESTROY",
  "GAME_GC_REPORT"
}; // weak
_UNKNOWN bulletPriorityMap; // weak
_UNKNOWN riflePriorityMap; // weak
char *off_ACEC0[19] =
{
  "none",
  "helmet",
  "head",
  "neck",
  "torso_upper",
  "torso_lower",
  "right_arm_upper",
  "left_arm_upper",
  "right_arm_lower",
  "left_arm_lower",
  "right_hand",
  "left_hand",
  "right_leg_upper",
  "left_leg_upper",
  "right_leg_lower",
  "left_leg_lower",
  "right_foot",
  "left_foot",
  "gun"
}; // weak
char *modNames[27] =
{
  "MOD_UNKNOWN",
  "MOD_PISTOL_BULLET",
  "MOD_RIFLE_BULLET",
  "MOD_GRENADE",
  "MOD_GRENADE_SPLASH",
  "MOD_PROJECTILE",
  "MOD_PROJECTILE_SPLASH",
  "MOD_MELEE",
  "MOD_HEAD_SHOT",
  "MOD_MORTAR",
  "MOD_MORTAR_SPLASH",
  "MOD_DYNAMITE",
  "MOD_DYNAMITE_SPLASH",
  "MOD_ARTILLERY",
  "MOD_ARTILLERY_SPLASH",
  "MOD_WATER",
  "MOD_CRUSH",
  "MOD_CRUSH_TANK",
  "MOD_CRUSH_JEEP",
  "MOD_TELEFRAG",
  "MOD_FALLING",
  "MOD_SUICIDE",
  "MOD_TRIGGER_HURT",
  "MOD_EXPLOSIVE",
  "MOD_COLLISION",
  "MOD_FLAME",
  "MOD_MELEE_BINOCULARS"
}; // weak
void *off_ACFA0 = &unk_9FCA0; // weak
char *off_AD0A0 = "settext"; // weak
int (__cdecl *off_AD0A4)(int) = &sub_526F0; // weak
char *off_AD110[6] = { "default", "bigfixed", "smallfixed", "left", "center", "right" }; // weak
char *off_AD11C[3] = { "left", "center", "right" }; // weak
void *off_AD128 = &unk_9FD0F; // weak
int off_AD134[3] = { 132, 0, 0 }; // weak
int (*gameCvarTable)[72] = &g_cheats; // weak
void *hintStrings = &unk_A1840; // weak
char *off_ADDD0[3] = { "entity", "hudelem", "vehiclenode" }; // weak
char *functions = "print"; // weak
char *off_AE380 = "getstance"; // weak
int (__cdecl *off_AE384)(int) = &sub_68590; // weak
char *off_AE540 = "moveto"; // weak
int (__cdecl *off_AE544)(char) = &ScriptEntCmd_MoveTo; // weak
char *off_AE5A0 = "classname"; // weak
char *spawns = "info_null"; // weak
int (__cdecl *dword_AE908)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0xFFFFFFFF; // weak
float flt_AE90C =  0.0; // weak
float flt_AE910 = -1.0; // weak
float flt_AE914 =  0.0; // weak
int dword_AE918 = 0; // weak
int dword_AE91C = 0; // weak
int dword_AE920 = 1065353216; // weak
float flt_AE924 =  0.0; // weak
float flt_AE928 = -2.0; // weak
float flt_AE92C =  0.0; // weak
int dword_AE930 = 0; // weak
int dword_AE934 = 0; // weak
int dword_AE938 = -1082130432; // weak
_UNKNOWN unk_AE93C; // weak
_UNKNOWN unk_AE948; // weak
int dword_AE954 = 0; // weak
char *off_AE960[25] =
{
  "** unknown **",
  "4 wheel",
  "tank",
  "plane",
  "boat",
  "artillery",
  "tag_wheel_front_left",
  "tag_wheel_front_right",
  "tag_wheel_back_left",
  "tag_wheel_back_right",
  "tag_wheel_middle_left",
  "tag_wheel_middle_right",
  "tag_flash",
  "tag_flash_11",
  "tag_flash_2",
  "tag_flash_22",
  "tag_altfire",
  "tag_altfire_11",
  "tag_altfire_2",
  "tag_altfire_22",
  "tag_secondary_flash",
  "tag_secondary_flash_11",
  "tag_secondary_flash_2",
  "tag_secondary_flash_22",
  "type"
}; // weak
char *off_AE978[19] =
{
  "tag_wheel_front_left",
  "tag_wheel_front_right",
  "tag_wheel_back_left",
  "tag_wheel_back_right",
  "tag_wheel_middle_left",
  "tag_wheel_middle_right",
  "tag_flash",
  "tag_flash_11",
  "tag_flash_2",
  "tag_flash_22",
  "tag_altfire",
  "tag_altfire_11",
  "tag_altfire_2",
  "tag_altfire_22",
  "tag_secondary_flash",
  "tag_secondary_flash_11",
  "tag_secondary_flash_2",
  "tag_secondary_flash_22",
  "type"
}; // weak
char *off_AE990[13] =
{
  "tag_flash",
  "tag_flash_11",
  "tag_flash_2",
  "tag_flash_22",
  "tag_altfire",
  "tag_altfire_11",
  "tag_altfire_2",
  "tag_altfire_22",
  "tag_secondary_flash",
  "tag_secondary_flash_11",
  "tag_secondary_flash_2",
  "tag_secondary_flash_22",
  "type"
}; // weak
char *off_AE9A0[9] =
{
  "tag_altfire",
  "tag_altfire_11",
  "tag_altfire_2",
  "tag_altfire_22",
  "tag_secondary_flash",
  "tag_secondary_flash_11",
  "tag_secondary_flash_2",
  "tag_secondary_flash_22",
  "type"
}; // weak
char *off_AE9B0[5] =
{
  "tag_secondary_flash",
  "tag_secondary_flash_11",
  "tag_secondary_flash_2",
  "tag_secondary_flash_22",
  "type"
}; // weak
char *off_AE9C0 = "type"; // weak
char *off_AEC80 = "attachpath"; // weak
int (__cdecl *off_AEC84)(int) = &CMD_VEH_AttachPath; // weak
_UNKNOWN unk_AED80; // weak
void *off_B3340 = &unk_A7B40; // weak
void *off_B337C = &unk_AED80; // weak
int dword_B3380 = 0; // weak
int dword_B3384 = 0; // weak
int dword_B3388 = 1; // weak
int dword_B338C = 1078530011; // weak
int dword_B3390 = 1078530011; // weak
int dword_B3394 = 1078530011; // weak
char *off_B33A0 = "targetname"; // weak
_UNKNOWN unk_B33F8; // weak
int dword_B3808 = 0; // weak
int dword_B3814 = 0; // weak
Elf32_Dyn *GLOBAL_OFFSET_TABLE_ = &DYNAMIC; // weak
char byte_B4840; // weak
_UNKNOWN unk_B4844; // weak
int dword_B4860; // weak
_UNKNOWN unk_B48A0; // weak
int dword_B6FB0; // weak
int dword_B6FC0[]; // weak
int dword_B6FC4; // weak
int dword_B7540[]; // weak
int dword_B7544; // weak
int dword_B7AC0; // weak
int dword_B7AC4; // weak
int dword_B7AC8; // weak
int dword_B7ACC; // weak
_BYTE byte_B7AE0[13332]; // idb
_UNKNOWN unk_BAEF4; // weak
int dword_D0180; // weak
int dword_D0380; // weak
int dword_D0580; // weak
int dword_D05A0; // weak
int dword_D07A0; // weak
int dword_D09A0; // weak
int dword_D09C0; // weak
int dword_D0BC0; // weak
int dword_D0DC0; // weak
int dword_D0DC4; // weak
int dword_D0DE0; // weak
int dword_D0DEC; // weak
_BYTE byte_D0F00[1024]; // idb
__int16 word_D1300; // weak
_DWORD dword_D1340[576]; // idb
int dword_D1C40; // weak
int dword_D1C44; // weak
int dword_D1C48; // weak
int dword_D1C60[]; // weak
int dword_D1C64; // weak
int dword_D2968; // weak
int dword_D2AC4; // weak
char byte_D2AD4[24]; // idb
_UNKNOWN unk_D2AEC; // weak
int dword_D2AF0; // weak
char byte_D2CB4[844]; // idb
_UNKNOWN unk_D3000; // weak
int dword_D3C60; // weak
int dword_D3C80; // weak
_UNKNOWN unk_D3CA0; // weak
int dword_D3DA0; // weak
_UNKNOWN unk_D3DC0; // weak
int dword_D3FC0; // weak
_UNKNOWN unk_D43C0; // weak
_DWORD dword_D43C8[16062]; // idb
char byte_E3EC0[63232]; // idb
__int16 word_F35C0; // weak
_UNKNOWN unk_F35E0; // weak
int dword_F35F0; // weak
int dword_F35F4; // weak
int dword_F35F8; // weak
int dword_F3610; // weak
int dword_F3614; // weak
_UNKNOWN unk_F3620; // weak
_UNKNOWN unk_F36D8; // weak
char byte_F37A0; // weak
int dword_F3BA0; // weak
int dword_F3BA4; // weak
int dword_F3BA8; // weak
int dword_F3BC0; // weak
_UNKNOWN unk_F3BE0; // weak
char byte_F3C40[1535]; // idb
_UNKNOWN unk_F423F; // weak
char byte_FB93F; // weak
_UNKNOWN unk_FB940; // weak
_UNKNOWN unk_103640; // weak
int (__cdecl *dword_107640)(_DWORD); // weak
int dword_107644; // weak
int (__cdecl *dword_107648)(_DWORD); // weak
int dword_10764C; // weak
int (__cdecl *dword_107650)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107654)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107658)(_DWORD); // weak
int dword_10765C; // weak
int (__cdecl *dword_107660)(_DWORD); // weak
int (__cdecl *dword_107664)(_DWORD); // weak
int (__cdecl *dword_107668)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_10766C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107670)(_DWORD); // weak
int (__cdecl *dword_107674)(_DWORD); // weak
int (__cdecl *dword_107678)(_DWORD); // weak
int (__cdecl *dword_10767C)(_DWORD); // weak
int (__cdecl *dword_107680)(_DWORD); // weak
int (__cdecl *dword_107684)(_DWORD); // weak
int (__cdecl *dword_107688)(_DWORD, _DWORD); // weak
int (__cdecl *dword_10768C)(_DWORD); // weak
int (__cdecl *dword_107690)(_DWORD); // weak
int (__cdecl *dword_107694)(_DWORD); // weak
int (__cdecl *dword_107698)(_DWORD, _DWORD); // weak
int (*dword_10769C)(void); // weak
int (__cdecl *dword_1076A0)(_DWORD); // weak
int (__cdecl *dword_1076A4)(_DWORD); // weak
int (__cdecl *dword_1076A8)(_DWORD); // weak
int (__cdecl *dword_1076AC)(_DWORD); // weak
int (*dword_1076B0)(void); // weak
int (__cdecl *dword_1076B4)(_DWORD, _DWORD); // weak
int (*dword_1076B8)(void); // weak
int (__cdecl *dword_1076BC)(_DWORD); // weak
int (__cdecl *dword_1076C0)(_DWORD); // weak
int (__cdecl *dword_1076C4)(_DWORD); // weak
int (__cdecl *dword_1076C8)(_DWORD); // weak
int (__cdecl *dword_1076CC)(_DWORD); // weak
int (*dword_1076D0)(void); // weak
int (__cdecl *dword_1076D4)(_DWORD); // weak
int (*dword_1076D8)(void); // weak
int (*dword_1076DC)(void); // weak
int (*dword_1076E0)(void); // weak
int (*dword_1076E4)(void); // weak
int (*dword_1076E8)(void); // weak
int (__cdecl *dword_1076EC)(_DWORD); // weak
int (__cdecl *dword_1076F0)(_DWORD); // weak
int (__cdecl *dword_1076F4)(_DWORD); // weak
int (__cdecl *dword_1076F8)(_DWORD); // weak
int (__cdecl *dword_1076FC)(_DWORD); // weak
int (__cdecl *dword_107700)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107704)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107708)(_DWORD, _DWORD); // weak
int (__cdecl *dword_10770C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107710)(_DWORD); // weak
int (__cdecl *dword_107714)(_DWORD); // weak
int (__cdecl *dword_107718)(_DWORD, _DWORD); // weak
int (__cdecl *dword_10771C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107720)(_DWORD); // weak
int (__cdecl *dword_107724)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107728)(_DWORD, _DWORD); // weak
int (__cdecl *dword_10772C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107730)(_DWORD, _DWORD); // weak
int (*dword_107734)(void); // weak
int (__cdecl *dword_107740)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107744)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107748)(_DWORD, _DWORD); // weak
int (__cdecl *dword_10774C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_107750)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_107754)(_DWORD, _DWORD, _DWORD); // weak
int (*dword_107758)(void); // weak
int (*dword_10775C)(void); // weak
int (__cdecl *dword_107760)(_DWORD); // weak
int (__cdecl *dword_107764)(_DWORD, _DWORD); // weak
int (*dword_107768)(void); // weak
int (__cdecl *dword_10776C)(_DWORD); // weak
int (*dword_107770)(void); // weak
int (__cdecl *dword_107774)(_DWORD); // weak
int (__cdecl *dword_107778)(_DWORD); // weak
int (__cdecl *dword_10777C)(_DWORD); // weak
int (__cdecl *dword_107780)(_DWORD); // weak
int (__cdecl *dword_107784)(_DWORD); // weak
int (*dword_107788)(void); // weak
int (__cdecl *dword_107790)(_DWORD, _DWORD); // weak
int (*dword_107794)(void); // weak
int (__cdecl *dword_10779C)(_DWORD); // weak
int (__cdecl *dword_1077A0)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077A4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_1077A8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077AC)(_DWORD); // weak
int (__cdecl *dword_1077B0)(_DWORD); // weak
int (__cdecl *dword_1077B4)(_DWORD); // weak
int (__cdecl *dword_1077B8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077BC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077C0)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_1077C4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_1077C8)(_DWORD); // weak
int (__cdecl *dword_1077CC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077D0)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077D4)(_DWORD); // weak
int (__cdecl *dword_1077D8)(_DWORD); // weak
int (__cdecl *dword_1077DC)(_DWORD); // weak
int (*dword_1077E0)(void); // weak
int (*dword_1077E4)(void); // weak
int (__cdecl *dword_1077E8)(_DWORD); // weak
int (__cdecl *dword_1077EC)(_DWORD); // weak
int (__cdecl *dword_1077F0)(_DWORD, _DWORD); // weak
int (__cdecl *dword_1077F4)(_DWORD, _DWORD); // weak
int dword_1077F8; // weak
int dword_1077FC; // weak
int dword_107800; // weak
int dword_107804; // weak
int dword_107808; // weak
__int16 word_107820[43632]; // idb
_UNKNOWN unk_11CD00; // weak
__int16 word_136620; // weak
int dword_136624; // weak
int dword_136628; // weak
int dword_13662C; // weak
int dword_136630; // weak
int dword_136634; // weak
int dword_136638; // weak
int dword_13663C; // weak
int dword_136640; // weak
int dword_136644; // weak
_DWORD weaponStrings[256]; // idb
int bg[8]; // idb
_DWORD bgs[191424]; // idb
_DWORD bg_viewheight_prone[72]; // idb
int bg_lmg_yawcap[72]; // idb
int bg_foliagesnd_slowinterval[72]; // idb
_DWORD bg_foliagesnd_fastinterval[72]; // idb
int bg_foliagesnd_minspeed[72]; // idb
_DWORD bg_viewheight_crouched[72]; // idb
_DWORD bg_foliagesnd_resetinterval[72]; // idb
float bg_fallDamageMinHeight[72]; // idb
_DWORD bg_viewheight_standing[72]; // idb
float pml[40]; // idb
int bg_ladder_yawcap[72]; // idb
_DWORD bg_foliagesnd_maxspeed[72]; // idb
float bg_fallDamageMaxHeight[72]; // idb
float bg_prone_yawcap[72]; // idb
_DWORD bg_nofatigue[68]; // idb
_DWORD pm[4]; // idb
_UNKNOWN bg_bobAmplitudeStanding; // weak
_DWORD bg_debugWeaponState[72]; // idb
float bg_bobMax[72]; // idb
_DWORD bg_debugWeaponAnim[72]; // idb
_DWORD bg_debugWeaponMessages[72]; // idb
_UNKNOWN bg_bobAmplitudeDucked; // weak
float bg_bobAmplitudeProne[72]; // idb
_DWORD g_fHitLocDamageMult[24]; // idb
_DWORD g_hudelems[13176]; // idb
_UNKNOWN unk_200000; // weak
_UNKNOWN unk_200004; // weak
_DWORD itemRegistered[256]; // idb
float g_tracerChanceLMG[72]; // idb
_DWORD g_allowVoteDrawFriend[72]; // idb
float g_vehicleTexScrollScale[72]; // idb
_UNKNOWN g_gametype; // weak
_DWORD g_dedicated[72]; // idb
int g_timeoutsAllowed[72]; // idb
_DWORD g_listEntity[72]; // idb
_DWORD g_timeoutBank[72]; // idb
_DWORD g_vehicleForceGrenadeDamage[72]; // idb
int g_timeoutLength[72]; // idb
int g_debugBullets[72]; // idb
char g_vehicleDrawPath[288]; // idb
float g_bounds_width[72]; // idb
_DWORD g_allowVoteMapRestart[72]; // idb
_DWORD g_logSync[72]; // idb
_DWORD g_allowVoteTempBanClient[72]; // idb
_DWORD g_debugProneCheckDepthCheck[72]; // idb
_UNKNOWN g_motd; // weak
float g_tracerChance[72]; // idb
_DWORD pmove_fixed[72]; // idb
_DWORD g_inactivity[72]; // idb
_DWORD g_allowVoteGameType[72]; // idb
_DWORD g_timeoutRecovery[72]; // idb
_DWORD g_inactivityspectator[72]; // idb
_DWORD g_obituary[72]; // idb
_DWORD g_bounds_height_standing[72]; // idb
int g_dumpAnims[72]; // idb
_DWORD g_debugProneCheck[72]; // idb
_DWORD g_cheats[72]; // idb
_DWORD g_languagewarnings[72]; // idb
_DWORD g_debugLocDamage[72]; // idb
_DWORD g_developer[72]; // idb
float g_knockback[72]; // idb
_DWORD g_vehicleDebug[72]; // idb
_DWORD g_allowVote[72]; // idb
char g_password[288]; // idb
int pmove_msec[72]; // idb
_DWORD level[3000]; // idb
_DWORD g_vehicleForceBulletDamage[72]; // idb
_DWORD g_allowVoteTypeMap[72]; // idb
float g_gravity[72]; // idb
_DWORD g_vehicleEnableCollisionDamage[72]; // idb
_UNKNOWN g_clients; // weak
_DWORD g_entities[8100]; // idb
_UNKNOWN unk_400000; // weak
_UNKNOWN unk_404000; // weak
_DWORD g_synchronousClients[72]; // idb
_DWORD g_vehicleHorns[72]; // idb
_DWORD g_NoScriptSpam[72]; // idb
_DWORD g_allowVoteKillCam[72]; // idb
_DWORD g_allowVoteFriendlyFire[72]; // idb
_DWORD g_vehicleTrafficStressTest[72]; // idb
_DWORD g_complaintlimit[72]; // idb
_UNKNOWN g_vehicleBurnTime; // weak
float bg_swingSpeed[72]; // idb
_DWORD g_maxclients[72]; // idb
_DWORD g_allowVoteMap[72]; // idb
_DWORD g_maxDroppedWeapons[72]; // idb
_DWORD g_debugMove[72]; // idb
_DWORD g_weaponRespawn[72]; // idb
_DWORD bg_debugAnim[72]; // idb
_DWORD g_speed[72]; // idb
_DWORD g_filterBan[72]; // idb
_DWORD g_allowVoteClientKick[72]; // idb
_DWORD g_deadChat[72]; // idb
_BYTE g_log[288]; // idb
_DWORD g_allowVoteKick[72]; // idb
_DWORD g_weaponAmmoPools[72]; // idb
char g_banIPs[288]; // idb
_DWORD g_debugDamage[72]; // idb
_DWORD g_allowVoteMapRotate[72]; // idb
_DWORD g_smoothClients[72]; // idb
_DWORD g_allowVoteTempBanUser[72]; // idb
_DWORD g_languagewarningsaserrors[72]; // idb
_UNKNOWN pushed; // weak
_WORD g_scr_data[224]; // idb
unsigned __int16 scr_const[160]; // idb
// extern _UNKNOWN _deregister_frame_info_bases; weak
// extern _UNKNOWN _register_frame_info_bases; weak
// extern int _ctype_b; weak
// extern _UNKNOWN Jv_RegisterClasses; weak
// extern _UNKNOWN _gmon_start__; weak


//----- (00016734) --------------------------------------------------------
void (*init_proc())(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_199B0();
  return sub_98790();
}
// 198A4: using guessed type int __gmon_start__(void);

//----- (00016764) --------------------------------------------------------
void sub_16764()
{
  __asm { jmp     dword ptr [ebx+8] }
}

//----- (00019920) --------------------------------------------------------
int start()
{
  int v0; // eax
  void (*i)(void); // edx
  int v3; // [esp+0h] [ebp-8h]

  if ( !byte_B4840 )
  {
    if ( &_cxa_finalize )
      __cxa_finalize(off_A9000);
    v0 = off_A9004[0];
    for ( i = *(void (**)(void))off_A9004[0]; *(_DWORD *)off_A9004[0]; i = *(void (**)(void))off_A9004[0] )
    {
      off_A9004[0] = v0 + 4;
      i();
      v0 = off_A9004[0];
    }
    if ( &_deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_B33F8);
    byte_B4840 = 1;
  }
  return v3;
}
// 19988: variable 'v3' is possibly undefined
// 17634: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// A9000: using guessed type void *off_A9000;
// A9004: using guessed type int off_A9004[7];
// B4840: using guessed type char byte_B4840;

//----- (000199B0) --------------------------------------------------------
void *sub_199B0()
{
  void *result; // eax

  if ( &_register_frame_info_bases )
    __register_frame_info_bases(&unk_B33F8, &unk_B4844, 0, &GLOBAL_OFFSET_TABLE_);
  result = (void *)dword_B3814;
  if ( dword_B3814 )
  {
    result = &Jv_RegisterClasses;
    if ( &Jv_RegisterClasses )
      result = (void *)_Jv_RegisterClasses(&dword_B3814);
  }
  return result;
}
// 18684: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 196A4: using guessed type int __cdecl _Jv_RegisterClasses(_DWORD);
// B3814: using guessed type int dword_B3814;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00019A26) --------------------------------------------------------
void sub_19A26()
{
  ;
}

//----- (00019A2C) --------------------------------------------------------
int __cdecl sub_19A2C(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += (i + 119) * (char)tolower(*(char *)(a1 + i));
  if ( v2 == -1 )
    v2 = 0;
  return v2;
}

//----- (00019A9C) --------------------------------------------------------
int BG_AnimParseError(char *format, ...)
{
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+42Ch] [ebp-Ch]
  va_list va; // [esp+444h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( !off_A9020 )
    return Com_Error(1, byte_98B13, (char)s);
  Com_GetCurrentParseLine();
  return Com_Error(1, byte_98B00, (char)s);
}
// 18D84: using guessed type int Com_GetCurrentParseLine(void);
// A9020: using guessed type char *off_A9020;

//----- (00019B3B) --------------------------------------------------------
int __cdecl BG_AnimationIndexForString(char *src)
{
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]

  if ( dword_B7AC8 )
  {
    v9 = sub_19A2C((int)src);
    v7 = 0;
    v3 = dword_B7AC8;
    while ( v7 < *(_DWORD *)dword_B7ACC )
    {
      if ( v9 == *(_DWORD *)(v3 + 4) && !Q_stricmp(src, v3 + 8) )
        return v7;
      ++v7;
      v3 += 72;
    }
    v4 = dword_B7AC8 + 72 * *(_DWORD *)dword_B7ACC;
    Scr_FindAnim("multiplayer", src, v4);
    strcpy((char *)(v4 + 8), src);
    *(_DWORD *)(v4 + 4) = v9;
    v2 = (*(_DWORD *)dword_B7ACC)++;
  }
  else
  {
    v6 = sub_19A2C((int)src);
    v8 = 0;
    v5 = dword_A9008;
    while ( v8 < *(_DWORD *)(dword_A9008 + 47104) )
    {
      if ( v6 == *(_DWORD *)(v5 + 76) && !Q_stricmp(src, v5) )
        return v8;
      ++v8;
      v5 += 92;
    }
    BG_AnimParseError("BG_AnimationIndexForString: unknown player animation '%s'", (char)src);
    v2 = -1;
  }
  return v2;
}
// 181B4: using guessed type _DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// A9008: using guessed type int dword_A9008;
// B7AC8: using guessed type int dword_B7AC8;
// B7ACC: using guessed type int dword_B7ACC;

//----- (00019CCB) --------------------------------------------------------
int __cdecl BG_AnimationForString(int a1)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  v4 = sub_19A2C(a1);
  v5 = 0;
  v3 = dword_A9008;
  while ( v5 < *(_DWORD *)(dword_A9008 + 47104) )
  {
    if ( v4 == *(_DWORD *)(v3 + 76) && !Q_stricmp(a1, v3) )
      return v3;
    ++v5;
    v3 += 92;
  }
  Com_Error(1, byte_98B80, a1);
  return 0;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// A9008: using guessed type int dword_A9008;

//----- (00019D71) --------------------------------------------------------
int __cdecl BG_IndexForString(int a1, int *a2, int a3)
{
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v6 = sub_19A2C(a1);
  v7 = 0;
  while ( *a2 )
  {
    if ( a2[1] == -1 )
      a2[1] = sub_19A2C(*a2);
    if ( v6 == a2[1] && !Q_stricmp(a1, *a2) )
      return v7;
    a2 += 2;
    ++v7;
  }
  if ( !a3 )
    BG_AnimParseError("BG_IndexForString: unknown token '%s'", a1);
  return -1;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00019E29) --------------------------------------------------------
char *__cdecl BG_CopyStringIntoBuffer(char *s, int a2, int a3, int a4)
{
  char v5; // [esp+4h] [ebp-14h]
  char *dest; // [esp+8h] [ebp-10h]

  if ( *(_DWORD *)a4 + strlen(s) + 1 >= a3 )
    BG_AnimParseError("BG_CopyStringIntoBuffer: out of buffer space", v5);
  dest = (char *)(a2 + *(_DWORD *)a4);
  strcpy(dest, s);
  *(_DWORD *)a4 += strlen(s) + 1;
  return dest;
}
// 19E5C: variable 'v5' is possibly undefined

//----- (00019E9F) --------------------------------------------------------
int BG_InitWeaponStrings()
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]

  memset(weaponStrings, 0, sizeof(weaponStrings));
  weaponStrings[0] = "none";
  weaponStrings[1] = sub_19A2C((int)"none");
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    weaponStrings[2 * i] = *(_DWORD *)(BG_GetInfoForWeapon(i) + 4);
    weaponStrings[2 * i + 1] = sub_19A2C(weaponStrings[2 * i]);
  }
  return result;
}
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00019F5B) --------------------------------------------------------
unsigned __int16 *__cdecl sub_19F5B(unsigned int a1)
{
  unsigned __int16 *v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  if ( a1 >= *(_DWORD *)(dword_A9008 + 47104) )
    Com_Error(1, byte_98C40, a1);
  v4 = 0;
  v3 = (unsigned __int16 *)dword_B7AC8;
  while ( v4 < *(_DWORD *)dword_B7ACC )
  {
    if ( a1 == *v3 )
      return v3;
    ++v4;
    v3 += 36;
  }
  return 0;
}
// A9008: using guessed type int dword_A9008;
// B7AC8: using guessed type int dword_B7AC8;
// B7ACC: using guessed type int dword_B7ACC;

//----- (00019FFA) --------------------------------------------------------
int __cdecl sub_19FFA(int a1)
{
  int result; // eax
  int k; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int j; // [esp+4h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-8h]
  _DWORD *v6; // [esp+10h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 47104); ++i )
    *(_DWORD *)(a1 + 92 * i + 88) = 0;
  v6 = (_DWORD *)(a1 + 134828);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= *v6 )
      break;
    v5 = v6[j + 1];
    for ( k = 0; k < *(_DWORD *)(v5 + 136); ++k )
    {
      if ( *(_WORD *)(v5 + 16 * k + 140) )
        *(_DWORD *)(a1 + 92 * *(__int16 *)(v5 + 16 * k + 144) + 88) = 1;
      if ( *(_WORD *)(v5 + 16 * k + 142) )
        *(_DWORD *)(a1 + 92 * *(__int16 *)(v5 + 16 * k + 146) + 88) = 1;
    }
  }
  return result;
}

//----- (0001A0DE) --------------------------------------------------------
int BG_FinalizePlayerAnims()
{
  char *v0; // eax
  char *v1; // esi
  char *v2; // esi
  float v4; // [esp+40h] [ebp-48h]
  unsigned __int16 *v5; // [esp+48h] [ebp-40h]
  int v6; // [esp+4Ch] [ebp-3Ch]
  float v7; // [esp+50h] [ebp-38h] BYREF
  float v8; // [esp+54h] [ebp-34h]
  float v9; // [esp+58h] [ebp-30h]
  char v10[8]; // [esp+60h] [ebp-28h] BYREF
  int v11; // [esp+68h] [ebp-20h]
  int v12; // [esp+6Ch] [ebp-1Ch]
  char *dest; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]
  signed int v16; // [esp+7Ch] [ebp-Ch]

  v14 = dword_A9008;
  v12 = *(int *)((char *)&dword_A7AC8 + dword_A9008);
  HIWORD(v11) = Scr_GetAnimsIndex(v12);
  v15 = trap_XAnimGetAnimTreeSize(v12);
  *(_DWORD *)(dword_A9008 + 47104) = v15;
  dest = (char *)v14;
  *(_DWORD *)(v14 + 80) |= 0x101u;
  Q_strncpyz(dest, "root", 64);
  *((_DWORD *)dest + 19) = 0;
  dest += 92;
  v16 = 1;
  while ( v16 < v15 )
  {
    LOWORD(v11) = v16;
    v5 = sub_19F5B(v16);
    if ( v5 )
    {
      if ( trap_XAnimIsPrimitive(v11) )
      {
        v0 = (char *)trap_XAnimGetAnimName(v11);
        Q_strncpyz(dest, v0, 64);
        v1 = dest;
        *((_DWORD *)v1 + 19) = sub_19A2C((int)dest);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        v2 = dest;
        *((_DWORD *)v2 + 18) = trap_XAnimGetLength(v12, (unsigned __int16)v16);
        if ( *((_DWORD *)dest + 18) )
        {
          trap_XAnimGetRelDelta(v11, v10, &v7, 0, 1065353216);
          v4 = sqrt(v7 * v7 + v8 * v8 + v9 * v9);
          v6 = (int)v4;
          if ( v6 )
            *((_DWORD *)dest + 17) = 1000 * v6 / *((_DWORD *)dest + 18);
          else
            *((_DWORD *)dest + 17) = 0;
        }
        else
        {
          *((_DWORD *)dest + 17) = 0;
        }
        if ( *((int *)dest + 18) < 500 )
          *((_DWORD *)dest + 18) = 500;
        if ( trap_XAnimIsLooped(v11) )
          *((_DWORD *)dest + 20) |= 0x80u;
      }
      else
      {
        *((_DWORD *)dest + 20) |= 1u;
        Q_strncpyz(dest, (char *)v5 + 8, 64);
        *((_DWORD *)dest + 19) = *((_DWORD *)v5 + 1);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        *((_DWORD *)dest + 18) = 0;
        *((_DWORD *)dest + 17) = 0;
      }
    }
    else
    {
      *((_DWORD *)dest + 20) |= 0x100u;
      Q_strncpyz(dest, "unused", 64);
      *((_DWORD *)dest + 19) = 0;
    }
    ++v16;
    dest += 92;
  }
  BG_AnimParseAnimScript(dword_A9008, 0, 0);
  return sub_19FFA(dword_A9008);
}
// 1A212: conditional instruction was optimized away because of '%var_40.4!=0'
// 16EC4: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17224: using guessed type _DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD);
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 17AE4: using guessed type _DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD);
// 185D4: using guessed type _DWORD __cdecl trap_XAnimIsLooped(_DWORD);
// 185F4: using guessed type _DWORD __cdecl trap_XAnimGetAnimName(_DWORD);
// 18D64: using guessed type _DWORD __cdecl trap_XAnimGetAnimTreeSize(_DWORD);
// 19554: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);
// A7AC8: using guessed type int dword_A7AC8;
// A9008: using guessed type int dword_A9008;

//----- (0001A41E) --------------------------------------------------------
void *__cdecl sub_1A41E(int a1, int a2, int a3, void *s)
{
  void *result; // eax
  int v5; // eax
  char v6; // [esp+4h] [ebp-74h]
  char *src; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  char v9[64]; // [esp+20h] [ebp-58h] BYREF
  int v10; // [esp+60h] [ebp-18h] BYREF
  int v11; // [esp+64h] [ebp-14h]
  int v12; // [esp+68h] [ebp-10h]
  int v13; // [esp+6Ch] [ebp-Ch]

  v13 = 0;
  v8 = 0;
  v9[0] = 0;
  memset(s, 0, 4u);
  result = memset(&v10, 0, 8u);
  while ( !v13 )
  {
    src = (char *)Com_ParseOnLine(a1);
    if ( !src || !*src )
    {
      result = (void *)Com_UngetToken();
      v13 = 1;
      if ( !v9[0] )
        break;
    }
    if ( !Q_stricmp(src, ",") )
      v13 = 1;
    if ( Q_stricmp(src, "none") )
    {
      if ( Q_stricmp(src, "none,") )
      {
        if ( !Q_stricmp(src, "NOT") )
          src = "MINUS";
        if ( !v13 && Q_stricmp(src, "AND") && Q_stricmp(src, "MINUS") )
        {
          if ( src[strlen(src) - 1] == 44 )
          {
            v13 = 1;
            src[strlen(src) - 1] = 0;
          }
          if ( v9[0] )
            Q_strcat(v9, 64, " ");
          Q_strcat(v9, 64, src);
        }
        if ( !Q_stricmp(src, "AND") || (result = (void *)Q_stricmp(src, "MINUS")) == 0 || v13 )
        {
          if ( v9[0] )
            goto LABEL_31;
          if ( v13 )
          {
            BG_AnimParseError("BG_ParseConditionBits: unexpected end of condition", v6);
            goto LABEL_31;
          }
          result = (void *)Q_stricmp(src, "MINUS");
          if ( result )
          {
            BG_AnimParseError("BG_ParseConditionBits: unexpected '%s'", (char)src);
LABEL_31:
            if ( Q_stricmp(v9, "all") )
            {
              v12 = BG_IndexForString(v9, &dword_B6FC0[32 * a3], 1);
              if ( v12 < 0 )
              {
                v12 = BG_IndexForString(v9, a2, 0);
                Com_BitSet(&v10, v12);
              }
              else
              {
                v10 = *(int *)((char *)&dword_B7540 + (_DWORD)&dword_0[32 * a3 + 2 * v12]);
                v11 = *(int *)((char *)&dword_B7544 + (_DWORD)&dword_0[32 * a3 + 2 * v12]);
              }
            }
            else
            {
              v10 = -1;
              v11 = -1;
            }
            if ( v8 )
            {
              *(_DWORD *)s &= ~v10;
              v5 = *((_DWORD *)s + 1) & ~v11;
            }
            else
            {
              *(_DWORD *)s |= v10;
              v5 = *((_DWORD *)s + 1) | v11;
            }
            *((_DWORD *)s + 1) = v5;
            v9[0] = 0;
            result = (void *)Q_stricmp(src, "MINUS");
            if ( !result )
              v8 = 1;
          }
          else
          {
            v8 = 1;
          }
        }
      }
      else
      {
        result = (void *)Com_BitSet(s, 0);
        v13 = 1;
      }
    }
    else
    {
      result = (void *)Com_BitSet(s, 0);
    }
  }
  return result;
}
// 1A65D: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E94: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 19654: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 19694: using guessed type int Com_UngetToken(void);
// 19804: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);
// B6FC0: using guessed type int dword_B6FC0[];
// B7540: using guessed type int dword_B7540;
// B7544: using guessed type int dword_B7544;

//----- (0001A7D0) --------------------------------------------------------
int __cdecl sub_1A7D0(int a1, _DWORD *a2)
{
  char v3; // [esp+4h] [ebp-34h]
  int v4; // [esp+18h] [ebp-20h]
  char *s; // [esp+1Ch] [ebp-1Ch]
  char *sa; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  int i; // [esp+24h] [ebp-14h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  for ( i = 0; ; a2[3 * (*a2)++ + 3] = i )
  {
    s = (char *)Com_ParseOnLine(a1);
    if ( !s || !*s )
      break;
    if ( !Q_stricmp(s, "default") )
      return 1;
    v9 = BG_IndexForString(s, &off_A93C0, 0);
    v4 = *(int *)((char *)&dword_A9480 + (_DWORD)&dword_0[2 * v9]);
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        if ( *(int (**)[256])((char *)&off_A9484 + (_DWORD)&dword_0[2 * v9]) )
        {
          sa = (char *)Com_ParseOnLine(a1);
          if ( !sa || !*sa )
            BG_AnimParseError("BG_ParseConditions: expected condition value, found end of line", v3);
          if ( sa[strlen(sa) - 1] == 44 )
            sa[strlen(sa) - 1] = 0;
          v7 = BG_IndexForString(sa, *(int (**)[256])((char *)&off_A9484 + (_DWORD)&dword_0[2 * v9]), 0);
        }
        else
        {
          v7 = 1;
        }
      }
    }
    else
    {
      sub_1A41E(a1, *(int *)((char *)&off_A9484 + (_DWORD)&dword_0[2 * v9]), v9, &v7);
    }
    a2[3 * *a2 + 1] = v9;
    a2[3 * *a2 + 2] = v7;
  }
  if ( !*a2 )
    BG_AnimParseError("BG_ParseConditions: no conditions found", v3);
  return 1;
}
// 1A8CF: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E94: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 19654: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// A93C0: using guessed type char *off_A93C0;
// A9480: using guessed type int dword_A9480;
// A9484: using guessed type int (*off_A9484)[256];

//----- (0001A9A3) --------------------------------------------------------
size_t __cdecl BG_ParseCommands(_DWORD *a1, _DWORD *a2, int a3)
{
  size_t result; // eax
  int *v4; // esi
  int v5; // edx
  char v6; // [esp+4h] [ebp-34h]
  char v7; // [esp+4h] [ebp-34h]
  char v8; // [esp+4h] [ebp-34h]
  char v9; // [esp+4h] [ebp-34h]
  char v10; // [esp+4h] [ebp-34h]
  char v11; // [esp+4h] [ebp-34h]
  const char *v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  _DWORD *v16; // [esp+24h] [ebp-14h]
  char *s; // [esp+28h] [ebp-10h]
  char *sa; // [esp+28h] [ebp-10h]
  char *sb; // [esp+28h] [ebp-10h]
  char *sc; // [esp+28h] [ebp-10h]
  char *sd; // [esp+28h] [ebp-10h]
  char *se; // [esp+28h] [ebp-10h]

  v16 = 0;
  v15 = 0;
  while ( 1 )
  {
    v12 = (const char *)(v15 > 0 ? Com_ParseOnLine(a1) : Com_Parse(a1));
    result = (size_t)v12;
    if ( !v12 )
      return result;
    result = (size_t)v12;
    if ( !*v12 )
      return result;
    if ( !Q_stricmp(v12, "}") )
    {
      result = *a1 - strlen(v12);
      *a1 = result;
      return result;
    }
    if ( !v15 )
    {
      if ( (int)a2[34] > 7 )
        BG_AnimParseError("BG_ParseCommands: exceeded maximum number of animations (%i)", 8);
      v16 = &a2[4 * a2[34]++ + 35];
      memset(v16, 0, sizeof(_DWORD));
    }
    *((_WORD *)v16 + v15) = BG_IndexForString(v12, &animBodyPartsStr, 1);
    if ( *((__int16 *)v16 + v15) <= 0 )
    {
      *a1 -= strlen(v12);
      goto LABEL_60;
    }
    s = (char *)Com_ParseOnLine(a1);
    if ( !s || !*s )
      BG_AnimParseError("BG_ParseCommands: expected animation", v6);
    *((_WORD *)v16 + v15 + 2) = BG_AnimationIndexForString(s);
    *((_WORD *)v16 + v15 + 4) = *(_WORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 72);
    if ( !dword_B7AC8 )
    {
      if ( dword_B7AC0 && *((_WORD *)v16 + v15) != 2 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 84) |= 1 << dword_B7AC0;
        if ( (dword_B7AC0 == 16 || dword_B7AC0 == 17) && *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 68) )
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 2u;
        for ( i = 0; ; ++i )
        {
          if ( i >= *a2 )
            goto LABEL_32;
          if ( a2[3 * i + 1] == 10 )
            break;
        }
        if ( a2[3 * i + 2] == 1 )
        {
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x10u;
        }
        else if ( a2[3 * i + 2] == 2 )
        {
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x20u;
        }
      }
LABEL_32:
      if ( dword_B7AC4 == 2 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 8u;
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 64) = 30;
      }
      else if ( dword_B7AC4 == 1 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 68) = 0;
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x40u;
      }
      goto LABEL_36;
    }
    do
    {
LABEL_36:
      v13 = 0;
      sa = (char *)Com_ParseOnLine(a1);
      if ( !sa || !*sa )
      {
LABEL_54:
        Com_UngetToken();
        continue;
      }
      if ( Q_stricmp(sa, "duration") )
      {
        if ( Q_stricmp(sa, "turretanim") )
        {
          if ( Q_stricmp(sa, "blendtime") )
            goto LABEL_54;
          v13 = 1;
          sc = (char *)Com_ParseOnLine(a1);
          if ( !sc || !*sc )
            BG_AnimParseError("BG_ParseCommands: expected blendtime value", v9);
          if ( !dword_B7AC8 )
          {
            v4 = (int *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 64);
            *v4 = atoi(sc);
          }
        }
        else
        {
          v13 = 1;
          if ( !dword_B7AC8 )
            *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 4u;
          if ( *((_WORD *)v16 + v15) != 3 )
            BG_AnimParseError("BG_ParseCommands: Turret animations can only be played on the 'both' body part", v8);
        }
      }
      else
      {
        v13 = 1;
        sb = (char *)Com_ParseOnLine(a1);
        if ( !sb || !*sb )
          BG_AnimParseError("BG_ParseCommands: expected duration value", v7);
        *((_WORD *)v16 + v15 + 4) = atoi(sb);
      }
    }
    while ( v13 );
    if ( *((_WORD *)v16 + v15) != 3 )
    {
      v5 = v15++;
      if ( v5 <= 0 )
        continue;
    }
LABEL_60:
    while ( 1 )
    {
      sd = (char *)Com_ParseOnLine(a1);
      if ( !sd || !*sd )
        break;
      if ( Q_stricmp(sd, "sound") )
      {
        BG_AnimParseError("BG_ParseCommands: unknown parameter '%s'", (char)sd);
      }
      else
      {
        se = (char *)Com_ParseOnLine(a1);
        if ( !se || !*se )
          BG_AnimParseError("BG_ParseCommands: expected sound", v10);
        if ( strstr(se, ".wav") )
          BG_AnimParseError("BG_ParseCommands: wav files not supported, only sound scripts", v11);
        v16[3] = (*(int (__cdecl **)(char *))((char *)&dword_A7AD8 + dword_A9008))(se);
      }
    }
    v15 = 0;
  }
}
// 1AAFA: variable 'v6' is possibly undefined
// 1AE00: variable 'v7' is possibly undefined
// 1AE96: variable 'v8' is possibly undefined
// 1AEE5: variable 'v9' is possibly undefined
// 1AFC9: variable 'v10' is possibly undefined
// 1AFF0: variable 'v11' is possibly undefined
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E94: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 19654: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 19694: using guessed type int Com_UngetToken(void);
// A7AD8: using guessed type int dword_A7AD8;
// A9008: using guessed type int dword_A9008;
// A91C0: using guessed type char *animBodyPartsStr;
// B7AC0: using guessed type int dword_B7AC0;
// B7AC4: using guessed type int dword_B7AC4;
// B7AC8: using guessed type int dword_B7AC8;

//----- (0001B042) --------------------------------------------------------
int __cdecl BG_AnimParseAnimScript(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  size_t v7; // eax
  size_t v8; // eax
  int v9; // esi
  size_t v10; // eax
  size_t v11; // eax
  int v12; // esi
  int v13; // esi
  size_t v14; // eax
  size_t v15; // eax
  int v16; // esi
  size_t v17; // eax
  size_t v18; // eax
  char v20; // [esp+4h] [ebp-1A4h]
  char v21; // [esp+4h] [ebp-1A4h]
  char v22; // [esp+4h] [ebp-1A4h]
  char v23; // [esp+4h] [ebp-1A4h]
  char v24; // [esp+4h] [ebp-1A4h]
  char v25; // [esp+4h] [ebp-1A4h]
  char v26; // [esp+4h] [ebp-1A4h]
  char v27; // [esp+4h] [ebp-1A4h]
  char v28; // [esp+4h] [ebp-1A4h]
  char v29; // [esp+4h] [ebp-1A4h]
  char v30; // [esp+4h] [ebp-1A4h]
  unsigned int v31; // [esp+1Ch] [ebp-18Ch]
  int *v32; // [esp+20h] [ebp-188h]
  int *v33; // [esp+24h] [ebp-184h]
  unsigned int v34; // [esp+28h] [ebp-180h]
  int *v35; // [esp+2Ch] [ebp-17Ch]
  int *v36; // [esp+30h] [ebp-178h]
  int v37; // [esp+34h] [ebp-174h]
  int v38; // [esp+38h] [ebp-170h] BYREF
  int v39; // [esp+3Ch] [ebp-16Ch]
  int i; // [esp+40h] [ebp-168h]
  int v41; // [esp+44h] [ebp-164h]
  int v42; // [esp+48h] [ebp-160h]
  int v43; // [esp+4Ch] [ebp-15Ch]
  int v44; // [esp+50h] [ebp-158h]
  int v45; // [esp+54h] [ebp-154h]
  int v46; // [esp+58h] [ebp-150h]
  int *v47; // [esp+6Ch] [ebp-13Ch]
  int v48; // [esp+70h] [ebp-138h] BYREF
  _BYTE v49[268]; // [esp+74h] [ebp-134h] BYREF
  void *s; // [esp+180h] [ebp-28h]
  int v51; // [esp+184h] [ebp-24h]
  char *v52; // [esp+188h] [ebp-20h]
  int v53[7]; // [esp+18Ch] [ebp-1Ch] BYREF

  v47 = 0;
  if ( !dword_A900C )
  {
    v37 = trap_FS_FOpenFile(off_A9020, &v38, 0);
    if ( v37 <= 0 )
      Com_Error(1, byte_99000, (char)off_A9020);
    if ( (unsigned int)v37 > 0x1869E )
      Com_Error(1, byte_99000, (char)off_A9020);
    trap_FS_Read(byte_B7AE0, v37, v38);
    byte_B7AE0[v37] = 0;
    trap_FS_FCloseFile(v38);
    dword_A900C = 1;
  }
  dword_A9008 = a1;
  dword_B7AC8 = a2;
  dword_B7ACC = a3;
  v51 = 0;
  BG_InitWeaponStrings();
  memset(dword_B6FC0, 0, 0x580u);
  memset(&unk_B48A0, 0, 0x2710u);
  memset(&dword_B4860, 0, 0x2Cu);
  dword_B6FB0 = 0;
  for ( i = 0; i <= 2; ++i )
    *(&v44 + i) = -1;
  v43 = 0;
  s = 0;
  v53[0] = (int)byte_B7AE0;
  Com_BeginParseSession("BG_AnimParseAnimScript");
  while ( 1 )
  {
    v52 = (char *)Com_Parse(v53);
    if ( !v52 || !*v52 )
      break;
    v41 = BG_IndexForString(v52, &off_A9440, 1);
    if ( v41 < 0 )
    {
      switch ( v51 )
      {
        case 0:
          if ( !Q_stricmp(v52, "set") )
          {
            v52 = (char *)Com_ParseOnLine(v53);
            if ( !v52 || !*v52 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition type string", v20);
            v39 = BG_IndexForString(v52, &off_A93C0, 0);
            if ( *(int *)((char *)&dword_A9480 + (_DWORD)&dword_0[2 * v39]) )
              BG_AnimParseError("BG_AnimParseAnimScript: can not make a define of type '%s'", (char)v52);
            v52 = (char *)Com_ParseOnLine(v53);
            if ( !v52 || !*v52 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition define string", v21);
            v3 = *(int *)((char *)&dword_B4860 + (_DWORD)&dword_0[v39]) + 16 * v39;
            *(int *)((char *)dword_B6FC0 + (_DWORD)&dword_0[2 * v3]) = BG_CopyStringIntoBuffer(
                                                                         v52,
                                                                         (int)&unk_B48A0,
                                                                         10000,
                                                                         (int)&dword_B6FB0);
            v4 = *(int *)((char *)&dword_B4860 + (_DWORD)&dword_0[v39]) + 16 * v39;
            *(int *)((char *)&dword_B6FC4 + (_DWORD)&dword_0[2 * v4]) = sub_19A2C(*(int *)((char *)dword_B6FC0
                                                                                         + (_DWORD)&dword_0[2 * v4]));
            v52 = (char *)Com_ParseOnLine(v53);
            if ( !v52 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found end of line", v22);
            if ( Q_stricmp(v52, "=") )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found '%s'", (char)v52);
            sub_1A41E(
              (int)v53,
              *(int *)((char *)&off_A9484 + (_DWORD)&dword_0[2 * v39]),
              v39,
              &dword_B7540[32 * v39 + 2 * *(int *)((char *)&dword_B4860 + (_DWORD)&dword_0[v39])]);
            ++*(int *)((char *)&dword_B4860 + (_DWORD)&dword_0[v39]);
          }
          break;
        case 1:
        case 2:
          if ( Q_stricmp(v52, "{") )
          {
            if ( Q_stricmp(v52, "}") )
            {
              if ( v43 || v44 >= 0 )
              {
                if ( v43 == 1 && v45 < 0 )
                {
                  v6 = v43;
                  *(&v44 + v6) = BG_IndexForString(v52, &off_A9080, 0);
                  if ( v51 == 1 )
                  {
                    s = (void *)(516 * v45 + a1 + 9288 * v44 + 47108);
                    dword_B7AC0 = v45;
                  }
                  else if ( v51 == 2 )
                  {
                    s = (void *)(516 * v45 + a1 + 9288 * v44 + 84260);
                  }
                  goto LABEL_105;
                }
                if ( v43 != 2 || v46 >= 0 )
                {
                  if ( v43 != 3 )
                    goto LABEL_78;
                  v10 = strlen(v52);
                  v53[0] -= v10;
                  v11 = strlen(v52);
                  if ( Q_strncmp(v53[0], v52, v11) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v25);
                  goto LABEL_77;
                }
                v7 = strlen(v52);
                v53[0] -= v7;
                v8 = strlen(v52);
                if ( Q_strncmp(v53[0], v52, v8) )
                  BG_AnimParseError("BG_AnimParseAnimScript: internal error", v24);
                memset(&v48, 0, 0x10Cu);
                v9 = v43;
                *(&v44 + v9) = sub_1A7D0((int)v53, &v48);
                if ( *(int *)s > 127 )
                  BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                if ( *(int *)((char *)&dword_A7AC4 + a1) > 2047 )
                  BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 0);
                *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 268 * (*(int *)((char *)&dword_A7AC4 + a1))++ + 137924;
                v47 = (int *)*((_DWORD *)s + ++*(_DWORD *)s);
                v36 = v47;
                v35 = &v48;
                v34 = 268;
                if ( ((unsigned __int8)v47 & 4) != 0 )
                {
                  *v47 = v48;
                  ++v36;
                  v35 = (int *)v49;
                  v34 = 264;
                }
                qmemcpy(v36, v35, 4 * (v34 >> 2));
              }
              else
              {
                if ( Q_stricmp(v52, "state") )
                  BG_AnimParseError("BG_AnimParseAnimScript: expected 'state'", v23);
                v52 = (char *)Com_ParseOnLine(v53);
                if ( !v52 )
                  BG_AnimParseError("BG_AnimParseAnimScript: expected state type", v23);
                v5 = v43;
                *(&v44 + v5) = BG_IndexForString(v52, &animStateStr, 0);
                v52 = (char *)Com_Parse(v53);
                if ( !v52 || Q_stricmp(v52, "{") )
                  BG_AnimParseError("BG_AnimParseAnimScript: expected '{'", v20);
                ++v43;
              }
            }
            else
            {
              if ( --v43 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
              if ( v43 == 1 )
                s = 0;
              *(&v44 + v43) = -1;
            }
          }
          else
          {
            if ( v43 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
            if ( *(&v44 + v43) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
            ++v43;
          }
          break;
        case 3:
        case 4:
          if ( Q_stricmp(v52, "{") )
          {
            if ( Q_stricmp(v52, "}") )
            {
              if ( v43 || v44 >= 0 )
              {
                if ( v43 == 1 && v45 < 0 )
                {
                  v14 = strlen(v52);
                  v53[0] -= v14;
                  v15 = strlen(v52);
                  if ( Q_strncmp(v53[0], v52, v15) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v29);
                  memset(&v48, 0, 0x10Cu);
                  v16 = v43;
                  *(&v44 + v16) = sub_1A7D0((int)v53, &v48);
                  if ( *(int *)s > 127 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(int *)((char *)&dword_A7AC4 + a1) > 2047 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 0);
                  *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 268 * (*(int *)((char *)&dword_A7AC4 + a1))++ + 137924;
                  v47 = (int *)*((_DWORD *)s + ++*(_DWORD *)s);
                  v33 = v47;
                  v32 = &v48;
                  v31 = 268;
                  if ( ((unsigned __int8)v47 & 4) != 0 )
                  {
                    *v47 = v48;
                    ++v33;
                    v32 = (int *)v49;
                    v31 = 264;
                  }
                  qmemcpy(v33, v32, 4 * (v31 >> 2));
                }
                else if ( v43 == 2 )
                {
                  v17 = strlen(v52);
                  v53[0] -= v17;
                  v18 = strlen(v52);
                  if ( Q_strncmp(v53[0], v52, v18) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v30);
LABEL_77:
                  BG_ParseCommands(v53, v47, a1);
                }
                else
                {
LABEL_78:
                  BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
                }
              }
              else
              {
                if ( v51 == 3 )
                {
                  if ( Q_stricmp(v52, "statechange") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected 'statechange', got '%s'", (char)v52);
                  v52 = (char *)Com_ParseOnLine(v53);
                  if ( !v52 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>", v26);
                  v42 = BG_IndexForString(v52, &animStateStr, 0);
                  v52 = (char *)Com_ParseOnLine(v53);
                  if ( !v52 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>", v27);
                  v12 = v43;
                  *(&v44 + v12) = BG_IndexForString(v52, &animStateStr, 0);
                  s = (void *)(516 * *(&v44 + v43) + a1 + 2064 * v42 + 121412);
                  v52 = (char *)Com_Parse(v53);
                  if ( !v52 || Q_stricmp(v52, "{") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected '{'", v28);
                  ++v43;
                }
                else
                {
                  v13 = v43;
                  *(&v44 + v13) = BG_IndexForString(v52, &off_A9120, 0);
                  s = (void *)(a1 + 516 * v44 + 129668);
                  dword_B7AC4 = *(&v44 + v43);
                }
LABEL_105:
                memset(s, 0, 0x204u);
              }
            }
            else
            {
              if ( --v43 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
              if ( !v43 )
                s = 0;
              *(&v44 + v43) = -1;
            }
          }
          else
          {
            if ( v43 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
            if ( *(&v44 + v43) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
            ++v43;
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      if ( v43 )
        BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v52);
      v51 = v41;
      dword_B7AC0 = 0;
      dword_B7AC4 = -1;
    }
  }
  if ( v43 )
    BG_AnimParseError("BG_AnimParseAnimScript: unexpected end of file: %s", v20);
  off_A9020 = 0;
  return Com_EndParseSession();
}
// 1B24A: variable 'v20' is possibly undefined
// 1B38F: variable 'v21' is possibly undefined
// 1B43B: variable 'v22' is possibly undefined
// 1B5E6: variable 'v23' is possibly undefined
// 1B7BF: variable 'v24' is possibly undefined
// 1B941: variable 'v25' is possibly undefined
// 1BAC5: variable 'v26' is possibly undefined
// 1BB0A: variable 'v27' is possibly undefined
// 1BBA8: variable 'v28' is possibly undefined
// 1BC90: variable 'v29' is possibly undefined
// 1BE12: variable 'v30' is possibly undefined
// 0: using guessed type int dword_0[];
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 17C64: using guessed type int Com_EndParseSession(void);
// 17F64: using guessed type _DWORD __cdecl BG_ParseCommands(_DWORD, _DWORD, _DWORD);
// 18804: using guessed type int BG_InitWeaponStrings(void);
// 18AE4: using guessed type _DWORD __cdecl Q_strncmp(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E94: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 19654: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 197A4: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// A7AC4: using guessed type int dword_A7AC4;
// A9008: using guessed type int dword_A9008;
// A900C: using guessed type int dword_A900C;
// A9020: using guessed type char *off_A9020;
// A9040: using guessed type char *animStateStr;
// A9080: using guessed type char *off_A9080;
// A9120: using guessed type char *off_A9120;
// A93C0: using guessed type char *off_A93C0;
// A9440: using guessed type char *off_A9440;
// A9480: using guessed type int dword_A9480;
// A9484: using guessed type int (*off_A9484)[256];
// B4860: using guessed type int dword_B4860;
// B6FB0: using guessed type int dword_B6FB0;
// B6FC0: using guessed type int dword_B6FC0[];
// B6FC4: using guessed type int dword_B6FC4;
// B7540: using guessed type int dword_B7540[];
// B7AC0: using guessed type int dword_B7AC0;
// B7AC4: using guessed type int dword_B7AC4;
// B7AC8: using guessed type int dword_B7AC8;
// B7ACC: using guessed type int dword_B7ACC;

//----- (0001BE6C) --------------------------------------------------------
int __cdecl sub_1BE6C(int a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-14h]
  _DWORD *v5; // [esp+8h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-8h]

  v6 = 0;
  v5 = a2 + 1;
  while ( v6 < *a2 )
  {
    v3 = *(int *)((char *)&dword_A9480 + (_DWORD)&dword_0[2 * *v5]);
    if ( v3 )
    {
      if ( v3 == 1 && *(_DWORD *)(a1 + 8 * *v5 + 1128) != v5[1] )
        return 0;
    }
    else if ( (*(_DWORD *)(a1 + 8 * *v5 + 1128) & v5[1]) == 0 && (*(_DWORD *)(a1 + 8 * *v5 + 1132) & v5[2]) == 0 )
    {
      return 0;
    }
    ++v6;
    v5 += 3;
  }
  return 1;
}
// 0: using guessed type int dword_0[];
// A9480: using guessed type int dword_A9480;

//----- (0001BF35) --------------------------------------------------------
_DWORD *__cdecl sub_1BF35(int a1, _DWORD *a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD **v5; // [esp+10h] [ebp-8h]

  v4 = 0;
  v5 = (_DWORD **)(a2 + 1);
  while ( v4 < *a2 )
  {
    if ( sub_1BE6C((int)&aSDoesNotExist[1232 * a1 + (_DWORD)&bgs], *v5) )
      return *v5;
    ++v4;
    ++v5;
  }
  return 0;
}

//----- (0001BFB9) --------------------------------------------------------
int __cdecl BG_PlayAnim(_DWORD *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-Ch]
  int v10; // [esp+Ch] [ebp-8h]

  v9 = 0;
  if ( a4 )
    v10 = a4;
  else
    v10 = *(_DWORD *)(dword_A9008 + 92 * a2 + 72) + 50;
  if ( a3 == 2 )
  {
LABEL_20:
    if ( (int)a1[30] <= 49 || a7 )
    {
      if ( a6 && (a1[31] & 0xFFFFFDFF) == a2 )
      {
        if ( a5 && (*(_BYTE *)(dword_A9008 + 92 * a2 + 80) & 0x80) != 0 )
          a1[30] = v10;
      }
      else
      {
        a1[31] = a2 | a1[31] & 0x200 ^ 0x200;
        if ( a5 )
          a1[30] = v10;
      }
    }
    goto LABEL_29;
  }
  if ( a3 > 2 )
  {
    if ( a3 != 3 )
      goto LABEL_29;
  }
  else if ( a3 != 1 )
  {
    goto LABEL_29;
  }
  if ( (int)a1[28] <= 49 || a7 )
  {
    if ( a6 && (a1[29] & 0xFFFFFDFF) == a2 )
    {
      if ( a5 && (*(_BYTE *)(dword_A9008 + 92 * a2 + 80) & 0x80) != 0 )
        a1[28] = v10;
    }
    else
    {
      v9 = 1;
      a1[29] = a2 | a1[29] & 0x200 ^ 0x200;
      if ( a5 )
        a1[28] = v10;
    }
  }
  if ( a3 == 3 )
  {
    a2 = 0;
    goto LABEL_20;
  }
LABEL_29:
  if ( v9 )
    v8 = v10;
  else
    v8 = -1;
  return v8;
}
// A9008: using guessed type int dword_A9008;

//----- (0001C151) --------------------------------------------------------
int __cdecl BG_PlayAnimName(int a1, char *src, int a3, int a4, int a5, int a6)
{
  int v6; // eax

  v6 = BG_AnimationIndexForString(src);
  return BG_PlayAnim(a1, v6, a3, 0, a4, a5, a6);
}
// 17454: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001C1A9) --------------------------------------------------------
int __cdecl BG_ExecuteCommand(int a1, __int16 *a2, int a3, int a4, int a5)
{
  int v6; // [esp+28h] [ebp-10h]
  _BOOL4 v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v8 = -1;
  v7 = 0;
  if ( *a2 )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = BG_PlayAnim(a1, a2[2], *a2, v8, a3, a4, a5) >= 0;
    else
      BG_PlayAnim(a1, a2[2], *a2, v8, a3, a4, a5);
  }
  if ( a2[1] )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = BG_PlayAnim(a1, a2[3], a2[1], v8, a3, a4, a5) >= 0;
    else
      BG_PlayAnim(a1, a2[3], a2[1], v8, a3, a4, a5);
  }
  if ( *((_DWORD *)a2 + 3) )
    (*(void (__cdecl **)(_DWORD, _DWORD))((char *)&dword_A7ADC + dword_A9008))(
      *(_DWORD *)(a1 + 212),
      *((_DWORD *)a2 + 3));
  if ( v7 )
    v6 = v8;
  else
    v6 = -1;
  return v6;
}
// 17454: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// A7ADC: using guessed type int dword_A7ADC;
// A9008: using guessed type int dword_A9008;

//----- (0001C377) --------------------------------------------------------
int __cdecl BG_AnimScriptAnimation(int a1, int a2, int a3, int a4)
{
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  if ( *(int *)(a1 + 4) > 5 )
    return -1;
  while ( !v6 && a2 >= 0 )
  {
    if ( *(_DWORD *)(516 * a3 + dword_A9008 + 9288 * a2 + 47108) )
    {
      v6 = sub_1BF35(*(_DWORD *)(a1 + 212), (_DWORD *)(516 * a3 + dword_A9008 + 9288 * a2 + 47108));
      if ( !v6 )
        --a2;
    }
    else
    {
      --a2;
    }
  }
  if ( !v6 )
    return -1;
  if ( !v6[34] )
    return -1;
  BG_UpdateConditionValue(*(_DWORD *)(a1 + 212), 5, a3, 1);
  return BG_ExecuteCommand(a1, &v6[4 * (*(_DWORD *)(a1 + 212) % v6[34]) + 35], 0, a4, 0) != -1;
}
// 17824: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// A9008: using guessed type int dword_A9008;

//----- (0001C4E3) --------------------------------------------------------
int __cdecl BG_AnimScriptStateChange(int a1, int a2, int a3)
{
  int v5; // [esp+28h] [ebp-10h]
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  if ( *(int *)(a1 + 4) > 5 )
    return -1;
  if ( !*(_DWORD *)(516 * a2 + dword_A9008 + 2064 * a3 + 121412) )
    return -1;
  v6 = sub_1BF35(*(_DWORD *)(a1 + 212), (_DWORD *)(516 * a2 + dword_A9008 + 2064 * a3 + 121412));
  if ( !v6 )
    return -1;
  if ( !v6[34] )
    return -1;
  v5 = (int)&v6[4 * (rand() % v6[34]) + 35];
  return BG_ExecuteCommand(a1, v5, 1, 0, 0);
}
// 17824: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// A9008: using guessed type int dword_A9008;

//----- (0001C5E3) --------------------------------------------------------
int __cdecl BG_AnimScriptEvent(int a1, int a2, int a3, int a4)
{
  int v6; // [esp+28h] [ebp-10h]
  _DWORD *v7; // [esp+2Ch] [ebp-Ch]
  _DWORD *v8; // [esp+30h] [ebp-8h]

  if ( a2 != 1 && *(int *)(a1 + 4) > 5 )
    return -1;
  v8 = (_DWORD *)(dword_A9008 + 516 * a2 + 129668);
  if ( !*v8 )
    return -1;
  v7 = sub_1BF35(*(_DWORD *)(a1 + 212), v8);
  if ( !v7 )
    return -1;
  if ( !v7[34] )
    return -1;
  v6 = (int)&v7[4 * (rand() % v7[34]) + 35];
  return BG_ExecuteCommand(a1, v6, 1, a3, a4);
}
// 17824: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// A9008: using guessed type int dword_A9008;

//----- (0001C6D5) --------------------------------------------------------
int __cdecl BG_GetAnimString(int a1, unsigned int a2)
{
  char v3; // [esp+4h] [ebp-4h]

  if ( a2 >= *(_DWORD *)(dword_A9008 + 47104) )
    BG_AnimParseError("BG_GetAnimString: anim index is out of range", v3);
  return dword_A9008 + 92 * a2;
}
// 1C701: variable 'v3' is possibly undefined
// A9008: using guessed type int dword_A9008;

//----- (0001C718) --------------------------------------------------------
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( !a4 || *(int *)((char *)&dword_A9480 + (_DWORD)&dword_0[2 * a2]) )
  {
    result = a3;
    *(int *)((char *)dword_A7F5C + (_DWORD)&bgs + 1232 * a1 + 8 * a2) = a3;
  }
  else
  {
    *(int *)((char *)dword_A7F5C + (_DWORD)&bgs + 1232 * a1 + 8 * a2) = 0;
    *(int *)((char *)&dword_A7F60 + (_DWORD)&bgs + 1232 * a1 + 8 * a2) = 0;
    result = Com_BitSet((char *)&dword_A7F5C[308 * a1 + 2 * a2] + (_DWORD)&bgs, a3);
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 19804: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);
// A7F5C: using guessed type int dword_A7F5C[];
// A7F60: using guessed type int dword_A7F60;
// A9480: using guessed type int dword_A9480;

//----- (0001C7CE) --------------------------------------------------------
unsigned int __cdecl sub_1C7CE(int a1, int a2, int a3)
{
  unsigned int i; // [esp+Ch] [ebp-Ch]

  if ( !a3 || *(int *)((char *)&dword_A9480 + (_DWORD)&dword_0[2 * a2]) )
    return *(_DWORD *)(a1 + 8 * a2 + 1128);
  for ( i = 0; i <= 0x3F; ++i )
  {
    if ( Com_BitCheck(a1 + 8 * a2 + 1128, i) )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// A9480: using guessed type int dword_A9480;

//----- (0001C85A) --------------------------------------------------------
int __cdecl BG_GetAnimScriptEvent(int a1, int a2)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]

  if ( a2 != 1 && *(int *)(a1 + 4) > 5 )
    return -1;
  v5 = (_DWORD *)(dword_A9008 + 516 * a2 + 129668);
  if ( !*v5 )
    return -1;
  v4 = sub_1BF35(*(_DWORD *)(a1 + 212), v5);
  if ( !v4 )
    return -1;
  if ( v4[34] )
    return SLOWORD(v4[4 * (rand() % v4[34]) + 36]);
  return -1;
}
// A9008: using guessed type int dword_A9008;

//----- (0001C928) --------------------------------------------------------
int __cdecl BG_GetAnimationForIndex(int a1, unsigned int a2)
{
  char v3; // [esp+8h] [ebp-10h]

  if ( a2 >= *(_DWORD *)(dword_A9008 + 47104) )
    Com_Error(1, byte_994A0, v3);
  return dword_A9008 + 92 * a2;
}
// 1C95C: variable 'v3' is possibly undefined
// A9008: using guessed type int dword_A9008;

//----- (0001C973) --------------------------------------------------------
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = *(_DWORD *)a1;
  BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)a1 + 212), 0, *(_DWORD *)(*(_DWORD *)a1 + 216), 1);
  v1 = BG_GetInfoForWeapon(*(_DWORD *)(v6 + 216));
  BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 1, *(_DWORD *)(v1 + 128), 1);
  if ( (*(_DWORD *)(v6 + 132) & 0x100) != 0 )
    BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 9, 1, 1);
  else
    BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 9, 0, 1);
  if ( (*(_DWORD *)(v6 + 132) & 0x100000) != 0 )
  {
    v4 = *(_DWORD *)(v6 + 1556);
    if ( v4 == 2 )
    {
      BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 2, 3, 1);
    }
    else if ( v4 > 2 )
    {
      if ( v4 <= 6 )
        BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 2, *(_DWORD *)(v6 + 1556) + 1, 1);
    }
    else if ( v4 == 1 )
    {
      BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 2, 2, 1);
    }
    v3 = *(_DWORD *)(v6 + 1560);
    if ( v3 == 2 )
    {
      BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 3, 1, 1);
    }
    else if ( v3 > 2 )
    {
      if ( v3 != 5 )
        goto LABEL_22;
      BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 3, 3, 1);
    }
    else
    {
      if ( v3 != 1 )
      {
LABEL_22:
        Com_Error(1, byte_994E0, *(_DWORD *)(v6 + 1560));
        goto LABEL_23;
      }
      BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 3, 2, 1);
    }
LABEL_23:
    BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 4, *(_DWORD *)(v6 + 1564), 1);
    goto LABEL_28;
  }
  if ( (*(_DWORD *)(v6 + 132) & 0x6000) != 0 )
    BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 2, 1, 1);
  else
    BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 2, 0, 1);
  BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 3, 0, 1);
  BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 4, 0, 1);
LABEL_28:
  BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 6, *(float *)(v6 + 232) > 0.0, 1);
  v5 = a1[8] & 1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 0x800000) != 0 )
    v5 = 0;
  if ( v5 )
    result = BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 8, 1, 1);
  else
    result = BG_UpdateConditionValue(*(_DWORD *)(v6 + 212), 8, 0, 1);
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001CDAC) --------------------------------------------------------
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, int a2)
{
  return (*(_BYTE *)(BG_GetAnimationForIndex(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0xC4) != 0;
}
// 16E94: using guessed type _DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD);

//----- (0001CE04) --------------------------------------------------------
_BOOL4 __cdecl BG_IsProneAnim(int a1, int a2)
{
  return (*(_DWORD *)(BG_GetAnimationForIndex(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0x308) != 0;
}
// 16E94: using guessed type _DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD);

//----- (0001CE5F) --------------------------------------------------------
_DWORD *__cdecl sub_1CE5F(int *a1, int *a2, int a3, int a4)
{
  int v4; // esi
  int v5; // esi
  _DWORD *result; // eax
  float v7; // [esp+8h] [ebp-70h]
  float v8; // [esp+Ch] [ebp-6Ch]
  float v9; // [esp+Ch] [ebp-6Ch]
  float v10; // [esp+Ch] [ebp-6Ch]
  float v11; // [esp+Ch] [ebp-6Ch]
  float v12; // [esp+Ch] [ebp-6Ch]
  float v13; // [esp+Ch] [ebp-6Ch]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+40h] [ebp-38h]
  int v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  float v19; // [esp+54h] [ebp-24h]
  float v20; // [esp+54h] [ebp-24h]
  int v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int v23; // [esp+64h] [ebp-14h]
  int v24; // [esp+68h] [ebp-10h]
  char *v25; // [esp+6Ch] [ebp-Ch]
  unsigned int v26; // [esp+88h] [ebp+10h]

  v23 = -1;
  v21 = 0;
  v19 = 0.0;
  v24 = a2[5];
  v22 = a2[4];
  if ( !v24 )
    v21 = 1;
  a2[4] = a3;
  v26 = a3 & 0xFFFFFDFF;
  if ( v26 >= bgs[11776] )
    Com_Error(1, byte_99540, bgs[11776]);
  v18 = a1[305];
  v17 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
  HIWORD(v16) = Scr_GetAnimsIndex(v17);
  if ( v26 )
  {
    v25 = (char *)&bgs[23 * v26];
    a2[5] = (int)v25;
    a2[6] = *((_DWORD *)v25 + 16);
    if ( a2 == a1 + 224 )
    {
      v4 = BG_IsCrouchingAnim(a1, v26);
      if ( v4 != BG_IsCrouchingAnim(a1, v22) || (v5 = BG_IsProneAnim(a1, v26), v5 != BG_IsProneAnim(a1, v22)) )
        a1[304] = bg[0] + 400;
    }
  }
  else
  {
    v25 = 0;
    a2[5] = 0;
    a2[6] = 200;
  }
  if ( v21 && a2 == a1 + 224 )
  {
    a2[6] = 0;
  }
  else
  {
    if ( !v25 || a2[6] <= 0 )
    {
      if ( v25 && *((_DWORD *)v25 + 17) )
      {
        v23 = 120;
      }
      else if ( v24 && *(_DWORD *)(v24 + 68) )
      {
        v23 = 250;
      }
      else
      {
        v23 = 170;
      }
    }
    if ( a1[304] - bg[0] > v23 )
      v23 = a1[304] - bg[0];
    if ( a2[6] < v23 )
      a2[6] = v23;
  }
  if ( v25 )
  {
    if ( *((_DWORD *)v25 + 17) )
    {
      LOWORD(v16) = v26;
      if ( trap_XAnimIsLooped(v16) )
      {
        LOWORD(v16) = v22 & 0xFDFF;
        if ( v24 && *(_DWORD *)(v24 + 68) && trap_XAnimIsLooped(v16) )
        {
          v19 = trap_XAnimGetTime(v18, v16);
        }
        else
        {
          if ( trap_XAnimIsPrimitive(v16) )
            v15 = trap_XAnimGetLength(v17, (unsigned __int16)v16) + 200;
          else
            v15 = 1000;
          v20 = (long double)(bg[0] % v15) / (long double)v15 + (long double)a1[2] * 0.36000001;
          v19 = v20 - (long double)(int)v20;
        }
      }
    }
  }
  if ( v24 )
  {
    v7 = (long double)a2[6] * 0.001;
    trap_XAnimClearGoalWeight(v18, v22 & 0xFDFF, LODWORD(v7));
  }
  if ( v26 )
  {
    if ( a2 != a1 + 224 )
    {
      a1[256] = 0;
      a1[257] = 1;
    }
    LOWORD(v16) = v26;
    if ( (*((_DWORD *)v25 + 20) & 0x40) != 0 )
    {
      if ( trap_XAnimIsLooped(v16) )
        Com_Error(1, "death animation '%s' is looping", (char)v25);
      if ( a4 )
      {
        v8 = (long double)a2[6] * 0.001;
        trap_XAnimSetCompleteGoalWeight(v18, v26, 1065353216, LODWORD(v8), 1065353216, 0, 0);
      }
      else
      {
        trap_XAnimSetCompleteGoalWeightKnobAll(
          v18,
          v26,
          *(int *)((char *)&dword_A7AE4 + (_DWORD)bgs),
          1065353216,
          0,
          1065353216,
          0,
          0);
        trap_XAnimSetTime(v18, v26, 1065353216);
      }
    }
    else
    {
      v14 = 0;
      if ( *((_DWORD *)v25 + 17) && trap_XAnimGetWeight(v18, v26) == 0.0 )
        v14 = 1;
      v9 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        v26,
        1065353216,
        LODWORD(v9),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        a2 != a1 + 224);
      if ( v14 )
        trap_XAnimSetTime(v18, v26, LODWORD(v19));
    }
    if ( a2 != a1 + 224 )
    {
      v10 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        *(int *)((char *)&dword_A7ACC + (_DWORD)bgs),
        1065353216,
        LODWORD(v10),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        0);
      v11 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        *(int *)((char *)&dword_A7AD0 + (_DWORD)bgs),
        1008981770,
        LODWORD(v11),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        0);
    }
  }
  else if ( a2 != a1 + 224 )
  {
    v12 = (long double)a2[6] * 0.001;
    trap_XAnimSetCompleteGoalWeight(
      v18,
      *(int *)((char *)&dword_A7ACC + (_DWORD)bgs),
      0,
      LODWORD(v12),
      1065353216,
      0,
      0);
    v13 = (long double)a2[6] * 0.001;
    trap_XAnimSetCompleteGoalWeight(
      v18,
      *(int *)((char *)&dword_A7AD0 + (_DWORD)bgs),
      1065353216,
      LODWORD(v13),
      1065353216,
      0,
      0);
  }
  result = bg_debugAnim;
  if ( bg_debugAnim[3] == 1 )
  {
    if ( a2 == a1 + 224 )
      result = (_DWORD *)Com_Printf("Anim-%s: %i, %s, (blend time) %i\n", (char)"legs ");
    else
      result = (_DWORD *)Com_Printf("Anim-%s: %i, %s, (blend time) %i\n", (char)"torso");
  }
  return result;
}
// 168C4: using guessed type _DWORD __cdecl trap_XAnimSetCompleteGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16BB4: using guessed type _DWORD __cdecl BG_IsProneAnim(_DWORD, _DWORD);
// 16CA4: using guessed type _DWORD __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(_DWORD, __int16, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17054: using guessed type _DWORD __cdecl BG_IsCrouchingAnim(_DWORD, _DWORD);
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 17AE4: using guessed type _DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD);
// 17E84: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 185D4: using guessed type _DWORD __cdecl trap_XAnimIsLooped(_DWORD);
// 186D4: using guessed type _DWORD __cdecl trap_XAnimClearGoalWeight(_DWORD, __int16, _DWORD);
// 19234: using guessed type long double __cdecl trap_XAnimGetTime(_DWORD, __int16);
// 19554: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);
// 195B4: using guessed type _DWORD __cdecl trap_XAnimSetTime(_DWORD, __int16, _DWORD);
// A7AC8: using guessed type int dword_A7AC8;
// A7ACC: using guessed type int dword_A7ACC;
// A7AD0: using guessed type int dword_A7AD0;
// A7AE4: using guessed type int dword_A7AE4;

//----- (0001D56D) --------------------------------------------------------
unsigned int __cdecl sub_1D56D(int *a1, unsigned int a2, int a3, int a4)
{
  unsigned int result; // eax
  int v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+40h] [ebp-18h]
  int v10; // [esp+50h] [ebp-8h]

  v5 = 0;
  if ( *(_DWORD *)(a2 + 20) && (*(_DWORD *)(*(_DWORD *)(a2 + 20) + 80) & 2) != 0 )
    v5 = 1;
  v9 = a1[305];
  Scr_GetAnimsIndex(*(int *)((char *)&dword_A7AC8 + (_DWORD)bgs));
  if ( a3 != *(_DWORD *)(a2 + 16) || !*(_DWORD *)(a2 + 20) && (a3 & 0xFFFFFDFF) != 0 )
    sub_1CE5F(a1, (int *)a2, a3, (*(_DWORD *)(a4 + 8) >> 10) & 1);
  result = a3 & 0xFFFFFDFF;
  if ( (a3 & 0xFFFFFDFF) != 0 )
  {
    v10 = *(_DWORD *)(a2 + 20);
    if ( *(_DWORD *)(v10 + 68) && *(_DWORD *)(a2 + 44) )
    {
      if ( bg[1] != *(_DWORD *)(a2 + 44) )
      {
        if ( v5 )
          v7 = fabs(*(float *)(a2 + 36) - *(float *)(a4 + 32));
        else
          v7 = VectorDistance(a2 + 28, a4 + 24);
        v8 = v7 / ((long double)(bg[1] - *(_DWORD *)(a2 + 44)) * 0.001);
        *(float *)(a2 + 40) = v8 / (long double)*(int *)(v10 + 68);
        *(_DWORD *)(a2 + 44) = bg[1];
        *(_DWORD *)(a2 + 28) = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a2 + 32) = *(_DWORD *)(a4 + 28);
        *(_DWORD *)(a2 + 36) = *(_DWORD *)(a4 + 32);
        if ( *(float *)(a2 + 40) >= 0.1 )
        {
          if ( *(float *)(a2 + 40) > 2.0 )
          {
            if ( (*(_DWORD *)(v10 + 80) & 2) != 0 )
            {
              if ( *(float *)(a2 + 40) > 4.0 )
                *(_DWORD *)(a2 + 40) = 1082130432;
            }
            else if ( *(int *)(v10 + 68) <= 150 )
            {
              if ( *(int *)(v10 + 68) > 19 )
              {
                v6 = 3.0 - (long double)(*(_DWORD *)(v10 + 68) - 20) / 130.0;
                if ( *(float *)(a2 + 40) > (long double)v6 )
                  *(float *)(a2 + 40) = v6;
              }
              else if ( *(float *)(a2 + 40) > 3.0 )
              {
                *(_DWORD *)(a2 + 40) = 1077936128;
              }
            }
            else
            {
              *(_DWORD *)(a2 + 40) = 0x40000000;
            }
          }
        }
        else if ( *(float *)(a2 + 40) < 0.0099999998 && v5 )
        {
          *(_DWORD *)(a2 + 40) = 0;
        }
        else
        {
          *(_DWORD *)(a2 + 40) = 1036831949;
        }
        if ( bg_debugAnim[3] == 2 )
          Com_Printf("MoveSpeed: %s, %i, %4.4f : %1.4f\n", 92 * a3 + (unsigned __int8)bgs);
      }
    }
    else
    {
      *(_DWORD *)(a2 + 40) = 1065353216;
      *(_DWORD *)(a2 + 44) = bg[1];
      *(_DWORD *)(a2 + 28) = *(_DWORD *)(a4 + 24);
      *(_DWORD *)(a2 + 32) = *(_DWORD *)(a4 + 28);
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(a4 + 32);
    }
    result = a2;
    if ( *(_DWORD *)(a2 + 16) )
      result = trap_XAnimSetAnimRate(v9, *(_WORD *)(a2 + 16) & 0xFDFF, *(_DWORD *)(a2 + 40));
  }
  return result;
}
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 18224: using guessed type _DWORD __cdecl trap_XAnimSetAnimRate(_DWORD, __int16, _DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// A7AC8: using guessed type int dword_A7AC8;

//----- (0001D922) --------------------------------------------------------
void __cdecl sub_1D922(int a1, _DWORD *a2)
{
  Scr_GetAnimsIndex(*(int *)((char *)&dword_A7AC8 + (_DWORD)bgs));
  if ( a2[4] )
  {
    if ( trap_XAnimGetWeight(a1, a2[4] & 0xFDFF) == 0.0 )
    {
      a2[4] = 0;
      a2[5] = 0;
      a2[6] = 150;
    }
  }
}
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 17E84: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// A7AC8: using guessed type int dword_A7AC8;

//----- (0001D9B4) --------------------------------------------------------
void __usercall sub_1D9B4(long double a1@<st0>, float a2, float a3, float a4, float a5, int a6, int a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  float v10; // [esp+0h] [ebp-28h]
  float v11; // [esp+0h] [ebp-28h]
  float v12; // [esp+0h] [ebp-28h]
  float v13; // [esp+18h] [ebp-10h]
  float v14; // [esp+18h] [ebp-10h]
  float v15; // [esp+1Ch] [ebp-Ch]
  float v16; // [esp+20h] [ebp-8h]
  float v17; // [esp+20h] [ebp-8h]
  float v18; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)a7 )
  {
    AngleSubtract(*(float *)a6, a2);
    v16 = a1;
    a1 = a3;
    if ( v16 > (long double)a3 || (a1 = v16, -a3 > (long double)v16) )
      *(_DWORD *)a7 = 1;
  }
  if ( *(_DWORD *)a7 )
  {
    AngleSubtract(a2, *(float *)a6);
    v17 = a1;
    v13 = fabs(v17);
    v14 = v13 * 0.050000001;
    if ( v14 < 0.5 )
      v14 = 0.5;
    if ( v17 < 0.0 )
    {
      v7 = v17;
      if ( v17 >= 0.0 )
        goto LABEL_17;
      v15 = (long double)bg[2] * v14 * -a5;
      if ( v17 < (long double)v15 )
      {
        *(_DWORD *)a7 = 1;
      }
      else
      {
        v15 = v17;
        *(_DWORD *)a7 = 0;
      }
    }
    else
    {
      v15 = (long double)bg[2] * v14 * a5;
      if ( v15 < (long double)v17 )
      {
        *(_DWORD *)a7 = 1;
      }
      else
      {
        v15 = a1;
        *(_DWORD *)a7 = 0;
      }
    }
    v7 = *(float *)a6 + v15;
    v10 = v7;
    AngleMod(v10);
    *(float *)a6 = v7;
LABEL_17:
    AngleSubtract(a2, *(float *)a6);
    v18 = v7;
    if ( v18 <= (long double)a4 )
    {
      if ( -a4 > (long double)v18 )
      {
        v9 = a2 + a4;
        v12 = v9;
        AngleMod(v12);
        *(float *)a6 = v9;
      }
    }
    else
    {
      v8 = a2 - a4;
      v11 = v8;
      AngleMod(v11);
      *(float *)a6 = v8;
    }
  }
}

//----- (0001DBAC) --------------------------------------------------------
void __usercall sub_1DBAC(long double a1@<st0>, _DWORD *a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+20h] [ebp-48h]
  float v6; // [esp+24h] [ebp-44h]
  float v7; // [esp+34h] [ebp-34h]
  float v8; // [esp+44h] [ebp-24h]
  float v9; // [esp+50h] [ebp-18h]
  int v10; // [esp+58h] [ebp-10h]
  float v11; // [esp+5Ch] [ebp-Ch]

  GetLeanFraction(*(float *)(a3 + 996));
  v9 = *(float *)(a3 + 992);
  v5 = *(float *)(a3 + 1000);
  AngleMod(*(float *)(a3 + 1004));
  v6 = a1;
  if ( (a2[2] & 0x106000) == 0 || BG_AllowPlayerWeaponAtVehiclePos(((int)a2[34] >> 3) & 7, a2[34] & 7) )
  {
    if ( (sub_1C7CE(a3, 5, 0) & 0x30000) != 0 )
    {
      *(_DWORD *)(a3 + 948) = 1;
      *(_DWORD *)(a3 + 956) = 1;
      *(_DWORD *)(a3 + 900) = 1;
    }
    else if ( (sub_1C7CE(a3, 5, 0) & 6) != 0 )
    {
      if ( sub_1C7CE(a3, 8, 1) )
      {
        *(_DWORD *)(a3 + 948) = 1;
        *(_DWORD *)(a3 + 956) = 1;
      }
    }
    else
    {
      *(_DWORD *)(a3 + 948) = 1;
      *(_DWORD *)(a3 + 956) = 1;
      *(_DWORD *)(a3 + 900) = 1;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 948) = 1;
    *(_DWORD *)(a3 + 956) = 1;
    *(_DWORD *)(a3 + 900) = 1;
  }
  v3 = v6 + v9;
  v8 = v3;
  if ( (a2[2] & 1) != 0 )
  {
    v8 = v6;
    v7 = v6;
    v10 = 1119092736;
  }
  else if ( (sub_1C7CE(a3, 5, 0) & 0x30000) != 0 )
  {
    v7 = v3;
    v10 = 0;
  }
  else if ( (a2[2] & 0x40) != 0 )
  {
    v7 = v6;
    v10 = 1119092736;
  }
  else if ( (a2[2] & 0x200) != 0 )
  {
    v7 = v6;
    v10 = 1110704128;
  }
  else
  {
    if ( (a2[2] & 0x100) != 0 )
    {
      v7 = v6;
    }
    else
    {
      v3 = v9 * 0.30000001 + v6;
      v7 = v3;
    }
    v10 = 1119092736;
  }
  if ( (a2[2] & 0x106000) != 0 && BG_AllowPlayerWeaponAtVehiclePos(((int)a2[34] >> 3) & 7, a2[34] & 7) && a2[51] )
    v8 = *(float *)(a3 + 1016);
  sub_1D9B4(v3, v7, 0.0, *(float *)&v10, bg_swingSpeed[2], a3 + 944, a3 + 948);
  if ( (a2[2] & 1) != 0 )
    goto LABEL_27;
  if ( (a2[2] & 0x40) != 0 )
  {
    *(_DWORD *)(a3 + 900) = 0;
    v3 = v6 + v9;
    *(float *)(a3 + 896) = v3;
  }
  else if ( (bgs[23 * (a2[52] & 0xFFFFFDFF) + 20] & 0x30) != 0 )
  {
    *(_DWORD *)(a3 + 900) = 0;
    sub_1D9B4(v3, v6, 0.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
  }
  else
  {
    if ( *(_DWORD *)(a3 + 900) )
    {
LABEL_27:
      sub_1D9B4(v3, v8, 0.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
      goto LABEL_34;
    }
    sub_1D9B4(v3, v8, 40.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
  }
LABEL_34:
  if ( (a2[2] & 0x106000) != 0 )
  {
    *(float *)(a3 + 944) = v6;
    *(float *)(a3 + 896) = v6;
  }
  else if ( (sub_1C7CE(a3, 5, 0) & 0x30000) != 0 )
  {
    *(float *)(a3 + 944) = v6 + v9;
    v3 = v6 + v9;
    *(float *)(a3 + 896) = v3;
  }
  if ( (a2[2] & 1) != 0 || (a2[2] & 0x106000) != 0 || (sub_1C7CE(a3, 5, 0) & 0x30000) != 0 )
  {
    sub_1D9B4(v3, 0.0, 0.0, 45.0, 0.15000001, a3 + 952, a3 + 956);
  }
  else
  {
    if ( v5 <= 180.0 )
      v4 = v5 * 0.60000002;
    else
      v4 = (v5 + -360.0) * 0.60000002;
    v11 = v4;
    sub_1D9B4(v4, v11, 0.0, 45.0, 0.15000001, a3 + 952, a3 + 956);
  }
}
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (0001E194) --------------------------------------------------------
int __cdecl sub_1E194(_DWORD *a1, int a2)
{
  int v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  unsigned int v6; // [esp+20h] [ebp-8h]

  BG_UpdateConditionValue(a1[37], 0, a1[51], 1);
  v2 = BG_GetInfoForWeapon(a1[51]);
  BG_UpdateConditionValue(a1[37], 1, *(_DWORD *)(v2 + 128), 1);
  if ( (a1[2] & 0x100) != 0 )
    BG_UpdateConditionValue(a1[37], 9, 1, 1);
  else
    BG_UpdateConditionValue(a1[37], 9, 0, 1);
  if ( (a1[2] & 0x100000) != 0 )
  {
    v5 = a1[34] & 7;
    if ( v5 == 2 )
    {
      BG_UpdateConditionValue(a1[37], 2, 3, 1);
    }
    else if ( (a1[34] & 7u) > 2 )
    {
      if ( (a1[34] & 7) != 7 )
        BG_UpdateConditionValue(a1[37], 2, (a1[34] & 7) + 1, 1);
    }
    else if ( v5 == 1 )
    {
      BG_UpdateConditionValue(a1[37], 2, 2, 1);
    }
    v4 = ((int)a1[34] >> 3) & 7;
    if ( v4 == 2 )
    {
      BG_UpdateConditionValue(a1[37], 3, 1, 1);
    }
    else if ( (((int)a1[34] >> 3) & 7u) > 2 )
    {
      if ( v4 != 5 )
        goto LABEL_22;
      BG_UpdateConditionValue(a1[37], 3, 3, 1);
    }
    else
    {
      if ( v4 != 1 )
      {
LABEL_22:
        Com_Error(1, byte_99680, ((int)a1[34] >> 3) & 7);
        goto LABEL_23;
      }
      BG_UpdateConditionValue(a1[37], 3, 2, 1);
    }
LABEL_23:
    BG_UpdateConditionValue(a1[37], 4, ((int)a1[34] >> 6) & 3, 1);
    goto LABEL_25;
  }
  BG_UpdateConditionValue(a1[37], 2, 0, 1);
  BG_UpdateConditionValue(a1[37], 3, 0, 1);
  BG_UpdateConditionValue(a1[37], 4, 0, 1);
LABEL_25:
  BG_UpdateConditionValue(a1[37], 6, *(float *)(a2 + 1000) > 0.0, 1);
  if ( (a1[2] & 0x20) != 0 )
    BG_UpdateConditionValue(a1[37], 7, 1, 1);
  else
    BG_UpdateConditionValue(a1[37], 7, 0, 1);
  if ( (a1[2] & 0x200) != 0 )
    BG_UpdateConditionValue(a1[37], 8, 1, 1);
  else
    BG_UpdateConditionValue(a1[37], 8, 0, 1);
  v6 = a1[52] & 0xFFFFFDFF;
  if ( bgs[23 * v6 + 21] )
    BG_UpdateConditionValue(a1[37], 5, bgs[23 * v6 + 21], 0);
  if ( (bgs[23 * v6 + 20] & 0x10) != 0 )
    return BG_UpdateConditionValue(a1[37], 10, 1, 1);
  if ( (bgs[23 * v6 + 20] & 0x20) != 0 )
    return BG_UpdateConditionValue(a1[37], 10, 2, 1);
  return BG_UpdateConditionValue(a1[37], 10, 0, 1);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001E6EC) --------------------------------------------------------
int sub_1E6EC()
{
  return 0;
}

//----- (0001E6F6) --------------------------------------------------------
int __cdecl sub_1E6F6(int a1)
{
  return trap_XModelGet(a1);
}
// 18714: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);

//----- (0001E719) --------------------------------------------------------
int __cdecl sub_1E719(int a1, unsigned __int16 a2, int a3, int a4)
{
  return trap_DObjCreate(a1, a2, a3, a4, 0);
}
// 16BE4: using guessed type _DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001E761) --------------------------------------------------------
int __usercall sub_1E761@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, int a6)
{
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  int result; // eax
  float v11; // [esp+0h] [ebp-E8h]
  float v12; // [esp+0h] [ebp-E8h]
  int i; // [esp+30h] [ebp-B8h]
  float v14; // [esp+34h] [ebp-B4h] BYREF
  float v15[2]; // [esp+38h] [ebp-B0h] BYREF
  float v16; // [esp+40h] [ebp-A8h] BYREF
  float v17; // [esp+44h] [ebp-A4h]
  float v18; // [esp+48h] [ebp-A0h]
  float v19; // [esp+50h] [ebp-98h] BYREF
  float v20; // [esp+54h] [ebp-94h]
  float v21; // [esp+58h] [ebp-90h]
  float v22; // [esp+6Ch] [ebp-7Ch]
  float v23; // [esp+70h] [ebp-78h]
  float v24; // [esp+74h] [ebp-74h]
  int v25; // [esp+78h] [ebp-70h]
  float v26; // [esp+80h] [ebp-68h] BYREF
  float v27; // [esp+84h] [ebp-64h]
  float v28; // [esp+88h] [ebp-60h]
  float v29; // [esp+90h] [ebp-58h]
  float v30; // [esp+94h] [ebp-54h]
  float v31; // [esp+98h] [ebp-50h]
  float v32; // [esp+9Ch] [ebp-4Ch]
  float v33; // [esp+A0h] [ebp-48h]
  float v34; // [esp+A4h] [ebp-44h]
  float v35; // [esp+A8h] [ebp-40h]
  float v36; // [esp+ACh] [ebp-3Ch]
  float v37; // [esp+B0h] [ebp-38h]
  float v38; // [esp+B4h] [ebp-34h]
  float v39; // [esp+B8h] [ebp-30h]
  int v40; // [esp+BCh] [ebp-2Ch]
  float v41; // [esp+C0h] [ebp-28h]
  float v42; // [esp+C4h] [ebp-24h]
  float v43; // [esp+C8h] [ebp-20h]
  float v44; // [esp+CCh] [ebp-1Ch]
  int v45; // [esp+D0h] [ebp-18h]
  int v46; // [esp+D4h] [ebp-14h]

  v15[1] = *(float *)(a3 + 148);
  v28 = 0.0;
  v27 = 0.0;
  v26 = 0.0;
  v21 = 0.0;
  v20 = 0.0;
  v19 = 0.0;
  v16 = *(float *)(a5 + 1000);
  v17 = *(float *)(a5 + 1004);
  v18 = *(float *)(a5 + 1008);
  v27 = *(float *)(a5 + 896);
  v20 = *(float *)(a5 + 944);
  if ( (*(_DWORD *)(a3 + 8) & 0x100000) != 0 )
  {
    v26 = *(float *)(a5 + 1012);
    v27 = *(float *)(a5 + 1016);
    v28 = *(float *)(a5 + 1020);
    if ( *(_DWORD *)(a3 + 204)
      && BG_AllowPlayerWeaponAtVehiclePos((*(int *)(a3 + 136) >> 3) & 7, *(_DWORD *)(a3 + 136) & 7) )
    {
      v19 = *(float *)(a5 + 1000);
      v20 = *(float *)(a5 + 1004);
      v21 = *(float *)(a5 + 1008);
      v16 = *(float *)(a5 + 1000);
      v17 = *(float *)(a5 + 1004);
      v18 = *(float *)(a5 + 1008);
    }
    else
    {
      v19 = v26;
      v20 = v27;
      v21 = v28;
      v16 = *(float *)(a5 + 1000);
      v17 = *(float *)(a5 + 1004);
      v18 = *(float *)(a5 + 1008);
    }
    AngleSubtract(v17, v20);
    v17 = a1;
    if ( v17 <= 90.0 )
    {
      if ( v17 < -90.0 )
        v17 = -180.0 - v17;
    }
    else
    {
      v17 = 180.0 - v17;
    }
    a1 = v17 + v20;
    v11 = a1;
    AngleNormalize180(v11);
    v17 = a1;
  }
  if ( (*(_DWORD *)(a3 + 8) & 0x100000) == 0 && (sub_1C7CE(a5, 5, 0) & 0x30000) == 0 )
  {
    v19 = *(float *)(a5 + 952);
    if ( (*(_DWORD *)(a3 + 8) & 0x40) != 0 )
    {
      AngleNormalize180(v19);
      v19 = a1;
      if ( v19 <= 0.0 )
        a1 = v19 * 0.25;
      else
        a1 = v19 * 0.5;
      v19 = a1;
    }
  }
  AnglesSubtract(&v16, &v19, &v16);
  AnglesSubtract(&v19, &v26, &v19);
  if ( (*(_DWORD *)(a3 + 8) & 0x100000) != 0 )
  {
    v28 = 0.0;
    v27 = 0.0;
    v26 = 0.0;
  }
  v23 = 0.0;
  v24 = 0.0;
  v25 = *(_DWORD *)(a3 + 232);
  GetLeanFraction(*(float *)(a5 + 996));
  v22 = a1;
  v21 = v22 * 50.0 * 0.92500001;
  v18 = v21;
  v6 = -v22 * 2.5 + v24;
  v24 = v6;
  if ( (*(_DWORD *)(a3 + 8) & 1) == 0 && (*(_DWORD *)(a3 + 8) & 0x100000) == 0 )
  {
    AngleSubtract(v27, *(float *)(a5 + 1004));
    v27 = v6;
  }
  if ( (*(_DWORD *)(a3 + 8) & 0x40) != 0 )
  {
    if ( v22 != 0.0 )
      v18 = v18 * 0.5;
    v26 = v26 + *(float *)(a3 + 236);
    v12 = v20 * 3.141592653589793 / 180.0;
    sub_1FA4D(v12, v15, &v14);
    v23 = (1.0 - v14) * -24.0 + v23;
    v24 = v15[0] * -12.0 + v24;
    if ( v22 * v15[0] > 0.0 )
      v24 = -v22 * (1.0 - v14) * 16.0 + v24;
    v29 = 0.0;
    v30 = v21 * -1.2;
    v31 = v21 * 0.30000001;
    v7 = 0.0;
    if ( *(float *)(a3 + 236) != 0.0 || (v7 = 0.0, *(float *)(a3 + 240) != 0.0) )
    {
      AngleSubtract(*(float *)(a3 + 236), *(float *)(a3 + 240));
      v29 = v7 + v29;
    }
    v32 = 0.0;
    v33 = v20 * 0.1 - v21 * 0.2;
    v34 = v21 * 0.2;
    v35 = v19;
    v36 = v20 * 0.80000001 - v21 * -1.0;
    v37 = v21 * -0.2;
  }
  else
  {
    if ( v22 != 0.0 )
    {
      if ( (*(_DWORD *)(a3 + 8) & 0x20) != 0 )
      {
        if ( v22 <= 0.0 )
        {
          v21 = v21 * 1.25;
          v18 = v18 * 1.25;
        }
        else
        {
          v21 = v21 * 1.5;
          v18 = v18 * 1.5;
        }
      }
      else if ( v22 <= 0.0 )
      {
        v21 = v21 * 1.25;
        v18 = v18 * 1.25;
      }
      else
      {
        v21 = v21 * 0.80000001;
        v18 = v18 * 0.80000001;
      }
    }
    v28 = v22 * 50.0 * 0.075000003 + v28;
    v29 = v19 * 0.2;
    v30 = v20 * 0.40000001;
    v31 = v21 * 0.5;
    v8 = 0.0;
    if ( *(float *)(a3 + 236) != 0.0 || (v8 = 0.0, *(float *)(a3 + 240) != 0.0) )
    {
      AngleSubtract(*(float *)(a3 + 236), *(float *)(a3 + 240));
      v29 = v8 + v29;
    }
    v32 = v19 * 0.30000001;
    v33 = v20 * 0.40000001;
    v34 = v21 * 0.5;
    v35 = v19 * 0.5;
    v36 = v20 * 0.2;
    v37 = v21 * -0.60000002;
  }
  v38 = v16 * 0.30000001;
  v39 = v17 * 0.30000001;
  v40 = 0;
  v41 = v16 * 0.69999999;
  v42 = v17 * 0.69999999;
  v43 = v18 * -0.30000001;
  v46 = 0;
  v45 = 0;
  v44 = 0.0;
  v9 = 0.0;
  if ( *(float *)(a3 + 240) != 0.0 || (v9 = 0.0, *(float *)(a3 + 236) != 0.0) )
  {
    AngleSubtract(*(float *)(a3 + 240), *(float *)(a3 + 236));
    v44 = v9;
  }
  for ( i = 0; i <= 5; ++i )
  {
    *(float *)(a6 + 12 * i) = *(&v29 + 3 * i);
    *(float *)(a6 + 12 * i + 4) = *(&v30 + 3 * i);
    *(float *)(a6 + 12 * i + 8) = *(&v31 + 3 * i);
  }
  *(float *)(a6 + 72) = v26;
  *(float *)(a6 + 76) = v27;
  *(float *)(a6 + 80) = v28;
  *(float *)(a6 + 84) = v23;
  *(float *)(a6 + 88) = v24;
  result = v25;
  *(_DWORD *)(a6 + 92) = v25;
  return result;
}
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (0001F107) --------------------------------------------------------
int *__cdecl sub_1F107(int a1, float a2, int a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-Ch] BYREF
  float v5; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a1 + 4 * i) - *(float *)(a3 + 4 * i);
    if ( v5 <= (long double)a2 )
    {
      if ( -a2 <= (long double)v5 )
        *(_DWORD *)(a3 + 4 * i) = *(_DWORD *)(a1 + 4 * i);
      else
        *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) - a2;
    }
    else
    {
      *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) + a2;
    }
    result = &i;
  }
  return result;
}

//----- (0001F1E7) --------------------------------------------------------
void __cdecl BG_LerpOffset(int a1, float a2, int a3)
{
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  v5 = *(float *)a1 - *(float *)a3;
  v6 = *(float *)(a1 + 4) - *(float *)(a3 + 4);
  v7 = *(float *)(a1 + 8) - *(float *)(a3 + 8);
  v3 = v5 * v5 + v6 * v6 + v7 * v7;
  if ( v3 != 0.0 )
  {
    v4 = (long double)Q_rsqrt(COERCE_FLOAT(COERCE_UNSIGNED_INT64(v3))) * a2;
    if ( v4 >= 1.0 )
    {
      *(_DWORD *)a3 = *(_DWORD *)a1;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
    }
    else
    {
      *(float *)a3 = v5 * v4 + *(float *)a3;
      *(float *)(a3 + 4) = v6 * v4 + *(float *)(a3 + 4);
      *(float *)(a3 + 8) = v7 * v4 + *(float *)(a3 + 8);
    }
  }
}

//----- (0001F2FE) --------------------------------------------------------
int __usercall BG_Player_DoControllers@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  float v6; // [esp+4h] [ebp-94h]
  _DWORD v7[18]; // [esp+20h] [ebp-78h] BYREF
  int v8; // [esp+68h] [ebp-30h] BYREF
  int v9; // [esp+74h] [ebp-24h] BYREF
  float v10; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  sub_1E761(a1, a2, a3, a4, a5, (int)v7);
  v10 = (long double)bg[2] * 0.36000001;
  for ( i = 0; i <= 5; ++i )
  {
    sub_1F107((int)&v7[3 * i], v10, a5 + 12 * i + 1032);
    G_DObjSetControlTagAngles(a2, a4, *(char **)((char *)off_A9420 + (_DWORD)&dword_0[i]), a5 + 12 * i + 1032);
  }
  sub_1F107((int)&v8, v10, a5 + 1104);
  v6 = (long double)bg[2] * 0.1;
  BG_LerpOffset((int)&v9, v6, a5 + 1116);
  return G_DObjSetLocalTag(a2, a4, "tag_origin", a5 + 1116, a5 + 1104);
}
// 0: using guessed type int dword_0[];
// 18B84: using guessed type _DWORD __cdecl G_DObjSetLocalTag(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18DB4: using guessed type _DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD);
// A9420: using guessed type char *off_A9420[6];

//----- (0001F462) --------------------------------------------------------
unsigned int __usercall BG_PlayerAnimation@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int *a4)
{
  int v5; // [esp+14h] [ebp-4h]

  sub_1DBAC(a1, a3, (int)a4);
  sub_1E194(a3, (int)a4);
  v5 = a4[305];
  sub_1D922(v5, a4 + 224);
  sub_1D922(v5, a4 + 236);
  if ( a4[256] && (a4[240] & 0xFFFFFDFF) == 0 )
  {
    a4[256] = 0;
    a4[257] = 1;
  }
  sub_1D56D(a4, (unsigned int)(a4 + 224), a3[52], (int)a3);
  return sub_1D56D(a4, (unsigned int)(a4 + 236), a3[53], (int)a3);
}

//----- (0001F556) --------------------------------------------------------
_BYTE *__cdecl BG_UpdatePlayerDObj(int a1, int *a2, int a3, _BYTE *a4)
{
  _BYTE *result; // eax
  int v5; // [esp+18h] [ebp-A0h]
  int v6; // [esp+1Ch] [ebp-9Ch]
  _DWORD v7[2]; // [esp+20h] [ebp-98h] BYREF
  __int16 v8; // [esp+28h] [ebp-90h]
  _DWORD v9[30]; // [esp+2Ch] [ebp-8Ch]
  int v10; // [esp+A4h] [ebp-14h]
  int i; // [esp+A8h] [ebp-10h]
  int v12; // [esp+ACh] [ebp-Ch]

  v5 = trap_DObjExists(a1);
  v12 = a2[51];
  if ( (a2[2] & 0x106000) != 0 && !BG_AllowPlayerWeaponAtVehiclePos((a2[34] >> 3) & 7, a2[34] & 7) )
    v12 = 0;
  if ( !*(_DWORD *)a3 || !*(_BYTE *)(a3 + 64) )
    return (_BYTE *)trap_SafeDObjFree(*a2, 1);
  if ( v5 )
  {
    if ( *(_DWORD *)(a3 + 1224) == v12 && !*(_DWORD *)(a3 + 1028) )
    {
      result = (_BYTE *)*(unsigned __int8 *)(a3 + 1228);
      if ( (_BYTE)result == *a4 )
        return result;
    }
    trap_SafeDObjFree(*a2, 0);
  }
  v10 = *(_DWORD *)(a3 + 1220);
  v8 = sub_1E6EC();
  v7[0] = sub_1E6F6(a3 + 64);
  v7[1] = 0;
  v9[0] = 0;
  v6 = 1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(a3 + (i << 6) + 128) )
    {
      LOWORD(v7[4 * v6 + 2]) = sub_1E6EC();
      v7[4 * v6] = sub_1E6F6(a3 + (i << 6) + 128);
      v7[4 * v6 + 1] = a3 + (i << 6) + 512;
      v9[4 * v6++] = ((int)*(unsigned __int8 *)(a1 + 386) >> i) & 1;
    }
  }
  sub_1E719((int)v7, v6, v10, *a2);
  *(_DWORD *)(a3 + 1224) = v12;
  if ( *(_DWORD *)(a3 + 1028) )
  {
    *(_DWORD *)(a3 + 1028) = 0;
    ++*(_BYTE *)(a3 + 1228);
  }
  result = a4;
  *a4 = *(_BYTE *)(a3 + 1228);
  return result;
}
// 16874: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);
// 174E4: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (0001F830) --------------------------------------------------------
int BG_FindAnims()
{
  Scr_FindAnim("multiplayer", "root", (char *)&dword_A7AE4 + (_DWORD)bgs);
  Scr_FindAnim("multiplayer", "torso", (char *)&dword_A7AE8 + (_DWORD)bgs);
  Scr_FindAnim("multiplayer", "legs", (char *)&dword_A7AEC + (_DWORD)bgs);
  return Scr_FindAnim("multiplayer", "turning", (char *)&dword_A7AF0 + (_DWORD)bgs);
}
// 181B4: using guessed type _DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD);
// A7AE4: using guessed type int dword_A7AE4;
// A7AE8: using guessed type int dword_A7AE8;
// A7AEC: using guessed type int dword_A7AEC;
// A7AF0: using guessed type int dword_A7AF0;

//----- (0001F8E8) --------------------------------------------------------
_DWORD *__userpurge sub_1F8E8@<eax>(_DWORD *a1, char a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h] BYREF

  Scr_FindAnimTree(&v4);
  if ( !v4 && a3 )
    Com_Error(1, byte_99780, a2);
  *a1 = v4;
  return a1;
}
// 18174: using guessed type _DWORD __stdcall Scr_FindAnimTree(_DWORD);

//----- (0001F94A) --------------------------------------------------------
int BG_FindAnimTrees()
{
  int result; // eax

  sub_1F8E8((int *)((char *)&dword_A7AE0 + (_DWORD)bgs), (char)"multiplayer", 1);
  *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs) = *(int *)((char *)&dword_A7AE0 + (_DWORD)bgs);
  *(int *)((char *)&dword_A7ACC + (_DWORD)bgs) = *(int *)((char *)&dword_A7AE8 + (_DWORD)bgs);
  *(int *)((char *)&dword_A7AD0 + (_DWORD)bgs) = *(int *)((char *)&dword_A7AEC + (_DWORD)bgs);
  result = *(int *)((char *)&dword_A7AF0 + (_DWORD)bgs);
  *(int *)((char *)&dword_A7AD4 + (_DWORD)bgs) = result;
  return result;
}
// A7AC8: using guessed type int dword_A7AC8;
// A7ACC: using guessed type int dword_A7ACC;
// A7AD0: using guessed type int dword_A7AD0;
// A7AD4: using guessed type int dword_A7AD4;
// A7AE0: using guessed type int dword_A7AE0;
// A7AE8: using guessed type int dword_A7AE8;
// A7AEC: using guessed type int dword_A7AEC;
// A7AF0: using guessed type int dword_A7AF0;

//----- (0001F9EA) --------------------------------------------------------
int *BG_LoadAnimTreeInstances()
{
  int *result; // eax
  char *v1; // esi
  int *v2; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch] BYREF

  result = *(int **)((char *)&dword_A7AE0 + (_DWORD)bgs);
  v2 = result;
  for ( i = 0; i <= 63; ++i )
  {
    v1 = &aKeySValueS[(_DWORD)&bgs[308 * i]];
    *(_DWORD *)v1 = trap_XAnimCreateTree(v2);
    result = &i;
  }
  return result;
}
// 17654: using guessed type _DWORD __cdecl trap_XAnimCreateTree(_DWORD);
// A7AE0: using guessed type int dword_A7AE0;

//----- (0001FA4D) --------------------------------------------------------
float *__cdecl sub_1FA4D(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0001FA65) --------------------------------------------------------
void sub_1FA65()
{
  ;
}

//----- (0001FA6C) --------------------------------------------------------
char *__cdecl BG_FindItemForWeapon(int a1)
{
  if ( a1 < 0 || a1 > BG_GetNumWeapons() )
    Com_Error(1, byte_9A7E0, a1);
  return (char *)&bg_itemlist + 48 * a1;
}
// 17324: using guessed type int BG_GetNumWeapons(void);

//----- (0001FACA) --------------------------------------------------------
char *__cdecl BG_FindItem(int a1)
{
  int v1; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 1; i < bg_numItems; ++i )
  {
    if ( i > BG_GetNumWeapons() )
    {
      v4 = (_DWORD *)((char *)&bg_itemlist + 48 * i);
      if ( !Q_stricmp(v4[6], a1) || !Q_stricmp(*v4, a1) )
        return (char *)&bg_itemlist + 48 * i;
    }
    else
    {
      v1 = BG_GetInfoForWeapon(i);
      if ( !Q_stricmp(a1, *(_DWORD *)(v1 + 4)) )
        return (char *)&bg_itemlist + 48 * i;
    }
  }
  return 0;
}
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0001FBA8) --------------------------------------------------------
_BOOL4 __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3)
{
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  BG_EvaluateTrajectory(a2 + 12, a3, &v5);
  return a1[5] - v5 <= 36.0
      && a1[5] - v5 >= -36.0
      && a1[6] - v6 <= 36.0
      && a1[6] - v6 >= -36.0
      && a1[7] - v7 <= 18.0
      && a1[7] - v7 >= -88.0;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (0001FC7B) --------------------------------------------------------
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3)
{
  char v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+8h] [ebp-10h]
  char *v7; // [esp+10h] [ebp-8h]

  if ( *(int *)(a1 + 140) <= 0 || *(_DWORD *)(a1 + 140) >= bg_numItems )
    Com_Error(1, byte_9A820, v4);
  v7 = (char *)&bg_itemlist + 48 * *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 148) != a2[53] )
  {
    v5 = *((_DWORD *)v7 + 8);
    if ( v5 != 1 )
    {
      if ( v5 )
      {
        if ( v5 == 2 )
        {
          if ( Com_BitCheck(a2 + 333, *((_DWORD *)v7 + 9)) )
          {
            if ( (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
              return 0;
          }
          else if ( !BG_WeaponIsClipOnly(*((_DWORD *)v7 + 9))
                 || (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
          {
            return 0;
          }
          return 1;
        }
        if ( v5 == 3 )
          return a2[71] < a2[73];
      }
      else
      {
        Com_Error(1, byte_9A849, 0);
      }
      return 0;
    }
    if ( Com_BitCheck(a2 + 333, *((_DWORD *)v7 + 9)) )
    {
      if ( (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
        return 0;
    }
    else if ( a3 )
    {
      return 0;
    }
    return 1;
  }
  return 0;
}
// 1FCBF: variable 'v4' is possibly undefined
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 19434: using guessed type _DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD);

//----- (0001FE63) --------------------------------------------------------
int __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3)
{
  int result; // eax
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+2Ch] [ebp-2Ch]
  float v6; // [esp+30h] [ebp-28h]
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+48h] [ebp-10h]
  int v11; // [esp+48h] [ebp-10h]
  float v12; // [esp+4Ch] [ebp-Ch]
  float v13; // [esp+4Ch] [ebp-Ch]
  float v14; // [esp+4Ch] [ebp-Ch]
  float v15; // [esp+4Ch] [ebp-Ch]
  float v16; // [esp+4Ch] [ebp-Ch]
  float v17; // [esp+4Ch] [ebp-Ch]
  float v18; // [esp+4Ch] [ebp-Ch]
  float v19; // [esp+4Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 8:
      *a3 = *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 16);
      result = *(_DWORD *)(a1 + 20);
      *((_DWORD *)a3 + 2) = result;
      break;
    case 2:
      v12 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v12 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v12 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v12 + *(float *)(a1 + 20);
      break;
    case 3:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v14 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      if ( v14 < 0.0 )
        v14 = 0.0;
      *a3 = *(float *)(a1 + 24) * v14 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v14 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v14 + *(float *)(a1 + 20);
      break;
    case 4:
      v13 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(int *)(a1 + 8);
      v9 = sin(v13 * 3.141592653589793 + v13 * 3.141592653589793);
      *a3 = *(float *)(a1 + 24) * v9 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v9 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v9 + *(float *)(a1 + 20);
      break;
    case 5:
      v15 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v15 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v15 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v15 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v15 * 400.0 * v15;
      break;
    case 6:
      v16 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v16 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v16 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v16 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v16 * 120.00001 * v16;
      break;
    case 7:
      v17 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v17 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v17 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v17 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v17 * 80.0;
      break;
    case 9:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v18 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v4 = sqrt(
             *(float *)(a1 + 24) * *(float *)(a1 + 24)
           + *(float *)(a1 + 28) * *(float *)(a1 + 28)
           + *(float *)(a1 + 32) * *(float *)(a1 + 32));
      v10 = v4 / ((long double)*(int *)(a1 + 8) * 0.001);
      VectorNormalize2(a1 + 24, a3);
      *a3 = v10 * 0.5 * v18 * v18 * *a3 + *(float *)(a1 + 12);
      a3[1] = v10 * 0.5 * v18 * v18 * a3[1] + *(float *)(a1 + 16);
      result = (int)(a3 + 2);
      a3[2] = v10 * 0.5 * v18 * v18 * a3[2] + *(float *)(a1 + 20);
      break;
    case 0xA:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v19 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v5 = sqrt(
             *(float *)(a1 + 24) * *(float *)(a1 + 24)
           + *(float *)(a1 + 28) * *(float *)(a1 + 28)
           + *(float *)(a1 + 32) * *(float *)(a1 + 32));
      *(float *)&v11 = v5 / ((long double)*(int *)(a1 + 8) * 0.001);
      VectorNormalize2(a1 + 24, a3);
      v6 = *(float *)(a1 + 24) * v19 + *(float *)(a1 + 12);
      v7 = *(float *)(a1 + 28) * v19 + *(float *)(a1 + 16);
      v8 = *(float *)(a1 + 32) * v19 + *(float *)(a1 + 20);
      *a3 = -*(float *)&v11 * 0.5 * v19 * v19 * *a3 + v6;
      a3[1] = -*(float *)&v11 * 0.5 * v19 * v19 * a3[1] + v7;
      result = v11;
      a3[2] = -*(float *)&v11 * 0.5 * v19 * v19 * a3[2] + v8;
      break;
    default:
      result = Com_Error(1, byte_9A880, *(_DWORD *)(a1 + 4));
      break;
  }
  return result;
}
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (00020494) --------------------------------------------------------
int __cdecl BG_EvaluateTrajectoryDelta(float *a1, int a2, float *a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+1Ch] [ebp-Ch]
  float v10; // [esp+1Ch] [ebp-Ch]
  float v11; // [esp+1Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
      result = 0;
      a3[2] = 0.0;
      a3[1] = 0.0;
      *a3 = 0.0;
      break;
    case 2:
      *a3 = a1[6];
      a3[1] = a1[7];
      result = *((_DWORD *)a1 + 8);
      *((_DWORD *)a3 + 2) = result;
      break;
    case 3:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        *a3 = a1[6];
        a3[1] = a1[7];
        result = *((_DWORD *)a1 + 8);
        *((_DWORD *)a3 + 2) = result;
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    case 4:
      v6 = (long double)(a2 - *((_DWORD *)a1 + 1)) / (long double)*((int *)a1 + 2);
      v4 = cos(v6 * 3.141592653589793 + v6 * 3.141592653589793);
      v5 = v4 * 0.5;
      *a3 = a1[6] * v5;
      a3[1] = a1[7] * v5;
      result = (int)a1;
      a3[2] = a1[8] * v5;
      break;
    case 5:
      v7 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v7 * 800.0;
      break;
    case 6:
      v8 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v8 * 240.00002;
      break;
    case 7:
      v9 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v9 * 160.0;
      break;
    case 9:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        v10 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
        *a3 = v10 * v10 * a1[6];
        a3[1] = v10 * v10 * a1[7];
        result = (int)a1;
        a3[2] = v10 * v10 * a1[8];
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    case 0xA:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        v11 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
        *a3 = a1[6] * v11;
        a3[1] = a1[7] * v11;
        result = (int)a1;
        a3[2] = a1[8] * v11;
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    default:
      result = Com_Error(1, byte_9A900, *((_DWORD *)a1 + 1));
      break;
  }
  return result;
}

//----- (00020869) --------------------------------------------------------
int __cdecl BG_GetMarkDir(_DWORD *a1, float *a2, float *a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  v5 = 0.30000001;
  v4 = sqrt(*a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2]);
  if ( v4 >= 1.0 )
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = a2[2];
  }
  else
  {
    v6 = 0.0;
    v7 = 0.0;
    v8 = 1.0;
  }
  LODWORD(v9) = *a1 ^ 0x80000000;
  LODWORD(v10) = a1[1] ^ 0x80000000;
  LODWORD(v11) = a1[2] ^ 0x80000000;
  VectorNormalize(&v9);
  if ( a2[2] > 0.80000001 )
    v5 = 0.69999999;
  while ( v5 > v9 * v6 + v10 * v7 + v11 * v8 )
  {
    v9 = v6 * 0.5 + v9;
    v10 = v7 * 0.5 + v10;
    v11 = v8 * 0.5 + v11;
    VectorNormalize(&v9);
  }
  *a3 = v9;
  a3[1] = v10;
  result = LODWORD(v11);
  a3[2] = v11;
  return result;
}
// 17474: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);

//----- (000209EB) --------------------------------------------------------
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 136) & 3) + 140) = (unsigned __int8)a1;
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 136) & 3) + 156) = a2;
    result = a3;
    ++*(_DWORD *)(a3 + 136);
  }
  return result;
}

//----- (00020A35) --------------------------------------------------------
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3)
{
  long double v3; // fst7
  unsigned int v4; // edx
  unsigned int v5; // edx
  long double v6; // fst7
  long double v7; // fst7
  int result; // eax
  unsigned __int8 v9; // [esp+23h] [ebp-15h]
  int j; // [esp+24h] [ebp-14h]
  float v11; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a1 + 12) & 0xC0000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 28);
  if ( a3 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 48) = 1;
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 236);
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 240);
  if ( a3 )
  {
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  if ( *(int *)(a1 + 128) <= 128 )
    v3 = (long double)*(int *)(a1 + 128);
  else
    v3 = (long double)*(int *)(a1 + 128) - 256.0;
  *(float *)(a2 + 108) = v3;
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 148) = *(_DWORD *)(a1 + 212);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 132);
  if ( (*(_DWORD *)(a1 + 132) & 0x106000) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1468);
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a1 + 1556) | *(_DWORD *)(a2 + 136) & 0xFFFFFFF8;
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a2 + 136) & 0xFFFFFFC7 | (8 * *(_DWORD *)(a1 + 1560));
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a2 + 136) & 0xFFFFFF3F | (*(_DWORD *)(a1 + 1564) << 6);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFFFFFE;
  else
    v4 = *(_DWORD *)(a2 + 8) | 1;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x100;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFFFEFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 216) = *(_DWORD *)(a1 + 68);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    if ( *(_DWORD *)(a1 + 252) )
    {
      v11 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
          / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
      if ( v11 >= 0.0 )
      {
        if ( v11 > 1.0 )
          v11 = 1.0;
      }
      else
      {
        v11 = 0.0;
      }
      if ( !*(_DWORD *)(a1 + 260) )
        v11 = 1.0 - v11;
    }
    else
    {
      v11 = 1.0;
    }
    v6 = *(float *)(a1 + 1544) * v11;
    *(float *)(a2 + 232) = v6;
    AngleNormalize180(*(float *)(a1 + 1548));
    v7 = v6 * v11;
    *(float *)(a2 + 236) = v7;
    AngleNormalize180(*(float *)(a1 + 1552));
    *(float *)(a2 + 240) = v7 * v11;
  }
  else
  {
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
    *(_DWORD *)(a2 + 240) = 0;
  }
  if ( *(_DWORD *)(a1 + 1568) - *(_DWORD *)(a1 + 136) >= 0 )
  {
    *(_DWORD *)(a2 + 164) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 136) - *(_DWORD *)(a1 + 1568) > 4 )
      *(_DWORD *)(a1 + 1568) = *(_DWORD *)(a1 + 136) - 4;
    *(_DWORD *)(a2 + 164) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1568))++ & 3) + 156);
  }
  for ( i = *(_DWORD *)(a1 + 172); i != *(_DWORD *)(a1 + 136); ++i )
  {
    v9 = *(_BYTE *)(a1 + 4 * (i & 3) + 140);
    G_PlayerEvent(*(_DWORD *)a2, v9);
    for ( j = 0; *((int *)pEventSingleClientList + j) > 0 && *((_DWORD *)pEventSingleClientList + j) != v9; ++j )
      ;
    if ( *((int *)pEventSingleClientList + j) < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 168) & 3) + 172) = v9;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 168))++ & 3) + 188) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 156);
    }
  }
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 204) = *(unsigned __int8 *)(a1 + 216);
  result = *(unsigned __int16 *)(a1 + 88);
  *(_DWORD *)(a2 + 124) = result;
  return result;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 18974: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 19834: using guessed type _DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD);
// A9870: using guessed type void *pEventSingleClientList;

//----- (00021028) --------------------------------------------------------
int __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  long double v6; // fst7
  long double v7; // fst7
  int result; // eax
  float v9; // [esp+20h] [ebp-18h]
  unsigned __int8 v10; // [esp+27h] [ebp-11h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  *(_DWORD *)(a2 + 12) = 3;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = 50;
  *(_DWORD *)(a2 + 48) = 1;
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 236);
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 240);
  *(float *)(a2 + 108) = (float)*(int *)(a1 + 128);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 132);
  if ( *(_DWORD *)(a1 + 1568) - *(_DWORD *)(a1 + 136) >= 0 )
  {
    *(_DWORD *)(a2 + 164) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 136) - *(_DWORD *)(a1 + 1568) > 4 )
      *(_DWORD *)(a1 + 1568) = *(_DWORD *)(a1 + 136) - 4;
    *(_DWORD *)(a2 + 164) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 1568))++ & 3) + 156);
  }
  if ( *(_DWORD *)(a1 + 172) - *(_DWORD *)(a1 + 136) > 0 )
    *(_DWORD *)(a1 + 172) = *(_DWORD *)(a1 + 136);
  for ( i = *(_DWORD *)(a1 + 172); i != *(_DWORD *)(a1 + 136); ++i )
  {
    v10 = *(_BYTE *)(a1 + 4 * (i & 3) + 140);
    G_PlayerEvent(*(_DWORD *)a2, v10);
    for ( j = 0; *((int *)pEventSingleClientList + j) > 0 && *((_DWORD *)pEventSingleClientList + j) != v10; ++j )
      ;
    if ( *((int *)pEventSingleClientList + j) < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 168) & 3) + 172) = v10;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 168))++ & 3) + 188) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 156);
    }
  }
  *(_DWORD *)(a1 + 172) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a2 + 204) = *(unsigned __int8 *)(a1 + 216);
  *(_DWORD *)(a2 + 124) = *(unsigned __int16 *)(a1 + 88);
  if ( (*(_DWORD *)(a1 + 12) & 0xC0000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  if ( a4 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 116);
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 124);
  *(_DWORD *)(a2 + 148) = *(_DWORD *)(a1 + 212);
  if ( (*(_DWORD *)(a1 + 132) & 0x106000) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 1468);
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a1 + 1556) | *(_DWORD *)(a2 + 136) & 0xFFFFFFF8;
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a2 + 136) & 0xFFFFFFC7 | (8 * *(_DWORD *)(a1 + 1560));
  *(_DWORD *)(a2 + 136) = *(_DWORD *)(a2 + 136) & 0xFFFFFF3F | (*(_DWORD *)(a1 + 1564) << 6);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFFFFFE;
  else
    v4 = *(_DWORD *)(a2 + 8) | 1;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x100;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFFFEFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 216) = *(_DWORD *)(a1 + 68);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    v9 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 252))
       / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
    if ( v9 >= 0.0 )
    {
      if ( v9 > 1.0 )
        v9 = 1.0;
    }
    else
    {
      v9 = 0.0;
    }
    if ( !*(_DWORD *)(a1 + 260) )
      v9 = 1.0 - v9;
    v6 = *(float *)(a1 + 1544) * v9;
    *(float *)(a2 + 232) = v6;
    AngleNormalize180(*(float *)(a1 + 1548));
    v7 = v6 * v9;
    *(float *)(a2 + 236) = v7;
    result = AngleNormalize180(*(float *)(a1 + 1552));
    *(float *)(a2 + 240) = v7 * v9;
  }
  else
  {
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
    result = a2;
    *(_DWORD *)(a2 + 240) = 0;
  }
  return result;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 18974: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 19834: using guessed type _DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD);
// A9870: using guessed type void *pEventSingleClientList;

//----- (0002162C) --------------------------------------------------------
int __cdecl BG_CheckProneValid(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, float a15, int a16, int a17)
{
  long double v17; // fst7
  long double v18; // fst7
  float v20; // [esp+0h] [ebp-148h]
  float v21; // [esp+0h] [ebp-148h]
  float v23; // [esp+30h] [ebp-118h]
  int v24; // [esp+34h] [ebp-114h]
  float v25; // [esp+38h] [ebp-110h]
  float v26; // [esp+40h] [ebp-108h]
  float v27; // [esp+44h] [ebp-104h]
  float v28; // [esp+48h] [ebp-100h]
  float v29; // [esp+4Ch] [ebp-FCh]
  int v30; // [esp+50h] [ebp-F8h] BYREF
  int v31; // [esp+54h] [ebp-F4h]
  float v32; // [esp+58h] [ebp-F0h]
  int v33; // [esp+60h] [ebp-E8h] BYREF
  int v34; // [esp+64h] [ebp-E4h]
  float v35; // [esp+68h] [ebp-E0h]
  int v36; // [esp+70h] [ebp-D8h] BYREF
  int v37; // [esp+74h] [ebp-D4h]
  float v38; // [esp+78h] [ebp-D0h]
  int v39[4]; // [esp+80h] [ebp-C8h] BYREF
  int v40[4]; // [esp+90h] [ebp-B8h] BYREF
  float v41; // [esp+A0h] [ebp-A8h] BYREF
  float v42; // [esp+A4h] [ebp-A4h]
  float v43; // [esp+A8h] [ebp-A0h]
  float v44; // [esp+B0h] [ebp-98h] BYREF
  float v45; // [esp+B4h] [ebp-94h]
  float v46; // [esp+B8h] [ebp-90h]
  float v47; // [esp+C0h] [ebp-88h] BYREF
  float v48; // [esp+C4h] [ebp-84h]
  float v49; // [esp+C8h] [ebp-80h]
  float v50; // [esp+D0h] [ebp-78h] BYREF
  float v51; // [esp+D4h] [ebp-74h]
  float v52; // [esp+D8h] [ebp-70h]
  float v53; // [esp+E0h] [ebp-68h] BYREF
  int v54; // [esp+E4h] [ebp-64h]
  float v55; // [esp+E8h] [ebp-60h]
  int v56; // [esp+F0h] [ebp-58h] BYREF
  int v57; // [esp+F4h] [ebp-54h]
  float v58; // [esp+F8h] [ebp-50h]
  float v59; // [esp+100h] [ebp-48h] BYREF
  int v60; // [esp+104h] [ebp-44h] BYREF
  int v61; // [esp+108h] [ebp-40h]
  float v62; // [esp+10Ch] [ebp-3Ch]
  float v63; // [esp+118h] [ebp-30h]
  int v64; // [esp+120h] [ebp-28h]
  unsigned __int16 v65; // [esp+128h] [ebp-20h]
  char v66; // [esp+12Eh] [ebp-1Ah]
  char v67; // [esp+12Fh] [ebp-19h]
  int v68; // [esp+13Ch] [ebp-Ch]

  v24 = 0;
  LODWORD(v50) = a3 ^ 0x80000000;
  LODWORD(v51) = a3 ^ 0x80000000;
  v52 = 0.0;
  v50 = COERCE_FLOAT(a3 ^ 0x80000000) + *(float *)a2;
  v51 = COERCE_FLOAT(a3 ^ 0x80000000) + *(float *)(a2 + 4);
  v52 = *(float *)(a2 + 8) + 0.0;
  v47 = *(float *)&a3;
  v48 = *(float *)&a3;
  v49 = *(float *)&a4;
  v47 = *(float *)&a3 + *(float *)a2;
  v48 = *(float *)&a3 + *(float *)(a2 + 4);
  v49 = *(float *)&a4 + *(float *)(a2 + 8);
  if ( g_debugProneCheck[3] )
    G_DebugBox(&v50, &v47, &colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( a14 )
    v68 = 8519697;
  else
    v68 = 8454193;
  if ( !a9 )
  {
    LODWORD(v50) = a3 ^ 0x80000000;
    LODWORD(v51) = a3 ^ 0x80000000;
    v52 = 0.0;
    v47 = *(float *)&a3;
    v48 = *(float *)&a3;
    v49 = *(float *)&a4;
    v56 = *(int *)a2;
    v57 = *(int *)(a2 + 4);
    v58 = *(float *)(a2 + 8);
    v53 = *(float *)a2;
    v54 = *(int *)(a2 + 4);
    v55 = *(float *)(a2 + 8);
    v55 = v55 + 10.0;
    ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a13)(&v59, &v56, &v50, &v47, &v53, a1, v68);
    if ( (v64 & 0x20) != 0 && v67 )
      return 0;
    if ( v66 )
      return 0;
    if ( a17 )
    {
      v53 = *(float *)a2;
      v54 = *(int *)(a2 + 4);
      v55 = *(float *)(a2 + 8);
      v55 = v55 - 10.0;
      ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a13)(
        &v59,
        &v56,
        &v50,
        &v47,
        &v53,
        a1,
        v68);
      if ( ((int (__cdecl *)(_DWORD))a17)(v65) == 12 )
        return 0;
    }
  }
  if ( a10 && a11 && *(float *)(a11 + 8) < 0.69999999 )
    return 0;
  v50 = -6.0;
  v51 = -6.0;
  v52 = -6.0;
  v47 = 6.0;
  v48 = 6.0;
  v49 = 6.0;
  v53 = 0.0;
  *(float *)&v54 = a5 - 180.0;
  v55 = 0.0;
  AngleVectors(&v53, &v41, v40, v39);
  v26 = *(float *)&a4 - 6.0;
  if ( a16 )
  {
    v56 = *(int *)a2;
    v57 = *(int *)(a2 + 4);
    v58 = *(float *)(a2 + 8);
    v58 = v58 + 8.0;
    v53 = v41 * -38.0 + *(float *)&v56;
    *(float *)&v54 = v42 * -38.0 + *(float *)&v57;
    v55 = v43 * -38.0 + v58;
    ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
    if ( v59 < 1.0 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      return 0;
    }
  }
  v56 = *(int *)a2;
  v57 = *(int *)(a2 + 4);
  v58 = *(float *)(a2 + 8);
  v58 = v58 + v26;
  v53 = (a15 - 6.0) * v41 + *(float *)&v56;
  *(float *)&v54 = (a15 - 6.0) * v42 + *(float *)&v57;
  v55 = (a15 - 6.0) * v43 + v58;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v56, 6.0, (int)v40, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v56, 6.0, (int)v39, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( v59 >= 1.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
    v25 = a15;
  }
  else
  {
    if ( !a10 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      return 0;
    }
    v24 = 1;
    v25 = (a15 - 6.0) * v59 + 6.0;
    if ( *(float *)&a3 + 2.0 > v25 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      return 0;
    }
    if ( v26 * 0.69999999 + 24.0 <= v25 )
    {
      if ( g_debugProneCheck[3] )
      {
LABEL_46:
        G_DebugLine(&v56, &v60, &colorYellow, g_debugProneCheckDepthCheck[3], 1);
        goto LABEL_55;
      }
    }
    else
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      v24 = 0;
      v55 = v55 + 22.0;
      v44 = v53 - *(float *)&v56;
      v45 = *(float *)&v54 - *(float *)&v57;
      v46 = v55 - v58;
      v27 = VectorNormalize2(&v44, &v41);
      ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(
        &v59,
        &v56,
        &v50,
        &v47,
        &v53,
        a1,
        v68);
      if ( v59 >= 1.0 )
      {
        if ( g_debugProneCheck[3] )
          G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
        v25 = a15;
      }
      else
      {
        v24 = 1;
        v25 = v59 * v27 + 6.0;
        if ( v26 * 0.69999999 + 24.0 > v25 )
        {
          if ( g_debugProneCheck[3] )
            G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
          return 0;
        }
        if ( g_debugProneCheck[3] )
          goto LABEL_46;
      }
    }
  }
LABEL_55:
  v30 = v60;
  v31 = v61;
  v32 = v62;
  *(float *)&v56 = v41 * 24.0 + *(float *)a2;
  *(float *)&v57 = v42 * 24.0 + *(float *)(a2 + 4);
  v58 = v43 * 24.0 + *(float *)(a2 + 8);
  v58 = v58 + v26;
  v53 = *(float *)&v56;
  v54 = v57;
  v55 = v58 - (*(float *)&a3 * 2.5 + v26 - 6.0);
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( v59 == 1.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_137;
  }
  if ( v63 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v33 = v60;
  v34 = v61;
  v35 = v62;
  if ( v24 )
  {
    v23 = (*(float *)&a3 * 2.5 + v26 - 6.0) * v59 + 6.0;
    if ( v23 * -0.75 > v25 - v23 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v30, &v33, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      goto LABEL_137;
    }
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v30, &v33, &colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
    v44 = *(float *)&v30 - *(float *)&v33;
    v45 = *(float *)&v31 - *(float *)&v34;
    v46 = v32 - v35;
    v44 = v41 * 6.0 + v44;
    v45 = v42 * 6.0 + v45;
    v46 = v43 * 6.0 + v46;
    v46 = v46 + 6.0;
    VectorNormalize(&v44);
    v53 = (a15 - 6.0 - 24.0) * v44 + *(float *)&v56;
    *(float *)&v54 = (a15 - 6.0 - 24.0) * v45 + *(float *)&v57;
    v55 = (a15 - 6.0 - 24.0) * v46 + v58;
    v53 = ((a15 - 6.0) * v41 + *(float *)a2 + v53) * 0.5;
    *(float *)&v54 = ((a15 - 6.0) * v42 + *(float *)(a2 + 4) + *(float *)&v54) * 0.5;
    ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
    if ( v59 < 1.0 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      v56 = v60;
      v57 = v61;
      v58 = v62 + 18.0;
      v55 = v55 + 18.0;
      ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(
        &v59,
        &v56,
        &v50,
        &v47,
        &v53,
        a1,
        v68);
      if ( v59 < 1.0 )
      {
        if ( !g_debugProneCheck[3] )
          goto LABEL_137;
LABEL_88:
        G_DebugLine(&v56, &v60, &colorRed, g_debugProneCheckDepthCheck[3], 1);
        goto LABEL_137;
      }
    }
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
    v30 = v60;
    v31 = v61;
    v32 = v62;
  }
  v56 = v30;
  v57 = v31;
  v58 = v32;
  v53 = *(float *)&v30;
  v54 = v31;
  v55 = v32 - (v32 - v35 + v32 - v35 + *(float *)&a3);
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( v59 == 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_137;
    goto LABEL_88;
  }
  if ( v59 < 1.0 && (v64 & 0x20) != 0 )
    goto LABEL_137;
  if ( v63 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v30 = v60;
  v31 = v61;
  v32 = v62;
  v56 = *(int *)a2;
  v57 = *(int *)(a2 + 4);
  v58 = *(float *)(a2 + 8);
  v58 = v58 + v26;
  v53 = *(float *)a2;
  v54 = *(int *)(a2 + 4);
  v55 = *(float *)(a2 + 8);
  v55 = v55 - *(float *)&a3 * 1.5;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( v59 == 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_137;
    goto LABEL_88;
  }
  if ( v59 < 1.0 && (v64 & 0x20) != 0 )
    goto LABEL_137;
  if ( v63 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v56, &v60, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v36 = v60;
  v37 = v61;
  v38 = v62;
  if ( fabs(v62 - *(float *)(a2 + 8) - 6.0) > 24.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(a2, &v36, &colorRed, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_137;
  }
  v44 = *(float *)&v33 - *(float *)&v36;
  v45 = *(float *)&v34 - *(float *)&v37;
  v46 = v35 - v38;
  v29 = vectopitch(&v44);
  v44 = *(float *)&v30 - *(float *)&v33;
  v45 = *(float *)&v31 - *(float *)&v34;
  v46 = v32 - v35;
  v28 = vectopitch(&v44);
  AngleSubtract(v28, v29);
  if ( v28 < -45.0 || v28 > 70.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v36, &v33, &colorMagenta, g_debugProneCheckDepthCheck[3], 1);
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v33, &v30, &colorMagenta, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_137;
  }
  v50 = -0.0;
  v51 = -0.0;
  v52 = -0.0;
  v47 = 0.0;
  v48 = 0.0;
  v49 = 0.0;
  v56 = v36;
  v57 = v37;
  v58 = v38 + 5.0;
  v53 = *(float *)&v33;
  v54 = v34;
  v55 = v35 + 5.0;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( v59 < 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_137;
    goto LABEL_106;
  }
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v56, &v53, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  *(float *)&v56 = v53;
  v57 = v54;
  v58 = v55;
  v53 = *(float *)&v30;
  v54 = v31;
  v55 = v32 + 5.0;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v59, &v56, &v50, &v47, &v53, a1, v68);
  if ( v59 < 1.0 )
  {
    if ( g_debugProneCheck[3] )
LABEL_106:
      G_DebugLine(&v56, &v53, &colorRed, g_debugProneCheckDepthCheck[3], 1);
LABEL_137:
    if ( a10 )
      return 0;
    if ( a6 )
      *(_DWORD *)a6 = 0;
    if ( a7 )
      *(_DWORD *)a7 = 0;
    if ( a8 )
      *(_DWORD *)a8 = 0;
    return 1;
  }
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v56, &v53, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v36, 6.0, (int)v40, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v36, 6.0, (int)v39, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v33, 6.0, (int)v40, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v33, 6.0, (int)v39, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v30, 6.0, (int)v40, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v30, 6.0, (int)v39, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v36, &v33, &colorCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v33, &v30, &colorCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( a6 )
    *(float *)a6 = v38 - *(float *)(a2 + 8) - 6.0;
  if ( a7 )
  {
    v44 = *(float *)&v36 - *(float *)&v33;
    v45 = *(float *)&v37 - *(float *)&v34;
    v46 = v38 - v35;
    v17 = vectopitch(&v44);
    v20 = v17;
    AngleNormalize180(v20);
    *(float *)a7 = v17;
  }
  if ( a8 )
  {
    v44 = *(float *)&v33 - *(float *)&v30;
    v45 = *(float *)&v34 - *(float *)&v31;
    v46 = v35 - v32;
    v18 = vectopitch(&v44);
    v21 = v18;
    AngleNormalize180(v21);
    *(float *)a8 = v18;
  }
  return 1;
}
// 16B24: using guessed type long double __cdecl vectopitch(_DWORD);
// 17474: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 190A4: using guessed type _DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00022FF3) --------------------------------------------------------
int __cdecl BG_CheckProne(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, float a15, int a16)
{
  return BG_CheckProneValid(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, 0, a16);
}

//----- (00023087) --------------------------------------------------------
int __cdecl BG_GetVehiclePosTag(int a1)
{
  int v2[10]; // [esp+0h] [ebp-28h]

  v2[0] = (int)"*unused*";
  v2[1] = (int)"tag_player";
  v2[2] = (int)"tag_secondary_player";
  v2[3] = (int)"tag_passenger";
  v2[4] = (int)"tag_passenger2";
  v2[5] = (int)"tag_passenger3";
  v2[6] = (int)"tag_passenger4";
  return v2[a1];
}

//----- (000230E5) --------------------------------------------------------
void *__cdecl BG_GetVehiclePosOffset(int a1, int a2)
{
  if ( a1 == 5 )
    return &unk_A94E0;
  if ( a1 == 2 && a2 == 2 )
    return &unk_A94EC;
  if ( a1 == 2 && a2 == 1 )
    return &unk_A94F8;
  return &vec3_origin;
}

//----- (00023148) --------------------------------------------------------
_BOOL4 __cdecl BG_AllowPlayerWeaponAtVehiclePos(int a1, int a2)
{
  return a1 == 1 && a2 == 3;
}

//----- (0002316F) --------------------------------------------------------
void sub_2316F()
{
  ;
}

//----- (00023174) --------------------------------------------------------
int __cdecl PM_trace(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax

  (*(void (__cdecl **)(int, int, int, int, int, int, int))(pm + 260))(a1, a2, a3, a4, a5, a6, a7);
  result = a1;
  if ( *(_BYTE *)(a1 + 47) )
  {
    result = *(_DWORD *)(a1 + 32) & 0x2000000;
    if ( result )
    {
      PM_AddTouchEnt(*(unsigned __int16 *)(a1 + 40));
      *(_DWORD *)(pm + 52) &= 0xFDFFFFFF;
      result = (*(int (__cdecl **)(int, int, int, int, int, int, unsigned int))(pm + 260))(
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7 & 0xFDFFFFFF);
    }
  }
  return result;
}
// 18754: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);

//----- (0002325A) --------------------------------------------------------
int __cdecl PM_AddEvent(int a1)
{
  return BG_AddPredictableEventToPlayerstate(a1, 0, *pm);
}
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (00023293) --------------------------------------------------------
int __cdecl PM_AddTouchEnt(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-8h]

  if ( a1 != 1022 )
  {
    result = pm;
    if ( *(_DWORD *)(pm + 84) != 32 )
    {
      for ( i = 0; i < *(_DWORD *)(pm + 84); ++i )
      {
        result = *(_DWORD *)(pm + 4 * i + 88);
        if ( result == a1 )
          return result;
      }
      *(_DWORD *)(pm + 4 * *(_DWORD *)(pm + 84) + 88) = a1;
      result = pm;
      ++*(_DWORD *)(pm + 84);
    }
  }
  return result;
}

//----- (00023321) --------------------------------------------------------
void __cdecl PM_ClipVelocity(int a1, int a2, int a3, float a4)
{
  int i; // [esp+0h] [ebp-14h]
  float v5; // [esp+4h] [ebp-10h]
  float v6; // [esp+8h] [ebp-Ch]
  float v7; // [esp+8h] [ebp-Ch]

  v6 = *(float *)a1 * *(float *)a2 + *(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)(a1 + 8) * *(float *)(a2 + 8);
  if ( v6 >= 0.0 )
    v7 = v6 / a4;
  else
    v7 = v6 * a4;
  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a2 + 4 * i) * v7;
    *(float *)(a3 + 4 * i) = *(float *)(a1 + 4 * i) - v5;
  }
}

//----- (000233E1) --------------------------------------------------------
int __cdecl PM_GetEffectiveStance(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1[61] == a1[350] )
    v2 = 2;
  else
    v2 = a1[61] == a1[349];
  return v2;
}

//----- (0002342D) --------------------------------------------------------
long double sub_2342D()
{
  float v1; // [esp+0h] [ebp-8h]

  if ( *(int *)(*pm + 16) <= 1699 )
    v1 = (long double)*(int *)(*pm + 16) * 1.5 * 0.00058823527 + 1.0;
  else
    v1 = 2.5;
  return v1;
}

//----- (0002348E) --------------------------------------------------------
long double sub_2348E()
{
  float v1; // [esp+0h] [ebp-8h]

  if ( *(int *)(*pm + 16) <= 1699 )
    v1 = (long double)*(int *)(*pm + 16) * 1.5 * 0.00058823527 + 1.0;
  else
    v1 = 2.5;
  return v1;
}

//----- (000234EF) --------------------------------------------------------
float *sub_234EF()
{
  float *result; // eax
  float v1; // [esp+14h] [ebp-34h]
  float v2; // [esp+1Ch] [ebp-2Ch]
  float v3; // [esp+20h] [ebp-28h]
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+24h] [ebp-24h]
  float v6; // [esp+28h] [ebp-20h]
  float *v7; // [esp+2Ch] [ebp-1Ch]
  float v8; // [esp+38h] [ebp-10h]

  v7 = (float *)(*pm + 32);
  v8 = *(float *)(*pm + 40);
  if ( LODWORD(pml[11]) )
    v8 = 0.0;
  v6 = sqrt(*v7 * *v7 + *(float *)(*pm + 36) * *(float *)(*pm + 36) + v8 * v8);
  if ( v6 >= 1.0 )
  {
    v2 = 0.0;
    if ( *(_BYTE *)(pm + 241) <= 1u
      && LODWORD(pml[11])
      && (LODWORD(pml[21]) & 2) == 0
      && (*(_DWORD *)(*pm + 12) & 0x200) == 0 )
    {
      if ( v6 >= 100.0 )
        v1 = v6;
      else
        v1 = 100.0;
      v3 = v1;
      if ( (*(_DWORD *)(*pm + 12) & 0x100) != 0 )
      {
        v3 = v1 * 0.30000001;
      }
      else if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 )
      {
        if ( *(int *)(*pm + 16) > 1800 )
        {
          *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
          *(_DWORD *)(*pm + 108) = 0;
        }
        else
        {
          v3 = sub_2342D() * v1;
        }
      }
      v2 = v3 * 5.5 * pml[9] + 0.0;
    }
    if ( *(_BYTE *)(pm + 241) )
      v2 = v6 * 1.0 * (long double)*(unsigned __int8 *)(pm + 241) * pml[9] + v2;
    if ( *(_DWORD *)(*pm + 4) == 4 )
      v2 = v6 * 5.0 * pml[9] + v2;
    v4 = v6 - v2;
    if ( v4 < 0.0 )
      v4 = 0.0;
    v5 = v4 / v6;
    *v7 = *v7 * v5;
    v7[1] = v7[1] * v5;
    result = v7 + 2;
    v7[2] = v7[2] * v5;
  }
  else
  {
    result = 0;
    v7[2] = 0.0;
    v7[1] = 0.0;
    *v7 = 0.0;
  }
  return result;
}

//----- (0002379E) --------------------------------------------------------
void __cdecl sub_2379E(int a1, float a2, float a3)
{
  float v3; // [esp+0h] [ebp-24h]
  float v4; // [esp+8h] [ebp-1Ch]
  float v5; // [esp+Ch] [ebp-18h]
  float v6; // [esp+10h] [ebp-14h]
  int i; // [esp+14h] [ebp-10h]

  v4 = *(float *)(*pm + 32) * *(float *)a1
     + *(float *)(*pm + 36) * *(float *)(a1 + 4)
     + *(float *)(*pm + 40) * *(float *)(a1 + 8);
  v6 = a2 - v4;
  if ( v6 > 0.0 )
  {
    if ( a2 >= 100.0 )
      v3 = a2;
    else
      v3 = 100.0;
    v5 = a3 * pml[9] * v3;
    if ( v5 > (long double)v6 )
      v5 = a2 - v4;
    if ( *(_DWORD *)(*pm + 88) != 1023 )
      v5 = 1.0 / *(float *)(*pm + 1472) * v5;
    if ( v5 > (long double)v6 )
      v5 = a2 - v4;
    for ( i = 0; i <= 2; ++i )
      *(float *)(*pm + 4 * i + 32) = v5 * *(float *)(a1 + 4 * i) + *(float *)(*pm + 4 * i + 32);
  }
}

//----- (00023905) --------------------------------------------------------
long double __cdecl sub_23905(char *a1)
{
  long double v1; // fst7
  int v3; // [esp+Ch] [ebp-2Ch]
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  float v9; // [esp+28h] [ebp-10h]
  float v10; // [esp+28h] [ebp-10h]
  float v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v7 = a1[20];
  if ( v7 < 0 )
    v7 = -v7;
  v12 = v7;
  v6 = a1[21];
  if ( v6 < 0 )
    v6 = -v6;
  if ( v6 > v7 )
  {
    v5 = a1[21];
    if ( v5 < 0 )
      v5 = -v5;
    v12 = v5;
  }
  v4 = a1[22];
  if ( v4 < 0 )
    v4 = -v4;
  if ( v4 > v12 )
  {
    v3 = a1[22];
    if ( v3 < 0 )
      v3 = -v3;
    v12 = v3;
  }
  if ( !v12 )
    return 0.0;
  v11 = sqrt((double)(a1[22] * a1[22] + a1[21] * a1[21] + a1[20] * a1[20]));
  v9 = (long double)*(int *)(*pm + 72) * (long double)v12 / (v11 * 127.0);
  if ( (*(_BYTE *)(*pm + 12) & 0x80) == 0 && *(float *)(*pm + 68) == 0.0 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
      v1 = v9 * *(float *)(*pm + 1420);
    else
      v1 = v9 * *(float *)(*pm + 1416);
    v10 = v1;
  }
  else
  {
    v10 = v9 * *(float *)(*pm + 1412);
  }
  if ( *(_DWORD *)(*pm + 4) == 2 )
    v10 = v10 * 3.0;
  if ( *(_DWORD *)(*pm + 4) == 3 )
    v10 = v10 * 6.0;
  return v10;
}

//----- (00023AF5) --------------------------------------------------------
long double __cdecl sub_23AF5(_BYTE *a1)
{
  long double v1; // fst7
  long double v2; // fst7
  float v4; // [esp+14h] [ebp-34h]
  float v6; // [esp+1Ch] [ebp-2Ch]
  float v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+20h] [ebp-28h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+38h] [ebp-10h]
  float v15; // [esp+38h] [ebp-10h]
  float v16; // [esp+3Ch] [ebp-Ch]

  if ( (char)a1[20] >= 0 )
    v1 = fabs((long double)(char)a1[20]);
  else
    v1 = fabs((long double)(char)a1[20] * *(float *)(*pm + 1436));
  v13 = v1;
  v12 = fabs((long double)(char)a1[21] * *(float *)(*pm + 1432));
  if ( v13 <= (long double)v12 )
    v4 = v12;
  else
    v4 = v1;
  if ( v4 == 0.0 )
    return 0.0;
  v16 = sqrt((double)((char)a1[21] * (char)a1[21] + (char)a1[20] * (char)a1[20]));
  v14 = (long double)*(int *)(*pm + 72) * v4 / (v16 * 127.0);
  if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0
    || *(float *)(*pm + 68) != 0.0
    || *(_DWORD *)(*pm + 220) == 13 && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216)) + 128) == 3 )
  {
    v15 = v14 * *(float *)(*pm + 1412);
  }
  else
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
      v2 = v14 * *(float *)(*pm + 1420);
    else
      v2 = v14 * *(float *)(*pm + 1416);
    v15 = v2;
  }
  if ( *(_DWORD *)(*pm + 4) == 2 )
  {
    v15 = v15 * 3.0;
  }
  else if ( *(_DWORD *)(*pm + 4) == 3 )
  {
    v15 = v15 * 6.0;
  }
  else
  {
    v8 = PM_GetEffectiveStance(*pm);
    v9 = sub_2706E(*(_DWORD *)(*pm + 1400), *(_DWORD *)(*pm + 1396));
    if ( v9 == 0.0 )
    {
      v10 = sub_2706E(*(_DWORD *)(*pm + 1396), *(_DWORD *)(*pm + 1400));
      if ( v10 == 0.0 )
      {
        if ( v8 == 1 )
        {
          v15 = v15 * *(float *)(*pm + 1424);
        }
        else if ( v8 == 2 )
        {
          v15 = v15 * *(float *)(*pm + 1428);
        }
      }
      else
      {
        v15 = (*(float *)(*pm + 1428) * v10 + (1.0 - v10) * *(float *)(*pm + 1424)) * v15;
      }
    }
    else
    {
      v15 = (*(float *)(*pm + 1424) * v9 + (1.0 - v9) * *(float *)(*pm + 1428)) * v15;
    }
    if ( *(_BYTE *)(pm + 241) )
    {
      v6 = (long double)*(unsigned __int8 *)(pm + 241) / 3.0;
      v7 = 1.0 - (1.0 - 0.5) * v6;
      v15 = v15 * v7;
    }
  }
  v11 = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216));
  if ( *(_DWORD *)(*pm + 216) && *(float *)(v11 + 620) > 0.0 && (*(_DWORD *)(*pm + 12) & 0x10000) == 0 )
    v15 = v15 * *(float *)(v11 + 620);
  if ( (a1[5] & 4) != 0 )
    v15 = v15 * 0.40000001;
  return v15;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00023F62) --------------------------------------------------------
int __usercall sub_23F62@<eax>(long double a1@<st0>)
{
  int result; // eax
  long double v2; // fst7
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+0h] [ebp-68h]
  int v6; // [esp+10h] [ebp-58h]
  int v7; // [esp+14h] [ebp-54h]
  int v8; // [esp+18h] [ebp-50h]
  char v9[4]; // [esp+20h] [ebp-48h] BYREF
  float v10; // [esp+24h] [ebp-44h]
  int v11; // [esp+3Ch] [ebp-2Ch]
  float v12; // [esp+40h] [ebp-28h] BYREF
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+5Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*pm + 12) & 1) == 0 || (*(_DWORD *)(*pm + 132) & 0x106000) != 0 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      v2 = vectoyaw(*pm + 92) + 180.0;
      v15 = v2;
      AngleDelta(v15, *(float *)(*pm + 236));
      v11 = (int)v2;
      v7 = (int)v2;
      if ( (int)v2 < 0 )
        v7 = -v7;
      if ( v7 > 90 )
      {
        if ( v11 <= 0 )
          v11 = -90;
        else
          v11 = 90;
      }
      result = (char)v11;
      *(_DWORD *)(*pm + 128) = (char)v11;
    }
    else
    {
      v12 = *(float *)(*pm + 20) - pml[27];
      v13 = *(float *)(*pm + 24) - pml[28];
      v14 = *(float *)(*pm + 28) - pml[29];
      if ( !*(_BYTE *)(pm + 24) && !*(_BYTE *)(pm + 25)
        || *(_DWORD *)(*pm + 88) == 1023
        || (v15 = sqrt(v12 * v12 + v13 * v13 + v14 * v14), v15 == 0.0)
        || v15 <= pml[9] * 5.0 )
      {
        result = *pm;
        *(_DWORD *)(*pm + 128) = 0;
      }
      else
      {
        v3 = VectorNormalize2(&v12, v9);
        vectoangles(v9, v9);
        AngleDelta(v10, *(float *)(*pm + 236));
        v11 = (int)v3;
        if ( *(char *)(pm + 24) < 0 )
        {
          v4 = (long double)v11 + 180.0;
          v5 = v4;
          AngleNormalize180(v5);
          v11 = (int)v4;
        }
        v6 = v11;
        if ( v11 < 0 )
          v6 = -v11;
        if ( v6 > 90 )
        {
          if ( v11 <= 0 )
            v11 = -90;
          else
            v11 = 90;
        }
        result = (char)v11;
        *(_DWORD *)(*pm + 128) = (char)v11;
      }
    }
  }
  else
  {
    AngleDelta(*(float *)(*pm + 1444), *(float *)(*pm + 236));
    v11 = (int)a1;
    v8 = (int)a1;
    if ( (int)a1 < 0 )
      v8 = -v8;
    if ( v8 > 90 )
    {
      if ( v11 <= 0 )
        v11 = -90;
      else
        v11 = 90;
    }
    result = (char)v11;
    *(_DWORD *)(*pm + 128) = (char)v11;
  }
  return result;
}
// 168D4: using guessed type long double __cdecl vectoyaw(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (000242B2) --------------------------------------------------------
int sub_242B2()
{
  int v2; // [esp+4h] [ebp-8h]

  if ( (LODWORD(pml[21]) & 0x2000) != 0 )
    return 0;
  v2 = (LODWORD(pml[21]) & 0x1F00000) >> 20;
  if ( pm && *(_BYTE *)(pm + 241) )
    v2 = 20;
  return v2;
}

//----- (00024328) --------------------------------------------------------
int sub_24328()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    return 83;
  v2 = sub_242B2();
  if ( v2 )
    v1 = v2 + 70;
  else
    v1 = 0;
  return v1;
}

//----- (00024380) --------------------------------------------------------
int __cdecl sub_24380(float a1)
{
  int v1; // esi
  int result; // eax
  float v3; // [esp+Ch] [ebp-Ch]

  pml[12] = 0.0;
  pml[13] = 0.0;
  pml[11] = 0.0;
  *(_DWORD *)(*pm + 88) = 1023;
  v3 = (a1 + a1) * (long double)*(int *)(*pm + 64);
  if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 && *(int *)(*pm + 16) <= 1800 )
    v3 = v3 / sub_2348E();
  v1 = *pm;
  *(float *)(v1 + 40) = sqrt(v3);
  *(_DWORD *)(*pm + 12) |= 0x2008u;
  *(_DWORD *)(*pm + 16) = 0;
  result = *(_DWORD *)(*pm + 28);
  *(_DWORD *)(*pm + 108) = result;
  return result;
}

//----- (00024483) --------------------------------------------------------
int sub_24483()
{
  int v0; // eax
  int v2; // [esp+1Ch] [ebp-3Ch]
  float v3; // [esp+20h] [ebp-38h] BYREF
  float v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 104) <= 499 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x800) != 0 )
    return 0;
  if ( PM_GetEffectiveStance(*pm) )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216)) + 128) == 3 )
    return 0;
  if ( *(char *)(pm + 26) <= 9 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 8) != 0 )
  {
    *(_BYTE *)(pm + 26) = 0;
    v2 = 0;
  }
  else
  {
    sub_24380(39.0);
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.75;
      v3 = pml[0];
      v4 = pml[1];
      v5 = 0.0;
      VectorNormalize(&v3);
      if ( *(float *)(*pm + 92) * pml[0] + *(float *)(*pm + 96) * pml[1] + *(float *)(*pm + 100) * pml[2] >= 0.0 )
      {
        v6 = v3;
        v7 = v4;
        v8 = v5;
      }
      else
      {
        v9 = v3 * *(float *)(*pm + 92) + v4 * *(float *)(*pm + 96) + v5 * *(float *)(*pm + 100);
        v6 = v9 * -2.0 * *(float *)(*pm + 92) + v3;
        v7 = v9 * -2.0 * *(float *)(*pm + 96) + v4;
        v8 = v9 * -2.0 * *(float *)(*pm + 100) + v5;
        VectorNormalize(&v6);
      }
      *(float *)(*pm + 32) = v6 * 128.0;
      *(float *)(*pm + 36) = v7 * 128.0;
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
    }
    v0 = sub_24328();
    PM_AddEvent(v0);
    *(float *)(*pm + 1576) = *(float *)(*pm + 1576) + 64.0;
    if ( *(float *)(*pm + 1576) > 255.0 )
      *(_DWORD *)(*pm + 1576) = 1132396544;
    if ( *(char *)(pm + 24) < 0 )
      BG_AnimScriptEvent(*pm, 4, 0, 1);
    else
      BG_AnimScriptEvent(*pm, 3, 0, 1);
    v2 = 1;
  }
  return v2;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17474: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 24328: using guessed type int sub_24328(void);

//----- (00024838) --------------------------------------------------------
int sub_24838()
{
  float v1; // [esp+1Ch] [ebp-4Ch]
  int v2[7]; // [esp+20h] [ebp-48h] BYREF
  float v3; // [esp+3Ch] [ebp-2Ch]
  int v4; // [esp+40h] [ebp-28h]
  int v5; // [esp+44h] [ebp-24h]
  float v6; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  sub_234EF();
  v1 = sub_23905((char *)(pm + 4));
  if ( v1 == 0.0 )
  {
    v4 = 0;
    v5 = 0;
    v6 = 0.0;
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
      *((float *)&v4 + i) = v1 * pml[i] * (long double)*(char *)(pm + 24)
                          + v1 * pml[i + 3] * (long double)*(char *)(pm + 25);
    v6 = (long double)*(char *)(pm + 26) * v1 + v6;
  }
  if ( *(_DWORD *)(*pm + 72) )
  {
    v6 = v6 - (long double)(16 * (*(_BYTE *)(pm + 9) & 0x20));
    v6 = (long double)(16 * (*(_BYTE *)(pm + 9) & 0x10)) + v6;
  }
  v2[0] = v4;
  v2[1] = v5;
  *(float *)&v2[2] = v6;
  v3 = VectorNormalize(v2);
  sub_2379E((int)v2, v3, 8.0);
  return PM_StepSlideMove(0);
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19444: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (000249CC) --------------------------------------------------------
int sub_249CC()
{
  long double v0; // fst7
  int v2[10]; // [esp+10h] [ebp-78h] BYREF
  float v3; // [esp+38h] [ebp-50h]
  float v4; // [esp+3Ch] [ebp-4Ch]
  int v5[6]; // [esp+40h] [ebp-48h] BYREF
  float v6; // [esp+58h] [ebp-30h]
  float v7; // [esp+5Ch] [ebp-2Ch]
  float v8[7]; // [esp+60h] [ebp-28h]
  int i; // [esp+7Ch] [ebp-Ch]

  sub_234EF();
  v7 = (float)*(char *)(pm + 24);
  v6 = (float)*(char *)(pm + 25);
  v2[0] = *(_DWORD *)(pm + 4);
  v2[1] = *(_DWORD *)(pm + 8);
  v2[2] = *(_DWORD *)(pm + 12);
  v2[3] = *(_DWORD *)(pm + 16);
  v2[4] = *(_DWORD *)(pm + 20);
  v2[5] = *(_DWORD *)(pm + 24);
  v3 = sub_23905((char *)v2);
  pml[2] = 0.0;
  pml[5] = 0.0;
  VectorNormalize(pml);
  VectorNormalize(&pml[3]);
  for ( i = 0; i <= 1; ++i )
    v8[i] = pml[i] * v7 + pml[i + 3] * v6;
  v8[2] = 0.0;
  *(float *)v5 = v8[0];
  *(float *)&v5[1] = v8[1];
  v5[2] = 0;
  v4 = VectorNormalize(v5);
  v0 = v4 * v3;
  v4 = v0;
  sub_2379E((int)v5, v4, 1.0);
  if ( LODWORD(pml[12]) )
    PM_ClipVelocity(*pm + 32, (int)&pml[18], *pm + 32, 1.001);
  PM_StepSlideMove(1);
  return sub_23F62(v0);
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19444: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (00024B7C) --------------------------------------------------------
int sub_24B7C()
{
  int result; // eax
  long double v1; // fst7
  int v2; // [esp+14h] [ebp-94h]
  float v3; // [esp+18h] [ebp-90h]
  float v4; // [esp+1Ch] [ebp-8Ch]
  int v5[10]; // [esp+20h] [ebp-88h] BYREF
  float v6; // [esp+48h] [ebp-60h]
  float v7; // [esp+4Ch] [ebp-5Ch]
  int v8[6]; // [esp+50h] [ebp-58h] BYREF
  float v9; // [esp+68h] [ebp-40h]
  float v10; // [esp+6Ch] [ebp-3Ch]
  float v11; // [esp+70h] [ebp-38h]
  float v12; // [esp+74h] [ebp-34h]
  float v13; // [esp+78h] [ebp-30h]
  float v14[7]; // [esp+80h] [ebp-28h]
  int i; // [esp+9Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 )
  {
    if ( *(int *)(*pm + 16) <= 1800 )
    {
      if ( !*(_DWORD *)(*pm + 16) )
      {
        if ( *(float *)(*pm + 108) + 18.0 <= *(float *)(*pm + 28) )
        {
          *(_DWORD *)(*pm + 16) = 1200;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.5;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.5;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.5;
        }
        else
        {
          *(_DWORD *)(*pm + 16) = 1800;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.64999998;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.64999998;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.64999998;
        }
      }
    }
    else
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*pm + 108) = 0;
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.64999998;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.64999998;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.64999998;
    }
  }
  if ( sub_24483() )
  {
    sub_249CC();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*pm + 104) = result;
  }
  else
  {
    sub_234EF();
    v10 = (float)*(char *)(pm + 24);
    v9 = (float)*(char *)(pm + 25);
    v5[0] = *(_DWORD *)(pm + 4);
    v5[1] = *(_DWORD *)(pm + 8);
    v5[2] = *(_DWORD *)(pm + 12);
    v5[3] = *(_DWORD *)(pm + 16);
    v5[4] = *(_DWORD *)(pm + 20);
    v5[5] = *(_DWORD *)(pm + 24);
    v6 = sub_23AF5(v5);
    pml[2] = 0.0;
    pml[5] = 0.0;
    PM_ClipVelocity((int)pml, (int)&pml[18], (int)pml, 1.001);
    PM_ClipVelocity((int)&pml[3], (int)&pml[18], (int)&pml[3], 1.001);
    VectorNormalize(pml);
    VectorNormalize(&pml[3]);
    for ( i = 0; i <= 2; ++i )
      v14[i] = pml[i] * v10 + pml[i + 3] * v9;
    *(float *)v8 = v14[0];
    *(float *)&v8[1] = v14[1];
    *(float *)&v8[2] = v14[2];
    v7 = VectorNormalize(v8);
    v7 = v7 * v6;
    v2 = PM_GetEffectiveStance(*pm);
    if ( (LODWORD(pml[21]) & 2) != 0 || (*(_DWORD *)(*pm + 12) & 0x200) != 0 )
    {
      v4 = pm_airaccelerate;
    }
    else if ( v2 == 1 )
    {
      v4 = pm_prone_accelerate;
    }
    else if ( v2 == 2 )
    {
      v4 = pm_ducked_accelerate;
    }
    else
    {
      v4 = pm_accelerate;
    }
    if ( (*(_DWORD *)(*pm + 12) & 0x100) != 0 )
      v4 = v4 * 0.25;
    sub_2379E((int)v8, v7, v4);
    if ( (LODWORD(pml[21]) & 2) != 0 || (*(_DWORD *)(*pm + 12) & 0x200) != 0 )
      *(float *)(*pm + 40) = *(float *)(*pm + 40) - (long double)*(int *)(*pm + 64) * pml[9];
    v3 = sqrt(
           *(float *)(*pm + 32) * *(float *)(*pm + 32)
         + *(float *)(*pm + 36) * *(float *)(*pm + 36)
         + *(float *)(*pm + 40) * *(float *)(*pm + 40));
    v11 = *(float *)(*pm + 32);
    v12 = *(float *)(*pm + 36);
    v13 = *(float *)(*pm + 40);
    PM_ClipVelocity(*pm + 32, (int)&pml[18], *pm + 32, 1.001);
    if ( *(float *)(*pm + 32) * v11 + *(float *)(*pm + 36) * v12 + *(float *)(*pm + 40) * v13 > 0.0 )
    {
      VectorNormalize(*pm + 32);
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * v3;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * v3;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * v3;
    }
    v1 = 0.0;
    if ( *(float *)(*pm + 32) != 0.0 || (v1 = 0.0, *(float *)(*pm + 36) != 0.0) )
      PM_StepSlideMove(0);
    result = sub_23F62(v1);
  }
  return result;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19444: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (00025246) --------------------------------------------------------
float *sub_25246()
{
  float *result; // eax
  int v1; // esi
  int v2; // ecx
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]

  result = pml;
  if ( LODWORD(pml[11]) )
  {
    v3 = sqrt(
           *(float *)(*pm + 32) * *(float *)(*pm + 32)
         + *(float *)(*pm + 36) * *(float *)(*pm + 36)
         + *(float *)(*pm + 40) * *(float *)(*pm + 40));
    v4 = v3 - 20.0;
    if ( v4 > 0.0 )
    {
      VectorNormalize(*pm + 32);
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * v4;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * v4;
      result = (float *)*pm;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * v4;
    }
    else
    {
      v1 = *pm;
      v2 = *pm;
      result = 0;
      *(_DWORD *)(*pm + 40) = 0;
      *(_DWORD *)(v2 + 36) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0002538B) --------------------------------------------------------
int sub_2538B()
{
  int result; // eax
  float v1; // [esp+10h] [ebp-68h]
  float v2; // [esp+18h] [ebp-60h]
  float v3; // [esp+1Ch] [ebp-5Ch]
  float v4; // [esp+1Ch] [ebp-5Ch]
  int v5[6]; // [esp+20h] [ebp-58h] BYREF
  float v6; // [esp+38h] [ebp-40h]
  float v7; // [esp+3Ch] [ebp-3Ch]
  float v8[2]; // [esp+40h] [ebp-38h]
  int v9; // [esp+48h] [ebp-30h]
  int i; // [esp+58h] [ebp-20h]
  float v11; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]
  float v15; // [esp+6Ch] [ebp-Ch]

  *(_DWORD *)(*pm + 244) = bg_viewheight_standing[3];
  *(_DWORD *)(*pm + 1404) = bg_viewheight_standing[3];
  v15 = sqrt(
          *(float *)(*pm + 32) * *(float *)(*pm + 32)
        + *(float *)(*pm + 36) * *(float *)(*pm + 36)
        + *(float *)(*pm + 40) * *(float *)(*pm + 40));
  if ( v15 >= 1.0 )
  {
    v14 = 0.0;
    v13 = 5.5 * 1.5;
    if ( v15 >= 100.0 )
      v1 = v15;
    else
      v1 = 100.0;
    v12 = v1;
    v14 = v1 * v13 * pml[9] + v14;
    v11 = v15 - v14;
    if ( v11 < 0.0 )
      v11 = 0.0;
    v11 = v11 / v15;
    *(float *)(*pm + 32) = *(float *)(*pm + 32) * v11;
    *(float *)(*pm + 36) = *(float *)(*pm + 36) * v11;
    *(float *)(*pm + 40) = *(float *)(*pm + 40) * v11;
  }
  else
  {
    *(float *)(*pm + 32) = vec3_origin[0];
    *(float *)(*pm + 36) = vec3_origin[1];
    *(float *)(*pm + 40) = vec3_origin[2];
  }
  v2 = sub_23905((char *)(pm + 4));
  v7 = (float)*(char *)(pm + 24);
  v6 = (float)*(char *)(pm + 25);
  for ( i = 0; i <= 2; ++i )
    v8[i] = pml[i] * v7 + pml[i + 3] * v6;
  *(float *)&v9 = (long double)*(char *)(pm + 26) + *(float *)&v9;
  *(float *)v5 = v8[0];
  *(float *)&v5[1] = v8[1];
  v5[2] = v9;
  v3 = VectorNormalize(v5);
  v4 = v3 * v2;
  sub_2379E((int)v5, v4, 9.0);
  *(float *)(*pm + 20) = *(float *)(*pm + 32) * pml[9] + *(float *)(*pm + 20);
  *(float *)(*pm + 24) = *(float *)(*pm + 36) * pml[9] + *(float *)(*pm + 24);
  result = *pm;
  *(float *)(*pm + 28) = *(float *)(*pm + 40) * pml[9] + *(float *)(*pm + 28);
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (000256ED) --------------------------------------------------------
int sub_256ED()
{
  int v0; // ecx
  int result; // eax
  float v2; // [esp+1Ch] [ebp-8Ch]
  float v3[4]; // [esp+20h] [ebp-88h] BYREF
  int v4[4]; // [esp+30h] [ebp-78h] BYREF
  int i; // [esp+40h] [ebp-68h]
  float v6; // [esp+48h] [ebp-60h]
  float v7; // [esp+4Ch] [ebp-5Ch]
  int v8[6]; // [esp+50h] [ebp-58h] BYREF
  float v9; // [esp+68h] [ebp-40h]
  float v10; // [esp+6Ch] [ebp-3Ch]
  float v11[2]; // [esp+70h] [ebp-38h]
  int v12; // [esp+78h] [ebp-30h]
  float v13; // [esp+8Ch] [ebp-1Ch]
  float v14; // [esp+90h] [ebp-18h]
  float v15; // [esp+94h] [ebp-14h]
  float v16; // [esp+98h] [ebp-10h]
  float v17; // [esp+9Ch] [ebp-Ch]

  *(_DWORD *)(*pm + 244) = bg_viewheight_standing[3];
  *(_DWORD *)(*pm + 1404) = bg_viewheight_standing[3];
  *(_BYTE *)(pm + 26) -= 127 * (*(_BYTE *)(pm + 9) & 0x20);
  *(_BYTE *)(pm + 26) += 127 * (*(_BYTE *)(pm + 9) & 0x10);
  if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
  {
    v17 = sqrt(
            *(float *)(*pm + 32) * *(float *)(*pm + 32)
          + *(float *)(*pm + 36) * *(float *)(*pm + 36)
          + *(float *)(*pm + 40) * *(float *)(*pm + 40));
  }
  else if ( (long double)*(char *)(pm + 26) == 0.0 )
  {
    v17 = 0.0;
  }
  else
  {
    v0 = *pm;
    *(_DWORD *)(*pm + 36) = 0;
    *(_DWORD *)(v0 + 32) = 0;
    v17 = 127.0;
    *(float *)(*pm + 40) = (float)*(char *)(pm + 26);
  }
  if ( v17 >= 1.0 )
  {
    v16 = 0.0;
    v15 = 5.5 * 1.5;
    if ( v17 >= 100.0 )
      v2 = v17;
    else
      v2 = 100.0;
    v14 = v2;
    v16 = v2 * v15 * pml[9] + v16;
    v13 = v17 - v16;
    if ( v13 < 0.0 )
      v13 = 0.0;
    v13 = v13 / v17;
    *(float *)(*pm + 32) = *(float *)(*pm + 32) * v13;
    *(float *)(*pm + 36) = *(float *)(*pm + 36) * v13;
    *(float *)(*pm + 40) = *(float *)(*pm + 40) * v13;
  }
  else
  {
    *(float *)(*pm + 32) = vec3_origin[0];
    *(float *)(*pm + 36) = vec3_origin[1];
    *(float *)(*pm + 40) = vec3_origin[2];
  }
  v6 = sub_23905((char *)(pm + 4));
  v10 = (float)*(char *)(pm + 24);
  v9 = (float)*(char *)(pm + 25);
  v4[1] = 0;
  v4[0] = 0;
  v4[2] = 1065353216;
  CrossProduct(v4, &pml[3], v3);
  for ( i = 0; i <= 2; ++i )
    v11[i] = v3[i] * v10 + pml[i + 3] * v9;
  *(float *)&v12 = (long double)*(char *)(pm + 26) + (long double)*(char *)(pm + 26) + *(float *)&v12;
  *(float *)v8 = v11[0];
  *(float *)&v8[1] = v11[1];
  v8[2] = v12;
  v7 = VectorNormalize(v8);
  v7 = v7 * v6;
  sub_2379E((int)v8, v7, 9.0);
  *(float *)(*pm + 20) = *(float *)(*pm + 32) * pml[9] + *(float *)(*pm + 20);
  *(float *)(*pm + 24) = *(float *)(*pm + 36) * pml[9] + *(float *)(*pm + 24);
  result = *pm;
  *(float *)(*pm + 28) = *(float *)(*pm + 40) * pml[9] + *(float *)(*pm + 28);
  return result;
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (00025B9B) --------------------------------------------------------
int __cdecl sub_25B9B(int a1)
{
  int v3; // [esp+10h] [ebp-8h]

  v3 = sub_242B2();
  if ( !v3 )
    return 0;
  if ( (a1 & 1) != 0 )
    return v3 + 47;
  if ( (a1 & 0x10000) != 0 )
    return v3 + 70;
  if ( (a1 & 0x80u) == 0 && *(float *)(*pm + 68) == 0.0 )
    return v3 + 1;
  return v3 + 24;
}

//----- (00025C34) --------------------------------------------------------
int sub_25C34()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_242B2();
  if ( v2 )
    v1 = v2 + 24;
  else
    v1 = 0;
  return v1;
}

//----- (00025C5F) --------------------------------------------------------
int sub_25C5F()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_242B2();
  if ( v2 )
    v1 = v2 + 1;
  else
    v1 = 0;
  return v1;
}

//----- (00025C88) --------------------------------------------------------
int sub_25C88()
{
  return sub_242B2() + 93;
}

//----- (00025C9E) --------------------------------------------------------
int sub_25C9E()
{
  return sub_242B2() + 116;
}

//----- (00025CB4) --------------------------------------------------------
void sub_25CB4()
{
  long double v0; // fst6
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  char v5; // [esp+4h] [ebp-74h]
  double v6; // [esp+4h] [ebp-74h]
  float v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+24h] [ebp-54h]
  int v9; // [esp+38h] [ebp-40h]
  int v10; // [esp+3Ch] [ebp-3Ch]
  int v11; // [esp+3Ch] [ebp-3Ch]
  int v12; // [esp+40h] [ebp-38h]
  float v13; // [esp+44h] [ebp-34h]
  float v14; // [esp+48h] [ebp-30h]
  float v15; // [esp+54h] [ebp-24h]
  float v16; // [esp+58h] [ebp-20h]
  float v17; // [esp+60h] [ebp-18h]
  float v18; // [esp+64h] [ebp-14h]
  float v19; // [esp+68h] [ebp-10h]
  float v20; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(pm + 241) != 3 )
  {
    v18 = pml[29] - *(float *)(*pm + 28);
    v17 = pml[32];
    v7 = (float)*(int *)(*pm + 64);
    v15 = COERCE_FLOAT(LODWORD(v7) ^ 0x80000000) * 0.5;
    v14 = v17 * v17 - v15 * 4.0 * v18;
    if ( v14 >= 0.0 )
    {
      v16 = (-v17 - sqrt(v14)) / (v15 + v15);
      v20 = (v16 * COERCE_FLOAT(LODWORD(v7) ^ 0x80000000) + v17) * -1.0;
      v0 = (long double)*(int *)(*pm + 64);
      v19 = v20 * v20 / (v0 + v0);
      if ( *(_DWORD *)(pm + 56) )
      {
        v6 = v20;
        Com_Printf("landing vel: %.1f fall height: %.1f\n", SLOBYTE(v6));
      }
      if ( bg_fallDamageMinHeight[2] < (long double)bg_fallDamageMaxHeight[2] && bg_fallDamageMinHeight[2] >= 0.0 )
      {
        if ( bg_fallDamageMinHeight[2] >= (long double)v19 || (LODWORD(pml[21]) & 1) != 0 || *(int *)(*pm + 4) > 5 )
        {
          v10 = 0;
        }
        else if ( v19 < (long double)bg_fallDamageMaxHeight[2] )
        {
          v11 = (int)((v19 - bg_fallDamageMinHeight[2]) / (bg_fallDamageMaxHeight[2] - bg_fallDamageMinHeight[2]) * 100.0);
          if ( v11 < 0 )
          {
            v8 = 0;
          }
          else
          {
            v8 = (int)((v19 - bg_fallDamageMinHeight[2])
                     / (bg_fallDamageMaxHeight[2] - bg_fallDamageMinHeight[2])
                     * 100.0);
            if ( v11 > 100 )
              v8 = 100;
          }
          v10 = v8;
        }
        else
        {
          v10 = 100;
        }
      }
      else
      {
        Com_Printf("bg_fallDamageMaxHeight and bg_fallDamageMinHeight have bad values\n", v5);
        v10 = 0;
      }
      if ( *(_BYTE *)(pm + 241) == 2 )
        v10 = (int)((long double)v10 * 0.5);
      if ( v19 > 12.0 )
        v12 = (int)((v19 - 12.0) / 26.0 * 4.0 + 4.0);
      else
        v12 = 0;
      if ( v12 > 24 )
        LOBYTE(v12) = 24;
      if ( v10 )
      {
        if ( !*(_DWORD *)(*pm + 112) )
          BG_AnimScriptEvent(*pm, 5, 0, 1);
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("falling damage: %i\n", v10);
        if ( v10 > 99 || (LODWORD(pml[21]) & 2) != 0 )
        {
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.67000002;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.67000002;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.67000002;
        }
        else
        {
          v9 = 35 * v10 + 500;
          if ( v9 > 2000 )
            v9 = 2000;
          if ( v9 > 500 )
          {
            if ( v9 <= 1499 )
              v13 = 0.5 - ((long double)v9 - 500.0) / 1000.0 * 0.30000001;
            else
              v13 = 0.2;
          }
          else
          {
            v13 = 0.5;
          }
          if ( *(int *)(pm + 56) > 1 )
            Com_Printf("landing stun time: %i speed mult: %.2f\n", v9);
          *(_DWORD *)(*pm + 16) = v9;
          *(_DWORD *)(*pm + 12) |= 0x100u;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * v13;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * v13;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * v13;
        }
        v1 = sub_25C9E();
        BG_AddPredictableEventToPlayerstate(v1, v10, *pm);
      }
      else if ( v19 > 4.0 )
      {
        if ( v19 >= 8.0 )
        {
          if ( v19 >= 12.0 )
          {
            *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.67000002;
            *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.67000002;
            *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.67000002;
            v4 = sub_25C88();
            BG_AddPredictableEventToPlayerstate(v4, v12, *pm);
          }
          else
          {
            v3 = sub_25C5F();
            PM_AddEvent(v3);
          }
        }
        else
        {
          v2 = sub_25C34();
          PM_AddEvent(v2);
        }
      }
    }
  }
}
// 25E20: variable 'v5' is possibly undefined
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000262B7) --------------------------------------------------------
int __cdecl sub_262B7(int a1)
{
  float v3; // [esp+30h] [ebp-38h] BYREF
  float v4; // [esp+34h] [ebp-34h]
  float v5; // [esp+38h] [ebp-30h]
  unsigned int i; // [esp+4Ch] [ebp-1Ch]

  for ( i = 0; i <= 0x19; ++i )
  {
    v3 = *(float *)(*pm + 20) + flt_9B6C0[3 * i];
    v4 = *(float *)(*pm + 24) + flt_9B6C0[3 * i + 1];
    v5 = *(float *)(*pm + 28) + flt_9B6C0[3 * i + 2];
    PM_trace(a1, &v3, pm + 216, pm + 228, &v3, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
    if ( !*(_BYTE *)(a1 + 47) )
    {
      *(float *)(*pm + 20) = v3;
      *(float *)(*pm + 24) = v4;
      *(float *)(*pm + 28) = v5;
      v3 = *(float *)(*pm + 20);
      v4 = *(float *)(*pm + 24);
      v5 = *(float *)(*pm + 28) - 1.0;
      PM_trace(a1, *pm + 20, pm + 216, pm + 228, &v3, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
      qmemcpy(&pml[14], (const void *)a1, 0x30u);
      *(_DWORD *)(*pm + 20) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(*pm + 24) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(*pm + 28) = *(_DWORD *)(a1 + 12);
      return 1;
    }
  }
  *(_DWORD *)(*pm + 88) = 1023;
  pml[12] = 0.0;
  pml[13] = 0.0;
  pml[11] = 0.0;
  *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
  *(_DWORD *)(*pm + 108) = 0;
  return 0;
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002656D) --------------------------------------------------------
float *sub_2656D()
{
  float *result; // eax
  int v1; // [esp+20h] [ebp-48h] BYREF
  int v2; // [esp+24h] [ebp-44h]
  float v3; // [esp+28h] [ebp-40h]
  float v4[14]; // [esp+30h] [ebp-38h] BYREF

  if ( *(_DWORD *)(*pm + 88) == 1023 )
  {
    v1 = *(_DWORD *)(*pm + 20);
    v2 = *(_DWORD *)(*pm + 24);
    v3 = *(float *)(*pm + 28);
    v3 = v3 - 1.0;
    (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, _DWORD))(pm + 260))(
      v4,
      *pm + 20,
      pm + 216,
      pm + 228,
      &v1,
      *(_DWORD *)(*pm + 212),
      *(_DWORD *)(pm + 52));
    LODWORD(pml[13]) = 1.0 != v4[0];
  }
  else
  {
    if ( *(_DWORD *)(pm + 56) )
      Com_Printf("%i:lift\n", c_pmove);
    v1 = *(_DWORD *)(*pm + 20);
    v2 = *(_DWORD *)(*pm + 24);
    v3 = *(float *)(*pm + 28);
    v3 = v3 - 64.0;
    (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, _DWORD))(pm + 260))(
      v4,
      *pm + 20,
      pm + 216,
      pm + 228,
      &v1,
      *(_DWORD *)(*pm + 212),
      *(_DWORD *)(pm + 52));
    if ( v4[0] == 1.0 )
    {
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*pm, 4, 0, 1);
      else
        BG_AnimScriptEvent(*pm, 3, 0, 1);
      pml[13] = 0.0;
    }
    else
    {
      LODWORD(pml[13]) = v4[0] < 0.015625;
    }
  }
  *(_DWORD *)(*pm + 88) = 1023;
  pml[12] = 0.0;
  result = pml;
  pml[11] = 0.0;
  return result;
}
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026823) --------------------------------------------------------
float *sub_26823()
{
  int v0; // eax
  long double v1; // fst6
  float *result; // eax
  float v3[12]; // [esp+20h] [ebp-68h] BYREF
  int v4[4]; // [esp+50h] [ebp-38h] BYREF
  int v5[2]; // [esp+60h] [ebp-28h] BYREF
  float v6; // [esp+68h] [ebp-20h]

  v5[0] = *(_DWORD *)(*pm + 20);
  v5[1] = *(_DWORD *)(*pm + 24);
  v4[0] = *(_DWORD *)(*pm + 20);
  v4[1] = *(_DWORD *)(*pm + 24);
  if ( (*(_DWORD *)(*pm + 132) & 0x106000) != 0 )
  {
    v6 = *(float *)(*pm + 28);
    v0 = *pm;
    v1 = 1.0;
  }
  else
  {
    v6 = *(float *)(*pm + 28) + 0.25;
    v0 = *pm;
    v1 = 0.25;
  }
  *(float *)&v4[2] = *(float *)(v0 + 28) - v1;
  PM_trace(v3, v5, pm + 216, pm + 228, v4, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
  qmemcpy(&pml[14], v3, 0x30u);
  if ( !BYTE2(v3[11]) || (result = (float *)sub_262B7((int)v3)) != 0 )
  {
    if ( HIBYTE(v3[11]) )
    {
      v6 = *(float *)(*pm + 28) - 0.001;
      PM_trace(v3, v5, pm + 216, pm + 228, v4, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
      if ( HIBYTE(v3[11]) )
      {
        *(_DWORD *)(*pm + 88) = 1023;
        pml[12] = 0.0;
        pml[13] = 0.0;
        result = pml;
        pml[11] = 0.0;
        return result;
      }
      qmemcpy(&pml[14], v3, 0x30u);
    }
    if ( v3[0] == 1.0 )
    {
      result = sub_2656D();
    }
    else if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0
           || *(float *)(*pm + 40) <= 0.0
           || *(float *)(*pm + 32) * v3[4] + *(float *)(*pm + 36) * v3[5] + *(float *)(*pm + 40) * v3[6] <= 10.0 )
    {
      if ( v3[6] >= 0.69999999 )
      {
        LODWORD(pml[12]) = 1;
        LODWORD(pml[13]) = 1;
        LODWORD(pml[11]) = 1;
        if ( *(_DWORD *)(*pm + 88) == 1023 )
        {
          if ( *(_DWORD *)(pm + 56) )
            Com_Printf("%i:Land\n", c_pmove);
          sub_25CB4();
        }
        *(_DWORD *)(*pm + 88) = LOWORD(v3[10]);
        result = (float *)PM_AddTouchEnt(LOWORD(v3[10]));
      }
      else
      {
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("%i:steep\n", c_pmove);
        *(_DWORD *)(*pm + 88) = 1023;
        LODWORD(pml[12]) = 1;
        LODWORD(pml[13]) = 1;
        pml[11] = 0.0;
        *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
        result = (float *)*pm;
        *(_DWORD *)(*pm + 108) = 0;
      }
    }
    else
    {
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("%i:kickoff\n", c_pmove);
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*pm, 4, 0, 0);
      else
        BG_AnimScriptEvent(*pm, 3, 0, 0);
      pml[13] = 0.0;
      *(_DWORD *)(*pm + 88) = 1023;
      pml[12] = 0.0;
      result = pml;
      pml[11] = 0.0;
    }
  }
  return result;
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18754: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026CF1) --------------------------------------------------------
int sub_26CF1()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-24h]
  int v2[2]; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+28h] [ebp-10h]

  *(_BYTE *)(pm + 241) = 0;
  *(_BYTE *)(pm + 240) = 0;
  v2[0] = *(_DWORD *)(*pm + 20);
  v2[1] = *(_DWORD *)(*pm + 24);
  v3 = *(float *)(*pm + 28) + *(float *)(*pm + 1380) + 1.0;
  result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 272))(v2, *(_DWORD *)(*pm + 212), 32);
  if ( result )
  {
    v1 = (int)(*(float *)(*pm + 248) - *(float *)(*pm + 1380));
    *(_BYTE *)(pm + 240) = result;
    *(_BYTE *)(pm + 241) = 1;
    v3 = *(float *)(*pm + 28) + *(float *)(*pm + 1380) + (long double)(v1 / 2);
    result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 272))(v2, *(_DWORD *)(*pm + 212), 32);
    if ( result )
    {
      *(_BYTE *)(pm + 241) = 2;
      v3 = *(float *)(*pm + 28) + *(float *)(*pm + 1380) + (long double)v1;
      result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 272))(v2, *(_DWORD *)(*pm + 212), 32);
      if ( result )
      {
        result = pm;
        *(_BYTE *)(pm + 241) = 3;
      }
    }
  }
  return result;
}

//----- (00026EF8) --------------------------------------------------------
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3)
{
  if ( a2 == *(_DWORD *)(a1 + 1396) )
    return 400;
  if ( a2 != *(_DWORD *)(a1 + 1400) )
    return 200;
  if ( a3 )
    return 200;
  return 400;
}

//----- (00026F47) --------------------------------------------------------
long double __cdecl sub_26F47(int a1, int a2, float *a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v6 = a2 + 12;
    v7 = 1;
    do
    {
      if ( a1 == *(_DWORD *)v6 )
      {
        *a3 = (float)*(int *)(v6 + 8);
        return *(float *)(v6 + 4);
      }
      if ( *(_DWORD *)v6 > a1 )
      {
        v5 = (long double)(a1 - *(_DWORD *)(a2 + 12 * v7 - 12))
           / (long double)(*(_DWORD *)v6 - *(_DWORD *)(a2 + 12 * v7 - 12));
        *a3 = (long double)*(int *)(a2 + 12 * v7 - 12 + 8)
            + (long double)(*(_DWORD *)(v6 + 8) - *(_DWORD *)(a2 + 12 * v7 - 12 + 8)) * v5;
        return (float)((*(float *)(v6 + 4) - *(float *)(a2 + 12 * v7 - 12 + 4)) * v5 + *(float *)(a2 + 12 * v7 - 12 + 4));
      }
      ++v7;
      v6 = a2 + 12 * v7;
    }
    while ( *(_DWORD *)v6 != -1 );
    *a3 = (float)*(int *)(a2 + 8);
    v4 = *(float *)(a2 + 4);
  }
  else
  {
    *a3 = (float)*(int *)(a2 + 8);
    v4 = *(float *)(a2 + 4);
  }
  return v4;
}

//----- (0002706E) --------------------------------------------------------
long double __cdecl sub_2706E(int a1, int a2)
{
  float v4; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(*pm + 252) )
    return 0.0;
  if ( a1 != -1
    && a2 != -1
    && (a2 != *(_DWORD *)(*pm + 256)
     || a2 == *(_DWORD *)(*pm + 1400)
     && (a1 != *(_DWORD *)(*pm + 1396) || *(_DWORD *)(*pm + 260))
     && (a1 != *(_DWORD *)(*pm + 1404) || !*(_DWORD *)(*pm + 260))) )
  {
    return 0.0;
  }
  v4 = (long double)(*(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 252))
     / (long double)(int)PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 256), *(_DWORD *)(*pm + 260));
  if ( v4 < 0.0 )
    return 0.0;
  if ( v4 > 1.0 )
    v4 = 1.0;
  return v4;
}
// 18974: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);

//----- (000271F8) --------------------------------------------------------
void sub_271F8()
{
  int v0; // esi
  int v1; // esi
  int v2; // esi
  float v3; // [esp+30h] [ebp-38h] BYREF
  float v4; // [esp+34h] [ebp-34h]
  float v5; // [esp+38h] [ebp-30h]
  int v6; // [esp+40h] [ebp-28h]
  int v7; // [esp+44h] [ebp-24h]
  int v8; // [esp+48h] [ebp-20h]
  float v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h] BYREF
  int v11; // [esp+58h] [ebp-10h]
  int v12; // [esp+5Ch] [ebp-Ch]

  if ( *(_DWORD *)(*pm + 244) && *(float *)(*pm + 248) != 0.0 )
  {
    if ( *(float *)(*pm + 248) != (long double)*(int *)(*pm + 244) || *(_DWORD *)(*pm + 252) )
    {
      v12 = 0;
      if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396)
        || *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1400)
        || *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1404) )
      {
        if ( *(_DWORD *)(*pm + 252) )
        {
          v11 = PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 256), *(_DWORD *)(*pm + 260));
          v12 = 100 * (*(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 252)) / v11;
          if ( v12 >= 0 )
          {
            if ( v12 > 100 )
              v12 = 100;
          }
          else
          {
            v12 = 0;
          }
          if ( v12 == 100 )
          {
            *(float *)(*pm + 248) = (float)*(int *)(*pm + 256);
            *(_DWORD *)(*pm + 252) = 0;
            *(_DWORD *)(*pm + 264) = 0;
          }
          else
          {
            if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1396) )
            {
              v0 = *pm;
              *(float *)(v0 + 248) = sub_26F47(v12, (int)&unk_AB300, &v10);
            }
            else if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1400) )
            {
              v1 = *pm;
              if ( *(_DWORD *)(*pm + 260) )
                *(float *)(v1 + 248) = sub_26F47(v12, (int)&unk_AB200, &v10);
              else
                *(float *)(v1 + 248) = sub_26F47(v12, (int)&unk_AB3E0, &v10);
            }
            else
            {
              v2 = *pm;
              *(float *)(v2 + 248) = sub_26F47(v12, (int)&unk_AB280, &v10);
            }
            if ( fabs(*(float *)(*pm + 264) - v10) > 0.05000000074505806 )
            {
              v6 = *(_DWORD *)(*pm + 32);
              v7 = *(_DWORD *)(*pm + 36);
              v8 = *(_DWORD *)(*pm + 40);
              v9 = v10 - *(float *)(*pm + 264);
              if ( *(_DWORD *)(*pm + 88) == 1023 )
                v9 = v9 * 0.5;
              v9 = v9 / pml[9];
              v3 = pml[0];
              v4 = pml[1];
              v5 = 0.0;
              VectorNormalize(&v3);
              *(float *)(*pm + 32) = v3 * v9;
              *(float *)(*pm + 36) = v4 * v9;
              *(float *)(*pm + 40) = v5 * v9;
              PM_StepSlideMove(1);
              *(_DWORD *)(*pm + 32) = v6;
              *(_DWORD *)(*pm + 36) = v7;
              *(_DWORD *)(*pm + 40) = v8;
              *(float *)(*pm + 264) = v10;
            }
          }
        }
        if ( *(_DWORD *)(*pm + 252) )
        {
          if ( *(_DWORD *)(*pm + 244) != *(_DWORD *)(*pm + 256)
            && (*(_DWORD *)(*pm + 244) < *(_DWORD *)(*pm + 256) && !*(_DWORD *)(*pm + 260)
             || *(_DWORD *)(*pm + 244) > *(_DWORD *)(*pm + 256) && *(_DWORD *)(*pm + 260)) )
          {
            v12 = 100 - v12;
            *(_DWORD *)(*pm + 260) ^= 1u;
            if ( *(_DWORD *)(*pm + 260) )
            {
              if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1404) )
              {
                *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1400);
              }
              else if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1400) )
              {
                *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1396);
              }
            }
            else if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1396) )
            {
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1400);
            }
            else if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1400) )
            {
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1404);
            }
            if ( v12 == 100 )
            {
              *(float *)(*pm + 248) = (float)*(int *)(*pm + 256);
              *(_DWORD *)(*pm + 252) = 0;
              *(_DWORD *)(*pm + 264) = 0;
            }
            else
            {
              v11 = PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 256), *(_DWORD *)(*pm + 260));
              *(_DWORD *)(*pm + 252) = *(_DWORD *)(pm + 4) - (int)((long double)v12 * 0.0099999998 * (long double)v11);
              if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1396) )
              {
                sub_26F47(v12, (int)&unk_AB300, &v10);
              }
              else if ( *(_DWORD *)(*pm + 256) == *(_DWORD *)(*pm + 1400) )
              {
                if ( *(_DWORD *)(*pm + 260) )
                  sub_26F47(v12, (int)&unk_AB200, &v10);
                else
                  sub_26F47(v12, (int)&unk_AB3E0, &v10);
              }
              else
              {
                sub_26F47(v12, (int)&unk_AB280, &v10);
              }
              *(float *)(*pm + 264) = v10;
            }
          }
        }
        else if ( *(float *)(*pm + 248) != (long double)*(int *)(*pm + 244) )
        {
          *(_DWORD *)(*pm + 252) = *(_DWORD *)(pm + 4);
          if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396) )
          {
            *(_DWORD *)(*pm + 260) = 1;
            if ( *(float *)(*pm + 248) <= (long double)*(int *)(*pm + 1400) )
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1396);
            else
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1400);
          }
          else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1400) )
          {
            *(_DWORD *)(*pm + 260) = *(float *)(*pm + 248) > (long double)*(int *)(*pm + 244);
            *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1400);
          }
          else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1404) )
          {
            *(_DWORD *)(*pm + 260) = 0;
            if ( (long double)*(int *)(*pm + 1400) <= *(float *)(*pm + 248) )
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1404);
            else
              *(_DWORD *)(*pm + 256) = *(_DWORD *)(*pm + 1400);
          }
        }
      }
      else
      {
        *(_DWORD *)(*pm + 252) = 0;
        if ( (long double)*(int *)(*pm + 244) <= *(float *)(*pm + 248) )
        {
          *(float *)(*pm + 248) = *(float *)(*pm + 248) - pml[9] * 180.0;
          if ( (long double)*(int *)(*pm + 244) >= *(float *)(*pm + 248) )
            *(float *)(*pm + 248) = (float)*(int *)(*pm + 244);
        }
        else
        {
          *(float *)(*pm + 248) = pml[9] * 180.0 + *(float *)(*pm + 248);
          if ( *(float *)(*pm + 248) >= (long double)*(int *)(*pm + 244) )
            *(float *)(*pm + 248) = (float)*(int *)(*pm + 244);
        }
      }
    }
  }
  else if ( *(_DWORD *)(*pm + 4) == 4 )
  {
    *(_DWORD *)(*pm + 248) = 0;
  }
  else
  {
    *(float *)(*pm + 248) = (float)*(int *)(*pm + 244);
  }
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18974: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 19444: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (00027E16) --------------------------------------------------------
void sub_27E16()
{
  int v0; // eax
  long double v1; // fst7
  int v2; // esi
  int v3; // [esp+40h] [ebp-88h] BYREF
  int v4; // [esp+44h] [ebp-84h]
  float v5; // [esp+48h] [ebp-80h]
  float v6; // [esp+5Ch] [ebp-6Ch]
  int v7[2]; // [esp+60h] [ebp-68h] BYREF
  float v8; // [esp+68h] [ebp-60h]
  int v9; // [esp+7Ch] [ebp-4Ch]
  float v10; // [esp+80h] [ebp-48h] BYREF
  int v11; // [esp+84h] [ebp-44h]
  int v12; // [esp+88h] [ebp-40h]
  float v13; // [esp+8Ch] [ebp-3Ch]
  int v14; // [esp+90h] [ebp-38h] BYREF
  char v15; // [esp+AEh] [ebp-1Ah]
  char v16; // [esp+AFh] [ebp-19h]
  _BOOL4 v17; // [esp+B8h] [ebp-10h]
  int v18; // [esp+BCh] [ebp-Ch]

  *(_DWORD *)(pm + 256) = 0;
  if ( *(_DWORD *)(*pm + 4) == 4 )
  {
    *(_DWORD *)(pm + 216) = -1056964608;
    *(_DWORD *)(pm + 220) = -1056964608;
    *(_DWORD *)(pm + 224) = -1056964608;
    *(_DWORD *)(pm + 228) = 1090519040;
    *(_DWORD *)(pm + 232) = 1090519040;
    *(_DWORD *)(pm + 236) = 1098907648;
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
    if ( (*(_BYTE *)(pm + 9) & 0x40) != 0 )
    {
      *(_BYTE *)(pm + 9) &= 0xBFu;
      BG_AddPredictableEventToPlayerstate(142, 0, *pm);
    }
    *(_DWORD *)(pm + 260) = *(_DWORD *)(pm + 268);
    *(_DWORD *)(*pm + 132) |= 0x10u;
    *(_DWORD *)(*pm + 244) = 0;
    *(_DWORD *)(*pm + 248) = 0;
    return;
  }
  v18 = *(_DWORD *)(*pm + 12) & 1;
  v17 = (*(_DWORD *)(*pm + 12) & 3) == 0;
  *(_DWORD *)(pm + 216) = *(_DWORD *)(*pm + 1372);
  *(_DWORD *)(pm + 220) = *(_DWORD *)(*pm + 1376);
  *(_DWORD *)(pm + 228) = *(_DWORD *)(*pm + 1384);
  *(_DWORD *)(pm + 232) = *(_DWORD *)(*pm + 1388);
  *(_DWORD *)(pm + 224) = *(_DWORD *)(*pm + 1380);
  if ( *(int *)(*pm + 4) > 5 )
  {
    *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
    *(_DWORD *)(*pm + 244) = *(_DWORD *)(*pm + 1408);
    if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
      *(_DWORD *)(pm + 260) = *(_DWORD *)(pm + 264);
    else
      *(_DWORD *)(pm + 260) = *(_DWORD *)(pm + 268);
    *(_DWORD *)(*pm + 132) |= 0x10u;
    sub_271F8();
    return;
  }
  if ( (*(_DWORD *)(*pm + 132) & 0x106000) != 0 )
  {
    if ( (*(_DWORD *)(*pm + 132) & 0x2000) == 0 || (*(_DWORD *)(*pm + 132) & 0x4000) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 132) & 0x4000) == 0 || (*(_DWORD *)(*pm + 132) & 0x2000) != 0 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
      }
      else
      {
        *(_DWORD *)(*pm + 12) |= 2u;
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
      }
    }
    else
    {
      *(_DWORD *)(*pm + 12) |= 1u;
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
    }
    goto LABEL_54;
  }
  if ( (*(_DWORD *)(*pm + 12) & 0x4000) == 0
    && ((*(_DWORD *)(*pm + 12) & 0x20) == 0 || *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216)) + 128) != 3) )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 && (*(_BYTE *)(pm + 9) & 0xC0) != 0 )
    {
      *(_BYTE *)(pm + 9) &= 0x3Fu;
      BG_AddPredictableEventToPlayerstate(142, 0, *pm);
    }
    if ( (*(_BYTE *)(pm + 9) & 0x40) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) == 0
        && (*(_DWORD *)(*pm + 88) == 1023
         || *(_BYTE *)(pm + 241)
         || !BG_CheckProne(
               *(_DWORD *)(*pm + 212),
               *pm + 20,
               *(_DWORD *)(pm + 228),
               1106247680,
               *(float *)(*pm + 236),
               *pm + 1544,
               *pm + 1548,
               *pm + 1552,
               0,
               *(_DWORD *)(*pm + 88) != 1023,
               0,
               *(_DWORD *)(pm + 268),
               *(_DWORD *)(pm + 264),
               0,
               60.0,
               *(_DWORD *)(pm + 276))) )
      {
        if ( *(_DWORD *)(*pm + 88) != 1023 )
        {
          *(_DWORD *)(*pm + 12) |= 0x8000u;
          if ( (*(_BYTE *)(pm + 9) & 2) == 0 )
          {
            if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
              BG_AddPredictableEventToPlayerstate(143, 0, *pm);
            else
              BG_AddPredictableEventToPlayerstate(142, 0, *pm);
          }
        }
      }
      else
      {
        *(_DWORD *)(*pm + 12) |= 1u;
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
      }
      goto LABEL_54;
    }
    if ( (*(_BYTE *)(pm + 9) & 0x80) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) == 0 )
      {
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_54;
      }
      *(_DWORD *)(pm + 236) = 1112014848;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 268))(
        &v10,
        *pm + 20,
        pm + 216,
        pm + 228,
        *pm + 20,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v15 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_54;
      }
      if ( (*(_BYTE *)(pm + 9) & 2) != 0 )
        goto LABEL_54;
    }
    else
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) == 0 )
      {
        if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
        {
          *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
          (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 268))(
            &v10,
            *pm + 20,
            pm + 216,
            pm + 228,
            *pm + 20,
            *(_DWORD *)(*pm + 212),
            *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
          if ( v15 )
          {
            if ( (*(_BYTE *)(pm + 9) & 2) == 0 )
              BG_AddPredictableEventToPlayerstate(143, 0, *pm);
          }
          else
          {
            *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
          }
        }
        goto LABEL_54;
      }
      *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 268))(
        &v10,
        *pm + 20,
        pm + 216,
        pm + 228,
        *pm + 20,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v15 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
        goto LABEL_54;
      }
      *(_DWORD *)(pm + 236) = 1112014848;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 268))(
        &v10,
        *pm + 20,
        pm + 216,
        pm + 228,
        *pm + 20,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v15 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_54;
      }
      if ( (*(_BYTE *)(pm + 9) & 2) != 0 )
        goto LABEL_54;
    }
    BG_AddPredictableEventToPlayerstate(144, 0, *pm);
  }
LABEL_54:
  if ( !*(_DWORD *)(*pm + 252) )
  {
    if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
    {
      if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1404) )
      {
        *(_DWORD *)(*pm + 244) = *(_DWORD *)(*pm + 1400);
      }
      else
      {
        if ( g_debugProneCheck[3] == 2 )
          BG_CheckProne(
            *(_DWORD *)(*pm + 212),
            *pm + 20,
            *(_DWORD *)(pm + 228),
            1106247680,
            *(float *)(*pm + 236),
            0,
            0,
            0,
            0,
            *(_DWORD *)(*pm + 88) != 1023,
            0,
            *(_DWORD *)(pm + 268),
            *(_DWORD *)(pm + 264),
            0,
            60.0,
            *(_DWORD *)(pm + 276));
        if ( *(_DWORD *)(*pm + 244) != *(_DWORD *)(*pm + 1396) )
        {
          *(_DWORD *)(*pm + 244) = *(_DWORD *)(*pm + 1396);
          *(_DWORD *)(pm + 256) = 1;
          if ( *(_DWORD *)(*pm + 220) != 12 && *(_DWORD *)(*pm + 220) != 13 )
            BG_PlayAnim(*pm, 0, 2, 0, 0, 1, 1);
          *(_DWORD *)(*pm + 12) |= 0x2000u;
          *(_DWORD *)(*pm + 16) = 1800;
        }
      }
    }
    else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396) )
    {
      *(_DWORD *)(*pm + 244) = *(_DWORD *)(*pm + 1400);
      *(_DWORD *)(pm + 256) = 1;
      if ( *(_DWORD *)(*pm + 220) != 12 && *(_DWORD *)(*pm + 220) != 13 )
        BG_PlayAnim(*pm, 0, 2, 0, 0, 1, 1);
    }
    else
    {
      if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
        v0 = *(_DWORD *)(*pm + 1400);
      else
        v0 = *(_DWORD *)(*pm + 1404);
      *(_DWORD *)(*pm + 244) = v0;
    }
  }
  sub_271F8();
  v9 = PM_GetEffectiveStance(*pm);
  if ( v9 == 1 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 3) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
        *(_DWORD *)(pm + 236) = 1112014848;
      else
        *(_DWORD *)(pm + 236) = 1106247680;
    }
    else
    {
      *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
    }
    *(_DWORD *)(*pm + 132) |= 0x40u;
    *(_DWORD *)(*pm + 132) &= 0xFFFFFFDF;
  }
  else if ( v9 == 2 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 3) != 0 )
      *(_DWORD *)(pm + 236) = 1112014848;
    else
      *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
    *(_DWORD *)(*pm + 132) |= 0x20u;
    *(_DWORD *)(*pm + 132) &= 0xFFFFFFBF;
  }
  else
  {
    *(_DWORD *)(pm + 236) = *(_DWORD *)(*pm + 1392);
    *(_DWORD *)(*pm + 132) &= 0xFFFFFF9F;
  }
  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    *(_DWORD *)(pm + 260) = *(_DWORD *)(pm + 264);
    *(_DWORD *)(*pm + 132) |= 0x10u;
    if ( !v18 )
    {
      if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
        PM_ClearAimDownSightFlag();
      }
      v3 = *(_DWORD *)(*pm + 20);
      v4 = *(_DWORD *)(*pm + 24);
      v5 = *(float *)(*pm + 28);
      v5 = v5 + 10.0;
      (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, unsigned int))(pm + 264))(
        &v10,
        *pm + 20,
        pm + 216,
        pm + 228,
        &v3,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      v3 = v11;
      v4 = v12;
      v5 = v13;
      (*(void (__cdecl **)(float *, int *, int, int, int, _DWORD, unsigned int))(pm + 264))(
        &v10,
        &v3,
        pm + 216,
        pm + 228,
        *pm + 20,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      *(_DWORD *)(*pm + 20) = v11;
      *(_DWORD *)(*pm + 24) = v12;
      *(float *)(*pm + 28) = v13;
      *(_DWORD *)(*pm + 1444) = *(_DWORD *)(*pm + 236);
      v7[0] = *(_DWORD *)(*pm + 20);
      v7[1] = *(_DWORD *)(*pm + 24);
      v8 = *(float *)(*pm + 28);
      v1 = v8 - 0.25;
      v8 = v1;
      (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, unsigned int))(pm + 264))(
        &v10,
        *pm + 20,
        pm + 216,
        pm + 228,
        v7,
        *(_DWORD *)(*pm + 212),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( v16 || (v1 = v10, v10 >= 1.0) )
      {
        *(_DWORD *)(*pm + 1448) = 0;
      }
      else
      {
        v2 = *pm;
        PitchForYawOnNormal(*(float *)(*pm + 1444), (int)&v14);
        *(float *)(v2 + 1448) = v1;
      }
      AngleDelta(*(float *)(*pm + 1448), *(float *)(*pm + 232));
      v6 = v1;
      if ( v6 >= -45.0 )
      {
        if ( v6 <= 45.0 )
          *(_DWORD *)(*pm + 1452) = *(_DWORD *)(*pm + 1448);
        else
          *(float *)(*pm + 1452) = *(float *)(*pm + 232) + 45.0;
      }
      else
      {
        *(float *)(*pm + 1452) = *(float *)(*pm + 232) - 45.0;
      }
    }
  }
  else
  {
    *(_DWORD *)(pm + 260) = *(_DWORD *)(pm + 268);
    *(_DWORD *)(*pm + 132) |= 0x10u;
  }
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 17454: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17AF4: using guessed type int PM_ClearAimDownSightFlag(void);

//----- (0002937C) --------------------------------------------------------
char __cdecl PM_FootstepEvent(char a1, char a2, int a3)
{
  char v3; // dl
  int v4; // eax
  int v5; // eax
  float v7[12]; // [esp+20h] [ebp-78h] BYREF
  float v8[4]; // [esp+50h] [ebp-48h] BYREF
  float v9; // [esp+60h] [ebp-38h] BYREF
  float v10; // [esp+64h] [ebp-34h]
  float v11; // [esp+68h] [ebp-30h]
  float v12; // [esp+70h] [ebp-28h] BYREF
  float v13; // [esp+74h] [ebp-24h]
  float v14; // [esp+78h] [ebp-20h]
  int v15; // [esp+84h] [ebp-14h]
  unsigned int v16; // [esp+88h] [ebp-10h]
  int v17; // [esp+8Ch] [ebp-Ch]

  v3 = (a2 + 64) ^ (a1 + 64);
  LOBYTE(v4) = v3 & 0x80;
  if ( v3 >= 0 )
    return v4;
  if ( *(_BYTE *)(pm + 241) )
  {
    if ( *(_BYTE *)(pm + 241) == 1 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
      {
LABEL_16:
        LOBYTE(v4) = PM_AddEvent(67);
        return v4;
      }
      if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 68) != 0.0 )
      {
LABEL_19:
        LOBYTE(v4) = PM_AddEvent(44);
        return v4;
      }
      if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
      {
LABEL_21:
        LOBYTE(v4) = PM_AddEvent(90);
        return v4;
      }
    }
    else
    {
      LOBYTE(v4) = pm;
      if ( *(_BYTE *)(pm + 241) != 2 )
        return v4;
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
        goto LABEL_16;
      if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 68) != 0.0 )
        goto LABEL_19;
      if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
        goto LABEL_21;
    }
    LOBYTE(v4) = PM_AddEvent(21);
    return v4;
  }
  v4 = *pm;
  if ( *(_DWORD *)(*pm + 88) == 1023 )
  {
    if ( a3 )
    {
      v4 = *(_DWORD *)(*pm + 12) & 0x10;
      if ( v4 )
      {
        v12 = *(float *)(pm + 216);
        v13 = *(float *)(pm + 220);
        v12 = v12 + 6.0;
        v13 = v13 + 6.0;
        v14 = 8.0;
        v9 = *(float *)(pm + 228);
        v10 = *(float *)(pm + 232);
        v11 = *(float *)(pm + 236);
        v9 = v9 - 6.0;
        v10 = v10 - 6.0;
        if ( v11 < 8.0 )
          v11 = v14;
        v16 = *(_DWORD *)(pm + 52) & 0xFDFEFFFF;
        v15 = -1040711680;
        v8[0] = *(float *)(*pm + 92) * -31.0 + *(float *)(*pm + 20);
        v8[1] = *(float *)(*pm + 96) * -31.0 + *(float *)(*pm + 24);
        v8[2] = *(float *)(*pm + 100) * -31.0 + *(float *)(*pm + 28);
        PM_trace(v7, *pm + 20, &v12, &v9, v8, *(_DWORD *)(*pm + 212), v16);
        v17 = (LODWORD(v7[7]) & 0x1F00000) >> 20;
        if ( v7[0] == 1.0 || !v17 )
          v17 = 13;
        LOBYTE(v4) = PM_AddEvent(v17 + 1);
      }
    }
  }
  else if ( a3 )
  {
    v5 = sub_25B9B(*(_DWORD *)(*pm + 12));
    LOBYTE(v4) = PM_AddEvent(v5);
  }
  return v4;
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00029756) --------------------------------------------------------
_BOOL4 PM_ShouldMakeFootsteps()
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(*pm + 12) & 0x80;
  v3 = PM_GetEffectiveStance(*pm);
  if ( v3 == 1 || v3 == 2 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x40) == 0 )
    return !v2;
  return !v2;
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);

//----- (000297E4) --------------------------------------------------------
void sub_297E4()
{
  int v0; // esi
  long double v1; // fst7
  long double v2; // fst6
  long double v3; // fst6
  float v4; // [esp+24h] [ebp-34h]
  int v5; // [esp+2Ch] [ebp-2Ch]
  int v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int v8; // [esp+34h] [ebp-24h]
  float v9; // [esp+38h] [ebp-20h]
  float v10; // [esp+38h] [ebp-20h]
  float v11; // [esp+3Ch] [ebp-1Ch]
  float v12; // [esp+3Ch] [ebp-1Ch]
  float v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+48h] [ebp-10h]
  float v18; // [esp+4Ch] [ebp-Ch]
  float v19; // [esp+4Ch] [ebp-Ch]

  v7 = -1;
  if ( *(int *)(*pm + 4) <= 5 )
  {
    v0 = pm;
    *(float *)(v0 + 244) = sqrt(*(float *)(*pm + 32) * *(float *)(*pm + 32) + *(float *)(*pm + 36)
                                                                            * *(float *)(*pm + 36));
    if ( (*(_DWORD *)(*pm + 132) & 0x106000) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 132) & 0x6000) != 0 )
      {
        if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396) )
        {
          v7 = BG_AnimScriptAnimation(*pm, 3, 3, 1);
        }
        else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1400) )
        {
          v7 = BG_AnimScriptAnimation(*pm, 3, 2, 1);
        }
      }
      if ( v7 < 0 )
      {
LABEL_9:
        BG_AnimScriptAnimation(*pm, 3, 1, 1);
        return;
      }
    }
    else
    {
      v14 = PM_GetEffectiveStance(*pm);
      if ( *(_DWORD *)(*pm + 88) != 1023 || *(_DWORD *)(*pm + 4) == 1 )
        goto LABEL_23;
      if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
      {
        if ( *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 104) < pm_ladderJumpTime )
          return;
        v4 = *(float *)(*pm + 40);
        v11 = 0.5 * 1.5 * 127.0;
        if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 68) != 0.0 )
          v18 = v4 / (v11 * *(float *)(*pm + 1412)) * 0.34999999;
        else
          v18 = v4 / (v11 * *(float *)(*pm + 1416)) * 0.44999999;
        if ( v4 < 0.0 )
          v7 = BG_AnimScriptAnimation(*pm, 3, 17, 1);
        else
          v7 = BG_AnimScriptAnimation(*pm, 3, 16, 1);
        v16 = *(_DWORD *)(*pm + 8);
        *(_DWORD *)(*pm + 8) = (unsigned __int8)(int)((long double)v16 + (long double)SLODWORD(pml[10]) * v18);
        PM_FootstepEvent(v16, *(_DWORD *)(*pm + 8), 1);
      }
      if ( v14 != (*(_DWORD *)(*pm + 12) & 3) )
      {
LABEL_23:
        v6 = *(_DWORD *)(*pm + 12) & 0x80;
        v5 = *(_DWORD *)(*pm + 12) & 0x10000;
        if ( *(float *)(pm + 244) < 10.0 || *(_DWORD *)(*pm + 4) == 1 )
        {
          if ( *(float *)(pm + 244) < 1.0 )
            *(_DWORD *)(*pm + 8) = 0;
          if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396) )
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 3, 1);
          }
          else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1400) )
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 2, 1);
          }
          if ( v7 < 0 )
            goto LABEL_9;
        }
        else
        {
          v12 = (float)*(int *)(*pm + 72);
          if ( *(_BYTE *)(pm + 24) )
          {
            if ( *(_BYTE *)(pm + 25) )
            {
              v12 = ((*(float *)(*pm + 1432) - 1.0) * 0.75 + 1.0 + 1.0) * 0.5 * v12;
              if ( *(char *)(pm + 24) < 0 )
                v12 = (*(float *)(*pm + 1436) + 1.0) * 0.5 * v12;
            }
            else if ( *(char *)(pm + 24) < 0 )
            {
              v12 = v12 * *(float *)(*pm + 1436);
            }
            BG_UpdateConditionValue(*(_DWORD *)(*pm + 212), 10, 0, 1);
          }
          else if ( *(_BYTE *)(pm + 25) )
          {
            v12 = ((*(float *)(*pm + 1432) - 1.0) * 0.75 + 1.0) * v12;
            if ( *(char *)(pm + 25) <= 0 )
              BG_UpdateConditionValue(*(_DWORD *)(*pm + 212), 10, 1, 1);
            else
              BG_UpdateConditionValue(*(_DWORD *)(*pm + 212), 10, 2, 1);
          }
          if ( v6 )
          {
            v13 = v12 * *(float *)(*pm + 1412);
          }
          else
          {
            if ( v5 )
              v1 = v12 * *(float *)(*pm + 1420);
            else
              v1 = v12 * *(float *)(*pm + 1416);
            v13 = v1;
          }
          v9 = sub_2706E(*(_DWORD *)(*pm + 1400), *(_DWORD *)(*pm + 1396));
          if ( v9 == 0.0 )
          {
            v10 = sub_2706E(*(_DWORD *)(*pm + 1396), *(_DWORD *)(*pm + 1400));
            if ( v10 == 0.0 )
            {
              if ( v14 == 1 )
              {
                v13 = v13 * *(float *)(*pm + 1424);
              }
              else if ( v14 == 2 )
              {
                v13 = v13 * *(float *)(*pm + 1428);
              }
            }
            else
            {
              v13 = (*(float *)(*pm + 1428) * v10 + (1.0 - v10) * *(float *)(*pm + 1424)) * v13;
            }
          }
          else
          {
            v13 = (*(float *)(*pm + 1424) * v9 + (1.0 - v9) * *(float *)(*pm + 1428)) * v13;
          }
          if ( v14 == 1 )
          {
            if ( v6 )
              v2 = 0.23999999;
            else
              v2 = 0.25;
            v19 = *(float *)(pm + 244) / v13 * v2;
            if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
              v8 = BG_AnimScriptAnimation(*pm, 3, 9, 1);
            else
              v8 = BG_AnimScriptAnimation(*pm, 3, 8, 1);
          }
          else if ( v14 == 2 )
          {
            if ( v6 )
              v3 = 0.315;
            else
              v3 = 0.34;
            v19 = *(float *)(pm + 244) / v13 * v3;
            if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
            {
              if ( v6 )
                v8 = BG_AnimScriptAnimation(*pm, 3, 7, 1);
              else
                v8 = BG_AnimScriptAnimation(*pm, 3, 13, 1);
            }
            else if ( v6 )
            {
              v8 = BG_AnimScriptAnimation(*pm, 3, 6, 1);
            }
            else
            {
              v8 = BG_AnimScriptAnimation(*pm, 3, 12, 1);
            }
          }
          else if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
          {
            if ( v6 )
            {
              v19 = *(float *)(pm + 244) / v13 * 0.32499999;
              v8 = BG_AnimScriptAnimation(*pm, 3, 5, 1);
            }
            else
            {
              v19 = *(float *)(pm + 244) / v13 * 0.36000001;
              v8 = BG_AnimScriptAnimation(*pm, 3, 11, 1);
            }
          }
          else if ( v6 )
          {
            v19 = *(float *)(pm + 244) / v13 * 0.30500001;
            v8 = BG_AnimScriptAnimation(*pm, 3, 4, 1);
          }
          else
          {
            v19 = *(float *)(pm + 244) / v13 * 0.33500001;
            v8 = BG_AnimScriptAnimation(*pm, 3, 10, 1);
          }
          v15 = PM_ShouldMakeFootsteps();
          v17 = *(_DWORD *)(*pm + 8);
          *(_DWORD *)(*pm + 8) = (unsigned __int8)(int)((long double)v17 + (long double)SLODWORD(pml[10]) * v19);
          if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
          {
            if ( v8 < 0 )
              BG_AnimScriptAnimation(*pm, 3, 1, 1);
            PM_FootstepEvent(v17, *(_DWORD *)(*pm + 8), v15);
          }
          else if ( *(float *)(pm + 244) <= 120.0 )
          {
            if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1396) )
            {
              v8 = BG_AnimScriptAnimation(*pm, 3, 3, 1);
            }
            else if ( *(_DWORD *)(*pm + 244) == *(_DWORD *)(*pm + 1400) )
            {
              v8 = BG_AnimScriptAnimation(*pm, 3, 2, 1);
            }
            if ( v8 < 0 )
              goto LABEL_9;
          }
        }
      }
    }
  }
}
// 16D24: using guessed type _DWORD __cdecl PM_FootstepEvent(char, char, _DWORD);
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// 18F44: using guessed type _DWORD __cdecl BG_AnimScriptAnimation(_DWORD, _DWORD, _DWORD, _DWORD);
// 194E4: using guessed type int PM_ShouldMakeFootsteps(void);

//----- (0002A550) --------------------------------------------------------
int sub_2A550()
{
  int result; // eax
  float v1[2]; // [esp+30h] [ebp-68h] BYREF
  float v2; // [esp+38h] [ebp-60h]
  float v3[4]; // [esp+40h] [ebp-58h] BYREF
  char v4[56]; // [esp+50h] [ebp-48h] BYREF
  int v5; // [esp+88h] [ebp-10h]
  float v6; // [esp+8Ch] [ebp-Ch]

  if ( (long double)bg_foliagesnd_minspeed[3] <= *(float *)(pm + 244) )
  {
    v6 = (*(float *)(pm + 244) - (long double)bg_foliagesnd_minspeed[3])
       / (long double)(bg_foliagesnd_maxspeed[3] - bg_foliagesnd_minspeed[3]);
    if ( v6 > 1.0 )
      v6 = 1.0;
    v5 = (int)((long double)(bg_foliagesnd_fastinterval[3] - bg_foliagesnd_slowinterval[3]) * v6
             + (long double)bg_foliagesnd_slowinterval[3]);
    result = pm;
    if ( v5 + *(_DWORD *)(*pm + 56) < *(_DWORD *)(pm + 4) )
    {
      v3[0] = *(float *)(pm + 216) * 0.75;
      v3[1] = *(float *)(pm + 220) * 0.75;
      v3[2] = *(float *)(pm + 224) * 0.75;
      v1[0] = *(float *)(pm + 228) * 0.75;
      v1[1] = *(float *)(pm + 232) * 0.75;
      v2 = *(float *)(pm + 236) * 0.75;
      v2 = *(float *)(pm + 236) * 0.89999998;
      result = PM_trace(v4, *pm + 20, v3, v1, *pm + 20, *(_DWORD *)(*pm + 212), 2);
      if ( v4[47] )
      {
        PM_AddEvent(139);
        result = *(_DWORD *)(pm + 4);
        *(_DWORD *)(*pm + 56) = result;
      }
    }
  }
  else
  {
    result = pm;
    if ( bg_foliagesnd_resetinterval[3] + *(_DWORD *)(*pm + 56) < *(_DWORD *)(pm + 4) )
    {
      result = *pm;
      *(_DWORD *)(*pm + 56) = 0;
    }
  }
  return result;
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (0002A7B9) --------------------------------------------------------
float *sub_2A7B9()
{
  float *result; // eax

  if ( !LODWORD(pml[33]) && *(_BYTE *)(pm + 241) )
    PM_AddEvent(146);
  result = pml;
  if ( LODWORD(pml[33]) )
  {
    result = (float *)pm;
    if ( !*(_BYTE *)(pm + 241) )
      result = (float *)PM_AddEvent(147);
  }
  return result;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (0002A829) --------------------------------------------------------
int sub_2A829()
{
  int result; // eax

  if ( *(_DWORD *)(*pm + 16) )
  {
    if ( SLODWORD(pml[10]) < *(_DWORD *)(*pm + 16) )
    {
      *(_DWORD *)(*pm + 16) -= LODWORD(pml[10]);
    }
    else
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDCFF;
      *(_DWORD *)(*pm + 16) = 0;
    }
  }
  if ( *(int *)(*pm + 112) > 0 )
  {
    *(_DWORD *)(*pm + 112) -= LODWORD(pml[10]);
    if ( *(int *)(*pm + 112) < 0 )
      *(_DWORD *)(*pm + 112) = 0;
  }
  result = *pm;
  if ( *(int *)(*pm + 120) > 0 )
  {
    *(_DWORD *)(*pm + 120) -= LODWORD(pml[10]);
    result = *pm;
    if ( *(int *)(*pm + 120) < 0 )
    {
      result = *pm;
      *(_DWORD *)(*pm + 120) = 0;
    }
  }
  return result;
}

//----- (0002A968) --------------------------------------------------------
int PM_PlayFatigueSound()
{
  int result; // eax

  if ( (*(_DWORD *)(*pm + 12) & 0x20000) != 0 )
  {
    result = pm;
    if ( *(_DWORD *)(*pm + 60) + 1700 < *(_DWORD *)(pm + 4) )
    {
      PM_AddEvent(140);
      result = *(_DWORD *)(pm + 4);
      *(_DWORD *)(*pm + 60) = result;
    }
  }
  else
  {
    result = *pm;
    if ( *(int *)(*pm + 60) > 0 )
    {
      result = pm;
      if ( *(_DWORD *)(*pm + 60) + 1700 < *(_DWORD *)(pm + 4) )
      {
        result = *pm;
        *(_DWORD *)(*pm + 60) = 0;
      }
    }
  }
  return result;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (0002AA22) --------------------------------------------------------
void PM_UpdateFatigue()
{
  if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
  {
    if ( *(_DWORD *)(*pm + 4) != 2 && !bg_nofatigue[3] )
    {
      *(_DWORD *)(*pm + 1460) = *(_DWORD *)(pm + 4);
      *(float *)(*pm + 1456) = *(float *)(*pm + 1456) - (long double)SLODWORD(pml[10]) * 0.001 * 0.33333334;
      if ( *(float *)(*pm + 1456) < 0.5 )
      {
        PM_AddEvent(140);
        *(_DWORD *)(*pm + 12) |= 0x20000u;
      }
      if ( *(float *)(*pm + 1456) < 0.0 )
        *(_DWORD *)(*pm + 1456) = 0;
    }
  }
  else
  {
    if ( (*(_BYTE *)(pm + 8) & 8) == 0 )
    {
      if ( *(_DWORD *)(pm + 4) < *(_DWORD *)(*pm + 1460) + pm_fatigueRegenDelay )
        return;
      *(float *)(*pm + 1456) = (long double)SLODWORD(pml[10]) * 0.001 * 0.14285715 + *(float *)(*pm + 1456);
      if ( *(float *)(*pm + 1456) >= 1.0 )
      {
        *(_DWORD *)(*pm + 1456) = 1065353216;
        if ( (*(_DWORD *)(*pm + 12) & 0x20000) != 0 )
          *(_DWORD *)(*pm + 12) &= 0xFFFDFFFF;
      }
    }
    PM_PlayFatigueSound();
  }
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 17D94: using guessed type int PM_PlayFatigueSound(void);

//----- (0002AC45) --------------------------------------------------------
void __cdecl PM_UpdateLean(int a1, int a2, void (__cdecl *a3)(float *, int *, int *, int *, int *, _DWORD, int))
{
  long double v3; // fst7
  float v4; // [esp+34h] [ebp-94h]
  float v5; // [esp+34h] [ebp-94h]
  float v6; // [esp+3Ch] [ebp-8Ch]
  float v7[14]; // [esp+40h] [ebp-88h] BYREF
  float v8; // [esp+78h] [ebp-50h]
  int v9; // [esp+7Ch] [ebp-4Ch]
  int v10[4]; // [esp+80h] [ebp-48h] BYREF
  int v11[4]; // [esp+90h] [ebp-38h] BYREF
  int v12[4]; // [esp+A0h] [ebp-28h] BYREF
  int v13; // [esp+B0h] [ebp-18h] BYREF
  int v14; // [esp+B4h] [ebp-14h]
  float v15; // [esp+B8h] [ebp-10h]

  v9 = 0;
  v8 = 0.0;
  if ( (*(_BYTE *)(a2 + 5) & 0x30) != 0
    && (*(_DWORD *)(a1 + 12) & 0x4000) == 0
    && *(int *)(a1 + 4) <= 5
    && (*(_DWORD *)(a1 + 88) != 1023 || *(_DWORD *)(a1 + 4) == 1) )
  {
    if ( (*(_BYTE *)(a2 + 5) & 0x10) != 0 )
      --v9;
    if ( (*(_BYTE *)(a2 + 5) & 0x20) != 0 )
      ++v9;
  }
  if ( (*(_DWORD *)(a1 + 132) & 0x106000) != 0
    || (*(_DWORD *)(a1 + 12) & 0x20) != 0 && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 216)) + 128) == 3 )
  {
    v9 = 0;
  }
  if ( PM_GetEffectiveStance(a1) == 1 )
    v6 = 0.25;
  else
    v6 = 0.5;
  v8 = *(float *)(a1 + 68);
  if ( v9 )
  {
    if ( v9 <= 0 )
    {
      if ( v8 > -v6 )
        v8 = v8 - (long double)SLODWORD(pml[10]) / 350.0 * v6;
      if ( -v6 > (long double)v8 )
        LODWORD(v8) = LODWORD(v6) ^ 0x80000000;
    }
    else
    {
      if ( v6 > (long double)v8 )
        v8 = (long double)SLODWORD(pml[10]) / 350.0 * v6 + v8;
      if ( v8 > (long double)v6 )
        v8 = v6;
    }
  }
  else if ( v8 <= 0.0 )
  {
    if ( v8 < 0.0 )
    {
      v8 = (long double)SLODWORD(pml[10]) / 280.0 * v6 + v8;
      if ( v8 > 0.0 )
        v8 = 0.0;
    }
  }
  else
  {
    v8 = v8 - (long double)SLODWORD(pml[10]) / 280.0 * v6;
    if ( v8 < 0.0 )
      v8 = 0.0;
  }
  *(float *)(a1 + 68) = v8;
  if ( *(float *)(a1 + 68) != 0.0 )
  {
    v4 = (float)sub_2E35B(*(float *)(a1 + 68));
    v13 = *(_DWORD *)(a1 + 20);
    v14 = *(_DWORD *)(a1 + 24);
    v15 = *(float *)(a1 + 28);
    v3 = v15 + *(float *)(a1 + 248);
    v15 = v3;
    v12[0] = v13;
    v12[1] = v14;
    *(float *)&v12[2] = v15;
    AddLeanToPosition((int)v12, *(_DWORD *)(a1 + 236), v4, 16.0, 20.0);
    v11[0] = -1056964608;
    v11[1] = -1056964608;
    v11[2] = -1056964608;
    v10[0] = 1090519040;
    v10[1] = 1090519040;
    v10[2] = 1090519040;
    a3(v7, &v13, v11, v10, v12, *(_DWORD *)(a1 + 212), 42008593);
    UnGetLeanFraction(v7[0]);
    v5 = v3;
    if ( fabs(*(float *)(a1 + 68)) > v5 )
      *(float *)(a1 + 68) = (long double)sub_2E35B(*(float *)(a1 + 68)) * v5;
  }
}
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002B031) --------------------------------------------------------
int __usercall sub_2B031@<eax>(long double a1@<st0>, int a2, float a3, int a4)
{
  long double v4; // fst7
  float v6; // [esp+0h] [ebp-58h]
  float v7; // [esp+40h] [ebp-18h]
  float v8; // [esp+44h] [ebp-14h]
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+4Ch] [ebp-Ch]
  float v11; // [esp+50h] [ebp-8h]

  AngleDelta(a3, *(float *)(a2 + 236));
  v11 = a1;
  v7 = fabs(v11);
  v9 = v7 / 240.0;
  v4 = a3 - (1.0 - v9) * v11;
  v6 = v4;
  AngleNormalize360Accurate(v6);
  v10 = v4;
  v8 = v9 * 45.0 + (1.0 - v9) * 60.0;
  return BG_CheckProne(
           *(_DWORD *)(a2 + 212),
           a2 + 20,
           *(_DWORD *)(a2 + 1384),
           1106247680,
           v10,
           a2 + 1544,
           a2 + 1548,
           a2 + 1552,
           1,
           *(_DWORD *)(a2 + 88) != 1023,
           0,
           a4,
           0,
           0,
           v8,
           0);
}

//----- (0002B15C) --------------------------------------------------------
int __usercall PM_UpdateViewAngles@<eax>(long double a1@<st0>, int a2, int a3, int a4)
{
  int result; // eax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  float v12; // [esp+0h] [ebp-E8h]
  float v13; // [esp+0h] [ebp-E8h]
  float v14; // [esp+0h] [ebp-E8h]
  float v15; // [esp+0h] [ebp-E8h]
  float v16; // [esp+0h] [ebp-E8h]
  float v17; // [esp+0h] [ebp-E8h]
  float v18; // [esp+0h] [ebp-E8h]
  float v19; // [esp+0h] [ebp-E8h]
  float v20; // [esp+8h] [ebp-E0h]
  float v21; // [esp+Ch] [ebp-DCh]
  float v22[4]; // [esp+60h] [ebp-88h] BYREF
  float v23[4]; // [esp+70h] [ebp-78h] BYREF
  int v24; // [esp+80h] [ebp-68h] BYREF
  float v25; // [esp+84h] [ebp-64h]
  float v26; // [esp+88h] [ebp-60h]
  float v27; // [esp+98h] [ebp-50h]
  int v28; // [esp+9Ch] [ebp-4Ch]
  float v29; // [esp+A0h] [ebp-48h]
  float v30; // [esp+A4h] [ebp-44h]
  float v31; // [esp+A8h] [ebp-40h]
  int v32; // [esp+ACh] [ebp-3Ch]
  float v33; // [esp+B0h] [ebp-38h]
  float v34; // [esp+B4h] [ebp-34h]
  _BOOL4 v35; // [esp+B8h] [ebp-30h]
  int v36; // [esp+BCh] [ebp-2Ch]
  float v37; // [esp+C0h] [ebp-28h]
  float v38; // [esp+C4h] [ebp-24h]
  int i; // [esp+C8h] [ebp-20h]
  __int16 v40; // [esp+CEh] [ebp-1Ah]

  result = a2;
  if ( *(_DWORD *)(a2 + 4) != 5 )
  {
    if ( *(int *)(a2 + 4) <= 5 )
    {
      v34 = *(float *)(a2 + 236);
      for ( i = 0; i <= 2; ++i )
      {
        v40 = *(_WORD *)(a2 + 4 * i + 76) + *(_WORD *)(a3 + 4 * i + 8);
        if ( !i )
        {
          v28 = 16000;
          if ( (*(_DWORD *)(a2 + 132) & 0x100000) != 0 )
            v28 = 12000;
          if ( v40 <= v28 )
          {
            if ( v40 < -v28 )
            {
              *(_DWORD *)(a2 + 4 * i + 76) = -v28 - *(_DWORD *)(a3 + 4 * i + 8);
              v40 = -(__int16)v28;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 4 * i + 76) = v28 - *(_DWORD *)(a3 + 4 * i + 8);
            v40 = v28;
          }
        }
        a1 = (long double)v40 * 0.0054931641;
        *(float *)(a2 + 4 * i + 232) = a1;
      }
      v33 = *(float *)(a2 + 236);
      if ( (*(_DWORD *)(a2 + 132) & 0x100000) != 0 )
      {
        if ( pm )
        {
          a1 = 0.0;
          if ( *(float *)(pm + 72) != 0.0
            || (a1 = vec3_origin[1], *(float *)(pm + 76) != a1)
            || (a1 = vec3_origin[2], *(float *)(pm + 80) != a1) )
          {
            for ( i = 0; i <= 2; ++i )
            {
              a1 = fabs(*(float *)(pm + 4 * i + 72));
              if ( a1 >= 1.0 )
              {
                AngleDelta(*(float *)(pm + 4 * i + 60), *(float *)(a2 + 4 * i + 232));
                v38 = a1;
                a1 = fabs(*(float *)(pm + 4 * i + 72));
                if ( fabs(v38) > a1 )
                {
                  if ( v38 <= (long double)*(float *)(pm + 4 * i + 72) )
                    v38 = v38 + *(float *)(pm + 4 * i + 72);
                  else
                    v38 = v38 - *(float *)(pm + 4 * i + 72);
                  *(_DWORD *)(a2 + 4 * i + 76) += (unsigned __int16)(int)(v38 * 182.04445);
                  if ( v38 <= 0.0 )
                    a1 = *(float *)(pm + 4 * i + 60) + *(float *)(pm + 4 * i + 72);
                  else
                    a1 = *(float *)(pm + 4 * i + 60) - *(float *)(pm + 4 * i + 72);
                  v12 = a1;
                  AngleNormalize360Accurate(v12);
                  *(float *)(a2 + 4 * i + 232) = a1;
                }
              }
            }
          }
        }
      }
      else if ( (*(_DWORD *)(a2 + 12) & 0x10) != 0 && *(_DWORD *)(a2 + 88) == 1023 )
      {
        if ( bg_ladder_yawcap[3] )
        {
          v27 = vectoyaw(a2 + 92) + 180.0;
          AngleDelta(v27, *(float *)(a2 + 236));
          v38 = v27;
          if ( v27 > (long double)bg_ladder_yawcap[3] || (a1 = v38, (long double)-bg_ladder_yawcap[3] > v38) )
          {
            if ( v38 <= (long double)bg_ladder_yawcap[3] )
              v38 = (long double)bg_ladder_yawcap[3] + v38;
            else
              v38 = v38 - (long double)bg_ladder_yawcap[3];
            *(_DWORD *)(a2 + 80) += (unsigned __int16)(int)(v38 * 182.04445);
            if ( v38 <= 0.0 )
              a1 = (long double)bg_ladder_yawcap[3] + v27;
            else
              a1 = v27 - (long double)bg_ladder_yawcap[3];
            v13 = a1;
            AngleNormalize360Accurate(v13);
            *(float *)(a2 + 236) = a1;
          }
        }
      }
      if ( (*(_DWORD *)(a2 + 132) & 0x106000) == 0
        && ((*(_DWORD *)(a2 + 12) & 1) != 0
         || (*(_DWORD *)(a2 + 12) & 0x20) != 0 && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a2 + 216)) + 128) == 3) )
      {
        if ( g_debugProneCheck[3] )
        {
          v24 = *(int *)(a2 + 20);
          v25 = *(float *)(a2 + 24);
          v26 = *(float *)(a2 + 28);
          v26 = (long double)*(int *)(a2 + 1396) + v26;
          AngleVectors(a2 + 232, v22, 0, 0);
          v23[0] = v22[0] * 18.0 + *(float *)&v24;
          v23[1] = v22[1] * 18.0 + v25;
          v23[2] = v22[2] * 18.0 + v26;
          G_DebugLine(&v24, v23, &colorWhite, 1, 1);
          v21 = *(float *)(a2 + 1444) + bg_prone_yawcap[2];
          a1 = *(float *)(a2 + 1444) - bg_prone_yawcap[2];
          v20 = a1;
          G_DebugArc((int)&v24, 16.0, v20, v21, (int)&colorWhite, 1, 1);
        }
        v32 = 0;
        AngleDelta(*(float *)(a2 + 1444), *(float *)(a2 + 236));
        v38 = a1;
        v5 = (long double)SLODWORD(bg_prone_yawcap[3]);
        v29 = v5;
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a2 + 216)) + 128) == 3 )
        {
          v5 = (long double)bg_lmg_yawcap[3];
          v29 = v5;
        }
        if ( (*(_DWORD *)(a2 + 12) & 1) != 0
          && (*(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a2 + 216)) + 128) != 3 || (*(_DWORD *)(a2 + 12) & 0x20) == 0) )
        {
          if ( v38 > v29 - 5.0
            || (v5 = v38, -(v29 - 5.0) > v38)
            || (*(_BYTE *)(a3 + 20) || *(_BYTE *)(a3 + 21)) && (v5 = 0.0, v38 != 0.0) )
          {
            v5 = fabs(v38);
            if ( pml[9] * 55.0 <= v5 )
            {
              if ( v38 <= 0.0 )
                v5 = pml[9] * 55.0 + *(float *)(a2 + 1444);
              else
                v5 = *(float *)(a2 + 1444) - pml[9] * 55.0;
              v37 = v5;
            }
            else
            {
              v37 = *(float *)(a2 + 236);
            }
            v35 = 1;
            while ( !sub_2B031(v5, a2, v37, a4) )
            {
              if ( !v35 )
                goto LABEL_81;
              AngleDelta(*(float *)(a2 + 1444), v37);
              v38 = v5;
              v6 = fabs(v38);
              v35 = v6 > 1.0;
              if ( v6 <= 1.0 )
              {
                v32 = 1;
              }
              else if ( v38 <= 0.0 )
              {
                v38 = -1.0;
              }
              else
              {
                v38 = 1.0;
              }
              v5 = v37 + v38;
              v14 = v5;
              AngleNormalize360Accurate(v14);
              v37 = v5;
            }
            v36 = BG_CheckProne(
                    *(_DWORD *)(a2 + 212),
                    a2 + 20,
                    *(_DWORD *)(a2 + 1384),
                    1106247680,
                    *(float *)(a2 + 236),
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a2 + 88) != 1023,
                    0,
                    a4,
                    0,
                    0,
                    45.0,
                    0);
            if ( v36 )
            {
              v36 = BG_CheckProne(
                      *(_DWORD *)(a2 + 212),
                      a2 + 20,
                      *(_DWORD *)(a2 + 1384),
                      1106247680,
                      v37,
                      0,
                      0,
                      0,
                      1,
                      *(_DWORD *)(a2 + 88) != 1023,
                      0,
                      a4,
                      0,
                      0,
                      45.0,
                      0);
              if ( v36 )
                *(float *)(a2 + 1444) = v37;
            }
            if ( !v36 )
              v32 = 1;
          }
        }
LABEL_81:
        AngleDelta(*(float *)(a2 + 1444), *(float *)(a2 + 236));
        v38 = v5;
        v7 = 0.0;
        if ( v38 != 0.0
          && (*(_DWORD *)(a2 + 12) & 1) != 0
          && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a2 + 216)) + 128) != 3 )
        {
          v37 = *(float *)(a2 + 1444);
          v35 = 1;
          while ( 1 )
          {
            v36 = BG_CheckProne(
                    *(_DWORD *)(a2 + 212),
                    a2 + 20,
                    *(_DWORD *)(a2 + 1384),
                    1106247680,
                    v37,
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a2 + 88) != 1023,
                    0,
                    a4,
                    0,
                    0,
                    45.0,
                    0);
            if ( v36 )
            {
              if ( sub_2B031(v7, a2, v37, a4) )
                break;
            }
            if ( !v35 )
              goto LABEL_95;
            v8 = fabs(v38);
            v35 = v8 > 1.0;
            if ( v8 > 1.0 )
            {
              if ( v38 <= 0.0 )
                v38 = -1.0;
              else
                v38 = 1.0;
            }
            v32 = 1;
            *(_DWORD *)(a2 + 80) += (unsigned __int16)(int)(v38 * 182.04445);
            v7 = *(float *)(a2 + 236) + v38;
            v15 = v7;
            AngleNormalize360Accurate(v15);
            *(float *)(a2 + 236) = v7;
            AngleDelta(*(float *)(a2 + 1444), *(float *)(a2 + 236));
            v38 = v7;
            if ( !v36 )
            {
              v7 = v37 + v38;
              v16 = v7;
              AngleNormalize360Accurate(v16);
              v37 = v7;
            }
          }
          *(float *)(a2 + 1444) = v37;
        }
LABEL_95:
        if ( v38 > (long double)v29 || (v9 = v38, -v29 > (long double)v38) )
        {
          if ( v38 <= (long double)v29 )
            v38 = v38 + v29;
          else
            v38 = v38 - v29;
          *(_DWORD *)(a2 + 80) += (unsigned __int16)(int)(v38 * 182.04445);
          if ( v38 <= 0.0 )
            v9 = *(float *)(a2 + 1444) + v29;
          else
            v9 = *(float *)(a2 + 1444) - v29;
          v17 = v9;
          AngleNormalize360Accurate(v17);
          *(float *)(a2 + 236) = v9;
        }
        if ( v32 )
        {
          *(_DWORD *)(a2 + 12) |= 0x8000u;
          AngleDelta(v34, *(float *)(a2 + 236));
          v31 = v9;
          v9 = fabs(v31);
          if ( v9 <= 1.0 )
          {
            AngleDelta(v33, *(float *)(a2 + 236));
            v30 = v9;
            v9 = 0.0;
            if ( v31 * v30 > 0.0 )
            {
              v31 = v31 * 0.98000002;
              v10 = *(float *)(a2 + 236) + v31;
              v18 = v10;
              AngleNormalize360Accurate(v18);
              *(float *)(a2 + 236) = v10;
              v9 = v31 * 182.04445;
              *(_DWORD *)(a2 + 80) += (unsigned __int16)(int)v9;
            }
          }
        }
        AngleDelta(*(float *)(a2 + 1452), *(float *)(a2 + 232));
        v38 = v9;
        if ( v38 > 45.0 || v38 < -45.0 )
        {
          if ( v38 <= 45.0 )
            v38 = v38 + 45.0;
          else
            v38 = v38 - 45.0;
          *(_DWORD *)(a2 + 76) += (unsigned __int16)(int)(v38 * 182.04445);
          if ( v38 <= 0.0 )
            v11 = *(float *)(a2 + 1452) + 45.0;
          else
            v11 = *(float *)(a2 + 1452) - 45.0;
          v19 = v11;
          AngleNormalize180Accurate(v19);
          *(float *)(a2 + 232) = v11;
        }
      }
      result = a2;
      if ( *(_DWORD *)(a2 + 4) != 3 )
      {
        result = a2;
        if ( *(_DWORD *)(a2 + 4) != 2 )
        {
          result = a2;
          if ( *(_DWORD *)(a2 + 4) != 4 )
            result = PM_UpdateLean(a2, a3, a4);
        }
      }
    }
    else
    {
      v40 = *(_WORD *)(a2 + 80) + *(_WORD *)(a3 + 12);
      if ( *(_DWORD *)(a2 + 288) == 999 )
        *(_DWORD *)(a2 + 288) = (int)((long double)v40 * 0.0054931641);
      result = PM_UpdateLean(a2, a3, a4);
    }
  }
  return result;
}
// 168D4: using guessed type long double __cdecl vectoyaw(_DWORD);
// 16F74: using guessed type _DWORD __cdecl PM_UpdateLean(_DWORD, _DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002C158) --------------------------------------------------------
void __usercall PM_UpdatePronePitch(long double a1@<st0>)
{
  int bProneOK; // eax
  long double v2; // fst7
  int v3; // esi
  int v4; // edi
  int v5; // esi
  int v6; // esi
  int v7; // edi
  long double v8; // fst7
  int v9; // esi
  int v10; // [esp+2Ch] [ebp-3Ch]
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+3Ch] [ebp-2Ch]
  float v13; // [esp+54h] [ebp-14h]
  float v14; // [esp+54h] [ebp-14h]
  float v15; // [esp+58h] [ebp-10h]
  float v16; // [esp+58h] [ebp-10h]

  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    if ( *(_DWORD *)(*pm + 88) == 1023 )
    {
      v12 = *(_DWORD *)(pm + 276);
      v11 = *(_DWORD *)(pm + 264);
      v10 = *(_DWORD *)(pm + 268);
      if ( LODWORD(pml[12]) )
        bProneOK = BG_CheckProne(
                     *(_DWORD *)(*pm + 212),
                     *pm + 20,
                     *(_DWORD *)(*pm + 1384),
                     1106247680,
                     *(float *)(*pm + 1444),
                     *pm + 1544,
                     *pm + 1548,
                     *pm + 1552,
                     1,
                     *(_DWORD *)(*pm + 88) != 1023,
                     (int)&pml[18],
                     v10,
                     v11,
                     0,
                     60.0,
                     v12);
      else
        bProneOK = BG_CheckProne(
                     *(_DWORD *)(*pm + 212),
                     *pm + 20,
                     *(_DWORD *)(*pm + 1384),
                     1106247680,
                     *(float *)(*pm + 1444),
                     *pm + 1544,
                     *pm + 1548,
                     *pm + 1552,
                     1,
                     *(_DWORD *)(*pm + 88) != 1023,
                     0,
                     v10,
                     v11,
                     0,
                     60.0,
                     v12);
      if ( !bProneOK || *(_BYTE *)(pm + 241) )
      {
        BG_AddPredictableEventToPlayerstate(143, 0, *pm);
        *(_DWORD *)(*pm + 12) |= 0x8000u;
      }
    }
    else if ( LODWORD(pml[12]) )
    {
      a1 = pml[20];
      if ( a1 < 0.69999999 )
        BG_AddPredictableEventToPlayerstate(143, 0, *pm);
    }
    if ( LODWORD(pml[12]) )
    {
      PitchForYawOnNormal(*(float *)(*pm + 1444), (int)&pml[18]);
      v15 = a1;
      AngleDelta(v15, *(float *)(*pm + 1448));
    }
    else
    {
      AngleDelta(0.0, *(float *)(*pm + 1448));
    }
    v13 = a1;
    v2 = 0.0;
    if ( v13 != 0.0 )
    {
      sub_2E342(v13);
      if ( pml[9] * 70.0 >= 0.0 )
      {
        v2 = *(float *)(*pm + 1448) + v13;
        *(float *)(*pm + 1448) = v2;
      }
      else
      {
        v3 = *pm;
        v4 = *pm;
        v2 = (long double)sub_2E35B(v13) * (pml[9] * 70.0) + *(float *)(v4 + 1448);
        *(float *)(v3 + 1448) = v2;
      }
      v5 = *pm;
      AngleNormalize180Accurate(*(float *)(*pm + 1448));
      *(float *)(v5 + 1448) = v2;
    }
    if ( LODWORD(pml[12]) )
    {
      PitchForYawOnNormal(*(float *)(*pm + 236), (int)&pml[18]);
      v16 = v2;
      AngleDelta(v16, *(float *)(*pm + 1452));
    }
    else
    {
      AngleDelta(0.0, *(float *)(*pm + 1452));
    }
    v14 = v2;
    if ( v14 != 0.0 )
    {
      sub_2E342(v14);
      if ( pml[9] * 70.0 >= 0.0 )
      {
        v8 = *(float *)(*pm + 1452) + v14;
        *(float *)(*pm + 1452) = v8;
      }
      else
      {
        v6 = *pm;
        v7 = *pm;
        v8 = (long double)sub_2E35B(v14) * (pml[9] * 70.0) + *(float *)(v7 + 1452);
        *(float *)(v6 + 1452) = v8;
      }
      v9 = *pm;
      AngleNormalize180Accurate(*(float *)(*pm + 1452));
      *(float *)(v9 + 1452) = v8;
    }
  }
}
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (0002C5DD) --------------------------------------------------------
int PM_SetProneMovementOverride()
{
  int result; // eax

  result = *(_DWORD *)(*pm + 12) & 1;
  if ( result )
  {
    result = *(_DWORD *)(*pm + 12) | 0x400;
    *(_DWORD *)(*pm + 12) = result;
  }
  return result;
}

//----- (0002C622) --------------------------------------------------------
char PM_UpdatePlayerWalkingFlag()
{
  int v0; // eax

  *(_DWORD *)(*pm + 12) &= 0xFFFFFF7F;
  v0 = *pm;
  if ( *(int *)(*pm + 4) <= 5 )
  {
    LOBYTE(v0) = *(_BYTE *)(pm + 8) & 0x10;
    if ( (_BYTE)v0 )
    {
      v0 = *(_DWORD *)(*pm + 12) & 1;
      if ( !v0 )
      {
        v0 = *(_DWORD *)(*pm + 12) & 0x20;
        if ( v0 )
        {
          v0 = *(_DWORD *)(*pm + 132) & 0x100000;
          if ( !v0 )
          {
            v0 = *pm;
            if ( *(_DWORD *)(*pm + 220) != 5 )
            {
              v0 = *pm;
              if ( *(_DWORD *)(*pm + 220) != 7 )
              {
                v0 = *pm;
                if ( *(_DWORD *)(*pm + 220) != 9 )
                {
                  v0 = *pm;
                  if ( *(_DWORD *)(*pm + 220) != 8 )
                  {
                    v0 = *pm;
                    if ( *(_DWORD *)(*pm + 220) != 6 )
                    {
                      v0 = *(_DWORD *)(*pm + 12) | 0x80;
                      *(_DWORD *)(*pm + 12) = v0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v0;
}

//----- (0002C74A) --------------------------------------------------------
void PM_UpdatePlayerSprintingFlag()
{
  int v0; // [esp+10h] [ebp-8h]

  v0 = *(_DWORD *)(*pm + 12) & 0x10000;
  *(_DWORD *)(*pm + 12) &= 0xFFFEFFFF;
  if ( *(int *)(*pm + 4) <= 3
    && (*(_BYTE *)(pm + 8) & 8) != 0
    && *(float *)(*pm + 1456) > 0.0
    && (v0 || *(float *)(*pm + 1456) > 0.25)
    && (*(_DWORD *)(*pm + 12) & 3) == 0
    && (*(_DWORD *)(*pm + 12) & 0x20) == 0
    && (v0 || *(_DWORD *)(*pm + 88) != 1023)
    && (*(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25))
    && (*(_DWORD *)(*pm + 132) & 0x106000) == 0
    && *(_DWORD *)(*pm + 220) != 13
    && (*(_DWORD *)(LODWORD(pml[34]) + 124) != 1
     || !*(_DWORD *)(LODWORD(pml[34]) + 824)
     || *(_DWORD *)(*pm + 52) >= *(_DWORD *)(LODWORD(pml[34]) + 616)
     || !*(_DWORD *)(*pm + 52)
     || !Com_BitCheck(*pm + 1332, *(_DWORD *)(*pm + 216)))
    && (*(_DWORD *)(LODWORD(pml[34]) + 124) != 1 || (*(_BYTE *)(pm + 8) & 1) == 0 && *(_DWORD *)(*pm + 220) != 3)
    && (*(_DWORD *)(*pm + 12) & 0x10) == 0 )
  {
    *(_DWORD *)(*pm + 12) |= 0x10000u;
  }
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);

//----- (0002C9A6) --------------------------------------------------------
void sub_2C9A6()
{
  int v0; // [esp+20h] [ebp-88h]
  int v1; // [esp+28h] [ebp-80h]
  float v2; // [esp+2Ch] [ebp-7Ch]
  float v3[7]; // [esp+30h] [ebp-78h] BYREF
  int v4; // [esp+4Ch] [ebp-5Ch]
  float v5; // [esp+60h] [ebp-48h] BYREF
  float v6; // [esp+64h] [ebp-44h]
  float v7; // [esp+68h] [ebp-40h]
  float v8; // [esp+70h] [ebp-38h] BYREF
  float v9; // [esp+74h] [ebp-34h]
  float v10; // [esp+78h] [ebp-30h]
  float v11; // [esp+80h] [ebp-28h] BYREF
  float v12; // [esp+84h] [ebp-24h]
  float v13; // [esp+88h] [ebp-20h]
  float v14; // [esp+90h] [ebp-18h] BYREF
  float v15; // [esp+94h] [ebp-14h]
  float v16; // [esp+98h] [ebp-10h]

  if ( !*(_DWORD *)(*pm + 16) || (*(_DWORD *)(*pm + 12) & 0x300) == 0 )
  {
    if ( LODWORD(pml[11]) )
      v2 = 8.0;
    else
      v2 = 30.0;
    v1 = (*(_DWORD *)(*pm + 12) >> 4) & 1;
    v0 = 0;
    if ( v1 && *(_DWORD *)(*pm + 88) == 1023 )
      v0 = 1;
    if ( v0 )
    {
      LODWORD(v11) = *(_DWORD *)(*pm + 92) ^ 0x80000000;
      LODWORD(v12) = *(_DWORD *)(*pm + 96) ^ 0x80000000;
      LODWORD(v13) = *(_DWORD *)(*pm + 100) ^ 0x80000000;
    }
    else
    {
      v11 = pml[0];
      v12 = pml[1];
      v13 = 0.0;
      VectorNormalize(&v11);
    }
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
    if ( *(int *)(*pm + 4) > 5 )
    {
      *(_DWORD *)(*pm + 88) = 1023;
      pml[12] = 0.0;
      pml[13] = 0.0;
      pml[11] = 0.0;
      return;
    }
    if ( PM_GetEffectiveStance(*pm) != 1 && *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 104) >= pm_ladderJumpTime )
    {
      v8 = *(float *)(pm + 216);
      v9 = *(float *)(pm + 220);
      v8 = v8 + 6.0;
      v9 = v9 + 6.0;
      v10 = 8.0;
      v5 = *(float *)(pm + 228);
      v6 = *(float *)(pm + 232);
      v7 = *(float *)(pm + 236);
      v5 = v5 - 6.0;
      v6 = v6 - 6.0;
      if ( v7 < 8.0 )
        v7 = v10;
      v14 = v11 * v2 + *(float *)(*pm + 20);
      v15 = v12 * v2 + *(float *)(*pm + 24);
      v16 = v13 * v2 + *(float *)(*pm + 28);
      PM_trace(v3, *pm + 20, &v8, &v5, &v14, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
      if ( v3[0] < 1.0 && (v4 & 8) != 0 && (!LODWORD(pml[11]) || *(char *)(pm + 24) > 0) )
      {
        *(float *)(*pm + 92) = v3[4];
        *(float *)(*pm + 96) = v3[5];
        *(float *)(*pm + 100) = v3[6];
        if ( v1 )
        {
          *(_DWORD *)(*pm + 12) |= 0x10u;
          return;
        }
        LODWORD(v11) = *(_DWORD *)(*pm + 92) ^ 0x80000000;
        LODWORD(v12) = *(_DWORD *)(*pm + 96) ^ 0x80000000;
        LODWORD(v13) = *(_DWORD *)(*pm + 100) ^ 0x80000000;
        v14 = v11 * v2 + *(float *)(*pm + 20);
        v15 = v12 * v2 + *(float *)(*pm + 24);
        v16 = v13 * v2 + *(float *)(*pm + 28);
        PM_trace(v3, *pm + 20, &v8, &v5, &v14, *(_DWORD *)(*pm + 212), *(_DWORD *)(pm + 52));
        if ( v3[0] < 1.0 && (v4 & 8) != 0 )
        {
          *(_DWORD *)(*pm + 12) |= 0x10u;
          return;
        }
      }
      if ( v0 )
        BG_AnimScriptEvent(*pm, 3, 0, 1);
    }
  }
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002CEBC) --------------------------------------------------------
int PM_LadderMove()
{
  int result; // eax
  long double v1; // fst7
  int v2; // [esp+2Ch] [ebp-6Ch]
  int v3; // [esp+34h] [ebp-64h]
  float v4; // [esp+38h] [ebp-60h]
  float v5; // [esp+3Ch] [ebp-5Ch]
  float v6; // [esp+3Ch] [ebp-5Ch]
  float v7; // [esp+3Ch] [ebp-5Ch]
  float v8; // [esp+3Ch] [ebp-5Ch]
  float v9; // [esp+40h] [ebp-58h] BYREF
  float v10; // [esp+44h] [ebp-54h]
  float v11; // [esp+4Ch] [ebp-4Ch]
  char v12[16]; // [esp+50h] [ebp-48h] BYREF
  float v13; // [esp+60h] [ebp-38h] BYREF
  float v14; // [esp+64h] [ebp-34h]
  float v15; // [esp+68h] [ebp-30h]
  int v16[6]; // [esp+70h] [ebp-28h] BYREF
  float v17; // [esp+88h] [ebp-10h]
  float v18; // [esp+8Ch] [ebp-Ch]

  if ( sub_24483() )
  {
    sub_249CC();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*pm + 104) = result;
  }
  else
  {
    v11 = (pml[2] + 0.25) * 2.5;
    if ( v11 <= 1.0 )
    {
      if ( v11 < -1.0 )
        v11 = -1.0;
    }
    else
    {
      v11 = 1.0;
    }
    pml[2] = 0.0;
    VectorNormalize(pml);
    pml[5] = 0.0;
    VectorNormalize2(&pml[3], v12);
    ProjectPointOnPlane(&pml[3], v12, *pm + 92);
    v17 = sub_23905((char *)(pm + 4));
    v15 = 0.0;
    v14 = 0.0;
    v13 = 0.0;
    if ( *(_BYTE *)(pm + 24) )
      v15 = 0.5 * v11 * v17 * (long double)*(char *)(pm + 24);
    if ( *(_BYTE *)(pm + 25) )
    {
      v13 = v17 * 0.2 * (long double)*(char *)(pm + 25) * pml[3] + v13;
      v14 = v17 * 0.2 * (long double)*(char *)(pm + 25) * pml[4] + v14;
      v15 = v17 * 0.2 * (long double)*(char *)(pm + 25) * pml[5] + v15;
    }
    v18 = VectorNormalize2(&v13, v16);
    sub_2379E((int)v16, v18, 9.0);
    if ( !*(_BYTE *)(pm + 24) )
    {
      if ( *(float *)(*pm + 40) <= 0.0 )
      {
        *(float *)(*pm + 40) = (long double)*(int *)(*pm + 64) * pml[9] + *(float *)(*pm + 40);
        if ( *(float *)(*pm + 40) > 0.0 )
          *(_DWORD *)(*pm + 40) = 0;
      }
      else
      {
        *(float *)(*pm + 40) = *(float *)(*pm + 40) - (long double)*(int *)(*pm + 64) * pml[9];
        if ( *(float *)(*pm + 40) < 0.0 )
          *(_DWORD *)(*pm + 40) = 0;
      }
    }
    if ( !*(_BYTE *)(pm + 25) )
    {
      v9 = pml[3];
      v10 = pml[4];
      VectorNormalize2D(&v9);
      v5 = v9 * *(float *)(*pm + 32) + v10 * *(float *)(*pm + 36);
      if ( v5 != 0.0 )
      {
        *(float *)(*pm + 32) = -v5 * v9 + *(float *)(*pm + 32);
        *(float *)(*pm + 36) = -v5 * v10 + *(float *)(*pm + 36);
        v4 = v5 * pml[9] * 16.0;
        if ( fabs(v5) > fabs(v4) )
        {
          if ( fabs(v4) < 1.0 )
            v4 = (float)sub_2E35B(v4);
          v6 = v5 - v4;
          *(float *)(*pm + 32) = v9 * v6 + *(float *)(*pm + 32);
          *(float *)(*pm + 36) = v10 * v6 + *(float *)(*pm + 36);
        }
      }
    }
    if ( !LODWORD(pml[11]) )
    {
      v7 = *(float *)(*pm + 92) * *(float *)(*pm + 32) + *(float *)(*pm + 96) * *(float *)(*pm + 36);
      *(float *)(*pm + 32) = -v7 * *(float *)(*pm + 92) + *(float *)(*pm + 32);
      *(float *)(*pm + 36) = -v7 * *(float *)(*pm + 96) + *(float *)(*pm + 36);
      if ( v15 <= 0.0 )
        v8 = -250.0;
      else
        v8 = -500.0;
      *(float *)(*pm + 32) = *(float *)(*pm + 92) * v8 + *(float *)(*pm + 32);
      *(float *)(*pm + 36) = *(float *)(*pm + 96) * v8 + *(float *)(*pm + 36);
    }
    PM_StepSlideMove(0);
    v1 = vectoyaw(*pm + 92) + 180.0;
    v17 = v1;
    AngleDelta(v17, *(float *)(*pm + 236));
    v3 = (int)v1;
    v2 = (int)v1;
    if ( (int)v1 < 0 )
      v2 = -v2;
    if ( v2 > 75 )
    {
      if ( v3 <= 0 )
        LOBYTE(v3) = -75;
      else
        LOBYTE(v3) = 75;
    }
    result = (char)v3;
    *(_DWORD *)(*pm + 128) = (char)v3;
  }
  return result;
}
// 168D4: using guessed type long double __cdecl vectoyaw(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17924: using guessed type _DWORD __cdecl VectorNormalize2D(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 19444: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);
// 19514: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (0002D530) --------------------------------------------------------
void __cdecl PmoveSingle(int a1)
{
  unsigned int v1; // eax
  float v2; // [esp+18h] [ebp-30h]
  float v3; // [esp+1Ch] [ebp-2Ch]
  float v4; // [esp+20h] [ebp-28h]
  float v5; // [esp+24h] [ebp-24h]
  float v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+3Ch] [ebp-Ch]

  BG_AnimUpdatePlayerStateConditions(a1);
  pm = a1;
  ++c_pmove;
  *(_BYTE *)(a1 + 240) = 0;
  *(_BYTE *)(pm + 241) = 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x4000) != 0 )
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
  {
    *(_BYTE *)(a1 + 8) &= 0x12u;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  *(_DWORD *)(*pm + 12) &= 0xFFFF7FFF;
  if ( *(int *)(*pm + 4) > 5 )
    *(_DWORD *)(pm + 52) &= 0xFDFFFFFF;
  LODWORD(pml[34]) = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216));
  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    if ( (*(_BYTE *)(pm + 24) == *(_BYTE *)(pm + 48)
       || fabs((long double)*(char *)(pm + 24)) <= fabs((long double)*(char *)(pm + 48)))
      && (*(_BYTE *)(pm + 25) == *(_BYTE *)(pm + 49)
       || fabs((long double)*(char *)(pm + 25)) <= fabs((long double)*(char *)(pm + 49))) )
    {
      if ( (*(_DWORD *)(*pm + 12) & 0x20) == 0
        && (!*(_DWORD *)(*pm + 220)
         || *(_DWORD *)(*pm + 220) == 1
         || *(_DWORD *)(*pm + 220) == 2
         || *(_DWORD *)(*pm + 220) == 5) )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
      }
    }
    else if ( PM_InteruptWeaponWithProneMove() )
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
      PM_ClearAimDownSightFlag();
    }
  }
  else
  {
    *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
  }
  if ( (*(_DWORD *)(*pm + 12) & 0x10000) != 0 )
    PM_InteruptWeaponWithSprintMove();
  v7 = PM_GetEffectiveStance(*pm);
  if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 && v7 == 1 )
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
  }
  if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216)) + 128) == 3 )
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
  }
  if ( (*(_BYTE *)(pm + 8) & 2) != 0 )
    v1 = *(_DWORD *)(*pm + 132) | 0x20000;
  else
    v1 = *(_DWORD *)(*pm + 132) & 0xFFFDFFFF;
  *(_DWORD *)(*pm + 132) = v1;
  *(_DWORD *)(*pm + 132) &= 0xFFFFFDFF;
  if ( *(_DWORD *)(*pm + 4) != 5
    && (*(_DWORD *)(*pm + 12) & 0x800) == 0
    && (!*(_DWORD *)(*pm + 220) || *(_DWORD *)(*pm + 220) == 3)
    && PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 216))
    && (*(_DWORD *)(*pm + 12) & 0x10000) == 0
    && (*(_BYTE *)(pm + 8) & 1) != 0 )
  {
    *(_DWORD *)(*pm + 132) |= 0x200u;
  }
  if ( *(int *)(*pm + 4) <= 5 && (*(_BYTE *)(pm + 8) & 1) == 0 )
    *(_DWORD *)(*pm + 12) &= 0xFFFFF7FF;
  memset(pml, 0, 0x8Cu);
  LODWORD(pml[10]) = *(_DWORD *)(a1 + 4) - *(_DWORD *)*pm;
  if ( SLODWORD(pml[10]) > 0 )
  {
    if ( SLODWORD(pml[10]) > 200 )
      LODWORD(pml[10]) = 200;
  }
  else
  {
    LODWORD(pml[10]) = 1;
  }
  *(_DWORD *)*pm = *(_DWORD *)(a1 + 4);
  pml[27] = *(float *)(*pm + 20);
  pml[28] = *(float *)(*pm + 24);
  pml[29] = *(float *)(*pm + 28);
  pml[30] = *(float *)(*pm + 32);
  pml[31] = *(float *)(*pm + 36);
  pml[32] = *(float *)(*pm + 40);
  pml[9] = (long double)SLODWORD(pml[10]) * 0.001;
  LODWORD(pml[34]) = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 216));
  PM_AdjustAimSpreadScale();
  PM_UpdateViewAngles(*pm, pm + 4, *(_DWORD *)(pm + 268));
  AngleVectors(*pm + 232, pml, &pml[3], &pml[6]);
  if ( *(char *)(pm + 26) <= 9 )
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFF7;
  if ( *(char *)(pm + 24) >= 0 )
  {
    if ( *(char *)(pm + 24) > 0 || !*(_BYTE *)(pm + 24) && *(_BYTE *)(pm + 25) )
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFBF;
  }
  else
  {
    *(_DWORD *)(*pm + 12) |= 0x40u;
  }
  if ( *(int *)(*pm + 4) > 5 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
    *(_BYTE *)(pm + 26) = 0;
  }
  if ( v7 == 1 && (*(_DWORD *)(*pm + 12) & 0x400) != 0 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
  }
  switch ( *(_DWORD *)(*pm + 4) )
  {
    case 1:
    case 7:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      *(_DWORD *)(*pm + 88) = 1023;
      pml[12] = 0.0;
      pml[13] = 0.0;
      pml[11] = 0.0;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      PM_UpdatePlayerSprintingFlag();
      sub_27E16();
      sub_2A829();
      PM_UpdateFatigue();
      if ( (*(_DWORD *)(*pm + 132) & 0x106000) != 0
        && !BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(*pm + 1560), *(_DWORD *)(*pm + 1556)) )
      {
        goto LABEL_68;
      }
      goto LABEL_72;
    case 2:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      PM_UpdatePlayerSprintingFlag();
      sub_2538B();
      PM_Weapon();
      sub_2A829();
      PM_UpdateFatigue();
      break;
    case 3:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      PM_UpdatePlayerSprintingFlag();
      sub_256ED();
      PM_Weapon();
      sub_2A829();
      PM_UpdateFatigue();
      break;
    case 4:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      PM_UpdatePlayerSprintingFlag();
      sub_27E16();
      sub_24838();
      sub_2A829();
      PM_UpdateFatigue();
      break;
    case 5:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      break;
    default:
      if ( (*(_DWORD *)(*pm + 132) & 0x106000) != 0 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
        *(_DWORD *)(*pm + 88) = 1023;
        pml[12] = 0.0;
        pml[13] = 0.0;
        pml[11] = 0.0;
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        PM_UpdatePlayerSprintingFlag();
        sub_27E16();
        sub_2A829();
        PM_UpdateFatigue();
        if ( BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(*pm + 1560), *(_DWORD *)(*pm + 1556)) )
LABEL_72:
          PM_Weapon();
        else
LABEL_68:
          PM_UpdateAimDownSightLerp();
        sub_297E4();
      }
      else
      {
        sub_26CF1();
        LODWORD(pml[33]) = *(unsigned __int8 *)(a1 + 241);
        sub_27E16();
        sub_26823();
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        PM_UpdatePlayerSprintingFlag();
        PM_UpdatePronePitch();
        if ( *(_DWORD *)(*pm + 4) == 6 )
          sub_25246();
        sub_2C9A6();
        sub_2A829();
        PM_UpdateFatigue();
        if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
        {
          PM_LadderMove();
        }
        else if ( LODWORD(pml[11]) )
        {
          sub_24B7C();
        }
        else
        {
          sub_249CC();
        }
        sub_26823();
        sub_26CF1();
        sub_297E4();
        PM_Weapon();
        sub_2A550();
        sub_2A7B9();
        v4 = *(float *)(*pm + 20) - pml[27];
        v5 = *(float *)(*pm + 24) - pml[28];
        v6 = *(float *)(*pm + 28) - pml[29];
        v3 = (v4 * v4 + v5 * v5 + v6 * v6) / (pml[9] * pml[9]);
        v2 = *(float *)(*pm + 32) * *(float *)(*pm + 32)
           + *(float *)(*pm + 36) * *(float *)(*pm + 36)
           + *(float *)(*pm + 40) * *(float *)(*pm + 40);
        if ( v2 * 0.25 > v3 )
        {
          *(float *)(*pm + 32) = 1.0 / pml[9] * v4;
          *(float *)(*pm + 36) = 1.0 / pml[9] * v5;
          *(float *)(*pm + 40) = 1.0 / pml[9] * v6;
        }
        trap_SnapVector(*pm + 32);
      }
      break;
  }
}
// 168E4: using guessed type int PM_InteruptWeaponWithProneMove(void);
// 16984: using guessed type int PM_UpdatePlayerWalkingFlag(void);
// 16A64: using guessed type int PM_UpdatePlayerSprintingFlag(void);
// 16BD4: using guessed type _DWORD __cdecl PM_UpdateViewAngles(_DWORD, _DWORD, _DWORD);
// 16E14: using guessed type _DWORD __cdecl BG_AnimUpdatePlayerStateConditions(_DWORD);
// 16EA4: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 17064: using guessed type int PM_InteruptWeaponWithSprintMove(void);
// 17524: using guessed type int PM_UpdateAimDownSightFlag(void);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17AF4: using guessed type int PM_ClearAimDownSightFlag(void);
// 17B34: using guessed type int PM_Weapon(void);
// 17CB4: using guessed type int PM_UpdateFatigue(void);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 18824: using guessed type int PM_UpdatePronePitch(void);
// 18D34: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 19034: using guessed type int PM_AdjustAimSpreadScale(void);
// 196C4: using guessed type int PM_LadderMove(void);
// 19854: using guessed type _DWORD __cdecl trap_SnapVector(_DWORD);
// 198D4: using guessed type int PM_UpdateAimDownSightLerp(void);

//----- (0002E1C7) --------------------------------------------------------
_DWORD *__cdecl Pmove(int a1)
{
  _DWORD *result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 4);
  result = (_DWORD *)v3;
  if ( v3 >= **(_DWORD **)a1 )
  {
    if ( v3 > **(_DWORD **)a1 + 1000 )
      **(_DWORD **)a1 = v3 - 1000;
    pm[0] = a1;
    *(_DWORD *)(a1 + 84) = 0;
    while ( **(_DWORD **)a1 != v3 )
    {
      v2 = v3 - **(_DWORD **)a1;
      if ( *(_DWORD *)(a1 + 248) )
      {
        if ( v2 > *(_DWORD *)(a1 + 252) )
          v2 = *(_DWORD *)(a1 + 252);
      }
      else if ( v2 > 66 )
      {
        v2 = 66;
      }
      *(_DWORD *)(a1 + 4) = **(_DWORD **)a1 + v2;
      PmoveSingle(a1);
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 8) != 0 )
        *(_BYTE *)(a1 + 26) = 20;
    }
    result = pm;
    pm[0] = 0;
  }
  return result;
}
// 18094: using guessed type _DWORD __cdecl PmoveSingle(_DWORD);

//----- (0002E2C7) --------------------------------------------------------
long double __cdecl BG_GetSpeed(int a1, int a2)
{
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+10h] [ebp-8h]

  if ( (*(_DWORD *)(a1 + 12) & 0x10) != 0 )
  {
    if ( a2 - *(_DWORD *)(a1 + 104) > 499 )
      v3 = *(float *)(a1 + 40);
    else
      v3 = 0.0;
  }
  else
  {
    v4 = sqrt(*(float *)(a1 + 32) * *(float *)(a1 + 32) + *(float *)(a1 + 36) * *(float *)(a1 + 36));
    v3 = v4;
  }
  return v3;
}

//----- (0002E342) --------------------------------------------------------
long double __cdecl sub_2E342(float a1)
{
  return (float)fabs(a1);
}

//----- (0002E35B) --------------------------------------------------------
int __cdecl sub_2E35B(float a1)
{
  return -2 * sub_2E381(a1) + 1;
}

//----- (0002E381) --------------------------------------------------------
_BOOL4 __cdecl sub_2E381(float a1)
{
  return a1 < 0.0;
}

//----- (0002E3A9) --------------------------------------------------------
void sub_2E3A9()
{
  ;
}

//----- (0002E3B0) --------------------------------------------------------
int __cdecl PM_VerifyPronePosition(_DWORD *a1, _DWORD *a2)
{
  int v4; // [esp+50h] [ebp-8h]

  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) == 0 )
    return 1;
  v4 = BG_CheckProne(
         *(_DWORD *)(*(_DWORD *)pm[0] + 212),
         *(_DWORD *)pm[0] + 20,
         *(_DWORD *)(*(_DWORD *)pm[0] + 1384),
         1106247680,
         *(float *)(*(_DWORD *)pm[0] + 1444),
         *(_DWORD *)pm[0] + 1544,
         *(_DWORD *)pm[0] + 1548,
         *(_DWORD *)pm[0] + 1552,
         1,
         1,
         0,
         *(_DWORD *)(pm[0] + 268),
         *(_DWORD *)(pm[0] + 264),
         0,
         60.0,
         *(_DWORD *)(pm[0] + 276));
  if ( !v4 )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 20) = *a1;
    *(_DWORD *)(*(_DWORD *)pm[0] + 24) = a1[1];
    *(_DWORD *)(*(_DWORD *)pm[0] + 28) = a1[2];
    *(_DWORD *)(*(_DWORD *)pm[0] + 32) = *a2;
    *(_DWORD *)(*(_DWORD *)pm[0] + 36) = a2[1];
    *(_DWORD *)(*(_DWORD *)pm[0] + 40) = a2[2];
  }
  return v4;
}

//----- (0002E563) --------------------------------------------------------
_BOOL4 __cdecl PM_SlideMove(int a1)
{
  int v1; // esi
  int v2; // ecx
  int v5; // [esp+40h] [ebp-138h] BYREF
  float v6; // [esp+44h] [ebp-134h]
  float v7; // [esp+48h] [ebp-130h]
  int v8; // [esp+50h] [ebp-128h] BYREF
  float v9; // [esp+54h] [ebp-124h]
  float v10; // [esp+58h] [ebp-120h]
  float v11; // [esp+68h] [ebp-110h]
  float v12; // [esp+6Ch] [ebp-10Ch]
  float v13; // [esp+70h] [ebp-108h] BYREF
  float v14; // [esp+74h] [ebp-104h]
  float v15; // [esp+78h] [ebp-100h]
  float v16[4]; // [esp+80h] [ebp-F8h] BYREF
  int v17; // [esp+90h] [ebp-E8h]
  float v18; // [esp+94h] [ebp-E4h]
  float v19; // [esp+98h] [ebp-E0h]
  unsigned __int16 v20; // [esp+A8h] [ebp-D0h]
  char v21; // [esp+AEh] [ebp-CAh]
  int l; // [esp+B4h] [ebp-C4h]
  int k; // [esp+B8h] [ebp-C0h]
  int j; // [esp+BCh] [ebp-BCh]
  int v25; // [esp+C0h] [ebp-B8h] BYREF
  float v26; // [esp+C4h] [ebp-B4h]
  float v27; // [esp+C8h] [ebp-B0h]
  int v28; // [esp+D0h] [ebp-A8h]
  int v29; // [esp+D4h] [ebp-A4h]
  float v30; // [esp+D8h] [ebp-A0h]
  int v31[26]; // [esp+E0h] [ebp-98h] BYREF
  int v32; // [esp+148h] [ebp-30h]
  float v33; // [esp+14Ch] [ebp-2Ch]
  float v34; // [esp+150h] [ebp-28h] BYREF
  float v35; // [esp+154h] [ebp-24h]
  float v36; // [esp+158h] [ebp-20h]
  int v37; // [esp+168h] [ebp-10h]
  int i; // [esp+16Ch] [ebp-Ch]
  _DWORD v39[2]; // [esp+170h] [ebp-8h] BYREF

  v37 = 4;
  v36 = 0.0;
  v35 = 0.0;
  v34 = 0.0;
  v15 = 0.0;
  v14 = 0.0;
  v13 = 0.0;
  v10 = 0.0;
  v9 = 0.0;
  *(float *)&v8 = 0.0;
  v30 = 0.0;
  v29 = 0;
  v28 = 0;
  v7 = 0.0;
  v6 = 0.0;
  *(float *)&v5 = 0.0;
  v27 = 0.0;
  v26 = 0.0;
  *(float *)&v25 = 0.0;
  v28 = *(_DWORD *)(*(_DWORD *)pm[0] + 32);
  v29 = *(_DWORD *)(*(_DWORD *)pm[0] + 36);
  v30 = *(float *)(*(_DWORD *)pm[0] + 40);
  if ( a1 )
  {
    v8 = *(int *)(*(_DWORD *)pm[0] + 32);
    v9 = *(float *)(*(_DWORD *)pm[0] + 36);
    v10 = *(float *)(*(_DWORD *)pm[0] + 40) - (long double)*(int *)(*(_DWORD *)pm[0] + 64) * pml[9];
    *(float *)(*(_DWORD *)pm[0] + 40) = (*(float *)(*(_DWORD *)pm[0] + 40) + v10) * 0.5;
    v30 = v10;
    if ( LODWORD(pml[12]) )
      PM_ClipVelocity(*(_DWORD *)pm[0] + 32, (int)&pml[18], *(_DWORD *)pm[0] + 32, 1.001);
  }
  v12 = pml[9];
  if ( LODWORD(pml[12]) )
  {
    *(float *)v31 = pml[18];
    *(float *)&v31[1] = pml[19];
    *(float *)&v31[2] = pml[20];
    v32 = 1;
  }
  else
  {
    v32 = 0;
  }
  VectorNormalize2(*(_DWORD *)pm[0] + 32, &v31[3 * v32++]);
  for ( i = 0; ; ++i )
  {
    if ( i >= v37 )
      goto LABEL_47;
    v13 = *(float *)(*(_DWORD *)pm[0] + 32) * v12 + *(float *)(*(_DWORD *)pm[0] + 20);
    v14 = *(float *)(*(_DWORD *)pm[0] + 36) * v12 + *(float *)(*(_DWORD *)pm[0] + 24);
    v15 = *(float *)(*(_DWORD *)pm[0] + 40) * v12 + *(float *)(*(_DWORD *)pm[0] + 28);
    PM_trace(
      v16,
      *(_DWORD *)pm[0] + 20,
      pm[0] + 216,
      pm[0] + 228,
      &v13,
      *(_DWORD *)(*(_DWORD *)pm[0] + 212),
      *(_DWORD *)(pm[0] + 52));
    if ( v21 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 40) = 0;
      return 1;
    }
    if ( v16[0] > 0.0 )
    {
      *(float *)(*(_DWORD *)pm[0] + 20) = v16[1];
      *(float *)(*(_DWORD *)pm[0] + 24) = v16[2];
      *(float *)(*(_DWORD *)pm[0] + 28) = v16[3];
    }
    if ( v16[0] == 1.0 )
    {
LABEL_47:
      if ( a1 )
      {
        *(float *)(*(_DWORD *)pm[0] + 32) = *(float *)&v8;
        *(float *)(*(_DWORD *)pm[0] + 36) = v9;
        *(float *)(*(_DWORD *)pm[0] + 40) = v10;
      }
      if ( *(_DWORD *)(*(_DWORD *)pm[0] + 16) )
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 32) = v28;
        *(_DWORD *)(*(_DWORD *)pm[0] + 36) = v29;
        *(float *)(*(_DWORD *)pm[0] + 40) = v30;
      }
      return i != 0;
    }
    PM_AddTouchEnt(v20);
    v12 = v12 - v12 * v16[0];
    if ( v32 > 7 )
      break;
    for ( j = 0; j < v32; ++j )
    {
      if ( *(float *)&v17 * *(float *)&v31[3 * j] + v18 * *(float *)&v39[3 * j - 35] + v19 * *(float *)&v39[3 * j - 34] > 0.99900001 )
      {
        if ( *(int *)(pm[0] + 56) > 1 )
          Com_Printf("%i:recollided with plane normal (%.2f, %.2f, %.2f)\n", c_pmove);
        *(float *)(*(_DWORD *)pm[0] + 32) = *(float *)&v17 + *(float *)(*(_DWORD *)pm[0] + 32);
        *(float *)(*(_DWORD *)pm[0] + 36) = v18 + *(float *)(*(_DWORD *)pm[0] + 36);
        *(float *)(*(_DWORD *)pm[0] + 40) = v19 + *(float *)(*(_DWORD *)pm[0] + 40);
        break;
      }
    }
    if ( j >= v32 )
    {
      v31[3 * v32] = v17;
      *(float *)&v39[3 * v32 - 35] = v18;
      *(float *)&v39[3 * v32++ - 34] = v19;
      for ( j = 0; j < v32; ++j )
      {
        v11 = *(float *)(*(_DWORD *)pm[0] + 32) * *(float *)&v31[3 * j]
            + *(float *)(*(_DWORD *)pm[0] + 36) * *(float *)&v39[3 * j - 35]
            + *(float *)(*(_DWORD *)pm[0] + 40) * *(float *)&v39[3 * j - 34];
        if ( v11 < 0.1 )
        {
          if ( -v11 > (long double)pml[26] )
            LODWORD(pml[26]) = LODWORD(v11) ^ 0x80000000;
          PM_ClipVelocity(*(_DWORD *)pm[0] + 32, (int)&v31[3 * j], (int)&v25, 1.001);
          PM_ClipVelocity((int)&v8, (int)&v31[3 * j], (int)&v5, 1.001);
          for ( k = 0; k < v32; ++k )
          {
            if ( k != j
              && *(float *)&v25 * *(float *)&v31[3 * k]
               + v26 * *(float *)&v39[3 * k - 35]
               + v27 * *(float *)&v39[3 * k - 34] < 0.1 )
            {
              PM_ClipVelocity((int)&v25, (int)&v31[3 * k], (int)&v25, 1.001);
              PM_ClipVelocity((int)&v5, (int)&v31[3 * k], (int)&v5, 1.001);
              if ( *(float *)&v25 * *(float *)&v31[3 * j]
                 + v26 * *(float *)&v39[3 * j - 35]
                 + v27 * *(float *)&v39[3 * j - 34] < 0.0 )
              {
                CrossProduct(&v31[3 * j], &v31[3 * k], &v34);
                VectorNormalize(&v34);
                v33 = v34 * *(float *)(*(_DWORD *)pm[0] + 32)
                    + v35 * *(float *)(*(_DWORD *)pm[0] + 36)
                    + v36 * *(float *)(*(_DWORD *)pm[0] + 40);
                *(float *)&v25 = v34 * v33;
                v26 = v35 * v33;
                v27 = v36 * v33;
                v33 = v34 * *(float *)&v8 + v35 * v9 + v36 * v10;
                *(float *)&v5 = v34 * v33;
                v6 = v35 * v33;
                v7 = v36 * v33;
                for ( l = 0; l < v32; ++l )
                {
                  if ( l != j
                    && l != k
                    && *(float *)&v25 * *(float *)&v31[3 * l]
                     + v26 * *(float *)&v39[3 * l - 35]
                     + v27 * *(float *)&v39[3 * l - 34] < 0.1 )
                  {
                    goto LABEL_41;
                  }
                }
              }
            }
          }
          *(float *)(*(_DWORD *)pm[0] + 32) = *(float *)&v25;
          *(float *)(*(_DWORD *)pm[0] + 36) = v26;
          *(float *)(*(_DWORD *)pm[0] + 40) = v27;
          v8 = v5;
          v9 = v6;
          v10 = v7;
          break;
        }
      }
    }
  }
  if ( *(int *)(pm[0] + 56) > 1 )
    Com_Printf("%i:MAX_CLIP_PLANES\n", c_pmove);
LABEL_41:
  v1 = *(_DWORD *)pm[0];
  v2 = *(_DWORD *)pm[0];
  *(_DWORD *)(*(_DWORD *)pm[0] + 40) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  return 1;
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18754: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (0002F236) --------------------------------------------------------
void __cdecl PM_StepSlideMove(int a1)
{
  float v1; // [esp+0h] [ebp-118h]
  float v2; // [esp+0h] [ebp-118h]
  int v3; // [esp+2Ch] [ebp-ECh]
  int v4; // [esp+30h] [ebp-E8h]
  float v5; // [esp+3Ch] [ebp-DCh]
  int v6; // [esp+40h] [ebp-D8h]
  float v7; // [esp+44h] [ebp-D4h]
  int v8; // [esp+48h] [ebp-D0h]
  int v9; // [esp+48h] [ebp-D0h]
  int v10; // [esp+48h] [ebp-D0h]
  int v11; // [esp+48h] [ebp-D0h]
  float v12; // [esp+50h] [ebp-C8h]
  float v13; // [esp+54h] [ebp-C4h]
  float v14; // [esp+54h] [ebp-C4h]
  int v15; // [esp+58h] [ebp-C0h]
  int v16; // [esp+5Ch] [ebp-BCh]
  float v17; // [esp+60h] [ebp-B8h]
  int v18; // [esp+64h] [ebp-B4h]
  float v19; // [esp+68h] [ebp-B0h]
  float v20; // [esp+70h] [ebp-A8h]
  float v21; // [esp+74h] [ebp-A4h]
  float v22; // [esp+78h] [ebp-A0h]
  float v23; // [esp+7Ch] [ebp-9Ch]
  int v24; // [esp+80h] [ebp-98h] BYREF
  int v25; // [esp+84h] [ebp-94h]
  float v26; // [esp+88h] [ebp-90h]
  float v27; // [esp+90h] [ebp-88h] BYREF
  float v28; // [esp+94h] [ebp-84h]
  float v29; // [esp+98h] [ebp-80h]
  float v30; // [esp+A0h] [ebp-78h] BYREF
  int v31; // [esp+A4h] [ebp-74h]
  int v32; // [esp+A8h] [ebp-70h]
  int v33; // [esp+ACh] [ebp-6Ch]
  _WORD v34[16]; // [esp+B0h] [ebp-68h] BYREF
  int v35; // [esp+D0h] [ebp-48h]
  int v36; // [esp+D4h] [ebp-44h]
  int v37; // [esp+D8h] [ebp-40h]
  float v38; // [esp+E0h] [ebp-38h]
  float v39; // [esp+E4h] [ebp-34h]
  float v40; // [esp+E8h] [ebp-30h]
  int v41; // [esp+F0h] [ebp-28h] BYREF
  int v42; // [esp+F4h] [ebp-24h]
  int v43; // [esp+F8h] [ebp-20h]
  float v44; // [esp+100h] [ebp-18h] BYREF
  float v45; // [esp+104h] [ebp-14h]
  float v46; // [esp+108h] [ebp-10h]

  v17 = 0.0;
  v15 = 0;
  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10) != 0 )
  {
    v16 = 0;
    *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFDFFF;
    *(_DWORD *)(*(_DWORD *)pm[0] + 108) = 0;
  }
  else if ( LODWORD(pml[12]) )
  {
    v16 = 1;
  }
  else
  {
    v16 = 0;
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x2000) != 0 && *(_DWORD *)(*(_DWORD *)pm[0] + 16) )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*(_DWORD *)pm[0] + 108) = 0;
    }
  }
  v44 = *(float *)(*(_DWORD *)pm[0] + 20);
  v45 = *(float *)(*(_DWORD *)pm[0] + 24);
  v46 = *(float *)(*(_DWORD *)pm[0] + 28);
  v41 = *(_DWORD *)(*(_DWORD *)pm[0] + 32);
  v42 = *(_DWORD *)(*(_DWORD *)pm[0] + 36);
  v43 = *(_DWORD *)(*(_DWORD *)pm[0] + 40);
  v18 = PM_SlideMove(a1);
  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) != 0 )
    v19 = 10.0;
  else
    v19 = 18.0;
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 88) == 1023 )
  {
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x2000) != 0 && *(_DWORD *)(*(_DWORD *)pm[0] + 16) )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*(_DWORD *)pm[0] + 108) = 0;
    }
    if ( v18 && (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x2000) != 0 && *(float *)(*(_DWORD *)pm[0] + 108) + 39.0 > v46 )
    {
      v19 = 18.0;
      if ( v46 + 18.0 > *(float *)(*(_DWORD *)pm[0] + 108) + 39.0 )
      {
        v19 = *(float *)(*(_DWORD *)pm[0] + 108) + 39.0 - v46;
        if ( v19 < 1.0 )
          return;
      }
      v15 = 1;
    }
    else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10) == 0 || *(float *)(*(_DWORD *)pm[0] + 40) <= 0.0 )
    {
      return;
    }
  }
  v38 = *(float *)(*(_DWORD *)pm[0] + 20);
  v39 = *(float *)(*(_DWORD *)pm[0] + 24);
  v40 = *(float *)(*(_DWORD *)pm[0] + 28);
  v35 = *(_DWORD *)(*(_DWORD *)pm[0] + 32);
  v36 = *(_DWORD *)(*(_DWORD *)pm[0] + 36);
  v37 = *(_DWORD *)(*(_DWORD *)pm[0] + 40);
  v22 = v38 - v44;
  v23 = v39 - v45;
  if ( v18 )
  {
    v27 = v44;
    v28 = v45;
    v29 = v19 + 1.0 + v46;
    PM_trace(&v30, &v44, pm[0] + 216, pm[0] + 228, &v27, *(_DWORD *)(*(_DWORD *)pm[0] + 212), *(_DWORD *)(pm[0] + 52));
    v17 = (v19 + 1.0) * v30 - 1.0;
    if ( v17 >= 1.0 )
    {
      *(float *)(*(_DWORD *)pm[0] + 20) = v27;
      *(float *)(*(_DWORD *)pm[0] + 24) = v28;
      *(float *)(*(_DWORD *)pm[0] + 28) = v46 + v17;
      *(_DWORD *)(*(_DWORD *)pm[0] + 32) = v41;
      *(_DWORD *)(*(_DWORD *)pm[0] + 36) = v42;
      *(_DWORD *)(*(_DWORD *)pm[0] + 40) = v43;
      PM_SlideMove(a1);
    }
    else
    {
      if ( *(_DWORD *)(pm[0] + 56) )
        Com_Printf("%i:not enough step room\n", c_pmove);
      v17 = 0.0;
    }
  }
  if ( v16 || v17 != 0.0 )
  {
    v24 = *(_DWORD *)(*(_DWORD *)pm[0] + 20);
    v25 = *(_DWORD *)(*(_DWORD *)pm[0] + 24);
    v26 = *(float *)(*(_DWORD *)pm[0] + 28) - v17;
    if ( v16 )
      v26 = v26 - 9.0;
    PM_trace(
      &v30,
      *(_DWORD *)pm[0] + 20,
      pm[0] + 216,
      pm[0] + 228,
      &v24,
      *(_DWORD *)(*(_DWORD *)pm[0] + 212),
      *(_DWORD *)(pm[0] + 52));
    if ( v34[12] <= 0x3Fu )
    {
      *(float *)(*(_DWORD *)pm[0] + 20) = v38;
      *(float *)(*(_DWORD *)pm[0] + 24) = v39;
      *(float *)(*(_DWORD *)pm[0] + 28) = v40;
      *(_DWORD *)(*(_DWORD *)pm[0] + 32) = v35;
      *(_DWORD *)(*(_DWORD *)pm[0] + 36) = v36;
      *(_DWORD *)(*(_DWORD *)pm[0] + 40) = v37;
      return;
    }
    if ( v30 >= 1.0 )
    {
      if ( v17 != 0.0 )
        *(float *)(*(_DWORD *)pm[0] + 28) = *(float *)(*(_DWORD *)pm[0] + 28) - v17;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 20) = v31;
      *(_DWORD *)(*(_DWORD *)pm[0] + 24) = v32;
      *(_DWORD *)(*(_DWORD *)pm[0] + 28) = v33;
      PM_ClipVelocity(*(_DWORD *)pm[0] + 32, (int)v34, *(_DWORD *)pm[0] + 32, 1.001);
    }
  }
  v20 = *(float *)(*(_DWORD *)pm[0] + 20) - v44;
  v21 = *(float *)(*(_DWORD *)pm[0] + 24) - v45;
  if ( v22 * *(float *)(*(_DWORD *)pm[0] + 32) + v23 * *(float *)(*(_DWORD *)pm[0] + 36) + 0.001 >= v20 * *(float *)(*(_DWORD *)pm[0] + 32) + v21 * *(float *)(*(_DWORD *)pm[0] + 36)
    || v15 && *(float *)(*(_DWORD *)pm[0] + 28) >= *(float *)(*(_DWORD *)pm[0] + 108) + 39.0 )
  {
    *(float *)(*(_DWORD *)pm[0] + 20) = v38;
    *(float *)(*(_DWORD *)pm[0] + 24) = v39;
    *(float *)(*(_DWORD *)pm[0] + 28) = v40;
    *(_DWORD *)(*(_DWORD *)pm[0] + 32) = v35;
    *(_DWORD *)(*(_DWORD *)pm[0] + 36) = v36;
    *(_DWORD *)(*(_DWORD *)pm[0] + 40) = v37;
    if ( *(int *)(pm[0] + 56) > 1 )
    {
      if ( v15 )
        Com_Printf("%i:didn't use jump step results because it went too high\n", c_pmove);
      else
        Com_Printf("%i:didn't use step results\n", c_pmove);
    }
    if ( v16 )
    {
      v24 = *(_DWORD *)(*(_DWORD *)pm[0] + 20);
      v25 = *(_DWORD *)(*(_DWORD *)pm[0] + 24);
      v26 = *(float *)(*(_DWORD *)pm[0] + 28);
      v26 = v26 - 9.0;
      PM_trace(
        &v30,
        *(_DWORD *)pm[0] + 20,
        pm[0] + 216,
        pm[0] + 228,
        &v24,
        *(_DWORD *)(*(_DWORD *)pm[0] + 212),
        *(_DWORD *)(pm[0] + 52));
      if ( v30 < 1.0 )
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 20) = v31;
        *(_DWORD *)(*(_DWORD *)pm[0] + 24) = v32;
        *(_DWORD *)(*(_DWORD *)pm[0] + 28) = v33;
        PM_ClipVelocity(*(_DWORD *)pm[0] + 32, (int)v34, *(_DWORD *)pm[0] + 32, 1.001);
        if ( *(int *)(pm[0] + 56) > 1 )
          Com_Printf("%i:did down step after not using step results\n", c_pmove);
      }
    }
  }
  if ( v15 && *(float *)(*(_DWORD *)pm[0] + 28) - v40 > 0.0 )
  {
    v13 = *(float *)(*(_DWORD *)pm[0] + 108) + 39.0 - *(float *)(*(_DWORD *)pm[0] + 28);
    if ( v13 >= 0.1 )
    {
      v12 = sqrt((v13 + v13) * (long double)*(int *)(*(_DWORD *)pm[0] + 64));
      if ( *(float *)(*(_DWORD *)pm[0] + 40) > (long double)v12 )
      {
        if ( *(_DWORD *)(pm[0] + 56) )
          Com_Printf("%i:adjusted jump vel: %.1f -> %.1f\n", c_pmove);
        *(float *)(*(_DWORD *)pm[0] + 40) = v12;
      }
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 40) = 0;
    }
  }
  if ( v16 )
  {
    if ( *(int *)(*(_DWORD *)pm[0] + 4) <= 5 )
    {
      if ( PM_VerifyPronePosition(&v44, &v41) )
      {
        if ( fabs(*(float *)(*(_DWORD *)pm[0] + 28) - v40) > 0.5 )
        {
          v1 = *(float *)(*(_DWORD *)pm[0] + 28) - v40;
          v8 = sub_300A5(v1);
          if ( v8 )
          {
            if ( *(_DWORD *)(pm[0] + 56) )
            {
              if ( v15 )
                Com_Printf("%i:jump step %2i\n", c_pmove);
              else
                Com_Printf("%i:stepped %2i\n", c_pmove);
            }
            if ( v8 >= -16 )
            {
              if ( v8 > 24 )
                v8 = 24;
            }
            else
            {
              v8 = -16;
            }
            v9 = v8 + 128;
            BG_AddPredictableEventToPlayerstate(145, v9, *(_DWORD *)pm[0]);
            v2 = *(float *)(*(_DWORD *)pm[0] + 28) - v46;
            v14 = sub_300E3(v2);
            v7 = 1.0 - 0.80000001 + (1.0 - v14 / v19) * 0.80000001;
            *(float *)(*(_DWORD *)pm[0] + 32) = *(float *)(*(_DWORD *)pm[0] + 32) * v7;
            *(float *)(*(_DWORD *)pm[0] + 36) = *(float *)(*(_DWORD *)pm[0] + 36) * v7;
            *(float *)(*(_DWORD *)pm[0] + 40) = *(float *)(*(_DWORD *)pm[0] + 40) * v7;
            v10 = v9 - 128;
            v4 = v10;
            if ( v10 < 0 )
              v4 = -v10;
            if ( v4 > 3 && *(_DWORD *)(*(_DWORD *)pm[0] + 88) != 1023 && PM_ShouldMakeFootsteps() )
            {
              v3 = v10;
              if ( v10 < 0 )
                v3 = -v10;
              v11 = v3 / 2;
              if ( v3 / 2 > 4 )
                v11 = 4;
              v5 = (long double)v11 * 1.25 + 7.0;
              v6 = *(_DWORD *)(*(_DWORD *)pm[0] + 8);
              *(_DWORD *)(*(_DWORD *)pm[0] + 8) = (unsigned __int8)(int)((long double)v6 + v5);
              PM_FootstepEvent(v6, *(_DWORD *)(*(_DWORD *)pm[0] + 8), 1);
            }
          }
        }
      }
    }
  }
}
// 16834: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16D24: using guessed type _DWORD __cdecl PM_FootstepEvent(char, char, _DWORD);
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 18254: using guessed type _DWORD __cdecl PM_SlideMove(_DWORD);
// 18F14: using guessed type _DWORD __cdecl PM_VerifyPronePosition(_DWORD, _DWORD);
// 194E4: using guessed type int PM_ShouldMakeFootsteps(void);

//----- (000300A5) --------------------------------------------------------
int __cdecl sub_300A5(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (000300E3) --------------------------------------------------------
long double __cdecl sub_300E3(float a1)
{
  return (float)fabs(a1);
}

//----- (000300FC) --------------------------------------------------------
void sub_300FC()
{
  ;
}

//----- (00030100) --------------------------------------------------------
int __cdecl BG_GetWeaponTypeName(int a1)
{
  return *(int *)((char *)off_AB468 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// AB468: using guessed type char *off_AB468[10];

//----- (0003011C) --------------------------------------------------------
int __cdecl BG_Bullet_Endpos(float a1, int a2, int a3)
{
  int result; // eax
  float v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+1Ch] [ebp-Ch] BYREF
  float v7[2]; // [esp+20h] [ebp-8h] BYREF

  v4 = tan(a1 * 3.141592653589793 / 180.0);
  v5 = v4 * 10000.0;
  gunrandom(v7, &v6);
  v7[0] = v7[0] * v5;
  v6 = v6 * v5;
  *(float *)a2 = *(float *)a3 * 10000.0 + *(float *)(a3 + 36);
  *(float *)(a2 + 4) = *(float *)(a3 + 4) * 10000.0 + *(float *)(a3 + 40);
  *(float *)(a2 + 8) = *(float *)(a3 + 8) * 10000.0 + *(float *)(a3 + 44);
  *(float *)a2 = *(float *)(a3 + 12) * v7[0] + *(float *)a2;
  *(float *)(a2 + 4) = *(float *)(a3 + 16) * v7[0] + *(float *)(a2 + 4);
  *(float *)(a2 + 8) = *(float *)(a3 + 20) * v7[0] + *(float *)(a2 + 8);
  *(float *)a2 = *(float *)(a3 + 24) * v6 + *(float *)a2;
  *(float *)(a2 + 4) = *(float *)(a3 + 28) * v6 + *(float *)(a2 + 4);
  result = a3;
  *(float *)(a2 + 8) = *(float *)(a3 + 32) * v6 + *(float *)(a2 + 8);
  return result;
}
// 17ED4: using guessed type _DWORD __cdecl gunrandom(_DWORD, _DWORD);

//----- (00030263) --------------------------------------------------------
int __cdecl sub_30263(int a1, char *s1, int a3)
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]
  int v11; // [esp+20h] [ebp-8h]

  switch ( a3 )
  {
    case 8:
      v5 = 0;
      break;
    case 9:
      v6 = 0;
      while ( 2 )
      {
        if ( v6 <= 10 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB4E0 + (_DWORD)&dword_0[v6])) )
          {
            ++v6;
            continue;
          }
          *(_DWORD *)(a1 + 128) = v6;
        }
        break;
      }
      if ( v6 == 11 )
        Com_Error(1, byte_9CD60, (char)s1);
      return 1;
    case 10:
      v7 = 0;
      while ( 2 )
      {
        if ( v7 <= 5 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB50C + (_DWORD)&dword_0[v7])) )
          {
            ++v7;
            continue;
          }
          *(_DWORD *)(a1 + 144) = v7;
        }
        break;
      }
      if ( v7 == 6 )
        Com_Error(1, byte_9CDA0, (char)s1);
      return 1;
    case 11:
      v8 = 0;
      while ( 2 )
      {
        if ( v8 <= 4 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB47C + (_DWORD)&dword_0[v8])) )
          {
            ++v8;
            continue;
          }
          *(_DWORD *)(a1 + 644) = v8;
        }
        break;
      }
      if ( v8 == 5 )
        Com_Error(1, byte_9CDE0, (char)s1);
      return 1;
    case 12:
      v9 = 0;
      while ( 2 )
      {
        if ( v9 <= 7 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB4A0 + (_DWORD)&dword_0[v9])) )
          {
            ++v9;
            continue;
          }
          *(_DWORD *)(a1 + 132) = v9;
        }
        break;
      }
      if ( v9 == 8 )
        Com_Error(1, byte_9CE20, (char)s1);
      return 1;
    case 13:
      v10 = 0;
      while ( 2 )
      {
        if ( v10 <= 2 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB4C0 + (_DWORD)&dword_0[v10])) )
          {
            ++v10;
            continue;
          }
          *(_DWORD *)(a1 + 140) = v10;
        }
        break;
      }
      if ( v10 == 3 )
        Com_Error(1, byte_9CE60, (char)s1);
      return 1;
    case 14:
      v11 = 0;
      while ( 2 )
      {
        if ( v11 <= 8 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_AB540 + (_DWORD)&dword_0[v11])) )
          {
            ++v11;
            continue;
          }
          *(_DWORD *)(a1 + 912) = v11;
        }
        break;
      }
      if ( v11 == 9 )
        Com_Error(1, byte_9CEA0, (char)s1);
      return 1;
    default:
      Com_Error(1, byte_9CECC, a3);
      return 0;
  }
  while ( 1 )
  {
    if ( v5 > 4 )
      goto LABEL_7;
    if ( !strcasecmp(s1, *(const char **)((char *)off_AB468 + (_DWORD)&dword_0[v5])) )
      break;
    ++v5;
  }
  *(_DWORD *)(a1 + 124) = v5;
LABEL_7:
  if ( v5 == 5 )
    Com_Error(1, byte_9CD20, (char)s1);
  return 1;
}
// 0: using guessed type int dword_0[];
// AB468: using guessed type char *off_AB468[10];
// AB47C: using guessed type char *off_AB47C[5];
// AB4A0: using guessed type char *off_AB4A0[11];
// AB4C0: using guessed type char *off_AB4C0[3];
// AB4E0: using guessed type char *off_AB4E0[17];
// AB50C: using guessed type char *off_AB50C[6];
// AB540: using guessed type char *off_AB540[9];

//----- (00030610) --------------------------------------------------------
char *__cdecl sub_30610(int a1, char *s)
{
  char *result; // eax
  size_t v3; // eax
  char *dest; // [esp+10h] [ebp-8h]

  if ( *s )
  {
    v3 = strlen(s);
    dest = (char *)trap_Hunk_AllocLowAlignInternal(v3 + 1, 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)a1 = dest;
  }
  else
  {
    result = (char *)dword_D0DC4;
    *(_DWORD *)a1 = dword_D0DC4;
  }
  return result;
}
// 17D34: using guessed type _DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD);
// D0DC4: using guessed type int dword_D0DC4;

//----- (00030676) --------------------------------------------------------
char *__cdecl sub_30676(int a1, char *s)
{
  return sub_30610(a1, s);
}

//----- (00030690) --------------------------------------------------------
_DWORD *__cdecl sub_30690(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int i; // [esp+10h] [ebp-8h]

  v4 = (_DWORD *)trap_Hunk_AllocLowInternal(1212);
  *(_DWORD *)(dword_AB448 + 4 * a1) = v4;
  *v4 = a1;
  sub_30610((int)(v4 + 1), (char *)&unk_9CF04);
  for ( i = 0; i < a3; ++i )
  {
    if ( !*(_DWORD *)(a2 + 8) )
      sub_30610((int)v4 + *(_DWORD *)(a2 + 4), (char *)&unk_9CF04);
    a2 += 12;
  }
  return v4;
}
// 17434: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);
// AB448: using guessed type int dword_AB448;

//----- (0003073B) --------------------------------------------------------
int __cdecl sub_3073B(int a1, int a2)
{
  int result; // eax
  size_t n; // [esp+20h] [ebp-2068h]
  int v4; // [esp+28h] [ebp-2060h] BYREF
  int v5; // [esp+2Ch] [ebp-205Ch]
  char s1[8192]; // [esp+30h] [ebp-2058h] BYREF
  char dest[72]; // [esp+2030h] [ebp-58h] BYREF
  int v8; // [esp+2078h] [ebp-10h]
  int i; // [esp+207Ch] [ebp-Ch]

  n = strlen("WEAPONFILE");
  dword_D0DC4 = trap_Hunk_AllocLowAlignInternal(1, 1);
  *(_BYTE *)dword_D0DC4 = 0;
  v5 = (int)sub_30690(0, (int)&off_AB580, bg_iNumWeaponInfoFields);
  sub_30610(v5 + 4, "none");
  dword_AB444 = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v5 = (int)sub_30690(++dword_AB444, (int)&off_AB580, bg_iNumWeaponInfoFields);
    sprintf(dest, (const char *)&off_9CF10, bg_szWeaponsFolder[0]);
    strcat(dest, *(const char **)(a1 + 4 * i));
    if ( bg_debugWeaponMessages[3] && bg_debugWeaponMessages[3] != 2 )
      Com_DPrintf("Parsing weapon file \"%s\"...\n", (char)dest);
    v8 = trap_FS_FOpenFile(dest, &v4, 0);
    if ( v8 <= 0 )
      Com_Error(1, byte_9CF40, (char)dest);
    trap_FS_Read(s1, n, v4);
    s1[n] = 0;
    if ( strncmp(s1, "WEAPONFILE", n) )
      Com_Error(1, byte_9CF80, (char)dest);
    if ( (int)(v8 - n) > 0x1FFF )
      Com_Error(1, byte_9CFC0, (char)dest);
    memset(s1, 0, sizeof(s1));
    trap_FS_Read(s1, v8 - n, v4);
    s1[v8 - n] = 0;
    trap_FS_FCloseFile(v4);
    if ( !Info_Validate(s1) )
      Com_Error(1, byte_9D000, (char)dest);
    sub_30610(v5 + 4, *(char **)(a1 + 4 * i));
    if ( !ParseConfigStringToStruct(
            v5,
            (int)&off_AB580,
            bg_iNumWeaponInfoFields,
            s1,
            15,
            (int)sub_30263,
            (int)sub_30676) )
      *(_DWORD *)(dword_AB448 + 4 * dword_AB444--) = 0;
  }
  return result;
}
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 17D34: using guessed type _DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD);
// 197A4: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// 9CF10: using guessed type void *off_9CF10;
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;
// AB464: using guessed type char *bg_szWeaponsFolder[11];
// AB580: using guessed type char *off_AB580;
// D0DC4: using guessed type int dword_D0DC4;

//----- (00030AB4) --------------------------------------------------------
int sub_30AB4()
{
  int result; // eax
  long double v1; // fst7
  long double v2; // fst7
  int v3; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_AB444 )
      break;
    v3 = *(_DWORD *)(dword_AB448 + 4 * i);
    if ( *(int *)(v3 + 708) <= 0 )
      v1 = 1.0 / 300.0;
    else
      v1 = 1.0 / (long double)*(int *)(v3 + 708);
    *(float *)(v3 + 1204) = v1;
    if ( *(int *)(v3 + 712) <= 0 )
      v2 = 1.0 / 500.0;
    else
      v2 = 1.0 / (long double)*(int *)(v3 + 712);
    *(float *)(v3 + 1208) = v2;
  }
  return result;
}
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;

//----- (00030B85) --------------------------------------------------------
int BG_FillInWeaponItems()
{
  int result; // eax
  size_t v1; // eax
  _DWORD *v2; // [esp+14h] [ebp-14h]
  _DWORD *v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v2 = (_DWORD *)((char *)&bg_itemlist + 48);
  for ( i = 1; i <= dword_AB444; ++i )
  {
    v3 = *(_DWORD **)(dword_AB448 + 4 * i);
    *v2 = v3[113];
    v2[1] = v3[39];
    if ( v3[115] && *(_BYTE *)v3[115] )
      v2[2] = v3[115];
    else
      v2[2] = v3[114];
    v2[3] = 0;
    v2[4] = v3[117];
    v2[5] = v3[119];
    v2[6] = v3[2];
    v2[7] = v3[120];
    v2[8] = 1;
    v2[9] = i;
    v2[10] = v3[122];
    v2[11] = v3[124];
    v2 += 12;
  }
  while ( 1 )
  {
    result = i;
    if ( i >= bg_numItems )
      return result;
    if ( v2[8] == 2 )
    {
      for ( j = 1; j <= dword_AB444; ++j )
      {
        v4 = *(_DWORD *)(dword_AB448 + 4 * j);
        v1 = strlen(*(const char **)(v4 + 4));
        if ( !Q_stricmpn(v2[6], *(_DWORD *)(v4 + 4), v1) )
        {
          v2[9] = j;
          v2[10] = *(_DWORD *)(v4 + 488);
          v2[11] = *(_DWORD *)(v4 + 496);
          break;
        }
      }
      if ( v2[9] == -1 )
      {
        Com_Printf("^3WARNING^7: Could not find weapon for ammo item %s\n", v2[6]);
        v5 = *(_DWORD *)(dword_AB448 + 4);
        v2[9] = 1;
        v2[10] = *(_DWORD *)(v5 + 488);
        v2[11] = *(_DWORD *)(v5 + 496);
      }
    }
    ++i;
    v2 += 12;
  }
}
// 18A94: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;

//----- (00030DC4) --------------------------------------------------------
int BG_SetupAmmoIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_AB444 )
      break;
    v3 = *(_DWORD **)(dword_AB448 + 4 * i);
    Q_strlwr(v3[121]);
    for ( j = 0; j < dword_D0580; ++j )
    {
      if ( !Q_stricmp(*(int *)((char *)&dword_D0180 + (_DWORD)&dword_0[j]), v3[121]) )
      {
        v3[122] = j;
        if ( *(int *)((char *)&dword_D0380 + (_DWORD)&dword_0[j]) != v3[125] && j )
        {
          for ( k = 1; k < i; ++k )
          {
            v1 = *(_DWORD *)(dword_AB448 + 4 * k);
            if ( !Q_stricmp(*(int *)((char *)&dword_D0180 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 484))
              && *(_DWORD *)(v1 + 500) == *(int *)((char *)&dword_D0380 + (_DWORD)&dword_0[j]) )
            {
              Com_Error(1, byte_9D080, v3[121]);
            }
          }
        }
        break;
      }
    }
    if ( j == dword_D0580 )
    {
      *(int *)((char *)&dword_D0180 + (_DWORD)&dword_0[j]) = v3[121];
      *(int *)((char *)&dword_D0380 + (_DWORD)&dword_0[j]) = v3[125];
      v3[122] = j;
      ++dword_D0580;
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 19904: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;
// D0180: using guessed type int dword_D0180;
// D0380: using guessed type int dword_D0380;
// D0580: using guessed type int dword_D0580;

//----- (00030F9B) --------------------------------------------------------
int BG_SetupSharedAmmoIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_AB444 )
      break;
    v3 = *(_DWORD **)(dword_AB448 + 4 * i);
    v3[128] = -1;
    if ( *(_BYTE *)v3[127] )
    {
      Com_DPrintf("%s: %s\n", v3[1]);
      Q_strlwr(v3[127]);
      for ( j = 0; j < dword_D09A0; ++j )
      {
        if ( !Q_stricmp(*(int *)((char *)&dword_D05A0 + (_DWORD)&dword_0[j]), v3[127]) )
        {
          v3[128] = j;
          if ( *(int *)((char *)&dword_D07A0 + (_DWORD)&dword_0[j]) != v3[129] && j )
          {
            for ( k = 1; k < i; ++k )
            {
              v1 = *(_DWORD *)(dword_AB448 + 4 * k);
              if ( !Q_stricmp(*(int *)((char *)&dword_D05A0 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 508))
                && *(_DWORD *)(v1 + 516) == *(int *)((char *)&dword_D07A0 + (_DWORD)&dword_0[j]) )
              {
                Com_Error(1, byte_9D0E0, v3[127]);
              }
            }
          }
          break;
        }
      }
      if ( j == dword_D09A0 )
      {
        *(int *)((char *)&dword_D05A0 + (_DWORD)&dword_0[j]) = v3[127];
        *(int *)((char *)&dword_D07A0 + (_DWORD)&dword_0[j]) = v3[129];
        v3[128] = j;
        ++dword_D09A0;
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 19904: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;
// D05A0: using guessed type int dword_D05A0;
// D07A0: using guessed type int dword_D07A0;
// D09A0: using guessed type int dword_D09A0;

//----- (000311B7) --------------------------------------------------------
int BG_SetupClipIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_AB444 )
      break;
    v3 = *(_DWORD **)(dword_AB448 + 4 * i);
    Q_strlwr(v3[123]);
    for ( j = 0; j < dword_D0DC0; ++j )
    {
      if ( !Q_stricmp(*(int *)((char *)&dword_D09C0 + (_DWORD)&dword_0[j]), v3[123]) )
      {
        v3[124] = j;
        if ( *(int *)((char *)&dword_D0BC0 + (_DWORD)&dword_0[j]) != v3[126] && j )
        {
          for ( k = 1; k < i; ++k )
          {
            v1 = *(_DWORD *)(dword_AB448 + 4 * k);
            if ( !Q_stricmp(*(int *)((char *)&dword_D09C0 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 492))
              && *(_DWORD *)(v1 + 504) == *(int *)((char *)&dword_D0BC0 + (_DWORD)&dword_0[j]) )
            {
              Com_Error(1, byte_9D160, v3[121]);
            }
          }
        }
        break;
      }
    }
    if ( j == dword_D0DC0 )
    {
      *(int *)((char *)&dword_D09C0 + (_DWORD)&dword_0[j]) = v3[123];
      *(int *)((char *)&dword_D0BC0 + (_DWORD)&dword_0[j]) = v3[126];
      v3[124] = j;
      ++dword_D0DC0;
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 19904: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;
// D09C0: using guessed type int dword_D09C0;
// D0BC0: using guessed type int dword_D0BC0;
// D0DC0: using guessed type int dword_D0DC0;

//----- (0003138E) --------------------------------------------------------
int sub_3138E()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-18h]
  int k; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int l; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  for ( i = 1; i <= dword_AB444; ++i )
    *(_DWORD *)(*(_DWORD *)(dword_AB448 + 4 * i) + 876) = 0;
  for ( j = 1; ; ++j )
  {
    result = j;
    if ( j > dword_AB444 )
      break;
    v3 = *(_DWORD *)(dword_AB448 + 4 * j);
    if ( !*(_DWORD *)(v3 + 876) && **(_BYTE **)(v3 + 872) )
    {
      for ( k = *(_DWORD *)(dword_AB448 + 4 * j); !*(_DWORD *)(k + 876); k = *(_DWORD *)(dword_AB448 + 4 * l) )
      {
        for ( l = 1; l <= dword_AB444; ++l )
        {
          v1 = *(_DWORD *)(dword_AB448 + 4 * l);
          if ( !strcasecmp(*(const char **)(k + 872), *(const char **)(v1 + 4)) )
          {
            *(_DWORD *)(k + 876) = l;
            if ( *(_DWORD *)(k + 132) != *(_DWORD *)(v1 + 132) )
              Com_Error(1, byte_9D1C0, *(_DWORD *)(k + 4));
            if ( *(_DWORD *)(k + 136) != *(_DWORD *)(v1 + 136) )
              Com_Error(1, byte_9D220, *(_DWORD *)(k + 4));
            break;
          }
        }
        if ( !*(_DWORD *)(k + 876) )
          Com_Error(1, byte_9D280, *(_DWORD *)(k + 872));
      }
      if ( k != v3 )
        Com_Error(1, byte_9D2C0, *(_DWORD *)(v3 + 4));
    }
  }
  return result;
}
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;

//----- (000315C3) --------------------------------------------------------
int sub_315C3()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_AB444 )
      break;
    v1 = *(_DWORD *)(dword_AB448 + 4 * i);
    if ( **(_BYTE **)(v1 + 1172) )
    {
      if ( !G_GetHintStringIndex(v1 + 1176, *(char **)(v1 + 1172)) )
        Com_Error(1, byte_9D300, 32);
    }
  }
  return result;
}
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;

//----- (00031659) --------------------------------------------------------
int __cdecl compare_weaponfile_names(_DWORD *a1, _DWORD *a2)
{
  return Q_stricmp(*a1, *a2);
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00031693) --------------------------------------------------------
int BG_SetupWeaponInfo()
{
  char v1; // [esp+4h] [ebp-3244h]
  char v2; // [esp+4h] [ebp-3244h]
  char v3; // [esp+4h] [ebp-3244h]
  char v4; // [esp+8h] [ebp-3240h]
  char dest[8204]; // [esp+10h] [ebp-3238h] BYREF
  char *v6; // [esp+201Ch] [ebp-122Ch]
  char v7[4104]; // [esp+2020h] [ebp-1228h] BYREF
  size_t v8; // [esp+3028h] [ebp-220h]
  int v9; // [esp+302Ch] [ebp-21Ch] BYREF
  int s[130]; // [esp+3030h] [ebp-218h] BYREF
  size_t nmemb; // [esp+3238h] [ebp-10h]
  int i; // [esp+323Ch] [ebp-Ch]

  Com_DPrintf("----------------------\n", v1);
  Com_DPrintf("Game: BG_SetupWeaponInfo\n", v2);
  dword_AB448 = trap_GetWeaponInfoMemory(512, &v9);
  if ( !dword_AB448 )
    Com_Error(1, byte_9D3A0, v4);
  memset(&dword_D0180, 0, 0x200u);
  memset(&dword_D0380, 0, sizeof(dword_D0380));
  dword_D0180 = (int)"none";
  dword_D0580 = 1;
  memset(&dword_D09C0, 0, 0x200u);
  memset(&dword_D0BC0, 0, sizeof(dword_D0BC0));
  dword_D09C0 = (int)"none";
  dword_D0DC0 = 1;
  memset(s, 0, 0x1FCu);
  if ( v9 )
  {
    dword_AB444 = 0;
    for ( i = 1; i <= 127 && *(_DWORD *)(dword_AB448 + 4 * i); ++i )
      ++dword_AB444;
  }
  else
  {
    nmemb = trap_FS_GetFileList(bg_szWeaponsFolder[0], &unk_9CF04, v7, 4096);
    v6 = v7;
    if ( (int)nmemb <= 0 )
      Com_Error(1, byte_9D3E0, (char)bg_szWeaponsFolder[0]);
    if ( (int)nmemb > 127 )
      Com_Error(1, byte_9D400, 127);
    i = 0;
    while ( i < (int)nmemb && i <= 126 )
    {
      v8 = strlen(v6);
      if ( bg_debugWeaponMessages[3] )
      {
        if ( bg_debugWeaponMessages[3] != 2 )
          Com_DPrintf("Getting weapon file \"%s/%s\" for parsing\n", (char)bg_szWeaponsFolder[0]);
      }
      s[i++] = (int)v6;
      v6 += v8 + 1;
    }
    qsort(s, nmemb, 4u, (__compar_fn_t)compare_weaponfile_names);
    dest[0] = 0;
    for ( i = 0; i < (int)nmemb; ++i )
    {
      if ( i > 0 )
        strcat(dest, " ");
      strcat(dest, (const char *)s[i]);
    }
    trap_SetConfigstring(7, dest);
    sub_3073B((int)s, nmemb);
  }
  sub_30AB4();
  BG_SetupAmmoIndexes();
  BG_SetupSharedAmmoIndexes();
  BG_SetupClipIndexes();
  BG_FillInWeaponItems();
  sub_3138E();
  sub_315C3();
  return Com_DPrintf("----------------------\n", v3);
}
// 316B1: variable 'v1' is possibly undefined
// 316BF: variable 'v2' is possibly undefined
// 316FA: variable 'v4' is possibly undefined
// 31A0B: variable 'v3' is possibly undefined
// 16A54: using guessed type int BG_SetupAmmoIndexes(void);
// 17494: using guessed type int BG_FillInWeaponItems(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17C34: using guessed type _DWORD __cdecl trap_GetWeaponInfoMemory(_DWORD, _DWORD);
// 184D4: using guessed type int BG_SetupSharedAmmoIndexes(void);
// 18504: using guessed type _DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD);
// 18C54: using guessed type int BG_SetupClipIndexes(void);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;
// AB464: using guessed type char *bg_szWeaponsFolder[11];
// D0180: using guessed type int dword_D0180;
// D0380: using guessed type int dword_D0380;
// D0580: using guessed type int dword_D0580;
// D09C0: using guessed type int dword_D09C0;
// D0BC0: using guessed type int dword_D0BC0;
// D0DC0: using guessed type int dword_D0DC0;

//----- (00031A19) --------------------------------------------------------
int __cdecl BG_GetInfoForWeapon(int a1)
{
  return *(_DWORD *)(dword_AB448 + 4 * a1);
}
// AB448: using guessed type int dword_AB448;

//----- (00031A3E) --------------------------------------------------------
int __cdecl BG_GetWeaponForInfo(int a1)
{
  return *(_DWORD *)a1;
}

//----- (00031A48) --------------------------------------------------------
int BG_GetNumWeapons()
{
  return dword_AB444;
}
// AB444: using guessed type int dword_AB444;

//----- (00031A60) --------------------------------------------------------
int BG_GetNumAmmoTypes()
{
  return dword_D0580;
}
// D0580: using guessed type int dword_D0580;

//----- (00031A78) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeMax(int a1)
{
  return *(int *)((char *)&dword_D0380 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D0380: using guessed type int dword_D0380;

//----- (00031A94) --------------------------------------------------------
int BG_GetNumAmmoClips()
{
  return dword_D0DC0;
}
// D0DC0: using guessed type int dword_D0DC0;

//----- (00031AAC) --------------------------------------------------------
int __cdecl BG_GetAmmoClipSize(int a1)
{
  return *(int *)((char *)&dword_D0BC0 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D0BC0: using guessed type int dword_D0BC0;

//----- (00031AC8) --------------------------------------------------------
int __cdecl BG_GetSharedAmmoCapSize(int a1)
{
  return *(int *)((char *)&dword_D07A0 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D07A0: using guessed type int dword_D07A0;

//----- (00031AE4) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeName(int a1)
{
  return *(int *)((char *)&dword_D0180 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D0180: using guessed type int dword_D0180;

//----- (00031B00) --------------------------------------------------------
int __cdecl BG_GetAmmoClipName(int a1)
{
  return *(int *)((char *)&dword_D09C0 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D09C0: using guessed type int dword_D09C0;

//----- (00031B1C) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_D0580; ++i )
  {
    if ( !Q_stricmp(*(int *)((char *)&dword_D0180 + (_DWORD)&dword_0[i]), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo type \"%s\"\n", a1);
  return 0;
}
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// D0180: using guessed type int dword_D0180;
// D0580: using guessed type int dword_D0580;

//----- (00031B93) --------------------------------------------------------
int __cdecl BG_GetAmmoClipForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_D0DC0; ++i )
  {
    if ( !Q_stricmp(*(int *)((char *)&dword_D09C0 + (_DWORD)&dword_0[i]), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo clip \"%s\"\n", a1);
  return 0;
}
// 0: using guessed type int dword_0[];
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// D09C0: using guessed type int dword_D09C0;
// D0DC0: using guessed type int dword_D0DC0;

//----- (00031C0A) --------------------------------------------------------
int __cdecl BG_GetWeaponSlotForName(char *s1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 7; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)((char *)off_AB4A0 + (_DWORD)&dword_0[i])) )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// AB4A0: using guessed type char *off_AB4A0[11];

//----- (00031C67) --------------------------------------------------------
int __cdecl BG_GetWeaponSlotNameForIndex(int a1)
{
  return *(int *)((char *)off_AB4A0 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// AB4A0: using guessed type char *off_AB4A0[11];

//----- (00031C83) --------------------------------------------------------
int __cdecl BG_GetWeaponIndexForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= dword_AB444; ++i )
  {
    if ( !Q_stricmp(a1, *(_DWORD *)(*(_DWORD *)(dword_AB448 + 4 * i) + 4)) )
      return (unsigned __int8)i;
  }
  Com_DPrintf("Couldn't find weapon \"%s\"\n", a1);
  return 0;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// AB444: using guessed type int dword_AB444;
// AB448: using guessed type int dword_AB448;

//----- (00031D07) --------------------------------------------------------
int __cdecl BG_IsAimDownSightWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 808);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00031D30) --------------------------------------------------------
int __cdecl BG_GivePlayerWeapon(int a1, int a2)
{
  _DWORD *v4; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( Com_BitCheck(a1 + 1332, a2) )
    return 0;
  v4 = (_DWORD *)BG_GetInfoForWeapon(a2);
  if ( v4[32] == 7 )
    return 0;
  if ( v4[32] == 9 )
    return 0;
  RegisterItem(a2, 1);
  Com_BitSet(a1 + 1332, a2);
  Com_BitClear(a1 + 1356, a2);
  v5 = v4[33];
  if ( v5 )
  {
    if ( v5 <= 2 )
    {
      if ( *(_BYTE *)(a1 + 1349) )
      {
        if ( !*(_BYTE *)(a1 + 1350) )
          *(_BYTE *)(a1 + 1350) = a2;
      }
      else
      {
        *(_BYTE *)(a1 + 1349) = a2;
      }
    }
    else if ( v5 <= 7 && !*(_BYTE *)(v5 + a1 + 1348) )
    {
      *(_BYTE *)(v5 + a1 + 1348) = a2;
    }
  }
  for ( i = v4[219]; i && !Com_BitCheck(a1 + 1332, i); i = *(_DWORD *)(BG_GetInfoForWeapon(i) + 876) )
  {
    RegisterItem(i, 1);
    Com_BitSet(a1 + 1332, i);
    Com_BitClear(a1 + 1356, a2);
  }
  return 1;
}
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18644: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 19804: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);

//----- (00031EFC) --------------------------------------------------------
int __cdecl BG_TakePlayerWeapon(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  if ( !Com_BitCheck(a1 + 1332, a2) )
    return 0;
  v5 = (_DWORD *)BG_GetInfoForWeapon(a2);
  v6 = BG_IsPlayerWeaponInSlot(a1, a2, 1);
  if ( v6 )
  {
    if ( v5[34] )
    {
      for ( i = 1; i <= dword_AB444; ++i )
      {
        v4 = BG_GetInfoForWeapon(a2);
        if ( *(_DWORD *)(v4 + 136)
          && *(_DWORD *)(v4 + 132) == v5[33]
          && Com_BitCheck(a1 + 1332, i)
          && !BG_IsPlayerWeaponInSlot(a1, i, 1) )
        {
          *(_BYTE *)(v6 + a1 + 1348) = i;
          break;
        }
      }
      if ( i > dword_AB444 )
        *(_BYTE *)(v6 + a1 + 1348) = 0;
    }
    else
    {
      *(_BYTE *)(v6 + a1 + 1348) = 0;
    }
  }
  Com_BitClear(a1 + 1332, a2);
  for ( j = v5[219]; j && Com_BitCheck(a1 + 1332, j); j = *(_DWORD *)(BG_GetInfoForWeapon(j) + 876) )
    Com_BitClear(a1 + 1332, j);
  return 1;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17C14: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 18644: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// AB444: using guessed type int dword_AB444;

//----- (000320C5) --------------------------------------------------------
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3)
{
  unsigned int v5; // [esp+10h] [ebp-8h]

  if ( Com_BitCheck(a1 + 1332, a3) )
  {
    v5 = *(_DWORD *)(BG_GetInfoForWeapon(a3) + 132);
    if ( v5 )
    {
      if ( v5 <= 2 )
      {
        if ( a2 != 1 && a2 != 2 )
          return 0;
LABEL_13:
        *(_BYTE *)(a2 + a1 + 1348) = a3;
        return 1;
      }
      if ( v5 <= 7 )
      {
        if ( a2 != v5 )
          return 0;
        goto LABEL_13;
      }
    }
    return 0;
  }
  return 0;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0003217B) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( !Com_BitCheck(a1 + 1332, a2) )
    return 0;
  v7 = a2;
  do
  {
    v6 = BG_GetInfoForWeapon(v7);
    v4 = *(_DWORD *)(v6 + 132);
    if ( !v4 )
      return 0;
    if ( v4 <= 2 )
    {
      if ( *(char *)(a1 + 1349) == v7 )
        return 1;
      if ( *(char *)(a1 + 1350) == v7 )
        return 2;
    }
    else
    {
      if ( v4 > 7 )
        return 0;
      if ( *(char *)(*(_DWORD *)(v6 + 132) + a1 + 1348) == v7 )
        return *(_DWORD *)(v6 + 132);
    }
    if ( a3 && *(_DWORD *)(v6 + 876) )
      v7 = *(_DWORD *)(v6 + 876);
  }
  while ( v7 != a2 );
  return 0;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00032286) --------------------------------------------------------
int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2)
{
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 132);
  if ( !v4 )
    return 0;
  if ( v4 > 2 )
  {
    if ( v4 <= 7 && !*(_BYTE *)(v4 + a1 + 1348) )
      return v4;
    return 0;
  }
  if ( !*(_BYTE *)(a1 + 1349) )
    return 1;
  if ( *(_BYTE *)(a1 + 1350) )
    return 0;
  return 2;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00032319) --------------------------------------------------------
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3)
{
  unsigned int v4; // [esp+8h] [ebp-10h]
  int v6; // [esp+10h] [ebp-8h]

  v6 = BG_GetInfoForWeapon(a2);
  if ( *(_DWORD *)(v6 + 136) )
  {
    v4 = *(_DWORD *)(v6 + 132);
    if ( v4 )
    {
      if ( v4 <= 2 )
      {
        if ( a3 == 1 || a3 == 2 )
        {
          if ( !*(_BYTE *)(a3 + a1 + 1348) )
            return a3;
          if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a3 + a1 + 1348)) + 136) )
            return a3;
        }
        if ( !*(_BYTE *)(a1 + 1349) )
          return 1;
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a1 + 1349)) + 136) )
          return 1;
        if ( !*(_BYTE *)(a1 + 1350) )
          return 2;
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a1 + 1350)) + 136) )
          return 2;
      }
      else if ( v4 <= 7 )
      {
        if ( !*(_BYTE *)(*(_DWORD *)(v6 + 132) + a1 + 1348) )
          return *(_DWORD *)(v6 + 132);
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(*(_DWORD *)(v6 + 132) + a1 + 1348)) + 136) )
          return *(_DWORD *)(v6 + 132);
      }
    }
    return 0;
  }
  return 0;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (000324BB) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = *(_DWORD *)(BG_GetInfoForWeapon(a1) + 876); i; i = *(_DWORD *)(BG_GetInfoForWeapon(i) + 876) )
  {
    if ( i == a2 )
      return 1;
    if ( i == a1 )
      return 0;
  }
  return 0;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00032531) --------------------------------------------------------
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7[128]; // [esp+10h] [ebp-428h] BYREF
  int s[130]; // [esp+210h] [ebp-228h] BYREF
  int v9; // [esp+418h] [ebp-20h]
  int v10; // [esp+41Ch] [ebp-1Ch]
  int v11; // [esp+420h] [ebp-18h]
  int v12; // [esp+424h] [ebp-14h]
  int v13; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  v10 = BG_AmmoForWeapon(a2);
  v9 = BG_ClipForWeapon(a2);
  memset(s, 0, 0x200u);
  memset(v7, 0, sizeof(v7));
  v13 = BG_GetInfoForWeapon(a2);
  if ( *(int *)(v13 + 512) < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
    {
      v4 = BG_GetAmmoClipSize(v9);
      v11 = v4 - *(_DWORD *)(a1 + 4 * v9 + 820);
    }
    else
    {
      v5 = BG_GetAmmoTypeMax(v10);
      v11 = v5 - *(_DWORD *)(a1 + 4 * v10 + 308);
    }
  }
  else
  {
    v11 = BG_GetSharedAmmoCapSize(*(_DWORD *)(v13 + 512));
    for ( i = 1; i <= dword_AB444; ++i )
    {
      if ( Com_BitCheck(a1 + 1332, i) )
      {
        v12 = BG_GetInfoForWeapon(i);
        if ( *(_DWORD *)(v12 + 512) == *(_DWORD *)(v13 + 512) )
        {
          if ( BG_WeaponIsClipOnly(i) )
          {
            if ( !v7[BG_ClipForWeapon(i)] )
            {
              v7[BG_ClipForWeapon(i)] = 1;
              v2 = BG_ClipForWeapon(i);
              v11 -= *(_DWORD *)(a1 + 4 * v2 + 820);
            }
          }
          else if ( !s[BG_AmmoForWeapon(i)] )
          {
            s[BG_AmmoForWeapon(i)] = 1;
            v3 = BG_AmmoForWeapon(i);
            v11 -= *(_DWORD *)(a1 + 4 * v3 + 308);
          }
        }
      }
    }
  }
  return v11;
}
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 18A24: using guessed type _DWORD __cdecl BG_GetSharedAmmoCapSize(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// AB444: using guessed type int dword_AB444;

//----- (0003272F) --------------------------------------------------------
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v5[128]; // [esp+10h] [ebp-428h] BYREF
  int s[130]; // [esp+210h] [ebp-228h] BYREF
  int v7; // [esp+418h] [ebp-20h]
  int v8; // [esp+41Ch] [ebp-1Ch]
  int v9; // [esp+420h] [ebp-18h]
  int v10; // [esp+424h] [ebp-14h]
  int v11; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  v9 = 0;
  v8 = BG_AmmoForWeapon(a2);
  v7 = BG_ClipForWeapon(a2);
  memset(s, 0, 0x200u);
  memset(v5, 0, sizeof(v5));
  v11 = BG_GetInfoForWeapon(a2);
  if ( *(int *)(v11 + 512) < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
      v9 = *(_DWORD *)(a1 + 4 * v7 + 820);
    else
      v9 = *(_DWORD *)(a1 + 4 * v8 + 308);
  }
  else
  {
    for ( i = 1; i <= dword_AB444; ++i )
    {
      if ( Com_BitCheck(a1 + 1332, i) )
      {
        v10 = BG_GetInfoForWeapon(i);
        if ( *(_DWORD *)(v10 + 512) == *(_DWORD *)(v11 + 512) )
        {
          if ( BG_WeaponIsClipOnly(i) )
          {
            if ( !v5[BG_ClipForWeapon(i)] )
            {
              v5[BG_ClipForWeapon(i)] = 1;
              v2 = BG_ClipForWeapon(i);
              v9 += *(_DWORD *)(a1 + 4 * v2 + 820);
            }
          }
          else if ( !s[BG_AmmoForWeapon(i)] )
          {
            s[BG_AmmoForWeapon(i)] = 1;
            v3 = BG_AmmoForWeapon(i);
            v9 += *(_DWORD *)(a1 + 4 * v3 + 308);
          }
        }
      }
    }
  }
  return v9;
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// AB444: using guessed type int dword_AB444;

//----- (00032902) --------------------------------------------------------
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  float v7; // [esp+14h] [ebp-14h]
  float v8; // [esp+18h] [ebp-10h]
  float *v9; // [esp+20h] [ebp-8h]

  v9 = (float *)BG_GetInfoForWeapon(a2);
  if ( (long double)*(int *)(a1 + 256) != *(float *)(a1 + 248) && *(_DWORD *)(a1 + 252) )
  {
    v8 = (long double)(a3 - *(_DWORD *)(a1 + 252))
       / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 256), *(_DWORD *)(a1 + 260));
    if ( v8 >= 0.0 )
    {
      if ( v8 > 1.0 )
        v8 = 1.0;
    }
    else
    {
      v8 = 0.0;
    }
    if ( a4 )
    {
      if ( *(_DWORD *)(a1 + 256) == *(_DWORD *)(a1 + 1396) )
      {
        v7 = (v9[262] - v9[261]) * v8 + v9[261];
      }
      else if ( *(_DWORD *)(a1 + 256) == *(_DWORD *)(a1 + 1404) )
      {
        v7 = (v9[260] - v9[261]) * v8 + v9[261];
      }
      else
      {
        if ( *(_DWORD *)(a1 + 260) )
          v5 = (v9[261] - v9[260]) * v8 + v9[260];
        else
          v5 = (v9[261] - v9[262]) * v8 + v9[262];
        v7 = v5;
      }
    }
    else if ( *(_DWORD *)(a1 + 256) == *(_DWORD *)(a1 + 1396) )
    {
      v7 = (v9[168] - v9[167]) * v8 + v9[167];
    }
    else if ( *(_DWORD *)(a1 + 256) == *(_DWORD *)(a1 + 1404) )
    {
      v7 = (v9[166] - v9[167]) * v8 + v9[167];
    }
    else
    {
      if ( *(_DWORD *)(a1 + 260) )
        v4 = (v9[167] - v9[166]) * v8 + v9[166];
      else
        v4 = (v9[167] - v9[168]) * v8 + v9[168];
      v7 = v4;
    }
  }
  else if ( a4 )
  {
    if ( (*(_DWORD *)(a1 + 12) & 1) != 0 )
    {
      v7 = v9[262];
    }
    else if ( (*(_DWORD *)(a1 + 12) & 2) != 0 )
    {
      v7 = v9[261];
    }
    else
    {
      v7 = v9[260];
    }
  }
  else if ( (*(_DWORD *)(a1 + 12) & 1) != 0 )
  {
    v7 = v9[168];
  }
  else if ( (*(_DWORD *)(a1 + 12) & 2) != 0 )
  {
    v7 = v9[167];
  }
  else
  {
    v7 = v9[166];
  }
  return v7;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18974: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);

//----- (00032C0B) --------------------------------------------------------
int PM_UpdateAimDownSightFlag()
{
  int result; // eax
  int v1; // [esp+5Ch] [ebp-4Ch]
  float v2[4]; // [esp+60h] [ebp-48h] BYREF
  int v3[4]; // [esp+70h] [ebp-38h] BYREF
  float v4[2]; // [esp+80h] [ebp-28h] BYREF
  float v5; // [esp+88h] [ebp-20h]
  int v6; // [esp+9Ch] [ebp-Ch]

  result = *(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x4000;
  if ( !result )
  {
    if ( *(int *)(*(_DWORD *)pm[0] + 4) <= 5
      && (*(_BYTE *)(pm[0] + 8) & 0x10) != 0
      && (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
    }
    else if ( *(int *)(*(_DWORD *)pm[0] + 4) > 5
           || (*(_BYTE *)(pm[0] + 8) & 0x10) == 0
           || !*(_DWORD *)(LODWORD(pml[34]) + 808)
           || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 2
           || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 1
           || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 10
           || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11
           || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 13
           && *(_DWORD *)(*(_DWORD *)pm[0] + 216) != *(unsigned __int8 *)(pm[0] + 10)
           || !LODWORD(pml[13]) && *(_DWORD *)(*(_DWORD *)pm[0] + 4) != 1 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFFFDF;
    }
    else
    {
      v6 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
      if ( *(_DWORD *)(v6 + 128) == 3 )
      {
        if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 )
        {
          v3[0] = *(_DWORD *)(*(_DWORD *)pm[0] + 232);
          v3[1] = *(_DWORD *)(*(_DWORD *)pm[0] + 236);
          v3[0] = 0;
          v3[2] = 0;
          AngleVectors(v3, v2, 0, 0);
          v4[0] = v2[0] * 15.0 + *(float *)(*(_DWORD *)pm[0] + 20);
          v4[1] = v2[1] * 15.0 + *(float *)(*(_DWORD *)pm[0] + 24);
          v5 = v2[2] * 15.0 + *(float *)(*(_DWORD *)pm[0] + 28);
          v5 = v5 + 1.0;
          v1 = (*(int (__cdecl **)(float *, _DWORD, void *))(pm[0] + 272))(
                 v4,
                 *(_DWORD *)(*(_DWORD *)pm[0] + 212),
                 &unk_404000);
          if ( v1 )
          {
            if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 )
              *(_DWORD *)(*(_DWORD *)pm[0] + 1444) = *(_DWORD *)(*(_DWORD *)pm[0] + 236);
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
            if ( (v1 & 0x400000) != 0 )
              *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 2u;
            else
              *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFFFFD;
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFFFFE;
          }
          else if ( *(_DWORD *)(*(_DWORD *)pm[0] + 1476) == 7 )
          {
            if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 )
              *(_DWORD *)(*(_DWORD *)pm[0] + 1444) = *(_DWORD *)(*(_DWORD *)pm[0] + 236);
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
            if ( *(_DWORD *)(*(_DWORD *)pm[0] + 1480) )
              *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 2u;
            else
              *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFFFFD;
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) &= 0xFFFFFFFE;
          }
          else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) != 0
                 || *(_DWORD *)(*(_DWORD *)pm[0] + 88) != 1023
                 && BG_CheckProneValid(
                      *(_DWORD *)(*(_DWORD *)pm[0] + 212),
                      *(_DWORD *)pm[0] + 20,
                      *(_DWORD *)(pm[0] + 228),
                      1106247680,
                      *(float *)(*(_DWORD *)pm[0] + 236),
                      *(_DWORD *)pm[0] + 1544,
                      *(_DWORD *)pm[0] + 1548,
                      *(_DWORD *)pm[0] + 1552,
                      0,
                      *(_DWORD *)(*(_DWORD *)pm[0] + 88) != 1023,
                      0,
                      *(_DWORD *)(pm[0] + 268),
                      *(_DWORD *)(pm[0] + 264),
                      0,
                      60.0,
                      1,
                      *(_DWORD *)(pm[0] + 276)) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 && (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) == 0 )
              *(_DWORD *)(*(_DWORD *)pm[0] + 1444) = *(_DWORD *)(*(_DWORD *)pm[0] + 236);
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 1u;
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
          }
          else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) == 0 )
          {
            *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x8000u;
            if ( (*(_BYTE *)(pm[0] + 9) & 2) == 0 )
            {
              if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 2) != 0 )
                BG_AddPredictableEventToPlayerstate(143, 0, *(_DWORD *)pm[0]);
              else
                BG_AddPredictableEventToPlayerstate(142, 0, *(_DWORD *)pm[0]);
            }
          }
        }
      }
      else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) != 0 )
      {
        if ( (*(_BYTE *)(pm[0] + 32) & 0x10) == 0 || !*(_BYTE *)(pm[0] + 24) && !*(_BYTE *)(pm[0] + 25) )
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
          *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x400u;
        }
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x20u;
      }
    }
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 )
      result = BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm[0] + 212), 9, 1, 1);
    else
      result = BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm[0] + 212), 9, 0, 1);
  }
  return result;
}
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003346F) --------------------------------------------------------
unsigned int PM_ClearAimDownSightFlag()
{
  unsigned int result; // eax

  result = *(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0xFFFFFFDF;
  *(_DWORD *)(*(_DWORD *)pm[0] + 12) = result;
  return result;
}

//----- (0003349E) --------------------------------------------------------
void PM_UpdateAimDownSightLerp()
{
  long double v0; // fst7
  int v1; // [esp+0h] [ebp-8h]

  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x4000) == 0 )
  {
    if ( *(_DWORD *)(LODWORD(pml[34]) + 808) || (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0 )
    {
      v1 = 0;
      if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0 && (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 )
      {
        v1 = 1;
      }
      else if ( !*(_DWORD *)(LODWORD(pml[34]) + 860)
             && *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
             && *(_DWORD *)(*(_DWORD *)pm[0] + 44) - *(_DWORD *)(LODWORD(pml[34]) + 1120) > 0
             && *(_DWORD *)(LODWORD(pml[34]) + 128) != 3
             || *(_DWORD *)(LODWORD(pml[34]) + 860)
             && *(_DWORD *)(LODWORD(pml[34]) + 128) != 3
             && (*(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9
              && *(_DWORD *)(*(_DWORD *)pm[0] + 44) - *(_DWORD *)(LODWORD(pml[34]) + 1120) > 0)
             || !*(_DWORD *)(LODWORD(pml[34]) + 812) && *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4 )
      {
        v1 = 0;
      }
      else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 )
      {
        v1 = 1;
      }
      if ( *(_DWORD *)(LODWORD(pml[34]) + 840)
        && *(_DWORD *)(*(_DWORD *)pm[0] + 48)
        && *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3 )
      {
        v1 = 1;
      }
      if ( v1 && *(float *)(*(_DWORD *)pm[0] + 224) != 1.0 || !v1 && *(float *)(*(_DWORD *)pm[0] + 224) != 0.0 )
      {
        if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0 && *(_DWORD *)(*(_DWORD *)pm[0] + 1556) == 1 )
        {
          if ( v1 )
            *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 1065353216;
          else
            *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 0;
        }
        else
        {
          if ( v1 )
            v0 = (long double)SLODWORD(pml[10]) * *(float *)(LODWORD(pml[34]) + 1204)
               + *(float *)(*(_DWORD *)pm[0] + 224);
          else
            v0 = *(float *)(*(_DWORD *)pm[0] + 224)
               - (long double)SLODWORD(pml[10]) * *(float *)(LODWORD(pml[34]) + 1208);
          *(float *)(*(_DWORD *)pm[0] + 224) = v0;
        }
        if ( *(float *)(*(_DWORD *)pm[0] + 224) < 1.0 )
        {
          if ( *(float *)(*(_DWORD *)pm[0] + 224) <= 0.0 )
            *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 0;
        }
        else
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 1065353216;
        }
      }
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 0;
    }
  }
}

//----- (000338B0) --------------------------------------------------------
int PM_InteruptWeaponWithProneMove()
{
  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0
    && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 128) == 3 )
  {
    return 0;
  }
  if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 220)
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 1
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 2
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4 )
  {
    return 1;
  }
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_34024(0);
  return 1;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00033A44) --------------------------------------------------------
int PM_InteruptWeaponWithSprintMove()
{
  if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 220)
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 1
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 2
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4 )
  {
    return 1;
  }
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 10
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11 )
  {
    return 0;
  }
  *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_34024(10);
  return 1;
}

//----- (00033BAD) --------------------------------------------------------
int __cdecl BG_ClipForWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 496);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00033BD6) --------------------------------------------------------
int __cdecl BG_AmmoForWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 488);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00033BFF) --------------------------------------------------------
int __cdecl BG_WeaponIsClipOnly(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 832);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00033C28) --------------------------------------------------------
int __cdecl BG_WeaponAmmo(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]

  v3 = BG_AmmoForWeapon(a2);
  return *(_DWORD *)(a1 + 4 * v3 + 308) + *(_DWORD *)(a1 + 4 * BG_ClipForWeapon(a2) + 820);
}
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00033C78) --------------------------------------------------------
int sub_33C78()
{
  int result; // eax
  float v1; // esi
  float v2; // esi
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 7 && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 8
    || (result = LODWORD(pml[34]), *(_DWORD *)(result + 868)) )
  {
    v7 = BG_AmmoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
    v6 = BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
    v5 = *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v7 + 308);
    v4 = *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v6 + 820);
    v3 = BG_GetAmmoClipSize(v6) - v4;
    if ( v3 > v5 )
      v3 = v5;
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8 )
    {
      v1 = pml[34];
      result = BG_GetAmmoClipSize(v6);
      if ( *(_DWORD *)(LODWORD(v1) + 868) < result )
      {
        result = v3;
        if ( v3 > *(_DWORD *)(LODWORD(pml[34]) + 868) )
        {
          result = *(_DWORD *)(LODWORD(pml[34]) + 868);
          v3 = result;
        }
      }
    }
    else
    {
      result = LODWORD(pml[34]);
      if ( *(_DWORD *)(result + 864) )
      {
        v2 = pml[34];
        result = BG_GetAmmoClipSize(v6);
        if ( *(_DWORD *)(LODWORD(v2) + 864) < result )
        {
          result = v3;
          if ( v3 > *(_DWORD *)(LODWORD(pml[34]) + 864) )
          {
            result = *(_DWORD *)(LODWORD(pml[34]) + 864);
            v3 = result;
          }
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v7 + 308) -= v3;
      result = *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v6 + 820) + v3;
      *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v6 + 820) = result;
    }
  }
  return result;
}
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00033E90) --------------------------------------------------------
int __cdecl PM_WeaponUseAmmo(int a1, int a2)
{
  int result; // eax

  result = BG_ClipForWeapon(a1);
  *(_DWORD *)(*(_DWORD *)pm[0] + 4 * result + 820) -= a2;
  if ( *(int *)(*(_DWORD *)pm[0] + 4 * result + 820) < 0 )
    *(_DWORD *)(*(_DWORD *)pm[0] + 4 * result + 820) = 0;
  return result;
}
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (00033F16) --------------------------------------------------------
int __cdecl PM_WeaponAmmoAvailable(int a1)
{
  return *(_DWORD *)(*(_DWORD *)pm[0] + 4 * BG_ClipForWeapon(a1) + 820);
}
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (00033F50) --------------------------------------------------------
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1)
{
  int v1; // esi

  v1 = *(_DWORD *)pm[0];
  return *(_DWORD *)(v1 + 4 * BG_ClipForWeapon(a1) + 820) == 0;
}
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (00033F9C) --------------------------------------------------------
int __cdecl sub_33F9C(int a1)
{
  int result; // eax

  result = *(_DWORD *)pm[0];
  if ( *(int *)(*(_DWORD *)pm[0] + 4) <= 5 )
  {
    result = pm[0];
    if ( *(_BYTE *)(pm[0] + 10) )
    {
      if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 4 )
      {
        result = a1;
        *(_DWORD *)(*(_DWORD *)pm[0] + 1572) = a1;
      }
      else
      {
        result = a1 | *(_DWORD *)(*(_DWORD *)pm[0] + 1572) & 0x200 ^ 0x200;
        *(_DWORD *)(*(_DWORD *)pm[0] + 1572) = result;
      }
    }
  }
  return result;
}

//----- (00034024) --------------------------------------------------------
unsigned int __cdecl sub_34024(int a1)
{
  unsigned int result; // eax

  result = pm[0];
  if ( *(_BYTE *)(pm[0] + 10) )
  {
    result = *(_DWORD *)(*(_DWORD *)pm[0] + 1572) & 0xFFFFFDFF;
    if ( result != a1 )
      result = sub_33F9C(a1);
  }
  return result;
}

//----- (00034073) --------------------------------------------------------
int sub_34073()
{
  int result; // eax

  sub_34024(0);
  result = *(_DWORD *)pm[0];
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  return result;
}

//----- (000340AB) --------------------------------------------------------
int __cdecl sub_340AB(int a1)
{
  if ( !*(_DWORD *)(LODWORD(pml[34]) + 804)
    || !Com_BitCheck(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
  {
    return 0;
  }
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 4
    || !a1
    || (Com_BitClear(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216)),
        PM_AddEvent(168),
        !*(_DWORD *)(*(_DWORD *)pm[0] + 44)) )
  {
    if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 44)
      || *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 3
      && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 4
      && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 10
      && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 11
      && !*(_DWORD *)(*(_DWORD *)pm[0] + 48) )
    {
      if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4 )
      {
        sub_34073();
      }
      else if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 220) )
      {
        if ( *(float *)(*(_DWORD *)pm[0] + 224) <= 0.75 )
          sub_33F9C(4);
        else
          sub_33F9C(7);
        *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 4;
        *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 560);
        if ( *(_DWORD *)(LODWORD(pml[34]) + 564)
          && *(_DWORD *)(LODWORD(pml[34]) + 564) < *(_DWORD *)(LODWORD(pml[34]) + 560) )
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 48) = *(_DWORD *)(LODWORD(pml[34]) + 564);
        }
        else
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 1;
        }
        PM_AddEvent(167);
      }
    }
    return 0;
  }
  return 1;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18644: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);

//----- (00034320) --------------------------------------------------------
int sub_34320()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8 )
  {
    if ( *(_DWORD *)(LODWORD(pml[34]) + 592) )
    {
      if ( *(_DWORD *)(LODWORD(pml[34]) + 592) >= *(_DWORD *)(LODWORD(pml[34]) + 588) )
        v1 = *(_DWORD *)(LODWORD(pml[34]) + 588);
      else
        v1 = *(_DWORD *)(LODWORD(pml[34]) + 592);
    }
    else
    {
      v1 = 0;
    }
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 4 * BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 820)
      || *(_DWORD *)(LODWORD(pml[34]) + 124) )
    {
      v1 = *(_DWORD *)(LODWORD(pml[34]) + 576);
    }
    else
    {
      v1 = *(_DWORD *)(LODWORD(pml[34]) + 580);
    }
    if ( *(_DWORD *)(LODWORD(pml[34]) + 584) && *(_DWORD *)(LODWORD(pml[34]) + 584) < v1 )
      v1 = *(_DWORD *)(LODWORD(pml[34]) + 584);
  }
  result = LODWORD(pml[34]);
  if ( *(_DWORD *)(result + 804)
    && (result = Com_BitCheck(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216))) != 0 )
  {
    if ( !v1 )
      v1 = *(_DWORD *)(*(_DWORD *)pm[0] + 44);
    if ( *(_DWORD *)(LODWORD(pml[34]) + 564) < v1 )
      v1 = *(_DWORD *)(LODWORD(pml[34]) + 564);
    if ( !v1 )
      v1 = 1;
    result = v1;
    *(_DWORD *)(*(_DWORD *)pm[0] + 48) = v1;
  }
  else if ( v1 )
  {
    result = v1;
    *(_DWORD *)(*(_DWORD *)pm[0] + 48) = v1;
  }
  return result;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0003454B) --------------------------------------------------------
int sub_3454B()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 4 * BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 820)
    || *(_DWORD *)(LODWORD(pml[34]) + 124) )
  {
    sub_33F9C(11);
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 576);
    PM_AddEvent(153);
  }
  else
  {
    sub_33F9C(12);
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 580);
    PM_AddEvent(154);
  }
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8 )
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 6;
  else
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 5;
  return sub_34320();
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (00034659) --------------------------------------------------------
int sub_34659()
{
  int result; // eax
  int v1; // esi

  if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 220)
    || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3
    || (result = *(_DWORD *)pm[0], *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4) )
  {
    result = *(_DWORD *)pm[0];
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 216) )
    {
      v1 = *(_DWORD *)pm[0];
      result = BG_GetNumWeapons();
      if ( *(_DWORD *)(v1 + 216) <= result )
      {
        if ( !BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
          BG_AnimScriptEvent(*(_DWORD *)pm[0], 10, 0, 1);
        if ( *(_DWORD *)(LODWORD(pml[34]) + 860) && *(_DWORD *)(LODWORD(pml[34]) + 588) )
        {
          sub_33F9C(13);
          *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 588);
          *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 7;
          PM_AddEvent(155);
          result = sub_34320();
        }
        else
        {
          result = sub_3454B();
        }
      }
    }
  }
  return result;
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000347AA) --------------------------------------------------------
int sub_347AA()
{
  int result; // eax

  result = *(_DWORD *)pm[0];
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 12 )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 12;
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 708);
    sub_33F9C(19);
    PM_AddEvent(160);
    result = BG_AnimScriptEvent(*(_DWORD *)pm[0], 14, 0, 1);
  }
  return result;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003484C) --------------------------------------------------------
int sub_3484C()
{
  int result; // eax

  result = *(_DWORD *)pm[0];
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 13 )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 13;
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 712);
    sub_33F9C(20);
    PM_AddEvent(161);
    result = BG_AnimScriptEvent(*(_DWORD *)pm[0], 15, 0, 1);
  }
  return result;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000348EE) --------------------------------------------------------
void __cdecl sub_348EE(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  if ( a2 >= 0
    && a2 <= BG_GetNumWeapons()
    && (!a2 || Com_BitCheck(*(_DWORD *)pm[0] + 1332, a2))
    && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 2
    && (*(_DWORD *)(LODWORD(pml[34]) + 128) != 3 && *(_DWORD *)(LODWORD(pml[34]) + 128) != 8
     || (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 && *(float *)(*(_DWORD *)pm[0] + 224) <= 0.000099999997) )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
    if ( a1 && Com_BitCheck(*(_DWORD *)pm[0] + 1332, a1) && *(int *)(*(_DWORD *)pm[0] + 52) <= 0 )
    {
      v6 = (_DWORD *)BG_GetInfoForWeapon(a1);
      BG_GetInfoForWeapon(a2);
      v4 = 0;
      if ( a2 && a2 == v6[219] )
        v4 = 1;
      v7 = 1;
      if ( BG_WeaponIsClipOnly(a1) )
      {
        v2 = *(_DWORD *)pm[0];
        if ( !*(_DWORD *)(v2 + 4 * BG_ClipForWeapon(a1) + 820) )
          v7 = 0;
      }
      *(_DWORD *)(*(_DWORD *)pm[0] + 52) = 0;
      if ( v4 )
      {
        PM_AddEvent(159);
        sub_33F9C(15);
      }
      else if ( v7 )
      {
        PM_AddEvent(158);
        sub_33F9C(9);
      }
      if ( !v4 )
        BG_AnimScriptEvent(*(_DWORD *)pm[0], 6, 0, 0);
      *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 2;
      PM_SetProneMovementOverride();
      if ( v4 )
        v3 = v6[152];
      else
        v3 = v6[150];
      *(_DWORD *)(*(_DWORD *)pm[0] + 44) = v3;
      if ( v4 )
      {
        v5 = BG_IsPlayerWeaponInSlot(*(_DWORD *)pm[0], a1, 1);
        if ( v5 )
          BG_SetPlayerWeaponForSlot(*(_DWORD *)pm[0], v5, a2);
      }
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
      *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 2;
      *(_DWORD *)(*(_DWORD *)pm[0] + 52) = 0;
      PM_SetProneMovementOverride();
      BG_AddPredictableEventToPlayerstate(202, a1, *(_DWORD *)pm[0]);
    }
  }
}
// 16944: using guessed type int PM_SetProneMovementOverride(void);
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 17C14: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 19744: using guessed type _DWORD __cdecl BG_SetPlayerWeaponForSlot(_DWORD, _DWORD, _DWORD);

//----- (00034C14) --------------------------------------------------------
int sub_34C14()
{
  int v0; // eax
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v4; // eax
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 2 )
    return 0;
  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10) == 0
    && Com_BitCheck(*(_DWORD *)pm[0] + 1332, *(unsigned __int8 *)(pm[0] + 10))
    && (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x400000) == 0
    && Com_BitCheck(*(_DWORD *)pm[0] + 1332, *(unsigned __int8 *)(pm[0] + 10))
    && ((*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) == 0
     || (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x400000) != 0
     || BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(*(_DWORD *)pm[0] + 1560), *(_DWORD *)(*(_DWORD *)pm[0] + 1556))) )
  {
    v8 = *(unsigned __int8 *)(pm[0] + 10);
    if ( v8 > BG_GetNumWeapons() )
      v8 = 0;
    v0 = Com_BitCheck(*(_DWORD *)pm[0] + 1332, v8);
  }
  else
  {
    v8 = 0;
    v0 = Com_BitCheck(*(_DWORD *)pm[0] + 1332, 0);
  }
  if ( !v0 )
    v8 = 0;
  v9 = *(_DWORD *)(*(_DWORD *)pm[0] + 216);
  *(_DWORD *)(*(_DWORD *)pm[0] + 216) = (unsigned __int8)v8;
  LODWORD(pml[34]) = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
  if ( v9 == v8 )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
    sub_33F9C(0);
    v7 = 1;
  }
  else if ( v9 )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 1;
    PM_SetProneMovementOverride();
    if ( *(_DWORD *)(BG_GetInfoForWeapon(v8) + 128) == 3 )
      *(_DWORD *)(*(_DWORD *)pm[0] + 224) = 0;
    v6 = 0;
    if ( v8 && v8 == *(_DWORD *)(BG_GetInfoForWeapon(v9) + 876) )
      v6 = 1;
    if ( v6 )
    {
      v2 = *(_DWORD *)pm[0];
      *(_DWORD *)(v2 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 612);
    }
    else
    {
      PM_AddEvent(157);
      v3 = *(_DWORD *)pm[0];
      *(_DWORD *)(v3 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 604);
    }
    BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm[0] + 212), 0, v8, 1);
    v4 = BG_GetInfoForWeapon(v8);
    BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)pm[0] + 212), 1, *(_DWORD *)(v4 + 128), 1);
    if ( v8 && v8 == *(_DWORD *)(BG_GetInfoForWeapon(v9) + 876) )
    {
      if ( *(float *)(*(_DWORD *)pm[0] + 1576) < 128.0 )
        *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1124073472;
      sub_33F9C(16);
    }
    else
    {
      BG_AnimScriptEvent(*(_DWORD *)pm[0], 7, 0, 0);
      *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1132396544;
      sub_33F9C(10);
    }
    v7 = 1;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 1;
    v1 = *(_DWORD *)pm[0];
    *(_DWORD *)(v1 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 604);
    *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1132396544;
    sub_33F9C(10);
    PM_SetProneMovementOverride();
    v7 = 1;
  }
  return v7;
}
// 16944: using guessed type int PM_SetProneMovementOverride(void);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 18734: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00035064) --------------------------------------------------------
int sub_35064()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 1 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_33F9C(0);
  return 1;
}

//----- (000350C2) --------------------------------------------------------
int sub_350C2()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 12 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_33F9C(0);
  return 1;
}

//----- (00035120) --------------------------------------------------------
int sub_35120()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 13 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_33F9C(0);
  return 1;
}

//----- (0003517E) --------------------------------------------------------
int sub_3517E()
{
  int v0; // edi
  float v1; // esi
  int v4; // [esp+18h] [ebp-10h]

  v4 = BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
  if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 4 * BG_AmmoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 308) )
    return 0;
  v0 = *(_DWORD *)pm[0];
  if ( *(_DWORD *)(v0 + 4 * v4 + 820) >= BG_GetAmmoClipSize(v4) )
    return 0;
  if ( !*(_DWORD *)(LODWORD(pml[34]) + 856) )
    return 1;
  if ( *(_DWORD *)(LODWORD(pml[34]) + 864) )
  {
    v1 = pml[34];
    if ( *(_DWORD *)(LODWORD(v1) + 864) < BG_GetAmmoClipSize(v4) )
      return BG_GetAmmoClipSize(v4) - *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v4 + 820) >= *(_DWORD *)(LODWORD(pml[34]) + 864);
  }
  return !*(_DWORD *)(*(_DWORD *)pm[0] + 4 * v4 + 820);
}
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (000352D2) --------------------------------------------------------
int sub_352D2()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+10h] [ebp-8h]

  if ( !*(_DWORD *)(LODWORD(pml[34]) + 804)
    || !Com_BitCheck(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
  {
    return sub_33C78();
  }
  Com_BitClear(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216));
  PM_AddEvent(168);
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 7 && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 8
    || (result = LODWORD(pml[34]), *(_DWORD *)(result + 592)) )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 44) )
    {
      if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8 )
      {
        v2 = *(_DWORD *)(LODWORD(pml[34]) + 592) >= *(_DWORD *)(LODWORD(pml[34]) + 588) ? *(_DWORD *)(LODWORD(pml[34]) + 588) : *(_DWORD *)(LODWORD(pml[34]) + 592);
      }
      else
      {
        v2 = *(_DWORD *)(*(_DWORD *)pm[0] + 4 * BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 820)
          || *(_DWORD *)(LODWORD(pml[34]) + 124) ? *(_DWORD *)(LODWORD(pml[34]) + 576) : *(_DWORD *)(LODWORD(pml[34]) + 580);
        if ( *(_DWORD *)(LODWORD(pml[34]) + 584) && *(_DWORD *)(LODWORD(pml[34]) + 584) < v2 )
          v2 = *(_DWORD *)(LODWORD(pml[34]) + 584);
      }
      v1 = *(_DWORD *)(LODWORD(pml[34]) + 564) >= v2 ? 1 : *(_DWORD *)(LODWORD(pml[34]) + 564);
      v3 = v2 - v1;
      if ( v3 > 0 )
      {
        result = v3;
        *(_DWORD *)(*(_DWORD *)pm[0] + 48) = v3;
        return result;
      }
    }
    return sub_33C78();
  }
  return result;
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18644: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (00035564) --------------------------------------------------------
int __cdecl sub_35564(int a1)
{
  int v1; // esi

  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 7 && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 8 )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
      sub_33F9C(0);
    }
    else if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6 )
    {
      if ( a1 )
      {
        sub_352D2();
        if ( *(_DWORD *)(*(_DWORD *)pm[0] + 44) )
          return 1;
      }
      if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 44) )
      {
        Com_BitClear(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216));
        if ( *(_DWORD *)(LODWORD(pml[34]) + 860) )
        {
          if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 6 && sub_3517E() )
          {
            sub_3454B();
            return 1;
          }
          if ( *(_DWORD *)(LODWORD(pml[34]) + 596) )
          {
            *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 9;
            sub_33F9C(14);
            *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 596);
            PM_AddEvent(156);
            return 1;
          }
        }
        *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
        sub_33F9C(0);
      }
      if ( a1 )
        return 1;
    }
    return 0;
  }
  if ( a1 )
    sub_352D2();
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 44) )
    return 1;
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 8
    || (v1 = *(_DWORD *)pm[0], !*(_DWORD *)(v1 + 4 * BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 820)) )
  {
    if ( sub_3517E() )
    {
      sub_3454B();
      return 1;
    }
  }
  Com_BitClear(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216));
  if ( *(_DWORD *)(LODWORD(pml[34]) + 596) )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 9;
    sub_33F9C(14);
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 596);
    PM_AddEvent(156);
    return 1;
  }
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  sub_33F9C(0);
  return 0;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18644: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (000358B2) --------------------------------------------------------
void sub_358B2()
{
  int v0; // [esp+14h] [ebp-14h]
  int v1; // [esp+18h] [ebp-10h]
  int v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]

  v2 = 0;
  v3 = *(_BYTE *)(pm[0] + 9) & 8;
  if ( *(_DWORD *)(LODWORD(pml[34]) + 860)
    && (*(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7 || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5)
    && (*(_BYTE *)(pm[0] + 8) & 1) != 0
    && (*(_BYTE *)(pm[0] + 32) & 1) == 0 )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 8;
    }
    else if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 6;
    }
  }
  if ( (*(_DWORD *)(LODWORD(pml[34]) + 128) != 3
     || (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 && *(float *)(*(_DWORD *)pm[0] + 224) >= 0.99000001)
    && (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10000) == 0 )
  {
    switch ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) )
    {
      case 1:
      case 2:
      case 0xA:
      case 0xB:
      case 0xC:
      case 0xD:
        return;
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        if ( *(_DWORD *)(pm[0] + 256) )
        {
          if ( !BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
            BG_AnimScriptEvent(*(_DWORD *)pm[0], 10, 0, 1);
        }
        break;
      default:
        v1 = BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
        v0 = BG_AmmoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
        if ( v3 && sub_3517E() )
          v2 = 1;
        if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 4 * v1 + 820)
          && *(_DWORD *)(*(_DWORD *)pm[0] + 4 * v0 + 308)
          && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 3
          && ((*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) == 0 || !*(_BYTE *)(pm[0] + 24) && !*(_BYTE *)(pm[0] + 25)) )
        {
          v2 = 1;
        }
        if ( v2 )
          sub_34659();
        break;
    }
  }
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00035B66) --------------------------------------------------------
void sub_35B66()
{
  if ( (*(_DWORD *)(LODWORD(pml[34]) + 128) == 3 || *(_DWORD *)(LODWORD(pml[34]) + 128) == 8)
    && !*(_DWORD *)(pm[0] + 280) )
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) > 0xDu )
    {
LABEL_9:
      if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0
        || *(float *)(*(_DWORD *)pm[0] + 224) == 1.0
        || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 12 )
      {
        if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0
          && *(float *)(*(_DWORD *)pm[0] + 224) != 0.0
          && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 13 )
        {
          sub_3484C();
        }
      }
      else
      {
        sub_347AA();
      }
    }
    else
    {
      switch ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) )
      {
        case 0:
        case 3:
        case 4:
        case 0xC:
          goto LABEL_9;
        case 1:
        case 2:
        case 0xA:
        case 0xB:
          return;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
          if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0 )
            goto LABEL_9;
          break;
        case 0xD:
          if ( *(_DWORD *)(pm[0] + 256) )
            BG_AnimScriptEvent(*(_DWORD *)pm[0], 15, 1, 1);
          goto LABEL_9;
      }
    }
  }
}
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00035CE8) --------------------------------------------------------
int sub_35CE8()
{
  int result; // eax
  int v1; // esi
  int v2; // esi

  result = BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
  if ( result )
  {
    result = LODWORD(pml[34]);
    if ( *(_DWORD *)(result + 128) != 8 )
    {
      v1 = *(_DWORD *)pm[0];
      result = BG_ClipForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
      if ( !*(_DWORD *)(v1 + 4 * result + 820) )
      {
        v2 = *(_DWORD *)pm[0];
        result = BG_AmmoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216));
        if ( !*(_DWORD *)(v2 + 4 * result + 308) )
        {
          BG_TakePlayerWeapon(*(_DWORD *)pm[0], *(_DWORD *)(*(_DWORD *)pm[0] + 216));
          result = PM_AddEvent(151);
        }
      }
    }
  }
  return result;
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00035DCB) --------------------------------------------------------
void PM_AdjustAimSpreadScale()
{
  long double v0; // fst7
  float v1; // [esp+0h] [ebp-38h]
  float v2; // [esp+4h] [ebp-34h]
  float v3; // [esp+14h] [ebp-24h]
  float v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int j; // [esp+30h] [ebp-8h]

  v4 = *(float *)(LODWORD(pml[34]) + 680);
  if ( v4 == 0.0 )
  {
    v7 = 0.0;
    v6 = 1.0;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 88) != 1023 || *(_DWORD *)(*(_DWORD *)pm[0] + 4) == 1 )
    {
      if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x40) != 0 )
      {
        v4 = v4 * *(float *)(LODWORD(pml[34]) + 700);
      }
      else if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x20) != 0 )
      {
        v4 = v4 * *(float *)(LODWORD(pml[34]) + 696);
      }
    }
    else
    {
      v4 = v4 * 0.5;
    }
    v6 = v4 * pml[9];
    if ( *(float *)(*(_DWORD *)pm[0] + 224) == 1.0 )
    {
      v7 = 0.0;
    }
    else
    {
      v5 = 0.0;
      if ( *(float *)(LODWORD(pml[34]) + 688) != 0.0 )
      {
        for ( i = 0; i <= 1; ++i )
        {
          v2 = (long double)*(int *)(pm[0] + 4 * i + 36) * 0.0054931641;
          v0 = (long double)*(int *)(pm[0] + 4 * i + 12) * 0.0054931641;
          v1 = v0;
          AngleSubtract(v1, v2);
          v3 = fabs(v0);
          v5 = v3 * 0.0099999998 * *(float *)(LODWORD(pml[34]) + 688) / pml[9] + v5;
        }
      }
      if ( *(float *)(LODWORD(pml[34]) + 692) != 0.0 && (*(_BYTE *)(pm[0] + 24) || *(_BYTE *)(pm[0] + 25)) )
        v5 = v5 + *(float *)(LODWORD(pml[34]) + 692);
      if ( *(_DWORD *)(*(_DWORD *)pm[0] + 88) == 1023 && *(_DWORD *)(*(_DWORD *)pm[0] + 4) != 1 )
      {
        for ( j = 0; j <= 1; ++j )
          v5 = 0.0099999998 * 128.0 + v5;
      }
      v7 = v5 * pml[9];
    }
  }
  *(float *)(*(_DWORD *)pm[0] + 1576) = (v7 - v6) * 255.0 + *(float *)(*(_DWORD *)pm[0] + 1576);
  if ( *(float *)(*(_DWORD *)pm[0] + 1576) >= 0.0 )
  {
    if ( *(float *)(*(_DWORD *)pm[0] + 1576) > 255.0 )
      *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1132396544;
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 0;
  }
}

//----- (000360FA) --------------------------------------------------------
int sub_360FA()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 44) )
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) -= LODWORD(pml[10]);
    if ( *(int *)(*(_DWORD *)pm[0] + 44) <= 0 )
    {
      if ( *(_DWORD *)(LODWORD(pml[34]) + 800)
        && (*(_BYTE *)(pm[0] + 8) & 1) != 0
        && *(_DWORD *)(*(_DWORD *)pm[0] + 216) == *(unsigned __int8 *)(pm[0] + 10)
        && PM_WeaponAmmoAvailable(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 1;
        if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4 )
        {
          sub_34073();
        }
        else if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3
               || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4
               || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 10
               || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11 )
        {
          sub_34024(0);
          *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
        }
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
      }
    }
  }
  if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 48) )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 48) -= LODWORD(pml[10]);
  if ( *(int *)(*(_DWORD *)pm[0] + 48) > 0 )
    return 0;
  *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
  return 1;
}
// 18D34: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);

//----- (000362EA) --------------------------------------------------------
void sub_362EA()
{
  if ( (*(_DWORD *)(LODWORD(pml[34]) + 124) != 1
     || !*(_DWORD *)(LODWORD(pml[34]) + 824)
     || *(_DWORD *)(*(_DWORD *)pm[0] + 52) >= *(_DWORD *)(LODWORD(pml[34]) + 616)
     || !*(_DWORD *)(*(_DWORD *)pm[0] + 52)
     || !Com_BitCheck(*(_DWORD *)pm[0] + 1332, *(_DWORD *)(*(_DWORD *)pm[0] + 216)))
    && (!*(_DWORD *)(*(_DWORD *)pm[0] + 44)
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 4
     || *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 3
     && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 4
     && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 10
     && *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 11
     && !*(_DWORD *)(*(_DWORD *)pm[0] + 48)) )
  {
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10) != 0 )
    {
      if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 216) )
        return;
LABEL_35:
      sub_348EE(*(_DWORD *)(*(_DWORD *)pm[0] + 216), 0);
      return;
    }
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x400000) != 0
      || (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0
      && (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x400000) == 0
      && !BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(*(_DWORD *)pm[0] + 1560), *(_DWORD *)(*(_DWORD *)pm[0] + 1556)) )
    {
      if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 216) )
        return;
      goto LABEL_35;
    }
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 216) != *(unsigned __int8 *)(pm[0] + 10)
      && ((*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x4000) == 0 || !*(_DWORD *)(*(_DWORD *)pm[0] + 216))
      && (!*(_BYTE *)(pm[0] + 10) || Com_BitCheck(*(_DWORD *)pm[0] + 1332, *(unsigned __int8 *)(pm[0] + 10))) )
    {
      sub_348EE(*(_DWORD *)(*(_DWORD *)pm[0] + 216), *(unsigned __int8 *)(pm[0] + 10));
      return;
    }
    if ( *(_DWORD *)(*(_DWORD *)pm[0] + 216)
      && !Com_BitCheck(*(_DWORD *)pm[0] + 1332, *(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
    {
      goto LABEL_35;
    }
  }
}
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (000366B2) --------------------------------------------------------
int __cdecl sub_366B2(int a1)
{
  if ( (*(_BYTE *)(pm[0] + 8) & 1) == 0
    && *(_DWORD *)(LODWORD(pml[34]) + 124) == 1
    && *(_DWORD *)(LODWORD(pml[34]) + 824)
    && *(_DWORD *)(*(_DWORD *)pm[0] + 52) < *(_DWORD *)(LODWORD(pml[34]) + 616)
    && *(_DWORD *)(*(_DWORD *)pm[0] + 52) )
  {
    return 0;
  }
  if ( (*(_BYTE *)(pm[0] + 8) & 1) != 0 || a1 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 3 )
    sub_34024(0);
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
  return 1;
}

//----- (0003679B) --------------------------------------------------------
int __cdecl sub_3679B(int a1)
{
  if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 1 )
  {
    if ( !a1 && !*(_DWORD *)(*(_DWORD *)pm[0] + 52) )
    {
      if ( PM_WeaponAmmoAvailable(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
      {
        *(_DWORD *)(*(_DWORD *)pm[0] + 52) = *(_DWORD *)(LODWORD(pml[34]) + 616);
        sub_33F9C(17);
        PM_AddEvent(162);
      }
      *(_DWORD *)(*(_DWORD *)pm[0] + 48) = *(_DWORD *)(LODWORD(pml[34]) + 568);
      *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
    }
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)pm[0] + 48) = *(_DWORD *)(LODWORD(pml[34]) + 548);
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 556);
    if ( *(_DWORD *)(LODWORD(pml[34]) + 840) )
      *(_DWORD *)(*(_DWORD *)pm[0] + 48) = (int)((1.0 - *(float *)(*(_DWORD *)pm[0] + 224))
                                               * (1.0
                                                / *(float *)(LODWORD(pml[34]) + 1204)));
    BG_AnimScriptEvent(*(_DWORD *)pm[0], 2, 0, 1);
    if ( *(_DWORD *)(LODWORD(pml[34]) + 804) )
      Com_BitSet(*(_DWORD *)pm[0] + 1356, *(_DWORD *)(*(_DWORD *)pm[0] + 216));
  }
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 3;
  return PM_SetProneMovementOverride();
}
// 16944: using guessed type int PM_SetProneMovementOverride(void);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18D34: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 19804: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);

//----- (00036997) --------------------------------------------------------
int sub_36997()
{
  return 1;
}

//----- (000369A1) --------------------------------------------------------
int sub_369A1()
{
  int v0; // esi
  int v3; // [esp+10h] [ebp-18h]
  _BOOL4 v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v3 = 1;
  v5 = sub_36997();
  if ( v5 <= PM_WeaponAmmoAvailable(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
    return 1;
  v0 = *(_DWORD *)pm[0];
  v4 = v5 <= *(_DWORD *)(v0 + 4 * BG_AmmoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) + 308);
  if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 1 )
    v3 = 0;
  if ( v3 && !v4 && *(_DWORD *)(LODWORD(pml[34]) + 128) != 8 )
    PM_AddEvent(151);
  if ( v4 )
  {
    sub_34659();
  }
  else
  {
    sub_34024(0);
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) += 500;
  }
  return 0;
}
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18D34: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00036ACC) --------------------------------------------------------
int sub_36ACC()
{
  int result; // eax

  if ( *(float *)(*(_DWORD *)pm[0] + 224) <= 0.75 )
  {
    if ( PM_WeaponClipEmpty(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
      result = sub_33F9C(3);
    else
      result = sub_33F9C(2);
  }
  else if ( PM_WeaponClipEmpty(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
  {
    result = sub_33F9C(6);
  }
  else
  {
    result = sub_33F9C(5);
  }
  return result;
}
// 17584: using guessed type _DWORD __cdecl PM_WeaponClipEmpty(_DWORD);

//----- (00036B6A) --------------------------------------------------------
void sub_36B6A()
{
  if ( *(float *)(*(_DWORD *)pm[0] + 224) != 1.0 )
  {
    *(float *)(*(_DWORD *)pm[0] + 1576) = *(float *)(LODWORD(pml[34]) + 684) * 255.0
                                        + *(float *)(*(_DWORD *)pm[0] + 1576);
    if ( *(float *)(*(_DWORD *)pm[0] + 1576) > 255.0 )
      *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1132396544;
  }
}

//----- (00036C0E) --------------------------------------------------------
void __cdecl sub_36C0E(int a1)
{
  int v1; // eax
  int v2; // eax

  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10000) == 0
    && (*(_DWORD *)(LODWORD(pml[34]) + 128) != 8
     || (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 && *(_DWORD *)(LODWORD(pml[34]) + 840))
    && (*(_DWORD *)(LODWORD(pml[34]) + 128) != 3
     || (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) != 0 && *(float *)(*(_DWORD *)pm[0] + 224) >= 0.99000001) )
  {
    sub_3679B(a1);
    if ( sub_369A1() )
    {
      if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 48) )
      {
        if ( PM_WeaponAmmoAvailable(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) != -1
          && ((*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x106000) == 0
           || BG_AllowPlayerWeaponAtVehiclePos(
                *(_DWORD *)(*(_DWORD *)pm[0] + 1560),
                *(_DWORD *)(*(_DWORD *)pm[0] + 1556))) )
        {
          v1 = sub_36997();
          PM_WeaponUseAmmo(*(_DWORD *)(*(_DWORD *)pm[0] + 216), v1);
          if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 4 )
          {
            v2 = sub_36997();
            PM_WeaponUseAmmo(*(_DWORD *)(*(_DWORD *)pm[0] + 216), v2);
          }
        }
        if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 1 )
          *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 556);
        if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 4 )
          *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 556);
        sub_36ACC();
        if ( PM_WeaponClipEmpty(*(_DWORD *)(*(_DWORD *)pm[0] + 216)) )
          PM_AddEvent(166);
        else
          PM_AddEvent(163);
        sub_36B6A();
        sub_35CE8();
      }
    }
  }
}
// 17004: using guessed type _DWORD __cdecl PM_WeaponUseAmmo(_DWORD, _DWORD);
// 17584: using guessed type _DWORD __cdecl PM_WeaponClipEmpty(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 18D34: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);

//----- (00036E91) --------------------------------------------------------
int sub_36E91()
{
  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 44) < *(_DWORD *)(LODWORD(pml[34]) + 572) - *(_DWORD *)(LODWORD(pml[34]) + 552) )
    *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 572) - *(_DWORD *)(LODWORD(pml[34]) + 552);
  PM_AddEvent(170);
  *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 11;
  return PM_SetProneMovementOverride();
}
// 16944: using guessed type int PM_SetProneMovementOverride(void);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00036F38) --------------------------------------------------------
int sub_36F38()
{
  int v1; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 10 )
  {
    sub_36E91();
    v1 = 1;
  }
  else if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11 )
  {
    sub_34024(0);
    *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
    v1 = 1;
  }
  else
  {
    v1 = 0;
  }
  return v1;
}

//----- (00036FB7) --------------------------------------------------------
char __cdecl sub_36FB7(int a1)
{
  int v1; // eax
  int v3; // [esp+10h] [ebp-8h]

  v1 = LODWORD(pml[34]);
  if ( *(_DWORD *)(v1 + 540) )
  {
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x20) == 0
      || (v1 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)pm[0] + 216)), *(_DWORD *)(v1 + 128) != 3) )
    {
      v1 = *(_DWORD *)pm[0];
      if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 13 )
      {
        v1 = LODWORD(pml[34]);
        if ( *(_DWORD *)(v1 + 124) != 1
          || (LOBYTE(v1) = *(_BYTE *)(pm[0] + 8) & 1, !(_BYTE)v1)
          && (v1 = *(_DWORD *)pm[0], *(_DWORD *)(*(_DWORD *)pm[0] + 220) != 3) )
        {
          if ( !a1 )
          {
            if ( !*(_DWORD *)(*(_DWORD *)pm[0] + 48)
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 5
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 7
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 9
              || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 8
              || (v1 = *(_DWORD *)pm[0], *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 6) )
            {
              if ( (*(_BYTE *)(pm[0] + 8) & 0x20) != 0 )
              {
                v1 = *(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x1000;
                if ( !v1 )
                {
                  v1 = *(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10000;
                  if ( !v1 )
                  {
                    *(_DWORD *)(*(_DWORD *)pm[0] + 12) |= 0x1000u;
                    v1 = *(_DWORD *)(*(_DWORD *)pm[0] + 220);
                    v3 = v1;
                    if ( v1 < 1 || v1 > 2 && (LOBYTE(v1) = v1 - 10, (unsigned int)(v3 - 10) > 1) )
                    {
                      BG_AnimScriptEvent(*(_DWORD *)pm[0], 13, 0, 1);
                      sub_33F9C(8);
                      PM_AddEvent(169);
                      if ( *(_DWORD *)(LODWORD(pml[34]) + 552) )
                      {
                        *(_DWORD *)(*(_DWORD *)pm[0] + 44) = *(_DWORD *)(LODWORD(pml[34]) + 572);
                        *(_DWORD *)(*(_DWORD *)pm[0] + 48) = *(_DWORD *)(LODWORD(pml[34]) + 552);
                        *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 10;
                        LOBYTE(v1) = PM_SetProneMovementOverride();
                      }
                      else
                      {
                        LOBYTE(v1) = sub_36E91();
                      }
                    }
                  }
                }
              }
              else
              {
                v1 = *(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0xFFFFEFFF;
                *(_DWORD *)(*(_DWORD *)pm[0] + 12) = v1;
              }
            }
          }
        }
      }
    }
  }
  return v1;
}
// 16944: using guessed type int PM_SetProneMovementOverride(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003726C) --------------------------------------------------------
void PM_Weapon()
{
  int v0; // [esp+1Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x800) == 0 )
  {
    if ( *(int *)(*(_DWORD *)pm[0] + 4) > 5 )
    {
      *(_DWORD *)(*(_DWORD *)pm[0] + 216) = 0;
      return;
    }
    if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x6000) == 0 )
    {
      if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 132) & 0x100000) != 0
        && !BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(*(_DWORD *)pm[0] + 1560), *(_DWORD *)(*(_DWORD *)pm[0] + 1556)) )
      {
        PM_UpdateAimDownSightLerp();
        if ( *(_DWORD *)(*(_DWORD *)pm[0] + 220) )
          sub_33F9C(0);
        *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 0;
        *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
        *(_DWORD *)(*(_DWORD *)pm[0] + 220) = 0;
        sub_34024(0);
        return;
      }
      if ( bg_debugWeaponState[3] && bg_debugWeaponState[3] != 2 )
        sub_377CC();
      if ( bg_debugWeaponAnim[3] && bg_debugWeaponAnim[3] != 2 )
        sub_3793A();
      PM_UpdateAimDownSightLerp();
      if ( *(_DWORD *)(LODWORD(pml[34]) + 124) == 1 )
      {
        if ( *(_DWORD *)(LODWORD(pml[34]) + 824)
          && ((*(_BYTE *)(pm[0] + 8) & 0x10) != 0 && (*(_BYTE *)(pm[0] + 32) & 0x10) == 0
           || (*(_BYTE *)(pm[0] + 8) & 0x10) == 0 && (*(_BYTE *)(pm[0] + 32) & 0x10) != 0)
          && *(_DWORD *)(*(_DWORD *)pm[0] + 52) >= *(_DWORD *)(LODWORD(pml[34]) + 616) )
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 52) -= 10;
          PM_AddEvent(182);
        }
        if ( *(int *)(*(_DWORD *)pm[0] + 52) > 0 )
        {
          if ( *(_DWORD *)(LODWORD(pml[34]) + 824)
            && *(_DWORD *)(*(_DWORD *)pm[0] + 52) < *(_DWORD *)(LODWORD(pml[34]) + 616) )
          {
            *(_DWORD *)(*(_DWORD *)pm[0] + 52) -= LODWORD(pml[10]);
          }
          if ( *(int *)(*(_DWORD *)pm[0] + 52) <= 50 )
          {
            *(_DWORD *)(*(_DWORD *)pm[0] + 52) = 50;
            PM_AddEvent(163);
            if ( *(_DWORD *)(LODWORD(pml[34]) + 892) )
              PM_AddEvent(210);
            PM_WeaponUseAmmo(*(_DWORD *)(*(_DWORD *)pm[0] + 216), 1);
            *(_DWORD *)(*(_DWORD *)pm[0] + 48) = 0;
            *(_DWORD *)(*(_DWORD *)pm[0] + 44) = 1600;
            sub_35CE8();
            return;
          }
          if ( (*(_BYTE *)(pm[0] + 8) & 1) != 0 && *(_DWORD *)(*(_DWORD *)pm[0] + 48) - LODWORD(pml[10]) <= 0 )
            *(_DWORD *)(*(_DWORD *)pm[0] + 48) = LODWORD(pml[10]) + 1;
          if ( (*(_BYTE *)(pm[0] + 8) & 1) == 0 && *(_DWORD *)(*(_DWORD *)pm[0] + 48) - LODWORD(pml[10]) <= 0 )
            BG_AnimScriptEvent(*(_DWORD *)pm[0], 2, 0, 1);
        }
      }
      v0 = sub_360FA();
      sub_35B66();
      sub_362EA();
      sub_358B2();
      sub_36FB7(v0);
      if ( !sub_340AB(v0) )
      {
        if ( (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 1) != 0 && (*(_BYTE *)(pm[0] + 24) || *(_BYTE *)(pm[0] + 25))
          || (*(_DWORD *)(*(_DWORD *)pm[0] + 12) & 0x10000) != 0 && (*(_BYTE *)(pm[0] + 24) || *(_BYTE *)(pm[0] + 25))
          || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 10
          || *(_DWORD *)(*(_DWORD *)pm[0] + 220) == 11 )
        {
          *(_DWORD *)(*(_DWORD *)pm[0] + 1576) = 1132396544;
        }
        if ( (v0 || !*(_DWORD *)(*(_DWORD *)pm[0] + 44) && !*(_DWORD *)(*(_DWORD *)pm[0] + 48))
          && !sub_35564(v0)
          && !sub_36F38()
          && !sub_34C14()
          && !sub_35064()
          && !sub_350C2()
          && !sub_35120()
          && *(_DWORD *)(*(_DWORD *)pm[0] + 216)
          && !sub_366B2(v0) )
        {
          sub_36C0E(v0);
        }
      }
    }
  }
}
// 17004: using guessed type _DWORD __cdecl PM_WeaponUseAmmo(_DWORD, _DWORD);
// 17A84: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 198D4: using guessed type int PM_UpdateAimDownSightLerp(void);

//----- (000377CC) --------------------------------------------------------
int sub_377CC()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(*(_DWORD *)pm[0] + 220);
  result = dword_AB44C;
  if ( dword_AB44C != v3 )
  {
    Com_Printf(" %i %s_", *(_DWORD *)(pm[0] + 4));
    dword_AB44C = v3;
    Com_Printf("WEAP_STATE -- ", v1);
    switch ( v3 )
    {
      case 0:
        result = Com_Printf("WEAPON_READY\n", v2);
        break;
      case 1:
        result = Com_Printf("WEAPON_RAISING\n", v2);
        break;
      case 2:
        result = Com_Printf("WEAPON_DROPPING\n", v2);
        break;
      case 3:
        result = Com_Printf("WEAPON_FIRING\n", v2);
        break;
      case 4:
        result = Com_Printf("WEAPON_RECHAMBERING\n", v2);
        break;
      case 5:
        result = Com_Printf("WEAPON_RELOADING\n", v2);
        break;
      case 6:
        result = Com_Printf("WEAPON_RELOADING_INTERUPT\n", v2);
        break;
      case 7:
        result = Com_Printf("WEAPON_RELOAD_START\n", v2);
        break;
      case 8:
        result = Com_Printf("WEAPON_RELOAD_START_INTERUPT\n", v2);
        break;
      case 9:
        result = Com_Printf("WEAPON_RELOAD_END\n", v2);
        break;
      case 10:
        result = Com_Printf("WEAPON_MELEE_WINDUP\n", v2);
        break;
      case 11:
        result = Com_Printf("WEAPON_MELEE_RELAX\n", v2);
        break;
      default:
        result = Com_Printf("UNKNOWN\n", v2);
        break;
    }
  }
  return result;
}
// 3783A: variable 'v1' is possibly undefined
// 37863: variable 'v2' is possibly undefined
// AB44C: using guessed type int dword_AB44C;

//----- (0003793A) --------------------------------------------------------
int sub_3793A()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(*(_DWORD *)pm[0] + 1572) & 0xFFFFFDFF;
  Com_Printf(" %i %s_", *(_DWORD *)(pm[0] + 4));
  dword_AB450 = v3;
  Com_Printf("WEAP_ANIM -- ", v1);
  switch ( v3 & 0xFFFFFDFF )
  {
    case 0u:
      result = Com_Printf("WEAP_IDLE\n", v2);
      break;
    case 2u:
      result = Com_Printf("WEAP_ATTACK\n", v2);
      break;
    case 3u:
      result = Com_Printf("WEAP_ATTACK_LASTSHOT\n", v2);
      break;
    case 4u:
      result = Com_Printf("WEAP_RECHAMBER\n", v2);
      break;
    case 5u:
      result = Com_Printf("WEAP_ADS_ATTACK\n", v2);
      break;
    case 6u:
      result = Com_Printf("WEAP_ADS_ATTACK_LASTSHOT\n", v2);
      break;
    case 7u:
      result = Com_Printf("WEAP_ADS_RECHAMBER\n", v2);
      break;
    case 8u:
      result = Com_Printf("WEAP_MELEE_ATTACK\n", v2);
      break;
    case 9u:
      result = Com_Printf("WEAP_DROP\n", v2);
      break;
    case 0xAu:
      result = Com_Printf("WEAP_RAISE\n", v2);
      break;
    case 0xBu:
      result = Com_Printf("WEAP_RELOAD\n", v2);
      break;
    case 0xCu:
      result = Com_Printf("WEAP_RELOAD_EMPTY\n", v2);
      break;
    case 0xDu:
      result = Com_Printf("WEAP_RELOAD_START\n", v2);
      break;
    case 0xEu:
      result = Com_Printf("WEAP_RELOAD_END\n", v2);
      break;
    case 0xFu:
      result = Com_Printf("WEAP_ALTSWITCHFROM\n", v2);
      break;
    case 0x10u:
      result = Com_Printf("WEAP_ALTSWITCHTO\n", v2);
      break;
    case 0x12u:
      result = Com_Printf("WEAP_DEPLOYED\n", v2);
      break;
    case 0x13u:
      result = Com_Printf("WEAP_DEPLOY\n", v2);
      break;
    case 0x14u:
      result = Com_Printf("WEAP_BREAKDOWN\n", v2);
      break;
    default:
      result = Com_Printf("UNKNOWN\n", v2);
      break;
  }
  return result;
}
// 3799D: variable 'v1' is possibly undefined
// 379D1: variable 'v2' is possibly undefined
// AB450: using guessed type int dword_AB450;

//----- (00037B2D) --------------------------------------------------------
long double __cdecl BG_GetBobCycle(int a1)
{
  long double v1; // fst6

  v1 = (long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793;
  return (float)(v1 + v1 + 6.283185307179586);
}

//----- (00037B7C) --------------------------------------------------------
long double __cdecl BG_GetVerticalBobFactor(int a1, float a2, float a3, float a4)
{
  float *v4; // eax
  float v6; // [esp+8h] [ebp-10h]
  float v7; // [esp+8h] [ebp-10h]
  float v8; // [esp+8h] [ebp-10h]
  float v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 244) == *(_DWORD *)(a1 + 1396) )
  {
    v11 = a3 * bg_bobAmplitudeProne[2];
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == *(_DWORD *)(a1 + 1400) )
      v4 = (float *)&bg_bobAmplitudeDucked;
    else
      v4 = (float *)&bg_bobAmplitudeStanding;
    v11 = a3 * v4[2];
  }
  if ( v11 > (long double)a4 )
    v11 = a4;
  v6 = sin(a2 + a2);
  v10 = sin(a2 * 4.0 + 1.570796326794897);
  v7 = v10 * 0.2 + v6;
  v8 = 0.75 * v7;
  return (float)(v8 * v11);
}

//----- (00037C5F) --------------------------------------------------------
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4)
{
  float *v4; // eax
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 244) == *(_DWORD *)(a1 + 1396) )
  {
    v7 = a3 * bg_bobAmplitudeProne[2];
  }
  else
  {
    if ( *(_DWORD *)(a1 + 244) == *(_DWORD *)(a1 + 1400) )
      v4 = (float *)&bg_bobAmplitudeDucked;
    else
      v4 = (float *)&bg_bobAmplitudeStanding;
    v7 = a3 * v4[2];
  }
  if ( v7 > (long double)a4 )
    v7 = a4;
  v6 = sin(a2);
  return v6 * v7;
}

//----- (00037CFB) --------------------------------------------------------
void __cdecl sub_37CFB(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+14h] [ebp-34h]
  float *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+30h] [ebp-18h]
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v5 = *(_DWORD *)a1;
  v4 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
  if ( (*(_DWORD *)(v5 + 12) & 0x10000) != 0 )
  {
    v9 = v4[109];
  }
  else if ( (*(_DWORD *)(v5 + 132) & 0x40) != 0 )
  {
    v9 = v4[112];
  }
  else if ( (*(_DWORD *)(v5 + 132) & 0x20) != 0 )
  {
    v9 = v4[111];
  }
  else
  {
    v9 = v4[110];
  }
  if ( a1[1] <= (long double)v9 || *(_DWORD *)(v5 + 220) == 5 )
  {
    v8 = 0.0;
    v7 = 0.0;
    v6 = 0.0;
  }
  else
  {
    v11 = (a1[1] - v9) / ((long double)*(int *)(v5 + 72) - v9);
    if ( v11 >= 0.0 && v11 > 1.0 )
    {
      v3 = 1.0;
    }
    else if ( v11 >= 0.0 )
    {
      v3 = v11;
    }
    else
    {
      v3 = 0.0;
    }
    v11 = v3;
    if ( (*(_DWORD *)(v5 + 12) & 0x10000) != 0 )
    {
      v6 = v4[74] * v11;
      v7 = v4[75] * v11;
      v8 = v4[76] * v11;
    }
    else if ( (*(_DWORD *)(v5 + 132) & 0x40) != 0 )
    {
      v6 = v4[98] * v11;
      v7 = v4[99] * v11;
      v8 = v4[100] * v11;
    }
    else
    {
      if ( (*(_DWORD *)(v5 + 132) & 0x20) != 0 )
      {
        v6 = v4[89] * v11;
        v7 = v4[90] * v11;
        v2 = v4[91] * v11;
      }
      else
      {
        v6 = v4[80] * v11;
        v7 = v4[81] * v11;
        v2 = v4[82] * v11;
      }
      v8 = v2;
    }
  }
  if ( *(float *)(v5 + 224) != 0.0 )
  {
    v10 = 1.0 - *(float *)(v5 + 224);
    v6 = v6 * v10;
    v7 = v7 * v10;
    v8 = v8 * v10;
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a1[i + 3] != *(&v6 + i) )
    {
      if ( *(float *)(v5 + 248) == (long double)*(int *)(v5 + 1396) )
        v10 = (*(&v6 + i) - a1[i + 3]) * a1[2] * v4[108];
      else
        v10 = (*(&v6 + i) - a1[i + 3]) * a1[2] * v4[107];
      if ( *(&v6 + i) <= (long double)a1[i + 3] )
      {
        if ( v10 > a1[2] * -0.1 )
          v10 = a1[2] * -0.1;
        a1[i + 3] = a1[i + 3] + v10;
        if ( *(&v6 + i) > (long double)a1[i + 3] )
          a1[i + 3] = *(&v6 + i);
      }
      else
      {
        if ( a1[2] * 0.1 > v10 )
          v10 = a1[2] * 0.1;
        a1[i + 3] = a1[i + 3] + v10;
        if ( a1[i + 3] > (long double)*(&v6 + i) )
          a1[i + 3] = *(&v6 + i);
      }
    }
  }
  if ( *(float *)(v5 + 224) == 0.0 )
  {
    *a2 = *a2 + a1[3];
    a2[1] = a2[1] + a1[4];
    a2[2] = a2[2] + a1[5];
  }
  else if ( *(float *)(v5 + 224) < 0.5 )
  {
    v10 = 1.0 - (*(float *)(v5 + 224) + *(float *)(v5 + 224));
    *a2 = a1[3] * v10 + *a2;
    a2[1] = a1[4] * v10 + a2[1];
    a2[2] = a1[5] * v10 + a2[2];
  }
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (000381E9) --------------------------------------------------------
void __cdecl sub_381E9(float *a1, float *a2)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = *(_DWORD *)a1;
  v2 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v3 + 216)) )
    *a2 = *(float *)(v3 + 224) * *(float *)(v2 + 968) + *a2;
  sub_37CFB(a1, a2);
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 183A4: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (00038264) --------------------------------------------------------
float *__cdecl sub_38264(float *a1, float *a2)
{
  float *result; // eax
  float *v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+28h] [ebp-10h]
  float v8; // [esp+2Ch] [ebp-Ch]
  float v9; // [esp+2Ch] [ebp-Ch]
  float v10; // [esp+2Ch] [ebp-Ch]

  v4 = *(_DWORD *)a1;
  v3 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v4 + 216)) )
  {
    v6 = (v3[179] - v3[180]) * *(float *)(v4 + 224) + v3[180];
  }
  else if ( v3[180] == 0.0 )
  {
    v6 = 80.0;
  }
  else
  {
    v6 = v3[180];
  }
  if ( (*(_DWORD *)(v4 + 132) & 0x40) != 0 )
  {
    v5 = v3[182];
  }
  else if ( (*(_DWORD *)(v4 + 132) & 0x20) != 0 )
  {
    v5 = v3[181];
  }
  else
  {
    v5 = 1.0;
  }
  if ( v5 != a1[6] )
  {
    if ( v5 <= (long double)a1[6] )
    {
      a1[6] = a1[6] - a1[2] * 0.5;
      if ( v5 > (long double)a1[6] )
        a1[6] = v5;
    }
    else
    {
      a1[6] = a1[2] * 0.5 + a1[6];
      if ( a1[6] > (long double)v5 )
        a1[6] = v5;
    }
  }
  v7 = v6 * a1[6];
  v8 = sin((long double)*((int *)a1 + 7) * 0.00050000002);
  a2[2] = v7 * v8 * 0.039999999 + a2[2];
  v9 = sin((long double)*((int *)a1 + 7) * 0.00069999998);
  a2[1] = v7 * v9 * 0.0099999998 + a2[1];
  v10 = sin((long double)*((int *)a1 + 7) * 0.001);
  result = a2;
  *a2 = v7 * v10 * 0.0099999998 + *a2;
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 183A4: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (00038498) --------------------------------------------------------
float *__cdecl sub_38498(float *a1, float *a2)
{
  long double v2; // fst6
  long double v3; // fst7
  long double v4; // fst7
  long double v5; // fst7
  float *result; // eax
  float v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+34h] [ebp-24h]
  float v13; // [esp+38h] [ebp-20h]
  float v14; // [esp+44h] [ebp-14h]
  float v15; // [esp+44h] [ebp-14h]
  float v16; // [esp+44h] [ebp-14h]
  float v17; // [esp+48h] [ebp-10h]
  float v18; // [esp+48h] [ebp-10h]
  float v19; // [esp+4Ch] [ebp-Ch]

  v9 = *(_DWORD *)a1;
  v8 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
  v2 = (long double)*(unsigned __int8 *)(v9 + 8) / 255.0 * 3.141592653589793;
  v10 = v2 + v2 + 6.283185307179586;
  v17 = v10 + 0.7853981633974483 + 6.283185307179586;
  v3 = a1[1] * 0.16;
  v14 = v3;
  BG_GetVerticalBobFactor(v9, v17, v14, 10.0);
  v4 = v3 * -1.0;
  v11 = v4;
  BG_GetHorizontalBobFactor(v9, v17, v14, 10.0);
  v12 = v4 * -1.0;
  v18 = v17 - 0.4712389167638204;
  v5 = v14 * 1.5;
  v15 = v5;
  BG_GetHorizontalBobFactor(v9, v18, v15, 10.0);
  if ( v5 >= 0.0 )
  {
    v7 = 0.0;
  }
  else
  {
    BG_GetHorizontalBobFactor(v9, v18, v15, 10.0);
    v7 = v5;
  }
  v13 = v7;
  v19 = *(float *)(v9 + 224);
  if ( v19 != 0.0 )
  {
    v16 = 1.0 - (1.0 - *(float *)(v8 + 656)) * v19;
    v11 = v11 * v16;
    v12 = v12 * v16;
    v13 = v7 * v16;
  }
  *a2 = *a2 + v11;
  a2[1] = a2[1] + v12;
  result = a2 + 2;
  a2[2] = a2[2] + v13;
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00038687) --------------------------------------------------------
void __cdecl sub_38687(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  float v6; // [esp+14h] [ebp-14h]
  float v7; // [esp+18h] [ebp-10h]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+20h] [ebp-8h]
  float v11; // [esp+20h] [ebp-8h]
  float v12; // [esp+20h] [ebp-8h]
  float v13; // [esp+20h] [ebp-8h]
  float v14; // [esp+20h] [ebp-8h]

  if ( *((_DWORD *)a1 + 8) )
  {
    v5 = *(_DWORD *)a1;
    v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
    v8 = *(float *)(v5 + 224) * 0.5 + 0.5;
    v7 = v8 * 100.0;
    v6 = v8 * 400.0;
    if ( *(float *)(v5 + 224) != 0.0 && *(_DWORD *)(v4 + 644) )
      v8 = (1.0 - *(float *)(v5 + 224) * 0.75) * v8;
    v9 = (float)(*((_DWORD *)a1 + 7) - *((_DWORD *)a1 + 8));
    if ( v7 <= (long double)v9 )
    {
      v12 = 1.0 - (v9 - v7) / v6;
      if ( v12 > 0.0 )
      {
        v2 = 1.0 - v12;
        v3 = v2;
        GetLeanFraction(v3);
        v13 = 1.0 - v2;
        v14 = v13 * v8;
        *a2 = v14 * a1[9] * 0.5 + *a2;
        a2[1] = a2[1] - v14 * a1[10];
        a2[2] = v14 * a1[10] * 0.5 + a2[2];
      }
    }
    else
    {
      v10 = v9 / v7;
      GetLeanFraction(v10);
      v11 = v10 * v8;
      *a2 = v11 * a1[9] * 0.5 + *a2;
      a2[1] = a2[1] - v11 * a1[10];
      a2[2] = v11 * a1[10] * 0.5 + a2[2];
    }
  }
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (000388A0) --------------------------------------------------------
int __cdecl sub_388A0(int a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v9; // [esp+4h] [ebp-8h]

  v9 = 0;
  if ( fabs(*(float *)a1) >= 0.25 || fabs(*(float *)a2) >= 1.0 )
  {
    *(float *)a1 = *(float *)a2 * a3 + *(float *)a1;
    if ( *(float *)a1 <= (long double)a4 )
    {
      if ( -a4 > (long double)*(float *)a1 )
      {
        *(_DWORD *)a1 = LODWORD(a4) ^ 0x80000000;
        if ( *(float *)a2 < 0.0 )
          *(_DWORD *)a2 = 0;
      }
    }
    else
    {
      *(float *)a1 = a4;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a1 <= 0.0 )
    {
      if ( *(float *)a1 < 0.0 )
        *(float *)a2 = a5 * a3 + *(float *)a2;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a5 * a3;
    }
    *(float *)a2 = *(float *)a2 - *(float *)a2 * a7 * a3;
    if ( *(float *)a2 <= 0.0 )
    {
      *(float *)a2 = a8 * a3 + *(float *)a2;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a8 * a3;
      if ( *(float *)a2 < 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a2 <= (long double)a6 )
    {
      if ( -a6 > (long double)*(float *)a2 )
        *(_DWORD *)a2 = LODWORD(a6) ^ 0x80000000;
    }
    else
    {
      *(float *)a2 = a6;
    }
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)a2 = 0;
    v9 = 1;
  }
  return v9;
}

//----- (00038AC6) --------------------------------------------------------
float *__cdecl sub_38AC6(float *a1, float *a2)
{
  float *result; // eax
  int v3; // eax
  float *v4; // [esp+2Ch] [ebp-2Ch]
  int v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h]
  float v7; // [esp+38h] [ebp-20h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  int v11; // [esp+48h] [ebp-10h]
  int v12; // [esp+4Ch] [ebp-Ch]
  float v13; // [esp+50h] [ebp-8h]

  v5 = *(_DWORD *)a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 132) & 0x100000) == 0
    || (result = (float *)BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(v5 + 1560), *(_DWORD *)(v5 + 1556))) != 0 )
  {
    result = (float *)BG_IsAimDownSightWeapon(*(_DWORD *)(v5 + 216));
    if ( result )
    {
      v4 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(v5 + 216));
      v6 = *(float *)(v5 + 224);
      v10 = (v4[249] - v4[267]) * v6 + v4[267];
      v9 = (v4[250] - v4[268]) * v6 + v4[268];
      v8 = (v4[251] - v4[269]) * v6 + v4[269];
      v7 = (v4[252] - v4[270]) * v6 + v4[270];
      v13 = a1[2];
      while ( v13 > 0.0 )
      {
        if ( v13 <= 0.005 )
        {
          v12 = LODWORD(v13);
          v13 = 0.0;
          v3 = sub_388A0((int)(a1 + 11), (int)(a1 + 14), *(float *)&v12, v4[183], v10, v9, v8, v7);
        }
        else
        {
          v12 = 1000593162;
          v13 = v13 - 0.005;
          v3 = sub_388A0((int)(a1 + 11), (int)(a1 + 14), 0.0049999999, v4[183], v10, v9, v8, v7);
        }
        v11 = v3;
        if ( sub_388A0((int)(a1 + 12), (int)(a1 + 15), *(float *)&v12, v4[184], v10, v9, v8, v7) )
        {
          if ( v11 )
            break;
        }
      }
      *a2 = *a2 + a1[11];
      a2[1] = a2[1] + a1[12];
      result = a2 + 2;
      a2[2] = a2[2] + a1[13];
    }
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 183A4: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (00038D25) --------------------------------------------------------
int __cdecl BG_CalculateWeaponAngles(float *a1, int a2)
{
  int result; // eax
  long double v3; // fst7
  float v4; // [esp+8h] [ebp-10h]

  v4 = *a1;
  if ( (*(_DWORD *)(*(_DWORD *)a1 + 132) & 0x100000) == 0
    || (result = BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(LODWORD(v4) + 1560), *(_DWORD *)(LODWORD(v4) + 1556))) != 0 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = 0;
    v3 = 0.0;
    if ( *(float *)(LODWORD(v4) + 68) != 0.0 )
    {
      GetLeanFraction(*(float *)(LODWORD(v4) + 68));
      v3 = *(float *)(a2 + 8) - ((float)0.0 + (float)0.0);
      *(float *)(a2 + 8) = v3;
    }
    sub_381E9(a1, (float *)a2);
    sub_38264(a1, (float *)a2);
    sub_38498(a1, (float *)a2);
    sub_38687(a1, (float *)a2);
    sub_38AC6(a1, (float *)a2);
    AngleSubtract(*(float *)a2, a1[17]);
    *(float *)a2 = v3;
    AngleSubtract(*(float *)(a2 + 4), a1[18]);
    result = a2 + 4;
    *(float *)(a2 + 4) = v3;
  }
  return result;
}
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (00038E76) --------------------------------------------------------
void __cdecl sub_38E76(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+14h] [ebp-14h]
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h]
  float v8; // [esp+20h] [ebp-8h]
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+20h] [ebp-8h]
  float v11; // [esp+20h] [ebp-8h]
  float v12; // [esp+20h] [ebp-8h]

  if ( *((_DWORD *)a1 + 1) )
  {
    v5 = *a1;
    if ( (*(_DWORD *)(*(_DWORD *)a1 + 132) & 0x106000) == 0
      || BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(LODWORD(v5) + 1560), *(_DWORD *)(LODWORD(v5) + 1556)) )
    {
      v4 = BG_GetInfoForWeapon(*(_DWORD *)(LODWORD(v5) + 216));
      v6 = 1.0 - *(float *)(LODWORD(v5) + 224) * 0.5;
      if ( *(float *)(LODWORD(v5) + 224) != 0.0 && *(_DWORD *)(v4 + 644) )
        v6 = (*(float *)(LODWORD(v5) + 224) * 0.5 + 1.0) * v6;
      v7 = (float)(*((_DWORD *)a1 + 2) - *((_DWORD *)a1 + 1));
      if ( v7 >= 100.0 )
      {
        v10 = 1.0 - (v7 - 100.0) / 400.0;
        if ( v10 > 0.0 )
        {
          v2 = 1.0 - v10;
          v3 = v2;
          GetLeanFraction(v3);
          v11 = 1.0 - v2;
          v12 = v11 * v6;
          *a2 = v12 * a1[3] + *a2;
          a2[2] = v12 * a1[4] + a2[2];
        }
      }
      else
      {
        v8 = v7 / 100.0;
        GetLeanFraction(v8);
        v9 = v8 * v6;
        *a2 = v9 * a1[3] + *a2;
        a2[2] = v9 * a1[4] + a2[2];
      }
    }
  }
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (00039062) --------------------------------------------------------
void __cdecl sub_39062(float *a1, float *a2)
{
  long double v2; // fst6
  long double v3; // fst7
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+2Ch] [ebp-Ch]
  float v8; // [esp+2Ch] [ebp-Ch]
  float v9; // [esp+30h] [ebp-8h]

  v5 = *(_DWORD *)a1;
  v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 216));
  if ( ((*(_DWORD *)(v5 + 132) & 0x106000) == 0
     || BG_AllowPlayerWeaponAtVehiclePos(*(_DWORD *)(v5 + 1560), *(_DWORD *)(v5 + 1556)))
    && *(float *)(v5 + 224) != 0.0
    && *(float *)(v4 + 660) != 0.0 )
  {
    v2 = (long double)*(unsigned __int8 *)(v5 + 8) / 255.0 * 3.141592653589793;
    v6 = v2 + v2 + 6.283185307179586;
    BG_GetVerticalBobFactor(v5, v6, a1[5], 45.0);
    v9 = *(float *)(v5 + 224) * *(float *)(v4 + 660) * v6;
    v3 = *a2 - v9;
    *a2 = v3;
    BG_GetHorizontalBobFactor(v5, v6, a1[5], 45.0);
    v7 = v3;
    v8 = *(float *)(v5 + 224) * *(float *)(v4 + 660) * v7;
    a2[1] = a2[1] - v8;
  }
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);

//----- (000391DD) --------------------------------------------------------
void __cdecl BG_CalculateViewAngles(float *a1, int a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  sub_38E76(a1, (float *)a2);
  sub_39062(a1, (float *)a2);
}

//----- (00039236) --------------------------------------------------------
long double __cdecl sub_39236(float a1, float a2, float a3, int a4)
{
  float v6; // [esp+4h] [ebp-Ch]
  float v7; // [esp+8h] [ebp-8h]

  v7 = a1 - a2;
  v6 = a3 * v7 * ((long double)a4 * 0.001);
  if ( fabs(v7) <= 0.001000000047497451 )
    return a1;
  if ( fabs(v6) <= fabs(v7) )
    return (float)(a2 + v6);
  return a1;
}

//----- (000392B2) --------------------------------------------------------
int __cdecl BG_CalculateWeaponPosition_Sway(int a1, int a2, int a3, int a4, float a5, int a6)
{
  int result; // eax
  float v7; // [esp+1Ch] [ebp-6Ch]
  float v8; // [esp+1Ch] [ebp-6Ch]
  float v9; // [esp+1Ch] [ebp-6Ch]
  float v10; // [esp+1Ch] [ebp-6Ch]
  float v11; // [esp+2Ch] [ebp-5Ch]
  float v12; // [esp+30h] [ebp-58h]
  float v13; // [esp+34h] [ebp-54h]
  float v14; // [esp+38h] [ebp-50h]
  float v15; // [esp+38h] [ebp-50h]
  float v16; // [esp+3Ch] [ebp-4Ch]
  float v17; // [esp+3Ch] [ebp-4Ch]
  float v18; // [esp+40h] [ebp-48h]
  float v19; // [esp+40h] [ebp-48h]
  float v20; // [esp+44h] [ebp-44h]
  float v21; // [esp+44h] [ebp-44h]
  float v22; // [esp+48h] [ebp-40h]
  float v23; // [esp+4Ch] [ebp-3Ch]
  float v24; // [esp+54h] [ebp-34h]
  float v25; // [esp+58h] [ebp-30h]
  float v26; // [esp+60h] [ebp-28h] BYREF
  float v27; // [esp+64h] [ebp-24h]
  int v28; // [esp+7Ch] [ebp-Ch]

  v28 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 216));
  v13 = *(float *)(a1 + 224);
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(a1 + 216)) )
  {
    if ( v13 > 0.0 )
    {
      result = v28;
      if ( *(_DWORD *)(v28 + 644) )
        return result;
    }
    v23 = (*(float *)(v28 + 768) - *(float *)(v28 + 740)) * v13 + *(float *)(v28 + 740);
    v22 = (*(float *)(v28 + 772) - *(float *)(v28 + 744)) * v13 + *(float *)(v28 + 744);
    v20 = (*(float *)(v28 + 776) - *(float *)(v28 + 748)) * v13 + *(float *)(v28 + 748);
    v18 = (*(float *)(v28 + 780) - *(float *)(v28 + 752)) * v13 + *(float *)(v28 + 752);
    v16 = (*(float *)(v28 + 784) - *(float *)(v28 + 756)) * v13 + *(float *)(v28 + 756);
    v14 = (*(float *)(v28 + 788) - *(float *)(v28 + 760)) * v13 + *(float *)(v28 + 760);
  }
  else
  {
    v23 = *(float *)(v28 + 740);
    v22 = *(float *)(v28 + 744);
    v20 = *(float *)(v28 + 748);
    v18 = *(float *)(v28 + 752);
    v16 = *(float *)(v28 + 756);
    v14 = *(float *)(v28 + 760);
  }
  v21 = v20 * a5;
  v19 = v18 * a5;
  v17 = v16 * a5;
  v15 = v14 * a5;
  AnglesSubtract(a1 + 232, a2, &v26);
  if ( -v23 <= (long double)v26 )
  {
    if ( v26 <= (long double)v23 )
      v12 = v26;
    else
      v12 = v23;
  }
  else
  {
    LODWORD(v12) = LODWORD(v23) ^ 0x80000000;
  }
  v26 = v12;
  if ( -v23 <= (long double)v27 )
  {
    if ( v27 <= (long double)v23 )
      v11 = v27;
    else
      v11 = v23;
  }
  else
  {
    LODWORD(v11) = LODWORD(v23) ^ 0x80000000;
  }
  v27 = v11;
  v24 = v11 * v17;
  v25 = v26 * v15;
  v7 = sub_39236(v24, *(float *)(a3 + 4), v22, a6);
  *(float *)(a3 + 4) = v7;
  v8 = sub_39236(v25, *(float *)(a3 + 8), v22, a6);
  *(float *)(a3 + 8) = v8;
  v26 = v26 * v21;
  v27 = v27 * v19;
  while ( v26 - *(float *)a4 > 180.0 )
    v26 = v26 - 360.0;
  while ( v27 - *(float *)(a4 + 4) > 180.0 )
    v27 = v27 - 360.0;
  v9 = sub_39236(v26, *(float *)a4, v22, a6);
  *(float *)a4 = v9;
  v10 = sub_39236(v27, *(float *)(a4 + 4), v22, a6);
  *(float *)(a4 + 4) = v10;
  AngleNormalize180(*(float *)a4);
  *(float *)a4 = v10;
  AngleNormalize180(*(float *)(a4 + 4));
  *(float *)(a4 + 4) = v10;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 232);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 236);
  result = *(_DWORD *)(a1 + 240);
  *(_DWORD *)(a2 + 8) = result;
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 183A4: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (000396BC) --------------------------------------------------------
float *__cdecl BG_WeaponFireRecoil(int a1, float *a2, int a3)
{
  float *result; // eax
  float v4; // [esp+10h] [ebp-38h]
  float v5; // [esp+14h] [ebp-34h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  float v8; // [esp+20h] [ebp-28h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+28h] [ebp-20h]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+34h] [ebp-14h]
  float v15; // [esp+38h] [ebp-10h]
  float v16; // [esp+38h] [ebp-10h]
  float *v17; // [esp+3Ch] [ebp-Ch]

  v17 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(a1 + 216));
  v12 = *(float *)(a1 + 224);
  if ( v12 == 1.0 )
  {
    v11 = v17[254] - v17[253];
    v15 = (long double)rand() / 2147483600.0 * v11 + v17[253];
    v10 = v17[256] - v17[255];
    v13 = (long double)rand() / 2147483600.0 * v10 + v17[255];
  }
  else
  {
    v9 = v17[272] - v17[271];
    v15 = (long double)rand() / 2147483600.0 * v9 + v17[271];
    v8 = v17[274] - v17[273];
    v13 = (long double)rand() / 2147483600.0 * v8 + v17[273];
  }
  *(_DWORD *)a3 = LODWORD(v15) ^ 0x80000000;
  *(float *)(a3 + 4) = v13;
  *(float *)(a3 + 8) = *(float *)(a3 + 4) * -0.5;
  if ( v12 <= 0.0 )
  {
    v5 = v17[264] - v17[263];
    v16 = (long double)rand() / 2147483600.0 * v5 + v17[263];
    v4 = v17[266] - v17[265];
    v14 = (long double)rand() / 2147483600.0 * v4 + v17[265];
  }
  else
  {
    v7 = v17[246] - v17[245];
    v16 = (long double)rand() / 2147483600.0 * v7 + v17[245];
    v6 = v17[248] - v17[247];
    v14 = (long double)rand() / 2147483600.0 * v6 + v17[247];
  }
  *a2 = *a2 + v16;
  result = a2 + 1;
  a2[1] = a2[1] + v14;
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0003995C) --------------------------------------------------------
void sub_3995C()
{
  ;
}

//----- (00039960) --------------------------------------------------------
int __cdecl Q_rand(int a1)
{
  *(_DWORD *)a1 = 69069 * *(_DWORD *)a1 + 1;
  return *(_DWORD *)a1;
}

//----- (0003997B) --------------------------------------------------------
long double __cdecl Q_random(int a1)
{
  return (long double)(unsigned __int16)Q_rand(a1) / 65536.0;
}
// 17804: using guessed type _DWORD __cdecl Q_rand(_DWORD);

//----- (000399B3) --------------------------------------------------------
long double __cdecl Q_crandom(int a1)
{
  long double v1; // fst7

  v1 = Q_random(a1);
  return v1 - 0.5 + v1 - 0.5;
}
// 18C64: using guessed type double __cdecl Q_random(_DWORD);

//----- (000399E0) --------------------------------------------------------
float *__cdecl gunrandom(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+14h] [ebp-14h] BYREF
  float v5; // [esp+18h] [ebp-10h] BYREF
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h]

  v7 = (long double)rand() / 2147483600.0 * 360.0;
  v6 = (long double)rand() / 2147483600.0;
  v3 = v7 * 3.141592653589793 / 180.0;
  sub_3F464(v3, &v5, &v4);
  *a1 = v6 * v4;
  result = a2;
  *a2 = v6 * v5;
  return result;
}

//----- (00039A6F) --------------------------------------------------------
long double __cdecl Q_rsqrt(float a1)
{
  float v3; // [esp+Ch] [ebp-Ch]

  v3 = a1 * 0.5;
  return (float)((1.5
                - v3 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
               * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (00039ADE) --------------------------------------------------------
int __cdecl Q_log2(int a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    a1 >>= 1;
    if ( !a1 )
      break;
  }
  return i;
}

//----- (00039B03) --------------------------------------------------------
long double __cdecl Q_acos(float a1)
{
  float v3; // [esp+10h] [ebp-8h]

  v3 = acos(a1);
  if ( v3 > 3.141592653589793 )
    return 3.1415927;
  if ( v3 >= -3.141592653589793 )
    return v3;
  return 3.1415927;
}

//----- (00039B6E) --------------------------------------------------------
int __cdecl ClampChar(int a1)
{
  if ( a1 < -128 )
    return -128;
  if ( a1 <= 127 )
    return (char)a1;
  return 127;
}

//----- (00039B9E) --------------------------------------------------------
int __cdecl ClampShort(int a1)
{
  if ( a1 < -32768 )
    return -32768;
  if ( a1 <= 0x7FFF )
    return (__int16)a1;
  return 0x7FFF;
}

//----- (00039BD4) --------------------------------------------------------
int __cdecl DirToByte(float *a1)
{
  float v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+8h] [ebp-10h]
  unsigned __int8 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int8 i; // [esp+Fh] [ebp-9h]

  if ( !a1 )
    return 0;
  v3 = 0.0;
  v5 = 0;
  for ( i = 0; i <= 0xA1u; ++i )
  {
    v4 = *a1 * bytedirs[3 * i] + a1[1] * bytedirs[3 * i + 1] + a1[2] * bytedirs[3 * i + 2];
    if ( v4 > (long double)v3 )
    {
      v3 = *a1 * bytedirs[3 * i] + a1[1] * bytedirs[3 * i + 1] + a1[2] * bytedirs[3 * i + 2];
      v5 = i;
    }
  }
  return v5;
}

//----- (00039CB2) --------------------------------------------------------
int __cdecl ByteToDir(int a1, int a2)
{
  int result; // eax

  if ( a1 >= 0 && a1 <= 161 )
  {
    *(float *)a2 = bytedirs[3 * a1];
    *(float *)(a2 + 4) = bytedirs[3 * a1 + 1];
    result = LODWORD(bytedirs[3 * a1 + 2]);
    *(_DWORD *)(a2 + 8) = result;
  }
  else
  {
    *(float *)a2 = vec3_origin[0];
    *(float *)(a2 + 4) = vec3_origin[1];
    result = LODWORD(vec3_origin[2]);
    *(_DWORD *)(a2 + 8) = result;
  }
  return result;
}

//----- (00039D64) --------------------------------------------------------
long double __cdecl DotProduct(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (00039D97) --------------------------------------------------------
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (00039DDB) --------------------------------------------------------
float *__cdecl VectorAdd(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (00039E1F) --------------------------------------------------------
int __cdecl VectorCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (00039E4E) --------------------------------------------------------
int __cdecl VectorScale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  result = a1 + 8;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  return result;
}

//----- (00039E86) --------------------------------------------------------
int __cdecl VectorMA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (00039ED9) --------------------------------------------------------
int __cdecl VectorCompareEpsilon(int a1, int a2)
{
  int i; // [esp+4h] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    if ( (*(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i)) * (*(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i)) > 0.0000010000001 )
      return 0;
  }
  return 1;
}

//----- (00039F6F) --------------------------------------------------------
long double __cdecl VectorLength(float *a1)
{
  return (float)sqrt(*a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2]);
}

//----- (00039FC9) --------------------------------------------------------
long double __cdecl VectorDistance(float *a1, float *a2)
{
  float v4; // [esp+30h] [ebp-18h]
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  return (float)sqrt(v4 * v4 + v5 * v5 + v6 * v6);
}

//----- (0003A03E) --------------------------------------------------------
long double __cdecl VectorDistanceSquared(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  v5 = a2[2] - a1[2];
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (0003A08F) --------------------------------------------------------
long double __cdecl VectorDistance2D(float *a1, float *a2)
{
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  return (float)sqrt(v4 * v4 + v5 * v5);
}

//----- (0003A0E9) --------------------------------------------------------
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  return v3 * v3 + v4 * v4;
}

//----- (0003A11F) --------------------------------------------------------
float *__cdecl CrossProduct(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = a1 + 1;
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (0003A193) --------------------------------------------------------
_DWORD *__cdecl CrossProductUp(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = a1[1];
  a2[1] = *a1 ^ 0x80000000;
  result = a2 + 2;
  a2[2] = 0;
  return result;
}

//----- (0003A1C3) --------------------------------------------------------
long double __cdecl VectorNormalize(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (0003A278) --------------------------------------------------------
long double __cdecl VectorNormalize2D(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
  }
  return v4;
}

//----- (0003A308) --------------------------------------------------------
long double __cdecl VectorNormalize4D(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
    a1[3] = a1[3] * v2;
  }
  return v4;
}

//----- (0003A3E2) --------------------------------------------------------
float *__cdecl VectorNormalizeFast(float *a1)
{
  long double v1; // fst7
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+10h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v3 = v1;
  Q_rsqrt(v3);
  v4 = v1;
  *a1 = *a1 * v4;
  a1[1] = a1[1] * v4;
  result = a1 + 2;
  a1[2] = a1[2] * v4;
  return result;
}

//----- (0003A466) --------------------------------------------------------
long double __cdecl VectorNormalize2(float *a1, float *a2)
{
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+1Ch] [ebp-Ch]

  v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sqrt(v4);
  if ( v5 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    v3 = 1.0 / v5;
    *a2 = *a1 * v3;
    a2[1] = a1[1] * v3;
    a2[2] = a1[2] * v3;
  }
  return v5;
}

//----- (0003A53A) --------------------------------------------------------
unsigned int __cdecl VectorInverse(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (0003A578) --------------------------------------------------------
int __cdecl Vector4Scale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  result = a1 + 12;
  *(float *)(a3 + 12) = *(float *)(a1 + 12) * a2;
  return result;
}

//----- (0003A5C3) --------------------------------------------------------
long double __cdecl VectorMax(float *a1)
{
  float v2; // [esp+0h] [ebp-Ch]
  float v3; // [esp+4h] [ebp-8h]

  if ( *a1 < (long double)a1[1] )
    v3 = a1[1];
  else
    v3 = *a1;
  if ( v3 < (long double)a1[2] )
    v2 = a1[2];
  else
    v2 = v3;
  return v2;
}

//----- (0003A62A) --------------------------------------------------------
float *__cdecl VectorRotate(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (0003A6D4) --------------------------------------------------------
int *__cdecl RotatePointAroundVector(int a1, int a2, int a3, float a4)
{
  int *result; // eax
  float v5; // [esp+1Ch] [ebp-13Ch]
  int v6; // [esp+20h] [ebp-138h] BYREF
  int v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9[4]; // [esp+30h] [ebp-128h] BYREF
  int v10[7]; // [esp+40h] [ebp-118h] BYREF
  int i; // [esp+5Ch] [ebp-FCh] BYREF
  float v12[12]; // [esp+60h] [ebp-F8h] BYREF
  char v13[48]; // [esp+90h] [ebp-C8h] BYREF
  int s; // [esp+C0h] [ebp-98h] BYREF
  int v15[3]; // [esp+C4h] [ebp-94h] BYREF
  int v16; // [esp+D0h] [ebp-88h]
  int v17; // [esp+E0h] [ebp-78h]
  char dest[4]; // [esp+F0h] [ebp-68h] BYREF
  int v19; // [esp+F4h] [ebp-64h]
  int v20; // [esp+F8h] [ebp-60h]
  int v21; // [esp+FCh] [ebp-5Ch]
  int v22; // [esp+104h] [ebp-54h]
  int v23; // [esp+108h] [ebp-50h]
  int v24; // [esp+10Ch] [ebp-4Ch]
  int src; // [esp+120h] [ebp-38h] BYREF
  int v26; // [esp+124h] [ebp-34h]
  int v27; // [esp+128h] [ebp-30h]
  int v28; // [esp+12Ch] [ebp-2Ch]
  int v29; // [esp+130h] [ebp-28h]
  int v30; // [esp+134h] [ebp-24h]
  int v31; // [esp+138h] [ebp-20h]
  int v32; // [esp+13Ch] [ebp-1Ch]
  int v33; // [esp+140h] [ebp-18h]
  _DWORD v34[2]; // [esp+150h] [ebp-8h] BYREF

  v6 = *(_DWORD *)a2;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  PerpendicularVector(v10, a2);
  CrossProduct(v10, &v6, v9);
  src = v10[0];
  v28 = v10[1];
  v31 = v10[2];
  v26 = v9[0];
  v29 = v9[1];
  v32 = v9[2];
  v27 = v6;
  v30 = v7;
  v33 = v8;
  memcpy(dest, &src, 0x24u);
  v19 = v28;
  v20 = v31;
  v21 = v26;
  v22 = v32;
  v23 = v27;
  v24 = v30;
  memset(&s, 0, 0x24u);
  v17 = 1065353216;
  v16 = 1065353216;
  s = 1065353216;
  v5 = a4 * 3.141592653589793 / 180.0;
  sub_3F464(v5, (float *)v15, (float *)&s);
  v15[2] = v15[0] ^ 0x80000000;
  v16 = s;
  MatrixMultiply(&src, &s, v13);
  result = (int *)MatrixMultiply(v13, dest, v12);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a1 + 4 * i) = v12[3 * i] * *(float *)a3
                           + *(float *)&v34[3 * i - 59] * *(float *)(a3 + 4)
                           + *(float *)&v34[3 * i - 58] * *(float *)(a3 + 8);
    result = &i;
  }
  return result;
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17B94: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 19824: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (0003A94F) --------------------------------------------------------
int __cdecl RotateAroundDirection(int a1, float a2)
{
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  PerpendicularVector(a1 + 12, a1);
  if ( a2 != 0.0 )
  {
    v3[0] = *(_DWORD *)(a1 + 12);
    v3[1] = *(_DWORD *)(a1 + 16);
    v3[2] = *(_DWORD *)(a1 + 20);
    RotatePointAroundVector(a1 + 12, a1, (int)v3, a2);
  }
  return CrossProduct(a1, a1 + 12, a1 + 24);
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 19824: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (0003A9F5) --------------------------------------------------------
int __cdecl MakeNormalVectors(float *a1, float *a2, int a3)
{
  float v4; // [esp+1Ch] [ebp-Ch]

  *((_DWORD *)a2 + 1) = *(_DWORD *)a1 ^ 0x80000000;
  a2[2] = a1[1];
  *a2 = a1[2];
  v4 = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  *a2 = -v4 * *a1 + *a2;
  a2[1] = -v4 * a1[1] + a2[1];
  a2[2] = -v4 * a1[2] + a2[2];
  VectorNormalize(a2);
  return CrossProduct(a2, a1, a3);
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0003AAFB) --------------------------------------------------------
long double __cdecl vectoyaw(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
    return 0.0;
  v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
  if ( v2 < 0.0 )
    v2 = v2 + 360.0;
  return v2;
}

//----- (0003ABA4) --------------------------------------------------------
long double __cdecl vectosignedyaw(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
    v2 = 0.0;
  else
    v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
  return v2;
}

//----- (0003AC2D) --------------------------------------------------------
long double __cdecl vectopitch(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = 270.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      v2 = v2 + 360.0;
  }
  return v2;
}

//----- (0003AD1D) --------------------------------------------------------
long double __cdecl vectosignedpitch(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = -90.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
  }
  return v2;
}

//----- (0003ADED) --------------------------------------------------------
int __cdecl vectoangles(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = 270.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
    if ( v3 < 0.0 )
      v3 = v3 + 360.0;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (0003AF4C) --------------------------------------------------------
int __cdecl vectosignedangles(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = -90.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (0003B068) --------------------------------------------------------
float *__cdecl AngleVectors(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+18h] [ebp-20h] BYREF
  float v6; // [esp+1Ch] [ebp-1Ch] BYREF
  float v7; // [esp+20h] [ebp-18h] BYREF
  float v8; // [esp+24h] [ebp-14h] BYREF
  float v9; // [esp+28h] [ebp-10h] BYREF
  float v10; // [esp+2Ch] [ebp-Ch] BYREF
  float v11; // [esp+30h] [ebp-8h]

  v11 = a1[1] * 0.0174532925199433;
  sub_3F464(v11, &v8, &v5);
  v11 = *a1 * 0.0174532925199433;
  result = sub_3F464(v11, &v9, &v6);
  if ( a2 )
  {
    *(float *)a2 = v6 * v5;
    *(float *)(a2 + 4) = v6 * v8;
    result = (float *)(LODWORD(v9) ^ 0x80000000);
    *(_DWORD *)(a2 + 8) = LODWORD(v9) ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v11 = a1[2] * 0.0174532925199433;
    result = sub_3F464(v11, &v10, &v7);
    if ( a3 )
    {
      *a3 = v10 * -1.0 * v9 * v5 + v7 * -1.0 * -v8;
      a3[1] = v10 * -1.0 * v9 * v8 + v7 * -1.0 * v5;
      result = a3 + 2;
      a3[2] = v10 * -1.0 * v6;
    }
    if ( a4 )
    {
      *a4 = v7 * v9 * v5 + v10 * v8;
      a4[1] = v7 * v9 * v8 + -v10 * v5;
      result = a4 + 2;
      a4[2] = v7 * v6;
    }
  }
  return result;
}

//----- (0003B201) --------------------------------------------------------
float *__cdecl YawVectors(float a1, int a2, int a3)
{
  float *result; // eax
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h]

  v6 = a1 * 0.0174532925199433;
  result = sub_3F464(v6, (float *)&v5, (float *)&v4);
  if ( a2 )
  {
    *(_DWORD *)a2 = v4;
    *(_DWORD *)(a2 + 4) = v5;
    result = (float *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = v5;
    *(_DWORD *)(a3 + 4) = v4 ^ 0x80000000;
    result = (float *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = 0;
  }
  return result;
}

//----- (0003B28F) --------------------------------------------------------
void __cdecl PerpendicularVector(int a1, int a2)
{
  int v2[5]; // [esp+20h] [ebp-28h] BYREF
  float v3; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v3 = 1.0;
  v5 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v3 > fabs(*(float *)(a2 + 4 * i)) )
    {
      v3 = fabs(*(float *)(a2 + 4 * i));
      v5 = i;
    }
  }
  v2[2] = 0;
  v2[1] = 0;
  v2[0] = 0;
  v2[v5] = 1065353216;
  ProjectPointOnPlane(a1, v2, a2);
  VectorNormalize(a1);
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19514: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (0003B344) --------------------------------------------------------
void __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, int a4)
{
  float v4[4]; // [esp+10h] [ebp-28h] BYREF
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  v5[0] = *a1 - *a2;
  v5[1] = a1[1] - a2[1];
  v5[2] = a1[2] - a2[2];
  VectorNormalize(v5);
  v4[0] = *a1 - *a3;
  v4[1] = a1[1] - a3[1];
  v4[2] = a1[2] - a3[2];
  VectorNormalize(v4);
  CrossProduct(v5, v4, a4);
  VectorNormalize(a4);
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0003B402) --------------------------------------------------------
float *__cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+10h] [ebp-28h] BYREF
  float v6; // [esp+14h] [ebp-24h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]

  v8 = *a1 - *a2;
  v9 = a1[1] - a2[1];
  v10 = a1[2] - a2[2];
  v5 = *a3 - *a2;
  v6 = a3[1] - a2[1];
  v7 = a3[2] - a2[2];
  VectorNormalize(&v5);
  *a4 = (v8 * v5 + v9 * v6 + v10 * v7) * v5 + *a2;
  a4[1] = (v8 * v5 + v9 * v6 + v10 * v7) * v6 + a2[1];
  result = a2 + 2;
  a4[2] = (v8 * v5 + v9 * v6 + v10 * v7) * v7 + a2[2];
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0003B508) --------------------------------------------------------
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = a1 + 8;
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (0003B714) --------------------------------------------------------
int __cdecl MatrixMultiplyEquals(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+Ch] [ebp-1Ch]
  float v7; // [esp+10h] [ebp-18h]
  float v8; // [esp+14h] [ebp-14h]

  v3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  v4 = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  v5 = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  v6 = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  v7 = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  v8 = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a2[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a2[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a2[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  *a2 = v3;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = v6;
  a2[4] = v7;
  result = LODWORD(v8);
  a2[5] = v8;
  return result;
}

//----- (0003B947) --------------------------------------------------------
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9];
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10];
  a3[3] = *a1 * a2[3] + a1[1] * a2[7] + a1[2] * a2[11] + a1[3];
  a3[4] = a1[4] * *a2 + a1[5] * a2[4] + a1[6] * a2[8];
  a3[5] = a1[4] * a2[1] + a1[5] * a2[5] + a1[6] * a2[9];
  a3[6] = a1[4] * a2[2] + a1[5] * a2[6] + a1[6] * a2[10];
  a3[7] = a1[4] * a2[3] + a1[5] * a2[7] + a1[6] * a2[11] + a1[7];
  a3[8] = a1[8] * *a2 + a1[9] * a2[4] + a1[10] * a2[8];
  a3[9] = a1[8] * a2[1] + a1[9] * a2[5] + a1[10] * a2[9];
  a3[10] = a1[8] * a2[2] + a1[9] * a2[6] + a1[10] * a2[10];
  result = a1 + 11;
  a3[11] = a1[8] * a2[3] + a1[9] * a2[7] + a1[10] * a2[11] + a1[11];
  return result;
}

//----- (0003BC1C) --------------------------------------------------------
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  a3[9] = a1[9] * *a2 + a1[10] * a2[3] + a1[11] * a2[6] + a2[9];
  a3[10] = a1[9] * a2[1] + a1[10] * a2[4] + a1[11] * a2[7] + a2[10];
  result = a2 + 11;
  a3[11] = a1[9] * a2[2] + a1[10] * a2[5] + a1[11] * a2[8] + a2[11];
  return result;
}

//----- (0003BEF1) --------------------------------------------------------
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  a3[6] = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  a3[7] = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  a3[8] = a1[8] * a2[2] + a1[9] * a2[5] + a1[10] * a2[8];
  a3[9] = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  a3[10] = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  result = a2 + 11;
  a3[11] = a1[12] * a2[2] + a1[13] * a2[5] + a1[14] * a2[8] + a2[11];
  return result;
}

//----- (0003C184) --------------------------------------------------------
int __cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3)
{
  int result; // eax

  *(float *)a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  *(float *)(a3 + 16) = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  *(float *)(a3 + 32) = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  *(float *)(a3 + 4) = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  *(float *)(a3 + 20) = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  *(float *)(a3 + 36) = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  *(float *)(a3 + 8) = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  *(float *)(a3 + 24) = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  *(float *)(a3 + 40) = a1[8] * a2[2] + a1[9] * a2[5] + a1[10] * a2[8];
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 44) = 0;
  *(float *)(a3 + 48) = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  *(float *)(a3 + 52) = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  *(float *)(a3 + 56) = a1[12] * a2[2] + a1[13] * a2[5] + a1[14] * a2[8] + a2[11];
  result = a3;
  *(_DWORD *)(a3 + 60) = 1065353216;
  return result;
}

//----- (0003C429) --------------------------------------------------------
int __cdecl MatrixTranspose(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (0003C4B8) --------------------------------------------------------
float *__cdecl MatrixInverse(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+0h] [ebp-8h]

  v3 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v4 = 1.0 / v3;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v4;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v4;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v4;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v4;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v4;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v4;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v4;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v4;
  result = a1 + 3;
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v4;
  return result;
}

//----- (0003C6EC) --------------------------------------------------------
int __cdecl MatrixInverseOrthogonal43(float *a1, int a2)
{
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  MatrixTranspose(a1, a2);
  v3[0] = 0.0 - a1[9];
  v3[1] = vec3_origin[1] - a1[10];
  v3[2] = vec3_origin[2] - a1[11];
  return MatrixTransformVector(v3, a2, a2 + 36);
}
// 17594: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 181E4: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);

//----- (0003C76D) --------------------------------------------------------
int *__cdecl MatrixInverse44(int a1, float *a2)
{
  int *result; // eax
  int i; // [esp+8h] [ebp-80h] BYREF
  float v4; // [esp+Ch] [ebp-7Ch]
  float v5; // [esp+10h] [ebp-78h]
  float v6; // [esp+14h] [ebp-74h]
  float v7; // [esp+18h] [ebp-70h]
  float v8; // [esp+1Ch] [ebp-6Ch]
  float v9; // [esp+20h] [ebp-68h]
  float v10; // [esp+24h] [ebp-64h]
  float v11; // [esp+28h] [ebp-60h]
  float v12; // [esp+2Ch] [ebp-5Ch]
  float v13; // [esp+30h] [ebp-58h]
  float v14; // [esp+34h] [ebp-54h]
  float v15; // [esp+38h] [ebp-50h]
  float v16; // [esp+3Ch] [ebp-4Ch]
  float v17; // [esp+40h] [ebp-48h]
  float v18; // [esp+44h] [ebp-44h]
  float v19; // [esp+48h] [ebp-40h]
  float v20; // [esp+4Ch] [ebp-3Ch]
  float v21; // [esp+50h] [ebp-38h]
  float v22; // [esp+54h] [ebp-34h]
  float v23; // [esp+58h] [ebp-30h]
  float v24; // [esp+5Ch] [ebp-2Ch]
  float v25; // [esp+60h] [ebp-28h]
  float v26; // [esp+64h] [ebp-24h]
  float v27; // [esp+68h] [ebp-20h]
  float v28; // [esp+6Ch] [ebp-1Ch]
  float v29; // [esp+70h] [ebp-18h]
  float v30; // [esp+74h] [ebp-14h]
  float v31; // [esp+78h] [ebp-10h]
  float v32; // [esp+7Ch] [ebp-Ch]

  for ( i = 0; i <= 3; ++i )
  {
    *(&v5 + i) = *(float *)(a1 + 16 * i);
    *(&v9 + i) = *(float *)(a1 + 16 * i + 4);
    *(&v13 + i) = *(float *)(a1 + 16 * i + 8);
    *(&v17 + i) = *(float *)(a1 + 16 * i + 12);
  }
  v21 = v15 * v20;
  v22 = v16 * v19;
  v23 = v14 * v20;
  v24 = v16 * v18;
  v25 = v14 * v19;
  v26 = v15 * v18;
  v27 = v13 * v20;
  v28 = v16 * v17;
  v29 = v13 * v19;
  v30 = v15 * v17;
  v31 = v13 * v18;
  v32 = v14 * v17;
  *a2 = v21 * v10 + v24 * v11 + v25 * v12;
  *a2 = *a2 - (v22 * v10 + v23 * v11 + v26 * v12);
  a2[1] = v22 * v9 + v27 * v11 + v30 * v12;
  a2[1] = a2[1] - (v21 * v9 + v28 * v11 + v29 * v12);
  a2[2] = v23 * v9 + v28 * v10 + v31 * v12;
  a2[2] = a2[2] - (v24 * v9 + v27 * v10 + v32 * v12);
  a2[3] = v26 * v9 + v29 * v10 + v32 * v11;
  a2[3] = a2[3] - (v25 * v9 + v30 * v10 + v31 * v11);
  a2[4] = v22 * v6 + v23 * v7 + v26 * v8;
  a2[4] = a2[4] - (v21 * v6 + v24 * v7 + v25 * v8);
  a2[5] = v21 * v5 + v28 * v7 + v29 * v8;
  a2[5] = a2[5] - (v22 * v5 + v27 * v7 + v30 * v8);
  a2[6] = v24 * v5 + v27 * v6 + v32 * v8;
  a2[6] = a2[6] - (v23 * v5 + v28 * v6 + v31 * v8);
  a2[7] = v25 * v5 + v30 * v6 + v31 * v7;
  a2[7] = a2[7] - (v26 * v5 + v29 * v6 + v32 * v7);
  v21 = v7 * v12;
  v22 = v8 * v11;
  v23 = v6 * v12;
  v24 = v8 * v10;
  v25 = v6 * v11;
  v26 = v7 * v10;
  v27 = v5 * v12;
  v28 = v8 * v9;
  v29 = v5 * v11;
  v30 = v7 * v9;
  v31 = v5 * v10;
  v32 = v6 * v9;
  a2[8] = v21 * v18 + v24 * v19 + v25 * v20;
  a2[8] = a2[8] - (v22 * v18 + v23 * v19 + v26 * v20);
  a2[9] = v22 * v17 + v27 * v19 + v30 * v20;
  a2[9] = a2[9] - (v21 * v17 + v28 * v19 + v29 * v20);
  a2[10] = v23 * v17 + v28 * v18 + v31 * v20;
  a2[10] = a2[10] - (v24 * v17 + v27 * v18 + v32 * v20);
  a2[11] = v26 * v17 + v29 * v18 + v32 * v19;
  a2[11] = a2[11] - (v25 * v17 + v30 * v18 + v31 * v19);
  a2[12] = v23 * v15 + v26 * v16 + v22 * v14;
  a2[12] = a2[12] - (v25 * v16 + v21 * v14 + v24 * v15);
  a2[13] = v29 * v16 + v21 * v13 + v28 * v15;
  a2[13] = a2[13] - (v27 * v15 + v30 * v16 + v22 * v13);
  a2[14] = v27 * v14 + v32 * v16 + v24 * v13;
  a2[14] = a2[14] - (v31 * v16 + v23 * v13 + v28 * v14);
  a2[15] = v31 * v15 + v25 * v13 + v30 * v14;
  a2[15] = a2[15] - (v29 * v14 + v32 * v15 + v26 * v13);
  result = (int *)(a2 + 3);
  v4 = v5 * *a2 + v6 * a2[1] + v7 * a2[2] + v8 * a2[3];
  v4 = 1.0 / v4;
  for ( i = 0; i <= 15; ++i )
  {
    a2[i] = a2[i] * v4;
    result = &i;
  }
  return result;
}

//----- (0003CD97) --------------------------------------------------------
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (0003CE41) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (0003CEEB) --------------------------------------------------------
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  result = a2 + 11;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  return result;
}

//----- (0003CFAD) --------------------------------------------------------
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (0003D059) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[9];
  v5 = a1[1] - a2[10];
  v6 = a1[2] - a2[11];
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = a2 + 8;
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (0003D118) --------------------------------------------------------
int __cdecl MatrixTransformVector43Equals(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  v4 = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  a1[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  *a1 = v3;
  result = LODWORD(v4);
  a1[1] = v4;
  return result;
}

//----- (0003D1E9) --------------------------------------------------------
int __cdecl VectorAngleMultiply(int a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6[2]; // [esp+20h] [ebp-8h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_3F464(v3, &v5, v6);
  v4 = *(float *)a1 * v6[0] - *(float *)(a1 + 4) * v5;
  *(float *)(a1 + 4) = *(float *)(a1 + 4) * v6[0] + *(float *)a1 * v5;
  result = LODWORD(v4);
  *(float *)a1 = v4;
  return result;
}

//----- (0003D25F) --------------------------------------------------------
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = a1 + 2;
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (0003D381) --------------------------------------------------------
unsigned int __cdecl QuatInverse(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0003D3CF) --------------------------------------------------------
int __cdecl ConvertQuatToMat(int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-2Ch]
  float v3; // [esp+0h] [ebp-2Ch]
  float v4; // [esp+4h] [ebp-28h]
  float v5; // [esp+8h] [ebp-24h]
  float v6; // [esp+8h] [ebp-24h]
  float v7; // [esp+Ch] [ebp-20h]
  float v8; // [esp+10h] [ebp-1Ch]
  float v9; // [esp+14h] [ebp-18h]
  float v10; // [esp+14h] [ebp-18h]
  float v11; // [esp+18h] [ebp-14h]
  float v12; // [esp+1Ch] [ebp-10h]
  float v13; // [esp+20h] [ebp-Ch]
  float v14; // [esp+24h] [ebp-8h]
  float v15; // [esp+24h] [ebp-8h]

  v14 = *(float *)a1 * *(float *)a1;
  v9 = *(float *)(a1 + 4) * *(float *)(a1 + 4);
  v5 = *(float *)(a1 + 8) * *(float *)(a1 + 8);
  v2 = v14 + v9 + v5 + *(float *)(a1 + 12) * *(float *)(a1 + 12);
  if ( v2 == 0.0 )
  {
    *(_DWORD *)a1 = 1065353216;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 1065353216;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    result = a1 + 32;
    *(_DWORD *)(a1 + 32) = 1065353216;
  }
  else
  {
    v3 = 2.0 / v2;
    v15 = v14 * v3;
    v10 = v9 * v3;
    v6 = v5 * v3;
    *(float *)a1 = *(float *)a1 * v3;
    v13 = *(float *)a1 * *(float *)(a1 + 4);
    v12 = *(float *)a1 * *(float *)(a1 + 8);
    v11 = *(float *)a1 * *(float *)(a1 + 12);
    *(float *)(a1 + 4) = *(float *)(a1 + 4) * v3;
    v8 = *(float *)(a1 + 4) * *(float *)(a1 + 8);
    v7 = *(float *)(a1 + 4) * *(float *)(a1 + 12);
    v4 = *(float *)(a1 + 8) * *(float *)(a1 + 12) * v3;
    *(float *)a1 = 1.0 - (v10 + v6);
    *(float *)(a1 + 4) = v13 + v4;
    *(float *)(a1 + 8) = v12 - v7;
    *(float *)(a1 + 12) = v13 - v4;
    *(float *)(a1 + 16) = 1.0 - (v15 + v6);
    *(float *)(a1 + 20) = v8 + v11;
    *(float *)(a1 + 24) = v12 + v7;
    *(float *)(a1 + 28) = v8 - v11;
    result = a1 + 32;
    *(float *)(a1 + 32) = 1.0 - (v15 + v10);
  }
  return result;
}

//----- (0003D602) --------------------------------------------------------
long double __cdecl QuatEigenTrace(float *a1)
{
  float v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+8h] [ebp-10h]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+Ch] [ebp-Ch]
  float v9; // [esp+10h] [ebp-8h]
  float v10; // [esp+10h] [ebp-8h]

  v9 = *a1 * *a1;
  v7 = a1[1] * a1[1];
  v5 = a1[2] * a1[2];
  v3 = v9 + v7 + v5 + a1[3] * a1[3];
  if ( v3 == 0.0 )
    return 0.0;
  v4 = 1.0 / v3;
  v10 = v9 * v4;
  v8 = v7 * v4;
  v6 = v5 * v4;
  return (float)(v10 + v8 + v6);
}

//----- (0003D6C2) --------------------------------------------------------
long double __cdecl AngleEigenTrace(float a1)
{
  double v3; // [esp+18h] [ebp-10h]

  v3 = sin(a1 * 0.0174532925199433);
  return (float)(v3 * v3);
}

//----- (0003D702) --------------------------------------------------------
void __cdecl QuatRatioEigenTrace(int a1, int a2)
{
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  QuatInverse(a2, v3);
  QuatMultiply(a1, v3, v2);
  QuatEigenTrace(v2);
}
// 17504: using guessed type _DWORD __cdecl QuatInverse(_DWORD, _DWORD);
// 17B74: using guessed type _DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD);
// 18DD4: using guessed type double __cdecl QuatEigenTrace(_DWORD);

//----- (0003D750) --------------------------------------------------------
long double __cdecl RotationToYaw(float *a1)
{
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  v5 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v5;
  v4 = 2.0 / v3;
  return (float)(atan2(*a1 * a1[1] * v4, 1.0 - v5 * v4) * 57.29577951308232);
}

//----- (0003D7D7) --------------------------------------------------------
float *__cdecl PitchToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return sub_3F464(v3, (float *)(a2 + 4), (float *)(a2 + 12));
}

//----- (0003D831) --------------------------------------------------------
float *__cdecl YawToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return sub_3F464(v3, (float *)(a2 + 8), (float *)(a2 + 12));
}

//----- (0003D88B) --------------------------------------------------------
float *__cdecl RollToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return sub_3F464(v3, (float *)a2, (float *)(a2 + 12));
}

//----- (0003D8E5) --------------------------------------------------------
int __cdecl ColorBytes3(float a1, float a2, float a3)
{
  int v4; // [esp+8h] [ebp-8h]

  LOBYTE(v4) = (__int16)(a1 * 255.0);
  BYTE1(v4) = (__int16)(a2 * 255.0);
  BYTE2(v4) = (__int16)(a3 * 255.0);
  HIBYTE(v4) = -1;
  return v4;
}

//----- (0003D964) --------------------------------------------------------
int __cdecl ColorBytes4(float a1, float a2, float a3, float a4)
{
  int v5; // [esp+8h] [ebp-8h]

  LOBYTE(v5) = (__int16)(a1 * 255.0);
  BYTE1(v5) = (__int16)(a2 * 255.0);
  BYTE2(v5) = (__int16)(a3 * 255.0);
  HIBYTE(v5) = (__int16)(a4 * 255.0);
  return v5;
}

//----- (0003D9FA) --------------------------------------------------------
long double __cdecl NormalizeColor(float *a1, float *a2)
{
  float v3; // [esp+4h] [ebp-Ch]

  v3 = *a1;
  if ( a1[1] > (long double)*a1 )
    v3 = a1[1];
  if ( a1[2] > (long double)v3 )
    v3 = a1[2];
  if ( v3 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    *a2 = *a1 / v3;
    a2[1] = a1[1] / v3;
    a2[2] = a1[2] / v3;
  }
  return v3;
}

//----- (0003DACD) --------------------------------------------------------
long double __cdecl AngleMod(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (0003DB20) --------------------------------------------------------
long double __cdecl LerpAngle(float a1, int a2, float a3)
{
  int v4; // [esp+4h] [ebp-Ch]

  v4 = a2;
  if ( *(float *)&a2 - a1 > 180.0 )
    *(float *)&v4 = *(float *)&a2 - 360.0;
  if ( *(float *)&v4 - a1 < -180.0 )
    *(float *)&v4 = *(float *)&v4 + 360.0;
  return (float)((*(float *)&v4 - a1) * a3 + a1);
}

//----- (0003DBA0) --------------------------------------------------------
long double __cdecl AngleSubtract(float a1, float a2)
{
  float i; // [esp+4h] [ebp-8h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (0003DC11) --------------------------------------------------------
float *__usercall AnglesSubtract@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4)
{
  float *result; // eax

  AngleSubtract(*a2, *a3);
  *a4 = a1;
  AngleSubtract(a2[1], a3[1]);
  a4[1] = a1;
  AngleSubtract(a2[2], a3[2]);
  result = a4 + 2;
  a4[2] = a1;
  return result;
}

//----- (0003DC8C) --------------------------------------------------------
long double __cdecl AngleNormalize360(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (0003DCDF) --------------------------------------------------------
long double __usercall AngleNormalize180@<st0>(long double a1@<st0>, float a2)
{
  float v3; // [esp+10h] [ebp-8h]

  AngleNormalize360(a2);
  v3 = a1;
  if ( v3 > 180.0 )
    v3 = v3 - 360.0;
  return v3;
}

//----- (0003DD30) --------------------------------------------------------
long double __cdecl AngleNormalize360Accurate(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  if ( a1 >= 0.0 )
  {
    if ( a1 < 360.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 >= 360.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 < 0.0 );
    v2 = a1;
  }
  return v2;
}

//----- (0003DDC5) --------------------------------------------------------
long double __cdecl AngleNormalize180Accurate(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  if ( a1 > -180.0 )
  {
    if ( a1 <= 180.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 > 180.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 <= -180.0 );
    v2 = a1;
  }
  return v2;
}

//----- (0003DE5A) --------------------------------------------------------
int __cdecl AngleDelta(float a1, float a2)
{
  float v3; // [esp+0h] [ebp-8h]

  v3 = a1 - a2;
  return AngleNormalize180(v3);
}

//----- (0003DE80) --------------------------------------------------------
long double __cdecl RadiusFromBounds(int a1, int a2)
{
  float v3; // [esp+2Ch] [ebp-3Ch]
  float v5; // [esp+38h] [ebp-30h]
  float v6; // [esp+3Ch] [ebp-2Ch]
  float v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+44h] [ebp-24h]
  float v9; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v6 = fabs(*(float *)(a1 + 4 * i));
    v5 = fabs(*(float *)(a2 + 4 * i));
    if ( v6 <= (long double)v5 )
      v3 = v5;
    else
      v3 = v6;
    *(&v7 + i) = v3;
  }
  return (float)sqrt(v7 * v7 + v8 * v8 + v9 * v9);
}

//----- (0003DF31) --------------------------------------------------------
int __cdecl ClearBounds(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[2] = 1216348160;
  a1[1] = 1216348160;
  *a1 = 1216348160;
  result = -931135488;
  a2[2] = -931135488;
  a2[1] = -931135488;
  *a2 = -931135488;
  return result;
}

//----- (0003DF7B) --------------------------------------------------------
void __cdecl AddPointToBounds(float *a1, float *a2, float *a3)
{
  if ( *a2 > (long double)*a1 )
    *a2 = *a1;
  if ( *a1 > (long double)*a3 )
    *a3 = *a1;
  if ( a2[1] > (long double)a1[1] )
    a2[1] = a1[1];
  if ( a1[1] > (long double)a3[1] )
    a3[1] = a1[1];
  if ( a2[2] > (long double)a1[2] )
    a2[2] = a1[2];
  if ( a1[2] > (long double)a3[2] )
    a3[2] = a1[2];
}

//----- (0003E064) --------------------------------------------------------
void __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4)
{
  if ( *a3 > (long double)*a1 )
    *a3 = *a1;
  if ( *a2 > (long double)*a4 )
    *a4 = *a2;
  if ( a3[1] > (long double)a1[1] )
    a3[1] = a1[1];
  if ( a2[1] > (long double)a4[1] )
    a4[1] = a2[1];
  if ( a3[2] > (long double)a1[2] )
    a3[2] = a1[2];
  if ( a2[2] > (long double)a4[2] )
    a4[2] = a2[2];
}

//----- (0003E14D) --------------------------------------------------------
_DWORD *__cdecl AxisClear(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1065353216;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = a1 + 8;
  a1[8] = 1065353216;
  return result;
}

//----- (0003E1BB) --------------------------------------------------------
int __cdecl AxisCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (0003E24A) --------------------------------------------------------
float *__cdecl AnglesToAxis(int a1, float *a2)
{
  float *result; // eax
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  AngleVectors(a1, a2, v3, a2 + 6);
  a2[3] = 0.0 - v3[0];
  a2[4] = vec3_origin[1] - v3[1];
  result = vec3_origin;
  a2[5] = vec3_origin[2] - v3[2];
  return result;
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003E2C0) --------------------------------------------------------
float *__cdecl YawToAxis(float a1, int a2)
{
  float *result; // eax
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  YawVectors(a1, a2, (int)v3);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(float *)(a2 + 12) = 0.0 - *(float *)v3;
  *(float *)(a2 + 16) = vec3_origin[1] - *(float *)&v3[1];
  result = vec3_origin;
  *(float *)(a2 + 20) = vec3_origin[2] - *(float *)&v3[2];
  return result;
}

//----- (0003E350) --------------------------------------------------------
int __cdecl AxisToAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectoangles(a1, a2);
  v9 = *((float *)a1 + 3);
  v10 = *((float *)a1 + 4);
  v11 = *((float *)a1 + 5);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 18BB4: using guessed type double __cdecl vectosignedpitch(_DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0003E4C8) --------------------------------------------------------
int __cdecl Axis4ToAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectoangles(a1, a2);
  v9 = *((float *)a1 + 4);
  v10 = *((float *)a1 + 5);
  v11 = *((float *)a1 + 6);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 18BB4: using guessed type double __cdecl vectosignedpitch(_DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0003E640) --------------------------------------------------------
int __cdecl AxisToSignedAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectosignedangles(a1, a2);
  v9 = *((float *)a1 + 3);
  v10 = *((float *)a1 + 4);
  v11 = *((float *)a1 + 5);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_3F464(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 187A4: using guessed type _DWORD __cdecl vectosignedangles(_DWORD, _DWORD);
// 18BB4: using guessed type double __cdecl vectosignedpitch(_DWORD);

//----- (0003E7B8) --------------------------------------------------------
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  v7[0] = *a3 - *a2;
  v7[1] = a3[1] - a2[1];
  v7[2] = a3[2] - a2[2];
  v6[0] = *a4 - *a2;
  v6[1] = a4[1] - a2[1];
  v6[2] = a4[2] - a2[2];
  CrossProduct(v6, v7, a1);
  if ( VectorNormalize(a1) == 0.0 )
    return 0;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return 1;
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0003E8B6) --------------------------------------------------------
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+Ch] [ebp-2Ch]
  float v6; // [esp+10h] [ebp-28h]
  float v7; // [esp+14h] [ebp-24h]
  float v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-Ch]

  v4 = *a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2];
  v5 = 1.0 / v4;
  v9 = (*a3 * *a2 + a3[1] * a2[1] + a3[2] * a2[2]) * v5;
  v6 = *a3 * v5;
  v7 = a3[1] * v5;
  v8 = a3[2] * v5;
  *a1 = *a2 - v9 * v6;
  a1[1] = a2[1] - v9 * v7;
  result = a2 + 2;
  a1[2] = a2[2] - v9 * v8;
  return result;
}

//----- (0003E9A8) --------------------------------------------------------
int __cdecl SetPlaneSignbits(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-Ch]
  unsigned __int8 v3; // [esp+7h] [ebp-5h]

  v3 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a1 + 4 * i) < 0.0 )
      v3 |= 1 << i;
  }
  result = v3;
  *(_BYTE *)(a1 + 17) = v3;
  return result;
}

//----- (0003EA0E) --------------------------------------------------------
_BOOL4 __cdecl BoxDistSqrdExceeds(int a1, int a2, int a3, float a4)
{
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+4h] [ebp-44h]
  float v7; // [esp+8h] [ebp-40h]
  float v8; // [esp+Ch] [ebp-3Ch]
  float v9[4]; // [esp+10h] [ebp-38h]
  float v10[7]; // [esp+20h] [ebp-28h]
  int i; // [esp+3Ch] [ebp-Ch]

  v10[0] = *(float *)a1 - *(float *)a3;
  v10[1] = *(float *)(a1 + 4) - *(float *)(a3 + 4);
  v10[2] = *(float *)(a1 + 8) - *(float *)(a3 + 8);
  v9[0] = *(float *)a2 - *(float *)a3;
  v9[1] = *(float *)(a2 + 4) - *(float *)(a3 + 4);
  v9[2] = *(float *)(a2 + 8) - *(float *)(a3 + 8);
  v8 = 0.0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v10[i] * v9[i] > 0.0 )
    {
      v7 = v10[i] * v10[i];
      v6 = v9[i] * v9[i];
      if ( v7 <= (long double)v6 )
        v5 = v8 + v7;
      else
        v5 = v8 + v6;
      v8 = v5;
    }
  }
  return v8 > (long double)a4;
}

//----- (0003EB22) --------------------------------------------------------
_BYTE *__cdecl NormalToLatLong(float *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  unsigned __int8 v3; // [esp+23h] [ebp-5h]

  if ( *a1 == 0.0 && a1[1] == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      *a2 = 0x80;
    else
      *a2 = 0;
    result = a2 + 1;
    a2[1] = 0;
  }
  else
  {
    v3 = (__int16)(atan2(a1[1], *a1) * 180.0 / 3.141592653589793 * 0.7083333134651184);
    *a2 = (__int16)(acos(a1[2]) * 180.0 / 3.141592653589793 * 0.7083333134651184);
    result = (_BYTE *)v3;
    a2[1] = v3;
  }
  return result;
}

//----- (0003EC50) --------------------------------------------------------
int __cdecl Vec10Copy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  result = a1[9];
  a2[9] = result;
  return result;
}

//----- (0003ECEF) --------------------------------------------------------
long double __cdecl Q_rint(float a1)
{
  return (float)floor(a1 + 0.5);
}

//----- (0003ED26) --------------------------------------------------------
long double __cdecl ColorNormalize(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-14h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]

  v5 = *a1;
  if ( a1[1] > (long double)*a1 )
    v5 = a1[1];
  if ( a1[2] > (long double)v5 )
    v5 = a1[2];
  if ( v5 == 0.0 )
  {
    a2[2] = 1.0;
    a2[1] = 1.0;
    *a2 = 1.0;
    v3 = 0.0;
  }
  else
  {
    v4 = 1.0 / v5;
    *a2 = *a1 * v4;
    a2[1] = a1[1] * v4;
    a2[2] = a1[2] * v4;
    v3 = v5;
  }
  return v3;
}

//----- (0003EE0E) --------------------------------------------------------
int __cdecl VectorRotateAngles(int *a1, int a2, _DWORD *a3)
{
  int result; // eax
  double v4; // [esp+20h] [ebp-68h] BYREF
  double v5; // [esp+28h] [ebp-60h] BYREF
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9[7]; // [esp+44h] [ebp-44h]
  int v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  int v12; // [esp+68h] [ebp-20h]
  int v13; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]

  v10 = *a1;
  v11 = a1[1];
  v12 = a1[2];
  v13 = v10;
  v14 = v11;
  v15 = v12;
  v8 = 1;
  v9[0] = 2;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i) != 0.0 )
    {
      v6 = *(float *)(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_3F47C(v6, &v4, &v5);
      *((float *)&v13 + *(&v8 + 2 * i)) = *((float *)&v10 + *(&v8 + 2 * i)) * v5 - *((float *)&v10 + v9[2 * i]) * v4;
      *((float *)&v13 + v9[2 * i]) = *((float *)&v10 + *(&v8 + 2 * i)) * v4 + *((float *)&v10 + v9[2 * i]) * v5;
    }
    v10 = v13;
    v11 = v14;
    v12 = v15;
  }
  *a3 = v13;
  a3[1] = v14;
  result = v15;
  a3[2] = v15;
  return result;
}

//----- (0003EF8D) --------------------------------------------------------
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5[4]; // [esp+10h] [ebp-28h] BYREF
  float v6[6]; // [esp+20h] [ebp-18h] BYREF

  v6[0] = *a1 - *a3;
  v6[1] = a1[1] - a3[1];
  v6[2] = a1[2] - a3[2];
  VectorRotateAngles(v6, a2, v5);
  *a4 = v5[0] + *a3;
  a4[1] = v5[1] + a3[1];
  result = a3 + 2;
  a4[2] = v5[2] + a3[2];
  return result;
}
// 192F4: using guessed type _DWORD __cdecl VectorRotateAngles(_DWORD, _DWORD, _DWORD);

//----- (0003F024) --------------------------------------------------------
int __cdecl VectorPolar(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-10h] BYREF
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h] BYREF
  float v7; // [esp+24h] [ebp-4h] BYREF

  sub_3F464(*(float *)&a3, &v7, &v6);
  sub_3F464(*(float *)&a3, &v5, &v4);
  *(float *)a1 = a2 * v6 * v4;
  *(float *)(a1 + 4) = a2 * v7 * v4;
  result = a1 + 8;
  *(float *)(a1 + 8) = a2 * v5;
  return result;
}

//----- (0003F08B) --------------------------------------------------------
void __cdecl VectorSnap(float *a1)
{
  *a1 = floor(*a1 + 0.5);
  a1[1] = floor(a1[1] + 0.5);
  a1[2] = floor(a1[2] + 0.5);
}

//----- (0003F0FF) --------------------------------------------------------
float *__cdecl Vector5Add(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  a3[3] = a1[3] + a2[3];
  result = a1 + 4;
  a3[4] = a1[4] + a2[4];
  return result;
}

//----- (0003F173) --------------------------------------------------------
int __cdecl Vector5Scale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  *(float *)(a3 + 12) = *(float *)(a1 + 12) * a2;
  result = a1 + 16;
  *(float *)(a3 + 16) = *(float *)(a1 + 16) * a2;
  return result;
}

//----- (0003F1D1) --------------------------------------------------------
int __cdecl Vector53Copy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (0003F200) --------------------------------------------------------
long double __cdecl RoundFloat(float a1, int a2)
{
  long double v2; // fst7
  double v5; // [esp+30h] [ebp-18h]
  double x[2]; // [esp+38h] [ebp-10h] BYREF

  x[0] = pow(10.0, (double)a2) * a1;
  v5 = modf(x[0], x);
  if ( v5 < 0.5 )
  {
    if ( v5 <= -0.5 )
      x[0] = x[0] + -1.0;
  }
  else
  {
    x[0] = x[0] + 1.0;
  }
  v2 = pow(0.1, (double)a2);
  return (float)(v2 * x[0]);
}

//----- (0003F2C9) --------------------------------------------------------
void __cdecl PitchForYawOnNormal(float a1, int a2)
{
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  int v3[6]; // [esp+20h] [ebp-18h] BYREF

  YawVectors(a1, (int)v3, 0);
  ProjectPointOnPlane(v2, v3, a2);
  vectopitch(v2);
}
// 16B24: using guessed type long double __cdecl vectopitch(_DWORD);
// 19514: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (0003F31F) --------------------------------------------------------
int __cdecl Rand_Init(int a1)
{
  int result; // eax

  result = a1;
  dword_ACAD8 = a1;
  return result;
}
// ACAD8: using guessed type int dword_ACAD8;

//----- (0003F33A) --------------------------------------------------------
long double __cdecl flrand(float a1, float a2)
{
  float v3; // [esp+4h] [ebp-8h]

  dword_ACAD8 = 214013 * dword_ACAD8 + 2531011;
  v3 = (float)((unsigned int)dword_ACAD8 >> 17);
  return (float)((a2 - a1) * v3 / 32768.0 + a1);
}
// ACAD8: using guessed type int dword_ACAD8;

//----- (0003F3A3) --------------------------------------------------------
int __cdecl irand(int a1, int a2)
{
  dword_ACAD8 = 214013 * dword_ACAD8 + 2531011;
  return a1 + ((int)(((unsigned int)dword_ACAD8 >> 17) * (a2 - a1)) >> 15);
}
// ACAD8: using guessed type int dword_ACAD8;

//----- (0003F3F6) --------------------------------------------------------
long double __cdecl Q_SwayRand(float a1, float a2, float a3)
{
  long double v3; // fst7
  long double v4; // fst7
  double v6; // [esp+10h] [ebp-18h]

  v3 = a3 / 1000.0 * a1 * 3.141592653589793;
  v6 = sin(v3 + v3);
  v4 = a3 / 1000.0 * a2 * 3.141592653589793;
  return (float)(cos(v4 + v4) * v6);
}

//----- (0003F464) --------------------------------------------------------
float *__cdecl sub_3F464(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0003F47C) --------------------------------------------------------
double *__cdecl sub_3F47C(double a1, double *a2, double *a3)
{
  long double v3; // fst7
  double *result; // eax

  *a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *a3 = v3;
  return result;
}

//----- (0003F4CE) --------------------------------------------------------
void sub_3F4CE()
{
  ;
}

//----- (0003F4D4) --------------------------------------------------------
_DWORD *__cdecl G_CheckFlameDamage(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+3Ch] [ebp-2Ch]
  float v3[6]; // [esp+40h] [ebp-28h] BYREF
  int v4; // [esp+58h] [ebp-10h]
  _DWORD *v5; // [esp+5Ch] [ebp-Ch]

  if ( dword_ACADC < 0 )
    dword_ACADC = (unsigned __int8)BG_GetWeaponIndexForName((unsigned __int8)&aFlamethrowerMp[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  result = (_DWORD *)(*(_DWORD *)(a1[88] + 17976) & 1);
  if ( result )
  {
    result = (_DWORD *)(level[123] - 3000);
    if ( *(_DWORD *)(a1[88] + 18208) > (int)result )
    {
      v5 = &g_entities[211 * *(_DWORD *)(a1[88] + 18212)];
      result = v5;
      if ( v5[88] )
      {
        v3[0] = *(float *)(a1[88] + 20) - *(float *)(v5[88] + 20);
        v3[1] = *(float *)(a1[88] + 24) - *(float *)(v5[88] + 24);
        v3[2] = *(float *)(a1[88] + 28) - *(float *)(v5[88] + 28);
        VectorNormalize(v3);
        v4 = BG_GetInfoForWeapon(dword_ACADC);
        v2 = *(_DWORD *)(v4 + 520);
        if ( a1 != v5 )
          v2 *= 4;
        result = (_DWORD *)G_Damage(a1, v5, v5, v3, v5[88] + 20, v2, 0, 25, 0);
      }
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// ACADC: using guessed type int dword_ACADC;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0003F65A) --------------------------------------------------------
int __cdecl P_DamageFeedback(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+2Ch] [ebp-6Ch]
  float v3[15]; // [esp+30h] [ebp-68h] BYREF
  float v4; // [esp+6Ch] [ebp-2Ch]
  float v5[6]; // [esp+70h] [ebp-28h] BYREF
  int v6; // [esp+88h] [ebp-10h]
  int v7; // [esp+8Ch] [ebp-Ch]

  v7 = a1[88];
  result = v7;
  if ( *(int *)(v7 + 4) <= 5 )
  {
    result = *(_DWORD *)(v7 + 18008);
    v6 = result;
    if ( result > 0 )
    {
      result = v7;
      if ( *(int *)(v7 + 17796) > 0 )
      {
        v6 = 100 * v6 / *(_DWORD *)(v7 + 17796);
        if ( v6 > 127 )
          v6 = 127;
        *(float *)(v7 + 1576) = (long double)v6 + *(float *)(v7 + 1576);
        if ( *(float *)(v7 + 1576) > 255.0 )
          *(_DWORD *)(v7 + 1576) = 1132396544;
        v4 = (long double)v6 * 0.2;
        if ( v4 >= 5.0 )
        {
          if ( v4 > 90.0 )
            v4 = 90.0;
        }
        else
        {
          v4 = 5.0;
        }
        if ( *(_DWORD *)(v7 + 18024) )
        {
          *(_DWORD *)(v7 + 18124) = 0;
          *(_DWORD *)(v7 + 18128) = LODWORD(v4) ^ 0x80000000;
          *(_DWORD *)(v7 + 276) = 255;
          *(_DWORD *)(v7 + 272) = 255;
          *(_DWORD *)(v7 + 18024) = 0;
        }
        else
        {
          vectoangles(v7 + 18012, v5);
          AnglesToAxis(v7 + 232, v3);
          *(float *)(v7 + 18124) = -v4
                                 * (*(float *)(v7 + 18012) * v3[3]
                                  + *(float *)(v7 + 18016) * v3[4]
                                  + *(float *)(v7 + 18020) * v3[5]);
          *(float *)(v7 + 18128) = (*(float *)(v7 + 18012) * v3[0]
                                  + *(float *)(v7 + 18016) * v3[1]
                                  + *(float *)(v7 + 18020) * v3[2])
                                 * v4;
          *(_DWORD *)(v7 + 276) = (int)(v5[0] / 360.0 * 256.0);
          *(_DWORD *)(v7 + 272) = (int)(v5[1] / 360.0 * 256.0);
        }
        if ( level[123] > a1[141] && (a1[99] & 1) == 0 )
        {
          v2 = (int)((long double)*(int *)(v7 + 284) / (long double)*(int *)(v7 + 292) * 100.0);
          if ( v2 >= 0 )
          {
            if ( v2 > 100 )
              v2 = 100;
            G_AddEvent(a1, 191, v2);
          }
          else
          {
            G_AddEvent(a1, 191, 0);
          }
          a1[141] = level[123] + 700;
        }
        ++*(_DWORD *)(v7 + 268);
        *(_DWORD *)(v7 + 18120) = level[123] - 20;
        *(_DWORD *)(v7 + 280) = v6;
        result = v7;
        *(_DWORD *)(v7 + 18008) = 0;
      }
    }
  }
  return result;
}
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0003F9A8) --------------------------------------------------------
int __cdecl G_SetClientSound(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (0003F9BA) --------------------------------------------------------
int __cdecl ClientImpacts(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a2 + 84) )
      break;
    for ( j = 0; j < i && *(_DWORD *)(a2 + 4 * j + 88) != *(_DWORD *)(a2 + 4 * i + 88); ++j )
      ;
    if ( j == i )
    {
      v3 = &g_entities[211 * *(_DWORD *)(a2 + 4 * i + 88)];
      if ( Scr_IsSystemActive(1) )
      {
        Scr_AddEntity(v3);
        Scr_Notify(a1, scr_const[87], 1);
        Scr_AddEntity(a1);
        Scr_Notify(v3, scr_const[87], 1);
      }
      if ( v3[135] )
        ((void (__cdecl *)(_DWORD *, int, int))v3[135])(v3, a1, 1);
      if ( *(_DWORD *)(a1 + 540) )
        (*(void (__cdecl **)(int, _DWORD *, int))(a1 + 540))(a1, v3, 1);
    }
  }
  return result;
}
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0003FB15) --------------------------------------------------------
int __cdecl G_TouchTriggers(int a1)
{
  int result; // eax
  float v2; // [esp+20h] [ebp-1048h] BYREF
  float v3; // [esp+24h] [ebp-1044h]
  float v4; // [esp+28h] [ebp-1040h]
  float v5; // [esp+30h] [ebp-1038h] BYREF
  float v6; // [esp+34h] [ebp-1034h]
  float v7; // [esp+38h] [ebp-1030h]
  _DWORD *v8; // [esp+4Ch] [ebp-101Ch]
  int v9[1026]; // [esp+50h] [ebp-1018h] BYREF
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  result = a1;
  if ( *(_DWORD *)(a1 + 352) )
  {
    result = *(_DWORD *)(a1 + 352);
    if ( *(int *)(result + 4) <= 1 )
    {
      v5 = *(float *)(*(_DWORD *)(a1 + 352) + 20) - flt_ACAE0;
      v6 = *(float *)(*(_DWORD *)(a1 + 352) + 24) - flt_ACAE4;
      v7 = *(float *)(*(_DWORD *)(a1 + 352) + 28) - flt_ACAE8;
      v2 = *(float *)(*(_DWORD *)(a1 + 352) + 20) + flt_ACAE0;
      v3 = *(float *)(*(_DWORD *)(a1 + 352) + 24) + flt_ACAE4;
      v4 = *(float *)(*(_DWORD *)(a1 + 352) + 28) + flt_ACAE8;
      v10 = trap_EntitiesInBox(&v5, &v2, v9, 1024, 1079771144);
      v5 = *(float *)(*(_DWORD *)(a1 + 352) + 20) + *(float *)(a1 + 264);
      v6 = *(float *)(*(_DWORD *)(a1 + 352) + 24) + *(float *)(a1 + 268);
      v7 = *(float *)(*(_DWORD *)(a1 + 352) + 28) + *(float *)(a1 + 272);
      v2 = *(float *)(*(_DWORD *)(a1 + 352) + 20) + *(float *)(a1 + 276);
      v3 = *(float *)(*(_DWORD *)(a1 + 352) + 24) + *(float *)(a1 + 280);
      v4 = *(float *)(*(_DWORD *)(a1 + 352) + 28) + *(float *)(a1 + 284);
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v10 )
          return result;
        v8 = &g_entities[211 * v9[i]];
        if ( v8[135] || *(_DWORD *)(a1 + 540) )
        {
          if ( v8[1] == 3 )
          {
            if ( !BG_PlayerTouchesItem(*(_DWORD *)(a1 + 352), v8, level[123]) )
              continue;
          }
          else if ( !trap_EntityContact(&v5, &v2, v8) )
          {
            continue;
          }
          if ( Scr_IsSystemActive(1) )
          {
            Scr_AddEntity(a1);
            Scr_Notify(v8, scr_const[87], 1);
            Scr_AddEntity(v8);
            Scr_Notify(a1, scr_const[87], 1);
          }
          if ( v8[135] )
            ((void (__cdecl *)(_DWORD *, int, int))v8[135])(v8, a1, 1);
        }
      }
    }
  }
  return result;
}
// 16EF4: using guessed type _DWORD __cdecl BG_PlayerTouchesItem(_DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 174C4: using guessed type _DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD);
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// ACAE0: using guessed type float flt_ACAE0;
// ACAE4: using guessed type float flt_ACAE4;
// ACAE8: using guessed type float flt_ACAE8;

//----- (0003FE31) --------------------------------------------------------
int __cdecl G_EntityType(int a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( LOBYTE(g_entities[211 * a1 + 91]) )
    v2 = g_entities[211 * a1 + 1];
  else
    v2 = -1;
  return v2;
}
// 3FE31: using guessed type int __cdecl G_EntityType(int);

//----- (0003FE8A) --------------------------------------------------------
int __cdecl SpectatorThink(_DWORD *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+1Ch] [ebp-12Ch]
  int s[74]; // [esp+20h] [ebp-128h] BYREF

  v3 = a1[88];
  *(_DWORD *)(v3 + 17968) = *(_DWORD *)(v3 + 17964);
  *(_DWORD *)(v3 + 17964) = *(unsigned __int8 *)(v3 + 17704);
  *(_DWORD *)(v3 + 17980) = *(_DWORD *)(v3 + 17976);
  *(_DWORD *)(v3 + 17976) = *(unsigned __int8 *)(v3 + 17705);
  if ( *(int *)(v3 + 17672) < 0
    && G_ClientCanSpectateTeam(v3, 4)
    && *(int *)(v3 + 17944) >= 0
    && (*(_DWORD *)(v3 + 17964) & 0x10) != (*(_DWORD *)(v3 + 17968) & 0x10) )
  {
    StopFollowing(a1);
  }
  if ( (*(_DWORD *)(v3 + 17964) & 1) == 0 || (*(_DWORD *)(v3 + 17968) & 1) != 0 )
  {
    if ( (*(_DWORD *)(v3 + 17964) & 0x20) != 0 && (*(_DWORD *)(v3 + 17968) & 0x20) == 0 )
      Cmd_FollowCycle_f(a1, -1);
  }
  else
  {
    Cmd_FollowCycle_f(a1, 1);
  }
  result = *(_DWORD *)(v3 + 12) & 0x40000;
  if ( !result )
  {
    *(_DWORD *)(v3 + 4) = 4;
    if ( G_ClientCanSpectateTeam(v3, 4) )
      *(_DWORD *)(v3 + 72) = 400;
    else
      *(_DWORD *)(v3 + 72) = 0;
    memset(s, 0, 0x11Cu);
    s[0] = v3;
    s[1] = *a2;
    s[2] = a2[1];
    s[3] = a2[2];
    s[4] = a2[3];
    s[5] = a2[4];
    s[6] = a2[5];
    s[13] = 8388625;
    s[65] = (int)trap_TraceCapsule;
    s[66] = (int)trap_TraceCapsule;
    s[67] = (int)trap_TraceCapsule;
    s[68] = (int)trap_PointContents;
    s[69] = (int)G_EntityType;
    s[70] = G_IsInMatchTimeout();
    Pmove(s);
    a1[79] = *(_DWORD *)(v3 + 20);
    a1[80] = *(_DWORD *)(v3 + 24);
    a1[81] = *(_DWORD *)(v3 + 28);
    result = trap_UnlinkEntity(a1);
  }
  return result;
}
// 17014: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 17694: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 17AA4: using guessed type _DWORD __cdecl Pmove(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18B74: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);
// 19584: using guessed type int G_IsInMatchTimeout(void);
// 3FE31: using guessed type int __cdecl G_EntityType(int);
// 74130: using guessed type int __cdecl trap_TraceCapsule(int, int, int, int, int, int, int);
// 7443A: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (0004013C) --------------------------------------------------------
int __cdecl ClientInactivityTimer(int a1)
{
  if ( !g_inactivity[3] )
  {
    *(_DWORD *)(a1 + 18040) = level[123] + 60000;
    *(_DWORD *)(a1 + 18048) = 0;
    return 1;
  }
  if ( *(_BYTE *)(a1 + 17720) || *(_BYTE *)(a1 + 17721) || *(_BYTE *)(a1 + 17722) || (*(_BYTE *)(a1 + 17704) & 1) != 0 )
  {
    *(_DWORD *)(a1 + 18040) = level[123] + 1000 * g_inactivity[3];
    *(_DWORD *)(a1 + 18048) = 0;
    return 1;
  }
  if ( *(_DWORD *)(a1 + 17748) )
    return 1;
  if ( level[123] <= *(_DWORD *)(a1 + 18040) )
  {
    if ( level[123] > *(_DWORD *)(a1 + 18040) - 10000 && !*(_DWORD *)(a1 + 18048) )
    {
      *(_DWORD *)(a1 + 18048) = 1;
      trap_SendServerCommand(-1380760827 * ((a1 - level[0]) >> 2), 0, "c \"GAME_INACTIVEDROPWARNING\"");
    }
    return 1;
  }
  trap_DropClient(-1380760827 * ((a1 - level[0]) >> 2), "GAME_DROPPEDFORINACTIVITY");
  return 0;
}
// 17E44: using guessed type _DWORD __cdecl trap_DropClient(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000402C0) --------------------------------------------------------
int __cdecl ClientSpectatorInactivityTimer(int a1)
{
  if ( *(int *)(a1 + 18044) < 0 )
  {
    *(_DWORD *)(a1 + 18044) = level[123] + 60000;
    *(_DWORD *)(a1 + 18052) = 0;
  }
  if ( dword_D0DE0 )
    trap_Cvar_Update(&dword_D0DE0);
  else
    trap_Cvar_Register(&dword_D0DE0, "sv_privateClients", "0", 4);
  if ( !g_inactivityspectator[3] || *(_DWORD *)(a1 + 17668) != 2 || *(_DWORD *)(a1 + 212) < dword_D0DEC )
  {
    *(_DWORD *)(a1 + 18044) = level[123] + 60000;
    *(_DWORD *)(a1 + 18052) = 0;
    return 1;
  }
  if ( *(_BYTE *)(a1 + 17720)
    || *(_BYTE *)(a1 + 17721)
    || *(_BYTE *)(a1 + 17722)
    || (*(_BYTE *)(a1 + 17704) & 1) != 0
    || *(_DWORD *)(a1 + 17940) )
  {
    *(_DWORD *)(a1 + 18044) = level[123] + 1000 * g_inactivityspectator[3];
    *(_DWORD *)(a1 + 18052) = 0;
    return 1;
  }
  if ( *(_DWORD *)(a1 + 17748) )
    return 1;
  if ( level[123] <= *(_DWORD *)(a1 + 18044) )
  {
    if ( level[123] > *(_DWORD *)(a1 + 18044) - 10000 && !*(_DWORD *)(a1 + 18052) )
    {
      *(_DWORD *)(a1 + 18052) = 1;
      trap_SendServerCommand(-1380760827 * ((a1 - level[0]) >> 2), 0, "c \"GAME_INACTIVEDROPWARNING\"");
    }
    return 1;
  }
  trap_DropClient(-1380760827 * ((a1 - level[0]) >> 2), "GAME_DROPPEDFORINACTIVITY");
  return 0;
}
// 176E4: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 17E44: using guessed type _DWORD __cdecl trap_DropClient(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// D0DE0: using guessed type int dword_D0DE0;
// D0DEC: using guessed type int dword_D0DEC;

//----- (000404E5) --------------------------------------------------------
int __cdecl ClientIntermissionThink(int a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v2 + 17968) = *(_DWORD *)(v2 + 17964);
  *(_DWORD *)(v2 + 17964) = *(unsigned __int8 *)(v2 + 17704);
  *(_DWORD *)(v2 + 17980) = *(_DWORD *)(v2 + 17976);
  result = *(unsigned __int8 *)(v2 + 17705);
  *(_DWORD *)(v2 + 17976) = result;
  return result;
}

//----- (00040543) --------------------------------------------------------
int __cdecl G_DoTouchTriggers(int a1, float *a2)
{
  int result; // eax
  int v3; // [esp+2Ch] [ebp-107Ch]
  float v4; // [esp+30h] [ebp-1078h] BYREF
  float v5; // [esp+34h] [ebp-1074h]
  float v6; // [esp+38h] [ebp-1070h]
  float v7; // [esp+40h] [ebp-1068h] BYREF
  float v8; // [esp+44h] [ebp-1064h]
  float v9; // [esp+48h] [ebp-1060h]
  char s[60]; // [esp+50h] [ebp-1058h] BYREF
  _DWORD *v11; // [esp+8Ch] [ebp-101Ch]
  int v12[1026]; // [esp+90h] [ebp-1018h] BYREF
  int v13; // [esp+1098h] [ebp-10h]
  int i; // [esp+109Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 356) )
  {
    v3 = 8;
LABEL_5:
    v7 = *a2 - 40.0;
    v8 = a2[1] - 40.0;
    v9 = a2[2] - 52.0;
    v4 = *a2 + 40.0;
    v5 = a2[1] + 40.0;
    v6 = a2[2] + 52.0;
    v13 = trap_EntitiesInBox(&v7, &v4, v12, 1024, v3);
    v7 = *a2 + *(float *)(a1 + 264);
    v8 = a2[1] + *(float *)(a1 + 268);
    v9 = a2[2] + *(float *)(a1 + 272);
    v4 = *a2 + *(float *)(a1 + 276);
    v5 = a2[1] + *(float *)(a1 + 280);
    v6 = a2[2] + *(float *)(a1 + 284);
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v13 )
        return result;
      v11 = &g_entities[211 * v12[i]];
      if ( v11[135] || *(_DWORD *)(a1 + 540) )
      {
        if ( v11[1] == 3 )
        {
          if ( !*(_DWORD *)(a1 + 352) || !BG_PlayerTouchesItem(*(_DWORD *)(a1 + 352), v11, level[123]) )
            continue;
        }
        else if ( !trap_EntityContactCapsule(&v7, &v4, v11) )
        {
          continue;
        }
        memset(s, 0, 0x30u);
        if ( Scr_IsSystemActive(1) )
        {
          Scr_AddEntity(a1);
          Scr_Notify(v11, scr_const[87], 1);
          Scr_AddEntity(v11);
          Scr_Notify(a1, scr_const[87], 1);
        }
        if ( v11[135] )
          ((void (__cdecl *)(_DWORD *, int, int))v11[135])(v11, a1, 1);
      }
    }
  }
  result = a1;
  if ( *(_DWORD *)(a1 + 352) )
  {
    v3 = 0x40000000;
    goto LABEL_5;
  }
  return result;
}
// 16EF4: using guessed type _DWORD __cdecl BG_PlayerTouchesItem(_DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18434: using guessed type _DWORD __cdecl trap_EntityContactCapsule(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00040860) --------------------------------------------------------
_DWORD *__cdecl ClientEvents(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // edx
  char *s2; // [esp+3Ch] [ebp-3Ch]
  char *s2a; // [esp+3Ch] [ebp-3Ch]
  float v6; // [esp+5Ch] [ebp-1Ch]
  float v7; // [esp+5Ch] [ebp-1Ch]
  int v8; // [esp+60h] [ebp-18h]
  int v9; // [esp+64h] [ebp-14h]
  int v10; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v8 = a1[88];
  if ( a2 < *(_DWORD *)(v8 + 136) - 4 )
    a2 = *(_DWORD *)(v8 + 136) - 4;
  for ( i = a2; ; ++i )
  {
    result = (_DWORD *)i;
    if ( i >= *(_DWORD *)(v8 + 136) )
      break;
    v10 = *(_DWORD *)(v8 + 4 * (i & 3) + 140);
    v9 = *(_DWORD *)(v8 + 4 * (i & 3) + 156);
    if ( v10 <= 115 || v10 > 138 )
    {
      switch ( v10 )
      {
        case 157:
          s2 = *(char **)(BG_GetInfoForWeapon(a1[51]) + 464);
          if ( s2 && *s2 )
            G_EntAttach((int)a1, s2, (int)&unk_9DD0C, 0);
          break;
        case 158:
          s2a = *(char **)(BG_GetInfoForWeapon(a1[51]) + 464);
          if ( s2a && *s2a )
            goto LABEL_19;
          break;
        case 163:
        case 164:
        case 165:
        case 166:
        case 173:
          FireWeapon(a1);
          break;
        case 170:
          FireWeaponMelee(a1);
          break;
        case 202:
          s2a = *(char **)(BG_GetInfoForWeapon(v9) + 464);
          if ( s2a && *s2a )
LABEL_19:
            G_EntDetach((int)a1, s2a, (int)&unk_9DD0C);
          break;
        case 203:
          if ( *(_DWORD *)(a1[88] + 216) && Com_BitCheck(a1[88] + 1332, *(_DWORD *)(a1[88] + 216)) )
            Drop_Weapon(a1, *(_DWORD *)(a1[88] + 216), "tag_weapon_right");
          break;
        case 210:
          if ( a1[88] && (a1[99] & 1) == 0 )
          {
            v3 = a1[88];
            a1[144] = 0;
            *(_DWORD *)(v3 + 284) = 0;
            player_die(a1, a1, a1, 100000, 21, 0, 0, 0);
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      result = a1;
      if ( a1[1] != 1 )
        return result;
      if ( v9 <= 99 )
        v6 = (long double)v9 * 0.0099999998;
      else
        v6 = 1.1;
      if ( v6 != 0.0 )
      {
        v7 = (long double)*(int *)(v8 + 292) * v6;
        a1[141] = level[123] + 200;
        G_Damage(a1, 0, 0, 0, 0, (int)v7, 0, 20, 0);
      }
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16F34: using guessed type _DWORD __cdecl FireWeaponMelee(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17964: using guessed type _DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17CC4: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 193D4: using guessed type _DWORD __cdecl FireWeapon(_DWORD);

//----- (00040C1C) --------------------------------------------------------
int __cdecl G_SetClientContents(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17948) )
  {
    result = a1;
    *(_DWORD *)(a1 + 288) = 0;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17952) )
  {
    result = a1;
    *(_DWORD *)(a1 + 288) = 0;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) == 1 )
      *(_DWORD *)(a1 + 288) = 0;
    else
      *(_DWORD *)(a1 + 288) = 0x2000000;
  }
  return result;
}

//----- (00040C91) --------------------------------------------------------
int __cdecl ClientThink_real(int a1, int *a2)
{
  int result; // eax
  int v3; // [esp+40h] [ebp-308h]
  float v4; // [esp+44h] [ebp-304h]
  float v5; // [esp+44h] [ebp-304h]
  float *v6; // [esp+48h] [ebp-300h]
  float v7; // [esp+4Ch] [ebp-2FCh]
  float v8[2]; // [esp+50h] [ebp-2F8h] BYREF
  float v9; // [esp+58h] [ebp-2F0h]
  float v10; // [esp+60h] [ebp-2E8h] BYREF
  float v11; // [esp+64h] [ebp-2E4h]
  float v12; // [esp+68h] [ebp-2E0h]
  int v13[2]; // [esp+70h] [ebp-2D8h] BYREF
  int v14; // [esp+78h] [ebp-2D0h]
  int v15[7]; // [esp+80h] [ebp-2C8h] BYREF
  float *v16; // [esp+9Ch] [ebp-2ACh]
  char v17[40]; // [esp+A0h] [ebp-2A8h] BYREF
  unsigned __int16 v18; // [esp+C8h] [ebp-280h]
  char v19; // [esp+CEh] [ebp-27Ah]
  char v20; // [esp+CFh] [ebp-279h]
  char v21[48]; // [esp+D0h] [ebp-278h] BYREF
  char v22[48]; // [esp+100h] [ebp-248h] BYREF
  char v23[48]; // [esp+130h] [ebp-218h] BYREF
  int v24; // [esp+160h] [ebp-1E8h]
  float v25; // [esp+164h] [ebp-1E4h]
  float v26; // [esp+168h] [ebp-1E0h]
  int v27; // [esp+16Ch] [ebp-1DCh]
  float v28[4]; // [esp+170h] [ebp-1D8h] BYREF
  float v29; // [esp+180h] [ebp-1C8h] BYREF
  float v30; // [esp+184h] [ebp-1C4h]
  float v31; // [esp+188h] [ebp-1C0h]
  int v32[3]; // [esp+190h] [ebp-1B8h] BYREF
  int v33; // [esp+19Ch] [ebp-1ACh]
  int v34; // [esp+1A0h] [ebp-1A8h]
  int v35; // [esp+1A4h] [ebp-1A4h]
  int v36; // [esp+1A8h] [ebp-1A0h]
  int v37; // [esp+1ACh] [ebp-19Ch]
  int v38; // [esp+1B0h] [ebp-198h]
  int v39; // [esp+1B4h] [ebp-194h]
  int v40; // [esp+1B8h] [ebp-190h]
  int v41; // [esp+1BCh] [ebp-18Ch]
  int v42; // [esp+1C0h] [ebp-188h]
  int v43; // [esp+1C4h] [ebp-184h]
  int v44; // [esp+1C8h] [ebp-180h]
  int v45; // [esp+1CCh] [ebp-17Ch]
  int v46; // [esp+1D0h] [ebp-178h]
  int v47; // [esp+1D4h] [ebp-174h]
  int v48; // [esp+1D8h] [ebp-170h]
  int v49; // [esp+1DCh] [ebp-16Ch]
  int v50[2]; // [esp+1E0h] [ebp-168h] BYREF
  int v51; // [esp+1E8h] [ebp-160h]
  int v52; // [esp+1ECh] [ebp-15Ch]
  int v53; // [esp+1F0h] [ebp-158h]
  int v54; // [esp+1F4h] [ebp-154h]
  int v55; // [esp+208h] [ebp-140h]
  int v56; // [esp+20Ch] [ebp-13Ch]
  int s[13]; // [esp+210h] [ebp-138h] BYREF
  int v58; // [esp+244h] [ebp-104h]
  int v59; // [esp+248h] [ebp-100h]
  int v60; // [esp+24Ch] [ebp-FCh]
  int v61; // [esp+250h] [ebp-F8h]
  int v62; // [esp+254h] [ebp-F4h]
  int v63; // [esp+258h] [ebp-F0h]
  int v64; // [esp+25Ch] [ebp-ECh]
  int v65; // [esp+2E8h] [ebp-60h]
  int v66; // [esp+2ECh] [ebp-5Ch]
  int v67; // [esp+2F0h] [ebp-58h]
  int v68; // [esp+2F4h] [ebp-54h]
  int v69; // [esp+2F8h] [ebp-50h]
  int v70; // [esp+2FCh] [ebp-4Ch]
  char v71; // [esp+300h] [ebp-48h]
  char v72; // [esp+301h] [ebp-47h]
  int v73; // [esp+308h] [ebp-40h]
  int v74; // [esp+30Ch] [ebp-3Ch]
  int (__cdecl *v75)(int, int, int, int, int, int, int); // [esp+314h] [ebp-34h]
  int (__cdecl *v76)(int, int, int, int, int, int, int); // [esp+318h] [ebp-30h]
  int (__cdecl *v77)(int, int, int, int, int, int, int); // [esp+31Ch] [ebp-2Ch]
  int (__cdecl *v78)(int, int, int); // [esp+320h] [ebp-28h]
  int (__cdecl *v79)(int); // [esp+324h] [ebp-24h]
  int v80; // [esp+328h] [ebp-20h]
  int v81; // [esp+33Ch] [ebp-Ch]

  v16 = 0;
  v81 = *(_DWORD *)(a1 + 352);
  result = v81;
  if ( *(_DWORD *)(v81 + 17696) == 2 )
  {
    if ( *a2 > level[123] + 200 )
      *a2 = level[123] + 200;
    if ( *a2 < level[123] - 1000 )
      *a2 = level[123] - 1000;
    v55 = *a2 - *(_DWORD *)v81;
    if ( v55 > 0 || (result = 1852331867 * ((a1 - (int)g_entities) >> 2), *(_DWORD *)(v81 + 212) != result) )
    {
      if ( v55 > 200 )
        v55 = 200;
      if ( pmove_msec[3] > 7 )
      {
        if ( pmove_msec[3] > 33 )
          trap_Cvar_Set("pmove_msec", "33");
      }
      else
      {
        trap_Cvar_Set("pmove_msec", &unk_9DE00);
      }
      if ( pmove_fixed[3] || *(_DWORD *)(v81 + 17756) )
        *a2 = pmove_msec[3] * ((*a2 + pmove_msec[3] - 1) / pmove_msec[3]);
      if ( *(_DWORD *)(v81 + 17668) == 3 )
      {
        result = ClientIntermissionThink(a1);
      }
      else
      {
        result = ClientSpectatorInactivityTimer(v81);
        if ( result )
        {
          if ( *(_DWORD *)(v81 + 17668) == 2 )
          {
            result = SpectatorThink(a1, a2);
          }
          else
          {
            result = ClientInactivityTimer(v81);
            if ( result )
            {
              v56 = *(_DWORD *)(v81 + 136);
              memset(s, 0, 0x11Cu);
              s[0] = v81;
              s[1] = *a2;
              s[2] = a2[1];
              s[3] = a2[2];
              s[4] = a2[3];
              s[5] = a2[4];
              s[6] = a2[5];
              s[7] = *(_DWORD *)(v81 + 17724);
              s[8] = *(_DWORD *)(v81 + 17728);
              s[9] = *(_DWORD *)(v81 + 17732);
              s[10] = *(_DWORD *)(v81 + 17736);
              s[11] = *(_DWORD *)(v81 + 17740);
              s[12] = *(_DWORD *)(v81 + 17744);
              if ( *(int *)(v81 + 4) <= 5 )
                v58 = 42008593;
              else
                v58 = 8454161;
              v75 = trap_TraceCapsule;
              v76 = trap_TraceCapsule;
              v77 = trap_TraceCapsule;
              v78 = trap_PointContents;
              v79 = G_EntityType;
              v80 = G_IsInMatchTimeout();
              v59 = g_debugMove[3];
              if ( (*(_DWORD *)(v81 + 132) & 0x100000) != 0 )
              {
                v60 = *(_DWORD *)(g_entities[211 * *(_DWORD *)(a1 + 340) + 89] + 208);
                v61 = *(_DWORD *)(g_entities[211 * *(_DWORD *)(a1 + 340) + 89] + 212);
                v62 = *(_DWORD *)(g_entities[211 * *(_DWORD *)(a1 + 340) + 89] + 216);
                if ( *(_DWORD *)(v81 + 1560) == 1 && *(_DWORD *)(v81 + 1556) == 3 )
                {
                  v64 = 1116471296;
                  v63 = 1114636288;
                }
              }
              v73 = pmove_fixed[3] | *(_DWORD *)(v81 + 17756);
              v74 = pmove_msec[3];
              *(_DWORD *)(v81 + 17988) = *(_DWORD *)(v81 + 20);
              *(_DWORD *)(v81 + 17992) = *(_DWORD *)(v81 + 24);
              *(_DWORD *)(v81 + 17996) = *(_DWORD *)(v81 + 28);
              *(_DWORD *)(v81 + 17968) = *(_DWORD *)(v81 + 17964);
              *(_DWORD *)(v81 + 17964) = *(unsigned __int8 *)(v81 + 17704);
              if ( (*(_DWORD *)(v81 + 132) & 0x100000) == 0 )
              {
                v27 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
                if ( *(_DWORD *)(v27 + 128) == 3 && (*(_DWORD *)(v81 + 12) & 0x20) != 0 )
                  *(_DWORD *)(v81 + 17964) &= 0xFFFFFFBF;
              }
              *(_DWORD *)(v81 + 17972) = *(_DWORD *)(v81 + 17964) & ~*(_DWORD *)(v81 + 17968);
              *(_DWORD *)(v81 + 17980) = *(_DWORD *)(v81 + 17976);
              *(_DWORD *)(v81 + 17976) = *(unsigned __int8 *)(v81 + 17705);
              *(_DWORD *)(v81 + 17984) = *(_DWORD *)(v81 + 17976) & ~*(_DWORD *)(v81 + 17980);
              v50[0] = v81;
              v50[1] = *(_DWORD *)(v81 + 18120);
              v51 = level[123];
              v52 = *(_DWORD *)(v81 + 18128);
              v53 = *(_DWORD *)(v81 + 18124);
              *(float *)&v54 = BG_GetSpeed(v81, v51);
              BG_CalculateViewAngles(v50, v28);
              v29 = *(float *)(v81 + 232) + v28[0];
              v30 = *(float *)(v81 + 236) + v28[1];
              v31 = *(float *)(v81 + 240) + v28[2];
              v27 = BG_GetInfoForWeapon(*(_DWORD *)(v81 + 216));
              v24 = *(_DWORD *)(v81 + 1584) + *(_DWORD *)(v81 + 1588) - v51;
              if ( v24 <= 0 )
              {
                v25 = 1.0;
              }
              else
              {
                v26 = 1.0;
                if ( v24 <= 2999 )
                  v26 = (long double)v24 / 3000.0;
                v26 = (3.0 - (v26 + v26)) * v26 * v26;
                v25 = (*(float *)(v27 + 764) - 1.0) * v26 + 1.0;
              }
              BG_CalculateWeaponPosition_Sway(v81, v81 + 18132, v81 + 18144, v81 + 18156, 1.0, v55);
              v32[0] = v50[0];
              v32[1] = v54;
              *(float *)&v32[2] = (long double)v55 * 0.001;
              v33 = *(_DWORD *)(v81 + 18168);
              v34 = *(_DWORD *)(v81 + 18172);
              v35 = *(_DWORD *)(v81 + 18176);
              v36 = *(_DWORD *)(v81 + 18180);
              v37 = v51;
              v38 = *(_DWORD *)(v81 + 18120);
              v39 = *(_DWORD *)(v81 + 18128);
              v40 = *(_DWORD *)(v81 + 18124);
              v41 = *(_DWORD *)(v81 + 18184);
              v42 = *(_DWORD *)(v81 + 18188);
              v43 = *(_DWORD *)(v81 + 18192);
              v44 = *(_DWORD *)(v81 + 18196);
              v45 = *(_DWORD *)(v81 + 18200);
              v46 = *(_DWORD *)(v81 + 18204);
              v47 = *(_DWORD *)(v81 + 18156);
              v48 = *(_DWORD *)(v81 + 18160);
              v49 = *(_DWORD *)(v81 + 18164);
              BG_CalculateWeaponAngles(v32, v28);
              if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v32[0] + 216)) && *(float *)(v32[0] + 224) != 0.0 )
              {
                AnglesToAxis(v28, v23);
                AnglesToAxis(&v29, v22);
                MatrixMultiply(v23, v22, v21);
                AxisToAngles(v21, &v29);
              }
              if ( (*(_DWORD *)(v81 + 132) & 0x100000) == 0 )
              {
                v15[0] = *(_DWORD *)(v81 + 1372);
                v15[1] = *(_DWORD *)(v81 + 1376);
                v15[2] = *(_DWORD *)(v81 + 1380);
                v13[0] = *(_DWORD *)(v81 + 1384);
                v13[1] = *(_DWORD *)(v81 + 1388);
                v14 = *(_DWORD *)(v81 + 1392);
                if ( (*(_DWORD *)(v81 + 12) & 1) != 0 )
                {
                  v14 = 1106247680;
                }
                else if ( (*(_DWORD *)(v81 + 12) & 2) != 0 )
                {
                  v14 = 1112014848;
                }
                trap_TraceCapsule(v17, v81 + 20, v15, v13, v81 + 20, *(_DWORD *)(v81 + 212), v58);
                if ( (v20 || v19) && g_entities[211 * v18 + 1] == 12 )
                {
                  v6 = (float *)&g_entities[211 * v18];
                  v10 = *(float *)(v81 + 20) - v6[79];
                  v11 = *(float *)(v81 + 24) - v6[80];
                  v12 = *(float *)(v81 + 28) - v6[81];
                  VectorNormalize(&v10);
                  v7 = VectorNormalize2(v81 + 32, v8);
                  v9 = 0.0;
                  v12 = 0.0;
                  if ( v7 < 1.0 || v10 * v8[0] + v11 * v8[1] + v12 * v9 > 0.80000001 )
                  {
                    v16 = v6;
                    trap_UnlinkEntity(v6);
                    if ( (*(_DWORD *)(v81 + 12) & 1) == 0 && v7 < 1.0 )
                    {
                      v4 = sqrt(
                             *(float *)(*((_DWORD *)v6 + 89) + 232) * *(float *)(*((_DWORD *)v6 + 89) + 232)
                           + *(float *)(*((_DWORD *)v6 + 89) + 236) * *(float *)(*((_DWORD *)v6 + 89) + 236)
                           + *(float *)(*((_DWORD *)v6 + 89) + 240) * *(float *)(*((_DWORD *)v6 + 89) + 240));
                      if ( v4 <= 1.0 )
                      {
                        *(float *)(v81 + 32) = v10 * 200.0;
                        *(float *)(v81 + 36) = v11 * 200.0;
                        *(float *)(v81 + 40) = v12 * 200.0;
                      }
                      else
                      {
                        VEH_PlayerCollision(v6, a1);
                        v5 = sqrt(
                               *(float *)(v81 + 32) * *(float *)(v81 + 32)
                             + *(float *)(v81 + 36) * *(float *)(v81 + 36)
                             + *(float *)(v81 + 40) * *(float *)(v81 + 40));
                        if ( v5 < 200.0 )
                        {
                          VectorNormalize(v81 + 32);
                          *(float *)(v81 + 32) = *(float *)(v81 + 32) * 200.0;
                          *(float *)(v81 + 36) = *(float *)(v81 + 36) * 200.0;
                          *(float *)(v81 + 40) = *(float *)(v81 + 40) * 200.0;
                        }
                      }
                      *(_DWORD *)(v81 + 16) = 200;
                      *(_DWORD *)(v81 + 12) |= 0x200u;
                    }
                  }
                  if ( (*(_DWORD *)(v81 + 12) & 1) != 0 && *(_DWORD *)(v81 + 18220) < level[123] - 500 )
                  {
                    v3 = *(_DWORD *)(a1 + 576);
                    VEH_PlayerDamage(a1, v6, 10);
                    if ( v3 == *(_DWORD *)(a1 + 576) )
                      VEH_PlayerDamage(a1, a1, 10);
                  }
                }
              }
              *(_DWORD *)(v81 + 18168) = v33;
              *(_DWORD *)(v81 + 18172) = v34;
              *(_DWORD *)(v81 + 18176) = v35;
              *(_DWORD *)(v81 + 18180) = v36;
              *(_DWORD *)(v81 + 18184) = v41;
              *(_DWORD *)(v81 + 18188) = v42;
              *(_DWORD *)(v81 + 18192) = v43;
              *(_DWORD *)(v81 + 18196) = v44;
              *(_DWORD *)(v81 + 18200) = v45;
              *(_DWORD *)(v81 + 18204) = v46;
              *(float *)(v81 + 18000) = v29;
              *(float *)(v81 + 18004) = v30;
              Pmove(s);
              if ( v16 )
                trap_LinkEntity(v16);
              *(_DWORD *)(a1 + 228) = (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 12) & 2) != 0;
              if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 136) != v56 )
              {
                *(_DWORD *)(a1 + 400) = level[123];
                *(_DWORD *)(a1 + 344) = level[123];
              }
              if ( g_smoothClients[3] )
                BG_PlayerStateToEntityStateExtrapolate(*(_DWORD *)(a1 + 352), a1, **(_DWORD **)(a1 + 352), 1);
              else
                BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 352), a1, 1);
              *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 24);
              *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 28);
              *(_DWORD *)(a1 + 324) = *(_DWORD *)(a1 + 32);
              *(_DWORD *)(a1 + 264) = v65;
              *(_DWORD *)(a1 + 268) = v66;
              *(_DWORD *)(a1 + 272) = v67;
              *(_DWORD *)(a1 + 276) = v68;
              *(_DWORD *)(a1 + 280) = v69;
              *(_DWORD *)(a1 + 284) = v70;
              *(_BYTE *)(a1 + 380) = v72;
              *(_BYTE *)(a1 + 379) = v71;
              ClientEvents(a1, v56);
              trap_LinkEntity(a1);
              if ( !*(_DWORD *)(*(_DWORD *)(a1 + 352) + 17948) )
                G_TouchTriggers(a1);
              *(_DWORD *)(a1 + 316) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 20);
              *(_DWORD *)(a1 + 320) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 24);
              *(_DWORD *)(a1 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 28);
              *(_DWORD *)(a1 + 336) = 0;
              *(_DWORD *)(a1 + 332) = 0;
              *(_DWORD *)(a1 + 328) = 0;
              *(_DWORD *)(a1 + 332) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 236);
              ClientImpacts(a1, s);
              if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 136) != v56 )
                *(_DWORD *)(a1 + 400) = level[123];
              result = *(_DWORD *)(v81 + 17972) & 0x40;
              if ( result )
                result = Cmd_Activate_f(a1);
            }
          }
        }
      }
    }
  }
  return result;
}
// 16964: using guessed type _DWORD __cdecl ClientEvents(_DWORD, _DWORD);
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16CC4: using guessed type _DWORD __cdecl ClientInactivityTimer(_DWORD);
// 16DB4: using guessed type _DWORD __cdecl VEH_PlayerDamage(_DWORD, _DWORD, _DWORD);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 173A4: using guessed type _DWORD __cdecl SpectatorThink(_DWORD, _DWORD);
// 17474: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 17644: using guessed type _DWORD __cdecl ClientSpectatorInactivityTimer(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17AA4: using guessed type _DWORD __cdecl Pmove(_DWORD);
// 17B94: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 17CF4: using guessed type _DWORD __cdecl BG_CalculateWeaponAngles(_DWORD, _DWORD);
// 17DA4: using guessed type _DWORD __cdecl BG_CalculateViewAngles(_DWORD, _DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 183A4: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);
// 18614: using guessed type _DWORD __cdecl G_TouchTriggers(_DWORD);
// 18864: using guessed type _DWORD __cdecl VEH_PlayerCollision(_DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 18B64: using guessed type _DWORD __cdecl ClientIntermissionThink(_DWORD);
// 18DC4: using guessed type long double __cdecl BG_GetSpeed(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 19374: using guessed type _DWORD __cdecl ClientImpacts(_DWORD, _DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 194B4: using guessed type _DWORD __cdecl Cmd_Activate_f(_DWORD);
// 19584: using guessed type int G_IsInMatchTimeout(void);
// 19734: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 3FE31: using guessed type int __cdecl G_EntityType(int);
// 74130: using guessed type int __cdecl trap_TraceCapsule(int, int, int, int, int, int, int);
// 7443A: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (00041D13) --------------------------------------------------------
_DWORD *__cdecl ClientThink(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = &g_entities[211 * a1];
  v1 = (_DWORD *)v3[88];
  v1[4431] = v1[4425];
  v1[4432] = v1[4426];
  v1[4433] = v1[4427];
  v1[4434] = v1[4428];
  v1[4435] = v1[4429];
  v1[4436] = v1[4430];
  trap_GetUsercmd(a1, v3[88] + 17700);
  *(_DWORD *)(v3[88] + 17960) = level[123];
  result = g_synchronousClients;
  if ( !g_synchronousClients[3] )
    result = (_DWORD *)ClientThink_real(v3, v3[88] + 17700);
  return result;
}
// 173D4: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 18994: using guessed type _DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD);

//----- (00041DFC) --------------------------------------------------------
int __cdecl G_RunClient(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]

  if ( g_synchronousClients[3] )
  {
    *(_DWORD *)(a1[88] + 17700) = level[123];
    ClientThink_real(a1, a1[88] + 17700);
  }
  result = a1[88];
  if ( !*(_DWORD *)(result + 17948) )
  {
    if ( a1[189] )
    {
      if ( *(_DWORD *)(a1[88] + 17668) == 1 )
        v2 = 7;
      else
        v2 = 1;
      *(_DWORD *)(a1[88] + 4) = v2;
      G_SetFixedLink(a1, 2);
      G_SetOrigin(a1, a1 + 79);
      a1[3] = 1;
      a1[12] = 1;
      trap_LinkEntity(a1);
      *(_DWORD *)(a1[88] + 20) = a1[79];
      *(_DWORD *)(a1[88] + 24) = a1[80];
      result = a1[81];
      *(_DWORD *)(a1[88] + 28) = result;
    }
    else if ( *(_DWORD *)(a1[88] + 4) == 1 || (result = a1[88], *(_DWORD *)(result + 4) == 7) )
    {
      result = a1[88];
      --*(_DWORD *)(result + 4);
    }
  }
  return result;
}
// 169C4: using guessed type _DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD);
// 173D4: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00041F6B) --------------------------------------------------------
int __cdecl IntermissionClientEndFrame(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 352);
  *(_DWORD *)(a1 + 248) &= 0xFFFFFFFD;
  *(_DWORD *)(a1 + 248) |= 1u;
  *(_BYTE *)(a1 + 381) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  v2[3] &= 0xFFC7FFFF;
  v2[1] = 5;
  v2[33] &= 0xFFFDFFFF;
  v2[33] &= 0xFFFFFDFF;
  v2[57] = 0;
  result = a1;
  *(_DWORD *)(a1 + 4) = 7;
  return result;
}

//----- (00042020) --------------------------------------------------------
_DWORD *__cdecl SpectatorClientEndFrame(int a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // [esp+10h] [ebp-45A8h]
  int *v4; // [esp+14h] [ebp-45A4h]
  int *v5; // [esp+18h] [ebp-45A0h]
  _DWORD *v6; // [esp+1Ch] [ebp-459Ch]
  char v7[4]; // [esp+20h] [ebp-4598h] BYREF
  int v8; // [esp+24h] [ebp-4594h]
  int v9; // [esp+80h] [ebp-4538h] BYREF
  _DWORD v10[4421]; // [esp+84h] [ebp-4534h] BYREF
  int v11; // [esp+4598h] [ebp-20h]
  unsigned int v12; // [esp+459Ch] [ebp-1Ch]

  v6 = *(_DWORD **)(a1 + 352);
  *(_DWORD *)(a1 + 248) &= 0xFFFFFFFD;
  *(_DWORD *)(a1 + 248) |= 1u;
  *(_BYTE *)(a1 + 381) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  v6[3] &= 0xFFF7FFFF;
  *(_DWORD *)(a1 + 4) = 7;
  v6[57] = 0;
  v6[4500] = 0;
  v6[4501] = 0;
  if ( (int)v6[4418] < 0 )
  {
LABEL_10:
    if ( (int)v6[4486] < 0 && !G_ClientCanSpectateTeam(v6, 4) )
      Cmd_FollowCycle_f(a1, 1);
    v11 = v6[4486];
    if ( v11 < 0 || !trap_GetArchivedClientInfo(v11, v6 + 4420, &v9, v7) || !G_ClientCanSpectateTeam(v6, v8) )
    {
      StopFollowing(a1);
      v6[3] &= 0xFFDFFFFF;
      if ( G_ClientCanSpectateTeam(v6, 2) || G_ClientCanSpectateTeam(v6, 1) || G_ClientCanSpectateTeam(v6, 0) )
      {
        result = v6;
        v6[3] |= 0x100000u;
      }
      else
      {
        result = v6;
        v6[3] &= 0xFFEFFFFF;
      }
      return result;
    }
  }
  else
  {
    v11 = v6[4418];
    v6[4486] = v11;
    while ( 1 )
    {
      if ( (int)v6[4420] < 0 )
        v6[4420] = 0;
      if ( trap_GetArchivedClientInfo(v6[4418], v6 + 4420, &v9, v7) && G_ClientCanSpectateTeam(v6, v8) )
        break;
      if ( !v6[4420] )
      {
        v6[4418] = -1;
        v6[4486] = -1;
        goto LABEL_10;
      }
      v6[4420] -= 50;
    }
  }
  v12 = v10[32] & 0xFFFEFFFF | v6[33] & 0x10000;
  v5 = v6;
  v4 = &v9;
  v3 = 17668;
  if ( ((unsigned __int8)v6 & 4) != 0 )
  {
    *v6 = v9;
    v5 = v6 + 1;
    v4 = v10;
    v3 = 17664;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  HudElem_UpdateClient(v6, *(_DWORD *)a1, 2);
  v6[33] = v12;
  v6[3] &= 0xFFF7FFFF;
  v6[3] |= 0x40000u;
  if ( (int)v6[4418] < 0 )
  {
    v6[3] |= 0x100000u;
    if ( G_ClientCanSpectateTeam(v6, 4) )
    {
      result = v6;
      v2 = v6[3] | 0x200000;
    }
    else
    {
      result = v6;
      v2 = v6[3] & 0xFFDFFFFF;
    }
    v6[3] = v2;
  }
  else
  {
    result = v6;
    v6[3] &= 0xFFCFFFFF;
  }
  return result;
}
// 17014: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 17694: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 17764: using guessed type _DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B74: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);
// 18F74: using guessed type _DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD);

//----- (000424B0) --------------------------------------------------------
int __cdecl G_ClientCanSpectateTeam(int a1, char a2)
{
  return ((unsigned __int8)(*(int *)(a1 + 17836) >> a2) ^ 1) & 1;
}

//----- (000424CA) --------------------------------------------------------
int __cdecl GetFollowPlayerState(int a1, _DWORD *a2)
{
  unsigned int v3; // [esp+14h] [ebp-24h]
  const void *v4; // [esp+18h] [ebp-20h]
  void *v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v7; // [esp+24h] [ebp-14h]

  v7 = (_DWORD *)g_entities[211 * a1 + 88];
  if ( (v7[3] & 0x80000) == 0 )
    return 0;
  v5 = a2;
  v4 = (const void *)g_entities[211 * a1 + 88];
  v3 = 17668;
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    *a2 = *v7;
    v5 = a2 + 1;
    v4 = v7 + 1;
    v3 = 17664;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  memset(a2 + 510, 0, 0x1E84u);
  return 1;
}

//----- (0004258C) --------------------------------------------------------
int __cdecl StuckInClient(int a1)
{
  long double v1; // fst6
  long double v2; // fst6
  float v4; // [esp+14h] [ebp-44h]
  float v5; // [esp+18h] [ebp-40h]
  float v7; // [esp+20h] [ebp-38h]
  float v8; // [esp+20h] [ebp-38h]
  float v9; // [esp+28h] [ebp-30h] BYREF
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h] BYREF
  float v12; // [esp+34h] [ebp-24h]
  _DWORD *v13; // [esp+3Ch] [ebp-1Ch]
  float v14; // [esp+40h] [ebp-18h]
  float v15; // [esp+44h] [ebp-14h]
  float v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 12) & 0x80000) == 0 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) )
    return 0;
  if ( *(_DWORD *)(a1 + 288) != 0x2000000 && *(_DWORD *)(a1 + 288) != 0x4000000 )
    return 0;
  v13 = g_entities;
  v17 = 0;
  while ( 1 )
  {
    if ( v17 >= level[121] )
      return 0;
    if ( !*((_BYTE *)v13 + 364)
      || (*(_DWORD *)(v13[88] + 12) & 0x80000) == 0
      || *(_DWORD *)(v13[88] + 17668)
      || v13 == (_DWORD *)a1
      || !v13[88]
      || (int)v13[144] <= 0
      || v13[72] != 0x2000000 && v13[72] != 0x4000000
      || (v13[2] & 0x100000) != 0
      || *((float *)v13 + 73) > (long double)*(float *)(a1 + 304)
      || *(float *)(a1 + 292) > (long double)*((float *)v13 + 76)
      || *((float *)v13 + 74) > (long double)*(float *)(a1 + 308)
      || *(float *)(a1 + 296) > (long double)*((float *)v13 + 77)
      || *((float *)v13 + 75) > (long double)*(float *)(a1 + 312)
      || *(float *)(a1 + 300) > (long double)*((float *)v13 + 78) )
    {
      goto LABEL_45;
    }
    if ( (*(_DWORD *)(a1 + 248) & 0x200) == 0 )
      break;
    if ( (v13[62] & 0x200) != 0 )
    {
      v11 = *((float *)v13 + 79) - *(float *)(a1 + 316);
      v12 = *((float *)v13 + 80) - *(float *)(a1 + 320);
      v16 = *(float *)(a1 + 276) + *((float *)v13 + 69);
      if ( v11 * v11 + v12 * v12 <= v16 * v16 )
        goto LABEL_35;
    }
    else
    {
      v11 = *((float *)v13 + 79) - *(float *)(a1 + 316);
      v12 = *((float *)v13 + 80) - *(float *)(a1 + 320);
      v9 = v11;
      v10 = v12;
      VectorNormalize2D(&v9);
      v11 = *(float *)(a1 + 276) * -1.0 * v9 + v11;
      v12 = *(float *)(a1 + 276) * -1.0 * v10 + v12;
      if ( fabs(v11) <= *((float *)v13 + 69) || fabs(v12) <= *((float *)v13 + 70) )
        goto LABEL_35;
    }
LABEL_45:
    ++v17;
    v13 += 211;
  }
  if ( (v13[62] & 0x200) != 0 )
  {
    v11 = *(float *)(a1 + 316) - *((float *)v13 + 79);
    v12 = *(float *)(a1 + 320) - *((float *)v13 + 80);
    v9 = v11;
    v10 = v12;
    VectorNormalize2D(&v9);
    v11 = *((float *)v13 + 69) * -1.0 * v9 + v11;
    v12 = *((float *)v13 + 69) * -1.0 * v10 + v12;
    if ( fabs(v11) > *(float *)(a1 + 276) && fabs(v12) > *(float *)(a1 + 280) )
      goto LABEL_45;
  }
LABEL_35:
  v11 = *((float *)v13 + 79) - *(float *)(a1 + 316);
  v12 = *((float *)v13 + 80) - *(float *)(a1 + 320);
  v1 = (long double)rand() / 2147483600.0;
  v11 = v1 + v1 - 1.0 + v11;
  v2 = (long double)rand() / 2147483600.0;
  v12 = v2 + v2 - 1.0 + v12;
  VectorNormalize2D(&v11);
  v7 = sqrt(*(float *)(v13[88] + 32) * *(float *)(v13[88] + 32) + *(float *)(v13[88] + 36) * *(float *)(v13[88] + 36));
  if ( v7 <= 0.0 )
    v5 = 0.0;
  else
    v5 = (float)*(int *)(v13[88] + 72);
  v14 = v5;
  v8 = sqrt(
         *(float *)(*(_DWORD *)(a1 + 352) + 32) * *(float *)(*(_DWORD *)(a1 + 352) + 32)
       + *(float *)(*(_DWORD *)(a1 + 352) + 36) * *(float *)(*(_DWORD *)(a1 + 352) + 36));
  if ( v8 <= 0.0 )
    v4 = 0.0;
  else
    v4 = (float)*(int *)(*(_DWORD *)(a1 + 352) + 72);
  v15 = v4;
  if ( v14 < 0.000099999997 && v15 < 0.000099999997 )
  {
    v14 = (float)*(int *)(v13[88] + 72);
    v15 = (float)*(int *)(*(_DWORD *)(a1 + 352) + 72);
  }
  *(float *)(v13[88] + 32) = v11 * v14;
  *(float *)(v13[88] + 36) = v12 * v14;
  *(_DWORD *)(v13[88] + 16) = 300;
  *(_DWORD *)(v13[88] + 12) |= 0x100u;
  *(float *)(*(_DWORD *)(a1 + 352) + 32) = -v15 * v11;
  *(float *)(*(_DWORD *)(a1 + 352) + 36) = -v15 * v12;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 16) = 300;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 12) |= 0x100u;
  return 1;
}
// 17924: using guessed type _DWORD __cdecl VectorNormalize2D(_DWORD);

//----- (00042C26) --------------------------------------------------------
int __cdecl sub_42C26(int a1, int a2)
{
  return BG_Player_DoControllers(a1, a1, a2, &aSDoesNotExist[1232 * *(_DWORD *)(a1 + 148) + (_DWORD)bgs]);
}
// 18FD4: using guessed type _DWORD __cdecl BG_Player_DoControllers(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00042C81) --------------------------------------------------------
int __cdecl G_UpdateClientInfo(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  char *src; // [esp+1Ch] [ebp-1Ch]
  char *s2; // [esp+20h] [ebp-18h]
  char *s2a; // [esp+20h] [ebp-18h]
  char *v8; // [esp+28h] [ebp-10h]

  v2 = *(_DWORD **)(a1 + 352);
  v8 = &aSDoesNotExist[1232 * *(_DWORD *)(a1 + 148) + (_DWORD)bgs];
  *((_DWORD *)v8 + 248) = *(_DWORD *)(a1 + 108);
  *((_DWORD *)v8 + 249) = *(_DWORD *)(a1 + 216);
  *((_DWORD *)v8 + 250) = v2[58];
  *((_DWORD *)v8 + 251) = v2[59];
  *((_DWORD *)v8 + 252) = v2[60];
  v3 = 0;
  s2 = (char *)G_ModelName(*(unsigned __int8 *)(a1 + 385));
  v2[4464] = *(unsigned __int8 *)(a1 + 385);
  if ( strcmp(v8 + 64, s2) )
  {
    v3 = 1;
    Q_strncpyz(v8 + 64, s2, 64);
  }
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(i + a1 + 764) )
    {
      s2a = (char *)G_ModelName(*(unsigned __int8 *)(i + a1 + 764));
      v2[i + 4465] = *(unsigned __int8 *)(i + a1 + 764);
      if ( strcmp(&v8[64 * i + 128], s2a) )
      {
        v3 = 1;
        Q_strncpyz(&v8[64 * i + 128], s2a, 64);
      }
      src = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 2 * i + 770));
      v2[i + 4471] = G_TagIndex(src);
      if ( strcmp(&v8[64 * i + 512], src) )
      {
        v3 = 1;
        Q_strncpyz(&v8[64 * i + 512], src, 64);
      }
    }
    else
    {
      v8[64 * i + 128] = 0;
      v8[64 * i + 512] = 0;
      v2[i + 4465] = 0;
      v2[i + 4471] = 0;
    }
  }
  if ( v3 )
    G_SafeDObjFree(a1);
  BG_UpdatePlayerDObj(a1, a1, v8, a1 + 840);
  return BG_PlayerAnimation(a1, a1, v8);
}
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17854: using guessed type _DWORD __cdecl G_SafeDObjFree(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18634: using guessed type _DWORD __cdecl BG_UpdatePlayerDObj(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B94: using guessed type _DWORD __cdecl BG_PlayerAnimation(_DWORD, _DWORD, _DWORD);

//----- (00042F59) --------------------------------------------------------
float *__cdecl ClientEndFrame(_DWORD *a1)
{
  float *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // edx
  int v4; // [esp+14h] [ebp-64h]
  int v5; // [esp+28h] [ebp-50h]
  int v6[4]; // [esp+30h] [ebp-48h] BYREF
  int v7[7]; // [esp+40h] [ebp-38h] BYREF
  float *v8; // [esp+5Ch] [ebp-1Ch]
  int v9[2]; // [esp+60h] [ebp-18h] BYREF
  float v10; // [esp+68h] [ebp-10h]

  v8 = (float *)a1[88];
  a1[140] = 0;
  v8[4416] = 0.0;
  result = v8;
  if ( *((_DWORD *)v8 + 4424) == 2 )
  {
    if ( *((_DWORD *)v8 + 4417) == 3 )
    {
      result = (float *)IntermissionClientEndFrame(a1);
    }
    else if ( *((_DWORD *)v8 + 4417) == 2 )
    {
      result = (float *)SpectatorClientEndFrame(a1);
    }
    else if ( *((_DWORD *)v8 + 53) == *a1 )
    {
      a1[62] |= 2u;
      a1[62] &= 0xFFFFFFFE;
      *((_BYTE *)a1 + 381) = 1;
      *((_DWORD *)v8 + 3) |= 0x80000u;
      *((_DWORD *)v8 + 3) &= 0xFFCFFFFF;
      v8[57] = v8[4458];
      G_SetClientContents(a1);
      if ( (*(_DWORD *)(a1[88] + 132) & 0x100000) != 0 )
      {
        v5 = g_entities[211 * a1[85] + 89];
        if ( v5 )
        {
          if ( v5 != -184 )
          {
            if ( fabs(*(float *)(v5 + 244)) >= 20.0 )
            {
              if ( *(float *)(v5 + 244) <= 0.0 )
              {
                if ( *(float *)(v5 + 244) < 0.0 )
                  *((_DWORD *)v8 + 391) = 3;
              }
              else
              {
                *((_DWORD *)v8 + 391) = 2;
              }
            }
            else
            {
              *((_DWORD *)v8 + 391) = 1;
            }
          }
        }
      }
      v8[4521] = 0.0;
      if ( *((_DWORD *)v8 + 4528) <= level[123] )
        *((_DWORD *)v8 + 33) &= 0xFFFBFFFF;
      if ( *((_DWORD *)v8 + 4487) )
      {
        *((_DWORD *)v8 + 1) = 2;
      }
      else if ( *((_DWORD *)v8 + 4488) )
      {
        *((_DWORD *)v8 + 1) = 3;
      }
      else if ( *((_DWORD *)v8 + 4417) == 1 )
      {
        if ( a1[189] )
          v4 = 7;
        else
          v4 = 6;
        *((_DWORD *)v8 + 1) = v4;
        a1[62] |= 1u;
        a1[62] &= 0xFFFFFFFD;
        *((_BYTE *)a1 + 381) = 0;
      }
      else
      {
        *((_DWORD *)v8 + 1) = a1[189] != 0;
      }
      *((_DWORD *)v8 + 16) = (int)g_gravity[2];
      v8[18] = v8[4450];
      v8[4518] = v8[394] / 255.0;
      G_CheckForPreventFriendlyFire(a1);
      G_CheckForCursorHints(a1);
      G_CheckFlameDamage(a1);
      P_DamageFeedback(a1);
      if ( level[123] - *((_DWORD *)v8 + 4490) <= 1000 )
        v2 = a1[2] & 0xFFFFF7FF;
      else
        v2 = a1[2] | 0x800;
      a1[2] = v2;
      v8[71] = *((float *)a1 + 144);
      G_SetClientSound(a1);
      if ( g_smoothClients[3] )
        BG_PlayerStateToEntityStateExtrapolate(v8, a1, *(_DWORD *)v8, 1);
      else
        BG_PlayerStateToEntityState(v8, a1, 1);
      if ( (int)a1[144] > 0 && StuckInClient(a1) )
        a1[72] = 0x4000000;
      v9[0] = (int)v8[5];
      v9[1] = (int)v8[6];
      v10 = v8[7];
      v10 = v10 + v8[62];
      G_AddLean(a1, v9);
      *((_DWORD *)v8 + 384) = G_GetNonPVSFriendlyInfo(a1, v9, *((_DWORD *)v8 + 4527));
      if ( *((_DWORD *)v8 + 384) )
      {
        *((_DWORD *)v8 + 4527) = (_DWORD)v8[384] & 0x3F;
        if ( (g_entities[211 * *((_DWORD *)v8 + 4527) + 2] & 0x40000) != 0 )
          v3 = *((_DWORD *)v8 + 33) | 0x80000;
        else
          v3 = (_DWORD)v8[33] & 0xFFF7FFFF;
        *((_DWORD *)v8 + 33) = v3;
      }
      else
      {
        *((_DWORD *)v8 + 4527) = 1023;
      }
      *((_DWORD *)v8 + 385) = G_GetNonPVSTankInfo(a1, v9, *((_DWORD *)v8 + 4529));
      if ( *((_DWORD *)v8 + 385) )
        *((_DWORD *)v8 + 4529) = (_DWORD)v8[385] & 0x3F;
      else
        *((_DWORD *)v8 + 4529) = 1023;
      result = (float *)a1;
      if ( a1[1] == 1 )
      {
        a1[140] = sub_42C26;
        G_UpdateClientInfo(a1);
        if ( ((_DWORD)v8[3] & 0x80000) != 0 && ((_DWORD)v8[33] & 0x6000) != 0 )
          turret_think_client(level[1] + 844 * *((_DWORD *)v8 + 367));
        if ( ((_DWORD)v8[3] & 0x80000) != 0 && ((_DWORD)v8[33] & 0x100000) != 0 )
          G_PlayerVehiclePositionAndBlend(a1);
        result = (float *)g_debugLocDamage;
        if ( g_debugLocDamage[3] )
        {
          result = (float *)trap_DObjExists(a1);
          if ( result )
          {
            G_DObjCalcPose(a1);
            result = (float *)trap_XModelDebugBoxes(a1);
          }
        }
      }
    }
    else
    {
      v7[0] = (int)v8[5];
      v7[1] = (int)v8[6];
      v7[2] = (int)v8[7];
      v6[0] = 0;
      v6[1] = (int)v8[59];
      v6[2] = 0;
      result = (float *)ClientSpawn(a1, v7, v6);
    }
  }
  return result;
}
// 16844: using guessed type _DWORD __cdecl turret_think_client(_DWORD);
// 16F04: using guessed type _DWORD __cdecl G_DObjCalcPose(_DWORD);
// 17274: using guessed type _DWORD __cdecl G_CheckForCursorHints(_DWORD);
// 174E4: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 175C4: using guessed type _DWORD __cdecl IntermissionClientEndFrame(_DWORD);
// 17BA4: using guessed type _DWORD __cdecl trap_XModelDebugBoxes(_DWORD);
// 17BD4: using guessed type _DWORD __cdecl G_CheckFlameDamage(_DWORD);
// 17DD4: using guessed type _DWORD __cdecl G_CheckForPreventFriendlyFire(_DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18274: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 18364: using guessed type _DWORD __cdecl G_SetClientContents(_DWORD);
// 184E4: using guessed type _DWORD __cdecl StuckInClient(_DWORD);
// 18724: using guessed type _DWORD __cdecl SpectatorClientEndFrame(_DWORD);
// 189D4: using guessed type _DWORD __cdecl G_SetClientSound(_DWORD);
// 18E04: using guessed type _DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD);
// 18E14: using guessed type _DWORD __cdecl G_UpdateClientInfo(_DWORD);
// 18FF4: using guessed type _DWORD __cdecl G_PlayerVehiclePositionAndBlend(_DWORD);
// 19604: using guessed type _DWORD __cdecl G_GetNonPVSFriendlyInfo(_DWORD, _DWORD, _DWORD);
// 19734: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 19764: using guessed type _DWORD __cdecl P_DamageFeedback(_DWORD);
// 19884: using guessed type _DWORD __cdecl G_GetNonPVSTankInfo(_DWORD, _DWORD, _DWORD);

//----- (000435CC) --------------------------------------------------------
int __cdecl G_PlayerEvent(int a1, int a2)
{
  int result; // eax
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  result = a2;
  if ( a2 >= 163 && (a2 <= 166 || a2 == 173) )
    result = BG_WeaponFireRecoil(g_entities[211 * a1 + 88], g_entities[211 * a1 + 88] + 18196, v3);
  return result;
}
// 17714: using guessed type _DWORD __cdecl BG_WeaponFireRecoil(_DWORD, _DWORD, _DWORD);

//----- (00043640) --------------------------------------------------------
void sub_43640()
{
  ;
}

//----- (00043644) --------------------------------------------------------
int __cdecl sub_43644(int a1, int a2, _DWORD *a3)
{
  int v3; // eax

  v3 = va("player field %s is read-only\n", *a3);
  return Scr_Error(v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0004367B) --------------------------------------------------------
int __cdecl sub_4367B(int a1)
{
  char v1; // al
  int v2; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[4] )
  {
    *(_DWORD *)(a1 + 17852) = 1;
  }
  else if ( v4 == scr_const[2] )
  {
    *(_DWORD *)(a1 + 17852) = 2;
  }
  else if ( v4 == scr_const[76] )
  {
    *(_DWORD *)(a1 + 17852) = 3;
  }
  else if ( v4 == scr_const[146] )
  {
    *(_DWORD *)(a1 + 17852) = 0;
  }
  else
  {
    v1 = SL_ConvertToString(v4);
    v2 = va("'%s' is an illegal sessionteam string. Must be allies, axis, none, or spectator.", v1);
    Scr_Error(v2);
  }
  ClientUserinfoChanged(-1380760827 * ((a1 - level[0]) >> 2));
  return CalculateRanks();
}
// 168F4: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16D14: using guessed type int CalculateRanks(void);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00043771) --------------------------------------------------------
int __cdecl sub_43771(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 17852);
  switch ( result )
  {
    case 1:
      return Scr_AddConstString(scr_const[4]);
    case 0:
      return Scr_AddConstString(scr_const[146]);
    case 2:
      return Scr_AddConstString(scr_const[2]);
    case 3:
      result = Scr_AddConstString(scr_const[76]);
      break;
  }
  return result;
}
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (00043803) --------------------------------------------------------
int __cdecl sub_43803(int a1)
{
  char v1; // al
  int v2; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[158] )
  {
    *(_WORD *)(a1 + 17844) = 1;
  }
  else if ( v4 == scr_const[159] )
  {
    *(_WORD *)(a1 + 17844) = 2;
  }
  else if ( v4 == scr_const[146] )
  {
    *(_WORD *)(a1 + 17844) = 0;
  }
  else
  {
    v1 = SL_ConvertToString(v4);
    v2 = va("'%s' is an illegal sessionsquad string. Must be squad_alpha, squad_bravo, or none.", v1);
    Scr_Error(v2);
  }
  return ClientUserinfoChanged(-1380760827 * ((a1 - level[0]) >> 2));
}
// 168F4: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000438D2) --------------------------------------------------------
int __cdecl sub_438D2(int a1)
{
  int result; // eax

  result = *(unsigned __int16 *)(a1 + 17844);
  if ( result == 1 )
    return Scr_AddConstString(scr_const[158]);
  if ( *(unsigned __int16 *)(a1 + 17844) <= 1u )
    return Scr_AddConstString(scr_const[146]);
  if ( result == 2 )
    result = Scr_AddConstString(scr_const[159]);
  return result;
}
// 43901: conditional instruction was optimized away because of '%var_8.4==0'
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (00043956) --------------------------------------------------------
int __cdecl sub_43956(int a1)
{
  int result; // eax
  char v2; // al
  int v3; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[126] )
  {
    result = a1;
    *(_DWORD *)(a1 + 17668) = 0;
  }
  else if ( v4 == scr_const[147] )
  {
    result = a1;
    *(_DWORD *)(a1 + 17668) = 1;
  }
  else if ( v4 == scr_const[76] )
  {
    result = a1;
    *(_DWORD *)(a1 + 17668) = 2;
  }
  else if ( v4 == scr_const[113] )
  {
    result = a1;
    *(_DWORD *)(a1 + 17668) = 3;
  }
  else
  {
    v2 = SL_ConvertToString(v4);
    v3 = va("'%s' is an illegal sessionstate string. Must be playing, dead, spectator, or intermission.", v2);
    result = Scr_Error(v3);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00043A2F) --------------------------------------------------------
int __cdecl sub_43A2F(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 17668);
  switch ( result )
  {
    case 1:
      return Scr_AddConstString(scr_const[147]);
    case 0:
      return Scr_AddConstString(scr_const[126]);
    case 2:
      return Scr_AddConstString(scr_const[76]);
    case 3:
      result = Scr_AddConstString(scr_const[113]);
      break;
  }
  return result;
}
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (00043AC7) --------------------------------------------------------
int __cdecl sub_43AC7(_DWORD *a1)
{
  int result; // eax

  a1[4449] = Scr_GetInt(0);
  if ( (int)a1[4449] <= 0 )
    a1[4449] = 1;
  if ( a1[71] > a1[4449] )
    a1[71] = a1[4449];
  g_entities[-356500193 * (((int)a1 - level[0]) >> 2) + 144] = a1[71];
  result = a1[4449];
  a1[73] = result;
  return result;
}
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00043B82) --------------------------------------------------------
int __cdecl sub_43B82(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 17800) = Scr_GetInt(0);
  if ( *(int *)(a1 + 17800) < 0 )
    *(_DWORD *)(a1 + 17800) = 0;
  result = a1;
  *(float *)&g_entities[-356500193 * ((a1 - level[0]) >> 2) + 124] = (float)*(int *)(a1 + 17800);
  return result;
}
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00043C05) --------------------------------------------------------
int __cdecl sub_43C05(int a1)
{
  *(_DWORD *)(a1 + 17684) = Scr_GetInt(0);
  return CalculateRanks();
}
// 16D14: using guessed type int CalculateRanks(void);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00043C3D) --------------------------------------------------------
int __cdecl sub_43C3D(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < -1 || v2 > 63 )
    Scr_Error("spectatorclient can only be set to -1, or a valid client number");
  result = v2;
  *(_DWORD *)(a1 + 17672) = v2;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00043C8C) --------------------------------------------------------
int __cdecl sub_43C8C(int a1)
{
  int result; // eax
  char v2; // [esp+Ch] [ebp-Ch]

  v2 = Scr_GetString(0);
  result = GScr_GetStatusIconIndex(v2);
  *(_DWORD *)(a1 + 17676) = result;
  return result;
}
// 18494: using guessed type _DWORD __cdecl GScr_GetStatusIconIndex(char);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00043CC9) --------------------------------------------------------
int __cdecl sub_43CC9(int a1)
{
  int result; // eax
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( !*(_DWORD *)(a1 + 17676) )
    return Scr_AddString(&unk_9DFE0);
  result = a1;
  if ( *(int *)(a1 + 17676) <= 16 )
  {
    trap_GetConfigstring(*(_DWORD *)(a1 + 17676) + 21, v2, 1024);
    result = Scr_AddString(v2);
  }
  return result;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00043D43) --------------------------------------------------------
int __cdecl sub_43D43(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+8h] [ebp-10h]
  char v3; // [esp+Ch] [ebp-Ch]

  v2 = &g_entities[-356500193 * ((a1 - level[0]) >> 2)];
  v3 = Scr_GetString(0);
  result = GScr_GetHeadIconIndex(v3);
  v2[38] = result;
  return result;
}
// 16814: using guessed type _DWORD __cdecl GScr_GetHeadIconIndex(char);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00043DA9) --------------------------------------------------------
_DWORD *__cdecl sub_43DA9(int a1)
{
  _DWORD *result; // eax
  char v2[1036]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v3; // [esp+41Ch] [ebp-Ch]

  v3 = &g_entities[-356500193 * ((a1 - level[0]) >> 2)];
  if ( !v3[38] )
    return (_DWORD *)Scr_AddString(&unk_9DFE0);
  result = v3;
  if ( (int)v3[38] <= 15 )
  {
    trap_GetConfigstring(v3[38] + 37, v2, 1024);
    result = (_DWORD *)Scr_AddString(v2);
  }
  return result;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00043E4C) --------------------------------------------------------
_DWORD *__cdecl sub_43E4C(int a1)
{
  _DWORD *result; // eax
  char v2; // al
  int v3; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]

  v4 = &g_entities[-356500193 * ((a1 - level[0]) >> 2)];
  v5 = Scr_GetConstString(0);
  if ( v5 == scr_const[146] )
  {
    result = v4;
    v4[39] = 0;
  }
  else if ( v5 == scr_const[2] )
  {
    result = v4;
    v4[39] = 2;
  }
  else if ( v5 == scr_const[4] )
  {
    result = v4;
    v4[39] = 1;
  }
  else if ( v5 == scr_const[76] )
  {
    result = v4;
    v4[39] = 3;
  }
  else
  {
    v2 = SL_ConvertToString(v5);
    v3 = va("'%s' is an illegal head icon team string. Must be none, allies, axis, or spectator.", v2);
    result = (_DWORD *)Scr_Error(v3);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00043F48) --------------------------------------------------------
int __cdecl sub_43F48(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = g_entities[-356500193 * ((a1 - level[0]) >> 2) + 39];
  if ( v2 == 2 )
    return Scr_AddConstString(scr_const[2]);
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
      return Scr_AddConstString(scr_const[76]);
  }
  else if ( v2 == 1 )
  {
    return Scr_AddConstString(scr_const[4]);
  }
  return Scr_AddConstString(scr_const[146]);
}
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (00044005) --------------------------------------------------------
__int16 __cdecl sub_44005(int a1)
{
  long double v1; // fst7
  __int16 result; // ax
  __int16 v3; // [esp+Eh] [ebp-Ah]

  v1 = Scr_GetFloat(0);
  result = v3 | 0xC00;
  *(_DWORD *)(a1 + 17680) = (int)(v1 * 1000.0);
  return result;
}
// 44036: variable 'v3' is possibly undefined
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00044051) --------------------------------------------------------
int __cdecl sub_44051(int a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = (long double)*(int *)(a1 + 17680) * 0.001;
  return Scr_AddFloat(LODWORD(v2));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (00044082) --------------------------------------------------------
char **__cdecl GScr_AddFieldsForClient(unsigned __int16 a1)
{
  char **result; // eax
  unsigned int v2; // [esp+18h] [ebp-10h]
  char **i; // [esp+1Ch] [ebp-Ch]

  for ( i = &off_ACB00; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    v2 = (unsigned int)i[2];
    if ( v2 > 7 )
    {
      if ( v2 != 10 )
        continue;
LABEL_8:
      Scr_AddClassField(
        a1,
        *i,
        (unsigned __int16)(-13107 * (((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_ACB00 - 183814))) >> 2)) | 0xC000);
      continue;
    }
    if ( v2 >= 3 || !v2 )
      goto LABEL_8;
  }
  return result;
}
// 18404: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// ACB00: using guessed type char *off_ACB00;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00044118) --------------------------------------------------------
int __cdecl Scr_SetClientField(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+10h] [ebp-8h]

  v3 = &(&off_ACB00)[5 * a2];
  if ( v3[3] )
    result = ((int (__cdecl *)(int, int, char **))v3[3])(a1, a1, v3);
  else
    result = Scr_SetGenericField(a1, v3[2], v3[1]);
  return result;
}
// 189E4: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// ACB00: using guessed type char *off_ACB00;

//----- (00044192) --------------------------------------------------------
int __cdecl Scr_GetClientField(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+10h] [ebp-8h]

  v3 = &(&off_ACB00)[5 * a2];
  if ( v3[4] )
    result = ((int (__cdecl *)(int, int, char **))v3[4])(a1, a1, v3);
  else
    result = Scr_GetGenericField(a1, v3[2], v3[1]);
  return result;
}
// 187F4: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// ACB00: using guessed type char *off_ACB00;

//----- (0004420C) --------------------------------------------------------
void sub_4420C()
{
  ;
}

//----- (00044210) --------------------------------------------------------
int __cdecl SetClientOrigin(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *(_DWORD *)(a1[88] + 20) = *a2;
  *(_DWORD *)(a1[88] + 24) = a2[1];
  *(_DWORD *)(a1[88] + 28) = a2[2];
  *(float *)(a1[88] + 28) = *(float *)(a1[88] + 28) + 1.0;
  *(_DWORD *)(a1[88] + 132) ^= 8u;
  BG_PlayerStateToEntityState(a1[88], a1, 1);
  a1[79] = *(_DWORD *)(a1[88] + 20);
  a1[80] = *(_DWORD *)(a1[88] + 24);
  result = *(_DWORD *)(a1[88] + 28);
  a1[81] = result;
  return result;
}
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);

//----- (00044301) --------------------------------------------------------
int __usercall SetClientViewAngle@<eax>(long double a1@<st0>, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  int result; // eax
  float v6; // [esp+0h] [ebp-48h]
  float v7; // [esp+0h] [ebp-48h]
  float v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+1Ch] [ebp-2Ch]
  float v11; // [esp+1Ch] [ebp-2Ch]
  float v12; // [esp+1Ch] [ebp-2Ch]
  float v13; // [esp+1Ch] [ebp-2Ch]
  float v14; // [esp+20h] [ebp-28h]
  float v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-Ch]

  v14 = *(float *)a3;
  v15 = *(float *)(a3 + 4);
  v16 = *(_DWORD *)(a3 + 8);
  if ( (*(_DWORD *)(*(_DWORD *)(a2 + 352) + 12) & 1) != 0 && (*(_DWORD *)(*(_DWORD *)(a2 + 352) + 132) & 0x106000) == 0 )
  {
    AngleDelta(*(float *)(*(_DWORD *)(a2 + 352) + 1444), v15);
    v8 = a1;
    AngleNormalize180(v8);
    v9 = a1;
    if ( v9 > 45.0 || (v3 = v9, v9 < -45.0) )
    {
      if ( v9 <= 45.0 )
        v10 = v9 + 45.0;
      else
        v10 = v9 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 352) + 80) += (unsigned __int16)(int)(v10 * 182.04445);
      if ( v10 <= 0.0 )
        v3 = *(float *)(*(_DWORD *)(a2 + 352) + 1444) + 45.0;
      else
        v3 = *(float *)(*(_DWORD *)(a2 + 352) + 1444) - 45.0;
      v6 = v3;
      AngleNormalize360(v6);
      v15 = v3;
    }
    AngleDelta(*(float *)(*(_DWORD *)(a2 + 352) + 1452), v14);
    v11 = v3;
    AngleNormalize180(v11);
    v12 = v3;
    if ( v12 > 45.0 || v12 < -15.0 )
    {
      if ( v12 <= 45.0 )
        v13 = v12 + 15.0;
      else
        v13 = v12 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 352) + 76) += (unsigned __int16)(int)(v13 * 182.04445);
      if ( v13 <= 0.0 )
        v4 = *(float *)(*(_DWORD *)(a2 + 352) + 1452) + 15.0;
      else
        v4 = *(float *)(*(_DWORD *)(a2 + 352) + 1452) - 45.0;
      v7 = v4;
      AngleNormalize180(v7);
      v14 = v4;
    }
  }
  for ( i = 0; i <= 2; ++i )
    *(_DWORD *)(*(_DWORD *)(a2 + 352) + 4 * i + 76) = (unsigned __int16)(int)(*(&v14 + i) * 182.04445)
                                                    - *(_DWORD *)(*(_DWORD *)(a2 + 352) + 4 * i + 17708);
  *(float *)(a2 + 328) = v14;
  *(float *)(a2 + 332) = v15;
  *(_DWORD *)(a2 + 336) = v16;
  *(_DWORD *)(*(_DWORD *)(a2 + 352) + 232) = *(_DWORD *)(a2 + 328);
  *(_DWORD *)(*(_DWORD *)(a2 + 352) + 236) = *(_DWORD *)(a2 + 332);
  result = *(_DWORD *)(a2 + 336);
  *(_DWORD *)(*(_DWORD *)(a2 + 352) + 240) = result;
  return result;
}

//----- (00044692) --------------------------------------------------------
int __cdecl sub_44692(char *a1, char *a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  char *dest; // [esp+14h] [ebp-14h]
  char v6; // [esp+1Bh] [ebp-Dh]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+38h] [ebp+10h]

  v9 = a3 - 1;
  v8 = 0;
  v7 = 0;
  dest = a2;
  *a2 = 0;
  v4 = 0;
  while ( 1 )
  {
    v6 = *a1++;
    if ( !v6 )
      break;
    if ( *dest || v6 != 32 )
    {
      if ( v6 == 94 )
      {
        if ( !*a1 )
          break;
        if ( (unsigned __int8)ColorIndex((unsigned __int8)*a1) )
        {
          if ( v8 > v9 - 2 )
            break;
          *a2 = 94;
          a2[1] = *a1++;
          a2 += 2;
          v8 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else if ( v6 == 32 )
      {
        if ( ++v4 <= 3 )
          goto LABEL_15;
      }
      else
      {
        v4 = 0;
LABEL_15:
        if ( v8 > v9 - 1 )
          break;
        *a2++ = v6;
        ++v7;
        ++v8;
      }
    }
  }
  *a2 = 0;
  result = (int)dest;
  if ( !*dest || !v7 )
    result = Q_strncpyz(dest, "UnnamedPlayer", v9);
  return result;
}
// 179C4: using guessed type _DWORD __cdecl ColorIndex(_DWORD);

//----- (000447D5) --------------------------------------------------------
char *__cdecl ClientUserinfoChanged(int a1)
{
  int v1; // esi
  int v2; // esi
  const char *v3; // eax
  char *result; // eax
  char *v5; // [esp+1Ch] [ebp-82Ch]
  char dest[1036]; // [esp+20h] [ebp-828h] BYREF
  int v7; // [esp+42Ch] [ebp-41Ch]
  char v8[1032]; // [esp+430h] [ebp-418h] BYREF
  char *nptr; // [esp+838h] [ebp-10h]
  _DWORD *v10; // [esp+83Ch] [ebp-Ch]

  v10 = &g_entities[211 * a1];
  v7 = v10[88];
  trap_GetUserinfo(a1, dest, 1024);
  if ( !Info_Validate(dest) )
    strcpy(dest, "\\name\\badinfo");
  v1 = v7;
  *(_DWORD *)(v1 + 17748) = trap_IsLocalClient(a1);
  nptr = (char *)Info_ValueForKey(dest, (int)"cg_predictItems");
  if ( atoi(nptr) )
    *(_DWORD *)(v7 + 17752) = 1;
  else
    *(_DWORD *)(v7 + 17752) = 0;
  if ( *(_DWORD *)(v7 + 17696) == 2 && level[133] )
  {
    nptr = (char *)Info_ValueForKey(dest, (int)"name");
    sub_44692(nptr, (char *)(v7 + 17760), 32);
  }
  else
  {
    Q_strncpyz(v8, (char *)(v7 + 17908), 1024);
    nptr = (char *)Info_ValueForKey(dest, (int)"name");
    sub_44692(nptr, (char *)(v7 + 17908), 32);
    Q_strncpyz((char *)(v7 + 17760), (char *)(v7 + 17908), 32);
  }
  v2 = v7;
  v3 = (const char *)Info_ValueForKey(dest, (int)"handicap");
  *(_DWORD *)(v2 + 17792) = atoi(v3);
  if ( *(int *)(v7 + 17792) <= 0 || *(int *)(v7 + 17792) > 100 )
    *(_DWORD *)(v7 + 17792) = 100;
  v5 = &aSDoesNotExist[1232 * a1 + (_DWORD)bgs];
  *((_DWORD *)v5 + 2) = a1;
  Q_strncpyz(v5 + 12, (char *)(v7 + 17908), 32);
  if ( *((_DWORD *)v5 + 11) != *(_DWORD *)(v7 + 17852) && (*(_DWORD *)(v7 + 132) & 0x100000) != 0 )
    VEH_UnlinkPlayer(v10, 0);
  result = &aSDoesNotExist[1232 * a1 + (_DWORD)bgs];
  *((_DWORD *)v5 + 11) = *(_DWORD *)(v7 + 17852);
  return result;
}
// 18154: using guessed type _DWORD __cdecl trap_IsLocalClient(_DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);
// 19054: using guessed type _DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD);

//----- (00044AB4) --------------------------------------------------------
const char *__cdecl ClientConnect(int a1, __int16 a2)
{
  const char *v3; // [esp+10h] [ebp-428h]
  int v4; // [esp+14h] [ebp-424h]
  char *v5; // [esp+18h] [ebp-420h]
  _DWORD *v6; // [esp+1Ch] [ebp-41Ch]
  char v7[1028]; // [esp+20h] [ebp-418h] BYREF
  void *s; // [esp+424h] [ebp-14h]
  char *s2; // [esp+428h] [ebp-10h]
  __int16 v10; // [esp+42Eh] [ebp-Ah]

  v10 = a2;
  v6 = &g_entities[211 * a1];
  s = (void *)(level[0] + 18228 * a1);
  memset(s, 0, 0x4734u);
  v5 = &aSDoesNotExist[1232 * a1 + (_DWORD)bgs];
  v4 = *((_DWORD *)v5 + 305);
  memset(v5, 0, 0x4D0u);
  *((_DWORD *)v5 + 305) = v4;
  *(_DWORD *)v5 = 1;
  *((_DWORD *)v5 + 1) = 1;
  *((_DWORD *)s + 4424) = 1;
  *((_WORD *)s + 8846) = v10;
  *((_DWORD *)s + 4463) = 3;
  *((_DWORD *)s + 4417) = 2;
  *((_DWORD *)s + 4486) = -1;
  *((_DWORD *)s + 4418) = -1;
  *((_WORD *)s + 8922) = 0;
  G_InitGentity(v6);
  v6[135] = 0;
  v6[137] = 0;
  v6[88] = s;
  *((_DWORD *)s + 4462) = a1;
  *((_DWORD *)s + 53) = a1;
  *((_DWORD *)s + 33) = 16;
  v6[62] = 512;
  *((_DWORD *)s + 4456) = -1;
  *((_DWORD *)s + 4457) = -1;
  *((_DWORD *)s + 4450) = g_speed[3];
  ClientUserinfoChanged(a1);
  trap_GetUserinfo(a1, v7, 1024);
  trap_Cvar_Set("cg_atmos", "-1");
  if ( *((_DWORD *)s + 4437)
    || (s2 = (char *)Info_ValueForKey(v7, (int)"password"), !g_password[16])
    || !Q_stricmp(&g_password[16], "none")
    || !strcmp(&g_password[16], s2) )
  {
    Scr_PlayerConnect(v6);
    CalculateRanks();
    v3 = 0;
  }
  else
  {
    G_FreeEntity(v6);
    v3 = "GAME_INVALIDPASSWORD";
  }
  return v3;
}
// 168F4: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 16D14: using guessed type int CalculateRanks(void);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 18064: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);
// 189A4: using guessed type _DWORD __cdecl Scr_PlayerConnect(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 19054: using guessed type _DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD);

//----- (00044D82) --------------------------------------------------------
int __cdecl ClientBegin(int a1)
{
  *(_DWORD *)(level[0] + 18228 * a1 + 17696) = 2;
  CalculateRanks();
  return Scr_Notify(&g_entities[211 * a1], scr_const[103], 0);
}
// 16D14: using guessed type int CalculateRanks(void);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);

//----- (00044DF4) --------------------------------------------------------
int __cdecl ClientSpawn(int a1, _DWORD *a2, int a3)
{
  unsigned int v4; // [esp+14h] [ebp-164h]
  int *v5; // [esp+18h] [ebp-160h]
  _DWORD *v6; // [esp+1Ch] [ebp-15Ch]
  unsigned int v7; // [esp+20h] [ebp-158h]
  int *v8; // [esp+24h] [ebp-154h]
  int *v9; // [esp+28h] [ebp-150h]
  int v10; // [esp+2Ch] [ebp-14Ch]
  int v11; // [esp+30h] [ebp-148h] BYREF
  _BYTE v12[288]; // [esp+34h] [ebp-144h] BYREF
  int v13; // [esp+154h] [ebp-24h]
  void *s; // [esp+158h] [ebp-20h]
  int v15; // [esp+15Ch] [ebp-1Ch]

  v15 = 1852331867 * ((a1 - (int)g_entities) >> 2);
  s = *(void **)(a1 + 352);
  if ( (*((_DWORD *)s + 3) & 0x80000) != 0 && (*((_DWORD *)s + 33) & 0x6000) != 0 )
    G_ClientStopUsingTurret(level[1] + 844 * *((_DWORD *)s + 367));
  if ( (*((_DWORD *)s + 3) & 0x80000) != 0 && (*((_DWORD *)s + 33) & 0x100000) != 0 )
    VEH_UnlinkPlayer(a1, 0);
  G_EntUnlink(a1);
  if ( *(_DWORD *)(a1 + 244) )
    trap_UnlinkEntity(a1);
  *(_DWORD *)(a1 + 124) = 1023;
  Scr_SetString(a1 + 388, scr_const[50]);
  *(_DWORD *)(a1 + 416) = 42008593;
  *(_DWORD *)(a1 + 248) |= 1u;
  *(_BYTE *)(a1 + 381) = 0;
  G_SetClientContents(a1);
  *(_DWORD *)(a1 + 552) = player_die;
  *(_BYTE *)(a1 + 380) = 0;
  *(_BYTE *)(a1 + 379) = 0;
  *(_DWORD *)(a1 + 396) = 0x2000;
  *(_DWORD *)(a1 + 264) = playerMins[0];
  *(_DWORD *)(a1 + 268) = playerMins[1];
  *(_DWORD *)(a1 + 272) = playerMins[2];
  *(_DWORD *)(a1 + 276) = playerMaxs[0];
  *(_DWORD *)(a1 + 280) = playerMaxs[1];
  *(_DWORD *)(a1 + 284) = playerMaxs[2];
  v13 = *((_DWORD *)s + 33) & 0x10008;
  v9 = &v11;
  v8 = (int *)((char *)s + 17668);
  v7 = 276;
  if ( ((unsigned __int8)&v11 & 4) != 0 )
  {
    v11 = *v8;
    v9 = (int *)v12;
    v8 = (int *)((char *)s + 17672);
    v7 = 272;
  }
  qmemcpy(v9, v8, 4 * (v7 >> 2));
  v10 = *((_DWORD *)s + 76);
  memset(s, 0, 0x4734u);
  v6 = (char *)s + 17668;
  v5 = &v11;
  v4 = 276;
  if ( (((_BYTE)s + 4) & 4) != 0 )
  {
    *v6++ = v11;
    v5 = (int *)v12;
    v4 = 272;
  }
  qmemcpy(v6, v5, 4 * (v4 >> 2));
  *((_DWORD *)s + 4486) = -1;
  *((_DWORD *)s + 76) = v10 + 1;
  *((_DWORD *)s + 73) = *((_DWORD *)s + 4449);
  *((_DWORD *)s + 33) = v13;
  *((_DWORD *)s + 33) |= 0x10u;
  *((_DWORD *)s + 4462) = v15;
  *((_DWORD *)s + 53) = v15;
  trap_GetUsercmd(-1380760827 * (((int)s - level[0]) >> 2), (char *)s + 17700);
  *((_DWORD *)s + 33) ^= 8u;
  *((_DWORD *)s + 343) = *(_DWORD *)(a1 + 264);
  *((_DWORD *)s + 344) = *(_DWORD *)(a1 + 268);
  *((_DWORD *)s + 345) = *(_DWORD *)(a1 + 272);
  *((_DWORD *)s + 346) = *(_DWORD *)(a1 + 276);
  *((_DWORD *)s + 347) = *(_DWORD *)(a1 + 280);
  *((_DWORD *)s + 348) = *(_DWORD *)(a1 + 284);
  *((_DWORD *)s + 349) = bg_viewheight_prone[3];
  *((_DWORD *)s + 350) = bg_viewheight_crouched[3];
  *((_DWORD *)s + 351) = bg_viewheight_standing[3];
  *((_DWORD *)s + 352) = 8;
  *((_DWORD *)s + 61) = bg_viewheight_standing[3];
  *((float *)s + 62) = (float)(int)bg_viewheight_standing[3];
  *((_DWORD *)s + 63) = 0;
  *((_DWORD *)s + 66) = 0;
  *((_DWORD *)s + 353) = 1053609165;
  *((_DWORD *)s + 354) = 1065353216;
  *((_DWORD *)s + 355) = 1070386381;
  *((_DWORD *)s + 356) = 1041865114;
  *((_DWORD *)s + 357) = 1059481190;
  *((_DWORD *)s + 358) = 1061997773;
  *((_DWORD *)s + 359) = 1060320051;
  *((_DWORD *)s + 360) = 1053609165;
  *((_DWORD *)s + 368) = 1065353216;
  *((_DWORD *)s + 364) = 1065353216;
  G_SetOrigin(a1, a2);
  *((_DWORD *)s + 5) = *a2;
  *((_DWORD *)s + 6) = a2[1];
  *((_DWORD *)s + 7) = a2[2];
  *((_DWORD *)s + 3) |= 0x800u;
  SetClientViewAngle(a1, a3);
  *((_DWORD *)s + 4510) = level[123] + 1000 * g_inactivity[3];
  *((_DWORD *)s + 4511) = level[123] + 1000 * g_inactivityspectator[3];
  *((_DWORD *)s + 4512) = 0;
  *((_DWORD *)s + 4513) = 0;
  *((_DWORD *)s + 4493) = 0;
  *((_DWORD *)s + 4496) = 0;
  *((_DWORD *)s + 4425) = level[123];
  *(_DWORD *)s = level[123] - 100;
  ClientEndFrame(a1);
  ClientThink_real(a1, (char *)s + 17700);
  return BG_PlayerStateToEntityState(s, a1, 1);
}
// 16F24: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);
// 173D4: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18364: using guessed type _DWORD __cdecl G_SetClientContents(_DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 18994: using guessed type _DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 197D4: using guessed type _DWORD __cdecl ClientEndFrame(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);
// 4F972: using guessed type int __cdecl player_die(int, int, int, int, int, int, int, int);

//----- (00045433) --------------------------------------------------------
int __cdecl ClientDisconnect(int a1)
{
  int v2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  v2 = level[0] + 18228 * a1;
  s = &g_entities[211 * a1];
  Scr_AddString("disconnect");
  Scr_AddString("-1");
  Scr_Notify(s, scr_const[115], 2);
  for ( i = 0; i < level[121]; ++i )
  {
    if ( *(_DWORD *)(level[0] + 18228 * i + 17696)
      && *(_DWORD *)(level[0] + 18228 * i + 17668) == 2
      && *(_DWORD *)(level[0] + 18228 * i + 17944) == a1 )
    {
      StopFollowing(&g_entities[211 * i]);
    }
  }
  for ( j = 0; j < level[121]; ++j )
  {
    if ( *(_DWORD *)(level[0] + 18228 * j + 17696) && *(_DWORD *)(level[0] + 18228 * j + 17824) == a1 )
    {
      *(_DWORD *)(level[0] + 18228 * j + 17824) = -1;
      *(_DWORD *)(level[0] + 18228 * j + 17828) = 0;
      trap_SendServerCommand(j, 1, "m -2");
      break;
    }
  }
  if ( (*(_DWORD *)(s[88] + 132) & 0x100000) != 0 )
    VEH_UnlinkPlayer(s, 0);
  HudElem_ClientDisconnect(s);
  Scr_PlayerDisconnect(s);
  G_FreeEntity(s);
  *(_DWORD *)(v2 + 17696) = 0;
  memset((void *)(v2 + 17848), 0, 0x5Cu);
  return CalculateRanks();
}
// 16B94: using guessed type _DWORD __cdecl Scr_PlayerDisconnect(_DWORD);
// 16D14: using guessed type int CalculateRanks(void);
// 17694: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18C74: using guessed type _DWORD __cdecl HudElem_ClientDisconnect(_DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);

//----- (00045692) --------------------------------------------------------
int G_SetPlayerSize()
{
  int result; // eax
  float v1; // [esp+0h] [ebp-8h]
  float v2; // [esp+0h] [ebp-8h]

  v1 = g_bounds_width[2] * -0.5;
  *(float *)&playerMins[1] = v1;
  *(float *)playerMins = v1;
  v2 = g_bounds_width[2] * 0.5;
  *(float *)&playerMaxs[1] = v2;
  *(float *)playerMaxs = v2;
  result = g_bounds_height_standing[2];
  playerMaxs[2] = result;
  return result;
}

//----- (0004570C) --------------------------------------------------------
int __cdecl G_AddLean(int a1, int a2)
{
  return AddLeanToPosition(
           a2,
           *(_DWORD *)(*(_DWORD *)(a1 + 352) + 236),
           *(float *)(*(_DWORD *)(a1 + 352) + 68),
           16.0,
           20.0);
}

//----- (00045762) --------------------------------------------------------
unsigned int __cdecl G_GetNonPVSFriendlyInfo(_DWORD *a1, float *a2, int a3)
{
  int v5; // [esp+30h] [ebp-38h]
  _DWORD *v6; // [esp+34h] [ebp-34h]
  float v7; // [esp+38h] [ebp-30h]
  float v8; // [esp+3Ch] [ebp-2Ch]
  float v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+44h] [ebp-24h]
  int v11; // [esp+48h] [ebp-20h]
  int v12; // [esp+4Ch] [ebp-1Ch]
  int i; // [esp+58h] [ebp-10h]
  int v14; // [esp+5Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1[88] + 17852);
  if ( !v5 || v5 == 3 )
    return 0;
  if ( a3 == 1023 )
    v14 = 0;
  else
    v14 = a3 + 1;
  for ( i = 0; ; ++i )
  {
    if ( i > 63 )
      return 0;
    v6 = &g_entities[211 * ((i + v14) % 64)];
    if ( *((_BYTE *)v6 + 364) )
    {
      if ( v6[88]
        && !*(_DWORD *)(v6[88] + 17668)
        && *(_DWORD *)(v6[88] + 17852) == v5
        && a1 != v6
        && !trap_InSnapshot(a2, *v6) )
      {
        break;
      }
    }
  }
  v9 = *((float *)v6 + 79) - *a2;
  v10 = *((float *)v6 + 80) - a2[1];
  v11 = (int)(v9 + 0.5);
  v12 = (int)(v10 + 0.5);
  v7 = 1.0;
  v8 = 1.0;
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v7 = -1022.0 / (long double)v11;
  }
  else
  {
    v7 = 1024.0 / (long double)v11;
  }
  if ( v12 <= 1024 )
  {
    if ( v12 < -1022 )
      v8 = -1022.0 / (long double)v12;
  }
  else
  {
    v8 = 1024.0 / (long double)v12;
  }
  if ( v7 < 1.0 || v8 < 1.0 )
  {
    if ( v8 <= (long double)v7 )
    {
      if ( v7 > (long double)v8 )
        v11 = (int)((long double)v11 * v8);
    }
    else
    {
      v12 = (int)((long double)v12 * v7);
    }
  }
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v11 = -1022;
  }
  else
  {
    v11 = 1024;
  }
  if ( v12 <= 1024 )
  {
    if ( v12 < -1022 )
      v12 = -1022;
  }
  else
  {
    v12 = 1024;
  }
  return ((*v6 & 0xFFFF803F | ((((unsigned __int16)((v11 + 2) / 4) + 255) & 0x1FF) << 6)) & 0xFF007FFF | ((((unsigned __int16)((v12 + 2) / 4) + 255) & 0x1FF) << 15)) & 0xFFFFFF | ((unsigned __int8)(int)(*((float *)v6 + 83) * 0.71111113) << 24);
}
// 188C4: using guessed type _DWORD __cdecl trap_InSnapshot(_DWORD, _DWORD);

//----- (00045ACB) --------------------------------------------------------
void sub_45ACB()
{
  ;
}

//----- (00045AD0) --------------------------------------------------------
int __cdecl PlayerCmd_giveWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+28h] [ebp-10h]
  char v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  v5 = Com_BitCheck(v4[88] + 1332, v6);
  if ( !BG_GetEmptySlotForWeapon(v4[88], v6) && !BG_GetStackSlotForWeapon(v4[88], v6, 0) )
    Scr_ParamError(0, "Can not give player weapon without having an empty weapon slot\n");
  BG_GivePlayerWeapon(v4[88], v6);
  v8 = BG_GetInfoForWeapon(v6);
  result = *(_DWORD *)(v8 + 480) - *(_DWORD *)(v4[88] + 4 * *(_DWORD *)(v8 + 488) + 308);
  if ( result > 0 )
    result = Add_Ammo(v4, v6, result, v5 == 0);
  return result;
}
// 16914: using guessed type _DWORD __cdecl BG_GetStackSlotForWeapon(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17C04: using guessed type _DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 180F4: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00045C6D) --------------------------------------------------------
int __cdecl PlayerCmd_takeWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int v4; // esi
  _DWORD *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v8 = Scr_GetString(0);
  v7 = (unsigned __int8)BG_GetWeaponIndexForName(v8);
  v3 = v6[88];
  *(_DWORD *)(v3 + 4 * BG_AmmoForWeapon(v7) + 308) = 0;
  v4 = v6[88];
  *(_DWORD *)(v4 + 4 * BG_ClipForWeapon(v7) + 820) = 0;
  return BG_TakePlayerWeapon(v6[88], v7);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00045D6B) --------------------------------------------------------
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // esi
  int v5; // esi
  _DWORD *v6; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  *(_DWORD *)(v6[88] + 216) = 0;
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    v4 = v6[88];
    *(_DWORD *)(v4 + 4 * BG_AmmoForWeapon(i) + 308) = 0;
    v5 = v6[88];
    *(_DWORD *)(v5 + 4 * BG_ClipForWeapon(i) + 820) = 0;
    BG_TakePlayerWeapon(v6[88], i);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00045E76) --------------------------------------------------------
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(int *)(v4[88] + 216) <= 0 )
    return Scr_AddString("none");
  v5 = BG_GetInfoForWeapon(*(_DWORD *)(v4[88] + 216));
  return Scr_AddString(*(_DWORD *)(v5 + 4));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00045F46) --------------------------------------------------------
int __cdecl PlayerCmd_hasWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  if ( Com_BitCheck(v4[88] + 1332, v5) )
    result = Scr_AddBool(1);
  else
    result = Scr_AddBool(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18DF4: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00046027) --------------------------------------------------------
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  if ( !Com_BitCheck(v5[88] + 1332, v6) )
    return Scr_AddBool(0);
  v3 = va("a %i", v6);
  trap_SendServerCommand(1852331867 * (v5 - g_entities), 1, v3);
  return Scr_AddBool(1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18DF4: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00046145) --------------------------------------------------------
int __cdecl PlayerCmd_giveClipAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+28h] [ebp-10h]
  char v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v5 = Scr_GetInt(1);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  result = Com_BitCheck(v4[88] + 1332, v6);
  if ( result )
  {
    v8 = BG_GetInfoForWeapon(v6);
    result = v5 * *(_DWORD *)(v8 + 504) - *(_DWORD *)(v4[88] + 4 * *(_DWORD *)(v8 + 488) + 308);
    if ( result > 0 )
      result = Add_Ammo(v4, v6, result, 1);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0004627D) --------------------------------------------------------
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[88] + 1332, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    result = *(_DWORD *)(v7 + 480) - *(_DWORD *)(v4[88] + 4 * *(_DWORD *)(v7 + 488) + 308);
    if ( result > 0 )
      result = Add_Ammo(v4, v5, result, 0);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (000463A0) --------------------------------------------------------
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[88] + 1332, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    result = BG_GetAmmoTypeMax(*(_DWORD *)(v7 + 488)) - *(_DWORD *)(v4[88] + 4 * *(_DWORD *)(v7 + 488) + 308);
    if ( result > 0 )
      result = Add_Ammo(v4, v5, result, 0);
  }
  return result;
}
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (000464CD) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  char v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  if ( !Com_BitCheck(v4[88] + 1332, v6) )
    return Scr_AddFloat(1065353216);
  v8 = BG_GetInfoForWeapon(v6);
  if ( *(int *)(v8 + 480) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(v4[88] + 4 * *(_DWORD *)(v8 + 488) + 308) <= 0 )
    return Scr_AddFloat(0);
  v5 = (long double)*(int *)(v4[88] + 4 * *(_DWORD *)(v8 + 488) + 308) / (long double)*(int *)(v8 + 480);
  return Scr_AddFloat(LODWORD(v5));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0004662A) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  float v4; // [esp+Ch] [ebp-1Ch]
  _DWORD *v5; // [esp+10h] [ebp-18h]
  float v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v8 = Scr_GetString(0);
  v7 = (unsigned __int8)BG_GetWeaponIndexForName(v8);
  if ( !Com_BitCheck(v5[88] + 1332, v7) )
    return Scr_AddFloat(1065353216);
  v9 = BG_GetInfoForWeapon(v7);
  if ( (int)BG_GetAmmoTypeMax(*(_DWORD *)(v9 + 488)) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(v5[88] + 4 * *(_DWORD *)(v9 + 488) + 308) <= 0 )
    return Scr_AddFloat(0);
  v4 = (float)*(int *)(v5[88] + 4 * *(_DWORD *)(v9 + 488) + 308);
  v6 = v4 / (long double)(int)BG_GetAmmoTypeMax(*(_DWORD *)(v9 + 488));
  return Scr_AddFloat(LODWORD(v6));
}
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (000467A4) --------------------------------------------------------
int __cdecl sub_467A4(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  int v5[6]; // [esp+20h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v5);
  trap_UnlinkEntity(v4);
  *(_DWORD *)(v4[88] + 20) = v5[0];
  *(_DWORD *)(v4[88] + 24) = v5[1];
  *(_DWORD *)(v4[88] + 28) = v5[2];
  *(float *)(v4[88] + 28) = *(float *)(v4[88] + 28) + 1.0;
  *(_DWORD *)(v4[88] + 132) ^= 8u;
  BG_PlayerStateToEntityState(v4[88], v4, 1);
  v4[79] = *(_DWORD *)(v4[88] + 20);
  v4[80] = *(_DWORD *)(v4[88] + 24);
  v4[81] = *(_DWORD *)(v4[88] + 28);
  return trap_LinkEntity(v4);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (00046920) --------------------------------------------------------
int __cdecl sub_46920(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  char v5[24]; // [esp+20h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v5);
  return SetClientViewAngle(v4, v5);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);

//----- (000469CB) --------------------------------------------------------
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[88] + 17964) & 0x40) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046A81) --------------------------------------------------------
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[88] + 17964) & 1) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046B37) --------------------------------------------------------
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[88] + 17964) & 0x20) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046BED) --------------------------------------------------------
int __cdecl PlayerCmd_isAds(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[88] + 12) & 0x20) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046CA0) --------------------------------------------------------
int __cdecl PlayerCmd_isInVehicle(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (v4[2] & 0x100000) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046D4F) --------------------------------------------------------
int __cdecl PlayerCmd_isOnGround(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v4[88] + 88) == 1023 )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00046E01) --------------------------------------------------------
int __cdecl PlayerCmd_pingPlayer(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  *(_DWORD *)(v4[88] + 132) |= 0x40000u;
  result = level[123] + 4000;
  *(_DWORD *)(v4[88] + 18112) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00046ECA) --------------------------------------------------------
int __cdecl sub_46ECA(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  char *s2; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  s2 = (char *)Scr_GetString(0);
  result = G_ModelIndex(s2);
  *(_DWORD *)(v4[88] + 17832) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00046F7F) --------------------------------------------------------
int __cdecl sub_46F7F(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5 = G_ModelName(*(_DWORD *)(v4[88] + 17832));
  return Scr_AddString(v5);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0004702A) --------------------------------------------------------
int __cdecl sub_4702A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = (_DWORD *)Scr_GetEntity(0);
  result = (int)v5;
  if ( v5 != v6 )
  {
    if ( *(_DWORD *)(v6[88] + 17748) )
    {
      result = trap_SendServerCommand(1852331867 * (v5 - g_entities), 1, "m -4");
    }
    else
    {
      v4 = va("m %i", *v6);
      trap_SendServerCommand(1852331867 * (v5 - g_entities), 1, v4);
      *(_DWORD *)(v5[88] + 17824) = v6[37];
      result = level[123] + 20500;
      *(_DWORD *)(v5[88] + 17828) = result;
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004718A) --------------------------------------------------------
int __cdecl sub_4718A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  return Cmd_Score_f(v4);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16D74: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);

//----- (0004721B) --------------------------------------------------------
int __cdecl sub_4721B(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[88] + 1332, v5);
  if ( result )
  {
    *(_DWORD *)(v4[88] + 216) = v5;
    result = v4[88];
    *(_DWORD *)(result + 220) = 0;
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00047307) --------------------------------------------------------
int __cdecl sub_47307(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  unsigned __int8 v3; // al
  int v4; // eax
  int result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v11 = Scr_GetString(0);
  v3 = BG_GetWeaponIndexForName(v11);
  v10 = v3;
  if ( v3 )
  {
    if ( (unsigned int)Scr_GetNumParam() <= 1 )
    {
      v4 = Drop_Weapon(v6, v10, "tag_weapon_right");
    }
    else
    {
      v9 = Scr_GetString(1);
      v4 = Drop_Weapon(v6, v10, v9);
    }
    result = GScr_AddEntity(v4);
  }
  else
  {
    v7 = BG_FindItem(v11);
    if ( v7 )
    {
      v8 = Drop_Item((int)v6, v7, 0.0, 0);
      result = GScr_AddEntity(v8);
    }
    else
    {
      result = GScr_AddEntity(0);
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17564: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 17CC4: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 18604: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00047442) --------------------------------------------------------
int __cdecl sub_47442(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // al
  char v5; // al
  unsigned __int16 v6; // ax
  _DWORD *v7; // eax
  _DWORD *v8; // [esp+30h] [ebp-98h]
  _DWORD *v9; // [esp+34h] [ebp-94h]
  int v10; // [esp+38h] [ebp-90h]
  float v11; // [esp+40h] [ebp-88h]
  float v12; // [esp+44h] [ebp-84h]
  float v13; // [esp+48h] [ebp-80h]
  float v14; // [esp+50h] [ebp-78h] BYREF
  float v15; // [esp+54h] [ebp-74h]
  float v16; // [esp+58h] [ebp-70h]
  float v17; // [esp+60h] [ebp-68h]
  int v18; // [esp+64h] [ebp-64h]
  int v19; // [esp+68h] [ebp-60h]
  int v20; // [esp+6Ch] [ebp-5Ch]
  int v21; // [esp+70h] [ebp-58h]
  int v22; // [esp+74h] [ebp-54h]
  int v23; // [esp+78h] [ebp-50h]
  char *v24; // [esp+7Ch] [ebp-4Ch]
  char v25[28]; // [esp+80h] [ebp-48h] BYREF
  char *v26; // [esp+9Ch] [ebp-2Ch]
  char v27[24]; // [esp+A0h] [ebp-28h] BYREF
  _DWORD *v28; // [esp+B8h] [ebp-10h]
  int v29; // [esp+BCh] [ebp-Ch]

  v29 = (int)&dword_D2968 + (_DWORD)g_entities;
  v28 = (int *)((char *)&dword_D2968 + (_DWORD)g_entities);
  v26 = 0;
  v24 = 0;
  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v8 = 0;
  }
  else
  {
    v8 = &g_entities[211 * a1];
    if ( !v8[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = Scr_GetInt(2);
  v23 = result;
  if ( result > 0 )
  {
    if ( Scr_GetType(0) && Scr_GetPointerType(0) == 13 )
      v29 = Scr_GetEntity(1);
    if ( Scr_GetType(1) && Scr_GetPointerType(1) == 13 )
      v28 = (_DWORD *)Scr_GetEntity(1);
    v22 = Scr_GetInt(3);
    v4 = Scr_GetString(4);
    v21 = G_IndexForMeansOfDeath(v4);
    v5 = Scr_GetString(5);
    v20 = (unsigned __int8)BG_GetWeaponIndexForName(v5);
    if ( Scr_GetType(6) )
    {
      Scr_GetVector(6, v25);
      v24 = v25;
    }
    if ( Scr_GetType(7) )
    {
      Scr_GetVector(7, v27);
      v26 = v27;
    }
    v6 = Scr_GetConstString(8);
    v19 = G_GetHitLocationIndexFromString(v6);
    if ( v26 )
    {
      VectorNormalize2(v26, &v14);
    }
    else
    {
      v16 = 0.0;
      v15 = 0.0;
      v14 = 0.0;
    }
    if ( (v8[99] & 8) != 0 || (v22 & 4) != 0 )
    {
      v18 = 0;
    }
    else
    {
      v17 = 0.30000001;
      if ( (*(_DWORD *)(v8[88] + 12) & 1) != 0 )
      {
        v17 = 0.02;
      }
      else if ( (*(_DWORD *)(v8[88] + 12) & 2) != 0 )
      {
        v17 = 0.15000001;
      }
      v18 = (int)((long double)v23 * v17);
      if ( v18 > 60 )
        v18 = 60;
      if ( v18 )
      {
        v11 = (long double)v18 * g_knockback[2] / 250.0 * v14;
        v12 = (long double)v18 * g_knockback[2] / 250.0 * v15;
        v13 = (long double)v18 * g_knockback[2] / 250.0 * v16;
        *(float *)(v8[88] + 32) = *(float *)(v8[88] + 32) + v11;
        *(float *)(v8[88] + 36) = *(float *)(v8[88] + 36) + v12;
        *(float *)(v8[88] + 40) = *(float *)(v8[88] + 40) + v13;
        if ( !*(_DWORD *)(v8[88] + 16) )
        {
          v10 = 2 * v18;
          if ( 2 * v18 <= 49 )
            v10 = 50;
          if ( v10 > 200 )
            v10 = 200;
          *(_DWORD *)(v8[88] + 16) = v10;
          *(_DWORD *)(v8[88] + 12) |= 0x200u;
        }
      }
    }
    result = v8[99] & 1;
    if ( !result )
    {
      if ( v20 && !*(_DWORD *)(BG_GetInfoForWeapon(v20) + 124) )
      {
        v9 = (_DWORD *)G_TempEntity(v25, 178);
        v9[41] = (unsigned __int8)DirToByte(&v14);
        v9[55] = (unsigned __int8)DirToByte(&v14);
        v9[34] = 7;
        v9[51] = v28[51];
        v9[29] = *v28;
        v9[62] |= 0x2000u;
        v9[63] = *(_DWORD *)(v8[88] + 212);
        if ( *(_DWORD *)(BG_GetInfoForWeapon(v20) + 796) )
          v7 = (_DWORD *)G_TempEntity(v25, 180);
        else
          v7 = (_DWORD *)G_TempEntity(v25, 179);
        v7[34] = 7;
        v7[51] = v28[51];
        v7[29] = *v28;
        v7[37] = *(_DWORD *)(v8[88] + 212);
        v7[62] = 2048;
        v7[63] = *(_DWORD *)(v8[88] + 212);
      }
      *(_DWORD *)(v8[88] + 18008) += v23;
      if ( v26 )
      {
        *(float *)(v8[88] + 18012) = v14;
        *(float *)(v8[88] + 18016) = v15;
        *(float *)(v8[88] + 18020) = v16;
        *(_DWORD *)(v8[88] + 18024) = 0;
      }
      else
      {
        *(_DWORD *)(v8[88] + 18012) = v8[79];
        *(_DWORD *)(v8[88] + 18016) = v8[80];
        *(_DWORD *)(v8[88] + 18020) = v8[81];
        *(_DWORD *)(v8[88] + 18024) = 1;
      }
      v8[144] -= v23;
      Scr_AddEntity(v28);
      Scr_AddInt(v23);
      Scr_Notify(v8, scr_const[13], 2);
      if ( (int)v8[144] > 0 )
      {
        if ( v8[137] )
          ((void (__cdecl *)(_DWORD *, _DWORD *, int, char *, int, float *, int))v8[137])(
            v8,
            v28,
            v23,
            v24,
            v21,
            &v14,
            v19);
      }
      else
      {
        if ( (int)v8[144] < -999 )
          v8[144] = -999;
        v8[154] = v28;
        if ( v8[138] )
          ((void (__cdecl *)(_DWORD *, int, _DWORD *, int, int, int, float *, int))v8[138])(
            v8,
            v29,
            v28,
            v23,
            v21,
            v20,
            &v14,
            v19);
        result = (int)v8;
        if ( !*((_BYTE *)v8 + 364) )
          return result;
      }
      result = v8[144];
      *(_DWORD *)(v8[88] + 284) = result;
      return result;
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17114: using guessed type _DWORD __cdecl G_GetHitLocationIndexFromString(_DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 192E4: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// D2968: using guessed type int dword_D2968;

//----- (00047C68) --------------------------------------------------------
int __cdecl sub_47C68(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // edx
  _DWORD *v5; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5[99] &= 0xFFFFFFFE;
  v3 = v5[88];
  v5[144] = 0;
  *(_DWORD *)(v3 + 284) = 0;
  return player_die(v5, v5, v5, 100000, 21, 0, 0, 0);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17964: using guessed type _DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00047D64) --------------------------------------------------------
int __cdecl sub_47D64(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  char v7; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v6[88] + 17696) != 2 )
    return Scr_AddInt(0);
  v3 = Scr_GetString(0);
  v7 = GScr_GetScriptMenuIndex(v3);
  v4 = va("t %i", v7);
  trap_SendServerCommand(a1, 1, v4);
  return Scr_AddInt(1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18FA4: using guessed type _DWORD __cdecl GScr_GetScriptMenuIndex(char);

//----- (00047E59) --------------------------------------------------------
int __cdecl sub_47E59(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  char v7; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v6[88] + 17696) != 2 )
    return Scr_AddInt(0);
  v3 = Scr_GetString(0);
  v7 = GScr_GetScriptMenuIndex(v3);
  v4 = va("t %i 1", v7);
  trap_SendServerCommand(a1, 1, v4);
  return Scr_AddInt(1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18FA4: using guessed type _DWORD __cdecl GScr_GetScriptMenuIndex(char);

//----- (00047F4E) --------------------------------------------------------
int __cdecl sub_47F4E(int a1)
{
  return trap_SendServerCommand(a1, 1, "u");
}
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00047F83) --------------------------------------------------------
_BOOL4 __cdecl sub_47F83(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) != 0;
}

//----- (00047F9E) --------------------------------------------------------
int __cdecl sub_47F9E(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v4; // eax
  char v5; // al
  int v6; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a1];
    if ( !v7[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_47F83((int)v7) )
    return Scr_AddConstString(scr_const[146]);
  v10 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v10);
  v9 = BG_GetWeaponSlotForName(v4);
  if ( !v9 )
  {
    v5 = SL_ConvertToString(v10);
    v6 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v5);
    Scr_ParamError(0, v6);
  }
  if ( !*(_BYTE *)(v9 + v7[88] + 1348) )
    return Scr_AddConstString(scr_const[146]);
  v8 = BG_GetInfoForWeapon(*(char *)(v9 + v7[88] + 1348));
  return Scr_AddString(*(_DWORD *)(v8 + 4));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000480F9) --------------------------------------------------------
int __cdecl sub_480F9(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  unsigned __int8 v6; // al
  int v7; // eax
  int v8; // eax
  int result; // eax
  _DWORD *v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+28h] [ebp-10h]
  unsigned __int16 v16; // [esp+2Eh] [ebp-Ah]

  v11 = 0;
  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v10 = 0;
  }
  else
  {
    v10 = &g_entities[211 * a1];
    if ( !v10[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v16 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v16);
  v15 = BG_GetWeaponSlotForName(v3);
  if ( !v15 )
  {
    v4 = SL_ConvertToString(v16);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v13 = Scr_GetString(1);
  if ( Q_stricmp(v13, "none") )
  {
    v6 = BG_GetWeaponIndexForName(v13);
    v14 = v6;
    if ( !v6 )
    {
      v7 = va("Unknown weapon %s.", v13);
      Scr_ParamError(1, v7);
    }
    v12 = BG_GetInfoForWeapon(v14);
    if ( *(_DWORD *)(v12 + 132) != v15
      && (*(_DWORD *)(v12 + 132) != 1 && *(_DWORD *)(v12 + 132) != 2 || v15 != 1 && v15 != 2) )
    {
      BG_GetWeaponSlotNameForIndex(v15);
      BG_GetWeaponSlotNameForIndex(*(_DWORD *)(v12 + 132));
      v8 = va("Weapon %s goes in the %s weaponslot, not the %s weaponslot.", v13);
      Scr_ParamError(1, v8);
    }
  }
  else
  {
    v14 = 0;
  }
  result = *(char *)(v15 + v10[88] + 1348);
  if ( *(_BYTE *)(v15 + v10[88] + 1348) )
    result = BG_TakePlayerWeapon(v10[88], *(char *)(v15 + v10[88] + 1348));
  if ( v14 )
  {
    if ( v15 == 2 && !*(_BYTE *)(v10[88] + 1349) )
      v11 = 1;
    result = BG_GivePlayerWeapon(v10[88], v14);
    if ( v11 )
    {
      *(_BYTE *)(v10[88] + 1350) = *(_BYTE *)(v10[88] + 1349);
      result = v10[88];
      *(_BYTE *)(result + 1349) = 0;
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 180F4: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 189F4: using guessed type _DWORD __cdecl BG_GetWeaponSlotNameForIndex(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0004838A) --------------------------------------------------------
int __cdecl sub_4838A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char *v4; // eax
  char v5; // al
  int v6; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v12; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a1];
    if ( !v7[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_47F83((int)v7) )
    return Scr_AddInt(0);
  v12 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v12);
  v11 = BG_GetWeaponSlotForName(v4);
  if ( !v11 )
  {
    v5 = SL_ConvertToString(v12);
    v6 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v5);
    Scr_ParamError(0, v6);
  }
  v10 = *(char *)(v11 + v7[88] + 1348);
  if ( !*(_BYTE *)(v11 + v7[88] + 1348) )
    return Scr_AddInt(0);
  if ( BG_WeaponIsClipOnly(v10) )
  {
    v8 = BG_ClipForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v7[88] + 4 * v8 + 820));
  }
  else
  {
    v9 = BG_AmmoForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v7[88] + 4 * v9 + 308));
  }
  return result;
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0004851A) --------------------------------------------------------
int __cdecl sub_4851A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v13; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a1];
    if ( !v7[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v13 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v13);
  v12 = BG_GetWeaponSlotForName(v3);
  if ( !v12 )
  {
    v4 = SL_ConvertToString(v13);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v10 = Scr_GetInt(1);
  result = *(char *)(v12 + v7[88] + 1348);
  v11 = result;
  if ( *(_BYTE *)(v12 + v7[88] + 1348) )
  {
    if ( BG_WeaponIsClipOnly(result) )
    {
      result = BG_ClipForWeapon(v11);
      v8 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > BG_GetAmmoClipSize(result) )
            v10 = BG_GetAmmoClipSize(v8);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(v7[88] + 4 * v8 + 820) = v10;
      }
    }
    else
    {
      result = BG_AmmoForWeapon(v11);
      v9 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > BG_GetAmmoTypeMax(result) )
            v10 = BG_GetAmmoTypeMax(v9);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(v7[88] + 4 * v9 + 308) = v10;
      }
    }
  }
  return result;
}
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (000486F3) --------------------------------------------------------
int __cdecl sub_486F3(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a1];
    if ( !v7[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_47F83((int)v7) )
    goto LABEL_11;
  v10 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v10);
  v9 = BG_GetWeaponSlotForName(v3);
  if ( !v9 )
  {
    v4 = SL_ConvertToString(v10);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  if ( *(_BYTE *)(v9 + v7[88] + 1348) && (v8 = BG_ClipForWeapon(*(char *)(v9 + v7[88] + 1348))) != 0 )
    result = Scr_AddInt(*(_DWORD *)(v7[88] + 4 * v8 + 820));
  else
LABEL_11:
    result = Scr_AddInt(0);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0004885D) --------------------------------------------------------
int __cdecl sub_4885D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v11; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a1];
    if ( !v7[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v11 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v11);
  v10 = BG_GetWeaponSlotForName(v3);
  if ( !v10 )
  {
    v4 = SL_ConvertToString(v11);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v9 = Scr_GetInt(1);
  if ( !*(_BYTE *)(v10 + v7[88] + 1348) )
    return Scr_AddInt(0);
  result = BG_ClipForWeapon(*(char *)(v10 + v7[88] + 1348));
  v8 = result;
  if ( result )
  {
    if ( v9 < 0 )
      v9 = 0;
    if ( v9 > BG_GetAmmoClipSize(result) )
      v9 = BG_GetAmmoClipSize(v8);
    result = v9;
    *(_DWORD *)(v7[88] + 4 * v8 + 820) = v9;
  }
  return result;
}
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000489D0) --------------------------------------------------------
int __cdecl sub_489D0(int a1)
{
  return Scr_MakeGameMessage(a1, (char)L"fg");
}
// 197E4: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);
// 9E35C: using guessed type __int16 aFg[3];

//----- (000489FD) --------------------------------------------------------
int __cdecl sub_489FD(int a1)
{
  return Scr_MakeGameMessage(a1, (char)L"g");
}
// 197E4: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);
// 9E35C: using guessed type __int16 aFg[3];

//----- (00048A2A) --------------------------------------------------------
int __cdecl sub_48A2A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  char v5[16]; // [esp+20h] [ebp-28h] BYREF
  char v6[24]; // [esp+30h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v6);
  Scr_GetVector(1, v5);
  return ClientSpawn(v4, v6, v5);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18E04: using guessed type _DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD);

//----- (00048AEF) --------------------------------------------------------
int __cdecl sub_48AEF(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int result; // eax
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v5[88];
  result = Scr_GetInt(0);
  *(_DWORD *)(v3 + 17804) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00048B92) --------------------------------------------------------
int __cdecl sub_48B92(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) &= 0xFFFFFBFF;
  return result;
}

//----- (00048BA9) --------------------------------------------------------
int __cdecl sub_48BA9(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5 = (_DWORD *)v4[88];
  v6 = G_SpawnPlayerClone();
  *(_DWORD *)(v6 + 148) = v5[53];
  *(_DWORD *)(v6 + 8) = v5[33] & 0xFFEFFFF7 | *(_DWORD *)(v6 + 8) & 8 | 0x400;
  G_SetOrigin(v6, v4 + 79);
  G_SetAngle(v6, v4 + 82);
  *(float *)(v6 + 324) = *(float *)(v6 + 324) + 1.0;
  *(float *)(v6 + 32) = *(float *)(v6 + 32) + 1.0;
  *(_DWORD *)(v6 + 12) = 5;
  *(_DWORD *)(v6 + 16) = level[123];
  *(_DWORD *)(v6 + 36) = v5[8];
  *(_DWORD *)(v6 + 40) = v5[9];
  *(_DWORD *)(v6 + 44) = v5[10];
  *(_DWORD *)(v6 + 4) = 2;
  *(_DWORD *)(v6 + 288) = 0x4000000;
  *(_BYTE *)(v6 + 365) = 1;
  *(_DWORD *)(v6 + 124) = 1023;
  *(_DWORD *)(v6 + 248) = 512;
  *(_DWORD *)(v6 + 264) = v4[66];
  *(_DWORD *)(v6 + 268) = v4[67];
  *(_DWORD *)(v6 + 272) = v4[68];
  *(_DWORD *)(v6 + 276) = v4[69];
  *(_DWORD *)(v6 + 280) = v4[70];
  *(_DWORD *)(v6 + 284) = v4[71];
  *(_DWORD *)(v6 + 292) = v4[73];
  *(_DWORD *)(v6 + 296) = v4[74];
  *(_DWORD *)(v6 + 300) = v4[75];
  *(_DWORD *)(v6 + 304) = v4[76];
  *(_DWORD *)(v6 + 308) = v4[77];
  *(_DWORD *)(v6 + 312) = v4[78];
  *(_DWORD *)(v6 + 208) = v5[29];
  *(_DWORD *)(v6 + 212) = v5[31];
  *(_DWORD *)(v6 + 416) = 65537;
  trap_LinkEntity(v6);
  *(_DWORD *)(v6 + 524) = level[123] + 250;
  *(_DWORD *)(v6 + 528) = sub_48B92;
  return GScr_AddEntity(v6);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18604: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 18D74: using guessed type int G_SpawnPlayerClone(void);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);
// 9E35C: using guessed type __int16 aFg[3];

//----- (00048E90) --------------------------------------------------------
int __cdecl sub_48E90(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char v5[1024]; // [esp+20h] [ebp-828h] BYREF
  char v6[1032]; // [esp+420h] [ebp-428h] BYREF
  char *v7; // [esp+828h] [ebp-20h]
  char *s; // [esp+82Ch] [ebp-1Ch]
  char v9[4]; // [esp+830h] [ebp-18h]
  int v10; // [esp+834h] [ebp-14h]
  size_t v11; // [esp+838h] [ebp-10h]
  int v12; // [esp+83Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  *(_DWORD *)v9 = Scr_GetString(0);
  v10 = Scr_GetType(1);
  if ( v10 == 2 )
  {
    Scr_ConstructMessageString(1, v6, 1024, 4);
    s = v6;
  }
  else
  {
    s = (char *)Scr_GetString(1);
  }
  v11 = strlen(s);
  v7 = v5;
  memset(v5, 0, sizeof(v5));
  v12 = 0;
  while ( v12 <= 0x1FFF && s[v12] )
  {
    *v7 = Q_CleanCharacter(s[v12]);
    if ( *v7 == 34 )
      *v7 = 39;
    ++v12;
    ++v7;
  }
  v3 = va("v %s \"%s\"", v9[0]);
  return trap_SendServerCommand(a1, 1, v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17164: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00049043) --------------------------------------------------------
int __cdecl sub_49043(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int result; // eax
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v5[88];
  result = Scr_GetBool(0);
  *(_DWORD *)(v3 + 17956) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);

//----- (000490E6) --------------------------------------------------------
int __cdecl sub_490E6(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = *(_DWORD *)(v4[88] + 12) | 0x400000;
  *(_DWORD *)(v4[88] + 12) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00049189) --------------------------------------------------------
unsigned int __cdecl sub_49189(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = *(_DWORD *)(v4[88] + 12) & 0xFFBFFFFF;
  *(_DWORD *)(v4[88] + 12) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0004922C) --------------------------------------------------------
int __cdecl sub_4922C(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned int v5; // [esp+20h] [ebp-18h]
  char v6; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  v5 = Scr_GetNumParam();
  if ( v5 == 2 )
    goto LABEL_11;
  if ( v5 <= 2 )
  {
    if ( v5 != 1 )
      return Scr_Error(
               "USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
               "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
LABEL_12:
    v6 = Scr_GetString(0);
    v3 = va("r \"%s\" %g %g", v6);
    return trap_SendServerCommand(a1, 1, v3);
  }
  if ( v5 == 3 )
  {
    Scr_GetFloat(2);
LABEL_11:
    Scr_GetFloat(1);
    goto LABEL_12;
  }
  return Scr_Error(
           "USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
           "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0004935B) --------------------------------------------------------
int __cdecl sub_4935B(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[211 * a1];
    if ( !v6[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v6[88];
  v4 = Scr_GetEntity(0);
  return Scr_AddInt(*(_DWORD *)(v3 + 18104) == v4);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0004940C) --------------------------------------------------------
int __cdecl sub_4940C(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  char *s2; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  s2 = (char *)Scr_GetString(0);
  v3 = G_SoundAliasIndex(s2);
  v4 = va("s %i", v3);
  return trap_SendServerCommand(a1, 0, v4);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000494D8) --------------------------------------------------------
int __cdecl sub_494D8(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  char *s2; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  s2 = (char *)Scr_GetString(0);
  v3 = G_SoundAliasIndex(s2);
  v4 = va("S %i", v3);
  return trap_SendServerCommand(a1, 0, v4);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000495A4) --------------------------------------------------------
int __cdecl sub_495A4(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 0, &src);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004968F) --------------------------------------------------------
int __cdecl sub_4968F(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 1, &src);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004977A) --------------------------------------------------------
int __cdecl sub_4977A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 3, &src);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00049865) --------------------------------------------------------
int __cdecl sub_49865(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int result; // eax
  _DWORD *v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 v7; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetConstString(0);
  v6 = 0;
  if ( v7 == scr_const[4] )
  {
    v6 = 2;
  }
  else if ( v7 == scr_const[2] )
  {
    v6 = 4;
  }
  else if ( v7 == scr_const[146] )
  {
    v6 = 1;
  }
  else if ( v7 == scr_const[150] )
  {
    v6 = 16;
  }
  else
  {
    Scr_ParamError(0, "team must be \"axis\", \"allies\", \"none\", or \"freelook\"");
  }
  if ( Scr_GetBool(1) )
  {
    v3 = v5[88];
    result = *(_DWORD *)(v3 + 17836) & ~v6;
  }
  else
  {
    v3 = v5[88];
    result = *(_DWORD *)(v3 + 17836) | v6;
  }
  *(_DWORD *)(v3 + 17836) = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000499DD) --------------------------------------------------------
int __cdecl sub_499DD(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self getGuid()\n");
  v3 = trap_GetGuid(a1);
  return Scr_AddInt(v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00049A8D) --------------------------------------------------------
int __cdecl sub_49A8D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( !v4[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self getFatigue()\n");
  return Scr_AddFloat(*(_DWORD *)(v4[88] + 1456));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00049B41) --------------------------------------------------------
int __cdecl sub_49B41(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( !v5[88] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( Scr_GetNumParam() != 1 )
    Scr_Error("USAGE: self setFatigue([0.0,1.0])\n");
  v6 = Scr_GetFloat(0);
  if ( v6 >= 0.0 )
  {
    if ( v6 <= 1.0 )
      v4 = v6;
    else
      v4 = 1.0;
  }
  else
  {
    v4 = 0.0;
  }
  result = v5[88];
  *(float *)(result + 1456) = v4;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00049C48) --------------------------------------------------------
int __cdecl sub_49C48(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoDemoStart()\n");
  result = trap_Cvar_VariableIntegerValue("g_autodemo");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "C");
    result = Scr_AddInt(1);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19404: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00049D22) --------------------------------------------------------
int __cdecl sub_49D22(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoDemoStop()\n");
  result = trap_Cvar_VariableIntegerValue("g_autodemo");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "D");
    result = Scr_AddInt(1);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19404: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00049DFC) --------------------------------------------------------
int __cdecl sub_49DFC(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[211 * a1 + 88] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoScreenshot()\n");
  result = trap_Cvar_VariableIntegerValue("g_autoscreenshot");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "E");
    result = Scr_AddInt(1);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19404: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00049ED6) --------------------------------------------------------
int __cdecl Player_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0x3B; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_ACC80 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_ACC80 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_ACC84 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// ACC80: using guessed type char *off_ACC80;
// ACC84: using guessed type int (__cdecl *off_ACC84)(char);

//----- (00049F51) --------------------------------------------------------
void sub_49F51()
{
  ;
}

//----- (00049F58) --------------------------------------------------------
int __cdecl DeathmatchScoreboardMessage(int a1)
{
  int v1; // eax
  int v3; // [esp+24h] [ebp-9A4h]
  int v4; // [esp+2Ch] [ebp-99Ch]
  size_t v5; // [esp+34h] [ebp-994h]
  int i; // [esp+38h] [ebp-990h]
  int v7; // [esp+3Ch] [ebp-98Ch]
  char v8[1408]; // [esp+40h] [ebp-988h] BYREF
  char s[1032]; // [esp+5C0h] [ebp-408h] BYREF

  v8[0] = 0;
  v7 = 0;
  v4 = level[134];
  if ( v4 > 64 )
    v4 = 64;
  for ( i = 0; i < v4; ++i )
  {
    v3 = level[i + 135];
    if ( *(_DWORD *)(level[0] + 18228 * v3 + 17696) != 1 )
      trap_GetClientPing(v3);
    Com_sprintf(s, 0x400u, " %i %i %i %i %i", level[i + 135]);
    v5 = strlen(s);
    if ( (int)(v7 + v5) > 1024 )
      break;
    strcpy(&v8[v7], s);
    v7 += v5;
  }
  v1 = va("b %i %i %i%s", i);
  return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, v1);
}
// 172A4: using guessed type _DWORD __cdecl trap_GetClientPing(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004A172) --------------------------------------------------------
int __cdecl Cmd_Score_f(int a1)
{
  return DeathmatchScoreboardMessage(a1);
}
// 19164: using guessed type _DWORD __cdecl DeathmatchScoreboardMessage(_DWORD);

//----- (0004A195) --------------------------------------------------------
int __cdecl CheatsOk(int a1)
{
  int v1; // eax
  int v2; // eax
  char v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+10h] [ebp-8h]

  if ( g_cheats[3] )
  {
    if ( *(int *)(a1 + 576) > 0 )
    {
      v5 = 1;
    }
    else
    {
      v2 = va("e \"GAME_MUSTBEALIVECOMMAND\"", v4);
      trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
      v5 = 0;
    }
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"", v4);
    trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v1);
    v5 = 0;
  }
  return v5;
}
// 4A1BC: variable 'v4' is possibly undefined
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004A24D) --------------------------------------------------------
_BYTE *__cdecl ConcatArgs(int a1)
{
  char s[1024]; // [esp+10h] [ebp-418h] BYREF
  int v3; // [esp+410h] [ebp-18h]
  size_t n; // [esp+414h] [ebp-14h]
  int v5; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  v3 = 0;
  v5 = trap_Argc();
  for ( i = a1; i < v5; ++i )
  {
    trap_Argv(i, s, 1024);
    n = strlen(s);
    if ( (int)(v3 + n) > 1022 )
      break;
    memcpy(&byte_D0F00[v3], s, n);
    v3 += n;
    if ( i != v5 - 1 )
      byte_D0F00[v3++] = 32;
  }
  byte_D0F00[v3] = 0;
  return byte_D0F00;
}
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);

//----- (0004A32C) --------------------------------------------------------
_BYTE *__cdecl SanitizeString(char *a1, _BYTE *a2)
{
  _BYTE *v2; // esi
  _BYTE *result; // eax
  int v4; // [esp+0h] [ebp-18h]

  while ( *a1 )
  {
    if ( *a1 == 27 )
    {
      a1 += 2;
    }
    else if ( *a1 > 31 )
    {
      v2 = a2;
      v4 = *a1++;
      ++a2;
      *v2 = tolower(v4);
    }
    else
    {
      ++a1;
    }
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (0004A391) --------------------------------------------------------
int __cdecl ClientNumberFromString(int a1, char *nptr)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // [esp+1Ch] [ebp-81Ch]
  char s1[1024]; // [esp+20h] [ebp-818h] BYREF
  char s2[1032]; // [esp+420h] [ebp-418h] BYREF
  char v9[4]; // [esp+828h] [ebp-10h]
  int v10; // [esp+82Ch] [ebp-Ch]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    SanitizeString(nptr, s2);
    *(_DWORD *)v9 = 0;
    v10 = level[0];
    while ( *(int *)v9 < level[121] )
    {
      if ( *(_DWORD *)(v10 + 17696) == 2 )
      {
        SanitizeString(v10 + 17908, s1);
        if ( !strcmp(s1, s2) )
          return *(_DWORD *)v9;
      }
      ++*(_DWORD *)v9;
      v10 += 18228;
    }
    v4 = va(aEGameUsernoton, (char)nptr);
    trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v4);
    v6 = -1;
  }
  else
  {
    *(_DWORD *)v9 = atoi(nptr);
    if ( *(int *)v9 >= 0 && *(int *)v9 < level[121] )
    {
      if ( *(_DWORD *)(level[0] + 18228 * *(_DWORD *)v9 + 17696) == 2 )
      {
        v6 = *(_DWORD *)v9;
      }
      else
      {
        v3 = va(aEGameClientnot_0, v9[0]);
        trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v3);
        v6 = -1;
      }
    }
    else
    {
      v2 = va(aEGameBadclient, v9[0]);
      trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
      v6 = -1;
    }
  }
  return v6;
}
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 185E4: using guessed type _DWORD __cdecl SanitizeString(_DWORD, _DWORD);

//----- (0004A59A) --------------------------------------------------------
void __cdecl G_setfog(char *s)
{
  char v1; // [esp+3Ch] [ebp-2Ch] BYREF
  char v2; // [esp+40h] [ebp-28h] BYREF
  char v3; // [esp+44h] [ebp-24h] BYREF
  char v4; // [esp+48h] [ebp-20h] BYREF
  float v5; // [esp+54h] [ebp-14h] BYREF
  float v6; // [esp+58h] [ebp-10h] BYREF
  float v7; // [esp+5Ch] [ebp-Ch] BYREF

  trap_SetConfigstring(13, s);
  level[2177] = 2139095039;
  level[2178] = 2139095039;
  if ( sscanf(s, "%f %f %f %f %f %f %f", &v7, &v6, &v5, &v2, &v3, &v4, &v1) == 7 && v5 >= 1.0 )
  {
    *(float *)&level[2177] = v6 - v7 + v7;
    *(float *)&level[2178] = *(float *)&level[2177] * *(float *)&level[2177];
  }
}
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (0004A683) --------------------------------------------------------
int Cmd_Fogswitch_f()
{
  char *v0; // eax

  v0 = (char *)ConcatArgs(1);
  return G_setfog(v0);
}
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (0004A6AF) --------------------------------------------------------
_DWORD *__cdecl Cmd_Give_f(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+18h] [ebp-20h]
  _DWORD *s; // [esp+1Ch] [ebp-1Ch]
  _BOOL4 v4; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int j; // [esp+24h] [ebp-14h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v8; // [esp+28h] [ebp-10h]
  char *nptr; // [esp+2Ch] [ebp-Ch]
  _DWORD *v10; // [esp+30h] [ebp-8h]

  result = (_DWORD *)CheatsOk(a1);
  if ( result )
  {
    nptr = (char *)ConcatArgs(2);
    v2 = atoi(nptr);
    result = (_DWORD *)ConcatArgs(1);
    v10 = result;
    if ( result )
    {
      if ( *(_BYTE *)result )
      {
        if ( !(v4 = Q_stricmp(result, &unk_9E960) == 0) && Q_stricmpn(v10, "health", 6)
          || (!v2 ? (result = *(_DWORD **)(a1[88] + 292)) : (result = (_DWORD *)(a1[144] + v2)), a1[144] = result, v4) )
        {
          if ( !v4 && Q_stricmp(v10, "weapons") )
            goto LABEL_41;
          level[8] = 1;
          for ( i = 1; i <= BG_GetNumWeapons(); BG_GivePlayerWeapon(a1[88], i++) )
            ;
          result = level;
          level[8] = 0;
          if ( v4 )
          {
LABEL_41:
            if ( !v4 && Q_stricmpn(v10, "ammo", 4) )
              goto LABEL_27;
            if ( v2 )
            {
              result = (_DWORD *)a1[88];
              if ( result[54] )
                result = (_DWORD *)Add_Ammo(a1, *(_DWORD *)(a1[88] + 216), v2, 1);
            }
            else
            {
              for ( j = 1; ; ++j )
              {
                result = (_DWORD *)BG_GetNumWeapons();
                if ( j > (int)result )
                  break;
                if ( Com_BitCheck(a1[88] + 1332, j) )
                  Add_Ammo(a1, j, 998, 1);
              }
            }
            if ( v4 )
            {
LABEL_27:
              result = (_DWORD *)Q_stricmpn(v10, "allammo", 7);
              if ( result )
                goto LABEL_40;
              if ( !v2 )
                goto LABEL_40;
              for ( k = 1; ; Add_Ammo(a1, k++, v2, 1) )
              {
                result = (_DWORD *)BG_GetNumWeapons();
                if ( k > (int)result )
                  break;
              }
              if ( v4 )
              {
LABEL_40:
                if ( !v4 )
                {
                  result = (_DWORD *)BG_FindItem(v10);
                  v8 = result;
                  if ( result )
                  {
                    level[8] = 1;
                    s = (_DWORD *)G_Spawn();
                    s[79] = a1[79];
                    s[80] = a1[80];
                    s[81] = a1[81];
                    G_SetConstString(s + 97, *v8);
                    G_SpawnItem(s, v8);
                    *((_BYTE *)s + 382) = 1;
                    Touch_Item(s, a1, 2);
                    *((_BYTE *)s + 382) = 0;
                    if ( *((_BYTE *)s + 364) )
                      G_FreeEntity(s);
                    result = level;
                    level[8] = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 167A4: using guessed type int G_Spawn(void);
// 172F4: using guessed type _DWORD __cdecl G_SetConstString(_DWORD, _DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17404: using guessed type _DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17564: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 17894: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 180F4: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 18A94: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0004AA5A) --------------------------------------------------------
int __cdecl Cmd_Take_f(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // esi
  int v10; // esi
  int v11; // esi
  int v12; // esi
  int v13; // esi
  int v14; // eax
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // [esp+18h] [ebp-30h]
  int v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+20h] [ebp-28h]
  int v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]
  _BOOL4 v25; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int v27; // [esp+30h] [ebp-18h]
  int j; // [esp+30h] [ebp-18h]
  int k; // [esp+30h] [ebp-18h]
  char *nptr; // [esp+34h] [ebp-14h]
  int v31; // [esp+38h] [ebp-10h]

  result = CheatsOk(a1);
  if ( result )
  {
    nptr = (char *)ConcatArgs(2);
    v24 = atoi(nptr);
    result = ConcatArgs(1);
    v31 = result;
    if ( result )
    {
      if ( *(_BYTE *)result )
      {
        v25 = Q_stricmp(result, &unk_9E960) == 0;
        if ( !v25 )
        {
          if ( Q_stricmpn(v31, "health", 6) )
            goto LABEL_18;
        }
        if ( v24 )
        {
          *(_DWORD *)(a1 + 576) -= v24;
          result = a1;
          if ( *(int *)(a1 + 576) <= 0 )
          {
            result = a1;
            *(_DWORD *)(a1 + 576) = 1;
          }
        }
        else
        {
          result = a1;
          *(_DWORD *)(a1 + 576) = 1;
        }
        if ( v25 )
        {
LABEL_18:
          if ( !v25 && Q_stricmp(v31, "weapons") )
            goto LABEL_29;
          for ( i = 1; i <= BG_GetNumWeapons(); ++i )
          {
            BG_TakePlayerWeapon(*(_DWORD *)(a1 + 352), i);
            v2 = *(_DWORD *)(a1 + 352);
            *(_DWORD *)(v2 + 4 * BG_AmmoForWeapon(i) + 308) = 0;
            v3 = *(_DWORD *)(a1 + 352);
            *(_DWORD *)(v3 + 4 * BG_ClipForWeapon(i) + 820) = 0;
          }
          result = *(_DWORD *)(a1 + 352);
          if ( *(_DWORD *)(result + 216) )
          {
            *(_DWORD *)(*(_DWORD *)(a1 + 352) + 216) = 0;
            result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, &off_9E980);
          }
          if ( v25 )
          {
LABEL_29:
            if ( !v25 && Q_stricmpn(v31, "ammo", 4) )
              goto LABEL_30;
            if ( v24 )
            {
              result = *(_DWORD *)(a1 + 352);
              if ( *(_DWORD *)(result + 216) )
              {
                v27 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 216);
                v4 = *(_DWORD *)(a1 + 352);
                v5 = BG_AmmoForWeapon(v27);
                *(_DWORD *)(v4 + 4 * v5 + 308) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v5 + 308) - v24;
                v6 = *(_DWORD *)(a1 + 352);
                result = BG_AmmoForWeapon(v27);
                if ( *(int *)(v6 + 4 * result + 308) < 0 )
                {
                  v23 = *(_DWORD *)(a1 + 352);
                  v7 = BG_ClipForWeapon(v27);
                  v22 = *(_DWORD *)(a1 + 352);
                  *(_DWORD *)(v23 + 4 * v7 + 820) = *(_DWORD *)(v22 + 4 * v7 + 820)
                                                  + *(_DWORD *)(v22 + 4 * BG_AmmoForWeapon(v27) + 308);
                  v8 = *(_DWORD *)(a1 + 352);
                  *(_DWORD *)(v8 + 4 * BG_AmmoForWeapon(v27) + 308) = 0;
                  v9 = *(_DWORD *)(a1 + 352);
                  result = BG_ClipForWeapon(v27);
                  if ( *(int *)(v9 + 4 * result + 820) < 0 )
                  {
                    v10 = *(_DWORD *)(a1 + 352);
                    result = BG_ClipForWeapon(v27);
                    *(_DWORD *)(v10 + 4 * result + 820) = 0;
                  }
                }
              }
            }
            else
            {
              for ( j = 1; ; *(_DWORD *)(v12 + 4 * BG_ClipForWeapon(j++) + 820) = 0 )
              {
                result = BG_GetNumWeapons();
                if ( j > result )
                  break;
                v11 = *(_DWORD *)(a1 + 352);
                *(_DWORD *)(v11 + 4 * BG_AmmoForWeapon(j) + 308) = 0;
                v12 = *(_DWORD *)(a1 + 352);
              }
            }
            if ( v25 )
            {
LABEL_30:
              result = Q_stricmpn(v31, "allammo", 7);
              if ( !result && v24 )
              {
                for ( k = 1; ; ++k )
                {
                  result = BG_GetNumWeapons();
                  if ( k > result )
                    break;
                  v13 = *(_DWORD *)(a1 + 352);
                  v14 = BG_AmmoForWeapon(k);
                  *(_DWORD *)(v13 + 4 * v14 + 308) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) - v24;
                  v15 = *(_DWORD *)(a1 + 352);
                  if ( *(int *)(v15 + 4 * BG_AmmoForWeapon(k) + 308) < 0 )
                  {
                    v21 = *(_DWORD *)(a1 + 352);
                    v16 = BG_ClipForWeapon(k);
                    v20 = *(_DWORD *)(a1 + 352);
                    *(_DWORD *)(v21 + 4 * v16 + 820) = *(_DWORD *)(v20 + 4 * v16 + 820)
                                                     + *(_DWORD *)(v20 + 4 * BG_AmmoForWeapon(k) + 308);
                    v17 = *(_DWORD *)(a1 + 352);
                    *(_DWORD *)(v17 + 4 * BG_AmmoForWeapon(k) + 308) = 0;
                    v18 = *(_DWORD *)(a1 + 352);
                    if ( *(int *)(v18 + 4 * BG_ClipForWeapon(k) + 820) < 0 )
                    {
                      v19 = *(_DWORD *)(a1 + 352);
                      *(_DWORD *)(v19 + 4 * BG_ClipForWeapon(k) + 820) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 18A94: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 9E980: using guessed type void *off_9E980;

//----- (0004AF77) --------------------------------------------------------
int __cdecl Cmd_God_f(int a1)
{
  int result; // eax
  int v2; // eax

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 396) ^= 1u;
    if ( (*(_DWORD *)(a1 + 396) & 1) != 0 )
      v2 = va("e \"%s\"", (unsigned __int8)&aGameGodmodeon[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v2 = va("e \"%s\"", (unsigned __int8)&aGameGodmodeoff[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0004B016) --------------------------------------------------------
int __cdecl Cmd_Notarget_f(int a1)
{
  int result; // eax
  int v2; // eax

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 396) ^= 2u;
    if ( (*(_DWORD *)(a1 + 396) & 2) != 0 )
      v2 = va("e \"%s\"", (unsigned __int8)&aGameNotargeton[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v2 = va("e \"%s\"", (unsigned __int8)&aGameNotargetof[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0004B0B5) --------------------------------------------------------
int __cdecl Cmd_Noclip_f(int a1)
{
  int result; // eax
  int v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17948) )
      v3 = "GAME_NOCLIPOFF";
    else
      v3 = "GAME_NOCLIPON";
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17948) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17948) == 0;
    v2 = va("e \"%s\"", (char)v3);
    result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004B169) --------------------------------------------------------
int __cdecl Cmd_UFO_f(int a1)
{
  int result; // eax
  int v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17952) )
      v3 = "GAME_UFOOFF";
    else
      v3 = "GAME_UFOON";
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17952) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17952) == 0;
    v2 = va("e \"%s\"", (char)v3);
    result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 17E64: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004B21D) --------------------------------------------------------
int __cdecl Cmd_Kill_f(_DWORD *a1)
{
  int result; // eax
  int v2; // edx

  result = a1[88];
  if ( !*(_DWORD *)(result + 17668) )
  {
    a1[99] &= 0xFFFFFFFE;
    v2 = a1[88];
    a1[144] = 0;
    *(_DWORD *)(v2 + 284) = 0;
    result = player_die(a1, a1, a1, 100000, 21, 0, 0, 0);
  }
  return result;
}
// 17964: using guessed type _DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004B2BF) --------------------------------------------------------
int __cdecl StopFollowing(int a1)
{
  int result; // eax
  char v2[4]; // [esp+20h] [ebp-B8h] BYREF
  float v3; // [esp+24h] [ebp-B4h]
  float v4; // [esp+28h] [ebp-B0h]
  float v5; // [esp+2Ch] [ebp-ACh]
  int v6[4]; // [esp+50h] [ebp-88h] BYREF
  int v7[4]; // [esp+60h] [ebp-78h] BYREF
  float v8; // [esp+70h] [ebp-68h] BYREF
  float v9; // [esp+74h] [ebp-64h]
  float v10; // [esp+78h] [ebp-60h]
  float v11[4]; // [esp+80h] [ebp-58h] BYREF
  float v12[4]; // [esp+90h] [ebp-48h] BYREF
  float v13; // [esp+A0h] [ebp-38h] BYREF
  float v14; // [esp+A4h] [ebp-34h]
  float v15; // [esp+A8h] [ebp-30h]
  int v16[7]; // [esp+B0h] [ebp-28h] BYREF
  int v17; // [esp+CCh] [ebp-Ch]

  v17 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v17 + 17672) = -1;
  *(_DWORD *)(v17 + 17944) = -1;
  result = *(_DWORD *)(v17 + 12) & 0x40000;
  if ( result )
  {
    v16[0] = *(_DWORD *)(v17 + 232);
    v16[1] = *(_DWORD *)(v17 + 236);
    v16[2] = *(_DWORD *)(v17 + 240);
    AngleVectors(v16, v12, 0, v11);
    *(float *)v16 = *(float *)v16 + 15.0;
    v13 = *(float *)(v17 + 20);
    v14 = *(float *)(v17 + 24);
    v15 = *(float *)(v17 + 28);
    v15 = v15 + *(float *)(v17 + 248);
    G_AddLean(a1, &v13);
    v8 = v12[0] * -40.0 + v13;
    v9 = v12[1] * -40.0 + v14;
    v10 = v12[2] * -40.0 + v15;
    v8 = v11[0] * 10.0 + v8;
    v9 = v11[1] * 10.0 + v9;
    v10 = v11[2] * 10.0 + v10;
    v7[0] = -1056964608;
    v7[1] = -1056964608;
    v7[2] = -1056964608;
    v6[0] = 1090519040;
    v6[1] = 1090519040;
    v6[2] = 1090519040;
    trap_TraceCapsule(v2, &v13, v7, v6, &v8, 1023, 8454161);
    v13 = v3;
    v14 = v4;
    v15 = v5;
    *(_DWORD *)(v17 + 212) = 1852331867 * ((a1 - (int)g_entities) >> 2);
    *(_DWORD *)(v17 + 132) &= 0xFFFF9FFF;
    *(_DWORD *)(v17 + 132) &= 0xFFEFFFFF;
    *(_DWORD *)(v17 + 1464) = 0;
    *(_DWORD *)(v17 + 1468) = 1023;
    *(_DWORD *)(v17 + 12) &= 0xFFFBFFDF;
    *(_DWORD *)(v17 + 224) = 0;
    G_SetOrigin(a1, &v13);
    *(float *)(v17 + 20) = v13;
    *(float *)(v17 + 24) = v14;
    *(float *)(v17 + 28) = v15;
    SetClientViewAngle(a1, v16);
    *(_DWORD *)(v17 + 1580) = 0;
    *(_DWORD *)(v17 + 1584) = 0;
    result = v17;
    *(_DWORD *)(v17 + 1588) = 0;
  }
  return result;
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 18274: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004B589) --------------------------------------------------------
int __cdecl Cmd_FollowCycle_f(int a1, int a2)
{
  char v4[96]; // [esp+20h] [ebp-4588h] BYREF
  char v5[17688]; // [esp+80h] [ebp-4528h] BYREF
  int v6; // [esp+4598h] [ebp-10h]
  int v7; // [esp+459Ch] [ebp-Ch]

  if ( a2 != 1 && a2 != -1 )
    G_Error("Cmd_FollowCycle_f: bad dir %i", a2);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) != 2 )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 352) + 17672) >= 0 )
    return 0;
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17944);
  if ( v7 < 0 )
    v7 = 0;
  v6 = v7;
  do
  {
    v7 += a2;
    if ( v7 >= level[121] )
      v7 = 0;
    if ( v7 < 0 )
      v7 = level[121] - 1;
    if ( trap_GetArchivedClientInfo(v7, *(_DWORD *)(a1 + 352) + 17680, v5, v4)
      && G_ClientCanSpectateTeam(*(_DWORD *)(a1 + 352), v4[4]) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17944) = v7;
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) = 2;
      return 1;
    }
  }
  while ( v7 != v6 );
  return 0;
}
// 17764: using guessed type _DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B74: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);

//----- (0004B70A) --------------------------------------------------------
int __cdecl Cmd_Killcam_f(int a1)
{
  int v1; // eax
  int v3; // [esp+1Ch] [ebp-4Ch]
  int v4; // [esp+1Ch] [ebp-4Ch]
  char nptr[72]; // [esp+20h] [ebp-48h] BYREF

  trap_Argv(1, nptr, 64);
  v3 = atoi(nptr);
  if ( v3 <= 0 )
    v3 = 20;
  v4 = 1000 * v3;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17672) = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17944) = *(_DWORD *)(a1 + 148);
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17680) = v4;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) = 2;
  v1 = va("C %i", v4);
  trap_SendServerCommand(*(_DWORD *)(a1 + 148), 0, v1);
  return 1;
}
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004B7F0) --------------------------------------------------------
_BOOL4 __cdecl G_IsPlaying(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) == 0;
}

//----- (0004B80B) --------------------------------------------------------
void __cdecl sub_4B80B(int a1, int a2, int a3)
{
  int v3; // eax

  if ( a2
    && *(_BYTE *)(a2 + 364)
    && *(_DWORD *)(a2 + 352)
    && *(_DWORD *)(*(_DWORD *)(a2 + 352) + 17696) == 2
    && (a3 != 1 || OnSameTeam(a1, a2))
    && (a3 != 3 || InSameSquad(a1, a2))
    && (g_deadChat[3] || G_IsPlaying(a1) || !G_IsPlaying(a2)) )
  {
    if ( a3 == 1 )
      v3 = va(aS_3, (unsigned __int8)&aI[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v3 = va(aS_3, (unsigned __int8)&asc_9EA31[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 0, v3);
  }
}
// 17304: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);
// 179B4: using guessed type _DWORD __cdecl InSameSquad(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 182C4: using guessed type _DWORD __cdecl G_IsPlaying(_DWORD);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0004B949) --------------------------------------------------------
void __cdecl G_Say(int a1, int a2, int a3, char *src)
{
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // [esp+Ch] [ebp-23Ch]
  int v8; // [esp+40h] [ebp-208h]
  void *v9; // [esp+44h] [ebp-204h]
  char v10[64]; // [esp+50h] [ebp-1F8h] BYREF
  char v11[160]; // [esp+90h] [ebp-1B8h] BYREF
  char s[64]; // [esp+130h] [ebp-118h] BYREF
  char v13[128]; // [esp+170h] [ebp-D8h] BYREF
  char dest[68]; // [esp+1F0h] [ebp-58h] BYREF
  int v15; // [esp+234h] [ebp-14h]
  _DWORD *v16; // [esp+238h] [ebp-10h]
  int i; // [esp+23Ch] [ebp-Ch]

  if ( a3 != 1 || *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 1 || *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 2 )
  {
    if ( a3 == 3 && *(_WORD *)(*(_DWORD *)(a1 + 352) + 17844) != 1 && *(_WORD *)(*(_DWORD *)(a1 + 352) + 17844) != 2 )
      a3 = 1;
  }
  else
  {
    a3 = 0;
  }
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 352) + 17908), 64);
  Q_CleanStr(dest);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852);
  if ( v8 == 1 )
  {
    v9 = &unk_9EA45;
  }
  else if ( v8 == 2 )
  {
    v9 = &unk_9EA42;
  }
  else
  {
    v9 = &unk_9EA48;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 3 )
  {
    Com_sprintf(s, 0x40u, byte_9EA49, v7);
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) )
  {
    Com_sprintf(s, 0x40u, byte_9EA5D, (char)v9);
  }
  else
  {
    Com_sprintf(s, 0x40u, byte_9EA6E, (char)v9);
  }
  if ( a3 == 1 )
  {
    v5 = trap_GetGuid(*(_DWORD *)a1);
    G_LogPrintf("sayteam;%d;%d;%s;%s\n", v5);
    if ( Team_GetLocationMsg(a1, v10, 0x40u) )
      Com_sprintf(v13, 0x80u, aS_5, (char)s);
    else
      Com_sprintf(v13, 0x80u, aS_4, (char)s);
    v15 = 53;
  }
  else
  {
    if ( a3 <= 1 )
      goto LABEL_23;
    if ( a3 == 2 )
    {
      if ( a2
        && *(_DWORD *)(a2 + 352)
        && *(_DWORD *)(*(_DWORD *)(a2 + 352) + 17852) == *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852)
        && Team_GetLocationMsg(a1, v10, 0x40u) )
      {
        Com_sprintf(v13, 0x80u, "%s[%s]%s (%s): ", (char)s);
      }
      else
      {
        Com_sprintf(v13, 0x80u, "%s[%s]%s: ", (char)s);
      }
      v15 = 51;
      goto LABEL_39;
    }
    if ( a3 == 3 )
    {
      v6 = trap_GetGuid(*(_DWORD *)a1);
      G_LogPrintf("saysquad;%d;%d;%s;%s\n", v6);
      if ( Team_GetLocationMsg(a1, v10, 0x40u) )
        Com_sprintf(v13, 0x80u, aS_7, (char)s);
      else
        Com_sprintf(v13, 0x80u, aS_6, (char)s);
      v15 = 53;
    }
    else
    {
LABEL_23:
      v4 = trap_GetGuid(*(_DWORD *)a1);
      G_LogPrintf("say;%d;%d;%s;%s\n", v4);
      Com_sprintf(v13, 0x80u, "%s%s%s: ", (char)s);
      v15 = 55;
    }
  }
LABEL_39:
  Q_strncpyz(v11, src, 150);
  if ( a2 )
  {
    sub_4B80B(a1, a2, a3);
  }
  else
  {
    if ( g_dedicated[3] )
      G_Printf("%s%s\n", (char)v13);
    for ( i = 0; i < level[121]; ++i )
    {
      v16 = &g_entities[211 * i];
      sub_4B80B(a1, (int)v16, a3);
    }
  }
}
// 4BA9D: variable 'v7' is possibly undefined
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);

//----- (0004C037) --------------------------------------------------------
int __cdecl sub_4C037(int a1, int a2, int a3)
{
  int result; // eax
  char *src; // [esp+10h] [ebp-8h]

  result = trap_Argc();
  if ( result > 1 || a3 )
  {
    if ( a3 )
      src = (char *)ConcatArgs(0);
    else
      src = (char *)ConcatArgs(1);
    result = G_Say(a1, 0, a2, src);
  }
  return result;
}
// 180A4: using guessed type int trap_Argc(void);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (0004C0A8) --------------------------------------------------------
_DWORD *__cdecl sub_4C0A8(int *a1)
{
  _DWORD *result; // eax
  char v2; // al
  char v3[64]; // [esp+20h] [ebp-498h] BYREF
  char dest[64]; // [esp+60h] [ebp-458h] BYREF
  char nptr[1028]; // [esp+A0h] [ebp-418h] BYREF
  char *src; // [esp+4A4h] [ebp-14h]
  int v7; // [esp+4A8h] [ebp-10h]
  int v8; // [esp+4ACh] [ebp-Ch]

  result = (_DWORD *)trap_Argc();
  if ( (int)result > 1 )
  {
    trap_Argv(1, nptr, 1024);
    result = (_DWORD *)atoi(nptr);
    v8 = (int)result;
    if ( (int)result >= 0 )
    {
      result = (_DWORD *)v8;
      if ( v8 < level[121] )
      {
        result = &g_entities[211 * v8];
        v7 = (int)result;
        if ( result )
        {
          result = (_DWORD *)v7;
          if ( *(_BYTE *)(v7 + 364) )
          {
            result = (_DWORD *)v7;
            if ( *(_DWORD *)(v7 + 352) )
            {
              src = (char *)ConcatArgs(2);
              Q_strncpyz(dest, (char *)(a1[88] + 17908), 64);
              Q_CleanStr(dest);
              Q_strncpyz(v3, (char *)(*(_DWORD *)(v7 + 352) + 17908), 64);
              Q_CleanStr(v3);
              trap_GetGuid(*(_DWORD *)v7);
              v2 = trap_GetGuid(*a1);
              G_LogPrintf("tell;%d;%d;%s;%d;%d;%s;%s\n", v2);
              G_Say((int)a1, v7, 2, src);
              result = (_DWORD *)G_Say((int)a1, (int)a1, 2, src);
            }
          }
        }
      }
    }
  }
  return result;
}
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (0004C284) --------------------------------------------------------
int __cdecl sub_4C284(int a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = ConcatArgs(1);
  Scr_AddString(v2);
  return Scr_Notify(a1, scr_const[156], 1);
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (0004C431) --------------------------------------------------------
void G_Voice()
{
  ;
}

//----- (0004C436) --------------------------------------------------------
_DWORD *__cdecl Cmd_GameCommand_f(int a1)
{
  _DWORD *result; // eax
  char nptr[1032]; // [esp+10h] [ebp-418h] BYREF
  unsigned int v3; // [esp+418h] [ebp-10h]
  int v4; // [esp+41Ch] [ebp-Ch]

  result = (_DWORD *)trap_Argc();
  if ( (int)result > 1 )
  {
    trap_Argv(1, nptr, 1024);
    v4 = atoi(nptr);
    trap_Argv(2, nptr, 1024);
    result = (_DWORD *)atoi(nptr);
    v3 = (unsigned int)result;
    if ( v4 >= 0 )
    {
      result = (_DWORD *)v4;
      if ( v4 < level[121] && (v3 & 0x80000000) == 0 && v3 <= 6 )
      {
        result = &g_entities[211 * v4 + 88];
        if ( LOBYTE(g_entities[211 * v4 + 91]) )
        {
          G_Say(a1, (int)&g_entities[211 * v4], 2, *(char **)((char *)off_ACE60 + (_DWORD)&dword_0[v3]));
          result = (_DWORD *)G_Say(a1, a1, 2, *(char **)((char *)off_ACE60 + (_DWORD)&dword_0[v3]));
        }
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);
// ACE60: using guessed type char *off_ACE60[7];

//----- (0004C56E) --------------------------------------------------------
int __cdecl Cmd_Where_f(int a1)
{
  char v1; // al
  int v2; // eax

  v1 = vtos(a1 + 316);
  v2 = va(aE_0, v1);
  return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
}
// 177C4: using guessed type _DWORD __cdecl vtos(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004C5D0) --------------------------------------------------------
int __cdecl Cmd_CallVote_f(int a1)
{
  int result; // eax
  int v2; // eax
  char v3; // al
  char v4; // al
  char v5; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  char v12; // [esp+Ch] [ebp-5BCh]
  char v13; // [esp+Ch] [ebp-5BCh]
  int v14; // [esp+38h] [ebp-590h]
  int i; // [esp+3Ch] [ebp-58Ch]
  char v16[16]; // [esp+40h] [ebp-588h] BYREF
  int v17; // [esp+50h] [ebp-578h] BYREF
  char v18[268]; // [esp+150h] [ebp-478h] BYREF
  int v19; // [esp+25Ch] [ebp-36Ch]
  char v20[256]; // [esp+260h] [ebp-368h] BYREF
  char dest[64]; // [esp+360h] [ebp-268h] BYREF
  char nptr[256]; // [esp+3A0h] [ebp-228h] BYREF
  char s[268]; // [esp+4A0h] [ebp-128h] BYREF
  int j; // [esp+5ACh] [ebp-1Ch]

  v19 = 0;
  if ( !g_allowVote[3] )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTINGNOTENABLED\"");
  if ( level[711] )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTEALREADYINPROGRESS\"");
  if ( *(int *)(*(_DWORD *)(a1 + 352) + 17812) > 2 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_MAXVOTESCALLED\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 3 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_NOSPECTATORCALLVOTE\"");
  trap_Argv(1, s, 256);
  trap_Argv(2, nptr, 256);
  if ( strchr(s, 59) || strchr(nptr, 59) )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDVOTESTRING\"");
  if ( Q_stricmp(s, "map_restart") )
  {
    if ( Q_stricmp(s, "map_rotate") )
    {
      if ( Q_stricmp(s, "typemap") )
      {
        if ( Q_stricmp(s, "map") )
        {
          if ( Q_stricmp(s, "g_gametype") )
          {
            if ( Q_stricmp(s, "kick") )
            {
              if ( Q_stricmp(s, "clientkick") )
              {
                if ( Q_stricmp(s, "tempBanUser") )
                {
                  if ( Q_stricmp(s, "tempBanClient") )
                  {
                    if ( Q_stricmp(s, "drawfriend") )
                    {
                      if ( Q_stricmp(s, "killcam") )
                      {
                        if ( Q_stricmp(s, "friendlyfire") )
                        {
                          trap_SendServerCommand(
                            1852331867 * ((a1 - (int)g_entities) >> 2),
                            0,
                            "e \"GAME_INVALIDVOTESTRING\"");
                          return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, &unk_9ED60);
                        }
                        v19 = g_allowVoteFriendlyFire[3];
                      }
                      else
                      {
                        v19 = g_allowVoteKillCam[3];
                      }
                    }
                    else
                    {
                      v19 = g_allowVoteDrawFriend[3];
                    }
                  }
                  else
                  {
                    v19 = g_allowVoteTempBanClient[3];
                  }
                }
                else
                {
                  v19 = g_allowVoteTempBanUser[3];
                }
              }
              else
              {
                v19 = g_allowVoteClientKick[3];
              }
            }
            else
            {
              v19 = g_allowVoteKick[3];
            }
          }
          else
          {
            v19 = g_allowVoteGameType[3];
          }
        }
        else
        {
          v19 = g_allowVoteMap[3];
        }
      }
      else
      {
        v19 = g_allowVoteTypeMap[3];
      }
    }
    else
    {
      v19 = g_allowVoteMapRotate[3];
    }
  }
  else
  {
    v19 = g_allowVoteMapRestart[3];
  }
  if ( !v19 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTINGNOTENABLED\"");
  if ( level[712] )
  {
    level[712] = 0;
    v2 = va((char *)&off_9EE69, 60);
    trap_SendConsoleCommand(2, v2);
  }
  if ( !Q_stricmp(s, "typemap") )
  {
    if ( !Scr_IsValidGameType(nptr) )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDGAMETYPE\"");
    if ( !Q_stricmp(nptr, (char *)&g_gametype + 16) )
      nptr[0] = 0;
    trap_Argv(3, v18, 256);
    if ( !trap_MapExists(v18) )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, &unk_9EEA0);
    trap_Cvar_Register(v16, "mapname", &unk_9EA48, 68);
    if ( !Q_stricmp(v18, &v17) )
      v18[0] = 0;
    if ( !nptr[0] && !v18[0] )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_TYPEMAP_NOCHANGE\"");
    if ( v18[0] )
    {
      if ( nptr[0] )
        Com_sprintf((char *)&level[199], 0x400u, "g_gametype %s; map %s", (char)nptr);
      else
        Com_sprintf((char *)&level[199], 0x400u, "map %s", (char)v18);
      if ( nptr[0] )
      {
        v3 = Scr_GetGameTypeNameForScript(nptr);
        Com_sprintf((char *)&level[455], 0x400u, aGameVoteGamety_0, v3);
      }
      else
      {
        Com_sprintf((char *)&level[455], 0x400u, aGameVoteMap, (char)v18);
      }
    }
    else
    {
      Com_sprintf((char *)&level[199], 0x400u, "g_gametype %s; map_restart", (char)nptr);
      v4 = Scr_GetGameTypeNameForScript(nptr);
      Com_sprintf((char *)&level[455], 0x400u, aGameVoteGamety, v4);
    }
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "g_gametype") )
  {
    if ( !Scr_IsValidGameType(nptr) )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDGAMETYPE\"");
    Com_sprintf((char *)&level[199], 0x400u, "%s %s; map_restart", (char)s);
    v5 = Scr_GetGameTypeNameForScript(nptr);
    Com_sprintf((char *)&level[455], 0x400u, aGameVoteGamety, v5);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map_restart") )
  {
    Com_sprintf((char *)&level[199], 0x400u, "%s", (char)s);
    Com_sprintf((char *)&level[455], 0x400u, "GAME_VOTE_MAPRESTART", v12);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map_rotate") )
  {
    Com_sprintf((char *)&level[199], 0x400u, "%s", (char)s);
    Com_sprintf((char *)&level[455], 0x400u, "GAME_VOTE_NEXTMAP", v13);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map") )
  {
    if ( !trap_MapExists(nptr) )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, &unk_9EEA0);
    Com_sprintf((char *)&level[199], 0x400u, "%s %s", (char)s);
    Com_sprintf((char *)&level[455], 0x400u, aGameVoteMap, (char)nptr);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "kick")
    || !Q_stricmp(s, "clientkick")
    || !Q_stricmp(s, "tempBanUser")
    || !Q_stricmp(s, "tempBanClient") )
  {
    v14 = 64;
    if ( Q_stricmp(s, "kick") && Q_stricmp(s, "tempBanUser") )
    {
      v14 = atoi(nptr);
      if ( (v14 || !Q_stricmp(nptr, "0")) && v14 >= 0 && v14 <= 63 && *(_DWORD *)(level[0] + 18228 * v14 + 17696) == 2 )
      {
        Q_strncpyz(dest, (char *)(level[0] + 18228 * v14 + 17908), 64);
        Q_CleanStr(dest);
      }
      else
      {
        v14 = 64;
      }
    }
    else
    {
      for ( i = 0; i <= 63; ++i )
      {
        if ( *(_DWORD *)(level[0] + 18228 * i + 17696) == 2 )
        {
          Q_strncpyz(dest, (char *)(level[0] + 18228 * i + 17908), 64);
          Q_CleanStr(dest);
          if ( !Q_stricmp(dest, nptr) )
            v14 = i;
        }
      }
    }
    if ( v14 == 64 )
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_CLIENTNOTONSERVER\"");
    if ( s[0] == 116 || s[0] == 84 )
      Com_sprintf(
        (char *)&level[199],
        0x400u,
        "%s \"%d\"",
        (unsigned __int8)&aTempbanclient[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      Com_sprintf(
        (char *)&level[199],
        0x400u,
        "%s \"%d\"",
        (unsigned __int8)&aClientkick[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    Com_sprintf((char *)&level[455], 0x400u, aGameVoteKick, v14);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "drawfriend") )
  {
    if ( !Q_stricmp(nptr, "0") && !Q_stricmp(nptr, &unk_9F00B) )
    {
      v6 = va(aEPatch15VoteAr, (char)nptr);
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v6);
    }
    trap_Cvar_VariableStringBuffer("scr_drawfriend", v20, 256);
    if ( !Q_stricmp(nptr, v20) )
      return trap_SendServerCommand(
               1852331867 * ((a1 - (int)g_entities) >> 2),
               0,
               "e \"PATCH_1_5_DRAWFRIEND_NOCHANGE\"");
    Com_sprintf((char *)&level[199], 0x400u, "setdrawfriend %s", (char)nptr);
    if ( nptr[0] == 49 )
      Com_sprintf(
        (char *)&level[455],
        0x400u,
        aPatch15VoteDra,
        (unsigned __int8)&aMenuOn[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      Com_sprintf(
        (char *)&level[455],
        0x400u,
        aPatch15VoteDra,
        (unsigned __int8)&aMenuOff[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "killcam") )
  {
    trap_Cvar_VariableStringBuffer("scr_killcam", v20, 256);
    if ( Q_stricmp(nptr, "0") || Q_stricmp(nptr, &unk_9F00B) )
    {
      if ( !Q_stricmp(nptr, v20) )
        return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_KILLCAM_NOCHANGE\"");
      Com_sprintf((char *)&level[199], 0x400u, "setkillcam %s", (char)nptr);
      if ( nptr[0] == 49 )
        Com_sprintf(
          (char *)&level[455],
          0x400u,
          aPatch15VoteKil,
          (unsigned __int8)&aMenuOn[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      else
        Com_sprintf(
          (char *)&level[455],
          0x400u,
          aPatch15VoteKil,
          (unsigned __int8)&aMenuOff[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      goto LABEL_129;
    }
LABEL_110:
    v7 = va(aEPatch15VoteAr, (char)nptr);
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v7);
  }
  result = Q_stricmp(s, "friendlyfire");
  if ( result )
    return result;
  trap_Cvar_VariableStringBuffer("scr_friendlyfire", v20, 256);
  if ( !Q_stricmp(nptr, v20) )
    return trap_SendServerCommand(
             1852331867 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_FRIENDLYFIRE_NOCHANGE\"");
  if ( Q_stricmp(nptr, "0") )
  {
    if ( Q_stricmp(nptr, &unk_9F00B) )
    {
      if ( Q_stricmp(nptr, &unk_9F19F) )
      {
        if ( Q_stricmp(nptr, "3") )
          goto LABEL_110;
        Com_sprintf(
          (char *)&level[455],
          0x400u,
          aPatch15VoteFri,
          (unsigned __int8)&aMenuShared[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      }
      else
      {
        Com_sprintf(
          (char *)&level[455],
          0x400u,
          aPatch15VoteFri,
          (unsigned __int8)&aMenuReflect[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      }
    }
    else
    {
      Com_sprintf(
        (char *)&level[455],
        0x400u,
        aPatch15VoteFri,
        (unsigned __int8)&aMenuOn[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    }
  }
  else
  {
    Com_sprintf(
      (char *)&level[455],
      0x400u,
      aPatch15VoteFri,
      (unsigned __int8)&aMenuOff[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  }
  Com_sprintf((char *)&level[199], 0x400u, "setfriendlyfire %s", (char)nptr);
LABEL_129:
  v8 = va(aEGameCalledavo, *(_DWORD *)(a1 + 352) - 12);
  trap_SendServerCommand(-1, 0, v8);
  level[711] = trap_Milliseconds() + 30000;
  level[713] = 1;
  level[714] = 0;
  for ( j = 0; j < level[121]; ++j )
    *(_DWORD *)(level[0] + 18228 * j + 132) &= 0xFFFEFFFF;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) |= 0x10000u;
  v9 = va("%i", 48);
  trap_SetConfigstring(16, v9);
  trap_SetConfigstring(17, &level[455]);
  v10 = va("%i", level[713]);
  trap_SetConfigstring(18, v10);
  v11 = va("%i", level[714]);
  return trap_SetConfigstring(19, v11);
}
// 4CF0A: variable 'v12' is possibly undefined
// 4CF81: variable 'v13' is possibly undefined
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 16DF4: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 173C4: using guessed type int trap_Milliseconds(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18444: using guessed type _DWORD __cdecl Scr_IsValidGameType(_DWORD);
// 185B4: using guessed type _DWORD __cdecl trap_MapExists(_DWORD);
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18BA4: using guessed type _DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD);
// 9EE69: using guessed type void *off_9EE69;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0004DA7A) --------------------------------------------------------
_DWORD *__cdecl Cmd_Vote_f(int a1)
{
  _DWORD *result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  char v7; // [esp+20h] [ebp-48h] BYREF
  char v8; // [esp+21h] [ebp-47h]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17828) <= level[123] )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17828) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17824) = -1;
    if ( level[711] )
    {
      if ( (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x10000) != 0 )
      {
        result = (_DWORD *)trap_SendServerCommand(
                             1852331867 * ((a1 - (int)g_entities) >> 2),
                             0,
                             "e \"GAME_VOTEALREADYCAST\"");
      }
      else if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 3 )
      {
        result = (_DWORD *)trap_SendServerCommand(
                             1852331867 * ((a1 - (int)g_entities) >> 2),
                             0,
                             "e \"GAME_NOSPECTATORVOTE\"");
      }
      else
      {
        trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTECAST\"");
        *(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) |= 0x10000u;
        trap_Argv(1, &v7, 64);
        if ( v7 == 121 || v8 == 89 || v8 == 49 )
        {
          v3 = va("%i", ++level[713]);
          result = (_DWORD *)trap_SetConfigstring(18, v3);
        }
        else
        {
          v4 = va("%i", ++level[714]);
          result = (_DWORD *)trap_SetConfigstring(19, v4);
        }
      }
    }
    else
    {
      result = (_DWORD *)trap_SendServerCommand(
                           1852331867 * ((a1 - (int)g_entities) >> 2),
                           0,
                           "e \"GAME_NOVOTEINPROGRESS\"");
    }
  }
  else
  {
    result = (_DWORD *)g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17824) + 88];
    v5 = result;
    if ( result )
    {
      result = (_DWORD *)g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17824) + 88];
      if ( v5[4424] == 2 )
      {
        if ( v5[4437] )
        {
          result = (_DWORD *)trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, "m -3");
        }
        else
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17828) = -1;
          *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17824) = -1;
          trap_Argv(1, &v7, 64);
          if ( v7 == 121 || v8 == 89 || v8 == 49 )
          {
            ++v5[4455];
            v6 = g_complaintlimit[3] - v5[4455];
            if ( v6 > 0 || v5[4437] )
            {
              v2 = va(aE_1, v6);
              trap_SendServerCommand(v5[53], 0, v2);
              result = (_DWORD *)trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, "m -1");
            }
            else
            {
              trap_DropClient(-1380760827 * (((int)v5 - level[0]) >> 2), "GAME_KICKEDFROMCOMPLAINTS");
              result = (_DWORD *)trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, "m -1");
            }
          }
          else
          {
            result = (_DWORD *)trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 1, "m -2");
          }
        }
      }
    }
  }
  return result;
}
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 17E44: using guessed type _DWORD __cdecl trap_DropClient(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004DEA0) --------------------------------------------------------
int __cdecl Cmd_SetViewpos_f(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  char v4; // [esp+4h] [ebp-444h]
  int i; // [esp+1Ch] [ebp-42Ch]
  char nptr[1024]; // [esp+20h] [ebp-428h] BYREF
  int v7; // [esp+420h] [ebp-28h] BYREF
  float v8; // [esp+424h] [ebp-24h]
  int v9; // [esp+428h] [ebp-20h]
  float v10[6]; // [esp+430h] [ebp-18h] BYREF

  if ( g_cheats[3] )
  {
    if ( trap_Argc() == 5 )
    {
      v9 = 0;
      v8 = 0.0;
      v7 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        trap_Argv(i + 1, nptr, 1024);
        v10[i] = atof(nptr);
      }
      trap_Argv(4, nptr, 1024);
      v8 = atof(nptr);
      result = TeleportPlayer(a1, v10, &v7);
    }
    else
    {
      v3 = va(aEGameUsage, v4);
      result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v3);
    }
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"", v4);
    result = trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v1);
  }
  return result;
}
// 4DECB: variable 'v4' is possibly undefined
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18414: using guessed type _DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD);

//----- (0004DFFB) --------------------------------------------------------
int __cdecl Cmd_Activate_f(int a1)
{
  char s[52]; // [esp+20h] [ebp-48h] BYREF
  int v4; // [esp+54h] [ebp-14h]
  int v5; // [esp+58h] [ebp-10h]
  _DWORD *v6; // [esp+5Ch] [ebp-Ch]

  v4 = 1;
  if ( !Scr_IsSystemActive(1) )
    return 0;
  v5 = G_IsVehicleUnusable(a1);
  if ( v5 )
  {
    (*(void (__cdecl **)(int, int, int))(v5 + 544))(v5, a1, a1);
    return 1;
  }
  if ( !*(_BYTE *)(a1 + 382) )
  {
    G_CheckForCursorHints(a1);
    if ( *(_WORD *)(*(_DWORD *)(a1 + 352) + 1528) == 1023 )
      return 0;
    v6 = &g_entities[211 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 352) + 1528)];
    if ( *((_WORD *)v6 + 194) )
    {
      if ( *((_WORD *)v6 + 194) == scr_const[26] || *((_WORD *)v6 + 194) == scr_const[27] )
      {
        G_TryDoor(v6, a1, a1);
      }
      else if ( *((_WORD *)v6 + 194) == scr_const[89] )
      {
        Scr_AddEntity(a1);
        Scr_Notify(v6, scr_const[88], 1);
        ((void (__cdecl *)(_DWORD *, int, int))v6[136])(v6, a1, a1);
      }
      else
      {
        switch ( v6[1] )
        {
          case 0xC:
            if ( !G_IsVehicleUsable(v6, a1) )
              return 0;
            break;
          case 3:
            memset(s, 0, 0x30u);
            Scr_AddEntity(a1);
            Scr_Notify(v6, scr_const[87], 1);
            if ( !v6[135] )
              return 0;
            *((_BYTE *)v6 + 382) = 1;
            ((void (__cdecl *)(_DWORD *, int, _DWORD))v6[135])(v6, a1, 0);
            return v4;
          case 0xB:
            if ( !G_IsTurretUsable(v6, a1) )
              return 0;
            break;
          default:
            if ( *((_WORD *)v6 + 194) == scr_const[38] && !*((_BYTE *)v6 + 382) )
            {
              if ( infront(v6, a1) )
                return 0;
              if ( *(_DWORD *)(level[0] + 18228 * *(_DWORD *)(a1 + 148) + 52) )
                return 0;
              *((_BYTE *)v6 + 382) = 1;
              *(_BYTE *)(a1 + 382) = 1;
              v6[85] = *(_DWORD *)a1;
              v6[167] = v6[82];
              v6[168] = v6[83];
              v6[169] = v6[84];
              return v4;
            }
            if ( *((_WORD *)v6 + 194) != scr_const[62] )
            {
              if ( *((_WORD *)v6 + 194) == scr_const[137] && v6[152] != *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) )
                ++v6[144];
              return v4;
            }
            Scr_AddEntity(a1);
            Scr_Notify(v6, scr_const[88], 1);
            if ( !v6[136] )
              return 0;
            break;
        }
        ((void (__cdecl *)(_DWORD *, int, int))v6[136])(v6, a1, a1);
      }
    }
    return v4;
  }
  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x6000) != 0 )
    *(_BYTE *)(a1 + 382) = 2;
  else
    *(_BYTE *)(a1 + 382) = 0;
  return 1;
}
// 169A4: using guessed type _DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD);
// 17274: using guessed type _DWORD __cdecl G_CheckForCursorHints(_DWORD);
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18564: using guessed type _DWORD __cdecl G_IsVehicleUsable(_DWORD, _DWORD);
// 187E4: using guessed type _DWORD __cdecl infront(_DWORD, _DWORD);
// 188B4: using guessed type _DWORD __cdecl G_TryDoor(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 196B4: using guessed type _DWORD __cdecl G_IsVehicleUnusable(_DWORD);

//----- (0004E4AA) --------------------------------------------------------
_DWORD *Cmd_EntityCount_f()
{
  _DWORD *result; // eax

  result = g_cheats;
  if ( g_cheats[3] )
    result = (_DWORD *)G_Printf("entity count = %i\n", level[3]);
  return result;
}

//----- (0004E4EB) --------------------------------------------------------
int __cdecl Cmd_MatchTimeout_f(int a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  if ( g_timeoutsAllowed[3] <= 0 || g_timeoutLength[3] <= 0 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEOUT_NOTENABLED\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) || *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 3 )
    return trap_SendServerCommand(
             1852331867 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_MUSTBEPLAYING\"");
  if ( level[1494] || level[1496] )
    return trap_SendServerCommand(
             1852331867 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_ALREADYINPROGRESS\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 2 )
  {
    if ( level[1492] >= g_timeoutsAllowed[3] )
    {
      v2 = va(aEPatch15Timeou_5, (unsigned __int8)&aGameAllies[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v2);
    }
    if ( (int)level[1490] <= 0 )
    {
      v3 = va(aEPatch15Timeou_6, (unsigned __int8)&aGameAllies[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v3);
    }
    ++level[1492];
    level[1497] = 2;
    Com_sprintf(
      (char *)&level[1234],
      0x400u,
      aPatch15Timeout,
      (unsigned __int8)&aGameAllies[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v9 = level[1490];
    if ( v9 > g_timeoutLength[3] )
      v9 = g_timeoutLength[3];
    level[1494] = v9;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) != 1 )
      return trap_SendServerCommand(
               1852331867 * ((a1 - (int)g_entities) >> 2),
               0,
               "e \"PATCH_1_5_TIMEOUT_INVALIDGAMETYPE\"");
    if ( level[1493] >= g_timeoutsAllowed[3] )
    {
      v4 = va(aEPatch15Timeou_5, (unsigned __int8)&aGameAxis[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v4);
    }
    if ( (int)level[1491] <= 0 )
    {
      v5 = va(aEPatch15Timeou_6, (unsigned __int8)&aGameAxis[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, v5);
    }
    ++level[1493];
    level[1497] = 1;
    Com_sprintf(
      (char *)&level[1234],
      0x400u,
      aPatch15Timeout,
      (unsigned __int8)&aGameAxis[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v8 = level[1491];
    if ( v8 > g_timeoutLength[3] )
      v8 = g_timeoutLength[3];
    level[1494] = v8;
  }
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 352) + 17908), 64);
  Q_CleanStr(dest);
  trap_Cvar_Set("timescale", "0");
  level[1495] = trap_Milliseconds();
  v6 = va("%i", level[1494]);
  trap_SetConfigstring(1909, v6);
  trap_SetConfigstring(1910, &level[1234]);
  v7 = va(aEPatch15Timeou_7, (char)dest);
  return trap_SendServerCommand(-1, 0, v7);
}
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 173C4: using guessed type int trap_Milliseconds(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0004E99C) --------------------------------------------------------
int __cdecl Cmd_MatchTimein_f(int a1)
{
  int v2; // eax
  int v3; // eax
  char v4; // [esp+Ch] [ebp-5Ch]
  char dest[88]; // [esp+10h] [ebp-58h] BYREF

  if ( g_timeoutsAllowed[3] <= 0 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEOUT_NOTENABLED\"");
  if ( !level[1494] )
    return trap_SendServerCommand(
             1852331867 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_NONEINPROGRESS\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) || *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == 3 )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEIN_MUSTBEPLAYING\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) != level[1497] )
    return trap_SendServerCommand(1852331867 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEIN_WRONGTEAM\"");
  Com_sprintf((char *)&level[1234], 0x400u, aPatch15Timeout_0, v4);
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 352) + 17908), 64);
  Q_CleanStr(dest);
  level[1490] -= trap_Milliseconds() - level[1495];
  level[1494] = 0;
  level[1496] = g_timeoutRecovery[3] + trap_Milliseconds();
  v2 = va("%i", g_timeoutRecovery[3]);
  trap_SetConfigstring(1909, v2);
  trap_SetConfigstring(1910, &level[1234]);
  v3 = va(aEPatch15Timein_1, (char)dest);
  return trap_SendServerCommand(-1, 0, v3);
}
// 4EAFB: variable 'v4' is possibly undefined
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 173C4: using guessed type int trap_Milliseconds(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004EC46) --------------------------------------------------------
int __cdecl Cmd_MenuResponse_f(int a1)
{
  int v1; // esi
  int result; // eax
  char dest[1024]; // [esp+10h] [ebp-C18h] BYREF
  char v4[1024]; // [esp+410h] [ebp-818h] BYREF
  char nptr[1036]; // [esp+810h] [ebp-418h] BYREF
  int v6; // [esp+C1Ch] [ebp-Ch]

  v6 = -1;
  if ( trap_Argc() == 4 )
  {
    trap_Argv(1, nptr, 1024);
    v1 = atoi(nptr);
    result = trap_Cvar_VariableIntegerValue("sv_serverId");
    if ( v1 != result )
      return result;
    trap_Argv(2, v4, 1024);
    v6 = atoi(v4);
    if ( v6 >= 0 && v6 <= 31 )
      trap_GetConfigstring(v6 + 1333, v4, 1024);
    trap_Argv(3, dest, 1024);
  }
  else
  {
    v4[0] = 0;
    strcpy(dest, "bad");
  }
  Scr_AddString(dest);
  Scr_AddString(v4);
  return Scr_Notify(a1, scr_const[115], 2);
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 19404: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (0004ED9B) --------------------------------------------------------
int __cdecl Cmd_NextVehSlot_f(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8) & 0x100000;
  if ( result )
  {
    result = a1;
    if ( *(int *)(a1 + 576) > 0 )
      result = G_VEH_CycleSlot(a1, 0);
  }
  return result;
}
// 19704: using guessed type _DWORD __cdecl G_VEH_CycleSlot(_DWORD, _DWORD);

//----- (0004EDE1) --------------------------------------------------------
int __cdecl Cmd_PrevVehSlot_f(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8) & 0x100000;
  if ( result )
  {
    result = a1;
    if ( *(int *)(a1 + 576) > 0 )
      result = G_VEH_CycleSlot(a1, 1);
  }
  return result;
}
// 19704: using guessed type _DWORD __cdecl G_VEH_CycleSlot(_DWORD, _DWORD);

//----- (0004EE27) --------------------------------------------------------
void Cmd_TraceProfile_f()
{
  ;
}

//----- (0004EE2C) --------------------------------------------------------
int __cdecl Cmd_FlameDamageClient_f(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-Ch]
  char nptr[8]; // [esp+10h] [ebp-8h] BYREF

  if ( trap_Argc() != 2 )
    return G_Printf("Cmd_FlameDamageClient_f: bad arg count\n", v2);
  trap_Argv(1, nptr, 4);
  v4 = atoi(nptr);
  if ( v4 < 0 || v4 > level[121] )
    return G_Printf("Cmd_FlameDamageClient_f: bad inflictor num\n", v3);
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 18212) = v4;
  result = level[123];
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 18208) = result;
  return result;
}
// 4EE51: variable 'v2' is possibly undefined
// 4EEA3: variable 'v3' is possibly undefined
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);

//----- (0004EEDD) --------------------------------------------------------
int *__cdecl ClientCommand(int a1)
{
  int *result; // eax
  int v2; // eax
  char v3[1036]; // [esp+10h] [ebp-418h] BYREF
  int *v4; // [esp+41Ch] [ebp-Ch]

  v4 = &g_entities[211 * a1];
  result = v4;
  if ( v4[88] )
  {
    trap_Argv(0, v3, 1024);
    if ( Q_stricmp(v3, "say") )
    {
      if ( Q_stricmp(v3, "say_team") )
      {
        if ( Q_stricmp(v3, "say_squad") )
        {
          if ( Q_stricmp(v3, "voice") )
          {
            if ( Q_stricmp(v3, "tell") )
            {
              if ( Q_stricmp(v3, "score") )
              {
                result = (int *)v4[88];
                if ( result[1] != 5 )
                {
                  if ( Q_stricmp(v3, "mr") )
                  {
                    if ( Q_stricmp(v3, "give") )
                    {
                      if ( Q_stricmp(v3, "take") )
                      {
                        if ( Q_stricmp(v3, "god") )
                        {
                          if ( Q_stricmp(v3, "notarget") )
                          {
                            if ( Q_stricmp(v3, "noclip") )
                            {
                              if ( Q_stricmp(v3, "ufo") )
                              {
                                if ( Q_stricmp(v3, "kill") )
                                {
                                  if ( Q_stricmp(v3, "follownext") )
                                  {
                                    if ( Q_stricmp(v3, "followprev") )
                                    {
                                      if ( Q_stricmp(v3, "where") )
                                      {
                                        if ( Q_stricmp(v3, "callvote") )
                                        {
                                          if ( Q_stricmp(v3, "vote") )
                                          {
                                            if ( Q_stricmp(v3, "gc") )
                                            {
                                              if ( Q_stricmp(v3, "setviewpos") )
                                              {
                                                if ( Q_stricmp(v3, "entitycount") )
                                                {
                                                  if ( Q_stricmp(v3, "nextvehslot") )
                                                  {
                                                    if ( Q_stricmp(v3, "prevvehslot") )
                                                    {
                                                      if ( Q_stricmp(v3, "killcam") )
                                                      {
                                                        if ( Q_stricmp(v3, "fdc") )
                                                        {
                                                          if ( Q_stricmp(v3, "trace_profile") )
                                                          {
                                                            if ( Q_stricmp(v3, "matchtimeout") )
                                                            {
                                                              if ( Q_stricmp(v3, "matchtimein") )
                                                              {
                                                                v2 = va(aEGameUnknowncl, (char)v3);
                                                                result = (int *)trap_SendServerCommand(a1, 0, v2);
                                                              }
                                                              else
                                                              {
                                                                result = (int *)Cmd_MatchTimein_f(v4);
                                                              }
                                                            }
                                                            else
                                                            {
                                                              result = (int *)Cmd_MatchTimeout_f(v4);
                                                            }
                                                          }
                                                          else
                                                          {
                                                            result = (int *)Cmd_TraceProfile_f(v4);
                                                          }
                                                        }
                                                        else
                                                        {
                                                          result = (int *)Cmd_FlameDamageClient_f(v4);
                                                        }
                                                      }
                                                      else
                                                      {
                                                        result = (int *)Cmd_Killcam_f(v4);
                                                      }
                                                    }
                                                    else
                                                    {
                                                      result = (int *)Cmd_PrevVehSlot_f(v4);
                                                    }
                                                  }
                                                  else
                                                  {
                                                    result = (int *)Cmd_NextVehSlot_f(v4);
                                                  }
                                                }
                                                else
                                                {
                                                  result = (int *)Cmd_EntityCount_f(v4);
                                                }
                                              }
                                              else
                                              {
                                                result = (int *)Cmd_SetViewpos_f(v4);
                                              }
                                            }
                                            else
                                            {
                                              result = (int *)Cmd_GameCommand_f(v4);
                                            }
                                          }
                                          else
                                          {
                                            result = (int *)Cmd_Vote_f(v4);
                                          }
                                        }
                                        else
                                        {
                                          result = (int *)Cmd_CallVote_f(v4);
                                        }
                                      }
                                      else
                                      {
                                        result = (int *)Cmd_Where_f(v4);
                                      }
                                    }
                                    else
                                    {
                                      result = (int *)Cmd_FollowCycle_f(v4, -1);
                                    }
                                  }
                                  else
                                  {
                                    result = (int *)Cmd_FollowCycle_f(v4, 1);
                                  }
                                }
                                else
                                {
                                  result = (int *)Cmd_Kill_f(v4);
                                }
                              }
                              else
                              {
                                result = (int *)Cmd_UFO_f(v4);
                              }
                            }
                            else
                            {
                              result = (int *)Cmd_Noclip_f(v4);
                            }
                          }
                          else
                          {
                            result = (int *)Cmd_Notarget_f(v4);
                          }
                        }
                        else
                        {
                          result = (int *)Cmd_God_f(v4);
                        }
                      }
                      else
                      {
                        result = (int *)Cmd_Take_f(v4);
                      }
                    }
                    else
                    {
                      result = (int *)Cmd_Give_f(v4);
                    }
                  }
                  else
                  {
                    result = (int *)Cmd_MenuResponse_f(v4);
                  }
                }
              }
              else
              {
                result = (int *)Cmd_Score_f(v4);
              }
            }
            else
            {
              result = sub_4C0A8(v4);
            }
          }
          else
          {
            result = (int *)sub_4C284((int)v4);
          }
        }
        else
        {
          result = (int *)sub_4C037((int)v4, 3, 0);
        }
      }
      else
      {
        result = (int *)sub_4C037((int)v4, 1, 0);
      }
    }
    else
    {
      result = (int *)sub_4C037((int)v4, 0, 0);
    }
  }
  return result;
}
// 169B4: using guessed type _DWORD __cdecl Cmd_FlameDamageClient_f(_DWORD);
// 16AA4: using guessed type _DWORD __cdecl Cmd_MatchTimeout_f(_DWORD);
// 16B04: using guessed type _DWORD __cdecl Cmd_Where_f(_DWORD);
// 16D74: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);
// 17014: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 17244: using guessed type _DWORD __cdecl Cmd_GameCommand_f(_DWORD);
// 17254: using guessed type _DWORD __cdecl Cmd_CallVote_f(_DWORD);
// 17394: using guessed type _DWORD __cdecl Cmd_UFO_f(_DWORD);
// 17574: using guessed type _DWORD __cdecl Cmd_God_f(_DWORD);
// 17604: using guessed type int __cdecl Cmd_TraceProfile_f(_DWORD);
// 17674: using guessed type _DWORD __cdecl Cmd_Kill_f(_DWORD);
// 17904: using guessed type _DWORD __cdecl Cmd_Killcam_f(_DWORD);
// 17994: using guessed type _DWORD __cdecl Cmd_Give_f(_DWORD);
// 179D4: using guessed type _DWORD __cdecl Cmd_MatchTimein_f(_DWORD);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 17B64: using guessed type _DWORD __cdecl Cmd_SetViewpos_f(_DWORD);
// 17C74: using guessed type _DWORD __cdecl Cmd_NextVehSlot_f(_DWORD);
// 17C84: using guessed type _DWORD __cdecl Cmd_Noclip_f(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18234: using guessed type _DWORD __cdecl Cmd_Notarget_f(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E54: using guessed type _DWORD __cdecl Cmd_PrevVehSlot_f(_DWORD);
// 18F04: using guessed type _DWORD __cdecl Cmd_Take_f(_DWORD);
// 192B4: using guessed type _DWORD __cdecl Cmd_MenuResponse_f(_DWORD);
// 19674: using guessed type int __cdecl Cmd_EntityCount_f(_DWORD);
// 19874: using guessed type _DWORD __cdecl Cmd_Vote_f(_DWORD);

//----- (0004F4B9) --------------------------------------------------------
void sub_4F4B9()
{
  ;
}

//----- (0004F4C0) --------------------------------------------------------
char *__cdecl sub_4F4C0(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (0004F4EA) --------------------------------------------------------
int G_ParseHitLocDmgTable()
{
  int v0; // esi
  int result; // eax
  int v2[61]; // [esp+20h] [ebp-2118h] BYREF
  size_t n; // [esp+114h] [ebp-2024h]
  char *s; // [esp+118h] [ebp-2020h]
  char v5[4]; // [esp+11Ch] [ebp-201Ch]
  char s1[8196]; // [esp+120h] [ebp-2018h] BYREF
  int v7; // [esp+2124h] [ebp-14h] BYREF
  int v8; // [esp+2128h] [ebp-10h]
  int i; // [esp+212Ch] [ebp-Ch]

  *(_DWORD *)v5 = "info/mp_lochit_dmgtable";
  s = "LOCDMGTABLE";
  n = strlen("LOCDMGTABLE");
  for ( i = 0; i <= 18; ++i )
  {
    g_fHitLocDamageMult[i] = 1065353216;
    v2[3 * i] = *(int *)((char *)off_ACEC0 + (_DWORD)&dword_0[i]);
    v2[3 * i + 1] = 4 * i;
    v2[3 * i + 2] = 6;
    v0 = i;
    *(__int16 *)((char *)&word_D1300 + (_DWORD)dword_0 + 2 * v0) = Scr_AllocString(
                                                                     *(char **)((char *)off_ACEC0 + (_DWORD)&dword_0[i]),
                                                                     1);
  }
  g_fHitLocDamageMult[18] = 0;
  v8 = trap_FS_FOpenFile(*(_DWORD *)v5, &v7, 0);
  if ( v8 <= 0 )
    return Com_Error(1, byte_9F880, v5[0]);
  trap_FS_Read(s1, n, v7);
  s1[n] = 0;
  if ( strncmp(s1, s, n) )
    return Com_Error(1, byte_9F8C0, v5[0]);
  if ( (int)(v8 - n) > 0x1FFF )
    return Com_Error(1, byte_9F900, v5[0]);
  trap_FS_Read(s1, v8 - n, v7);
  s1[v8 - n] = 0;
  trap_FS_FCloseFile(v7);
  if ( !Info_Validate(s1) )
    return Com_Error(1, byte_9F940, v5[0]);
  result = ParseConfigStringToStruct((int)g_fHitLocDamageMult, (int)v2, 19, s1, 0, 0, (int)sub_4F4C0);
  if ( !result )
    result = G_Error("Error parsing hitloc damage table %s\n", v5[0]);
  return result;
}
// 0: using guessed type int dword_0[];
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 19394: using guessed type _DWORD __cdecl Scr_AllocString(_DWORD, _DWORD);
// 197A4: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// ACEC0: using guessed type char *off_ACEC0[19];
// D1300: using guessed type __int16 word_D1300;

//----- (0004F7C7) --------------------------------------------------------
void AddScore()
{
  ;
}

//----- (0004F7CC) --------------------------------------------------------
void __cdecl LookAtKiller(int a1, float *a2, float *a3)
{
  int v3; // esi
  float v4; // [esp+30h] [ebp-18h] BYREF
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]

  if ( !a3 || a3 == (float *)a1 )
  {
    if ( !a2 || a2 == (float *)a1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 288) = (int)*(float *)(a1 + 332);
      return;
    }
    v4 = a2[79] - *(float *)(a1 + 316);
    v5 = a2[80] - *(float *)(a1 + 320);
    v6 = a2[81] - *(float *)(a1 + 324);
  }
  else
  {
    v4 = a3[79] - *(float *)(a1 + 316);
    v5 = a3[80] - *(float *)(a1 + 320);
    v6 = a3[81] - *(float *)(a1 + 324);
  }
  v3 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v3 + 288) = (int)vectoyaw(&v4);
  vectoyaw(&v4);
}
// 168D4: using guessed type long double __cdecl vectoyaw(_DWORD);

//----- (0004F8FE) --------------------------------------------------------
int __cdecl G_IndexForMeansOfDeath(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 26; ++i )
  {
    if ( !Q_stricmp(a1, modNames[i]) )
      return i;
  }
  Com_Printf("Unknown means of death string '%s'\n", a1);
  return 0;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// ACF20: using guessed type char *modNames[27];

//----- (0004F972) --------------------------------------------------------
int __cdecl player_die(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax
  long double v9; // fst6
  long double v10; // fst6
  _DWORD *v11; // [esp+2Ch] [ebp-3Ch]
  _DWORD *v12; // [esp+2Ch] [ebp-3Ch]
  int v13[2]; // [esp+30h] [ebp-38h] BYREF
  float v14; // [esp+38h] [ebp-30h]
  float v15; // [esp+40h] [ebp-28h] BYREF
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 352);
  if ( *(int *)(result + 4) <= 5 )
  {
    if ( (a3[1] == 11 || a3[1] == 12) && a3[85] != 1023 )
      a3 = &g_entities[211 * a3[85]];
    Scr_AddEntity(a3);
    Scr_Notify(a1, scr_const[14], 1);
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 18044) = -1;
    if ( a6 )
    {
      if ( a3[88] )
      {
        if ( (*(_DWORD *)(a3[88] + 132) & 0x6000) != 0 )
        {
          v11 = &g_entities[211 * a3[29]];
          if ( v11[1] == 11 )
            a6 = v11[51];
        }
      }
    }
    *(_DWORD *)(a1 + 616) = a3;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 52) )
    {
      v9 = (long double)rand() / 2147483600.0;
      v15 = v9 + v9 - 1.0;
      v10 = (long double)rand() / 2147483600.0;
      v16 = v10 + v10 - 1.0;
      v17 = (long double)rand() / 2147483600.0;
      v15 = v15 * 160.0;
      v16 = v16 * 160.0;
      v17 = v17 * 160.0;
      v13[0] = *(_DWORD *)(a1 + 316);
      v13[1] = *(_DWORD *)(a1 + 320);
      v14 = *(float *)(a1 + 324);
      v14 = v14 + 40.0;
      fire_grenade(a1, v13, &v15, *(_DWORD *)(a1 + 204));
    }
    BG_AnimScriptEvent(*(_DWORD *)(a1 + 352), 1, 0, 1);
    G_AddEvent(a1, 193, 0);
    Scr_PlayerKilled(a1, a2, a3, a4, a5, a6, a7, a8);
    for ( i = 0; i < level[121]; ++i )
    {
      v12 = (_DWORD *)(level[0] + 18228 * i);
      if ( v12[4424] == 2 && v12[4417] == 2 && v12[4486] == *(_DWORD *)a1 )
        Cmd_Score_f(&g_entities[211 * i]);
    }
    *(_BYTE *)(a1 + 381) = 1;
    *(_DWORD *)(a1 + 288) = 0x4000000;
    *(_DWORD *)(a1 + 336) = 0;
    LookAtKiller(a1, a2, a3);
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 232) = *(_DWORD *)(a1 + 328);
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 236) = *(_DWORD *)(a1 + 332);
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 240) = *(_DWORD *)(a1 + 336);
    *(_DWORD *)(a1 + 132) = 0;
    trap_UnlinkEntity(a1);
    *(_DWORD *)(a1 + 284) = 1106247680;
    trap_LinkEntity(a1);
    *(_DWORD *)(a1 + 576) = 0;
    *(_DWORD *)(a1 + 552) = 0;
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 16D74: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17E14: using guessed type _DWORD __cdecl LookAtKiller(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18AB4: using guessed type _DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 191F4: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 197B4: using guessed type _DWORD __cdecl Scr_PlayerKilled(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004FD4B) --------------------------------------------------------
_DWORD *__cdecl G_DamageClient(int a1, _DWORD *a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  _DWORD *result; // eax
  float v10; // [esp+28h] [ebp-10h]
  int v11; // [esp+54h] [ebp+1Ch]

  result = (_DWORD *)a1;
  if ( *(_BYTE *)(a1 + 381) )
  {
    result = *(_DWORD **)(a1 + 352);
    if ( !result[4487] )
    {
      result = *(_DWORD **)(a1 + 352);
      if ( !result[4488] )
      {
        result = *(_DWORD **)(a1 + 352);
        if ( result[4424] == 2 )
        {
          if ( !*(_DWORD *)(a1 + 352) || (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x100000) == 0 )
            goto LABEL_12;
          if ( (a7 & 1) != 0 )
          {
            v10 = (float)a6;
            a6 = (int)(G_VehicleOccupantRadiusDamageScale(a1) * v10);
          }
          if ( !G_IsVehicleOccupantInvulnerable(a1) || !a2 || (result = *(_DWORD **)(a1 + 340), result == (_DWORD *)*a2) )
          {
LABEL_12:
            v11 = (int)((long double)a6 * *(float *)&g_fHitLocDamageMult[a9]);
            if ( a2 )
            {
              result = (_DWORD *)Scr_PlayerDamage(a1, a2, a3, v11, a7, a8, a2[51], a5, a4, a9);
            }
            else if ( a3 )
            {
              result = (_DWORD *)Scr_PlayerDamage(a1, 0, a3, v11, a7, a8, *(_DWORD *)(a3 + 204), a5, a4, a9);
            }
            else
            {
              result = (_DWORD *)Scr_PlayerDamage(a1, 0, 0, v11, a7, a8, 0, a5, a4, a9);
            }
          }
        }
      }
    }
  }
  return result;
}
// 167D4: using guessed type _DWORD __cdecl G_IsVehicleOccupantInvulnerable(_DWORD);
// 17044: using guessed type _DWORD __cdecl Scr_PlayerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17E94: using guessed type long double __cdecl G_VehicleOccupantRadiusDamageScale(_DWORD);

//----- (0004FEDB) --------------------------------------------------------
int __cdecl G_Damage(int a1, char *a2, char *a3, int a4, _DWORD *a5, int a6, int a7, int a8, int a9)
{
  int result; // eax
  float v10; // [esp+38h] [ebp-20h]
  int v11[6]; // [esp+40h] [ebp-18h] BYREF

  if ( *(_DWORD *)(a1 + 352) )
    return G_DamageClient(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  result = a1;
  if ( *(_BYTE *)(a1 + 381) )
  {
    if ( *(_DWORD *)(a1 + 356) )
    {
      result = G_IsVehicleImmune(a1, a8);
      if ( result )
        return result;
      result = a7 & 1;
      if ( (a7 & 1) != 0 && a6 <= 99 )
        return result;
      v10 = (float)a6;
      a6 = (int)(Scr_Vehicle_DamageScale(a1, a3, a2, a5, a8) * v10);
    }
    if ( !a2 )
      a2 = (char *)&dword_D2968 + (_DWORD)g_entities;
    if ( !a3 )
      a3 = (char *)&dword_D2968 + (_DWORD)g_entities;
    if ( *(_DWORD *)(a1 + 4) == 5 )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 544) )
      {
        result = a1;
        if ( !*(_BYTE *)(a1 + 384) )
        {
          Scr_AddEntity(a3);
          Scr_Notify(a1, scr_const[88], 1);
          result = (*(int (__cdecl **)(int, char *, char *))(a1 + 544))(a1, a2, a3);
        }
      }
    }
    else
    {
      VectorNormalize2(a4, v11);
      if ( *(_DWORD *)(a1 + 4) == 8 )
      {
        Scr_AddEntity(a2);
        Scr_AddString(modNames[a8]);
        if ( a5 )
          Scr_AddVector(a5);
        else
          Scr_AddVector(a1 + 316);
        Scr_AddVector(v11);
        Scr_AddEntity(a3);
        Scr_AddInt(a6);
        result = Scr_Notify(a1, scr_const[13], 6);
      }
      else
      {
        result = *(_DWORD *)(a1 + 396) & 1;
        if ( !result )
        {
          if ( a6 <= 0 )
            a6 = 1;
          if ( g_debugDamage[3] )
            G_Printf("target:%i health:%i damage:%i\n", *(_DWORD *)a1);
          if ( *(_WORD *)(a1 + 388) != scr_const[39] && *(_WORD *)(a1 + 388) != scr_const[40] )
            *(_DWORD *)(a1 + 576) -= a6;
          Scr_AddEntity(a2);
          Scr_AddString(modNames[a8]);
          if ( a5 )
            Scr_AddVector(a5);
          else
            Scr_AddVector(a1 + 316);
          Scr_AddVector(v11);
          Scr_AddEntity(a3);
          Scr_AddInt(a6);
          Scr_Notify(a1, scr_const[13], 6);
          if ( *(int *)(a1 + 576) > 0 )
          {
            result = a1;
            if ( *(_DWORD *)(a1 + 548) )
            {
              if ( a4 )
              {
                *(_DWORD *)(a1 + 656) = v11[0];
                *(_DWORD *)(a1 + 660) = v11[1];
                *(_DWORD *)(a1 + 664) = v11[2];
                *(_DWORD *)(a1 + 460) = *a5;
                *(_DWORD *)(a1 + 464) = a5[1];
                *(_DWORD *)(a1 + 468) = a5[2];
              }
              else
              {
                *(_DWORD *)(a1 + 664) = 0;
                *(_DWORD *)(a1 + 660) = 0;
                *(_DWORD *)(a1 + 656) = 0;
                *(_DWORD *)(a1 + 468) = 0;
                *(_DWORD *)(a1 + 464) = 0;
                *(_DWORD *)(a1 + 460) = 0;
              }
              result = (*(int (__cdecl **)(int, char *, int, _DWORD *, int, int *, int))(a1 + 548))(
                         a1,
                         a3,
                         a6,
                         a5,
                         a8,
                         v11,
                         a9);
            }
          }
          else
          {
            if ( *(int *)(a1 + 576) < -999 )
              *(_DWORD *)(a1 + 576) = -999;
            Scr_AddEntity(a3);
            Scr_Notify(a1, scr_const[14], 1);
            *(_DWORD *)(a1 + 616) = a3;
            result = a1;
            if ( *(_DWORD *)(a1 + 552) )
              result = (*(int (__cdecl **)(int, char *, char *, int, int, _DWORD, int *, int))(a1 + 552))(
                         a1,
                         a2,
                         a3,
                         a6,
                         a8,
                         *((_DWORD *)a2 + 51),
                         v11,
                         a9);
          }
        }
      }
    }
  }
  return result;
}
// 16C34: using guessed type long double __cdecl Scr_Vehicle_DamageScale(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 171C4: using guessed type _DWORD __cdecl G_IsVehicleImmune(_DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18354: using guessed type _DWORD __cdecl G_DamageClient(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// ACF20: using guessed type char *modNames[27];
// D2968: using guessed type int dword_D2968;

//----- (000503F8) --------------------------------------------------------
long double __cdecl CanDamage(float *a1, float *a2)
{
  float v3; // [esp+34h] [ebp-D4h]
  int v4; // [esp+38h] [ebp-D0h]
  float v5; // [esp+3Ch] [ebp-CCh]
  float v6; // [esp+40h] [ebp-C8h] BYREF
  float v7; // [esp+44h] [ebp-C4h]
  float v8; // [esp+48h] [ebp-C0h]
  unsigned int v9; // [esp+50h] [ebp-B8h]
  float v10; // [esp+54h] [ebp-B4h]
  float v11; // [esp+58h] [ebp-B0h]
  float v12; // [esp+60h] [ebp-A8h] BYREF
  float v13; // [esp+64h] [ebp-A4h]
  float v14; // [esp+68h] [ebp-A0h]
  int i; // [esp+7Ch] [ebp-8Ch]
  float v16[12]; // [esp+80h] [ebp-88h] BYREF
  float v17; // [esp+B0h] [ebp-58h] BYREF
  float v18; // [esp+B4h] [ebp-54h]
  float v19; // [esp+B8h] [ebp-50h]
  float v20; // [esp+BCh] [ebp-4Ch]
  float v21; // [esp+C0h] [ebp-48h]
  float v22; // [esp+C4h] [ebp-44h]
  float v23; // [esp+C8h] [ebp-40h]
  float v24; // [esp+CCh] [ebp-3Ch]
  float v25; // [esp+D0h] [ebp-38h]
  float v26; // [esp+D4h] [ebp-34h]
  float v27; // [esp+D8h] [ebp-30h]
  float v28; // [esp+DCh] [ebp-2Ch]
  float v29; // [esp+E0h] [ebp-28h]
  float v30; // [esp+E4h] [ebp-24h]
  float v31; // [esp+E8h] [ebp-20h]
  float v32; // [esp+FCh] [ebp-Ch]

  v32 = 15.0;
  if ( *((_DWORD *)a1 + 88) )
  {
    v6 = a1[79];
    v7 = a1[80];
    v8 = a1[81];
    v8 = v8 + *(float *)(*((_DWORD *)a1 + 88) + 248);
    G_AddLean(a1, &v6);
    v5 = (v8 - a1[81]) * 0.5;
    v12 = *a2 - a1[79];
    v13 = a2[1] - a1[80];
    v14 = 0.0;
    VectorNormalize(&v12);
    v9 = LODWORD(v13) ^ 0x80000000;
    v10 = v12;
    v11 = v14;
    v17 = v6 + a1[79];
    v18 = v7 + a1[80];
    v19 = v8 + a1[81];
    v17 = v17 * 0.5;
    v18 = v18 * 0.5;
    v19 = v19 * 0.5;
    v20 = COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) * v32 + v17;
    v21 = v12 * v32 + v18;
    v22 = v14 * v32 + v19;
    v22 = v22 + v5;
    v23 = v20;
    v24 = v21;
    v25 = v14 * v32 + v19;
    v25 = v25 - v5;
    v26 = -v32 * COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) + v17;
    v27 = -v32 * v12 + v18;
    v28 = -v32 * v14 + v19;
    v28 = v28 + v5;
    v29 = v26;
    v30 = v27;
    v31 = -v32 * v14 + v19;
    v31 = v31 - v5;
    v4 = 0;
    for ( i = 0; i <= 4; ++i )
    {
      trap_LocationalTrace(v16, &v17 + 3 * i, a2, *(_DWORD *)a1, 8396945, &bulletPriorityMap);
      if ( v16[0] == 1.0 )
        ++v4;
    }
    if ( v4 )
    {
      if ( v4 <= 3 )
        v3 = (long double)v4 / 3.0;
      else
        v3 = 1.0;
    }
    else
    {
      v3 = 0.0;
    }
  }
  else
  {
    v17 = a1[73] + a1[76];
    v18 = a1[74] + a1[77];
    v19 = a1[75] + a1[78];
    v17 = v17 * 0.5;
    v18 = v18 * 0.5;
    v19 = v19 * 0.5;
    v22 = v19;
    v20 = v17 + v32;
    v21 = v18 + v32;
    v25 = v19;
    v23 = v20;
    v24 = v18 - v32;
    v28 = v19;
    v26 = v17 - v32;
    v27 = v21;
    v31 = v19;
    v29 = v26;
    v30 = v24;
    if ( VectorDistanceSquared(&v17, a2) >= 0.0000099999997 )
    {
      for ( i = 0; i <= 4; ++i )
      {
        trap_LocationalTrace(v16, &v17 + 3 * i, a2, *(_DWORD *)a1, 8396945, &bulletPriorityMap);
        if ( v16[0] == 1.0 )
          return 1.0;
      }
      v3 = 0.0;
    }
    else
    {
      v3 = 1.0;
    }
  }
  return v3;
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18274: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0005098B) --------------------------------------------------------
int __cdecl G_RadiusDamage(int a1, int a2, int a3, float a4, float a5, float a6, int a7, int a8)
{
  float v10; // [esp+40h] [ebp-10D8h]
  float v11; // [esp+40h] [ebp-10D8h]
  float v12; // [esp+44h] [ebp-10D4h]
  float v13; // [esp+44h] [ebp-10D4h]
  float v14; // [esp+48h] [ebp-10D0h]
  float v15; // [esp+48h] [ebp-10D0h]
  float v16[12]; // [esp+50h] [ebp-10C8h] BYREF
  float v17; // [esp+80h] [ebp-1098h] BYREF
  float v18; // [esp+84h] [ebp-1094h]
  float v19; // [esp+88h] [ebp-1090h]
  float v20; // [esp+90h] [ebp-1088h]
  int v21; // [esp+94h] [ebp-1084h]
  int j; // [esp+98h] [ebp-1080h]
  int i; // [esp+9Ch] [ebp-107Ch]
  float v24; // [esp+A0h] [ebp-1078h] BYREF
  float v25; // [esp+A4h] [ebp-1074h]
  float v26; // [esp+A8h] [ebp-1070h]
  float v27; // [esp+B0h] [ebp-1068h]
  float v28; // [esp+B4h] [ebp-1064h]
  float v29; // [esp+B8h] [ebp-1060h]
  float v30[4]; // [esp+C0h] [ebp-1058h] BYREF
  float v31[7]; // [esp+D0h] [ebp-1048h] BYREF
  int v32; // [esp+ECh] [ebp-102Ch]
  int v33[1024]; // [esp+F0h] [ebp-1028h] BYREF
  float *v34; // [esp+10F0h] [ebp-28h]
  float v35; // [esp+10F4h] [ebp-24h]
  float v36; // [esp+10F8h] [ebp-20h]
  float v37; // [esp+10FCh] [ebp-1Ch]

  v21 = 0;
  if ( !a3 )
    return 0;
  if ( a6 < 1.0 )
    a6 = 1.0;
  v20 = a6 * 1.4142135;
  for ( i = 0; i <= 2; ++i )
  {
    v31[i] = *(float *)(a1 + 4 * i) - v20;
    v30[i] = *(float *)(a1 + 4 * i) + v20;
  }
  v32 = trap_EntitiesInBox(v31, v30, v33, 1024, -1);
  for ( j = 0; j < v32; ++j )
  {
    v34 = (float *)&g_entities[211 * v33[j]];
    if ( v34 != (float *)a7 && *((_BYTE *)v34 + 381) )
    {
      if ( *((_DWORD *)v34 + 65) )
      {
        if ( *((_DWORD *)v34 + 89) )
        {
          for ( i = 0; i <= 2; ++i )
          {
            if ( v34[i + 73] - v34[i + 66] * 0.75 <= *(float *)(a1 + 4 * i) )
            {
              if ( *(float *)(a1 + 4 * i) <= v34[i + 76] - v34[i + 69] * 0.75 )
                *(&v27 + i) = 0.0;
              else
                *(&v27 + i) = *(float *)(a1 + 4 * i) - (v34[i + 76] - v34[i + 69] * 0.75);
            }
            else
            {
              *(&v27 + i) = v34[i + 73] - v34[i + 66] * 0.75 - *(float *)(a1 + 4 * i);
            }
          }
        }
        else
        {
          for ( i = 0; i <= 2; ++i )
          {
            if ( v34[i + 73] <= (long double)*(float *)(a1 + 4 * i) )
            {
              if ( *(float *)(a1 + 4 * i) <= (long double)v34[i + 76] )
                *(&v27 + i) = 0.0;
              else
                *(&v27 + i) = *(float *)(a1 + 4 * i) - v34[i + 76];
            }
            else
            {
              *(&v27 + i) = v34[i + 73] - *(float *)(a1 + 4 * i);
            }
          }
        }
      }
      else
      {
        v27 = v34[79] - *(float *)a1;
        v28 = v34[80] - *(float *)(a1 + 4);
        v29 = v34[81] - *(float *)(a1 + 8);
      }
      v36 = sqrt(v27 * v27 + v28 * v28 + v29 * v29);
      if ( v36 < (long double)a6 && (!*((_DWORD *)v34 + 88) || !level[2970]) )
      {
        v37 = (a4 - a5) * (1.0 - v36 / a6) + a5;
        v35 = CanDamage(v34, a1);
        if ( v35 <= 0.0 )
        {
          v10 = v34[73] + v34[76];
          v12 = v34[74] + v34[77];
          v14 = v34[75] + v34[78];
          v11 = v10 * 0.5;
          v13 = v12 * 0.5;
          v15 = v14 * 0.5;
          v17 = v11;
          v18 = v13;
          v19 = v15;
          trap_Trace(v16, a1, vec3_origin, vec3_origin, &v17, 1023, 17);
          if ( v16[0] < 1.0 )
          {
            v17 = v17 - *(float *)a1;
            v18 = v18 - *(float *)(a1 + 4);
            v19 = v19 - *(float *)(a1 + 8);
            v36 = sqrt(v17 * v17 + v18 * v18 + v19 * v19);
            if ( a6 * 0.2 > v36 )
            {
              if ( LogAccuracyHit(v34, a3) )
                v21 = 1;
              v24 = v34[79] - *(float *)a1;
              v25 = v34[80] - *(float *)(a1 + 4);
              v26 = v34[81] - *(float *)(a1 + 8);
              v26 = v26 + 24.0;
              G_Damage(v34, a2, a3, &v24, a1, (int)(v37 * 0.1), 1, a8, 0);
            }
          }
        }
        else
        {
          if ( LogAccuracyHit(v34, a3) )
            v21 = 1;
          v24 = v34[79] - *(float *)a1;
          v25 = v34[80] - *(float *)(a1 + 4);
          v26 = v34[81] - *(float *)(a1 + 8);
          v26 = v26 + 24.0;
          G_Damage(v34, a2, a3, &v24, a1, (int)(v37 * v35), 1, a8, 0);
        }
      }
    }
  }
  return v21;
}
// 16A74: using guessed type _DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD);
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18554: using guessed type double __cdecl CanDamage(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000511DC) --------------------------------------------------------
int __cdecl G_GetHitLocationString(int a1)
{
  return *(unsigned __int16 *)((char *)&word_D1300 + (_DWORD)dword_0 + 2 * a1);
}
// 0: using guessed type int dword_0[];
// D1300: using guessed type __int16 word_D1300;

//----- (000511F9) --------------------------------------------------------
int __cdecl G_GetHitLocationIndexFromString(__int16 a1)
{
  int i; // [esp+4h] [ebp-Ch]

  for ( i = 0; i <= 18; ++i )
  {
    if ( *(__int16 *)((char *)&word_D1300 + (_DWORD)dword_0 + 2 * i) == a1 )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// D1300: using guessed type __int16 word_D1300;

//----- (00051251) --------------------------------------------------------
void sub_51251()
{
  ;
}

//----- (00051258) --------------------------------------------------------
int __cdecl G_DebugLine(int a1, int a2, int a3, int a4, int a5)
{
  return trap_AddDebugLine(a1, a2, a3, a4, a5);
}
// 18B54: using guessed type _DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00051297) --------------------------------------------------------
int *__cdecl G_DebugBox(int a1, int a2, int a3, int a4, int a5)
{
  int *result; // eax
  float v6; // [esp+28h] [ebp-80h]
  float v7[26]; // [esp+30h] [ebp-78h] BYREF
  int i; // [esp+98h] [ebp-10h]
  int v9[3]; // [esp+9Ch] [ebp-Ch] BYREF

  for ( v9[0] = 0; v9[0] <= 7; ++v9[0] )
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( ((v9[0] >> i) & 1) != 0 )
        v6 = *(float *)(a2 + 4 * i);
      else
        v6 = *(float *)(a1 + 4 * i);
      v7[3 * v9[0] + i] = v6;
    }
    result = v9;
  }
  for ( v9[0] = 0; v9[0] <= 0xBu; ++v9[0] )
  {
    G_DebugLine(
      &v7[3 * *(int *)((char *)&dword_9FC00 + (_DWORD)&dword_0[2 * v9[0]])],
      &v7[3 * *(int *)((char *)&dword_9FC04 + (_DWORD)&dword_0[2 * v9[0]])],
      a3,
      a4,
      a5);
    result = v9;
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 9FC00: using guessed type int dword_9FC00;
// 9FC04: using guessed type int dword_9FC04;

//----- (0005139D) --------------------------------------------------------
int __cdecl G_DebugCircle(int a1, float a2, int a3, int a4, int a5, int a6)
{
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  if ( a5 )
  {
    *(float *)&v9 = 0.0;
    v10 = 0.0;
    v11 = 1.0;
  }
  else
  {
    v7 = *(float *)(level[0] + 24);
    v8 = *(float *)(level[0] + 28) + *(float *)(level[0] + 248);
    *(float *)&v9 = *(float *)a1 - *(float *)(level[0] + 20);
    v10 = *(float *)(a1 + 4) - v7;
    v11 = *(float *)(a1 + 8) - v8;
  }
  return G_DebugCircleEx(a1, a2, (int)&v9, a3, a4, a6);
}

//----- (00051465) --------------------------------------------------------
unsigned int *__cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4, int a5, int a6)
{
  unsigned int *result; // eax
  float v7; // [esp+2Ch] [ebp-10Ch] BYREF
  float v8[2]; // [esp+30h] [ebp-108h] BYREF
  float v9; // [esp+38h] [ebp-100h]
  unsigned int i; // [esp+3Ch] [ebp-FCh] BYREF
  float v11[4]; // [esp+40h] [ebp-F8h] BYREF
  float v12[4]; // [esp+50h] [ebp-E8h] BYREF
  char v13[216]; // [esp+60h] [ebp-D8h] BYREF

  VectorNormalize2(a3, v13);
  PerpendicularVector(v12, v13);
  result = (unsigned int *)CrossProduct(v13, v12, v11);
  for ( i = 0; i <= 0xF; ++i )
  {
    v9 = (long double)(int)i * 0.3926990816987241;
    sub_518EC(v9, v8, &v7);
    v8[0] = v8[0] * a2;
    v7 = v7 * a2;
    *(float *)&v13[12 * i + 16] = v11[0] * v8[0] + *(float *)a1;
    *(float *)&v13[12 * i + 20] = v11[1] * v8[0] + *(float *)(a1 + 4);
    *(float *)&v13[12 * i + 24] = v11[2] * v8[0] + *(float *)(a1 + 8);
    *(float *)&v13[12 * i + 16] = v12[0] * v7 + *(float *)&v13[12 * i + 16];
    *(float *)&v13[12 * i + 20] = v12[1] * v7 + *(float *)&v13[12 * i + 20];
    *(float *)&v13[12 * i + 24] = v12[2] * v7 + *(float *)&v13[12 * i + 24];
    result = &i;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    G_DebugLine(&v13[12 * i + 16], &v13[12 * (((_BYTE)i + 1) & 0xF) + 16], a4, a5, a6);
    result = &i;
  }
  return result;
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 19824: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (00051725) --------------------------------------------------------
void __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5, int a6, int a7)
{
  float v7; // [esp+28h] [ebp-E0h] BYREF
  float v8[2]; // [esp+2Ch] [ebp-DCh] BYREF
  float v9; // [esp+34h] [ebp-D4h]
  float v10; // [esp+38h] [ebp-D0h]
  unsigned int i; // [esp+3Ch] [ebp-CCh]
  _DWORD v12[50]; // [esp+40h] [ebp-C8h] BYREF

  v10 = (a4 - a3) / 15.0;
  if ( v10 < 0.0 )
  {
    a3 = a3 - 360.0;
    v10 = (a4 - a3) / 15.0;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    v9 = ((long double)(int)i * v10 + a3) * 3.141592653589793 / 180.0;
    sub_518EC(v9, v8, &v7);
    *(float *)&v12[3 * i] = v7 * a2 + *(float *)a1;
    *(float *)&v12[3 * i + 1] = v8[0] * a2 + *(float *)(a1 + 4);
    v12[3 * i + 2] = *(_DWORD *)(a1 + 8);
  }
  for ( i = 0; i <= 0xE; ++i )
    G_DebugLine(&v12[3 * i], &v12[3 * i + 3], a5, a6, a7);
}
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000518EC) --------------------------------------------------------
float *__cdecl sub_518EC(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (00051904) --------------------------------------------------------
void sub_51904()
{
  ;
}

//----- (00051908) --------------------------------------------------------
_DWORD *__cdecl sub_51908(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[23] = 0;
  a1[24] = 0;
  a1[25] = 0;
  result = a1;
  a1[26] = 0;
  return result;
}

//----- (0005197B) --------------------------------------------------------
_DWORD *__cdecl sub_5197B(_DWORD *a1)
{
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 1065353216;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = -1;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[27] = 0;
  a1[33] = 1;
  return sub_51908(a1);
}

//----- (00051A1C) --------------------------------------------------------
char *__cdecl HudElem_Alloc(int a1, int a2)
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x7FF; ++i )
  {
    if ( !g_hudelems[34 * i] )
    {
      sub_5197B(&g_hudelems[34 * i]);
      g_hudelems[34 * i + 31] = a1;
      g_hudelems[34 * i + 32] = a2;
      return (char *)&g_hudelems[34 * i];
    }
  }
  return 0;
}

//----- (00051AF3) --------------------------------------------------------
_DWORD *__cdecl HudElem_Free(_DWORD *a1)
{
  _DWORD *result; // eax

  Scr_FreeHudElem(a1);
  result = a1;
  *a1 = 0;
  return result;
}
// 17334: using guessed type _DWORD __cdecl Scr_FreeHudElem(_DWORD);

//----- (00051B1F) --------------------------------------------------------
unsigned int *__cdecl HudElem_ClientDisconnect(_DWORD *a1)
{
  unsigned int *result; // eax
  unsigned int i; // [esp+10h] [ebp-8h] BYREF

  for ( i = 0; i <= 0x7FF; ++i )
  {
    if ( g_hudelems[34 * i] )
    {
      if ( g_hudelems[34 * i + 31] == *a1 )
        HudElem_Free(&g_hudelems[34 * i]);
    }
    result = &i;
  }
  return result;
}
// 19254: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (00051BAD) --------------------------------------------------------
void *HudElem_DestroyAll()
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x7FF; ++i )
  {
    if ( g_hudelems[34 * i] )
      HudElem_Free(&g_hudelems[34 * i]);
  }
  return memset(g_hudelems, 0, 0x44000u);
}
// 19254: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (00051C38) --------------------------------------------------------
int __cdecl sub_51C38(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax
  const char *v5; // eax
  char s[2056]; // [esp+10h] [ebp-818h] BYREF
  int v7; // [esp+818h] [ebp-10h]
  int i; // [esp+81Ch] [ebp-Ch]

  v7 = Scr_GetString(0);
  for ( i = 0; i < a4; ++i )
  {
    if ( !Q_stricmp(v7, *(_DWORD *)(a3 + 4 * i)) )
    {
      result = i;
      *(_DWORD *)(a2[1] + a1) = i;
      return result;
    }
  }
  sprintf(s, "\"%s\" is not a valid value for hudelem field \"%s\"\nShould be one of:", v7, *a2);
  for ( i = 0; i < a4; ++i )
  {
    v5 = (const char *)va(" %s", *(_DWORD *)(a3 + 4 * i));
    strncat(s, v5, 0x800u);
    s[2047] = 0;
  }
  return Scr_Error(s);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00051D43) --------------------------------------------------------
int __cdecl sub_51D43(int a1, int a2, int a3)
{
  return Scr_AddString(*(_DWORD *)(a3 + 4 * *(_DWORD *)(a1 + *(_DWORD *)(a2 + 4))));
}
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00051D81) --------------------------------------------------------
int *__cdecl sub_51D81(int a1, int a2)
{
  int v2; // edx
  int *result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]

  s2 = (char *)Scr_GetIString(0);
  v2 = G_LocalizedStringIndex(s2);
  result = (int *)((char *)*(&off_ACFA0 + 5 * a2 + 1) + a1);
  *result = v2;
  return result;
}
// 16C04: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// ACFA0: using guessed type void *off_ACFA0;

//----- (00051DDC) --------------------------------------------------------
int __cdecl sub_51DDC(int a1, int a2)
{
  int result; // eax

  result = Scr_GetBool(0);
  *(_DWORD *)((char *)*(&off_ACFA0 + 5 * a2 + 1) + a1) = result;
  return result;
}
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// ACFA0: using guessed type void *off_ACFA0;

//----- (00051E2F) --------------------------------------------------------
int __cdecl sub_51E2F(_BYTE *a1)
{
  char v1; // al
  char v2; // al
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+20h] [ebp-28h]
  float v6; // [esp+28h] [ebp-20h]
  float v7; // [esp+30h] [ebp-18h] BYREF
  float v8; // [esp+34h] [ebp-14h]
  float v9; // [esp+38h] [ebp-10h]

  Scr_GetVector(0, &v7);
  if ( v7 <= 1.0 && v7 < 0.0 )
  {
    v1 = sub_53335(0.0);
  }
  else if ( v7 <= 1.0 )
  {
    v6 = v7 * 255.0;
    v1 = sub_53335(v6);
  }
  else
  {
    v1 = sub_53335(255.0);
  }
  a1[28] = v1;
  if ( v8 <= 1.0 && v8 < 0.0 )
  {
    v2 = sub_53335(0.0);
  }
  else if ( v8 <= 1.0 )
  {
    v5 = v8 * 255.0;
    v2 = sub_53335(v5);
  }
  else
  {
    v2 = sub_53335(255.0);
  }
  a1[29] = v2;
  if ( v9 <= 1.0 && v9 < 0.0 )
  {
    v4 = 0.0;
  }
  else if ( v9 <= 1.0 )
  {
    v4 = v9 * 255.0;
  }
  else
  {
    v4 = 255.0;
  }
  result = sub_53335(v4);
  a1[30] = result;
  return result;
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (00051FAD) --------------------------------------------------------
int __cdecl sub_51FAD(unsigned __int8 *a1)
{
  float v2[6]; // [esp+10h] [ebp-18h] BYREF

  v2[0] = (long double)a1[28] * 0.0039215689;
  v2[1] = (long double)a1[29] * 0.0039215689;
  v2[2] = (long double)a1[30] * 0.0039215689;
  return Scr_AddVector(v2);
}
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005201E) --------------------------------------------------------
int __cdecl sub_5201E(int a1)
{
  int result; // eax
  float v2; // [esp+8h] [ebp-10h]
  float v3; // [esp+10h] [ebp-8h]

  v3 = Scr_GetFloat(0);
  if ( v3 <= 1.0 && v3 < 0.0 )
  {
    v2 = 0.0;
  }
  else if ( v3 <= 1.0 )
  {
    v2 = v3 * 255.0;
  }
  else
  {
    v2 = 255.0;
  }
  result = sub_53335(v2);
  *(_BYTE *)(a1 + 31) = result;
  return result;
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (000520B6) --------------------------------------------------------
int __cdecl sub_520B6(int a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = (long double)*(unsigned __int8 *)(a1 + 31) * 0.0039215689;
  return Scr_AddFloat(LODWORD(v2));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (000520ED) --------------------------------------------------------
int __cdecl sub_520ED(int a1)
{
  int v1; // eax
  int result; // eax
  double v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetFloat(0);
  if ( v4 <= 0.0 )
  {
    v3 = v4;
    v1 = va("font scale was %g; should be > 0", SLOBYTE(v3));
    Scr_Error(v1);
  }
  result = LODWORD(v4);
  *(float *)(a1 + 12) = v4;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0005214C) --------------------------------------------------------
int __cdecl sub_5214C(int a1, int a2)
{
  return sub_51C38(a1, &off_ACFA0 + 5 * a2, (int)off_AD110, 3);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD110: using guessed type char *off_AD110[6];

//----- (0005219E) --------------------------------------------------------
int __cdecl sub_5219E(int a1, int a2)
{
  return sub_51D43(a1, (int)(&off_ACFA0 + 5 * a2), (int)off_AD110);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD110: using guessed type char *off_AD110[6];

//----- (000521F0) --------------------------------------------------------
int __cdecl sub_521F0(int a1, int a2)
{
  return sub_51C38(a1, &off_ACFA0 + 5 * a2, (int)off_AD11C, 3);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD11C: using guessed type char *off_AD11C[3];

//----- (00052242) --------------------------------------------------------
int __cdecl sub_52242(int a1, int a2)
{
  return sub_51D43(a1, (int)(&off_ACFA0 + 5 * a2), (int)off_AD11C);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD11C: using guessed type char *off_AD11C[3];

//----- (00052294) --------------------------------------------------------
int __cdecl sub_52294(int a1, int a2)
{
  return sub_51C38(a1, &off_ACFA0 + 5 * a2, (int)&off_AD128, 3);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD128: using guessed type void *off_AD128;

//----- (000522E6) --------------------------------------------------------
int __cdecl sub_522E6(int a1, int a2)
{
  return sub_51D43(a1, (int)(&off_ACFA0 + 5 * a2), (int)&off_AD128);
}
// ACFA0: using guessed type void *off_ACFA0;
// AD128: using guessed type void *off_AD128;

//----- (00052338) --------------------------------------------------------
int __cdecl Scr_GetHudElemField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  void **v4; // [esp+10h] [ebp-8h]

  v4 = &off_ACFA0 + 5 * a2;
  v3 = &g_hudelems[34 * a1];
  if ( v4[4] )
    result = ((int (__cdecl *)(_DWORD *, int))v4[4])(v3, a2);
  else
    result = Scr_GetGenericField(v3, v4[2], v4[1]);
  return result;
}
// 187F4: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// ACFA0: using guessed type void *off_ACFA0;

//----- (000523C7) --------------------------------------------------------
int __cdecl Scr_SetHudElemField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  void **v4; // [esp+10h] [ebp-8h]

  v4 = &off_ACFA0 + 5 * a2;
  v3 = &g_hudelems[34 * a1];
  if ( v4[3] )
    result = ((int (__cdecl *)(_DWORD *, int))v4[3])(v3, a2);
  else
    result = Scr_SetGenericField(v3, v4[2], v4[1]);
  return result;
}
// 189E4: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// ACFA0: using guessed type void *off_ACFA0;

//----- (00052456) --------------------------------------------------------
void **__cdecl Scr_FreeHudElemConstStrings(int a1)
{
  void **result; // eax
  void **i; // [esp+10h] [ebp-8h]

  for ( i = &off_ACFA0; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    if ( i[2] == &byte_5 )
      Scr_SetString((char *)i[1] + a1, 0);
  }
  return result;
}
// 5: using guessed type char;
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// ACFA0: using guessed type void *off_ACFA0;

//----- (000524AB) --------------------------------------------------------
int GScr_NewHudElem()
{
  int v1; // [esp+10h] [ebp-8h]

  v1 = HudElem_Alloc(1023, 0);
  if ( !v1 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F84: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 19064: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);

//----- (000524F9) --------------------------------------------------------
int GScr_NewClientHudElem()
{
  _DWORD *v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v1 = (_DWORD *)Scr_GetEntity(0);
  if ( !v1[88] )
    Scr_ParamError(0, "not a client");
  v2 = HudElem_Alloc(*v1, 0);
  if ( !v2 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v2);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17F84: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 19064: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);

//----- (00052579) --------------------------------------------------------
int GScr_NewTeamHudElem()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  __int16 v4; // [esp+Eh] [ebp-Ah]
  int v5; // [esp+10h] [ebp-8h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[2] )
  {
    v0 = HudElem_Alloc(1023, 2);
  }
  else if ( v4 == scr_const[4] )
  {
    v0 = HudElem_Alloc(1023, 1);
  }
  else if ( v4 == scr_const[76] )
  {
    v0 = HudElem_Alloc(1023, 3);
  }
  else
  {
    v1 = Scr_GetString(0);
    v2 = va("team \"%s\" should be \"allies\", \"axis\", or \"spectator\"", v1);
    Scr_ParamError(0, v2);
    v0 = HudElem_Alloc(1023, 0);
  }
  v5 = v0;
  if ( !v0 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v5);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17F84: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19064: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00052659) --------------------------------------------------------
void **GScr_AddFieldsForHudElems()
{
  void **result; // eax
  unsigned __int16 v1; // [esp+1Eh] [ebp-Ah]
  void **i; // [esp+20h] [ebp-8h]

  v1 = g_scr_data[214];
  for ( i = &off_ACFA0; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 0xAu:
      case 0xBu:
        Scr_AddClassField(
          v1,
          *i,
          (unsigned __int16)(-13107
                           * (((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_ACFA0 - 183814))) >> 2)));
        break;
      default:
        continue;
    }
  }
  return result;
}
// 18404: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// ACFA0: using guessed type void *off_ACFA0;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (000526F0) --------------------------------------------------------
int __cdecl sub_526F0(int a1)
{
  int result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]

  s2 = (char *)Scr_GetIString(0);
  sub_51908(&g_hudelems[34 * a1]);
  g_hudelems[34 * a1] = 1;
  result = G_LocalizedStringIndex(s2);
  g_hudelems[34 * a1 + 26] = result;
  return result;
}
// 16C04: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);

//----- (00052779) --------------------------------------------------------
int __cdecl sub_52779(int a1)
{
  char *v1; // eax
  int v2; // eax
  int v3; // eax
  int result; // eax
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]
  float *v11; // [esp+20h] [ebp-8h]

  v5 = 1.0;
  v6 = 1.0;
  v10 = Scr_GetNumParam();
  if ( v10 != 1 && v10 != 3 && v10 != 5 )
    Scr_Error(
      "USAGE: <hudelem> setShader(\"shadername\"[, optional_width, optional_height,optional_right_texcoord,optional_bottom_texcoord]);");
  v11 = (float *)&g_hudelems[34 * a1];
  v1 = (char *)Scr_GetString(0);
  v7 = G_ShaderIndex(v1);
  if ( v10 == 1 )
  {
    v9 = 0;
    v8 = 0;
  }
  else
  {
    v9 = Scr_GetInt(1);
    if ( v9 < 0 )
    {
      v2 = va("width %i < 0", v9);
      Scr_ParamError(1, v2);
    }
    v8 = Scr_GetInt(2);
    if ( v8 < 0 )
    {
      v3 = va("height %i < 0", v8);
      Scr_ParamError(2, v3);
    }
    if ( v10 == 5 )
    {
      v6 = Scr_GetFloat(3);
      v5 = Scr_GetFloat(4);
    }
  }
  sub_51908(v11);
  *(_DWORD *)v11 = 3;
  *((_DWORD *)v11 + 14) = v7;
  *((_DWORD *)v11 + 12) = v9;
  *((_DWORD *)v11 + 13) = v8;
  v11[28] = v6;
  result = LODWORD(v5);
  v11[29] = v5;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (000528EA) --------------------------------------------------------
int __cdecl sub_528EA(int a1, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int result; // eax
  float v6; // [esp+0h] [ebp-18h]
  double v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  if ( Scr_GetNumParam() != 1 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds);\n", a3);
    Scr_Error(v3);
  }
  v9 = &g_hudelems[34 * a1];
  v6 = Scr_GetFloat(0) * 1000.0;
  v8 = sub_53373(v6);
  if ( v8 <= 0 && a2 != 5 )
  {
    v7 = (long double)v8 * 0.001;
    v4 = va("time %g should be > 0", SLOBYTE(v7));
    Scr_ParamError(0, v4);
  }
  sub_51908(v9);
  *v9 = a2;
  result = level[123] + v8;
  v9[23] = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (000529C5) --------------------------------------------------------
int __cdecl sub_529C5(int a1, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  float v10; // [esp+0h] [ebp-38h]
  float v11; // [esp+0h] [ebp-38h]
  double v12; // [esp+4h] [ebp-34h]
  double v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]
  int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  _DWORD *v20; // [esp+30h] [ebp-8h]

  v19 = Scr_GetNumParam();
  if ( v19 != 3 && v19 != 5 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds, total_clock_time_in_seconds, shadername[, width, height]);\n", a3);
    Scr_Error(v3);
  }
  v20 = &g_hudelems[34 * a1];
  v10 = Scr_GetFloat(0) * 1000.0;
  v18 = sub_53373(v10);
  if ( v18 <= 0 && a2 != 9 )
  {
    v12 = (long double)v18 * 0.001;
    v4 = va("time %g should be > 0", SLOBYTE(v12));
    Scr_ParamError(0, v4);
  }
  v11 = Scr_GetFloat(1) * 1000.0;
  v17 = sub_53373(v11);
  if ( v17 <= 0 )
  {
    v13 = (long double)v17 * 0.001;
    v5 = va("duration %g should be > 0", SLOBYTE(v13));
    Scr_ParamError(1, v5);
  }
  v6 = (char *)Scr_GetString(2);
  v16 = G_ShaderIndex(v6);
  if ( v19 == 3 )
  {
    v15 = 0;
    v14 = 0;
  }
  else
  {
    v15 = Scr_GetInt(3);
    if ( v15 < 0 )
    {
      v7 = va("width %i < 0", v15);
      Scr_ParamError(3, v7);
    }
    v14 = Scr_GetInt(4);
    if ( v14 < 0 )
    {
      v8 = va("height %i < 0", v14);
      Scr_ParamError(4, v8);
    }
  }
  sub_51908(v20);
  *v20 = a2;
  v20[23] = level[123] + v18;
  v20[24] = v17;
  v20[14] = v16;
  v20[12] = v15;
  result = v14;
  v20[13] = v14;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00052BC1) --------------------------------------------------------
int __cdecl sub_52BC1(int a1)
{
  return sub_528EA(a1, 4, (char)"setTimer");
}

//----- (00052BF6) --------------------------------------------------------
int __cdecl sub_52BF6(int a1)
{
  return sub_528EA(a1, 5, (char)"setTimerUp");
}

//----- (00052C2B) --------------------------------------------------------
int __cdecl sub_52C2B(int a1)
{
  return sub_528EA(a1, 6, (char)"setTenthsTimer");
}

//----- (00052C60) --------------------------------------------------------
int __cdecl sub_52C60(int a1)
{
  return sub_528EA(a1, 7, (char)"setTenthsTimerUp");
}

//----- (00052C95) --------------------------------------------------------
int __cdecl sub_52C95(int a1)
{
  return sub_529C5(a1, 8, (char)"setClock");
}

//----- (00052CCA) --------------------------------------------------------
int __cdecl sub_52CCA(int a1)
{
  return sub_529C5(a1, 9, (char)"setClockUp");
}

//----- (00052CFF) --------------------------------------------------------
int __cdecl sub_52CFF(int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetFloat(0);
  sub_51908(&g_hudelems[34 * a1]);
  g_hudelems[34 * a1] = 2;
  result = LODWORD(v2);
  *(float *)&g_hudelems[34 * a1 + 25] = v2;
  return result;
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00052D7E) --------------------------------------------------------
int __cdecl sub_52D7E(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = &g_hudelems[34 * a1];
  v7 = Scr_GetFloat(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v6 = v7;
      v2 = va("fade time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v7;
    v1 = va("fade time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8[9] = level[123];
  v4 = v7 * 1000.0;
  v8[10] = sub_53335(v4);
  result = v8[7];
  v8[8] = result;
  return result;
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (00052E6C) --------------------------------------------------------
int __cdecl sub_52E6C(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  _DWORD *v10; // [esp+1Ch] [ebp-Ch]

  v10 = &g_hudelems[34 * a1];
  if ( Scr_GetNumParam() != 3 )
    Scr_Error("hudelem scaleOverTime(time_in_seconds, new_width, new_height)");
  v9 = Scr_GetFloat(0);
  if ( v9 > 0.0 )
  {
    if ( v9 > 60.0 )
    {
      v6 = v9;
      v2 = va("scale time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v9;
    v1 = va("scale time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8 = Scr_GetInt(1);
  v7 = Scr_GetInt(2);
  v10[17] = level[123];
  v4 = v9 * 1000.0;
  v10[18] = sub_53335(v4);
  v10[15] = v10[12];
  v10[16] = v10[13];
  v10[12] = v8;
  result = v7;
  v10[13] = v7;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00052FAE) --------------------------------------------------------
int __cdecl sub_52FAE(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = &g_hudelems[34 * a1];
  v7 = Scr_GetFloat(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v6 = v7;
      v2 = va("move time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v7;
    v1 = va("move time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8[21] = level[123];
  v4 = v7 * 1000.0;
  v8[22] = sub_53335(v4);
  v8[19] = v8[1];
  result = v8[2];
  v8[20] = result;
  return result;
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (000530A8) --------------------------------------------------------
_DWORD *__cdecl sub_530A8(int a1)
{
  return sub_5197B(&g_hudelems[34 * a1]);
}

//----- (000530E1) --------------------------------------------------------
int __cdecl sub_530E1(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = &g_hudelems[34 * a1];
  if ( *v2 )
    result = HudElem_Free(v2);
  else
    result = Scr_Error("tried to free invalid hud element\n");
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 19254: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (00053138) --------------------------------------------------------
int __cdecl HudElem_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0xD; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_AD0A0 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_AD0A0 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_AD0A4 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// AD0A0: using guessed type char *off_AD0A0;
// AD0A4: using guessed type int (__cdecl *off_AD0A4)(int);

//----- (000531B3) --------------------------------------------------------
_DWORD *__cdecl HudElem_UpdateClient(_DWORD *a1, int a2, char a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+18h] [ebp-20h] BYREF
  _DWORD *v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]

  if ( (a3 & 1) != 0 )
    memset(a1 + 2463, 0, 0x1E84u);
  if ( (a3 & 2) != 0 )
    memset(a1 + 510, 0, 0x1E84u);
  v7 = 0;
  v6 = 0;
  result = g_hudelems;
  v4 = g_hudelems;
  v8 = 0;
  while ( v8 <= 0x7FF )
  {
    if ( *v4 && (!v4[32] || v4[32] == a1[4463]) && (v4[31] == 1023 || v4[31] == a2) )
    {
      if ( v4[33] )
      {
        if ( (a3 & 1) != 0 )
        {
          v5 = &a1[31 * v7++ + 2463];
          if ( v7 <= 63 )
            goto LABEL_18;
        }
      }
      else if ( (a3 & 2) != 0 )
      {
        v5 = &a1[31 * v6++ + 510];
        if ( v6 <= 63 )
        {
LABEL_18:
          qmemcpy(v5, v4, 0x7Cu);
          goto LABEL_19;
        }
      }
    }
LABEL_19:
    ++v8;
    result = &v4;
    v4 += 34;
  }
  return result;
}

//----- (00053335) --------------------------------------------------------
int __cdecl sub_53335(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (00053373) --------------------------------------------------------
int __cdecl sub_53373(float a1)
{
  return (int)ceil(a1);
}

//----- (000533B1) --------------------------------------------------------
void sub_533B1()
{
  ;
}

//----- (000533B8) --------------------------------------------------------
int __cdecl Fill_Clip(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+18h] [ebp-10h]

  v4 = BG_AmmoForWeapon(a2);
  result = BG_ClipForWeapon(a2);
  v3 = result;
  if ( a2 > 0 )
  {
    result = BG_GetNumWeapons();
    if ( a2 <= result )
    {
      v6 = *(_DWORD *)(a1 + 4 * v3 + 820);
      v5 = BG_GetAmmoClipSize(v3) - v6;
      result = v5;
      if ( v5 > *(_DWORD *)(a1 + 4 * v4 + 308) )
      {
        result = *(_DWORD *)(a1 + 4 * v4 + 308);
        v5 = result;
      }
      if ( v5 )
      {
        *(_DWORD *)(a1 + 4 * v4 + 308) -= v5;
        result = *(_DWORD *)(a1 + 4 * v3 + 820) + v5;
        *(_DWORD *)(a1 + 4 * v3 + 820) = result;
      }
    }
  }
  return result;
}
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (00053495) --------------------------------------------------------
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+48h] [ebp+10h]

  v14 = BG_AmmoForWeapon(a2);
  v13 = BG_ClipForWeapon(a2);
  v12 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820);
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) = v11 + a3;
  if ( BG_WeaponIsClipOnly(a2) )
  {
    BG_GivePlayerWeapon(*(_DWORD *)(a1 + 352), a2);
    v12 = 1;
  }
  if ( a4 || v12 )
    Fill_Clip(*(_DWORD *)(a1 + 352), a2);
  if ( v12 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 352);
    if ( *(_DWORD *)(v4 + 4 * v14 + 308) > BG_GetAmmoTypeMax(v14) )
    {
      v5 = *(_DWORD *)(a1 + 352);
      *(_DWORD *)(v5 + 4 * v14 + 308) = BG_GetAmmoTypeMax(v14);
    }
  }
  v6 = *(_DWORD *)(a1 + 352);
  if ( *(_DWORD *)(v6 + 4 * v13 + 820) > BG_GetAmmoClipSize(v13) )
  {
    v7 = *(_DWORD *)(a1 + 352);
    *(_DWORD *)(v7 + 4 * v13 + 820) = BG_GetAmmoClipSize(v13);
  }
  if ( *(int *)(BG_GetInfoForWeapon(a2) + 512) < 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308)
         - v11;
  v15 = BG_GetMaxPickupableAmmo(*(_DWORD *)(a1 + 352), a2);
  if ( v15 >= 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308)
         - v11;
  if ( !BG_WeaponIsClipOnly(a2) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) += v15;
    if ( *(int *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) < 0 )
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308) = 0;
    return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308)
         - v11;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820) += v15;
  if ( *(int *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820) > 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v14 + 308)
         - v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v13 + 820) = 0;
  BG_TakePlayerWeapon(*(_DWORD *)(a1 + 352), a2);
  return 0;
}
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 180F4: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 19414: using guessed type _DWORD __cdecl Fill_Clip(_DWORD, _DWORD);
// 19434: using guessed type _DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD);

//----- (00053772) --------------------------------------------------------
int __cdecl sub_53772(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax

  if ( *(_DWORD *)(a1 + 608) )
    v2 = Add_Ammo(a2, *(_DWORD *)(*(_DWORD *)(a1 + 680) + 36), *(_DWORD *)(a1 + 608), 0);
  else
    v2 = Add_Ammo(a2, *(_DWORD *)(*(_DWORD *)(a1 + 680) + 36), *(_DWORD *)(*(_DWORD *)(a1 + 680) + 28), 0);
  if ( !v2 )
    return 0;
  if ( BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36)) )
  {
    v3 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36));
    v4 = va(aFGamePickupCli, *(_DWORD *)(v3 + 8));
  }
  else
  {
    v5 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36));
    v4 = va(aFGamePickupAmm, *(_DWORD *)(v5 + 8));
  }
  trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 0, v4);
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[88], 1);
  return 40;
}
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000538E7) --------------------------------------------------------
int __cdecl sub_538E7(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // esi
  int v21; // eax
  float v23; // [esp+0h] [ebp-C8h]
  char v24; // [esp+4h] [ebp-C4h]
  char v25; // [esp+4h] [ebp-C4h]
  int v26; // [esp+30h] [ebp-98h]
  float v27; // [esp+38h] [ebp-90h]
  int v28; // [esp+3Ch] [ebp-8Ch]
  int v29[2]; // [esp+40h] [ebp-88h] BYREF
  float v30; // [esp+48h] [ebp-80h]
  float v31; // [esp+50h] [ebp-78h] BYREF
  int v32; // [esp+54h] [ebp-74h] BYREF
  int v33[5]; // [esp+80h] [ebp-48h] BYREF
  int v34; // [esp+94h] [ebp-34h]
  int v35; // [esp+98h] [ebp-30h]
  int i; // [esp+9Ch] [ebp-2Ch]
  int v37; // [esp+A0h] [ebp-28h]
  _DWORD *v38; // [esp+A4h] [ebp-24h]
  float *v39; // [esp+A8h] [ebp-20h]
  int v40; // [esp+ACh] [ebp-1Ch]
  char v41[4]; // [esp+B0h] [ebp-18h]
  int v42; // [esp+B4h] [ebp-14h]
  int v43; // [esp+B8h] [ebp-10h]
  int v44; // [esp+BCh] [ebp-Ch]

  v42 = 0;
  v39 = 0;
  *(_DWORD *)v41 = *(_DWORD *)(a1[170] + 36);
  v38 = (_DWORD *)BG_GetInfoForWeapon(*(_DWORD *)v41);
  if ( (int)a1[152] >= 0 )
  {
    if ( !a1[152] )
    {
      i = v38[221];
      v37 = v38[220];
      if ( i < v37 )
      {
        i = v37;
        v37 = v38[221];
      }
      if ( i || v37 )
      {
        if ( i >= 0 )
        {
          if ( i == v37 )
            v26 = v37;
          else
            v26 = rand() % (i - v37) + v37;
          a1[152] = v26;
          if ( (int)a1[152] <= 0 )
            a1[152] = 0;
        }
        else
        {
          a1[152] = 0;
        }
      }
      else
      {
        v27 = ((long double)rand() / 2147483600.0 + 1.0) * 0.5;
        v4 = BG_ClipForWeapon(*(_DWORD *)v41);
        v23 = (long double)(BG_GetAmmoClipSize(v4) - 1) * v27;
        a1[152] = sub_56A7D(v23) + 1;
      }
    }
    v5 = BG_AmmoForWeapon(*(_DWORD *)v41);
    if ( a1[152] > BG_GetAmmoTypeMax(v5) )
    {
      v6 = BG_AmmoForWeapon(*(_DWORD *)v41);
      a1[152] = BG_GetAmmoTypeMax(v6);
    }
    v44 = a1[152];
  }
  else
  {
    v44 = 0;
  }
  if ( (int)a1[183] >= 0 )
  {
    if ( !a1[183] )
    {
      if ( (int)a1[152] >= 0 )
      {
        v7 = BG_ClipForWeapon(*(_DWORD *)v41);
        a1[183] = BG_GetAmmoClipSize(v7);
        if ( a1[183] > a1[152] )
          a1[183] = a1[152];
        a1[152] -= a1[183];
        v44 = a1[152];
      }
      else
      {
        a1[183] = 0;
      }
    }
    v8 = BG_ClipForWeapon(*(_DWORD *)v41);
    if ( a1[183] > BG_GetAmmoClipSize(v8) )
    {
      v9 = BG_ClipForWeapon(*(_DWORD *)v41);
      a1[183] = BG_GetAmmoClipSize(v9);
    }
    v43 = a1[183];
  }
  else
  {
    v43 = 0;
  }
  v42 = Com_BitCheck(*(_DWORD *)(a2 + 352) + 1332, *(_DWORD *)v41);
  if ( !v42 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 352) + 216) )
    {
      if ( !Com_BitCheck(*(_DWORD *)(a2 + 352) + 1332, *(_DWORD *)(*(_DWORD *)(a2 + 352) + 216)) )
        return 0;
      if ( !BG_IsPlayerWeaponInSlot(*(_DWORD *)(a2 + 352), *(_DWORD *)(*(_DWORD *)(a2 + 352) + 216), 1) )
      {
        v10 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 352) + 216));
        if ( !BG_GetStackSlotForWeapon(
                *(_DWORD *)(a2 + 352),
                *(_DWORD *)(*(_DWORD *)(a2 + 352) + 216),
                *(_DWORD *)(v10 + 132))
          && !BG_GetEmptySlotForWeapon(*(_DWORD *)(a2 + 352), *(_DWORD *)v41) )
        {
          Com_Printf(
            "WARNING: cannot swap out a debug weapon (can result from too many weapons given to the player)\n",
            v24);
          return 0;
        }
      }
    }
    if ( !BG_GetEmptySlotForWeapon(*(_DWORD *)(a2 + 352), *(_DWORD *)v41) )
    {
      v11 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 352) + 216));
      if ( !BG_GetStackSlotForWeapon(*(_DWORD *)(a2 + 352), *(_DWORD *)v41, *(_DWORD *)(v11 + 132)) )
      {
        if ( v38[33] == *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 352) + 216)) + 132) )
        {
          v39 = (float *)Drop_Weapon(a2, *(_DWORD *)(*(_DWORD *)(a2 + 352) + 216), 0);
        }
        else if ( v38[33] == 3 || v38[33] == 4 || v38[33] == 5 || v38[33] == 6 || v38[33] == 7 )
        {
          v39 = (float *)Drop_Weapon(a2, *(char *)(v38[33] + *(_DWORD *)(a2 + 352) + 1348), 0);
        }
        else
        {
          for ( i = 1; i <= 2; ++i )
          {
            v37 = *(char *)(i + *(_DWORD *)(a2 + 352) + 1348);
            v35 = BG_AmmoForWeapon(*(_DWORD *)v41);
            v34 = BG_ClipForWeapon(*(_DWORD *)v41);
            if ( !*(_DWORD *)(*(_DWORD *)(a2 + 352) + 4 * v35 + 308)
              && !*(_DWORD *)(*(_DWORD *)(a2 + 352) + 4 * v34 + 820) )
            {
              v39 = (float *)Drop_Weapon(a2, v37, 0);
              break;
            }
          }
          if ( i > 2 )
          {
            v12 = va("f \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", v25);
            trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 0, v12);
            return 0;
          }
        }
        if ( v39 )
        {
          if ( (a1[99] & 0x10) != 0 )
          {
            v33[0] = a1[79];
            v33[1] = a1[80];
            v33[2] = a1[81];
            G_SetOrigin(v39, v33);
            G_SetAngle(v39, a1 + 82);
            trap_LinkEntity(v39);
          }
          else
          {
            v29[0] = (int)v39[79];
            v29[1] = (int)v39[80];
            v30 = v39[81];
            v30 = v30 - 256.0;
            trap_Trace(&v31, v39 + 79, v39 + 66, v39 + 69, v29, *(_DWORD *)v39, *((_DWORD *)v39 + 104));
            if ( v31 < 1.0 )
            {
              G_SetOrigin(v39, &v32);
              trap_LinkEntity(v39);
            }
          }
        }
        else if ( !BG_GetEmptySlotForWeapon(*(_DWORD *)(a2 + 352), *(_DWORD *)v41) )
        {
          return 0;
        }
      }
    }
    BG_GivePlayerWeapon(*(_DWORD *)(a2 + 352), *(_DWORD *)v41);
    if ( !a4 )
    {
      v13 = va("a %i", v41[0]);
      trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 1, v13);
    }
  }
  if ( v42 )
  {
    *a3 = 150;
    v44 += v43;
    v40 = Add_Ammo(a2, *(_DWORD *)v41, v44, 0);
    if ( v40 )
    {
      if ( BG_WeaponIsClipOnly(*(_DWORD *)v41) )
        v14 = va(aFGamePickupCli, v38[2]);
      else
        v14 = va(aFGamePickupAmm, v38[2]);
      trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 0, v14);
    }
    if ( v40 != v44 )
    {
      a1[152] -= v40;
      if ( (int)a1[152] <= 0 )
      {
        a1[183] += a1[152];
        a1[152] = -1;
        if ( (int)a1[183] <= 0 )
          a1[183] = -1;
      }
      if ( ((int)a1[152] > 0 || (int)a1[183] > 0) && g_weaponAmmoPools[3] )
        return 0;
    }
  }
  else
  {
    if ( v43 >= 0 )
    {
      v15 = BG_ClipForWeapon(*(_DWORD *)v41);
      v16 = BG_GetAmmoClipSize(v15);
      if ( v43 > v16 )
      {
        v17 = BG_ClipForWeapon(*(_DWORD *)v41);
        v18 = BG_GetAmmoClipSize(v17);
        v44 += v43 - v18;
        v19 = BG_ClipForWeapon(*(_DWORD *)v41);
        v43 = BG_GetAmmoClipSize(v19);
      }
      v20 = *(_DWORD *)(a2 + 352);
      v21 = BG_ClipForWeapon(*(_DWORD *)v41);
      *(_DWORD *)(v20 + 4 * v21 + 820) = v43;
    }
    Add_Ammo(a2, *(_DWORD *)v41, v44, v43 == -1);
  }
  if ( v39 )
    Scr_AddEntity(v39);
  else
    Scr_AddUndefined();
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[88], 2);
  if ( (a1[98] & 8) != 0 )
    v28 = g_weaponRespawn[3];
  else
    v28 = -1;
  return v28;
}
// 53CD7: variable 'v24' is possibly undefined
// 53EC9: variable 'v25' is possibly undefined
// 16864: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 16914: using guessed type _DWORD __cdecl BG_GetStackSlotForWeapon(_DWORD, _DWORD, _DWORD);
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16C84: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17154: using guessed type int Scr_AddUndefined(void);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17C04: using guessed type _DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD);
// 17C14: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 17CC4: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 180F4: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00054361) --------------------------------------------------------
int __cdecl Pickup_Health(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 680) + 28) == 5 || *(_DWORD *)(*(_DWORD *)(a1 + 680) + 28) == 100 )
    v9 = 2 * *(_DWORD *)(*(_DWORD *)(a2 + 352) + 292);
  else
    v9 = *(_DWORD *)(*(_DWORD *)(a2 + 352) + 292);
  if ( *(_DWORD *)(a1 + 608) )
    v8 = *(_DWORD *)(a1 + 608);
  else
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 680) + 28);
  v7 = *(_DWORD *)(a2 + 576);
  *(_DWORD *)(a2 + 576) = v7
                        + (int)((long double)v8 * (long double)*(int *)(*(_DWORD *)(a2 + 352) + 292) * 0.0099999998);
  if ( *(_DWORD *)(a2 + 576) <= v9 )
  {
    v6 = (int)((long double)(100 * *(_DWORD *)(a2 + 576)) / (long double)*(int *)(*(_DWORD *)(a2 + 352) + 292));
    if ( v6 > 0 )
    {
      if ( v6 > 100 )
        v6 = 100;
    }
    else
    {
      v6 = 1;
    }
    v4 = (int)((long double)(100 * v7) / (long double)*(int *)(*(_DWORD *)(a2 + 352) + 292));
    if ( v4 <= 0 )
      v4 = 1;
    v5 = v8 + v4;
    if ( v5 > 100 )
      v5 = 100;
    if ( v6 != v5 )
      *(_DWORD *)(a2 + 576) = *(_DWORD *)(*(_DWORD *)(a2 + 352) + 292) * v5 / 100;
  }
  else
  {
    *(_DWORD *)(a2 + 576) = v9;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 352) + 284) = *(_DWORD *)(a2 + 576);
  v2 = va(aFGamePickupHea, v8);
  trap_SendServerCommand(1852331867 * ((a2 - (int)g_entities) >> 2), 0, v2);
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[88], 1);
  return -1;
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000545DB) --------------------------------------------------------
int __cdecl RespawnItem(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-24h]
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+30h] [ebp+8h]

  if ( *(_WORD *)(a1 + 488) )
  {
    if ( !*(_DWORD *)(a1 + 628) )
      G_Error("RespawnItem: bad teammaster", v2);
    v6 = *(_DWORD *)(a1 + 628);
    v4 = 0;
    v7 = v6;
    while ( v7 )
    {
      v7 = *(_DWORD *)(v7 + 624);
      ++v4;
    }
    v3 = rand() % v4;
    v5 = 0;
    a1 = v6;
    while ( v5 < v3 )
    {
      a1 = *(_DWORD *)(a1 + 624);
      ++v5;
    }
  }
  *(_DWORD *)(a1 + 288) = 1081868296;
  *(_DWORD *)(a1 + 396) &= 0xFFFFEFFF;
  *(_DWORD *)(a1 + 248) &= 0xFFFFFFFE;
  trap_LinkEntity(a1);
  G_AddEvent(a1, 204, 0);
  result = a1;
  *(_DWORD *)(a1 + 524) = 0;
  return result;
}
// 54613: variable 'v2' is possibly undefined
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (00054700) --------------------------------------------------------
int __cdecl Touch_Item_Auto(int a1, int a2, int a3)
{
  *(_BYTE *)(a1 + 382) = 1;
  return Touch_Item(a1, a2, a3);
}
// 17404: using guessed type _DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD);

//----- (0005473B) --------------------------------------------------------
unsigned int __cdecl Touch_Item(int a1, int *a2, int a3)
{
  unsigned int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char v10; // al
  char v11; // al
  long double v12; // fst6
  char v13; // [esp+4h] [ebp-84h]
  char dest[72]; // [esp+30h] [ebp-58h] BYREF
  int v15; // [esp+78h] [ebp-10h] BYREF
  int v16; // [esp+7Ch] [ebp-Ch]

  v15 = 148;
  result = a1;
  if ( *(_BYTE *)(a1 + 382) )
  {
    *(_BYTE *)(a1 + 382) = 0;
    result = (unsigned int)a2;
    if ( a2[88] )
    {
      result = (unsigned int)a2;
      if ( a2[144] > 0 )
      {
        result = BG_CanItemBeGrabbed(a1, a2[88], a3);
        if ( result || a3 == 2 )
        {
          Q_strncpyz(dest, (char *)(a2[88] + 17908), 64);
          Q_CleanStr(dest);
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 680) + 32) == 1 )
          {
            BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36));
            v10 = trap_GetGuid(*a2);
            G_LogPrintf("Weapon;%d;%d;%s;%s\n", v10);
          }
          else
          {
            v11 = trap_GetGuid(*a2);
            G_LogPrintf("Item;%d;%d;%s;%s\n", v11);
          }
          result = *(_DWORD *)(*(_DWORD *)(a1 + 680) + 32);
          if ( result == 2 )
          {
            result = sub_53772(a1, (int)a2);
            v16 = result;
          }
          else if ( result > 2 )
          {
            if ( result != 3 )
              return result;
            result = Pickup_Health(a1, a2);
            v16 = result;
          }
          else
          {
            if ( result != 1 )
              return result;
            result = sub_538E7((_DWORD *)a1, (int)a2, &v15, a3);
            v16 = result;
          }
          if ( v16 )
          {
            if ( *(_BYTE *)(a1 + 378) )
            {
              v15 = 149;
              G_PlaySoundAlias(a2, *(unsigned __int8 *)(a1 + 378));
            }
            if ( *(_DWORD *)(a2[88] + 17752) )
              G_AddPredictableEvent(a2, v15, *(_DWORD *)(a1 + 140));
            else
              G_AddEvent(a2, v15, *(_DWORD *)(a1 + 140));
            if ( *(float *)(a1 + 632) == -1.0 )
            {
              *(_DWORD *)(a1 + 396) |= 0x1000u;
              *(_DWORD *)(a1 + 8) |= 0x80u;
              *(_DWORD *)(a1 + 288) = 0;
              result = a1;
              *(_DWORD *)(a1 + 408) = 1;
            }
            else
            {
              if ( *(float *)(a1 + 632) != 0.0 )
                v16 = (int)*(float *)(a1 + 632);
              if ( *(float *)(a1 + 636) != 0.0 )
              {
                v12 = (long double)rand() / 2147483600.0;
                v16 += (int)((v12 + v12 - 1.0) * *(float *)(a1 + 636));
                if ( v16 <= 0 )
                  v16 = 1;
              }
              if ( (*(_DWORD *)(a1 + 396) & 0x10) != 0 )
                *(_DWORD *)(a1 + 404) = 1;
              *(_DWORD *)(a1 + 248) |= 1u;
              *(_DWORD *)(a1 + 396) |= 0x1000u;
              *(_DWORD *)(a1 + 288) = 0;
              if ( v16 > 0 )
              {
                *(_DWORD *)(a1 + 524) = level[123] + 1000 * v16;
                *(_DWORD *)(a1 + 528) = RespawnItem;
              }
              else
              {
                *(_DWORD *)(a1 + 524) = 0;
                *(_DWORD *)(a1 + 528) = 0;
              }
              if ( (*(_DWORD *)(a1 + 396) & 0x10) != 0 )
              {
                *(_DWORD *)(a1 + 528) = G_FreeEntity;
                *(_DWORD *)(a1 + 524) = level[123] + 100;
              }
              result = trap_LinkEntity(a1);
            }
          }
        }
        else if ( !a3 )
        {
          result = *(_DWORD *)(a1 + 148);
          if ( result != *a2 )
          {
            result = *(_DWORD *)(*(_DWORD *)(a1 + 680) + 32);
            if ( result == 1 )
            {
              if ( Com_BitCheck(a2[88] + 1332, *(_DWORD *)(*(_DWORD *)(a1 + 680) + 36)) )
              {
                v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36));
                v5 = va(aFGamePickupCan, *(_DWORD *)(v4 + 8));
                result = trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v5);
              }
              else
              {
                result = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 680) + 36));
                if ( *(_DWORD *)(result + 132) <= 5u )
                {
                  result = *(_DWORD *)(result + 132);
                  switch ( result )
                  {
                    case 0u:
                      return result;
                    case 1u:
                    case 2u:
                      v6 = va("f \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v6);
                      break;
                    case 3u:
                      v7 = va("f \"GAME_CANT_GET_PISTOL_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v7);
                      break;
                    case 4u:
                      v8 = va("f \"GAME_CANT_GET_GRENADE_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v8);
                      break;
                    case 5u:
                      v9 = va("f \"GAME_CANT_GET_SMOKER_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v9);
                      break;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 548BF: variable 'v13' is possibly undefined
// 16CE4: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 17134: using guessed type _DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17B44: using guessed type _DWORD __cdecl G_AddPredictableEvent(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 19474: using guessed type _DWORD __cdecl Pickup_Health(_DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (00054D84) --------------------------------------------------------
int sub_54D84()
{
  int v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+18h] [ebp-20h]
  float v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v9 = 0;
  v6 = -1.0;
  v2 = g_maxDroppedWeapons[3];
  if ( v2 > 0 )
  {
    if ( v2 > 32 )
      v2 = 32;
  }
  else
  {
    v2 = 1;
  }
  for ( i = 0; i < v2; ++i )
  {
    v4 = level[i + 2145];
    if ( !v4 )
      return i;
    v8 = 9.9999803e11;
    for ( j = 0; j < level[121]; ++j )
    {
      v3 = level[0] + 18228 * j;
      if ( *(_DWORD *)(v3 + 17696) == 2 && !*(_DWORD *)(v3 + 17668) )
      {
        v7 = VectorDistanceSquared(&g_entities[211 * j + 79], v4 + 316);
        if ( v8 > (long double)v7 )
          v8 = v7;
      }
    }
    if ( v8 > (long double)v6 )
    {
      v6 = v8;
      v9 = i;
    }
  }
  v5 = level[v9 + 2145];
  *(_DWORD *)(v5 + 528) = G_FreeEntity;
  *(_DWORD *)(v5 + 524) = level[123] + 1;
  return v9;
}
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (00054F16) --------------------------------------------------------
int __cdecl DroppedItemClearOwner(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 148) = 1022;
  return result;
}

//----- (00054F28) --------------------------------------------------------
_DWORD *__cdecl LaunchItem(int a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  RegisterItem(-1431655765 * ((a1 - (int)&bg_itemlist) >> 4), 1);
  v5 = (_DWORD *)G_Spawn();
  level[sub_54D84() + 2145] = v5;
  v5[1] = 3;
  v5[35] = -1431655765 * ((a1 - (int)&bg_itemlist) >> 4);
  G_SetConstString(v5 + 97, *(_DWORD *)a1);
  v5[170] = a1;
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v5[66] = -1082130432;
    v5[67] = -1082130432;
    v5[68] = -1082130432;
    v5[69] = 1065353216;
    v5[70] = 1065353216;
    v5[71] = 1065353216;
  }
  else
  {
    v5[66] = -1082130432;
    v5[67] = -1082130432;
    v5[68] = 0;
    v5[69] = 1065353216;
    v5[70] = 1065353216;
    v5[71] = 0x40000000;
  }
  v5[62] |= 0x200u;
  v5[2] |= 0x10u;
  v5[72] = 1081868552;
  v5[104] = 129;
  v5[37] = a4;
  G_SetModel((int)v5, *(char **)(a1 + 8));
  G_DObjUpdate(v5);
  v5[135] = Touch_Item_Auto;
  G_SetOrigin(v5, a2);
  v5[3] = 5;
  v5[4] = level[123];
  v5[9] = *a3;
  v5[10] = a3[1];
  v5[11] = a3[2];
  v5[132] = DroppedItemClearOwner;
  v5[131] = level[123] + 1000;
  v5[99] = 16;
  trap_LinkEntity(v5);
  return v5;
}
// 167A4: using guessed type int G_Spawn(void);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 172F4: using guessed type _DWORD __cdecl G_SetConstString(_DWORD, _DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005518C) --------------------------------------------------------
int __cdecl Drop_Item(int a1, int a2, float a3, int a4)
{
  long double v4; // fst6
  int v6[2]; // [esp+10h] [ebp-38h] BYREF
  float v7; // [esp+18h] [ebp-30h]
  int v8[4]; // [esp+20h] [ebp-28h] BYREF
  float v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  v8[0] = *(_DWORD *)(a1 + 328);
  *(float *)&v8[1] = *(float *)(a1 + 332) + a3;
  v8[0] = 0;
  v8[2] = 0;
  if ( a4 )
  {
    v11 = 0.0;
    v10 = 0.0;
    v9 = 0.0;
  }
  else
  {
    AngleVectors(v8, &v9, 0, 0);
    v9 = v9 * 150.0;
    v10 = v10 * 150.0;
    v11 = v11 * 150.0;
    v4 = (long double)rand() / 2147483600.0;
    v11 = (v4 + v4 - 1.0) * 50.0 + 200.0 + v11;
  }
  v6[0] = *(_DWORD *)(a1 + 316);
  v6[1] = *(_DWORD *)(a1 + 320);
  v7 = *(float *)(a1 + 324);
  v7 = (*(float *)(a1 + 284) - *(float *)(a1 + 272)) * 0.5 + v7;
  return LaunchItem(a2, v6, &v9, *(_DWORD *)a1);
}
// 17104: using guessed type _DWORD __cdecl LaunchItem(_DWORD, _DWORD, _DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000552E6) --------------------------------------------------------
int __cdecl Drop_Weapon(int a1, int a2, int a3)
{
  long double v3; // fst6
  long double v4; // fst6
  long double v5; // fst6
  float v7; // [esp+0h] [ebp-118h]
  float v8; // [esp+0h] [ebp-118h]
  int v9; // [esp+30h] [ebp-E8h]
  int v10; // [esp+34h] [ebp-E4h]
  float v11; // [esp+38h] [ebp-E0h]
  int v12; // [esp+3Ch] [ebp-DCh]
  char v13[4]; // [esp+40h] [ebp-D8h] BYREF
  int v14; // [esp+44h] [ebp-D4h]
  int v15; // [esp+48h] [ebp-D0h]
  int v16; // [esp+4Ch] [ebp-CCh]
  float v17; // [esp+70h] [ebp-A8h] BYREF
  float v18; // [esp+74h] [ebp-A4h]
  float v19; // [esp+78h] [ebp-A0h]
  int v20[2]; // [esp+80h] [ebp-98h] BYREF
  float v21; // [esp+88h] [ebp-90h]
  char v22[48]; // [esp+90h] [ebp-88h] BYREF
  int v23; // [esp+C0h] [ebp-58h] BYREF
  float v24; // [esp+D0h] [ebp-48h]
  float v25; // [esp+D4h] [ebp-44h]
  float v26; // [esp+D8h] [ebp-40h]
  int v27; // [esp+ECh] [ebp-2Ch]
  int v28; // [esp+F0h] [ebp-28h]
  int v29; // [esp+F4h] [ebp-24h]
  int v30; // [esp+F8h] [ebp-20h]
  int v31; // [esp+FCh] [ebp-1Ch]
  int v32; // [esp+100h] [ebp-18h]
  int v33; // [esp+104h] [ebp-14h]
  int v34; // [esp+108h] [ebp-10h]
  int v35; // [esp+10Ch] [ebp-Ch]

  v30 = (int)&bg_itemlist + 48 * a2;
  if ( *(_DWORD *)(a1 + 352) && !Com_BitCheck(*(_DWORD *)(a1 + 352) + 1332, a2) )
    goto LABEL_3;
  v33 = BG_AmmoForWeapon(a2);
  v32 = BG_ClipForWeapon(a2);
  if ( *(_DWORD *)(BG_GetInfoForWeapon(a2) + 844) )
    return 0;
  if ( *(_DWORD *)(BG_GetInfoForWeapon(a2) + 832) && !*(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v32 + 820) )
  {
LABEL_3:
    BG_TakePlayerWeapon(*(_DWORD *)(a1 + 352), a2);
    v12 = 0;
  }
  else
  {
    v31 = Drop_Item(a1, v30, 0.0, 0);
    if ( *(_DWORD *)(a1 + 352) )
    {
      v35 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v33 + 308);
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v33 + 308) = 0;
      v34 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v32 + 820);
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v32 + 820) = 0;
      BG_TakePlayerWeapon(*(_DWORD *)(a1 + 352), a2);
    }
    else
    {
      v28 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 884);
      v27 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 880);
      if ( v28 < v27 )
      {
        v28 = v27;
        v27 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 884);
      }
      if ( v28 || v27 )
      {
        if ( v28 >= 0 )
        {
          if ( v28 == v27 )
            v10 = v27;
          else
            v10 = rand() % (v28 - v27) + v27;
          v35 = v10;
          if ( v10 > 0 )
          {
            v29 = BG_GetAmmoClipSize(v32);
            if ( v29 )
              v9 = rand() % v29;
            else
              v9 = 0;
            v34 = v9;
            if ( v9 < v35 )
            {
              v35 -= v34;
            }
            else
            {
              v34 = v35;
              v35 = 0;
            }
          }
          else
          {
            v35 = 0;
            v34 = 0;
          }
        }
        else
        {
          v35 = 0;
          v34 = 0;
        }
      }
      else
      {
        v11 = ((long double)rand() / 2147483600.0 + 1.0) * 0.5;
        v7 = (long double)(BG_GetAmmoClipSize(v32) - 1) * v11;
        v35 = sub_56A7D(v7) + 1;
        v8 = ((long double)rand() / 2147483600.0 * 0.5 + 0.25) * (long double)v35;
        v34 = sub_56A7D(v8);
        v35 -= v34;
      }
    }
    *(_DWORD *)(v31 + 608) = v35;
    *(_DWORD *)(v31 + 732) = v34;
    if ( !*(_DWORD *)(v31 + 608) )
      *(_DWORD *)(v31 + 608) = -1;
    if ( !*(_DWORD *)(v31 + 732) )
      *(_DWORD *)(v31 + 732) = -1;
    if ( a3 )
    {
      if ( G_DObjGetWorldTagMatrix(a1, a3, v22) )
      {
        v17 = *(float *)(a1 + 264) + *(float *)(a1 + 276);
        v18 = *(float *)(a1 + 268) + *(float *)(a1 + 280);
        v19 = *(float *)(a1 + 272) + *(float *)(a1 + 284);
        v17 = v17 * 0.5;
        v18 = v18 * 0.5;
        v19 = v19 * 0.5;
        v17 = v17 + *(float *)(a1 + 316);
        v18 = v18 + *(float *)(a1 + 320);
        v19 = v19 + *(float *)(a1 + 324);
        trap_TraceCapsule(v13, &v17, v31 + 264, v31 + 276, &v23, *(_DWORD *)a1, 1041);
        *(_DWORD *)(v31 + 24) = v14;
        *(_DWORD *)(v31 + 28) = v15;
        *(_DWORD *)(v31 + 32) = v16;
        *(_DWORD *)(v31 + 316) = v14;
        *(_DWORD *)(v31 + 320) = v15;
        *(_DWORD *)(v31 + 324) = v16;
        *(_DWORD *)(v31 + 16) = level[123];
        Axis4ToAngles(v22, v20);
      }
      else
      {
        v20[0] = *(_DWORD *)(a1 + 328);
        v20[1] = *(_DWORD *)(a1 + 332);
        v21 = *(float *)(a1 + 336);
      }
      v21 = v21 + 90.0;
      G_SetAngle(v31, a1 + 328);
      v3 = (long double)rand() / 2147483600.0;
      v24 = (v3 + v3 - 1.0) * 50.0;
      v4 = (long double)rand() / 2147483600.0;
      v25 = (v4 + v4 - 1.0) * 40.0;
      v5 = (long double)rand() / 2147483600.0;
      v26 = (v5 + v5 - 1.0) * 60.0;
      *(_DWORD *)(v31 + 48) = 2;
      *(_DWORD *)(v31 + 52) = level[123];
      *(float *)(v31 + 72) = v24;
      *(float *)(v31 + 76) = v25;
      *(float *)(v31 + 80) = v26;
    }
    v12 = v31;
  }
  return v12;
}
// 16954: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 180C4: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 18134: using guessed type _DWORD __cdecl Axis4ToAngles(_DWORD, _DWORD);
// 186B4: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 193E4: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000559AF) --------------------------------------------------------
int __cdecl Use_Item(int a1)
{
  return RespawnItem(a1);
}
// 187B4: using guessed type _DWORD __cdecl RespawnItem(_DWORD);

//----- (000559D2) --------------------------------------------------------
int __cdecl FinishSpawningItem(void *s)
{
  char v1; // al
  char v3[12]; // [esp+20h] [ebp-B8h] BYREF
  _BYTE v4[12]; // [esp+2Ch] [ebp-ACh] BYREF
  int v5[6]; // [esp+38h] [ebp-A0h] BYREF
  char v6[8]; // [esp+50h] [ebp-88h] BYREF
  float v7; // [esp+58h] [ebp-80h]
  int v8[2]; // [esp+60h] [ebp-78h] BYREF
  float v9; // [esp+68h] [ebp-70h]
  int v10; // [esp+70h] [ebp-68h] BYREF
  int v11; // [esp+74h] [ebp-64h]
  int v12; // [esp+78h] [ebp-60h]
  int v13; // [esp+80h] [ebp-58h] BYREF
  int v14; // [esp+84h] [ebp-54h]
  int v15; // [esp+88h] [ebp-50h]
  int v16; // [esp+90h] [ebp-48h] BYREF
  int v17; // [esp+94h] [ebp-44h]
  float v18; // [esp+98h] [ebp-40h]
  float v19; // [esp+A0h] [ebp-38h] BYREF
  _DWORD v20[9]; // [esp+A4h] [ebp-34h] BYREF
  unsigned __int16 v21; // [esp+C8h] [ebp-10h]
  char v22; // [esp+CFh] [ebp-9h]

  if ( (*((_DWORD *)s + 98) & 1) != 0 )
  {
    G_SetOrigin(s, (char *)s + 316);
  }
  else
  {
    if ( *(_DWORD *)(*((_DWORD *)s + 170) + 32) == 1 )
    {
      v13 = -1082130432;
      v14 = -1082130432;
      v15 = -1082130432;
      v10 = 1065353216;
      v11 = 1065353216;
      v12 = 1065353216;
    }
    else
    {
      v13 = -1082130432;
      v14 = -1082130432;
      v15 = 0;
      v10 = 1065353216;
      v11 = 1065353216;
      v12 = 0x40000000;
    }
    *((_DWORD *)s + 62) |= 0x200u;
    *((_DWORD *)s + 2) |= 0x10u;
    v16 = *((_DWORD *)s + 79);
    v17 = *((_DWORD *)s + 80);
    v18 = *((float *)s + 81) - 4096.0;
    trap_TraceCapsule(&v19, (char *)s + 316, &v13, &v10, &v16, *(_DWORD *)s, 1041);
    if ( v22 )
    {
      v8[0] = *((_DWORD *)s + 79);
      v8[1] = *((_DWORD *)s + 80);
      v9 = *((float *)s + 81);
      v9 = v9 - 15.0;
      v16 = *((_DWORD *)s + 79);
      v17 = *((_DWORD *)s + 80);
      v18 = *((float *)s + 81) - 4096.0;
      trap_TraceCapsule(&v19, v8, &v13, &v10, &v16, *(_DWORD *)s, 1041);
    }
    if ( v22 )
    {
      vtos((char *)s + 316);
      v1 = SL_ConvertToString(*((unsigned __int16 *)s + 194));
      G_Printf("FinishSpawningItem: %s startsolid at %s\n", v1);
      return G_FreeEntity(s);
    }
    *((_DWORD *)s + 31) = v21;
    G_SetOrigin(s, v20);
    if ( v19 < 1.0 )
    {
      v5[0] = v20[3];
      v5[1] = v20[4];
      v5[2] = v20[5];
      AngleVectors((char *)s + 328, v3, 0, 0);
      CrossProduct(v5, v3, v4);
      CrossProduct(v4, v5, v3);
      AxisToAngles(v3, v6);
      if ( bg_itemlist[12 * *((_DWORD *)s + 35) + 8] == 1 )
        v7 = v7 + 90.0;
      G_SetAngle(s, v6);
    }
  }
  return trap_LinkEntity(s);
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 177C4: using guessed type _DWORD __cdecl vtos(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00055D33) --------------------------------------------------------
_DWORD *ClearRegisteredItems()
{
  _DWORD *result; // eax

  memset(itemRegistered, 0, sizeof(itemRegistered));
  result = itemRegistered;
  itemRegistered[0] = 1;
  return result;
}

//----- (00055D75) --------------------------------------------------------
int SaveRegisteredItems()
{
  char v1; // [esp+13h] [ebp-135h]
  char *v2; // [esp+14h] [ebp-134h]
  char v3; // [esp+1Bh] [ebp-12Dh]
  char *v4; // [esp+1Ch] [ebp-12Ch]
  int v5; // [esp+20h] [ebp-128h]
  int v6; // [esp+24h] [ebp-124h]
  int v7; // [esp+28h] [ebp-120h]
  int i; // [esp+2Ch] [ebp-11Ch]
  char v9[280]; // [esp+30h] [ebp-118h] BYREF

  level[2993] = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  for ( i = 0; i < bg_numItems; ++i )
  {
    if ( itemRegistered[i] )
      v6 += 1 << v5;
    if ( ++v5 == 4 )
    {
      v4 = &v9[v7++];
      if ( v6 > 9 )
        v3 = v6 + 87;
      else
        v3 = v6 + 48;
      *v4 = v3;
      v6 = 0;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    v2 = &v9[v7++];
    if ( v6 > 9 )
      v1 = v6 + 87;
    else
      v1 = v6 + 48;
    *v2 = v1;
  }
  v9[v7] = 0;
  return trap_SetConfigstring(8, v9);
}
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (00055F2A) --------------------------------------------------------
_DWORD *__cdecl RegisterItem(int a1, int a2)
{
  _DWORD *result; // eax
  int v3; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  const char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]

  result = (_DWORD *)a1;
  if ( !itemRegistered[a1] )
  {
    if ( !level[8] )
    {
      v5 = (const char *)bg_itemlist[12 * a1 + 6];
      if ( (!v5 || !*v5) && a1 <= BG_GetNumWeapons() )
        v5 = *(const char **)(BG_GetInfoForWeapon(a1) + 4);
      if ( !v5 || !*v5 )
        v5 = "<<unknown>>";
      v3 = va("game tried to register the item '%s' after initialization finished\n", (char)v5);
      Scr_Error(v3);
    }
    itemRegistered[a1] = 1;
    if ( bg_itemlist[12 * a1 + 8] == 1 )
    {
      v6 = a1;
      do
      {
        itemRegistered[v6] = 1;
        v4 = BG_GetInfoForWeapon(v6);
        G_ModelIndex(*(char **)(v4 + 456));
        G_ModelIndex(*(char **)(v4 + 464));
        G_ModelIndex(*(char **)(v4 + 460));
        G_ModelIndex(*(char **)(v4 + 908));
        result = *(_DWORD **)(v4 + 876);
        v6 = (int)result;
        if ( !result )
          break;
        result = *(_DWORD **)(v4 + 876);
      }
      while ( v6 != a1 );
    }
    else
    {
      if ( bg_itemlist[12 * a1 + 2] )
        G_ModelIndex((char *)bg_itemlist[12 * a1 + 2]);
      result = &bg_itemlist[12 * a1 + 3];
      if ( *result )
        result = (_DWORD *)G_ModelIndex((char *)bg_itemlist[12 * a1 + 3]);
    }
    if ( a2 )
    {
      result = level;
      level[2993] = 1;
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00056128) --------------------------------------------------------
int __cdecl IsItemRegistered(int a1)
{
  return itemRegistered[a1];
}

//----- (00056146) --------------------------------------------------------
int (__cdecl *__cdecl G_SpawnItem(int a1, int a2))(void *s)
{
  int (__cdecl *result)(void *); // eax
  char *s2; // [esp+Ch] [ebp-Ch] BYREF

  G_SpawnFloat("random", (int)"0", a1 + 636);
  G_SpawnFloat("wait", (int)"0", a1 + 632);
  RegisterItem(-1431655765 * ((a2 - (int)bg_itemlist) >> 4), 0);
  *(_DWORD *)(a1 + 680) = a2;
  G_SetModel(a1, *(char **)(a2 + 8));
  if ( G_SpawnString("noise", 0, (int)&s2) )
    *(_BYTE *)(a1 + 378) = G_SoundAliasIndex(s2);
  *(_DWORD *)(a1 + 412) = 0;
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    *(_DWORD *)(a1 + 264) = -1082130432;
    *(_DWORD *)(a1 + 268) = -1082130432;
    *(_DWORD *)(a1 + 272) = -1082130432;
    *(_DWORD *)(a1 + 276) = 1065353216;
    *(_DWORD *)(a1 + 280) = 1065353216;
    *(_DWORD *)(a1 + 284) = 1065353216;
  }
  else
  {
    *(_DWORD *)(a1 + 264) = -1082130432;
    *(_DWORD *)(a1 + 268) = -1082130432;
    *(_DWORD *)(a1 + 272) = 0;
    *(_DWORD *)(a1 + 276) = 1065353216;
    *(_DWORD *)(a1 + 280) = 1065353216;
    *(_DWORD *)(a1 + 284) = 0x40000000;
  }
  *(_DWORD *)(a1 + 248) |= 0x200u;
  *(_DWORD *)(a1 + 8) |= 0x10u;
  *(_DWORD *)(a1 + 288) = 1081868552;
  *(_DWORD *)(a1 + 540) = Touch_Item_Auto;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 140) = -1431655765 * ((*(_DWORD *)(a1 + 680) - (int)bg_itemlist) >> 4);
  G_DObjUpdate(a1);
  *(_DWORD *)(a1 + 148) = 1022;
  *(_DWORD *)(a1 + 544) = Use_Item;
  *(_DWORD *)(a1 + 396) |= 0x2000u;
  if ( level[1499] )
  {
    G_SetAngle(a1, a1 + 328);
    *(_DWORD *)(a1 + 524) = level[123] + 200;
    result = FinishSpawningItem;
    *(_DWORD *)(a1 + 528) = FinishSpawningItem;
  }
  else
  {
    if ( (*(_DWORD *)(a1 + 392) & 1) == 0 )
    {
      *(_DWORD *)(a1 + 124) = 1023;
      if ( *(_DWORD *)(a2 + 32) == 1 )
        *(float *)(a1 + 336) = *(float *)(a1 + 336) + 90.0;
    }
    G_SetAngle(a1, a1 + 328);
    G_SetOrigin(a1, a1 + 316);
    result = (int (__cdecl *)(void *))trap_LinkEntity(a1);
  }
  return result;
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005644A) --------------------------------------------------------
int __cdecl G_BounceItem(int a1, int a2)
{
  int result; // eax
  char v3[8]; // [esp+30h] [ebp-78h] BYREF
  float v4; // [esp+38h] [ebp-70h]
  char v5[12]; // [esp+40h] [ebp-68h] BYREF
  _BYTE v6[12]; // [esp+4Ch] [ebp-5Ch] BYREF
  int v7[6]; // [esp+58h] [ebp-50h] BYREF
  int v8[5]; // [esp+70h] [ebp-38h] BYREF
  int v9; // [esp+84h] [ebp-24h]
  float v10; // [esp+88h] [ebp-20h]
  float v11; // [esp+8Ch] [ebp-1Ch]
  float v12; // [esp+90h] [ebp-18h] BYREF
  float v13; // [esp+94h] [ebp-14h]
  float v14; // [esp+98h] [ebp-10h]

  v9 = level[124] + (int)((long double)(level[123] - level[124]) * *(float *)a2);
  BG_EvaluateTrajectoryDelta(a1 + 12, v9, &v12);
  v11 = v12 * *(float *)(a2 + 16) + v13 * *(float *)(a2 + 20) + v14 * *(float *)(a2 + 24);
  *(float *)(a1 + 36) = v11 * -2.0 * *(float *)(a2 + 16) + v12;
  *(float *)(a1 + 40) = v11 * -2.0 * *(float *)(a2 + 20) + v13;
  *(float *)(a1 + 44) = v11 * -2.0 * *(float *)(a2 + 24) + v14;
  *(float *)(a1 + 36) = *(float *)(a1 + 36) * *(float *)(a1 + 412);
  *(float *)(a1 + 40) = *(float *)(a1 + 40) * *(float *)(a1 + 412);
  *(float *)(a1 + 44) = *(float *)(a1 + 44) * *(float *)(a1 + 412);
  if ( *(_BYTE *)(a2 + 47) )
  {
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    v8[0] = *(_DWORD *)(a1 + 316);
    v8[1] = *(_DWORD *)(a1 + 320);
    *(float *)&v8[2] = *(float *)(a1 + 324) - 128.0;
    if ( (*(_DWORD *)(a1 + 8) & 0x10) != 0 )
      trap_TraceCapsule(a2, a1 + 316, a1 + 264, a1 + 276, v8, *(_DWORD *)a1, 1041);
    else
      trap_Trace(a2, a1 + 316, a1 + 264, a1 + 276, v8, *(_DWORD *)a1, 1041);
  }
  if ( *(float *)(a2 + 24) <= 0.0 || *(float *)(a1 + 44) >= 40.0 )
  {
    *(float *)(a1 + 316) = *(float *)(a1 + 316) + *(float *)(a2 + 16);
    *(float *)(a1 + 320) = *(float *)(a1 + 320) + *(float *)(a2 + 20);
    *(float *)(a1 + 324) = *(float *)(a1 + 324) + *(float *)(a2 + 24);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
    result = level[123];
    *(_DWORD *)(a1 + 16) = result;
  }
  else
  {
    v10 = (long double)rand() / 2147483600.0 * 0.5 + 0.5;
    *(float *)(a2 + 12) = *(float *)(a2 + 12) + v10;
    G_SetOrigin(a1, a2 + 4);
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
    v7[0] = *(_DWORD *)(a2 + 16);
    v7[1] = *(_DWORD *)(a2 + 20);
    v7[2] = *(_DWORD *)(a2 + 24);
    AngleVectors(a1 + 328, v5, 0, 0);
    CrossProduct(v7, v5, v6);
    CrossProduct(v6, v7, v5);
    AxisToAngles(v5, v3);
    if ( bg_itemlist[12 * *(_DWORD *)(a1 + 140) + 8] == 1 )
      v4 = v4 + 90.0;
    G_SetAngle(a1, v3);
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 191C4: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00056876) --------------------------------------------------------
void __cdecl G_RunItem(void *s)
{
  int v1; // [esp+28h] [ebp-50h]
  int v2[11]; // [esp+30h] [ebp-48h] BYREF
  char v3; // [esp+5Fh] [ebp-19h]
  char v4[24]; // [esp+60h] [ebp-18h] BYREF

  if ( *((_DWORD *)s + 31) == 1023 && *((_DWORD *)s + 3) != 5 )
  {
    *((_DWORD *)s + 3) = 5;
    *((_DWORD *)s + 4) = level[123];
  }
  if ( *((_DWORD *)s + 3) && *((_DWORD *)s + 3) != 8 )
  {
    BG_EvaluateTrajectory((char *)s + 12, level[123], v4);
    if ( *((_DWORD *)s + 104) )
      v1 = *((_DWORD *)s + 104);
    else
      v1 = 1169;
    if ( (*((_DWORD *)s + 2) & 0x10) != 0 )
      trap_TraceCapsule(v2, (char *)s + 316, (char *)s + 264, (char *)s + 276, v4, *((_DWORD *)s + 85), v1);
    else
      trap_Trace(v2, (char *)s + 316, (char *)s + 264, (char *)s + 276, v4, *((_DWORD *)s + 85), v1);
    *((_DWORD *)s + 79) = v2[1];
    *((_DWORD *)s + 80) = v2[2];
    *((_DWORD *)s + 81) = v2[3];
    if ( v3 )
      v2[0] = 0;
    trap_LinkEntity(s);
    G_RunThink(s);
    if ( *((_BYTE *)s + 364) && *(float *)v2 != 1.0 )
    {
      if ( trap_PointContents((char *)s + 316, -1, 0x80000000) )
        G_FreeEntity(s);
      else
        G_BounceItem(s, v2);
    }
  }
  else
  {
    G_RunThink(s);
  }
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17EB4: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 19194: using guessed type _DWORD __cdecl G_BounceItem(_DWORD, _DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00056A7D) --------------------------------------------------------
int __cdecl sub_56A7D(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (00056ABB) --------------------------------------------------------
void sub_56ABB()
{
  ;
}

//----- (00056AC0) --------------------------------------------------------
int __cdecl vmMain(int a1, int a2, unsigned int seed, int a4, int a5)
{
  int v7; // [esp+20h] [ebp-8h]

  v7 = 0;
  switch ( a1 )
  {
    case 1:
      return 5;
    case 2:
      G_InitGame(a2, seed, a4, a5);
      return v7;
    case 3:
      G_ShutdownGame(a2);
      return v7;
    case 4:
      return ClientConnect(a2, (unsigned __int16)seed);
    case 5:
      ClientBegin(a2);
      return v7;
    case 6:
      ClientUserinfoChanged(a2);
      return v7;
    case 7:
      ClientDisconnect(a2);
      return v7;
    case 8:
      ClientCommand(a2);
      return v7;
    case 9:
      ClientThink(a2);
      return v7;
    case 10:
      return GetFollowPlayerState(a2, seed);
    case 11:
      G_UpdateCvars();
      return v7;
    case 12:
      G_RunFrame(a2);
      return v7;
    case 13:
      return ConsoleCommand();
    case 14:
      return Scr_FarHook(a2);
    case 15:
      G_DObjCalcPose(level[1] + 844 * a2);
      return v7;
    case 16:
      return a2 >= 0 && a2 <= BG_GetNumWeapons();
    case 17:
      level[2142] = a2;
      return v7;
    case 18:
      return level[2142];
    case 19:
      return level[0] + 18228 * a2 + 17848;
    case 20:
      return *(_DWORD *)(level[0] + 18228 * a2 + 17680);
    case 21:
      *(_DWORD *)(level[0] + 18228 * a2 + 17680) = seed;
      return v7;
    case 22:
      return *(_DWORD *)(level[0] + 18228 * a2 + 17684);
    case 23:
      return level[2178];
    default:
      return -1;
  }
}
// 168F4: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 16A04: using guessed type _DWORD __cdecl Scr_FarHook(_DWORD);
// 16BA4: using guessed type int ConsoleCommand(void);
// 16F04: using guessed type _DWORD __cdecl G_DObjCalcPose(_DWORD);
// 17324: using guessed type int BG_GetNumWeapons(void);
// 17A04: using guessed type _DWORD __cdecl ClientDisconnect(_DWORD);
// 17BB4: using guessed type _DWORD __cdecl ClientThink(_DWORD);
// 18464: using guessed type _DWORD __cdecl G_RunFrame(_DWORD);
// 18474: using guessed type int G_UpdateCvars(void);
// 184B4: using guessed type _DWORD __cdecl ClientBegin(_DWORD);
// 186C4: using guessed type _DWORD __cdecl ClientConnect(_DWORD, _DWORD);
// 187D4: using guessed type _DWORD __cdecl ClientCommand(_DWORD);
// 18A34: using guessed type _DWORD __cdecl G_ShutdownGame(_DWORD);
// 18A54: using guessed type _DWORD __cdecl GetFollowPlayerState(_DWORD, _DWORD);

//----- (00056D04) --------------------------------------------------------
int G_Printf(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Printf(s);
}
// 17204: using guessed type _DWORD __cdecl trap_Printf(_DWORD);

//----- (00056D52) --------------------------------------------------------
_DWORD *G_DPrintf(char *format, ...)
{
  _DWORD *result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  result = g_developer;
  if ( g_developer[3] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    result = (_DWORD *)trap_Printf(s);
  }
  return result;
}
// 17204: using guessed type _DWORD __cdecl trap_Printf(_DWORD);

//----- (00056DAE) --------------------------------------------------------
int G_Error(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Error(s);
}
// 16924: using guessed type _DWORD __cdecl trap_Error(_DWORD);

//----- (00056DFC) --------------------------------------------------------
int G_Error_Localized(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Error_Localized(s);
}
// 18C14: using guessed type _DWORD __cdecl trap_Error_Localized(_DWORD);

//----- (00056E4A) --------------------------------------------------------
int __cdecl sub_56E4A(int a1, int a2)
{
  return (int)(*(float *)(a1 + 4) - *(float *)(a2 + 4));
}

//----- (00056E85) --------------------------------------------------------
int __cdecl G_GetActivateEnt(int a1, void *base)
{
  char v3[48]; // [esp+20h] [ebp-1128h] BYREF
  float v4; // [esp+50h] [ebp-10F8h]
  float v5; // [esp+54h] [ebp-10F4h]
  float v6; // [esp+58h] [ebp-10F0h]
  int v7; // [esp+64h] [ebp-10E4h]
  float v8; // [esp+68h] [ebp-10E0h]
  float v9; // [esp+6Ch] [ebp-10DCh]
  float v10; // [esp+70h] [ebp-10D8h]
  int v11; // [esp+74h] [ebp-10D4h]
  float v12; // [esp+78h] [ebp-10D0h]
  float v13; // [esp+7Ch] [ebp-10CCh]
  float v14; // [esp+80h] [ebp-10C8h]
  size_t nmemb; // [esp+84h] [ebp-10C4h]
  int i; // [esp+88h] [ebp-10C0h]
  int v17; // [esp+8Ch] [ebp-10BCh]
  float v18; // [esp+90h] [ebp-10B8h] BYREF
  float v19; // [esp+94h] [ebp-10B4h]
  float v20; // [esp+98h] [ebp-10B0h]
  float v21; // [esp+A0h] [ebp-10A8h] BYREF
  float v22; // [esp+A4h] [ebp-10A4h]
  float v23; // [esp+A8h] [ebp-10A0h]
  float v24; // [esp+B0h] [ebp-1098h] BYREF
  float v25; // [esp+B4h] [ebp-1094h]
  float v26; // [esp+B8h] [ebp-1090h]
  float v27[4]; // [esp+C0h] [ebp-1088h] BYREF
  float v28[7]; // [esp+D0h] [ebp-1078h] BYREF
  float *v29; // [esp+ECh] [ebp-105Ch]
  int v30[1024]; // [esp+F0h] [ebp-1058h] BYREF
  float v31; // [esp+10F0h] [ebp-58h] BYREF
  float v32; // [esp+10F4h] [ebp-54h]
  float v33; // [esp+10F8h] [ebp-50h]
  int v34; // [esp+110Ch] [ebp-3Ch]
  char v35[4]; // [esp+1110h] [ebp-38h] BYREF
  float v36; // [esp+1114h] [ebp-34h]
  float v37; // [esp+1118h] [ebp-30h]
  float v38; // [esp+111Ch] [ebp-2Ch]
  unsigned __int16 v39; // [esp+1138h] [ebp-10h]
  int v40; // [esp+1150h] [ebp+8h]

  v29 = 0;
  nmemb = 0;
  v13 = 0.75999999;
  v11 = 0;
  v34 = *(_DWORD *)(a1 + 352);
  AngleVectors(v34 + 232, &v31, 0, 0);
  CalcMuzzlePoint(a1, &v24);
  v28[0] = v24 - 192.0;
  v28[1] = v25 - 192.0;
  v28[2] = v26 - 96.0;
  v27[0] = v24 + 192.0;
  v27[1] = v25 + 192.0;
  v27[2] = v26 + 96.0;
  v17 = trap_EntitiesInBox(v28, v27, v30, 1024, &unk_200000);
  for ( i = 0; i < v17; ++i )
  {
    v29 = (float *)&g_entities[211 * v30[i]];
    if ( (float *)a1 != v29 && (*((_DWORD *)v29 + 1) == 3 || ((_DWORD)v29[72] & 0x200000) != 0) )
    {
      v14 = 128.0;
      if ( *((_DWORD *)v29 + 1) == 12 )
        v14 = 128.0;
      v21 = v29[73] + v29[76];
      v22 = v29[74] + v29[77];
      v23 = v29[75] + v29[78];
      v21 = v21 * 0.5;
      v22 = v22 * 0.5;
      v23 = v23 * 0.5;
      if ( *((_DWORD *)v29 + 1) == 12 )
      {
        v21 = v31 * v14 + v24;
        v22 = v32 * v14 + v25;
        v23 = v33 * v14 + v26;
        trap_Trace(v35, &v24, vec3_origin, vec3_origin, &v21, *(_DWORD *)(v34 + 212), 42008593);
        if ( v39 != *(_DWORD *)v29 )
          continue;
        v18 = v36 - v24;
        v19 = v37 - v25;
        v20 = v38 - v26;
      }
      else
      {
        v18 = v21 - v24;
        v19 = v22 - v25;
        v20 = v23 - v26;
      }
      v12 = VectorNormalize(&v18);
      if ( v12 <= (long double)v14 )
      {
        v10 = v18 * v31 + v19 * v32 + v20 * v33;
        if ( v10 > 0.0 && v13 <= (long double)v10 )
        {
          v9 = v14 + v14;
          v8 = 1.0 - (v10 - v13) / (1.0 - v13);
          *((float *)base + 2 * nmemb + 1) = v8 * v9;
          if ( *((_DWORD *)v29 + 1) == 3 && !BG_CanItemBeGrabbed(v29, *(_DWORD *)(a1 + 352), 0) )
          {
            *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + 10000.0;
            ++v11;
          }
          *((_DWORD *)base + 2 * nmemb) = v29;
          *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + v12;
          ++nmemb;
        }
      }
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_56E4A);
  nmemb -= v11;
  v7 = 0;
  for ( i = 0; i < (int)nmemb; ++i )
  {
    v40 = *((_DWORD *)base + 2 * i);
    if ( *(_DWORD *)(v40 + 4) == 12 )
      break;
    v21 = *(float *)(v40 + 292) + *(float *)(v40 + 304);
    v22 = *(float *)(v40 + 296) + *(float *)(v40 + 308);
    v23 = *(float *)(v40 + 300) + *(float *)(v40 + 312);
    v21 = v21 * 0.5;
    v22 = v22 * 0.5;
    v23 = v23 * 0.5;
    if ( *(_DWORD *)(v40 + 4) == 11 && G_DObjGetWorldTagMatrix(v40, "tag_aim", v3) )
    {
      v21 = v4;
      v22 = v5;
      v23 = v6;
    }
    trap_Trace(v35, &v24, vec3_origin, vec3_origin, &v21, *(_DWORD *)(v34 + 212), 8388625);
    if ( v39 != 1022 )
      break;
    *((float *)base + 2 * i + 1) = *((float *)base + 2 * i + 1) + 100000.0;
    ++v7;
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_56E4A);
  return nmemb - v7;
}
// 169E4: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 17134: using guessed type _DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000575BB) --------------------------------------------------------
int __cdecl G_CheckForCursorHints(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+14h] [ebp-2074h]
  int v4; // [esp+18h] [ebp-2070h] BYREF
  int v5; // [esp+1Ch] [ebp-206Ch]
  float v6[4]; // [esp+20h] [ebp-2068h] BYREF
  int v7[4]; // [esp+30h] [ebp-2058h] BYREF
  float v8[2]; // [esp+40h] [ebp-2048h] BYREF
  float v9; // [esp+48h] [ebp-2040h]
  int v10; // [esp+54h] [ebp-2034h]
  int i; // [esp+58h] [ebp-2030h]
  int v12; // [esp+5Ch] [ebp-202Ch]
  _DWORD base[2051]; // [esp+60h] [ebp-2028h] BYREF
  int v14; // [esp+206Ch] [ebp-1Ch]
  int v15; // [esp+2070h] [ebp-18h]
  int v16; // [esp+2074h] [ebp-14h]
  int v17; // [esp+2078h] [ebp-10h]
  int v18; // [esp+207Ch] [ebp-Ch]

  v18 = 0;
  v12 = 0;
  v14 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(v14 + 1476) = 0;
  *(_DWORD *)(v14 + 1480) = 0;
  *(_WORD *)(v14 + 1528) = 1023;
  result = a1;
  if ( *(int *)(a1 + 576) > 0 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 382) )
    {
      *(_DWORD *)(v14 + 1476) = 0;
      v17 = 0;
      *(_DWORD *)(v14 + 1480) = 0;
      v16 = 0;
      *(_DWORD *)(v14 + 1484) = -1;
      v15 = -1;
      v10 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 216)) + 128);
      result = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 12) & 0x20;
      if ( !result || v10 != 3 )
      {
        result = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x100000;
        if ( !result )
        {
          result = G_GetActivateEnt(a1, base);
          v12 = result;
          if ( v10 == 3 )
          {
            v5 = 0;
            v4 = 0;
            v7[0] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 232);
            v7[1] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 236);
            v7[0] = 0;
            v7[2] = 0;
            AngleVectors(v7, v6, 0, 0);
            v8[0] = v6[0] * 15.0 + *(float *)(a1 + 316);
            v8[1] = v6[1] * 15.0 + *(float *)(a1 + 320);
            v9 = v6[2] * 15.0 + *(float *)(a1 + 324);
            v9 = v9 + 1.0;
            v5 = trap_PointContents(v8, -1, &unk_404000);
            if ( v5 || G_CheckPointInsideTriggerMount(a1, v8, &v4) )
            {
              v17 = 7;
              v16 = v4;
              if ( **(_BYTE **)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 216)) + 1172) )
                v15 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 352) + 216)) + 1176);
            }
            *(_DWORD *)(v14 + 1476) = v17;
            *(_DWORD *)(v14 + 1480) = v16;
            result = v15;
            *(_DWORD *)(v14 + 1484) = v15;
          }
          if ( v12 )
          {
            for ( i = 0; ; ++i )
            {
              result = i;
              if ( i >= v12 )
                return result;
              v18 = base[2 * i];
              *(_WORD *)(v14 + 1528) = *(_WORD *)v18;
              if ( !v18 )
                goto LABEL_60;
              if ( *(_DWORD *)v18 == 1022 )
                break;
              if ( *(_DWORD *)(v18 + 352) )
                goto LABEL_60;
              if ( !*(_DWORD *)(v18 + 4) )
              {
                if ( *(_WORD *)(v18 + 388) == scr_const[89] )
                {
                  v17 = *(_DWORD *)(v18 + 224);
                  if ( *(_DWORD *)(v18 + 224) )
                  {
                    if ( *(_DWORD *)(v18 + 220) != 255 )
                      v15 = *(_DWORD *)(v18 + 220);
                  }
                }
                goto LABEL_57;
              }
              if ( *(_DWORD *)(v18 + 4) == 11 )
              {
                if ( G_IsTurretUsable(v18, a1) )
                {
                  v17 = 6;
                  if ( **(_BYTE **)(BG_GetInfoForWeapon(*(_DWORD *)(v18 + 204)) + 1172) )
                    v15 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(v18 + 204)) + 1176);
                  goto LABEL_57;
                }
              }
              else
              {
                if ( *(_DWORD *)(v18 + 4) != 12 )
                {
                  if ( *(_DWORD *)(v18 + 4) == 3 )
                  {
                    v5 = *(_DWORD *)(v18 + 680);
                    v3 = *(_DWORD *)(v5 + 32);
                    if ( v3 == 1 )
                    {
                      if ( Com_BitCheck(*(_DWORD *)(a1 + 352) + 1332, *(_DWORD *)(v5 + 36)) )
                        v2 = *(_DWORD *)(v5 + 36) + 138;
                      else
                        v2 = *(_DWORD *)(v5 + 36) + 10;
                      v17 = v2;
                    }
                    else if ( v3 )
                    {
                      if ( v3 == 2 )
                      {
                        v17 = *(_DWORD *)(v5 + 36) + 138;
                      }
                      else if ( v3 == 3 )
                      {
                        v17 = 8;
                      }
                    }
                  }
                  else if ( *(_DWORD *)(v18 + 4) == 5 )
                  {
                    if ( *(_WORD *)(v18 + 388) == scr_const[27] )
                    {
                      if ( *(_BYTE *)(v18 + 384) == 7 || *(_BYTE *)(v18 + 384) == 8 && *(char *)(v18 + 396) < 0 )
                      {
                        v17 = 4;
                        if ( *(_DWORD *)(v18 + 696) )
                          v17 = 5;
                      }
                    }
                    else if ( *(_WORD *)(v18 + 388) == scr_const[26]
                           && (!*(_BYTE *)(v18 + 384) || *(_BYTE *)(v18 + 384) == 1 && *(char *)(v18 + 396) < 0) )
                    {
                      v17 = 4;
                      if ( *(_DWORD *)(v18 + 696) )
                        v17 = 5;
                    }
                  }
LABEL_57:
                  if ( *(int *)(v18 + 224) > 0 && v17 )
                    v17 = *(_DWORD *)(v18 + 224);
LABEL_60:
                  *(_DWORD *)(v14 + 1476) = v17;
                  *(_DWORD *)(v14 + 1480) = v16;
                  *(_DWORD *)(v14 + 1484) = v15;
                  result = v14;
                  if ( !*(_DWORD *)(v14 + 1476) )
                  {
                    result = v14;
                    *(_WORD *)(v14 + 1528) = 1023;
                  }
                  return result;
                }
                if ( G_IsVehicleUsable(v18, a1) )
                {
                  v17 = 2;
                  v15 = *(_DWORD *)(*(_DWORD *)(v18 + 356) + 564);
                  goto LABEL_57;
                }
              }
            }
            v5 = v14 + 1488;
            if ( (*(_DWORD *)(v14 + 1516) & 8) != 0 && (*(_DWORD *)(v14 + 12) & 0x10) == 0 )
              v17 = 9;
            goto LABEL_60;
          }
        }
      }
    }
  }
  return result;
}
// 169A4: using guessed type _DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD);
// 174B4: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 18564: using guessed type _DWORD __cdecl G_IsVehicleUsable(_DWORD, _DWORD);
// 18D24: using guessed type _DWORD __cdecl G_CheckPointInsideTriggerMount(_DWORD, _DWORD, _DWORD);

//----- (00057C8B) --------------------------------------------------------
_DWORD *__cdecl G_CheckForPreventFriendlyFire(_DWORD *a1)
{
  _DWORD *result; // eax
  void *v2; // [esp+2Ch] [ebp-9Ch]
  float v3[9]; // [esp+30h] [ebp-98h] BYREF
  float v4[7]; // [esp+54h] [ebp-74h] BYREF
  float v5[4]; // [esp+70h] [ebp-58h] BYREF
  char v6[40]; // [esp+80h] [ebp-48h] BYREF
  unsigned __int16 v7; // [esp+A8h] [ebp-20h]
  _DWORD *v8; // [esp+BCh] [ebp-Ch]

  *(_DWORD *)(a1[88] + 18104) = 0;
  result = a1;
  if ( !*((_BYTE *)a1 + 382) )
  {
    CalcMuzzlePoints(a1, v3);
    if ( *(_DWORD *)(a1[88] + 216) && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1[88] + 216)) + 796) )
      v2 = &riflePriorityMap;
    else
      v2 = &bulletPriorityMap;
    v5[0] = v3[0] * 8192.0 + v4[0];
    v5[1] = v3[1] * 8192.0 + v4[1];
    v5[2] = v3[2] * 8192.0 + v4[2];
    result = (_DWORD *)trap_LocationalTrace(v6, v4, v5, *a1, 536870913, v2);
    if ( v7 <= 0x3FDu )
    {
      result = (_DWORD *)trap_LocationalTrace(v6, v4, v5, *a1, 578822145, v2);
      if ( v7 <= 0x3FDu )
      {
        v8 = &g_entities[211 * v7];
        result = (_DWORD *)*((unsigned __int16 *)v8 + 194);
        if ( (_WORD)result == scr_const[92] )
        {
          *(_DWORD *)(a1[88] + 18104) = v8;
          result = (_DWORD *)G_Trigger(v8, a1);
        }
      }
    }
  }
  return result;
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 179F4: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 18CD4: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);

//----- (00057E4F) --------------------------------------------------------
int G_FindTeams()
{
  int v1; // [esp+Ch] [ebp-1Ch]
  char v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  v2 = 0;
  v1 = 0;
  v4 = 1;
  v6 = &g_entities[211];
  while ( v4 < level[3] )
  {
    if ( *((_BYTE *)v6 + 364) && *((_WORD *)v6 + 244) && (v6[99] & 4) == 0 )
    {
      if ( *((_WORD *)v6 + 194) == scr_const[29] )
      {
        if ( (v6[98] & 8) == 0 )
          goto LABEL_18;
        v6[157] = v6;
      }
      ++v2;
      ++v1;
      v3 = v4 + 1;
      v5 = v6 + 211;
      while ( v3 < level[3] )
      {
        if ( *((_BYTE *)v5 + 364)
          && *((_WORD *)v5 + 244)
          && (v5[99] & 4) == 0
          && *((_WORD *)v6 + 244) == *((_WORD *)v5 + 244) )
        {
          ++v1;
          v5[156] = v6[156];
          v6[156] = v5;
          v5[157] = v6;
          v5[99] |= 4u;
          if ( *((_WORD *)v5 + 194) == scr_const[29] )
            trap_UnlinkEntity(v5);
        }
        ++v3;
        v5 += 211;
      }
    }
LABEL_18:
    ++v4;
    v6 += 211;
  }
  return G_Printf("%i teams with %i entities\n", v2);
}
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (00058034) --------------------------------------------------------
int G_RegisterCvars()
{
  int result; // eax
  int (**v1)[72]; // [esp+1Ch] [ebp-Ch]
  int v2; // [esp+20h] [ebp-8h]

  v2 = 0;
  v1 = &gameCvarTable;
  while ( v2 < off_AD134[0] )
  {
    trap_Cvar_Register(*v1, v1[1], v1[2], v1[3]);
    if ( *v1 )
      v1[4] = (int (*)[72])(**v1)[1];
    ++v2;
    v1 += 6;
  }
  result = Scr_IsValidGameType((char *)&g_gametype + 16);
  if ( !result )
  {
    G_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", 176);
    trap_Cvar_Set("g_gametype", "dm");
    result = trap_Cvar_Update(&g_gametype);
  }
  return result;
}
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 176E4: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 18444: using guessed type _DWORD __cdecl Scr_IsValidGameType(_DWORD);
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// AD134: using guessed type int off_AD134[3];
// AD140: using guessed type int (*gameCvarTable)[72];

//----- (0005810D) --------------------------------------------------------
int G_UpdateCvars()
{
  int result; // eax
  int v1; // eax
  int (**i)[72]; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = 0;
  for ( i = &gameCvarTable; ; i += 6 )
  {
    result = v3;
    if ( v3 >= off_AD134[0] )
      break;
    if ( *i )
    {
      trap_Cvar_Update(*i);
      if ( i[4] != (int (*)[72])(**i)[1] )
      {
        i[4] = (int (*)[72])(**i)[1];
        if ( i[5] )
        {
          v1 = va(aEGameServer, (char)i[1]);
          trap_SendServerCommand(-1, 0, v1);
        }
      }
    }
    ++v3;
  }
  return result;
}
// 176E4: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// AD134: using guessed type int off_AD134[3];
// AD140: using guessed type int (*gameCvarTable)[72];

//----- (000581CD) --------------------------------------------------------
int G_SetUICvars()
{
  char v1[264]; // [esp+10h] [ebp-108h] BYREF

  trap_Cvar_VariableStringBuffer("g_allowvote", v1, 256);
  trap_Cvar_Set("ui_allowvote", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMapRestart", v1, 256);
  trap_Cvar_Set("ui_allowVoteMapRestart", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMapRotate", v1, 256);
  trap_Cvar_Set("ui_allowVoteMapRotate", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTypeMap", v1, 256);
  trap_Cvar_Set("ui_allowVoteTypeMap", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMap", v1, 256);
  trap_Cvar_Set("ui_allowVoteMap", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteGameType", v1, 256);
  trap_Cvar_Set("ui_allowVoteGameType", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteKick", v1, 256);
  trap_Cvar_Set("ui_allowVoteKick", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteClientKick", v1, 256);
  trap_Cvar_Set("ui_allowVoteClientKick", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTempBanUser", v1, 256);
  trap_Cvar_Set("ui_allowVoteTempBanUser", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTempBanClient", v1, 256);
  trap_Cvar_Set("ui_allowVoteTempBanClient", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteDrawFriend", v1, 256);
  trap_Cvar_Set("ui_allowVoteDrawFriend", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteKillCam", v1, 256);
  trap_Cvar_Set("ui_allowVoteKillCam", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteFriendlyFire", v1, 256);
  trap_Cvar_Set("ui_allowVoteFriendlyFire", v1);
  trap_Cvar_VariableStringBuffer("scr_drawfriend", v1, 256);
  trap_Cvar_Set("ui_drawfriend", v1);
  trap_Cvar_VariableStringBuffer("scr_friendlyfire", v1, 256);
  trap_Cvar_Set("ui_friendlyfire", v1);
  trap_Cvar_VariableStringBuffer("scr_killcam", v1, 256);
  trap_Cvar_Set("ui_killcam", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutsAllowed", v1, 256);
  trap_Cvar_Set("ui_timeoutsAllowed", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutBank", v1, 256);
  trap_Cvar_Set("ui_timeoutBank", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutLength", v1, 256);
  trap_Cvar_Set("ui_timeoutLength", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutRecovery", v1, 256);
  return trap_Cvar_Set("ui_timeoutRecovery", v1);
}
// 16DF4: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);

//----- (0005864B) --------------------------------------------------------
_DWORD *G_FreeEntities()
{
  _DWORD *result; // eax
  _BYTE *s; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  s = g_entities;
  for ( i = 0; i < level[3]; ++i )
  {
    if ( s[364] )
      G_FreeEntity(s);
    s += 844;
  }
  result = g_entities;
  if ( byte_D2AD4[(_DWORD)g_entities] )
    result = (_DWORD *)G_FreeEntity((char *)&dword_D2968 + (_DWORD)g_entities);
  return result;
}
// D2968: using guessed type int dword_D2968;

//----- (000586CF) --------------------------------------------------------
_DWORD *__cdecl G_InitGame(int a1, unsigned int seed, int a3, int a4)
{
  int v4; // eax
  _DWORD *result; // eax
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+4h] [ebp-834h]
  char v8; // [esp+4h] [ebp-834h]
  char v9; // [esp+4h] [ebp-834h]
  char v10[1024]; // [esp+20h] [ebp-818h] BYREF
  char s[1036]; // [esp+420h] [ebp-418h] BYREF
  int i; // [esp+82Ch] [ebp-Ch]

  Swap_Init();
  G_Printf("------- Game Initialization -------\n", v6);
  G_Printf("gamename: %s\n", (unsigned __int8)&aCodUnitedOffen[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  G_Printf("gamedate: %s\n", (unsigned __int8)&aFeb102005[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  srand(seed);
  v4 = trap_Milliseconds();
  Rand_Init(v4);
  Scr_ParseGameTypeList();
  if ( !a3 || !a4 )
    G_RegisterCvars();
  G_ProcessIPBans();
  G_SetPlayerSize();
  memset(level, 0, 0x2EC8u);
  level[2182] = 1023;
  memset(bg, 0, 0xCu);
  memset(bgs, 0, (size_t)&unk_BAEF4);
  level[8] = 1;
  level[123] = a1;
  level[126] = a1;
  level[1490] = g_timeoutBank[3];
  level[1491] = g_timeoutBank[3];
  *(int *)((char *)&dword_A7AD8 + (_DWORD)bgs) = (int)trap_Com_SoundAliasString;
  *(int *)((char *)&dword_A7ADC + (_DWORD)bgs) = (int)G_AnimScriptSound;
  if ( g_log[16] )
  {
    if ( g_logSync[3] )
      trap_FS_FOpenFile(&g_log[16], &level[7], 3);
    else
      trap_FS_FOpenFile(&g_log[16], &level[7], 2);
    if ( level[7] )
    {
      trap_GetServerinfo(v10, 1024);
      G_LogPrintf("------------------------------------------------------------\n", v8);
      G_LogPrintf("InitGame: %s\n", (char)v10);
    }
    else
    {
      G_Printf("WARNING: Couldn't open logfile: %s\n", 16);
    }
  }
  else
  {
    G_Printf("Not logging to disk.\n", v7);
  }
  BG_SetupWeaponInfo();
  G_ParseScrVehicleInfo();
  GScr_LoadScripts();
  GScr_LoadConsts();
  trap_GetConfigstring(21, s, 1024);
  Info_SetValueForKey(s, "winner", (int)"0");
  trap_SetConfigstring(21, s);
  memset(g_entities, 0, (size_t)&unk_D3000);
  level[1] = g_entities;
  level[121] = g_maxclients[3];
  memset(&g_clients, 0, (size_t)&unk_11CD00);
  level[0] = &g_clients;
  for ( i = 0; i < level[121]; ++i )
    g_entities[211 * i + 88] = level[0] + 18228 * i;
  level[3] = 72;
  level[4] = 0;
  level[5] = 0;
  trap_LocateGameData(level[1], level[3], 844, level[0], 18228);
  G_ParseHitLocDmgTable();
  if ( !a3 )
    ClearRegisteredItems();
  G_InitVehiclePaths();
  G_InitScrVehicles();
  G_InitTurrets();
  G_SpawnEntitiesFromString();
  G_SetupVehiclePaths();
  G_SetupScrVehicles();
  G_FindTeams();
  G_SetUICvars();
  SaveRegisteredItems();
  G_setfog("0");
  trap_Cvar_Set("cg_atmos", "-1");
  G_InitObjectives();
  G_Printf("-----------------------------------\n", v9);
  Scr_InitSystem(1, level[123]);
  Scr_SetLoading(1);
  Scr_AllocGameVariable();
  Scr_LoadGameType();
  Scr_LoadLevel();
  Scr_StartupGameType();
  result = level;
  level[8] = 0;
  return result;
}
// 586F2: variable 'v6' is possibly undefined
// 588F4: variable 'v8' is possibly undefined
// 5891C: variable 'v7' is possibly undefined
// 58B16: variable 'v9' is possibly undefined
// 16824: using guessed type int G_SetUICvars(void);
// 16994: using guessed type int G_SetupScrVehicles(void);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 16E24: using guessed type int G_InitTurrets(void);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 16F64: using guessed type int Scr_LoadLevel(void);
// 16FA4: using guessed type _DWORD __cdecl trap_GetServerinfo(_DWORD, _DWORD);
// 17264: using guessed type int BG_SetupWeaponInfo(void);
// 173C4: using guessed type int trap_Milliseconds(void);
// 17514: using guessed type _DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17794: using guessed type int G_ParseScrVehicleInfo(void);
// 177E4: using guessed type int G_SetPlayerSize(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 179A4: using guessed type int G_FindTeams(void);
// 17BC4: using guessed type int G_ParseHitLocDmgTable(void);
// 17C54: using guessed type int GScr_LoadScripts(void);
// 17D74: using guessed type _DWORD __cdecl Rand_Init(_DWORD);
// 18034: using guessed type int Scr_ParseGameTypeList(void);
// 18084: using guessed type int G_SetupVehiclePaths(void);
// 18124: using guessed type int ClearRegisteredItems(void);
// 18454: using guessed type int G_InitVehiclePaths(void);
// 18574: using guessed type int G_ProcessIPBans(void);
// 18694: using guessed type _DWORD __cdecl Scr_SetLoading(_DWORD);
// 18704: using guessed type int G_InitObjectives(void);
// 18914: using guessed type int SaveRegisteredItems(void);
// 18AD4: using guessed type int Swap_Init(void);
// 18DA4: using guessed type int Scr_AllocGameVariable(void);
// 19184: using guessed type int GScr_LoadConsts(void);
// 191D4: using guessed type int Scr_StartupGameType(void);
// 19264: using guessed type _DWORD __cdecl Scr_InitSystem(_DWORD, _DWORD);
// 19334: using guessed type int Scr_LoadGameType(void);
// 19344: using guessed type int G_SpawnEntitiesFromString(void);
// 194A4: using guessed type int G_RegisterCvars(void);
// 19534: using guessed type int G_InitScrVehicles(void);
// 74828: using guessed type int __cdecl trap_Com_SoundAliasString(int);
// A7AD8: using guessed type int dword_A7AD8;
// A7ADC: using guessed type int dword_A7ADC;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00058B6D) --------------------------------------------------------
int __cdecl G_ShutdownGame(int a1)
{
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  char v4; // [esp+4h] [ebp-14h]

  if ( a1 )
    G_Printf("==== RestartGame ====\n", v2);
  else
    G_Printf("==== ShutdownGame ====\n", v2);
  if ( level[7] )
  {
    if ( a1 )
      G_LogPrintf("RestartGame:\n", v3);
    else
      G_LogPrintf("ShutdownGame:\n", v3);
    G_LogPrintf("------------------------------------------------------------\n", v4);
    trap_FS_FCloseFile(level[7]);
  }
  G_FreeEntities();
  HudElem_DestroyAll();
  G_FreeScrVehicles();
  G_FreeVehiclePaths();
  if ( Scr_IsSystemActive(1) )
  {
    if ( !level[2142] )
      trap_FreeClientScriptPers();
    Scr_SetString(&level[2183], 0);
    Scr_FreeGameVariable(level[2142] == 0);
    Scr_ShutdownSystem(1);
  }
  GScr_FreeScripts();
  Scr_FreeScripts(1);
  return trap_FreeWeaponInfoMemory(0);
}
// 58B8E: variable 'v2' is possibly undefined
// 58BBE: variable 'v3' is possibly undefined
// 58BDC: variable 'v4' is possibly undefined
// 168A4: using guessed type int GScr_FreeScripts(void);
// 16B14: using guessed type _DWORD __cdecl Scr_FreeScripts(_DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 17EA4: using guessed type _DWORD __cdecl Scr_ShutdownSystem(_DWORD);
// 17EC4: using guessed type int G_FreeEntities(void);
// 180E4: using guessed type int G_FreeScrVehicles(void);
// 18A74: using guessed type int trap_FreeClientScriptPers(void);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 18F94: using guessed type int HudElem_DestroyAll(void);
// 19014: using guessed type int G_FreeVehiclePaths(void);
// 19524: using guessed type _DWORD __cdecl trap_FreeWeaponInfoMemory(_DWORD);
// 19814: using guessed type _DWORD __cdecl Scr_FreeGameVariable(_DWORD);

//----- (00058C90) --------------------------------------------------------
int Com_Error(int a1, char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return G_Error("%s", (char)s);
}

//----- (00058CE8) --------------------------------------------------------
int Com_Printf(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return G_Printf("%s", (char)s);
}

//----- (00058D40) --------------------------------------------------------
_DWORD *Com_DPrintf(char *format, ...)
{
  _DWORD *result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  result = g_developer;
  if ( g_developer[3] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    result = (_DWORD *)G_Printf("%s", (char)s);
  }
  return result;
}

//----- (00058DA4) --------------------------------------------------------
_DWORD *SendScoreboardMessageToAllIntermissionClients()
{
  _DWORD *result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = level;
  if ( level[132] )
  {
    for ( i = 0; i < level[121]; ++i )
    {
      v1 = level[0] + 18228 * i;
      if ( *(_DWORD *)(v1 + 17696) == 2 && *(_DWORD *)(v1 + 4) == 5 )
        DeathmatchScoreboardMessage(&g_entities[211 * i]);
    }
    result = level;
    level[132] = 0;
  }
  return result;
}
// 19164: using guessed type _DWORD __cdecl DeathmatchScoreboardMessage(_DWORD);

//----- (00058E44) --------------------------------------------------------
int __cdecl sub_58E44(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-10h]
  _DWORD *v4; // [esp+4h] [ebp-Ch]
  _DWORD *v5; // [esp+8h] [ebp-8h]

  v5 = (_DWORD *)(level[0] + 18228 * *a1);
  v4 = (_DWORD *)(level[0] + 18228 * *a2);
  if ( v5[4424] == 1 )
    return 1;
  if ( v4[4424] == 1 )
    return -1;
  if ( v5[4463] == 3 && v4[4463] == 3 )
  {
    if ( v5 >= v4 )
      v3 = v5 > v4;
    else
      v3 = -1;
  }
  else if ( v5[4463] == 3 )
  {
    v3 = 1;
  }
  else if ( v4[4463] == 3 )
  {
    v3 = -1;
  }
  else if ( v5[4421] <= v4[4421] )
  {
    if ( v5[4421] >= v4[4421] )
    {
      if ( v5[4422] >= v4[4422] )
        v3 = v5[4422] > v4[4422];
      else
        v3 = -1;
    }
    else
    {
      v3 = 1;
    }
  }
  else
  {
    v3 = -1;
  }
  return v3;
}

//----- (00058FAF) --------------------------------------------------------
_DWORD *CalculateRanks()
{
  _DWORD *result; // eax
  int i; // [esp+10h] [ebp-8h]

  level[134] = 0;
  level[715] = 0;
  for ( i = 0; i < level[121]; ++i )
  {
    if ( *(_DWORD *)(level[0] + 18228 * i + 17696) )
    {
      level[level[134]++ + 135] = i;
      if ( *(_DWORD *)(level[0] + 18228 * i + 17852) != 3 && *(_DWORD *)(level[0] + 18228 * i + 17696) == 2 )
        ++level[715];
    }
  }
  qsort(&level[135], level[134], 4u, (__compar_fn_t)sub_58E44);
  result = level;
  level[132] = 1;
  return result;
}

//----- (000590E1) --------------------------------------------------------
int ExitLevel()
{
  char v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  trap_SendConsoleCommand(2, "map_rotate\n");
  level[128] = 0;
  level[129] = 0;
  for ( i = 0; i < g_maxclients[3]; ++i )
  {
    v2 = level[0] + 18228 * i;
    if ( *(_DWORD *)(v2 + 17696) == 2 )
      *(_DWORD *)(v2 + 17684) = 0;
  }
  for ( j = 0; j < g_maxclients[3]; ++j )
  {
    if ( *(_DWORD *)(level[0] + 18228 * j + 17696) == 2 )
      *(_DWORD *)(level[0] + 18228 * j + 17696) = 1;
  }
  return G_LogPrintf("ExitLevel: executed\n", v1);
}
// 591D8: variable 'v1' is possibly undefined
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);

//----- (000591E3) --------------------------------------------------------
_DWORD *G_LogPrintf(char *format, ...)
{
  _DWORD *result; // eax
  size_t v2; // eax
  char s[1024]; // [esp+30h] [ebp-818h] BYREF
  char v4[1036]; // [esp+430h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+83Ch] [ebp-Ch]
  va_list va; // [esp+854h] [ebp+Ch] BYREF

  va_start(va, format);
  result = level;
  if ( level[7] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    Com_sprintf(v4, 0x400u, "%3i:%i%i %s", level[123] / 1000 / 60);
    v2 = strlen(v4);
    result = (_DWORD *)trap_FS_Write(v4, v2, level[7]);
  }
  return result;
}
// 195E4: using guessed type _DWORD __cdecl trap_FS_Write(_DWORD, _DWORD, _DWORD);

//----- (00059347) --------------------------------------------------------
_DWORD *CheckVote()
{
  int v0; // eax
  _DWORD *result; // eax
  int v2; // [esp+Ch] [ebp-Ch]

  if ( level[712] )
  {
    if ( level[712] < trap_Milliseconds() )
    {
      level[712] = 0;
      v0 = va((char *)&off_A1341, 60);
      trap_SendConsoleCommand(2, v0);
    }
  }
  result = level;
  if ( level[711] )
  {
    if ( trap_Milliseconds() - level[711] < 0 )
    {
      v2 = level[715] / 2 + 1;
      if ( level[713] >= v2 )
      {
        trap_SendServerCommand(-1, 0, "e \"GAME_VOTEPASSED\"");
        level[712] = trap_Milliseconds() + 3000;
LABEL_10:
        level[711] = 0;
        return (_DWORD *)trap_SetConfigstring(16, &unk_A058A);
      }
      result = (_DWORD *)(level[715] - v2);
      if ( level[714] <= (int)result )
        return result;
    }
    trap_SendServerCommand(-1, 0, "e \"GAME_VOTEFAILED\"");
    goto LABEL_10;
  }
  return result;
}
// 173C4: using guessed type int trap_Milliseconds(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// A1341: using guessed type void *off_A1341;

//----- (000594D4) --------------------------------------------------------
_DWORD *CheckMatchTimeout()
{
  _DWORD *result; // eax
  int v1; // esi
  int v2; // eax
  char v3; // [esp+Ch] [ebp-Ch]

  if ( level[1496] && level[1496] < trap_Milliseconds() )
  {
    level[1496] = 0;
    trap_SetConfigstring(1909, &unk_A058A);
    result = (_DWORD *)trap_Cvar_Set("timescale", "1");
  }
  else
  {
    result = level;
    if ( level[1494] )
    {
      v1 = level[1494] + level[1495];
      result = (_DWORD *)trap_Milliseconds();
      if ( v1 <= (int)result )
      {
        Com_sprintf((char *)&level[1234], 0x400u, aPatch15Timeout_1, v3);
        if ( level[1497] == 2 )
          level[1490] -= level[1494];
        else
          level[1491] -= level[1494];
        level[1494] = 0;
        level[1496] = g_timeoutRecovery[3] + trap_Milliseconds();
        v2 = va("%i", g_timeoutRecovery[3]);
        trap_SetConfigstring(1909, v2);
        trap_SetConfigstring(1910, &level[1234]);
        result = (_DWORD *)trap_SendServerCommand(-1, 0, "e \"PATCH_1_5_TIMEOUT_EXPIRED\"");
      }
    }
  }
  return result;
}
// 595A7: variable 'v3' is possibly undefined
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 173C4: using guessed type int trap_Milliseconds(void);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000596A4) --------------------------------------------------------
int G_UpdateObjectiveToClients()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // [esp+0h] [ebp-1Ch]
  int v3; // [esp+4h] [ebp-18h]
  _DWORD *v4; // [esp+8h] [ebp-14h]
  int j; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int i; // [esp+14h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[121] )
      break;
    v6 = level[1] + 844 * i;
    if ( *(_BYTE *)(v6 + 364) )
    {
      v3 = *(_DWORD *)(v6 + 352);
      v2 = *(_DWORD *)(v3 + 17852);
      for ( j = 0; j <= 15; ++j )
      {
        v4 = &level[7 * j + 9];
        if ( *v4 && (!v4[5] || v4[5] == v2) )
        {
          v1 = (_DWORD *)(v3 + 28 * j + 1584);
          v1[2] = *v4;
          v1[3] = v4[1];
          v1[4] = v4[2];
          v1[5] = v4[3];
          v1[6] = v4[4];
          v1[7] = v4[5];
          v1[8] = v4[6];
        }
        else
        {
          *(_DWORD *)(v3 + 28 * j + 1592) = 0;
        }
      }
    }
  }
  return result;
}

//----- (000597E4) --------------------------------------------------------
int G_UpdateHudElemsToClients()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[121] )
      break;
    v1 = level[1] + 844 * i;
    if ( *(_BYTE *)(v1 + 364) )
      HudElem_UpdateClient(*(_DWORD *)(v1 + 352), *(_DWORD *)v1, 3);
  }
  return result;
}
// 18F74: using guessed type _DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD);

//----- (00059862) --------------------------------------------------------
int __cdecl G_RunThink(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)(a1 + 524);
  v3 = result;
  if ( result > 0 )
  {
    result = *(_DWORD *)(a1 + 524);
    if ( v3 <= level[123] )
    {
      *(_DWORD *)(a1 + 524) = 0;
      if ( !*(_DWORD *)(a1 + 528) )
        G_Error("NULL ent->think", v2);
      result = (*(int (__cdecl **)(int))(a1 + 528))(a1);
    }
  }
  return result;
}
// 598BD: variable 'v2' is possibly undefined

//----- (000598D9) --------------------------------------------------------
int *DebugDumpAnims()
{
  int *result; // eax

  result = g_dumpAnims;
  if ( g_dumpAnims[3] >= 0 )
  {
    result = g_dumpAnims;
    if ( g_dumpAnims[3] <= 1023 )
      result = (int *)trap_DObjDisplayAnim(level[1] + 844 * g_dumpAnims[3]);
  }
  return result;
}
// 196F4: using guessed type _DWORD __cdecl trap_DObjDisplayAnim(_DWORD);

//----- (0005992C) --------------------------------------------------------
int __cdecl G_XAnimUpdateEnt(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 364) )
      break;
    result = *(_DWORD *)(a1 + 396) & 0x4000;
    if ( result )
      break;
    result = G_DObjUpdateServerTime(a1, 1);
    if ( !result )
      break;
    Scr_RunCurrentThreads();
  }
  return result;
}
// 16974: using guessed type _DWORD __cdecl G_DObjUpdateServerTime(_DWORD, _DWORD);
// 185A4: using guessed type int Scr_RunCurrentThreads(void);

//----- (00059983) --------------------------------------------------------
int G_XAnimUpdate()
{
  int result; // eax
  float v1; // [esp+4h] [ebp-14h]
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  v2 = g_entities;
  for ( i = 0; i < level[3]; ++i )
  {
    if ( *((_BYTE *)v2 + 364) )
    {
      v1 = (long double)(int)level[125] * 0.001;
      trap_DObjInitServerTime(v2, LODWORD(v1));
    }
    v2 += 211;
  }
  v3 = g_entities;
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= level[3] )
      break;
    G_XAnimUpdateEnt(v3);
    v3 += 211;
  }
  return result;
}
// 17A24: using guessed type _DWORD __cdecl trap_DObjInitServerTime(_DWORD, _DWORD);
// 183D4: using guessed type _DWORD __cdecl G_XAnimUpdateEnt(_DWORD);

//----- (00059A35) --------------------------------------------------------
void *__cdecl sub_59A35(void *s)
{
  void *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // edx

  result = (void *)*((_DWORD *)s + 105);
  if ( result != (void *)level[122] )
  {
    *((_DWORD *)s + 105) = level[122];
    if ( !*((_DWORD *)s + 88) )
    {
      if ( (*((_DWORD *)s + 99) & 0x1000) != 0 )
        v2 = *((_DWORD *)s + 2) | 0x80;
      else
        v2 = *((_DWORD *)s + 2) & 0xFFFFFF7F;
      *((_DWORD *)s + 2) = v2;
    }
    if ( level[123] - *((_DWORD *)s + 100) > 300 )
    {
      if ( *((_DWORD *)s + 101) )
        return (void *)G_FreeEntity(s);
      if ( *((_DWORD *)s + 102) )
      {
        *((_DWORD *)s + 102) = 0;
        trap_UnlinkEntity(s);
      }
    }
    v3 = (*((_DWORD *)s + 2) & 0x10) != 0 ? *((_DWORD *)s + 62) | 0x200 : *((_DWORD *)s + 62) & 0xFFFFFDFF;
    *((_DWORD *)s + 62) = v3;
    result = s;
    if ( !*((_DWORD *)s + 101) )
    {
      if ( *((_DWORD *)s + 1) == 4 )
        return (void *)G_RunMissile(s);
      if ( *((_DWORD *)s + 1) == 3 )
      {
        if ( *((_DWORD *)s + 189) )
        {
          G_GeneralLink(s);
          return (void *)G_RunThink(s);
        }
        return (void *)G_RunItem(s);
      }
      if ( *((_BYTE *)s + 365) )
        return (void *)G_RunItem(s);
      if ( *((_DWORD *)s + 1) == 5 || *((_DWORD *)s + 1) == 8 )
      {
        result = (void *)G_RunMover(s);
      }
      else if ( *((_DWORD *)s + 88) )
      {
        result = (void *)G_RunClient(s);
      }
      else
      {
        result = (void *)G_RunThink(s);
      }
    }
  }
  return result;
}
// 17614: using guessed type _DWORD __cdecl G_RunMover(_DWORD);
// 17EB4: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 186A4: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);
// 18D94: using guessed type _DWORD __cdecl G_RunClient(_DWORD);

//----- (00059C21) --------------------------------------------------------
int __cdecl G_RunFrame(int a1)
{
  unsigned __int16 *v1; // ecx
  int v2; // eax
  char s[1028]; // [esp+10h] [ebp-428h] BYREF
  int v5; // [esp+414h] [ebp-24h]
  unsigned __int16 *v6; // [esp+418h] [ebp-20h]
  char v7[5]; // [esp+41Fh] [ebp-19h]
  _DWORD *v8; // [esp+424h] [ebp-14h]
  void *v9; // [esp+428h] [ebp-10h]
  int v10[3]; // [esp+42Ch] [ebp-Ch]

  ++level[122];
  level[124] = level[123];
  level[123] = a1;
  level[125] = level[123] - level[124];
  bg[0] = level[123];
  bg[1] = level[123];
  bg[2] = level[125];
  G_UpdateCvars();
  memset(s, 0, 0x400u);
  v7[0] = 0;
  do
  {
    v7[4] = 0;
    *(_DWORD *)v7 = (unsigned __int8)(v7[0] + 1);
    for ( v10[0] = 0; v10[0] < level[2968]; ++v10[0] )
    {
      v6 = (unsigned __int16 *)&level[3 * v10[0] + 2200];
      v5 = *v6;
      v9 = &g_entities[211 * v5];
      if ( *((_DWORD *)v9 + 196) == *((_DWORD *)v6 + 1) )
      {
        v8 = &g_entities[211 * v6[1]];
        if ( v8[196] == *((_DWORD *)v6 + 2) )
        {
          if ( s[v5] == v7[0] )
          {
            *(_DWORD *)&v7[1] = 1;
            continue;
          }
          s[v5] = v7[0];
          Scr_AddEntity(v8);
          Scr_Notify(v9, scr_const[88], 1);
        }
      }
      --level[2968];
      --v10[0];
      v1 = v6;
      v2 = 3 * level[2968];
      *(_DWORD *)v6 = level[v2 + 2200];
      *((_DWORD *)v1 + 1) = level[v2 + 2201];
      *((_DWORD *)v1 + 2) = level[v2 + 2202];
    }
    Scr_RunCurrentThreads();
  }
  while ( *(_DWORD *)&v7[1] );
  level[2968] = 0;
  G_XAnimUpdate();
  Scr_SetTime(level[123]);
  if ( *(float *)&level[2972] != g_bounds_width[2] || *(float *)&level[2973] != *(float *)&g_bounds_height_standing[2] )
  {
    level[2972] = LODWORD(g_bounds_width[2]);
    level[2973] = g_bounds_height_standing[2];
    G_SetPlayerSize();
    v9 = g_entities;
    v10[0] = 0;
    while ( v10[0] <= 63 )
    {
      if ( *((_BYTE *)v9 + 364) )
      {
        *((_DWORD *)v9 + 66) = playerMins[0];
        *((_DWORD *)v9 + 67) = playerMins[1];
        *((_DWORD *)v9 + 68) = playerMins[2];
        *((_DWORD *)v9 + 69) = playerMaxs[0];
        *((_DWORD *)v9 + 70) = playerMaxs[1];
        *((_DWORD *)v9 + 71) = playerMaxs[2];
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1372) = *((_DWORD *)v9 + 66);
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1376) = *((_DWORD *)v9 + 67);
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1380) = *((_DWORD *)v9 + 68);
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1384) = *((_DWORD *)v9 + 69);
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1388) = *((_DWORD *)v9 + 70);
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1392) = *((_DWORD *)v9 + 71);
        trap_LinkEntity(v9);
      }
      ++v10[0];
      v9 = (char *)v9 + 844;
    }
  }
  if ( *(float *)&level[2974] != *(float *)&bg_viewheight_standing[2]
    || *(float *)&level[2975] != *(float *)&bg_viewheight_crouched[2]
    || *(float *)&level[2976] != *(float *)&bg_viewheight_prone[2] )
  {
    level[2974] = bg_viewheight_standing[2];
    level[2975] = bg_viewheight_crouched[2];
    level[2976] = bg_viewheight_prone[2];
    v9 = g_entities;
    v10[0] = 0;
    while ( v10[0] <= 63 )
    {
      if ( *((_BYTE *)v9 + 364) )
      {
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1396) = bg_viewheight_prone[3];
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1400) = bg_viewheight_crouched[3];
        *(_DWORD *)(*((_DWORD *)v9 + 88) + 1404) = bg_viewheight_standing[3];
      }
      ++v10[0];
      v9 = (char *)v9 + 844;
    }
  }
  v9 = g_entities;
  v10[0] = 0;
  while ( v10[0] < level[3] )
  {
    if ( *((_BYTE *)v9 + 364) )
    {
      if ( *((_DWORD *)v9 + 189) )
        sub_59A35(**((void ***)v9 + 189));
      sub_59A35(v9);
    }
    ++v10[0];
    v9 = (char *)v9 + 844;
  }
  G_UpdateObjectiveToClients();
  G_UpdateHudElemsToClients();
  G_VehicleClientThink();
  v9 = g_entities;
  v10[0] = 0;
  while ( v10[0] < level[121] )
  {
    if ( *((_BYTE *)v9 + 364) )
      ClientEndFrame(v9);
    ++v10[0];
    v9 = (char *)v9 + 844;
  }
  CheckTeamStatus();
  CheckVote();
  CheckMatchTimeout();
  SendScoreboardMessageToAllIntermissionClients();
  if ( g_listEntity[3] )
  {
    for ( v10[0] = 0; v10[0] <= 1023; ++v10[0] )
    {
      SL_ConvertToString(LOWORD(g_entities[211 * v10[0] + 97]));
      G_Printf("%4i: %s\n", v10[0]);
    }
    trap_Cvar_Set("g_listEntity", "0");
  }
  if ( level[2993] )
    SaveRegisteredItems();
  return DebugDumpAnims();
}
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 16E84: using guessed type int CheckVote(void);
// 17464: using guessed type int CheckMatchTimeout(void);
// 17554: using guessed type int DebugDumpAnims(void);
// 175D4: using guessed type int G_UpdateHudElemsToClients(void);
// 176B4: using guessed type int SendScoreboardMessageToAllIntermissionClients(void);
// 177E4: using guessed type int G_SetPlayerSize(void);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17F14: using guessed type int CheckTeamStatus(void);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 183C4: using guessed type int G_UpdateObjectiveToClients(void);
// 18474: using guessed type int G_UpdateCvars(void);
// 185A4: using guessed type int Scr_RunCurrentThreads(void);
// 18914: using guessed type int SaveRegisteredItems(void);
// 18AC4: using guessed type int G_VehicleClientThink(void);
// 18D04: using guessed type int G_XAnimUpdate(void);
// 18E24: using guessed type _DWORD __cdecl Scr_SetTime(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 197D4: using guessed type _DWORD __cdecl ClientEndFrame(_DWORD);

//----- (0005A2CF) --------------------------------------------------------
void sub_5A2CF()
{
  ;
}

//----- (0005A2D4) --------------------------------------------------------
int __cdecl SP_info_camp(int a1)
{
  return G_SetOrigin(a1, a1 + 316);
}
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005A303) --------------------------------------------------------
int __cdecl SP_info_null(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005A326) --------------------------------------------------------
int __cdecl SP_info_notnull(int a1)
{
  return G_SetOrigin(a1, a1 + 316);
}
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005A355) --------------------------------------------------------
int __cdecl SP_light(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005A378) --------------------------------------------------------
int __cdecl TeleportPlayer(_DWORD *a1, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1[88] + 17668) )
  {
    *(_DWORD *)(G_TempEntity(a1[88] + 20, 207) + 148) = a1[37];
    *(_DWORD *)(G_TempEntity(a2, 206) + 148) = a1[37];
  }
  v4 = a1[61];
  trap_UnlinkEntity(a1);
  *(_DWORD *)(a1[88] + 20) = *a2;
  *(_DWORD *)(a1[88] + 24) = a2[1];
  *(_DWORD *)(a1[88] + 28) = a2[2];
  *(float *)(a1[88] + 28) = *(float *)(a1[88] + 28) + 1.0;
  *(_DWORD *)(a1[88] + 132) ^= 8u;
  SetClientViewAngle(a1, a3);
  BG_PlayerStateToEntityState(a1[88], a1, 1);
  a1[79] = *(_DWORD *)(a1[88] + 20);
  a1[80] = *(_DWORD *)(a1[88] + 24);
  result = *(_DWORD *)(a1[88] + 28);
  a1[81] = result;
  if ( v4 )
    result = trap_LinkEntity(a1);
  return result;
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0005A5E2) --------------------------------------------------------
void SP_misc_teleporter_dest()
{
  ;
}

//----- (0005A5E7) --------------------------------------------------------
int __cdecl SP_sound_blend(_DWORD *a1)
{
  int result; // eax

  a1[72] = 0;
  a1[1] = 9;
  a1[3] = 0;
  a1[12] = 0;
  a1[41] = 0;
  a1[55] = 0;
  a1[54] = 0;
  a1[29] = 1023;
  result = a1[62] | 8;
  a1[62] = result;
  return result;
}

//----- (0005A65D) --------------------------------------------------------
int G_SpawnSoundBlend()
{
  int v1; // [esp+10h] [ebp-8h]

  v1 = G_Spawn();
  Scr_SetString(v1 + 388, scr_const[61]);
  SP_sound_blend(v1);
  return v1;
}
// 167A4: using guessed type int G_Spawn(void);
// 18C34: using guessed type _DWORD __cdecl SP_sound_blend(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0005A6A9) --------------------------------------------------------
int __cdecl G_SetSoundBlend(_DWORD *a1, int a2, int a3, int a4)
{
  if ( !a2 && !a3 )
    return trap_UnlinkEntity(a1);
  a1[41] = (unsigned __int8)a2;
  a1[55] = (unsigned __int8)a3;
  a1[27] = a4;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (0005A708) --------------------------------------------------------
int __cdecl G_SetSoundBlendAndPitch(int a1, int a2, int a3, float a4, float a5)
{
  double v6; // [esp+8h] [ebp-20h]
  double v7; // [esp+10h] [ebp-18h]

  if ( !a2 && !a3 )
    return trap_UnlinkEntity(a1);
  *(_DWORD *)(a1 + 164) = (unsigned __int8)a2;
  *(_DWORD *)(a1 + 220) = (unsigned __int8)a3;
  v7 = floor(a5 * 100.0);
  HIBYTE(v7) ^= 0x80u;
  if ( a4 >= 0.99000001 )
    v6 = v7 - 0.9900000095367432;
  else
    v6 = v7 - a4;
  *(float *)(a1 + 216) = v6;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (0005A7B7) --------------------------------------------------------
int __cdecl SP_misc_model(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005A7DA) --------------------------------------------------------
int __cdecl use_corona(int a1)
{
  if ( *(_DWORD *)(a1 + 244) )
    return trap_UnlinkEntity(a1);
  *(_BYTE *)(a1 + 382) = 0;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (0005A820) --------------------------------------------------------
int __cdecl SP_corona(void *s)
{
  return G_FreeEntity(s);
}

//----- (0005A843) --------------------------------------------------------
_BOOL4 G_IsInMatchTimeout()
{
  return level[125] == 0;
}

//----- (0005A868) --------------------------------------------------------
int *G_InitTurrets()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-8h] BYREF

  for ( i = 0; i <= 31; ++i )
  {
    dword_D1340[18 * i] = 0;
    result = &i;
  }
  return result;
}

//----- (0005A8B0) --------------------------------------------------------
int __cdecl sub_5A8B0(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-B0h]
  float v5; // [esp+1Ch] [ebp-ACh]
  float v6[4]; // [esp+20h] [ebp-A8h] BYREF
  float v7[4]; // [esp+30h] [ebp-98h] BYREF
  char v8[48]; // [esp+40h] [ebp-88h] BYREF
  float v9; // [esp+70h] [ebp-58h]
  float v10; // [esp+74h] [ebp-54h]
  float v11; // [esp+78h] [ebp-50h]
  char v12[48]; // [esp+80h] [ebp-48h] BYREF
  float v13; // [esp+B0h] [ebp-18h]
  float v14; // [esp+B4h] [ebp-14h]
  float v15; // [esp+B8h] [ebp-10h]

  if ( G_DObjGetWorldTagMatrix(a1, "tag_flash", v12) )
  {
    if ( G_DObjGetWorldTagMatrix(a1, "tag_player", v8) )
    {
      v6[0] = *(float *)(a1 + 104) + *(float *)(a1 + 328);
      v6[1] = *(float *)(a1 + 108) + *(float *)(a1 + 332);
      v6[2] = 0.0;
      AngleVectors(v6, a3, a3 + 12, a3 + 24);
      *(_DWORD *)(a3 + 48) = *(_DWORD *)a3;
      *(_DWORD *)(a3 + 52) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 56) = *(_DWORD *)(a3 + 8);
      v7[0] = v13 - v9;
      v7[1] = v14 - v10;
      v7[2] = v15 - v11;
      v5 = VectorNormalize(v7);
      *(float *)(a3 + 36) = *(float *)a3 * v5 + v9;
      *(float *)(a3 + 40) = *(float *)(a3 + 4) * v5 + v10;
      *(float *)(a3 + 44) = *(float *)(a3 + 8) * v5 + v11;
      v4 = 1;
    }
    else
    {
      SL_ConvertToString(*(unsigned __int16 *)(a1 + 388));
      Com_Printf(
        "Couldn't find %s on turret (entity %d, classname '%s').\n",
        (unsigned __int8)&aTagPlayer_0[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      v4 = 0;
    }
  }
  else
  {
    SL_ConvertToString(*(unsigned __int16 *)(a1 + 388));
    Com_Printf(
      "Couldn't find %s on turret (entity %d, classname '%s').\n",
      (unsigned __int8)&aTagFlash[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v4 = 0;
  }
  return v4;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0005AAA9) --------------------------------------------------------
_DWORD *__cdecl sub_5AAA9(int a1, char *a2, int a3)
{
  _DWORD *result; // eax
  char *v4; // [esp+30h] [ebp-58h]
  int v5; // [esp+34h] [ebp-54h]
  int v6; // [esp+38h] [ebp-50h]
  int v7[15]; // [esp+40h] [ebp-48h] BYREF
  int v8; // [esp+7Ch] [ebp-Ch]

  result = level;
  if ( !level[1494] )
  {
    result = level;
    if ( !level[1496] )
    {
      v6 = *(_DWORD *)(a1 + 360);
      result = (_DWORD *)v6;
      if ( !*(_DWORD *)(v6 + 68) )
      {
        if ( a2 == &byte_D2CB4[(_DWORD)g_entities] )
          v4 = (char *)&dword_D2968 + (_DWORD)g_entities;
        else
          v4 = a2;
        result = (_DWORD *)sub_5A8B0(a1, (int)v4, (int)v7);
        if ( result )
        {
          v8 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
          if ( *(_DWORD *)(v8 + 124) )
          {
            result = (_DWORD *)Weapon_RocketLauncher_Fire(a1, 0.0, (int)v7);
          }
          else
          {
            v5 = Bullet_Fire((int)v4, 0.0, a3, (int)v7, a1);
            *(float *)(v6 + 64) = *(float *)(v6 + 64) + *(float *)(v8 + 1180);
            if ( v5 )
              result = (_DWORD *)G_AddEvent(a1, 173, 0);
            else
              result = (_DWORD *)G_AddEvent(a1, 173, 128);
          }
        }
      }
    }
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// D2968: using guessed type int dword_D2968;

//----- (0005AC06) --------------------------------------------------------
int __cdecl sub_5AC06(int a1, float *a2)
{
  int result; // eax
  char v3; // al
  char v4; // al
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  char v12; // [esp+4h] [ebp-1D4h]
  char v13; // [esp+4h] [ebp-1D4h]
  float v14; // [esp+8h] [ebp-1D0h]
  float v15; // [esp+8h] [ebp-1D0h]
  float v16; // [esp+8h] [ebp-1D0h]
  float v17; // [esp+8h] [ebp-1D0h]
  float v18; // [esp+2Ch] [ebp-1ACh]
  float v19; // [esp+30h] [ebp-1A8h]
  float v20; // [esp+34h] [ebp-1A4h]
  float v21; // [esp+38h] [ebp-1A0h]
  float v22; // [esp+3Ch] [ebp-19Ch]
  float v23; // [esp+40h] [ebp-198h]
  float v24; // [esp+44h] [ebp-194h]
  float v25; // [esp+4Ch] [ebp-18Ch]
  float v26; // [esp+4Ch] [ebp-18Ch]
  float v27; // [esp+4Ch] [ebp-18Ch]
  float v28; // [esp+4Ch] [ebp-18Ch]
  float v29; // [esp+4Ch] [ebp-18Ch]
  float v30; // [esp+4Ch] [ebp-18Ch]
  float v31; // [esp+4Ch] [ebp-18Ch]
  float v32[12]; // [esp+50h] [ebp-188h] BYREF
  int v33[4]; // [esp+80h] [ebp-158h] BYREF
  int v34[2]; // [esp+90h] [ebp-148h] BYREF
  int v35; // [esp+98h] [ebp-140h]
  float v36; // [esp+A0h] [ebp-138h]
  float v37; // [esp+A4h] [ebp-134h]
  float v38; // [esp+A8h] [ebp-130h]
  int v39; // [esp+B0h] [ebp-128h] BYREF
  int v40; // [esp+B4h] [ebp-124h] BYREF
  int v41; // [esp+B8h] [ebp-120h] BYREF
  int v42; // [esp+BCh] [ebp-11Ch]
  int v43; // [esp+C0h] [ebp-118h]
  int v44; // [esp+C4h] [ebp-114h]
  float *v46; // [esp+CCh] [ebp-10Ch]
  char v47[36]; // [esp+D0h] [ebp-108h] BYREF
  int v48; // [esp+F4h] [ebp-E4h]
  int v49; // [esp+F8h] [ebp-E0h]
  int v50; // [esp+FCh] [ebp-DCh]
  int v51[15]; // [esp+100h] [ebp-D8h] BYREF
  int v52; // [esp+13Ch] [ebp-9Ch]
  char v53[24]; // [esp+140h] [ebp-98h] BYREF
  float v54; // [esp+158h] [ebp-80h]
  float v55; // [esp+15Ch] [ebp-7Ch]
  float v56; // [esp+160h] [ebp-78h]
  float v57; // [esp+164h] [ebp-74h]
  float v58; // [esp+168h] [ebp-70h]
  float v59; // [esp+16Ch] [ebp-6Ch]
  int v60[2]; // [esp+170h] [ebp-68h] BYREF
  float v61; // [esp+178h] [ebp-60h]
  char v62[12]; // [esp+180h] [ebp-58h] BYREF
  float v63; // [esp+18Ch] [ebp-4Ch]
  float v64; // [esp+190h] [ebp-48h]
  float v65; // [esp+194h] [ebp-44h]
  float v66; // [esp+198h] [ebp-40h]
  float v67; // [esp+19Ch] [ebp-3Ch]
  float v68; // [esp+1A0h] [ebp-38h]
  float v69; // [esp+1A4h] [ebp-34h]
  float v70; // [esp+1A8h] [ebp-30h]
  int v71; // [esp+1ACh] [ebp-2Ch]
  char *v72; // [esp+1B0h] [ebp-28h]
  char *v73; // [esp+1B4h] [ebp-24h]
  int v74; // [esp+1B8h] [ebp-20h]
  int v75; // [esp+1BCh] [ebp-1Ch]
  int v76; // [esp+1C0h] [ebp-18h]
  int v77; // [esp+1C4h] [ebp-14h]
  int v78; // [esp+1C8h] [ebp-10h]
  int v79; // [esp+1CCh] [ebp-Ch]

  v78 = *(_DWORD *)(a1 + 148);
  v73 = &aSDoesNotExist[1232 * v78 + (_DWORD)bgs];
  v72 = v73 + 896;
  result = (int)(v73 + 896);
  if ( *((_DWORD *)v73 + 228) )
  {
    result = (int)v72;
    if ( *((_DWORD *)v72 + 5) )
    {
      result = *(_DWORD *)(*((_DWORD *)v72 + 5) + 80) & 4;
      if ( result )
      {
        v46 = (float *)G_DObjGetLocalTagMatrix(a2, "tag_weapon");
        if ( !v46 )
          return Com_Printf("WARNING: aborting player positioning on turret since 'tag_weapon' does not exist\n", v12);
        v71 = BG_GetInfoForWeapon(*((_DWORD *)a2 + 51));
        v44 = *((_DWORD *)v73 + 305);
        v43 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
        HIWORD(v42) = Scr_GetAnimsIndex(v43);
        LOWORD(v42) = *((_WORD *)v72 + 8) & 0xFDFF;
        v70 = vectosignedyaw(v46);
        AnglesToAxis(a2 + 82, v53);
        v57 = a2[79];
        v58 = a2[80];
        v59 = a2[81];
        v36 = *(float *)(a1 + 316) - v57;
        v37 = *(float *)(a1 + 320) - v58;
        v38 = *(float *)(a1 + 324) - v59;
        *(float *)&v52 = v36 * v54 + v37 * v55 + v38 * v56;
        v69 = *(float *)&v52 - v46[14];
        trap_XAnimClearTreeGoalWeightsStrict(v44, v42, 0);
        v77 = trap_XAnimGetNumChildren(v42);
        v68 = 0.0;
        v67 = 0.0;
        v75 = 0;
        v40 = 0;
        if ( !v77 )
        {
          v3 = trap_XAnimGetAnimName(v42);
          Com_Error(1, byte_A14E0, v3);
        }
        v79 = 0;
        do
        {
          trap_XAnimGetChildAt(&v39);
          trap_XAnimSetGoalWeight(v44, v39, 1065353216, 1065353216, 1065353216, 0, 0);
          v76 = trap_XAnimGetNumChildren(v39);
          if ( !v76 )
          {
            v4 = trap_XAnimGetAnimName(v39);
            Com_Error(1, byte_A14E0, v4);
          }
          v65 = (long double)v76 * 0.5 - v70 / *(float *)(v71 + 1164);
          if ( v65 >= 0.0 )
          {
            if ( v65 >= (long double)(v76 - 1) )
              v65 = (float)(v76 - 1);
          }
          else
          {
            v65 = 0.0;
          }
          v74 = (int)v65;
          v65 = v65 - (long double)v74;
          trap_XAnimGetChildAt(&v41);
          v14 = 1.0 - v65;
          trap_XAnimSetGoalWeight(v44, v41, LODWORD(v14), 1065353216, 1065353216, 0, 0);
          if ( v65 != 0.0 )
          {
            trap_XAnimGetChildAt(&v40);
            trap_XAnimSetGoalWeight(v44, v40, LODWORD(v65), 1065353216, 1065353216, 0, 0);
          }
          trap_XAnimCalcAbsDelta(v44, v39, v62, v60);
          if ( v61 >= (long double)v69 )
            break;
          v68 = v61;
          v75 = v74;
          v67 = v65;
          ++v79;
        }
        while ( v79 < v77 );
        trap_XAnimClearTreeGoalWeightsStrict(v44, v42, 0);
        v5 = trap_XAnimGetWeight(v44, v41);
        v25 = fabs(v5 - (1.0 - v65));
        v64 = v25 * (1000.0 / (long double)(int)level[125]);
        if ( v64 <= 0.0 )
          v24 = 0.0;
        else
          v24 = 1.0 / v64;
        v15 = 1.0 - v65;
        trap_XAnimSetGoalWeight(v44, v41, LODWORD(v15), LODWORD(v24), 1065353216, 0, 0);
        if ( v65 != 0.0 )
        {
          v6 = trap_XAnimGetWeight(v44, v40);
          v26 = fabs(v6 - v65);
          v64 = v26 * (1000.0 / (long double)(int)level[125]);
          if ( v64 <= 0.0 )
          {
            ((void (__cdecl *)(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))trap_XAnimSetGoalWeight)(
              v44,
              v40,
              LODWORD(v65),
              0.0,
              1065353216,
              0,
              0);
          }
          else
          {
            v23 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v40, LODWORD(v65), LODWORD(v23), 1065353216, 0, 0);
          }
        }
        if ( v79 && v79 != v77 )
        {
          v63 = (v69 - v68) / (v61 - v68);
          v7 = trap_XAnimGetWeight(v44, v39);
          v28 = fabs(v7 - v63);
          v64 = v28 * (1000.0 / (long double)(int)level[125]);
          if ( v64 <= 0.0 )
          {
            trap_XAnimSetGoalWeight(v44, v39, LODWORD(v63), 0, 1065353216, 0, 0);
          }
          else
          {
            v21 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v39, LODWORD(v63), LODWORD(v21), 1065353216, 0, 0);
          }
          trap_XAnimGetChildAt(&v39);
          v8 = trap_XAnimGetWeight(v44, v39);
          v29 = fabs(v8 - (1.0 - v63));
          v64 = v29 * (1000.0 / (long double)(int)level[125]);
          if ( v64 <= 0.0 )
            v20 = 0.0;
          else
            v20 = 1.0 / v64;
          v16 = 1.0 - v63;
          trap_XAnimSetGoalWeight(v44, v39, LODWORD(v16), LODWORD(v20), 1065353216, 0, 0);
          trap_XAnimGetChildAt(&v41);
          v9 = trap_XAnimGetWeight(v44, v41);
          v30 = fabs(v9 - (1.0 - v67));
          v64 = v30 * (1000.0 / (long double)(int)level[125]);
          if ( v64 <= 0.0 )
            v19 = 0.0;
          else
            v19 = 1.0 / v64;
          v17 = 1.0 - v67;
          trap_XAnimSetGoalWeight(v44, v41, LODWORD(v17), LODWORD(v19), 1065353216, 0, 0);
          if ( v67 != 0.0 )
          {
            trap_XAnimGetChildAt(&v40);
            v10 = trap_XAnimGetWeight(v44, v40);
            v31 = fabs(v10 - v67);
            v64 = v31 * (1000.0 / (long double)(int)level[125]);
            if ( v64 <= 0.0 )
            {
              trap_XAnimSetGoalWeight(v44, v40, LODWORD(v67), 0, 1065353216, 0, 0);
            }
            else
            {
              v18 = 1.0 / v64;
              trap_XAnimSetGoalWeight(v44, v40, LODWORD(v67), LODWORD(v18), 1065353216, 0, 0);
            }
          }
        }
        else
        {
          if ( !G_DObjGetLocalTagMatrix(a2, "tag_aim") )
            return Com_Printf("WARNING: aborting player positioning on turret since 'tag_aim' does not exist\n", v13);
          v27 = fabs(trap_XAnimGetWeight(v44, v39) - 1.0);
          v64 = v27 * (1000.0 / (long double)(int)level[125]);
          if ( v64 <= 0.0 )
          {
            trap_XAnimSetGoalWeight(v44, v39, 1065353216, 0, 1065353216, 0, 0);
          }
          else
          {
            v22 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v39, 1065353216, LODWORD(v22), 1065353216, 0, 0);
          }
        }
        trap_XAnimCalcAbsDelta(v44, v42, v62, v60);
        VectorAngleMultiply((int)v60, v70);
        *(float *)&v51[9] = *(float *)v60 + v46[12];
        *(float *)&v51[10] = *(float *)&v60[1] + v46[13];
        v51[11] = v52;
        v11 = RotationToYaw(v62);
        v66 = v11 + v70;
        YawToAxis(v66, (int)v51);
        MatrixMultiply43(v51, v53, v47);
        *(_DWORD *)(*(_DWORD *)(a1 + 352) + 20) = v48;
        *(_DWORD *)(*(_DWORD *)(a1 + 352) + 24) = v49;
        *(_DWORD *)(*(_DWORD *)(a1 + 352) + 28) = v50;
        v34[0] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 20);
        v34[1] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 24);
        v35 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 28);
        v33[0] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 20);
        v33[1] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 24);
        v33[2] = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 28);
        v35 = *((_DWORD *)a2 + 81);
        trap_Trace(v32, v34, 0, 0, v33, *(_DWORD *)a1, 42008593);
        if ( v32[0] < 1.0 )
          *(float *)(*(_DWORD *)(a1 + 352) + 28) = v32[3];
        BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 352), a1, 1);
        *(_DWORD *)(a1 + 316) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 20);
        *(_DWORD *)(a1 + 320) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 24);
        *(_DWORD *)(a1 + 324) = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 28);
        AxisToAngles(v47, a1 + 328);
        result = trap_LinkEntity(a1);
      }
    }
  }
  return result;
}
// 5ACAB: variable 'v12' is possibly undefined
// 5B2B5: variable 'v13' is possibly undefined
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 17294: using guessed type _DWORD __cdecl trap_XAnimClearTreeGoalWeightsStrict(_DWORD, __int16, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 17E84: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 17F34: using guessed type double __cdecl vectosignedyaw(_DWORD);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 18194: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 18244: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 185F4: using guessed type _DWORD __cdecl trap_XAnimGetAnimName(_DWORD);
// 18674: using guessed type _DWORD __cdecl trap_XAnimGetNumChildren(_DWORD);
// 18D14: using guessed type _DWORD __stdcall trap_XAnimGetChildAt(_DWORD);
// 18E74: using guessed type _DWORD __cdecl trap_XAnimCalcAbsDelta(_DWORD, __int16, _DWORD, _DWORD);
// 19024: using guessed type double __cdecl RotationToYaw(_DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 195D4: using guessed type _DWORD __cdecl trap_XAnimSetGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// A7AC8: using guessed type int dword_A7AC8;

//----- (0005B950) --------------------------------------------------------
int __cdecl sub_5B950(int a1, int a2)
{
  int result; // eax
  float v3; // [esp+10h] [ebp-38h]
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+38h] [ebp-10h]
  int v8; // [esp+3Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 360);
  v7 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
  *(_DWORD *)(*(_DWORD *)(a2 + 352) + 1468) = *(_DWORD *)a1;
  AnglesSubtract(*(_DWORD *)(a2 + 352) + 232, a1 + 328, &v5);
  if ( *(float *)(v8 + 12) <= (long double)v5 )
  {
    if ( v5 <= (long double)*(float *)(v8 + 20) )
      v4 = v5;
    else
      v4 = *(float *)(v8 + 20);
  }
  else
  {
    v4 = *(float *)(v8 + 12);
  }
  *(float *)(a1 + 104) = v4;
  if ( *(float *)(v8 + 16) <= (long double)v6 )
  {
    if ( v6 <= (long double)*(float *)(v8 + 24) )
      v3 = v6;
    else
      v3 = *(float *)(v8 + 24);
  }
  else
  {
    v3 = *(float *)(v8 + 16);
  }
  *(float *)(a1 + 108) = v3;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 216) = *(_DWORD *)(v8 + 20);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(v8 + 24);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(v8 + 12);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(v8 + 16);
  result = *(_DWORD *)(v8 + 4) & 0x800;
  if ( result )
  {
    *(_DWORD *)(v8 + 4) &= 0xFFFFF7FF;
    result = *(_DWORD *)(a1 + 8) ^ 8;
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (0005BAD3) --------------------------------------------------------
_DWORD *__cdecl sub_5BAD3(_DWORD *a1, _DWORD *a2)
{
  int v2; // esi
  _DWORD *result; // eax

  v2 = a1[90];
  *(_DWORD *)(v2 + 40) = 3 * *(_DWORD *)(BG_GetInfoForWeapon(a1[51]) + 556);
  result = a2;
  if ( a2[88] )
    result = sub_5AAA9((int)a1, (char *)a2, a1[146]);
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0005BB49) --------------------------------------------------------
int __cdecl sub_5BB49(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 360);
  sub_5B950(a1, (int)a2);
  sub_5AC06((int)a2, (float *)a1);
  v3 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
  *(_DWORD *)(a1 + 8) &= 0xFFFFFDFF;
  *(_DWORD *)(v4 + 8) -= 50;
  result = v4;
  if ( *(int *)(v4 + 8) <= 0 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = *(_DWORD *)(a2[88] + 17964) & 1;
    if ( result )
    {
      result = v4;
      if ( !*(_DWORD *)(v4 + 68) )
      {
        *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 556);
        sub_5BAD3((_DWORD *)a1, a2);
        result = *(_DWORD *)(a1 + 8) | 0x200;
        *(_DWORD *)(a1 + 8) = result;
      }
    }
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0005BC29) --------------------------------------------------------
int __cdecl sub_5BC29(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 360);
  *(_DWORD *)(a1 + 132) = 0;
  result = v2;
  if ( *(int *)(v2 + 40) > 0 )
  {
    if ( (*(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 360) + 60),
          *(_DWORD *)(v2 + 40) -= 50,
          *(int *)(v2 + 40) <= 0)
      && *(_BYTE *)(v2 + 61)
      || (result = G_IsInMatchTimeout()) != 0 )
    {
      *(_DWORD *)(a1 + 132) = 0;
      result = G_PlaySoundAlias(a1, *(unsigned __int8 *)(v2 + 61));
    }
  }
  return result;
}
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 19584: using guessed type int G_IsInMatchTimeout(void);

//----- (0005BCC8) --------------------------------------------------------
int __cdecl G_ClientStopUsingTurret(int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 360);
  v3 = &g_entities[211 * *(_DWORD *)(a1 + 340)];
  v2[10] = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( v2[9] != -1 )
  {
    if ( v2[9] == 2 )
    {
      G_AddEvent(v3, 144, 0);
    }
    else if ( v2[9] == 1 )
    {
      G_AddEvent(v3, 143, 0);
    }
    else
    {
      G_AddEvent(v3, 142, 0);
    }
    v2[9] = -1;
  }
  TeleportPlayer(v3, v2 + 11, v3 + 82);
  *(_DWORD *)(v3[88] + 132) &= 0xFFFF9FFF;
  *(_DWORD *)(v3[88] + 1464) = 0;
  *(_DWORD *)(v3[88] + 1468) = 1023;
  *((_BYTE *)v3 + 382) = 0;
  v3[29] = 0;
  *(_BYTE *)(a1 + 382) = 0;
  *(_DWORD *)(a1 + 340) = 1023;
  v2[1] &= 0xFFFFF7FF;
  return Scr_Notify(a1, scr_const[152], 0);
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18414: using guessed type _DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0005BE63) --------------------------------------------------------
int __cdecl turret_think_client(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = &g_entities[211 * *(_DWORD *)(a1 + 340)];
  if ( *((_BYTE *)v2 + 382) != 1 || *(_DWORD *)(v2[88] + 17668) )
    return G_ClientStopUsingTurret(a1);
  sub_5BB49(a1, v2);
  return sub_5BC29(a1);
}
// 16F24: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);

//----- (0005BEDF) --------------------------------------------------------
int __cdecl sub_5BEDF(int a1, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  float v6; // [esp+1Ch] [ebp-2Ch]
  float v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a1 + 360);
  v8 = 1;
  v7 = *(float *)(a1 + 104);
  v3 = v7 + *(float *)(a1 + 112);
  *(float *)(a1 + 104) = v3;
  if ( a3 )
  {
    v12 = *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204)) + 1148);
    v13 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204)) + 1152);
  }
  else
  {
    v12 = 200.0;
    v13 = 1128792064;
  }
  if ( (*(_DWORD *)(v9 + 4) & 0x200) != 0 && (*(_DWORD *)(v9 + 4) & 0x100) != 0 )
  {
    v3 = v12;
    if ( v12 < 360.0 )
      v12 = 360.0;
  }
  for ( i = 0; i <= 1; ++i )
  {
    v4 = *(&v12 + i) * 0.050000001;
    *(&v12 + i) = v4;
    AngleSubtract(*(float *)(a2 + 4 * i), *(float *)(a1 + 4 * i + 104));
    v10 = v4;
    if ( v10 <= (long double)*(&v12 + i) )
    {
      if ( -*(&v12 + i) > (long double)v10 )
      {
        v8 = 0;
        LODWORD(v10) = *((_DWORD *)&v12 + i) ^ 0x80000000;
      }
    }
    else
    {
      v8 = 0;
      v10 = *(&v12 + i);
    }
    v3 = *(float *)(a1 + 4 * i + 104) + v10;
    *(float *)(a1 + 4 * i + 104) = v3;
  }
  v6 = *(float *)(a1 + 104);
  *(float *)(a1 + 112) = v6;
  if ( (*(_DWORD *)(v9 + 4) & 0x200) != 0 )
  {
    if ( (*(_DWORD *)(v9 + 4) & 0x400) != 0 )
    {
      v3 = *(float *)(a1 + 104);
      if ( *(float *)(v9 + 56) > v3 )
        goto LABEL_18;
      *(_DWORD *)(v9 + 4) &= 0xFFFFFEFF;
    }
    else
    {
      v3 = *(float *)(v9 + 56);
      if ( *(float *)(a1 + 104) > v3 )
      {
LABEL_18:
        AngleSubtract(*(float *)(v9 + 56), v7);
        goto LABEL_23;
      }
      *(_DWORD *)(v9 + 4) &= 0xFFFFFEFF;
    }
  }
  AngleSubtract(v6, v7);
LABEL_23:
  v11 = v3;
  if ( v11 <= (long double)v12 )
  {
    if ( -v12 > (long double)v11 )
    {
      v8 = 0;
      LODWORD(v11) = LODWORD(v12) ^ 0x80000000;
    }
  }
  else
  {
    v8 = 0;
    v11 = v12;
  }
  *(float *)(a1 + 104) = v7 + v11;
  *(float *)(a1 + 112) = *(float *)(a1 + 112) - *(float *)(a1 + 104);
  return v8;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0005C18E) --------------------------------------------------------
int __cdecl sub_5C18E(int a1, int a2)
{
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4[3]; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 360);
  if ( a2 )
    v3 = 0.0;
  else
    v3 = *(float *)(v5 + 28);
  v4[0] = v3;
  v4[1] = 0.0;
  return sub_5BEDF(a1, (int)v4, a2);
}

//----- (0005C1F2) --------------------------------------------------------
int __cdecl turret_think(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *v4; // [esp+20h] [ebp-8h]

  v3 = a1[90];
  a1[131] = level[123] + 50;
  if ( a1[189] )
    G_GeneralLink(a1);
  v4 = &g_entities[211 * a1[85]];
  if ( *(float *)(v3 + 64) < 1.0 )
  {
    if ( *(_DWORD *)(v3 + 68) && *(float *)(v3 + 64) <= 0.5 )
      *(_DWORD *)(v3 + 68) = 0;
  }
  else
  {
    *(_DWORD *)(v3 + 68) = 1;
    G_AddEvent(a1, 208, 0);
    Scr_Notify(a1, scr_const[99], 0);
    a1[57] = 1;
  }
  v2 = BG_GetInfoForWeapon(a1[51]);
  if ( *(float *)(v3 + 64) <= 0.0 )
    *(_DWORD *)(v3 + 64) = 0;
  else
    *(float *)(v3 + 64) = *(float *)(v3 + 64) - *(float *)(v2 + 1184);
  result = (int)v4;
  if ( !v4[88] )
  {
    sub_5BC29((int)a1);
    a1[2] &= 0xFFFFFDFF;
    result = sub_5C18E((int)a1, 0);
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 186A4: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0005C381) --------------------------------------------------------
float *__cdecl turret_think_init(_DWORD *a1)
{
  float *result; // eax
  int i; // [esp+2Ch] [ebp-FCh]
  float v3[12]; // [esp+30h] [ebp-F8h] BYREF
  char v4[16]; // [esp+60h] [ebp-C8h] BYREF
  char v5[16]; // [esp+70h] [ebp-B8h] BYREF
  float v6; // [esp+80h] [ebp-A8h] BYREF
  float v7; // [esp+84h] [ebp-A4h]
  float v8; // [esp+88h] [ebp-A0h]
  float v9[4]; // [esp+90h] [ebp-98h] BYREF
  float v10[4]; // [esp+A0h] [ebp-88h] BYREF
  char v11[48]; // [esp+B0h] [ebp-78h] BYREF
  char v12[36]; // [esp+E0h] [ebp-48h] BYREF
  int v13; // [esp+104h] [ebp-24h]
  int v14; // [esp+108h] [ebp-20h]
  int v15; // [esp+10Ch] [ebp-1Ch]
  float *v16; // [esp+110h] [ebp-18h]
  float *v17; // [esp+114h] [ebp-14h]
  int v18; // [esp+118h] [ebp-10h]
  int v19; // [esp+11Ch] [ebp-Ch]

  v19 = 30;
  v18 = a1[90];
  a1[132] = turret_think;
  a1[131] = level[123] + 50;
  result = (float *)G_DObjGetLocalTagMatrix(a1, "tag_aim");
  v17 = result;
  if ( result )
  {
    result = (float *)G_DObjGetLocalTagMatrix(a1, "tag_butt");
    v16 = result;
    if ( result )
    {
      AnglesToAxis(a1 + 82, v12);
      v13 = a1[79];
      v14 = a1[80];
      v15 = a1[81];
      v9[0] = v16[12] - v17[12];
      v9[1] = v16[13] - v17[13];
      v9[2] = v16[14] - v17[14];
      MatrixTransformVector43(v17 + 12, v12, v5);
      for ( i = 0; ; ++i )
      {
        result = (float *)i;
        if ( i > v19 )
          break;
        v10[0] = -90.0 / (long double)v19 * (long double)i;
        v10[1] = 0.0;
        v10[2] = 0.0;
        AnglesToAxis(v10, v11);
        MatrixTransformVector(v9, v11, &v6);
        v6 = v6 + v17[12];
        v7 = v7 + v17[13];
        v8 = v8 + v17[14];
        MatrixTransformVector43(&v6, v12, v4);
        trap_LocationalTrace(v3, v5, v4, *a1, 17, &bulletPriorityMap);
        if ( v3[0] < 1.0 )
        {
          result = (float *)LODWORD(v10[0]);
          *(float *)(v18 + 28) = v10[0];
          return result;
        }
      }
    }
  }
  return result;
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17594: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 18194: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 185C4: using guessed type _DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0005C5E9) --------------------------------------------------------
int __cdecl turret_controller(_DWORD *a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h] BYREF
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = a1[27];
  v3 = a1[26];
  v5 = 0;
  G_DObjSetControlTagAngles(a1, a2, "tag_aim", &v3);
  G_DObjSetControlTagAngles(a1, a2, "tag_aim_animated", &v3);
  v3 = a1[28];
  v4 = 0;
  return G_DObjSetControlTagAngles(a1, a2, "tag_flash", &v3);
}
// 18DB4: using guessed type _DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005C693) --------------------------------------------------------
_BOOL4 __cdecl sub_5C693(int a1, float *a2)
{
  long double v2; // fst7
  long double v3; // fst7
  float v5; // [esp+0h] [ebp-68h]
  float v6; // [esp+10h] [ebp-58h]
  float v8; // [esp+1Ch] [ebp-4Ch]
  float v9; // [esp+20h] [ebp-48h]
  float v10; // [esp+24h] [ebp-44h]
  float v11; // [esp+28h] [ebp-40h]
  float v12; // [esp+2Ch] [ebp-3Ch]
  int v13[4]; // [esp+30h] [ebp-38h] BYREF
  float v14; // [esp+40h] [ebp-28h] BYREF
  float v15; // [esp+44h] [ebp-24h]
  float v16; // [esp+48h] [ebp-20h]
  int v17; // [esp+5Ch] [ebp-Ch]

  v17 = *(_DWORD *)(a1 + 360);
  v12 = *(float *)(a1 + 332) + *(float *)(v17 + 16);
  v6 = sub_5D425(*(float *)(v17 + 16));
  v11 = (sub_5D425(*(float *)(v17 + 24)) + v6) * 0.5;
  v2 = v12 + v11;
  v5 = v2;
  AngleNormalize180(v5);
  v10 = v2;
  YawVectors(v10, (int)v13, 0);
  VectorNormalize(v13);
  v14 = *(float *)(a1 + 316) - a2[79];
  v15 = *(float *)(a1 + 320) - a2[80];
  v16 = *(float *)(a1 + 324) - a2[81];
  if ( v16 < 0.0 && *(_DWORD *)(v17 + 32) != 2 && *(_DWORD *)(v17 + 32) != 1 )
    return 0;
  v16 = 0.0;
  VectorNormalize(&v14);
  v3 = *(float *)v13 * v14 + *(float *)&v13[1] * v15 + *(float *)&v13[2] * v16;
  v9 = v3;
  Q_acos(v9);
  v8 = v3 * 180.0 / 3.141592653589793;
  return v8 <= (long double)v11;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0005C80B) --------------------------------------------------------
int __cdecl G_FreeTurret(int a1)
{
  int result; // eax

  if ( g_entities[211 * *(_DWORD *)(a1 + 340) + 88] )
    G_ClientStopUsingTurret(a1);
  *(_BYTE *)(a1 + 382) = 0;
  **(_DWORD **)(a1 + 360) = 0;
  result = a1;
  *(_DWORD *)(a1 + 360) = 0;
  return result;
}
// 16F24: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);

//----- (0005C888) --------------------------------------------------------
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 382) || !*(_DWORD *)(a1 + 360) || !*(_BYTE *)(a1 + 381) )
    return 0;
  if ( !sub_5C693(a1, (float *)a2) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 352) + 52) )
    return 0;
  return *(_DWORD *)(*(_DWORD *)(a2 + 352) + 88) != 1023;
}

//----- (0005C919) --------------------------------------------------------
int __usercall turret_use@<eax>(long double a1@<st0>, int a2, int a3, int a4)
{
  int v4; // edx
  unsigned int v5; // eax
  int i; // [esp+1Ch] [ebp-3Ch]
  float v8[7]; // [esp+20h] [ebp-38h] BYREF
  _DWORD *v9; // [esp+3Ch] [ebp-1Ch]

  v9 = *(_DWORD **)(a2 + 360);
  *(_BYTE *)(a3 + 382) = 1;
  *(_BYTE *)(a2 + 382) = 1;
  *(_DWORD *)(a2 + 340) = *(_DWORD *)a3;
  *(_DWORD *)(*(_DWORD *)(a3 + 352) + 1468) = *(_DWORD *)a2;
  v9[1] |= 0x800u;
  v9[11] = *(_DWORD *)(a3 + 316);
  v9[12] = *(_DWORD *)(a3 + 320);
  v9[13] = *(_DWORD *)(a3 + 324);
  *(_DWORD *)(a3 + 116) = *(_DWORD *)a2;
  if ( (*(_DWORD *)(*(_DWORD *)(a3 + 352) + 12) & 1) != 0 )
    v9[9] = 2;
  else
    v9[9] = (*(_DWORD *)(*(_DWORD *)(a3 + 352) + 12) & 2) != 0;
  if ( v9[8] == 2 )
  {
    *(_DWORD *)(*(_DWORD *)(a3 + 352) + 132) |= 0x2000u;
    *(_DWORD *)(*(_DWORD *)(a3 + 352) + 132) &= 0xFFFFBFFF;
  }
  else
  {
    if ( v9[8] == 1 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 352) + 132) |= 0x4000u;
      v4 = *(_DWORD *)(a3 + 352);
      v5 = *(_DWORD *)(v4 + 132) & 0xFFFFDFFF;
    }
    else
    {
      v4 = *(_DWORD *)(a3 + 352);
      v5 = *(_DWORD *)(v4 + 132) | 0x6000;
    }
    *(_DWORD *)(v4 + 132) = v5;
  }
  *(_DWORD *)(a2 + 668) = *(_DWORD *)(a2 + 328);
  *(_DWORD *)(a2 + 672) = *(_DWORD *)(a2 + 332);
  *(_DWORD *)(a2 + 676) = *(_DWORD *)(a2 + 336);
  for ( i = 0; i <= 1; ++i )
  {
    AngleSubtract(*(float *)(*(_DWORD *)(a3 + 352) + 4 * i + 232), *(float *)(a2 + 4 * i + 328));
    *(float *)(a2 + 4 * i + 104) = a1;
    a1 = *(float *)&v9[i + 5];
    if ( *(float *)(a2 + 4 * i + 104) <= a1 )
    {
      a1 = *(float *)(a2 + 4 * i + 104);
      if ( *(float *)&v9[i + 3] > a1 )
        *(_DWORD *)(a2 + 4 * i + 104) = v9[i + 3];
    }
    else
    {
      *(_DWORD *)(a2 + 4 * i + 104) = v9[i + 5];
    }
  }
  v8[0] = *(float *)(a2 + 104) + *(float *)(a2 + 328);
  v8[1] = *(float *)(a2 + 108) + *(float *)(a2 + 332);
  v8[2] = 0.0;
  SetClientViewAngle(a3, v8);
  Scr_AddEntity(a4);
  return Scr_Notify(a2, scr_const[151], 1);
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0005CC27) --------------------------------------------------------
int __cdecl G_SpawnTurret(int a1, char a2)
{
  int v2; // eax
  int i; // [esp+14h] [ebp-14h]
  _DWORD *s; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  s = 0;
  for ( i = 0; i <= 31; ++i )
  {
    s = &dword_D1340[18 * i];
    if ( !*s )
      break;
  }
  if ( i == 32 )
    Com_Error(1, byte_A15E0, 32);
  memset(s, 0, 0x48u);
  *(_DWORD *)(a1 + 360) = s;
  *s = 1;
  *(_DWORD *)(a1 + 204) = (unsigned __int8)BG_GetWeaponIndexForName(a2);
  if ( !*(_DWORD *)(a1 + 204) )
    Com_Error(1, byte_A1620, a2);
  v6 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
  if ( !level[8] && !IsItemRegistered(*(_DWORD *)(a1 + 204)) )
  {
    v2 = va("turret '%s' not precached", a2);
    Scr_Error(v2);
  }
  RegisterItem(*(_DWORD *)(a1 + 204), 1);
  s[2] = 0;
  s[8] = *(_DWORD *)(v6 + 140);
  s[9] = -1;
  s[10] = 0;
  if ( *(_DWORD *)(v6 + 176) && **(_BYTE **)(v6 + 176) )
    *((_BYTE *)s + 60) = G_SoundAliasIndex(*(char **)(v6 + 176));
  else
    *((_BYTE *)s + 60) = 0;
  if ( *(_DWORD *)(v6 + 180) && **(_BYTE **)(v6 + 180) )
    *((_BYTE *)s + 61) = G_SoundAliasIndex(*(char **)(v6 + 180));
  else
    *((_BYTE *)s + 61) = 0;
  if ( !G_SpawnFloat("rightarc", (int)&unk_A1664, (int)(s + 4)) )
    s[4] = *(_DWORD *)(v6 + 1132);
  *((float *)s + 4) = *((float *)s + 4) * -1.0;
  if ( *((float *)s + 4) > 0.0 )
    s[4] = 0;
  if ( !G_SpawnFloat("leftarc", (int)&unk_A1664, (int)(s + 6)) )
    s[6] = *(_DWORD *)(v6 + 1128);
  if ( *((float *)s + 6) < 0.0 )
    s[6] = 0;
  if ( !G_SpawnFloat("toparc", (int)&unk_A1664, (int)(s + 3)) )
    s[3] = *(_DWORD *)(v6 + 1136);
  *((float *)s + 3) = *((float *)s + 3) * -1.0;
  if ( *((float *)s + 3) > 0.0 )
    s[3] = 0;
  if ( !G_SpawnFloat("bottomarc", (int)&unk_A1664, (int)(s + 5)) )
    s[5] = *(_DWORD *)(v6 + 1140);
  if ( *((float *)s + 5) < 0.0 )
    s[5] = 0;
  s[7] = -1028390912;
  if ( !*(_DWORD *)(a1 + 576) )
    *(_DWORD *)(a1 + 576) = 100;
  if ( !G_SpawnInt("damage", (int)"0", a1 + 584) )
    *(_DWORD *)(a1 + 584) = *(_DWORD *)(v6 + 520);
  if ( *(int *)(a1 + 584) < 0 )
    *(_DWORD *)(a1 + 584) = 0;
  s[1] = 3;
  *(_DWORD *)(a1 + 416) = 1;
  *(_DWORD *)(a1 + 288) = &unk_200004;
  *(_DWORD *)(a1 + 248) = 128;
  *(_DWORD *)(a1 + 4) = 11;
  *(_DWORD *)(a1 + 396) |= 0x2000u;
  G_DObjUpdate(a1);
  *(_DWORD *)(a1 + 264) = -1040187392;
  *(_DWORD *)(a1 + 268) = -1040187392;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 276) = 1107296256;
  *(_DWORD *)(a1 + 280) = 1107296256;
  *(_DWORD *)(a1 + 284) = 1113587712;
  G_SetOrigin(a1, a1 + 316);
  G_SetAngle(a1, a1 + 328);
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 528) = turret_think_init;
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  *(_DWORD *)(a1 + 560) = turret_controller;
  *(_DWORD *)(a1 + 544) = turret_use;
  *(_DWORD *)(a1 + 48) = 3;
  *(_BYTE *)(a1 + 381) = 1;
  return trap_LinkEntity(a1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 172C4: using guessed type _DWORD __cdecl IsItemRegistered(_DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005D16B) --------------------------------------------------------
int __cdecl SP_turret(int a1)
{
  char v2; // [esp+8h] [ebp-10h]
  char v3[4]; // [esp+10h] [ebp-8h] BYREF

  if ( !G_SpawnString("weaponinfo", (int)&unk_A1664, (int)v3) )
    Com_Error(1, byte_A16C0, v2);
  return G_SpawnTurret(a1, v3[0]);
}
// 5D1B1: variable 'v2' is possibly undefined
// 19544: using guessed type _DWORD __cdecl G_SpawnTurret(_DWORD, char);

//----- (0005D1CE) --------------------------------------------------------
int __cdecl misc_spawner_think(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // al
  char v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+20h] [ebp-8h]

  v1 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 728));
  v5 = BG_FindItem(v1);
  result = Drop_Item(a1, v5, 0.0, 0);
  if ( !result )
  {
    G_Printf("-----> WARNING <-------\n", v4);
    v3 = vtos(a1 + 316);
    result = G_Printf("misc_spawner used at %s failed to drop!\n", v3);
  }
  return result;
}
// 5D238: variable 'v4' is possibly undefined
// 17564: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 177C4: using guessed type _DWORD __cdecl vtos(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0005D265) --------------------------------------------------------
int __cdecl misc_spawner_use(int a1)
{
  *(_DWORD *)(a1 + 528) = misc_spawner_think;
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0005D2AF) --------------------------------------------------------
int __cdecl SP_misc_spawner(int a1)
{
  char v1; // al
  int result; // eax
  char v3; // [esp+4h] [ebp-14h]

  if ( *(_WORD *)(a1 + 728) )
  {
    *(_DWORD *)(a1 + 544) = misc_spawner_use;
    result = trap_LinkEntity(a1);
  }
  else
  {
    G_Printf("-----> WARNING <-------\n", v3);
    v1 = vtos(a1 + 316);
    result = G_Printf("misc_spawner at loc %s has no spawnitem!\n", v1);
  }
  return result;
}
// 5D2D7: variable 'v3' is possibly undefined
// 177C4: using guessed type _DWORD __cdecl vtos(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0005D320) --------------------------------------------------------
float *__cdecl miscGunnerEnemyScan(int a1)
{
  float *result; // eax
  char v2[16]; // [esp+10h] [ebp-38h] BYREF
  float v3[7]; // [esp+20h] [ebp-28h] BYREF
  float *i; // [esp+3Ch] [ebp-Ch]

  for ( i = (float *)g_entities; ; i += 211 )
  {
    result = (float *)&g_entities[211 * level[121]];
    if ( i >= result )
      break;
    if ( *((_BYTE *)i + 364)
      && *((int *)i + 144) >= 0
      && VectorDistance(a1 + 316, i + 79) <= (long double)*(int *)(a1 + 640) )
    {
      v3[0] = i[79] - *(float *)(a1 + 316);
      v3[1] = i[80] - *(float *)(a1 + 320);
      v3[2] = i[81] - *(float *)(a1 + 324);
      vectoangles(v3, v2);
      result = i;
      *(_DWORD *)(a1 + 616) = i;
      return result;
    }
  }
  return result;
}
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0005D425) --------------------------------------------------------
long double __cdecl sub_5D425(float a1)
{
  return (float)fabs(a1);
}

//----- (0005D43E) --------------------------------------------------------
void sub_5D43E()
{
  ;
}

//----- (0005D444) --------------------------------------------------------
void __cdecl G_MissileLandAngles(int a1, float *a2, int a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+0h] [ebp-68h]
  float v9; // [esp+0h] [ebp-68h]
  float v10; // [esp+0h] [ebp-68h]
  float v11; // [esp+40h] [ebp-28h]
  float v12; // [esp+48h] [ebp-20h]
  int v13; // [esp+4Ch] [ebp-1Ch]

  v13 = level[124] + (int)((long double)(level[123] - level[124]) * *a2);
  BG_EvaluateTrajectory(a1 + 48, v13, a3);
  if ( a2[6] <= 0.1 )
  {
    if ( !a4 )
    {
      v7 = (long double)((rand() & 0x7F) - 63) + *(float *)(a1 + 72);
      v10 = v7;
      AngleNormalize360(v10);
      *(float *)(a1 + 72) = v7;
    }
  }
  else
  {
    PitchForYawOnNormal(*(float *)(a3 + 4), (int)(a2 + 4));
    v12 = 0.1;
    AngleSubtract(0.1, *(float *)a3);
    v4 = fabs((float)0.1);
    v11 = v4;
    if ( !a4 )
    {
      *(_DWORD *)(a1 + 60) = *(_DWORD *)a3;
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a1 + 52) = v13;
      if ( v11 >= 80.0 )
        v4 = ((long double)rand() / 2147483600.0 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
      else
        v4 = ((long double)rand() / 2147483600.0 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72) * -1.0;
      *(float *)(a1 + 72) = v4;
    }
    AngleNormalize180(*(float *)a3);
    *(float *)a3 = v4;
    if ( a4 || v11 < 45.0 )
    {
      v5 = 90.0;
      if ( fabs(*(float *)a3) <= 90.0 )
      {
        AngleNormalize360(v12);
      }
      else
      {
        v5 = v12 + 180.0;
        v8 = v5;
        AngleNormalize360(v8);
      }
      *(float *)a3 = v5;
    }
    else
    {
      v6 = v11;
      if ( v11 >= 80.0 )
      {
        AngleNormalize360(*(float *)a3);
      }
      else
      {
        v6 = (float)0.1 * 0.25 + *(float *)a3;
        v9 = v6;
        AngleNormalize360(v9);
      }
      *(float *)a3 = v6;
    }
  }
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (0005D6E5) --------------------------------------------------------
_BOOL4 __cdecl G_BounceMissile(int a1, int a2)
{
  _BOOL4 v3; // [esp+14h] [ebp-54h]
  float v4; // [esp+20h] [ebp-48h]
  int v5; // [esp+24h] [ebp-44h]
  float v6; // [esp+2Ch] [ebp-3Ch]
  float v7; // [esp+2Ch] [ebp-3Ch]
  int v8[4]; // [esp+30h] [ebp-38h] BYREF
  float v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+44h] [ebp-24h]
  float v11; // [esp+48h] [ebp-20h]
  float v12; // [esp+50h] [ebp-18h] BYREF
  float v13; // [esp+54h] [ebp-14h]
  float v14; // [esp+58h] [ebp-10h]

  v5 = trap_PointContents(a1 + 316, -1, 32);
  BG_EvaluateTrajectoryDelta(a1 + 12, level[124] + (int)((long double)(level[123] - level[124]) * *(float *)a2), &v12);
  v6 = v12 * *(float *)(a2 + 16) + v13 * *(float *)(a2 + 20) + v14 * *(float *)(a2 + 24);
  *(float *)(a1 + 36) = v6 * -2.0 * *(float *)(a2 + 16) + v12;
  *(float *)(a1 + 40) = v6 * -2.0 * *(float *)(a2 + 20) + v13;
  *(float *)(a1 + 44) = v6 * -2.0 * *(float *)(a2 + 24) + v14;
  if ( *(float *)(a2 + 24) > 0.69999999 )
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
  if ( (*(_DWORD *)(a1 + 8) & 0x2000000) != 0
    && (!v5 && (*(_DWORD *)(a2 + 32) & 0x2000000) == 0 ? (*(float *)(a1 + 36) = *(float *)(a1 + 36) * 0.40000001,
                                                          *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.40000001,
                                                          *(float *)(a1 + 44) = *(float *)(a1 + 44) * 0.40000001) : (*(float *)(a1 + 36) = *(float *)(a1 + 36) * 0.1, *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.1, *(float *)(a1 + 44) = *(float *)(a1 + 44) * 0.1),
        *(float *)(a2 + 24) > 0.7
     && (v4 = sqrt(
                *(float *)(a1 + 36) * *(float *)(a1 + 36)
              + *(float *)(a1 + 40) * *(float *)(a1 + 40)
              + *(float *)(a1 + 44) * *(float *)(a1 + 44)),
         v4 < 20.0)) )
  {
    G_SetOrigin(a1, a1 + 316);
    G_MissileLandAngles(a1, a2, v8, 1);
    G_SetAngle(a1, v8);
    v3 = 0;
  }
  else
  {
    v9 = *(float *)(a2 + 16) * 0.1;
    v10 = *(float *)(a2 + 20) * 0.1;
    v11 = *(float *)(a2 + 24) * 0.1;
    if ( v11 > 0.0 )
      v11 = 0.0;
    *(float *)(a1 + 316) = *(float *)(a1 + 316) + v9;
    *(float *)(a1 + 320) = *(float *)(a1 + 320) + v10;
    *(float *)(a1 + 324) = *(float *)(a1 + 324) + v11;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
    *(_DWORD *)(a1 + 16) = level[123];
    G_MissileLandAngles(a1, a2, v8, 0);
    *(_DWORD *)(a1 + 60) = v8[0];
    *(_DWORD *)(a1 + 64) = v8[1];
    *(_DWORD *)(a1 + 68) = v8[2];
    *(_DWORD *)(a1 + 52) = level[123];
    if ( v5 )
    {
      v3 = 0;
    }
    else
    {
      v12 = *(float *)(a1 + 36) - v12;
      v13 = *(float *)(a1 + 40) - v13;
      v14 = *(float *)(a1 + 44) - v14;
      v7 = sqrt(v12 * v12 + v13 * v13 + v14 * v14);
      v3 = v7 > 100.0;
    }
  }
  return v3;
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 191C4: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 19304: using guessed type _DWORD __cdecl G_MissileLandAngles(_DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005DB67) --------------------------------------------------------
int __cdecl G_MissileImpact(int a1, int a2)
{
  int result; // eax
  long double v3; // fst7
  int v4; // [esp+4h] [ebp-B4h]
  float v5; // [esp+8h] [ebp-B0h]
  int v6; // [esp+8h] [ebp-B0h]
  float v7; // [esp+Ch] [ebp-ACh]
  float v8; // [esp+10h] [ebp-A8h]
  float v9; // [esp+14h] [ebp-A4h]
  int v10; // [esp+3Ch] [ebp-7Ch]
  int v11; // [esp+44h] [ebp-74h]
  char *v12; // [esp+48h] [ebp-70h]
  float v13[4]; // [esp+50h] [ebp-68h] BYREF
  float v14; // [esp+60h] [ebp-58h] BYREF
  float v15; // [esp+64h] [ebp-54h]
  float v16; // [esp+68h] [ebp-50h]
  float v17; // [esp+74h] [ebp-44h]
  float v18; // [esp+78h] [ebp-40h]
  float v19; // [esp+7Ch] [ebp-3Ch]
  int *v21; // [esp+84h] [ebp-34h]
  int v22; // [esp+88h] [ebp-30h]
  int v23; // [esp+8Ch] [ebp-2Ch]
  float v24; // [esp+90h] [ebp-28h] BYREF
  float v25; // [esp+94h] [ebp-24h]
  float v26; // [esp+98h] [ebp-20h]
  int v27; // [esp+A0h] [ebp-18h]
  int v28; // [esp+A4h] [ebp-14h]
  int v29; // [esp+A8h] [ebp-10h]
  int v30; // [esp+ACh] [ebp-Ch]

  v27 = 0;
  v21 = (int *)BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
  v30 = (int)&g_entities[211 * *(unsigned __int16 *)(a2 + 40)];
  v29 = 0;
  v28 = 0;
  if ( *(_BYTE *)(v30 + 381) || (*(_DWORD *)(a1 + 8) & 0x3000000) == 0 )
  {
    if ( *(_DWORD *)(a1 + 340) != 1023 )
    {
      v29 = (int)&g_entities[211 * *(_DWORD *)(a1 + 340)];
      v28 = a1;
      if ( *(_DWORD *)(v29 + 4) != 11 || *(_DWORD *)(v29 + 340) == 1023 )
      {
        if ( *(_DWORD *)(v29 + 4) == 12 && *(_DWORD *)(a1 + 816) != 1023 )
        {
          v28 = v29;
          v29 = (int)&g_entities[211 * *(_DWORD *)(a1 + 816)];
        }
      }
      else
      {
        v28 = v29;
        v29 = (int)&g_entities[211 * *(_DWORD *)(v29 + 340)];
      }
    }
    if ( *(_BYTE *)(v30 + 381) )
    {
      if ( !*(_DWORD *)(a1 + 584) )
        return G_BounceMissile(a1, a2);
      v18 = VectorDistance(a1 + 24, a1 + 316);
      if ( v21 )
      {
        v5 = (float)v21[132];
        v3 = (long double)*(int *)(a1 + 584);
        *(float *)&v4 = v3;
        Damage_Falloff(v18, v4, v5, v21[133], v21[134]);
        v19 = v3;
      }
      else
      {
        v19 = (float)*(int *)(a1 + 584);
      }
      if ( v19 > 0.0 )
      {
        if ( LogAccuracyHit(v30, &g_entities[211 * *(_DWORD *)(a1 + 340)]) )
          v27 = 1;
        BG_EvaluateTrajectoryDelta(a1 + 12, level[123], &v24);
        v17 = sqrt(v24 * v24 + v25 * v25 + v26 * v26);
        if ( v17 == 0.0 )
          v26 = 1.0;
        G_Damage(v30, v28, v29, &v24, a1 + 316, (int)v19, 0, *(_DWORD *)(a1 + 600), 0);
      }
    }
    if ( *(_DWORD *)(a1 + 584) )
    {
      v12 = (char *)v29;
      if ( !v29 )
        v12 = (char *)&dword_D2968 + (_DWORD)g_entities;
      G_CheckHitTriggerDamage(v12, a1 + 316, a2 + 4, *(_DWORD *)(a1 + 584), *(_DWORD *)(a1 + 600));
    }
    v11 = 0;
    if ( v27 || *(_WORD *)(a2 + 42) )
      v11 = 1;
    v22 = v11;
    v6 = (unsigned __int8)DirToByte(a2 + 16);
    if ( v11 )
      G_AddEvent(a1, 186, v6);
    else
      G_AddEvent(a1, 185, v6);
    *(_DWORD *)(a1 + 404) = 1;
    if ( trap_PointContents(a1 + 316, -1, 32) )
      *(_DWORD *)(a1 + 136) = 20;
    else
      *(_DWORD *)(a1 + 136) = (*(_DWORD *)(a2 + 28) & 0x1F00000) >> 20;
    *(_DWORD *)(a1 + 220) = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204)) + 912);
    if ( v30 && *(_DWORD *)(v30 + 4) == 12 )
      *(_DWORD *)(a1 + 8) |= 0x100000u;
    v23 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 4) = 0;
    SnapVectorTowards(a2 + 4, a1 + 24);
    G_SetOrigin(a1, a2 + 4);
    if ( *(_DWORD *)(a1 + 588) )
    {
      v14 = *(float *)(a2 + 4);
      v15 = *(float *)(a2 + 8);
      v16 = *(float *)(a2 + 12);
      v13[0] = *(float *)(a2 + 16) * 4.0 + v14;
      v13[1] = *(float *)(a2 + 20) * 4.0 + v15;
      v13[2] = *(float *)(a2 + 24) * 4.0 + v16;
      trap_Trace(a2, &v14, vec3_origin, vec3_origin, v13, *(_DWORD *)a1, 17);
      v10 = v28;
      if ( !v28 )
        v10 = a1;
      v7 = (float)*(int *)(a1 + 588);
      v8 = (float)*(int *)(a1 + 592);
      v9 = (float)*(int *)(a1 + 596);
      G_RadiusDamage(a2 + 4, v10, v29, v7, v8, v9, v30, *(_DWORD *)(a1 + 604));
    }
    result = trap_LinkEntity(a1);
  }
  else
  {
    result = G_BounceMissile(a1, a2);
    if ( result )
    {
      result = a2;
      if ( !*(_BYTE *)(a2 + 47) )
      {
        result = *(unsigned __int16 *)(a1 + 388);
        if ( (_WORD)result != scr_const[144] )
        {
          if ( *(_WORD *)(a1 + 388) == scr_const[24] )
            result = G_AddEvent(a1, 200, 0);
          else
            result = G_AddEvent(a1, 181, (*(_DWORD *)(a2 + 28) & 0x1F00000) >> 20);
        }
      }
    }
  }
  return result;
}
// 16A74: using guessed type _DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD);
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17944: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17D44: using guessed type _DWORD __cdecl G_BounceMissile(_DWORD, _DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 18D54: using guessed type _DWORD __cdecl SnapVectorTowards(_DWORD, _DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 191C4: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);
// D2968: using guessed type int dword_D2968;

//----- (0005E1C8) --------------------------------------------------------
int __cdecl Concussive_think(int a1)
{
  int result; // eax

  if ( (long double)(int)level[123] > *(float *)(a1 + 644) )
    *(_DWORD *)(a1 + 528) = G_FreeEntity;
  result = a1;
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  return result;
}

//----- (0005E221) --------------------------------------------------------
_DWORD *__cdecl Concussive_fx(float *a1)
{
  float *v1; // eax
  float *v2; // edx
  _DWORD *result; // eax

  v1 = (float *)G_Spawn();
  v1[79] = *a1;
  v1[80] = a1[1];
  v1[81] = a1[2];
  *((_DWORD *)v1 + 132) = Concussive_think;
  *((_DWORD *)v1 + 131) = level[123] + 100;
  v2 = v1;
  result = level;
  v2[161] = (long double)(int)level[123] + 500.0;
  return result;
}
// 167A4: using guessed type int G_Spawn(void);

//----- (0005E2B5) --------------------------------------------------------
int __cdecl G_ExplodeMissile(float *a1)
{
  int result; // eax
  unsigned __int8 v2; // al
  float v3; // [esp+Ch] [ebp-ECh]
  float v4; // [esp+10h] [ebp-E8h]
  float v5; // [esp+14h] [ebp-E4h]
  float v6[4]; // [esp+30h] [ebp-C8h] BYREF
  float v7; // [esp+40h] [ebp-B8h] BYREF
  float v8; // [esp+44h] [ebp-B4h]
  float v9; // [esp+48h] [ebp-B0h]
  int v10; // [esp+50h] [ebp-A8h]
  int v11; // [esp+54h] [ebp-A4h]
  int v12; // [esp+58h] [ebp-A0h]
  int v13[2]; // [esp+60h] [ebp-98h] BYREF
  float v14; // [esp+68h] [ebp-90h]
  int v15; // [esp+78h] [ebp-80h]
  int v16; // [esp+7Ch] [ebp-7Ch]
  float v17; // [esp+80h] [ebp-78h] BYREF
  _BYTE v18[12]; // [esp+84h] [ebp-74h] BYREF
  _DWORD v19[10]; // [esp+90h] [ebp-68h] BYREF
  int v21; // [esp+BCh] [ebp-3Ch]
  int v22[2]; // [esp+C0h] [ebp-38h] BYREF
  float v23; // [esp+C8h] [ebp-30h]
  float v24; // [esp+D0h] [ebp-28h] BYREF
  float v25; // [esp+D4h] [ebp-24h]
  float v26; // [esp+D8h] [ebp-20h]
  int v27; // [esp+E0h] [ebp-18h]
  int v28; // [esp+E4h] [ebp-14h]
  int v29; // [esp+E8h] [ebp-10h]

  v16 = 0;
  v15 = 0;
  if ( *((_DWORD *)a1 + 85) == 1023 )
    a1[85] = a1[204];
  if ( *((_DWORD *)a1 + 106) )
  {
    v15 = *((_DWORD *)a1 + 106);
    if ( *(_DWORD *)(v15 + 4) == 11 && *(_DWORD *)(v15 + 340) != 1023 )
      v15 = (int)&g_entities[211 * *(_DWORD *)(v15 + 340)];
  }
  BG_EvaluateTrajectory(a1 + 3, level[123], &v24);
  v24 = (float)(int)v24;
  v25 = (float)(int)v25;
  v26 = (float)(int)v26;
  G_SetOrigin(a1, &v24);
  v28 = 0;
  v27 = 0;
  v29 = 1065353216;
  v21 = *((_DWORD *)a1 + 1);
  a1[1] = 0.0;
  *((_DWORD *)a1 + 2) |= 0x80u;
  *((_DWORD *)a1 + 99) |= 0x1000u;
  *((_DWORD *)a1 + 62) |= 8u;
  a1[72] = 0.0;
  if ( *((_WORD *)a1 + 194) == scr_const[24] )
  {
    *((_DWORD *)a1 + 101) = 1;
    result = trap_LinkEntity(a1);
  }
  else
  {
    v22[0] = (int)a1[79];
    v22[1] = (int)a1[80];
    v23 = a1[81];
    v23 = v23 - 16.0;
    trap_Trace(&v17, a1 + 79, &vec3_origin, &vec3_origin, v22, *(_DWORD *)a1, 17);
    v2 = DirToByte(v19);
    G_AddEvent(a1, 185, v2);
    v16 = BG_GetInfoForWeapon(*((_DWORD *)a1 + 51));
    a1[55] = *(float *)(v16 + 912);
    if ( trap_PointContents(a1 + 79, -1, 32) )
    {
      v13[0] = (int)a1[79];
      v13[1] = (int)a1[80];
      v14 = a1[81];
      v14 = v14 + 500.0;
      trap_Trace(&v17, v13, &vec3_origin, &vec3_origin, v22, *(_DWORD *)a1, 32);
      if ( v17 < 1.0 )
        G_SetOrigin(a1, v18);
      *((_DWORD *)a1 + 34) = 20;
    }
    else
    {
      *((_DWORD *)a1 + 34) = (v19[3] & 0x1F00000) >> 20;
    }
    *((_DWORD *)a1 + 101) = 1;
    if ( *((_DWORD *)a1 + 147) )
    {
      v10 = 0;
      v11 = 0;
      v12 = 1092616192;
      v7 = a1[79];
      v8 = a1[80];
      v9 = a1[81];
      v6[0] = v7 + 0.0;
      v6[1] = v8 + 0.0;
      v6[2] = v9 + 10.0;
      trap_Trace(&v17, &v7, &vec3_origin, &vec3_origin, v6, *(_DWORD *)a1, 17);
      v5 = (float)*((int *)a1 + 149);
      v4 = (float)*((int *)a1 + 148);
      v3 = (float)*((int *)a1 + 147);
      G_RadiusDamage((int)v18, (int)a1, v15, v3, v4, v5, (int)a1, *((_DWORD *)a1 + 151));
    }
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0005E7B5) --------------------------------------------------------
int (__cdecl *__cdecl G_BarrageThink(int a1))(void *s)
{
  long double v1; // fst6
  long double v2; // fst6
  long double v3; // fst6
  int (__cdecl *result)(void *); // eax
  float v5; // [esp+18h] [ebp-60h]
  float v6[2]; // [esp+20h] [ebp-58h] BYREF
  float v7; // [esp+28h] [ebp-50h]
  float v8[4]; // [esp+30h] [ebp-48h] BYREF
  int v9; // [esp+40h] [ebp-38h] BYREF
  float v10; // [esp+44h] [ebp-34h]
  int v11; // [esp+48h] [ebp-30h]
  int v12; // [esp+58h] [ebp-20h]
  _DWORD *v13; // [esp+5Ch] [ebp-1Ch]

  v9 = 0;
  v10 = 0.0;
  v11 = 0;
  v13 = (_DWORD *)BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
  *(_DWORD *)(a1 + 524) += 50;
  if ( *(_DWORD *)(a1 + 608) < v13[232] && *(_DWORD *)(a1 + 588) < level[123] )
  {
    ++*(_DWORD *)(a1 + 608);
    v5 = (float)*(int *)(a1 + 588);
    *(_DWORD *)(a1 + 588) = (int)((long double)(int)irand(v13[235], v13[236]) * 0.5 + v5);
    v12 = G_TempEntity(a1 + 316, 183);
    *(_DWORD *)(v12 + 164) = v13[228];
  }
  if ( *(_DWORD *)(a1 + 732) < v13[232] && *(_DWORD *)(a1 + 592) < level[123] )
  {
    ++*(_DWORD *)(a1 + 732);
    *(_DWORD *)(a1 + 592) += irand(v13[235], v13[236]);
    v10 = (float)(int)irand(0, 360);
    AngleVectors(&v9, v8, 0, 0);
    v1 = (long double)rand() / 2147483600.0;
    v6[0] = (v1 + v1 - 1.0) * (long double)(int)v13[233] * v8[0] + *(float *)(a1 + 316);
    v2 = (long double)rand() / 2147483600.0;
    v6[1] = (v2 + v2 - 1.0) * (long double)(int)v13[233] * v8[1] + *(float *)(a1 + 320);
    v3 = (long double)rand() / 2147483600.0;
    v7 = (v3 + v3 - 1.0) * (long double)(int)v13[233] * v8[2] + *(float *)(a1 + 324);
    v12 = G_TempEntity(v6, 184);
    *(_DWORD *)(v12 + 164) = v13[228];
    v7 = v7 + 1000.0;
    fire_artillery(a1, v6, 1750);
  }
  result = *(int (__cdecl **)(void *))(a1 + 608);
  if ( (int)result >= v13[232] )
  {
    result = *(int (__cdecl **)(void *))(a1 + 732);
    if ( (int)result >= v13[232] )
    {
      result = G_FreeEntity;
      *(_DWORD *)(a1 + 528) = G_FreeEntity;
    }
  }
  return result;
}
// 16804: using guessed type _DWORD __cdecl irand(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18424: using guessed type _DWORD __cdecl fire_artillery(_DWORD, _DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0005EABE) --------------------------------------------------------
int __cdecl G_DropArtillery(_DWORD *a1)
{
  int result; // eax

  a1[131] = level[123] + 15000;
  a1[132] = G_ExplodeMissile;
  a1[62] = 136;
  a1[3] = 5;
  result = level[123] - 50;
  a1[4] = result;
  return result;
}

//----- (0005EB25) --------------------------------------------------------
int __cdecl G_MissileDie(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a2 != a1 )
  {
    *(_BYTE *)(a1 + 381) = 0;
    *(_DWORD *)(a1 + 528) = G_ExplodeMissile;
    result = level[123] + 10;
    *(_DWORD *)(a1 + 524) = result;
  }
  return result;
}

//----- (0005EB72) --------------------------------------------------------
int __cdecl G_ExplodeSmokeGrenade(float *a1)
{
  unsigned __int8 v1; // al
  char v3[16]; // [esp+30h] [ebp-78h] BYREF
  _DWORD v4[10]; // [esp+40h] [ebp-68h] BYREF
  int v6; // [esp+6Ch] [ebp-3Ch]
  int v7[2]; // [esp+70h] [ebp-38h] BYREF
  float v8; // [esp+78h] [ebp-30h]
  float v9; // [esp+80h] [ebp-28h] BYREF
  float v10; // [esp+84h] [ebp-24h]
  float v11; // [esp+88h] [ebp-20h]
  int v12; // [esp+90h] [ebp-18h]
  int v13; // [esp+94h] [ebp-14h]
  int v14; // [esp+98h] [ebp-10h]

  if ( *((_DWORD *)a1 + 85) == 1023 )
    a1[85] = a1[204];
  BG_EvaluateTrajectory(a1 + 3, level[123], &v9);
  v9 = (float)(int)v9;
  v10 = (float)(int)v10;
  v11 = (float)(int)v11;
  v13 = 0;
  v12 = 0;
  v14 = 1065353216;
  v6 = *((_DWORD *)a1 + 1);
  *((_DWORD *)a1 + 131) = level[123] + 15000;
  *((_DWORD *)a1 + 132) = G_FreeEntity;
  v7[0] = (int)a1[79];
  v7[1] = (int)a1[80];
  v8 = a1[81];
  v8 = v8 - 16.0;
  trap_Trace(v3, a1 + 79, vec3_origin, vec3_origin, v7, *(_DWORD *)a1, 17);
  v1 = DirToByte(v4);
  G_AddEvent(a1, 185, v1);
  a1[55] = *(float *)(BG_GetInfoForWeapon(*((_DWORD *)a1 + 51)) + 912);
  if ( trap_PointContents(a1 + 79, -1, 32) )
    *((_DWORD *)a1 + 34) = 20;
  else
    *((_DWORD *)a1 + 34) = (v4[3] & 0x1F00000) >> 20;
  return trap_LinkEntity(a1);
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0005EDAE) --------------------------------------------------------
void __cdecl G_MissileTrace(int a1, float *a2, float *a3, int a4, int a5)
{
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  trap_LocationalTrace(a1, a2, a3, a4, a5, &bulletPriorityMap);
  if ( *(_BYTE *)(a1 + 47) && (*(_DWORD *)(a1 + 32) & 0x800) != 0 )
  {
    *(_BYTE *)(a1 + 47) = 0;
    *(_DWORD *)a1 = 1065353216;
  }
  else if ( *(_BYTE *)(a1 + 47) )
  {
    *(_DWORD *)a1 = 0;
    v5[0] = *a2 - *a3;
    v5[1] = a2[1] - a3[1];
    v5[2] = a2[2] - a3[2];
    VectorNormalize2(v5, a1 + 16);
  }
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (0005EE7D) --------------------------------------------------------
void *__cdecl G_RunMissile(void *s)
{
  void *result; // eax
  float v2; // [esp+24h] [ebp-C4h]
  int v3; // [esp+28h] [ebp-C0h]
  _DWORD *v4; // [esp+2Ch] [ebp-BCh]
  _DWORD *v5; // [esp+2Ch] [ebp-BCh]
  char v6[8]; // [esp+30h] [ebp-B8h] BYREF
  float v7; // [esp+38h] [ebp-B0h]
  int v8[4]; // [esp+40h] [ebp-A8h] BYREF
  float v9[12]; // [esp+50h] [ebp-98h] BYREF
  float v10[12]; // [esp+80h] [ebp-68h] BYREF
  float v11[4]; // [esp+B0h] [ebp-38h] BYREF
  float v12; // [esp+C0h] [ebp-28h] BYREF
  float v13; // [esp+C4h] [ebp-24h]
  float v14; // [esp+C8h] [ebp-20h]

  if ( !*((_DWORD *)s + 3) && *((_DWORD *)s + 31) != 1022 )
  {
    v12 = *((float *)s + 79);
    v13 = *((float *)s + 80);
    v14 = *((float *)s + 81);
    v14 = v14 - 1.5;
    G_MissileTrace(v10, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104));
    if ( v10[0] == 1.0 )
    {
      *((_DWORD *)s + 3) = 5;
      *((_DWORD *)s + 4) = level[123];
      *((_DWORD *)s + 5) = 0;
      *((_DWORD *)s + 6) = *((_DWORD *)s + 79);
      *((_DWORD *)s + 7) = *((_DWORD *)s + 80);
      *((_DWORD *)s + 8) = *((_DWORD *)s + 81);
      *((_DWORD *)s + 11) = 0;
      *((_DWORD *)s + 10) = 0;
      *((_DWORD *)s + 9) = 0;
    }
  }
  v8[0] = *((_DWORD *)s + 79);
  v8[1] = *((_DWORD *)s + 80);
  v8[2] = *((_DWORD *)s + 81);
  BG_EvaluateTrajectory((char *)s + 12, level[123], &v12);
  v11[0] = v12 - *((float *)s + 79);
  v11[1] = v13 - *((float *)s + 80);
  v11[2] = v14 - *((float *)s + 81);
  if ( VectorNormalize(v11) < 0.001 )
    return (void *)G_RunThink(s);
  if ( fabs(*((float *)s + 11)) <= 30.0 || trap_PointContents((char *)s + 316, -1, 32) )
    G_MissileTrace(v10, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104));
  else
    G_MissileTrace(v10, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104) | 0x20);
  if ( (LODWORD(v10[7]) & 0x1F00000) == 20971520 )
  {
    VectorNormalize2((char *)s + 36, v6);
    if ( v7 < 0.0 )
      v7 = v7 * -1.0;
    v4 = (_DWORD *)G_TempEntity((char *)s + 316, 178);
    v4[41] = (unsigned __int8)DirToByte(&v10[4]);
    v4[55] = (unsigned __int8)DirToByte(v6);
    v4[34] = (LODWORD(v10[7]) & 0x1F00000) >> 20;
    v4[51] = *((_DWORD *)s + 51);
    v4[29] = *(_DWORD *)s;
    if ( *(_DWORD *)(BG_GetInfoForWeapon(*((_DWORD *)s + 51)) + 912) == 1 )
      return (void *)G_FreeEntity(s);
    G_MissileTrace(v10, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104));
  }
  if ( (LOBYTE(v10[7]) & 4) != 0 )
  {
    v10[1] = v10[4] * -2.0 + v10[1];
    v10[2] = v10[5] * -2.0 + v10[2];
    v10[3] = v10[6] * -2.0 + v10[3];
  }
  if ( *((_DWORD *)s + 150) == 3 && (g_entities[211 * LOWORD(v10[10]) + 99] & 0x10000) != 0 )
  {
    v5 = &g_entities[211 * LOWORD(v10[10])];
    v3 = v5[72];
    v5[72] = 0;
    G_MissileTrace(v10, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104));
    v5[72] = v3;
  }
  *((float *)s + 79) = v10[1];
  *((float *)s + 80) = v10[2];
  *((float *)s + 81) = v10[3];
  if ( HIBYTE(v10[11]) )
    v10[0] = 0.0;
  if ( (*((_DWORD *)s + 2) & 0x3000000) != 0 && (v10[0] == 1.0 || v10[0] < 1.0 && v10[6] > 0.69999999) )
  {
    v12 = *((float *)s + 79);
    v13 = *((float *)s + 80);
    v14 = *((float *)s + 81);
    v14 = v14 - 1.5;
    G_MissileTrace(v9, (char *)s + 316, &v12, *((_DWORD *)s + 85), *((_DWORD *)s + 104));
    if ( v9[0] != 1.0 && LOWORD(v9[10]) == 1022 )
    {
      qmemcpy(v10, v9, sizeof(v10));
      *((float *)s + 8) = v10[3] + 1.5 - *((float *)s + 81) + *((float *)s + 8);
      *((float *)s + 79) = v10[1];
      *((float *)s + 80) = v10[2];
      *((float *)s + 81) = v10[3];
      *((float *)s + 81) = *((float *)s + 81) + 1.5;
    }
  }
  trap_LinkEntity(s);
  if ( *((_DWORD *)s + 150) == 3 )
    G_GrenadeTouchTriggerDamage(s, v8, (char *)s + 316, *((_DWORD *)s + 147), *((_DWORD *)s + 150));
  if ( v10[0] == 1.0 )
  {
    v2 = sqrt(
           *((float *)s + 9) * *((float *)s + 9)
         + *((float *)s + 10) * *((float *)s + 10)
         + *((float *)s + 11) * *((float *)s + 11));
    if ( v2 != 0.0 )
      *((_DWORD *)s + 31) = 1023;
    return (void *)G_RunThink(s);
  }
  if ( (LOBYTE(v10[7]) & 4) != 0 )
    return (void *)G_RunThink(s);
  if ( (LOBYTE(v10[7]) & 0x10) != 0 )
    return (void *)G_FreeEntity(s);
  G_MissileImpact(s, v10);
  result = s;
  if ( *((_DWORD *)s + 1) == 4 )
    return (void *)G_RunThink(s);
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177A4: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 17EB4: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 17EE4: using guessed type _DWORD __cdecl G_MissileImpact(_DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 18B34: using guessed type _DWORD __cdecl G_GrenadeTouchTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18E84: using guessed type _DWORD __cdecl G_MissileTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0005F5EB) --------------------------------------------------------
int __cdecl DynaSink(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  if ( *(_DWORD *)(a1 + 476) >= level[123] )
  {
    *(float *)(a1 + 32) = *(float *)(a1 + 32) - 0.5;
    result = level[123] + 50;
  }
  else
  {
    *(_DWORD *)(a1 + 528) = G_FreeEntity;
    result = level[123] + 100;
  }
  *(_DWORD *)(a1 + 524) = result;
  return result;
}

//----- (0005F683) --------------------------------------------------------
int __cdecl G_GrenadeDie(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 524) = level[123] + 100;
  result = a1;
  *(_BYTE *)(a1 + 381) = 0;
  return result;
}

//----- (0005F6B7) --------------------------------------------------------
int (__cdecl *__cdecl G_GrenadeLeaveOwnerThink(int (__cdecl *a1)(float *a1)))(float *a1)
{
  int (__cdecl *result)(float *); // eax
  char v2[56]; // [esp+30h] [ebp-38h] BYREF

  G_MissileTrace(v2, (char *)a1 + 316, (char *)a1 + 316, 1023, 0x2000000);
  if ( level[123] < *((_DWORD *)a1 + 203) - 100 && (v2[46] || v2[47]) )
  {
    result = a1;
    *((_DWORD *)a1 + 131) = level[123] + 100;
  }
  else
  {
    *((_DWORD *)a1 + 131) = *((_DWORD *)a1 + 203);
    *((_DWORD *)a1 + 85) = *(_DWORD *)a1;
    trap_LinkEntity(a1);
    if ( *(_DWORD *)(BG_GetInfoForWeapon(*((_DWORD *)a1 + 51)) + 912) == 1 )
      result = G_ExplodeSmokeGrenade;
    else
      result = G_ExplodeMissile;
    *((_DWORD *)a1 + 132) = result;
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18E84: using guessed type _DWORD __cdecl G_MissileTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005F7AD) --------------------------------------------------------
int __cdecl fire_grenade(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int (__cdecl *v4)(float *); // eax
  long double v5; // fst7
  long double v6; // fst7
  float v8; // [esp+0h] [ebp-28h]
  int v9; // [esp+18h] [ebp-10h]
  int v10; // [esp+1Ch] [ebp-Ch]

  v10 = G_Spawn();
  if ( a1[88] && *(_DWORD *)(a1[88] + 52) )
    *(_DWORD *)(v10 + 524) = level[123] + *(_DWORD *)(a1[88] + 52);
  else
    *(_DWORD *)(v10 + 524) = level[123] + 2500;
  *(_DWORD *)(v10 + 812) = *(_DWORD *)(v10 + 524);
  if ( a1[88] )
    *(_DWORD *)(a1[88] + 52) = 0;
  v9 = BG_GetInfoForWeapon(a4);
  if ( *(_DWORD *)(v9 + 912) == 1 )
    v4 = G_ExplodeSmokeGrenade;
  else
    v4 = G_ExplodeMissile;
  *(_DWORD *)(v10 + 528) = v4;
  *(_DWORD *)(v10 + 4) = 4;
  *(_DWORD *)(v10 + 248) = 136;
  *(_DWORD *)(v10 + 204) = a4;
  *(_DWORD *)(v10 + 340) = *a1;
  *(_DWORD *)(v10 + 424) = a1;
  Scr_SetString(v10 + 388, scr_const[31]);
  *(_DWORD *)(v10 + 584) = *(_DWORD *)(v9 + 520);
  *(_DWORD *)(v10 + 588) = *(_DWORD *)(v9 + 892);
  *(_DWORD *)(v10 + 592) = *(_DWORD *)(v9 + 896);
  *(_DWORD *)(v10 + 596) = *(_DWORD *)(v9 + 888);
  *(_DWORD *)(v10 + 600) = 3;
  *(_DWORD *)(v10 + 604) = 4;
  *(_DWORD *)(v10 + 8) = 50331648;
  *(_DWORD *)(v10 + 416) = 41951377;
  *(_DWORD *)(v10 + 12) = 5;
  *(_DWORD *)(v10 + 16) = level[123];
  *(_DWORD *)(v10 + 24) = *a2;
  *(_DWORD *)(v10 + 28) = a2[1];
  *(_DWORD *)(v10 + 32) = a2[2];
  *(_DWORD *)(v10 + 36) = *a3;
  *(_DWORD *)(v10 + 40) = a3[1];
  *(_DWORD *)(v10 + 44) = a3[2];
  *(float *)(v10 + 36) = (float)(int)*(float *)(v10 + 36);
  *(float *)(v10 + 40) = (float)(int)*(float *)(v10 + 40);
  *(float *)(v10 + 44) = (float)(int)*(float *)(v10 + 44);
  *(_DWORD *)(v10 + 48) = 2;
  *(_DWORD *)(v10 + 52) = level[123];
  vectoangles(a3, v10 + 60);
  v5 = *(float *)(v10 + 60) - 120.0;
  v8 = v5;
  AngleNormalize360(v8);
  *(float *)(v10 + 60) = v5;
  flrand(-45.0, 45.0);
  v6 = v5 + 720.0;
  *(float *)(v10 + 72) = v6;
  *(_DWORD *)(v10 + 76) = 0;
  flrand(-45.0, 45.0);
  *(float *)(v10 + 80) = v6 + 360.0;
  *(_DWORD *)(v10 + 316) = *a2;
  *(_DWORD *)(v10 + 320) = a2[1];
  *(_DWORD *)(v10 + 324) = a2[2];
  *(_DWORD *)(v10 + 328) = *(_DWORD *)(v10 + 60);
  *(_DWORD *)(v10 + 332) = *(_DWORD *)(v10 + 64);
  *(_DWORD *)(v10 + 336) = *(_DWORD *)(v10 + 68);
  *(_BYTE *)(v10 + 381) = *(_BYTE *)(v9 + 524);
  if ( *(_BYTE *)(v10 + 381) && *(_DWORD *)(v10 + 812) > level[123] + 500 )
  {
    *(_DWORD *)(v10 + 264) = -1061158912;
    *(_DWORD *)(v10 + 268) = -1061158912;
    *(_DWORD *)(v10 + 272) = 0;
    *(_DWORD *)(v10 + 276) = 1086324736;
    *(_DWORD *)(v10 + 280) = 1086324736;
    *(_DWORD *)(v10 + 284) = 1086324736;
    *(_DWORD *)(v10 + 288) = 0x2000;
    *(_DWORD *)(v10 + 248) |= 0x200u;
    *(_DWORD *)(v10 + 248) &= 0xFFFFFFF9;
    *(_DWORD *)(v10 + 8) |= 0x10u;
    *(_DWORD *)(v10 + 576) = 1;
    *(_DWORD *)(v10 + 552) = G_GrenadeDie;
    *(_DWORD *)(v10 + 816) = *(_DWORD *)(v10 + 340);
    *(_DWORD *)(v10 + 528) = G_GrenadeLeaveOwnerThink;
    *(_DWORD *)(v10 + 524) = level[123] + 500;
    trap_LinkEntity(v10);
  }
  return v10;
}
// 167A4: using guessed type int G_Spawn(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0005FC74) --------------------------------------------------------
int __cdecl fire_rocket(_DWORD *a1, _DWORD *a2, float *a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  VectorNormalize(a3);
  v4 = (_DWORD *)BG_GetInfoForWeapon(a1[51]);
  v5 = G_Spawn();
  Scr_SetString(v5 + 388, scr_const[59]);
  *(_DWORD *)(v5 + 524) = level[123] + 15000;
  *(_DWORD *)(v5 + 528) = G_ExplodeMissile;
  *(_DWORD *)(v5 + 4) = 4;
  *(_DWORD *)(v5 + 8) |= 0x8000u;
  *(_DWORD *)(v5 + 248) = 136;
  *(_DWORD *)(v5 + 204) = a1[51];
  if ( a1[1] == 12 )
    *(_DWORD *)(v5 + 816) = a1[85];
  else
    *(_DWORD *)(v5 + 816) = 1023;
  *(_DWORD *)(v5 + 340) = *a1;
  *(_DWORD *)(v5 + 424) = a1;
  *(_DWORD *)(v5 + 584) = v4[130];
  *(_DWORD *)(v5 + 588) = v4[223];
  *(_DWORD *)(v5 + 592) = v4[224];
  *(_DWORD *)(v5 + 596) = v4[222];
  *(_DWORD *)(v5 + 600) = 5;
  *(_DWORD *)(v5 + 604) = 6;
  *(_DWORD *)(v5 + 416) = 41951377;
  *(_DWORD *)(v5 + 12) = 2;
  *(_DWORD *)(v5 + 16) = level[123] - 50;
  *(_DWORD *)(v5 + 24) = *a2;
  *(_DWORD *)(v5 + 28) = a2[1];
  *(_DWORD *)(v5 + 32) = a2[2];
  *(float *)(v5 + 36) = (long double)(int)v4[225] * *a3;
  *(float *)(v5 + 40) = (long double)(int)v4[225] * a3[1];
  *(float *)(v5 + 44) = (long double)(int)v4[225] * a3[2];
  *(float *)(v5 + 36) = (float)(int)*(float *)(v5 + 36);
  *(float *)(v5 + 40) = (float)(int)*(float *)(v5 + 40);
  *(float *)(v5 + 44) = (float)(int)*(float *)(v5 + 44);
  *(_DWORD *)(v5 + 316) = *a2;
  *(_DWORD *)(v5 + 320) = a2[1];
  *(_DWORD *)(v5 + 324) = a2[2];
  vectoangles(v5 + 36, v5 + 328);
  G_SetAngle(v5, v5 + 328);
  return v5;
}
// 167A4: using guessed type int G_Spawn(void);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17474: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 5E2B5: using guessed type int __cdecl G_ExplodeMissile(int);

//----- (0005FF4A) --------------------------------------------------------
int __cdecl fire_artillery(_DWORD *a1, int *a2, int a3)
{
  float v4; // [esp+10h] [ebp-38h] BYREF
  float v5; // [esp+14h] [ebp-34h]
  float v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  float v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+38h] [ebp-10h]
  int v11; // [esp+3Ch] [ebp-Ch]

  v4 = 0.0;
  v5 = 0.0;
  v6 = -1.0;
  v10 = BG_GetInfoForWeapon(a1[51]);
  v11 = G_Spawn();
  Scr_SetString(v11 + 388, scr_const[59]);
  *(_DWORD *)(v11 + 524) = level[123] + a3;
  *(_DWORD *)(v11 + 528) = G_DropArtillery;
  *(_DWORD *)(v11 + 4) = 4;
  *(_DWORD *)(v11 + 8) |= 0x8000u;
  *(_DWORD *)(v11 + 248) = 1;
  *(_DWORD *)(v11 + 204) = a1[51];
  if ( g_entities[211 * *a1 + 1] )
  {
    *(_DWORD *)(v11 + 340) = *a1;
    *(_DWORD *)(v11 + 424) = a1;
  }
  else
  {
    *(_DWORD *)(v11 + 340) = a1[85];
    *(_DWORD *)(v11 + 424) = &g_entities[211 * a1[85]];
  }
  *(_DWORD *)(v11 + 584) = *(_DWORD *)(v10 + 520);
  *(_DWORD *)(v11 + 588) = *(_DWORD *)(v10 + 892);
  *(_DWORD *)(v11 + 592) = *(_DWORD *)(v10 + 896);
  *(_DWORD *)(v11 + 596) = *(_DWORD *)(v10 + 888);
  *(_DWORD *)(v11 + 600) = 13;
  *(_DWORD *)(v11 + 604) = 14;
  *(_DWORD *)(v11 + 416) = 41951377;
  *(_DWORD *)(v11 + 124) = 1022;
  *(_DWORD *)(v11 + 12) = 0;
  v7 = *a2;
  v8 = a2[1];
  v9 = *((float *)a2 + 2);
  v9 = v9 + 1000.0;
  *(_DWORD *)(v11 + 24) = v7;
  *(_DWORD *)(v11 + 28) = v8;
  *(float *)(v11 + 32) = v9;
  *(float *)(v11 + 36) = (long double)*(int *)(v10 + 900) * v4;
  *(float *)(v11 + 40) = (long double)*(int *)(v10 + 900) * v5;
  *(float *)(v11 + 44) = (long double)*(int *)(v10 + 900) * v6;
  *(_DWORD *)(v11 + 316) = v7;
  *(_DWORD *)(v11 + 320) = v8;
  *(float *)(v11 + 324) = v9;
  vectoangles(&v4, v11 + 328);
  G_SetAngle(v11, v11 + 328);
  G_SetModel(v11, *(char **)(v10 + 908));
  G_DObjUpdate(v11);
  return v11;
}
// 167A4: using guessed type int G_Spawn(void);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (000601FB) --------------------------------------------------------
_DWORD *__cdecl fire_artillery_barrage(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+28h] [ebp-10h]
  _DWORD *v7; // [esp+2Ch] [ebp-Ch]

  v6 = BG_GetInfoForWeapon(a3);
  v7 = (_DWORD *)G_Spawn();
  Scr_SetString(v7 + 97, scr_const[59]);
  v7[131] = level[123] + 50;
  v7[132] = G_BarrageThink;
  v7[1] = 0;
  v7[62] = 1;
  v7[51] = a3;
  v7[85] = *a1;
  v7[106] = a1;
  v4 = a2[1];
  v5 = a2[2];
  v7[79] = *a2;
  v7[80] = v4;
  v7[81] = v5;
  v7[152] = 0;
  v7[183] = 0;
  v7[147] = level[123] + 250;
  v7[148] = level[123] + *(_DWORD *)(v6 + 936);
  Scr_AddVector(a2);
  Scr_Notify(a1, scr_const[157], 1);
  return v7;
}
// 167A4: using guessed type int G_Spawn(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (00060371) --------------------------------------------------------
void sub_60371()
{
  ;
}

//----- (00060378) --------------------------------------------------------
_DWORD *__cdecl G_TestEntityPosition(_DWORD *a1, int a2)
{
  _DWORD *v3; // [esp+28h] [ebp-40h]
  int v4; // [esp+2Ch] [ebp-3Ch]
  char v5[40]; // [esp+30h] [ebp-38h] BYREF
  unsigned __int16 v6; // [esp+58h] [ebp-10h]
  char v7; // [esp+5Fh] [ebp-9h]

  if ( a1[104] )
  {
    if ( a1[72] == 0x4000000 )
      return 0;
    v4 = a1[104];
  }
  else
  {
    v4 = 17;
  }
  if ( a1[1] == 4 )
    trap_Trace(v5, a2, a1 + 66, a1 + 69, a2, a1[85], v4);
  else
    trap_Trace(v5, a2, a1 + 66, a1 + 69, a2, *a1, v4);
  if ( v7 )
    v3 = &g_entities[211 * v6];
  else
    v3 = 0;
  return v3;
}
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00060487) --------------------------------------------------------
int __cdecl G_CreateRotationMatrix(int a1, int a2)
{
  AngleVectors(a1, a2, a2 + 12, a2 + 24);
  return VectorInverse(a2 + 12);
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 183E4: using guessed type _DWORD __cdecl VectorInverse(_DWORD);

//----- (000604D3) --------------------------------------------------------
int *__cdecl G_TransposeMatrix(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (0006053E) --------------------------------------------------------
float *__cdecl G_RotatePoint(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  *a1 = *a2 * *a1 + a2[1] * v4 + a2[2] * v5;
  a1[1] = a2[3] * v3 + a2[4] * v4 + a2[5] * v5;
  result = a2 + 8;
  a1[2] = a2[6] * v3 + a2[7] * v4 + a2[8] * v5;
  return result;
}

//----- (000605E5) --------------------------------------------------------
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, int a4)
{
  int v5; // [esp+14h] [ebp-E4h]
  float v6; // [esp+20h] [ebp-D8h] BYREF
  float v7; // [esp+24h] [ebp-D4h]
  float v8; // [esp+28h] [ebp-D0h]
  float v9; // [esp+38h] [ebp-C0h]
  float v10; // [esp+3Ch] [ebp-BCh]
  float v11; // [esp+40h] [ebp-B8h]
  float v12; // [esp+44h] [ebp-B4h]
  float v13; // [esp+48h] [ebp-B0h]
  float v14; // [esp+4Ch] [ebp-ACh]
  char v15[48]; // [esp+50h] [ebp-A8h] BYREF
  char v16[60]; // [esp+80h] [ebp-78h] BYREF
  int v17; // [esp+BCh] [ebp-3Ch]
  float v18; // [esp+C0h] [ebp-38h]
  float v19; // [esp+C4h] [ebp-34h]
  float v20; // [esp+C8h] [ebp-30h]
  float v21; // [esp+D0h] [ebp-28h] BYREF
  float v22; // [esp+D4h] [ebp-24h]
  float v23; // [esp+D8h] [ebp-20h]
  float v24; // [esp+E0h] [ebp-18h]
  float v25; // [esp+E4h] [ebp-14h]
  float v26; // [esp+E8h] [ebp-10h]

  if ( (*(_DWORD *)(a2 + 8) & 0x4000000) != 0 && *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
    return 0;
  v6 = *(float *)(a1 + 316) + *a3;
  v7 = *(float *)(a1 + 320) + a3[1];
  v8 = *(float *)(a1 + 324) + a3[2];
  G_CreateRotationMatrix(a4, v15);
  G_TransposeMatrix(v15, v16);
  v24 = v6 - *(float *)(a2 + 316);
  v25 = v7 - *(float *)(a2 + 320);
  v26 = v8 - *(float *)(a2 + 324);
  v21 = v24;
  v22 = v25;
  v23 = v26;
  G_RotatePoint(&v21, v16);
  v18 = v21 - v24;
  v19 = v22 - v25;
  v20 = v23 - v26;
  v6 = v6 + v18;
  v7 = v7 + v19;
  v8 = v8 + v20;
  v17 = G_TestEntityPosition(a1, &v6);
  if ( v17 )
  {
    if ( *(float *)(a1 + 276) / 2.0 <= 4.0 )
      goto LABEL_36;
    v24 = v6;
    v25 = v7;
    v26 = v8;
    v10 = 0.0;
LABEL_12:
    if ( *(float *)(a1 + 276) / 2.0 <= v10 )
    {
LABEL_36:
      v17 = G_TestEntityPosition(a1, a1 + 316);
      if ( v17 )
      {
        v5 = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1023;
        v5 = 1;
      }
    }
    else
    {
      LODWORD(v9) = LODWORD(v10) ^ 0x80000000;
      while ( 1 )
      {
        if ( v10 < (long double)v9 )
        {
LABEL_35:
          v10 = v10 + 4.0;
          goto LABEL_12;
        }
        v14 = 4.0;
LABEL_16:
        if ( *(float *)(a1 + 276) / 2.0 > v14 )
          break;
        if ( v9 == 0.0 )
          goto LABEL_35;
        v9 = v10 + v10 + v9;
      }
      LODWORD(v13) = LODWORD(v14) ^ 0x80000000;
      while ( 1 )
      {
        if ( v14 < (long double)v13 )
        {
          v14 = v14 + 4.0;
          goto LABEL_16;
        }
        v12 = 4.0;
LABEL_20:
        if ( *(float *)(a1 + 276) / 2.0 > v12 )
          break;
        v13 = v14 + v14 + v13;
      }
      LODWORD(v11) = LODWORD(v12) ^ 0x80000000;
      while ( 1 )
      {
        if ( v12 < (long double)v11 )
        {
          v12 = v12 + 4.0;
          goto LABEL_20;
        }
        v18 = v13;
        v19 = v11;
        v20 = v9;
        v21 = v24 + v13;
        v22 = v25 + v11;
        v23 = v26 + v9;
        v17 = G_TestEntityPosition(a1, &v21);
        if ( !v17 )
          break;
        v11 = v12 + v12 + v11;
      }
      if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
        *(_DWORD *)(a1 + 124) = 1023;
      *(float *)(a1 + 316) = v21;
      *(float *)(a1 + 320) = v22;
      *(float *)(a1 + 324) = v23;
      *(float *)(a1 + 24) = v21;
      *(float *)(a1 + 28) = v22;
      *(float *)(a1 + 32) = v23;
      if ( *(_DWORD *)(a1 + 352) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 352) + 80) += (unsigned __int16)(int)(*(float *)(a4 + 4) * 182.04445);
        *(float *)(*(_DWORD *)(a1 + 352) + 20) = v21;
        *(float *)(*(_DWORD *)(a1 + 352) + 24) = v22;
        *(float *)(*(_DWORD *)(a1 + 352) + 28) = v23;
      }
      dword_D1C40 += 32;
      v5 = 1;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
      *(_DWORD *)(a1 + 124) = 1023;
    *(float *)(a1 + 316) = v6;
    *(float *)(a1 + 320) = v7;
    *(float *)(a1 + 324) = v8;
    *(float *)(a1 + 24) = v6;
    *(float *)(a1 + 28) = v7;
    *(float *)(a1 + 32) = v8;
    if ( *(_DWORD *)(a1 + 352) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 80) += (unsigned __int16)(int)(*(float *)(a4 + 4) * 182.04445);
      *(float *)(*(_DWORD *)(a1 + 352) + 20) = v6;
      *(float *)(*(_DWORD *)(a1 + 352) + 24) = v7;
      *(float *)(*(_DWORD *)(a1 + 352) + 28) = v8;
    }
    dword_D1C40 += 32;
    v5 = 1;
  }
  return v5;
}
// 16D64: using guessed type _DWORD __cdecl G_TransposeMatrix(_DWORD, _DWORD);
// 17A44: using guessed type _DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD);
// 18164: using guessed type _DWORD __cdecl G_CreateRotationMatrix(_DWORD, _DWORD);
// 18594: using guessed type _DWORD __cdecl G_RotatePoint(_DWORD, _DWORD);
// D1C40: using guessed type int dword_D1C40;

//----- (00060C1B) --------------------------------------------------------
int __cdecl sub_60C1B(int a1, float *a2, float *a3, _DWORD *a4)
{
  float v6; // [esp+3Ch] [ebp-207Ch]
  float v7[4]; // [esp+40h] [ebp-2078h] BYREF
  float v8[6]; // [esp+50h] [ebp-2068h] BYREF
  int v9; // [esp+68h] [ebp-2050h]
  int v10; // [esp+6Ch] [ebp-204Ch]
  int v11[1024]; // [esp+70h] [ebp-2048h]
  int v12[1024]; // [esp+1070h] [ebp-1048h] BYREF
  float v13[4]; // [esp+2070h] [ebp-48h]
  float v14[5]; // [esp+2080h] [ebp-38h]
  _DWORD *v15; // [esp+2094h] [ebp-24h]
  int j; // [esp+2098h] [ebp-20h]
  int i; // [esp+209Ch] [ebp-1Ch]

  *a4 = 0;
  if ( *(float *)(a1 + 328) == 0.0
    && *(float *)(a1 + 332) == 0.0
    && *(float *)(a1 + 336) == 0.0
    && *a3 == 0.0
    && a3[1] == 0.0
    && a3[2] == 0.0 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v14[i] = *(float *)(a1 + 4 * i + 292) + a2[i];
      v13[i] = *(float *)(a1 + 4 * i + 304) + a2[i];
    }
    v8[0] = *(float *)(a1 + 292);
    v8[1] = *(float *)(a1 + 296);
    v8[2] = *(float *)(a1 + 300);
    v7[0] = *(float *)(a1 + 304);
    v7[1] = *(float *)(a1 + 308);
    v7[2] = *(float *)(a1 + 312);
  }
  else
  {
    v6 = RadiusFromBounds(a1 + 264, a1 + 276);
    for ( i = 0; i <= 2; ++i )
    {
      v14[i] = *(float *)(a1 + 4 * i + 316) - v6 + a2[i];
      v13[i] = *(float *)(a1 + 4 * i + 316) + v6 + a2[i];
      v8[i] = *(float *)(a1 + 4 * i + 316) - v6;
      v7[i] = *(float *)(a1 + 4 * i + 316) + v6;
    }
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a2[i] <= 0.0 )
      v8[i] = v8[i] + a2[i];
    else
      v7[i] = v7[i] + a2[i];
  }
  trap_UnlinkEntity(a1);
  v10 = trap_EntitiesInBox(v8, v7, v12, 1024, 33554816);
  *(float *)(a1 + 316) = *(float *)(a1 + 316) + *a2;
  *(float *)(a1 + 320) = *(float *)(a1 + 320) + a2[1];
  *(float *)(a1 + 324) = *(float *)(a1 + 324) + a2[2];
  *(float *)(a1 + 328) = *(float *)(a1 + 328) + *a3;
  *(float *)(a1 + 332) = *(float *)(a1 + 332) + a3[1];
  *(float *)(a1 + 336) = *(float *)(a1 + 336) + a3[2];
  trap_LinkEntity(a1);
  v9 = 0;
  for ( j = 0; j < v10; ++j )
  {
    v15 = &g_entities[211 * v12[j]];
    if ( (v15[1] == 4 || v15[1] == 3 || v15[1] == 1 || *((_BYTE *)v15 + 365))
      && (v15[31] == *(_DWORD *)a1
       || *((float *)v15 + 73) < (long double)v13[0]
       && *((float *)v15 + 74) < (long double)v13[1]
       && *((float *)v15 + 75) < (long double)v13[2]
       && v14[0] < (long double)*((float *)v15 + 76)
       && v14[1] < (long double)*((float *)v15 + 77)
       && v14[2] < (long double)*((float *)v15 + 78)
       && G_TestEntityPosition(v15, v15 + 79) == a1) )
    {
      v11[v9++] = v12[j];
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[211 * v11[j]];
    trap_UnlinkEntity(v15);
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[211 * v11[j]];
    *(_DWORD *)dword_D1C40 = v15;
    *(_DWORD *)(dword_D1C40 + 4) = v15[79];
    *(_DWORD *)(dword_D1C40 + 8) = v15[80];
    *(_DWORD *)(dword_D1C40 + 12) = v15[81];
    *(float *)(dword_D1C40 + 28) = a3[1];
    if ( G_TryPushingEntity(v15, a1, a2, a3) || v15[1] == 3 )
    {
      trap_LinkEntity(v15);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 12) != 4 && *(_DWORD *)(a1 + 48) != 4 )
      {
        *a4 = v15;
        return 0;
      }
      G_Damage(v15, a1, a1, 0, 0, sub_1869F, 0, 16, 0);
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[211 * v11[j]];
    trap_LinkEntity(v15);
  }
  return 1;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 176D4: using guessed type _DWORD __cdecl G_TryPushingEntity(_DWORD, _DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17A44: using guessed type _DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 1869F: using guessed type int sub_1869F();
// 18CE4: using guessed type double __cdecl RadiusFromBounds(_DWORD, _DWORD);
// D1C40: using guessed type int dword_D1C40;

//----- (000612F9) --------------------------------------------------------
int __cdecl G_MoverTeam(int a1)
{
  int result; // eax
  unsigned int j; // [esp+18h] [ebp-70h]
  _DWORD *v3; // [esp+1Ch] [ebp-6Ch]
  float v4[4]; // [esp+20h] [ebp-68h] BYREF
  float v5[6]; // [esp+30h] [ebp-58h] BYREF
  int v6; // [esp+48h] [ebp-40h] BYREF
  int i; // [esp+4Ch] [ebp-3Ch]
  float v8[4]; // [esp+50h] [ebp-38h] BYREF
  float v9[10]; // [esp+60h] [ebp-28h] BYREF

  v6 = 0;
  dword_D1C40 = (int)&pushed;
  for ( i = a1; i; i = *(_DWORD *)(i + 624) )
  {
    BG_EvaluateTrajectory(i + 12, level[123], v5);
    BG_EvaluateTrajectory(i + 48, level[123], v4);
    v9[0] = v5[0] - *(float *)(i + 316);
    v9[1] = v5[1] - *(float *)(i + 320);
    v9[2] = v5[2] - *(float *)(i + 324);
    v8[0] = v4[0] - *(float *)(i + 328);
    v8[1] = v4[1] - *(float *)(i + 332);
    v8[2] = v4[2] - *(float *)(i + 336);
    if ( !sub_60C1B(i, v9, v8, &v6) )
    {
      for ( j = dword_D1C40 - 32; j >= (unsigned int)&pushed; j -= 32 )
      {
        v3 = *(_DWORD **)j;
        v3[79] = *(_DWORD *)(j + 4);
        v3[80] = *(_DWORD *)(j + 8);
        v3[81] = *(_DWORD *)(j + 12);
        v3[6] = *(_DWORD *)(j + 4);
        v3[7] = *(_DWORD *)(j + 8);
        v3[8] = *(_DWORD *)(j + 12);
        if ( v3[88] )
        {
          *(_DWORD *)(v3[88] + 80) -= (unsigned __int16)(int)(*(float *)(j + 28) * 182.04445);
          *(_DWORD *)(v3[88] + 20) = *(_DWORD *)(j + 4);
          *(_DWORD *)(v3[88] + 24) = *(_DWORD *)(j + 8);
          *(_DWORD *)(v3[88] + 28) = *(_DWORD *)(j + 12);
        }
        trap_LinkEntity(v3);
      }
      for ( i = a1; i; i = *(_DWORD *)(i + 624) )
      {
        *(_DWORD *)(i + 16) += level[123] - level[124];
        *(_DWORD *)(i + 52) += level[123] - level[124];
        BG_EvaluateTrajectory(i + 12, level[123], i + 316);
        BG_EvaluateTrajectory(i + 48, level[123], i + 328);
        trap_LinkEntity(i);
      }
      result = a1;
      if ( *(_DWORD *)(a1 + 536) )
        result = (*(int (__cdecl **)(int, int))(a1 + 536))(a1, v6);
      return result;
    }
  }
  result = a1;
  for ( i = a1; i; i = result )
  {
    if ( *(_DWORD *)(i + 12) && level[123] >= *(_DWORD *)(i + 16) + *(_DWORD *)(i + 20) && *(_DWORD *)(i + 532) )
      (*(void (__cdecl **)(int))(i + 532))(i);
    if ( *(_DWORD *)(i + 48) && level[123] >= *(_DWORD *)(i + 52) + *(_DWORD *)(i + 56) && *(_DWORD *)(i + 532) )
      (*(void (__cdecl **)(int))(i + 532))(i);
    result = *(_DWORD *)(i + 624);
  }
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// D1C40: using guessed type int dword_D1C40;

//----- (000616C5) --------------------------------------------------------
int __cdecl G_RunMover(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 756) )
  {
    G_GeneralLink(a1);
    return G_RunThink(a1);
  }
  if ( (*(_DWORD *)(a1 + 396) & 4) == 0 )
  {
    if ( *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 48) )
      G_MoverTeam(a1);
    return G_RunThink(a1);
  }
  if ( *(_DWORD *)(a1 + 244) && *(_WORD *)(a1 + 388) == scr_const[29]
    || (result = a1, *(_DWORD *)(a1 + 244))
    && (result = *(unsigned __int16 *)(a1 + 388), (_WORD)result == scr_const[28]) )
  {
    result = trap_UnlinkEntity(a1);
  }
  return result;
}
// 17EB4: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 184F4: using guessed type _DWORD __cdecl G_MoverTeam(_DWORD);
// 186A4: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);

//----- (00061791) --------------------------------------------------------
int __cdecl SetMoverState(int a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+28h] [ebp-20h]
  float v6; // [esp+2Ch] [ebp-1Ch]
  float v7; // [esp+2Ch] [ebp-1Ch]
  float v8; // [esp+2Ch] [ebp-1Ch]
  float v9; // [esp+2Ch] [ebp-1Ch]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+30h] [ebp-18h]
  float v14; // [esp+30h] [ebp-18h]
  float v15; // [esp+30h] [ebp-18h]
  float v16; // [esp+34h] [ebp-14h]
  float v17; // [esp+34h] [ebp-14h]
  float v18; // [esp+34h] [ebp-14h]
  float v19; // [esp+34h] [ebp-14h]
  float v20; // [esp+38h] [ebp-10h]
  float v21; // [esp+38h] [ebp-10h]
  float v22; // [esp+38h] [ebp-10h]
  float v23; // [esp+38h] [ebp-10h]

  v5 = *(_DWORD *)(a1 + 396) & 0x100;
  *(_BYTE *)(a1 + 384) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 52) = a3;
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 436);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 444);
      *(_DWORD *)(a1 + 12) = 0;
      *(_BYTE *)(a1 + 382) = 0;
      break;
    case 1:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 448);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 456);
      *(_DWORD *)(a1 + 12) = 0;
      break;
    case 2:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 464);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 468);
      *(_DWORD *)(a1 + 12) = 0;
      break;
    case 3:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 436);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 444);
      v14 = *(float *)(a1 + 448) - *(float *)(a1 + 436);
      v18 = *(float *)(a1 + 452) - *(float *)(a1 + 440);
      v22 = *(float *)(a1 + 456) - *(float *)(a1 + 444);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 516);
      v8 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v14 * v8;
      *(float *)(a1 + 40) = v18 * v8;
      *(float *)(a1 + 44) = v22 * v8;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 4:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 448);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 456);
      v15 = *(float *)(a1 + 436) - *(float *)(a1 + 448);
      v19 = *(float *)(a1 + 440) - *(float *)(a1 + 452);
      v23 = *(float *)(a1 + 444) - *(float *)(a1 + 456);
      if ( *(float *)(a1 + 500) == 0.0 )
      {
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 516);
        v9 = 1000.0 / (long double)*(int *)(a1 + 20);
      }
      else
      {
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 520);
        v9 = 1000.0 / (long double)*(int *)(a1 + 520);
      }
      *(float *)(a1 + 36) = v15 * v9;
      *(float *)(a1 + 40) = v19 * v9;
      *(float *)(a1 + 44) = v23 * v9;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 5:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 448);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 456);
      v12 = *(float *)(a1 + 460) - *(float *)(a1 + 448);
      v16 = *(float *)(a1 + 464) - *(float *)(a1 + 452);
      v20 = *(float *)(a1 + 468) - *(float *)(a1 + 456);
      v6 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v12 * v6;
      *(float *)(a1 + 40) = v16 * v6;
      *(float *)(a1 + 44) = v20 * v6;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 6:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 464);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 468);
      v13 = *(float *)(a1 + 448) - *(float *)(a1 + 460);
      v17 = *(float *)(a1 + 452) - *(float *)(a1 + 464);
      v21 = *(float *)(a1 + 456) - *(float *)(a1 + 468);
      v7 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v13 * v7;
      *(float *)(a1 + 40) = v17 * v7;
      *(float *)(a1 + 44) = v21 * v7;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 7:
    case 8:
      *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 328);
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 332);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 336);
      *(_DWORD *)(a1 + 48) = 0;
      break;
    case 9:
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 60) = 0;
      if ( v5 )
      {
        v10 = 500.0 / (long double)*(int *)(a1 + 516);
        v3 = 2 * *(_DWORD *)(a1 + 516);
      }
      else
      {
        v10 = 1000.0 / (long double)*(int *)(a1 + 516);
        v3 = *(_DWORD *)(a1 + 516);
      }
      *(_DWORD *)(a1 + 56) = v3;
      *(float *)(a1 + 72) = v10 * *(float *)(a1 + 480) * *(float *)(a1 + 656);
      *(float *)(a1 + 76) = v10 * *(float *)(a1 + 480) * *(float *)(a1 + 660);
      *(float *)(a1 + 80) = v10 * *(float *)(a1 + 480) * *(float *)(a1 + 664);
      *(_DWORD *)(a1 + 48) = 3;
      break;
    case 10:
      *(float *)(a1 + 60) = *(float *)(a1 + 656) * *(float *)(a1 + 480);
      *(float *)(a1 + 64) = *(float *)(a1 + 660) * *(float *)(a1 + 480);
      *(float *)(a1 + 68) = *(float *)(a1 + 664) * *(float *)(a1 + 480);
      v11 = 1000.0 / (long double)*(int *)(a1 + 516);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(a1 + 516);
      if ( v5 )
      {
        *(_DWORD *)(a1 + 56) *= 2;
        v11 = v11 * 0.5;
      }
      *(float *)(a1 + 72) = -v11 * *(float *)(a1 + 60);
      *(float *)(a1 + 76) = -v11 * *(float *)(a1 + 64);
      *(float *)(a1 + 80) = -v11 * *(float *)(a1 + 68);
      *(_DWORD *)(a1 + 48) = 3;
      *(_BYTE *)(a1 + 382) = 0;
      break;
    default:
      break;
  }
  BG_EvaluateTrajectory(a1 + 12, level[123], a1 + 316);
  if ( (*(_DWORD *)(a1 + 248) & 1) == 0 || (result = a1, *(_DWORD *)(a1 + 288)) )
    result = trap_LinkEntity(a1);
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00061E5F) --------------------------------------------------------
int __cdecl MatchTeam(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = a1;
  for ( i = a1; i; i = result )
  {
    if ( (*(_DWORD *)(a1 + 396) & 0x100) != 0 )
      *(_DWORD *)(i + 396) |= 0x100u;
    SetMoverState(i, a2, a3);
    result = *(_DWORD *)(i + 624);
  }
  return result;
}
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00061ED6) --------------------------------------------------------
int __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = a1;
  for ( i = a1; i; i = result )
  {
    *(float *)(i + 480) = *(float *)(i + 480) * -1.0;
    if ( (*(_DWORD *)(a1 + 396) & 0x100) != 0 )
      *(_DWORD *)(i + 396) |= 0x100u;
    SetMoverState(i, a2, a3);
    result = *(_DWORD *)(i + 624);
  }
  return result;
}
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00061F67) --------------------------------------------------------
int __cdecl ReturnToPos1(int a1)
{
  int result; // eax

  MatchTeam(a1, 4, level[123]);
  G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 368));
  *(_DWORD *)(a1 + 132) = 0;
  result = *(unsigned __int8 *)(a1 + 372);
  *(_DWORD *)(a1 + 132) = result;
  return result;
}
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (00061FDB) --------------------------------------------------------
int __cdecl ReturnToPos2(int a1)
{
  MatchTeam(a1, 6, level[123]);
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 370);
  return G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 372));
}
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (0006204F) --------------------------------------------------------
int __cdecl GotoPos3(int a1)
{
  MatchTeam(a1, 5, level[123]);
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 370);
  return G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 371));
}
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (000620C3) --------------------------------------------------------
int __cdecl ReturnToPos1Rotate(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = 0;
  MatchTeam(a1, 10, level[123]);
  v2 = G_Find(0, 388, scr_const[50]);
  if ( v2 )
    v3 = trap_InPVS(v2 + 316, a1 + 316);
  if ( v3 )
  {
    if ( (*(_DWORD *)(a1 + 396) & 0x100) != 0 )
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 376));
    else
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 368));
  }
  result = a1;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 372);
  return result;
}
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 18534: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 18F24: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (000621AE) --------------------------------------------------------
void __cdecl Reached_BinaryMover(int a1)
{
  char v1; // [esp+4h] [ebp-24h]
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  v4 = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( (*(_DWORD *)(a1 + 396) & 0x100) != 0 )
    v4 = 1;
  switch ( *(_BYTE *)(a1 + 384) )
  {
    case 3:
      SetMoverState(a1, 1, level[123]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 375));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 369));
      if ( !*(_DWORD *)(a1 + 620) )
        *(_DWORD *)(a1 + 620) = a1;
      if ( *(char *)(a1 + 396) >= 0 )
      {
        if ( *(float *)(a1 + 632) != -1000.0 )
        {
          *(_DWORD *)(a1 + 528) = ReturnToPos1;
          *(_DWORD *)(a1 + 524) = level[123] + (int)*(float *)(a1 + 632);
        }
      }
      else
      {
        *(_BYTE *)(a1 + 382) = 0;
        *(_DWORD *)(a1 + 528) = ReturnToPos1;
        *(_DWORD *)(a1 + 524) = 0;
      }
      return;
    case 4:
      SetMoverState(a1, 0, level[123]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 377));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 366));
      if ( *(_DWORD *)(a1 + 628) == a1 || !*(_DWORD *)(a1 + 628) )
        goto LABEL_19;
      break;
    case 9:
      SetMoverState(a1, 8, level[123]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 375));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 369));
      if ( !*(_DWORD *)(a1 + 620) )
        *(_DWORD *)(a1 + 620) = a1;
      if ( *(char *)(a1 + 396) >= 0 )
      {
        if ( *(float *)(a1 + 632) != -1000.0 )
        {
          *(_DWORD *)(a1 + 528) = ReturnToPos1Rotate;
          *(_DWORD *)(a1 + 524) = level[123] + (int)*(float *)(a1 + 632);
        }
      }
      else
      {
        *(_BYTE *)(a1 + 382) = 0;
        *(_DWORD *)(a1 + 528) = ReturnToPos1Rotate;
        *(_DWORD *)(a1 + 524) = 0;
      }
      break;
    case 0xA:
      SetMoverState(a1, 7, level[123]);
      v3 = 0;
      v2 = G_Find(0, 388, scr_const[50]);
      if ( v2 )
        v3 = trap_InPVS(v2 + 316, a1 + 316);
      if ( v3 )
      {
        if ( v4 )
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 377));
        else
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 366));
      }
      *(_DWORD *)(a1 + 396) &= 0xFFFFFEFF;
      if ( *(_DWORD *)(a1 + 628) == a1 || !*(_DWORD *)(a1 + 628) )
      {
LABEL_19:
        trap_AdjustAreaPortalState(a1, 0);
        return;
      }
      break;
    default:
      G_Error("Reached_BinaryMover: bad moverState", v1);
      return;
  }
}
// 625FD: variable 'v1' is possibly undefined
// 170D4: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 18534: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 18F24: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (00062608) --------------------------------------------------------
_BOOL4 __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3)
{
  float v5[7]; // [esp+20h] [ebp-68h] BYREF
  float v6; // [esp+3Ch] [ebp-4Ch]
  float v7; // [esp+40h] [ebp-48h] BYREF
  float v8; // [esp+44h] [ebp-44h]
  float v9; // [esp+48h] [ebp-40h]
  float v10; // [esp+50h] [ebp-38h]
  float v11; // [esp+54h] [ebp-34h]
  float v12; // [esp+58h] [ebp-30h]
  float v13; // [esp+60h] [ebp-28h] BYREF
  float v14; // [esp+64h] [ebp-24h]
  float v15; // [esp+68h] [ebp-20h]
  float v16[6]; // [esp+70h] [ebp-18h] BYREF

  if ( *(_WORD *)(a1 + 388) != scr_const[27] )
    return 0;
  if ( (*(_DWORD *)(a1 + 392) & 0x20) != 0 )
    return 0;
  v10 = *(float *)(a1 + 292) + *(float *)(a1 + 304);
  v11 = *(float *)(a1 + 296) + *(float *)(a1 + 308);
  v12 = *(float *)(a1 + 300) + *(float *)(a1 + 312);
  v10 = v10 * 0.5;
  v11 = v11 * 0.5;
  v12 = v12 * 0.5;
  v16[0] = v10 - *(float *)(a1 + 316);
  v16[1] = v11 - *(float *)(a1 + 320);
  v16[2] = v12 - *(float *)(a1 + 324);
  vectoangles(v16, &v13);
  if ( *(float *)(a1 + 660) == 0.0 )
  {
    if ( *(float *)(a1 + 656) == 0.0 )
    {
      if ( *(float *)(a1 + 664) != 0.0 )
        v15 = v15 + *(float *)(a1 + 480);
    }
    else
    {
      v13 = v13 + *(float *)(a1 + 480);
    }
  }
  else
  {
    v14 = v14 + *(float *)(a1 + 480);
  }
  AngleVectors(&v13, v5, 0, 0);
  v7 = a3[79] - v10;
  v8 = a3[80] - v11;
  v9 = a3[81] - v12;
  VectorNormalize(&v7);
  v6 = v7 * v5[0] + v8 * v5[1] + v9 * v5[2];
  return v6 >= 0.0;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0006282E) --------------------------------------------------------
void __cdecl Use_BinaryMover(int a1, int a2, int a3)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  v5 = 0;
  v4 = 0;
  v3 = 0;
  if ( (*(_DWORD *)(a1 + 396) & 0x100) != 0 )
    v5 = 1;
  if ( (int)level[123] <= 4000 )
    v3 = 1;
  if ( (*(_DWORD *)(a1 + 396) & 4) != 0 )
  {
    if ( v5 )
      *(_DWORD *)(*(_DWORD *)(a1 + 628) + 396) |= 0x100u;
    Use_BinaryMover(*(_DWORD *)(a1 + 628), a2, a3);
    return;
  }
  if ( !*(_BYTE *)(a1 + 384) || *(_BYTE *)(a1 + 384) == 7 )
    v4 = IsBinaryMoverBlocked(a1, a2, a3);
  if ( !v4 )
  {
    *(_DWORD *)(a1 + 620) = a3;
    if ( *(_DWORD *)(a1 + 428)
      && *(float *)(*(_DWORD *)(a1 + 428) + 632) == -1.0
      && *(_DWORD *)(*(_DWORD *)(a1 + 428) + 608) == 1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 428) + 608) = 0;
      return;
    }
    switch ( *(_BYTE *)(a1 + 384) )
    {
      case 0:
        MatchTeam(a1, 3, level[123] + 50);
        if ( !v3 )
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
        *(_DWORD *)(a1 + 132) = 0;
        if ( !v3 )
          *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 371);
        if ( *(_DWORD *)(a1 + 628) == a1 || !*(_DWORD *)(a1 + 628) )
          goto LABEL_43;
        return;
      case 7:
        MatchTeam(a1, 9, level[123] + 50);
        if ( !v3 )
        {
          if ( v5 )
            G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 374));
          else
            G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
        }
        *(_DWORD *)(a1 + 132) = 0;
        if ( !v3 )
          *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 371);
        if ( *(_DWORD *)(a1 + 628) == a1 || !*(_DWORD *)(a1 + 628) )
          goto LABEL_43;
        return;
      case 1:
        if ( *(char *)(a1 + 396) >= 0 )
        {
          if ( *(float *)(a1 + 632) != -1000.0 )
            *(_DWORD *)(a1 + 524) = level[123] + (int)*(float *)(a1 + 632);
        }
        else
        {
          *(_DWORD *)(a1 + 524) = level[123] + 50;
        }
        return;
      case 8:
        if ( *(char *)(a1 + 396) >= 0 )
          *(_DWORD *)(a1 + 524) = level[123] + (int)*(float *)(a1 + 632);
        else
          *(_DWORD *)(a1 + 524) = level[123] + 50;
        return;
      case 4:
        Blocked_Door(a1, 0);
        if ( v3 )
          return;
        goto LABEL_55;
      case 3:
        Blocked_Door(a1, 0);
        if ( v3 )
          return;
        break;
      case 0xA:
        Blocked_DoorRotate(a1, 0);
        if ( v3 )
          return;
LABEL_55:
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
        return;
      case 9:
        Blocked_DoorRotate(a1, 0);
        if ( v3 )
          return;
        if ( v5 )
        {
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 376));
          return;
        }
        break;
      default:
        return;
    }
    G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 368));
    return;
  }
  MatchTeamReverseAngleOnSlaves(a1, 9, level[123] + 50);
  if ( !v3 )
  {
    if ( v5 )
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 374));
    else
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
  }
  *(_DWORD *)(a1 + 132) = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 371);
  if ( *(_DWORD *)(a1 + 628) == a1 || !*(_DWORD *)(a1 + 628) )
LABEL_43:
    trap_AdjustAreaPortalState(a1, 1);
}
// 629B6: conditional instruction was optimized away because of '%var_10.4==1'
// 170D4: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 17754: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 17AB4: using guessed type _DWORD __cdecl MatchTeamReverseAngleOnSlaves(_DWORD, _DWORD, _DWORD);
// 18334: using guessed type _DWORD __cdecl IsBinaryMoverBlocked(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (00062E2E) --------------------------------------------------------
void __cdecl InitMover(int a1)
{
  int v1; // eax
  int v2; // [esp+24h] [ebp-54h]
  int v3; // [esp+28h] [ebp-50h]
  int v4; // [esp+2Ch] [ebp-4Ch]
  int v5; // [esp+30h] [ebp-48h]
  char *s2; // [esp+34h] [ebp-44h] BYREF
  int v7; // [esp+38h] [ebp-40h]
  int v8; // [esp+3Ch] [ebp-3Ch]
  int v9[6]; // [esp+40h] [ebp-38h] BYREF
  int v10; // [esp+58h] [ebp-20h] BYREF
  float v11; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]

  if ( G_SpawnString("noise", (int)&off_A1978, (int)&s2) )
    *(_DWORD *)(a1 + 132) = (unsigned __int8)G_SoundAliasIndex(s2);
  v8 = G_SpawnFloat("light", (int)&off_A1978, (int)&v10);
  v7 = G_SpawnVector("color", (int)"1 1 1", (int)v9);
  if ( v8 || v7 )
  {
    v5 = (int)(*(float *)v9 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v9[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v9[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(*(float *)&v10 / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    *(_DWORD *)(a1 + 128) = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  if ( *(_WORD *)(a1 + 388) == scr_const[28] )
  {
    *(_DWORD *)(a1 + 544) = Use_Func_Rotate;
    *(_DWORD *)(a1 + 532) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 544) = Use_BinaryMover;
    *(_DWORD *)(a1 + 532) = Reached_BinaryMover;
  }
  *(_BYTE *)(a1 + 384) = 0;
  *(_DWORD *)(a1 + 248) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 436);
  *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 440);
  *(_DWORD *)(a1 + 324) = *(_DWORD *)(a1 + 444);
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 436);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 440);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 444);
  v12 = *(float *)(a1 + 448) - *(float *)(a1 + 436);
  v13 = *(float *)(a1 + 452) - *(float *)(a1 + 440);
  v14 = *(float *)(a1 + 456) - *(float *)(a1 + 444);
  v11 = sqrt(v12 * v12 + v13 * v13 + v14 * v14);
  if ( *(float *)(a1 + 496) == 0.0 )
    *(_DWORD *)(a1 + 496) = 1120403456;
  *(_DWORD *)(a1 + 20) = (int)(v11 * 1000.0 / *(float *)(a1 + 496));
  if ( *(int *)(a1 + 20) <= 0 )
    *(_DWORD *)(a1 + 20) = 1;
  v1 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 516) = v1;
  *(_DWORD *)(a1 + 520) = v1;
  if ( *(float *)(a1 + 500) != 0.0 )
  {
    *(_DWORD *)(a1 + 520) = (int)(v11 * 1000.0 / *(float *)(a1 + 500));
    if ( *(int *)(a1 + 520) <= 0 )
      *(_DWORD *)(a1 + 520) = 1;
  }
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 646A0: using guessed type int __cdecl Use_Func_Rotate(int);
// A1978: using guessed type void *off_A1978;

//----- (000631C0) --------------------------------------------------------
int __cdecl InitMoverRotate(int a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8[7]; // [esp+30h] [ebp-28h] BYREF
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v7 = G_SpawnFloat("light", (int)&off_A1978, (int)v9);
  v6 = G_SpawnVector("color", (int)"1 1 1", (int)v8);
  if ( v7 || v6 )
  {
    v5 = (int)(*(float *)v8 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v8[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v8[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(v9[0] / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    *(_DWORD *)(a1 + 128) = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  *(_DWORD *)(a1 + 544) = Use_BinaryMover;
  if ( (*(_DWORD *)(a1 + 392) & 0x40) == 0 )
    *(_DWORD *)(a1 + 532) = Reached_BinaryMover;
  *(_BYTE *)(a1 + 384) = 7;
  *(_DWORD *)(a1 + 248) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  if ( *(float *)(a1 + 496) == 0.0 )
    *(_DWORD *)(a1 + 496) = 1120403456;
  *(_DWORD *)(a1 + 56) = (int)*(float *)(a1 + 496);
  if ( *(int *)(a1 + 56) <= 0 )
    *(_DWORD *)(a1 + 56) = 1;
  result = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 520) = result;
  *(_DWORD *)(a1 + 516) = result;
  return result;
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// A1978: using guessed type void *off_A1978;

//----- (000633F9) --------------------------------------------------------
int __cdecl Blocked_Door(int a1, void *s)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]

  if ( s )
  {
    if ( !*((_DWORD *)s + 88) )
    {
      G_TempEntity((char *)s + 316, 205);
      return G_FreeEntity(s);
    }
    if ( *(_DWORD *)(a1 + 584) )
      G_Damage(s, a1, a1, 0, 0, *(_DWORD *)(a1 + 584), 0, 16, 0);
  }
  result = *(_DWORD *)(a1 + 392) & 4;
  if ( !result )
  {
    result = a1;
    for ( i = a1; i; i = result )
    {
      v3 = level[123] - (*(_DWORD *)(i + 20) - (level[123] - *(_DWORD *)(i + 16)));
      if ( *(_BYTE *)(i + 384) == 3 )
        SetMoverState(i, 4, v3);
      else
        SetMoverState(i, 3, v3);
      trap_LinkEntity(i);
      result = *(_DWORD *)(i + 624);
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00063562) --------------------------------------------------------
int __cdecl Blocked_DoorRotate(int a1, void *s)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]

  if ( s )
  {
    if ( !*((_DWORD *)s + 88) )
    {
      G_TempEntity((char *)s + 316, 205);
      return G_FreeEntity(s);
    }
    if ( *((int *)s + 144) <= 0 )
      G_Damage(s, a1, a1, 0, 0, sub_1869F, 0, 16, 0);
    if ( *(_DWORD *)(a1 + 584) )
      G_Damage(s, a1, a1, 0, 0, *(_DWORD *)(a1 + 584), 0, 16, 0);
  }
  result = a1;
  for ( i = a1; i; i = result )
  {
    v3 = level[123] - (*(_DWORD *)(i + 56) - (level[123] - *(_DWORD *)(i + 52)));
    if ( *(_BYTE *)(i + 384) == 9 )
      SetMoverState(i, 10, v3);
    else
      SetMoverState(i, 9, v3);
    trap_LinkEntity(i);
    result = *(_DWORD *)(i + 624);
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 1869F: using guessed type int sub_1869F();
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006370B) --------------------------------------------------------
int __cdecl Touch_DoorTrigger(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 424);
  if ( !*(_DWORD *)(result + 696) )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(a1 + 424) + 384)
      || *(_BYTE *)(*(_DWORD *)(a1 + 424) + 384) == 7
      || (result = *(_DWORD *)(a1 + 424), *(_BYTE *)(result + 384) == 10) )
    {
      result = Use_BinaryMover(*(_DWORD *)(a1 + 424), a1, a2);
    }
  }
  return result;
}
// 17754: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);

//----- (0006378C) --------------------------------------------------------
int __cdecl sub_6378C(int a1)
{
  int v2; // [esp+18h] [ebp-40h]
  int j; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h] BYREF
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+30h] [ebp-28h] BYREF
  int v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+38h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-Ch]

  for ( i = a1; i; i = *(_DWORD *)(i + 624) )
    *(_BYTE *)(i + 381) = 1;
  v7 = *(_DWORD *)(a1 + 292);
  v8 = *(_DWORD *)(a1 + 296);
  v9 = *(_DWORD *)(a1 + 300);
  v4 = *(_DWORD *)(a1 + 304);
  v5 = *(_DWORD *)(a1 + 308);
  v6 = *(_DWORD *)(a1 + 312);
  for ( i = *(_DWORD *)(a1 + 624); i; i = *(_DWORD *)(i + 624) )
  {
    AddPointToBounds(i + 292, &v7, &v4);
    AddPointToBounds(i + 304, &v7, &v4);
  }
  v2 = 0;
  for ( j = 1; j <= 2; ++j )
  {
    if ( *((float *)&v4 + v2) - *((float *)&v7 + v2) > *((float *)&v4 + j) - *((float *)&v7 + j) )
      v2 = j;
  }
  *((float *)&v4 + v2) = *((float *)&v4 + v2) + 120.0;
  *((float *)&v7 + v2) = *((float *)&v7 + v2) - 120.0;
  i = G_Spawn();
  *(_DWORD *)(i + 264) = v7;
  *(_DWORD *)(i + 268) = v8;
  *(_DWORD *)(i + 272) = v9;
  *(_DWORD *)(i + 276) = v4;
  *(_DWORD *)(i + 280) = v5;
  *(_DWORD *)(i + 284) = v6;
  *(_DWORD *)(i + 424) = a1;
  *(_DWORD *)(i + 288) = 0x40000000;
  *(_DWORD *)(i + 540) = Touch_DoorTrigger;
  trap_LinkEntity(i);
  MatchTeam(a1, *(unsigned __int8 *)(a1 + 384), level[123]);
  return i;
}
// 167A4: using guessed type int G_Spawn(void);
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18924: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);

//----- (00063993) --------------------------------------------------------
int __cdecl Think_SpawnNewDoorTrigger(int a1)
{
  return sub_6378C(a1);
}

//----- (000639A6) --------------------------------------------------------
int __cdecl sub_639A6(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 528) = ReturnToPos1Rotate;
  *(float *)(a1 + 332) = *(float *)(a1 + 332) + *(float *)(a1 + 480);
  SetMoverState(a1, 8, level[123]);
  if ( *(_DWORD *)(a1 + 628) == a1 || (result = a1, !*(_DWORD *)(a1 + 628)) )
    result = trap_AdjustAreaPortalState(a1, 1);
  return result;
}
// 170D4: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 18C84: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00063A38) --------------------------------------------------------
int __cdecl Think_SpawnNewAutoDoorTrigger(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 392) & 1;
  if ( result )
    result = sub_639A6(a1);
  return result;
}

//----- (00063A5B) --------------------------------------------------------
int __cdecl Think_MatchTeam(int a1)
{
  return MatchTeam(a1, *(unsigned __int8 *)(a1 + 384), level[123]);
}
// 17834: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);

//----- (00063A9C) --------------------------------------------------------
int __cdecl finishSpawningKeyedMover(int a1)
{
  int result; // eax
  int (__cdecl *v2)(int); // eax
  int i; // [esp+0h] [ebp-8h]

  *(_DWORD *)(a1 + 524) = level[123] + 100;
  result = *(_DWORD *)(a1 + 396) & 4;
  if ( !result )
  {
    if ( *(_BYTE *)(a1 + 381) )
    {
      *(_DWORD *)(a1 + 528) = Think_MatchTeam;
    }
    else if ( *(_WORD *)(a1 + 388) == scr_const[27] )
    {
      *(_DWORD *)(a1 + 528) = Think_SpawnNewAutoDoorTrigger;
    }
    else
    {
      if ( (*(_DWORD *)(a1 + 392) & 8) != 0 )
        v2 = Think_SpawnNewDoorTrigger;
      else
        v2 = Think_MatchTeam;
      *(_DWORD *)(a1 + 528) = v2;
    }
    result = a1;
    for ( i = a1; i; i = result )
    {
      if ( i != a1 )
        *(_DWORD *)(i + 696) = *(_DWORD *)(a1 + 696);
      result = *(_DWORD *)(i + 624);
    }
  }
  return result;
}

//----- (00063B8C) --------------------------------------------------------
int __cdecl Door_reverse_sounds(_BYTE *a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-4h]
  char v3; // [esp+0h] [ebp-4h]
  char v4; // [esp+0h] [ebp-4h]
  char v5; // [esp+0h] [ebp-4h]
  unsigned __int8 v6; // [esp+0h] [ebp-4h]

  v2 = a1[367];
  a1[367] = a1[368];
  a1[368] = v2;
  v3 = a1[366];
  a1[366] = a1[369];
  a1[369] = v3;
  v4 = a1[371];
  a1[371] = a1[372];
  a1[372] = v4;
  v5 = a1[374];
  a1[374] = a1[376];
  a1[376] = v5;
  v6 = a1[375];
  a1[375] = a1[377];
  result = v6;
  a1[377] = v6;
  return result;
}

//----- (00063C75) --------------------------------------------------------
int __cdecl DoorSetSounds(_BYTE *a1)
{
  int result; // eax

  a1[367] = G_SoundAliasIndex("door_opening");
  a1[369] = G_SoundAliasIndex("door_open_end");
  a1[368] = G_SoundAliasIndex("door_closing");
  a1[366] = G_SoundAliasIndex("door_close_end");
  a1[371] = G_SoundAliasIndex("door_open_loop");
  a1[372] = G_SoundAliasIndex("door_close_loop");
  a1[373] = G_SoundAliasIndex("door_locked");
  a1[374] = G_SoundAliasIndex("door_opening_quiet");
  a1[375] = G_SoundAliasIndex("door_open_quiet_end");
  a1[376] = G_SoundAliasIndex("door_closing_quiet");
  result = G_SoundAliasIndex("door_close_quiet_end");
  a1[377] = result;
  return result;
}

//----- (00063D8C) --------------------------------------------------------
int __cdecl G_TryDoor(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 396) & 0x100;
  result = a1;
  if ( !*(_DWORD *)(a1 + 48) )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 12) )
    {
      result = a1;
      if ( !*(_BYTE *)(a1 + 382) )
      {
        if ( *(_DWORD *)(a1 + 696) )
        {
          result = G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 373));
        }
        else
        {
          Scr_AddEntity(a3);
          Scr_Notify(a1, scr_const[88], 1);
          if ( *(_DWORD *)(a1 + 628) && *(_WORD *)(a1 + 488) && a1 != *(_DWORD *)(a1 + 628) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 628) + 382) = 1;
            if ( v4 )
              *(_DWORD *)(*(_DWORD *)(a1 + 628) + 396) |= 0x100u;
            result = Use_BinaryMover(*(_DWORD *)(a1 + 628), a3, a3);
          }
          else
          {
            *(_BYTE *)(a1 + 382) = 1;
            if ( v4 )
              *(_DWORD *)(a1 + 396) |= 0x100u;
            result = Use_BinaryMover(a1, a3, a3);
          }
        }
      }
    }
  }
  return result;
}
// 17754: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00063F01) --------------------------------------------------------
int (__cdecl *__cdecl SP_func_door(int a1))(int a1)
{
  int (__cdecl *result)(int); // eax
  int v2; // [esp+18h] [ebp-60h] BYREF
  int v3; // [esp+1Ch] [ebp-5Ch]
  int v4; // [esp+20h] [ebp-58h]
  int v5; // [esp+24h] [ebp-54h]
  int v6; // [esp+28h] [ebp-50h]
  int v7; // [esp+38h] [ebp-40h] BYREF
  int v8; // [esp+3Ch] [ebp-3Ch] BYREF
  float v9; // [esp+40h] [ebp-38h]
  float v10; // [esp+44h] [ebp-34h]
  float v11; // [esp+48h] [ebp-30h]
  float v12; // [esp+5Ch] [ebp-1Ch]
  float v13; // [esp+60h] [ebp-18h]
  float v14; // [esp+64h] [ebp-14h]
  float v15; // [esp+68h] [ebp-10h]

  DoorSetSounds(a1);
  *(_DWORD *)(a1 + 536) = Blocked_Door;
  if ( *(float *)(a1 + 496) == 0.0 )
    *(_DWORD *)(a1 + 496) = 1137180672;
  if ( *(float *)(a1 + 632) == 0.0 )
    *(_DWORD *)(a1 + 632) = 0x40000000;
  *(float *)(a1 + 632) = *(float *)(a1 + 632) * 1000.0;
  if ( G_SpawnInt("key", (int)&unk_A1840, (int)&v7) )
    *(_DWORD *)(a1 + 696) = 1;
  else
    *(_DWORD *)(a1 + 696) = 0;
  G_SpawnFloat("lip", (int)"8", (int)&v8);
  G_SpawnInt("dmg", (int)"2", a1 + 584);
  *(_DWORD *)(a1 + 436) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 440) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 444) = *(_DWORD *)(a1 + 324);
  trap_SetBrushModel(a1);
  G_SetMovedir(a1 + 328, a1 + 504);
  v13 = fabs(*(float *)(a1 + 504));
  v14 = fabs(*(float *)(a1 + 508));
  v15 = fabs(*(float *)(a1 + 512));
  v9 = *(float *)(a1 + 276) - *(float *)(a1 + 264);
  v10 = *(float *)(a1 + 280) - *(float *)(a1 + 268);
  v11 = *(float *)(a1 + 284) - *(float *)(a1 + 272);
  v12 = v13 * v9 + v14 * v10 + v15 * v11 - *(float *)&v8;
  *(float *)(a1 + 448) = *(float *)(a1 + 504) * v12 + *(float *)(a1 + 436);
  *(float *)(a1 + 452) = *(float *)(a1 + 508) * v12 + *(float *)(a1 + 440);
  *(float *)(a1 + 456) = *(float *)(a1 + 512) * v12 + *(float *)(a1 + 444);
  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
  {
    v4 = *(_DWORD *)(a1 + 448);
    v5 = *(_DWORD *)(a1 + 452);
    v6 = *(_DWORD *)(a1 + 456);
    *(_DWORD *)(a1 + 448) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 452) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 456) = *(_DWORD *)(a1 + 324);
    *(_DWORD *)(a1 + 436) = v4;
    *(_DWORD *)(a1 + 440) = v5;
    *(_DWORD *)(a1 + 444) = v6;
    if ( *(float *)(a1 + 500) != 0.0 )
    {
      v3 = *(_DWORD *)(a1 + 496);
      *(_DWORD *)(a1 + 496) = *(_DWORD *)(a1 + 500);
      *(_DWORD *)(a1 + 500) = v3;
    }
    Door_reverse_sounds(a1);
  }
  if ( (*(_DWORD *)(a1 + 392) & 2) != 0 )
    *(_DWORD *)(a1 + 396) |= 0x80u;
  InitMover(a1);
  if ( (*(_DWORD *)(a1 + 396) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v2);
    if ( v2 )
      *(_BYTE *)(a1 + 381) = 1;
  }
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  result = finishSpawningKeyedMover;
  *(_DWORD *)(a1 + 528) = finishSpawningKeyedMover;
  return result;
}
// 17C24: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 18C24: using guessed type _DWORD __cdecl DoorSetSounds(_DWORD);
// 18D44: using guessed type _DWORD __cdecl G_SetMovedir(_DWORD, _DWORD);
// 19224: using guessed type _DWORD __cdecl Door_reverse_sounds(_DWORD);

//----- (000642E7) --------------------------------------------------------
int __cdecl Use_Static(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 244) )
    result = trap_UnlinkEntity(a1);
  else
    result = trap_LinkEntity(a1);
  return result;
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (00064323) --------------------------------------------------------
void __cdecl Static_Pain(int a1)
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+4h] [ebp-24h]
  float v3; // [esp+8h] [ebp-20h]
  float v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 392) & 4) != 0 )
  {
    v4 = (float)(int)level[123];
    v3 = *(float *)(a1 + 632) + *(float *)(a1 + 644);
    if ( v4 > (long double)(rand() % 1000) + v3 + 500.0 )
    {
      *(float *)(a1 + 632) = (float)(int)level[123];
      v5 = *(_DWORD *)(a1 + 316);
      v6 = *(_DWORD *)(a1 + 320);
      v7 = *(_DWORD *)(a1 + 324);
      *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 464);
      *(_DWORD *)(a1 + 324) = *(_DWORD *)(a1 + 468);
      *(_DWORD *)(a1 + 316) = v5;
      *(_DWORD *)(a1 + 320) = v6;
      *(_DWORD *)(a1 + 324) = v7;
    }
  }
  else
  {
    v2 = (float)(int)level[123];
    v1 = *(float *)(a1 + 632) + *(float *)(a1 + 644);
    if ( v2 > (long double)(rand() % 1000) + v1 + 500.0 )
      *(float *)(a1 + 632) = (float)(int)level[123];
  }
}

//----- (000644CE) --------------------------------------------------------
int __cdecl SP_func_leaky(_DWORD *a1)
{
  int result; // eax

  trap_SetBrushModel(a1);
  trap_LinkEntity(a1);
  a1[3] = 0;
  a1[6] = a1[79];
  a1[7] = a1[80];
  result = a1[81];
  a1[8] = result;
  return result;
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (00064533) --------------------------------------------------------
int __cdecl SP_func_static(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h] BYREF

  trap_SetBrushModel(a1);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 544) = Use_Static;
  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
    trap_UnlinkEntity(a1);
  if ( (*(_DWORD *)(a1 + 396) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v2);
    if ( v2 )
      *(_BYTE *)(a1 + 381) = 1;
  }
  if ( (*(_DWORD *)(a1 + 392) & 2) != 0 || (result = *(_DWORD *)(a1 + 392) & 4) != 0 )
  {
    *(_DWORD *)(a1 + 548) = Static_Pain;
    if ( *(float *)(a1 + 644) == 0.0 )
      *(_DWORD *)(a1 + 644) = 1148846080;
    else
      *(float *)(a1 + 644) = *(float *)(a1 + 644) * 1000.0;
    *(_BYTE *)(a1 + 381) = 1;
    *(_DWORD *)(a1 + 576) = 9999;
    result = a1;
    if ( !*(_DWORD *)(a1 + 608) )
    {
      result = a1;
      *(_DWORD *)(a1 + 608) = 4;
    }
  }
  return result;
}
// 17C24: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (000646A0) --------------------------------------------------------
int __cdecl Use_Func_Rotate(_DWORD *a1)
{
  if ( (a1[98] & 4) != 0 )
  {
    a1[20] = a1[124];
  }
  else if ( (a1[98] & 8) != 0 )
  {
    a1[18] = a1[124];
  }
  else
  {
    a1[19] = a1[124];
  }
  if ( (a1[98] & 2) != 0 )
    a1[99] &= 0xFFFFFFFB;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00064739) --------------------------------------------------------
int __cdecl SP_func_rotating(float *a1)
{
  if ( a1[124] == 0.0 )
    a1[124] = 100.0;
  *((_DWORD *)a1 + 12) = 2;
  if ( ((_DWORD)a1[98] & 1) != 0 )
  {
    if ( ((_DWORD)a1[98] & 4) != 0 )
    {
      a1[20] = a1[124];
    }
    else if ( ((_DWORD)a1[98] & 8) != 0 )
    {
      a1[18] = a1[124];
    }
    else
    {
      a1[19] = a1[124];
    }
  }
  if ( !*((_DWORD *)a1 + 146) )
    *((_DWORD *)a1 + 146) = 2;
  trap_SetBrushModel(a1);
  InitMover(a1);
  a1[6] = a1[79];
  a1[7] = a1[80];
  a1[8] = a1[81];
  if ( ((_DWORD)a1[98] & 2) == 0 )
    return trap_LinkEntity(a1);
  *((_DWORD *)a1 + 99) |= 4u;
  return trap_UnlinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17C24: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (0006487E) --------------------------------------------------------
int __cdecl SP_func_bobbing(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch] BYREF
  int v3; // [esp+20h] [ebp-8h] BYREF

  G_SpawnFloat("speed", (int)&unk_A1A98, a1 + 496);
  G_SpawnFloat("height", (int)"32", (int)&v3);
  G_SpawnInt("dmg", (int)"2", a1 + 584);
  G_SpawnFloat("phase", (int)"0", (int)&v2);
  trap_SetBrushModel(a1);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 20) = (int)(*(float *)(a1 + 496) * 1000.0);
  *(_DWORD *)(a1 + 16) = (int)((long double)*(int *)(a1 + 20) * *(float *)&v2);
  *(_DWORD *)(a1 + 12) = 4;
  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
  {
    result = v3;
    *(_DWORD *)(a1 + 36) = v3;
  }
  else
  {
    result = v3;
    if ( (*(_DWORD *)(a1 + 392) & 2) != 0 )
      *(_DWORD *)(a1 + 40) = v3;
    else
      *(_DWORD *)(a1 + 44) = v3;
  }
  return result;
}
// 17C24: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (000649E9) --------------------------------------------------------
int __cdecl SP_func_pendulum(int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+18h] [ebp-10h] BYREF
  float v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  G_SpawnFloat("speed", (int)&unk_A1AB4, (int)&v3);
  G_SpawnInt("dmg", (int)"2", a1 + 584);
  G_SpawnFloat("phase", (int)"0", (int)&v4);
  trap_SetBrushModel(a1);
  v5 = fabs(*(float *)(a1 + 272));
  if ( v5 < 8.0 )
    v5 = 8.0;
  v2 = sqrt(g_gravity[2] / (v5 * 3.0));
  v6 = v2 * 0.1591549430918953;
  *(_DWORD *)(a1 + 20) = (int)(1000.0 / v6);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 332);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 336);
  *(_DWORD *)(a1 + 56) = (int)(1000.0 / v6);
  *(_DWORD *)(a1 + 52) = (int)((long double)*(int *)(a1 + 56) * *(float *)&v4);
  *(_DWORD *)(a1 + 48) = 4;
  result = v3;
  *(_DWORD *)(a1 + 80) = v3;
  return result;
}
// 17C24: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (00064B99) --------------------------------------------------------
int (__cdecl *__cdecl SP_func_door_rotating(int a1))(int, void *s)
{
  int (__cdecl *result)(int, void *); // eax
  char v2; // [esp+4h] [ebp-24h]
  int v3; // [esp+14h] [ebp-14h] BYREF
  float v4; // [esp+18h] [ebp-10h]
  int v5[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
    *(_DWORD *)(a1 + 392) |= 2u;
  *(_DWORD *)(a1 + 392) &= 0xFFFFFFBF;
  DoorSetSounds(a1);
  if ( *(float *)(a1 + 496) == 0.0 )
    *(_DWORD *)(a1 + 496) = 1148846080;
  if ( *(float *)(a1 + 480) == 0.0 )
    *(_DWORD *)(a1 + 480) = 1119092736;
  if ( (*(_DWORD *)(a1 + 392) & 0x10) != 0 )
    *(float *)(a1 + 480) = *(float *)(a1 + 480) * -1.0;
  if ( (*(_DWORD *)(a1 + 392) & 2) != 0 )
    *(_DWORD *)(a1 + 396) |= 0x80u;
  if ( G_SpawnInt("key", (int)&unk_A1840, (int)v5) )
    *(_DWORD *)(a1 + 696) = 1;
  else
    *(_DWORD *)(a1 + 696) = 0;
  *(_DWORD *)(a1 + 664) = 0;
  *(_DWORD *)(a1 + 660) = 0;
  *(_DWORD *)(a1 + 656) = 0;
  if ( (*(_DWORD *)(a1 + 392) & 0xC) == 12 )
  {
    *(_DWORD *)(a1 + 660) = 1065353216;
  }
  else if ( (*(_DWORD *)(a1 + 392) & 4) != 0 )
  {
    *(_DWORD *)(a1 + 664) = 1065353216;
  }
  else if ( (*(_DWORD *)(a1 + 392) & 8) != 0 )
  {
    *(_DWORD *)(a1 + 656) = 1065353216;
  }
  else
  {
    *(_DWORD *)(a1 + 660) = 1065353216;
  }
  v4 = sqrt(
         *(float *)(a1 + 656) * *(float *)(a1 + 656)
       + *(float *)(a1 + 660) * *(float *)(a1 + 660)
       + *(float *)(a1 + 664) * *(float *)(a1 + 664));
  if ( v4 > 1.0 )
  {
    G_Error(
      "Too many axis marked in func_door_rotating entity.  Only choose one axis of rotation. (defaulting to standard door rotation)",
      v2);
    *(_DWORD *)(a1 + 664) = 0;
    *(_DWORD *)(a1 + 660) = 0;
    *(_DWORD *)(a1 + 656) = 0;
    *(_DWORD *)(a1 + 660) = 1065353216;
  }
  if ( *(float *)(a1 + 632) == 0.0 )
    *(_DWORD *)(a1 + 632) = 0x40000000;
  *(float *)(a1 + 632) = *(float *)(a1 + 632) * 1000.0;
  trap_SetBrushModel(a1);
  InitMoverRotate(a1);
  if ( (*(_DWORD *)(a1 + 396) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v3);
    if ( v3 )
      *(_BYTE *)(a1 + 381) = 1;
  }
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  *(_DWORD *)(a1 + 528) = finishSpawningKeyedMover;
  result = Blocked_DoorRotate;
  *(_DWORD *)(a1 + 536) = Blocked_DoorRotate;
  return result;
}
// 64DCA: variable 'v2' is possibly undefined
// 16E74: using guessed type _DWORD __cdecl InitMoverRotate(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 18C24: using guessed type _DWORD __cdecl DoorSetSounds(_DWORD);

//----- (00064ED2) --------------------------------------------------------
void __cdecl use_trigger_use(int a1, int a2)
{
  unsigned int v2; // edx

  if ( (long double)(int)level[123] > *(float *)(a1 + 632) )
  {
    *(float *)(a1 + 632) = (long double)(int)level[123] + *(float *)(a1 + 644);
    if ( !*(_DWORD *)(a2 + 352) )
    {
      if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
        v2 = *(_DWORD *)(a1 + 392) & 0xFFFFFFFE;
      else
        v2 = *(_DWORD *)(a1 + 392) | 1;
      *(_DWORD *)(a1 + 392) = v2;
    }
  }
}

//----- (00064F76) --------------------------------------------------------
int __cdecl trigger_use(int a1)
{
  int result; // eax
  char s2[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h] BYREF
  unsigned int i; // [esp+41Ch] [ebp-Ch] BYREF

  trap_SetBrushModel(a1);
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 288) = &unk_200000;
  *(_DWORD *)(a1 + 248) = 1;
  *(float *)(a1 + 644) = *(float *)(a1 + 644) * 1000.0;
  *(_DWORD *)(a1 + 544) = use_trigger_use;
  *(_DWORD *)(a1 + 224) = 2;
  if ( G_SpawnString("cursorhint", (int)&unk_A1840, (int)&s1) )
  {
    if ( Q_strcasecmp(s1, "HINT_INHERIT") )
    {
      for ( i = 1; i <= 0xB; ++i )
      {
        if ( !Q_strcasecmp(s1, *(&hintStrings + i)) )
        {
          *(_DWORD *)(a1 + 224) = i;
          break;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 224) = -1;
    }
  }
  *(_DWORD *)(a1 + 220) = 255;
  result = G_SpawnString("hintstring", (int)&unk_A1840, (int)&s1);
  if ( result )
  {
    for ( i = 0; (int)i <= 31; ++i )
    {
      trap_GetConfigstring(i + 1365, s2, 1024);
      if ( !s2[0] )
      {
        trap_SetConfigstring(i + 1365, s1);
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 220) = (unsigned __int8)i;
        break;
      }
      if ( !strcmp(s1, s2) )
      {
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 220) = (unsigned __int8)i;
        break;
      }
      result = (int)&i;
    }
    if ( i == 32 )
      result = Com_Error(1, byte_A1BA0, 32);
  }
  return result;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 19284: using guessed type _DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD);
// ADDA0: using guessed type void *hintStrings;

//----- (000651AC) --------------------------------------------------------
int __cdecl G_Activate(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 48) )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 12) )
    {
      result = a1;
      if ( !*(_BYTE *)(a1 + 382) )
      {
        result = a1;
        if ( !*(_DWORD *)(a1 + 696) )
        {
          if ( *(_DWORD *)(a1 + 628) && *(_WORD *)(a1 + 488) && a1 != *(_DWORD *)(a1 + 628) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 628) + 382) = 1;
            result = Use_BinaryMover(*(_DWORD *)(a1 + 628), a2, a2);
          }
          else
          {
            *(_BYTE *)(a1 + 382) = 1;
            result = Use_BinaryMover(a1, a2, a2);
          }
        }
      }
    }
  }
  return result;
}
// 17754: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);

//----- (0006529F) --------------------------------------------------------
void sub_6529F()
{
  ;
}

//----- (000652A4) --------------------------------------------------------
int __cdecl GScr_AllocString(int a1)
{
  return (unsigned __int16)Scr_AllocString(a1, 1);
}
// 19394: using guessed type _DWORD __cdecl Scr_AllocString(_DWORD, _DWORD);

//----- (000652D2) --------------------------------------------------------
int GScr_LoadConsts()
{
  int result; // eax

  scr_const[0] = GScr_AllocString("active");
  scr_const[1] = GScr_AllocString("air strike");
  scr_const[2] = GScr_AllocString("allies");
  scr_const[3] = GScr_AllocString("animdone");
  scr_const[4] = GScr_AllocString("axis");
  scr_const[5] = GScr_AllocString("bodyque");
  scr_const[6] = GScr_AllocString("combat");
  scr_const[7] = GScr_AllocString("connected");
  scr_const[8] = GScr_AllocString("connecting");
  scr_const[9] = GScr_AllocString("count");
  scr_const[11] = GScr_AllocString("crouch");
  scr_const[12] = GScr_AllocString("crowbar");
  scr_const[10] = GScr_AllocString("current");
  scr_const[13] = GScr_AllocString("damage");
  scr_const[14] = GScr_AllocString("death");
  scr_const[15] = GScr_AllocString("disconnected");
  scr_const[16] = GScr_AllocString("dlight");
  scr_const[17] = GScr_AllocString("done");
  scr_const[18] = GScr_AllocString("empty");
  scr_const[19] = GScr_AllocString("enemy");
  scr_const[20] = GScr_AllocString("enemyhidden");
  scr_const[21] = GScr_AllocString("enemyvisible");
  scr_const[22] = GScr_AllocString("entity");
  scr_const[23] = GScr_AllocString("failed");
  scr_const[24] = GScr_AllocString("flamebarrel");
  scr_const[25] = GScr_AllocString("fraction");
  scr_const[26] = GScr_AllocString("func_door");
  scr_const[27] = GScr_AllocString("func_door_rotating");
  scr_const[28] = GScr_AllocString("func_rotating");
  scr_const[29] = GScr_AllocString("func_tramcar");
  scr_const[30] = GScr_AllocString("goal");
  scr_const[31] = GScr_AllocString("grenade");
  scr_const[32] = GScr_AllocString("info_notnull");
  scr_const[33] = GScr_AllocString("invisible");
  scr_const[34] = GScr_AllocString("key1");
  scr_const[35] = GScr_AllocString("key2");
  scr_const[36] = GScr_AllocString("killanimscript");
  scr_const[37] = GScr_AllocString("left");
  scr_const[38] = GScr_AllocString("misc_flak");
  scr_const[39] = GScr_AllocString("misc_mg42");
  scr_const[40] = GScr_AllocString("misc_turret");
  scr_const[41] = GScr_AllocString("misc_tagemitter");
  scr_const[42] = GScr_AllocString("mortar");
  scr_const[43] = GScr_AllocString("movedone");
  scr_const[44] = GScr_AllocString("noclass");
  scr_const[45] = GScr_AllocString("noenemy");
  scr_const[46] = GScr_AllocString("noncombat");
  scr_const[47] = GScr_AllocString("normal");
  scr_const[48] = GScr_AllocString("pistol");
  scr_const[49] = GScr_AllocString("plane_waypoint");
  scr_const[50] = GScr_AllocString("player");
  scr_const[51] = GScr_AllocString("position");
  scr_const[52] = GScr_AllocString("primary");
  scr_const[53] = GScr_AllocString("primaryb");
  scr_const[54] = GScr_AllocString("prone");
  scr_const[55] = GScr_AllocString("reached_end_node");
  scr_const[56] = GScr_AllocString("reached_wait_node");
  scr_const[57] = GScr_AllocString("reached_wait_node");
  scr_const[58] = GScr_AllocString("right");
  scr_const[59] = GScr_AllocString("rocket");
  scr_const[60] = GScr_AllocString("rotatedone");
  scr_const[62] = GScr_AllocString("script_brushmodel");
  scr_const[63] = GScr_AllocString("script_model");
  scr_const[64] = GScr_AllocString("script_origin");
  scr_const[65] = GScr_AllocString("script_vehicle");
  scr_const[66] = GScr_AllocString("script_vehicle_corpse");
  scr_const[67] = GScr_AllocString("script_vehicle_collmap");
  scr_const[68] = GScr_AllocString("front_left");
  scr_const[69] = GScr_AllocString("front_right");
  scr_const[70] = GScr_AllocString("back_left");
  scr_const[71] = GScr_AllocString("back_right");
  scr_const[72] = GScr_AllocString("middle_left");
  scr_const[73] = GScr_AllocString("middle_right");
  scr_const[74] = GScr_AllocString("scriptcamera");
  scr_const[75] = GScr_AllocString("spawned");
  scr_const[76] = GScr_AllocString("spectator");
  scr_const[78] = GScr_AllocString("stand");
  scr_const[79] = GScr_AllocString("surfacetype");
  scr_const[80] = GScr_AllocString("tag_engine1");
  scr_const[81] = GScr_AllocString("tag_engine2");
  scr_const[82] = GScr_AllocString("target_location");
  scr_const[83] = GScr_AllocString("target_script_trigger");
  scr_const[84] = GScr_AllocString("tempEntity");
  scr_const[85] = GScr_AllocString("muzzleEntity");
  scr_const[86] = GScr_AllocString("smokegrenade");
  scr_const[87] = GScr_AllocString("touch");
  scr_const[88] = GScr_AllocString("trigger");
  scr_const[89] = GScr_AllocString("trigger_use");
  scr_const[90] = GScr_AllocString("trigger_damage");
  scr_const[91] = GScr_AllocString("trigger_mount");
  scr_const[92] = GScr_AllocString("trigger_lookat");
  scr_const[93] = GScr_AllocString("truck_cam");
  scr_const[94] = GScr_AllocString("turret_fire");
  scr_const[95] = GScr_AllocString("turret_alt_fire");
  scr_const[96] = GScr_AllocString("turret_gunner_fire");
  scr_const[97] = GScr_AllocString("turret_on_target");
  scr_const[98] = GScr_AllocString("turret_on_vistarget");
  scr_const[101] = GScr_AllocString("xmodel/airborne");
  scr_const[102] = GScr_AllocString("xmodel/wehrmacht");
  scr_const[100] = GScr_AllocString("worldspawn");
  scr_const[103] = GScr_AllocString("begin");
  scr_const[104] = GScr_AllocString("dynamite");
  scr_const[105] = GScr_AllocString("explosive_indicator");
  scr_const[106] = GScr_AllocString("flamechunk");
  scr_const[107] = GScr_AllocString("follow");
  scr_const[108] = GScr_AllocString("free");
  scr_const[109] = GScr_AllocString("freed");
  scr_const[110] = GScr_AllocString("func_leaky");
  scr_const[111] = GScr_AllocString("info_player_checkpoint");
  scr_const[112] = GScr_AllocString("initialize");
  scr_const[113] = GScr_AllocString("intermission");
  scr_const[114] = GScr_AllocString("item_stamina_brandy");
  scr_const[115] = GScr_AllocString("menuresponse");
  scr_const[116] = GScr_AllocString("misc_gunner_gun");
  scr_const[117] = GScr_AllocString("misc_gunner_ring");
  scr_const[118] = GScr_AllocString("mp_info_player_deathmatch");
  scr_const[119] = GScr_AllocString("mp_info_player_intermission");
  scr_const[120] = GScr_AllocString("mp_team_alliedplayer_respawn");
  scr_const[121] = GScr_AllocString("mp_team_alliedplayer_start");
  scr_const[122] = GScr_AllocString("mp_team_axisplayer_respawn");
  scr_const[123] = GScr_AllocString("mp_team_axisplayer_start");
  scr_const[124] = GScr_AllocString("nail");
  scr_const[125] = GScr_AllocString("not");
  scr_const[126] = GScr_AllocString("playing");
  scr_const[127] = GScr_AllocString("prox_mine");
  scr_const[128] = GScr_AllocString("reset");
  scr_const[129] = GScr_AllocString("script_mover");
  scr_const[130] = GScr_AllocString("script_multiplayer");
  scr_const[131] = GScr_AllocString("spear");
  scr_const[77] = GScr_AllocString("sprint");
  scr_const[132] = GScr_AllocString("tag_hand");
  scr_const[133] = GScr_AllocString("tag_rider");
  scr_const[134] = GScr_AllocString("tag_ring");
  scr_const[135] = GScr_AllocString("team_CTF_blueflag");
  scr_const[136] = GScr_AllocString("team_CTF_redflag");
  scr_const[137] = GScr_AllocString("team_WOLF_checkpoint");
  scr_const[138] = GScr_AllocString("team_WOLF_objective");
  scr_const[139] = GScr_AllocString("trigger_aidoor");
  scr_const[140] = GScr_AllocString("trigger_flagonly");
  scr_const[141] = GScr_AllocString("trigger_multiple");
  scr_const[142] = GScr_AllocString("trigger_objective_info");
  scr_const[143] = GScr_AllocString("waiting_for_players");
  scr_const[144] = GScr_AllocString("WP");
  scr_const[145] = GScr_AllocString("zombiespit");
  scr_const[146] = GScr_AllocString("none");
  scr_const[147] = GScr_AllocString("dead");
  scr_const[148] = GScr_AllocString("auto_change");
  scr_const[149] = GScr_AllocString("manual_change");
  scr_const[150] = GScr_AllocString("freelook");
  scr_const[151] = GScr_AllocString("activated");
  scr_const[152] = GScr_AllocString("deactivated");
  scr_const[153] = GScr_AllocString("vehicle_collision");
  scr_const[154] = GScr_AllocString("vehicle_activated");
  scr_const[155] = GScr_AllocString("vehicle_deactivated");
  scr_const[156] = GScr_AllocString("vsay");
  scr_const[157] = GScr_AllocString("artillery");
  scr_const[99] = GScr_AllocString("overheating");
  scr_const[158] = GScr_AllocString("squad_alpha");
  result = GScr_AllocString("squad_bravo");
  scr_const[159] = result;
  return result;
}
// 193F4: using guessed type _DWORD __cdecl GScr_AllocString(_DWORD);

//----- (000662F3) --------------------------------------------------------
_WORD *Scr_LoadLevel()
{
  _WORD *result; // eax
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  result = g_scr_data;
  if ( *(_DWORD *)g_scr_data )
  {
    v1 = Scr_ExecThread(*(_DWORD *)g_scr_data, 0);
    result = (_WORD *)Scr_FreeThread(v1);
  }
  return result;
}
// 193B4: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (00066340) --------------------------------------------------------
int __cdecl sub_66340(int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]

  if ( !Scr_LoadScript(a1) && a3 )
    G_Error("Could not find script '%s'", a1);
  v4 = Scr_GetFunctionHandle(a1, a2);
  if ( !v4 && a3 )
    G_Error("Could not find label '%s' in script '%s'", a2);
  return v4;
}
// 176C4: using guessed type _DWORD __cdecl Scr_LoadScript(_DWORD);
// 18BF4: using guessed type _DWORD __cdecl Scr_GetFunctionHandle(_DWORD, _DWORD);

//----- (000663C2) --------------------------------------------------------
int GScr_LoadGameTypeScript()
{
  int result; // eax
  char s[72]; // [esp+10h] [ebp-48h] BYREF

  Com_sprintf(s, 0x40u, "maps/mp/gametypes/%s", (char)&g_gametype + 16);
  *(_DWORD *)&g_scr_data[4] = sub_66340((int)s, (int)"main", 1);
  *(_DWORD *)&g_scr_data[6] = sub_66340((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_StartGameType", 1);
  *(_DWORD *)&g_scr_data[8] = sub_66340((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerConnect", 1);
  *(_DWORD *)&g_scr_data[10] = sub_66340(
                                 (int)"maps/mp/gametypes/_callbacksetup",
                                 (int)"CodeCallback_PlayerDisconnect",
                                 1);
  *(_DWORD *)&g_scr_data[12] = sub_66340((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerDamage", 1);
  result = sub_66340((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerKilled", 1);
  *(_DWORD *)&g_scr_data[14] = result;
  return result;
}

//----- (000664F9) --------------------------------------------------------
int sub_664F9()
{
  int result; // eax
  char v1[16]; // [esp+10h] [ebp-158h] BYREF
  int v2; // [esp+20h] [ebp-148h] BYREF
  char s[72]; // [esp+120h] [ebp-48h] BYREF

  trap_Cvar_Register(v1, "mapname", &unk_A248E, 68);
  Com_sprintf(s, 0x40u, "maps/mp/%s", (char)&v2);
  result = sub_66340((int)s, (int)"main", 0);
  *(_DWORD *)g_scr_data = result;
  return result;
}
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00066592) --------------------------------------------------------
int sub_66592()
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
    *(_DWORD *)&g_scr_data[4 * i + 212] = *(char **)((char *)off_ADDD0 + (_DWORD)&dword_0[i]);
  Scr_SetClassMap(&g_scr_data[210], 3);
  GScr_AddFieldsForEntity();
  GScr_AddFieldsForHudElems();
  return GScr_AddFieldsForRadiant();
}
// 0: using guessed type int dword_0[];
// 16774: using guessed type int GScr_AddFieldsForHudElems(void);
// 170C4: using guessed type int GScr_AddFieldsForEntity(void);
// 17E24: using guessed type int GScr_AddFieldsForRadiant(void);
// 18054: using guessed type _DWORD __cdecl Scr_SetClassMap(_DWORD, _DWORD);
// ADDD0: using guessed type char *off_ADDD0[3];

//----- (00066605) --------------------------------------------------------
int __cdecl sub_66605(int a1)
{
  return trap_Hunk_AllocLowInternal(a1);
}
// 17434: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);

//----- (00066628) --------------------------------------------------------
int GScr_LoadScripts()
{
  int v1; // [esp+1Ch] [ebp-900Ch] BYREF
  char v2[36872]; // [esp+20h] [ebp-9008h] BYREF

  v1 = 0;
  trap_Cvar_Set("cg_atmos", "-1");
  Scr_BeginLoadScripts();
  GScr_LoadGameTypeScript();
  sub_664F9();
  sub_66592();
  Scr_EndLoadScripts();
  BG_FindAnims();
  BG_AnimParseAnimScript(bgs, v2, &v1);
  Scr_PrecacheAnimTrees(sub_66605);
  BG_FindAnimTrees();
  Scr_EndLoadAnimTrees();
  BG_FinalizePlayerAnims();
  return BG_LoadAnimTreeInstances();
}
// 16D84: using guessed type int Scr_BeginLoadScripts(void);
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 16F84: using guessed type int BG_LoadAnimTreeInstances(void);
// 170B4: using guessed type int Scr_EndLoadAnimTrees(void);
// 17224: using guessed type _DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD);
// 172E4: using guessed type int GScr_LoadGameTypeScript(void);
// 17344: using guessed type int BG_FinalizePlayerAnims(void);
// 183B4: using guessed type int BG_FindAnimTrees(void);
// 188D4: using guessed type int BG_FindAnims(void);
// 18A64: using guessed type _DWORD __cdecl Scr_PrecacheAnimTrees(_DWORD);
// 197C4: using guessed type int Scr_EndLoadScripts(void);

//----- (000666CA) --------------------------------------------------------
int GScr_FreeScripts()
{
  return Scr_RemoveClassMap();
}
// 16DD4: using guessed type int Scr_RemoveClassMap(void);

//----- (000666E7) --------------------------------------------------------
_DWORD *__cdecl sub_666E7(unsigned int a1)
{
  if ( a1 <= 0x3FF )
    return &g_entities[211 * a1];
  Scr_ObjectError("not an entity");
  return 0;
}
// 181C4: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);

//----- (00066739) --------------------------------------------------------
_DWORD *__cdecl sub_66739(unsigned int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+30h] [ebp-8h]

  v3 = sub_666E7(a1);
  if ( !v3[88] )
  {
    if ( *((_WORD *)v3 + 243) )
      SL_ConvertToString(*((unsigned __int16 *)v3 + 243));
    SL_ConvertToString(*((unsigned __int16 *)v3 + 194));
    v1 = va("only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", a1);
    Scr_Error(v1);
  }
  return v3;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (00066800) --------------------------------------------------------
_DWORD *sub_66800()
{
  _DWORD *result; // eax
  char v1; // al
  char *i; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  result = g_NoScriptSpam;
  if ( !g_NoScriptSpam[3] )
  {
    v3 = Scr_GetNumParam();
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( (int)i >= v3 )
        break;
      v1 = Scr_GetDebugString(i);
      Com_Printf("%s", v1);
    }
  }
  return result;
}
// 17784: using guessed type _DWORD __cdecl Scr_GetDebugString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00066863) --------------------------------------------------------
_DWORD *sub_66863()
{
  _DWORD *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  result = g_NoScriptSpam;
  if ( !g_NoScriptSpam[3] )
  {
    sub_66800();
    result = (_DWORD *)Com_Printf("\n", v1);
  }
  return result;
}
// 66891: variable 'v1' is possibly undefined

//----- (0006689C) --------------------------------------------------------
int __cdecl Scr_LocalizationError(int a1, char *format)
{
  char v3; // [esp+8h] [ebp-10h]

  return Com_Error(7, format, v3);
}
// 668BC: variable 'v3' is possibly undefined

//----- (000668C7) --------------------------------------------------------
int *__cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char *v9; // eax
  int v10; // eax
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+14h] [ebp-34h]
  _BYTE *v13; // [esp+18h] [ebp-30h]
  const char *v14; // [esp+1Ch] [ebp-2Ch]
  int v15; // [esp+20h] [ebp-28h]
  char *s; // [esp+24h] [ebp-24h]
  int v17; // [esp+28h] [ebp-20h]
  int v18; // [esp+2Ch] [ebp-1Ch]
  signed int v19; // [esp+30h] [ebp-18h]
  int v20; // [esp+34h] [ebp-14h] BYREF
  int v21; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+40h] [ebp-8h]

  v15 = 1;
  switch ( a4 )
  {
    case 0:
      v14 = "Game Message";
      break;
    case 1:
      v14 = "Cvar Value";
      break;
    case 2:
      v14 = "Hint String";
      break;
    case 3:
      v14 = "Announcement String";
      break;
    case 4:
      v14 = "Client Cvar Value";
      break;
    case 5:
      v14 = "Client Chat Message";
      break;
    default:
      v14 = "BAD";
      break;
  }
  v20 = 0;
  *a2 = 0;
  v21 = Scr_GetNumParam();
  for ( i = a1; ; ++i )
  {
    result = (int *)i;
    if ( i >= v21 )
      break;
    v18 = Scr_GetType(i);
    v17 = 0;
    if ( v18 == 2 )
    {
      s = (char *)Scr_GetIString(i);
      v19 = strlen(s);
      for ( j = 0; j < v19; ++j )
      {
        if ( (*(_WORD *)(_ctype_b + 2 * s[j]) & 8) == 0 && s[j] != 95 )
        {
          v5 = va(
                 "Illegal localized string reference: %s (must contain only alpha-numeric characters and underscores",
                 (char)s);
          Scr_ParamError(i, v5);
        }
      }
      if ( v20 )
        v17 = 1;
      if ( v17 + v20 + v19 >= a3 )
      {
        v6 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v6);
      }
      if ( v17 )
      {
        a2[v20] = 20;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 1;
    }
    else if ( v18 == 7 && Scr_GetPointerType(i) == 13 )
    {
      v11 = Scr_GetEntity(i);
      if ( !*(_DWORD *)(v11 + 352) )
        Scr_ParamError(i, "Entity is not a player");
      s = (char *)va("%s^7", *(_DWORD *)(v11 + 352) - 12);
      v19 = strlen(s);
      if ( v15 )
        v17 = 1;
      if ( v17 + v20 + v19 >= a3 )
      {
        v7 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v7);
      }
      if ( v17 )
      {
        a2[v20] = 21;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 0;
    }
    else
    {
      v12 = 0;
      s = (char *)Scr_GetString(i);
      v19 = strlen(s);
      for ( j = 0; j < v19; ++j )
      {
        if ( s[j] == 20 || s[j] == 21 || s[j] == 22 )
        {
          v8 = va("bad escape character (%i) present in string", s[j]);
          Scr_ParamError(i, v8);
        }
        if ( (*(_WORD *)(_ctype_b + 2 * s[j]) & 0x400) != 0 )
        {
          if ( !v12 && g_languagewarnings[3] )
          {
            if ( g_languagewarningsaserrors[3] )
            {
              v9 = (char *)va("non-localized %s strings are not allowed to have letters in them: \"%s\"", (char)v14);
              Scr_LocalizationError(i, v9);
            }
            else
            {
              Com_Printf(
                "^3WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a local"
                "ized string: \"%s\"\n",
                (char)v14);
            }
          }
          v12 = 1;
        }
      }
      if ( v12 )
      {
        if ( v20 )
          v17 = 1;
      }
      else if ( v15 )
      {
        v17 = 1;
      }
      if ( v17 + v20 + v19 >= a3 )
      {
        v10 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v10);
      }
      if ( v12 )
      {
        if ( v17 )
        {
          a2[v20] = 20;
          a2[v20 + 1] = 0;
          v20 += v17;
        }
      }
      else if ( v17 )
      {
        a2[v20] = 21;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 0;
    }
    v13 = &a2[v20];
    for ( j = 0; j < v19; ++j )
    {
      if ( s[j] && (unsigned __int8)s[j] <= 0x1Fu || (unsigned __int8)s[j] > 0x7Eu )
        v13[j] = 46;
      else
        v13[j] = s[j];
    }
    v13[j] = 0;
    v20 += v19;
  }
  if ( v15 )
  {
    a2[v20] = 21;
    a2[v20 + 1] = 0;
    result = &v20;
    ++v20;
  }
  return result;
}
// 66DD3: returning address of temporary local variable '%var_14'
// 16C04: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 43A024: using guessed type int _ctype_b;

//----- (00066DDE) --------------------------------------------------------
int __cdecl Scr_MakeGameMessage(int a1, char a2)
{
  int v2; // eax
  char v4[1032]; // [esp+10h] [ebp-408h] BYREF

  Scr_ConstructMessageString(0, v4, 1024, 0);
  v2 = va("%s \"%s\"", a2);
  return trap_SendServerCommand(a1, 0, v2);
}
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00066E58) --------------------------------------------------------
int sub_66E58()
{
  return Scr_MakeGameMessage(-1, (char)"f");
}
// 197E4: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (00066E86) --------------------------------------------------------
int sub_66E86()
{
  return Scr_MakeGameMessage(-1, (char)"g");
}
// 197E4: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (00066EB4) --------------------------------------------------------
int sub_66EB4()
{
  unsigned int v1; // [esp+18h] [ebp-50h]
  float v2; // [esp+1Ch] [ebp-4Ch]
  int v3[4]; // [esp+20h] [ebp-48h] BYREF
  int v4; // [esp+30h] [ebp-38h] BYREF
  int v5; // [esp+34h] [ebp-34h]
  int v6; // [esp+38h] [ebp-30h]
  float v7; // [esp+3Ch] [ebp-2Ch]
  int v8; // [esp+4Ch] [ebp-1Ch]
  char v9[24]; // [esp+50h] [ebp-18h] BYREF

  v2 = 1.0;
  v4 = 1065353216;
  v5 = 1065353216;
  v6 = 1065353216;
  v7 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 == 3 )
    goto LABEL_8;
  if ( v1 > 3 )
  {
    if ( v1 == 4 )
    {
LABEL_7:
      v7 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, v3);
      v4 = v3[0];
      v5 = v3[1];
      v6 = v3[2];
      goto LABEL_9;
    }
LABEL_6:
    v2 = Scr_GetFloat(4);
    goto LABEL_7;
  }
  if ( v1 != 2 )
    goto LABEL_6;
LABEL_9:
  v8 = Scr_GetString(1);
  Scr_GetVector(0, v9);
  return trap_AddDebugString(v9, &v4, LODWORD(v2), v8);
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 188A4: using guessed type _DWORD __cdecl trap_AddDebugString(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00066F96) --------------------------------------------------------
int sub_66F96()
{
  unsigned int v1; // [esp+28h] [ebp-50h]
  int v2; // [esp+2Ch] [ebp-4Ch]
  int v3[4]; // [esp+30h] [ebp-48h] BYREF
  int v4; // [esp+40h] [ebp-38h] BYREF
  int v5; // [esp+44h] [ebp-34h]
  int v6; // [esp+48h] [ebp-30h]
  float v7; // [esp+4Ch] [ebp-2Ch]
  char v8[16]; // [esp+50h] [ebp-28h] BYREF
  char v9[24]; // [esp+60h] [ebp-18h] BYREF

  v2 = 0;
  v4 = 1065353216;
  v5 = 1065353216;
  v6 = 1065353216;
  v7 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 == 3 )
    goto LABEL_8;
  if ( v1 > 3 )
  {
    if ( v1 == 4 )
    {
LABEL_7:
      v7 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, v3);
      v4 = v3[0];
      v5 = v3[1];
      v6 = v3[2];
      goto LABEL_9;
    }
LABEL_6:
    v2 = Scr_GetInt(4);
    goto LABEL_7;
  }
  if ( v1 != 2 )
    goto LABEL_6;
LABEL_9:
  Scr_GetVector(1, v8);
  Scr_GetVector(0, v9);
  return trap_AddDebugLine(v9, v8, &v4, v2, 0);
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18B54: using guessed type _DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00067084) --------------------------------------------------------
void sub_67084()
{
  ;
}

//----- (00067089) --------------------------------------------------------
int sub_67089()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+10h] [ebp-8h]

  v1 = Scr_GetType(0);
  if ( v1 != 7 )
    return Scr_AddInt(v1 != 0);
  v2 = Scr_GetPointerType(0);
  return Scr_AddInt(v2 <= 15);
}
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (000670EB) --------------------------------------------------------
int sub_670EB()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && *(int *)(Scr_GetEntity(0) + 576) > 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (00067176) --------------------------------------------------------
int sub_67176()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]

  if ( Scr_GetType(0) == 7
    && Scr_GetPointerType(0) == 13
    && (v1 = Scr_GetEntity(0), *(_BYTE *)(v1 + 364))
    && *(_DWORD *)(v1 + 352)
    && *(_DWORD *)(*(_DWORD *)(v1 + 352) + 17696) == 2 )
  {
    result = Scr_AddInt(1);
  }
  else
  {
    result = Scr_AddInt(0);
  }
  return result;
}
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (0006721F) --------------------------------------------------------
int sub_6721F()
{
  char v1[1036]; // [esp+10h] [ebp-418h] BYREF
  int v2; // [esp+41Ch] [ebp-Ch]

  v2 = Scr_GetString(0);
  trap_Cvar_VariableStringBuffer(v2, v1, 1024);
  return Scr_AddString(v1);
}
// 16DF4: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00067277) --------------------------------------------------------
int sub_67277()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetString(0);
  v0 = trap_Cvar_VariableIntegerValue(v2);
  return Scr_AddInt(v0);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19404: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (000672B1) --------------------------------------------------------
int sub_672B1()
{
  float v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetString(0);
  v1 = trap_Cvar_VariableValue(v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19174: using guessed type long double __cdecl trap_Cvar_VariableValue(_DWORD);

//----- (000672EB) --------------------------------------------------------
int sub_672EB()
{
  size_t v0; // eax
  int v2; // [esp+20h] [ebp-828h]
  char *s; // [esp+28h] [ebp-820h]
  int v4; // [esp+2Ch] [ebp-81Ch]
  char v5[1024]; // [esp+30h] [ebp-818h] BYREF
  char v6[1024]; // [esp+430h] [ebp-418h] BYREF
  char *v7; // [esp+830h] [ebp-18h]
  int v8; // [esp+834h] [ebp-14h]
  size_t v9; // [esp+838h] [ebp-10h]
  int v10; // [esp+83Ch] [ebp-Ch]

  v4 = Scr_GetString(0);
  v8 = Scr_GetType(1);
  if ( v8 == 2 )
  {
    Scr_ConstructMessageString(1, v6, 1024, 1);
    s = v6;
    v0 = strlen(v6);
  }
  else
  {
    s = (char *)Scr_GetString(1);
    v0 = strlen(s);
  }
  v9 = v0;
  v7 = v5;
  memset(v5, 0, sizeof(v5));
  v10 = 0;
  while ( v10 <= 0x1FFF && s[v10] )
  {
    *v7 = Q_CleanCharacter(s[v10]);
    if ( *v7 == 34 )
      *v7 = 39;
    ++v10;
    ++v7;
  }
  v2 = 0;
  if ( (unsigned int)Scr_GetNumParam() > 2 && Scr_GetBool(2) )
    v2 = 1;
  if ( v2 )
    trap_Cvar_Register(0, v4, s, 12288);
  else
    trap_Cvar_Register(0, v4, s, 4096);
  return trap_Cvar_Set(v4, s);
}
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 17164: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006749E) --------------------------------------------------------
int sub_6749E()
{
  return Scr_AddInt(level[123]);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (000674CA) --------------------------------------------------------
_DWORD *sub_674CA()
{
  _DWORD *result; // eax

  result = (_DWORD *)Scr_GetInt(0);
  if ( (unsigned int)result <= 0x3FF )
  {
    result = sub_666E7((unsigned int)result);
    if ( *((_BYTE *)result + 364) )
      result = (_DWORD *)Scr_AddEntity(result);
  }
  return result;
}
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00067523) --------------------------------------------------------
int sub_67523()
{
  unsigned __int8 v0; // al
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char v4; // [esp+4h] [ebp-14h]
  _BYTE *v5; // [esp+10h] [ebp-8h]

  v5 = (_BYTE *)Scr_GetString(0);
  v0 = BG_GetWeaponIndexForName((char)v5);
  if ( v0 )
  {
    v3 = BG_GetInfoForWeapon(v0);
    result = Scr_AddString(*(_DWORD *)(v3 + 456));
  }
  else
  {
    if ( *v5 )
    {
      if ( Q_stricmp(v5, "none") )
      {
        v1 = (char *)va("unknown weapon '%s' in getWeaponModel\n", (char)v5);
        Com_Printf(v1, v4);
      }
    }
    result = Scr_AddString(&unk_A248E);
  }
  return result;
}
// 67594: variable 'v4' is possibly undefined
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (000675C8) --------------------------------------------------------
int sub_675C8()
{
  unsigned __int8 v0; // al
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char *v4; // eax
  char v5; // [esp+4h] [ebp-14h]
  char v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _BYTE *v9; // [esp+10h] [ebp-8h]

  v9 = (_BYTE *)Scr_GetString(0);
  v0 = BG_GetWeaponIndexForName((char)v9);
  v8 = v0;
  if ( v0 )
  {
    v7 = v0;
    do
    {
      if ( **(_BYTE **)(BG_GetInfoForWeapon(v7) + 452) )
      {
        v3 = BG_GetInfoForWeapon(v7);
        return Scr_AddString(*(_DWORD *)(v3 + 452));
      }
      v7 = *(_DWORD *)(BG_GetInfoForWeapon(v7) + 876);
    }
    while ( v7 && v7 != v8 );
    v4 = (char *)va("^3WARNING^7: no Radiant name found for weapon '%s' in getWeaponClassname\n", (char)v9);
    Com_Printf(v4, v6);
    result = Scr_AddUndefined();
  }
  else
  {
    if ( *v9 )
    {
      if ( Q_stricmp(v9, "none") )
      {
        v1 = (char *)va("unknown weapon '%s' in getWeaponClassname\n", (char)v9);
        Com_Printf(v1, v5);
      }
    }
    result = Scr_AddUndefined();
  }
  return result;
}
// 67639: variable 'v5' is possibly undefined
// 676B6: variable 'v6' is possibly undefined
// 17154: using guessed type int Scr_AddUndefined(void);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (000676C6) --------------------------------------------------------
int sub_676C6()
{
  float v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+10h] [ebp-8h] BYREF

  Scr_GetAnim(&v2);
  if ( !trap_XAnimIsPrimitive(v2) )
    Scr_ParamError(0, "non-primitive animation has no concept of length");
  v1 = trap_XAnimGetLengthSeconds(v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18BE4: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 19244: using guessed type long double __cdecl trap_XAnimGetLengthSeconds(_DWORD);
// 19554: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);

//----- (00067733) --------------------------------------------------------
int sub_67733()
{
  int v0; // eax
  unsigned __int16 v2; // [esp+Eh] [ebp-Ah]
  int v3; // [esp+10h] [ebp-8h] BYREF

  Scr_GetAnim(&v3);
  v2 = Scr_GetConstString(1);
  v0 = trap_XAnimNotetrackExists(v3, v2);
  return Scr_AddBool(v0);
}
// 18B44: using guessed type _DWORD __cdecl trap_XAnimNotetrackExists(_DWORD, _DWORD);
// 18BE4: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 18DF4: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00067793) --------------------------------------------------------
int sub_67793()
{
  float *v1; // [esp+1Ch] [ebp-1Ch]
  float v2; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+24h] [ebp-14h]
  float v4; // [esp+28h] [ebp-10h]

  v1 = (float *)Scr_GetEntity(0);
  v2 = v1[73] + v1[76];
  v3 = v1[74] + v1[77];
  v4 = v1[75] + v1[78];
  v2 = v2 * 0.5;
  v3 = v3 * 0.5;
  v4 = v4 * 0.5;
  return Scr_AddVector(&v2);
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006782E) --------------------------------------------------------
int sub_6782E()
{
  int v1; // [esp+8h] [ebp-10h]
  char v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v2 = Scr_GetString(0);
  v1 = (unsigned __int8)BG_GetWeaponIndexForName(v2);
  v3 = BG_GetInfoForWeapon(v1);
  return Scr_AddInt(*(_DWORD *)(v3 + 504));
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00067885) --------------------------------------------------------
int sub_67885()
{
  char v1; // al
  int v2; // eax
  int v3; // [esp+18h] [ebp-30h]
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  int v5[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v6; // [esp+3Eh] [ebp-Ah]

  v6 = Scr_GetConstString(0);
  Scr_GetVector(1, v5);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v3 = 0;
  else
    v3 = Scr_GetInt(2);
  v4 = (_DWORD *)G_Spawn();
  Scr_SetString(v4 + 97, v6);
  v4[79] = v5[0];
  v4[80] = v5[1];
  v4[81] = v5[2];
  v4[98] = v3;
  if ( G_CallSpawnEntity(v4) )
    return Scr_AddEntity(v4);
  v1 = SL_ConvertToString(v6);
  v2 = va("unable to spawn \"%s\" entity", v1);
  return Scr_Error(v2);
}
// 167A4: using guessed type int G_Spawn(void);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 197F4: using guessed type _DWORD __cdecl G_CallSpawnEntity(_DWORD);

//----- (00067974) --------------------------------------------------------
int sub_67974()
{
  int i; // [esp+10h] [ebp-38h]
  float v2; // [esp+14h] [ebp-34h]
  int v3; // [esp+18h] [ebp-30h]
  float *v4; // [esp+1Ch] [ebp-2Ch]
  float v5[4]; // [esp+20h] [ebp-28h] BYREF
  float v6[6]; // [esp+30h] [ebp-18h] BYREF

  Scr_GetVector(0, v6);
  Scr_GetVector(1, v5);
  v3 = Scr_GetBool(2);
  for ( i = 0; i <= 2; ++i )
  {
    if ( v6[i] > (long double)v5[i] )
    {
      v2 = v6[i];
      v6[i] = v5[i];
      v5[i] = v2;
    }
  }
  v4 = (float *)G_Spawn();
  Scr_SetString(v4 + 97, scr_const[91]);
  v4[66] = v6[0];
  v4[67] = v6[1];
  v4[68] = v6[2];
  v4[69] = v5[0];
  v4[70] = v5[1];
  v4[71] = v5[2];
  SP_trigger_mount_no_brush(v4, v3);
  return Scr_AddEntity(v4);
}
// 167A4: using guessed type int G_Spawn(void);
// 16D34: using guessed type _DWORD __cdecl SP_trigger_mount_no_brush(_DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00067AA0) --------------------------------------------------------
int sub_67AA0()
{
  char v1; // [esp+18h] [ebp-30h]
  _DWORD *v2; // [esp+1Ch] [ebp-2Ch]
  int v3[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v4; // [esp+3Eh] [ebp-Ah]

  v4 = Scr_GetConstString(0);
  Scr_GetVector(1, v3);
  v1 = Scr_GetString(2);
  v2 = (_DWORD *)G_Spawn();
  Scr_SetString(v2 + 97, v4);
  v2[79] = v3[0];
  v2[80] = v3[1];
  v2[81] = v3[2];
  G_SpawnTurret(v2, v1);
  return Scr_AddEntity(v2);
}
// 167A4: using guessed type int G_Spawn(void);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19544: using guessed type _DWORD __cdecl G_SpawnTurret(_DWORD, char);

//----- (00067B4B) --------------------------------------------------------
int sub_67B4B()
{
  int result; // eax
  char v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetString(0);
  if ( !level[8] )
    Scr_Error("precacheTurret must be called before any wait statements in the level script\n");
  result = (unsigned __int8)BG_GetWeaponIndexForName(v1);
  if ( (_BYTE)result )
    result = RegisterItem((unsigned __int8)result, 1);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00067BB6) --------------------------------------------------------
int __cdecl sub_67BB6(unsigned int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+1Ch] [ebp-1Ch]
  void *v4; // [esp+20h] [ebp-18h]
  char *s2; // [esp+2Ch] [ebp-Ch]
  _DWORD *v6; // [esp+30h] [ebp-8h]

  v6 = sub_666E7(a1);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v4 = &unk_A248E;
  else
    v4 = (void *)Scr_GetString(1);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v3 = 0;
  else
    v3 = Scr_GetBool(2);
  if ( G_EntDetach((int)v6, s2, (int)v4) )
  {
    v1 = va("model '%s' already attached to tag '%s'", (char)s2);
    Scr_Error(v1);
  }
  result = G_EntAttach((int)v6, s2, (int)v4, v3);
  if ( !result )
    result = Scr_Error("maximum attached models exceeded");
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00067CB0) --------------------------------------------------------
int __cdecl sub_67CB0(unsigned int a1)
{
  int result; // eax
  char v2; // al
  int v3; // eax
  char v4; // [esp+4h] [ebp-24h]
  void *v5; // [esp+Ch] [ebp-1Ch]
  int i; // [esp+10h] [ebp-18h]
  char *s2; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_666E7(a1);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v5 = &unk_A248E;
  else
    v5 = (void *)Scr_GetString(1);
  result = G_EntDetach((int)v8, s2, (int)v5);
  if ( !result )
  {
    Com_Printf("Current attachments:\n", v4);
    for ( i = 0; i <= 5; ++i )
    {
      if ( *((_BYTE *)v8 + i + 764) )
      {
        if ( *((_WORD *)v8 + i + 385) )
        {
          SL_ConvertToString(*((unsigned __int16 *)v8 + i + 385));
          v2 = G_ModelName(*((unsigned __int8 *)v8 + i + 764));
          Com_Printf("model: '%s', tag: '%s'\n", v2);
        }
      }
    }
    v3 = va("failed to detach model '%s' from tag '%s'", (char)s2);
    result = Scr_Error(v3);
  }
  return result;
}
// 67D35: variable 'v4' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (00067DE6) --------------------------------------------------------
int __cdecl sub_67DE6(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  return G_EntDetachAll(v2);
}
// 16AB4: using guessed type _DWORD __cdecl G_EntDetachAll(_DWORD);

//----- (00067E17) --------------------------------------------------------
int __cdecl sub_67E17(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  for ( i = 0; i <= 5 && *((_BYTE *)v2 + i + 764); ++i )
    ;
  return Scr_AddInt(i);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00067E71) --------------------------------------------------------
int __cdecl sub_67E71(unsigned int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  unsigned int v4; // [esp+10h] [ebp-8h]

  v3 = sub_666E7(a1);
  v4 = Scr_GetInt(0);
  if ( v4 > 5 || !*((_BYTE *)v3 + v4 + 764) )
    Scr_ParamError(0, "bad index");
  v1 = G_ModelName(*((unsigned __int8 *)v3 + v4 + 764));
  return Scr_AddString(v1);
}
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00067EF2) --------------------------------------------------------
int __cdecl sub_67EF2(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 5 || !*((_BYTE *)v2 + v3 + 764) )
    Scr_ParamError(0, "bad index");
  return Scr_AddConstString(*((unsigned __int16 *)v2 + v3 + 385));
}
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00067F6A) --------------------------------------------------------
int __cdecl sub_67F6A(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 5 || !*((_BYTE *)v2 + v3 + 764) )
    Scr_ParamError(0, "bad index");
  return Scr_AddBool(((int)*((unsigned __int8 *)v2 + 386) >> v3) & 1);
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18DF4: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);

//----- (00067FE7) --------------------------------------------------------
int __cdecl sub_67FE7(unsigned int a1)
{
  char v1; // al
  int v2; // eax
  int result; // eax
  char v4; // al
  int v5; // eax
  int v6; // eax
  void *v7; // [esp+2Ch] [ebp-3Ch]
  char v8[16]; // [esp+30h] [ebp-38h] BYREF
  char v9[16]; // [esp+40h] [ebp-28h] BYREF
  int v10; // [esp+50h] [ebp-18h]
  char v11[4]; // [esp+54h] [ebp-14h]
  int v12; // [esp+58h] [ebp-10h]
  _DWORD *v13; // [esp+5Ch] [ebp-Ch]

  v13 = sub_666E7(a1);
  if ( Scr_GetType(0) != 7 || Scr_GetPointerType(0) != 13 )
    Scr_ParamError(0, "not an entity");
  if ( (v13[99] & 0x2000) == 0 )
  {
    v1 = SL_ConvertToString(*((unsigned __int16 *)v13 + 194));
    v2 = va("entity (classname: '%s') does not currently support linkTo", v1);
    Scr_ObjectError(v2);
  }
  v12 = Scr_GetEntity(0);
  v10 = Scr_GetNumParam();
  if ( v10 <= 1 )
    v7 = &unk_A248E;
  else
    v7 = (void *)Scr_GetString(1);
  *(_DWORD *)v11 = v7;
  if ( v10 > 2 )
  {
    Scr_GetVector(2, v9);
    Scr_GetVector(3, v8);
    result = G_EntLinkToWithOffset(v13, v12, *(_DWORD *)v11, v9, v8);
    if ( result )
      return result;
  }
  else
  {
    result = G_EntLinkTo(v13, v12, *(_DWORD *)v11);
    if ( result )
      return result;
  }
  if ( !trap_DObjExists(v12) )
  {
    if ( !*(_BYTE *)(v12 + 385) )
      Scr_Error("failed to link entity since parent has no model");
    v4 = G_ModelName(*(unsigned __int8 *)(v12 + 385));
    v5 = va("failed to link entity since parent model '%s' is invalid", v4);
    Scr_Error(v5);
  }
  if ( **(_BYTE **)v11 )
  {
    if ( (int)trap_DObjGetBoneIndex(v12, *(_DWORD *)v11) < 0 )
    {
      trap_DObjDumpInfo(v12);
      G_ModelName(*(unsigned __int8 *)(v12 + 385));
      v6 = va("failed to link entity since tag '%s' does not exist in parent model '%s'", v11[0]);
      Scr_Error(v6);
    }
  }
  return Scr_Error("failed to link entity due to link cycle");
}
// 16854: using guessed type _DWORD __cdecl G_EntLinkTo(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 174E4: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17734: using guessed type _DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 181C4: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19044: using guessed type _DWORD __cdecl trap_DObjDumpInfo(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (000681FF) --------------------------------------------------------
int __cdecl sub_681FF(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  return G_EntUnlink(v2);
}
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (00068230) --------------------------------------------------------
int __cdecl sub_68230(unsigned int a1)
{
  const char *v1; // eax
  char v2; // al
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = sub_666E7(a1);
  if ( (v5[99] & 0x2000) != 0 )
    Scr_ObjectError("entity already has linkTo enabled");
  if ( v5[1]
    || *((_BYTE *)v5 + 365)
    || (v5[131] || v5[132])
    && (v1 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v5 + 194)), strcasecmp(v1, "trigger_multiple")) )
  {
    v2 = SL_ConvertToString(*((unsigned __int16 *)v5 + 194));
    v3 = va("entity (classname: '%s') does not currently support enableLinkTo", v2);
    Scr_ObjectError(v3);
  }
  v5[131] = level[123];
  v5[132] = Think_GeneralLink;
  result = v5[99] | 0x2000;
  v5[99] = result;
  return result;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 181C4: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// 78C40: using guessed type int __cdecl Think_GeneralLink(int);

//----- (00068338) --------------------------------------------------------
int __cdecl sub_68338(unsigned int a1)
{
  int v2[7]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v3; // [esp+2Ch] [ebp-Ch]

  v3 = sub_666E7(a1);
  v2[0] = v3[79];
  v2[1] = v3[80];
  v2[2] = v3[81];
  return Scr_AddVector(v2);
}
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006838D) --------------------------------------------------------
_DWORD *__cdecl sub_6838D(unsigned int a1)
{
  char v1; // al
  int v2; // eax
  int v3; // eax
  char v4; // al
  int v5; // eax
  unsigned __int16 v6; // ax
  _DWORD *v8; // [esp+Ch] [ebp-Ch]

  if ( a1 != level[2182] || level[123] != level[2181] || (unsigned __int16)Scr_GetConstString(0) != LOWORD(level[2183]) )
  {
    v8 = sub_666E7(a1);
    if ( !trap_DObjExists(v8) )
    {
      v1 = SL_ConvertToString(*((unsigned __int16 *)v8 + 194));
      v2 = va("entity has no model defined (classname '%s')", v1);
      Scr_ObjectError(v2);
    }
    v3 = Scr_GetString(0);
    if ( !G_DObjGetWorldTagMatrix(v8, v3, &level[2184]) )
    {
      trap_DObjDumpInfo(v8);
      G_ModelName(*((unsigned __int8 *)v8 + 385));
      v4 = Scr_GetString(0);
      v5 = va("tag '%s' does not exist in model '%s' (or any attached submodels)", v4);
      Scr_ParamError(0, v5);
    }
    level[2182] = a1;
    level[2181] = level[123];
    v6 = Scr_GetConstString(0);
    Scr_SetString(&level[2183], v6);
  }
  return &level[2184];
}
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 174E4: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 181C4: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19044: using guessed type _DWORD __cdecl trap_DObjDumpInfo(_DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00068590) --------------------------------------------------------
int __cdecl sub_68590(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( !v2[88] )
    return Scr_Error("GetStance is only defined for players.");
  if ( (*(_DWORD *)(v2[88] + 12) & 1) != 0 )
    return Scr_AddConstString(scr_const[54]);
  if ( (*(_DWORD *)(v2[88] + 12) & 2) != 0 )
    return Scr_AddConstString(scr_const[11]);
  return Scr_AddConstString(scr_const[78]);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (00068635) --------------------------------------------------------
int __cdecl sub_68635(unsigned int a1)
{
  int v2[7]; // [esp+10h] [ebp-28h] BYREF
  float *v3; // [esp+2Ch] [ebp-Ch]

  v3 = (float *)sub_666E7(a1);
  v2[0] = (int)v3[79];
  v2[1] = (int)v3[80];
  *(float *)&v2[2] = v3[81] + 40.0;
  return Scr_AddVector(v2);
}
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (00068698) --------------------------------------------------------
int __cdecl sub_68698(unsigned int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_666E7(a1);
  v2 = Scr_GetEntity(0);
  Scr_AddEntity(v2);
  Scr_Notify(v3, scr_const[88], 1);
  result = (int)v3;
  if ( v3[136] )
    result = ((int (__cdecl *)(_DWORD *, int, int))v3[136])(v3, v2, v2);
  return result;
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00068727) --------------------------------------------------------
int __cdecl sub_68727(unsigned int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-68h]
  float v3; // [esp+14h] [ebp-64h]
  float v4; // [esp+18h] [ebp-60h]
  float v5; // [esp+20h] [ebp-58h]
  float v6; // [esp+24h] [ebp-54h]
  float v7; // [esp+28h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-3Ch]
  float v9; // [esp+40h] [ebp-38h] BYREF
  float v10; // [esp+44h] [ebp-34h]
  float v11; // [esp+48h] [ebp-30h]
  float v12; // [esp+50h] [ebp-28h] BYREF
  float v13; // [esp+54h] [ebp-24h]
  float v14; // [esp+58h] [ebp-20h]
  float *v15; // [esp+68h] [ebp-10h]
  float *v16; // [esp+6Ch] [ebp-Ch]

  v8 = 0;
  v16 = (float *)sub_666E7(a1);
  if ( *((_DWORD *)v16 + 65) )
  {
    v16 = (float *)Scr_GetEntity(0);
    v15 = (float *)sub_666E7(a1);
  }
  else
  {
    v15 = (float *)Scr_GetEntity(0);
  }
  v12 = v16[79] + v16[66];
  v13 = v16[80] + v16[67];
  v14 = v16[81] + v16[68];
  v9 = v16[79] + v16[69];
  v10 = v16[80] + v16[70];
  v11 = v16[81] + v16[71];
  if ( *((_DWORD *)v16 + 65) && *((_DWORD *)v15 + 65) )
  {
    v2 = v15[79] + v15[69];
    if ( v2 > (long double)v12
      || (v3 = v15[80] + v15[70], v3 > (long double)v13)
      || (v4 = v15[81] + v15[71], v4 > (long double)v14)
      || (v5 = v15[79] + v15[66], v9 > (long double)v5)
      || (v6 = v15[80] + v15[67], v10 > (long double)v6)
      || (v7 = v15[81] + v15[68], v11 > (long double)v7) )
    {
      v8 = 1;
    }
  }
  else if ( ((_DWORD)v16[62] & 0x200) != 0 )
  {
    if ( trap_EntityContactCapsule(&v12, &v9, v15) )
      v8 = 1;
  }
  else if ( trap_EntityContact(&v12, &v9, v15) )
  {
    v8 = 1;
  }
  if ( v8 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 174C4: using guessed type _DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18434: using guessed type _DWORD __cdecl trap_EntityContactCapsule(_DWORD, _DWORD, _DWORD);

//----- (0006897F) --------------------------------------------------------
_DWORD *__cdecl sub_6897F(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) == scr_const[27]
    || (result = (_DWORD *)*((unsigned __int16 *)v2 + 194), (_WORD)result == scr_const[26]) )
  {
    result = v2;
    v2[174] = 1;
  }
  return result;
}

//----- (000689E0) --------------------------------------------------------
_DWORD *__cdecl sub_689E0(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) == scr_const[27]
    || (result = (_DWORD *)*((unsigned __int16 *)v2 + 194), (_WORD)result == scr_const[26]) )
  {
    result = v2;
    v2[174] = 0;
  }
  return result;
}

//----- (00068A41) --------------------------------------------------------
int __cdecl sub_68A41(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( (*((_WORD *)v2 + 194) == scr_const[27] || *((_WORD *)v2 + 194) == scr_const[26]) && v2[174] )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00068ABB) --------------------------------------------------------
int __cdecl sub_68ABB(unsigned int a1)
{
  int v2; // [esp+8h] [ebp-10h]
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v4; // [esp+10h] [ebp-8h]

  v4 = sub_666E7(a1);
  s2 = (char *)Scr_GetString(0);
  v2 = (unsigned __int8)G_SoundAliasIndex(s2);
  v4[64] = level[123] + 300;
  return G_PlaySoundAlias(v4, v2);
}
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00068B2E) --------------------------------------------------------
int __cdecl sub_68B2E(unsigned int a1)
{
  int result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_666E7(a1);
  s2 = (char *)Scr_GetString(0);
  LOBYTE(result) = G_SoundAliasIndex(s2);
  v3[64] = -1;
  result = (unsigned __int8)result;
  v3[33] = (unsigned __int8)result;
  return result;
}
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00068B8D) --------------------------------------------------------
_DWORD *__cdecl sub_68B8D(unsigned int a1)
{
  _DWORD *result; // eax

  result = sub_666E7(a1);
  result[64] = level[123] + 300;
  result[33] = 0;
  return result;
}

//----- (00068BDA) --------------------------------------------------------
int __cdecl sub_68BDA(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( v2[88] )
    Scr_Error("Cannot delete a client entity");
  Scr_AddEntity(v2);
  Scr_Notify(v2, scr_const[14], 1);
  trap_UnlinkEntity(v2);
  v2[136] = 0;
  v2[135] = 0;
  v2[132] = G_FreeEntity;
  result = level[123] + 100;
  v2[131] = result;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00068C92) --------------------------------------------------------
int __cdecl sub_68C92(unsigned int a1)
{
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_666E7(a1);
  s2 = (char *)Scr_GetString(0);
  G_SetModel((int)v3, s2);
  G_DObjUpdate(v3);
  return trap_LinkEntity(v3);
}
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00068CEF) --------------------------------------------------------
int __cdecl sub_68CEF(unsigned int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+0h] [ebp-18h]
  _DWORD *v4; // [esp+10h] [ebp-8h]

  v4 = sub_666E7(a1);
  if ( v4[88] )
  {
    if ( v4[144] )
    {
      v2 = (long double)(int)v4[144] / (long double)*(int *)(v4[88] + 17796);
      result = Scr_AddFloat(LODWORD(v2));
    }
    else
    {
      result = Scr_AddFloat(0);
    }
  }
  else
  {
    v3 = (float)(int)v4[144];
    result = Scr_AddFloat(LODWORD(v3));
  }
  return result;
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (00068D70) --------------------------------------------------------
int __cdecl sub_68D70(unsigned int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+6h] [ebp-12h]
  int v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = sub_666E7(a1);
  v5 = Scr_GetFloat(0);
  if ( v5 > 1.0 )
    v5 = 1.0;
  if ( v6[88] )
  {
    v2 = v3;
    v4 = (int)((long double)*(int *)(v6[88] + 17796) * v5);
  }
  else
  {
    v2 = v3;
    if ( v6[145] )
      v4 = (int)((long double)(int)v6[145] * v5);
    else
      v4 = (int)v5;
  }
  if ( v4 <= 0 )
    return Com_Printf("ERROR: Cannot setnormalhealth to 0 or below.\n", v2);
  result = v4;
  v6[144] = v4;
  return result;
}
// 68DE3: variable 'v3' is possibly undefined
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00068E67) --------------------------------------------------------
int __cdecl sub_68E67(unsigned int a1)
{
  long double v1; // fst7
  char v2; // al
  int v4; // [esp+38h] [ebp-50h]
  float *v5; // [esp+3Ch] [ebp-4Ch]
  float v6; // [esp+40h] [ebp-48h] BYREF
  float v7; // [esp+44h] [ebp-44h]
  float v8; // [esp+48h] [ebp-40h]
  float v9; // [esp+50h] [ebp-38h] BYREF
  float v10; // [esp+54h] [ebp-34h]
  float v11; // [esp+58h] [ebp-30h]
  int v12[4]; // [esp+60h] [ebp-28h] BYREF
  float v13; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]
  float *v16; // [esp+7Ch] [ebp-Ch]

  v4 = 0;
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    Scr_Error("DoDamage damageAmount sourceVec [attacker] [inflictor] [mod]\n");
  v16 = (float *)sub_666E7(a1);
  v13 = Scr_GetFloat(0);
  Scr_GetVector(1, v12);
  v9 = *(float *)v12;
  v10 = *(float *)&v12[1];
  v11 = *(float *)&v12[2];
  if ( *((_DWORD *)v16 + 88) )
  {
    v6 = *(float *)(*((_DWORD *)v16 + 88) + 20) - v9;
    v7 = *(float *)(*((_DWORD *)v16 + 88) + 24) - v10;
    v1 = *(float *)(*((_DWORD *)v16 + 88) + 28) - v11;
  }
  else
  {
    v6 = v16[79] - v9;
    v7 = v16[80] - v10;
    v1 = v16[81] - v11;
  }
  v8 = v1;
  if ( VectorNormalize(&v6) == 0.0 )
    v5 = 0;
  else
    v5 = &v6;
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v15 = 0;
  else
    v15 = Scr_GetEntity(2);
  if ( (unsigned int)Scr_GetNumParam() <= 3 )
    v14 = v15;
  else
    v14 = Scr_GetEntity(3);
  if ( (unsigned int)Scr_GetNumParam() > 4 )
  {
    v2 = Scr_GetString(4);
    v4 = G_IndexForMeansOfDeath(v2);
  }
  return G_Damage(v16, v14, v15, v5, &v9, (int)v13, 0, v4, 0);
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 192E4: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);

//----- (00069042) --------------------------------------------------------
int __cdecl sub_69042(unsigned int a1)
{
  long double v1; // fst7
  char v2; // al
  int v4; // [esp+38h] [ebp-50h]
  float *v5; // [esp+3Ch] [ebp-4Ch]
  float v6; // [esp+40h] [ebp-48h] BYREF
  float v7; // [esp+44h] [ebp-44h]
  float v8; // [esp+48h] [ebp-40h]
  float v9; // [esp+50h] [ebp-38h] BYREF
  float v10; // [esp+54h] [ebp-34h]
  float v11; // [esp+58h] [ebp-30h]
  int v12[6]; // [esp+60h] [ebp-28h] BYREF
  float v13; // [esp+78h] [ebp-10h]
  float *v14; // [esp+7Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    Scr_Error("DoDamageMod damageAmount sourceVec mod\n");
  v14 = (float *)sub_666E7(a1);
  v13 = Scr_GetFloat(0);
  Scr_GetVector(1, v12);
  v9 = *(float *)v12;
  v10 = *(float *)&v12[1];
  v11 = *(float *)&v12[2];
  if ( *((_DWORD *)v14 + 88) )
  {
    v6 = *(float *)(*((_DWORD *)v14 + 88) + 20) - v9;
    v7 = *(float *)(*((_DWORD *)v14 + 88) + 24) - v10;
    v1 = *(float *)(*((_DWORD *)v14 + 88) + 28) - v11;
  }
  else
  {
    v6 = v14[79] - v9;
    v7 = v14[80] - v10;
    v1 = v14[81] - v11;
  }
  v8 = v1;
  if ( VectorNormalize(&v6) == 0.0 )
    v5 = 0;
  else
    v5 = &v6;
  v2 = Scr_GetString(2);
  v4 = G_IndexForMeansOfDeath(v2);
  return G_Damage(v14, 0, 0, v5, &v9, (int)v13, 0, v4, 0);
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 192E4: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);

//----- (000691D2) --------------------------------------------------------
int __cdecl sub_691D2(unsigned int a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  if ( Scr_GetNumParam() != 1 )
    Scr_Error("SetTakeDamage true/false\n");
  v3 = sub_666E7(a1);
  v2 = Scr_GetBool(0);
  result = v2;
  *((_BYTE *)v3 + 381) = v2;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006922C) --------------------------------------------------------
unsigned int __cdecl sub_6922C(unsigned int a1)
{
  _DWORD *v1; // edx
  unsigned int result; // eax

  v1 = sub_666E7(a1);
  result = v1[99] & 0xFFFFEFFF;
  v1[99] = result;
  return result;
}

//----- (00069259) --------------------------------------------------------
int __cdecl sub_69259(unsigned int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_666E7(a1);
  result = v1[99] | 0x1000;
  v1[99] = result;
  return result;
}

//----- (00069286) --------------------------------------------------------
int __cdecl sub_69286(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  return trap_UnlinkEntity(v2);
}
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (000692B7) --------------------------------------------------------
int __cdecl sub_692B7(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  return trap_LinkEntity(v2);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000692E8) --------------------------------------------------------
int __cdecl ScrCmd_VerifyPosition(unsigned int a1)
{
  int result; // eax
  int v2; // [esp+2Ch] [ebp-ACh]
  int v3[12]; // [esp+30h] [ebp-A8h] BYREF
  float v4; // [esp+60h] [ebp-78h]
  float v5; // [esp+64h] [ebp-74h]
  float v6; // [esp+68h] [ebp-70h]
  float v7; // [esp+70h] [ebp-68h] BYREF
  float v8; // [esp+74h] [ebp-64h]
  float v9; // [esp+78h] [ebp-60h]
  float v10; // [esp+80h] [ebp-58h] BYREF
  float v11; // [esp+84h] [ebp-54h]
  float v12; // [esp+88h] [ebp-50h]
  char v13[60]; // [esp+90h] [ebp-48h] BYREF
  float *v14; // [esp+CCh] [ebp-Ch]

  v14 = (float *)sub_666E7(a1);
  if ( *((_DWORD *)v14 + 1) == 12 )
  {
    VEH_GetMinsMaxs(v14, &v10, &v7);
    v10 = v10 * 1.2;
    v11 = v11 * 1.2;
    v12 = v12 * 1.2;
    v7 = v7 * 1.2;
    v8 = v8 * 1.2;
    v9 = v9 * 1.2;
    v4 = v14[79];
    v5 = v14[80];
    v6 = v14[81];
    v10 = v10 + v4;
    v11 = v11 + v5;
    v12 = v12 + v6;
    v7 = v7 + v4;
    v8 = v8 + v5;
    v9 = v9 + v6;
    v12 = v12 - 32.0;
    v2 = trap_EntitiesInBox(&v10, &v7, v3, 10, 41943040);
    if ( !v2 || v2 == 1 && v3[0] == a1 )
    {
      if ( Scr_GetNumParam() == 1 )
      {
        if ( Scr_GetInt(0) )
          VEH_InitPhysics(v14);
      }
      result = Scr_AddInt(1);
    }
    else
    {
      result = Scr_AddInt(0);
    }
  }
  else
  {
    trap_Trace(v13, v14 + 79, v14 + 66, v14 + 69, v14 + 79, *(_DWORD *)v14, *((_DWORD *)v14 + 104));
    if ( v13[47] || v13[46] )
      result = Scr_AddInt(0);
    else
      result = Scr_AddInt(1);
  }
  return result;
}
// 16A34: using guessed type _DWORD __cdecl VEH_GetMinsMaxs(_DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 180B4: using guessed type _DWORD __cdecl VEH_InitPhysics(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006950E) --------------------------------------------------------
int *__cdecl sub_6950E(unsigned int a1)
{
  int *result; // eax
  _DWORD *v2; // [esp+24h] [ebp-84h]
  int *i; // [esp+28h] [ebp-80h]
  int v4; // [esp+2Ch] [ebp-7Ch]
  int v5[12]; // [esp+30h] [ebp-78h] BYREF
  float v6; // [esp+60h] [ebp-48h]
  float v7; // [esp+64h] [ebp-44h]
  float v8; // [esp+68h] [ebp-40h]
  float v9; // [esp+70h] [ebp-38h] BYREF
  float v10; // [esp+74h] [ebp-34h]
  float v11; // [esp+78h] [ebp-30h]
  float v12; // [esp+80h] [ebp-28h] BYREF
  float v13; // [esp+84h] [ebp-24h]
  float v14; // [esp+88h] [ebp-20h]
  int *v15; // [esp+9Ch] [ebp-Ch]

  result = sub_666E7(a1);
  v15 = result;
  if ( result[1] == 12 )
  {
    VEH_GetMinsMaxs(v15, &v12, &v9);
    v6 = *((float *)v15 + 79);
    v7 = *((float *)v15 + 80);
    v8 = *((float *)v15 + 81);
    v12 = v12 + v6;
    v13 = v13 + v7;
    v14 = v14 + v8;
    v9 = v9 + v6;
    v10 = v10 + v7;
    v11 = v11 + v8;
    v4 = trap_EntitiesInBox(&v12, &v9, v5, 10, 67109120);
    for ( i = 0; ; i = (int *)((char *)i + 1) )
    {
      result = i;
      if ( (int)i >= v4 )
        break;
      v2 = sub_666E7(v5[(_DWORD)i]);
      Scr_AddEntity(v2);
      Scr_Notify(v2, scr_const[14], 1);
      trap_UnlinkEntity(v2);
      v2[136] = 0;
      v2[135] = 0;
      v2[132] = G_FreeEntity;
      v2[131] = level[123] + 100;
    }
  }
  return result;
}
// 16A34: using guessed type _DWORD __cdecl VEH_GetMinsMaxs(_DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000696B9) --------------------------------------------------------
int __cdecl sub_696B9(unsigned int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_666E7(a1);
  v2 = Scr_GetInt(0);
  Scr_AddInt(v3[72]);
  v3[72] = v2;
  return trap_LinkEntity(v3);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (00069716) --------------------------------------------------------
int __cdecl sub_69716(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  Scr_GetVector(0, v2 + 66);
  Scr_GetVector(1, v2 + 69);
  return trap_LinkEntity(v2);
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00069777) --------------------------------------------------------
_DWORD *__cdecl sub_69777(unsigned int a1)
{
  _DWORD *result; // eax
  int v2; // eax
  char v3; // [esp+4h] [ebp-14h]
  char v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  v6 = sub_666E7(a1);
  v5 = Scr_GetString(0);
  if ( *((_WORD *)v6 + 194) != scr_const[89] || Q_strcasecmp(v5, "HINT_INHERIT") )
  {
    for ( i = 1; i <= 266 && *(&hintStrings + i); ++i )
    {
      if ( !Q_strcasecmp(v5, *(&hintStrings + i)) )
      {
        result = (_DWORD *)i;
        v6[56] = i;
        return result;
      }
    }
    Com_Printf("List of valid hint type strings\n", v3);
    if ( *((_WORD *)v6 + 194) == scr_const[89] )
      Com_Printf("HINT_INHERIT (for trigger_use entities only)\n", v4);
    for ( j = 1; j <= 266 && *(&hintStrings + j); ++j )
      Com_Printf((char *)&off_A2E8E, (char)*(&hintStrings + j));
    v2 = va("%s is not a valid hint type. See above for list of valid hint types\n", v5);
    result = (_DWORD *)Scr_Error(v2);
  }
  else
  {
    result = v6;
    v6[56] = -1;
  }
  return result;
}
// 6984B: variable 'v3' is possibly undefined
// 69872: variable 'v4' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19284: using guessed type _DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD);
// A2E8E: using guessed type void *off_A2E8E;
// ADDA0: using guessed type void *hintStrings;

//----- (000698E0) --------------------------------------------------------
int __cdecl G_GetHintStringIndex(int a1, char *s1)
{
  char s2[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1365, s2, 1024);
    if ( !s2[0] )
    {
      trap_SetConfigstring(i + 1365, s1);
      *(_DWORD *)a1 = i;
      return 1;
    }
    if ( !strcmp(s1, s2) )
    {
      *(_DWORD *)a1 = i;
      return 1;
    }
  }
  *(_DWORD *)a1 = -1;
  return 0;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (000699B6) --------------------------------------------------------
_DWORD *__cdecl sub_699B6(unsigned int a1)
{
  int v1; // eax
  _DWORD *result; // eax
  int v3; // eax
  char s1[1028]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v5; // [esp+414h] [ebp-14h]
  int v6; // [esp+418h] [ebp-10h]
  int v7[3]; // [esp+41Ch] [ebp-Ch] BYREF

  v5 = sub_666E7(a1);
  if ( *((_WORD *)v5 + 194) != scr_const[89] )
    Scr_Error("The setHintString command only works on trigger_use entities.\n");
  v6 = Scr_GetType(0);
  if ( v6 != 1 || (v1 = Scr_GetString(0), Q_stricmp(v1, &unk_A248E)) )
  {
    Scr_ConstructMessageString(0, s1, 1024, 2);
    if ( !G_GetHintStringIndex((int)v7, s1) )
    {
      v3 = va("Too many different hintstring values. Max allowed is %i different strings", 32);
      Scr_Error(v3);
    }
    result = (_DWORD *)LOBYTE(v7[0]);
    v5[55] = LOBYTE(v7[0]);
  }
  else
  {
    result = v5;
    v5[55] = 255;
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00069AB9) --------------------------------------------------------
int __cdecl sub_69AB9(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  return Scr_AddInt(*v2);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00069AEC) --------------------------------------------------------
int __cdecl sub_69AEC(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) != scr_const[39] && *((_WORD *)v2 + 194) != scr_const[40] )
    Scr_Error("Can only call turret script functions on misc_mg42 or misc_turret");
  return Scr_AddFloat(*(_DWORD *)(v2[90] + 64));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (00069B60) --------------------------------------------------------
int __cdecl sub_69B60(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) != scr_const[39] && *((_WORD *)v2 + 194) != scr_const[40] )
    Scr_Error("Can only call turret script functions on misc_mg42 or misc_turret");
  return Scr_AddBool(*(_DWORD *)(v2[90] + 68));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18DF4: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);

//----- (00069BD4) --------------------------------------------------------
_DWORD *__cdecl sub_69BD4(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) != scr_const[90] )
    Scr_Error("Currently on supported on damage triggers");
  result = v2;
  v2[99] |= 0x8000u;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00069C39) --------------------------------------------------------
_DWORD *__cdecl sub_69C39(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_666E7(a1);
  if ( *((_WORD *)v2 + 194) != scr_const[90] )
    Scr_Error("Currently on supported on damage triggers");
  result = v2;
  v2[99] &= 0xFFFF7FFF;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00069C9E) --------------------------------------------------------
unsigned int __cdecl sub_69C9E(unsigned int a1)
{
  _DWORD *v1; // edx
  unsigned int result; // eax

  v1 = sub_666E7(a1);
  result = v1[99] & 0xFFFEFFFF;
  v1[99] = result;
  return result;
}

//----- (00069CCB) --------------------------------------------------------
int __cdecl sub_69CCB(unsigned int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_666E7(a1);
  result = v1[99] | 0x10000;
  v1[99] = result;
  return result;
}

//----- (00069CF8) --------------------------------------------------------
int *G_InitObjectives()
{
  int *result; // eax
  int i; // [esp+10h] [ebp-8h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    sub_69E3F(&level[7 * i + 9]);
    result = &i;
  }
  return result;
}

//----- (00069D4B) --------------------------------------------------------
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2)
{
  if ( a2 == scr_const[18] )
  {
    *a1 = 0;
    return 1;
  }
  if ( a2 == scr_const[33] )
  {
    *a1 = 2;
    return 1;
  }
  if ( a2 == scr_const[10] )
  {
    *a1 = 4;
    return 1;
  }
  *a1 = 0;
  return 0;
}

//----- (00069DD7) --------------------------------------------------------
int __cdecl sub_69DD7(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-8h]

  result = a1;
  if ( *(_DWORD *)(a1 + 16) != 1023 )
  {
    v2 = &g_entities[211 * *(_DWORD *)(a1 + 16)];
    if ( *((_BYTE *)v2 + 364) )
      v2[62] &= 0xFFFFFFEF;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1023;
  }
  return result;
}

//----- (00069E3F) --------------------------------------------------------
_DWORD *__cdecl sub_69E3F(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[3] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[4] = 1023;
  a1[5] = 0;
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (00069E92) --------------------------------------------------------
int __cdecl sub_69E92(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  char *s2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  s2 = (char *)Scr_GetString(a2);
  for ( i = 0; s2[i]; ++i )
  {
    if ( s2[i] <= 31 || s2[i] == 127 )
    {
      v2 = va("Illegal character '%c'(ascii %i) in objective icon name: %s\n", s2[i]);
      Scr_ParamError(3, v2);
    }
  }
  if ( i > 63 )
  {
    v3 = va("Objective icon name is too long (> %i): %s\n", 63);
    Scr_ParamError(3, v3);
  }
  result = G_ShaderIndex(s2);
  *(_DWORD *)(a1 + 24) = result;
  return result;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00069F70) --------------------------------------------------------
float *sub_69F70()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  float *result; // eax
  int v4; // [esp+20h] [ebp-18h] BYREF
  unsigned __int16 v5; // [esp+26h] [ebp-12h]
  float *v6; // [esp+28h] [ebp-10h]
  char v7[4]; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v8 = Scr_GetNumParam();
  if ( v8 <= 1 )
    Scr_Error(
      "objective_add needs at least the first two parameters out of its parameter list of: index state [string] [position]\n");
  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(int *)v7 < 0 || *(int *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v7[0]);
    Scr_ParamError(0, v0);
  }
  v6 = (float *)&level[7 * *(_DWORD *)v7 + 9];
  sub_69DD7((int)v6);
  v5 = Scr_GetConstString(1);
  if ( !ObjectiveStateIndexFromString(&v4, v5) )
  {
    v1 = SL_ConvertToString(v5);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, v2);
  }
  *(_DWORD *)v6 = v4;
  if ( v8 > 2 )
  {
    Scr_GetVector(2, v6 + 1);
    v6[1] = (float)(int)v6[1];
    v6[2] = (float)(int)v6[2];
    v6[3] = (float)(int)v6[3];
    *((_DWORD *)v6 + 4) = 1023;
    if ( v8 > 3 )
      sub_69E92((int)v6, 3);
  }
  result = v6;
  v6[5] = 0.0;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 193C4: using guessed type _DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD);

//----- (0006A132) --------------------------------------------------------
_DWORD *sub_6A132()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2);
    Scr_ParamError(0, v0);
  }
  sub_69DD7((int)&level[7 * v2 + 9]);
  return sub_69E3F(&level[7 * v2 + 9]);
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006A1DE) --------------------------------------------------------
int sub_6A1DE()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  int result; // eax
  unsigned __int16 v4; // [esp+16h] [ebp-12h]
  int v5; // [esp+18h] [ebp-10h] BYREF
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]
  char v7[4]; // [esp+20h] [ebp-8h]

  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(int *)v7 < 0 || *(int *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v7[0]);
    Scr_ParamError(0, v0);
  }
  v6 = &level[7 * *(_DWORD *)v7 + 9];
  v4 = Scr_GetConstString(1);
  if ( !ObjectiveStateIndexFromString(&v5, v4) )
  {
    v1 = Scr_GetString(1);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, v2);
  }
  result = v5;
  *v6 = v5;
  if ( !v5 || v5 == 2 )
    result = sub_69DD7((int)v6);
  return result;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 193C4: using guessed type _DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD);

//----- (0006A2D6) --------------------------------------------------------
int sub_6A2D6()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2);
    Scr_ParamError(0, v0);
  }
  return sub_69E92((int)&level[7 * v2 + 9], 1);
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006A365) --------------------------------------------------------
int sub_6A365()
{
  int v0; // eax
  int result; // eax
  float *v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetInt(0);
  if ( v3 < 0 || v3 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3);
    Scr_ParamError(0, v0);
  }
  v2 = (float *)&level[7 * v3 + 9];
  sub_69DD7((int)v2);
  Scr_GetVector(1, v2 + 1);
  v2[1] = (float)(int)v2[1];
  v2[2] = (float)(int)v2[2];
  result = (int)v2[3];
  v2[3] = (float)result;
  return result;
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006A477) --------------------------------------------------------
int sub_6A477()
{
  int v0; // eax
  int result; // eax
  int *v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetInt(0);
  if ( v3 < 0 || v3 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3);
    Scr_ParamError(0, v0);
  }
  sub_69DD7((int)&level[7 * v3 + 9]);
  v2 = (int *)Scr_GetEntity(1);
  v2[62] |= 0x10u;
  result = *v2;
  level[7 * v3 + 13] = *v2;
  return result;
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006A533) --------------------------------------------------------
char *sub_6A533()
{
  char *result; // eax
  int v1; // eax
  int s[16]; // [esp+10h] [ebp-58h] BYREF
  _DWORD *v3; // [esp+50h] [ebp-18h]
  char v4[4]; // [esp+54h] [ebp-14h] BYREF
  char *v5; // [esp+58h] [ebp-10h]
  char *i; // [esp+5Ch] [ebp-Ch]

  v5 = (char *)Scr_GetNumParam();
  memset(s, 0, sizeof(s));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i >= (int)v5 )
      break;
    *(_DWORD *)v4 = Scr_GetInt(i);
    if ( *(int *)v4 < 0 || *(int *)v4 > 15 )
    {
      v1 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v4[0]);
      Scr_ParamError(i, v1);
    }
    s[*(_DWORD *)v4] = 1;
  }
  *(_DWORD *)v4 = 0;
  while ( *(int *)v4 <= 15 )
  {
    v3 = &level[7 * *(_DWORD *)v4 + 9];
    if ( s[*(_DWORD *)v4] )
    {
      *v3 = 4;
    }
    else if ( *v3 == 4 )
    {
      *v3 = 1;
    }
    result = v4;
    ++*(_DWORD *)v4;
  }
  return result;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006A635) --------------------------------------------------------
_DWORD *sub_6A635()
{
  int v0; // eax
  _DWORD *result; // eax
  char v2; // al
  int v3; // eax
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = Scr_GetInt(0);
  if ( v6 < 0 || v6 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v6);
    Scr_ParamError(0, v0);
  }
  v5 = &level[7 * v6 + 9];
  v4 = Scr_GetConstString(1);
  if ( v4 == scr_const[2] )
  {
    result = &level[7 * v6 + 9];
    v5[5] = 2;
  }
  else if ( v4 == scr_const[4] )
  {
    result = &level[7 * v6 + 9];
    v5[5] = 1;
  }
  else if ( v4 == scr_const[146] )
  {
    result = &level[7 * v6 + 9];
    v5[5] = 0;
  }
  else
  {
    v2 = SL_ConvertToString(v4);
    v3 = va("Illegal team string '%s'. Must be allies, axis, or none.", v2);
    result = (_DWORD *)Scr_ParamError(1, v3);
  }
  return result;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006A74C) --------------------------------------------------------
int sub_6A74C()
{
  char v1; // [esp+4h] [ebp-434h]
  char *s; // [esp+1Ch] [ebp-41Ch]
  char dest[1024]; // [esp+20h] [ebp-418h] BYREF
  size_t v4; // [esp+420h] [ebp-18h]
  int v5; // [esp+424h] [ebp-14h]
  int v6; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  dest[0] = 0;
  v5 = 0;
  v6 = Scr_GetNumParam();
  for ( i = 0; i < v6; ++i )
  {
    s = (char *)Scr_GetString(i);
    v4 = strlen(s);
    if ( (int)(v5 + v4) > 1023 )
      break;
    strcat(dest, s);
    v5 += v4;
  }
  return G_LogPrintf(dest, v1);
}
// 6A7E7: variable 'v1' is possibly undefined
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006A7F5) --------------------------------------------------------
int sub_6A7F5()
{
  return Scr_AddInt(1022);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0006A819) --------------------------------------------------------
_DWORD *sub_6A819()
{
  _DWORD *result; // eax
  _DWORD *v1; // [esp+Ch] [ebp-1Ch]
  int v2; // [esp+10h] [ebp-18h]
  void *v3; // [esp+14h] [ebp-14h]
  char v4; // [esp+18h] [ebp-10h]
  char v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  result = g_obituary;
  if ( g_obituary[3] )
  {
    v5 = Scr_GetString(2);
    v3 = (void *)(unsigned __int8)BG_GetWeaponIndexForName(v5);
    v4 = Scr_GetString(3);
    v2 = G_IndexForMeansOfDeath(v4);
    v6 = (_DWORD *)Scr_GetEntity(0);
    v1 = (_DWORD *)G_TempEntity(vec3_origin, 209);
    v1[29] = *v6;
    if ( Scr_GetType(1) == 7 && Scr_GetPointerType(1) == 13 )
      v1[30] = *(_DWORD *)Scr_GetEntity(1);
    else
      v1[30] = 1022;
    v1[62] = 8;
    if ( v2 == 7
      || v2 == 26
      || v2 == 8
      || v2 == 13
      || v2 == 21
      || v2 == 20
      || v2 == 16
      || v2 == 17
      || v2 == 18
      || v2 == 15 )
    {
      result = (_DWORD *)(v2 | 0x80);
      v1[41] = v2 | 0x80;
    }
    else
    {
      result = v3;
      v1[41] = v3;
    }
  }
  return result;
}
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 192E4: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0006A964) --------------------------------------------------------
int sub_6A964()
{
  float v1; // [esp+20h] [ebp-1058h] BYREF
  float v2; // [esp+24h] [ebp-1054h]
  float v3; // [esp+28h] [ebp-1050h]
  float v4; // [esp+30h] [ebp-1048h] BYREF
  float v5; // [esp+34h] [ebp-1044h]
  float v6; // [esp+38h] [ebp-1040h]
  float v7; // [esp+40h] [ebp-1038h] BYREF
  float v8; // [esp+44h] [ebp-1034h]
  float v9; // [esp+48h] [ebp-1030h]
  _DWORD *v10; // [esp+5Ch] [ebp-101Ch]
  int v11[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v12; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  Scr_GetVector(0, &v1);
  v7 = v1 + *(float *)playerMins;
  v8 = v2 + *(float *)&playerMins[1];
  v9 = v3 + *(float *)&playerMins[2];
  v4 = v1 + *(float *)playerMaxs;
  v5 = v2 + *(float *)&playerMaxs[1];
  v6 = v3 + *(float *)&playerMaxs[2];
  v12 = trap_EntitiesInBox(&v7, &v4, v11, 1024, 0x2000000);
  for ( i = 0; i < v12; ++i )
  {
    v10 = &g_entities[211 * v11[i]];
    if ( v10[88] && *(int *)(v10[88] + 4) <= 5 )
      return Scr_AddInt(1);
  }
  v7 = v1 + *(float *)playerMins;
  v8 = v2 + *(float *)&playerMins[1];
  v9 = v3 + *(float *)&playerMins[2];
  v4 = v1 + *(float *)playerMaxs;
  v5 = v2 + *(float *)&playerMaxs[1];
  v6 = v3 + *(float *)&playerMaxs[2];
  v12 = trap_EntitiesInBox(&v7, &v4, v11, 1024, 128);
  for ( i = 0; i < v12; ++i )
  {
    v10 = &g_entities[211 * v11[i]];
    if ( v10[1] == 12 )
      return Scr_AddInt(1);
  }
  return Scr_AddInt(0);
}
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0006ABC2) --------------------------------------------------------
int sub_6ABC2()
{
  return Scr_AddInt(level[126]);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0006ABEE) --------------------------------------------------------
int sub_6ABEE()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1333, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the menu '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1333, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 32 )
  {
    v1 = va("Too many menus precached. Max allowed menus is %i", 32);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 1333, *(_DWORD *)v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006AD04) --------------------------------------------------------
int __cdecl GScr_GetScriptMenuIndex(int a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1333, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i;
  }
  v1 = va("Menu '%s' was not precached\n", a1);
  Scr_Error(v1);
  return 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006ADAB) --------------------------------------------------------
int sub_6ADAB()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 15; ++i )
  {
    trap_GetConfigstring(i + 22, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the player status icon '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 15; ++i )
  {
    trap_GetConfigstring(i + 22, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 16 )
  {
    v1 = va("Too many player status icons precached. Max allowed is %i", 16);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 22, *(_DWORD *)v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006AEBB) --------------------------------------------------------
int __cdecl GScr_GetStatusIconIndex(_BYTE *a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 15; ++i )
  {
    trap_GetConfigstring(i + 22, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i + 1;
  }
  v1 = va("Status icon '%s' was not precached\n", (char)a1);
  Scr_Error(v1);
  return 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006AF78) --------------------------------------------------------
int sub_6AF78()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 38, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the player head icon '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 38, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 15 )
  {
    v1 = va("Too many player head icons precached. Max allowed is %i", 15);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 38, *(_DWORD *)v3);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006B088) --------------------------------------------------------
int __cdecl GScr_GetHeadIconIndex(_BYTE *a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 38, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i + 1;
  }
  v1 = va("Head icon '%s' was not precached\n", (char)a1);
  Scr_Error(v1);
  return 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006B145) --------------------------------------------------------
int sub_6B145()
{
  int v0; // eax
  int result; // eax
  float v2[7]; // [esp+20h] [ebp-88h] BYREF
  int v3; // [esp+3Ch] [ebp-6Ch]
  float v4; // [esp+40h] [ebp-68h] BYREF
  int v5; // [esp+44h] [ebp-64h] BYREF
  _DWORD v6[6]; // [esp+50h] [ebp-58h] BYREF
  unsigned __int16 v7; // [esp+68h] [ebp-40h]
  int v8; // [esp+70h] [ebp-38h]
  int v9; // [esp+74h] [ebp-34h]
  int *v10; // [esp+78h] [ebp-30h]
  float v12[4]; // [esp+80h] [ebp-28h] BYREF
  float v13[6]; // [esp+90h] [ebp-18h] BYREF

  v10 = 0;
  v9 = 1023;
  v8 = 41951281;
  Scr_GetVector(0, v13);
  Scr_GetVector(1, v12);
  if ( !Scr_GetBool(2) )
    v8 &= 0xFDFFFFFF;
  if ( Scr_GetType(3) == 7 && Scr_GetPointerType(3) == 13 )
  {
    v10 = (int *)Scr_GetEntity(3);
    v9 = *v10;
  }
  trap_LocationalTrace(&v4, v13, v12, v9, v8, &bulletPriorityMap);
  Scr_MakeArray();
  Scr_AddFloat(LODWORD(v4));
  Scr_AddArrayStringIndexed(scr_const[25]);
  Scr_AddVector(&v5);
  Scr_AddArrayStringIndexed(scr_const[51]);
  if ( v7 == 1023 || v7 == 1022 )
    Scr_AddUndefined();
  else
    Scr_AddEntity(&g_entities[211 * v7]);
  Scr_AddArrayStringIndexed(scr_const[22]);
  if ( v4 >= 1.0 )
  {
    v2[0] = v12[0] - v13[0];
    v2[1] = v12[1] - v13[1];
    v2[2] = v12[2] - v13[2];
    VectorNormalize(v2);
    Scr_AddVector(v2);
    Scr_AddArrayStringIndexed(scr_const[47]);
    Scr_AddConstString(scr_const[146]);
    result = Scr_AddArrayStringIndexed(scr_const[79]);
  }
  else
  {
    Scr_AddVector(v6);
    Scr_AddArrayStringIndexed(scr_const[47]);
    v3 = (v6[3] & 0x1F00000) >> 20;
    v0 = trap_SurfaceTypeToName(v3);
    Scr_AddString(v0);
    result = Scr_AddArrayStringIndexed(scr_const[79]);
  }
  return result;
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17154: using guessed type int Scr_AddUndefined(void);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18BD4: using guessed type _DWORD __cdecl Scr_AddArrayStringIndexed(_DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19204: using guessed type _DWORD __cdecl trap_SurfaceTypeToName(_DWORD);
// 19504: using guessed type int Scr_MakeArray(void);

//----- (0006B397) --------------------------------------------------------
int sub_6B397()
{
  int result; // eax
  int v1; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 > 0 )
  {
    v1 = irand(0, v2);
    result = Scr_AddInt(v1);
  }
  else
  {
    Com_Printf("RandomInt parm: %d  ", v2);
    result = Scr_Error("RandomInt parm must be positive integer.\n");
  }
  return result;
}
// 16804: using guessed type _DWORD __cdecl irand(_DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006B404) --------------------------------------------------------
int sub_6B404()
{
  float v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetFloat(0);
  flrand(0.0, v1);
  return Scr_AddFloat(LODWORD(v1));
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B446) --------------------------------------------------------
int sub_6B446()
{
  int v0; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = Scr_GetInt(0);
  v2 = Scr_GetInt(1);
  if ( v2 <= v3 )
  {
    Com_Printf("RandomIntRange parms: %d %d ", v3);
    Scr_Error("RandomIntRange range must be positive integer.\n");
  }
  v0 = irand(v3, v2);
  return Scr_AddInt(v0);
}
// 16804: using guessed type _DWORD __cdecl irand(_DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006B4C8) --------------------------------------------------------
int sub_6B4C8()
{
  long double v0; // fst7
  float v2; // [esp+0h] [ebp-28h]
  double v3; // [esp+4h] [ebp-24h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  v4 = Scr_GetFloat(1);
  v0 = v4;
  if ( v5 >= (long double)v4 )
  {
    v0 = v5;
    v3 = v5;
    Com_Printf("Scr_RandomFloatRange parms: %d %d ", SLOBYTE(v3));
    Scr_Error("Scr_RandomFloatRange range must be positive float.\n");
  }
  flrand(v5, v4);
  v2 = v0;
  return Scr_AddFloat(LODWORD(v2));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B551) --------------------------------------------------------
int sub_6B551()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = sin(v0 * 3.141592653589793 / 180.0);
  return Scr_AddFloat(LODWORD(v2));
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B59B) --------------------------------------------------------
int sub_6B59B()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = cos(v0 * 3.141592653589793 / 180.0);
  return Scr_AddFloat(LODWORD(v2));
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B5E5) --------------------------------------------------------
int sub_6B5E5()
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+18h] [ebp-10h]
  float v3; // [esp+1Ch] [ebp-Ch] BYREF
  float v4[2]; // [esp+20h] [ebp-8h] BYREF

  v2 = Scr_GetFloat(0) * 3.141592653589793 / 180.0;
  sub_6F0F7(v2, v4, &v3);
  if ( v3 == 0.0 )
    Scr_Error("divide by 0");
  v1 = v4[0] / v3;
  return Scr_AddFloat(LODWORD(v1));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B667) --------------------------------------------------------
int sub_6B667()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-14h]
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  if ( v5 < -1.0 || v5 > 1.0 )
  {
    v2 = v5;
    v0 = va("%g out of range", SLOBYTE(v2));
    Scr_Error(v0);
  }
  v3 = asin(v5);
  v4 = v3 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v4));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B6FE) --------------------------------------------------------
int sub_6B6FE()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-14h]
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  if ( v5 < -1.0 || v5 > 1.0 )
  {
    v2 = v5;
    v0 = va("%g out of range", SLOBYTE(v2));
    Scr_Error(v0);
  }
  v3 = acos(v5);
  v4 = v3 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v4));
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B795) --------------------------------------------------------
int sub_6B795()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = atan(v0);
  v3 = v2 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v3));
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B7E5) --------------------------------------------------------
int sub_6B7E5()
{
  float v1; // [esp+0h] [ebp-38h]
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = VectorDistance(v3, v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);

//----- (0006B83D) --------------------------------------------------------
int sub_6B83D()
{
  float v1; // [esp+0h] [ebp-38h]
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = VectorDistanceSquared(v3, v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0006B895) --------------------------------------------------------
int sub_6B895()
{
  float v1; // [esp+1Ch] [ebp-1Ch]
  float v2; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+24h] [ebp-14h]
  float v4; // [esp+28h] [ebp-10h]

  Scr_GetVector(0, &v2);
  v1 = sqrt(v2 * v2 + v3 * v3 + v4 * v4);
  return Scr_AddFloat(LODWORD(v1));
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B8EC) --------------------------------------------------------
int sub_6B8EC()
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+10h] [ebp-18h] BYREF
  float v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+18h] [ebp-10h]

  Scr_GetVector(0, &v2);
  v1 = v2 * v2 + v3 * v3 + v4 * v4;
  return Scr_AddFloat(LODWORD(v1));
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006B935) --------------------------------------------------------
int sub_6B935()
{
  float v1; // [esp+18h] [ebp-40h]
  float v2; // [esp+1Ch] [ebp-3Ch]
  char v3[16]; // [esp+20h] [ebp-38h] BYREF
  char v4[16]; // [esp+30h] [ebp-28h] BYREF
  char v5[24]; // [esp+40h] [ebp-18h] BYREF

  Scr_GetVector(0, v5);
  Scr_GetVector(1, v4);
  Scr_GetVector(2, v3);
  v2 = VectorDistanceSquared(v4, v5);
  v1 = VectorDistanceSquared(v3, v5);
  return Scr_AddInt(v1 > (long double)v2);
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0006B9CB) --------------------------------------------------------
int sub_6B9CB()
{
  float v1; // [esp+0h] [ebp-38h]
  float v2[4]; // [esp+10h] [ebp-28h] BYREF
  float v3[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = v3[0] * v2[0] + v3[1] * v2[1] + v3[2] * v2[2];
  return Scr_AddFloat(LODWORD(v1));
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0006BA27) --------------------------------------------------------
int sub_6BA27()
{
  int v1[4]; // [esp+10h] [ebp-28h] BYREF
  int v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  v1[0] = v2[0];
  v1[1] = v2[1];
  v1[2] = v2[2];
  VectorNormalize(v1);
  return Scr_AddVector(v1);
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006BA7C) --------------------------------------------------------
int sub_6BA7C()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  vectoangles(v2, v1);
  return Scr_AddVector(v1);
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0006BAC4) --------------------------------------------------------
int sub_6BAC4()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, 0, v1);
  return Scr_AddVector(v1);
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006BB1C) --------------------------------------------------------
int sub_6BB1C()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, v1, 0);
  return Scr_AddVector(v1);
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006BB74) --------------------------------------------------------
int sub_6BB74()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, v1, 0, 0);
  return Scr_AddVector(v1);
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006BBCC) --------------------------------------------------------
int sub_6BBCC()
{
  char v0; // al
  int v1; // eax

  v0 = Scr_GetString(0);
  v1 = va("o %s", v0);
  return trap_SendServerCommand(-1, 1, v1);
}
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006BC1A) --------------------------------------------------------
int sub_6BC1A()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  v6 = Scr_GetNumParam();
  if ( v6 )
  {
    if ( v6 != 1 )
    {
      v0 = va("USAGE: musicStop([fadetime]);\n", v5);
      return Scr_Error(v0);
    }
    v4 = Scr_GetFloat(0) * 1000.0;
    v7 = sub_6F0B9(v4);
  }
  else
  {
    v7 = 0;
  }
  if ( v7 < 0 )
  {
    v2 = va("musicStop: fade time must be >= 0\n", v5);
    Scr_Error(v2);
  }
  v3 = va("p %i", v7);
  return trap_SendServerCommand(-1, 1, v3);
}
// 6BC75: variable 'v5' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006BCD3) --------------------------------------------------------
int sub_6BCD3()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-24h]
  float v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetFloat(0);
  if ( (unsigned int)Scr_GetNumParam() > 1 )
    Scr_GetFloat(1);
  v2 = v3;
  v0 = va("q %f %i\n", SLOBYTE(v2));
  return trap_SendServerCommand(-1, 1, v0);
}
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006BD6D) --------------------------------------------------------
int sub_6BD6D()
{
  char *v0; // eax

  if ( !level[8] )
    Scr_Error("precacheModel must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ModelIndex(v0);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006BDB3) --------------------------------------------------------
int sub_6BDB3()
{
  char *v0; // eax

  if ( !level[8] )
    Scr_Error("precacheShellShock must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ShellShockIndex(v0);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006BDF9) --------------------------------------------------------
int sub_6BDF9()
{
  int v0; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  if ( !level[8] )
    Scr_Error("precacheItem must be called before any wait statements in the gametype or level script\n");
  v3 = Scr_GetString(0);
  v2 = BG_FindItem(v3);
  if ( !v2 )
  {
    v0 = va("unknown item '%s'", v3);
    Scr_ParamError(0, v0);
  }
  return RegisterItem(-1431655765 * ((v2 - (int)bg_itemlist) >> 4), 1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 17564: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006BE9D) --------------------------------------------------------
int sub_6BE9D()
{
  char *s2; // [esp+10h] [ebp-8h]

  if ( !level[8] )
    Scr_Error("precacheShader must be called before any wait statements in the gametype or level script\n");
  s2 = (char *)Scr_GetString(0);
  if ( !*s2 )
    Scr_ParamError(0, "Shader name string is empty");
  return G_ShaderIndex(s2);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006BF07) --------------------------------------------------------
char *sub_6BF07()
{
  char *result; // eax

  if ( !level[8] )
    Scr_Error("precacheString must be called before any wait statements in the gametype or level script\n");
  result = (char *)Scr_GetIString(0);
  if ( *result )
    result = (char *)G_LocalizedStringIndex(result);
  return result;
}
// 16C04: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0006BF5B) --------------------------------------------------------
int sub_6BF5B()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  float v5; // [esp+0h] [ebp-28h]
  char v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+18h] [ebp-10h]
  _BYTE *v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = 0;
  v7 = Scr_GetNumParam();
  if ( v7 != 1 )
  {
    if ( v7 != 2 )
    {
      v0 = va("USAGE: ambientPlay(alias_name, <fadetime>);\n", v6);
      return Scr_Error(v0);
    }
    v5 = Scr_GetFloat(1) * 1000.0;
    v9 = sub_6F0B9(v5);
  }
  v8 = (_BYTE *)Scr_GetString(0);
  if ( !*v8 )
  {
    v2 = va("ambientPlay: alias name cannot be the empty string... use stop or fade version\n", v6);
    Scr_Error(v2);
  }
  if ( v9 < 0 )
  {
    v3 = va("ambientPlay: fade time must be >= 0\n", v6);
    Scr_Error(v3);
  }
  v4 = va("n\\%s\\t\\%i", (char)v8);
  return trap_SetConfigstring(3, v4);
}
// 6BFCC: variable 'v6' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006C053) --------------------------------------------------------
int sub_6C053()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  v6 = Scr_GetNumParam();
  if ( v6 )
  {
    if ( v6 != 1 )
    {
      v0 = va("USAGE: ambientStop(<fadetime>);\n", v5);
      return Scr_Error(v0);
    }
    v4 = Scr_GetFloat(0) * 1000.0;
    v7 = sub_6F0B9(v4);
  }
  else
  {
    v7 = 0;
  }
  if ( v7 < 0 )
  {
    v2 = va("ambientStop: fade time must be >= 0\n", v5);
    Scr_Error(v2);
  }
  v3 = va("t\\%i", LOBYTE(level[123]) + v7);
  return trap_SetConfigstring(3, v3);
}
// 6C0AE: variable 'v5' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006C110) --------------------------------------------------------
int sub_6C110()
{
  int result; // eax
  char v1[28]; // [esp+20h] [ebp-88h] BYREF
  int v2; // [esp+3Ch] [ebp-6Ch]
  _DWORD *v3; // [esp+5Ch] [ebp-4Ch]
  int v4[4]; // [esp+60h] [ebp-48h] BYREF
  int v5; // [esp+70h] [ebp-38h] BYREF
  int v6; // [esp+74h] [ebp-34h]
  float v7; // [esp+78h] [ebp-30h]
  int v8[4]; // [esp+80h] [ebp-28h] BYREF
  int v9[6]; // [esp+90h] [ebp-18h] BYREF

  Scr_GetVector(0, v9);
  v5 = v9[0];
  v6 = v9[1];
  v7 = *(float *)&v9[2] + 1.0;
  v3 = (_DWORD *)G_TempEntity(&v5, 185);
  v3[55] = 0;
  v8[0] = 0;
  v8[1] = 0;
  v8[2] = 1065353216;
  v3[41] = (unsigned __int8)DirToByte(v8);
  v4[0] = v5;
  v4[1] = v6;
  *(float *)&v4[2] = v7 - 17.0;
  trap_Trace(v1, &v5, vec3_origin, vec3_origin, v4, 1023, 17);
  result = (v2 & 0x1F00000) >> 20;
  v3[34] = result;
  return result;
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006C229) --------------------------------------------------------
_DWORD *sub_6C229()
{
  _DWORD *result; // eax
  char *v1; // [esp+28h] [ebp-30h]
  int v2; // [esp+2Ch] [ebp-2Ch]
  char *v3; // [esp+30h] [ebp-28h]
  float v4; // [esp+34h] [ebp-24h]
  float v5; // [esp+38h] [ebp-20h]
  float v6; // [esp+3Ch] [ebp-1Ch]
  int v7[6]; // [esp+40h] [ebp-18h] BYREF

  v3 = 0;
  v2 = 0;
  Scr_GetVector(0, v7);
  v6 = Scr_GetFloat(1);
  v5 = Scr_GetFloat(2);
  v4 = Scr_GetFloat(3);
  if ( (unsigned int)Scr_GetNumParam() > 4 )
    v3 = (char *)Scr_GetEntity(4);
  if ( (unsigned int)Scr_GetNumParam() > 5 )
    v2 = Scr_GetEntity(5);
  level[2970] = level[2971];
  v1 = v3;
  if ( !v3 )
    v1 = (char *)&dword_D2968 + (_DWORD)g_entities;
  G_RadiusDamage((int)v7, v2, (int)v1, v5, v4, v6, 0, 23);
  result = level;
  level[2970] = 0;
  return result;
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// D2968: using guessed type int dword_D2968;

//----- (0006C348) --------------------------------------------------------
int sub_6C348()
{
  int result; // eax

  result = Scr_GetBool(0);
  level[2971] = result;
  return result;
}
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);

//----- (0006C37A) --------------------------------------------------------
int sub_6C37A()
{
  int v1; // [esp+24h] [ebp-34h]
  float v2; // [esp+28h] [ebp-30h]
  float v3; // [esp+2Ch] [ebp-2Ch]
  char v4[16]; // [esp+30h] [ebp-28h] BYREF
  char v5[12]; // [esp+40h] [ebp-18h] BYREF
  int v6; // [esp+4Ch] [ebp-Ch] BYREF

  v3 = 0.0;
  v2 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 != 1 )
  {
    if ( v1 != 2 )
    {
      v2 = Scr_GetFloat(2);
      if ( v2 < 0.0 || v2 > 1.0 )
        Scr_ParamError(2, "end time must be between 0 and 1");
    }
    v3 = Scr_GetFloat(1);
    if ( v3 < 0.0 || v3 > 1.0 )
      Scr_ParamError(1, "start time must be between 0 and 1");
  }
  Scr_GetAnim(&v6);
  trap_XAnimGetRelDelta(v6, v5, v4, LODWORD(v3), LODWORD(v2));
  return Scr_AddVector(v4);
}
// 16EC4: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18BE4: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006C499) --------------------------------------------------------
int sub_6C499()
{
  float v1; // [esp+0h] [ebp-58h]
  int v2; // [esp+24h] [ebp-34h]
  float v3; // [esp+28h] [ebp-30h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  char v5[16]; // [esp+30h] [ebp-28h] BYREF
  char v6[12]; // [esp+40h] [ebp-18h] BYREF
  int v7; // [esp+4Ch] [ebp-Ch] BYREF

  v4 = 0.0;
  v3 = 1.0;
  v2 = Scr_GetNumParam();
  if ( v2 != 1 )
  {
    if ( v2 != 2 )
    {
      v3 = Scr_GetFloat(2);
      if ( v3 < 0.0 || v3 > 1.0 )
        Scr_ParamError(2, "end time must be between 0 and 1");
    }
    v4 = Scr_GetFloat(1);
    if ( v4 < 0.0 || v4 > 1.0 )
      Scr_ParamError(1, "start time must be between 0 and 1");
  }
  Scr_GetAnim(&v7);
  trap_XAnimGetRelDelta(v7, v6, v5, LODWORD(v4), LODWORD(v3));
  v1 = RotationToYaw(v6);
  return Scr_AddFloat(LODWORD(v1));
}
// 16EC4: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18BE4: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 19024: using guessed type double __cdecl RotationToYaw(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006C5C0) --------------------------------------------------------
int sub_6C5C0()
{
  char *s2; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  s2 = (char *)Scr_GetString(0);
  v2 = G_EffectIndex(s2);
  if ( !v2 && !level[8] )
    Scr_Error(
      "loadFx must be called before any wait statements in the gametype or level script, or on an already loaded effect\n");
  return Scr_AddInt(v2);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006C620) --------------------------------------------------------
int sub_6C620()
{
  char v0; // al
  int v1; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  if ( Scr_GetNumParam() != 2 )
    Scr_Error("USAGE: rewindfx <entity> <time>");
  v3 = (_DWORD *)Scr_GetEntity(0);
  v0 = Scr_GetInt(1);
  v1 = va("F %d", -24 * v0);
  return trap_SendServerCommand(*v3, 0, v1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006C6A2) --------------------------------------------------------
int sub_6C6A2()
{
  int v0; // eax
  int v1; // esi
  int result; // eax
  char dest[1024]; // [esp+10h] [ebp-438h] BYREF
  char v4[16]; // [esp+410h] [ebp-38h] BYREF
  char v5[24]; // [esp+420h] [ebp-28h] BYREF
  int v6; // [esp+438h] [ebp-10h]
  int v7; // [esp+43Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 1 || (unsigned int)Scr_GetNumParam() > 3 )
    Scr_Error("USAGE: playFx <effect id from loadFx> <vector position of effect> <optional forward vector>");
  v6 = Scr_GetInt(0);
  Scr_GetVector(1, v5);
  if ( Scr_GetNumParam() == 3 )
  {
    Scr_GetVector(2, v4);
    if ( VectorNormalize(v4) == 0.0 )
    {
      if ( v6 )
        trap_GetConfigstring(v6 + 917, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v0 = va("playFx called with (0 0 0) forward direction (effect = %s)\n", (char)dest);
      Scr_Error(v0);
    }
    v7 = G_TempEntity(v5, 196);
    *(_DWORD *)(v7 + 164) = (unsigned __int8)v6;
    v1 = v7;
    result = (unsigned __int8)DirToByte(v4);
    *(_DWORD *)(v1 + 220) = (unsigned __int8)result;
  }
  else
  {
    v7 = G_TempEntity(v5, 195);
    result = (unsigned __int8)v6;
    *(_DWORD *)(v7 + 164) = (unsigned __int8)v6;
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006C808) --------------------------------------------------------
int sub_6C808()
{
  int v0; // eax
  int v1; // eax
  char *v2; // eax
  char *s; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( Scr_GetNumParam() != 3 )
    Scr_Error("USAGE: playFxOnTag <effect id from loadFx> <entity> <tag name>");
  v7 = Scr_GetInt(0);
  if ( v7 <= 0 || v7 > 79 )
  {
    v0 = va("effect id %i is invalid\n", v7);
    Scr_ParamError(0, v0);
  }
  v5 = Scr_GetEntity(1);
  if ( !*(_BYTE *)(v5 + 385) )
    Scr_ParamError(1, "cannot play fx on entity with no model");
  s = (char *)Scr_GetString(2);
  if ( strchr(s, 34) )
    Scr_ParamError(2, "cannot use \" characters in tag names\n");
  if ( (int)trap_DObjGetBoneIndex(v5, s) < 0 )
  {
    trap_DObjDumpInfo(v5);
    G_ModelName(*(unsigned __int8 *)(v5 + 385));
    v1 = va("tag '%s' does not exist on entity with model '%s'", (char)s);
    Scr_ParamError(2, v1);
  }
  v2 = (char *)va("%02d%s", v7);
  v6 = G_FindConfigstringIndex(v2, 997, 256, 1, 0);
  return G_AddEvent(v5, 197, v6);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19044: using guessed type _DWORD __cdecl trap_DObjDumpInfo(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006C9A4) --------------------------------------------------------
int sub_6C9A4()
{
  int v0; // eax
  char s[44]; // [esp+10h] [ebp-38h] BYREF
  int v3[3]; // [esp+3Ch] [ebp-Ch]

  v3[0] = Scr_GetInt(0);
  if ( v3[0] > 79 )
  {
    v0 = va("effect id %i is invalid\n", v3[0]);
    Scr_ParamError(0, v0);
  }
  sprintf(s, "%d", v3[0]);
  return trap_Cvar_Set("cg_atmos", s);
}
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006CA27) --------------------------------------------------------
int sub_6CA27()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-54h]
  float v3; // [esp+40h] [ebp-18h] BYREF

  if ( !Scr_GetNumParam() || (unsigned int)Scr_GetNumParam() > 2 )
    Scr_Error("USAGE: SetWind <vector angles> <strength>");
  Scr_GetVector(0, &v3);
  Scr_GetFloat(1);
  v2 = v3;
  v0 = va("%.2f %.2f %.2f %.2f", SLOBYTE(v2));
  return trap_SetConfigstring(12, v0);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006CABE) --------------------------------------------------------
int sub_6CABE()
{
  int v0; // eax
  float v2; // [esp+0h] [ebp-468h]
  int v3; // [esp+1Ch] [ebp-44Ch]
  char dest[1032]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+428h] [ebp-40h]
  float v6; // [esp+42Ch] [ebp-3Ch]
  int v7; // [esp+430h] [ebp-38h] BYREF
  int v8; // [esp+434h] [ebp-34h]
  int v9; // [esp+438h] [ebp-30h]
  char v10[24]; // [esp+440h] [ebp-28h] BYREF
  int v11; // [esp+458h] [ebp-10h]
  int v12; // [esp+45Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 2 || (unsigned int)Scr_GetNumParam() > 5 )
    Scr_Error(
      "USAGE: playLoopedFx <effect id from loadFx> <repeat delay> <vector position of effect> <optional cull distance (0 "
      "= never cull)> <optional forward vector>");
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0.0;
  v11 = Scr_GetInt(0);
  v3 = Scr_GetNumParam();
  if ( v3 == 4 )
    goto LABEL_11;
  if ( v3 == 5 )
  {
    Scr_GetVector(4, &v7);
    if ( VectorNormalize(&v7) == 0.0 )
    {
      if ( v11 )
        trap_GetConfigstring(v11 + 917, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v0 = va("playLoopedFx called with (0 0 0) forward direction (effect = %s)\n", (char)dest);
      Scr_Error(v0);
    }
LABEL_11:
    v6 = Scr_GetFloat(3);
  }
  Scr_GetVector(2, v10);
  v2 = Scr_GetFloat(1) * 1000.0;
  v5 = sub_6F0B9(v2);
  v12 = G_Spawn();
  *(_DWORD *)(v12 + 4) = 10;
  *(_DWORD *)(v12 + 248) |= 8u;
  *(_DWORD *)(v12 + 220) = (unsigned __int8)v11;
  G_SetOrigin(v12, v10);
  *(_DWORD *)(v12 + 92) = v7;
  *(_DWORD *)(v12 + 96) = v8;
  *(_DWORD *)(v12 + 100) = v9;
  *(float *)(v12 + 104) = v6;
  *(float *)(v12 + 108) = (float)v5;
  trap_LinkEntity(v12);
  return Scr_AddEntity(v12);
}
// 167A4: using guessed type int G_Spawn(void);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006CCA8) --------------------------------------------------------
int __cdecl sub_6CCA8(char a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // eax
  double v14; // [esp+4h] [ebp-44h]

  if ( a2 < 0.0 )
  {
    v8 = va("%s: near distance must be >= 0", a1);
    Scr_Error(v8);
  }
  if ( a2 >= (long double)a3 )
  {
    v9 = va("%s: near distance must be less than far distance", a1);
    Scr_Error(v9);
  }
  if ( a5 < 0.0 || a5 > 1.0 || a6 < 0.0 || a6 > 1.0 || a7 < 0.0 || a7 > 1.0 )
  {
    v10 = va("%s: red/green/blue color components must be in the range [0, 1]", a1);
    Scr_Error(v10);
  }
  if ( a8 < 0.0 )
  {
    v11 = va("%s: transition time must be >= 0 seconds", a1);
    Scr_Error(v11);
  }
  v14 = a2;
  v12 = (char *)va("%g %g %g %g %g %g %.0f", SLOBYTE(v14));
  return G_setfog(v12);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0006CE1E) --------------------------------------------------------
int sub_6CE1E()
{
  float v1; // [esp+2Ch] [ebp-1Ch]
  float v2; // [esp+30h] [ebp-18h]
  float v3; // [esp+34h] [ebp-14h]
  float v4; // [esp+38h] [ebp-10h]
  float v5; // [esp+3Ch] [ebp-Ch]
  float v6; // [esp+40h] [ebp-8h]

  if ( Scr_GetNumParam() != 6 )
    Scr_Error("USAGE: setCullFog(near distance, far distance, red, green, blue, transition time);\n");
  v6 = Scr_GetFloat(0);
  v5 = Scr_GetFloat(1);
  v4 = Scr_GetFloat(2);
  v3 = Scr_GetFloat(3);
  v2 = Scr_GetFloat(4);
  v1 = Scr_GetFloat(5);
  return sub_6CCA8(
           (unsigned __int8)&aSetcullfog[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_,
           v6,
           v5,
           1.0,
           v4,
           v3,
           v2,
           v1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0006CEE8) --------------------------------------------------------
int sub_6CEE8()
{
  float v1; // [esp+20h] [ebp-18h]
  float v2; // [esp+24h] [ebp-14h]
  float v3; // [esp+28h] [ebp-10h]
  float v4; // [esp+2Ch] [ebp-Ch]
  float v5; // [esp+30h] [ebp-8h]

  if ( Scr_GetNumParam() != 5 )
    Scr_Error(
      "USAGE: setExpFog(density, red, green, blue, transition time);\n"
      "Density must be greater than 0 and less than 1, and typically less than .001.  For example, .0002 means the fog ge"
      "ts .02%% more dense for every 1 unit of distance (about 1%% thicker every 50 units of distance)\n");
  v5 = Scr_GetFloat(0);
  v4 = Scr_GetFloat(1);
  v3 = Scr_GetFloat(2);
  v2 = Scr_GetFloat(3);
  v1 = Scr_GetFloat(4);
  if ( v5 <= 0.0 || v5 >= 1.0 )
    Scr_Error("setExpFog: distance must be greater than 0 and less than 1");
  return sub_6CCA8(
           (unsigned __int8)&aSetexpfog[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_,
           0.0,
           1.0,
           v5,
           v4,
           v3,
           v2,
           v1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0006CFD6) --------------------------------------------------------
int sub_6CFD6()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && *(_DWORD *)(Scr_GetEntity(0) + 352) )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FC4: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (0006D045) --------------------------------------------------------
int sub_6D045()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetInt(0);
  if ( v1 >= 0 && v1 <= 63 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006D094) --------------------------------------------------------
int sub_6D094()
{
  int v0; // eax
  int result; // eax
  char s[1032]; // [esp+20h] [ebp-418h] BYREF
  int v3; // [esp+428h] [ebp-10h]
  char v4[4]; // [esp+42Ch] [ebp-Ch]

  *(_DWORD *)v4 = *(_DWORD *)Scr_GetEntity(0) + 1;
  trap_GetConfigstring(21, s, 1024);
  v3 = va("%i", v4[0]);
  v0 = Info_ValueForKey(s, (int)"winner");
  result = Q_stricmp(v0, v3);
  if ( result )
  {
    Info_SetValueForKey(s, "winner", v3);
    result = trap_SetConfigstring(21, s);
  }
  return result;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006D16A) --------------------------------------------------------
int sub_6D16A()
{
  char v0; // al
  int v1; // eax
  int result; // eax
  int v3; // eax
  char s[1028]; // [esp+10h] [ebp-418h] BYREF
  int v5; // [esp+414h] [ebp-14h]
  char v6[4]; // [esp+418h] [ebp-10h]
  unsigned __int16 v7; // [esp+41Eh] [ebp-Ah]

  v7 = Scr_GetConstString(0);
  if ( v7 == scr_const[2] )
  {
    *(_DWORD *)v6 = -2;
  }
  else if ( v7 == scr_const[4] )
  {
    *(_DWORD *)v6 = -1;
  }
  else
  {
    if ( v7 != scr_const[146] )
    {
      v0 = SL_ConvertToString(v7);
      v1 = va("Illegal team string '%s'. Must be allies, axis, or none.", v0);
      return Scr_ParamError(0, v1);
    }
    *(_DWORD *)v6 = 0;
  }
  trap_GetConfigstring(21, s, 1024);
  v5 = va("%i", v6[0]);
  v3 = Info_ValueForKey(s, (int)"winner");
  result = Q_stricmp(v3, v5);
  if ( result )
  {
    Info_SetValueForKey(s, "winner", v5);
    result = trap_SetConfigstring(21, s);
  }
  return result;
}
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006D2B3) --------------------------------------------------------
int sub_6D2B3()
{
  int v0; // eax
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  Scr_ConstructMessageString(0, v2, 1024, 3);
  v0 = va("c \"%s\" 2", (char)v2);
  return trap_SendServerCommand(-1, 0, v0);
}
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0006D327) --------------------------------------------------------
int sub_6D327()
{
  int v0; // eax
  char v2[1036]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v3; // [esp+41Ch] [ebp-Ch]

  v3 = (_DWORD *)Scr_GetEntity(0);
  Scr_ConstructMessageString(1, v2, 1024, 3);
  v0 = va("c \"%s\" 2", (char)v2);
  return trap_SendServerCommand(*v3, 0, v0);
}
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0006D3AB) --------------------------------------------------------
int sub_6D3AB()
{
  char v0; // al
  int v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]

  v3 = Scr_GetConstString(0);
  if ( v3 != scr_const[2] && v3 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v3);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  if ( v3 == scr_const[2] )
    result = Scr_AddInt(level[129]);
  else
    result = Scr_AddInt(level[128]);
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006D454) --------------------------------------------------------
_DWORD *sub_6D454()
{
  char v0; // al
  int v1; // eax
  int v2; // eax
  int v3; // eax
  _DWORD *result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  v6 = Scr_GetConstString(0);
  if ( v6 != scr_const[2] && v6 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v6);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  v5 = Scr_GetInt(1);
  if ( v6 == scr_const[2] )
  {
    level[129] = v5;
    v2 = va("%i", level[129]);
    trap_SetConfigstring(6, v2);
  }
  else
  {
    level[128] = v5;
    v3 = va("%i", level[128]);
    trap_SetConfigstring(5, v3);
  }
  result = level;
  level[132] = 1;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006D56D) --------------------------------------------------------
_DWORD *sub_6D56D()
{
  _DWORD *result; // eax
  __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_GetConstString(0);
  if ( v1 == scr_const[148] )
  {
    result = level;
    level[133] = 0;
  }
  else if ( v1 == scr_const[149] )
  {
    result = level;
    level[133] = 1;
  }
  else
  {
    result = (_DWORD *)Scr_Error("Unknown mode");
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006D5ED) --------------------------------------------------------
int sub_6D5ED()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-3Ch]
  char dest[44]; // [esp+20h] [ebp-38h] BYREF
  int i; // [esp+4Ch] [ebp-Ch]

  if ( !level[133] )
    Scr_Error("Only works in [manual_change] mode");
  v1 = 0;
  for ( i = level[0]; ; i += 18228 )
  {
    result = v1;
    if ( v1 >= level[121] )
      break;
    if ( *(_DWORD *)(i + 17696) == 2 )
    {
      if ( strcmp((const char *)(i + 17908), (const char *)(i + 17760)) )
      {
        Q_strncpyz(dest, (char *)(i + 17908), 32);
        Q_strncpyz((char *)(i + 17908), (char *)(i + 17760), 32);
        ClientUserinfoChanged(v1);
      }
    }
    ++v1;
  }
  return result;
}
// 168F4: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0006D6DB) --------------------------------------------------------
int sub_6D6DB()
{
  char v0; // al
  int v1; // eax
  _DWORD *v3; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]

  v7 = Scr_GetConstString(0);
  if ( v7 != scr_const[2] && v7 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v7);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  if ( v7 == scr_const[2] )
    v5 = 2;
  else
    v5 = 1;
  v6 = 0;
  for ( i = 0; i < g_maxclients[3]; ++i )
  {
    v3 = &g_entities[211 * i];
    if ( *((_BYTE *)v3 + 364) && *(_DWORD *)(v3[88] + 17852) == v5 && (int)v3[144] > 0 )
      ++v6;
  }
  return Scr_AddInt(v6);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0006D7E0) --------------------------------------------------------
int GScr_GetNumParts()
{
  int v0; // eax
  int v1; // eax
  int v3; // [esp+10h] [ebp-8h]

  v0 = Scr_GetString(0);
  v3 = trap_XModelGet(v0);
  v1 = trap_XModelNumBones(v3);
  return Scr_AddInt(v1);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18624: using guessed type _DWORD __cdecl trap_XModelNumBones(_DWORD);
// 18714: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006D822) --------------------------------------------------------
int GScr_GetPartName()
{
  int v0; // eax
  int v1; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  unsigned int v4; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v0 = Scr_GetString(0);
  v6 = trap_XModelGet(v0);
  v5 = Scr_GetInt(1);
  v4 = trap_XModelNumBones(v6);
  if ( v5 >= v4 )
  {
    v1 = va("index out of range (0 - %d)", v4 - 1);
    Scr_ParamError(1, v1);
  }
  v3 = *(_WORD *)(trap_XModelGetBoneNames(v6) + 2 * v5);
  if ( !v3 )
    Scr_ParamError(0, "bad model");
  return Scr_AddConstString(v3);
}
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18624: using guessed type _DWORD __cdecl trap_XModelNumBones(_DWORD);
// 18714: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 194F4: using guessed type _DWORD __cdecl trap_XModelGetBoneNames(_DWORD);

//----- (0006D8DD) --------------------------------------------------------
int sub_6D8DD()
{
  int result; // eax
  float v1; // [esp+0h] [ebp-48h]
  float v2; // [esp+1Ch] [ebp-2Ch]
  char v3[20]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+34h] [ebp-14h]
  float v5; // [esp+38h] [ebp-10h]
  float *v6; // [esp+3Ch] [ebp-Ch]

  v5 = Scr_GetFloat(0);
  v1 = Scr_GetFloat(1) * 1000.0;
  v4 = sub_6F0B9(v1);
  Scr_GetVector(2, v3);
  v2 = Scr_GetFloat(3);
  v6 = (float *)G_TempEntity(v3, 201);
  v6[26] = v5;
  v6[28] = (float)v4;
  result = LODWORD(v2);
  v6[27] = v2;
  return result;
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006D976) --------------------------------------------------------
int __cdecl sub_6D976(unsigned int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-428h]
  double v5; // [esp+4h] [ebp-424h]
  char s1[1024]; // [esp+10h] [ebp-418h] BYREF
  char *s2; // [esp+410h] [ebp-18h]
  int v8; // [esp+414h] [ebp-14h]
  int i; // [esp+418h] [ebp-10h]
  _DWORD *v10; // [esp+41Ch] [ebp-Ch]

  v10 = sub_66739(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error("USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  s2 = (char *)Scr_GetString(0);
  for ( i = 1; ; ++i )
  {
    if ( i > 15 )
    {
      v3 = va("shellshock '%s' was not precached\n", (char)s2);
      return Scr_Error(v3);
    }
    trap_GetConfigstring(i + 1253, s1, 1024);
    if ( !strcasecmp(s1, s2) )
      break;
  }
  v4 = Scr_GetFloat(1) * 1000.0;
  v8 = sub_6F0B9(v4);
  if ( v8 < 0 || v8 > 60000 )
  {
    v5 = (long double)v8 * 0.001;
    v1 = va("duration %g should be >= 0 and <= 60", SLOBYTE(v5));
    Scr_ParamError(1, v1);
  }
  *(_DWORD *)(v10[88] + 1580) = i;
  *(_DWORD *)(v10[88] + 1584) = level[123];
  result = v8;
  *(_DWORD *)(v10[88] + 1588) = v8;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16DE4: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006DADF) --------------------------------------------------------
int __cdecl sub_6DADF(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_66739(a1);
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: <player> stopshellshock()\n");
  *(_DWORD *)(v2[88] + 1580) = 0;
  *(_DWORD *)(v2[88] + 1584) = 0;
  result = v2[88];
  *(_DWORD *)(result + 1588) = 0;
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006DB55) --------------------------------------------------------
int __cdecl sub_6DB55(unsigned int a1)
{
  int v1; // esi
  int v2; // eax
  int result; // eax
  double v4; // [esp+4h] [ebp-34h]
  float v5[7]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_66739(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error("USAGE: <player> viewkick <force 0-127> <source position>\n");
  v1 = v6[88];
  *(_DWORD *)(v1 + 18008) = (v6[145] * Scr_GetInt(0) + 50) / 100;
  if ( *(int *)(v6[88] + 18008) < 0 )
  {
    v4 = Scr_GetFloat(0);
    v2 = va("viewkick: damage %g < 0\n", SLOBYTE(v4));
    Scr_Error(v2);
  }
  Scr_GetVector(1, v5);
  *(float *)(v6[88] + 18012) = *(float *)(v6[88] + 20) - v5[0];
  *(float *)(v6[88] + 18016) = *(float *)(v6[88] + 24) - v5[1];
  result = v6[88];
  *(float *)(result + 18020) = *(float *)(result + 28) - v5[2];
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006DC79) --------------------------------------------------------
int __cdecl sub_6DC79(unsigned int a1)
{
  char v2[48]; // [esp+10h] [ebp-68h] BYREF
  float v3; // [esp+40h] [ebp-38h] BYREF
  float v4; // [esp+44h] [ebp-34h]
  float v5; // [esp+48h] [ebp-30h]
  char v6[28]; // [esp+50h] [ebp-28h] BYREF
  float *v7; // [esp+6Ch] [ebp-Ch]

  v7 = (float *)sub_666E7(a1);
  Scr_GetVector(0, v6);
  AnglesToAxis(v7 + 82, v2);
  MatrixTransformVector(v6, v2, &v3);
  v3 = v3 + v7[79];
  v4 = v4 + v7[80];
  v5 = v5 + v7[81];
  return Scr_AddVector(&v3);
}
// 17594: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0006DD1A) --------------------------------------------------------
void __cdecl sub_6DD1A(unsigned int a1)
{
  float v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = sub_666E7(a1)[90];
  if ( !v2 )
    Scr_Error("entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 16) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 16) > 0.0 )
    *(_DWORD *)(v2 + 16) = 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0006DDA0) --------------------------------------------------------
void __cdecl sub_6DDA0(unsigned int a1)
{
  int v1; // [esp+8h] [ebp-10h]

  v1 = sub_666E7(a1)[90];
  if ( !v1 )
    Scr_Error("entity is not a turret");
  *(float *)(v1 + 24) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 24) < 0.0 )
    *(_DWORD *)(v1 + 24) = 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0006DE19) --------------------------------------------------------
void __cdecl sub_6DE19(unsigned int a1)
{
  float v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = sub_666E7(a1)[90];
  if ( !v2 )
    Scr_Error("entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 12) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 12) > 0.0 )
    *(_DWORD *)(v2 + 12) = 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0006DE9F) --------------------------------------------------------
void __cdecl sub_6DE9F(unsigned int a1)
{
  int v1; // [esp+8h] [ebp-10h]

  v1 = sub_666E7(a1)[90];
  if ( !v1 )
    Scr_Error("entity is not a turret");
  *(float *)(v1 + 20) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 20) < 0.0 )
    *(_DWORD *)(v1 + 20) = 0;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0006DF18) --------------------------------------------------------
int __cdecl sub_6DF18(unsigned int a1)
{
  int v2; // [esp+30h] [ebp-68h] BYREF
  int v3; // [esp+34h] [ebp-64h]
  float v4; // [esp+38h] [ebp-60h]
  int v5; // [esp+40h] [ebp-58h] BYREF
  int v6; // [esp+44h] [ebp-54h]
  float v7; // [esp+48h] [ebp-50h]
  char v8[4]; // [esp+50h] [ebp-48h] BYREF
  int v9; // [esp+54h] [ebp-44h] BYREF
  int v10; // [esp+58h] [ebp-40h]
  float v11; // [esp+5Ch] [ebp-3Ch]
  unsigned __int16 v12; // [esp+78h] [ebp-20h]
  char v13; // [esp+7Eh] [ebp-1Ah]
  float *v14; // [esp+8Ch] [ebp-Ch]

  v14 = (float *)sub_666E7(a1);
  v5 = *((_DWORD *)v14 + 79);
  v6 = *((_DWORD *)v14 + 80);
  v7 = v14[81];
  v2 = *((_DWORD *)v14 + 79);
  v3 = *((_DWORD *)v14 + 80);
  v4 = v14[81];
  v4 = v4 + 128.0;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v2, *(_DWORD *)v14, 42008593);
  v5 = v9;
  v6 = v10;
  v7 = v11;
  v2 = v9;
  v3 = v10;
  v4 = v11 - 262144.0;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v2, *(_DWORD *)v14, 42008593);
  *((_DWORD *)v14 + 31) = v12;
  v5 = v9;
  v6 = v10;
  v7 = v11;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v5, *(_DWORD *)v14, 42008593);
  if ( v13 )
    Com_Printf("WARNING: Spawn point entity %i is in solid at (%i, %i, %i)\n", *(_DWORD *)v14);
  return G_SetOrigin(v14, &v9);
}
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006E11C) --------------------------------------------------------
int sub_6E11C()
{
  char v0; // al
  int v1; // eax

  if ( !Scr_GetNumParam() )
    Scr_Error("exec command requires a filename");
  v0 = Scr_GetString(0);
  v1 = va("exec %s\n", v0);
  return trap_SendConsoleCommand(2, v1);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006E179) --------------------------------------------------------
int sub_6E179()
{
  if ( level[2969] )
  {
    if ( level[2969] == 1 )
      Scr_Error("map_restart already called");
    else
      Scr_Error("exitlevel already called");
  }
  level[2969] = 1;
  level[2142] = 0;
  if ( Scr_GetNumParam() )
    level[2142] = Scr_GetInt(0);
  return trap_SendConsoleCommand(2, "map_restart\n");
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006E227) --------------------------------------------------------
int sub_6E227()
{
  if ( level[2969] )
  {
    if ( level[2969] == 1 )
      Scr_Error("map_restart already called");
    else
      Scr_Error("exitlevel already called");
  }
  level[2969] = 2;
  level[2142] = 0;
  if ( Scr_GetNumParam() )
    level[2142] = Scr_GetInt(0);
  return ExitLevel();
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 16FF4: using guessed type int ExitLevel(void);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0006E2C4) --------------------------------------------------------
int __cdecl sub_6E2C4(unsigned int a1)
{
  int result; // eax
  char v2; // al
  int v3; // eax
  int j; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  _DWORD *v6; // [esp+24h] [ebp-14h]
  _DWORD *v7; // [esp+28h] [ebp-10h]

  v7 = sub_666E7(a1);
  if ( !v7[206] )
    Scr_Error("Attempted to spawn duplicate of an entity that didn't save it's spawn details");
  level[1629] = v7[208];
  memcpy(&level[1630], (const void *)v7[209], v7[208]);
  level[1500] = v7[206];
  for ( i = 0; i < level[1500]; ++i )
  {
    for ( j = 0; j <= 1; ++j )
      level[2 * i + 1501 + j] = (char *)&level[1630] + *(_DWORD *)(v7[207] + 4 * (j + 2 * i)) - v7[209];
  }
  v6 = (_DWORD *)G_CallSpawn();
  if ( v6 )
  {
    v6[208] = v7[208];
    v6[209] = v7[209];
    v6[206] = v7[206];
    v6[207] = v7[207];
    result = Scr_AddEntity(v6);
  }
  else
  {
    v2 = SL_ConvertToString(LOWORD(elf_hash_bucket[50]));
    v3 = va("unable to spawn \"%s\" entity", v2);
    result = Scr_Error(v3);
  }
  return result;
}
// BC: using guessed type int elf_hash_bucket[1031];
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 175E4: using guessed type int G_CallSpawn(void);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006E47D) --------------------------------------------------------
int sub_6E47D()
{
  int result; // eax

  result = trap_AddTestClient();
  if ( result )
    result = Scr_AddEntity(result);
  return result;
}
// 171D4: using guessed type int trap_AddTestClient(void);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006E4AE) --------------------------------------------------------
int sub_6E4AE()
{
  size_t v0; // eax
  char *s; // [esp+18h] [ebp-820h]
  int v3; // [esp+1Ch] [ebp-81Ch]
  char v4[1024]; // [esp+20h] [ebp-818h] BYREF
  char v5[1024]; // [esp+420h] [ebp-418h] BYREF
  char *v6; // [esp+820h] [ebp-18h]
  int v7; // [esp+824h] [ebp-14h]
  size_t v8; // [esp+828h] [ebp-10h]
  int v9; // [esp+82Ch] [ebp-Ch]

  v3 = Scr_GetString(0);
  v7 = Scr_GetType(1);
  if ( v7 == 2 )
  {
    Scr_ConstructMessageString(1, v5, 1024, 1);
    s = v5;
    v0 = strlen(v5);
  }
  else
  {
    s = (char *)Scr_GetString(1);
    v0 = strlen(s);
  }
  v8 = v0;
  v6 = v4;
  memset(v4, 0, sizeof(v4));
  v9 = 0;
  while ( v9 <= 0x1FFF && s[v9] )
  {
    *v6 = Q_CleanCharacter(s[v9]);
    if ( *v6 == 34 )
      *v6 = 39;
    ++v9;
    ++v6;
  }
  return trap_Cvar_Register(0, v3, s, 2048);
}
// 17164: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 171A4: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 17234: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 18A84: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006E5EE) --------------------------------------------------------
int sub_6E5EE()
{
  int v0; // eax

  v0 = Scr_GetBool(0);
  return trap_SetArchive(v0);
}
// 17E74: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 18A44: using guessed type _DWORD __cdecl trap_SetArchive(_DWORD);

//----- (0006E61A) --------------------------------------------------------
void Scr_Prof_Begin()
{
  ;
}

//----- (0006E61F) --------------------------------------------------------
void Scr_Prof_End()
{
  ;
}

//----- (0006E624) --------------------------------------------------------
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2)
{
  char *s1; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  s1 = *a1;
  for ( i = 0; i <= 0x77; ++i )
  {
    if ( !strcmp(s1, (&functions)[3 * i]) )
    {
      *a1 = (&functions)[3 * i];
      *a2 = (&functions)[3 * i + 2];
      return (&functions)[3 * i + 1];
    }
  }
  return 0;
}
// ADDE0: using guessed type char *functions;

//----- (0006E6E4) --------------------------------------------------------
int __cdecl sub_6E6E4(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0x37; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_AE380 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_AE380 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_AE384 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// AE380: using guessed type char *off_AE380;
// AE384: using guessed type int (__cdecl *off_AE384)(int);

//----- (0006E75F) --------------------------------------------------------
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+10h] [ebp-8h]

  *a2 = 0;
  v4 = Player_GetMethod(a1);
  if ( v4 )
    return v4;
  v5 = ScriptEnt_GetMethod(a1);
  if ( v5 )
    return v5;
  v6 = ScriptVehicle_GetMethod(a1);
  if ( v6 )
    return v6;
  v7 = HudElem_GetMethod(a1);
  if ( v7 )
    v3 = v7;
  else
    v3 = sub_6E6E4(a1);
  return v3;
}
// 17624: using guessed type _DWORD __cdecl HudElem_GetMethod(_DWORD);
// 18F54: using guessed type _DWORD __cdecl Player_GetMethod(_DWORD);
// 19564: using guessed type _DWORD __cdecl ScriptEnt_GetMethod(_DWORD);
// 19624: using guessed type _DWORD __cdecl ScriptVehicle_GetMethod(_DWORD);

//----- (0006E801) --------------------------------------------------------
int __cdecl Scr_SetOrigin(int a1)
{
  int result; // eax
  char v2[24]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  G_SetOrigin(a1, v2);
  result = a1;
  if ( *(_DWORD *)(a1 + 244) )
    result = trap_LinkEntity(a1);
  return result;
}
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006E855) --------------------------------------------------------
int __cdecl Scr_SetAngles(int a1)
{
  char v2[24]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  return G_SetAngle(a1, v2);
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (0006E892) --------------------------------------------------------
int __cdecl Scr_SetHealth(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( a1[88] )
  {
    a1[144] = v2;
    result = v2;
    *(_DWORD *)(a1[88] + 284) = v2;
  }
  else
  {
    a1[145] = v2;
    result = v2;
    a1[144] = v2;
  }
  return result;
}
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0006E8FD) --------------------------------------------------------
int __cdecl GScr_AddVector(int a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddVector(a1);
  else
    result = Scr_AddUndefined();
  return result;
}
// 17154: using guessed type int Scr_AddUndefined(void);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0006E92D) --------------------------------------------------------
int __cdecl GScr_AddEntity(int a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddEntity(a1);
  else
    result = Scr_AddUndefined();
  return result;
}
// 17154: using guessed type int Scr_AddUndefined(void);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006E95D) --------------------------------------------------------
int Scr_ParseGameTypeList()
{
  _DWORD *v0; // esi
  size_t v1; // eax
  int v2; // eax
  char v3; // al
  char v4; // al
  _BYTE **v5; // esi
  size_t v6; // eax
  int result; // eax
  int v8; // [esp+18h] [ebp-1430h] BYREF
  _BYTE **v9; // [esp+1Ch] [ebp-142Ch]
  char *src; // [esp+20h] [ebp-1428h]
  char *v11; // [esp+24h] [ebp-1424h] BYREF
  size_t v12; // [esp+28h] [ebp-1420h]
  int v13; // [esp+2Ch] [ebp-141Ch]
  int v14; // [esp+30h] [ebp-1418h]
  int v15; // [esp+34h] [ebp-1414h]
  int i; // [esp+38h] [ebp-1410h]
  char *s; // [esp+3Ch] [ebp-140Ch]
  char v18[1024]; // [esp+40h] [ebp-1408h] BYREF
  char v19[4104]; // [esp+440h] [ebp-1008h] BYREF

  v14 = 0;
  memset(&g_scr_data[18], 0, 0x180u);
  v13 = trap_FS_GetFileList("maps/mp/gametypes", "gsc", v19, 4096);
  s = v19;
  for ( i = 0; i < v13; ++i )
  {
    v9 = (_BYTE **)&g_scr_data[6 * v14 + 18];
    v12 = strlen(s);
    if ( *s == 95 )
    {
      s += v12 + 1;
    }
    else
    {
      if ( !Q_stricmp(&s[v12 - 4], ".gsc") )
        s[v12 - 4] = 0;
      if ( v14 == 32 )
      {
        G_Printf("Too many game type scripts found! Only loading the first %i\n", 31);
        break;
      }
      v0 = v9;
      v1 = strlen(s);
      *v0 = trap_Hunk_AllocLowInternal(v1);
      strcpy(*v9, s);
      sub_6F10F(*v9);
      v2 = va("maps/mp/gametypes/%s.txt", (char)s);
      v15 = trap_FS_FOpenFile(v2, &v8, 0);
      if ( v15 > 0 && v15 <= 1023 )
      {
        memset(v18, 0, sizeof(v18));
        trap_FS_Read(v18, v15, v8);
        v11 = v18;
        src = (char *)Com_Parse(&v11);
        v5 = v9;
        v6 = strlen(src);
        v5[1] = (_BYTE *)trap_Hunk_AllocLowInternal(v6);
        strcpy(v9[1], src);
        src = (char *)Com_Parse(&v11);
        v9[2] = (_BYTE *)(src && !Q_stricmp(src, "team"));
      }
      else
      {
        if ( v15 > 0 )
        {
          v4 = va("maps/mp/gametypes/%s.txt", (char)s);
          Com_Printf("WARNING: GameType description file %s is too big to load.\n", v4);
        }
        else
        {
          v3 = va("maps/mp/gametypes/%s.txt", (char)s);
          Com_Printf("WARNING: Could not load GameType description file %s for gametype %s\n", v3);
        }
        v9[1] = *v9;
        v9[2] = 0;
      }
      if ( v15 > 0 )
        trap_FS_FCloseFile(v8);
      ++v14;
      s += v12 + 1;
    }
  }
  result = v14;
  *(_DWORD *)&g_scr_data[16] = v14;
  return result;
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 17434: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 18504: using guessed type _DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 197A4: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);

//----- (0006ED1F) --------------------------------------------------------
int __cdecl Scr_GetGameTypeNameForScript(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < *(_DWORD *)&g_scr_data[16]; ++i )
  {
    if ( !Q_stricmp(*(_DWORD *)&g_scr_data[6 * i + 18], a1) )
      return *(_DWORD *)&g_scr_data[6 * i + 20];
  }
  return 0;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006EDA9) --------------------------------------------------------
_BOOL4 __cdecl Scr_IsValidGameType(int a1)
{
  return Scr_GetGameTypeNameForScript(a1) != 0;
}
// 18BA4: using guessed type _DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD);

//----- (0006EDE3) --------------------------------------------------------
int Scr_LoadGameType()
{
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_ExecThread(*(_DWORD *)&g_scr_data[4], 0);
  return Scr_FreeThread(v1);
}
// 193B4: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (0006EE24) --------------------------------------------------------
int Scr_StartupGameType()
{
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_ExecThread(*(_DWORD *)&g_scr_data[6], 0);
  return Scr_FreeThread(v1);
}
// 193B4: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (0006EE65) --------------------------------------------------------
int __cdecl Scr_PlayerConnect(int a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]

  v2 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[8], 0);
  return Scr_FreeThread(v2);
}
// 182A4: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (0006EEAD) --------------------------------------------------------
int __cdecl Scr_PlayerDisconnect(int a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]

  v2 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[10], 0);
  return Scr_FreeThread(v2);
}
// 182A4: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (0006EEF5) --------------------------------------------------------
int __cdecl Scr_PlayerDamage(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  unsigned __int16 v10; // ax
  int v11; // eax
  unsigned __int16 v13; // [esp+12h] [ebp-6h]

  v10 = G_GetHitLocationString(a10);
  Scr_AddConstString(v10);
  GScr_AddVector(a9);
  GScr_AddVector(a8);
  v11 = BG_GetInfoForWeapon(a7);
  Scr_AddString(*(_DWORD *)(v11 + 4));
  if ( a6 >= 0 && (unsigned int)a6 <= 0x1A )
    Scr_AddString(modNames[a6]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a5);
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v13 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[12], 9);
  return Scr_FreeThread(v13);
}
// 16E04: using guessed type _DWORD __cdecl GScr_AddVector(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17AD4: using guessed type _DWORD __cdecl G_GetHitLocationString(_DWORD);
// 182A4: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 18604: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);
// ACF20: using guessed type char *modNames[27];

//----- (0006EFDD) --------------------------------------------------------
int __cdecl Scr_PlayerKilled(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  unsigned __int16 v8; // ax
  int v9; // eax
  unsigned __int16 v11; // [esp+12h] [ebp-6h]

  v8 = G_GetHitLocationString(a8);
  Scr_AddConstString(v8);
  GScr_AddVector(a7);
  v9 = BG_GetInfoForWeapon(a6);
  Scr_AddString(*(_DWORD *)(v9 + 4));
  if ( a5 >= 0 && (unsigned int)a5 <= 0x1A )
    Scr_AddString(modNames[a5]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v11 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[14], 7);
  return Scr_FreeThread(v11);
}
// 16E04: using guessed type _DWORD __cdecl GScr_AddVector(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17AD4: using guessed type _DWORD __cdecl G_GetHitLocationString(_DWORD);
// 182A4: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 18604: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 19724: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);
// ACF20: using guessed type char *modNames[27];

//----- (0006F0AF) --------------------------------------------------------
int Scr_LoadRead()
{
  return 0;
}

//----- (0006F0B9) --------------------------------------------------------
int __cdecl sub_6F0B9(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (0006F0F7) --------------------------------------------------------
float *__cdecl sub_6F0F7(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0006F10F) --------------------------------------------------------
_BYTE *__cdecl sub_6F10F(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower((char)*a1);
    ++a1;
  }
  return a1;
}

//----- (0006F163) --------------------------------------------------------
void sub_6F163()
{
  ;
}

//----- (0006F168) --------------------------------------------------------
int __cdecl sub_6F168(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8)
{
  float v10; // [esp+20h] [ebp-28h] BYREF
  float v11; // [esp+24h] [ebp-24h]
  float v12; // [esp+28h] [ebp-20h]
  float v13; // [esp+3Ch] [ebp-Ch]

  if ( *(_DWORD *)a1 == 9 && a4 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[123];
    *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    v10 = *(float *)a7 - *(float *)a6;
    v11 = *(float *)(a7 + 4) - *(float *)(a6 + 4);
    v12 = *(float *)(a7 + 8) - *(float *)(a6 + 8);
    v13 = 1000.0 / (long double)*(int *)(a1 + 8);
    *(float *)(a1 + 24) = v10 * v13;
    *(float *)(a1 + 28) = v11 * v13;
    *(float *)(a1 + 32) = v12 * v13;
    *(_DWORD *)a1 = 3;
    return 0;
  }
  if ( (*(_DWORD *)a1 == 9 && a4 <= 0.0 || *(_DWORD *)a1 == 3) && a5 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[123];
    *(_DWORD *)(a1 + 8) = (int)(a5 * 1000.0);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a7;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a7 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a7 + 8);
    v10 = *(float *)a8 - *(float *)a7;
    v11 = *(float *)(a8 + 4) - *(float *)(a7 + 4);
    v12 = *(float *)(a8 + 8) - *(float *)(a7 + 8);
    VectorNormalize(&v10);
    v10 = v10 * a3;
    v11 = v11 * a3;
    v12 = v12 * a3;
    *(float *)(a1 + 24) = v10;
    *(float *)(a1 + 28) = v11;
    *(float *)(a1 + 32) = v12;
    *(_DWORD *)a1 = 10;
    return 0;
  }
  if ( *(_DWORD *)a1 == 5 )
  {
    BG_EvaluateTrajectory(a1, level[123], a1 + 12);
  }
  else
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a8;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a8 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a8 + 8);
  }
  *(_DWORD *)(a1 + 4) = level[123];
  *(_DWORD *)a1 = 0;
  return 1;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0006F418) --------------------------------------------------------
_DWORD *__usercall Reached_ScriptMover@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+2Ch] [ebp-Ch]
  int v4; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 12) )
  {
    if ( *(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 16) <= level[123] )
    {
      v3 = sub_6F168(
             a2 + 12,
             a2 + 316,
             *(float *)(a2 + 496),
             *(float *)(a2 + 632),
             *(float *)(a2 + 644),
             a2 + 436,
             a2 + 448,
             a2 + 460);
      BG_EvaluateTrajectory(a2 + 12, level[123], a2 + 316);
      trap_LinkEntity(a2);
      if ( v3 )
        Scr_Notify(a2, scr_const[43], 0);
    }
  }
  result = (_DWORD *)a2;
  if ( *(_DWORD *)(a2 + 48) )
  {
    result = level;
    if ( *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 52) <= level[123] )
    {
      v4 = sub_6F168(
             a2 + 48,
             a2 + 328,
             *(float *)(a2 + 500),
             *(float *)(a2 + 480),
             *(float *)(a2 + 636),
             a2 + 504,
             a2 + 656,
             a2 + 668);
      BG_EvaluateTrajectory(a2 + 48, level[123], a2 + 328);
      result = (_DWORD *)trap_LinkEntity(a2);
      if ( v4 )
      {
        AngleNormalize180(*(float *)(a2 + 328));
        *(float *)(a2 + 328) = a1;
        AngleNormalize360(*(float *)(a2 + 332));
        *(float *)(a2 + 332) = a1;
        AngleNormalize180(*(float *)(a2 + 336));
        *(float *)(a2 + 336) = a1;
        result = (_DWORD *)Scr_Notify(a2, scr_const[60], 0);
      }
    }
  }
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);

//----- (0006F662) --------------------------------------------------------
int __cdecl sub_6F662(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  float v13; // [esp+20h] [ebp-38h] BYREF
  float v14; // [esp+24h] [ebp-34h]
  float v15; // [esp+28h] [ebp-30h]
  float v16; // [esp+30h] [ebp-28h] BYREF
  float v17; // [esp+34h] [ebp-24h]
  float v18; // [esp+38h] [ebp-20h]
  float v19; // [esp+48h] [ebp-10h]
  float v20; // [esp+4Ch] [ebp-Ch]

  v16 = *(float *)a2 - *(float *)a6;
  v17 = *(float *)(a2 + 4) - *(float *)(a6 + 4);
  v18 = *(float *)(a2 + 8) - *(float *)(a6 + 8);
  if ( *(_DWORD *)a1 )
    BG_EvaluateTrajectory(a1, level[123], a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[123];
    *(_DWORD *)(a1 + 8) = (int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    *(_DWORD *)a12 = *(_DWORD *)a2;
    *(_DWORD *)(a12 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a12 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    v19 = 1000.0 / (long double)*(int *)(a1 + 8);
    *(float *)(a1 + 24) = v16 * v19;
    *(float *)(a1 + 28) = v17 * v19;
    *(float *)(a1 + 32) = v18 * v19;
    *(_DWORD *)a1 = 3;
    result = BG_EvaluateTrajectory(a1, level[123], a6);
  }
  else
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    v20 = sqrt(v16 * v16 + v17 * v17 + v18 * v18);
    *(float *)a7 = (v20 + v20) / (a3 + a3 - a4 - a5);
    VectorNormalize2(&v16, &v13);
    v13 = v13 * *(float *)a7;
    v14 = v14 * *(float *)a7;
    v15 = v15 * *(float *)a7;
    if ( a4 == 0.0 )
    {
      *(_DWORD *)a10 = *(_DWORD *)a6;
      *(_DWORD *)(a10 + 4) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a10 + 8) = *(_DWORD *)(a6 + 8);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = level[123];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a9 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(float *)(a1 + 24) = v13;
        *(float *)(a1 + 28) = v14;
        *(float *)(a1 + 32) = v15;
        *(_DWORD *)a1 = 10;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = level[123];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a8 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        v16 = v13 * *(float *)a8;
        v17 = v14 * *(float *)a8;
        v18 = v15 * *(float *)a8;
        v19 = 1000.0 / (long double)*(int *)(a1 + 8);
        *(float *)(a1 + 24) = v16 * v19;
        *(float *)(a1 + 28) = v17 * v19;
        *(float *)(a1 + 32) = v18 * v19;
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[123];
      *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
      *(float *)(a1 + 24) = v13;
      *(float *)(a1 + 28) = v14;
      *(float *)(a1 + 32) = v15;
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[123] + *(_DWORD *)(a1 + 8), a10);
    }
    *(float *)a11 = v13 * *(float *)a8 + *(float *)a10;
    *(float *)(a11 + 4) = v14 * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 8) = v15 * *(float *)a8 + *(float *)(a10 + 8);
    *(_DWORD *)a12 = *(_DWORD *)a2;
    *(_DWORD *)(a12 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a12 + 8) = *(_DWORD *)(a2 + 8);
    result = BG_EvaluateTrajectory(a1, level[123], a6);
  }
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (0006FB7A) --------------------------------------------------------
int __cdecl sub_6FB7A(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  int v13[2]; // [esp+20h] [ebp-48h] BYREF
  int v14; // [esp+28h] [ebp-40h]
  int v15; // [esp+2Ch] [ebp-3Ch]
  int v16; // [esp+30h] [ebp-38h]
  int v17; // [esp+34h] [ebp-34h]
  int v18; // [esp+38h] [ebp-30h]
  int v19; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]

  if ( *(_DWORD *)a1 )
    BG_EvaluateTrajectory(a1, level[123], a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[123];
    *(_DWORD *)(a1 + 8) = (int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)a1 = 3;
    BG_EvaluateTrajectory(a1, level[123], a6);
    result = BG_EvaluateTrajectory(a1, level[123] + *(_DWORD *)(a1 + 8), a12);
  }
  else
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    *(float *)a7 = sqrt(
                     *(float *)a2 * *(float *)a2
                   + *(float *)(a2 + 4) * *(float *)(a2 + 4)
                   + *(float *)(a2 + 8) * *(float *)(a2 + 8));
    if ( a4 == 0.0 )
    {
      *(_DWORD *)a10 = *(_DWORD *)a6;
      *(_DWORD *)(a10 + 4) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a10 + 8) = *(_DWORD *)(a6 + 8);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = level[123];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a9 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)a1 = 10;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = level[123];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a8 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[123];
      *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[123] + *(_DWORD *)(a1 + 8), a10);
    }
    *(float *)a11 = *(float *)a2 * *(float *)a8 + *(float *)a10;
    *(float *)(a11 + 4) = *(float *)(a2 + 4) * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 8) = *(float *)(a2 + 8) * *(float *)a8 + *(float *)(a10 + 8);
    if ( *(float *)a9 == 0.0 )
    {
      *(_DWORD *)a12 = *(_DWORD *)a11;
      *(_DWORD *)(a12 + 4) = *(_DWORD *)(a11 + 4);
      *(_DWORD *)(a12 + 8) = *(_DWORD *)(a11 + 8);
    }
    else
    {
      v13[0] = 10;
      v13[1] = level[123];
      v14 = (int)(*(float *)a9 * 1000.0);
      v15 = *(_DWORD *)a11;
      v16 = *(_DWORD *)(a11 + 4);
      v17 = *(_DWORD *)(a11 + 8);
      v18 = *(_DWORD *)a2;
      v19 = *(_DWORD *)(a2 + 4);
      v20 = *(_DWORD *)(a2 + 8);
      BG_EvaluateTrajectory(v13, level[123] + v14, a12);
    }
    result = BG_EvaluateTrajectory(a1, level[123], a6);
  }
  return result;
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (000700CA) --------------------------------------------------------
int __cdecl sub_700CA(int a1, int a2, float a3, float a4, float a5)
{
  sub_6F662(a1 + 12, a2, a3, a4, a5, a1 + 316, a1 + 496, a1 + 632, a1 + 644, a1 + 436, a1 + 448, a1 + 460);
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0007016B) --------------------------------------------------------
int __cdecl sub_7016B(int a1, int a2, float a3)
{
  *(_DWORD *)(a1 + 16) = level[123];
  *(_DWORD *)(a1 + 20) = (int)(a3 * 1000.0);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = 5;
  BG_EvaluateTrajectory(a1 + 12, level[123], a1 + 316);
  return trap_LinkEntity(a1);
}
// 16D04: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00070253) --------------------------------------------------------
int __cdecl sub_70253(int a1, int a2, float a3, float a4, float a5)
{
  sub_6F662(a1 + 48, a2, a3, a4, a5, a1 + 328, a1 + 500, a1 + 480, a1 + 636, a1 + 504, a1 + 656, a1 + 668);
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000702F4) --------------------------------------------------------
int __cdecl sub_702F4(int a1, int a2, float a3, float a4, float a5)
{
  sub_6FB7A(a1 + 48, a2, a3, a4, a5, a1 + 328, a1 + 500, a1 + 480, a1 + 636, a1 + 504, a1 + 656, a1 + 668);
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00070395) --------------------------------------------------------
int __cdecl InitScriptMover(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8[7]; // [esp+30h] [ebp-28h] BYREF
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v7 = G_SpawnFloat("light", (int)&off_A4EFC, (int)v9);
  v6 = G_SpawnVector("color", (int)"1 1 1", (int)v8);
  if ( v7 || v6 )
  {
    v5 = (int)(*(float *)v8 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v8[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v8[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(v9[0] / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    a1[32] = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  a1[133] = Reached_ScriptMover;
  a1[62] = 128;
  a1[1] = 8;
  a1[6] = a1[79];
  a1[7] = a1[80];
  a1[8] = a1[81];
  a1[3] = 0;
  a1[15] = a1[82];
  a1[16] = a1[83];
  a1[17] = a1[84];
  a1[12] = 0;
  result = a1[99] | 0x2000;
  a1[99] = result;
  return result;
}
// A4EFC: using guessed type void *off_A4EFC;

//----- (00070570) --------------------------------------------------------
int __cdecl SP_script_brushmodel(int a1)
{
  trap_SetBrushModel(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 288) = 1;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 19214: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (000705B6) --------------------------------------------------------
int __cdecl SP_script_model(int a1)
{
  G_DObjUpdate(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 248) |= 4u;
  *(_DWORD *)(a1 + 288) = 8320;
  return trap_LinkEntity(a1);
}
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19214: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (00070611) --------------------------------------------------------
_DWORD *__cdecl SP_script_origin(_DWORD *a1)
{
  _DWORD *result; // eax

  InitScriptMover(a1);
  a1[72] = 0;
  trap_LinkEntity(a1);
  result = a1;
  if ( a1[32] )
    a1[2] |= 0x80u;
  else
    a1[62] |= 1u;
  return result;
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19214: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (00070681) --------------------------------------------------------
void __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3)
{
  int v3; // [esp+10h] [ebp-8h]

  *a1 = Scr_GetFloat(1);
  if ( *a1 <= 0.0 )
    Scr_ParamError(1, "total time must be positive");
  v3 = Scr_GetNumParam();
  if ( v3 <= 2 )
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a2 = Scr_GetFloat(2);
    if ( *a2 < 0.0 )
      Scr_ParamError(2, "accel time must be nonnegative");
    if ( v3 <= 3 )
    {
      *a3 = 0.0;
    }
    else
    {
      *a3 = Scr_GetFloat(3);
      if ( *a3 < 0.0 )
        Scr_ParamError(3, "decel time must be nonnegative");
    }
  }
  if ( *a2 + *a3 > (long double)*a1 )
    Scr_Error("accel time plus decel time is greater than total time");
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (000707A9) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[5]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+44h] [ebp-14h] BYREF
  float v7; // [esp+48h] [ebp-10h] BYREF
  float v8[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( *((_WORD *)v4 + 194) != scr_const[62]
      && *((_WORD *)v4 + 194) != scr_const[63]
      && *((_WORD *)v4 + 194) != scr_const[64] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[99] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    ScriptEntCmdGetCommandTimes(v8, &v7, &v6);
    result = sub_700CA((int)v4, (int)v5, v8[0], v7, v6);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 178C4: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (000708CD) --------------------------------------------------------
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  int v5[7]; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+3Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( *((_WORD *)v4 + 194) != scr_const[62]
      && *((_WORD *)v4 + 194) != scr_const[63]
      && *((_WORD *)v4 + 194) != scr_const[64] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[99] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    v6 = Scr_GetFloat(1);
    result = sub_7016B((int)v4, (int)v5, v6);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (000709D9) --------------------------------------------------------
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+2Ch] [ebp-2Ch]
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+40h] [ebp-18h] BYREF
  float v8; // [esp+44h] [ebp-14h] BYREF
  float v9; // [esp+48h] [ebp-10h] BYREF
  float v10; // [esp+4Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error(v3);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( *((_WORD *)v5 + 194) != scr_const[62]
      && *((_WORD *)v5 + 194) != scr_const[63]
      && *((_WORD *)v5 + 194) != scr_const[64] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v2);
    }
  }
  result = v5[99] & 4;
  if ( !result )
  {
    v10 = Scr_GetFloat(0);
    ScriptEntCmdGetCommandTimes(&v9, &v8, &v7);
    v6[0] = v5[79];
    v6[1] = v5[80];
    v6[2] = v5[81];
    *(float *)&v6[a2] = *(float *)&v6[a2] + v10;
    result = sub_700CA((int)v5, (int)v6, v9, v8, v7);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 178C4: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00070B31) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveX(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 0);
}
// 18CA4: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00070B5C) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveY(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 1);
}
// 18CA4: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00070B87) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 2);
}
// 18CA4: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00070BB2) --------------------------------------------------------
int __usercall ScriptEntCmd_RotateTo@<eax>(long double a1@<st0>, unsigned int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  int v5; // edi
  int v6; // esi
  _DWORD *v7; // [esp+2Ch] [ebp-4Ch]
  float v8[4]; // [esp+30h] [ebp-48h] BYREF
  float v9[4]; // [esp+40h] [ebp-38h] BYREF
  float v10; // [esp+50h] [ebp-28h] BYREF
  float v11; // [esp+54h] [ebp-24h] BYREF
  float v12; // [esp+58h] [ebp-20h] BYREF
  int i; // [esp+5Ch] [ebp-1Ch]

  if ( a2 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a2);
    Scr_Error(v3);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[211 * a2];
    if ( *((_WORD *)v7 + 194) != scr_const[62]
      && *((_WORD *)v7 + 194) != scr_const[63]
      && *((_WORD *)v7 + 194) != scr_const[64] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a2);
      Scr_Error(v2);
    }
  }
  result = v7[99] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v9);
    ScriptEntCmdGetCommandTimes(&v12, &v11, &v10);
    for ( i = 0; i <= 2; ++i )
    {
      v5 = i;
      v6 = i;
      AngleSubtract(v9[i], *(float *)&v7[i + 82]);
      a1 = a1 + *(float *)&v7[v6 + 82];
      v8[v5] = a1;
    }
    result = sub_70253((int)v7, (int)v8, v12, v11, v10);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 178C4: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (00070D2F) --------------------------------------------------------
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+2Ch] [ebp-2Ch]
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+40h] [ebp-18h] BYREF
  float v8; // [esp+44h] [ebp-14h] BYREF
  float v9; // [esp+48h] [ebp-10h] BYREF
  float v10; // [esp+4Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error(v3);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( *((_WORD *)v5 + 194) != scr_const[62]
      && *((_WORD *)v5 + 194) != scr_const[63]
      && *((_WORD *)v5 + 194) != scr_const[64] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v2);
    }
  }
  result = v5[99] & 4;
  if ( !result )
  {
    v10 = Scr_GetFloat(0);
    ScriptEntCmdGetCommandTimes(&v9, &v8, &v7);
    v6[0] = v5[82];
    v6[1] = v5[83];
    v6[2] = v5[84];
    *(float *)&v6[a2] = *(float *)&v6[a2] + v10;
    result = sub_70253((int)v5, (int)v6, v9, v8, v7);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 178C4: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00070E87) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 0);
}
// 190E4: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00070EB2) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 1);
}
// 190E4: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00070EDD) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 2);
}
// 190E4: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00070F08) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[5]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+44h] [ebp-14h] BYREF
  float v7; // [esp+48h] [ebp-10h] BYREF
  float v8[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[211 * a1];
    if ( *((_WORD *)v4 + 194) != scr_const[62]
      && *((_WORD *)v4 + 194) != scr_const[63]
      && *((_WORD *)v4 + 194) != scr_const[64] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[99] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    ScriptEntCmdGetCommandTimes(v8, &v7, &v6);
    result = sub_702F4((int)v4, (int)v5, v8[0], v7, v6);
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 178C4: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (0007102C) --------------------------------------------------------
int __cdecl ScriptEntCmd_Solid(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // [esp+4h] [ebp-14h]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( *((_WORD *)v5 + 194) != scr_const[62]
      && *((_WORD *)v5 + 194) != scr_const[63]
      && *((_WORD *)v5 + 194) != scr_const[64] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  if ( *((_WORD *)v5 + 194) == scr_const[64] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity\n", v4);
  if ( *((_WORD *)v5 + 194) == scr_const[63] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity\n", v4);
  result = (int)v5;
  v5[72] = 1;
  return result;
}
// 71107: variable 'v4' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00071147) --------------------------------------------------------
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // [esp+4h] [ebp-14h]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( *((_WORD *)v5 + 194) != scr_const[62]
      && *((_WORD *)v5 + 194) != scr_const[63]
      && *((_WORD *)v5 + 194) != scr_const[64] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  if ( *((_WORD *)v5 + 194) == scr_const[64] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity\n", v4);
  if ( *((_WORD *)v5 + 194) == scr_const[63] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity\n", v4);
  result = (int)v5;
  v5[72] = 0;
  return result;
}
// 71222: variable 'v4' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00071262) --------------------------------------------------------
int __cdecl ScriptEnt_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0xB; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_AE540 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_AE540 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_AE544 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// AE540: using guessed type char *off_AE540;
// AE544: using guessed type int (__cdecl *off_AE544)(char);

//----- (000712DD) --------------------------------------------------------
void sub_712DD()
{
  ;
}

//----- (000712E4) --------------------------------------------------------
int __cdecl G_SpawnString(char *s1, int a2, int a3)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !level[1499] )
    *(_DWORD *)a3 = a2;
  for ( i = 0; i < level[1500]; ++i )
  {
    if ( !strcmp(s1, (const char *)level[2 * i + 1501]) )
    {
      *(_DWORD *)a3 = level[2 * i + 1502];
      return 1;
    }
  }
  *(_DWORD *)a3 = a2;
  return 0;
}

//----- (00071387) --------------------------------------------------------
int __cdecl G_SpawnFloat(char *s1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch] BYREF

  v4 = G_SpawnString(s1, a2, (int)&nptr);
  *(float *)a3 = atof(nptr);
  return v4;
}

//----- (000713D0) --------------------------------------------------------
int __cdecl G_SpawnInt(char *s1, int a2, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  char *nptr; // [esp+10h] [ebp-8h] BYREF

  v4 = G_SpawnString(s1, a2, (int)&nptr);
  *(_DWORD *)a3 = atoi(nptr);
  return v4;
}

//----- (00071419) --------------------------------------------------------
int __cdecl G_SpawnVector(char *s1, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h] BYREF

  v4 = G_SpawnString(s1, a2, (int)&s);
  sscanf(s, "%f %f %f", a3, a3 + 4, a3 + 8);
  return v4;
}

//----- (00071480) --------------------------------------------------------
int sub_71480()
{
  return Scr_Error("Tried to set a read only entity field");
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (000714A6) --------------------------------------------------------
int __cdecl sub_714A6(int a1, int a2)
{
  char *v2; // eax
  char v4; // [esp+8h] [ebp-20h]
  char v5[4]; // [esp+20h] [ebp-8h] BYREF

  if ( level[1499] )
  {
    G_SpawnString("classname", (int)&unk_A5487, (int)v5);
    v4 = dword_D1C44;
    v2 = (char *)va(byte_A54A0, v5[0]);
    Com_Error(1, v2, v4);
  }
  return Scr_ObjectError(a2);
}
// 181C4: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// D1C44: using guessed type int dword_D1C44;
// D1C48: using guessed type int dword_D1C48;

//----- (00071537) --------------------------------------------------------
int __cdecl sub_71537(int a1, char *nptr, int a3)
{
  int result; // eax
  int v4; // eax
  float v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  int v7; // [esp+20h] [ebp-8h] BYREF

  result = Scr_FindField(a1, &v7);
  v6 = result;
  if ( (_WORD)result )
  {
    result = v7;
    if ( v7 == 4 )
    {
      v5 = atof(nptr);
      Scr_AddFloat(LODWORD(v5));
      return GScr_SetDynamicEntityField(a3, v6);
    }
    if ( v7 <= 4 )
    {
      if ( v7 != 1 )
        return result;
      Scr_AddString(nptr);
      return GScr_SetDynamicEntityField(a3, v6);
    }
    if ( v7 == 5 )
    {
      v4 = atoi(nptr);
      Scr_AddInt(v4);
      return GScr_SetDynamicEntityField(a3, v6);
    }
  }
  return result;
}
// 174F4: using guessed type _DWORD __cdecl GScr_SetDynamicEntityField(_DWORD, _DWORD);
// 17684: using guessed type _DWORD __cdecl Scr_FindField(_DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (000715DE) --------------------------------------------------------
void __cdecl sub_715DE(int a1, char *s, int a3)
{
  float *v3; // esi
  int v4; // [esp+30h] [ebp-28h] BYREF
  int v5; // [esp+34h] [ebp-24h] BYREF
  int v6; // [esp+38h] [ebp-20h] BYREF
  int v7; // [esp+48h] [ebp-10h]
  char **i; // [esp+4Ch] [ebp-Ch]

  dword_D1C44 = a1;
  dword_D1C48 = (int)s;
  for ( i = &off_AE5A0; ; i += 4 )
  {
    if ( !*i )
    {
      sub_71537(a1, s, a3);
      return;
    }
    if ( !Q_stricmp(*i, a1) )
      break;
  }
  v7 = a3;
  switch ( (unsigned int)i[2] )
  {
    case 0u:
      *(_DWORD *)&i[1][v7] = atoi(s);
      break;
    case 3u:
      v3 = (float *)&i[1][v7];
      *v3 = atof(s);
      break;
    case 5u:
      Scr_SetString(&i[1][v7], 0);
      *(_WORD *)&i[1][v7] = G_NewString(s);
      break;
    case 6u:
      sscanf(s, "%f %f %f", &v4, &v5, &v6);
      *(_DWORD *)&i[1][v7] = v4;
      *(_DWORD *)&i[1][v7 + 4] = v5;
      *(_DWORD *)&i[1][v7 + 8] = v6;
      break;
    case 0xBu:
      if ( *s == 42 )
        *(_DWORD *)(a3 + 140) = (unsigned __int16)atoi(s + 1);
      else
        *(_BYTE *)(a3 + 385) = G_ModelIndex(s);
      break;
    default:
      return;
  }
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;
// D1C44: using guessed type int dword_D1C44;
// D1C48: using guessed type int dword_D1C48;

//----- (000717A5) --------------------------------------------------------
int __cdecl sub_717A5(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < level[1500]; ++i )
    sub_715DE(level[2 * i + 1501], (char *)level[2 * i + 1502], a1);
  G_SetOrigin(a1, a1 + 316);
  return G_SetAngle(a1, a1 + 328);
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0007183F) --------------------------------------------------------
char **__cdecl G_DuplicateEntityFields(int a1, int a2)
{
  char **result; // eax
  char **i; // [esp+20h] [ebp-8h]

  for ( i = &off_AE5A0; ; i += 4 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 3u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 5u:
        Scr_SetString(&i[1][a1], *(unsigned __int16 *)&i[1][a2]);
        break;
      case 6u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        *(_DWORD *)&i[1][a1 + 4] = *(_DWORD *)&i[1][a2 + 4];
        *(_DWORD *)&i[1][a1 + 8] = *(_DWORD *)&i[1][a2 + 8];
        break;
      case 0xBu:
        i[1][a1] = i[1][a2];
        break;
      default:
        continue;
    }
  }
  return result;
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00071970) --------------------------------------------------------
int __cdecl G_DuplicateScriptFields(_DWORD *a1, _DWORD *a2)
{
  return Scr_CopyEntityNum(*a2, *a1, 0);
}
// 19634: using guessed type _DWORD __cdecl Scr_CopyEntityNum(_DWORD, _DWORD, _DWORD);

//----- (000719A6) --------------------------------------------------------
int G_CallSpawn()
{
  char v1; // [esp+4h] [ebp-24h]
  int v2; // [esp+10h] [ebp-18h]
  char *s2; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+18h] [ebp-10h]
  const char **i; // [esp+1Ch] [ebp-Ch]
  char **j; // [esp+20h] [ebp-8h]

  G_SpawnString("classname", (int)&unk_A5487, (int)&s2);
  if ( s2 )
  {
    if ( !strcmp("info_vehicle_node", s2) )
    {
      SP_info_vehicle_node(0);
      v2 = 0;
    }
    else if ( !strcmp("info_vehicle_node_rotate", s2) )
    {
      SP_info_vehicle_node(1);
      v2 = 0;
    }
    else
    {
      for ( i = (const char **)&bg_itemlist[12]; *i; i += 12 )
      {
        if ( !strcmp(*i, s2) )
        {
          v4 = G_Spawn();
          sub_717A5(v4);
          G_SpawnItem(v4, i);
          return v4;
        }
      }
      for ( j = &spawns; *j; j += 2 )
      {
        if ( !strcmp(*j, s2) )
        {
          v4 = G_Spawn();
          sub_717A5(v4);
          ((void (__cdecl *)(int))j[1])(v4);
          return v4;
        }
      }
      v4 = G_Spawn();
      sub_717A5(v4);
      v2 = v4;
    }
  }
  else
  {
    G_Printf("G_CallSpawn: NULL classname\n", v1);
    v2 = 0;
  }
  return v2;
}
// 719E6: variable 'v1' is possibly undefined
// 167A4: using guessed type int G_Spawn(void);
// 17894: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 17BF4: using guessed type _DWORD __cdecl SP_info_vehicle_node(_DWORD);
// AE800: using guessed type char *spawns;

//----- (00071B3A) --------------------------------------------------------
int __cdecl G_CallSpawnEntity(int a1)
{
  char v1; // al
  char v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+14h] [ebp-14h]
  char *s2; // [esp+18h] [ebp-10h]
  const char **i; // [esp+1Ch] [ebp-Ch]
  char **j; // [esp+20h] [ebp-8h]

  if ( *(_WORD *)(a1 + 388) )
  {
    s2 = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 388));
    for ( i = (const char **)&bg_itemlist[12]; *i; i += 12 )
    {
      if ( !strcmp(*i, s2) )
      {
        G_SpawnItem(a1, i);
        return 1;
      }
    }
    for ( j = &spawns; *j; j += 2 )
    {
      if ( !strcmp(*j, s2) )
      {
        ((void (__cdecl *)(int))j[1])(a1);
        return 1;
      }
    }
    v1 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 388));
    G_Printf("%s doesn't have a spawn function\n", v1);
    v4 = 0;
  }
  else
  {
    G_Printf("G_CallSpawnEntity: NULL classname\n", v3);
    v4 = 0;
  }
  return v4;
}
// 71B62: variable 'v3' is possibly undefined
// 17894: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// AE800: using guessed type char *spawns;

//----- (00071C57) --------------------------------------------------------
int __cdecl G_NewString(char *s)
{
  size_t v2; // [esp+14h] [ebp-10014h]
  signed int i; // [esp+18h] [ebp-10010h]
  char *v4; // [esp+1Ch] [ebp-1000Ch]
  char v5[65544]; // [esp+20h] [ebp-10008h] BYREF

  v2 = strlen(s) + 1;
  if ( v2 > 0x10000 )
    G_Error("G_NewString: len = %i > %i\n", v2);
  v4 = v5;
  for ( i = 0; i < (int)v2; ++i )
  {
    if ( s[i] == 92 && i < (int)(v2 - 1) )
    {
      if ( s[++i] == 110 )
        *v4 = 10;
      else
        *v4 = 92;
      ++v4;
    }
    else
    {
      *v4++ = s[i];
    }
  }
  return (unsigned __int16)SL_GetString(v5, 0);
}
// 17814: using guessed type _DWORD __cdecl SL_GetString(_DWORD, _DWORD);

//----- (00071D79) --------------------------------------------------------
int GScr_AddFieldsForEntity()
{
  unsigned __int16 v1; // [esp+1Eh] [ebp-Ah]
  char **i; // [esp+20h] [ebp-8h]

  v1 = g_scr_data[210];
  for ( i = &off_AE5A0; *i; i += 4 )
  {
    switch ( (unsigned int)i[2] )
    {
      case 0u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 0xAu:
      case 0xBu:
        Scr_AddClassField(
          v1,
          *i,
          (unsigned __int16)(((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_AE5A0 - 183814))) >> 4));
        break;
      default:
        continue;
    }
  }
  return GScr_AddFieldsForClient(v1);
}
// 18404: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// 18AA4: using guessed type _DWORD __cdecl GScr_AddFieldsForClient(_DWORD);
// AE5A0: using guessed type char *off_AE5A0;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00071E16) --------------------------------------------------------
int GScr_AddFieldsForRadiant()
{
  return Scr_AddFields("radiant", ".txt");
}
// 167E4: using guessed type _DWORD __cdecl Scr_AddFields(_DWORD, _DWORD);

//----- (00071E46) --------------------------------------------------------
int __cdecl Scr_SetEntityField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  char **v4; // [esp+10h] [ebp-8h]

  v3 = &g_entities[211 * a1];
  if ( (a2 & 0xC000) == 49152 )
  {
    if ( !v3[88] )
      sub_714A6((int)v3, (int)"field must be applied to a player");
    result = Scr_SetClientField(v3[88], a2 & 0xFFFF3FFF);
  }
  else
  {
    v4 = &(&off_AE5A0)[4 * a2];
    if ( v4[3] )
      result = ((int (__cdecl *)(_DWORD *, int))v4[3])(v3, a2);
    else
      result = Scr_SetGenericField(v3, v4[2], v4[1]);
  }
  return result;
}
// 189C4: using guessed type _DWORD __cdecl Scr_SetClientField(_DWORD, _DWORD);
// 189E4: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00071F15) --------------------------------------------------------
int __cdecl Scr_SetGenericField(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  long double v5; // fst7
  int v6; // [esp+10h] [ebp-18h] BYREF
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_GetInt(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 3:
      v5 = Scr_GetFloat(0);
      result = a1 + a3;
      *(float *)(a1 + a3) = v5;
      break;
    case 5:
      v4 = Scr_GetConstString(0);
      result = Scr_SetString(a1 + a3, v4);
      break;
    case 6:
      Scr_GetVector(0, &v6);
      *(_DWORD *)(a3 + a1) = v6;
      *(_DWORD *)(a1 + a3 + 4) = v7;
      result = v8;
      *(_DWORD *)(a1 + a3 + 8) = v8;
      break;
    case 7:
      result = Scr_GetEntity(0);
      *(_DWORD *)(a3 + a1) = result;
      break;
    case 9:
      Scr_GetVector(0, &v6);
      result = v7;
      *(_DWORD *)(a3 + a1) = v7;
      break;
    default:
      return result;
  }
  return result;
}
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17FB4: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00072012) --------------------------------------------------------
int __cdecl Scr_SetObjectField(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  char v5; // [esp+4h] [ebp-14h]

  result = a1;
  switch ( a1 )
  {
    case 1:
      return Scr_SetHudElemField(a2, a3);
    case 0:
      return Scr_SetEntityField(a2, a3);
    case 2:
      v4 = va("vehicle node is read-only\n", v5);
      result = Scr_Error(v4);
      break;
  }
  return result;
}
// 7206F: variable 'v5' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F04: using guessed type _DWORD __cdecl Scr_SetEntityField(_DWORD, _DWORD);
// 18B04: using guessed type _DWORD __cdecl Scr_SetHudElemField(_DWORD, _DWORD);

//----- (00072082) --------------------------------------------------------
int __cdecl Scr_GetEntityField(int a1, int a2)
{
  _DWORD *v3; // [esp+Ch] [ebp-Ch]

  v3 = &g_entities[211 * a1];
  if ( (a2 & 0xC000) != 49152 )
    return Scr_GetGenericField(v3, (&off_AE5A0)[4 * a2 + 2], (&off_AE5A0)[4 * a2 + 1]);
  if ( !v3[88] )
    sub_714A6((int)v3, (int)"field must be applied to a player");
  return Scr_GetClientField(v3[88], a2 & 0xFFFF3FFF);
}
// 18314: using guessed type _DWORD __cdecl Scr_GetClientField(_DWORD, _DWORD);
// 187F4: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00072131) --------------------------------------------------------
int __cdecl Scr_GetGenericField(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  unsigned __int16 v5; // [esp+1Eh] [ebp-2Ah]
  int v6[6]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v7; // [esp+3Ah] [ebp-Eh]
  int v8; // [esp+3Ch] [ebp-Ch]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_AddInt(*(_DWORD *)(a1 + a3));
      break;
    case 3:
      result = Scr_AddFloat(*(_DWORD *)(a1 + a3));
      break;
    case 4:
      v8 = a1 + a3;
      result = Scr_AddString(a1 + a3);
      break;
    case 5:
      result = *(unsigned __int16 *)(a1 + a3);
      v7 = *(_WORD *)(a1 + a3);
      if ( v7 )
        result = Scr_AddConstString(v7);
      break;
    case 6:
      result = Scr_AddVector(a1 + a3);
      break;
    case 7:
      result = a1 + a3;
      if ( *(_DWORD *)(a1 + a3) )
        result = Scr_AddEntity(*(_DWORD *)(a1 + a3));
      break;
    case 9:
      v6[0] = 0;
      v6[1] = *(_DWORD *)(a1 + a3);
      v6[2] = 0;
      result = Scr_AddVector(v6);
      break;
    case 10:
      result = *(unsigned __int16 *)(a1 + a3);
      v5 = *(_WORD *)(a1 + a3);
      if ( v5 )
        result = Scr_AddObject(v5);
      break;
    case 11:
      v4 = G_ModelName(*(unsigned __int8 *)(a1 + a3));
      result = Scr_AddString(v4);
      break;
    default:
      return result;
  }
  return result;
}
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17484: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19384: using guessed type _DWORD __cdecl Scr_AddObject(_DWORD);

//----- (0007225E) --------------------------------------------------------
int __cdecl Scr_GetObjectField(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  switch ( a1 )
  {
    case 1:
      return Scr_GetHudElemField(a2, a3);
    case 0:
      return Scr_GetEntityField(a2, a3);
    case 2:
      result = GScr_GetVehicleNodeField(a2, a3);
      break;
  }
  return result;
}
// 16DC4: using guessed type _DWORD __cdecl Scr_GetEntityField(_DWORD, _DWORD);
// 189B4: using guessed type _DWORD __cdecl GScr_GetVehicleNodeField(_DWORD, _DWORD);
// 18EE4: using guessed type _DWORD __cdecl Scr_GetHudElemField(_DWORD, _DWORD);

//----- (000722CA) --------------------------------------------------------
int *__cdecl Scr_FreeEntityConstStrings(int a1)
{
  int *result; // eax
  int v2[2]; // [esp+8h] [ebp-10h] BYREF
  char **i; // [esp+10h] [ebp-8h]

  for ( i = &off_AE5A0; ; i += 4 )
  {
    result = (int *)i;
    if ( !*i )
      break;
    if ( i[2] == &byte_5 )
    {
      v2[1] = a1;
      Scr_SetString(&i[1][a1], 0);
    }
  }
  for ( v2[0] = 0; v2[0] <= 5; ++v2[0] )
  {
    *(_BYTE *)(v2[0] + a1 + 764) = 0;
    Scr_SetString(a1 + 2 * v2[0] + 770, 0);
    result = v2;
  }
  return result;
}
// 5: using guessed type char byte_5;
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00072367) --------------------------------------------------------
int __cdecl Scr_FreeEntity(_DWORD *a1)
{
  Scr_FreeEntityConstStrings(a1);
  return Scr_FreeEntityNum(*a1, 0);
}
// 16A24: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 18764: using guessed type _DWORD __cdecl Scr_FreeEntityConstStrings(_DWORD);

//----- (0007239F) --------------------------------------------------------
int __cdecl Scr_AddEntity(_DWORD *a1)
{
  return Scr_AddEntityNum(*a1, 0);
}
// 17F24: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);

//----- (000723CC) --------------------------------------------------------
_DWORD *__cdecl Scr_GetEntity(int a1)
{
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetEntityNum(a1, &v3);
  if ( !v3 && v4 <= 0x3FF )
    return &g_entities[211 * v4];
  Scr_ParamError(a1, "not an entity");
  return 0;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19664: using guessed type _DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD);

//----- (00072440) --------------------------------------------------------
int __cdecl Scr_FreeHudElem(int a1)
{
  Scr_FreeHudElemConstStrings(a1);
  return Scr_FreeEntityNum(-252645135 * ((a1 - (int)g_hudelems) >> 3), 1);
}
// 16A24: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 17094: using guessed type _DWORD __cdecl Scr_FreeHudElemConstStrings(_DWORD);

//----- (00072487) --------------------------------------------------------
int __cdecl Scr_AddHudElem(int a1)
{
  return Scr_AddEntityNum(-252645135 * ((a1 - (int)g_hudelems) >> 3), 1);
}
// 17F24: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);

//----- (000724C3) --------------------------------------------------------
_DWORD *__cdecl Scr_GetHudElem(int a1)
{
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetEntityNum(a1, &v3);
  if ( v3 == 1 && v4 <= 0x7FF )
    return &g_hudelems[34 * v4];
  Scr_ParamError(a1, "not a hudelem");
  return 0;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19664: using guessed type _DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD);

//----- (0007253D) --------------------------------------------------------
int __cdecl Scr_ExecEntThread(_DWORD *a1, int a2, int a3)
{
  return (unsigned __int16)Scr_ExecEntThreadNum(*a1, 0, a2, a3);
}
// 198F4: using guessed type _DWORD __cdecl Scr_ExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007257B) --------------------------------------------------------
int __cdecl Scr_AddExecEntThread(_DWORD *a1, int a2, int a3)
{
  return Scr_AddExecEntThreadNum(*a1, 0, a2, a3);
}
// 18F84: using guessed type _DWORD __cdecl Scr_AddExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000725B6) --------------------------------------------------------
int __cdecl Scr_Notify(_DWORD *a1, unsigned __int16 a2, int a3)
{
  return Scr_NotifyNum(*a1, 0, a2, a3);
}
// 17B04: using guessed type _DWORD __cdecl Scr_NotifyNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000725F9) --------------------------------------------------------
int Scr_GetEnt()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-24h]
  _DWORD *v2; // [esp+18h] [ebp-20h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  __int16 v4; // [esp+20h] [ebp-18h]
  __int16 v5; // [esp+22h] [ebp-16h]
  int v6; // [esp+24h] [ebp-14h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]

  v4 = Scr_GetConstString(0);
  v6 = Scr_GetString(1);
  result = Scr_GetOffset((unsigned __int16)g_scr_data[210], v6);
  v3 = result;
  if ( result >= 0 )
  {
    result = (int)&(&off_AE5A0)[4 * result];
    if ( *(_DWORD *)(result + 8) == 5 )
    {
      v2 = 0;
      v1 = 0;
      for ( i = g_entities; ; i += 211 )
      {
        result = v1;
        if ( v1 >= level[3] )
          break;
        if ( *((_BYTE *)i + 364) )
        {
          v5 = *(_WORD *)&(&off_AE5A0)[4 * v3 + 1][(_DWORD)i];
          if ( v5 )
          {
            if ( v5 == v4 )
            {
              if ( v2 )
                Scr_Error("getent used with more than one entity");
              v2 = i;
            }
          }
        }
        ++v1;
      }
      if ( v2 )
        result = Scr_AddEntity(v2);
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19454: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00072716) --------------------------------------------------------
int Scr_GetEntArray()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-20h]
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  __int16 v4; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+12h] [ebp-16h]
  int v6; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+1Ch] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-Ch]

  if ( Scr_GetNumParam() )
  {
    v4 = Scr_GetConstString(0);
    v6 = Scr_GetString(1);
    result = Scr_GetOffset((unsigned __int16)g_scr_data[210], v6);
    v3 = result;
    if ( result >= 0 )
    {
      result = (int)&(&off_AE5A0)[4 * result];
      if ( *(_DWORD *)(result + 8) == 5 )
      {
        Scr_MakeArray();
        v2 = 0;
        for ( i = g_entities; ; i += 211 )
        {
          result = v2;
          if ( v2 >= level[3] )
            break;
          if ( *((_BYTE *)i + 364) )
          {
            v5 = *(_WORD *)&(&off_AE5A0)[4 * v3 + 1][(_DWORD)i];
            if ( v5 )
            {
              if ( v5 == v4 )
              {
                Scr_AddEntity(i);
                Scr_AddArray();
              }
            }
          }
          ++v2;
        }
      }
    }
  }
  else
  {
    Scr_MakeArray();
    v1 = 0;
    for ( j = g_entities; ; j += 211 )
    {
      result = v1;
      if ( v1 >= level[3] )
        break;
      if ( *((_BYTE *)j + 364) )
      {
        Scr_AddEntity(j);
        Scr_AddArray();
      }
      ++v1;
    }
  }
  return result;
}
// 177B4: using guessed type int Scr_AddArray(void);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19454: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// 19504: using guessed type int Scr_MakeArray(void);
// AE5A0: using guessed type char *off_AE5A0;

//----- (00072872) --------------------------------------------------------
int __cdecl GScr_SetDynamicEntityField(_DWORD *a1, unsigned __int16 a2)
{
  return Scr_SetDynamicEntityField(*a1, 0, a2);
}
// 180D4: using guessed type _DWORD __cdecl Scr_SetDynamicEntityField(_DWORD, _DWORD, _DWORD);

//----- (000728AE) --------------------------------------------------------
int G_SpawnGEntityFromSpawnVars()
{
  return G_CallSpawn();
}
// 175E4: using guessed type int G_CallSpawn(void);

//----- (000728CB) --------------------------------------------------------
char *__cdecl G_AddSpawnVarToken(char *s)
{
  char v2; // [esp+4h] [ebp-14h]
  char *dest; // [esp+Ch] [ebp-Ch]
  size_t v4; // [esp+10h] [ebp-8h]

  v4 = strlen(s);
  if ( (int)(level[1629] + v4 + 1) > 2048 )
    G_Error("G_AddSpawnVarToken: MAX_SPAWN_VARS", v2);
  dest = (char *)&level[1630] + level[1629];
  memcpy(dest, s, v4 + 1);
  level[1629] += v4 + 1;
  return dest;
}
// 7290B: variable 'v2' is possibly undefined

//----- (0007296A) --------------------------------------------------------
int G_ParseSpawnVars()
{
  int v0; // esi
  int v1; // esi
  char v3; // [esp+4h] [ebp-834h]
  char v4; // [esp+4h] [ebp-834h]
  char v6[1024]; // [esp+20h] [ebp-818h] BYREF
  char s[1048]; // [esp+420h] [ebp-418h] BYREF

  level[1500] = 0;
  level[1629] = 0;
  if ( !trap_GetEntityToken(v6, 1024) )
    return 0;
  if ( v6[0] != 123 )
    G_Error("G_ParseSpawnVars: found %s when expecting {", (char)v6);
  while ( 1 )
  {
    if ( !trap_GetEntityToken(s, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace", v3);
    if ( s[0] == 125 )
      break;
    if ( !trap_GetEntityToken(v6, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace", v4);
    if ( v6[0] == 125 )
      G_Error("G_ParseSpawnVars: closing brace without data", v4);
    if ( level[1500] == 64 )
      G_Error("G_ParseSpawnVars: MAX_SPAWN_VARS", v4);
    v0 = level[1500];
    level[2 * v0 + 1501] = G_AddSpawnVarToken(s);
    v1 = level[1500];
    level[2 * v1 + 1502] = G_AddSpawnVarToken(v6);
    ++level[1500];
  }
  return 1;
}
// 72A0F: variable 'v3' is possibly undefined
// 72A45: variable 'v4' is possibly undefined
// 17184: using guessed type _DWORD __cdecl trap_GetEntityToken(_DWORD, _DWORD);

//----- (00072AF8) --------------------------------------------------------
_DWORD *SP_worldspawn()
{
  int v0; // eax
  int v1; // eax
  _DWORD *result; // eax
  char v3; // [esp+4h] [ebp-14h]
  char *nptr[3]; // [esp+Ch] [ebp-Ch] BYREF

  G_SpawnString("classname", (int)&unk_A5487, (int)nptr);
  if ( Q_stricmp(nptr[0], "worldspawn") )
    G_Error("SP_worldspawn: The first entity isn't 'worldspawn'", v3);
  trap_SetConfigstring(2, "cod");
  v0 = va("%i", level[126]);
  trap_SetConfigstring(14, v0);
  G_SpawnString("ambienttrack", (int)&unk_A5487, (int)nptr);
  if ( *nptr[0] )
  {
    v1 = va("n\\%s", (char)nptr[0]);
    trap_SetConfigstring(3, v1);
  }
  else
  {
    trap_SetConfigstring(3, &unk_A5487);
  }
  G_SpawnString("message", (int)&unk_A5487, (int)nptr);
  trap_SetConfigstring(4, nptr[0]);
  trap_SetConfigstring(15, (char *)&g_motd + 16);
  G_SpawnString("gravity", (int)&off_A58CC, (int)nptr);
  trap_Cvar_Set("g_gravity", nptr[0]);
  G_SpawnString("northyaw", (int)&unk_A5487, (int)nptr);
  if ( *nptr[0] )
    trap_SetConfigstring(11, nptr[0]);
  else
    trap_SetConfigstring(11, "0");
  G_SpawnString("spawnflags", (int)"0", (int)nptr);
  *(int *)((char *)&dword_D2AF0 + (_DWORD)g_entities) = atoi(nptr[0]);
  *(int *)((char *)&dword_D2AC4 + (_DWORD)g_entities) = *(int *)((char *)&dword_D2AF0 + (_DWORD)g_entities);
  *(int *)((char *)&dword_D2968 + (_DWORD)g_entities) = 1022;
  Scr_SetString((char *)&unk_D2AEC + (_DWORD)g_entities, scr_const[100]);
  result = g_entities;
  byte_D2AD4[(_DWORD)g_entities] = 1;
  return result;
}
// 72B4C: variable 'v3' is possibly undefined
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// A58CC: using guessed type void *off_A58CC;
// D2968: using guessed type int dword_D2968;
// D2AC4: using guessed type int dword_D2AC4;
// D2AF0: using guessed type int dword_D2AF0;

//----- (00072D61) --------------------------------------------------------
_DWORD *G_SpawnEntitiesFromString()
{
  _DWORD *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  level[1499] = 1;
  level[1500] = 0;
  if ( !G_ParseSpawnVars() )
    G_Error("SpawnEntities: no entities", v1);
  SP_worldspawn();
  while ( G_ParseSpawnVars() )
    G_SpawnGEntityFromSpawnVars();
  result = level;
  level[1499] = 0;
  return result;
}
// 72DA5: variable 'v1' is possibly undefined
// 17A34: using guessed type int SP_worldspawn(void);
// 17B84: using guessed type int G_ParseSpawnVars(void);
// 18ED4: using guessed type int G_SpawnGEntityFromSpawnVars(void);

//----- (00072DD7) --------------------------------------------------------
void sub_72DD7()
{
  ;
}

//----- (00072DDC) --------------------------------------------------------
int __cdecl sub_72DDC(char *a1, _DWORD *a2)
{
  _BYTE *v2; // esi
  int v5; // [esp+20h] [ebp-98h] BYREF
  int v6; // [esp+24h] [ebp-94h] BYREF
  int v7; // [esp+28h] [ebp-90h]
  int i; // [esp+2Ch] [ebp-8Ch]
  char nptr[136]; // [esp+30h] [ebp-88h] BYREF

  for ( i = 0; i <= 3; ++i )
  {
    *((_BYTE *)&v6 + i) = 0;
    *((_BYTE *)&v5 + i) = 0;
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      G_Printf("Bad filter address: %s\n", (char)a1);
      return 0;
    }
    v7 = 0;
    while ( *a1 > 47 && *a1 <= 57 )
      nptr[v7++] = *a1++;
    nptr[v7] = 0;
    v2 = (char *)&v6 + i;
    *v2 = atoi(nptr);
    if ( *((_BYTE *)&v6 + i) )
      *((_BYTE *)&v5 + i) = -1;
    if ( !*a1 )
      break;
    ++a1;
  }
  *a2 = v5;
  a2[1] = v6;
  return 1;
}

//----- (00072F54) --------------------------------------------------------
int sub_72F54()
{
  size_t v0; // edi
  size_t v1; // eax
  char s[1032]; // [esp+20h] [ebp-428h] BYREF
  int i; // [esp+428h] [ebp-20h]
  int v5; // [esp+42Ch] [ebp-1Ch]

  s[0] = 0;
  for ( i = 0; i < dword_D3C60; ++i )
  {
    if ( *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]) != -1 )
    {
      v5 = *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]);
      v0 = 1024 - strlen(s);
      v1 = strlen(s);
      Com_sprintf(&s[v1], v0, "%i.%i.%i.%i ", v5);
    }
  }
  return trap_Cvar_Set("g_banIPs", s);
}
// 0: using guessed type int dword_0[];
// 16E44: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// D1C64: using guessed type int dword_D1C64;
// D3C60: using guessed type int dword_D3C60;

//----- (00073038) --------------------------------------------------------
_BOOL4 __cdecl G_FilterPacket(char *a1)
{
  int v4; // [esp+8h] [ebp-10h] BYREF
  int v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  i = 0;
  while ( *a1 && i <= 3 )
  {
    *((_BYTE *)&v4 + i) = 0;
    while ( *a1 > 47 && *a1 <= 57 )
      *((_BYTE *)&v4 + i) = *a1++ + 10 * *((_BYTE *)&v4 + i) - 48;
    if ( !*a1 || *a1 == 58 )
      break;
    ++i;
    ++a1;
  }
  v5 = v4;
  for ( i = 0; i < dword_D3C60; ++i )
  {
    if ( (*(int *)((_BYTE *)&dword_D1C60 + (_DWORD)&dword_0[2 * i]) & v5) == *(int *)((char *)&dword_D1C64
                                                                                    + (_DWORD)&dword_0[2 * i]) )
      return g_filterBan[3] != 0;
  }
  return g_filterBan[3] == 0;
}
// 0: using guessed type int dword_0[];
// D1C60: using guessed type int dword_D1C60;
// D1C64: using guessed type int dword_D1C64;
// D3C60: using guessed type int dword_D3C60;

//----- (00073138) --------------------------------------------------------
int __cdecl sub_73138(char *a1)
{
  char v2; // [esp+4h] [ebp-14h]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_D3C60 && *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]) != -1; ++i )
    ;
  if ( i == dword_D3C60 )
  {
    if ( dword_D3C60 == 1024 )
      return G_Printf("IP filter list is full\n", v2);
    ++dword_D3C60;
  }
  if ( !sub_72DDC(a1, &dword_D1C60[2 * i]) )
    *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]) = -1;
  return sub_72F54();
}
// 73194: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0[];
// D1C60: using guessed type int dword_D1C60[];
// D1C64: using guessed type int dword_D1C64;
// D3C60: using guessed type int dword_D3C60;

//----- (000731DF) --------------------------------------------------------
char *G_ProcessIPBans()
{
  char *result; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *i; // [esp+418h] [ebp-10h]
  char *s; // [esp+41Ch] [ebp-Ch]

  dword_D3C60 = 0;
  Q_strncpyz(dest, &g_banIPs[16], 1024);
  s = &g_banIPs[16];
  for ( i = &g_banIPs[16]; ; i = s )
  {
    result = i;
    if ( !*i )
      break;
    result = strchr(s, 32);
    s = result;
    if ( !result )
      break;
    while ( *s == 32 )
      *s++ = 0;
    if ( *i )
      sub_73138(i);
  }
  return result;
}
// D3C60: using guessed type int dword_D3C60;

//----- (00073294) --------------------------------------------------------
int Svcmd_AddIP_f()
{
  char v1; // [esp+4h] [ebp-414h]
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  addip <ip-mask>\n", v1);
  trap_Argv(1, v2, 1024);
  return sub_73138(v2);
}
// 732BC: variable 'v1' is possibly undefined
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);

//----- (000732F8) --------------------------------------------------------
int Svcmd_RemoveIP_f()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-424h]
  char v2; // [esp+4h] [ebp-424h]
  char v3[1028]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+414h] [ebp-14h]
  char v5[4]; // [esp+418h] [ebp-10h] BYREF
  int v6; // [esp+41Ch] [ebp-Ch]

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  sv removeip <ip-mask>\n", v1);
  trap_Argv(1, v3, 1024);
  result = sub_72DDC(v3, v5);
  if ( result )
  {
    for ( i = 0; i < dword_D3C60; ++i )
    {
      if ( *(int *)((char *)dword_D1C60 + (_DWORD)&dword_0[2 * i]) == *(_DWORD *)v5
        && *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]) == v6 )
      {
        *(int *)((char *)&dword_D1C64 + (_DWORD)&dword_0[2 * i]) = -1;
        G_Printf("Removed.\n", v2);
        return sub_72F54();
      }
    }
    result = G_Printf("Didn't find %s.\n", (char)v3);
  }
  return result;
}
// 73320: variable 'v1' is possibly undefined
// 733AC: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0[];
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 180A4: using guessed type int trap_Argc(void);
// D1C60: using guessed type int dword_D1C60[];
// D1C64: using guessed type int dword_D1C64;
// D3C60: using guessed type int dword_D3C60;

//----- (000733E0) --------------------------------------------------------
int Svcmd_EntityList_f()
{
  char v0; // al
  char v2; // [esp+4h] [ebp-34h]
  char v3; // [esp+4h] [ebp-34h]
  char v4; // [esp+28h] [ebp-10h]
  _DWORD *v5; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v4 = 0;
  v5 = &g_entities[211];
  for ( i = 1; i < level[3]; ++i )
  {
    if ( *((_BYTE *)v5 + 364) )
    {
      ++v4;
      G_Printf("%3i:", i);
      switch ( v5[1] )
      {
        case 0:
          G_Printf("ET_GENERAL          ", v2);
          break;
        case 1:
          G_Printf("ET_PLAYER           ", v2);
          break;
        case 3:
          G_Printf("ET_ITEM             ", v2);
          break;
        case 4:
          G_Printf("ET_MISSILE          ", v2);
          break;
        case 5:
          G_Printf("ET_MOVER            ", v2);
          break;
        case 6:
          G_Printf("ET_PORTAL           ", v2);
          break;
        case 7:
          G_Printf("ET_INVISIBLE        ", v2);
          break;
        case 8:
          G_Printf("ET_SCRIPTMOVER      ", v2);
          break;
        case 9:
          G_Printf("ET_SOUND_BLEND      ", v2);
          break;
        case 0xC:
          G_Printf("ET_VEHICLE          ", v2);
          break;
        default:
          G_Printf("%3i                 ", v5[1]);
          break;
      }
      if ( *((_WORD *)v5 + 194) )
      {
        v0 = SL_ConvertToString(*((unsigned __int16 *)v5 + 194));
        G_Printf("%s, origin: %g %g %g", v0);
      }
      G_Printf("\n", v3);
    }
    v5 += 211;
  }
  return G_Printf("Total entities used: %i\n", v4);
}
// 7347D: variable 'v2' is possibly undefined
// 73598: variable 'v3' is possibly undefined
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (000735CB) --------------------------------------------------------
int __cdecl ClientForString(char *nptr)
{
  int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    for ( i = 0; i < level[121]; ++i )
    {
      v5 = level[0] + 18228 * i;
      if ( *(_DWORD *)(v5 + 17696) && !Q_stricmp(v5 + 17908, nptr) )
        return v5;
    }
    G_Printf("User %s is not on the server\n", (char)nptr);
    v2 = 0;
  }
  else
  {
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < level[121] )
    {
      if ( *(_DWORD *)(level[0] + 18228 * v3 + 17696) )
      {
        v2 = level[0] + 18228 * v3;
      }
      else
      {
        G_Printf("Client %i is not connected\n", v3);
        v2 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      v2 = 0;
    }
  }
  return v2;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00073714) --------------------------------------------------------
int ConsoleCommand()
{
  char v0; // al
  int v1; // eax
  int v3; // [esp+1Ch] [ebp-40Ch]
  char v4[1032]; // [esp+20h] [ebp-408h] BYREF

  trap_Argv(0, v4, 1024);
  if ( Q_stricmp(v4, "entitylist") )
  {
    if ( Q_stricmp(v4, "addip") )
    {
      if ( Q_stricmp(v4, "removeip") )
      {
        if ( Q_stricmp(v4, "listip") )
        {
          if ( !g_dedicated[3] || Q_stricmp(v4, "say") )
          {
            v3 = 0;
          }
          else
          {
            v0 = ConcatArgs(1);
            v1 = va(aEGameServer_0, v0);
            trap_SendServerCommand(-1, 0, v1);
            v3 = 1;
          }
        }
        else
        {
          trap_SendConsoleCommand(1, "g_banIPs\n");
          v3 = 1;
        }
      }
      else
      {
        Svcmd_RemoveIP_f();
        v3 = 1;
      }
    }
    else
    {
      Svcmd_AddIP_f();
      v3 = 1;
    }
  }
  else
  {
    Svcmd_EntityList_f();
    v3 = 1;
  }
  return v3;
}
// 172D4: using guessed type int Svcmd_RemoveIP_f(void);
// 17B54: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 17FF4: using guessed type int Svcmd_AddIP_f(void);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18654: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 18894: using guessed type int Svcmd_EntityList_f(void);
// 18A04: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00073898) --------------------------------------------------------
void sub_73898()
{
  ;
}

//----- (0007389C) --------------------------------------------------------
int (__cdecl *__cdecl dllEntry(int (__cdecl *a1)(_DWORD, _DWORD)))(_DWORD, _DWORD)
{
  int (__cdecl *result)(_DWORD, _DWORD); // eax

  result = a1;
  dword_AE908 = a1;
  return result;
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000738B7) --------------------------------------------------------
long double __cdecl sub_738B7(float a1)
{
  return a1;
}

//----- (000738CE) --------------------------------------------------------
int __cdecl PASSFLOAT(int a1)
{
  return a1;
}

//----- (000738DF) --------------------------------------------------------
int __cdecl trap_Printf(int a1)
{
  return dword_AE908(0, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007390D) --------------------------------------------------------
int __cdecl trap_Error(int a1)
{
  return dword_AE908(1, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007393B) --------------------------------------------------------
int __cdecl trap_Error_Localized(int a1)
{
  return dword_AE908(2, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073969) --------------------------------------------------------
int trap_Milliseconds()
{
  return ((int (__cdecl *)(int))dword_AE908)(3);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073990) --------------------------------------------------------
int trap_Argc()
{
  return ((int (__cdecl *)(int))dword_AE908)(10);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000739B7) --------------------------------------------------------
int __cdecl trap_Argv(int a1)
{
  return dword_AE908(11, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000739F3) --------------------------------------------------------
int __cdecl trap_Hunk_AllocInternal(int a1)
{
  return dword_AE908(12, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073A21) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowInternal(int a1)
{
  return dword_AE908(13, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073A4F) --------------------------------------------------------
int __cdecl trap_Hunk_AllocAlignInternal(int a1)
{
  return dword_AE908(14, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073A84) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1)
{
  return dword_AE908(15, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073AB9) --------------------------------------------------------
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1)
{
  return dword_AE908(16, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073AE7) --------------------------------------------------------
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1)
{
  return dword_AE908(17, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073B15) --------------------------------------------------------
int __cdecl trap_FS_FOpenFile(int a1)
{
  return dword_AE908(18, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073B51) --------------------------------------------------------
int __cdecl trap_FS_Read(int a1)
{
  return dword_AE908(19, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073B8D) --------------------------------------------------------
int __cdecl trap_FS_Write(int a1)
{
  return dword_AE908(20, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073BC9) --------------------------------------------------------
int __cdecl trap_FS_Rename(int a1)
{
  return dword_AE908(21, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073BFE) --------------------------------------------------------
int __cdecl trap_FS_FCloseFile(int a1)
{
  return dword_AE908(22, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073C2C) --------------------------------------------------------
int __cdecl trap_FS_GetFileList(int a1)
{
  return dword_AE908(59, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073C6F) --------------------------------------------------------
int __cdecl trap_MapExists(int a1)
{
  return dword_AE908(60, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073C9D) --------------------------------------------------------
int __cdecl trap_SendConsoleCommand(int a1)
{
  return dword_AE908(23, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073CD2) --------------------------------------------------------
int __cdecl trap_Cvar_Register(int a1)
{
  return dword_AE908(4, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073D15) --------------------------------------------------------
int __cdecl trap_Cvar_Update(int a1)
{
  return dword_AE908(5, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073D43) --------------------------------------------------------
int __cdecl trap_Cvar_Set(int a1)
{
  return dword_AE908(6, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073D78) --------------------------------------------------------
int __cdecl trap_Cvar_VariableIntegerValue(int a1)
{
  return dword_AE908(7, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073DA6) --------------------------------------------------------
long double __cdecl trap_Cvar_VariableValue(int a1)
{
  float v2; // [esp+10h] [ebp-8h]

  dword_AE908(8, a1);
  return v2;
}
// 73DDB: variable 'v2' is possibly undefined
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073DE4) --------------------------------------------------------
int __cdecl trap_Cvar_VariableStringBuffer(int a1)
{
  return dword_AE908(9, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073E20) --------------------------------------------------------
int __cdecl trap_LocateGameData(int a1)
{
  return dword_AE908(24, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073E6A) --------------------------------------------------------
int __cdecl trap_GetGuid(int a1)
{
  return dword_AE908(25, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073E98) --------------------------------------------------------
int __cdecl trap_DropClient(int a1)
{
  return dword_AE908(26, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073ECD) --------------------------------------------------------
int __cdecl trap_SendServerCommand(int a1)
{
  return dword_AE908(27, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073F09) --------------------------------------------------------
int __cdecl trap_SetConfigstring(int a1)
{
  return dword_AE908(28, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073F3E) --------------------------------------------------------
int __cdecl trap_GetConfigstring(int a1)
{
  return dword_AE908(29, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073F7A) --------------------------------------------------------
int __cdecl trap_GetConfigstringConst(int a1)
{
  return dword_AE908(30, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073FA8) --------------------------------------------------------
int __cdecl trap_IsLocalClient(int a1)
{
  return dword_AE908(31, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00073FD6) --------------------------------------------------------
int __cdecl trap_GetClientPing(int a1)
{
  return dword_AE908(32, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074004) --------------------------------------------------------
int __cdecl trap_GetUserinfo(int a1)
{
  return dword_AE908(33, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074040) --------------------------------------------------------
int __cdecl trap_SetUserinfo(int a1)
{
  return dword_AE908(34, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074075) --------------------------------------------------------
int __cdecl trap_GetServerinfo(int a1)
{
  return dword_AE908(35, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000740AA) --------------------------------------------------------
int __cdecl trap_SetBrushModel(int a1)
{
  return dword_AE908(36, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000740D8) --------------------------------------------------------
int __cdecl trap_Trace(int a1)
{
  return dword_AE908(37, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074130) --------------------------------------------------------
int __cdecl trap_TraceCapsule(int a1)
{
  return dword_AE908(38, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074188) --------------------------------------------------------
int __cdecl trap_SightTrace(int a1)
{
  return dword_AE908(39, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000741E7) --------------------------------------------------------
int __cdecl trap_SightTraceCapsule(int a1)
{
  return dword_AE908(40, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074246) --------------------------------------------------------
int __cdecl trap_SightTraceToEntity(int a1)
{
  return dword_AE908(41, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074297) --------------------------------------------------------
int __cdecl trap_CM_BoxTrace(int a1)
{
  return dword_AE908(42, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000742EF) --------------------------------------------------------
int __cdecl trap_CM_CapsuleTrace(int a1)
{
  return dword_AE908(43, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074347) --------------------------------------------------------
int __cdecl trap_CM_BoxSightTrace(int a1)
{
  return dword_AE908(44, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074398) --------------------------------------------------------
int __cdecl trap_CM_CapsuleSightTrace(int a1)
{
  return dword_AE908(45, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000743E9) --------------------------------------------------------
int __cdecl trap_LocationalTrace(int a1)
{
  return dword_AE908(46, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007443A) --------------------------------------------------------
int __cdecl trap_PointContents(int a1)
{
  return dword_AE908(47, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074476) --------------------------------------------------------
int __cdecl trap_InPVS(int a1)
{
  return dword_AE908(48, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000744AB) --------------------------------------------------------
int __cdecl trap_InPVSIgnorePortals(int a1)
{
  return dword_AE908(49, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000744E0) --------------------------------------------------------
int __cdecl trap_InSnapshot(int a1)
{
  return dword_AE908(50, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074515) --------------------------------------------------------
int __cdecl trap_AdjustAreaPortalState(int a1)
{
  return dword_AE908(51, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007454A) --------------------------------------------------------
int __cdecl trap_AreasConnected(int a1)
{
  return dword_AE908(52, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007457F) --------------------------------------------------------
int __cdecl trap_LinkEntity(int a1)
{
  return dword_AE908(53, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000745AD) --------------------------------------------------------
int __cdecl trap_UnlinkEntity(int a1)
{
  return dword_AE908(54, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000745DB) --------------------------------------------------------
int __cdecl trap_EntitiesInBox(int a1)
{
  return dword_AE908(55, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074625) --------------------------------------------------------
int __cdecl trap_EntityContact(int a1)
{
  return dword_AE908(56, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074661) --------------------------------------------------------
int __cdecl trap_EntityContactCapsule(int a1)
{
  return dword_AE908(63, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007469D) --------------------------------------------------------
int __cdecl trap_GetUsercmd(int a1)
{
  return dword_AE908(57, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000746D2) --------------------------------------------------------
int __cdecl trap_GetEntityToken(int a1)
{
  return dword_AE908(58, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074707) --------------------------------------------------------
int __cdecl trap_AddDebugString(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, int, int, int))dword_AE908)(71, a1, a2, v4, a4);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074754) --------------------------------------------------------
int __cdecl trap_AddDebugLine(int a1)
{
  return dword_AE908(72, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007479E) --------------------------------------------------------
int __cdecl trap_SetArchive(int a1)
{
  return dword_AE908(73, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000747CC) --------------------------------------------------------
int __cdecl trap_RealTime(int a1)
{
  return dword_AE908(61, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000747FA) --------------------------------------------------------
int __cdecl trap_SnapVector(int a1)
{
  return dword_AE908(62, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074828) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasString(int a1)
{
  return dword_AE908(64, a1);
}
// 74828: using guessed type int __cdecl trap_Com_SoundAliasString(int);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074856) --------------------------------------------------------
int __cdecl trap_Com_PickSoundAlias(int a1)
{
  return dword_AE908(65, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007488B) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasIndex(int a1)
{
  return dword_AE908(66, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000748B9) --------------------------------------------------------
int __cdecl trap_SurfaceTypeFromName(int a1)
{
  return dword_AE908(67, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000748E7) --------------------------------------------------------
int __cdecl trap_SurfaceTypeToName(int a1)
{
  return dword_AE908(68, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074915) --------------------------------------------------------
int __cdecl trap_Z_MallocInternal(int a1)
{
  return dword_AE908(74, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074943) --------------------------------------------------------
int __cdecl trap_Z_FreeInternal(int a1)
{
  return dword_AE908(75, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074971) --------------------------------------------------------
int trap_AddTestClient()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = ((int (__cdecl *)(int))dword_AE908)(69);
  if ( v2 < 0 )
    v1 = 0;
  else
    v1 = 844 * v2 + level[1];
  return v1;
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000749C4) --------------------------------------------------------
int __cdecl trap_GetArchivedClientInfo(int a1)
{
  return dword_AE908(70, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074A07) --------------------------------------------------------
int __cdecl trap_XAnimCreateTree(int a1)
{
  return dword_AE908(76, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074A35) --------------------------------------------------------
int __cdecl trap_XAnimCreateSmallTree(int a1)
{
  return dword_AE908(77, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074A63) --------------------------------------------------------
int __cdecl trap_XAnimFreeSmallTree(int a1)
{
  return dword_AE908(78, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074A91) --------------------------------------------------------
int __cdecl trap_XModelExists(int a1)
{
  return dword_AE908(79, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074ABF) --------------------------------------------------------
int __cdecl trap_XModelGet(int a1)
{
  return dword_AE908(80, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074AED) --------------------------------------------------------
int __cdecl trap_DObjCreate(int a1)
{
  return dword_AE908(81, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074B47) --------------------------------------------------------
int __cdecl trap_SafeDObjFree(int a1)
{
  return dword_AE908(83, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074B7C) --------------------------------------------------------
int __cdecl trap_DObjExists(_DWORD *a1)
{
  return dword_AE908(82, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074BAC) --------------------------------------------------------
int __cdecl trap_XAnimGetAnims(int a1)
{
  return dword_AE908(84, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074BDA) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2)
{
  int v2; // eax
  int v4; // [esp+Ch] [ebp-Ch]

  LOWORD(v4) = 0;
  v2 = trap_XAnimGetAnims(a2);
  HIWORD(v4) = Scr_GetAnimsIndex(v2);
  *a1 = v4;
  return a1;
}
// 16A44: using guessed type _DWORD __cdecl trap_XAnimGetAnims(_DWORD);
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);

//----- (00074C1D) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_AE908)(86, a1, a2, v3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074C62) --------------------------------------------------------
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_AE908)(87, a1, a2, v3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074CA7) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_AE908)(88, a1, a2, v3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074CEC) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_AE908)(89, a1, a2, v9, v8, v7, a6, a7);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074D6F) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4, int a5, int a6, unsigned __int16 a7, int a8)
{
  int v8; // edi
  int v9; // esi
  int v10; // eax

  v8 = PASSFLOAT(a6);
  v9 = PASSFLOAT(a5);
  v10 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, int, _DWORD, _DWORD, int, int, int, _DWORD, int))dword_AE908)(
           90,
           a1,
           a2,
           a3,
           v10,
           v9,
           v8,
           a7,
           a8);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074DFA) --------------------------------------------------------
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_AE908)(91, a1, a2, v3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074E3F) --------------------------------------------------------
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_AE908)(92, a1, a2, v3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074E84) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_AE908)(93, a1, a2, v9, v8, v7, a6, a7);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074F07) --------------------------------------------------------
int __cdecl trap_XAnimClearTree(int a1)
{
  return dword_AE908(94, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074F35) --------------------------------------------------------
int __cdecl trap_XAnimHasTime(int a1)
{
  return dword_AE908(95, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074F6C) --------------------------------------------------------
int __cdecl trap_XAnimIsPrimitive(int a1)
{
  return dword_AE908(96, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074FA3) --------------------------------------------------------
int __cdecl trap_XAnimGetLength(int a1)
{
  return dword_AE908(97, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00074FE0) --------------------------------------------------------
long double __cdecl trap_XAnimGetLengthSeconds(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_AE908(98, HIWORD(a1)));
  return (float)sub_738B7(v1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007502B) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_AE908)(99, a1, a2, v9, v8, v7, a6, a7);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000750AE) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_AE908)(100, a1, a2, v9, v8, v7, a6, a7);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075131) --------------------------------------------------------
int __cdecl trap_XAnimCalcAbsDelta(int a1)
{
  return dword_AE908(101, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075175) --------------------------------------------------------
int __cdecl trap_XAnimCalcDelta(int a1)
{
  return dword_AE908(102, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000751C0) --------------------------------------------------------
int __cdecl trap_XAnimGetRelDelta(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // eax

  v5 = PASSFLOAT(a5);
  v6 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, _DWORD, _DWORD, int, int, int, int))dword_AE908)(
           103,
           HIWORD(a1),
           (unsigned __int16)a1,
           a2,
           a3,
           v6,
           v5);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075227) --------------------------------------------------------
int __cdecl trap_XAnimGetAbsDelta(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, _DWORD, _DWORD, int, int, int))dword_AE908)(
           104,
           HIWORD(a1),
           (unsigned __int16)a1,
           a2,
           a3,
           v4);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007527B) --------------------------------------------------------
int __cdecl trap_XAnimIsLooped(int a1)
{
  return dword_AE908(105, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000752B2) --------------------------------------------------------
int __cdecl trap_XAnimNotetrackExists(int a1)
{
  return dword_AE908(106, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000752F8) --------------------------------------------------------
long double __cdecl trap_XAnimGetTime(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_AE908(107, a1));
  return (float)sub_738B7(v1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075342) --------------------------------------------------------
long double __cdecl trap_XAnimGetWeight(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_AE908(108, a1));
  return (float)sub_738B7(v1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007538C) --------------------------------------------------------
int __cdecl trap_DObjDumpInfo(_DWORD *a1)
{
  return dword_AE908(109, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000753BC) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1)
{
  return dword_AE908(110, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000753F3) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1)
{
  return dword_AE908(111, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007542A) --------------------------------------------------------
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a2);
  return ((int (__cdecl *)(int, _DWORD, int, int))dword_AE908)(112, *a1, v3, a3);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075472) --------------------------------------------------------
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2)
{
  int v2; // eax

  v2 = PASSFLOAT(a2);
  return ((int (__cdecl *)(int, _DWORD, int))dword_AE908)(113, *a1, v2);
}
// 18344: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000754B1) --------------------------------------------------------
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1)
{
  return dword_AE908(114, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000754EF) --------------------------------------------------------
int __cdecl trap_DObjCalcAnim(_DWORD *a1)
{
  return dword_AE908(115, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075526) --------------------------------------------------------
int __cdecl trap_DObjCalcSkel(_DWORD *a1)
{
  return dword_AE908(116, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007555D) --------------------------------------------------------
int __cdecl trap_XAnimLoadAnimTree(int a1)
{
  return dword_AE908(117, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007558B) --------------------------------------------------------
int __cdecl trap_XAnimSaveAnimTree(int a1)
{
  return dword_AE908(118, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000755B9) --------------------------------------------------------
int __cdecl trap_XAnimCloneAnimTree(int a1)
{
  return dword_AE908(119, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000755EE) --------------------------------------------------------
int __cdecl trap_DObjNumBones(_DWORD *a1)
{
  return dword_AE908(120, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007561E) --------------------------------------------------------
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1)
{
  return dword_AE908(121, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075655) --------------------------------------------------------
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1)
{
  return dword_AE908(122, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075685) --------------------------------------------------------
int __cdecl trap_DObjDisplayAnim(_DWORD *a1)
{
  return dword_AE908(123, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000756B5) --------------------------------------------------------
int __cdecl trap_XAnimHasFinished(int a1)
{
  return dword_AE908(124, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000756EB) --------------------------------------------------------
int __cdecl trap_XAnimGetNumChildren(int a1)
{
  return dword_AE908(125, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075722) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, int a2)
{
  LOWORD(a2) = dword_AE908(126, HIWORD(a2));
  *a1 = a2;
  return a1;
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075772) --------------------------------------------------------
int __cdecl trap_XModelNumBones(int a1)
{
  return dword_AE908(127, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000757A0) --------------------------------------------------------
int __cdecl trap_XModelGetBoneNames(int a1)
{
  return dword_AE908(128, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000757CE) --------------------------------------------------------
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1)
{
  return dword_AE908(129, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000757FE) --------------------------------------------------------
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1)
{
  return dword_AE908(130, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007583C) --------------------------------------------------------
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1)
{
  return dword_AE908(131, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007587A) --------------------------------------------------------
int __cdecl trap_DObjGetBounds(_DWORD *a1)
{
  return dword_AE908(132, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000758B8) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimName(int a1)
{
  return dword_AE908(133, HIWORD(a1));
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000758EF) --------------------------------------------------------
int __cdecl trap_DObjGetTree(_DWORD *a1)
{
  return dword_AE908(134, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007591F) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimTreeSize(int a1)
{
  return dword_AE908(135, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007594D) --------------------------------------------------------
int __cdecl trap_XModelDebugBoxes(_DWORD *a1)
{
  return dword_AE908(136, *a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (0007597D) --------------------------------------------------------
int __cdecl trap_GetWeaponInfoMemory(int a1)
{
  return dword_AE908(137, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000759B2) --------------------------------------------------------
int __cdecl trap_FreeWeaponInfoMemory(int a1)
{
  return dword_AE908(138, a1);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (000759E0) --------------------------------------------------------
int trap_FreeClientScriptPers()
{
  return ((int (__cdecl *)(int))dword_AE908)(139);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075A07) --------------------------------------------------------
int trap_ResetEntityParsePoint()
{
  return ((int (__cdecl *)(int))dword_AE908)(140);
}
// AE908: using guessed type int (__cdecl *dword_AE908)(_DWORD, _DWORD);

//----- (00075A2E) --------------------------------------------------------
void sub_75A2E()
{
  ;
}

//----- (00075A34) --------------------------------------------------------
_DWORD *target_location_linkup()
{
  _DWORD *result; // eax
  int v1; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+20h] [ebp+8h]

  result = level;
  if ( !level[2143] )
  {
    level[2143] = 1;
    level[2144] = 0;
    trap_SetConfigstring(53, "unknown");
    v3 = 0;
    v5 = g_entities;
    v2 = 1;
    while ( 1 )
    {
      result = v3;
      if ( (int)v3 >= level[3] )
        break;
      if ( *((_WORD *)v5 + 194) == scr_const[82] )
      {
        v5[144] = v2;
        v1 = SL_ConvertToString(*((unsigned __int16 *)v5 + 236));
        trap_SetConfigstring(v2 + 53, v1);
        ++v2;
        v5[107] = level[2144];
        level[2144] = v5;
      }
      v3 = (_DWORD *)((char *)v3 + 1);
      v5 += 211;
    }
  }
  return result;
}
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (00075B43) --------------------------------------------------------
int __cdecl SP_target_location(int a1)
{
  Scr_SetString(a1 + 388, scr_const[82]);
  *(_DWORD *)(a1 + 528) = target_location_linkup;
  *(_DWORD *)(a1 + 524) = level[123] + 200;
  return G_SetOrigin(a1, a1 + 316);
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00075BBC) --------------------------------------------------------
void sub_75BBC()
{
  ;
}

//----- (00075BC0) --------------------------------------------------------
_BOOL4 __cdecl OnSameTeam(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 352) || !*(_DWORD *)(a2 + 352) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) == *(_DWORD *)(*(_DWORD *)(a2 + 352) + 17852);
  return 0;
}

//----- (00075C37) --------------------------------------------------------
_BOOL4 __cdecl InSameSquad(int a1, int a2)
{
  if ( !OnSameTeam(a1, a2) )
    return 0;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 352) + 17844) )
    return *(_WORD *)(*(_DWORD *)(a1 + 352) + 17844) == *(_WORD *)(*(_DWORD *)(a2 + 352) + 17844);
  return 0;
}
// 17304: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);

//----- (00075CBF) --------------------------------------------------------
int __cdecl Team_GetLocation(int *a1)
{
  float v2; // [esp+10h] [ebp-28h] BYREF
  float v3; // [esp+14h] [ebp-24h]
  float v4; // [esp+18h] [ebp-20h]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  v6 = 201326590.0;
  v2 = *((float *)a1 + 79);
  v3 = *((float *)a1 + 80);
  v4 = *((float *)a1 + 81);
  for ( i = level[2144]; i; i = *(_DWORD *)(i + 428) )
  {
    v5 = (v2 - *(float *)(i + 316)) * (v2 - *(float *)(i + 316))
       + (v3 - *(float *)(i + 320)) * (v3 - *(float *)(i + 320))
       + (v4 - *(float *)(i + 324)) * (v4 - *(float *)(i + 324));
    if ( v5 <= (long double)v6 )
    {
      if ( trap_InPVS(&v2, i + 316) )
      {
        v6 = v5;
        v7 = i;
      }
    }
  }
  return v7;
}
// 18534: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);

//----- (00075DC4) --------------------------------------------------------
int __cdecl Team_GetLocationMsg(int a1, char *s, size_t maxlen)
{
  char v3; // al
  int v6; // [esp+20h] [ebp-8h]

  v6 = Team_GetLocation(a1);
  if ( !v6 )
    return 0;
  if ( *(_DWORD *)(v6 + 608) )
  {
    if ( *(int *)(v6 + 608) < 0 )
      *(_DWORD *)(v6 + 608) = 0;
    if ( *(int *)(v6 + 608) > 7 )
      *(_DWORD *)(v6 + 608) = 7;
    SL_ConvertToString(*(unsigned __int16 *)(v6 + 472));
    Com_sprintf(s, maxlen, byte_A5BA7, 94);
  }
  else
  {
    v3 = SL_ConvertToString(*(unsigned __int16 *)(v6 + 472));
    Com_sprintf(s, maxlen, byte_A5BB3, v3);
  }
  return 1;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 19844: using guessed type _DWORD __cdecl Team_GetLocation(_DWORD);

//----- (00075EC2) --------------------------------------------------------
int __cdecl TeamplayInfoMessage(int a1)
{
  int result; // eax
  float v2[9]; // [esp+30h] [ebp-B8h] BYREF
  float v3; // [esp+54h] [ebp-94h]
  float v4; // [esp+58h] [ebp-90h]
  float v5; // [esp+5Ch] [ebp-8Ch]
  char v6[40]; // [esp+70h] [ebp-78h] BYREF
  unsigned __int16 v7; // [esp+98h] [ebp-50h]
  float v8; // [esp+A0h] [ebp-48h] BYREF
  float v9; // [esp+A4h] [ebp-44h]
  float v10; // [esp+A8h] [ebp-40h]
  float v11; // [esp+B0h] [ebp-38h] BYREF
  float v12; // [esp+B4h] [ebp-34h]
  float v13; // [esp+B8h] [ebp-30h]
  float v14[6]; // [esp+C0h] [ebp-28h] BYREF
  int v15; // [esp+D8h] [ebp-10h]
  int v16; // [esp+DCh] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 352) + 17668) )
  {
    AngleVectors(*(_DWORD *)(a1 + 352) + 232, v14, 0, 0);
    CalcMuzzlePoint(a1, &v11);
    if ( *(float *)(*(_DWORD *)(a1 + 352) + 248) < 8.0 )
      v13 = 8.0 - *(float *)(*(_DWORD *)(a1 + 352) + 248) + v13;
    v8 = v14[0] * 8192.0 + v11;
    v9 = v14[1] * 8192.0 + v12;
    v10 = v14[2] * 8192.0 + v13;
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 352) + 17852) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 352) + 296) = -1;
      result = *(_DWORD *)(a1 + 352);
      *(_DWORD *)(result + 300) = 0;
      return result;
    }
    CalcMuzzlePoints(a1, v2);
    v8 = v2[0] * 8192.0 + v3;
    v9 = v2[1] * 8192.0 + v4;
    v10 = v2[2] * 8192.0 + v5;
    v11 = v3;
    v12 = v4;
    v13 = v5;
  }
  trap_Trace(v6, &v11, vec3_origin, vec3_origin, &v8, *(_DWORD *)(*(_DWORD *)(a1 + 352) + 212), 33554433);
  v16 = v7;
  if ( v7 <= 0x3Fu
    && g_entities[211 * v16 + 88]
    && (!G_IsPlaying(a1) || LOWORD(g_entities[211 * v16 + 122]) == *(_WORD *)(a1 + 488)) )
  {
    v15 = g_entities[211 * v16 + 144];
  }
  else
  {
    v16 = -1;
    v15 = 0;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 296) = v16;
  result = v15;
  *(_DWORD *)(*(_DWORD *)(a1 + 352) + 300) = v15;
  return result;
}
// 169E4: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 182C4: using guessed type _DWORD __cdecl G_IsPlaying(_DWORD);
// 18CD4: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00076164) --------------------------------------------------------
int CheckTeamStatus()
{
  int result; // eax
  _DWORD *v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = level[123] - level[131];
  if ( result > 0 )
  {
    level[131] = level[123];
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= g_maxclients[3] )
        break;
      v1 = &g_entities[211 * i];
      if ( *((_BYTE *)v1 + 364) )
      {
        if ( (*(_DWORD *)(v1[88] + 12) & 0x40000) == 0 )
          TeamplayInfoMessage(v1);
      }
    }
  }
  return result;
}
// 17F74: using guessed type _DWORD __cdecl TeamplayInfoMessage(_DWORD);

//----- (00076212) --------------------------------------------------------
void sub_76212()
{
  ;
}

//----- (00076218) --------------------------------------------------------
int __cdecl G_Trigger(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  result = Scr_IsSystemActive(1);
  if ( result )
  {
    if ( level[2968] == 256 )
    {
      Scr_AddEntity(a2);
      result = Scr_Notify(a1, scr_const[88], 1);
    }
    else
    {
      v3 = &level[3 * level[2968]++ + 2200];
      *(_WORD *)v3 = *(_WORD *)a1;
      *((_WORD *)v3 + 1) = *(_WORD *)a2;
      v3[1] = *(_DWORD *)(a1 + 784);
      result = *(_DWORD *)(a2 + 784);
      v3[2] = result;
    }
  }
  return result;
}
// 17884: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000762F6) --------------------------------------------------------
int __cdecl InitTrigger(int a1)
{
  int result; // eax

  if ( *(float *)(a1 + 328) != 0.0 || *(float *)(a1 + 332) != vec3_origin[1] || *(float *)(a1 + 336) != vec3_origin[2] )
    G_SetMovedir(a1 + 328, a1 + 504);
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 288) = 1079771144;
  *(_DWORD *)(a1 + 248) = 1;
  result = *(_DWORD *)(a1 + 8) | 2;
  *(_DWORD *)(a1 + 8) = result;
  return result;
}
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 18D44: using guessed type _DWORD __cdecl G_SetMovedir(_DWORD, _DWORD);

//----- (000763B6) --------------------------------------------------------
int __cdecl InitSentientTrigger(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 288) = 0;
  if ( (*(_DWORD *)(a1 + 392) & 8) == 0 )
    *(_DWORD *)(a1 + 288) |= 0x40000000u;
  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
    *(_DWORD *)(a1 + 288) |= 0x40000u;
  if ( (*(_DWORD *)(a1 + 392) & 2) != 0 )
    *(_DWORD *)(a1 + 288) |= 0x80000u;
  if ( (*(_DWORD *)(a1 + 392) & 4) != 0 )
    *(_DWORD *)(a1 + 288) |= 0x100000u;
  result = *(_DWORD *)(a1 + 392) & 0x10;
  if ( result )
  {
    result = a1;
    *(_DWORD *)(a1 + 288) |= 8u;
  }
  return result;
}

//----- (0007648D) --------------------------------------------------------
int __cdecl multi_wait(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 524) = 0;
  return result;
}

//----- (0007649F) --------------------------------------------------------
int (__cdecl *__cdecl multi_trigger(int a1, int a2))(int)
{
  int (__cdecl *result)(int); // eax
  long double v3; // fst6

  *(_DWORD *)(a1 + 620) = a2;
  result = Think_GeneralLink;
  if ( *(int (__cdecl **)(int))(a1 + 528) != Think_GeneralLink )
  {
    result = (int (__cdecl *)(int))a1;
    if ( !*(_DWORD *)(a1 + 524) )
    {
      if ( *(float *)(a1 + 632) <= 0.0 )
      {
        *(_DWORD *)(a1 + 540) = 0;
        *(_DWORD *)(a1 + 524) = level[123] + 100;
        result = (int (__cdecl *)(int))G_FreeEntity;
        *(_DWORD *)(a1 + 528) = G_FreeEntity;
      }
      else
      {
        *(_DWORD *)(a1 + 528) = multi_wait;
        v3 = (long double)rand() / 2147483600.0;
        result = (int (__cdecl *)(int))(level[123]
                                      + (int)(((v3 + v3 - 1.0) * *(float *)(a1 + 636) + *(float *)(a1 + 632)) * 1000.0));
        *(_DWORD *)(a1 + 524) = result;
      }
    }
  }
  return result;
}
// 78C40: using guessed type int __cdecl Think_GeneralLink(int);

//----- (000765C7) --------------------------------------------------------
int __cdecl Use_Multi(int a1, int a2, int a3)
{
  return multi_trigger(a1, a3);
}
// 17DF4: using guessed type _DWORD __cdecl multi_trigger(_DWORD, _DWORD);

//----- (000765F1) --------------------------------------------------------
int __cdecl Touch_Multi(int a1, int a2)
{
  G_Trigger(a1, a2);
  return multi_trigger(a1, a2);
}
// 179F4: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 17DF4: using guessed type _DWORD __cdecl multi_trigger(_DWORD, _DWORD);

//----- (0007662D) --------------------------------------------------------
int __cdecl SP_trigger_multiple(int a1)
{
  char v2; // [esp+4h] [ebp-14h]

  G_SpawnFloat("wait", (int)&off_A5BD0, a1 + 632);
  G_SpawnFloat("random", (int)"0", a1 + 636);
  if ( *(float *)(a1 + 636) >= (long double)*(float *)(a1 + 632) && *(float *)(a1 + 632) >= 0.0 )
  {
    *(float *)(a1 + 636) = *(float *)(a1 + 632) - 100.0;
    G_Printf("trigger_multiple has random >= wait\n", v2);
  }
  *(_DWORD *)(a1 + 540) = Touch_Multi;
  *(_DWORD *)(a1 + 544) = Use_Multi;
  InitTrigger(a1);
  InitSentientTrigger(a1);
  return trap_LinkEntity(a1);
}
// 766E1: variable 'v2' is possibly undefined
// 170E4: using guessed type _DWORD __cdecl InitSentientTrigger(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178F4: using guessed type _DWORD __cdecl InitTrigger(_DWORD);
// A5BD0: using guessed type void *off_A5BD0;

//----- (0007672B) --------------------------------------------------------
int __cdecl hurt_touch(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a2;
  if ( *(_BYTE *)(a2 + 381) )
  {
    result = *(_DWORD *)(a1 + 476);
    if ( result <= level[123] )
    {
      G_Trigger(a1, a2);
      if ( (*(_DWORD *)(a1 + 392) & 0x10) != 0 )
        v3 = level[123] + 1000;
      else
        v3 = level[123] + 100;
      *(_DWORD *)(a1 + 476) = v3;
      if ( (*(_DWORD *)(a1 + 392) & 4) == 0 )
        G_PlaySoundAliasAtPoint(a2 + 316, *(unsigned __int8 *)(a1 + 378));
      if ( (*(_DWORD *)(a1 + 392) & 8) != 0 )
        G_Damage(a2, a1, a1, 0, 0, *(_DWORD *)(a1 + 584), 16, 22, 0);
      else
        G_Damage(a2, a1, a1, 0, 0, *(_DWORD *)(a1 + 584), 0, 22, 0);
      result = *(_DWORD *)(a1 + 392) & 0x20;
      if ( result )
      {
        result = a1;
        *(_DWORD *)(a1 + 540) = 0;
      }
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 179F4: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 17EF4: using guessed type _DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD);

//----- (0007687F) --------------------------------------------------------
void __cdecl hurt_think(void *s)
{
  *((_DWORD *)s + 131) = level[123] + 100;
  if ( (long double)(int)level[123] > *((float *)s + 158) )
    G_FreeEntity(s);
}

//----- (000768DA) --------------------------------------------------------
void __cdecl hurt_use(int a1)
{
  if ( *(_DWORD *)(a1 + 540) )
    *(_DWORD *)(a1 + 540) = 0;
  else
    *(_DWORD *)(a1 + 540) = hurt_touch;
  if ( *(float *)(a1 + 644) != 0.0 )
  {
    *(_DWORD *)(a1 + 524) = level[123] + 50;
    *(_DWORD *)(a1 + 528) = hurt_think;
    *(float *)(a1 + 632) = (long double)(int)level[123] + *(float *)(a1 + 644) * 1000.0;
  }
}

//----- (00076981) --------------------------------------------------------
int __cdecl SP_trigger_hurt(int a1)
{
  int result; // eax
  float v2; // [esp+14h] [ebp-14h]
  char *s2; // [esp+18h] [ebp-10h] BYREF
  char *nptr; // [esp+1Ch] [ebp-Ch] BYREF

  InitTrigger(a1);
  G_SpawnString("sound", (int)"world_hurt_me", (int)&s2);
  *(_BYTE *)(a1 + 378) = G_SoundAliasIndex(s2);
  if ( !*(_DWORD *)(a1 + 584) )
    *(_DWORD *)(a1 + 584) = 5;
  *(_DWORD *)(a1 + 288) = 1079771144;
  *(_DWORD *)(a1 + 544) = hurt_use;
  if ( (*(_DWORD *)(a1 + 392) & 1) == 0 )
    *(_DWORD *)(a1 + 540) = hurt_touch;
  G_SpawnString("life", (int)"0", (int)&nptr);
  v2 = atof(nptr);
  result = LODWORD(v2);
  *(float *)(a1 + 644) = v2;
  return result;
}
// 178F4: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (00076A66) --------------------------------------------------------
int __cdecl SP_trigger_once(_DWORD *a1)
{
  a1[158] = -1082130432;
  a1[135] = Touch_Multi;
  a1[136] = Use_Multi;
  InitTrigger(a1);
  InitSentientTrigger(a1);
  return trap_LinkEntity(a1);
}
// 170E4: using guessed type _DWORD __cdecl InitSentientTrigger(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178F4: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (00076ACA) --------------------------------------------------------
int __cdecl Respond_trigger_damage(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-8h]

  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 && a2 == 1 )
    return 0;
  if ( (*(_DWORD *)(a1 + 392) & 2) != 0 && a2 == 2 )
    return 0;
  if ( (*(_DWORD *)(a1 + 392) & 4) != 0 && a2 >= 3 && (a2 <= 6 || (unsigned int)(a2 - 13) <= 1) )
    return 0;
  if ( (*(_DWORD *)(a1 + 392) & 8) != 0 )
  {
    switch ( a2 )
    {
      case 3:
      case 4:
      case 5:
      case 6:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 23:
        v3 = 0;
        break;
      default:
        goto LABEL_15;
    }
  }
  else
  {
LABEL_15:
    if ( (*(_DWORD *)(a1 + 392) & 0x10) != 0 )
    {
      switch ( a2 )
      {
        case 4:
        case 6:
        case 10:
        case 12:
        case 14:
          v3 = 0;
          break;
        default:
          goto LABEL_18;
      }
    }
    else
    {
LABEL_18:
      if ( (*(_DWORD *)(a1 + 392) & 0x20) != 0 && a2 == 7 )
      {
        v3 = 0;
      }
      else if ( (*(_DWORD *)(a1 + 392) & 0x100) != 0 )
      {
        switch ( a2 )
        {
          case 0:
          case 15:
          case 16:
          case 19:
          case 20:
          case 21:
          case 22:
            v3 = 0;
            break;
          default:
            goto LABEL_24;
        }
      }
      else
      {
LABEL_24:
        v3 = 1;
      }
    }
  }
  return v3;
}

//----- (00076C2F) --------------------------------------------------------
int (__cdecl *__cdecl Activate_trigger_damage(int a1, int a2, int (__cdecl *a3)(int), int a4))(int)
{
  int (__cdecl *result)(int); // eax
  long double v5; // fst6
  int (__cdecl *v6)(int); // [esp+24h] [ebp-14h]
  int (__cdecl *v7)(int); // [esp+28h] [ebp-10h]

  if ( *(_DWORD *)(a1 + 352) )
    v7 = *(int (__cdecl **)(int))(*(_DWORD *)(a1 + 352) + 17852);
  else
    v7 = *(int (__cdecl **)(int))(a1 + 732);
  if ( *(_DWORD *)(a2 + 352) )
    v6 = *(int (__cdecl **)(int))(*(_DWORD *)(a2 + 352) + 17852);
  else
    v6 = *(int (__cdecl **)(int))(a1 + 732);
  result = v7;
  if ( v7 == v6 || !v7 || !v6 )
  {
    if ( !*(_DWORD *)(a1 + 524) || (result = Think_GeneralLink, *(int (__cdecl **)(int))(a1 + 528) == Think_GeneralLink) )
    {
      if ( *(int *)(a1 + 696) <= 0 || (result = a3, (int)a3 >= *(_DWORD *)(a1 + 696)) )
      {
        result = (int (__cdecl *)(int))Respond_trigger_damage(a1, a4);
        if ( result )
        {
          if ( !*(_DWORD *)(a1 + 608)
            || (result = (int (__cdecl *)(int))a1, 32000 - *(_DWORD *)(a1 + 576) >= *(_DWORD *)(a1 + 608)) )
          {
            *(_DWORD *)(a1 + 620) = a2;
            if ( a4 != -1 )
              G_Trigger(a1, *(_DWORD *)(a1 + 620));
            if ( *(int (__cdecl **)(int))(a1 + 528) != Think_GeneralLink )
            {
              if ( *(float *)(a1 + 632) <= 0.0 )
              {
                *(_DWORD *)(a1 + 540) = 0;
                *(_DWORD *)(a1 + 524) = level[123] + 100;
                *(_DWORD *)(a1 + 528) = G_FreeEntity;
              }
              else
              {
                *(_DWORD *)(a1 + 528) = multi_wait;
                v5 = (long double)rand() / 2147483600.0;
                *(_DWORD *)(a1 + 524) = level[123]
                                      + (int)(((v5 + v5 - 1.0) * *(float *)(a1 + 636) + *(float *)(a1 + 632)) * 1000.0);
              }
            }
            result = (int (__cdecl *)(int))a1;
            *(_DWORD *)(a1 + 576) = 32000;
          }
        }
      }
    }
  }
  return result;
}
// 16C94: using guessed type _DWORD __cdecl Respond_trigger_damage(_DWORD, _DWORD);
// 179F4: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 78C40: using guessed type int __cdecl Think_GeneralLink(int);

//----- (00076E77) --------------------------------------------------------
int __cdecl Use_trigger_damage(int a1, int a2)
{
  return Activate_trigger_damage(a1, a2, *(_DWORD *)(a1 + 608) + 1, -1);
}
// 17954: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00076EB7) --------------------------------------------------------
int __cdecl Pain_trigger_damage(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  Activate_trigger_damage(a1, a2, a3, a5);
  result = a1;
  if ( !*(_DWORD *)(a1 + 608) )
  {
    result = a1;
    *(_DWORD *)(a1 + 576) = 32000;
  }
  return result;
}
// 17954: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00076F08) --------------------------------------------------------
int __cdecl Die_trigger_damage(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  Activate_trigger_damage(a1, a3, a4, a5);
  result = a1;
  if ( !*(_DWORD *)(a1 + 608) )
  {
    result = a1;
    *(_DWORD *)(a1 + 576) = 32000;
  }
  return result;
}
// 17954: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00076F59) --------------------------------------------------------
int __cdecl SP_trigger_damage(int a1)
{
  char v2; // [esp+4h] [ebp-14h]
  char *s1; // [esp+10h] [ebp-8h]

  s1 = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 488));
  G_SpawnFloat("wait", (int)&off_A5BD0, a1 + 632);
  G_SpawnFloat("random", (int)"0", a1 + 636);
  if ( *(float *)(a1 + 636) >= (long double)*(float *)(a1 + 632) && *(float *)(a1 + 632) >= 0.0 )
  {
    *(float *)(a1 + 636) = *(float *)(a1 + 632) - 100.0;
    G_Printf("trigger_damage has random >= wait\n", v2);
  }
  G_SpawnInt("accumulate", (int)"0", a1 + 608);
  G_SpawnInt("threshold", (int)"0", a1 + 696);
  *(_DWORD *)(a1 + 732) = 0;
  if ( s1 )
  {
    if ( !strcasecmp(s1, "axis") )
    {
      *(_DWORD *)(a1 + 732) = 1;
    }
    else if ( !strcasecmp(s1, "allies") )
    {
      *(_DWORD *)(a1 + 732) = 2;
    }
  }
  *(_DWORD *)(a1 + 576) = 32000;
  *(_BYTE *)(a1 + 381) = 1;
  *(_DWORD *)(a1 + 544) = Use_trigger_damage;
  *(_DWORD *)(a1 + 548) = Pain_trigger_damage;
  *(_DWORD *)(a1 + 552) = Die_trigger_damage;
  InitTrigger(a1);
  return trap_LinkEntity(a1);
}
// 77022: variable 'v2' is possibly undefined
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178F4: using guessed type _DWORD __cdecl InitTrigger(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// A5BD0: using guessed type void *off_A5BD0;

//----- (00077130) --------------------------------------------------------
int __cdecl G_CheckHitTriggerDamage(int a1, int *a2, int a3, int a4, int a5)
{
  int result; // eax
  _DWORD *v6; // [esp+2Ch] [ebp-105Ch]
  int v7[4]; // [esp+50h] [ebp-1038h] BYREF
  int v8[4]; // [esp+60h] [ebp-1028h] BYREF
  int v9[1026]; // [esp+70h] [ebp-1018h] BYREF
  int v10; // [esp+1078h] [ebp-10h]
  int i; // [esp+107Ch] [ebp-Ch]

  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v7[0] = *a2;
  v7[1] = a2[1];
  v7[2] = a2[2];
  AddPointToBounds(a3, v8, v7);
  v10 = trap_EntitiesInBox(v8, v7, v9, 1024, &unk_400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = &g_entities[211 * v9[i]];
    if ( *((_WORD *)v6 + 194) == scr_const[90] && trap_SightTraceToEntity(a2, vec3_origin, vec3_origin, a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, scr_const[13], 2);
      Activate_trigger_damage(v6, a1, a4, a5);
      if ( !v6[152] )
        v6[144] = 32000;
    }
  }
  return result;
}
// 16894: using guessed type _DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17954: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18924: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000773BF) --------------------------------------------------------
int __cdecl G_GrenadeTouchTriggerDamage(int a1, int *a2, int a3, int a4, int a5)
{
  int result; // eax
  _DWORD *v6; // [esp+2Ch] [ebp-103Ch]
  int v7[4]; // [esp+30h] [ebp-1038h] BYREF
  int v8[4]; // [esp+40h] [ebp-1028h] BYREF
  int v9[1026]; // [esp+50h] [ebp-1018h] BYREF
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v7[0] = *a2;
  v7[1] = a2[1];
  v7[2] = a2[2];
  AddPointToBounds(a3, v8, v7);
  v10 = trap_EntitiesInBox(v8, v7, v9, 1024, &unk_400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = &g_entities[211 * v9[i]];
    if ( *((_WORD *)v6 + 194) == scr_const[90]
      && *((__int16 *)v6 + 198) < 0
      && trap_SightTraceToEntity(a2, vec3_origin, vec3_origin, a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, scr_const[13], 2);
      Activate_trigger_damage(v6, a1, a4, a5);
      if ( !v6[152] )
        v6[144] = 32000;
    }
  }
  return result;
}
// 16894: using guessed type _DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17954: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18924: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000775B8) --------------------------------------------------------
int __cdecl explosive_indicator_think(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-8h]

  v2 = &g_entities[211 * a1[85]];
  if ( *((_BYTE *)v2 + 364) && *((_WORD *)v2 + 194) == scr_const[142] )
  {
    result = (int)a1;
    a1[131] = level[123] + 100;
  }
  else
  {
    a1[132] = G_FreeEntity;
    result = level[123] + 100;
    a1[131] = result;
  }
  return result;
}

//----- (00077654) --------------------------------------------------------
int __cdecl SP_trigger_lookat(_DWORD *a1)
{
  trap_SetBrushModel(a1);
  a1[72] = 0x20000000;
  a1[62] = 1;
  a1[2] |= 2u;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (000776AB) --------------------------------------------------------
int __cdecl Touch_trigger_mount(int a1, int a2)
{
  return G_Trigger(a1, a2);
}
// 179F4: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);

//----- (000776D5) --------------------------------------------------------
int __cdecl SP_trigger_mount(_DWORD *a1)
{
  int v1; // edx

  a1[135] = Touch_trigger_mount;
  InitTrigger(a1);
  if ( (a1[98] & 1) != 0 )
    v1 = a1[72] | 0x400000;
  else
    v1 = a1[72] | 0x4000;
  a1[72] = v1;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 178F4: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (00077754) --------------------------------------------------------
int __cdecl SP_trigger_mount_no_brush(_DWORD *a1, int a2)
{
  int v2; // eax

  a1[135] = Touch_trigger_mount;
  a1[72] = 1075576840;
  a1[62] = 1;
  a1[2] |= 2u;
  if ( a2 )
  {
    a1[98] |= 1u;
    v2 = a1[72] | 0x400000;
  }
  else
  {
    a1[98] &= 0xFFFFFFFE;
    v2 = a1[72] | 0x4000;
  }
  a1[72] = v2;
  return trap_LinkEntity(a1);
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0007780F) --------------------------------------------------------
int __cdecl G_CheckPointInsideTriggerMount(int a1, float *a2, _DWORD *a3)
{
  _DWORD *v5; // [esp+4Ch] [ebp-103Ch]
  float v6[4]; // [esp+50h] [ebp-1038h] BYREF
  float v7[4]; // [esp+60h] [ebp-1028h] BYREF
  int v8[1026]; // [esp+70h] [ebp-1018h] BYREF
  int v9; // [esp+1078h] [ebp-10h]
  int i; // [esp+107Ch] [ebp-Ch]

  v7[0] = *a2 - 0.1;
  v7[1] = a2[1] - 0.1;
  v7[2] = a2[2] - 0.1;
  v6[0] = *a2 + 0.1;
  v6[1] = a2[1] + 0.1;
  v6[2] = a2[2] + 0.1;
  v9 = trap_EntitiesInBox(v7, v6, v8, 1024, 1079771144);
  for ( i = 0; ; ++i )
  {
    if ( i >= v9 )
      return 0;
    v5 = &g_entities[211 * v8[i]];
    if ( *((_WORD *)v5 + 194) == scr_const[91] )
      break;
  }
  if ( a3 )
    *a3 = (v5[98] & 1) != 0;
  return 1;
}
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00077997) --------------------------------------------------------
void sub_77997()
{
  ;
}

//----- (0007799C) --------------------------------------------------------
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  char v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < a3; ++i )
  {
    s1 = (char *)trap_GetConfigstringConst(a2 + i);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( a4 )
  {
    if ( i == a3 )
      G_Error("G_FindConfigstringIndex: overflow", v7);
    trap_SetConfigstring(a2 + i, s2);
    v8 = i;
  }
  else
  {
    if ( a5 )
    {
      v5 = va("%s \"%s\" not precached", a5);
      Scr_Error(v5);
    }
    v8 = 0;
  }
  return v8;
}
// 77A63: variable 'v7' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18184: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);

//----- (00077A8C) --------------------------------------------------------
int __cdecl G_LocalizedStringIndex(char *s2)
{
  int v2; // [esp+20h] [ebp-8h]

  if ( *s2 )
    v2 = G_FindConfigstringIndex(
           s2,
           1397,
           256,
           level[8],
           (unsigned __int8)&aLocalizedStrin[-735256] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  else
    v2 = 0;
  return v2;
}
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00077AED) --------------------------------------------------------
int __cdecl G_ShaderIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 1653, 256, level[8], (char)"shader");
}

//----- (00077B37) --------------------------------------------------------
int __cdecl G_ModelIndex(char *s2)
{
  int v1; // eax
  char v3; // [esp+4h] [ebp-24h]
  char *s1; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !*s2 )
    return 0;
  for ( i = 1; i <= 255; ++i )
  {
    s1 = (char *)trap_GetConfigstringConst(i + 405);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( !level[8] )
  {
    v1 = va("model '%s' not precached", (char)s2);
    Scr_Error(v1);
  }
  if ( i == 256 )
    G_Error("G_ModelIndex: overflow", v3);
  *(int *)((char *)&dword_D3FC0 + (_DWORD)&dword_0[i]) = trap_XModelGet(s2);
  trap_SetConfigstring(i + 405, s2);
  return i;
}
// 77BED: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0[];
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17874: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 18184: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);
// 18714: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// D3FC0: using guessed type int dword_D3FC0;

//----- (00077C2E) --------------------------------------------------------
int __cdecl sub_77C2E(int a1)
{
  return *(int *)((char *)&dword_D3FC0 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// D3FC0: using guessed type int dword_D3FC0;

//----- (00077C4A) --------------------------------------------------------
int __cdecl G_ModelName(int a1)
{
  return trap_GetConfigstringConst(a1 + 405);
}
// 18184: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);

//----- (00077C72) --------------------------------------------------------
int __cdecl G_TagIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 117, 32, 1, 0);
}

//----- (00077CB5) --------------------------------------------------------
int __cdecl G_EffectIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 917, 80, level[8], (char)"effect");
}

//----- (00077CFF) --------------------------------------------------------
int __cdecl G_ShellShockIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 1253, 16, 1, 0);
}

//----- (00077D42) --------------------------------------------------------
int __cdecl G_SoundAliasIndex(char *s2)
{
  return (unsigned __int8)G_FindConfigstringIndex(s2, 661, 256, 1, 0);
}

//----- (00077D88) --------------------------------------------------------
int __cdecl G_GetGameId(_DWORD *a1)
{
  return (unsigned __int16)Scr_GetEntityId(*a1, 0);
}
// 181A4: using guessed type _DWORD __cdecl Scr_GetEntityId(_DWORD, _DWORD);

//----- (00077DB8) --------------------------------------------------------
int __cdecl G_UpdateTags(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 356) )
    G_UpdateVehicleTags(a1);
  return G_UpdateTagInfoOfChildren(a1, a2);
}
// 171E4: using guessed type _DWORD __cdecl G_UpdateTagInfoOfChildren(_DWORD, _DWORD);
// 188E4: using guessed type _DWORD __cdecl G_UpdateVehicleTags(_DWORD);

//----- (00077DF9) --------------------------------------------------------
int __cdecl G_DObjUpdate(int a1)
{
  int i; // [esp+28h] [ebp-A0h]
  int v3; // [esp+2Ch] [ebp-9Ch]
  _DWORD v4[2]; // [esp+30h] [ebp-98h] BYREF
  __int16 v5[2]; // [esp+38h] [ebp-90h]
  _DWORD v6[30]; // [esp+3Ch] [ebp-8Ch]
  unsigned __int16 v7; // [esp+B6h] [ebp-12h]
  int v8; // [esp+B8h] [ebp-10h]
  int v9; // [esp+BCh] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 352) )
    return G_UpdateClientInfo(a1);
  G_SafeDObjFree(a1);
  v9 = *(unsigned __int8 *)(a1 + 385);
  if ( !v9 )
    return G_UpdateTags(a1, 0);
  v7 = G_GetGameId(a1);
  v8 = sub_77C2E(v9);
  v4[0] = v8;
  v4[1] = 0;
  v5[0] = -(__int16)v9;
  v6[0] = 0;
  v3 = 1;
  if ( !*(_DWORD *)(a1 + 4)
    || *(_DWORD *)(a1 + 4) == 8
    || *(_DWORD *)(a1 + 4) == 11
    || *(_DWORD *)(a1 + 4) == 12
    || *(_DWORD *)(a1 + 4) == 13
    || *(_DWORD *)(a1 + 4) == 14 )
  {
    *(_DWORD *)(a1 + 144) = v9;
  }
  for ( i = 0; i <= 5; ++i )
  {
    v9 = *(unsigned __int8 *)(i + a1 + 764);
    if ( v9 )
    {
      v4[4 * v3] = sub_77C2E(v9);
      v4[4 * v3 + 1] = SL_ConvertToString(*(unsigned __int16 *)(a1 + 2 * i + 770));
      v5[8 * v3] = -(__int16)v9;
      v6[4 * v3++] = ((int)*(unsigned __int8 *)(a1 + 386) >> i) & 1;
    }
  }
  trap_DObjCreate(v4, (unsigned __int16)v3, 0, *(_DWORD *)a1, v7);
  return G_UpdateTags(a1, 1);
}
// 16BE4: using guessed type _DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17854: using guessed type _DWORD __cdecl G_SafeDObjFree(_DWORD);
// 17D54: using guessed type _DWORD __cdecl G_GetGameId(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18E14: using guessed type _DWORD __cdecl G_UpdateClientInfo(_DWORD);
// 192D4: using guessed type _DWORD __cdecl G_UpdateTags(_DWORD, _DWORD);
// 77DF9: using guessed type __int16 anonymous_0[2];

//----- (00078075) --------------------------------------------------------
int __cdecl G_SetModel(int a1, char *s2)
{
  int result; // eax
  unsigned __int8 v3; // [esp+10h] [ebp-8h]

  if ( *s2 )
  {
    v3 = G_ModelIndex(s2);
    result = v3;
    *(_BYTE *)(a1 + 385) = v3;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 385) = 0;
  }
  return result;
}

//----- (000780BC) --------------------------------------------------------
int __cdecl G_EntAttach(int a1, char *s2, int a3, int a4)
{
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    if ( i > 5 )
      return 0;
    if ( !*(_BYTE *)(i + a1 + 764) )
      break;
  }
  *(_BYTE *)(i + a1 + 764) = G_ModelIndex(s2);
  *(_WORD *)(a1 + 2 * i + 770) = SL_GetLowercaseString(a3, 0);
  if ( a4 )
    *(_BYTE *)(a1 + 386) |= 1 << i;
  G_DObjUpdate(a1);
  return 1;
}
// 16EB4: using guessed type _DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);

//----- (0007818A) --------------------------------------------------------
int __cdecl G_EntDetach(int a1, char *s2, int a3)
{
  const char *v3; // eax
  char v4; // al
  __int16 v7; // [esp+1Ah] [ebp-Eh]
  int i; // [esp+1Ch] [ebp-Ch]

  v7 = SL_FindLowercaseString(a3);
  if ( !v7 )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i > 5 )
      return 0;
    if ( *(_WORD *)(a1 + 2 * i + 770) == v7 )
    {
      v3 = (const char *)G_ModelName(*(unsigned __int8 *)(i + a1 + 764));
      if ( !strcasecmp(v3, s2) )
        break;
    }
  }
  *(_BYTE *)(i + a1 + 764) = 0;
  Scr_SetString(a1 + 2 * i + 770, 0);
  while ( i <= 4 )
  {
    *(_BYTE *)(i + a1 + 764) = *(_BYTE *)(i + a1 + 765);
    *(_WORD *)(a1 + 2 * i + 770) = *(_WORD *)(a1 + 2 * i + 772);
    if ( (((int)*(unsigned __int8 *)(a1 + 386) >> (i + 1)) & 1) != 0 )
      v4 = *(_BYTE *)(a1 + 386) | (1 << i);
    else
      v4 = *(_BYTE *)(a1 + 386) & ~(unsigned __int8)(1 << i);
    *(_BYTE *)(a1 + 386) = v4;
    ++i;
  }
  *(_BYTE *)(i + a1 + 764) = 0;
  *(_WORD *)(a1 + 2 * i + 770) = 0;
  *(_BYTE *)(a1 + 386) &= ~(unsigned __int8)(1 << i);
  G_DObjUpdate(a1);
  return 1;
}
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 17AC4: using guessed type _DWORD __cdecl SL_FindLowercaseString(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (00078358) --------------------------------------------------------
int __cdecl G_EntDetachAll(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 5; ++i )
  {
    *(_BYTE *)(i + a1 + 764) = 0;
    Scr_SetString(a1 + 2 * i + 770, 0);
  }
  *(_BYTE *)(a1 + 386) = 0;
  return G_DObjUpdate(a1);
}
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (000783C7) --------------------------------------------------------
int __cdecl sub_783C7(int a1, int a2, _BYTE *a3)
{
  __int16 v4; // [esp+Eh] [ebp-1Ah]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  G_EntUnlink(a1);
  if ( *a3 )
  {
    if ( !trap_DObjExists(a2) )
      return 0;
    v6 = trap_DObjGetBoneIndex(a2, a3);
    if ( v6 < 0 )
      return 0;
  }
  else
  {
    v6 = -1;
  }
  for ( i = a2; ; i = **(_DWORD **)(i + 756) )
  {
    if ( i == a1 )
      return 0;
    if ( !*(_DWORD *)(i + 756) )
      break;
  }
  v8 = MT_Alloc(112, 16);
  *(_DWORD *)v8 = a2;
  if ( *a3 )
    v4 = SL_GetLowercaseString(a3, 0);
  else
    v4 = 0;
  *(_WORD *)(v8 + 8) = v4;
  *(_DWORD *)(v8 + 4) = *(_DWORD *)(a2 + 760);
  *(_DWORD *)(v8 + 12) = v6;
  memset((void *)(v8 + 16), 0, 0x30u);
  *(_DWORD *)(a2 + 760) = a1;
  *(_DWORD *)(a1 + 756) = v8;
  memset((void *)(v8 + 64), 0, 0x30u);
  return 1;
}
// 16EB4: using guessed type _DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD);
// 174E4: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 193A4: using guessed type _DWORD __cdecl MT_Alloc(_DWORD, _DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (00078540) --------------------------------------------------------
int __cdecl G_EntLinkTo(int a1, int a2, _BYTE *a3)
{
  if ( !sub_783C7(a1, a2, a3) )
    return 0;
  G_CalcTagAxis(a1, 0);
  return 1;
}
// 16D54: using guessed type _DWORD __cdecl G_CalcTagAxis(_DWORD, _DWORD);

//----- (0007859B) --------------------------------------------------------
int __cdecl G_EntLinkToWithOffset(int a1, int a2, _BYTE *a3, _DWORD *a4, int a5)
{
  _DWORD *v7; // [esp+10h] [ebp-8h]

  if ( !sub_783C7(a1, a2, a3) )
    return 0;
  v7 = *(_DWORD **)(a1 + 756);
  AnglesToAxis(a5, v7 + 4);
  v7[13] = *a4;
  v7[14] = a4[1];
  v7[15] = a4[2];
  return 1;
}
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0007862B) --------------------------------------------------------
_DWORD *__cdecl G_EntUnlink(int a1)
{
  _DWORD *result; // eax
  int v2; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+20h] [ebp-8h]

  result = *(_DWORD **)(a1 + 756);
  v4 = result;
  if ( result )
  {
    G_SetOrigin(a1, a1 + 316);
    G_SetAngle(a1, a1 + 328);
    v2 = 0;
    for ( i = *(_DWORD *)(*v4 + 760); i != a1; i = *(_DWORD *)(*(_DWORD *)(i + 756) + 4) )
      v2 = i;
    if ( v2 )
      *(_DWORD *)(*(_DWORD *)(v2 + 756) + 4) = v4[1];
    else
      *(_DWORD *)(*v4 + 760) = v4[1];
    *(_DWORD *)(a1 + 756) = 0;
    Scr_SetString(v4 + 2, 0);
    result = (_DWORD *)MT_Free(v4, 112);
  }
  return result;
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 171B4: using guessed type _DWORD __cdecl MT_Free(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00078723) --------------------------------------------------------
int __cdecl G_EntIsLinkedTo(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  v4 = *(_DWORD **)(a1 + 756);
  v3 = 0;
  if ( v4 && *v4 == a2 )
    v3 = 1;
  return v3;
}

//----- (00078758) --------------------------------------------------------
int __cdecl G_UpdateTagInfo(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]

  v4 = *(_DWORD *)(a1 + 756);
  if ( *(_WORD *)(v4 + 8) )
  {
    if ( !a2
      || (v2 = SL_ConvertToString(*(unsigned __int16 *)(v4 + 8)),
          *(_DWORD *)(v4 + 12) = trap_DObjGetBoneIndex(*(_DWORD *)v4, v2),
          result = v4,
          *(int *)(v4 + 12) < 0) )
    {
      result = G_EntUnlink(a1);
    }
  }
  else
  {
    result = *(_DWORD *)(a1 + 756);
    *(_DWORD *)(v4 + 12) = -1;
  }
  return result;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (000787D6) --------------------------------------------------------
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)(a1 + 760);
  for ( i = result; i; i = v3 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(i + 756) + 4);
    G_UpdateTagInfo(i, a2);
    result = v3;
  }
  return result;
}
// 18F64: using guessed type _DWORD __cdecl G_UpdateTagInfo(_DWORD, _DWORD);

//----- (0007882B) --------------------------------------------------------
int __cdecl G_CalcTagParentAxis(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+1Ch] [ebp-4Ch]
  char v4[36]; // [esp+20h] [ebp-48h] BYREF
  int v5; // [esp+44h] [ebp-24h]
  int v6; // [esp+48h] [ebp-20h]
  int v7; // [esp+4Ch] [ebp-1Ch]
  _DWORD *v8; // [esp+58h] [ebp-10h]
  int *v9; // [esp+5Ch] [ebp-Ch]

  v9 = *(int **)(a1 + 756);
  v8 = (_DWORD *)*v9;
  if ( v9[3] < 0 )
  {
    AnglesToAxis(v8 + 82, a2);
    a2[9] = v8[79];
    a2[10] = v8[80];
    result = v8[81];
    a2[11] = result;
  }
  else
  {
    AnglesToAxis(v8 + 82, v4);
    v5 = v8[79];
    v6 = v8[80];
    v7 = v8[81];
    G_DObjCalcBone(v8, v9[3]);
    v3 = trap_DObjGetMatrixArray(v8);
    result = DObjSkelMatrixMultiply43(v3 + (v9[3] << 6), v4, a2);
  }
  return result;
}
// 16A14: using guessed type _DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD);
// 17084: using guessed type _DWORD __cdecl DObjSkelMatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 18584: using guessed type _DWORD __cdecl trap_DObjGetMatrixArray(_DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00078930) --------------------------------------------------------
int __cdecl G_CalcTagParentRelAxis(int a1, int a2)
{
  int v3; // [esp+1Ch] [ebp-3Ch]
  char v4[56]; // [esp+20h] [ebp-38h] BYREF

  v3 = *(_DWORD *)(a1 + 756);
  G_CalcTagParentAxis(a1, v4);
  return MatrixMultiply43(v3 + 64, v4, a2);
}
// 17CE4: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 18244: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);

//----- (00078982) --------------------------------------------------------
int __cdecl G_CalcTagAxis(_DWORD *a1, int a2)
{
  int result; // eax
  char v3[48]; // [esp+10h] [ebp-A8h] BYREF
  char v4[48]; // [esp+40h] [ebp-78h] BYREF
  char v5[36]; // [esp+70h] [ebp-48h] BYREF
  int v6; // [esp+94h] [ebp-24h]
  int v7; // [esp+98h] [ebp-20h]
  int v8; // [esp+9Ch] [ebp-1Ch]
  int v9; // [esp+ACh] [ebp-Ch]

  G_CalcTagParentAxis(a1, v4);
  AnglesToAxis(a1 + 82, v5);
  v9 = a1[189];
  if ( a2 )
  {
    MatrixTranspose(v4, v3);
    result = MatrixMultiply(v5, v3, v9 + 16);
  }
  else
  {
    MatrixInverseOrthogonal43(v4, v3);
    v6 = a1[79];
    v7 = a1[80];
    v8 = a1[81];
    result = MatrixMultiply43(v5, v3, v9 + 16);
  }
  return result;
}
// 16934: using guessed type _DWORD __cdecl MatrixInverseOrthogonal43(_DWORD, _DWORD);
// 17B94: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 17CE4: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 181E4: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);
// 18244: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00078A69) --------------------------------------------------------
void __cdecl G_SetFixedLink(int a1, int a2)
{
  char v2[48]; // [esp+20h] [ebp-78h] BYREF
  char v3[36]; // [esp+50h] [ebp-48h] BYREF
  int v4; // [esp+74h] [ebp-24h] BYREF
  int v5; // [esp+78h] [ebp-20h]
  int v6; // [esp+7Ch] [ebp-1Ch]
  int v7; // [esp+8Ch] [ebp-Ch]

  G_CalcTagParentAxis(a1, v2);
  v7 = *(_DWORD *)(a1 + 756);
  if ( a2 == 1 )
  {
    MatrixMultiply43(v7 + 16, v2, v3);
    *(_DWORD *)(a1 + 316) = v4;
    *(_DWORD *)(a1 + 320) = v5;
    *(_DWORD *)(a1 + 324) = v6;
    *(float *)(a1 + 332) = vectoyaw(v3);
  }
  else if ( a2 > 1 )
  {
    if ( a2 == 2 )
    {
      MatrixTransformVector43(v7 + 52, v2, &v4);
      *(_DWORD *)(a1 + 316) = v4;
      *(_DWORD *)(a1 + 320) = v5;
      *(_DWORD *)(a1 + 324) = v6;
    }
  }
  else if ( !a2 )
  {
    MatrixMultiply43(v7 + 16, v2, v3);
    *(_DWORD *)(a1 + 316) = v4;
    *(_DWORD *)(a1 + 320) = v5;
    *(_DWORD *)(a1 + 324) = v6;
    AxisToAngles(v3, a1 + 328);
  }
}
// 168D4: using guessed type long double __cdecl vectoyaw(_DWORD);
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 17CE4: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 18244: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 185C4: using guessed type _DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD);

//----- (00078BC8) --------------------------------------------------------
int __cdecl G_GeneralLink(int a1)
{
  G_SetFixedLink(a1, 0);
  G_SetOrigin(a1, a1 + 316);
  G_SetAngle(a1, a1 + 328);
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  return trap_LinkEntity(a1);
}
// 169C4: using guessed type _DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD);
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00078C40) --------------------------------------------------------
int __cdecl Think_GeneralLink(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 524) = level[123] + 50;
  result = a1;
  if ( *(_DWORD *)(a1 + 756) )
    result = G_GeneralLink(a1);
  return result;
}
// 186A4: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);
// 78C40: using guessed type int __cdecl Think_GeneralLink(int);

//----- (00078C87) --------------------------------------------------------
int __cdecl G_SafeDObjFree(_DWORD *a1)
{
  return trap_SafeDObjFree(*a1, 0);
}
// 16874: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);

//----- (00078CB4) --------------------------------------------------------
int __cdecl G_DObjUpdateServerTime(int a1, int a2)
{
  float v3; // [esp+4h] [ebp-14h]

  v3 = (long double)(int)level[125] * 0.001;
  return trap_DObjUpdateServerTime(a1, LODWORD(v3), a2);
}
// 18204: using guessed type _DWORD __cdecl trap_DObjUpdateServerTime(_DWORD, _DWORD, _DWORD);

//----- (00078CF6) --------------------------------------------------------
int __cdecl sub_78CF6(int a1, _DWORD *a2, float *a3, int a4)
{
  int result; // eax
  char v5[16]; // [esp+10h] [ebp-58h] BYREF
  int v6[4]; // [esp+20h] [ebp-48h] BYREF
  int v7[4]; // [esp+30h] [ebp-38h] BYREF
  int v8[7]; // [esp+40h] [ebp-28h] BYREF
  _DWORD *v9; // [esp+5Ch] [ebp-Ch]

  v9 = (_DWORD *)(32 * a4 + trap_DObjGetRotTransArray(a1));
  YawToQuaternion(a3[1], (int)v8);
  PitchToQuaternion(*a3, (int)v6);
  RollToQuaternion(a3[2], (int)v7);
  QuatMultiply(v6, v8, v5);
  QuatMultiply(v7, v5, v9);
  v9[4] = 0;
  v9[5] = *a2;
  v9[6] = a2[1];
  result = a2[2];
  v9[7] = result;
  return result;
}
// 17B74: using guessed type _DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD);
// 184A4: using guessed type _DWORD __cdecl trap_DObjGetRotTransArray(_DWORD);

//----- (00078DCC) --------------------------------------------------------
int __cdecl G_DObjSetLocalBoneIndex(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  if ( !trap_DObjSetRotTransIndex(a1, a2, a3) )
    return 0;
  sub_78CF6(a1, a4, a5, a3);
  return 1;
}
// 19324: using guessed type _DWORD __cdecl trap_DObjSetRotTransIndex(_DWORD, _DWORD, _DWORD);

//----- (00078E34) --------------------------------------------------------
int __cdecl G_DObjSetLocalTag(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  int v7; // [esp+20h] [ebp-8h]

  v7 = trap_DObjGetBoneIndex(a1, a3);
  if ( v7 < 0 )
    return 0;
  if ( !trap_DObjSetRotTransIndex(a1, a2, v7) )
    return 0;
  sub_78CF6(a1, a4, a5, v7);
  return 1;
}
// 19324: using guessed type _DWORD __cdecl trap_DObjSetRotTransIndex(_DWORD, _DWORD, _DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (00078EC0) --------------------------------------------------------
int __cdecl G_DObjSetControlTagAngles(int a1, int a2, int a3, float *a4)
{
  int v6; // [esp+20h] [ebp-8h]

  v6 = trap_DObjGetBoneIndex(a1, a3);
  if ( v6 < 0 )
    return 0;
  if ( !trap_DObjSetControlRotTransIndex(a1, a2, v6) )
    return 0;
  sub_78CF6(a1, vec3_origin, a4, v6);
  return 1;
}
// 19294: using guessed type _DWORD __cdecl trap_DObjSetControlRotTransIndex(_DWORD, _DWORD, _DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (00078F4F) --------------------------------------------------------
int __cdecl G_DObjCalcPose(int a1)
{
  int result; // eax
  char s[24]; // [esp+10h] [ebp-18h] BYREF

  memset(s, 255, 0x10u);
  result = trap_DObjCreateSkelForBones(a1, s);
  if ( !result )
  {
    trap_DObjCalcAnim(a1, s);
    if ( *(_DWORD *)(a1 + 560) )
      (*(void (__cdecl **)(int, char *))(a1 + 560))(a1, s);
    result = trap_DObjCalcSkel(a1, s);
  }
  return result;
}
// 16784: using guessed type _DWORD __cdecl trap_DObjCreateSkelForBones(_DWORD, _DWORD);
// 17A54: using guessed type _DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD);
// 19784: using guessed type _DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD);

//----- (00078FE2) --------------------------------------------------------
int __cdecl G_DObjCalcBone(int a1, int a2)
{
  int result; // eax
  char v3[24]; // [esp+10h] [ebp-18h] BYREF

  result = trap_DObjCreateSkelForBone(a1, a2);
  if ( !result )
  {
    trap_DObjGetHierarchyBits(a1, a2, v3);
    trap_DObjCalcAnim(a1, v3);
    if ( *(_DWORD *)(a1 + 560) )
      (*(void (__cdecl **)(int, char *))(a1 + 560))(a1, v3);
    result = trap_DObjCalcSkel(a1, v3);
  }
  return result;
}
// 178D4: using guessed type _DWORD __cdecl trap_DObjCreateSkelForBone(_DWORD, _DWORD);
// 17A54: using guessed type _DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD);
// 19784: using guessed type _DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD);
// 19794: using guessed type _DWORD __cdecl trap_DObjGetHierarchyBits(_DWORD, _DWORD, _DWORD);

//----- (00079073) --------------------------------------------------------
int __cdecl G_DObjGetLocalBoneIndexMatrix(int a1, int a2)
{
  G_DObjCalcBone(a1, a2);
  return trap_DObjGetMatrixArray(a1) + (a2 << 6);
}
// 16A14: using guessed type _DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD);
// 18584: using guessed type _DWORD __cdecl trap_DObjGetMatrixArray(_DWORD);

//----- (000790B4) --------------------------------------------------------
int __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD *a1, int a2, int a3)
{
  char v4[36]; // [esp+10h] [ebp-48h] BYREF
  int v5; // [esp+34h] [ebp-24h]
  int v6; // [esp+38h] [ebp-20h]
  int v7; // [esp+3Ch] [ebp-1Ch]
  int v8; // [esp+4Ch] [ebp-Ch]

  v8 = G_DObjGetLocalBoneIndexMatrix(a1, a2);
  AnglesToAxis(a1 + 82, v4);
  v5 = a1[79];
  v6 = a1[80];
  v7 = a1[81];
  return DObjSkel2MatrixMultiply43(v8, v4, a3);
}
// 16A94: using guessed type _DWORD __cdecl G_DObjGetLocalBoneIndexMatrix(_DWORD, _DWORD);
// 175A4: using guessed type _DWORD __cdecl DObjSkel2MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00079135) --------------------------------------------------------
int __cdecl G_DObjGetLocalTagMatrix(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-Ch]

  v4 = trap_DObjGetBoneIndex(a1, a2);
  if ( v4 < 0 )
    return 0;
  G_DObjCalcBone(a1, v4);
  return trap_DObjGetMatrixArray(a1) + (v4 << 6);
}
// 16A14: using guessed type _DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD);
// 18584: using guessed type _DWORD __cdecl trap_DObjGetMatrixArray(_DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (000791A0) --------------------------------------------------------
int __cdecl G_DObjGetWorldTagMatrix(_DWORD *a1, int a2, int a3)
{
  char v5[36]; // [esp+20h] [ebp-48h] BYREF
  int v6; // [esp+44h] [ebp-24h]
  int v7; // [esp+48h] [ebp-20h]
  int v8; // [esp+4Ch] [ebp-1Ch]
  int v9; // [esp+5Ch] [ebp-Ch]

  v9 = G_DObjGetLocalTagMatrix(a1, a2);
  if ( !v9 )
    return 0;
  AnglesToAxis(a1 + 82, v5);
  v6 = a1[79];
  v7 = a1[80];
  v8 = a1[81];
  DObjSkel2MatrixMultiply43(v9, v5, a3);
  return 1;
}
// 175A4: using guessed type _DWORD __cdecl DObjSkel2MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 18194: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0007923A) --------------------------------------------------------
_DWORD *__cdecl G_Find(int a1, int a2, __int16 a3)
{
  __int16 v5; // [esp+4h] [ebp-8h]
  _DWORD *v6; // [esp+14h] [ebp+8h]

  if ( a1 )
    v6 = (_DWORD *)(a1 + 844);
  else
    v6 = g_entities;
  while ( v6 < &g_entities[211 * level[3]] )
  {
    if ( *((_BYTE *)v6 + 364) )
    {
      v5 = *(_WORD *)((char *)v6 + a2);
      if ( v5 )
      {
        if ( v5 == a3 )
          return v6;
      }
    }
    v6 += 211;
  }
  return 0;
}

//----- (000792DB) --------------------------------------------------------
_DWORD *__cdecl G_FindStr(int a1, int a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  _DWORD *v6; // [esp+20h] [ebp+8h]

  if ( a1 )
    v6 = (_DWORD *)(a1 + 844);
  else
    v6 = g_entities;
  while ( v6 < &g_entities[211 * level[3]] )
  {
    if ( *((_BYTE *)v6 + 364) )
    {
      v5 = *(_DWORD *)((char *)v6 + a2);
      if ( v5 )
      {
        if ( !Q_stricmp(v5, a3) )
          return v6;
      }
    }
    v6 += 211;
  }
  return 0;
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0007937F) --------------------------------------------------------
int __cdecl G_PickTarget(unsigned __int16 a1)
{
  char v1; // al
  int v4[33]; // [esp+30h] [ebp-98h]
  int v5; // [esp+B4h] [ebp-14h]
  int v6; // [esp+B8h] [ebp-10h]
  unsigned __int16 v7; // [esp+BEh] [ebp-Ah]

  v7 = a1;
  v6 = 0;
  v5 = 0;
  if ( !a1 )
    return 0;
  do
  {
    v6 = G_Find(v6, 486, v7);
    if ( !v6 )
      break;
    v4[v5++] = v6;
  }
  while ( v5 != 32 );
  if ( v5 )
    return v4[rand() % v5];
  v1 = SL_ConvertToString(v7);
  G_Printf("G_PickTarget: target %s not found\n", v1);
  return 0;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18F24: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (00079467) --------------------------------------------------------
char *__cdecl vtos(float *a1)
{
  char *s; // [esp+20h] [ebp-8h]

  s = (char *)&unk_D3CA0 + 32 * dword_D3C80;
  dword_D3C80 = ((_BYTE)dword_D3C80 + 1) & 7;
  Com_sprintf(s, 0x20u, "(%i %i %i)", (int)*a1);
  return s;
}
// D3C80: using guessed type int dword_D3C80;

//----- (00079507) --------------------------------------------------------
char *__cdecl vtosf(float *a1)
{
  double v2; // [esp+Ch] [ebp-2Ch]
  char *s; // [esp+30h] [ebp-8h]

  s = (char *)&unk_D3DC0 + 64 * dword_D3DA0;
  dword_D3DA0 = ((_BYTE)dword_D3DA0 + 1) & 7;
  v2 = *a1;
  Com_sprintf(s, 0x40u, "(%f %f %f)", SLOBYTE(v2));
  return s;
}
// D3DA0: using guessed type int dword_D3DA0;

//----- (00079586) --------------------------------------------------------
int __cdecl G_SetMovedir(float *a1, _DWORD *a2)
{
  int result; // eax

  if ( *a1 == flt_AE90C && a1[1] == flt_AE910 && a1[2] == flt_AE914 )
  {
    *a2 = dword_AE918;
    a2[1] = dword_AE91C;
    a2[2] = dword_AE920;
  }
  else if ( *a1 == flt_AE924 && a1[1] == flt_AE928 && a1[2] == flt_AE92C )
  {
    *a2 = dword_AE930;
    a2[1] = dword_AE934;
    a2[2] = dword_AE938;
  }
  else
  {
    AngleVectors(a1, a2, 0, 0);
  }
  result = 0;
  a1[2] = 0.0;
  a1[1] = 0.0;
  *a1 = 0.0;
  return result;
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// AE90C: using guessed type float flt_AE90C;
// AE910: using guessed type float flt_AE910;
// AE914: using guessed type float flt_AE914;
// AE918: using guessed type int dword_AE918;
// AE91C: using guessed type int dword_AE91C;
// AE920: using guessed type int dword_AE920;
// AE924: using guessed type float flt_AE924;
// AE928: using guessed type float flt_AE928;
// AE92C: using guessed type float flt_AE92C;
// AE930: using guessed type int dword_AE930;
// AE934: using guessed type int dword_AE934;
// AE938: using guessed type int dword_AE938;

//----- (000796CE) --------------------------------------------------------
int __cdecl G_InitGentity(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 364) = 1;
  Scr_SetString(a1 + 388, scr_const[44]);
  *(_DWORD *)a1 = 1852331867 * ((a1 - (int)g_entities) >> 2);
  *(_DWORD *)(a1 + 340) = 1023;
  *(_DWORD *)(a1 + 400) = 0;
  *(_DWORD *)(a1 + 404) = 0;
  result = a1;
  *(_DWORD *)(a1 + 816) = 1023;
  return result;
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0007975B) --------------------------------------------------------
int G_Spawn()
{
  char v1; // [esp+4h] [ebp-34h]
  int v2; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v2 = level[4];
  if ( v2 )
  {
    level[4] = *(_DWORD *)(level[4] + 808);
    if ( !level[4] )
      level[5] = 0;
    *(_DWORD *)(v2 + 808) = 0;
  }
  else
  {
    if ( level[3] == 1022 )
    {
      for ( i = 0; i < level[3]; ++i )
      {
        if ( LOWORD(g_entities[211 * i + 97]) )
          SL_ConvertToString(LOWORD(g_entities[211 * i + 97]));
        G_Printf("%4i: '%s', origin: %f %f %f\n", i);
      }
      G_Error("G_Spawn: no free entities", v1);
    }
    v2 = level[1] + 844 * level[3]++;
    trap_LocateGameData(level[1], level[3], 844, level[0], 18228);
  }
  G_InitGentity(v2);
  return v2;
}
// 79880: variable 'v1' is possibly undefined
// 17514: using guessed type _DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18064: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);

//----- (00079937) --------------------------------------------------------
_DWORD *G_SpawnPlayerClone()
{
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *s; // [esp+10h] [ebp-8h]

  s = (_DWORD *)(level[1] + 844 * level[2180] + 54016);
  v1 = level[2180] + 1;
  level[2180] = v1 / 8;
  level[2180] = v1 - 8 * level[2180];
  v2 = s[2] & 8 ^ 8;
  if ( *((_BYTE *)s + 364) )
    G_FreeEntity(s);
  G_InitGentity(s);
  s[2] = v2;
  return s;
}
// 18064: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);

//----- (00079A06) --------------------------------------------------------
int *__cdecl G_FreeEntityRefs(int *a1)
{
  int *result; // eax
  int v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch] BYREF
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v3 = *a1;
  for ( i = 0; i < level[3]; ++i )
  {
    v5 = &g_entities[211 * i];
    if ( *((_BYTE *)v5 + 364) )
    {
      if ( (int *)v5[106] == a1 )
        v5[106] = 0;
      if ( v5[85] == v3 )
      {
        v5[85] = 1023;
        if ( v5[1] == 11 )
          *((_BYTE *)v5 + 382) = 0;
      }
      if ( v5[31] == v3 )
        v5[31] = 1023;
    }
  }
  for ( i = 0; i <= 63; ++i )
  {
    v5 = &g_entities[211 * i];
    if ( *((_BYTE *)v5 + 364) )
    {
      v2 = v5[88];
      if ( *(int **)(v2 + 18104) == a1 )
        *(_DWORD *)(v2 + 18104) = 0;
    }
  }
  result = (int *)G_FreeVehicleRefs(a1);
  for ( i = 0; i <= 31; ++i )
  {
    if ( (int *)level[i + 2145] == a1 )
      level[i + 2145] = 0;
    result = &i;
  }
  return result;
}
// 192A4: using guessed type _DWORD __cdecl G_FreeVehicleRefs(_DWORD);

//----- (00079B77) --------------------------------------------------------
int __cdecl G_FreeEntity(void *s)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  G_EntUnlink(s);
  while ( *((_DWORD *)s + 190) )
    G_EntUnlink(*((_DWORD *)s + 190));
  trap_UnlinkEntity(s);
  trap_SafeDObjFree(*(_DWORD *)s, 1);
  G_FreeEntityRefs(s);
  if ( *((_DWORD *)s + 90) )
    G_FreeTurret(s);
  if ( *((_DWORD *)s + 89) )
    G_FreeVehicle(s);
  Scr_FreeEntity(s);
  v2 = *((_DWORD *)s + 196);
  memset(s, 0, 0x34Cu);
  if ( 1852331867 * (((int)s - level[1]) >> 2) > 71 )
  {
    if ( level[5] )
      *(_DWORD *)(level[5] + 808) = s;
    else
      level[4] = s;
    level[5] = s;
    *(_DWORD *)(level[5] + 808) = 0;
  }
  result = v2 + 1;
  *((_DWORD *)s + 196) = v2 + 1;
  return result;
}
// 16874: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);
// 17544: using guessed type _DWORD __cdecl G_FreeTurret(_DWORD);
// 17D24: using guessed type _DWORD __cdecl Scr_FreeEntity(_DWORD);
// 18024: using guessed type _DWORD __cdecl G_FreeVehicle(_DWORD);
// 18074: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 18524: using guessed type _DWORD __cdecl G_FreeEntityRefs(_DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (00079CBA) --------------------------------------------------------
_DWORD *__cdecl G_TempEntity(int *a1, int a2)
{
  float v3; // [esp+20h] [ebp-28h] BYREF
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+28h] [ebp-20h]
  _DWORD *v6; // [esp+3Ch] [ebp-Ch]

  v6 = (_DWORD *)G_Spawn();
  v6[1] = a2 + 16;
  Scr_SetString(v6 + 97, scr_const[84]);
  v6[100] = level[123];
  v6[86] = level[123];
  v6[101] = 1;
  v3 = *(float *)a1;
  v4 = *((float *)a1 + 1);
  v5 = *((float *)a1 + 2);
  v3 = (float)(int)v3;
  v4 = (float)(int)v4;
  v5 = (float)(int)v5;
  G_SetOrigin(v6, &v3);
  trap_LinkEntity(v6);
  return v6;
}
// 167A4: using guessed type int G_Spawn(void);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00079DD9) --------------------------------------------------------
int __cdecl G_KillBox(int a1)
{
  int result; // eax
  float v2[4]; // [esp+30h] [ebp-1048h] BYREF
  float v3[7]; // [esp+40h] [ebp-1038h] BYREF
  _DWORD *v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  v3[0] = *(float *)(*(_DWORD *)(a1 + 352) + 20) + *(float *)(a1 + 264);
  v3[1] = *(float *)(*(_DWORD *)(a1 + 352) + 24) + *(float *)(a1 + 268);
  v3[2] = *(float *)(*(_DWORD *)(a1 + 352) + 28) + *(float *)(a1 + 272);
  v2[0] = *(float *)(*(_DWORD *)(a1 + 352) + 20) + *(float *)(a1 + 276);
  v2[1] = *(float *)(*(_DWORD *)(a1 + 352) + 24) + *(float *)(a1 + 280);
  v2[2] = *(float *)(*(_DWORD *)(a1 + 352) + 28) + *(float *)(a1 + 284);
  v6 = trap_EntitiesInBox(v3, v2, v5, 1024, 0x2000000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v4 = &g_entities[211 * v5[i]];
    if ( v4[88] )
    {
      if ( v4[61] )
        G_Damage(v4, a1, a1, 0, 0, 100000, 16, 19, 0);
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00079F7A) --------------------------------------------------------
int __cdecl G_AddPredictableEvent(int a1, int a2, char a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 352) )
    result = BG_AddPredictableEventToPlayerstate(a2, a3, *(_DWORD *)(a1 + 352));
  return result;
}
// 170F4: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (00079FBF) --------------------------------------------------------
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1[88] )
  {
    *(_DWORD *)(a1[88] + 4 * (*(_DWORD *)(a1[88] + 136) & 3) + 140) = a2;
    *(_DWORD *)(a1[88] + 4 * ((*(_DWORD *)(a1[88] + 136))++ & 3) + 156) = a3;
  }
  else
  {
    a1[(a1[42] & 3) + 43] = a2;
    a1[(a1[42]++ & 3) + 47] = a3;
  }
  a1[100] = level[123];
  result = level[123];
  a1[86] = result;
  return result;
}

//----- (0007A09D) --------------------------------------------------------
int __cdecl G_PlaySoundAliasAtPoint(int a1, unsigned __int8 a2)
{
  int v2; // edx

  if ( !a2 )
    return 0;
  v2 = G_TempEntity(a1, 177);
  *(_DWORD *)(v2 + 164) = a2;
  return v2;
}
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0007A0F6) --------------------------------------------------------
int __cdecl G_PlaySoundAlias(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( (_BYTE)a2 )
    result = G_AddEvent(a1, 177, (unsigned __int8)a2);
  return result;
}
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0007A135) --------------------------------------------------------
int __cdecl G_AnimScriptSound(int a1, char *s2)
{
  unsigned __int8 v2; // al

  v2 = G_SoundAliasIndex(s2);
  return G_PlaySoundAlias(&g_entities[211 * a1], v2);
}
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (0007A17A) --------------------------------------------------------
int __cdecl G_SetOrigin(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[6] = *a2;
  a1[7] = a2[1];
  a1[8] = a2[2];
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[11] = 0;
  a1[10] = 0;
  a1[9] = 0;
  a1[79] = *a2;
  a1[80] = a2[1];
  result = a2[2];
  a1[81] = result;
  return result;
}

//----- (0007A21B) --------------------------------------------------------
int __cdecl G_SetAngle(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[15] = *a2;
  a1[16] = a2[1];
  a1[17] = a2[2];
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[20] = 0;
  a1[19] = 0;
  a1[18] = 0;
  a1[82] = *a2;
  a1[83] = a2[1];
  result = a2[2];
  a1[84] = result;
  return result;
}

//----- (0007A2BC) --------------------------------------------------------
_BOOL4 __cdecl infront(float *a1, float *a2)
{
  float v3[7]; // [esp+20h] [ebp-38h] BYREF
  float v4; // [esp+3Ch] [ebp-1Ch]
  float v5; // [esp+40h] [ebp-18h] BYREF
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]

  AngleVectors(a1 + 82, v3, 0, 0);
  v5 = a2[79] - a1[79];
  v6 = a2[80] - a1[80];
  v7 = a2[81] - a1[81];
  VectorNormalize(&v5);
  v4 = v5 * v3[0] + v6 * v3[1] + v7 * v3[2];
  return v4 > 0.0;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007A387) --------------------------------------------------------
int DebugLine()
{
  return 0;
}

//----- (0007A391) --------------------------------------------------------
_WORD *__cdecl G_SetConstString(_WORD *a1, int a2)
{
  __int16 v2; // dx
  _WORD *result; // eax

  Scr_SetString(a1, 0);
  v2 = SL_GetString(a2, 0);
  result = a1;
  *a1 = v2;
  return result;
}
// 17814: using guessed type _DWORD __cdecl SL_GetString(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0007A3D7) --------------------------------------------------------
int __cdecl G_BackupSpawnVars(int a1)
{
  int result; // eax
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]

  *(_DWORD *)(a1 + 836) = trap_Hunk_AllocAlignInternal(level[1629], 1);
  *(_DWORD *)(a1 + 832) = level[1629];
  memcpy(*(void **)(a1 + 836), &level[1630], level[1629]);
  *(_DWORD *)(a1 + 828) = trap_Hunk_AllocAlignInternal(8 * level[1500], 1);
  *(_DWORD *)(a1 + 824) = level[1500];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[1500] )
      break;
    for ( j = 0; j <= 1; ++j )
      *(_DWORD *)(*(_DWORD *)(a1 + 828) + 4 * (j + 2 * i)) = -(int)level
                                                           - 6520
                                                           + level[2 * i + 1501 + j]
                                                           + *(_DWORD *)(a1 + 836);
  }
  return result;
}
// 18374: using guessed type _DWORD __cdecl trap_Hunk_AllocAlignInternal(_DWORD, _DWORD);

//----- (0007A51D) --------------------------------------------------------
void sub_7A51D()
{
  ;
}

//----- (0007A524) --------------------------------------------------------
void __cdecl Weapon_Melee(_DWORD *a1, float *a2)
{
  int v2; // esi
  int v3; // eax
  float v4[4]; // [esp+30h] [ebp-58h] BYREF
  int v5; // [esp+40h] [ebp-48h]
  int v6; // [esp+44h] [ebp-44h]
  int v7; // [esp+48h] [ebp-40h]
  _DWORD *v8; // [esp+4Ch] [ebp-3Ch]
  float v9; // [esp+50h] [ebp-38h] BYREF
  _BYTE v10[12]; // [esp+54h] [ebp-34h] BYREF
  _BYTE v11[24]; // [esp+60h] [ebp-28h] BYREF
  unsigned __int16 v12; // [esp+78h] [ebp-10h]
  unsigned __int16 v13; // [esp+7Ch] [ebp-Ch]

  v5 = 7;
  v4[0] = *a2 * 64.0 + a2[9];
  v4[1] = a2[1] * 64.0 + a2[10];
  v4[2] = a2[2] * 64.0 + a2[11];
  trap_LocationalTrace(&v9, a2 + 9, v4, *a1, 41951281, &bulletPriorityMap);
  v6 = *(_DWORD *)(BG_GetInfoForWeapon(a1[51]) + 540);
  G_CheckHitTriggerDamage(a1, a2 + 9, v10, v6, v5);
  if ( (v11[12] & 0x10) == 0 && v9 != 1.0 )
  {
    v8 = &g_entities[211 * v12];
    if ( v8[88] )
      v7 = G_TempEntity(v10, 171);
    else
      v7 = G_TempEntity(v10, 172);
    *(_DWORD *)(v7 + 116) = v12;
    v2 = v7;
    *(_DWORD *)(v2 + 164) = (unsigned __int8)DirToByte(v11);
    *(_DWORD *)(v7 + 204) = a1[51];
    if ( v12 != 1022 )
    {
      if ( *((_BYTE *)v8 + 381) )
      {
        v3 = rand();
        G_Damage(v8, a1, a1, a2, v10, v6 + v3 % 5, 0, v5, v13);
      }
    }
  }
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17944: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0007A745) --------------------------------------------------------
int *__cdecl SnapVectorTowards(int a1, int a2)
{
  int v2; // esi
  int *result; // eax
  int i; // [esp+18h] [ebp-10h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v2 = 4 * i;
    if ( *(float *)(a1 + 4 * i) < (long double)*(float *)(a2 + 4 * i) )
      *(float *)(a1 + v2) = ceil(*(float *)(a1 + 4 * i));
    else
      *(float *)(a1 + v2) = floor(*(float *)(a1 + 4 * i));
    result = &i;
  }
  return result;
}

//----- (0007A7F8) --------------------------------------------------------
long double __cdecl Damage_Falloff(float a1, int a2, float a3, int a4, int a5)
{
  float v6; // [esp+4h] [ebp-Ch]
  float v7; // [esp+8h] [ebp-8h]

  v7 = *(float *)&a2;
  if ( a1 > (long double)a4 )
  {
    if ( a1 <= (long double)a5 )
    {
      v6 = 1.0 - (a1 - (long double)a4) / (long double)(a5 - a4);
      v7 = ((100.0 - a3) * v6 + a3) * 0.0099999998 * *(float *)&a2;
    }
    else
    {
      v7 = a3 * 0.0099999998 * *(float *)&a2;
    }
  }
  if ( v7 < 0.0 )
    v7 = 0.0;
  return v7;
}

//----- (0007A8AF) --------------------------------------------------------
int __cdecl Bullet_Fire(int a1, float a2, int a3, int a4, int a5)
{
  int v6[6]; // [esp+20h] [ebp-18h] BYREF

  BG_Bullet_Endpos(a2, (int)v6, a4);
  return Bullet_Fire_Extended(a5, a1, a4 + 36, v6, a3, 0, a4, a5);
}
// 16B84: using guessed type _DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007A920) --------------------------------------------------------
int __cdecl Bullet_Fire_Extended(_DWORD *a1, _DWORD *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8)
{
  int v8; // esi
  int v9; // esi
  int v10; // edx
  long double v11; // fst7
  int v12; // edx
  char v14; // [esp+4h] [ebp-F4h]
  int v15; // [esp+4h] [ebp-F4h]
  float v16; // [esp+8h] [ebp-F0h]
  float v17; // [esp+3Ch] [ebp-BCh]
  float v18; // [esp+48h] [ebp-B0h]
  int v19; // [esp+50h] [ebp-A8h]
  int v20; // [esp+58h] [ebp-A0h]
  int v21; // [esp+58h] [ebp-A0h]
  _DWORD *v22; // [esp+58h] [ebp-A0h]
  float v23; // [esp+5Ch] [ebp-9Ch]
  float v24; // [esp+5Ch] [ebp-9Ch]
  float v25; // [esp+5Ch] [ebp-9Ch]
  float v26; // [esp+60h] [ebp-98h] BYREF
  float v27; // [esp+64h] [ebp-94h]
  float v28; // [esp+68h] [ebp-90h]
  float v29; // [esp+70h] [ebp-88h] BYREF
  float v30; // [esp+74h] [ebp-84h]
  float v31; // [esp+78h] [ebp-80h]
  float *v32; // [esp+88h] [ebp-70h]
  unsigned int v33; // [esp+8Ch] [ebp-6Ch]
  float v34; // [esp+90h] [ebp-68h] BYREF
  float v35; // [esp+94h] [ebp-64h]
  float v36; // [esp+98h] [ebp-60h]
  int v37; // [esp+ACh] [ebp-4Ch]
  int v38; // [esp+B0h] [ebp-48h]
  int v39; // [esp+B4h] [ebp-44h]
  float *v40; // [esp+B8h] [ebp-40h]
  int v41; // [esp+BCh] [ebp-3Ch]
  float v42; // [esp+C0h] [ebp-38h] BYREF
  float v43; // [esp+C4h] [ebp-34h] BYREF
  float v44; // [esp+C8h] [ebp-30h]
  float v45; // [esp+CCh] [ebp-2Ch]
  float v46; // [esp+D0h] [ebp-28h] BYREF
  float v47; // [esp+D4h] [ebp-24h]
  float v48; // [esp+D8h] [ebp-20h]
  int v49; // [esp+DCh] [ebp-1Ch]
  int v50; // [esp+E0h] [ebp-18h]
  unsigned __int16 v51; // [esp+E8h] [ebp-10h]
  unsigned __int16 v52; // [esp+ECh] [ebp-Ch]
  int v53; // [esp+110h] [ebp+18h]

  v39 = 0;
  v37 = 0;
  if ( a6 <= 12 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
    {
      v38 = 2;
      v39 = 32;
    }
    else
    {
      v38 = 1;
    }
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 796) )
      trap_LocationalTrace(&v42, a3, a4, *a1, 41951281, &riflePriorityMap);
    else
      trap_LocationalTrace(&v42, a3, a4, *a1, 41951281, &bulletPriorityMap);
    if ( (g_debugBullets[3] & 1) != 0 )
    {
      v41 = G_TempEntity(a3, 189);
      *(float *)(v41 + 92) = v43;
      *(float *)(v41 + 96) = v44;
      *(float *)(v41 + 100) = v45;
      *(_DWORD *)(v41 + 120) = *a2;
    }
    G_CheckHitTriggerDamage(a2, a3, &v43, a5, v38);
    v40 = (float *)&g_entities[211 * v51];
    if ( v42 >= 1.0 )
    {
      if ( a1 == a2 )
      {
        v24 = g_tracerChance[2];
        v21 = BG_GetInfoForWeapon(a8[51]);
        if ( v21 && (*(_DWORD *)(v21 + 144) == 3 || *(_DWORD *)(v21 + 144) == 4 || *(_DWORD *)(v21 + 144) == 5) )
          v24 = g_tracerChanceLMG[2];
        if ( v24 > (long double)rand() / 2147483600.0 )
        {
          v32 = (float *)G_TempEntity(a3, 176);
          v32[23] = *a4;
          v32[24] = a4[1];
          v32[25] = a4[2];
          v32[41] = **(float **)(a7 + 60);
        }
        v37 = 1;
      }
    }
    else
    {
      if ( g_debugBullets[3] <= -2 )
      {
        v29 = v40[79];
        v30 = v40[80];
        v31 = v40[81];
        v26 = v40[79];
        v27 = v40[80];
        v28 = v40[81];
        v29 = v29 + v40[66];
        v30 = v30 + v40[67];
        v31 = v31 + v40[68];
        v26 = v26 + v40[69];
        v27 = v27 + v40[70];
        v28 = v28 + v40[71];
        v32 = (float *)G_TempEntity(&v29, 189);
        v32[23] = v26;
        v32[24] = v27;
        v32[25] = v28;
        *((_DWORD *)v32 + 56) = 2;
      }
      v34 = *a4 - *a3;
      v35 = a4[1] - a3[1];
      v36 = a4[2] - a3[2];
      VectorNormalize(&v34);
      *(float *)&v33 = (v34 * v46 + v35 * v47 + v36 * v48) * -2.0;
      v34 = v46 * *(float *)&v33 + v34;
      v35 = v47 * *(float *)&v33 + v35;
      v36 = v48 * *(float *)&v33 + v36;
      if ( (v49 & 4) != 0 || *((_DWORD *)v40 + 88) )
      {
        if ( a1 == a2 || *((_DWORD *)v40 + 88) )
        {
          v23 = g_tracerChance[2];
          v32 = (float *)BG_GetInfoForWeapon(a8[51]);
          if ( v32 && (*((_DWORD *)v32 + 36) == 3 || *((_DWORD *)v32 + 36) == 4 || *((_DWORD *)v32 + 36) == 5) )
            v23 = g_tracerChanceLMG[2];
          if ( v23 > (long double)rand() / 2147483600.0 )
          {
            v20 = G_TempEntity(a3, 176);
            *(float *)(v20 + 92) = v43;
            *(float *)(v20 + 96) = v44;
            *(float *)(v20 + 100) = v45;
            *(_DWORD *)(v20 + 164) = **(_DWORD **)(a7 + 60);
          }
          v37 = 1;
        }
      }
      else if ( a1 == a2 || v52 )
      {
        v41 = G_TempEntity(&v43, 178);
        v8 = v41;
        *(_DWORD *)(v8 + 164) = (unsigned __int8)DirToByte(&v46);
        v9 = v41;
        *(_DWORD *)(v9 + 220) = (unsigned __int8)DirToByte(&v34);
        *(_DWORD *)(v41 + 136) = (v49 & 0x1F00000) >> 20;
        *(_DWORD *)(v41 + 204) = **(_DWORD **)(a7 + 60);
        *(_DWORD *)(v41 + 116) = *a8;
        if ( a2 && a2[88] && (a2[2] & 0x100000) != 0 )
        {
          *(_DWORD *)(v41 + 212) = a2[85] + 1;
          *(_DWORD *)(v41 + 208) = a2[34];
        }
        v37 = 1;
      }
    }
    if ( (v50 & 0x10) != 0 )
    {
      v26 = *a4 - *a3;
      v27 = a4[1] - a3[1];
      v28 = a4[2] - a3[2];
      VectorNormalize(&v26);
      v17 = v46 * v26 + v47 * v27 + v48 * v28;
      v33 = LODWORD(v17) ^ 0x80000000;
      if ( COERCE_FLOAT(LODWORD(v17) ^ 0x80000000) < 0.125 )
        v18 = 0.0;
      else
        v18 = 0.25 / *(float *)&v33;
      *a3 = v26 * v18 + v43;
      a3[1] = v27 * v18 + v44;
      a3[2] = v28 * v18 + v45;
      v10 = Bullet_Fire_Extended(a1, a2, a3, a4, a5, a6 + 1, a7, a8);
      v37 |= v10;
      v19 = v37;
    }
    else
    {
      if ( *((_BYTE *)v40 + 381) )
      {
        v25 = VectorDistance(a3, &v43);
        v16 = (float)*(int *)(*(_DWORD *)(a7 + 60) + 528);
        v11 = (long double)a5;
        *(float *)&v15 = v11;
        Damage_Falloff(v25, v15, v16, *(_DWORD *)(*(_DWORD *)(a7 + 60) + 532), *(_DWORD *)(*(_DWORD *)(a7 + 60) + 536));
        v53 = (int)v11;
        if ( (long double)(int)v11 > 0.0 )
        {
          v22 = a8;
          if ( !a8 )
            v22 = a2;
          if ( v22 == a2 && a2 && a2[88] && (a2[2] & 0x100000) != 0 && *(_DWORD *)(a2[88] + 1556) != 3 )
            v22 = &g_entities[211 * a2[85]];
          G_Damage(v40, v22, a2, a7, &v43, v53, v39, v38, v52);
          if ( *((_DWORD *)v40 + 88) && (v39 & 0x20) != 0 && (long double)v53 * 0.5 > 0.0 )
          {
            v12 = Bullet_Fire_Extended(v40, a2, &v43, a4, (int)((long double)v53 * 0.5), a6 + 1, a7, a8);
            v37 |= v12;
          }
        }
      }
      v19 = v37;
    }
  }
  else
  {
    Com_DPrintf("Bullet_Fire_Extended: Too many resursions, bullet aborted\n", v14);
    v19 = v37;
  }
  return v19;
}
// 7A953: variable 'v14' is possibly undefined
// 16B84: using guessed type _DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17944: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17DE4: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 190F4: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0007B2C4) --------------------------------------------------------
float *__cdecl weapon_grenadelauncher_fire(int a1, int a2, int a3)
{
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  float v7; // [esp+28h] [ebp-20h]
  float *v8; // [esp+3Ch] [ebp-Ch]

  v5 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 900) * *(float *)a3;
  v6 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 900) * *(float *)(a3 + 4);
  v7 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 900) * *(float *)(a3 + 8);
  v7 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 904) + v7;
  v8 = (float *)fire_grenade(a1, a3 + 36, &v5, a2);
  VectorNormalize(&v5);
  v4 = *(float *)(*(_DWORD *)(a1 + 352) + 32) * v5
     + *(float *)(*(_DWORD *)(a1 + 352) + 36) * v6
     + *(float *)(*(_DWORD *)(a1 + 352) + 40) * v7;
  v8[9] = v5 * v4 + v8[9];
  v8[10] = v6 * v4 + v8[10];
  v8[11] = v7 * v4 + v8[11];
  return v8;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18AB4: using guessed type _DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007B3DA) --------------------------------------------------------
int __cdecl Weapon_RocketLauncher_Fire(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-40h]
  int v5[4]; // [esp+20h] [ebp-38h] BYREF
  float v6; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h] BYREF
  float v11; // [esp+48h] [ebp-10h] BYREF
  float v12; // [esp+4Ch] [ebp-Ch]

  v12 = 16.0;
  v4 = tan(a2 * 3.141592653589793 / 180.0);
  v9 = v4 * 16.0;
  gunrandom(&v11, &v10);
  v11 = v11 * v9;
  v10 = v10 * v9;
  v6 = *(float *)a3 * v12;
  v7 = *(float *)(a3 + 4) * v12;
  v8 = *(float *)(a3 + 8) * v12;
  v6 = *(float *)(a3 + 12) * v11 + v6;
  v7 = *(float *)(a3 + 16) * v11 + v7;
  v8 = *(float *)(a3 + 20) * v11 + v8;
  v6 = *(float *)(a3 + 24) * v10 + v6;
  v7 = *(float *)(a3 + 28) * v10 + v7;
  v8 = *(float *)(a3 + 32) * v10 + v8;
  VectorNormalize(&v6);
  v5[0] = *(_DWORD *)(a3 + 36);
  v5[1] = *(_DWORD *)(a3 + 40);
  v5[2] = *(_DWORD *)(a3 + 44);
  fire_rocket(a1, v5, &v6);
  result = a1;
  if ( *(_DWORD *)(a1 + 352) )
  {
    *(float *)(*(_DWORD *)(a1 + 352) + 32) = *(float *)a3 * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 32);
    *(float *)(*(_DWORD *)(a1 + 352) + 36) = *(float *)(a3 + 4) * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 36);
    result = a3;
    *(float *)(*(_DWORD *)(a1 + 352) + 40) = *(float *)(a3 + 8) * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 40);
  }
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17ED4: using guessed type _DWORD __cdecl gunrandom(_DWORD, _DWORD);
// 18874: using guessed type _DWORD __cdecl fire_rocket(_DWORD, _DWORD, _DWORD);

//----- (0007B594) --------------------------------------------------------
int __cdecl Weapon_Artillery_Fire(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-40h]
  int v5[4]; // [esp+20h] [ebp-38h] BYREF
  float v6; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h] BYREF
  float v11; // [esp+48h] [ebp-10h] BYREF
  float v12; // [esp+4Ch] [ebp-Ch]

  v12 = 16.0;
  v4 = tan(a2 * 3.141592653589793 / 180.0);
  v9 = v4 * 16.0;
  gunrandom(&v11, &v10);
  v11 = v11 * v9;
  v10 = v10 * v9;
  v6 = *(float *)a3 * v12;
  v7 = *(float *)(a3 + 4) * v12;
  v8 = *(float *)(a3 + 8) * v12;
  v6 = *(float *)(a3 + 12) * v11 + v6;
  v7 = *(float *)(a3 + 16) * v11 + v7;
  v8 = *(float *)(a3 + 20) * v11 + v8;
  v6 = *(float *)(a3 + 24) * v10 + v6;
  v7 = *(float *)(a3 + 28) * v10 + v7;
  v8 = *(float *)(a3 + 32) * v10 + v8;
  VectorNormalize(&v6);
  v5[0] = *(_DWORD *)(a3 + 36);
  v5[1] = *(_DWORD *)(a3 + 40);
  v5[2] = *(_DWORD *)(a3 + 44);
  *(_DWORD *)(fire_rocket(a1, v5, &v6) + 12) = 5;
  result = a1;
  if ( *(_DWORD *)(a1 + 352) )
  {
    *(float *)(*(_DWORD *)(a1 + 352) + 32) = *(float *)a3 * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 32);
    *(float *)(*(_DWORD *)(a1 + 352) + 36) = *(float *)(a3 + 4) * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 36);
    result = a3;
    *(float *)(*(_DWORD *)(a1 + 352) + 40) = *(float *)(a3 + 8) * -64.0 + *(float *)(*(_DWORD *)(a1 + 352) + 40);
  }
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17ED4: using guessed type _DWORD __cdecl gunrandom(_DWORD, _DWORD);
// 18874: using guessed type _DWORD __cdecl fire_rocket(_DWORD, _DWORD, _DWORD);

//----- (0007B758) --------------------------------------------------------
int __cdecl Weapon_ArtilleryStrike_Fire(int a1, float a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // eax
  float v6[7]; // [esp+20h] [ebp-48h] BYREF
  int v7; // [esp+3Ch] [ebp-2Ch]
  int v8[6]; // [esp+50h] [ebp-18h] BYREF

  BG_Bullet_Endpos(a2, (int)v8, a3);
  trap_LocationalTrace(v6, a3 + 36, v8, *(_DWORD *)a1, 41951281, &bulletPriorityMap);
  if ( v6[0] >= 1.0 || (v7 & 4) != 0 )
  {
    v5 = BG_GetWeaponForInfo(*(_DWORD *)(a3 + 60));
    result = Add_Ammo(a1, v5, 1, 0);
  }
  else
  {
    *(float *)v8 = v6[1];
    *(float *)&v8[1] = v6[2];
    *(float *)&v8[2] = v6[3];
    v3 = BG_GetWeaponForInfo(*(_DWORD *)(a3 + 60));
    result = fire_artillery_barrage(a1, v8, v3);
  }
  return result;
}
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18794: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 18BC4: using guessed type _DWORD __cdecl BG_GetWeaponForInfo(_DWORD);
// 191B4: using guessed type _DWORD __cdecl fire_artillery_barrage(_DWORD, _DWORD, _DWORD);

//----- (0007B841) --------------------------------------------------------
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 381) )
    return 0;
  if ( a1 == a2 )
    return 0;
  if ( !*(_DWORD *)(a1 + 352) )
    return 0;
  if ( !*(_DWORD *)(a2 + 352) )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 352) + 4) <= 5 )
    return OnSameTeam(a1, a2) == 0;
  return 0;
}
// 17304: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);

//----- (0007B8EA) --------------------------------------------------------
void __cdecl CalcMuzzlePoint(_DWORD *a1, float *a2)
{
  long double v2; // fst7
  long double v3; // fst7
  char v4[4]; // [esp+20h] [ebp-98h] BYREF
  int v5; // [esp+24h] [ebp-94h]
  int v6; // [esp+28h] [ebp-90h]
  int v7; // [esp+2Ch] [ebp-8Ch]
  char v8; // [esp+4Eh] [ebp-6Ah]
  float v9[4]; // [esp+50h] [ebp-68h] BYREF
  float v10[4]; // [esp+60h] [ebp-58h] BYREF
  int v11[5]; // [esp+70h] [ebp-48h] BYREF
  int v12; // [esp+84h] [ebp-34h]
  float v13; // [esp+88h] [ebp-30h]
  float v14; // [esp+8Ch] [ebp-2Ch]
  float v15[6]; // [esp+90h] [ebp-28h] BYREF
  float v16; // [esp+A8h] [ebp-10h]
  float v17; // [esp+ACh] [ebp-Ch]

  *a2 = *(float *)(a1[88] + 20);
  a2[1] = *(float *)(a1[88] + 24);
  a2[2] = *(float *)(a1[88] + 28);
  if ( a1[88] && (*(_DWORD *)(a1[88] + 132) & 0x100000) != 0 )
    a2[2] = a2[2] + 28.0;
  else
    a2[2] = a2[2] + *(float *)(a1[88] + 248);
  if ( (*(_DWORD *)(a1[88] + 132) & 0x6000) == 0 )
  {
    v12 = BG_GetInfoForWeapon(a1[51]);
    if ( *(_DWORD *)(v12 + 128) == 3 && (*(_DWORD *)(a1[88] + 12) & 0x20) != 0 )
    {
      v11[0] = 0;
      v11[1] = *(_DWORD *)(a1[88] + 1444);
      v11[2] = 0;
      AngleVectors(v11, v10, 0, 0);
      v9[0] = v10[0] * 19.0 + *a2;
      v9[1] = v10[1] * 19.0 + a2[1];
      v9[2] = v10[2] * 19.0 + a2[2];
      trap_Trace(v4, a2, &unk_AE93C, &unk_AE948, v9, *a1, 17);
      if ( !v8 )
      {
        *(_DWORD *)a2 = v5;
        *((_DWORD *)a2 + 1) = v6;
        *((_DWORD *)a2 + 2) = v7;
      }
    }
    v14 = BG_GetBobCycle(a1[88]);
    v2 = BG_GetSpeed(a1[88], level[123]);
    v13 = v2;
    BG_GetVerticalBobFactor(a1[88], v14, v13, bg_bobMax[2]);
    v17 = v2;
    v3 = a2[2] + v17;
    a2[2] = v3;
    BG_GetHorizontalBobFactor(a1[88], v14, v13, bg_bobMax[2]);
    v16 = v3;
    AngleVectors(a1[88] + 232, 0, v15, 0);
    *a2 = v15[0] * v16 + *a2;
    a2[1] = v15[1] * v16 + a2[1];
    a2[2] = v15[2] * v16 + a2[2];
    G_AddLean(a1, a2);
    if ( *(float *)(a1[88] + 28) + 8.0 > a2[2] )
      a2[2] = *(float *)(a1[88] + 28) + 8.0;
  }
}
// 16C44: using guessed type double __cdecl BG_GetBobCycle(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18274: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 18DC4: using guessed type long double __cdecl BG_GetSpeed(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007BC58) --------------------------------------------------------
int __cdecl CalcMuzzlePoints(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h] BYREF
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 232);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 236);
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 240);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 18000);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 18004);
  AngleVectors(&v3, a2, a2 + 12, a2 + 24);
  return CalcMuzzlePoint(a1, a2 + 36);
}
// 169E4: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007BD05) --------------------------------------------------------
int __cdecl FireWeapon(int a1)
{
  int result; // eax
  int v2[15]; // [esp+20h] [ebp-58h] BYREF
  int v3; // [esp+5Ch] [ebp-1Ch]
  float v4; // [esp+64h] [ebp-14h]
  float v5; // [esp+68h] [ebp-10h]
  float v6; // [esp+6Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x106000) == 0
    || !*(_BYTE *)(a1 + 382)
    || (result = BG_AllowPlayerWeaponAtVehiclePos(
                   *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1560),
                   *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1556))) != 0 )
  {
    v3 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
    CalcMuzzlePoints(a1, v2);
    v6 = *(float *)(*(_DWORD *)(a1 + 352) + 18072);
    v4 = BG_GetMinSpreadForWeapon(
           *(_DWORD *)(a1 + 352),
           *(_DWORD *)(a1 + 204),
           level[123],
           1.0 == *(float *)(*(_DWORD *)(a1 + 352) + 224));
    v5 = (*(float *)(v3 + 676) - v4) * v6 + v4;
    if ( *(_DWORD *)(v3 + 124) )
    {
      switch ( *(_DWORD *)(v3 + 124) )
      {
        case 1:
          result = weapon_grenadelauncher_fire(a1, *(_DWORD *)(a1 + 204), v2);
          break;
        case 2:
          result = Weapon_RocketLauncher_Fire(a1, v5, (int)v2);
          break;
        case 3:
          result = Weapon_ArtilleryStrike_Fire(a1, v5, (int)v2);
          break;
        default:
          result = v3;
          if ( *(_DWORD *)(v3 + 124) != 4 )
            result = G_Error("Unknown weapon type %i for %s\n", *(_DWORD *)(v3 + 124));
          break;
      }
    }
    else
    {
      result = Bullet_Fire(a1, v5, *(_DWORD *)(v3 + 520), (int)v2, a1);
    }
  }
  return result;
}
// 167B4: using guessed type double __cdecl BG_GetMinSpreadForWeapon(_DWORD, _DWORD, _DWORD, _DWORD);
// 16904: using guessed type _DWORD __cdecl weapon_grenadelauncher_fire(_DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18264: using guessed type _DWORD __cdecl BG_AllowPlayerWeaponAtVehiclePos(_DWORD, _DWORD);
// 18CD4: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);

//----- (0007BEF7) --------------------------------------------------------
int __cdecl FireWeaponMelee(int a1)
{
  int result; // eax
  char v2[12]; // [esp+10h] [ebp-48h] BYREF
  int v3; // [esp+1Ch] [ebp-3Ch] BYREF
  int v4; // [esp+28h] [ebp-30h] BYREF
  _DWORD v5[9]; // [esp+34h] [ebp-24h] BYREF

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 352) + 132) & 0x106000) == 0 || (result = a1, !*(_BYTE *)(a1 + 382)) )
  {
    v5[6] = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 204));
    AngleVectors(*(_DWORD *)(a1 + 352) + 232, v2, &v3, &v4);
    CalcMuzzlePoint(a1, v5);
    result = Weapon_Melee(a1, v2);
  }
  return result;
}
// 169E4: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 169F4: using guessed type _DWORD __cdecl Weapon_Melee(_DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0007BFA1) --------------------------------------------------------
void sub_7BFA1()
{
  ;
}

//----- (0007BFA8) --------------------------------------------------------
char *__cdecl sub_7BFA8(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (0007BFD2) --------------------------------------------------------
int __cdecl sub_7BFD2(int a1, int a2, int a3, int a4, int a5)
{
  int v6[6]; // [esp+20h] [ebp-18h] BYREF

  v6[0] = a3;
  v6[1] = a4;
  v6[2] = a5;
  v6[3] = 1065353216;
  return G_DebugLine(a1, a2, v6, 1, 0);
}
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007C02C) --------------------------------------------------------
int __cdecl sub_7C02C(int a1, float a2, int a3, int a4, int a5)
{
  float v6[4]; // [esp+20h] [ebp-38h] BYREF
  float v7[4]; // [esp+30h] [ebp-28h] BYREF
  int v8[6]; // [esp+40h] [ebp-18h] BYREF

  v8[0] = a3;
  v8[1] = a4;
  v8[2] = a5;
  v8[3] = 1065353216;
  v7[0] = a2 * 0.5 + *(float *)a1;
  v7[1] = a2 * 0.5 + *(float *)(a1 + 4);
  v7[2] = a2 * 0.5 + *(float *)(a1 + 8);
  v6[0] = *(float *)a1 - a2 * 0.5;
  v6[1] = *(float *)(a1 + 4) - a2 * 0.5;
  v6[2] = *(float *)(a1 + 8) - a2 * 0.5;
  return G_DebugBox(v7, v6, v8, 1, 0);
}
// 190A4: using guessed type _DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007C110) --------------------------------------------------------
int __cdecl sub_7C110(int a1, float a2, float a3, int a4, int a5, int a6)
{
  int v7[4]; // [esp+20h] [ebp-28h] BYREF
  int v8[6]; // [esp+30h] [ebp-18h] BYREF

  v8[0] = a4;
  v8[1] = a5;
  v8[2] = a6;
  v8[3] = 1065353216;
  v7[0] = *(_DWORD *)a1;
  v7[1] = *(_DWORD *)(a1 + 4);
  *(float *)&v7[2] = *(float *)(a1 + 8) + a3;
  G_DebugCircle(a1, a2, (int)v8, 1, 1, 0);
  return G_DebugCircle((int)v7, a2, (int)v8, 1, 1, 0);
}

//----- (0007C1CA) --------------------------------------------------------
int __cdecl VEH_ParseSpecificField(int a1, char *s1, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  if ( a3 == 8 )
  {
    for ( i = 0; i <= 5; ++i )
    {
      if ( !strcasecmp(s1, *(const char **)((char *)off_AE960 + (_DWORD)&dword_0[i])) )
      {
        *(_WORD *)(a1 + 64) = i;
        break;
      }
    }
    if ( i == 6 )
      Com_Error(1, byte_A67FC, (char)s1);
    v4 = 1;
  }
  else
  {
    Com_Error(1, byte_A6817, a3);
    v4 = 0;
  }
  return v4;
}
// 0: using guessed type int dword_0[];
// AE960: using guessed type char *off_AE960[25];

//----- (0007C280) --------------------------------------------------------
_DWORD *__cdecl sub_7C280(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = 0;
  if ( a1 > 1023 )
  {
    v3 = va("i is not a valid entity number\n", a1);
    Scr_Error(v3);
  }
  else
  {
    v5 = &g_entities[211 * a1];
    if ( *((_WORD *)v5 + 194) != scr_const[65] )
    {
      v1 = va("entity %i is not a script_vehicle\n", a1);
      Scr_Error(v1);
    }
    if ( !v5[89] )
    {
      v2 = va("entity %i doesn't have a script_vehicle\n", a1);
      Scr_Error(v2);
    }
  }
  return v5;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0007C33F) --------------------------------------------------------
int __cdecl sub_7C33F(char *s1)
{
  __int16 i; // [esp+Eh] [ebp-Ah]

  if ( !s1 || !*s1 )
    return -1;
  for ( i = 0; i < word_F35C0; ++i )
  {
    if ( !strcasecmp(s1, &byte_E3EC0[988 * i]) )
      return i;
  }
  return -1;
}
// F35C0: using guessed type __int16 word_F35C0;

//----- (0007C3CE) --------------------------------------------------------
_DWORD *__cdecl sub_7C3CE(char *s2)
{
  const char *v1; // eax
  int i; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  for ( i = 0; i < level[3]; ++i )
  {
    v5 = &g_entities[211 * i];
    if ( *((_BYTE *)v5 + 364) )
    {
      if ( *((_WORD *)v5 + 194) == scr_const[67] )
      {
        v1 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v5 + 243));
        if ( !strcasecmp(v1, s2) )
          return &g_entities[211 * i];
      }
    }
  }
  return 0;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0007C488) --------------------------------------------------------
int __cdecl sub_7C488(int a1, int a2, _DWORD *a3)
{
  char v3; // al
  int result; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (_DWORD *)G_DObjGetLocalTagMatrix(a1, *(char **)((char *)off_AE978 + (_DWORD)&dword_0[a2]));
  if ( !v5 )
  {
    v3 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 486));
    Com_Error(1, byte_A68E0, v3);
  }
  *a3 = v5[12];
  a3[1] = v5[13];
  result = v5[14];
  a3[2] = result;
  return result;
}
// 0: using guessed type int dword_0[];
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18194: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// AE978: using guessed type char *off_AE978[19];

//----- (0007C525) --------------------------------------------------------
long double __cdecl sub_7C525(float a1, float a2, float a3)
{
  float v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+Ch] [ebp-8h]

  v6 = a1 - a2;
  if ( v6 <= 0.0 )
    v5 = -a3 * 0.050000001;
  else
    v5 = a3 * 0.050000001;
  if ( fabs(v6) <= 0.001000000047497451 )
    return a1;
  if ( fabs(v5) <= fabs(v6) )
    return (float)(a2 + v5);
  return a1;
}

//----- (0007C5C5) --------------------------------------------------------
long double __cdecl sub_7C5C5(float a1, float a2, float a3)
{
  float v5; // [esp+4h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-8h]

  v6 = a1 - a2;
  v5 = a3 * v6 * 0.050000001;
  if ( fabs(v6) <= 0.001000000047497451 )
    return a1;
  if ( fabs(v5) <= fabs(v6) )
    return (float)(a2 + v5);
  return a1;
}

//----- (0007C63C) --------------------------------------------------------
int __cdecl sub_7C63C(float a1, float a2, float a3)
{
  float v4; // [esp+Ch] [ebp-Ch]

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_7C525(a1, a2, a3);
  return AngleNormalize180(v4);
}

//----- (0007C6CF) --------------------------------------------------------
int __cdecl sub_7C6CF(float a1, float a2, float a3)
{
  float v4; // [esp+Ch] [ebp-Ch]

  while ( a1 - a2 > 180.0 )
    a1 = a1 - 360.0;
  while ( a1 - a2 < -180.0 )
    a1 = a1 + 360.0;
  v4 = sub_7C5C5(a1, a2, a3);
  return AngleNormalize180(v4);
}

//----- (0007C762) --------------------------------------------------------
void __cdecl sub_7C762(int a1, float *a2, float *a3)
{
  if ( *(float *)(a1 + 316) != *a2
    || *(float *)(a1 + 320) != a2[1]
    || *(float *)(a1 + 324) != a2[2]
    || *(float *)(a1 + 24) != *a2
    || *(float *)(a1 + 28) != a2[1]
    || *(float *)(a1 + 32) != a2[2]
    || *(float *)(a1 + 328) != *a3
    || *(float *)(a1 + 332) != a3[1]
    || *(float *)(a1 + 336) != a3[2]
    || *(float *)(a1 + 60) != *a3
    || *(float *)(a1 + 64) != a3[1]
    || *(float *)(a1 + 68) != a3[2] )
  {
    G_SetOrigin(a1, a2);
    G_SetAngle(a1, a3);
    *(_DWORD *)(a1 + 12) = 1;
    *(_DWORD *)(a1 + 48) = 1;
    if ( *(_DWORD *)(a1 + 244) )
      trap_LinkEntity(a1);
  }
}
// 16D94: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0007C935) --------------------------------------------------------
char *__cdecl sub_7C935(int a1, int a2, __int16 a3)
{
  int v3; // eax
  unsigned __int8 v4; // al
  int v5; // eax
  unsigned __int8 v6; // al
  int v7; // eax
  char *result; // eax
  unsigned __int8 v9; // al
  unsigned __int8 v10; // al
  char *v11; // [esp+18h] [ebp-10h]

  v11 = &byte_E3EC0[988 * a3];
  *(_DWORD *)(a1 + 528) = Scr_Vehicle_Init;
  *(_DWORD *)(a1 + 548) = Scr_Vehicle_Pain;
  *(_DWORD *)(a1 + 552) = Scr_Vehicle_Die;
  *(_DWORD *)(a1 + 540) = Scr_Vehicle_Touch;
  *(_DWORD *)(a1 + 544) = Scr_Vehicle_Use;
  *(_DWORD *)(a1 + 560) = Scr_Vehicle_Controller;
  *(_DWORD *)(a1 + 248) = 4;
  *(_DWORD *)(a1 + 288) = 8320;
  if ( (*(_DWORD *)(a1 + 392) & 1) != 0 )
    *(_DWORD *)(a1 + 288) |= 0x200000u;
  *(_DWORD *)(a1 + 4) = 12;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 228) = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( v11 != (char *)-140 && v11[140] )
    *(_DWORD *)(a1 + 204) = (unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v11 - 116);
  *(_DWORD *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 136) = *((__int16 *)v11 + 32);
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  *(_DWORD *)(a1 + 92) = 127;
  *(_DWORD *)(a1 + 100) = 127;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 356) = a2;
  *(_DWORD *)(a1 + 524) = level[123] + 50;
  *(_BYTE *)(a1 + 381) = 1;
  *(_DWORD *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 382) = 0;
  *(_DWORD *)(a1 + 416) = 513;
  *(_DWORD *)(a1 + 396) |= 0x20000u;
  G_DObjUpdate(a1);
  trap_DObjGetBounds(a1, a1 + 264, a1 + 276);
  trap_LinkEntity(a1);
  if ( !level[8] && !IsItemRegistered(*(_DWORD *)(a1 + 204)) )
  {
    v3 = va("vehicle '%s' not precached", (char)v11);
    Scr_Error(v3);
  }
  if ( !level[8] && v11 != (char *)-204 )
  {
    v4 = BG_GetWeaponIndexForName((_BYTE)v11 - 52);
    if ( !IsItemRegistered(v4) )
    {
      v5 = va("vehicle '%s' not precached", (char)v11);
      Scr_Error(v5);
    }
  }
  if ( !level[8] && v11 != (char *)-288 )
  {
    v6 = BG_GetWeaponIndexForName((_BYTE)v11 + 32);
    if ( !IsItemRegistered(v6) )
    {
      v7 = va("vehicle '%s' not precached", (char)v11);
      Scr_Error(v7);
    }
  }
  result = (char *)RegisterItem(*(_DWORD *)(a1 + 204), 1);
  if ( v11 != (char *)-204 )
  {
    result = &byte_E3EC0[988 * a3];
    if ( v11[204] )
    {
      v9 = BG_GetWeaponIndexForName((_BYTE)v11 - 52);
      result = (char *)RegisterItem(v9, 1);
    }
  }
  if ( v11 != (char *)-288 )
  {
    result = &byte_E3EC0[988 * a3];
    if ( v11[288] )
    {
      v10 = BG_GetWeaponIndexForName((_BYTE)v11 + 32);
      result = (char *)RegisterItem(v10, 1);
    }
  }
  return result;
}
// 16B54: using guessed type _DWORD __cdecl trap_DObjGetBounds(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 172C4: using guessed type _DWORD __cdecl IsItemRegistered(_DWORD);
// 17374: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 8C2D2: using guessed type int __cdecl Scr_Vehicle_Controller(int, int);
// 8C5AB: using guessed type int __cdecl Scr_Vehicle_Init(int);
// 8D1CA: using guessed type int __cdecl Scr_Vehicle_Pain(int, int, int, int, int, int);
// 8DC43: using guessed type int __cdecl Scr_Vehicle_Use(int, int);
// 8DCCB: using guessed type int __cdecl Scr_Vehicle_Die(int, int, int, int, int, int, int);

//----- (0007CD00) --------------------------------------------------------
int __cdecl VEH_InitPhysics(_DWORD *a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-18h]
  _DWORD *v3; // [esp+4h] [ebp-14h]
  _DWORD *v4; // [esp+8h] [ebp-10h]

  v4 = (_DWORD *)a1[89];
  v3 = v4 + 46;
  v4[46] = a1[79];
  v4[47] = a1[80];
  v4[48] = a1[81];
  v4[49] = a1[79];
  v4[50] = a1[80];
  v4[51] = a1[81];
  v4[52] = a1[82];
  v4[53] = a1[83];
  v4[54] = a1[84];
  v4[55] = a1[82];
  v4[56] = a1[83];
  v4[57] = a1[84];
  v4[60] = 0;
  v4[59] = 0;
  v4[58] = 0;
  v4[63] = 0;
  v4[62] = 0;
  v4[61] = 0;
  v4[66] = 0;
  v4[65] = 0;
  v4[64] = 0;
  v4[70] = 0;
  v4[69] = 0;
  v4[68] = 0;
  v4[73] = 0;
  v4[72] = 0;
  v4[71] = 0;
  for ( i = 0; i <= 5; ++i )
  {
    v3[i + 28] = 0;
    v3[i + 34] = 0;
    v3[i + 40] = 0;
  }
  result = 184;
  qmemcpy(v4 + 92, v3, 0xB8u);
  return result;
}

//----- (0007CEBF) --------------------------------------------------------
void __cdecl sub_7CEBF(int a1, int a2, __int16 a3)
{
  _DWORD *v3; // eax
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h]
  _DWORD *v9; // [esp+24h] [ebp-14h]
  _DWORD *v10; // [esp+24h] [ebp-14h]
  _DWORD *v11; // [esp+24h] [ebp-14h]
  char *v12; // [esp+28h] [ebp-10h]

  v12 = &byte_E3EC0[988 * a3];
  *(_DWORD *)(a1 + 116) = 1023;
  G_VehInitPathPos(a2);
  VEH_InitPhysics(a1);
  *(_DWORD *)(a2 + 552) = *(_DWORD *)a1;
  *(_WORD *)(a2 + 556) = a3;
  *(_WORD *)(a2 + 568) = -1;
  *(_DWORD *)(a2 + 572) = -1082130432;
  *(_DWORD *)(a2 + 576) = 0;
  *(_DWORD *)(a2 + 584) = 0;
  *(_DWORD *)(a2 + 588) = 0;
  *(_DWORD *)(a2 + 592) = 0;
  *(_DWORD *)(a2 + 620) = 0;
  *(_DWORD *)(a2 + 624) = 0;
  *(_DWORD *)(a2 + 628) = 0;
  *(_DWORD *)(a2 + 632) = 0;
  *(_DWORD *)(a2 + 636) = 0;
  *(_DWORD *)(a2 + 640) = 0;
  *(_DWORD *)(a2 + 644) = 0;
  *(_DWORD *)(a2 + 648) = 1023;
  *(_DWORD *)(a2 + 652) = 0;
  *(_DWORD *)(a2 + 656) = 0;
  *(_DWORD *)(a2 + 660) = 0;
  *(_DWORD *)(a2 + 664) = 0;
  *(_DWORD *)(a2 + 668) = 0;
  *(_DWORD *)(a2 + 672) = 0;
  *(_DWORD *)(a2 + 676) = 0;
  *(_DWORD *)(a2 + 680) = 0;
  *(_DWORD *)(a2 + 688) = 0;
  *(_DWORD *)(a2 + 684) = 0;
  *(_DWORD *)(a2 + 692) = 0;
  *(_DWORD *)(a2 + 696) = 0;
  *(_DWORD *)(a2 + 700) = 0;
  *(_DWORD *)(a2 + 704) = 1;
  *(_DWORD *)(a2 + 708) = 1023;
  *(_DWORD *)(a2 + 712) = 1023;
  *(_DWORD *)(a2 + 716) = 1023;
  *(_DWORD *)(a2 + 720) = 1023;
  *(_DWORD *)(a2 + 724) = 0;
  *(_DWORD *)(a2 + 728) = 0;
  *(_DWORD *)(a2 + 892) = 0;
  *(_DWORD *)(a2 + 952) = 1065353216;
  *(_DWORD *)(a2 + 976) = 1023;
  *(_DWORD *)(a2 + 980) = 1203982208;
  G_GetHintStringIndex(a2 + 564, v12 + 924);
  for ( i = 0; i <= 6; ++i )
    *(_DWORD *)(a2 + 4 * i + 924) = 1023;
  if ( v12[820] && v12[821] )
  {
    v9 = (_DWORD *)G_SpawnSoundBlend();
    *(_DWORD *)(a2 + 708) = *v9;
    v9[29] = *(_DWORD *)a1;
    trap_LinkEntity(v9);
  }
  if ( v12[822] && v12[823] )
  {
    v10 = (_DWORD *)G_SpawnSoundBlend();
    *(_DWORD *)(a2 + 712) = *v10;
    v10[29] = *(_DWORD *)a1;
    trap_LinkEntity(v10);
  }
  if ( v12 != (char *)-204 )
  {
    v11 = (_DWORD *)G_SpawnSoundBlend();
    *(_DWORD *)(a2 + 716) = *v11;
    v11[29] = *(_DWORD *)a1;
    trap_LinkEntity(v11);
  }
  if ( v12 != (char *)-288 )
  {
    v3 = (_DWORD *)G_SpawnSoundBlend();
    *(_DWORD *)(a2 + 720) = *v3;
    v3[29] = *(_DWORD *)a1;
    trap_LinkEntity(v3);
  }
  if ( v12 != (char *)-204 && v12[204] )
  {
    v4 = BG_GetWeaponIndexForName((_BYTE)v12 - 52);
    v6 = BG_GetInfoForWeapon(v4);
    if ( *(_DWORD *)(v6 + 176) && **(_BYTE **)(v6 + 176) )
      *(_DWORD *)(a2 + 732) = (unsigned __int8)G_SoundAliasIndex(*(char **)(v6 + 176));
    if ( *(_DWORD *)(v6 + 180) && **(_BYTE **)(v6 + 180) )
      *(_DWORD *)(a2 + 736) = (unsigned __int8)G_SoundAliasIndex(*(char **)(v6 + 180));
  }
  if ( v12 != (char *)-288 && v12[288] )
  {
    v5 = BG_GetWeaponIndexForName((_BYTE)v12 + 32);
    v7 = BG_GetInfoForWeapon(v5);
    if ( *(_DWORD *)(v7 + 176) && **(_BYTE **)(v7 + 176) )
      *(_DWORD *)(a2 + 744) = (unsigned __int8)G_SoundAliasIndex(*(char **)(v7 + 176));
    if ( *(_DWORD *)(v7 + 180) && **(_BYTE **)(v7 + 180) )
      *(_DWORD *)(a2 + 748) = (unsigned __int8)G_SoundAliasIndex(*(char **)(v7 + 180));
  }
  sub_7C762(a1, (float *)(a1 + 316), (float *)(a1 + 328));
}
// 17744: using guessed type _DWORD __cdecl G_VehInitPathPos(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 180B4: using guessed type _DWORD __cdecl VEH_InitPhysics(_DWORD);
// 186E4: using guessed type int G_SpawnSoundBlend(void);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0007D3E2) --------------------------------------------------------
_DWORD *__cdecl VEH_SetupCollmap(int a1)
{
  char *v1; // eax
  _DWORD *result; // eax
  char v3; // al

  v1 = (char *)G_ModelName(*(unsigned __int8 *)(a1 + 385));
  result = sub_7C3CE(v1);
  if ( result )
  {
    if ( result[35] )
    {
      *(_DWORD *)(a1 + 140) = result[35];
      trap_SetBrushModel(a1);
      *(_DWORD *)(a1 + 288) = 0x800000;
      result = (_DWORD *)(*(_DWORD *)(a1 + 288) | 0x200000);
      *(_DWORD *)(a1 + 288) = result;
    }
    else
    {
      v3 = G_ModelName(*(unsigned __int8 *)(a1 + 385));
      result = (_DWORD *)Com_Printf("WARNING: Cannot use empty vehicle collmap for [%s]\n", v3);
    }
  }
  return result;
}
// 17424: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 181F4: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (0007D492) --------------------------------------------------------
int __cdecl sub_7D492(int a1, int a2, float a3, float a4, int a5)
{
  int result; // eax
  float v6; // [esp+1Ch] [ebp-6Ch]
  float v7; // [esp+2Ch] [ebp-5Ch]
  float v8; // [esp+34h] [ebp-54h]
  float v9; // [esp+3Ch] [ebp-4Ch]
  float v10[13]; // [esp+40h] [ebp-48h] BYREF
  char *v11; // [esp+74h] [ebp-14h]
  int v12; // [esp+78h] [ebp-10h]
  int v13; // [esp+7Ch] [ebp-Ch]

  v13 = *(_DWORD *)(a1 + 356);
  v12 = v13 + 184;
  v11 = &byte_E3EC0[988 * *(__int16 *)(v13 + 556)];
  *(_DWORD *)(v13 + 960) = level[123];
  if ( a3 >= 0.0 )
  {
    if ( a3 <= 1.0 )
      v9 = a3;
    else
      v9 = 1.0;
  }
  else
  {
    v9 = 0.0;
  }
  AnglesToAxis(v12 + 24, v10);
  *(float *)(v13 + 676) = *(float *)a2 * v10[0] + *(float *)(a2 + 4) * v10[1] + *(float *)(a2 + 8) * v10[2];
  v6 = *(float *)a2 * v10[3] + *(float *)(a2 + 4) * v10[4] + *(float *)(a2 + 8) * v10[5];
  *(_DWORD *)(v13 + 680) = LODWORD(v6) ^ 0x80000000;
  *(float *)(v13 + 688) = v9 + v9;
  *(_DWORD *)(v13 + 684) = *(_DWORD *)(v13 + 688);
  *(_DWORD *)(v13 + 692) = 0;
  VectorNormalize2D(v13 + 676);
  *(float *)(v13 + 676) = *((float *)v11 + 30) * v9 * *(float *)(v13 + 676);
  if ( fabs(*(float *)(v13 + 676)) > 30.0 )
  {
    if ( *(float *)(v13 + 676) <= 0.0 )
      v8 = -30.0;
    else
      v8 = 30.0;
    *(float *)(v13 + 676) = v8;
  }
  *(float *)(v13 + 680) = *((float *)v11 + 31) * v9 * *(float *)(v13 + 680);
  if ( fabs(*(float *)(v13 + 680)) > 30.0 )
  {
    if ( *(float *)(v13 + 680) <= 0.0 )
      v7 = -30.0;
    else
      v7 = 30.0;
    *(float *)(v13 + 680) = v7;
  }
  *(float *)(v13 + 696) = *(float *)(a1 + 496) * a4;
  result = a5;
  *(_DWORD *)(v13 + 700) = a5;
  return result;
}
// 17924: using guessed type _DWORD __cdecl VectorNormalize2D(_DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0007D709) --------------------------------------------------------
int __cdecl sub_7D709(int a1, char *a2, float *a3, float *a4)
{
  long double v4; // fst7
  int v5; // esi
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  double v9; // rax
  int result; // eax
  float v11; // [esp+0h] [ebp-218h]
  float v12; // [esp+2Ch] [ebp-1ECh]
  float v13; // [esp+30h] [ebp-1E8h]
  float v14; // [esp+38h] [ebp-1E0h]
  float v15; // [esp+3Ch] [ebp-1DCh]
  float v16; // [esp+40h] [ebp-1D8h]
  float v17; // [esp+48h] [ebp-1D0h]
  float v18; // [esp+4Ch] [ebp-1CCh]
  float v19; // [esp+54h] [ebp-1C4h]
  double v20; // [esp+58h] [ebp-1C0h]
  double v21; // [esp+70h] [ebp-1A8h]
  double v22; // [esp+88h] [ebp-190h]
  double v23; // [esp+88h] [ebp-190h]
  double v24; // [esp+88h] [ebp-190h]
  double v25; // [esp+98h] [ebp-180h]
  double v26; // [esp+98h] [ebp-180h]
  float v27; // [esp+ACh] [ebp-16Ch]
  float v28; // [esp+B4h] [ebp-164h]
  float v29; // [esp+BCh] [ebp-15Ch]
  float v30; // [esp+C4h] [ebp-154h]
  float v31; // [esp+C8h] [ebp-150h]
  float v32; // [esp+CCh] [ebp-14Ch]
  float v33; // [esp+D4h] [ebp-144h]
  float v34; // [esp+D8h] [ebp-140h]
  float v35; // [esp+DCh] [ebp-13Ch]
  double v36; // [esp+E0h] [ebp-138h]
  double v37; // [esp+E8h] [ebp-130h]
  double v38; // [esp+E8h] [ebp-130h]
  double v39; // [esp+F0h] [ebp-128h]
  float v40; // [esp+104h] [ebp-114h]
  float v41; // [esp+108h] [ebp-110h]
  float v42; // [esp+108h] [ebp-110h]
  float v43; // [esp+108h] [ebp-110h]
  float v44; // [esp+108h] [ebp-110h]
  float v45; // [esp+10Ch] [ebp-10Ch]
  float v46; // [esp+10Ch] [ebp-10Ch]
  float v47; // [esp+10Ch] [ebp-10Ch]
  float v48; // [esp+10Ch] [ebp-10Ch]
  float v49; // [esp+110h] [ebp-108h]
  float v50; // [esp+110h] [ebp-108h]
  float v51; // [esp+110h] [ebp-108h]
  float v52; // [esp+114h] [ebp-104h]
  float v53; // [esp+118h] [ebp-100h]
  _DWORD v54[4]; // [esp+120h] [ebp-F8h] BYREF
  _DWORD v55[4]; // [esp+130h] [ebp-E8h] BYREF
  float v56; // [esp+140h] [ebp-D8h]
  _DWORD *v57; // [esp+144h] [ebp-D4h]
  int i; // [esp+148h] [ebp-D0h]
  float v59; // [esp+14Ch] [ebp-CCh]
  float v60; // [esp+150h] [ebp-C8h]
  float v61; // [esp+154h] [ebp-C4h]
  float v62; // [esp+158h] [ebp-C0h]
  float v63; // [esp+15Ch] [ebp-BCh]
  float v64; // [esp+160h] [ebp-B8h]
  float v65; // [esp+164h] [ebp-B4h]
  float v66; // [esp+168h] [ebp-B0h]
  float v67; // [esp+16Ch] [ebp-ACh]
  float v68[4]; // [esp+170h] [ebp-A8h] BYREF
  float v69; // [esp+180h] [ebp-98h]
  float v70; // [esp+184h] [ebp-94h]
  float v71; // [esp+188h] [ebp-90h]
  float v72[12]; // [esp+190h] [ebp-88h] BYREF
  float v73[4]; // [esp+1C0h] [ebp-58h]
  float v74; // [esp+1D0h] [ebp-48h]
  float v75; // [esp+1D4h] [ebp-44h]
  float v76; // [esp+1D8h] [ebp-40h]
  float v77; // [esp+1E0h] [ebp-38h] BYREF
  float v78; // [esp+1E4h] [ebp-34h]
  float v79; // [esp+1E8h] [ebp-30h]
  char *v80; // [esp+1F4h] [ebp-24h]
  int v81; // [esp+1F8h] [ebp-20h]
  int v82; // [esp+1FCh] [ebp-1Ch]
  _DWORD v83[6]; // [esp+200h] [ebp-18h] BYREF

  v82 = *(_DWORD *)(a1 + 356);
  v81 = v82 + 184;
  v80 = &byte_E3EC0[988 * *(__int16 *)(v82 + 556)];
  v57 = &g_entities[211 * *(_DWORD *)(a1 + 340)];
  if ( *(float *)(v82 + 688) <= 0.0 || *(_DWORD *)(v82 + 956) <= level[123] )
  {
    v67 = *((float *)v80 + 26) * 0.80000001;
    if ( *(float *)(a1 + 500) != 0.0 )
      v67 = v67 * *(float *)(a1 + 500);
    v66 = *((float *)v80 + 27);
  }
  else
  {
    v67 = *(float *)(v82 + 696);
    v66 = *(float *)(v82 + 700);
  }
  if ( *a2 <= 0 )
  {
    if ( *a2 >= 0 )
    {
      if ( *((_WORD *)v80 + 32) != 1 || *(float *)(v81 + 60) == 0.0 )
      {
        v77 = 0.0;
      }
      else if ( *(float *)(v81 + 60) <= 0.0 )
      {
        if ( *(float *)(v81 + 60) + 10.0 >= 0.0 )
          v52 = 0.0;
        else
          v52 = *(float *)(v81 + 60) + 10.0;
        v77 = v52;
      }
      else
      {
        if ( *(float *)(v81 + 60) - 10.0 <= 0.0 )
          v53 = 0.0;
        else
          v53 = *(float *)(v81 + 60) - 10.0;
        v77 = v53;
      }
    }
    else
    {
      v77 = *(float *)(v81 + 60) - v66 * 0.050000001;
      if ( -v67 * 0.5 > v77 )
        v77 = -v67 * 0.5;
    }
  }
  else
  {
    v77 = v66 * 0.050000001 + *(float *)(v81 + 60);
  }
  if ( *((_WORD *)v80 + 32) == 1 )
  {
    if ( fabs(*(float *)(v81 + 60)) >= 400.0 )
      v78 = 0.0;
    else
      v78 = (1.0 - fabs(*(float *)(v81 + 60)) / 400.0) * fabs(v77) * 0.75 * *(float *)(v81 + 76) / 80.0;
  }
  else
  {
    v78 = 0.0;
  }
  v79 = *(float *)(v81 + 68);
  if ( *(float *)(v82 + 208) >= 0.0 )
    v67 = (*(float *)(v82 + 208) / 90.0 + 1.0) * v67;
  else
    v67 = (1.0 - *(float *)(v82 + 208) / -90.0) * v67;
  if ( v67 != 0.0 )
  {
    v56 = sqrt(v77 * v77 + v78 * v78 + v79 * v79);
    if ( v56 != 0.0 )
    {
      v56 = sqrt(v77 * v77 + v78 * v78 + v79 * v79);
      if ( v56 > (long double)v67 )
      {
        VectorNormalize(&v77);
        v77 = v77 * v67;
        v78 = v78 * v67;
        v79 = v79 * v67;
      }
    }
  }
  for ( i = 0; i <= 2; ++i )
    a3[i] = (*(&v77 + i) - *(float *)(v81 + 4 * i + 60)) / 0.050000001;
  v56 = sqrt(*a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2]);
  if ( v56 > (long double)v66 )
  {
    VectorNormalize(a3);
    *a3 = *a3 * v66;
    a3[1] = a3[1] * v66;
    a3[2] = a3[2] * v66;
  }
  v4 = 0.0;
  if ( *(float *)(v82 + 964) == 0.0 )
  {
    sub_7C488(a1, 0, v55);
    sub_7C488(a1, 2, v54);
    v5 = v82;
    v4 = VectorDistance(v55, v54);
    *(float *)(v5 + 964) = v4;
  }
  if ( *((_WORD *)v80 + 32) == 1 )
  {
    v56 = sqrt(
            *(float *)(v81 + 48) * *(float *)(v81 + 48)
          + *(float *)(v81 + 52) * *(float *)(v81 + 52)
          + *(float *)(v81 + 56) * *(float *)(v81 + 56));
    if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
      && (v56 = sqrt(
                  *(float *)(v81 + 48) * *(float *)(v81 + 48)
                + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
          (1.0 - v56 / *((float *)v80 + 26)) * 0.89999998 + 0.1 < 0.0) )
    {
      v51 = 0.0;
    }
    else
    {
      v56 = sqrt(
              *(float *)(v81 + 48) * *(float *)(v81 + 48)
            + *(float *)(v81 + 52) * *(float *)(v81 + 52)
            + *(float *)(v81 + 56) * *(float *)(v81 + 56));
      if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
        && (v56 = sqrt(
                    *(float *)(v81 + 48) * *(float *)(v81 + 48)
                  + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                  + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
            (1.0 - v56 / *((float *)v80 + 26)) * 0.89999998 + 0.1 > 1.0) )
      {
        v51 = 1.0;
      }
      else
      {
        v56 = sqrt(
                *(float *)(v81 + 48) * *(float *)(v81 + 48)
              + *(float *)(v81 + 52) * *(float *)(v81 + 52)
              + *(float *)(v81 + 56) * *(float *)(v81 + 56));
        if ( 1.0 - v56 / *((float *)v80 + 26) <= 0.0 )
        {
          v51 = 0.1;
        }
        else
        {
          v56 = sqrt(
                  *(float *)(v81 + 48) * *(float *)(v81 + 48)
                + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                + *(float *)(v81 + 56) * *(float *)(v81 + 56));
          v49 = 1.0 - v56 / *((float *)v80 + 26);
          v50 = 0.89999998 * v49;
          v51 = v50 + 0.1;
        }
      }
    }
    v59 = v51;
    if ( a2[1] >= 0 )
    {
      if ( a2[1] <= 0 )
      {
        v62 = 0.0;
      }
      else
      {
        v56 = sqrt(
                *(float *)(v81 + 48) * *(float *)(v81 + 48)
              + *(float *)(v81 + 52) * *(float *)(v81 + 52)
              + *(float *)(v81 + 56) * *(float *)(v81 + 56));
        if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
          && (v56 = sqrt(
                      *(float *)(v81 + 48) * *(float *)(v81 + 48)
                    + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                    + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
              (1.0 - v56 / *((float *)v80 + 26)) * 0.94999999 + 0.050000001 < 0.0) )
        {
          v44 = 0.0;
        }
        else
        {
          v56 = sqrt(
                  *(float *)(v81 + 48) * *(float *)(v81 + 48)
                + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                + *(float *)(v81 + 56) * *(float *)(v81 + 56));
          if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
            && (v56 = sqrt(
                        *(float *)(v81 + 48) * *(float *)(v81 + 48)
                      + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                      + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
                (1.0 - v56 / *((float *)v80 + 26)) * 0.94999999 + 0.050000001 > 1.0) )
          {
            v44 = 60.0;
          }
          else
          {
            v56 = sqrt(
                    *(float *)(v81 + 48) * *(float *)(v81 + 48)
                  + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                  + *(float *)(v81 + 56) * *(float *)(v81 + 56));
            if ( 1.0 - v56 / *((float *)v80 + 26) <= 0.0 )
            {
              v44 = 3.0;
            }
            else
            {
              v56 = sqrt(
                      *(float *)(v81 + 48) * *(float *)(v81 + 48)
                    + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                    + *(float *)(v81 + 56) * *(float *)(v81 + 56));
              v41 = 1.0 - v56 / *((float *)v80 + 26);
              v42 = 0.94999999 * v41;
              v43 = v42 + 0.050000001;
              v44 = 60.0 * v43;
            }
          }
        }
        v62 = v44;
      }
    }
    else
    {
      v56 = sqrt(
              *(float *)(v81 + 48) * *(float *)(v81 + 48)
            + *(float *)(v81 + 52) * *(float *)(v81 + 52)
            + *(float *)(v81 + 56) * *(float *)(v81 + 56));
      if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
        && (v56 = sqrt(
                    *(float *)(v81 + 48) * *(float *)(v81 + 48)
                  + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                  + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
            (1.0 - v56 / *((float *)v80 + 26)) * 0.94999999 + 0.050000001 < 0.0) )
      {
        v48 = -0.0;
      }
      else
      {
        v56 = sqrt(
                *(float *)(v81 + 48) * *(float *)(v81 + 48)
              + *(float *)(v81 + 52) * *(float *)(v81 + 52)
              + *(float *)(v81 + 56) * *(float *)(v81 + 56));
        if ( 1.0 - v56 / *((float *)v80 + 26) > 0.0
          && (v56 = sqrt(
                      *(float *)(v81 + 48) * *(float *)(v81 + 48)
                    + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                    + *(float *)(v81 + 56) * *(float *)(v81 + 56)),
              (1.0 - v56 / *((float *)v80 + 26)) * 0.94999999 + 0.050000001 > 1.0) )
        {
          v48 = -60.0;
        }
        else
        {
          v56 = sqrt(
                  *(float *)(v81 + 48) * *(float *)(v81 + 48)
                + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                + *(float *)(v81 + 56) * *(float *)(v81 + 56));
          if ( 1.0 - v56 / *((float *)v80 + 26) <= 0.0 )
          {
            v48 = -3.0;
          }
          else
          {
            v56 = sqrt(
                    *(float *)(v81 + 48) * *(float *)(v81 + 48)
                  + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                  + *(float *)(v81 + 56) * *(float *)(v81 + 56));
            v45 = 1.0 - v56 / *((float *)v80 + 26);
            v46 = 0.94999999 * v45;
            v47 = v46 + 0.050000001;
            v48 = -60.0 * v47;
          }
        }
      }
      v62 = v48;
    }
    if ( v57[88] && a2[2] > 0 )
    {
      v59 = 2.0;
      if ( a2[1] >= 0 )
      {
        if ( a2[1] > 0 )
          v62 = 60.0;
      }
      else
      {
        v62 = -60.0;
      }
      v6 = *(float *)(v57[88] + 236) - v62;
      v11 = v6;
      AngleSubtract(v11, *(float *)(v81 + 40));
      v62 = v6;
      if ( v62 >= -60.0 )
      {
        if ( v62 <= 60.0 )
          v40 = v62;
        else
          v40 = 60.0;
      }
      else
      {
        v40 = -60.0;
      }
      v62 = v40;
      if ( *a2 < 0 )
      {
        if ( fabs(*(float *)(v81 + 84) - v62) > 10.0 )
        {
          if ( (fabs(*(float *)(v81 + 84) - v62) - 10.0) / 60.0 >= 1.0 )
            v39 = 0.0 * *a3;
          else
            v39 = (1.0 - (fabs(*(float *)(v81 + 84) - v62) - 10.0) / 60.0) * *a3;
          *a3 = v39;
        }
      }
      else
      {
        HIBYTE(v62) ^= 0x80u;
      }
    }
    else if ( v57[88] && (*(_DWORD *)(v57[88] + 17964) & 0x20) != 0 )
    {
      v59 = 2.0;
      if ( a2[1] >= 0 )
      {
        if ( a2[1] <= 0 )
          v62 = 0.0;
        else
          v62 = 60.0;
      }
      else
      {
        v62 = -60.0;
      }
    }
    if ( v62 >= 0.0 || *(float *)(v81 + 84) <= 0.0 )
    {
      if ( v62 > 0.0 && *(float *)(v81 + 84) < 0.0 )
        v59 = v59 + v59;
    }
    else
    {
      v59 = v59 + v59;
    }
    if ( v62 <= (long double)*(float *)(v81 + 84) )
    {
      if ( *(float *)(v81 + 84) > (long double)v62 )
      {
        *(float *)(v81 + 84) = *(float *)(v81 + 84) - v59 * 4.0;
        if ( v62 > (long double)*(float *)(v81 + 84) )
          *(float *)(v81 + 84) = v62;
      }
    }
    else
    {
      *(float *)(v81 + 84) = v59 * 4.0 + *(float *)(v81 + 84);
      if ( *(float *)(v81 + 84) > (long double)v62 )
        *(float *)(v81 + 84) = v62;
    }
    AnglesToAxis(v81 + 24, v72);
    MatrixTransformVector(a3, v72, v68);
    v69 = v68[0] * 0.050000001 + *(float *)(v81 + 48);
    v70 = v68[1] * 0.050000001 + *(float *)(v81 + 52);
    v71 = v68[2] * 0.050000001 + *(float *)(v81 + 56);
    v56 = sqrt(v69 * v69 + v70 * v70 + v71 * v71);
    if ( v56 < 10.0 )
    {
      v71 = 0.0;
      v70 = 0.0;
      v69 = 0.0;
    }
    for ( i = 0; i <= 2; ++i )
      v73[i] = v72[3 * i] * v69 + *(float *)&v83[3 * i - 27] * v70 + *(float *)&v83[3 * i - 26] * v71;
    v37 = v73[0];
    HIBYTE(v37) &= 0x7Fu;
    v38 = v37 / *(float *)(v82 + 964);
    v56 = sqrt(
            *(float *)(v81 + 48) * *(float *)(v81 + 48)
          + *(float *)(v81 + 52) * *(float *)(v81 + 52)
          + *(float *)(v81 + 56) * *(float *)(v81 + 56));
    if ( 1.0 - v56 / *((float *)v80 + 26) <= 0.0 )
    {
      v36 = 0.3 * v38;
    }
    else
    {
      v56 = sqrt(
              *(float *)(v81 + 48) * *(float *)(v81 + 48)
            + *(float *)(v81 + 52) * *(float *)(v81 + 52)
            + *(float *)(v81 + 56) * *(float *)(v81 + 56));
      v36 = ((1.0 - v56 / *((float *)v80 + 26)) * 0.7 + 0.3) * v38;
    }
    v61 = v36;
    if ( v61 >= 0.0 )
    {
      if ( v61 <= 3.0 )
        v35 = v61;
      else
        v35 = 3.0;
    }
    else
    {
      v35 = 0.0;
    }
    v61 = v35;
    if ( v73[0] <= 0.0 )
    {
      if ( v73[0] >= 0.0 )
        v75 = 0.0;
      else
        v75 = *(float *)(v81 + 84) * v61;
    }
    else
    {
      v75 = -*(float *)(v81 + 84) * v61;
    }
    if ( -*((float *)v80 + 28) * v61 <= (long double)v75 )
    {
      if ( v75 <= *((float *)v80 + 28) * v61 )
        v34 = v75;
      else
        v34 = *((float *)v80 + 28) * v61;
    }
    else
    {
      v34 = COERCE_FLOAT(*((_DWORD *)v80 + 28) ^ 0x80000000) * v61;
    }
    v75 = v34;
    if ( *(_DWORD *)(v81 + 160) || *(_DWORD *)(v81 + 164) || *(_DWORD *)(v81 + 168) || *(_DWORD *)(v81 + 172) )
    {
      v56 = sqrt(v69 * v69 + v70 * v70 + v71 * v71);
      if ( v56 == 0.0 )
      {
        v60 = 2.0;
      }
      else
      {
        v56 = sqrt(
                *(float *)(v81 + 48) * *(float *)(v81 + 48)
              + *(float *)(v81 + 52) * *(float *)(v81 + 52)
              + *(float *)(v81 + 56) * *(float *)(v81 + 56));
        v7 = fabs(v73[0] / v56);
        if ( v7 + v7 >= 2.0 )
        {
          v33 = 2.0;
        }
        else
        {
          v56 = sqrt(
                  *(float *)(v81 + 48) * *(float *)(v81 + 48)
                + *(float *)(v81 + 52) * *(float *)(v81 + 52)
                + *(float *)(v81 + 56) * *(float *)(v81 + 56));
          v8 = fabs(v73[0] / v56);
          v33 = v8 + v8;
        }
        v60 = v33;
      }
    }
    else
    {
      v60 = 0.0;
    }
    if ( fabs(v75 - *(float *)(v81 + 76)) < 10.0 )
      v60 = 1.0;
    a4[1] = (v75 - *(float *)(v81 + 76)) * v60 / 0.050000001;
    if ( -*((float *)v80 + 29) * v60 <= (long double)a4[1] )
    {
      if ( a4[1] <= *((float *)v80 + 29) * v60 )
        v32 = a4[1];
      else
        v32 = *((float *)v80 + 29) * v60;
    }
    else
    {
      v32 = COERCE_FLOAT(*((_DWORD *)v80 + 29) ^ 0x80000000) * v60;
    }
    a4[1] = v32;
  }
  else if ( a2[2] <= 0 )
  {
    if ( a2[1] >= 0 )
    {
      if ( a2[1] <= 0 )
        v75 = 0.0;
      else
        v75 = *(float *)(v81 + 76) - *((float *)v80 + 29) * 0.050000001;
    }
    else
    {
      v75 = *((float *)v80 + 29) * 0.050000001 + *(float *)(v81 + 76);
    }
    if ( -*((float *)v80 + 28) <= (long double)v75 )
    {
      if ( v75 <= (long double)*((float *)v80 + 28) )
        v30 = v75;
      else
        v30 = *((float *)v80 + 28);
    }
    else
    {
      LODWORD(v30) = *((_DWORD *)v80 + 28) ^ 0x80000000;
    }
    v75 = v30;
    a4[1] = (v30 - *(float *)(v81 + 76)) / 0.050000001;
    if ( -*((float *)v80 + 29) <= (long double)a4[1] )
    {
      if ( a4[1] <= (long double)*((float *)v80 + 29) )
        v29 = a4[1];
      else
        v29 = *((float *)v80 + 29);
    }
    else
    {
      LODWORD(v29) = *((_DWORD *)v80 + 29) ^ 0x80000000;
    }
    a4[1] = v29;
  }
  else
  {
    AngleSubtract(*(float *)(g_entities[211 * *(_DWORD *)(a1 + 340) + 88] + 236), *(float *)(v81 + 40));
    v75 = v4 / 0.050000001;
    if ( -*((float *)v80 + 28) <= (long double)v75 )
    {
      if ( v75 <= (long double)*((float *)v80 + 28) )
        v31 = v75;
      else
        v31 = *((float *)v80 + 28);
    }
    else
    {
      LODWORD(v31) = *((_DWORD *)v80 + 28) ^ 0x80000000;
    }
    v75 = v31;
    a4[1] = (v31 - *(float *)(v81 + 76)) / 0.050000001;
  }
  v74 = 0.0;
  *a4 = (0.0 - *(float *)(v81 + 72)) / 0.050000001;
  if ( -*((float *)v80 + 29) <= (long double)*a4 )
  {
    if ( *a4 <= (long double)*((float *)v80 + 29) )
      v28 = *a4;
    else
      v28 = *((float *)v80 + 29);
  }
  else
  {
    LODWORD(v28) = *((_DWORD *)v80 + 29) ^ 0x80000000;
  }
  *a4 = v28;
  v76 = 0.0;
  a4[2] = (0.0 - *(float *)(v81 + 80)) / 0.050000001;
  if ( -*((float *)v80 + 29) <= (long double)a4[2] )
  {
    if ( a4[2] <= (long double)*((float *)v80 + 29) )
      v27 = a4[2];
    else
      v27 = *((float *)v80 + 29);
  }
  else
  {
    LODWORD(v27) = *((_DWORD *)v80 + 29) ^ 0x80000000;
  }
  a4[2] = v27;
  if ( *a2 >= 0 )
  {
    if ( *a2 <= 0 )
    {
      v65 = 0.0;
    }
    else
    {
      if ( fabs((long double)*a2) >= 100.0 )
      {
        v24 = (double)(-1.0 * *((float *)v80 + 225)) / 2.0;
      }
      else
      {
        v22 = (double)*a2;
        HIBYTE(v22) &= 0x7Fu;
        v23 = v22 / 100.0;
        HIBYTE(v23) ^= 0x80u;
        v24 = v23 * *((float *)v80 + 225) / 2.0;
      }
      v65 = v24;
    }
  }
  else
  {
    if ( fabs((long double)*a2) >= 100.0 )
    {
      v26 = *((float *)v80 + 225) / 2.0;
    }
    else
    {
      v25 = (double)*a2;
      HIBYTE(v25) &= 0x7Fu;
      v26 = (double)(v25 / 100.0) * *((float *)v80 + 225) / 2.0;
    }
    v65 = v26;
  }
  if ( *a3 >= -10.0 )
  {
    if ( *a3 > 10.0 )
    {
      if ( fabs((long double)*a2) >= 100.0 )
        v20 = -1.0 * *((float *)v80 + 225) / 2.0 + v65;
      else
        v20 = -(fabs((long double)*a2) / 100.0) * *((float *)v80 + 225) / 2.0 + v65;
      v65 = v20;
    }
  }
  else
  {
    if ( fabs((long double)*a2) >= 100.0 )
      v21 = *((float *)v80 + 225) / 2.0 + v65;
    else
      v21 = fabs((long double)*a2) / 100.0 * *((float *)v80 + 225) / 2.0 + v65;
    v65 = v21;
  }
  v64 = (v65 - *(float *)(v81 + 100)) * 4.0;
  v9 = *(float *)(v81 + 100) / *((float *)v80 + 227);
  HIDWORD(v9) &= 0x7FFFFFFFu;
  v63 = pow(v9, 2.0) + 0.2000000029802322;
  if ( v63 >= 0.0 )
  {
    if ( v63 <= 1.0 )
      v19 = v63;
    else
      v19 = 1.0;
  }
  else
  {
    v19 = 0.0;
  }
  v63 = v19;
  v74 = v19 * v64;
  v74 = (1.0 - v19) * (v64 + *(float *)(v81 + 88)) + v74;
  if ( fabs(v74) < 0.5 && *(float *)(v81 + 100) < 0.5 )
    v74 = 0.0;
  v18 = *(float *)(v81 + 88);
  if ( v74 - v18 >= -3.0 )
  {
    if ( v74 - *(float *)(v81 + 88) <= 3.0 )
      v17 = v74 - *(float *)(v81 + 88) + v18;
    else
      v17 = v18 + 3.0;
  }
  else
  {
    v17 = v18 + -3.0;
  }
  *(float *)(v81 + 88) = v17;
  if ( *(float *)(v81 + 88) >= -16.0 )
  {
    if ( *(float *)(v81 + 88) <= 16.0 )
      v16 = *(float *)(v81 + 88);
    else
      v16 = 16.0;
  }
  else
  {
    v16 = -16.0;
  }
  *(float *)(v81 + 88) = v16;
  *(float *)(v81 + 100) = *(float *)(v81 + 88) * 0.050000001 + *(float *)(v81 + 100);
  if ( *(float *)(v81 + 76) <= 0.0 )
  {
    if ( *(float *)(v81 + 76) >= 0.0 )
    {
      v65 = 0.0;
    }
    else
    {
      LODWORD(v14) = *((_DWORD *)v80 + 226) ^ 0x80000000;
      if ( -*(float *)(v81 + 76) / 40.0 < 1.0 )
        v14 = -*(float *)(v81 + 76) / 40.0 * v14;
      v65 = v14;
    }
  }
  else
  {
    v15 = *((float *)v80 + 226);
    if ( *(float *)(v81 + 76) / 40.0 < 1.0 )
      v15 = *(float *)(v81 + 76) / 40.0 * v15;
    v65 = v15;
  }
  if ( *a2 >= 0 )
  {
    if ( !*a2 )
      v65 = 0.0;
  }
  else
  {
    HIBYTE(v65) ^= 0x80u;
  }
  v76 = (v65 - *(float *)(v81 + 108)) * 4.0;
  v13 = *(float *)(v81 + 96);
  if ( -*((float *)v80 + 28) * 0.050000001 <= v76 - v13 )
  {
    if ( v76 - *(float *)(v81 + 96) <= *((float *)v80 + 28) * 0.050000001 )
      v12 = v76 - *(float *)(v81 + 96) + v13;
    else
      v12 = *((float *)v80 + 28) * 0.050000001 + v13;
  }
  else
  {
    v12 = -*((float *)v80 + 28) * 0.050000001 + v13;
  }
  *(float *)(v81 + 96) = v12;
  result = v81;
  *(float *)(v81 + 108) = *(float *)(v81 + 96) * 0.050000001 + *(float *)(v81 + 108);
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17594: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0007F932) --------------------------------------------------------
void __cdecl sub_7F932(float *a1, float *a2, float *a3)
{
  int i; // [esp+4h] [ebp-14h]
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+Ch] [ebp-Ch]

  if ( a2[2] < 0.69999999 || *a1 * *a1 + a1[1] * a1[1] < a1[2] * a1[2] )
  {
    v5 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
    if ( v5 >= 0.0 )
      v6 = v5 / 1.01;
    else
      v6 = v5 * 1.01;
    for ( i = 0; i <= 2; ++i )
    {
      v4 = a2[i] * v6;
      a3[i] = a1[i] - v4;
    }
  }
  else
  {
    a3[2] = -*a1 * *a2 - a1[1] * a2[1];
    *a3 = *a1 * a2[2];
    a3[1] = a1[1] * a2[2];
  }
}

//----- (0007FAAA) --------------------------------------------------------
int __cdecl sub_7FAAA(_DWORD *a1, int a2)
{
  unsigned int i; // [esp+2Ch] [ebp-3Ch]
  float v5; // [esp+30h] [ebp-38h] BYREF
  float v6; // [esp+34h] [ebp-34h]
  float v7; // [esp+38h] [ebp-30h]
  char *v8; // [esp+44h] [ebp-24h]
  float *v9; // [esp+48h] [ebp-20h]
  int v10; // [esp+4Ch] [ebp-1Ch]

  v10 = a1[89];
  v9 = (float *)(v10 + 184);
  v8 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  for ( i = 0; i <= 0x19; ++i )
  {
    v5 = *v9 + flt_A66C0[3 * i];
    v6 = v9[1] + flt_A66C0[3 * i + 1];
    v7 = v9[2] + flt_A66C0[3 * i + 2];
    trap_Trace(a2, &v5, v8 + 852, v8 + 864, &v5, *a1, a1[104]);
    if ( !*(_BYTE *)(a2 + 47) )
    {
      *v9 = v5;
      v9[1] = v6;
      v9[2] = v7;
      v5 = *v9;
      v6 = v9[1];
      v7 = v9[2] - 1.0;
      trap_Trace(a2, v9, v8 + 852, v8 + 864, &v5, *a1, a1[104]);
      qmemcpy(&unk_F35E0, (const void *)a2, 0x30u);
      *v9 = *(float *)(a2 + 4);
      v9[1] = *(float *)(a2 + 8);
      v9[2] = *(float *)(a2 + 12);
      return 1;
    }
  }
  return 0;
}
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0007FC99) --------------------------------------------------------
void __cdecl sub_7FC99(_DWORD *a1)
{
  long double v1; // fst7
  float v2[12]; // [esp+20h] [ebp-78h] BYREF
  int v3; // [esp+50h] [ebp-48h] BYREF
  int v4; // [esp+54h] [ebp-44h]
  float v5; // [esp+58h] [ebp-40h]
  int v6[5]; // [esp+60h] [ebp-38h] BYREF
  char *v7; // [esp+74h] [ebp-24h]
  int v8; // [esp+78h] [ebp-20h]
  int v9; // [esp+7Ch] [ebp-1Ch]

  v9 = a1[89];
  v8 = v9 + 184;
  v7 = &byte_E3EC0[988 * *(__int16 *)(v9 + 556)];
  v6[0] = *(_DWORD *)(v9 + 184);
  v6[1] = *(_DWORD *)(v9 + 188);
  *(float *)&v6[2] = *(float *)(v9 + 192) + 0.25;
  if ( *(_DWORD *)(v9 + 928) == 1023 )
  {
    v3 = *(_DWORD *)v8;
    v4 = *(_DWORD *)(v8 + 4);
    v1 = *(float *)(v8 + 8) - *((float *)v7 + 34);
  }
  else
  {
    v3 = *(_DWORD *)v8;
    v4 = *(_DWORD *)(v8 + 4);
    v1 = *(float *)(v8 + 8) - 0.25;
  }
  v5 = v1;
  trap_Trace(v2, v6, v7 + 852, v7 + 864, &v3, *a1, a1[104]);
  qmemcpy(&unk_F35E0, v2, 0x30u);
  dword_F3610 = 0;
  dword_F3614 = 0;
  if ( (!BYTE2(v2[11]) || sub_7FAAA(a1, (int)v2))
    && v2[0] != 1.0
    && (*(float *)(v8 + 56) <= 0.0
     || *(float *)(v8 + 48) * v2[4] + *(float *)(v8 + 52) * v2[5] + *(float *)(v8 + 56) * v2[6] <= 10.0) )
  {
    dword_F3610 = 1;
    if ( v2[6] >= 0.69999999 )
      dword_F3614 = 1;
  }
}
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// F3610: using guessed type int dword_F3610;
// F3614: using guessed type int dword_F3614;

//----- (0007FE81) --------------------------------------------------------
void __cdecl VEH_GroundFriction(int a1)
{
  float *v1; // esi
  float *v2; // ecx
  float v3; // [esp+2Ch] [ebp-8Ch]
  float v4; // [esp+34h] [ebp-84h]
  float v5; // [esp+38h] [ebp-80h]
  float v6; // [esp+40h] [ebp-78h] BYREF
  float v7; // [esp+44h] [ebp-74h]
  float v8; // [esp+48h] [ebp-70h]
  float v9[4]; // [esp+50h] [ebp-68h] BYREF
  float v10; // [esp+60h] [ebp-58h] BYREF
  float v11; // [esp+64h] [ebp-54h]
  float v12; // [esp+68h] [ebp-50h]
  float v13; // [esp+6Ch] [ebp-4Ch]
  float v14; // [esp+70h] [ebp-48h]
  float v15; // [esp+74h] [ebp-44h]
  float v16; // [esp+78h] [ebp-40h]
  float v17; // [esp+7Ch] [ebp-3Ch]
  float v18; // [esp+80h] [ebp-38h]
  float v19; // [esp+90h] [ebp-28h]
  float v20; // [esp+94h] [ebp-24h]
  float v21; // [esp+98h] [ebp-20h]
  int i; // [esp+A0h] [ebp-18h]
  int v23; // [esp+A4h] [ebp-14h]
  float *v24; // [esp+A8h] [ebp-10h]
  int v25; // [esp+ACh] [ebp-Ch]

  v25 = *(_DWORD *)(a1 + 356);
  v24 = (float *)(v25 + 184);
  v23 = (int)&unk_E3EC0 + 988 * *(__int16 *)(v25 + 556);
  AnglesToAxis(v25 + 208, &v10);
  for ( i = 0; i <= 2; ++i )
    *(&v19 + i) = *(&v10 + 3 * i) * v24[12] + *(&v11 + 3 * i) * v24[13] + *(&v12 + 3 * i) * v24[14];
  if ( fabs(v20) >= 20.0 )
    v3 = 20.0;
  else
    v3 = fabs(v20);
  VectorNormalize2(v24 + 12, v9);
  v24[12] = -v3 * 0.050000001 * v9[0] + v24[12];
  v24[13] = -v3 * 0.050000001 * v9[1] + v24[13];
  v24[14] = -v3 * 0.050000001 * v9[2] + v24[14];
  for ( i = 0; i <= 2; ++i )
    *(&v19 + i) = *(&v10 + 3 * i) * v24[12] + *(&v11 + 3 * i) * v24[13] + *(&v12 + 3 * i) * v24[14];
  if ( *(_WORD *)(v23 + 64) == 2 && fabs(v20) > 20.0 && fabs(v20) > fabs(v19) )
  {
    v1 = v24;
    v2 = v24;
    v24[14] = 0.0;
    v2[13] = 0.0;
    v1[12] = 0.0;
    v24[12] = v10 * v19 + v24[12];
    v24[13] = v11 * v19 + v24[13];
    v24[14] = v12 * v19 + v24[14];
    if ( v20 <= 0.0 )
    {
      v24[12] = v13 * -20.0 + v24[12];
      v24[13] = v14 * -20.0 + v24[13];
      v24[14] = v15 * -20.0 + v24[14];
    }
    else
    {
      v24[12] = v13 * 20.0 + v24[12];
      v24[13] = v14 * 20.0 + v24[13];
      v24[14] = v15 * 20.0 + v24[14];
    }
    v24[12] = v16 * v21 + v24[12];
    v24[13] = v17 * v21 + v24[13];
    v24[14] = v18 * v21 + v24[14];
  }
  if ( v19 > 100.0 && v20 > 1.0 )
  {
    v5 = sqrt(v24[12] * v24[12] + v24[13] * v24[13] + v24[14] * v24[14]);
    v6 = v10 * v5;
    v7 = v11 * v5;
    v8 = v12 * v5;
    v6 = v6 - v24[12];
    v7 = v7 - v24[13];
    v8 = v8 - v24[14];
    v4 = VectorNormalize(&v6);
    if ( v4 > 5.0 )
      v4 = 5.0;
    v24[12] = v6 * v4 + v24[12];
    v24[13] = v7 * v4 + v24[13];
    v24[14] = v8 * v4 + v24[14];
    VectorNormalize(v24 + 12);
    v24[12] = v24[12] * v5;
    v24[13] = v24[13] * v5;
    v24[14] = v24[14] * v5;
  }
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0008036E) --------------------------------------------------------
_BOOL4 __cdecl VEH_SlideMove(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // ecx
  int v8; // [esp+30h] [ebp-F8h]
  int n; // [esp+34h] [ebp-F4h]
  int m; // [esp+38h] [ebp-F0h]
  int i; // [esp+3Ch] [ebp-ECh]
  int k; // [esp+3Ch] [ebp-ECh]
  int l; // [esp+3Ch] [ebp-ECh]
  int v14; // [esp+40h] [ebp-E8h]
  int v15; // [esp+40h] [ebp-E8h]
  int j; // [esp+44h] [ebp-E4h]
  float v17; // [esp+48h] [ebp-E0h]
  float v18; // [esp+48h] [ebp-E0h]
  float v19; // [esp+4Ch] [ebp-DCh]
  float v20; // [esp+50h] [ebp-D8h] BYREF
  float v21; // [esp+54h] [ebp-D4h]
  float v22; // [esp+58h] [ebp-D0h]
  float v23[4]; // [esp+60h] [ebp-C8h] BYREF
  float v24; // [esp+70h] [ebp-B8h] BYREF
  float v25; // [esp+74h] [ebp-B4h]
  float v26; // [esp+78h] [ebp-B0h]
  float v27; // [esp+80h] [ebp-A8h] BYREF
  float v28; // [esp+84h] [ebp-A4h]
  float v29; // [esp+88h] [ebp-A0h]
  float v30; // [esp+90h] [ebp-98h] BYREF
  float v31; // [esp+94h] [ebp-94h]
  float v32; // [esp+98h] [ebp-90h]
  int v33[16]; // [esp+A0h] [ebp-88h] BYREF
  float v34[4]; // [esp+E0h] [ebp-48h] BYREF
  int v35; // [esp+F0h] [ebp-38h]
  float v36; // [esp+F4h] [ebp-34h]
  float v37; // [esp+F8h] [ebp-30h]
  unsigned __int16 v38; // [esp+108h] [ebp-20h]
  char v39; // [esp+10Fh] [ebp-19h]
  int v40; // [esp+114h] [ebp-14h]
  float *v41; // [esp+118h] [ebp-10h]
  int v42; // [esp+11Ch] [ebp-Ch]
  _DWORD v43[2]; // [esp+120h] [ebp-8h] BYREF

  v42 = a1[89];
  v41 = (float *)(v42 + 184);
  v40 = (int)&unk_E3EC0 + 988 * *(__int16 *)(v42 + 556);
  v19 = 0.050000001;
  v29 = 0.0;
  v28 = 0.0;
  v27 = 0.0;
  if ( a2 )
  {
    v27 = v41[12];
    v28 = v41[13];
    v29 = v41[14] - 40.0;
    v41[14] = (v41[14] + v29) * 0.5;
    if ( dword_F3610 )
      sub_7F932(v41 + 12, (float *)&dword_F35F0, v41 + 12);
  }
  if ( dword_F3610 )
  {
    v14 = 1;
    v33[0] = dword_F35F0;
    v33[1] = dword_F35F4;
    v33[2] = dword_F35F8;
  }
  else
  {
    v14 = 0;
  }
  VectorNormalize2(v41 + 12, &v33[3 * v14]);
  v15 = v14 + 1;
  v8 = 0;
  for ( i = 0; i < a4; ++i )
    *(_DWORD *)(a3 + 4 * i) = 1023;
  for ( j = 0; j <= 3; ++j )
  {
    v23[0] = v41[12] * v19 + *v41;
    v23[1] = v41[13] * v19 + v41[1];
    v23[2] = v41[14] * v19 + v41[2];
    trap_Trace(v34, v41, v40 + 852, v40 + 864, v23, *a1, a1[104]);
    if ( v39 )
    {
      v41[14] = 0.0;
      return 1;
    }
    if ( v34[0] > 0.0 )
    {
      *v41 = v34[1];
      v41[1] = v34[2];
      v41[2] = v34[3];
    }
    if ( v34[0] == 1.0 )
      break;
    if ( a3 && v38 != 1022 && v8 < a4 )
      *(_DWORD *)(a3 + 4 * v8++) = v38;
    v19 = v19 - v19 * v34[0];
    if ( v15 > 4 )
    {
LABEL_22:
      v4 = (int)v41;
      v5 = (int)v41;
      v41[14] = 0.0;
      *(_DWORD *)(v5 + 52) = 0;
      *(_DWORD *)(v4 + 48) = 0;
      return 1;
    }
    for ( k = 0; k < v15; ++k )
    {
      if ( *(float *)&v35 * *(float *)&v33[3 * k] + v36 * *(float *)&v43[3 * k - 31] + v37 * *(float *)&v43[3 * k - 30] > 0.99000001 )
      {
        v41[12] = *(float *)&v35 + v41[12];
        v41[13] = v36 + v41[13];
        v41[14] = v37 + v41[14];
        break;
      }
    }
    if ( k >= v15 )
    {
      v33[3 * v15] = v35;
      *(float *)&v43[3 * v15 - 31] = v36;
      *(float *)&v43[3 * v15++ - 30] = v37;
      for ( l = 0; l < v15; ++l )
      {
        if ( v41[12] * *(float *)&v33[3 * l]
           + v41[13] * *(float *)&v43[3 * l - 31]
           + v41[14] * *(float *)&v43[3 * l - 30] < 0.1 )
        {
          sub_7F932(v41 + 12, (float *)&v33[3 * l], &v30);
          sub_7F932(&v27, (float *)&v33[3 * l], &v24);
          for ( m = 0; m < v15; ++m )
          {
            if ( m != l
              && v30 * *(float *)&v33[3 * m] + v31 * *(float *)&v43[3 * m - 31] + v32 * *(float *)&v43[3 * m - 30] < 0.1 )
            {
              sub_7F932(&v30, (float *)&v33[3 * m], &v30);
              sub_7F932(&v24, (float *)&v33[3 * m], &v24);
              if ( v30 * *(float *)&v33[3 * l] + v31 * *(float *)&v43[3 * l - 31] + v32 * *(float *)&v43[3 * l - 30] < 0.0 )
              {
                CrossProduct(&v33[3 * l], &v33[3 * m], &v20);
                VectorNormalize(&v20);
                v17 = v20 * v41[12] + v21 * v41[13] + v22 * v41[14];
                v30 = v20 * v17;
                v31 = v21 * v17;
                v32 = v22 * v17;
                CrossProduct(&v33[3 * l], &v33[3 * m], &v20);
                VectorNormalize(&v20);
                v18 = v20 * v27 + v21 * v28 + v22 * v29;
                v24 = v20 * v18;
                v25 = v21 * v18;
                v26 = v22 * v18;
                for ( n = 0; n < v15; ++n )
                {
                  if ( n != l
                    && n != m
                    && v30 * *(float *)&v33[3 * n] + v31 * *(float *)&v43[3 * n - 31] + v32 * *(float *)&v43[3 * n - 30] < 0.1 )
                  {
                    goto LABEL_22;
                  }
                }
              }
            }
          }
          v32 = 0.0;
          v26 = 0.0;
          v41[12] = v30;
          v41[13] = v31;
          v41[14] = v32;
          v27 = v24;
          v28 = v25;
          v29 = v26;
          break;
        }
      }
    }
  }
  if ( a2 )
  {
    v41[12] = v27;
    v41[13] = v28;
    v41[14] = v29;
  }
  return j != 0;
}
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// F35F0: using guessed type int dword_F35F0;
// F35F4: using guessed type int dword_F35F4;
// F35F8: using guessed type int dword_F35F8;
// F3610: using guessed type int dword_F3610;

//----- (00080D93) --------------------------------------------------------
void __cdecl sub_80D93(_DWORD *a1, int a2)
{
  int i; // [esp+2Ch] [ebp-9Ch]
  int v3[4]; // [esp+30h] [ebp-98h] BYREF
  float v4; // [esp+40h] [ebp-88h] BYREF
  int v5; // [esp+44h] [ebp-84h]
  int v6; // [esp+48h] [ebp-80h]
  float v7; // [esp+4Ch] [ebp-7Ch]
  float v8[7]; // [esp+50h] [ebp-78h] BYREF
  char v9; // [esp+6Fh] [ebp-59h]
  int v10; // [esp+70h] [ebp-58h] BYREF
  int v11; // [esp+74h] [ebp-54h]
  float v12; // [esp+78h] [ebp-50h]
  int v13[2]; // [esp+80h] [ebp-48h] BYREF
  float v14; // [esp+88h] [ebp-40h]
  int v15; // [esp+90h] [ebp-38h]
  int v16; // [esp+94h] [ebp-34h]
  int v17; // [esp+98h] [ebp-30h]
  int v18; // [esp+A0h] [ebp-28h] BYREF
  int v19; // [esp+A4h] [ebp-24h]
  float v20; // [esp+A8h] [ebp-20h]
  char *v21; // [esp+B4h] [ebp-14h]
  int v22; // [esp+B8h] [ebp-10h]
  int v23; // [esp+BCh] [ebp-Ch]

  v23 = a1[89];
  v22 = v23 + 184;
  v21 = &byte_E3EC0[988 * *(__int16 *)(v23 + 556)];
  v18 = *(_DWORD *)(v23 + 184);
  v19 = *(_DWORD *)(v23 + 188);
  v20 = *(float *)(v23 + 192);
  v15 = *(_DWORD *)(v23 + 232);
  v16 = *(_DWORD *)(v23 + 236);
  v17 = *(_DWORD *)(v23 + 240);
  if ( VEH_SlideMove(a1, a2, v3, 4) )
  {
    v10 = v18;
    v11 = v19;
    v12 = v20;
    v12 = v20 - *((float *)v21 + 228);
    trap_Trace(&v4, &v18, v21 + 852, v21 + 864, &v10, *a1, a1[104]);
    if ( *(float *)(v22 + 56) <= 0.0 || v4 != 1.0 && v8[2] >= 0.69999999 )
    {
      for ( i = 0; i <= 3 && v3[i] != 1023; ++i )
      {
        if ( g_entities[211 * v3[i] + 1] == 12 )
          return;
        if ( LOWORD(g_entities[211 * v3[i] + 97]) == scr_const[63] )
        {
          Scr_AddEntity(a1);
          Scr_Notify(&g_entities[211 * v3[i]], scr_const[88], 1);
        }
      }
      v13[0] = v18;
      v13[1] = v19;
      v14 = v20;
      v14 = v20 + *((float *)v21 + 228);
      trap_Trace(&v4, &v18, v21 + 852, v21 + 864, v13, *a1, a1[104]);
      if ( !v9 )
      {
        *(_DWORD *)v22 = v5;
        *(_DWORD *)(v22 + 4) = v6;
        *(float *)(v22 + 8) = v7;
        *(_DWORD *)(v22 + 48) = v15;
        *(_DWORD *)(v22 + 52) = v16;
        *(_DWORD *)(v22 + 56) = v17;
        VEH_SlideMove(a1, a2, 0, 0);
        v10 = *(_DWORD *)v22;
        v11 = *(_DWORD *)(v22 + 4);
        v12 = *(float *)(v22 + 8);
        v12 = v20 - v7 + v12;
        trap_Trace(&v4, v22, v21 + 852, v21 + 864, &v10, *a1, a1[104]);
        if ( !v9 )
        {
          *(_DWORD *)v22 = v5;
          *(_DWORD *)(v22 + 4) = v6;
          *(float *)(v22 + 8) = v7;
        }
        if ( v4 < 1.0 )
          sub_7F932((float *)(v22 + 48), v8, (float *)(v22 + 48));
      }
    }
  }
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19424: using guessed type _DWORD __cdecl VEH_SlideMove(_DWORD, _DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00081175) --------------------------------------------------------
void __cdecl sub_81175(_DWORD *a1)
{
  float v1; // [esp+1Ch] [ebp-2Ch]
  float v2; // [esp+20h] [ebp-28h]
  float v3; // [esp+24h] [ebp-24h]
  float v4; // [esp+28h] [ebp-20h]
  float *v5; // [esp+3Ch] [ebp-Ch]

  v5 = (float *)a1[89];
  v1 = sqrt(v5[58] * v5[58] + v5[59] * v5[59] + v5[60] * v5[60]);
  v2 = v5[58];
  v3 = v5[59];
  v4 = v5[60];
  sub_7F932(v5 + 58, (float *)&dword_F35F0, v5 + 58);
  if ( v5[58] * v2 + v5[59] * v3 + v5[60] * v4 > 0.0 )
  {
    VectorNormalize(v5 + 58);
    v5[58] = v5[58] * v1;
    v5[59] = v5[59] * v1;
    v5[60] = v5[60] * v1;
  }
  if ( v5[58] != 0.0 || v5[59] != 0.0 )
    sub_80D93(a1, 0);
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// F35F0: using guessed type int dword_F35F0;

//----- (000812C4) --------------------------------------------------------
void __cdecl sub_812C4(_DWORD *a1)
{
  if ( dword_F3610 )
    sub_7F932((float *)(a1[89] + 232), (float *)&dword_F35F0, (float *)(a1[89] + 232));
  sub_80D93(a1, 1);
}
// F35F0: using guessed type int dword_F35F0;
// F3610: using guessed type int dword_F3610;

//----- (00081331) --------------------------------------------------------
_DWORD *__cdecl sub_81331(_DWORD *a1)
{
  long double v1; // fst7
  int v2; // esi
  int v3; // esi
  _DWORD *result; // eax
  float v5; // [esp+20h] [ebp-1B8h]
  float v6; // [esp+28h] [ebp-1B0h]
  float v7[3]; // [esp+30h] [ebp-1A8h] BYREF
  _BYTE v8[12]; // [esp+3Ch] [ebp-19Ch] BYREF
  _BYTE v9[12]; // [esp+48h] [ebp-190h] BYREF
  _BYTE v10[16]; // [esp+54h] [ebp-184h] BYREF
  int v11; // [esp+64h] [ebp-174h]
  int i; // [esp+68h] [ebp-170h]
  float v13; // [esp+6Ch] [ebp-16Ch]
  float v14; // [esp+70h] [ebp-168h] BYREF
  float v15; // [esp+74h] [ebp-164h]
  float v16; // [esp+78h] [ebp-160h]
  float v17; // [esp+7Ch] [ebp-15Ch]
  float v18; // [esp+80h] [ebp-158h]
  float v19; // [esp+84h] [ebp-154h]
  float v20; // [esp+88h] [ebp-150h]
  float v21; // [esp+90h] [ebp-148h]
  float v22; // [esp+94h] [ebp-144h]
  float v23; // [esp+98h] [ebp-140h]
  float v24[4]; // [esp+A0h] [ebp-138h] BYREF
  float v25[4]; // [esp+B0h] [ebp-128h] BYREF
  float v26[4]; // [esp+C0h] [ebp-118h] BYREF
  char v27[12]; // [esp+D0h] [ebp-108h] BYREF
  _DWORD v28[9]; // [esp+DCh] [ebp-FCh] BYREF
  _DWORD v29[4]; // [esp+100h] [ebp-D8h] BYREF
  int v30; // [esp+110h] [ebp-C8h] BYREF
  int v31; // [esp+114h] [ebp-C4h]
  float v32; // [esp+118h] [ebp-C0h]
  int v33; // [esp+120h] [ebp-B8h] BYREF
  int v34; // [esp+124h] [ebp-B4h]
  float v35; // [esp+128h] [ebp-B0h]
  int v36[4]; // [esp+130h] [ebp-A8h] BYREF
  float v37; // [esp+140h] [ebp-98h] BYREF
  float v38; // [esp+144h] [ebp-94h]
  float v39; // [esp+148h] [ebp-90h]
  float v40; // [esp+14Ch] [ebp-8Ch]
  float v41; // [esp+150h] [ebp-88h]
  float v42; // [esp+154h] [ebp-84h]
  float v43; // [esp+158h] [ebp-80h]
  float v44; // [esp+15Ch] [ebp-7Ch]
  float v45; // [esp+160h] [ebp-78h]
  float v46; // [esp+164h] [ebp-74h]
  float v47; // [esp+168h] [ebp-70h]
  float v48; // [esp+16Ch] [ebp-6Ch]
  float v49[13]; // [esp+190h] [ebp-48h] BYREF
  char *v50; // [esp+1C4h] [ebp-14h]
  int v51; // [esp+1C8h] [ebp-10h]
  int v52; // [esp+1CCh] [ebp-Ch]
  _DWORD v53[2]; // [esp+1D0h] [ebp-8h] BYREF

  v52 = a1[89];
  v51 = v52 + 184;
  v50 = &byte_E3EC0[988 * *(__int16 *)(v52 + 556)];
  if ( *((_WORD *)v50 + 32) == 1 )
    v11 = 4;
  else
    v11 = 6;
  v28[6] = *(_DWORD *)v51;
  v28[7] = *(_DWORD *)(v51 + 4);
  v28[8] = *(_DWORD *)(v51 + 20);
  AnglesToAxis(v51 + 24, v27);
  for ( i = 0; i < v11; ++i )
  {
    sub_7C488((int)a1, i, v29);
    MatrixTransformVector43(v29, v27, &v30);
    if ( g_vehicleDebug[3] )
      sub_7C02C((int)&v30, 4.0, 1065353216, 0, 0);
    v36[0] = v30;
    v36[1] = v31;
    v33 = v30;
    v34 = v31;
    *(float *)&v36[2] = v32 + 100.0;
    v35 = v32 - 256.0;
    if ( g_vehicleDebug[3] )
      sub_7BFD2((int)v36, (int)&v33, 0, 0, 1065353216);
    if ( *((_BYTE *)a1 + 382) == 2 )
      trap_Trace(v49, v36, 0, 0, &v33, *a1, 66065);
    else
      trap_Trace(v49, v36, 0, 0, &v33, *a1, 529);
    if ( v49[0] >= 1.0 )
    {
      v30 = v33;
      v31 = v34;
      v32 = v35;
      *(_DWORD *)(v51 + 4 * i + 160) = 0;
    }
    else
    {
      v30 = LODWORD(v49[1]);
      v31 = LODWORD(v49[2]);
      v32 = v49[3];
      *(_DWORD *)(v51 + 4 * i + 160) = (LODWORD(v49[7]) & 0x1F00000) >> 20;
    }
    *(float *)(v51 + 4 * i + 136) = v32;
    *(_DWORD *)(v51 + 4 * i + 112) = 0;
    *((_DWORD *)&v37 + 3 * i) = v30;
    *((_DWORD *)&v38 + 3 * i) = v31;
    *(&v39 + 3 * i) = *(float *)(v51 + 4 * i + 136);
    if ( g_vehicleDebug[3] )
      sub_7C02C((int)(&v37 + 3 * i), 4.0, 0, 1065353216, 0);
  }
  v21 = v40 + v46;
  v22 = v41 + v47;
  v23 = v42 + v48;
  v18 = v37 + v43;
  v19 = v38 + v44;
  v20 = v39 + v45;
  v21 = v21 * 0.5;
  v22 = v22 * 0.5;
  v23 = v23 * 0.5;
  v18 = v18 * 0.5;
  v19 = v19 * 0.5;
  v20 = v20 * 0.5;
  v25[0] = v21 - v18;
  v25[1] = v22 - v19;
  v25[2] = v23 - v20;
  VectorNormalize(v25);
  v21 = v37 + v40;
  v22 = v38 + v41;
  v23 = v39 + v42;
  v18 = v43 + v46;
  v19 = v44 + v47;
  v20 = v45 + v48;
  v21 = v21 * 0.5;
  v22 = v22 * 0.5;
  v23 = v23 * 0.5;
  v18 = v18 * 0.5;
  v19 = v19 * 0.5;
  v20 = v20 * 0.5;
  v24[0] = v21 - v18;
  v24[1] = v22 - v19;
  v24[2] = v23 - v20;
  VectorNormalize(v24);
  CrossProduct(v25, v24, &v14);
  v17 = v37 * v14 + v38 * v15 + v39 * v16;
  for ( i = 1; i < v11; ++i )
  {
    v13 = v14 * *(&v37 + 3 * i) + v15 * *(&v38 + 3 * i) + v16 * *(&v39 + 3 * i) - v17;
    if ( v13 > (long double)*((float *)v50 + 34) )
      v17 = *(&v37 + 3 * i) * v14 + *(&v38 + 3 * i) * v15 + *(&v39 + 3 * i) * v16 - *((float *)v50 + 34);
  }
  CrossProduct(&v14, v27, v28);
  VectorNormalize(v28);
  CrossProduct(v28, &v14, v27);
  v1 = VectorNormalize(v27);
  AxisToAngles(v27, v26);
  v2 = v51;
  sub_7C6CF(v26[0], *(float *)(v51 + 36), 6.0);
  *(float *)(v2 + 24) = v1;
  v3 = v51;
  sub_7C6CF(v26[2], *(float *)(v51 + 44), 6.0);
  *(float *)(v3 + 32) = v1;
  if ( *(float *)(v51 + 24) >= -60.0 )
  {
    if ( *(float *)(v51 + 24) <= 60.0 )
      v6 = *(float *)(v51 + 24);
    else
      v6 = 60.0;
  }
  else
  {
    v6 = -60.0;
  }
  *(float *)(v51 + 24) = v6;
  if ( *(float *)(v51 + 32) >= -60.0 )
  {
    if ( *(float *)(v51 + 32) <= 60.0 )
      v5 = *(float *)(v51 + 32);
    else
      v5 = 60.0;
  }
  else
  {
    v5 = -60.0;
  }
  *(float *)(v51 + 32) = v5;
  if ( *((_BYTE *)a1 + 382) != 2 )
    *(float *)(v51 + 8) = -(*(float *)v51 * v14 + *(float *)(v51 + 4) * v15 - v17) / v16;
  AnglesSubtract(v51 + 24, v51 + 36, v51 + 72);
  *(float *)(v51 + 72) = *(float *)(v51 + 72) * 20.0;
  *(float *)(v51 + 76) = *(float *)(v51 + 76) * 20.0;
  *(float *)(v51 + 80) = *(float *)(v51 + 80) * 20.0;
  result = g_vehicleDebug;
  if ( g_vehicleDebug[3] )
  {
    for ( i = 0; i <= 3; ++i )
    {
      v7[3 * i] = *(&v37 + 3 * i);
      v53[3 * i - 103] = *((_DWORD *)&v38 + 3 * i);
      v53[3 * i - 102] = *((_DWORD *)&v39 + 3 * i);
      *(float *)&v53[3 * i - 102] = -(v7[3 * i] * v14 + *(float *)&v53[3 * i - 103] * v15 - v17) / v16;
    }
    sub_7BFD2((int)v7, (int)v8, 1065353216, 1065353216, 0);
    sub_7BFD2((int)v8, (int)v10, 1065353216, 1065353216, 0);
    sub_7BFD2((int)v10, (int)v9, 1065353216, 1065353216, 0);
    result = (_DWORD *)sub_7BFD2((int)v9, (int)v7, 1065353216, 1065353216, 0);
  }
  return result;
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16BF4: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 185C4: using guessed type _DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00081F2E) --------------------------------------------------------
void *__cdecl sub_81F2E(_DWORD *a1)
{
  _DWORD *src; // [esp+10h] [ebp-8h]

  src = (_DWORD *)a1[89];
  src[49] = a1[79];
  src[50] = a1[80];
  src[51] = a1[81];
  src[55] = a1[82];
  src[56] = a1[83];
  src[57] = a1[84];
  memcpy(&unk_F3620, src, 0xB8u);
  return memcpy(&unk_F36D8, src + 46, 0xB8u);
}

//----- (00081FFD) --------------------------------------------------------
int __cdecl VEH_PlayerDamage(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+28h] [ebp-10h]
  char *v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]

  v7 = *(_DWORD *)(a2 + 356);
  v6 = 0;
  if ( v7 )
    v6 = (char *)&unk_E3EC0 + 988 * *(__int16 *)(v7 + 556);
  if ( !v6 )
    return G_Damage(a1, a2, a2, vec3_origin, a1 + 316, a3, 0, 21, 0);
  if ( *((_WORD *)v6 + 32) == 1 )
    v5 = 18;
  else
    v5 = 17;
  v4 = a1 + 316;
  if ( *(_DWORD *)(a2 + 340) == 1023 )
    result = G_Damage(a1, a2, a2, vec3_origin, v4, a3, 0, v5, 0);
  else
    result = G_Damage(a1, a2, &g_entities[211 * *(_DWORD *)(a2 + 340)], vec3_origin, v4, a3, 0, v5, 0);
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008213F) --------------------------------------------------------
void __cdecl VEH_PlayerCollision(_DWORD *a1, int a2)
{
  int v2; // esi
  int v3; // edi
  int v4; // esi
  int v5; // edi
  int v6; // esi
  int v7; // edi
  long double v8; // fst7
  int v9; // [esp+20h] [ebp-88h]
  float v10; // [esp+24h] [ebp-84h]
  float v11; // [esp+28h] [ebp-80h]
  float v12; // [esp+28h] [ebp-80h]
  float v13[6]; // [esp+30h] [ebp-78h] BYREF
  float v14; // [esp+48h] [ebp-60h]
  int v15; // [esp+50h] [ebp-58h]
  float v16; // [esp+54h] [ebp-54h]
  float v17; // [esp+58h] [ebp-50h]
  float v18; // [esp+5Ch] [ebp-4Ch]
  float v19; // [esp+60h] [ebp-48h] BYREF
  float v20; // [esp+64h] [ebp-44h]
  float v21; // [esp+68h] [ebp-40h]
  _DWORD *v22; // [esp+7Ch] [ebp-2Ch]
  int v23; // [esp+80h] [ebp-28h]
  int v24; // [esp+84h] [ebp-24h]
  float *v25; // [esp+88h] [ebp-20h]
  int v26; // [esp+8Ch] [ebp-1Ch]

  v26 = a1[89];
  v25 = (float *)(v26 + 184);
  v24 = (int)&unk_E3EC0 + 988 * *(__int16 *)(v26 + 556);
  v23 = *(_DWORD *)(a2 + 352);
  if ( (*(_DWORD *)(*(_DWORD *)(a2 + 352) + 132) & 0x100000) == 0 )
  {
    v16 = sqrt(v25[12] * v25[12] + v25[13] * v25[13] + v25[14] * v25[14]);
    if ( v16 >= 0.0099999998 )
    {
      v19 = *(float *)(v23 + 20) - *v25;
      v20 = *(float *)(v23 + 24) - v25[1];
      v21 = *(float *)(v23 + 28) - v25[2];
      VectorNormalize(&v19);
      v16 = sqrt(v25[12] * v25[12] + v25[13] * v25[13] + v25[14] * v25[14]);
      v19 = v16 * v19;
      v16 = sqrt(v25[12] * v25[12] + v25[13] * v25[13] + v25[14] * v25[14]);
      v20 = v16 * v20;
      v16 = sqrt(v25[12] * v25[12] + v25[13] * v25[13] + v25[14] * v25[14]);
      v21 = v16 * v21;
      v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
      if ( v16 >= 400.0 )
      {
        v12 = 1.0;
      }
      else
      {
        v11 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
        v12 = v11 / 400.0;
      }
      v18 = v12;
      if ( v19 * v25[12] + v20 * v25[13] + v21 * v25[14] <= 0.0099999998 )
        v17 = 0.0;
      else
        v17 = v18 * 150.0;
      v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
      if ( v16 < 200.0 )
      {
        VectorNormalize(&v19);
        v19 = v19 * 200.0;
        v20 = v20 * 200.0;
        v21 = v21 * 200.0;
      }
      v19 = v19 * 1.3;
      v20 = v20 * 1.3;
      v21 = v21 * 1.3;
      *(float *)(v23 + 32) = *(float *)(v23 + 32) + v19;
      *(float *)(v23 + 36) = *(float *)(v23 + 36) + v20;
      *(float *)(v23 + 40) = *(float *)(v23 + 40) + v21;
      v10 = sqrt(
              *(float *)(v23 + 32) * *(float *)(v23 + 32)
            + *(float *)(v23 + 36) * *(float *)(v23 + 36)
            + *(float *)(v23 + 40) * *(float *)(v23 + 40));
      v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
      if ( v10 > v16 * 1.3 )
      {
        VectorNormalize(v23 + 32);
        v2 = v23;
        v3 = v23;
        v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
        *(float *)(v2 + 32) = v16 * 1.3 * *(float *)(v3 + 32);
        v4 = v23;
        v5 = v23;
        v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
        *(float *)(v4 + 36) = v16 * 1.3 * *(float *)(v5 + 36);
        v6 = v23;
        v7 = v23;
        v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
        *(float *)(v6 + 40) = v16 * 1.3 * *(float *)(v7 + 40);
      }
      v9 = v23;
      v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
      if ( v16 >= 400.0 )
      {
        v8 = pow(1.0, 2.0);
      }
      else
      {
        v16 = sqrt(v19 * v19 + v20 * v20 + v21 * v21);
        v8 = pow(v16 / 400.0, 2.0);
      }
      *(float *)(v9 + 40) = v8 * 100.0 + 200.0;
      v22 = a1;
      if ( *(_DWORD *)(v26 + 928) != 1023 )
        v22 = &g_entities[211 * *(_DWORD *)(v26 + 928)];
      if ( !v22[88] )
        v22 = a1;
      if ( *(_DWORD *)(v23 + 18216) < level[123] - 500 )
      {
        VectorNormalize(&v19);
        VEH_PlayerDamage(a2, a1, (int)v17);
        if ( (*(_DWORD *)(*(_DWORD *)(a2 + 352) + 12) & 1) == 0 )
        {
          v13[5] = 0.0;
          v13[4] = 0.0;
          v14 = (1.0 - v18) * 1500.0 + 0.0;
          v13[0] = *(float *)(a2 + 316) + 0.0;
          v13[1] = *(float *)(a2 + 320) + 0.0;
          v13[2] = *(float *)(a2 + 324) + v14;
          v15 = G_PlaySoundAliasAtPoint(v13, *(unsigned __int8 *)(v24 + 827));
          *(_DWORD *)(v15 + 248) |= 8u;
        }
        *(_DWORD *)(v23 + 18216) = level[123];
      }
    }
  }
}
// 16DB4: using guessed type _DWORD __cdecl VEH_PlayerDamage(_DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17EF4: using guessed type _DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD);

//----- (000827AB) --------------------------------------------------------
int __cdecl sub_827AB(float *a1, int a2)
{
  int v2; // edx
  int v3; // esi
  int v4; // ecx
  int v5; // esi
  int v6; // esi
  int v7; // ecx
  long double v8; // fst6
  int v10; // [esp+10h] [ebp-328h]
  float v11; // [esp+40h] [ebp-2F8h]
  float v12; // [esp+44h] [ebp-2F4h]
  float v13; // [esp+48h] [ebp-2F0h]
  float v14; // [esp+50h] [ebp-2E8h]
  float v15; // [esp+54h] [ebp-2E4h]
  float v16; // [esp+58h] [ebp-2E0h]
  float v17; // [esp+60h] [ebp-2D8h]
  float v18; // [esp+64h] [ebp-2D4h]
  float v19; // [esp+68h] [ebp-2D0h]
  float v20; // [esp+70h] [ebp-2C8h]
  float v21; // [esp+74h] [ebp-2C4h]
  float v22; // [esp+78h] [ebp-2C0h]
  float v23; // [esp+84h] [ebp-2B4h]
  float v24; // [esp+90h] [ebp-2A8h]
  float v25; // [esp+9Ch] [ebp-29Ch]
  float v26; // [esp+A0h] [ebp-298h]
  float v27; // [esp+ACh] [ebp-28Ch]
  float v28; // [esp+B0h] [ebp-288h]
  float v29; // [esp+BCh] [ebp-27Ch]
  float v30; // [esp+C0h] [ebp-278h]
  float v31; // [esp+CCh] [ebp-26Ch]
  double v32; // [esp+D0h] [ebp-268h]
  double v33; // [esp+D8h] [ebp-260h]
  double v34; // [esp+E0h] [ebp-258h]
  double v35; // [esp+E8h] [ebp-250h]
  double v36; // [esp+F8h] [ebp-240h]
  float v37; // [esp+104h] [ebp-234h]
  float v38; // [esp+108h] [ebp-230h]
  float v39; // [esp+10Ch] [ebp-22Ch]
  int v40; // [esp+110h] [ebp-228h]
  float v41; // [esp+114h] [ebp-224h]
  float v42; // [esp+118h] [ebp-220h]
  float v43; // [esp+11Ch] [ebp-21Ch]
  int v44; // [esp+120h] [ebp-218h]
  float v45; // [esp+124h] [ebp-214h]
  float v46; // [esp+128h] [ebp-210h]
  float v47; // [esp+12Ch] [ebp-20Ch]
  int v48; // [esp+130h] [ebp-208h]
  float v49; // [esp+134h] [ebp-204h]
  float v50; // [esp+138h] [ebp-200h]
  float v51; // [esp+13Ch] [ebp-1FCh]
  float v52; // [esp+140h] [ebp-1F8h]
  float v53; // [esp+140h] [ebp-1F8h]
  float v54; // [esp+148h] [ebp-1F0h]
  float v55; // [esp+14Ch] [ebp-1ECh]
  float v56; // [esp+150h] [ebp-1E8h]
  float v57; // [esp+154h] [ebp-1E4h]
  float v58; // [esp+154h] [ebp-1E4h]
  float v59; // [esp+15Ch] [ebp-1DCh]
  float v60; // [esp+160h] [ebp-1D8h]
  float v61; // [esp+164h] [ebp-1D4h]
  float v62; // [esp+168h] [ebp-1D0h]
  float v63; // [esp+168h] [ebp-1D0h]
  float v64; // [esp+170h] [ebp-1C8h]
  float v65; // [esp+174h] [ebp-1C4h]
  float v66; // [esp+174h] [ebp-1C4h]
  float v67; // [esp+178h] [ebp-1C0h]
  float v68; // [esp+17Ch] [ebp-1BCh]
  float v69; // [esp+180h] [ebp-1B8h]
  float v70; // [esp+184h] [ebp-1B4h]
  float v71; // [esp+188h] [ebp-1B0h]
  float v72; // [esp+18Ch] [ebp-1ACh]
  int v74; // [esp+198h] [ebp-1A0h]
  float v75; // [esp+1A0h] [ebp-198h]
  float v76; // [esp+1A4h] [ebp-194h]
  float v77; // [esp+1A8h] [ebp-190h]
  float v78; // [esp+1B4h] [ebp-184h]
  float v79; // [esp+1B4h] [ebp-184h]
  float v80; // [esp+1B4h] [ebp-184h]
  float v81; // [esp+1B4h] [ebp-184h]
  float v82; // [esp+1B4h] [ebp-184h]
  float v83; // [esp+1B4h] [ebp-184h]
  float v84; // [esp+1B4h] [ebp-184h]
  float v85; // [esp+1B4h] [ebp-184h]
  float v86; // [esp+1B4h] [ebp-184h]
  float v87; // [esp+1B4h] [ebp-184h]
  float v88; // [esp+1B4h] [ebp-184h]
  float v89; // [esp+1B4h] [ebp-184h]
  float v90; // [esp+1B4h] [ebp-184h]
  float v91; // [esp+1B4h] [ebp-184h]
  float v92; // [esp+1B4h] [ebp-184h]
  float v93; // [esp+1B4h] [ebp-184h]
  float v94; // [esp+1B4h] [ebp-184h]
  float v95; // [esp+1B4h] [ebp-184h]
  float v96; // [esp+1B4h] [ebp-184h]
  float v97; // [esp+1B4h] [ebp-184h]
  float v98; // [esp+1B4h] [ebp-184h]
  float v99; // [esp+1B4h] [ebp-184h]
  float v100; // [esp+1B4h] [ebp-184h]
  float v101; // [esp+1B4h] [ebp-184h]
  float v102; // [esp+1B4h] [ebp-184h]
  float v103; // [esp+1B4h] [ebp-184h]
  float v104; // [esp+1B4h] [ebp-184h]
  float v105; // [esp+1B4h] [ebp-184h]
  float v106; // [esp+1B4h] [ebp-184h]
  int v107; // [esp+1B8h] [ebp-180h]
  char *v108; // [esp+1BCh] [ebp-17Ch]
  int v109; // [esp+1C0h] [ebp-178h]
  float *v110; // [esp+1C4h] [ebp-174h]
  int v111; // [esp+1C8h] [ebp-170h]
  int v112; // [esp+1CCh] [ebp-16Ch]
  float v113; // [esp+1D0h] [ebp-168h]
  float v114; // [esp+1D0h] [ebp-168h]
  float v115; // [esp+1D4h] [ebp-164h]
  float v116; // [esp+1D4h] [ebp-164h]
  float v117; // [esp+1D8h] [ebp-160h]
  float v118; // [esp+1D8h] [ebp-160h]
  float v119; // [esp+1DCh] [ebp-15Ch]
  char s[52]; // [esp+1E0h] [ebp-158h] BYREF
  float v121; // [esp+214h] [ebp-124h]
  float v122; // [esp+218h] [ebp-120h]
  float v123; // [esp+21Ch] [ebp-11Ch]
  float v124[12]; // [esp+220h] [ebp-118h] BYREF
  int v125[2]; // [esp+250h] [ebp-E8h] BYREF
  float v126; // [esp+258h] [ebp-E0h]
  int v127[4]; // [esp+260h] [ebp-D8h] BYREF
  float v128; // [esp+270h] [ebp-C8h] BYREF
  float v129; // [esp+274h] [ebp-C4h]
  float v130; // [esp+278h] [ebp-C0h]
  float v131; // [esp+280h] [ebp-B8h] BYREF
  float v132; // [esp+284h] [ebp-B4h]
  float v133; // [esp+288h] [ebp-B0h]
  float v134; // [esp+290h] [ebp-A8h] BYREF
  float v135; // [esp+294h] [ebp-A4h]
  float v136; // [esp+298h] [ebp-A0h]
  int v137; // [esp+2A0h] [ebp-98h] BYREF
  float v138; // [esp+2A4h] [ebp-94h]
  float v139; // [esp+2A8h] [ebp-90h]
  float v140; // [esp+2B0h] [ebp-88h] BYREF
  float v141; // [esp+2B4h] [ebp-84h]
  float v142; // [esp+2B8h] [ebp-80h]
  float v143; // [esp+2BCh] [ebp-7Ch]
  float v144; // [esp+2C0h] [ebp-78h]
  float v145; // [esp+2C4h] [ebp-74h]
  float v146; // [esp+2C8h] [ebp-70h]
  float v147; // [esp+2CCh] [ebp-6Ch]
  float v148; // [esp+2D0h] [ebp-68h]
  int v149[4]; // [esp+2E0h] [ebp-58h] BYREF
  int v150[6]; // [esp+2F0h] [ebp-48h] BYREF
  int v151; // [esp+308h] [ebp-30h]
  int v152; // [esp+30Ch] [ebp-2Ch]
  int i; // [esp+310h] [ebp-28h]
  int v154; // [esp+314h] [ebp-24h]
  char *v155; // [esp+318h] [ebp-20h]
  int v156; // [esp+31Ch] [ebp-1Ch]

  v156 = *((_DWORD *)a1 + 89);
  v155 = &byte_E3EC0[988 * *(__int16 *)(v156 + 556)];
  v154 = 1;
  v150[0] = -1044381696;
  v150[1] = -1044381696;
  v150[2] = -1082130432;
  v149[0] = 1103101952;
  v149[1] = 1103101952;
  v149[2] = 1092616192;
  v122 = 1.0;
  v117 = 0.0;
  v112 = 0;
  v111 = 0;
  v110 = 0;
  v109 = 0;
  v108 = 0;
  if ( !*((_DWORD *)a1 + 65) )
    return 1;
  if ( *(_DWORD *)(v156 + 928) == 1023
    && *(float *)(v156 + 208) == *(float *)(v156 + 392)
    && *(float *)(v156 + 212) == *(float *)(v156 + 396)
    && *(float *)(v156 + 216) == *(float *)(v156 + 400)
    && *(float *)(v156 + 184) == *(float *)(v156 + 368)
    && *(float *)(v156 + 188) == *(float *)(v156 + 372)
    && *(float *)(v156 + 192) == *(float *)(v156 + 376) )
  {
    return 1;
  }
  v123 = 1.0;
  memset(s, 0, 0x30u);
  v151 = 0;
  v127[2] = 0;
  v127[1] = 0;
  v127[0] = 0;
  v126 = 0.0;
  v125[1] = 0;
  v125[0] = 0;
  v113 = 0.0;
  for ( i = 0; i <= 1; ++i )
  {
    if ( a1[i + 69] > (long double)v113 )
      v113 = a1[i + 69];
  }
  v114 = v113 + 48.0;
  for ( i = 0; i <= 1; ++i )
  {
    v127[i] = LODWORD(v114) ^ 0x80000000;
    *(float *)&v125[i] = v114;
  }
  v126 = a1[71] + 16.0;
  v131 = a1[79];
  v132 = a1[80];
  v133 = a1[81];
  v133 = v133 + 24.0;
  v128 = v131;
  v129 = v132;
  v130 = v133;
  trap_Trace(v124, &v131, v127, v125, &v128, *(_DWORD *)a1, *((_DWORD *)a1 + 104) | 0x2800000);
  if ( v124[0] == 1.0 && !HIBYTE(v124[11]) )
    return 1;
  AnglesToAxis(v156 + 208, &v140);
  for ( i = 0; i <= 5; ++i )
  {
    v136 = 0.0;
    v135 = 0.0;
    v134 = 0.0;
    v134 = (*((float *)v155 + 228) + 2.0) * v146 + 0.0;
    v135 = (*((float *)v155 + 228) + 2.0) * v147 + 0.0;
    v136 = (*((float *)v155 + 228) + 2.0) * v148 + 0.0;
    *(float *)&v137 = (*((float *)v155 + 222) - *(float *)v149) * vehCheckSolidOffsets[3 * i];
    v138 = (*((float *)v155 + 222) - *(float *)v149) * vehCheckSolidOffsets[3 * i + 1];
    v139 = (*((float *)v155 + 222) - *(float *)v149) * vehCheckSolidOffsets[3 * i + 2];
    if ( vehCheckSolidOffsets[3 * i] <= 0.0 )
    {
      if ( vehCheckSolidOffsets[3 * i] < 0.0 )
        v137 = *((_DWORD *)v155 + 230) ^ 0x80000000;
    }
    else
    {
      v137 = *((int *)v155 + 229);
    }
    v134 = v140 * *(float *)&v137 + v134;
    v135 = v141 * *(float *)&v137 + v135;
    v136 = v142 * *(float *)&v137 + v136;
    v134 = v143 * v138 + v134;
    v135 = v144 * v138 + v135;
    v136 = v145 * v138 + v136;
    v134 = v146 * v139 + v134;
    v135 = v147 * v139 + v135;
    v136 = v148 * v139 + v136;
    v131 = *(float *)(v156 + 184);
    v132 = *(float *)(v156 + 188);
    v133 = *(float *)(v156 + 192);
    v133 = v133 + *((float *)v155 + 34);
    v121 = 0.0;
    v152 = 0;
    v107 = 0;
    while ( v121 < 1.0 )
    {
      v2 = v152++;
      if ( v2 > 3 )
        break;
      v128 = (1.0 - v121) * v134 + v131;
      v129 = (1.0 - v121) * v135 + v132;
      v130 = (1.0 - v121) * v136 + v133;
      trap_Trace(v124, &v131, v150, v149, &v128, *(_DWORD *)a1, (*((_DWORD *)a1 + 104) | 0x2000000) & ~v107 | 0x800000);
      if ( v124[0] >= 1.0 || LOWORD(v124[10]) >= (int)level[121] )
      {
        if ( v124[0] < 1.0
          && LOWORD(v124[10]) != 1022
          && LOWORD(g_entities[211 * LOWORD(v124[10]) + 97]) == scr_const[63] )
        {
          VectorNormalize2(v156 + 232, &v137);
          VectorInverse(&v137);
          sub_7D492((int)a1, (int)&v137, 1.0, 0.0, 1143930880);
          *(_DWORD *)(v156 + 956) = level[123] + 150;
          v3 = v156;
          v4 = v156;
          *(_DWORD *)(v156 + 240) = 0;
          *(_DWORD *)(v4 + 236) = 0;
          *(_DWORD *)(v3 + 232) = 0;
          Scr_AddEntity(a1);
          Scr_Notify(&g_entities[211 * LOWORD(v124[10])], scr_const[88], 1);
          return 1;
        }
        if ( LOWORD(v124[10]) == 1022 && v124[0] < 1.0 && *(float *)(v156 + 240) > -20.0 && v124[6] >= 0.69999999 )
        {
          v121 = (1.0 - v121) * v124[0] + v121;
          v131 = v124[1] + v124[4];
          v132 = v124[2] + v124[5];
          v133 = v124[3] + v124[6];
          sub_7F932(&v134, &v124[4], &v134);
        }
        else
        {
          if ( v124[0] == 1.0 )
            break;
          if ( LOWORD(v124[10]) == *(_DWORD *)(v156 + 976) )
          {
            v134 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 79] - *(float *)(v156 + 184);
            v135 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 80] - *(float *)(v156 + 188);
            v136 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 81] - *(float *)(v156 + 192);
            if ( v134 * *(float *)(v156 + 232) + v135 * *(float *)(v156 + 236) + v136 * *(float *)(v156 + 240) <= 0.0 )
            {
              v111 = 1;
              break;
            }
          }
          if ( v122 > (long double)v121 )
            v122 = v121;
          if ( v123 > (long double)v121 )
          {
            v154 = 0;
            v123 = v121;
            qmemcpy(s, v124, 0x30u);
            v151 = i;
          }
          if ( v124[0] == 0.0 )
            break;
        }
      }
      else
      {
        VEH_PlayerCollision(a1, &g_entities[211 * LOWORD(v124[10])]);
        v107 = 0x2000000;
      }
    }
  }
  if ( v154 )
  {
    *(float *)(v156 + 952) = v122;
    if ( !v111 && *(_DWORD *)(v156 + 976) != 1023 )
    {
      *(_DWORD *)(v156 + 976) = 1023;
      *(_DWORD *)(v156 + 980) = 1203982208;
    }
    return 1;
  }
  qmemcpy(v124, s, sizeof(v124));
  *(float *)(v156 + 952) = v123;
  if ( LOWORD(v124[10]) != 1022 )
  {
    *(_DWORD *)(v156 + 976) = LOWORD(v124[10]);
    v5 = v156;
    *(float *)(v5 + 980) = VectorDistance(v156 + 184, &g_entities[211 * LOWORD(v124[10]) + 79]);
  }
  qmemcpy((void *)(v156 + 184), (const void *)(v156 + 368), 0xB8u);
  *(_DWORD *)(v156 + 988) = level[123];
  *(float *)(v156 + 992) = v124[4];
  *(float *)(v156 + 996) = v124[5];
  *(float *)(v156 + 1000) = v124[6];
  if ( fabs(*(float *)(v156 + 260)) / 100.0 >= 0.0 )
    v72 = fabs(*(float *)(v156 + 260)) / 100.0;
  else
    v72 = 0.0;
  v119 = v72;
  v78 = sqrt(
          *(float *)(v156 + 232) * *(float *)(v156 + 232)
        + *(float *)(v156 + 236) * *(float *)(v156 + 236)
        + *(float *)(v156 + 240) * *(float *)(v156 + 240));
  if ( v78 != 0.0 )
  {
    v79 = sqrt(
            *(float *)(v156 + 232) * *(float *)(v156 + 232)
          + *(float *)(v156 + 236) * *(float *)(v156 + 236)
          + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    v118 = v79 / (*((float *)v155 + 26) * 0.75);
    if ( v118 >= 0.0 )
    {
      if ( v118 <= 1.0 )
        v71 = v79 / (*((float *)v155 + 26) * 0.75);
      else
        v71 = 1.0;
    }
    else
    {
      v71 = 0.0;
    }
    VectorNormalize2(v156 + 232, &v137);
    if ( *(float *)&v137 * v124[4] + v138 * v124[5] + v139 * v124[6] >= 0.0 )
      v70 = v71 * 0.0;
    else
      v70 = -(*(float *)&v137 * v124[4] + v138 * v124[5] + v139 * v124[6]) * v71;
    v117 = v70;
    if ( v72 + v70 >= 0.5 )
      v69 = 0.5;
    else
      v69 = v72 + v70;
    v119 = v69;
  }
  if ( *(float *)(v156 + 688) <= 0.0 )
  {
    VectorNormalize2(v156 + 232, &v137);
    *(float *)&v10 = 400.0 - fabs(*(float *)&v137 * v140 + v138 * v141 + v139 * v142) * 300.0;
    if ( v119 * 4.0 >= 0.2 )
    {
      if ( v119 * 4.0 <= 0.6 )
      {
        v68 = v119 * 4.0;
        sub_7D492((int)a1, (int)&v124[4], v68, 0.0, v10);
      }
      else
      {
        sub_7D492((int)a1, (int)&v124[4], 0.60000002, 0.0, v10);
      }
    }
    else
    {
      sub_7D492((int)a1, (int)&v124[4], 0.2, 0.0, v10);
    }
  }
  if ( LOWORD(v124[10]) != 1023 )
  {
    v110 = (float *)&g_entities[211 * LOWORD(v124[10])];
    v109 = *((_DWORD *)v110 + 89);
    if ( v109 )
      v108 = &byte_E3EC0[988 * *(__int16 *)(v109 + 556)];
  }
  if ( v110 && *((_WORD *)v110 + 194) == scr_const[65] )
  {
    if ( *(float *)(v109 + 688) == 0.0 )
    {
      *(float *)&v137 = v110[79] - *(float *)(v156 + 184);
      v138 = v110[80] - *(float *)(v156 + 188);
      v139 = v110[81] - *(float *)(v156 + 192);
      VectorNormalize(&v137);
      if ( v119 + v119 >= 0.2 )
      {
        if ( v119 + v119 <= 0.5 )
        {
          v67 = v119 + v119;
          sub_7D492((int)v110, (int)&v137, v67, 0.0, 1143930880);
        }
        else
        {
          sub_7D492((int)v110, (int)&v137, 0.5, 0.0, 1143930880);
        }
      }
      else
      {
        sub_7D492((int)v110, (int)&v137, 0.2, 0.0, 1143930880);
      }
    }
    v65 = *((float *)v108 + 26) / *((float *)v155 + 26);
    v66 = 100.0 * v65;
    v64 = sqrt(
            *(float *)(v109 + 232) * *(float *)(v109 + 232)
          + *(float *)(v109 + 236) * *(float *)(v109 + 236)
          + *(float *)(v109 + 240) * *(float *)(v109 + 240));
    v80 = sqrt(
            *(float *)(v156 + 232) * *(float *)(v156 + 232)
          + *(float *)(v156 + 236) * *(float *)(v156 + 236)
          + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    if ( v80 / *((float *)v155 + 26) >= 0.5 )
    {
      v81 = sqrt(
              *(float *)(v156 + 232) * *(float *)(v156 + 232)
            + *(float *)(v156 + 236) * *(float *)(v156 + 236)
            + *(float *)(v156 + 240) * *(float *)(v156 + 240));
      if ( v81 / *((float *)v155 + 26) <= 1.0 )
      {
        v82 = sqrt(
                *(float *)(v156 + 232) * *(float *)(v156 + 232)
              + *(float *)(v156 + 236) * *(float *)(v156 + 236)
              + *(float *)(v156 + 240) * *(float *)(v156 + 240));
        if ( v82 / *((float *)v155 + 26) * v66 <= (long double)v64 )
          goto LABEL_117;
      }
      else if ( v66 <= (long double)v64 )
      {
LABEL_117:
        v134 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 79] - *(float *)(v156 + 184);
        v135 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 80] - *(float *)(v156 + 188);
        v136 = *(float *)&g_entities[211 * LOWORD(v124[10]) + 81] - *(float *)(v156 + 192);
        if ( v134 * *(float *)(v156 + 232) + v135 * *(float *)(v156 + 236) + v136 * *(float *)(v156 + 240) >= 0.0 )
        {
          if ( *((float *)v155 + 26) < (long double)*((float *)v108 + 26) )
          {
            v6 = v156;
            v7 = v156;
            *(_DWORD *)(v156 + 240) = 0;
            *(_DWORD *)(v7 + 236) = 0;
            *(_DWORD *)(v6 + 232) = 0;
          }
          else
          {
            v75 = *(float *)(v109 + 232) - *(float *)(v156 + 232);
            v76 = *(float *)(v109 + 236) - *(float *)(v156 + 236);
            v77 = *(float *)(v109 + 240) - *(float *)(v156 + 240);
            v134 = *(float *)(v109 + 184) - *(float *)(v156 + 184);
            v135 = *(float *)(v109 + 188) - *(float *)(v156 + 188);
            v136 = *(float *)(v109 + 192) - *(float *)(v156 + 192);
            VectorNormalize(&v134);
            if ( *(float *)(v156 + 232) * v134 + *(float *)(v156 + 236) * v135 + *(float *)(v156 + 240) * v136 > 0.0 )
            {
              v48 = v156;
              v47 = v134;
              v46 = *(float *)(v156 + 232);
              v93 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
              if ( v93 >= 0.0 )
              {
                v94 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                if ( v94 <= *((float *)v155 + 26) / 2.0 )
                {
                  v95 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                  v45 = -v95 * v47 + v46;
                }
                else
                {
                  v45 = -(*((float *)v155 + 26) / 2.0) * v47 + v46;
                }
              }
              else
              {
                v45 = -0.0 * v47 + v46;
              }
              *(float *)(v48 + 232) = v45;
              v44 = v156;
              v43 = v135;
              v42 = *(float *)(v156 + 236);
              v96 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
              if ( v96 >= 0.0 )
              {
                v97 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                if ( v97 <= *((float *)v155 + 26) / 2.0 )
                {
                  v98 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                  v41 = -v98 * v43 + v42;
                }
                else
                {
                  v41 = -(*((float *)v155 + 26) / 2.0) * v43 + v42;
                }
              }
              else
              {
                v41 = -0.0 * v43 + v42;
              }
              *(float *)(v44 + 236) = v41;
              v40 = v156;
              v39 = v136;
              v38 = *(float *)(v156 + 240);
              v99 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
              if ( v99 >= 0.0 )
              {
                v100 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                if ( v100 <= *((float *)v155 + 26) / 2.0 )
                {
                  v101 = sqrt(v75 * v75 + v76 * v76 + v77 * v77);
                  v37 = -v101 * v39 + v38;
                }
                else
                {
                  v37 = -(*((float *)v155 + 26) / 2.0) * v39 + v38;
                }
              }
              else
              {
                v37 = -0.0 * v39 + v38;
              }
              *(float *)(v40 + 240) = v37;
              v112 = 1;
            }
          }
        }
        goto LABEL_137;
      }
    }
    else if ( 0.5 * v66 <= v64 )
    {
      goto LABEL_117;
    }
    v134 = *(float *)(v109 + 184) - *(float *)(v156 + 184);
    v135 = *(float *)(v109 + 188) - *(float *)(v156 + 188);
    v136 = *(float *)(v109 + 192) - *(float *)(v156 + 192);
    VectorNormalize(&v134);
    v62 = *((float *)v108 + 26) / *((float *)v155 + 26);
    v63 = 100.0 * v62;
    v61 = v134;
    v60 = *(float *)(v109 + 232);
    v83 = sqrt(
            *(float *)(v156 + 232) * *(float *)(v156 + 232)
          + *(float *)(v156 + 236) * *(float *)(v156 + 236)
          + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    if ( v83 / *((float *)v155 + 26) >= 0.5 )
    {
      v84 = sqrt(
              *(float *)(v156 + 232) * *(float *)(v156 + 232)
            + *(float *)(v156 + 236) * *(float *)(v156 + 236)
            + *(float *)(v156 + 240) * *(float *)(v156 + 240));
      if ( v84 / *((float *)v155 + 26) <= 1.0 )
      {
        v85 = sqrt(
                *(float *)(v156 + 232) * *(float *)(v156 + 232)
              + *(float *)(v156 + 236) * *(float *)(v156 + 236)
              + *(float *)(v156 + 240) * *(float *)(v156 + 240));
        v59 = v85 / *((float *)v155 + 26) * v63 * v61 + v60;
      }
      else
      {
        v59 = v61 * v63 + v60;
      }
    }
    else
    {
      v59 = 0.5 * v63 * v61 + v60;
    }
    *(float *)(v109 + 232) = v59;
    v57 = *((float *)v108 + 26) / *((float *)v155 + 26);
    v58 = 100.0 * v57;
    v56 = v135;
    v55 = *(float *)(v109 + 236);
    v86 = sqrt(
            *(float *)(v156 + 232) * *(float *)(v156 + 232)
          + *(float *)(v156 + 236) * *(float *)(v156 + 236)
          + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    if ( v86 / *((float *)v155 + 26) >= 0.5 )
    {
      v87 = sqrt(
              *(float *)(v156 + 232) * *(float *)(v156 + 232)
            + *(float *)(v156 + 236) * *(float *)(v156 + 236)
            + *(float *)(v156 + 240) * *(float *)(v156 + 240));
      if ( v87 / *((float *)v155 + 26) <= 1.0 )
      {
        v88 = sqrt(
                *(float *)(v156 + 232) * *(float *)(v156 + 232)
              + *(float *)(v156 + 236) * *(float *)(v156 + 236)
              + *(float *)(v156 + 240) * *(float *)(v156 + 240));
        v54 = v88 / *((float *)v155 + 26) * v58 * v56 + v55;
      }
      else
      {
        v54 = v56 * v58 + v55;
      }
    }
    else
    {
      v54 = 0.5 * v58 * v56 + v55;
    }
    *(float *)(v109 + 236) = v54;
    v52 = *((float *)v108 + 26) / *((float *)v155 + 26);
    v53 = 100.0 * v52;
    v51 = v136;
    v50 = *(float *)(v109 + 240);
    v89 = sqrt(
            *(float *)(v156 + 232) * *(float *)(v156 + 232)
          + *(float *)(v156 + 236) * *(float *)(v156 + 236)
          + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    if ( v89 / *((float *)v155 + 26) >= 0.5 )
    {
      v90 = sqrt(
              *(float *)(v156 + 232) * *(float *)(v156 + 232)
            + *(float *)(v156 + 236) * *(float *)(v156 + 236)
            + *(float *)(v156 + 240) * *(float *)(v156 + 240));
      if ( v90 / *((float *)v155 + 26) <= 1.0 )
      {
        v91 = sqrt(
                *(float *)(v156 + 232) * *(float *)(v156 + 232)
              + *(float *)(v156 + 236) * *(float *)(v156 + 236)
              + *(float *)(v156 + 240) * *(float *)(v156 + 240));
        v49 = v91 / *((float *)v155 + 26) * v53 * v51 + v50;
      }
      else
      {
        v49 = v51 * v53 + v50;
      }
    }
    else
    {
      v49 = 0.5 * v53 * v51 + v50;
    }
    *(float *)(v109 + 240) = v49;
    v92 = sqrt(
            *(float *)(v109 + 232) * *(float *)(v109 + 232)
          + *(float *)(v109 + 236) * *(float *)(v109 + 236)
          + *(float *)(v109 + 240) * *(float *)(v109 + 240));
    if ( v92 > (long double)*((float *)v108 + 26) )
    {
      VectorNormalize(v109 + 232);
      *(float *)(v109 + 232) = *(float *)(v109 + 232) * *((float *)v108 + 26);
      *(float *)(v109 + 236) = *(float *)(v109 + 236) * *((float *)v108 + 26);
      *(float *)(v109 + 240) = *(float *)(v109 + 240) * *((float *)v108 + 26);
    }
    goto LABEL_117;
  }
LABEL_137:
  v134 = vehCheckSolidOffsets[3 * v151];
  v135 = vehCheckSolidOffsets[3 * v151 + 1];
  v136 = vehCheckSolidOffsets[3 * v151 + 2];
  *(float *)&v137 = v124[1] - *(float *)(v156 + 184);
  v138 = v124[2] - *(float *)(v156 + 188);
  v139 = v124[3] - *(float *)(v156 + 192);
  VectorNormalize(&v137);
  v115 = 0.0;
  if ( *(float *)&v137 * v143 + v138 * v144 + v139 * v145 <= 0.1 )
  {
    if ( *(float *)&v137 * v143 + v138 * v144 + v139 * v145 < -0.1 )
    {
      if ( *(float *)&v137 * v140 + v138 * v141 + v139 * v142 >= -0.1 )
      {
        if ( *(float *)&v137 * v140 + v138 * v141 + v139 * v142 > 0.1 )
          v115 = 1.0;
      }
      else
      {
        v115 = -1.0;
      }
    }
  }
  else if ( *(float *)&v137 * v140 + v138 * v141 + v139 * v142 >= -0.1 )
  {
    if ( *(float *)&v137 * v140 + v138 * v141 + v139 * v142 > 0.1 )
      v115 = -1.0;
  }
  else
  {
    v115 = 1.0;
  }
  if ( *(float *)(v156 + 232) != 0.0
    || *(float *)(v156 + 236) != vec3_origin[1]
    || *(float *)(v156 + 240) != vec3_origin[2] )
  {
    VectorNormalize2(v156 + 232, &v134);
  }
  v36 = *((float *)v155 + 29) / 70.0;
  v34 = fabs(*(float *)(v156 + 260));
  v102 = sqrt(
           *(float *)(v156 + 232) * *(float *)(v156 + 232)
         + *(float *)(v156 + 236) * *(float *)(v156 + 236)
         + *(float *)(v156 + 240) * *(float *)(v156 + 240));
  if ( v102 * 0.5 + v34 >= 0.0 )
  {
    v33 = fabs(*(float *)(v156 + 260));
    v103 = sqrt(
             *(float *)(v156 + 232) * *(float *)(v156 + 232)
           + *(float *)(v156 + 236) * *(float *)(v156 + 236)
           + *(float *)(v156 + 240) * *(float *)(v156 + 240));
    if ( v103 * 0.5 + v33 <= 80.0 )
    {
      v32 = fabs(*(float *)(v156 + 260));
      v104 = sqrt(
               *(float *)(v156 + 232) * *(float *)(v156 + 232)
             + *(float *)(v156 + 236) * *(float *)(v156 + 236)
             + *(float *)(v156 + 240) * *(float *)(v156 + 240));
      v35 = (v104 * 0.5 + v32) * v36 * v115;
    }
    else
    {
      v35 = 80.0 * v36 * v115;
    }
  }
  else
  {
    v35 = 0.0 * v36 * v115;
  }
  v116 = v35;
  if ( v116 != 0.0 )
  {
    v8 = fabs(fabs(v134 * v124[4] + v135 * v124[5] + v136 * v124[6]) - 0.5);
    *(float *)(v156 + 260) = v116 * (1.0 - (v8 + v8));
  }
  if ( !v112
    && (!v110 || !*((_DWORD *)v110 + 88))
    && (!v110 || !v108 || *((float *)v155 + 26) > (long double)*((float *)v108 + 26)) )
  {
    v134 = *(float *)(v156 + 232);
    v135 = *(float *)(v156 + 236);
    v136 = 0.0;
    v105 = sqrt(v134 * v134 + v135 * v135 + 0.0 * 0.0);
    if ( v105 <= 10.0 )
      v31 = 10.0;
    else
      v31 = sqrt(v134 * v134 + v135 * v135 + v136 * v136);
    v134 = v124[4];
    v135 = v124[5];
    v136 = v124[6] * 0.5;
    if ( v124[4] == 0.0 && v135 == vec3_origin[1] && v136 == vec3_origin[2] )
    {
      v134 = *(float *)&v137;
      v135 = v138;
      v136 = v139;
      VectorInverse(&v134);
    }
    if ( v134 * *(float *)(v156 + 232) + v135 * *(float *)(v156 + 236) + v136 * *(float *)(v156 + 240) >= 0.0 )
    {
      if ( v31 >= 120.0 )
      {
        if ( v31 <= 160.0 )
          v24 = v134 * v31;
        else
          v24 = 160.0 * v134;
      }
      else
      {
        v24 = 120.0 * v134;
      }
      *(float *)(v156 + 232) = v24;
      if ( v31 >= 120.0 )
      {
        if ( v31 <= 160.0 )
          v23 = v135 * v31;
        else
          v23 = 160.0 * v135;
      }
      else
      {
        v23 = 120.0 * v135;
      }
      *(float *)(v156 + 236) = v23;
      if ( v31 >= 120.0 )
      {
        if ( v31 <= 160.0 )
          v22 = v136 * v31;
        else
          v22 = 160.0 * v136;
      }
      else
      {
        v22 = 120.0 * v136;
      }
      *(float *)(v156 + 240) = v22;
    }
    else
    {
      sub_7F932((float *)(v156 + 232), &v134, (float *)(v156 + 232));
      v30 = *(float *)(v156 + 232);
      if ( v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 <= 40.0 )
        v29 = 40.0 * v134 + v30;
      else
        v29 = v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 * v134 + v30;
      *(float *)(v156 + 232) = v29;
      v28 = *(float *)(v156 + 236);
      if ( v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 <= 40.0 )
        v27 = 40.0 * v135 + v28;
      else
        v27 = v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 * v135 + v28;
      *(float *)(v156 + 236) = v27;
      v26 = *(float *)(v156 + 240);
      if ( v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 <= 40.0 )
        v25 = 40.0 * v136 + v26;
      else
        v25 = v31 / *((float *)v155 + 26) * 150.0 * 0.85000002 * v136 + v26;
      *(float *)(v156 + 240) = v25;
    }
  }
  *(_DWORD *)(v156 + 956) = level[123] + 150;
  v21 = *((float *)v155 + 26);
  v20 = sqrt(
          *(float *)(v156 + 232) * *(float *)(v156 + 232)
        + *(float *)(v156 + 236) * *(float *)(v156 + 236)
        + *(float *)(v156 + 240) * *(float *)(v156 + 240));
  if ( a1[125] == 0.0 )
  {
    if ( v20 <= (long double)v21 )
      goto LABEL_212;
LABEL_202:
    VectorNormalize(v156 + 232);
    v19 = *((float *)v155 + 26);
    v18 = *(float *)(v156 + 232);
    if ( a1[125] == 0.0 )
      v17 = v18 * v19;
    else
      v17 = v19 * a1[125] * v18;
    *(float *)(v156 + 232) = v17;
    v16 = *((float *)v155 + 26);
    v15 = *(float *)(v156 + 236);
    if ( a1[125] == 0.0 )
      v14 = v15 * v16;
    else
      v14 = v16 * a1[125] * v15;
    *(float *)(v156 + 236) = v14;
    v13 = *((float *)v155 + 26);
    v12 = *(float *)(v156 + 240);
    if ( a1[125] == 0.0 )
      v11 = v12 * v13;
    else
      v11 = v13 * a1[125] * v12;
    *(float *)(v156 + 240) = v11;
    goto LABEL_212;
  }
  if ( v20 > v21 * a1[125] )
    goto LABEL_202;
LABEL_212:
  if ( g_vehicleEnableCollisionDamage[3] && v117 > 0.5 )
    G_Damage(a1, a1, a1, &v124[4], &v124[1], (int)((v119 - 0.5 + v119 - 0.5) * *((float *)v155 + 32)), 0, 24, 2);
  if ( *(_DWORD *)(v156 + 984) < level[123] - 7000 )
  {
    G_Damage(a1, a1, a1, &v124[4], &v124[1], &unk_F423F, 0, 24, 2);
    *(_DWORD *)(v156 + 984) = level[123] + 99999;
  }
  if ( *(_DWORD *)(v156 + 984) > level[123] - 200 && *(_DWORD *)(v156 + 968) < level[123] - 1000 && v119 > 0.25 )
  {
    v106 = sqrt(v124[4] * v124[4] + v124[5] * v124[5] + v124[6] * v124[6]);
    if ( v106 != 0.0 )
    {
      v128 = *(float *)v149 * -1.0 * v124[4] + v124[1];
      v129 = *(float *)v149 * -1.0 * v124[5] + v124[2];
      v130 = *(float *)v149 * -1.0 * v124[6] + v124[3];
      Scr_AddVector(&v124[4]);
      Scr_AddVector(&v128);
      Scr_Notify(a1, scr_const[153], 2);
      *(_DWORD *)(v156 + 968) = level[123];
    }
  }
  if ( *(_DWORD *)(v156 + 984) > level[123] - 200 && *(_DWORD *)(v156 + 972) < level[123] - 1000 && v155[826] )
  {
    v138 = 0.0;
    *(float *)&v137 = 0.0;
    v139 = (1.0 - v119) * 2500.0 + 0.0;
    v128 = v124[1] + 0.0;
    v129 = v124[2] + 0.0;
    v130 = v124[3] + v139;
    v74 = G_PlaySoundAliasAtPoint(&v128, (unsigned __int8)v155[826]);
    *(_DWORD *)(v74 + 248) |= 8u;
    *(_DWORD *)(v156 + 972) = level[123];
  }
  if ( a2 > 1 )
  {
    *(float *)&v137 = *(float *)(v156 + 184) - v124[1];
    v138 = *(float *)(v156 + 188) - v124[2];
    v139 = *(float *)(v156 + 192) - v124[3];
    VectorNormalize(&v137);
    *(float *)(v156 + 232) = *((float *)v155 + 26) / 4.0 * *(float *)&v137;
    *(float *)(v156 + 236) = *((float *)v155 + 26) / 4.0 * v138;
    *(float *)(v156 + 240) = *((float *)v155 + 26) / 4.0 * v139;
  }
  return 0;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17EF4: using guessed type _DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD);
// 183E4: using guessed type _DWORD __cdecl VectorInverse(_DWORD);
// 18864: using guessed type _DWORD __cdecl VEH_PlayerCollision(_DWORD, _DWORD);
// 18964: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00085B32) --------------------------------------------------------
void __cdecl sub_85B32(int a1)
{
  long double v1; // fst7
  float v2; // [esp+30h] [ebp-178h]
  float v3; // [esp+34h] [ebp-174h]
  float v4; // [esp+38h] [ebp-170h]
  float v5; // [esp+40h] [ebp-168h] BYREF
  float v6; // [esp+44h] [ebp-164h]
  int v7; // [esp+48h] [ebp-160h]
  float v8; // [esp+50h] [ebp-158h] BYREF
  float v9; // [esp+54h] [ebp-154h]
  int v10; // [esp+58h] [ebp-150h]
  float v11; // [esp+60h] [ebp-148h] BYREF
  float v12; // [esp+64h] [ebp-144h]
  float v13; // [esp+68h] [ebp-140h]
  char v14[48]; // [esp+70h] [ebp-138h] BYREF
  char v15[48]; // [esp+A0h] [ebp-108h] BYREF
  char v16[48]; // [esp+D0h] [ebp-D8h] BYREF
  float v17; // [esp+100h] [ebp-A8h] BYREF
  float v18; // [esp+104h] [ebp-A4h]
  float v19; // [esp+110h] [ebp-98h] BYREF
  float v20; // [esp+114h] [ebp-94h]
  int v21; // [esp+118h] [ebp-90h]
  float v22; // [esp+120h] [ebp-88h] BYREF
  float v23; // [esp+124h] [ebp-84h]
  int v24; // [esp+128h] [ebp-80h]
  char v25[16]; // [esp+130h] [ebp-78h] BYREF
  char v26[48]; // [esp+140h] [ebp-68h] BYREF
  int v27; // [esp+170h] [ebp-38h] BYREF
  _DWORD *v28; // [esp+18Ch] [ebp-1Ch]
  _DWORD *v29; // [esp+190h] [ebp-18h]
  char *v30; // [esp+194h] [ebp-14h]
  float *v31; // [esp+198h] [ebp-10h]
  int v32; // [esp+19Ch] [ebp-Ch]

  v32 = *(_DWORD *)(a1 + 356);
  v31 = (float *)(v32 + 184);
  v30 = &byte_E3EC0[988 * *(__int16 *)(v32 + 556)];
  v29 = 0;
  if ( *(_DWORD *)(v32 + 928) == 1023 )
    v28 = 0;
  else
    v28 = &g_entities[211 * *(_DWORD *)(v32 + 928)];
  if ( *((float *)v30 + 71) == 0.0 && v30[824] )
  {
    if ( g_vehicleHorns[3] )
    {
      if ( v28 && (*(_DWORD *)(v28[88] + 17964) & 1) != 0 && !*(_DWORD *)(v32 + 612) )
      {
        *(_DWORD *)(v32 + 588) = 2;
        *(float *)(v32 + 604) = *(float *)(v32 + 604) + 0.039999999;
      }
      else if ( *(_DWORD *)(v32 + 588) == 2 )
      {
        *(_DWORD *)(v32 + 588) = 1;
      }
      else if ( *(_DWORD *)(v32 + 588) == 1 )
      {
        *(_DWORD *)(v32 + 588) = 0;
      }
    }
  }
  else if ( *(_DWORD *)(a1 + 792)
         || *(_DWORD *)(v32 + 928) == 1023
         || *(int *)(a1 + 576) <= 0
         || *((float *)v30 + 71) == 0.0 )
  {
    if ( *(_DWORD *)(v32 + 588) == 2 )
    {
      *(_DWORD *)(v32 + 588) = 1;
    }
    else if ( *(_DWORD *)(v32 + 588) == 1 )
    {
      *(_DWORD *)(v32 + 588) = 0;
    }
  }
  else if ( *(int *)(v32 + 776) >= 0 )
  {
    G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v32 + 776), v26);
    v11 = v31[6];
    v12 = v31[7];
    v13 = v31[8];
    v11 = v11 + v31[25];
    v12 = v12 + v31[26];
    v13 = v13 + v31[27];
    v23 = *(float *)(v28[88] + 236);
    v22 = *(float *)(v28[88] + 232);
    v24 = 0;
    AnglesToAxis(&v22, v16);
    AnglesToAxis(&v11, v15);
    MatrixTranspose(v15, v14);
    MatrixMultiply(v16, v14, v15);
    AxisToAngles(v15, &v22);
    v19 = *(float *)(a1 + 104);
    v20 = *(float *)(a1 + 108);
    v21 = 0;
    AnglesSubtract(&v22, &v19, &v17);
    v17 = fabs(v17);
    v1 = fabs(v18);
    v18 = v1;
    sub_7C63C(v22, v19, *((float *)v30 + 71));
    v5 = v1;
    sub_7C63C(v23, v20, *((float *)v30 + 71));
    v6 = v1;
    v7 = 0;
    v8 = v5;
    v9 = v6;
    v10 = 0;
    if ( -*((float *)v30 + 69) <= (long double)v5 )
    {
      if ( v5 <= (long double)*((float *)v30 + 70) )
        v4 = v5;
      else
        v4 = *((float *)v30 + 70);
    }
    else
    {
      LODWORD(v4) = *((_DWORD *)v30 + 69) ^ 0x80000000;
    }
    v5 = v4;
    if ( *(float *)(a1 + 700) == 0.0 )
    {
      if ( -*((float *)v30 + 68) <= (long double)v6 )
      {
        if ( v6 <= (long double)*((float *)v30 + 67) )
          v2 = v6;
        else
          v2 = *((float *)v30 + 67);
      }
      else
      {
        LODWORD(v2) = *((_DWORD *)v30 + 68) ^ 0x80000000;
      }
      v6 = v2;
    }
    else
    {
      if ( -*(float *)(a1 + 700) <= (long double)v6 )
      {
        if ( v6 <= (long double)*(float *)(a1 + 700) )
          v3 = v6;
        else
          v3 = *(float *)(a1 + 700);
      }
      else
      {
        LODWORD(v3) = *(_DWORD *)(a1 + 700) ^ 0x80000000;
      }
      v6 = v3;
    }
    *(float *)(a1 + 104) = v5;
    *(float *)(a1 + 108) = v6;
    AnglesSubtract(&v8, &v5, &v8);
    if ( v17 >= 2.0 && v8 == 0.0 || v18 >= 2.0 && v9 == 0.0 )
    {
      *(_DWORD *)(v32 + 588) = 2;
    }
    else if ( *(_DWORD *)(v32 + 588) == 2 )
    {
      *(_DWORD *)(v32 + 588) = 1;
    }
    else if ( *(_DWORD *)(v32 + 588) == 1 )
    {
      *(_DWORD *)(v32 + 588) = 0;
    }
    if ( v17 < 1.0 && v18 < 1.0 )
    {
      Scr_Notify(a1, scr_const[97], 0);
      if ( v29 )
      {
        trap_SightTrace(v32 + 892, &v27, 0, 0, v25, *(_DWORD *)a1, *v29, 1);
        if ( !*(_DWORD *)(v32 + 892) )
          Scr_Notify(a1, scr_const[98], 0);
      }
    }
  }
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16FE4: using guessed type _DWORD __cdecl trap_SightTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17B94: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 181E4: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00086285) --------------------------------------------------------
int __cdecl sub_86285(int a1)
{
  int result; // eax
  long double v2; // fst7
  float v3; // [esp+24h] [ebp-154h]
  float v4; // [esp+28h] [ebp-150h]
  float v5; // [esp+30h] [ebp-148h] BYREF
  float v6; // [esp+34h] [ebp-144h]
  int v7; // [esp+38h] [ebp-140h]
  float v8; // [esp+40h] [ebp-138h] BYREF
  float v9; // [esp+44h] [ebp-134h]
  int v10; // [esp+48h] [ebp-130h]
  float v11; // [esp+50h] [ebp-128h] BYREF
  float v12; // [esp+54h] [ebp-124h]
  float v13; // [esp+58h] [ebp-120h]
  char v14[48]; // [esp+60h] [ebp-118h] BYREF
  char v15[48]; // [esp+90h] [ebp-E8h] BYREF
  char v16[48]; // [esp+C0h] [ebp-B8h] BYREF
  float v17; // [esp+F0h] [ebp-88h] BYREF
  float v18; // [esp+F4h] [ebp-84h]
  float v19; // [esp+100h] [ebp-78h] BYREF
  float v20; // [esp+104h] [ebp-74h]
  int v21; // [esp+108h] [ebp-70h]
  float v22; // [esp+110h] [ebp-68h] BYREF
  float v23; // [esp+114h] [ebp-64h]
  int v24; // [esp+118h] [ebp-60h]
  char v25[64]; // [esp+120h] [ebp-58h] BYREF
  _DWORD *v26; // [esp+160h] [ebp-18h]
  char *v27; // [esp+164h] [ebp-14h]
  float *v28; // [esp+168h] [ebp-10h]
  int v29; // [esp+16Ch] [ebp-Ch]

  v29 = *(_DWORD *)(a1 + 356);
  v28 = (float *)(v29 + 184);
  v27 = &byte_E3EC0[988 * *(__int16 *)(v29 + 556)];
  if ( *(_DWORD *)(v29 + 932) == 1023 || *(int *)(a1 + 576) <= 0 )
  {
    if ( *(_DWORD *)(v29 + 596) == 2 )
    {
      result = v29;
      *(_DWORD *)(v29 + 596) = 1;
    }
    else
    {
      result = v29;
      if ( *(_DWORD *)(v29 + 596) == 1 )
      {
        result = v29;
        *(_DWORD *)(v29 + 596) = 0;
      }
    }
  }
  else
  {
    result = v29;
    if ( *(int *)(v29 + 788) >= 0 )
    {
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v29 + 788), v25);
      v11 = v28[6];
      v12 = v28[7];
      v13 = v28[8];
      v11 = v11 + v28[25];
      v12 = v12 + v28[26];
      v13 = v13 + v28[27];
      v26 = &g_entities[211 * *(_DWORD *)(v29 + 932)];
      v23 = *(float *)(v26[88] + 236);
      v22 = *(float *)(v26[88] + 232);
      v24 = 0;
      AnglesToAxis(&v22, v16);
      AnglesToAxis(&v11, v15);
      MatrixTranspose(v15, v14);
      MatrixMultiply(v16, v14, v15);
      AxisToAngles(v15, &v22);
      v19 = *(float *)(a1 + 112);
      v20 = *(float *)(a1 + 96) + *(float *)(a1 + 108);
      v21 = 0;
      AnglesSubtract(&v22, &v19, &v17);
      v17 = fabs(v17);
      v2 = fabs(v18);
      v18 = v2;
      sub_7C63C(v22, v19, *((float *)v27 + 92));
      v5 = v2;
      sub_7C63C(v23, v20, *((float *)v27 + 92));
      v6 = v2;
      v7 = 0;
      v8 = v5;
      v9 = v6;
      v10 = 0;
      if ( -*((float *)v27 + 90) <= (long double)v5 )
      {
        if ( v5 <= (long double)*((float *)v27 + 91) )
          v4 = v5;
        else
          v4 = *((float *)v27 + 91);
      }
      else
      {
        LODWORD(v4) = *((_DWORD *)v27 + 90) ^ 0x80000000;
      }
      v5 = v4;
      if ( -*((float *)v27 + 89) <= (long double)v6 )
      {
        if ( v6 <= (long double)*((float *)v27 + 88) )
          v3 = v6;
        else
          v3 = *((float *)v27 + 88);
      }
      else
      {
        LODWORD(v3) = *((_DWORD *)v27 + 89) ^ 0x80000000;
      }
      v6 = v3;
      v7 = 0;
      *(float *)(a1 + 112) = v5;
      *(float *)(a1 + 96) = v6 - *(float *)(a1 + 108);
      AnglesSubtract(&v8, &v5, &v8);
      if ( v17 >= 2.0 && v8 == 0.0 || v18 >= 2.0 && v9 == 0.0 )
      {
        result = v29;
        *(_DWORD *)(v29 + 596) = 2;
      }
      else if ( *(_DWORD *)(v29 + 596) == 2 )
      {
        result = v29;
        *(_DWORD *)(v29 + 596) = 1;
      }
      else
      {
        result = v29;
        if ( *(_DWORD *)(v29 + 596) == 1 )
        {
          result = v29;
          *(_DWORD *)(v29 + 596) = 0;
        }
      }
    }
  }
  return result;
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 17B94: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 181E4: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00086735) --------------------------------------------------------
_DWORD *__cdecl sub_86735(_DWORD *a1)
{
  long double v1; // fst7
  long double v2; // fst7
  _DWORD *result; // eax
  float v4; // [esp+34h] [ebp-34h]
  float v5; // [esp+3Ch] [ebp-2Ch]
  float v6; // [esp+40h] [ebp-28h]
  float v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+48h] [ebp-20h]
  float v9; // [esp+48h] [ebp-20h]
  float v10; // [esp+54h] [ebp-14h]
  float *v11; // [esp+5Ch] [ebp-Ch]

  v11 = (float *)a1[89];
  v8 = 0.0;
  v6 = 0.0;
  if ( v11[172] > 0.0 )
  {
    v4 = v11[172] / v11[171];
    v5 = sin(v11[173] * 3.141592653589793 / 180.0);
    v10 = v5 * v4;
    v6 = v10 * v11[169];
    v8 = v10 * v11[170];
    v11[172] = v11[172] - 0.050000001;
    if ( v11[172] < 0.0 )
      v11[172] = 0.0;
    v11[173] = v11[173] + 36.0;
  }
  v7 = v6 + v11[71];
  v9 = v8 + v11[73];
  if ( v7 * 127.0 / 30.0 + 127.0 > 0.0 && v7 * 127.0 / 30.0 + 127.0 >= 255.0 )
  {
    v1 = floor(255.0);
  }
  else if ( v7 * 127.0 / 30.0 + 127.0 <= 0.0 )
  {
    v1 = floor(0.0);
  }
  else
  {
    v1 = floor(v7 * 127.0 / 30.0 + 127.0);
  }
  a1[23] = (int)v1;
  if ( v9 * 127.0 / 30.0 + 127.0 > 0.0 && v9 * 127.0 / 30.0 + 127.0 >= 255.0 )
  {
    v2 = floor(255.0);
  }
  else if ( v9 * 127.0 / 30.0 + 127.0 <= 0.0 )
  {
    v2 = floor(0.0);
  }
  else
  {
    v2 = floor(v9 * 127.0 / 30.0 + 127.0);
  }
  result = a1 + 25;
  a1[25] = (int)v2;
  return result;
}

//----- (00086A29) --------------------------------------------------------
unsigned int __cdecl sub_86A29(unsigned int a1)
{
  unsigned int result; // eax
  int v2; // [esp+8h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 356);
  if ( *(_DWORD *)&byte_E3EC0[988 * *(__int16 *)(v2 + 556) + 68] )
  {
    result = *(_DWORD *)(v2 + 268) ^ 0x80000000;
    *(_DWORD *)(a1 + 216) = result;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 216) = 0;
  }
  return result;
}

//----- (00086AA1) --------------------------------------------------------
int __cdecl sub_86AA1(int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-28h]
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+0h] [ebp-28h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+8h] [ebp-20h]
  float v7; // [esp+8h] [ebp-20h]
  float v8; // [esp+18h] [ebp-10h]
  char *v9; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]

  v10 = *(_DWORD *)(a1 + 356);
  v9 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  if ( *((_DWORD *)v9 + 18) )
  {
    if ( g_vehicleTexScrollScale[2] <= 0.0 )
    {
      if ( *(float *)(v10 + 244) == 0.0 )
        v2 = *(float *)(v10 + 260) / 176.0;
      else
        v2 = *(float *)(v10 + 244) / 176.0;
      v3 = 0.050000001 * v2;
      v4 = v3 * *((float *)v9 + 25);
      v8 = v4;
    }
    else
    {
      if ( *(float *)(v10 + 244) == 0.0 )
        v5 = *(float *)(v10 + 260) / 176.0;
      else
        v5 = *(float *)(v10 + 244) / 176.0;
      v6 = 0.050000001 * v5;
      v7 = v6 * g_vehicleTexScrollScale[2];
      v8 = v7;
    }
    result = *(_DWORD *)(a1 + 84) + (int)(v8 * 1000.0);
    *(_DWORD *)(a1 + 84) = result;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 84) = -1;
  }
  return result;
}

//----- (00086C57) --------------------------------------------------------
void __cdecl sub_86C57(_DWORD *a1)
{
  int v1; // esi
  int v2; // ecx
  char v3; // [esp+8h] [ebp-150h]
  float v4[12]; // [esp+20h] [ebp-138h] BYREF
  float v5[4]; // [esp+50h] [ebp-108h] BYREF
  float v6; // [esp+60h] [ebp-F8h] BYREF
  float v7; // [esp+64h] [ebp-F4h]
  float v8; // [esp+68h] [ebp-F0h]
  float v9; // [esp+70h] [ebp-E8h] BYREF
  float v10; // [esp+74h] [ebp-E4h]
  float v11; // [esp+78h] [ebp-E0h]
  char v12[48]; // [esp+80h] [ebp-D8h] BYREF
  float v13; // [esp+B0h] [ebp-A8h]
  float v14; // [esp+B4h] [ebp-A4h]
  float v15; // [esp+B8h] [ebp-A0h]
  char v16[48]; // [esp+C0h] [ebp-98h] BYREF
  int v17; // [esp+F0h] [ebp-68h] BYREF
  char v18[48]; // [esp+100h] [ebp-58h] BYREF
  int v19; // [esp+130h] [ebp-28h] BYREF
  int v20; // [esp+140h] [ebp-18h]
  _DWORD *v21; // [esp+144h] [ebp-14h]
  char *v22; // [esp+148h] [ebp-10h]
  int v23; // [esp+14Ch] [ebp-Ch]

  v23 = a1[89];
  v22 = &byte_E3EC0[988 * *(__int16 *)(v23 + 556)];
  v21 = 0;
  v20 = 0;
  *(_DWORD *)(v23 + 644) = 0;
  *(_DWORD *)(v23 + 648) = 1023;
  v1 = v23;
  v2 = v23;
  *(_DWORD *)(v23 + 672) = 0;
  *(_DWORD *)(v2 + 668) = 0;
  *(_DWORD *)(v1 + 664) = 0;
  if ( a1[85] != 1023 && v22 != (char *)-140 )
  {
    if ( v22[140] )
    {
      a1[51] = (unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v22 - 116);
      if ( a1[51] )
      {
        if ( !a1[198] )
        {
          v21 = &g_entities[211 * a1[85]];
          v20 = v21[88];
          a1[38] = v21[38];
          a1[39] = v21[39];
          if ( (*(_DWORD *)(v21[88] + 132) & 0x400000) == 0 )
          {
            if ( *(int *)(v23 + 576) > 0 )
            {
              *(_DWORD *)(v23 + 576) -= 50;
            }
            else if ( (*(_BYTE *)(v20 + 17704) & 1) != 0 )
            {
              Scr_Notify(a1, scr_const[94], 0);
            }
            *(_DWORD *)(v23 + 580) -= 50;
            if ( *(int *)(v23 + 580) <= 0 && (*(_BYTE *)(v20 + 17704) & 0x20) != 0 )
              Scr_Notify(a1, scr_const[95], 0);
            *(_DWORD *)(v23 + 644) = 1;
            if ( *(int *)(v23 + 804) < 0 )
              Com_Error(1, byte_A6CA8, (char)off_AE990[0]);
            G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v23 + 804), v18);
            if ( *(int *)(v23 + 776) < 0 )
              Com_Error(1, byte_A6CE0, v3);
            G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v23 + 776), v16);
            AngleVectors(v20 + 232, v5, 0, 0);
            if ( *(float *)(v20 + 224) == 0.0 )
            {
              if ( *(int *)(v23 + 796) < 0 )
              {
LABEL_20:
                CalcMuzzlePoint(v21, &v9);
                goto LABEL_24;
              }
              G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v23 + 796), v12);
              v9 = v13;
              v10 = v14;
              v11 = v15;
            }
            else
            {
              if ( *(int *)(v23 + 800) < 0 )
                goto LABEL_20;
              G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v23 + 800), v12);
              v9 = v13;
              v10 = v14;
              v11 = v15;
            }
LABEL_24:
            v6 = v5[0] * 10240.0 + v9;
            v7 = v5[1] * 10240.0 + v10;
            v8 = v5[2] * 10240.0 + v11;
            *(float *)(v23 + 652) = v6;
            *(float *)(v23 + 656) = v7;
            *(float *)(v23 + 660) = v8;
            trap_Trace(v4, &v17, 0, 0, &v19, *a1, a1[104] & 0xFDFFFFFF);
            if ( v4[0] == 1.0 )
            {
              trap_LocationalTrace(v4, &v9, &v6, a1[85], 8337, &bulletPriorityMap);
              if ( v4[0] < 1.0 )
              {
                *(float *)(v23 + 652) = v4[1];
                *(float *)(v23 + 656) = v4[2];
                *(float *)(v23 + 660) = v4[3];
              }
            }
            else
            {
              *(_DWORD *)(v23 + 624) = 1;
            }
            return;
          }
        }
      }
    }
  }
}
// 86ED9: variable 'v3' is possibly undefined
// 169E4: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16D44: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// AE990: using guessed type char *off_AE990[13];

//----- (000871A6) --------------------------------------------------------
char __cdecl sub_871A6(int a1)
{
  unsigned __int8 v1; // al
  int v2; // eax
  char *v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  _DWORD *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 356);
  v4 = &byte_E3EC0[988 * *(__int16 *)(v8 + 556)];
  *(_DWORD *)(v8 + 644) = 0;
  *(_DWORD *)(v8 + 648) = 1023;
  *(_DWORD *)(v8 + 672) = 0;
  *(_DWORD *)(v8 + 668) = 0;
  *(_DWORD *)(v8 + 664) = 0;
  if ( *(float *)(v8 + 608) < 1.0 || *(_DWORD *)(v8 + 616) )
  {
    if ( *(_DWORD *)(v8 + 616) && *(float *)(v8 + 608) <= 0.5 )
    {
      *(_DWORD *)(v8 + 616) = 0;
      *(_DWORD *)(a1 + 228) = 0;
    }
  }
  else
  {
    *(_DWORD *)(v8 + 616) = 1;
    *(_DWORD *)(a1 + 228) = 1;
    G_AddEvent(a1, 208, 0);
  }
  if ( v4 != (char *)-288 && v4[288] )
  {
    v1 = BG_GetWeaponIndexForName((_BYTE)v4 + 32);
    v5 = BG_GetInfoForWeapon(v1);
    if ( *(float *)(v8 + 608) <= 0.0 )
      *(_DWORD *)(v8 + 608) = 0;
    else
      *(float *)(v8 + 608) = *(float *)(v8 + 608) - *(float *)(v5 + 1184);
  }
  LOBYTE(v2) = v8;
  if ( *(_DWORD *)(v8 + 932) != 1023 )
  {
    v7 = &g_entities[211 * *(_DWORD *)(v8 + 932)];
    v6 = v7[88];
    if ( *(_DWORD *)(v8 + 616) )
    {
      *(_DWORD *)(v7[88] + 12) |= 0x800000u;
      Scr_Notify(a1, scr_const[99], 0);
    }
    else
    {
      *(_DWORD *)(v7[88] + 12) &= 0xFF7FFFFF;
    }
    v2 = *(_DWORD *)(v7[88] + 132) & 0x400000;
    if ( !v2 )
    {
      LOBYTE(v2) = (_BYTE)v7;
      if ( (int)v7[144] > 0 )
      {
        v2 = v7[88];
        if ( *(_DWORD *)(v2 + 17696) == 2 )
        {
          *(_DWORD *)(v8 + 600) -= 50;
          LOBYTE(v2) = v8;
          if ( *(int *)(v8 + 600) <= 0 )
          {
            LOBYTE(v2) = *(_BYTE *)(v6 + 17704) & 1;
            if ( (_BYTE)v2 )
              LOBYTE(v2) = Scr_Notify(a1, scr_const[96], 0);
          }
        }
      }
    }
  }
  return v2;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (00087480) --------------------------------------------------------
char *__cdecl sub_87480(_DWORD *a1)
{
  unsigned __int8 v1; // al
  char *result; // eax
  unsigned __int8 v3; // al
  _DWORD *v4; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v5; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v7; // [esp+3Ch] [ebp-1Ch]
  _BOOL4 v8; // [esp+40h] [ebp-18h]
  char *v9; // [esp+48h] [ebp-10h]
  int v10; // [esp+4Ch] [ebp-Ch]

  v10 = a1[89];
  v9 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  v8 = a1[144] <= 0;
  a1[33] = 0;
  if ( *(_DWORD *)(v10 + 708) != 1023 )
  {
    v4 = &g_entities[211 * *(_DWORD *)(v10 + 708)];
    if ( v8 || !*(_DWORD *)(v10 + 704) || *(_DWORD *)(v10 + 928) == 1023 || a1[198] )
      G_SetSoundBlend(v4, 0, 0, 0);
    else
      G_SetSoundBlend(v4, (unsigned __int8)v9[820], (unsigned __int8)v9[821], *(_DWORD *)(v10 + 724));
  }
  if ( *(_DWORD *)(v10 + 712) != 1023 )
  {
    v5 = &g_entities[211 * *(_DWORD *)(v10 + 712)];
    if ( v8
      || !*(_DWORD *)(v10 + 704)
      || *(_DWORD *)(v10 + 708) != 1023 && *(float *)(v10 + 728) == 0.0
      || *(_DWORD *)(v10 + 928) == 1023 && fabs(*(float *)(v10 + 244)) < 0.1 )
    {
      G_SetSoundBlend(v5, 0, 0, 0);
    }
    else
    {
      G_SetSoundBlend(v5, (unsigned __int8)v9[822], (unsigned __int8)v9[823], *(_DWORD *)(v10 + 728));
    }
  }
  if ( v8 )
  {
    if ( a1[33] )
      a1[33] = 0;
  }
  else if ( *(_DWORD *)(v10 + 588) == 2 && v9[824] )
  {
    a1[33] = (unsigned __int8)v9[824];
  }
  else if ( *(_DWORD *)(v10 + 588) == 1 && v9[825] )
  {
    G_PlaySoundAlias(a1, (unsigned __int8)v9[825]);
  }
  if ( *(_DWORD *)(v10 + 716) != 1023 && v9 != (char *)-204 )
  {
    if ( v9[204] )
    {
      v1 = BG_GetWeaponIndexForName((_BYTE)v9 - 52);
      BG_GetInfoForWeapon(v1);
      v6 = &g_entities[211 * *(_DWORD *)(v10 + 716)];
      G_SetSoundBlend(v6, 0, 0, 0);
      if ( !v8 && *(int *)(v10 + 740) > 0 )
      {
        G_SetSoundBlend(v6, *(_DWORD *)(v10 + 732), *(_DWORD *)(v10 + 732), 0);
        *(_DWORD *)(v10 + 740) -= 50;
        if ( *(int *)(v10 + 740) <= 0 )
        {
          if ( *(_DWORD *)(v10 + 736) )
            G_PlaySoundAlias(a1, *(unsigned __int8 *)(v10 + 736));
        }
      }
    }
  }
  result = (char *)v10;
  if ( *(_DWORD *)(v10 + 720) != 1023 && v9 != (char *)-288 )
  {
    result = v9;
    if ( v9[288] )
    {
      v3 = BG_GetWeaponIndexForName((_BYTE)v9 + 32);
      BG_GetInfoForWeapon(v3);
      v7 = &g_entities[211 * *(_DWORD *)(v10 + 720)];
      result = (char *)G_SetSoundBlend(v7, 0, 0, 0);
      if ( !v8 )
      {
        result = (char *)v10;
        if ( *(int *)(v10 + 752) > 0 )
        {
          G_SetSoundBlend(v7, *(_DWORD *)(v10 + 744), *(_DWORD *)(v10 + 744), 0);
          *(_DWORD *)(v10 + 752) -= 50;
          result = (char *)v10;
          if ( *(int *)(v10 + 752) <= 0 )
          {
            result = (char *)v10;
            if ( *(_DWORD *)(v10 + 748) )
              result = (char *)G_PlaySoundAlias(a1, *(unsigned __int8 *)(v10 + 748));
          }
        }
      }
    }
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18774: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 19484: using guessed type _DWORD __cdecl G_SetSoundBlend(_DWORD, _DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (00087A13) --------------------------------------------------------
int __cdecl VEH_PhysicsNotRequired(int a1, int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  float *v6; // [esp+20h] [ebp-8h]

  v6 = *(float **)(a1 + 356);
  if ( v6[64] != 0.0
    || v6[65] != vec3_origin[1]
    || v6[66] != vec3_origin[2]
    || v6[58] != 0.0
    || v6[59] != vec3_origin[1]
    || v6[60] != vec3_origin[2]
    || v6[71] != 0.0
    || v6[72] != vec3_origin[1]
    || v6[73] != vec3_origin[2]
    || v6[68] != 0.0
    || v6[69] != vec3_origin[1]
    || v6[70] != vec3_origin[2]
    || v6[61] != 0.0
    || v6[62] != vec3_origin[1]
    || v6[63] != vec3_origin[2] )
  {
    return 0;
  }
  if ( !a2 )
    return 1;
  v5 = 0;
  v4 = &unk_D43C0;
  while ( v5 <= 63 )
  {
    if ( v4[138] != 1023
      && VectorDistanceSquared(v4 + 46, v6 + 46) < 1048576.0
      && !VEH_PhysicsNotRequired(&g_entities[211 * v4[138]], 0) )
    {
      return 0;
    }
    ++v5;
    v4 += 251;
  }
  return 1;
}
// 17B24: using guessed type _DWORD __cdecl VEH_PhysicsNotRequired(_DWORD, _DWORD);
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (00087CD3) --------------------------------------------------------
_DWORD *__cdecl sub_87CD3(int a1)
{
  _DWORD *result; // eax
  int v2; // esi
  long double v3; // fst7
  int v4; // esi
  int v5; // esi
  float v6; // [esp+0h] [ebp-D8h]
  double v7; // [esp+20h] [ebp-B8h]
  double v8; // [esp+20h] [ebp-B8h]
  double v9; // [esp+20h] [ebp-B8h]
  float v10; // [esp+2Ch] [ebp-ACh]
  int v11; // [esp+30h] [ebp-A8h]
  _DWORD *v12; // [esp+40h] [ebp-98h]
  float v13; // [esp+48h] [ebp-90h]
  __int16 v14; // [esp+50h] [ebp-88h] BYREF
  unsigned __int8 v15; // [esp+52h] [ebp-86h]
  char v16[36]; // [esp+60h] [ebp-78h] BYREF
  int v17; // [esp+84h] [ebp-54h]
  int v18; // [esp+88h] [ebp-50h]
  int v19; // [esp+8Ch] [ebp-4Ch]
  float v20[4]; // [esp+90h] [ebp-48h] BYREF
  float v21[4]; // [esp+A0h] [ebp-38h] BYREF
  float v22[5]; // [esp+B0h] [ebp-28h] BYREF
  char *v23; // [esp+C4h] [ebp-14h]
  int v24; // [esp+C8h] [ebp-10h]
  int v25; // [esp+CCh] [ebp-Ch]

  v25 = *(_DWORD *)(a1 + 356);
  v24 = v25 + 184;
  v23 = &byte_E3EC0[988 * *(__int16 *)(v25 + 556)];
  v14 = 0;
  v15 = 0;
  if ( *(int *)(a1 + 576) > 0 )
  {
    if ( *(_DWORD *)(a1 + 340) == 1023 )
    {
      if ( *(_DWORD *)(v25 + 912) <= level[123] )
      {
        v11 = g_vehicleTrafficStressTest[3];
        if ( v11 < 0 )
          v11 = -v11;
        if ( v11 > *(_DWORD *)(v25 + 560) )
        {
          LOBYTE(v14) = (__int16)(sin((long double)(int)level[123] * 0.00023424) * 127.0);
          HIBYTE(v14) = (__int16)(cos((long double)(int)level[123] * 0.00236732) * 127.0);
          v15 = 0;
        }
      }
      else
      {
        LOBYTE(v14) = *(_BYTE *)(v25 + 916);
        HIBYTE(v14) = *(_BYTE *)(v25 + 920);
        v15 = 0;
      }
    }
    else
    {
      v12 = &g_entities[211 * *(_DWORD *)(a1 + 340)];
      if ( v12 && v12[88] && *(_DWORD *)(v12[88] + 18068) && VEH_UnlinkPlayer(v12, 1) )
      {
        result = (_DWORD *)v12[88];
        result[4517] = 0;
        return result;
      }
      *(_DWORD *)(v12[88] + 132) |= 0x200000u;
      if ( !*(_DWORD *)(a1 + 792) && *(_DWORD *)(v25 + 956) < level[123] && (*(_DWORD *)(v12[88] + 132) & 0x400000) == 0 )
      {
        v14 = *(_WORD *)(v12[88] + 17720);
        v15 = *(_BYTE *)(v12[88] + 17722);
        if ( (_BYTE)v14 && !*(_DWORD *)(v25 + 896) )
          *(_DWORD *)(v25 + 904) = level[123];
        *(_DWORD *)(v25 + 896) = (char)v14;
        *(_DWORD *)(v25 + 900) = 0;
        if ( *((_WORD *)v23 + 32) == 2
          && *((float *)v23 + 67) == 0.0
          && *((float *)v23 + 68) == 0.0
          && *(float *)(v12[88] + 224) != 0.0 )
        {
          v15 = 127;
        }
        if ( *((_WORD *)v23 + 32) == 2 || (char)v15 > 0 )
          *(_DWORD *)(v12[88] + 132) &= 0xFFDFFFFF;
        if ( *((_WORD *)v23 + 32) == 2 && (v14 & 0x80u) != 0 )
          HIBYTE(v14) = -HIBYTE(v14);
      }
    }
  }
  else
  {
    v14 = 0;
    v15 = 0;
  }
  if ( (_BYTE)v14 || __PAIR16__(HIBYTE(v14), 0) != v15 || !VEH_PhysicsNotRequired(a1, 1) )
  {
    sub_7D709(a1, (char *)&v14, v22, v20);
    sub_7FC99((_DWORD *)a1);
    if ( dword_F3614 )
    {
      *(float *)(v24 + 72) = v20[0] * 0.050000001 + *(float *)(v24 + 72);
      *(float *)(v24 + 76) = v20[1] * 0.050000001 + *(float *)(v24 + 76);
      *(float *)(v24 + 80) = v20[2] * 0.050000001 + *(float *)(v24 + 80);
    }
    v2 = v24;
    v3 = *(float *)(v24 + 76) * 0.050000001 + *(float *)(v24 + 40);
    v6 = v3;
    AngleNormalize180(v6);
    *(float *)(v2 + 28) = v3;
    *(_DWORD *)(v24 + 24) = 0;
    *(_DWORD *)(v24 + 32) = 0;
    if ( *((_WORD *)v23 + 32) == 2 )
      *(float *)(a1 + 108) = *(float *)(a1 + 108) - *(float *)(v24 + 76) * 0.050000001;
    AnglesToAxis(v24 + 24, v16);
    v19 = 0;
    v18 = 0;
    v17 = 0;
    if ( dword_F3614 )
    {
      MatrixTransformVector(v22, v16, v21);
      *(float *)(v24 + 48) = v21[0] * 0.050000001 + *(float *)(v24 + 48);
      *(float *)(v24 + 52) = v21[1] * 0.050000001 + *(float *)(v24 + 52);
      *(float *)(v24 + 56) = v21[2] * 0.050000001 + *(float *)(v24 + 56);
      VEH_GroundFriction(a1);
    }
    if ( *(float *)(v24 + 48) != 0.0
      || *(float *)(v24 + 52) != vec3_origin[1]
      || *(float *)(v24 + 56) != vec3_origin[2]
      || !dword_F3614 )
    {
      sub_7FC99((_DWORD *)a1);
      if ( dword_F3614 )
        sub_81175((_DWORD *)a1);
      else
        sub_812C4((_DWORD *)a1);
    }
    MatrixTransposeTransformVector43(v24 + 48, v16, v24 + 60);
    if ( *((_WORD *)v23 + 32) == 1 || *((_WORD *)v23 + 32) == 2 )
      sub_81331((_DWORD *)a1);
  }
  *(float *)(a1 + 496) = fabs(*(float *)(v24 + 60));
  if ( fabs(*(float *)(v24 + 60)) / *((float *)v23 + 26) > fabs(*(float *)(v24 + 76))
                                                         / (*((float *)v23 + 28) + *((float *)v23 + 28)) )
  {
    if ( fabs(*(float *)(v24 + 60)) / *((float *)v23 + 26) >= 1.0 )
      goto LABEL_59;
LABEL_55:
    if ( fabs(*(float *)(v24 + 60)) / *((float *)v23 + 26) <= fabs(*(float *)(v24 + 76))
                                                            / (*((float *)v23 + 28) + *((float *)v23 + 28)) )
    {
      v9 = *(float *)(v24 + 76);
      HIBYTE(v9) &= 0x7Fu;
      v8 = v9 / (*((float *)v23 + 28) + *((float *)v23 + 28));
    }
    else
    {
      v7 = *(float *)(v24 + 60);
      HIBYTE(v7) &= 0x7Fu;
      v8 = v7 / *((float *)v23 + 26);
    }
    v10 = v8;
    goto LABEL_60;
  }
  if ( fabs(*(float *)(v24 + 76)) / (*((float *)v23 + 28) + *((float *)v23 + 28)) < 1.0 )
    goto LABEL_55;
LABEL_59:
  v10 = 1.0;
LABEL_60:
  v13 = 1.0 - v10;
  v4 = v25;
  *(float *)(v4 + 724) = sub_7C5C5(v13, *(float *)(v25 + 724), 4.0);
  v5 = v25;
  *(float *)(v5 + 728) = sub_7C5C5(v10, *(float *)(v25 + 728), 4.0);
  result = g_vehicleDebug;
  if ( g_vehicleDebug[3] )
    result = (_DWORD *)sub_7C110(v24, *((float *)v23 + 216), *((float *)v23 + 218), 1065353216, 1065353216, 0);
  return result;
}
// 167F4: using guessed type _DWORD __cdecl MatrixTransposeTransformVector43(_DWORD, _DWORD, _DWORD);
// 17594: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 17B24: using guessed type _DWORD __cdecl VEH_PhysicsNotRequired(_DWORD, _DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 19144: using guessed type _DWORD __cdecl VEH_GroundFriction(_DWORD);
// F3614: using guessed type int dword_F3614;

//----- (00088561) --------------------------------------------------------
void __cdecl sub_88561(int a1)
{
  long double v1; // fst7
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // ecx
  float v10; // [esp+28h] [ebp-100h]
  float v11; // [esp+30h] [ebp-F8h]
  int v12; // [esp+34h] [ebp-F4h]
  float v13; // [esp+38h] [ebp-F0h]
  float v14[49]; // [esp+40h] [ebp-E8h] BYREF
  float *v15; // [esp+104h] [ebp-24h]
  char *v16; // [esp+108h] [ebp-20h]
  float *v17; // [esp+10Ch] [ebp-1Ch]

  v17 = *(float **)(a1 + 356);
  v16 = &byte_E3EC0[988 * *((__int16 *)v17 + 278)];
  v15 = v17 + 46;
  qmemcpy(v14, v17, 0xB8u);
  v12 = 0;
  v13 = *(float *)(a1 + 496);
  if ( SLOWORD(v14[0]) >= 0 )
  {
    if ( *((_DWORD *)v17 + 157) )
    {
      if ( *((_DWORD *)v17 + 157) == 2 )
        v11 = v17[2];
      else
        v11 = v17[158];
      if ( v11 <= (long double)*(float *)(a1 + 496) )
      {
        *(float *)(a1 + 496) = *(float *)(a1 + 496) - v17[159] * 0.050000001;
        if ( v11 > (long double)*(float *)(a1 + 496) )
          *(float *)(a1 + 496) = v11;
      }
      else
      {
        *(float *)(a1 + 496) = v17[159] * 0.050000001 + *(float *)(a1 + 496);
        if ( *(float *)(a1 + 496) > (long double)v11 )
          *(float *)(a1 + 496) = v11;
      }
      if ( *((_DWORD *)v17 + 157) == 2 && *(float *)(a1 + 496) == v11 )
        v17[157] = 0.0;
    }
    else
    {
      *(float *)(a1 + 496) = v17[2];
    }
    if ( v17[2] > 0.0 )
      v17[160] = *(float *)(a1 + 496) / v17[2] + v17[160];
    G_VehUpdatePathPos(v14, *((__int16 *)v17 + 284));
    while ( v17[160] > 1.0 )
    {
      v17[160] = v17[160] - 1.0;
      qmemcpy(v17, v14, 0xB8u);
      if ( G_VehUpdatePathPos(v14, *((__int16 *)v17 + 284)) )
        v12 = 1;
    }
    if ( *((_WORD *)v17 + 1) )
      *(_DWORD *)(a1 + 496) = 0;
    *v15 = (v14[5] - v17[5]) * v17[160] + v17[5];
    v15[1] = (v14[6] - v17[6]) * v17[160] + v17[6];
    v1 = (v14[7] - v17[7]) * v17[160] + v17[7];
    v15[2] = v1;
    v2 = (int)v15;
    LerpAngle(v17[8], SLODWORD(v14[8]), v17[160]);
    *(float *)(v2 + 24) = v1;
    v3 = (int)v15;
    LerpAngle(v17[9], SLODWORD(v14[9]), v17[160]);
    *(float *)(v3 + 28) = v1;
    v4 = (int)v15;
    LerpAngle(v17[10], SLODWORD(v14[10]), v17[160]);
    *(float *)(v4 + 32) = v1;
    v5 = (int)v15;
    sub_7C6CF(v15[6], v15[9], 6.0);
    *(float *)(v5 + 24) = v1;
    v6 = (int)v15;
    sub_7C6CF(v15[7], v15[10], 4.0);
    *(float *)(v6 + 28) = v1;
    v7 = (int)v15;
    sub_7C6CF(v15[8], v15[11], 6.0);
    *(float *)(v7 + 32) = v1;
    if ( g_vehicleDebug[3] )
      sub_7C02C((int)(v17 + 11), 8.0, 0, 1065353216, 1065353216);
    v15[12] = *v15 - v15[3];
    v15[13] = v15[1] - v15[4];
    v15[14] = v15[2] - v15[5];
    v15[12] = v15[12] * 20.0;
    v15[13] = v15[13] * 20.0;
    v15[14] = v15[14] * 20.0;
    v8 = (int)v15;
    v9 = (int)v15;
    v15[17] = 0.0;
    *(_DWORD *)(v9 + 64) = 0;
    *(_DWORD *)(v8 + 60) = 0;
    v15[15] = *(float *)(a1 + 496);
    AnglesSubtract(v15 + 6, v15 + 9, v15 + 18);
    v15[18] = v15[18] * 20.0;
    v15[19] = v15[19] * 20.0;
    v15[20] = v15[20] * 20.0;
    if ( v12 && *((__int16 *)v17 + 284) > -1 )
      Scr_Notify(a1, scr_const[56], 0);
    if ( *((_WORD *)v17 + 1) )
      Scr_Notify(a1, scr_const[55], 0);
    if ( *(float *)(a1 + 496) / *((float *)v16 + 207) >= 0.0 )
    {
      if ( *(float *)(a1 + 496) / *((float *)v16 + 207) <= 1.0 )
        v10 = *(float *)(a1 + 496) / *((float *)v16 + 207);
      else
        v10 = 1.0;
    }
    else
    {
      v10 = 0.0;
    }
    v17[182] = v10;
    v17[181] = 1.0 - v17[182];
    if ( v17[143] >= 0.0
      && (v17[143] >= (long double)v13 && *(float *)(a1 + 496) >= (long double)v17[143]
       || v13 >= (long double)v17[143] && v17[143] >= (long double)*(float *)(a1 + 496)) )
    {
      Scr_Notify(a1, scr_const[57], 0);
    }
  }
}
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 17A94: using guessed type _DWORD __cdecl G_VehUpdatePathPos(_DWORD, _DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (00088C78) --------------------------------------------------------
int __cdecl sub_88C78(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-10h]
  int i; // [esp+8h] [ebp-Ch]
  char *v7; // [esp+Ch] [ebp-8h]

  v7 = &byte_E3EC0[988 * *(__int16 *)(a1 + 556)];
  if ( a3 )
    v5 = -1;
  else
    v5 = 1;
  for ( i = a2 + v5; i != a2; i += v5 )
  {
    if ( i )
    {
      if ( i <= 6 )
      {
        if ( i > 0 )
        {
          if ( (i != 2 || *((_DWORD *)v7 + 23))
            && (i <= 2 || *((_DWORD *)v7 + 24) > i - 3)
            && *(_DWORD *)(a1 + 4 * i + 924) == 1023 )
          {
            return i;
          }
        }
        else
        {
          i = 7;
        }
      }
      else
      {
        i = -v5;
      }
    }
  }
  return 0;
}
// 88D12: conditional instruction was optimized away because of '%var_C.4 in (3..6)'

//----- (00088D5C) --------------------------------------------------------
int __cdecl sub_88D5C(int a1, unsigned int a2)
{
  char v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]

  if ( a2 == 2 )
    return *(_DWORD *)(a1 + 784);
  if ( a2 > 2 )
  {
    if ( a2 > 6 )
    {
LABEL_9:
      Com_Error(1, byte_A6D80, v3);
      return -1;
    }
    v4 = *(_DWORD *)(a1 + 4 * a2 + 864);
  }
  else
  {
    if ( a2 != 1 )
      goto LABEL_9;
    v4 = *(_DWORD *)(a1 + 756);
  }
  return v4;
}
// 88DD9: variable 'v3' is possibly undefined

//----- (00088DEE) --------------------------------------------------------
_BOOL4 __cdecl VEH_FindValidDismountSpot(float *a1, float *a2, int a3, float *a4, float *a5, int a6)
{
  char v7; // [esp+4h] [ebp-194h]
  float v8; // [esp+34h] [ebp-164h]
  float v9; // [esp+38h] [ebp-160h]
  float v10; // [esp+3Ch] [ebp-15Ch]
  float v11; // [esp+40h] [ebp-158h]
  float v12; // [esp+44h] [ebp-154h]
  float v13; // [esp+44h] [ebp-154h]
  float v14; // [esp+48h] [ebp-150h]
  char v16[48]; // [esp+50h] [ebp-148h] BYREF
  int v17; // [esp+80h] [ebp-118h]
  int v18; // [esp+84h] [ebp-114h]
  int v19; // [esp+88h] [ebp-110h]
  int v20[2]; // [esp+90h] [ebp-108h] BYREF
  float v21; // [esp+98h] [ebp-100h]
  int v22[2]; // [esp+A0h] [ebp-F8h] BYREF
  float v23; // [esp+A8h] [ebp-F0h]
  int v24[2]; // [esp+B0h] [ebp-E8h] BYREF
  float v25; // [esp+B8h] [ebp-E0h]
  int v26[4]; // [esp+C0h] [ebp-D8h] BYREF
  int v27[2]; // [esp+D0h] [ebp-C8h] BYREF
  float v28; // [esp+D8h] [ebp-C0h]
  float v29; // [esp+E4h] [ebp-B4h]
  int k; // [esp+E8h] [ebp-B0h]
  float j; // [esp+ECh] [ebp-ACh]
  float i; // [esp+F0h] [ebp-A8h]
  float v33; // [esp+F4h] [ebp-A4h]
  float v34; // [esp+F8h] [ebp-A0h]
  float v35; // [esp+FCh] [ebp-9Ch]
  float v36; // [esp+100h] [ebp-98h]
  float v37; // [esp+104h] [ebp-94h]
  float v38; // [esp+108h] [ebp-90h]
  float v39; // [esp+10Ch] [ebp-8Ch]
  float v40; // [esp+110h] [ebp-88h]
  int v41; // [esp+114h] [ebp-84h]
  int v42; // [esp+118h] [ebp-80h]
  float v43; // [esp+120h] [ebp-78h] BYREF
  float v44; // [esp+124h] [ebp-74h]
  float v45; // [esp+128h] [ebp-70h]
  float v46; // [esp+130h] [ebp-68h] BYREF
  float v47; // [esp+134h] [ebp-64h]
  float v48; // [esp+138h] [ebp-60h]
  float v49; // [esp+140h] [ebp-58h]
  float v50; // [esp+144h] [ebp-54h]
  float v51; // [esp+148h] [ebp-50h]
  int v52; // [esp+154h] [ebp-44h]
  float *v53; // [esp+158h] [ebp-40h]
  int v54; // [esp+15Ch] [ebp-3Ch]
  float s[10]; // [esp+160h] [ebp-38h] BYREF
  unsigned __int16 v56; // [esp+188h] [ebp-10h]
  char v57; // [esp+18Eh] [ebp-Ah]
  char v58; // [esp+18Fh] [ebp-9h]

  v54 = *((_DWORD *)a1 + 89);
  v53 = (float *)((char *)&unk_E3EC0 + 988 * *(__int16 *)(v54 + 556));
  if ( v53[26] <= 0.0 )
  {
    if ( *(int *)(*((_DWORD *)a1 + 89) + 760) >= 0 )
    {
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(*((_DWORD *)a1 + 89) + 760), v16);
      *(_DWORD *)a5 = v17;
      *((_DWORD *)a5 + 1) = v18;
      *((_DWORD *)a5 + 2) = v19;
    }
    else
    {
      Com_Printf("VEH_UnlinkPlayer: Warning - no [tag_detach] on vehicle\n", v7);
      *a5 = a1[79];
      a5[1] = a1[80];
      a5[2] = a1[81];
      a5[2] = v53[218] + 48.0 + a5[2];
    }
    trap_TraceCapsule(s, a5, a3, a4, a5, a6, 42008593);
    v52 = 0;
    while ( s[0] < 1.0 || v58 )
    {
      if ( ++v52 > 7 )
        break;
      a5[2] = a5[2] + 4.0;
      trap_TraceCapsule(s, a5, a3, a4, a5, a6, 42008593);
    }
    return v52 <= 7;
  }
  AngleVectors(v54 + 208, &v46, &v43, 0);
  v29 = sqrt(
          *(float *)(v54 + 232) * *(float *)(v54 + 232)
        + *(float *)(v54 + 236) * *(float *)(v54 + 236)
        + *(float *)(v54 + 240) * *(float *)(v54 + 240));
  if ( v29 <= 0.0 )
  {
    v49 = *a2 - *(float *)(v54 + 184);
    v50 = a2[1] - *(float *)(v54 + 188);
    v51 = a2[2] - *(float *)(v54 + 192);
  }
  else
  {
    LODWORD(v49) = *(_DWORD *)(v54 + 232) ^ 0x80000000;
    LODWORD(v50) = *(_DWORD *)(v54 + 236) ^ 0x80000000;
    LODWORD(v51) = *(_DWORD *)(v54 + 240) ^ 0x80000000;
  }
  v51 = 0.0;
  v29 = sqrt(v49 * v49 + v50 * v50 + 0.0 * 0.0);
  if ( v29 < 0.0000099999997 )
  {
    v49 = 1.0;
    v50 = 0.0;
  }
  v39 = v43 * v49 + v44 * v50 + v45 * v51;
  v38 = v46 * v49 + v47 * v50 + v48 * v51;
  v37 = v53[222] + a4[1] + 60.0;
  v14 = *a4;
  if ( v53[230] <= (long double)v53[229] )
    v12 = v14 + v53[229];
  else
    v12 = v14 + v53[230];
  v13 = v12 + 100.0;
  v36 = v13;
  v34 = fabs(v39);
  v33 = fabs(v38);
  if ( v34 <= (long double)v33 )
  {
    v35 = v36 / fabs(v38);
    v39 = v39 * v35;
    v38 = v38 * v35;
  }
  else
  {
    v35 = v37 / fabs(v39);
    v39 = v39 * v35;
    v38 = v38 * v35;
    if ( v38 >= 0.0 )
    {
      if ( *a4 <= (long double)v38 )
        v10 = v38;
      else
        v10 = *a4;
      v38 = v10;
    }
    else
    {
      if ( v38 <= -*a4 )
        v11 = v38;
      else
        LODWORD(v11) = *(_DWORD *)a4 ^ 0x80000000;
      v38 = v11;
    }
  }
  if ( -v37 <= (long double)v39 )
  {
    if ( v39 <= (long double)v37 )
      v9 = v39;
    else
      v9 = v37;
  }
  else
  {
    LODWORD(v9) = LODWORD(v37) ^ 0x80000000;
  }
  v39 = v9;
  if ( -v36 <= (long double)v38 )
  {
    if ( v38 <= (long double)v36 )
      v8 = v38;
    else
      v8 = v36;
  }
  else
  {
    LODWORD(v8) = LODWORD(v36) ^ 0x80000000;
  }
  v38 = v8;
  v52 = 0;
  memset(s, 0, 0x30u);
  do
  {
    *a5 = 0.0;
    a5[1] = 0.0;
    a5[2] = 4.0;
    *a5 = *(float *)(v54 + 184) + *a5;
    a5[1] = *(float *)(v54 + 188) + a5[1];
    a5[2] = *(float *)(v54 + 192) + a5[2];
    *a5 = v46 * v38 + *a5;
    a5[1] = v47 * v38 + a5[1];
    a5[2] = v48 * v38 + a5[2];
    *a5 = v43 * v39 + *a5;
    a5[1] = v44 * v39 + a5[1];
    a5[2] = v45 * v39 + a5[2];
    v40 = *a5;
    v41 = *((_DWORD *)a5 + 1);
    v42 = *((_DWORD *)a5 + 2);
    for ( i = -80.0; i < 80.0; i = i + 20.0 )
    {
      for ( j = -80.0; j < 80.0; j = j + 20.0 )
      {
        for ( k = 0; k <= 1; ++k )
        {
          trap_TraceCapsule(s, a5, a3, a4, a5, a6, 0x2000000);
          if ( s[0] == 1.0 && !v58 )
          {
            v27[0] = *(int *)a5;
            v27[1] = (int)a5[1];
            v28 = a5[2];
            v28 = v28 - 256.0;
            trap_TraceCapsule(s, a5, a3, a4, v27, 1023, 8454161);
            if ( !v58 && !v57 && s[0] < 1.0 )
            {
              v26[0] = *(_DWORD *)(level[0] + 18228 * a6 + 1372);
              v26[1] = *(_DWORD *)(level[0] + 18228 * a6 + 1376);
              v26[2] = *(_DWORD *)(level[0] + 18228 * a6 + 1380);
              v24[0] = *(_DWORD *)(level[0] + 18228 * a6 + 1384);
              v24[1] = *(_DWORD *)(level[0] + 18228 * a6 + 1388);
              v25 = *(float *)(level[0] + 18228 * a6 + 1392);
              v25 = v25 - 30.0;
              v22[0] = *(int *)a5;
              v22[1] = (int)a5[1];
              v23 = a5[2];
              v23 = v23 + 30.0;
              v20[0] = *(_DWORD *)(v54 + 184);
              v20[1] = *(_DWORD *)(v54 + 188);
              v21 = *(float *)(v54 + 192);
              v21 = v21 + 30.0;
              trap_Trace(s, v20, v26, v24, v22, g_entities[211 * a6 + 85], 8454161);
              if ( !v58 && (s[0] == 1.0 || v56 == *(_DWORD *)a1) )
                return v52 <= 3;
            }
          }
          a5[2] = a5[2] + 32.0;
        }
        *a5 = v40;
        *((_DWORD *)a5 + 1) = v41;
        *((_DWORD *)a5 + 2) = v42;
        *a5 = *a5 + i;
        a5[1] = a5[1] + j;
      }
    }
    if ( (v52 & 1) != 0 )
      HIBYTE(v39) ^= 0x80u;
    else
      HIBYTE(v38) ^= 0x80u;
    ++v52;
  }
  while ( v52 <= 3 );
  return v52 <= 3;
}
// 89807: variable 'v7' is possibly undefined
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 19464: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008998D) --------------------------------------------------------
void __cdecl sub_8998D(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char v4; // al
  int v5; // esi
  int v6; // eax
  char v7; // al
  char v8; // [esp+4h] [ebp-D4h]
  char v9; // [esp+8h] [ebp-D0h]
  char v10; // [esp+8h] [ebp-D0h]
  int v11; // [esp+28h] [ebp-B0h]
  int v12; // [esp+2Ch] [ebp-ACh]
  char v13[8]; // [esp+30h] [ebp-A8h] BYREF
  int v14; // [esp+38h] [ebp-A0h]
  char v15[64]; // [esp+40h] [ebp-98h] BYREF
  char v16[48]; // [esp+80h] [ebp-58h] BYREF
  int v17; // [esp+B0h] [ebp-28h] BYREF
  int v18; // [esp+C4h] [ebp-14h]
  char *v19; // [esp+C8h] [ebp-10h]
  int v20; // [esp+CCh] [ebp-Ch]

  v20 = *(_DWORD *)(a1 + 356);
  v19 = &byte_E3EC0[988 * *(__int16 *)(v20 + 556)];
  v18 = a2[88];
  if ( (*(_DWORD *)(v18 + 132) & 0x100000) != 0 )
    Com_Error(1, byte_A6E40, v9);
  if ( a2[85] != 1023 )
    Com_Error(1, byte_A6E80, v9);
  if ( *(_DWORD *)(a1 + 796)
    && *(_DWORD *)(*(_DWORD *)(a1 + 796) + 352)
    && *(_DWORD *)(v20 + 928) == 1023
    && a2 != *(_DWORD **)(a1 + 796) )
  {
    v3 = va("e \"GMI_GAME_VEHICLE_NOT_OWNER\"", v8);
    trap_SendServerCommand(1852331867 * (a2 - g_entities), 0, v3);
  }
  else if ( (a2[31] != 1023 || *(float *)(v18 + 40) >= -80.0) && *(_DWORD *)(v18 + 18060) <= level[123] - 250 )
  {
    if ( *((_WORD *)v19 + 32) != 2 || *(_DWORD *)(v18 + 18224) )
      *(_DWORD *)(v18 + 18060) = level[123] + 1500;
    else
      *(_DWORD *)(v18 + 18060) = level[123];
    if ( a3 && *(_DWORD *)(v20 + 4 * a3 + 924) != 1023 )
      a3 = 0;
    if ( a3 )
      v12 = a3;
    else
      v12 = sub_88C78(v20, 0, 0);
    if ( !v12 )
      Com_Error(1, byte_A6EE0, v9);
    v11 = sub_88D5C(v20, v12);
    if ( v11 < 0 )
    {
      v4 = BG_GetVehiclePosTag(v12);
      Com_Error(1, byte_A6F20, v4);
    }
    G_DObjGetWorldBoneIndexMatrix(a1, v11, v16);
    if ( v12 == 1 )
    {
      if ( *(int *)(v20 + 756) < 0 )
        Com_Error(1, byte_A6F60, v10);
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v20 + 756), v15);
    }
    else if ( v12 == 2 )
    {
      if ( *(int *)(v20 + 788) < 0 )
        Com_Error(1, byte_A6FC0, v10);
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v20 + 788), v15);
    }
    else
    {
      if ( *(int *)(v20 + 768) < 0 )
        Com_Error(1, byte_A7020, v10);
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v20 + 768), v15);
    }
    Axis4ToAngles(v15, v13);
    v14 = 0;
    SetClientOrigin(a2, &v17);
    SetClientViewAngle(a2, v13);
    v5 = BG_GetVehiclePosOffset(*((__int16 *)v19 + 32), a3);
    v6 = BG_GetVehiclePosTag(v12);
    if ( !G_EntLinkToWithOffset(a2, a1, v6, v5, vec3_origin) )
    {
      v7 = BG_GetVehiclePosTag(v12);
      Com_Error(1, byte_A7080, v7);
    }
    if ( *(_DWORD *)(v20 + 648) == *a2 )
    {
      *(_DWORD *)(v20 + 644) = 0;
      *(_DWORD *)(v20 + 648) = 1023;
    }
    *(_DWORD *)(v20 + 4 * v12 + 924) = *a2;
    *(_DWORD *)(a1 + 228) |= 1 << v12;
    if ( v12 == 1 )
    {
      *(_BYTE *)(a1 + 382) = 2;
      *(_DWORD *)(a1 + 8) |= 0x100000u;
      *(_DWORD *)(a1 + 340) = *a2;
      *(_DWORD *)(a1 + 116) = *a2;
    }
    a2[85] = *(_DWORD *)a1;
    *(_DWORD *)(v18 + 132) |= 0x300000u;
    *(_DWORD *)(v18 + 132) &= 0xFFBFFFFF;
    *(_DWORD *)(v18 + 1468) = *(_DWORD *)a1;
    *(_DWORD *)(v18 + 12) &= 0xFFFFFFDF;
    trap_SendServerCommand(*(_DWORD *)(v18 + 212), 1, "v cl_run 1");
    trap_SendServerCommand(*(_DWORD *)(v18 + 212), 1, "v cl_stance 0");
    *(_DWORD *)(v18 + 1556) = v12;
    *(_DWORD *)(v18 + 1560) = *((__int16 *)v19 + 32);
    Scr_AddEntity(a2);
    Scr_AddInt(*(_DWORD *)(v18 + 1556));
    Scr_Notify(a1, scr_const[151], 2);
    Scr_AddEntity(a1);
    Scr_AddInt(*(_DWORD *)(v18 + 1556));
    Scr_Notify(a2, scr_const[154], 2);
    *(_DWORD *)(a1 + 240) = *((_DWORD *)v19 + 91);
    *(_DWORD *)(a1 + 236) = *((_DWORD *)v19 + 90);
  }
}
// 899FB: variable 'v9' is possibly undefined
// 89A69: variable 'v8' is possibly undefined
// 89C27: variable 'v10' is possibly undefined
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16FC4: using guessed type _DWORD __cdecl BG_GetVehiclePosOffset(_DWORD, _DWORD);
// 17734: using guessed type _DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 18134: using guessed type _DWORD __cdecl Axis4ToAngles(_DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 181D4: using guessed type _DWORD __cdecl BG_GetVehiclePosTag(_DWORD);
// 18834: using guessed type _DWORD __cdecl SetClientOrigin(_DWORD, _DWORD);
// 18854: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00089FB2) --------------------------------------------------------
int __cdecl VEH_UnlinkPlayer(_DWORD *a1, int a2)
{
  int v2; // eax
  int v3; // eax
  char v5; // [esp+4h] [ebp-64h]
  char v6; // [esp+4h] [ebp-64h]
  char v7; // [esp+8h] [ebp-60h]
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+2Ch] [ebp-3Ch]
  char v10[20]; // [esp+30h] [ebp-38h] BYREF
  _DWORD *v11; // [esp+44h] [ebp-24h]
  _DWORD *v12; // [esp+48h] [ebp-20h]
  int v13; // [esp+4Ch] [ebp-1Ch]

  v12 = (_DWORD *)a1[88];
  if ( (v12[33] & 0x100000) == 0 )
    Com_Error(1, byte_A70E0, v7);
  if ( a1[85] == 1023 )
  {
    v12[33] &= 0xFF8FFFFF;
    Com_Printf(byte_A7120, v5);
    v8 = 1;
  }
  else
  {
    v11 = &g_entities[211 * a1[85]];
    v9 = v11[89];
    v13 = (int)&unk_E3EC0 + 988 * *(__int16 *)(v9 + 556);
    if ( (int)v11[144] > 0
      && a2
      && *(_DWORD *)(a1[88] + 18060) > level[123] - 1500
      && *(int *)(a1[88] + 18224) <= 1
      && *(_WORD *)(v13 + 64) == 2 )
    {
      v2 = va("e \"GMI_GAME_VEHICLE_EXIT_DELAY\"", v5);
      trap_SendServerCommand(1852331867 * (a1 - g_entities), 0, v2);
      v8 = 0;
    }
    else if ( !a2 || VEH_FindValidDismountSpot(v11, v12 + 5, a1 + 66, a1 + 69, v10, *a1) )
    {
      G_EntUnlink(a1);
      *(_DWORD *)(v9 + 4 * *(_DWORD *)(a1[88] + 1556) + 924) = 1023;
      v11[57] &= ~(1 << *(_BYTE *)(a1[88] + 1556));
      if ( *(_DWORD *)(a1[88] + 1556) == 1 )
      {
        v11[2] &= 0xFFEFFFFF;
        v11[85] = 1023;
        v11[29] = 1023;
        v11[38] = 0;
        if ( !v11[198] && *(_WORD *)(v13 + 64) == 2 )
        {
          *(_DWORD *)(v9 + 912) = level[123] + 3000;
          if ( *(_DWORD *)(v9 + 896) && *(_DWORD *)(v9 + 904) < level[123] - 750 )
            *(_DWORD *)(v9 + 916) = *(_DWORD *)(v9 + 896);
          else
            *(_DWORD *)(v9 + 916) = 0;
          if ( *(_DWORD *)(v9 + 900) && *(_DWORD *)(v9 + 908) < level[123] - 750 )
            *(_DWORD *)(v9 + 920) = *(_DWORD *)(v9 + 900);
          else
            *(_DWORD *)(v9 + 920) = 0;
        }
      }
      else if ( *(_DWORD *)(a1[88] + 1556) == 2 )
      {
        if ( *(_DWORD *)(v11[89] + 716) != 1023 && *(int *)(v9 + 740) > 0 )
          *(_DWORD *)(v9 + 740) = 10;
        *(_DWORD *)(a1[88] + 12) &= 0xFF7FFFFF;
      }
      if ( v11[29] == *a1 )
        v11[29] = 1023;
      a1[85] = 1023;
      v12[33] &= 0xFF8FFFFF;
      v12[367] = 1023;
      v12[389] = 0;
      v12[3] &= 0xFFFFFFDF;
      v12[56] = 0;
      trap_SendServerCommand(v12[53], 1, "v cl_run 1");
      trap_SendServerCommand(v12[53], 1, "v cl_stance 0");
      a1[200] = level[123] + 2000;
      a1[201] = *v11;
      if ( a2 )
      {
        SetClientOrigin(a1, v10);
        if ( *(_DWORD *)(v9 + 912) > level[123] )
        {
          *(_DWORD *)(a1[88] + 40) = 1128792064;
          *(_DWORD *)(a1[88] + 32) = 0;
          *(_DWORD *)(a1[88] + 36) = 0;
        }
      }
      Scr_AddEntity(a1);
      Scr_Notify(v11, scr_const[152], 1);
      Scr_AddEntity(v11);
      Scr_Notify(a1, scr_const[155], 1);
      v8 = 1;
    }
    else
    {
      v3 = va("e \"GMI_GAME_VEHICLE_UNLINK_BLOCKED\"", v6);
      trap_SendServerCommand(1852331867 * (a1 - g_entities), 0, v3);
      v8 = 0;
    }
  }
  return v8;
}
// 89FF5: variable 'v7' is possibly undefined
// 8A029: variable 'v5' is possibly undefined
// 8A16D: variable 'v6' is possibly undefined
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18834: using guessed type _DWORD __cdecl SetClientOrigin(_DWORD, _DWORD);
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 18FC4: using guessed type _DWORD __cdecl VEH_FindValidDismountSpot(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (0008A51F) --------------------------------------------------------
int G_ParseScrVehicleInfo()
{
  int result; // eax
  int v1; // esi
  float *v2; // esi
  int l; // [esp+20h] [ebp-3178h]
  int i; // [esp+24h] [ebp-3174h]
  int j; // [esp+24h] [ebp-3174h]
  int k; // [esp+24h] [ebp-3174h]
  size_t v7; // [esp+28h] [ebp-3170h]
  int v8; // [esp+2Ch] [ebp-316Ch]
  int v9; // [esp+30h] [ebp-3168h]
  int v10; // [esp+34h] [ebp-3164h] BYREF
  float *v11; // [esp+38h] [ebp-3160h]
  char *v12; // [esp+3Ch] [ebp-315Ch]
  char s1[8192]; // [esp+40h] [ebp-3158h] BYREF
  char v14[64]; // [esp+2040h] [ebp-1158h] BYREF
  char *src[64]; // [esp+2080h] [ebp-1118h]
  char v16[4104]; // [esp+2180h] [ebp-1018h] BYREF
  size_t n; // [esp+3188h] [ebp-10h]
  char *s; // [esp+318Ch] [ebp-Ch]

  s = "VEHICLEFILE";
  n = strlen("VEHICLEFILE");
  word_F35C0 = 0;
  v9 = trap_FS_GetFileList("vehicles", &unk_A71B0, v16, 4096);
  if ( v9 > 64 )
    Com_Error(1, byte_A71C0, 64);
  v12 = v16;
  for ( i = 0; i < v9; ++i )
  {
    v7 = strlen(v12);
    src[i] = v12;
    v12 += v7 + 1;
  }
  for ( j = 0; j < v9; ++j )
  {
    sprintf(v14, "%s/%s", "vehicles", src[j]);
    v8 = trap_FS_FOpenFile(v14, &v10, 0);
    if ( v8 > 0 )
    {
      trap_FS_Read(s1, n, v10);
      s1[n] = 0;
      if ( !strncmp(s1, s, n) )
      {
        if ( (int)(v8 - n) <= 0x1FFF )
        {
          trap_FS_Read(s1, v8 - n, v10);
          s1[v8 - n] = 0;
          trap_FS_FCloseFile(v10);
          if ( Info_Validate(s1) )
          {
            strcpy(&byte_E3EC0[988 * word_F35C0], src[j]);
            if ( ParseConfigStringToStruct(
                   (int)&byte_E3EC0[988 * word_F35C0],
                   (int)&off_AE9C0,
                   *(__int16 *)":",
                   s1,
                   9,
                   (int)VEH_ParseSpecificField,
                   (int)sub_7BFA8) )
            {
              ++word_F35C0;
            }
          }
          else
          {
            Com_Error(1, byte_A7280, (char)v14);
          }
        }
        else
        {
          Com_Error(1, byte_A7262, (char)v14);
        }
      }
      else
      {
        Com_Error(1, byte_A7240, (char)v14);
      }
    }
    else
    {
      Com_Error(1, byte_A7200, (char)v14);
    }
  }
  for ( k = 0; ; ++k )
  {
    result = word_F35C0;
    if ( k >= word_F35C0 )
      break;
    v11 = (float *)&byte_E3EC0[988 * k];
    v11[27] = v11[27] * 17.6;
    v11[33] = v11[33] * 17.6;
    v11[26] = v11[26] * 17.6;
    v11[207] = v11[207] * 17.6;
    v11[213] = v11[219] * 0.5;
    v11[214] = v11[220] * 0.5;
    v11[215] = v11[221] * 0.5;
    v11[216] = v11[222] * 0.5;
    v11[217] = v11[223] * 0.5;
    v11[218] = v11[224] * 0.5;
    for ( l = 0; l <= 6; ++l )
    {
      if ( LOBYTE(v11[16 * l + 93]) )
      {
        v1 = (int)v11 + l + 816;
        *(_BYTE *)(v1 + 4) = G_SoundAliasIndex((char *)&v11[16 * l + 93]);
      }
      else
      {
        *((_BYTE *)v11 + l + 820) = 0;
      }
    }
    v2 = v11;
    *((_BYTE *)v2 + 827) = G_SoundAliasIndex("vehicle_hit_person");
  }
  return result;
}
// 16E54: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 17664: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 18504: using guessed type _DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD);
// 197A4: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// AE9C0: using guessed type char *off_AE9C0;
// F35C0: using guessed type __int16 word_F35C0;

//----- (0008AABC) --------------------------------------------------------
void *G_InitScrVehicles()
{
  void *result; // eax
  __int16 i; // [esp+12h] [ebp-6h]

  for ( i = 0; i <= 63; ++i )
  {
    G_VehInitPathPos((char *)&unk_D43C0 + 1004 * i);
    dword_D43C8[251 * i + 136] = 1023;
  }
  result = &unk_D43C0;
  level[6] = &unk_D43C0;
  return result;
}
// 17744: using guessed type _DWORD __cdecl G_VehInitPathPos(_DWORD);

//----- (0008AB36) --------------------------------------------------------
void G_SetupScrVehicles()
{
  __int16 i; // [esp+Ah] [ebp-Eh]
  char *v1; // [esp+Ch] [ebp-Ch]
  _DWORD *v2; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 63; ++i )
  {
    v1 = (char *)&unk_D43C0 + 1004 * i;
    if ( *((_DWORD *)v1 + 138) != 1023 )
    {
      v2 = sub_7C280(*((_DWORD *)v1 + 138));
      VEH_SetupCollmap(v2);
    }
  }
}
// 17034: using guessed type _DWORD __cdecl VEH_SetupCollmap(_DWORD);

//----- (0008ABAF) --------------------------------------------------------
int G_FreeScrVehicles()
{
  int result; // eax
  __int16 i; // [esp+12h] [ebp-6h]

  for ( i = 0; i <= 63; ++i )
  {
    G_VehFreePathPos((char *)&unk_D43C0 + 1004 * i);
    result = (unsigned __int16)i + 1;
  }
  return result;
}
// 187C4: using guessed type _DWORD __cdecl G_VehFreePathPos(_DWORD);

//----- (0008ABFD) --------------------------------------------------------
void __cdecl G_SpawnVehicle(int a1, char *s1, int a3)
{
  char v3; // al
  __int16 v4; // [esp+Ch] [ebp-Ch]
  __int16 i; // [esp+Eh] [ebp-Ah]
  _DWORD *s; // [esp+10h] [ebp-8h]

  s = 0;
  for ( i = 0; i <= 63; ++i )
  {
    s = (_DWORD *)((char *)&unk_D43C0 + 1004 * i);
    if ( s[138] == 1023 )
      break;
  }
  if ( i == 64 )
    Com_Error(1, byte_A72BC, 64);
  memset(s, 0, 0x3ECu);
  s[162] = 1023;
  s[177] = 1023;
  s[178] = 1023;
  s[179] = 1023;
  s[180] = 1023;
  v4 = sub_7C33F(s1);
  if ( v4 < 0 )
  {
    v3 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 486));
    Com_Error(1, byte_A72E0, v3);
  }
  s[140] = i;
  *(_DWORD *)(a1 + 120) = i;
  sub_7C935(a1, (int)s, v4);
  sub_7CEBF(a1, (int)s, v4);
  if ( !a3 )
    VEH_SetupCollmap(a1);
}
// 17034: using guessed type _DWORD __cdecl VEH_SetupCollmap(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0008AD7D) --------------------------------------------------------
int __cdecl G_FreeVehicle(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 576) = 0;
  sub_87480((_DWORD *)a1);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 356) + 708) != 1023 )
    G_FreeEntity(&g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 356) + 708)]);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 356) + 712) != 1023 )
    G_FreeEntity(&g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 356) + 712)]);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 356) + 716) != 1023 )
    G_FreeEntity(&g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 356) + 716)]);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 356) + 720) != 1023 )
    G_FreeEntity(&g_entities[211 * *(_DWORD *)(*(_DWORD *)(a1 + 356) + 720)]);
  *(_DWORD *)(a1 + 528) = 0;
  *(_DWORD *)(a1 + 548) = 0;
  *(_DWORD *)(a1 + 552) = 0;
  *(_DWORD *)(a1 + 540) = 0;
  *(_DWORD *)(a1 + 544) = 0;
  *(_DWORD *)(a1 + 560) = 0;
  *(_DWORD *)(a1 + 524) = 0;
  *(_BYTE *)(a1 + 381) = 0;
  *(_DWORD *)(a1 + 496) = 0;
  *(_BYTE *)(a1 + 382) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  Scr_SetString(*(_DWORD *)(a1 + 356) + 56, 0);
  Scr_SetString(*(_DWORD *)(a1 + 356) + 120, 0);
  Scr_SetString(*(_DWORD *)(a1 + 356) + 58, 0);
  Scr_SetString(*(_DWORD *)(a1 + 356) + 122, 0);
  *(_DWORD *)(*(_DWORD *)(a1 + 356) + 552) = 1023;
  result = a1;
  *(_DWORD *)(a1 + 356) = 0;
  return result;
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0008AFDF) --------------------------------------------------------
int *__cdecl G_FreeVehicleRefs(_DWORD *a1)
{
  int *result; // eax
  int i; // [esp+0h] [ebp-Ch] BYREF
  _DWORD *v3; // [esp+4h] [ebp-8h]

  for ( i = 0; i <= 63; ++i )
  {
    v3 = (_DWORD *)((char *)&unk_D43C0 + 1004 * i);
    if ( v3[138] != 1023 )
    {
      if ( v3[177] == *a1 )
        v3[177] = 1023;
      if ( v3[178] == *a1 )
        v3[178] = 1023;
      if ( v3[179] == *a1 )
        v3[179] = 1023;
      if ( v3[180] == *a1 )
        v3[180] = 1023;
      if ( v3[162] == *a1 )
        v3[162] = 1023;
    }
    result = &i;
  }
  return result;
}

//----- (0008B0CE) --------------------------------------------------------
int *G_VehicleClientThink()
{
  int *result; // eax
  int i; // [esp+8h] [ebp-10h] BYREF
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  dword_AE954 = 1;
  for ( i = 0; i <= 63; ++i )
  {
    v3 = (int)&unk_D43C0 + 1004 * i;
    if ( *(_DWORD *)(v3 + 552) != 1023 )
    {
      v2 = &g_entities[211 * *(_DWORD *)(v3 + 552)];
      if ( *((_BYTE *)v2 + 382) == 2 )
        G_RunThink(v2);
    }
    result = &i;
  }
  dword_AE954 = 0;
  return result;
}
// 17EB4: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// AE954: using guessed type int dword_AE954;

//----- (0008B16C) --------------------------------------------------------
int *__cdecl G_UpdateVehicleTags(int a1)
{
  int v1; // eax
  int v2; // eax
  int *result; // eax
  _DWORD *v4; // esi
  int v5; // edi
  _DWORD *v6; // esi
  int v7; // edi
  _DWORD *v8; // esi
  int v9; // edi
  _DWORD *v10; // esi
  int v11; // edi
  _DWORD *v12; // edi
  _DWORD *v13; // esi
  int v14; // edi
  int v15; // eax
  int i; // [esp+14h] [ebp-14h] BYREF
  _DWORD *v17; // [esp+18h] [ebp-10h]

  v17 = *(_DWORD **)(a1 + 356);
  v1 = BG_GetVehiclePosTag(1);
  v17[189] = trap_DObjGetBoneIndex(a1, v1);
  v17[190] = trap_DObjGetBoneIndex(a1, "tag_detach");
  v17[191] = trap_DObjGetBoneIndex(a1, "tag_popout");
  v17[192] = trap_DObjGetBoneIndex(a1, "tag_body");
  v17[193] = trap_DObjGetBoneIndex(a1, "tag_turret");
  v17[194] = trap_DObjGetBoneIndex(a1, "tag_barrel");
  v17[195] = trap_DObjGetBoneIndex(a1, "tag_coaxel");
  v2 = BG_GetVehiclePosTag(2);
  v17[196] = trap_DObjGetBoneIndex(a1, v2);
  v17[197] = trap_DObjGetBoneIndex(a1, "tag_secondary_gun");
  v17[198] = trap_DObjGetBoneIndex(a1, "tag_secondary_base");
  v17[199] = trap_DObjGetBoneIndex(a1, "tag_chasecam");
  result = (int *)trap_DObjGetBoneIndex(a1, "tag_aimdownbarrel");
  v17[200] = result;
  for ( i = 0; i <= 3; ++i )
  {
    v4 = v17;
    v5 = i;
    v4[v5 + 201] = trap_DObjGetBoneIndex(a1, *(char **)((char *)off_AE990 + (_DWORD)&dword_0[i]));
    result = &i;
  }
  for ( i = 0; i <= 3; ++i )
  {
    v6 = v17;
    v7 = i;
    v6[v7 + 205] = trap_DObjGetBoneIndex(a1, *(char **)((char *)off_AE9A0 + (_DWORD)&dword_0[i]));
    result = &i;
  }
  for ( i = 0; i <= 3; ++i )
  {
    v8 = v17;
    v9 = i;
    v8[v9 + 209] = trap_DObjGetBoneIndex(a1, *(char **)((char *)off_AE9B0 + (_DWORD)&dword_0[i]));
    result = &i;
  }
  for ( i = 0; i <= 5; ++i )
  {
    v10 = v17;
    v11 = i;
    v10[v11 + 213] = trap_DObjGetBoneIndex(a1, *(char **)((char *)off_AE978 + (_DWORD)&dword_0[i]));
    result = &i;
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( i )
    {
      v13 = v17;
      v14 = i;
      v15 = va("tag_passenger%i", i + 1);
      v13[v14 + 219] = trap_DObjGetBoneIndex(a1, v15);
    }
    else
    {
      v12 = v17;
      v12[219] = trap_DObjGetBoneIndex(a1, "tag_passenger");
    }
    result = &i;
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 181D4: using guessed type _DWORD __cdecl BG_GetVehiclePosTag(_DWORD);
// 19774: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);
// AE978: using guessed type char *off_AE978[19];
// AE990: using guessed type char *off_AE990[13];
// AE9A0: using guessed type char *off_AE9A0[9];
// AE9B0: using guessed type char *off_AE9B0[5];

//----- (0008B46A) --------------------------------------------------------
int __cdecl G_GetVehicleInfoIndex(char *s1)
{
  return (__int16)sub_7C33F(s1);
}

//----- (0008B485) --------------------------------------------------------
char *__cdecl G_GetVehicleInfoName(__int16 a1)
{
  return &byte_E3EC0[988 * a1];
}

//----- (0008B4B9) --------------------------------------------------------
int GScr_GetNumVehicles()
{
  int i; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = 0; i <= 63; ++i )
  {
    if ( dword_D43C8[251 * i + 136] != 1023 )
      ++v2;
  }
  return Scr_AddInt(v2);
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0008B51C) --------------------------------------------------------
char *GScr_PrecacheVehicle()
{
  int v0; // eax
  char *result; // eax
  __int16 v2; // [esp+1Ah] [ebp-Eh]
  _BYTE *v3; // [esp+1Ch] [ebp-Ch]
  char *s1; // [esp+20h] [ebp-8h]

  s1 = (char *)Scr_GetString(0);
  if ( !level[8] )
    Scr_Error("precacheVehicle must be called before any wait statements in the level script\n");
  v2 = sub_7C33F(s1);
  if ( v2 < 0 )
  {
    v0 = va("Cannot find vehicle info for [%s]\n", (char)s1);
    Scr_Error(v0);
  }
  result = &byte_E3EC0[988 * v2];
  v3 = result;
  if ( result != (char *)-140 )
  {
    result = &byte_E3EC0[988 * v2];
    if ( v3[140] )
    {
      result = (char *)(unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v3 - 116);
      if ( (_BYTE)result )
        result = (char *)RegisterItem((unsigned __int8)result, 1);
    }
  }
  if ( v3 != (_BYTE *)-204 )
  {
    result = &byte_E3EC0[988 * v2];
    if ( v3[204] )
    {
      result = (char *)(unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v3 - 52);
      if ( (_BYTE)result )
        result = (char *)RegisterItem((unsigned __int8)result, 1);
    }
  }
  if ( v3 != (_BYTE *)-288 )
  {
    result = &byte_E3EC0[988 * v2];
    if ( v3[288] )
    {
      result = (char *)(unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v3 + 32);
      if ( (_BYTE)result )
        result = (char *)RegisterItem((unsigned __int8)result, 1);
    }
  }
  return result;
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17214: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0008B673) --------------------------------------------------------
int __cdecl G_IsVehicleUsable(int a1, int a2)
{
  int i; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = *(_DWORD *)(a1 + 356);
  v5 = *(_DWORD *)(a2 + 352);
  if ( !v5 )
    return 0;
  if ( (*(_DWORD *)(v5 + 132) & 0x100000) != 0 )
    return 0;
  if ( *(_DWORD *)(a2 + 340) != 1023 )
    return 0;
  if ( !sub_88C78(v6, 0, 0) )
    return 0;
  if ( *(float *)(a1 + 496) > 100.0 || *(int *)(a1 + 576) <= 0 )
    return 0;
  if ( (*(_DWORD *)(a1 + 288) & 0x200000) == 0 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 352) + 52) )
    return 0;
  for ( i = 1; i <= 6; ++i )
  {
    if ( *(_DWORD *)(v6 + 4 * i + 924) != 1023 && !OnSameTeam(&g_entities[211 * *(_DWORD *)(v6 + 4 * i + 924)], a2) )
      return 0;
  }
  return 1;
}
// 17304: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);

//----- (0008B7ED) --------------------------------------------------------
_DWORD *__cdecl G_IsVehicleUnusable(int a1)
{
  int v3; // [esp+8h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 352);
  if ( !v3 )
    return 0;
  if ( (*(_DWORD *)(v3 + 132) & 0x100000) == 0 )
    return 0;
  if ( *(_DWORD *)(a1 + 340) == 1023 )
    return 0;
  if ( (g_entities[211 * *(_DWORD *)(a1 + 340) + 72] & 0x200000) != 0 )
    return &g_entities[211 * *(_DWORD *)(a1 + 340)];
  return 0;
}

//----- (0008B893) --------------------------------------------------------
_BOOL4 __cdecl G_IsVehicleImmune(int a1, int a2)
{
  _BOOL4 v3; // [esp+0h] [ebp-10h]
  char *v4; // [esp+4h] [ebp-Ch]

  v4 = &byte_E3EC0[988 * *(__int16 *)(*(_DWORD *)(a1 + 356) + 556)];
  switch ( a2 )
  {
    case 1:
    case 2:
      if ( g_vehicleForceBulletDamage[3] )
        v3 = 0;
      else
        v3 = *((_DWORD *)v4 + 20) == 0;
      break;
    case 3:
    case 4:
      if ( g_vehicleForceGrenadeDamage[3] )
        v3 = 0;
      else
        v3 = *((_DWORD *)v4 + 21) == 0;
      break;
    case 5:
    case 6:
    case 13:
    case 14:
      v3 = *((_DWORD *)v4 + 22) == 0;
      break;
    case 15:
      v3 = 0;
      break;
    case 23:
    case 24:
      v3 = 0;
      break;
    default:
      v3 = 1;
      break;
  }
  return v3;
}

//----- (0008B96B) --------------------------------------------------------
_BOOL4 __cdecl G_IsVehicleOccupantInvulnerable(int a1)
{
  _BOOL4 v2; // [esp+0h] [ebp-18h]
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 352);
  if ( !v4 )
    return 0;
  if ( (*(_DWORD *)(v4 + 132) & 0x100000) == 0 || (*(_DWORD *)(v4 + 132) & 0x400000) != 0 )
    return 0;
  if ( *(_DWORD *)(a1 + 340) == 1023 )
    return 0;
  v3 = g_entities[211 * *(_DWORD *)(a1 + 340) + 89];
  if ( v3 )
    v2 = *(_WORD *)&byte_E3EC0[988 * *(__int16 *)(v3 + 556) + 64] == 2 && *(_DWORD *)(*(_DWORD *)(a1 + 352) + 1556) == 1;
  else
    v2 = 0;
  return v2;
}

//----- (0008BA86) --------------------------------------------------------
long double __cdecl G_VehicleOccupantRadiusDamageScale(int a1)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 352);
  if ( !v4 )
    return 1.0;
  if ( (*(_DWORD *)(v4 + 132) & 0x100000) == 0 || (*(_DWORD *)(v4 + 132) & 0x400000) != 0 )
    return 1.0;
  if ( *(_DWORD *)(a1 + 340) == 1023 )
    return 1.0;
  v3 = g_entities[211 * *(_DWORD *)(a1 + 340) + 89];
  if ( !v3 )
    return 1.0;
  if ( *(_WORD *)&byte_E3EC0[988 * *(__int16 *)(v3 + 556) + 64] == 5 )
    return 0.2;
  return 0.1;
}

//----- (0008BBB0) --------------------------------------------------------
_DWORD *__cdecl G_VehiclePopOut(_DWORD *a1)
{
  _DWORD *result; // eax
  char v2; // [esp+8h] [ebp-70h]
  char v3[48]; // [esp+20h] [ebp-58h] BYREF
  int v4; // [esp+50h] [ebp-28h] BYREF
  _DWORD *v5; // [esp+60h] [ebp-18h]
  int v6; // [esp+64h] [ebp-14h]
  char v7[4]; // [esp+68h] [ebp-10h]
  int v8; // [esp+6Ch] [ebp-Ch]

  v6 = a1[88];
  v5 = 0;
  Com_Error(1, byte_A74C0, v2);
  result = (_DWORD *)(*(_DWORD *)(v6 + 132) & 0x100000);
  if ( result )
  {
    result = a1;
    if ( a1[85] != 1023 )
    {
      v5 = &g_entities[211 * a1[85]];
      result = v5;
      if ( v5[85] != 1023 )
      {
        result = (_DWORD *)(v5[72] & 0x200000);
        if ( !result )
        {
          if ( (*(_DWORD *)(v6 + 132) & 0x400000) != 0 )
          {
            *(_DWORD *)(v6 + 132) &= 0xFFBFFFFF;
            v8 = *(_DWORD *)(v5[89] + 756);
            *(_DWORD *)v7 = "tag_player";
          }
          else
          {
            *(_DWORD *)(v6 + 132) |= 0x400000u;
            v8 = *(_DWORD *)(v5[89] + 764);
            *(_DWORD *)v7 = "tag_popout";
          }
          if ( v8 < 0 )
            Com_Error(1, byte_A7500, v7[0]);
          G_EntUnlink(a1);
          G_DObjGetWorldBoneIndexMatrix(v5, v8, v3);
          SetClientOrigin(a1, &v4);
          result = (_DWORD *)G_EntLinkToWithOffset(a1, v5, *(_DWORD *)v7, vec3_origin, vec3_origin);
          if ( !result )
            result = (_DWORD *)Com_Error(1, byte_A7540, v7[0]);
        }
      }
    }
  }
  return result;
}
// 8BBE6: variable 'v2' is possibly undefined
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 17734: using guessed type _DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 18834: using guessed type _DWORD __cdecl SetClientOrigin(_DWORD, _DWORD);
// 19574: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (0008BD83) --------------------------------------------------------
int __cdecl G_GetTankIndex(int a1)
{
  int v3; // [esp+8h] [ebp-Ch]
  _DWORD *v4; // [esp+Ch] [ebp-8h]

  v4 = &g_entities[211 * a1];
  if ( !v4[89] || (int)v4[144] <= 0 )
    return -1;
  if ( v4[85] != 1023 )
    return -1;
  v3 = v4[89];
  if ( *(_DWORD *)(v3 + 552) == 1023 )
    return -1;
  if ( *(_WORD *)&byte_E3EC0[988 * *(__int16 *)(v3 + 556) + 64] != 2 )
    return -1;
  if ( *(_DWORD *)(v3 + 592) )
    return -1711142349 * ((v4[89] - level[6]) >> 2);
  return -1;
}

//----- (0008BE7E) --------------------------------------------------------
int __cdecl G_GetTankEntNum(int a1)
{
  int v3; // [esp+8h] [ebp-Ch]
  _DWORD *v4; // [esp+Ch] [ebp-8h]

  v3 = level[6] + 1004 * a1;
  if ( *(_DWORD *)(v3 + 552) == 1023 )
    return 1023;
  if ( *(_WORD *)&byte_E3EC0[988 * *(__int16 *)(v3 + 556) + 64] != 2 )
    return 1023;
  if ( !*(_DWORD *)(v3 + 592) )
    return 1023;
  v4 = &g_entities[211 * *(_DWORD *)(v3 + 552)];
  if ( !v4[89] || (int)v4[144] <= 0 )
    return 1023;
  if ( v4[85] == 1023 )
    return *v4;
  return 1023;
}

//----- (0008BF6D) --------------------------------------------------------
unsigned int __cdecl G_GetNonPVSTankInfo(_DWORD *a1, float *a2, int a3)
{
  _DWORD *v5; // [esp+34h] [ebp-34h]
  float v6; // [esp+38h] [ebp-30h]
  float v7; // [esp+3Ch] [ebp-2Ch]
  float v8; // [esp+40h] [ebp-28h]
  float v9; // [esp+44h] [ebp-24h]
  int v10; // [esp+48h] [ebp-20h]
  int v11; // [esp+4Ch] [ebp-1Ch]
  int v12; // [esp+50h] [ebp-18h]
  int i; // [esp+58h] [ebp-10h]
  int v14; // [esp+5Ch] [ebp-Ch]

  if ( a3 == 1023 )
    v14 = 0;
  else
    v14 = a3 + 1;
  for ( i = 0; ; ++i )
  {
    if ( i >= level[3] )
      return 0;
    v5 = &g_entities[211 * ((i + v14) % level[3])];
    if ( *((_BYTE *)v5 + 364) )
    {
      if ( G_GetTankIndex(*v5) != -1
        && !trap_InSnapshot(a2, *v5)
        && *(_DWORD *)(v5[89] + 928) != 1023
        && *(_DWORD *)(v5[89] + 928) != *a1
        && OnSameTeam(a1, &g_entities[211 * *(_DWORD *)(v5[89] + 928)]) )
      {
        break;
      }
    }
  }
  v12 = G_GetTankIndex(*v5);
  v8 = *((float *)v5 + 79) - *a2;
  v9 = *((float *)v5 + 80) - a2[1];
  v10 = (int)(v8 + 0.5);
  v11 = (int)(v9 + 0.5);
  v6 = 1.0;
  v7 = 1.0;
  if ( v10 <= 1024 )
  {
    if ( v10 < -1022 )
      v6 = -1022.0 / (long double)v10;
  }
  else
  {
    v6 = 1024.0 / (long double)v10;
  }
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v7 = -1022.0 / (long double)v11;
  }
  else
  {
    v7 = 1024.0 / (long double)v11;
  }
  if ( v6 < 1.0 || v7 < 1.0 )
  {
    if ( v7 <= (long double)v6 )
    {
      if ( v6 > (long double)v7 )
        v10 = (int)((long double)v10 * v7);
    }
    else
    {
      v11 = (int)((long double)v11 * v6);
    }
  }
  if ( v10 <= 1024 )
  {
    if ( v10 < -1022 )
      v10 = -1022;
  }
  else
  {
    v10 = 1024;
  }
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v11 = -1022;
  }
  else
  {
    v11 = 1024;
  }
  return ((v12 & 0xFFFF803F | ((((unsigned __int16)((v10 + 2) / 4) + 255) & 0x1FF) << 6)) & 0xFF007FFF | ((((unsigned __int16)((v11 + 2) / 4) + 255) & 0x1FF) << 15)) & 0xFFFFFF | ((unsigned __int8)(int)(*((float *)v5 + 83) * 0.71111113) << 24);
}
// 17304: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);
// 17CD4: using guessed type _DWORD __cdecl G_GetTankIndex(_DWORD);
// 188C4: using guessed type _DWORD __cdecl trap_InSnapshot(_DWORD, _DWORD);

//----- (0008C2D2) --------------------------------------------------------
int __cdecl Scr_Vehicle_Controller(int *a1, int a2)
{
  int result; // eax
  int v3; // [esp+20h] [ebp-68h] BYREF
  int v4; // [esp+24h] [ebp-64h]
  int v5; // [esp+28h] [ebp-60h]
  int v6; // [esp+30h] [ebp-58h] BYREF
  int v7; // [esp+34h] [ebp-54h]
  int v8; // [esp+38h] [ebp-50h]
  int v9[4]; // [esp+40h] [ebp-48h] BYREF
  int v10[4]; // [esp+50h] [ebp-38h] BYREF
  float v11[6]; // [esp+60h] [ebp-28h] BYREF
  char *v12; // [esp+78h] [ebp-10h]
  int v13; // [esp+7Ch] [ebp-Ch]

  v13 = a1[89];
  v12 = &byte_E3EC0[988 * *(__int16 *)(v13 + 556)];
  v11[0] = ((long double)a1[23] - 127.0) * 30.0 / 127.0;
  v11[1] = 0.0;
  v11[2] = ((long double)a1[25] - 127.0) * 30.0 / 127.0;
  if ( *(int *)(v13 + 768) >= 0 )
    G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 768), vec3_origin, v11);
  v10[0] = 0;
  v10[1] = a1[27];
  v10[2] = 0;
  v9[0] = a1[26];
  v9[1] = 0;
  v9[2] = 0;
  if ( *(int *)(v13 + 772) >= 0 )
    G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 772), vec3_origin, v10);
  if ( *(int *)(v13 + 776) >= 0 )
    G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 776), vec3_origin, v9);
  if ( *((_WORD *)v12 + 32) == 1 )
  {
    v6 = 0;
    v7 = a1[24];
    v8 = 0;
    v3 = a1[28];
    v4 = 0;
    v5 = 0;
    if ( *(int *)(v13 + 792) >= 0 )
      G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 792), vec3_origin, &v6);
    result = v13;
    if ( *(int *)(v13 + 788) >= 0 )
      return G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 788), vec3_origin, &v3);
  }
  else
  {
    v6 = 0;
    v7 = a1[24];
    v8 = 0;
    v3 = a1[28];
    v4 = 0;
    v5 = 0;
    if ( *(int *)(v13 + 784) >= 0 )
      G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 784), vec3_origin, &v6);
    result = v13;
    if ( *(int *)(v13 + 788) >= 0 )
      return G_DObjSetLocalBoneIndex(a1, a2, *(_DWORD *)(v13 + 788), vec3_origin, &v3);
  }
  return result;
}
// 16DA4: using guessed type _DWORD __cdecl G_DObjSetLocalBoneIndex(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008C5AB) --------------------------------------------------------
int __cdecl Scr_Vehicle_Init(int a1)
{
  int result; // eax
  int v2; // esi
  int i; // [esp+1Ch] [ebp-6Ch]
  int v4[4]; // [esp+20h] [ebp-68h] BYREF
  char v5[48]; // [esp+30h] [ebp-58h] BYREF
  int v6[2]; // [esp+60h] [ebp-28h] BYREF
  int v7; // [esp+68h] [ebp-20h]
  char *v8; // [esp+74h] [ebp-14h]
  float *v9; // [esp+78h] [ebp-10h]
  int v10; // [esp+7Ch] [ebp-Ch]

  v10 = *(_DWORD *)(a1 + 356);
  v9 = (float *)(v10 + 184);
  v8 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  if ( *(_BYTE *)(a1 + 382) != 2 || dword_AE954 )
  {
    for ( i = 0; i <= 5; ++i )
    {
      if ( G_DObjGetWorldTagMatrix(a1, *(char **)((char *)off_AE978 + (_DWORD)&dword_0[i]), v5) )
        LODWORD(v9[i + 34]) = v7;
    }
    if ( *(int *)(v10 + 804) >= 0 )
    {
      G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v10 + 804), v5);
      v4[0] = v6[0];
      v4[1] = v6[1];
      v4[2] = v7;
      if ( *(int *)(v10 + 776) >= 0 )
      {
        G_DObjGetWorldBoneIndexMatrix(a1, *(_DWORD *)(v10 + 776), v5);
        v2 = v10;
        *(float *)(v2 + 620) = VectorDistance(v6, v4);
      }
    }
    if ( *((_WORD *)v8 + 32) == 1 || *((_WORD *)v8 + 32) == 2 )
      sub_81331((_DWORD *)a1);
    sub_7C762(a1, v9, v9 + 6);
    v9[3] = *v9;
    v9[4] = v9[1];
    v9[5] = v9[2];
    v9[9] = v9[6];
    v9[10] = v9[7];
    v9[11] = v9[8];
    G_DoTouchTriggers(a1, a1 + 316);
    *(_DWORD *)(a1 + 528) = Scr_Vehicle_Think;
    result = level[123] + 50;
    *(_DWORD *)(a1 + 524) = result;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 524) = level[123];
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 17D14: using guessed type _DWORD __cdecl G_DoTouchTriggers(_DWORD, _DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 8C5AB: using guessed type int __cdecl Scr_Vehicle_Init(int);
// 8C7CC: using guessed type int __cdecl Scr_Vehicle_Think(int);
// AE954: using guessed type int dword_AE954;
// AE978: using guessed type char *off_AE978[19];

//----- (0008C7CC) --------------------------------------------------------
_DWORD *__cdecl Scr_Vehicle_Think(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  unsigned __int8 v3; // al
  int v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+24h] [ebp-24h]
  int i; // [esp+28h] [ebp-20h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  char *v8; // [esp+30h] [ebp-18h]
  const void *v9; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]

  v10 = a1[89];
  v9 = (const void *)(v10 + 184);
  v8 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  if ( *((_BYTE *)a1 + 382) != 2 || dword_AE954 )
  {
    sub_81F2E(a1);
    memset(&unk_F35E0, 0, 0x38u);
    for ( i = 1; i <= 6; ++i )
    {
      if ( *(_DWORD *)(v10 + 4 * i + 924) != 1023 && (int)g_entities[211 * *(_DWORD *)(v10 + 4 * i + 924) + 144] <= 0 )
        VEH_UnlinkPlayer(&g_entities[211 * *(_DWORD *)(v10 + 4 * i + 924)], 0);
    }
    v5 = 0;
    while ( 1 )
    {
      v2 = v5++;
      if ( v2 > 1 )
        break;
      if ( *((_WORD *)v8 + 32) != 5 )
      {
        if ( *((_BYTE *)a1 + 382) == 1 )
          sub_88561((int)a1);
        else
          sub_87CD3((int)a1);
      }
      if ( *((_WORD *)v8 + 32) == 5 )
        break;
      if ( sub_827AB((float *)a1, v5) )
      {
        qmemcpy((void *)(v10 + 368), v9, 0xB8u);
        break;
      }
      qmemcpy((void *)(v10 + 368), v9, 0xB8u);
    }
    if ( *(_DWORD *)(v10 + 988) < level[123] - 1000 )
      *(_DWORD *)(v10 + 984) = level[123];
    sub_7C762((int)a1, (float *)(v10 + 184), (float *)(v10 + 208));
    G_DoTouchTriggers(a1, a1 + 79);
    if ( g_vehicleDebug[3] )
      sub_7C02C((int)v9, 4.0, 1065353216, 1065353216, 0);
    *(_DWORD *)(v10 + 624) = 0;
    if ( *(float *)(v10 + 604) < 1.0 || *(_DWORD *)(v10 + 612) )
    {
      if ( *(_DWORD *)(v10 + 612) && *(float *)(v10 + 604) <= 0.5 )
        *(_DWORD *)(v10 + 612) = 0;
    }
    else
    {
      *(_DWORD *)(v10 + 612) = 1;
      if ( *((_WORD *)v8 + 32) != 1 )
        G_AddEvent(a1, 208, 0);
    }
    if ( v8 == (char *)-204 || !v8[204] )
    {
      if ( *((_WORD *)v8 + 32) == 1 )
      {
        if ( *(float *)(v10 + 604) <= 0.0 )
          *(_DWORD *)(v10 + 604) = 0;
        else
          *(float *)(v10 + 604) = *(float *)(v10 + 604) - 0.0099999998;
      }
    }
    else
    {
      v3 = BG_GetWeaponIndexForName((_BYTE)v8 - 52);
      v7 = BG_GetInfoForWeapon(v3);
      if ( *(float *)(v10 + 604) <= 0.0 )
        *(_DWORD *)(v10 + 604) = 0;
      else
        *(float *)(v10 + 604) = *(float *)(v10 + 604) - *(float *)(v7 + 1184);
    }
    if ( *((_BYTE *)a1 + 382) == 2 )
      sub_86C57(a1);
    sub_871A6((int)a1);
    sub_85B32((int)a1);
    sub_86285((int)a1);
    sub_86735(a1);
    sub_86A29((unsigned int)a1);
    sub_86AA1((int)a1);
    sub_87480(a1);
    a1[22] = (int)(*((float *)v8 + 34) * 1000.0);
    if ( (int)g_vehicleTrafficStressTest[3] < 0 )
    {
      v4 = g_vehicleTrafficStressTest[3];
      if ( v4 < 0 )
        v4 = -v4;
      if ( v4 > *(_DWORD *)(v10 + 560) && *((_DWORD *)v8 + 23) )
        G_VEH_FireGunner(*a1, 1);
    }
    result = a1;
    a1[131] = level[123] + 50;
  }
  else
  {
    result = a1;
    a1[131] = level[123];
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 177D4: using guessed type _DWORD __cdecl G_VEH_FireGunner(_DWORD, _DWORD);
// 17D14: using guessed type _DWORD __cdecl G_DoTouchTriggers(_DWORD, _DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// AE954: using guessed type int dword_AE954;

//----- (0008CCAD) --------------------------------------------------------
long double __cdecl Scr_Vehicle_DamageScale(int a1, int a2, int a3, float *a4, int a5)
{
  float v6; // [esp+34h] [ebp-B4h]
  int v7; // [esp+38h] [ebp-B0h]
  float v8; // [esp+3Ch] [ebp-ACh]
  float v9; // [esp+5Ch] [ebp-8Ch]
  float v10; // [esp+60h] [ebp-88h]
  float v11; // [esp+64h] [ebp-84h]
  float v12; // [esp+68h] [ebp-80h]
  float v13; // [esp+6Ch] [ebp-7Ch]
  int v14; // [esp+70h] [ebp-78h]
  float v15; // [esp+78h] [ebp-70h]
  float v16; // [esp+7Ch] [ebp-6Ch]
  float v17; // [esp+80h] [ebp-68h]
  float v18; // [esp+80h] [ebp-68h]
  float v19; // [esp+84h] [ebp-64h]
  int v20; // [esp+88h] [ebp-60h]
  int i; // [esp+8Ch] [ebp-5Ch]
  float v22[12]; // [esp+90h] [ebp-58h] BYREF
  float v23; // [esp+C0h] [ebp-28h] BYREF
  float v24; // [esp+C4h] [ebp-24h]
  float v25; // [esp+C8h] [ebp-20h]
  float *v26; // [esp+D4h] [ebp-14h]
  float *v27; // [esp+D8h] [ebp-10h]
  int v28; // [esp+DCh] [ebp-Ch]
  _DWORD v29[2]; // [esp+E0h] [ebp-8h] BYREF

  v28 = *(_DWORD *)(a1 + 356);
  v27 = (float *)(v28 + 184);
  v26 = (float *)&byte_E3EC0[988 * *(__int16 *)(v28 + 556)];
  v15 = cos(0.3490658503988659);
  switch ( a5 )
  {
    case 4:
    case 6:
    case 10:
    case 12:
    case 14:
      v14 = 1;
      break;
    default:
      v14 = 0;
      break;
  }
  if ( (unsigned int)(a5 - 1) > 1 )
    v16 = 1.0;
  else
    v16 = v26[212] * 0.0099999998;
  AnglesToAxis(v27 + 6, v22);
  v23 = *a4 - *v27;
  v24 = a4[1] - v27[1];
  v25 = 0.0;
  VectorNormalize(&v23);
  v17 = 0.0;
  v20 = -1;
  for ( i = 0; i <= 1; ++i )
  {
    if ( v20 >= 0 )
    {
      v19 = v23 * v22[3 * i] + v24 * *(float *)&v29[3 * i - 19] + v25 * *(float *)&v29[3 * i - 18];
      if ( fabs(v19) <= fabs(v17) )
        continue;
    }
    v17 = v23 * v22[3 * i] + v24 * *(float *)&v29[3 * i - 19] + v25 * *(float *)&v29[3 * i - 18];
    v20 = i;
  }
  if ( v14 )
  {
    v13 = 1.0;
    v12 = 1.0;
    v11 = *(float *)(a1 + 280) * 0.80000001;
    v10 = *(float *)(a1 + 284) * 0.5;
    v9 = VectorDistanceSquared(a4, v27);
    if ( a5 == 4 )
    {
      v8 = 1.0;
      if ( a3 )
      {
        v7 = BG_GetInfoForWeapon(*(_DWORD *)(a3 + 204));
        if ( v7 )
        {
          if ( *(float *)(v7 + 1196) > 0.0 )
            v8 = *(float *)(v7 + 1196);
        }
      }
      if ( v27[2] + v10 <= a4[2] - 10.0 || v11 * v11 <= (long double)v9 )
        v6 = v16 * v8;
      else
        v6 = v16 * 0.0099999998 * v26[211] * v8;
    }
    else
    {
      if ( v20 )
      {
        if ( v20 == 1 )
        {
          v13 = v26[209] * 0.0099999998;
          if ( v23 * v22[0] + v24 * v22[1] + v25 * v22[2] >= 0.0 )
            v12 = v26[208] * 0.0099999998;
          else
            v12 = v26[210] * 0.0099999998;
        }
      }
      else
      {
        if ( v17 >= 0.0 )
          v13 = v26[208] * 0.0099999998;
        else
          v13 = v26[210] * 0.0099999998;
        v12 = v26[209] * 0.0099999998;
      }
      v18 = fabs(v17);
      v6 = (v13 * v18 + (1.0 - v18) * v12) * v16 * 0.69999999;
    }
  }
  else if ( v20 )
  {
    if ( v20 == 1 )
      v6 = v16 * 0.0099999998 * v26[209];
    else
      v6 = 0.0;
  }
  else if ( v17 >= 0.0 )
  {
    v6 = v16 * 0.0099999998 * v26[208];
  }
  else if ( v15 <= -v17 )
  {
    v6 = v16 * 0.0099999998 * v26[210];
  }
  else
  {
    v6 = v16 * 0.0099999998 * v26[209];
  }
  return v6;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18CB4: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);
// 19134: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0008D1CA) --------------------------------------------------------
_DWORD *__cdecl Scr_Vehicle_Pain(int a1, int a2, int a3, float *a4, int a5, int a6)
{
  _DWORD *result; // eax
  _DWORD *v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  v8 = 0;
  if ( a5 != 24 && a2 && *(_DWORD *)(a2 + 204) )
    v8 = BG_GetInfoForWeapon(*(_DWORD *)(a2 + 204));
  if ( v8 && (a3 > 200 || *(_DWORD *)(v8 + 124) == 2 || *(_DWORD *)(v8 + 124) == 1) || a5 == 23 )
    sub_7D492(a1, a6, 1.0, 0.0, 0);
  result = (_DWORD *)a1;
  if ( *(int *)(a1 + 116) >= 0 )
  {
    result = *(_DWORD **)(a1 + 116);
    if ( (int)result < level[121] )
    {
      v7 = &g_entities[211 * *(_DWORD *)(a1 + 116)];
      result = v7;
      if ( v7[88] )
      {
        result = (_DWORD *)v7[88];
        if ( result[4424] == 2 )
        {
          *(_DWORD *)(v7[88] + 18008) += a3;
          if ( a2 == a1 )
          {
            *(float *)(v7[88] + 18012) = *a4;
            *(float *)(v7[88] + 18016) = a4[1];
            *(float *)(v7[88] + 18020) = a4[2];
            result = (_DWORD *)v7[88];
            result[4506] = 1;
          }
          else
          {
            *(float *)(v7[88] + 18012) = *(float *)(a1 + 316) - *a4;
            *(float *)(v7[88] + 18016) = *(float *)(a1 + 320) - a4[1];
            *(float *)(v7[88] + 18020) = *(float *)(a1 + 324) - a4[2];
            result = (_DWORD *)v7[88];
            result[4506] = 0;
          }
        }
      }
    }
  }
  return result;
}
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0008D3BC) --------------------------------------------------------
int __cdecl Scr_Vehicle_PushAway(int a1, int a2)
{
  char *v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  float v7; // [esp+28h] [ebp-20h]
  float v8; // [esp+30h] [ebp-18h] BYREF
  float v9; // [esp+34h] [ebp-14h]
  float v10; // [esp+38h] [ebp-10h]

  v4 = &byte_E3EC0[988 * *(__int16 *)(*(_DWORD *)(a2 + 356) + 556)];
  v8 = *(float *)(a1 + 316) - *(float *)(a2 + 316);
  v9 = *(float *)(a1 + 320) - *(float *)(a2 + 320);
  v10 = *(float *)(a1 + 324) - *(float *)(a2 + 324);
  v10 = *(float *)(a1 + 272) - *(float *)(a2 + 272) + v10;
  VectorNormalize(&v8);
  v5 = *(float *)(a1 + 316);
  v6 = *(float *)(a1 + 320);
  v7 = *(float *)(a1 + 324);
  do
  {
    if ( *((float *)v4 + 216) + 25.0 + 32.0 <= VectorDistance(&v5, a2 + 316) )
      return 0;
    v5 = v8 * 4.0 + v5;
    v6 = v9 * 4.0 + v6;
    v7 = v10 * 4.0 + v7;
  }
  while ( G_TestEntityPosition(a1, &v5) );
  *(float *)(a1 + 316) = v5;
  *(float *)(a1 + 320) = v6;
  *(float *)(a1 + 324) = v7;
  *(float *)(a1 + 24) = v5;
  *(float *)(a1 + 28) = v6;
  *(float *)(a1 + 32) = v7;
  if ( *(_DWORD *)(a1 + 352) )
  {
    *(float *)(*(_DWORD *)(a1 + 352) + 20) = v5;
    *(float *)(*(_DWORD *)(a1 + 352) + 24) = v6;
    *(float *)(*(_DWORD *)(a1 + 352) + 28) = v7;
  }
  return 1;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17A44: using guessed type _DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD);
// 19004: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);

//----- (0008D5A1) --------------------------------------------------------
void Scr_Vehicle_Touch()
{
  ;
}

//----- (0008D5A6) --------------------------------------------------------
int __cdecl VEH_GetMinsMaxs(int a1, float *a2, float *a3)
{
  int result; // eax
  float *v4; // [esp+14h] [ebp-14h]

  v4 = (float *)&byte_E3EC0[988 * *(__int16 *)(*(_DWORD *)(a1 + 356) + 556)];
  *a2 = v4[219] * 1.2;
  a2[1] = v4[220] * 1.2;
  a2[2] = v4[221] * 1.2;
  *a2 = *a2 + *(float *)tv(-1035468800, -1035468800, 0);
  a2[1] = a2[1] + *(float *)(tv(-1035468800, -1035468800, 0) + 4);
  a2[2] = a2[2] + *(float *)(tv(-1035468800, -1035468800, 0) + 8);
  *a3 = v4[222] * 1.2;
  a3[1] = v4[223] * 1.2;
  a3[2] = v4[224] * 1.2;
  *a3 = *a3 + *(float *)tv(1112014848, 1112014848, 1101004800);
  a3[1] = a3[1] + *(float *)(tv(1112014848, 1112014848, 1101004800) + 4);
  result = tv(1112014848, 1112014848, 1101004800);
  a3[2] = a3[2] + *(float *)(result + 8);
  return result;
}
// 16F14: using guessed type _DWORD __cdecl tv(_DWORD, _DWORD, _DWORD);

//----- (0008D787) --------------------------------------------------------
int __cdecl VEH_CheckPushClients(int a1)
{
  int result; // eax
  float v2[4]; // [esp+20h] [ebp-178h] BYREF
  float v3[4]; // [esp+30h] [ebp-168h] BYREF
  char v4[40]; // [esp+40h] [ebp-158h] BYREF
  unsigned __int16 v5; // [esp+68h] [ebp-130h]
  char v6; // [esp+6Eh] [ebp-12Ah]
  char v7; // [esp+6Fh] [ebp-129h]
  _DWORD *v8; // [esp+74h] [ebp-124h]
  int i; // [esp+78h] [ebp-120h]
  int v10; // [esp+7Ch] [ebp-11Ch]
  int v11[66]; // [esp+80h] [ebp-118h] BYREF
  float *v12; // [esp+188h] [ebp-10h]
  int v13; // [esp+18Ch] [ebp-Ch]

  v13 = *(_DWORD *)(a1 + 356);
  v12 = (float *)&byte_E3EC0[988 * *(__int16 *)(v13 + 556)];
  v3[0] = *(float *)(a1 + 316) + v12[213];
  v3[1] = *(float *)(a1 + 320) + v12[214];
  v3[2] = *(float *)(a1 + 324) + v12[215];
  v2[0] = *(float *)(a1 + 316) + v12[216];
  v2[1] = *(float *)(a1 + 320) + v12[217];
  v2[2] = *(float *)(a1 + 324) + v12[218];
  for ( i = 0; i <= 2; ++i )
  {
    v3[i] = v3[i] - 25.0;
    v2[i] = v2[i] + 25.0;
  }
  v10 = trap_EntitiesInBox(v3, v2, v11, 64, 0x2000000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    if ( *(_DWORD *)(a1 + 340) != v11[i] )
    {
      v8 = &g_entities[211 * v11[i]];
      if ( v8[88] )
      {
        trap_Trace(v4, v8 + 79, v8 + 66, v8 + 69, v8 + 79, *v8, v8[104]);
        if ( (v7 || v6) && v5 == *(_DWORD *)a1 )
          Scr_Vehicle_Touch(a1, v8, 1);
      }
    }
  }
  return result;
}
// 173E4: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 173F4: using guessed type int __cdecl Scr_Vehicle_Touch(_DWORD, _DWORD, _DWORD);
// 194C4: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0008DA1E) --------------------------------------------------------
int __cdecl G_VEH_CycleSlot(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // eax
  char v4; // [esp+4h] [ebp-34h]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+2Ch] [ebp-Ch]
  _DWORD *v8; // [esp+30h] [ebp-8h]

  v8 = &g_entities[211 * a1[85]];
  v7 = v8[89];
  result = sub_88C78(v7, 0, 0);
  if ( result )
  {
    if ( *(_WORD *)&byte_E3EC0[988 * *(__int16 *)(v7 + 556) + 64] == 2 && !*(_DWORD *)(a1[88] + 18224) )
      *(_DWORD *)(a1[88] + 18060) = 0;
    if ( a1[88] && *(_DWORD *)(a1[88] + 18060) <= level[123] - 250 )
    {
      v5 = *(_DWORD *)(a1[88] + 1556);
      *(_DWORD *)(a1[88] + 18060) = 0;
      ++*(_DWORD *)(a1[88] + 18224);
      VEH_UnlinkPlayer(a1, 0);
      v6 = sub_88C78(v7, v5, a2);
      *(_DWORD *)(a1[88] + 18060) = 0;
      sub_8998D((int)v8, a1, v6);
      result = level[123] + 1500;
      *(_DWORD *)(a1[88] + 18060) = result;
    }
    else
    {
      result = level[123] - 500;
      if ( *(_DWORD *)(a1[88] + 18064) < result )
      {
        v3 = va("e \"GMI_GAME_VEHICLE_DELAY_IGNORE\"", v4);
        trap_SendServerCommand(1852331867 * (a1 - g_entities), 0, v3);
        result = level[123];
        *(_DWORD *)(a1[88] + 18064) = result;
      }
    }
  }
  return result;
}
// 8DB39: variable 'v4' is possibly undefined
// 18144: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);

//----- (0008DC43) --------------------------------------------------------
_DWORD *__cdecl Scr_Vehicle_Use(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( a2[88] )
  {
    if ( (*(_DWORD *)(a2[88] + 132) & 0x100000) != 0 )
    {
      result = (_DWORD *)VEH_UnlinkPlayer(a2, 1);
    }
    else
    {
      sub_8998D(a1, a2, 0);
      result = (_DWORD *)a2[88];
      result[4556] = 0;
    }
  }
  return result;
}
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);

//----- (0008DCCB) --------------------------------------------------------
int *__cdecl Scr_Vehicle_Die(int a1, int a2, int *a3, int a4, int a5, int a6, int a7)
{
  int *result; // eax
  int v8[2]; // [esp+30h] [ebp-38h] BYREF
  float v9; // [esp+38h] [ebp-30h]
  _BOOL4 v10; // [esp+48h] [ebp-20h]
  float *v11; // [esp+4Ch] [ebp-1Ch]
  int v12; // [esp+50h] [ebp-18h]
  int i; // [esp+54h] [ebp-14h] BYREF
  int *v14; // [esp+58h] [ebp-10h]
  int *v15; // [esp+5Ch] [ebp-Ch]

  result = *(int **)(a1 + 356);
  v15 = result;
  for ( i = 1; i <= 6; ++i )
  {
    if ( v15[i + 231] != 1023 )
    {
      if ( g_entities[211 * v15[i + 231] + 88] )
      {
        v11 = (float *)&g_entities[211 * v15[i + 231]];
        v12 = *((_DWORD *)v11 + 144);
        *((_DWORD *)v11 + 144) += 10;
        G_Damage(v11, a3, a3, vec3_origin, *((_DWORD *)v11 + 88) + 20, 5, 0, 23, 0);
        v10 = *((_DWORD *)v11 + 144) == v12 + 10;
        *((_DWORD *)v11 + 144) = v12;
        VEH_UnlinkPlayer(v11, v10);
        v8[0] = (int)v11[79];
        v8[1] = (int)v11[80];
        v9 = v11[81];
        v9 = v9 + 32.0;
        G_SetOrigin(v11, v8);
      }
    }
    result = &i;
  }
  if ( a3 )
  {
    result = a3;
    if ( a3[51] )
    {
      v14 = (int *)BG_GetInfoForWeapon(a3[51]);
      if ( v14[31] == 2 || (result = v14, v14[31] == 1) )
        result = (int *)sub_7D492(a1, a7, 1.0, 0.0, 0);
    }
  }
  return result;
}
// 16C64: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 18C94: using guessed type _DWORD __cdecl VEH_UnlinkPlayer(_DWORD, _DWORD);
// 19894: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0008DEC6) --------------------------------------------------------
int __cdecl SP_script_vehicle(int a1)
{
  char *v1; // eax

  G_SpawnFloat("delay", (int)&g_vehicleBurnTime + 16, a1 + 644);
  if ( level[1499] )
    G_BackupSpawnVars(a1);
  v1 = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 788));
  return G_SpawnVehicle(a1, v1, level[1499]);
}
// 16B64: using guessed type _DWORD __cdecl G_BackupSpawnVars(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0008DF52) --------------------------------------------------------
int __cdecl SP_script_vehicle_collmap(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 288) = 0;
  result = a1;
  *(_DWORD *)(a1 + 4) = 14;
  return result;
}

//----- (0008DF6E) --------------------------------------------------------
int __cdecl ScriptVehicle_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0x1E; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_AEC80 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_AEC80 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_AEC84 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// AEC80: using guessed type char *off_AEC80;
// AEC84: using guessed type int (__cdecl *off_AEC84)(int);

//----- (0008DFE9) --------------------------------------------------------
int __cdecl CMD_VEH_AttachPath(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // [esp+4h] [ebp-74h]
  __int16 v4; // [esp+1Ah] [ebp-5Eh]
  int i; // [esp+1Ch] [ebp-5Ch]
  char v6[56]; // [esp+20h] [ebp-58h] BYREF
  float v7; // [esp+58h] [ebp-20h]
  char *v8; // [esp+60h] [ebp-18h]
  float *v9; // [esp+64h] [ebp-14h]
  int v10; // [esp+68h] [ebp-10h]
  _DWORD *v11; // [esp+6Ch] [ebp-Ch]

  v11 = sub_7C280(a1);
  v10 = v11[89];
  v9 = (float *)(v10 + 184);
  v8 = &byte_E3EC0[988 * *(__int16 *)(v10 + 556)];
  v4 = GScr_GetVehicleNodeIndex(0);
  if ( *((_BYTE *)v11 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v3);
    Scr_Error(v1);
  }
  G_VehSetUpPathPos(v10, v4);
  *v9 = *(float *)(v10 + 20);
  v9[1] = *(float *)(v10 + 24);
  v9[2] = *(float *)(v10 + 28);
  v9[6] = *(float *)(v10 + 32);
  v9[7] = *(float *)(v10 + 36);
  v9[8] = *(float *)(v10 + 40);
  sub_7C762((int)v11, v9, v9 + 6);
  v9[3] = *v9;
  v9[4] = v9[1];
  v9[5] = v9[2];
  v9[9] = v9[6];
  v9[10] = v9[7];
  v9[11] = v9[8];
  for ( i = 0; i <= 5; ++i )
  {
    if ( G_DObjGetWorldTagMatrix(v11, *(char **)((char *)off_AE978 + (_DWORD)&dword_0[i]), v6) )
      v9[i + 34] = v7;
  }
  if ( *((_WORD *)v8 + 32) == 1 || *((_WORD *)v8 + 32) == 2 )
    sub_81331(v11);
  sub_7C762((int)v11, v9, v9 + 6);
  v9[3] = *v9;
  v9[4] = v9[1];
  v9[5] = v9[2];
  v9[9] = v9[6];
  v9[10] = v9[7];
  result = *((_DWORD *)v9 + 8);
  *((_DWORD *)v9 + 11) = result;
  return result;
}
// 8E062: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0[];
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174D4: using guessed type _DWORD __cdecl GScr_GetVehicleNodeIndex(_DWORD);
// 18324: using guessed type _DWORD __cdecl G_VehSetUpPathPos(_DWORD, _DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// AE978: using guessed type char *off_AE978[19];

//----- (0008E21C) --------------------------------------------------------
_DWORD *__cdecl CMD_VEH_StartPath(int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *result; // eax
  char v4; // [esp+4h] [ebp-14h]
  __int16 *v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = sub_7C280(a1);
  v5 = (__int16 *)v6[89];
  if ( *((_BYTE *)v6 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v4);
    Scr_Error(v1);
  }
  if ( *v5 < 0 )
  {
    v2 = va("Can't start path on a vehicle that hasn't been attached", v4);
    Scr_Error(v2);
  }
  result = v6;
  *((_BYTE *)v6 + 382) = 1;
  return result;
}
// 8E25D: variable 'v4' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0008E299) --------------------------------------------------------
int __cdecl CMD_VEH_SetSwitchNode(int a1)
{
  int v1; // eax
  char v3; // [esp+4h] [ebp-24h]
  __int16 v4; // [esp+18h] [ebp-10h]
  __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  _DWORD *v7; // [esp+20h] [ebp-8h]

  v7 = sub_7C280(a1);
  v6 = v7[89];
  v5 = GScr_GetVehicleNodeIndex(0);
  v4 = GScr_GetVehicleNodeIndex(1);
  if ( *((_BYTE *)v7 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v3);
    Scr_Error(v1);
  }
  return G_VehSetSwitchNode(v6, v5, v4);
}
// 8E2FA: variable 'v3' is possibly undefined
// 169D4: using guessed type _DWORD __cdecl G_VehSetSwitchNode(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174D4: using guessed type _DWORD __cdecl GScr_GetVehicleNodeIndex(_DWORD);

//----- (0008E328) --------------------------------------------------------
int __cdecl CMD_VEH_SetWaitNode(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  v5 = sub_7C280(a1);
  v4 = v5[89];
  if ( *((_BYTE *)v5 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v3);
    Scr_Error(v1);
  }
  result = GScr_GetVehicleNodeIndex(0);
  *(_WORD *)(v4 + 568) = result;
  return result;
}
// 8E36A: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 174D4: using guessed type _DWORD __cdecl GScr_GetVehicleNodeIndex(_DWORD);

//----- (0008E394) --------------------------------------------------------
void __cdecl CMD_VEH_SetWaitSpeed(int a1)
{
  int v1; // eax
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  v4 = sub_7C280(a1);
  v3 = v4[89];
  if ( *((_BYTE *)v4 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v2);
    Scr_Error(v1);
  }
  *(float *)(v3 + 572) = Scr_GetFloat(0) * 17.6;
  if ( *(float *)(v3 + 572) < 0.0 )
    Scr_ParamError(0, "Cannot have a negative wait speed on a vehicle");
}
// 8E3D6: variable 'v2' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (0008E435) --------------------------------------------------------
void __cdecl CMD_VEH_SetSpeed(int a1)
{
  int v1; // eax
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  v4 = sub_7C280(a1);
  v3 = v4[89];
  if ( *((_BYTE *)v4 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v2);
    Scr_Error(v1);
  }
  *(_DWORD *)(v3 + 628) = 1;
  *(float *)(v3 + 632) = Scr_GetFloat(0) * 17.6;
  *(float *)(v3 + 636) = Scr_GetFloat(1) * 17.6;
  if ( *(float *)(v3 + 632) < 0.0 )
    Scr_ParamError(0, "Cannot set negative speed on vehicle");
  if ( *(float *)(v3 + 636) < 0.0 )
    Scr_ParamError(1, "Cannot set negative acceleration on vehicle");
}
// 8E477: variable 'v2' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (0008E52E) --------------------------------------------------------
void __cdecl CMD_VEH_ResumeSpeed(int a1)
{
  int v1; // eax
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  v4 = sub_7C280(a1);
  v3 = v4[89];
  if ( *((_BYTE *)v4 + 382) == 2 )
  {
    v1 = va("Vehicle is invalid on path after it's been used", v2);
    Scr_Error(v1);
  }
  *(_DWORD *)(v3 + 628) = 2;
  *(float *)(v3 + 636) = Scr_GetFloat(0) * 17.6;
  if ( *(float *)(v3 + 636) < 0.0 )
    Scr_ParamError(0, "Cannot set negative acceleration on vehicle");
}
// 8E570: variable 'v2' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (0008E5DC) --------------------------------------------------------
int __cdecl CMD_VEH_JoltBody(int a1)
{
  int v2; // [esp+20h] [ebp-48h]
  float v3; // [esp+24h] [ebp-44h]
  float v4; // [esp+28h] [ebp-40h]
  float v5; // [esp+2Ch] [ebp-3Ch]
  int v6[4]; // [esp+30h] [ebp-38h] BYREF
  float v7[7]; // [esp+40h] [ebp-28h] BYREF
  int v8; // [esp+5Ch] [ebp-Ch]

  v8 = (int)sub_7C280(a1);
  v2 = Scr_GetNumParam();
  Scr_GetVector(0, v7);
  v5 = Scr_GetFloat(1);
  if ( v2 <= 2 )
  {
    v4 = 0.0;
    v3 = 0.0;
  }
  else
  {
    v4 = Scr_GetFloat(2);
    if ( v4 < 0.0 || v4 > 1.0 )
      Scr_ParamError(2, "Speed fraction must be between [0,1]");
    v3 = Scr_GetFloat(3) * 17.6;
    if ( v3 < 0.0 )
      Scr_ParamError(3, "Deceleration can't be negative");
  }
  *(float *)v6 = *(float *)(v8 + 316) - v7[0];
  *(float *)&v6[1] = *(float *)(v8 + 320) - v7[1];
  *(float *)&v6[2] = *(float *)(v8 + 324) - v7[2];
  VectorNormalize(v6);
  return sub_7D492(v8, (int)v6, v5, v4, SLODWORD(v3));
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 17D84: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19094: using guessed type int Scr_GetNumParam(void);

//----- (0008E72F) --------------------------------------------------------
int __cdecl CMD_VEH_FreeVehicle(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_7C280(a1);
  G_FreeVehicle(v2);
  v2[1] = 13;
  Scr_SetString(v2 + 97, scr_const[66]);
  Scr_Notify(v2, scr_const[14], 0);
  return Scr_FreeEntityNum(*v2, 0);
}
// 16A24: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 178E4: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 18024: using guessed type _DWORD __cdecl G_FreeVehicle(_DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0008E7C1) --------------------------------------------------------
int __cdecl CMD_VEH_GetWheelSurface(int a1)
{
  int v1; // eax
  int v2; // eax
  int v4; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+16h] [ebp-12h]
  char *v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v7 = sub_7C280(a1)[89];
  v6 = &byte_E3EC0[988 * *(__int16 *)(v7 + 556)];
  v5 = Scr_GetConstString(0);
  v4 = 0;
  if ( *((_WORD *)v6 + 32) != 2 && *((_WORD *)v6 + 32) != 1 )
  {
    v1 = va("Vehicle type [%s] has no wheels\n", (char)v6);
    Scr_Error(v1);
  }
  if ( v5 == scr_const[68] )
  {
    v4 = 0;
  }
  else if ( v5 == scr_const[69] )
  {
    v4 = 1;
  }
  else if ( v5 == scr_const[70] )
  {
    v4 = 2;
  }
  else if ( v5 == scr_const[71] )
  {
    v4 = 3;
  }
  else if ( v5 == scr_const[72] )
  {
    v4 = 4;
  }
  else if ( v5 == scr_const[73] )
  {
    v4 = 5;
  }
  else
  {
    Scr_ParamError(
      0,
      "Valid wheel names are: [front_left, front_right, back_left, back_right, middle_left, middle_right]\n");
  }
  if ( *((_WORD *)v6 + 32) == 1 && v4 > 3 )
    Scr_ParamError(0, "Vehicle has no middle wheels\n");
  if ( !*(_DWORD *)(v7 + 4 * v4 + 344) )
    return Scr_AddString("none");
  v2 = trap_SurfaceTypeToName(*(_DWORD *)(v7 + 4 * v4 + 344));
  return Scr_AddString(v2);
}
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19204: using guessed type _DWORD __cdecl trap_SurfaceTypeToName(_DWORD);

//----- (0008E97F) --------------------------------------------------------
int __cdecl CMD_VEH_GetSpeedMPH(int a1)
{
  float v2; // [esp+Ch] [ebp-Ch]

  v2 = *((float *)sub_7C280(a1) + 124) / 17.6;
  return Scr_AddFloat(LODWORD(v2));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0008E9CB) --------------------------------------------------------
_DWORD *__cdecl CMD_VEH_GetVehicleOwner(int a1)
{
  _DWORD *result; // eax

  result = sub_7C280(a1);
  if ( result[85] != 1023 )
    result = (_DWORD *)Scr_AddEntity(&g_entities[211 * result[85]]);
  return result;
}
// 18EF4: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0008EA21) --------------------------------------------------------
int __cdecl CMD_VEH_MakeVehicleUsable(int a1)
{
  _DWORD *v1; // eax
  _DWORD *v2; // edx
  int result; // eax

  v1 = sub_7C280(a1);
  v1[98] |= 1u;
  v2 = v1;
  result = v1[72] | 0x200000;
  v2[72] = result;
  return result;
}

//----- (0008EA63) --------------------------------------------------------
unsigned int __cdecl CMD_VEH_MakeVehicleUnusable(int a1)
{
  int v1; // eax
  unsigned int result; // eax
  char v3; // [esp+4h] [ebp-14h]
  _DWORD *v4; // [esp+10h] [ebp-8h]

  v4 = sub_7C280(a1);
  if ( v4[85] != 1023 )
  {
    v1 = va("Vehicle is already in use", v3);
    Scr_Error(v1);
  }
  v4[98] &= 0xFFFFFFFE;
  result = v4[72] & 0xFFDFFFFF;
  v4[72] = result;
  return result;
}
// 8EA9B: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0008EADA) --------------------------------------------------------
int __cdecl CMD_VEH_AddVehicleToCompass(int a1)
{
  int result; // eax

  result = sub_7C280(a1)[89];
  *(_DWORD *)(result + 592) = 1;
  return result;
}

//----- (0008EB09) --------------------------------------------------------
int __cdecl CMD_VEH_RemoveVehicleFromCompass(int a1)
{
  int result; // eax

  result = sub_7C280(a1)[89];
  *(_DWORD *)(result + 592) = 0;
  return result;
}

//----- (0008EB38) --------------------------------------------------------
int __cdecl CMD_VEH_StartEngineSound(int a1)
{
  int result; // eax

  result = sub_7C280(a1)[89];
  *(_DWORD *)(result + 704) = 1;
  return result;
}

//----- (0008EB67) --------------------------------------------------------
int __cdecl CMD_VEH_StopEngineSound(int a1)
{
  int result; // eax

  result = sub_7C280(a1)[89];
  *(_DWORD *)(result + 704) = 0;
  return result;
}

//----- (0008EB96) --------------------------------------------------------
_DWORD *__cdecl CMD_VEH_SetTurretTargetVec(int a1)
{
  int v1; // eax
  _DWORD *result; // eax
  char v3; // [esp+4h] [ebp-34h]
  int v4[6]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v5; // [esp+28h] [ebp-10h]
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_7C280(a1);
  v5 = (_DWORD *)v6[89];
  if ( (long double)(int)v6[144] <= 0.0 )
  {
    v1 = va("Vehicle must have health to control the turret", v3);
    Scr_Error(v1);
  }
  v5[161] = 1;
  v5[162] = 1023;
  Scr_GetVector(0, v4);
  v5[163] = v4[0];
  v5[164] = v4[1];
  v5[165] = v4[2];
  v5[166] = 0;
  v5[167] = 0;
  result = v5;
  v5[168] = 0;
  return result;
}
// 8EBE3: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (0008EC6E) --------------------------------------------------------
int __cdecl CMD_VEH_SetTurretTargetEnt(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // [esp+4h] [ebp-44h]
  int v4; // [esp+18h] [ebp-30h]
  int v5[2]; // [esp+20h] [ebp-28h] BYREF
  int v6; // [esp+28h] [ebp-20h]
  _DWORD *v7; // [esp+34h] [ebp-14h]
  int *v8; // [esp+38h] [ebp-10h]
  _DWORD *v9; // [esp+3Ch] [ebp-Ch]

  v9 = sub_7C280(a1);
  v8 = 0;
  v7 = (_DWORD *)v9[89];
  if ( (long double)(int)v9[144] <= 0.0 )
  {
    v1 = va("Vehicle must have health to control the turret", v3);
    Scr_Error(v1);
  }
  v8 = (int *)Scr_GetEntity(0);
  v7[161] = 1;
  if ( v8 )
    v4 = *v8;
  else
    v4 = 1023;
  v7[162] = v4;
  Scr_GetVector(1, v5);
  v7[163] = 0;
  v7[164] = 0;
  v7[165] = 0;
  v7[166] = v5[0];
  v7[167] = v5[1];
  result = v6;
  v7[168] = v6;
  return result;
}
// 8ECC2: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17314: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 17704: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (0008ED78) --------------------------------------------------------
_DWORD *__cdecl CMD_VEH_ClearTurretTarget(int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = (_DWORD *)sub_7C280(a1)[89];
  v2[161] = 0;
  v2[162] = 1023;
  v2[163] = 0;
  v2[164] = 0;
  v2[165] = 0;
  v2[166] = 0;
  v2[167] = 0;
  result = v2;
  v2[168] = 0;
  return result;
}

//----- (0008EE02) --------------------------------------------------------
int __cdecl CMD_VEH_FireTurret(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // al
  int v4; // eax
  int v5; // eax
  char v6; // al
  int v7; // eax
  char *v8; // eax
  int v9; // esi
  char v10; // [esp+4h] [ebp-174h]
  char v11; // [esp+4h] [ebp-174h]
  int v12; // [esp+30h] [ebp-148h]
  float v13; // [esp+34h] [ebp-144h]
  float v14; // [esp+38h] [ebp-140h]
  int v15; // [esp+3Ch] [ebp-13Ch]
  int v16; // [esp+40h] [ebp-138h]
  float v17; // [esp+44h] [ebp-134h]
  int v18; // [esp+48h] [ebp-130h]
  int v19; // [esp+4Ch] [ebp-12Ch]
  int v20; // [esp+54h] [ebp-124h]
  int v21; // [esp+58h] [ebp-120h]
  int i; // [esp+5Ch] [ebp-11Ch]
  int v23[9]; // [esp+60h] [ebp-118h] BYREF
  float v24; // [esp+84h] [ebp-F4h]
  float v25; // [esp+88h] [ebp-F0h]
  float v26; // [esp+8Ch] [ebp-ECh]
  float v27; // [esp+90h] [ebp-E8h] BYREF
  int v28; // [esp+94h] [ebp-E4h]
  int v29; // [esp+98h] [ebp-E0h]
  int v30; // [esp+9Ch] [ebp-DCh]
  float v31; // [esp+A0h] [ebp-D8h] BYREF
  float v32; // [esp+A4h] [ebp-D4h]
  int v33; // [esp+A8h] [ebp-D0h]
  char v34[16]; // [esp+B0h] [ebp-C8h] BYREF
  char v35[16]; // [esp+C0h] [ebp-B8h] BYREF
  int v36[4]; // [esp+D0h] [ebp-A8h] BYREF
  int v37[12]; // [esp+E0h] [ebp-98h] BYREF
  float v38; // [esp+110h] [ebp-68h]
  float v39; // [esp+114h] [ebp-64h]
  float v40; // [esp+118h] [ebp-60h]
  int v41[16]; // [esp+120h] [ebp-58h] BYREF
  int v42; // [esp+160h] [ebp-18h]
  char *v43; // [esp+164h] [ebp-14h]
  int v44; // [esp+168h] [ebp-10h]
  int v45; // [esp+16Ch] [ebp-Ch]

  v45 = (int)sub_7C280(a1);
  v44 = *(_DWORD *)(v45 + 356);
  v43 = &byte_E3EC0[988 * *(__int16 *)(v44 + 556)];
  v18 = 0;
  if ( (long double)*(int *)(v45 + 576) <= 0.0 )
  {
    v1 = va("Vehicle must have health to control the turret", v10);
    Scr_Error(v1);
  }
  result = v44;
  if ( *(_DWORD *)(v44 + 928) != 1023 )
  {
    *(_DWORD *)(v45 + 204) = (unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v43 - 116);
    if ( !*(_DWORD *)(v45 + 204) )
    {
      v3 = SL_ConvertToString(*(unsigned __int16 *)(v45 + 486));
      v4 = va("No weapon specified for [%s]\n", v3);
      Scr_Error(v4);
    }
    v30 = BG_GetInfoForWeapon(*(_DWORD *)(v45 + 204));
    if ( *(_DWORD *)(v30 + 124) && *(_DWORD *)(v30 + 124) != 2 )
    {
      v5 = va("Vehicles only support bullet and projectile weapons\n", v10);
      Scr_Error(v5);
    }
    if ( *(int *)(v44 + 776) < 0 )
    {
      v6 = SL_ConvertToString(*(unsigned __int16 *)(v45 + 486));
      v7 = va("No tag_barrel for [%s]\n", v6);
      Scr_Error(v7);
    }
    G_DObjGetWorldBoneIndexMatrix(v45, *(_DWORD *)(v44 + 776), v41);
    v42 = (int)&g_entities[211 * *(_DWORD *)(v44 + 928)];
    if ( *((_DWORD *)v43 + 19) )
    {
      v21 = 2;
      if ( *(_DWORD *)(v44 + 584) )
        v16 = 2;
      else
        v16 = 0;
      v20 = v16;
      if ( *(_DWORD *)(v44 + 584) )
        v15 = 175;
      else
        v15 = 174;
      v19 = v15;
    }
    else
    {
      v21 = 1;
      v20 = 0;
      v19 = 163;
    }
    for ( i = 0; i < v21; ++i )
    {
      if ( !G_DObjGetWorldTagMatrix(v45, *(char **)((char *)off_AE990 + (_DWORD)&dword_0[v20 + i]), v37) )
      {
        SL_ConvertToString(*(unsigned __int16 *)(v45 + 486));
        v8 = (char *)va("WARNING: No %s for [%s]\n", (char)*(char **)((char *)off_AE990 + (_DWORD)&dword_0[v20 + i]));
        G_Printf(v8, v11);
      }
      if ( *(_DWORD *)(v45 + 340) == 1023 || v21 != 1 || *(_DWORD *)(v44 + 624) )
      {
        v27 = *(float *)v37;
        v28 = v37[1];
        v29 = v37[2];
      }
      else
      {
        v27 = *(float *)(v44 + 652) - v38;
        *(float *)&v28 = *(float *)(v44 + 656) - v39;
        *(float *)&v29 = *(float *)(v44 + 660) - v40;
        VectorNormalize(&v27);
        vectoangles(v37, v35);
        vectoangles(&v27, v34);
        AnglesSubtract(v35, v34, &v31);
        if ( v31 >= -5.0 )
        {
          if ( v31 <= 5.0 )
            v14 = v31;
          else
            v14 = 5.0;
        }
        else
        {
          v14 = -5.0;
        }
        v31 = v14;
        if ( v32 >= -2.0 )
        {
          if ( v32 <= 2.0 )
            v13 = v32;
          else
            v13 = 2.0;
        }
        else
        {
          v13 = -2.0;
        }
        v32 = v13;
        v33 = 0;
        AnglesSubtract(v35, &v31, v35);
        AngleVectors(v35, &v27, 0, 0);
      }
      *(float *)v23 = v27;
      v23[1] = v28;
      v23[2] = v29;
      v23[3] = v37[4];
      v23[4] = v37[5];
      v23[5] = v37[6];
      v23[6] = v37[8];
      v23[7] = v37[9];
      v23[8] = v37[10];
      if ( *(_DWORD *)(v44 + 624) )
      {
        v24 = -*(float *)(v44 + 620) * v27 + v38;
        v25 = -*(float *)(v44 + 620) * *(float *)&v28 + v39;
        v26 = -*(float *)(v44 + 620) * *(float *)&v29 + v40;
      }
      else
      {
        v24 = v38;
        v25 = v39;
        v26 = v40;
      }
      if ( *(_DWORD *)(v30 + 124) )
      {
        Weapon_Artillery_Fire(v45, 0.0, (int)v23);
      }
      else
      {
        v9 = v30;
        v17 = (long double)rand() / 2147483600.0 * *(float *)(v30 + 676) + *(float *)(v9 + 664);
        v18 = Bullet_Fire(v42, v17, *(_DWORD *)(v30 + 520), (int)v23, v45);
      }
    }
    if ( *(_DWORD *)(v30 + 124) )
    {
      G_AddEvent(v45, v19, 0);
    }
    else
    {
      v12 = *(_DWORD *)(v45 + 204);
      if ( !v18 )
        v12 |= 0x80u;
      G_AddEvent(v45, v19, v12);
    }
    v36[0] = v41[0] ^ 0x80000000;
    v36[1] = v41[1] ^ 0x80000000;
    v36[2] = v41[2] ^ 0x80000000;
    sub_7D492(v45, (int)v36, 0.75, 0.0, 0);
    *(_DWORD *)(v44 + 576) = *(_DWORD *)(v30 + 556);
    result = *(_DWORD *)(v44 + 584) == 0;
    *(_DWORD *)(v44 + 584) = result;
  }
  return result;
}
// 8EE7A: variable 'v10' is possibly undefined
// 8F0C9: variable 'v11' is possibly undefined
// 0: using guessed type int dword_0[];
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// AE990: using guessed type char *off_AE990[13];

//----- (0008F57E) --------------------------------------------------------
int __cdecl CMD_VEH_FireAltTurret(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // al
  int v4; // eax
  int v5; // eax
  char v6; // al
  int v7; // eax
  char *v8; // eax
  int v9; // esi
  char v10; // [esp+4h] [ebp-164h]
  char v11; // [esp+4h] [ebp-164h]
  int v12; // [esp+38h] [ebp-130h]
  float v13; // [esp+3Ch] [ebp-12Ch]
  float v14; // [esp+40h] [ebp-128h]
  float v15; // [esp+44h] [ebp-124h]
  int v16; // [esp+48h] [ebp-120h]
  int i; // [esp+5Ch] [ebp-10Ch]
  float v18; // [esp+60h] [ebp-108h] BYREF
  float v19; // [esp+64h] [ebp-104h]
  int v20; // [esp+68h] [ebp-100h]
  char v21[16]; // [esp+70h] [ebp-F8h] BYREF
  char v22[16]; // [esp+80h] [ebp-E8h] BYREF
  int v23[9]; // [esp+90h] [ebp-D8h] BYREF
  float v24; // [esp+B4h] [ebp-B4h]
  float v25; // [esp+B8h] [ebp-B0h]
  float v26; // [esp+BCh] [ebp-ACh]
  float v27; // [esp+C0h] [ebp-A8h] BYREF
  int v28; // [esp+C4h] [ebp-A4h]
  int v29; // [esp+C8h] [ebp-A0h]
  int v30; // [esp+CCh] [ebp-9Ch]
  int v31[12]; // [esp+D0h] [ebp-98h] BYREF
  float v32; // [esp+100h] [ebp-68h]
  float v33; // [esp+104h] [ebp-64h]
  float v34; // [esp+108h] [ebp-60h]
  char v35[64]; // [esp+110h] [ebp-58h] BYREF
  int v36; // [esp+150h] [ebp-18h]
  char *v37; // [esp+154h] [ebp-14h]
  int v38; // [esp+158h] [ebp-10h]
  int v39; // [esp+15Ch] [ebp-Ch]

  v39 = (int)sub_7C280(a1);
  v38 = *(_DWORD *)(v39 + 356);
  v37 = &byte_E3EC0[988 * *(__int16 *)(v38 + 556)];
  v16 = 0;
  if ( (long double)*(int *)(v39 + 576) <= 0.0 )
  {
    v1 = va("Vehicle must have health to control the turret", v10);
    Scr_Error(v1);
  }
  result = v38;
  if ( !*(_DWORD *)(v38 + 612) )
  {
    result = v38;
    if ( *(_DWORD *)(v38 + 928) != 1023 )
    {
      *(_DWORD *)(v39 + 204) = (unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v37 - 52);
      if ( !*(_DWORD *)(v39 + 204) )
      {
        v3 = SL_ConvertToString(*(unsigned __int16 *)(v39 + 486));
        v4 = va("No weapon specified for [%s]\n", v3);
        Scr_Error(v4);
      }
      v30 = BG_GetInfoForWeapon(*(_DWORD *)(v39 + 204));
      if ( *(_DWORD *)(v30 + 124) && *(_DWORD *)(v30 + 124) != 2 )
      {
        v5 = va("Vehicles only support bullet and projectile weapons\n", v10);
        Scr_Error(v5);
      }
      if ( *(int *)(v38 + 780) < 0 )
      {
        v6 = SL_ConvertToString(*(unsigned __int16 *)(v39 + 486));
        v7 = va("No tag_barrel for [%s]\n", v6);
        Scr_Error(v7);
      }
      G_DObjGetWorldBoneIndexMatrix(v39, *(_DWORD *)(v38 + 780), v35);
      v36 = (int)&g_entities[211 * *(_DWORD *)(v38 + 928)];
      if ( !*(_DWORD *)(v36 + 352) || (result = *(_DWORD *)(v36 + 352), *(_DWORD *)(result + 17668) != 3) )
      {
        for ( i = 0; i < 1; ++i )
        {
          if ( !G_DObjGetWorldTagMatrix(v39, *(char **)((char *)off_AE9A0 + (_DWORD)&dword_0[i]), v31) )
          {
            SL_ConvertToString(*(unsigned __int16 *)(v39 + 486));
            v8 = (char *)va("WARNING: No %s for [%s]\n", (char)*(char **)((char *)off_AE9A0 + (_DWORD)&dword_0[i]));
            G_Printf(v8, v11);
          }
          if ( *(_DWORD *)(v39 + 340) == 1023 || *(_DWORD *)(v38 + 624) )
          {
            v27 = *(float *)v31;
            v28 = v31[1];
            v29 = v31[2];
          }
          else
          {
            v27 = *(float *)(v38 + 652) - v32;
            *(float *)&v28 = *(float *)(v38 + 656) - v33;
            *(float *)&v29 = *(float *)(v38 + 660) - v34;
            VectorNormalize(&v27);
            vectoangles(v31, v22);
            vectoangles(&v27, v21);
            AnglesSubtract(v22, v21, &v18);
            if ( v18 >= -5.0 )
            {
              if ( v18 <= 5.0 )
                v14 = v18;
              else
                v14 = 5.0;
            }
            else
            {
              v14 = -5.0;
            }
            v18 = v14;
            if ( v19 >= -2.0 )
            {
              if ( v19 <= 2.0 )
                v13 = v19;
              else
                v13 = 2.0;
            }
            else
            {
              v13 = -2.0;
            }
            v19 = v13;
            v20 = 0;
            AnglesSubtract(v22, &v18, v22);
            AngleVectors(v22, &v27, 0, 0);
          }
          *(float *)v23 = v27;
          v23[1] = v28;
          v23[2] = v29;
          v23[3] = v31[4];
          v23[4] = v31[5];
          v23[5] = v31[6];
          v23[6] = v31[8];
          v23[7] = v31[9];
          v23[8] = v31[10];
          if ( *(_DWORD *)(v38 + 624) )
          {
            v24 = -*(float *)(v38 + 620) * v27 + v32;
            v25 = -*(float *)(v38 + 620) * *(float *)&v28 + v33;
            v26 = -*(float *)(v38 + 620) * *(float *)&v29 + v34;
          }
          else
          {
            v24 = v32;
            v25 = v33;
            v26 = v34;
          }
          if ( *(_DWORD *)(v30 + 124) )
          {
            Weapon_Artillery_Fire(v39, 0.0, (int)v23);
          }
          else
          {
            v9 = v30;
            v15 = (long double)rand() / 2147483600.0 * *(float *)(v30 + 676) + *(float *)(v9 + 664);
            v16 = Bullet_Fire(v36, v15, *(_DWORD *)(v30 + 520), (int)v23, v39);
            *(float *)(v38 + 604) = *(float *)(v38 + 604) + *(float *)(v30 + 1180);
          }
        }
        if ( *(_DWORD *)(v30 + 124) )
        {
          G_AddEvent(v39, 164, 0);
        }
        else
        {
          v12 = *(_DWORD *)(v39 + 204);
          if ( !v16 )
            v12 |= 0x80u;
          G_AddEvent(v39, 164, v12);
        }
        *(_DWORD *)(v38 + 580) = *(_DWORD *)(v30 + 556);
        result = v38;
        *(_DWORD *)(v38 + 740) = 200;
      }
    }
  }
  return result;
}
// 8F825: conditional instruction was optimized away because of '%var_110.4==1'
// 8F5F6: variable 'v10' is possibly undefined
// 8F806: variable 'v11' is possibly undefined
// 0: using guessed type int dword_0[];
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 186F4: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// AE9A0: using guessed type char *off_AE9A0[9];

//----- (0008FC7A) --------------------------------------------------------
int __cdecl G_VEH_FireGunner(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  char v4; // al
  int v5; // eax
  int v6; // eax
  char v7; // al
  int v8; // eax
  char *v9; // eax
  int v10; // esi
  char v11; // [esp+4h] [ebp-124h]
  char v12; // [esp+4h] [ebp-124h]
  int v13; // [esp+30h] [ebp-F8h]
  float v14; // [esp+34h] [ebp-F4h]
  int v15; // [esp+38h] [ebp-F0h]
  int i; // [esp+4Ch] [ebp-DCh]
  int v17[9]; // [esp+50h] [ebp-D8h] BYREF
  float v18; // [esp+74h] [ebp-B4h]
  float v19; // [esp+78h] [ebp-B0h]
  float v20; // [esp+7Ch] [ebp-ACh]
  float v21; // [esp+80h] [ebp-A8h]
  float v22; // [esp+84h] [ebp-A4h]
  float v23; // [esp+88h] [ebp-A0h]
  int v24; // [esp+8Ch] [ebp-9Ch]
  float v25; // [esp+90h] [ebp-98h] BYREF
  float v26; // [esp+94h] [ebp-94h]
  float v27; // [esp+98h] [ebp-90h]
  int v28; // [esp+A0h] [ebp-88h]
  int v29; // [esp+A4h] [ebp-84h]
  int v30; // [esp+A8h] [ebp-80h]
  int v31; // [esp+B0h] [ebp-78h]
  int v32; // [esp+B4h] [ebp-74h]
  int v33; // [esp+B8h] [ebp-70h]
  float v34; // [esp+C0h] [ebp-68h]
  float v35; // [esp+C4h] [ebp-64h]
  float v36; // [esp+C8h] [ebp-60h]
  char v37[64]; // [esp+D0h] [ebp-58h] BYREF
  int v38; // [esp+110h] [ebp-18h]
  char *v39; // [esp+114h] [ebp-14h]
  int v40; // [esp+118h] [ebp-10h]
  int v41; // [esp+11Ch] [ebp-Ch]

  v41 = (int)sub_7C280(a1);
  v40 = *(_DWORD *)(v41 + 356);
  v39 = &byte_E3EC0[988 * *(__int16 *)(v40 + 556)];
  v15 = 0;
  if ( !a2 && (long double)*(int *)(v41 + 576) <= 0.0 )
  {
    v2 = va("Vehicle must have health to control the turret", v11);
    Scr_Error(v2);
  }
  if ( a2 || (result = v40, !*(_DWORD *)(v40 + 616)) )
  {
    if ( a2 || (result = v40, *(_DWORD *)(v40 + 932) != 1023) )
    {
      *(_DWORD *)(v41 + 204) = (unsigned __int8)BG_GetWeaponIndexForName((_BYTE)v39 + 32);
      if ( !*(_DWORD *)(v41 + 204) )
      {
        v4 = SL_ConvertToString(*(unsigned __int16 *)(v41 + 486));
        v5 = va("No weapon specified for [%s]\n", v4);
        Scr_Error(v5);
      }
      v24 = BG_GetInfoForWeapon(*(_DWORD *)(v41 + 204));
      if ( *(_DWORD *)(v24 + 124) && *(_DWORD *)(v24 + 124) != 2 )
      {
        v6 = va("Vehicles only support bullet and projectile weapons\n", v11);
        Scr_Error(v6);
      }
      if ( *(int *)(v40 + 788) < 0 )
      {
        v7 = SL_ConvertToString(*(unsigned __int16 *)(v41 + 486));
        v8 = va("No tag_secondary_gun for [%s]\n", v7);
        Scr_Error(v8);
      }
      G_DObjGetWorldBoneIndexMatrix(v41, *(_DWORD *)(v40 + 788), v37);
      if ( a2 )
      {
        v38 = (int)g_entities;
      }
      else
      {
        v38 = (int)&g_entities[211 * *(_DWORD *)(v40 + 932)];
        if ( *(_DWORD *)(v38 + 352) )
        {
          result = *(_DWORD *)(v38 + 352);
          if ( *(_DWORD *)(result + 17668) == 3 )
            return result;
        }
      }
      for ( i = 0; i < 1; ++i )
      {
        if ( !G_DObjGetWorldTagMatrix(v41, *(char **)((char *)off_AE9B0 + (_DWORD)&dword_0[i]), &v25) )
        {
          SL_ConvertToString(*(unsigned __int16 *)(v41 + 486));
          v9 = (char *)va("WARNING: No %s for [%s]\n", (char)*(char **)((char *)off_AE9B0 + (_DWORD)&dword_0[i]));
          G_Printf(v9, v12);
        }
        v21 = v25;
        v22 = v26;
        v23 = v27;
        *(float *)v17 = v25;
        *(float *)&v17[1] = v26;
        *(float *)&v17[2] = v27;
        v17[3] = v28;
        v17[4] = v29;
        v17[5] = v30;
        v17[6] = v31;
        v17[7] = v32;
        v17[8] = v33;
        if ( *(_DWORD *)(v40 + 624) )
        {
          v18 = -*(float *)(v40 + 620) * v21 + v34;
          v19 = -*(float *)(v40 + 620) * v22 + v35;
          v20 = -*(float *)(v40 + 620) * v23 + v36;
        }
        else
        {
          v18 = v34;
          v19 = v35;
          v20 = v36;
        }
        if ( *(_DWORD *)(v24 + 124) )
        {
          Weapon_Artillery_Fire(v41, 0.0, (int)v17);
        }
        else
        {
          v10 = v24;
          v14 = (long double)rand() / 2147483600.0 * *(float *)(v24 + 676) + *(float *)(v10 + 664);
          v15 = Bullet_Fire(v38, v14, *(_DWORD *)(v24 + 520), (int)v17, v41);
          *(float *)(v40 + 608) = *(float *)(v40 + 608) + *(float *)(v24 + 1180);
        }
      }
      if ( *(_DWORD *)(v24 + 124) )
      {
        G_AddEvent(v41, 165, 0);
      }
      else
      {
        v13 = *(_DWORD *)(v41 + 204);
        if ( !v15 )
          v13 |= 0x80u;
        G_AddEvent(v41, 165, v13);
      }
      *(_DWORD *)(v40 + 600) = *(_DWORD *)(v24 + 556);
      result = v40;
      *(_DWORD *)(v40 + 752) = 200;
    }
  }
  return result;
}
// 8FCF8: variable 'v11' is possibly undefined
// 8FF23: variable 'v12' is possibly undefined
// 0: using guessed type int dword_0[];
// 16B74: using guessed type _DWORD __cdecl G_DObjGetWorldBoneIndexMatrix(_DWORD, _DWORD, _DWORD);
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17774: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 19494: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 19714: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// AE9B0: using guessed type char *off_AE9B0[5];

//----- (000901B0) --------------------------------------------------------
int __cdecl CMD_VEH_FireGunner(int a1)
{
  return G_VEH_FireGunner(a1, 0);
}
// 177D4: using guessed type _DWORD __cdecl G_VEH_FireGunner(_DWORD, _DWORD);

//----- (000901DB) --------------------------------------------------------
int __cdecl CMD_VEH_IsTurretReady(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = sub_7C280(a1);
  v4 = v5[89];
  if ( *((_BYTE *)v5 + 382) != 2 )
  {
    v1 = va("Must be called on a player controlled vehicle", v3);
    Scr_Error(v1);
  }
  if ( *(int *)(v4 + 576) > 0 )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}
// 9021C: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00090255) --------------------------------------------------------
int __cdecl CMD_VEH_GetFireTime(int a1)
{
  int v1; // eax
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = sub_7C280(a1);
  v4 = v5[89];
  if ( *((_BYTE *)v5 + 382) != 2 )
  {
    v1 = va("Must be called on a player controlled vehicle", v3);
    Scr_Error(v1);
  }
  return Scr_AddInt(*(_DWORD *)(v4 + 576));
}
// 90296: variable 'v3' is possibly undefined
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (000902BA) --------------------------------------------------------
int __cdecl CMD_VEH_GetAltHeat(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_7C280(a1);
  return Scr_AddFloat(*(_DWORD *)(v2[89] + 604));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (000902FD) --------------------------------------------------------
int __cdecl CMD_VEH_GetAltOverheating(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_7C280(a1);
  return Scr_AddInt(*(_DWORD *)(v2[89] + 612));
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00090340) --------------------------------------------------------
int __cdecl CMD_VEH_GetGunnerOverheating(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_7C280(a1);
  return Scr_AddInt(*(_DWORD *)(v2[89] + 616));
}
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00090383) --------------------------------------------------------
int __cdecl CMD_VEH_GetGunnerHeat(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_7C280(a1);
  return Scr_AddFloat(*(_DWORD *)(v2[89] + 608));
}
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (000903C6) --------------------------------------------------------
int __cdecl CMD_VEH_GetDismountSpot(int a1)
{
  int result; // eax
  int v2[4]; // [esp+20h] [ebp-48h] BYREF
  int v3[4]; // [esp+30h] [ebp-38h] BYREF
  int v4[7]; // [esp+40h] [ebp-28h] BYREF
  _DWORD *v5; // [esp+5Ch] [ebp-Ch]

  v5 = sub_7C280(a1);
  v4[0] = -1049624576;
  v4[1] = -1049624576;
  v4[2] = 1097859072;
  v3[0] = 1097859072;
  v3[1] = 1097859072;
  v3[2] = 1116471296;
  v2[0] = v5[79];
  v2[1] = v5[80];
  v2[2] = v5[81];
  if ( VEH_FindValidDismountSpot(v5, v5 + 79, v4, v3, v2, 0) )
    result = Scr_AddVector(v2);
  else
    result = Scr_AddVector(v5 + 79);
  return result;
}
// 18CF4: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 18FC4: using guessed type _DWORD __cdecl VEH_FindValidDismountSpot(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0009048F) --------------------------------------------------------
int __cdecl G_PlayerVehiclePositionAndBlend(int *a1)
{
  char v1; // al
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  char v6; // al
  char v7; // al
  char v8; // al
  float *v9; // eax
  float v11; // [esp+8h] [ebp-120h]
  float v12; // [esp+2Ch] [ebp-FCh]
  float v13; // [esp+30h] [ebp-F8h]
  float v14; // [esp+34h] [ebp-F4h]
  float v15; // [esp+38h] [ebp-F0h]
  float v16; // [esp+3Ch] [ebp-ECh]
  float v17; // [esp+40h] [ebp-E8h]
  float v18; // [esp+44h] [ebp-E4h]
  float v19; // [esp+48h] [ebp-E0h]
  float v20; // [esp+4Ch] [ebp-DCh]
  float v21; // [esp+50h] [ebp-D8h]
  float v22; // [esp+54h] [ebp-D4h]
  int v23; // [esp+58h] [ebp-D0h]
  float v24; // [esp+5Ch] [ebp-CCh]
  float v25; // [esp+5Ch] [ebp-CCh]
  float v26; // [esp+5Ch] [ebp-CCh]
  float v27; // [esp+5Ch] [ebp-CCh]
  float v28; // [esp+5Ch] [ebp-CCh]
  float v29; // [esp+5Ch] [ebp-CCh]
  float v30; // [esp+5Ch] [ebp-CCh]
  float v31; // [esp+5Ch] [ebp-CCh]
  float v32; // [esp+5Ch] [ebp-CCh]
  float v33; // [esp+64h] [ebp-C4h]
  float v34; // [esp+68h] [ebp-C0h]
  float v35; // [esp+6Ch] [ebp-BCh]
  float v36; // [esp+6Ch] [ebp-BCh]
  float v37; // [esp+6Ch] [ebp-BCh]
  float v38; // [esp+6Ch] [ebp-BCh]
  float v39; // [esp+6Ch] [ebp-BCh]
  float v40; // [esp+6Ch] [ebp-BCh]
  float v41; // [esp+6Ch] [ebp-BCh]
  float v42; // [esp+6Ch] [ebp-BCh]
  float v43; // [esp+6Ch] [ebp-BCh]
  int v44; // [esp+74h] [ebp-B4h] BYREF
  int v45; // [esp+78h] [ebp-B0h] BYREF
  int v46; // [esp+7Ch] [ebp-ACh] BYREF
  int v47; // [esp+80h] [ebp-A8h]
  int v48; // [esp+84h] [ebp-A4h]
  int v49; // [esp+88h] [ebp-A0h]
  char v50[4]; // [esp+8Ch] [ebp-9Ch]
  float v51; // [esp+90h] [ebp-98h] BYREF
  float v52; // [esp+94h] [ebp-94h]
  float v53; // [esp+98h] [ebp-90h]
  float v54; // [esp+9Ch] [ebp-8Ch]
  float v55; // [esp+A0h] [ebp-88h]
  float v56; // [esp+A4h] [ebp-84h]
  float v57; // [esp+A8h] [ebp-80h]
  float v58; // [esp+ACh] [ebp-7Ch]
  float v59; // [esp+B0h] [ebp-78h]
  int v60[18]; // [esp+C0h] [ebp-68h] BYREF
  char *v61; // [esp+108h] [ebp-20h]
  float *v62; // [esp+10Ch] [ebp-1Ch]
  int v63; // [esp+110h] [ebp-18h]
  int v64; // [esp+114h] [ebp-14h]
  int v65; // [esp+118h] [ebp-10h]
  char *v66; // [esp+11Ch] [ebp-Ch]

  if ( a1[29] <= 63 || a1[29] == 1023 )
    return 0;
  if ( *(int *)(a1[88] + 1556) <= 0 || *(int *)(a1[88] + 1556) > 6 )
    return 0;
  v65 = a1[37];
  v66 = &aSDoesNotExist[1232 * v65 + (_DWORD)bgs];
  v62 = (float *)&g_entities[211 * a1[85]];
  v61 = v66 + 896;
  if ( *((_DWORD *)v66 + 228) && *((_DWORD *)v61 + 5) && (*(_DWORD *)(*((_DWORD *)v61 + 5) + 80) & 4) != 0 )
  {
    if ( (*(_DWORD *)(a1[88] + 1556) == 1 || *(_DWORD *)(a1[88] + 1556) == 3) && *((_DWORD *)v62 + 34) == 1 )
    {
      v33 = v62[54];
      v49 = *((_DWORD *)v66 + 305);
      v48 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
      HIWORD(v47) = Scr_GetAnimsIndex(v48);
      LOWORD(v47) = *((_WORD *)v61 + 8) & 0xFDFF;
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v64 = trap_XAnimGetNumChildren(v47);
      if ( !v64 )
      {
        v1 = trap_XAnimGetAnimName(v47);
        Com_Error(1, byte_A7A80, v1);
      }
      trap_XAnimGetChildAt(&v44);
      v63 = trap_XAnimGetNumChildren(v44);
      if ( !v63 )
      {
        v2 = trap_XAnimGetAnimName(v44);
        Com_Error(1, byte_A7A80, v2);
      }
      trap_XAnimGetChildAt(&v46);
      if ( v33 <= 0.0 )
      {
        if ( v33 >= 0.0 )
        {
          v34 = 0.0;
          trap_XAnimGetChildAt(&v45);
        }
        else
        {
          if ( fabs(v33) / 45.0 >= 1.0 )
            v21 = 1.0;
          else
            v21 = fabs(v33) / 45.0;
          v34 = v21;
          trap_XAnimGetChildAt(&v45);
        }
      }
      else
      {
        if ( v33 / 45.0 >= 1.0 )
          v22 = 1.0;
        else
          v22 = v33 / 45.0;
        v34 = v22;
        trap_XAnimGetChildAt(&v45);
      }
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v24 = fabs(trap_XAnimGetWeight(v49, v46) - (1.0 - v34));
      v35 = v24 * 10.0;
      if ( v35 <= 0.0 )
        v20 = 0.0;
      else
        v20 = 1.0 / v35;
      v11 = 1.0 - v34;
      trap_XAnimSetGoalWeight(v49, v46, LODWORD(v11), LODWORD(v20), 1065353216, 0, 0);
      if ( v34 != 0.0 )
      {
        v25 = fabs(trap_XAnimGetWeight(v49, v45) - v34);
        v36 = v25 * 10.0;
        if ( v36 <= 0.0 )
        {
          trap_XAnimSetGoalWeight(v49, v45, LODWORD(v34), 0, 1065353216, 0, 0);
        }
        else
        {
          v19 = 1.0 / v36;
          trap_XAnimSetGoalWeight(v49, v45, LODWORD(v34), LODWORD(v19), 1065353216, 0, 0);
        }
      }
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, 1065353216, 1065353216, 0, 0);
      v26 = fabs(trap_XAnimGetWeight(v49, v44) - 1.0);
      v37 = v26 * 10.0;
      if ( v37 <= 0.0 )
        v18 = 0.0;
      else
        v18 = 1.0 / v37;
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, LODWORD(v18), 1065353216, 0, 0);
    }
    else if ( *(_DWORD *)(a1[88] + 1556) == 2 && *((_DWORD *)v62 + 34) == 1 )
    {
      v49 = *((_DWORD *)v66 + 305);
      v48 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
      HIWORD(v47) = Scr_GetAnimsIndex(v48);
      LOWORD(v47) = *((_WORD *)v61 + 8) & 0xFDFF;
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v64 = trap_XAnimGetNumChildren(v47);
      if ( !v64 )
      {
        v3 = trap_XAnimGetAnimName(v47);
        Com_Error(1, byte_A7A80, v3);
      }
      trap_XAnimGetChildAt(&v44);
      v63 = trap_XAnimGetNumChildren(v44);
      if ( !v63 )
      {
        v4 = trap_XAnimGetAnimName(v44);
        Com_Error(1, byte_A7A80, v4);
      }
      trap_XAnimGetChildAt(&v46);
      trap_XAnimSetGoalWeight(v49, v46, 1065353216, 1065353216, 1065353216, 0, 0);
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v27 = fabs(trap_XAnimGetWeight(v49, v46) - 1.0);
      v38 = v27 * 10.0;
      if ( v38 <= 0.0 )
      {
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, 0, 1065353216, 0, 0);
      }
      else
      {
        v17 = 1.0 / v38;
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, LODWORD(v17), 1065353216, 0, 0);
      }
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, 1065353216, 1065353216, 0, 0);
      v28 = fabs(trap_XAnimGetWeight(v49, v44) - 1.0);
      v39 = v28 * 10.0;
      if ( v39 <= 0.0 )
        v16 = 0.0;
      else
        v16 = 1.0 / v39;
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, LODWORD(v16), 1065353216, 0, 0);
    }
    else if ( *((_DWORD *)v62 + 34) == 5 )
    {
      v49 = *((_DWORD *)v66 + 305);
      v48 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
      HIWORD(v47) = Scr_GetAnimsIndex(v48);
      LOWORD(v47) = *((_WORD *)v61 + 8) & 0xFDFF;
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v64 = trap_XAnimGetNumChildren(v47);
      if ( !v64 )
      {
        v5 = trap_XAnimGetAnimName(v47);
        Com_Error(1, byte_A7A80, v5);
      }
      trap_XAnimGetChildAt(&v44);
      v63 = trap_XAnimGetNumChildren(v44);
      if ( !v63 )
      {
        v6 = trap_XAnimGetAnimName(v44);
        Com_Error(1, byte_A7A80, v6);
      }
      trap_XAnimGetChildAt(&v46);
      trap_XAnimSetGoalWeight(v49, v46, 1065353216, 1065353216, 1065353216, 0, 0);
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v29 = fabs(trap_XAnimGetWeight(v49, v46) - 1.0);
      v40 = v29 * 10.0;
      if ( v40 <= 0.0 )
      {
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, 0, 1065353216, 0, 0);
      }
      else
      {
        v15 = 1.0 / v40;
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, LODWORD(v15), 1065353216, 0, 0);
      }
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, 1065353216, 1065353216, 0, 0);
      v30 = fabs(trap_XAnimGetWeight(v49, v44) - 1.0);
      v41 = v30 * 10.0;
      if ( v41 <= 0.0 )
        v14 = 0.0;
      else
        v14 = 1.0 / v41;
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, LODWORD(v14), 1065353216, 0, 0);
    }
    else if ( *((_DWORD *)v62 + 34) == 2 && *(_DWORD *)(a1[88] + 1556) == 2 )
    {
      v49 = *((_DWORD *)v66 + 305);
      v48 = *(int *)((char *)&dword_A7AC8 + (_DWORD)bgs);
      HIWORD(v47) = Scr_GetAnimsIndex(v48);
      LOWORD(v47) = *((_WORD *)v61 + 8) & 0xFDFF;
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v64 = trap_XAnimGetNumChildren(v47);
      if ( !v64 )
      {
        v7 = trap_XAnimGetAnimName(v47);
        Com_Error(1, byte_A7A80, v7);
      }
      trap_XAnimGetChildAt(&v44);
      v63 = trap_XAnimGetNumChildren(v44);
      if ( !v63 )
      {
        v8 = trap_XAnimGetAnimName(v44);
        Com_Error(1, byte_A7A80, v8);
      }
      trap_XAnimGetChildAt(&v46);
      trap_XAnimSetGoalWeight(v49, v46, 1065353216, 1065353216, 1065353216, 0, 0);
      trap_XAnimClearTreeGoalWeightsStrict(v49, v47, 0);
      v31 = fabs(trap_XAnimGetWeight(v49, v46) - 1.0);
      v42 = v31 * 10.0;
      if ( v42 <= 0.0 )
      {
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, 0, 1065353216, 0, 0);
      }
      else
      {
        v13 = 1.0 / v42;
        trap_XAnimSetGoalWeight(v49, v46, 1065353216, LODWORD(v13), 1065353216, 0, 0);
      }
      trap_XAnimSetGoalWeight(v49, v44, 1065353216, 1065353216, 1065353216, 0, 0);
      v32 = fabs(trap_XAnimGetWeight(v49, v44) - 1.0);
      v43 = v32 * 10.0;
      if ( v43 <= 0.0 )
      {
        ((void (__cdecl *)(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))trap_XAnimSetGoalWeight)(
          v49,
          v44,
          1065353216,
          0.0,
          1065353216,
          0,
          0);
      }
      else
      {
        v12 = 1.0 / v43;
        trap_XAnimSetGoalWeight(v49, v44, 1065353216, LODWORD(v12), 1065353216, 0, 0);
      }
    }
  }
  *(_DWORD *)v50 = BG_GetVehiclePosTag(*(_DWORD *)(a1[88] + 1556));
  if ( G_DObjGetWorldTagMatrix(v62, *(_DWORD *)v50, v60) )
  {
    v51 = *(float *)v60;
    v52 = *(float *)&v60[1];
    v53 = *(float *)&v60[2];
    v54 = *(float *)&v60[4];
    v55 = *(float *)&v60[5];
    v56 = *(float *)&v60[6];
    v57 = *(float *)&v60[8];
    v58 = *(float *)&v60[9];
    v59 = *(float *)&v60[10];
    *(_DWORD *)(a1[88] + 20) = v60[12];
    *(_DWORD *)(a1[88] + 24) = v60[13];
    *(_DWORD *)(a1[88] + 28) = v60[14];
    v9 = (float *)BG_GetVehiclePosOffset(*((_DWORD *)v62 + 34), *(_DWORD *)(a1[88] + 1556));
    *(float *)(a1[88] + 20) = v51 * *v9 + *(float *)(a1[88] + 20);
    *(float *)(a1[88] + 24) = v52 * *v9 + *(float *)(a1[88] + 24);
    *(float *)(a1[88] + 28) = v53 * *v9 + *(float *)(a1[88] + 28);
    *(float *)(a1[88] + 20) = v54 * v9[1] + *(float *)(a1[88] + 20);
    *(float *)(a1[88] + 24) = v55 * v9[1] + *(float *)(a1[88] + 24);
    *(float *)(a1[88] + 28) = v56 * v9[1] + *(float *)(a1[88] + 28);
    *(float *)(a1[88] + 20) = v57 * v9[2] + *(float *)(a1[88] + 20);
    *(float *)(a1[88] + 24) = v58 * v9[2] + *(float *)(a1[88] + 24);
    *(float *)(a1[88] + 28) = v59 * v9[2] + *(float *)(a1[88] + 28);
    BG_PlayerStateToEntityState(a1[88], a1, 1);
    a1[79] = *(_DWORD *)(a1[88] + 20);
    a1[80] = *(_DWORD *)(a1[88] + 24);
    a1[81] = *(_DWORD *)(a1[88] + 28);
    AxisToAngles(&v51, a1 + 82);
    AxisToAngles(&v51, v66 + 1012);
    v23 = 1;
  }
  else
  {
    Com_Printf(aWarn, v50[0]);
    v23 = 0;
  }
  return v23;
}
// 16B44: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 16FC4: using guessed type _DWORD __cdecl BG_GetVehiclePosOffset(_DWORD, _DWORD);
// 17294: using guessed type _DWORD __cdecl trap_XAnimClearTreeGoalWeightsStrict(_DWORD, __int16, _DWORD);
// 17A64: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 17E84: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 18004: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 181D4: using guessed type _DWORD __cdecl BG_GetVehiclePosTag(_DWORD);
// 185F4: using guessed type _DWORD __cdecl trap_XAnimGetAnimName(_DWORD);
// 18674: using guessed type _DWORD __cdecl trap_XAnimGetNumChildren(_DWORD);
// 18D14: using guessed type _DWORD __stdcall trap_XAnimGetChildAt(_DWORD);
// 19154: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 195D4: using guessed type _DWORD __cdecl trap_XAnimSetGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// A7AC8: using guessed type int dword_A7AC8;

//----- (000918E2) --------------------------------------------------------
int __cdecl script_vehicle_owner_enable(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 796) && *(_DWORD *)(*(_DWORD *)(a1 + 796) + 352) && (*(_DWORD *)(a1 + 248) & 0x800) == 0 )
  {
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 324);
    *(_DWORD *)(a1 + 252) = **(_DWORD **)(a1 + 796);
    *(_DWORD *)(a1 + 248) |= 0x800u;
    *(_DWORD *)(a1 + 84) = (int)((long double)(int)level[123] + *(float *)(a1 + 652) * 1000.0);
    *(float *)(a1 + 216) = (float)*(int *)(a1 + 640);
    trap_LinkEntity(a1);
  }
  result = a1;
  *(_DWORD *)(a1 + 524) = level[123] + 100;
  return result;
}
// 17844: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000919FD) --------------------------------------------------------
int __cdecl SP_script_vehicle_owner_icon(_DWORD *a1)
{
  int result; // eax

  a1[1] = 15;
  a1[132] = script_vehicle_owner_enable;
  result = level[123] + 100;
  a1[131] = result;
  return result;
}

//----- (00091A40) --------------------------------------------------------
void sub_91A40()
{
  ;
}

//----- (00091A44) --------------------------------------------------------
int __cdecl Com_BeginParseSession(char *src)
{
  char v2; // [esp+8h] [ebp-10h]

  if ( dword_F3BA0 == 15 )
    Com_Error(0, byte_A7B80, v2);
  ++dword_F3BA0;
  off_B337C = (char *)&unk_AED80 + 1116 * dword_F3BA0;
  *((_DWORD *)off_B337C + 256) = 1;
  *((_DWORD *)off_B337C + 257) = 0;
  *((_DWORD *)off_B337C + 258) = 1;
  *((_DWORD *)off_B337C + 259) = 0;
  return Q_strncpyz((char *)off_B337C + 1052, src, 64);
}
// 91A70: variable 'v2' is possibly undefined
// B337C: using guessed type void *off_B337C;
// F3BA0: using guessed type int dword_F3BA0;

//----- (00091AFF) --------------------------------------------------------
char *Com_EndParseSession()
{
  char *result; // eax
  char v1; // [esp+8h] [ebp-10h]

  if ( !dword_F3BA0 )
    Com_Error(0, byte_A7BC0, v1);
  --dword_F3BA0;
  result = (char *)&unk_AED80 + 1116 * dword_F3BA0;
  off_B337C = result;
  return result;
}
// 91B2B: variable 'v1' is possibly undefined
// B337C: using guessed type void *off_B337C;
// F3BA0: using guessed type int dword_F3BA0;

//----- (00091B58) --------------------------------------------------------
void *Com_ResetParseSessions()
{
  void *result; // eax

  dword_F3BA0 = 0;
  result = &unk_AED80;
  off_B337C = &unk_AED80;
  return result;
}
// B337C: using guessed type void *off_B337C;
// F3BA0: using guessed type int dword_F3BA0;

//----- (00091B90) --------------------------------------------------------
int __cdecl Com_SetSpaceDelimited(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_B337C + 258) = a1;
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (00091BB1) --------------------------------------------------------
int __cdecl Com_SetCSV(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_B337C + 259) = a1;
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (00091BD2) --------------------------------------------------------
int __cdecl Com_SetParseNegativeNumbers(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_B337C + 260) = a1;
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (00091BF3) --------------------------------------------------------
int Com_GetCurrentParseLine()
{
  return *((_DWORD *)off_B337C + 256);
}
// B337C: using guessed type void *off_B337C;

//----- (00091C11) --------------------------------------------------------
int Com_ScriptError(char *format, ...)
{
  char s[32012]; // [esp+20h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D2Ch] [ebp-Ch]
  va_list va; // [esp+7D44h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return Com_Error(1, byte_A7BE8, (_BYTE)off_B337C + 28);
}
// B337C: using guessed type void *off_B337C;

//----- (00091C90) --------------------------------------------------------
int Com_ScriptWarning(char *format, ...)
{
  char s[32012]; // [esp+10h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D1Ch] [ebp-Ch]
  va_list va; // [esp+7D34h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return Com_Printf("File %s, line %i: %s", (_BYTE)off_B337C + 28);
}
// B337C: using guessed type void *off_B337C;

//----- (00091D07) --------------------------------------------------------
int Com_UngetToken()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-4h]

  if ( *((_DWORD *)off_B337C + 257) )
    Com_ScriptError("UngetToken called twice", v1);
  *((_DWORD *)off_B337C + 257) = 1;
  result = dword_F3BA8;
  dword_F3BA4 = dword_F3BA8;
  return result;
}
// 91D31: variable 'v1' is possibly undefined
// B337C: using guessed type void *off_B337C;
// F3BA4: using guessed type int dword_F3BA4;
// F3BA8: using guessed type int dword_F3BA8;

//----- (00091D58) --------------------------------------------------------
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *((_DWORD *)off_B337C + 256);
  a2[1] = *a1;
  a2[2] = *((_DWORD *)off_B337C + 257);
  a2[3] = *((_DWORD *)off_B337C + 261);
  result = *((_DWORD *)off_B337C + 262);
  a2[4] = result;
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (00091DBC) --------------------------------------------------------
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *((_DWORD *)off_B337C + 256) = *a2;
  *a1 = a2[1];
  *((_DWORD *)off_B337C + 257) = a2[2];
  *((_DWORD *)off_B337C + 261) = a2[3];
  result = a2[4];
  *((_DWORD *)off_B337C + 262) = result;
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (00091E20) --------------------------------------------------------
_BYTE *__cdecl sub_91E20(_BYTE *a1, _DWORD *a2)
{
  int v4; // [esp+4h] [ebp-8h]

  while ( 1 )
  {
    v4 = (char)*a1;
    if ( v4 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v4 == 10 )
    {
      ++*((_DWORD *)off_B337C + 256);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}
// B337C: using guessed type void *off_B337C;

//----- (00091E84) --------------------------------------------------------
int __cdecl Com_Compress(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 == 13 || v3 == 10 )
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
      else if ( v3 == 47 && v5[1] == 47 )
      {
        while ( *v5 && *v5 != 10 )
          ++v5;
      }
      else if ( v3 == 47 && v5[1] == 42 )
      {
        while ( *v5 && (*v5 != 42 || v5[1] != 47) )
        {
          if ( *v5 == 10 )
          {
            *v4++ = 10;
            ++v2;
          }
          ++v5;
        }
        if ( *v5 )
          v5 += 2;
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}
// 91F84: conditional instruction was optimized away because of '%var_14.4==0'

//----- (00091FC0) --------------------------------------------------------
int Com_GetLastTokenPos()
{
  return dword_F3BA4;
}
// F3BA4: using guessed type int dword_F3BA4;

//----- (00091FD8) --------------------------------------------------------
void *__cdecl sub_91FD8(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+4h] [ebp-Ch]
  _BYTE *i; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]

  v4 = *a1;
  v6 = 0;
  *(_BYTE *)off_B337C = 0;
  if ( a2 )
  {
    while ( *v4 == 13 || *v4 == 10 )
      ++v4;
  }
  else if ( *v4 == 13 || *v4 == 10 )
  {
    return off_B337C;
  }
  dword_F3BA8 = dword_F3BA4;
  dword_F3BA4 = (int)v4;
  while ( *v4 && *v4 != 44 && *v4 != 10 )
  {
    if ( *v4 == 13 )
    {
      ++v4;
    }
    else if ( *v4 == 34 )
    {
      for ( i = v4 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v6 <= 1022 )
            *((_BYTE *)off_B337C + v6++) = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v6 <= 1022 )
          *((_BYTE *)off_B337C + v6++) = 34;
      }
      v4 = i + 1;
    }
    else
    {
      if ( v6 <= 1022 )
        *((_BYTE *)off_B337C + v6++) = *v4;
      ++v4;
    }
  }
  if ( *v4 )
  {
    if ( *v4 != 10 )
      ++v4;
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
  }
  *((_BYTE *)off_B337C + v6) = 0;
  return off_B337C;
}
// B337C: using guessed type void *off_B337C;
// F3BA4: using guessed type int dword_F3BA4;
// F3BA8: using guessed type int dword_F3BA8;

//----- (0009216A) --------------------------------------------------------
void *__cdecl sub_9216A(char **a1, int a2)
{
  char v3; // [esp+8h] [ebp-30h]
  void *v4; // [esp+14h] [ebp-24h]
  signed int j; // [esp+18h] [ebp-20h]
  signed int n; // [esp+1Ch] [ebp-1Ch]
  const char **i; // [esp+20h] [ebp-18h]
  char *v8; // [esp+24h] [ebp-14h]
  char *v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h] BYREF
  int v11; // [esp+2Ch] [ebp-Ch]
  char v12; // [esp+33h] [ebp-5h]

  v12 = 0;
  v10 = 0;
  if ( !a1 )
    Com_Error(0, byte_A7C2B, v3);
  v8 = *a1;
  v11 = 0;
  *(_BYTE *)off_B337C = 0;
  if ( v8 )
  {
    *((_DWORD *)off_B337C + 261) = *((_DWORD *)off_B337C + 256);
    *((_DWORD *)off_B337C + 262) = *a1;
    if ( *((_DWORD *)off_B337C + 259) )
    {
      v4 = sub_91FD8(a1, a2);
    }
    else
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v8 = sub_91E20(v8, &v10);
          if ( !v8 )
          {
            *a1 = 0;
            return off_B337C;
          }
          if ( v10 && !a2 )
          {
            *a1 = v8;
            return off_B337C;
          }
          v12 = *v8;
          if ( v12 != 47 || v8[1] != 47 )
            break;
          while ( *v8 && *v8 != 10 )
            ++v8;
        }
        if ( v12 != 47 || v8[1] != 42 )
          break;
        while ( *v8 && (*v8 != 42 || v8[1] != 47) )
        {
          if ( *v8 == 10 )
            ++*((_DWORD *)off_B337C + 256);
          ++v8;
        }
        if ( *v8 )
          v8 += 2;
      }
      dword_F3BA8 = dword_F3BA4;
      dword_F3BA4 = (int)v8;
      if ( v12 == 34 )
      {
        v9 = v8 + 1;
        while ( 1 )
        {
          v12 = *v9++;
          if ( v12 == 92 && *v9 == 34 )
          {
            v12 = *v9++;
          }
          else
          {
            if ( v12 == 34 || !v12 )
            {
              *((_BYTE *)off_B337C + v11) = 0;
              *a1 = v9;
              return off_B337C;
            }
            if ( *v9 == 10 )
              ++*((_DWORD *)off_B337C + 256);
          }
          if ( v11 <= 1022 )
            *((_BYTE *)off_B337C + v11++) = v12;
        }
      }
      if ( *((_DWORD *)off_B337C + 258) )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_B337C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 32 );
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_B337C + v11) = 0;
        *a1 = v8;
        v4 = off_B337C;
      }
      else if ( v12 > 47 && v12 <= 57
             || *((_DWORD *)off_B337C + 260) && v12 == 45 && v8[1] > 47 && v8[1] <= 57
             || v12 == 46 && v8[1] > 47 && v8[1] <= 57 )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_B337C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 47 && v12 <= 57 || v12 == 46 );
        if ( v12 == 101 || v12 == 69 )
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_B337C + v11++) = v12;
          v12 = *++v8;
          if ( v12 == 45 || v12 == 43 )
          {
            if ( v11 <= 1022 )
              *((_BYTE *)off_B337C + v11++) = v12;
            v12 = *++v8;
          }
          do
          {
            if ( v11 <= 1022 )
              *((_BYTE *)off_B337C + v11++) = v12;
            v12 = *++v8;
          }
          while ( v12 > 47 && v12 <= 57 );
        }
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_B337C + v11) = 0;
        *a1 = v8;
        v4 = off_B337C;
      }
      else if ( v12 > 96 && v12 <= 122 || v12 > 64 && v12 <= 90 || v12 == 95 || v12 == 47 || v12 == 92 )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_B337C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 96 && v12 <= 122
             || v12 > 64 && v12 <= 90
             || v12 == 95
             || v12 > 47 && v12 <= 57
             || v12 == 47
             || v12 == 92
             || v12 == 58
             || v12 == 46 );
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_B337C + v11) = 0;
        *a1 = v8;
        v4 = off_B337C;
      }
      else
      {
        for ( i = (const char **)&off_B3340; ; ++i )
        {
          if ( !*i )
          {
            *(_BYTE *)off_B337C = *v8;
            *((_BYTE *)off_B337C + 1) = 0;
            *a1 = v8 + 1;
            return off_B337C;
          }
          n = strlen(*i);
          for ( j = 0; j < n && v8[j] == (*i)[j]; ++j )
            ;
          if ( j == n )
            break;
        }
        memcpy(off_B337C, *i, n);
        *((_BYTE *)off_B337C + n) = 0;
        *a1 = &v8[n];
        v4 = off_B337C;
      }
    }
  }
  else
  {
    *a1 = 0;
    v4 = off_B337C;
  }
  return v4;
}
// 9219E: variable 'v3' is possibly undefined
// B3340: using guessed type void *off_B3340;
// B337C: using guessed type void *off_B337C;
// F3BA4: using guessed type int dword_F3BA4;
// F3BA8: using guessed type int dword_F3BA8;

//----- (00092768) --------------------------------------------------------
void *__cdecl Com_Parse(char **a1)
{
  if ( *((_DWORD *)off_B337C + 257) )
  {
    *((_DWORD *)off_B337C + 257) = 0;
    *a1 = (char *)*((_DWORD *)off_B337C + 262);
    *((_DWORD *)off_B337C + 256) = *((_DWORD *)off_B337C + 261);
  }
  return sub_9216A(a1, 1);
}
// B337C: using guessed type void *off_B337C;

//----- (000927DB) --------------------------------------------------------
void *__cdecl Com_ParseOnLine(char **a1)
{
  if ( !*((_DWORD *)off_B337C + 257) )
    return sub_9216A(a1, 0);
  *((_DWORD *)off_B337C + 257) = 0;
  if ( *((_DWORD *)off_B337C + 258) )
  {
    *a1 = (char *)*((_DWORD *)off_B337C + 262);
    *((_DWORD *)off_B337C + 256) = *((_DWORD *)off_B337C + 261);
    return sub_9216A(a1, 0);
  }
  return off_B337C;
}
// B337C: using guessed type void *off_B337C;

//----- (0009286E) --------------------------------------------------------
int __cdecl Com_MatchToken(int a1, char *s2, int a3)
{
  int result; // eax
  char *s1; // [esp+10h] [ebp-8h]

  s1 = (char *)Com_Parse(a1);
  result = strcmp(s1, s2);
  if ( result )
  {
    if ( a3 )
      result = Com_ScriptWarning("MatchToken: %s != %s", (char)s1);
    else
      result = Com_ScriptError("MatchToken: %s != %s", (char)s1);
  }
  return result;
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (000928EA) --------------------------------------------------------
int __cdecl Com_SkipBracedSection(_DWORD *a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  _BYTE *v5; // [esp+10h] [ebp-8h]

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = (_BYTE *)Com_Parse(a1);
    if ( !v5[1] )
    {
      if ( *v5 == 123 )
      {
        if ( v4 == a2 )
          v3 = 1;
        else
          ++v4;
      }
      else if ( *v5 == 125 )
      {
        --v4;
      }
    }
  }
  while ( v4 && *a1 );
  return v3;
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (00092965) --------------------------------------------------------
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1)
{
  _BYTE *result; // eax
  int v2; // [esp+0h] [ebp-Ch]
  _BYTE *v3; // [esp+4h] [ebp-8h]

  result = (_BYTE *)*a1;
  v3 = (_BYTE *)*a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = (char)*v3;
      if ( !*v3 )
        break;
      ++v3;
      if ( v2 == 10 )
      {
        ++*((_DWORD *)off_B337C + 256);
        break;
      }
    }
    result = v3;
    *a1 = v3;
  }
  return result;
}
// B337C: using guessed type void *off_B337C;

//----- (000929BF) --------------------------------------------------------
char *__cdecl Com_ParseRestOfLine(int a1)
{
  char *src; // [esp+10h] [ebp-8h]

  for ( byte_F37A0 = 0; ; Q_strcat(&byte_F37A0, 1024, src) )
  {
    src = (char *)Com_ParseOnLine(a1);
    if ( !*src )
      break;
    if ( byte_F37A0 )
      Q_strcat(&byte_F37A0, 1024, " ");
  }
  return &byte_F37A0;
}
// 19654: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// F37A0: using guessed type char byte_F37A0;

//----- (00092A44) --------------------------------------------------------
long double __cdecl Com_ParseFloat(int a1)
{
  char *nptr; // [esp+10h] [ebp-8h]

  nptr = (char *)Com_Parse(a1);
  if ( !*nptr )
    return 0.0;
  return (float)atof(nptr);
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (00092A94) --------------------------------------------------------
int __cdecl Com_ParseInt(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  char *nptr; // [esp+10h] [ebp-8h]

  nptr = (char *)Com_Parse(a1);
  if ( *nptr )
    v2 = atoi(nptr);
  else
    v2 = 0;
  return v2;
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (00092ADC) --------------------------------------------------------
int __cdecl Com_Parse1DMatrix(int a1, int a2, int a3)
{
  int i; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]

  Com_MatchToken(a1, (char *)&off_A7C64, 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = (char *)Com_Parse(a1);
    *(float *)(a3 + 4 * i) = atof(nptr);
  }
  return Com_MatchToken(a1, (char *)&off_A7C64 + 2, 0);
}
// 16A84: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// A7C64: using guessed type void *off_A7C64;

//----- (00092B73) --------------------------------------------------------
int __cdecl Com_Parse2DMatrix(int a1, int a2, int a3, int a4)
{
  int i; // [esp+10h] [ebp-8h]

  Com_MatchToken(a1, (char *)&off_A7C64, 0);
  for ( i = 0; i < a2; ++i )
    Com_Parse1DMatrix(a1, a3, a4 + 4 * a3 * i);
  return Com_MatchToken(a1, (char *)&off_A7C64 + 2, 0);
}
// 17124: using guessed type _DWORD __cdecl Com_Parse1DMatrix(_DWORD, _DWORD, _DWORD);
// A7C64: using guessed type void *off_A7C64;

//----- (00092C00) --------------------------------------------------------
int __cdecl Com_Parse3DMatrix(int a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+10h] [ebp-8h]

  Com_MatchToken(a1, (char *)&off_A7C64, 0);
  for ( i = 0; i < a2; ++i )
    Com_Parse2DMatrix(a1, a3, a4, a5 + 4 * a3 * a4 * i);
  return Com_MatchToken(a1, (char *)&off_A7C64 + 2, 0);
}
// 19684: using guessed type _DWORD __cdecl Com_Parse2DMatrix(_DWORD, _DWORD, _DWORD, _DWORD);
// A7C64: using guessed type void *off_A7C64;

//----- (00092C98) --------------------------------------------------------
void sub_92C98()
{
  ;
}

//----- (00092C9C) --------------------------------------------------------
int __cdecl ColorIndex(char a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( (unsigned __int8)(a1 - 48) > 9u )
    v2 = 7;
  else
    v2 = (unsigned __int8)(a1 - 48);
  return v2;
}

//----- (00092CCC) --------------------------------------------------------
long double __cdecl Com_Clamp(float a1, float a2, float a3)
{
  if ( a1 > (long double)a3 )
    return a1;
  if ( a3 <= (long double)a2 )
    return a3;
  return a2;
}

//----- (00092D0D) --------------------------------------------------------
_BYTE *__cdecl Com_SkipPath(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = a1 + 1;
    ++a1;
  }
  return v2;
}

//----- (00092D3C) --------------------------------------------------------
_BYTE *__cdecl Com_StripExtension(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax

  while ( *a1 && *a1 != 46 )
    *a2++ = *a1++;
  result = a2;
  *a2 = 0;
  return result;
}

//----- (00092D71) --------------------------------------------------------
_BYTE *__cdecl Com_StripFilename(char *s, char *dest)
{
  int v2; // eax
  _BYTE *result; // eax

  v2 = strlen(s);
  Q_strncpyz(dest, s, v2);
  result = (_BYTE *)Com_SkipPath(dest);
  *result = 0;
  return result;
}
// 17414: using guessed type _DWORD __cdecl Com_SkipPath(_DWORD);

//----- (00092DBE) --------------------------------------------------------
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest[72]; // [esp+30h] [ebp-48h] BYREF

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  Q_strncpyz(dest, s, 64);
  return (char *)Com_sprintf(s, maxlen, "%s%s", (char)dest);
}

//----- (00092E4F) --------------------------------------------------------
int __cdecl Com_BitCheck(int a1, int a2)
{
  return (*(int *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (00092E72) --------------------------------------------------------
int __cdecl Com_BitSet(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) | (1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (00092EB6) --------------------------------------------------------
int __cdecl Com_BitClear(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) & ~(1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (00092EF4) --------------------------------------------------------
int __cdecl BigShort(__int16 a1)
{
  return (__int16)dword_107640(a1);
}
// 107640: using guessed type int (__cdecl *dword_107640)(_DWORD);

//----- (00092F23) --------------------------------------------------------
int __cdecl BigLong(int a1)
{
  return dword_107648(a1);
}
// 107648: using guessed type int (__cdecl *dword_107648)(_DWORD);

//----- (00092F49) --------------------------------------------------------
int __userpurge BigLong64@<eax>(int a1, int a2, int a3)
{
  dword_107650(a1, a2, a3);
  return a1;
}
// 107650: using guessed type int (__cdecl *dword_107650)(_DWORD, _DWORD, _DWORD);

//----- (00092F92) --------------------------------------------------------
int __userpurge LittleLong64@<eax>(int a1, int a2, int a3)
{
  dword_107654(a1, a2, a3);
  return a1;
}
// 107654: using guessed type int (__cdecl *dword_107654)(_DWORD, _DWORD, _DWORD);

//----- (00092FDB) --------------------------------------------------------
int __cdecl BigFloat(int a1)
{
  return dword_107658(a1);
}
// 107658: using guessed type int (__cdecl *dword_107658)(_DWORD);

//----- (00093001) --------------------------------------------------------
int __cdecl ShortSwap(__int16 a1)
{
  return (__int16)(((unsigned __int8)a1 << 8) + HIBYTE(a1));
}

//----- (00093038) --------------------------------------------------------
int __cdecl ShortNoSwap(__int16 a1)
{
  return a1;
}

//----- (0009304B) --------------------------------------------------------
int __cdecl LongSwap(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + ((unsigned __int8)a1 << 24);
}

//----- (000930A7) --------------------------------------------------------
int __cdecl LongNoSwap(int a1)
{
  return a1;
}

//----- (000930AF) --------------------------------------------------------
_DWORD *__userpurge Long64Swap@<eax>(_DWORD *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  LOBYTE(v4) = HIBYTE(a3);
  BYTE1(v4) = BYTE2(a3);
  BYTE2(v4) = BYTE1(a3);
  HIBYTE(v4) = a3;
  LOBYTE(v5) = HIBYTE(a2);
  BYTE1(v5) = BYTE2(a2);
  BYTE2(v5) = BYTE1(a2);
  HIBYTE(v5) = a2;
  *a1 = v4;
  a1[1] = v5;
  return a1;
}

//----- (0009310D) --------------------------------------------------------
_DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (00093131) --------------------------------------------------------
long double __cdecl FloatSwap(int a1)
{
  float v2; // [esp+4h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (00093164) --------------------------------------------------------
long double __cdecl FloatNoSwap(float a1)
{
  return a1;
}

//----- (00093175) --------------------------------------------------------
long double (__cdecl *Swap_Init())(float a1)
{
  long double (__cdecl *result)(float); // eax

  dword_107640 = (int (__cdecl *)(_DWORD))ShortSwap;
  dword_107644 = (int)ShortNoSwap;
  dword_107648 = LongSwap;
  dword_10764C = (int)LongNoSwap;
  dword_107650 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))Long64Swap;
  dword_107654 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))Long64NoSwap;
  dword_107658 = (int (__cdecl *)(_DWORD))FloatSwap;
  result = FloatNoSwap;
  dword_10765C = (int)FloatNoSwap;
  return result;
}
// 107640: using guessed type int (__cdecl *dword_107640)(_DWORD);
// 107644: using guessed type int dword_107644;
// 107648: using guessed type int (__cdecl *dword_107648)(_DWORD);
// 10764C: using guessed type int dword_10764C;
// 107650: using guessed type int (__cdecl *dword_107650)(_DWORD, _DWORD, _DWORD);
// 107654: using guessed type int (__cdecl *dword_107654)(_DWORD, _DWORD, _DWORD);
// 107658: using guessed type int (__cdecl *dword_107658)(_DWORD);
// 10765C: using guessed type int dword_10765C;

//----- (0009325E) --------------------------------------------------------
_BOOL4 __cdecl Q_isprint(int a1)
{
  return a1 > 31 && a1 <= 126;
}

//----- (00093285) --------------------------------------------------------
_BOOL4 __cdecl Q_islower(int a1)
{
  return a1 > 96 && a1 <= 122;
}

//----- (000932AC) --------------------------------------------------------
_BOOL4 __cdecl Q_isupper(int a1)
{
  return a1 > 64 && a1 <= 90;
}

//----- (000932D3) --------------------------------------------------------
_BOOL4 __cdecl Q_isalpha(int a1)
{
  return a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90;
}

//----- (00093308) --------------------------------------------------------
_BOOL4 __cdecl Q_isnumeric(int a1)
{
  return a1 > 47 && a1 <= 57;
}

//----- (0009332F) --------------------------------------------------------
_BOOL4 __cdecl Q_isalphanumeric(int a1)
{
  return Q_isalpha(a1) || Q_isnumeric(a1);
}
// 17724: using guessed type _DWORD __cdecl Q_isnumeric(_DWORD);
// 178A4: using guessed type _DWORD __cdecl Q_isalpha(_DWORD);

//----- (0009337A) --------------------------------------------------------
_BOOL4 __cdecl Q_isforfilename(int a1)
{
  return (Q_isalphanumeric(a1) || a1 == 95 || a1 == 45) && a1 != 32;
}
// 16884: using guessed type _DWORD __cdecl Q_isalphanumeric(_DWORD);

//----- (000933C8) --------------------------------------------------------
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2)
{
  _BYTE *v3; // [esp+0h] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    if ( *a1 == a2 )
      v3 = a1;
    ++a1;
  }
  if ( !a2 )
    v3 = a1;
  return v3;
}

//----- (00093415) --------------------------------------------------------
char *__cdecl Q_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (00093451) --------------------------------------------------------
int __cdecl Q_stricmpn(char *a1, char *a2, int a3)
{
  int v4; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( Q_islower(v7) )
        v7 -= 32;
      if ( Q_islower(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}
// 17DC4: using guessed type _DWORD __cdecl Q_islower(_DWORD);

//----- (00093506) --------------------------------------------------------
int __cdecl Q_strncmp(char *a1, char *a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (00093575) --------------------------------------------------------
int __cdecl Q_stricmp(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( a1 && a2 )
    v3 = Q_stricmpn(a1, a2, sub_1869F);
  else
    v3 = -1;
  return v3;
}
// 1869F: using guessed type int sub_1869F();
// 18A94: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);

//----- (000935C2) --------------------------------------------------------
_BYTE *__cdecl Q_strlwr(_BYTE *a1)
{
  _BYTE *i; // [esp+Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
    *i = tolower((char)*i);
  return a1;
}

//----- (00093609) --------------------------------------------------------
_BYTE *__cdecl Q_strupr(_BYTE *a1)
{
  _BYTE *i; // [esp+Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
    *i = toupper((char)*i);
  return a1;
}

//----- (00093650) --------------------------------------------------------
int __cdecl Q_strcat(char *s, int a2, char *src)
{
  char v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+10h] [ebp-8h]

  v5 = strlen(s);
  if ( v5 >= a2 )
    Com_Error(0, byte_A7DB5, v4);
  return Q_strncpyz(&s[v5], src, a2 - v5);
}
// 93689: variable 'v4' is possibly undefined

//----- (000936B5) --------------------------------------------------------
int __cdecl Q_DrawStrlen(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
  {
    if ( a1 && *a1 == 94 && a1[1] && a1[1] != 94 && (char)a1[1] > 47 && (char)a1[1] <= 57 )
    {
      a1 += 2;
    }
    else
    {
      ++v2;
      ++a1;
    }
  }
  return v2;
}

//----- (0009371D) --------------------------------------------------------
char *__cdecl Q_CleanStr(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (000937A5) --------------------------------------------------------
int __cdecl Q_CleanCharacter(char a1)
{
  if ( (unsigned __int8)a1 == 146 )
    return 39;
  if ( a1 >= 0 )
    return a1;
  return 46;
}

//----- (000937E5) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+3Ch] [ebp+14h] BYREF

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (00093833) --------------------------------------------------------
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3)
{
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  do
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v6 != v5 )
    {
      if ( Q_islower(v6) )
        v6 -= 32;
      if ( Q_islower(v5) )
        v5 -= 32;
      if ( v6 != v5 )
        return -1;
    }
  }
  while ( v6 );
  return 0;
}
// 17DC4: using guessed type _DWORD __cdecl Q_islower(_DWORD);

//----- (000938CD) --------------------------------------------------------
int __cdecl Q_strcasecmp(int a1, int a2)
{
  return Q_strncasecmp(a1, a2, sub_1869F);
}
// 17B14: using guessed type _DWORD __cdecl Q_strncasecmp(_DWORD, _DWORD, _DWORD);
// 1869F: using guessed type int sub_1869F();

//----- (000938FF) --------------------------------------------------------
char *va(char *format, ...)
{
  char v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+18h] [ebp-10h]
  char *dest; // [esp+1Ch] [ebp-Ch]
  va_list v5; // [esp+34h] [ebp+Ch] BYREF

  va_start(v5, format);
  v3 = vsnprintf(byte_F3C40, 0x7D00u, format, v5);
  byte_FB93F = 0;
  if ( v3 < 0 || v3 > 31999 )
    Com_Error(1, byte_A7DE0, v2);
  if ( v3 + dword_B3380 > 31998 )
    dword_B3380 = 0;
  dest = (char *)&unk_FB940 + dword_B3380;
  memcpy((char *)&unk_FB940 + dword_B3380, byte_F3C40, v3 + 1);
  dword_B3380 += v3 + 1;
  return dest;
}
// 93967: variable 'v2' is possibly undefined
// B3380: using guessed type int dword_B3380;
// FB93F: using guessed type char byte_FB93F;

//----- (000939CB) --------------------------------------------------------
_DWORD *__cdecl tv(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+0h] [ebp-8h]

  v4 = (_DWORD *)((char *)&unk_F3BE0 + 12 * dword_F3BC0);
  dword_F3BC0 = ((_BYTE)dword_F3BC0 + 1) & 7;
  *v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  return v4;
}
// F3BC0: using guessed type int dword_F3BC0;

//----- (00093A32) --------------------------------------------------------
char *__cdecl Info_ValueForKey(char *s, int a2)
{
  char v3; // [esp+8h] [ebp-2020h]
  char *v5; // [esp+1Ch] [ebp-200Ch]
  _BYTE *v6; // [esp+1Ch] [ebp-200Ch]
  char v7[8200]; // [esp+20h] [ebp-2008h] BYREF
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return (char *)&unk_A7E0E;
  if ( strlen(s) > 0x1FFF )
    Com_Error(1, byte_A7E20, v3);
  dword_B3384 ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v5 = v7;
    while ( *s != 92 )
    {
      if ( !*s )
        return (char *)&unk_A7E0E;
      *v5++ = *s++;
    }
    *v5 = 0;
    sa = s + 1;
    v6 = (char *)&unk_103640 + 0x2000 * dword_B3384;
    while ( *sa != 92 && *sa )
      *v6++ = *sa++;
    *v6 = 0;
    if ( !Q_stricmp(a2, v7) )
      return (char *)&unk_103640 + 0x2000 * dword_B3384;
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return (char *)&unk_A7E0E;
}
// 93A87: variable 'v3' is possibly undefined
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// B3384: using guessed type int dword_B3384;

//----- (00093BAA) --------------------------------------------------------
_BYTE *__cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // [esp+0h] [ebp-8h]
  _BYTE *v5; // [esp+0h] [ebp-8h]
  _BYTE *v6; // [esp+4h] [ebp-4h]
  _BYTE *v7; // [esp+4h] [ebp-4h]

  v4 = *a1;
  if ( **a1 == 92 )
    ++v4;
  *a2 = 0;
  *a3 = 0;
  v6 = a2;
  while ( *v4 != 92 )
  {
    if ( !*v4 )
    {
      *v6 = 0;
      result = v4;
      *a1 = v4;
      return result;
    }
    *v6++ = *v4++;
  }
  *v6 = 0;
  v5 = v4 + 1;
  v7 = a3;
  while ( *v5 != 92 && *v5 )
    *v7++ = *v5++;
  *v7 = 0;
  result = v5;
  *a1 = v5;
  return result;
}

//----- (00093C5E) --------------------------------------------------------
char *__cdecl Info_RemoveKey(char *s, char *s1)
{
  char *result; // eax
  char v3; // [esp+8h] [ebp-830h]
  char *v4; // [esp+1Ch] [ebp-81Ch]
  char *v5; // [esp+1Ch] [ebp-81Ch]
  char v6; // [esp+20h] [ebp-818h] BYREF
  char s2[1036]; // [esp+420h] [ebp-418h] BYREF
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    Com_Error(1, byte_A7E60, v3);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v4 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      ++s;
      v5 = &v6;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v5++ = *s++;
      }
      *v5 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}
// 93C96: variable 'v3' is possibly undefined

//----- (00093DA5) --------------------------------------------------------
char *__cdecl Info_RemoveKey_Big(char *s, char *s1)
{
  char *result; // eax
  char v3; // [esp+8h] [ebp-4030h]
  char *v4; // [esp+1Ch] [ebp-401Ch]
  char *v5; // [esp+1Ch] [ebp-401Ch]
  char v6; // [esp+20h] [ebp-4018h] BYREF
  char s2[8204]; // [esp+2020h] [ebp-2018h] BYREF
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    Com_Error(1, byte_A7EA0, v3);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v4 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      ++s;
      v5 = &v6;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v5++ = *s++;
      }
      *v5 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}
// 93DDD: variable 'v3' is possibly undefined

//----- (00093EEC) --------------------------------------------------------
_BOOL4 __cdecl Info_Validate(char *s)
{
  _BOOL4 v2; // [esp+10h] [ebp-8h]

  if ( strchr(s, 34) )
    v2 = 0;
  else
    v2 = strchr(s, 59) == 0;
  return v2;
}

//----- (00093F4E) --------------------------------------------------------
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // esi
  char v5; // [esp+4h] [ebp-834h]
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+23h] [ebp-815h]
  int v8; // [esp+28h] [ebp-810h]
  int i; // [esp+2Ch] [ebp-80Ch]
  char v10[1024]; // [esp+30h] [ebp-808h] BYREF
  char src[1032]; // [esp+430h] [ebp-408h] BYREF

  if ( strlen(s) > 0x3FF )
    return (char *)Com_Printf(byte_A7EE0, v5);
  v8 = 0;
  for ( i = 0; i <= 1022; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf(byte_A7F20, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf((char *)&dword_A7F60, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf(byte_A7FA0, (char)s1);
  result = (char *)Info_RemoveKey(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x400u, "\\%s\\%s", (char)s1) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x400 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf(byte_A8040, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf(byte_A7FE0, v6);
    }
  }
  return result;
}
// 93F7F: variable 'v5' is possibly undefined
// 9412C: variable 'v6' is possibly undefined
// A7F60: using guessed type int dword_A7F60;

//----- (0009419C) --------------------------------------------------------
char *__cdecl Info_SetValueForKey_Big(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // esi
  char v5; // [esp+4h] [ebp-4034h]
  char v6; // [esp+4h] [ebp-4034h]
  char v7; // [esp+23h] [ebp-4015h]
  int v8; // [esp+28h] [ebp-4010h]
  int i; // [esp+2Ch] [ebp-400Ch]
  char v10[8192]; // [esp+30h] [ebp-4008h] BYREF
  char src[8200]; // [esp+2030h] [ebp-2008h] BYREF

  if ( strlen(s) > 0x1FFF )
    return (char *)Com_Printf(byte_A7EE0, v5);
  v8 = 0;
  for ( i = 0; i <= 8190; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf(byte_A7F20, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf((char *)&dword_A7F60, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf(byte_A7FA0, (char)s1);
  result = (char *)Info_RemoveKey_Big(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x2000u, "\\%s\\%s", (char)s1) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x2000 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf(byte_A80A0, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf(byte_A7FE0, v6);
    }
  }
  return result;
}
// 941CD: variable 'v5' is possibly undefined
// 9437A: variable 'v6' is possibly undefined
// A7F60: using guessed type int dword_A7F60;

//----- (000943EA) --------------------------------------------------------
_BOOL4 __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, char *s, int a5, int a6, int a7)
{
  _DWORD *v7; // esi
  float *v8; // esi
  _DWORD *v9; // esi
  float v12; // [esp+20h] [ebp-18h]
  char *nptr; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; i < a3; ++i )
  {
    nptr = (char *)Info_ValueForKey(s, *(_DWORD *)a2);
    if ( *nptr )
    {
      if ( *(int *)(a2 + 8) > 7 )
      {
        if ( a5 <= 0 || *(_DWORD *)(a2 + 8) >= a5 )
        {
          Com_Error(1, byte_A80E8, *(_DWORD *)(a2 + 8));
        }
        else if ( !((int (__cdecl *)(int, char *, _DWORD))a6)(a1, nptr, *(_DWORD *)(a2 + 8)) )
        {
          return 0;
        }
      }
      else
      {
        switch ( *(_DWORD *)(a2 + 8) )
        {
          case 0:
            ((void (__cdecl *)(int, char *))a7)(a1 + *(_DWORD *)(a2 + 4), nptr);
            break;
          case 1:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 1024);
            break;
          case 2:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 64);
            break;
          case 3:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 256);
            break;
          case 4:
            *(_DWORD *)(a1 + *(_DWORD *)(a2 + 4)) = atoi(nptr);
            break;
          case 5:
            v7 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            *v7 = atoi(nptr) != 0;
            break;
          case 6:
            v8 = (float *)(*(_DWORD *)(a2 + 4) + a1);
            *v8 = atof(nptr);
            break;
          case 7:
            v9 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            v12 = atof(nptr);
            *v9 = (int)(v12 * 1000.0);
            break;
          default:
            break;
        }
      }
    }
    a2 += 12;
  }
  return i == a3;
}

//----- (00094623) --------------------------------------------------------
long double __cdecl GetLeanFraction(float a1)
{
  return (2.0 - sub_94A75(a1)) * a1;
}

//----- (00094651) --------------------------------------------------------
long double __cdecl UnGetLeanFraction(float a1)
{
  float v2; // [esp+10h] [ebp-8h]

  v2 = sqrt(1.0 - a1);
  return 1.0 - v2;
}

//----- (00094688) --------------------------------------------------------
void __cdecl AddLeanToPosition(int a1, int a2, float a3, float a4, float a5)
{
  int v5[4]; // [esp+10h] [ebp-38h] BYREF
  float v6[7]; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    GetLeanFraction(a3);
    v7 = 0.0;
    v5[0] = 0;
    v5[1] = a2;
    *(float *)&v5[2] = (float)0.0 * a4;
    AngleVectors(v5, 0, v6, 0);
    v7 = v7 * a5;
    *(float *)a1 = v6[0] * v7 + *(float *)a1;
    *(float *)(a1 + 4) = v6[1] * v7 + *(float *)(a1 + 4);
    *(float *)(a1 + 8) = v6[2] * v7 + *(float *)(a1 + 8);
  }
}
// 175B4: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0009474A) --------------------------------------------------------
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + *a1 + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a1[1] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a1[2] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (000947F8) --------------------------------------------------------
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (00094893) --------------------------------------------------------
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  *a3 = v4 * a1[3] + v5 * a1[4] + v6 * a1[5];
  a3[1] = v4 * a1[6] + v5 * a1[7] + v6 * a1[8];
  result = a1;
  a3[2] = v4 * a1[9] + v5 * a1[10] + v6 * a1[11];
  return result;
}

//----- (0009493C) --------------------------------------------------------
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[4] + a2[2] * a1[5];
  a3[1] = *a2 * a1[6] + a2[1] * a1[7] + a2[2] * a1[8];
  result = a2 + 2;
  a3[2] = *a2 * a1[9] + a2[1] * a1[10] + a2[2] * a1[11];
  return result;
}

//----- (000949D7) --------------------------------------------------------
int Q_GetDecimalDelimiter()
{
  return 46;
}

//----- (000949E1) --------------------------------------------------------
int __cdecl Q_LocalizedFloatToString(float a1, char *s, int a3, int a4, int a5)
{
  int result; // eax
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]
  unsigned int i; // [esp+20h] [ebp-8h]

  snprintf(s, a3 - 1, "%.*f", a4, a1);
  s[a3 - 1] = 0;
  result = Q_GetDecimalDelimiter(a5);
  v6 = result;
  if ( (_BYTE)result != 46 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      if ( s[i] == 46 )
      {
        result = v6;
        s[i] = v6;
        return result;
      }
    }
  }
  return result;
}
// 19114: using guessed type int __cdecl Q_GetDecimalDelimiter(_DWORD);

//----- (00094A75) --------------------------------------------------------
long double __cdecl sub_94A75(float a1)
{
  return (float)fabs(a1);
}

//----- (00094A8E) --------------------------------------------------------
void sub_94A8E()
{
  ;
}

//----- (00094A94) --------------------------------------------------------
int __cdecl Scr_GetBool(int a1)
{
  return dword_107660(a1);
}
// 107660: using guessed type int (__cdecl *dword_107660)(_DWORD);

//----- (00094ABA) --------------------------------------------------------
int __cdecl Scr_GetInt(int a1)
{
  return dword_107664(a1);
}
// 107664: using guessed type int (__cdecl *dword_107664)(_DWORD);

//----- (00094AE0) --------------------------------------------------------
int __userpurge Scr_GetAnim@<eax>(int a1, int a2, int a3)
{
  dword_107668(a1, a2, a3);
  return a1;
}
// 107668: using guessed type int (__cdecl *dword_107668)(_DWORD, _DWORD, _DWORD);

//----- (00094B1D) --------------------------------------------------------
int __userpurge Scr_GetAnimTree@<eax>(int a1, int a2)
{
  dword_10766C(a1, a2);
  return a1;
}
// 10766C: using guessed type int (__cdecl *dword_10766C)(_DWORD, _DWORD);

//----- (00094B53) --------------------------------------------------------
int __cdecl Scr_GetFloat(int a1)
{
  return dword_107670(a1);
}
// 107670: using guessed type int (__cdecl *dword_107670)(_DWORD);

//----- (00094B79) --------------------------------------------------------
int __cdecl Scr_GetString(int a1)
{
  return dword_107674(a1);
}
// 107674: using guessed type int (__cdecl *dword_107674)(_DWORD);

//----- (00094B9F) --------------------------------------------------------
int __cdecl Scr_GetConstString(int a1)
{
  return (unsigned __int16)dword_107678(a1);
}
// 107678: using guessed type int (__cdecl *dword_107678)(_DWORD);

//----- (00094BC8) --------------------------------------------------------
int __cdecl Scr_GetDebugString(int a1)
{
  return dword_10767C(a1);
}
// 10767C: using guessed type int (__cdecl *dword_10767C)(_DWORD);

//----- (00094BEE) --------------------------------------------------------
int __cdecl Scr_GetIString(int a1)
{
  return dword_107680(a1);
}
// 107680: using guessed type int (__cdecl *dword_107680)(_DWORD);

//----- (00094C14) --------------------------------------------------------
int __cdecl Scr_GetConstIString(int a1)
{
  return (unsigned __int16)dword_107684(a1);
}
// 107684: using guessed type int (__cdecl *dword_107684)(_DWORD);

//----- (00094C3D) --------------------------------------------------------
int __cdecl Scr_GetVector(int a1, int a2)
{
  return dword_107688(a1, a2);
}
// 107688: using guessed type int (__cdecl *dword_107688)(_DWORD, _DWORD);

//----- (00094C6A) --------------------------------------------------------
int __cdecl Scr_GetFunc(int a1)
{
  return dword_10768C(a1);
}
// 10768C: using guessed type int (__cdecl *dword_10768C)(_DWORD);

//----- (00094C90) --------------------------------------------------------
int __cdecl Scr_GetEntityNum(int a1, int a2)
{
  return dword_107698(a1, a2);
}
// 107698: using guessed type int (__cdecl *dword_107698)(_DWORD, _DWORD);

//----- (00094CBD) --------------------------------------------------------
int __cdecl Scr_GetType(int a1)
{
  return dword_107690(a1);
}
// 107690: using guessed type int (__cdecl *dword_107690)(_DWORD);

//----- (00094CE3) --------------------------------------------------------
int __cdecl Scr_GetPointerType(int a1)
{
  return dword_107694(a1);
}
// 107694: using guessed type int (__cdecl *dword_107694)(_DWORD);

//----- (00094D09) --------------------------------------------------------
int Scr_GetNumParam()
{
  return dword_10769C();
}
// 10769C: using guessed type int (*dword_10769C)(void);

//----- (00094D29) --------------------------------------------------------
int __cdecl Scr_AddBool(int a1)
{
  return dword_1076A0(a1);
}
// 1076A0: using guessed type int (__cdecl *dword_1076A0)(_DWORD);

//----- (00094D4F) --------------------------------------------------------
int __cdecl Scr_AddInt(int a1)
{
  return dword_1076A4(a1);
}
// 1076A4: using guessed type int (__cdecl *dword_1076A4)(_DWORD);

//----- (00094D75) --------------------------------------------------------
int __cdecl Scr_AddFloat(int a1)
{
  return dword_1076A8(a1);
}
// 1076A8: using guessed type int (__cdecl *dword_1076A8)(_DWORD);

//----- (00094D9B) --------------------------------------------------------
int __cdecl Scr_AddAnim(int a1)
{
  return dword_1076AC(a1);
}
// 1076AC: using guessed type int (__cdecl *dword_1076AC)(_DWORD);

//----- (00094DC1) --------------------------------------------------------
int Scr_AddUndefined()
{
  return dword_1076B0();
}
// 1076B0: using guessed type int (*dword_1076B0)(void);

//----- (00094DE1) --------------------------------------------------------
int __cdecl Scr_AddEntityNum(int a1, int a2)
{
  return dword_1076B4(a1, a2);
}
// 1076B4: using guessed type int (__cdecl *dword_1076B4)(_DWORD, _DWORD);

//----- (00094E0E) --------------------------------------------------------
int Scr_AddStruct()
{
  return dword_1076B8();
}
// 1076B8: using guessed type int (*dword_1076B8)(void);

//----- (00094E2E) --------------------------------------------------------
int __cdecl Scr_AddString(int a1)
{
  return dword_1076BC(a1);
}
// 1076BC: using guessed type int (__cdecl *dword_1076BC)(_DWORD);

//----- (00094E54) --------------------------------------------------------
int __cdecl Scr_AddIString(int a1)
{
  return dword_1076C0(a1);
}
// 1076C0: using guessed type int (__cdecl *dword_1076C0)(_DWORD);

//----- (00094E7A) --------------------------------------------------------
int __cdecl Scr_AddConstString(unsigned __int16 a1)
{
  return dword_1076C4(a1);
}
// 1076C4: using guessed type int (__cdecl *dword_1076C4)(_DWORD);

//----- (00094EA8) --------------------------------------------------------
int __cdecl Scr_AddVector(int a1)
{
  return dword_1076C8(a1);
}
// 1076C8: using guessed type int (__cdecl *dword_1076C8)(_DWORD);

//----- (00094ECE) --------------------------------------------------------
int __cdecl Scr_AddObject(unsigned __int16 a1)
{
  return dword_1076CC(a1);
}
// 1076CC: using guessed type int (__cdecl *dword_1076CC)(_DWORD);

//----- (00094EFC) --------------------------------------------------------
int Scr_MakeArray()
{
  return dword_1076D8();
}
// 1076D8: using guessed type int (*dword_1076D8)(void);

//----- (00094F1C) --------------------------------------------------------
int Scr_AddArray()
{
  return dword_1076D0();
}
// 1076D0: using guessed type int (*dword_1076D0)(void);

//----- (00094F3C) --------------------------------------------------------
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1)
{
  return dword_1076D4(a1);
}
// 1076D4: using guessed type int (__cdecl *dword_1076D4)(_DWORD);

//----- (00094F6A) --------------------------------------------------------
int __cdecl Scr_Error(int a1)
{
  return dword_107714(a1);
}
// 107714: using guessed type int (__cdecl *dword_107714)(_DWORD);

//----- (00094F90) --------------------------------------------------------
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2)
{
  return dword_107718(a1, a2);
}
// 107718: using guessed type int (__cdecl *dword_107718)(_DWORD, _DWORD);

//----- (00094FBD) --------------------------------------------------------
int __cdecl Scr_ParamError(int a1, int a2)
{
  return dword_10771C(a1, a2);
}
// 10771C: using guessed type int (__cdecl *dword_10771C)(_DWORD, _DWORD);

//----- (00094FEA) --------------------------------------------------------
int __cdecl Scr_ObjectError(int a1)
{
  return dword_107720(a1);
}
// 107720: using guessed type int (__cdecl *dword_107720)(_DWORD);

//----- (00095010) --------------------------------------------------------
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3)
{
  return dword_107724(a1, a2, a3);
}
// 107724: using guessed type int (__cdecl *dword_107724)(_DWORD, _DWORD, _DWORD);

//----- (0009504C) --------------------------------------------------------
int __cdecl Scr_FreeEntityNum(int a1, int a2)
{
  return dword_107728(a1, a2);
}
// 107728: using guessed type int (__cdecl *dword_107728)(_DWORD, _DWORD);

//----- (00095079) --------------------------------------------------------
int __cdecl Scr_GetEntityId(int a1, int a2)
{
  return (unsigned __int16)dword_10772C(a1, a2);
}
// 10772C: using guessed type int (__cdecl *dword_10772C)(_DWORD, _DWORD);

//----- (000950A9) --------------------------------------------------------
int __cdecl Scr_SetClassMap(int a1, int a2)
{
  return dword_107730(a1, a2);
}
// 107730: using guessed type int (__cdecl *dword_107730)(_DWORD, _DWORD);

//----- (000950D6) --------------------------------------------------------
int Scr_RemoveClassMap()
{
  return dword_107734();
}
// 107734: using guessed type int (*dword_107734)(void);

//----- (000950F6) --------------------------------------------------------
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3)
{
  return dword_107740(a1, a2, a3);
}
// 107740: using guessed type int (__cdecl *dword_107740)(_DWORD, _DWORD, _DWORD);

//----- (0009513A) --------------------------------------------------------
int __cdecl Scr_AddFields(int a1, int a2)
{
  return dword_107744(a1, a2);
}
// 107744: using guessed type int (__cdecl *dword_107744)(_DWORD, _DWORD);

//----- (00095167) --------------------------------------------------------
int __cdecl Scr_FindField(int a1, int a2)
{
  return (unsigned __int16)dword_107748(a1, a2);
}
// 107748: using guessed type int (__cdecl *dword_107748)(_DWORD, _DWORD);

//----- (00095197) --------------------------------------------------------
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2)
{
  return dword_10774C(a1, a2);
}
// 10774C: using guessed type int (__cdecl *dword_10774C)(_DWORD, _DWORD);

//----- (000951CC) --------------------------------------------------------
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3)
{
  return dword_107750(a1, a2, a3);
}
// 107750: using guessed type int (__cdecl *dword_107750)(_DWORD, _DWORD, _DWORD);

//----- (00095200) --------------------------------------------------------
int __cdecl Scr_Init(int a1, int a2, int a3)
{
  return dword_107754(a1, a2, a3);
}
// 107754: using guessed type int (__cdecl *dword_107754)(_DWORD, _DWORD, _DWORD);

//----- (00095234) --------------------------------------------------------
int Scr_Shutdown()
{
  return dword_107758();
}
// 107758: using guessed type int (*dword_107758)(void);

//----- (00095254) --------------------------------------------------------
int Scr_Abort()
{
  return dword_10775C();
}
// 10775C: using guessed type int (*dword_10775C)(void);

//----- (00095274) --------------------------------------------------------
int __cdecl Scr_SetLoading(int a1)
{
  return dword_107760(a1);
}
// 107760: using guessed type int (__cdecl *dword_107760)(_DWORD);

//----- (0009529A) --------------------------------------------------------
int Scr_AllocGameVariable()
{
  return dword_107768();
}
// 107768: using guessed type int (*dword_107768)(void);

//----- (000952BA) --------------------------------------------------------
int __cdecl Scr_InitSystem(int a1, int a2)
{
  return dword_107764(a1, a2);
}
// 107764: using guessed type int (__cdecl *dword_107764)(_DWORD, _DWORD);

//----- (000952E7) --------------------------------------------------------
int __cdecl Scr_GetChecksum(int a1)
{
  return dword_10776C(a1);
}
// 10776C: using guessed type int (__cdecl *dword_10776C)(_DWORD);

//----- (0009530D) --------------------------------------------------------
int Scr_HasSourceFiles()
{
  return dword_107770();
}
// 107770: using guessed type int (*dword_107770)(void);

//----- (0009532D) --------------------------------------------------------
int __cdecl Scr_SaveSource(int a1)
{
  return dword_107774(a1);
}
// 107774: using guessed type int (__cdecl *dword_107774)(_DWORD);

//----- (00095353) --------------------------------------------------------
int __cdecl Scr_LoadSource(int a1)
{
  return dword_107778(a1);
}
// 107778: using guessed type int (__cdecl *dword_107778)(_DWORD);

//----- (00095379) --------------------------------------------------------
int __cdecl Scr_SkipSource(int a1)
{
  return dword_10777C(a1);
}
// 10777C: using guessed type int (__cdecl *dword_10777C)(_DWORD);

//----- (0009539F) --------------------------------------------------------
int __cdecl Scr_SavePre(int a1)
{
  return dword_107780(a1);
}
// 107780: using guessed type int (__cdecl *dword_107780)(_DWORD);

//----- (000953C5) --------------------------------------------------------
int __cdecl Scr_SavePost(int a1)
{
  return dword_107784(a1);
}
// 107784: using guessed type int (__cdecl *dword_107784)(_DWORD);

//----- (000953EB) --------------------------------------------------------
int Scr_SaveShutdown()
{
  return dword_107788();
}
// 107788: using guessed type int (*dword_107788)(void);

//----- (0009540B) --------------------------------------------------------
int __cdecl Scr_LoadPre(int a1, int a2)
{
  return dword_107790(a1, a2);
}
// 107790: using guessed type int (__cdecl *dword_107790)(_DWORD, _DWORD);

//----- (00095438) --------------------------------------------------------
int Scr_LoadShutdown()
{
  return dword_107794();
}
// 107794: using guessed type int (*dword_107794)(void);

//----- (00095458) --------------------------------------------------------
int __cdecl Scr_LoadScript(int a1)
{
  return dword_10779C(a1);
}
// 10779C: using guessed type int (__cdecl *dword_10779C)(_DWORD);

//----- (0009547E) --------------------------------------------------------
int __userpurge Scr_FindAnimTree@<eax>(int a1, int a2)
{
  dword_1077A0(a1, a2);
  return a1;
}
// 1077A0: using guessed type int (__cdecl *dword_1077A0)(_DWORD, _DWORD);

//----- (000954B4) --------------------------------------------------------
int __cdecl Scr_FindAnim(int a1, int a2, int a3)
{
  return dword_1077A4(a1, a2, a3);
}
// 1077A4: using guessed type int (__cdecl *dword_1077A4)(_DWORD, _DWORD, _DWORD);

//----- (000954E8) --------------------------------------------------------
int __cdecl Scr_GetFunctionHandle(int a1, int a2)
{
  return dword_1077A8(a1, a2);
}
// 1077A8: using guessed type int (__cdecl *dword_1077A8)(_DWORD, _DWORD);

//----- (00095515) --------------------------------------------------------
int Scr_BeginLoadScripts()
{
  return dword_1076DC();
}
// 1076DC: using guessed type int (*dword_1076DC)(void);

//----- (00095535) --------------------------------------------------------
int Scr_BeginLoadAnimTrees()
{
  return dword_1076E0();
}
// 1076E0: using guessed type int (*dword_1076E0)(void);

//----- (00095555) --------------------------------------------------------
int Scr_EndLoadScripts()
{
  return dword_1076E4();
}
// 1076E4: using guessed type int (*dword_1076E4)(void);

//----- (00095575) --------------------------------------------------------
int Scr_EndLoadAnimTrees()
{
  return dword_1076E8();
}
// 1076E8: using guessed type int (*dword_1076E8)(void);

//----- (00095595) --------------------------------------------------------
int __cdecl Scr_PrecacheAnimTrees(int a1)
{
  return dword_1076EC(a1);
}
// 1076EC: using guessed type int (__cdecl *dword_1076EC)(_DWORD);

//----- (000955BB) --------------------------------------------------------
int __cdecl Scr_FreeScripts(unsigned __int8 a1)
{
  return dword_1076F0(a1);
}
// 1076F0: using guessed type int (__cdecl *dword_1076F0)(_DWORD);

//----- (000955E8) --------------------------------------------------------
int __cdecl Scr_FreeGameVariable(int a1)
{
  return dword_1076F4(a1);
}
// 1076F4: using guessed type int (__cdecl *dword_1076F4)(_DWORD);

//----- (0009560E) --------------------------------------------------------
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1)
{
  return dword_1076F8(a1);
}
// 1076F8: using guessed type int (__cdecl *dword_1076F8)(_DWORD);

//----- (0009563B) --------------------------------------------------------
int __cdecl Scr_IsSystemActive(unsigned __int8 a1)
{
  return dword_1076FC(a1);
}
// 1076FC: using guessed type int (__cdecl *dword_1076FC)(_DWORD);

//----- (00095668) --------------------------------------------------------
int __cdecl Scr_ExecThread(int a1, int a2)
{
  return (unsigned __int16)dword_107708(a1, a2);
}
// 107708: using guessed type int (__cdecl *dword_107708)(_DWORD, _DWORD);

//----- (00095698) --------------------------------------------------------
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return (unsigned __int16)dword_10770C(a1, a2, a3, a4);
}
// 10770C: using guessed type int (__cdecl *dword_10770C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000956D6) --------------------------------------------------------
int __cdecl Scr_AddExecThread(int a1, int a2)
{
  return dword_107700(a1, a2);
}
// 107700: using guessed type int (__cdecl *dword_107700)(_DWORD, _DWORD);

//----- (00095703) --------------------------------------------------------
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return dword_107704(a1, a2, a3, a4);
}
// 107704: using guessed type int (__cdecl *dword_107704)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0009573E) --------------------------------------------------------
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1)
{
  return dword_107710(a1);
}
// 107710: using guessed type int (__cdecl *dword_107710)(_DWORD);

//----- (0009576C) --------------------------------------------------------
int __cdecl Scr_FreeThread(unsigned __int16 a1)
{
  return dword_1077AC(a1);
}
// 1077AC: using guessed type int (__cdecl *dword_1077AC)(_DWORD);

//----- (0009579A) --------------------------------------------------------
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1)
{
  return (unsigned __int16)dword_1077B0(a1);
}
// 1077B0: using guessed type int (__cdecl *dword_1077B0)(_DWORD);

//----- (000957CB) --------------------------------------------------------
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1)
{
  return (unsigned __int16)dword_1077B4(a1);
}
// 1077B4: using guessed type int (__cdecl *dword_1077B4)(_DWORD);

//----- (000957FC) --------------------------------------------------------
int __cdecl Scr_SetString(int a1, unsigned __int16 a2)
{
  return dword_1077B8(a1, a2);
}
// 1077B8: using guessed type int (__cdecl *dword_1077B8)(_DWORD, _DWORD);

//----- (00095831) --------------------------------------------------------
int __cdecl Scr_AllocString(int a1, int a2)
{
  return (unsigned __int16)dword_1077BC(a1, a2);
}
// 1077BC: using guessed type int (__cdecl *dword_1077BC)(_DWORD, _DWORD);

//----- (00095861) --------------------------------------------------------
int __cdecl Scr_SetTime(int a1)
{
  return dword_1077DC(a1);
}
// 1077DC: using guessed type int (__cdecl *dword_1077DC)(_DWORD);

//----- (00095887) --------------------------------------------------------
int Scr_RunCurrentThreads()
{
  return dword_1077E0();
}
// 1077E0: using guessed type int (*dword_1077E0)(void);

//----- (000958A7) --------------------------------------------------------
int Scr_ResetTimeout()
{
  return dword_1077E4();
}
// 1077E4: using guessed type int (*dword_1077E4)(void);

//----- (000958C7) --------------------------------------------------------
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4)
{
  return dword_1077C0(a1, a2, a3, a4);
}
// 1077C0: using guessed type int (__cdecl *dword_1077C0)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0009590A) --------------------------------------------------------
int __cdecl SL_ConvertToString(unsigned __int16 a1)
{
  return dword_1077C8(a1);
}
// 1077C8: using guessed type int (__cdecl *dword_1077C8)(_DWORD);

//----- (00095938) --------------------------------------------------------
int __cdecl SL_GetString(int a1, unsigned __int8 a2)
{
  return (unsigned __int16)dword_1077CC(a1, a2);
}
// 1077CC: using guessed type int (__cdecl *dword_1077CC)(_DWORD, _DWORD);

//----- (0009596F) --------------------------------------------------------
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2)
{
  return (unsigned __int16)dword_1077D0(a1, a2);
}
// 1077D0: using guessed type int (__cdecl *dword_1077D0)(_DWORD, _DWORD);

//----- (000959A6) --------------------------------------------------------
int __cdecl SL_FindLowercaseString(int a1)
{
  return (unsigned __int16)dword_1077D4(a1);
}
// 1077D4: using guessed type int (__cdecl *dword_1077D4)(_DWORD);

//----- (000959CF) --------------------------------------------------------
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3)
{
  return dword_1077C4(a1, a2, a3);
}
// 1077C4: using guessed type int (__cdecl *dword_1077C4)(_DWORD, _DWORD, _DWORD);

//----- (00095A13) --------------------------------------------------------
int __cdecl Scr_CreateCanonicalFilename(int a1)
{
  return (unsigned __int16)dword_1077D8(a1);
}
// 1077D8: using guessed type int (__cdecl *dword_1077D8)(_DWORD);

//----- (00095A3C) --------------------------------------------------------
int __cdecl Scr_GetAnimsIndex(int a1)
{
  return dword_1077E8(a1);
}
// 1077E8: using guessed type int (__cdecl *dword_1077E8)(_DWORD);

//----- (00095A62) --------------------------------------------------------
int __cdecl Scr_GetAnims(int a1)
{
  return dword_1077EC(a1);
}
// 1077EC: using guessed type int (__cdecl *dword_1077EC)(_DWORD);

//----- (00095A88) --------------------------------------------------------
int __cdecl MT_Alloc(int a1, int a2)
{
  return dword_1077F0(a1, a2);
}
// 1077F0: using guessed type int (__cdecl *dword_1077F0)(_DWORD, _DWORD);

//----- (00095AB5) --------------------------------------------------------
int __cdecl MT_Free(int a1, int a2)
{
  return dword_1077F4(a1, a2);
}
// 1077F4: using guessed type int (__cdecl *dword_1077F4)(_DWORD, _DWORD);

//----- (00095AE2) --------------------------------------------------------
int *__cdecl Scr_FarHook(int (__cdecl **a1)(_DWORD))
{
  unsigned int v2; // [esp+0h] [ebp-18h]
  const void *v3; // [esp+4h] [ebp-14h]
  int (__cdecl **v4)(_DWORD); // [esp+8h] [ebp-10h]

  if ( a1 )
  {
    v4 = &dword_107660;
    v3 = a1;
    v2 = 408;
    if ( (((unsigned __int8)(&dword_107660 - 183814) + (unsigned __int8)&GLOBAL_OFFSET_TABLE_) & 4) != 0 )
    {
      dword_107660 = *a1;
      v4 = &dword_107660 + 1;
      v3 = a1 + 1;
      v2 = 404;
    }
    qmemcpy(v4, v3, 4 * (v2 >> 2));
  }
  dword_1077F8 = (int)Scr_GetFunction;
  dword_1077FC = (int)Scr_GetMethod;
  dword_107800 = (int)Scr_SetObjectField;
  dword_107804 = (int)Scr_GetObjectField;
  dword_107808 = (int)Scr_LoadRead;
  return &dword_1077F8;
}
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// 107660: using guessed type int (__cdecl *dword_107660)(_DWORD);
// 1077F8: using guessed type int dword_1077F8;
// 1077FC: using guessed type int dword_1077FC;
// 107800: using guessed type int dword_107800;
// 107804: using guessed type int dword_107804;
// 107808: using guessed type int dword_107808;

//----- (00095B8B) --------------------------------------------------------
void sub_95B8B()
{
  ;
}

//----- (00095B90) --------------------------------------------------------
int __cdecl sub_95B90(float *a1, float *a2, int a3)
{
  int result; // eax
  int v4[4]; // [esp+20h] [ebp-28h] BYREF
  int v5; // [esp+30h] [ebp-18h] BYREF
  int v6; // [esp+34h] [ebp-14h]
  int v7; // [esp+38h] [ebp-10h]

  *(float *)&v5 = *a2 - *a1;
  *(float *)&v6 = a2[1] - a1[1];
  *(float *)&v7 = a2[2] - a1[2];
  VectorNormalize(&v5);
  if ( dword_B3388 )
  {
    dword_136624 = *(_DWORD *)a1;
    dword_136628 = *((_DWORD *)a1 + 1);
    dword_13662C = *((_DWORD *)a1 + 2);
    dword_136630 = *(_DWORD *)a2;
    dword_136634 = *((_DWORD *)a2 + 1);
    dword_136638 = *((_DWORD *)a2 + 2);
    dword_13663C = v5;
    dword_136640 = v6;
    result = v7;
    dword_136644 = v7;
    dword_B3388 = 0;
  }
  else if ( *(float *)&v5 * *(float *)&dword_13663C
          + *(float *)&v6 * *(float *)&dword_136640
          + *(float *)&v7 * *(float *)&dword_136644 < 0.99989998
         || a3 )
  {
    v4[0] = 1065353216;
    v4[1] = 0;
    v4[2] = 0;
    v4[3] = 1065353216;
    G_DebugLine(&dword_136624, &dword_136630, v4, 1, 0);
    dword_136624 = *(_DWORD *)a1;
    dword_136628 = *((_DWORD *)a1 + 1);
    dword_13662C = *((_DWORD *)a1 + 2);
    dword_136630 = *(_DWORD *)a2;
    dword_136634 = *((_DWORD *)a2 + 1);
    dword_136638 = *((_DWORD *)a2 + 2);
    dword_13663C = v5;
    dword_136640 = v6;
    result = v7;
    dword_136644 = v7;
  }
  else
  {
    dword_136630 = *(_DWORD *)a2;
    dword_136634 = *((_DWORD *)a2 + 1);
    result = *((_DWORD *)a2 + 2);
    dword_136638 = result;
  }
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 18904: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B3388: using guessed type int dword_B3388;
// 136624: using guessed type int dword_136624;
// 136628: using guessed type int dword_136628;
// 13662C: using guessed type int dword_13662C;
// 136630: using guessed type int dword_136630;
// 136634: using guessed type int dword_136634;
// 136638: using guessed type int dword_136638;
// 13663C: using guessed type int dword_13663C;
// 136640: using guessed type int dword_136640;
// 136644: using guessed type int dword_136644;

//----- (00095D7E) --------------------------------------------------------
int __cdecl sub_95D7E(int a1, char *nptr, int a3)
{
  int result; // eax
  int v4; // eax
  float v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  int v7; // [esp+20h] [ebp-8h] BYREF

  result = Scr_FindField(a1, &v7);
  v6 = result;
  if ( (_WORD)result )
  {
    result = v7;
    if ( v7 == 4 )
    {
      v5 = atof(nptr);
      Scr_AddFloat(LODWORD(v5));
      return Scr_SetDynamicEntityField(*(__int16 *)(a3 + 4), 2, v6);
    }
    if ( v7 <= 4 )
    {
      if ( v7 != 1 )
        return result;
      Scr_AddString(nptr);
      return Scr_SetDynamicEntityField(*(__int16 *)(a3 + 4), 2, v6);
    }
    if ( v7 == 5 )
    {
      v4 = atoi(nptr);
      Scr_AddInt(v4);
      return Scr_SetDynamicEntityField(*(__int16 *)(a3 + 4), 2, v6);
    }
  }
  return result;
}
// 17684: using guessed type _DWORD __cdecl Scr_FindField(_DWORD, _DWORD);
// 179E4: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 17E34: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 180D4: using guessed type _DWORD __cdecl Scr_SetDynamicEntityField(_DWORD, _DWORD, _DWORD);
// 18984: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00095E32) --------------------------------------------------------
void __usercall sub_95E32(long double a1@<st0>, int a2, char *s, int a4)
{
  char *v4; // esi
  char *v5; // esi
  float *v6; // esi
  int v7; // [esp+30h] [ebp-28h] BYREF
  float v8; // [esp+34h] [ebp-24h] BYREF
  int v9; // [esp+38h] [ebp-20h] BYREF
  int v10; // [esp+48h] [ebp-10h]
  char **i; // [esp+4Ch] [ebp-Ch]

  for ( i = &off_B33A0; ; i += 3 )
  {
    if ( !*i )
    {
      sub_95D7E(a2, s, a4);
      return;
    }
    if ( !Q_stricmp(*i, a2) )
      break;
  }
  v10 = a4;
  switch ( (unsigned int)i[2] )
  {
    case 0u:
      *(_DWORD *)&i[1][v10] = atoi(s);
      break;
    case 1u:
      v4 = &i[1][v10];
      *(_WORD *)v4 = atoi(s);
      break;
    case 2u:
      v5 = &i[1][v10];
      *v5 = atoi(s);
      break;
    case 3u:
      v6 = (float *)&i[1][v10];
      *v6 = atof(s);
      break;
    case 5u:
      Scr_SetString(&i[1][v10], 0);
      *(_WORD *)&i[1][v10] = G_NewString(s);
      break;
    case 6u:
      sscanf(s, "%f %f %f", &v7, &v8, &v9);
      *(_DWORD *)&i[1][v10] = v7;
      *(float *)&i[1][v10 + 4] = v8;
      *(_DWORD *)&i[1][v10 + 8] = v9;
      break;
    case 9u:
      sscanf(s, "%f %f %f", &v7, &v8, &v9);
      AngleNormalize360Accurate(v8);
      *(float *)&i[1][v10] = a1;
      break;
    default:
      return;
  }
}
// 18AF4: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// B33A0: using guessed type char *off_B33A0;

//----- (00096028) --------------------------------------------------------
int __usercall sub_96028@<eax>(long double a1@<st0>, int a2)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[1500] )
      break;
    sub_95E32(a1, level[2 * i + 1501], (char *)level[2 * i + 1502], a2);
  }
  return result;
}

//----- (00096094) --------------------------------------------------------
int __cdecl sub_96094(int a1, __int16 a2)
{
  int result; // eax

  Scr_SetString(a1, 0);
  Scr_SetString(a1 + 2, 0);
  *(_WORD *)(a1 + 4) = a2;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = -1082130432;
  *(_DWORD *)(a1 + 16) = -1082130432;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 44) = dword_B338C;
  *(_DWORD *)(a1 + 48) = dword_B3390;
  *(_DWORD *)(a1 + 52) = dword_B3394;
  *(_DWORD *)(a1 + 56) = 0;
  *(_WORD *)(a1 + 60) = -1;
  result = a1;
  *(_WORD *)(a1 + 62) = -1;
  return result;
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// B338C: using guessed type int dword_B338C;
// B3390: using guessed type int dword_B3390;
// B3394: using guessed type int dword_B3394;

//----- (00096178) --------------------------------------------------------
int __cdecl sub_96178(unsigned __int16 *a1, int a2)
{
  int result; // eax

  Scr_SetString(a2, *a1);
  Scr_SetString(a2 + 2, a1[1]);
  *(_WORD *)(a2 + 4) = a1[2];
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a1 + 2);
  *(_DWORD *)(a2 + 12) = *((_DWORD *)a1 + 3);
  *(_DWORD *)(a2 + 16) = *((_DWORD *)a1 + 4);
  *(_DWORD *)(a2 + 20) = *((_DWORD *)a1 + 5);
  *(_DWORD *)(a2 + 24) = *((_DWORD *)a1 + 6);
  *(_DWORD *)(a2 + 28) = *((_DWORD *)a1 + 7);
  *(_DWORD *)(a2 + 32) = *((_DWORD *)a1 + 8);
  *(_DWORD *)(a2 + 36) = *((_DWORD *)a1 + 9);
  *(_DWORD *)(a2 + 40) = *((_DWORD *)a1 + 10);
  *(_DWORD *)(a2 + 44) = *((_DWORD *)a1 + 11);
  *(_DWORD *)(a2 + 48) = *((_DWORD *)a1 + 12);
  *(_DWORD *)(a2 + 52) = *((_DWORD *)a1 + 13);
  *(_DWORD *)(a2 + 56) = *((_DWORD *)a1 + 14);
  *(_WORD *)(a2 + 60) = a1[30];
  result = a1[31];
  *(_WORD *)(a2 + 62) = result;
  return result;
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (00096284) --------------------------------------------------------
int __cdecl VP_GetNodeIndex(unsigned __int16 a1, float *a2)
{
  __int16 i; // [esp+6h] [ebp-Eh]
  float *v5; // [esp+8h] [ebp-Ch]

  if ( !a1 )
    return -1;
  for ( i = 0; i < word_136620; ++i )
  {
    v5 = (float *)((char *)&unk_107820 + 64 * i);
    if ( *(_WORD *)v5 == a1 )
    {
      if ( !a2 )
        return i;
      if ( v5[5] == *a2 && v5[6] == a2[1] && v5[7] == a2[2] )
        return i;
    }
  }
  return -1;
}
// 136620: using guessed type __int16 word_136620;

//----- (0009636C) --------------------------------------------------------
long double __cdecl sub_9636C(__int16 a1)
{
  __int16 v3; // [esp+6h] [ebp-2Eh]
  __int16 v4; // [esp+6h] [ebp-2Eh]
  float v5; // [esp+8h] [ebp-2Ch]
  float v7; // [esp+10h] [ebp-24h]
  float v8; // [esp+14h] [ebp-20h]
  float v9; // [esp+18h] [ebp-1Ch]
  float v10; // [esp+1Ch] [ebp-18h]
  float v11; // [esp+20h] [ebp-14h]
  __int16 *v12; // [esp+24h] [ebp-10h]
  __int16 *v13; // [esp+24h] [ebp-10h]
  __int16 *v14; // [esp+28h] [ebp-Ch]

  v14 = &word_107820[32 * a1];
  if ( *((float *)v14 + 3) >= 0.0 )
    return *((float *)v14 + 3);
  v10 = 0.0;
  v11 = 0.0;
  v7 = -1.0;
  v8 = -1.0;
  if ( v14[31] >= 0 )
  {
    v3 = 0;
    v12 = &word_107820[32 * v14[31]];
    while ( v3 < word_136620 )
    {
      ++v3;
      v11 = v11 + *((float *)v12 + 14);
      if ( *((float *)v12 + 3) >= 0.0 )
      {
        v8 = *((float *)v12 + 3);
        break;
      }
      if ( v12[31] < 0 || v12[31] == a1 )
        break;
      v12 = &word_107820[32 * v12[31]];
    }
  }
  v4 = 0;
  v13 = &word_107820[32 * a1];
  while ( v4 < word_136620 )
  {
    ++v4;
    if ( *((float *)v13 + 3) >= 0.0 )
    {
      v7 = *((float *)v13 + 3);
      break;
    }
    if ( v13[30] < 0 || v13[30] == a1 )
      break;
    v10 = v10 + *((float *)v13 + 14);
    v13 = &word_107820[32 * v13[30]];
  }
  if ( v8 < 0.0 && v7 < 0.0 )
    return 0.0;
  if ( v8 < 0.0 )
    return v7;
  if ( v7 < 0.0 )
    return v8;
  v9 = v11 + v10;
  if ( v9 <= 0.0 )
    return 0.0;
  v5 = v11 / v9;
  return (float)((v7 - v8) * v5 + v8);
}
// 136620: using guessed type __int16 word_136620;

//----- (000965B8) --------------------------------------------------------
long double __cdecl sub_965B8(__int16 a1)
{
  __int16 v3; // [esp+6h] [ebp-2Eh]
  __int16 v4; // [esp+6h] [ebp-2Eh]
  float v5; // [esp+8h] [ebp-2Ch]
  float v7; // [esp+10h] [ebp-24h]
  float v8; // [esp+14h] [ebp-20h]
  float v9; // [esp+18h] [ebp-1Ch]
  float v10; // [esp+1Ch] [ebp-18h]
  float v11; // [esp+20h] [ebp-14h]
  __int16 *v12; // [esp+24h] [ebp-10h]
  __int16 *v13; // [esp+24h] [ebp-10h]
  __int16 *v14; // [esp+28h] [ebp-Ch]

  v14 = &word_107820[32 * a1];
  if ( *((float *)v14 + 4) >= 0.0 )
    return *((float *)v14 + 4);
  v10 = 0.0;
  v11 = 0.0;
  v7 = -1.0;
  v8 = -1.0;
  if ( v14[31] >= 0 )
  {
    v3 = 0;
    v12 = &word_107820[32 * v14[31]];
    while ( v3 < word_136620 )
    {
      ++v3;
      v11 = v11 + *((float *)v12 + 14);
      if ( *((float *)v12 + 4) > 0.0 )
      {
        v8 = *((float *)v12 + 4);
        break;
      }
      if ( v12[31] < 0 || v12[31] == a1 )
        break;
      v12 = &word_107820[32 * v12[31]];
    }
  }
  v4 = 0;
  v13 = &word_107820[32 * a1];
  while ( v4 < word_136620 )
  {
    ++v4;
    if ( *((float *)v13 + 4) > 0.0 )
    {
      v7 = *((float *)v13 + 4);
      break;
    }
    if ( v13[30] < 0 || v13[30] == a1 )
      break;
    v10 = v10 + *((float *)v13 + 14);
    v13 = &word_107820[32 * v13[30]];
  }
  if ( v8 < 0.0 && v7 < 0.0 )
    return 0.0;
  if ( v8 < 0.0 )
    return v7;
  if ( v7 < 0.0 )
    return v8;
  v9 = v11 + v10;
  if ( v9 <= 0.0 )
    return 0.0;
  v5 = v11 / v9;
  return (float)((v7 - v8) * v5 + v8);
}
// 136620: using guessed type __int16 word_136620;

//----- (00096804) --------------------------------------------------------
int __cdecl sub_96804(__int16 a1, float *a2)
{
  int result; // eax
  __int16 v3; // [esp+1Ah] [ebp-4Eh]
  __int16 v4; // [esp+1Ah] [ebp-4Eh]
  float v5; // [esp+1Ch] [ebp-4Ch]
  int v6; // [esp+20h] [ebp-48h]
  int v7; // [esp+24h] [ebp-44h]
  int v8; // [esp+28h] [ebp-40h]
  float v9; // [esp+30h] [ebp-38h]
  float v10; // [esp+34h] [ebp-34h]
  float v11; // [esp+38h] [ebp-30h]
  float v12; // [esp+48h] [ebp-20h]
  float v13; // [esp+4Ch] [ebp-1Ch]
  float v14; // [esp+50h] [ebp-18h]
  __int16 *v15; // [esp+54h] [ebp-14h]
  __int16 *v16; // [esp+54h] [ebp-14h]
  __int16 *v17; // [esp+58h] [ebp-10h]

  v17 = &word_107820[32 * a1];
  if ( *((float *)v17 + 11) == *(float *)&dword_B338C
    && *((float *)v17 + 12) == *(float *)&dword_B3390
    && *((float *)v17 + 13) == *(float *)&dword_B3394 )
  {
    v13 = 0.0;
    v14 = 0.0;
    v9 = *(float *)&dword_B338C;
    v10 = *(float *)&dword_B3390;
    v11 = *(float *)&dword_B3394;
    v6 = dword_B338C;
    v7 = dword_B3390;
    v8 = dword_B3394;
    if ( v17[31] >= 0 )
    {
      v3 = 0;
      v15 = &word_107820[32 * v17[31]];
      while ( v3 < word_136620 )
      {
        ++v3;
        v14 = v14 + *((float *)v15 + 14);
        if ( *((float *)v15 + 11) != *(float *)&dword_B338C
          || *((float *)v15 + 12) != *(float *)&dword_B3390
          || *((float *)v15 + 13) != *(float *)&dword_B3394 )
        {
          v9 = *((float *)v15 + 11);
          v10 = *((float *)v15 + 12);
          v11 = *((float *)v15 + 13);
          break;
        }
        if ( v15[31] < 0 || v15[31] == a1 )
          break;
        v15 = &word_107820[32 * v15[31]];
      }
    }
    v4 = 0;
    v16 = &word_107820[32 * a1];
    while ( v4 < word_136620 )
    {
      ++v4;
      if ( *((float *)v16 + 11) != *(float *)&dword_B338C
        || *((float *)v16 + 12) != *(float *)&dword_B3390
        || *((float *)v16 + 13) != *(float *)&dword_B3394 )
      {
        v6 = *((int *)v16 + 11);
        v7 = *((int *)v16 + 12);
        v8 = *((int *)v16 + 13);
        break;
      }
      if ( v16[30] < 0 || v16[30] == a1 )
        break;
      v13 = v13 + *((float *)v16 + 14);
      v16 = &word_107820[32 * v16[30]];
    }
    if ( v9 == *(float *)&dword_B338C
      && v10 == *(float *)&dword_B3390
      && v11 == *(float *)&dword_B3394
      && *(float *)&v6 == *(float *)&dword_B338C
      && *(float *)&v7 == *(float *)&dword_B3390
      && *(float *)&v8 == *(float *)&dword_B3394 )
    {
      result = 0;
      a2[2] = 0.0;
      a2[1] = 0.0;
      *a2 = 0.0;
    }
    else if ( v9 == *(float *)&dword_B338C && v10 == *(float *)&dword_B3390 && v11 == *(float *)&dword_B3394 )
    {
      *a2 = *(float *)&v6;
      a2[1] = *(float *)&v7;
      result = v8;
      a2[2] = *(float *)&v8;
    }
    else if ( *(float *)&v6 == *(float *)&dword_B338C
           && *(float *)&v7 == *(float *)&dword_B3390
           && *(float *)&v8 == *(float *)&dword_B3394 )
    {
      *a2 = v9;
      a2[1] = v10;
      result = LODWORD(v11);
      a2[2] = v11;
    }
    else
    {
      v12 = v14 + v13;
      if ( v12 > 0.0 )
      {
        v5 = v14 / v12;
        LerpAngle(v9, v6, v5);
        *a2 = v5;
        LerpAngle(v10, v7, v5);
        a2[1] = v5;
        LerpAngle(v11, v8, v5);
        result = (int)(a2 + 2);
        a2[2] = v5;
      }
      else
      {
        result = 0;
        a2[2] = 0.0;
        a2[1] = 0.0;
        *a2 = 0.0;
      }
    }
  }
  else
  {
    *a2 = *((float *)v17 + 11);
    a2[1] = *((float *)v17 + 12);
    result = *((_DWORD *)v17 + 13);
    *((_DWORD *)a2 + 2) = result;
  }
  return result;
}
// B338C: using guessed type int dword_B338C;
// B3390: using guessed type int dword_B3390;
// B3394: using guessed type int dword_B3394;
// 136620: using guessed type __int16 word_136620;

//----- (00096CC2) --------------------------------------------------------
long double __cdecl sub_96CC2(float *a1)
{
  __int16 *v4; // [esp+8h] [ebp-8h]

  v4 = &word_107820[32 * *(__int16 *)a1];
  if ( v4[30] < 0 )
    return *((float *)v4 + 3);
  return (float)((*(float *)&word_107820[32 * v4[30] + 6] - *((float *)v4 + 3)) * a1[1] + *((float *)v4 + 3));
}

//----- (00096D3E) --------------------------------------------------------
long double __cdecl sub_96D3E(float *a1)
{
  __int16 *v4; // [esp+8h] [ebp-8h]

  v4 = &word_107820[32 * *(__int16 *)a1];
  if ( v4[30] < 0 )
    return *((float *)v4 + 4);
  return (float)((*(float *)&word_107820[32 * v4[30] + 8] - *((float *)v4 + 4)) * a1[1] + *((float *)v4 + 4));
}

//----- (00096DBC) --------------------------------------------------------
long double __cdecl sub_96DBC(float *a1)
{
  float v2; // [esp+0h] [ebp-14h]
  float v3; // [esp+4h] [ebp-10h]
  __int16 *v4; // [esp+8h] [ebp-Ch]
  __int16 *v5; // [esp+Ch] [ebp-8h]

  v5 = &word_107820[32 * *(__int16 *)a1];
  if ( v5[30] >= 0 )
  {
    v4 = &word_107820[32 * v5[30]];
    if ( *((_DWORD *)v5 + 2) && *((_DWORD *)v4 + 2) )
    {
      v3 = 1.0;
    }
    else if ( *((_DWORD *)v5 + 2) || !*((_DWORD *)v4 + 2) )
    {
      if ( !*((_DWORD *)v5 + 2) || *((_DWORD *)v4 + 2) )
        v3 = 0.0;
      else
        v3 = 1.0 - a1[1];
    }
    else
    {
      v3 = a1[1];
    }
  }
  else
  {
    if ( *((_DWORD *)v5 + 2) )
      v2 = 1.0;
    else
      v2 = 0.0;
    v3 = v2;
  }
  return v3;
}

//----- (00096E9A) --------------------------------------------------------
__int16 *__usercall sub_96E9A@<eax>(long double a1@<st0>, float *a2, int *a3)
{
  __int16 *result; // eax
  int i; // [esp+1Ch] [ebp-3Ch] BYREF
  int v5; // [esp+20h] [ebp-38h]
  int v6; // [esp+24h] [ebp-34h]
  __int16 *v7; // [esp+28h] [ebp-30h]
  float v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  __int16 *v11; // [esp+48h] [ebp-10h]
  __int16 *v12; // [esp+4Ch] [ebp-Ch]

  v12 = &word_107820[32 * *(__int16 *)a2];
  if ( v12[30] >= 0 )
  {
    v11 = &word_107820[32 * v12[30]];
    if ( *((_DWORD *)v12 + 2) || (result = v11, *((_DWORD *)v11 + 2)) )
    {
      if ( *((_DWORD *)v12 + 2) && *((_DWORD *)v11 + 2) )
      {
        v8 = *((float *)v12 + 11);
        v9 = *((_DWORD *)v12 + 12);
        v10 = *((_DWORD *)v12 + 13);
        v5 = *((_DWORD *)v11 + 11);
        v6 = *((_DWORD *)v11 + 12);
        result = (__int16 *)*((_DWORD *)v11 + 13);
        v7 = result;
      }
      else if ( *((_DWORD *)v12 + 2) || !*((_DWORD *)v11 + 2) )
      {
        v8 = *((float *)v12 + 11);
        v9 = *((_DWORD *)v12 + 12);
        v10 = *((_DWORD *)v12 + 13);
        v5 = *a3;
        v6 = a3[1];
        result = (__int16 *)a3[2];
        v7 = result;
      }
      else
      {
        LODWORD(v8) = *a3;
        v9 = a3[1];
        v10 = a3[2];
        v5 = *((_DWORD *)v11 + 11);
        v6 = *((_DWORD *)v11 + 12);
        result = (__int16 *)*((_DWORD *)v11 + 13);
        v7 = result;
      }
      for ( i = 0; i <= 2; ++i )
      {
        LerpAngle(*(&v8 + i), *(&v5 + i), a2[1]);
        *(float *)&a3[i] = a1;
        AngleNormalize180(*(float *)&a3[i]);
        *(float *)&a3[i] = a1;
        result = (__int16 *)&i;
      }
    }
  }
  else
  {
    result = v12;
    if ( *((_DWORD *)v12 + 2) )
    {
      *a3 = *((_DWORD *)v12 + 11);
      a3[1] = *((_DWORD *)v12 + 12);
      result = (__int16 *)*((_DWORD *)v12 + 13);
      a3[2] = (int)result;
    }
  }
  return result;
}

//----- (0009707E) --------------------------------------------------------
__int16 *__cdecl sub_9707E(float *a1, float *a2)
{
  __int16 *result; // eax
  __int16 v3; // [esp+2h] [ebp-12h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]
  __int16 *v6; // [esp+Ch] [ebp-8h]

  v6 = &word_107820[32 * *(__int16 *)a1];
  v5 = a1[3] * a1[2];
  v4 = a1[1] * *((float *)v6 + 14) + v5;
  v3 = 0;
  while ( v3 < word_136620 )
  {
    ++v3;
    if ( v6[30] < 0 || *((float *)v6 + 14) == 0.0 )
    {
      v4 = 0.0;
      break;
    }
    if ( *((float *)v6 + 14) > (long double)v4 )
      break;
    v4 = v4 - *((float *)v6 + 14);
    v6 = &word_107820[32 * v6[30]];
  }
  *a2 = *((float *)v6 + 8) * v4 + *((float *)v6 + 5);
  a2[1] = *((float *)v6 + 9) * v4 + *((float *)v6 + 6);
  result = v6;
  a2[2] = *((float *)v6 + 10) * v4 + *((float *)v6 + 7);
  return result;
}
// 136620: using guessed type __int16 word_136620;

//----- (00097194) --------------------------------------------------------
int __cdecl sub_97194(float *a1, float *a2, __int16 a3)
{
  __int16 v4; // [esp+1Ch] [ebp-3Ch]
  __int16 v5; // [esp+1Eh] [ebp-3Ah]
  int v6; // [esp+20h] [ebp-38h]
  float v7; // [esp+24h] [ebp-34h]
  float v8; // [esp+28h] [ebp-30h]
  float v9; // [esp+2Ch] [ebp-2Ch]
  float v10; // [esp+30h] [ebp-28h]
  float v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+34h] [ebp-24h]
  float v13; // [esp+34h] [ebp-24h]
  float v14; // [esp+38h] [ebp-20h]
  float v15; // [esp+38h] [ebp-20h]
  float *v16; // [esp+44h] [ebp-14h]
  __int16 *v17; // [esp+48h] [ebp-10h]

  v5 = *(_WORD *)a1;
  v17 = &word_107820[32 * *(__int16 *)a1];
  v7 = a1[1];
  v6 = 0;
  v4 = 0;
  while ( v4 < word_136620 )
  {
    ++v4;
    v17 = &word_107820[32 * v5];
    if ( v5 == a3 )
      v6 = 1;
    if ( v17[30] < 0 || *((float *)v17 + 14) == 0.0 )
    {
      v7 = 0.0;
      break;
    }
    v16 = (float *)&word_107820[32 * v17[30]];
    v10 = a1[5] - *((float *)v17 + 5);
    v12 = a1[6] - *((float *)v17 + 6);
    v14 = a1[7] - *((float *)v17 + 7);
    v9 = v10 * *a2 + v12 * a2[1] + v14 * a2[2];
    v11 = v16[5] - a1[5];
    v13 = v16[6] - a1[6];
    v15 = v16[7] - a1[7];
    v8 = v11 * *a2 + v13 * a2[1] + v15 * a2[2];
    if ( v9 == 0.0 && v8 == 0.0 )
    {
      v7 = 0.0;
      break;
    }
    if ( v9 >= 0.0 && v8 >= 0.0 )
    {
      v7 = v9 / (v9 + v8);
      break;
    }
    v5 = v17[30];
  }
  *(_WORD *)a1 = v5;
  *((_WORD *)a1 + 1) = (unsigned __int16)v17[30] >> 15;
  a1[1] = v7;
  a1[2] = sub_96CC2(a1);
  a1[3] = sub_96D3E(a1);
  a1[4] = sub_96DBC(a1);
  return v6;
}
// 136620: using guessed type __int16 word_136620;

//----- (000973E0) --------------------------------------------------------
int __cdecl sub_973E0(int a1)
{
  int result; // eax

  result = VP_GetNodeIndex(*(_WORD *)(a1 + 56), 0);
  if ( (result & 0x8000u) == 0 )
    result = sub_96178((unsigned __int16 *)(a1 + 56), (int)&word_107820[32 * (__int16)result]);
  return result;
}

//----- (0009743E) --------------------------------------------------------
int __cdecl sub_9743E(int a1)
{
  int result; // eax

  result = VP_GetNodeIndex(*(_WORD *)(a1 + 56), 0);
  if ( (result & 0x8000u) == 0 )
    result = sub_96178((unsigned __int16 *)(a1 + 120), (int)&word_107820[32 * (__int16)result]);
  return result;
}

//----- (0009749C) --------------------------------------------------------
__int16 *__cdecl sub_9749C(__int16 *a1)
{
  __int16 *result; // eax
  char v2; // [esp+4h] [ebp-214h]
  int v3[4]; // [esp+20h] [ebp-1F8h] BYREF
  int v4[4]; // [esp+30h] [ebp-1E8h] BYREF
  float v5[4]; // [esp+40h] [ebp-1D8h] BYREF
  float v6[7]; // [esp+50h] [ebp-1C8h] BYREF
  __int16 *i; // [esp+6Ch] [ebp-1ACh]
  __int16 v8; // [esp+72h] [ebp-1A6h]
  int v9; // [esp+74h] [ebp-1A4h]
  int v10; // [esp+78h] [ebp-1A0h]
  int v11; // [esp+7Ch] [ebp-19Ch]
  float v12[48]; // [esp+80h] [ebp-198h] BYREF
  float v13[54]; // [esp+140h] [ebp-D8h] BYREF

  v11 = 0;
  v9 = 0;
  v8 = -1;
  qmemcpy(v13, a1, 0xB8u);
  qmemcpy(v12, a1, 0xB8u);
  dword_B3388 = 1;
  while ( !v11 )
  {
    if ( ++v9 > 50000 )
    {
      Com_Printf("WARNING: Invalid vehicle path.  Possible infinite loop\n", v2);
      break;
    }
    if ( SLOWORD(v13[0]) != *a1 )
      v8 = *a1;
    qmemcpy(v13, v12, 0xB8u);
    v10 = G_VehUpdatePathPos(v12, v8);
    if ( HIWORD(v12[0]) || v10 )
      v11 = 1;
    sub_95B90(&v13[5], &v12[5], v11);
  }
  v4[0] = 0;
  v4[1] = 1065353216;
  v4[2] = 0;
  v4[3] = 1065353216;
  v3[0] = 0;
  v3[1] = 0;
  v3[2] = 1065353216;
  v3[3] = 1065353216;
  v9 = 0;
  for ( i = &word_107820[32 * *a1]; ; i = &word_107820[32 * i[30]] )
  {
    result = (__int16 *)word_136620;
    if ( v9 >= word_136620 )
      break;
    ++v9;
    v6[0] = *((float *)i + 5) + 4.0;
    v6[1] = *((float *)i + 6) + 4.0;
    v6[2] = *((float *)i + 7) + 4.0;
    v5[0] = *((float *)i + 5) - 4.0;
    v5[1] = *((float *)i + 6) - 4.0;
    v5[2] = *((float *)i + 7) - 4.0;
    if ( i == &word_107820[32 * *a1] )
      G_DebugBox(v6, v5, v4, 1, 0);
    else
      G_DebugBox(v6, v5, v3, 1, 0);
    result = i;
    if ( i[30] < 0 )
      break;
    result = (__int16 *)*a1;
    if ( (__int16 *)i[30] == result )
      break;
  }
  return result;
}
// 97535: variable 'v2' is possibly undefined
// 17A94: using guessed type _DWORD __cdecl G_VehUpdatePathPos(_DWORD, _DWORD);
// 190A4: using guessed type _DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// B3388: using guessed type int dword_B3388;
// 136620: using guessed type __int16 word_136620;

//----- (000977CA) --------------------------------------------------------
void G_InitVehiclePaths()
{
  word_136620 = 0;
}
// 136620: using guessed type __int16 word_136620;

//----- (000977E6) --------------------------------------------------------
int G_FreeVehiclePaths()
{
  int result; // eax
  __int16 i; // [esp+Eh] [ebp-Ah]
  char *v2; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = (unsigned __int16)i;
    if ( i >= word_136620 )
      break;
    v2 = (char *)&unk_107820 + 64 * i;
    Scr_FreeEntityNum(*((__int16 *)v2 + 2), 2);
    Scr_SetString(v2, 0);
    Scr_SetString(v2 + 2, 0);
  }
  word_136620 = 0;
  return result;
}
// 16A24: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 136620: using guessed type __int16 word_136620;

//----- (0009787C) --------------------------------------------------------
int G_FreeVehiclePathsScriptInfo()
{
  int result; // eax
  __int16 i; // [esp+Eh] [ebp-Ah]

  for ( i = 0; ; ++i )
  {
    result = (unsigned __int16)i;
    if ( i >= word_136620 )
      break;
    Scr_FreeEntityNum(word_107820[32 * i + 2], 2);
  }
  return result;
}
// 16A24: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 136620: using guessed type __int16 word_136620;

//----- (000978E0) --------------------------------------------------------
int G_SetupVehiclePaths()
{
  int result; // eax
  long double v1; // fst7
  double v2; // [esp+8h] [ebp-30h]
  __int16 j; // [esp+28h] [ebp-10h]
  __int16 i; // [esp+2Ah] [ebp-Eh]
  __int16 k; // [esp+2Ah] [ebp-Eh]
  __int16 l; // [esp+2Ah] [ebp-Eh]
  __int16 *v7; // [esp+2Ch] [ebp-Ch]
  __int16 *v8; // [esp+2Ch] [ebp-Ch]
  __int16 *v9; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; i < word_136620; ++i )
  {
    v7 = &word_107820[32 * i];
    if ( v7[1] )
      v7[30] = VP_GetNodeIndex(v7[1], 0);
    for ( j = 0; j < word_136620; ++j )
    {
      if ( i != j && *v7 == word_107820[32 * j + 1] )
      {
        v7[31] = j;
        break;
      }
    }
    if ( v7[30] == i )
      v7[30] = -1;
    if ( v7[31] == i )
      v7[31] = -1;
  }
  for ( k = 0; k < word_136620; ++k )
  {
    v8 = &word_107820[32 * k];
    if ( v8[30] >= 0 )
    {
      *((float *)v8 + 8) = *(float *)&word_107820[32 * v8[30] + 10] - *((float *)v8 + 5);
      *((float *)v8 + 9) = *(float *)&word_107820[32 * v8[30] + 12] - *((float *)v8 + 6);
      *((float *)v8 + 10) = *(float *)&word_107820[32 * v8[30] + 14] - *((float *)v8 + 7);
      *((float *)v8 + 14) = VectorNormalize(v8 + 16);
      if ( !*((_DWORD *)v8 + 2) )
        vectoangles(v8 + 16, v8 + 22);
    }
  }
  for ( l = 0; ; ++l )
  {
    result = (unsigned __int16)l;
    if ( l >= word_136620 )
      break;
    v9 = &word_107820[32 * l];
    *((float *)v9 + 3) = sub_9636C(l);
    *((float *)v9 + 4) = sub_965B8(l);
    v1 = *((float *)v9 + 3);
    if ( v1 < 0.0 )
    {
      v1 = *((float *)v9 + 5);
      v2 = *((float *)v9 + 5);
      Com_Error(1, byte_A8220, SLOBYTE(v2));
    }
    if ( *((_DWORD *)v9 + 2) )
      sub_96804(l, (float *)v9 + 11);
    AngleNormalize180(*((float *)v9 + 11));
    *((float *)v9 + 11) = v1;
    AngleNormalize180(*((float *)v9 + 12));
    *((float *)v9 + 12) = v1;
    AngleNormalize180(*((float *)v9 + 13));
    *((float *)v9 + 13) = v1;
    if ( *((float *)v9 + 3) <= 0.0 || *((float *)v9 + 4) <= 0.0 )
      v9[30] = -1;
    if ( v9[30] < 0 )
    {
      if ( *((float *)v9 + 3) <= 0.0 )
        *((_DWORD *)v9 + 3) = 1065353216;
      if ( *((float *)v9 + 4) <= 0.0 )
        *((_DWORD *)v9 + 4) = 1065353216;
    }
  }
  return result;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 136620: using guessed type __int16 word_136620;

//----- (00097C3C) --------------------------------------------------------
__int16 *G_DrawVehiclePaths()
{
  __int16 *result; // eax
  char *s1; // [esp+18h] [ebp-E0h]
  __int16 i; // [esp+1Eh] [ebp-DAh]
  __int16 v3[102]; // [esp+20h] [ebp-D8h] BYREF
  __int16 *v4; // [esp+ECh] [ebp-Ch]

  result = (__int16 *)g_vehicleDrawPath;
  if ( g_vehicleDrawPath[16] )
  {
    result = (__int16 *)g_vehicleDrawPath;
    if ( g_vehicleDrawPath[16] != 48 )
    {
      for ( i = 0; ; ++i )
      {
        result = (__int16 *)(unsigned __int16)i;
        if ( i >= word_136620 )
          break;
        v4 = &word_107820[32 * i];
        s1 = (char *)SL_ConvertToString((unsigned __int16)*v4);
        if ( !strcmp(s1, &g_vehicleDrawPath[16]) )
        {
          v3[28] = 0;
          v3[29] = 0;
          v3[60] = 0;
          v3[61] = 0;
          G_VehSetUpPathPos(v3, i);
          return sub_9749C(v3);
        }
      }
    }
  }
  return result;
}
// 17FA4: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 18324: using guessed type _DWORD __cdecl G_VehSetUpPathPos(_DWORD, _DWORD);
// 136620: using guessed type __int16 word_136620;

//----- (00097D40) --------------------------------------------------------
int __cdecl G_VehInitPathPos(int a1)
{
  *(_WORD *)a1 = -1;
  *(_WORD *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  sub_96094(a1 + 56, -1);
  return sub_96094(a1 + 120, -1);
}

//----- (00097E08) --------------------------------------------------------
int __cdecl G_VehFreePathPos(int a1)
{
  Scr_SetString(a1 + 56, 0);
  Scr_SetString(a1 + 58, 0);
  Scr_SetString(a1 + 120, 0);
  return Scr_SetString(a1 + 122, 0);
}
// 18E44: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (00097E78) --------------------------------------------------------
int __cdecl G_VehSetUpPathPos(int a1, __int16 a2)
{
  float v3; // [esp+14h] [ebp-14h]
  __int16 *v4; // [esp+1Ch] [ebp-Ch]

  v4 = &word_107820[32 * a2];
  *(_WORD *)a1 = a2;
  *(_WORD *)(a1 + 2) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)v4 + 3);
  *(_DWORD *)(a1 + 12) = *((_DWORD *)v4 + 4);
  if ( *((_DWORD *)v4 + 2) )
    v3 = 1.0;
  else
    v3 = 0.0;
  *(float *)(a1 + 16) = v3;
  *(_DWORD *)(a1 + 20) = *((_DWORD *)v4 + 5);
  *(_DWORD *)(a1 + 24) = *((_DWORD *)v4 + 6);
  *(_DWORD *)(a1 + 28) = *((_DWORD *)v4 + 7);
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v4 + 11);
  *(_DWORD *)(a1 + 36) = *((_DWORD *)v4 + 12);
  *(_DWORD *)(a1 + 40) = *((_DWORD *)v4 + 13);
  *(_DWORD *)(a1 + 44) = *((_DWORD *)v4 + 5);
  *(_DWORD *)(a1 + 48) = *((_DWORD *)v4 + 6);
  *(_DWORD *)(a1 + 52) = *((_DWORD *)v4 + 7);
  sub_96094(a1 + 56, -1);
  return sub_96094(a1 + 120, -1);
}

//----- (00097FA4) --------------------------------------------------------
int __cdecl G_VehUpdatePathPos(int a1, __int16 a2)
{
  long double v2; // fst7
  int v5; // [esp+18h] [ebp-30h]
  float v6; // [esp+1Ch] [ebp-2Ch]
  float v7; // [esp+20h] [ebp-28h] BYREF
  float v8; // [esp+24h] [ebp-24h]
  float v9; // [esp+28h] [ebp-20h]
  __int16 v10; // [esp+3Eh] [ebp-Ah]

  v10 = a2;
  v5 = 0;
  if ( *(_WORD *)(a1 + 2) )
    return 0;
  sub_973E0(a1);
  sub_9707E((float *)a1, (float *)(a1 + 44));
  v7 = *(float *)(a1 + 44) - *(float *)(a1 + 20);
  v8 = *(float *)(a1 + 48) - *(float *)(a1 + 24);
  v9 = *(float *)(a1 + 52) - *(float *)(a1 + 28);
  v6 = VectorNormalize(&v7);
  if ( v6 <= 0.0 )
  {
    *(_WORD *)(a1 + 2) = 1;
  }
  else
  {
    vectoangles(&v7, a1 + 32);
    AngleNormalize180(*(float *)(a1 + 32));
    *(float *)(a1 + 32) = 0.0;
    AngleNormalize180(*(float *)(a1 + 36));
    *(float *)(a1 + 36) = 0.0;
    AngleNormalize180(*(float *)(a1 + 40));
    *(float *)(a1 + 40) = 0.0;
    *(float *)(a1 + 20) = *(float *)(a1 + 8) * 0.050000001 * v7 + *(float *)(a1 + 20);
    *(float *)(a1 + 24) = *(float *)(a1 + 8) * 0.050000001 * v8 + *(float *)(a1 + 24);
    v2 = *(float *)(a1 + 8) * 0.050000001 * v9 + *(float *)(a1 + 28);
    *(float *)(a1 + 28) = v2;
    v5 = sub_97194((float *)a1, &v7, v10);
    sub_96E9A(v2, (float *)a1, (int *)(a1 + 32));
  }
  sub_9743E(a1);
  return v5;
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 19614: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (00098154) --------------------------------------------------------
void __cdecl G_VehSetSwitchNode(int a1, __int16 a2, __int16 a3)
{
  float *v3; // [esp+14h] [ebp-14h]
  __int16 *v4; // [esp+18h] [ebp-10h]

  sub_96094(a1 + 56, -1);
  sub_96094(a1 + 120, -1);
  if ( a2 >= 0 && a3 >= 0 )
  {
    v4 = &word_107820[32 * a2];
    v3 = (float *)&word_107820[32 * a3];
    sub_96178((unsigned __int16 *)v4, a1 + 56);
    sub_96178((unsigned __int16 *)v4, a1 + 120);
    *(_WORD *)(a1 + 116) = a3;
    *(float *)(a1 + 88) = v3[5] - *((float *)v4 + 5);
    *(float *)(a1 + 92) = v3[6] - *((float *)v4 + 6);
    *(float *)(a1 + 96) = v3[7] - *((float *)v4 + 7);
    *(float *)(a1 + 112) = VectorNormalize(a1 + 88);
  }
}
// 17474: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (00098272) --------------------------------------------------------
void __usercall SP_info_vehicle_node(long double a1@<st0>, int a2)
{
  double v2; // [esp+8h] [ebp-20h]
  __int16 *v3; // [esp+20h] [ebp-8h]

  if ( word_136620 > 2999 )
    Com_Error(1, byte_A8280, 184);
  v3 = &word_107820[32 * word_136620];
  sub_96094((int)v3, word_136620);
  ++word_136620;
  sub_96028(a1, (int)v3);
  *((_DWORD *)v3 + 2) = a2;
  if ( !*v3 )
  {
    v2 = *((float *)v3 + 5);
    Com_Error(1, byte_A82C0, SLOBYTE(v2));
  }
  if ( *((float *)v3 + 3) >= 0.0 )
    *((float *)v3 + 3) = *((float *)v3 + 3) * 17.6;
}
// 136620: using guessed type __int16 word_136620;

//----- (0009836C) --------------------------------------------------------
int __cdecl GScr_GetVehicleNodeIndex(int a1)
{
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetEntityNum(a1, &v3);
  if ( v3 == 2 && v4 < word_136620 )
    return (__int16)v4;
  Scr_ParamError(a1, "Not a vehicle node");
  return -1;
}
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 19664: using guessed type _DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD);
// 136620: using guessed type __int16 word_136620;

//----- (000983D4) --------------------------------------------------------
char **GScr_AddFieldsForVehicleNode()
{
  char **result; // eax
  unsigned __int16 v1; // [esp+1Eh] [ebp-Ah]
  char **i; // [esp+20h] [ebp-8h]

  v1 = g_scr_data[218];
  for ( i = &off_B33A0; ; i += 3 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 5u:
      case 6u:
      case 7u:
      case 9u:
        Scr_AddClassField(
          v1,
          *i,
          (unsigned __int16)(-21845
                           * (((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_B33A0 - 183814))) >> 2)));
        break;
      default:
        continue;
    }
  }
  return result;
}
// 18404: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// B33A0: using guessed type char *off_B33A0;
// B3818: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0009846C) --------------------------------------------------------
int __cdecl GScr_GetVehicleNodeField(int a1, int a2)
{
  return Scr_GetGenericField(&word_107820[32 * a1], (&off_B33A0)[3 * a2 + 2], (&off_B33A0)[3 * a2 + 1]);
}
// 187F4: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// B33A0: using guessed type char *off_B33A0;

//----- (000984D2) --------------------------------------------------------
int GScr_GetVehicleNode()
{
  int result; // eax
  __int16 i; // [esp+16h] [ebp-22h]
  int v2; // [esp+18h] [ebp-20h]
  int v3; // [esp+20h] [ebp-18h]
  __int16 v4; // [esp+24h] [ebp-14h]
  __int16 v5; // [esp+26h] [ebp-12h]
  __int16 *v6; // [esp+2Ch] [ebp-Ch]

  v4 = Scr_GetConstString(0);
  v3 = Scr_GetString(1);
  result = Scr_GetOffset((unsigned __int16)g_scr_data[218], v3);
  v2 = result;
  if ( result >= 0 )
  {
    if ( (&off_B33A0)[3 * result + 2] != &byte_5 )
      Scr_ParamError(1, "key is not internally a string");
    v6 = 0;
    for ( i = 0; ; ++i )
    {
      result = (unsigned __int16)i;
      if ( i >= word_136620 )
        break;
      v5 = *(__int16 *)((char *)&word_107820[32 * i] + (_DWORD)(&off_B33A0)[3 * v2 + 1]);
      if ( v5 && v5 == v4 )
      {
        if ( v6 )
          Scr_Error("GetVehicleNode used with more than one node");
        v6 = &word_107820[32 * i];
      }
    }
    if ( v6 )
      result = Scr_AddEntityNum(v6[2], 2);
  }
  return result;
}
// 5: using guessed type char byte_5;
// 16CB4: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 17F24: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19454: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// B33A0: using guessed type char *off_B33A0;
// 136620: using guessed type __int16 word_136620;

//----- (0009860A) --------------------------------------------------------
int GScr_GetVehicleNodeArray()
{
  int result; // eax
  __int16 i; // [esp+Ah] [ebp-1Eh]
  int v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+14h] [ebp-14h]
  __int16 v4; // [esp+18h] [ebp-10h]
  __int16 v5; // [esp+1Ah] [ebp-Eh]

  v4 = Scr_GetConstString(0);
  v3 = Scr_GetString(1);
  result = Scr_GetOffset((unsigned __int16)g_scr_data[218], v3);
  v2 = result;
  if ( result >= 0 )
  {
    if ( (&off_B33A0)[3 * result + 2] != &byte_5 )
      Scr_ParamError(1, "key is not internally a string");
    Scr_MakeArray();
    for ( i = 0; ; ++i )
    {
      result = (unsigned __int16)i;
      if ( i >= word_136620 )
        break;
      v5 = *(__int16 *)((char *)&word_107820[32 * i] + (_DWORD)(&off_B33A0)[3 * v2 + 1]);
      if ( v5 )
      {
        if ( v5 == v4 )
        {
          Scr_AddEntityNum(word_107820[32 * i + 2], 2);
          Scr_AddArray();
        }
      }
    }
  }
  return result;
}
// 5: using guessed type char byte_5;
// 177B4: using guessed type int Scr_AddArray(void);
// 17F24: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);
// 17F44: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 18B24: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 191E4: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 19454: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// 19504: using guessed type int Scr_MakeArray(void);
// B33A0: using guessed type char *off_B33A0;
// 136620: using guessed type __int16 word_136620;

//----- (00098726) --------------------------------------------------------
int GScr_GetAllVehicleNodes()
{
  int result; // eax
  __int16 i; // [esp+12h] [ebp-6h]

  Scr_MakeArray();
  for ( i = 0; ; ++i )
  {
    result = (unsigned __int16)i;
    if ( i >= word_136620 )
      break;
    Scr_AddEntityNum(word_107820[32 * i + 2], 2);
    Scr_AddArray();
  }
  return result;
}
// 177B4: using guessed type int Scr_AddArray(void);
// 17F24: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);
// 19504: using guessed type int Scr_MakeArray(void);
// 136620: using guessed type __int16 word_136620;

//----- (0009878A) --------------------------------------------------------
void sub_9878A()
{
  ;
}

//----- (00098790) --------------------------------------------------------
void (*sub_98790())(void)
{
  void (**v0)(void); // esi
  void (*result)(void); // eax

  v0 = (void (**)(void))(&dword_B3808 - 1);
  result = (void (*)(void))*(&dword_B3808 - 1);
  if ( result != (void (*)(void))-1 )
  {
    do
    {
      --v0;
      result();
      result = *v0;
    }
    while ( *v0 != (void (*)(void))-1 );
  }
  return result;
}
// B3808: using guessed type int dword_B3808;

//----- (000987D0) --------------------------------------------------------
void sub_987D0()
{
  ;
}

//----- (000987D4) --------------------------------------------------------
int term_proc()
{
  return start();
}

// nfuncs=2523 queued=1686 decompiled=1686 lumina nreq=0 worse=0 better=0
// ALL OK, 1686 function(s) have been successfully decompiled
