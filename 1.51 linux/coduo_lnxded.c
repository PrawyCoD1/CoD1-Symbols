/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc(void); // idb
void sub_804979C();
// int usleep(__useconds_t useconds);
// int mkdir(const char *path, __mode_t mode);
// double cos(double x);
// void *__cdecl __cxa_allocate_exception(size_t thrown_size);
// uint32_t ntohl(uint32_t netlong);
// int rename(const char *old, const char *new);
// int execl(const char *path, const char *arg, ...);
// char *strncat(char *dest, const char *src, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// ssize_t write(int fd, const void *buf, size_t n);
// struct tm *localtime(const time_t *timer);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int fileno(FILE *stream);
// int strcmp(const char *s1, const char *s2);
// int close(int fd);
// void *dlsym(void *handle, const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// __pid_t fork(void);
// char *getenv(const char *name);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int fflush(FILE *stream);
// int seteuid(__uid_t uid);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strerror(int errnum);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// struct passwd *getpwuid(__uid_t uid);
// void __cdecl operator delete(void *); idb
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
// int *__errno_location(void);
// int ftell(FILE *stream);
// int system(const char *command);
// int chmod(const char *file, __mode_t mode);
// int tolower(int c);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *malloc(size_t size);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int remove(const char *filename);
// void __cdecl __noreturn __cxa_throw(void *, struct type_info *lptinfo, void (__cdecl *)(void *));
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int fseek(FILE *stream, int off, int whence);
// time_t time(time_t *timer);
// int fputs(const char *s, FILE *stream);
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// unsigned int sleep(unsigned int seconds);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double atof(const char *nptr);
// double atan2(double y, double x);
// int strncmp(const char *s1, const char *s2, size_t n);
// in_addr_t inet_addr(const char *cp);
// double floor(double x);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *dlerror(void);
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int toupper(int c);
// void *realloc(void *ptr, size_t size);
// char *strcat(char *dest, const char *src);
// char *asctime(const struct tm *tp);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int fcntl(int fd, int cmd, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
// int fclose(FILE *stream);
// char *ctime(const time_t *timer);
// int closedir(DIR *dirp);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void srand(unsigned int seed);
// DIR *opendir(const char *name);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int gethostname(char *name, size_t len);
// struct hostent *gethostbyname(const char *name);
// int strcasecmp(const char *s1, const char *s2);
// int dlclose(void *handle);
// void exit(int status);
// int atoi(const char *nptr);
// void *calloc(size_t nmemb, size_t size);
// int sscanf(const char *s, const char *format, ...);
// void free(void *ptr);
// int ioctl(int fd, unsigned int request, ...);
// uint16_t htons(uint16_t hostshort);
// char *getcwd(char *buf, size_t size);
// int isatty(int fd);
// void *memset(void *s, int c, size_t n);
// void _exit(int status);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// FILE *fopen(const char *filename, const char *modes);
// _DWORD __cdecl operator new[](unsigned int); idb
// int sprintf(char *s, const char *format, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// double sin(double x);
// int socket(int domain, int type, int protocol);
// struct dirent *readdir(DIR *dirp);
// int rand(void);
// int tcgetattr(int fd, struct termios *termios_p);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __uid_t geteuid(void);
// int __gmon_start__(void); weak
// double ceil(double x);
// void *dlopen(const char *file, int mode);
// char *strcpy(char *dest, const char *src);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void sub_8049F70();
int sub_8049FD0();
char *sub_804A030();
int __cdecl sub_804A06C(_DWORD *a1);
signed int __cdecl sub_804A19D(_DWORD *a1);
signed int __cdecl sub_804A40A(_DWORD *a1);
int __cdecl sub_804A557(_DWORD *a1, _DWORD *a2);
void *__cdecl sub_804A8EA(_DWORD *a1);
int __cdecl sub_804AB81(_DWORD *a1);
int __cdecl sub_804AD14(_DWORD *a1);
int __cdecl sub_804ADB4(_DWORD *a1);
_DWORD __cdecl sub_804AE51(_DWORD, _DWORD, _DWORD); // weak
void *__cdecl sub_804B316(size_t *a1);
void *__cdecl sub_804B360(size_t *a1);
char *__cdecl sub_804B429(char *src, int a2, int a3);
int *__cdecl sub_804BC58(int a1);
int __cdecl sub_804BD20(int a1);
void *sub_804BD66();
int __cdecl sub_804BD70(int a1);
int __cdecl sub_804BD86(int a1);
int sub_804BD9D();
int __cdecl sub_804BE53(int *a1, int *a2, int a3, int a4);
int sub_804BF27();
int __cdecl sub_804BF33(int a1, int *a2, _DWORD *a3);
int __cdecl sub_804BF96(__int16 a1);
int __cdecl sub_804BFA9(int a1);
long double __cdecl sub_804BFB1(float a1);
int __cdecl sub_804BFC4(int a1);
int __cdecl sub_804C019(float *a1, float *a2, float *a3, float *a4);
_BOOL4 __cdecl sub_804C103(int a1, int a2, int a3, int a4);
int *__cdecl sub_804C1A3(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804C278(int *a1);
_DWORD *__cdecl sub_804C8AF(_DWORD *a1);
int __cdecl sub_804C985(_DWORD *a1, int a2);
_BOOL4 __cdecl sub_804CD9C(float *a1, float *a2);
int __cdecl sub_804CE6B(int *a1);
int __cdecl sub_804D04C(float *a1, float *a2, _DWORD *a3);
int *__cdecl sub_804D1A1(int *a1);
int __cdecl sub_804D278(int a1, _DWORD *a2);
int __cdecl sub_804D3C2(float *a1, float *a2, float *a3);
int __cdecl sub_804D6F7(float *a1, int a2);
int __cdecl sub_804D7A7(int a1, int a2, int a3, int a4);
int __cdecl sub_804D830(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_804DEE3(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804E1AC(_DWORD *a1);
int __cdecl sub_804E40B(_DWORD *a1);
void *__cdecl sub_804EC66(_DWORD *a1, int a2);
void *__cdecl sub_804F52D(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_804F85B(int a1, _DWORD *a2);
int __cdecl sub_804FD53(int a1, _DWORD *a2);
int __cdecl sub_8050216(float *a1, float *a2, float *a3, float *a4, float *a5, _DWORD *a6);
int __cdecl sub_80503B2(int a1, _DWORD *a2);
int __cdecl sub_80509F7(int a1, _DWORD *a2);
int __cdecl sub_8050FC6(int a1, _DWORD *a2);
void *__cdecl sub_8051484(int a1);
void __cdecl sub_80514CC(void *ptr);
float *__cdecl sub_80517A4(float *a1, float *a2, float *a3);
long double __cdecl sub_8051863(int a1);
int __cdecl sub_805199E(_DWORD *a1, _DWORD *a2, _DWORD *a3);
float *__cdecl sub_8051B87(int a1, float a2);
void *__cdecl sub_8051EBB(void *src);
int *__cdecl sub_8051FE8(void *src, int a2, float a3, float a4, int a5, int a6);
int *__cdecl sub_805275D(int a1, int a2, float a3, float a4);
void *__cdecl sub_805366C(size_t a1);
void *__cdecl sub_805367F(size_t a1);
int __cdecl sub_8053692(int a1, const char *a2, float *a3, float *a4, float *a5);
char *sub_805391F();
int __cdecl sub_8053D9B(int a1, int *a2, float *a3, float *a4, int a5);
int __cdecl sub_8053FA4(int a1, int a2, __int16 a3, __int16 a4);
unsigned __int16 *__cdecl sub_805403E(int a1, int a2, unsigned int a3, int a4, float *a5);
int __cdecl sub_8055595(int a1, unsigned __int16 *a2);
int __cdecl sub_80558DD(int a1, unsigned __int16 *a2);
int __cdecl sub_8056773(float *a1, unsigned __int16 *a2);
int __cdecl sub_8056F57(_DWORD *a1, unsigned __int16 *a2);
int __cdecl sub_8056FF5(_DWORD *a1, unsigned __int16 *a2);
_BOOL4 __cdecl sub_8057073(int *a1, unsigned __int16 *a2);
int __cdecl sub_8057122(int a1, unsigned __int16 *a2);
int __cdecl sub_8057184(float *a1, int a2);
int __cdecl sub_805723E(float *a1);
_DWORD *__cdecl sub_8057259(_DWORD *a1, int a2);
int __cdecl sub_80572C1(_DWORD *a1, int a2);
int __cdecl sub_80573E6(int a1, int a2);
int __cdecl sub_8057491(int *a1, int *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_80575A9(float *a1, int a2);
int __cdecl sub_805772B(float *a1, int a2, float *a3, float *a4);
char *__cdecl sub_805784E(int a1);
int __cdecl sub_8057890(int a1, int a2);
int sub_805793E();
int __cdecl sub_80579A3(int a1, int a2, int a3);
_BOOL4 __cdecl sub_8057ABD(int a1, int a2);
float *__cdecl sub_8057B18(float *a1, float *a2);
int *__cdecl sub_8057BBF(int a1, int a2);
unsigned int __cdecl sub_8057C2A(float *a1, int a2);
float *__cdecl sub_8057C66(float *a1, float *a2, float *a3, float *a4);
void __cdecl sub_8057FE3(int a1, int a2);
int __cdecl sub_80582C8(int a1, int a2);
void __cdecl sub_805848F(int a1);
void __cdecl sub_8058894(int a1);
int __cdecl sub_80589FE(int a1);
_BOOL4 __cdecl sub_8058B85(int a1, float *a2, float *a3);
void __cdecl sub_8058E30(int a1, int a2);
void __cdecl sub_8058F0A(int a1, _DWORD *a2);
void __cdecl sub_8059875(int a1, int a2);
int __cdecl sub_80599E6(int, int, int, int, float); // idb
int __cdecl sub_8059C6B(int, int, float, float); // idb
void __cdecl sub_8059FB5(float *a1);
void __cdecl sub_805A3EF(int a1);
void __cdecl sub_805A58F(int a1, int a2, float a3, int a4, int a5, int a6);
int __cdecl sub_805A9D5(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8, int a9);
int __cdecl sub_805B145(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8);
int __cdecl sub_805B19A(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
int __cdecl sub_805B5B0(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
int __cdecl sub_805B60B(int *a1, int a2);
int __cdecl sub_805B67D(int a1, int a2);
int __cdecl sub_805BDAD(int *a1, int a2);
_BOOL4 __cdecl sub_805BF30(int a1, int a2, int a3, int a4, float a5);
_BOOL4 __cdecl sub_805C0A6(int a1, int a2, float a3, float a4);
int __cdecl sub_805C2CC(float *a1);
int __cdecl sub_805C76A(int a1);
int __cdecl sub_805C90A(int *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805CD62(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_805D459(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8);
int __cdecl sub_805D4AD(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
long double __cdecl sub_805D7EC(float a1);
int __cdecl sub_805D808(float *a1, float *a2);
__int64 sub_805D8E6();
int __cdecl sub_805D9DF(int *a1);
int __cdecl sub_805DB34(float *a1, float *a2, float *a3);
int __cdecl sub_805DE1A(int a1, _DWORD *a2, _DWORD *a3);
int sub_805E021();
int __cdecl sub_805E02B(int a1);
void __cdecl sub_805E166(int a1, int a2);
int __cdecl sub_805E344(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_805E387(int a1, int a2, int a3, int a4, float a5);
void __cdecl sub_805E4FD(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805E7AF(int *a1, int *a2, int *a3, int a4);
void __cdecl sub_805E8E5(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805EC45(int a1);
int __cdecl sub_805EC86(int *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805F042(int a1);
void __cdecl sub_805F087(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805F2BE(int a1);
int __cdecl sub_805F2FC(_DWORD *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805F58C(int a1);
int __cdecl sub_805F5CE(int a1, int a2, float a3, float a4, float *a5, float *a6);
int sub_805F9A0();
void sub_805F9D7();
void __cdecl sub_805F9FA(char *s);
void __cdecl sub_805FA59(char *s);
void __cdecl sub_805FAF4(int a1, char *s);
void sub_805FB6E();
void sub_805FC9A();
void sub_805FDAE();
void sub_805FE83();
void sub_805FED5();
int sub_805FF1E();
char *__cdecl sub_805FF28(unsigned int a1);
char *__cdecl sub_805FF54(int a1, char *dest, int a3);
char *__cdecl sub_805FF7F(int a1);
char **__cdecl sub_8060010(char **a1, int a2);
char **__cdecl sub_8060257(char **a1);
void __cdecl sub_8060272(char *s1, int a2);
void __cdecl sub_8060308(char *s1);
void sub_8060376();
int __cdecl sub_80603B9(void (__cdecl *a1)(int));
void __cdecl sub_80603E9(char *s);
void sub_8060561();
void sub_8060603();
_BOOL4 sub_8060684();
void sub_8060696();
int __cdecl sub_806069B(int a1);
int sub_80606F8();
_BOOL4 __cdecl sub_8060702(int a1);
int __cdecl sub_806077A(int a1, int a2);
int __cdecl sub_806080D(int a1);
int __cdecl sub_80608D4(int a1);
int __cdecl sub_80608EC(int a1);
int __cdecl sub_8060925(int a1);
_BYTE *__cdecl sub_80609D3(_BYTE *a1);
void *__cdecl sub_8060A0A(char *s, char *a2, char *a3, void *dest, int a5);
void *__cdecl sub_8060B06(char *s, char *a2, char *a3, void *dest);
int __cdecl sub_8060B36(char *haystack); // idb
void __cdecl sub_8060BCB(char *haystack, char *filename);
int __cdecl sub_8060F50(char *filename); // idb
int __cdecl sub_8060F63(char *); // idb
int __cdecl sub_8060FDD(char *, char *); // idb
void *__cdecl FS_FCloseFile(int a1);
int __cdecl sub_80611FB(char *src); // idb
int __cdecl sub_806135D(char *src); // idb
int __cdecl sub_80614BF(char *src); // idb
int __cdecl sub_806161E(char *a1, char *a2);
char *__cdecl sub_8061918(char *haystack, int a2, char a3);
const char *__cdecl sub_806198C(_BYTE *a1);
_BOOL4 __cdecl sub_80619D7(char *s1);
int __cdecl sub_8061A74(char *haystack, int, int, int); // idb
int __cdecl sub_8062558(char *haystack, int, int); // idb
int __cdecl sub_806258B(char *haystack); // idb
_BOOL4 __cdecl sub_8062782(char *a1, int a2);
int __cdecl sub_8062853(int a1, unsigned int a2, int a3);
size_t __cdecl sub_8062983(char *a1, size_t a2, int a3);
size_t sub_8062A7E(int a1, char *format, ...);
int __cdecl sub_8062AD4(int, int off, int); // idb
unsigned int __cdecl sub_8062EB0(char *haystack, int a2);
void sub_80631F8();
void __cdecl sub_8063207(void *ptr);
void __cdecl sub_806323F(char *src, int a2, int a3);
char *__cdecl sub_80632B9(char *src, char *a2);
int __cdecl sub_8063873(char *src, char *dest, int); // idb
int __cdecl sub_8063901(char *s, int, int); // idb
void *__cdecl sub_8063988(char *s, char *a2, int a3, int a4);
void *__cdecl sub_8063EFC(char *s, char *a2, int a3);
void __cdecl sub_8063F25(void *ptr);
int __cdecl sub_8063F80(char *s, char *, char *dest, int); // idb
_BYTE *__cdecl sub_806407D(_BYTE *a1);
int __cdecl sub_80640AA(char *a1, char *a2);
void __cdecl sub_8064157(void *dest, int a2);
void __cdecl sub_8064271(int a1);
void sub_80643C4();
void sub_80643D8();
int __cdecl sub_80643EC(char *s); // idb
int compar(const void *, const void *); // idb
_DWORD *__cdecl sub_8064597(_DWORD *a1);
void __cdecl sub_80645FD(char *a1, char *src);
void __cdecl sub_806490E(char *a1, char *src, int a3, int a4);
void __cdecl sub_8064B58(char *a1, char *src);
void __cdecl sub_8064BA4(char *a1, int a2, char *a3, char *a4);
char *__cdecl sub_8064F6D(char *a1, char *a2);
int __cdecl sub_8064FC5(char *s2, int, int); // idb
_DWORD *__cdecl sub_8065197(unsigned int a1, unsigned int a2);
void *__cdecl sub_8065316(void *ptr);
void *__cdecl sub_8065398(void *ptr);
void *sub_80653D9();
int sub_8065429();
int sub_8065483();
void __cdecl sub_80654DD(int a1);
void __cdecl sub_80655D8(char *src);
_DWORD *__cdecl sub_8065A4D(int a1);
void *sub_8065AB2();
char *__cdecl sub_8065BBB(int a1);
int __cdecl sub_8065D85(char *src, int, int); // idb
int __cdecl sub_8065FA4(int a1);
int __cdecl sub_8065FC7(int a1);
int __cdecl sub_8065FD0(int a1);
long double __cdecl sub_8065FEB(int a1);
long double __cdecl sub_80660AF(float a1);
long double __cdecl sub_80665E0(float *a1, float *a2);
float *__cdecl sub_80666B1(float *a1, float *a2, float *a3);
long double __cdecl sub_8066755(float *a1);
long double __cdecl sub_80669A0(float *a1, float *a2);
unsigned int __cdecl sub_8066A5E(_DWORD *a1);
float *__cdecl sub_8066BF8(int a1, int a2, int a3, float a4);
long double __cdecl sub_80670EE(float *a1);
long double __cdecl sub_80671BE(float *a1);
int __cdecl sub_8067272(float *a1, int a2);
int __cdecl sub_80673AD(float *a1, int a2);
float *__cdecl sub_80674AD(float *a1, int a2, float *a3, float *a4);
float *__cdecl sub_8067636(float a1, int a2, int a3);
void __cdecl sub_80676B4(float *a1, float *a2);
float *__cdecl sub_80678FC(float *a1, float *a2, float *a3);
int __cdecl sub_806881D(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_80688AC(float *a1, float *a2);
float *__cdecl sub_8069154(float *a1, float *a2, float *a3);
float *__cdecl sub_80691FE(float *a1, float *a2, float *a3);
float *__cdecl sub_8069416(float *a1, float *a2, float *a3);
float *__cdecl sub_806960C(float *a1, float *a2, float *a3);
unsigned int __cdecl sub_806972E(_DWORD *a1, unsigned int *a2);
long double __cdecl sub_806998F(float *a1);
long double __cdecl sub_8069E5B(float a1, float a2);
long double __cdecl sub_8069F27(float a1);
long double __cdecl sub_8069F6A(float a1);
long double __cdecl sub_806A0C3(int a1, int a2);
int __cdecl sub_806A164(_DWORD *a1, _DWORD *a2);
void __cdecl sub_806A19F(float *a1, float *a2, float *a3);
float *__cdecl sub_806A46E(float *a1, float *a2);
int __cdecl sub_806A964(float *a1, float *a2, float *a3, float *a4);
float *__cdecl sub_806AA4E(float *a1, float *a2, float *a3);
_BOOL4 __cdecl sub_806AB7E(int a1, int a2, int a3, float a4);
int __cdecl sub_806AF24(int *a1, int a2, _DWORD *a3);
float *__cdecl sub_806B4DE(float a1, float *a2, float *a3);
double *__cdecl sub_806B4F6(double a1, double *a2, double *a3);
char *__cdecl sub_806B538(char *s, char *a2, int a3);
int __cdecl sub_806B606(int, char *, int); // idb
int __cdecl sub_806B926(int a1, int a2, int a3);
int __cdecl sub_806BA16(int a1, int a2);
time_t __cdecl sub_806BA76(int *a1);
void __cdecl sub_806BB25(void *ptr);
void *__cdecl sub_806BB38(size_t size);
char *__cdecl sub_806BB76(char *s);
void sub_806BBAA();
void sub_806BD7F();
void sub_806C0C7();
int sub_806C1F1();
_DWORD *sub_806C20A();
int sub_806C267();
_DWORD *sub_806C2B1();
int sub_806C2F1();
_DWORD *sub_806C300();
void *sub_806C31C();
int *sub_806C394();
void sub_806C3AB();
void *__cdecl sub_806C3D4(size_t n);
void *__cdecl sub_806C3EF(size_t n, int a2);
int __cdecl sub_806C4B7(int a1);
int sub_806C522();
void *__cdecl sub_806C531(size_t n);
void *__cdecl sub_806C54C(size_t n, int a2);
int sub_806C5F1();
_DWORD *__cdecl sub_806C600(size_t size);
int __cdecl sub_806C6D0(int a1);
int sub_806C724();
int sub_806C733();
void __cdecl sub_806C742(void *ptr);
int sub_806C79D();
int __cdecl sub_806C7E4(_BYTE *a1);
int __cdecl sub_806C82A(char *a1);
int __cdecl sub_806C8BA(int, float); // idb
int __cdecl sub_806C93D(int, int, float); // idb
char *__cdecl sub_806C9C8(char *dest, int a2);
int __cdecl sub_806CAE6(char *a1);
int __cdecl sub_806CC0F(char *a1);
int __cdecl sub_806CC85(char *a1);
_BOOL4 __cdecl sub_806CCFB(char *s, char *src);
void __cdecl sub_806D096(char *s1, int a2);
void __cdecl sub_806D0F8(char *a1, char *s, int a3, int a4, int a5);
void __cdecl sub_806D4AE(int a1);
int __cdecl sub_806D686(_DWORD *a1);
int __cdecl sub_806D6FC(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_806D851(char *, char *haystack, int, int); // idb
int __cdecl sub_806DAE7(int a1, _DWORD *a2);
int __cdecl sub_806DCF2(int a1, int a2);
int __cdecl sub_806E081(char *s, int, int); // idb
void __cdecl sub_806E108(void *ptr);
_DWORD *__cdecl sub_806E15E(char *a1, int *a2);
void __cdecl sub_806E35A(char *s2, int a2);
int __cdecl sub_806E5C2(int a1);
int __cdecl sub_806E663(int a1, int a2);
float *__cdecl sub_806E6A2(int a1, int a2);
int __cdecl sub_806E89C(int a1, int a2);
int __cdecl sub_806E8FA(char *a1);
char *__cdecl sub_806EA00(char *a1);
size_t __cdecl sub_806EB5F(char *a1, char *a2, int a3);
void __cdecl sub_806EC2B(int a1, char *a2);
void __cdecl sub_806EF7E(char *a1);
void __cdecl sub_806FA62(char *filename, char *a2);
_BYTE *__cdecl sub_806FDA0(_BYTE *a1);
char *__cdecl sub_806FDE8(char *a1, int a2, int a3);
int sub_806FE21();
void __cdecl sub_806FE5F(int a1, char *s);
void Com_Printf(char *format, ...);
int Com_DPrintf(char *format, ...);
void __cdecl sub_80702FC(const char *a1);
void *sub_807032A();
void sub_8070435();
int sub_807044F();
void sub_8070466();
int __cdecl sub_8070475(char *s1);
void __noreturn sub_80704AC(int a1, char *format, ...);
int sub_807066C(void); // weak
char *__cdecl sub_80706B8(char *a1);
int sub_8070717();
int __cdecl sub_80707BC(char *s2); // idb
int sub_807088E();
void __cdecl Info_Print(char *a1);
void sub_8070A72();
_DWORD *__stdcall sub_8070B87(_DWORD *a1);
void *sub_8070CFE();
int __cdecl sub_8070D36(int *a1);
_DWORD *__stdcall sub_8070E61(_DWORD *a1);
void __cdecl SV_PacketEvent(_DWORD *a1, int a2);
int sub_8070F7C();
int sub_807123E();
void __noreturn sub_807129B();
void sub_80712D7();
void sub_8071344();
char *sub_8071353();
char *sub_807136F();
int __cdecl sub_8071439(int a1, int a2);
int sub_8071489();
void sub_80714EC();
int sub_80714F1();
void __cdecl sub_807154E(char *a1);
void __cdecl sub_8071B45(char *src);
void __cdecl sub_8071BAA(char *src);
void sub_8071C04();
void sub_8071C38();
void sub_8071CB4();
int __cdecl sub_8071D30(int a1);
int __cdecl sub_8071DC1(int a1);
int sub_8071E2E();
void sub_80720E4();
_DWORD *__cdecl sub_8072140(_DWORD *a1);
char *__cdecl sub_8072183(char *src);
void __cdecl sub_8072237(char *a1);
int sub_8072279();
char *__cdecl sub_8072359(char *haystack, char *needle);
char *__cdecl sub_80723B4(char **a1);
int __cdecl sub_80725CB(int a1);
int sub_8072603();
int __cdecl sub_8072755(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5);
int __cdecl sub_80727E5(int a1, int a2);
int __cdecl sub_8072884(int a1, int a2);
void *sub_80729AC();
void sub_8072A1C();
void *sub_8072A36();
void *__cdecl sub_8072A66(size_t a1);
void *__cdecl sub_8072A79(size_t a1);
_DWORD *__cdecl sub_8072A9F(int a1);
int __cdecl sub_8072ABA(int a1);
_DWORD *__cdecl sub_8072AD5(int a1);
int __cdecl sub_8072AF0(int a1);
int __cdecl sub_8072B0B(signed int a1, _DWORD *a2, int a3);
int __cdecl sub_8072B74(int a1, int a2);
int sub_8072DCA();
const char *sub_8072DD4();
int __cdecl sub_8072DDE(_BYTE *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8072EB8(int a1);
_BOOL4 __cdecl sub_8072F2D(char *s);
int __cdecl sub_8072FAE(char *a1);
unsigned int *sub_807300E();
int *__cdecl sub_8073114(char *s, char *s2, int a3);
int __cdecl sub_8073440(char *s, char *s1, int); // idb
int __cdecl sub_8073798(char *s, char *s1); // idb
int __cdecl sub_80737F5(char *s, char *s1); // idb
int __cdecl sub_8073817(char *, float); // idb
int __cdecl sub_80738B1(char *s); // idb
int *__cdecl sub_80738D4(int a1, char *s, char *s2, int a4);
int *__cdecl sub_807392B(int a1);
void sub_8073A2F();
int sub_8073A7E();
long double __cdecl sub_8073AB4(char *a1);
int __cdecl sub_8073AE3(char *a1);
void *__cdecl sub_8073B14(char *a1);
char *__cdecl sub_8073B45(int a1, char *dest, int a3);
int __cdecl sub_8073B85(void (__cdecl *a1)(_DWORD));
int sub_8073C1A();
void sub_8073CD5();
void sub_8073E28();
void sub_8073F0A();
void sub_8073F5D();
void sub_8073FB0();
void sub_8074003();
void sub_8074077();
const char **__cdecl sub_80740AB(int a1);
int __cdecl sub_8074190(int a1);
void sub_8074236();
void sub_8074414();
void __cdecl sub_8074428(int a1);
int __cdecl sub_80745C5(char *s, char *s1); // idb
int sub_8074714();
int __cdecl sub_807480C(int a1, int a2, int a3);
char *__cdecl sub_8074863(int a1);
char *__cdecl sub_80748C0(int a1);
void sub_8074948();
int __cdecl sub_8074A18(char *); // idb
int __cdecl sub_8074C2E(char *src, int); // idb
void *__cdecl sub_8075080(char *s, char a2);
int __cdecl sub_8075187(char *haystack, int); // idb
int __cdecl sub_8075308(_DWORD *a1);
_DWORD *__cdecl sub_8075335(void *ptr, void *a2, void *a3);
int __cdecl sub_8075464(char *, int); // idb
void sub_807596B();
void sub_8075A5F();
void sub_8075B4E();
int __cdecl sub_8075B82(char *haystack, int, int); // idb
_BOOL4 __cdecl sub_8075E57(char *src);
void sub_80761EE();
_DWORD *sub_807625A();
char *sub_8076302();
char *sub_807637A();
char *sub_8076406();
char *sub_807647E();
char *sub_8076564();
void *__cdecl sub_807683D(char **a1, char **a2);
int __cdecl sub_8076BFF(char a1, int a2);
int __cdecl sub_8076C68(int a1);
_DWORD *__cdecl sub_8076C9B(int a1);
_DWORD *__cdecl sub_8076CEB(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8076D0A(int a1, int a2, int a3);
int __cdecl sub_8076D92(int a1, int a2);
void __cdecl sub_8076E52(int a1, int a2);
void __cdecl sub_8076FB9(_DWORD *a1, unsigned __int8 a2);
int __cdecl sub_807723E(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_807729F(_DWORD *a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_807730F(int a1, int a2, int a3);
int *__cdecl sub_8077375(int a1, int a2, int a3);
int __cdecl sub_80773F8(int a1, int a2, int a3, int *a4);
unsigned __int8 *__cdecl sub_8077435(_DWORD *a1, int a2);
unsigned __int8 *__cdecl sub_8077662(int a1, int a2);
int __cdecl sub_807780C(void *s); // idb
long double __cdecl sub_80779A4(char *a1);
char **__cdecl sub_8077A61(char *s);
void __cdecl sub_8077AD2(int a1);
int __cdecl sub_8077B40(char *a1);
char **__cdecl sub_8077BED(char *a1, char *s);
long double __cdecl sub_8077C9D(char *a1, char *s);
void __cdecl sub_8077DAC(char *filename);
void sub_8077E8B();
int sub_8077EF9(char *format, ...);
_DWORD *__cdecl sub_8077F64(int a1);
_DWORD *__cdecl sub_8077FA7(size_t n);
_DWORD *__cdecl sub_8077FDA(int a1);
void __cdecl sub_8078050(int a1);
void sub_8078084(int a1, char *format, ...);
void sub_80780EA(int a1, char *format, ...);
_DWORD *__cdecl sub_8078150(_DWORD *a1, int a2, int a3);
void __cdecl sub_80781C1(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void __cdecl sub_807825C(int a1, int a2);
void sub_80782D6();
_DWORD *__cdecl sub_80782DB(void *src);
void __cdecl sub_807834B(int a1);
int __cdecl sub_8078364(int, void *dest); // idb
int __cdecl sub_80784B9(int, void *src); // idb
int __cdecl sub_80784F2(int a1, const char **a2, int a3, int a4);
int __cdecl sub_8078899(int, char *dest); // idb
int __cdecl sub_8078957(char *dest, char *src); // idb
int __cdecl sub_8078A71(int a1);
int *__cdecl sub_8078AD0(int *a1, int a2);
int __cdecl sub_8078B11(int, char *s2); // idb
int __cdecl sub_8078B77(int, char *s2); // idb
int __cdecl sub_8078BC2(int, char *s2); // idb
void __cdecl sub_8078C1D(int a1);
int __cdecl sub_8078D8D(int, void *src, int, int, int); // idb
int __cdecl sub_8079003(int, void *, int, int, int); // idb
int __cdecl sub_80794BD(int, void *, int); // idb
char *__cdecl sub_8079536(char *a1);
int __cdecl sub_80795BF(int a1);
int __cdecl sub_807983D(int, char *s1); // idb
_BOOL4 __cdecl sub_80798BC(int a1);
_DWORD *__cdecl sub_80798EB(_DWORD *a1);
int __cdecl sub_8079917(int a1);
int __cdecl sub_8079AD6(int a1);
int __cdecl sub_807A072(char *s); // idb
char **__cdecl sub_807A318(int a1, int a2);
int __cdecl sub_807A473(int a1);
int __cdecl sub_807A4C3(_DWORD *a1, int a2);
int __cdecl sub_807A5B9(_DWORD *a1);
int __cdecl sub_807A5D4(_DWORD *a1);
int __cdecl sub_807A5EF(_DWORD *a1);
int __cdecl sub_807A67F(_DWORD *a1);
int __cdecl sub_807A6CC(int a1);
int __cdecl sub_807A7DB(int a1, char *a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_807B78A(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_807BADD(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_807BE92(_DWORD *a1);
int __cdecl sub_807BF3D(_DWORD *a1);
int __cdecl sub_807BFA5(int a1);
int __cdecl sub_807BFC5(int a1);
int __cdecl sub_807C01D(int a1);
int __cdecl sub_807C059(int a1);
int __cdecl sub_807C0D1(int a1);
int __cdecl sub_807C1B3(int a1);
int __cdecl sub_807C29D(int a1);
int __cdecl sub_807C3B9(int a1);
int __cdecl sub_807C4A7(int a1);
int __cdecl sub_807C5D3(int a1);
int __cdecl sub_807C704(int, char *s); // idb
int __cdecl sub_807CCC5(int, char *s2); // idb
int __cdecl sub_807CE4B(int, void *src); // idb
_DWORD *__cdecl sub_807CEE6(char *src);
void __cdecl sub_807D0CC(_DWORD *a1);
int __cdecl sub_807D4E4(int a1, int a2);
void sub_807D6B4(int a1, char *format, ...);
void sub_807D71D(int a1, char *format, ...);
int __cdecl sub_807D786(int a1, int a2);
int __cdecl sub_807D7D6(int a1);
int __cdecl sub_807D926(int a1, char *a2);
int __cdecl sub_807DB3D(_DWORD *a1, int a2, int a3);
int __cdecl sub_807DD60(int a1, int a2);
int __cdecl sub_807DE20(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4);
int __cdecl sub_807E0D4(int a1, int a2);
int __cdecl sub_807E624(int, char *dest); // idb
int __cdecl sub_807E702(int a1, void *src);
int __cdecl sub_807E7AA(_DWORD *a1, void *dest);
int __cdecl sub_807EAEB(_DWORD *a1, int a2, int a3, void *a4);
int __cdecl sub_807EE15(_DWORD *a1, void *dest);
char *__cdecl sub_807F01D(char *dest);
_BOOL4 __cdecl sub_807F2B0(int a1);
int *__cdecl sub_807F353(char *src);
_DWORD *__cdecl sub_807F4F1(void *a1, size_t n, char *src);
void __cdecl sub_807F5D9(int a1);
int __cdecl sub_807F603(char *format); // idb
_DWORD *__cdecl sub_807F628(_DWORD *a1);
void *__cdecl sub_807F668(int a1, void *src, int a3);
void *__cdecl sub_807F764(int a1, void *s);
void *__cdecl sub_807F825(int *a1, int a2);
unsigned int __cdecl sub_807FF31(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_807FFD9(int a1, int a2, unsigned int a3);
int __cdecl sub_8080055(void *src, int); // idb
int sub_80800B1(void *a1, int a2, ...);
int __cdecl MSG_Init(void *s, int, int); // idb
int __cdecl sub_808016F(int a1);
int __cdecl sub_8080188(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_808024E(_DWORD *a1);
_DWORD *__cdecl sub_80802AB(_DWORD *a1);
int __cdecl sub_8080344(_DWORD *a1, int a2);
int __cdecl sub_80803C6(_DWORD *a1);
int __cdecl sub_808041F(unsigned __int8 *a1, int a2, int a3);
_BYTE *__cdecl sub_8080473(int a1, _BYTE *a2, int a3);
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2);
int __cdecl MSG_WriteData(int, void *src, size_t n); // idb
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2);
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2);
int __cdecl sub_8080607(int, char *s); // idb
int __cdecl MSG_WriteBigString(int, char *s); // idb
_DWORD *__cdecl sub_8080815(int a1, float a2);
int __cdecl sub_8080857(_DWORD *a1);
int __cdecl sub_8080897(_DWORD *a1);
int __cdecl sub_80808EC(_DWORD *a1);
void *__cdecl sub_808093F(_DWORD *a1);
void *__cdecl sub_8080A16(_DWORD *a1);
long double __cdecl sub_8080A8C(_DWORD *a1);
_DWORD *__cdecl sub_8080B8D(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8080BD1(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8080C19(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8080C3D(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_8080C6A(_DWORD *a1, char a2, char a3, char a4);
int __cdecl sub_8080CA8(_DWORD *a1, char a2, int a3);
_DWORD *__cdecl sub_8080CDE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_8080D1C(_DWORD *a1, __int16 a2, int a3);
_BYTE *__cdecl sub_8080D54(char *s, int a2, int a3);
void *__cdecl sub_8080E16(int a1, void *s);
int __cdecl sub_8080FA3(int a1, int a2);
int __cdecl sub_8080FE9(int a1);
_BYTE *__cdecl sub_8081015(char a1, _BYTE *a2, _BYTE *a3);
_BYTE *__cdecl sub_808106E(char a1, _BYTE *a2);
_BYTE *__cdecl sub_80814CE(_DWORD *a1, int a2, int a3, int a4);
int *__cdecl sub_8081850(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8081A7E(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__cdecl sub_8081B38(_DWORD *a1, int *a2, int *a3, int a4, int a5, int a6, int a7, void (__cdecl *a8)(_DWORD *, int *), int a9);
_DWORD *__cdecl sub_8081D54(_DWORD *a1, int a2);
_DWORD *__cdecl MSG_WriteDeltaEntity(_DWORD *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl sub_8081E9C(_DWORD *a1, int *a2, int *a3, int a4);
_DWORD *__cdecl sub_8081EF2(_DWORD *a1, int *a2, int *a3, int a4);
int __cdecl sub_8081F72(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl sub_808219A(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_808224C(int, void *src, void *dest, int, int, int, int); // idb
int __cdecl sub_808249A(int, void *src, void *dest, int); // idb
int __cdecl sub_80824E0(int, void *src, void *dest, int); // idb
int __cdecl sub_8082550(_DWORD *a1, int a2, int a3, int a4);
void *__cdecl sub_80826C7(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8082826(_DWORD *a1, char *a2, _DWORD *a3);
int __cdecl sub_80830ED(int a1, char *a2, char *a3);
int *sub_80837EB();
int __cdecl sub_8083869(__int16 a1);
int __cdecl sub_808387C(int a1);
void *__cdecl sub_8083884(void **a1);
int __cdecl sub_8083973(int a1, int a2, int a3);
int __cdecl sub_80839F9(_DWORD *a1, int a2, int a3);
void __cdecl sub_8083A7A(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_8083B00(_DWORD *a1);
void sub_8083E34();
void __cdecl sub_8083E5F(unsigned __int16 a1);
void *__cdecl sub_8083F57(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8);
int *__cdecl sub_8083FD0(int *a1);
int *__cdecl sub_80841CE(int a1, size_t n, void *src);
int __cdecl sub_8084378(int a1, _DWORD *a2);
int __cdecl sub_8084802(int a1, int a2);
_BOOL4 sub_80848CB(char a1, int a2, int a3, int a4, int a5, ...);
char *__cdecl sub_80848F8(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80849FE(int a1, int a2);
_BOOL4 sub_8084AF7(char a1, int a2, int a3, int a4, int a5, ...);
int __cdecl sub_8084B24(int a1);
int __cdecl sub_8084B49(int, void *s, int); // idb
size_t __cdecl sub_8084C4C(int a1, size_t n, void *src);
void *__cdecl sub_8084CBF(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8);
void *sub_8084D76(int a1, int a2, int a3, int a4, int a5, int a6, char *format, ...);
void *__cdecl sub_8084F14(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n);
int __cdecl sub_8084FC8(char *s1, void *s); // idb
int __cdecl sub_8085130(int a1);
void sub_8085138();
int *sub_808513D();
void sub_8085187();
void sub_808518C();
void sub_8085191();
void sub_8085196();
void sub_808519B();
void sub_80851A0();
void sub_80851A5();
int sub_80851AA();
void sub_80851B4();
int sub_80851B9();
void sub_80851C3();
void sub_80851C8();
void sub_80851D2();
void sub_80851D7();
void sub_80851DC();
void sub_80851E1();
void sub_80851E6();
int sub_80851EB();
void sub_80851FC();
void sub_8085201();
void sub_8085206();
void sub_808520B();
char *__cdecl sub_808521C(char *src);
_DWORD *sub_80852BD();
void *sub_8085301();
int __cdecl sub_808533D(int a1);
void __noreturn sub_8085375(char *format, ...);
void sub_80853DD(char *format, ...);
int sub_808543D();
_BYTE *__cdecl sub_8085522(_BYTE *a1, _DWORD *a2);
int __cdecl sub_8085575(_BYTE *a1);
int sub_80856B1();
void *__cdecl sub_80856BB(_BYTE **a1, int a2);
void *__cdecl sub_8085836(char **a1, int a2);
void *__cdecl sub_8085E0B(char **a1);
void *__cdecl sub_8085E6A(char **a1);
void __cdecl sub_8085EE7(int a1, char *s2, int a3);
_BYTE *__cdecl sub_8085FBA(_DWORD *a1);
void __cdecl sub_80860E5(char **a1, int a2, int a3);
void __cdecl sub_808616B(char **a1, int a2, int a3, int a4);
_BYTE *__cdecl sub_80862D9(_BYTE *a1);
char *__cdecl sub_808637A(char *s, size_t maxlen, int a3);
int __cdecl sub_808649A(__int16 a1);
int __cdecl sub_8086556(__int16 a1);
int __cdecl sub_808658D(__int16 a1);
int __cdecl sub_80865A0(int a1);
int __cdecl sub_80865FC(int a1);
// _DWORD *__userpurge sub_8086604@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge sub_8086662@<eax>(_DWORD *a1, int a2, int a3);
long double __cdecl sub_8086686(int a1);
long double __cdecl sub_80866B9(float a1);
void sub_80866CA();
_BOOL4 __cdecl sub_80867AA(int a1);
_BOOL4 __cdecl sub_80867F8(int a1);
_BOOL4 __cdecl sub_808682D(int a1);
_BOOL4 __cdecl sub_8086854(int a1);
char *__cdecl Q_strncpyz(char *dest, char *src, int a3);
int __cdecl sub_8086946(char *a1, char *a2, int a3);
int __cdecl sub_80869EB(char *a1, char *a2, int a3);
int __cdecl sub_8086A5A(char *a1, char *a2);
_BYTE *__cdecl sub_8086A97(_BYTE *a1);
_BYTE *__cdecl sub_8086AD1(_BYTE *a1);
char *__cdecl sub_8086B0B(char *s, int a2, char *src);
int __cdecl sub_8086B5E(_BYTE *a1);
char *__cdecl sub_8086BC6(char *a1);
int __cdecl sub_8086C4E(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
int __cdecl sub_8086CCC(char *a1, char *a2, int a3);
int __cdecl sub_8086D56(char *a1, char *a2);
char *sub_8086D78(char *format, ...);
void *__cdecl sub_8086E7F(char *s, int a2);
char *__cdecl sub_8087087(char *s, char *s1);
char *__cdecl sub_80871B9(char *s, char *s1);
char *__cdecl sub_808733D(char *s, char *s1, int a3);
void __cdecl sub_8087570(char *s, char *s1, int a3);
long double __cdecl sub_80879CA(float a1);
void __cdecl sub_8087A07(int a1, int a2, float a3, float a4, float a5);
int sub_8087D42();
long double __cdecl sub_8087DCE(float a1);
char *sub_8087DE8();
char *sub_8087EFF();
char *__cdecl sub_8088020(char *s);
void sub_80880C9();
void SV_MapRestart();
void *sub_8088655();
_DWORD sub_80886E5(); // weak
int __cdecl sub_8088AEC(int, char *dest, int); // idb
int __cdecl sub_8088B8A(char *dest, int); // idb
int __cdecl sub_8088C9E(char *dest, int); // idb
int sub_8088D2B();
void sub_8088D74();
void sub_8088DC8();
void sub_8088E1C();
int sub_8088E50();
int sub_8088E6C();
int sub_8088E88();
void sub_8088ED1();
void sub_8089169();
void sub_808921B();
void sub_8089336();
void sub_8089345();
void sub_808936D();
void SV_DumpUser_f();
void sub_8089404();
void sub_8089418();
int sub_8089425();
int sub_8089432();
void sub_808943F();
void sub_80894AA();
void sub_8089515();
void sub_8089580();
void sub_808977C();
void sub_8089781();
void __cdecl sub_80897D4(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_8089C3F(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_8089D79(int a1);
int __cdecl sub_8089DFC(int a1);
unsigned int sub_8089E9A();
int __cdecl sub_8089EF9(int a1);
int __cdecl sub_8089F25(int a1);
void __cdecl sub_808A021(char *src);
void __cdecl sub_808A1C5(char a1, int a2, int a3, int a4, int a5);
int __cdecl sub_808ABB3(int a1);
void sub_808AC2B();
void __cdecl SVC_DirectConnect(int a1, int a2, int a3, int a4, int a5);
int sub_808B9B5();
void __cdecl SV_DropClient(int drop, int a2);
_DWORD *__cdecl sub_808BBFF(_DWORD *a1, _DWORD *a2);
void __cdecl sub_808BC22(int a1, int a2);
void *__cdecl SV_SendClientGameState(char *client);
int __cdecl SV_ClientEnterWorld(char *client, _DWORD *cmd); // idb
int *__cdecl sub_808C016(int a1);
int *__cdecl SV_StopDownload_f(int a1);
void *__cdecl sub_808C0EF(int a1);
int __cdecl sub_808C11A(int a1);
void __cdecl sub_808C159(int client);
char *__cdecl sub_808C25D(int a1);
void __cdecl sub_808C298(int a1);
int __cdecl sub_808C503(int a1, _DWORD *a2);
int sub_808C54F();
int __cdecl SV_WriteDownloadToClient(int client, int msg); // idb
void __cdecl sub_808CF08(int a1);
int __cdecl sub_808CF23(int a1);
int __cdecl sub_808D2B5(int a1);
const char *__cdecl SV_UserInfoChanged(int a1);
_DWORD __cdecl sub_808D514(_DWORD); // weak
_DWORD __cdecl SV_ExecuteClientCommand(_DWORD, _DWORD, _DWORD); // weak
int __cdecl SV_ClientCommand(int client, int a2); // idb
void __cdecl sub_808D829(char *client, int *a2);
void __cdecl SV_UserMove(char *client, int a2, int delta);
void __cdecl SV_ExecuteClientMessage(int client, _DWORD *msg);
int sub_808DE54();
int __cdecl SV_GentityNum(int a1);
int __cdecl sub_808E105(int a1);
int __cdecl sub_808E122(int *a1);
int __cdecl sub_808E16C(int a1);
int __cdecl sub_808E19A(int a1, int a2, const char *a3);
void __cdecl sub_808E20D(int a1, int a2);
int __cdecl sub_808E247(_DWORD *a1);
_BOOL4 __cdecl sub_808E2E9(float *a1, float *a2);
int __cdecl sub_808E3A9(float *a1, int a2);
_BOOL4 __cdecl sub_808E60E(float *a1, float *a2);
int __cdecl sub_808E693(int *a1, int a2);
int __cdecl sub_808E6DC(int *a1, int *a2, int a3, int a4);
char *__cdecl sub_808E759(char *dest, int a2);
void *__cdecl sub_808E7A4(size_t a1);
void *__cdecl sub_808E7D4(size_t a1);
void *__cdecl sub_808E804(size_t n, int a2);
void *__cdecl sub_808E83B(size_t n, int a2);
_DWORD *__cdecl sub_808E872(size_t size);
void __cdecl sub_808E885(void *ptr);
int __cdecl sub_808E898(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_808E8C5(int a1, _DWORD *a2);
int __cdecl sub_808E952(int a1);
int __cdecl sub_808E963(char *s1); // idb
void __cdecl sub_808E9E3(int a1);
int __cdecl sub_808EA25(int a1, int a2);
int __cdecl sub_808EAA2(int a1, int a2);
int __cdecl sub_808EB1F(int a1, float a2, int a3);
void __cdecl sub_808EB63(int a1, float a2);
int __cdecl sub_808EB93(int a1, int a2, int a3);
int *__cdecl sub_808EBC2(int a1, int a2);
int *__cdecl sub_808EBEA(int a1, int a2);
int __cdecl sub_808EC12(int a1);
int __cdecl sub_808EC33(int, char *s); // idb
int __cdecl sub_808EC70(int a1);
void __cdecl sub_808EC99(int a1);
int __cdecl sub_808ECC2(int a1);
int __cdecl sub_808ECE3(int a1, int a2, int a3);
int __cdecl sub_808ED12(int a1, int a2, int a3);
int __cdecl sub_808ED41(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_808ED70(int a1);
void sub_808EE3D();
_BOOL4 __cdecl sub_808EE42(char *s);
void *sub_808EE92();
int __cdecl sub_808EEA4(int a1);
int sub_8090B57(void); // weak
_DWORD __cdecl sub_8090BBB(_DWORD, _DWORD); // weak
_DWORD __cdecl sub_8090C91(_DWORD); // weak
_DWORD __cdecl sub_8090CCE(_DWORD); // weak
int sub_8090D65(void); // weak
char *__cdecl sub_8090DA8(int a1, char *s1);
char *__cdecl sub_8090F8C(int a1, char *dest, int a3);
const char *__cdecl sub_8091016(int a1);
char *__cdecl sub_80910B8(int a1, int a2, char *s1, char *a4);
char *__cdecl sub_8091153(int a1, char *src);
char *__cdecl sub_80911FD(int a1, char *dest, int a3);
int sub_809127F();
int __cdecl sub_80913E2(int a1);
int sub_8091473();
int sub_8091563();
void __cdecl sub_8091824(char *a1);
void *sub_809193D();
void *__cdecl sub_8091999(int a1);
void sub_8091A14();
void sub_8091A55();
int sub_8091AFD();
int __cdecl SV_SpawnServer(char *s1); // idb
int __cdecl sub_80921F6(char *s1); // idb
int *sub_8092211();
int *__cdecl sub_8092803(const char *a1);
void __cdecl sub_80928C2(const char *a1);
_BYTE *__cdecl sub_8092980(_BYTE *a1);
int __cdecl sub_8092A0E(_BYTE *a1, _BYTE *a2);
int __cdecl sub_8092A94(int a1, char *a2);
int __cdecl sub_8092BC4(int a1);
int __cdecl SV_AddServerCommand(int, int, char *s); // idb
int sub_8092F86(int a1, int a2, char *format, ...);
int *sub_809308F();
void __cdecl sub_8093159(const char *a1);
void sub_809324A();
void sub_80932AB();
_DWORD __cdecl sub_80932C9(_DWORD); // weak
void *__cdecl sub_8093316(int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_8093702(int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_809392E(int a1, int a2, int a3, int a4, int a5);
void *__cdecl sub_8093F49(char *s);
int __cdecl sub_8094031(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_80942CB(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int sub_809475B();
int __cdecl sub_8094768(int, void *s); // idb
int __cdecl sub_8094895(int, char *s); // idb
int __cdecl sub_8094930(size_t n, void *src, int); // idb
void __cdecl sub_80949F4(int a1, int a2, int a3, int a4, int a5, _DWORD *a6);
int sub_8094CAD();
int __cdecl sub_8094DE7(int a1);
int sub_8094E0D();
int sub_8094F3A();
int sub_8094FCA(void); // weak
void __cdecl sub_8095033(char *client);
int sub_809517C();
void __cdecl sub_8095202(int a1);
void __cdecl sub_80956DE(const char *a1, const char *a2);
int __cdecl sub_8095700(int a1, _BYTE *a2, int a3);
int __cdecl sub_809578A(int a1, _BYTE *a2, int a3);
int *__cdecl SV_Netchan_TransmitNextFragment(int *a1);
int *__cdecl sub_809584B(int a1, void *src, size_t n);
int __cdecl sub_8095890(int a1);
int sub_809593B();
int __cdecl sub_80959E7(int a1);
int __cdecl sub_80963B4(int a1, int a2, int a3, int a4, _DWORD *a5);
_DWORD *__cdecl sub_8096527(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl SV_WriteSnapshotToClient(_DWORD *a1, int a2);
_DWORD *__cdecl SV_UpdateServerCommandsToClient(_DWORD *client, int msg); // idb
int __cdecl sub_80969C1(_DWORD *a1, _DWORD *a2, signed int a3);
int __cdecl sub_8096A94(int a1);
_DWORD *__cdecl sub_8096B4B(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8096B71(int a1, _DWORD *a2);
int __cdecl sub_8096B97(float *a1, int a2, _DWORD *a3);
_DWORD __cdecl sub_8096F2B(_DWORD); // weak
int __cdecl sub_8096F4F(int a1, int a2, float *a3, int a4, _DWORD *a5, int a6);
_DWORD __cdecl sub_8097250(_DWORD); // weak
_DWORD __cdecl sub_8097274(_DWORD, _DWORD); // weak
_DWORD *__cdecl sub_809729F(int a1);
_DWORD *__cdecl sub_8097D7D(int *a1);
_DWORD __cdecl sub_8097E9D(_DWORD, _DWORD); // weak
int __cdecl sub_8097EC8(int a1, int a2, void *a3);
int __cdecl sub_8097F44(int a1, int *a2, int a3, void *a4);
int __cdecl sub_80982CF(char *a1);
int __cdecl sub_809899F(int a1, int a2);
size_t __cdecl SV_SendMessageToClient(int a1, int client); // idb
size_t __cdecl SV_SendClientSnapshot(_DWORD *a1);
void sub_8098E10();
int sub_8099A2C();
int __cdecl sub_8099CA0(int *a1);
int __cdecl sub_8099D49(int *a1);
void __cdecl sub_8099D77(int a1);
int __cdecl sub_8099DEE(_DWORD *a1);
int __cdecl sub_809A594(int a1, int a2);
int __cdecl sub_809A72A(int a1, int a2);
int __cdecl sub_809AC6D(int *a1, int a2);
int __cdecl sub_809AE1E(_DWORD *a1, int a2);
int __cdecl sub_809AFC9(void *a1, int a2, int *a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int *__cdecl sub_809B4F1(int *a1, int *a2, int *a3, int *a4, int *a5, int a6, int a7, int a8, int a9);
int __cdecl sub_809B8C5(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_809BB17(float *a1, int a2, int a3);
int __cdecl sub_809BC1F(float); // idb
void *sub_809BC50();
int __cdecl sub_809BC74(char a1);
int __cdecl sub_809BCDB(char *src, int); // idb
void *__cdecl sub_809BEED(void *s);
int *sub_809BF2B();
int __cdecl VM_Call(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14);
int __cdecl sub_809C040(int a1);
void __cdecl __noreturn sub_809C04E(const char *a1);
int sub_809C086();
int __cdecl sub_809C13A(int *a1, unsigned __int16 a2, unsigned __int16 a3, int a4);
int __cdecl sub_809C1F4(int *a1, unsigned __int16 a2, int a3);
int __cdecl sub_809C248(unsigned __int16 a1, unsigned __int16 a2, char a3, char a4, char a5);
_DWORD *__cdecl sub_809C60C(int a1, unsigned __int16 a2, unsigned __int16 a3);
void *__cdecl sub_809C67C(size_t n);
int __cdecl sub_809C698(unsigned __int16 a1);
int __cdecl sub_809C738(unsigned __int16 a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5);
int __cdecl sub_809C80A(int a1);
int __cdecl sub_809C85E(int a1);
int __cdecl sub_809C876(unsigned __int16 a1, unsigned __int16 a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, int a8);
int __cdecl sub_809CB02(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_809CC08(unsigned __int16 a1);
int __cdecl sub_809CCA2(char *a1, int *a2);
int __cdecl sub_809CDE8(char *a1, int a2);
_BOOL4 __cdecl sub_809CE2E(const char *a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl sub_809CEFC(int a1, int (__cdecl *a2)(int));
// _DWORD *__userpurge sub_809D1DE@<eax>(_DWORD *a1, char *a2);
int __cdecl sub_809D290(char *a1, char *s, int *a3);
int __cdecl sub_809D2F8(int a1);
_DWORD *__cdecl sub_809D31E(unsigned __int16 a1);
int __cdecl sub_809D3E0(unsigned __int16 a1, unsigned __int8 a2);
int __cdecl sub_809D436(unsigned __int8 a1, int a2, int a3);
int sub_809D4EE();
int __cdecl sub_809D512(int a1);
int __cdecl sub_809D536(unsigned __int16 a1);
int __cdecl sub_809D564(unsigned __int8 a1);
int __cdecl sub_809D590(int a1);
int __cdecl sub_809D5B4(unsigned __int16 a1);
int sub_809D5E2();
int __cdecl sub_809D606(int a1);
int __cdecl sub_809D62A(int a1);
int __cdecl sub_809D64E(int a1);
int sub_809D672();
int __cdecl sub_809D696(int a1);
int __cdecl sub_809D6C6(int a1);
int sub_809D6F6();
int sub_809D726();
int __cdecl sub_809D756(int a1);
void __cdecl sub_809D7A6(int a1);
_DWORD *__cdecl sub_809D7D6(unsigned __int16 a1, int a2);
_DWORD *__cdecl sub_809D812(unsigned __int16 a1, int a2);
int __cdecl sub_809D84E(unsigned __int16 a1);
int __cdecl sub_809D89A(unsigned __int16 a1);
void __cdecl sub_809D8E6(int a1);
void __cdecl sub_809D916(int a1);
void __cdecl sub_809D946(int a1);
void __cdecl sub_809D976(int a1);
void __cdecl sub_809D9A6(int a1);
void __cdecl sub_809D9D6(int a1);
void __cdecl sub_809DA06(int a1, int a2);
int sub_809DA40();
int sub_809DA64();
int sub_809DA88();
int sub_809DAAC();
int sub_809DAD0();
int sub_809DAF4();
int sub_809DB18();
_DWORD *__cdecl sub_809DB3C(unsigned __int16 a1);
_DWORD *__cdecl sub_809DB6C(unsigned __int16 a1);
int sub_809DB9C();
_DWORD *__cdecl sub_809DBC0(unsigned __int16 a1);
void __cdecl sub_809DBF0(int a1, int a2);
void __cdecl sub_809DC2A(int a1, int a2);
void __cdecl sub_809DC64(int a1, int a2);
int sub_809DC9E();
int __cdecl sub_809DCC2(unsigned __int16 a1, int a2);
_DWORD *__cdecl sub_809DD26(_DWORD *a1, unsigned __int16 a2, int a3);
_DWORD *__cdecl sub_809DD74(_DWORD *a1, unsigned __int16 a2, int a3);
_DWORD *__cdecl sub_809DDB6(_DWORD *a1, unsigned __int16 a2, int a3, int a4);
int __cdecl sub_809DE04(_DWORD *a1, int *a2);
int __cdecl sub_809DE42(int a1, _DWORD *a2, _DWORD *a3, int a4);
int sub_809DE8E();
void __cdecl sub_809DEB2(int a1);
void __cdecl sub_809DEE2(_DWORD *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809DF12(int *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809DF4A(int *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809DF82(int a1);
int __cdecl sub_809E01E(int *a1);
int __cdecl sub_809E062(int a1);
_DWORD *__cdecl sub_809E09E(_DWORD *a1);
int __cdecl sub_809E0E0(unsigned __int16 a1, int a2);
void __cdecl sub_809E140(int a1, int a2);
void __cdecl sub_809E45A(int a1, int a2);
int __cdecl sub_809E490(int a1, int a2, char a3, int a4);
int __cdecl sub_809E502(int a1, int a2, char a3, int a4, int a5);
int __cdecl sub_809E584(int a1, int a2, char a3, int a4);
int __cdecl sub_809E5F4(int a1, int a2, char a3, int a4);
int __cdecl sub_809E666(int *a1, int a2, char a3, int a4);
void __cdecl sub_809E6E4(_DWORD *a1, int a2, char a3, int a4, int a5);
int __cdecl sub_809E766(_DWORD *a1);
void __cdecl sub_809E792(int a1, int a2, char a3);
int __cdecl sub_809E81A(_DWORD *a1);
_DWORD *__cdecl sub_809E8A4(_DWORD *a1, int *a2, char a3);
_DWORD *__cdecl sub_809EAE0(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5);
int sub_809ED4A();
int __cdecl sub_809EEC4(unsigned __int16 a1, int a2);
int __cdecl sub_809EF3A(int a1, int a2);
int __cdecl sub_809EFBC(unsigned __int16 a1);
int __cdecl sub_809F000(unsigned __int16 a1);
_DWORD *__cdecl sub_809F056(int a1, unsigned __int8 a2);
int __cdecl sub_809F0DC(int a1);
void __cdecl sub_809F158(int a1);
_DWORD *__cdecl sub_809F1FC(_DWORD *a1, int a2);
int __cdecl sub_809F262(int *a1, int a2);
int __cdecl sub_809F30A(int a1, int a2);
void __cdecl sub_809F364(_DWORD *a1);
int __cdecl sub_809F516(int a1, int a2, int a3, int a4);
int __cdecl sub_809F596(int a1, int a2, int a3, int a4);
void __cdecl sub_809F616(int a1, int a2, unsigned __int8 a3, int a4);
void __cdecl sub_809F65C(int a1, _DWORD *a2, unsigned __int8 a3, int a4);
void __cdecl sub_809F6C6(_DWORD *a1);
void __cdecl sub_809F880(int a1);
int __cdecl sub_809F91C(int *a1, int a2);
int __cdecl sub_809F9B0(_DWORD *a1, int a2);
void __cdecl sub_809FA00(_DWORD *a1, int a2);
int __cdecl sub_809FAA6(_DWORD *a1, int a2);
int sub_809FAF6();
int sub_809FB3A();
_BOOL4 __cdecl sub_809FB82(_DWORD *a1);
_BOOL4 __cdecl sub_809FB94(int a1);
void __cdecl sub_809FBC6(int a1);
void __cdecl sub_809FC72(int a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_809FCB8(int a1);
int __cdecl sub_809FCD4(_DWORD *a1);
int sub_809FD04();
void __cdecl sub_809FD28(_DWORD *a1, int a2, int a3);
int __cdecl sub_809FD8A(_DWORD *a1, int a2, int a3);
int __cdecl sub_809FE04(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_809FECE(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80A0088(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_80A01DA(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_80A03C6(int a1, int a2);
void __cdecl sub_80A040C(int a1, int a2);
int __cdecl sub_80A0452(int a1);
int __cdecl sub_80A048E(int a1);
int __cdecl sub_80A04CA(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_80A0580(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_80A06A0(_DWORD *a1, int *a2, int a3, int a4);
void __cdecl sub_80A075C(_DWORD *a1, _DWORD *a2, int a3, int a4);
int sub_80A07AC(const void *, const void *); // idb
int __cdecl sub_80A07E8(_DWORD *a1, int a2, int a3);
void __cdecl sub_80A0A40(int a1, int a2);
void __cdecl sub_80A0AC0(_DWORD *a1, int a2);
void __cdecl sub_80A0BD2(int a1);
_DWORD *__cdecl sub_80A0C0C(int a1);
_DWORD *__cdecl sub_80A0CAE(int a1);
void __cdecl sub_80A0D50(_DWORD *a1);
int __cdecl sub_80A1140(int a1);
int sub_80A1178();
int sub_80A11EC();
int __cdecl sub_80A12FE(int a1, int a2);
void sub_80A13C2();
void sub_80A144E();
void sub_80A1512();
void __cdecl sub_80A1566(int *a1, int a2);
int __cdecl sub_80A15A2(int a1);
int __cdecl sub_80A163E(int a1, int a2);
int __cdecl sub_80A16F4(int a1, int a2);
int __cdecl sub_80A174C(int a1, int a2);
int __cdecl sub_80A182E(int a1, int a2);
int __cdecl sub_80A18BA(int a1);
int __cdecl sub_80A1932(int a1, __int16 a2);
int __cdecl sub_80A1AAC(int a1, int a2);
int __cdecl sub_80A1AC8(int a1, int a2);
int __cdecl sub_80A1AE4(int a1, int a2, int a3);
int __cdecl sub_80A1B07(int a1, int a2, int a3);
int __cdecl sub_80A1B2A(int a1);
int *__cdecl sub_80A1B3F(int a1);
int __cdecl sub_80A1F50(unsigned int a1);
int __cdecl sub_80A1F84(unsigned int a1);
int __cdecl sub_80A1FE4(_BYTE *a1);
int __cdecl sub_80A2032(int, char *s); // idb
void *sub_80A211A();
_DWORD *sub_80A2142();
int __cdecl sub_80A2150(unsigned __int16 a1);
int __cdecl sub_80A21CA(char *s); // idb
int sub_80A21EC();
int sub_80A2254();
_BOOL4 __cdecl sub_80A229A(char *a1);
unsigned int *sub_80A242E();
int __cdecl sub_80A24A2(int (__cdecl *a1)(int));
void *sub_80A24DE();
void sub_80A254A();
int __cdecl sub_80A25BC(int a1);
int sub_80A2614();
int *sub_80A2708();
int __cdecl sub_80A27CA(int a1);
int __cdecl sub_80A283E(int a1, int a2);
int __cdecl sub_80A29A2(int a1, int a2);
int __cdecl sub_80A2B7C(int a1);
int *sub_80A2CC4();
void __cdecl __noreturn sub_80A2D72(const char *a1, int a2);
int __cdecl sub_80A2DA2(int a1);
int __cdecl sub_80A2E22(int a1);
int __cdecl sub_80A2EDA(unsigned __int16 a1, int a2);
int __cdecl sub_80A2F68(int a1);
int __cdecl sub_80A2F8E(int a1, int a2);
_BOOL4 __cdecl sub_80A2FB4(int a1, int a2);
void sub_80A2FE4();
void sub_80A30EA();
void __cdecl sub_80A3226(int a1);
int __cdecl sub_80A3458(unsigned int a1, int a2);
int sub_80A3540();
unsigned int __cdecl sub_80A354A(void (__cdecl *a1)(int *, int));
int *__cdecl sub_80A360A(void (__cdecl *a1)(int *, int));
int *__cdecl sub_80A370C(void (__cdecl *a1)(int *, int));
char *sub_80A376A();
int __cdecl sub_80A3806(char *s, int, int); // idb
int __cdecl sub_80A3AAA(int a1, const char *a2, char *a3, int a4);
int __cdecl sub_80A3C34(int a1, unsigned int a2, int a3);
void __noreturn sub_80A3D50(int a1, char *format, ...);
void __noreturn sub_80A3E12(unsigned int a1, char *format, ...);
void __cdecl sub_80A3EA8(int a1, unsigned int a2, int a3, const char *a4);
void __cdecl sub_80A3F4A(unsigned int a1, int a2, const char *a3, void *a4);
// _DWORD *__userpurge sub_80A4030@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_80A4042@<eax>(_DWORD *a1, int a2);
// int *__userpurge sub_80A4054@<eax>(int *a1, int a2);
// int __userpurge sub_80A407E@<eax>(int a1, int a2, int a3);
// int __userpurge sub_80A40B2@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_80A40F0@<eax>(int a1, int a2, int a3);
// int __userpurge sub_80A4124@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80A416C@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_80A41AA@<eax>(int a1, int a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_80A41FC@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80A4244@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// int __userpurge sub_80A42A0@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_80A4306@<eax>(int a1, int a2);
// _DWORD *__userpurge sub_80A435C@<eax>(_DWORD *a1, int a2, _DWORD *a3);
// _DWORD *__userpurge sub_80A43A2@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_80A4430(unsigned __int16 a1);
int __cdecl sub_80A444C(int a1);
int __cdecl sub_80A4458(unsigned __int16 a1);
int __cdecl sub_80A448E(int a1);
int __cdecl sub_80A44BE(char *a1, unsigned int a2);
int sub_80A4572();
int __cdecl sub_80A45FC(void *s2, size_t n); // idb
int __cdecl sub_80A47E8(char *s); // idb
int __cdecl sub_80A480E(char *s); // idb
int __cdecl sub_80A4884(void *s2, int a2, size_t n);
int __cdecl sub_80A4D5C(char *s, int a2);
int __cdecl sub_80A4D9A(char *s, int); // idb
int __cdecl sub_80A4DC6(int, int, size_t n, int); // idb
int __cdecl sub_80A4E42(char *s, int, int); // idb
int __cdecl sub_80A4E80(char *s, int); // idb
int __cdecl sub_80A4EAC(unsigned __int16 a1, unsigned __int8 a2);
int __cdecl sub_80A4F00(unsigned __int16 a1);
int __cdecl sub_80A4F2C(unsigned __int16 a1, char *a2, unsigned int a3);
int __cdecl sub_80A509E(unsigned __int16 a1);
int __cdecl sub_80A50FE(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A5152(unsigned __int16 *a1, unsigned __int16 a2);
int __cdecl sub_80A5196(char *s); // idb
int __cdecl sub_80A51B4(float); // idb
int __cdecl sub_80A51FE(int a1);
int __cdecl sub_80A5248(float *a1);
unsigned int *__cdecl sub_80A52AC(unsigned int *a1);
_BYTE *__cdecl sub_80A5358(_BYTE *a1, char *a2, int a3);
int __cdecl sub_80A53FC(char *a1);
void sub_80A5448();
int __cdecl sub_80A5458(int a1);
int __cdecl sub_80A548C(int a1);
int sub_80A54C0(const void *, const void *); // idb
int sub_80A5540();
void sub_80A59C2();
int sub_80A59C8();
int sub_80A5A96();
int __cdecl sub_80A5AC8(unsigned __int16 a1);
unsigned int __cdecl sub_80A5AF0(unsigned __int16 a1);
int __cdecl sub_80A5B24(unsigned __int16 a1, int a2);
int __cdecl sub_80A5C62(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A6158(__int16 *a1, int a2);
int __cdecl sub_80A63BA(unsigned __int16 a1);
int __cdecl sub_80A64B0(unsigned __int16 a1);
int __cdecl sub_80A64E4(unsigned __int16 a1);
int __cdecl sub_80A650C(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6564(unsigned __int16 a1);
int __cdecl sub_80A65BA(unsigned __int16 a1);
int *sub_80A6864();
int __cdecl sub_80A6914(unsigned __int16 a1);
int sub_80A69FA();
int sub_80A6A28();
int __cdecl sub_80A6A5E(int a1, __int16 a2);
int sub_80A6AAC();
int __cdecl sub_80A6AEC(__int16 a1);
int __cdecl sub_80A6B34(unsigned __int16 a1);
int __cdecl sub_80A6B58(int *a1);
int __cdecl sub_80A6B96(unsigned __int16 a1);
int __cdecl sub_80A6BC6(unsigned __int16 a1);
int __cdecl sub_80A6C02(unsigned __int16 a1);
_WORD *sub_80A6C5C();
_DWORD *__cdecl sub_80A6C8C(_DWORD *a1);
int __cdecl sub_80A6CCA(int a1);
int __cdecl sub_80A6CF8(int a1);
int __cdecl sub_80A6D4E(int a1, int a2);
int __cdecl sub_80A6DA0(int a1, int a2);
_BOOL4 __cdecl sub_80A6DF2(int a1);
int __cdecl sub_80A6E18(int a1);
int __cdecl sub_80A6E2A(unsigned __int16 a1, int a2);
int __cdecl sub_80A6E5A(unsigned __int16 a1, int a2);
int __cdecl sub_80A6E88(unsigned __int16 a1, int a2);
int __cdecl sub_80A6EB6(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6EF0(unsigned __int16 a1, int a2);
int __cdecl sub_80A6F20(unsigned __int16 a1, unsigned __int16 a2);
unsigned int __cdecl sub_80A70B6(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A717C(unsigned __int16 a1, int a2);
int __cdecl sub_80A71AA(unsigned __int16 a1, int a2);
int __cdecl sub_80A71D8(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A7206(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A7240(unsigned __int16 a1, int a2);
int __cdecl sub_80A72CA(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A72FA(unsigned __int16 a1, int a2);
int __cdecl sub_80A7326(unsigned __int16 a1, int a2);
int __cdecl sub_80A7352(unsigned __int16 a1, int a2);
int __cdecl sub_80A73E6(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A7590(unsigned __int16 a1, int *a2);
int __cdecl sub_80A7600(unsigned __int16 a1, int *a2);
int *__cdecl sub_80A7646(unsigned __int16 a1);
int __cdecl sub_80A7674(unsigned __int16 a1);
int __cdecl sub_80A76C8(unsigned __int16 a1, int *a2);
int __cdecl sub_80A779A(unsigned __int16 a1, int *a2);
int __cdecl sub_80A77DE(unsigned __int16 a1, unsigned __int16 *a2);
int __cdecl sub_80A7912(unsigned __int16 *a1);
int __cdecl sub_80A79FE(unsigned __int16 a1);
int __cdecl sub_80A7A30(unsigned __int16 a1);
unsigned int __cdecl sub_80A7AA4(unsigned __int16 a1);
int __cdecl sub_80A7ACA(unsigned __int16 a1);
int __cdecl sub_80A7B26(unsigned __int16 a1);
int __cdecl sub_80A7B82(unsigned __int16 a1);
_BOOL4 __cdecl sub_80A7BB2(unsigned __int16 a1);
_BOOL4 __cdecl sub_80A7BF8(unsigned __int16 a1);
int __cdecl sub_80A7C3E(unsigned __int16 *a1);
int __cdecl sub_80A7D0A(unsigned __int16 a1);
void __cdecl sub_80A7D30(int a1, int a2);
unsigned int __cdecl sub_80A7E1A(int a1, unsigned int a2);
unsigned int sub_80A7EA4();
int __cdecl sub_80A7EFE(int, char *s, int); // idb
int __cdecl sub_80A800C(unsigned __int16 a1, int a2);
int __cdecl sub_80A806C(int a1, int a2);
int __cdecl sub_80A80E8(int a1, int a2);
int __cdecl sub_80A81B4(int *a1, unsigned __int16 *a2);
int __cdecl sub_80A8506(unsigned __int16 a1, unsigned __int16 *a2);
int __cdecl sub_80A8726(unsigned __int16 a1, int *a2);
int __cdecl sub_80A89BE(unsigned __int16 a1, int *a2);
int __cdecl sub_80A8BC4(int a1);
int __cdecl sub_80A8BE6(unsigned __int16 a1);
int __cdecl sub_80A8C30(unsigned __int16 a1);
int __cdecl sub_80A8C54(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A8D5A(int a1, int a2, int a3);
int __cdecl sub_80A8DB8(unsigned __int8 a1);
int sub_80A8DDA();
int __cdecl sub_80A8DF8(unsigned __int16 a1);
int sub_80A8E1C();
char *__cdecl sub_80A8E3C(unsigned __int16 a1);
char *__cdecl sub_80A8E80(unsigned __int16 a1);
int sub_80A8EBC();
int sub_80A8F0A();
int __cdecl sub_80A8F32(int a1);
long double sub_80A8F4E();
int __cdecl sub_80A8F70(int *a1);
_DWORD *sub_80A8FA6();
int __cdecl sub_80A8FD2(int a1);
int sub_80A8FEE();
int __cdecl sub_80A900A(int a1);
int sub_80A903A();
int __cdecl sub_80A9070(unsigned __int16 a1);
int sub_80A9098();
void *__cdecl sub_80A90C8(void *src, size_t n);
size_t __cdecl sub_80A90F4(void *dest, size_t n);
int __cdecl sub_80A9120(unsigned __int16 a1);
int __cdecl sub_80A9162(unsigned __int16 a1);
int __cdecl sub_80A91AC(int a1);
int sub_80A9242();
int __cdecl sub_80A92EC(int a1);
int __cdecl sub_80A935A(unsigned __int8 a1, int a2);
int __cdecl sub_80A9396(int a1);
long double __cdecl sub_80A93BC(char a1, unsigned __int16 a2);
long double __cdecl sub_80A942C(int a1);
char *__cdecl sub_80A9456(unsigned __int8 a1, int *a2);
char *__cdecl sub_80A94F6(int a1, unsigned int a2, char a3);
void __cdecl sub_80A95A4(int a1);
int __cdecl sub_80A963E(int a1);
void *__cdecl sub_80A96BE(unsigned __int16 a1);
long double __cdecl sub_80A97F2(unsigned __int16 a1);
long double __cdecl sub_80A9862(unsigned __int16 a1);
long double __cdecl sub_80A98F0(int a1, float *a2);
int __cdecl sub_80A99E8(unsigned __int16 a1);
int __cdecl sub_80A9B6E(unsigned __int16 a1);
int sub_80A9D06();
char *sub_80A9E28();
int sub_80A9E6E();
unsigned int sub_80A9EE0();
int sub_80A9FC0();
unsigned int sub_80A9FCE();
void sub_80AA144();
int __cdecl sub_80AA19A(char *s1, int); // idb
int __cdecl sub_80AA222(char *src); // idb
int __cdecl sub_80AA49A(char *, char *); // idb
int __cdecl sub_80AA558(unsigned __int16 a1);
int __cdecl sub_80AA574(unsigned __int16 a1);
void sub_80AA678();
int __cdecl sub_80AA6A6(int a1);
int __cdecl sub_80AA6FA(_DWORD *a1);
int __cdecl sub_80AA72C(int *a1);
int __cdecl sub_80AA74C(int *a1);
int sub_80AA76C();
int __cdecl sub_80AA818(int a1, int a2, int a3);
void sub_80AA872();
void sub_80AA88A();
int __cdecl sub_80AA8A0(int a1);
int sub_80AA8AE(void); // weak
_BOOL4 __cdecl sub_80AA922(char *a1);
int __cdecl sub_80AA9A0(int a1);
int __cdecl sub_80AAAE2(int a1);
int __cdecl sub_80AAC34(int a1);
int __cdecl sub_80AAD7C(int *a1);
int __cdecl sub_80AAE80(int *a1);
int __cdecl sub_80AAEDC(int *a1);
int __cdecl sub_80AAF38(int *a1);
_DWORD *__cdecl sub_80AAF94(_DWORD *a1);
int __cdecl sub_80AB014(int a1);
int *__cdecl sub_80AB04E(int *a1, int *a2);
int __cdecl sub_80AB0B2(int a1, int a2);
int __cdecl sub_80AB30E(int a1, unsigned __int16 *a2);
int __cdecl sub_80AB56A(int *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4, int a5);
int __cdecl sub_80AE052(int a1, int a2, __int16 a3, unsigned __int16 a4, int a5, int a6);
int __cdecl sub_80AE146(unsigned __int16 a1, int a2);
int __cdecl sub_80AE250(unsigned __int16 a1);
int __cdecl sub_80AE2B6(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80AE38A(unsigned __int16 a1);
int __cdecl sub_80AE54E(unsigned __int16 a1, unsigned __int16 a2, int *a3);
int __cdecl sub_80AEAEA(unsigned __int16 a1, unsigned __int16 a2, int a3);
int __cdecl sub_80AEBB6(int a1, int a2, unsigned __int16 a3, int a4);
int __cdecl sub_80AEC98(unsigned __int16 a1);
int __cdecl sub_80AED48(unsigned __int16 a1);
int __cdecl sub_80AEDC6(unsigned __int16 a1);
int sub_80AF004();
int __cdecl sub_80AF062(__int16 a1, char *a2, int a3);
int __cdecl sub_80AF1F2(int a1, int a2);
int __cdecl sub_80AF270(int a1, int a2, int a3, int a4);
int __cdecl sub_80AF2FC(int a1, int a2);
int __cdecl sub_80AF356(int a1, int a2, int a3, int a4);
int __cdecl sub_80AF3BE(unsigned __int16 a1);
void sub_80AF3DA();
int __cdecl sub_80AF442(int a1, int a2);
int sub_80AF484();
_BOOL4 sub_80AF5D4();
int __cdecl sub_80AF5F0(unsigned int a1);
int __cdecl sub_80AF6C6(unsigned int a1);
// unsigned __int16 *__userpurge sub_80AF762@<eax>(unsigned __int16 *a1, unsigned int a2, int a3);
// _DWORD *__userpurge sub_80AF91C@<eax>(_DWORD *a1, unsigned int a2);
long double __cdecl sub_80AFA72(unsigned int a1);
int __cdecl sub_80AFB0C(unsigned int a1);
int __cdecl sub_80AFBAA(unsigned int a1);
const char *__cdecl sub_80AFBEE(unsigned int a1);
int __cdecl sub_80AFD70(unsigned int a1);
int __cdecl sub_80AFE0E(unsigned int a1);
int __cdecl sub_80AFE52(unsigned int a1, _DWORD *a2);
int __cdecl sub_80AFF2C(unsigned int a1);
int __cdecl sub_80AFFD4(unsigned int a1, unsigned int *a2);
int __cdecl sub_80B00D0(unsigned int a1);
int __cdecl sub_80B0142(unsigned int a1);
int sub_80B01F8();
int __cdecl sub_80B0202(int a1);
int __cdecl sub_80B0226(int a1);
int __cdecl sub_80B024A(int a1);
int __cdecl sub_80B026E(int a1);
int sub_80B0292();
int __cdecl sub_80B02AC(unsigned __int16 a1);
int __cdecl sub_80B02E6(int a1, int a2);
int sub_80B030C();
int __cdecl sub_80B0336(char *s); // idb
int __cdecl sub_80B0370(char *s); // idb
int __cdecl sub_80B03AA(unsigned __int16 a1);
_DWORD *__cdecl sub_80B03E4(_DWORD *a1);
int sub_80B0416();
int sub_80B0442();
int __cdecl sub_80B0498(unsigned __int16 a1);
void __cdecl __noreturn sub_80B04E8(int a1);
void __cdecl __noreturn sub_80B051E(int a1, int a2);
void __cdecl __noreturn sub_80B055C(int a1);
void __cdecl __noreturn sub_80B05A0(int a1, int a2);
void __cdecl __noreturn sub_80B05DC(int a1);
int __cdecl sub_80B061A(int a1, int a2, int a3, int a4);
int __cdecl sub_80B0674(int a1, int a2, int a3, int a4);
int __cdecl sub_80B06B4(int a1, int a2, unsigned __int16 a3);
int __cdecl sub_80B0718(int a1);
void sub_80B0760();
unsigned __int64 sub_80B076E();
int __cdecl sub_80B0780(unsigned __int16 *a1);
int __cdecl sub_80B082E(float); // idb
long double __cdecl sub_80B085C(float a1);
unsigned __int64 sub_80B0876();
void sub_80B0892();
int __cdecl sub_80B0898(int a1);
int __cdecl sub_80B08B8(int a1, int a2);
int __cdecl sub_80B08E9(_BYTE *a1, int a2);
int __cdecl sub_80B09DE(char *s); // idb
int __cdecl sub_80B0A01(char *s); // idb
int sub_80B0A24();
int sub_80B1E14();
int sub_80B20EA();
int __cdecl sub_80B21C2(int a1);
int sub_80B227E();
int __cdecl sub_80B237F(FILE *stream); // idb
int __cdecl sub_80B23C3(int a1);
int sub_80B2422();
_DWORD *__cdecl sub_80B245F(FILE *stream, int a2);
_BOOL4 __cdecl sub_80B2528(int a1, FILE *stream);
int __cdecl sub_80B258E(int a1);
_DWORD *__cdecl sub_80B25EB(int a1, unsigned int a2);
_DWORD *__cdecl sub_80B26ED(int a1, int a2);
void __cdecl __noreturn sub_80B2792(const char *a1);
void *__cdecl sub_80B27C0(size_t size);
void *__cdecl sub_80B27D3(void *ptr, size_t size);
void __cdecl sub_80B27ED(void *ptr);
int sub_80B2800();
int __cdecl sub_80B284E(int a1, _DWORD *a2);
int sub_80B28D4();
int sub_80B28DE();
int __cdecl sub_80B5AB0(_DWORD *a1, _DWORD *a2);
unsigned int *__cdecl sub_80B685A(_DWORD *a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_80B6AE0(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_80B6B18(int a1, char *s, char *src);
int sub_80B6BC0();
int sub_80B6C0E();
int sub_80B6C2A();
int __cdecl sub_80B6C46(int a1, int a2);
int __cdecl sub_80B6C80(int a1, int a2);
int __cdecl sub_80B6CB0(int a1, int a2, int a3);
int sub_80B6CF4();
int sub_80B6D30();
int sub_80B6D6C();
void __cdecl sub_80B6DA8(char *s, int a2);
int __cdecl sub_80B6E20(char *s1, char *nptr); // idb
const char *__cdecl sub_80B6FB6(int a1, char *nptr);
int __cdecl sub_80B70A0(const char *a1);
int __cdecl sub_80B70FE(size_t n, void *src, int); // idb
int __cdecl sub_80B7124(char *cp, unsigned __int16 a2, size_t n, void *buf);
int __cdecl sub_80B715A(int a1, int a2);
int ctor_001();
int dtor_001();
char *__cdecl sub_80B71D0(int a1, char *dest, int a3);
_DWORD *__cdecl sub_80B72DC(_DWORD *a1);
int __cdecl sub_80B7330(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_80B73F0(int a1, int a2);
int __cdecl sub_80B74A0(int a1);
int __cdecl sub_80B7542(int a1);
int __cdecl sub_80B756C(int a1);
int __cdecl sub_80B7596(int a1);
_DWORD *__cdecl sub_80B75CC(_DWORD *a1);
int __cdecl sub_80B7606(int a1);
const char *__cdecl sub_80B767A(int a1);
int __cdecl sub_80B78F8(char *file); // idb
char *__cdecl sub_80B7914(int a1, char *dest, char *src);
int __cdecl sub_80B7A62(int, char *dest); // idb
int __cdecl sub_80B7AA2(int, char *src, char *); // idb
char *__cdecl sub_80B7B5A(int a1);
int __cdecl sub_80B7C18(char *filename, char *, int); // idb
int sub_80B7D84();
int sub_80B7EBA();
int sub_80B7EE4();
int __cdecl sub_80B7EF8(int (__cdecl *a1)(int));
unsigned __int16 *__cdecl sub_80B7F72(int a1);
char *__cdecl sub_80B8058(int a1, char *s, int a3, int a4);
int __cdecl sub_80B816E(const char *a1, int (__cdecl *a2)(int));
int __cdecl sub_80B9570(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_80B95E2(int a1, unsigned __int16 a2, int a3, __int16 a4, unsigned __int16 a5, __int16 a6);
_DWORD *__cdecl sub_80B966A(int a1, int a2, int (__cdecl *a3)(int));
_DWORD *__cdecl sub_80B969A(int a1, int (__cdecl *a2)(int));
int __cdecl sub_80B9700(int a1, int (__cdecl *a2)(int, int));
int __cdecl sub_80B9748(int a1);
int __cdecl sub_80B9752(int a1, int a2, int a3);
int __cdecl sub_80B9914(float, int, int, int); // idb
int __cdecl sub_80B9A32(float, int, int, int); // idb
int __cdecl sub_80B9B72(int, int, float, float, int); // idb
int __cdecl sub_80BA17A(int, int, float, float, int); // idb
int __cdecl sub_80BA782(int, int, float, int); // idb
int __cdecl sub_80BAA8A(_DWORD *a1);
int __cdecl sub_80BAB1C(int, int, float, int, float); // idb
float *__cdecl sub_80BAC12(int a1, int a2, int a3, float a4);
void __cdecl sub_80BB35C(float *a1, float *a2);
int __cdecl sub_80BB40A(int, float, int, float, float); // idb
int __cdecl sub_80BB5D0(int, float, int, float); // idb
int __cdecl sub_80BB68C(int a1);
int __cdecl sub_80BB6AE(int a1, unsigned __int16 a2);
long double __cdecl sub_80BB732(int a1);
int __cdecl sub_80BB892(int a1);
int __cdecl sub_80BBA7E(int, int, float); // idb
long double __cdecl sub_80BBB04(float a1);
long double __cdecl sub_80BBC46(unsigned __int16 *a1, int a2);
int __cdecl sub_80BBCF6(int, int, int, float, int); // idb
void __cdecl sub_80BBDAC(int a1, int a2, unsigned __int16 a3);
void __cdecl sub_80BC178(int a1, unsigned __int8 a2);
void __cdecl sub_80BC456(int a1, float a2, int a3);
int __cdecl sub_80BC94E(int a1);
int __cdecl sub_80BCA32(int a1);
void __cdecl sub_80BCC1E(int a1);
int __cdecl sub_80BCEB6(int a1);
int __cdecl sub_80BCEEA(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
long double __cdecl sub_80BCF30(unsigned __int16 *a1, unsigned __int16 *a2);
long double __cdecl sub_80BD01A(int a1, float a2);
void __cdecl sub_80BD3A0(unsigned __int16 *a1, int a2);
int __cdecl sub_80BD71E(unsigned __int16 *a1, unsigned __int16 *a2);
int __cdecl sub_80BD7E4(int a1);
void __cdecl sub_80BD884(int a1, float a2, int a3);
int __cdecl sub_80BDBDC(int, float, int, int, int); // idb
void __cdecl sub_80BE3CA(int *a1, int a2, int a3);
void __cdecl sub_80BE810(int a1, int a2, float a3, int a4, int a5, int a6);
long double __cdecl sub_80BEEF2(int a1, int a2);
long double __cdecl sub_80BEF30(int a1, int a2);
long double __cdecl sub_80BEF88(int a1, int a2);
int __cdecl sub_80BEFE0(int a1, int a2);
int __cdecl sub_80BF082(int a1, int a2);
int __cdecl sub_80BF092(int a1, int a2, int a3);
const char *__cdecl sub_80BF0A6(int a1, int a2);
int __cdecl sub_80BF0DE(int a1);
int __cdecl sub_80BF0E8(int a1);
int __cdecl sub_80BF0F4(int *a1);
void __cdecl sub_80BF11C(int *a1, float a2);
void __cdecl sub_80BF14C(int a1, float a2);
int __cdecl sub_80BF1A2(int, float, int); // idb
int *__cdecl sub_80BF2A8(int a1, int a2);
void __cdecl sub_80BF59A(int **a1);
int __cdecl sub_80BF5E2(int a1, int a2, float *a3, _DWORD *a4, int a5);
int __cdecl sub_80BF696(int a1, int a2, float *a3, _DWORD *a4);
int __cdecl sub_80BF74A(int, int, int, int, float, float); // idb
int __cdecl sub_80BF888(int, int, int, int, float); // idb
int __cdecl sub_80BF9BE(int a1, int a2);
int __cdecl sub_80BFA7C(_DWORD *a1, int a2);
int __cdecl sub_80BFAFC(_DWORD *a1, int a2);
int __cdecl sub_80BFBDC(_DWORD *a1, int a2);
void __cdecl sub_80BFC22(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BFD0C(_DWORD *a1, int a2, float a3);
int __cdecl sub_80BFD90(int, int, float); // idb
int __cdecl sub_80BFDCA(int, int, float); // idb
int __cdecl sub_80BFE3E(int, int, float, float); // idb
float *__cdecl sub_80BFFBC(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80C004A(int, int, int, float, float, int, int, int, int); // idb
int __cdecl sub_80C01D6(int, int, float, float, int, int, int, int); // idb
int __cdecl sub_80C0264(int, int, float); // idb
int __cdecl sub_80C02D8(_DWORD *a1, int a2);
int *__cdecl sub_80C0364(_DWORD *a1);
int __cdecl sub_80C0456(int a1);
int __cdecl sub_80C048C(int a1);
int __cdecl sub_80C04C2(int a1);
int __cdecl sub_80C05A2(int, float, int, int, int, int, int); // idb
int __cdecl sub_80C0804(int a1, int a2);
int __cdecl sub_80C0850(_DWORD *a1, int a2, unsigned __int8 a3);
int __cdecl sub_80C09C8(_DWORD *a1, int a2);
int __cdecl sub_80C0AA8(_DWORD *a1);
int __cdecl sub_80C0AC4(int a1, int a2);
_BOOL4 __cdecl sub_80C0B06(int a1, int a2);
char *__cdecl sub_80C0B1E(int a1, int a2, int a3);
int __cdecl sub_80C0BA8(int a1, int a2);
int __cdecl sub_80C0C82(int a1);
float *__cdecl sub_80C0C90(int a1);
int __cdecl sub_80C0D54(int a1, int a2);
int __cdecl sub_80C0E0E(int a1, int a2);
int __cdecl sub_80C0FFA(int a1, int a2);
int __cdecl sub_80C1072(int, int, float, int, int, int, int, int); // idb
int __cdecl sub_80C1120(int a1, int a2, int a3);
int __cdecl sub_80C1142(int a1, int a2);
int __cdecl sub_80C1186(int a1, int a2, __int16 a3);
float *__cdecl sub_80C11FA(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl sub_80C1340(int a1);
int __cdecl sub_80C13A6(int a1);
void __cdecl sub_80C1420(_WORD *a1);
int __cdecl sub_80C1498(unsigned __int16 *a1);
int __cdecl sub_80C151C(const void *a1, unsigned __int16 *a2);
int __cdecl sub_80C155C(int a1);
unsigned int __cdecl sub_80C15FA(int a1);
int __cdecl sub_80C1716(int a1, int a2);
long double __cdecl sub_80C1814(float a1);
int __cdecl sub_80C182E(__int16 a1);
int __cdecl sub_80C1844(int a1);
_BOOL4 __cdecl sub_80C1852(int a1);
int __cdecl sub_80C1876(__int16 *a1, __int16 *a2);
int __cdecl sub_80C1966(__int16 *a1, __int16 *a2);
void sub_80C19F4();
int __cdecl sub_80C19FA(int a1);
int *__cdecl sub_80C1A5A(int a1);
int __cdecl sub_80C1B12(int a1, int a2, __int16 **a3);
int __cdecl sub_80C1BDA(_DWORD *a1, int a2);
int __cdecl sub_80C1D6C(int a1, __int16 **a2, int (__cdecl *a3)(int));
int __cdecl sub_80C23BC(int a1);
_DWORD *sub_80C24DA();
_DWORD *sub_80C25E4();
void *__cdecl sub_80C2646(int a1);
int *sub_80C273C();
_DWORD *__cdecl sub_80C2760(_DWORD *a1, int (__cdecl *a2)(int));
_DWORD *__cdecl sub_80C2810(const char *a1, int (__cdecl *a2)(int));
int __cdecl sub_80C2ABE(const char *a1, int (__cdecl *a2)(int));
float *__cdecl sub_80C3310(int a1, char *src, int a3);
int *__cdecl sub_80C34B2(int *a1, _DWORD *a2, int (__cdecl *a3)(int));
_BOOL4 __cdecl sub_80C37F6(int a1);
int __cdecl sub_80C382C(const char *a1, int a2, int (__cdecl *a3)(int));
int __cdecl sub_80C3E74(unsigned int a1, unsigned int a2);
int __cdecl sub_80C3F5E(int a1);
int __cdecl sub_80C3F76(int a1);
int __cdecl sub_80C3F8E(int a1, __int16 a2);
int __cdecl sub_80C3FF0(int a1, _DWORD *a2, _DWORD *a3);
const char *__cdecl sub_80C409E(int a1, int a2, int a3);
int __cdecl sub_80C40F0(void **a1, int (__cdecl *a2)(int));
int __cdecl sub_80C4296(int a1);
int __cdecl sub_80C4334(int a1);
int *__cdecl sub_80C4342(int a1, int a2, int a3, void *dest, int a5);
int __cdecl sub_80C4512(int a1);
int __cdecl sub_80C45AE(int a1, float a2);
unsigned __int8 **__cdecl sub_80C4658(int a1, int a2);
int __cdecl sub_80C4892(int a1, int a2, int a3, float *a4, float *a5, int a6);
int __cdecl sub_80C4CB2(int a1, float *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80C4E86(__int16 a1);
int __cdecl sub_80C4E9A(int a1);
long double __cdecl sub_80C4EA2(float a1);
int __cdecl sub_80C4EB4(int a1);
float *__cdecl sub_80C5086(float *a1, float *a2, float *a3);
int __cdecl sub_80C5132(int, float, int, int); // idb
float *__cdecl sub_80C5204(float *a1, float *a2, float *a3);
float *__cdecl sub_80C529E(float *a1, float *a2, float *a3);
int sub_80C5338();
int sub_80C5384();
void __cdecl sub_80C53B6(int a1);
int __cdecl sub_80C557A(int a1, __int16 a2);
int __cdecl sub_80C5608(int a1);
int __cdecl sub_80C5832(int a1, int a2, int a3);
int *__cdecl sub_80C5A16(int a1, int a2);
int __cdecl sub_80C5C08(int a1, int a2);
int __cdecl sub_80C5C36(int a1, int a2);
int *__cdecl sub_80C5C96(int a1, int a2);
int __cdecl sub_80C665C(int a1, int a2);
int __cdecl sub_80C667A(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5);
int __cdecl sub_80C6962(int a1, int a2);
int __cdecl sub_80C6A24(int a1);
_BOOL4 __cdecl sub_80C6A4A(int a1, int a2);
int *__cdecl sub_80C6AC4(int a1, int *a2);
int __cdecl sub_80C6B36(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80C6B5A(int a1);
int __cdecl sub_80C6BF4(int a1, int a2, int a3);
int __cdecl sub_80C6C76(int a1, int a2, int a3);
const char *__cdecl sub_80C6DE2(int a1, int a2, int a3, int a4);
int __cdecl sub_80C6E48(int, int, void *s, int); // idb
int __cdecl sub_80C70F0(int, char *s); // idb
int __cdecl sub_80C7136(int a1, int a2);
int __cdecl sub_80C71DC(int a1);
int __cdecl sub_80C71E6(int a1);
int __cdecl sub_80C7232(int a1);
float *__cdecl sub_80C723E(float *a1, float *a2, float *a3);
float *__cdecl sub_80C72EA(float *a1, float *a2, float *a3);
int __cdecl sub_80C7394(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80C7BE8(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80C7D10(int a1, int a2, float a3);
int __cdecl sub_80C7D32(int a1, int a2);
float *__cdecl sub_80C7D82(float *a1, float *a2);
int __cdecl sub_80C7F9A(float *a1, float *a2);
int __cdecl sub_80C8056(float *a1, float *a2);
int __cdecl sub_80C818E(float *a1, float *a2);
int __cdecl sub_80C82C8(char *name); // idb
void *__cdecl sub_80C835C(void *dest, void *src, size_t n);
void *__cdecl sub_80C837D(void *s, int c, size_t n);
void sub_80C83CD();
ssize_t sub_80C83DF();
ssize_t sub_80C8408();
int sub_80C846D();
int sub_80C84B5();
int sub_80C8510();
unsigned int __cdecl sub_80C8549(_DWORD *a1);
int sub_80C8625();
int sub_80C8666();
void __cdecl __noreturn sub_80C86A5(int status); // idb
int sub_80C86E8(void); // weak
void sub_80C8749();
void __noreturn sub_80C8793(char *format, ...);
void handler();
void sub_80C88EF();
char *sub_80C8A5E();
char *__cdecl sub_80C8FC8(void *handle);
void sub_80C9010();
int sub_80C901A();
int sub_80C9024();
int sub_80C902E(void); // weak
void __noreturn sub_80C9055();
void *__cdecl sub_80C9071(const char *a1, char *dest, int a3, int a4);
void sub_80C934E();
int __cdecl sub_80C9353(int a1, int a2, int a3, int a4);
int __cdecl sub_80C9378(int, int off, int); // idb
int __cdecl sub_80C9399(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__stdcall sub_80C9445(_DWORD *a1);
int __cdecl sub_80C96E0(char *s); // idb
void sub_80C9718();
int __cdecl sub_80C9723(const char *a1);
__pid_t __cdecl sub_80C984F(char *s);
void __cdecl sub_80C98B7(char *src, int a2);
void __cdecl sub_80C9B14(int a1, const char **a2);
void __cdecl __noreturn main(int a1, char **a2);
int __cdecl sub_80C9D0C(int, void *s); // idb
int __cdecl sub_80C9D89(int a1, int a2);
int __cdecl sub_80C9DFE(char *cp, void *s); // idb
int __cdecl sub_80C9E95(char *cp, int); // idb
int __cdecl sub_80C9ED8(int *a1, int a2);
ssize_t __cdecl sub_80CA04B(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7);
ssize_t __cdecl sub_80CA149(char *cp, int a2, size_t n, void *buf);
int __cdecl sub_80CA1BC(int a1, int a2);
struct hostent *sub_80CA32D();
struct hostent *sub_80CA4FD();
void sub_80CA5E0();
int __cdecl sub_80CA62E(char *cp, int a2);
char *sub_80CA82C();
int __cdecl sub_80CA849(int a1);
int sub_80CA93C();
int __cdecl sub_80CA9C3(char *path); // idb
DIR *__cdecl sub_80CA9DE(const char *a1, const char *a2, int a3, int a4, int *a5);
void *__cdecl sub_80CAC75(char *name, char *s, int a3, int a4, int a5);
void __cdecl sub_80CB004(void *ptr);
char *sub_80CB05A();
char *__cdecl sub_80CB082(char *src);
char *sub_80CB0A5();
char *sub_80CB0F7();
char *sub_80CB13F();
void sub_80CB230();
const char *sub_80CB235();
int __cdecl sub_80CB294(float *a1, float *a2, int a3);
void __cdecl sub_80CB470(float *a1);
int __cdecl sub_80CB520(__int16 a1);
int __cdecl sub_80CB590(int a1);
int __cdecl sub_80CB5DE(FILE *stream, int); // idb
int __cdecl sub_80CB624(FILE *stream, int); // idb
int __cdecl sub_80CB668(char *a1, char *a2);
int __cdecl sub_80CB70C(char *s1, char *s2, int); // idb
size_t __cdecl sub_80CB756(FILE *stream);
_DWORD *__cdecl sub_80CB8F4(char *filename, void *src);
int *__cdecl sub_80CB95C(char *filename);
int __cdecl sub_80CBC1C(int a1);
int __cdecl sub_80CBC70(int a1, _DWORD *a2);
int __cdecl sub_80CBCAA(int a1, int *a2);
int __cdecl sub_80CBD1E(int, int, int, void *ptr, int, void *, int, void *, int); // idb
int __cdecl sub_80CC1F2(int, int, void *ptr, int, void *, int, void *, int); // idb
int __cdecl sub_80CC23E(_DWORD *a1);
int __cdecl sub_80CC2E6(_DWORD *a1);
int __cdecl sub_80CC504(int a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl sub_80CC7AC(_DWORD *a1);
int __cdecl sub_80CC9B8(int a1, int a2, unsigned int a3);
int __cdecl sub_80CCD02(int a1);
int __cdecl sub_80CCE86(int a1);
int __cdecl sub_80CD00E(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_80CD186(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_80CD256(int a1, int a2, int a3);
int __cdecl sub_80CD398(int a1, int a2, int a3);
int __cdecl sub_80CE7B2(int a1, int a2);
int __cdecl sub_80CE828(int, void *src, size_t n); // idb
_BOOL4 __cdecl sub_80CE86A(_DWORD *a1);
int __cdecl sub_80CE87C(int a1, _DWORD *a2, int a3);
int __cdecl sub_80CEA70(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10);
int __cdecl sub_80CF294(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_80CF37E(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9);
int __cdecl sub_80CF562(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80CF592(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_80CFC00(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_80CFC66(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80D09EA(int a1, int a2);
int __cdecl sub_80D0A0A(int a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_80D0C56(_DWORD *a1);
int __cdecl sub_80D0CEC(_DWORD *a1);
int __cdecl sub_80D0D68(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80D0F00(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_80D0F2A(unsigned __int8 **a1, int a2);
int __cdecl sub_80D15BE(_DWORD *a1);
void *__cdecl sub_80D1754(int a1, int a2, int a3);
void __cdecl sub_80D176C(int a1, void *ptr);
int __cdecl sub_80D1780(int a1, _DWORD *a2);
int __cdecl sub_80D17B2(int a1, int a2);
int __cdecl sub_80D1844(int a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_80D1A90(int a1, int *a2, int a3, int a4, int a5);
int __cdecl sub_80D1D28(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80D1D70(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8);
int __cdecl sub_80D226E(_DWORD *a1);
int __cdecl sub_80D24A4(int a1, __int16 a2);
size_t __cdecl sub_80D24DD(int a1);
int __cdecl sub_80D25AB(int a1, int a2);
int __cdecl sub_80D2994(int a1);
unsigned int __cdecl sub_80D2DAC(int a1, void *dest, int a3);
int __cdecl sub_80D2E60(int a1);
int __cdecl sub_80D2F6D(_DWORD *a1, unsigned int a2);
int __cdecl sub_80D31F7(int a1);
int __cdecl sub_80D3448(int *a1, int a2);
int __cdecl sub_80D43EC(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_80D44BC(int a1, int a2, int a3);
int __cdecl sub_80D45FE(int a1, int a2, int a3);
int __cdecl sub_80D5A45(int a1, int a2);
int __cdecl sub_80D5ABA(int, void *src, size_t n); // idb
_BOOL4 __cdecl sub_80D5AFB(_DWORD *a1);
int __cdecl sub_80D5B0C(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_80D5B71(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80D68DE(int a1, int a2);
int __cdecl sub_80D6900(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_80D7000(_DWORD *a1);
int __cdecl sub_80D7095(_DWORD *a1);
int __cdecl sub_80D7111(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80D72A8(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_80D72D1(unsigned __int8 **a1, int a2);
int __cdecl sub_80D7AF4(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10);
int __cdecl sub_80D8319(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_80D8402(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9);
int __cdecl sub_80D85E5(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80D8618(int a1, _DWORD *a2, int a3);
void sub_80D880C();
int __cdecl sub_80D8811(int a1);
int __cdecl sub_80D88A9(int a1);
int __cdecl sub_80D8966(int a1, int a2, int a3);
int *__cdecl sub_80D8B28(_DWORD *a1, int a2);
int __cdecl sub_80D8E64(int a1, int a2, int a3);
int __cdecl sub_80D8F1A(_DWORD *a1, int a2);
int __cdecl sub_80D92B9(_WORD *a1, int a2, int a3);
int __cdecl sub_80D944C(int a1, int a2, int a3);
int __cdecl sub_80D9E12(int a1);
int __cdecl sub_80D9ED1(int a1, int a2, int a3, int a4);
int *__cdecl sub_80DA375(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80DA4A3(int a1);
int __cdecl sub_80DA911(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80DAE1B(int a1, int a2, int a3);
bool __cdecl sub_80DB5C6(int a1);
unsigned int __cdecl sub_80DB660(unsigned int a1, int a2);
int __cdecl sub_80DB68E(int a1);
int __cdecl sub_80DB751(int a1);
int *__cdecl sub_80DB7E8(_DWORD *a1, _BYTE *a2, int a3, int a4);
void *__cdecl sub_80DB9B6(int a1, size_t nmemb, size_t size);
void __cdecl sub_80DB9D0(int a1, void *ptr);
int __cdecl sub_80DB9E4(char *filename, struct stat *stat_buf); // idb
int sub_80DBA10();
void term_proc(void); // idb

//-------------------------------------------------------------------------
// Data declarations

const char byte_80DBAA0 = '\x15'; // idb
const char byte_80DBAC3 = '\x15'; // idb
const char byte_80DBAE0 = '\x15'; // idb
const char byte_80DBB05 = '\x15'; // idb
const char byte_80DBB19 = '\x15'; // idb
const char byte_80DBB40 = '\x15'; // idb
const char byte_80DBB80 = '\x15'; // idb
const char byte_80DBBC0 = '\x15'; // idb
const char byte_80DBC00 = '\x15'; // idb
const char byte_80DBC21 = '\x15'; // idb
const char byte_80DBC40 = '\x15'; // idb
const char byte_80DBC80 = '\x15'; // idb
const char byte_80DBCC0 = '\x15'; // idb
const char byte_80DBD00 = '\x15'; // idb
const char byte_80DBD40 = '\x15'; // idb
const char byte_80DBD80 = '\x15'; // idb
const char byte_80DBDC0 = '\x15'; // idb
const char byte_80DBDE1 = '\x15'; // idb
const char byte_80DBE00 = '\x15'; // idb
const char byte_80DBE40 = '\x15'; // idb
const char byte_80DBE80 = '\x15'; // idb
const char byte_80DBEA0 = '\x15'; // idb
const char byte_80DBEE0 = '\x15'; // idb
const char byte_80DBF20 = '\x15'; // idb
const char byte_80DBF4A = '\x15'; // idb
const char byte_80DBF60 = '\x15'; // idb
const char byte_80DC0BE = '\x15'; // idb
const char aExeErrCouldntL[20] = "EXE_ERR_COULDNT_LOAD"; // idb
const char aExeErrWrongMap[29] = "EXE_ERR_WRONG_MAP_VERSION_NUM"; // idb
const char byte_80DC180 = '\x15'; // idb
const char byte_80DC1C0 = '\x15'; // idb
const char byte_80DC1EF = '\x15'; // idb
const char byte_80DC264 = '\x15'; // idb
const char byte_80DC2A0 = '\x15'; // idb
const char byte_80DC2E0 = '\x15'; // idb
const char byte_80DC410 = '\x15'; // idb
const char byte_80DC420 = '\x15'; // idb
const char byte_80DC460 = '\x15'; // idb
const char byte_80DC4C0 = '\x15'; // idb
const char byte_80DC520 = '\x15'; // idb
const char byte_80DC560 = '\x15'; // idb
const char byte_80DC5A0 = '\x15'; // idb
const char byte_80DC5E0 = '\x15'; // idb
const char byte_80DC6E0 = '\x15'; // idb
const char byte_80DC720 = '\x15'; // idb
const char byte_80DC760 = '\x15'; // idb
const char byte_80DC7A0 = '\x15'; // idb
const char byte_80DC820 = '\x15'; // idb
const char byte_80DC860 = '\x15'; // idb
const char byte_80DC8A0 = '\x15'; // idb
const char byte_80DC8E0 = '\x15'; // idb
const char byte_80DC9A0 = '\x15'; // idb
const char byte_80DC9C0 = '\x15'; // idb
const char byte_80DCA00 = '\x15'; // idb
const char byte_80DCB00 = '\x15'; // idb
_UNKNOWN unk_80DCCBC; // weak
const char byte_80DCD50 = '\x15'; // idb
const char byte_80DCD80 = '\x15'; // idb
const char byte_80DCE20 = '\x15'; // idb
const char byte_80DCE60 = '\x15'; // idb
const char byte_80DCF61 = '\0'; // idb
const char byte_80DD00D = '\x15'; // idb
const char aExeUnpureclien_0[24] = "EXE_UNPURECLIENTDETECTED"; // idb
const char byte_80DD0E0 = '\x15'; // idb
const char byte_80DD12F = '\x15'; // idb
const char byte_80DD222 = '\x15'; // idb
const char byte_80DD237 = '\x15'; // idb
const char byte_80DD6ED = '\x15'; // idb
int dword_80DD708 = 0; // weak
const char byte_80DDB00 = '\x15'; // idb
const char byte_80DDC20 = '\x15'; // idb
const char byte_80DDC55 = '\x15'; // idb
const char byte_80DDC80 = '\x15'; // idb
const char byte_80DDCC0 = '\x15'; // idb
const char byte_80DDD00 = '\x15'; // idb
const char byte_80DDD40 = '\x15'; // idb
const char byte_80DDD80 = '\x15'; // idb
const char byte_80DDEA0 = '\x15'; // idb
const char byte_80DDF00 = '\x15'; // idb
const char byte_80DDF60 = '\x15'; // idb
const char byte_80DDFB8 = '\0'; // idb
const char byte_80DDFE0 = '\x15'; // idb
const char byte_80DE040 = '\x15'; // idb
const char byte_80DE080 = '\x15'; // idb
const char byte_80DE0E0 = '\x15'; // idb
const char byte_80DE120 = '\x15'; // idb
const char byte_80DE180 = '\x15'; // idb
const char byte_80DE1E0 = '\x15'; // idb
const char byte_80DE280 = '\x15'; // idb
const char byte_80DE2C0 = '\x15'; // idb
const char byte_80DE300 = '\x15'; // idb
const char byte_80DE340 = '\x15'; // idb
const char byte_80DE380 = '\x15'; // idb
const char byte_80DE3C0 = '\x15'; // idb
const char byte_80DE400 = '\x15'; // idb
const char byte_80DE4C0 = '\x15'; // idb
const char byte_80DE620 = '\x15'; // idb
const char byte_80DE840 = '\x15'; // idb
const char byte_80DE880 = '\x15'; // idb
const char byte_80DEAD1 = '\0'; // idb
const char aExeServerFatal[24] = "EXE_SERVER_FATAL_CRASHED"; // idb
const char byte_80DEC60 = '\x15'; // idb
const char byte_80DECDC = '\x15'; // idb
const char byte_80DECF0 = '\x15'; // idb
const char aExeErrNotFound[17] = "EXE_ERR_NOT_FOUND"; // idb
const char byte_80DF191 = '\x15'; // idb
const char byte_80DF260 = '\x15'; // idb
const char byte_80DF280 = '\x15'; // idb
const char byte_80DF3E0 = '\x15'; // idb
const char byte_80DF420 = '\x15'; // idb
_UNKNOWN unk_80DF480; // weak
const char aSurialc[] = "S\x00U\x00R\x00I\x00A\x00L\x00C"; // idb
const char byte_80DF800 = '\0'; // idb
const char byte_80DF900 = '\x15'; // idb
const char byte_80E06A9 = '\0'; // idb
char *off_80E11A0 = "pos.trTime"; // weak
char *off_80E1480 = "pos.trBase[2]"; // weak
char *off_80E17C0 = "absmin[1]"; // weak
char *off_80E1C40 = "team"; // weak
char *off_80E2260 = "commandTime"; // weak
_UNKNOWN unk_80E28BA; // weak
_UNKNOWN unk_80E2A8F; // weak
const char byte_80E2BC0 = '\x15'; // idb
const char byte_80E2E40 = '\x15'; // idb
const char byte_80E2E80 = '\x15'; // idb
const char byte_80E2EA8 = '\x15'; // idb
const char byte_80E2EEB = '\x15'; // idb
const char byte_80E3075 = '\x15'; // idb
const char byte_80E30A0 = '\x15'; // idb
_UNKNOWN unk_80E30CE; // weak
const char byte_80E30E0 = '\x15'; // idb
const char byte_80E3120 = '\x15'; // idb
const char byte_80E3160 = '\x15'; // idb
const char byte_80E31A0 = '\x15'; // idb
const char byte_80E31E0 = '\x15'; // idb
const char byte_80E3220 = '\x15'; // idb
const char byte_80E3260 = '\x15'; // idb
const char byte_80E32A0 = '\x15'; // idb
const char byte_80E3300 = '\x15'; // idb
const char byte_80E3360 = '\x15'; // idb
const char byte_80E35EE = '\0'; // idb
const char asc_80E3BF2[3] = "h \""; // idb
const char byte_80E3E9B = '\0'; // idb
const char aError_2[6] = "error\n"; // idb
const char aError_3[6] = "error\n"; // idb
const char aErrorExeServer_0[33] = "error\nEXE_SERVER_IS_DIFFERENT_VER"; // idb
const char aE[3] = "e \""; // idb
const char aExeCantautodlg[21] = "EXE_CANTAUTODLGAMEPAK"; // idb
const char aExeAutodlServe[30] = "EXE_AUTODL_SERVERDISABLED_PURE"; // idb
const char aExeAutodlServe_0[25] = "EXE_AUTODL_SERVERDISABLED"; // idb
const char aExeAutodlFilen[26] = "EXE_AUTODL_FILENOTONSERVER"; // idb
const char byte_80E4E60 = '\x15'; // idb
const char byte_80E4EA0 = '\x15'; // idb
const char byte_80E4EE0 = '\x15'; // idb
const char byte_80E4F40 = '\x15'; // idb
const char byte_80E4FA0 = '\x15'; // idb
const char byte_80E5000 = '\x15'; // idb
const char byte_80E5080 = '\x15'; // idb
const char byte_80E50A8 = '\x15'; // idb
const char byte_80E50D7 = '\x15'; // idb
const char byte_80E50DB = '\x15'; // idb
const char byte_80E54C0 = '\x15'; // idb
const char byte_80E54E3 = '\0'; // idb
__int16 aXzy[3] = { 120, 122, 121 }; // weak
const char byte_80E5500 = '\x15'; // idb
const char byte_80E5540 = '\x15'; // idb
const char byte_80E5580 = '\x15'; // idb
const char byte_80E55C0 = '\x15'; // idb
const char byte_80E5600 = '\x15'; // idb
const char byte_80E5640 = '\x15'; // idb
const char byte_80E5673 = '\x15'; // idb
const char byte_80E56A0 = '\x15'; // idb
const char aExeServerresta_6[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_5[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_4[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_3[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_2[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_1[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_0[] = "EXE_SERVERRESTARTMISC"; // idb
const char byte_80E6700 = '\x15'; // idb
const char byte_80E6740 = '\x15'; // idb
const char byte_80E6780 = '\x15'; // idb
const char byte_80E67C0 = '\x15'; // idb
const char byte_80E6800 = '\x15'; // idb
const char byte_80E6840 = '\x15'; // idb
const char byte_80E6880 = '\x15'; // idb
const char byte_80E6960 = '\x15'; // idb
const char byte_80E69A0 = '\x15'; // idb
const char byte_80E6AA0 = '\x15'; // idb
const char byte_80E6AB6 = '\x15'; // idb
const char byte_80E6CC0 = '\x15'; // idb
const char byte_80E6D2D = '\x15'; // idb
_UNKNOWN unk_80E772C; // weak
const char byte_80E77E0 = '\x15'; // idb
const char byte_80E7860 = '\x15'; // idb
const char byte_80E78A0 = '\x15'; // idb
const char byte_80E7900 = '\x15'; // idb
const char byte_80E7DB4 = '\x15'; // idb
const char byte_80E7DD4 = '\x15'; // idb
const char byte_80E7DEF = '\x15'; // idb
const char byte_80E7E0B = '\x15'; // idb
const char byte_80E7E60 = '\x15'; // idb
const char byte_80E86C0 = '\x15'; // idb
__int16 word_80E8800[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  92,
  1,
  4,
  33,
  92,
  43,
  32,
  19,
  11,
  12,
  30,
  28,
  37,
  29,
  38,
  31,
  35,
  40,
  42,
  22,
  41,
  23,
  39,
  90,
  13,
  14,
  18,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  9,
  17,
  10,
  34,
  3,
  3,
  4,
  21,
  0,
  7,
  0,
  89,
  0,
  0,
  67,
  0,
  16,
  60,
  0,
  0,
  0,
  0,
  65,
  56,
  63,
  57,
  64,
  36,
  0,
  88,
  6,
  5,
  66,
  0,
  35,
  0,
  75,
  26,
  24,
  20,
  25,
  27,
  90,
  0,
  59,
  90,
  90,
  90,
  90,
  90,
  84,
  90,
  90,
  90,
  90,
  90,
  52,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  58,
  15,
  2,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  0,
  36,
  61,
  62,
  91,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  55,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  91,
  51,
  90,
  80,
  90,
  90,
  53,
  90,
  90,
  50,
  90,
  90,
  90,
  48,
  90,
  90,
  87,
  90,
  45,
  90,
  0,
  0,
  0,
  0,
  69,
  0,
  72,
  82,
  90,
  90,
  85,
  86,
  49,
  90,
  90,
  90,
  90,
  90,
  90,
  54,
  0,
  0,
  68,
  0,
  0,
  90,
  90,
  78,
  44,
  79,
  46,
  90,
  90,
  0,
  0,
  70,
  0,
  90,
  81,
  90,
  90,
  0,
  0,
  71,
  83,
  90,
  76,
  74,
  0,
  47,
  90,
  0,
  90,
  0,
  90,
  0,
  90,
  0,
  77,
  0,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_80E8A00[] = { '\0' }; // weak
char byte_80E8E00[] = { '\0' }; // weak
__int16 word_80E8F00[256] =
{
  0,
  391,
  390,
  0,
  0,
  54,
  55,
  392,
  395,
  395,
  389,
  369,
  54,
  44,
  368,
  56,
  37,
  395,
  367,
  50,
  395,
  49,
  50,
  68,
  63,
  369,
  395,
  65,
  365,
  69,
  395,
  358,
  395,
  395,
  363,
  55,
  60,
  66,
  67,
  72,
  73,
  41,
  76,
  74,
  79,
  81,
  87,
  80,
  92,
  93,
  395,
  74,
  395,
  395,
  395,
  367,
  380,
  395,
  116,
  395,
  0,
  395,
  338,
  334,
  395,
  121,
  395,
  395,
  335,
  337,
  334,
  329,
  395,
  395,
  395,
  395,
  395,
  113,
  336,
  395,
  395,
  0,
  395,
  357,
  117,
  127,
  395,
  352,
  395,
  395,
  395,
  351,
  344,
  0,
  395,
  106,
  119,
  109,
  113,
  122,
  343,
  120,
  123,
  124,
  125,
  126,
  342,
  132,
  133,
  135,
  134,
  137,
  140,
  136,
  144,
  147,
  150,
  395,
  395,
  395,
  329,
  328,
  164,
  395,
  0,
  322,
  321,
  317,
  318,
  310,
  0,
  344,
  343,
  395,
  395,
  332,
  145,
  152,
  161,
  146,
  163,
  165,
  168,
  170,
  331,
  171,
  172,
  174,
  175,
  178,
  177,
  176,
  182,
  183,
  181,
  188,
  315,
  313,
  314,
  323,
  343,
  313,
  316,
  323,
  322,
  192,
  321,
  194,
  193,
  320,
  195,
  199,
  319,
  198,
  200,
  203,
  318,
  204,
  213,
  317,
  215,
  208,
  218,
  296,
  305,
  331,
  293,
  395,
  296,
  395,
  311,
  216,
  219,
  310,
  309,
  308,
  220,
  222,
  223,
  229,
  225,
  227,
  307,
  288,
  302,
  395,
  321,
  293,
  230,
  235,
  302,
  301,
  300,
  299,
  231,
  240,
  290,
  293,
  395,
  313,
  241,
  295,
  242,
  243,
  286,
  273,
  395,
  285,
  245,
  246,
  395,
  267,
  267,
  256,
  251,
  248,
  245,
  253,
  246,
  258,
  255,
  262,
  94,
  395,
  395,
  296,
  300,
  304,
  306,
  310,
  314,
  123,
  316,
  0,
  0,
  0
}; // idb
__int16 word_80E9100[256] =
{
  0,
  245,
  245,
  244,
  3,
  246,
  246,
  244,
  244,
  244,
  244,
  244,
  247,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  247,
  244,
  247,
  244,
  244,
  244,
  244,
  249,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  250,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  251,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  249,
  244,
  249,
  244,
  244,
  244,
  244,
  244,
  250,
  244,
  244,
  244,
  244,
  252,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  252,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  248,
  248,
  248,
  244,
  244,
  248,
  248,
  244,
  248,
  244,
  248,
  244,
  248,
  244,
  248,
  244,
  244,
  0,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  0,
  0,
  0
}; // idb
__int16 word_80E9300[464] =
{
  0,
  8,
  10,
  9,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  31,
  32,
  8,
  33,
  34,
  31,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  31,
  42,
  31,
  43,
  31,
  44,
  31,
  45,
  46,
  47,
  48,
  31,
  49,
  31,
  31,
  50,
  51,
  52,
  53,
  9,
  9,
  59,
  61,
  65,
  73,
  75,
  66,
  55,
  55,
  77,
  93,
  68,
  76,
  74,
  105,
  69,
  79,
  62,
  70,
  67,
  83,
  80,
  84,
  60,
  93,
  71,
  81,
  87,
  88,
  93,
  85,
  82,
  90,
  91,
  63,
  93,
  93,
  117,
  78,
  97,
  95,
  93,
  93,
  93,
  99,
  93,
  103,
  96,
  93,
  93,
  93,
  107,
  98,
  100,
  106,
  101,
  93,
  102,
  109,
  104,
  112,
  93,
  93,
  59,
  110,
  108,
  115,
  113,
  123,
  135,
  118,
  243,
  77,
  116,
  83,
  93,
  84,
  114,
  93,
  111,
  85,
  131,
  93,
  131,
  85,
  60,
  132,
  136,
  93,
  93,
  124,
  93,
  93,
  93,
  93,
  93,
  137,
  138,
  139,
  142,
  140,
  93,
  93,
  93,
  93,
  93,
  93,
  143,
  141,
  93,
  145,
  123,
  144,
  93,
  93,
  93,
  93,
  149,
  150,
  93,
  153,
  93,
  147,
  146,
  148,
  165,
  152,
  151,
  154,
  164,
  93,
  155,
  93,
  124,
  93,
  167,
  168,
  93,
  166,
  93,
  93,
  93,
  169,
  93,
  93,
  93,
  93,
  93,
  172,
  173,
  93,
  93,
  93,
  178,
  170,
  174,
  176,
  93,
  171,
  179,
  180,
  93,
  93,
  93,
  93,
  175,
  177,
  93,
  93,
  93,
  181,
  182,
  93,
  93,
  190,
  191,
  194,
  93,
  196,
  198,
  193,
  195,
  93,
  192,
  93,
  93,
  199,
  93,
  93,
  93,
  197,
  93,
  93,
  200,
  93,
  202,
  93,
  201,
  93,
  93,
  93,
  208,
  209,
  212,
  93,
  213,
  214,
  211,
  215,
  93,
  93,
  93,
  93,
  210,
  93,
  93,
  222,
  93,
  227,
  228,
  220,
  232,
  93,
  223,
  221,
  93,
  229,
  93,
  239,
  235,
  233,
  93,
  242,
  240,
  238,
  236,
  93,
  237,
  241,
  8,
  8,
  8,
  8,
  54,
  54,
  54,
  54,
  58,
  234,
  58,
  58,
  92,
  92,
  122,
  93,
  122,
  122,
  130,
  231,
  130,
  130,
  163,
  163,
  230,
  93,
  226,
  225,
  224,
  93,
  93,
  93,
  93,
  219,
  218,
  217,
  216,
  93,
  93,
  93,
  93,
  93,
  207,
  206,
  205,
  204,
  203,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  189,
  188,
  187,
  186,
  185,
  184,
  183,
  93,
  93,
  132,
  132,
  162,
  161,
  160,
  159,
  158,
  157,
  156,
  93,
  93,
  93,
  134,
  133,
  77,
  129,
  128,
  127,
  126,
  125,
  121,
  120,
  56,
  119,
  94,
  93,
  89,
  86,
  72,
  64,
  57,
  56,
  244,
  9,
  9,
  7,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80E96A0[452] =
{
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  6,
  12,
  13,
  15,
  19,
  21,
  15,
  5,
  6,
  22,
  41,
  16,
  21,
  19,
  41,
  16,
  23,
  13,
  16,
  15,
  24,
  23,
  24,
  12,
  35,
  16,
  23,
  27,
  27,
  36,
  24,
  23,
  29,
  29,
  13,
  37,
  38,
  51,
  22,
  37,
  35,
  39,
  40,
  43,
  38,
  42,
  40,
  36,
  44,
  47,
  45,
  43,
  37,
  38,
  42,
  39,
  46,
  39,
  45,
  40,
  47,
  48,
  49,
  58,
  46,
  44,
  49,
  47,
  65,
  251,
  51,
  242,
  77,
  49,
  84,
  95,
  84,
  48,
  97,
  46,
  77,
  85,
  98,
  85,
  84,
  58,
  85,
  95,
  96,
  101,
  65,
  99,
  102,
  103,
  104,
  105,
  96,
  97,
  98,
  102,
  99,
  107,
  108,
  110,
  109,
  113,
  111,
  103,
  101,
  112,
  105,
  122,
  104,
  114,
  136,
  139,
  115,
  110,
  111,
  116,
  114,
  137,
  108,
  107,
  109,
  137,
  113,
  112,
  115,
  136,
  138,
  116,
  140,
  122,
  141,
  139,
  140,
  142,
  138,
  143,
  145,
  146,
  141,
  147,
  148,
  151,
  150,
  149,
  145,
  146,
  154,
  152,
  153,
  151,
  142,
  147,
  149,
  155,
  143,
  152,
  153,
  165,
  168,
  167,
  170,
  148,
  150,
  173,
  171,
  174,
  154,
  155,
  175,
  177,
  165,
  167,
  171,
  181,
  174,
  177,
  170,
  173,
  178,
  168,
  180,
  191,
  178,
  182,
  192,
  196,
  175,
  197,
  198,
  180,
  200,
  182,
  201,
  181,
  199,
  208,
  214,
  191,
  192,
  198,
  209,
  199,
  200,
  197,
  201,
  215,
  220,
  222,
  223,
  196,
  228,
  229,
  214,
  235,
  220,
  222,
  208,
  228,
  237,
  215,
  209,
  233,
  223,
  239,
  237,
  233,
  229,
  241,
  240,
  238,
  236,
  234,
  232,
  235,
  239,
  245,
  245,
  245,
  245,
  246,
  246,
  246,
  246,
  247,
  231,
  247,
  247,
  248,
  248,
  249,
  227,
  249,
  249,
  250,
  225,
  250,
  250,
  252,
  252,
  224,
  221,
  219,
  217,
  216,
  213,
  212,
  211,
  210,
  207,
  206,
  204,
  203,
  202,
  195,
  194,
  193,
  190,
  188,
  186,
  185,
  184,
  183,
  179,
  176,
  172,
  169,
  166,
  164,
  163,
  162,
  161,
  160,
  159,
  158,
  157,
  156,
  144,
  135,
  132,
  131,
  129,
  128,
  127,
  126,
  125,
  121,
  120,
  106,
  100,
  92,
  91,
  87,
  83,
  78,
  71,
  70,
  69,
  68,
  63,
  62,
  56,
  55,
  34,
  31,
  28,
  25,
  18,
  14,
  11,
  10,
  7,
  2,
  1,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244
}; // idb
_UNKNOWN unk_80E9FA2; // weak
_UNKNOWN unk_80EA104; // weak
const char byte_80EA10B = '\x15'; // idb
const char byte_80EA131 = '\x15'; // idb
const char byte_80EA160 = '\x15'; // idb
const char byte_80EA193 = '\x15'; // idb
const char byte_80EA400 = '\x15'; // idb
const char byte_80EA460 = '\x15'; // idb
const char byte_80EA4A0 = '\x15'; // idb
const char byte_80EA4E0 = '\x15'; // idb
const char byte_80EA540 = '\x15'; // idb
_UNKNOWN unk_80EA598; // weak
const char byte_80EA5C0 = '\x15'; // idb
const char byte_80EA660 = '\x15'; // idb
const char byte_80EA680 = '\x15'; // idb
const char byte_80EA6E0 = '\x15'; // idb
const char byte_80EA780 = '\x15'; // idb
const char byte_80EA7A0 = '\x15'; // idb
const char byte_80EA7E0 = '\x15'; // idb
const char byte_80EA820 = '\x15'; // idb
const char byte_80EA860 = '\x15'; // idb
const char byte_80EA8ED = '\x15'; // idb
const char byte_80EAA80 = '\x15'; // idb
const char byte_80EB05F = '\0'; // idb
_UNKNOWN unk_80EB30E; // weak
int dword_80EB6A0[256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // idb
int dword_80EBAA0[40] =
{
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15,
  0,
  0,
  0,
  0,
  0,
  1718511904,
  1702125932,
  825110816,
  1126183726,
  1920561263,
  1952999273,
  960049440,
  959524149,
  1293957177,
  543912545,
  1701602369,
  8306,
  0,
  0,
  0,
  0
}; // idb
_UNKNOWN unk_80EBB40; // weak
_UNKNOWN unk_80EBBC0; // weak
_UNKNOWN unk_80EBC40; // weak
_UNKNOWN unk_80EBCC0; // weak
__int16 word_80EC180[] = { 0 }; // weak
__int16 word_80EC182[] = { 0 }; // weak
__int16 word_80EC184[] = { 0 }; // weak
__int16 word_80EC186[] = { 0 }; // weak
int (__cdecl *off_80EC188[28])(int, int) =
{
  &sub_80D3448,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008,
  &loc_80D36E5,
  (int (__cdecl *)(int, int))0x50004,
  (int (__cdecl *)(int, int))0x80010,
  &loc_80D36E5,
  (int (__cdecl *)(int, int))0x60004,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80D36E5,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x100010,
  &loc_80D3CA4,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80D3CA4,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x800080,
  &loc_80D3CA4,
  (int (__cdecl *)(int, int))0x200008,
  (int (__cdecl *)(int, int))0x1000080,
  &loc_80D3CA4,
  (int (__cdecl *)(int, int))0x800020,
  (int (__cdecl *)(int, int))0x4000102,
  &loc_80D3CA4,
  (int (__cdecl *)(int, int))0x1020020,
  (int (__cdecl *)(int, int))0x10000102,
  &loc_80D3CA4
}; // idb
int dword_80EC200[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // idb
_UNKNOWN unk_80EC460; // weak
_UNKNOWN unk_80EC4E0; // weak
_UNKNOWN unk_80EC560; // weak
_UNKNOWN unk_80EC5E0; // weak
int dword_80EC7C0[] = { 0 }; // weak
int dword_80EC840[] = { 0 }; // weak
_UNKNOWN unk_80EC920; // weak
_UNKNOWN unk_80ECDA0; // weak
char byte_80ECF20[] = { '\0' }; // weak
int dword_80ED120[32] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0,
  0,
  0,
  0
}; // idb
int dword_80ED1A0[30] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
}; // idb
int (**off_80EF508)() = &off_80FDFD8; // weak
int dword_80EF50C = 0; // weak
void *dword_80EF510 = NULL; // idb
void *dword_80EF514 = NULL; // idb
void *dword_80EF518 = NULL; // idb
void *dword_80EF51C = NULL; // idb
char dword_80EF520[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_80EF524 = 0; // weak
int dword_80EFCDC = 0; // weak
void *ptr = NULL; // idb
int dword_80EFD00[] = { 0 }; // weak
char *off_80EFD60[10] =
{
  "auto",
  "menu",
  "weapon",
  "voice",
  "item",
  "body",
  "local",
  "music",
  "announcer",
  "shellshock"
}; // weak
int dword_80EFDA0 = 0; // weak
int dword_80EFDA4 = 0; // weak
int dword_80EFDA8 = 0; // weak
int dword_80EFDAC = 0; // weak
int dword_80EFDB0 = 0; // weak
int dword_80EFDBC = 0; // weak
char a123456789[] = "123456789"; // idb
char byte_80EFDD0 = '\0'; // weak
_UNKNOWN unk_80EFDE2; // weak
char byte_80EFDE6 = '\0'; // weak
int dword_80EFDEC = 0; // weak
int dword_80EFDF0 = 0; // weak
int dword_80EFE98 = 0; // weak
char *off_80EFEA0 = "if"; // idb
int (__cdecl *off_80EFEA4)(int) = &sub_807BF3D; // weak
char *off_80EFF40 = "evalint"; // idb
int (__cdecl *off_80EFF44)(int) = &sub_807C3B9; // weak
char *off_80EFFE0 = ">>="; // weak
_UNKNOWN unk_80F0260; // weak
int dword_80F02A0 = 0; // weak
int dword_80F02C0[40] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  131071,
  262143,
  524287,
  1048575,
  2097151,
  4194303,
  8388607,
  16777215,
  33554431,
  67108863,
  134217727,
  268435455,
  536870911,
  1073741823,
  2147483647,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char *off_80F0360 = "origin[0]"; // weak
char *off_80F03C0 = "color.rgba"; // weak
int dword_80F03C4[95] =
{
  28,
  32,
  135145431,
  0,
  4,
  135145436,
  12,
  0,
  135145446,
  8,
  10,
  135145448,
  4,
  10,
  135145450,
  24,
  2,
  135145457,
  20,
  2,
  135139661,
  92,
  32,
  135145464,
  16,
  4,
  135145469,
  104,
  8,
  135145474,
  56,
  8,
  135145486,
  48,
  10,
  135145492,
  52,
  10,
  135145499,
  108,
  0,
  135145504,
  32,
  32,
  135145519,
  36,
  32,
  135145533,
  40,
  16,
  135145542,
  68,
  32,
  135145557,
  72,
  16,
  135145567,
  64,
  10,
  135145578,
  100,
  0,
  135145584,
  44,
  8,
  135145590,
  60,
  10,
  135145600,
  84,
  32,
  135145614,
  88,
  16,
  135145623,
  76,
  10,
  135145629,
  80,
  10,
  135145635,
  96,
  32,
  135145644,
  112,
  32,
  135145651,
  116,
  32,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
int dword_80F0540[255] =
{
  250315,
  41193,
  6292,
  7106,
  3730,
  3750,
  6110,
  23283,
  33317,
  6950,
  7838,
  9714,
  9257,
  17259,
  3949,
  1778,
  8288,
  1604,
  1590,
  1663,
  1100,
  1213,
  1238,
  1134,
  1749,
  1059,
  1246,
  1149,
  1273,
  4486,
  2805,
  3472,
  21819,
  1159,
  1670,
  1066,
  1043,
  1012,
  1053,
  1070,
  1726,
  888,
  1180,
  850,
  960,
  780,
  1752,
  3296,
  10630,
  4514,
  5881,
  2685,
  4650,
  3837,
  2093,
  1867,
  2584,
  1949,
  1972,
  940,
  1134,
  1788,
  1670,
  1206,
  5719,
  6128,
  7222,
  6654,
  3710,
  3795,
  1492,
  1524,
  2215,
  1140,
  1355,
  971,
  2180,
  1248,
  1328,
  1195,
  1770,
  1078,
  1264,
  1266,
  1168,
  965,
  1155,
  1186,
  1347,
  1228,
  1529,
  1600,
  2617,
  2048,
  2546,
  3275,
  2410,
  3585,
  2504,
  2800,
  2675,
  6146,
  3663,
  2840,
  14253,
  3164,
  2221,
  1687,
  3208,
  2739,
  3512,
  4796,
  4091,
  3515,
  5288,
  4016,
  7937,
  6031,
  5360,
  3924,
  4892,
  3743,
  4566,
  4807,
  5852,
  6400,
  6225,
  8291,
  23243,
  7838,
  7073,
  8935,
  5437,
  4483,
  3641,
  5256,
  5312,
  5328,
  5370,
  3492,
  2458,
  1694,
  1821,
  2121,
  1916,
  1149,
  1516,
  1367,
  1236,
  1029,
  1258,
  1104,
  1245,
  1006,
  1149,
  1025,
  1241,
  952,
  1287,
  997,
  1713,
  1009,
  1187,
  879,
  1099,
  929,
  1078,
  951,
  1656,
  930,
  1153,
  1030,
  1262,
  1062,
  1214,
  1060,
  1621,
  930,
  1106,
  912,
  1034,
  892,
  1158,
  990,
  1175,
  850,
  1121,
  903,
  1087,
  920,
  1144,
  1056,
  3462,
  2240,
  4397,
  12136,
  7758,
  1345,
  1307,
  3278,
  1950,
  886,
  1023,
  1112,
  1077,
  1042,
  1061,
  1071,
  1484,
  1001,
  1096,
  915,
  1052,
  995,
  1070,
  876,
  1111,
  851,
  1059,
  805,
  1112,
  923,
  1103,
  817,
  1899,
  1872,
  976,
  841,
  1127,
  956,
  1159,
  950,
  7791,
  954,
  1289,
  933,
  1127,
  3207,
  1020,
  927,
  1355,
  768,
  1040,
  745,
  952,
  805,
  1073,
  740,
  1013,
  805,
  1008,
  796,
  996,
  1057,
  11457
}; // idb
char dword_80F093C[] = { '\xC0', '4', '\0', '\0' }; // idb
char off_80F0940[] = { '@', '*', '\x0E', '\b' }; // idb
int dword_80F0948 = 0; // weak
char *off_80F0960[14] =
{
  "+=",
  "-=",
  "*=",
  "/=",
  "&=",
  "|=",
  "++",
  "--",
  "&&",
  "||",
  "<=",
  ">=",
  "==",
  "!="
}; // weak
_DWORD dword_80F09A0[4464] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
void *off_80F4F60 = &dword_80F09A0; // idb
int dword_80F4F64 = 0; // weak
int dword_80F4F68 = 0; // weak
int dword_80F4FD8 = 0; // weak
char dword_80F5100[] = { '\0', '\0', '\0', '\0' }; // idb
void *gvm = NULL; // idb
int dword_80F5108 = 0; // weak
int dword_80F510C = 0; // weak
float flt_80F5110 = -64.0; // weak
float flt_80F5114 = -64.0; // weak
float flt_80F5118 = -32.0; // weak
float flt_80F511C =  64.0; // weak
float flt_80F5120 =  64.0; // weak
float flt_80F5124 =  72.0; // weak
int dword_80F5128 = 0; // weak
int dword_80F512C = 0; // weak
char *off_80F5130 = "loopsync"; // idb
void *dword_80F513C = NULL; // idb
int dword_80F5140 = 0; // weak
void *dword_80F5144 = NULL; // idb
void *dword_80F5148 = NULL; // idb
char byte_80F514C = '\0'; // weak
char byte_80F514D = '\0'; // weak
int dword_80F5150 = 0; // weak
char byte_80F5154 = '\0'; // weak
char byte_80F5155 = '\0'; // weak
int dword_80F5158 = 0; // weak
char byte_80F515C = '\0'; // weak
char byte_80F515D = '\0'; // weak
int dword_80F5160 = 0; // weak
int dword_80F5164 = 0; // weak
int dword_80F5168 = 0; // weak
int dword_80F516C = 0; // weak
void *dword_80F5170 = NULL; // idb
char dword_80F5174[] = { '\0', '\0', '\0', '\0' }; // idb
char dword_80F5178[] = { '\0', '\0', '\0', '\0' }; // idb
void *dword_80F517C = NULL; // idb
void *dword_80F5180 = NULL; // idb
int dword_80F5184 = -1; // weak
int dword_80F5188 = 0; // weak
__int16 word_80F51A0 = 0; // weak
__int16 word_80F51A2 = 0; // weak
int dword_80F51A4 = 0; // weak
char off_80F51C0[] = { '@', 'y', '\x0E', '\b' }; // idb
int dword_80F520C = 0; // weak
__int16 word_80F5210 = 0; // weak
__int16 word_80F5212 = 0; // weak
char byte_80F5214 = '\0'; // weak
char (*`typeinfo for'ScriptErrorClass)[44] = &strcat; // weak
__int16 word_80F5260[] = { -1 }; // weak
__int16 word_80F5360[128] =
{
  2,
  2,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  0,
  1,
  1,
  3,
  1,
  3,
  2,
  1,
  5,
  1,
  2,
  4,
  5,
  3,
  1,
  1,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  2,
  1,
  1,
  1,
  3,
  4,
  1,
  1,
  3,
  2,
  1,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  5,
  5,
  5,
  1,
  1,
  6,
  0,
  1,
  2,
  3,
  5,
  7,
  5,
  8,
  5,
  3,
  1,
  3,
  2,
  1,
  2,
  0,
  3,
  1,
  0,
  3,
  1,
  0,
  3,
  1,
  3,
  1,
  3,
  1,
  7,
  9,
  5,
  2,
  0,
  0,
  3,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80F5460[] = { 124 }; // weak
__int16 word_80F5660[32] =
{
  1,
  2,
  3,
  81,
  82,
  213,
  63,
  64,
  65,
  66,
  67,
  83,
  84,
  85,
  70,
  218,
  220,
  222,
  71,
  242,
  25,
  72,
  14,
  8,
  4,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80F56A0[256] =
{
  0,
  0,
  0,
  -250,
  -283,
  -244,
  -233,
  -222,
  0,
  0,
  -221,
  -218,
  -204,
  0,
  -247,
  -172,
  -221,
  -219,
  -162,
  -198,
  -169,
  0,
  0,
  0,
  -152,
  147,
  0,
  0,
  0,
  0,
  0,
  0,
  576,
  -260,
  -265,
  -159,
  0,
  0,
  0,
  576,
  576,
  -255,
  0,
  0,
  0,
  0,
  0,
  -153,
  -112,
  -111,
  0,
  -105,
  0,
  -106,
  745,
  -133,
  0,
  0,
  483,
  0,
  0,
  0,
  171,
  -167,
  0,
  0,
  0,
  -102,
  0,
  316,
  -122,
  0,
  0,
  231,
  315,
  576,
  576,
  576,
  576,
  576,
  576,
  1151,
  -201,
  0,
  -95,
  0,
  576,
  0,
  0,
  0,
  0,
  1151,
  1151,
  0,
  -66,
  -119,
  0,
  576,
  576,
  399,
  0,
  576,
  -245,
  0,
  -93,
  62,
  654,
  -49,
  0,
  -47,
  -44,
  -42,
  -39,
  -31,
  -38,
  576,
  576,
  0,
  0,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  0,
  -116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  0,
  576,
  1114,
  7,
  440,
  524,
  576,
  1053,
  0,
  -30,
  0,
  567,
  1133,
  0,
  576,
  576,
  576,
  576,
  576,
  0,
  -62,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  0,
  1168,
  1184,
  1199,
  1213,
  1226,
  1237,
  1237,
  267,
  267,
  267,
  267,
  100,
  100,
  -256,
  -256,
  0,
  0,
  0,
  1151,
  18,
  0,
  483,
  483,
  1151,
  -7,
  483,
  576,
  0,
  1151,
  -20,
  1151,
  2,
  1151,
  17,
  1074,
  24,
  0,
  0,
  -16,
  0,
  662,
  0,
  1095,
  0,
  9,
  0,
  576,
  0,
  576,
  0,
  0,
  483,
  0,
  23,
  0,
  0,
  1151,
  1151,
  0,
  483,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80F58A0[] = { 0 }; // weak
__int16 word_80F5AA0[32] =
{
  0,
  0,
  0,
  -8,
  -25,
  0,
  -37,
  0,
  0,
  259,
  -48,
  -23,
  -97,
  -18,
  72,
  0,
  0,
  0,
  -43,
  0,
  -14,
  206,
  303,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80F5AE0[1536] =
{
  62,
  121,
  68,
  93,
  95,
  86,
  87,
  69,
  5,
  9,
  94,
  68,
  73,
  93,
  113,
  104,
  74,
  17,
  176,
  10,
  106,
  32,
  88,
  89,
  67,
  95,
  153,
  154,
  155,
  102,
  11,
  91,
  92,
  62,
  113,
  68,
  12,
  13,
  69,
  68,
  69,
  15,
  21,
  18,
  107,
  95,
  164,
  105,
  62,
  62,
  68,
  68,
  67,
  41,
  113,
  69,
  69,
  93,
  5,
  16,
  5,
  5,
  5,
  5,
  106,
  95,
  69,
  132,
  133,
  134,
  135,
  136,
  137,
  52,
  62,
  6,
  68,
  224,
  158,
  108,
  62,
  69,
  68,
  52,
  5,
  29,
  5,
  69,
  107,
  160,
  161,
  7,
  19,
  163,
  23,
  24,
  22,
  41,
  168,
  90,
  7,
  66,
  7,
  7,
  7,
  7,
  7,
  7,
  177,
  26,
  97,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  18,
  3,
  108,
  3,
  3,
  7,
  52,
  7,
  66,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  3,
  207,
  3,
  98,
  99,
  100,
  212,
  72,
  73,
  101,
  103,
  158,
  114,
  115,
  217,
  219,
  221,
  223,
  74,
  227,
  228,
  156,
  129,
  230,
  8,
  75,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  76,
  72,
  73,
  62,
  62,
  68,
  68,
  62,
  77,
  68,
  69,
  69,
  74,
  157,
  69,
  247,
  8,
  86,
  8,
  75,
  225,
  78,
  62,
  249,
  68,
  231,
  159,
  169,
  76,
  69,
  79,
  165,
  80,
  62,
  170,
  68,
  77,
  171,
  175,
  172,
  69,
  62,
  173,
  68,
  188,
  245,
  157,
  246,
  69,
  78,
  174,
  215,
  93,
  93,
  93,
  93,
  93,
  93,
  79,
  93,
  80,
  10,
  232,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  93,
  81,
  121,
  93,
  93,
  93,
  93,
  93,
  209,
  234,
  244,
  93,
  10,
  233,
  10,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  236,
  93,
  93,
  226,
  229,
  81,
  248,
  239,
  240,
  1,
  28,
  235,
  122,
  89,
  27,
  93,
  93,
  93,
  93,
  96,
  241,
  93,
  93,
  93,
  162,
  0,
  237,
  93,
  93,
  93,
  93,
  93,
  93,
  157,
  93,
  93,
  93,
  93,
  20,
  27,
  28,
  29,
  30,
  0,
  32,
  121,
  33,
  0,
  9,
  110,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  0,
  0,
  107,
  121,
  34,
  106,
  48,
  35,
  105,
  112,
  36,
  37,
  65,
  48,
  0,
  38,
  9,
  110,
  9,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  107,
  48,
  49,
  106,
  0,
  0,
  105,
  112,
  0,
  48,
  0,
  0,
  65,
  151,
  152,
  153,
  154,
  155,
  48,
  0,
  114,
  50,
  51,
  52,
  0,
  0,
  116,
  53,
  54,
  55,
  56,
  57,
  58,
  113,
  59,
  60,
  61,
  166,
  27,
  28,
  29,
  30,
  31,
  32,
  48,
  33,
  114,
  0,
  48,
  48,
  48,
  48,
  116,
  0,
  0,
  0,
  0,
  0,
  48,
  113,
  0,
  34,
  93,
  115,
  35,
  0,
  0,
  36,
  37,
  106,
  0,
  4,
  38,
  4,
  4,
  4,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  115,
  0,
  0,
  0,
  107,
  0,
  0,
  0,
  4,
  0,
  4,
  0,
  0,
  41,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  130,
  32,
  108,
  33,
  0,
  0,
  52,
  109,
  110,
  111,
  0,
  0,
  0,
  0,
  0,
  0,
  112,
  0,
  0,
  34,
  49,
  0,
  35,
  0,
  0,
  36,
  37,
  49,
  0,
  0,
  38,
  0,
  0,
  0,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  0,
  0,
  0,
  0,
  49,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  0,
  49,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  131,
  32,
  49,
  33,
  0,
  0,
  49,
  49,
  49,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  49,
  0,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  38,
  0,
  0,
  116,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  0,
  0,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  0,
  32,
  0,
  33,
  0,
  11,
  0,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  38,
  11,
  0,
  11,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  210,
  48,
  49,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  0,
  32,
  0,
  33,
  12,
  0,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  12,
  0,
  12,
  0,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  211,
  48,
  49,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  0,
  0,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  167,
  87,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  0,
  59,
  60,
  0,
  0,
  0,
  0,
  27,
  28,
  29,
  59,
  60,
  32,
  0,
  167,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  59,
  60,
  0,
  0,
  56,
  57,
  58,
  0,
  59,
  60,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  13,
  0,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  13,
  0,
  13,
  0,
  0,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  2,
  0,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  0,
  50,
  51,
  52,
  0,
  2,
  0,
  2,
  0,
  0,
  0,
  64,
  0,
  0,
  59,
  60,
  32,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  0,
  0,
  0,
  0,
  64,
  64,
  64,
  64,
  0,
  64,
  0,
  0,
  6,
  64,
  6,
  6,
  6,
  6,
  6,
  0,
  0,
  0,
  0,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  0,
  0,
  0,
  6,
  64,
  6,
  0,
  29,
  64,
  64,
  64,
  64,
  0,
  0,
  33,
  0,
  0,
  0,
  64,
  31,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  16,
  33,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  33,
  16,
  0,
  0,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  0,
  17,
  33,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  14,
  17,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  14,
  15,
  14,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  15,
  214,
  15,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  238,
  0,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  243,
  0,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  208,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  216,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80F66E0[] = { 25 }; // weak
int dword_80F72C4 = 0; // idb
int dword_80F72C8 = 0; // weak
int dword_80F72CC = 1; // weak
int dword_80F72D0 = 0; // weak
FILE *dword_80F72D4 = NULL; // idb
FILE *dword_80F72D8 = NULL; // idb
char *dword_80F7320 = NULL; // idb
int dword_80F7324 = 0; // weak
__int16 word_80F7328 = 0; // weak
__int16 word_80F732A = 0; // weak
int dword_80F732C = 0; // weak
int dword_80F7330 = 1; // weak
__int16 word_80F7338 = 0; // weak
int dword_80F7340 = 1; // weak
int dword_80F7344 = 0; // weak
int dword_80F7348 = 0; // weak
int dword_80F734C = 0; // weak
int dword_80F7350 = 0; // weak
int dword_80F7354 = 0; // weak
int dword_80F7358 = -1; // weak
int dword_80F735C = 0; // weak
char byte_80F7360 = '\0'; // idb
int dword_80F7760 = 0; // weak
int dword_80F7764 = 0; // weak
int dword_80F776C = 0; // weak
int dword_80F77A0[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // idb
int dword_80F77E4 = 9; // weak
int dword_80F77E8 = 5; // weak
_UNKNOWN unk_80F7800; // weak
_UNKNOWN unk_80F8800; // weak
char *off_80F8900 = "1.1.4"; // weak
int dword_80F8920 = 9; // weak
int dword_80F8924 = 5; // weak
_UNKNOWN unk_80F8940; // weak
_UNKNOWN unk_80F9940; // weak
int dword_80F9A40[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // idb
void *off_80F9A84 = &unk_80EC920; // weak
void *off_80F9A98 = &unk_80ECDA0; // weak
_UNKNOWN unk_80F9AAC; // weak
char *off_80F9AD0[5] =
{
  "stream error",
  "data error",
  "insufficient memory",
  "buffer error",
  "incompatible version"
}; // weak
char *off_80F9AD8[3] = { "insufficient memory", "buffer error", "incompatible version" }; // weak
char *off_80F9ADC[2] = { "buffer error", "incompatible version" }; // weak
_UNKNOWN unk_80F9AE8; // weak
int dword_80FDA10[] = { 5 }; // weak
int dword_80FDE18[] = { -436141608 }; // weak
int (*off_80FDFCC)() = &ctor_001; // weak
int dword_80FDFE0 = 0; // weak
Elf32_Dyn *off_80FDFE4 = &stru_80FDED8; // weak
FILE *stdout; // idb
FILE *stderr; // idb
int _ctype_b; // weak
int stdin; // weak
char byte_80FE1F0; // weak
_UNKNOWN unk_80FE1F4; // weak
int dword_80FE210; // weak
int dword_80FE214[]; // weak
int dword_80FE21C[]; // weak
int dword_80FE220[]; // weak
int dword_80FE224[]; // weak
int dword_80FE228[]; // weak
int dword_80FE62C[33029]; // idb
_UNKNOWN unk_811EA40; // weak
int dword_816EA40; // weak
int dword_816EA44; // weak
int dword_816EA48; // weak
int dword_816EA4C; // weak
_UNKNOWN unk_816EA50; // weak
_UNKNOWN unk_816EA54; // weak
_DWORD dword_816EA58[49921]; // idb
int dword_819F65C; // weak
int dword_819F660[]; // weak
int dword_819F664[]; // weak
int dword_819F668[]; // weak
int dword_819F66C[]; // weak
int dword_819F670[]; // weak
float flt_81B3660; // weak
float flt_81B3664; // weak
__int16 word_81B3680[]; // weak
__int16 word_81B3682[131071]; // idb
__int16 word_81F3680[65536]; // idb
__int16 word_8213680[65536]; // idb
int dword_8233680; // weak
char *src; // idb
_UNKNOWN unk_8233EA0; // weak
int dword_82360A0; // weak
char byte_82360C0; // idb
char byte_82384C0[128]; // idb
char dword_8238548[]; // idb
int dword_823854C; // weak
char dword_8238550[]; // idb
char dword_8238554[]; // idb
char dword_8238558[]; // idb
int dword_823855C; // weak
char dword_8238560[]; // idb
char dword_8238564[]; // idb
char dword_8238568[]; // idb
char dword_823856C[]; // idb
char byte_8238580[1024]; // idb
char *dword_8238980; // idb
int dword_8238988[256]; // idb
_UNKNOWN unk_8238D88; // weak
_UNKNOWN unk_8239188; // weak
void *dword_8239588; // idb
int dword_823958C; // weak
int dword_8239590; // weak
int dword_8239594[]; // weak
int dword_8239598; // weak
int dword_823959C; // weak
int dword_82395A0; // weak
char s1; // idb
int dword_82395E4[]; // weak
int dword_8239600; // weak
int dword_8239604; // weak
int dword_8239608; // weak
int dword_8239610; // weak
struct __jmp_buf_tag env[1]; // idb
int dword_82396BC; // weak
int dword_82396C0[]; // weak
int dword_82396C4[]; // weak
int dword_82396C8[]; // weak
int dword_82396CC[]; // weak
int dword_82396D0[]; // weak
int dword_82396D4[]; // weak
char *dword_823AEC0; // idb
char byte_823AEE0; // idb
int dword_823B2E0; // weak
void *dword_823B2E4; // idb
_UNKNOWN unk_823B300; // weak
char byte_8252300[]; // weak
__int16 word_8252400[1152]; // idb
__int16 word_8252D00[1024]; // idb
int dword_8253500; // weak
char *dword_8253504; // idb
int dword_8253508; // idb
int (__cdecl *dword_825350C)(_DWORD); // weak
int dword_8253520; // weak
int dword_8253524; // weak
int dword_8253540[22528]; // idb
int dword_8269540[256]; // idb
char byte_8269940; // idb
char byte_8269D40; // idb
_UNKNOWN unk_826BD40; // weak
char byte_826C240; // idb
char byte_826E240; // idb
char byte_8270240; // idb
char byte_8272240; // idb
char byte_8278240; // idb
char byte_827A240[1024]; // idb
FILE *stream; // idb
_UNKNOWN unk_827A660; // weak
_UNKNOWN unk_827CA60; // weak
_DWORD dword_827CE60[7175]; // idb
_DWORD dword_8283E7C[2]; // idb
int dword_8283E84; // weak
char byte_828AEA0[64]; // idb
int dword_828B2E0; // weak
int dword_828B2E4; // weak
int dword_828B2E8; // weak
char byte_828B380[31999]; // idb
char byte_829307F; // weak
_UNKNOWN unk_8293080; // weak
_UNKNOWN unk_829AD80; // weak
int (__cdecl *dword_829ED80)(_DWORD); // weak
int dword_829ED84; // weak
int dword_829ED88; // weak
int dword_829ED8C; // weak
int dword_829ED90; // weak
int dword_829ED94; // weak
int dword_829ED98; // weak
int dword_829ED9C; // weak
int dword_829EDA0; // weak
_BYTE byte_829EDC0[1024]; // idb
int dword_829F1C0; // weak
char byte_829F1C4; // weak
__int16 word_829F1D2; // weak
__int16 word_829F1E0; // weak
int dword_829F1E4; // weak
int dword_829F1E8; // weak
int dword_829F1EC; // weak
int dword_829F200[256]; // idb
__int16 word_829F600[]; // weak
int dword_829F800[]; // weak
int dword_829F808; // weak
__int16 word_829F80C; // weak
int dword_829F810; // weak
int dword_829F814; // weak
int dword_829F818; // weak
char byte_829F81C; // weak
int dword_829F820; // weak
char byte_829F824; // weak
void *dword_829F828; // idb
void *dword_829F82C; // idb
int dword_829F830; // weak
int dword_829F840; // weak
int dword_829F844; // weak
int dword_829F848; // weak
int dword_829F84C; // weak
int dword_829F850; // weak
int dword_829F854; // weak
int dword_829F858; // weak
int dword_829F85C; // weak
int dword_829F860; // weak
int dword_829F864; // weak
int dword_829F868; // weak
int dword_829F86C; // weak
int dword_829F870; // weak
int dword_829F874; // weak
int dword_829F878; // weak
int dword_829F87C; // weak
int dword_829F880; // weak
int dword_829F884; // weak
int dword_829F888; // weak
int dword_829F88C; // weak
int dword_829F890; // weak
int dword_829F894; // weak
int dword_829F898; // weak
int dword_829F89C; // weak
int dword_829F8A0; // weak
int dword_829F8A4; // weak
int dword_829F8A8; // weak
int dword_829F8AC; // weak
int dword_829F8B0; // weak
int dword_829F8B4; // weak
int dword_829F8B8; // weak
int dword_829F8BC; // weak
int dword_829F8C0; // weak
int dword_829F8C4; // weak
int dword_829F8C8; // weak
int dword_829F8CC; // weak
int dword_829F8D0; // weak
int dword_829F8D4; // weak
int dword_829F8D8; // weak
int dword_829F8DC; // weak
int dword_829F8E0; // weak
int dword_829F8E4; // weak
int dword_829F8E8; // weak
int dword_829F8EC; // weak
int dword_829F8F0; // weak
int dword_829F8F4; // weak
int dword_829F8F8; // weak
int dword_829F8FC; // weak
int dword_829F900; // weak
int dword_829F904; // weak
int dword_829F908; // weak
int dword_829F90C; // weak
int dword_829F910; // weak
int dword_829F914; // weak
int dword_829F920; // weak
int dword_829F924; // weak
int dword_829F928; // weak
int dword_829F92C; // weak
int dword_829F930; // weak
int dword_829F934; // weak
int dword_829F938; // weak
int dword_829F93C; // weak
int dword_829F940; // weak
int dword_829F944; // weak
int dword_829F948; // weak
int dword_829F94C; // weak
int dword_829F950; // weak
int dword_829F954; // weak
int dword_829F958; // weak
int dword_829F95C; // weak
int dword_829F960; // weak
int dword_829F964; // weak
int dword_829F968; // weak
int dword_829F970; // weak
int dword_829F974; // weak
int dword_829F97C; // weak
int dword_829F980; // weak
int dword_829F984; // weak
int dword_829F988; // weak
int dword_829F98C; // weak
int dword_829F990; // weak
int dword_829F994; // weak
int dword_829F998; // weak
int dword_829F99C; // weak
int dword_829F9A0; // weak
int dword_829F9A4; // weak
int dword_829F9A8; // weak
int dword_829F9AC; // weak
int dword_829F9B0; // weak
int dword_829F9B4; // weak
int dword_829F9B8; // weak
int dword_829F9BC; // weak
int dword_829F9C0; // weak
int dword_829F9C4; // weak
int dword_829F9C8; // weak
int dword_829F9CC; // weak
int dword_829F9D0; // weak
int dword_829F9D4; // weak
int (__cdecl *dword_829F9D8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_829F9DC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_829F9E0)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_829F9E4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_829F9E8)(_DWORD); // weak
char byte_829F9EC; // weak
char byte_829F9ED; // weak
__int16 word_829F9EE; // weak
__int16 word_829F9F0; // weak
__int16 word_829F9F2; // weak
__int16 word_829F9F4; // weak
int dword_829F9F8; // weak
__int16 word_829F9FC; // weak
int dword_829FA00; // weak
int dword_829FA04; // weak
int dword_829FA08; // weak
int dword_829FA0C; // weak
int dword_829FA20[]; // weak
int dword_829FA24[131071]; // idb
int dword_831FA20; // weak
int dword_831FA24; // weak
int dword_831FA28; // weak
int dword_831FA2C; // weak
__int16 word_831FA40[32]; // idb
_BYTE byte_831FA80[512]; // idb
char byte_831FC80[256]; // idb
int dword_831FD80; // weak
char dword_831FD84[]; // idb
int dword_831FD88; // weak
void *dword_831FD8C; // idb
int dword_831FD90; // weak
int dword_831FD94[]; // weak
int dword_831FD9C[]; // weak
int dword_831FDA0; // weak
int dword_831FDA4; // weak
int dword_831FDA8; // weak
int dword_831FDAC; // weak
int dword_831FDB0; // weak
int dword_831FDB4; // weak
int dword_831FDB8; // weak
__int16 word_831FDC0[]; // weak
__int16 word_831FDC2[32767]; // idb
int dword_832FDC0; // weak
int dword_832FDE0[]; // weak
int dword_832FDE4[]; // weak
__int16 word_832FDE8[]; // weak
__int16 word_832FDEA[393211]; // idb
__int16 word_83EFDE0[]; // weak
__int16 word_83EFDE2[100689]; // idb
_UNKNOWN unk_8421085; // weak
int dword_842FDE0; // weak
int dword_842FDE4; // weak
__int16 word_842FDE8; // weak
void *dword_842FDEC; // idb
void *dword_842FDF0; // idb
char *dword_842FDF4; // idb
int dword_842FDF8; // weak
_UNKNOWN unk_842FE00; // weak
int dword_842FE04; // weak
int dword_842FE08[4092]; // idb
_UNKNOWN unk_8433DF8; // weak
int dword_8433E00; // weak
int dword_8433E20[32]; // idb
char dword_8433EA0[]; // idb
int dword_8433EA4; // weak
int dword_8433EA8; // weak
char byte_8433EAC; // weak
int dword_8433EB0; // weak
int dword_8433EB4; // weak
int dword_8433EB8; // weak
int dword_8433EC0[40]; // idb
int dword_8433F60; // weak
int dword_8433F64; // weak
int dword_8433F68; // weak
int dword_8433F6C; // weak
__int16 word_8433F70; // weak
__int16 word_8433F72; // weak
__int16 word_8433F74; // weak
__int16 word_8433F76; // weak
int dword_8433F78; // weak
int dword_8433F80; // weak
int dword_8433F84; // weak
int dword_8433F88; // weak
int dword_8433F8C; // idb
char byte_8433F90; // weak
int dword_8433F94; // weak
int dword_8433F98; // weak
int dword_8433F9C; // weak
int dword_8433FA0; // weak
_DWORD dword_8433FC0[5]; // idb
char byte_8433FD4[12]; // idb
char byte_8433FE0[300]; // idb
int dword_843410C; // weak
int (__cdecl *dword_8434118)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_843411C)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_8434120)(_DWORD, _DWORD, _DWORD); // weak
_UNKNOWN unk_8434140; // weak
__int16 word_8434148[]; // weak
__int16 word_843414A[]; // weak
int dword_843414C[]; // weak
int dword_8434150[]; // weak
__int16 word_8434154; // weak
__int16 word_8434156; // weak
_UNKNOWN unk_843415C; // weak
_UNKNOWN unk_8434160; // weak
int dword_8434168; // weak
int dword_843416C; // weak
__int16 word_8434170; // weak
__int16 word_8434172; // weak
float flt_8456140; // weak
float flt_8456144; // idb
float flt_8456148; // idb
float flt_845614C; // weak
__int16 word_8456150; // weak
__int16 word_8456152; // weak
__int16 word_8456154; // weak
int dword_8456158; // weak
int dword_845615C; // weak
int dword_8456160[]; // weak
char dword_8456170[15]; // idb
char byte_845617F; // weak
int dword_8456180; // weak
int dword_8456184; // weak
int dword_8456188; // weak
__int16 word_845618C; // weak
float flt_8456190; // weak
int dword_8456194; // weak
int dword_8456198; // weak
char byte_845619C; // weak
int dword_84561A0; // weak
_UNKNOWN unk_84561C0; // weak
_DWORD dword_84561CC[381]; // idb
int dword_84567C0; // weak
int dword_84567C4; // weak
int dword_84567C8; // weak
_WORD word_84567E0[2]; // idb
_DWORD dword_84567E4[2]; // idb
_UNKNOWN unk_84567EC; // weak
int dword_8456820; // weak
_UNKNOWN unk_8456824; // weak
_UNKNOWN unk_845688C; // weak
_UNKNOWN unk_84568A4; // weak
_DWORD dword_84568B0[10]; // idb
int dword_84568D8; // weak
_DWORD dword_84568E4[3]; // idb
_DWORD dword_84568F0[3]; // idb
_UNKNOWN unk_84568FC; // weak
_UNKNOWN unk_8456944; // weak
_WORD word_845695E[3]; // idb
char byte_8456964; // weak
__int16 word_8456966; // weak
int dword_8456980; // weak
char byte_84569BC; // weak
float flt_84569C0; // weak
char buf[256]; // idb
struct termios termios_p; // idb
int dword_8456B20; // weak
_UNKNOWN unk_8456B24; // weak
char byte_8456B3C; // idb
_DWORD dword_8456C40[2272]; // idb
int dword_8459000; // weak
int dword_8459004; // weak
char byte_8459020[]; // weak
char byte_8459021[]; // weak
char byte_8459022[]; // weak
char byte_8459023[61]; // idb
char byte_8459060[255]; // idb
char byte_845915F; // weak
char byte_8459160[256]; // idb
char byte_8459260; // weak
char path; // idb
char s[1024]; // idb
int dword_8459860; // weak
int dword_8459864; // weak
char byte_8459880[64]; // idb
int dword_84598C0; // weak
int dword_84598C4; // weak
int dword_84598C8; // weak
void *dword_84598CC; // idb
int dword_84598D0; // weak
int dword_84598D4; // weak
int dword_84598D8; // weak
int dword_84598DC; // weak
int dword_84598E0; // weak
int dword_84598E4; // weak
int dword_84598E8; // weak
int dword_84598EC; // weak
int dword_84598F0; // weak
int dword_84598F4; // weak
int dword_84598F8; // weak
int dword_84598FC; // weak
char dword_8459900[]; // idb
int dword_8459904; // weak
int dword_8459908; // weak
int dword_845990C; // weak
int dword_8459910; // weak
size_t dword_8459914; // idb
void *dword_8459918; // idb
int dword_845991C; // weak
int dword_8459920; // weak
void *dword_8459924; // idb
int dword_8459928; // weak
int dword_845992C; // weak
int dword_8459930; // weak
int dword_8459934; // weak
int dword_8459938; // weak
int dword_845993C; // weak
int dword_8459940; // weak
float flt_8459944[]; // weak
float flt_8459948; // weak
float flt_8459950[]; // weak
float flt_8459954; // weak
int dword_845995C; // weak
int dword_8459960[]; // weak
int dword_8459964; // weak
int dword_8459968; // weak
int dword_845996C[]; // weak
int dword_8459970; // weak
int dword_8459974; // weak
int dword_845997C; // weak
__int16 word_8459980; // weak
int dword_8459988; // weak
float flt_8459998; // weak
int dword_84599A8; // weak
int dword_84599AC; // weak
int dword_84599B0; // weak
_UNKNOWN unk_84599B4; // weak
_UNKNOWN unk_84599DC; // weak
int dword_84599F8[10230]; // idb
int dword_84639D0; // weak
int dword_84639DC; // weak
int dword_84639E8; // weak
int dword_84639EC; // weak
_UNKNOWN unk_8463A00; // weak
int dword_8473A00; // weak
void *dest; // idb
int dword_8473A08; // weak
size_t n; // idb
void *dword_8473A20; // idb
int dword_8477A20; // weak
int dword_8477A24; // weak
int dword_8477A40[]; // weak
int dword_8477A44[]; // weak
int dword_8477A48[]; // weak
int dword_8477A4C[]; // weak
int dword_8477A50[]; // weak
int dword_8477A54[]; // weak
int dword_8477A58[]; // weak
int dword_8477A5C[4601]; // idb
char byte_847C240; // idb
int dword_8480340; // weak
int dword_8480360[4096]; // idb
int dword_8484360; // weak
int dword_8484364; // weak
int dword_8484368; // weak
int dword_848436C; // weak
int dword_8484370; // weak
int dword_8484374; // weak
int dword_8484378; // weak
int dword_848437C; // weak
int dword_8484380; // weak
int dword_8484384; // weak
char byte_84843A0; // idb
int dword_84844A0; // weak
void *dword_84844C0; // idb
char byte_84884C0; // idb
int dword_84885C0; // weak
char byte_84885E0[256]; // idb
int dword_84886E0; // weak
int dword_84886E4; // weak
int dword_84886E8; // weak
int dword_8488700; // weak
int dword_8488704; // weak
int dword_8488708; // weak
int dword_848870C; // weak
int dword_8488710; // weak
int dword_8488714; // weak
int dword_8488718; // weak
int dword_848871C; // weak
char byte_8488720[4096]; // idb
int dword_8489720; // weak
char dword_8489728[]; // idb
int dword_848972C; // weak
int dword_8489730; // weak
char *dword_8489740; // idb
int dword_84897C0; // weak
int dword_84897C4; // weak
int dword_84897C8; // weak
char dword_84897D0[]; // idb
int dword_84897D4; // weak
int dword_84897D8; // weak
int dword_84897DC; // weak
int dword_84898AC; // weak
char dword_84898B0[]; // idb
int dword_84898B4; // weak
int dword_84898B8; // weak
int dword_84898BC; // weak
int dword_84898C0; // weak
int dword_84898C4; // weak
int dword_84898C8; // weak
int dword_84898CC; // weak
int dword_84898D0; // weak
char dword_84898D4[]; // idb
int dword_84898D8; // weak
int dword_84898DC; // weak
int dword_8489A00; // weak
int dword_8489A04; // weak
char byte_8489A20; // idb
int dword_8489A60; // weak
int dword_8489A64; // weak
int dword_8489A68; // weak
int dword_8489A6C; // weak
int dword_8489A70; // weak
int dword_8489A74; // weak
_UNKNOWN unk_8489A80; // weak
int dword_8494A10; // weak
int dword_8494A14; // weak
int dword_8494A20; // weak
int dword_8494A24; // weak
int dword_8494A28; // weak
int dword_8494A2C; // weak
int dword_8494A30; // weak
int dword_8494A34; // weak
int dword_8494A38; // weak
int dword_8494A3C; // weak
int dword_8494A40; // weak
int dword_8494A44; // weak
int dword_8494A48; // weak
int dword_8494A4C; // weak
int dword_8494A50; // weak
int dword_8494A54; // weak
int dword_8494A58; // weak
int dword_8494A5C; // weak
int dword_8494A60; // weak
int dword_8494A64; // weak
int dword_8494A68; // weak
int dword_8494A6C; // weak
int dword_8494A80; // weak
int dword_8494A84; // weak
int dword_8494A88; // weak
int dword_8494A8C; // weak
int dword_8494A90; // weak
char *dword_8494E98; // idb
_UNKNOWN unk_8496EA0; // weak
int dword_8496F94[]; // weak
int dword_8496F98[]; // weak
int dword_8496F9C[]; // weak
int dword_8496FA0[]; // weak
int dword_8496FA4[]; // weak
int dword_8496FA8[]; // weak
int dword_8496FAC[]; // weak
int dword_8496FB0[98234]; // idb
int dword_84F6E98; // weak
int dword_84F6E9C; // weak
int dword_84F6EA0; // weak
int dword_84F6EA4; // weak
int dword_84F6EA8; // weak
int dword_84F6EAC; // weak
int dword_84F6EB0[]; // weak
int dword_84F6EB4[18]; // idb
int dword_84F6EFC; // weak
int dword_84F6F00; // weak
int dword_84F6F04; // weak
int dword_84F6F08; // weak
int dword_84F6F0C[]; // weak
int dword_84F6F10[18]; // idb
int dword_84F6F58; // weak
int dword_84F6F5C; // weak
int dword_84F6F60; // weak
float flt_84F6F64; // weak
int dword_84F6F68; // weak
char byte_84F6F6C[64]; // idb
int dword_84F6FAC; // weak
int dword_84F6FB0; // weak
int dword_84F6FB4; // weak
int dword_84F6FB8; // weak
int dword_84F6FBC; // weak
int dword_84F6FC0; // weak
int dword_84F6FC4; // weak
int dword_84F6FC8; // weak
int dword_84F6FCC; // weak
int dword_84F6FD0; // weak
int dword_84F6FD4; // weak
int dword_84F6FD8; // weak
int dword_84F6FDC; // weak
int dword_84F6FE0; // weak
int dword_84F7000; // weak
int dword_84F7004; // weak
int svs_time; // weak
int dword_84F700C; // weak
void *svs_clients; // idb
int dword_84F7014; // weak
int dword_84F7018; // weak
int dword_84F701C; // weak
int dword_84F7020; // weak
int dword_84F7024; // weak
int dword_84F7028; // weak
int dword_84F702C; // weak
int dword_84F7030; // weak
void *dword_84F7034; // idb
void *dword_84F7038; // idb
int dword_84F703C; // weak
int dword_84F7040; // weak
int dword_84F7044; // weak
int dword_84F7048; // weak
void *dword_84F704C; // idb
void *dword_84F7050; // idb
void *dword_84F7054; // idb
int dword_84F7058; // weak
int dword_84F705C; // weak
int dword_84F7060[]; // weak
int dword_84F7064[]; // weak
int dword_84F7068[]; // weak
int dword_84F706C[]; // weak
int dword_84F7070[]; // weak
int dword_84F7074[]; // weak
int dword_84F707C[]; // weak
int dword_84F7084[]; // weak
int dword_84F7088[]; // weak
int dword_84F708C[21493]; // idb
int dword_850C060; // idb
int dword_850C064; // idb
int dword_850C068; // idb
int dword_850C06C; // idb
int dword_850C070; // idb
int dword_850C074; // idb
int dword_850C078; // idb
char dword_850C07C[]; // idb
int dword_850C080; // idb
int unk_850C084; // idb
__int16 word_850C086; // weak
int dword_850C088; // weak
int dword_850C08C[]; // weak
int dword_850C090[31]; // idb
int dword_850C10C; // weak
int dword_850C110; // weak
_UNKNOWN unk_850C120; // weak
char byte_850C124[]; // weak
int dword_850C1A8[78]; // idb
int dword_850C2E0; // weak
char *dword_850C2E4; // idb
int dword_850C2E8; // weak
int dword_850C2EC; // weak
int dword_850C2F0; // weak
int dword_850C2F4; // weak
int dword_850C2F8; // weak
size_t size; // idb
_WORD word_850C300[499]; // idb
_UNKNOWN unk_850C6E6; // weak
int dword_850C6EC; // weak
int dword_850C6F0; // weak
_UNKNOWN unk_850C700; // weak
int dword_850D6A0; // weak
int dword_850D7AC; // weak
int dword_850D7C0[]; // weak
int dword_850D7C4[]; // weak
int dword_850D7C8[]; // weak
int dword_850D7CC[]; // weak
int dword_850D7D0[]; // weak
int dword_850D7D4[]; // weak
_UNKNOWN unk_850EFE0; // weak
int dword_8516FE0; // weak
int dword_8516FF8; // weak
int dword_8516FFC; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (0804976C) --------------------------------------------------------
void init_proc(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_8049FD0();
  sub_80DBA10();
}
// 8049EFC: using guessed type int __gmon_start__(void);

//----- (0804979C) --------------------------------------------------------
void sub_804979C()
{
  JUMPOUT(0);
}
// 80497A2: control flows out of bounds to 0

//----- (08049F40) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main(main, v2, &retaddr, init_proc, term_proc, a2, &v3);
  __halt();
}
// 8049F43: positive sp value 4 has been found

//----- (08049F70) --------------------------------------------------------
void sub_8049F70()
{
  int (**v0)(); // eax
  void (*i)(void); // edx

  if ( !byte_80FE1F0 )
  {
    v0 = off_80EF508;
    for ( i = *off_80EF508; *off_80EF508; i = *off_80EF508 )
    {
      off_80EF508 = v0 + 1;
      i();
      v0 = off_80EF508;
    }
    if ( __deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_80F9AE8);
    byte_80FE1F0 = 1;
  }
}
// 804998C: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// 80EF508: using guessed type int (**off_80EF508)();
// 80FE1F0: using guessed type char byte_80FE1F0;

//----- (08049FD0) --------------------------------------------------------
int sub_8049FD0()
{
  int result; // eax

  if ( __register_frame_info_bases )
    __register_frame_info_bases(&unk_80F9AE8, &unk_80FE1F4, 0, &off_80FDFE4);
  result = dword_80FDFE0;
  if ( dword_80FDFE0 )
    result = 0;
  return result;
}
// 8049BCC: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 80FDFE0: using guessed type int dword_80FDFE0;
// 80FDFE4: using guessed type Elf32_Dyn *off_80FDFE4;

//----- (0804A030) --------------------------------------------------------
char *sub_804A030()
{
  sprintf(s, "%d %s %s", 1466, "Feb 10 2005", "15:43:53");
  return s;
}

//----- (0804A06C) --------------------------------------------------------
int __cdecl sub_804A06C(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  src = (dword_84639DC + a1[1]);
  if ( *a1 % 0x48u )
    sub_80704AC(1, &byte_80DBAA0);
  v2 = *a1 / 0x48u;
  if ( v2 <= 0 )
    sub_80704AC(1, &byte_80DBAC3);
  dword_84598CC = sub_806C3D4(72 * v2 + 72) + 72;
  dword_84598C8 = v2;
  sub_80C835C(dword_84598CC, src, 72 * v2);
  result = sub_804BFA9(1);
  if ( result != 1 )
  {
    v4 = dword_84598CC;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v2 )
        break;
      v4[17] = sub_804BFA9(v4[17]);
      v4[16] = sub_804BFA9(v4[16]);
      src += 72;
      v4 += 18;
    }
  }
  return result;
}
// 84598C8: using guessed type int dword_84598C8;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804A19D) --------------------------------------------------------
signed int __cdecl sub_804A19D(_DWORD *a1)
{
  signed int result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  _DWORD *v5; // [esp+18h] [ebp-20h]
  signed int v6; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  int k; // [esp+20h] [ebp-18h]
  signed int i; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int *v11; // [esp+2Ch] [ebp-Ch]

  v11 = (dword_84639DC + a1[1]);
  if ( *a1 % 0x30u )
    sub_80704AC(1, &byte_80DBAE0);
  v6 = *a1 / 0x30u;
  if ( v6 <= 0 )
    sub_80704AC(1, &byte_80DBB05);
  dword_8459904 = sub_806C3D4(40 * v6);
  *dword_8459900 = v6;
  if ( v6 > 512 )
    sub_80704AC(1, &byte_80DBB19);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v10 = dword_8459904 + 40 * i;
    for ( j = 0; j <= 2; ++j )
    {
      *(v10 + 4 * j) = sub_804BFB1(*&v11[j]) - 1.0;
      *(v10 + 4 * j + 12) = sub_804BFB1(*&v11[j + 3]) + 1.0;
    }
    if ( i )
    {
      v4 = sub_804BFA9(v11[11]);
      *(v10 + 32) = v4;
      if ( *(v10 + 32) != v4 )
        sub_80704AC(1, &byte_80DBB40);
      v5 = sub_806C3D4(4 * v4);
      *(v10 + 28) = (v5 - dword_84598F4) >> 2;
      for ( k = 0; k < v4; ++k )
        v5[k] = k + sub_804BFA9(v11[10]);
      v3 = sub_804BFA9(v11[9]);
      *(v10 + 36) = v3;
      if ( *(v10 + 36) != v3 )
        sub_80704AC(1, &byte_80DBB80);
      v2 = sub_804BFA9(v11[8]);
      *(v10 + 34) = v2;
      if ( *(v10 + 34) != v2 )
        sub_80704AC(1, &byte_80DBBC0);
    }
    v11 += 12;
  }
  return result;
}
// 84598F4: using guessed type int dword_84598F4;
// 8459904: using guessed type int dword_8459904;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804A40A) --------------------------------------------------------
signed int __cdecl sub_804A40A(_DWORD *a1)
{
  signed int result; // eax
  signed int v2; // [esp+Ch] [ebp-1Ch]
  int j; // [esp+10h] [ebp-18h]
  signed int i; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]

  v7 = (dword_84639DC + a1[1]);
  if ( *a1 % 0x24u )
    sub_80704AC(1, &byte_80DBC00);
  v2 = *a1 / 0x24u;
  if ( v2 <= 0 )
    sub_80704AC(1, &byte_80DBC21);
  dword_84598E4 = sub_806C3D4(8 * v2);
  dword_84598E0 = v2;
  v5 = dword_84598E4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v5 = dword_84598DC + 20 * sub_804BFA9(*v7);
    for ( j = 0; j <= 1; ++j )
    {
      v6 = sub_804BFA9(v7[j + 1]);
      *(v5 + j + 2) = v6;
      if ( *(v5 + j + 2) != v6 )
        sub_80704AC(1, &byte_80DBC40);
    }
    v5 += 2;
    v7 += 9;
  }
  return result;
}
// 84598DC: using guessed type int dword_84598DC;
// 84598E0: using guessed type int dword_84598E0;
// 84598E4: using guessed type int dword_84598E4;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804A557) --------------------------------------------------------
int __cdecl sub_804A557(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-44h]
  _DWORD *v4; // [esp+1Ch] [ebp-3Ch]
  int k; // [esp+24h] [ebp-34h]
  int v6; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int j; // [esp+38h] [ebp-20h]
  signed int l; // [esp+38h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v13; // [esp+40h] [ebp-18h]
  unsigned int *v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  __int16 *v16; // [esp+4Ch] [ebp-Ch]

  v16 = (dword_84639DC + a1[1]);
  if ( (*a1 & 3) != 0 )
    sub_80704AC(1, &byte_80DBC80);
  v9 = *a1 >> 2;
  v15 = dword_84639DC + a2[1];
  if ( (*a2 & 7) != 0 )
    sub_80704AC(1, &byte_80DBC80);
  v8 = (*a2 >> 3) - 6 * v9;
  if ( v8 < 0 )
    sub_80704AC(1, &byte_80DBCC0);
  if ( v8 )
    v4 = sub_806C3D4(8 * v8);
  else
    v4 = 0;
  dword_84598D4 = v4;
  dword_84598D0 = v8;
  v13 = v4;
  dword_845990C = sub_806C3D4(52 * v9 + 52);
  dword_8459908 = v9;
  v14 = dword_845990C;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v9 )
      break;
    v14[7] = sub_804BFA9(*v16) - 6;
    if ( (v14[7] & 0x80000000) != 0 )
      sub_80704AC(1, &byte_80DBD00);
    if ( v14[7] )
      v3 = v13;
    else
      v3 = 0;
    v14[8] = v3;
    for ( j = 0; j <= 2; ++j )
    {
      for ( k = 0; k <= 1; ++k )
      {
        *&v14[3 * k + 1 + j] = sub_804BFB1(*v15);
        v6 = sub_804BFA9(*(v15 + 4));
        if ( v6 < 0 || v6 >= dword_84598C8 )
          sub_80704AC(1, &byte_80DBD40, v6);
        *(v14 + 3 * k + j + 20) = v6;
        if ( *(v14 + 3 * k + j + 20) != v6 )
          sub_80704AC(1, &byte_80DBD80);
        v15 += 8;
      }
    }
    for ( l = 0; l < v14[7]; ++l )
    {
      *v13 = dword_84598DC + 20 * sub_804BFA9(*v15);
      v13[1] = sub_804BFA9(*(v15 + 4));
      if ( v13[1] < 0 || v13[1] >= dword_84598C8 )
        sub_80704AC(1, &byte_80DBD40, v13[1]);
      v15 += 8;
      v13 += 2;
    }
    v7 = sub_804BFA9(v16[1]);
    if ( v7 < 0 || v7 >= dword_84598C8 )
      sub_80704AC(1, &byte_80DBD40, v7);
    *v14 = *(dword_84598CC + 18 * v7 + 17) & 0xDFFF7FFB;
    v14 += 13;
    v16 += 2;
  }
  return result;
}
// 84598C8: using guessed type int dword_84598C8;
// 84598D0: using guessed type int dword_84598D0;
// 84598D4: using guessed type int dword_84598D4;
// 84598DC: using guessed type int dword_84598DC;
// 8459908: using guessed type int dword_8459908;
// 845990C: using guessed type int dword_845990C;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804A8EA) --------------------------------------------------------
void *__cdecl sub_804A8EA(_DWORD *a1)
{
  void *result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  signed int v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+28h] [ebp-10h]
  __int16 *v10; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]

  v9 = (dword_84639DC + a1[1]);
  if ( *a1 % 0x24u )
    sub_80704AC(1, &byte_80DBDC0);
  v8 = *a1 / 0x24u;
  if ( v8 <= 0 )
    sub_80704AC(1, &byte_80DBDE1);
  dword_84598EC = sub_806C3D4(16 * v8);
  dword_84598E8 = v8;
  v10 = dword_84598EC;
  for ( i = 0; i < v8; ++i )
  {
    v7 = v9[6];
    v10[7] = v7;
    if ( v10[7] != v7 )
      sub_80704AC(1, &byte_80DBE00);
    v6 = sub_804BFA9(*v9);
    *v10 = v6;
    if ( *v10 != v6 )
      sub_80704AC(1, &byte_80DBE40);
    v5 = sub_804BFA9(v9[1]);
    v10[1] = v5;
    if ( v10[1] != v5 )
      sub_80704AC(1, &byte_80DBE80);
    *(v10 + 1) = sub_804BFA9(v9[4]);
    v4 = sub_804BFA9(v9[5]);
    v10[4] = v4;
    if ( v10[4] != v4 )
      sub_80704AC(1, &byte_80DBEA0);
    v3 = sub_804BFA9(v9[2]);
    v10[5] = v3;
    if ( v10[5] != v3 )
      sub_80704AC(1, &byte_80DBEE0);
    v2 = sub_804BFA9(v9[3]);
    v10[6] = v2;
    if ( v10[6] != v2 )
      sub_80704AC(1, &byte_80DBF20);
    if ( v6 >= dword_8459910 )
      dword_8459910 = v6 + 1;
    if ( v5 >= dword_8459928 )
      dword_8459928 = v5 + 1;
    v9 += 9;
    v10 += 8;
  }
  dword_845992C = sub_806C3D4(8 * dword_8459928);
  result = sub_806C3D4(4 * dword_8459928 * dword_8459928);
  dword_8459930 = result;
  return result;
}
// 84598E8: using guessed type int dword_84598E8;
// 84598EC: using guessed type int dword_84598EC;
// 8459910: using guessed type int dword_8459910;
// 8459928: using guessed type int dword_8459928;
// 845992C: using guessed type int dword_845992C;
// 8459930: using guessed type int dword_8459930;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804AB81) --------------------------------------------------------
int __cdecl sub_804AB81(_DWORD *a1)
{
  int result; // eax
  char v2; // [esp+13h] [ebp-25h]
  char v3; // [esp+1Bh] [ebp-1Dh]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v5 = dword_84639DC + a1[1];
  if ( (*a1 & 0xF) != 0 )
    sub_80704AC(1, &byte_80DBC00);
  v4 = *a1 >> 4;
  if ( !v4 )
    sub_80704AC(1, &byte_80DBF4A);
  dword_84598DC = sub_806C3D4(20 * v4);
  dword_84598D8 = v4;
  v6 = dword_84598DC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    v3 = 0;
    for ( j = 0; j <= 2; ++j )
    {
      *(v6 + 4 * j) = sub_804BFB1(*(v5 + 4 * j));
      if ( *(v6 + 4 * j) < 0.0 )
        v3 |= 1 << j;
    }
    *(v6 + 12) = sub_804BFB1(*(v5 + 12));
    if ( *v6 == 1.0 )
    {
      v2 = 0;
    }
    else if ( *(v6 + 4) == 1.0 )
    {
      v2 = 1;
    }
    else if ( *(v6 + 8) == 1.0 )
    {
      v2 = 2;
    }
    else
    {
      v2 = 3;
    }
    *(v6 + 16) = v2;
    *(v6 + 17) = v3;
    v5 += 16;
    v6 += 20;
  }
  return result;
}
// 84598D8: using guessed type int dword_84598D8;
// 84598DC: using guessed type int dword_84598DC;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804AD14) --------------------------------------------------------
int __cdecl sub_804AD14(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int *v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = (dword_84639DC + a1[1]);
  if ( (*a1 & 3) != 0 )
    sub_80704AC(1, &byte_80DBC00);
  v2 = *a1 >> 2;
  dword_84598F4 = sub_806C3D4(4 * v2 + 4);
  dword_84598F0 = v2;
  v4 = dword_84598F4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v4++ = sub_804BFA9(*v3++);
  }
  return result;
}
// 84598F0: using guessed type int dword_84598F0;
// 84598F4: using guessed type int dword_84598F4;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804ADB4) --------------------------------------------------------
int __cdecl sub_804ADB4(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int *v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = (dword_84639DC + a1[1]);
  if ( (*a1 & 3) != 0 )
    sub_80704AC(1, &byte_80DBF60);
  v2 = *a1 >> 2;
  dword_84598FC = sub_806C3D4(4 * v2);
  dword_84598F8 = v2;
  v4 = dword_84598FC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v4++ = sub_804BFA9(*v3++);
  }
  return result;
}
// 84598F8: using guessed type int dword_84598F8;
// 84598FC: using guessed type int dword_84598FC;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804AE51) --------------------------------------------------------
#error "804AE51: stack frame is too big (funcsize=0)"

//----- (0804B316) --------------------------------------------------------
void *__cdecl sub_804B316(size_t *a1)
{
  dword_8459924 = sub_806C3D4(*a1);
  dword_8459920 = *a1;
  return sub_80C835C(dword_8459924, (dword_84639DC + a1[1]), *a1);
}
// 8459920: using guessed type int dword_8459920;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804B360) --------------------------------------------------------
void *__cdecl sub_804B360(size_t *a1)
{
  void *result; // eax
  int *v2; // [esp+10h] [ebp-8h]
  size_t v3; // [esp+14h] [ebp-4h]

  v3 = *a1;
  if ( *a1 )
  {
    v2 = (dword_84639DC + a1[1]);
    dword_845991C = 1;
    dword_8459918 = sub_806C3D4(v3);
    dword_8459910 = sub_804BFA9(*v2);
    dword_8459914 = sub_804BFA9(v2[1]);
    result = sub_80C835C(dword_8459918, v2 + 2, v3 - 8);
  }
  else
  {
    dword_8459914 = (dword_8459910 + 31) & 0xFFFFFFE0;
    dword_8459918 = sub_806C3D4((dword_8459910 + 31) & 0xFFFFFFE0);
    result = sub_80C837D(dword_8459918, 255, dword_8459914);
  }
  return result;
}
// 8459910: using guessed type int dword_8459910;
// 845991C: using guessed type int dword_845991C;
// 84639DC: using guessed type int dword_84639DC;

//----- (0804B429) --------------------------------------------------------
char *__cdecl sub_804B429(char *src, int a2, int a3)
{
  char *result; // eax
  char *v4; // eax
  int v5; // edx
  char *v6; // eax
  unsigned int v7; // [esp+14h] [ebp-184h]
  char *v8; // [esp+18h] [ebp-180h]
  char *v9; // [esp+1Ch] [ebp-17Ch]
  char dest[76]; // [esp+20h] [ebp-178h] BYREF
  int v11; // [esp+6Ch] [ebp-12Ch]
  int v12; // [esp+70h] [ebp-128h] BYREF
  char v13[4]; // [esp+74h] [ebp-124h] BYREF
  int v14[4]; // [esp+78h] [ebp-120h] BYREF
  int v15; // [esp+88h] [ebp-110h] BYREF
  int v16; // [esp+90h] [ebp-108h] BYREF
  int v17[32]; // [esp+98h] [ebp-100h] BYREF
  int v18; // [esp+118h] [ebp-80h] BYREF
  int v19; // [esp+120h] [ebp-78h] BYREF
  int v20; // [esp+128h] [ebp-70h] BYREF
  int v21; // [esp+130h] [ebp-68h] BYREF
  int v22; // [esp+138h] [ebp-60h] BYREF
  int v23; // [esp+140h] [ebp-58h] BYREF
  int v24; // [esp+148h] [ebp-50h] BYREF
  int v25; // [esp+150h] [ebp-48h] BYREF
  size_t v26[2]; // [esp+158h] [ebp-40h] BYREF
  size_t v27[10]; // [esp+160h] [ebp-38h] BYREF
  unsigned int i; // [esp+188h] [ebp-10h]
  void *v29; // [esp+18Ch] [ebp-Ch] BYREF

  if ( !src || !*src )
    sub_80704AC(1, &byte_80DC0BE);
  Q_strncpyz(dest, src, 64);
  dword_8459860 = sub_8073114("cm_noCurves", "0", 512);
  dword_8459864 = sub_8073114("cm_playerCurveClip", "1", 513);
  Com_DPrintf("CM_LoadMap( %s, %i )\n", dest, a2);
  if ( a2 && *(dword_84897C0 + 32) )
  {
    result = dword_80FE210;
    *a3 = dword_80FE210;
  }
  else
  {
    sub_80C837D(byte_8459880, 0, 0xA15Cu);
    v11 = sub_8062EB0(dest, &v29);
    if ( !v29 )
    {
      v4 = sub_8086D78(aExeErrCouldntL, dest);
      sub_80704AC(1, v4);
    }
    dword_80FE210 = sub_8080055(v29, v11);
    *a3 = dword_80FE210;
    v9 = &v12;
    v8 = v29;
    v7 = 272;
    if ( (&v12 & 4) != 0 )
    {
      v12 = *v29;
      v9 = v13;
      v8 = v29 + 4;
      v7 = 268;
    }
    qmemcpy(v9, v8, 4 * (v7 >> 2));
    for ( i = 0; i <= 0x43; ++i )
    {
      v5 = sub_804BFA9(*(&v12 + i));
      *(&v12 + i) = v5;
    }
    if ( *v13 != 59 )
    {
      v6 = sub_8086D78(aExeErrWrongMap, dest, *v13, 59);
      sub_80704AC(1, v6);
    }
    dword_84639DC = v29;
    sub_804A06C(v14);
    sub_804AB81(&v15);
    sub_804A557(v17, &v16);
    sub_804A40A(&v18);
    sub_804A8EA(&v19);
    sub_804AD14(&v20);
    sub_804ADB4(&v21);
    sub_804AE51(&v22, &v23, &v24);
    sub_804A19D(&v25);
    sub_804B360(v26);
    sub_804B316(v27);
    sub_8063207(v29);
    sub_804BD9D();
    sub_805793E();
    sub_805D8E6();
    result = sub_805391F();
    if ( !a2 )
      result = Q_strncpyz(byte_8459880, dest, 64);
  }
  return result;
}
// 804AE51: using guessed type _DWORD __cdecl sub_804AE51(_DWORD, _DWORD, _DWORD);
// 80FE210: using guessed type int dword_80FE210;
// 8459860: using guessed type int dword_8459860;
// 8459864: using guessed type int dword_8459864;
// 84639DC: using guessed type int dword_84639DC;
// 84897C0: using guessed type int dword_84897C0;

//----- (0804BC58) --------------------------------------------------------
int *__cdecl sub_804BC58(int a1)
{
  if ( a1 < 0 )
    sub_80704AC(1, &byte_80DC180, a1);
  if ( a1 < *dword_8459900 )
    return (dword_8459904 + 40 * a1);
  if ( a1 != 511 && a1 != 510 )
  {
    if ( a1 <= 511 )
      sub_80704AC(1, &byte_80DC1C0, *dword_8459900, a1, 512);
    sub_80704AC(1, &byte_80DC180, a1 + 512);
  }
  return dword_8459960;
}
// 8459904: using guessed type int dword_8459904;
// 8459960: using guessed type int dword_8459960[];

//----- (0804BD20) --------------------------------------------------------
int __cdecl sub_804BD20(int a1)
{
  if ( a1 < 0 || a1 >= *dword_8459900 )
    sub_80704AC(1, &byte_80DC1EF);
  return a1;
}

//----- (0804BD66) --------------------------------------------------------
void *sub_804BD66()
{
  return dword_8459924;
}

//----- (0804BD70) --------------------------------------------------------
int __cdecl sub_804BD70(int a1)
{
  return *(dword_84598EC + 16 * a1);
}
// 84598EC: using guessed type int dword_84598EC;

//----- (0804BD86) --------------------------------------------------------
int __cdecl sub_804BD86(int a1)
{
  return *(dword_84598EC + 16 * a1 + 2);
}
// 84598EC: using guessed type int dword_84598EC;

//----- (0804BD9D) --------------------------------------------------------
int sub_804BD9D()
{
  int result; // eax

  dword_845995C = dword_845990C + 52 * dword_8459908;
  *(dword_845990C + 52 * dword_8459908 + 28) = 0;
  *(dword_845995C + 32) = 0;
  *dword_845995C = -1;
  *(dword_845995C + 40) = -1;
  *(dword_845995C + 42) = -1;
  *(dword_845995C + 44) = -1;
  *(dword_845995C + 46) = -1;
  *(dword_845995C + 48) = -1;
  *(dword_845995C + 50) = -1;
  word_8459980 = 1;
  dword_845997C = dword_84598F0;
  result = dword_8459908;
  *(dword_84598F4 + 4 * dword_84598F0) = dword_8459908;
  return result;
}
// 84598F0: using guessed type int dword_84598F0;
// 84598F4: using guessed type int dword_84598F4;
// 8459908: using guessed type int dword_8459908;
// 845990C: using guessed type int dword_845990C;
// 845995C: using guessed type int dword_845995C;
// 845997C: using guessed type int dword_845997C;
// 8459980: using guessed type __int16 word_8459980;

//----- (0804BE53) --------------------------------------------------------
int __cdecl sub_804BE53(int *a1, int *a2, int a3, int a4)
{
  int v5; // [esp+0h] [ebp-4h]

  dword_8459960 = *a1;
  dword_8459964 = a1[1];
  dword_8459968 = a1[2];
  dword_845996C = *a2;
  dword_8459970 = a2[1];
  dword_8459974 = a2[2];
  *(dword_845995C + 4) = *a1;
  *(dword_845995C + 8) = a1[1];
  *(dword_845995C + 12) = a1[2];
  *(dword_845995C + 16) = *a2;
  *(dword_845995C + 20) = a2[1];
  *(dword_845995C + 24) = a2[2];
  *dword_845995C = a3;
  if ( a4 )
    v5 = 510;
  else
    v5 = 511;
  return v5;
}
// 845995C: using guessed type int dword_845995C;
// 8459960: using guessed type int dword_8459960;
// 8459964: using guessed type int dword_8459964;
// 8459968: using guessed type int dword_8459968;
// 845996C: using guessed type int dword_845996C;
// 8459970: using guessed type int dword_8459970;
// 8459974: using guessed type int dword_8459974;

//----- (0804BF27) --------------------------------------------------------
int sub_804BF27()
{
  return *dword_845995C;
}
// 845995C: using guessed type int dword_845995C;

//----- (0804BF33) --------------------------------------------------------
int __cdecl sub_804BF33(int a1, int *a2, _DWORD *a3)
{
  int *v3; // eax
  int result; // eax

  v3 = sub_804BC58(a1);
  *a2 = *v3;
  a2[1] = v3[1];
  a2[2] = v3[2];
  *a3 = v3[3];
  a3[1] = v3[4];
  result = v3[5];
  a3[2] = result;
  return result;
}

//----- (0804BF96) --------------------------------------------------------
int __cdecl sub_804BF96(__int16 a1)
{
  return a1;
}

//----- (0804BFA9) --------------------------------------------------------
int __cdecl sub_804BFA9(int a1)
{
  return a1;
}

//----- (0804BFB1) --------------------------------------------------------
long double __cdecl sub_804BFB1(float a1)
{
  return a1;
}

//----- (0804BFC4) --------------------------------------------------------
int __cdecl sub_804BFC4(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(a1 + 4 * i) < 0.0 )
      v3 |= 1 << i;
  }
  return v3;
}

//----- (0804C019) --------------------------------------------------------
int __cdecl sub_804C019(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  v7[0] = *a3 - *a2;
  v7[1] = a3[1] - a2[1];
  v7[2] = a3[2] - a2[2];
  v6[0] = *a4 - *a2;
  v6[1] = a4[1] - a2[1];
  v6[2] = a4[2] - a2[2];
  sub_80666B1(v6, v7, a1);
  if ( sub_8066755(a1) == 0.0 )
    return 0;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return 1;
}

//----- (0804C103) --------------------------------------------------------
_BOOL4 __cdecl sub_804C103(int a1, int a2, int a3, int a4)
{
  float v5; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  float v7; // [esp+1Ch] [ebp-1Ch]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]

  for ( i = 0; i <= 2; ++i )
    *(&v8 + i) = *(a1 + 4 * i) + *(a3 + 4 * i) - (*(a2 + 4 * i) + *(a2 + 4 * i));
  v5 = sqrt(v8 * v8 + v9 * v9 + v10 * v10);
  v7 = v5 * 0.25;
  return v7 > a4;
}

//----- (0804C1A3) --------------------------------------------------------
int *__cdecl sub_804C1A3(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int *result; // eax
  int i; // [esp+0h] [ebp-10h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    *(a4 + 4 * i) = (*(a1 + 4 * i) + *(a2 + 4 * i)) * 0.5;
    *(a6 + 4 * i) = (*(a2 + 4 * i) + *(a3 + 4 * i)) * 0.5;
    *(a5 + 4 * i) = (*(a4 + 4 * i) + *(a6 + 4 * i)) * 0.5;
    result = &i;
  }
  return result;
}

//----- (0804C278) --------------------------------------------------------
int __cdecl sub_804C278(int *a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+24h] [ebp-14h]
  int l; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  int k; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( *a1 <= a1[1] )
  {
    for ( i = 0; i < *a1; ++i )
    {
      for ( j = i + 1; j < a1[1]; ++j )
      {
        if ( j >= *a1 )
        {
          a1[387 * j + 4 + 3 * i] = a1[387 * i + 4 + 3 * j];
          a1[387 * j + 5 + 3 * i] = a1[387 * i + 5 + 3 * j];
          a1[387 * j + 6 + 3 * i] = a1[387 * i + 6 + 3 * j];
        }
        else
        {
          v4 = a1[387 * j + 4 + 3 * i];
          v6 = a1[387 * j + 5 + 3 * i];
          v8 = a1[387 * j + 6 + 3 * i];
          a1[387 * j + 4 + 3 * i] = a1[387 * i + 4 + 3 * j];
          a1[387 * j + 5 + 3 * i] = a1[387 * i + 5 + 3 * j];
          a1[387 * j + 6 + 3 * i] = a1[387 * i + 6 + 3 * j];
          a1[387 * i + 4 + 3 * j] = v4;
          a1[387 * i + 5 + 3 * j] = v6;
          a1[387 * i + 6 + 3 * j] = v8;
        }
      }
    }
  }
  else
  {
    for ( k = 0; k < a1[1]; ++k )
    {
      for ( l = k + 1; l < *a1; ++l )
      {
        if ( l >= a1[1] )
        {
          a1[387 * k + 4 + 3 * l] = a1[387 * l + 4 + 3 * k];
          a1[387 * k + 5 + 3 * l] = a1[387 * l + 5 + 3 * k];
          a1[387 * k + 6 + 3 * l] = a1[387 * l + 6 + 3 * k];
        }
        else
        {
          v3 = a1[387 * k + 4 + 3 * l];
          v5 = a1[387 * k + 5 + 3 * l];
          v7 = a1[387 * k + 6 + 3 * l];
          a1[387 * k + 4 + 3 * l] = a1[387 * l + 4 + 3 * k];
          a1[387 * k + 5 + 3 * l] = a1[387 * l + 5 + 3 * k];
          a1[387 * k + 6 + 3 * l] = a1[387 * l + 6 + 3 * k];
          a1[387 * l + 4 + 3 * k] = v3;
          a1[387 * l + 5 + 3 * k] = v5;
          a1[387 * l + 6 + 3 * k] = v7;
        }
      }
    }
  }
  v9 = *a1;
  *a1 = a1[1];
  a1[1] = v9;
  v2 = a1[2];
  a1[2] = a1[3];
  result = v2;
  a1[3] = v2;
  return result;
}

//----- (0804C8AF) --------------------------------------------------------
_DWORD *__cdecl sub_804C8AF(_DWORD *a1)
{
  _DWORD *result; // eax
  float v2; // [esp+0h] [ebp-18h]
  int j; // [esp+4h] [ebp-14h]
  int i; // [esp+8h] [ebp-10h]

  for ( i = 0; i < a1[1]; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v2 = *&a1[3 * i + 4 + j] - *&a1[387 * *a1 - 383 + 3 * i + j];
      if ( v2 < -0.1 || v2 > 0.1 )
        break;
    }
    if ( j != 3 )
      break;
  }
  result = a1;
  a1[2] = i == a1[1];
  return result;
}

//----- (0804C985) --------------------------------------------------------
int __cdecl sub_804C985(_DWORD *a1, int a2)
{
  int result; // eax
  int v3[4]; // [esp+20h] [ebp-48h] BYREF
  int v4[4]; // [esp+30h] [ebp-38h] BYREF
  int v5[5]; // [esp+40h] [ebp-28h] BYREF
  int j; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int v8; // [esp+5Ch] [ebp-Ch]

  v8 = 0;
  while ( 1 )
  {
    result = *a1 - 2;
    if ( v8 >= result )
      break;
    for ( i = 0;
          i < a1[1]
       && !sub_804C103(&a1[387 * v8 + 4 + 3 * i], &a1[387 * v8 + 391 + 3 * i], &a1[387 * v8 + 778 + 3 * i], a2);
          ++i )
    {
      ;
    }
    if ( i == a1[1] )
    {
      v8 += 2;
    }
    else
    {
      for ( i = 0; i < a1[1]; ++i )
      {
        v5[0] = a1[387 * v8 + 4 + 3 * i];
        v5[1] = a1[387 * v8 + 5 + 3 * i];
        v5[2] = a1[387 * v8 + 6 + 3 * i];
        v4[0] = a1[387 * v8 + 391 + 3 * i];
        v4[1] = a1[387 * v8 + 392 + 3 * i];
        v4[2] = a1[387 * v8 + 393 + 3 * i];
        v3[0] = a1[387 * v8 + 778 + 3 * i];
        v3[1] = a1[387 * v8 + 779 + 3 * i];
        v3[2] = a1[387 * v8 + 780 + 3 * i];
        for ( j = *a1 - 1; j > v8 + 1; --j )
        {
          a1[387 * j + 778 + 3 * i] = a1[387 * j + 4 + 3 * i];
          a1[387 * j + 779 + 3 * i] = a1[387 * j + 5 + 3 * i];
          a1[387 * j + 780 + 3 * i] = a1[387 * j + 6 + 3 * i];
        }
        sub_804C1A3(v5, v4, v3, &a1[387 * v8 + 391 + 3 * i], &a1[387 * v8 + 778 + 3 * i], &a1[387 * v8 + 1165 + 3 * i]);
      }
      *a1 += 2;
    }
  }
  return result;
}

//----- (0804CD9C) --------------------------------------------------------
_BOOL4 __cdecl sub_804CD9C(float *a1, float *a2)
{
  float v4; // [esp+4h] [ebp-4h]
  float v5; // [esp+4h] [ebp-4h]
  float v6; // [esp+4h] [ebp-4h]

  v4 = *a1 - *a2;
  if ( v4 < -0.1 || v4 > 0.1 )
    return 0;
  v5 = a1[1] - a2[1];
  if ( v5 < -0.1 || v5 > 0.1 )
    return 0;
  v6 = a1[2] - a2[2];
  return v6 >= -0.1 && v6 <= 0.1;
}

//----- (0804CE6B) --------------------------------------------------------
int __cdecl sub_804CE6B(int *a1)
{
  int result; // eax
  int l; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int k; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = *a1 - 1;
    if ( i >= result )
      break;
    for ( j = 0; j < a1[1] && sub_804CD9C(&a1[387 * i + 4 + 3 * j], &a1[387 * i + 391 + 3 * j]); ++j )
      ;
    if ( j == a1[1] )
    {
      for ( k = 0; k < a1[1]; ++k )
      {
        for ( l = i + 2; l < *a1; ++l )
        {
          a1[387 * l - 383 + 3 * k] = a1[387 * l + 4 + 3 * k];
          a1[387 * l - 382 + 3 * k] = a1[387 * l + 5 + 3 * k];
          a1[387 * l - 381 + 3 * k] = a1[387 * l + 6 + 3 * k];
        }
      }
      --*a1;
      --i;
    }
  }
  return result;
}

//----- (0804D04C) --------------------------------------------------------
int __cdecl sub_804D04C(float *a1, float *a2, _DWORD *a3)
{
  int v4; // [esp+Ch] [ebp-1Ch]

  if ( fabs(*a1 - *a2) >= 0.0001
    || fabs(a1[1] - a2[1]) >= 0.0001
    || fabs(a1[2] - a2[2]) >= 0.0001
    || fabs(a1[3] - a2[3]) >= 0.02 )
  {
    if ( fabs(*a1 - COERCE_FLOAT(*a2 ^ 0x80000000)) >= 0.0001
      || fabs(a1[1] - COERCE_FLOAT(*(a2 + 1) ^ 0x80000000)) >= 0.0001
      || fabs(a1[2] - COERCE_FLOAT(*(a2 + 2) ^ 0x80000000)) >= 0.0001
      || fabs(a1[3] - COERCE_FLOAT(*(a2 + 3) ^ 0x80000000)) >= 0.02 )
    {
      v4 = 0;
    }
    else
    {
      *a3 = 1;
      v4 = 1;
    }
  }
  else
  {
    *a3 = 0;
    v4 = 1;
  }
  return v4;
}

//----- (0804D1A1) --------------------------------------------------------
int *__cdecl sub_804D1A1(int *a1)
{
  int *result; // eax
  int i; // [esp+0h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    if ( fabs(*&a1[i] - 1.0) < 0.0001 )
    {
      a1[2] = 0;
      a1[1] = 0;
      *a1 = 0;
      result = a1;
      a1[i] = 1065353216;
      return result;
    }
    if ( fabs(*&a1[i] - -1.0) < 0.0001 )
    {
      a1[2] = 0;
      a1[1] = 0;
      *a1 = 0;
      result = a1;
      a1[i] = -1082130432;
      return result;
    }
    result = &i;
  }
  return result;
}

//----- (0804D278) --------------------------------------------------------
int __cdecl sub_804D278(int a1, _DWORD *a2)
{
  int v2; // ebx
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_819F65C; ++i )
  {
    if ( sub_804D04C(&dword_819F660[5 * i], a1, a2) )
      return i;
  }
  if ( dword_819F65C == 4096 )
    sub_80704AC(1, &byte_80DC264);
  dword_819F660[5 * dword_819F65C] = *a1;
  dword_819F664[5 * dword_819F65C] = *(a1 + 4);
  dword_819F668[5 * dword_819F65C] = *(a1 + 8);
  dword_819F66C[5 * dword_819F65C] = *(a1 + 12);
  v2 = 5 * dword_819F65C;
  dword_819F670[v2] = sub_804BFC4(a1);
  ++dword_819F65C;
  *a2 = 0;
  return dword_819F65C - 1;
}
// 819F65C: using guessed type int dword_819F65C;
// 819F660: using guessed type int dword_819F660[];
// 819F664: using guessed type int dword_819F664[];
// 819F668: using guessed type int dword_819F668[];
// 819F66C: using guessed type int dword_819F66C[];
// 819F670: using guessed type int dword_819F670[];

//----- (0804D3C2) --------------------------------------------------------
int __cdecl sub_804D3C2(float *a1, float *a2, float *a3)
{
  int v3; // ebx
  float v6; // [esp+18h] [ebp-20h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( !sub_804C019(&v10, a1, a2, a3) )
    return -1;
  for ( i = 0; i < dword_819F65C; ++i )
  {
    if ( *&v10 * *&dword_819F660[5 * i] + *&v11 * *&dword_819F664[5 * i] + *&v12 * *&dword_819F668[5 * i] >= 0.0 )
    {
      v6 = *a1 * *&dword_819F660[5 * i]
         + a1[1] * *&dword_819F664[5 * i]
         + a1[2] * *&dword_819F668[5 * i]
         - *&dword_819F66C[5 * i];
      if ( v6 >= -0.1 && v6 <= 0.1 )
      {
        v7 = *a2 * *&dword_819F660[5 * i]
           + a2[1] * *&dword_819F664[5 * i]
           + a2[2] * *&dword_819F668[5 * i]
           - *&dword_819F66C[5 * i];
        if ( v7 >= -0.1 && v7 <= 0.1 )
        {
          v8 = *a3 * *&dword_819F660[5 * i]
             + a3[1] * *&dword_819F664[5 * i]
             + a3[2] * *&dword_819F668[5 * i]
             - *&dword_819F66C[5 * i];
          if ( v8 >= -0.1 && v8 <= 0.1 )
            return i;
        }
      }
    }
  }
  if ( dword_819F65C == 4096 )
    sub_80704AC(1, &byte_80DC264);
  dword_819F660[5 * dword_819F65C] = v10;
  dword_819F664[5 * dword_819F65C] = v11;
  dword_819F668[5 * dword_819F65C] = v12;
  dword_819F66C[5 * dword_819F65C] = v13;
  v3 = 5 * dword_819F65C;
  dword_819F670[v3] = sub_804BFC4(&v10);
  return dword_819F65C++;
}
// 819F65C: using guessed type int dword_819F65C;
// 819F660: using guessed type int dword_819F660[];
// 819F664: using guessed type int dword_819F664[];
// 819F668: using guessed type int dword_819F668[];
// 819F66C: using guessed type int dword_819F66C[];
// 819F670: using guessed type int dword_819F670[];

//----- (0804D6F7) --------------------------------------------------------
int __cdecl sub_804D6F7(float *a1, int a2)
{
  float v4; // [esp+4h] [ebp-8h]

  if ( a2 == -1 )
    return 2;
  v4 = *a1 * *&dword_819F660[5 * a2]
     + a1[1] * *&dword_819F660[5 * a2 + 1]
     + a1[2] * *&dword_819F660[5 * a2 + 2]
     - *&dword_819F660[5 * a2 + 3];
  if ( v4 > 0.1 )
    return 0;
  if ( v4 >= -0.1 )
    return 2;
  return 1;
}
// 819F660: using guessed type int dword_819F660[];

//----- (0804D7A7) --------------------------------------------------------
int __cdecl sub_804D7A7(int a1, int a2, int a3, int a4)
{
  int *v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]

  if ( *(a1 + 4 * (a4 + 2 * (a3 + 129 * a2))) != -1 )
    return *(a1 + 4 * (a4 + 2 * (a3 + 129 * a2)));
  v5 = (8 * (a3 + 129 * a2) + a1);
  if ( !a4 )
    ++v5;
  if ( *v5 == -1 )
    v6 = -1;
  else
    v6 = *v5;
  return v6;
}

//----- (0804D830) --------------------------------------------------------
int __cdecl sub_804D830(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+20h] [ebp-28h] BYREF
  float v10; // [esp+24h] [ebp-24h]
  float v11; // [esp+28h] [ebp-20h]
  float *v12; // [esp+38h] [ebp-10h]
  float *v13; // [esp+3Ch] [ebp-Ch]

  switch ( a5 )
  {
    case 0:
      v13 = (12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (12 * a4 + a1 + 1548 * a3 + 1564);
      v7 = sub_804D7A7(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      return -1;
    case 1:
      v13 = (12 * a4 + a1 + 1548 * a3 + 1564);
      v12 = (a1 + 12 * a4 + 1548 * a3 + 1576);
      v7 = sub_804D7A7(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      return -1;
    case 2:
      v13 = (a1 + 12 * a4 + 1548 * a3 + 28);
      v12 = (a1 + 12 * a4 + 1548 * a3 + 1576);
      v8 = sub_804D7A7(a2, a3, a4, 1);
      if ( v8 >= 0 )
        goto LABEL_7;
      return -1;
    case 3:
      v13 = (12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (a1 + 12 * a4 + 1548 * a3 + 28);
      v8 = sub_804D7A7(a2, a3, a4, 1);
      if ( v8 < 0 )
        return -1;
LABEL_7:
      v9 = *&dword_819F660[5 * v8] * 4.0 + *v13;
      v10 = *&dword_819F664[5 * v8] * 4.0 + v13[1];
      v11 = *&dword_819F668[5 * v8] * 4.0 + v13[2];
      return sub_804D3C2(v12, v13, &v9);
    case 4:
      v13 = (a1 + 12 * a4 + 1548 * a3 + 1576);
      v12 = (12 * a4 + a1 + 1548 * a3 + 16);
      v7 = sub_804D7A7(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      v6 = -1;
      break;
    case 5:
      v13 = (12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (a1 + 12 * a4 + 1548 * a3 + 1576);
      v7 = sub_804D7A7(a2, a3, a4, 1);
      if ( v7 >= 0 )
      {
LABEL_19:
        v9 = *&dword_819F660[5 * v7] * 4.0 + *v13;
        v10 = *&dword_819F664[5 * v7] * 4.0 + v13[1];
        v11 = *&dword_819F668[5 * v7] * 4.0 + v13[2];
        v6 = sub_804D3C2(v13, v12, &v9);
      }
      else
      {
        v6 = -1;
      }
      break;
    default:
      sub_80704AC(1, &byte_80DC2A0);
  }
  return v6;
}
// 819F660: using guessed type int dword_819F660[];
// 819F664: using guessed type int dword_819F664[];
// 819F668: using guessed type int dword_819F668[];

//----- (0804DEE3) --------------------------------------------------------
int __cdecl sub_804DEE3(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( a6 )
  {
    if ( a6 > 0 )
    {
      if ( a6 != 1 )
LABEL_10:
        sub_80704AC(0, &byte_80DC2E0);
      v11 = a2 + 12 * a5 + 1548 * a4 + 1576;
      v12 = a2 + 12 * a5 + 1548 * a4 + 28;
      v13 = 12 * a5 + a2 + 1548 * a4 + 16;
      v10 = 3;
    }
    else
    {
      if ( a6 != -1 )
        goto LABEL_10;
      v11 = 12 * a5 + a2 + 1548 * a4 + 16;
      v12 = 12 * a5 + a2 + 1548 * a4 + 1564;
      v13 = a2 + 12 * a5 + 1548 * a4 + 1576;
      v14 = a2 + 12 * a5 + 1548 * a4 + 28;
      v10 = 4;
    }
  }
  else
  {
    v11 = 12 * a5 + a2 + 1548 * a4 + 16;
    v12 = 12 * a5 + a2 + 1548 * a4 + 1564;
    v13 = a2 + 12 * a5 + 1548 * a4 + 1576;
    v10 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(a1 + 4) )
      break;
    v9 = 0;
    v8 = 0;
    for ( j = 0; j < v10; ++j )
    {
      v7 = sub_804D6F7(*(&v11 + j), *(a1 + 4 * i + 8));
      if ( v7 )
      {
        if ( v7 == 1 )
          ++v8;
      }
      else
      {
        ++v9;
      }
    }
    if ( !v9 || v8 )
    {
      if ( !v8 || v9 )
      {
        if ( v9 || v8 )
        {
          Com_DPrintf("WARNING: CM_SetBorderInward: mixed plane sides\n");
          *(a1 + 4 * i + 112) = 0;
        }
        else
        {
          *(a1 + 4 * i + 8) = -1;
        }
      }
      else
      {
        *(a1 + 4 * i + 112) = 0;
      }
    }
    else
    {
      *(a1 + 4 * i + 112) = 1;
    }
  }
  return result;
}

//----- (0804E1AC) --------------------------------------------------------
int __cdecl sub_804E1AC(_DWORD *a1)
{
  float v3[3]; // [esp+20h] [ebp-48h] BYREF
  float v4[7]; // [esp+2Ch] [ebp-3Ch] BYREF
  void *ptr; // [esp+48h] [ebp-20h] BYREF
  int i; // [esp+4Ch] [ebp-1Ch]
  int v7; // [esp+50h] [ebp-18h] BYREF
  int v8; // [esp+54h] [ebp-14h]
  int v9; // [esp+58h] [ebp-10h]
  float v10; // [esp+5Ch] [ebp-Ch]

  if ( *a1 == -1 )
    return 0;
  v7 = dword_819F660[5 * *a1];
  v8 = dword_819F664[5 * *a1];
  v9 = dword_819F668[5 * *a1];
  LODWORD(v10) = dword_819F66C[5 * *a1];
  ptr = sub_8051B87(&v7, v10);
  for ( i = 0; i < a1[1] && ptr; ++i )
  {
    if ( a1[i + 2] == -1 )
    {
      sub_80514CC(ptr);
      return 0;
    }
    v7 = dword_819F660[5 * a1[i + 2]];
    v8 = dword_819F664[5 * a1[i + 2]];
    v9 = dword_819F668[5 * a1[i + 2]];
    LODWORD(v10) = dword_819F66C[5 * a1[i + 2]];
    if ( !a1[i + 28] )
    {
      HIBYTE(v7) ^= 0x80u;
      HIBYTE(v8) ^= 0x80u;
      HIBYTE(v9) ^= 0x80u;
      HIBYTE(v10) ^= 0x80u;
    }
    sub_805275D(&ptr, &v7, v10, 0.1);
  }
  if ( !ptr )
    return 0;
  sub_805199E(ptr, v3, v4);
  sub_80514CC(ptr);
  for ( i = 0; i <= 2; ++i )
  {
    if ( v4[i] - v3[i] > 131072.0 )
      return 0;
    if ( v3[i] >= 131072.0 )
      return 0;
    if ( v4[i] <= -131072.0 )
      return 0;
  }
  return 1;
}
// 819F660: using guessed type int dword_819F660[];
// 819F664: using guessed type int dword_819F664[];
// 819F668: using guessed type int dword_819F668[];
// 819F66C: using guessed type int dword_819F66C[];

//----- (0804E40B) --------------------------------------------------------
int __cdecl sub_804E40B(_DWORD *a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ebx
  int v4; // [esp+2Ch] [ebp-ACh]
  char v5[4]; // [esp+30h] [ebp-A8h] BYREF
  int v6; // [esp+34h] [ebp-A4h]
  int v7; // [esp+38h] [ebp-A0h]
  int v8[4]; // [esp+40h] [ebp-98h] BYREF
  float v9[4]; // [esp+50h] [ebp-88h] BYREF
  int v10[6]; // [esp+60h] [ebp-78h] BYREF
  void *ptr; // [esp+78h] [ebp-60h] BYREF
  void *src; // [esp+7Ch] [ebp-5Ch] BYREF
  char v13[4]; // [esp+80h] [ebp-58h] BYREF
  int v14; // [esp+84h] [ebp-54h]
  int v15; // [esp+88h] [ebp-50h]
  float v16; // [esp+8Ch] [ebp-4Ch]
  float v17; // [esp+9Ch] [ebp-3Ch]
  char v18[4]; // [esp+A0h] [ebp-38h] BYREF
  float v19; // [esp+A4h] [ebp-34h]
  float v20; // [esp+A8h] [ebp-30h]
  float v21; // [esp+ACh] [ebp-2Ch]
  char v22[4]; // [esp+B4h] [ebp-24h] BYREF
  int k; // [esp+B8h] [ebp-20h]
  int j; // [esp+BCh] [ebp-1Ch]
  int n; // [esp+C0h] [ebp-18h]
  int m; // [esp+C4h] [ebp-14h]
  int i; // [esp+C8h] [ebp-10h]
  int l; // [esp+CCh] [ebp-Ch]

  *v18 = *&dword_819F660[5 * *a1];
  v19 = *&dword_819F664[5 * *a1];
  v20 = *&dword_819F668[5 * *a1];
  v21 = *&dword_819F66C[5 * *a1];
  src = sub_8051B87(v18, v21);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[1] || !src )
      break;
    if ( a1[i + 2] != *a1 )
    {
      *v18 = *&dword_819F660[5 * a1[i + 2]];
      v19 = *&dword_819F664[5 * a1[i + 2]];
      v20 = *&dword_819F668[5 * a1[i + 2]];
      v21 = *&dword_819F66C[5 * a1[i + 2]];
      if ( !a1[i + 28] )
      {
        v18[3] ^= 0x80u;
        HIBYTE(v19) ^= 0x80u;
        HIBYTE(v20) ^= 0x80u;
        HIBYTE(v21) ^= 0x80u;
      }
      sub_805275D(&src, v18, v21, 0.1);
    }
  }
  if ( src )
  {
    sub_805199E(src, v10, v9);
    for ( j = 0; j <= 2; ++j )
    {
      for ( k = -1; k <= 1; k += 2 )
      {
        v20 = 0.0;
        v19 = 0.0;
        *v18 = 0.0;
        *&v18[4 * j] = k;
        if ( k == 1 )
          v21 = v9[j];
        else
          LODWORD(v21) = v10[j] ^ 0x80000000;
        if ( !sub_804D04C(&dword_819F660[5 * *a1], v18, v22) )
        {
          for ( l = 0; l < a1[1] && !sub_804D04C(&dword_819F660[5 * a1[l + 2]], v18, v22); ++l )
            ;
          if ( l == a1[1] )
          {
            if ( a1[1] > 26 )
              Com_Printf("ERROR: too many bevels\n");
            v2 = a1[1];
            a1[v2 + 2] = sub_804D278(v18, v22);
            a1[a1[1] + 54] = 0;
            a1[a1[1]++ + 28] = *v22;
          }
        }
      }
    }
    for ( i = 0; i < *src; ++i )
    {
      m = (i + 1) % *src;
      *v8 = *(src + 3 * i + 1) - *(src + 3 * m + 1);
      *&v8[1] = *(src + 3 * i + 2) - *(src + 3 * m + 2);
      *&v8[2] = *(src + 3 * i + 3) - *(src + 3 * m + 3);
      if ( sub_8066755(v8) >= 0.5 )
      {
        sub_804D1A1(v8);
        for ( m = 0; m <= 2 && *&v8[m] != -1.0 && *&v8[m] != 1.0; ++m )
          ;
        if ( m > 2 )
        {
          for ( j = 0; j <= 2; ++j )
          {
            for ( k = -1; k <= 1; k += 2 )
            {
              v7 = 0;
              v6 = 0;
              *v5 = 0;
              *&v5[4 * j] = k;
              sub_80666B1(v8, v5, v18);
              if ( sub_8066755(v18) >= 0.5 )
              {
                v21 = *(src + 3 * i + 1) * *v18 + *(src + 3 * i + 2) * v19 + *(src + 3 * i + 3) * v20;
                v4 = 0;
                for ( n = 0; n < *src; ++n )
                {
                  v17 = *(src + 3 * n + 1) * *v18 + *(src + 3 * n + 2) * v19 + *(src + 3 * n + 3) * v20 - v21;
                  if ( v17 > 0.1 )
                    break;
                  if ( v17 < -0.1 )
                    v4 = 1;
                }
                if ( n >= *src && v4 )
                {
                  for ( l = 0; l < a1[1] && !sub_804D04C(&dword_819F660[5 * a1[l + 2]], v18, v22); ++l )
                    ;
                  if ( l == a1[1] )
                  {
                    if ( a1[1] > 26 )
                      Com_Printf("ERROR: too many bevels\n");
                    v3 = a1[1];
                    a1[v3 + 2] = sub_804D278(v18, v22);
                    for ( m = 0; m < a1[1]; ++m )
                    {
                      if ( a1[a1[1] + 2] == a1[m + 2] )
                        Com_Printf("WARNING: bevel plane already used\n");
                    }
                    a1[a1[1] + 54] = 0;
                    a1[a1[1] + 28] = *v22;
                    ptr = sub_8051EBB(src);
                    *v13 = dword_819F660[5 * a1[a1[1] + 2]];
                    v14 = dword_819F664[5 * a1[a1[1] + 2]];
                    v15 = dword_819F668[5 * a1[a1[1] + 2]];
                    LODWORD(v16) = dword_819F66C[5 * a1[a1[1] + 2]];
                    if ( !a1[a1[1] + 28] )
                    {
                      v13[3] ^= 0x80u;
                      HIBYTE(v14) ^= 0x80u;
                      HIBYTE(v15) ^= 0x80u;
                      HIBYTE(v16) ^= 0x80u;
                    }
                    sub_805275D(&ptr, v13, v16, 0.1);
                    if ( ptr )
                    {
                      sub_80514CC(ptr);
                      ++a1[1];
                    }
                    else
                    {
                      Com_DPrintf("WARNING: CM_AddFacetBevels... invalid bevel\n");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_80514CC(src);
    a1[a1[1] + 2] = *a1;
    a1[a1[1] + 54] = 0;
    a1[a1[1] + 28] = 1;
    result = a1;
    ++a1[1];
  }
  return result;
}
// 819F660: using guessed type int dword_819F660[];
// 819F664: using guessed type int dword_819F664[];
// 819F668: using guessed type int dword_819F668[];
// 819F66C: using guessed type int dword_819F66C[];

//----- (0804EC66) --------------------------------------------------------
void *__cdecl sub_804EC66(_DWORD *a1, int a2)
{
  int v3; // [esp+2Ch] [ebp-4Ch]
  _BOOL4 v4; // [esp+30h] [ebp-48h]
  _BOOL4 v5; // [esp+34h] [ebp-44h]
  _BOOL4 v6; // [esp+38h] [ebp-40h]
  _BOOL4 v7; // [esp+3Ch] [ebp-3Ch]
  int v8; // [esp+40h] [ebp-38h]
  int v9; // [esp+44h] [ebp-34h]
  int v10; // [esp+48h] [ebp-30h]
  int v11; // [esp+4Ch] [ebp-2Ch]
  _DWORD *s; // [esp+58h] [ebp-20h]
  int j; // [esp+68h] [ebp-10h]
  int k; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]
  int v16; // [esp+6Ch] [ebp-Ch]

  dword_819F65C = 0;
  v3 = 0;
  for ( i = 0; i < *a1 - 1; ++i )
  {
    for ( j = 0; j < a1[1] - 1; ++j )
    {
      dword_80FE220[258 * i + 2 * j] = sub_804D3C2(
                                         &a1[387 * i + 4 + 3 * j],
                                         &a1[387 * i + 391 + 3 * j],
                                         &a1[387 * i + 394 + 3 * j]);
      dword_80FE224[258 * i + 2 * j] = sub_804D3C2(
                                         &a1[387 * i + 394 + 3 * j],
                                         &a1[387 * i + 7 + 3 * j],
                                         &a1[387 * i + 4 + 3 * j]);
    }
  }
  v16 = 0;
LABEL_8:
  if ( v16 < *a1 - 1 )
  {
    for ( k = 0; ; ++k )
    {
      if ( k >= a1[1] - 1 )
      {
        ++v16;
        goto LABEL_8;
      }
      v8 = -1;
      if ( k <= 0 )
      {
        if ( a1[3] )
          v8 = dword_80FE214[258 * v16 + 2 * a1[1]];
      }
      else
      {
        v8 = dword_80FE21C[258 * v16 + 2 * k];
      }
      v4 = v8 == dword_80FE220[258 * v16 + 2 * k];
      if ( v8 == -1 || v8 == dword_80FE220[258 * v16 + 2 * k] )
        v8 = sub_804D830(a1, dword_80FE220, v16, k, 0);
      v10 = -1;
      if ( k >= a1[1] - 2 )
      {
        if ( a1[3] )
          v10 = dword_80FE220[258 * v16];
      }
      else
      {
        v10 = dword_80FE228[258 * v16 + 2 * k];
      }
      v6 = v10 == dword_80FE224[258 * v16 + 2 * k];
      if ( v10 == -1 || v10 == dword_80FE224[258 * v16 + 2 * k] )
        v10 = sub_804D830(a1, dword_80FE220, v16, k, 2);
      v11 = -1;
      if ( v16 <= 0 )
      {
        if ( a1[2] )
          v11 = dword_80FDA10[258 * *a1 + 2 * k];
      }
      else
      {
        v11 = dword_80FDE18[258 * v16 + 2 * k];
      }
      v7 = v11 == dword_80FE224[258 * v16 + 2 * k];
      if ( v11 == -1 || v11 == dword_80FE224[258 * v16 + 2 * k] )
        v11 = sub_804D830(a1, dword_80FE220, v16, k, 3);
      v9 = -1;
      if ( v16 >= *a1 - 2 )
      {
        if ( a1[2] )
          v9 = dword_80FE224[2 * k];
      }
      else
      {
        v9 = dword_80FE62C[258 * v16 + 2 * k];
      }
      v5 = v9 == dword_80FE220[258 * v16 + 2 * k];
      if ( v9 == -1 || v9 == dword_80FE220[258 * v16 + 2 * k] )
        v9 = sub_804D830(a1, dword_80FE220, v16, k, 1);
      if ( v3 == 1024 )
        sub_80704AC(1, &byte_80DC410);
      s = (&unk_811EA40 + 320 * v3);
      sub_80C837D(s, 0, 0x140u);
      if ( dword_80FE220[258 * v16 + 2 * k] == dword_80FE224[258 * v16 + 2 * k] )
      {
        if ( dword_80FE220[258 * v16 + 2 * k] != -1 )
        {
          *s = dword_80FE220[258 * v16 + 2 * k];
          s[1] = 4;
          s[2] = v8;
          s[54] = v4;
          s[3] = v9;
          s[55] = v5;
          s[4] = v10;
          s[56] = v6;
          s[5] = v11;
          s[57] = v7;
          sub_804DEE3(s, a1, dword_80FE220, v16, k, -1);
          if ( sub_804E1AC(s) )
            goto LABEL_56;
        }
      }
      else
      {
        *s = dword_80FE220[258 * v16 + 2 * k];
        s[1] = 3;
        s[2] = v8;
        s[54] = v4;
        s[3] = v9;
        s[55] = v5;
        s[4] = dword_80FE224[258 * v16 + 2 * k];
        if ( s[4] == -1 )
        {
          s[4] = v10;
          if ( s[4] == -1 )
            s[4] = sub_804D830(a1, dword_80FE220, v16, k, 4);
        }
        sub_804DEE3(s, a1, dword_80FE220, v16, k, 0);
        if ( sub_804E1AC(s) )
        {
          sub_804E40B(s);
          ++v3;
        }
        if ( v3 == 1024 )
          sub_80704AC(1, &byte_80DC410);
        s = (&unk_811EA40 + 320 * v3);
        sub_80C837D(s, 0, 0x140u);
        *s = dword_80FE224[258 * v16 + 2 * k];
        s[1] = 3;
        s[2] = v10;
        s[54] = v6;
        s[3] = v11;
        s[55] = v7;
        s[4] = dword_80FE220[258 * v16 + 2 * k];
        if ( s[4] == -1 )
        {
          s[4] = v8;
          if ( s[4] == -1 )
            s[4] = sub_804D830(a1, dword_80FE220, v16, k, 5);
        }
        sub_804DEE3(s, a1, dword_80FE220, v16, k, 1);
        if ( sub_804E1AC(s) )
        {
LABEL_56:
          sub_804E40B(s);
          ++v3;
          continue;
        }
      }
    }
  }
  *a2 = dword_819F65C;
  *(a2 + 8) = v3;
  *(a2 + 12) = sub_806C3D4(320 * v3);
  sub_80C835C(*(a2 + 12), &unk_811EA40, 320 * v3);
  *(a2 + 4) = sub_806C3D4(20 * dword_819F65C);
  return sub_80C835C(*(a2 + 4), dword_819F660, 20 * dword_819F65C);
}
// 80FDA10: using guessed type int dword_80FDA10[];
// 80FDE18: using guessed type int dword_80FDE18[];
// 80FE214: using guessed type int dword_80FE214[];
// 80FE21C: using guessed type int dword_80FE21C[];
// 80FE220: using guessed type int dword_80FE220[];
// 80FE224: using guessed type int dword_80FE224[];
// 80FE228: using guessed type int dword_80FE228[];
// 819F65C: using guessed type int dword_819F65C;
// 819F660: using guessed type int dword_819F660[];

//----- (0804F52D) --------------------------------------------------------
void *__cdecl sub_804F52D(int a1, int a2, int a3, int a4, int a5)
{
  int j; // [esp+1Ch] [ebp-Ch]
  int l; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int k; // [esp+20h] [ebp-8h]
  void *v10; // [esp+24h] [ebp-4h]

  if ( a1 <= 2 || a2 <= 2 || !a4 )
    sub_80704AC(1, &byte_80DC420, a1, a2, a4);
  if ( (a1 & 1) == 0 || (a2 & 1) == 0 )
    sub_80704AC(1, &byte_80DC460);
  if ( a1 > 129 || a2 > 129 )
    sub_80704AC(1, &byte_80DC4C0);
  dword_816EA40 = a1;
  dword_816EA44 = a2;
  dword_816EA48 = 0;
  dword_816EA4C = 0;
  for ( i = 0; i < a1; ++i )
  {
    for ( j = 0; j < a2; ++j )
    {
      *(&unk_816EA50 + 387 * i + 3 * j) = *(a4 + 12 * (i + a1 * j));
      *(&unk_816EA54 + 387 * i + 3 * j) = *(a4 + 12 * (i + a1 * j) + 4);
      dword_816EA58[387 * i + 3 * j] = *(a4 + 12 * (i + a1 * j) + 8);
    }
  }
  sub_804C8AF(&dword_816EA40);
  sub_804C985(&dword_816EA40, a3);
  sub_804CE6B(&dword_816EA40);
  sub_804C278(&dword_816EA40);
  sub_804C8AF(&dword_816EA40);
  sub_804C985(&dword_816EA40, a3);
  sub_804CE6B(&dword_816EA40);
  v10 = sub_806C3D4(0x10u);
  sub_806A164(a5, (a5 + 12));
  for ( k = 0; k < dword_816EA40; ++k )
  {
    for ( l = 0; l < dword_816EA44; ++l )
      sub_806A19F((12 * l + 1548 * k + 135719504), a5, (a5 + 12));
  }
  sub_804EC66(&dword_816EA40, v10);
  *a5 = *a5 - 1.0;
  *(a5 + 4) = *(a5 + 4) - 1.0;
  *(a5 + 8) = *(a5 + 8) - 1.0;
  *(a5 + 12) = *(a5 + 12) + 1.0;
  *(a5 + 16) = *(a5 + 16) + 1.0;
  *(a5 + 20) = *(a5 + 20) + 1.0;
  return v10;
}
// 816EA40: using guessed type int dword_816EA40;
// 816EA44: using guessed type int dword_816EA44;
// 816EA48: using guessed type int dword_816EA48;
// 816EA4C: using guessed type int dword_816EA4C;

//----- (0804F85B) --------------------------------------------------------
int __cdecl sub_804F85B(int a1, _DWORD *a2)
{
  int result; // eax
  float v3; // [esp+Ch] [ebp-802Ch]
  float v4; // [esp+Ch] [ebp-802Ch]
  float v5; // [esp+10h] [ebp-8028h]
  float v6; // [esp+10h] [ebp-8028h]
  float v7; // [esp+14h] [ebp-8024h]
  float v8; // [esp+14h] [ebp-8024h]
  int v9; // [esp+18h] [ebp-8020h]
  int k; // [esp+1Ch] [ebp-801Ch]
  int i; // [esp+20h] [ebp-8018h]
  int j; // [esp+20h] [ebp-8018h]
  _DWORD *v13; // [esp+24h] [ebp-8014h]
  int v14; // [esp+28h] [ebp-8010h]
  int v15; // [esp+28h] [ebp-8010h]
  float v16; // [esp+2Ch] [ebp-800Ch]
  int v17[8194]; // [esp+30h] [ebp-8008h]

  result = dword_8459864;
  if ( *(dword_8459864 + 32) )
  {
    result = a1;
    if ( *(a1 + 192) )
    {
      v14 = a2[1];
      for ( i = 0; i < *a2; ++i )
      {
        v7 = *(a1 + 12 * *(v14 + 16) + 64) * *v14
           + *(a1 + 12 * *(v14 + 16) + 68) * *(v14 + 4)
           + *(a1 + 12 * *(v14 + 16) + 72) * *(v14 + 8);
        v5 = *a1 * *v14 + *(a1 + 4) * *(v14 + 4) + *(a1 + 8) * *(v14 + 8) - *(v14 + 12) + v7;
        v3 = *(a1 + 12) * *v14 + *(a1 + 16) * *(v14 + 4) + *(a1 + 20) * *(v14 + 8) - *(v14 + 12) + v7;
        v17[i + 4096] = v5 > 0.0;
        if ( v5 == v3 )
        {
          v17[i] = 1203982208;
        }
        else
        {
          *&v17[i] = v5 / (v5 - v3);
          if ( *&v17[i] <= 0.0 )
            v17[i] = 1203982208;
        }
        v14 += 20;
      }
      v13 = a2[3];
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= a2[2] )
          break;
        if ( v17[*v13 + 4096] )
        {
          v16 = *&v17[*v13];
          if ( v16 >= 0.0 && v16 <= *(a1 + 196) )
          {
            for ( k = 0; k < v13[1]; ++k )
            {
              v9 = v13[k + 2];
              if ( v17[v9 + 4096] == v13[k + 28] )
              {
                if ( v16 > *&v17[v9] )
                  break;
              }
              else if ( *&v17[v9] > v16 )
              {
                break;
              }
            }
            if ( k == v13[1] )
            {
              v15 = a2[1] + 20 * *v13;
              v8 = *(a1 + 12 * *(v15 + 16) + 64) * *v15
                 + *(a1 + 12 * *(v15 + 16) + 68) * *(v15 + 4)
                 + *(a1 + 12 * *(v15 + 16) + 72) * *(v15 + 8);
              v6 = *a1 * *v15 + *(a1 + 4) * *(v15 + 4) + *(a1 + 8) * *(v15 + 8) - *(v15 + 12) + v8;
              v4 = *(a1 + 12) * *v15 + *(a1 + 16) * *(v15 + 4) + *(a1 + 20) * *(v15 + 8) - *(v15 + 12) + v8;
              *(a1 + 196) = (v6 - 0.125) / (v6 - v4);
              if ( *(a1 + 196) < 0.0 )
                *(a1 + 196) = 0;
              *(a1 + 212) = *v15;
              *(a1 + 216) = *(v15 + 4);
              *(a1 + 220) = *(v15 + 8);
            }
          }
        }
        v13 += 80;
      }
    }
  }
  return result;
}
// 8459864: using guessed type int dword_8459864;

//----- (0804FD53) --------------------------------------------------------
int __cdecl sub_804FD53(int a1, _DWORD *a2)
{
  float v4; // [esp+Ch] [ebp-802Ch]
  float v5; // [esp+Ch] [ebp-802Ch]
  float v6; // [esp+10h] [ebp-8028h]
  float v7; // [esp+10h] [ebp-8028h]
  float v8; // [esp+14h] [ebp-8024h]
  float v9; // [esp+14h] [ebp-8024h]
  int v10; // [esp+18h] [ebp-8020h]
  int k; // [esp+1Ch] [ebp-801Ch]
  int i; // [esp+20h] [ebp-8018h]
  int j; // [esp+20h] [ebp-8018h]
  _DWORD *v14; // [esp+24h] [ebp-8014h]
  int v15; // [esp+28h] [ebp-8010h]
  int v16; // [esp+28h] [ebp-8010h]
  float v17; // [esp+2Ch] [ebp-800Ch]
  int v18[8194]; // [esp+30h] [ebp-8008h]

  if ( !*(dword_8459864 + 32) || !*(a1 + 192) )
    return 1;
  v15 = a2[1];
  for ( i = 0; i < *a2; ++i )
  {
    v8 = *(a1 + 12 * *(v15 + 16) + 64) * *v15
       + *(a1 + 12 * *(v15 + 16) + 68) * *(v15 + 4)
       + *(a1 + 12 * *(v15 + 16) + 72) * *(v15 + 8);
    v6 = *a1 * *v15 + *(a1 + 4) * *(v15 + 4) + *(a1 + 8) * *(v15 + 8) - *(v15 + 12) + v8;
    v4 = *(a1 + 12) * *v15 + *(a1 + 16) * *(v15 + 4) + *(a1 + 20) * *(v15 + 8) - *(v15 + 12) + v8;
    v18[i + 4096] = v6 > 0.0;
    if ( v6 == v4 )
    {
      v18[i] = 1203982208;
    }
    else
    {
      *&v18[i] = v6 / (v6 - v4);
      if ( *&v18[i] <= 0.0 )
        v18[i] = 1203982208;
    }
    v15 += 20;
  }
  v14 = a2[3];
  for ( j = 0; j < a2[2]; ++j )
  {
    if ( v18[*v14 + 4096] )
    {
      v17 = *&v18[*v14];
      if ( v17 >= 0.0 )
      {
        for ( k = 0; k < v14[1]; ++k )
        {
          v10 = v14[k + 2];
          if ( v18[v10 + 4096] == v14[k + 28] )
          {
            if ( v17 > *&v18[v10] )
              break;
          }
          else if ( *&v18[v10] > v17 )
          {
            break;
          }
        }
        if ( k == v14[1] )
        {
          v16 = a2[1] + 20 * *v14;
          v9 = *(a1 + 12 * *(v16 + 16) + 64) * *v16
             + *(a1 + 12 * *(v16 + 16) + 68) * *(v16 + 4)
             + *(a1 + 12 * *(v16 + 16) + 72) * *(v16 + 8);
          v7 = *a1 * *v16 + *(a1 + 4) * *(v16 + 4) + *(a1 + 8) * *(v16 + 8) - *(v16 + 12) + v9;
          v5 = *(a1 + 12) * *v16 + *(a1 + 16) * *(v16 + 4) + *(a1 + 20) * *(v16 + 8) - *(v16 + 12) + v9;
          if ( v7 - v5 > 0.0 && (v7 - 0.125) / (v7 - v5) < 1.0 )
            return 0;
        }
      }
    }
    v14 += 80;
  }
  return 1;
}
// 8459864: using guessed type int dword_8459864;

//----- (08050216) --------------------------------------------------------
int __cdecl sub_8050216(float *a1, float *a2, float *a3, float *a4, float *a5, _DWORD *a6)
{
  float v8; // [esp+4h] [ebp-Ch]
  float v9; // [esp+4h] [ebp-Ch]
  float v10; // [esp+8h] [ebp-8h]
  float v11; // [esp+Ch] [ebp-4h]

  *a6 = 0;
  v11 = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2] - a1[3];
  v10 = *a3 * *a1 + a3[1] * a1[1] + a3[2] * a1[2] - a1[3];
  if ( v11 > 0.0 && (v10 >= 0.125 || v10 >= v11) )
    return 0;
  if ( v11 <= 0.0 && v10 <= 0.0 )
    return 1;
  if ( v11 <= v10 )
  {
    v9 = (v11 + 0.125) / (v11 - v10);
    if ( v9 > 1.0 )
      v9 = 1.0;
    if ( *a5 > v9 )
      *a5 = v9;
  }
  else
  {
    v8 = (v11 - 0.125) / (v11 - v10);
    if ( v8 < 0.0 )
      v8 = 0.0;
    if ( v8 > *a4 )
    {
      *a4 = v8;
      *a6 = 1;
    }
  }
  return 1;
}

//----- (080503B2) --------------------------------------------------------
int __cdecl sub_80503B2(int a1, _DWORD *a2)
{
  int result; // eax
  float v3; // [esp+2Ch] [ebp-7Ch]
  float v4; // [esp+30h] [ebp-78h] BYREF
  float v5; // [esp+34h] [ebp-74h]
  float v6; // [esp+38h] [ebp-70h]
  float v7; // [esp+40h] [ebp-68h] BYREF
  float v8; // [esp+44h] [ebp-64h]
  float v9; // [esp+48h] [ebp-60h]
  unsigned int v10; // [esp+50h] [ebp-58h]
  unsigned int v11; // [esp+54h] [ebp-54h]
  unsigned int v12; // [esp+58h] [ebp-50h]
  unsigned int v13; // [esp+60h] [ebp-48h] BYREF
  unsigned int v14; // [esp+64h] [ebp-44h]
  unsigned int v15; // [esp+68h] [ebp-40h]
  float v16; // [esp+6Ch] [ebp-3Ch]
  _DWORD *v17; // [esp+78h] [ebp-30h]
  int *v18; // [esp+7Ch] [ebp-2Ch]
  float v19; // [esp+80h] [ebp-28h]
  float v20; // [esp+84h] [ebp-24h] BYREF
  float v21; // [esp+88h] [ebp-20h] BYREF
  float v22; // [esp+8Ch] [ebp-1Ch]
  int v23; // [esp+90h] [ebp-18h]
  int v24; // [esp+94h] [ebp-14h] BYREF
  int i; // [esp+98h] [ebp-10h]
  int v26; // [esp+9Ch] [ebp-Ch]

  if ( *(a1 + 192) )
    return sub_804F85B(a1, a2);
  v17 = a2[3];
  v26 = 0;
  while ( 1 )
  {
    result = v26;
    if ( v26 >= a2[2] )
      break;
    v21 = -1.0;
    v20 = *(a1 + 196);
    v23 = -1;
    v18 = (a2[1] + 20 * *v17);
    v13 = *v18;
    v14 = *(v18 + 1);
    v15 = *(v18 + 2);
    v16 = *(v18 + 3);
    if ( *(a1 + 244) )
    {
      v16 = v16 + *(a1 + 248);
      v19 = *&v13 * *(a1 + 256) + *&v14 * *(a1 + 260) + *&v15 * *(a1 + 264);
      if ( v19 <= 0.0 )
      {
        v7 = *a1 + *(a1 + 256);
        v8 = *(a1 + 4) + *(a1 + 260);
        v9 = *(a1 + 8) + *(a1 + 264);
        v4 = *(a1 + 12) + *(a1 + 256);
        v5 = *(a1 + 16) + *(a1 + 260);
        v6 = *(a1 + 20) + *(a1 + 264);
      }
      else
      {
        v7 = *a1 - *(a1 + 256);
        v8 = *(a1 + 4) - *(a1 + 260);
        v9 = *(a1 + 8) - *(a1 + 264);
        v4 = *(a1 + 12) - *(a1 + 256);
        v5 = *(a1 + 16) - *(a1 + 260);
        v6 = *(a1 + 20) - *(a1 + 264);
      }
    }
    else
    {
      v22 = *(a1 + 12 * v18[4] + 64) * *&v13 + *(a1 + 12 * v18[4] + 68) * *&v14 + *(a1 + 12 * v18[4] + 72) * *&v15;
      v16 = v16 - v22;
      v7 = *a1;
      v8 = *(a1 + 4);
      v9 = *(a1 + 8);
      v4 = *(a1 + 12);
      v5 = *(a1 + 16);
      v6 = *(a1 + 20);
    }
    if ( sub_8050216(&v13, &v7, &v4, &v21, &v20, &v24) )
    {
      if ( v24 )
      {
        v10 = v13;
        v11 = v14;
        v12 = v15;
      }
      for ( i = 0; i < v17[1]; ++i )
      {
        v18 = (a2[1] + 20 * v17[i + 2]);
        if ( v17[i + 28] )
        {
          v13 = *v18 ^ 0x80000000;
          v14 = v18[1] ^ 0x80000000;
          v15 = v18[2] ^ 0x80000000;
          LODWORD(v16) = v18[3] ^ 0x80000000;
        }
        else
        {
          v13 = *v18;
          v14 = *(v18 + 1);
          v15 = *(v18 + 2);
          v16 = *(v18 + 3);
        }
        if ( *(a1 + 244) )
        {
          v16 = v16 + *(a1 + 248);
          v19 = *&v13 * *(a1 + 256) + *&v14 * *(a1 + 260) + *&v15 * *(a1 + 264);
          if ( v19 <= 0.0 )
          {
            v7 = *a1 + *(a1 + 256);
            v8 = *(a1 + 4) + *(a1 + 260);
            v9 = *(a1 + 8) + *(a1 + 264);
            v4 = *(a1 + 12) + *(a1 + 256);
            v5 = *(a1 + 16) + *(a1 + 260);
            v6 = *(a1 + 20) + *(a1 + 264);
          }
          else
          {
            v7 = *a1 - *(a1 + 256);
            v8 = *(a1 + 4) - *(a1 + 260);
            v9 = *(a1 + 8) - *(a1 + 264);
            v4 = *(a1 + 12) - *(a1 + 256);
            v5 = *(a1 + 16) - *(a1 + 260);
            v6 = *(a1 + 20) - *(a1 + 264);
          }
        }
        else
        {
          v22 = *(a1 + 12 * v18[4] + 64) * *&v13 + *(a1 + 12 * v18[4] + 68) * *&v14 + *(a1 + 12 * v18[4] + 72) * *&v15;
          v3 = fabs(v22);
          v16 = v3 + v16;
          v7 = *a1;
          v8 = *(a1 + 4);
          v9 = *(a1 + 8);
          v4 = *(a1 + 12);
          v5 = *(a1 + 16);
          v6 = *(a1 + 20);
        }
        if ( !sub_8050216(&v13, &v7, &v4, &v21, &v20, &v24) )
          break;
        if ( v24 )
        {
          v23 = i;
          v10 = v13;
          v11 = v14;
          v12 = v15;
        }
      }
      if ( i >= v17[1] && v23 != v17[1] - 1 && v20 > v21 && v21 >= 0.0 && *(a1 + 196) > v21 )
      {
        if ( v21 < 0.0 )
          v21 = 0.0;
        *(a1 + 196) = v21;
        *(a1 + 212) = v10;
        *(a1 + 216) = v11;
        *(a1 + 220) = v12;
      }
    }
    ++v26;
    v17 += 80;
  }
  return result;
}

//----- (080509F7) --------------------------------------------------------
int __cdecl sub_80509F7(int a1, _DWORD *a2)
{
  float v4; // [esp+2Ch] [ebp-6Ch]
  float v5; // [esp+30h] [ebp-68h] BYREF
  float v6; // [esp+34h] [ebp-64h]
  float v7; // [esp+38h] [ebp-60h]
  float v8; // [esp+40h] [ebp-58h] BYREF
  float v9; // [esp+44h] [ebp-54h]
  float v10; // [esp+48h] [ebp-50h]
  unsigned int v11; // [esp+50h] [ebp-48h] BYREF
  float v12; // [esp+54h] [ebp-44h]
  float v13; // [esp+58h] [ebp-40h]
  float v14; // [esp+5Ch] [ebp-3Ch]
  _DWORD *v15; // [esp+68h] [ebp-30h]
  int *v16; // [esp+6Ch] [ebp-2Ch]
  float v17; // [esp+70h] [ebp-28h]
  float v18; // [esp+74h] [ebp-24h] BYREF
  float v19; // [esp+78h] [ebp-20h] BYREF
  float v20; // [esp+7Ch] [ebp-1Ch]
  int v21; // [esp+80h] [ebp-18h]
  int v22; // [esp+84h] [ebp-14h] BYREF
  int i; // [esp+88h] [ebp-10h]
  int v24; // [esp+8Ch] [ebp-Ch]

  if ( *(a1 + 192) )
    return sub_804FD53(a1, a2);
  v15 = a2[3];
  v24 = 0;
  while ( v24 < a2[2] )
  {
    v19 = -1.0;
    v18 = 1.0;
    v21 = -1;
    v16 = (a2[1] + 20 * *v15);
    v11 = *v16;
    v12 = *(v16 + 1);
    v13 = *(v16 + 2);
    v14 = *(v16 + 3);
    if ( *(a1 + 244) )
    {
      v14 = v14 + *(a1 + 248);
      v17 = *&v11 * *(a1 + 256) + v12 * *(a1 + 260) + v13 * *(a1 + 264);
      if ( v17 <= 0.0 )
      {
        v8 = *a1 + *(a1 + 256);
        v9 = *(a1 + 4) + *(a1 + 260);
        v10 = *(a1 + 8) + *(a1 + 264);
        v5 = *(a1 + 12) + *(a1 + 256);
        v6 = *(a1 + 16) + *(a1 + 260);
        v7 = *(a1 + 20) + *(a1 + 264);
      }
      else
      {
        v8 = *a1 - *(a1 + 256);
        v9 = *(a1 + 4) - *(a1 + 260);
        v10 = *(a1 + 8) - *(a1 + 264);
        v5 = *(a1 + 12) - *(a1 + 256);
        v6 = *(a1 + 16) - *(a1 + 260);
        v7 = *(a1 + 20) - *(a1 + 264);
      }
    }
    else
    {
      v20 = *(a1 + 12 * v16[4] + 64) * *&v11 + *(a1 + 12 * v16[4] + 68) * v12 + *(a1 + 12 * v16[4] + 72) * v13;
      v14 = v14 - v20;
      v8 = *a1;
      v9 = *(a1 + 4);
      v10 = *(a1 + 8);
      v5 = *(a1 + 12);
      v6 = *(a1 + 16);
      v7 = *(a1 + 20);
    }
    if ( sub_8050216(&v11, &v8, &v5, &v19, &v18, &v22) )
    {
      for ( i = 0; i < v15[1]; ++i )
      {
        v16 = (a2[1] + 20 * v15[i + 2]);
        if ( v15[i + 28] )
        {
          v11 = *v16 ^ 0x80000000;
          LODWORD(v12) = v16[1] ^ 0x80000000;
          LODWORD(v13) = v16[2] ^ 0x80000000;
          LODWORD(v14) = v16[3] ^ 0x80000000;
        }
        else
        {
          v11 = *v16;
          v12 = *(v16 + 1);
          v13 = *(v16 + 2);
          v14 = *(v16 + 3);
        }
        if ( *(a1 + 244) )
        {
          v14 = v14 + *(a1 + 248);
          v17 = *&v11 * *(a1 + 256) + v12 * *(a1 + 260) + v13 * *(a1 + 264);
          if ( v17 <= 0.0 )
          {
            v8 = *a1 + *(a1 + 256);
            v9 = *(a1 + 4) + *(a1 + 260);
            v10 = *(a1 + 8) + *(a1 + 264);
            v5 = *(a1 + 12) + *(a1 + 256);
            v6 = *(a1 + 16) + *(a1 + 260);
            v7 = *(a1 + 20) + *(a1 + 264);
          }
          else
          {
            v8 = *a1 - *(a1 + 256);
            v9 = *(a1 + 4) - *(a1 + 260);
            v10 = *(a1 + 8) - *(a1 + 264);
            v5 = *(a1 + 12) - *(a1 + 256);
            v6 = *(a1 + 16) - *(a1 + 260);
            v7 = *(a1 + 20) - *(a1 + 264);
          }
        }
        else
        {
          v20 = *(a1 + 12 * v16[4] + 64) * *&v11 + *(a1 + 12 * v16[4] + 68) * v12 + *(a1 + 12 * v16[4] + 72) * v13;
          v4 = fabs(v20);
          v14 = v4 + v14;
          v8 = *a1;
          v9 = *(a1 + 4);
          v10 = *(a1 + 8);
          v5 = *(a1 + 12);
          v6 = *(a1 + 16);
          v7 = *(a1 + 20);
        }
        if ( !sub_8050216(&v11, &v8, &v5, &v19, &v18, &v22) )
          break;
        if ( v22 )
          v21 = i;
      }
      if ( i >= v15[1] && v21 != v15[1] - 1 && v18 > v19 && v19 >= 0.0 )
        return 0;
    }
    ++v24;
    v15 += 80;
  }
  return 1;
}

//----- (08050FC6) --------------------------------------------------------
int __cdecl sub_8050FC6(int a1, _DWORD *a2)
{
  float v4; // [esp+Ch] [ebp-4Ch]
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+10h] [ebp-48h]
  float v7; // [esp+14h] [ebp-44h]
  float v8; // [esp+14h] [ebp-44h]
  float v9; // [esp+18h] [ebp-40h]
  float v10; // [esp+18h] [ebp-40h]
  float v11; // [esp+20h] [ebp-38h]
  float v12; // [esp+20h] [ebp-38h]
  float v13; // [esp+24h] [ebp-34h]
  float v14; // [esp+24h] [ebp-34h]
  float v15; // [esp+28h] [ebp-30h]
  float v16; // [esp+28h] [ebp-30h]
  float v17; // [esp+2Ch] [ebp-2Ch]
  float v18; // [esp+2Ch] [ebp-2Ch]
  float v19; // [esp+2Ch] [ebp-2Ch]
  float v20; // [esp+2Ch] [ebp-2Ch]
  _DWORD *v21; // [esp+38h] [ebp-20h]
  int v22; // [esp+3Ch] [ebp-1Ch]
  float *v23; // [esp+3Ch] [ebp-1Ch]
  float v24; // [esp+40h] [ebp-18h]
  float v25; // [esp+40h] [ebp-18h]
  float v26; // [esp+44h] [ebp-14h]
  float v27; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( *(a1 + 192) )
    return 0;
  v21 = a2[3];
  for ( i = 0; i < a2[2]; ++i )
  {
    v22 = a2[1] + 20 * *v21;
    v11 = *v22;
    v13 = *(v22 + 4);
    v15 = *(v22 + 8);
    v17 = *(v22 + 12);
    if ( *(a1 + 244) )
    {
      v18 = v17 + *(a1 + 248);
      v24 = v11 * *(a1 + 256) + v13 * *(a1 + 260) + v15 * *(a1 + 264);
      if ( v24 <= 0.0 )
      {
        v5 = *a1 + *(a1 + 256);
        v7 = *(a1 + 4) + *(a1 + 260);
        v9 = *(a1 + 8) + *(a1 + 264);
      }
      else
      {
        v5 = *a1 - *(a1 + 256);
        v7 = *(a1 + 4) - *(a1 + 260);
        v9 = *(a1 + 8) - *(a1 + 264);
      }
    }
    else
    {
      v26 = *(a1 + 12 * *(v22 + 16) + 64) * v11
          + *(a1 + 12 * *(v22 + 16) + 68) * v13
          + *(a1 + 12 * *(v22 + 16) + 72) * v15;
      v18 = v17 - v26;
      v5 = *a1;
      v7 = *(a1 + 4);
      v9 = *(a1 + 8);
    }
    if ( v11 * v5 + v13 * v7 + v15 * v9 - v18 <= 0.0 )
    {
      for ( j = 0; j < v21[1]; ++j )
      {
        v23 = (a2[1] + 20 * v21[j + 2]);
        if ( v21[j + 28] )
        {
          LODWORD(v12) = *v23 ^ 0x80000000;
          LODWORD(v14) = *(v23 + 1) ^ 0x80000000;
          LODWORD(v16) = *(v23 + 2) ^ 0x80000000;
          LODWORD(v19) = *(v23 + 3) ^ 0x80000000;
        }
        else
        {
          v12 = *v23;
          v14 = v23[1];
          v16 = v23[2];
          v19 = v23[3];
        }
        if ( *(a1 + 244) )
        {
          v20 = v19 + *(a1 + 248);
          v25 = v12 * *(a1 + 256) + v14 * *(a1 + 260) + v16 * *(a1 + 264);
          if ( v25 <= 0.0 )
          {
            v6 = *a1 + *(a1 + 256);
            v8 = *(a1 + 4) + *(a1 + 260);
            v10 = *(a1 + 8) + *(a1 + 264);
          }
          else
          {
            v6 = *a1 - *(a1 + 256);
            v8 = *(a1 + 4) - *(a1 + 260);
            v10 = *(a1 + 8) - *(a1 + 264);
          }
        }
        else
        {
          v27 = *(a1 + 12 * *(v23 + 4) + 64) * v12
              + *(a1 + 12 * *(v23 + 4) + 68) * v14
              + *(a1 + 12 * *(v23 + 4) + 72) * v16;
          v4 = fabs(v27);
          v20 = v4 + v19;
          v6 = *a1;
          v8 = *(a1 + 4);
          v10 = *(a1 + 8);
        }
        if ( v12 * v6 + v14 * v8 + v16 * v10 - v20 > 0.0 )
          break;
      }
      if ( j >= v21[1] )
        return 1;
    }
    v21 += 80;
  }
  return 0;
}

//----- (08051484) --------------------------------------------------------
void *__cdecl sub_8051484(int a1)
{
  if ( ++dword_84639EC > dword_84639E8 )
    dword_84639E8 = dword_84639EC;
  return sub_806BB38(12 * a1 + 4);
}
// 84639E8: using guessed type int dword_84639E8;
// 84639EC: using guessed type int dword_84639EC;

//----- (080514CC) --------------------------------------------------------
void __cdecl sub_80514CC(void *ptr)
{
  if ( *ptr == -559030611 )
    sub_80704AC(0, &byte_80DC520);
  *ptr = -559030611;
  --dword_84639EC;
  sub_806BB25(ptr);
}
// 84639EC: using guessed type int dword_84639EC;

//----- (080517A4) --------------------------------------------------------
float *__cdecl sub_80517A4(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4[4]; // [esp+10h] [ebp-28h] BYREF
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  v5[0] = a1[4] - a1[1];
  v5[1] = a1[5] - a1[2];
  v5[2] = a1[6] - a1[3];
  v4[0] = a1[7] - a1[1];
  v4[1] = a1[8] - a1[2];
  v4[2] = a1[9] - a1[3];
  sub_80666B1(v4, v5, a2);
  sub_80669A0(a2, a2);
  result = a1;
  *a3 = a1[1] * *a2 + a1[2] * a2[1] + a1[3] * a2[2];
  return result;
}

//----- (08051863) --------------------------------------------------------
long double __cdecl sub_8051863(int a1)
{
  float v2; // [esp+28h] [ebp-50h]
  float v3; // [esp+2Ch] [ebp-4Ch]
  float v4; // [esp+30h] [ebp-48h] BYREF
  float v5; // [esp+34h] [ebp-44h]
  float v6; // [esp+38h] [ebp-40h]
  float v7[4]; // [esp+40h] [ebp-38h] BYREF
  float v8[7]; // [esp+50h] [ebp-28h] BYREF
  int i; // [esp+6Ch] [ebp-Ch]

  v3 = 0.0;
  for ( i = 2; i < *a1; ++i )
  {
    v8[0] = *(a1 + 12 * i - 8) - *(a1 + 4);
    v8[1] = *(a1 + 12 * i - 4) - *(a1 + 8);
    v8[2] = *(a1 + 12 * i) - *(a1 + 12);
    v7[0] = *(a1 + 12 * i + 4) - *(a1 + 4);
    v7[1] = *(a1 + 12 * i + 8) - *(a1 + 8);
    v7[2] = *(a1 + 12 * i + 12) - *(a1 + 12);
    sub_80666B1(v8, v7, &v4);
    v2 = sqrt(v4 * v4 + v5 * v5 + v6 * v6);
    v3 = v2 * 0.5 + v3;
  }
  return v3;
}

//----- (0805199E) --------------------------------------------------------
int __cdecl sub_805199E(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int j; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-8h]

  a2[2] = 1207959552;
  a2[1] = 1207959552;
  *a2 = 1207959552;
  a3[2] = -939524096;
  a3[1] = -939524096;
  *a3 = -939524096;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *a1 )
      break;
    for ( j = 0; j <= 2; ++j )
    {
      v6 = *&a1[3 * i + 1 + j];
      if ( *&a2[j] > v6 )
        *&a2[j] = v6;
      if ( v6 > *&a3[j] )
        *&a3[j] = v6;
    }
  }
  return result;
}

//----- (08051B87) --------------------------------------------------------
float *__cdecl sub_8051B87(int a1, float a2)
{
  float *result; // eax
  float v3; // [esp+30h] [ebp-48h] BYREF
  float v4; // [esp+34h] [ebp-44h]
  float v5; // [esp+38h] [ebp-40h]
  float v6; // [esp+40h] [ebp-38h] BYREF
  float v7; // [esp+44h] [ebp-34h]
  float v8; // [esp+48h] [ebp-30h]
  float v9; // [esp+50h] [ebp-28h]
  float v10; // [esp+54h] [ebp-24h]
  float v11; // [esp+58h] [ebp-20h]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  int v14; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v13 = -131072.0;
  v14 = -1;
  for ( i = 0; i <= 2; ++i )
  {
    v12 = fabs(*(a1 + 4 * i));
    if ( v12 > v13 )
    {
      v14 = i;
      v13 = v12;
    }
  }
  if ( v14 == -1 )
    sub_80704AC(1, &byte_80DC560);
  v3 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  if ( v14 >= 0 )
  {
    if ( v14 <= 1 )
      v5 = 1.0;
    else
      v3 = 1.0;
  }
  v12 = v3 * *a1 + v4 * *(a1 + 4) + v5 * *(a1 + 8);
  v3 = -v12 * *a1 + v3;
  v4 = -v12 * *(a1 + 4) + v4;
  v5 = -v12 * *(a1 + 8) + v5;
  sub_80669A0(&v3, &v3);
  v9 = *a1 * a2;
  v10 = *(a1 + 4) * a2;
  v11 = *(a1 + 8) * a2;
  sub_80666B1(&v3, a1, &v6);
  v3 = v3 * 131072.0;
  v4 = v4 * 131072.0;
  v5 = v5 * 131072.0;
  v6 = v6 * 131072.0;
  v7 = v7 * 131072.0;
  v8 = v8 * 131072.0;
  result = sub_8051484(4);
  result[1] = v9 - v6;
  result[2] = v10 - v7;
  result[3] = v11 - v8;
  result[1] = result[1] + v3;
  result[2] = result[2] + v4;
  result[3] = result[3] + v5;
  result[4] = v9 + v6;
  result[5] = v10 + v7;
  result[6] = v11 + v8;
  result[4] = result[4] + v3;
  result[5] = result[5] + v4;
  result[6] = result[6] + v5;
  result[7] = v9 + v6;
  result[8] = v10 + v7;
  result[9] = v11 + v8;
  result[7] = result[7] - v3;
  result[8] = result[8] - v4;
  result[9] = result[9] - v5;
  result[10] = v9 - v6;
  result[11] = v10 - v7;
  result[12] = v11 - v8;
  result[10] = result[10] - v3;
  result[11] = result[11] - v4;
  result[12] = result[12] - v5;
  *result = 4;
  return result;
}
// 8051C2B: conditional instruction was optimized away because of '%var_54.4==2'

//----- (08051EBB) --------------------------------------------------------
void *__cdecl sub_8051EBB(void *src)
{
  void *dest; // [esp+10h] [ebp-8h]

  dest = sub_8051484(*src);
  sub_80C835C(dest, src, 12 * *src + 4);
  return dest;
}

//----- (08051FE8) --------------------------------------------------------
int *__cdecl sub_8051FE8(void *src, int a2, float a3, float a4, int a5, int a6)
{
  void *v6; // edx
  int *result; // eax
  void *v8; // edx
  int v9; // [esp+24h] [ebp-274h]
  int *v10; // [esp+28h] [ebp-270h]
  int *v11; // [esp+2Ch] [ebp-26Ch]
  int v12; // [esp+30h] [ebp-268h]
  int v13; // [esp+34h] [ebp-264h]
  int v14; // [esp+38h] [ebp-260h]
  int v15; // [esp+40h] [ebp-258h]
  int *v16; // [esp+44h] [ebp-254h]
  int j; // [esp+48h] [ebp-250h]
  int i; // [esp+4Ch] [ebp-24Ch]
  int v19; // [esp+50h] [ebp-248h]
  int v20; // [esp+54h] [ebp-244h]
  int v21; // [esp+58h] [ebp-240h]
  int v22[68]; // [esp+60h] [ebp-238h]
  int v23[74]; // [esp+170h] [ebp-128h]

  v21 = 0;
  v20 = 0;
  v19 = 0;
  for ( i = 0; i < *src; ++i )
  {
    flt_81B3660 = *(src + 3 * i + 1) * *a2 + *(src + 3 * i + 2) * *(a2 + 4) + *(src + 3 * i + 3) * *(a2 + 8);
    flt_81B3660 = flt_81B3660 - a3;
    v23[i] = LODWORD(flt_81B3660);
    if ( flt_81B3660 <= a4 )
    {
      if ( -a4 <= flt_81B3660 )
        v22[i] = 2;
      else
        v22[i] = 1;
    }
    else
    {
      v22[i] = 0;
    }
    ++*(&v19 + v22[i]);
  }
  v22[i] = v22[0];
  v23[i] = v23[0];
  *a6 = 0;
  *a5 = 0;
  if ( v19 )
  {
    if ( v20 )
    {
      v9 = *src + 4;
      v11 = sub_8051484(v9);
      *a5 = v11;
      v10 = sub_8051484(v9);
      *a6 = v10;
      for ( i = 0; i < *src; ++i )
      {
        v16 = (src + 12 * i + 4);
        if ( v22[i] == 2 )
        {
          v11[3 * *v11 + 1] = *v16;
          v11[3 * *v11 + 2] = v16[1];
          v11[3 * (*v11)++ + 3] = v16[2];
          v10[3 * *v10 + 1] = *v16;
          v10[3 * *v10 + 2] = v16[1];
          v10[3 * (*v10)++ + 3] = v16[2];
        }
        else
        {
          if ( !v22[i] )
          {
            v11[3 * *v11 + 1] = *v16;
            v11[3 * *v11 + 2] = v16[1];
            v11[3 * (*v11)++ + 3] = v16[2];
          }
          if ( v22[i] == 1 )
          {
            v10[3 * *v10 + 1] = *v16;
            v10[3 * *v10 + 2] = v16[1];
            v10[3 * (*v10)++ + 3] = v16[2];
          }
          if ( v22[i + 1] != 2 && v22[i + 1] != v22[i] )
          {
            v15 = src + 12 * ((i + 1) % *src) + 4;
            flt_81B3660 = *&v23[i] / (*&v23[i] - *&v23[i + 1]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( *(a2 + 4 * j) == 1.0 )
              {
                *(&v12 + j) = a3;
              }
              else if ( *(a2 + 4 * j) == -1.0 )
              {
                *(&v12 + j) = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                *(&v12 + j) = (*(v15 + 4 * j) - *&v16[j]) * flt_81B3660 + *&v16[j];
              }
            }
            v11[3 * *v11 + 1] = v12;
            v11[3 * *v11 + 2] = v13;
            v11[3 * (*v11)++ + 3] = v14;
            v10[3 * *v10 + 1] = v12;
            v10[3 * *v10 + 2] = v13;
            v10[3 * (*v10)++ + 3] = v14;
          }
        }
      }
      if ( *v11 > v9 || *v10 > v9 )
        sub_80704AC(1, &byte_80DC5A0);
      if ( *v11 > 64 || (result = v10, *v10 > 64) )
        sub_80704AC(1, &byte_80DC5E0);
    }
    else
    {
      v8 = sub_8051EBB(src);
      result = a5;
      *a5 = v8;
    }
  }
  else
  {
    v6 = sub_8051EBB(src);
    result = a6;
    *a6 = v6;
  }
  return result;
}
// 81B3660: using guessed type float flt_81B3660;

//----- (0805275D) --------------------------------------------------------
int *__cdecl sub_805275D(int a1, int a2, float a3, float a4)
{
  int *result; // eax
  int v5; // [esp+28h] [ebp-280h]
  int *v6; // [esp+2Ch] [ebp-27Ch]
  int v7[4]; // [esp+30h] [ebp-278h]
  int v8; // [esp+40h] [ebp-268h]
  int *v9; // [esp+44h] [ebp-264h]
  int j; // [esp+48h] [ebp-260h]
  int i; // [esp+4Ch] [ebp-25Ch]
  int v12; // [esp+50h] [ebp-258h]
  int v13; // [esp+54h] [ebp-254h]
  int v14; // [esp+58h] [ebp-250h]
  int v15[68]; // [esp+60h] [ebp-248h]
  int v16[71]; // [esp+170h] [ebp-138h]
  void *ptr; // [esp+28Ch] [ebp-1Ch]

  ptr = *a1;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *ptr; ++i )
  {
    flt_81B3664 = *(ptr + 3 * i + 1) * *a2 + *(ptr + 3 * i + 2) * *(a2 + 4) + *(ptr + 3 * i + 3) * *(a2 + 8);
    flt_81B3664 = flt_81B3664 - a3;
    v16[i] = LODWORD(flt_81B3664);
    if ( flt_81B3664 <= a4 )
    {
      if ( -a4 <= flt_81B3664 )
        v15[i] = 2;
      else
        v15[i] = 1;
    }
    else
    {
      v15[i] = 0;
    }
    ++*(&v12 + v15[i]);
  }
  v15[i] = v15[0];
  result = v16[0];
  v16[i] = v16[0];
  if ( v12 )
  {
    if ( v13 )
    {
      v5 = *ptr + 4;
      v6 = sub_8051484(v5);
      for ( i = 0; i < *ptr; ++i )
      {
        v9 = (ptr + 12 * i + 4);
        if ( v15[i] == 2 )
        {
          v6[3 * *v6 + 1] = *v9;
          v6[3 * *v6 + 2] = v9[1];
          v6[3 * (*v6)++ + 3] = v9[2];
        }
        else
        {
          if ( !v15[i] )
          {
            v6[3 * *v6 + 1] = *v9;
            v6[3 * *v6 + 2] = v9[1];
            v6[3 * (*v6)++ + 3] = v9[2];
          }
          if ( v15[i + 1] != 2 && v15[i + 1] != v15[i] )
          {
            v8 = ptr + 12 * ((i + 1) % *ptr) + 4;
            flt_81B3664 = *&v16[i] / (*&v16[i] - *&v16[i + 1]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( *(a2 + 4 * j) == 1.0 )
              {
                *&v7[j] = a3;
              }
              else if ( *(a2 + 4 * j) == -1.0 )
              {
                v7[j] = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                *&v7[j] = (*(v8 + 4 * j) - *&v9[j]) * flt_81B3664 + *&v9[j];
              }
            }
            v6[3 * *v6 + 1] = v7[0];
            v6[3 * *v6 + 2] = v7[1];
            v6[3 * (*v6)++ + 3] = v7[2];
          }
        }
      }
      if ( *v6 > v5 )
        sub_80704AC(1, &byte_80DC5A0);
      if ( *v6 > 64 )
        sub_80704AC(1, &byte_80DC5E0);
      sub_80514CC(ptr);
      result = v6;
      *a1 = v6;
    }
  }
  else
  {
    sub_80514CC(ptr);
    result = a1;
    *a1 = 0;
  }
  return result;
}
// 81B3664: using guessed type float flt_81B3664;

//----- (0805366C) --------------------------------------------------------
void *__cdecl sub_805366C(size_t a1)
{
  return sub_806C3D4(a1);
}

//----- (0805367F) --------------------------------------------------------
void *__cdecl sub_805367F(size_t a1)
{
  return sub_806C3D4(a1);
}

//----- (08053692) --------------------------------------------------------
int __cdecl sub_8053692(int a1, const char *a2, float *a3, float *a4, float *a5)
{
  int result; // eax
  float v6; // [esp+20h] [ebp-38h] BYREF
  float v7; // [esp+24h] [ebp-34h]
  float v8; // [esp+28h] [ebp-30h]
  float v9; // [esp+2Ch] [ebp-2Ch]
  float v10; // [esp+30h] [ebp-28h]
  float v11; // [esp+34h] [ebp-24h]
  float v12; // [esp+38h] [ebp-20h]
  float v13; // [esp+3Ch] [ebp-1Ch]
  float v14; // [esp+40h] [ebp-18h]

  if ( !a2 || !*a2 )
    sub_80704AC(1, &byte_80DC6E0, *a3, a3[1], a3[2]);
  if ( *a5 == 0.0 )
    sub_80704AC(1, &byte_80DC720, a2);
  if ( a5[1] == 0.0 )
    sub_80704AC(1, &byte_80DC760, a2);
  if ( a5[2] == 0.0 )
    sub_80704AC(1, &byte_80DC7A0, a2);
  *a1 = sub_80C382C(a2, 1, sub_805366C);
  *(a1 + 4) = *a3;
  *(a1 + 8) = a3[1];
  *(a1 + 12) = a3[2];
  sub_806A46E(a4, &v6);
  v6 = v6 * *a5;
  v7 = v7 * *a5;
  v8 = v8 * *a5;
  v9 = v9 * a5[1];
  v10 = v10 * a5[1];
  v11 = v11 * a5[1];
  v12 = v12 * a5[2];
  v13 = v13 * a5[2];
  v14 = v14 * a5[2];
  sub_80688AC(&v6, (a1 + 16));
  result = sub_80C4CB2(*a1, &v6, (a1 + 56), (a1 + 68));
  if ( result )
  {
    *(a1 + 56) = *(a1 + 56) + *a3;
    *(a1 + 60) = *(a1 + 60) + a3[1];
    *(a1 + 64) = *(a1 + 64) + a3[2];
    *(a1 + 68) = *(a1 + 68) + *a3;
    *(a1 + 72) = *(a1 + 72) + a3[1];
    *(a1 + 76) = *(a1 + 76) + a3[2];
    result = sub_80C4334(*a1);
    if ( result )
      result = sub_805E02B(a1);
  }
  return result;
}

//----- (0805391F) --------------------------------------------------------
char *sub_805391F()
{
  char *result; // eax
  int v1; // [esp+28h] [ebp-110h]
  int v2; // [esp+2Ch] [ebp-10Ch]
  int v3; // [esp+2Ch] [ebp-10Ch]
  int v4; // [esp+30h] [ebp-108h] BYREF
  int v5; // [esp+34h] [ebp-104h] BYREF
  float v6; // [esp+38h] [ebp-100h] BYREF
  int v7; // [esp+40h] [ebp-F8h] BYREF
  int v8; // [esp+44h] [ebp-F4h] BYREF
  int v9; // [esp+48h] [ebp-F0h] BYREF
  int v10; // [esp+50h] [ebp-E8h] BYREF
  int v11; // [esp+54h] [ebp-E4h] BYREF
  int v12; // [esp+58h] [ebp-E0h] BYREF
  char s1[64]; // [esp+60h] [ebp-D8h] BYREF
  char dest[64]; // [esp+A0h] [ebp-98h] BYREF
  char v15[7]; // [esp+E0h] [ebp-58h] BYREF
  char v16[65]; // [esp+E7h] [ebp-51h] BYREF
  char *v17; // [esp+128h] [ebp-10h] BYREF
  char *src; // [esp+12Ch] [ebp-Ch]

  v17 = dword_8459924;
  dword_84598C0 = 0;
  dword_84598C4 = 0;
  while ( 1 )
  {
    result = sub_8085E0B(&v17);
    src = result;
    if ( !*result )
      break;
    result = src;
    if ( *src != 123 )
      break;
    v2 = 0;
    while ( 1 )
    {
      src = sub_8085E0B(&v17);
      if ( !*src )
        break;
      if ( *src == 125 )
        break;
      strcpy(dest, src);
      src = sub_8085E0B(&v17);
      if ( !*src )
        break;
      strcpy(s1, src);
      if ( !strcasecmp(dest, "classname") && !strcasecmp(s1, "misc_model") )
        v2 = 1;
    }
    if ( v2 )
      ++dword_84598C0;
  }
  if ( dword_84598C0 )
  {
    dword_84598C4 = sub_806C3D4(84 * dword_84598C0);
    v17 = dword_8459924;
    v1 = 0;
    while ( 1 )
    {
      result = sub_8085E0B(&v17);
      src = result;
      if ( !*result )
        break;
      result = src;
      if ( *src != 123 )
        break;
      v15[0] = 0;
      v12 = 0;
      v11 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
      v7 = 0;
      v6 = 1.0;
      v5 = 1065353216;
      v4 = 1065353216;
      v3 = 0;
      while ( 1 )
      {
        src = sub_8085E0B(&v17);
        if ( !*src )
          break;
        if ( *src == 125 )
          break;
        strcpy(dest, src);
        src = sub_8085E0B(&v17);
        if ( !*src )
          break;
        strcpy(s1, src);
        if ( !strcasecmp(dest, "classname") )
        {
          if ( !strcasecmp(s1, "misc_model") )
            v3 = 1;
        }
        else if ( !strcasecmp(dest, "model") )
        {
          strcpy(v15, s1);
        }
        else if ( !strcasecmp(dest, "origin") )
        {
          sscanf(s1, "%f %f %f", &v10, &v11, &v12);
        }
        else if ( !strcasecmp(dest, "angles") )
        {
          sscanf(s1, "%f %f %f", &v7, &v8, &v9);
        }
        else if ( !strcasecmp(dest, "modelscale_vec") )
        {
          sscanf(s1, "%f %f %f", &v4, &v5, &v6);
        }
        else if ( !strcasecmp(dest, "modelscale") )
        {
          v6 = atof(s1);
          v5 = LODWORD(v6);
          v4 = LODWORD(v6);
        }
      }
      if ( v3 )
        sub_8053692(dword_84598C4 + 84 * v1++, v16, &v10, &v7, &v4);
    }
  }
  return result;
}
// 84598C0: using guessed type int dword_84598C0;
// 84598C4: using guessed type int dword_84598C4;

//----- (08053D9B) --------------------------------------------------------
int __cdecl sub_8053D9B(int a1, int *a2, float *a3, float *a4, int a5)
{
  void *v5; // esp
  int result; // eax
  _BYTE v7[20]; // [esp+18h] [ebp-B0h] BYREF
  int v8; // [esp+2Ch] [ebp-9Ch]
  int v9[4]; // [esp+30h] [ebp-98h] BYREF
  float v10; // [esp+40h] [ebp-88h]
  float v11; // [esp+44h] [ebp-84h]
  float v12; // [esp+48h] [ebp-80h]
  float v13; // [esp+50h] [ebp-78h] BYREF
  float v14; // [esp+54h] [ebp-74h]
  float v15; // [esp+58h] [ebp-70h]
  float v16[4]; // [esp+60h] [ebp-68h] BYREF
  float v17[4]; // [esp+70h] [ebp-58h] BYREF
  int v18[15]; // [esp+80h] [ebp-48h] BYREF
  _BYTE *v19; // [esp+BCh] [ebp-Ch]

  v18[0] = *a2;
  v8 = sub_80C3F5E(*a1);
  v5 = alloca(16 * (((v8 << 6) + 15) >> 4));
  v19 = v7;
  sub_80C4658(*a1, v7);
  v13 = *a3 - *(a1 + 4);
  v14 = a3[1] - *(a1 + 8);
  v15 = a3[2] - *(a1 + 12);
  sub_8069154(&v13, (a1 + 16), v16);
  v13 = *a4 - *(a1 + 4);
  v14 = a4[1] - *(a1 + 8);
  v15 = a4[2] - *(a1 + 12);
  sub_8069154(&v13, (a1 + 16), v17);
  result = sub_80C4892(*a1, v18, v19, v16, v17, a5);
  if ( result >= 0 )
  {
    LOWORD(v18[10]) = 1022;
    v10 = *a4 - *a3;
    v11 = a4[1] - a3[1];
    v12 = a4[2] - a3[2];
    *&v18[1] = v10 * *v18 + *a3;
    *&v18[2] = v11 * *v18 + a3[1];
    *&v18[3] = v12 * *v18 + a3[2];
    sub_80691FE(&v18[4], (a1 + 16), v9);
    sub_8066755(v9);
    v18[4] = v9[0];
    v18[5] = v9[1];
    v18[6] = v9[2];
    result = 12;
    qmemcpy(a2, v18, 0x30u);
  }
  return result;
}

//----- (08053FA4) --------------------------------------------------------
int __cdecl sub_8053FA4(int a1, int a2, __int16 a3, __int16 a4)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i < a1; ++i )
  {
    if ( *(a2 + 4 * i) == a4 && *(a2 + 4 * i + 2) == a3 || *(a2 + 4 * i) == a3 && *(a2 + 4 * i + 2) == a4 )
      return i;
  }
  return -1;
}

//----- (0805403E) --------------------------------------------------------
unsigned __int16 *__cdecl sub_805403E(int a1, int a2, unsigned int a3, int a4, float *a5)
{
  int v5; // esi
  char *v6; // ebx
  char v8; // [esp+2Fh] [ebp-109h]
  char *v9; // [esp+34h] [ebp-104h]
  char *v10; // [esp+3Ch] [ebp-FCh]
  char *v11; // [esp+44h] [ebp-F4h]
  char *v12; // [esp+4Ch] [ebp-ECh]
  char *v13; // [esp+54h] [ebp-E4h]
  char *v14; // [esp+5Ch] [ebp-DCh]
  float v15; // [esp+64h] [ebp-D4h]
  __int16 v16; // [esp+68h] [ebp-D0h]
  int v17; // [esp+68h] [ebp-D0h]
  __int16 v18; // [esp+6Ah] [ebp-CEh]
  __int16 v19; // [esp+6Ch] [ebp-CCh]
  __int16 v20; // [esp+6Ch] [ebp-CCh]
  __int16 v21; // [esp+6Eh] [ebp-CAh]
  float v22; // [esp+70h] [ebp-C8h]
  float v23; // [esp+74h] [ebp-C4h]
  float v24; // [esp+78h] [ebp-C0h]
  float v25; // [esp+7Ch] [ebp-BCh]
  float v26; // [esp+80h] [ebp-B8h] BYREF
  float v27; // [esp+84h] [ebp-B4h]
  float v28; // [esp+88h] [ebp-B0h]
  float v29; // [esp+90h] [ebp-A8h] BYREF
  float v30; // [esp+94h] [ebp-A4h]
  float v31; // [esp+98h] [ebp-A0h]
  int j; // [esp+A8h] [ebp-90h]
  int i; // [esp+ACh] [ebp-8Ch]
  float v34; // [esp+B0h] [ebp-88h]
  float v35; // [esp+B4h] [ebp-84h]
  float v36; // [esp+B8h] [ebp-80h]
  float v37; // [esp+BCh] [ebp-7Ch]
  float v38; // [esp+C0h] [ebp-78h] BYREF
  float v39; // [esp+C4h] [ebp-74h]
  float v40; // [esp+C8h] [ebp-70h]
  float v41; // [esp+D0h] [ebp-68h]
  float v42; // [esp+D4h] [ebp-64h]
  float v43; // [esp+D8h] [ebp-60h]
  float v44[4]; // [esp+E0h] [ebp-58h] BYREF
  float v45[5]; // [esp+F0h] [ebp-48h] BYREF
  int v46; // [esp+104h] [ebp-34h]
  int v47; // [esp+108h] [ebp-30h]
  int v48; // [esp+10Ch] [ebp-2Ch]
  int v49; // [esp+110h] [ebp-28h]
  char *v50; // [esp+114h] [ebp-24h]
  _DWORD *v51; // [esp+118h] [ebp-20h]
  unsigned __int16 *v52; // [esp+11Ch] [ebp-1Ch]

  if ( a1 % 3 )
    sub_80704AC(1, &byte_80DC820);
  if ( a3 > 0xFFFF )
    sub_80704AC(1, &byte_80DC860);
  v49 = 0;
  v48 = 0;
  for ( i = 0; i < a1; i += 3 )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v19 = *(a2 + 2 * (i + j));
      v18 = *(a2 + 2 * (i + (j + 1) % 3));
      v16 = *(a2 + 2 * (i + (j + 2) % 3));
      if ( v19 == v18 )
        sub_80704AC(1, &byte_80DC8A0);
      v46 = sub_8053FA4(v49, word_81B3680, v19, v18);
      if ( v46 >= 0 )
      {
        v45[0] = *(a4 + 12 * v19) - *(a4 + 12 * v16);
        v45[1] = *(a4 + 12 * v19 + 4) - *(a4 + 12 * v16 + 4);
        v45[2] = *(a4 + 12 * v19 + 8) - *(a4 + 12 * v16 + 8);
        v44[0] = *(a4 + 12 * v18) - *(a4 + 12 * v16);
        v44[1] = *(a4 + 12 * v18 + 4) - *(a4 + 12 * v16 + 4);
        v44[2] = *(a4 + 12 * v18 + 8) - *(a4 + 12 * v16 + 8);
        v41 = *(a4 + 12 * word_81F3680[v46]) - *(a4 + 12 * v16);
        v42 = *(a4 + 12 * word_81F3680[v46] + 4) - *(a4 + 12 * v16 + 4);
        v43 = *(a4 + 12 * word_81F3680[v46] + 8) - *(a4 + 12 * v16 + 8);
        sub_80666B1(v44, v45, &v38);
        v37 = v38 * v41 + v39 * v42 + v40 * v43;
        if ( v37 > 0.0 )
        {
          v34 = sub_80665E0((a4 + 12 * v19), (a4 + 12 * word_81F3680[v46]));
          v35 = sub_80665E0((a4 + 12 * v18), (a4 + 12 * word_81F3680[v46]));
          v15 = v34 <= v35 ? v35 : v34;
          v36 = v15;
          if ( v15 * 0.0000000064000001 > v38 * v38 + v39 * v39 + v40 * v40 )
          {
            --v49;
            ++v48;
            word_81B3680[2 * v46] = word_81B3680[2 * v49];
            word_81B3682[2 * v46] = word_81B3682[2 * v49];
            word_81F3680[v46] = word_81F3680[v49];
          }
        }
      }
      else
      {
        if ( v49 > 0xFFFF )
          sub_80704AC(1, &byte_80DC8E0);
        word_81B3680[2 * v49] = v19;
        word_81B3682[2 * v49] = v18;
        word_81F3680[v49++] = v16;
      }
    }
  }
  memset(word_8213680, -1, sizeof(word_8213680));
  v47 = 0;
  for ( i = 0; i < v49; ++i )
  {
    if ( word_8213680[word_81B3680[2 * i]] < 0 )
      word_8213680[word_81B3680[2 * i]] = v47++;
    if ( word_8213680[word_81B3682[2 * i]] < 0 )
      word_8213680[word_81B3682[2 * i]] = v47++;
  }
  v52 = sub_806C3D4(72 * (a1 / 3) + 4);
  v51 = sub_806C3D4(16 * v47);
  v50 = sub_806C3D4(56 * v49);
  v21 = 0;
  *v52 = a1 / 3;
  for ( i = 0; i < *v52; ++i )
  {
    v17 = *(a2 + 6 * i);
    v20 = *(a2 + 6 * i + 4);
    sub_806A964(&v52[36 * i + 2], (a4 + 12 * v17), (a4 + 12 * SHIWORD(v17)), (a4 + 12 * v20));
    if ( *&v52[36 * i + 6] >= -0.001 )
    {
      if ( *&v52[36 * i + 6] > 0.001 )
        LOBYTE(v21) = 1;
    }
    else
    {
      HIBYTE(v21) = 1;
    }
    v29 = *(a4 + 12 * SHIWORD(v17)) - *(a4 + 12 * v17);
    v30 = *(a4 + 12 * SHIWORD(v17) + 4) - *(a4 + 12 * v17 + 4);
    v31 = *(a4 + 12 * SHIWORD(v17) + 8) - *(a4 + 12 * v17 + 8);
    v25 = sub_8066755(&v29);
    v26 = *(a4 + 12 * v20) - *(a4 + 12 * v17);
    v27 = *(a4 + 12 * v20 + 4) - *(a4 + 12 * v17 + 4);
    v28 = *(a4 + 12 * v20 + 8) - *(a4 + 12 * v17 + 8);
    v24 = sub_8066755(&v26);
    v23 = v29 * v26 + v30 * v27 + v31 * v28;
    v22 = 1.0 / (1.0 - v23 * v23);
    v29 = v29 * v22;
    v30 = v30 * v22;
    v31 = v31 * v22;
    v26 = v26 * v22;
    v27 = v27 * v22;
    v28 = v28 * v22;
    *&v52[36 * i + 10] = -v23 * v26 + v29;
    *&v52[36 * i + 12] = -v23 * v27 + v30;
    *&v52[36 * i + 14] = -v23 * v28 + v31;
    *&v52[36 * i + 10] = 1.0 / v25 * *&v52[36 * i + 10];
    *&v52[36 * i + 12] = 1.0 / v25 * *&v52[36 * i + 12];
    *&v52[36 * i + 14] = 1.0 / v25 * *&v52[36 * i + 14];
    *&v52[36 * i + 16] = *&v52[36 * i + 10] * *(a4 + 12 * v17)
                       + *&v52[36 * i + 12] * *(a4 + 12 * v17 + 4)
                       + *&v52[36 * i + 14] * *(a4 + 12 * v17 + 8);
    *&v52[36 * i + 18] = -v23 * v29 + v26;
    *&v52[36 * i + 20] = -v23 * v30 + v27;
    *&v52[36 * i + 22] = -v23 * v31 + v28;
    *&v52[36 * i + 18] = 1.0 / v24 * *&v52[36 * i + 18];
    *&v52[36 * i + 20] = 1.0 / v24 * *&v52[36 * i + 20];
    *&v52[36 * i + 22] = 1.0 / v24 * *&v52[36 * i + 22];
    *&v52[36 * i + 24] = *&v52[36 * i + 18] * *(a4 + 12 * v17)
                       + *&v52[36 * i + 20] * *(a4 + 12 * v17 + 4)
                       + *&v52[36 * i + 22] * *(a4 + 12 * v17 + 8);
    if ( word_8213680[v17] < 0 )
      v14 = 0;
    else
      v14 = &v51[4 * word_8213680[v17]];
    *&v52[36 * i + 26] = v14;
    if ( word_8213680[SHIWORD(v17)] < 0 )
      v13 = 0;
    else
      v13 = &v51[4 * word_8213680[SHIWORD(v17)]];
    *&v52[36 * i + 28] = v13;
    if ( word_8213680[v20] < 0 )
      v12 = 0;
    else
      v12 = &v51[4 * word_8213680[v20]];
    *&v52[36 * i + 30] = v12;
    v46 = sub_8053FA4(v49, word_81B3680, SHIWORD(v17), v20);
    if ( v46 < 0 )
      v11 = 0;
    else
      v11 = &v50[56 * v46];
    *&v52[36 * i + 32] = v11;
    v46 = sub_8053FA4(v49, word_81B3680, v20, v17);
    if ( v46 < 0 )
      v10 = 0;
    else
      v10 = &v50[56 * v46];
    *&v52[36 * i + 34] = v10;
    v46 = sub_8053FA4(v49, word_81B3680, v17, SHIWORD(v17));
    if ( v46 < 0 )
      v9 = 0;
    else
      v9 = &v50[56 * v46];
    *&v52[36 * i + 36] = v9;
  }
  v8 = 0;
  if ( HIBYTE(v21) && !v21 )
    v8 = 1;
  *(v52 + 2) = v8;
  sub_806A164(a5, a5 + 3);
  for ( i = 0; i < a3; ++i )
  {
    sub_806A19F((a4 + 12 * i), a5, a5 + 3);
    if ( word_8213680[i] >= 0 )
    {
      v51[4 * word_8213680[i]] = 0;
      v51[4 * word_8213680[i] + 1] = *(a4 + 12 * i);
      v51[4 * word_8213680[i] + 2] = *(a4 + 12 * i + 4);
      v51[4 * word_8213680[i] + 3] = *(a4 + 12 * i + 8);
    }
  }
  for ( i = 0; i < v49; ++i )
  {
    *&v50[56 * i] = 0;
    *&v50[56 * i + 4] = *(a4 + 12 * word_81B3680[2 * i]);
    *&v50[56 * i + 8] = *(a4 + 12 * word_81B3680[2 * i] + 4);
    *&v50[56 * i + 12] = *(a4 + 12 * word_81B3680[2 * i] + 8);
    *&v50[56 * i + 40] = *(a4 + 12 * word_81B3682[2 * i]) - *(a4 + 12 * word_81B3680[2 * i]);
    *&v50[56 * i + 44] = *(a4 + 12 * word_81B3682[2 * i] + 4) - *(a4 + 12 * word_81B3680[2 * i] + 4);
    *&v50[56 * i + 48] = *(a4 + 12 * word_81B3682[2 * i] + 8) - *(a4 + 12 * word_81B3680[2 * i] + 8);
    v5 = 56 * i;
    v6 = v50;
    *&v6[v5 + 52] = sub_8066755(&v50[56 * i + 40]);
    sub_80676B4(&v50[56 * i + 16], &v50[56 * i + 40]);
    sub_80666B1(&v50[56 * i + 40], &v50[56 * i + 16], &v50[56 * i + 28]);
  }
  return v52;
}
// 81B3680: using guessed type __int16 word_81B3680[];

//----- (08055595) --------------------------------------------------------
int __cdecl sub_8055595(int a1, unsigned __int16 *a2)
{
  int result; // eax
  float v3; // [esp+8h] [ebp-40h]
  float v4; // [esp+Ch] [ebp-3Ch]
  float v5; // [esp+10h] [ebp-38h]
  float v6; // [esp+14h] [ebp-34h]
  float v7; // [esp+18h] [ebp-30h]
  float v8; // [esp+2Ch] [ebp-1Ch]
  float v9; // [esp+30h] [ebp-18h]
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v10 = *(a1 + 12) * *&a2[36 * i + 2]
        + *(a1 + 16) * *&a2[36 * i + 4]
        + *(a1 + 20) * *&a2[36 * i + 6]
        - *&a2[36 * i + 8];
    if ( v10 < 0.0 )
    {
      v11 = *a1 * *&a2[36 * i + 2] + *(a1 + 4) * *&a2[36 * i + 4] + *(a1 + 8) * *&a2[36 * i + 6] - *&a2[36 * i + 8];
      if ( v11 > 0.0 )
      {
        v9 = (v11 - 0.125) / (v11 - v10);
        if ( v9 < *(a1 + 196) )
        {
          v8 = v11 / (v11 - v10);
          v5 = *(a1 + 24) * v8 + *a1;
          v6 = *(a1 + 28) * v8 + *(a1 + 4);
          v7 = *(a1 + 32) * v8 + *(a1 + 8);
          v4 = v5 * *&a2[36 * i + 10] + v6 * *&a2[36 * i + 12] + v7 * *&a2[36 * i + 14] - *&a2[36 * i + 16];
          if ( v4 >= -0.001 && v4 <= 1.001 )
          {
            v3 = v5 * *&a2[36 * i + 18] + v6 * *&a2[36 * i + 20] + v7 * *&a2[36 * i + 22] - *&a2[36 * i + 24];
            if ( v3 >= -0.001 && v4 + v3 <= 1.001 )
            {
              *(a1 + 196) = v9;
              *(a1 + 212) = *&a2[36 * i + 2];
              *(a1 + 216) = *&a2[36 * i + 4];
              *(a1 + 220) = *&a2[36 * i + 6];
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080558DD) --------------------------------------------------------
int __cdecl sub_80558DD(int a1, unsigned __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+18h] [ebp-A0h]
  int v5; // [esp+1Ch] [ebp-9Ch]
  int v6; // [esp+20h] [ebp-98h]
  float v7; // [esp+28h] [ebp-90h]
  float v8; // [esp+2Ch] [ebp-8Ch]
  float v9; // [esp+30h] [ebp-88h]
  float v10; // [esp+30h] [ebp-88h]
  float v11; // [esp+34h] [ebp-84h]
  float v12; // [esp+38h] [ebp-80h]
  int v13; // [esp+3Ch] [ebp-7Ch]
  float v14; // [esp+40h] [ebp-78h]
  float v15; // [esp+40h] [ebp-78h]
  float v16; // [esp+44h] [ebp-74h]
  float v17; // [esp+44h] [ebp-74h]
  float v18; // [esp+48h] [ebp-70h]
  float v19; // [esp+48h] [ebp-70h]
  float v20; // [esp+4Ch] [ebp-6Ch]
  float v21; // [esp+4Ch] [ebp-6Ch]
  float v22; // [esp+50h] [ebp-68h]
  float v23; // [esp+54h] [ebp-64h]
  float v24; // [esp+58h] [ebp-60h]
  float v25; // [esp+60h] [ebp-58h]
  float v26; // [esp+60h] [ebp-58h]
  float v27; // [esp+60h] [ebp-58h]
  float v28; // [esp+64h] [ebp-54h]
  float v29; // [esp+64h] [ebp-54h]
  float v30; // [esp+64h] [ebp-54h]
  float v31; // [esp+68h] [ebp-50h]
  float v32; // [esp+68h] [ebp-50h]
  float v33; // [esp+68h] [ebp-50h]
  float v34; // [esp+78h] [ebp-40h]
  float v35; // [esp+78h] [ebp-40h]
  float v36; // [esp+78h] [ebp-40h]
  float v37; // [esp+7Ch] [ebp-3Ch]
  float v38; // [esp+7Ch] [ebp-3Ch]
  float v39; // [esp+7Ch] [ebp-3Ch]
  float v40; // [esp+80h] [ebp-38h]
  float v41; // [esp+80h] [ebp-38h]
  float v42; // [esp+84h] [ebp-34h]
  float v43; // [esp+84h] [ebp-34h]
  float v44; // [esp+88h] [ebp-30h]
  float v45; // [esp+88h] [ebp-30h]
  float v46; // [esp+94h] [ebp-24h]
  float v47; // [esp+94h] [ebp-24h]
  float v48; // [esp+94h] [ebp-24h]
  float v49; // [esp+94h] [ebp-24h]
  float v50; // [esp+94h] [ebp-24h]
  float v51; // [esp+98h] [ebp-20h]
  float v52; // [esp+9Ch] [ebp-1Ch]
  float v53; // [esp+A0h] [ebp-18h]
  float v54; // [esp+A4h] [ebp-14h]
  int j; // [esp+A8h] [ebp-10h]
  int i; // [esp+ACh] [ebp-Ch]

  v9 = *(a1 + 252) - *(a1 + 248);
  if ( *(a2 + 2) )
  {
    v11 = v9 * -2.0;
    *(a1 + 8) = *(a1 + 8) + v9;
    v2 = *(a1 + 20) + v9;
  }
  else
  {
    v11 = v9 + v9;
    *(a1 + 8) = *(a1 + 8) - v9;
    v2 = *(a1 + 20) - v9;
  }
  *(a1 + 20) = v2;
  v53 = *(a1 + 248) + 0.125;
  LODWORD(v54) = LODWORD(v53) ^ 0x80000000;
  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v51 = *(a1 + 12) * *&a2[36 * i + 2]
        + *(a1 + 16) * *&a2[36 * i + 4]
        + *(a1 + 20) * *&a2[36 * i + 6]
        - *&a2[36 * i + 8];
    if ( v51 < v53 )
    {
      v52 = *a1 * *&a2[36 * i + 2] + *(a1 + 4) * *&a2[36 * i + 4] + *(a1 + 8) * *&a2[36 * i + 6] - *&a2[36 * i + 8];
      v10 = v52 - v51;
      if ( v10 > 0.0 )
      {
        if ( v54 < v52 )
        {
          if ( v53 <= v52 )
          {
            v48 = (v52 - v53) / v10;
            if ( v48 > *(a1 + 196) )
              continue;
            v40 = *(a1 + 24) * v48 + *a1;
            v42 = *(a1 + 28) * v48 + *(a1 + 4);
            v44 = *(a1 + 32) * v48 + *(a1 + 8);
          }
          else
          {
            v48 = 0.0;
            v40 = *a1;
            v42 = *(a1 + 4);
            v44 = *(a1 + 8);
          }
          v39 = v40 * *&a2[36 * i + 10] + v42 * *&a2[36 * i + 12] + v44 * *&a2[36 * i + 14] - *&a2[36 * i + 16];
          v36 = v40 * *&a2[36 * i + 18] + v42 * *&a2[36 * i + 20] + v44 * *&a2[36 * i + 22] - *&a2[36 * i + 24];
          v5 = v39 + v36 > 1.0;
          if ( v39 < 0.0 )
            v5 |= 2u;
          v4 = v5;
          if ( v36 < 0.0 )
            v4 = v5 | 4;
          if ( v4 )
          {
            for ( j = 0; j <= 2; ++j )
            {
              if ( ((v4 >> j) & 1) != 0 )
              {
                v13 = *&a2[36 * i + 32 + 2 * j];
                if ( v13 && *v13 != dword_8459940 )
                {
                  *v13 = dword_8459940;
                  v25 = *a1 - *(v13 + 4);
                  v28 = *(a1 + 4) - *(v13 + 8);
                  v31 = *(a1 + 8) - *(v13 + 12);
                  v22 = v25 * *(v13 + 16) + v28 * *(v13 + 20) + v31 * *(v13 + 24);
                  v23 = v25 * *(v13 + 28) + v28 * *(v13 + 32) + v31 * *(v13 + 36);
                  v24 = v25 * *(v13 + 40) + v28 * *(v13 + 44) + v31 * *(v13 + 48);
                  v14 = v22 * v22 + v23 * v23 - v53 * v53;
                  if ( v14 > 0.0 )
                  {
                    v26 = *(a1 + 24) * *(v13 + 16) + *(a1 + 28) * *(v13 + 20) + *(a1 + 32) * *(v13 + 24);
                    v29 = *(a1 + 24) * *(v13 + 28) + *(a1 + 28) * *(v13 + 32) + *(a1 + 32) * *(v13 + 36);
                    v16 = v26 * v22 + v29 * v23;
                    if ( v16 < 0.0 )
                    {
                      v18 = v26 * v26 + v29 * v29;
                      v20 = v16 * v16 - v18 * v14;
                      if ( v20 > 0.0 )
                      {
                        v49 = (-sqrt(v20) - v16) / v18;
                        if ( *(a1 + 196) > v49 )
                        {
                          v32 = *(a1 + 24) * *(v13 + 40) + *(a1 + 28) * *(v13 + 44) + *(a1 + 32) * *(v13 + 48);
                          v45 = v49 * v32 + v24;
                          if ( v45 >= 0.0 && v45 <= *(v13 + 52) )
                          {
                            v41 = (v49 * v26 + v22) / v53;
                            v43 = (v49 * v29 + v23) / v53;
                            *(a1 + 212) = *(v13 + 16) * v41;
                            *(a1 + 216) = *(v13 + 20) * v41;
                            *(a1 + 220) = *(v13 + 24) * v41;
                            *(a1 + 212) = *(v13 + 28) * v43 + *(a1 + 212);
                            *(a1 + 216) = *(v13 + 32) * v43 + *(a1 + 216);
                            *(a1 + 220) = *(v13 + 36) * v43 + *(a1 + 220);
                            if ( *(a1 + 196) <= 0.0000099999997 )
                            {
                              *(a1 + 196) = 0;
                              result = a1;
                              *(a1 + 243) = 1;
                              return result;
                            }
                            *(a1 + 196) = v49 - 0.0000099999997;
                          }
                        }
                      }
                    }
                  }
                  else if ( v24 >= 0.0 && v24 <= *(v13 + 52) )
                  {
                    goto LABEL_52;
                  }
                }
              }
              else
              {
                v6 = *&a2[36 * i + 26 + 2 * j];
                if ( v6 && *v6 != dword_8459940 )
                {
                  *v6 = dword_8459940;
                  v27 = *a1 - *(v6 + 4);
                  v30 = *(a1 + 4) - *(v6 + 8);
                  v33 = *(a1 + 8) - *(v6 + 12);
                  v15 = v27 * v27 + v30 * v30 + v33 * v33 - v53 * v53;
                  if ( v15 <= 0.0 )
                    goto LABEL_52;
                  v17 = *(a1 + 24) * v27 + *(a1 + 28) * v30 + *(a1 + 32) * v33;
                  if ( v17 < 0.0 )
                  {
                    v19 = *(a1 + 36);
                    v21 = v17 * v17 - v19 * v15;
                    if ( v21 >= 0.0 )
                    {
                      v50 = (-sqrt(v21) - v17) / v19;
                      if ( *(a1 + 196) > v50 )
                      {
                        *(a1 + 212) = *(a1 + 24) * v50 + v27;
                        *(a1 + 216) = *(a1 + 28) * v50 + v30;
                        *(a1 + 220) = *(a1 + 32) * v50 + v33;
                        *(a1 + 212) = 1.0 / v53 * *(a1 + 212);
                        *(a1 + 216) = 1.0 / v53 * *(a1 + 216);
                        *(a1 + 220) = 1.0 / v53 * *(a1 + 220);
                        if ( *(a1 + 196) <= 0.0000099999997 )
                        {
                          *(a1 + 196) = 0;
                          result = a1;
                          *(a1 + 243) = 1;
                          return result;
                        }
                        *(a1 + 196) = v50 - 0.0000099999997;
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            *(a1 + 212) = *&a2[36 * i + 2];
            *(a1 + 216) = *&a2[36 * i + 4];
            *(a1 + 220) = *&a2[36 * i + 6];
            if ( v48 <= 0.0000099999997 )
            {
              *(a1 + 196) = 0;
              result = a1;
              *(a1 + 243) = 1;
              return result;
            }
            *(a1 + 196) = v48 - 0.0000099999997;
          }
        }
        else
        {
          v12 = v11 * *&a2[36 * i + 6] + v52;
          if ( v54 < v12 )
          {
            v46 = (v54 - v52) / *&a2[36 * i + 6];
            v8 = *a1 * *&a2[36 * i + 10]
               + *(a1 + 4) * *&a2[36 * i + 12]
               + *(a1 + 8) * *&a2[36 * i + 14]
               - *&a2[36 * i + 16];
            v7 = *a1 * *&a2[36 * i + 18]
               + *(a1 + 4) * *&a2[36 * i + 20]
               + *(a1 + 8) * *&a2[36 * i + 22]
               - *&a2[36 * i + 24];
            v37 = v46 * *&a2[36 * i + 14] + v8;
            if ( v37 >= 0.0 )
            {
              v34 = v46 * *&a2[36 * i + 22] + v7;
              if ( v34 >= 0.0 && v37 + v34 <= 1.0 )
                goto LABEL_52;
            }
            v47 = v53 <= v12 ? ((v53 - v52) / *&a2[36 * i + 6]) : v11;
            v38 = v47 * *&a2[36 * i + 14] + v8;
            if ( v38 >= 0.0 )
            {
              v35 = v47 * *&a2[36 * i + 22] + v7;
              if ( v35 >= 0.0 && v38 + v35 <= 1.0 )
              {
LABEL_52:
                *(a1 + 212) = *&a2[36 * i + 2];
                *(a1 + 216) = *&a2[36 * i + 4];
                *(a1 + 220) = *&a2[36 * i + 6];
                *(a1 + 196) = 0;
                result = a1;
                *(a1 + 243) = 1;
                return result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 8459940: using guessed type int dword_8459940;

//----- (08056773) --------------------------------------------------------
int __cdecl sub_8056773(float *a1, unsigned __int16 *a2)
{
  long double v2; // fst7
  int v4; // [esp+18h] [ebp-80h]
  int v5; // [esp+1Ch] [ebp-7Ch]
  float v7; // [esp+28h] [ebp-70h]
  float v8; // [esp+2Ch] [ebp-6Ch]
  float v9; // [esp+30h] [ebp-68h]
  float v10; // [esp+34h] [ebp-64h]
  float v11; // [esp+38h] [ebp-60h]
  float v12; // [esp+3Ch] [ebp-5Ch]
  float v13; // [esp+3Ch] [ebp-5Ch]
  float v14; // [esp+40h] [ebp-58h]
  float v15; // [esp+44h] [ebp-54h]
  float *v16; // [esp+48h] [ebp-50h]
  float v17; // [esp+4Ch] [ebp-4Ch]
  float v18; // [esp+50h] [ebp-48h]
  float v19; // [esp+50h] [ebp-48h]
  float v20; // [esp+50h] [ebp-48h]
  float v21; // [esp+54h] [ebp-44h]
  float v22; // [esp+54h] [ebp-44h]
  float v23; // [esp+54h] [ebp-44h]
  float v24; // [esp+58h] [ebp-40h]
  float v25; // [esp+58h] [ebp-40h]
  float v26; // [esp+58h] [ebp-40h]
  float v27; // [esp+68h] [ebp-30h]
  float v28; // [esp+68h] [ebp-30h]
  float v29; // [esp+68h] [ebp-30h]
  float v30; // [esp+6Ch] [ebp-2Ch]
  float v31; // [esp+6Ch] [ebp-2Ch]
  float v32; // [esp+6Ch] [ebp-2Ch]
  float v33; // [esp+70h] [ebp-28h]
  float v34; // [esp+74h] [ebp-24h]
  float v35; // [esp+78h] [ebp-20h]
  float v36; // [esp+84h] [ebp-14h]
  int j; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  v9 = a1[63] - a1[62];
  if ( *(a2 + 2) )
  {
    v10 = v9 * -2.0;
    a1[2] = a1[2] + v9;
    v2 = a1[5] + v9;
  }
  else
  {
    v10 = v9 + v9;
    a1[2] = a1[2] - v9;
    v2 = a1[5] - v9;
  }
  a1[5] = v2;
  v14 = a1[62];
  LODWORD(v15) = LODWORD(v14) ^ 0x80000000;
  for ( i = 0; i < *a2; ++i )
  {
    v36 = *a1 * *&a2[36 * i + 2] + a1[1] * *&a2[36 * i + 4] + a1[2] * *&a2[36 * i + 6] - *&a2[36 * i + 8];
    if ( v36 < v14 )
    {
      if ( v15 < v36 )
      {
        v33 = -v36 * *&a2[36 * i + 2] + *a1;
        v34 = -v36 * *&a2[36 * i + 4] + a1[1];
        v35 = -v36 * *&a2[36 * i + 6] + a1[2];
        v32 = v33 * *&a2[36 * i + 10] + v34 * *&a2[36 * i + 12] + v35 * *&a2[36 * i + 14] - *&a2[36 * i + 16];
        v29 = v33 * *&a2[36 * i + 18] + v34 * *&a2[36 * i + 20] + v35 * *&a2[36 * i + 22] - *&a2[36 * i + 24];
        v5 = v32 + v29 > 1.0;
        if ( v32 < 0.0 )
          v5 = (v32 + v29 > 1.0) | 2;
        v4 = v5;
        if ( v29 < 0.0 )
          v4 = v5 | 4;
        if ( !v4 )
          return 1;
        for ( j = 0; j <= 2; ++j )
        {
          if ( ((v4 >> j) & 1) != 0 )
          {
            v16 = *&a2[36 * i + 32 + 2 * j];
            if ( v16 )
            {
              v18 = *a1 - v16[1];
              v21 = a1[1] - v16[2];
              v24 = a1[2] - v16[3];
              v17 = v18 * v16[10] + v21 * v16[11] + v24 * v16[12];
              if ( v17 >= 0.0 && v16[13] >= v17 )
              {
                v19 = -v17 * v16[10] + v18;
                v22 = -v17 * v16[11] + v21;
                v25 = -v17 * v16[12] + v24;
                if ( a1[62] * a1[62] > v19 * v19 + v22 * v22 + v25 * v25 )
                  return 1;
              }
            }
          }
          else if ( *&a2[36 * i + 26 + 2 * j] )
          {
            v20 = *a1 - *(*&a2[36 * i + 26 + 2 * j] + 4);
            v23 = a1[1] - *(*&a2[36 * i + 26 + 2 * j] + 8);
            v26 = a1[2] - *(*&a2[36 * i + 26 + 2 * j] + 12);
            if ( a1[62] * a1[62] > v20 * v20 + v23 * v23 + v26 * v26 )
              return 1;
          }
        }
      }
      else
      {
        v11 = v10 * *&a2[36 * i + 6] + v36;
        if ( v15 < v11 )
        {
          v12 = (v15 - v36) / *&a2[36 * i + 6];
          v8 = *a1 * *&a2[36 * i + 10] + a1[1] * *&a2[36 * i + 12] + a1[2] * *&a2[36 * i + 14] - *&a2[36 * i + 16];
          v7 = *a1 * *&a2[36 * i + 18] + a1[1] * *&a2[36 * i + 20] + a1[2] * *&a2[36 * i + 22] - *&a2[36 * i + 24];
          v30 = v12 * *&a2[36 * i + 14] + v8;
          if ( v30 >= 0.0 )
          {
            v27 = v12 * *&a2[36 * i + 22] + v7;
            if ( v27 >= 0.0 && v30 + v27 <= 1.0 )
              return 1;
          }
          v13 = v14 <= v11 ? ((v14 - v36) / *&a2[36 * i + 6]) : v10;
          v31 = v13 * *&a2[36 * i + 14] + v8;
          if ( v31 >= 0.0 )
          {
            v28 = v13 * *&a2[36 * i + 22] + v7;
            if ( v28 >= 0.0 && v31 + v28 <= 1.0 )
              return 1;
          }
        }
      }
    }
  }
  return 0;
}

//----- (08056F57) --------------------------------------------------------
int __cdecl sub_8056F57(_DWORD *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !dword_80EF50C )
  {
    dword_80EF50C = 1;
    Com_DPrintf("^1Box collision on terrain currently being faked with capsule collision\n");
  }
  a1[61] = 1;
  v5 = a1[2];
  v4 = a1[5];
  v3 = a1[62];
  a1[62] = a1[13];
  sub_80558DD(a1, a2);
  a1[61] = 0;
  a1[2] = v5;
  a1[5] = v4;
  result = v3;
  a1[62] = v3;
  return result;
}
// 80EF50C: using guessed type int dword_80EF50C;

//----- (08056FF5) --------------------------------------------------------
int __cdecl sub_8056FF5(_DWORD *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( a1[48] )
    return sub_8055595(a1, a2);
  if ( !a1[61] )
    return sub_8056F57(a1, a2);
  v4 = a1[2];
  v3 = a1[5];
  sub_80558DD(a1, a2);
  a1[2] = v4;
  result = v3;
  a1[5] = v3;
  return result;
}

//----- (08057073) --------------------------------------------------------
_BOOL4 __cdecl sub_8057073(int *a1, unsigned __int16 *a2)
{
  unsigned int v3; // [esp+14h] [ebp-134h]
  int *v4; // [esp+18h] [ebp-130h]
  int *v5; // [esp+1Ch] [ebp-12Ch]
  int v6; // [esp+20h] [ebp-128h] BYREF
  int v7; // [esp+24h] [ebp-124h] BYREF
  float v8; // [esp+E4h] [ebp-64h]

  v5 = &v6;
  v4 = a1;
  v3 = 280;
  if ( (&v6 & 4) != 0 )
  {
    v6 = *a1;
    v5 = &v7;
    v4 = a1 + 1;
    v3 = 276;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  v8 = 1.0;
  sub_8056FF5(&v6, a2);
  return 1.0 == v8;
}

//----- (08057122) --------------------------------------------------------
int __cdecl sub_8057122(int a1, unsigned __int16 *a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( *(a1 + 192) )
    return 0;
  v5 = *(a1 + 8);
  v4 = *(a1 + 20);
  v6 = sub_8056773(a1, a2);
  *(a1 + 8) = v5;
  *(a1 + 20) = v4;
  return v6;
}

//----- (08057184) --------------------------------------------------------
int __cdecl sub_8057184(float *a1, int a2)
{
  long double v2; // fst7
  int v4; // [esp+0h] [ebp-Ch]
  __int16 *v5; // [esp+4h] [ebp-8h]
  float v6; // [esp+8h] [ebp-4h]

  while ( a2 >= 0 )
  {
    v5 = (dword_84598E4 + 8 * a2);
    v4 = *v5;
    if ( *(*v5 + 16) > 2u )
      v2 = *v4 * *a1 + *(v4 + 4) * a1[1] + *(v4 + 8) * a1[2] - *(v4 + 12);
    else
      v2 = a1[*(v4 + 16)] - *(v4 + 12);
    v6 = v2;
    if ( v6 >= 0.0 )
      a2 = v5[2];
    else
      a2 = v5[3];
  }
  return -1 - a2;
}
// 84598E4: using guessed type int dword_84598E4;

//----- (0805723E) --------------------------------------------------------
int __cdecl sub_805723E(float *a1)
{
  return sub_8057184(a1, 0);
}

//----- (08057259) --------------------------------------------------------
_DWORD *__cdecl sub_8057259(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = -1 - a2;
  if ( *(dword_84598EC + 16 * (-1 - a2)) != 0xFFFF )
    a1[10] = v3;
  if ( *a1 < a1[1] )
  {
    result = (-1 - a2);
    *(a1[3] + 4 * (*a1)++) = v3;
  }
  else
  {
    result = a1;
    a1[2] = 1;
  }
  return result;
}
// 84598EC: using guessed type int dword_84598EC;

//----- (080572C1) --------------------------------------------------------
int __cdecl sub_80572C1(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-1Ch]
  int v4; // [esp+4h] [ebp-18h]
  int i; // [esp+10h] [ebp-Ch]
  int j; // [esp+14h] [ebp-8h]

  v4 = dword_84598EC + 16 * (-1 - a2);
  for ( i = 0; ; ++i )
  {
    result = *(v4 + 8);
    if ( i >= result )
      break;
    v3 = dword_845990C + 52 * *(dword_84598F4 + 4 * (*(v4 + 4) + i));
    if ( *(v3 + 36) != dword_8459940 )
    {
      *(v3 + 36) = dword_8459940;
      for ( j = 0; j <= 2 && *(v3 + 4 * j + 4) < *&a1[j + 7] && *&a1[j + 4] < *(v3 + 4 * j + 16); ++j )
        ;
      if ( j == 3 )
      {
        if ( *a1 >= a1[1] )
        {
          result = a1;
          a1[2] = 1;
          return result;
        }
        *(a1[3] + 4 * (*a1)++) = v3;
      }
    }
  }
  return result;
}
// 84598EC: using guessed type int dword_84598EC;
// 84598F4: using guessed type int dword_84598F4;
// 845990C: using guessed type int dword_845990C;
// 8459940: using guessed type int dword_8459940;

//----- (080573E6) --------------------------------------------------------
int __cdecl sub_80573E6(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  while ( a2 >= 0 )
  {
    v4 = dword_84598E4 + 8 * a2;
    v3 = sub_80CB294((a1 + 16), (a1 + 28), *v4);
    if ( v3 == 1 )
    {
      a2 = *(v4 + 4);
    }
    else
    {
      if ( v3 != 2 )
        sub_80573E6(a1, *(v4 + 4));
      a2 = *(v4 + 6);
    }
  }
  return (*(a1 + 44))(a1, a2);
}
// 84598E4: using guessed type int dword_84598E4;

//----- (08057491) --------------------------------------------------------
int __cdecl sub_8057491(int *a1, int *a2, int a3, int a4, _DWORD *a5)
{
  int v6[10]; // [esp+10h] [ebp-38h] BYREF
  int v7; // [esp+38h] [ebp-10h]
  _DWORD *(__cdecl *v8)(_DWORD *, int); // [esp+3Ch] [ebp-Ch]

  ++dword_8459940;
  v6[4] = *a1;
  v6[5] = a1[1];
  v6[6] = a1[2];
  v6[7] = *a2;
  v6[8] = a2[1];
  v6[9] = a2[2];
  v6[0] = 0;
  v6[1] = a4;
  v6[3] = a3;
  v8 = sub_8057259;
  v7 = 0;
  v6[2] = 0;
  sub_80573E6(v6, 0);
  *a5 = v7;
  return v6[0];
}
// 8459940: using guessed type int dword_8459940;

//----- (080575A9) --------------------------------------------------------
int __cdecl sub_80575A9(float *a1, int a2)
{
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+18h] [ebp-20h]
  _DWORD *v5; // [esp+1Ch] [ebp-1Ch]
  int *v6; // [esp+20h] [ebp-18h]
  int i; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int k; // [esp+2Ch] [ebp-Ch]

  if ( a2 )
    v6 = sub_804BC58(a2) + 6;
  else
    v6 = (dword_84598EC + 16 * sub_8057184(a1, 0));
  v4 = 0;
  for ( i = 0; i < *(v6 + 4); ++i )
  {
    v5 = (dword_845990C + 52 * *(dword_84598F4 + 4 * (v6[1] + i)));
    for ( j = 0; j <= 2; ++j )
    {
      if ( *&v5[j + 1] > a1[j] || a1[j] > *&v5[j + 4] )
        goto LABEL_16;
    }
    v3 = v5[8];
    for ( k = v5[7]; k; --k )
    {
      if ( *a1 * **v3 + a1[1] * *(*v3 + 4) + a1[2] * *(*v3 + 8) > *(*v3 + 12) )
        goto LABEL_16;
      v3 += 8;
    }
    v4 |= *v5;
LABEL_16:
    ;
  }
  return v4;
}
// 84598EC: using guessed type int dword_84598EC;
// 84598F4: using guessed type int dword_84598F4;
// 845990C: using guessed type int dword_845990C;

//----- (0805772B) --------------------------------------------------------
int __cdecl sub_805772B(float *a1, int a2, float *a3, float *a4)
{
  float v5; // [esp+1Ch] [ebp-5Ch]
  float v6[4]; // [esp+20h] [ebp-58h] BYREF
  float v7[4]; // [esp+30h] [ebp-48h] BYREF
  float v8[4]; // [esp+40h] [ebp-38h] BYREF
  float v9; // [esp+50h] [ebp-28h]
  float v10; // [esp+54h] [ebp-24h]
  float v11; // [esp+58h] [ebp-20h]
  float v12; // [esp+60h] [ebp-18h] BYREF
  unsigned int v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]

  v12 = *a1 - *a3;
  *&v13 = a1[1] - a3[1];
  v14 = a1[2] - a3[2];
  if ( a2 != 511 && (*a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0) )
  {
    sub_80674AD(a4, v8, v7, v6);
    v9 = v12;
    v10 = *&v13;
    v11 = v14;
    v12 = v12 * v8[0] + *&v13 * v8[1] + v14 * v8[2];
    v5 = v9 * v7[0] + *&v13 * v7[1] + v14 * v7[2];
    v13 = LODWORD(v5) ^ 0x80000000;
    v14 = v9 * v6[0] + v10 * v6[1] + v14 * v6[2];
  }
  return sub_80575A9(&v12, a2);
}

//----- (0805784E) --------------------------------------------------------
char *__cdecl sub_805784E(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0 && a1 < dword_8459910 && dword_845991C )
    v2 = dword_8459918 + dword_8459914 * a1;
  else
    v2 = dword_8459918;
  return v2;
}
// 8459910: using guessed type int dword_8459910;
// 845991C: using guessed type int dword_845991C;

//----- (08057890) --------------------------------------------------------
int __cdecl sub_8057890(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (dword_845992C + 8 * a1);
  if ( v4[1] == dword_845993C )
  {
    result = *v4;
    if ( *v4 != a2 )
      sub_80704AC(1, &byte_80DC9A0);
  }
  else
  {
    *v4 = a2;
    v4[1] = dword_845993C;
    v3 = dword_8459930 + 4 * dword_8459928 * a1;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_8459928 )
        break;
      if ( *(v3 + 4 * i) > 0 )
        sub_8057890(i, a2);
    }
  }
  return result;
}
// 8459928: using guessed type int dword_8459928;
// 845992C: using guessed type int dword_845992C;
// 8459930: using guessed type int dword_8459930;
// 845993C: using guessed type int dword_845993C;

//----- (0805793E) --------------------------------------------------------
int sub_805793E()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  ++dword_845993C;
  v1 = 0;
  v2 = dword_845992C;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8459928 )
      break;
    if ( *(v2 + 4) != dword_845993C )
      sub_8057890(i, ++v1);
    v2 += 8;
  }
  return result;
}
// 8459928: using guessed type int dword_8459928;
// 845992C: using guessed type int dword_845992C;
// 845993C: using guessed type int dword_845993C;

//----- (080579A3) --------------------------------------------------------
int __cdecl sub_80579A3(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 >= 0 && a2 >= 0 )
  {
    if ( a1 >= dword_8459928 || a2 >= dword_8459928 )
      sub_80704AC(1, &byte_80DC9C0);
    if ( a3 )
    {
      ++*(dword_8459930 + 4 * (a2 + dword_8459928 * a1));
      ++*(dword_8459930 + 4 * (a1 + dword_8459928 * a2));
    }
    else if ( *(dword_8459930 + 4 * (a1 + dword_8459928 * a2)) )
    {
      --*(dword_8459930 + 4 * (a2 + dword_8459928 * a1));
      if ( --*(dword_8459930 + 4 * (a1 + dword_8459928 * a2)) < 0 )
        sub_80704AC(1, &byte_80DCA00);
    }
    result = sub_805793E();
  }
  return result;
}
// 8459928: using guessed type int dword_8459928;
// 8459930: using guessed type int dword_8459930;

//----- (08057ABD) --------------------------------------------------------
_BOOL4 __cdecl sub_8057ABD(int a1, int a2)
{
  _BOOL4 v3; // [esp+0h] [ebp-Ch]

  if ( a1 >= 0 && a2 >= 0 )
    v3 = *(dword_845992C + 8 * a1) == *(dword_845992C + 8 * a2);
  else
    v3 = 0;
  return v3;
}
// 845992C: using guessed type int dword_845992C;

//----- (08057B18) --------------------------------------------------------
float *__cdecl sub_8057B18(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  *a1 = *a2 * *a1 + a2[1] * v4 + a2[2] * v5;
  a1[1] = a2[3] * v3 + a2[4] * v4 + a2[5] * v5;
  result = a2 + 8;
  a1[2] = a2[6] * v3 + a2[7] * v4 + a2[8] * v5;
  return result;
}

//----- (08057BBF) --------------------------------------------------------
int *__cdecl sub_8057BBF(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(a2 + 4 * (j + 3 * i)) = *(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (08057C2A) --------------------------------------------------------
unsigned int __cdecl sub_8057C2A(float *a1, int a2)
{
  sub_80674AD(a1, a2, (a2 + 12), (a2 + 24));
  return sub_8066A5E((a2 + 12));
}

//----- (08057C66) --------------------------------------------------------
float *__cdecl sub_8057C66(float *a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+4h] [ebp-14h]
  float v7; // [esp+8h] [ebp-10h]

  v5 = *a1 - *a2;
  v6 = a1[1] - a2[1];
  v7 = a1[2] - a2[2];
  *a4 = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * *a3 + *a2;
  a4[1] = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * a3[1] + a2[1];
  result = a3 + 2;
  a4[2] = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * a3[2] + a2[2];
  return result;
}

//----- (08057FE3) --------------------------------------------------------
void __cdecl sub_8057FE3(int a1, int a2)
{
  float v2; // [esp+0h] [ebp-38h]
  float v3; // [esp+4h] [ebp-34h]
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+18h] [ebp-20h]
  float **v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+24h] [ebp-14h]
  float *v11; // [esp+28h] [ebp-10h]
  float *v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( *(a1 + 164) <= *(a2 + 16)
    && *(a1 + 168) <= *(a2 + 20)
    && *(a1 + 172) <= *(a2 + 24)
    && *(a2 + 4) <= *(a1 + 176)
    && *(a2 + 8) <= *(a1 + 180)
    && *(a2 + 12) <= *(a1 + 184) )
  {
    v6 = *(a2 + 32);
    v13 = *(a2 + 28);
    if ( *(a1 + 244) )
    {
      while ( v13 )
      {
        v11 = *v6;
        v5 = *v11 * *(a1 + 256) + v11[1] * *(a1 + 260) + v11[2] * *(a1 + 264);
        if ( v5 <= 0.0 )
        {
          v2 = *a1 + *(a1 + 256);
          v3 = *(a1 + 4) + *(a1 + 260);
          v4 = *(a1 + 8) + *(a1 + 264);
        }
        else
        {
          v2 = *a1 - *(a1 + 256);
          v3 = *(a1 + 4) - *(a1 + 260);
          v4 = *(a1 + 8) - *(a1 + 264);
        }
        v9 = (*v6)[3] + *(a1 + 248);
        v7 = v2 * *v11 + v3 * v11[1] + v4 * v11[2] - v9;
        if ( v7 > 0.0 )
          return;
        --v13;
        v6 += 2;
      }
    }
    else
    {
      while ( v13 )
      {
        v12 = *v6;
        v10 = v12[3]
            - (*(a1 + 12 * *(v12 + 17) + 64) * *v12
             + *(a1 + 12 * *(v12 + 17) + 68) * v12[1]
             + *(a1 + 12 * *(*v6 + 17) + 72) * v12[2]);
        v8 = *a1 * *v12 + *(a1 + 4) * v12[1] + *(a1 + 8) * v12[2] - v10;
        if ( v8 > 0.0 )
          return;
        --v13;
        v6 += 2;
      }
    }
    *(a1 + 242) = 1;
    *(a1 + 243) = 1;
    *(a1 + 196) = 0;
    *(a1 + 228) = *a2;
  }
}

//----- (080582C8) --------------------------------------------------------
int __cdecl sub_80582C8(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(a2 + 8); ++i )
  {
    v4 = (dword_845990C + 52 * *(dword_84598F4 + 4 * (*(a2 + 4) + i)));
    if ( v4[9] != dword_8459940 )
    {
      v4[9] = dword_8459940;
      if ( (*v4 & *(a1 + 188)) != 0 )
      {
        sub_8057FE3(a1, v4);
        result = a1;
        if ( *(a1 + 242) )
          return result;
      }
    }
  }
  result = dword_8459860;
  if ( !*(dword_8459860 + 32) )
  {
    for ( j = 0; ; ++j )
    {
      result = *(a2 + 12);
      if ( j >= result )
        break;
      v3 = dword_8459938 + 44 * *(dword_84598FC + 4 * (j + *(a2 + 10)));
      if ( *v3 != dword_8459940 )
      {
        *v3 = dword_8459940;
        if ( (*(v3 + 8) & *(a1 + 188)) != 0 )
        {
          if ( *(v3 + 36) )
          {
            if ( sub_8050FC6(a1, *(v3 + 36)) )
            {
              *(a1 + 242) = 1;
              *(a1 + 243) = 1;
              result = a1;
              *(a1 + 196) = 0;
              return result;
            }
          }
          else if ( sub_8057122(a1, *(v3 + 40)) )
          {
            *(a1 + 242) = 1;
            *(a1 + 243) = 1;
            result = a1;
            *(a1 + 196) = 0;
            return result;
          }
        }
      }
    }
  }
  return result;
}
// 8459860: using guessed type int dword_8459860;
// 84598F4: using guessed type int dword_84598F4;
// 84598FC: using guessed type int dword_84598FC;
// 845990C: using guessed type int dword_845990C;
// 8459938: using guessed type int dword_8459938;
// 8459940: using guessed type int dword_8459940;

//----- (0805848F) --------------------------------------------------------
void __cdecl sub_805848F(int a1)
{
  float v1; // [esp+10h] [ebp-B8h]
  float v2; // [esp+14h] [ebp-B4h]
  float v3; // [esp+18h] [ebp-B0h]
  float v4; // [esp+1Ch] [ebp-ACh]
  float v5; // [esp+20h] [ebp-A8h]
  float v6[3]; // [esp+30h] [ebp-98h]
  float v7[2]; // [esp+3Ch] [ebp-8Ch]
  float v8; // [esp+44h] [ebp-84h]
  float v9; // [esp+50h] [ebp-78h]
  float v10; // [esp+54h] [ebp-74h]
  float v11; // [esp+58h] [ebp-70h]
  float v12; // [esp+60h] [ebp-68h]
  float v13; // [esp+64h] [ebp-64h]
  float v14; // [esp+68h] [ebp-60h]
  float v15; // [esp+70h] [ebp-58h]
  float v16; // [esp+74h] [ebp-54h]
  float v17; // [esp+78h] [ebp-50h]
  float v18; // [esp+80h] [ebp-48h]
  float v19; // [esp+84h] [ebp-44h]
  float v20; // [esp+88h] [ebp-40h]
  float v21; // [esp+90h] [ebp-38h]
  float v22; // [esp+94h] [ebp-34h]
  float v23; // [esp+98h] [ebp-30h]
  float v24; // [esp+A0h] [ebp-28h]
  float v25; // [esp+A4h] [ebp-24h]
  float v26; // [esp+A8h] [ebp-20h]
  int i; // [esp+BCh] [ebp-Ch]

  v24 = *a1 + *(a1 + 256);
  v25 = *(a1 + 4) + *(a1 + 260);
  v26 = *(a1 + 8) + *(a1 + 264);
  v21 = *a1 - *(a1 + 256);
  v22 = *(a1 + 4) - *(a1 + 260);
  v23 = *(a1 + 8) - *(a1 + 264);
  for ( i = 0; i <= 2; ++i )
  {
    *(&v9 + i) = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
    v6[i] = *&dword_8459960[i] - *(&v9 + i);
    v7[i] = *&dword_845996C[i] - *(&v9 + i);
  }
  if ( v7[0] <= v8 )
    v1 = v7[0];
  else
    v1 = v8;
  v5 = v8 - v1;
  v4 = (*(a1 + 248) + v1) * (*(a1 + 248) + v1);
  v18 = v9;
  v19 = v10;
  v20 = v11 + v5;
  v12 = v9 - v24;
  v13 = v10 - v25;
  v14 = v20 - v26;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(a1 + 242) = 1;
    *(a1 + 243) = 1;
    *(a1 + 196) = 0;
  }
  v12 = v18 - v21;
  v13 = v19 - v22;
  v14 = v20 - v23;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(a1 + 242) = 1;
    *(a1 + 243) = 1;
    *(a1 + 196) = 0;
  }
  v15 = v9;
  v16 = v10;
  v17 = v11 - v5;
  v12 = v9 - v24;
  v13 = v10 - v25;
  v14 = v17 - v26;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(a1 + 242) = 1;
    *(a1 + 243) = 1;
    *(a1 + 196) = 0;
  }
  v12 = v15 - v21;
  v13 = v16 - v22;
  v14 = v17 - v23;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(a1 + 242) = 1;
    *(a1 + 243) = 1;
    *(a1 + 196) = 0;
  }
  v3 = *(a1 + 8) - v11;
  v2 = v5 + *(a1 + 252) - *(a1 + 248);
  if ( v2 >= v3 && v3 >= -v2 )
  {
    v20 = 0.0;
    v26 = 0.0;
    v12 = v24 - v18;
    v13 = v25 - v19;
    v14 = 0.0 - 0.0;
    if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
    {
      *(a1 + 242) = 1;
      *(a1 + 243) = 1;
      *(a1 + 196) = 0;
    }
  }
}
// 8459960: using guessed type int dword_8459960[];
// 845996C: using guessed type int dword_845996C[];

//----- (08058894) --------------------------------------------------------
void __cdecl sub_8058894(int a1)
{
  float v1; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v3[3]; // [esp+20h] [ebp-38h]
  float v4[2]; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+34h] [ebp-24h]
  float v6[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v6[i] = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
    v3[i] = *&dword_8459960[i] - v6[i];
    v4[i] = *&dword_845996C[i] - v6[i];
    *(a1 + 4 * i) = *(a1 + 4 * i) - v6[i];
    *(a1 + 4 * i + 12) = *(a1 + 4 * i + 12) - v6[i];
  }
  *(a1 + 244) = 1;
  if ( v4[0] <= v5 )
    v1 = v4[0];
  else
    v1 = v5;
  *(a1 + 248) = v1;
  *(a1 + 252) = v5;
  *(a1 + 256) = 0;
  *(a1 + 260) = 0;
  *(a1 + 264) = v5 - *(a1 + 248);
  sub_804BE53((a1 + 40), (a1 + 52), *dword_845995C, 0);
  sub_8057FE3(a1, dword_845995C);
}
// 845995C: using guessed type int dword_845995C;
// 8459960: using guessed type int dword_8459960[];
// 845996C: using guessed type int dword_845996C[];

//----- (080589FE) --------------------------------------------------------
int __cdecl sub_80589FE(int a1)
{
  int result; // eax
  int v2[4]; // [esp+10h] [ebp-1048h] BYREF
  float v3[3]; // [esp+20h] [ebp-1038h]
  float v4[8]; // [esp+2Ch] [ebp-102Ch]
  int i; // [esp+4Ch] [ebp-100Ch]
  int v6[1026]; // [esp+50h] [ebp-1008h] BYREF

  v3[0] = *a1 + *(a1 + 40);
  v3[1] = *(a1 + 4) + *(a1 + 44);
  v3[2] = *(a1 + 8) + *(a1 + 48);
  v4[0] = *a1 + *(a1 + 52);
  v4[1] = *(a1 + 4) + *(a1 + 56);
  v4[2] = *(a1 + 8) + *(a1 + 60);
  for ( i = 0; i <= 2; ++i )
  {
    v3[i] = v3[i] - 1.0;
    v4[i] = v4[i] + 1.0;
  }
  v2[0] = 0;
  v2[1] = 1024;
  v2[3] = v6;
  LODWORD(v4[4]) = sub_8057259;
  v4[3] = 0.0;
  v2[2] = 0;
  ++dword_8459940;
  sub_80573E6(v2, 0);
  ++dword_8459940;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2[0] )
      break;
    sub_80582C8(a1, dword_84598EC + 16 * v6[i]);
    result = a1;
    if ( *(a1 + 242) )
      break;
  }
  return result;
}
// 84598EC: using guessed type int dword_84598EC;
// 8459940: using guessed type int dword_8459940;

//----- (08058B85) --------------------------------------------------------
_BOOL4 __cdecl sub_8058B85(int a1, float *a2, float *a3)
{
  float v5; // [esp+Ch] [ebp-6Ch]
  float v6; // [esp+Ch] [ebp-6Ch]
  float v7; // [esp+Ch] [ebp-6Ch]
  float v8; // [esp+10h] [ebp-68h]
  float v9; // [esp+14h] [ebp-64h]
  float v10; // [esp+18h] [ebp-60h]
  float v11; // [esp+20h] [ebp-58h]
  float v12; // [esp+24h] [ebp-54h]
  float v13; // [esp+28h] [ebp-50h]
  float v14; // [esp+30h] [ebp-48h]
  float v15; // [esp+34h] [ebp-44h]
  float v16; // [esp+38h] [ebp-40h]
  float v17; // [esp+40h] [ebp-38h]
  float v18; // [esp+44h] [ebp-34h]
  float v19; // [esp+48h] [ebp-30h]
  float v20; // [esp+50h] [ebp-28h]
  float v21; // [esp+54h] [ebp-24h]
  float v22; // [esp+58h] [ebp-20h]
  float v23; // [esp+60h] [ebp-18h]
  float v24; // [esp+64h] [ebp-14h]
  float v25; // [esp+68h] [ebp-10h]

  if ( *(a1 + 164) > *a3 || *a2 > *(a1 + 176) )
    return 0;
  if ( *(a1 + 168) > a3[1] || a2[1] > *(a1 + 180) )
    return 0;
  if ( *(a1 + 172) > a3[2] || a2[2] > *(a1 + 184) )
    return 0;
  if ( !*(a1 + 192) )
    return 1;
  v11 = *a3 - *a2;
  v12 = a3[1] - a2[1];
  v13 = a3[2] - a2[2];
  v20 = *a3 + *a2;
  v21 = a3[1] + a2[1];
  v22 = a3[2] + a2[2];
  v23 = *(a1 + 12) + *a1;
  v24 = *(a1 + 16) + *(a1 + 4);
  v25 = *(a1 + 20) + *(a1 + 8);
  v17 = v23 - v20;
  v18 = v24 - v21;
  v19 = v25 - v22;
  v8 = *(a1 + 176) - *(a1 + 164);
  v9 = *(a1 + 180) - *(a1 + 168);
  v10 = *(a1 + 184) - *(a1 + 172);
  v14 = *(a1 + 28) * v19 - *(a1 + 32) * v18;
  v5 = v12 * v10 + v13 * v9;
  if ( v14 * v14 > v5 * v5 )
    return 0;
  v15 = *(a1 + 32) * v17 - *(a1 + 24) * v19;
  v6 = v11 * v10 + v13 * v8;
  if ( v15 * v15 > v6 * v6 )
    return 0;
  v16 = *(a1 + 24) * v18 - *(a1 + 28) * v17;
  v7 = v11 * v9 + v12 * v8;
  return v16 * v16 <= v7 * v7;
}

//----- (08058E30) --------------------------------------------------------
void __cdecl sub_8058E30(int a1, int a2)
{
  float v2; // [esp+14h] [ebp-4h]

  if ( sub_8058B85(a1, (a2 + 12), (a2 + 24)) )
  {
    v2 = *(a1 + 196);
    if ( *(a2 + 36) )
      sub_80503B2(a1, *(a2 + 36));
    else
      sub_8056FF5(a1, *(a2 + 40));
    if ( v2 > *(a1 + 196) )
    {
      *(a1 + 224) = *(dword_84598CC + 18 * *(a2 + 4) + 16);
      *(a1 + 228) = *(a2 + 8);
      *(a1 + 232) = dword_84598CC + 72 * *(a2 + 4);
    }
  }
}

//----- (08058F0A) --------------------------------------------------------
void __cdecl sub_8058F0A(int a1, _DWORD *a2)
{
  int v2; // [esp+Ch] [ebp-9Ch]
  int v3; // [esp+10h] [ebp-98h] BYREF
  int v4; // [esp+14h] [ebp-94h]
  int v5; // [esp+18h] [ebp-90h]
  int *v6; // [esp+38h] [ebp-70h] BYREF
  int v7; // [esp+3Ch] [ebp-6Ch]
  int i; // [esp+40h] [ebp-68h]
  _DWORD *v9; // [esp+44h] [ebp-64h]
  float v10; // [esp+48h] [ebp-60h]
  float v11; // [esp+4Ch] [ebp-5Ch]
  float v12; // [esp+50h] [ebp-58h]
  float v13; // [esp+54h] [ebp-54h]
  float v14; // [esp+58h] [ebp-50h]
  float v15; // [esp+60h] [ebp-48h]
  float v16; // [esp+64h] [ebp-44h]
  float v17; // [esp+68h] [ebp-40h]
  float v18; // [esp+70h] [ebp-38h]
  int **v19; // [esp+74h] [ebp-34h]
  int *v20; // [esp+78h] [ebp-30h]
  float v21; // [esp+7Ch] [ebp-2Ch]
  int v22; // [esp+80h] [ebp-28h]
  float v23; // [esp+84h] [ebp-24h]
  float v24; // [esp+88h] [ebp-20h]
  float v25; // [esp+8Ch] [ebp-1Ch]
  float v26; // [esp+90h] [ebp-18h]
  float v27; // [esp+94h] [ebp-14h]
  int v28; // [esp+98h] [ebp-10h]
  int v29; // [esp+9Ch] [ebp-Ch]

  v26 = 0.0;
  v25 = *(a1 + 196);
  v22 = 1;
  v19 = 0;
  v10 = -1.0;
  v9 = a2 + 1;
  v2 = 0;
  if ( *(a1 + 244) )
  {
LABEL_2:
    for ( i = 0; ; ++i )
    {
      if ( i > 2 )
      {
        if ( !v2 )
        {
          v10 = 1.0;
          v9 = a2 + 4;
          v2 = 1;
          goto LABEL_2;
        }
        v20 = a2[8];
        v29 = a2[7];
        while ( 2 )
        {
          if ( !v29 )
            goto LABEL_73;
          v28 = *v20;
          v27 = *(v28 + 12) + *(a1 + 248);
          v18 = *v28 * *(a1 + 256) + *(v28 + 4) * *(a1 + 260) + *(v28 + 8) * *(a1 + 264);
          if ( v18 <= 0.0 )
          {
            v15 = *a1 + *(a1 + 256);
            v16 = *(a1 + 4) + *(a1 + 260);
            v17 = *(a1 + 8) + *(a1 + 264);
            v12 = *(a1 + 12) + *(a1 + 256);
            v13 = *(a1 + 16) + *(a1 + 260);
            v14 = *(a1 + 20) + *(a1 + 264);
          }
          else
          {
            v15 = *a1 - *(a1 + 256);
            v16 = *(a1 + 4) - *(a1 + 260);
            v17 = *(a1 + 8) - *(a1 + 264);
            v12 = *(a1 + 12) - *(a1 + 256);
            v13 = *(a1 + 16) - *(a1 + 260);
            v14 = *(a1 + 20) - *(a1 + 264);
          }
          v24 = v15 * *v28 + v16 * *(v28 + 4) + v17 * *(v28 + 8) - v27;
          v23 = v12 * *v28 + v13 * *(v28 + 4) + v14 * *(v28 + 8) - v27;
          if ( v24 <= 0.0 )
          {
            if ( v23 > 0.0 )
            {
              v22 = 0;
              v11 = v24 - v23;
              if ( v24 > v25 * v11 )
              {
                v25 = v24 / v11;
                if ( v26 >= v25 )
                  return;
              }
            }
          }
          else
          {
            v11 = v24 - v23;
            if ( v23 > 0.0 )
            {
              if ( v11 <= 0.0 || v23 >= 0.125 )
                return;
              v22 = 0;
            }
            v21 = v24 - 0.125;
            if ( v21 <= v26 * v11 )
            {
              if ( !v19 )
                goto LABEL_34;
            }
            else
            {
              v26 = v21 / v11;
              if ( v26 >= v25 )
                return;
LABEL_34:
              v19 = v20;
            }
          }
          --v29;
          v20 += 2;
          continue;
        }
      }
      v24 = (*(a1 + 4 * i) - *&v9[i]) * v10 - *(a1 + 4 * i + 268);
      v23 = (*(a1 + 4 * i + 12) - *&v9[i]) * v10 - *(a1 + 4 * i + 268);
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( v19 )
            continue;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= v25 )
            return;
        }
        v7 = *(a2 + 3 * v2 + i + 20);
        v5 = 0;
        v4 = 0;
        v3 = 0;
        *(&v3 + i) = v10;
        v6 = &v3;
        v19 = &v6;
      }
    }
  }
  while ( 2 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v24 = (*(a1 + 4 * i) - *&v9[i]) * v10 - *(a1 + 4 * i + 52);
      v23 = (*(a1 + 4 * i + 12) - *&v9[i]) * v10 - *(a1 + 4 * i + 52);
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( v19 )
            continue;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= v25 )
            return;
        }
        v7 = *(a2 + 3 * v2 + i + 20);
        v5 = 0;
        v4 = 0;
        v3 = 0;
        *(&v3 + i) = v10;
        v6 = &v3;
        v19 = &v6;
      }
    }
    if ( !v2 )
    {
      v10 = 1.0;
      v9 = a2 + 4;
      v2 = 1;
      continue;
    }
    break;
  }
  v20 = a2[8];
  v29 = a2[7];
  while ( 2 )
  {
    if ( v29 )
    {
      v28 = *v20;
      v27 = *(v28 + 12)
          - (*(a1 + 12 * *(v28 + 17) + 64) * *v28
           + *(a1 + 12 * *(v28 + 17) + 68) * *(v28 + 4)
           + *(a1 + 12 * *(v28 + 17) + 72) * *(v28 + 8));
      v24 = *a1 * *v28 + *(a1 + 4) * *(v28 + 4) + *(a1 + 8) * *(v28 + 8) - v27;
      v23 = *(a1 + 12) * *v28 + *(a1 + 16) * *(v28 + 4) + *(a1 + 20) * *(v28 + 8) - v27;
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( !v19 )
            goto LABEL_68;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= v25 )
            return;
LABEL_68:
          v19 = v20;
        }
      }
      --v29;
      v20 += 2;
      continue;
    }
    break;
  }
LABEL_73:
  *(a1 + 228) = *a2;
  if ( v19 )
  {
    *(a1 + 196) = v26;
    *(a1 + 212) = **v19;
    *(a1 + 216) = (*v19)[1];
    *(a1 + 220) = (*v19)[2];
    *(a1 + 224) = *(dword_84598CC + 18 * v19[1] + 16);
    *(a1 + 232) = dword_84598CC + 72 * v19[1];
  }
  else
  {
    *(a1 + 243) = 1;
    if ( v22 )
    {
      *(a1 + 242) = 1;
      *(a1 + 196) = 0;
    }
  }
}

//----- (08059875) --------------------------------------------------------
void __cdecl sub_8059875(int a1, int a2)
{
  _DWORD *v2; // [esp+8h] [ebp-10h]
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(a2 + 8); ++i )
  {
    v3 = (dword_845990C + 52 * *(dword_84598F4 + 4 * (*(a2 + 4) + i)));
    if ( v3[9] != dword_8459940 )
    {
      v3[9] = dword_8459940;
      if ( (*v3 & *(a1 + 188)) != 0 )
      {
        sub_8058F0A(a1, v3);
        if ( *(a1 + 196) == 0.0 )
          return;
      }
    }
  }
  if ( !*(dword_8459860 + 32) )
  {
    for ( j = 0; j < *(a2 + 12); ++j )
    {
      v2 = (dword_8459938 + 44 * *(dword_84598FC + 4 * (j + *(a2 + 10))));
      if ( *v2 != dword_8459940 )
      {
        *v2 = dword_8459940;
        if ( (v2[2] & *(a1 + 188)) != 0 )
        {
          sub_8058E30(a1, v2);
          if ( *(a1 + 196) == 0.0 )
            break;
        }
      }
    }
  }
}
// 8459860: using guessed type int dword_8459860;
// 84598F4: using guessed type int dword_84598F4;
// 84598FC: using guessed type int dword_84598FC;
// 845990C: using guessed type int dword_845990C;
// 8459938: using guessed type int dword_8459938;
// 8459940: using guessed type int dword_8459940;

//----- (080599E6) --------------------------------------------------------
int __cdecl sub_80599E6(int a1, int a2, int a3, int a4, float a5)
{
  long double v5; // fst7
  float v7; // [esp+28h] [ebp-60h]
  double v8; // [esp+30h] [ebp-58h]
  int v9; // [esp+38h] [ebp-50h]
  float v10; // [esp+3Ch] [ebp-4Ch]
  int v11[5]; // [esp+40h] [ebp-48h] BYREF
  float v12; // [esp+54h] [ebp-34h]
  float v13; // [esp+58h] [ebp-30h]
  float v14; // [esp+5Ch] [ebp-2Ch]
  float v15; // [esp+60h] [ebp-28h]
  float v16; // [esp+64h] [ebp-24h]
  float v17; // [esp+68h] [ebp-20h]
  float v18; // [esp+6Ch] [ebp-1Ch]
  float v19; // [esp+70h] [ebp-18h] BYREF
  float v20; // [esp+74h] [ebp-14h]
  float v21; // [esp+78h] [ebp-10h]

  v19 = *a2 - *a4;
  v20 = *(a2 + 4) - *(a4 + 4);
  v21 = *(a2 + 8) - *(a4 + 8);
  v14 = (a5 + *(a1 + 248)) * (a5 + *(a1 + 248));
  v16 = v19 * v19 + v20 * v20 + v21 * v21 - v14;
  if ( v16 > 0.0 )
  {
    v17 = *(a1 + 24) * v19 + *(a1 + 28) * v20 + *(a1 + 32) * v21;
    if ( v17 < 0.0 )
    {
      v18 = *(a1 + 36);
      v15 = v17 * v17 - v18 * v16;
      if ( v15 >= 0.0 )
      {
        v12 = sub_80669A0(&v19, v11);
        v8 = -v17;
        v5 = sqrt(v15);
        v10 = (v8 - v5) / v18;
        v13 = v10 + v12 * 0.125 / v17;
        if ( *(a1 + 196) <= v13 )
        {
          v9 = 1;
        }
        else
        {
          if ( v13 <= 0.0 )
            v7 = 0.0;
          else
            v7 = v13;
          *(a1 + 196) = v7;
          *(a1 + 212) = v11[0];
          *(a1 + 216) = v11[1];
          *(a1 + 220) = v11[2];
          *(a1 + 228) = sub_804BF27();
          v9 = 0;
        }
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    *(a1 + 196) = 0;
    *(a1 + 243) = 1;
    sub_80669A0(&v19, (a1 + 212));
    *(a1 + 228) = sub_804BF27();
    v19 = *a3 - *a4;
    v20 = *(a3 + 4) - *(a4 + 4);
    v21 = *(a3 + 8) - *(a4 + 8);
    if ( v14 >= v19 * v19 + v20 * v20 + v21 * v21 )
      *(a1 + 242) = 1;
    v9 = 0;
  }
  return v9;
}

//----- (08059C6B) --------------------------------------------------------
int __cdecl sub_8059C6B(int a1, int a2, float a3, float a4)
{
  long double v4; // fst7
  float v6; // [esp+20h] [ebp-68h]
  double v7; // [esp+28h] [ebp-60h]
  int v8; // [esp+30h] [ebp-58h]
  float v9; // [esp+34h] [ebp-54h]
  float v10; // [esp+38h] [ebp-50h]
  float v11; // [esp+3Ch] [ebp-4Ch]
  float v12; // [esp+3Ch] [ebp-4Ch]
  int v13[4]; // [esp+40h] [ebp-48h] BYREF
  float v14; // [esp+50h] [ebp-38h]
  float v15; // [esp+54h] [ebp-34h]
  float v16; // [esp+58h] [ebp-30h]
  float v17; // [esp+5Ch] [ebp-2Ch]
  float v18; // [esp+60h] [ebp-28h]
  float v19; // [esp+64h] [ebp-24h]
  float v20; // [esp+68h] [ebp-20h]
  float v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h] BYREF
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]

  v22 = *a1 - *a2;
  v23 = *(a1 + 4) - *(a2 + 4);
  v24 = *(a1 + 8) - *(a2 + 8);
  v17 = (a4 + *(a1 + 248)) * (a4 + *(a1 + 248));
  v19 = v22 * v22 + v23 * v23 - v17;
  if ( v19 > 0.0 )
  {
    v20 = *(a1 + 24) * v22 + *(a1 + 28) * v23;
    if ( v20 < 0.0 )
    {
      v21 = *(a1 + 24) * *(a1 + 24) + *(a1 + 28) * *(a1 + 28);
      v18 = v20 * v20 - v21 * v19;
      if ( v18 >= 0.0 )
      {
        v24 = 0.0;
        v14 = sub_80669A0(&v22, v13);
        v15 = v14 * 0.125 / v20;
        v7 = -v20;
        v4 = sqrt(v18);
        v9 = (v7 - v4) / v21;
        v16 = v9 + v15;
        if ( *(a1 + 196) <= v16 )
        {
          v8 = 1;
        }
        else
        {
          v12 = *(a1 + 252) - *(a1 + 248) + a3;
          v10 = (v16 - v15) * *(a1 + 32) + *(a1 + 8) - *(a2 + 8);
          if ( v10 <= v12 && -v12 <= v10 )
          {
            if ( v16 <= 0.0 )
              v6 = 0.0;
            else
              v6 = v16;
            *(a1 + 196) = v6;
            *(a1 + 212) = v13[0];
            *(a1 + 216) = v13[1];
            *(a1 + 220) = v13[2];
            *(a1 + 228) = sub_804BF27();
            v8 = 0;
          }
          else
          {
            v8 = 1;
          }
        }
      }
      else
      {
        v8 = 1;
      }
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v11 = *(a1 + 252) - *(a1 + 248) + a3;
    if ( v24 <= v11 && -v11 <= v24 )
    {
      *(a1 + 196) = 0;
      *(a1 + 243) = 1;
      v24 = 0.0;
      sub_80669A0(&v22, (a1 + 212));
      *(a1 + 228) = sub_804BF27();
      v22 = *(a1 + 12) - *a2;
      v23 = *(a1 + 16) - *(a2 + 4);
      v24 = *(a1 + 20) - *(a2 + 8);
      if ( v11 >= v24 && v24 >= -v11 )
        *(a1 + 242) = 1;
      v8 = 0;
    }
    else
    {
      v8 = 1;
    }
  }
  return v8;
}

//----- (08059FB5) --------------------------------------------------------
void __cdecl sub_8059FB5(float *a1)
{
  float v1; // [esp+2Ch] [ebp-BCh]
  float v2; // [esp+30h] [ebp-B8h]
  float v3[3]; // [esp+40h] [ebp-A8h]
  float v4[2]; // [esp+4Ch] [ebp-9Ch]
  float v5; // [esp+54h] [ebp-94h]
  int v6; // [esp+60h] [ebp-88h] BYREF
  int v7; // [esp+64h] [ebp-84h]
  float v8; // [esp+68h] [ebp-80h]
  int v9[2]; // [esp+70h] [ebp-78h] BYREF
  float v10; // [esp+78h] [ebp-70h]
  int v11[2]; // [esp+80h] [ebp-68h] BYREF
  float v12; // [esp+88h] [ebp-60h]
  int v13[2]; // [esp+90h] [ebp-58h] BYREF
  float v14; // [esp+98h] [ebp-50h]
  int v15[2]; // [esp+A0h] [ebp-48h] BYREF
  float v16; // [esp+A8h] [ebp-40h]
  int v17[2]; // [esp+B0h] [ebp-38h] BYREF
  float v18; // [esp+B8h] [ebp-30h]
  int v19[2]; // [esp+C0h] [ebp-28h] BYREF
  float v20; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( a1[41] <= *dword_845996C + 1.0
    && a1[42] <= *&dword_8459970 + 1.0
    && a1[43] <= *&dword_8459974 + 1.0
    && *dword_8459960 - 1.0 <= a1[44]
    && *&dword_8459964 - 1.0 <= a1[45]
    && *&dword_8459968 - 1.0 <= a1[46] )
  {
    *v15 = *a1 + a1[64];
    *&v15[1] = a1[1] + a1[65];
    v16 = a1[2] + a1[66];
    *v13 = *a1 - a1[64];
    *&v13[1] = a1[1] - a1[65];
    v14 = a1[2] - a1[66];
    *v11 = a1[3] + a1[64];
    *&v11[1] = a1[4] + a1[65];
    v12 = a1[5] + a1[66];
    *v9 = a1[3] - a1[64];
    *&v9[1] = a1[4] - a1[65];
    v10 = a1[5] - a1[66];
    for ( i = 0; i <= 2; ++i )
    {
      *(&v6 + i) = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
      v3[i] = *&dword_8459960[i] - *(&v6 + i);
      v4[i] = *&dword_845996C[i] - *(&v6 + i);
    }
    if ( v4[0] <= v5 )
      v1 = v4[0];
    else
      v1 = v5;
    v2 = v5 - v1;
    v19[0] = v6;
    v19[1] = v7;
    v20 = v8 + v2;
    v17[0] = v6;
    v17[1] = v7;
    v18 = v8 - v2;
    if ( v14 <= v20 )
    {
      if ( v18 > v16 && (!sub_80599E6(a1, v15, v11, v17, v1) || a1[8] <= 0.0) )
        return;
    }
    else if ( !sub_80599E6(a1, v13, v9, v19, v1) || a1[8] >= 0.0 )
    {
      return;
    }
    if ( sub_8059C6B(a1, &v6, v2, v1) )
    {
      if ( v10 <= v20 )
      {
        if ( v18 > v12 && v16 >= v18 )
          sub_80599E6(a1, v15, v11, v17, v1);
      }
      else if ( v20 >= v14 )
      {
        sub_80599E6(a1, v13, v9, v19, v1);
      }
    }
  }
}
// 8459960: using guessed type int dword_8459960[];
// 8459964: using guessed type int dword_8459964;
// 8459968: using guessed type int dword_8459968;
// 845996C: using guessed type int dword_845996C[];
// 8459970: using guessed type int dword_8459970;
// 8459974: using guessed type int dword_8459974;

//----- (0805A3EF) --------------------------------------------------------
void __cdecl sub_805A3EF(int a1)
{
  float v1; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v3[3]; // [esp+20h] [ebp-38h]
  float v4[2]; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+34h] [ebp-24h]
  float v6[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v6[i] = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
    v3[i] = *&dword_8459960[i] - v6[i];
    v4[i] = *&dword_845996C[i] - v6[i];
    *(a1 + 4 * i) = *(a1 + 4 * i) - v6[i];
    *(a1 + 4 * i + 12) = *(a1 + 4 * i + 12) - v6[i];
  }
  *(a1 + 244) = 1;
  if ( v4[0] <= v5 )
    v1 = v4[0];
  else
    v1 = v5;
  *(a1 + 248) = v1;
  *(a1 + 252) = v5;
  *(a1 + 256) = 0;
  *(a1 + 260) = 0;
  *(a1 + 264) = v5 - *(a1 + 248);
  *(a1 + 268) = *(a1 + 248);
  *(a1 + 272) = *(a1 + 248);
  *(a1 + 276) = *(a1 + 252);
  sub_804BE53((a1 + 40), (a1 + 52), *dword_845995C, 0);
  sub_8058F0A(a1, dword_845995C);
}
// 845995C: using guessed type int dword_845995C;
// 8459960: using guessed type int dword_8459960[];
// 845996C: using guessed type int dword_845996C[];

//----- (0805A58F) --------------------------------------------------------
void __cdecl sub_805A58F(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int v6; // [esp+28h] [ebp-40h]
  float v7; // [esp+28h] [ebp-40h]
  int v8; // [esp+2Ch] [ebp-3Ch]
  int v9; // [esp+30h] [ebp-38h] BYREF
  float v10; // [esp+34h] [ebp-34h]
  float v11; // [esp+38h] [ebp-30h]
  float v12; // [esp+40h] [ebp-28h]
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+4Ch] [ebp-1Ch]
  float v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  int v18; // [esp+58h] [ebp-10h]
  int v19; // [esp+5Ch] [ebp-Ch]

  if ( a3 < *(a1 + 196) )
  {
    if ( a2 >= 0 )
    {
      v19 = dword_84598E4 + 8 * a2;
      v18 = *v19;
      if ( *(v18 + 16) > 2u )
      {
        v17 = *v18 * *a5 + *(v18 + 4) * *(a5 + 4) + *(v18 + 8) * *(a5 + 8) - *(v18 + 12);
        v16 = *v18 * *a6 + *(v18 + 4) * *(a6 + 4) + *(v18 + 8) * *(a6 + 8) - *(v18 + 12);
        if ( *(a1 + 192) )
          v15 = 0.0;
        else
          v15 = 2048.0;
      }
      else
      {
        v17 = *(a5 + 4 * *(v18 + 16)) - *(v18 + 12);
        v16 = *(a6 + 4 * *(v18 + 16)) - *(v18 + 12);
        v15 = *(a1 + 4 * *(v18 + 16) + 52);
      }
      if ( v17 < v15 + 1.0 || v16 < v15 + 1.0 )
      {
        if ( -1.0 - v15 <= v17 || -1.0 - v15 <= v16 )
        {
          if ( v16 <= v17 )
          {
            if ( v17 <= v16 )
            {
              v8 = 0;
              v14 = 1.0;
              v13 = 0.0;
            }
            else
            {
              v12 = 1.0 / (v17 - v16);
              v8 = 0;
              v13 = (v17 - v15 - 0.125) * v12;
              v14 = (v17 + v15 + 0.125) * v12;
            }
          }
          else
          {
            v12 = 1.0 / (v17 - v16);
            v8 = 1;
            v13 = (v17 + v15 + 0.125) * v12;
            v14 = (v17 - v15 + 0.125) * v12;
          }
          if ( v14 < 0.0 )
            v14 = 0.0;
          if ( v14 > 1.0 )
            v14 = 1.0;
          *&v6 = (*&a4 - a3) * v14 + a3;
          *&v9 = (*a6 - *a5) * v14 + *a5;
          v10 = (*(a6 + 4) - *(a5 + 4)) * v14 + *(a5 + 4);
          v11 = (*(a6 + 8) - *(a5 + 8)) * v14 + *(a5 + 8);
          sub_805A58F(a1, *(v19 + 2 * v8 + 4), a3, v6, a5, &v9);
          if ( v13 < 0.0 )
            v13 = 0.0;
          if ( v13 > 1.0 )
            v13 = 1.0;
          v7 = (*&a4 - a3) * v13 + a3;
          *&v9 = (*a6 - *a5) * v13 + *a5;
          v10 = (*(a6 + 4) - *(a5 + 4)) * v13 + *(a5 + 4);
          v11 = (*(a6 + 8) - *(a5 + 8)) * v13 + *(a5 + 8);
          sub_805A58F(a1, *(v19 + 2 * (v8 ^ 1) + 4), v7, a4, &v9, a6);
        }
        else
        {
          sub_805A58F(a1, *(v19 + 6), a3, a4, a5, a6);
        }
      }
      else
      {
        sub_805A58F(a1, *(v19 + 4), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_8059875(a1, dword_84598EC + 16 * (-1 - a2));
    }
  }
}
// 84598E4: using guessed type int dword_84598E4;
// 84598EC: using guessed type int dword_84598EC;

//----- (0805A9D5) --------------------------------------------------------
int __cdecl sub_805A9D5(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8, int a9)
{
  int v9; // ebx
  long double v10; // fst7
  int result; // eax
  float v12; // [esp+24h] [ebp-164h]
  float v13; // [esp+28h] [ebp-160h]
  float v14; // [esp+28h] [ebp-160h]
  float v15; // [esp+28h] [ebp-160h]
  int *v16; // [esp+2Ch] [ebp-15Ch]
  float v17[4]; // [esp+30h] [ebp-158h]
  float s[3]; // [esp+40h] [ebp-148h] BYREF
  float v19[3]; // [esp+4Ch] [ebp-13Ch] BYREF
  float v20; // [esp+58h] [ebp-130h]
  float v21; // [esp+5Ch] [ebp-12Ch]
  float v22; // [esp+60h] [ebp-128h]
  float v23; // [esp+64h] [ebp-124h]
  int v24; // [esp+68h] [ebp-120h]
  int v25; // [esp+6Ch] [ebp-11Ch]
  int v26; // [esp+70h] [ebp-118h]
  int v27; // [esp+74h] [ebp-114h]
  int v28; // [esp+78h] [ebp-110h]
  int v29; // [esp+7Ch] [ebp-10Ch]
  int v30; // [esp+80h] [ebp-108h]
  int v31; // [esp+84h] [ebp-104h]
  int v32; // [esp+88h] [ebp-100h]
  int v33; // [esp+8Ch] [ebp-FCh]
  int v34; // [esp+90h] [ebp-F8h]
  int v35; // [esp+94h] [ebp-F4h]
  int v36; // [esp+98h] [ebp-F0h]
  int v37; // [esp+9Ch] [ebp-ECh]
  int v38; // [esp+A0h] [ebp-E8h]
  int v39; // [esp+A4h] [ebp-E4h]
  int v40; // [esp+A8h] [ebp-E0h]
  int v41; // [esp+ACh] [ebp-DCh]
  int v42; // [esp+B0h] [ebp-D8h]
  int v43; // [esp+B4h] [ebp-D4h]
  int v44; // [esp+B8h] [ebp-D0h]
  int v45; // [esp+BCh] [ebp-CCh]
  int v46; // [esp+C0h] [ebp-C8h]
  int v47; // [esp+C4h] [ebp-C4h]
  float v48; // [esp+C8h] [ebp-C0h]
  int v49; // [esp+CCh] [ebp-BCh]
  int v50; // [esp+D0h] [ebp-B8h]
  float v51; // [esp+D4h] [ebp-B4h]
  float v52; // [esp+D8h] [ebp-B0h]
  int v53; // [esp+DCh] [ebp-ACh]
  float v54; // [esp+E0h] [ebp-A8h]
  float v55[6]; // [esp+E4h] [ebp-A4h]
  int v56; // [esp+FCh] [ebp-8Ch]
  _BOOL4 v57; // [esp+100h] [ebp-88h]
  int v58[12]; // [esp+104h] [ebp-84h] BYREF
  int v59; // [esp+134h] [ebp-54h]
  float v60; // [esp+138h] [ebp-50h]
  float v61; // [esp+13Ch] [ebp-4Ch]
  float v62; // [esp+140h] [ebp-48h]
  int v63; // [esp+144h] [ebp-44h]
  float v64; // [esp+148h] [ebp-40h]
  int v65[8]; // [esp+14Ch] [ebp-3Ch]
  int i; // [esp+16Ch] [ebp-1Ch]

  v16 = sub_804BC58(a6);
  ++dword_8459940;
  sub_80C837D(s, 0, 0x118u);
  v58[0] = *a1;
  if ( !a4 )
    a4 = &dword_80DD708;
  if ( !a5 )
    a5 = &dword_80DD708;
  v56 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v17[i] = (*&a4[i] + *&a5[i]) * 0.5;
    *(&v24 + i) = *&a4[i] - v17[i];
    *(&v27 + i) = *&a5[i] - v17[i];
    s[i] = a2[i] + v17[i];
    v19[i] = a3[i] + v17[i];
    *(&v20 + i) = v19[i] - s[i];
  }
  v23 = v20 * v20 + v21 * v21 + v22 * v22;
  if ( a9 )
  {
    v59 = *a9;
    v60 = *(a9 + 4);
    v61 = *(a9 + 8);
    v62 = *(a9 + 12);
    v63 = *(a9 + 16);
    v64 = *(a9 + 20);
    v65[0] = *(a9 + 24);
    v65[1] = *(a9 + 28);
    v65[2] = *(a9 + 32);
  }
  else
  {
    v59 = a8;
    if ( *&v27 <= *&v29 )
      v12 = *&v27;
    else
      v12 = *&v29;
    v60 = v12;
    v61 = *&v29;
    v62 = 0.0;
    v63 = 0;
    v64 = *&v29 - v12;
  }
  v54 = *&v27 + *&v28 + *&v29;
  v30 = v24;
  v31 = v25;
  v32 = v26;
  v33 = v27;
  v34 = v25;
  v35 = v26;
  v36 = v24;
  v37 = v28;
  v38 = v26;
  v39 = v27;
  v40 = v28;
  v41 = v26;
  v42 = v24;
  v43 = v25;
  v44 = v29;
  v45 = v27;
  v46 = v25;
  v47 = v29;
  v48 = *&v24;
  v49 = v28;
  v50 = v29;
  v51 = *&v27;
  v52 = *&v28;
  v53 = v29;
  if ( v59 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v13 = fabs(*(&v62 + i));
      if ( v19[i] <= s[i] )
      {
        v55[i] = v19[i] - v13 - v60;
        v15 = fabs(*(&v62 + i));
        v55[i + 3] = v15 + s[i] + v60;
      }
      else
      {
        v55[i] = s[i] - v13 - v60;
        v14 = fabs(*(&v62 + i));
        v55[i + 3] = v14 + v19[i] + v60;
      }
    }
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( v19[i] <= s[i] )
      {
        v55[i] = v19[i] + *(&v24 + i);
        v55[i + 3] = s[i] + *(&v27 + i);
      }
      else
      {
        v55[i] = s[i] + *(&v24 + i);
        v55[i + 3] = v19[i] + *(&v27 + i);
      }
    }
  }
  if ( *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] )
  {
    if ( a6 )
    {
      if ( a6 == 510 )
      {
        if ( (v56 & *dword_845995C) != 0 )
        {
          if ( v59 )
            sub_805848F(s);
          else
            sub_8058894(s);
        }
      }
      else
      {
        sub_80582C8(s, (v16 + 6));
      }
    }
    else
    {
      sub_80589FE(s);
    }
  }
  else
  {
    v57 = 0.0 == *&v27 + *&v28 + *&v29;
    if ( v59 )
    {
      for ( i = 0; i <= 2; ++i )
      {
        v9 = i;
        v10 = sub_805D7EC(*(&v62 + i));
        *&v65[v9] = v10 + v60;
      }
    }
    if ( a6 )
    {
      if ( a6 == 510 )
      {
        if ( (v56 & *dword_845995C) != 0 )
        {
          if ( v59 )
            sub_8059FB5(s);
          else
            sub_805A3EF(s);
        }
      }
      else
      {
        sub_8059875(s, (v16 + 6));
      }
    }
    else
    {
      sub_805A58F(s, 0, 0.0, v58[0], s, v19);
    }
  }
  *&v58[1] = v20 * *v58 + *a2;
  *&v58[2] = v21 * *v58 + a2[1];
  *&v58[3] = v22 * *v58 + a2[2];
  result = 12;
  qmemcpy(a1, v58, 0x30u);
  return result;
}
// 80DD708: using guessed type int dword_80DD708;
// 8459940: using guessed type int dword_8459940;
// 845995C: using guessed type int dword_845995C;

//----- (0805B145) --------------------------------------------------------
int __cdecl sub_805B145(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8)
{
  *a1 = 1065353216;
  return sub_805A9D5(a1, a2, a3, a4, a5, a6, a7, a8, 0);
}

//----- (0805B19A) --------------------------------------------------------
int __cdecl sub_805B19A(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  int result; // eax
  int v11; // [esp+4Ch] [ebp-14Ch]
  int v12[3]; // [esp+50h] [ebp-148h] BYREF
  float v13; // [esp+5Ch] [ebp-13Ch]
  float v14; // [esp+60h] [ebp-138h]
  float v15; // [esp+64h] [ebp-134h]
  float v16; // [esp+80h] [ebp-118h]
  int v17; // [esp+84h] [ebp-114h]
  int v18; // [esp+88h] [ebp-110h]
  int i; // [esp+8Ch] [ebp-10Ch]
  float v20[12]; // [esp+90h] [ebp-108h] BYREF
  float v21[12]; // [esp+C0h] [ebp-D8h] BYREF
  int v22[3]; // [esp+F0h] [ebp-A8h] BYREF
  float v23[2]; // [esp+FCh] [ebp-9Ch] BYREF
  float v24; // [esp+104h] [ebp-94h]
  float v25[7]; // [esp+110h] [ebp-88h]
  _BOOL4 v26; // [esp+12Ch] [ebp-6Ch]
  float v27; // [esp+130h] [ebp-68h] BYREF
  float v28; // [esp+134h] [ebp-64h]
  float v29; // [esp+138h] [ebp-60h]
  float v30; // [esp+140h] [ebp-58h] BYREF
  float v31; // [esp+144h] [ebp-54h]
  float v32; // [esp+148h] [ebp-50h]
  int v33[18]; // [esp+150h] [ebp-48h] BYREF

  if ( !a4 )
    a4 = &dword_80DD708;
  if ( !a5 )
    a5 = &dword_80DD708;
  for ( i = 0; i <= 2; ++i )
  {
    v25[i] = (*&a4[i] + *&a5[i]) * 0.5;
    *&v22[i] = *&a4[i] - v25[i];
    v23[i] = *&a5[i] - v25[i];
    *(&v30 + i) = a2[i] + v25[i];
    *(&v27 + i) = a3[i] + v25[i];
  }
  v30 = v30 - *a8;
  v31 = v31 - a8[1];
  v32 = v32 - a8[2];
  v27 = v27 - *a8;
  v28 = v28 - a8[1];
  v29 = v29 - a8[2];
  v26 = a6 != 511 && (*a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0);
  v18 = SLODWORD(v23[0]);
  *&v17 = v24;
  v12[0] = a10;
  if ( v23[0] <= v24 )
    v11 = v18;
  else
    v11 = v17;
  v12[1] = v11;
  v12[2] = v17;
  v16 = *&v17 - *&v11;
  if ( v26 )
  {
    sub_8057C2A(a9, v21);
    sub_8057B18(&v30, v21);
    sub_8057B18(&v27, v21);
    v13 = v21[2] * v16;
    v14 = -v21[5] * v16;
    v15 = v21[8] * v16;
  }
  else
  {
    v13 = 0.0;
    v14 = 0.0;
    v15 = v16;
  }
  v33[0] = *a1;
  sub_805A9D5(v33, &v30, &v27, v22, v23, a6, a7, a10, v12);
  if ( v26 && *a1 > *v33 )
  {
    sub_8057BBF(v21, v20);
    sub_8057B18(&v33[4], v20);
  }
  *&v33[1] = (*a3 - *a2) * *v33 + *a2;
  *&v33[2] = (a3[1] - a2[1]) * *v33 + a2[1];
  *&v33[3] = (a3[2] - a2[2]) * *v33 + a2[2];
  result = 12;
  qmemcpy(a1, v33, 0x30u);
  return result;
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0805B5B0) --------------------------------------------------------
int __cdecl sub_805B5B0(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  *a1 = 1065353216;
  return sub_805B19A(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0805B60B) --------------------------------------------------------
int __cdecl sub_805B60B(int *a1, int a2)
{
  if ( !sub_8058B85(a1, (a2 + 12), (a2 + 24)) )
    return 1;
  if ( *(a2 + 36) )
    return sub_80509F7(a1, *(a2 + 36));
  return sub_8057073(a1, *(a2 + 40));
}

//----- (0805B67D) --------------------------------------------------------
int __cdecl sub_805B67D(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-6Ch]
  int i; // [esp+10h] [ebp-68h]
  int k; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  float v8; // [esp+18h] [ebp-60h]
  float v9; // [esp+1Ch] [ebp-5Ch]
  float v10; // [esp+1Ch] [ebp-5Ch]
  float v11; // [esp+1Ch] [ebp-5Ch]
  float v12; // [esp+1Ch] [ebp-5Ch]
  float v13; // [esp+1Ch] [ebp-5Ch]
  float v14; // [esp+1Ch] [ebp-5Ch]
  float v15; // [esp+1Ch] [ebp-5Ch]
  float v16; // [esp+1Ch] [ebp-5Ch]
  float v17; // [esp+20h] [ebp-58h]
  float v18; // [esp+24h] [ebp-54h]
  float v19; // [esp+28h] [ebp-50h]
  float v20; // [esp+30h] [ebp-48h]
  float v21; // [esp+34h] [ebp-44h]
  float v22; // [esp+38h] [ebp-40h]
  float v23; // [esp+4Ch] [ebp-2Ch]
  float **v24; // [esp+50h] [ebp-28h]
  int *v25; // [esp+50h] [ebp-28h]
  float v26; // [esp+54h] [ebp-24h]
  float v27; // [esp+54h] [ebp-24h]
  float v28; // [esp+54h] [ebp-24h]
  float v29; // [esp+54h] [ebp-24h]
  float v30; // [esp+58h] [ebp-20h]
  float v31; // [esp+58h] [ebp-20h]
  float v32; // [esp+58h] [ebp-20h]
  float v33; // [esp+58h] [ebp-20h]
  float v34; // [esp+5Ch] [ebp-1Ch]
  float v35; // [esp+60h] [ebp-18h]
  float v36; // [esp+64h] [ebp-14h]
  float v37; // [esp+64h] [ebp-14h]
  float *v38; // [esp+68h] [ebp-10h]
  int v39; // [esp+68h] [ebp-10h]
  int j; // [esp+6Ch] [ebp-Ch]
  int l; // [esp+6Ch] [ebp-Ch]

  v35 = 0.0;
  v34 = 1.0;
  v8 = -1.0;
  v7 = a2 + 4;
  v4 = 0;
  if ( *(a1 + 244) )
  {
    while ( 1 )
    {
      for ( i = 0; i <= 2; ++i )
      {
        v30 = (*(a1 + 4 * i) - *(v7 + 4 * i)) * v8 - *(a1 + 4 * i + 268);
        v26 = (*(a1 + 4 * i + 12) - *(v7 + 4 * i)) * v8 - *(a1 + 4 * i + 268);
        if ( v30 <= 0.0 )
        {
          if ( v26 > 0.0 )
          {
            v10 = v30 - v26;
            if ( v30 > v34 * v10 )
            {
              v34 = v30 / v10;
              if ( v35 >= v34 )
                return 0;
            }
          }
        }
        else
        {
          v9 = v30 - v26;
          if ( v26 > 0.0 )
            return 0;
          if ( v30 > v35 * v9 )
          {
            v35 = v30 / v9;
            if ( v35 >= v34 )
              return 0;
          }
        }
      }
      if ( v4 )
        break;
      v8 = 1.0;
      v7 = a2 + 16;
      v4 = 1;
    }
    v24 = *(a2 + 32);
    for ( j = *(a2 + 28); j; --j )
    {
      v38 = *v24;
      v36 = (*v24)[3] + *(a1 + 248);
      v23 = *v38 * *(a1 + 256) + v38[1] * *(a1 + 260) + v38[2] * *(a1 + 264);
      if ( v23 <= 0.0 )
      {
        v20 = *a1 + *(a1 + 256);
        v21 = *(a1 + 4) + *(a1 + 260);
        v22 = *(a1 + 8) + *(a1 + 264);
        v17 = *(a1 + 12) + *(a1 + 256);
        v18 = *(a1 + 16) + *(a1 + 260);
        v19 = *(a1 + 20) + *(a1 + 264);
      }
      else
      {
        v20 = *a1 - *(a1 + 256);
        v21 = *(a1 + 4) - *(a1 + 260);
        v22 = *(a1 + 8) - *(a1 + 264);
        v17 = *(a1 + 12) - *(a1 + 256);
        v18 = *(a1 + 16) - *(a1 + 260);
        v19 = *(a1 + 20) - *(a1 + 264);
      }
      v31 = v20 * *v38 + v21 * v38[1] + v22 * v38[2] - v36;
      v27 = v17 * *v38 + v18 * v38[1] + v19 * v38[2] - v36;
      if ( v31 <= 0.0 )
      {
        if ( v27 > 0.0 )
        {
          v12 = v31 - v27;
          if ( v31 > v34 * v12 )
          {
            v34 = v31 / v12;
            if ( v35 >= v34 )
              return 0;
          }
        }
      }
      else
      {
        v11 = v31 - v27;
        if ( v27 > 0.0 )
          return 0;
        if ( v31 > v35 * v11 )
        {
          v35 = v31 / v11;
          if ( v35 >= v34 )
            return 0;
        }
      }
      v24 += 2;
    }
  }
  else
  {
    while ( 1 )
    {
      for ( k = 0; k <= 2; ++k )
      {
        v32 = (*(a1 + 4 * k) - *(v7 + 4 * k)) * v8 - *(a1 + 4 * k + 52);
        v28 = (*(a1 + 4 * k + 12) - *(v7 + 4 * k)) * v8 - *(a1 + 4 * k + 52);
        if ( v32 <= 0.0 )
        {
          if ( v28 > 0.0 )
          {
            v14 = v32 - v28;
            if ( v32 > v34 * v14 )
            {
              v34 = v32 / v14;
              if ( v35 >= v34 )
                return 0;
            }
          }
        }
        else
        {
          v13 = v32 - v28;
          if ( v28 > 0.0 )
            return 0;
          if ( v32 > v35 * v13 )
          {
            v35 = v32 / v13;
            if ( v35 >= v34 )
              return 0;
          }
        }
      }
      if ( v4 )
        break;
      v8 = 1.0;
      v7 = a2 + 16;
      v4 = 1;
    }
    v25 = *(a2 + 32);
    for ( l = *(a2 + 28); l; --l )
    {
      v39 = *v25;
      v37 = *(v39 + 12)
          - (*(a1 + 12 * *(v39 + 17) + 64) * *v39
           + *(a1 + 12 * *(v39 + 17) + 68) * *(v39 + 4)
           + *(a1 + 12 * *(*v25 + 17) + 72) * *(v39 + 8));
      v33 = *a1 * *v39 + *(a1 + 4) * *(v39 + 4) + *(a1 + 8) * *(v39 + 8) - v37;
      v29 = *(a1 + 12) * *v39 + *(a1 + 16) * *(v39 + 4) + *(a1 + 20) * *(v39 + 8) - v37;
      if ( v33 <= 0.0 )
      {
        if ( v29 > 0.0 )
        {
          v16 = v33 - v29;
          if ( v33 > v34 * v16 )
          {
            v34 = v33 / v16;
            if ( v35 >= v34 )
              return 0;
          }
        }
      }
      else
      {
        v15 = v33 - v29;
        if ( v29 > 0.0 )
          return 0;
        if ( v33 > v35 * v15 )
        {
          v35 = v33 / v15;
          if ( v35 >= v34 )
            return 0;
        }
      }
      v25 += 2;
    }
  }
  return -991146299 * ((a2 - dword_845990C) >> 2) + 1;
}
// 845990C: using guessed type int dword_845990C;

//----- (0805BDAD) --------------------------------------------------------
int __cdecl sub_805BDAD(int *a1, int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < *(a2 + 8); ++i )
  {
    v5 = (dword_845990C + 52 * *(dword_84598F4 + 4 * (*(a2 + 4) + i)));
    if ( v5[9] != dword_8459940 )
    {
      v5[9] = dword_8459940;
      if ( (*v5 & a1[47]) != 0 )
      {
        v6 = sub_805B67D(a1, v5);
        if ( v6 )
          return v6;
      }
    }
  }
  if ( !*(dword_8459860 + 32) )
  {
    for ( j = 0; j < *(a2 + 12); ++j )
    {
      v4 = (dword_8459938 + 44 * *(dword_84598FC + 4 * (j + *(a2 + 10))));
      if ( *v4 != dword_8459940 )
      {
        *v4 = dword_8459940;
        if ( (v4[2] & a1[47]) != 0 && !sub_805B60B(a1, v4) )
          return dword_8459908 - 1171354717 * ((v4 - dword_8459938) >> 2) + 1;
      }
    }
  }
  return 0;
}
// 8459860: using guessed type int dword_8459860;
// 84598F4: using guessed type int dword_84598F4;
// 84598FC: using guessed type int dword_84598FC;
// 8459908: using guessed type int dword_8459908;
// 845990C: using guessed type int dword_845990C;
// 8459938: using guessed type int dword_8459938;
// 8459940: using guessed type int dword_8459940;

//----- (0805BF30) --------------------------------------------------------
_BOOL4 __cdecl sub_805BF30(int a1, int a2, int a3, int a4, float a5)
{
  long double v5; // fst7
  double v7; // [esp+20h] [ebp-58h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  float v10[5]; // [esp+30h] [ebp-48h] BYREF
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+4Ch] [ebp-2Ch]
  float v14; // [esp+50h] [ebp-28h]
  float v15; // [esp+54h] [ebp-24h]
  float v16; // [esp+58h] [ebp-20h]
  float v17; // [esp+5Ch] [ebp-1Ch]
  float v18; // [esp+60h] [ebp-18h] BYREF
  float v19; // [esp+64h] [ebp-14h]
  float v20; // [esp+68h] [ebp-10h]

  v18 = *a2 - *a4;
  v19 = *(a2 + 4) - *(a4 + 4);
  v20 = *(a2 + 8) - *(a4 + 8);
  v13 = (a5 + *(a1 + 248)) * (a5 + *(a1 + 248));
  v15 = v18 * v18 + v19 * v19 + v20 * v20 - v13;
  if ( v15 <= 0.0 )
    return 0;
  v16 = *(a1 + 24) * v18 + *(a1 + 28) * v19 + *(a1 + 32) * v20;
  if ( v16 >= 0.0 )
    return 1;
  v17 = *(a1 + 36);
  v14 = v16 * v16 - v17 * v15;
  if ( v14 < 0.0 )
    return 1;
  v11 = sub_80669A0(&v18, v10);
  v7 = -v16;
  v5 = sqrt(v14);
  v9 = (v7 - v5) / v17;
  v12 = v9 + v16 * 0.125 / v11;
  return *(a1 + 196) <= v12;
}

//----- (0805C0A6) --------------------------------------------------------
_BOOL4 __cdecl sub_805C0A6(int a1, int a2, float a3, float a4)
{
  long double v4; // fst7
  int v6; // [esp+24h] [ebp-64h]
  double v7; // [esp+28h] [ebp-60h]
  _BOOL4 v8; // [esp+30h] [ebp-58h]
  float v9; // [esp+34h] [ebp-54h]
  float v10; // [esp+38h] [ebp-50h]
  float v11; // [esp+3Ch] [ebp-4Ch]
  float v12; // [esp+3Ch] [ebp-4Ch]
  float v13[4]; // [esp+40h] [ebp-48h] BYREF
  float v14; // [esp+50h] [ebp-38h]
  float v15; // [esp+54h] [ebp-34h]
  float v16; // [esp+58h] [ebp-30h]
  float v17; // [esp+5Ch] [ebp-2Ch]
  float v18; // [esp+60h] [ebp-28h]
  float v19; // [esp+64h] [ebp-24h]
  float v20; // [esp+68h] [ebp-20h]
  float v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h] BYREF
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]

  v22 = *a1 - *a2;
  v23 = *(a1 + 4) - *(a2 + 4);
  v24 = *(a1 + 8) - *(a2 + 8);
  v17 = (a4 + *(a1 + 248)) * (a4 + *(a1 + 248));
  v19 = v22 * v22 + v23 * v23 - v17;
  if ( v19 > 0.0 )
  {
    v20 = *(a1 + 24) * v22 + *(a1 + 28) * v23;
    if ( v20 < 0.0 )
    {
      v21 = *(a1 + 36);
      v18 = v20 * v20 - v21 * v19;
      if ( v18 >= 0.0 )
      {
        v24 = 0.0;
        v14 = sub_80669A0(&v22, v13);
        v15 = v20 * 0.125 / v14;
        v7 = -v20;
        v4 = sqrt(v18);
        v9 = (v7 - v4) / v21;
        v16 = v9 + v15;
        if ( *(a1 + 196) <= v16 )
        {
          v8 = 1;
        }
        else
        {
          v12 = *(a1 + 252) - *(a1 + 248) + a3;
          v10 = (v16 - v15) * *(a1 + 32) + *(a1 + 8) - *(a2 + 8);
          v6 = 0;
          if ( v10 > v12 || -v12 > v10 )
            v6 = 1;
          v8 = v6;
        }
      }
      else
      {
        v8 = 1;
      }
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v11 = *(a1 + 252) - *(a1 + 248) + a3;
    v8 = v24 > v11 || -v11 > v24;
  }
  return v8;
}

//----- (0805C2CC) --------------------------------------------------------
int __cdecl sub_805C2CC(float *a1)
{
  float v2; // [esp+28h] [ebp-C0h]
  float v4; // [esp+30h] [ebp-B8h]
  float v5[3]; // [esp+40h] [ebp-A8h]
  float v6[2]; // [esp+4Ch] [ebp-9Ch]
  float v7; // [esp+54h] [ebp-94h]
  int v8; // [esp+60h] [ebp-88h] BYREF
  int v9; // [esp+64h] [ebp-84h]
  float v10; // [esp+68h] [ebp-80h]
  int v11[2]; // [esp+70h] [ebp-78h] BYREF
  float v12; // [esp+78h] [ebp-70h]
  int v13[2]; // [esp+80h] [ebp-68h] BYREF
  float v14; // [esp+88h] [ebp-60h]
  int v15[2]; // [esp+90h] [ebp-58h] BYREF
  float v16; // [esp+98h] [ebp-50h]
  int v17[2]; // [esp+A0h] [ebp-48h] BYREF
  float v18; // [esp+A8h] [ebp-40h]
  int v19[2]; // [esp+B0h] [ebp-38h] BYREF
  float v20; // [esp+B8h] [ebp-30h]
  int v21[2]; // [esp+C0h] [ebp-28h] BYREF
  float v22; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( a1[41] > *dword_845996C + 1.0
    || a1[42] > *&dword_8459970 + 1.0
    || a1[43] > *&dword_8459974 + 1.0
    || *dword_8459960 - 1.0 > a1[44]
    || *&dword_8459964 - 1.0 > a1[45]
    || *&dword_8459968 - 1.0 > a1[46] )
  {
    return 0;
  }
  *v17 = *a1 + a1[64];
  *&v17[1] = a1[1] + a1[65];
  v18 = a1[2] + a1[66];
  *v15 = *a1 - a1[64];
  *&v15[1] = a1[1] - a1[65];
  v16 = a1[2] - a1[66];
  *v13 = a1[3] + a1[64];
  *&v13[1] = a1[4] + a1[65];
  v14 = a1[5] + a1[66];
  *v11 = a1[3] - a1[64];
  *&v11[1] = a1[4] - a1[65];
  v12 = a1[5] - a1[66];
  for ( i = 0; i <= 2; ++i )
  {
    *(&v8 + i) = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
    v5[i] = *&dword_8459960[i] - *(&v8 + i);
    v6[i] = *&dword_845996C[i] - *(&v8 + i);
  }
  if ( v6[0] <= v7 )
    v2 = v6[0];
  else
    v2 = v7;
  v4 = v7 - v2;
  v21[0] = v8;
  v21[1] = v9;
  v22 = v10 + v4;
  v19[0] = v8;
  v19[1] = v9;
  v20 = v10 - v4;
  if ( v16 <= v22 )
  {
    if ( v20 > v18 )
    {
      if ( !sub_805BF30(a1, v17, v13, v19, v2) )
        return -1;
      if ( a1[8] <= 0.0 )
        return 0;
    }
  }
  else
  {
    if ( !sub_805BF30(a1, v15, v11, v21, v2) )
      return -1;
    if ( a1[8] >= 0.0 )
      return 0;
  }
  if ( sub_805C0A6(a1, &v8, v4, v2) )
  {
    if ( v12 <= v22 )
    {
      if ( v20 > v14 && v18 >= v20 && !sub_805BF30(a1, v17, v13, v19, v2) )
        return -1;
    }
    else if ( v22 >= v16 && !sub_805BF30(a1, v15, v11, v21, v2) )
    {
      return -1;
    }
    return 0;
  }
  return -1;
}
// 8459960: using guessed type int dword_8459960[];
// 8459964: using guessed type int dword_8459964;
// 8459968: using guessed type int dword_8459968;
// 845996C: using guessed type int dword_845996C[];
// 8459970: using guessed type int dword_8459970;
// 8459974: using guessed type int dword_8459974;

//----- (0805C76A) --------------------------------------------------------
int __cdecl sub_805C76A(int a1)
{
  float v2; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v4[3]; // [esp+20h] [ebp-38h]
  float v5[2]; // [esp+2Ch] [ebp-2Ch]
  float v6; // [esp+34h] [ebp-24h]
  float v7[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v7[i] = (*&dword_8459960[i] + *&dword_845996C[i]) * 0.5;
    v4[i] = *&dword_8459960[i] - v7[i];
    v5[i] = *&dword_845996C[i] - v7[i];
    *(a1 + 4 * i) = *(a1 + 4 * i) - v7[i];
    *(a1 + 4 * i + 12) = *(a1 + 4 * i + 12) - v7[i];
  }
  *(a1 + 244) = 1;
  if ( v5[0] <= v6 )
    v2 = v5[0];
  else
    v2 = v6;
  *(a1 + 248) = v2;
  *(a1 + 252) = v6;
  *(a1 + 256) = 0;
  *(a1 + 260) = 0;
  *(a1 + 264) = v6 - *(a1 + 248);
  *(a1 + 268) = *(a1 + 248);
  *(a1 + 272) = *(a1 + 248);
  *(a1 + 276) = *(a1 + 252);
  sub_804BE53((a1 + 40), (a1 + 52), *dword_845995C, 0);
  return sub_805B67D(a1, dword_845995C);
}
// 845995C: using guessed type int dword_845995C;
// 8459960: using guessed type int dword_8459960[];
// 845996C: using guessed type int dword_845996C[];

//----- (0805C90A) --------------------------------------------------------
int __cdecl sub_805C90A(int *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+24h] [ebp-44h]
  float v9; // [esp+28h] [ebp-40h]
  float v10; // [esp+28h] [ebp-40h]
  int v11; // [esp+2Ch] [ebp-3Ch]
  float v12; // [esp+30h] [ebp-38h] BYREF
  float v13; // [esp+34h] [ebp-34h]
  float v14; // [esp+38h] [ebp-30h]
  float v15; // [esp+40h] [ebp-28h]
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  float v18; // [esp+4Ch] [ebp-1Ch]
  float v19; // [esp+50h] [ebp-18h]
  float v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  if ( a2 < 0 )
    return sub_805BDAD(a1, dword_84598EC + 16 * (-1 - a2));
  v22 = dword_84598E4 + 8 * a2;
  v21 = *v22;
  if ( *(v21 + 16) > 2u )
  {
    v20 = *v21 * *a5 + *(v21 + 4) * a5[1] + *(v21 + 8) * a5[2] - *(v21 + 12);
    v19 = *v21 * *a6 + *(v21 + 4) * a6[1] + *(v21 + 8) * a6[2] - *(v21 + 12);
    if ( a1[48] )
      v18 = 0.0;
    else
      v18 = 2048.0;
  }
  else
  {
    v20 = a5[*(v21 + 16)] - *(v21 + 12);
    v19 = a6[*(v21 + 16)] - *(v21 + 12);
    v18 = *&a1[*(v21 + 16) + 13];
  }
  if ( v20 >= v18 + 1.0 && v19 >= v18 + 1.0 )
    return sub_805C90A(a1, *(v22 + 4), LODWORD(a3), LODWORD(a4), a5, a6);
  if ( -1.0 - v18 > v20 && -1.0 - v18 > v19 )
    return sub_805C90A(a1, *(v22 + 6), LODWORD(a3), LODWORD(a4), a5, a6);
  if ( v19 <= v20 )
  {
    if ( v20 <= v19 )
    {
      v11 = 0;
      v17 = 1.0;
      v16 = 0.0;
    }
    else
    {
      v15 = 1.0 / (v20 - v19);
      v11 = 0;
      v16 = (v20 - v18 - 0.125) * v15;
      v17 = (v20 + v18 + 0.125) * v15;
    }
  }
  else
  {
    v15 = 1.0 / (v20 - v19);
    v11 = 1;
    v16 = (v20 + v18 + 0.125) * v15;
    v17 = (v20 - v18 + 0.125) * v15;
  }
  if ( v17 < 0.0 )
    v17 = 0.0;
  if ( v17 > 1.0 )
    v17 = 1.0;
  v9 = (a4 - a3) * v17 + a3;
  v12 = (*a6 - *a5) * v17 + *a5;
  v13 = (a6[1] - a5[1]) * v17 + a5[1];
  v14 = (a6[2] - a5[2]) * v17 + a5[2];
  v8 = sub_805C90A(a1, *(v22 + 2 * v11 + 4), LODWORD(a3), LODWORD(v9), a5, &v12);
  if ( v8 )
    return v8;
  if ( v16 < 0.0 )
    v16 = 0.0;
  if ( v16 > 1.0 )
    v16 = 1.0;
  v10 = (a4 - a3) * v16 + a3;
  v12 = (*a6 - *a5) * v16 + *a5;
  v13 = (a6[1] - a5[1]) * v16 + a5[1];
  v14 = (a6[2] - a5[2]) * v16 + a5[2];
  return sub_805C90A(a1, *(v22 + 2 * (v11 ^ 1) + 4), LODWORD(v10), LODWORD(a4), &v12, a6);
}
// 84598E4: using guessed type int dword_84598E4;
// 84598EC: using guessed type int dword_84598EC;

//----- (0805CD62) --------------------------------------------------------
int __cdecl sub_805CD62(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ebx
  long double v11; // fst7
  float v13; // [esp+20h] [ebp-158h]
  float v14; // [esp+24h] [ebp-154h]
  float v15; // [esp+24h] [ebp-154h]
  float v16; // [esp+24h] [ebp-154h]
  int v17; // [esp+28h] [ebp-150h]
  int *v18; // [esp+2Ch] [ebp-14Ch]
  float v19[4]; // [esp+30h] [ebp-148h]
  float s[3]; // [esp+40h] [ebp-138h] BYREF
  float v21[3]; // [esp+4Ch] [ebp-12Ch] BYREF
  float v22; // [esp+58h] [ebp-120h]
  float v23; // [esp+5Ch] [ebp-11Ch]
  float v24; // [esp+60h] [ebp-118h]
  float v25; // [esp+64h] [ebp-114h]
  int v26; // [esp+68h] [ebp-110h]
  int v27; // [esp+6Ch] [ebp-10Ch]
  int v28; // [esp+70h] [ebp-108h]
  int v29; // [esp+74h] [ebp-104h]
  int v30; // [esp+78h] [ebp-100h]
  int v31; // [esp+7Ch] [ebp-FCh]
  int v32; // [esp+80h] [ebp-F8h]
  int v33; // [esp+84h] [ebp-F4h]
  int v34; // [esp+88h] [ebp-F0h]
  int v35; // [esp+8Ch] [ebp-ECh]
  int v36; // [esp+90h] [ebp-E8h]
  int v37; // [esp+94h] [ebp-E4h]
  int v38; // [esp+98h] [ebp-E0h]
  int v39; // [esp+9Ch] [ebp-DCh]
  int v40; // [esp+A0h] [ebp-D8h]
  int v41; // [esp+A4h] [ebp-D4h]
  int v42; // [esp+A8h] [ebp-D0h]
  int v43; // [esp+ACh] [ebp-CCh]
  int v44; // [esp+B0h] [ebp-C8h]
  int v45; // [esp+B4h] [ebp-C4h]
  int v46; // [esp+B8h] [ebp-C0h]
  int v47; // [esp+BCh] [ebp-BCh]
  int v48; // [esp+C0h] [ebp-B8h]
  int v49; // [esp+C4h] [ebp-B4h]
  float v50; // [esp+C8h] [ebp-B0h]
  int v51; // [esp+CCh] [ebp-ACh]
  int v52; // [esp+D0h] [ebp-A8h]
  float v53; // [esp+D4h] [ebp-A4h]
  float v54; // [esp+D8h] [ebp-A0h]
  int v55; // [esp+DCh] [ebp-9Ch]
  float v56; // [esp+E0h] [ebp-98h]
  float v57[6]; // [esp+E4h] [ebp-94h]
  int v58; // [esp+FCh] [ebp-7Ch]
  _BOOL4 v59; // [esp+100h] [ebp-78h]
  int v60; // [esp+104h] [ebp-74h]
  int v61; // [esp+134h] [ebp-44h]
  float v62; // [esp+138h] [ebp-40h]
  float v63; // [esp+13Ch] [ebp-3Ch]
  float v64; // [esp+140h] [ebp-38h]
  int v65; // [esp+144h] [ebp-34h]
  float v66; // [esp+148h] [ebp-30h]
  int v67[8]; // [esp+14Ch] [ebp-2Ch]
  int i; // [esp+16Ch] [ebp-Ch]
  int v69; // [esp+180h] [ebp+8h]
  int v70; // [esp+180h] [ebp+8h]

  v18 = sub_804BC58(a6);
  ++dword_8459940;
  sub_80C837D(s, 0, 0x118u);
  v60 = 1065353216;
  if ( !a4 )
    a4 = &dword_80DD708;
  if ( !a5 )
    a5 = &dword_80DD708;
  v58 = a8;
  for ( i = 0; i <= 2; ++i )
  {
    v19[i] = (*&a4[i] + *&a5[i]) * 0.5;
    *(&v26 + i) = *&a4[i] - v19[i];
    *(&v29 + i) = *&a5[i] - v19[i];
    s[i] = *(a2 + 4 * i) + v19[i];
    v21[i] = *(a3 + 4 * i) + v19[i];
    *(&v22 + i) = v21[i] - s[i];
  }
  v25 = v22 * v22 + v23 * v23 + v24 * v24;
  if ( a10 )
  {
    v61 = *a10;
    v62 = *(a10 + 4);
    v63 = *(a10 + 8);
    v64 = *(a10 + 12);
    v65 = *(a10 + 16);
    v66 = *(a10 + 20);
    v67[0] = *(a10 + 24);
    v67[1] = *(a10 + 28);
    v67[2] = *(a10 + 32);
  }
  else
  {
    v61 = a9;
    if ( *&v29 <= *&v31 )
      v13 = *&v29;
    else
      v13 = *&v31;
    v62 = v13;
    v63 = *&v31;
    v64 = 0.0;
    v65 = 0;
    v66 = *&v31 - v13;
  }
  v56 = *&v29 + *&v30 + *&v31;
  v32 = v26;
  v33 = v27;
  v34 = v28;
  v35 = v29;
  v36 = v27;
  v37 = v28;
  v38 = v26;
  v39 = v30;
  v40 = v28;
  v41 = v29;
  v42 = v30;
  v43 = v28;
  v44 = v26;
  v45 = v27;
  v46 = v31;
  v47 = v29;
  v48 = v27;
  v49 = v31;
  v50 = *&v26;
  v51 = v30;
  v52 = v31;
  v53 = *&v29;
  v54 = *&v30;
  v55 = v31;
  if ( v61 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v14 = fabs(*(&v64 + i));
      if ( v21[i] <= s[i] )
      {
        v57[i] = v21[i] - v14 - v62;
        v16 = fabs(*(&v64 + i));
        v57[i + 3] = v16 + s[i] + v62;
      }
      else
      {
        v57[i] = s[i] - v14 - v62;
        v15 = fabs(*(&v64 + i));
        v57[i + 3] = v15 + v21[i] + v62;
      }
    }
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( v21[i] <= s[i] )
      {
        v57[i] = v21[i] + *(&v26 + i);
        v57[i + 3] = s[i] + *(&v29 + i);
      }
      else
      {
        v57[i] = s[i] + *(&v26 + i);
        v57[i + 3] = v21[i] + *(&v29 + i);
      }
    }
  }
  v59 = 0.0 == *&v29 + *&v30 + *&v31;
  if ( v61 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v10 = i;
      v11 = sub_805D7EC(*(&v64 + i));
      *&v67[v10] = v11 + v62;
    }
  }
  if ( a6 )
  {
    if ( a6 == 510 )
    {
      if ( (v58 & *dword_845995C) != 0 )
      {
        if ( v61 )
          v17 = sub_805C2CC(s);
        else
          v17 = sub_805C76A(s);
      }
      else
      {
        v17 = 0;
      }
    }
    else
    {
      v17 = sub_805BDAD(s, (v18 + 6));
    }
  }
  else
  {
    v17 = 0;
    if ( a1 > 0 )
    {
      v69 = a1 - 1;
      if ( v69 >= dword_8459908 )
      {
        v70 = v69 - dword_8459908;
        if ( v70 < dword_8459934 )
          v17 = sub_805B60B(s, dword_8459938 + 44 * v70);
      }
      else
      {
        v17 = sub_805B67D(s, dword_845990C + 52 * v69);
      }
    }
    if ( !v17 )
      v17 = sub_805C90A(s, 0, 0.0, 1.0, s, v21);
  }
  return v17;
}
// 80DD708: using guessed type int dword_80DD708;
// 8459908: using guessed type int dword_8459908;
// 845990C: using guessed type int dword_845990C;
// 8459934: using guessed type int dword_8459934;
// 8459938: using guessed type int dword_8459938;
// 8459940: using guessed type int dword_8459940;
// 845995C: using guessed type int dword_845995C;

//----- (0805D459) --------------------------------------------------------
int __cdecl sub_805D459(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8)
{
  return sub_805CD62(a1, a2, a3, a4, a5, a6, &dword_80DD708, a7, a8, 0);
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0805D4AD) --------------------------------------------------------
int __cdecl sub_805D4AD(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  int v11; // [esp+4Ch] [ebp-DCh]
  int v12[3]; // [esp+50h] [ebp-D8h] BYREF
  float v13; // [esp+5Ch] [ebp-CCh]
  float v14; // [esp+60h] [ebp-C8h]
  float v15; // [esp+64h] [ebp-C4h]
  float v16; // [esp+80h] [ebp-A8h]
  int v17; // [esp+84h] [ebp-A4h]
  int v18; // [esp+88h] [ebp-A0h]
  int i; // [esp+8Ch] [ebp-9Ch]
  float v20[12]; // [esp+90h] [ebp-98h] BYREF
  int v21[3]; // [esp+C0h] [ebp-68h] BYREF
  float v22[2]; // [esp+CCh] [ebp-5Ch] BYREF
  float v23; // [esp+D4h] [ebp-54h]
  float v24[7]; // [esp+E0h] [ebp-48h]
  _BOOL4 v25; // [esp+FCh] [ebp-2Ch]
  float v26; // [esp+100h] [ebp-28h] BYREF
  float v27; // [esp+104h] [ebp-24h]
  float v28; // [esp+108h] [ebp-20h]
  float v29; // [esp+110h] [ebp-18h] BYREF
  float v30; // [esp+114h] [ebp-14h]
  float v31; // [esp+118h] [ebp-10h]

  if ( !a4 )
    a4 = &dword_80DD708;
  if ( !a5 )
    a5 = &dword_80DD708;
  for ( i = 0; i <= 2; ++i )
  {
    v24[i] = (*&a4[i] + *&a5[i]) * 0.5;
    *&v21[i] = *&a4[i] - v24[i];
    v22[i] = *&a5[i] - v24[i];
    *(&v29 + i) = *(a2 + 4 * i) + v24[i];
    *(&v26 + i) = *(a3 + 4 * i) + v24[i];
  }
  v29 = v29 - *a8;
  v30 = v30 - a8[1];
  v31 = v31 - a8[2];
  v26 = v26 - *a8;
  v27 = v27 - a8[1];
  v28 = v28 - a8[2];
  v25 = a6 != 511 && (*a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0);
  v18 = SLODWORD(v22[0]);
  *&v17 = v23;
  v12[0] = a10;
  if ( v22[0] <= v23 )
    v11 = v18;
  else
    v11 = v17;
  v12[1] = v11;
  v12[2] = v17;
  v16 = *&v17 - *&v11;
  if ( v25 )
  {
    sub_8057C2A(a9, v20);
    sub_8057B18(&v29, v20);
    sub_8057B18(&v26, v20);
    v13 = v20[2] * v16;
    v14 = -v20[5] * v16;
    v15 = v20[8] * v16;
  }
  else
  {
    v13 = 0.0;
    v14 = 0.0;
    v15 = v16;
  }
  return sub_805CD62(a1, &v29, &v26, v21, v22, a6, a8, a7, a10, v12);
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0805D7EC) --------------------------------------------------------
long double __cdecl sub_805D7EC(float a1)
{
  return fabs(a1);
}

//----- (0805D808) --------------------------------------------------------
int __cdecl sub_805D808(float *a1, float *a2)
{
  _BOOL4 v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  float v6; // [esp+10h] [ebp-10h]
  float v7; // [esp+14h] [ebp-Ch]

  v5 = dword_84599B0;
  if ( !dword_84599B0 )
    return 0;
  v6 = *a2 - *a1;
  v7 = a2[1] - a1[1];
  v4 = v7 >= v6;
  if ( *(&v6 + v4) <= 512.0 )
    return 0;
  dword_84599B0 = *(dword_84599B0 + 28);
  *v5 = v4;
  *(v5 + 16) = (a2[v4] + a1[v4]) * 0.5;
  *(v5 + 32) = &unk_84599B4;
  *(v5 + 36) = &unk_84599B4;
  return v5;
}
// 84599B0: using guessed type int dword_84599B0;

//----- (0805D8E6) --------------------------------------------------------
__int64 sub_805D8E6()
{
  __int64 result; // rax
  float v1; // [esp+18h] [ebp-10h]
  float v2; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v4 = sub_804BD20(0);
  sub_804BF33(v4, flt_8459944, flt_8459950);
  dword_84599B0 = &unk_84599DC;
  for ( i = 0; i <= 0x3FE; ++i )
    dword_84599F8[10 * i] = 40 * i + 138779140;
  dword_84639D0 = 0;
  v1 = flt_8459950[0] - flt_8459944[0];
  v2 = flt_8459954 - flt_8459948;
  dword_8459988 = v2 >= v1;
  LODWORD(result) = dword_8459988;
  HIDWORD(result) = dword_8459988;
  flt_8459998 = (flt_8459950[dword_8459988] + flt_8459944[dword_8459988]) * 0.5;
  dword_84599A8 = &unk_84599B4;
  dword_84599AC = &unk_84599B4;
  return result;
}
// 8459944: using guessed type float flt_8459944[];
// 8459948: using guessed type float flt_8459948;
// 8459950: using guessed type float flt_8459950[];
// 8459954: using guessed type float flt_8459954;
// 8459988: using guessed type int dword_8459988;
// 8459998: using guessed type float flt_8459998;
// 84599A8: using guessed type int dword_84599A8;
// 84599AC: using guessed type int dword_84599AC;
// 84599B0: using guessed type int dword_84599B0;
// 84639D0: using guessed type int dword_84639D0;

//----- (0805D9DF) --------------------------------------------------------
int __cdecl sub_805D9DF(int *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  result = *a1;
  v3 = *a1;
  if ( *a1 )
  {
    *a1 = 0;
    if ( *(v3 + 20) == a1 )
    {
      *(v3 + 20) = a1[1];
    }
    else
    {
      for ( i = *(v3 + 20); *(i + 4) != a1; i = *(i + 4) )
        ;
      *(i + 4) = a1[1];
    }
    while ( 1 )
    {
      result = v3;
      if ( *(v3 + 20) )
        break;
      result = v3;
      if ( *(v3 + 24) )
        break;
      result = v3;
      if ( *(v3 + 32) != &unk_84599B4 )
        break;
      result = v3;
      if ( *(v3 + 36) != &unk_84599B4 )
        break;
      *(v3 + 12) = 0;
      result = *(v3 + 28);
      if ( !result )
        break;
      *(v3 + 28) = dword_84599B0;
      dword_84599B0 = v3;
      if ( *(result + 32) == v3 )
        *(result + 32) = &unk_84599B4;
      else
        *(result + 36) = &unk_84599B4;
      v3 = result;
    }
    while ( v3 )
    {
      v2 = *(*(v3 + 32) + 12) | *(*(v3 + 36) + 12);
      for ( j = *(v3 + 20); j; j = *(j + 4) )
        v2 |= *(sub_808E16C(j) + 288);
      *(v3 + 12) = v2;
      result = *(v3 + 28);
      v3 = result;
    }
  }
  return result;
}
// 84599B0: using guessed type int dword_84599B0;

//----- (0805DB34) --------------------------------------------------------
int __cdecl sub_805DB34(float *a1, float *a2, float *a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-2Ch]
  int v5; // [esp+Ch] [ebp-2Ch]
  int *v6; // [esp+10h] [ebp-28h]
  int *v7; // [esp+14h] [ebp-24h]
  int *v8; // [esp+18h] [ebp-20h]
  int *v9; // [esp+1Ch] [ebp-1Ch]
  float v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  int *v12; // [esp+28h] [ebp-10h]
  int *i; // [esp+2Ch] [ebp-Ch]

  v11 = *a1;
  v10 = a1[4];
  v9 = 0;
  for ( i = *(a1 + 5); ; i = i[1] )
  {
    while ( 1 )
    {
      if ( !i )
      {
        v8 = 0;
        result = *(a1 + 6);
        v12 = result;
        while ( 1 )
        {
          if ( !v12 )
            return result;
          if ( *&v12[LODWORD(v11) + 14] > v10 )
            break;
          if ( v10 <= *&v12[LODWORD(v11) + 17] )
          {
            v8 = v12;
            result = v12[13];
            v12 = result;
          }
          else
          {
            v5 = *(a1 + 9);
            if ( v5 == &unk_84599B4 )
            {
              result = sub_805D808(a2, a3);
              v5 = result;
              if ( !result )
                return result;
              *(a1 + 9) = result;
              *(result + 28) = a1;
            }
LABEL_27:
            v6 = v12[13];
            v12[13] = *(v5 + 24);
            *(v5 + 24) = v12;
            *(v5 + 4) |= sub_80C4334(*v12);
            if ( v12[20] )
              *(v5 + 8) |= sub_80C4334(*v12);
            if ( v8 )
              v8[13] = v6;
            else
              *(a1 + 6) = v6;
            result = v6;
            v12 = v6;
          }
        }
        v5 = *(a1 + 8);
        if ( v5 == &unk_84599B4 )
        {
          result = sub_805D808(a2, a3);
          v5 = result;
          if ( !result )
            return result;
          *(a1 + 8) = result;
          *(result + 28) = a1;
        }
        goto LABEL_27;
      }
      if ( *&i[LODWORD(v11) + 92] <= v10 )
        break;
      v4 = *(a1 + 8);
      if ( v4 == &unk_84599B4 )
      {
        result = sub_805D808(a2, a3);
        v4 = result;
        if ( !result )
          return result;
        *(a1 + 8) = result;
        *(result + 28) = a1;
      }
LABEL_12:
      v7 = i[1];
      *i = v4;
      i[1] = *(v4 + 20);
      *(v4 + 20) = i;
      *(v4 + 12) |= *(sub_808E16C(i) + 288);
      if ( v9 )
        v9[1] = v7;
      else
        *(a1 + 5) = v7;
      i = v7;
    }
    if ( v10 > *&i[LODWORD(v11) + 94] )
      break;
    v9 = i;
  }
  v4 = *(a1 + 9);
  if ( v4 != &unk_84599B4 )
    goto LABEL_12;
  result = sub_805D808(a2, a3);
  v4 = result;
  if ( result )
  {
    *(a1 + 9) = result;
    *(result + 28) = a1;
    goto LABEL_12;
  }
  return result;
}

//----- (0805DE1A) --------------------------------------------------------
int __cdecl sub_805DE1A(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4[2]; // [esp+18h] [ebp-20h] BYREF
  int v5[2]; // [esp+20h] [ebp-18h] BYREF
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  float *i; // [esp+34h] [ebp-4h]

  v6 = *(sub_808E16C(a1) + 288);
  while ( 1 )
  {
    *v5 = flt_8459944[0];
    *&v5[1] = flt_8459948;
    *v4 = flt_8459950[0];
    *&v4[1] = flt_8459954;
    for ( i = &dword_8459988; ; i = *(i + 9) )
    {
      while ( 1 )
      {
        *(i + 3) |= v6;
        v8 = *i;
        v7 = *(i + 4);
        if ( *&a2[v8] <= *&v7 )
          break;
        v5[v8] = v7;
        if ( *(i + 8) == &unk_84599B4 )
          goto LABEL_12;
        i = *(i + 8);
      }
      if ( *&v7 <= *&a3[v8] )
        break;
      v4[v8] = v7;
      if ( *(i + 9) == &unk_84599B4 )
        goto LABEL_12;
    }
    if ( i == *a1 && (*(a1 + 364) & ~v6) == 0 )
    {
      *(a1 + 364) = v6;
      *(a1 + 368) = *a2;
      *(a1 + 372) = a2[1];
      *(a1 + 376) = *a3;
      result = a3[1];
      *(a1 + 380) = result;
      return result;
    }
LABEL_12:
    if ( !*a1 )
      break;
    if ( i == *a1 && (*(a1 + 364) & ~v6) == 0 )
      goto LABEL_17;
    sub_805D9DF(a1);
  }
  *a1 = i;
  *(a1 + 4) = i[5];
  *(i + 5) = a1;
LABEL_17:
  *(a1 + 364) = v6;
  *(a1 + 368) = *a2;
  *(a1 + 372) = a2[1];
  *(a1 + 376) = *a3;
  *(a1 + 380) = a3[1];
  return sub_805DB34(i, v5, v4);
}
// 8459944: using guessed type float flt_8459944[];
// 8459948: using guessed type float flt_8459948;
// 8459950: using guessed type float flt_8459950[];
// 8459954: using guessed type float flt_8459954;
// 8459988: using guessed type int dword_8459988;

//----- (0805E021) --------------------------------------------------------
int sub_805E021()
{
  return 0;
}

//----- (0805E02B) --------------------------------------------------------
int __cdecl sub_805E02B(int a1)
{
  int v2[2]; // [esp+10h] [ebp-28h] BYREF
  int v3[2]; // [esp+18h] [ebp-20h] BYREF
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  float *i; // [esp+2Ch] [ebp-Ch]

  *(a1 + 80) = sub_805E021();
  v4 = sub_80C4334(*a1);
  *v3 = flt_8459944;
  *&v3[1] = flt_8459948;
  *v2 = flt_8459950;
  *&v2[1] = flt_8459954;
  for ( i = &dword_8459988; ; i = *(i + 9) )
  {
    while ( 1 )
    {
      *(i + 1) |= v4;
      if ( *(a1 + 80) )
        *(i + 2) |= v4;
      v6 = *i;
      v5 = *(i + 4);
      if ( *(a1 + 4 * v6 + 56) <= *&v5 )
        break;
      v3[v6] = v5;
      if ( *(i + 8) == &unk_84599B4 )
        goto LABEL_10;
      i = *(i + 8);
    }
    if ( *&v5 <= *(a1 + 4 * v6 + 68) )
      break;
    v2[v6] = v5;
    if ( *(i + 9) == &unk_84599B4 )
      break;
  }
LABEL_10:
  *(a1 + 52) = i[6];
  *(i + 6) = a1;
  return sub_805DB34(i, v3, v2);
}
// 8459944: using guessed type float flt_8459944;
// 8459948: using guessed type float flt_8459948;
// 8459950: using guessed type float flt_8459950;
// 8459954: using guessed type float flt_8459954;
// 8459988: using guessed type int dword_8459988;

//----- (0805E166) --------------------------------------------------------
void __cdecl sub_805E166(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( (*(a1 + 12) & *(a2 + 24)) != 0 )
  {
    for ( i = *(a1 + 20); i; i = *(i + 4) )
    {
      v2 = sub_808E16C(i);
      if ( (*(v2 + 288) & *(a2 + 24)) != 0
        && *(v2 + 292) <= **(a2 + 8)
        && **(a2 + 4) <= *(v2 + 304)
        && *(v2 + 296) <= *(*(a2 + 8) + 4)
        && *(*(a2 + 4) + 4) <= *(v2 + 308)
        && *(v2 + 300) <= *(*(a2 + 8) + 8)
        && *(*(a2 + 4) + 8) <= *(v2 + 312) )
      {
        if ( *(a2 + 16) == *(a2 + 20) )
        {
          Com_DPrintf("CM_AreaEntities: MAXCOUNT\n");
          return;
        }
        *(*(a2 + 12) + 4 * (*(a2 + 16))++) = -1431655765 * ((i + -&dword_8494A80 - 9240) >> 7);
      }
    }
    if ( *(*(a2 + 8) + 4 * *a1) > *(a1 + 16) )
      sub_805E166(*(a1 + 32), a2);
    if ( *(a1 + 16) > *(*(a2 + 4) + 4 * *a1) )
      sub_805E166(*(a1 + 36), a2);
  }
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0805E344) --------------------------------------------------------
int __cdecl sub_805E344(int a1, int a2, int a3, int a4, int a5)
{
  char v6[4]; // [esp+10h] [ebp-28h] BYREF
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = 0;
  v11 = a4;
  v12 = a5;
  sub_805E166(&dword_8459988, v6);
  return v10;
}
// 8459988: using guessed type int dword_8459988;

//----- (0805E387) --------------------------------------------------------
int __cdecl sub_805E387(int a1, int a2, int a3, int a4, float a5)
{
  float v8; // [esp+8h] [ebp-20h]
  float v9; // [esp+8h] [ebp-20h]
  int i; // [esp+Ch] [ebp-1Ch]
  float v11; // [esp+10h] [ebp-18h]
  float v12; // [esp+14h] [ebp-14h]
  float v13; // [esp+18h] [ebp-10h]
  float v15; // [esp+20h] [ebp-8h]

  v15 = 0.0;
  v13 = -1.0;
  while ( 1 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v12 = (*(a1 + 4 * i) - *(a3 + 4 * i)) * v13;
      v11 = (*(a2 + 4 * i) - *(a3 + 4 * i)) * v13;
      if ( v12 <= 0.0 )
      {
        if ( v11 > 0.0 )
        {
          v9 = v12 - v11;
          if ( v12 > a5 * v9 )
          {
            a5 = v12 / v9;
            if ( v15 >= a5 )
              return 1;
          }
        }
      }
      else
      {
        if ( v11 > 0.0 )
          return 1;
        v8 = v12 - v11;
        if ( v12 > v15 * v8 )
        {
          v15 = v12 / v8;
          if ( v15 >= a5 )
            return 1;
        }
      }
    }
    if ( v13 == 1.0 )
      break;
    v13 = 1.0;
    a3 = a4;
  }
  return 0;
}

//----- (0805E4FD) --------------------------------------------------------
void __cdecl sub_805E4FD(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int *i; // [esp+2Ch] [ebp-3Ch]
  int v7[7]; // [esp+30h] [ebp-38h] BYREF
  float v8; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( a3 < *a1 && (*(a2 + 4) & *(a1 + 48)) != 0 )
  {
    v12 = *(a5 + 4 * *a2) - *(a2 + 16);
    v11 = *(a6 + 4 * *a2) - *(a2 + 16);
    if ( v12 < 0.0 || v11 < 0.0 )
    {
      if ( v12 > 0.0 || v11 > 0.0 )
      {
        v10 = v12 / (v12 - v11);
        v8 = (*&a4 - a3) * v10 + a3;
        *v7 = (*a6 - *a5) * v10 + *a5;
        *&v7[1] = (*(a6 + 4) - *(a5 + 4)) * v10 + *(a5 + 4);
        *&v7[2] = (*(a6 + 8) - *(a5 + 8)) * v10 + *(a5 + 8);
        v9 = v12 < 0.0;
        sub_805E4FD(a1, *(a2 + 4 * v9 + 32), a3, SLODWORD(v8), a5, v7);
        sub_805E4FD(a1, *(a2 + 4 * (1 - v9) + 32), v8, a4, v7, a6);
      }
      else
      {
        sub_805E4FD(a1, *(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805E4FD(a1, *(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(a2 + 24); i; i = i[13] )
    {
      if ( (*(a1 + 48) & sub_80C4334(*i)) != 0 && !sub_805E387(a1 + 52, a1 + 64, (i + 14), (i + 17), *a1) )
        sub_8053D9B(i, a1, (a1 + 52), (a1 + 64), *(a1 + 48));
    }
  }
}

//----- (0805E7AF) --------------------------------------------------------
void __cdecl sub_805E7AF(int *a1, int *a2, int *a3, int a4)
{
  float v4; // [esp+20h] [ebp-68h]
  float v5; // [esp+24h] [ebp-64h]
  float v6; // [esp+28h] [ebp-60h]
  int s[13]; // [esp+30h] [ebp-58h] BYREF
  int v8[3]; // [esp+64h] [ebp-24h] BYREF
  int v9[6]; // [esp+70h] [ebp-18h] BYREF

  memset(s, 0, 0x30u);
  s[0] = *a1;
  s[12] = a4;
  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v9[0] = *a3;
  v9[1] = a3[1];
  v9[2] = a3[2];
  sub_805E4FD(s, &dword_8459988, 0.0, s[0], v8, v9);
  if ( *a1 > *s )
  {
    v4 = *a3 - *a2;
    v5 = *(a3 + 1) - *(a2 + 1);
    v6 = *(a3 + 2) - *(a2 + 2);
    *&s[1] = v4 * *s + *a2;
    *&s[2] = v5 * *s + *(a2 + 1);
    *&s[3] = v6 * *s + *(a2 + 2);
    qmemcpy(a1, s, 0x30u);
  }
}
// 8459988: using guessed type int dword_8459988;

//----- (0805E8E5) --------------------------------------------------------
void __cdecl sub_805E8E5(int a1, int a2, float a3, int a4, int a5, int a6)
{
  float v6; // [esp+34h] [ebp-44h]
  float v7; // [esp+34h] [ebp-44h]
  float v8; // [esp+38h] [ebp-40h]
  int i; // [esp+3Ch] [ebp-3Ch]
  int v10; // [esp+40h] [ebp-38h] BYREF
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+58h] [ebp-20h]
  int v14; // [esp+5Ch] [ebp-1Ch]
  float v15; // [esp+60h] [ebp-18h]
  float v16; // [esp+64h] [ebp-14h]
  float v17; // [esp+68h] [ebp-10h]
  float v18; // [esp+6Ch] [ebp-Ch]

  if ( a3 < *(a1 + 60) && (*(a2 + 12) & *(a1 + 116)) != 0 )
  {
    v18 = *(a5 + 4 * *a2) - *(a2 + 16);
    v17 = *(a6 + 4 * *a2) - *(a2 + 16);
    v8 = *(a1 + 4 * *a2 + 24);
    if ( v18 < v8 || v17 < v8 )
    {
      if ( -v8 < v18 || -v8 < v17 )
      {
        if ( v17 <= v18 )
        {
          if ( v18 <= v17 )
          {
            v14 = 0;
            v16 = 1.0;
            v15 = 0.0;
          }
          else
          {
            v7 = 1.0 / (v18 - v17);
            v14 = 0;
            v15 = (v18 - v8) * v7;
            v16 = (v18 + v8) * v7;
          }
        }
        else
        {
          v6 = 1.0 / (v18 - v17);
          v14 = 1;
          v15 = (v18 + v8) * v6;
          v16 = (v18 - v8) * v6;
        }
        if ( v16 > 1.0 )
          v16 = 1.0;
        v13 = (*&a4 - a3) * v16 + a3;
        *&v10 = (*a6 - *a5) * v16 + *a5;
        v11 = (*(a6 + 4) - *(a5 + 4)) * v16 + *(a5 + 4);
        v12 = (*(a6 + 8) - *(a5 + 8)) * v16 + *(a5 + 8);
        sub_805E8E5(a1, *(a2 + 4 * v14 + 32), a3, SLODWORD(v13), a5, &v10);
        if ( v15 < 0.0 )
          v15 = 0.0;
        v13 = (*&a4 - a3) * v15 + a3;
        *&v10 = (*a6 - *a5) * v15 + *a5;
        v11 = (*(a6 + 4) - *(a5 + 4)) * v15 + *(a5 + 4);
        v12 = (*(a6 + 8) - *(a5 + 8)) * v15 + *(a5 + 8);
        sub_805E8E5(a1, *(a2 + 4 * (1 - v14) + 32), v13, a4, &v10, a6);
      }
      else
      {
        sub_805E8E5(a1, *(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805E8E5(a1, *(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(a2 + 20); i; i = *(i + 4) )
      sub_809A594(a1, i);
  }
}

//----- (0805EC45) --------------------------------------------------------
void __cdecl sub_805EC45(int a1)
{
  sub_805E8E5(a1, &dword_8459988, 0.0, *(a1 + 60), a1 + 36, a1 + 48);
}
// 8459988: using guessed type int dword_8459988;

//----- (0805EC86) --------------------------------------------------------
int __cdecl sub_805EC86(int *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+40h] [ebp-48h]
  int v9; // [esp+40h] [ebp-48h]
  int v10; // [esp+40h] [ebp-48h]
  int v11; // [esp+40h] [ebp-48h]
  int v12; // [esp+40h] [ebp-48h]
  float v13; // [esp+44h] [ebp-44h]
  float v14; // [esp+44h] [ebp-44h]
  float v15; // [esp+48h] [ebp-40h]
  int i; // [esp+4Ch] [ebp-3Ch]
  float v17; // [esp+50h] [ebp-38h] BYREF
  float v18; // [esp+54h] [ebp-34h]
  float v19; // [esp+58h] [ebp-30h]
  float v20; // [esp+68h] [ebp-20h]
  int v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h]
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]
  float v25; // [esp+7Ch] [ebp-Ch]

  if ( (*(a2 + 12) & a1[19]) == 0 )
    return 0;
  v25 = a5[*a2] - *(a2 + 16);
  v24 = a6[*a2] - *(a2 + 16);
  v15 = *&a1[*a2 + 6];
  if ( v25 < v15 || v24 < v15 )
  {
    if ( -v15 < v25 || -v15 < v24 )
    {
      if ( v24 <= v25 )
      {
        if ( v25 <= v24 )
        {
          v21 = 0;
          v23 = 1.0;
          v22 = 0.0;
        }
        else
        {
          v14 = 1.0 / (v25 - v24);
          v21 = 0;
          v22 = (v25 - v15) * v14;
          v23 = (v25 + v15) * v14;
        }
      }
      else
      {
        v13 = 1.0 / (v25 - v24);
        v21 = 1;
        v22 = (v25 + v15) * v13;
        v23 = (v25 - v15) * v13;
      }
      if ( v23 > 1.0 )
        v23 = 1.0;
      v20 = (a4 - a3) * v23 + a3;
      v17 = (*a6 - *a5) * v23 + *a5;
      v18 = (a6[1] - a5[1]) * v23 + a5[1];
      v19 = (a6[2] - a5[2]) * v23 + a5[2];
      v10 = sub_805EC86(a1, *(a2 + 4 * v21 + 32), LODWORD(a3), LODWORD(v20), a5, &v17);
      if ( v10 )
        return v10;
      if ( v22 < 0.0 )
        v22 = 0.0;
      v20 = (a4 - a3) * v22 + a3;
      v17 = (*a6 - *a5) * v22 + *a5;
      v18 = (a6[1] - a5[1]) * v22 + a5[1];
      v19 = (a6[2] - a5[2]) * v22 + a5[2];
      v11 = sub_805EC86(a1, *(a2 + 4 * (1 - v21) + 32), LODWORD(v20), LODWORD(a4), &v17, a6);
      if ( v11 )
        return v11;
    }
    else
    {
      v9 = sub_805EC86(a1, *(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6);
      if ( v9 )
        return v9;
    }
  }
  else
  {
    v8 = sub_805EC86(a1, *(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6);
    if ( v8 )
      return v8;
  }
  for ( i = *(a2 + 20); i; i = *(i + 4) )
  {
    v12 = sub_809AC6D(a1, i);
    if ( v12 )
      return v12;
  }
  return 0;
}

//----- (0805F042) --------------------------------------------------------
int __cdecl sub_805F042(int a1)
{
  return sub_805EC86(a1, &dword_8459988, 0.0, 1.0, (a1 + 36), (a1 + 48));
}
// 8459988: using guessed type int dword_8459988;

//----- (0805F087) --------------------------------------------------------
void __cdecl sub_805F087(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int i; // [esp+2Ch] [ebp-3Ch]
  int v7[7]; // [esp+30h] [ebp-38h] BYREF
  float v8; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( a3 < *(a1 + 24) && (*(a2 + 12) & *(a1 + 80)) != 0 )
  {
    v12 = *(a5 + 4 * *a2) - *(a2 + 16);
    v11 = *(a6 + 4 * *a2) - *(a2 + 16);
    if ( v12 < 0.0 || v11 < 0.0 )
    {
      if ( v12 > 0.0 || v11 > 0.0 )
      {
        v10 = v12 / (v12 - v11);
        v8 = (*&a4 - a3) * v10 + a3;
        *v7 = (*a6 - *a5) * v10 + *a5;
        *&v7[1] = (*(a6 + 4) - *(a5 + 4)) * v10 + *(a5 + 4);
        *&v7[2] = (*(a6 + 8) - *(a5 + 8)) * v10 + *(a5 + 8);
        v9 = v12 < 0.0;
        sub_805F087(a1, *(a2 + 4 * v9 + 32), a3, SLODWORD(v8), a5, v7);
        sub_805F087(a1, *(a2 + 4 * (1 - v9) + 32), v8, a4, v7, a6);
      }
      else
      {
        sub_805F087(a1, *(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805F087(a1, *(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(a2 + 20); i; i = *(i + 4) )
      sub_809A72A(a1, i);
  }
}

//----- (0805F2BE) --------------------------------------------------------
void __cdecl sub_805F2BE(int a1)
{
  sub_805F087(a1, &dword_8459988, 0.0, *(a1 + 24), a1, a1 + 12);
}
// 8459988: using guessed type int dword_8459988;

//----- (0805F2FC) --------------------------------------------------------
int __cdecl sub_805F2FC(_DWORD *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+28h] [ebp-40h]
  int v11; // [esp+28h] [ebp-40h]
  int v12; // [esp+28h] [ebp-40h]
  int i; // [esp+2Ch] [ebp-3Ch]
  float v14[7]; // [esp+30h] [ebp-38h] BYREF
  float v15; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  float v18; // [esp+58h] [ebp-10h]
  float v19; // [esp+5Ch] [ebp-Ch]

  if ( (*(a2 + 12) & a1[10]) == 0 )
    return 0;
  v19 = a5[*a2] - *(a2 + 16);
  v18 = a6[*a2] - *(a2 + 16);
  if ( v19 < 0.0 || v18 < 0.0 )
  {
    if ( v19 > 0.0 || v18 > 0.0 )
    {
      v17 = v19 / (v19 - v18);
      v15 = (a4 - a3) * v17 + a3;
      v14[0] = (*a6 - *a5) * v17 + *a5;
      v14[1] = (a6[1] - a5[1]) * v17 + a5[1];
      v14[2] = (a6[2] - a5[2]) * v17 + a5[2];
      v16 = v19 < 0.0;
      v10 = sub_805F2FC(a1, *(a2 + 4 * v16 + 32), LODWORD(a3), LODWORD(v15), a5, v14);
      if ( v10 )
        return v10;
      v11 = sub_805F2FC(a1, *(a2 + 4 * (1 - v16) + 32), LODWORD(v15), LODWORD(a4), v14, a6);
      if ( v11 )
        return v11;
    }
    else
    {
      v9 = sub_805F2FC(a1, *(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6);
      if ( v9 )
        return v9;
    }
  }
  else
  {
    v8 = sub_805F2FC(a1, *(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6);
    if ( v8 )
      return v8;
  }
  for ( i = *(a2 + 20); i; i = *(i + 4) )
  {
    v12 = sub_809AE1E(a1, i);
    if ( v12 )
      return v12;
  }
  return 0;
}

//----- (0805F58C) --------------------------------------------------------
int __cdecl sub_805F58C(int a1)
{
  return sub_805F2FC(a1, &dword_8459988, 0.0, 1.0, a1, (a1 + 12));
}
// 8459988: using guessed type int dword_8459988;

//----- (0805F5CE) --------------------------------------------------------
int __cdecl sub_805F5CE(int a1, int a2, float a3, float a4, float *a5, float *a6)
{
  float v8[15]; // [esp+30h] [ebp-78h] BYREF
  int *i; // [esp+6Ch] [ebp-3Ch]
  float v10[7]; // [esp+70h] [ebp-38h] BYREF
  float v11; // [esp+8Ch] [ebp-1Ch]
  _BOOL4 v12; // [esp+90h] [ebp-18h]
  float v13; // [esp+94h] [ebp-14h]
  float v14; // [esp+98h] [ebp-10h]
  float v15; // [esp+9Ch] [ebp-Ch]

  if ( (*(a2 + 8) & *a1) == 0 )
    return 1;
  v15 = a5[*a2] - *(a2 + 16);
  v14 = a6[*a2] - *(a2 + 16);
  if ( v15 < 0.0 || v14 < 0.0 )
  {
    if ( v15 > 0.0 || v14 > 0.0 )
    {
      v13 = v15 / (v15 - v14);
      v11 = (a4 - a3) * v13 + a3;
      v10[0] = (*a6 - *a5) * v13 + *a5;
      v10[1] = (a6[1] - a5[1]) * v13 + a5[1];
      v10[2] = (a6[2] - a5[2]) * v13 + a5[2];
      v12 = v15 < 0.0;
      if ( !sub_805F5CE(a1, *(a2 + 4 * v12 + 32), LODWORD(a3), LODWORD(v11), a5, v10) )
        return 0;
      if ( !sub_805F5CE(a1, *(a2 + 4 * (1 - v12) + 32), LODWORD(v11), LODWORD(a4), v10, a6) )
        return 0;
    }
    else if ( !sub_805F5CE(a1, *(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6) )
    {
      return 0;
    }
  }
  else if ( !sub_805F5CE(a1, *(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6) )
  {
    return 0;
  }
  v8[0] = 1.0;
  for ( i = *(a2 + 24); i; i = i[13] )
  {
    if ( i[20] )
    {
      if ( (*a1 & sub_80C4334(*i)) != 0 && !sub_805E387(a1 + 4, a1 + 16, (i + 14), (i + 17), 1.0) )
      {
        sub_8053D9B(i, v8, (a1 + 4), (a1 + 16), *a1);
        if ( v8[0] != 1.0 )
          return 0;
      }
    }
  }
  return 1;
}

//----- (0805F9A0) --------------------------------------------------------
int sub_805F9A0()
{
  int result; // eax
  char *v1; // eax

  result = sub_805FF1E();
  if ( result == 2 )
  {
    v1 = sub_805FF28(1u);
    result = atoi(v1);
    dword_8473A00 = result;
  }
  else
  {
    dword_8473A00 = 1;
  }
  return result;
}
// 8473A00: using guessed type int dword_8473A00;

//----- (0805F9D7) --------------------------------------------------------
void sub_805F9D7()
{
  dest = &unk_8463A00;
  dword_8473A08 = 0x10000;
  n = 0;
}
// 8473A08: using guessed type int dword_8473A08;

//----- (0805F9FA) --------------------------------------------------------
void __cdecl sub_805F9FA(char *s)
{
  size_t n; // [esp+14h] [ebp-4h]

  n = strlen(s);
  if ( (::n + n) < dword_8473A08 )
  {
    memcpy(dest + ::n, s, n);
    ::n += n;
  }
  else
  {
    Com_Printf("Cbuf_AddText: overflow\n");
  }
}
// 8473A08: using guessed type int dword_8473A08;

//----- (0805FA59) --------------------------------------------------------
void __cdecl sub_805FA59(char *s)
{
  signed int i; // [esp+10h] [ebp-8h]
  size_t v2; // [esp+14h] [ebp-4h]

  v2 = strlen(s) + 1;
  if ( (v2 + n) <= dword_8473A08 )
  {
    for ( i = n - 1; i >= 0; --i )
      *(dest + i + v2) = *(dest + i);
    memcpy(dest, s, v2 - 1);
    *(dest + v2 - 1) = 10;
    n += v2;
  }
  else
  {
    Com_Printf("Cbuf_InsertText overflowed\n");
  }
}
// 8473A08: using guessed type int dword_8473A08;

//----- (0805FAF4) --------------------------------------------------------
void __cdecl sub_805FAF4(int a1, char *s)
{
  if ( a1 == 1 )
  {
    sub_805FA59(s);
  }
  else if ( a1 > 1 )
  {
    if ( a1 != 2 )
LABEL_13:
      sub_80704AC(0, &byte_80DCB00);
    sub_805F9FA(s);
  }
  else
  {
    if ( a1 )
      goto LABEL_13;
    if ( s && *s )
      sub_80603E9(s);
    else
      sub_805FB6E();
  }
}

//----- (0805FB6E) --------------------------------------------------------
void sub_805FB6E()
{
  char v0; // [esp+1Ch] [ebp-101Ch]
  char dest[4104]; // [esp+20h] [ebp-1018h] BYREF
  void *src; // [esp+1028h] [ebp-10h]
  size_t n; // [esp+102Ch] [ebp-Ch]

  while ( ::n )
  {
    if ( dword_8473A00 )
    {
      --dword_8473A00;
      return;
    }
    src = ::dest;
    v0 = 0;
    for ( n = 0; n < ::n; ++n )
    {
      if ( *(src + n) == 34 )
        ++v0;
      if ( (v0 & 1) == 0 && *(src + n) == 59 || *(src + n) == 10 || *(src + n) == 13 )
        break;
    }
    if ( n > 4094 )
      n = 4095;
    memcpy(dest, src, n);
    dest[n] = 0;
    if ( n == ::n )
    {
      ::n = 0;
    }
    else
    {
      ::n -= ++n;
      memmove(src, src + n, ::n);
    }
    sub_80603E9(dest);
  }
}
// 8473A00: using guessed type int dword_8473A00;

//----- (0805FC9A) --------------------------------------------------------
void sub_805FC9A()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int v3; // eax
  char *v4; // eax
  unsigned int v5; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  void *src; // [esp+6Ch] [ebp-Ch] BYREF

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    Q_strncpyz(dest, v0, 64);
    sub_808637A(dest, 0x40u, ".cfg");
    v5 = sub_8062EB0(dest, &src);
    if ( src )
    {
      v2 = sub_805FF28(1u);
      Com_Printf("execing %s\n", v2);
      if ( sub_8073AE3("sv_console_lockout") )
      {
        v3 = sub_8080055(src, v5);
        v4 = sub_8086D78("say Server exec: %s, size: %i, checksum: %i", dest, v5, v3);
        sub_805FA59(v4);
      }
      sub_805FA59(src);
      sub_8063207(src);
    }
    else
    {
      v1 = sub_805FF28(1u);
      Com_Printf("couldn't exec %s\n", v1);
    }
  }
  else
  {
    Com_Printf("exec <filename> : execute a script file\n");
  }
}

//----- (0805FDAE) --------------------------------------------------------
void sub_805FDAE()
{
  char *v0; // eax
  char *v1; // eax
  int v2; // eax
  unsigned int v3; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  void *src; // [esp+6Ch] [ebp-Ch] BYREF

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    Q_strncpyz(dest, v0, 64);
    sub_808637A(dest, 0x40u, ".cfg");
    v3 = sub_8062EB0(dest, &src);
    if ( src )
    {
      v2 = sub_8080055(src, v3);
      Com_Printf("ShowChecksum: %s, size: %i, checksum: %i", dest, v3, v2);
      sub_8063207(src);
    }
    else
    {
      v1 = sub_805FF28(1u);
      Com_Printf("couldn't find %s\n", v1);
    }
  }
  else
  {
    Com_Printf("showchecksum <filename> : prints size and checksum of a file\n");
  }
}

//----- (0805FE83) --------------------------------------------------------
void sub_805FE83()
{
  char *v0; // eax
  char *v1; // eax
  const char *v2; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    v2 = sub_8073B14(v0);
    v1 = sub_8086D78("%s\n", v2);
    sub_805FA59(v1);
  }
  else
  {
    Com_Printf("vstr <variablename> : execute a variable command\n");
  }
}

//----- (0805FED5) --------------------------------------------------------
void sub_805FED5()
{
  char *v0; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i < sub_805FF1E(); ++i )
  {
    v0 = sub_805FF28(i);
    Com_Printf("%s ", v0);
  }
  Com_Printf("\n");
}

//----- (0805FF1E) --------------------------------------------------------
int sub_805FF1E()
{
  return dword_8233680;
}
// 8233680: using guessed type int dword_8233680;

//----- (0805FF28) --------------------------------------------------------
char *__cdecl sub_805FF28(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 < dword_8233680 )
    v2 = (&src)[a1];
  else
    v2 = &unk_80DCCBC;
  return v2;
}
// 8233680: using guessed type int dword_8233680;

//----- (0805FF54) --------------------------------------------------------
char *__cdecl sub_805FF54(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = sub_805FF28(a1);
  return Q_strncpyz(dest, v3, a3);
}

//----- (0805FF7F) --------------------------------------------------------
char *__cdecl sub_805FF7F(int a1)
{
  byte_82360C0 = 0;
  while ( a1 < dword_8233680 )
  {
    strcat(&byte_82360C0, (&src)[a1]);
    if ( a1 != dword_8233680 - 1 )
      strcat(&byte_82360C0, " ");
    ++a1;
  }
  return &byte_82360C0;
}
// 8233680: using guessed type int dword_8233680;

//----- (08060010) --------------------------------------------------------
char **__cdecl sub_8060010(char **a1, int a2)
{
  char **result; // eax
  char *v3; // [esp+0h] [ebp-8h] BYREF
  char *v4; // [esp+4h] [ebp-4h] BYREF

  dword_8233680 = 0;
  if ( a1 )
  {
    result = a1;
    v4 = a1;
    v3 = &unk_8233EA0;
LABEL_3:
    if ( dword_8233680 != 512 )
    {
      if ( --a2 )
      {
        while ( 1 )
        {
          while ( *v4 && *v4 <= 32 )
            ++v4;
          result = v4;
          if ( !*v4 )
            break;
          if ( *v4 == 47 )
          {
            result = (v4 + 1);
            if ( v4[1] == 47 )
              break;
          }
          if ( *v4 != 47 || v4[1] != 42 )
          {
            if ( *v4 == 34 )
            {
              (&src)[dword_8233680++] = v3;
              ++v4;
              while ( *v4 && *v4 != 34 )
                *v3++ = *v4++;
              *v3++ = 0;
              result = v4;
              if ( !*v4 )
                return result;
              result = ++v4;
              if ( !*v4 )
                return result;
              result = v4;
              if ( *v4 <= 32 )
              {
                result = &v4;
                ++v4;
              }
            }
            else
            {
              (&src)[dword_8233680++] = v3;
              while ( *v4 > 32 && *v4 != 34 && (*v4 != 47 || v4[1] != 47) && (*v4 != 47 || v4[1] != 42) )
                *v3++ = *v4++;
              *v3++ = 0;
              result = v4;
              if ( !*v4 )
                return result;
              result = v4;
              if ( *v4 <= 32 )
              {
                result = &v4;
                ++v4;
              }
            }
            goto LABEL_3;
          }
          while ( *v4 && (*v4 != 42 || v4[1] != 47) )
            ++v4;
          result = v4;
          if ( !*v4 )
            return result;
          v4 += 2;
        }
      }
      else
      {
        result = v4;
        if ( *v4 )
        {
          (&src)[dword_8233680++] = v3;
          while ( *v4 )
            *v3++ = *v4++;
          *v3 = 0;
          result = &v3;
          ++v3;
        }
      }
    }
  }
  return result;
}
// 8060250: returning address of temporary local variable '%var_8'
// 8233680: using guessed type int dword_8233680;

//----- (08060257) --------------------------------------------------------
char **__cdecl sub_8060257(char **a1)
{
  return sub_8060010(a1, 0);
}

//----- (08060272) --------------------------------------------------------
void __cdecl sub_8060272(char *s1, int a2)
{
  _DWORD *v2; // ebx
  int i; // [esp+10h] [ebp-8h]

  for ( i = dword_82360A0; ; i = *i )
  {
    if ( !i )
    {
      v2 = sub_806BB38(0xCu);
      v2[1] = sub_806BB76(s1);
      v2[2] = a2;
      *v2 = dword_82360A0;
      dword_82360A0 = v2;
      return;
    }
    if ( !strcmp(s1, *(i + 4)) )
      break;
  }
  if ( a2 )
    Com_Printf("Cmd_AddCommand: %s already defined\n", s1);
}
// 82360A0: using guessed type int dword_82360A0;

//----- (08060308) --------------------------------------------------------
void __cdecl sub_8060308(char *s1)
{
  const char ***i; // [esp+10h] [ebp-8h]
  const char **ptr; // [esp+14h] [ebp-4h]

  for ( i = &dword_82360A0; ; i = ptr )
  {
    ptr = *i;
    if ( !*i )
      break;
    if ( !strcmp(s1, ptr[1]) )
    {
      *i = *ptr;
      if ( ptr[1] )
        sub_806BB25(ptr[1]);
      sub_806BB25(ptr);
      return;
    }
  }
}
// 82360A0: using guessed type int dword_82360A0;

//----- (08060376) --------------------------------------------------------
void sub_8060376()
{
  void **ptr; // [esp+4h] [ebp-4h]

  while ( dword_82360A0 )
  {
    ptr = dword_82360A0;
    dword_82360A0 = *dword_82360A0;
    sub_806BB25(ptr[1]);
    sub_806BB25(ptr);
  }
}
// 82360A0: using guessed type int dword_82360A0;

//----- (080603B9) --------------------------------------------------------
int __cdecl sub_80603B9(void (__cdecl *a1)(int))
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = dword_82360A0;
  for ( i = dword_82360A0; i; i = *i )
  {
    a1(i[1]);
    result = *i;
  }
  return result;
}
// 82360A0: using guessed type int dword_82360A0;

//----- (080603E9) --------------------------------------------------------
void __cdecl sub_80603E9(char *s)
{
  size_t v1; // eax
  int *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  sub_8060257(s);
  if ( sub_805FF1E() )
  {
    for ( i = &dword_82360A0; *i; i = v3 )
    {
      v3 = *i;
      if ( !sub_8086A5A(src, *(*i + 4)) )
      {
        *i = *v3;
        *v3 = dword_82360A0;
        dword_82360A0 = v3;
        if ( *(v3 + 8) )
        {
          (*(v3 + 8))();
          return;
        }
        break;
      }
    }
    if ( sub_8086946(s, "pb_", 3) )
    {
      if ( !sub_8073C1A()
        && (!dword_84898B8 || !*(dword_84898B8 + 32) || !sub_80851AA())
        && (!dword_84897C0 || !*(dword_84897C0 + 32) || !sub_8090D65())
        && (!dword_84898B8 || !*(dword_84898B8 + 32) || !sub_80851B9()) )
      {
        sub_80851C3();
      }
    }
    else if ( !sub_8086946(s + 3, "sv_", 3) )
    {
      v1 = strlen(s);
      sub_80B6AE0(14, -1, v1 + 1, s);
    }
  }
}
// 8090D65: using guessed type int sub_8090D65(void);
// 82360A0: using guessed type int dword_82360A0;
// 84897C0: using guessed type int dword_84897C0;
// 84898B8: using guessed type int dword_84898B8;

//----- (08060561) --------------------------------------------------------
void sub_8060561()
{
  char *v0; // [esp+Ch] [ebp-Ch]
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() <= 1 )
    v0 = 0;
  else
    v0 = sub_805FF28(1u);
  v1 = 0;
  for ( i = dword_82360A0; i; i = *i )
  {
    if ( !v0 || sub_806B606(v0, *(i + 4), 0) )
    {
      Com_Printf("%s\n", *(i + 4));
      ++v1;
    }
  }
  Com_Printf("%i commands\n", v1);
}
// 82360A0: using guessed type int dword_82360A0;

//----- (08060603) --------------------------------------------------------
void sub_8060603()
{
  sub_8060272("cmdlist", sub_8060561);
  sub_8060272("exec", sub_805FC9A);
  sub_8060272("vstr", sub_805FE83);
  sub_8060272("echo", sub_805FED5);
  sub_8060272("wait", sub_805F9A0);
  sub_8060272("showchecksum", sub_805FDAE);
}

//----- (08060684) --------------------------------------------------------
_BOOL4 sub_8060684()
{
  return dword_80EF510 != 0;
}

//----- (08060696) --------------------------------------------------------
void sub_8060696()
{
  ;
}

//----- (0806069B) --------------------------------------------------------
int __cdecl sub_806069B(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  if ( !dword_848436C )
    return 1;
  for ( i = 0; i < dword_848436C; ++i )
  {
    if ( *(a1 + 772) == dword_8480360[i] )
      return 1;
  }
  return 0;
}
// 848436C: using guessed type int dword_848436C;

//----- (080606F8) --------------------------------------------------------
int sub_80606F8()
{
  return dword_8477A20;
}
// 8477A20: using guessed type int dword_8477A20;

//----- (08060702) --------------------------------------------------------
_BOOL4 __cdecl sub_8060702(int a1)
{
  return !*(a1 + 12) || !*(dword_8477A24 + 32);
}
// 8477A24: using guessed type int dword_8477A24;

//----- (0806077A) --------------------------------------------------------
int __cdecl sub_806077A(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( i = 0; *(a1 + i); ++i )
  {
    v3 = tolower(*(a1 + i));
    if ( v3 == 46 )
      break;
    if ( v3 == 92 )
      v3 = 47;
    if ( v3 == 47 )
      v3 = 47;
    v4 += v3 * (i + 119);
  }
  return (a2 - 1) & (v4 ^ (v4 >> 10) ^ (v4 >> 20));
}

//----- (0806080D) --------------------------------------------------------
int __cdecl sub_806080D(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( a1 )
  {
    v3 = 51;
    v2 = 13;
  }
  else
  {
    v3 = 1;
    v2 = 50;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= v2 )
    {
      for ( j = 1; j <= 63; ++j )
        Com_Printf("FILE %2i: '%s'\n", j);
      sub_80704AC(1, &byte_80DCD50);
    }
    if ( !dword_8477A40[72 * i + 72 * v3] )
      break;
  }
  return v3 + i;
}
// 8477A40: using guessed type int dword_8477A40[];

//----- (080608D4) --------------------------------------------------------
int __cdecl sub_80608D4(int a1)
{
  return dword_8477A40[72 * a1];
}
// 8477A40: using guessed type int dword_8477A40[];

//----- (080608EC) --------------------------------------------------------
int __cdecl sub_80608EC(int a1)
{
  FILE *stream; // [esp+14h] [ebp-4h]

  stream = sub_80608D4(a1);
  return setvbuf(stream, 0, 2, 0);
}

//----- (08060925) --------------------------------------------------------
int __cdecl sub_8060925(int a1)
{
  FILE *stream; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int off; // [esp+24h] [ebp-4h]

  sub_8060696();
  if ( dword_8477A58[72 * a1] )
    return *(dword_8477A40[72 * a1] + 68);
  stream = sub_80608D4(a1);
  off = ftell(stream);
  fseek(stream, 0, 2);
  v4 = ftell(stream);
  fseek(stream, off, 0);
  return v4;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A58: using guessed type int dword_8477A58[];

//----- (080609D3) --------------------------------------------------------
_BYTE *__cdecl sub_80609D3(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 47 || *a1 == 92 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (08060A0A) --------------------------------------------------------
void *__cdecl sub_8060A0A(char *s, char *a2, char *a3, void *dest, int a5)
{
  void *result; // eax
  char v6; // [esp+8h] [ebp-10h]
  size_t v7; // [esp+Ch] [ebp-Ch]
  size_t v8; // [esp+10h] [ebp-8h]
  size_t n; // [esp+14h] [ebp-4h]

  if ( !a2 || !*a2 )
    a2 = byte_84885E0;
  n = strlen(s);
  v8 = strlen(a2);
  v7 = strlen(a3);
  if ( (v7 + n + v8 + 2) <= 255 )
  {
    memcpy(dest, s, n);
    *(dest + n) = 47;
    memcpy(dest + n + 1, a2, v8);
    *(dest + n + v8 + 1) = 47;
    memcpy(dest + n + v8 + 2, a3, v7 + 1);
    result = sub_80609D3(dest + n);
  }
  else
  {
    if ( !a5 )
      sub_80704AC(0, &byte_80DCD80, v6);
    result = dest;
    *dest = 0;
  }
  return result;
}
// 8060A82: variable 'v6' is possibly undefined

//----- (08060B06) --------------------------------------------------------
void *__cdecl sub_8060B06(char *s, char *a2, char *a3, void *dest)
{
  return sub_8060A0A(s, a2, a3, dest, 0);
}

//----- (08060B36) --------------------------------------------------------
int __cdecl sub_8060B36(char *haystack)
{
  int v2; // [esp+10h] [ebp-8h]
  char *i; // [esp+14h] [ebp-4h]

  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    Com_Printf("WARNING: refusing to create relative path \"%s\"\n", haystack);
    v2 = 1;
  }
  else
  {
    for ( i = haystack + 1; *i; ++i )
    {
      if ( *i == 47 )
      {
        *i = 0;
        sub_80CA9C3(haystack);
        *i = 47;
      }
    }
    v2 = 0;
  }
  return v2;
}

//----- (08060BCB) --------------------------------------------------------
void __cdecl sub_8060BCB(char *haystack, char *filename)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  if ( !strstr(haystack, "journal.dat") && !strstr(haystack, "journaldata.dat") )
  {
    stream = fopen(haystack, "rb");
    if ( stream )
    {
      fseek(stream, 0, 2);
      size = ftell(stream);
      fseek(stream, 0, 0);
      ptr = malloc(size);
      if ( fread(ptr, 1u, size, stream) != size )
        sub_80704AC(0, &byte_80DCE20);
      fclose(stream);
      if ( sub_8060B36(filename) || (streama = fopen(filename, "wb")) == 0 )
      {
        free(ptr);
      }
      else
      {
        if ( fwrite(ptr, 1u, size, streama) != size )
          sub_80704AC(0, &byte_80DCE60);
        fclose(streama);
        free(ptr);
      }
    }
  }
}

//----- (08060F50) --------------------------------------------------------
int __cdecl sub_8060F50(char *filename)
{
  return remove(filename);
}

//----- (08060F63) --------------------------------------------------------
int __cdecl sub_8060F63(char *a1)
{
  char filename[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, a1, filename);
  stream = fopen(filename, "rb");
  if ( !stream )
    return 0;
  fclose(stream);
  return 1;
}
// 8484370: using guessed type int dword_8484370;

//----- (08060FDD) --------------------------------------------------------
int __cdecl sub_8060FDD(char *a1, char *a2)
{
  int result; // eax
  char newa[256]; // [esp+10h] [ebp-208h] BYREF
  char old[264]; // [esp+110h] [ebp-108h] BYREF

  sub_8060696();
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, a1, old);
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, a2, newa);
  if ( *(dword_8484380 + 32) )
    Com_Printf("FS_Rename: %s --> %s\n", old, newa);
  result = rename(old, newa);
  if ( result )
  {
    sub_8060F50(newa);
    result = rename(old, newa);
    if ( result )
    {
      sub_8060BCB(old, newa);
      result = sub_8060F50(old);
    }
  }
  return result;
}
// 8484370: using guessed type int dword_8484370;
// 8484380: using guessed type int dword_8484380;

//----- (080610D6) --------------------------------------------------------
void *__cdecl FS_FCloseFile(int a1)
{
  sub_8060696();
  if ( dword_8477A5C[72 * a1] )
    sub_80C934E();
  if ( dword_8477A58[72 * a1] )
  {
    sub_80CCE86(dword_8477A40[72 * a1]);
    if ( dword_8477A44[72 * a1] )
      sub_80CBC1C(dword_8477A40[72 * a1]);
  }
  else if ( dword_8477A40[72 * a1] )
  {
    fclose(dword_8477A40[72 * a1]);
  }
  return sub_80C837D(&dword_8477A40[72 * a1], 0, 0x120u);
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A44: using guessed type int dword_8477A44[];
// 8477A58: using guessed type int dword_8477A58[];

//----- (080611FB) --------------------------------------------------------
int __cdecl sub_80611FB(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060696();
  v3 = sub_806080D(0);
  dword_8477A58[72 * v3] = 0;
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, src, filename);
  if ( *(dword_8484380 + 32) )
    Com_Printf("FS_FOpenFileWrite: %s\n", filename);
  if ( sub_8060B36(filename) )
    return 0;
  dword_8477A40[72 * v3] = fopen(filename, "wb");
  Q_strncpyz((288 * v3 + 138902112), src, 256);
  dword_8477A48[72 * v3] = 0;
  if ( !dword_8477A40[72 * v3] )
    v3 = 0;
  return v3;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A48: using guessed type int dword_8477A48[];
// 8477A58: using guessed type int dword_8477A58[];
// 8484370: using guessed type int dword_8484370;
// 8484380: using guessed type int dword_8484380;

//----- (0806135D) --------------------------------------------------------
int __cdecl sub_806135D(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060696();
  v3 = sub_806080D(0);
  dword_8477A58[72 * v3] = 0;
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, src, filename);
  if ( *(dword_8484380 + 32) )
    Com_Printf("FS_FOpenFileWrite: %s\n", filename);
  if ( sub_8060B36(filename) )
    return 0;
  dword_8477A40[72 * v3] = fopen(filename, "wt");
  Q_strncpyz((288 * v3 + 138902112), src, 256);
  dword_8477A48[72 * v3] = 0;
  if ( !dword_8477A40[72 * v3] )
    v3 = 0;
  return v3;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A48: using guessed type int dword_8477A48[];
// 8477A58: using guessed type int dword_8477A58[];
// 8484370: using guessed type int dword_8484370;
// 8484380: using guessed type int dword_8484380;

//----- (080614BF) --------------------------------------------------------
int __cdecl sub_80614BF(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060696();
  v3 = sub_806080D(0);
  dword_8477A58[72 * v3] = 0;
  Q_strncpyz((288 * v3 + 138902112), src, 256);
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, src, filename);
  if ( *(dword_8484380 + 32) )
    Com_Printf("FS_FOpenFileAppend: %s\n", filename);
  if ( sub_8060B36(filename) )
    return 0;
  dword_8477A40[72 * v3] = fopen(filename, "ab");
  dword_8477A48[72 * v3] = 0;
  if ( !dword_8477A40[72 * v3] )
    v3 = 0;
  return v3;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A48: using guessed type int dword_8477A48[];
// 8477A58: using guessed type int dword_8477A58[];
// 8484370: using guessed type int dword_8484370;
// 8484380: using guessed type int dword_8484380;

//----- (0806161E) --------------------------------------------------------
int __cdecl sub_806161E(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( sub_80867AA(v5) )
      v5 -= 32;
    if ( sub_80867AA(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 != v4 )
      return -1;
  }
  while ( v5 );
  return 0;
}

//----- (08061918) --------------------------------------------------------
char *__cdecl sub_8061918(char *haystack, int a2, char a3)
{
  int i; // [esp+1Ch] [ebp-10Ch]
  char needle[264]; // [esp+20h] [ebp-108h] BYREF

  for ( i = 0; *(a2 + i); ++i )
    needle[i] = *(i + a2) + a3;
  needle[i] = 0;
  return strstr(haystack, needle);
}

//----- (0806198C) --------------------------------------------------------
const char *__cdecl sub_806198C(_BYTE *a1)
{
  const char *v2; // [esp+0h] [ebp-4h]

  v2 = &byte_80DCF61;
  while ( *a1 )
  {
    if ( *a1 == 46 )
    {
      v2 = a1 + 1;
    }
    else if ( *a1 == 47 || *a1 == 92 )
    {
      v2 = &byte_80DCF61;
    }
    ++a1;
  }
  return v2;
}

//----- (080619D7) --------------------------------------------------------
_BOOL4 __cdecl sub_80619D7(char *s1)
{
  if ( *s1 == 46 )
    ++s1;
  if ( !strcasecmp(s1, "cfg") )
    return 1;
  if ( !sub_8086A5A(s1, "menu") )
    return 1;
  if ( sub_8086A5A(s1, ".dm_NETWORK_PROTOCOL_VERSION") )
    return sub_8086A5A(s1, "dat") == 0;
  return 1;
}

//----- (08061A74) --------------------------------------------------------
int __cdecl sub_8061A74(char *haystack, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  char v9[268]; // [esp+30h] [ebp-248h] BYREF
  char v10[4]; // [esp+13Ch] [ebp-13Ch]
  char *s1; // [esp+140h] [ebp-138h]
  size_t v12; // [esp+144h] [ebp-134h]
  FILE *stream; // [esp+148h] [ebp-130h]
  void *dest; // [esp+14Ch] [ebp-12Ch]
  int v15; // [esp+150h] [ebp-128h]
  char *s; // [esp+154h] [ebp-124h]
  int v17; // [esp+158h] [ebp-120h]
  char *v18; // [esp+15Ch] [ebp-11Ch]
  char filename[268]; // [esp+160h] [ebp-118h] BYREF
  void *i; // [esp+26Ch] [ebp-Ch]

  v15 = 0;
  sub_8060696();
  if ( !a2 )
  {
    for ( i = dword_80EF510; ; i = *i )
    {
      if ( !i )
        return 0;
      if ( sub_8060702(i) )
      {
        if ( *(i + 1) )
          v15 = sub_806077A(haystack, *(*(i + 1) + 788));
        if ( *(i + 1) && *(*(*(i + 1) + 792) + 4 * v15) )
        {
          v18 = *(i + 1);
          v17 = *(*(v18 + 198) + 4 * v15);
          while ( sub_806161E(*(v17 + 16), haystack) )
          {
            v17 = *(v17 + 20);
            if ( !v17 )
              goto LABEL_17;
          }
          return 1;
        }
        if ( *(i + 2) )
        {
          s = *(i + 2);
          sub_8060A0A(s, s + 256, haystack, filename, a4);
          stream = fopen(filename, "rb");
          if ( stream )
          {
            fclose(stream);
            return 1;
          }
        }
      }
LABEL_17:
      ;
    }
  }
  while ( *haystack == 47 || *haystack == 92 )
    ++haystack;
  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    *a2 = 0;
    return -1;
  }
  *a2 = sub_806080D(a4);
  dword_8477A44[72 * *a2] = a3;
  *v10 = 0;
  for ( i = dword_80EF510; ; i = *i )
  {
    if ( !i )
    {
      if ( *(dword_8484380 + 32) && !a4 )
        Com_Printf("Can't find %s\n", haystack);
      *a2 = 0;
      if ( *v10 )
      {
        v6 = sub_8086D78(aExeUnpureclien_0, *v10);
        sub_80704AC(1, v6);
      }
      return -1;
    }
    if ( sub_8060702(i) )
      break;
LABEL_93:
    ;
  }
  v18 = *(i + 1);
  if ( v18 )
    v15 = sub_806077A(haystack, *(v18 + 197));
  if ( strstr(haystack, ".bsp") )
  {
    if ( v18 && *(*(v18 + 198) + 4 * v15) )
    {
      Q_strncpyz(&byte_84843A0, v18 + 512, 256);
    }
    else if ( *(i + 2) )
    {
      Q_strncpyz(&byte_84843A0, (*(i + 2) + 256), 256);
    }
  }
  if ( !v18 || !*(*(v18 + 198) + 4 * v15) )
  {
    if ( *(i + 2) )
    {
      if ( (s1 = sub_806198C(haystack), !*(dword_848437C + 32)) && !dword_848436C || *(i + 3) || sub_80619D7(s1) )
      {
        s = *(i + 2);
        sub_8060A0A(s, s + 256, haystack, filename, a4);
        v5 = 72 * *a2;
        dword_8477A40[v5] = fopen(filename, "rb");
        if ( dword_8477A40[72 * *a2] )
        {
          if ( !*(i + 3) && !sub_80619D7(s1) )
            dword_8484378 = rand() + 1;
          Q_strncpyz((288 * *a2 + 138902112), haystack, 256);
          dword_8477A58[72 * *a2] = 0;
          if ( *(dword_8484380 + 32) && !a4 )
            Com_Printf("FS_FOpenFileRead: %s (found in '%s/%s')\n", haystack, s, s + 256);
          if ( *(dword_8484364 + 32) && !sub_8086A5A(s, *(dword_84844A0 + 4)) )
          {
            sub_8060A0A(*(dword_8480340 + 4), s + 256, haystack, v9, a4);
            sub_8060BCB(filename, v9);
          }
          return sub_8060925(*a2);
        }
      }
    }
    goto LABEL_93;
  }
  v17 = *(*(v18 + 198) + 4 * v15);
  while ( sub_806161E(*(v17 + 16), haystack) )
  {
    v17 = *(v17 + 20);
    if ( !v17 )
      goto LABEL_93;
  }
  if ( !*(i + 3) && !sub_806069B(v18) )
  {
    *v10 = v18;
    goto LABEL_93;
  }
  v12 = strlen(haystack);
  if ( !v18[784]
    && sub_8086A5A(&haystack[v12 - 7], ".shader")
    && sub_8086A5A(&haystack[v12 - 4], ".txt")
    && sub_8086A5A(&haystack[v12 - 4], ".cfg")
    && sub_8086A5A(&haystack[v12 - 7], ".config")
    && !strstr(haystack, "levelshots")
    && sub_8086A5A(&haystack[v12 - 4], ".bot")
    && sub_8086A5A(&haystack[v12 - 6], ".arena")
    && sub_8086A5A(&haystack[v12 - 5], ".menu")
    && !strstr(haystack, "soundaliases") )
  {
    v18[784] = 1;
  }
  if ( !v18[787] && sub_8061918(haystack, "{usmgskesve~><4jrr", -6) )
    v18[787] = 1;
  if ( !v18[786] && sub_8061918(haystack, "wqaeicogaoraz:80fnn", -2) )
    v18[786] = 1;
  if ( !v18[785] && sub_8061918(haystack, "ztdzndrud}=;3iqq", -5) )
    v18[785] = 1;
  if ( a3 )
  {
    v4 = 72 * *a2;
    dword_8477A40[v4] = sub_80CB8F4(v18, *(v18 + 192));
    if ( !dword_8477A40[72 * *a2] )
    {
      if ( !a4 )
        sub_80704AC(0, &byte_80DD00D, v18);
      FS_FCloseFile(*a2);
      *a2 = 0;
      return -1;
    }
  }
  else
  {
    dword_8477A40[72 * *a2] = *(v18 + 192);
  }
  Q_strncpyz((288 * *a2 + 138902112), haystack, 256);
  dword_8477A58[72 * *a2] = v18;
  dest = dword_8477A40[72 * *a2];
  stream = *dest;
  sub_80D17B2(*(v18 + 192), *v17);
  if ( dest != *(v18 + 192) )
    sub_80C835C(dest, *(v18 + 192), 0x80u);
  *dest = stream;
  sub_80CC7AC(dword_8477A40[72 * *a2]);
  dword_8477A54[72 * *a2] = *v17;
  if ( *(dword_8484380 + 32) && !a4 )
    Com_Printf("FS_FOpenFileRead: %s (found in '%s')\n", haystack, v18);
  return *(dest + 17);
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A44: using guessed type int dword_8477A44[];
// 8477A54: using guessed type int dword_8477A54[];
// 8477A58: using guessed type int dword_8477A58[];
// 8480340: using guessed type int dword_8480340;
// 8484364: using guessed type int dword_8484364;
// 848436C: using guessed type int dword_848436C;
// 8484378: using guessed type int dword_8484378;
// 848437C: using guessed type int dword_848437C;
// 8484380: using guessed type int dword_8484380;
// 84844A0: using guessed type int dword_84844A0;

//----- (08062558) --------------------------------------------------------
int __cdecl sub_8062558(char *haystack, int a2, int a3)
{
  dword_84885C0 = 1;
  return sub_8061A74(haystack, a2, a3, 0);
}
// 84885C0: using guessed type int dword_84885C0;

//----- (0806258B) --------------------------------------------------------
int __cdecl sub_806258B(char *haystack)
{
  int v3; // [esp+14h] [ebp-4h] BYREF

  sub_8062558(haystack, &v3, 0);
  if ( !v3 )
    return 0;
  FS_FCloseFile(v3);
  return 1;
}

//----- (08062782) --------------------------------------------------------
_BOOL4 __cdecl sub_8062782(char *a1, int a2)
{
  __mode_t v3; // [esp+18h] [ebp-180h]
  struct stat stat_buf; // [esp+20h] [ebp-178h] BYREF
  char file[264]; // [esp+90h] [ebp-108h] BYREF

  sub_8060696();
  sub_8060B06(*(dword_8484370 + 4), byte_84885E0, a1, file);
  if ( sub_80DB9E4(file, &stat_buf) == -1 )
    return 0;
  if ( a2 )
    v3 = stat_buf.st_mode & 0xFFFFFEFF;
  else
    v3 = stat_buf.st_mode | 0x100;
  stat_buf.st_mode = v3;
  return chmod(file, v3) != -1;
}
// 8484370: using guessed type int dword_8484370;

//----- (08062853) --------------------------------------------------------
int __cdecl sub_8062853(int a1, unsigned int a2, int a3)
{
  char v4; // [esp+8h] [ebp-20h]
  int v6; // [esp+14h] [ebp-14h]
  char *ptr; // [esp+18h] [ebp-10h]
  size_t v8; // [esp+1Ch] [ebp-Ch]
  size_t v9; // [esp+20h] [ebp-8h]

  sub_8060696();
  if ( !a3 )
    return 0;
  ptr = a1;
  if ( dword_8477A58[72 * a3] )
    return sub_80CC9B8(dword_8477A40[72 * a3], a1, a2);
  v9 = a2;
  v6 = 0;
  while ( 1 )
  {
    if ( !v9 )
      return a2;
    v8 = fread(ptr, 1u, v9, dword_8477A40[72 * a3]);
    if ( !v8 )
    {
      if ( v6 )
        return a2 - v9;
      v6 = 1;
    }
    if ( v8 == -1 )
      break;
    v9 -= v8;
    ptr += v8;
  }
  if ( a3 <= 50 || a3 > 63 )
    sub_80704AC(0, &byte_80DD0E0, v4);
  return -1;
}
// 8062930: variable 'v4' is possibly undefined
// 8477A40: using guessed type int dword_8477A40[];
// 8477A58: using guessed type int dword_8477A58[];

//----- (08062983) --------------------------------------------------------
size_t __cdecl sub_8062983(char *a1, size_t a2, int a3)
{
  char v4; // [esp+4h] [ebp-34h]
  FILE *s; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+2Ch] [ebp-Ch]
  size_t v10; // [esp+30h] [ebp-8h]

  sub_8060696();
  if ( !a3 )
    return 0;
  s = sub_80608D4(a3);
  v10 = a2;
  v7 = 0;
  while ( v10 )
  {
    v9 = fwrite(a1, 1u, v10, s);
    if ( !v9 )
    {
      if ( v7 )
      {
        Com_Printf("FS_Write: 0 bytes written\n", v4);
        return 0;
      }
      v7 = 1;
    }
    if ( v9 == -1 )
    {
      Com_Printf("FS_Write: -1 bytes written\n", v4);
      return 0;
    }
    v10 -= v9;
    a1 += v9;
  }
  if ( dword_8477A48[72 * a3] )
    fflush(s);
  return a2;
}
// 8062A12: variable 'v4' is possibly undefined
// 8477A48: using guessed type int dword_8477A48[];

//----- (08062A7E) --------------------------------------------------------
size_t sub_8062A7E(int a1, char *format, ...)
{
  size_t v2; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  v2 = strlen(s);
  return sub_8062983(s, v2, a1);
}

//----- (08062AD4) --------------------------------------------------------
int __cdecl sub_8062AD4(int a1, int off, int a3)
{
  int v4; // [esp+14h] [ebp-10024h]
  FILE *stream; // [esp+18h] [ebp-10020h]
  char v6[65536]; // [esp+20h] [ebp-10018h] BYREF
  int whence; // [esp+10020h] [ebp-18h]
  int v8; // [esp+10024h] [ebp-14h]
  int v9; // [esp+10028h] [ebp-10h]
  int v10; // [esp+1002Ch] [ebp-Ch]

  sub_8060696();
  if ( dword_8477A5C[72 * a1] )
  {
    dword_8477A5C[72 * a1] = 0;
    sub_80C9378(a1, off, a3);
    dword_8477A5C[72 * a1] = 1;
  }
  if ( !dword_8477A58[72 * a1] )
  {
    stream = sub_80608D4(a1);
    if ( a3 == 1 )
    {
      whence = 2;
    }
    else if ( a3 > 1 )
    {
      if ( a3 != 2 )
        return 0;
      whence = 0;
    }
    else
    {
      if ( a3 )
        return 0;
      whence = 1;
    }
    return fseek(stream, off, whence);
  }
  if ( off || a3 != 2 )
  {
    if ( off || a3 )
    {
      v9 = sub_80CCD02(dword_8477A40[72 * a1]);
      switch ( a3 )
      {
        case 0:
          if ( off >= 0 )
          {
            v8 = off;
          }
          else
          {
            sub_80D17B2(dword_8477A40[72 * a1], dword_8477A54[72 * a1]);
            sub_80CC7AC(dword_8477A40[72 * a1]);
            v8 = v9 + off;
          }
          goto LABEL_23;
        case 1:
          if ( off + sub_8060925(a1) >= v9 )
          {
            v8 = off + sub_8060925(a1) - v9;
          }
          else
          {
            sub_80D17B2(dword_8477A40[72 * a1], dword_8477A54[72 * a1]);
            sub_80CC7AC(dword_8477A40[72 * a1]);
            v8 = off + sub_8060925(a1);
          }
          goto LABEL_23;
        case 2:
          if ( off >= v9 )
          {
            v8 = off - v9;
          }
          else
          {
            sub_80D17B2(dword_8477A40[72 * a1], dword_8477A54[72 * a1]);
            sub_80CC7AC(dword_8477A40[72 * a1]);
            v8 = off;
          }
LABEL_23:
          while ( v8 )
          {
            if ( v8 >= 0x10000 )
            {
              v10 = sub_8062853(v6, 0x10000u, a1);
              v8 -= 0x10000;
            }
            else
            {
              v10 = sub_8062853(v6, v8, a1);
              v8 = 0;
            }
            if ( !v10 )
              return -1;
          }
          v4 = 0;
          break;
        default:
          v4 = -1;
          break;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    sub_80D17B2(dword_8477A40[72 * a1], dword_8477A54[72 * a1]);
    v4 = sub_80CC7AC(dword_8477A40[72 * a1]);
  }
  return v4;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A54: using guessed type int dword_8477A54[];
// 8477A58: using guessed type int dword_8477A58[];

//----- (08062EB0) --------------------------------------------------------
unsigned int __cdecl sub_8062EB0(char *haystack, int a2)
{
  unsigned int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h] BYREF
  int v6; // [esp+1Ch] [ebp-Ch]
  char *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h] BYREF

  sub_8060696();
  if ( !haystack || !*haystack )
    sub_80704AC(0, &byte_80DD12F);
  v7 = 0;
  if ( strstr(haystack, ".cfg") )
  {
    v6 = 1;
    if ( dword_8489730 && *(dword_8489730 + 32) == 2 )
    {
      Com_DPrintf("Loading %s from journal file.\n", haystack);
      if ( sub_8062853(&v5, 4u, *dword_84897D0) == 4 )
      {
        if ( v5 )
        {
          if ( a2 )
          {
            v7 = sub_806C600(v5 + 1);
            *a2 = v7;
            v4 = sub_8062853(v7, v5, *dword_84897D0);
            if ( v4 != v5 )
              sub_80704AC(0, "EXE_ERR_JOURNAL_FILE_READ");
            ++dword_8477A20;
            v7[v5] = 0;
            v3 = v5;
          }
          else
          {
            v3 = v5;
          }
        }
        else if ( a2 )
        {
          *a2 = 0;
          v3 = -1;
        }
        else
        {
          v3 = 1;
        }
      }
      else
      {
        if ( a2 )
          *a2 = 0;
        v3 = -1;
      }
      return v3;
    }
  }
  else
  {
    v6 = 0;
  }
  v5 = sub_8062558(haystack, &v8, 0);
  if ( v8 )
  {
    if ( a2 )
    {
      ++dword_8477A20;
      v7 = sub_806C600(v5 + 1);
      *a2 = v7;
      sub_8062853(v7, v5, v8);
      v7[v5] = 0;
      FS_FCloseFile(v8);
      if ( v6 && dword_8489730 && *(dword_8489730 + 32) == 1 )
      {
        Com_DPrintf("Writing %s to journal file.\n", haystack);
        sub_8062983(&v5, 4u, *dword_84897D0);
        sub_8062983(v7, v5, *dword_84897D0);
        sub_8065FA4(*dword_84897D0);
      }
      v3 = v5;
    }
    else
    {
      if ( v6 && dword_8489730 && *(dword_8489730 + 32) == 1 )
      {
        Com_DPrintf("Writing len for %s to journal file.\n", haystack);
        sub_8062983(&v5, 4u, *dword_84897D0);
        sub_8065FA4(*dword_84897D0);
      }
      FS_FCloseFile(v8);
      v3 = v5;
    }
  }
  else
  {
    if ( a2 )
      *a2 = 0;
    if ( v6 && dword_8489730 && *(dword_8489730 + 32) == 1 )
    {
      Com_DPrintf("Writing zero for %s to journal file.\n", haystack);
      v5 = 0;
      sub_8062983(&v5, 4u, *dword_84897D0);
      sub_8065FA4(*dword_84897D0);
    }
    v3 = -1;
  }
  return v3;
}
// 8477A20: using guessed type int dword_8477A20;
// 8489730: using guessed type int dword_8489730;

//----- (080631F8) --------------------------------------------------------
void sub_80631F8()
{
  dword_8477A20 = 0;
}
// 8477A20: using guessed type int dword_8477A20;

//----- (08063207) --------------------------------------------------------
void __cdecl sub_8063207(void *ptr)
{
  sub_8060696();
  if ( !ptr )
    sub_80704AC(0, &byte_80DD222);
  --dword_8477A20;
  sub_806C742(ptr);
}
// 8477A20: using guessed type int dword_8477A20;

//----- (0806323F) --------------------------------------------------------
void __cdecl sub_806323F(char *src, int a2, int a3)
{
  int v3; // [esp+14h] [ebp-4h]

  sub_8060696();
  if ( !src || !a2 )
    sub_80704AC(0, &byte_80DD237);
  v3 = sub_80611FB(src);
  if ( v3 )
  {
    sub_8062983(a2, a3, v3);
    FS_FCloseFile(v3);
  }
  else
  {
    Com_Printf("Failed to open %s\n", src);
  }
}

//----- (080632B9) --------------------------------------------------------
char *__cdecl sub_80632B9(char *src, char *a2)
{
  size_t v2; // eax
  char *v3; // ebx
  char *v4; // ebx
  char *v5; // ebx
  int v6; // eax
  char *v7; // ebx
  char *v8; // ebx
  signed int m; // [esp+24h] [ebp-194h]
  char *v12; // [esp+28h] [ebp-190h]
  _DWORD *ptr; // [esp+2Ch] [ebp-18Ch]
  int v14; // [esp+30h] [ebp-188h]
  int v15; // [esp+34h] [ebp-184h]
  int v16; // [esp+38h] [ebp-180h]
  unsigned int i; // [esp+3Ch] [ebp-17Ch]
  int j; // [esp+3Ch] [ebp-17Ch]
  int k; // [esp+3Ch] [ebp-17Ch]
  unsigned int l; // [esp+3Ch] [ebp-17Ch]
  int v21[20]; // [esp+40h] [ebp-178h] BYREF
  char s[264]; // [esp+90h] [ebp-128h] BYREF
  unsigned int v23; // [esp+198h] [ebp-20h] BYREF
  int v24; // [esp+1A0h] [ebp-18h]
  int v25; // [esp+1A4h] [ebp-14h]
  char *dest; // [esp+1A8h] [ebp-10h]
  _DWORD *v27; // [esp+1ACh] [ebp-Ch]

  v14 = 0;
  v25 = sub_80CB95C(src);
  v24 = sub_80CBC70(v25, &v23);
  if ( v24 )
    return 0;
  *dword_80EF520 += v23;
  v16 = 0;
  sub_80CC23E(v25);
  for ( i = 0; i < v23; ++i )
  {
    v24 = sub_80CC1F2(v25, v21, s, 256, 0, 0, 0, 0);
    if ( v24 )
      break;
    v16 += strlen(s) + 1;
    sub_80CC2E6(v25);
  }
  v27 = sub_806BB38(v16 + 24 * v23);
  v12 = &v27[6 * v23];
  ptr = sub_806BB38(4 * v23);
  for ( j = 1; j <= 1024 && j <= v23; j *= 2 )
    ;
  dest = sub_806BB38(4 * j + 800);
  *(dest + 197) = j;
  *(dest + 198) = dest + 800;
  for ( k = 0; k < *(dest + 197); ++k )
    *(*(dest + 198) + 4 * k) = 0;
  Q_strncpyz(dest, src, 256);
  Q_strncpyz(dest + 256, a2, 256);
  if ( strlen(dest + 256) > 4 )
  {
    v2 = strlen(dest + 256);
    if ( !sub_8086A5A(&dest[v2 + 252], ".pk3") )
    {
      v3 = dest;
      v3[strlen(dest + 256) + 252] = 0;
    }
  }
  *(dest + 192) = v25;
  *(dest + 195) = v23;
  sub_80CC23E(v25);
  for ( l = 0; l < v23; ++l )
  {
    v24 = sub_80CC1F2(v25, v21, s, 256, 0, 0, 0, 0);
    if ( v24 )
      break;
    if ( v21[7] )
      ptr[v14++] = sub_8065FC7(v21[5]);
    sub_8086A97(s);
    v15 = sub_806077A(s, *(dest + 197));
    v27[6 * l + 4] = v12;
    strcpy(v27[6 * l + 4], s);
    for ( m = strlen(v12) - 1; m >= 0 && v12[m] != 47 && v12[m] != 92; --m )
      ;
    v27[6 * l + 1] = &v12[m + 1];
    v12 += strlen(s) + 1;
    sub_80D1780(v25, &v27[6 * l]);
    v27[6 * l + 5] = *(*(dest + 198) + 4 * v15);
    *(*(dest + 198) + 4 * v15) = &v27[6 * l];
    sub_80CC2E6(v25);
  }
  v4 = dest;
  *(v4 + 193) = sub_8080055(ptr, 4 * v14);
  v5 = dest;
  v6 = sub_8065FC7(dword_8484374);
  *(v5 + 194) = sub_80800B1(ptr, 4 * v14, v6);
  v7 = dest;
  *(v7 + 193) = sub_8065FC7(*(dest + 193));
  v8 = dest;
  *(v8 + 194) = sub_8065FC7(*(dest + 194));
  sub_806BB25(ptr);
  *(dest + 199) = v27;
  return dest;
}
// 8484374: using guessed type int dword_8484374;

//----- (08063873) --------------------------------------------------------
int __cdecl sub_8063873(char *src, char *dest, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = 0;
  *dest = 0;
  v6 = 0;
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] == 47 || src[i] == 92 )
    {
      v6 = i;
      ++v4;
    }
  }
  strcpy(dest, src);
  dest[v6] = 0;
  if ( v6 + 1 == i )
    --v4;
  *a3 = v4;
  return v6;
}

//----- (08063901) --------------------------------------------------------
int __cdecl sub_8063901(char *s, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( a3 == 4095 )
    return 4095;
  for ( i = 0; i < a3; ++i )
  {
    if ( !sub_8086A5A(s, *(a2 + 4 * i)) )
      return a3;
  }
  *(a2 + 4 * a3) = sub_806BB76(s);
  return a3 + 1;
}

//----- (08063988) --------------------------------------------------------
void *__cdecl sub_8063988(char *s, char *a2, int a3, int a4)
{
  void *v5; // [esp+2Ch] [ebp-429Ch]
  char name[256]; // [esp+30h] [ebp-4298h] BYREF
  char dest[64]; // [esp+130h] [ebp-4198h] BYREF
  int v8; // [esp+170h] [ebp-4158h] BYREF
  void *ptr; // [esp+174h] [ebp-4154h]
  char *src; // [esp+178h] [ebp-4150h]
  int v11; // [esp+17Ch] [ebp-414Ch]
  char v12[268]; // [esp+180h] [ebp-4148h] BYREF
  int v13; // [esp+28Ch] [ebp-403Ch]
  int v14; // [esp+290h] [ebp-4038h]
  int v15; // [esp+294h] [ebp-4034h]
  int v16; // [esp+298h] [ebp-4030h] BYREF
  int v17; // [esp+29Ch] [ebp-402Ch]
  int v18; // [esp+2A0h] [ebp-4028h]
  int v19; // [esp+2A4h] [ebp-4024h]
  int j; // [esp+2A8h] [ebp-4020h]
  void *i; // [esp+2ACh] [ebp-401Ch]
  int v22[4098]; // [esp+2B0h] [ebp-4018h] BYREF
  _DWORD *v23; // [esp+42B8h] [ebp-10h]
  int v24; // [esp+42BCh] [ebp-Ch]

  sub_8060696();
  if ( s )
  {
    if ( !a2 )
      a2 = &byte_80DCF61;
    if ( *s == 47 || *s == 92 )
      ++s;
    v11 = sub_8086A5A(a2, "/") == 0;
    v19 = strlen(s);
    if ( v19 && (s[v19 - 1] == 92 || s[v19 - 1] == 47) )
      --v19;
    v18 = strlen(a2);
    v24 = 0;
    sub_8063873(s, v12, &v16);
    if ( *s )
      ++v16;
    for ( i = dword_80EF510; i; i = *i )
    {
      if ( sub_8060702(i) )
      {
        if ( *(i + 1) )
        {
          if ( *(i + 3) || sub_806069B(*(i + 1)) )
          {
            v14 = *(i + 1);
            v13 = *(v14 + 796);
            for ( j = 0; j < *(v14 + 780); ++j )
            {
              src = *(v13 + 24 * j + 16);
              if ( a3 )
              {
                if ( sub_806B926(a3, src, 0) )
                  v24 = sub_8063901(src, v22, v24);
              }
              else
              {
                ptr = sub_8063873(src, v12, &v8);
                if ( v8 == v16 && v19 <= ptr && (v19 <= 0 || src[v19] == 47) && !sub_8086946(src, s, v19) )
                {
                  v17 = strlen(src);
                  if ( v17 >= v18 && !sub_8086A5A(&src[v17 - v18], a2) )
                  {
                    v15 = v19;
                    if ( v19 )
                      ++v15;
                    if ( v11 )
                    {
                      strcpy(dest, &src[v15]);
                      dest[strlen(dest) - 1] = 0;
                      v24 = sub_8063901(dest, v22, v24);
                    }
                    else
                    {
                      v24 = sub_8063901(&src[v15], v22, v24);
                    }
                  }
                }
              }
            }
          }
        }
        else if ( *(i + 2) && (!*(dword_848437C + 32) && !dword_848436C || !sub_8086A5A(a2, "svg")) )
        {
          sub_8060B06(*(i + 2), (*(i + 2) + 256), s, name);
          ptr = sub_80CAC75(name, a2, a3, &v8, v11);
          for ( j = 0; j < v8; ++j )
          {
            src = *(ptr + j);
            v24 = sub_8063901(src, v22, v24);
          }
          sub_80CB004(ptr);
        }
      }
    }
    *a4 = v24;
    if ( v24 )
    {
      v23 = sub_806BB38(4 * v24 + 4);
      for ( j = 0; j < v24; ++j )
        v23[j] = v22[j];
      v23[j] = 0;
      v5 = v23;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    *a4 = 0;
    v5 = 0;
  }
  return v5;
}
// 848436C: using guessed type int dword_848436C;
// 848437C: using guessed type int dword_848437C;

//----- (08063EFC) --------------------------------------------------------
void *__cdecl sub_8063EFC(char *s, char *a2, int a3)
{
  return sub_8063988(s, a2, 0, a3);
}

//----- (08063F25) --------------------------------------------------------
void __cdecl sub_8063F25(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  sub_8060696();
  if ( ptr )
  {
    for ( i = 0; *(ptr + i); ++i )
      sub_806BB25(*(ptr + i));
    sub_806BB25(ptr);
  }
}

//----- (08063F80) --------------------------------------------------------
int __cdecl sub_8063F80(char *s, char *a2, char *dest, int a4)
{
  const char **ptr; // [esp+14h] [ebp-14h]
  size_t v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h] BYREF

  *dest = 0;
  v10 = 0;
  v8 = 0;
  if ( !sub_8086A5A(s, "$modlist") )
    return sub_8075464(dest, a4);
  ptr = sub_8063EFC(s, a2, &v10);
  for ( i = 0; i < v10; ++i )
  {
    v7 = strlen(ptr[i]) + 1;
    if ( (v8 + v7 + 1) >= a4 )
    {
      v10 = i;
      break;
    }
    strcpy(dest, ptr[i]);
    dest += v7;
    v8 += v7;
  }
  sub_8063F25(ptr);
  return v10;
}

//----- (0806407D) --------------------------------------------------------
_BYTE *__cdecl sub_806407D(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 92 || *a1 == 58 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (080640AA) --------------------------------------------------------
int __cdecl sub_80640AA(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( sub_80867AA(v5) )
      v5 -= 32;
    if ( sub_80867AA(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 < v4 )
      return -1;
    if ( v5 > v4 )
      return 1;
  }
  while ( v5 );
  return 0;
}

//----- (08064157) --------------------------------------------------------
void __cdecl sub_8064157(void *dest, int a2)
{
  _DWORD *ptr; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int k; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  ptr = sub_806BB38(4 * a2 + 4);
  *ptr = 0;
  v3 = 0;
  for ( i = 0; i < a2; ++i )
  {
    for ( j = 0; j < v3 && sub_80640AA(*(dest + i), ptr[j]) >= 0; ++j )
      ;
    for ( k = v3; k > j; --k )
      ptr[k] = ptr[k - 1];
    ptr[j] = *(dest + i);
    ++v3;
  }
  sub_80C835C(dest, ptr, 4 * a2);
  sub_806BB25(ptr);
}

//----- (08064271) --------------------------------------------------------
void __cdecl sub_8064271(int a1)
{
  int j; // [esp+10h] [ebp-8h]
  const char *i; // [esp+14h] [ebp-4h]

  if ( *(dword_8477A24 + 32) )
    Com_Printf("    localized assets are being ignored\n");
  Com_Printf("Current search path:\n");
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( !a1 || sub_8060702(i) )
    {
      if ( *(i + 1) )
      {
        Com_Printf("%s (%i files)\n", *(i + 1), *(*(i + 1) + 780));
        if ( dword_848436C )
        {
          if ( sub_806069B(*(i + 1)) )
            Com_Printf("    on the pure list\n");
          else
            Com_Printf("    not on the pure list\n");
        }
      }
      else
      {
        Com_Printf("%s/%s\n", *(i + 2), (*(i + 2) + 256));
      }
    }
  }
  Com_Printf("\nFile Handles:\n");
  for ( j = 1; j <= 63; ++j )
  {
    if ( dword_8477A40[72 * j] )
      Com_Printf("handle %i: %s\n", j, (288 * j + 138902112));
  }
}
// 8477A24: using guessed type int dword_8477A24;
// 8477A40: using guessed type int dword_8477A40[];
// 848436C: using guessed type int dword_848436C;

//----- (080643C4) --------------------------------------------------------
void sub_80643C4()
{
  sub_8064271(0);
}

//----- (080643D8) --------------------------------------------------------
void sub_80643D8()
{
  sub_8064271(0);
}

//----- (080643EC) --------------------------------------------------------
int __cdecl sub_80643EC(char *s)
{
  int v2; // [esp+14h] [ebp-4h]

  dword_80EF524 ^= 1u;
  if ( strlen(s) > 9 )
  {
    v2 = 10;
    memset(&byte_82384C0[64 * dword_80EF524], 0, 0x40u);
    while ( v2 <= 63 && s[v2] && (*(_ctype_b + 2 * s[v2]) & 0x400) != 0 )
    {
      byte_82384C0[64 * dword_80EF524 - 10 + v2] = s[v2];
      ++v2;
    }
  }
  else
  {
    byte_82384C0[64 * dword_80EF524] = 0;
  }
  return (dword_80EF524 << 6) + 136545472;
}
// 80EF524: using guessed type int dword_80EF524;
// 80FE1E8: using guessed type int _ctype_b;

//----- (080644B2) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  char *v4; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = *a1;
  v6 = *a2;
  if ( sub_80869EB(*a1, "          ", 10) || sub_80869EB(v6, "          ", 10) )
    return sub_80640AA(s, v6);
  v5 = sub_80643EC(s);
  v4 = sub_80643EC(v6);
  if ( sub_8086A5A(v5, "english") )
  {
    if ( !sub_8086A5A(v4, "english") )
      return 1;
    return sub_80640AA(s, v6);
  }
  if ( !sub_8086A5A(v4, "english") )
    return sub_80640AA(s, v6);
  return -1;
}

//----- (08064597) --------------------------------------------------------
_DWORD *__cdecl sub_8064597(_DWORD *a1)
{
  _DWORD *result; // eax
  void *i; // [esp+0h] [ebp-4h]

  if ( a1[3] && dword_80EF510 )
  {
    for ( i = dword_80EF510; *i && !*(*i + 12); i = *i )
      ;
    *a1 = *i;
    result = a1;
    *i = a1;
  }
  else
  {
    *a1 = dword_80EF510;
    result = a1;
    dword_80EF510 = a1;
  }
  return result;
}

//----- (080645FD) --------------------------------------------------------
void __cdecl sub_80645FD(char *a1, char *src)
{
  char *v2; // [esp+20h] [ebp-1128h]
  _DWORD *v3; // [esp+24h] [ebp-1124h]
  char *v4; // [esp+28h] [ebp-1120h]
  _DWORD *ptr; // [esp+2Ch] [ebp-111Ch]
  void *dest[1024]; // [esp+30h] [ebp-1118h] BYREF
  char s[256]; // [esp+1030h] [ebp-118h] BYREF
  int v8; // [esp+1130h] [ebp-18h]
  size_t nmemb; // [esp+1134h] [ebp-14h] BYREF
  int v10; // [esp+1138h] [ebp-10h]
  int i; // [esp+113Ch] [ebp-Ch]

  sub_8060B06(a1, src, &byte_80DCF61, s);
  s[strlen(s) - 1] = 0;
  ptr = sub_80CAC75(s, ".pk3", 0, &nmemb, 0);
  if ( nmemb > 1024 )
  {
    Com_Printf("WARNING: Exceeded max number of pak files in %s/%s (%1/%1)\n", a1, src, nmemb, 1024);
    nmemb = 1024;
  }
  for ( i = 0; i < nmemb; ++i )
  {
    dest[i] = ptr[i];
    if ( !sub_80869EB(dest[i], "localized_", 10) )
      memcpy(dest[i], "          ", 0xAu);
  }
  qsort(dest, nmemb, 4u, compar);
  for ( i = 0; i < nmemb; ++i )
  {
    if ( sub_80869EB(dest[i], "          ", 10) )
    {
      v8 = 0;
      v10 = 0;
LABEL_16:
      sub_8060B06(a1, src, dest[i], s);
      v2 = sub_80632B9(s, dest[i]);
      if ( v2 )
      {
        strcpy(v2 + 512, src);
        v3 = sub_806BB38(0x14u);
        v3[1] = v2;
        v3[3] = v8;
        v3[4] = v10;
        sub_8064597(v3);
      }
      continue;
    }
    memcpy(dest[i], "localized_", 0xAu);
    v8 = 1;
    v4 = sub_80643EC(dest[i]);
    if ( !*v4 )
    {
      Com_Printf(
        "WARNING: Localized assets pak file %s/%s/%s has invalid name (no language specified). Proper naming convention i"
        "s: localized_[language]_pak#.pk3\n",
        a1,
        src,
        dest[i]);
      continue;
    }
    if ( !sub_8086A5A(v4, "english") )
    {
      v10 = 0;
      goto LABEL_16;
    }
  }
  sub_80CB004(ptr);
}

//----- (0806490E) --------------------------------------------------------
void __cdecl sub_806490E(char *a1, char *src, int a3, int a4)
{
  _DWORD *v4; // ebx
  const char *v5; // [esp+4h] [ebp-184h]
  const char *v6; // [esp+8h] [ebp-180h]
  const char *v7; // [esp+2Ch] [ebp-15Ch]
  char s[260]; // [esp+30h] [ebp-158h] BYREF
  _DWORD *v9; // [esp+134h] [ebp-54h]
  void *i; // [esp+138h] [ebp-50h]
  const char *v11; // [esp+13Ch] [ebp-4Ch]
  char dest[72]; // [esp+140h] [ebp-48h] BYREF

  if ( a3 )
  {
    v11 = "english";
    Com_sprintf(dest, 0x40u, "%s_%s", src, "english");
  }
  else
  {
    Q_strncpyz(dest, src, 64);
  }
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( *(i + 2) && !sub_8086A5A(*(i + 2), a1) && !sub_8086A5A((*(i + 2) + 256), dest) )
    {
      if ( *(i + 3) != a3 )
      {
        if ( *(i + 3) )
          v7 = "localized";
        else
          v7 = "non-localized";
        Com_Printf(
          "WARNING: game folder %s/%s added as both localized & non-localized. Using folder as %s\n",
          a1,
          dest,
          v7);
      }
      if ( *(i + 3) )
      {
        if ( *(i + 4) != a4 )
          Com_Printf("WARNING: game golder %s/%s re-added as localized folder with different language\n", v5, v6);
      }
      return;
    }
  }
  if ( a3 )
  {
    sub_8060B06(a1, dest, &byte_80DCF61, s);
    s[strlen(s) - 1] = 0;
    if ( !sub_80C82C8(s) )
      return;
  }
  else
  {
    Q_strncpyz(byte_84885E0, dest, 256);
  }
  v9 = sub_806BB38(0x14u);
  v4 = v9;
  v4[2] = sub_806BB38(0x200u);
  Q_strncpyz(v9[2], a1, 256);
  Q_strncpyz((v9[2] + 256), dest, 256);
  v9[3] = a3;
  v9[4] = a4;
  sub_8064597(v9);
  sub_80645FD(a1, dest);
}
// 8064A36: variable 'v5' is possibly undefined
// 8064A36: variable 'v6' is possibly undefined

//----- (08064B58) --------------------------------------------------------
void __cdecl sub_8064B58(char *a1, char *src)
{
  sub_806490E(a1, src, 1, 0);
  sub_806490E(a1, src, 0, 0);
}

//----- (08064BA4) --------------------------------------------------------
void __cdecl sub_8064BA4(char *a1, int a2, char *a3, char *a4)
{
  size_t v4; // eax
  size_t v5; // eax
  char s[268]; // [esp+20h] [ebp-238h] BYREF
  _DWORD *v7; // [esp+12Ch] [ebp-12Ch]
  int v8; // [esp+130h] [ebp-128h]
  int v9; // [esp+134h] [ebp-124h]
  int i; // [esp+138h] [ebp-120h]
  char *src; // [esp+13Ch] [ebp-11Ch]
  _DWORD *v12; // [esp+140h] [ebp-118h]
  char *dest; // [esp+144h] [ebp-114h]
  void *ptr; // [esp+148h] [ebp-110h]
  int v15; // [esp+14Ch] [ebp-10Ch] BYREF
  char name[264]; // [esp+150h] [ebp-108h] BYREF

  sprintf(s, "%s/%s", a2, a3);
  sub_8060B06(a1, s, &byte_80DCF61, name);
  name[strlen(name) - 1] = 0;
  ptr = sub_80CAC75(name, a4, 0, &v15, 0);
  v9 = 0;
  for ( i = 0; i < v15; ++i )
  {
    v4 = strlen(*(ptr + i));
    v9 += v4 + 1;
  }
  for ( i = 1; i <= 1024 && i <= v15; i *= 2 )
    ;
  dest = sub_806BB38(4 * i + 276);
  *(dest + 65) = i;
  *(dest + 66) = dest + 276;
  for ( i = 0; i < *(dest + 65); ++i )
    *(*(dest + 66) + 4 * i) = 0;
  Q_strncpyz(dest, a3, 256);
  *(dest + 68) = dword_80EF514;
  dword_80EF514 = dest;
  *(dest + 64) = v15;
  v12 = sub_806BB38(v9 + 16 * v15);
  v7 = &v12[4 * v15];
  for ( i = 0; i < v15; ++i )
  {
    src = *(ptr + i);
    sub_8086A97(src);
    v8 = sub_806077A(src, *(dest + 65));
    v12[4 * i] = v7;
    strcpy(v12[4 * i], src);
    v5 = strlen(src);
    v7 = (v7 + v5 + 1);
    v12[4 * i + 3] = *(*(dest + 66) + 4 * v8);
    v12[4 * i + 1] = 0;
    v12[4 * i + 2] = 0;
    *(*(dest + 66) + 4 * v8) = &v12[4 * i];
  }
  *(dest + 67) = v12;
  sub_80CB004(ptr);
  sub_80C9010();
}

//----- (08064F6D) --------------------------------------------------------
char *__cdecl sub_8064F6D(char *a1, char *a2)
{
  char *result; // eax
  char *i; // [esp+14h] [ebp-4h]

  result = dword_80EF510;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( !*(i + 1) )
      sub_8064BA4(*(i + 2), *(i + 2) + 256, a1, a2);
    result = *i;
  }
  return result;
}

//----- (08064FC5) --------------------------------------------------------
int __cdecl sub_8064FC5(char *s2, int a2, int a3)
{
  char s[1036]; // [esp+30h] [ebp-428h] BYREF
  int v6; // [esp+43Ch] [ebp-1Ch]
  int k; // [esp+440h] [ebp-18h]
  int j; // [esp+444h] [ebp-14h]
  char *s1; // [esp+448h] [ebp-10h]
  int *i; // [esp+44Ch] [ebp-Ch]

  sprintf(s, "%s/%s%s", s2, a2, a3);
  for ( i = dword_80EF518; i; i = *i )
  {
    if ( sub_8060702(i) && i[1] )
    {
      v6 = sub_806077A(s, *(i[1] + 788));
      for ( j = *(*(i[1] + 792) + 4 * v6); j; j = *(j + 20) )
      {
        if ( !sub_806161E(*(j + 16), s) )
          return j + 4;
      }
    }
  }
  sprintf(s, "%s%s", a2, a3);
  for ( s1 = dword_80EF51C; s1; s1 = *(s1 + 68) )
  {
    if ( !strcasecmp(s1, s2) )
    {
      v6 = sub_806077A(s, *(s1 + 65));
      for ( k = *(*(s1 + 66) + 4 * v6); k; k = *(k + 12) )
      {
        if ( !sub_806161E(*k, s) )
          return k;
      }
    }
  }
  return 0;
}

//----- (08065197) --------------------------------------------------------
_DWORD *__cdecl sub_8065197(unsigned int a1, unsigned int a2)
{
  _DWORD *result; // eax
  int j; // [esp+4h] [ebp-14h]
  int m; // [esp+4h] [ebp-14h]
  int n; // [esp+8h] [ebp-10h]
  int k; // [esp+Ch] [ebp-Ch]
  _DWORD *l; // [esp+10h] [ebp-8h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  for ( i = dword_80EF518; i; i = *i )
  {
    if ( i[1] )
    {
      for ( j = 0; j < *(i[1] + 788); ++j )
      {
        for ( k = *(*(i[1] + 792) + 4 * j); k; k = *(k + 20) )
        {
          if ( *(k + 8) >= a1 && *(k + 8) < a2 )
          {
            if ( *(k + 12) )
            {
              (*(k + 12))(k + 4);
              *(k + 12) = 0;
            }
            *(k + 8) = 0;
          }
        }
      }
    }
  }
  result = dword_80EF51C;
  for ( l = dword_80EF51C; l; l = result )
  {
    for ( m = 0; m < l[65]; ++m )
    {
      for ( n = *(l[66] + 4 * m); n; n = *(n + 12) )
      {
        if ( *(n + 4) >= a1 && *(n + 4) < a2 )
        {
          if ( *(n + 8) )
          {
            (*(n + 8))(n);
            *(n + 8) = 0;
          }
          *(n + 4) = 0;
        }
      }
    }
    result = l[68];
  }
  return result;
}

//----- (08065316) --------------------------------------------------------
void *__cdecl sub_8065316(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = *ptr;
    if ( *(ptr + 1) )
    {
      sub_80CBC1C(*(*(ptr + 1) + 768));
      sub_806BB25(*(*(ptr + 1) + 796));
      sub_806BB25(*(ptr + 1));
    }
    if ( *(ptr + 2) )
      sub_806BB25(*(ptr + 2));
    sub_806BB25(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (08065398) --------------------------------------------------------
void *__cdecl sub_8065398(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = *(ptr + 68);
    sub_806BB25(*(ptr + 67));
    sub_806BB25(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (080653D9) --------------------------------------------------------
void *sub_80653D9()
{
  void *result; // eax

  if ( dword_80EF518 != dword_80EF510 )
  {
    sub_8065316(dword_80EF518);
    dword_80EF518 = dword_80EF510;
  }
  result = dword_80EF51C;
  if ( dword_80EF51C != dword_80EF514 )
  {
    sub_8065398(dword_80EF51C);
    result = dword_80EF514;
    dword_80EF51C = dword_80EF514;
  }
  return result;
}

//----- (08065429) --------------------------------------------------------
int sub_8065429()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_848436C )
      break;
    if ( *(&dword_84844C0 + i) )
      sub_806BB25(*(&dword_84844C0 + i));
    *(&dword_84844C0 + i) = 0;
  }
  dword_848436C = 0;
  return result;
}
// 848436C: using guessed type int dword_848436C;

//----- (08065483) --------------------------------------------------------
int sub_8065483()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8484368 )
      break;
    if ( *(&dword_8473A20 + i) )
      sub_806BB25(*(&dword_8473A20 + i));
    *(&dword_8473A20 + i) = 0;
  }
  dword_8484368 = 0;
  return result;
}
// 8484368: using guessed type int dword_8484368;

//----- (080654DD) --------------------------------------------------------
void __cdecl sub_80654DD(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 63; ++i )
  {
    if ( dword_8477A50[72 * i] )
      FS_FCloseFile(i);
  }
  if ( a1 )
  {
    sub_8065316(dword_80EF510);
    sub_8065398(dword_80EF514);
    dword_80EF518 = 0;
    dword_80EF51C = 0;
  }
  else
  {
    if ( dword_80EF518 != dword_80EF510 )
      sub_8065316(dword_80EF510);
    if ( dword_80EF51C != dword_80EF514 )
      sub_8065398(dword_80EF514);
  }
  dword_80EF510 = 0;
  dword_80EF514 = 0;
  sub_8060308("path");
  sub_8060308("fullpath");
  sub_8060308("dir");
  sub_8060308("fdir");
  sub_8060308("touchFile");
}
// 8477A50: using guessed type int dword_8477A50[];

//----- (080655D8) --------------------------------------------------------
void __cdecl sub_80655D8(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char *s2; // [esp+14h] [ebp-4h]

  Com_Printf("----- FS_Startup -----\n");
  *dword_80EF520 = 0;
  dword_8484380 = sub_8073114("fs_debug", "0", 0);
  dword_8484364 = sub_8073114("fs_copyfiles", "0", 16);
  v1 = sub_80CB0A5();
  dword_84844A0 = sub_8073114("fs_cdpath", v1, 16);
  v2 = sub_80CB0F7();
  dword_8480340 = sub_8073114("fs_basepath", v2, 16);
  dword_8484360 = sub_8073114("fs_basegame", "uo", 16);
  s2 = sub_80CB13F();
  if ( !s2 || !*s2 )
    s2 = *(dword_8480340 + 4);
  dword_8484370 = sub_8073114("fs_homepath", s2, 16);
  dword_8484384 = sub_8073114("fs_game", &byte_80DCF61, 24);
  dword_848437C = sub_8073114("fs_restrict", &byte_80DCF61, 16);
  dword_8477A24 = sub_8073114("fs_ignoreLozalized", "0", 544);
  if ( **(dword_84844A0 + 4) )
    sub_8064B58(*(dword_84844A0 + 4), src);
  if ( **(dword_8480340 + 4) )
    sub_8064B58(*(dword_8480340 + 4), src);
  if ( **(dword_8480340 + 4) && sub_8086A5A(*(dword_8484370 + 4), *(dword_8480340 + 4)) )
    sub_8064B58(*(dword_8484370 + 4), src);
  if ( **(dword_8484360 + 4) && !sub_8086A5A(src, "main") && sub_8086A5A(*(dword_8484360 + 4), src) )
  {
    if ( **(dword_84844A0 + 4) )
      sub_8064B58(*(dword_84844A0 + 4), *(dword_8484360 + 4));
    if ( **(dword_8480340 + 4) )
      sub_8064B58(*(dword_8480340 + 4), *(dword_8484360 + 4));
    if ( **(dword_8484370 + 4) && sub_8086A5A(*(dword_8484370 + 4), *(dword_8480340 + 4)) )
      sub_8064B58(*(dword_8484370 + 4), *(dword_8484360 + 4));
  }
  if ( **(dword_8484384 + 4) && !sub_8086A5A(src, "main") && sub_8086A5A(*(dword_8484384 + 4), src) )
  {
    if ( **(dword_84844A0 + 4) )
      sub_8064B58(*(dword_84844A0 + 4), *(dword_8484384 + 4));
    if ( **(dword_8480340 + 4) )
      sub_8064B58(*(dword_8480340 + 4), *(dword_8484384 + 4));
    if ( **(dword_8484370 + 4) && sub_8086A5A(*(dword_8484370 + 4), *(dword_8480340 + 4)) )
      sub_8064B58(*(dword_8484370 + 4), *(dword_8484384 + 4));
  }
  sub_8064F6D("xanim", &byte_80DCF61);
  sub_8064F6D("xmodel", &byte_80DCF61);
  sub_8064F6D("xmodelparts", &byte_80DCF61);
  sub_8064F6D("xmodelsurfs", &byte_80DCF61);
  sub_8064F6D("weapons", &byte_80DCF61);
  sub_8064F6D("animtrees", ".atr");
  sub_807136F();
  sub_80761EE();
  sub_80643D8();
  *(dword_8484384 + 20) = 0;
  Com_Printf("----------------------\n");
  Com_Printf("%d files in pk3 files\n", *dword_80EF520);
}
// 8477A24: using guessed type int dword_8477A24;
// 8480340: using guessed type int dword_8480340;
// 8484360: using guessed type int dword_8484360;
// 8484364: using guessed type int dword_8484364;
// 8484370: using guessed type int dword_8484370;
// 848437C: using guessed type int dword_848437C;
// 8484380: using guessed type int dword_8484380;
// 8484384: using guessed type int dword_8484384;
// 84844A0: using guessed type int dword_84844A0;

//----- (08065A4D) --------------------------------------------------------
_DWORD *__cdecl sub_8065A4D(int a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+0h] [ebp-4h]

  result = dword_80EF510;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] )
    {
      *(i[1] + 786) = 0;
      *(i[1] + 785) = 0;
      if ( !a1 )
      {
        *(i[1] + 784) = 0;
        *(i[1] + 787) = 0;
      }
    }
    result = *i;
  }
  return result;
}

//----- (08065AB2) --------------------------------------------------------
void *sub_8065AB2()
{
  sub_80707BC("fs_cdpath");
  sub_80707BC("fs_basepath");
  sub_80707BC("fs_homepath");
  sub_80707BC("fs_game");
  sub_80707BC("fs_copyfiles");
  sub_80707BC("fs_restrict");
  sub_80707BC("fs_usewolf");
  sub_80707BC("cl_language");
  sub_80655D8("main");
  sub_807625A();
  if ( sub_8062EB0("default_mp.cfg", 0) <= 0 )
    sub_80704AC(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  Q_strncpyz(&byte_84884C0, *(dword_8480340 + 4), 256);
  Q_strncpyz(&byte_847C240, *(dword_8484384 + 4), 256);
  return memset(&byte_84843A0, 0, 0x100u);
}
// 8480340: using guessed type int dword_8480340;
// 8484384: using guessed type int dword_8484384;

//----- (08065BBB) --------------------------------------------------------
char *__cdecl sub_8065BBB(int a1)
{
  char *v1; // eax

  sub_80654DD(0);
  dword_8484374 = a1;
  sub_8065A4D(0);
  sub_80655D8("main");
  sub_807625A();
  if ( sub_8062EB0("default_mp.cfg", 0) <= 0 )
  {
    if ( byte_84884C0 )
    {
      sub_807683D(&byte_80DCF61, &byte_80DCF61);
      sub_8073798("fs_basepath", &byte_84884C0);
      sub_8073798("fs_gamedirvar", &byte_847C240);
      byte_84884C0 = 0;
      byte_847C240 = 0;
      sub_8073798("fs_restrict", "0");
      sub_8065BBB(a1);
      sub_80704AC(1, "Invalid game folder\n");
    }
    sub_80704AC(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  }
  if ( sub_8086A5A(*(dword_8484384 + 4), &byte_847C240) && !sub_8070717() )
  {
    v1 = sub_8086D78("exec %s\n", "uoconfig_mp_server.cfg");
    sub_805F9FA(v1);
  }
  Q_strncpyz(&byte_84884C0, *(dword_8480340 + 4), 256);
  return Q_strncpyz(&byte_847C240, *(dword_8484384 + 4), 256);
}
// 8480340: using guessed type int dword_8480340;
// 8484374: using guessed type int dword_8484374;
// 8484384: using guessed type int dword_8484384;

//----- (08065D85) --------------------------------------------------------
int __cdecl sub_8065D85(char *src, int a2, int a3)
{
  int v3; // ebx
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v6 = 0;
  if ( a3 == 1 )
  {
    *a2 = sub_80611FB(src);
    v7 = 0;
    if ( !*a2 )
      v7 = -1;
  }
  else if ( a3 )
  {
    if ( a3 != 2 )
    {
      if ( a3 != 3 )
        sub_80704AC(0, &byte_80DD6ED);
      v6 = 1;
    }
    *a2 = sub_80614BF(src);
    v7 = 0;
    if ( !*a2 )
      v7 = -1;
  }
  else
  {
    v7 = sub_8062558(src, a2, 1);
  }
  if ( !a2 )
    return v7;
  if ( *a2 )
  {
    v3 = 72 * *a2;
    if ( dword_8477A58[v3] )
      dword_8477A4C[v3] = sub_80CCD02(dword_8477A40[72 * *a2]);
    else
      dword_8477A4C[v3] = ftell(dword_8477A40[72 * *a2]);
    dword_8477A50[72 * *a2] = v7;
    dword_8477A5C[72 * *a2] = 0;
  }
  dword_8477A48[72 * *a2] = v6;
  return v7;
}
// 8477A40: using guessed type int dword_8477A40[];
// 8477A48: using guessed type int dword_8477A48[];
// 8477A4C: using guessed type int dword_8477A4C[];
// 8477A50: using guessed type int dword_8477A50[];
// 8477A58: using guessed type int dword_8477A58[];

//----- (08065FA4) --------------------------------------------------------
int __cdecl sub_8065FA4(int a1)
{
  return fflush(dword_8477A40[72 * a1]);
}
// 8477A40: using guessed type int dword_8477A40[];

//----- (08065FC7) --------------------------------------------------------
int __cdecl sub_8065FC7(int a1)
{
  return a1;
}

//----- (08065FD0) --------------------------------------------------------
int __cdecl sub_8065FD0(int a1)
{
  *a1 = 69069 * *a1 + 1;
  return *a1;
}

//----- (08065FEB) --------------------------------------------------------
long double __cdecl sub_8065FEB(int a1)
{
  return sub_8065FD0(a1) / 65536.0;
}

//----- (080660AF) --------------------------------------------------------
long double __cdecl sub_80660AF(float a1)
{
  float v3; // [esp+Ch] [ebp-8h]

  v3 = a1 * 0.5;
  return ((1.5 - v3 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
        * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (080665E0) --------------------------------------------------------
long double __cdecl sub_80665E0(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  v5 = a2[2] - a1[2];
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (080666B1) --------------------------------------------------------
float *__cdecl sub_80666B1(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = a1 + 1;
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (08066755) --------------------------------------------------------
long double __cdecl sub_8066755(float *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (080669A0) --------------------------------------------------------
long double __cdecl sub_80669A0(float *a1, float *a2)
{
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+20h] [ebp-8h]

  v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sqrt(v4);
  if ( v5 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    v3 = 1.0 / v5;
    *a2 = *a1 * v3;
    a2[1] = a1[1] * v3;
    a2[2] = a1[2] * v3;
  }
  return v5;
}

//----- (08066A5E) --------------------------------------------------------
unsigned int __cdecl sub_8066A5E(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (08066BF8) --------------------------------------------------------
float *__cdecl sub_8066BF8(int a1, int a2, int a3, float a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-13Ch]
  float v6; // [esp+20h] [ebp-138h] BYREF
  float v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9[4]; // [esp+30h] [ebp-128h] BYREF
  int v10[7]; // [esp+40h] [ebp-118h] BYREF
  int i; // [esp+5Ch] [ebp-FCh] BYREF
  float v12[12]; // [esp+60h] [ebp-F8h] BYREF
  float v13[12]; // [esp+90h] [ebp-C8h] BYREF
  int s; // [esp+C0h] [ebp-98h] BYREF
  int v15[3]; // [esp+C4h] [ebp-94h] BYREF
  int v16; // [esp+D0h] [ebp-88h]
  int v17; // [esp+E0h] [ebp-78h]
  float dest[12]; // [esp+F0h] [ebp-68h] BYREF
  int src; // [esp+120h] [ebp-38h] BYREF
  int v20; // [esp+124h] [ebp-34h]
  float v21; // [esp+128h] [ebp-30h]
  int v22; // [esp+12Ch] [ebp-2Ch]
  int v23; // [esp+130h] [ebp-28h]
  float v24; // [esp+134h] [ebp-24h]
  int v25; // [esp+138h] [ebp-20h]
  int v26; // [esp+13Ch] [ebp-1Ch]
  int v27; // [esp+140h] [ebp-18h]
  _DWORD v28[2]; // [esp+150h] [ebp-8h] BYREF

  v6 = *a2;
  v7 = *(a2 + 4);
  v8 = *(a2 + 8);
  sub_80676B4(v10, a2);
  sub_80666B1(v10, &v6, v9);
  src = v10[0];
  v22 = v10[1];
  v25 = v10[2];
  v20 = v9[0];
  v23 = v9[1];
  v26 = v9[2];
  v21 = v6;
  v24 = v7;
  v27 = v8;
  memcpy(dest, &src, 0x24u);
  LODWORD(dest[1]) = v22;
  LODWORD(dest[2]) = v25;
  LODWORD(dest[3]) = v20;
  LODWORD(dest[5]) = v26;
  dest[6] = v21;
  dest[7] = v24;
  memset(&s, 0, 0x24u);
  v17 = 1065353216;
  v16 = 1065353216;
  s = 1065353216;
  v5 = a4 * 3.141592653589793 / 180.0;
  sub_806B4DE(v5, v15, &s);
  v15[2] = v15[0] ^ 0x80000000;
  v16 = s;
  sub_80678FC(&src, &s, v13);
  result = sub_80678FC(v13, dest, v12);
  for ( i = 0; i <= 2; ++i )
  {
    *(a1 + 4 * i) = v12[3 * i] * *a3 + *&v28[3 * i - 59] * *(a3 + 4) + *&v28[3 * i - 58] * *(a3 + 8);
    result = &i;
  }
  return result;
}

//----- (080670EE) --------------------------------------------------------
long double __cdecl sub_80670EE(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = 270.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      v2 = v2 + 360.0;
  }
  return v2;
}

//----- (080671BE) --------------------------------------------------------
long double __cdecl sub_80671BE(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = -90.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
  }
  return v2;
}

//----- (08067272) --------------------------------------------------------
int __cdecl sub_8067272(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = 270.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
    if ( v3 < 0.0 )
      v3 = v3 + 360.0;
  }
  *a2 = v3;
  *(a2 + 4) = v4;
  result = a2 + 8;
  *(a2 + 8) = 0;
  return result;
}

//----- (080673AD) --------------------------------------------------------
int __cdecl sub_80673AD(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = -90.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
  }
  *a2 = v3;
  *(a2 + 4) = v4;
  result = a2 + 8;
  *(a2 + 8) = 0;
  return result;
}

//----- (080674AD) --------------------------------------------------------
float *__cdecl sub_80674AD(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-1Ch] BYREF
  float v6; // [esp+20h] [ebp-18h] BYREF
  float v7; // [esp+24h] [ebp-14h] BYREF
  float v8; // [esp+28h] [ebp-10h] BYREF
  float v9; // [esp+2Ch] [ebp-Ch] BYREF
  float v10; // [esp+30h] [ebp-8h] BYREF
  float v11; // [esp+34h] [ebp-4h]

  v11 = a1[1] * 0.0174532925199433;
  sub_806B4DE(v11, &v8, &v5);
  v11 = *a1 * 0.0174532925199433;
  result = sub_806B4DE(v11, &v9, &v6);
  if ( a2 )
  {
    *a2 = v6 * v5;
    *(a2 + 4) = v6 * v8;
    result = (LODWORD(v9) ^ 0x80000000);
    *(a2 + 8) = LODWORD(v9) ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v11 = a1[2] * 0.0174532925199433;
    result = sub_806B4DE(v11, &v10, &v7);
    if ( a3 )
    {
      *a3 = v10 * -1.0 * v9 * v5 + v7 * -1.0 * -v8;
      a3[1] = v10 * -1.0 * v9 * v8 + v7 * -1.0 * v5;
      result = a3 + 2;
      a3[2] = v10 * -1.0 * v6;
    }
    if ( a4 )
    {
      *a4 = v7 * v9 * v5 + v10 * v8;
      a4[1] = v7 * v9 * v8 + -v10 * v5;
      result = a4 + 2;
      a4[2] = v7 * v6;
    }
  }
  return result;
}

//----- (08067636) --------------------------------------------------------
float *__cdecl sub_8067636(float a1, int a2, int a3)
{
  float *result; // eax
  int v4; // [esp+1Ch] [ebp-Ch] BYREF
  int v5; // [esp+20h] [ebp-8h] BYREF
  float v6; // [esp+24h] [ebp-4h]

  v6 = a1 * 0.0174532925199433;
  result = sub_806B4DE(v6, &v5, &v4);
  if ( a2 )
  {
    *a2 = v4;
    *(a2 + 4) = v5;
    result = (a2 + 8);
    *(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *a3 = v5;
    *(a3 + 4) = v4 ^ 0x80000000;
    result = (a3 + 8);
    *(a3 + 8) = 0;
  }
  return result;
}

//----- (080676B4) --------------------------------------------------------
void __cdecl sub_80676B4(float *a1, float *a2)
{
  int v2[5]; // [esp+20h] [ebp-28h] BYREF
  float v3; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v3 = 1.0;
  v5 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v3 > fabs(a2[i]) )
    {
      v3 = fabs(a2[i]);
      v5 = i;
    }
  }
  v2[2] = 0;
  v2[1] = 0;
  v2[0] = 0;
  v2[v5] = 1065353216;
  sub_806AA4E(a1, v2, a2);
  sub_8066755(a1);
}

//----- (080678FC) --------------------------------------------------------
float *__cdecl sub_80678FC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = a1 + 8;
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (0806881D) --------------------------------------------------------
int __cdecl sub_806881D(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (080688AC) --------------------------------------------------------
float *__cdecl sub_80688AC(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-4h]
  float v4; // [esp+0h] [ebp-4h]

  v3 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v4 = 1.0 / v3;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v4;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v4;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v4;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v4;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v4;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v4;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v4;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v4;
  result = a1 + 3;
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v4;
  return result;
}

//----- (08069154) --------------------------------------------------------
float *__cdecl sub_8069154(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080691FE) --------------------------------------------------------
float *__cdecl sub_80691FE(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (08069416) --------------------------------------------------------
float *__cdecl sub_8069416(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[9];
  v5 = a1[1] - a2[10];
  v6 = a1[2] - a2[11];
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = a2 + 8;
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (0806960C) --------------------------------------------------------
float *__cdecl sub_806960C(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = a1 + 2;
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (0806972E) --------------------------------------------------------
unsigned int __cdecl sub_806972E(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0806998F) --------------------------------------------------------
long double __cdecl sub_806998F(float *a1)
{
  float v3; // [esp+4h] [ebp-10h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-Ch]
  float v7; // [esp+Ch] [ebp-8h]
  float v8; // [esp+Ch] [ebp-8h]
  float v9; // [esp+10h] [ebp-4h]
  float v10; // [esp+10h] [ebp-4h]

  v9 = *a1 * *a1;
  v7 = a1[1] * a1[1];
  v5 = a1[2] * a1[2];
  v3 = v9 + v7 + v5 + a1[3] * a1[3];
  if ( v3 == 0.0 )
    return 0.0;
  v4 = 1.0 / v3;
  v10 = v9 * v4;
  v8 = v7 * v4;
  v6 = v5 * v4;
  return (v10 + v8 + v6);
}

//----- (08069E5B) --------------------------------------------------------
long double __cdecl sub_8069E5B(float a1, float a2)
{
  float i; // [esp+4h] [ebp-4h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (08069F27) --------------------------------------------------------
long double __cdecl sub_8069F27(float a1)
{
  return (a1 * 182.04445) * 0.0054931641;
}

//----- (08069F6A) --------------------------------------------------------
long double __cdecl sub_8069F6A(float a1)
{
  float v2; // [esp+14h] [ebp-4h]

  v2 = sub_8069F27(a1);
  if ( v2 > 180.0 )
    v2 = v2 - 360.0;
  return v2;
}

//----- (0806A0C3) --------------------------------------------------------
long double __cdecl sub_806A0C3(int a1, int a2)
{
  float v3; // [esp+2Ch] [ebp-3Ch]
  float v5; // [esp+38h] [ebp-30h]
  float v6; // [esp+3Ch] [ebp-2Ch]
  float v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+44h] [ebp-24h]
  float v9; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v6 = fabs(*(a1 + 4 * i));
    v5 = fabs(*(a2 + 4 * i));
    if ( v6 <= v5 )
      v3 = v5;
    else
      v3 = v6;
    *(&v7 + i) = v3;
  }
  return sqrt(v7 * v7 + v8 * v8 + v9 * v9);
}

//----- (0806A164) --------------------------------------------------------
int __cdecl sub_806A164(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[2] = 1216348160;
  a1[1] = 1216348160;
  *a1 = 1216348160;
  result = -931135488;
  a2[2] = -931135488;
  a2[1] = -931135488;
  *a2 = -931135488;
  return result;
}

//----- (0806A19F) --------------------------------------------------------
void __cdecl sub_806A19F(float *a1, float *a2, float *a3)
{
  if ( *a2 > *a1 )
    *a2 = *a1;
  if ( *a1 > *a3 )
    *a3 = *a1;
  if ( a2[1] > a1[1] )
    a2[1] = a1[1];
  if ( a1[1] > a3[1] )
    a3[1] = a1[1];
  if ( a2[2] > a1[2] )
    a2[2] = a1[2];
  if ( a1[2] > a3[2] )
    a3[2] = a1[2];
}

//----- (0806A46E) --------------------------------------------------------
float *__cdecl sub_806A46E(float *a1, float *a2)
{
  float *result; // eax
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  sub_80674AD(a1, a2, v3, a2 + 6);
  a2[3] = 0.0 - v3[0];
  a2[4] = 0.0 - v3[1];
  result = a2 + 5;
  a2[5] = 0.0 - v3[2];
  return result;
}

//----- (0806A964) --------------------------------------------------------
int __cdecl sub_806A964(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  v7[0] = *a3 - *a2;
  v7[1] = a3[1] - a2[1];
  v7[2] = a3[2] - a2[2];
  v6[0] = *a4 - *a2;
  v6[1] = a4[1] - a2[1];
  v6[2] = a4[2] - a2[2];
  sub_80666B1(v6, v7, a1);
  if ( sub_8066755(a1) == 0.0 )
    return 0;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return 1;
}

//----- (0806AA4E) --------------------------------------------------------
float *__cdecl sub_806AA4E(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+Ch] [ebp-2Ch]
  float v6; // [esp+10h] [ebp-28h]
  float v7; // [esp+14h] [ebp-24h]
  float v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-Ch]

  v4 = *a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2];
  v5 = 1.0 / v4;
  v9 = (*a3 * *a2 + a3[1] * a2[1] + a3[2] * a2[2]) * v5;
  v6 = *a3 * v5;
  v7 = a3[1] * v5;
  v8 = a3[2] * v5;
  *a1 = *a2 - v9 * v6;
  a1[1] = a2[1] - v9 * v7;
  result = a2 + 2;
  a1[2] = a2[2] - v9 * v8;
  return result;
}

//----- (0806AB7E) --------------------------------------------------------
_BOOL4 __cdecl sub_806AB7E(int a1, int a2, int a3, float a4)
{
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+4h] [ebp-44h]
  float v7; // [esp+8h] [ebp-40h]
  float v8; // [esp+Ch] [ebp-3Ch]
  float v9[4]; // [esp+10h] [ebp-38h]
  float v10[7]; // [esp+20h] [ebp-28h]
  int i; // [esp+3Ch] [ebp-Ch]

  v10[0] = *a1 - *a3;
  v10[1] = *(a1 + 4) - *(a3 + 4);
  v10[2] = *(a1 + 8) - *(a3 + 8);
  v9[0] = *a2 - *a3;
  v9[1] = *(a2 + 4) - *(a3 + 4);
  v9[2] = *(a2 + 8) - *(a3 + 8);
  v8 = 0.0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v10[i] * v9[i] > 0.0 )
    {
      v7 = v10[i] * v10[i];
      v6 = v9[i] * v9[i];
      if ( v7 <= v6 )
        v5 = v8 + v7;
      else
        v5 = v8 + v6;
      v8 = v5;
    }
  }
  return v8 > a4;
}

//----- (0806AF24) --------------------------------------------------------
int __cdecl sub_806AF24(int *a1, int a2, _DWORD *a3)
{
  int result; // eax
  double v4; // [esp+20h] [ebp-68h] BYREF
  double v5; // [esp+28h] [ebp-60h] BYREF
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9[7]; // [esp+44h] [ebp-44h]
  int v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  int v12; // [esp+68h] [ebp-20h]
  int v13; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]

  v10 = *a1;
  v11 = a1[1];
  v12 = a1[2];
  v13 = v10;
  v14 = v11;
  v15 = v12;
  v8 = 1;
  v9[0] = 2;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(a2 + 4 * i) != 0.0 )
    {
      v6 = *(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_806B4F6(v6, &v4, &v5);
      *(&v13 + *(&v8 + 2 * i)) = *(&v10 + *(&v8 + 2 * i)) * v5 - *(&v10 + v9[2 * i]) * v4;
      *(&v13 + v9[2 * i]) = *(&v10 + *(&v8 + 2 * i)) * v4 + *(&v10 + v9[2 * i]) * v5;
    }
    v10 = v13;
    v11 = v14;
    v12 = v15;
  }
  *a3 = v13;
  a3[1] = v14;
  result = v15;
  a3[2] = v15;
  return result;
}

//----- (0806B4DE) --------------------------------------------------------
float *__cdecl sub_806B4DE(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0806B4F6) --------------------------------------------------------
double *__cdecl sub_806B4F6(double a1, double *a2, double *a3)
{
  long double v3; // fst7
  double *result; // eax

  *a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *a3 = v3;
  return result;
}

//----- (0806B538) --------------------------------------------------------
char *__cdecl sub_806B538(char *s, char *a2, int a3)
{
  size_t v3; // ebx
  int v4; // ebx
  int j; // [esp+8h] [ebp-10h]
  signed int i; // [esp+Ch] [ebp-Ch]
  signed int v9; // [esp+10h] [ebp-8h]

  v3 = strlen(s);
  v9 = v3 - strlen(a2);
  for ( i = 0; i <= v9; ++i )
  {
    for ( j = 0; a2[j]; ++j )
    {
      if ( a3 )
      {
        if ( s[j] != a2[j] )
          break;
      }
      else
      {
        v4 = toupper(s[j]);
        if ( v4 != toupper(a2[j]) )
          break;
      }
    }
    if ( !a2[j] )
      return s;
    ++s;
  }
  return 0;
}

//----- (0806B606) --------------------------------------------------------
int __cdecl sub_806B606(int a1, char *a2, int a3)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v9; // [esp+14h] [ebp-414h]
  int v10; // [esp+18h] [ebp-410h]
  char *v11; // [esp+1Ch] [ebp-40Ch]
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  char *v13; // [esp+430h] [ebp+8h]

  while ( *a1 )
  {
    if ( *a1 == 42 )
    {
      ++a1;
      v10 = 0;
      while ( *a1 && *a1 != 42 && *a1 != 63 )
        s[v10++] = *a1++;
      s[v10] = 0;
      if ( s[0] )
      {
        v11 = sub_806B538(a2, s, a3);
        if ( !v11 )
          return 0;
        a2 = &v11[strlen(s)];
      }
    }
    else if ( *a1 == 63 )
    {
      ++a1;
      ++a2;
    }
    else if ( *a1 == 91 && *(a1 + 1) == 91 )
    {
      ++a1;
    }
    else if ( *a1 == 91 )
    {
      v13 = (a1 + 1);
      v9 = 0;
      while ( *v13 && !v9 && (*v13 != 93 || v13[1] == 93) )
      {
        if ( v13[1] == 45 && v13[2] && (v13[2] != 93 || v13[3] == 93) )
        {
          if ( a3 )
          {
            if ( *a2 >= *v13 && *a2 <= v13[2] )
              v9 = 1;
          }
          else
          {
            v3 = toupper(*a2);
            if ( v3 >= toupper(*v13) )
            {
              v4 = toupper(*a2);
              if ( v4 <= toupper(v13[2]) )
                v9 = 1;
            }
          }
          v13 += 3;
        }
        else
        {
          if ( a3 )
          {
            if ( *v13 == *a2 )
              v9 = 1;
          }
          else
          {
            v5 = toupper(*v13);
            if ( v5 == toupper(*a2) )
              v9 = 1;
          }
          ++v13;
        }
      }
      if ( !v9 )
        return 0;
      while ( *v13 && (*v13 != 93 || v13[1] == 93) )
        ++v13;
      a1 = (v13 + 1);
      ++a2;
    }
    else
    {
      if ( a3 )
      {
        if ( *a1 != *a2 )
          return 0;
      }
      else
      {
        v6 = toupper(*a1);
        if ( v6 != toupper(*a2) )
          return 0;
      }
      ++a1;
      ++a2;
    }
  }
  return 1;
}

//----- (0806B926) --------------------------------------------------------
int __cdecl sub_806B926(int a1, int a2, int a3)
{
  char v4[64]; // [esp+10h] [ebp-98h] BYREF
  _BYTE v5[76]; // [esp+50h] [ebp-58h] BYREF
  int i; // [esp+9Ch] [ebp-Ch]

  for ( i = 0; i <= 62 && *(a1 + i); ++i )
  {
    if ( *(a1 + i) == 92 || *(a1 + i) == 58 )
      v5[i] = 47;
    else
      v5[i] = *(a1 + i);
  }
  v5[i] = 0;
  for ( i = 0; i <= 62 && *(a2 + i); ++i )
  {
    if ( *(a2 + i) == 92 || *(a2 + i) == 58 )
      v4[i] = 47;
    else
      v4[i] = *(a2 + i);
  }
  v4[i] = 0;
  return sub_806B606(v5, v4, a3);
}

//----- (0806BA16) --------------------------------------------------------
int __cdecl sub_806BA16(int a1, int a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < a2 && *(i + a1); ++i )
    v4 += *(i + a1) * (i + 119);
  return (v4 >> 20) ^ (v4 >> 10) ^ v4;
}

//----- (0806BA76) --------------------------------------------------------
time_t __cdecl sub_806BA76(int *a1)
{
  struct tm *v3; // [esp+10h] [ebp-8h]
  time_t timer; // [esp+14h] [ebp-4h] BYREF

  timer = time(0);
  if ( !a1 )
    return timer;
  v3 = localtime(&timer);
  if ( v3 )
  {
    *a1 = v3->tm_sec;
    a1[1] = v3->tm_min;
    a1[2] = v3->tm_hour;
    a1[3] = v3->tm_mday;
    a1[4] = v3->tm_mon;
    a1[5] = v3->tm_year;
    a1[6] = v3->tm_wday;
    a1[7] = v3->tm_yday;
    a1[8] = v3->tm_isdst;
  }
  return timer;
}

//----- (0806BB25) --------------------------------------------------------
void __cdecl sub_806BB25(void *ptr)
{
  free(ptr);
}

//----- (0806BB38) --------------------------------------------------------
void *__cdecl sub_806BB38(size_t size)
{
  void *s; // [esp+14h] [ebp-4h]

  s = malloc(size);
  if ( !s )
    sub_80C902E();
  sub_80C837D(s, 0, size);
  return s;
}
// 80C902E: using guessed type int sub_80C902E(void);

//----- (0806BB76) --------------------------------------------------------
char *__cdecl sub_806BB76(char *s)
{
  size_t v1; // eax
  char *dest; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  dest = sub_806BB38(v1 + 1);
  strcpy(dest, s);
  return dest;
}

//----- (0806BBAA) --------------------------------------------------------
void sub_806BBAA()
{
  Com_Printf("%8i bytes total hunk\n", *dword_8238568);
  Com_Printf("%8i bytes total zone\n", *dword_823856C);
  Com_Printf("\n");
  Com_Printf("%8i low mark\n", *dword_8238548);
  Com_Printf("%8i low permanent\n", *dword_8238550);
  if ( *dword_8238554 != *dword_8238550 )
    Com_Printf("%8i low temp\n", *dword_8238554);
  Com_Printf("\n");
  Com_Printf("%8i high mark\n", *dword_8238558);
  Com_Printf("%8i high permanent\n", *dword_8238560);
  if ( *dword_8238564 != *dword_8238560 )
    Com_Printf("%8i high temp\n", *dword_8238564);
  Com_Printf("\n");
  Com_Printf("%8i total hunk in use\n", *dword_8238550 + *dword_8238560);
  Com_Printf("\n");
}

//----- (0806BD7F) --------------------------------------------------------
void sub_806BD7F()
{
  ;
}

//----- (0806C0C7) --------------------------------------------------------
void sub_806C0C7()
{
  int v0; // [esp+18h] [ebp-10h]
  char *format; // [esp+1Ch] [ebp-Ch]
  int v2; // [esp+20h] [ebp-8h]
  int *v3; // [esp+24h] [ebp-4h]

  if ( sub_80606F8() )
    sub_80704AC(0, &byte_80DDB00);
  v3 = sub_8073114("com_hunkMegs", "128", 33);
  if ( dword_84886E0 && *(dword_84886E0 + 32) )
  {
    v2 = 1;
    format = "Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n";
  }
  else
  {
    v2 = 80;
    format = "Minimum com_hunkMegs is %i, allocating %i megs.\n";
  }
  if ( v3[8] >= v2 )
  {
    *dword_8238568 = v3[8] << 20;
  }
  else
  {
    *dword_8238568 = v2 << 20;
    v0 = v2 << 20;
    if ( (v2 & 0x800) != 0 )
      v0 += 0xFFFFF;
    Com_Printf(format, v2, v0 >> 20);
  }
  dword_80EFCDC = malloc(*dword_8238568 + 31);
  if ( !dword_80EFCDC )
    sub_80C902E();
  ptr = dword_80EFCDC;
  dword_80EFCDC = (dword_80EFCDC + 31) & 0xFFFFFFE0;
  sub_806C394();
  sub_8060272("meminfo", sub_806BBAA);
}
// 80C902E: using guessed type int sub_80C902E(void);
// 80EFCDC: using guessed type int dword_80EFCDC;
// 84886E0: using guessed type int dword_84886E0;

//----- (0806C1F1) --------------------------------------------------------
int sub_806C1F1()
{
  return *dword_8238568 - (*dword_8238564 + *dword_8238554);
}

//----- (0806C20A) --------------------------------------------------------
_DWORD *sub_806C20A()
{
  unsigned int v1; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = dword_80EFCDC + *dword_8238550;
  v1 = dword_80EFCDC + *dword_8238568 - *dword_8238560;
  sub_80C3E74(dword_80EFCDC + *dword_8238550, v1);
  return sub_8065197(v2, v1);
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C267) --------------------------------------------------------
int sub_806C267()
{
  int result; // eax

  result = *dword_8238560;
  dword_823855C = *dword_8238560;
  return result;
}
// 823855C: using guessed type int dword_823855C;

//----- (0806C2B1) --------------------------------------------------------
_DWORD *sub_806C2B1()
{
  *dword_8238564 = dword_823855C;
  *dword_8238560 = dword_823855C;
  return sub_806C20A();
}
// 823855C: using guessed type int dword_823855C;

//----- (0806C2F1) --------------------------------------------------------
int sub_806C2F1()
{
  int result; // eax

  result = *dword_8238550;
  *dword_8238548 = *dword_8238550;
  return result;
}

//----- (0806C300) --------------------------------------------------------
_DWORD *sub_806C300()
{
  *dword_8238554 = *dword_8238548;
  *dword_8238550 = *dword_8238548;
  return sub_806C20A();
}

//----- (0806C31C) --------------------------------------------------------
void *sub_806C31C()
{
  char v1; // [esp+4h] [ebp-4h]

  *dword_8238548 = 0;
  dword_823854C = 0;
  *dword_8238550 = 0;
  *dword_8238554 = 0;
  *dword_8238558 = 0;
  dword_823855C = 0;
  *dword_8238560 = 0;
  *dword_8238564 = 0;
  dword_84886E4 = 0;
  Com_Printf("Hunk_Clear: reset the hunk ok\n", v1);
  sub_806C20A();
  return sub_80653D9();
}
// 806C383: variable 'v1' is possibly undefined
// 823854C: using guessed type int dword_823854C;
// 823855C: using guessed type int dword_823855C;
// 84886E4: using guessed type int dword_84886E4;

//----- (0806C394) --------------------------------------------------------
int *sub_806C394()
{
  sub_8090B57();
  sub_806C31C();
  return sub_809BF2B();
}
// 8090B57: using guessed type int sub_8090B57(void);

//----- (0806C3AB) --------------------------------------------------------
void sub_806C3AB()
{
  free(ptr);
  dword_80EFCDC = 0;
  ptr = 0;
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C3D4) --------------------------------------------------------
void *__cdecl sub_806C3D4(size_t n)
{
  return sub_806C3EF(n, 32);
}

//----- (0806C3EF) --------------------------------------------------------
void *__cdecl sub_806C3EF(size_t n, int a2)
{
  void *s; // [esp+14h] [ebp-4h]
  int v4; // [esp+24h] [ebp+Ch]

  v4 = a2 - 1;
  if ( !dword_80EFCDC )
    sub_80704AC(0, &byte_80DDC20);
  *dword_8238560 += n;
  *dword_8238560 = (v4 + *dword_8238560) & ~v4;
  s = (dword_80EFCDC + *dword_8238568 - *dword_8238560);
  *dword_8238564 = *dword_8238560;
  if ( *dword_8238554 + *dword_8238560 > *dword_8238568 )
  {
    sub_806BBAA();
    sub_80704AC(1, &byte_80DDC55, n);
  }
  dword_84886E4 = *dword_8238550 + *dword_8238560;
  memset(s, 0, n);
  return s;
}
// 80EFCDC: using guessed type int dword_80EFCDC;
// 84886E4: using guessed type int dword_84886E4;

//----- (0806C4B7) --------------------------------------------------------
int __cdecl sub_806C4B7(int a1)
{
  *dword_8238564 += a1;
  *dword_8238564 = (*dword_8238564 + 15) & 0xFFFFFFF0;
  if ( *dword_8238554 + *dword_8238564 > *dword_8238568 )
  {
    sub_806BBAA();
    sub_80704AC(1, &byte_80DDC80, a1);
  }
  return dword_80EFCDC + *dword_8238568 - *dword_8238564;
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C522) --------------------------------------------------------
int sub_806C522()
{
  int result; // eax

  result = *dword_8238560;
  *dword_8238564 = *dword_8238560;
  return result;
}

//----- (0806C531) --------------------------------------------------------
void *__cdecl sub_806C531(size_t n)
{
  return sub_806C54C(n, 32);
}

//----- (0806C54C) --------------------------------------------------------
void *__cdecl sub_806C54C(size_t n, int a2)
{
  void *s; // [esp+14h] [ebp-4h]

  *dword_8238550 = (a2 - 1 + *dword_8238550) & ~(a2 - 1);
  s = (dword_80EFCDC + *dword_8238550);
  *dword_8238550 += n;
  *dword_8238554 = *dword_8238550;
  if ( *dword_8238550 + *dword_8238564 > *dword_8238568 )
  {
    sub_806BBAA();
    sub_80704AC(1, &byte_80DDCC0, n);
  }
  dword_84886E4 = *dword_8238550 + *dword_8238560;
  memset(s, 0, n);
  return s;
}
// 80EFCDC: using guessed type int dword_80EFCDC;
// 84886E4: using guessed type int dword_84886E4;

//----- (0806C5F1) --------------------------------------------------------
int sub_806C5F1()
{
  int result; // eax

  result = *dword_8238554;
  *dword_8238550 = *dword_8238554;
  return result;
}

//----- (0806C600) --------------------------------------------------------
_DWORD *__cdecl sub_806C600(size_t size)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *v4; // [esp+24h] [ebp-4h]
  size_t sizea; // [esp+30h] [ebp+8h]

  if ( !dword_80EFCDC )
    return sub_806BB38(size);
  sizea = size + 16;
  v3 = *dword_8238554;
  *dword_8238554 = (*dword_8238554 + 15) & 0xFFFFFFF0;
  v4 = (dword_80EFCDC + *dword_8238554);
  *dword_8238554 += sizea;
  if ( *dword_8238554 + *dword_8238564 > *dword_8238568 )
  {
    sub_806BBAA();
    sub_80704AC(1, &byte_80DDD00, sizea, *dword_8238554 + *dword_8238564 - *dword_8238568);
  }
  *v4 = -1991018350;
  v4[1] = *dword_8238554 - v3;
  return v4 + 4;
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C6D0) --------------------------------------------------------
int __cdecl sub_806C6D0(int a1)
{
  *dword_8238554 = *dword_8238550 + a1;
  if ( *dword_8238550 + a1 + *dword_8238564 > *dword_8238568 )
  {
    sub_806BBAA();
    sub_80704AC(1, &byte_80DDD40, a1);
  }
  return dword_80EFCDC + *dword_8238550;
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C724) --------------------------------------------------------
int sub_806C724()
{
  int result; // eax

  result = dword_823854C;
  *dword_8238554 = dword_823854C;
  return result;
}
// 823854C: using guessed type int dword_823854C;

//----- (0806C733) --------------------------------------------------------
int sub_806C733()
{
  int result; // eax

  result = *dword_8238554;
  dword_823854C = *dword_8238554;
  return result;
}
// 823854C: using guessed type int dword_823854C;

//----- (0806C742) --------------------------------------------------------
void __cdecl sub_806C742(void *ptr)
{
  _DWORD *v1; // [esp+14h] [ebp-4h]

  if ( dword_80EFCDC )
  {
    v1 = ptr - 16;
    if ( *(ptr - 4) != -1991018350 )
      sub_80704AC(0, &byte_80DDD80);
    *v1 = -1991018349;
    *dword_8238554 -= v1[1];
  }
  else
  {
    sub_806BB25(ptr);
  }
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C79D) --------------------------------------------------------
int sub_806C79D()
{
  int result; // eax

  if ( dword_80EFCDC )
  {
    result = *dword_8238550;
    *dword_8238554 = *dword_8238550;
  }
  return result;
}
// 80EFCDC: using guessed type int dword_80EFCDC;

//----- (0806C7E4) --------------------------------------------------------
int __cdecl sub_806C7E4(_BYTE *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
    v2 = tolower(*a1++) + 31337 * v2;
  return v2;
}

//----- (0806C82A) --------------------------------------------------------
int __cdecl sub_806C82A(char *a1)
{
  char *i; // [esp+Ch] [ebp+8h]

  if ( *a1 <= 31 || (*(_ctype_b + 2 * *a1) & 0x400) == 0 && *a1 != 95 )
    return 0;
  for ( i = a1 + 1; *i; ++i )
  {
    if ( *i <= 31 || (*(_ctype_b + 2 * *i) & 8) == 0 && *i != 95 )
      return 0;
  }
  return 1;
}
// 80FE1E8: using guessed type int _ctype_b;

//----- (0806C8BA) --------------------------------------------------------
int __cdecl sub_806C8BA(int a1, float a2)
{
  if ( *(a1 + 64) >= 0.0 )
  {
    if ( a2 >= 0.0 )
    {
      if ( a2 >= *(a1 + 64) && *(a1 + 68) > a2 )
        return 1;
    }
    else if ( *(a1 + 64) <= 0.0 )
    {
      return 1;
    }
    return 0;
  }
  return 1;
}

//----- (0806C93D) --------------------------------------------------------
int __cdecl sub_806C93D(int a1, int a2, float a3)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !a1 )
    return 0;
  for ( i = dword_8238988[256 * a2 + sub_806C7E4(a1)]; i; i = *(i + 72) )
  {
    if ( !sub_8086A5A(a1, *i) && sub_806C8BA(i, a3) )
      return i;
  }
  return 0;
}

//----- (0806C9C8) --------------------------------------------------------
char *__cdecl sub_806C9C8(char *dest, int a2)
{
  char *result; // eax

  strcpy(dest, dword_8238980);
  dest[64] = 0;
  *(dest + 1056) = 0;
  dest[4228] = 0;
  dest[128] = 0;
  *(dest + 1074) = 1065353216;
  *(dest + 1075) = 1065353216;
  *(dest + 1076) = 1065353216;
  *(dest + 1077) = 1065353216;
  *(dest + 1078) = 1123024896;
  *(dest + 1079) = 0;
  *(dest + 1080) = 0;
  *(dest + 1081) = 1;
  dest[4328] = 0;
  *(dest + 1084) = 1065353216;
  *(dest + 1085) = a2 != 0;
  dest[4329] = 0;
  dest[4330] = 0;
  *(dest + 1083) = 1065353216;
  *(dest + 1086) = -1082130432;
  *(dest + 1087) = -1082130432;
  result = dest;
  *(dest + 1089) = 0;
  return result;
}

//----- (0806CAE6) --------------------------------------------------------
int __cdecl sub_806CAE6(char *a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char v5[16392]; // [esp+30h] [ebp-4018h] BYREF
  int v6; // [esp+4038h] [ebp-10h]
  int i; // [esp+403Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
    {
      v6 = 0;
      for ( i = 0; i <= 9; ++i )
      {
        v1 = sprintf(&v5[v6], "%s", off_80EFD60[i]);
        v6 += v1;
        if ( i > 7 )
        {
          if ( i == 8 )
          {
            v3 = sprintf(&v5[v6], " or ");
            v6 += v3;
          }
        }
        else
        {
          v2 = sprintf(&v5[v6], ", ");
          v6 += v2;
        }
      }
      sub_80704AC(1, &byte_80DDEA0, dword_8238980, a1, v5);
    }
    if ( !sub_8086A5A(a1, off_80EFD60[i]) )
      break;
  }
  return i;
}
// 80EFD60: using guessed type char *off_80EFD60[10];

//----- (0806CC0F) --------------------------------------------------------
int __cdecl sub_806CC0F(char *a1)
{
  if ( !sub_8086A5A(a1, "streamed") )
    return 2;
  if ( sub_8086A5A(a1, "loaded") )
    sub_80704AC(1, &byte_80DDF00, dword_8238980, a1);
  return 1;
}

//----- (0806CC85) --------------------------------------------------------
int __cdecl sub_806CC85(char *a1)
{
  if ( !sub_8086A5A(a1, "looping") )
    return 1;
  if ( sub_8086A5A(a1, "nonlooping") )
    sub_80704AC(1, &byte_80DDF60, dword_8238980, a1);
  return 0;
}

//----- (0806CCFB) --------------------------------------------------------
_BOOL4 __cdecl sub_806CCFB(char *s, char *src)
{
  size_t v2; // eax
  size_t v3; // eax
  _BOOL4 v5; // [esp+10h] [ebp-10028h]
  int v6; // [esp+14h] [ebp-10024h]
  size_t v7; // [esp+1Ch] [ebp-1001Ch]
  char dest[65535]; // [esp+20h] [ebp-10018h] BYREF
  char v9; // [esp+1001Fh] [ebp-19h]
  char *haystack; // [esp+10028h] [ebp-10h]
  char *s1; // [esp+1002Ch] [ebp-Ch]

  sub_8073114("fs_game", &byte_80DDFB8, 0);
  v7 = strlen(s);
  v9 = 0;
  strncpy(dest, src, 0x10000u);
  if ( v9 )
    sub_80704AC(1, &byte_80DDFE0, dword_8238980, 0xFFFF);
  sub_806FDA0(dest);
  haystack = dest;
  if ( dest[0] == 33 )
  {
    do
      ++haystack;
    while ( *haystack <= 32 && *haystack );
    if ( strcmp(s, "menu") || (s1 = strstr(haystack, "menu")) != 0 )
    {
      s1 = strstr(haystack, "all_");
      if ( s1 && !strncmp(s1, "all_mp", 6u) )
      {
        v5 = 0;
      }
      else if ( byte_84843A0
             && (s1 = strstr(haystack, "game_")) != 0
             && (v2 = strlen(&byte_84843A0), !strncmp(s1 + 5, &byte_84843A0, v2)) )
      {
        v5 = 0;
      }
      else
      {
        while ( 1 )
        {
          s1 = strstr(haystack, s);
          if ( !s1 )
            return 1;
          if ( (s1 == dest || *(s1 - 1) <= 32) && s1[v7] <= 32 )
            break;
          haystack = s1 + 1;
        }
        v5 = 0;
      }
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    while ( 1 )
    {
      s1 = strstr(haystack, s);
      if ( !s1 )
        break;
      if ( (s1 == dest || *(s1 - 1) <= 32) && s1[v7] <= 32 )
        return 1;
      haystack = s1 + 1;
    }
    v6 = 0;
    if ( strcmp(s, "menu") || (s1 = strstr(haystack, "menu")) != 0 )
    {
      s1 = strstr(haystack, "all_");
      if ( !s1 || (v6 = 1, !strncmp(s1, "all_mp", 6u)) )
      {
        if ( byte_84843A0
          && (s1 = strstr(haystack, "game_")) != 0
          && (v6 = 1, v3 = strlen(&byte_84843A0), strncmp(s1 + 5, &byte_84843A0, v3)) )
        {
          v5 = 0;
        }
        else
        {
          v5 = v6 != 0;
        }
      }
      else
      {
        v5 = 0;
      }
    }
    else
    {
      v5 = 0;
    }
  }
  return v5;
}

//----- (0806D096) --------------------------------------------------------
void __cdecl sub_806D096(char *s1, int a2)
{
  if ( !strcasecmp(s1, "master") )
  {
    *(a2 + 4329) = 1;
    *(a2 + 4330) = 0;
  }
  else
  {
    *(a2 + 4329) = 0;
    *(a2 + 4330) = 1;
    *(a2 + 4332) = atof(s1);
  }
}

//----- (0806D0F8) --------------------------------------------------------
void __cdecl sub_806D0F8(char *a1, char *s, int a3, int a4, int a5)
{
  int i; // [esp+20h] [ebp-8h]

  if ( a3 )
  {
    if ( *(a4 + a3) )
      sub_80704AC(1, &byte_80DE040, dword_8238980, dword_80EFD00[a3]);
    *(a4 + a3) = 1;
    switch ( a3 )
    {
      case 1:
        if ( strlen(s) > 0x3E )
          sub_80704AC(1, &byte_80DE080, dword_8238980, s, 63);
        if ( !sub_806C82A(s) )
          sub_80704AC(1, &byte_80DE0E0, dword_8238980, s);
        strcpy((a5 + 64), s);
        break;
      case 2:
        *(a5 + 4224) = atoi(s);
        break;
      case 3:
        if ( strlen(s) > 0x3E )
          sub_80704AC(1, &byte_80DE120, dword_8238980, s, 63);
        strcpy((a5 + 4228), s);
        break;
      case 4:
        if ( strlen(s) > 0xFFE )
          sub_80704AC(1, &byte_80DE180, dword_8238980, s, 4095);
        for ( i = 0; s[i]; ++i )
        {
          if ( s[i] < 0 )
            sub_80704AC(1, &byte_80DE1E0, dword_8238980, s, s[i], s[i]);
        }
        strcpy((a5 + 128), s);
        break;
      case 5:
        *(a5 + 4296) = atof(s);
        if ( !*(a4 + 6) )
          *(a5 + 4300) = *(a5 + 4296);
        break;
      case 6:
        *(a5 + 4300) = atof(s);
        break;
      case 7:
        *(a5 + 4304) = atof(s);
        if ( !*(a4 + 8) )
          *(a5 + 4308) = *(a5 + 4304);
        break;
      case 8:
        *(a5 + 4308) = atof(s);
        break;
      case 9:
        *(a5 + 4312) = atof(s);
        break;
      case 10:
        *(a5 + 4316) = atof(s);
        break;
      case 11:
        *(a5 + 4320) = sub_806CAE6(s);
        break;
      case 12:
        *(a5 + 4324) = sub_806CC0F(s);
        break;
      case 13:
        *(a5 + 4328) = sub_806CC85(s);
        break;
      case 14:
        *(a5 + 4336) = atof(s);
        break;
      case 15:
        *(a5 + 4340) = sub_806CCFB(a1, s);
        break;
      case 16:
        sub_806D096(s, a5);
        break;
      case 17:
        *(a5 + 4344) = atof(s);
        break;
      case 18:
        *(a5 + 4348) = atof(s);
        break;
      default:
        return;
    }
  }
}
// 80EFD00: using guessed type int dword_80EFD00[];

//----- (0806D4AE) --------------------------------------------------------
void __cdecl sub_806D4AE(int a1)
{
  int v1; // [esp+24h] [ebp-4h]
  int v2; // [esp+24h] [ebp-4h]

  if ( *(a1 + 4304) > *(a1 + 4308) )
  {
    v1 = *(a1 + 4308);
    *(a1 + 4308) = *(a1 + 4304);
    *(a1 + 4304) = v1;
  }
  if ( *(a1 + 4304) <= 0.0 )
    sub_80704AC(1, &byte_80DE280, a1 + 64, *(a1 + 4304));
  if ( *(a1 + 4296) > *(a1 + 4300) )
  {
    v2 = *(a1 + 4300);
    *(a1 + 4300) = *(a1 + 4296);
    *(a1 + 4296) = v2;
  }
  if ( *(a1 + 4296) < 0.0 )
    sub_80704AC(1, &byte_80DE2C0, a1 + 64, *(a1 + 4296));
  if ( *(a1 + 4316) == 0.0 )
    *(a1 + 4316) = *(a1 + 4312) * 5.0;
  if ( *(a1 + 4312) > *(a1 + 4316) )
    sub_80704AC(1, &byte_80DE300, a1 + 64, *(a1 + 4312), *(a1 + 4316));
  if ( *(a1 + 4312) <= 0.0 )
    sub_80704AC(1, &byte_80DE340, a1 + 64, *(a1 + 4312));
}

//----- (0806D686) --------------------------------------------------------
int __cdecl sub_806D686(_DWORD *a1)
{
  int result; // eax
  unsigned int v2; // [esp+10h] [ebp-18h]
  const void *v3; // [esp+14h] [ebp-14h]
  void *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = sub_806C600(0x1108u);
  v4 = v5;
  v3 = a1;
  v2 = 4360;
  if ( (v5 & 4) != 0 )
  {
    *v5 = *a1;
    v4 = (v5 + 4);
    v3 = a1 + 1;
    v2 = 4356;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  *(v5 + 4356) = dword_82395A0;
  result = v5;
  dword_82395A0 = v5;
  return result;
}
// 82395A0: using guessed type int dword_82395A0;

//----- (0806D6FC) --------------------------------------------------------
int __cdecl sub_806D6FC(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int result; // eax

  *a2 = a3;
  *(a2 + 4) = a4;
  *(a2 + 8) = a5;
  *(a2 + 12) = 0;
  *(a2 + 16) = 0;
  *(a2 + 20) = *(a1 + 4296);
  *(a2 + 24) = *(a1 + 4300);
  *(a2 + 28) = *(a1 + 4304);
  *(a2 + 32) = *(a1 + 4308);
  *(a2 + 36) = *(a1 + 4312);
  *(a2 + 40) = *(a1 + 4316);
  *(a2 + 44) = *(a1 + 4320);
  *(a2 + 48) = *(a1 + 4324);
  *(a2 + 52) = *(a1 + 4328);
  *(a2 + 53) = *(a1 + 4329);
  *(a2 + 54) = *(a1 + 4330);
  *(a2 + 56) = *(a1 + 4332);
  *(a2 + 60) = *(a1 + 4336);
  *(a2 + 64) = *(a1 + 4344);
  *(a2 + 68) = *(a1 + 4348);
  v6 = sub_806C7E4(*a2);
  *(a2 + 72) = dword_8238988[256 * a6 + v6];
  v7 = v6 + (a6 << 8);
  result = a2;
  dword_8238988[v7] = a2;
  return result;
}

//----- (0806D851) --------------------------------------------------------
int __cdecl sub_806D851(char *a1, char *haystack, int a3, int a4)
{
  int v6; // [esp+28h] [ebp-1560h]
  int v7; // [esp+2Ch] [ebp-155Ch]
  char s[32]; // [esp+30h] [ebp-1558h] BYREF
  char dest[4340]; // [esp+50h] [ebp-1538h] BYREF
  int v10; // [esp+1144h] [ebp-444h]
  int v11[259]; // [esp+1160h] [ebp-428h]
  int v12; // [esp+156Ch] [ebp-1Ch]
  int i; // [esp+1570h] [ebp-18h]
  char *v14; // [esp+1574h] [ebp-14h]
  char *v15; // [esp+1578h] [ebp-10h] BYREF
  int v16[3]; // [esp+157Ch] [ebp-Ch] BYREF

  if ( (sub_8062EB0(haystack, v16) & 0x80000000) != 0 )
    return a3;
  sub_808521C(haystack);
  sub_808533D(1);
  v15 = v16[0];
  v12 = 0;
  while ( 1 )
  {
    v14 = sub_8085E0B(&v15);
    if ( !v15 )
      break;
    if ( *v14 && *v14 != 35 )
    {
      if ( v12 )
      {
        memset(s, 0, 0x13u);
        sub_806C9C8(dest, a4);
        i = 0;
        while ( 1 )
        {
          if ( *v14 )
            sub_806D0F8(a1, v14, v11[i], s, dest);
          if ( ++i == v12 )
            break;
          v14 = sub_8085E6A(&v15);
        }
        if ( !s[1] || !s[3] )
          sub_80704AC(1, &byte_80DE3C0, dword_8238980);
        if ( v10 )
        {
          sub_806D4AE(dest);
          sub_806D686(dest);
          ++a3;
        }
      }
      else
      {
        v7 = 0;
        v6 = 0;
        while ( 2 )
        {
          v11[v12] = 0;
          for ( i = 1; i <= 18; ++i )
          {
            if ( !sub_8086A5A(dword_80EFD00[i], v14) )
            {
              v11[v12] = i;
              if ( i == 1 )
              {
                v7 = 1;
              }
              else if ( i == 3 )
              {
                v6 = 1;
              }
              break;
            }
          }
          if ( ++v12 != 256 && v15 && *v15 != 10 )
          {
            v14 = sub_8085E6A(&v15);
            continue;
          }
          break;
        }
        if ( !v7 || !v6 )
          sub_80704AC(1, &byte_80DE380, dword_8238980);
      }
    }
    sub_8085FBA(&v15);
  }
  sub_80852BD();
  return a3;
}
// 80EFD00: using guessed type int dword_80EFD00[];

//----- (0806DAE7) --------------------------------------------------------
int __cdecl sub_806DAE7(int a1, _DWORD *a2)
{
  int v2; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h] BYREF
  int v9; // [esp+28h] [ebp-10h] BYREF
  int *v10; // [esp+2Ch] [ebp-Ch]
  char *v11; // [esp+30h] [ebp-8h]
  char v12[4]; // [esp+34h] [ebp-4h]

  if ( *a2 == 1 )
  {
    *(a1 + 4356) = 0;
    v4 = a1;
  }
  else
  {
    v9 = *a2 / 2;
    v8 = *a2 - v9;
    v5 = 0;
    v11 = a1;
    while ( v5 < v9 )
    {
      ++v5;
      v11 = *(v11 + 1089);
    }
    *v12 = sub_806DAE7(a1, &v9);
    v11 = sub_806DAE7(v11, &v8);
    *a2 = 0;
    a1 = 0;
    v10 = &a1;
    while ( v9 && v8 )
    {
      v6 = sub_8086A5A((*v12 + 64), v11 + 64);
      if ( v6 || (v6 = *(*v12 + 4224) - *(v11 + 1056)) != 0 )
      {
        if ( v6 >= 0 )
        {
          *v10 = v11;
          v11 = *(v11 + 1089);
          --v8;
        }
        else
        {
          *v10 = *v12;
          *v12 = *(*v12 + 4356);
          --v9;
        }
        ++*a2;
        v10 = (*v10 + 4356);
      }
      else
      {
        v7 = sub_8086A5A(*v12, v11);
        if ( !v7 )
          sub_80704AC(1, &byte_80DE400, *v12, *v12 + 64);
        if ( v7 >= 0 )
        {
          v11 = *(v11 + 1089);
          --v8;
        }
        else
        {
          *v12 = *(*v12 + 4356);
          --v9;
        }
      }
    }
    if ( v9 )
    {
      *v10 = *v12;
      v2 = *a2 + v9;
    }
    else
    {
      *v10 = v11;
      v2 = *a2 + v8;
    }
    *a2 = v2;
    v4 = a1;
  }
  return v4;
}

//----- (0806DCF2) --------------------------------------------------------
int __cdecl sub_806DCF2(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+28h] [ebp-30h]
  int v4; // [esp+2Ch] [ebp-2Ch]
  size_t v5; // [esp+30h] [ebp-28h]
  size_t v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int l; // [esp+34h] [ebp-24h]
  char *v9; // [esp+38h] [ebp-20h]
  char *v10; // [esp+3Ch] [ebp-1Ch]
  char *v11; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  int k; // [esp+48h] [ebp-10h]
  char *s; // [esp+4Ch] [ebp-Ch]
  char *v16; // [esp+50h] [ebp-8h]
  char *dest; // [esp+54h] [ebp-4h]
  char *desta; // [esp+54h] [ebp-4h]

  dword_82395A0 = sub_806DAE7(dword_82395A0, &a1);
  v4 = 0;
  v3 = 0;
  dest = 0;
  for ( i = dword_82395A0; i; i = *(i + 4356) )
  {
    v5 = strlen((i + 64)) + 1;
    if ( dest && !sub_8086A5A(dest, (i + 64)) )
    {
      v3 += v5;
    }
    else
    {
      v4 += v5;
      dest = (i + 64);
    }
    if ( *(i + 128) )
      v4 += strlen((i + 128)) + 1;
    v6 = strlen((i + 4228)) + 1;
    for ( j = dword_82395A0; j != i; j = *(j + 4356) )
    {
      if ( !sub_8086A5A((j + 4228), (i + 4228)) )
      {
        v3 += v6;
        *(i + 4352) = j;
        goto LABEL_15;
      }
    }
    *(i + 4352) = 0;
    v4 += v6;
LABEL_15:
    ;
  }
  Com_DPrintf("Sound alias strings use %.1f KB; %.1f KB saved by string sharing\n", (v4 / 1024.0), (v3 / 1024.0));
  v9 = sub_806BB38(v4 + 76 * a1);
  v10 = &v9[76 * a1];
  v11 = v10;
  desta = 0;
  v7 = 0;
  for ( k = dword_82395A0; k; k = *(k + 4356) )
  {
    if ( !desta || sub_8086A5A(desta, (k + 64)) )
    {
      desta = v10;
      strcpy(v10, (k + 64));
      v10 += strlen(v10) + 1;
    }
    if ( *(k + 128) )
    {
      s = v10;
      strcpy(v10, (k + 128));
      v10 += strlen(v10) + 1;
    }
    else
    {
      s = 0;
    }
    if ( *(k + 4352) )
    {
      v16 = *(*(k + 4352) + 4292);
    }
    else
    {
      v16 = v10;
      strcpy(v10, (k + 4228));
      v10 += strlen(v10) + 1;
    }
    *(k + 4292) = v16;
    sub_806D6FC(k, &v9[76 * v7++], desta, v16, s, a2);
  }
  *(&dword_8239588 + a2) = v9;
  dword_8239594[a2] = a1;
  dword_82395E4[a2] = v4 * a1;
  for ( l = 0; ; ++l )
  {
    result = l;
    if ( l >= v4 )
      break;
    dword_82395E4[a2] *= 31337;
    dword_82395E4[a2] += v11[l];
  }
  return result;
}
// 8239594: using guessed type int dword_8239594[];
// 82395A0: using guessed type int dword_82395A0;
// 82395E4: using guessed type int dword_82395E4[];

//----- (0806E081) --------------------------------------------------------
int __cdecl sub_806E081(char *s, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( a3 == 4095 )
    return 4095;
  for ( i = 0; i < a3; ++i )
  {
    if ( !sub_8086A5A(s, *(a2 + 4 * i)) )
      return a3;
  }
  *(a2 + 4 * a3) = sub_806BB76(s);
  return a3 + 1;
}

//----- (0806E108) --------------------------------------------------------
void __cdecl sub_806E108(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  if ( ptr )
  {
    for ( i = 0; *(ptr + i); ++i )
      sub_806BB25(*(ptr + i));
    sub_806BB25(ptr);
  }
}

//----- (0806E15E) --------------------------------------------------------
_DWORD *__cdecl sub_806E15E(char *a1, int *a2)
{
  char *haystack; // [esp+14h] [ebp-4024h]
  int i; // [esp+18h] [ebp-4020h]
  int v6; // [esp+1Ch] [ebp-401Ch]
  char *s; // [esp+20h] [ebp-4018h]
  char *v8; // [esp+24h] [ebp-4014h] BYREF
  int v9; // [esp+28h] [ebp-4010h] BYREF
  _DWORD *v10; // [esp+2Ch] [ebp-400Ch]
  int v11[4098]; // [esp+30h] [ebp-4008h] BYREF

  haystack = a1;
  v6 = 0;
  if ( (sub_8062EB0(a1, &v9) & 0x80000000) != 0 )
  {
    haystack = "soundloadspecs/mp/default.csv";
    if ( (sub_8062EB0("soundloadspecs/mp/default.csv", &v9) & 0x80000000) != 0 )
      sub_80704AC(1, &byte_80DE4C0, a1, "soundloadspecs/mp/default.csv");
  }
  sub_808521C(haystack);
  sub_808533D(1);
  v8 = v9;
  while ( v8 )
  {
    s = sub_8085E0B(&v8);
    if ( *s && *s != 35 )
    {
      v6 = sub_806E081(s, v11, v6);
      sub_8085FBA(&v8);
    }
    else
    {
      sub_8085FBA(&v8);
    }
  }
  sub_80852BD();
  sub_8063207(v9);
  *a2 = v6;
  if ( !v6 )
    return 0;
  v10 = sub_806BB38(4 * v6 + 4);
  for ( i = 0; i < v6; ++i )
    v10[i] = v11[i];
  v10[i] = 0;
  return v10;
}

//----- (0806E35A) --------------------------------------------------------
void __cdecl sub_806E35A(char *s2, int a2)
{
  char *v2; // eax
  char v3[72]; // [esp+10h] [ebp-A8h] BYREF
  int v4; // [esp+58h] [ebp-60h]
  size_t v5; // [esp+5Ch] [ebp-5Ch]
  char dest[68]; // [esp+60h] [ebp-58h] BYREF
  int i; // [esp+A4h] [ebp-14h]
  int v8; // [esp+A8h] [ebp-10h] BYREF
  void *ptr; // [esp+ACh] [ebp-Ch]

  v4 = 0;
  if ( a2 == 1 && !strcasecmp(&s1, s2) )
  {
    dword_823958C = dword_8239590;
    dword_8239598 = dword_823959C;
    sub_80C835C(&unk_8238D88, &unk_8239188, 0x400u);
  }
  else
  {
    if ( !strncasecmp(s2, "maps/", 5u) )
    {
      strcpy(dest, s2 + 8);
      v5 = strlen(dest);
      if ( !strcasecmp(&dest[v5 - 4], ".bsp") )
      {
        v5 -= 4;
        dest[v5] = 0;
      }
    }
    else
    {
      strcpy(dest, s2);
    }
    sub_806FDA0(dest);
    if ( a2 == 1 || a2 == 2 )
    {
      strcpy(v3, "soundloadspecs/mp/");
      strcat(v3, dest);
      strcat(v3, ".csv");
      ptr = sub_806E15E(v3, &v8);
    }
    else
    {
      ptr = sub_8063EFC("soundaliases", "csv", &v8);
    }
    if ( !v8 )
    {
      Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n");
      return;
    }
    sub_806C733();
    for ( i = 0; i < v8; ++i )
    {
      dword_8238980 = *(ptr + i);
      v2 = sub_8086D78("soundaliases/%s", dword_8238980);
      v4 = sub_806D851(dest, v2, v4, a2);
    }
    if ( v4 )
      sub_806DCF2(v4, a2);
    sub_806C724();
    if ( a2 == 1 || a2 == 2 )
      sub_806E108(ptr);
    else
      sub_8063F25(ptr);
    if ( a2 == 2 )
      strcpy(&s1, s2);
  }
  *(a2 + 136546692) = 1;
}
// 806E582: conditional instruction was optimized away because of '%arg_4.4==1'
// 823958C: using guessed type int dword_823958C;
// 8239590: using guessed type int dword_8239590;
// 8239598: using guessed type int dword_8239598;
// 823959C: using guessed type int dword_823959C;

//----- (0806E5C2) --------------------------------------------------------
int __cdecl sub_806E5C2(int a1)
{
  int result; // eax

  result = a1 + 136546688;
  if ( *(a1 + 136546692) )
  {
    if ( a1 == 2 )
      s1 = 0;
    if ( *(&dword_8239588 + a1) )
    {
      if ( a1 != 1 || !dword_8239590 )
        sub_806BB25(*(&dword_8239588 + a1));
      *(&dword_8239588 + a1) = 0;
      dword_8239594[a1] = 0;
      memset(((a1 << 10) + 136546696), 0, 0x400u);
    }
    result = a1 + 136546688;
    *(a1 + 136546692) = 0;
  }
  return result;
}
// 8239590: using guessed type int dword_8239590;
// 8239594: using guessed type int dword_8239594[];

//----- (0806E663) --------------------------------------------------------
int __cdecl sub_806E663(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int *v4; // [esp+14h] [ebp-4h]

  v4 = sub_806C93D(a1, a2, -1.0);
  if ( v4 )
    v3 = *v4;
  else
    v3 = 0;
  return v3;
}

//----- (0806E6A2) --------------------------------------------------------
float *__cdecl sub_806E6A2(int a1, int a2)
{
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+28h] [ebp-10h]
  float *v8; // [esp+2Ch] [ebp-Ch]
  float *v9; // [esp+30h] [ebp-8h]
  int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v9 = sub_806C93D(a1, a2, 10.0);
  if ( !v9 )
    return 0;
  v11 = v9;
  v8 = v9;
  v6 = v9[15];
  v5 = 1;
  v4 = *(v9 + 4);
  while ( v9 != *(&dword_8239588 + a2) )
  {
    v9 -= 19;
    if ( *v9 != *v8 )
      break;
    if ( sub_806C8BA(v9, 10.0) )
    {
      ++v5;
      v6 = v6 + v9[15];
      if ( v9[15] * -2147483600.0 > rand() * v6 )
        v8 = v9;
      if ( v4 < *(v9 + 4) )
        v4 = *(v9 + 4);
    }
  }
  if ( v5 > 2 && v4 == *(v8 + 4) )
  {
    v7 = 0.0;
    v10 = v11;
    while ( v5 )
    {
      if ( sub_806C8BA(v10, 10.0) )
      {
        if ( v4 != *(v10 + 16) )
        {
          v7 = v7 + *(v10 + 60);
          if ( *(v10 + 60) * -2147483600.0 > rand() * v7 )
            v8 = v10;
        }
      }
      else
      {
        ++v5;
      }
      v10 -= 76;
      --v5;
    }
  }
  *(v8 + 4) = v4 + 1;
  return v8;
}

//----- (0806E89C) --------------------------------------------------------
int __cdecl sub_806E89C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = 678152731 * ((a1 - *(&dword_8239588 + a2) + 76) >> 2);
  if ( v4 > 0 && v4 <= dword_8239594[a2] )
    v3 = 678152731 * ((a1 - *(&dword_8239588 + a2) + 76) >> 2);
  else
    v3 = 0;
  return v3;
}
// 8239594: using guessed type int dword_8239594[];

//----- (0806E8FA) --------------------------------------------------------
int __cdecl sub_806E8FA(char *a1)
{
  int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  v3 = 0;
  if ( sub_80869EB(a1, "SUBTITLE_", 9) )
    return 0;
  if ( (sub_8062EB0("soundaliases/subtitle.st", &v7) & 0x80000000) == 0 )
  {
    sub_808521C("soundaliases/subtitle.st");
    for ( i = v7; ; sub_8085FBA(&i) )
    {
      s1 = sub_8085E0B(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1a = sub_8085E6A(&i);
        if ( !sub_8086A5A(a1 + 9, s1a) )
        {
          v3 = 1;
          break;
        }
      }
    }
    sub_80852BD();
    sub_8063207(v7);
    v2 = v3;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    v2 = 0;
  }
  return v2;
}

//----- (0806EA00) --------------------------------------------------------
char *__cdecl sub_806EA00(char *a1)
{
  int v2; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1b; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  char *s1c; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  int v8; // [esp+24h] [ebp-4h] BYREF

  if ( (sub_8062EB0("soundaliases/subtitle.st", &v8) & 0x80000000) == 0 )
  {
    sub_808521C("soundaliases/subtitle.st");
    for ( i = v8; ; sub_8085FBA(&i) )
    {
      s1 = sub_8085E0B(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1b = sub_8085E6A(&i);
        strcpy(byte_8238580, s1b);
        sub_8085FBA(&i);
        do
        {
          s1a = sub_8085E0B(&i);
          if ( !i )
            sub_80704AC(1, &byte_80DE620, "soundaliases/subtitle.st");
        }
        while ( strcmp(s1a, "LANG_ENGLISH") );
        s1c = sub_8085E6A(&i);
        if ( !sub_8086A5A(a1, s1c) )
        {
          sub_80852BD();
          sub_8063207(v8);
          return byte_8238580;
        }
      }
    }
    sub_80852BD();
    sub_8063207(v8);
    v2 = 0;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
    v2 = 0;
  }
  return v2;
}

//----- (0806EB5F) --------------------------------------------------------
size_t __cdecl sub_806EB5F(char *a1, char *a2, int a3)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax

  v3 = strlen("REFERENCE           ");
  sub_8062983("REFERENCE           ", v3, a3);
  v4 = strlen(a1);
  sub_8062983(a1, v4, a3);
  v5 = strlen("\r\nLANG_ENGLISH        \"");
  sub_8062983("\r\nLANG_ENGLISH        \"", v5, a3);
  v6 = strlen(a2);
  sub_8062983(a2, v6, a3);
  v7 = strlen("\"\r\n\r\n");
  return sub_8062983("\"\r\n\r\n", v7, a3);
}

//----- (0806EC2B) --------------------------------------------------------
void __cdecl sub_806EC2B(int a1, char *a2)
{
  size_t v2; // eax
  int v3; // [esp+1Ch] [ebp-22Ch]
  int v4; // [esp+20h] [ebp-228h]
  unsigned int v5; // [esp+24h] [ebp-224h]
  char *s1; // [esp+28h] [ebp-220h]
  char *s1b; // [esp+28h] [ebp-220h]
  char *s1a; // [esp+28h] [ebp-220h]
  char *s2; // [esp+2Ch] [ebp-21Ch]
  char dest[256]; // [esp+30h] [ebp-218h] BYREF
  char filename[260]; // [esp+130h] [ebp-118h] BYREF
  char *v12; // [esp+234h] [ebp-14h] BYREF
  int v13; // [esp+238h] [ebp-10h] BYREF
  char *v14; // [esp+23Ch] [ebp-Ch]

  v3 = 0;
  s2 = (a1 + 9);
  v4 = sub_80611FB("soundaliases/temp.st");
  if ( v4 )
  {
    if ( (sub_8062EB0("soundaliases/subtitle.st", &v13) & 0x80000000) == 0 )
    {
      sub_808521C("soundaliases/subtitle.st");
      v12 = v13;
      v5 = v13;
      while ( 1 )
      {
        s1 = sub_8085E0B(&v12);
        if ( !v12 )
          break;
        if ( !strcmp(s1, "ENDMARKER") )
        {
          if ( v5 < v12 )
          {
            v14 = &v12[-v5 - 11];
            sub_8062983(v5, v14, v4);
          }
          break;
        }
        if ( !strcmp(s1, "REFERENCE") )
        {
          s1b = sub_8085E6A(&v12);
          if ( !strcmp(s1b, s2) )
          {
            if ( v5 < v12 )
            {
              v14 = &v12[-v5];
              sub_8062983(v5, &v12[-v5], v4);
            }
            sub_806EB5F(s2, a2, v4);
            v3 = 1;
            do
            {
              v5 = v12;
              s1a = sub_8085E0B(&v12);
              if ( !v12 )
              {
                v5 = 0;
                goto LABEL_20;
              }
            }
            while ( strcmp(s1a, "REFERENCE") && strcmp(s1a, "ENDMARKER") );
            sub_808543D();
          }
        }
LABEL_20:
        sub_8085FBA(&v12);
      }
      if ( !v3 )
        sub_806EB5F(s2, a2, v4);
      sub_80852BD();
      sub_8063207(v13);
      v2 = strlen("\r\nENDMARKER\r\n\r\n\r\n");
      sub_8062983("\r\nENDMARKER\r\n\r\n\r\n", v2, v4);
      FS_FCloseFile(v4);
      sub_8060B06(*(dword_8480340 + 4), byte_84885E0, "soundaliases/temp.st", filename);
      sub_8060B06(*(dword_8480340 + 4), byte_84885E0, "soundaliases/subtitle.st", dest);
      sub_8060BCB(filename, dest);
      sub_8060F50(filename);
    }
    else
    {
      Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", "soundaliases/subtitle.st");
      FS_FCloseFile(v4);
    }
  }
  else
  {
    Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.st");
  }
}
// 8480340: using guessed type int dword_8480340;

//----- (0806EF7E) --------------------------------------------------------
void __cdecl sub_806EF7E(char *a1)
{
  int v1; // [esp+24h] [ebp-6884h]
  int v2; // [esp+28h] [ebp-6880h]
  char dest[4368]; // [esp+30h] [ebp-6878h] BYREF
  int v4[257]; // [esp+1140h] [ebp-5768h]
  FILE *stream; // [esp+1544h] [ebp-5364h]
  int v6; // [esp+1548h] [ebp-5360h]
  int v7; // [esp+154Ch] [ebp-535Ch]
  char s[36]; // [esp+1550h] [ebp-5358h] BYREF
  char *v9; // [esp+1574h] [ebp-5334h]
  char *v10; // [esp+1578h] [ebp-5330h]
  char *src; // [esp+157Ch] [ebp-532Ch]
  char v12[256]; // [esp+1580h] [ebp-5328h] BYREF
  char haystack[256]; // [esp+1680h] [ebp-5228h] BYREF
  char v14[2048]; // [esp+1780h] [ebp-5128h] BYREF
  char v15[1024]; // [esp+1F80h] [ebp-4928h] BYREF
  char v16[2048]; // [esp+2380h] [ebp-4528h] BYREF
  char v17[15360]; // [esp+2B80h] [ebp-3D28h] BYREF
  char filename[264]; // [esp+6780h] [ebp-128h] BYREF
  char *v19; // [esp+6888h] [ebp-20h] BYREF
  int v20; // [esp+688Ch] [ebp-1Ch] BYREF
  char v21[4]; // [esp+6890h] [ebp-18h]
  int v22; // [esp+6894h] [ebp-14h]
  int v23; // [esp+6898h] [ebp-10h]
  int i; // [esp+689Ch] [ebp-Ch]

  sub_8060B06(*(dword_8480340 + 4), byte_84885E0, a1, filename);
  Com_Printf("Processing sound alias file %s..\n", filename);
  stream = fopen(filename, "r+");
  if ( !stream )
  {
    Com_Printf("WARNING: Can not write to sound alias file %s\n", filename);
    return;
  }
  fclose(stream);
  if ( (sub_8062EB0(a1, &v20) & 0x80000000) != 0 )
  {
    Com_Printf("WARNING: Could not read sound alias file %s\n", a1);
    return;
  }
  v6 = sub_80611FB("soundaliases/temp.csv");
  if ( !v6 )
  {
    Com_Printf("WARNING: Could not open output file %s for writing\n", "soundaliases/temp.csv");
    return;
  }
  sub_808521C(a1);
  sub_808533D(1);
  v19 = v20;
  v23 = 0;
  *v21 = 0;
  while ( v19 )
  {
    if ( *v19 == 13 )
    {
      while ( *v19 == 13 )
        ++v19;
    }
    if ( *v19 == 10 )
    {
      ++v19;
      sub_8062983("\r\n", 2u, v6);
    }
    v10 = v19;
    src = sub_8085E0B(&v19);
    if ( !v19 )
      break;
    if ( !sub_8086A5A(src, "#Chateau") )
      i = 0;
    if ( !*src || *src == 35 )
    {
      sub_8085FBA(&v19);
      if ( *v10 == 10 )
        sub_8062983("\r", 1u, v6);
      goto LABEL_21;
    }
    if ( v23 )
    {
      memset(s, 0, 0x13u);
      sub_806C9C8(dest, 0);
      i = 0;
      while ( 1 )
      {
        strcpy(&v14[1024 * v4[i] + 1024], src);
        if ( *src )
          sub_806D0F8(&byte_80DDFB8, src, v4[i], s, dest);
        if ( ++i == v23 )
          break;
        src = sub_8085E6A(&v19);
      }
      if ( !s[1] || !s[3] )
        sub_80704AC(1, &byte_80DE3C0, dword_8238980);
      v7 = 0;
      if ( s[4] )
      {
        v22 = strlen(v17);
        for ( i = 0; i < v22 && (v17[i] > 64 && v17[i] <= 90 || v17[i] > 47 && v17[i] <= 57 || v17[i] == 95); ++i )
          ;
        if ( i < v22 || sub_80869EB(v17, "SUBTITLE_", 9) || !sub_806E8FA(v17) )
          v7 = 1;
      }
      if ( v7 )
      {
        for ( i = 0; i < v23; ++i )
        {
          if ( v4[i] && s[v4[i]] )
          {
            if ( v4[i] == 4 )
            {
              src = sub_806EA00(v17);
              if ( src )
              {
                Com_sprintf(v14, 0x400u, "%s%s", "SUBTITLE_", src);
                src = sub_8086AD1(v14);
              }
              else
              {
                if ( s[2] )
                  Com_sprintf(v14, 0x400u, "%s%s_%s", "SUBTITLE_", v15, v16);
                else
                  Com_sprintf(v14, 0x400u, "%s%s", "SUBTITLE_", v15);
                src = sub_8086AD1(v14);
                sub_806EC2B(v14, v17);
                ++*v21;
              }
            }
            else if ( i == v23 - 1 )
            {
              if ( strchr(&v14[1024 * v4[i] + 1024], 44)
                || strchr(&v14[1024 * v4[i] + 1024], 32)
                || strchr(&v14[1024 * v4[i] + 1024], 10)
                || strchr(&v14[1024 * v4[i] + 1024], 13) )
              {
                src = sub_8086D78("\"%s\"", &v14[1024 * v4[i] + 1024]);
              }
              else
              {
                src = sub_8086D78("%s", &v14[1024 * v4[i] + 1024]);
              }
            }
            else if ( strchr(&v14[1024 * v4[i] + 1024], 44)
                   || strchr(&v14[1024 * v4[i] + 1024], 32)
                   || strchr(&v14[1024 * v4[i] + 1024], 10)
                   || strchr(&v14[1024 * v4[i] + 1024], 13) )
            {
              src = sub_8086D78("\"%s\",", &v14[1024 * v4[i] + 1024]);
            }
            else
            {
              src = sub_8086D78("%s,", &v14[1024 * v4[i] + 1024]);
            }
            v22 = strlen(src);
            sub_8062983(src, v22, v6);
          }
          else if ( i != v23 - 1 )
          {
            sub_8062983(",", 1u, v6);
          }
        }
        sub_8062983("\r\n", 2u, v6);
        sub_8085FBA(&v19);
      }
      else
      {
        sub_8085FBA(&v19);
        v9 = v19;
        sub_8062983(v10, v19 - v10, v6);
      }
    }
    else
    {
      v2 = 0;
      v1 = 0;
      while ( 2 )
      {
        v4[v23] = 0;
        for ( i = 1; i <= 18; ++i )
        {
          if ( !sub_8086A5A(dword_80EFD00[i], src) )
          {
            v4[v23] = i;
            if ( i == 1 )
            {
              v2 = 1;
            }
            else if ( i == 3 )
            {
              v1 = 1;
            }
            break;
          }
        }
        if ( ++v23 != 256 && v19 && *v19 != 10 )
        {
          src = sub_8085E6A(&v19);
          continue;
        }
        break;
      }
      if ( !v2 || !v1 )
        sub_80704AC(1, &byte_80DE380, dword_8238980);
      sub_8085FBA(&v19);
      if ( *v10 == 10 )
        sub_8062983("\r", 1u, v6);
LABEL_21:
      v9 = v19;
      sub_8062983(v10, v19 - v10, v6);
    }
  }
  sub_80852BD();
  FS_FCloseFile(v6);
  sub_8060B06(*(dword_8480340 + 4), byte_84885E0, "soundaliases/temp.csv", haystack);
  sub_8060B06(*(dword_8480340 + 4), byte_84885E0, a1, v12);
  if ( *v21 )
    sub_8060BCB(haystack, v12);
  sub_8060F50(haystack);
  Com_Printf("Localized %i sound alias subtitles\n", *v21);
}
// 80EFD00: using guessed type int dword_80EFD00[];
// 8480340: using guessed type int dword_8480340;

//----- (0806FA62) --------------------------------------------------------
void __cdecl sub_806FA62(char *filename, char *a2)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = fopen(filename, "rb");
  if ( stream )
  {
    fseek(stream, 0, 2);
    size = ftell(stream);
    fseek(stream, 0, 0);
    ptr = malloc(size);
    if ( fread(ptr, 1u, size, stream) != size )
      sub_80704AC(0, &byte_80DE840);
    fclose(stream);
    streama = fopen(a2, "wb");
    if ( streama )
    {
      if ( fwrite(ptr, 1u, size, streama) != size )
        sub_80704AC(0, &byte_80DE880);
      fclose(streama);
      free(ptr);
    }
    else
    {
      free(ptr);
    }
  }
}

//----- (0806FDA0) --------------------------------------------------------
_BYTE *__cdecl sub_806FDA0(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower(*a1);
    ++a1;
  }
  return a1;
}

//----- (0806FDE8) --------------------------------------------------------
char *__cdecl sub_806FDE8(char *a1, int a2, int a3)
{
  char *result; // eax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      dword_8253504 = a1;
      dword_8253508 = a2;
      dword_825350C = a3;
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 825350C: using guessed type int dword_825350C;

//----- (0806FE21) --------------------------------------------------------
int sub_806FE21()
{
  int result; // eax

  if ( dword_825350C )
    result = dword_825350C(dword_8253504);
  dword_8253504 = 0;
  dword_8253508 = 0;
  dword_825350C = 0;
  return result;
}
// 825350C: invalid function type has been ignored
// 825350C: using guessed type int (__cdecl *dword_825350C)(_DWORD);

//----- (0806FE5F) --------------------------------------------------------
void __cdecl sub_806FE5F(int a1, char *s)
{
  size_t v2; // ebx
  char v3; // al
  size_t v4; // eax
  time_t timer; // [esp+1Ch] [ebp-Ch] BYREF
  struct tm *tp; // [esp+20h] [ebp-8h]

  sub_80B6DA8(s, 4096);
  if ( dword_8253504 )
  {
    if ( a1 != 4 )
    {
      v2 = strlen(s);
      if ( strlen(dword_8253504) + v2 > dword_8253508 - 1 )
      {
        dword_825350C(dword_8253504);
        *dword_8253504 = 0;
      }
      sub_8086B0B(dword_8253504, dword_8253508, s);
    }
  }
  else
  {
    if ( a1 != 4 )
    {
      if ( dword_84886E0 && !*(dword_84886E0 + 32) )
        sub_80851C8();
      sub_80C96E0(s);
    }
    if ( dword_84898CC && *(dword_84898CC + 32) )
    {
      if ( !dword_82396BC && sub_8060684() && !dword_80EFDB0 )
      {
        dword_80EFDB0 = 1;
        time(&timer);
        tp = localtime(&timer);
        dword_82396BC = sub_806135D("console_mp_server.log");
        v3 = asctime(tp);
        Com_Printf("logfile opened on %s\n", v3);
        if ( *(dword_84898CC + 32) > 1 )
          sub_80608EC(dword_82396BC);
        dword_80EFDB0 = 0;
      }
      if ( dword_82396BC && sub_8060684() )
      {
        v4 = strlen(s);
        sub_8062983(s, v4, dword_82396BC);
      }
    }
  }
}
// 80EFDB0: using guessed type int dword_80EFDB0;
// 82396BC: using guessed type int dword_82396BC;
// 825350C: using guessed type int (__cdecl *dword_825350C)(_DWORD);
// 84886E0: using guessed type int dword_84886E0;
// 84898CC: using guessed type int dword_84898CC;

//----- (08070248) --------------------------------------------------------
void Com_Printf(char *format, ...)
{
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsnprintf(s, 0x1000u, format, va);
  s[4095] = 0;
  sub_806FE5F(0, s);
}

//----- (08070297) --------------------------------------------------------
int Com_DPrintf(char *format, ...)
{
  int result; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( dword_8488708 )
  {
    result = dword_8488708;
    if ( *(dword_8488708 + 32) )
    {
      va_copy(__varargs, va);
      vsnprintf(s, 0x1000u, format, va);
      s[4095] = 0;
      result = Com_Printf("%s", s);
    }
  }
  return result;
}
// 8488708: using guessed type int dword_8488708;

//----- (080702FC) --------------------------------------------------------
void __cdecl sub_80702FC(const char *a1)
{
  sub_80851A0();
  sub_80851E6();
  sub_80928C2(a1);
  sub_806C394();
  sub_80851E1();
}

//----- (0807032A) --------------------------------------------------------
void *sub_807032A()
{
  switch ( dword_8239610 )
  {
    case 2:
      sub_80702FC("EXE_DISCONNECTEDFROMOWNLISTENSERVER");
      dword_84897DC = 0;
      break;
    case 5:
      sub_80702FC("EXE_ENDOFGAME");
      dword_84897DC = 0;
      break;
    case 1:
    case 3:
      Com_Printf("********************\nERROR: %s\n********************\n", byte_8488720);
      sub_80702FC(byte_8488720);
      dword_84897DC = 0;
      if ( dword_8239610 == 1 && sub_8073114("r_vc_compile", "0", 0)[8] == 2 )
        sub_807066C();
      break;
    case 4:
      sub_80702FC("EXE_SERVERDIDNTHAVECD");
      if ( dword_84898B8 && *(dword_84898B8 + 32) )
      {
        dword_84897DC = 0;
        sub_80851DC();
      }
      else
      {
        Com_Printf("Server didn't have CD\n");
      }
      break;
  }
  return sub_8072A36();
}
// 807066C: using guessed type int sub_807066C(void);
// 8239610: using guessed type int dword_8239610;
// 84897DC: using guessed type int dword_84897DC;
// 84898B8: using guessed type int dword_84898B8;

//----- (08070435) --------------------------------------------------------
void sub_8070435()
{
  if ( !++dword_8488704 )
    ++dword_8488704;
}
// 8488704: using guessed type int dword_8488704;

//----- (0807044F) --------------------------------------------------------
int sub_807044F()
{
  sub_8070435();
  sub_806C79D();
  return sub_806C522();
}

//----- (08070466) --------------------------------------------------------
void sub_8070466()
{
  dword_80F510C = 0;
}
// 80F510C: using guessed type int dword_80F510C;

//----- (08070475) --------------------------------------------------------
int __cdecl sub_8070475(char *s1)
{
  sub_8073114("com_errorMessage", &byte_80DEAD1, 64);
  return sub_8073798("com_errorMessage", s1);
}

//----- (080704AC) --------------------------------------------------------
void __noreturn sub_80704AC(int a1, char *format, ...)
{
  char *v2; // eax
  char dest[4104]; // [esp+10h] [ebp-1018h] BYREF
  int v4; // [esp+1018h] [ebp-10h]
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h] BYREF

  va_start(va, format);
  if ( dword_84897DC )
    sub_80C8793("recursive error after: %s", byte_8488720);
  sub_807044F();
  va_copy(__varargs, va);
  vsprintf(byte_8488720, format, va);
  strcpy(dest, byte_8488720);
  if ( a1 == 6 || a1 == 7 )
    a1 = 1;
  dword_84897DC = 1;
  sub_807683D(&byte_80DEAD1, &byte_80DEAD1);
  if ( a1 != 3 && a1 != 4 && a1 != 5 )
    sub_8070475(byte_8488720);
  if ( a1 != 3 )
    sub_80AA88A();
  sub_8070466();
  sub_8085301();
  sub_80631F8();
  if ( a1 == 1 )
    sub_805F9D7();
  sub_8072B74(1, 0);
  sub_8072B74(2, 0);
  v4 = sub_80CA93C();
  if ( v4 - dword_8239600 > 99 )
  {
    dword_8239604 = 0;
  }
  else if ( ++dword_8239604 > 3 )
  {
    a1 = 0;
  }
  dword_8239600 = v4;
  if ( a1 != 2 && a1 != 5 && a1 != 1 && a1 != 3 && a1 != 4 )
  {
    sub_8085138();
    v2 = sub_8086D78(aExeServerFatal, dest);
    sub_80928C2(v2);
    sub_806C31C();
    sub_80720E4();
    sub_80C8793("%s", byte_8488720);
  }
  dword_8239610 = a1;
  longjmp(env, -1);
}
// 8239600: using guessed type int dword_8239600;
// 8239604: using guessed type int dword_8239604;
// 8239610: using guessed type int dword_8239610;
// 84897DC: using guessed type int dword_84897DC;

//----- (0807066C) --------------------------------------------------------
void __noreturn sub_807066C()
{
  if ( !dword_84897DC )
  {
    sub_807044F();
    sub_8070466();
    sub_80928C2("EXE_SERVERQUIT");
    sub_806C31C();
    sub_80720E4();
    sub_80654DD(1);
    sub_8065429();
    sub_8065483();
  }
  sub_80C86E8();
}
// 807066C: using guessed type void __noreturn sub_807066C();
// 80C86E8: using guessed type int sub_80C86E8(void);
// 84897DC: using guessed type int dword_84897DC;

//----- (080706B8) --------------------------------------------------------
char *__cdecl sub_80706B8(char *a1)
{
  char *result; // eax

  dword_8489740 = a1;
  dword_8488718 = 1;
  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    result = a1;
    if ( *a1 == 43 || (result = a1, *a1 == 10) )
    {
      if ( dword_8488718 == 32 )
        return result;
      (&dword_8489740)[dword_8488718++] = a1 + 1;
      *a1 = 0;
    }
    ++a1;
  }
  return result;
}
// 8488718: using guessed type int dword_8488718;

//----- (08070717) --------------------------------------------------------
int sub_8070717()
{
  char *v0; // eax
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_8488718; ++i )
  {
    sub_8060257((&dword_8489740)[i]);
    v0 = sub_805FF28(0);
    if ( sub_8086A5A(v0, "safe") )
    {
      v1 = sub_805FF28(0);
      if ( sub_8086A5A(v1, "cvar_restart") )
        continue;
    }
    *(&dword_8489740)[i] = 0;
    return 1;
  }
  return dword_80EFDAC;
}
// 80EFDAC: using guessed type int dword_80EFDAC;
// 8488718: using guessed type int dword_8488718;

//----- (080707BC) --------------------------------------------------------
int __cdecl sub_80707BC(char *s2)
{
  int result; // eax
  char *v2; // eax
  char *v3; // eax
  int *v4; // edx
  char *s1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8488718 )
      break;
    sub_8060257((&dword_8489740)[i]);
    v2 = sub_805FF28(0);
    if ( !strcmp(v2, "set") )
    {
      s1 = sub_805FF28(1u);
      if ( !s2 || !strcmp(s1, s2) )
      {
        v3 = sub_805FF28(2u);
        sub_8073798(s1, v3);
        v4 = sub_8073114(s1, &byte_80DEAD1, 0);
        v4[4] |= 0x80u;
      }
    }
  }
  return result;
}
// 8488718: using guessed type int dword_8488718;

//----- (0807088E) --------------------------------------------------------
int sub_807088E()
{
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = 0; i < dword_8488718; ++i )
  {
    if ( (&dword_8489740)[i] && *(&dword_8489740)[i] )
    {
      if ( sub_8086946((&dword_8489740)[i], "set", 3) )
        v1 = 1;
      sub_805F9FA((&dword_8489740)[i]);
      sub_805F9FA("\n");
    }
  }
  return v1;
}
// 8488718: using guessed type int dword_8488718;

//----- (08070924) --------------------------------------------------------
void __cdecl Info_Print(char *a1)
{
  char *s; // [esp+1Ch] [ebp-40Ch]
  char *sa; // [esp+1Ch] [ebp-40Ch]
  char v3[512]; // [esp+20h] [ebp-408h] BYREF
  char v4[520]; // [esp+220h] [ebp-208h] BYREF

  if ( *a1 == 92 )
    ++a1;
  while ( *a1 )
  {
    s = v4;
    while ( *a1 && *a1 != 92 )
      *s++ = *a1++;
    if ( s - v4 > 19 )
    {
      *s = 0;
    }
    else
    {
      memset(s, 32, 20 - (s - v4));
      v4[20] = 0;
    }
    Com_Printf("%s", v4);
    if ( !*a1 )
    {
      Com_Printf("MISSING VALUE\n");
      return;
    }
    sa = v3;
    ++a1;
    while ( *a1 && *a1 != 92 )
      *sa++ = *a1++;
    *sa = 0;
    if ( *a1 )
      ++a1;
    Com_Printf("%s\n", v3);
  }
}

//----- (08070A72) --------------------------------------------------------
void sub_8070A72()
{
  sub_80707BC("journal");
  dword_8489730 = sub_8073114("journal", "0", 16);
  if ( *(dword_8489730 + 32) )
  {
    if ( *(dword_8489730 + 32) == 1 )
    {
      Com_Printf("Journaling events\n");
      *dword_84898B0 = sub_80611FB("journal.dat");
      *dword_84897D0 = sub_80611FB("journaldata.dat");
    }
    else if ( *(dword_8489730 + 32) == 2 )
    {
      Com_Printf("Replaying journaled events\n");
      sub_8062558("journal.dat", dword_84898B0, 1);
      sub_8062558("journaldata.dat", dword_84897D0, 1);
    }
    if ( !*dword_84898B0 || !*dword_84897D0 )
    {
      sub_8073798("com_journal", "0");
      *dword_84898B0 = 0;
      *dword_84897D0 = 0;
      Com_Printf("Couldn't open journal files\n");
    }
  }
}
// 8489730: using guessed type int dword_8489730;

//----- (08070B87) --------------------------------------------------------
_DWORD *__stdcall sub_8070B87(_DWORD *a1)
{
  int v2[4]; // [esp+10h] [ebp-38h] BYREF
  size_t size; // [esp+20h] [ebp-28h]
  char *v4; // [esp+24h] [ebp-24h]
  size_t v5; // [esp+3Ch] [ebp-Ch]

  if ( *(dword_8489730 + 32) == 2 )
  {
    v5 = sub_8062853(v2, 0x18u, *dword_84898B0);
    if ( v5 != 24 )
      sub_80704AC(0, "EXE_ERR_JOURNAL_FILE_READ");
    if ( size )
    {
      v4 = sub_806BB38(size);
      v5 = sub_8062853(v4, size, *dword_84898B0);
      if ( v5 != size )
        sub_80704AC(0, "EXE_ERR_JOURNAL_FILE_READ");
    }
  }
  else
  {
    sub_80C9445(v2);
    if ( *(dword_8489730 + 32) == 1 )
    {
      v5 = sub_8062983(v2, 0x18u, *dword_84898B0);
      if ( v5 != 24 )
        sub_80704AC(0, "EXE_ERR_JOURNAL_FILE_WRITE");
      if ( size )
      {
        v5 = sub_8062983(v4, size, *dword_84898B0);
        if ( v5 != size )
          sub_80704AC(0, "EXE_ERR_JOURNAL_FILE_WRITE");
      }
    }
  }
  *a1 = v2[0];
  a1[1] = v2[1];
  a1[2] = v2[2];
  a1[3] = v2[3];
  a1[4] = size;
  a1[5] = v4;
  return a1;
}
// 8489730: using guessed type int dword_8489730;

//----- (08070CFE) --------------------------------------------------------
void *sub_8070CFE()
{
  void *result; // eax

  result = memset(&dword_82396C0, 0, 0x1800u);
  dword_80EFDA0 = 0;
  dword_80EFDA4 = 0;
  return result;
}
// 80EFDA0: using guessed type int dword_80EFDA0;
// 80EFDA4: using guessed type int dword_80EFDA4;
// 82396C0: using guessed type int dword_82396C0;

//----- (08070D36) --------------------------------------------------------
int __cdecl sub_8070D36(int *a1)
{
  int result; // eax
  int *v2; // [esp+4h] [ebp-4h]

  v2 = &dword_82396C0[6 * dword_80EFDA0];
  if ( dword_80EFDA0 - dword_80EFDA4 <= 255 )
  {
    dword_80EFDBC = 0;
  }
  else
  {
    if ( !dword_80EFDBC )
    {
      dword_80EFDBC = 1;
      Com_Printf("WARNING: Com_PushEvent overflow\n");
    }
    if ( v2[5] )
      sub_806BB25(v2[5]);
    ++dword_80EFDA4;
  }
  *v2 = *a1;
  v2[1] = a1[1];
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  result = a1[5];
  v2[5] = result;
  ++dword_80EFDA0;
  return result;
}
// 80EFDA0: using guessed type int dword_80EFDA0;
// 80EFDA4: using guessed type int dword_80EFDA4;
// 80EFDBC: using guessed type int dword_80EFDBC;
// 82396C0: using guessed type int dword_82396C0[];

//----- (08070E61) --------------------------------------------------------
_DWORD *__stdcall sub_8070E61(_DWORD *a1)
{
  int v1; // edx

  if ( dword_80EFDA0 <= dword_80EFDA4 )
  {
    sub_8070B87(a1);
  }
  else
  {
    v1 = 6 * dword_80EFDA4++;
    *a1 = dword_82396C0[v1];
    a1[1] = dword_82396C4[v1];
    a1[2] = dword_82396C8[v1];
    a1[3] = dword_82396CC[v1];
    a1[4] = dword_82396D0[v1];
    a1[5] = dword_82396D4[v1];
  }
  return a1;
}
// 80EFDA0: using guessed type int dword_80EFDA0;
// 80EFDA4: using guessed type int dword_80EFDA4;
// 82396C0: using guessed type int dword_82396C0[];
// 82396C4: using guessed type int dword_82396C4[];
// 82396C8: using guessed type int dword_82396C8[];
// 82396CC: using guessed type int dword_82396CC[];
// 82396D0: using guessed type int dword_82396D0[];
// 82396D4: using guessed type int dword_82396D4[];

//----- (08070EEE) --------------------------------------------------------
void __cdecl SV_PacketEvent(_DWORD *a1, int a2)
{
  int v2; // [esp+20h] [ebp-8h]
  int v3; // [esp+24h] [ebp-4h]

  v3 = 0;
  if ( *(dword_84898C0 + 32) )
    v3 = sub_80CA93C();
  sub_80949F4(*a1, a1[1], a1[2], a1[3], a1[4], a2);
  if ( *(dword_84898C0 + 32) )
  {
    v2 = sub_80CA93C();
    if ( *(dword_84898C0 + 32) == 3 )
      Com_Printf("SV_PacketEvent time: %i\n", v2 - v3);
  }
}
// 84898C0: using guessed type int dword_84898C0;

//----- (08070F7C) --------------------------------------------------------
int sub_8070F7C()
{
  int v1[3]; // [esp+30h] [ebp-8068h] BYREF
  size_t n; // [esp+3Ch] [ebp-805Ch]
  char s[32768]; // [esp+50h] [ebp-8048h] BYREF
  int v4[8]; // [esp+8050h] [ebp-48h] BYREF
  int v5; // [esp+8070h] [ebp-28h] BYREF
  char v6[4]; // [esp+8074h] [ebp-24h]
  int v7; // [esp+8080h] [ebp-18h]
  void *ptr; // [esp+8084h] [ebp-14h]

  memset(s, 0, sizeof(s));
  MSG_Init(v1, s, 0x8000);
  while ( 1 )
  {
    sub_8070E61(&v5);
    if ( !*v6 )
      break;
    switch ( *v6 )
    {
      case 0:
        continue;
      case 1:
        sub_80851B4();
        break;
      case 2:
        sub_808519B();
        break;
      case 3:
        sub_8085187();
        break;
      case 4:
        sub_80851D2();
        break;
      case 5:
        sub_805F9FA(ptr);
        sub_806BB25(ptr);
        sub_805F9FA("\n");
        break;
      case 6:
        v4[0] = *ptr;
        v4[1] = *(ptr + 1);
        v4[2] = *(ptr + 2);
        v4[3] = *(ptr + 3);
        v4[4] = *(ptr + 4);
        n = v7 - 20;
        if ( (v7 - 20) <= v1[2] )
        {
          memcpy(v1[1], ptr + 20, n);
          sub_806BB25(ptr);
          if ( *(dword_84897C0 + 32) )
            SV_PacketEvent(v4, v1);
          else
            sub_8085196();
        }
        else
        {
          sub_806BB25(ptr);
          Com_Printf("Com_EventLoop: oversize packet\n");
        }
        break;
      default:
        sub_80704AC(0, &byte_80DEC60, *v6);
    }
  }
  while ( sub_8084B49(0, v4, v1) )
    sub_8085196();
  while ( sub_8084B49(1, v4, v1) )
  {
    if ( *(dword_84897C0 + 32) )
      SV_PacketEvent(v4, v1);
  }
  return v5;
}
// 84897C0: using guessed type int dword_84897C0;

//----- (0807123E) --------------------------------------------------------
int sub_807123E()
{
  int v1; // [esp+10h] [ebp-28h] BYREF
  int v2; // [esp+14h] [ebp-24h]

  do
  {
    sub_8070B87(&v1);
    if ( v2 )
      sub_8070D36(&v1);
  }
  while ( v2 );
  return v1;
}

//----- (0807129B) --------------------------------------------------------
void __noreturn sub_807129B()
{
  if ( sub_805FF1E() > 1 )
    sub_80704AC(1, &byte_80DECDC);
  sub_80704AC(0, &byte_80DECF0);
}

//----- (080712D7) --------------------------------------------------------
void sub_80712D7()
{
  char *v0; // eax
  int v1; // [esp+10h] [ebp-8h]
  float v2; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    v2 = atof(v0);
    v1 = sub_807123E();
    while ( (sub_807123E() - v1) * 0.001 <= v2 )
      ;
  }
  else
  {
    Com_Printf("freeze <seconds>\n");
  }
}

//----- (08071344) --------------------------------------------------------
void sub_8071344()
{
  MEMORY[0] = 305419896;
}

//----- (08071353) --------------------------------------------------------
char *sub_8071353()
{
  return strcpy(a123456789, "                ");
}

//----- (0807136F) --------------------------------------------------------
char *sub_807136F()
{
  char *result; // eax
  unsigned int n; // [esp+18h] [ebp-30h]
  void *src; // [esp+1Ch] [ebp-2Ch] BYREF
  char dest[16]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+30h] [ebp-18h] BYREF

  n = sub_8062EB0("cdkey", 0);
  if ( sub_8062EB0("cdkey", &src)
    || (memcpy(dest, src, n), n != 21)
    || (memcpy(a123456789, dest, 0x10u),
        byte_80EFDD0 = 0,
        memcpy(&unk_80EFDE2, &v4, 4u),
        byte_80EFDE6 = 0,
        (result = sub_80851EB()) == 0) )
  {
    result = sub_8071353();
  }
  return result;
}
// 80EFDD0: using guessed type char byte_80EFDD0;
// 80EFDE6: using guessed type char byte_80EFDE6;

//----- (08071439) --------------------------------------------------------
int __cdecl sub_8071439(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < a2; ++i )
    v3 = *(a1 + i) + 31337 * v3;
  return (v3 & 0xFFFFFFF) + 1;
}

//----- (08071489) --------------------------------------------------------
int sub_8071489()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h] BYREF

  v1 = sub_8062EB0("configure_mp.csv", &v2);
  if ( v1 < 0 )
    sub_80704AC(0, aExeErrNotFound);
  sub_8071439(v2, v1);
  sub_8063207(v2);
  return sub_80C9024();
}

//----- (080714EC) --------------------------------------------------------
void sub_80714EC()
{
  ;
}

//----- (080714F1) --------------------------------------------------------
int sub_80714F1()
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  if ( *(dword_8488708 + 32) || *(dword_84898CC + 32) )
    v1 = 1;
  return sub_80AA818(v1, *(dword_84897C8 + 32), *(dword_8488708 + 32));
}
// 8488708: using guessed type int dword_8488708;
// 84897C8: using guessed type int dword_84897C8;
// 84898CC: using guessed type int dword_84898CC;

//----- (0807154E) --------------------------------------------------------
void __cdecl sub_807154E(char *a1)
{
  char *v1; // eax
  unsigned __int16 v2; // ax
  char *s2; // [esp+18h] [ebp-10h]

  Com_Printf("%s %s build %s %s\n", "CODUO MP", "1.51", "linux-i386", "Feb 10 2005");
  if ( __sigsetjmp(env, 0) )
  {
    sub_807032A();
    sub_80C8793("Error during initialization");
  }
  sub_8070CFE();
  sub_8073A2F();
  sub_80706B8(a1);
  sub_80866CA();
  sub_805F9D7();
  sub_806BD7F();
  sub_8060603();
  sub_80707BC(0);
  sub_80707BC("developer");
  sub_80851D7();
  sub_8065AB2();
  sub_8070A72();
  sub_805F9FA("exec default_mp.cfg\n");
  sub_805F9FA("exec language.cfg\n");
  sub_805F9FA("exec uoconfig_mp_server.cfg\n");
  sub_805F9FA("exec autoexec_mp.cfg\n");
  if ( sub_8070717() )
    sub_805F9FA("exec safemode_mp_server.cfg\n");
  sub_805FB6E();
  dword_84897C4 = sub_8073114("com_recommendedSet", "0", 1);
  if ( !*(dword_84897C4 + 32) || sub_8071489() )
  {
    sub_80714EC();
    sub_8073798("com_recommendedSet", "1");
  }
  if ( sub_80C901A() )
    sub_80714EC();
  sub_80707BC(0);
  dword_84886E0 = sub_8073114("dedicated", "2", 64);
  sub_806C0C7();
  dword_84898D8 &= 0xFFFFFFFE;
  dword_8489720 = sub_8073114("com_maxfps", "85", 1);
  dword_8488708 = sub_8073114("developer", "0", 256);
  dword_84897C8 = sub_8073114("developer_script", "0", 256);
  dword_84898CC = sub_8073114("logfile", "0", 0);
  dword_8488714 = sub_8073114("timescale", "1", 2560);
  dword_84897D4 = sub_8073114("fixedtime", "0", 512);
  dword_8488710 = sub_8073114("viewlog", "0", 512);
  dword_84898C0 = sub_8073114("com_speeds", "0", 0);
  dword_8488700 = sub_8073114("sv_paused", "0", 64);
  dword_84898B4 = sub_8073114("cl_paused", "0", 64);
  dword_84897C0 = sub_8073114("sv_running", "0", 64);
  dword_84898B8 = sub_8073114("cl_running", "0", 64);
  dword_84897D8 = sub_8073114("com_introplayed", "0", 1);
  dword_84898AC = sub_8073114("com_animCheck", "0", 0);
  dword_84886E4 = 0;
  if ( *(dword_84886E0 + 32) && !*(dword_8488710 + 32) )
    sub_8073798("viewlog", "1");
  if ( dword_8488708 && *(dword_8488708 + 32) )
  {
    sub_8060272("error", sub_807129B);
    sub_8060272("crash", sub_8071344);
    sub_8060272("freeze", sub_80712D7);
  }
  sub_8060272("quit", sub_807066C);
  sub_8060272("writeconfig", sub_8071C38);
  sub_8060272("writedefaults", sub_8071CB4);
  v1 = sub_804A030();
  s2 = sub_8086D78("%s %s build %s %s", "CODUO MP", "1.51", v1, "linux-i386");
  dword_84898C4 = sub_8073114("version", s2, 64);
  dword_84898BC = sub_8073114("shortversion", "1.51", 68);
  sub_80C8749();
  v2 = sub_807123E();
  sub_8083E5F(v2);
  sub_80714F1();
  sub_80B7D84();
  sub_80C5338();
  sub_809BC50();
  sub_8092211();
  sub_80CA5E0();
  *(dword_84886E0 + 20) = 0;
  if ( !*(dword_84886E0 + 32) )
  {
    sub_808513D();
    sub_80CB230();
  }
  dword_848871C = sub_807123E();
  sub_807088E();
  sub_8073798("r_uiFullScreen", "1");
  sub_80851E1();
  if ( !*(dword_84886E0 + 32) )
    sub_80CB230();
  if ( !*(dword_84886E0 + 32) )
  {
    sub_8073798("cl_movieplaying", "0");
    if ( !*(dword_84897D8 + 32) )
    {
      sub_8073798(*dword_84897D8, "1");
      sub_805F9FA("cinematic atvi.bik\n");
      sub_8073798("nextmap", "cinematic gmi_logo.roq");
      sub_8073798("nextmap", "cinematic iw_logo.roq");
    }
  }
  sub_8073798("com_statmon", "0");
  dword_84886E8 = 1;
  Com_Printf("--- Common Initialization Complete ---\n");
}
// 807066C: using guessed type int sub_807066C(void);
// 84886E0: using guessed type int dword_84886E0;
// 84886E4: using guessed type int dword_84886E4;
// 84886E8: using guessed type int dword_84886E8;
// 8488700: using guessed type int dword_8488700;
// 8488708: using guessed type int dword_8488708;
// 8488710: using guessed type int dword_8488710;
// 8488714: using guessed type int dword_8488714;
// 848871C: using guessed type int dword_848871C;
// 8489720: using guessed type int dword_8489720;
// 84897C0: using guessed type int dword_84897C0;
// 84897C4: using guessed type int dword_84897C4;
// 84897C8: using guessed type int dword_84897C8;
// 84897D4: using guessed type int dword_84897D4;
// 84897D8: using guessed type int dword_84897D8;
// 84898AC: using guessed type int dword_84898AC;
// 84898B4: using guessed type int dword_84898B4;
// 84898B8: using guessed type int dword_84898B8;
// 84898BC: using guessed type int dword_84898BC;
// 84898C0: using guessed type int dword_84898C0;
// 84898C4: using guessed type int dword_84898C4;
// 84898CC: using guessed type int dword_84898CC;
// 84898D8: using guessed type int dword_84898D8;

//----- (08071B45) --------------------------------------------------------
void __cdecl sub_8071B45(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_80611FB(src);
  if ( v1 )
  {
    sub_8062A7E(v1, "// generated by Call of Duty, do not modify\n");
    sub_808518C();
    sub_80740AB(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (08071BAA) --------------------------------------------------------
void __cdecl sub_8071BAA(char *src)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_80611FB(src);
  if ( v1 )
  {
    sub_8062A7E(v1, "// generated by Call of Duty, do not modify\n");
    sub_8074190(v1);
    FS_FCloseFile(v1);
  }
  else
  {
    Com_Printf("Couldn't write %s.\n", src);
  }
}

//----- (08071C04) --------------------------------------------------------
void sub_8071C04()
{
  if ( dword_84886E8 )
  {
    if ( (dword_84898D8 & 1) != 0 )
    {
      dword_84898D8 &= 0xFFFFFFFE;
      sub_8071B45("uoconfig_mp_server.cfg");
    }
  }
}
// 84886E8: using guessed type int dword_84886E8;
// 84898D8: using guessed type int dword_84898D8;

//----- (08071C38) --------------------------------------------------------
void sub_8071C38()
{
  char *v0; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    Q_strncpyz(dest, v0, 64);
    sub_808637A(dest, 0x40u, ".cfg");
    Com_Printf("Writing %s.\n", dest);
    sub_8071B45(dest);
  }
  else
  {
    Com_Printf("Usage: writeconfig <filename>\n");
  }
}

//----- (08071CB4) --------------------------------------------------------
void sub_8071CB4()
{
  char *v0; // eax
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    Q_strncpyz(dest, v0, 64);
    sub_808637A(dest, 0x40u, ".cfg");
    Com_Printf("Writing %s.\n", dest);
    sub_8071BAA(dest);
  }
  else
  {
    Com_Printf("Usage: writedefaults <filename>\n");
  }
}

//----- (08071D30) --------------------------------------------------------
int __cdecl sub_8071D30(int a1)
{
  int v2; // [esp+20h] [ebp+8h]

  if ( *(dword_8488714 + 28) < 0.0 )
    sub_8073798("timescale", "0");
  if ( *(dword_84897D4 + 32) )
    v2 = *(dword_84897D4 + 32);
  else
    v2 = (a1 * *(dword_8488714 + 28));
  if ( v2 <= 0 && *(dword_8488714 + 28) != 0.0 )
    v2 = 1;
  return v2;
}
// 8488714: using guessed type int dword_8488714;
// 84897D4: using guessed type int dword_84897D4;

//----- (08071DC1) --------------------------------------------------------
int __cdecl sub_8071DC1(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( *(dword_84886E0 + 32) )
  {
    if ( a1 > 500 && a1 <= 499999 )
      Com_Printf("Hitch warning: %i msec frame time\n", a1);
    v2 = 5000;
  }
  else if ( *(dword_84897C0 + 32) )
  {
    v2 = 200;
  }
  else
  {
    v2 = 5000;
  }
  if ( a1 > v2 )
    a1 = v2;
  return a1;
}
// 84886E0: using guessed type int dword_84886E0;
// 84897C0: using guessed type int dword_84897C0;

//----- (08071E2E) --------------------------------------------------------
int sub_8071E2E()
{
  int result; // eax
  int v1; // [esp+38h] [ebp-30h]
  int v2; // [esp+3Ch] [ebp-2Ch]
  int v3; // [esp+40h] [ebp-28h]
  int v4; // [esp+44h] [ebp-24h]
  int v5; // [esp+48h] [ebp-20h]
  int v6; // [esp+50h] [ebp-18h]
  int v7; // [esp+58h] [ebp-10h]
  int v8; // [esp+58h] [ebp-10h]

  if ( __sigsetjmp(env, 0) )
    return sub_807032A();
  v5 = 0;
  v4 = 0;
  v3 = 0;
  v2 = 0;
  v1 = 0;
  sub_8071C04();
  if ( *(dword_8488710 + 20) )
  {
    if ( *(dword_84886E0 + 28) == 0.0 )
      sub_80CB230();
    *(dword_8488710 + 20) = 0;
  }
  sub_809C040(*(dword_84898AC + 32));
  if ( *(dword_84898C0 + 32) )
    v5 = sub_80CA93C();
  v6 = 1;
  if ( *(dword_8489720 + 32) > 0 && !*(dword_84886E0 + 32) )
    v6 = 1000 / *(dword_8489720 + 32);
  do
  {
    dword_848871C = sub_8070F7C();
    if ( dword_8239608 > dword_848871C )
      dword_8239608 = dword_848871C;
    v7 = dword_848871C - dword_8239608;
  }
  while ( dword_848871C - dword_8239608 < v6 );
  sub_805FB6E();
  dword_8239608 = dword_848871C;
  v8 = sub_8071DC1(v7);
  sub_8071D30(v8);
  if ( *(dword_84898C0 + 32) )
    v4 = sub_80CA93C();
  sub_8095202(v8);
  if ( *(dword_84898C0 + 32) )
    v3 = sub_80CA93C();
  if ( *(dword_84886E0 + 32) )
  {
    if ( *(dword_84898C0 + 32) )
    {
      v1 = sub_80CA93C();
      v2 = v1;
    }
  }
  else
  {
    sub_8070F7C();
    sub_805FB6E();
    if ( *(dword_84898C0 + 32) )
      v2 = sub_80CA93C();
    sub_8085191();
    if ( *(dword_84898C0 + 32) )
      v1 = sub_80CA93C();
  }
  if ( *(dword_84898C0 + 32) )
    Com_Printf(
      "frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i\n",
      *dword_8489728,
      v1 - v4,
      v3 - v4 - dword_848972C,
      v2 + v4 - v5 - v3,
      v1 - v2 - (dword_848870C + dword_84898C8),
      dword_848972C,
      dword_84898C8,
      dword_848870C);
  result = -2027669113 * dword_8239608;
  ++*dword_8489728;
  return result;
}
// 8239608: using guessed type int dword_8239608;
// 84886E0: using guessed type int dword_84886E0;
// 848870C: using guessed type int dword_848870C;
// 8488710: using guessed type int dword_8488710;
// 848871C: using guessed type int dword_848871C;
// 8489720: using guessed type int dword_8489720;
// 848972C: using guessed type int dword_848972C;
// 84898AC: using guessed type int dword_84898AC;
// 84898C0: using guessed type int dword_84898C0;
// 84898C8: using guessed type int dword_84898C8;

//----- (080720E4) --------------------------------------------------------
void sub_80720E4()
{
  sub_8072A1C();
  sub_80C5384();
  sub_80B7EBA();
  sub_80AA872();
  if ( dword_82396BC )
  {
    FS_FCloseFile(dword_82396BC);
    dword_82396BC = 0;
  }
  if ( *dword_84898B0 )
  {
    FS_FCloseFile(*dword_84898B0);
    *dword_84898B0 = 0;
  }
}
// 82396BC: using guessed type int dword_82396BC;

//----- (08072140) --------------------------------------------------------
_DWORD *__cdecl sub_8072140(_DWORD *a1)
{
  _DWORD *result; // eax

  memset(a1 + 7, 0, 0x100u);
  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 256;
  return result;
}

//----- (08072183) --------------------------------------------------------
char *__cdecl sub_8072183(char *src)
{
  int v1; // eax
  char *result; // eax
  int v3; // ebx
  int i; // [esp+10h] [ebp-8h]

  v1 = strlen(dword_823AEC0);
  result = sub_8086946(src, dword_823AEC0, v1);
  if ( !result )
  {
    if ( ++dword_823B2E0 == 1 )
    {
      result = Q_strncpyz(&byte_823AEE0, src, 1024);
    }
    else
    {
      for ( i = 0; ; ++i )
      {
        result = &src[i];
        if ( !src[i] )
          break;
        v3 = tolower(*(i + 136556256));
        if ( v3 != tolower(src[i]) )
          *(i + 136556256) = 0;
      }
    }
  }
  return result;
}
// 823B2E0: using guessed type int dword_823B2E0;

//----- (08072237) --------------------------------------------------------
void __cdecl sub_8072237(char *a1)
{
  int v1; // eax

  v1 = strlen(&byte_823AEE0);
  if ( !sub_8086946(a1, &byte_823AEE0, v1) )
    Com_Printf("    %s\n", a1);
}

//----- (08072279) --------------------------------------------------------
int sub_8072279()
{
  int result; // eax
  char *v1; // eax
  char *j; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = sub_805FF1E();
    if ( i >= result )
      break;
    sub_8086B0B(dword_823B2E4 + 28, 256, " ");
    for ( j = sub_805FF28(i); *j; ++j )
    {
      if ( *j == 32 )
      {
        sub_8086B0B(dword_823B2E4 + 28, 256, "\"");
        break;
      }
    }
    v1 = sub_805FF28(i);
    sub_8086B0B(dword_823B2E4 + 28, 256, v1);
    if ( *j == 32 )
      sub_8086B0B(dword_823B2E4 + 28, 256, "\"");
  }
  return result;
}

//----- (08072359) --------------------------------------------------------
char *__cdecl sub_8072359(char *haystack, char *needle)
{
  size_t v3; // eax
  char *src; // [esp+14h] [ebp-4h]

  src = strstr(haystack, needle);
  if ( !src )
    return sub_8072279();
  v3 = strlen(needle);
  return sub_8086B0B(dword_823B2E4 + 28, 256, &src[v3]);
}

//----- (080723B4) --------------------------------------------------------
char *__cdecl sub_80723B4(char **a1)
{
  char *result; // eax
  char **v2; // ebx
  size_t *v3; // ebx
  char dest[28]; // [esp+10h] [ebp-128h] BYREF
  char v5[268]; // [esp+2Ch] [ebp-10Ch] BYREF

  dword_823B2E4 = a1;
  sub_8060257(a1 + 7);
  dword_823AEC0 = sub_805FF28(0);
  if ( *dword_823AEC0 == 92 || *dword_823AEC0 == 47 )
    ++dword_823AEC0;
  dword_823B2E0 = 0;
  byte_823AEE0 = 0;
  result = dword_823AEC0;
  if ( *dword_823AEC0 )
  {
    sub_80603B9(sub_8072183);
    result = sub_8073B85(sub_8072183);
    if ( dword_823B2E0 )
    {
      sub_80C835C(dest, dword_823B2E4, 0x11Cu);
      if ( dword_823B2E0 == 1 )
      {
        Com_sprintf(dword_823B2E4 + 28, 0x100u, "\\%s", &byte_823AEE0);
        if ( sub_805FF1E() == 1 )
          sub_8086B0B(dword_823B2E4 + 28, 256, " ");
        else
          sub_8072359(v5, dword_823AEC0);
        v2 = dword_823B2E4;
        result = strlen(dword_823B2E4 + 28);
        *v2 = result;
      }
      else
      {
        Com_sprintf(dword_823B2E4 + 28, 0x100u, "\\%s", &byte_823AEE0);
        v3 = dword_823B2E4;
        *v3 = strlen(dword_823B2E4 + 28);
        sub_8072359(v5, dword_823AEC0);
        Com_Printf("]%s\n", dword_823B2E4 + 28);
        sub_80603B9(sub_8072237);
        result = sub_8073B85(sub_8072237);
      }
    }
  }
  return result;
}
// 823B2E0: using guessed type int dword_823B2E0;

//----- (080725CB) --------------------------------------------------------
int __cdecl sub_80725CB(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( word_8252D00[a1] )
    v2 = 92 * word_8252D00[a1] + 136557312;
  else
    v2 = 0;
  return v2;
}

//----- (08072603) --------------------------------------------------------
int sub_8072603()
{
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = dword_8253500 + 1; i <= 1023; ++i )
  {
    if ( (byte_8252300[i >> 2] & (3 << (2 * (i & 3)))) == 0 )
    {
      dword_8253500 = i;
      return i;
    }
  }
  for ( j = 1; ; ++j )
  {
    if ( j > dword_8253500 )
      sub_80704AC(1, &byte_80DF191);
    if ( (byte_8252300[j >> 2] & (3 << (2 * (j & 3)))) == 0 )
      break;
  }
  dword_8253500 = j;
  return j;
}
// 8253500: using guessed type int dword_8253500;

//----- (08072755) --------------------------------------------------------
int __cdecl sub_8072755(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5)
{
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8072603();
  byte_8252300[v6 >> 2] |= 2 << (2 * (v6 & 3));
  word_8252D00[a4] = v6;
  return sub_80C667A(a1, a2, a3, &unk_823B300 + 92 * v6, a5);
}

//----- (080727E5) --------------------------------------------------------
int __cdecl sub_80727E5(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  result = word_8252400[a1];
  v3 = result;
  if ( word_8252400[a1] )
  {
    word_8252400[a1] = 0;
    byte_8252300[result >> 2] &= ~(1 << (2 * (result & 3)));
    result = byte_8252300[result >> 2] & (3 << (2 * (result & 3)));
    if ( !result )
      result = sub_80C6962(&unk_823B300 + 92 * v3, a2);
  }
  return result;
}

//----- (08072884) --------------------------------------------------------
int __cdecl sub_8072884(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  result = word_8252D00[a1];
  v3 = result;
  if ( word_8252D00[a1] )
  {
    word_8252D00[a1] = 0;
    byte_8252300[result >> 2] &= ~(2 << (2 * (result & 3)));
    result = byte_8252300[result >> 2] & (3 << (2 * (result & 3)));
    if ( !result )
      result = sub_80C6962(&unk_823B300 + 92 * v3, a2);
  }
  return result;
}

//----- (080729AC) --------------------------------------------------------
void *sub_80729AC()
{
  void *result; // eax

  sub_80C837D(&byte_8252300, 0, 0x100u);
  sub_80C837D(&word_8252400, 0, 0x900u);
  result = sub_80C837D(word_8252D00, 0, 0x800u);
  dword_8253500 = 1;
  dword_80EFDA8 = 1;
  return result;
}
// 80EFDA8: using guessed type int dword_80EFDA8;
// 8252300: using guessed type char byte_8252300;
// 8252400: using guessed type __int16 word_8252400;
// 8253500: using guessed type int dword_8253500;

//----- (08072A1C) --------------------------------------------------------
void sub_8072A1C()
{
  if ( dword_80EFDA8 )
    dword_80EFDA8 = 0;
}
// 80EFDA8: using guessed type int dword_80EFDA8;

//----- (08072A36) --------------------------------------------------------
void *sub_8072A36()
{
  sub_8072A1C();
  sub_80C5384();
  sub_80B7EBA();
  sub_80AA872();
  sub_80714F1();
  sub_80B7D84();
  sub_80C5338();
  return sub_80729AC();
}

//----- (08072A66) --------------------------------------------------------
void *__cdecl sub_8072A66(size_t a1)
{
  return sub_806C531(a1);
}

//----- (08072A79) --------------------------------------------------------
void *__cdecl sub_8072A79(size_t a1)
{
  return sub_806C3D4(a1);
}

//----- (08072A9F) --------------------------------------------------------
_DWORD *__cdecl sub_8072A9F(int a1)
{
  return sub_80B969A(a1, sub_8072A66);
}

//----- (08072ABA) --------------------------------------------------------
int __cdecl sub_8072ABA(int a1)
{
  return sub_80A2F68(a1);
}

//----- (08072AD5) --------------------------------------------------------
_DWORD *__cdecl sub_8072AD5(int a1)
{
  return sub_80B969A(a1, sub_8072ABA);
}

//----- (08072AF0) --------------------------------------------------------
int __cdecl sub_8072AF0(int a1)
{
  return sub_80B9700(a1, sub_80A2F8E);
}

//----- (08072B0B) --------------------------------------------------------
int __cdecl sub_8072B0B(signed int a1, _DWORD *a2, int a3)
{
  if ( a1 <= 0 )
    return 0;
  if ( dword_80EFDEC )
  {
    *a2 = dword_80EFDF0;
    if ( !dword_80EFDF0 )
      dword_80EFDF0 = a3;
  }
  else
  {
    dword_80EFDEC = sub_806C531(a1);
    dword_80EFDF0 = a3;
    *a2 = 0;
  }
  return dword_80EFDEC;
}
// 80EFDEC: using guessed type int dword_80EFDEC;
// 80EFDF0: using guessed type int dword_80EFDF0;

//----- (08072B74) --------------------------------------------------------
int __cdecl sub_8072B74(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == dword_80EFDF0 )
  {
    if ( !a2 )
      dword_80EFDEC = 0;
    dword_80EFDF0 = 0;
  }
  return result;
}
// 80EFDEC: using guessed type int dword_80EFDEC;
// 80EFDF0: using guessed type int dword_80EFDF0;

//----- (08072DCA) --------------------------------------------------------
int sub_8072DCA()
{
  return -1;
}

//----- (08072DD4) --------------------------------------------------------
const char *sub_8072DD4()
{
  return "default";
}

//----- (08072DDE) --------------------------------------------------------
int __cdecl sub_8072DDE(_BYTE *a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+0h] [ebp-8h]
  int j; // [esp+0h] [ebp-8h]
  int v8; // [esp+4h] [ebp-4h]

  v8 = 0;
  if ( a5 )
  {
    if ( *a1 )
    {
      for ( i = 0; i < a4 - a3 && a1[i]; ++i )
      {
        if ( a1[i] <= 32 )
        {
          v8 = 1;
          break;
        }
      }
    }
    else
    {
      v8 = 1;
    }
  }
  if ( v8 && a3 < a4 )
    *(a2 + a3++) = 34;
  for ( j = 0; a3 < a4 && a1[j]; ++j )
    *(a2 + a3++) = a1[j];
  if ( v8 && a3 < a4 )
    *(a2 + a3++) = 34;
  return a3;
}

//----- (08072EB8) --------------------------------------------------------
int __cdecl sub_8072EB8(int a1)
{
  char v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !a1 )
    sub_80704AC(1, &byte_80DF260, v2);
  v3 = 0;
  for ( i = 0; *(a1 + i); ++i )
    v3 += tolower(*(a1 + i)) * (i + 119);
  return v3;
}
// 8072ED3: variable 'v2' is possibly undefined

//----- (08072F2D) --------------------------------------------------------
_BOOL4 __cdecl sub_8072F2D(char *s)
{
  if ( !s )
    return 0;
  if ( strchr(s, 92) )
    return 0;
  if ( strchr(s, 34) )
    return 0;
  return strchr(s, 59) == 0;
}

//----- (08072FAE) --------------------------------------------------------
int __cdecl sub_8072FAE(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_8269540[sub_8072EB8(a1)]; i; i = *(i + 40) )
  {
    if ( !sub_8086A5A(a1, *i) )
      return i;
  }
  return 0;
}

//----- (0807300E) --------------------------------------------------------
unsigned int *sub_807300E()
{
  unsigned int *result; // eax
  unsigned int i; // [esp+10h] [ebp-8h] BYREF
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0xFF; ++i )
  {
    for ( j = dword_8269540[i]; j; j = *(j + 40) )
    {
      if ( *(j + 12) )
      {
        sub_806BB25(*(j + 12));
        *(j + 12) = 0;
      }
      if ( *(j + 4) )
      {
        sub_806BB25(*(j + 4));
        *(j + 4) = 0;
      }
      if ( *(j + 8) )
      {
        sub_806BB25(*(j + 8));
        *(j + 8) = 0;
      }
      sub_806BB25(*j);
      *j = 0;
    }
    dword_8269540[i] = 0;
    result = &i;
  }
  *dword_84898D4 = 0;
  dword_84898D0 = 0;
  dword_8253520 = 0;
  dword_8253524 = 0;
  dword_84898D8 = 0;
  return result;
}
// 8253520: using guessed type int dword_8253520;
// 8253524: using guessed type int dword_8253524;
// 84898D0: using guessed type int dword_84898D0;
// 84898D8: using guessed type int dword_84898D8;

//----- (08073114) --------------------------------------------------------
int *__cdecl sub_8073114(char *s, char *s2, int a3)
{
  char *v3; // eax
  int v4; // eax
  char v6; // [esp+8h] [ebp-30h]
  int *v7; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+24h] [ebp-14h]
  const char ***i; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]
  int *v11; // [esp+30h] [ebp-8h]

  if ( !s || !s2 )
    sub_80704AC(0, &byte_80DF280, v6);
  if ( !sub_8072F2D(s) )
  {
    v3 = sub_8086D78("invalid cvar name string: %s", s);
    sub_80704AC(0, v3, v6);
  }
  v10 = sub_8072FAE(s);
  if ( v10 )
  {
    if ( (*(v10 + 16) & 0x1080) != 0 && (a3 & 0x1080) == 0 && (*s2 || (a3 & 0x200) != 0) )
    {
      *(v10 + 16) &= 0xFFFFEF7F;
      sub_806BB25(*(v10 + 8));
      *(v10 + 8) = sub_806BB76(s2);
      dword_84898D8 |= a3;
    }
    *(v10 + 16) |= a3;
    if ( **(v10 + 8) )
    {
      if ( *s2 && strcmp(*(v10 + 8), s2) )
        Com_DPrintf("Warning: cvar \"%s\" given initial values: \"%s\" and \"%s\"\n", s, *(v10 + 8), s2);
    }
    else
    {
      sub_806BB25(*(v10 + 8));
      *(v10 + 8) = sub_806BB76(s2);
    }
    if ( *(v10 + 12) )
    {
      ptr = *(v10 + 12);
      *(v10 + 12) = 0;
      sub_8073440(s, ptr, 1);
      sub_806BB25(ptr);
    }
    if ( (*(v10 + 16) & 0x200) != 0 && dword_8253520 && !*(dword_8253520 + 32) )
      sub_8073440(s, s2, 1);
    v7 = v10;
  }
  else
  {
    if ( *dword_84898D4 > 2047 )
      sub_80704AC(0, "MAX_CVARS", v6);
    v11 = &dword_8253540[11 * (*dword_84898D4)++];
    *v11 = sub_806BB76(s);
    v11[1] = sub_806BB76(s2);
    v11[5] = 1;
    v11[6] = 1;
    *(v11 + 7) = atof(v11[1]);
    v11[8] = atoi(v11[1]);
    v11[2] = sub_806BB76(s2);
    for ( i = &dword_84898D0; *i && strcasecmp(*v11, **i) >= 0; i = (*i + 9) )
      ;
    v11[9] = *i;
    *i = v11;
    v11[4] = a3;
    v4 = sub_8072EB8(s);
    v11[10] = dword_8269540[v4];
    dword_8269540[v4] = v11;
    v7 = v11;
  }
  return v7;
}
// 8073136: variable 'v6' is possibly undefined
// 8253520: using guessed type int dword_8253520;
// 84898D0: using guessed type int dword_84898D0;
// 84898D8: using guessed type int dword_84898D8;

//----- (08073440) --------------------------------------------------------
int __cdecl sub_8073440(char *s, char *s1, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+20h] [ebp-8h]

  v3 = sub_8086D78("      cvar set %s %s\n", s);
  sub_806FE5F(4, v3);
  if ( !sub_8072F2D(s) )
  {
    v4 = sub_8086D78("invalid cvar name string: %s", s);
    sub_80704AC(0, v4, s1);
  }
  v8 = sub_8072FAE(s);
  if ( v8 )
  {
    if ( !s1 )
      s1 = *(v8 + 8);
    if ( !strcmp(s1, *(v8 + 4)) )
    {
      if ( (*(v8 + 16) & 0x20) != 0 && *(v8 + 12) )
      {
        sub_806BB25(*(v8 + 12));
        *(v8 + 12) = 0;
      }
      v7 = v8;
    }
    else
    {
      dword_84898D8 |= *(v8 + 16);
      if ( a3 )
      {
        if ( *(v8 + 12) )
        {
          sub_806BB25(*(v8 + 12));
          *(v8 + 12) = 0;
        }
      }
      else
      {
        if ( (*(v8 + 16) & 0x40) != 0 )
        {
          Com_Printf("%s is read only.\n", s);
          return v8;
        }
        if ( (*(v8 + 16) & 0x10) != 0 )
        {
          Com_Printf("%s is write protected.\n", s);
          return v8;
        }
        if ( (*(v8 + 16) & 0x200) != 0 && !*(dword_8253520 + 32) )
        {
          Com_Printf("%s is cheat protected.\n", s);
          return v8;
        }
        if ( *(dword_8253524 + 32) && *(dword_84897C0 + 32) )
        {
          Com_Printf("Consol is locked out, cannot change cvars.\n", v6);
          return v8;
        }
        if ( (*(v8 + 16) & 0x20) != 0 )
        {
          if ( *(v8 + 12) )
          {
            if ( !strcmp(s1, *(v8 + 12)) )
              return v8;
            sub_806BB25(*(v8 + 12));
          }
          else if ( !strcmp(s1, *(v8 + 4)) )
          {
            return v8;
          }
          Com_Printf("%s will be changed upon restarting.\n", s);
          *(v8 + 12) = sub_806BB76(s1);
          *(v8 + 20) = 1;
          return v8;
        }
      }
      if ( strcmp(s1, *(v8 + 4)) )
      {
        *(v8 + 20) = 1;
        ++*(v8 + 24);
        sub_806BB25(*(v8 + 4));
        *(v8 + 4) = sub_806BB76(s1);
        *(v8 + 28) = atof(*(v8 + 4));
        *(v8 + 32) = atoi(*(v8 + 4));
      }
      v7 = v8;
    }
  }
  else if ( s1 )
  {
    if ( a3 )
      v7 = sub_8073114(s, s1, 0);
    else
      v7 = sub_8073114(s, s1, 128);
  }
  else
  {
    v7 = 0;
  }
  return v7;
}
// 8073635: variable 'v6' is possibly undefined
// 8072FAE: using guessed type _DWORD __cdecl sub_8072FAE(_DWORD);
// 8253520: using guessed type int dword_8253520;
// 8253524: using guessed type int dword_8253524;
// 84897C0: using guessed type int dword_84897C0;
// 84898D8: using guessed type int dword_84898D8;

//----- (08073798) --------------------------------------------------------
int __cdecl sub_8073798(char *s, char *s1)
{
  return sub_8073440(s, s1, 1);
}

//----- (080737F5) --------------------------------------------------------
int __cdecl sub_80737F5(char *s, char *s1)
{
  return sub_8073440(s, s1, 0);
}

//----- (08073817) --------------------------------------------------------
int __cdecl sub_8073817(char *a1, float a2)
{
  char s[40]; // [esp+30h] [ebp-28h] BYREF

  if ( a2 == a2 )
    Com_sprintf(s, 0x20u, "%i", a2);
  else
    Com_sprintf(s, 0x20u, "%f", a2);
  return sub_8073798(a1, s);
}

//----- (080738B1) --------------------------------------------------------
int __cdecl sub_80738B1(char *s)
{
  return sub_8073440(s, 0, 0);
}

//----- (080738D4) --------------------------------------------------------
int *__cdecl sub_80738D4(int a1, char *s, char *s2, int a4)
{
  int *result; // eax

  result = sub_8073114(s, s2, a4);
  if ( a1 )
  {
    *a1 = -1171354717 * (result - dword_8253540);
    *(a1 + 4) = -1;
    result = sub_807392B(a1);
  }
  return result;
}

//----- (0807392B) --------------------------------------------------------
int *__cdecl sub_807392B(int a1)
{
  int *result; // eax
  size_t v2; // eax
  int *v3; // [esp+14h] [ebp-4h]

  if ( *a1 >= *dword_84898D4 )
    sub_80704AC(1, &byte_80DF3E0);
  v3 = &dword_8253540[11 * *a1];
  result = v3[6];
  if ( result != *(a1 + 4) )
  {
    result = &dword_8253540[11 * *a1];
    if ( v3[1] )
    {
      *(a1 + 4) = v3[6];
      if ( strlen(v3[1]) + 1 > 0x100 )
      {
        v2 = strlen(v3[1]);
        sub_80704AC(1, &byte_80DF420, v3[1], v2, 256);
      }
      Q_strncpyz((a1 + 16), v3[1], 256);
      *(a1 + 8) = v3[7];
      result = v3[8];
      *(a1 + 12) = result;
    }
  }
  return result;
}

//----- (08073A2F) --------------------------------------------------------
void sub_8073A2F()
{
  dword_8253520 = sub_8073114("sv_cheats", "0", 72);
  dword_8253524 = sub_8073114("sv_console_lockout", "0", 72);
  sub_8074948();
}
// 8253520: using guessed type int dword_8253520;
// 8253524: using guessed type int dword_8253524;

//----- (08073A7E) --------------------------------------------------------
int sub_8073A7E()
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  result = dword_84898D0;
  for ( i = dword_84898D0; i; i = result )
  {
    *(i + 16) &= 0xFFFFDFFF;
    result = *(i + 36);
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08073AB4) --------------------------------------------------------
long double __cdecl sub_8073AB4(char *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8072FAE(a1);
  if ( v3 )
    v2 = *(v3 + 28);
  else
    v2 = 0.0;
  return v2;
}

//----- (08073AE3) --------------------------------------------------------
int __cdecl sub_8073AE3(char *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8072FAE(a1);
  if ( v3 )
    v2 = *(v3 + 32);
  else
    v2 = 0;
  return v2;
}

//----- (08073B14) --------------------------------------------------------
void *__cdecl sub_8073B14(char *a1)
{
  void *v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8072FAE(a1);
  if ( v3 )
    v2 = *(v3 + 4);
  else
    v2 = &unk_80DF480;
  return v2;
}

//----- (08073B45) --------------------------------------------------------
char *__cdecl sub_8073B45(int a1, char *dest, int a3)
{
  char *result; // eax
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_8072FAE(a1);
  if ( v4 )
    return Q_strncpyz(dest, *(v4 + 4), a3);
  result = dest;
  *dest = 0;
  return result;
}

//----- (08073B85) --------------------------------------------------------
int __cdecl sub_8073B85(void (__cdecl *a1)(_DWORD))
{
  int result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  result = dword_84898D0;
  for ( i = dword_84898D0; i; i = result )
  {
    a1(*i);
    result = i[9];
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08073C1A) --------------------------------------------------------
int sub_8073C1A()
{
  char *v0; // eax
  char *v1; // eax
  int v3; // [esp+10h] [ebp-8h]
  const char **v4; // [esp+14h] [ebp-4h]

  v0 = sub_805FF28(0);
  v4 = sub_8072FAE(v0);
  if ( !v4 )
    return 0;
  if ( sub_805FF1E() == 1 )
  {
    Com_Printf("\"%s\" is:\"%s^7\" default:\"%s^7\"\n", *v4, v4[1], v4[2]);
    if ( v4[3] )
      Com_Printf("latched: \"%s\"\n", v4[3]);
    v3 = 1;
  }
  else
  {
    v1 = sub_805FF28(1u);
    sub_8073440(*v4, v1, 0);
    v3 = 1;
  }
  return v3;
}

//----- (08073CD5) --------------------------------------------------------
void sub_8073CD5()
{
  char *v0; // eax
  char *v1; // ebx
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // ebx
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *s1; // [esp+1Ch] [ebp-Ch]
  _BOOL4 v10; // [esp+20h] [ebp-8h]
  signed int i; // [esp+20h] [ebp-8h]

  if ( sub_805FF1E() > 1 )
  {
    if ( sub_805FF1E() == 2 )
    {
      v0 = sub_805FF28(1u);
      v10 = sub_8073AB4(v0) == 0;
      v1 = sub_8086D78("%i", v10);
      v2 = sub_805FF28(1u);
      sub_8073440(v2, v1, 0);
    }
    else
    {
      v3 = sub_805FF28(1u);
      s1 = sub_8073B14(v3);
      for ( i = 2; i < sub_805FF1E() - 1; ++i )
      {
        v4 = sub_805FF28(i);
        if ( !strcmp(s1, v4) )
        {
          v5 = sub_805FF28(i + 1);
          v6 = sub_805FF28(1u);
          sub_8073440(v6, v5, 0);
          return;
        }
      }
      v7 = sub_805FF28(2u);
      v8 = sub_805FF28(1u);
      sub_8073440(v8, v7, 0);
    }
  }
  else
  {
    Com_Printf("usage: toggle <variable> <optional value sequence>\n");
  }
}

//----- (08073E28) --------------------------------------------------------
void sub_8073E28()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  char dest[4096]; // [esp+10h] [ebp-1018h] BYREF
  size_t v4; // [esp+1010h] [ebp-18h]
  int v5; // [esp+1014h] [ebp-14h]
  int v6; // [esp+1018h] [ebp-10h]
  signed int i; // [esp+101Ch] [ebp-Ch]

  v6 = sub_805FF1E();
  if ( v6 > 2 )
  {
    dest[0] = 0;
    v5 = 0;
    for ( i = 2; i < v6; ++i )
    {
      v0 = sub_805FF28(i);
      v4 = strlen(v0 + 1);
      if ( (v5 + v4) > 4093 )
        break;
      v1 = sub_805FF28(i);
      strcat(dest, v1);
      if ( i != v6 - 1 )
        strcat(dest, " ");
      v5 += v4;
    }
    v2 = sub_805FF28(1u);
    sub_8073440(v2, dest, 0);
  }
  else
  {
    Com_Printf("usage: set <variable> <value>\n");
  }
}

//----- (08073F0A) --------------------------------------------------------
void sub_8073F0A()
{
  char *v0; // eax
  int v1; // [esp+4h] [ebp-4h]

  if ( sub_805FF1E() == 3 )
  {
    sub_8073E28();
    v0 = sub_805FF28(1u);
    v1 = sub_8072FAE(v0);
    if ( v1 )
      *(v1 + 16) |= 2u;
  }
  else
  {
    Com_Printf("usage: setu <variable> <value>\n");
  }
}

//----- (08073F5D) --------------------------------------------------------
void sub_8073F5D()
{
  char *v0; // eax
  int v1; // [esp+4h] [ebp-4h]

  if ( sub_805FF1E() == 3 )
  {
    sub_8073E28();
    v0 = sub_805FF28(1u);
    v1 = sub_8072FAE(v0);
    if ( v1 )
      *(v1 + 16) |= 4u;
  }
  else
  {
    Com_Printf("usage: sets <variable> <value>\n");
  }
}

//----- (08073FB0) --------------------------------------------------------
void sub_8073FB0()
{
  char *v0; // eax
  int v1; // [esp+4h] [ebp-4h]

  if ( sub_805FF1E() == 3 )
  {
    sub_8073E28();
    v0 = sub_805FF28(1u);
    v1 = sub_8072FAE(v0);
    if ( v1 )
      *(v1 + 16) |= 1u;
  }
  else
  {
    Com_Printf("usage: seta <variable> <value>\n");
  }
}

//----- (08074003) --------------------------------------------------------
void sub_8074003()
{
  char *v0; // eax
  char *v1; // eax
  char *s1; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 3 )
  {
    v0 = sub_805FF28(2u);
    v3 = sub_8072FAE(v0);
    if ( v3 )
      s1 = *(v3 + 4);
    else
      s1 = &unk_80DF480;
    v1 = sub_805FF28(1u);
    sub_8073440(v1, s1, 0);
  }
  else
  {
    Com_Printf("usage: setfromcvar <variable> <variablein>\n");
  }
}

//----- (08074077) --------------------------------------------------------
void sub_8074077()
{
  char *v0; // eax

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    sub_80738B1(v0);
  }
  else
  {
    Com_Printf("usage: reset <variable>\n");
  }
}

//----- (080740AB) --------------------------------------------------------
const char **__cdecl sub_80740AB(int a1)
{
  const char **result; // eax
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  const char **i; // [esp+42Ch] [ebp-Ch]

  result = dword_84898D0;
  for ( i = dword_84898D0; i; i = result )
  {
    if ( sub_8086A5A(*i, "cl_cdkey") && (i[4] & 1) != 0 )
    {
      if ( i[3] )
        Com_sprintf(s, 0x400u, "seta %s \"%s\"\n", *i, i[3]);
      else
        Com_sprintf(s, 0x400u, "seta %s \"%s\"\n", *i, i[1]);
      sub_8062A7E(a1, "%s", s);
    }
    result = i[9];
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08074190) --------------------------------------------------------
int __cdecl sub_8074190(int a1)
{
  int result; // eax
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  result = dword_84898D0;
  for ( i = dword_84898D0; i; i = result )
  {
    if ( sub_8086A5A(*i, "cl_cdkey") )
    {
      if ( (*(i + 16) & 0x12C0) == 0 )
      {
        Com_sprintf(s, 0x400u, "set %s \"%s\"\n", *i, *(i + 8));
        sub_8062A7E(a1, "%s", s);
      }
    }
    result = *(i + 36);
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08074236) --------------------------------------------------------
void sub_8074236()
{
  char *v0; // [esp+Ch] [ebp-Ch]
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() <= 1 )
    v0 = 0;
  else
    v0 = sub_805FF28(1u);
  v1 = 0;
  v2 = dword_84898D0;
  while ( v2 )
  {
    if ( !v0 || sub_806B606(v0, *v2, 0) )
    {
      if ( (*(v2 + 16) & 0x2004) != 0 )
        Com_Printf(aSurialc);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 2) != 0 )
        Com_Printf(&aSurialc[2]);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 0x40) != 0 )
        Com_Printf(&aSurialc[4]);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 0x10) != 0 )
        Com_Printf(&aSurialc[6]);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 1) != 0 )
        Com_Printf(&aSurialc[8]);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 0x20) != 0 )
        Com_Printf(&aSurialc[10]);
      else
        Com_Printf(" ");
      if ( (*(v2 + 16) & 0x200) != 0 )
        Com_Printf(&aSurialc[12]);
      else
        Com_Printf(" ");
      Com_Printf(" %s \"%s\"\n", *v2, *(v2 + 4));
    }
    v2 = *(v2 + 36);
    ++v1;
  }
  Com_Printf("\n%i total cvars\n", v1);
  Com_Printf("%i cvar indexes\n", *dword_84898D4);
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08074414) --------------------------------------------------------
void sub_8074414()
{
  sub_8074428(0);
}

//----- (08074428) --------------------------------------------------------
void __cdecl sub_8074428(int a1)
{
  char s[8196]; // [esp+20h] [ebp-2018h] BYREF
  int v2; // [esp+2024h] [ebp-14h]
  char v3[4]; // [esp+2028h] [ebp-10h]
  const char **v4; // [esp+202Ch] [ebp-Ch]

  if ( sub_805FF1E() <= 1 )
    v2 = 0;
  else
    v2 = sub_805FF28(1u);
  if ( a1 || dword_84898CC && *(dword_84898CC + 32) )
  {
    *v3 = 0;
    sub_806FE5F(a1, "=============================== CVAR DUMP ========================================\n");
    v4 = dword_84898D0;
    while ( v4 )
    {
      if ( !v2 || sub_806B606(v2, *v4, 0) )
      {
        if ( v4[3] )
          Com_sprintf(s, 0x2000u, "      %s \"%s\" -- latched \"%s\"\n", *v4, v4[1], v4[3]);
        else
          Com_sprintf(s, 0x2000u, "      %s \"%s\"\n", *v4, v4[1]);
        sub_806FE5F(a1, s);
      }
      v4 = v4[9];
      ++*v3;
    }
    Com_sprintf(s, 0x2000u, "\n%i total cvars\n%i cvar indexes\n", *v3, *dword_84898D4);
    sub_806FE5F(a1, s);
    sub_806FE5F(a1, "=============================== END CVAR DUMP =====================================\n");
  }
}
// 84898CC: using guessed type int dword_84898CC;
// 84898D0: using guessed type int dword_84898D0;

//----- (080745C5) --------------------------------------------------------
int __cdecl sub_80745C5(char *s, char *s1)
{
  int result; // eax

  result = sub_8072FAE(s);
  if ( result )
  {
    if ( (*(result + 16) & 0x20) != 0 )
      result = sub_80737F5(s, s1);
    else
      result = sub_8073798(s, s1);
  }
  return result;
}

//----- (08074714) --------------------------------------------------------
int sub_8074714()
{
  int result; // eax
  int *v1; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v1 = &dword_84898D0;
  while ( 1 )
  {
    result = *v1;
    s = *v1;
    if ( !*v1 )
      break;
    if ( (*(s + 4) & 0x450) != 0 )
    {
      v1 = (s + 36);
    }
    else if ( s[16] >= 0 )
    {
      sub_8073798(*s, *(s + 2));
      v1 = (s + 36);
    }
    else
    {
      *v1 = *(s + 9);
      if ( *s )
        sub_806BB25(*s);
      if ( *(s + 1) )
        sub_806BB25(*(s + 1));
      if ( *(s + 3) )
        sub_806BB25(*(s + 3));
      if ( *(s + 2) )
        sub_806BB25(*(s + 2));
      memset(s, 0, 4u);
    }
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (0807480C) --------------------------------------------------------
int __cdecl sub_807480C(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = dword_84898D0;
  for ( i = dword_84898D0; i; i = result )
  {
    if ( (a3 & *(i + 16)) != 0 )
      sub_80910B8(a1, a2, *i, *(i + 4));
    result = *(i + 36);
  }
  return result;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08074863) --------------------------------------------------------
char *__cdecl sub_8074863(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  byte_8269940 = 0;
  for ( i = dword_84898D0; i; i = *(i + 36) )
  {
    if ( (a1 & *(i + 16)) != 0 )
      sub_808733D(&byte_8269940, *i, *(i + 4));
  }
  return &byte_8269940;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (080748C0) --------------------------------------------------------
char *__cdecl sub_80748C0(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  byte_8269D40 = 0;
  for ( i = dword_84898D0; i; i = *(i + 36) )
  {
    if ( (a1 & *(i + 16)) != 0 )
      sub_8087570(&byte_8269D40, *i, *(i + 4));
  }
  return &byte_8269D40;
}
// 84898D0: using guessed type int dword_84898D0;

//----- (08074948) --------------------------------------------------------
void sub_8074948()
{
  sub_8060272("toggle", sub_8073CD5);
  sub_8060272("set", sub_8073E28);
  sub_8060272("sets", sub_8073F5D);
  sub_8060272("setu", sub_8073F0A);
  sub_8060272("seta", sub_8073FB0);
  sub_8060272("setfromcvar", sub_8074003);
  sub_8060272("reset", sub_8074077);
  sub_8060272("cvarlist", sub_8074236);
  sub_8060272("cvardump", sub_8074414);
  sub_8060272("cvar_restart", sub_8074714);
}

//----- (08074A18) --------------------------------------------------------
int __cdecl sub_8074A18(char *a1)
{
  char s[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  sub_8060B06(*(dword_8484370 + 4), a1, &byte_80DF800, s);
  s[strlen(s) - 1] = 0;
  stream = fopen(s, "rb");
  if ( !stream )
    return 0;
  fclose(stream);
  return 1;
}
// 8484370: using guessed type int dword_8484370;

//----- (08074C2E) --------------------------------------------------------
int __cdecl sub_8074C2E(char *src, int a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v7; // [esp+18h] [ebp-110h]
  int v8; // [esp+1Ch] [ebp-10Ch]
  char s[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060696();
  v2 = sub_806080D(0);
  v8 = v2;
  dword_8477A58[72 * v2] = 0;
  Q_strncpyz((288 * v2 + 138902112), src, 256);
  sub_8060B06(*(dword_8484370 + 4), src, &byte_80DF800, s);
  s[strlen(s) - 1] = 0;
  if ( *(dword_8484380 + 32) )
    Com_Printf("FS_SV_FOpenFileRead (fs_homepath): %s\n", s);
  v3 = 72 * v8;
  dword_8477A40[v3] = fopen(s, "rb");
  dword_8477A48[72 * v8] = 0;
  if ( !dword_8477A40[72 * v8] && sub_8086A5A(*(dword_8484370 + 4), *(dword_8480340 + 4)) )
  {
    sub_8060B06(*(dword_8480340 + 4), src, &byte_80DF800, s);
    s[strlen(s) - 1] = 0;
    if ( *(dword_8484380 + 32) )
      Com_Printf("FS_SV_FOpenFileRead (fs_basepath): %s\n", s);
    v4 = 72 * v8;
    dword_8477A40[v4] = fopen(s, "rb");
    dword_8477A48[72 * v8] = 0;
    if ( !dword_8477A40[72 * v8] )
      v8 = 0;
  }
  if ( !dword_8477A40[72 * v8] )
  {
    sub_8060B06(*(dword_84844A0 + 4), src, &byte_80DF800, s);
    s[strlen(s) - 1] = 0;
    if ( *(dword_8484380 + 32) )
      Com_Printf("FS_SV_FOpenFileRead (fs_cdpath) : %s\n", s);
    v5 = 72 * v8;
    dword_8477A40[v5] = fopen(s, "rb");
    dword_8477A48[72 * v8] = 0;
    if ( !dword_8477A40[72 * v8] )
      v8 = 0;
  }
  *a2 = v8;
  if ( v8 )
    v7 = sub_8060925(v8);
  else
    v7 = 0;
  return v7;
}
// 806080D: using guessed type _DWORD __cdecl sub_806080D(_DWORD);
// 8477A40: using guessed type int dword_8477A40[];
// 8477A48: using guessed type int dword_8477A48[];
// 8477A58: using guessed type int dword_8477A58[];
// 8480340: using guessed type int dword_8480340;
// 8484370: using guessed type int dword_8484370;
// 8484380: using guessed type int dword_8484380;
// 84844A0: using guessed type int dword_84844A0;

//----- (08075080) --------------------------------------------------------
void *__cdecl sub_8075080(char *s, char a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  v3 = strlen(s);
  for ( i = 0; i < v3; ++i )
    *(i + 136756544) = s[i] + a2;
  *(i + 136756544) = 0;
  return &unk_826BD40;
}

//----- (08075187) --------------------------------------------------------
int __cdecl sub_8075187(char *haystack, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  _DWORD *i; // [esp+24h] [ebp-4h]

  v4 = 0;
  sub_8060696();
  if ( !haystack )
    sub_80704AC(0, &byte_80DF900);
  if ( *haystack == 47 || *haystack == 92 )
    ++haystack;
  if ( strstr(haystack, "..") || strstr(haystack, "::") )
    return -1;
  for ( i = dword_80EF510; ; i = *i )
  {
    if ( !i )
      return -1;
    if ( i[1] )
      v4 = sub_806077A(haystack, *(i[1] + 788));
    if ( i[1] && *(*(i[1] + 792) + 4 * v4) && (i[3] || sub_806069B(i[1])) )
      break;
LABEL_23:
    ;
  }
  v6 = i[1];
  v5 = *(*(v6 + 792) + 4 * v4);
  while ( sub_806161E(*(v5 + 16), haystack) )
  {
    v5 = *(v5 + 20);
    if ( !v5 )
      goto LABEL_23;
  }
  if ( a2 )
    *a2 = *(v6 + 776);
  return 1;
}

//----- (08075308) --------------------------------------------------------
int __cdecl sub_8075308(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 )
  {
    while ( *a1 )
    {
      ++a1;
      ++v2;
    }
  }
  return v2;
}

//----- (08075335) --------------------------------------------------------
_DWORD *__cdecl sub_8075335(void *ptr, void *a2, void *a3)
{
  int v3; // eax
  _DWORD *i; // [esp+8h] [ebp-10h]
  _DWORD *j; // [esp+8h] [ebp-10h]
  _DWORD *k; // [esp+8h] [ebp-10h]
  _DWORD *v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+14h] [ebp-4h]

  v10 = sub_8075308(ptr);
  v11 = sub_8075308(a2) + v10;
  v3 = sub_8075308(a3);
  v9 = sub_806BB38(4 * (v3 + v11) + 4);
  v8 = v9;
  if ( ptr )
  {
    for ( i = ptr; *i; ++i )
      *v8++ = *i;
  }
  if ( a2 )
  {
    for ( j = a2; *j; ++j )
      *v8++ = *j;
  }
  if ( a3 )
  {
    for ( k = a3; *k; ++k )
      *v8++ = *k;
  }
  *v8 = 0;
  if ( ptr )
    sub_806BB25(ptr);
  if ( a2 )
    sub_806BB25(a2);
  if ( a3 )
    sub_806BB25(a3);
  return v9;
}

//----- (08075464) --------------------------------------------------------
int __cdecl sub_8075464(char *a1, int a2)
{
  FILE *stream; // [esp+24h] [ebp-254h]
  int v4; // [esp+28h] [ebp-250h]
  void *v5; // [esp+2Ch] [ebp-24Ch]
  void *v6; // [esp+30h] [ebp-248h]
  void *v7; // [esp+34h] [ebp-244h]
  int v8; // [esp+38h] [ebp-240h] BYREF
  int v9; // [esp+3Ch] [ebp-23Ch] BYREF
  char dest[256]; // [esp+40h] [ebp-238h] BYREF
  char name[260]; // [esp+140h] [ebp-138h] BYREF
  char *s; // [esp+244h] [ebp-34h]
  void *ptr; // [esp+248h] [ebp-30h]
  void *v14; // [esp+24Ch] [ebp-2Ch]
  int v15; // [esp+250h] [ebp-28h]
  int v16; // [esp+254h] [ebp-24h]
  int v17; // [esp+258h] [ebp-20h] BYREF
  size_t v18; // [esp+25Ch] [ebp-1Ch]
  int v19; // [esp+260h] [ebp-18h]
  int j; // [esp+264h] [ebp-14h]
  int i; // [esp+268h] [ebp-10h]
  int v22; // [esp+26Ch] [ebp-Ch]
  char *v23; // [esp+280h] [ebp+8h]

  v14 = 0;
  ptr = 0;
  v5 = 0;
  v4 = 0;
  *a1 = 0;
  v19 = 0;
  v16 = 0;
  v22 = 0;
  v7 = sub_80CAC75(*(dword_8484370 + 4), 0, 0, &v8, 1);
  v6 = sub_80CAC75(*(dword_8480340 + 4), 0, 0, &v8, 1);
  if ( *(dword_84844A0 + 4) && **(dword_84844A0 + 4) )
    v5 = sub_80CAC75(*(dword_84844A0 + 4), 0, 0, &v8, 1);
  v14 = sub_8075335(v7, v6, v5);
  v16 = sub_8075308(v14);
  for ( i = 0; i < v16; ++i )
  {
    s = *(v14 + i);
    if ( i )
    {
      v4 = 0;
      for ( j = 0; j < i; ++j )
      {
        if ( !sub_8086A5A(*(v14 + j), s) )
        {
          v4 = 1;
          break;
        }
      }
    }
    if ( !v4 && sub_8086946(s, ".", 1) )
    {
      sub_8060B06(*(dword_8480340 + 4), s, &byte_80DF800, name);
      v17 = 0;
      ptr = sub_80CAC75(name, ".pk3", 0, &v17, 0);
      sub_80CB004(ptr);
      if ( v17 <= 0 )
      {
        sub_8060B06(*(dword_84844A0 + 4), s, &byte_80DF800, name);
        v17 = 0;
        ptr = sub_80CAC75(name, ".pk3", 0, &v17, 0);
        sub_80CB004(ptr);
      }
      if ( v17 <= 0 )
      {
        sub_8060B06(*(dword_8484370 + 4), s, &byte_80DF800, name);
        v17 = 0;
        ptr = sub_80CAC75(name, ".pk3", 0, &v17, 0);
        sub_80CB004(ptr);
      }
      if ( v17 > 0 )
      {
        v18 = strlen(s) + 1;
        dest[0] = 0;
        strcpy(dest, s);
        strcat(dest, "/description.txt");
        v15 = sub_8074C2E(dest, &v9);
        if ( v15 > 0 && v9 )
        {
          stream = sub_80608D4(v9);
          sub_80C837D(dest, 0, 0x100u);
          v15 = fread(dest, 1u, 0x30u, stream);
          if ( v15 >= 0 )
            dest[v15] = 0;
          FS_FCloseFile(v9);
        }
        else if ( sub_8086A5A(s, "main") )
        {
          strcpy(dest, s);
        }
        else
        {
          strcpy(dest, "CoD:United Offensive Multiplayer");
        }
        v15 = strlen(dest) + 1;
        if ( (v15 + v19 + v18 + 2) >= a2 )
          break;
        strcpy(a1, s);
        v23 = &a1[v18];
        strcpy(v23, dest);
        a1 = &v23[v15];
        v19 += v15 + v18;
        ++v22;
      }
    }
  }
  sub_80CB004(v14);
  return v22;
}
// 8480340: using guessed type int dword_8480340;
// 8484370: using guessed type int dword_8484370;
// 84844A0: using guessed type int dword_84844A0;

//----- (0807596B) --------------------------------------------------------
void sub_807596B()
{
  int i; // [esp+14h] [ebp-14h]
  int v1; // [esp+18h] [ebp-10h] BYREF
  void *ptr; // [esp+1Ch] [ebp-Ch]
  char *v3; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  if ( sub_805FF1E() > 1 && sub_805FF1E() <= 3 )
  {
    if ( sub_805FF1E() == 2 )
    {
      s = sub_805FF28(1u);
      v3 = &byte_80DF800;
    }
    else
    {
      s = sub_805FF28(1u);
      v3 = sub_805FF28(2u);
    }
    Com_Printf("Directory of %s %s\n", s, v3);
    Com_Printf("---------------\n");
    ptr = sub_8063EFC(s, v3, &v1);
    for ( i = 0; i < v1; ++i )
      Com_Printf("%s\n", *(ptr + i));
    sub_8063F25(ptr);
  }
  else
  {
    Com_Printf("usage: dir <directory> [extension]\n");
  }
}

//----- (08075A5F) --------------------------------------------------------
void sub_8075A5F()
{
  int i; // [esp+18h] [ebp-10h]
  char v1[4]; // [esp+1Ch] [ebp-Ch] BYREF
  void *ptr; // [esp+20h] [ebp-8h]
  int v3; // [esp+24h] [ebp-4h]

  if ( sub_805FF1E() > 1 )
  {
    v3 = sub_805FF28(1u);
    Com_Printf("---------------\n");
    ptr = sub_8063988(&byte_80DF800, &byte_80DF800, v3, v1);
    sub_8064157(ptr, *v1);
    for ( i = 0; i < *v1; ++i )
    {
      sub_806407D(*(ptr + i));
      Com_Printf("%s\n", *(ptr + i));
    }
    Com_Printf("%d files listed\n", *v1);
    sub_8063F25(ptr);
  }
  else
  {
    Com_Printf("usage: fdir <filter>\n");
    Com_Printf("example: fdir *q3dm*.bsp\n");
  }
}

//----- (08075B4E) --------------------------------------------------------
void sub_8075B4E()
{
  char *v0; // eax

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    sub_806258B(v0);
  }
  else
  {
    Com_Printf("Usage: touchFile <file>\n");
  }
}

//----- (08075B82) --------------------------------------------------------
int __cdecl sub_8075B82(char *haystack, int a2, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v16; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  int v18[3]; // [esp+6Ch] [ebp-Ch]

  v3 = sub_8086D78("%s/mp_bin", a2);
  if ( !sub_806161E(haystack, v3) )
    return 1;
  for ( v18[0] = 0; v18[0] <= 23; ++v18[0] )
  {
    v4 = sub_8086D78("%s/pak%x", a2, v18[0]);
    if ( !sub_806161E(haystack, v4) )
      return 1;
    v5 = sub_8086D78("%s/pakuo%x", a3, v18[0]);
    if ( !sub_806161E(haystack, v5) )
      return 1;
    v6 = sub_8086D78("%s/pakuo0%x", a3, v18[0]);
    if ( !sub_806161E(haystack, v6) )
      return 1;
    v7 = sub_8086D78("%s/mp_pak%x", a2, v18[0]);
    if ( !sub_806161E(haystack, v7) )
      return 1;
    v8 = sub_8086D78("%s/sp_pak%x", a2, v18[0]);
    if ( !sub_806161E(haystack, v8) )
      return 1;
  }
  v16 = strstr(haystack, "localized_");
  if ( v16 )
  {
    strcpy(dest, haystack);
    dest[v16 - haystack + 10] = 0;
    v9 = sub_8086D78("%s/localized_", a2);
    if ( !sub_806161E(dest, v9) || (v10 = sub_8086D78("%s/localized_", a3), !sub_806161E(dest, v10)) )
    {
      strcpy(dest, v16 + 10);
      sub_8086A97(dest);
      for ( v18[0] = 0; v18[0] <= 23; ++v18[0] )
      {
        v11 = sub_8086D78("_pak%x", v18[0]);
        if ( strstr(dest, v11) )
          return 1;
        v12 = sub_8086D78("_pakuo%x", v18[0]);
        if ( strstr(dest, v12) )
          return 1;
        v13 = sub_8086D78("_pakuo0%x", v18[0]);
        if ( strstr(dest, v13) )
          return 1;
      }
    }
  }
  return 0;
}

//----- (08075E57) --------------------------------------------------------
_BOOL4 __cdecl sub_8075E57(char *src)
{
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  strcpy(dest, src);
  sub_8086A97(dest);
  return strstr(dest, "_svr_") != 0;
}

//----- (080761EE) --------------------------------------------------------
void sub_80761EE()
{
  sub_8060272("path", sub_80643D8);
  sub_8060272("fullpath", sub_80643C4);
  sub_8060272("dir", sub_807596B);
  sub_8060272("fdir", sub_8075A5F);
  sub_8060272("touchFile", sub_8075B4E);
}

//----- (0807625A) --------------------------------------------------------
_DWORD *sub_807625A()
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = dword_848437C;
  if ( *(dword_848437C + 32) )
  {
    sub_8073798("fs_restrict", "0");
    Com_Printf("\nRunning in restricted demo mode.\n\n");
    result = dword_80EF510;
    for ( i = dword_80EF510; i; i = *i )
    {
      if ( sub_8060702(i) && i[1] && (*(i[1] + 772) ^ 0x2261994) != -1277981599 )
        sub_80704AC(0, "Corrupted pak0.pk3: %u", *(i[1] + 772));
      result = *i;
    }
  }
  return result;
}
// 848437C: using guessed type int dword_848437C;

//----- (08076302) --------------------------------------------------------
char *sub_8076302()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_826C240 = 0;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = sub_8086D78("%i ", *(i[1] + 772));
        sub_8086B0B(&byte_826C240, 0x2000, v0);
      }
    }
  }
  return &byte_826C240;
}

//----- (0807637A) --------------------------------------------------------
char *sub_807637A()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_826E240 = 0;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] && !i[3] )
    {
      if ( byte_826E240 )
        sub_8086B0B(&byte_826E240, 0x2000, " ");
      sub_8086B0B(&byte_826E240, 0x2000, (i[1] + 256));
    }
  }
  return &byte_826E240;
}

//----- (08076406) --------------------------------------------------------
char *sub_8076406()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8270240 = 0;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = sub_8086D78("%i ", *(i[1] + 776));
        sub_8086B0B(&byte_8270240, 0x2000, v0);
      }
    }
  }
  return &byte_8270240;
}

//----- (0807647E) --------------------------------------------------------
char *sub_807647E()
{
  int v0; // eax
  char *v1; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8272240 = 0;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] )
    {
      if ( *(i[1] + 784)
        || sub_8086946((i[1] + 512), "main", 4)
        && (v0 = strlen(*(dword_8484360 + 4)), sub_8086946((i[1] + 512), *(dword_8484360 + 4), v0)) )
      {
        v1 = sub_8086D78("%i ", *(i[1] + 772));
        sub_8086B0B(&byte_8272240, 0x2000, v1);
      }
    }
  }
  return &byte_8272240;
}
// 8484360: using guessed type int dword_8484360;

//----- (08076564) --------------------------------------------------------
char *sub_8076564()
{
  int v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8278240 = 0;
  for ( i = dword_80EF510; i; i = *i )
  {
    if ( i[1] )
    {
      if ( *(i[1] + 784)
        || sub_8086946((i[1] + 512), "main", 4)
        && (v0 = strlen(*(dword_8484360 + 4)), sub_8086946((i[1] + 512), *(dword_8484360 + 4), v0)) )
      {
        if ( byte_8278240 )
          sub_8086B0B(&byte_8278240, 0x2000, " ");
        sub_8086B0B(&byte_8278240, 0x2000, (i[1] + 512));
        sub_8086B0B(&byte_8278240, 0x2000, "/");
        sub_8086B0B(&byte_8278240, 0x2000, (i[1] + 256));
      }
    }
  }
  return &byte_8278240;
}
// 8484360: using guessed type int dword_8484360;

//----- (0807683D) --------------------------------------------------------
void *__cdecl sub_807683D(char **a1, char **a2)
{
  signed int v2; // ebx
  char *v3; // eax
  signed int v4; // ebx
  char *v5; // eax
  void *result; // eax
  char v7; // [esp+8h] [ebp-8020h]
  void *ptr[4096]; // [esp+10h] [ebp-8018h] BYREF
  int src[4096]; // [esp+4010h] [ebp-4018h] BYREF
  int v10; // [esp+8010h] [ebp-18h]
  int v11; // [esp+8014h] [ebp-14h]
  int j; // [esp+8018h] [ebp-10h]
  signed int i; // [esp+801Ch] [ebp-Ch]

  sub_8060257(a1);
  v11 = sub_805FF1E();
  if ( v11 > 4096 )
    v11 = 4096;
  for ( i = 0; i < v11; ++i )
  {
    v2 = i;
    v3 = sub_805FF28(i);
    src[v2] = atoi(v3);
  }
  sub_8060257(a2);
  v10 = sub_805FF1E();
  if ( v10 > 4096 )
    v10 = 4096;
  for ( i = 0; i < v10; ++i )
  {
    v4 = i;
    v5 = sub_805FF28(i);
    ptr[v4] = sub_806BB76(v5);
  }
  if ( v11 != v10 )
    sub_80704AC(1, "pak sum/name mismatch", v7);
  if ( v11 == dword_848436C )
  {
    i = 0;
LABEL_15:
    if ( i >= v11 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v10 )
          break;
        sub_806BB25(ptr[i]);
      }
      return result;
    }
    for ( j = 0; j < dword_848436C; ++j )
    {
      if ( src[i] == dword_8480360[j] && !sub_8086A5A(ptr[i], *(&dword_84844C0 + j)) )
      {
        ++i;
        goto LABEL_15;
      }
    }
  }
  sub_8065429();
  result = v11;
  dword_848436C = v11;
  if ( v11 )
  {
    Com_DPrintf("Connected to a pure server.\n");
    sub_80C835C(dword_8480360, src, 4 * dword_848436C);
    result = sub_80C835C(&dword_84844C0, ptr, 4 * dword_848436C);
    dword_8484378 = 0;
  }
  return result;
}
// 807690E: variable 'v7' is possibly undefined
// 848436C: using guessed type int dword_848436C;
// 8484378: using guessed type int dword_8484378;

//----- (08076BFF) --------------------------------------------------------
int __cdecl sub_8076BFF(char a1, int a2)
{
  int result; // eax

  if ( (dword_80EFE98 & 7) == 0 )
    *((dword_80EFE98 >> 3) + a2) = 0;
  result = a1 << (dword_80EFE98 & 7);
  LOBYTE(result) = *((dword_80EFE98 >> 3) + a2) | result;
  *((dword_80EFE98++ >> 3) + a2) = result;
  return result;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (08076C68) --------------------------------------------------------
int __cdecl sub_8076C68(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = (*((dword_80EFE98 >> 3) + a1) >> (dword_80EFE98 & 7)) & 1;
  ++dword_80EFE98;
  return v2;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (08076C9B) --------------------------------------------------------
_DWORD *__cdecl sub_8076C9B(int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  if ( *(a1 + 1048) )
  {
    v4 = *(a1 + 1048);
    *(a1 + 1048) = *v4;
    v3 = v4;
  }
  else
  {
    v1 = a1 + 4 * (*(a1 + 4))++;
    v3 = (v1 + 25628);
  }
  return v3;
}

//----- (08076CEB) --------------------------------------------------------
_DWORD *__cdecl sub_8076CEB(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = *(a1 + 1048);
  result = a2;
  *(a1 + 1048) = a2;
  return result;
}

//----- (08076D0A) --------------------------------------------------------
_DWORD *__cdecl sub_8076D0A(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+0h] [ebp-8h]
  _DWORD *v5; // [esp+4h] [ebp-4h]

  v5 = *(a2 + 8);
  v4 = *(a3 + 8);
  if ( v5 )
  {
    if ( *v5 == a2 )
      *v5 = a3;
    else
      v5[1] = a3;
  }
  else
  {
    *(a1 + 8) = a3;
  }
  if ( v4 )
  {
    if ( *v4 == a3 )
      *v4 = a2;
    else
      v4[1] = a2;
  }
  else
  {
    *(a1 + 8) = a2;
  }
  *(a2 + 8) = v4;
  result = v5;
  *(a3 + 8) = v5;
  return result;
}

//----- (08076D92) --------------------------------------------------------
int __cdecl sub_8076D92(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = *(a1 + 12);
  *(a1 + 12) = *(a2 + 12);
  *(a2 + 12) = v3;
  v4 = *(a1 + 16);
  *(a1 + 16) = *(a2 + 16);
  *(a2 + 16) = v4;
  if ( *(a1 + 12) == a1 )
    *(a1 + 12) = a2;
  if ( *(a2 + 12) == a2 )
    *(a2 + 12) = a1;
  if ( *(a1 + 12) )
    *(*(a1 + 12) + 16) = a1;
  if ( *(a2 + 12) )
    *(*(a2 + 12) + 16) = a2;
  if ( *(a1 + 16) )
    *(*(a1 + 16) + 12) = a1;
  result = a2;
  if ( *(a2 + 16) )
  {
    result = a2;
    *(*(a2 + 16) + 12) = a2;
  }
  return result;
}

//----- (08076E52) --------------------------------------------------------
void __cdecl sub_8076E52(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a2 )
  {
    if ( *(a2 + 12) && *(*(a2 + 12) + 24) == *(a2 + 24) )
    {
      v2 = **(a2 + 20);
      if ( v2 != *(a2 + 8) )
        sub_8076D0A(a1, v2, a2);
      sub_8076D92(v2, a2);
    }
    if ( *(a2 + 16) && *(*(a2 + 16) + 24) == *(a2 + 24) )
    {
      **(a2 + 20) = *(a2 + 16);
    }
    else
    {
      **(a2 + 20) = 0;
      sub_8076CEB(a1, *(a2 + 20));
    }
    ++*(a2 + 24);
    if ( *(a2 + 12) && *(*(a2 + 12) + 24) == *(a2 + 24) )
    {
      *(a2 + 20) = *(*(a2 + 12) + 20);
    }
    else
    {
      *(a2 + 20) = sub_8076C9B(a1);
      **(a2 + 20) = a2;
    }
    if ( *(a2 + 8) )
    {
      sub_8076E52(a1, *(a2 + 8));
      if ( *(a2 + 16) == *(a2 + 8) )
      {
        sub_8076D92(a2, *(a2 + 8));
        if ( **(a2 + 20) == a2 )
          **(a2 + 20) = *(a2 + 8);
      }
    }
  }
}

//----- (08076FB9) --------------------------------------------------------
void __cdecl sub_8076FB9(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // ecx
  _DWORD *v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  if ( a1[a2 + 5] )
  {
    sub_8076E52(a1, a1[a2 + 5]);
  }
  else
  {
    v4 = &a1[8 * (*a1)++ + 263];
    v3 = &a1[8 * (*a1)++ + 263];
    v3[7] = 257;
    v3[6] = 1;
    v3[3] = *(a1[3] + 12);
    if ( *(a1[3] + 12) && (*(*(a1[3] + 12) + 16) = v3, *(*(a1[3] + 12) + 24) == 1) )
    {
      v3[5] = *(*(a1[3] + 12) + 20);
    }
    else
    {
      v3[5] = sub_8076C9B(a1);
      *v3[5] = v3;
    }
    *(a1[3] + 12) = v3;
    v3[4] = a1[3];
    v4[7] = a2;
    v4[6] = 1;
    v4[3] = *(a1[3] + 12);
    if ( *(a1[3] + 12) )
    {
      *(*(a1[3] + 12) + 16) = v4;
      if ( *(*(a1[3] + 12) + 24) == 1 )
      {
        v4[5] = *(*(a1[3] + 12) + 20);
      }
      else
      {
        v4[5] = sub_8076C9B(a1);
        *v4[5] = v3;
      }
    }
    else
    {
      v4[5] = sub_8076C9B(a1);
      *v4[5] = v4;
    }
    *(a1[3] + 12) = v4;
    v4[4] = a1[3];
    v4[1] = 0;
    *v4 = 0;
    if ( *(a1[3] + 8) )
    {
      if ( **(a1[3] + 8) == a1[3] )
        **(a1[3] + 8) = v3;
      else
        *(*(a1[3] + 8) + 4) = v3;
    }
    else
    {
      a1[2] = v3;
    }
    v3[1] = v4;
    *v3 = a1[3];
    v3[2] = *(a1[3] + 8);
    v2 = a1[3];
    v4[2] = v3;
    *(v2 + 8) = v3;
    a1[a2 + 5] = v4;
    sub_8076E52(a1, v3[2]);
  }
}

//----- (0807723E) --------------------------------------------------------
int __cdecl sub_807723E(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // edx

  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8076C68(a3) )
      a1 = a1[1];
    else
      a1 = *a1;
  }
  if ( !a1 )
    return 0;
  v3 = a1[7];
  *a2 = v3;
  return v3;
}

//----- (0807729F) --------------------------------------------------------
int __cdecl sub_807729F(_DWORD *a1, _DWORD *a2, int a3, int *a4)
{
  int result; // eax

  dword_80EFE98 = *a4;
  while ( a1 && a1[7] == 257 )
  {
    if ( sub_8076C68(a3) )
      a1 = a1[1];
    else
      a1 = *a1;
  }
  if ( a1 )
  {
    *a2 = a1[7];
    result = dword_80EFE98;
    *a4 = dword_80EFE98;
  }
  else
  {
    result = a2;
    *a2 = 0;
  }
  return result;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (0807730F) --------------------------------------------------------
int __cdecl sub_807730F(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( *(a1 + 8) )
    result = sub_807730F(*(a1 + 8), a1, a3);
  if ( a2 )
  {
    if ( *(a1 + 4) == a2 )
      result = sub_8076BFF(1, a3);
    else
      result = sub_8076BFF(0, a3);
  }
  return result;
}

//----- (08077375) --------------------------------------------------------
int *__cdecl sub_8077375(int a1, int a2, int a3)
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  if ( *(a1 + 4 * a2 + 20) )
    return sub_807730F(*(a1 + 4 * a2 + 20), 0, a3);
  result = sub_8077375(a1, 256, a3);
  for ( i = 7; i >= 0; --i )
  {
    sub_8076BFF((a2 >> i) & 1, a3);
    result = &i;
  }
  return result;
}

//----- (080773F8) --------------------------------------------------------
int __cdecl sub_80773F8(int a1, int a2, int a3, int *a4)
{
  int result; // eax

  dword_80EFE98 = *a4;
  sub_807730F(*(a1 + 4 * a2 + 20), 0, a3);
  result = dword_80EFE98;
  *a4 = dword_80EFE98;
  return result;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (08077435) --------------------------------------------------------
unsigned __int8 *__cdecl sub_8077435(_DWORD *a1, int a2)
{
  unsigned __int8 *result; // eax
  int v3; // edx
  int *v4; // ecx
  int *v5; // edx
  int v6; // ebx
  int s[2]; // [esp+10h] [ebp-17058h] BYREF
  int *v8; // [esp+18h] [ebp-17050h]
  int *v9; // [esp+1Ch] [ebp-1704Ch]
  int *v10; // [esp+20h] [ebp-17048h]
  int *v11; // [esp+424h] [ebp-16C44h]
  unsigned __int8 *v12; // [esp+703Ch] [ebp-1002Ch]
  char src[65548]; // [esp+7040h] [ebp-10028h] BYREF
  int v14; // [esp+1704Ch] [ebp-1Ch]
  int i; // [esp+17050h] [ebp-18h]
  int j; // [esp+17054h] [ebp-14h]
  size_t n; // [esp+17058h] [ebp-10h]
  int v18[3]; // [esp+1705Ch] [ebp-Ch] BYREF

  v14 = a1[3] - a2;
  result = (a1[1] + a2);
  v12 = result;
  if ( v14 > 0 )
  {
    sub_80C837D(s, 0, 0x701Cu);
    v11 = &s[8 * s[0] + 263];
    v10 = v11;
    v9 = v11;
    v8 = v11;
    ++s[0];
    v11[7] = 256;
    v8[6] = 0;
    v3 = v9;
    v9[4] = 0;
    *(v3 + 12) = 0;
    v4 = v8;
    v5 = v8;
    v8[1] = 0;
    *v5 = 0;
    v4[2] = 0;
    n = v12[1] + (*v12 << 8);
    if ( n > a1[2] - a2 )
      n = a1[2] - a2;
    dword_80EFE98 = 16;
    for ( i = 0; i < n; ++i )
    {
      v18[0] = 0;
      if ( dword_80EFE98 >> 3 > v14 )
      {
        src[i] = 0;
        break;
      }
      sub_807723E(v8, v18, v12);
      if ( v18[0] == 256 )
      {
        v18[0] = 0;
        for ( j = 0; j <= 7; ++j )
        {
          v6 = 2 * v18[0];
          v18[0] = sub_8076C68(v12) + v6;
        }
      }
      src[i] = v18[0];
      sub_8076FB9(s, v18[0]);
    }
    a1[3] = n + a2;
    result = sub_80C835C((a1[1] + a2), src, n);
  }
  return result;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (08077662) --------------------------------------------------------
unsigned __int8 *__cdecl sub_8077662(int a1, int a2)
{
  unsigned __int8 *result; // eax
  int v3; // edx
  int v4; // ecx
  int *v5; // edx
  int s[2]; // [esp+10h] [ebp-17048h] BYREF
  int *v7; // [esp+18h] [ebp-17040h]
  int *v8; // [esp+1Ch] [ebp-1703Ch]
  int *v9; // [esp+424h] [ebp-16C34h]
  unsigned __int8 *v10; // [esp+703Ch] [ebp-1001Ch]
  char src[65540]; // [esp+7040h] [ebp-10018h] BYREF
  int v12; // [esp+17044h] [ebp-14h]
  int v13; // [esp+17048h] [ebp-10h]
  int i; // [esp+1704Ch] [ebp-Ch]

  v12 = *(a1 + 12) - a2;
  result = (*(a1 + 4) + a2);
  v10 = result;
  if ( v12 > 0 )
  {
    sub_80C837D(s, 0, 0x701Cu);
    v8 = &s[8 * s[0] + 263];
    v7 = v8;
    ++s[0];
    v8[7] = 256;
    v7[6] = 0;
    v3 = v8;
    v8[4] = 0;
    *(v3 + 12) = 0;
    v4 = v7;
    v5 = v7;
    v7[1] = 0;
    *v5 = 0;
    *(v4 + 8) = 0;
    v9 = v7;
    src[0] = BYTE1(v12);
    src[1] = v12;
    dword_80EFE98 = 16;
    for ( i = 0; i < v12; ++i )
    {
      v13 = v10[i];
      sub_8077375(s, v13, src);
      sub_8076FB9(s, v13);
    }
    dword_80EFE98 += 8;
    *(a1 + 12) = a2 + (dword_80EFE98 >> 3);
    result = sub_80C835C((*(a1 + 4) + a2), src, dword_80EFE98 >> 3);
  }
  return result;
}
// 80EFE98: using guessed type int dword_80EFE98;

//----- (0807780C) --------------------------------------------------------
int __cdecl sub_807780C(void *s)
{
  int v1; // eax
  int v2; // edx
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // ecx
  int result; // eax

  sub_80C837D(s, 0, 0x701Cu);
  sub_80C837D(s + 28700, 0, 0x701Cu);
  *(s + 7436) = s + 32 * *(s + 7175) + 29752;
  v1 = *(s + 7436);
  *(s + 7179) = v1;
  *(s + 7178) = v1;
  *(s + 7177) = v1;
  ++*(s + 7175);
  *(*(s + 7177) + 28) = 256;
  *(*(s + 7177) + 24) = 0;
  v2 = *(s + 7178);
  *(v2 + 16) = 0;
  *(v2 + 12) = 0;
  v3 = *(s + 7177);
  v3[1] = 0;
  *v3 = 0;
  v3[2] = 0;
  *(s + 261) = s + 32 * *s + 1052;
  v4 = *(s + 261);
  *(s + 3) = v4;
  *(s + 2) = v4;
  ++*s;
  *(*(s + 2) + 28) = 256;
  *(*(s + 2) + 24) = 0;
  v5 = *(s + 3);
  *(v5 + 16) = 0;
  *(v5 + 12) = 0;
  v6 = *(s + 2);
  v6[1] = 0;
  *v6 = 0;
  v6[2] = 0;
  result = *(s + 2);
  *(s + 261) = result;
  return result;
}

//----- (080779A4) --------------------------------------------------------
long double __cdecl sub_80779A4(char *a1)
{
  float v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v3 = 0.0;
  while ( *a1 )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      if ( v4 || *a1 != 46 )
        return 0.0;
      v4 = 10;
      ++a1;
    }
    if ( v4 )
    {
      v3 = (*a1 - 48) / v4 + v3;
      v4 *= 10;
    }
    else
    {
      v3 = v3 * 10.0 + (*a1 - 48);
    }
    ++a1;
  }
  return v3;
}

//----- (08077A61) --------------------------------------------------------
char **__cdecl sub_8077A61(char *s)
{
  size_t v1; // eax
  char **v3; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  v3 = sub_8077F64(v1 + 25);
  memset(v3, 0, 0x18u);
  *v3 = (v3 + 6);
  strcpy(*v3, s);
  v3[5] = dword_84898DC;
  dword_84898DC = v3;
  return v3;
}
// 84898DC: using guessed type int dword_84898DC;

//----- (08077AD2) --------------------------------------------------------
void __cdecl sub_8077AD2(int a1)
{
  if ( *(a1 + 4) )
    sub_8078050(*(a1 + 4));
  sub_8078050(a1);
}

//----- (08077B40) --------------------------------------------------------
int __cdecl sub_8077B40(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_84898DC; i; i = *(i + 20) )
  {
    if ( !sub_8086A5A(*i, a1) )
      return i;
  }
  return 0;
}
// 84898DC: using guessed type int dword_84898DC;

//----- (08077BED) --------------------------------------------------------
char **__cdecl sub_8077BED(char *a1, char *s)
{
  size_t v2; // eax
  char **v4; // [esp+10h] [ebp-8h]

  v4 = sub_8077B40(a1);
  if ( !v4 )
  {
    v4 = sub_8077A61(a1);
    v2 = strlen(s);
    v4[1] = sub_8077F64(v2 + 1);
    strcpy(v4[1], s);
    *(v4 + 4) = sub_80779A4(v4[1]);
    v4[3] = 1;
  }
  return v4;
}

//----- (08077C9D) --------------------------------------------------------
long double __cdecl sub_8077C9D(char *a1, char *s)
{
  return *(sub_8077BED(a1, s) + 4);
}

//----- (08077DAC) --------------------------------------------------------
void __cdecl sub_8077DAC(char *filename)
{
  if ( filename && *filename )
  {
    if ( stream )
    {
      Com_Printf("^1Error: log file %s is already opened\n", byte_827A240);
    }
    else
    {
      stream = fopen(filename, "wb");
      if ( stream )
      {
        strncpy(byte_827A240, filename, 0x400u);
        Com_Printf("Opened log %s\n", byte_827A240);
      }
      else
      {
        Com_Printf("^1Error: can't open the log file %s\n", filename);
      }
    }
  }
  else
  {
    Com_Printf("openlog <filename>\n");
  }
}

//----- (08077E8B) --------------------------------------------------------
void sub_8077E8B()
{
  if ( stream )
  {
    if ( fclose(stream) )
    {
      Com_Printf("^1Error: can't close log file %s\n", byte_827A240);
    }
    else
    {
      stream = 0;
      Com_Printf("Closed log %s\n", byte_827A240);
    }
  }
}

//----- (08077EF9) --------------------------------------------------------
int sub_8077EF9(char *format, ...)
{
  int result; // eax
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( stream )
  {
    vfprintf(stream, format, va);
    result = fflush(stream);
  }
  return result;
}

//----- (08077F64) --------------------------------------------------------
_DWORD *__cdecl sub_8077F64(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = sub_806BB38(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = 305419896;
  return v3 + 1;
}

//----- (08077FA7) --------------------------------------------------------
_DWORD *__cdecl sub_8077FA7(size_t n)
{
  _DWORD *s; // [esp+14h] [ebp-4h]

  s = sub_8077F64(n);
  memset(s, 0, n);
  return s;
}

//----- (08077FDA) --------------------------------------------------------
_DWORD *__cdecl sub_8077FDA(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = sub_806C3D4(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = -2023406815;
  return v3 + 1;
}

//----- (08078050) --------------------------------------------------------
void __cdecl sub_8078050(int a1)
{
  if ( *(a1 - 4) == 305419896 )
    sub_806BB25((a1 - 4));
}

//----- (08078084) --------------------------------------------------------
void sub_8078084(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  Com_Printf("^1Error: file %s, line %d: %s\n", *(a1 + 132), *(*(a1 + 132) + 92), s);
}

//----- (080780EA) --------------------------------------------------------
void sub_80780EA(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  Com_Printf("file %s, line %d: %s\n", *(a1 + 132), *(*(a1 + 132) + 92), s);
}

//----- (08078150) --------------------------------------------------------
_DWORD *__cdecl sub_8078150(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = sub_8077F64(16);
  *result = a2;
  result[2] = a1[33];
  result[1] = a3 != 0;
  a1[38] += result[1];
  result[3] = a1[37];
  a1[37] = result;
  return result;
}

//----- (080781C1) --------------------------------------------------------
void __cdecl sub_80781C1(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  *a2 = 0;
  *a3 = 0;
  v3 = a1[37];
  if ( v3 )
  {
    if ( *(a1[37] + 8) == a1[33] )
    {
      *a2 = *v3;
      *a3 = v3[1];
      a1[37] = *(a1[37] + 12);
      a1[38] -= v3[1];
      sub_8078050(v3);
    }
  }
}

//----- (0807825C) --------------------------------------------------------
void __cdecl sub_807825C(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(a1 + 132); i; i = *(i + 1184) )
  {
    if ( !sub_8086A5A(i, a2) )
    {
      sub_8078084(a1, "%s recursively included", a2);
      return;
    }
  }
  *(a2 + 1184) = *(a1 + 132);
  *(a1 + 132) = a2;
}

//----- (080782D6) --------------------------------------------------------
void sub_80782D6()
{
  ;
}

//----- (080782DB) --------------------------------------------------------
_DWORD *__cdecl sub_80782DB(void *src)
{
  _DWORD *dest; // [esp+14h] [ebp-4h]

  dest = sub_8077F64(1068);
  if ( !dest )
    sub_80704AC(0, "EXE_ERR_OUT_OF_MEMORY");
  memcpy(dest, src, 0x42Cu);
  dest[266] = 0;
  ++dword_8489A00;
  return dest;
}
// 8489A00: using guessed type int dword_8489A00;

//----- (0807834B) --------------------------------------------------------
void __cdecl sub_807834B(int a1)
{
  sub_8078050(a1);
  --dword_8489A00;
}
// 8489A00: using guessed type int dword_8489A00;

//----- (08078364) --------------------------------------------------------
int __cdecl sub_8078364(int a1, void *dest)
{
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  while ( !*(a1 + 136) )
  {
    if ( sub_807E7AA(*(a1 + 132), dest) )
      return 1;
    if ( sub_807F2B0(*(a1 + 132)) )
    {
      while ( *(a1 + 148) && *(*(a1 + 148) + 8) == *(a1 + 132) )
      {
        sub_80780EA(a1, "missing #endif");
        sub_80781C1(a1, &v5, &v4);
      }
    }
    if ( !*(*(a1 + 132) + 1184) )
      return 0;
    v6 = *(a1 + 132);
    *(a1 + 132) = *(*(a1 + 132) + 1184);
    sub_807F5D9(v6);
  }
  memcpy(dest, *(a1 + 136), 0x42Cu);
  v7 = *(a1 + 136);
  *(a1 + 136) = *(*(a1 + 136) + 1064);
  sub_807834B(v7);
  return 1;
}

//----- (080784B9) --------------------------------------------------------
int __cdecl sub_80784B9(int a1, void *src)
{
  _DWORD *v2; // eax

  v2 = sub_80782DB(src);
  v2[266] = *(a1 + 136);
  *(a1 + 136) = v2;
  return 1;
}

//----- (080784F2) --------------------------------------------------------
int __cdecl sub_80784F2(int a1, const char **a2, int a3, int a4)
{
  int v5; // [esp+10h] [ebp-458h]
  int v6; // [esp+14h] [ebp-454h]
  int v7; // [esp+18h] [ebp-450h]
  int v8; // [esp+1Ch] [ebp-44Ch]
  int v9; // [esp+20h] [ebp-448h]
  int i; // [esp+24h] [ebp-444h]
  _DWORD *v11; // [esp+28h] [ebp-440h]
  _DWORD *v12; // [esp+2Ch] [ebp-43Ch]
  char s1[1080]; // [esp+30h] [ebp-438h] BYREF

  if ( sub_8078364(a1, s1) )
  {
    if ( a2[3] <= a4 )
    {
      for ( i = 0; i < a2[3]; ++i )
        *(a3 + 4 * i) = 0;
      if ( !strcmp(s1, "(") )
      {
        v9 = 0;
        v7 = 0;
        v6 = 0;
        while ( !v9 )
        {
          if ( v7 >= a4 )
          {
            sub_8078084(a1, "define %s with too many parms", *a2);
            return 0;
          }
          if ( v7 >= a2[3] )
          {
            sub_80780EA(a1, "define %s has too many parms", *a2);
            return 0;
          }
          *(a3 + 4 * v7) = 0;
          v8 = 1;
          v11 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( !sub_8078364(a1, s1) )
              {
                sub_8078084(a1, "define %s incomplete", *a2);
                return 0;
              }
              if ( !strcmp(s1, ",") && v6 <= 0 )
              {
                if ( v8 )
                  sub_80780EA(a1, "too many comma's");
                goto LABEL_36;
              }
              v8 = 0;
              if ( strcmp(s1, "(") )
                break;
              ++v6;
            }
            if ( !strcmp(s1, ")") && --v6 <= 0 )
              break;
            if ( v7 < a2[3] )
            {
              v12 = sub_80782DB(s1);
              v12[266] = 0;
              if ( v11 )
                v11[266] = v12;
              else
                *(a3 + 4 * v7) = v12;
              v11 = v12;
            }
          }
          if ( !*(a3 + 4 * a2[3] - 4) )
            sub_80780EA(a1, "too few define parms");
          v9 = 1;
LABEL_36:
          ++v7;
        }
        v5 = 1;
      }
      else
      {
        sub_80784B9(a1, s1);
        sub_8078084(a1, "define %s missing parms", *a2);
        v5 = 0;
      }
    }
    else
    {
      sub_8078084(a1, "define with more than %d parameters", a4);
      v5 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "define %s missing parms", *a2);
    v5 = 0;
  }
  return v5;
}
// 80786D5: conditional instruction was optimized away because of '%var_448.4==0'

//----- (08078899) --------------------------------------------------------
int __cdecl sub_8078899(int a1, char *dest)
{
  size_t v2; // eax
  size_t v3; // eax

  *(dest + 256) = 1;
  *(dest + 262) = 0;
  *(dest + 263) = 0;
  *dest = 0;
  strcat(dest, "\"");
  while ( a1 )
  {
    v2 = strlen(dest);
    strncat(dest, a1, 1024 - v2);
    a1 = *(a1 + 1064);
  }
  v3 = strlen(dest);
  strncat(dest, "\"", 1024 - v3);
  return 1;
}

//----- (08078957) --------------------------------------------------------
int __cdecl sub_8078957(char *dest, char *src)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( *(dest + 256) == 4 && (*(src + 256) == 4 || *(src + 256) == 3) )
  {
    strcat(dest, src);
    v3 = 1;
  }
  else if ( *(dest + 256) == 1 && *(src + 256) == 1 )
  {
    dest[strlen(dest) - 1] = 0;
    strcat(dest, src + 1);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  return v3;
}

//----- (08078A71) --------------------------------------------------------
int __cdecl sub_8078A71(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; *(i + a1); ++i )
    v3 += *(i + a1) * (i + 119);
  return ((v3 >> 20) ^ ((v3 >> 10) ^ v3)) & 0x3FF;
}

//----- (08078AD0) --------------------------------------------------------
int *__cdecl sub_8078AD0(int *a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int *result; // eax

  v2 = sub_8078A71(*a1);
  a1[7] = *(a2 + 4 * v2);
  v3 = 4 * v2;
  result = a1;
  *(a2 + v3) = a1;
  return result;
}

//----- (08078B11) --------------------------------------------------------
int __cdecl sub_8078B11(int a1, char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(a1 + 4 * sub_8078A71(s2)); i; i = *(i + 28) )
  {
    if ( !strcmp(*i, s2) )
      return i;
  }
  return 0;
}

//----- (08078B77) --------------------------------------------------------
int __cdecl sub_8078B77(int a1, char *s2)
{
  while ( a1 )
  {
    if ( !strcmp(*a1, s2) )
      return a1;
    a1 = *(a1 + 24);
  }
  return 0;
}

//----- (08078BC2) --------------------------------------------------------
int __cdecl sub_8078BC2(int a1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( s1 = *(a1 + 16); s1; s1 = *(s1 + 266) )
  {
    if ( !strcmp(s1, s2) )
      return v4;
    ++v4;
  }
  return -1;
}

//----- (08078C1D) --------------------------------------------------------
void __cdecl sub_8078C1D(int a1)
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(a1 + 16); i; i = v1 )
  {
    v1 = *(i + 1064);
    sub_807834B(i);
  }
  for ( j = *(a1 + 20); j; j = v2 )
  {
    v2 = *(j + 1064);
    sub_807834B(j);
  }
  sub_8078050(a1);
}

//----- (08078D8D) --------------------------------------------------------
int __cdecl sub_8078D8D(int a1, void *src, int a3, int a4, int a5)
{
  char *v5; // ebx
  char *v6; // ebx
  char *ptr; // [esp+18h] [ebp-10h]
  char *ptra; // [esp+18h] [ebp-10h]
  time_t timer; // [esp+1Ch] [ebp-Ch] BYREF
  char *s; // [esp+20h] [ebp-8h]

  s = sub_80782DB(src);
  switch ( *(a3 + 8) )
  {
    case 1:
      sprintf(s, "%d", *(src + 264));
      *(s + 258) = *(src + 264);
      *(s + 1036) = *(src + 264);
      *(s + 256) = 3;
      *(s + 257) = 4104;
      *a4 = s;
      *a5 = s;
      break;
    case 2:
      strcpy(s, *(a1 + 132));
      *(s + 256) = 4;
      *(s + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    case 3:
      timer = time(0);
      ptr = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptr + 4, 7u);
      strncat(s + 7, ptr + 20, 4u);
      strcat(s, "\"");
      free(ptr);
      *(s + 256) = 4;
      v5 = s;
      *(v5 + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    case 4:
      timer = time(0);
      ptra = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptra + 11, 8u);
      strcat(s, "\"");
      free(ptra);
      *(s + 256) = 4;
      v6 = s;
      *(v6 + 257) = strlen(s);
      *a4 = s;
      *a5 = s;
      break;
    default:
      *a4 = 0;
      *a5 = 0;
      break;
  }
  return 1;
}

//----- (08079003) --------------------------------------------------------
int __cdecl sub_8079003(int a1, void *a2, int a3, int a4, int a5)
{
  int j; // [esp+28h] [ebp-660h]
  int v8; // [esp+2Ch] [ebp-65Ch]
  int v9; // [esp+2Ch] [ebp-65Ch]
  char dest[1072]; // [esp+30h] [ebp-658h] BYREF
  void *v11; // [esp+460h] [ebp-228h]
  char *v12; // [esp+464h] [ebp-224h]
  _DWORD *v13; // [esp+468h] [ebp-220h]
  char *src; // [esp+46Ch] [ebp-21Ch]
  char *v15; // [esp+470h] [ebp-218h]
  _DWORD *v16; // [esp+474h] [ebp-214h]
  void *i; // [esp+478h] [ebp-210h]
  char *s2; // [esp+47Ch] [ebp-20Ch]
  int v19[130]; // [esp+480h] [ebp-208h] BYREF

  if ( *(a3 + 8) )
    return sub_8078D8D(a1, a2, a3, a4, a5);
  if ( *(a3 + 12) && !sub_80784F2(a1, a3, v19, 128) )
    return 0;
  v13 = 0;
  v12 = 0;
  for ( s2 = *(a3 + 20); s2; s2 = *(s2 + 266) )
  {
    v8 = -1;
    if ( *(s2 + 256) == 4 )
      v8 = sub_8078BC2(a3, s2);
    if ( v8 < 0 )
    {
      if ( *s2 != 35 || s2[1] )
      {
        v16 = sub_80782DB(s2);
      }
      else
      {
        if ( *(s2 + 266) )
          v9 = sub_8078BC2(a3, *(s2 + 266));
        else
          v9 = -1;
        if ( v9 < 0 )
        {
          sub_80780EA(a1, "stringizing operator without define parameter");
          continue;
        }
        s2 = *(s2 + 266);
        if ( !sub_8078899(v19[v9], dest) )
        {
          sub_8078084(a1, "can't stringize tokens");
          return 0;
        }
        v16 = sub_80782DB(dest);
      }
      v16[266] = 0;
      if ( v12 )
        *(v12 + 266) = v16;
      else
        v13 = v16;
      v12 = v16;
    }
    else
    {
      for ( i = v19[v8]; i; i = *(i + 266) )
      {
        v16 = sub_80782DB(i);
        v16[266] = 0;
        if ( v12 )
          *(v12 + 266) = v16;
        else
          v13 = v16;
        v12 = v16;
      }
    }
  }
  v16 = v13;
  while ( v16 )
  {
    if ( v16[266] && *v16[266] == 35 && *(v16[266] + 1) == 35 && (v15 = v16, (src = *(v16[266] + 1064)) != 0) )
    {
      if ( !sub_8078957(v15, src) )
      {
        sub_8078084(a1, "can't merge %s with %s", v15, src);
        return 0;
      }
      sub_807834B(*(v15 + 266));
      *(v15 + 266) = *(src + 266);
      if ( src == v12 )
        v12 = v15;
      sub_807834B(src);
    }
    else
    {
      v16 = v16[266];
    }
  }
  *a4 = v13;
  *a5 = v12;
  for ( j = 0; j < *(a3 + 12); ++j )
  {
    for ( i = v19[j]; i; i = v11 )
    {
      v11 = *(i + 266);
      sub_807834B(i);
    }
  }
  return 1;
}

//----- (080794BD) --------------------------------------------------------
int __cdecl sub_80794BD(int a1, void *a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  if ( !sub_8079003(a1, a2, a3, &v6, &v5) )
    return 0;
  if ( !v6 || !v5 )
    return 0;
  *(v5 + 1064) = *(a1 + 136);
  *(a1 + 136) = v6;
  return 1;
}

//----- (08079536) --------------------------------------------------------
char *__cdecl sub_8079536(char *a1)
{
  char *result; // eax
  char *dest; // [esp+14h] [ebp-4h]
  char *desta; // [esp+14h] [ebp-4h]

  dest = a1;
  while ( *dest )
  {
    if ( (*dest == 92 || *dest == 47) && (dest[1] == 92 || dest[1] == 47) )
      strcpy(dest, dest + 1);
    else
      ++dest;
  }
  for ( desta = a1; ; ++desta )
  {
    result = desta;
    if ( !*desta )
      break;
    if ( *desta == 47 || *desta == 92 )
      *desta = 47;
  }
  return result;
}

//----- (080795BF) --------------------------------------------------------
int __cdecl sub_80795BF(int a1)
{
  int v2; // [esp+1Ch] [ebp-48Ch]
  char dest[64]; // [esp+20h] [ebp-488h] BYREF
  char src[1024]; // [esp+60h] [ebp-448h] BYREF
  int v5; // [esp+460h] [ebp-48h]
  int v6; // [esp+484h] [ebp-24h]
  int *v7; // [esp+49Ch] [ebp-Ch]

  if ( *(a1 + 152) > 0 )
    return 1;
  if ( !sub_8078364(a1, src) || v6 > 0 )
    goto LABEL_4;
  if ( v5 != 1 )
  {
    if ( v5 == 5 && src[0] == 60 )
    {
      strcpy(dest, (a1 + 64));
      while ( sub_8078364(a1, src) )
      {
        if ( v6 > 0 )
        {
          sub_80784B9(a1, src);
          break;
        }
        if ( v5 == 5 && src[0] == 62 )
          break;
        strncat(dest, src, 0x40u);
      }
      if ( src[0] != 62 )
        sub_80780EA(a1, "#include missing trailing >");
      if ( !dest[0] )
      {
        sub_8078084(a1, "#include without file name between < >");
        return 0;
      }
      sub_8079536(dest);
      v7 = sub_807F353(dest);
      goto LABEL_24;
    }
LABEL_4:
    sub_8078084(a1, "#include without file name");
    return 0;
  }
  sub_807F01D(src);
  sub_8079536(src);
  v7 = sub_807F353(src);
  if ( !v7 )
  {
    strcpy(dest, (a1 + 64));
    strcat(dest, src);
    v7 = sub_807F353(dest);
  }
LABEL_24:
  if ( v7 )
  {
    sub_807825C(a1, v7);
    v2 = 1;
  }
  else
  {
    sub_8078084(a1, "file %s not found", dest);
    v2 = 0;
  }
  return v2;
}

//----- (0807983D) --------------------------------------------------------
int __cdecl sub_807983D(int a1, char *s1)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = 0;
  do
  {
    if ( !sub_8078364(a1, s1) )
      return 0;
    if ( *(s1 + 265) > v4 )
    {
      sub_80784B9(a1, s1);
      return 0;
    }
    v4 = 1;
  }
  while ( !strcmp(s1, "\\") );
  return 1;
}

//----- (080798BC) --------------------------------------------------------
_BOOL4 __cdecl sub_80798BC(int a1)
{
  return *(a1 + 1052) - *(a1 + 1048) > 0;
}

//----- (080798EB) --------------------------------------------------------
_DWORD *__cdecl sub_80798EB(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[262] = 0;
  a1[263] = 0;
  result = a1;
  a1[265] = 0;
  return result;
}

//----- (08079917) --------------------------------------------------------
int __cdecl sub_8079917(int a1)
{
  int v2; // [esp+10h] [ebp-448h]
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v7; // [esp+420h] [ebp-38h]

  if ( *(a1 + 152) > 0 )
    return 1;
  if ( sub_807983D(a1, s2) )
  {
    if ( v7 == 4 )
    {
      v3 = sub_8078A71(s2);
      v4 = 0;
      for ( i = *(*(a1 + 144) + 4 * v3); i; i = *(i + 28) )
      {
        if ( !strcmp(*i, s2) )
        {
          if ( (*(i + 4) & 1) != 0 )
          {
            sub_80780EA(a1, "can't undef %s", s2);
          }
          else
          {
            if ( v4 )
              *(v4 + 28) = *(i + 28);
            else
              *(*(a1 + 144) + 4 * v3) = *(i + 28);
            sub_8078C1D(i);
          }
          break;
        }
        v4 = i;
      }
      v2 = 1;
    }
    else
    {
      sub_80784B9(a1, s2);
      sub_8078084(a1, "expected name, found %s", s2);
      v2 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "undef without name");
    v2 = 0;
  }
  return v2;
}

//----- (08079AD6) --------------------------------------------------------
int __cdecl sub_8079AD6(int a1)
{
  size_t v1; // eax
  _DWORD *v4; // [esp+14h] [ebp-444h]
  char **v5; // [esp+14h] [ebp-444h]
  char *v6; // [esp+18h] [ebp-440h]
  char *v7; // [esp+18h] [ebp-440h]
  char *s1; // [esp+1Ch] [ebp-43Ch]
  char *s1a; // [esp+1Ch] [ebp-43Ch]
  char s[1024]; // [esp+20h] [ebp-438h] BYREF
  int v11; // [esp+420h] [ebp-38h]

  if ( *(a1 + 152) > 0 )
    return 1;
  if ( !sub_807983D(a1, s) )
  {
    sub_8078084(a1, "#define without name");
    return 0;
  }
  if ( v11 != 4 )
  {
    sub_80784B9(a1, s);
    sub_8078084(a1, "expected name after #define, found %s", s);
    return 0;
  }
  v4 = sub_8078B11(*(a1 + 144), s);
  if ( v4 )
  {
    if ( (v4[1] & 1) != 0 )
    {
      sub_8078084(a1, "can't redefine %s", s);
      return 0;
    }
    sub_80780EA(a1, "redefinition of %s", s);
    sub_80784B9(a1, s);
    if ( !sub_8079917(a1) )
      return 0;
    sub_8078B11(*(a1 + 144), s);
  }
  v1 = strlen(s);
  v5 = sub_8077F64(v1 + 33);
  memset(v5, 0, 0x20u);
  *v5 = (v5 + 8);
  strcpy(*v5, s);
  sub_8078AD0(v5, *(a1 + 144));
  if ( !sub_807983D(a1, s) )
    return 1;
  if ( sub_80798BC(s) || strcmp(s, "(") )
    goto LABEL_34;
  v6 = 0;
  if ( sub_807CCC5(a1, ")") )
  {
LABEL_32:
    if ( !sub_807983D(a1, s) )
      return 1;
LABEL_34:
    v7 = 0;
    do
    {
      s1a = sub_80782DB(s);
      if ( *(s1a + 256) == 4 && !strcmp(s1a, *v5) )
      {
        sub_8078084(a1, "recursive define (removed recursion)");
      }
      else
      {
        sub_80798EB(s1a);
        *(s1a + 266) = 0;
        if ( v7 )
          *(v7 + 266) = s1a;
        else
          v5[5] = s1a;
        v7 = s1a;
      }
    }
    while ( sub_807983D(a1, s) );
    if ( !v7 || strcmp(v5[5], "##") && strcmp(v7, "##") )
      return 1;
    sub_8078084(a1, "define with misplaced ##");
    return 0;
  }
  do
  {
    if ( !sub_807983D(a1, s) )
    {
      sub_8078084(a1, "expected define parameter");
      return 0;
    }
    if ( v11 != 4 )
    {
      sub_8078084(a1, "invalid define parameter");
      return 0;
    }
    if ( sub_8078BC2(v5, s) >= 0 )
    {
      sub_8078084(a1, "two the same define parameters");
      return 0;
    }
    s1 = sub_80782DB(s);
    sub_80798EB(s1);
    *(s1 + 266) = 0;
    if ( v6 )
      *(v6 + 266) = s1;
    else
      v5[4] = s1;
    v6 = s1;
    ++v5[3];
    if ( !sub_807983D(a1, s) )
    {
      sub_8078084(a1, "define parameters not terminated");
      return 0;
    }
    if ( !strcmp(s, ")") )
      goto LABEL_32;
  }
  while ( !strcmp(s, ",") );
  sub_8078084(a1, "define not terminated");
  return 0;
}

//----- (0807A072) --------------------------------------------------------
int __cdecl sub_807A072(char *s)
{
  size_t v1; // eax
  int v4; // [esp+20h] [ebp-4F8h]
  int j; // [esp+24h] [ebp-4F4h]
  int v6; // [esp+28h] [ebp-4F0h]
  int i; // [esp+2Ch] [ebp-4ECh]
  char dest[132]; // [esp+30h] [ebp-4E8h] BYREF
  _DWORD *v9; // [esp+B4h] [ebp-464h]
  int v10; // [esp+B8h] [ebp-460h]
  int v11; // [esp+BCh] [ebp-45Ch]
  _DWORD *v12; // [esp+C0h] [ebp-458h]
  _DWORD *v13; // [esp+50Ch] [ebp-Ch]

  sub_80782D6();
  v1 = strlen(s);
  v13 = sub_807F4F1(s, v1, "*extern");
  memset(dest, 0, 0x4C8u);
  strncpy(dest, "*extern", 0x40u);
  v9 = v13;
  v12 = sub_8077FA7(0x1000u);
  v6 = sub_8079AD6(dest);
  for ( i = v10; i; i = v10 )
  {
    v10 = *(v10 + 1064);
    sub_807834B(i);
  }
  v4 = 0;
  for ( j = 0; j <= 1023; ++j )
  {
    if ( v12[j] )
    {
      v4 = v12[j];
      break;
    }
  }
  sub_8078050(v12);
  sub_807F5D9(v13);
  if ( v6 > 0 )
    return v4;
  if ( v11 )
    sub_8078C1D(v4);
  return 0;
}

//----- (0807A318) --------------------------------------------------------
char **__cdecl sub_807A318(int a1, int a2)
{
  size_t v2; // eax
  char *v4; // [esp+8h] [ebp-10h]
  char *v5; // [esp+8h] [ebp-10h]
  char *v6; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+Ch] [ebp-Ch]
  _DWORD *src; // [esp+10h] [ebp-8h]
  _DWORD *srca; // [esp+10h] [ebp-8h]
  char **v10; // [esp+14h] [ebp-4h]

  v2 = strlen(*a2);
  v10 = sub_8077F64(v2 + 33);
  *v10 = (v10 + 8);
  strcpy(*v10, *a2);
  v10[1] = *(a2 + 4);
  v10[2] = *(a2 + 8);
  v10[3] = *(a2 + 12);
  v10[6] = 0;
  v10[7] = 0;
  v10[5] = 0;
  v4 = 0;
  for ( src = *(a2 + 20); src; src = src[266] )
  {
    v6 = sub_80782DB(src);
    *(v6 + 266) = 0;
    if ( v4 )
      *(v4 + 266) = v6;
    else
      v10[5] = v6;
    v4 = v6;
  }
  v10[4] = 0;
  v5 = 0;
  for ( srca = *(a2 + 16); srca; srca = srca[266] )
  {
    v7 = sub_80782DB(srca);
    *(v7 + 266) = 0;
    if ( v5 )
      *(v5 + 266) = v7;
    else
      v10[4] = v7;
    v5 = v7;
  }
  return v10;
}

//----- (0807A473) --------------------------------------------------------
int __cdecl sub_807A473(int a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = dword_8489A04;
  for ( i = dword_8489A04; i; i = result )
  {
    v2 = sub_807A318(a1, i);
    sub_8078AD0(v2, *(a1 + 144));
    result = *(i + 24);
  }
  return result;
}
// 8489A04: using guessed type int dword_8489A04;

//----- (0807A4C3) --------------------------------------------------------
int __cdecl sub_807A4C3(_DWORD *a1, int a2)
{
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v6; // [esp+420h] [ebp-38h]

  if ( sub_807983D(a1, s2) )
  {
    if ( v6 == 4 )
    {
      v4 = sub_8078B11(a1[36], s2);
      sub_8078150(a1, a2, (a2 != 8) ^ (v4 == 0));
      v3 = 1;
    }
    else
    {
      sub_80784B9(a1, s2);
      sub_8078084(a1, "expected name after #ifdef, found %s", s2);
      v3 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "#ifdef without name");
    v3 = 0;
  }
  return v3;
}

//----- (0807A5B9) --------------------------------------------------------
int __cdecl sub_807A5B9(_DWORD *a1)
{
  return sub_807A4C3(a1, 8);
}

//----- (0807A5D4) --------------------------------------------------------
int __cdecl sub_807A5D4(_DWORD *a1)
{
  return sub_807A4C3(a1, 16);
}

//----- (0807A5EF) --------------------------------------------------------
int __cdecl sub_807A5EF(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  char v3[4]; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  sub_80781C1(a1, &v4, v3);
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      sub_8078084(a1, "#else after #else");
      v2 = 0;
    }
    else
    {
      sub_8078150(a1, 2, *v3 == 0);
      v2 = 1;
    }
  }
  else
  {
    sub_8078084(a1, "misplaced #else");
    v2 = 0;
  }
  return v2;
}

//----- (0807A67F) --------------------------------------------------------
int __cdecl sub_807A67F(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  sub_80781C1(a1, &v4, &v3);
  if ( v4 )
    return 1;
  sub_8078084(a1, "misplaced #endif");
  return 0;
}

//----- (0807A6CC) --------------------------------------------------------
int __cdecl sub_807A6CC(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 5:
      v2 = 7;
      break;
    case 6:
      v2 = 6;
      break;
    case 7:
      v2 = 12;
      break;
    case 8:
      v2 = 12;
      break;
    case 9:
      v2 = 11;
      break;
    case 10:
      v2 = 11;
      break;
    case 21:
      v2 = 13;
      break;
    case 22:
      v2 = 13;
      break;
    case 26:
      v2 = 15;
      break;
    case 27:
      v2 = 15;
      break;
    case 28:
      v2 = 15;
      break;
    case 29:
      v2 = 14;
      break;
    case 30:
      v2 = 14;
      break;
    case 32:
      v2 = 10;
      break;
    case 33:
      v2 = 8;
      break;
    case 34:
      v2 = 9;
      break;
    case 35:
      v2 = 16;
      break;
    case 36:
      v2 = 16;
      break;
    case 37:
      v2 = 12;
      break;
    case 38:
      v2 = 12;
      break;
    case 42:
      v2 = 5;
      break;
    case 43:
      v2 = 5;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (0807A7DB) --------------------------------------------------------
int __cdecl sub_807A7DB(int a1, char *a2, _DWORD *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  int *v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // edx
  double v13; // [esp+38h] [ebp-C10h]
  double v14; // [esp+48h] [ebp-C00h]
  double v15; // [esp+58h] [ebp-BF0h]
  double v16; // [esp+68h] [ebp-BE0h]
  double v17; // [esp+78h] [ebp-BD0h]
  double v18; // [esp+88h] [ebp-BC0h]
  int v19; // [esp+98h] [ebp-BB0h]
  int v20; // [esp+A0h] [ebp-BA8h]
  int v21; // [esp+A8h] [ebp-BA0h]
  int v22; // [esp+B0h] [ebp-B98h]
  double v23; // [esp+B8h] [ebp-B90h]
  int v24; // [esp+C4h] [ebp-B84h]
  int v26; // [esp+DCh] [ebp-B6Ch]
  _QWORD v27[193]; // [esp+E0h] [ebp-B68h] BYREF
  int v28; // [esp+6ECh] [ebp-55Ch]
  _DWORD v29[320]; // [esp+6F0h] [ebp-558h] BYREF
  int v30; // [esp+BF0h] [ebp-58h]
  int v31; // [esp+BF4h] [ebp-54h]
  double v32; // [esp+BF8h] [ebp-50h]
  int v33; // [esp+C04h] [ebp-44h]
  int v34; // [esp+C08h] [ebp-40h]
  int v35; // [esp+C0Ch] [ebp-3Ch]
  int v36; // [esp+C10h] [ebp-38h]
  int v37; // [esp+C14h] [ebp-34h]
  int v38; // [esp+C18h] [ebp-30h]
  char *s1; // [esp+C1Ch] [ebp-2Ch]
  int v40; // [esp+C20h] [ebp-28h]
  int *v41; // [esp+C24h] [ebp-24h]
  _DWORD *v42; // [esp+C28h] [ebp-20h]
  _DWORD *v43; // [esp+C2Ch] [ebp-1Ch]
  _DWORD *j; // [esp+C30h] [ebp-18h]
  _DWORD *v45; // [esp+C34h] [ebp-14h]
  _DWORD *v46; // [esp+C38h] [ebp-10h]
  _DWORD *i; // [esp+C3Ch] [ebp-Ch]

  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v32 = 0.0;
  v31 = 0;
  v30 = 0;
  v28 = 0;
  v26 = 0;
  v45 = 0;
  v46 = 0;
  v42 = 0;
  v43 = 0;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
  {
    *a4 = 0;
    a4[1] = 0;
  }
  for ( s1 = a2; s1; s1 = *(s1 + 266) )
  {
    v24 = *(s1 + 256);
    if ( v24 == 4 )
    {
      if ( v35 || v34 )
      {
LABEL_37:
        sub_8078084(a1, "syntax error in #if/#elif");
        v36 = 1;
        goto LABEL_80;
      }
      if ( strcmp(s1, "defined") )
      {
        sub_8078084(a1, "undefined name %s in #if/#elif", s1);
        v36 = 1;
        goto LABEL_80;
      }
      s1 = *(s1 + 266);
      if ( !strcmp(s1, "(") )
      {
        v38 = 1;
        s1 = *(s1 + 266);
      }
      if ( !s1 || *(s1 + 256) != 4 )
      {
        sub_8078084(a1, "defined without name in #if/#elif");
        v36 = 1;
        goto LABEL_80;
      }
      if ( v26 > 63 )
      {
LABEL_24:
        sub_8078084(a1, "out of value space\n");
        v36 = 1;
        goto LABEL_80;
      }
      j = &v27[3 * v26++];
      if ( sub_8078B11(*(a1 + 144), s1) )
      {
        *j = 1;
        v5 = j;
        j[1] = 0;
        v5[2] = 1072693248;
      }
      else
      {
        *j = 0;
        v6 = j;
        j[1] = 0;
        v6[2] = 0;
      }
      j[3] = v37;
      j[5] = 0;
      j[4] = v42;
      if ( v42 )
        v42[5] = j;
      else
        v43 = j;
      v42 = j;
      if ( !v38 || (s1 = *(s1 + 266)) != 0 && !strcmp(s1, ")") )
      {
        v38 = 0;
        v35 = 1;
      }
      else
      {
        sub_8078084(a1, "defined without ) in #if/#elif");
        v36 = 1;
      }
    }
    else if ( v24 > 4 )
    {
      if ( v24 != 5 )
      {
LABEL_79:
        sub_8078084(a1, "unknown %s in #if/#elif", s1);
        v36 = 1;
        goto LABEL_80;
      }
      if ( v34 )
      {
        sub_8078084(a1, "misplaced minus sign in #if/#elif");
        v36 = 1;
      }
      else if ( *(s1 + 257) == 44 )
      {
        ++v37;
      }
      else if ( *(s1 + 257) == 45 )
      {
        if ( --v37 < 0 )
        {
          sub_8078084(a1, "too many ) in #if/#elsif");
          v36 = 1;
        }
      }
      else if ( !a5
             && (*(s1 + 257) == 35
              || *(s1 + 257) == 28
              || *(s1 + 257) == 21
              || *(s1 + 257) == 22
              || *(s1 + 257) == 32
              || *(s1 + 257) == 33
              || *(s1 + 257) == 34) )
      {
        sub_8078084(a1, "illigal operator %s on floating point operands\n", s1);
        v36 = 1;
      }
      else
      {
        switch ( *(s1 + 257) )
        {
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0x15:
          case 0x16:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x25:
          case 0x26:
          case 0x2A:
          case 0x2B:
            goto LABEL_68;
          case 0x10:
          case 0x11:
            sub_8078084(a1, "++ or -- used in #if/#elif");
            break;
          case 0x1E:
            if ( v35 )
            {
LABEL_68:
              if ( !v35 )
              {
                sub_8078084(a1, "operator %s after operator in #if/#elif", s1);
                v36 = 1;
              }
            }
            else
            {
              v34 = 1;
            }
            break;
          case 0x23:
          case 0x24:
            if ( v35 )
            {
              sub_8078084(a1, "! or ~ after value in #if/#elif");
              v36 = 1;
            }
            break;
          default:
            sub_8078084(a1, "invalid operator %s in #if/#elif", s1);
            v36 = 1;
            break;
        }
        if ( !v36 && !v34 )
        {
          if ( v28 <= 63 )
          {
            i = &v29[5 * v28++];
            *i = *(s1 + 257);
            v7 = i;
            v7[1] = sub_807A6CC(*(s1 + 257));
            i[2] = v37;
            i[4] = 0;
            i[3] = v45;
            if ( v45 )
              v45[4] = i;
            else
              v46 = i;
            v45 = i;
            v35 = 0;
          }
          else
          {
            sub_8078084(a1, "out of operator space\n");
            v36 = 1;
          }
        }
      }
    }
    else
    {
      if ( v24 != 3 )
        goto LABEL_79;
      if ( v35 )
        goto LABEL_37;
      if ( v26 > 63 )
        goto LABEL_24;
      j = &v27[3 * v26++];
      if ( v34 )
      {
        *j = -*(s1 + 258);
        *(j + 1) = -*(s1 + 1036);
      }
      else
      {
        *j = *(s1 + 258);
        *(j + 1) = *(s1 + 1036);
      }
      j[3] = v37;
      j[5] = 0;
      j[4] = v42;
      if ( v42 )
        v42[5] = j;
      else
        v43 = j;
      v42 = j;
      v35 = 1;
      v34 = 0;
    }
LABEL_80:
    if ( v36 )
      break;
  }
  if ( !v36 )
  {
    if ( v35 )
    {
      if ( v37 )
      {
        sub_8078084(a1, "too many ( in #if/#elif");
        v36 = 1;
      }
    }
    else
    {
      sub_8078084(a1, "trailing operator in #if/#elif");
      v36 = 1;
    }
  }
  v31 = 0;
  v33 = 0;
  v32 = 0.0;
  while ( !v36 && v46 )
  {
    j = v43;
    for ( i = v46; i[4] && i[2] <= *(i[4] + 8) && (i[2] != *(i[4] + 8) || i[1] < *(i[4] + 4)); i = i[4] )
    {
      if ( *i != 36 && *i != 35 )
        j = j[5];
      if ( !j )
      {
        sub_8078084(a1, "mising values in #if/#elif");
        v36 = 1;
        break;
      }
    }
    if ( v36 )
      break;
    v41 = j;
    v40 = j[5];
    switch ( *i )
    {
      case 5:
        v22 = 0;
        if ( *v41 && *v40 )
          v22 = 1;
        *v41 = v22;
        v21 = 0;
        if ( *(v41 + 1) != 0.0 && *(v40 + 4) != 0.0 )
          v21 = 1;
        *(v41 + 1) = v21;
        break;
      case 6:
        v20 = 0;
        if ( *v41 || *v40 )
          v20 = 1;
        *v41 = v20;
        v19 = 0;
        if ( *(v41 + 1) != 0.0 || *(v40 + 4) != 0.0 )
          v19 = 1;
        *(v41 + 1) = v19;
        break;
      case 7:
        *v41 = *v41 >= *v40;
        if ( *(v41 + 1) < *(v40 + 4) )
          v18 = 0.0;
        else
          v18 = 1.0;
        *(v41 + 1) = v18;
        break;
      case 8:
        *v41 = *v41 <= *v40;
        if ( *(v40 + 4) < *(v41 + 1) )
          v17 = 0.0;
        else
          v17 = 1.0;
        *(v41 + 1) = v17;
        break;
      case 9:
        *v41 = *v41 == *v40;
        if ( *(v41 + 1) == *(v40 + 4) )
          v16 = 1.0;
        else
          v16 = 0.0;
        *(v41 + 1) = v16;
        break;
      case 0xA:
        *v41 = *v41 != *v40;
        if ( *(v41 + 1) == *(v40 + 4) )
          v15 = 0.0;
        else
          v15 = 1.0;
        *(v41 + 1) = v15;
        break;
      case 0x15:
        *v41 >>= *v40;
        break;
      case 0x16:
        *v41 <<= *v40;
        break;
      case 0x1A:
        *v41 *= *v40;
        *(v41 + 1) = *(v41 + 1) * *(v40 + 4);
        break;
      case 0x1B:
        if ( !*v40 || *(v40 + 4) == 0.0 )
          goto LABEL_114;
        *v41 /= *v40;
        *(v41 + 1) = *(v41 + 1) / *(v40 + 4);
        break;
      case 0x1C:
        if ( *v40 )
        {
          *v41 %= *v40;
        }
        else
        {
LABEL_114:
          sub_8078084(a1, "divide by zero in #if/#elif\n");
          v36 = 1;
        }
        break;
      case 0x1D:
        *v41 += *v40;
        *(v41 + 1) = *(v41 + 1) + *(v40 + 4);
        break;
      case 0x1E:
        *v41 -= *v40;
        *(v41 + 1) = *(v41 + 1) - *(v40 + 4);
        break;
      case 0x20:
        *v41 &= *v40;
        break;
      case 0x21:
        *v41 |= *v40;
        break;
      case 0x22:
        *v41 ^= *v40;
        break;
      case 0x23:
        *v41 = ~*v41;
        break;
      case 0x24:
        *v41 = *v41 == 0;
        if ( *(v41 + 1) == 0.0 )
          v23 = 1.0;
        else
          v23 = 0.0;
        *(v41 + 1) = v23;
        break;
      case 0x25:
        *v41 = *v41 > *v40;
        if ( *(v41 + 1) <= *(v40 + 4) )
          v14 = 0.0;
        else
          v14 = 1.0;
        *(v41 + 1) = v14;
        break;
      case 0x26:
        *v41 = *v41 < *v40;
        if ( *(v40 + 4) <= *(v41 + 1) )
          v13 = 0.0;
        else
          v13 = 1.0;
        *(v41 + 1) = v13;
        break;
      case 0x2A:
        if ( v31 )
        {
          if ( a5 )
          {
            if ( !v33 )
              *v41 = *v40;
          }
          else if ( v32 == 0.0 )
          {
            v8 = v41;
            v9 = *(v40 + 8);
            v41[1] = *(v40 + 4);
            v8[2] = v9;
          }
          v31 = 0;
        }
        else
        {
          sub_8078084(a1, ": without ? in #if/#elif");
          v36 = 1;
        }
        break;
      case 0x2B:
        if ( v31 )
        {
          sub_8078084(a1, "? after ? in #if/#elif");
          v36 = 1;
        }
        else
        {
          v33 = *v41;
          v10 = v41[2];
          LODWORD(v32) = v41[1];
          HIDWORD(v32) = v10;
          v31 = 1;
        }
        break;
      default:
        break;
    }
    if ( v36 )
      break;
    v30 = *i;
    if ( *i != 36 && *i != 35 )
    {
      if ( *i != 43 )
        j = j[5];
      if ( j[4] )
        *(j[4] + 20) = j[5];
      else
        v43 = j[5];
      if ( j[5] )
        *(j[5] + 16) = j[4];
      else
        v42 = j[4];
    }
    if ( i[3] )
      *(i[3] + 16) = i[4];
    else
      v46 = i[4];
    if ( i[4] )
      *(i[4] + 12) = i[3];
    else
      v45 = i[3];
  }
  if ( v43 )
  {
    if ( a3 )
      *a3 = *v43;
    if ( a4 )
    {
      v11 = v43[2];
      *a4 = v43[1];
      a4[1] = v11;
    }
  }
  for ( i = v46; i; i = v45 )
    v45 = i[4];
  for ( j = v43; j; j = v42 )
    v42 = j[5];
  if ( !v36 )
    return 1;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return 0;
}

//----- (0807B78A) --------------------------------------------------------
int __cdecl sub_807B78A(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v5; // [esp+24h] [ebp-454h]
  int v6; // [esp+28h] [ebp-450h]
  int v7; // [esp+2Ch] [ebp-44Ch]
  int v8; // [esp+30h] [ebp-448h]
  char *v9; // [esp+34h] [ebp-444h]
  char *v10; // [esp+34h] [ebp-444h]
  char *v11; // [esp+34h] [ebp-444h]
  int i; // [esp+34h] [ebp-444h]
  char *v13; // [esp+38h] [ebp-440h]
  char *v14; // [esp+3Ch] [ebp-43Ch]
  char s1[1024]; // [esp+40h] [ebp-438h] BYREF
  int v16; // [esp+440h] [ebp-38h]

  v6 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
  {
    *a3 = 0;
    a3[1] = 0;
  }
  if ( sub_807983D(a1, s1) )
  {
    v14 = 0;
    v13 = 0;
    do
    {
      if ( v16 == 4 )
      {
        if ( v6 )
        {
          v6 = 0;
          v9 = sub_80782DB(s1);
          *(v9 + 266) = 0;
          if ( v13 )
            *(v13 + 266) = v9;
          else
            v14 = v9;
          v13 = v9;
        }
        else if ( !strcmp(s1, "defined") )
        {
          v6 = 1;
          v10 = sub_80782DB(s1);
          *(v10 + 266) = 0;
          if ( v13 )
            *(v13 + 266) = v10;
          else
            v14 = v10;
          v13 = v10;
        }
        else
        {
          v7 = sub_8078B11(*(a1 + 144), s1);
          if ( !v7 )
          {
            sub_8078084(a1, "can't evaluate %s, not defined", s1);
            return 0;
          }
          if ( !sub_80794BD(a1, s1, v7) )
            return 0;
        }
      }
      else
      {
        if ( v16 != 3 && v16 != 5 )
        {
          sub_8078084(a1, "can't evaluate %s", s1);
          return 0;
        }
        v11 = sub_80782DB(s1);
        *(v11 + 266) = 0;
        if ( v13 )
          *(v13 + 266) = v11;
        else
          v14 = v11;
        v13 = v11;
      }
    }
    while ( sub_807983D(a1, s1) );
    if ( sub_807A7DB(a1, v14, a2, a3, a4) )
    {
      for ( i = v14; i; i = v8 )
      {
        v8 = *(i + 1064);
        sub_807834B(i);
      }
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "no value after #if/#elif");
    v5 = 0;
  }
  return v5;
}

//----- (0807BADD) --------------------------------------------------------
int __cdecl sub_807BADD(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v6; // [esp+2Ch] [ebp-45Ch]
  int v7; // [esp+30h] [ebp-458h]
  char *v8; // [esp+34h] [ebp-454h]
  char *v9; // [esp+34h] [ebp-454h]
  char *v10; // [esp+34h] [ebp-454h]
  int i; // [esp+34h] [ebp-454h]
  char *v12; // [esp+38h] [ebp-450h]
  char *v13; // [esp+3Ch] [ebp-44Ch]
  char s1[1024]; // [esp+40h] [ebp-448h] BYREF
  int v15; // [esp+440h] [ebp-48h]
  int v16; // [esp+478h] [ebp-10h]
  int v17; // [esp+47Ch] [ebp-Ch]

  v16 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
  {
    *a3 = 0;
    a3[1] = 0;
  }
  if ( !sub_8078364(a1, s1) )
  {
    sub_8078084(a1, "no leading ( after $evalint/$evalfloat");
    return 0;
  }
  if ( !sub_8078364(a1, s1) )
  {
    sub_8078084(a1, "nothing to evaluate");
    return 0;
  }
  v17 = 1;
  v13 = 0;
  v12 = 0;
  do
  {
    if ( v15 == 4 )
    {
      if ( v16 )
      {
        v16 = 0;
        v8 = sub_80782DB(s1);
        *(v8 + 266) = 0;
        if ( v12 )
          *(v12 + 266) = v8;
        else
          v13 = v8;
        v12 = v8;
      }
      else if ( !strcmp(s1, "defined") )
      {
        v16 = 1;
        v9 = sub_80782DB(s1);
        *(v9 + 266) = 0;
        if ( v12 )
          *(v12 + 266) = v9;
        else
          v13 = v9;
        v12 = v9;
      }
      else
      {
        v6 = sub_8078B11(*(a1 + 144), s1);
        if ( !v6 )
        {
          sub_8078084(a1, "can't evaluate %s, not defined", s1);
          return 0;
        }
        if ( !sub_80794BD(a1, s1, v6) )
          return 0;
      }
      continue;
    }
    if ( v15 != 3 && v15 != 5 )
    {
      sub_8078084(a1, "can't evaluate %s", s1);
      return 0;
    }
    if ( s1[0] == 40 )
    {
      ++v17;
    }
    else if ( s1[0] == 41 )
    {
      --v17;
    }
    if ( v17 <= 0 )
      break;
    v10 = sub_80782DB(s1);
    *(v10 + 266) = 0;
    if ( v12 )
      *(v12 + 266) = v10;
    else
      v13 = v10;
    v12 = v10;
  }
  while ( sub_8078364(a1, s1) );
  if ( !sub_807A7DB(a1, v13, a2, a3, a4) )
    return 0;
  for ( i = v13; i; i = v7 )
  {
    v7 = *(i + 1064);
    sub_807834B(i);
  }
  return 1;
}

//----- (0807BE92) --------------------------------------------------------
int __cdecl sub_807BE92(_DWORD *a1)
{
  int v2; // [esp+18h] [ebp-10h]
  char v3[4]; // [esp+1Ch] [ebp-Ch] BYREF
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  sub_80781C1(a1, &v4, v3);
  if ( v4 && v4 != 2 )
  {
    if ( sub_807B78A(a1, &v5, 0, 1) )
    {
      *v3 = v5 == 0;
      sub_8078150(a1, 4, *v3);
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "misplaced #elif");
    v2 = 0;
  }
  return v2;
}

//----- (0807BF3D) --------------------------------------------------------
int __cdecl sub_807BF3D(_DWORD *a1)
{
  int v3; // [esp+24h] [ebp-4h] BYREF

  if ( !sub_807B78A(a1, &v3, 0, 1) )
    return 0;
  sub_8078150(a1, 1, v3 == 0);
  return 1;
}

//----- (0807BFA5) --------------------------------------------------------
int __cdecl sub_807BFA5(int a1)
{
  sub_8078084(a1, "#line directive not supported");
  return 0;
}

//----- (0807BFC5) --------------------------------------------------------
int __cdecl sub_807BFC5(int a1)
{
  char dest[1080]; // [esp+10h] [ebp-438h] BYREF

  strcpy(dest, &byte_80E06A9);
  sub_8078364(a1, dest);
  sub_8078084(a1, "#error directive: %s", dest);
  return 0;
}

//----- (0807C01D) --------------------------------------------------------
int __cdecl sub_807C01D(int a1)
{
  char s1[1080]; // [esp+10h] [ebp-438h] BYREF

  sub_80780EA(a1, "#pragma directive not supported");
  while ( sub_807983D(a1, s1) )
    ;
  return 1;
}

//----- (0807C059) --------------------------------------------------------
int __cdecl sub_807C059(int a1)
{
  char dest[1024]; // [esp+10h] [ebp-438h] BYREF
  int v3; // [esp+410h] [ebp-38h]
  int v4; // [esp+414h] [ebp-34h]
  int v5; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int v7; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]

  v7 = *(*(a1 + 132) + 92);
  v5 = *(*(a1 + 132) + 68);
  v6 = *(*(a1 + 132) + 68);
  v8 = 0;
  strcpy(dest, "-");
  v3 = 5;
  v4 = 30;
  return sub_80784B9(a1, dest);
}

//----- (0807C0D1) --------------------------------------------------------
int __cdecl sub_807C0D1(int a1)
{
  int v2; // [esp+8h] [ebp-460h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+438h] [ebp-30h]
  int v8; // [esp+43Ch] [ebp-2Ch]
  int v9; // [esp+440h] [ebp-28h]
  int v10; // [esp+444h] [ebp-24h]
  int v11[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !sub_807B78A(a1, v11, 0, 1) )
    return 0;
  v9 = *(*(a1 + 132) + 92);
  v7 = *(*(a1 + 132) + 68);
  v8 = *(*(a1 + 132) + 68);
  v10 = 0;
  v2 = v11[0];
  if ( v11[0] < 0 )
    v2 = -v11[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  sub_80784B9(a1, s);
  if ( v11[0] < 0 )
    sub_807C059(a1);
  return 1;
}

//----- (0807C1B3) --------------------------------------------------------
int __cdecl sub_807C1B3(int a1)
{
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v4; // [esp+420h] [ebp-48h]
  int v5; // [esp+424h] [ebp-44h]
  int v6; // [esp+438h] [ebp-30h]
  int v7; // [esp+43Ch] [ebp-2Ch]
  int v8; // [esp+440h] [ebp-28h]
  int v9; // [esp+444h] [ebp-24h]
  double v10[2]; // [esp+458h] [ebp-10h] BYREF

  if ( !sub_807B78A(a1, 0, v10, 0) )
    return 0;
  v8 = *(*(a1 + 132) + 92);
  v6 = *(*(a1 + 132) + 68);
  v7 = *(*(a1 + 132) + 68);
  v9 = 0;
  sprintf(s, "%1.2f", COERCE_DOUBLE(*&v10[0] & 0x7FFFFFFFFFFFFFFFLL));
  v4 = 3;
  v5 = 10248;
  sub_80784B9(a1, s);
  if ( v10[0] < 0.0 )
    sub_807C059(a1);
  return 1;
}

//----- (0807C29D) --------------------------------------------------------
int __cdecl sub_807C29D(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_8078364(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_80EFEA0)[2 * i]; ++i )
        {
          if ( !strcmp((&off_80EFEA0)[2 * i], s2) )
            return (*(&off_80EFEA4 + 2 * i))(a1);
        }
      }
      sub_8078084(a1, "unknown precompiler directive %s", s2);
      v2 = 0;
    }
    else
    {
      sub_80784B9(a1, s2);
      sub_8078084(a1, "found # at end of line");
      v2 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "found # without name");
    v2 = 0;
  }
  return v2;
}
// 80EFEA4: using guessed type int (__cdecl *off_80EFEA4)(int);

//----- (0807C3B9) --------------------------------------------------------
int __cdecl sub_807C3B9(int a1)
{
  int v2; // [esp+8h] [ebp-460h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+428h] [ebp-40h]
  long double v8; // [esp+42Ch] [ebp-3Ch]
  int v9; // [esp+438h] [ebp-30h]
  int v10; // [esp+43Ch] [ebp-2Ch]
  int v11; // [esp+440h] [ebp-28h]
  int v12; // [esp+444h] [ebp-24h]
  int v13[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !sub_807BADD(a1, v13, 0, 1) )
    return 0;
  v11 = *(*(a1 + 132) + 92);
  v9 = *(*(a1 + 132) + 68);
  v10 = *(*(a1 + 132) + 68);
  v12 = 0;
  v2 = v13[0];
  if ( v13[0] < 0 )
    v2 = -v13[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  v7 = v13[0];
  v8 = v13[0];
  sub_80784B9(a1, s);
  if ( v13[0] < 0 )
    sub_807C059(a1);
  return 1;
}

//----- (0807C4A7) --------------------------------------------------------
int __cdecl sub_807C4A7(int a1)
{
  char s[1024]; // [esp+30h] [ebp-448h] BYREF
  int v4; // [esp+430h] [ebp-48h]
  int v5; // [esp+434h] [ebp-44h]
  int v6; // [esp+438h] [ebp-40h]
  long double v7; // [esp+43Ch] [ebp-3Ch]
  int v8; // [esp+448h] [ebp-30h]
  int v9; // [esp+44Ch] [ebp-2Ch]
  int v10; // [esp+450h] [ebp-28h]
  int v11; // [esp+454h] [ebp-24h]
  double v12[2]; // [esp+468h] [ebp-10h] BYREF

  if ( !sub_807BADD(a1, 0, v12, 0) )
    return 0;
  v10 = *(*(a1 + 132) + 92);
  v8 = *(*(a1 + 132) + 68);
  v9 = *(*(a1 + 132) + 68);
  v11 = 0;
  sprintf(s, "%1.2f", COERCE_DOUBLE(*&v12[0] & 0x7FFFFFFFFFFFFFFFLL));
  v4 = 3;
  v5 = 10248;
  v6 = v12[0];
  v7 = v12[0];
  sub_80784B9(a1, s);
  if ( v12[0] < 0.0 )
    sub_807C059(a1);
  return 1;
}

//----- (0807C5D3) --------------------------------------------------------
int __cdecl sub_807C5D3(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_8078364(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_80EFF40)[2 * i]; ++i )
        {
          if ( !strcmp((&off_80EFF40)[2 * i], s2) )
            return (*(&off_80EFF44 + 2 * i))(a1);
        }
      }
      sub_80784B9(a1, s2);
      sub_8078084(a1, "unknown precompiler directive %s", s2);
      v2 = 0;
    }
    else
    {
      sub_80784B9(a1, s2);
      sub_8078084(a1, "found $ at end of line");
      v2 = 0;
    }
  }
  else
  {
    sub_8078084(a1, "found $ without name");
    v2 = 0;
  }
  return v2;
}
// 80EFF44: using guessed type int (__cdecl *off_80EFF44)(int);

//----- (0807C704) --------------------------------------------------------
int __cdecl sub_807C704(int a1, char *s)
{
  size_t v2; // ebx
  char src; // [esp+20h] [ebp-448h] BYREF
  char v6[1023]; // [esp+21h] [ebp-447h] BYREF
  int v7; // [esp+420h] [ebp-48h]
  int v8; // [esp+45Ch] [ebp-Ch]

  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !sub_8078364(a1, s) )
            return 0;
          if ( *(s + 256) != 5 || *s != 35 )
            break;
          if ( !sub_807C29D(a1) )
            return 0;
        }
        if ( *(s + 256) != 5 || *s != 36 )
          break;
        if ( !sub_807C5D3(a1) )
          return 0;
      }
      if ( *(s + 256) == 1 && sub_807C704(a1, &src) )
      {
        if ( v7 == 1 )
        {
          s[strlen(s) - 1] = 0;
          v2 = strlen(s);
          if ( strlen(v6) + v2 + 1 > 0x3FF )
          {
            sub_8078084(a1, "string longer than MAX_TOKEN %d\n", 1024);
            return 0;
          }
          strcat(s, v6);
        }
        else
        {
          sub_807CE4B(a1, &src);
        }
      }
    }
    while ( *(a1 + 152) );
    if ( *(s + 256) != 4 )
      break;
    v8 = sub_8078B11(*(a1 + 144), s);
    if ( !v8 )
      break;
    if ( !sub_80794BD(a1, s, v8) )
      return 0;
  }
  memcpy((a1 + 156), s, 0x42Cu);
  return 1;
}

//----- (0807CCC5) --------------------------------------------------------
int __cdecl sub_807CCC5(int a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( !sub_807C704(a1, s1) )
    return 0;
  if ( !strcmp(s1, s2) )
    return 1;
  sub_80784B9(a1, s1);
  return 0;
}

//----- (0807CE4B) --------------------------------------------------------
int __cdecl sub_807CE4B(int a1, void *src)
{
  return sub_80784B9(a1, src);
}

//----- (0807CEE6) --------------------------------------------------------
_DWORD *__cdecl sub_807CEE6(char *src)
{
  int *v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  sub_80782D6();
  v3 = sub_807F353(src);
  if ( !v3 )
    return 0;
  v3[296] = 0;
  s = sub_8077F64(1224);
  memset(s, 0, 0x4C8u);
  strncpy(s, src, 0x40u);
  s[33] = v3;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = sub_8077FA7(0x1000u);
  sub_807A473(s);
  return s;
}

//----- (0807D0CC) --------------------------------------------------------
void __cdecl sub_807D0CC(_DWORD *a1)
{
  int i; // [esp+Ch] [ebp-1Ch]
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  while ( a1[33] )
  {
    v5 = a1[33];
    a1[33] = *(v5 + 1184);
    sub_807F5D9(v5);
  }
  while ( a1[34] )
  {
    v4 = a1[34];
    a1[34] = *(v4 + 1064);
    sub_807834B(v4);
  }
  for ( i = 0; i <= 1023; ++i )
  {
    while ( *(a1[36] + 4 * i) )
    {
      v3 = *(a1[36] + 4 * i);
      *(a1[36] + 4 * i) = *(v3 + 28);
      sub_8078C1D(v3);
    }
  }
  while ( a1[37] )
  {
    v2 = a1[37];
    a1[37] = *(v2 + 12);
    sub_8078050(v2);
  }
  if ( a1[36] )
    sub_8078050(a1[36]);
  sub_8078050(a1);
}

//----- (0807D4E4) --------------------------------------------------------
int __cdecl sub_807D4E4(int a1, int a2)
{
  int result; // eax
  size_t v3; // ebx
  const char **v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(a1 + 112) )
    *(a1 + 112) = sub_8077F64(1024);
  memset(*(a1 + 112), 0, 0x400u);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( !*(a2 + 12 * i) )
      break;
    v4 = (a2 + 12 * i);
    v5 = 0;
    for ( j = *(*(a1 + 112) + 4 * **v4); j; j = *(j + 8) )
    {
      v3 = strlen(*j);
      if ( v3 < strlen(*v4) )
      {
        v4[2] = j;
        if ( v5 )
          *(v5 + 8) = v4;
        else
          *(*(a1 + 112) + 4 * **v4) = v4;
        break;
      }
      v5 = j;
    }
    if ( !j )
    {
      v4[2] = 0;
      if ( v5 )
        *(v5 + 8) = v4;
      else
        *(*(a1 + 112) + 4 * **v4) = v4;
    }
  }
  return result;
}

//----- (0807D6B4) --------------------------------------------------------
void sub_807D6B4(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  if ( (*(a1 + 104) & 1) == 0 )
  {
    vsprintf(s, format, va);
    Com_Printf("^1Error: file %s, line %d: %s\n", a1, *(a1 + 92), s);
  }
}

//----- (0807D71D) --------------------------------------------------------
void sub_807D71D(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  if ( (*(a1 + 104) & 2) == 0 )
  {
    vsprintf(s, format, va);
    Com_Printf("file %s, line %d: %s\n", a1, *(a1 + 92), s);
  }
}

//----- (0807D786) --------------------------------------------------------
int __cdecl sub_807D786(int a1, int a2)
{
  int result; // eax

  if ( a2 )
    sub_807D4E4(a1, a2);
  else
    sub_807D4E4(a1, &off_80EFFE0);
  if ( a2 )
  {
    result = a2;
    *(a1 + 108) = a2;
  }
  else
  {
    result = a1;
    *(a1 + 108) = &off_80EFFE0;
  }
  return result;
}
// 80EFFE0: using guessed type char *off_80EFFE0;

//----- (0807D7D6) --------------------------------------------------------
int __cdecl sub_807D7D6(int a1)
{
  while ( 1 )
  {
    while ( **(a1 + 68) <= 32 )
    {
      if ( !**(a1 + 68) )
        return 0;
      if ( **(a1 + 68) == 10 )
        ++*(a1 + 92);
      ++*(a1 + 68);
    }
    if ( **(a1 + 68) != 47 )
      break;
    if ( *(*(a1 + 68) + 1) == 47 )
    {
      ++*(a1 + 68);
      do
      {
        if ( !*++*(a1 + 68) )
          return 0;
      }
      while ( **(a1 + 68) != 10 );
      ++*(a1 + 92);
      if ( !*++*(a1 + 68) )
        return 0;
    }
    else
    {
      if ( *(*(a1 + 68) + 1) != 42 )
        return 1;
      ++*(a1 + 68);
      do
      {
        if ( !*++*(a1 + 68) )
          return 0;
        if ( **(a1 + 68) == 10 )
          ++*(a1 + 92);
      }
      while ( **(a1 + 68) != 42 || *(*(a1 + 68) + 1) != 47 );
      if ( !*++*(a1 + 68) )
        return 0;
      if ( !*++*(a1 + 68) )
        return 0;
    }
  }
  return 1;
}

//----- (0807D926) --------------------------------------------------------
int __cdecl sub_807D926(int a1, char *a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+10h] [ebp-8h]
  char v8; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+14h] [ebp-4h]

  v3 = *++*(a1 + 68) - 34;
  switch ( **(a1 + 68) )
  {
    case '"':
      v8 = 34;
      goto LABEL_37;
    case '\'':
      v8 = 39;
      goto LABEL_37;
    case '?':
      v8 = 63;
      goto LABEL_37;
    case '\\':
      v8 = 92;
      goto LABEL_37;
    case 'a':
      v8 = 7;
      goto LABEL_37;
    case 'b':
      v8 = 8;
      goto LABEL_37;
    case 'f':
      v8 = 12;
      goto LABEL_37;
    case 'n':
      v8 = 10;
      goto LABEL_37;
    case 'r':
      v8 = 13;
      goto LABEL_37;
    case 't':
      v8 = 9;
      goto LABEL_37;
    case 'v':
      v8 = 11;
      goto LABEL_37;
    case 'x':
      ++*(a1 + 68);
      v4 = 0;
      v6 = 0;
      break;
    default:
      if ( **(a1 + 68) <= 47 || **(a1 + 68) > 57 )
        sub_807D6B4(a1, "unknown escape char", v3);
      v5 = 0;
      v7 = 0;
      while ( 1 )
      {
        v11 = **(a1 + 68);
        if ( v11 <= 47 || v11 > 57 )
          break;
        v7 = v11 - 48 + 10 * v7;
        ++v5;
        ++*(a1 + 68);
      }
      --*(a1 + 68);
      if ( v7 > 255 )
      {
        sub_807D71D(a1, "too large value in escape character");
        LOBYTE(v7) = -1;
      }
      v8 = v7;
      goto LABEL_37;
  }
  while ( 1 )
  {
    v9 = **(a1 + 68);
    if ( v9 > 47 && v9 <= 57 )
    {
      v10 = v9 - 48;
      goto LABEL_23;
    }
    if ( v9 > 64 && v9 <= 90 )
    {
      v10 = v9 - 55;
      goto LABEL_23;
    }
    if ( v9 <= 96 || v9 > 122 )
      break;
    v10 = v9 - 87;
LABEL_23:
    v6 = v10 + 16 * v6;
    ++v4;
    ++*(a1 + 68);
  }
  --*(a1 + 68);
  if ( v6 > 255 )
  {
    sub_807D71D(a1, "too large value in escape character", v3);
    LOBYTE(v6) = -1;
  }
  v8 = v6;
LABEL_37:
  ++*(a1 + 68);
  *a2 = v8;
  return 1;
}

//----- (0807DB3D) --------------------------------------------------------
int __cdecl sub_807DB3D(_DWORD *a1, int a2, int a3)
{
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]

  if ( a3 == 34 )
    *(a2 + 1024) = 1;
  else
    *(a2 + 1024) = 2;
  *a2 = *a1[17]++;
  v7 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v7 > 1021 )
        {
          sub_807D6B4(a1, "string longer than MAX_TOKEN = %d", 1024);
          return 0;
        }
        if ( *a1[17] != 92 || (a1[26] & 8) != 0 )
          break;
        if ( !sub_807D926(a1, (a2 + v7)) )
        {
          *(v7 + a2) = 0;
          return 0;
        }
        ++v7;
      }
      if ( *a1[17] == a3 )
        break;
      if ( !*a1[17] )
      {
        *(v7 + a2) = 0;
        sub_807D6B4(a1, "missing trailing quote");
        return 0;
      }
      if ( *a1[17] == 10 )
      {
        *(v7 + a2) = 0;
        sub_807D6B4(a1, "newline inside string %s", a2);
        return 0;
      }
      *(a2 + v7++) = *a1[17]++;
    }
    ++a1[17];
    if ( (a1[26] & 4) != 0 )
      break;
    v5 = a1[17];
    v6 = a1[23];
    if ( !sub_807D7D6(a1) )
    {
      a1[17] = v5;
      a1[23] = v6;
      break;
    }
    if ( *a1[17] != a3 )
    {
      a1[17] = v5;
      a1[23] = v6;
      break;
    }
    ++a1[17];
  }
  *(a2 + v7) = a3;
  v8 = v7 + 1;
  *(v8 + a2) = 0;
  *(a2 + 1028) = v8;
  return 1;
}

//----- (0807DD60) --------------------------------------------------------
int __cdecl sub_807DD60(int a1, int a2)
{
  char v4; // [esp+1Fh] [ebp-9h]
  int v5; // [esp+20h] [ebp-8h]

  v5 = 0;
  *(a2 + 1024) = 4;
  do
  {
    *(a2 + v5) = *(*(a1 + 68))++;
    if ( ++v5 > 1023 )
    {
      sub_807D6B4(a1, "name longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v4 = **(a1 + 68);
  }
  while ( v4 > 96 && v4 <= 122 || v4 > 64 && v4 <= 90 || v4 > 47 && v4 <= 57 || v4 == 95 );
  *(v5 + a2) = 0;
  *(a2 + 1028) = v5;
  return 1;
}

//----- (0807DE20) --------------------------------------------------------
int __cdecl sub_807DE20(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4)
{
  __int64 v4; // rax
  int v6; // [esp+Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp+8h]
  _BYTE *j; // [esp+20h] [ebp+8h]
  _BYTE *k; // [esp+20h] [ebp+8h]

  v6 = 0;
  *a3 = 0;
  *a4 = 0;
  *(a4 + 1) = 0;
  *(a4 + 2) = 0;
  if ( (a2 & 0x800) != 0 )
  {
    while ( *a1 )
    {
      LODWORD(v4) = a1;
      if ( *a1 == 46 )
      {
        if ( v6 )
          return v4;
        v6 = 10;
        ++a1;
      }
      if ( v6 )
      {
        *a4 = (*a1 - 48) / v6 + *a4;
        v6 *= 10;
      }
      else
      {
        *a4 = *a4 * 10.0 + (*a1 - 48);
      }
      ++a1;
    }
    v4 = *a4;
    *a3 = v4;
  }
  else if ( (a2 & 8) != 0 )
  {
    while ( *a1 )
      *a3 = *a1++ + 10 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = *a3;
  }
  else if ( (a2 & 0x100) != 0 )
  {
    for ( i = a1 + 2; *i; ++i )
    {
      *a3 *= 16;
      if ( *i <= 96 || *i > 102 )
      {
        if ( *i <= 64 || *i > 70 )
          *a3 = *a3 + *i - 48;
        else
          *a3 = *a3 + *i - 55;
      }
      else
      {
        *a3 = *a3 + *i - 87;
      }
    }
    LODWORD(v4) = *a3;
    *a4 = *a3;
  }
  else if ( (a2 & 0x200) != 0 )
  {
    for ( j = a1 + 1; *j; ++j )
      *a3 = *j + 8 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = *a3;
  }
  else
  {
    LODWORD(v4) = a2 & 0x400;
    if ( (a2 & 0x400) != 0 )
    {
      for ( k = a1 + 2; *k; ++k )
        *a3 = *k + 2 * *a3 - 48;
      LODWORD(v4) = *a3;
      *a4 = *a3;
    }
  }
  return v4;
}

//----- (0807E0D4) --------------------------------------------------------
int __cdecl sub_807E0D4(int a1, int a2)
{
  int v2; // edx
  char i; // [esp+23h] [ebp-15h]
  char j; // [esp+23h] [ebp-15h]
  char v7; // [esp+23h] [ebp-15h]
  char v8; // [esp+23h] [ebp-15h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int k; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v12 = 0;
  *(a2 + 1024) = 3;
  if ( **(a1 + 68) == 48 && (*(*(a1 + 68) + 1) == 120 || *(*(a1 + 68) + 1) == 88) )
  {
    *a2 = *(*(a1 + 68))++;
    *(a2 + 1) = *(*(a1 + 68))++;
    v12 = 2;
    for ( i = **(a1 + 68); i > 47 && i <= 57 || i > 96 && i <= 102 || i > 64 && i <= 65; i = **(a1 + 68) )
    {
      *(a2 + v12) = *(*(a1 + 68))++;
      if ( ++v12 > 1023 )
      {
        sub_807D6B4(a1, "hexadecimal number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(a2 + 1028) |= 0x100u;
    goto LABEL_41;
  }
  if ( **(a1 + 68) == 48 && (*(*(a1 + 68) + 1) == 98 || *(*(a1 + 68) + 1) == 66) )
  {
    *a2 = *(*(a1 + 68))++;
    *(a2 + 1) = *(*(a1 + 68))++;
    v12 = 2;
    for ( j = **(a1 + 68); j == 48 || j == 49; j = **(a1 + 68) )
    {
      *(a2 + v12) = *(*(a1 + 68))++;
      if ( ++v12 > 1023 )
      {
        sub_807D6B4(a1, "binary number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(a2 + 1028) |= 0x400u;
    goto LABEL_41;
  }
  v10 = 0;
  v9 = 0;
  if ( **(a1 + 68) == 48 )
    v10 = 1;
  while ( 1 )
  {
    v7 = **(a1 + 68);
    if ( v7 != 46 )
      break;
    v9 = 1;
LABEL_34:
    *(a2 + v12) = *(*(a1 + 68))++;
    if ( ++v12 > 1022 )
    {
      sub_807D6B4(a1, "number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if ( v7 == 56 || v7 == 57 )
  {
    v10 = 0;
    goto LABEL_34;
  }
  if ( v7 > 47 && v7 <= 57 )
    goto LABEL_34;
  if ( v10 )
    v2 = *(a2 + 1028) | 0x200;
  else
    v2 = *(a2 + 1028) | 8;
  *(a2 + 1028) = v2;
  if ( v9 )
    *(a2 + 1028) |= 0x800u;
LABEL_41:
  for ( k = 0; k <= 1; ++k )
  {
    v8 = **(a1 + 68);
    if ( (v8 == 108 || v8 == 76) && (*(a2 + 1028) & 0x2000) == 0 )
    {
      ++*(a1 + 68);
      *(a2 + 1028) |= 0x2000u;
    }
    else if ( (v8 == 117 || v8 == 85) && (*(a2 + 1028) & 0x4800) == 0 )
    {
      ++*(a1 + 68);
      *(a2 + 1028) |= 0x4000u;
    }
  }
  *(v12 + a2) = 0;
  sub_807DE20(a2, *(a2 + 1028), (a2 + 1032), (a2 + 1036));
  if ( (*(a2 + 1028) & 0x800) == 0 )
    *(a2 + 1028) |= 0x1000u;
  return 1;
}

//----- (0807E624) --------------------------------------------------------
int __cdecl sub_807E624(int a1, char *dest)
{
  int i; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]

  for ( i = *(*(a1 + 112) + 4 * **(a1 + 68)); i; i = *(i + 8) )
  {
    s = *i;
    n = strlen(*i);
    if ( n + *(a1 + 68) <= *(a1 + 72) && !strncmp(*(a1 + 68), s, n) )
    {
      strncpy(dest, s, 0x400u);
      *(a1 + 68) += n;
      *(dest + 256) = 5;
      *(dest + 257) = *(i + 4);
      return 1;
    }
  }
  return 0;
}

//----- (0807E702) --------------------------------------------------------
int __cdecl sub_807E702(int a1, void *src)
{
  int v4; // [esp+10h] [ebp-8h]

  v4 = 0;
  while ( **(a1 + 68) > 32 && **(a1 + 68) != 59 )
  {
    if ( v4 > 1023 )
    {
      sub_807D6B4(a1, "primitive token longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    *(src + v4++) = *(*(a1 + 68))++;
  }
  *(src + v4) = 0;
  memcpy((a1 + 116), src, 0x42Cu);
  return 1;
}

//----- (0807E7AA) --------------------------------------------------------
int __cdecl sub_807E7AA(_DWORD *a1, void *dest)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( a1[25] )
  {
    a1[25] = 0;
    memcpy(dest, a1 + 29, 0x42Cu);
    v3 = 1;
  }
  else
  {
    a1[19] = a1[17];
    a1[24] = a1[23];
    memset(dest, 0, 0x42Cu);
    a1[20] = a1[17];
    *(dest + 262) = a1[17];
    if ( sub_807D7D6(a1) )
    {
      a1[21] = a1[17];
      *(dest + 263) = a1[17];
      *(dest + 264) = a1[23];
      *(dest + 265) = a1[23] - a1[24];
      if ( *a1[17] == 34 )
      {
        if ( !sub_807DB3D(a1, dest, 34) )
          return 0;
      }
      else if ( *a1[17] == 39 )
      {
        if ( !sub_807DB3D(a1, dest, 39) )
          return 0;
      }
      else if ( *a1[17] > 47 && *a1[17] <= 57 || *a1[17] == 46 && *(a1[17] + 1) > 47 && *(a1[17] + 1) <= 57 )
      {
        if ( !sub_807E0D4(a1, dest) )
          return 0;
      }
      else
      {
        if ( (a1[26] & 0x10) != 0 )
          return sub_807E702(a1, dest);
        if ( *a1[17] > 96 && *a1[17] <= 122 || *a1[17] > 64 && *a1[17] <= 90 || *a1[17] == 95 )
        {
          if ( !sub_807DD60(a1, dest) )
            return 0;
        }
        else if ( !sub_807E624(a1, dest) )
        {
          sub_807D6B4(a1, "can't read token");
          return 0;
        }
      }
      memcpy(a1 + 29, dest, 0x42Cu);
      return 1;
    }
    v3 = 0;
  }
  return v3;
}

//----- (0807EAEB) --------------------------------------------------------
int __cdecl sub_807EAEB(_DWORD *a1, int a2, int a3, void *a4)
{
  char dest[1032]; // [esp+30h] [ebp-408h] BYREF

  if ( !sub_807E7AA(a1, a4) )
  {
    sub_807D6B4(a1, "couldn't read expected token");
    return 0;
  }
  if ( *(a4 + 256) != a2 )
  {
    if ( a2 == 1 )
      strcpy(dest, "string");
    if ( a2 == 2 )
      strcpy(dest, "literal");
    if ( a2 == 3 )
      strcpy(dest, "number");
    if ( a2 == 4 )
      strcpy(dest, "name");
    if ( a2 == 5 )
      strcpy(dest, "punctuation");
    sub_807D6B4(a1, "expected a %s, found %s", dest, a4);
    return 0;
  }
  if ( *(a4 + 256) != 3 )
  {
    if ( *(a4 + 256) == 5 )
    {
      if ( a3 < 0 )
      {
        sub_807D6B4(a1, "BUG: wrong punctuation subtype");
        return 0;
      }
      if ( *(a4 + 257) != a3 )
      {
        sub_807D6B4(a1, "expected %s, found %s", *(a1[27] + 12 * a3), *(a1[27] + 12 * a3 + 4));
        return 0;
      }
    }
    return 1;
  }
  if ( (a3 & *(a4 + 257)) == a3 )
    return 1;
  if ( (a3 & 8) != 0 )
    strcpy(dest, "decimal");
  if ( (a3 & 0x100) != 0 )
    strcpy(dest, "hex");
  if ( (a3 & 0x200) != 0 )
    strcpy(dest, "octal");
  if ( (a3 & 0x400) != 0 )
    strcpy(dest, "binary");
  if ( (a3 & 0x2000) != 0 )
    strcat(dest, " long");
  if ( (a3 & 0x4000) != 0 )
    strcat(dest, " unsigned");
  if ( (a3 & 0x800) != 0 )
    strcat(dest, " float");
  if ( (a3 & 0x1000) != 0 )
    strcat(dest, " integer");
  sub_807D6B4(a1, "expected %s, found %s", dest, a4);
  return 0;
}

//----- (0807EE15) --------------------------------------------------------
int __cdecl sub_807EE15(_DWORD *a1, void *dest)
{
  if ( sub_807E7AA(a1, dest) )
    return 1;
  sub_807D6B4(a1, "couldn't read expected token");
  return 0;
}

//----- (0807F01D) --------------------------------------------------------
char *__cdecl sub_807F01D(char *dest)
{
  char *result; // eax

  if ( *dest == 34 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 34 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (0807F2B0) --------------------------------------------------------
_BOOL4 __cdecl sub_807F2B0(int a1)
{
  return *(a1 + 68) >= *(a1 + 72);
}

//----- (0807F353) --------------------------------------------------------
int *__cdecl sub_807F353(char *src)
{
  int *s; // [esp+24h] [ebp-64h]
  unsigned int v4; // [esp+2Ch] [ebp-5Ch]
  char v5[76]; // [esp+30h] [ebp-58h] BYREF
  int v6[3]; // [esp+7Ch] [ebp-Ch] BYREF

  if ( byte_8489A20 )
    Com_sprintf(v5, 0x40u, "%s/%s", &byte_8489A20, src);
  else
    Com_sprintf(v5, 0x40u, "%s", src);
  v4 = sub_8065D85(v5, v6, 0);
  if ( !v6[0] )
    return 0;
  s = sub_8077FA7(v4 + 1189);
  memset(s, 0, 0x4A4u);
  strcpy(s, src);
  s[16] = (s + 297);
  *(s[16] + v4) = 0;
  s[22] = v4;
  s[17] = s[16];
  s[19] = s[16];
  s[18] = s[16] + v4;
  s[25] = 0;
  s[23] = 1;
  s[24] = 1;
  sub_807D786(s, 0);
  sub_8062853(s[16], v4, v6[0]);
  FS_FCloseFile(v6[0]);
  s[22] = sub_8085575(s[16]);
  return s;
}

//----- (0807F4F1) --------------------------------------------------------
_DWORD *__cdecl sub_807F4F1(void *a1, size_t n, char *src)
{
  _DWORD *s; // [esp+10h] [ebp-8h]

  s = sub_8077FA7(n + 1189);
  memset(s, 0, 0x4A4u);
  strcpy(s, src);
  s[16] = s + 297;
  *(s[16] + n) = 0;
  s[22] = n;
  s[17] = s[16];
  s[19] = s[16];
  s[18] = s[16] + n;
  s[25] = 0;
  s[23] = 1;
  s[24] = 1;
  sub_807D786(s, 0);
  memcpy(s[16], a1, n);
  return s;
}

//----- (0807F5D9) --------------------------------------------------------
void __cdecl sub_807F5D9(int a1)
{
  if ( *(a1 + 112) )
    sub_8078050(*(a1 + 112));
  sub_8078050(a1);
}

//----- (0807F603) --------------------------------------------------------
int __cdecl sub_807F603(char *format)
{
  return Com_sprintf(&byte_8489A20, 0x40u, format);
}

//----- (0807F628) --------------------------------------------------------
_DWORD *__cdecl sub_807F628(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  result = a1;
  a1[3] = 271733878;
  return result;
}

//----- (0807F668) --------------------------------------------------------
void *__cdecl sub_807F668(int a1, void *src, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (*(a1 + 16) >> 3) & 0x3F;
  *(a1 + 16) += 8 * a3;
  if ( *(a1 + 16) < (8 * a3) )
    ++*(a1 + 20);
  *(a1 + 20) += a3 >> 29;
  if ( a3 < (64 - v4) )
  {
    i = 0;
  }
  else
  {
    sub_80C835C((a1 + v4 + 24), src, 64 - v4);
    sub_807F825(a1, a1 + 24);
    for ( i = 64 - v4; i + 63 < a3; i += 64 )
      sub_807F825(a1, src + i);
    v4 = 0;
  }
  return sub_80C835C((a1 + v4 + 24), src + i, a3 - i);
}

//----- (0807F764) --------------------------------------------------------
void *__cdecl sub_807F764(int a1, void *s)
{
  int v3; // [esp+14h] [ebp-14h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]
  char src[8]; // [esp+20h] [ebp-8h] BYREF

  sub_807FF31(src, s + 16, 8u);
  v4 = (*(s + 4) >> 3) & 0x3F;
  if ( v4 > 0x37 )
    v3 = 120 - v4;
  else
    v3 = 56 - v4;
  sub_807F668(s, &unk_80F0260, v3);
  sub_807F668(s, src, 8);
  sub_807FF31(a1, s, 0x10u);
  return sub_80C837D(s, 0, 0x58u);
}

//----- (0807F825) --------------------------------------------------------
void *__cdecl sub_807F825(int *a1, int a2)
{
  int s; // [esp+10h] [ebp-58h] BYREF
  int v4; // [esp+14h] [ebp-54h]
  int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+24h] [ebp-44h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+2Ch] [ebp-3Ch]
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+38h] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-2Ch]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+44h] [ebp-24h]
  int v17; // [esp+48h] [ebp-20h]
  int v18; // [esp+4Ch] [ebp-1Ch]
  int v19; // [esp+50h] [ebp-18h]
  int v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  v22 = *a1;
  v21 = a1[1];
  v20 = a1[2];
  v19 = a1[3];
  sub_807FFD9(&s, a2, 0x40u);
  v22 += s + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v4 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v5 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v6 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v7 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v9 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v10 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v11 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v13 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v14 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v15 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v16 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v17 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += s + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v7 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v11 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v15 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v4 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v12 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v16 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v5 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v9 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v13 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v17 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v6 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v10 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v14 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v18 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += s + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v11 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v7 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v15 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v5 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v13 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v9 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v17 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v4 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v8 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v16 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v6 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v14 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v10 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  *a1 += v22;
  a1[1] += v21;
  a1[2] += v20;
  a1[3] += v19;
  return sub_80C837D(&s, 0, 0x40u);
}

//----- (0807FF31) --------------------------------------------------------
unsigned int __cdecl sub_807FF31(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(i + a1) = __PAIR16__(BYTE1(*(a2 + 4 * v5)), *(a2 + 4 * v5));
    *(a1 + i + 2) = BYTE2(*(a2 + 4 * v5));
    *(a1 + i + 3) = HIBYTE(*(a2 + 4 * v5++));
  }
  return result;
}

//----- (0807FFD9) --------------------------------------------------------
unsigned int __cdecl sub_807FFD9(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(a1 + 4 * v5++) = (*(a2 + i + 2) << 16) | *(a2 + i) | (*(a2 + i + 3) << 24);
  }
  return result;
}

//----- (08080055) --------------------------------------------------------
int __cdecl sub_8080055(void *src, int a2)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF

  sub_807F628(s);
  sub_807F668(s, src, a2);
  sub_807F764(v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (080800B1) --------------------------------------------------------
int sub_80800B1(void *a1, int a2, ...)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF
  va_list va; // [esp+A8h] [ebp+10h] BYREF

  va_start(va, a2);
  sub_807F628(s);
  sub_807F668(s, va, 4);
  sub_807F668(s, a1, a2);
  sub_807F764(v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (0808012C) --------------------------------------------------------
int __cdecl MSG_Init(void *s, int a2, int a3)
{
  int result; // eax

  if ( !dword_80F02A0 )
    sub_80837EB();
  memset(s, 0, 0x18u);
  *(s + 1) = a2;
  result = a3;
  *(s + 2) = a3;
  return result;
}
// 80F02A0: using guessed type int dword_80F02A0;

//----- (0808016F) --------------------------------------------------------
int __cdecl sub_808016F(int a1)
{
  int result; // eax

  *(a1 + 16) = 0;
  result = a1;
  *(a1 + 20) = 0;
  return result;
}

//----- (08080188) --------------------------------------------------------
int __cdecl sub_8080188(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]

  result = a1[2] - a1[3];
  if ( result > 3 )
  {
    while ( a3 )
    {
      --a3;
      v4 = a1[5] & 7;
      if ( !v4 )
      {
        a1[5] = 8 * a1[3];
        *(a1[1] + a1[3]++) = 0;
      }
      if ( (a2 & 1) != 0 )
        *((a1[5] >> 3) + a1[1]) |= 1 << v4;
      ++a1[5];
      result = &a2;
      a2 >>= 1;
    }
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (0808024E) --------------------------------------------------------
_DWORD *__cdecl sub_808024E(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1[3] < a1[2] )
  {
    if ( (a1[5] & 7) == 0 )
    {
      a1[5] = 8 * a1[3];
      *(a1[1] + a1[3]++) = 0;
    }
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (080802AB) --------------------------------------------------------
_DWORD *__cdecl sub_80802AB(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+0h] [ebp-10h]

  if ( a1[3] < a1[2] )
  {
    v2 = a1[5] & 7;
    if ( !v2 )
    {
      a1[5] = 8 * a1[3];
      *(a1[1] + a1[3]++) = 0;
    }
    *((a1[5] >> 3) + a1[1]) |= 1 << v2;
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (08080344) --------------------------------------------------------
int __cdecl sub_8080344(_DWORD *a1, int a2)
{
  int i; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v4 = a1[5] & 7;
    if ( !v4 )
      a1[5] = 8 * a1[4]++;
    v5 |= ((*((a1[5]++ >> 3) + a1[1]) >> v4) & 1) << i;
  }
  return v5;
}

//----- (080803C6) --------------------------------------------------------
int __cdecl sub_80803C6(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = a1[5] & 7;
  if ( !v2 )
    a1[5] = 8 * a1[4]++;
  return (*((a1[5]++ >> 3) + a1[1]) >> v2) & 1;
}

//----- (0808041F) --------------------------------------------------------
int __cdecl sub_808041F(unsigned __int8 *a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = a3;
  while ( v5 )
  {
    sub_80773F8(dword_827CE60, *a1, a2, &v4);
    --v5;
    ++a1;
  }
  return (v4 + 7) >> 3;
}

//----- (08080473) --------------------------------------------------------
_BYTE *__cdecl sub_8080473(int a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h] BYREF

  v6 = 8 * a3;
  v4 = a2;
  v5 = 0;
  while ( v5 < v6 )
  {
    sub_807729F(dword_8283E84, &v7, a1, &v5);
    *v4++ = v7;
  }
  return (v4 - a2);
}
// 8283E84: using guessed type int dword_8283E84;

//----- (080804DC) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2)
{
  _DWORD *result; // eax

  if ( a1[3] >= a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(a1[3] + a1[1]) = a2;
    result = a1;
    ++a1[3];
  }
  return result;
}

//----- (08080514) --------------------------------------------------------
int __cdecl MSG_WriteData(int a1, void *src, size_t n)
{
  int result; // eax
  signed int v4; // [esp+14h] [ebp-4h]

  v4 = *(a1 + 12) + n;
  if ( v4 > *(a1 + 8) )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    memcpy((*(a1 + 4) + *(a1 + 12)), src, n);
    result = v4;
    *(a1 + 12) = v4;
  }
  return result;
}

//----- (08080569) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 2;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(a1[1] + a1[3]) = sub_8083869(a2);
    result = v3;
    a1[3] = v3;
  }
  return result;
}

//----- (080805B9) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+4h] [ebp-4h]

  v3 = a1[3] + 4;
  if ( v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(a1[1] + a1[3]) = sub_808387C(a2);
    result = v3;
    a1[3] = v3;
  }
  return result;
}

//----- (08080607) --------------------------------------------------------
int __cdecl sub_8080607(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char v4; // [esp+4h] [ebp-424h]
  char src[1032]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+418h] [ebp-10h]
  int v7; // [esp+41Ch] [ebp-Ch]

  if ( !s )
    return MSG_WriteData(a1, &unk_80E28BA, 1u);
  v7 = strlen(s);
  if ( v7 <= 1023 )
  {
    for ( i = 0; i < v7; ++i )
    {
      v3 = &src[i];
      *v3 = sub_8086C4E(s[i]);
    }
    src[i] = 0;
    result = MSG_WriteData(a1, src, v7 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: MAX_STRING_CHARS", v4);
    result = MSG_WriteData(a1, &unk_80E28BA, 1u);
  }
  return result;
}
// 8080655: variable 'v4' is possibly undefined

//----- (080806DF) --------------------------------------------------------
int __cdecl MSG_WriteBigString(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char src[8200]; // [esp+10h] [ebp-2018h] BYREF
  int i; // [esp+2018h] [ebp-10h]
  int v6; // [esp+201Ch] [ebp-Ch]

  if ( !s )
    return MSG_WriteData(a1, &unk_80E28BA, 1u);
  v6 = strlen(s);
  if ( v6 <= 0x1FFF )
  {
    Q_strncpyz(src, s, 0x2000);
    for ( i = 0; i < v6; ++i )
    {
      v3 = &src[i];
      *v3 = sub_8086C4E(src[i]);
    }
    result = MSG_WriteData(a1, src, v6 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: BIG_INFO_STRING");
    result = MSG_WriteData(a1, &unk_80E28BA, 1u);
  }
  return result;
}

//----- (08080815) --------------------------------------------------------
_DWORD *__cdecl sub_8080815(int a1, float a2)
{
  return MSG_WriteShort(a1, (a2 * 182.04445));
}

//----- (08080857) --------------------------------------------------------
int __cdecl sub_8080857(_DWORD *a1)
{
  if ( a1[4] >= a1[3] )
    return -1;
  return *(a1[1] + a1[4]++);
}

//----- (08080897) --------------------------------------------------------
int __cdecl sub_8080897(_DWORD *a1)
{
  __int16 v1; // ax
  int v4; // [esp+10h] [ebp-8h]

  v4 = a1[4] + 2;
  if ( v4 > a1[3] )
    return -1;
  v1 = sub_8083869(*(a1[1] + a1[4]));
  a1[4] = v4;
  return v1;
}

//----- (080808EC) --------------------------------------------------------
int __cdecl sub_80808EC(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = a1[4] + 4;
  if ( v3 > a1[3] )
    return -1;
  v4 = sub_808387C(*(a1[1] + a1[4]));
  a1[4] = v3;
  return v4;
}

//----- (0808093F) --------------------------------------------------------
void *__cdecl sub_808093F(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FE; ++i )
  {
    v2 = sub_8080857(a1);
    if ( v2 == -1 )
      break;
    if ( !v2 )
      break;
    *(i + 136816224) = sub_8086C4E(v2);
  }
  *(i + 136816224) = 0;
  return &unk_827A660;
}

//----- (08080A16) --------------------------------------------------------
void *__cdecl sub_8080A16(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FE; ++i )
  {
    v2 = sub_8080857(a1);
    if ( v2 == -1 || !v2 || v2 == 10 )
      break;
    if ( v2 == 37 )
      LOBYTE(v2) = 46;
    *(i + 136825440) = sub_8086C4E(v2);
  }
  *(i + 136825440) = 0;
  return &unk_827CA60;
}

//----- (08080A8C) --------------------------------------------------------
long double __cdecl sub_8080A8C(_DWORD *a1)
{
  return sub_8080897(a1) * 0.0054931641;
}

//----- (08080B8D) --------------------------------------------------------
_DWORD *__cdecl sub_8080B8D(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  if ( a3 == a4 )
    return sub_808024E(a1);
  sub_80802AB(a1);
  return sub_8080188(a1, a4 ^ a2, a5);
}

//----- (08080BD1) --------------------------------------------------------
int __cdecl sub_8080BD1(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-4h]

  if ( sub_80803C6(a1) )
    v5 = a2 & dword_80F02C0[a4] ^ sub_8080344(a1, a4);
  else
    v5 = a3;
  return v5;
}

//----- (08080C19) --------------------------------------------------------
int __cdecl sub_8080C19(_DWORD *a1, int a2, int a3, int a4)
{
  return sub_8080188(a1, a3 ^ a2, a4);
}

//----- (08080C3D) --------------------------------------------------------
int __cdecl sub_8080C3D(_DWORD *a1, int a2, int a3)
{
  return a2 & dword_80F02C0[a3] ^ sub_8080344(a1, a3);
}

//----- (08080C6A) --------------------------------------------------------
_DWORD *__cdecl sub_8080C6A(_DWORD *a1, char a2, char a3, char a4)
{
  if ( a3 == a4 )
    return sub_808024E(a1);
  sub_80802AB(a1);
  return MSG_WriteByte(a1, a4 ^ a2);
}

//----- (08080CA8) --------------------------------------------------------
int __cdecl sub_8080CA8(_DWORD *a1, char a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( sub_80803C6(a1) )
    v4 = (a2 ^ sub_8080857(a1));
  else
    v4 = a3;
  return v4;
}

//----- (08080CDE) --------------------------------------------------------
_DWORD *__cdecl sub_8080CDE(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4)
{
  if ( a3 == a4 )
    return sub_808024E(a1);
  sub_80802AB(a1);
  return MSG_WriteShort(a1, a4 ^ a2);
}

//----- (08080D1C) --------------------------------------------------------
int __cdecl sub_8080D1C(_DWORD *a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( sub_80803C6(a1) )
    v4 = (sub_8080897(a1) ^ a2);
  else
    v4 = a3;
  return v4;
}

//----- (08080D54) --------------------------------------------------------
_BYTE *__cdecl sub_8080D54(char *s, int a2, int a3)
{
  _BYTE *result; // eax
  char v4; // [esp+4h] [ebp-24h]
  _BYTE *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v6 = strlen(s);
  if ( v6 >= a3 )
    Com_Printf("WARNING: Reliable command is too long (%i/%i) and will be truncated: '%s'\n", v6);
  if ( !v6 )
    Com_Printf("WARNING: Empty reliable command\n", v4);
  v5 = a2;
  for ( i = 0; i < a3 && s[i]; ++i )
  {
    *v5 = sub_8086C4E(s[i]);
    if ( *v5 == 37 )
      *v5 = 46;
    ++v5;
  }
  if ( i >= a3 )
  {
    result = (a2 + a3 - 1);
    *result = 0;
  }
  else
  {
    result = (a2 + i);
    *(a2 + i) = 0;
  }
  return result;
}
// 8080D9E: variable 'v4' is possibly undefined

//----- (08080E16) --------------------------------------------------------
void *__cdecl sub_8080E16(int a1, void *s)
{
  void *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]

  memset(s, 0, 0x18u);
  *(s + 6) = *(a1 + 216);
  for ( i = 0; i <= 1; ++i )
    *(s + i + 2) = ((*(a1 + 4 * i + 232) * 182.04445) - *(a1 + 4 * i + 76));
  result = (*(a1 + 12) & 0x80000);
  if ( result )
  {
    if ( (*(a1 + 132) & 0x40) != 0 )
    {
      *(s + 5) |= 0x40u;
      *(s + 22) = -127;
    }
    else if ( (*(a1 + 132) & 0x20) != 0 )
    {
      *(s + 5) |= 0x80u;
      *(s + 22) = -127;
    }
    if ( *(a1 + 68) <= 0.0 )
    {
      if ( *(a1 + 68) < 0.0 )
        *(s + 5) |= 0x10u;
    }
    else
    {
      *(s + 5) |= 0x20u;
    }
    if ( *(a1 + 224) != 0.0 )
      *(s + 4) |= 0x10u;
    result = (*(a1 + 12) & 0x10000);
    if ( result )
    {
      result = s;
      *(s + 4) |= 8u;
    }
  }
  return result;
}

//----- (08080FA3) --------------------------------------------------------
int __cdecl sub_8080FA3(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( a1 <= 10 )
  {
    if ( a1 < -10 )
      v3 = 2;
  }
  else
  {
    v3 = 1;
  }
  if ( a2 > 10 )
    return v3 | 4;
  if ( a2 < -10 )
    v3 |= 8u;
  return v3;
}

//----- (08080FE9) --------------------------------------------------------
int __cdecl sub_8080FE9(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 10 )
    return 1;
  if ( a1 < -10 )
    v2 = 2;
  return v2;
}

//----- (08081015) --------------------------------------------------------
_BYTE *__cdecl sub_8081015(char a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax

  if ( (a1 & 1) != 0 )
  {
    *a2 = 127;
  }
  else if ( (a1 & 2) != 0 )
  {
    *a2 = -127;
  }
  else
  {
    *a2 = 0;
  }
  if ( (a1 & 4) != 0 )
  {
    result = a3;
    *a3 = 127;
  }
  else
  {
    result = a3;
    if ( (a1 & 8) != 0 )
      *a3 = -127;
    else
      *a3 = 0;
  }
  return result;
}

//----- (0808106E) --------------------------------------------------------
_BYTE *__cdecl sub_808106E(char a1, _BYTE *a2)
{
  _BYTE *result; // eax

  if ( (a1 & 1) != 0 )
  {
    result = a2;
    *a2 = 127;
  }
  else
  {
    result = a2;
    if ( (a1 & 2) != 0 )
      *a2 = -127;
    else
      *a2 = 0;
  }
  return result;
}

//----- (080814CE) --------------------------------------------------------
_BYTE *__cdecl sub_80814CE(_DWORD *a1, int a2, int a3, int a4)
{
  _BYTE *result; // eax
  int v5; // [esp+10h] [ebp-18h]
  char v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+18h] [ebp-10h]
  char v9; // [esp+1Ch] [ebp-Ch]
  char v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+34h] [ebp+Ch]
  int v12; // [esp+34h] [ebp+Ch]

  *a4 = *a3;
  *(a4 + 4) = *(a3 + 4);
  *(a4 + 8) = *(a3 + 8);
  *(a4 + 12) = *(a3 + 12);
  *(a4 + 16) = *(a3 + 16);
  *(a4 + 20) = *(a3 + 20);
  if ( sub_80803C6(a1) )
    *a4 = *a3 + sub_8080857(a1);
  else
    *a4 = sub_80808EC(a1);
  result = sub_8080C3D(a1, a2, 1);
  if ( result )
  {
    *(a4 + 4) &= 0xFEu;
    if ( sub_8080C3D(a1, a2, 1) )
    {
      *(a4 + 4) |= sub_8080C3D(a1, a2, 1);
      *(a4 + 8) = sub_8080D1C(a1, a2, *(a3 + 8));
      *(a4 + 12) = sub_8080D1C(a1, a2, *(a3 + 12));
      v8 = sub_8080FA3(*(a3 + 20), *(a3 + 21));
      v10 = sub_8080BD1(a1, a2, v8, 4);
      sub_8081015(v10, (a4 + 20), (a4 + 21));
      v12 = *a4 ^ a2;
      *(a4 + 16) = sub_8080D1C(a1, v12, *(a3 + 16));
      *(a4 + 4) &= 1u;
      *(a4 + 4) |= 2 * sub_8080BD1(a1, v12, *(a3 + 4) >> 1, 6);
      *(a4 + 5) = sub_8080CA8(a1, v12, *(a3 + 5));
      v5 = sub_8080FE9(*(a3 + 22));
      v6 = sub_8080BD1(a1, v12, v5, 2);
      sub_808106E(v6, (a4 + 22));
      result = sub_8080BD1(a1, v12, *(a3 + 6), 7);
      *(a4 + 6) = result;
    }
    else
    {
      v11 = *a4 ^ a2;
      *(a4 + 4) |= sub_8080C3D(a1, v11, 1);
      *(a4 + 8) = sub_8080D1C(a1, v11, *(a3 + 8));
      *(a4 + 12) = sub_8080D1C(a1, v11, *(a3 + 12));
      v7 = sub_8080FA3(*(a3 + 20), *(a3 + 21));
      v9 = sub_8080BD1(a1, v11, v7, 4);
      result = sub_8081015(v9, (a4 + 20), (a4 + 21));
    }
  }
  return result;
}

//----- (08081850) --------------------------------------------------------
int *__cdecl sub_8081850(_DWORD *a1, int a2, int a3, int a4)
{
  int *result; // eax
  int v5; // [esp+14h] [ebp-24h]
  int *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  int v8; // [esp+24h] [ebp-14h] BYREF
  float v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  float *v11; // [esp+30h] [ebp-8h]
  _DWORD *v12; // [esp+34h] [ebp-4h]

  v12 = (a2 + *(a4 + 4));
  v11 = (a3 + *(a4 + 4));
  if ( *v12 == *v11 )
    return sub_808024E(a1);
  sub_80802AB(a1);
  if ( !*(a4 + 8) )
  {
    v9 = *v11;
    v10 = v9;
    if ( v9 != 0.0 )
    {
      sub_80802AB(a1);
      if ( v10 == v9 && v10 + 4096 >= 0 && v10 + 4096 <= 0x1FFF )
      {
        sub_808024E(a1);
        v10 += 4096;
        sub_8080188(a1, v10, 5);
        result = MSG_WriteByte(a1, v10 >> 5);
      }
      else
      {
        sub_80802AB(a1);
        result = MSG_WriteLong(a1, *v11);
      }
      return result;
    }
    return sub_808024E(a1);
  }
  if ( *(a4 + 8) == -100 )
  {
    if ( *v11 )
    {
      sub_80802AB(a1);
      return sub_8080815(a1, *v11);
    }
    return sub_808024E(a1);
  }
  if ( !*v11 )
    return sub_808024E(a1);
  sub_80802AB(a1);
  v8 = *v11;
  v5 = *(a4 + 8);
  if ( v5 < 0 )
    v5 = -v5;
  v7 = v5;
  result = (v5 & 7);
  v6 = result;
  if ( (v5 & 7) != 0 )
  {
    sub_8080188(a1, v8, result);
    v7 -= v6;
    result = &v8;
    v8 >>= v6;
  }
  while ( v7 )
  {
    MSG_WriteByte(a1, v8);
    v8 >>= 8;
    result = &v7;
    v7 -= 8;
  }
  return result;
}

//----- (08081A7E) --------------------------------------------------------
_DWORD *__cdecl sub_8081A7E(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *result; // eax
  int j; // [esp+24h] [ebp-4h]
  int i; // [esp+24h] [ebp-4h]

  if ( a4 )
  {
LABEL_7:
    sub_80802AB(a1);
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a5 )
        break;
      sub_8081850(a1, a2, a3, a6 + 12 * i);
    }
  }
  else
  {
    for ( j = 0; j < a5; ++j )
    {
      if ( *(a2 + *(a6 + 12 * j + 4)) != *(a3 + *(a6 + 12 * j + 4)) )
        goto LABEL_7;
    }
    result = sub_808024E(a1);
  }
  return result;
}

//----- (08081B38) --------------------------------------------------------
_DWORD *__cdecl sub_8081B38(_DWORD *a1, int *a2, int *a3, int a4, int a5, int a6, int a7, void (__cdecl *a8)(_DWORD *, int *), int a9)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  char *v12; // [esp+20h] [ebp-8h]
  _DWORD *v13; // [esp+24h] [ebp-4h]
  _DWORD *v14; // [esp+24h] [ebp-4h]

  if ( a3 )
  {
    v12 = 0;
    v13 = 0;
    for ( i = a7; ; i += 12 )
    {
      result = v13;
      if ( v13 >= a5 )
        break;
      if ( *(a2 + *(i + 4)) != *(a3 + *(i + 4)) )
        v12 = v13 + 1;
      v13 = (v13 + 1);
    }
    if ( v12 )
    {
      if ( a9 )
        sub_80802AB(a1);
      sub_8080188(a1, *a3, a6);
      if ( a8 )
        a8(a1, a3);
      sub_808024E(a1);
      sub_80802AB(a1);
      MSG_WriteByte(a1, v12);
      v14 = 0;
      for ( j = a7; ; j += 12 )
      {
        result = v14;
        if ( v14 >= v12 )
          break;
        sub_8081850(a1, a2, a3, j);
        v14 = (v14 + 1);
      }
    }
    else if ( a4 )
    {
      if ( a9 )
        sub_80802AB(a1);
      sub_8080188(a1, *a3, a6);
      if ( a8 )
        a8(a1, a3);
      sub_808024E(a1);
      result = sub_808024E(a1);
    }
  }
  else
  {
    if ( dword_8494A14 && (*(dword_8494A14 + 32) > 1 || *(dword_8494A14 + 32) == -1) )
      Com_Printf("W|%3i: #%-3i remove\n", a1[3]);
    if ( a9 )
      sub_80802AB(a1);
    sub_8080188(a1, *a2, a6);
    if ( a8 )
      a8(a1, 0);
    result = sub_80802AB(a1);
  }
  return result;
}
// 8494A14: using guessed type int dword_8494A14;

//----- (08081D54) --------------------------------------------------------
_DWORD *__cdecl sub_8081D54(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  if ( a2 && *(a2 + 4) == 12 )
    result = sub_80802AB(a1);
  else
    result = sub_808024E(a1);
  return result;
}

//----- (08081D9A) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaEntity(_DWORD *a1, int *a2, int *a3, int a4)
{
  if ( !a3 )
    return sub_8081B38(a1, a2, 0, a4, 60, 10, &off_80E11A0, sub_8081D54, 0);
  if ( a3[1] == 12 )
    return sub_8081B38(a1, a2, a3, a4, 60, 10, &off_80E1480, sub_8081D54, 0);
  return sub_8081B38(a1, a2, a3, a4, 60, 10, &off_80E11A0, sub_8081D54, 0);
}
// 80E11A0: using guessed type char *off_80E11A0;
// 80E1480: using guessed type char *off_80E1480;

//----- (08081E9C) --------------------------------------------------------
_DWORD *__cdecl sub_8081E9C(_DWORD *a1, int *a2, int *a3, int a4)
{
  return sub_8081B38(a1, a2, a3, a4, 68, 10, &off_80E17C0, 0, 0);
}
// 80E17C0: using guessed type char *off_80E17C0;

//----- (08081EF2) --------------------------------------------------------
_DWORD *__cdecl sub_8081EF2(_DWORD *a1, int *a2, int *a3, int a4)
{
  char s[108]; // [esp+30h] [ebp-78h] BYREF
  int v6; // [esp+9Ch] [ebp-Ch]

  v6 = 22;
  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x5Cu);
  }
  return sub_8081B38(a1, a2, a3, a4, v6, 6, &off_80E1C40, 0, 1);
}
// 80E1C40: using guessed type char *off_80E1C40;

//----- (08081F72) --------------------------------------------------------
int __cdecl sub_8081F72(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax
  int v6; // edx
  long double v7; // fst7
  int v8; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+2Ch] [ebp-Ch]
  int *v14; // [esp+30h] [ebp-8h]
  int *v15; // [esp+34h] [ebp-4h]

  v15 = (a2 + a4[1]);
  v14 = (a3 + a4[1]);
  if ( !sub_80803C6(a1) )
  {
    result = v14;
    *v14 = *v15;
    return result;
  }
  if ( a4[2] )
  {
    if ( a4[2] == -100 )
    {
      if ( sub_80803C6(a1) )
      {
        v7 = sub_8080A8C(a1);
        result = v14;
        *v14 = v7;
      }
      else
      {
        result = v14;
        *v14 = 0;
      }
    }
    else
    {
      if ( !sub_80803C6(a1) )
      {
        result = v14;
        *v14 = 0;
        return result;
      }
      v9 = a4[2];
      if ( v9 < 0 )
        v9 = -v9;
      if ( (v9 & 7) != 0 )
        v8 = sub_8080344(a1, v9 & 7);
      else
        v8 = 0;
      v11 = v8;
      for ( i = v9 & 7; i < v9; i += 8 )
        v11 |= sub_8080857(a1) << i;
      result = v11;
      *v14 = v11;
      if ( a5 )
        return Com_Printf("%s:%i ", *a4);
    }
  }
  else
  {
    if ( !sub_80803C6(a1) )
    {
      result = v14;
      *v14 = 0;
      return result;
    }
    if ( !sub_80803C6(a1) )
    {
      v12 = sub_8080344(a1, 5);
      v13 = 32 * sub_8080857(a1) + v12 - 4096;
      result = v14;
      *v14 = v13;
      if ( !a5 )
        return result;
      return Com_Printf("%s:%i ", *a4);
    }
    v6 = sub_80808EC(a1);
    result = v14;
    *v14 = v6;
    if ( a5 )
      result = Com_Printf("%s:%f ", *a4);
  }
  return result;
}

//----- (0808219A) --------------------------------------------------------
int __cdecl sub_808219A(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( sub_80803C6(a1) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a4 )
        break;
      sub_8081F72(a1, a2, a3, (a5 + 12 * i), 0);
    }
  }
  else
  {
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= a4 )
        break;
      *(a3 + *(a5 + 12 * j + 4)) = *(a2 + *(a5 + 12 * j + 4));
    }
  }
  return result;
}

//----- (0808224C) --------------------------------------------------------
int __cdecl sub_808224C(int a1, void *src, void *dest, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]
  int v14; // [esp+34h] [ebp-4h]

  if ( sub_80803C6(a1) == 1 )
  {
    if ( dword_8494A14 && (*(dword_8494A14 + 32) > 1 || *(dword_8494A14 + 32) == -1) )
      Com_Printf("%3i: #%-3i remove\n", *(a1 + 16));
    v8 = 1;
  }
  else if ( sub_80803C6(a1) )
  {
    v12 = sub_8080857(a1);
    if ( v12 > a5 )
      v12 = a5;
    if ( dword_8494A14 && (*(dword_8494A14 + 32) > 1 || *(dword_8494A14 + 32) == -1) )
    {
      v9 = 1;
      Com_Printf("%3i: #%-3i ", *(a1 + 16));
    }
    else
    {
      v9 = 0;
    }
    *dest = a4;
    v13 = 0;
    v10 = a7;
    while ( v13 < v12 )
    {
      sub_8081F72(a1, src, dest, v10, v9);
      ++v13;
      v10 += 3;
    }
    v14 = v12;
    v11 = a7 + 12 * v12;
    while ( v14 < a5 )
    {
      *(dest + *(v11 + 4)) = *(src + *(v11 + 4));
      ++v14;
      v11 += 12;
    }
    v8 = 0;
  }
  else
  {
    memcpy(dest, src, 4 * a5 + 4);
    v8 = 0;
  }
  return v8;
}
// 8494A14: using guessed type int dword_8494A14;

//----- (0808249A) --------------------------------------------------------
int __cdecl sub_808249A(int a1, void *src, void *dest, int a4)
{
  return sub_808224C(a1, src, dest, a4, 68, 10, &off_80E17C0);
}
// 80E17C0: using guessed type char *off_80E17C0;

//----- (080824E0) --------------------------------------------------------
int __cdecl sub_80824E0(int a1, void *src, void *dest, int a4)
{
  char s[108]; // [esp+20h] [ebp-78h] BYREF
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !src )
  {
    src = s;
    memset(s, 0, 0x5Cu);
  }
  return sub_808224C(a1, src, dest, a4, v6, 6, &off_80E1C40);
}
// 80E1C40: using guessed type char *off_80E1C40;

//----- (08082550) --------------------------------------------------------
int __cdecl sub_8082550(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  unsigned int k; // [esp+20h] [ebp-8h]
  int l; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a4 && *(a3 + 124 * i); ++i )
    ;
  sub_8080188(a1, i, 6);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= i )
      break;
    v5 = 0;
    for ( k = 0; k <= 0x1D; ++k )
    {
      if ( *(dword_80F03C4[3 * k] + a2 + 124 * j) != *(dword_80F03C4[3 * k] + a3 + 124 * j) )
        v5 = k;
    }
    sub_8080188(a1, v5, 5);
    for ( l = 0; l <= v5; ++l )
      sub_8081850(a1, a2 + 124 * j, a3 + 124 * j, &(&off_80F03C0)[3 * l]);
  }
  return result;
}
// 80F03C0: using guessed type char *off_80F03C0;

//----- (080826C7) --------------------------------------------------------
void *__cdecl sub_80826C7(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v6 = sub_8080344(a1, 6);
  for ( i = 0; i < v6; ++i )
  {
    v5 = sub_8080344(a1, 5);
    for ( j = 0; j <= v5; ++j )
      sub_8081F72(a1, a2 + 124 * i, a3 + 124 * i, &(&off_80F03C0)[3 * j], 0);
    while ( j <= 0x1D )
    {
      *(dword_80F03C4[3 * j] + a3 + 124 * i) = *(dword_80F03C4[3 * j] + a2 + 124 * i);
      ++j;
    }
  }
  return memset((a3 + 124 * v6), 0, 124 * (a4 - v6));
}
// 80F03C0: using guessed type char *off_80F03C0;

//----- (08082826) --------------------------------------------------------
_DWORD *__cdecl sub_8082826(_DWORD *a1, char *a2, _DWORD *a3)
{
  int v4; // [esp+20h] [ebp-4578h]
  int v5; // [esp+28h] [ebp-4570h]
  int v6; // [esp+2Ch] [ebp-456Ch]
  float v7; // [esp+30h] [ebp-4568h]
  int v8; // [esp+34h] [ebp-4564h]
  int v9; // [esp+34h] [ebp-4564h]
  float *v10; // [esp+3Ch] [ebp-455Ch]
  char **v11; // [esp+44h] [ebp-4554h]
  char **v12; // [esp+44h] [ebp-4554h]
  int v13; // [esp+4Ch] [ebp-454Ch]
  int v14[7]; // [esp+50h] [ebp-4548h]
  int v15; // [esp+6Ch] [ebp-452Ch]
  char s[17684]; // [esp+70h] [ebp-4528h] BYREF
  int v17; // [esp+4584h] [ebp-14h]
  int j; // [esp+4588h] [ebp-10h]
  int i; // [esp+458Ch] [ebp-Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x4504u);
  }
  v17 = 0;
  i = 0;
  v11 = &off_80E2260;
  while ( i < 114 )
  {
    if ( *&v11[1][a2] != *&v11[1][a3] )
      v17 = i + 1;
    ++i;
    v11 += 3;
  }
  MSG_WriteByte(a1, v17);
  i = 0;
  v12 = &off_80E2260;
  while ( i < v17 )
  {
    v10 = &v12[1][a3];
    if ( *&v12[1][a2] == *v10 )
      goto LABEL_11;
    sub_80802AB(a1);
    if ( v12[2] )
    {
      if ( v12[2] == -100 )
      {
        if ( !*v10 )
        {
LABEL_11:
          sub_808024E(a1);
          goto LABEL_27;
        }
        sub_80802AB(a1);
        sub_8080815(a1, *v10);
      }
      else
      {
        v7 = *v10;
        v4 = v12[2];
        if ( v4 < 0 )
          v4 = -v4;
        v6 = v4;
        v5 = v4 & 7;
        if ( (v4 & 7) != 0 )
        {
          sub_8080188(a1, SLODWORD(v7), v5);
          v6 = v4 - v5;
          SLODWORD(v7) >>= v5;
        }
        while ( v6 )
        {
          MSG_WriteByte(a1, SLOBYTE(v7));
          SLODWORD(v7) >>= 8;
          v6 -= 8;
        }
      }
    }
    else
    {
      v8 = *v10;
      if ( v8 == *v10 && v8 + 4096 >= 0 && v8 + 4096 <= 0x1FFF )
      {
        sub_808024E(a1);
        v9 = v8 + 4096;
        sub_8080188(a1, v9, 5);
        MSG_WriteByte(a1, v9 >> 5);
      }
      else
      {
        sub_80802AB(a1);
        MSG_WriteLong(a1, *v10);
      }
    }
LABEL_27:
    ++i;
    v12 += 3;
  }
  v15 = 0;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a3[i + 71] != *&a2[4 * i + 284] )
      v15 |= 1 << i;
  }
  if ( v15 )
  {
    sub_80802AB(a1);
    sub_8080188(a1, v15, 6);
    if ( (v15 & 1) != 0 )
      MSG_WriteShort(a1, a3[71]);
    if ( (v15 & 2) != 0 )
      MSG_WriteShort(a1, a3[72]);
    if ( (v15 & 4) != 0 )
      MSG_WriteShort(a1, a3[73]);
    if ( (v15 & 8) != 0 )
      sub_8080188(a1, a3[74], 6);
    if ( (v15 & 0x10) != 0 )
      MSG_WriteShort(a1, a3[75]);
    if ( (v15 & 0x20) != 0 )
      MSG_WriteByte(a1, a3[76]);
  }
  else
  {
    sub_808024E(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v14[j] = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 77 + i] != *&a2[64 * j + 308 + 4 * i] )
        v14[j] |= 1 << i;
    }
  }
  if ( v14[0] || v14[1] || v14[2] || v14[3] )
  {
    sub_80802AB(a1);
    for ( j = 0; j <= 3; ++j )
    {
      if ( v14[j] )
      {
        sub_80802AB(a1);
        MSG_WriteShort(a1, v14[j]);
        for ( i = 0; i <= 15; ++i )
        {
          if ( ((v14[j] >> i) & 1) != 0 )
            MSG_WriteShort(a1, a3[16 * j + 77 + i]);
        }
      }
      else
      {
        sub_808024E(a1);
      }
    }
  }
  else
  {
    sub_808024E(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v13 = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 205 + i] != *&a2[64 * j + 820 + 4 * i] )
        v13 |= 1 << i;
    }
    if ( v13 )
    {
      sub_80802AB(a1);
      MSG_WriteShort(a1, v13);
      for ( i = 0; i <= 15; ++i )
      {
        if ( ((v13 >> i) & 1) != 0 )
          MSG_WriteShort(a1, a3[16 * j + 205 + i]);
      }
    }
    else
    {
      sub_808024E(a1);
    }
  }
  if ( !memcmp(a2 + 1592, a3 + 398, 0x1C0u) )
  {
    sub_808024E(a1);
  }
  else
  {
    sub_80802AB(a1);
    for ( i = 0; i <= 15; ++i )
    {
      sub_8080188(a1, a3[7 * i + 398], 3);
      sub_8081A7E(a1, &a2[28 * i + 1592], &a3[7 * i + 398], 0, 6, &off_80F0360);
    }
  }
  if ( !memcmp(a2 + 2040, a3 + 510, 0x3D08u) )
    return sub_808024E(a1);
  sub_80802AB(a1);
  sub_8082550(a1, (a2 + 9852), (a3 + 2463), 63);
  return sub_8082550(a1, (a2 + 2040), (a3 + 510), 63);
}
// 80E2260: using guessed type char *off_80E2260;
// 80F0360: using guessed type char *off_80F0360;

//----- (080830ED) --------------------------------------------------------
int __cdecl sub_80830ED(int a1, char *a2, char *a3)
{
  int v3; // eax
  int v4; // eax
  long double v5; // fst7
  int v6; // eax
  int v7; // ebx
  int v8; // ebx
  char *v9; // ebx
  int result; // eax
  int v11; // [esp+2Ch] [ebp-457Ch]
  int v12; // [esp+30h] [ebp-4578h]
  unsigned int v13; // [esp+34h] [ebp-4574h]
  char *v14; // [esp+38h] [ebp-4570h]
  char *v15; // [esp+3Ch] [ebp-456Ch]
  char s[17692]; // [esp+40h] [ebp-4568h] BYREF
  int v17; // [esp+455Ch] [ebp-4Ch]
  int v18; // [esp+4560h] [ebp-48h]
  unsigned int v19; // [esp+4564h] [ebp-44h]
  int v20; // [esp+4568h] [ebp-40h]
  float *v21; // [esp+456Ch] [ebp-3Ch]
  char *v22; // [esp+4570h] [ebp-38h]
  int v23; // [esp+4574h] [ebp-34h]
  int v24; // [esp+4578h] [ebp-30h]
  char **v25; // [esp+457Ch] [ebp-2Ch]
  int v26; // [esp+4580h] [ebp-28h]
  int v27; // [esp+4584h] [ebp-24h]
  int i; // [esp+4588h] [ebp-20h]
  int j; // [esp+458Ch] [ebp-1Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 17668u);
  }
  v15 = a3;
  v14 = a2;
  v13 = 17668;
  if ( (a3 & 4) != 0 )
  {
    *a3 = *a2;
    v15 = a3 + 4;
    v14 = a2 + 4;
    v13 = 17664;
  }
  qmemcpy(v15, v14, 4 * (v13 >> 2));
  if ( dword_8494A14 && (*(dword_8494A14 + 32) > 1 || *(dword_8494A14 + 32) == -2) )
  {
    v23 = 1;
    Com_Printf("%3i: playerstate ", *(a1 + 16));
  }
  else
  {
    v23 = 0;
  }
  v24 = 114;
  v27 = sub_8080857(a1);
  j = 0;
  v25 = &off_80E2260;
  while ( j < v27 )
  {
    v22 = &v25[1][a2];
    v21 = &v25[1][a3];
    if ( !sub_80803C6(a1) )
    {
      *v21 = *v22;
      goto LABEL_34;
    }
    if ( v25[2] )
    {
      if ( v25[2] == -100 )
      {
        if ( sub_80803C6(a1) )
        {
          v5 = sub_8080A8C(a1);
          *v21 = v5;
        }
        else
        {
          *v21 = 0.0;
        }
      }
      else
      {
        v19 = v25[2] >> 31;
        v12 = v25[2];
        if ( v19 )
          v12 = -v12;
        v26 = v12;
        v18 = v12 & 7;
        if ( (v12 & 7) != 0 )
          v11 = sub_8080344(a1, v18);
        else
          v11 = 0;
        v17 = v11;
        for ( i = v18; i < v26; i += 8 )
        {
          v6 = sub_8080857(a1);
          v17 |= v6 << i;
        }
        *v21 = v17;
        if ( v23 )
          goto LABEL_33;
      }
    }
    else
    {
      if ( !sub_80803C6(a1) )
      {
        v20 = sub_8080344(a1, 5);
        v3 = sub_8080857(a1);
        v20 += 32 * v3;
        v20 -= 4096;
        *v21 = v20;
        if ( !v23 )
          goto LABEL_34;
LABEL_33:
        Com_Printf("%s:%i ", *v25);
        goto LABEL_34;
      }
      v4 = sub_80808EC(a1);
      *v21 = v4;
      if ( v23 )
        Com_Printf("%s:%f ", *v25);
    }
LABEL_34:
    ++j;
    v25 += 3;
  }
  j = v27;
  v25 = &(&off_80E2260)[3 * v27];
  while ( j < v24 )
  {
    v22 = &v25[1][a2];
    v21 = &v25[1][a3];
    *v21 = *v22;
    ++j;
    v25 += 3;
  }
  if ( sub_80803C6(a1) )
  {
    if ( dword_8494A14 && *(dword_8494A14 + 32) == 4 )
      Com_Printf("%s ", "PS_STATS");
    v26 = sub_8080344(a1, 6);
    if ( (v26 & 1) != 0 )
      *(a3 + 71) = sub_8080897(a1);
    if ( (v26 & 2) != 0 )
      *(a3 + 72) = sub_8080897(a1);
    if ( (v26 & 4) != 0 )
      *(a3 + 73) = sub_8080897(a1);
    if ( (v26 & 8) != 0 )
      *(a3 + 74) = sub_8080344(a1, 6);
    if ( (v26 & 0x10) != 0 )
      *(a3 + 75) = sub_8080897(a1);
    if ( (v26 & 0x20) != 0 )
      *(a3 + 76) = sub_8080857(a1);
  }
  if ( sub_80803C6(a1) )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( sub_80803C6(a1) )
      {
        if ( dword_8494A14 && *(dword_8494A14 + 32) == 4 )
          Com_Printf("%s ", "PS_AMMO");
        v26 = sub_8080897(a1);
        for ( j = 0; j <= 15; ++j )
        {
          if ( ((v26 >> j) & 1) != 0 )
          {
            v7 = j + 16 * i;
            *&a3[4 * v7 + 308] = sub_8080897(a1);
          }
        }
      }
    }
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( sub_80803C6(a1) )
    {
      if ( dword_8494A14 && *(dword_8494A14 + 32) == 4 )
        Com_Printf("%s ", "PS_AMMOCLIP");
      v26 = sub_8080897(a1);
      for ( j = 0; j <= 15; ++j )
      {
        if ( ((v26 >> j) & 1) != 0 )
        {
          v8 = j + 16 * i;
          *&a3[4 * v8 + 820] = sub_8080897(a1);
        }
      }
    }
  }
  if ( sub_80803C6(a1) )
  {
    for ( j = 0; j <= 15; ++j )
    {
      v9 = &a3[28 * j + 1592];
      *v9 = sub_8080344(a1, 3);
      sub_808219A(a1, &a2[28 * j + 1592], &a3[28 * j + 1592], 6, &off_80F0360);
    }
  }
  result = sub_80803C6(a1);
  if ( result )
  {
    sub_80826C7(a1, a2 + 9852, a3 + 9852, 63);
    result = sub_80826C7(a1, a2 + 2040, a3 + 2040, 63);
  }
  return result;
}
// 8080344: using guessed type _DWORD __cdecl sub_8080344(_DWORD, _DWORD);
// 80803C6: using guessed type _DWORD __cdecl sub_80803C6(_DWORD);
// 8080857: using guessed type _DWORD __cdecl sub_8080857(_DWORD);
// 8080897: using guessed type _DWORD __cdecl sub_8080897(_DWORD);
// 80808EC: using guessed type _DWORD __cdecl sub_80808EC(_DWORD);
// 8080A8C: using guessed type double __cdecl sub_8080A8C(_DWORD);
// 808219A: using guessed type _DWORD __cdecl sub_808219A(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80826C7: using guessed type _DWORD __cdecl sub_80826C7(_DWORD, _DWORD, _DWORD, _DWORD);
// 80E2260: using guessed type char *off_80E2260;
// 80F0360: using guessed type char *off_80F0360;
// 8494A14: using guessed type int dword_8494A14;

//----- (080837EB) --------------------------------------------------------
int *sub_80837EB()
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  dword_80F02A0 = 1;
  result = sub_807780C(dword_827CE60);
  for ( i = 0; i <= 255; ++i )
  {
    for ( j = 0; j < dword_80F0540[i]; ++j )
    {
      sub_8076FB9(dword_827CE60, i);
      sub_8076FB9(dword_8283E7C, i);
    }
    result = &i;
  }
  return result;
}
// 80F02A0: using guessed type int dword_80F02A0;

//----- (08083869) --------------------------------------------------------
int __cdecl sub_8083869(__int16 a1)
{
  return a1;
}

//----- (0808387C) --------------------------------------------------------
int __cdecl sub_808387C(int a1)
{
  return a1;
}

//----- (08083884) --------------------------------------------------------
void *__cdecl sub_8083884(void **a1)
{
  void *result; // eax
  char v2; // [esp+4h] [ebp-14h]

  if ( *(dword_8489A64 + 32) )
  {
    if ( !dword_80F0948 )
    {
      if ( !*(dword_84897C0 + 32) || *(dword_84898B8 + 32) && *(dword_8489A64 + 32) == 2 )
        dword_80F0948 = 1;
      else
        dword_80F0948 = 2;
      Com_Printf("Net Profiling turned on: %s\n", *&dword_80F093C[4 * dword_80F0948]);
    }
    result = a1;
    if ( !*a1 )
    {
      *a1 = malloc(0x5E0u);
      result = memset(*a1, 0, 0x5E0u);
    }
  }
  else
  {
    if ( dword_80F0948 )
    {
      dword_80F0948 = 0;
      Com_Printf("Net Profiling turned off\n", v2);
    }
    result = a1;
    if ( *a1 )
    {
      free(*a1);
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 808394A: variable 'v2' is possibly undefined
// 80F0948: using guessed type int dword_80F0948;
// 84897C0: using guessed type int dword_84897C0;
// 84898B8: using guessed type int dword_84898B8;
// 8489A64: using guessed type int dword_8489A64;

//----- (08083973) --------------------------------------------------------
int __cdecl sub_8083973(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int *v5; // [esp+0h] [ebp-8h]

  v3 = *(a1 + 720) + 1;
  *(a1 + 720) = v3 / 60;
  *(a1 + 720) = v3 - 60 * *(a1 + 720);
  v5 = (a1 + 12 * *(a1 + 720));
  *v5 = sub_80CA93C();
  v5[1] = a2;
  result = a3;
  v5[2] = a3;
  return result;
}

//----- (080839F9) --------------------------------------------------------
int __cdecl sub_80839F9(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( dword_80F0948 )
  {
    sub_8083973(a1[16399], a2, a3);
    result = *(dword_8489A6C + 32) & 2;
    if ( result )
      result = Com_Printf("%s send%s: %i\n", *&off_80F0940[4 * *a1]);
  }
  return result;
}
// 80F0948: using guessed type int dword_80F0948;
// 8489A6C: using guessed type int dword_8489A6C;

//----- (08083A7A) --------------------------------------------------------
void __cdecl sub_8083A7A(_DWORD *a1, int a2, int a3)
{
  if ( dword_80F0948 )
  {
    sub_8083973(a1[16399] + 752, a2, a3);
    if ( (*(dword_8489A6C + 32) & 2) != 0 )
    {
      if ( a3 )
        Com_Printf("%s recieve%s: %i\n", *&off_80F0940[4 * *a1], " fragment", a2);
      else
        Com_Printf("%s recieve%s: %i\n", *&off_80F0940[4 * *a1], &unk_80E2A8F, a2);
    }
  }
}
// 80F0948: using guessed type int dword_80F0948;
// 8489A6C: using guessed type int dword_8489A6C;

//----- (08083B00) --------------------------------------------------------
_DWORD *__cdecl sub_8083B00(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ebx
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  _DWORD *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v10 = 0;
  v9 = 0;
  v8 = -1;
  v7 = sub_80CA93C();
  v5 = 0;
  v4 = 9999;
  v3 = 0;
  for ( i = 0; i <= 59; ++i )
  {
    if ( a1[3 * i] && sub_80CA93C() <= a1[3 * i] + 1000 )
    {
      ++v10;
      if ( a1[3 * i + 2] )
        v9 = (v9 + 1);
      if ( a1[3 * i] < v7 )
      {
        v8 = i;
        v7 = a1[3 * i];
      }
      v5 += a1[3 * i + 1];
      if ( a1[3 * i + 1] < v4 )
        v4 = a1[3 * i + 1];
      if ( a1[3 * i + 1] > v3 )
        v3 = a1[3 * i + 1];
    }
  }
  if ( v10 )
  {
    if ( v9 )
      a1[185] = 100 * v9 / v10;
    else
      a1[185] = 0;
    a1[186] = v3;
    a1[187] = v4;
    v2 = a1[182] + 100;
    if ( v2 < sub_80CA93C() )
    {
      v6 = sub_80CA93C() - v7;
      if ( v8 != -1 )
      {
        v5 -= a1[3 * v8 + 1];
        --v10;
        if ( a1[3 * v8 + 2] )
          v9 = (v9 - 1);
      }
      if ( v6 > 0 && v10 )
      {
        if ( v5 )
          a1[181] = (v5 / (v6 * 0.001));
        else
          a1[181] = 0;
        a1[182] = sub_80CA93C();
      }
      else
      {
        a1[181] = 0;
      }
    }
    a1[183] = v10;
    result = v9;
    a1[184] = v9;
  }
  else
  {
    a1[181] = 0;
    a1[182] = 0;
    a1[183] = 0;
    a1[184] = 0;
    a1[185] = 0;
    a1[186] = 0;
    result = a1;
    a1[187] = 0;
  }
  return result;
}

//----- (08083E34) --------------------------------------------------------
void sub_8083E34()
{
  if ( dword_80F0948 )
    sub_80959E7(1);
  else
    Com_Printf("Network profiling is not on. Set net_profile to turn on network profiling\n");
}
// 80F0948: using guessed type int dword_80F0948;

//----- (08083E5F) --------------------------------------------------------
void __cdecl sub_8083E5F(unsigned __int16 a1)
{
  char *v1; // eax

  dword_8489A74 = sub_8073114("showpackets", "0", 256);
  dword_8489A68 = sub_8073114("showdrop", "0", 256);
  v1 = sub_8086D78("%i", a1);
  dword_8489A70 = sub_8073114("net_qport", v1, 16);
  dword_8489A64 = sub_8073114("net_profile", "0", 256);
  dword_8489A6C = sub_8073114("net_showprofile", "0", 256);
  dword_8489A60 = sub_8073114("net_lanauthorize", "0", 0);
  sub_8060272("net_dumpprofile", sub_8083E34);
}
// 8489A60: using guessed type int dword_8489A60;
// 8489A64: using guessed type int dword_8489A64;
// 8489A68: using guessed type int dword_8489A68;
// 8489A6C: using guessed type int dword_8489A6C;
// 8489A70: using guessed type int dword_8489A70;
// 8489A74: using guessed type int dword_8489A74;

//----- (08083F57) --------------------------------------------------------
void *__cdecl sub_8083F57(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  memset(s, 0, 0x10040u);
  *s = a1;
  *(s + 2) = a3;
  *(s + 3) = a4;
  *(s + 4) = a5;
  *(s + 5) = a6;
  *(s + 6) = a7;
  *(s + 7) = a8;
  *(s + 8) = 0;
  *(s + 9) = 1;
  return sub_8083884(s + 16399);
}

//----- (08083FD0) --------------------------------------------------------
int *__cdecl sub_8083FD0(int *a1)
{
  int *result; // eax
  int n; // [esp+2Ch] [ebp-5ACh]
  int v3[352]; // [esp+30h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5B0h] [ebp-28h] BYREF
  size_t v5; // [esp+5BCh] [ebp-1Ch]

  sub_8083884(a1 + 16399);
  MSG_Init(s, v3, 1400);
  MSG_WriteLong(s, a1[9] | 0x80000000);
  if ( !*a1 )
    MSG_WriteShort(s, *(dword_8489A70 + 32));
  n = 1300;
  if ( a1[8205] + 1300 > a1[8206] )
    n = a1[8206] - a1[8205];
  MSG_WriteShort(s, a1[8205]);
  MSG_WriteShort(s, n);
  MSG_WriteData(s, a1 + a1[8205] + 32828, n);
  sub_8084CBF(*a1, v5, s[1], a1[2], a1[3], a1[4], a1[5], a1[6]);
  sub_80839F9(a1, v5, 1);
  if ( *(dword_8489A74 + 32) )
    Com_Printf("%s send %4i : s=%i fragment=%i,%i\n", *&off_80F0940[4 * *a1]);
  a1[8205] += n;
  result = a1[8205];
  if ( result == a1[8206] && n != 1300 )
  {
    ++a1[9];
    result = a1;
    a1[8204] = 0;
  }
  return result;
}
// 8080569: using guessed type _DWORD __cdecl sub_8080569(_DWORD, __int16);
// 80805B9: using guessed type _DWORD __cdecl sub_80805B9(_DWORD, _DWORD);
// 8083884: using guessed type _DWORD __cdecl sub_8083884(_DWORD);
// 80839F9: using guessed type _DWORD __cdecl sub_80839F9(_DWORD, _DWORD, _DWORD);
// 8489A70: using guessed type int dword_8489A70;
// 8489A74: using guessed type int dword_8489A74;

//----- (080841CE) --------------------------------------------------------
int *__cdecl sub_80841CE(int a1, size_t n, void *src)
{
  int *result; // eax
  int v4[352]; // [esp+20h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5A0h] [ebp-28h] BYREF
  size_t v6; // [esp+5ACh] [ebp-1Ch]

  if ( n > 0x8000 )
    sub_80704AC(1, &byte_80E2BC0, n);
  *(a1 + 32820) = 0;
  if ( n <= 1299 )
  {
    sub_8083884((a1 + 65596));
    MSG_Init(s, v4, 1400);
    MSG_WriteLong(s, *(a1 + 36));
    ++*(a1 + 36);
    if ( !*a1 )
      MSG_WriteShort(s, *(dword_8489A70 + 32));
    MSG_WriteData(s, src, n);
    sub_8084CBF(*a1, v6, s[1], *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
    sub_80839F9(a1, v6, 0);
    result = dword_8489A74;
    if ( *(dword_8489A74 + 32) )
      result = Com_Printf("%s send %4i : s=%i ack=%i\n", *&off_80F0940[4 * *a1]);
  }
  else
  {
    *(a1 + 32816) = 1;
    *(a1 + 32824) = n;
    sub_80C835C((a1 + 32828), src, n);
    result = sub_8083FD0(a1);
  }
  return result;
}
// 8489A70: using guessed type int dword_8489A70;
// 8489A74: using guessed type int dword_8489A74;

//----- (08084378) --------------------------------------------------------
int __cdecl sub_8084378(int a1, _DWORD *a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+34h] [ebp-4h]

  sub_8083884((a1 + 65596));
  sub_808016F(a2);
  v12 = sub_80808EC(a2);
  if ( (v12 & 0x80000000) != 0 )
  {
    v12 &= 0x7FFFFFFFu;
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  if ( *a1 == 1 )
    sub_8080897(a2);
  if ( v9 )
  {
    v11 = sub_8080897(a2);
    n = sub_8080897(a2);
  }
  else
  {
    v11 = 0;
    n = 0;
  }
  sub_8083A7A(a1, a2[3], v9);
  if ( *(dword_8489A74 + 32) )
  {
    if ( v9 )
      Com_Printf("%s recv %4i : s=%i fragment=%i,%i\n", *&off_80F0940[4 * *a1], a2[3], v12, v11, n);
    else
      Com_Printf("%s recv %4i : s=%i\n", *&off_80F0940[4 * *a1], a2[3], v12);
  }
  if ( v12 > *(a1 + 32) )
  {
    *(a1 + 4) = v12 - *(a1 + 32) - 1;
    if ( *(a1 + 4) > 0 && (*(dword_8489A68 + 32) || *(dword_8489A74 + 32)) )
    {
      v3 = sub_80848F8(*(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
      Com_Printf("%s:Dropped %i packets at %i\n", v3, *(a1 + 4), v12);
    }
    if ( v9 )
    {
      if ( v12 != *(a1 + 40) )
      {
        *(a1 + 40) = v12;
        *(a1 + 44) = 0;
      }
      if ( v11 == *(a1 + 44) )
      {
        if ( n >= 0 && n + a2[4] <= a2[3] && (n + *(a1 + 44)) <= 0x8000 )
        {
          memcpy((a1 + *(a1 + 44) + 48), (a2[1] + a2[4]), n);
          *(a1 + 44) += n;
          if ( n == 1300 )
          {
            v8 = 0;
          }
          else if ( *(a1 + 44) <= a2[2] )
          {
            *a2[1] = sub_8085130(v12);
            memcpy((a2[1] + 4), (a1 + 48), *(a1 + 44));
            a2[3] = *(a1 + 44) + 4;
            *(a1 + 44) = 0;
            sub_808016F(a2);
            sub_80808EC(a2);
            v8 = 1;
          }
          else
          {
            v6 = sub_80848F8(*(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
            Com_Printf("%s:fragmentLength %i > msg->maxsize\n", v6, *(a1 + 44));
            v8 = 0;
          }
        }
        else
        {
          if ( *(dword_8489A68 + 32) || *(dword_8489A74 + 32) )
          {
            v5 = sub_80848F8(*(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
            Com_Printf("%s:illegal fragment length\n", v5);
          }
          v8 = 0;
        }
      }
      else
      {
        if ( *(dword_8489A68 + 32) || *(dword_8489A74 + 32) )
        {
          v4 = sub_80848F8(*(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
          Com_Printf("%s:Dropped a message fragment\n", v4);
        }
        v8 = 0;
      }
    }
    else
    {
      *(a1 + 32) = v12;
      v8 = 1;
    }
  }
  else
  {
    if ( *(dword_8489A68 + 32) || *(dword_8489A74 + 32) )
    {
      v2 = sub_80848F8(*(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
      Com_Printf("%s:Out of order packet %i at %i\n", v2, v12, *(a1 + 32));
    }
    v8 = 0;
  }
  return v8;
}
// 8489A68: using guessed type int dword_8489A68;
// 8489A74: using guessed type int dword_8489A74;

//----- (08084802) --------------------------------------------------------
int __cdecl sub_8084802(int a1, int a2)
{
  if ( *a1 != *a2 )
    return *a1 - *a2;
  switch ( *a1 )
  {
    case 2:
      return 0;
    case 0:
      return *(a1 + 18) - *(a2 + 18);
    case 4:
      return memcmp((a1 + 4), (a2 + 4), 4u);
    case 5:
      return memcmp((a1 + 8), (a2 + 8), 0xAu);
  }
  Com_Printf("NET_CompareBaseAdrSigned: bad address type\n");
  return 0;
}

//----- (080848CB) --------------------------------------------------------
_BOOL4 sub_80848CB(char a1, int a2, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+34h] [ebp+1Ch] BYREF

  va_start(va, a5);
  return sub_8084802(&a1, va) == 0;
}

//----- (080848F8) --------------------------------------------------------
char *__cdecl sub_80848F8(int a1, int a2, int a3, int a4, int a5)
{
  __int16 v5; // ax

  if ( a1 == 2 )
  {
    Com_sprintf(byte_828AEA0, 0x40u, "loopback");
  }
  else
  {
    v5 = sub_808649A(SHIWORD(a5));
    if ( a1 == 4 )
      Com_sprintf(byte_828AEA0, 0x40u, "%i.%i.%i.%i:%i", a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2), v5);
    else
      Com_sprintf(
        byte_828AEA0,
        0x40u,
        "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%i",
        a3,
        BYTE1(a3),
        BYTE2(a3),
        HIBYTE(a3),
        a4,
        BYTE1(a4),
        BYTE2(a4),
        HIBYTE(a4),
        a5,
        BYTE1(a5),
        v5);
  }
  return byte_828AEA0;
}

//----- (080849FE) --------------------------------------------------------
int __cdecl sub_80849FE(int a1, int a2)
{
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+14h] [ebp-4h]

  if ( *a1 != *a2 )
    return *a1 - *a2;
  switch ( *a1 )
  {
    case 2:
      return 0;
    case 4:
      if ( *(a1 + 18) == *(a2 + 18) )
        v4 = memcmp((a1 + 4), (a2 + 4), 4u);
      else
        v4 = *(a1 + 18) - *(a2 + 18);
      break;
    case 5:
      if ( *(a1 + 18) == *(a2 + 18) )
        v4 = memcmp((a1 + 8), (a2 + 8), 0xAu);
      else
        v4 = *(a1 + 18) - *(a2 + 18);
      break;
    default:
      Com_Printf("NET_CompareAdrSigned: bad address type\n", v3);
      v4 = 0;
      break;
  }
  return v4;
}
// 8084AE6: variable 'v3' is possibly undefined

//----- (08084AF7) --------------------------------------------------------
_BOOL4 sub_8084AF7(char a1, int a2, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+34h] [ebp+1Ch] BYREF

  va_start(va, a5);
  return sub_80849FE(&a1, va) == 0;
}

//----- (08084B24) --------------------------------------------------------
int __cdecl sub_8084B24(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 2 || !a1 )
    v2 = 1;
  return v2;
}

//----- (08084B49) --------------------------------------------------------
int __cdecl sub_8084B49(int a1, void *s, int a3)
{
  char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v5 = &unk_8489A80 + 22472 * a1;
  if ( *(v5 + 5617) - *(v5 + 5616) > 16 )
    *(v5 + 5616) = *(v5 + 5617) - 16;
  if ( *(v5 + 5616) >= *(v5 + 5617) )
    return 0;
  v6 = (*(v5 + 5616))++ & 0xF;
  memcpy(*(a3 + 4), &v5[1404 * v6], *&v5[1404 * v6 + 1400]);
  *(a3 + 12) = *&v5[1404 * v6 + 1400];
  memset(s, 0, 0x14u);
  *s = 2;
  return 1;
}

//----- (08084C4C) --------------------------------------------------------
size_t __cdecl sub_8084C4C(int a1, size_t n, void *src)
{
  size_t result; // eax
  char *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = &unk_8489A80 + 22472 * (a1 ^ 1);
  v5 = (*(v4 + 5617))++ & 0xF;
  memcpy(&v4[1404 * v5], src, n);
  result = n;
  *&v4[1404 * v5 + 1400] = n;
  return result;
}

//----- (08084CBF) --------------------------------------------------------
void *__cdecl sub_8084CBF(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8)
{
  void *result; // eax

  result = dword_8489A74;
  if ( *(dword_8489A74 + 32) )
  {
    result = src;
    if ( *src == -1 )
      result = Com_Printf("send packet %4i\n", n);
  }
  if ( a4 == 2 )
    return sub_8084C4C(a1, n, src);
  if ( a4 != 1 )
  {
    if ( a4 )
      result = sub_80CA04B(n, src, a4, a5, a6, a7, a8);
  }
  return result;
}
// 8489A74: using guessed type int dword_8489A74;

//----- (08084D76) --------------------------------------------------------
void *sub_8084D76(int a1, int a2, int a3, int a4, int a5, int a6, char *format, ...)
{
  void *result; // eax
  size_t n; // [esp+2Ch] [ebp-801Ch]
  char s[4]; // [esp+30h] [ebp-8018h] BYREF
  char v10[32776]; // [esp+34h] [ebp-8014h] BYREF
  __gnuc_va_list __varargs; // [esp+803Ch] [ebp-Ch]
  va_list va; // [esp+806Ch] [ebp+24h] BYREF

  va_start(va, format);
  s[0] = -1;
  s[1] = -1;
  s[2] = -1;
  s[3] = -1;
  va_copy(__varargs, va);
  vsprintf(v10, format, va);
  n = strlen(s);
  result = sub_8084CBF(a1, n, s, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    result = sub_8095890(n);
  return result;
}

//----- (08084F14) --------------------------------------------------------
void *__cdecl sub_8084F14(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n)
{
  void *result; // eax
  char v9[4]; // [esp+40h] [ebp-10008h] BYREF
  int v10; // [esp+44h] [ebp-10004h] BYREF

  v9[0] = -1;
  v9[1] = -1;
  v9[2] = -1;
  v9[3] = -1;
  memcpy(&v10, src, n);
  result = sub_8084CBF(a1, n + 4, v9, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    result = sub_8095890(n + 4);
  return result;
}

//----- (08084FC8) --------------------------------------------------------
int __cdecl sub_8084FC8(char *s1, void *s)
{
  __int16 v2; // ax
  int v4; // [esp+18h] [ebp-420h]
  const char *nptr; // [esp+1Ch] [ebp-41Ch]
  char haystack[1036]; // [esp+20h] [ebp-418h] BYREF

  if ( !strcmp(s1, "localhost") )
  {
    memset(s, 0, 0x14u);
    *s = 2;
    v4 = 1;
  }
  else
  {
    Q_strncpyz(haystack, s1, 1024);
    nptr = strstr(haystack, ":");
    if ( nptr )
      *nptr++ = 0;
    if ( sub_80C9E95(haystack, s) )
    {
      if ( *(s + 4) == 0xFF && *(s + 5) == 0xFF && *(s + 6) == 0xFF && *(s + 7) == 0xFF )
      {
        *s = 1;
        v4 = 0;
      }
      else
      {
        if ( nptr )
        {
          v2 = atoi(nptr);
          *(s + 9) = sub_808649A(v2);
        }
        else
        {
          *(s + 9) = sub_808649A(28960);
        }
        v4 = 1;
      }
    }
    else
    {
      *s = 1;
      v4 = 0;
    }
  }
  return v4;
}

//----- (08085130) --------------------------------------------------------
int __cdecl sub_8085130(int a1)
{
  return a1;
}

//----- (08085138) --------------------------------------------------------
void sub_8085138()
{
  ;
}

//----- (0808513D) --------------------------------------------------------
int *sub_808513D()
{
  int *result; // eax

  dword_8494A14 = sub_8073114("cl_shownet", "0", 256);
  result = sub_8073114("cl_language", "0", 1);
  dword_8494A10 = result;
  return result;
}
// 8494A10: using guessed type int dword_8494A10;
// 8494A14: using guessed type int dword_8494A14;

//----- (08085187) --------------------------------------------------------
void sub_8085187()
{
  ;
}

//----- (0808518C) --------------------------------------------------------
void sub_808518C()
{
  ;
}

//----- (08085191) --------------------------------------------------------
void sub_8085191()
{
  ;
}

//----- (08085196) --------------------------------------------------------
void sub_8085196()
{
  ;
}

//----- (0808519B) --------------------------------------------------------
void sub_808519B()
{
  ;
}

//----- (080851A0) --------------------------------------------------------
void sub_80851A0()
{
  ;
}

//----- (080851A5) --------------------------------------------------------
void sub_80851A5()
{
  ;
}

//----- (080851AA) --------------------------------------------------------
int sub_80851AA()
{
  return 0;
}

//----- (080851B4) --------------------------------------------------------
void sub_80851B4()
{
  ;
}

//----- (080851B9) --------------------------------------------------------
int sub_80851B9()
{
  return 0;
}

//----- (080851C3) --------------------------------------------------------
void sub_80851C3()
{
  ;
}

//----- (080851C8) --------------------------------------------------------
void sub_80851C8()
{
  ;
}

//----- (080851D2) --------------------------------------------------------
void sub_80851D2()
{
  ;
}

//----- (080851D7) --------------------------------------------------------
void sub_80851D7()
{
  ;
}

//----- (080851DC) --------------------------------------------------------
void sub_80851DC()
{
  ;
}

//----- (080851E1) --------------------------------------------------------
void sub_80851E1()
{
  ;
}

//----- (080851E6) --------------------------------------------------------
void sub_80851E6()
{
  ;
}

//----- (080851EB) --------------------------------------------------------
int sub_80851EB()
{
  return 1;
}

//----- (080851FC) --------------------------------------------------------
void sub_80851FC()
{
  ;
}

//----- (08085201) --------------------------------------------------------
void sub_8085201()
{
  ;
}

//----- (08085206) --------------------------------------------------------
void sub_8085206()
{
  ;
}

//----- (0808520B) --------------------------------------------------------
void sub_808520B()
{
  ;
}

//----- (0808521C) --------------------------------------------------------
char *__cdecl sub_808521C(char *src)
{
  if ( dword_828B2E0 == 15 )
    sub_80704AC(0, &byte_80E2E40);
  ++dword_828B2E0;
  off_80F4F60 = &dword_80F09A0[279 * dword_828B2E0];
  dword_80F09A0[279 * dword_828B2E0 + 256] = 1;
  *(off_80F4F60 + 257) = 0;
  *(off_80F4F60 + 258) = 1;
  *(off_80F4F60 + 259) = 0;
  return Q_strncpyz(off_80F4F60 + 1052, src, 64);
}
// 828B2E0: using guessed type int dword_828B2E0;

//----- (080852BD) --------------------------------------------------------
_DWORD *sub_80852BD()
{
  _DWORD *result; // eax

  if ( !dword_828B2E0 )
    sub_80704AC(0, &byte_80E2E80);
  --dword_828B2E0;
  result = &dword_80F09A0[279 * dword_828B2E0];
  off_80F4F60 = result;
  return result;
}
// 828B2E0: using guessed type int dword_828B2E0;

//----- (08085301) --------------------------------------------------------
void *sub_8085301()
{
  void *result; // eax

  dword_828B2E0 = 0;
  result = &unk_80F09A0;
  off_80F4F60 = &unk_80F09A0;
  return result;
}
// 828B2E0: using guessed type int dword_828B2E0;

//----- (0808533D) --------------------------------------------------------
int __cdecl sub_808533D(int a1)
{
  int result; // eax

  result = a1;
  *(off_80F4F60 + 259) = a1;
  return result;
}

//----- (08085375) --------------------------------------------------------
void __noreturn sub_8085375(char *format, ...)
{
  char s[32012]; // [esp+20h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D2Ch] [ebp-Ch]
  va_list va; // [esp+7D44h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  sub_80704AC(1, &byte_80E2EA8, off_80F4F60 + 1052, *(off_80F4F60 + 256), s);
}

//----- (080853DD) --------------------------------------------------------
void sub_80853DD(char *format, ...)
{
  char s[32012]; // [esp+10h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D1Ch] [ebp-Ch]
  va_list va; // [esp+7D34h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Printf("File %s, line %i: %s", off_80F4F60 + 1052, *(off_80F4F60 + 256), s);
}

//----- (0808543D) --------------------------------------------------------
int sub_808543D()
{
  int result; // eax

  if ( *(off_80F4F60 + 257) )
    sub_8085375("UngetToken called twice");
  *(off_80F4F60 + 257) = 1;
  result = dword_828B2E8;
  dword_828B2E4 = dword_828B2E8;
  return result;
}
// 828B2E4: using guessed type int dword_828B2E4;
// 828B2E8: using guessed type int dword_828B2E8;

//----- (08085522) --------------------------------------------------------
_BYTE *__cdecl sub_8085522(_BYTE *a1, _DWORD *a2)
{
  int v4; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    v4 = *a1;
    if ( v4 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v4 == 10 )
    {
      ++*(off_80F4F60 + 256);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}

//----- (08085575) --------------------------------------------------------
int __cdecl sub_8085575(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 == 13 || v3 == 10 )
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
      else if ( v3 == 47 && v5[1] == 47 )
      {
        while ( *v5 && *v5 != 10 )
          ++v5;
      }
      else if ( v3 == 47 && v5[1] == 42 )
      {
        while ( *v5 && (*v5 != 42 || v5[1] != 47) )
        {
          if ( *v5 == 10 )
          {
            *v4++ = 10;
            ++v2;
          }
          ++v5;
        }
        if ( *v5 )
          v5 += 2;
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}
// 8085675: conditional instruction was optimized away because of '%var_14.4==0'

//----- (080856B1) --------------------------------------------------------
int sub_80856B1()
{
  return dword_828B2E4;
}
// 828B2E4: using guessed type int dword_828B2E4;

//----- (080856BB) --------------------------------------------------------
void *__cdecl sub_80856BB(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+4h] [ebp-8h]
  _BYTE *i; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v4 = *a1;
  v6 = 0;
  *off_80F4F60 = 0;
  if ( a2 )
  {
    while ( *v4 == 13 || *v4 == 10 )
      ++v4;
  }
  else if ( *v4 == 13 || *v4 == 10 )
  {
    return off_80F4F60;
  }
  dword_828B2E8 = dword_828B2E4;
  dword_828B2E4 = v4;
  while ( *v4 && *v4 != 44 && *v4 != 10 )
  {
    if ( *v4 == 13 )
    {
      ++v4;
    }
    else if ( *v4 == 34 )
    {
      for ( i = v4 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v6 <= 1022 )
            *(off_80F4F60 + v6++) = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v6 <= 1022 )
          *(off_80F4F60 + v6++) = 34;
      }
      v4 = i + 1;
    }
    else
    {
      if ( v6 <= 1022 )
        *(off_80F4F60 + v6++) = *v4;
      ++v4;
    }
  }
  if ( *v4 )
  {
    if ( *v4 != 10 )
      ++v4;
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
  }
  *(off_80F4F60 + v6) = 0;
  return off_80F4F60;
}
// 828B2E4: using guessed type int dword_828B2E4;
// 828B2E8: using guessed type int dword_828B2E8;

//----- (08085836) --------------------------------------------------------
void *__cdecl sub_8085836(char **a1, int a2)
{
  void *v3; // [esp+18h] [ebp-20h]
  signed int j; // [esp+1Ch] [ebp-1Ch]
  signed int n; // [esp+20h] [ebp-18h]
  const char **i; // [esp+24h] [ebp-14h]
  char *v7; // [esp+28h] [ebp-10h]
  char *v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch] BYREF
  int v10; // [esp+30h] [ebp-8h]
  char v11; // [esp+37h] [ebp-1h]

  v11 = 0;
  v9 = 0;
  if ( !a1 )
    sub_80704AC(0, &byte_80E2EEB);
  v7 = *a1;
  v10 = 0;
  *off_80F4F60 = 0;
  if ( v7 )
  {
    *(off_80F4F60 + 261) = *(off_80F4F60 + 256);
    *(off_80F4F60 + 262) = *a1;
    if ( *(off_80F4F60 + 259) )
    {
      v3 = sub_80856BB(a1, a2);
    }
    else
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v7 = sub_8085522(v7, &v9);
          if ( !v7 )
          {
            *a1 = 0;
            return off_80F4F60;
          }
          if ( v9 && !a2 )
          {
            *a1 = v7;
            return off_80F4F60;
          }
          v11 = *v7;
          if ( v11 != 47 || v7[1] != 47 )
            break;
          while ( *v7 && *v7 != 10 )
            ++v7;
        }
        if ( v11 != 47 || v7[1] != 42 )
          break;
        while ( *v7 && (*v7 != 42 || v7[1] != 47) )
        {
          if ( *v7 == 10 )
            ++*(off_80F4F60 + 256);
          ++v7;
        }
        if ( *v7 )
          v7 += 2;
      }
      dword_828B2E8 = dword_828B2E4;
      dword_828B2E4 = v7;
      if ( v11 == 34 )
      {
        v8 = v7 + 1;
        while ( 1 )
        {
          v11 = *v8++;
          if ( v11 == 92 && *v8 == 34 )
          {
            v11 = *v8++;
          }
          else
          {
            if ( v11 == 34 || !v11 )
            {
              *(off_80F4F60 + v10) = 0;
              *a1 = v8;
              return off_80F4F60;
            }
            if ( *v8 == 10 )
              ++*(off_80F4F60 + 256);
          }
          if ( v10 <= 1022 )
            *(off_80F4F60 + v10++) = v11;
        }
      }
      if ( *(off_80F4F60 + 258) )
      {
        do
        {
          if ( v10 <= 1022 )
            *(off_80F4F60 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 32 );
        if ( v10 == 1024 )
          v10 = 0;
        *(off_80F4F60 + v10) = 0;
        *a1 = v7;
        v3 = off_80F4F60;
      }
      else if ( v11 > 47 && v11 <= 57
             || *(off_80F4F60 + 260) && v11 == 45 && v7[1] > 47 && v7[1] <= 57
             || v11 == 46 && v7[1] > 47 && v7[1] <= 57 )
      {
        do
        {
          if ( v10 <= 1022 )
            *(off_80F4F60 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 47 && v11 <= 57 || v11 == 46 );
        if ( v11 == 101 || v11 == 69 )
        {
          if ( v10 <= 1022 )
            *(off_80F4F60 + v10++) = v11;
          v11 = *++v7;
          if ( v11 == 45 || v11 == 43 )
          {
            if ( v10 <= 1022 )
              *(off_80F4F60 + v10++) = v11;
            v11 = *++v7;
          }
          do
          {
            if ( v10 <= 1022 )
              *(off_80F4F60 + v10++) = v11;
            v11 = *++v7;
          }
          while ( v11 > 47 && v11 <= 57 );
        }
        if ( v10 == 1024 )
          v10 = 0;
        *(off_80F4F60 + v10) = 0;
        *a1 = v7;
        v3 = off_80F4F60;
      }
      else if ( v11 > 96 && v11 <= 122 || v11 > 64 && v11 <= 90 || v11 == 95 || v11 == 47 || v11 == 92 )
      {
        do
        {
          if ( v10 <= 1022 )
            *(off_80F4F60 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 96 && v11 <= 122
             || v11 > 64 && v11 <= 90
             || v11 == 95
             || v11 > 47 && v11 <= 57
             || v11 == 47
             || v11 == 92
             || v11 == 58
             || v11 == 46 );
        if ( v10 == 1024 )
          v10 = 0;
        *(off_80F4F60 + v10) = 0;
        *a1 = v7;
        v3 = off_80F4F60;
      }
      else
      {
        for ( i = off_80F0960; ; ++i )
        {
          if ( !*i )
          {
            *off_80F4F60 = *v7;
            *(off_80F4F60 + 1) = 0;
            *a1 = v7 + 1;
            return off_80F4F60;
          }
          n = strlen(*i);
          for ( j = 0; j < n && v7[j] == (*i)[j]; ++j )
            ;
          if ( j == n )
            break;
        }
        memcpy(off_80F4F60, *i, n);
        *(off_80F4F60 + n) = 0;
        *a1 = &v7[n];
        v3 = off_80F4F60;
      }
    }
  }
  else
  {
    *a1 = 0;
    v3 = off_80F4F60;
  }
  return v3;
}
// 80F0960: using guessed type char *off_80F0960[14];
// 828B2E4: using guessed type int dword_828B2E4;
// 828B2E8: using guessed type int dword_828B2E8;

//----- (08085E0B) --------------------------------------------------------
void *__cdecl sub_8085E0B(char **a1)
{
  if ( *(off_80F4F60 + 257) )
  {
    *(off_80F4F60 + 257) = 0;
    *a1 = *(off_80F4F60 + 262);
    *(off_80F4F60 + 256) = *(off_80F4F60 + 261);
  }
  return sub_8085836(a1, 1);
}

//----- (08085E6A) --------------------------------------------------------
void *__cdecl sub_8085E6A(char **a1)
{
  if ( !*(off_80F4F60 + 257) )
    return sub_8085836(a1, 0);
  *(off_80F4F60 + 257) = 0;
  if ( *(off_80F4F60 + 258) )
  {
    *a1 = *(off_80F4F60 + 262);
    *(off_80F4F60 + 256) = *(off_80F4F60 + 261);
    return sub_8085836(a1, 0);
  }
  return off_80F4F60;
}

//----- (08085EE7) --------------------------------------------------------
void __cdecl sub_8085EE7(int a1, char *s2, int a3)
{
  char *s1; // [esp+14h] [ebp-4h]

  s1 = sub_8085E0B(a1);
  if ( strcmp(s1, s2) )
  {
    if ( !a3 )
      sub_8085375("MatchToken: %s != %s", s1, s2);
    sub_80853DD("MatchToken: %s != %s", s1, s2);
  }
}

//----- (08085FBA) --------------------------------------------------------
_BYTE *__cdecl sub_8085FBA(_DWORD *a1)
{
  _BYTE *result; // eax
  int v2; // [esp+0h] [ebp-8h]
  _BYTE *v3; // [esp+4h] [ebp-4h]

  result = *a1;
  v3 = *a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = *v3;
      if ( !*v3 )
        break;
      ++v3;
      if ( v2 == 10 )
      {
        ++*(off_80F4F60 + 256);
        break;
      }
    }
    result = v3;
    *a1 = v3;
  }
  return result;
}

//----- (080860E5) --------------------------------------------------------
void __cdecl sub_80860E5(char **a1, int a2, int a3)
{
  int i; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  sub_8085EE7(a1, "(", 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = sub_8085E0B(a1);
    *(a3 + 4 * i) = atof(nptr);
  }
  sub_8085EE7(a1, ")", 0);
}

//----- (0808616B) --------------------------------------------------------
void __cdecl sub_808616B(char **a1, int a2, int a3, int a4)
{
  int i; // [esp+14h] [ebp-4h]

  sub_8085EE7(a1, "(", 0);
  for ( i = 0; i < a2; ++i )
    sub_80860E5(a1, a3, a4 + 4 * a3 * i);
  sub_8085EE7(a1, ")", 0);
}

//----- (080862D9) --------------------------------------------------------
_BYTE *__cdecl sub_80862D9(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = a1 + 1;
    ++a1;
  }
  return v2;
}

//----- (0808637A) --------------------------------------------------------
char *__cdecl sub_808637A(char *s, size_t maxlen, int a3)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest[72]; // [esp+30h] [ebp-48h] BYREF

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  Q_strncpyz(dest, s, 64);
  return Com_sprintf(s, maxlen, "%s%s", dest, a3);
}

//----- (0808649A) --------------------------------------------------------
int __cdecl sub_808649A(__int16 a1)
{
  return dword_829ED80(a1);
}
// 829ED80: using guessed type int (__cdecl *dword_829ED80)(_DWORD);

//----- (08086556) --------------------------------------------------------
int __cdecl sub_8086556(__int16 a1)
{
  return ((a1 << 8) + HIBYTE(a1));
}

//----- (0808658D) --------------------------------------------------------
int __cdecl sub_808658D(__int16 a1)
{
  return a1;
}

//----- (080865A0) --------------------------------------------------------
int __cdecl sub_80865A0(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + (a1 << 24);
}

//----- (080865FC) --------------------------------------------------------
int __cdecl sub_80865FC(int a1)
{
  return a1;
}

//----- (08086604) --------------------------------------------------------
_DWORD *__userpurge sub_8086604@<eax>(_DWORD *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  LOBYTE(v4) = HIBYTE(a3);
  BYTE1(v4) = BYTE2(a3);
  BYTE2(v4) = BYTE1(a3);
  HIBYTE(v4) = a3;
  LOBYTE(v5) = HIBYTE(a2);
  BYTE1(v5) = BYTE2(a2);
  BYTE2(v5) = BYTE1(a2);
  HIBYTE(v5) = a2;
  *a1 = v4;
  a1[1] = v5;
  return a1;
}

//----- (08086662) --------------------------------------------------------
_DWORD *__userpurge sub_8086662@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (08086686) --------------------------------------------------------
long double __cdecl sub_8086686(int a1)
{
  float v2; // [esp+4h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (080866B9) --------------------------------------------------------
long double __cdecl sub_80866B9(float a1)
{
  return a1;
}

//----- (080866CA) --------------------------------------------------------
void sub_80866CA()
{
  dword_829ED80 = sub_8086556;
  dword_829ED84 = sub_808658D;
  dword_829ED88 = sub_80865A0;
  dword_829ED8C = sub_80865FC;
  dword_829ED90 = sub_8086604;
  dword_829ED94 = sub_8086662;
  dword_829ED98 = sub_8086686;
  dword_829ED9C = sub_80866B9;
}
// 829ED80: using guessed type int (__cdecl *dword_829ED80)(_DWORD);
// 829ED84: using guessed type int dword_829ED84;
// 829ED88: using guessed type int dword_829ED88;
// 829ED8C: using guessed type int dword_829ED8C;
// 829ED90: using guessed type int dword_829ED90;
// 829ED94: using guessed type int dword_829ED94;
// 829ED98: using guessed type int dword_829ED98;
// 829ED9C: using guessed type int dword_829ED9C;

//----- (080867AA) --------------------------------------------------------
_BOOL4 __cdecl sub_80867AA(int a1)
{
  return a1 > 96 && a1 <= 122;
}

//----- (080867F8) --------------------------------------------------------
_BOOL4 __cdecl sub_80867F8(int a1)
{
  return a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90;
}

//----- (0808682D) --------------------------------------------------------
_BOOL4 __cdecl sub_808682D(int a1)
{
  return a1 > 47 && a1 <= 57;
}

//----- (08086854) --------------------------------------------------------
_BOOL4 __cdecl sub_8086854(int a1)
{
  return sub_80867F8(a1) || sub_808682D(a1);
}

//----- (0808691A) --------------------------------------------------------
char *__cdecl Q_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (08086946) --------------------------------------------------------
int __cdecl sub_8086946(char *a1, char *a2, int a3)
{
  int v4; // [esp+8h] [ebp-10h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( sub_80867AA(v7) )
        v7 -= 32;
      if ( sub_80867AA(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (080869EB) --------------------------------------------------------
int __cdecl sub_80869EB(char *a1, char *a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (08086A5A) --------------------------------------------------------
int __cdecl sub_8086A5A(char *a1, char *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( a1 && a2 )
    v3 = sub_8086946(a1, a2, 99999);
  else
    v3 = -1;
  return v3;
}

//----- (08086A97) --------------------------------------------------------
_BYTE *__cdecl sub_8086A97(_BYTE *a1)
{
  _BYTE *i; // [esp+10h] [ebp-8h]

  for ( i = a1; *i; ++i )
    *i = tolower(*i);
  return a1;
}

//----- (08086AD1) --------------------------------------------------------
_BYTE *__cdecl sub_8086AD1(_BYTE *a1)
{
  _BYTE *i; // [esp+10h] [ebp-8h]

  for ( i = a1; *i; ++i )
    *i = toupper(*i);
  return a1;
}

//----- (08086B0B) --------------------------------------------------------
char *__cdecl sub_8086B0B(char *s, int a2, char *src)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = strlen(s);
  if ( v4 >= a2 )
    sub_80704AC(0, &byte_80E3075);
  return Q_strncpyz(&s[v4], src, a2 - v4);
}

//----- (08086B5E) --------------------------------------------------------
int __cdecl sub_8086B5E(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
  {
    if ( a1 && *a1 == 94 && a1[1] && a1[1] != 94 && a1[1] > 47 && a1[1] <= 57 )
    {
      a1 += 2;
    }
    else
    {
      ++v2;
      ++a1;
    }
  }
  return v2;
}

//----- (08086BC6) --------------------------------------------------------
char *__cdecl sub_8086BC6(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (08086C4E) --------------------------------------------------------
int __cdecl sub_8086C4E(char a1)
{
  if ( a1 == 146 )
    return 39;
  if ( a1 >= 0 )
    return a1;
  return 46;
}

//----- (08086C8E) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+2Ch] [ebp+14h] BYREF

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (08086CCC) --------------------------------------------------------
int __cdecl sub_8086CCC(char *a1, char *a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  do
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v6 != v5 )
    {
      if ( sub_80867AA(v6) )
        v6 -= 32;
      if ( sub_80867AA(v5) )
        v5 -= 32;
      if ( v6 != v5 )
        return -1;
    }
  }
  while ( v6 );
  return 0;
}

//----- (08086D56) --------------------------------------------------------
int __cdecl sub_8086D56(char *a1, char *a2)
{
  return sub_8086CCC(a1, a2, 99999);
}

//----- (08086D78) --------------------------------------------------------
char *sub_8086D78(char *format, ...)
{
  char v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+1Ch] [ebp-Ch]
  char *dest; // [esp+20h] [ebp-8h]
  va_list va; // [esp+34h] [ebp+Ch] BYREF

  va_start(va, format);
  v3 = vsnprintf(byte_828B380, 0x7D00u, format, va);
  byte_829307F = 0;
  if ( v3 < 0 || v3 > 31999 )
    sub_80704AC(1, &byte_80E30A0, v2);
  if ( v3 + dword_80F4F64 > 31998 )
    dword_80F4F64 = 0;
  dest = &unk_8293080 + dword_80F4F64;
  memcpy(&unk_8293080 + dword_80F4F64, byte_828B380, v3 + 1);
  dword_80F4F64 += v3 + 1;
  return dest;
}
// 8086DD0: variable 'v2' is possibly undefined
// 80F4F64: using guessed type int dword_80F4F64;
// 829307F: using guessed type char byte_829307F;

//----- (08086E7F) --------------------------------------------------------
void *__cdecl sub_8086E7F(char *s, int a2)
{
  char v3; // [esp+8h] [ebp-2020h]
  char *v5; // [esp+1Ch] [ebp-200Ch]
  _BYTE *v6; // [esp+1Ch] [ebp-200Ch]
  char v7[8200]; // [esp+20h] [ebp-2008h] BYREF
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return &unk_80E30CE;
  if ( strlen(s) > 0x1FFF )
    sub_80704AC(1, &byte_80E30E0, v3);
  dword_80F4F68 ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v5 = v7;
    while ( *s != 92 )
    {
      if ( !*s )
        return &unk_80E30CE;
      *v5++ = *s++;
    }
    *v5 = 0;
    sa = s + 1;
    v6 = &unk_829AD80 + 0x2000 * dword_80F4F68;
    while ( *sa != 92 && *sa )
      *v6++ = *sa++;
    *v6 = 0;
    if ( !sub_8086A5A(a2, v7) )
      return ((dword_80F4F68 << 13) + 136949120);
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return &unk_80E30CE;
}
// 8086EC4: variable 'v3' is possibly undefined
// 80F4F68: using guessed type int dword_80F4F68;

//----- (08087087) --------------------------------------------------------
char *__cdecl sub_8087087(char *s, char *s1)
{
  char *result; // eax
  char v3; // [esp+8h] [ebp-830h]
  char *v4; // [esp+1Ch] [ebp-81Ch]
  char *v5; // [esp+1Ch] [ebp-81Ch]
  char v6; // [esp+20h] [ebp-818h] BYREF
  char s2[1036]; // [esp+420h] [ebp-418h] BYREF
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    sub_80704AC(1, &byte_80E3120, v3);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v4 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      ++s;
      v5 = &v6;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v5++ = *s++;
      }
      *v5 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}
// 80870B1: variable 'v3' is possibly undefined

//----- (080871B9) --------------------------------------------------------
char *__cdecl sub_80871B9(char *s, char *s1)
{
  char *result; // eax
  char *v3; // [esp+1Ch] [ebp-401Ch]
  char *v4; // [esp+1Ch] [ebp-401Ch]
  char v5; // [esp+20h] [ebp-4018h] BYREF
  char s2[8204]; // [esp+2020h] [ebp-2018h] BYREF
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    sub_80704AC(1, &byte_80E3160);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v3 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v3++ = *s++;
      }
      *v3 = 0;
      ++s;
      v4 = &v5;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}

//----- (0808733D) --------------------------------------------------------
char *__cdecl sub_808733D(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // ebx
  char v5; // [esp+4h] [ebp-834h]
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+23h] [ebp-815h]
  int v8; // [esp+28h] [ebp-810h]
  int i; // [esp+2Ch] [ebp-80Ch]
  char v10[1024]; // [esp+30h] [ebp-808h] BYREF
  char src[1032]; // [esp+430h] [ebp-408h] BYREF

  if ( strlen(s) > 0x3FF )
    return Com_Printf(&byte_80E31A0, v5);
  v8 = 0;
  for ( i = 0; i <= 1022; ++i )
  {
    v7 = *(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return Com_Printf(&byte_80E31E0, s1);
  if ( strchr(s1, 59) )
    return Com_Printf(&byte_80E3220, s1);
  if ( strchr(s1, 34) )
    return Com_Printf(&byte_80E3260, s1);
  result = sub_8087087(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x400u, "\\%s\\%s", s1, v10) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x400 )
        result = strcat(s, src);
      else
        result = Com_Printf(&byte_80E3300, s1);
    }
    else
    {
      result = Com_Printf(&byte_80E32A0, v6);
    }
  }
  return result;
}
// 8087360: variable 'v5' is possibly undefined
// 8087503: variable 'v6' is possibly undefined

//----- (08087570) --------------------------------------------------------
void __cdecl sub_8087570(char *s, char *s1, int a3)
{
  size_t v3; // ebx
  char v4; // [esp+23h] [ebp-4015h]
  int v5; // [esp+28h] [ebp-4010h]
  int i; // [esp+2Ch] [ebp-400Ch]
  char v7[8192]; // [esp+30h] [ebp-4008h] BYREF
  char src[8200]; // [esp+2030h] [ebp-2008h] BYREF

  if ( strlen(s) <= 0x1FFF )
  {
    v5 = 0;
    for ( i = 0; i <= 8190; ++i )
    {
      v4 = *(a3 + i);
      if ( !v4 )
        break;
      if ( v4 != 92 && v4 != 59 && v4 != 34 )
        v7[v5++] = v4;
    }
    v7[v5] = 0;
    if ( strchr(s1, 92) )
    {
      Com_Printf(&byte_80E31E0, s1, a3);
    }
    else if ( strchr(s1, 59) )
    {
      Com_Printf(&byte_80E3220, s1, a3);
    }
    else if ( strchr(s1, 34) )
    {
      Com_Printf(&byte_80E3260, s1, a3);
    }
    else
    {
      sub_80871B9(s, s1);
      if ( v7[0] )
      {
        if ( Com_sprintf(src, 0x2000u, "\\%s\\%s", s1, v7) > 0 )
        {
          v3 = strlen(src);
          if ( strlen(s) + v3 <= 0x2000 )
            strcat(s, src);
          else
            Com_Printf(&byte_80E3360, s1, a3, s);
        }
        else
        {
          Com_Printf(&byte_80E32A0);
        }
      }
    }
  }
  else
  {
    Com_Printf(&byte_80E31A0);
  }
}

//----- (080879CA) --------------------------------------------------------
long double __cdecl sub_80879CA(float a1)
{
  return (2.0 - sub_8087DCE(a1)) * a1;
}

//----- (08087A07) --------------------------------------------------------
void __cdecl sub_8087A07(int a1, int a2, float a3, float a4, float a5)
{
  int v5[4]; // [esp+10h] [ebp-38h] BYREF
  float v6[7]; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    v7 = sub_80879CA(a3);
    v5[0] = 0;
    v5[1] = a2;
    *&v5[2] = v7 * a4;
    sub_80674AD(v5, 0, v6, 0);
    v7 = v7 * a5;
    *a1 = v6[0] * v7 + *a1;
    *(a1 + 4) = v6[1] * v7 + *(a1 + 4);
    *(a1 + 8) = v6[2] * v7 + *(a1 + 8);
  }
}

//----- (08087D42) --------------------------------------------------------
int sub_8087D42()
{
  return 46;
}

//----- (08087DCE) --------------------------------------------------------
long double __cdecl sub_8087DCE(float a1)
{
  return fabs(a1);
}

//----- (08087DE8) --------------------------------------------------------
char *sub_8087DE8()
{
  int v1; // [esp+1Ch] [ebp-5Ch]
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  char v3[4]; // [esp+64h] [ebp-14h]
  int v4; // [esp+68h] [ebp-10h]
  char *v5; // [esp+6Ch] [ebp-Ch]

  if ( !*(dword_84897C0 + 32) )
    return 0;
  if ( sub_805FF1E() > 1 )
  {
    *v3 = sub_805FF28(1u);
    v4 = 0;
    v5 = svs_clients;
    while ( v4 < *(dword_8494A64 + 32) )
    {
      if ( *v5 )
      {
        if ( !sub_8086A5A(v5 + 68164, *v3) )
          return v5;
        Q_strncpyz(dest, v5 + 68164, 64);
        sub_8086BC6(dest);
        if ( !sub_8086A5A(dest, *v3) )
          return v5;
      }
      ++v4;
      v5 += 700596;
    }
    Com_Printf("Player %s is not on the server\n", *v3);
    v1 = 0;
  }
  else
  {
    Com_Printf("No player specified.\n");
    v1 = 0;
  }
  return v1;
}
// 84897C0: using guessed type int dword_84897C0;
// 8494A64: using guessed type int dword_8494A64;

//----- (08087EFF) --------------------------------------------------------
char *sub_8087EFF()
{
  char *v1; // [esp+14h] [ebp-14h]
  const char *nptr; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(dword_84897C0 + 32) )
    return 0;
  if ( sub_805FF1E() > 1 )
  {
    nptr = sub_805FF28(1u);
    for ( i = 0; nptr[i]; ++i )
    {
      if ( nptr[i] <= 47 || nptr[i] > 57 )
      {
        Com_Printf("Bad slot number: %s\n", nptr);
        return 0;
      }
    }
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < *(dword_8494A64 + 32) )
    {
      if ( *(svs_clients + 175149 * v3) )
      {
        v1 = svs_clients + 700596 * v3;
      }
      else
      {
        Com_Printf("Client %i is not active\n", v3);
        v1 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      v1 = 0;
    }
  }
  else
  {
    Com_Printf("No player specified.\n");
    v1 = 0;
  }
  return v1;
}
// 84897C0: using guessed type int dword_84897C0;
// 8494A64: using guessed type int dword_8494A64;

//----- (08088020) --------------------------------------------------------
char *__cdecl sub_8088020(char *s)
{
  size_t n; // [esp+1Ch] [ebp-4Ch]
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  if ( !sub_8086946(s, "mp", 2) && (s[2] == 47 || s[2] == 92) )
    s += 3;
  n = strlen(s);
  if ( !strcmp(&s[n - 4], ".bsp") )
    n -= 4;
  memcpy(dest, s, n);
  dest[n] = 0;
  return sub_8086D78("%s", dest);
}

//----- (080880C9) --------------------------------------------------------
void sub_80880C9()
{
  char *v0; // eax
  char *v1; // ebx
  char *v2; // eax
  char v3[24]; // [esp+10h] [ebp-C8h] BYREF
  char *i; // [esp+28h] [ebp-B0h]
  _BOOL4 v5; // [esp+2Ch] [ebp-ACh]
  char v6[72]; // [esp+30h] [ebp-A8h] BYREF
  char *haystack; // [esp+78h] [ebp-60h]
  char *s1; // [esp+7Ch] [ebp-5Ch]
  char dest[72]; // [esp+80h] [ebp-58h] BYREF
  char *src; // [esp+C8h] [ebp-10h]
  char *v11; // [esp+CCh] [ebp-Ch]

  src = sub_805FF28(1u);
  if ( *src )
  {
    strcpy(dest, src);
    sub_8086A97(dest);
    s1 = sub_8088020(dest);
    haystack = sub_8086D78("maps/mp/%s.bsp", s1);
    if ( sub_8062EB0(haystack, 0) == -1 )
    {
      Com_Printf("Can't find map %s\n", haystack);
    }
    else
    {
      v11 = sub_805FF28(0);
      v5 = sub_8086A5A(v11, "devmap") == 0;
      if ( *(dword_84897C0 + 32) && *(dword_8488714 + 28) <= 0.0 )
        sub_8073817("timescale", 1.0);
      if ( sub_805FF1E() <= 2 || (v11 = sub_805FF28(2u)) != 0 && sub_8086A5A(v11, "noautoexec") )
      {
        v0 = sub_8073B14("g_gametype");
        Q_strncpyz(v3, v0, 16);
        for ( i = v3; *i; ++i )
        {
          v1 = i;
          *v1 = tolower(*i);
        }
        v2 = sub_8086D78("exec %s_%s.cfg\n", s1, v3);
        sub_805FAF4(0, v2);
      }
      if ( *(dword_84897C0 + 32) && !strcasecmp(s1, *(dword_8494A48 + 4)) )
      {
        SV_MapRestart();
      }
      else
      {
        Q_strncpyz(v6, s1, 64);
        SV_SpawnServer(v6);
      }
      if ( v5 )
        sub_8073798("sv_cheats", "1");
      else
        sub_8073798("sv_cheats", "0");
    }
  }
}
// 8488714: using guessed type int dword_8488714;
// 84897C0: using guessed type int dword_84897C0;
// 8494A48: using guessed type int dword_8494A48;

//----- (08088325) --------------------------------------------------------
void SV_MapRestart()
{
  char *v0; // eax
  char *v1; // eax
  char *v2; // eax
  int v3; // [esp+8h] [ebp-70h]
  int v4; // [esp+Ch] [ebp-6Ch]
  int v5; // [esp+10h] [ebp-68h]
  int v6; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  int v8; // [esp+14h] [ebp-64h]
  char *s; // [esp+18h] [ebp-60h]
  char *sa; // [esp+18h] [ebp-60h]
  int v11; // [esp+1Ch] [ebp-5Ch]
  int v12; // [esp+1Ch] [ebp-5Ch]
  int dest; // [esp+20h] [ebp-58h] BYREF
  int v14; // [esp+24h] [ebp-54h]
  int v15; // [esp+28h] [ebp-50h]
  int v16; // [esp+2Ch] [ebp-4Ch]
  int v17; // [esp+30h] [ebp-48h]
  int v18; // [esp+34h] [ebp-44h]
  int v19; // [esp+64h] [ebp-14h]
  int v20; // [esp+68h] [ebp-10h]
  int v21[3]; // [esp+6Ch] [ebp-Ch]

  if ( !*(dword_84897C0 + 32) )
  {
    Com_Printf("Server is not running.\n");
    return;
  }
  if ( *(dword_8488714 + 28) <= 0.0 )
    sub_8073817("timescale", 1.0);
  sub_8073114("g_gametype", "dm", 36);
  v12 = VM_Call(gvm, 18, v3, v4, v5, v7, s, v11, dest, v14, v15, v16, v17, v18);
  if ( v12 )
  {
    sub_8073798("g_gametype", byte_84F6F6C);
  }
  else
  {
    if ( strcasecmp(byte_84F6F6C, *(dword_84F6FD0 + 4)) )
    {
      Com_Printf("g_gametype variable change -- restarting.\n");
      v0 = sub_8073B14("mapname");
      Q_strncpyz(&dest, v0, 64);
      SV_SpawnServer(&dest);
      return;
    }
    if ( *(dword_8494A64 + 20) )
    {
      Com_Printf("sv_maxclients variable change -- restarting.\n");
      v1 = sub_8073B14("mapname");
      Q_strncpyz(&dest, v1, 64);
      SV_SpawnServer(&dest);
      return;
    }
  }
  if ( dword_848871C != dword_8494A88 )
  {
    sub_8091AFD();
    sub_8091A14();
    dword_84F700C ^= 4u;
    *dword_80F5100 = ((dword_80F5100[0] + 1) & 0xF) + (dword_80F5100[0] & 0xF0);
    v2 = sub_8086D78("%i", *dword_80F5100);
    sub_8073798("sv_serverid", v2);
    dword_8494A88 = dword_848871C;
    dword_8494A80 = 1;
    dword_8494A84 = 1;
    sub_8073798("sv_serverRestarting", "1");
    sub_80C0C82(1);
    sub_8090C91(v12);
    for ( v21[0] = 0; v21[0] <= 2; ++v21[0] )
    {
      svs_time += 100;
      dword_84F7004 += 100;
      sub_8094FCA();
    }
    for ( v21[0] = 0; v21[0] < *(dword_8494A64 + 32); ++v21[0] )
    {
      v20 = svs_clients + 700596 * v21[0];
      if ( *v20 > 1 )
      {
        if ( v12 )
        {
          sa = "n";
          SV_AddServerCommand(v20, 1, "n");
        }
        else
        {
          sa = "B";
          SV_AddServerCommand(v20, 1, "B");
        }
        v19 = VM_Call(gvm, 4, v21[0], *(v20 + 700548), v6, v8, sa, v12, dest, v14, v15, v16, v17, v18);
        if ( v19 )
        {
          SV_DropClient(v20, v19);
          Com_Printf("SV_MapRestart_f: dropped client %i - denied!\n", v21[0]);
        }
        else if ( *v20 == 4 )
        {
          SV_ClientEnterWorld(v20, (v20 + 67108));
        }
      }
    }
    dword_8494A80 = 2;
    dword_8494A84 = 0;
    sub_8073798("sv_serverRestarting", "0");
  }
}
// 808839A: variable 'v3' is possibly undefined
// 808839A: variable 'v4' is possibly undefined
// 808839A: variable 'v5' is possibly undefined
// 808839A: variable 'v7' is possibly undefined
// 808839A: variable 's' is possibly undefined
// 808839A: variable 'v11' is possibly undefined
// 808857A: variable 'v12' is possibly undefined
// 80885CB: variable 'v6' is possibly undefined
// 80885CB: variable 'v8' is possibly undefined
// 8090C91: using guessed type _DWORD __cdecl sub_8090C91(_DWORD);
// 8094FCA: using guessed type int sub_8094FCA(void);
// 8488714: using guessed type int dword_8488714;
// 848871C: using guessed type int dword_848871C;
// 84897C0: using guessed type int dword_84897C0;
// 8494A64: using guessed type int dword_8494A64;
// 8494A80: using guessed type int dword_8494A80;
// 8494A84: using guessed type int dword_8494A84;
// 8494A88: using guessed type int dword_8494A88;
// 84F6FD0: using guessed type int dword_84F6FD0;
// 84F7004: using guessed type int dword_84F7004;
// 84F7008: using guessed type int svs_time;
// 84F700C: using guessed type int dword_84F700C;

//----- (08088655) --------------------------------------------------------
void *sub_8088655()
{
  void *v0; // esp
  void *v2; // [esp+8h] [ebp-10h] BYREF
  void *v3; // [esp+Ch] [ebp-Ch]
  char *dest; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h] BYREF

  s = *(dword_8494A24 + 4);
  v3 = sub_8085E0B(&s);
  if ( s )
  {
    v0 = alloca(16 * ((strlen(s) + 16) >> 4));
    dest = &v2;
    strcpy(&v2, s);
    sub_8073798("sv_mapRotationCurrent", dest);
    v2 = v3;
  }
  else
  {
    sub_8073798("sv_mapRotationCurrent", &byte_80E35EE);
    v2 = 0;
  }
  return v2;
}
// 8494A24: using guessed type int dword_8494A24;

//----- (080886E5) --------------------------------------------------------
#error "8088A04: call analysis failed (funcsize=232)"

//----- (08088AEC) --------------------------------------------------------
int __cdecl sub_8088AEC(int a1, char *dest, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( *(a1 + 634952) == 2 )
  {
    sub_8092F86(0, 0, "e \"EXE_CANNOTKICKHOSTPLAYER\"");
    v4 = 0;
  }
  else
  {
    if ( dest )
    {
      Q_strncpyz(dest, (a1 + 68164), a3);
      sub_8086BC6(dest);
    }
    v5 = *(a1 + 700544);
    SV_DropClient(a1, "EXE_PLAYERKICKED");
    *(a1 + 68636) = svs_time;
    v4 = v5;
  }
  return v4;
}
// 84F7008: using guessed type int svs_time;

//----- (08088B8A) --------------------------------------------------------
int __cdecl sub_8088B8A(char *dest, int a2)
{
  char *v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  _DWORD *v7; // [esp+20h] [ebp-8h]
  char *v8; // [esp+24h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() == 2 )
    {
      v6 = sub_8087DE8();
      if ( v6 )
      {
        v4 = sub_8088AEC(v6, dest, a2);
      }
      else
      {
        v2 = sub_805FF28(1u);
        if ( !sub_8086A5A(v2, "all") )
        {
          v5 = 0;
          v7 = svs_clients;
          while ( v5 < *(dword_8494A64 + 32) )
          {
            if ( *v7 )
              sub_8088AEC(v7, 0, 0);
            ++v5;
            v7 += 175149;
          }
        }
        v4 = 0;
      }
    }
    else
    {
      v8 = sub_805FF28(0);
      Com_Printf("Usage: %s <player name>\n%s all = kick everyone\n", v8, v8);
      v4 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    v4 = 0;
  }
  return v4;
}
// 84897C0: using guessed type int dword_84897C0;
// 8494A64: using guessed type int dword_8494A64;

//----- (08088C9E) --------------------------------------------------------
int __cdecl sub_8088C9E(char *dest, int a2)
{
  char *v2; // eax
  int v4; // [esp+10h] [ebp-8h]
  char *v5; // [esp+14h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() == 2 )
    {
      v5 = sub_8087EFF();
      if ( v5 )
        v4 = sub_8088AEC(v5, dest, a2);
      else
        v4 = 0;
    }
    else
    {
      v2 = sub_805FF28(0);
      Com_Printf("Usage: %s <client number>\n", v2);
      v4 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
    v4 = 0;
  }
  return v4;
}
// 84897C0: using guessed type int dword_84897C0;

//----- (08088D2B) --------------------------------------------------------
int sub_8088D2B()
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v2; // [esp+5Ch] [ebp-Ch]

  result = sub_8088B8A(dest, 64);
  v2 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", dest, v2);
    result = sub_8089EF9(v2);
  }
  return result;
}

//----- (08088D74) --------------------------------------------------------
void sub_8088D74()
{
  char *v0; // [esp+4h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() == 2 )
    {
      v0 = sub_8087DE8();
      if ( v0 )
        sub_8089F25(v0);
    }
    else
    {
      Com_Printf("Usage: banUser <player name>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 84897C0: using guessed type int dword_84897C0;

//----- (08088DC8) --------------------------------------------------------
void sub_8088DC8()
{
  char *v0; // [esp+4h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() == 2 )
    {
      v0 = sub_8087EFF();
      if ( v0 )
        sub_8089F25(v0);
    }
    else
    {
      Com_Printf("Usage: banClient <client number>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 84897C0: using guessed type int dword_84897C0;

//----- (08088E1C) --------------------------------------------------------
void sub_8088E1C()
{
  char *v0; // eax

  if ( sub_805FF1E() == 2 )
  {
    v0 = sub_805FF28(1u);
    sub_808A021(v0);
  }
  else
  {
    Com_Printf("Usage: unban <client name>\n");
  }
}

//----- (08088E50) --------------------------------------------------------
int sub_8088E50()
{
  return sub_8088B8A(0, 0);
}

//----- (08088E6C) --------------------------------------------------------
int sub_8088E6C()
{
  return sub_8088C9E(0, 0);
}

//----- (08088E88) --------------------------------------------------------
int sub_8088E88()
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v2; // [esp+5Ch] [ebp-Ch]

  result = sub_8088C9E(dest, 64);
  v2 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", dest, v2);
    result = sub_8089EF9(v2);
  }
  return result;
}

//----- (08088ED1) --------------------------------------------------------
void sub_8088ED1()
{
  int v0; // eax
  int v1; // [esp+18h] [ebp-20h]
  const char *s; // [esp+20h] [ebp-18h]
  const char *v3; // [esp+28h] [ebp-10h]
  int v4; // [esp+2Ch] [ebp-Ch]
  signed int v5; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    Com_Printf("map: %s\n", *(dword_8494A48 + 4));
    Com_Printf("num score ping guid   name            lastmsg address               qport rate\n");
    Com_Printf("--- ----- ---- ------ --------------- ------- --------------------- ----- -----\n");
    v8 = 0;
    v3 = svs_clients;
    while ( v8 < *(dword_8494A64 + 32) )
    {
      if ( *v3 )
      {
        Com_Printf("%3i ", v8);
        sub_808E105(v8);
        v0 = sub_80932C9(v3);
        Com_Printf("%5i ", v0);
        if ( *v3 == 2 )
        {
          Com_Printf("CNCT ");
        }
        else if ( *v3 == 1 )
        {
          Com_Printf("ZMBI ");
        }
        else
        {
          v1 = *(v3 + 158732);
          if ( v1 > 9999 )
            v1 = 9999;
          Com_Printf("%4i ", v1);
        }
        Com_Printf("%6i ", *(v3 + 175136));
        Com_Printf("%s^7", v3 + 68164);
        v4 = 16 - sub_8086B5E(v3 + 68164);
        for ( i = 0; i < v4; ++i )
          Com_Printf(" ");
        Com_Printf("%7i ", svs_time - *(v3 + 17159));
        s = sub_80848F8(*(v3 + 158738), *(v3 + 158739), *(v3 + 158740), *(v3 + 158741), *(v3 + 158742));
        Com_Printf("%s", s);
        v5 = 22 - strlen(s);
        for ( j = 0; j < v5; ++j )
          Com_Printf(" ");
        Com_Printf("%5i", *(v3 + 158743));
        Com_Printf(" %5i", *(v3 + 158733));
        Com_Printf("\n");
      }
      ++v8;
      v3 += 700596;
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 80932C9: using guessed type _DWORD __cdecl sub_80932C9(_DWORD);
// 84897C0: using guessed type int dword_84897C0;
// 8494A48: using guessed type int dword_8494A48;
// 8494A64: using guessed type int dword_8494A64;
// 84F7008: using guessed type int svs_time;

//----- (08089169) --------------------------------------------------------
void sub_8089169()
{
  size_t v0; // eax
  char dest[1036]; // [esp+10h] [ebp-418h] BYREF
  char *s; // [esp+41Ch] [ebp-Ch]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() > 1 )
    {
      strcpy(dest, "console: ");
      s = sub_805FF7F(1);
      if ( *s == 34 )
      {
        v0 = strlen(++s);
        s[v0 - 1] = 0;
      }
      strcat(dest, s);
      sub_8092F86(0, 0, asc_80E3BF2, dest);
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 84897C0: using guessed type int dword_84897C0;

//----- (0808921B) --------------------------------------------------------
void sub_808921B()
{
  char *v0; // eax
  size_t v1; // eax
  int v2; // [esp+18h] [ebp-420h]
  _DWORD *v3; // [esp+1Ch] [ebp-41Ch]
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  char *s; // [esp+42Ch] [ebp-Ch]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() > 2 )
    {
      v0 = sub_805FF28(1u);
      v2 = atoi(v0);
      if ( v2 >= 0 && v2 < *(dword_8494A64 + 32) )
      {
        v3 = svs_clients + 700596 * v2;
        if ( *v3 == 4 )
        {
          strcpy(dest, "console: ");
          s = sub_805FF7F(2);
          if ( *s == 34 )
          {
            v1 = strlen(++s);
            s[v1 - 1] = 0;
          }
          strcat(dest, s);
          sub_8092F86(v3, 0, asc_80E3BF2, dest);
        }
      }
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 84897C0: using guessed type int dword_84897C0;
// 8494A64: using guessed type int dword_8494A64;

//----- (08089336) --------------------------------------------------------
void sub_8089336()
{
  dword_84F7058 = 0x80000000;
}
// 84F7058: using guessed type int dword_84F7058;

//----- (08089345) --------------------------------------------------------
void sub_8089345()
{
  char *v0; // eax

  Com_Printf("Server info settings:\n");
  v0 = sub_8074863(8196);
  Info_Print(v0);
}

//----- (0808936D) --------------------------------------------------------
void sub_808936D()
{
  char *v0; // eax

  Com_Printf("System info settings:\n");
  v0 = sub_8074863(8);
  Info_Print(v0);
}

//----- (08089395) --------------------------------------------------------
void SV_DumpUser_f()
{
  char *v0; // [esp+4h] [ebp-4h]

  if ( *(dword_84897C0 + 32) )
  {
    if ( sub_805FF1E() == 2 )
    {
      v0 = sub_8087DE8();
      if ( v0 )
      {
        Com_Printf("userinfo\n");
        Com_Printf("--------\n");
        Info_Print(v0 + 12);
      }
    }
    else
    {
      Com_Printf("Usage: info <userid>\n");
    }
  }
  else
  {
    Com_Printf("Server is not running.\n");
  }
}
// 84897C0: using guessed type int dword_84897C0;

//----- (08089404) --------------------------------------------------------
void sub_8089404()
{
  sub_80702FC("EXE_SERVERKILLED");
}

//----- (08089418) --------------------------------------------------------
void sub_8089418()
{
  sub_809324A();
}

//----- (08089425) --------------------------------------------------------
int sub_8089425()
{
  return sub_80A5540();
}

//----- (08089432) --------------------------------------------------------
int sub_8089432()
{
  return sub_80A2614();
}

//----- (0808943F) --------------------------------------------------------
void sub_808943F()
{
  char *s1; // [esp+10h] [ebp-8h]
  char *v1; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 2 )
  {
    s1 = sub_805FF28(1u);
    sub_8073798("scr_drawfriend", s1);
    sub_8073798("ui_drawfriend", s1);
  }
  else
  {
    v1 = sub_805FF28(0);
    Com_Printf("Usage: %s <integer>\n", v1);
  }
}

//----- (080894AA) --------------------------------------------------------
void sub_80894AA()
{
  char *s1; // [esp+10h] [ebp-8h]
  char *v1; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 1 )
  {
    v1 = sub_805FF28(0);
    Com_Printf("Usage: %s <integer>\n", v1);
  }
  else
  {
    s1 = sub_805FF28(1u);
    sub_8073798("scr_friendlyfire", s1);
    sub_8073798("ui_friendlyfire", s1);
  }
}

//----- (08089515) --------------------------------------------------------
void sub_8089515()
{
  char *s1; // [esp+10h] [ebp-8h]
  char *v1; // [esp+14h] [ebp-4h]

  if ( sub_805FF1E() == 1 )
  {
    v1 = sub_805FF28(0);
    Com_Printf("Usage: %s <integer>\n", v1);
  }
  else
  {
    s1 = sub_805FF28(1u);
    sub_8073798("scr_killcam", s1);
    sub_8073798("ui_killcam", s1);
  }
}

//----- (08089580) --------------------------------------------------------
void sub_8089580()
{
  if ( !dword_829EDA0 )
  {
    dword_829EDA0 = 1;
    sub_8060272("heartbeat", sub_8089336);
    sub_8060272("kick", sub_8088E50);
    sub_8060272("banUser", sub_8088D74);
    sub_8060272("banClient", sub_8088DC8);
    sub_8060272("tempBanUser", sub_8088D2B);
    sub_8060272("tempBanClient", sub_8088E88);
    sub_8060272("unbanUser", sub_8088E1C);
    sub_8060272("clientkick", sub_8088E6C);
    sub_8060272("status", sub_8088ED1);
    sub_8060272("serverinfo", sub_8089345);
    sub_8060272("systeminfo", sub_808936D);
    sub_8060272("dumpuser", SV_DumpUser_f);
    sub_8060272("map_restart", SV_MapRestart);
    sub_8060272("map", sub_80880C9);
    sub_8060272("map_rotate", sub_80886E5);
    sub_8060272("gameCompleteStatus", sub_8089418);
    sub_8060272("devmap", sub_80880C9);
    sub_8060272("killserver", sub_8089404);
    if ( *(dword_84886E0 + 32) )
      sub_8089781();
    sub_8060272("scriptUsage", sub_8089425);
    sub_8060272("stringUsage", sub_8089432);
    sub_8060272("setdrawfriend", sub_808943F);
    sub_8060272("setfriendlyfire", sub_80894AA);
    sub_8060272("setkillcam", sub_8089515);
  }
}
// 80886E5: using guessed type _DWORD sub_80886E5();
// 829EDA0: using guessed type int dword_829EDA0;
// 84886E0: using guessed type int dword_84886E0;

//----- (0808977C) --------------------------------------------------------
void sub_808977C()
{
  ;
}

//----- (08089781) --------------------------------------------------------
void sub_8089781()
{
  sub_8060272("say", sub_8089169);
  sub_8060272("tell", sub_808921B);
}

//----- (080897D4) --------------------------------------------------------
void __cdecl sub_80897D4(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx
  __int16 v6; // ax
  int *v7; // eax
  int *v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v10 = 0;
  v9 = 0x7FFFFFFF;
  v8 = dword_84F7060;
  for ( i = 0; i <= 1023 && (v8[10] || !sub_8084AF7(a1, a2, a3, a4, a5, *v8, v8[1], v8[2], v8[3], v8[4])); ++i )
  {
    if ( v8[6] < v9 )
    {
      v9 = v8[6];
      v10 = i;
    }
    v8 += 21;
  }
  if ( i == 1024 )
  {
    v8 = (84 * v10 + 139423840);
    v5 = rand() << 16;
    dword_84F7074[21 * v10] = dword_84F7004 ^ v5 ^ rand();
    *v8 = a1;
    v8[1] = a2;
    v8[2] = a3;
    v8[3] = a4;
    v8[4] = a5;
    v8[8] = svs_time;
    v8[9] = 0;
    v8[6] = svs_time;
    v8[10] = 0;
    i = v10;
  }
  if ( *(dword_8489A60 + 32) || !sub_80CA1BC(a1, a2) )
  {
    if ( !dword_850C078 && dword_850C074 != 1 )
    {
      Com_Printf("Resolving %s\n", "coduoauthorize.activision.com");
      if ( !sub_8084FC8("coduoauthorize.activision.com", &dword_850C074) )
      {
        Com_Printf("Couldn't resolve address\n");
        return;
      }
      word_850C086 = sub_808649A(20600);
      v6 = sub_808649A(word_850C086);
      Com_Printf(
        "%s resolved to %i.%i.%i.%i:%i\n",
        "coduoauthorize.activision.com",
        dword_850C078,
        BYTE1(dword_850C078),
        BYTE2(dword_850C078),
        HIBYTE(dword_850C078),
        v6);
    }
    if ( svs_time - v8[8] <= 5000
      || (v7 = sub_809308F(), sub_8084AF7(a1, a2, a3, a4, a5, *v7, v7[1], v7[2], v7[3], v7[4])) )
    {
      sub_8089C3F(a1, a2, a3, a4, a5, dword_84F7074[21 * i]);
    }
    else
    {
      Com_DPrintf("authorize server timed out\n");
      v8[7] = svs_time;
      if ( *(dword_84F6FC8 + 32) )
        sub_8084D76(1, *v8, v8[1], v8[2], v8[3], v8[4], "challengeResponse %i %i", v8[5], *(dword_84F6FC8 + 32));
      else
        sub_8084D76(1, *v8, v8[1], v8[2], v8[3], v8[4], "challengeResponse %i", v8[5]);
    }
  }
  else
  {
    v8[7] = svs_time;
    if ( *(dword_84F6FC8 + 32) )
      sub_8084D76(1, a1, a2, a3, a4, a5, "challengeResponse %i %i", v8[5], *(dword_84F6FC8 + 32));
    else
      sub_8084D76(1, a1, a2, a3, a4, a5, "challengeResponse %i", v8[5]);
  }
}
// 8489A60: using guessed type int dword_8489A60;
// 84F6FC8: using guessed type int dword_84F6FC8;
// 84F7004: using guessed type int dword_84F7004;
// 84F7008: using guessed type int svs_time;
// 84F7060: using guessed type int dword_84F7060[];
// 84F7074: using guessed type int dword_84F7074[];
// 850C086: using guessed type __int16 word_850C086;

//----- (08089C3F) --------------------------------------------------------
void __cdecl sub_8089C3F(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char dest[1036]; // [esp+40h] [ebp-418h] BYREF
  int *v8; // [esp+44Ch] [ebp-Ch]

  if ( dword_850C074 != 1 )
  {
    dest[0] = 0;
    v8 = sub_8073114("fs_game", &byte_80E3E9B, 24);
    if ( v8 )
    {
      if ( *v8[1] )
        strcpy(dest, v8[1]);
    }
    v6 = sub_80848F8(a1, a2, a3, a4, a5);
    Com_DPrintf("sending getIpAuthorize for %s\n", v6);
    v8 = sub_8073114("sv_allowAnonymous", "0", 4);
    sub_8084D76(
      1,
      dword_850C074,
      dword_850C078,
      *dword_850C07C,
      dword_850C080,
      unk_850C084,
      "getIpAuthorize %i %i.%i.%i.%i %s %i",
      a6,
      a2,
      BYTE1(a2),
      BYTE2(a2),
      HIBYTE(a2),
      dest,
      v8[8]);
  }
}

//----- (08089D79) --------------------------------------------------------
int __cdecl sub_8089D79(int a1)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dword_850C08C[2 * i] == a1 && (dword_84F7004 - dword_850C090[2 * i]) <= *(dword_8494A28 + 28) * 1000.0 )
      return 1;
  }
  return 0;
}
// 8494A28: using guessed type int dword_8494A28;
// 84F7004: using guessed type int dword_84F7004;
// 850C08C: using guessed type int dword_850C08C[];

//----- (08089DFC) --------------------------------------------------------
int __cdecl sub_8089DFC(int a1)
{
  int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  if ( !a1 )
    return 0;
  if ( (sub_8062EB0("ban.txt", &v6) & 0x80000000) != 0 )
    return 0;
  v5 = v6;
  v3 = 0;
  while ( 1 )
  {
    nptr = sub_8085E0B(&v5);
    if ( !*nptr )
      break;
    if ( atoi(nptr) == a1 )
    {
      v3 = 1;
      break;
    }
    sub_8085FBA(&v5);
  }
  sub_8063207(v6);
  return v3;
}

//----- (08089E9A) --------------------------------------------------------
unsigned int sub_8089E9A()
{
  unsigned int v2; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( !dword_850C08C[2 * i] )
      return i;
    if ( dword_850C090[2 * i] < dword_850C090[2 * v2] )
      v2 = i;
  }
  return v2;
}
// 850C08C: using guessed type int dword_850C08C[];

//----- (08089EF9) --------------------------------------------------------
int __cdecl sub_8089EF9(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  int result; // eax

  v1 = sub_8089E9A();
  dword_850C08C[2 * v1] = a1;
  v2 = v1;
  result = dword_84F7004;
  dword_850C090[2 * v2] = dword_84F7004;
  return result;
}
// 84F7004: using guessed type int dword_84F7004;
// 850C08C: using guessed type int dword_850C08C[];

//----- (08089F25) --------------------------------------------------------
int __cdecl sub_8089F25(int a1)
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v3[3]; // [esp+5Ch] [ebp-Ch] BYREF

  if ( *(a1 + 634952) == 2 )
    return sub_8092F86(0, 0, "e \"EXE_CANNOTKICKHOSTPLAYER\"");
  result = a1;
  if ( *(a1 + 700544) )
  {
    result = sub_8089DFC(*(a1 + 700544));
    if ( !result )
    {
      result = sub_8065D85("ban.txt", v3, 2);
      if ( result >= 0 )
      {
        Q_strncpyz(dest, (a1 + 68164), 64);
        sub_8086BC6(dest);
        sub_8062A7E(v3[0], "%i %s\r\n", *(a1 + 700544), dest);
        FS_FCloseFile(v3[0]);
        SV_DropClient(a1, "EXE_PLAYERKICKED");
        result = svs_time;
        *(a1 + 68636) = svs_time;
      }
    }
  }
  return result;
}
// 84F7008: using guessed type int svs_time;

//----- (0808A021) --------------------------------------------------------
void __cdecl sub_808A021(char *src)
{
  int v1; // [esp+1Ch] [ebp-6Ch]
  int v2; // [esp+20h] [ebp-68h]
  size_t n; // [esp+28h] [ebp-60h]
  char *dest; // [esp+30h] [ebp-58h]
  char *s1; // [esp+34h] [ebp-54h] BYREF
  int v6; // [esp+38h] [ebp-50h]
  int v7; // [esp+3Ch] [ebp-4Ch] BYREF
  char s[72]; // [esp+40h] [ebp-48h] BYREF

  v6 = sub_8062EB0("ban.txt", &v7);
  if ( v6 >= 0 )
  {
    Q_strncpyz(s, src, 64);
    sub_8086BC6(s);
    n = strlen(s);
    v2 = 0;
    s1 = v7;
    while ( 1 )
    {
      dest = s1;
      if ( !*sub_8085E0B(&s1) )
        break;
      while ( *s1 && *s1 <= 32 )
        ++s1;
      v1 = 0;
      if ( !strncasecmp(s1, s, n) && (s1[n] == 13 || s1[n] == 10) )
        v1 = 1;
      sub_8085FBA(&s1);
      if ( v1 )
      {
        ++v2;
        memmove(dest, s1, v6 - &s1[-v7] + 1);
        v6 -= s1 - dest;
        s1 = dest;
      }
    }
    sub_806323F("ban.txt", v7, v6);
    sub_8063207(v7);
    if ( v2 )
      Com_Printf("unbanned %i user(s) named %s\n", v2, s);
    else
      Com_Printf("no banned user has name %s\n", s);
  }
}

//----- (0808A1C5) --------------------------------------------------------
void __cdecl sub_808A1C5(char a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char s[1024]; // [esp+30h] [ebp-418h] BYREF
  char *v9; // [esp+430h] [ebp-18h]
  char *v10; // [esp+434h] [ebp-14h]
  int i; // [esp+438h] [ebp-10h]
  int v12; // [esp+43Ch] [ebp-Ch]

  if ( !sub_80848CB(a1, a2, a3, a4, a5, dword_850C074, dword_850C078, *dword_850C07C, dword_850C080, unk_850C084) )
  {
    Com_Printf("SV_AuthorizeIpPacket: not from authorize server\n");
    return;
  }
  v5 = sub_805FF28(1u);
  v12 = atoi(v5);
  for ( i = 0; i <= 1023 && dword_84F7074[21 * i] != v12; ++i )
    ;
  if ( i == 1024 )
  {
    Com_Printf("SV_AuthorizeIpPacket: challenge not found\n");
    return;
  }
  dword_84F707C[21 * i] = svs_time;
  v10 = sub_805FF28(2u);
  v9 = sub_805FF28(3u);
  v6 = sub_805FF28(5u);
  Q_strncpyz((84 * i + 139423888), v6, 32);
  if ( !sub_8086A5A(v10, "demo") )
  {
    if ( sub_8073AB4("fs_restrict") == 0.0 )
    {
      sub_8084D76(
        1,
        dword_84F7060[21 * i],
        dword_84F7064[21 * i],
        dword_84F7068[21 * i],
        dword_84F706C[21 * i],
        dword_84F7070[21 * i],
        "error\nEXE_ERR_NOT_A_DEMO_SERVER");
      memset((84 * i + 139423840), 0, 0x54u);
      return;
    }
    goto LABEL_12;
  }
  if ( sub_8086A5A(v10, "accept") )
  {
    if ( sub_8086A5A(v10, "deny") )
    {
      if ( v9 && *v9 )
      {
        sprintf(s, "error\n%s", v9);
        sub_8084D76(
          1,
          dword_84F7060[21 * i],
          dword_84F7064[21 * i],
          dword_84F7068[21 * i],
          dword_84F706C[21 * i],
          dword_84F7070[21 * i],
          s);
      }
      else
      {
        sub_8084D76(
          1,
          dword_84F7060[21 * i],
          dword_84F7064[21 * i],
          dword_84F7068[21 * i],
          dword_84F706C[21 * i],
          dword_84F7070[21 * i],
          "error\nEXE_ERR_BAD_CDKEY");
      }
      memset((84 * i + 139423840), 0, 0x54u);
      return;
    }
    if ( v9 && *v9 )
    {
      if ( !sub_8086A5A(v9, "CLIENT_UNKNOWN_TO_AUTH") || !sub_8086A5A(v9, "BAD_CDKEY") )
      {
        sub_8084D76(
          1,
          dword_84F7060[21 * i],
          dword_84F7064[21 * i],
          dword_84F7068[21 * i],
          dword_84F706C[21 * i],
          dword_84F7070[21 * i],
          "needcdkey");
LABEL_32:
        memset((84 * i + 139423840), 0, 0x54u);
        return;
      }
      if ( sub_8086A5A(v9, "INVALID_CDKEY") )
      {
        sub_8086A5A(v9, "BANNED_CDKEY");
        sub_8084D76(
          1,
          dword_84F7060[21 * i],
          dword_84F7064[21 * i],
          dword_84F7068[21 * i],
          dword_84F706C[21 * i],
          dword_84F7070[21 * i],
          "error\nEXE_ERR_BAD_CDKEY");
        goto LABEL_32;
      }
    }
    sub_8084D76(
      1,
      dword_84F7060[21 * i],
      dword_84F7064[21 * i],
      dword_84F7068[21 * i],
      dword_84F706C[21 * i],
      dword_84F7070[21 * i],
      "error\nEXE_ERR_CDKEY_IN_USE");
    goto LABEL_32;
  }
  v7 = sub_805FF28(4u);
  dword_84F708C[21 * i] = atoi(v7);
  if ( sub_8089DFC(dword_84F708C[21 * i]) )
  {
    Com_Printf("rejected connection from permanently banned GUID %i\n", dword_84F708C[21 * i]);
    sub_8084D76(
      1,
      dword_84F7060[21 * i],
      dword_84F7064[21 * i],
      dword_84F7068[21 * i],
      dword_84F706C[21 * i],
      dword_84F7070[21 * i],
      aError_2);
    memset((84 * i + 139423840), 0, 0x54u);
  }
  else if ( sub_8089D79(dword_84F708C[21 * i]) )
  {
    Com_Printf("rejected connection from temporarily banned GUID %i\n", dword_84F708C[21 * i]);
    sub_8084D76(
      1,
      dword_84F7060[21 * i],
      dword_84F7064[21 * i],
      dword_84F7068[21 * i],
      dword_84F706C[21 * i],
      dword_84F7070[21 * i],
      aError_3);
    memset((84 * i + 139423840), 0, 0x54u);
  }
  else if ( !dword_84F7088[21 * i] )
  {
    if ( !*(dword_84F6FC8 + 32) )
    {
LABEL_12:
      sub_8084D76(
        1,
        dword_84F7060[21 * i],
        dword_84F7064[21 * i],
        dword_84F7068[21 * i],
        dword_84F706C[21 * i],
        dword_84F7070[21 * i],
        "challengeResponse %i",
        dword_84F7074[21 * i]);
      return;
    }
    sub_8084D76(
      1,
      dword_84F7060[21 * i],
      dword_84F7064[21 * i],
      dword_84F7068[21 * i],
      dword_84F706C[21 * i],
      dword_84F7070[21 * i],
      "challengeResponse %i %i",
      dword_84F7074[21 * i],
      *(dword_84F6FC8 + 32));
  }
}
// 84F6FC8: using guessed type int dword_84F6FC8;
// 84F7008: using guessed type int svs_time;
// 84F7060: using guessed type int dword_84F7060[];
// 84F7064: using guessed type int dword_84F7064[];
// 84F7068: using guessed type int dword_84F7068[];
// 84F706C: using guessed type int dword_84F706C[];
// 84F7070: using guessed type int dword_84F7070[];
// 84F7074: using guessed type int dword_84F7074[];
// 84F707C: using guessed type int dword_84F707C[];
// 84F7088: using guessed type int dword_84F7088[];

//----- (0808ABB3) --------------------------------------------------------
#error "808ABF5: call analysis failed (funcsize=31)"

//----- (0808AC2B) --------------------------------------------------------
void sub_808AC2B()
{
  int *v0; // [esp+10h] [ebp-8h]
  int v1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v0 = svs_clients;
  while ( v1 < *(dword_8494A64 + 32) )
  {
    if ( *v0 > 1 )
      sub_808ABB3(v0);
    ++v1;
    v0 += 175149;
  }
  free(svs_clients);
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0808AC82) --------------------------------------------------------
void __cdecl SVC_DirectConnect(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  char *v13; // eax
  _WORD *v14; // ebx
  int v15; // [esp+10h] [ebp-AB558h]
  int v16; // [esp+14h] [ebp-AB554h]
  int v17; // [esp+18h] [ebp-AB550h]
  int v18; // [esp+1Ch] [ebp-AB54Ch]
  int v19; // [esp+20h] [ebp-AB548h]
  int v20; // [esp+24h] [ebp-AB544h]
  int v21; // [esp+28h] [ebp-AB540h]
  int v22; // [esp+2Ch] [ebp-AB53Ch]
  int v23; // [esp+30h] [ebp-AB538h]
  int v24; // [esp+34h] [ebp-AB534h]
  unsigned int v25; // [esp+3Ch] [ebp-AB52Ch]
  int *v26; // [esp+40h] [ebp-AB528h]
  int *v27; // [esp+44h] [ebp-AB524h]
  char *v28; // [esp+48h] [ebp-AB520h]
  int v29; // [esp+4Ch] [ebp-AB51Ch]
  char *s1; // [esp+50h] [ebp-AB518h]
  void *v31; // [esp+54h] [ebp-AB514h]
  int v32; // [esp+58h] [ebp-AB510h]
  int v33; // [esp+5Ch] [ebp-AB50Ch]
  const char *denied; // [esp+60h] [ebp-AB508h]
  int v35; // [esp+64h] [ebp-AB504h]
  char *v36; // [esp+68h] [ebp-AB500h]
  int v37; // [esp+6Ch] [ebp-AB4FCh]
  int v38; // [esp+70h] [ebp-AB4F8h]
  int v39; // [esp+74h] [ebp-AB4F4h]
  int v40; // [esp+78h] [ebp-AB4F0h]
  int v41; // [esp+80h] [ebp-AB4E8h] BYREF
  int v42; // [esp+84h] [ebp-AB4E4h] BYREF
  void *newcl; // [esp+AB140h] [ebp-428h]
  _DWORD *v44; // [esp+AB144h] [ebp-424h]
  int v45; // [esp+AB148h] [ebp-420h]
  char v46[4]; // [esp+AB14Ch] [ebp-41Ch]
  char dest[1048]; // [esp+AB150h] [ebp-418h] BYREF

  Com_DPrintf("SVC_DirectConnect ()\n");
  v5 = sub_805FF28(1u);
  Q_strncpyz(dest, v5, 1024);
  v6 = sub_8086E7F(dest, "protocol");
  v39 = atoi(v6);
  if ( v39 != 22 )
  {
    sub_8084D76(1, a1, a2, a3, a4, a5, aErrorExeServer_0, "1.51");
    Com_DPrintf("    rejected connect from protocol version %i (should be %i)\n", v39, 22);
    return;
  }
  v7 = sub_8086E7F(dest, "challenge");
  v37 = atoi(v7);
  v8 = sub_8086E7F(dest, "qport");
  v38 = atoi(v8);
  *v46 = 0;
  v44 = svs_clients;
  while ( *v46 < *(dword_8494A64 + 32) )
  {
    v19 = v44[158741];
    v20 = v44[158742];
    if ( sub_80848CB(a1, a2, a3, a4, a5, v44[158738], v44[158739], v44[158740])
      && (v44[158743] == v38 || HIWORD(a5) == *(v44 + 317485)) )
    {
      if ( svs_time - v44[17160] < 1000 * *(dword_84F6FDC + 32) )
      {
        v9 = sub_80848F8(a1, a2, a3, a4, a5);
        Com_DPrintf("%s:reconnect rejected : too soon\n", v9);
        return;
      }
      break;
    }
    ++*v46;
    v44 += 175149;
  }
  v45 = 0;
  if ( sub_8084B24(a1) )
    goto LABEL_30;
  *v46 = 0;
  while ( *v46 <= 1023 )
  {
    v19 = dword_84F706C[21 * *v46];
    v20 = dword_84F7070[21 * *v46];
    if ( sub_8084AF7(a1, a2, a3, a4, a5, dword_84F7060[21 * *v46], dword_84F7064[21 * *v46], dword_84F7068[21 * *v46])
      && v37 == dword_84F7074[21 * *v46] )
    {
      v45 = dword_84F708C[21 * *v46];
      break;
    }
    ++*v46;
  }
  if ( *v46 == 1024 )
  {
    sub_8084D76(1, a1, a2, a3, a4, a5, "error\nEXE_BAD_CHALLENGE");
    return;
  }
  if ( dword_84F7084[21 * *v46] )
  {
    v29 = dword_84F7084[21 * *v46];
  }
  else
  {
    v29 = svs_time - dword_84F707C[21 * *v46];
    dword_84F7084[21 * *v46] = v29;
  }
  v10 = sub_80848F8(a1, a2, a3, a4, a5);
  Com_Printf("Client %i connecting with %i challenge ping from %s\n", *v46, v29, v10);
  dword_84F7088[21 * *v46] = 1;
  if ( sub_80CA1BC(a1, a2) )
    goto LABEL_30;
  if ( *(dword_84F6FE0 + 28) != 0.0 && *(dword_84F6FE0 + 28) > v29 )
  {
    sub_8084D76(1, a1, a2, a3, a4, a5, "error\nEXE_ERR_HIGH_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too low ping\n", *v46);
    return;
  }
  if ( *(dword_84F6FB4 + 28) == 0.0 || v29 <= *(dword_84F6FB4 + 28) )
  {
LABEL_30:
    v11 = sub_8086E7F(dest, "cl_punkbuster");
    v32 = atoi(v11);
    v31 = sub_8086E7F(dest, "cl_guid");
    if ( sub_8084B24(a1) )
    {
      v12 = sub_80B6CB0("localhost", v32, v31);
    }
    else
    {
      v28 = sub_80848F8(a1, a2, a3, a4, a5);
      v12 = sub_80B6CB0(v28, v32, v31);
    }
    s1 = v12;
    if ( v12 )
    {
      if ( !strncasecmp(v12, "error\n", 6u) )
        sub_8084D76(1, a1, a2, a3, a4, a5, s1);
    }
    else
    {
      newcl = &v41;
      memset(&v41, 0, 0xAB0B4u);
      *v46 = 0;
      v44 = svs_clients;
      while ( *v46 < *(dword_8494A64 + 32) )
      {
        if ( *v44 )
        {
          v19 = v44[158741];
          v20 = v44[158742];
          if ( sub_80848CB(a1, a2, a3, a4, a5, v44[158738], v44[158739], v44[158740])
            && (v44[158743] == v38 || HIWORD(a5) == *(v44 + 317485)) )
          {
            v13 = sub_80848F8(a1, a2, a3, a4, a5);
            Com_Printf("%s:reconnect\n", v13);
            if ( *v44 > 1 )
              sub_808ABB3(v44);
            newcl = v44;
            goto LABEL_57;
          }
        }
        ++*v46;
        v44 += 175149;
      }
      v36 = sub_8086E7F(dest, "password");
      if ( !strcmp(v36, *(dword_8494A4C + 4)) )
        v35 = 0;
      else
        v35 = *(dword_8494A20 + 32);
      newcl = 0;
      *v46 = v35;
      while ( *v46 < *(dword_8494A64 + 32) )
      {
        v44 = svs_clients + 700596 * *v46;
        if ( !*v44 )
        {
          newcl = v44;
          break;
        }
        ++*v46;
      }
      if ( !newcl )
      {
        sub_8084D76(1, a1, a2, a3, a4, a5, "error\nEXE_SERVERISFULL");
        Com_DPrintf("Rejected a connection.\n");
        return;
      }
      v44[16772] = 0;
      v44[16771] = 0;
LABEL_57:
      v27 = newcl;
      v26 = &v41;
      v25 = 700596;
      if ( (newcl & 4) != 0 )
      {
        *newcl = v41;
        ++v27;
        v26 = &v42;
        v25 = 700592;
      }
      qmemcpy(v27, v26, 4 * (v25 >> 2));
      v40 = -1067678811 * ((newcl - svs_clients) >> 2);
      *(newcl + 17040) = SV_GentityNum(v40);
      v14 = newcl;
      v14[350274] = sub_80A6AAC();
      *(newcl + 16776) = v37;
      *(newcl + 175136) = v45;
      sub_8083F57(1, newcl + 634944, a1, a2, a3, a4, a5, v38);
      Q_strncpyz(newcl + 12, dest, 1024);
      denied = VM_Call(gvm, 4, v40, *(newcl + 350274), v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
      if ( denied )
      {
        sub_8084D76(1, a1, a2, a3, a4, a5, "error\n%s", denied);
        Com_DPrintf("Game rejected a connection: %s.\n", denied);
        sub_8094DE7(newcl);
      }
      else
      {
        SV_UserInfoChanged(newcl);
        dword_84F7084[21 * *v46] = 0;
        sub_8084D76(1, a1, a2, a3, a4, a5, "connectResponse");
        Com_Printf(
          "Going from CS_FREE to CS_CONNECTED for %s (num %i guid %i)\n",
          newcl + 68164,
          v40,
          *(newcl + 175136));
        *newcl = 2;
        *(newcl + 17159) = svs_time;
        *(newcl + 17160) = svs_time;
        *(newcl + 17161) = svs_time;
        *(newcl + 16775) = -1;
        v33 = 0;
        *v46 = 0;
        v44 = svs_clients;
        while ( *v46 < *(dword_8494A64 + 32) )
        {
          if ( *(svs_clients + 175149 * *v46) > 1 )
            ++v33;
          ++*v46;
          v44 += 175149;
        }
        if ( v33 == 1 || v33 == *(dword_8494A64 + 32) )
          sub_8089336();
      }
    }
  }
  else
  {
    sub_8084D76(1, a1, a2, a3, a4, a5, "error\nEXE_ERR_LOW_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too high ping: %i\n", *v46, v29);
  }
}
// 808B7BA: variable 'v15' is possibly undefined
// 808B7BA: variable 'v16' is possibly undefined
// 808B7BA: variable 'v17' is possibly undefined
// 808B7BA: variable 'v18' is possibly undefined
// 808B7BA: variable 'v19' is possibly undefined
// 808B7BA: variable 'v20' is possibly undefined
// 808B7BA: variable 'v21' is possibly undefined
// 808B7BA: variable 'v22' is possibly undefined
// 808B7BA: variable 'v23' is possibly undefined
// 808B7BA: variable 'v24' is possibly undefined
// 8494A20: using guessed type int dword_8494A20;
// 8494A4C: using guessed type int dword_8494A4C;
// 8494A64: using guessed type int dword_8494A64;
// 84F6FB4: using guessed type int dword_84F6FB4;
// 84F6FDC: using guessed type int dword_84F6FDC;
// 84F6FE0: using guessed type int dword_84F6FE0;
// 84F7008: using guessed type int svs_time;
// 84F7060: using guessed type int dword_84F7060[];
// 84F7064: using guessed type int dword_84F7064[];
// 84F7068: using guessed type int dword_84F7068[];
// 84F706C: using guessed type int dword_84F706C[];
// 84F7070: using guessed type int dword_84F7070[];
// 84F7074: using guessed type int dword_84F7074[];
// 84F707C: using guessed type int dword_84F707C[];
// 84F7084: using guessed type int dword_84F7084[];
// 84F7088: using guessed type int dword_84F7088[];

//----- (0808B9B5) --------------------------------------------------------
int sub_808B9B5()
{
  int result; // eax
  int *i; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = svs_clients; ; i += 175149 )
  {
    result = v2;
    if ( v2 >= *(dword_8494A64 + 32) )
      break;
    if ( *i > 1 )
    {
      sub_8094DE7(i);
      *(i + 350274) = sub_80A6AAC();
    }
    ++v2;
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0808BA15) --------------------------------------------------------
void __cdecl SV_DropClient(int drop, int a2)
{
  char *v2; // eax
  char dest[40]; // [esp+30h] [ebp-38h] BYREF
  int *v4; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  if ( *drop != 1 )
  {
    *(drop + 8) = 0;
    strcpy(dest, (drop + 68164));
    sub_808ABB3(drop);
    Com_DPrintf("Going to CS_ZOMBIE for %s\n", dest);
    *drop = 1;
    if ( !*(drop + 68160) )
    {
      v4 = dword_84F7060;
      i = 0;
      while ( i <= 1023 )
      {
        if ( sub_8084AF7(
               *(drop + 634952),
               *(drop + 634956),
               *(drop + 634960),
               *(drop + 634964),
               *(drop + 634968),
               *v4,
               v4[1],
               v4[2],
               v4[3],
               v4[4]) )
        {
          v4[10] = 0;
          break;
        }
        ++i;
        v4 += 21;
      }
    }
    if ( sub_8086A5A(a2, "EXE_DISCONNECTED") )
      sub_8092F86(0, 0, aE, dest, a2);
    Com_Printf("%i:%s %s\n", -91 * ((drop - svs_clients) >> 2));
    v2 = sub_8086D78("w \"%s\"", a2);
    sub_8092F86(drop, 1, v2, a2);
    for ( i = 0; i < *(dword_8494A64 + 32) && *(svs_clients + 175149 * i) <= 1; ++i )
      ;
    if ( i == *(dword_8494A64 + 32) )
      sub_8089336();
  }
}
// 8494A64: using guessed type int dword_8494A64;
// 84F7060: using guessed type int dword_84F7060[];

//----- (0808BBFF) --------------------------------------------------------
_DWORD *__cdecl sub_808BBFF(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( *a1 != 1 )
  {
    result = a1;
    if ( !a1[2] )
    {
      result = a2;
      a1[2] = a2;
    }
  }
  return result;
}

//----- (0808BC22) --------------------------------------------------------
void __cdecl sub_808BC22(int a1, int a2)
{
  SV_DropClient(svs_clients + 700596 * a1, a2);
}

//----- (0808BC48) --------------------------------------------------------
void *__cdecl SV_SendClientGameState(char *client)
{
  void *result; // eax
  int v2[8192]; // [esp+10h] [ebp-8138h] BYREF
  int msg[3]; // [esp+8010h] [ebp-138h] BYREF
  _DWORD v4[5]; // [esp+801Ch] [ebp-12Ch]
  int s[66]; // [esp+8030h] [ebp-118h] BYREF
  int *v6; // [esp+8138h] [ebp-10h]
  int i; // [esp+813Ch] [ebp-Ch]

  while ( *client && *(client + 166940) )
    SV_Netchan_TransmitNextFragment(client + 158736);
  Com_DPrintf("SV_SendClientGameState() for %s\n", client + 68164);
  Com_DPrintf("Going from CS_CONNECTED to CS_PRIMED for %s\n", client + 68164);
  *client = 3;
  *(client + 158735) = 0;
  *(client + 16775) = *(client + 158745);
  MSG_Init(msg, v2, 32768);
  MSG_WriteLong(msg, *(client + 16783));
  SV_UpdateServerCommandsToClient(client, msg);
  MSG_WriteByte(msg, 2);
  MSG_WriteLong(msg, *(client + 16771));
  for ( i = 0; i <= 2047; ++i )
  {
    if ( *(&dword_8494E98)[i] )
    {
      MSG_WriteByte(msg, 3);
      MSG_WriteShort(msg, i);
      MSG_WriteBigString(msg, (&dword_8494E98)[i]);
    }
  }
  memset(s, 0, 0xF4u);
  for ( i = 0; i <= 1023; ++i )
  {
    v6 = (384 * i + 139030176);
    if ( *(&unk_8496EA0 + 96 * i) )
    {
      MSG_WriteByte(msg, 4);
      MSG_WriteDeltaEntity(msg, s, v6, 1);
    }
  }
  MSG_WriteByte(msg, 8);
  MSG_WriteLong(msg, -1067678811 * ((client - svs_clients) >> 2));
  MSG_WriteLong(msg, dword_8494A8C);
  MSG_WriteByte(msg, 8);
  Com_DPrintf("Sending %i bytes in gamestate to client: %i\n", v4[0], -1067678811 * ((client - svs_clients) >> 2));
  SV_SendMessageToClient(msg, client);
  result = dword_8488714;
  if ( !*(dword_8488714 + 32) )
  {
    result = client;
    if ( *client )
    {
      result = client;
      if ( *(client + 166940) )
        result = SV_Netchan_TransmitNextFragment(client + 158736);
    }
  }
  return result;
}
// 8488714: using guessed type int dword_8488714;
// 8494A8C: using guessed type int dword_8494A8C;

//----- (0808BF31) --------------------------------------------------------
#error "808C00F: call analysis failed (funcsize=57)"

//----- (0808C016) --------------------------------------------------------
int *__cdecl sub_808C016(int a1)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  if ( *(a1 + 68260) )
    FS_FCloseFile(*(a1 + 68260));
  *(a1 + 68260) = 0;
  result = (a1 + 68196);
  *(a1 + 68196) = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( *(a1 + 4 * i + 68284) )
    {
      sub_806BB25(*(a1 + 4 * i + 68284));
      *(a1 + 4 * i + 68284) = 0;
    }
    result = &i;
  }
  return result;
}

//----- (0808C09F) --------------------------------------------------------
int *__cdecl SV_StopDownload_f(int a1)
{
  if ( *(a1 + 68196) )
    Com_DPrintf("clientDownload: %d : file \"%s\" aborted\n", -1067678811 * ((a1 - svs_clients) >> 2), (a1 + 68196));
  return sub_808C016(a1);
}

//----- (0808C0EF) --------------------------------------------------------
void *__cdecl sub_808C0EF(int a1)
{
  Com_DPrintf("clientDownload: %s Done\n", (a1 + 68164));
  return SV_SendClientGameState(a1);
}

//----- (0808C11A) --------------------------------------------------------
int __cdecl sub_808C11A(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = sub_805FF28(1u);
  result = atoi(v1);
  if ( result == *(a1 + 68272) )
  {
    result = a1;
    *(a1 + 68280) = *(a1 + 68272);
  }
  return result;
}

//----- (0808C159) --------------------------------------------------------
void __cdecl sub_808C159(int client)
{
  char *v1; // eax
  int v2; // [esp+24h] [ebp-4h]

  v1 = sub_805FF28(1u);
  v2 = atoi(v1);
  if ( v2 == *(client + 68272) )
  {
    Com_DPrintf(
      "clientDownload: %d : client acknowledge of block %d\n",
      -1067678811 * ((client - svs_clients) >> 2),
      v2);
    if ( *(client + 4 * (*(client + 68272) % 8) + 68316) )
    {
      *(client + 68352) = svs_time;
      ++*(client + 68272);
    }
    else
    {
      Com_Printf(
        "clientDownload: %d : file \"%s\" completed\n",
        -1067678811 * ((client - svs_clients) >> 2),
        (client + 68196));
      sub_808C016(client);
    }
  }
  else
  {
    SV_DropClient(client, "broken download");
  }
}
// 84F7008: using guessed type int svs_time;

//----- (0808C25D) --------------------------------------------------------
char *__cdecl sub_808C25D(int a1)
{
  char *v1; // eax

  sub_808C016(a1);
  v1 = sub_805FF28(1u);
  return Q_strncpyz((a1 + 68196), v1, 64);
}

//----- (0808C298) --------------------------------------------------------
void __cdecl sub_808C298(int a1)
{
  char *v1; // [esp+14h] [ebp-4h]

  v1 = sub_805FF28(1u);
  if ( !*(a1 + 68616) )
    goto LABEL_2;
  if ( sub_8086A5A(v1, "ack") )
  {
    if ( sub_8086A5A(v1, "bbl8r") )
    {
      if ( !*(a1 + 68620) )
      {
LABEL_2:
        Com_Printf("SV_WWWDownload: unexpected wwwdl '%s' for client '%s'\n", v1, (a1 + 68164));
        SV_DropClient(a1, "GMI_EXE_UNEXPECTEDWWWDOWLOADMESSAGE");
        return;
      }
      if ( sub_8086A5A(v1, "done") )
      {
        if ( sub_8086A5A(v1, "fail") )
        {
          if ( sub_8086A5A(v1, "chkfail") )
          {
            Com_Printf("SV_WWWDownload: unknown wwwdl subcommand '%s' for client '%s'\n", v1, (a1 + 68164));
            SV_DropClient(a1, "GMI_EXE_UNEXPECTEDWWWDOWLOADMESSAGE");
          }
          else
          {
            Com_Printf(
              "WARNING: client '%s' reports that the redirect download for '%s' had wrong checksum.\n",
              (a1 + 68164),
              (a1 + 68196));
            Com_Printf("         you should check your download redirect configuration.\n");
            *(a1 + 68260) = 0;
            *(a1 + 68196) = 0;
            *(a1 + 68620) = 0;
            *(a1 + 68624) = 1;
            SV_SendClientGameState(a1);
          }
        }
        else
        {
          *(a1 + 68260) = 0;
          *(a1 + 68196) = 0;
          *(a1 + 68620) = 0;
          *(a1 + 68624) = 1;
          SV_SendClientGameState(a1);
        }
      }
      else
      {
        *(a1 + 68260) = 0;
        *(a1 + 68196) = 0;
        *(a1 + 68620) = 0;
      }
    }
    else
    {
      SV_DropClient(a1, "GMI_EXE_DOWNLOADDISCONNECTED");
    }
  }
  else
  {
    if ( *(a1 + 68620) )
      Com_Printf("WARNING: dupe wwwdl ack from client '%s'\n", (a1 + 68164));
    *(a1 + 68620) = 1;
  }
}

//----- (0808C503) --------------------------------------------------------
int __cdecl sub_808C503(int a1, _DWORD *a2)
{
  int result; // eax

  MSG_WriteByte(a2, 6);
  MSG_WriteShort(a2, 0);
  MSG_WriteLong(a2, -1);
  result = a1 + 68196;
  *(a1 + 68196) = 0;
  return result;
}

//----- (0808C54F) --------------------------------------------------------
int sub_808C54F()
{
  return 1;
}

//----- (0808C559) --------------------------------------------------------
int __cdecl SV_WriteDownloadToClient(int client, int msg)
{
  int result; // eax
  char *v3; // eax
  int v4; // ebx
  int v5; // ebx
  int v6; // [esp+30h] [ebp-428h]
  int v7; // [esp+34h] [ebp-424h]
  int v8; // [esp+38h] [ebp-420h] BYREF
  int v9; // [esp+3Ch] [ebp-41Ch]
  char s[1024]; // [esp+40h] [ebp-418h] BYREF
  int v11; // [esp+440h] [ebp-18h]
  int v12; // [esp+444h] [ebp-14h] BYREF
  int rate; // [esp+448h] [ebp-10h]
  int v14; // [esp+44Ch] [ebp-Ch]

  result = client + 68196;
  if ( !*(client + 68196) )
    return result;
  result = client;
  if ( *(client + 68620) )
    return result;
  if ( *(client + 68260) )
  {
LABEL_29:
    while ( *(client + 68276) - *(client + 68272) <= 7 && *(client + 68264) != *(client + 68268) )
    {
      v6 = *(client + 68276);
      v14 = v6 % 8;
      if ( !*(client + 4 * (v6 % 8) + 68284) )
      {
        v4 = v14;
        *(client + 4 * v4 + 68284) = sub_806BB38(0x800u);
      }
      v5 = v14;
      *(client + 4 * v5 + 68316) = sub_8062853(*(client + 4 * v14 + 68284), 0x800u, *(client + 68260));
      if ( *(client + 4 * v14 + 68316) < 0 )
      {
        *(client + 68268) = *(client + 68264);
        break;
      }
      *(client + 68268) += *(client + 4 * v14 + 68316);
      ++*(client + 68276);
    }
    if ( *(client + 68268) == *(client + 68264) && !*(client + 68348) && *(client + 68276) - *(client + 68272) <= 7 )
    {
      *(client + 4 * ((*(client + 68276))++ % 8) + 68316) = 0;
      *(client + 68348) = 1;
    }
    rate = *(client + 634932);
    if ( *(dword_84F6FAC + 32) )
    {
      if ( *(dword_84F6FAC + 32) <= 999 )
        sub_8073798("sv_MaxRate", "1000");
      if ( *(dword_84F6FAC + 32) < rate )
        rate = *(dword_84F6FAC + 32);
    }
    if ( rate )
      v12 = (*(client + 634936) * rate / 1000 + 2048) / 2048;
    else
      v12 = 1;
    if ( v12 < 0 )
      v12 = 1;
    while ( 1 )
    {
      result = &v12;
      if ( --v12 == -1 )
        break;
      result = *(client + 68272);
      if ( result == *(client + 68276) )
        break;
      if ( *(client + 68280) == *(client + 68276) )
      {
        result = svs_time - *(client + 68352);
        if ( result <= 1000 )
          return result;
        *(client + 68280) = *(client + 68272);
      }
      v14 = *(client + 68280) % 8;
      MSG_WriteByte(msg, 6);
      MSG_WriteShort(msg, *(client + 68280));
      if ( !*(client + 68280) )
        MSG_WriteLong(msg, *(client + 68264));
      MSG_WriteShort(msg, *(client + 4 * v14 + 68316));
      if ( *(client + 4 * v14 + 68316) )
        MSG_WriteData(msg, *(client + 4 * v14 + 68284), *(client + 4 * v14 + 68316));
      Com_DPrintf(
        "clientDownload: %d : writing block %d\n",
        -1067678811 * ((client - svs_clients) >> 2),
        *(client + 68280));
      ++*(client + 68280);
      *(client + 68352) = svs_time;
    }
  }
  else
  {
    Com_DPrintf("clientDownload: %d : begining \"%s\"\n", -1067678811 * ((client - svs_clients) >> 2), (client + 68196));
    v11 = sub_8075B82((client + 68196), "main", *(dword_8484360 + 4));
    if ( !*(dword_84F6FC0 + 32) || v11 )
    {
      if ( v11 )
      {
        Com_Printf("clientDownload: %d : \"%s\" cannot download id pk3 files\n", -91 * ((client - svs_clients) >> 2));
        Com_sprintf(s, 0x400u, aExeCantautodlg, client + 68196);
      }
      else if ( *(dword_84F6FC0 + 32) )
      {
        Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", -91 * ((client - svs_clients) >> 2));
        Com_sprintf(s, 0x400u, aExeAutodlFilen, client + 68196);
      }
      else
      {
        Com_Printf("clientDownload: %d : \"%s\" download disabled", -91 * ((client - svs_clients) >> 2));
        if ( *(dword_84F6FB8 + 32) )
          Com_sprintf(s, 0x400u, aExeAutodlServe, client + 68196);
        else
          Com_sprintf(s, 0x400u, aExeAutodlServe_0, client + 68196);
      }
      MSG_WriteByte(msg, 6);
      MSG_WriteShort(msg, 0);
      MSG_WriteLong(msg, -1);
      sub_8080607(msg, s);
      result = client + 68196;
      *(client + 68196) = 0;
      return result;
    }
    if ( *(dword_8494A50 + 32) )
    {
      if ( *(client + 68356) )
      {
        if ( *(client + 68624) )
        {
          *(client + 68624) = 0;
          result = sub_808C54F();
          if ( result )
            return result;
          Com_Printf("Client '%s': falling back to regular downloading for failed file %s\n", client + 100);
        }
        else
        {
          v7 = sub_8074C2E((client + 68196), &v8);
          if ( v7 )
          {
            FS_FCloseFile(v8);
            v3 = sub_8086D78("%s/%s", *(dword_8494A44 + 4), (client + 68196));
            Q_strncpyz((client + 68360), v3, 256);
            Com_DPrintf("Redirecting client '%s' to %s\n", (client + 68164), (client + 68360));
            *(client + 68616) = 1;
            MSG_WriteByte(msg, 6);
            MSG_WriteShort(msg, -1);
            sub_8080607(msg, (client + 68360));
            MSG_WriteLong(msg, v7);
            v9 = 0;
            if ( *(dword_8494A5C + 32) )
              v9 |= 1u;
            return MSG_WriteLong(msg, v9);
          }
          Com_Printf("ERROR: Client '%s': couldn't extract file size for %s\n", client + 100);
        }
      }
      else
      {
        result = sub_808C54F();
        if ( result )
          return result;
        Com_Printf("Client '%s' is not configured for www download\n", client + 68);
      }
    }
    *(client + 68616) = 0;
    *(client + 68264) = sub_8074C2E((client + 68196), client + 68260);
    if ( *(client + 68264) > 0 )
    {
      *(client + 68280) = 0;
      *(client + 68272) = 0;
      *(client + 68276) = 0;
      *(client + 68268) = 0;
      *(client + 68348) = 0;
      goto LABEL_29;
    }
    Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", -91 * ((client - svs_clients) >> 2));
    Com_sprintf(s, 0x400u, aExeAutodlFilen, client + 68196);
    sub_808C503(client, msg);
    result = sub_8080607(msg, s);
  }
  return result;
}
// 8484360: using guessed type int dword_8484360;
// 8494A44: using guessed type int dword_8494A44;
// 8494A50: using guessed type int dword_8494A50;
// 8494A5C: using guessed type int dword_8494A5C;
// 84F6FAC: using guessed type int dword_84F6FAC;
// 84F6FB8: using guessed type int dword_84F6FB8;
// 84F6FC0: using guessed type int dword_84F6FC0;
// 84F7008: using guessed type int svs_time;

//----- (0808CF08) --------------------------------------------------------
void __cdecl sub_808CF08(int a1)
{
  SV_DropClient(a1, "EXE_DISCONNECTED");
}

//----- (0808CF23) --------------------------------------------------------
int __cdecl sub_808CF23(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  int v5; // eax
  signed int v6; // ebx
  char *v7; // eax
  signed int v8; // ebx
  char *v9; // eax
  int result; // eax
  unsigned int v11; // [esp+0h] [ebp-2048h]
  unsigned int v12; // [esp+0h] [ebp-2048h]
  unsigned int v13; // [esp+0h] [ebp-2048h]
  unsigned int v14; // [esp+0h] [ebp-2048h]
  _BOOL4 v15; // [esp+14h] [ebp-2034h]
  char *nptr; // [esp+18h] [ebp-2030h]
  char *nptra; // [esp+18h] [ebp-2030h]
  char *v18; // [esp+1Ch] [ebp-202Ch]
  int v19[2049]; // [esp+20h] [ebp-2028h]
  int v20; // [esp+2024h] [ebp-24h]
  int j; // [esp+2028h] [ebp-20h]
  signed int i; // [esp+202Ch] [ebp-1Ch]
  int v23; // [esp+2030h] [ebp-18h]
  int v24; // [esp+2034h] [ebp-14h]
  int v25; // [esp+2038h] [ebp-10h] BYREF
  int v26[3]; // [esp+203Ch] [ebp-Ch] BYREF

  v25 = 0;
  v26[0] = 0;
  v1 = sub_8075080("wqaeicogaoraz:80fnn", -2);
  v2 = sub_8075187(v1, v26);
  v15 = v2 == 1;
  if ( v2 == 1 )
  {
    v3 = sub_8075080("ztdzndrud}=;3iqq", -5);
    v15 = sub_8075187(v3, &v25) == 1;
  }
  v24 = sub_805FF1E();
  v20 = 1;
  if ( v15 )
  {
    if ( v24 > 5 )
    {
      v11 = v20++;
      nptr = sub_805FF28(v11);
      if ( nptr && *nptr != 64 && (v4 = atoi(nptr), v4 == v26[0]) )
      {
        v12 = v20++;
        nptra = sub_805FF28(v12);
        if ( nptra && *nptra != 64 && (v5 = atoi(nptra), v5 == v25) )
        {
          v13 = v20++;
          if ( *sub_805FF28(v13) == 64 )
          {
            i = 0;
            while ( v20 < v24 )
            {
              v6 = i;
              v14 = v20++;
              v7 = sub_805FF28(v14);
              v19[v6 + 1024] = atoi(v7);
              ++i;
            }
            v24 = i - 1;
            for ( i = 0; i < v24; ++i )
            {
              for ( j = 0; j < v24; ++j )
              {
                if ( i != j && v19[i + 1024] == v19[j + 1024] )
                {
                  v15 = 0;
                  break;
                }
              }
              if ( !v15 )
                break;
            }
            if ( v15 )
            {
              v18 = sub_8076406();
              sub_8060257(v18);
              v23 = sub_805FF1E();
              if ( v23 > 1024 )
                v23 = 1024;
              for ( i = 0; i < v23; ++i )
              {
                v8 = i;
                v9 = sub_805FF28(i);
                v19[v8] = atoi(v9);
              }
              for ( i = 0; i < v24; ++i )
              {
                for ( j = 0; j < v23 && v19[i + 1024] != v19[j]; ++j )
                  ;
                if ( j >= v23 )
                {
                  v15 = 0;
                  break;
                }
              }
              if ( v15 )
              {
                v26[0] = dword_8494A8C;
                for ( i = 0; i < v24; ++i )
                  v26[0] ^= v19[i + 1024];
                v26[0] ^= v24;
                if ( v26[0] != v19[v24 + 1024] )
                  v15 = 0;
              }
            }
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 0;
        }
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = 0;
    }
  }
  result = a1;
  if ( v15 )
    *(a1 + 634940) = 1;
  else
    *(a1 + 634940) = 2;
  return result;
}
// 8494A8C: using guessed type int dword_8494A8C;

//----- (0808D2B5) --------------------------------------------------------
int __cdecl sub_808D2B5(int a1)
{
  int result; // eax

  result = a1;
  *(a1 + 634940) = 0;
  return result;
}

//----- (0808D2C7) --------------------------------------------------------
const char *__cdecl SV_UserInfoChanged(int a1)
{
  char *v1; // eax
  const char *result; // eax
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+20h] [ebp-8h]
  char *nptr; // [esp+24h] [ebp-4h]
  char *nptra; // [esp+24h] [ebp-4h]
  char *nptrb; // [esp+24h] [ebp-4h]

  v1 = sub_8086E7F((a1 + 12), "name");
  Q_strncpyz((a1 + 68164), v1, 32);
  if ( !sub_80CA1BC(*(a1 + 634952), *(a1 + 634956)) || *(dword_84886E0 + 32) == 2 )
  {
    nptr = sub_8086E7F((a1 + 12), "rate");
    if ( *nptr )
    {
      *(a1 + 634932) = atoi(nptr);
      if ( *(a1 + 634932) > 999 )
      {
        if ( *(a1 + 634932) > 90000 )
          *(a1 + 634932) = 90000;
      }
      else
      {
        *(a1 + 634932) = 1000;
      }
    }
    else
    {
      *(a1 + 634932) = 5000;
    }
  }
  else
  {
    *(a1 + 634932) = 99999;
  }
  nptra = sub_8086E7F((a1 + 12), "handicap");
  if ( *nptra )
  {
    v3 = atoi(nptra);
    if ( v3 <= 0 || v3 > 100 || strlen(nptra) > 4 )
      sub_808733D((a1 + 12), "handicap", "100");
  }
  nptrb = sub_8086E7F((a1 + 12), "snaps");
  if ( *nptrb )
  {
    v4 = atoi(nptrb);
    if ( v4 > 0 )
    {
      if ( v4 > 30 )
        v4 = 30;
    }
    else
    {
      v4 = 1;
    }
    *(a1 + 634936) = 1000 / v4;
  }
  else
  {
    *(a1 + 634936) = 50;
  }
  result = sub_8086E7F((a1 + 12), "cl_wwwDownload");
  *(a1 + 68356) = 0;
  if ( *result )
  {
    result = atoi(result);
    if ( result )
    {
      result = a1;
      *(a1 + 68356) = 1;
    }
  }
  return result;
}
// 84886E0: using guessed type int dword_84886E0;

//----- (0808D514) --------------------------------------------------------
#error "808D573: call analysis failed (funcsize=26)"

//----- (0808D57A) --------------------------------------------------------
#error "808D622: call analysis failed (funcsize=51)"

//----- (0808D629) --------------------------------------------------------
int __cdecl SV_ClientCommand(int client, int a2)
{
  char *v2; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int clientOK; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  int seq; // [esp+24h] [ebp-4h]

  clientOK = 1;
  v5 = 1;
  seq = sub_80808EC(a2);
  s = sub_808093F(a2);
  if ( *(client + 67132) >= seq )
    return 1;
  if ( *(dword_850C110 + 32) )
    Com_Printf("clientCommand: %i : %s\n", seq, s);
  if ( seq <= *(client + 67132) + 1 )
  {
    if ( !sub_80869EB("team ", s, 5) || !sub_80869EB("score ", s, 6) || !sub_80869EB("mr ", s, 3) )
      v5 = 0;
    if ( !*(dword_84898B8 + 32) && *client > 3 && *(dword_8494A38 + 32) && svs_time < *(client + 68632) && v5 )
    {
      clientOK = 0;
      v2 = sub_805FF28(0);
      Com_DPrintf("client text ignored for %s: %s\n", (client + 68164), v2);
    }
    if ( v5 )
      *(client + 68632) = svs_time + 800;
    SV_ExecuteClientCommand(client, s, clientOK);
    *(client + 67132) = seq;
    Com_sprintf((client + 67136), 1024u, "%s", s);
    v4 = 1;
  }
  else
  {
    Com_Printf("Client %s lost %i clientCommands\n", (client + 68164), seq - *(client + 67132) + 1);
    SV_DropClient(client, "EXE_LOSTRELIABLECOMMANDS");
    v4 = 0;
  }
  return v4;
}
// 808D57A: using guessed type _DWORD __cdecl SV_ExecuteClientCommand(_DWORD, _DWORD, _DWORD);
// 84898B8: using guessed type int dword_84898B8;
// 8494A38: using guessed type int dword_8494A38;
// 84F7008: using guessed type int svs_time;
// 850C110: using guessed type int dword_850C110;

//----- (0808D829) --------------------------------------------------------
#error "808D8A8: call analysis failed (funcsize=35)"

//----- (0808D8AF) --------------------------------------------------------
void __cdecl SV_UserMove(char *client, int a2, int delta)
{
  int v3; // [esp+Ch] [ebp-34Ch]
  int v4; // [esp+10h] [ebp-348h]
  int v5; // [esp+14h] [ebp-344h]
  char *v6; // [esp+18h] [ebp-340h]
  _DWORD *v7; // [esp+1Ch] [ebp-33Ch]
  _DWORD v8[192]; // [esp+20h] [ebp-338h] BYREF
  char s[36]; // [esp+320h] [ebp-38h] BYREF
  int v10; // [esp+344h] [ebp-14h]
  int v11; // [esp+348h] [ebp-10h]
  int i; // [esp+34Ch] [ebp-Ch]
  char v13[8]; // [esp+350h] [ebp-8h] BYREF

  if ( delta )
    *(client + 17157) = *(client + 16774);
  else
    *(client + 17157) = -1;
  if ( *(client + 16771) - *(client + 16772) <= 63 )
  {
    v10 = sub_8080857(a2);
    if ( v10 > 0 )
    {
      if ( v10 <= 32 )
      {
        v11 = dword_8494A8C;
        v11 = *(client + 16774) ^ dword_8494A8C;
        v11 ^= sub_806BA16(&client[1032 * (*(client + 16772) & 63) + 1036], 32);
        v5 = sub_808E105(3227288485 * ((client - svs_clients) >> 2));
        sub_8080E16(v5, s);
        v6 = s;
        for ( i = 0; i < v10; ++i )
        {
          v7 = &v8[6 * i];
          sub_80814CE(a2, v11, v6, v7);
          if ( !VM_Call(gvm, 16, *(v7 + 6), v3, v4, v5, v6, v7, v8[0], v8[1], v8[2], v8[3], v8[4], v8[5]) )
            *(v7 + 6) = *(v5 + 216);
          v6 = v7;
        }
        *&client[17696 * (*(client + 16774) & 0x1F) + 86344] = svs_time;
        if ( *client == 3 )
        {
          sub_80C0C82(1);
          SV_ClientEnterWorld(client, v8);
        }
        if ( !*(dword_84F6FB8 + 32) || *(client + 158735) )
        {
          if ( *client == 4 )
          {
            for ( i = 0; i < v10; ++i )
            {
              if ( v8[6 * i] <= *&v13[24 * v10 - 840] && v8[6 * i] > *(client + 16777) )
                sub_808D829(client, &v8[6 * i]);
            }
          }
          else
          {
            *(client + 17157) = -1;
          }
        }
        else
        {
          SV_DropClient(client, "EXE_CANNOTVALIDATEPURECLIENT");
        }
      }
      else
      {
        Com_Printf("cmdCount > MAX_PACKET_USERCMDS\n");
      }
    }
    else
    {
      Com_Printf("cmdCount < 1\n");
    }
  }
}
// 8494A8C: using guessed type int dword_8494A8C;
// 84F6FB8: using guessed type int dword_84F6FB8;
// 84F7008: using guessed type int svs_time;

//----- (0808DBA1) --------------------------------------------------------
void __cdecl SV_ExecuteClientMessage(int client, _DWORD *msg)
{
  _BYTE v2[32768]; // [esp+20h] [ebp-8038h] BYREF
  _DWORD s[11]; // [esp+8020h] [ebp-38h] BYREF
  _DWORD v4[3]; // [esp+804Ch] [ebp-Ch]

  MSG_Init(s, v2, 0x8000);
  s[3] = sub_8080473(msg[1] + msg[4], v2, msg[3] - msg[4]);
  if ( *(client + 700556) == *dword_80F5100 || *(client + 68196) )
  {
    while ( 1 )
    {
      v4[0] = sub_8080344(s, 2);
      if ( v4[0] == 3 || v4[0] != 2 )
        break;
      if ( !SV_ClientCommand(client, s) || *client == 1 )
        return;
    }
    if ( *(dword_84F6FB8 + 32) && *(client + 634940) == 2 )
    {
      *(client + 68644) = -1;
      *client = 4;
      SV_SendClientSnapshot(client);
      SV_DropClient(client, "EXE_UNPURECLIENTDETECTED");
    }
    if ( v4[0] )
    {
      if ( v4[0] == 1 )
      {
        SV_UserMove(client, s, 0);
      }
      else if ( v4[0] != 3 )
      {
        Com_Printf("WARNING: bad command byte %i for client %i\n", v4[0], -1067678811 * ((client - svs_clients) >> 2));
      }
    }
    else
    {
      SV_UserMove(client, s, 1);
    }
  }
  else if ( (*(client + 700556) & 0xF0) == (dword_80F5100[0] & 0xF0) )
  {
    if ( *client == 3 )
    {
      sub_80C0C82(1);
      SV_ClientEnterWorld(client, (client + 67108));
    }
  }
  else if ( *(client + 67096) > *(client + 67100) )
  {
    Com_DPrintf("%s : dropped gamestate, resending\n", (client + 68164));
    SV_SendClientGameState(client);
    if ( *(dword_8489A60 + 32) || !sub_80CA1BC(*(client + 634952), *(client + 634956)) )
      sub_8089C3F(
        *(client + 634952),
        *(client + 634956),
        *(client + 634960),
        *(client + 634964),
        *(client + 634968),
        *(client + 67104));
  }
}
// 8489A60: using guessed type int dword_8489A60;
// 84F6FB8: using guessed type int dword_84F6FB8;

//----- (0808DE54) --------------------------------------------------------
int sub_808DE54()
{
  _DWORD v2[10]; // [esp+40h] [ebp-458h] BYREF
  char *i; // [esp+68h] [ebp-430h]
  int v4; // [esp+6Ch] [ebp-42Ch]
  int v5; // [esp+70h] [ebp-428h] BYREF
  int v6; // [esp+74h] [ebp-424h]
  int v7; // [esp+78h] [ebp-420h]
  int v8; // [esp+7Ch] [ebp-41Ch]
  int v9; // [esp+80h] [ebp-418h]
  char s[1032]; // [esp+90h] [ebp-408h] BYREF

  v4 = 0;
  for ( i = svs_clients; v4 < *(dword_8494A64 + 32) && *i; i += 700596 )
    ++v4;
  if ( v4 == *(dword_8494A64 + 32) )
    return -1;
  sprintf(
    s,
    "connect \"\\cl_guid\\unknown\\cg_predictItems\\1\\cl_punkbuster\\0\\cl_anonymous\\0\\handicap\\100\\color\\4\\head\\"
    "default\\model\\multi\\snaps\\20\\rate\\5000\\name\\bot%d\\protocol\\%d\"",
    dword_80F4FD8,
    22);
  sub_8060257(s);
  memset(&v5, 0, 0x14u);
  v5 = 0;
  HIWORD(v9) = dword_80F4FD8++;
  SVC_DirectConnect(0, v6, v7, v8, v9);
  v4 = 0;
  for ( i = svs_clients;
        v4 < *(dword_8494A64 + 32)
     && (!*i
      || !sub_80848CB(v5, v6, v7, v8, v9, *(i + 158738), *(i + 158739), *(i + 158740), *(i + 158741), *(i + 158742)));
        i += 700596 )
  {
    ++v4;
  }
  if ( v4 == *(dword_8494A64 + 32) )
    return -1;
  sub_80C0C82(1);
  *(i + 175138) = 1;
  SV_SendClientGameState(i);
  memset(v2, 0, 0x18u);
  SV_ClientEnterWorld(i, v2);
  return v4;
}
// 80F4FD8: using guessed type int dword_80F4FD8;
// 8494A64: using guessed type int dword_8494A64;

//----- (0808E0E8) --------------------------------------------------------
int __cdecl SV_GentityNum(int a1)
{
  return dword_84F6E9C + a1 * dword_84F6EA0;
}
// 84F6E9C: using guessed type int dword_84F6E9C;
// 84F6EA0: using guessed type int dword_84F6EA0;

//----- (0808E105) --------------------------------------------------------
int __cdecl sub_808E105(int a1)
{
  return dword_84F6EA8 + a1 * dword_84F6EAC;
}
// 84F6EA8: using guessed type int dword_84F6EA8;
// 84F6EAC: using guessed type int dword_84F6EAC;

//----- (0808E122) --------------------------------------------------------
int __cdecl sub_808E122(int *a1)
{
  char savedregs; // [esp+8h] [ebp+0h]

  if ( !a1 || *a1 < 0 || *a1 > 1023 )
    sub_80704AC(1, &byte_80E4E60, savedregs);
  return 384 * *a1 + 139030168;
}
// 808E152: variable 'savedregs' is possibly undefined

//----- (0808E16C) --------------------------------------------------------
int __cdecl sub_808E16C(int a1)
{
  return SV_GentityNum(-1431655765 * ((a1 + -&dword_8494A80 - 9240) >> 7));
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0808E19A) --------------------------------------------------------
int __cdecl sub_808E19A(int a1, int a2, const char *a3)
{
  int result; // eax

  if ( a1 == -1 )
    return sub_8092F86(0, a2, "%s", a3);
  if ( a1 >= 0 )
  {
    result = a1;
    if ( a1 < *(dword_8494A64 + 32) )
      result = sub_8092F86(svs_clients + 700596 * a1, a2, "%s", a3);
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0808E20D) --------------------------------------------------------
void __cdecl sub_808E20D(int a1, int a2)
{
  if ( a1 >= 0 && a1 < *(dword_8494A64 + 32) )
    SV_DropClient(svs_clients + 700596 * a1, a2);
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0808E247) --------------------------------------------------------
int __cdecl sub_808E247(_DWORD *a1)
{
  int v2[4]; // [esp+10h] [ebp-38h] BYREF
  int v3[7]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+3Ch] [ebp-Ch]

  v4 = sub_804BD20(a1[35]);
  sub_804BF33(v4, v3, v2);
  a1[66] = v3[0];
  a1[67] = v3[1];
  a1[68] = v3[2];
  a1[69] = v2[0];
  a1[70] = v2[1];
  a1[71] = v2[2];
  a1[65] = 1;
  a1[72] = -1;
  return sub_8099DEE(a1);
}

//----- (0808E2E9) --------------------------------------------------------
_BOOL4 __cdecl sub_808E2E9(float *a1, float *a2)
{
  _BOOL4 v3; // [esp+10h] [ebp-18h]
  char *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = sub_805723E(a1);
  v7 = sub_804BD70(v9);
  v6 = sub_804BD86(v9);
  v4 = sub_805784E(v7);
  v10 = sub_805723E(a2);
  v8 = sub_804BD70(v10);
  v5 = sub_804BD86(v10);
  if ( !v4 || ((v4[v8 >> 3] >> (v8 & 7)) & 1) != 0 )
    v3 = sub_8057ABD(v6, v5);
  else
    v3 = 0;
  return v3;
}

//----- (0808E3A9) --------------------------------------------------------
int __cdecl sub_808E3A9(float *a1, int a2)
{
  int v3; // [esp+8h] [ebp-40h]
  int v4; // [esp+Ch] [ebp-3Ch]
  int v5; // [esp+10h] [ebp-38h]
  int v6; // [esp+14h] [ebp-34h]
  int v7; // [esp+18h] [ebp-30h]
  _BOOL4 v8; // [esp+18h] [ebp-30h]
  int v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+1Ch] [ebp-2Ch]
  int v11; // [esp+20h] [ebp-28h]
  char *v12; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int v14; // [esp+30h] [ebp-18h]
  int v15; // [esp+34h] [ebp-14h]
  int v16; // [esp+38h] [ebp-10h]
  int v17; // [esp+3Ch] [ebp-Ch]
  _DWORD *v18; // [esp+40h] [ebp-8h]
  int *v19; // [esp+44h] [ebp-4h]

  v19 = SV_GentityNum(a2);
  if ( !v19[61] )
    return 0;
  if ( (v19[62] & 1) != 0 )
    return 0;
  if ( (v19[62] & 0x18) != 0 || v19[64] )
    return 1;
  v18 = sub_808E122(v19);
  v15 = sub_805723E(a1);
  v17 = sub_804BD86(v15);
  if ( !sub_8057ABD(v17, v18[89]) && !sub_8057ABD(v17, v18[90]) )
    return 0;
  if ( !v18[71] )
    return 0;
  v16 = sub_804BD70(v15);
  v12 = sub_805784E(v16);
  v14 = 0;
  for ( i = 0; i < v18[71]; ++i )
  {
    v14 = v18[i + 72];
    if ( ((v12[v14 >> 3] >> (v14 & 7)) & 1) != 0 )
      break;
  }
  if ( i != v18[71] )
    goto LABEL_25;
  if ( !v18[88] )
    return 0;
  while ( v14 <= v18[88] && ((v12[v14 >> 3] >> (v14 & 7)) & 1) == 0 )
    ++v14;
  if ( v14 == v18[88] )
    return 0;
LABEL_25:
  v10 = COERCE_FLOAT(VM_Call(gvm, 23, v3, v4, v5, v6, v7, v9, v11, v12, v12, i, v14, v15));
  if ( v10 == 3.4028235e38 )
    v8 = 1;
  else
    v8 = !sub_806AB7E((v19 + 73), (v19 + 76), a1, v10);
  return v8;
}
// 808E59C: variable 'v3' is possibly undefined
// 808E59C: variable 'v4' is possibly undefined
// 808E59C: variable 'v5' is possibly undefined
// 808E59C: variable 'v6' is possibly undefined
// 808E59C: variable 'v7' is possibly undefined
// 808E59C: variable 'v9' is possibly undefined
// 808E59C: variable 'v11' is possibly undefined

//----- (0808E60E) --------------------------------------------------------
_BOOL4 __cdecl sub_808E60E(float *a1, float *a2)
{
  int v2; // eax
  int v3; // eax
  char *v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v2 = sub_805723E(a1);
  v3 = sub_804BD70(v2);
  v6 = sub_805784E(v3);
  v8 = sub_805723E(a2);
  v7 = sub_804BD70(v8);
  return !v6 || ((v6[v7 >> 3] >> (v7 & 7)) & 1) != 0;
}

//----- (0808E693) --------------------------------------------------------
int __cdecl sub_808E693(int *a1, int a2)
{
  int result; // eax

  result = sub_808E122(a1);
  if ( *(result + 360) != -1 )
    result = sub_80579A3(*(result + 356), *(result + 360), a2);
  return result;
}

//----- (0808E6DC) --------------------------------------------------------
int __cdecl sub_808E6DC(int *a1, int *a2, int a3, int a4)
{
  int v5[11]; // [esp+30h] [ebp-48h] BYREF
  unsigned __int8 v6; // [esp+5Fh] [ebp-19h]
  int v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int v9; // [esp+6Ch] [ebp-Ch]

  v9 = a3 + 316;
  v8 = a3 + 328;
  v7 = sub_8099CA0(a3);
  sub_805B5B0(v5, &dword_80DD708, &dword_80DD708, a1, a2, v7, -1, (a3 + 316), (a3 + 328), a4);
  return v6;
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0808E759) --------------------------------------------------------
char *__cdecl sub_808E759(char *dest, int a2)
{
  char *v2; // eax

  if ( a2 <= 0 )
    sub_80704AC(1, &byte_80E4EA0, a2);
  v2 = sub_8074863(8196);
  return Q_strncpyz(dest, v2, a2);
}

//----- (0808E7A4) --------------------------------------------------------
void *__cdecl sub_808E7A4(size_t a1)
{
  if ( dword_8494A80 != 1 )
    sub_80704AC(1, &byte_80E4EE0);
  return sub_806C3D4(a1);
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0808E7D4) --------------------------------------------------------
void *__cdecl sub_808E7D4(size_t a1)
{
  if ( dword_8494A80 != 1 )
    sub_80704AC(1, &byte_80E4F40);
  return sub_806C531(a1);
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0808E804) --------------------------------------------------------
void *__cdecl sub_808E804(size_t n, int a2)
{
  if ( dword_8494A80 != 1 )
    sub_80704AC(1, &byte_80E4FA0);
  return sub_806C3EF(n, a2);
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0808E83B) --------------------------------------------------------
void *__cdecl sub_808E83B(size_t n, int a2)
{
  if ( dword_8494A80 != 1 )
    sub_80704AC(1, &byte_80E5000);
  return sub_806C54C(n, a2);
}
// 8494A80: using guessed type int dword_8494A80;

//----- (0808E872) --------------------------------------------------------
_DWORD *__cdecl sub_808E872(size_t size)
{
  return sub_806C600(size);
}

//----- (0808E885) --------------------------------------------------------
void __cdecl sub_808E885(void *ptr)
{
  sub_806C742(ptr);
}

//----- (0808E898) --------------------------------------------------------
int __cdecl sub_808E898(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  dword_84F6E9C = a1;
  dword_84F6EA0 = a3;
  dword_84F6EA4 = a2;
  dword_84F6EA8 = a4;
  result = a5;
  dword_84F6EAC = a5;
  return result;
}
// 84F6E9C: using guessed type int dword_84F6E9C;
// 84F6EA0: using guessed type int dword_84F6EA0;
// 84F6EA4: using guessed type int dword_84F6EA4;
// 84F6EA8: using guessed type int dword_84F6EA8;
// 84F6EAC: using guessed type int dword_84F6EAC;

//----- (0808E8C5) --------------------------------------------------------
int __cdecl sub_808E8C5(int a1, _DWORD *a2)
{
  _DWORD *v2; // edx
  int result; // eax

  if ( a1 < 0 || a1 >= *(dword_8494A64 + 32) )
    sub_80704AC(1, &byte_80E5080, a1);
  v2 = svs_clients;
  *a2 = *(svs_clients + 175149 * a1 + 16777);
  a2[1] = v2[175149 * a1 + 16778];
  a2[2] = v2[175149 * a1 + 16779];
  a2[3] = v2[175149 * a1 + 16780];
  a2[4] = v2[175149 * a1 + 16781];
  result = v2[175149 * a1 + 16782];
  a2[5] = result;
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0808E952) --------------------------------------------------------
int __cdecl sub_808E952(int a1)
{
  return a1;
}

//----- (0808E963) --------------------------------------------------------
int __cdecl sub_808E963(char *s1)
{
  if ( strncasecmp(s1, "xmodel", 6u) || s1[6] != 47 && s1[6] != 92 )
    sub_80704AC(1, &byte_80E50A8, s1);
  return sub_80C382C(s1 + 7, 0, sub_8072A79);
}

//----- (0808E9E3) --------------------------------------------------------
void __cdecl sub_808E9E3(int a1)
{
  int v1; // [esp+4h] [ebp-4h]

  if ( *(dword_8488708 + 32) )
  {
    v1 = sub_80725CB(a1);
    if ( v1 )
      sub_80C53B6(v1);
    else
      Com_Printf("no model.\n");
  }
}
// 8488708: using guessed type int dword_8488708;

//----- (0808EA25) --------------------------------------------------------
int __cdecl sub_808EA25(int a1, int a2)
{
  int *v4; // [esp+Ch] [ebp-Ch]
  int size; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80725CB(a1);
  if ( sub_80C6A4A(v6, dword_8488704) )
    return sub_80C5C08(v6, a2);
  size = sub_80C6A24(v6);
  v4 = sub_806C600(size);
  sub_80C6AC4(v6, v4);
  return 0;
}
// 8488704: using guessed type int dword_8488704;

//----- (0808EAA2) --------------------------------------------------------
int __cdecl sub_808EAA2(int a1, int a2)
{
  int *v4; // [esp+Ch] [ebp-Ch]
  int size; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_80725CB(a1);
  if ( sub_80C6A4A(v6, dword_8488704) )
    return sub_80C5C36(v6, a2);
  size = sub_80C6A24(v6);
  v4 = sub_806C600(size);
  sub_80C6AC4(v6, v4);
  return 0;
}
// 8488704: using guessed type int dword_8488704;

//----- (0808EB1F) --------------------------------------------------------
int __cdecl sub_808EB1F(int a1, float a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_80725CB(a1);
  if ( v5 )
    v4 = sub_80BF1A2(v5, a2, a3);
  else
    v4 = 0;
  return v4;
}

//----- (0808EB63) --------------------------------------------------------
void __cdecl sub_808EB63(int a1, float a2)
{
  int *v2; // [esp+14h] [ebp-4h]

  v2 = sub_80725CB(a1);
  if ( v2 )
    sub_80BF11C(v2, a2);
}

//----- (0808EB93) --------------------------------------------------------
int __cdecl sub_808EB93(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80725CB(a1);
  return sub_80C5832(v4, a2, a3);
}

//----- (0808EBC2) --------------------------------------------------------
int *__cdecl sub_808EBC2(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80725CB(a1);
  return sub_80BF2A8(v3, a2);
}

//----- (0808EBEA) --------------------------------------------------------
int *__cdecl sub_808EBEA(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_80725CB(a1);
  return sub_80C5C96(v3, a2);
}

//----- (0808EC12) --------------------------------------------------------
int __cdecl sub_808EC12(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_80725CB(a1);
  return sub_80C7232(v2);
}

//----- (0808EC33) --------------------------------------------------------
int __cdecl sub_808EC33(int a1, char *s)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80725CB(a1);
  if ( v4 )
    v3 = sub_80C70F0(v4, s);
  else
    v3 = -1;
  return v3;
}

//----- (0808EC70) --------------------------------------------------------
int __cdecl sub_808EC70(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_80725CB(a1);
  return sub_80C665C(v2, 0);
}

//----- (0808EC99) --------------------------------------------------------
void __cdecl sub_808EC99(int a1)
{
  int **v1; // [esp+4h] [ebp-4h]

  v1 = sub_80725CB(a1);
  if ( v1 )
    sub_80BF59A(v1);
}

//----- (0808ECC2) --------------------------------------------------------
int __cdecl sub_808ECC2(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_80725CB(a1);
  return sub_80C6B5A(v2);
}

//----- (0808ECE3) --------------------------------------------------------
int __cdecl sub_808ECE3(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80725CB(a1);
  return sub_80C6BF4(v4, a2, a3);
}

//----- (0808ED12) --------------------------------------------------------
int __cdecl sub_808ED12(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80725CB(a1);
  return sub_80C6C76(v4, a2, a3);
}

//----- (0808ED41) --------------------------------------------------------
int __cdecl sub_808ED41(int a1, _DWORD *a2, _DWORD *a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_80725CB(a1);
  return sub_80C6B36(v4, a2, a3);
}

//----- (0808ED70) --------------------------------------------------------
int __cdecl sub_808ED70(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_80725CB(a1);
  return sub_80C71DC(v2);
}

//----- (0808EE3D) --------------------------------------------------------
void sub_808EE3D()
{
  ;
}

//----- (0808EE42) --------------------------------------------------------
_BOOL4 __cdecl sub_808EE42(char *s)
{
  char *haystack; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8088020(s);
  haystack = sub_8086D78("maps/mp/%s.bsp", v3);
  return (sub_8062EB0(haystack, 0) & 0x80000000) == 0;
}

//----- (0808EE92) --------------------------------------------------------
void *sub_808EE92()
{
  void *result; // eax

  result = sub_804BD66();
  dword_84F6E98 = result;
  return result;
}
// 84F6E98: using guessed type int dword_84F6E98;

//----- (0808EEA4) --------------------------------------------------------
int __cdecl sub_808EEA4(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+0h] [ebp-58h]
  int v14; // [esp+0h] [ebp-58h]
  int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+4Ch] [ebp-Ch]
  int v17; // [esp+4Ch] [ebp-Ch]
  int v18; // [esp+4Ch] [ebp-Ch]
  int v19; // [esp+4Ch] [ebp-Ch]
  int v20; // [esp+4Ch] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-Ch]
  char *src; // [esp+50h] [ebp-8h]
  float v23; // [esp+54h] [ebp-4h]

  switch ( *a1 )
  {
    case 0:
      Com_Printf("%s", *(a1 + 4));
      v15 = 0;
      break;
    case 1:
      sub_80704AC(1, &byte_80E50D7, *(a1 + 4));
    case 2:
      sub_80704AC(1, "%s", *(a1 + 4));
    case 3:
      v15 = sub_80CA93C();
      break;
    case 4:
      sub_80738D4(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
      v15 = 0;
      break;
    case 5:
      sub_807392B(*(a1 + 4));
      v15 = 0;
      break;
    case 6:
      sub_8073798(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 7:
      v15 = sub_8073AE3(*(a1 + 4));
      break;
    case 8:
      v23 = sub_8073AB4(*(a1 + 4));
      **(a1 + 8) = v23;
      v15 = 0;
      break;
    case 9:
      sub_8073B45(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0xA:
      v15 = sub_805FF1E();
      break;
    case 0xB:
      sub_805FF54(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0xC:
      v15 = sub_808E7A4(*(a1 + 4));
      break;
    case 0xD:
      v15 = sub_808E7D4(*(a1 + 4));
      break;
    case 0xE:
      v15 = sub_808E804(*(a1 + 4), *(a1 + 8));
      break;
    case 0xF:
      v15 = sub_808E83B(*(a1 + 4), *(a1 + 8));
      break;
    case 0x10:
      v15 = sub_808E872(*(a1 + 4));
      break;
    case 0x11:
      sub_808E885(*(a1 + 4));
      v15 = 0;
      break;
    case 0x12:
      v15 = sub_8065D85(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x13:
      sub_8062853(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x14:
      v15 = sub_8062983(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x15:
      sub_8060FDD(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x16:
      FS_FCloseFile(*(a1 + 4));
      v15 = 0;
      break;
    case 0x17:
      sub_805FAF4(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x18:
      sub_808E898(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20));
      v15 = 0;
      break;
    case 0x19:
      if ( *(a1 + 4) >= 0 && *(a1 + 4) < *(dword_8494A64 + 32) )
        v15 = *(svs_clients + 175149 * *(a1 + 4) + 175136);
      else
        v15 = 0;
      break;
    case 0x1A:
      sub_808E20D(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x1B:
      sub_808E19A(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x1C:
      sub_8090DA8(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x1D:
      sub_8090F8C(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x1E:
      v15 = sub_8091016(*(a1 + 4));
      break;
    case 0x1F:
      v15 = sub_8084B24(*(svs_clients + 175149 * *(a1 + 4) + 158738));
      break;
    case 0x20:
      v15 = *(svs_clients + 175149 * *(a1 + 4) + 158732);
      break;
    case 0x21:
      sub_80911FD(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x22:
      sub_8091153(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x23:
      sub_808E759(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x24:
      sub_808E247(*(a1 + 4));
      v15 = 0;
      break;
    case 0x25:
      sub_809AFC9(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), 0, 0, 0, 0);
      v15 = 0;
      break;
    case 0x26:
      sub_809AFC9(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), 1, 0, 0, 0);
      v15 = 0;
      break;
    case 0x27:
      sub_809B4F1(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), *(a1 + 32), 0);
      v15 = 0;
      break;
    case 0x28:
      sub_809B4F1(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), *(a1 + 32), 1);
      v15 = 0;
      break;
    case 0x29:
      v15 = sub_809B8C5(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 1);
      break;
    case 0x2A:
      sub_805B145(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), 0);
      v15 = 0;
      break;
    case 0x2B:
      sub_805B145(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), 1);
      v15 = 0;
      break;
    case 0x2C:
      v15 = sub_805D459(0, *(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 0);
      break;
    case 0x2D:
      v15 = sub_805D459(0, *(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 1);
      break;
    case 0x2E:
      sub_809AFC9(*(a1 + 4), *(a1 + 8), 0, 0, *(a1 + 12), *(a1 + 16), *(a1 + 20), 0, 1, *(a1 + 24), 1);
      v15 = 0;
      break;
    case 0x2F:
      v15 = sub_809BB17(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x30:
      v15 = sub_808E2E9(*(a1 + 4), *(a1 + 8));
      break;
    case 0x31:
      v15 = sub_808E60E(*(a1 + 4), *(a1 + 8));
      break;
    case 0x32:
      v15 = sub_808E3A9(*(a1 + 4), *(a1 + 8));
      break;
    case 0x33:
      sub_808E693(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x34:
      v15 = sub_8057ABD(*(a1 + 4), *(a1 + 8));
      break;
    case 0x35:
      sub_8099DEE(*(a1 + 4));
      v15 = 0;
      break;
    case 0x36:
      sub_8099D49(*(a1 + 4));
      v15 = 0;
      break;
    case 0x37:
      v15 = sub_805E344(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20));
      break;
    case 0x38:
      v15 = sub_808E6DC(*(a1 + 4), *(a1 + 8), *(a1 + 12), 0);
      break;
    case 0x39:
      sub_808E8C5(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x3A:
      src = sub_8085E0B(&dword_84F6E98);
      Q_strncpyz(*(a1 + 4), src, *(a1 + 8));
      v15 = dword_84F6E98 || *src;
      break;
    case 0x3B:
      v15 = sub_8063F80(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
      break;
    case 0x3C:
      v15 = sub_808EE42(*(a1 + 4));
      break;
    case 0x3D:
      v15 = sub_806BA76(*(a1 + 4));
      break;
    case 0x3E:
      sub_80CB470(*(a1 + 4));
      v15 = 0;
      break;
    case 0x3F:
      v15 = sub_808E6DC(*(a1 + 4), *(a1 + 8), *(a1 + 12), 1);
      break;
    case 0x40:
      v15 = sub_806E663(*(a1 + 4), 2);
      break;
    case 0x41:
      v15 = sub_806E6A2(*(a1 + 4), 2);
      break;
    case 0x42:
      v15 = sub_806E89C(*(a1 + 4), 2);
      break;
    case 0x43:
      v15 = sub_8072DCA();
      break;
    case 0x44:
      v15 = sub_8072DD4();
      break;
    case 0x45:
      v15 = sub_808DE54();
      break;
    case 0x46:
      v15 = sub_8097F44(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
      break;
    case 0x47:
      v15 = 0;
      break;
    case 0x48:
      v15 = 0;
      break;
    case 0x49:
      sub_8091999(*(a1 + 4));
      v15 = 0;
      break;
    case 0x4A:
      v15 = sub_806BB38(*(a1 + 4));
      break;
    case 0x4B:
      sub_806BB25(*(a1 + 4));
      v15 = 0;
      break;
    case 0x4C:
      v15 = sub_8072A9F(*(a1 + 4));
      break;
    case 0x4D:
      v15 = sub_8072AD5(*(a1 + 4));
      break;
    case 0x4E:
      sub_8072AF0(*(a1 + 4));
      v15 = 0;
      break;
    case 0x4F:
      v15 = sub_80C37F6(*(a1 + 4));
      break;
    case 0x50:
      v15 = sub_808E963(*(a1 + 4));
      break;
    case 0x51:
      sub_8072755(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20));
      v15 = 0;
      break;
    case 0x52:
      v15 = sub_80725CB(*(a1 + 4)) != 0;
      break;
    case 0x53:
      sub_8072884(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x54:
      v15 = sub_80B9748(*(a1 + 4));
      break;
    case 0x56:
      sub_80BFD90(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x57:
      sub_80BFC22(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x58:
      sub_80BFDCA(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x59:
      sub_80BFFBC(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 0, *(a1 + 28));
      v15 = 0;
      break;
    case 0x5A:
      v15 = sub_80C004A(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), *(a1 + 28), 0, *(a1 + 32));
      break;
    case 0x5B:
      sub_80C1120(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x5C:
      sub_80C0B1E(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x5D:
      sub_80C01D6(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 0, *(a1 + 28));
      v15 = 0;
      break;
    case 0x5E:
      sub_80C0364(*(a1 + 4));
      v15 = 0;
      break;
    case 0x5F:
      v1 = sub_809C85E(*(a1 + 4));
      v15 = sub_80C0AC4(v1, *(a1 + 8));
      break;
    case 0x60:
      v2 = sub_809C85E(*(a1 + 4));
      v15 = sub_80C0B06(v2, *(a1 + 8));
      break;
    case 0x61:
      v15 = (sub_80BEEF2(*(a1 + 4), *(a1 + 8)) * 1000.0);
      break;
    case 0x62:
      v3 = sub_809C85E(*(a1 + 4));
      *&v12 = sub_80BEEF2(v3, *(a1 + 8));
      v15 = sub_808E952(v12);
      break;
    case 0x63:
      sub_80C11FA(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 0, *(a1 + 28));
      v15 = 0;
      break;
    case 0x64:
      sub_80C1072(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24), 0, *(a1 + 28));
      v15 = 0;
      break;
    case 0x65:
      sub_80BF696(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
      v15 = 0;
      break;
    case 0x66:
      sub_80BF5E2(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20));
      v15 = 0;
      break;
    case 0x67:
      v4 = sub_809C85E(*(a1 + 4));
      sub_80BF74A(v4, *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20), *(a1 + 24));
      v15 = 0;
      break;
    case 0x68:
      v5 = sub_809C85E(*(a1 + 4));
      sub_80BF888(v5, *(a1 + 8), *(a1 + 12), *(a1 + 16), *(a1 + 20));
      v15 = 0;
      break;
    case 0x69:
      v6 = sub_809C85E(*(a1 + 4));
      v15 = sub_80C1142(v6, *(a1 + 8));
      break;
    case 0x6A:
      v7 = sub_809C85E(*(a1 + 4));
      v15 = sub_80C1186(v7, *(a1 + 8), *(a1 + 12));
      break;
    case 0x6B:
      *&v13 = sub_80BEF30(*(a1 + 4), *(a1 + 8));
      v15 = sub_808E952(v13);
      break;
    case 0x6C:
      *&v14 = sub_80BEF88(*(a1 + 4), *(a1 + 8));
      v15 = sub_808E952(v14);
      break;
    case 0x6D:
      sub_808E9E3(*(a1 + 4));
      v15 = 0;
      break;
    case 0x6E:
      v15 = sub_808EA25(*(a1 + 4), *(a1 + 8));
      break;
    case 0x6F:
      v15 = sub_808EAA2(*(a1 + 4), *(a1 + 8));
      break;
    case 0x70:
      v15 = sub_808EB1F(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x71:
      sub_808EB63(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x72:
      sub_808EB93(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x73:
      sub_808EBC2(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x74:
      sub_808EBEA(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x75:
      sub_80C155C(*(a1 + 4));
      v15 = 0;
      break;
    case 0x76:
      sub_80C15FA(*(a1 + 4));
      v15 = 0;
      break;
    case 0x77:
      sub_80C1716(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0x78:
      v15 = sub_808EC12(*(a1 + 4));
      break;
    case 0x79:
      v15 = sub_808EC33(*(a1 + 4), *(a1 + 8));
      break;
    case 0x7A:
      v15 = sub_808EC70(*(a1 + 4));
      break;
    case 0x7B:
      sub_808EC99(*(a1 + 4));
      v15 = 0;
      break;
    case 0x7C:
      v15 = sub_80BEFE0(*(a1 + 4), *(a1 + 8));
      break;
    case 0x7D:
      v8 = sub_809C85E(*(a1 + 4));
      v15 = sub_80BF082(v8, *(a1 + 8));
      break;
    case 0x7E:
      v9 = sub_809C85E(*(a1 + 4));
      v15 = sub_80BF092(v9, *(a1 + 8), *(a1 + 12));
      break;
    case 0x7F:
      v15 = sub_80C3F5E(*(a1 + 4));
      break;
    case 0x80:
      v15 = sub_80C3F76(*(a1 + 4));
      break;
    case 0x81:
      v15 = sub_808ECC2(*(a1 + 4));
      break;
    case 0x82:
      v15 = sub_808ECE3(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x83:
      v15 = sub_808ED12(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0x84:
      sub_808ED41(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0x85:
      v10 = sub_809C85E(*(a1 + 4));
      v15 = sub_80BF0A6(v10, *(a1 + 8));
      break;
    case 0x86:
      v15 = sub_808ED70(*(a1 + 4));
      break;
    case 0x87:
      v15 = sub_80BF0E8(*(a1 + 4));
      break;
    case 0x88:
      sub_808EE3D();
      v15 = 0;
      break;
    case 0x89:
      v15 = sub_8072B0B(*(a1 + 4), *(a1 + 8), 1);
      break;
    case 0x8A:
      sub_8072B74(1, *(a1 + 4));
      v15 = 0;
      break;
    case 0x8B:
      sub_808B9B5();
      v15 = 0;
      break;
    case 0x8C:
      sub_808EE92();
      v15 = 0;
      break;
    case 0xC8:
      memset(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0xC9:
      memcpy(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0xCA:
      v15 = strncpy(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      break;
    case 0xCB:
      *&v16 = sin(*(a1 + 4));
      v15 = sub_808E952(v16);
      break;
    case 0xCC:
      *&v17 = cos(*(a1 + 4));
      v15 = sub_808E952(v17);
      break;
    case 0xCD:
      *&v18 = atan2(*(a1 + 4), *(a1 + 8));
      v15 = sub_808E952(v18);
      break;
    case 0xCE:
      *&v19 = sqrt(*(a1 + 4));
      v15 = sub_808E952(v19);
      break;
    case 0xCF:
      sub_80678FC(*(a1 + 4), *(a1 + 8), *(a1 + 12));
      v15 = 0;
      break;
    case 0xD0:
      sub_80674AD(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
      v15 = 0;
      break;
    case 0xD1:
      sub_80676B4(*(a1 + 4), *(a1 + 8));
      v15 = 0;
      break;
    case 0xD2:
      *&v20 = floor(*(a1 + 4));
      v15 = sub_808E952(v20);
      break;
    case 0xD3:
      *&v21 = ceil(*(a1 + 4));
      v15 = sub_808E952(v21);
      break;
    default:
      sub_80704AC(1, &byte_80E50DB, *a1);
  }
  return v15;
}
// 8494A64: using guessed type int dword_8494A64;
// 84F6E98: using guessed type int dword_84F6E98;

//----- (08090B57) --------------------------------------------------------
#error "8090B98: call analysis failed (funcsize=22)"

//----- (08090BBB) --------------------------------------------------------
#error "8090BF1: call analysis failed (funcsize=52)"

//----- (08090C91) --------------------------------------------------------
#error "8090CAF: call analysis failed (funcsize=15)"

//----- (08090CCE) --------------------------------------------------------
#error "8090D1A: call analysis failed (funcsize=32)"

//----- (08090D65) --------------------------------------------------------
#error "8090D99: call analysis failed (funcsize=17)"

//----- (08090DA8) --------------------------------------------------------
char *__cdecl sub_8090DA8(int a1, char *s1)
{
  char *result; // eax
  char dest[1028]; // [esp+20h] [ebp-428h] BYREF
  char v4[4]; // [esp+424h] [ebp-24h]
  int j; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int i; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]
  char *v9; // [esp+438h] [ebp-10h]
  int v10; // [esp+43Ch] [ebp-Ch]

  v8 = 1000;
  if ( a1 < 0 || a1 > 2047 )
    sub_80704AC(1, &byte_80E54C0, a1);
  if ( !s1 )
    s1 = &byte_80E54E3;
  result = strcmp(s1, (&dword_8494E98)[a1]);
  if ( result )
  {
    sub_806BB25((&dword_8494E98)[a1]);
    result = sub_806BB76(s1);
    (&dword_8494E98)[a1] = result;
    if ( dword_8494A80 == 2 || dword_8494A84 )
    {
      v9 = 0;
      for ( i = svs_clients; ; i += 700596 )
      {
        result = v9;
        if ( v9 >= *(dword_8494A64 + 32) )
          break;
        if ( *i > 2 )
        {
          v10 = strlen(s1);
          if ( v10 < v8 )
          {
            sub_8092F86(i, 1, "d %i %s", a1, s1);
          }
          else
          {
            v6 = 0;
            for ( j = v10; j > 0; j = j - v8 + 1 )
            {
              if ( v6 )
              {
                if ( j >= v8 )
                  *v4 = 135156968;
                else
                  *v4 = 135156966;
              }
              else
              {
                *v4 = aXzy;
              }
              Q_strncpyz(dest, &s1[v6], v8);
              sub_8092F86(i, 1, "%s %i %s", *v4, a1, dest);
              v6 = v6 + v8 - 1;
            }
          }
        }
        ++v9;
      }
    }
  }
  return result;
}
// 80E54E4: using guessed type __int16 aXzy[3];
// 8494A64: using guessed type int dword_8494A64;
// 8494A80: using guessed type int dword_8494A80;
// 8494A84: using guessed type int dword_8494A84;

//----- (08090F8C) --------------------------------------------------------
char *__cdecl sub_8090F8C(int a1, char *dest, int a3)
{
  char *result; // eax

  if ( a3 <= 0 )
    sub_80704AC(1, &byte_80E5500, a3);
  if ( a1 < 0 || a1 > 2047 )
    sub_80704AC(1, &byte_80E5540, a1);
  if ( (&dword_8494E98)[a1] )
    return Q_strncpyz(dest, (&dword_8494E98)[a1], a3);
  result = dest;
  *dest = 0;
  return result;
}

//----- (08091016) --------------------------------------------------------
const char *__cdecl sub_8091016(int a1)
{
  const char *v2; // [esp+0h] [ebp-4h]

  v2 = (&dword_8494E98)[a1];
  if ( !v2 )
    v2 = &byte_80E54E3;
  return v2;
}

//----- (080910B8) --------------------------------------------------------
char *__cdecl sub_80910B8(int a1, int a2, char *s1, char *a4)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = (&(&dword_8494E98)[a1])[i];
    if ( !*s2 )
    {
      sub_8090DA8(a1 + i, s1);
      break;
    }
    if ( !strcasecmp(s1, s2) )
      break;
  }
  if ( i == a2 )
    sub_80704AC(1, &byte_80E5580);
  return sub_8090DA8(i + a1 + a2, a4);
}

//----- (08091153) --------------------------------------------------------
char *__cdecl sub_8091153(int a1, char *src)
{
  char *v2; // eax

  if ( a1 < 0 || a1 >= *(dword_8494A64 + 32) )
    sub_80704AC(1, &byte_80E55C0, a1);
  if ( !src )
    src = &byte_80E54E3;
  Q_strncpyz(svs_clients + 700596 * a1 + 12, src, 1024);
  v2 = sub_8086E7F(src, "name");
  return Q_strncpyz(svs_clients + 700596 * a1 + 68164, v2, 32);
}
// 8494A64: using guessed type int dword_8494A64;

//----- (080911FD) --------------------------------------------------------
char *__cdecl sub_80911FD(int a1, char *dest, int a3)
{
  if ( a3 <= 0 )
    sub_80704AC(1, &byte_80E5600, a3);
  if ( a1 < 0 || a1 >= *(dword_8494A64 + 32) )
    sub_80704AC(1, &byte_80E5640, a1);
  return Q_strncpyz(dest, svs_clients + 700596 * a1 + 12, a3);
}
// 8494A64: using guessed type int dword_8494A64;

//----- (0809127F) --------------------------------------------------------
int sub_809127F()
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  int *v2; // [esp+Ch] [ebp-Ch]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= dword_84F6EA4 )
      break;
    v2 = SV_GentityNum(i);
    if ( v2[61] )
    {
      *v2 = i;
      qmemcpy(&unk_8496EA0 + 384 * i, v2, 0xF4u);
      dword_8496F94[96 * i] = v2[62];
      dword_8496F98[96 * i] = v2[63];
      dword_8496F9C[96 * i] = v2[73];
      dword_8496FA0[96 * i] = v2[74];
      dword_8496FA4[96 * i] = v2[75];
      dword_8496FA8[96 * i] = v2[76];
      dword_8496FAC[96 * i] = v2[77];
      dword_8496FB0[96 * i] = v2[78];
    }
  }
  return result;
}
// 8496F94: using guessed type int dword_8496F94[];
// 8496F98: using guessed type int dword_8496F98[];
// 8496F9C: using guessed type int dword_8496F9C[];
// 8496FA0: using guessed type int dword_8496FA0[];
// 8496FA4: using guessed type int dword_8496FA4[];
// 8496FA8: using guessed type int dword_8496FA8[];
// 8496FAC: using guessed type int dword_8496FAC[];
// 84F6EA4: using guessed type int dword_84F6EA4;

//----- (080913E2) --------------------------------------------------------
int __cdecl sub_80913E2(int a1)
{
  char *v1; // eax
  int result; // eax
  char *v3; // eax

  sub_8073114("sv_maxclients", "20", 0);
  *(dword_8494A64 + 20) = 0;
  if ( *(dword_8494A64 + 32) >= a1 )
  {
    result = dword_8494A64;
    if ( *(dword_8494A64 + 32) > 64 )
    {
      v3 = sub_8086D78("%i", 64);
      result = sub_8073798("sv_maxclients", v3);
    }
  }
  else
  {
    v1 = sub_8086D78("%i", a1);
    result = sub_8073798("sv_maxclients", v1);
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (08091473) --------------------------------------------------------
int sub_8091473()
{
  if ( dword_84F7000 )
    sub_80704AC(0, &byte_80E5673);
  sub_80913E2(1);
  svs_clients = calloc(700596 * *(dword_8494A64 + 32), 1u);
  if ( !svs_clients )
    sub_80704AC(0, &byte_80E56A0);
  if ( *(dword_84886E0 + 32) )
  {
    dword_84F7014 = *(dword_8494A64 + 32) << 11;
    dword_84F7018 = 32 * *(dword_8494A64 + 32) * *(dword_8494A64 + 32);
  }
  else
  {
    dword_84F7014 = *(dword_8494A64 + 32) << 8;
    dword_84F7018 = 4 * *(dword_8494A64 + 32) * *(dword_8494A64 + 32);
  }
  dword_84F7000 = 1;
  return sub_8073798("sv_running", "1");
}
// 84886E0: using guessed type int dword_84886E0;
// 8494A64: using guessed type int dword_8494A64;
// 84F7000: using guessed type int dword_84F7000;
// 84F7014: using guessed type int dword_84F7014;
// 84F7018: using guessed type int dword_84F7018;

//----- (08091563) --------------------------------------------------------
int sub_8091563()
{
  int result; // eax
  unsigned int v1; // [esp+14h] [ebp-34h]
  _DWORD *v2; // [esp+18h] [ebp-30h]
  _DWORD *v3; // [esp+1Ch] [ebp-2Ch]
  unsigned int v4; // [esp+20h] [ebp-28h]
  _DWORD *v5; // [esp+24h] [ebp-24h]
  _DWORD *v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+2Ch] [ebp-1Ch]
  _DWORD *ptr; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  int j; // [esp+34h] [ebp-14h]
  int k; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]

  v7 = 0;
  for ( i = 0; i < *(dword_8494A64 + 32); ++i )
  {
    if ( *(svs_clients + 175149 * i) > 1 && i > v7 )
      v7 = i;
  }
  v8 = v7 + 1;
  v13 = *(dword_8494A64 + 32);
  sub_80913E2(v8);
  result = *(dword_8494A64 + 32);
  if ( result != v13 )
  {
    ptr = sub_806C600(700596 * v8);
    for ( j = 0; j < v8; ++j )
    {
      if ( *(svs_clients + 175149 * j) <= 1 )
      {
        sub_80C837D(&ptr[175149 * j], 0, 0xAB0B4u);
      }
      else
      {
        v6 = &ptr[175149 * j];
        v5 = svs_clients + 700596 * j;
        v4 = 700596;
        if ( ((ptr - 76 * j) & 4) != 0 )
        {
          *v6++ = *v5++;
          v4 = 700592;
        }
        qmemcpy(v6, v5, 4 * (v4 >> 2));
      }
    }
    free(svs_clients);
    svs_clients = calloc(700596 * *(dword_8494A64 + 32), 1u);
    if ( !svs_clients )
      sub_80704AC(0, &byte_80E56A0);
    sub_80C837D(svs_clients, 0, 700596 * *(dword_8494A64 + 32));
    for ( k = 0; k < v8; ++k )
    {
      if ( ptr[175149 * k] > 1 )
      {
        v3 = svs_clients + 700596 * k;
        v2 = &ptr[175149 * k];
        v1 = 700596;
        if ( ((svs_clients - 76 * k) & 4) != 0 )
        {
          *v3++ = *v2++;
          v1 = 700592;
        }
        qmemcpy(v3, v2, 4 * (v1 >> 2));
      }
    }
    sub_806C742(ptr);
    if ( *(dword_84886E0 + 32) )
    {
      dword_84F7014 = *(dword_8494A64 + 32) << 11;
      result = 32 * *(dword_8494A64 + 32) * *(dword_8494A64 + 32);
    }
    else
    {
      dword_84F7014 = *(dword_8494A64 + 32) << 8;
      result = 4 * *(dword_8494A64 + 32) * *(dword_8494A64 + 32);
    }
    dword_84F7018 = result;
  }
  return result;
}
// 84886E0: using guessed type int dword_84886E0;
// 8494A64: using guessed type int dword_8494A64;
// 84F7014: using guessed type int dword_84F7014;
// 84F7018: using guessed type int dword_84F7018;

//----- (08091824) --------------------------------------------------------
void __cdecl sub_8091824(char *a1)
{
  signed int v1; // [esp+10h] [ebp-18h]
  char *s1; // [esp+14h] [ebp-14h]
  char *s1a; // [esp+14h] [ebp-14h]
  char *v4; // [esp+18h] [ebp-10h] BYREF
  void *s; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h] BYREF

  src = "hunkusage.dat";
  v1 = sub_8065D85("hunkusage.dat", &v7, 0);
  if ( v1 >= 0 )
  {
    s = sub_806BB38(v1 + 1);
    memset(s, 0, v1 + 1);
    sub_8062853(s, v1, v7);
    FS_FCloseFile(v7);
    v4 = s;
    while ( 1 )
    {
      s1 = sub_8085E0B(&v4);
      if ( !s1 || !*s1 )
        break;
      if ( !sub_8086D56(s1, a1) )
      {
        s1a = sub_8085E0B(&v4);
        if ( s1a )
        {
          if ( *s1a )
          {
            sub_8073798("com_expectedhunkusage", s1a);
            sub_806BB25(s);
            return;
          }
        }
      }
    }
    sub_806BB25(s);
  }
  sub_8073798("com_expectedhunkusage", "-1");
}

//----- (0809193D) --------------------------------------------------------
void *sub_809193D()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    if ( (&dword_8494E98)[i] )
      sub_806BB25((&dword_8494E98)[i]);
  }
  return sub_80C837D(&dword_8494A80, 0, 0x6252Cu);
}
// 8494A80: using guessed type int dword_8494A80;

//----- (08091999) --------------------------------------------------------
void *__cdecl sub_8091999(int a1)
{
  void *result; // eax

  result = a1;
  dword_84F702C = a1;
  if ( a1 )
  {
    if ( !dword_84F7034 )
    {
      dword_84F704C = sub_806BB38(0x450000u);
      dword_84F7050 = sub_806BB38(0x4564000u);
      dword_84F7034 = sub_806BB38(0x2580u);
      dword_84F7038 = sub_806BB38(0x2000000u);
      result = sub_806BB38(0x3800u);
      dword_84F7054 = result;
    }
  }
  return result;
}
// 84F702C: using guessed type int dword_84F702C;

//----- (08091A14) --------------------------------------------------------
void sub_8091A14()
{
  dword_84F702C = 0;
  dword_84F7030 = 0;
  dword_84F703C = 0;
  dword_84F7040 = 0;
  dword_84F7044 = 0;
  dword_84F7048 = 0;
}
// 84F702C: using guessed type int dword_84F702C;
// 84F7030: using guessed type int dword_84F7030;
// 84F703C: using guessed type int dword_84F703C;
// 84F7040: using guessed type int dword_84F7040;
// 84F7044: using guessed type int dword_84F7044;
// 84F7048: using guessed type int dword_84F7048;

//----- (08091A55) --------------------------------------------------------
void sub_8091A55()
{
  if ( dword_84F704C )
  {
    sub_806BB25(dword_84F704C);
    dword_84F704C = 0;
  }
  if ( dword_84F7050 )
  {
    sub_806BB25(dword_84F7050);
    dword_84F7050 = 0;
  }
  if ( dword_84F7034 )
  {
    sub_806BB25(dword_84F7034);
    dword_84F7034 = 0;
  }
  if ( dword_84F7038 )
  {
    sub_806BB25(dword_84F7038);
    dword_84F7038 = 0;
  }
  if ( dword_84F7054 )
  {
    sub_806BB25(dword_84F7054);
    dword_84F7054 = 0;
  }
}

//----- (08091AFD) --------------------------------------------------------
int sub_8091AFD()
{
  char *v0; // eax
  char *i; // [esp+10h] [ebp-8h]

  v0 = sub_8073B14("g_gametype");
  Q_strncpyz(byte_84F6F6C, v0, 64);
  for ( i = byte_84F6F6C; *i; ++i )
    *i = tolower(*i);
  sub_8073798("g_gametype", byte_84F6F6C);
  return sub_8073A7E();
}

//----- (08091B72) --------------------------------------------------------
int __cdecl SV_SpawnServer(char *s1)
{
  int *v1; // eax
  char *v2; // eax
  int v3; // eax
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int result; // eax
  int v14; // [esp+8h] [ebp-2040h]
  int v15; // [esp+Ch] [ebp-203Ch]
  int v16; // [esp+10h] [ebp-2038h]
  int v17; // [esp+14h] [ebp-2034h]
  int v18; // [esp+18h] [ebp-2030h]
  int v19; // [esp+1Ch] [ebp-202Ch]
  int v20; // [esp+20h] [ebp-2028h]
  int v21; // [esp+24h] [ebp-2024h]
  int v22; // [esp+24h] [ebp-2024h]
  int *v23; // [esp+28h] [ebp-2020h]
  char *v24; // [esp+2Ch] [ebp-201Ch]
  char *v25; // [esp+2Ch] [ebp-201Ch]
  char *v26; // [esp+2Ch] [ebp-201Ch]
  char *v27; // [esp+2Ch] [ebp-201Ch]
  int dest; // [esp+30h] [ebp-2018h] BYREF
  int v29; // [esp+34h] [ebp-2014h]
  int v30; // [esp+2038h] [ebp-10h] BYREF
  int i; // [esp+203Ch] [ebp-Ch]

  v1 = sub_8073114("cl_xmodelcheck", "0", 33);
  sub_80C1844(v1[8]);
  sub_8073114("g_gametype", "dm", 36);
  if ( sub_8073AB4("sv_running") == 0.0 )
  {
    v22 = 0;
  }
  else
  {
    v22 = VM_Call(gvm, 18, v14, v15, v16, v17, v18, v19, v20, v21, v23, v24, dest, v29);
    if ( v22 )
      sub_8073798("g_gametype", byte_84F6F6C);
    i = 0;
    v23 = svs_clients;
    while ( i < *(dword_8494A64 + 32) )
    {
      if ( *v23 > 2 )
      {
        v2 = sub_8086D78("loadingnewmap\n%s\n%s", s1, *(dword_84F6FD0 + 4));
        sub_8084D76(1, v23[158738], v23[158739], v23[158740], v23[158741], v23[158742], v2);
      }
      ++i;
      v23 += 175149;
    }
    sub_80CA849(250);
  }
  sub_80851A5();
  sub_80851E6();
  sub_8090B57();
  Com_Printf("------ Server Initialization ------\n");
  Com_Printf("Server: %s\n", s1);
  sub_806C394();
  sub_809193D();
  sub_80654DD(1);
  sub_8065A4D(0);
  v3 = sub_80CA93C();
  srand(v3);
  v4 = rand() << 16;
  v5 = rand() ^ v4;
  dword_8494A8C = v5 ^ sub_80CA93C();
  sub_8065BBB(dword_8494A8C);
  sub_80653D9();
  for ( i = 0; i <= 2047; ++i )
    (&dword_8494E98)[i] = sub_806BB76(&byte_80E54E3);
  if ( sub_8073AB4("sv_running") == 0.0 )
  {
    sub_8072A36();
    sub_8091473();
  }
  else
  {
    sub_80729AC();
    if ( *(dword_8494A64 + 20) )
      sub_8091563();
  }
  sub_8091AFD();
  dword_84F7024 = sub_806C3D4(244 * dword_84F7014);
  dword_84F701C = 0;
  dword_84F7028 = sub_806C3D4(92 * dword_84F7018);
  dword_84F7020 = 0;
  sub_8091A14();
  dword_84F700C ^= 4u;
  sub_8073798("nextmap", "map_restart");
  v6 = sub_8086D78("maps/mp/%s.bsp", s1);
  sub_8091824(v6);
  sub_8073798("cl_paused", "0");
  v7 = sub_8086D78("maps/mp/%s.bsp", s1);
  sub_804B429(v7, 0, &v30);
  sub_8073798("mapname", s1);
  *dword_80F5100 = (dword_80F5100[0] + 16);
  if ( (dword_80F5100[0] & 0xF0) == 0 )
    *dword_80F5100 += 16;
  v8 = sub_8086D78("%i", *dword_80F5100);
  sub_8073798("sv_serverid", v8);
  dword_8494A88 = dword_848871C;
  dword_8494A80 = 1;
  sub_8073798("sv_serverRestarting", "1");
  v9 = sub_8086D78("maps/mp/%s.bsp", s1);
  sub_806E35A(v9, 2);
  sub_80C0C82(1);
  sub_8090CCE(v22);
  for ( i = 0; i <= 2; ++i )
  {
    svs_time += 100;
    dword_84F7004 += 100;
    sub_8094FCA();
  }
  sub_809127F();
  for ( i = 0; i < *(dword_8494A64 + 32); ++i )
  {
    if ( *(svs_clients + 175149 * i) > 1 )
    {
      v20 = VM_Call(gvm, 4, i, *(svs_clients + 350298 * i + 350274), v16, v17, v18, v19, v20, v22, v23, v24, dest, v29);
      if ( v20 )
        SV_DropClient(svs_clients + 700596 * i, v20);
      else
        *(svs_clients + 175149 * i) = 2;
    }
  }
  if ( *(dword_84F6FB8 + 32) )
  {
    v25 = sub_8076302();
    sub_8073798("sv_paks", v25);
    if ( !*v25 )
      Com_Printf("WARNING: sv_pure set but no PK3 files loaded\n");
    v26 = sub_807637A();
    sub_8073798("sv_pakNames", v26);
  }
  else
  {
    sub_8073798("sv_paks", &byte_80E54E3);
    sub_8073798("sv_pakNames", &byte_80E54E3);
  }
  v10 = sub_807647E();
  sub_8073798("sv_referencedPaks", v10);
  v27 = sub_8076564();
  sub_8073798("sv_referencedPakNames", v27);
  v11 = sub_80748C0(8);
  Q_strncpyz(&dest, v11, 0x2000);
  dword_84898D8 &= 0xFFFFFFF7;
  sub_8090DA8(1, &dest);
  v12 = sub_8074863(8196);
  sub_8090DA8(0, v12);
  dword_84898D8 &= 0xFFFFDFFB;
  sub_807480C(149, 128, 2048);
  dword_84898D8 &= 0xFFFFF7FF;
  dword_8494A80 = 2;
  sub_8089336();
  sub_8073798("sv_serverRestarting", "0");
  Com_Printf("-----------------------------------\n");
  if ( *sub_8073B14("sv_punkbuster") == 49 )
    result = sub_80B6D30();
  else
    result = sub_80B6D6C();
  return result;
}
// 8091BED: variable 'v14' is possibly undefined
// 8091BED: variable 'v15' is possibly undefined
// 8091BED: variable 'v16' is possibly undefined
// 8091BED: variable 'v17' is possibly undefined
// 8091BED: variable 'v18' is possibly undefined
// 8091BED: variable 'v19' is possibly undefined
// 8091BED: variable 'v20' is possibly undefined
// 8091BED: variable 'v21' is possibly undefined
// 8091BED: variable 'v23' is possibly undefined
// 8091BED: variable 'v24' is possibly undefined
// 8091FEA: variable 'v22' is possibly undefined
// 8090B57: using guessed type int sub_8090B57(void);
// 8090CCE: using guessed type _DWORD __cdecl sub_8090CCE(_DWORD);
// 8094FCA: using guessed type int sub_8094FCA(void);
// 848871C: using guessed type int dword_848871C;
// 84898D8: using guessed type int dword_84898D8;
// 8494A64: using guessed type int dword_8494A64;
// 8494A80: using guessed type int dword_8494A80;
// 8494A88: using guessed type int dword_8494A88;
// 8494A8C: using guessed type int dword_8494A8C;
// 84F6FB8: using guessed type int dword_84F6FB8;
// 84F6FD0: using guessed type int dword_84F6FD0;
// 84F7004: using guessed type int dword_84F7004;
// 84F7008: using guessed type int svs_time;
// 84F700C: using guessed type int dword_84F700C;
// 84F7014: using guessed type int dword_84F7014;
// 84F7018: using guessed type int dword_84F7018;
// 84F701C: using guessed type int dword_84F701C;
// 84F7020: using guessed type int dword_84F7020;
// 84F7024: using guessed type int dword_84F7024;
// 84F7028: using guessed type int dword_84F7028;

//----- (080921F6) --------------------------------------------------------
int __cdecl sub_80921F6(char *s1)
{
  return sub_8073798("sv_punkbuster", s1);
}

//----- (08092211) --------------------------------------------------------
int *sub_8092211()
{
  int *result; // eax
  char *s2; // [esp+14h] [ebp-4h]

  sub_8089580();
  dword_84F6FD0 = sub_8073114("g_gametype", "dm", 36);
  dword_84F6FBC = sub_8073114("scr_allow_jeeps", "1", 36);
  dword_84F6FCC = sub_8073114("scr_allow_tanks", "1", 36);
  sub_8073114("sv_keywords", &byte_80E54E3, 4);
  s2 = sub_8086D78("%i", 22);
  sub_8073114("protocol", s2, 68);
  sub_8073798("protocol", s2);
  dword_8494A48 = sub_8073114("mapname", "nomap", 68);
  dword_8494A20 = sub_8073114("sv_privateClients", "0", 4);
  dword_8494A58 = sub_8073114("sv_hostname", "CoDHost", 5);
  dword_8494A64 = sub_8073114("sv_maxclients", "20", 36);
  dword_84F6FC4 = sub_8073114("sv_punkbuster", "0", 69);
  dword_84F6FAC = sub_8073114("sv_maxRate", "0", 5);
  dword_84F6FE0 = sub_8073114("sv_minPing", "0", 5);
  dword_84F6FB4 = sub_8073114("sv_maxPing", "0", 5);
  dword_8494A38 = sub_8073114("sv_floodProtect", "1", 5);
  dword_8494A54 = sub_8073114("sv_allowAnonymous", "0", 4);
  dword_850C110 = sub_8073114("sv_showCommands", "0", 0);
  dword_8494A6C = sub_8073114("sv_disableClientConsole", "0", 8);
  sub_8073114("sv_cheats", "1", 72);
  dword_8494A60 = sub_8073114("sv_serverid", "0", 72);
  dword_84F6FB8 = sub_8073114("sv_pure", "1", 12);
  sub_8073114("sv_paks", &byte_80E54E3, 72);
  sub_8073114("sv_pakNames", &byte_80E54E3, 72);
  sub_8073114("sv_referencedPaks", &byte_80E54E3, 72);
  sub_8073114("sv_referencedPakNames", &byte_80E54E3, 72);
  dword_84F6FD8 = sub_8073114("rconPassword", &byte_80E54E3, 256);
  dword_8494A4C = sub_8073114("sv_privatePassword", &byte_80E54E3, 256);
  dword_8494A34 = sub_8073114("sv_fps", "20", 256);
  dword_84F6FB0 = sub_8073114("sv_timeout", "240", 256);
  dword_84F6FD4 = sub_8073114("sv_zombietime", "2", 256);
  sub_8073114("nextmap", &byte_80E54E3, 256);
  dword_84F6FC0 = sub_8073114("sv_allowDownload", "1", 9);
  dword_84F6FDC = sub_8073114("sv_reconnectlimit", "3", 0);
  dword_850C10C = sub_8073114("sv_showloss", "0", 0);
  dword_8494A68 = sub_8073114("sv_padPackets", "0", 0);
  dword_8494A3C = sub_8073114("sv_killserver", "0", 0);
  dword_84F6FC8 = sub_8073114("sv_onlyVisibleClients", "0", 0);
  dword_8494A2C = sub_8073114("sv_packet_info", "0", 0);
  dword_8494A30 = sub_8073114("sv_showAverageBPS", "0", 0);
  dword_8494A28 = sub_8073114("sv_kickBanTime", "300", 0);
  sub_8073114("g_complaintlimit", "3", 1);
  dword_8494A40 = sub_8073114("sv_mapRotation", &byte_80E54E3, 0);
  dword_8494A24 = sub_8073114("sv_mapRotationCurrent", &byte_80E54E3, 0);
  sub_8073114("fs_game", &byte_80E54E3, 12);
  dword_8494A50 = sub_8073114("sv_wwwDownload", "0", 1);
  dword_8494A44 = sub_8073114("sv_wwwBaseURL", &byte_80E54E3, 1);
  result = sub_8073114("sv_wwwDlDisconnected", "0", 1);
  dword_8494A5C = result;
  return result;
}
// 8494A20: using guessed type int dword_8494A20;
// 8494A24: using guessed type int dword_8494A24;
// 8494A28: using guessed type int dword_8494A28;
// 8494A2C: using guessed type int dword_8494A2C;
// 8494A30: using guessed type int dword_8494A30;
// 8494A34: using guessed type int dword_8494A34;
// 8494A38: using guessed type int dword_8494A38;
// 8494A3C: using guessed type int dword_8494A3C;
// 8494A40: using guessed type int dword_8494A40;
// 8494A44: using guessed type int dword_8494A44;
// 8494A48: using guessed type int dword_8494A48;
// 8494A4C: using guessed type int dword_8494A4C;
// 8494A50: using guessed type int dword_8494A50;
// 8494A54: using guessed type int dword_8494A54;
// 8494A58: using guessed type int dword_8494A58;
// 8494A5C: using guessed type int dword_8494A5C;
// 8494A60: using guessed type int dword_8494A60;
// 8494A64: using guessed type int dword_8494A64;
// 8494A68: using guessed type int dword_8494A68;
// 8494A6C: using guessed type int dword_8494A6C;
// 84F6FAC: using guessed type int dword_84F6FAC;
// 84F6FB0: using guessed type int dword_84F6FB0;
// 84F6FB4: using guessed type int dword_84F6FB4;
// 84F6FB8: using guessed type int dword_84F6FB8;
// 84F6FBC: using guessed type int dword_84F6FBC;
// 84F6FC0: using guessed type int dword_84F6FC0;
// 84F6FC4: using guessed type int dword_84F6FC4;
// 84F6FC8: using guessed type int dword_84F6FC8;
// 84F6FCC: using guessed type int dword_84F6FCC;
// 84F6FD0: using guessed type int dword_84F6FD0;
// 84F6FD4: using guessed type int dword_84F6FD4;
// 84F6FD8: using guessed type int dword_84F6FD8;
// 84F6FDC: using guessed type int dword_84F6FDC;
// 84F6FE0: using guessed type int dword_84F6FE0;
// 850C10C: using guessed type int dword_850C10C;
// 850C110: using guessed type int dword_850C110;

//----- (08092803) --------------------------------------------------------
int *__cdecl sub_8092803(const char *a1)
{
  int *result; // eax
  int *v2; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h] BYREF
  int v4; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v4 = 0;
    v2 = svs_clients;
    while ( v4 < *(dword_8494A64 + 32) )
    {
      if ( *v2 > 1 )
      {
        if ( v2[158738] != 2 )
        {
          sub_8092F86(v2, 0, "e \"%s\"", a1);
          sub_8092F86(v2, 1, "w");
        }
        v2[17161] = -1;
        SV_SendClientSnapshot(v2);
      }
      ++v4;
      v2 += 175149;
    }
    result = &i;
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (080928C2) --------------------------------------------------------
void __cdecl sub_80928C2(const char *a1)
{
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]

  if ( dword_84897C0 && *(dword_84897C0 + 32) )
  {
    Com_Printf("----- Server Shutdown -----\n", v1);
    if ( svs_clients && !dword_84897DC )
      sub_8092803(a1);
    sub_808977C();
    sub_80932AB();
    sub_8090B57();
    sub_809193D();
    if ( svs_clients )
      sub_808AC2B();
    sub_8091A55();
    memset(&dword_84F7000, 0, 0x1510Cu);
    sub_8073798("sv_running", "0");
    Com_Printf("---------------------------\n", v2);
    sub_80851A0();
  }
}
// 80928EC: variable 'v1' is possibly undefined
// 809296C: variable 'v2' is possibly undefined
// 8090B57: using guessed type int sub_8090B57(void);
// 84897C0: using guessed type int dword_84897C0;
// 84897DC: using guessed type int dword_84897DC;
// 84F7000: using guessed type int dword_84F7000;

//----- (08092980) --------------------------------------------------------
_BYTE *__cdecl sub_8092980(_BYTE *a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]
  unsigned int v3; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a1 && v2 <= 0x3FC )
  {
    if ( *a1 == 10 )
    {
      *(v2 + 136965568) = 92;
      v3 = v2 + 1;
      *(v3 + 136965568) = 110;
      v2 = v3 + 1;
      goto LABEL_10;
    }
    if ( *a1 == 20 || *a1 == 21 )
    {
      ++a1;
    }
    else
    {
      byte_829EDC0[v2++] = *a1;
LABEL_10:
      ++a1;
    }
  }
  *(v2 + 136965568) = 0;
  return byte_829EDC0;
}

//----- (08092A0E) --------------------------------------------------------
int __cdecl sub_8092A0E(_BYTE *a1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-8h]

  while ( *a1 && *a2 && *a1 != 32 && *a2 != 32 )
  {
    if ( *a1 != *a2 )
      return 0;
    ++a1;
    ++a2;
  }
  v3 = 0;
  if ( (!*a1 || *a1 == 32) && (!*a2 || *a2 == 32) )
    v3 = 1;
  return v3;
}

//----- (08092A94) --------------------------------------------------------
int __cdecl sub_8092A94(int a1, char *a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = *(a1 + 67092) + 1; ; ++i )
  {
    if ( i > *(a1 + 67084) )
      return -1;
    v4 = i & 0x3F;
    if ( *(a1 + 1032 * v4 + 2064) )
    {
      if ( *a2 == *(a1 + 1032 * v4 + 1036) && (*a2 - 120) > 2 )
        break;
    }
LABEL_12:
    ;
  }
  if ( !strcmp(a2 + 1, (a1 + 1032 * v4 + 1037)) )
    return i;
  switch ( *a2 )
  {
    case 'a':
    case 'b':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 't':
      v3 = i;
      break;
    case 'd':
    case 'v':
      if ( !sub_8092A0E(a2 + 2, (a1 + 1032 * v4 + 1038)) )
        goto LABEL_12;
      v3 = i;
      break;
    default:
      goto LABEL_12;
  }
  return v3;
}

//----- (08092BC4) --------------------------------------------------------
int __cdecl sub_8092BC4(int a1)
{
  int result; // eax
  unsigned int v2; // [esp+0h] [ebp-28h]
  _DWORD *v3; // [esp+4h] [ebp-24h]
  _DWORD *v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]

  v7 = *(a1 + 67092) + 1;
  for ( i = v7; i <= *(a1 + 67084); ++i )
  {
    v6 = i & 0x3F;
    if ( *(a1 + 1032 * v6 + 2064) )
    {
      v5 = v7 & 0x3F;
      if ( v5 != v6 )
      {
        v4 = (a1 + 1032 * v5 + 1036);
        v3 = (a1 + 1032 * v6 + 1036);
        v2 = 1032;
        if ( ((a1 + 8 * v5 + 12) & 4) != 0 )
        {
          *v4 = *v3;
          v4 = (a1 + 1032 * v5 + 1040);
          v3 = (a1 + 1032 * v6 + 1040);
          v2 = 1028;
        }
        qmemcpy(v4, v3, 4 * (v2 >> 2));
      }
      ++v7;
    }
  }
  result = v7 - 1;
  *(a1 + 67084) = v7 - 1;
  return result;
}

//----- (08092CC3) --------------------------------------------------------
int __cdecl SV_AddServerCommand(int a1, int a2, char *s)
{
  int result; // eax
  char v4; // [esp+4h] [ebp-44h]
  unsigned int v5; // [esp+20h] [ebp-28h]
  _DWORD *v6; // [esp+24h] [ebp-24h]
  _DWORD *v7; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int j; // [esp+34h] [ebp-14h]
  int index; // [esp+38h] [ebp-10h]

  result = a1;
  if ( !*(a1 + 700552) )
  {
    if ( *(a1 + 67084) - *(a1 + 67088) <= 31 && *a1 == 4 || (result = sub_8092BC4(a1), a2) )
    {
      v9 = sub_8092A94(a1, s);
      if ( v9 < 0 )
      {
        ++*(a1 + 67084);
      }
      else
      {
        for ( i = v9 + 1; i <= *(a1 + 67084); ++i )
        {
          v7 = (a1 + 1032 * (v9 & 0x3F) + 1036);
          v6 = (a1 + 1032 * (i & 0x3F) + 1036);
          v5 = 1032;
          if ( ((a1 + 8 * (v9 & 0x3F) + 12) & 4) != 0 )
          {
            *v7 = *v6;
            v7 = (a1 + 1032 * (v9 & 0x3F) + 1040);
            v6 = (a1 + 1032 * (i & 0x3F) + 1040);
            v5 = 1028;
          }
          qmemcpy(v7, v6, 4 * (v5 >> 2));
          LOBYTE(v9) = v9 + 1;
        }
      }
      if ( *(a1 + 67084) - *(a1 + 67088) == 65 )
      {
        Com_Printf("===== pending server commands =====\n", v4);
        for ( j = *(a1 + 67088) + 1; j <= *(a1 + 67084); ++j )
          Com_Printf("cmd %5d: %8d: %s\n", j);
        Com_Printf("cmd %5d: %8d: %s\n", j);
        sub_8084D76(1, *(a1 + 634952), *(a1 + 634956), *(a1 + 634960), *(a1 + 634964), *(a1 + 634968), "disconnect");
        sub_808BBFF(a1, "EXE_SERVERCOMMANDOVERFLOW");
        a2 = 1;
        s = "w \"EXE_SERVERCOMMANDOVERFLOW\"";
      }
      index = *(a1 + 67084) & 63;
      sub_8080D54(s, a1 + 1032 * index + 1036, 1024);
      *(a1 + 1032 * index + 2060) = svs_time;
      result = a2;
      *(a1 + 1032 * index + 2064) = a2;
    }
  }
  return result;
}
// 8092E02: variable 'v4' is possibly undefined
// 84F7008: using guessed type int svs_time;

//----- (08092F86) --------------------------------------------------------
int sub_8092F86(int a1, int a2, char *format, ...)
{
  int result; // eax
  char v4; // al
  int v5; // [esp+18h] [ebp-8020h]
  int *i; // [esp+1Ch] [ebp-801Ch]
  char s[32780]; // [esp+20h] [ebp-8018h] BYREF
  __gnuc_va_list __varargs; // [esp+802Ch] [ebp-Ch]
  va_list va; // [esp+804Ch] [ebp+14h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( a1 )
    return SV_AddServerCommand(a1, a2, s);
  if ( *(dword_84886E0 + 32) && !strncmp(s, "print", 5u) )
  {
    v4 = sub_8092980(s);
    Com_Printf("broadcast: %s\n", v4);
  }
  v5 = 0;
  for ( i = svs_clients; ; i += 175149 )
  {
    result = v5;
    if ( v5 >= *(dword_8494A64 + 32) )
      break;
    if ( *i > 2 )
      SV_AddServerCommand(i, a2, s);
    ++v5;
  }
  return result;
}
// 84886E0: using guessed type int dword_84886E0;
// 8494A64: using guessed type int dword_8494A64;

//----- (0809308F) --------------------------------------------------------
int *sub_809308F()
{
  char v1; // [esp+4h] [ebp-14h]

  if ( !dword_829F1C0 )
  {
    Com_Printf("Resolving %s\n", "coduomaster.activision.com");
    if ( sub_8084FC8("coduomaster.activision.com", &dword_829F1C0) )
    {
      if ( !strstr(":", "coduomaster.activision.com") )
        word_829F1D2 = sub_808649A(20610);
      sub_808649A(word_829F1D2);
      Com_Printf("coduomaster.activision.com resolved to %i.%i.%i.%i:%i\n", byte_829F1C4);
    }
    else
    {
      Com_Printf("Couldn't resolve address: coduomaster.activision.com\n", v1);
    }
  }
  return &dword_829F1C0;
}
// 80930D5: variable 'v1' is possibly undefined
// 829F1C0: using guessed type int dword_829F1C0;
// 829F1C4: using guessed type char byte_829F1C4;
// 829F1D2: using guessed type __int16 word_829F1D2;

//----- (08093159) --------------------------------------------------------
void __cdecl sub_8093159(const char *a1)
{
  char v1; // [esp+4h] [ebp-24h]
  int *v2; // [esp+24h] [ebp-4h]
  int *v3; // [esp+24h] [ebp-4h]

  if ( dword_84886E0 && *(dword_84886E0 + 32) == 2 )
  {
    if ( svs_time >= dword_84F7058 )
    {
      dword_84F7058 = svs_time + 180000;
      v2 = sub_809308F();
      if ( *v2 != 1 )
      {
        Com_Printf("Sending heartbeat to coduomaster.activision.com\n", v1);
        sub_8084D76(1, *v2, v2[1], v2[2], v2[3], v2[4], "heartbeat %s\n", a1);
      }
    }
    if ( svs_time >= dword_84F705C )
    {
      dword_84F705C = svs_time + 600000;
      v3 = sub_809308F();
      if ( *v3 != 1 )
        sub_8093316(*v3, v3[1], v3[2], v3[3], v3[4]);
    }
  }
}
// 80931AE: variable 'v1' is possibly undefined
// 84886E0: using guessed type int dword_84886E0;
// 84F7008: using guessed type int svs_time;
// 84F7058: using guessed type int dword_84F7058;
// 84F705C: using guessed type int dword_84F705C;

//----- (0809324A) --------------------------------------------------------
void sub_809324A()
{
  int *v0; // [esp+14h] [ebp-4h]

  if ( dword_84886E0 && *(dword_84886E0 + 32) == 2 )
  {
    v0 = sub_809308F();
    if ( *v0 != 1 )
    {
      Com_Printf("Sending gameCompleteStatus to coduomaster.activision.com\n");
      sub_8093702(*v0, v0[1], v0[2], v0[3], v0[4]);
    }
  }
}
// 84886E0: using guessed type int dword_84886E0;

//----- (080932AB) --------------------------------------------------------
void sub_80932AB()
{
  dword_84F7058 = 0x80000000;
  sub_8093159("flatline");
}
// 84F7058: using guessed type int dword_84F7058;

//----- (080932C9) --------------------------------------------------------
#error "8093300: call analysis failed (funcsize=21)"

//----- (08093316) --------------------------------------------------------
void *__cdecl sub_8093316(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char v13[1024]; // [esp+30h] [ebp-8C38h] BYREF
  char v14[4]; // [esp+430h] [ebp-8838h]
  char **v15; // [esp+434h] [ebp-8834h]
  _BYTE *v16; // [esp+438h] [ebp-8830h]
  _BYTE *v17; // [esp+43Ch] [ebp-882Ch]
  char dest[1032]; // [esp+440h] [ebp-8828h] BYREF
  size_t v19; // [esp+848h] [ebp-8420h]
  int v20; // [esp+84Ch] [ebp-841Ch]
  int v21; // [esp+850h] [ebp-8418h]
  int v22; // [esp+854h] [ebp-8414h]
  int v23; // [esp+858h] [ebp-8410h]
  int i; // [esp+85Ch] [ebp-840Ch]
  char v25[32768]; // [esp+860h] [ebp-8408h] BYREF
  char s[1032]; // [esp+8860h] [ebp-408h] BYREF

  *v14 = 0;
  v5 = sub_8074863(8196);
  strcpy(dest, v5);
  v6 = sub_805FF28(1u);
  sub_808733D(dest, "challenge", v6);
  if ( sub_8073AB4("fs_restrict") != 0.0 )
  {
    v7 = sub_8086E7F(dest, "sv_keywords");
    Com_sprintf(v13, 0x400u, "demo %s", v7);
    sub_808733D(dest, "sv_keywords", v13);
  }
  v25[0] = 0;
  v20 = 0;
  for ( i = 0; i < *(dword_8494A64 + 32); ++i )
  {
    v22 = svs_clients + 700596 * i;
    if ( *v22 > 1 )
    {
      v21 = sub_808E105(i);
      v8 = sub_80932C9(v22);
      Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v8, *(v22 + 634928), (v22 + 68164));
      v19 = strlen(s);
      if ( v20 + v19 > 0x7FFF )
        break;
      strcpy(&v25[v20], s);
      v20 += v19;
    }
  }
  if ( *(dword_8494A6C + 32) )
  {
    v9 = sub_8086D78("%i", *(dword_8494A6C + 32));
    sub_808733D(dest, "con_disabled", v9);
  }
  v17 = sub_8073B14("g_password");
  if ( v17 && *v17 )
    sub_808733D(dest, "pswrd", "1");
  else
    sub_808733D(dest, "pswrd", "0");
  v16 = sub_8073B14("fs_game");
  if ( !*(dword_84F6FB8 + 32) || v16 && *v16 )
  {
    *v14 = 1;
  }
  else
  {
    v15 = sub_8073B14("sv_referencedPakNames");
    if ( v15 && *v15 )
    {
      sub_8060257(v15);
      v23 = sub_805FF1E();
      for ( i = 0; i < v23; ++i )
      {
        v10 = sub_805FF28(i);
        if ( !sub_8075B82(v10, "main", *(dword_8484360 + 4)) )
        {
          *v14 = 1;
          break;
        }
      }
    }
  }
  v11 = sub_8086D78("%i", *v14);
  sub_808733D(dest, "mod", v11);
  return sub_8084D76(1, a1, a2, a3, a4, a5, "statusResponse\n%s\n%s", dest, v25);
}
// 80932C9: using guessed type _DWORD __cdecl sub_80932C9(_DWORD);
// 8484360: using guessed type int dword_8484360;
// 8494A64: using guessed type int dword_8494A64;
// 8494A6C: using guessed type int dword_8494A6C;
// 84F6FB8: using guessed type int dword_84F6FB8;

//----- (08093702) --------------------------------------------------------
void *__cdecl sub_8093702(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  int v8; // eax
  char v10[1024]; // [esp+30h] [ebp-8C28h] BYREF
  char dest[1036]; // [esp+430h] [ebp-8828h] BYREF
  size_t v12; // [esp+83Ch] [ebp-841Ch]
  int v13; // [esp+840h] [ebp-8418h]
  int v14; // [esp+844h] [ebp-8414h]
  int v15; // [esp+848h] [ebp-8410h]
  int i; // [esp+84Ch] [ebp-840Ch]
  char v17[32768]; // [esp+850h] [ebp-8408h] BYREF
  char s[1032]; // [esp+8850h] [ebp-408h] BYREF

  v5 = sub_8074863(8196);
  strcpy(dest, v5);
  v6 = sub_805FF28(1u);
  sub_808733D(dest, "challenge", v6);
  if ( sub_8073AB4("fs_restrict") != 0.0 )
  {
    v7 = sub_8086E7F(dest, "sv_keywords");
    Com_sprintf(v10, 0x400u, "demo %s", v7);
    sub_808733D(dest, "sv_keywords", v10);
  }
  v17[0] = 0;
  v13 = 0;
  for ( i = 0; i < *(dword_8494A64 + 32); ++i )
  {
    v15 = svs_clients + 700596 * i;
    if ( *v15 > 1 )
    {
      v14 = sub_808E105(i);
      v8 = sub_80932C9(v15);
      Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v8, *(v15 + 634928), (v15 + 68164));
      v12 = strlen(s);
      if ( v13 + v12 > 0x7FFF )
        return sub_8084D76(1, a1, a2, a3, a4, a5, "gameCompleteStatus\n%s\n%s", dest, v17);
      strcpy(&v17[v13], s);
      v13 += v12;
    }
  }
  return sub_8084D76(1, a1, a2, a3, a4, a5, "gameCompleteStatus\n%s\n%s", dest, v17);
}
// 80932C9: using guessed type _DWORD __cdecl sub_80932C9(_DWORD);
// 8494A64: using guessed type int dword_8494A64;

//----- (0809392E) --------------------------------------------------------
void *__cdecl sub_809392E(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  void *v18; // [esp+24h] [ebp-444h]
  char **v19; // [esp+2Ch] [ebp-43Ch]
  char s[1028]; // [esp+30h] [ebp-438h] BYREF
  char v21[4]; // [esp+434h] [ebp-34h]
  char *v22; // [esp+438h] [ebp-30h]
  char *v23; // [esp+43Ch] [ebp-2Ch]
  char *v24; // [esp+440h] [ebp-28h]
  char *v25; // [esp+444h] [ebp-24h]
  char *nptr; // [esp+448h] [ebp-20h]
  _BYTE *v27; // [esp+44Ch] [ebp-1Ch]
  int v28; // [esp+450h] [ebp-18h]
  int v29; // [esp+454h] [ebp-14h]
  char v30[4]; // [esp+458h] [ebp-10h]
  signed int i; // [esp+45Ch] [ebp-Ch]

  v29 = 0;
  for ( i = 0; i < *(dword_8494A20 + 32); ++i )
  {
    if ( *(svs_clients + 175149 * i) > 1 )
      ++v29;
  }
  *v30 = v29;
  while ( i < *(dword_8494A64 + 32) )
  {
    if ( *(svs_clients + 175149 * i) > 1 )
      ++*v30;
    ++i;
  }
  s[0] = 0;
  v5 = sub_805FF28(1u);
  sub_808733D(s, "challenge", v5);
  v6 = sub_8086D78("%i", 22);
  sub_808733D(s, "protocol", v6);
  sub_808733D(s, "hostname", *(dword_8494A58 + 4));
  sub_808733D(s, "mapname", *(dword_8494A48 + 4));
  if ( *v30 )
  {
    v7 = sub_8086D78("%i", *v30);
    sub_808733D(s, "clients", v7);
  }
  *v21 = *(dword_8494A64 + 32) - (*(dword_8494A20 + 32) - v29);
  if ( *v21 > 0 )
  {
    v8 = sub_8086D78("%i", *v21);
    sub_808733D(s, "sv_maxclients", v8);
  }
  sub_808733D(s, "gametype", *(dword_84F6FD0 + 4));
  if ( *(dword_84F6FB8 + 32) )
  {
    v9 = sub_8086D78("%i", *(dword_84F6FB8 + 32));
    sub_808733D(s, "pure", v9);
  }
  if ( *(dword_84F6FE0 + 32) )
  {
    v10 = sub_8086D78("%i", *(dword_84F6FE0 + 32));
    sub_808733D(s, "minPing", v10);
  }
  if ( *(dword_84F6FB4 + 32) )
  {
    v11 = sub_8086D78("%i", *(dword_84F6FB4 + 32));
    sub_808733D(s, "maxPing", v11);
  }
  v28 = sub_8073B14("fs_game");
  if ( v28 && *v28 )
    sub_808733D(s, "game", v28);
  if ( *(dword_8494A54 + 32) )
  {
    v12 = sub_8086D78("%i", *(dword_8494A54 + 32));
    sub_808733D(s, "sv_allowAnonymous", v12);
  }
  v27 = sub_8073B14("g_password");
  if ( v27 && *v27 )
    sub_808733D(s, "pswrd", "1");
  nptr = sub_8073B14("scr_friendlyfire");
  if ( nptr && atoi(nptr) )
    sub_808733D(s, "ff", nptr);
  v25 = sub_8073B14("scr_killcam");
  if ( v25 && atoi(v25) )
    sub_808733D(s, "kc", v25);
  v24 = sub_8073B14("g_timeoutsallowed");
  if ( v24 && atoi(v24) )
    sub_808733D(s, "timeoutsAllowed", v24);
  v23 = sub_8073B14("scr_allow_jeeps");
  if ( v23 && atoi(v23) )
    sub_808733D(s, "jps", v23);
  v22 = sub_8073B14("scr_allow_tanks");
  if ( v22 && atoi(v22) )
    sub_808733D(s, "tnk", v22);
  v13 = sub_8086D78("%i", 1);
  sub_808733D(s, "hw", v13);
  v14 = sub_8086D78("%i", *(dword_84F6FC4 + 32));
  sub_808733D(s, "pb", v14);
  if ( !*(dword_84F6FB8 + 32) || v28 && *v28 )
  {
LABEL_53:
    v16 = sub_8086D78("%i", 1);
  }
  else
  {
    v19 = sub_8073B14("sv_referencedPakNames");
    if ( v19 && *v19 )
    {
      v18 = sub_8073B14("fs_basegame");
      sub_8060257(v19);
      *v30 = sub_805FF1E();
      for ( i = 0; i < *v30; ++i )
      {
        v15 = sub_805FF28(i);
        if ( !sub_8075B82(v15, "main", v18) )
          goto LABEL_53;
      }
    }
    v16 = sub_8086D78("%i", 0);
  }
  sub_808733D(s, "mod", v16);
  return sub_8084D76(1, a1, a2, a3, a4, a5, "infoResponse\n%s", s);
}
// 8494A20: using guessed type int dword_8494A20;
// 8494A48: using guessed type int dword_8494A48;
// 8494A54: using guessed type int dword_8494A54;
// 8494A58: using guessed type int dword_8494A58;
// 8494A64: using guessed type int dword_8494A64;
// 84F6FB4: using guessed type int dword_84F6FB4;
// 84F6FB8: using guessed type int dword_84F6FB8;
// 84F6FC4: using guessed type int dword_84F6FC4;
// 84F6FD0: using guessed type int dword_84F6FD0;
// 84F6FE0: using guessed type int dword_84F6FE0;

//----- (08093F49) --------------------------------------------------------
void *__cdecl sub_8093F49(char *s)
{
  char v2; // [esp+23h] [ebp-5h]
  signed int i; // [esp+24h] [ebp-4h]

  for ( i = strlen(s); i > 1300; i -= 1300 )
  {
    v2 = s[1300];
    s[1300] = 0;
    sub_8084D76(1, dword_850C060, dword_850C064, dword_850C068, dword_850C06C, dword_850C070, "print\n%s", s);
    s += 1300;
    *s = v2;
  }
  return sub_8084D76(1, dword_850C060, dword_850C064, dword_850C068, dword_850C06C, dword_850C070, "print\n%s", s);
}

//----- (08094031) --------------------------------------------------------
int __cdecl sub_8094031(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  char *v6; // eax
  char *v7; // ebx
  char *v8; // eax
  char *v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char v12[32760]; // [esp+20h] [ebp-8418h] BYREF
  int v13; // [esp+8018h] [ebp-420h]
  int v14; // [esp+801Ch] [ebp-41Ch]
  char s[1028]; // [esp+8020h] [ebp-418h] BYREF
  int v16; // [esp+8424h] [ebp-14h]
  signed int i; // [esp+8428h] [ebp-10h]
  int v18; // [esp+842Ch] [ebp-Ch]

  v16 = sub_807123E();
  if ( !dword_80F5108 || (result = v16 - dword_80F5108, v16 - dword_80F5108 > 499) )
  {
    dword_80F5108 = v16;
    if ( **(dword_84F6FD8 + 4) && (v6 = sub_805FF28(1u), !strcmp(v6, *(dword_84F6FD8 + 4))) )
    {
      v18 = 1;
      v9 = sub_805FF28(2u);
      v10 = sub_80848F8(a1, a2, a3, a4, a5);
      Com_Printf("Rcon from %s:\n%s\n", v10, v9);
    }
    else
    {
      v18 = 0;
      v7 = sub_805FF28(2u);
      v8 = sub_80848F8(a1, a2, a3, a4, a5);
      Com_Printf("Bad rcon from %s:\n%s\n", v8, v7);
    }
    dword_850C060 = a1;
    dword_850C064 = a2;
    dword_850C068 = a3;
    dword_850C06C = a4;
    dword_850C070 = a5;
    sub_806FDE8(v12, 32752, sub_8093F49);
    if ( **(dword_84F6FD8 + 4) )
    {
      if ( v18 )
      {
        v14 = 0;
        v13 = 1024;
        for ( i = 2; i < sub_805FF1E(); ++i )
        {
          v11 = sub_805FF28(i);
          v14 = sub_8072DDE(v11, s, v14, v13, 1);
          v14 = sub_8072DDE(" ", s, v14, v13, 0);
        }
        if ( v14 < v13 )
        {
          s[v14] = 0;
          sub_80603E9(s);
          if ( !sub_8086946(s, "pb_sv_", 6) )
            sub_80B6C2A();
        }
      }
      else
      {
        Com_Printf("Bad rconpassword.\n");
      }
    }
    else
    {
      Com_Printf("No rconpassword set on the server.\n");
    }
    result = sub_806FE21();
  }
  return result;
}
// 80F5108: using guessed type int dword_80F5108;
// 84F6FD8: using guessed type int dword_84F6FD8;

//----- (080942CB) --------------------------------------------------------
void __cdecl sub_80942CB(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  char *v6; // eax
  char *v7; // eax
  char *v8; // [esp+30h] [ebp-18h]
  _DWORD *v9; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]
  int v11; // [esp+3Ch] [ebp-Ch]
  char *v12; // [esp+40h] [ebp-8h]
  char **v13; // [esp+44h] [ebp-4h]

  v10 = -1;
  sub_808016F(a6);
  sub_80808EC(a6);
  sub_8095890(a6[3]);
  if ( sub_8086946((a6[1] + 4), "pb_", 3) )
  {
    if ( !sub_80869EB("connect", (a6[1] + 4), 7) )
      sub_8077435(a6, 12);
    v13 = sub_8080A16(a6);
    sub_8060257(v13);
    v12 = sub_805FF28(0);
    if ( *(dword_8494A2C + 32) )
    {
      v6 = sub_80848F8(a1, a2, a3, a4, a5);
      Com_Printf("SV packet %s : %s\n", v6, v12);
    }
    if ( sub_8086A5A(v12, "getstatus") )
    {
      if ( sub_8086A5A(v12, "getinfo") )
      {
        if ( sub_8086A5A(v12, "getchallenge") )
        {
          if ( sub_8086A5A(v12, "connect") )
          {
            if ( sub_8086A5A(v12, "ipAuthorize") )
            {
              if ( sub_8086A5A(v12, "rcon") )
              {
                if ( sub_8086A5A(v12, "disconnect") )
                {
                  v7 = sub_80848F8(a1, a2, a3, a4, a5);
                  Com_DPrintf("bad connectionless packet from %s:\n%s\n", v7, v13);
                }
              }
              else
              {
                sub_8094031(a1, a2, a3, a4, a5);
              }
            }
            else
            {
              sub_808A1C5(a1, a2, a3, a4, a5);
            }
          }
          else
          {
            if ( sub_8084B24(a1) )
            {
              sub_80B6C80("localhost", a6[1]);
            }
            else
            {
              v8 = sub_80848F8(a1, a2, a3, a4, a5);
              sub_80B6C80(v8, a6[1]);
            }
            SVC_DirectConnect(a1, a2, a3, a4, a5);
          }
        }
        else
        {
          sub_80897D4(a1, a2, a3, a4, a5);
        }
      }
      else
      {
        sub_809392E(a1, a2, a3, a4, a5);
      }
    }
    else
    {
      sub_8093316(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    v11 = 0;
    v9 = svs_clients;
    while ( v11 < *(dword_8494A64 + 32) )
    {
      if ( *v9
        && sub_80848CB(a1, a2, a3, a4, a5, v9[158738], v9[158739], v9[158740], v9[158741], v9[158742])
        && *(v9 + 317485) == HIWORD(a5) )
      {
        v10 = v11;
        break;
      }
      ++v11;
      v9 += 175149;
    }
    if ( *(a6[1] + 7) != 67 && *(a6[1] + 7) != 49 && *(a6[1] + 7) != 74 )
      sub_80B6AE0(13, v10, a6[3] - 4, a6[1] + 4);
  }
}
// 8494A2C: using guessed type int dword_8494A2C;
// 8494A64: using guessed type int dword_8494A64;

//----- (0809475B) --------------------------------------------------------
int sub_809475B()
{
  return *(dword_8494A64 + 32);
}
// 8494A64: using guessed type int dword_8494A64;

//----- (08094768) --------------------------------------------------------
int __cdecl sub_8094768(int a1, void *s)
{
  char *v2; // eax

  memset(s, 0, 0x68u);
  if ( a1 < 0 || a1 >= *(dword_8494A64 + 32) )
    return 0;
  if ( !svs_clients )
    return 0;
  if ( *(svs_clients + 175149 * a1) <= 3 )
    return 0;
  strcpy(s, svs_clients + 700596 * a1 + 68164);
  strcpy(s + 33, svs_clients + 700596 * a1 + 700560);
  v2 = sub_80848F8(
         *(svs_clients + 175149 * a1 + 158738),
         *(svs_clients + 175149 * a1 + 158739),
         *(svs_clients + 175149 * a1 + 158740),
         *(svs_clients + 175149 * a1 + 158741),
         *(svs_clients + 175149 * a1 + 158742));
  strcpy(s + 66, v2);
  return 1;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (08094895) --------------------------------------------------------
int __cdecl sub_8094895(int a1, char *s)
{
  int v2; // eax
  int *v5; // [esp+14h] [ebp-4h]

  *s = 0;
  if ( a1 < 0 || a1 >= *(dword_8494A64 + 32) )
    return 0;
  if ( !svs_clients )
    return 0;
  v5 = (svs_clients + 700596 * a1);
  if ( *v5 <= 3 )
    return 0;
  v2 = sub_80932C9(v5);
  sprintf(s, "ping=%d score=%d", v5[158732], v2);
  return 1;
}
// 80932C9: using guessed type _DWORD __cdecl sub_80932C9(_DWORD);
// 8494A64: using guessed type int dword_8494A64;

//----- (08094930) --------------------------------------------------------
int __cdecl sub_8094930(size_t n, void *src, int a3)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  if ( dword_84F7000 == 1 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(dword_8494A64 + 32) )
        break;
      if ( (a3 < 0 || a3 == i) && *(svs_clients + 175149 * i) > 1 )
        sub_8084F14(
          1,
          *(svs_clients + 175149 * i + 158738),
          *(svs_clients + 175149 * i + 158739),
          *(svs_clients + 175149 * i + 158740),
          *(svs_clients + 175149 * i + 158741),
          *(svs_clients + 175149 * i + 158742),
          src,
          n);
    }
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;
// 84F7000: using guessed type int dword_84F7000;

//----- (080949F4) --------------------------------------------------------
void __cdecl sub_80949F4(int a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  int v6; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( a6[3] > 3 && *a6[1] == -1 )
  {
    sub_80942CB(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    if ( !++dword_8488704 )
      ++dword_8488704;
    dword_80F510C = 1;
    sub_808016F(a6);
    sub_80808EC(a6);
    v6 = sub_8080897(a6);
    v8 = 0;
    for ( i = svs_clients; ; i += 175149 )
    {
      if ( v8 >= *(dword_8494A64 + 32) )
      {
        sub_8084D76(1, a1, a2, a3, a4, a5, "disconnect");
        goto LABEL_21;
      }
      if ( *i
        && sub_80848CB(a1, a2, a3, a4, a5, i[158738], i[158739], i[158740], i[158741], i[158742])
        && i[158743] == v6 )
      {
        break;
      }
      ++v8;
    }
    if ( *(i + 317485) != HIWORD(a5) )
    {
      Com_Printf("SV_ReadPackets: fixing up a translated port\n");
      *(i + 317485) = HIWORD(a5);
    }
    if ( sub_8084378((i + 158736), a6) )
    {
      i[175139] = sub_8080857(a6);
      i[16774] = sub_80808EC(a6);
      if ( i[16774] >= 0 )
      {
        i[16772] = sub_80808EC(a6);
        if ( i[16771] - i[16772] <= 63 )
        {
          sub_809578A(i, (a6[1] + a6[4]), a6[3] - a6[4]);
          if ( *i != 1 )
          {
            i[17159] = svs_time;
            SV_ExecuteClientMessage(i, a6);
          }
        }
        else
        {
          i[16772] = i[16771];
        }
      }
    }
LABEL_21:
    dword_80F510C = 0;
    sub_806C79D();
  }
}
// 80F510C: using guessed type int dword_80F510C;
// 8488704: using guessed type int dword_8488704;
// 8494A64: using guessed type int dword_8494A64;
// 84F7008: using guessed type int svs_time;

//----- (08094CAD) --------------------------------------------------------
int sub_8094CAD()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-14h]
  int v2; // [esp+Ch] [ebp-10h]
  _DWORD *v3; // [esp+10h] [ebp-Ch]
  int j; // [esp+14h] [ebp-8h]
  int i; // [esp+18h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(dword_8494A64 + 32) )
      break;
    v3 = svs_clients + 700596 * i;
    if ( *v3 == 4 )
    {
      if ( v3[17040] )
      {
        v2 = 0;
        v1 = 0;
        for ( j = 0; j <= 31; ++j )
        {
          if ( v3[4424 * j + 21586] > 0 )
          {
            ++v1;
            v2 += v3[4424 * j + 21586] - v3[4424 * j + 21585];
          }
        }
        if ( v1 )
        {
          v3[158732] = v2 / v1;
          if ( v3[158732] > 999 )
            v3[158732] = 999;
        }
        else
        {
          v3[158732] = 999;
        }
      }
      else
      {
        v3[158732] = 999;
      }
    }
    else
    {
      v3[158732] = 999;
    }
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;

//----- (08094DE7) --------------------------------------------------------
int __cdecl sub_8094DE7(int a1)
{
  int result; // eax

  sub_80AA558(*(a1 + 700548));
  result = a1;
  *(a1 + 700548) = 0;
  return result;
}

//----- (08094E0D) --------------------------------------------------------
int sub_8094E0D()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  const char *i; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v2 = svs_time - 1000 * *(dword_84F6FB0 + 32);
  v1 = svs_time - 1000 * *(dword_84F6FD4 + 32);
  v4 = 0;
  for ( i = svs_clients; ; i += 700596 )
  {
    result = v4;
    if ( v4 >= *(dword_8494A64 + 32) )
      break;
    if ( *(i + 17159) > svs_time )
      *(i + 17159) = svs_time;
    if ( !*(i + 175138) )
    {
      if ( *i == 1 && *(i + 17159) < v1 )
      {
        Com_DPrintf("Going from CS_ZOMBIE to CS_FREE for %s\n", i + 68164);
        *i = 0;
      }
      else if ( *i <= 1 || *(i + 17159) >= v2 )
      {
        *(i + 17163) = 0;
      }
      else if ( ++*(i + 17163) > 5 )
      {
        SV_DropClient(i, "EXE_TIMEDOUT");
        *i = 0;
      }
    }
    ++v4;
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;
// 84F6FB0: using guessed type int dword_84F6FB0;
// 84F6FD4: using guessed type int dword_84F6FD4;
// 84F7008: using guessed type int svs_time;

//----- (08094F3A) --------------------------------------------------------
int sub_8094F3A()
{
  int v1; // [esp+0h] [ebp-10h]
  int v2; // [esp+4h] [ebp-Ch]
  int *v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  if ( !*(dword_84898B4 + 32) )
    return 0;
  v4 = 0;
  v2 = 0;
  v3 = svs_clients;
  while ( v2 < *(dword_8494A64 + 32) )
  {
    if ( *v3 > 1 )
      ++v4;
    ++v2;
    v3 += 175149;
  }
  if ( v4 <= 1 )
  {
    *(dword_8488700 + 32) = 1;
    v1 = 1;
  }
  else
  {
    *(dword_8488700 + 32) = 0;
    v1 = 0;
  }
  return v1;
}
// 8488700: using guessed type int dword_8488700;
// 84898B4: using guessed type int dword_84898B4;
// 8494A64: using guessed type int dword_8494A64;

//----- (08094FCA) --------------------------------------------------------
#error "8094FE0: call analysis failed (funcsize=22)"

//----- (08095033) --------------------------------------------------------
void __cdecl sub_8095033(char *client)
{
  int s; // [esp+10h] [ebp-28h] BYREF
  char v2; // [esp+14h] [ebp-24h]
  char v3; // [esp+16h] [ebp-22h]
  char v4; // [esp+24h] [ebp-14h]

  if ( *(client + 17040) )
  {
    memset(&s, 0, 0x18u);
    v3 = *(sub_808E105(-1067678811 * ((client - svs_clients) >> 2)) + 216);
    if ( !sub_8096F2B(-1067678811 * ((client - svs_clients) >> 2)) )
    {
      if ( rand() / 2147483600.0 < 0.5 )
        v2 |= 1u;
      if ( rand() / 2147483600.0 < 0.5 )
        v2 |= 0x40u;
      if ( rand() / 2147483600.0 >= 0.33000001 )
      {
        if ( rand() / 2147483600.0 < 0.5 )
          v4 = -127;
      }
      else
      {
        v4 = 127;
      }
    }
    *(client + 17157) = *(client + 158745) - 1;
    sub_808D829(client, &s);
  }
}
// 8096F2B: using guessed type _DWORD __cdecl sub_8096F2B(_DWORD);

//----- (0809517C) --------------------------------------------------------
int sub_809517C()
{
  char *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( !++dword_8488704 )
    ++dword_8488704;
  dword_80F510C = 1;
  v2 = 0;
  v1 = svs_clients;
  while ( v2 < *(dword_8494A64 + 32) )
  {
    if ( *v1 )
    {
      if ( !*(v1 + 158738) )
        sub_8095033(v1);
    }
    ++v2;
    v1 += 700596;
  }
  dword_80F510C = 0;
  return sub_806C79D();
}
// 80F510C: using guessed type int dword_80F510C;
// 8488704: using guessed type int dword_8488704;
// 8494A64: using guessed type int dword_8494A64;

//----- (08095202) --------------------------------------------------------
void __cdecl sub_8095202(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  int v12; // [esp+64h] [ebp-14h]
  int v13; // [esp+68h] [ebp-10h]
  int v14; // [esp+6Ch] [ebp-Ch]

  v12 = 0;
  if ( *(dword_8494A3C + 32) )
  {
    sub_80702FC("EXE_SERVERKILLED");
    sub_8073798("sv_killserver", "0");
  }
  else if ( *(dword_84897C0 + 32) && !sub_8094F3A() )
  {
    if ( *(dword_8494A34 + 32) <= 0 )
      sub_8073798("sv_fps", "10");
    v14 = 1000 / *(dword_8494A34 + 32);
    dword_8494A90 += a1;
    if ( dword_8494A90 >= v14 )
    {
      if ( svs_time <= 1879048192 && dword_84F7004 <= 1879048192 )
      {
        if ( dword_84F701C < 2147483646 - dword_84F7014 )
        {
          if ( dword_84F7040 <= 2147467261 )
          {
            if ( dword_84F7044 <= 2147479549 )
            {
              if ( dword_84F7030 <= 2147482445 )
              {
                if ( dword_84F703C <= 2113929213 )
                {
                  if ( dword_84F7048 <= 2147483133 )
                  {
                    if ( dword_84F7020 < 2147483646 - dword_84F7018 )
                    {
                      sub_80C0C82(1);
                      if ( (dword_84898D8 & 0x2004) != 0 )
                      {
                        v9 = sub_8074863(8196);
                        sub_8090DA8(0, v9);
                        dword_84898D8 &= 0xFFFFDFFB;
                      }
                      if ( (dword_84898D8 & 8) != 0 )
                      {
                        v10 = sub_80748C0(8);
                        sub_8090DA8(1, v10);
                        dword_84898D8 &= 0xFFFFFFF7;
                      }
                      if ( (dword_84898D8 & 0x800) != 0 )
                      {
                        sub_807480C(149, 128, 2048);
                        dword_84898D8 &= 0xFFFFF7FF;
                      }
                      sub_809517C();
                      if ( *(dword_84898C0 + 32) )
                        v12 = sub_80CA93C();
                      else
                        v12 = 0;
                      sub_8094CAD();
                      v13 = sub_8071D30(v14);
                      while ( 1 )
                      {
                        dword_8494A90 -= v14;
                        svs_time += v14;
                        dword_84F7004 += v13;
                        sub_8094FCA();
                        sub_80AA8A0(0);
                        if ( v14 <= 0 || dword_8494A90 < v14 )
                          break;
                        sub_8098E10();
                      }
                      if ( *(dword_84898C0 + 32) )
                        dword_848972C = sub_80CA93C() - v12;
                      sub_8094E0D();
                      sub_8099A2C();
                      if ( *(dword_8488714 + 28) > 0.0 )
                        sub_8098E10();
                      sub_8093159("COD-1");
                    }
                    else
                    {
                      Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
                      sub_80702FC(aExeServerresta_0);
                      v8 = sub_8086D78("map %s\n", dest);
                      sub_805F9FA(v8);
                    }
                  }
                  else
                  {
                    Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
                    sub_80702FC(aExeServerresta_1);
                    v7 = sub_8086D78("map %s\n", dest);
                    sub_805F9FA(v7);
                  }
                }
                else
                {
                  Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
                  sub_80702FC(aExeServerresta_2);
                  v6 = sub_8086D78("map %s\n", dest);
                  sub_805F9FA(v6);
                }
              }
              else
              {
                Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
                sub_80702FC(aExeServerresta_3);
                v5 = sub_8086D78("map %s\n", dest);
                sub_805F9FA(v5);
              }
            }
            else
            {
              Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
              sub_80702FC(aExeServerresta_4);
              v4 = sub_8086D78("map %s\n", dest);
              sub_805F9FA(v4);
            }
          }
          else
          {
            Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
            sub_80702FC(aExeServerresta_5);
            v3 = sub_8086D78("map %s\n", dest);
            sub_805F9FA(v3);
          }
        }
        else
        {
          Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
          sub_80702FC(aExeServerresta_6);
          v2 = sub_8086D78("map %s\n", dest);
          sub_805F9FA(v2);
        }
      }
      else
      {
        Q_strncpyz(dest, *(dword_8494A48 + 4), 64);
        sub_80702FC("EXE_SERVERRESTARTTIMEWRAP");
        v1 = sub_8086D78("map %s\n", dest);
        sub_805F9FA(v1);
      }
    }
  }
}
// 8094FCA: using guessed type int sub_8094FCA(void);
// 8488714: using guessed type int dword_8488714;
// 848972C: using guessed type int dword_848972C;
// 84897C0: using guessed type int dword_84897C0;
// 84898C0: using guessed type int dword_84898C0;
// 84898D8: using guessed type int dword_84898D8;
// 8494A34: using guessed type int dword_8494A34;
// 8494A3C: using guessed type int dword_8494A3C;
// 8494A48: using guessed type int dword_8494A48;
// 8494A90: using guessed type int dword_8494A90;
// 84F7004: using guessed type int dword_84F7004;
// 84F7008: using guessed type int svs_time;
// 84F7014: using guessed type int dword_84F7014;
// 84F7018: using guessed type int dword_84F7018;
// 84F701C: using guessed type int dword_84F701C;
// 84F7020: using guessed type int dword_84F7020;
// 84F7030: using guessed type int dword_84F7030;
// 84F703C: using guessed type int dword_84F703C;
// 84F7040: using guessed type int dword_84F7040;
// 84F7044: using guessed type int dword_84F7044;
// 84F7048: using guessed type int dword_84F7048;

//----- (080956DE) --------------------------------------------------------
void __cdecl sub_80956DE(const char *a1, const char *a2)
{
  Com_Printf("%s: %s\n", a1, a2);
}

//----- (08095700) --------------------------------------------------------
int __cdecl sub_8095700(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 67136;
  v5[4] = 0;
  *v5 = (*(a1 + 67104) ^ *(a1 + 634980));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(v4 + *&v5[1]) )
      *&v5[1] = 0;
    v5[0] ^= *(v4 + (*&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (0809578A) --------------------------------------------------------
int __cdecl sub_809578A(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 1032 * (*(a1 + 67088) & 0x3F) + 1036;
  v5[4] = 0;
  *v5 = (*(a1 + 67096) ^ *(a1 + 700556) ^ *(a1 + 67104));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(v4 + *&v5[1]) )
      *&v5[1] = 0;
    v5[0] ^= *(v4 + (*&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (08095838) --------------------------------------------------------
int *__cdecl SV_Netchan_TransmitNextFragment(int *a1)
{
  return sub_8083FD0(a1);
}

//----- (0809584B) --------------------------------------------------------
int *__cdecl sub_809584B(int a1, void *src, size_t n)
{
  sub_8095700(a1, src + 4, n - 4);
  return sub_80841CE(a1 + 634944, n, src);
}

//----- (08095890) --------------------------------------------------------
int __cdecl sub_8095890(int a1)
{
  int result; // eax

  result = dword_8489A64;
  if ( *(dword_8489A64 + 32) )
  {
    sub_8083884(&dword_850C088);
    result = sub_8083973(dword_850C088, a1, 0);
  }
  return result;
}
// 8489A64: using guessed type int dword_8489A64;
// 850C088: using guessed type int dword_850C088;

//----- (0809593B) --------------------------------------------------------
int sub_809593B()
{
  int result; // eax
  _DWORD **i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( svs_clients )
  {
    if ( dword_850C088 )
    {
      sub_8083B00(dword_850C088);
      sub_8083B00((dword_850C088 + 752));
    }
    v2 = 0;
    for ( i = svs_clients; ; i += 175149 )
    {
      result = v2;
      if ( v2 >= *(dword_8494A64 + 32) )
        break;
      if ( *i )
      {
        if ( i[175135] )
        {
          sub_8083B00(i[175135]);
          sub_8083B00(i[175135] + 188);
        }
      }
      ++v2;
    }
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;
// 850C088: using guessed type int dword_850C088;

//----- (080959E7) --------------------------------------------------------
int __cdecl sub_80959E7(int a1)
{
  int result; // eax
  int v2; // [esp+2Ch] [ebp-4CCh]
  int v3; // [esp+60h] [ebp-498h]
  int v4; // [esp+68h] [ebp-490h]
  int v5; // [esp+70h] [ebp-488h]
  int v6; // [esp+78h] [ebp-480h]
  int v7; // [esp+84h] [ebp-474h]
  int v8; // [esp+88h] [ebp-470h]
  int v9; // [esp+8Ch] [ebp-46Ch]
  char s[1024]; // [esp+90h] [ebp-468h] BYREF
  char dest[40]; // [esp+490h] [ebp-68h] BYREF
  char *i; // [esp+4B8h] [ebp-40h]
  _DWORD *v13; // [esp+4BCh] [ebp-3Ch]
  int v14; // [esp+4C0h] [ebp-38h]
  int v15; // [esp+4C4h] [ebp-34h]
  int v16; // [esp+4C8h] [ebp-30h]
  int v17; // [esp+4CCh] [ebp-2Ch]
  int v18; // [esp+4D0h] [ebp-28h]
  int v19; // [esp+4D4h] [ebp-24h]
  int v20; // [esp+4D8h] [ebp-20h]
  int v21; // [esp+4DCh] [ebp-1Ch]
  int v22; // [esp+4E0h] [ebp-18h]
  int v23; // [esp+4E4h] [ebp-14h]
  char v24[4]; // [esp+4E8h] [ebp-10h]
  int v25[3]; // [esp+4ECh] [ebp-Ch]

  *v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 9999;
  v16 = 0;
  v15 = 9999;
  if ( svs_clients )
  {
    sub_809593B();
    if ( a1 )
      Com_Printf("\n\n");
    Com_sprintf(s, 0x400u, "====================");
    if ( a1 )
      Com_Printf("%s\n", s);
    Com_sprintf(s, 0x400u, "Server Network Profile:");
    if ( a1 )
      Com_Printf("%s\n\n", s);
    Com_sprintf(
      s,
      0x400u,
      "                    | Sent To                | Recieved From          | Total Source Traffic   |");
    if ( a1 )
      Com_Printf("%s\n", s);
    Com_sprintf(
      s,
      0x400u,
      "              Source|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|");
    if ( a1 )
      Com_Printf("%s\n", s);
    if ( dword_850C088 )
    {
      v13 = dword_850C088;
      *v24 += *(dword_850C088 + 724);
      v22 += *(dword_850C088 + 732);
      v21 += *(dword_850C088 + 736);
      v23 += *(dword_850C088 + 1476);
      v20 += *(dword_850C088 + 1484);
      v19 += *(dword_850C088 + 1488);
      if ( *(dword_850C088 + 744) > v18 )
        v18 = v13[186];
      if ( v13[187] < v17 )
        v17 = v13[187];
      if ( v13[374] > v16 )
        v16 = v13[374];
      if ( v13[375] < v15 )
        v15 = v13[375];
    }
    v25[0] = 0;
    i = svs_clients;
    while ( v25[0] < *(dword_8494A64 + 32) )
    {
      if ( *i && *(i + 175135) )
      {
        v13 = *(i + 175135);
        *v24 += v13[181];
        v22 += v13[183];
        v21 += v13[184];
        v23 += v13[369];
        v20 += v13[371];
        v19 += v13[372];
        if ( v13[186] > v18 )
          v18 = v13[186];
        if ( v13[187] < v17 )
          v17 = v13[187];
        if ( v13[374] > v16 )
          v16 = v13[374];
        if ( v13[375] < v15 )
          v15 = v13[375];
      }
      ++v25[0];
      i += 700596;
    }
    if ( v22 + v20 <= 0 || v21 + v19 <= 0 )
      v14 = 0;
    else
      v14 = 100 * (v19 + v21) / (v20 + v22);
    v9 = v15;
    if ( v15 > v17 )
      v9 = v17;
    v8 = v16;
    if ( v16 < v18 )
      v8 = v18;
    v2 = *v24 + v23;
    if ( v20 )
      v7 = 100 * v19 / v20;
    else
      v7 = 0;
    if ( v22 )
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *v24,
        v18,
        v17,
        100 * v21 / v22,
        v23,
        v16,
        v15,
        v7,
        v2,
        v8,
        v9,
        v14);
    else
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *v24,
        v18,
        v17,
        0,
        v23,
        v16,
        v15,
        v7,
        v2,
        v8,
        v9,
        v14);
    if ( a1 )
      Com_Printf("%s\n", s);
    if ( dword_850C088 )
    {
      v13 = dword_850C088;
      if ( *(dword_850C088 + 732) + *(dword_850C088 + 1484) <= 0 || v13[184] + v13[372] <= 0 )
        v14 = 0;
      else
        v14 = 100 * (v13[372] + v13[184]) / (v13[371] + v13[183]);
      v6 = v13[375];
      if ( v6 > v13[187] )
        v6 = v13[187];
      v5 = v13[374];
      if ( v5 < v13[186] )
        v5 = v13[186];
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
        v13[181],
        v13[186],
        v13[187],
        v13[185],
        v13[369],
        v13[374],
        v13[375],
        v13[373],
        v13[181] + v13[369],
        v5,
        v6,
        v14);
      if ( !a1 )
        goto LABEL_63;
    }
    else
    {
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages:     0|    0|    0|   - |     0|    0|    0|   - |     0|    0|    0|   - |");
      if ( !a1 )
      {
LABEL_63:
        v25[0] = 0;
        for ( i = svs_clients; ; i += 700596 )
        {
          result = v25[0];
          if ( v25[0] >= *(dword_8494A64 + 32) )
            return result;
          if ( *i )
          {
            strncpy(dest, i + 68164, 0x11u);
            dest[16] = 0;
            v13 = *(i + 175135);
            if ( !v13 )
            {
              Com_sprintf(
                s,
                0x400u,
                "#%2i-%16s:     0|    0|    0|   0%%|     0|    0|    0|   0%%|     0|    0|    0|   0%%|",
                v25[0],
                dest);
              if ( !a1 )
                goto LABEL_79;
LABEL_78:
              Com_Printf("%s\n", s);
              goto LABEL_79;
            }
            if ( v13[183] + v13[371] <= 0 || v13[184] + v13[372] <= 0 )
              v14 = 0;
            else
              v14 = 100 * (v13[372] + v13[184]) / (v13[371] + v13[183]);
            v4 = v13[375];
            if ( v4 > v13[187] )
              v4 = v13[187];
            v3 = v13[374];
            if ( v3 < v13[186] )
              v3 = v13[186];
            Com_sprintf(
              s,
              0x400u,
              "#%2i-%16s: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
              v25[0],
              dest,
              v13[181],
              v13[186],
              v13[187],
              v13[185],
              v13[369],
              v13[374],
              v13[375],
              v13[373],
              v13[181] + v13[369],
              v3,
              v4,
              v14);
            if ( a1 )
              goto LABEL_78;
          }
LABEL_79:
          ++v25[0];
        }
      }
    }
    Com_Printf("%s\n", s);
    goto LABEL_63;
  }
  return result;
}
// 8494A64: using guessed type int dword_8494A64;
// 850C088: using guessed type int dword_850C088;

//----- (080963B4) --------------------------------------------------------
int __cdecl sub_80963B4(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  int *v11; // [esp+24h] [ebp-4h]

  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  while ( v8 < a3 || v9 < a1 )
  {
    if ( v8 < a3 )
    {
      v10 = (dword_84F7024 + 244 * ((a4 + v8) % dword_84F7014));
      v6 = *v10;
    }
    else
    {
      v6 = 9999;
    }
    if ( v9 < a1 )
    {
      v11 = (dword_84F7024 + 244 * ((a2 + v9) % dword_84F7014));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v6 == v7 )
    {
      MSG_WriteDeltaEntity(a5, v11, v10, 0);
      ++v9;
      ++v8;
    }
    else if ( v6 >= v7 )
    {
      if ( v6 > v7 )
      {
        MSG_WriteDeltaEntity(a5, v11, 0, 1);
        ++v9;
      }
    }
    else
    {
      MSG_WriteDeltaEntity(a5, (384 * v6 + 139030176), v10, 1);
      ++v8;
    }
  }
  return sub_8080188(a5, 1023, 10);
}
// 84F7014: using guessed type int dword_84F7014;
// 84F7024: using guessed type int dword_84F7024;

//----- (08096527) --------------------------------------------------------
_DWORD *__cdecl sub_8096527(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  int *v11; // [esp+24h] [ebp-4h]

  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  while ( v8 < a3 || v9 < a1 )
  {
    if ( v8 < a3 )
    {
      v10 = (dword_84F7028 + 92 * ((a4 + v8) % dword_84F7018));
      v6 = *v10;
    }
    else
    {
      v6 = 9999;
    }
    if ( v9 < a1 )
    {
      v11 = (dword_84F7028 + 92 * ((a2 + v9) % dword_84F7018));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v6 == v7 )
    {
      sub_8081EF2(a5, v11, v10, 0);
      ++v9;
      ++v8;
    }
    else if ( v6 >= v7 )
    {
      if ( v6 > v7 )
      {
        sub_8081EF2(a5, v11, 0, 1);
        ++v9;
      }
    }
    else
    {
      sub_8081EF2(a5, 0, v10, 1);
      ++v8;
    }
  }
  return sub_808024E(a5);
}
// 84F7018: using guessed type int dword_84F7018;
// 84F7028: using guessed type int dword_84F7028;

//----- (08096673) --------------------------------------------------------
int __cdecl SV_WriteSnapshotToClient(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  char v5; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  char *v8; // [esp+30h] [ebp-8h]
  _DWORD *v9; // [esp+34h] [ebp-4h]

  v9 = &a1[4424 * (a1[158745] & 0x1F) + 17164];
  if ( a1[17157] > 0 && *a1 == 4 )
  {
    if ( a1[158745] - a1[17157] <= 28 )
    {
      v8 = &a1[4424 * (a1[17157] & 0x1F) + 17164];
      v7 = a1[158745] - a1[17157];
      if ( a1[4424 * (a1[17157] & 0x1F) + 21583] < dword_84F701C - dword_84F7014 )
      {
        Com_DPrintf("%s: Delta request from out of date entities.\n", a1 + 68164);
        v8 = 0;
        LOBYTE(v7) = 0;
      }
    }
    else
    {
      Com_DPrintf("%s: Delta request from out of date packet.\n", a1 + 68164);
      v8 = 0;
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    v8 = 0;
    LOBYTE(v7) = 0;
  }
  MSG_WriteByte(a2, 7);
  MSG_WriteLong(a2, dword_84F7004);
  MSG_WriteByte(a2, v7);
  v5 = dword_84F700C;
  if ( a1[17162] )
    v5 = dword_84F700C | 1;
  if ( *a1 == 4 )
  {
    a1[1] = 1;
  }
  else if ( *a1 != 1 )
  {
    a1[1] = 0;
  }
  if ( !a1[1] )
    v5 |= 2u;
  MSG_WriteByte(a2, v5);
  if ( v8 )
  {
    sub_8082826(a2, v8, v9);
    v4 = *(v8 + 4418);
    v3 = *(v8 + 4420);
    sub_80963B4(*(v8 + 4417), *(v8 + 4419), v9[4417], v9[4419], a2);
  }
  else
  {
    sub_8082826(a2, 0, v9);
    v4 = 0;
    v3 = 0;
    sub_80963B4(0, 0, v9[4417], v9[4419], a2);
  }
  sub_8096527(v4, v3, v9[4418], v9[4420], a2);
  result = dword_8494A68;
  if ( *(dword_8494A68 + 32) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(dword_8494A68 + 32) )
        break;
      MSG_WriteByte(a2, 1);
    }
  }
  return result;
}
// 8494A68: using guessed type int dword_8494A68;
// 84F7004: using guessed type int dword_84F7004;
// 84F700C: using guessed type int dword_84F700C;
// 84F7014: using guessed type int dword_84F7014;
// 84F701C: using guessed type int dword_84F701C;

//----- (08096937) --------------------------------------------------------
_DWORD *__cdecl SV_UpdateServerCommandsToClient(_DWORD *client, int msg)
{
  _DWORD *result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = client[16772] + 1; i <= client[16771]; ++i )
  {
    MSG_WriteByte(msg, 5);
    MSG_WriteLong(msg, i);
    sub_8080607(msg, &client[258 * (i & 0x3F) + 259]);
  }
  result = client;
  client[16773] = client[16771];
  return result;
}

//----- (080969C1) --------------------------------------------------------
int __cdecl sub_80969C1(_DWORD *a1, _DWORD *a2, signed int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int v5; // [esp+14h] [ebp-4h]

  for ( i = a1[16772] + 1; i <= a1[16771] && (a2[3] + strlen(&a1[258 * (i & 0x3F) + 259]) + 6) < a3; ++i )
  {
    MSG_WriteByte(a2, 5);
    MSG_WriteLong(a2, i);
    sub_8080607(a2, &a1[258 * (i & 0x3F) + 259]);
  }
  v5 = i - 1;
  result = v5;
  if ( v5 > a1[16773] )
  {
    result = v5;
    a1[16773] = v5;
  }
  return result;
}

//----- (08096A94) --------------------------------------------------------
int __cdecl sub_8096A94(int a1)
{
  char v2; // [esp+4h] [ebp-14h]
  int i; // [esp+14h] [ebp-4h]

  Com_Printf("-- Unacknowledged Server Commands for client %i:%s --\n", -91 * ((a1 - svs_clients) >> 2));
  for ( i = *(a1 + 67088) + 1; i <= *(a1 + 67084); ++i )
    Com_Printf("cmd %5d: %8d: %s\n", i);
  return Com_Printf("----------", v2);
}
// 8096B44: variable 'v2' is possibly undefined

//----- (08096B4B) --------------------------------------------------------
_DWORD *__cdecl sub_8096B4B(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (08096B71) --------------------------------------------------------
_DWORD *__cdecl sub_8096B71(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (08096B97) --------------------------------------------------------
int __cdecl sub_8096B97(float *a1, int a2, _DWORD *a3)
{
  int result; // eax
  char *v4; // eax
  int v5; // [esp+8h] [ebp-40h]
  int v6; // [esp+Ch] [ebp-3Ch]
  int v7; // [esp+10h] [ebp-38h]
  int v8; // [esp+14h] [ebp-34h]
  int v9; // [esp+18h] [ebp-30h]
  float v10; // [esp+18h] [ebp-30h]
  int v11; // [esp+1Ch] [ebp-2Ch]
  int v12; // [esp+20h] [ebp-28h]
  int v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  int v15; // [esp+2Ch] [ebp-1Ch]
  int v16; // [esp+30h] [ebp-18h]
  int v17; // [esp+30h] [ebp-18h]
  int v18; // [esp+34h] [ebp-14h]
  int v19; // [esp+34h] [ebp-14h]
  _DWORD *v20; // [esp+38h] [ebp-10h]
  int *v21; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]

  v12 = sub_805723E(a1);
  result = sub_804BD86(v12);
  v16 = result;
  if ( result >= 0 )
  {
    v15 = sub_804BD70(v12);
    v4 = sub_805784E(v15);
    v10 = COERCE_FLOAT(VM_Call(gvm, 23, v5, v6, v7, v8, v9, v11, v12, v13, v4, v15, v16, v18));
    if ( v10 == 3.4028235e38 )
      v10 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_84F6EA4 )
        return result;
      v21 = SV_GentityNum(i);
      if ( v21[61] )
      {
        if ( v21[1] == 9 && v21[29] != 1023 )
          v21 = SV_GentityNum(v21[29]);
        if ( (v21[62] & 1) == 0
          && ((v21[62] & 0x800) == 0 || v21[63] == a2)
          && ((v21[62] & 0x2000) == 0 || v21[63] != a2)
          && i != a2 )
        {
          if ( (v21[62] & 0x18) != 0 )
            goto LABEL_41;
          if ( v21[64] )
          {
            if ( v21[64] < 0 || v21[64] - dword_84F7004 >= 0 )
              goto LABEL_41;
            v21[64] = 0;
          }
          v20 = sub_808E122(v21);
          if ( (v21[1] != 1 || (v21[2] & 0x100000) == 0 || *(SV_GentityNum(v21[85]) + 136) != 2 || (v21[34] & 7) != 1)
            && (sub_8057ABD(v17, v20[89]) || sub_8057ABD(v17, v20[90]))
            && v20[71] )
          {
            v19 = 0;
            for ( j = 0; j < v20[71]; ++j )
            {
              v19 = v20[j + 72];
              if ( ((*((v19 >> 3) + v14) >> (v19 & 7)) & 1) != 0 )
                break;
            }
            if ( j != v20[71] )
              goto LABEL_45;
            if ( v20[88] )
            {
              while ( v19 <= v20[88] && ((*((v19 >> 3) + v14) >> (v19 & 7)) & 1) == 0 )
                ++v19;
              if ( v19 != v20[88] )
              {
LABEL_45:
                if ( v10 == 0.0 || !sub_806AB7E((v21 + 73), (v21 + 76), a1, v10) )
                {
LABEL_41:
                  sub_8096B4B(i, a3);
                  continue;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 8096BF0: variable 'v5' is possibly undefined
// 8096BF0: variable 'v6' is possibly undefined
// 8096BF0: variable 'v7' is possibly undefined
// 8096BF0: variable 'v8' is possibly undefined
// 8096BF0: variable 'v9' is possibly undefined
// 8096BF0: variable 'v11' is possibly undefined
// 8096BF0: variable 'v13' is possibly undefined
// 8096BF0: variable 'v18' is possibly undefined
// 8096DD0: variable 'v17' is possibly undefined
// 8096E4A: variable 'v14' is possibly undefined
// 84F6EA4: using guessed type int dword_84F6EA4;
// 84F7004: using guessed type int dword_84F7004;

//----- (08096F2B) --------------------------------------------------------
#error "8096F48: call analysis failed (funcsize=11)"

//----- (08096F4F) --------------------------------------------------------
int __cdecl sub_8096F4F(int a1, int a2, float *a3, int a4, _DWORD *a5, int a6)
{
  int result; // eax
  int v7; // [esp+8h] [ebp-260h]
  int v8; // [esp+Ch] [ebp-25Ch]
  int v9; // [esp+10h] [ebp-258h]
  int v10; // [esp+14h] [ebp-254h]
  int v11; // [esp+18h] [ebp-250h]
  int v12; // [esp+1Ch] [ebp-24Ch]
  int v13; // [esp+20h] [ebp-248h]
  int v14; // [esp+24h] [ebp-244h]
  int v15; // [esp+28h] [ebp-240h]
  float v16; // [esp+28h] [ebp-240h]
  int v17; // [esp+2Ch] [ebp-23Ch]
  int v18; // [esp+30h] [ebp-238h]
  int v19; // [esp+34h] [ebp-234h]
  int v20; // [esp+34h] [ebp-234h]
  int v21; // [esp+38h] [ebp-230h]
  int v22; // [esp+3Ch] [ebp-22Ch] BYREF
  int v23[129]; // [esp+40h] [ebp-228h] BYREF
  int v24; // [esp+244h] [ebp-24h]
  char *v25; // [esp+248h] [ebp-20h]
  int v26; // [esp+24Ch] [ebp-1Ch]
  int v27; // [esp+250h] [ebp-18h]
  _DWORD *v28; // [esp+254h] [ebp-14h]
  int j; // [esp+258h] [ebp-10h]
  int i; // [esp+25Ch] [ebp-Ch]

  v18 = sub_805723E(a3);
  result = sub_804BD86(v18);
  v27 = result;
  if ( result >= 0 )
  {
    v26 = sub_804BD70(v18);
    v25 = sub_805784E(v26);
    v16 = COERCE_FLOAT(VM_Call(gvm, 23, v7, v8, v9, v10, v11, v12, v13, v14, v15, v17, v18, v19));
    if ( v16 == 3.4028235e38 )
      v16 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a1 )
        break;
      v28 = dword_84F704C + 276 * ((i + a2) % 0x4000);
      if ( ((v28[61] & 0x800) == 0 || v28[62] == a4)
        && ((v28[61] & 0x2000) == 0 || v28[62] != a4)
        && (*v28 != a4 || (*(a6 + 12) & 0x40000) == 0) )
      {
        if ( (v28[61] & 0x18) != 0 )
          goto LABEL_27;
        v24 = sub_8057491(v28 + 63, v28 + 66, v23, 128, &v22);
        if ( v24 )
        {
          for ( j = 0; j < v24; ++j )
          {
            v21 = sub_804BD86(v23[j]);
            if ( sub_8057ABD(v27, v21) )
              break;
          }
          if ( j != v24 )
          {
            for ( j = 0; j < v24; ++j )
            {
              v20 = sub_804BD70(v23[j]);
              if ( v20 != -1 && ((v25[v20 >> 3] >> (v20 & 7)) & 1) != 0 )
                break;
            }
            if ( j != v24 && (v16 == 0.0 || !sub_806AB7E((v28 + 63), (v28 + 66), a3, v16)) )
LABEL_27:
              sub_8096B71(i, a5);
          }
        }
      }
    }
  }
  return result;
}
// 8096FB4: variable 'v7' is possibly undefined
// 8096FB4: variable 'v8' is possibly undefined
// 8096FB4: variable 'v9' is possibly undefined
// 8096FB4: variable 'v10' is possibly undefined
// 8096FB4: variable 'v11' is possibly undefined
// 8096FB4: variable 'v12' is possibly undefined
// 8096FB4: variable 'v13' is possibly undefined
// 8096FB4: variable 'v14' is possibly undefined
// 8096FB4: variable 'v15' is possibly undefined
// 8096FB4: variable 'v17' is possibly undefined
// 8096FB4: variable 'v19' is possibly undefined

//----- (08097250) --------------------------------------------------------
#error "809726D: call analysis failed (funcsize=11)"

//----- (08097274) --------------------------------------------------------
#error "8097298: call analysis failed (funcsize=13)"

//----- (0809729F) --------------------------------------------------------
_DWORD *__cdecl sub_809729F(int a1)
{
  _DWORD *v1; // ebx
  int *v2; // ebx
  int *v3; // ebx
  _DWORD *v4; // ebx
  int *v5; // ebx
  char v7; // [esp+8h] [ebp-200E0h]
  int v9[32768]; // [esp+80h] [ebp-20068h] BYREF
  int s; // [esp+20080h] [ebp-68h] BYREF
  void *dest; // [esp+20084h] [ebp-64h]
  size_t n; // [esp+2008Ch] [ebp-5Ch]
  int v13; // [esp+20090h] [ebp-58h]
  int v14; // [esp+200A8h] [ebp-40h]
  int v15; // [esp+200ACh] [ebp-3Ch]
  int v16; // [esp+200B0h] [ebp-38h]
  int v17; // [esp+200B4h] [ebp-34h]
  size_t v18; // [esp+200B8h] [ebp-30h]
  int v19; // [esp+200BCh] [ebp-2Ch]
  _DWORD *v20; // [esp+200C0h] [ebp-28h]
  int v21; // [esp+200C4h] [ebp-24h]
  int i; // [esp+200C8h] [ebp-20h]
  int v23; // [esp+200CCh] [ebp-1Ch]
  int v24; // [esp+200D0h] [ebp-18h]
  void *v25; // [esp+200D4h] [ebp-14h]
  int v26; // [esp+200D8h] [ebp-10h]
  _DWORD *v27; // [esp+200DCh] [ebp-Ch]

  v20 = dword_84F7034 + 8 * (a1 % 1200);
  if ( *v20 >= dword_84F703C - 0x2000000 )
  {
    v17 = dword_84F7048 - 512;
    if ( dword_84F7048 - 512 < 0 )
      v17 = 0;
    for ( i = dword_84F7048 - 1; i >= v17; --i )
    {
      v27 = dword_84F7054 + 28 * (i % 512);
      if ( *v27 == a1 )
      {
        if ( v27[3] >= dword_84F7040 - 0x4000 && v27[5] >= dword_84F7044 - 4096 )
          return v27;
        break;
      }
    }
    MSG_Init(&s, v9, 0x20000);
    n = v20[1];
    v19 = *v20 % 0x2000000;
    v18 = 0x2000000 - v19;
    if ( n > 0x2000000 - v19 )
    {
      memcpy(dest, dword_84F7038 + v19, v18);
      memcpy(dest + v18, dword_84F7038, n - v18);
    }
    else
    {
      memcpy(dest, dword_84F7038 + v19, n);
    }
    if ( sub_80803C6(&s) )
    {
      v27 = dword_84F7054 + 28 * (dword_84F7048 % 512);
      *v27 = a1;
      v27[2] = 0;
      v27[3] = dword_84F7040;
      v27[4] = 0;
      v27[5] = dword_84F7044;
      v27[6] = 0;
      v4 = v27;
      v4[1] = sub_80808EC(&s);
      while ( sub_80803C6(&s) )
      {
        v21 = sub_8080344(&s, 6);
        if ( v13 > n )
          sub_80704AC(1, &byte_80E6700, v7);
        v24 = dword_84F7050 + 17764 * (dword_84F7044 % 4096);
        sub_80824E0(&s, 0, (v24 + 4), v21);
        v5 = v24;
        *v5 = sub_80803C6(&s);
        if ( *v24 )
          sub_80830ED(&s, 0, (v24 + 96));
        if ( ++dword_84F7044 > 2147483645 )
          sub_80704AC(0, &byte_80E6740, v7);
        ++v27[4];
      }
      while ( 1 )
      {
        v21 = sub_8080344(&s, 10);
        if ( v21 == 1023 )
          break;
        if ( v13 > n )
          sub_80704AC(1, &byte_80E6700, v7);
        v25 = dword_84F704C + 276 * (dword_84F7040 % 0x4000);
        sub_808249A(&s, (384 * v21 + 139030176), v25, v21);
        if ( ++dword_84F7040 > 2147483645 )
          sub_80704AC(0, &byte_80E6780, v7);
        ++v27[2];
      }
      if ( ++dword_84F7048 > 2147483645 )
        sub_80704AC(0, &byte_80E67C0, v7);
    }
    else
    {
      v16 = sub_80808EC(&s);
      if ( v16 < dword_84F7030 - 1200 )
        return 0;
      v20 = dword_84F7034 + 8 * (v16 % 1200);
      if ( *v20 < dword_84F703C - 0x2000000 )
        return 0;
      v26 = sub_809729F(v16);
      if ( !v26 )
        return 0;
      v27 = dword_84F7054 + 28 * (dword_84F7048 % 512);
      *v27 = a1;
      v27[2] = 0;
      v27[3] = dword_84F7040;
      v27[4] = 0;
      v27[5] = dword_84F7044;
      v27[6] = 1;
      v1 = v27;
      v1[1] = sub_80808EC(&s);
      v15 = 0;
      v23 = 0;
      if ( *(v26 + 16) > 0 )
      {
        v23 = dword_84F7050 + 17764 * ((v15 + *(v26 + 20)) % 4096);
        v14 = *(v23 + 4);
      }
      else
      {
        v14 = 99999;
      }
      while ( sub_80803C6(&s) )
      {
        v21 = sub_8080344(&s, 6);
        if ( v13 > n )
          sub_80704AC(1, &byte_80E6700, v7);
        while ( v14 < v21 )
        {
          if ( ++v15 < *(v26 + 16) )
          {
            v23 = dword_84F7050 + 17764 * ((v15 + *(v26 + 20)) % 4096);
            v14 = *(v23 + 4);
          }
          else
          {
            v14 = 99999;
          }
        }
        if ( v14 == v21 )
        {
          v24 = dword_84F7050 + 17764 * (dword_84F7044 % 4096);
          sub_80824E0(&s, (v23 + 4), (v24 + 4), v21);
          v2 = v24;
          *v2 = sub_80803C6(&s);
          if ( *v24 )
            sub_80830ED(&s, (v23 + 96), (v24 + 96));
          if ( ++dword_84F7044 > 2147483645 )
            sub_80704AC(0, &byte_80E6740, v7);
          ++v27[4];
          if ( ++v15 < *(v26 + 16) )
          {
            v23 = dword_84F7050 + 17764 * ((v15 + *(v26 + 20)) % 4096);
            v14 = *(v23 + 4);
          }
          else
          {
            v14 = 99999;
          }
        }
        else
        {
          v24 = dword_84F7050 + 17764 * (dword_84F7044 % 4096);
          sub_80824E0(&s, 0, (v24 + 4), v21);
          v3 = v24;
          *v3 = sub_80803C6(&s);
          if ( *v24 )
            sub_80830ED(&s, 0, (v24 + 96));
          if ( ++dword_84F7044 > 2147483645 )
            sub_80704AC(0, &byte_80E6740, v7);
          ++v27[4];
        }
      }
      while ( 1 )
      {
        v21 = sub_8080344(&s, 10);
        if ( v21 == 1023 )
          break;
        if ( v13 > n )
          sub_80704AC(1, &byte_80E6700, v7);
        v25 = dword_84F704C + 276 * (dword_84F7040 % 0x4000);
        sub_808249A(&s, (384 * v21 + 139030176), v25, v21);
        if ( ++dword_84F7040 > 2147483645 )
          sub_80704AC(0, &byte_80E6780, v7);
        ++v27[2];
      }
      if ( ++dword_84F7048 > 2147483645 )
        sub_80704AC(0, &byte_80E67C0, v7);
    }
    return v27;
  }
  return 0;
}
// 80976AD: variable 'v7' is possibly undefined
// 84F7030: using guessed type int dword_84F7030;
// 84F703C: using guessed type int dword_84F703C;
// 84F7040: using guessed type int dword_84F7040;
// 84F7044: using guessed type int dword_84F7044;
// 84F7048: using guessed type int dword_84F7048;

//----- (08097D7D) --------------------------------------------------------
_DWORD *__cdecl sub_8097D7D(int *a1)
{
  int v1; // edx
  _DWORD *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( !dword_84F702C )
    return 0;
  if ( *a1 <= 0 )
    return 0;
  v1 = *(dword_8494A34 + 32) * *a1 / 1000;
  v5 = dword_84F7030 - v1;
  if ( dword_84F7030 - v1 < dword_84F7030 - 1200 )
  {
    v5 = dword_84F7030 - 1200;
    *a1 = 1000 * (dword_84F7030 - (dword_84F7030 - 1200)) / *(dword_8494A34 + 32);
  }
  if ( v5 < 0 )
  {
    v5 = 0;
    *a1 = 1000 * dword_84F7030 / *(dword_8494A34 + 32);
  }
  while ( v5 < dword_84F7030 )
  {
    v4 = sub_809729F(v5);
    if ( v4 )
      return v4;
    ++v5;
  }
  *a1 = 0;
  return 0;
}
// 8494A34: using guessed type int dword_8494A34;
// 84F702C: using guessed type int dword_84F702C;
// 84F7030: using guessed type int dword_84F7030;

//----- (08097E9D) --------------------------------------------------------
#error "8097EC1: call analysis failed (funcsize=13)"

//----- (08097EC8) --------------------------------------------------------
int __cdecl sub_8097EC8(int a1, int a2, void *a3)
{
  if ( *(svs_clients + 175149 * a1) != 4 )
    return 0;
  if ( !sub_8097E9D(a1, a2) )
    return 0;
  qmemcpy(a3, sub_8097250(a1), 0x5Cu);
  return 1;
}
// 8097250: using guessed type _DWORD __cdecl sub_8097250(_DWORD);
// 8097E9D: using guessed type _DWORD __cdecl sub_8097E9D(_DWORD, _DWORD);

//----- (08097F44) --------------------------------------------------------
int __cdecl sub_8097F44(int a1, int *a2, int a3, void *a4)
{
  unsigned int v5; // [esp+10h] [ebp-38h]
  _DWORD *v6; // [esp+14h] [ebp-34h]
  void *v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  _DWORD *v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  unsigned int j; // [esp+34h] [ebp-14h]
  _DWORD *v14; // [esp+38h] [ebp-10h]

  v14 = sub_8097D7D(a2);
  if ( v14 )
  {
    v11 = dword_84F7004 - v14[1];
    for ( i = 0; ; ++i )
    {
      if ( i >= v14[4] )
        return 0;
      v10 = dword_84F7050 + 17764 * ((i + v14[5]) % 4096);
      if ( v10[1] == a1 )
        break;
    }
    if ( !*v10 )
      return 0;
    v7 = a3;
    v6 = v10 + 24;
    v5 = 17668;
    if ( (a3 & 4) != 0 )
    {
      *a3 = *v6;
      v7 = (a3 + 4);
      v6 = v10 + 25;
      v5 = 17664;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
    qmemcpy(a4, v10 + 1, 0x5Cu);
    if ( *a3 )
      *a3 += v11;
    if ( *(a3 + 16) )
      *(a3 + 16) += v11;
    if ( *(a3 + 56) )
      *(a3 + 56) += v11;
    if ( *(a3 + 60) )
      *(a3 + 60) += v11;
    if ( *(a3 + 104) )
      *(a3 + 104) += v11;
    if ( *(a3 + 252) )
      *(a3 + 252) += v11;
    if ( *(a3 + 1584) )
      *(a3 + 1584) += v11;
    for ( j = 0; j <= 0x3E; ++j )
    {
      if ( *(a3 + 124 * j + 9944) )
        *(a3 + 124 * j + 9944) += v11;
      if ( *(a3 + 124 * j + 9888) )
        *(a3 + 124 * j + 9888) += v11;
      if ( *(a3 + 124 * j + 9920) )
        *(a3 + 124 * j + 9920) += v11;
      if ( *(a3 + 124 * j + 9936) )
        *(a3 + 124 * j + 9936) += v11;
    }
    *(a3 + 17664) += v11;
    v9 = 1;
  }
  else
  {
    if ( *a2 > 0 )
      v8 = 0;
    else
      v8 = sub_8097EC8(a1, a3, a4);
    v9 = v8;
  }
  return v9;
}
// 84F7004: using guessed type int dword_84F7004;

//----- (080982CF) --------------------------------------------------------
int __cdecl sub_80982CF(char *a1)
{
  int result; // eax
  char v2; // [esp+8h] [ebp-10C0h]
  char v3; // [esp+8h] [ebp-10C0h]
  char v4; // [esp+8h] [ebp-10C0h]
  int v5; // [esp+30h] [ebp-1098h]
  unsigned int v6; // [esp+3Ch] [ebp-108Ch]
  _DWORD *v7; // [esp+40h] [ebp-1088h]
  int v8; // [esp+44h] [ebp-1084h]
  int v9; // [esp+48h] [ebp-1080h]
  int v10; // [esp+4Ch] [ebp-107Ch] BYREF
  int v11; // [esp+50h] [ebp-1078h]
  int v12; // [esp+54h] [ebp-1074h]
  char *v13; // [esp+58h] [ebp-1070h]
  _DWORD *v14; // [esp+5Ch] [ebp-106Ch]
  float *v15; // [esp+60h] [ebp-1068h]
  int v16; // [esp+64h] [ebp-1064h]
  int v17; // [esp+68h] [ebp-1060h]
  int v18; // [esp+6Ch] [ebp-105Ch]
  void *v19; // [esp+70h] [ebp-1058h]
  void *v20; // [esp+74h] [ebp-1054h]
  const void *v21; // [esp+78h] [ebp-1050h]
  int i; // [esp+7Ch] [ebp-104Ch]
  char v23[4]; // [esp+80h] [ebp-1048h] BYREF
  int v24[1030]; // [esp+84h] [ebp-1044h]
  char *v25; // [esp+109Ch] [ebp-2Ch]
  char v26[4]; // [esp+10A0h] [ebp-28h] BYREF
  int v27; // [esp+10A4h] [ebp-24h]
  float v28; // [esp+10A8h] [ebp-20h]
  int *j; // [esp+10D0h] [ebp+8h]

  v25 = &a1[17696 * (*(a1 + 158745) & 0x1F) + 68656];
  *(v25 + 4417) = 0;
  *(v25 + 4418) = 0;
  result = *(a1 + 17040);
  v17 = result;
  if ( result )
  {
    result = a1;
    if ( *a1 != 1 )
    {
      *(v25 + 4419) = dword_84F701C;
      result = dword_84F7020;
      *(v25 + 4420) = dword_84F7020;
      if ( dword_8494A80 == 2 )
      {
        *v23 = 0;
        v16 = -1067678811 * ((a1 - svs_clients) >> 2);
        v10 = sub_8096F2B(v16);
        v14 = sub_8097D7D(&v10);
        sub_8097274(v16, v10);
        if ( v14 )
          v9 = dword_84F7004 - v14[1];
        else
          v9 = 0;
        v12 = v9;
        v15 = v25;
        v8 = v25;
        v7 = sub_808E105(v16);
        v6 = 17668;
        if ( (v8 & 4) != 0 )
        {
          *v8 = *v7;
          v8 += 4;
          ++v7;
          v6 = 17664;
        }
        qmemcpy(v8, v7, 4 * (v6 >> 2));
        v16 = *(v15 + 53);
        if ( v16 < 0 || v16 > 1023 )
          sub_80704AC(1, &byte_80E6800, v2);
        v18 = 384 * v16 + 139030168;
        *v26 = v15[5];
        v27 = *(v15 + 6);
        v28 = v15[7];
        v28 = v28 + v15[62];
        sub_8087A07(v26, *(v15 + 59), v15[17], 16.0, 20.0);
        if ( v14 )
        {
          sub_8096F4F(v14[2], v14[3], v26, v16, v23, v15);
          for ( i = 0; i < *v23; ++i )
          {
            v13 = dword_84F704C + 276 * ((v24[i] + v14[3]) % 0x4000);
            v20 = (dword_84F7024 + 244 * (dword_84F701C % dword_84F7014));
            qmemcpy(v20, v13, 0xF4u);
            if ( *(v20 + 4) )
              *(v20 + 4) += v12;
            if ( *(v20 + 13) )
              *(v20 + 13) += v12;
            if ( *(v20 + 21) )
              *(v20 + 21) += v12;
            if ( *(v20 + 22) )
              *(v20 + 22) += v12;
            if ( ++dword_84F701C > 2147483645 )
              sub_80704AC(0, &byte_80E6840, v4);
            ++*(v25 + 4417);
          }
          for ( i = 0; ; ++i )
          {
            result = i;
            if ( i >= v14[4] )
              break;
            v5 = i + v14[5];
            v11 = dword_84F7050 + 17764 * (v5 % 4096);
            v19 = (dword_84F7028 + 92 * (dword_84F7020 % dword_84F7018));
            qmemcpy(v19, (v11 + 4), 0x5Cu);
            if ( ++dword_84F7020 > 2147483645 )
              sub_80704AC(0, &byte_80E6880, v4);
            ++*(v25 + 4418);
          }
        }
        else
        {
          sub_8096B97(v26, v16, v23);
          for ( i = 0; i < *v23; ++i )
          {
            v21 = SV_GentityNum(v24[i]);
            v20 = (dword_84F7024 + 244 * (dword_84F701C % dword_84F7014));
            qmemcpy(v20, v21, 0xF4u);
            if ( ++dword_84F701C > 2147483645 )
              sub_80704AC(0, &byte_80E6840, v3);
            ++*(v25 + 4417);
          }
          i = 0;
          for ( j = svs_clients; ; j += 175149 )
          {
            result = i;
            if ( i >= *(dword_8494A64 + 32) )
              break;
            if ( *j > 1 )
            {
              v19 = (dword_84F7028 + 92 * (dword_84F7020 % dword_84F7018));
              qmemcpy(v19, sub_8097250(i), 0x5Cu);
              if ( ++dword_84F7020 > 2147483645 )
                sub_80704AC(0, &byte_80E6880, v3);
              ++*(v25 + 4418);
            }
            ++i;
          }
        }
      }
    }
  }
  return result;
}
// 80984B4: variable 'v2' is possibly undefined
// 8098603: variable 'v3' is possibly undefined
// 8098886: variable 'v4' is possibly undefined
// 8096F2B: using guessed type _DWORD __cdecl sub_8096F2B(_DWORD);
// 8097250: using guessed type _DWORD __cdecl sub_8097250(_DWORD);
// 8097274: using guessed type _DWORD __cdecl sub_8097274(_DWORD, _DWORD);
// 8494A64: using guessed type int dword_8494A64;
// 8494A80: using guessed type int dword_8494A80;
// 84F7004: using guessed type int dword_84F7004;
// 84F7014: using guessed type int dword_84F7014;
// 84F7018: using guessed type int dword_84F7018;
// 84F701C: using guessed type int dword_84F701C;
// 84F7020: using guessed type int dword_84F7020;
// 84F7024: using guessed type int dword_84F7024;
// 84F7028: using guessed type int dword_84F7028;

//----- (0809899F) --------------------------------------------------------
int __cdecl sub_809899F(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( a2 > 1500 )
    a2 = 1500;
  v3 = *(a1 + 634932);
  if ( *(dword_84F6FAC + 32) )
  {
    if ( *(dword_84F6FAC + 32) <= 999 )
      sub_8073798("sv_MaxRate", "1000");
    if ( *(dword_84F6FAC + 32) < v3 )
      v3 = *(dword_84F6FAC + 32);
  }
  return (1000 * a2 + 48000) / v3;
}
// 84F6FAC: using guessed type int dword_84F6FAC;

//----- (08098A23) --------------------------------------------------------
size_t __cdecl SV_SendMessageToClient(int a1, int client)
{
  size_t result; // eax
  char dest[4]; // [esp+20h] [ebp-8018h] BYREF
  int v4; // [esp+24h] [ebp-8014h] BYREF
  size_t n; // [esp+8028h] [ebp-10h]
  int v6; // [esp+802Ch] [ebp-Ch]

  memcpy(dest, *(a1 + 4), sizeof(dest));
  n = sub_808041F((*(a1 + 4) + 4), &v4, *(a1 + 12) - 4) + 4;
  if ( *(client + 8) )
    SV_DropClient(client, *(client + 8));
  *(client + 17696 * (*(client + 634980) & 0x1F) + 86348) = n;
  *(client + 17696 * (*(client + 634980) & 0x1F) + 86340) = svs_time;
  *(client + 17696 * (*(client + 634980) & 0x1F) + 86344) = -1;
  sub_809584B(client, dest, n);
  if ( *(client + 634952) == 2 || sub_80CA1BC(*(client + 634952), *(client + 634956)) )
  {
    result = svs_time - 1;
    *(client + 68644) = svs_time - 1;
  }
  else
  {
    v6 = sub_809899F(client, n);
    if ( v6 >= *(client + 634936) )
    {
      *(client + 68648) = 1;
    }
    else
    {
      v6 = *(client + 634936);
      *(client + 68648) = 0;
    }
    *(client + 68644) = svs_time + v6;
    if ( *client != 4 && !*(client + 68196) && *(client + 68644) < svs_time + 1000 )
      *(client + 68644) = svs_time + 1000;
    result = n;
    dword_84F6F04 += n;
  }
  return result;
}
// 84F6F04: using guessed type int dword_84F6F04;
// 84F7008: using guessed type int svs_time;

//----- (08098C23) --------------------------------------------------------
size_t __cdecl SV_SendClientSnapshot(_DWORD *a1)
{
  int v2[8192]; // [esp+20h] [ebp-8028h] BYREF
  int s[10]; // [esp+8020h] [ebp-28h] BYREF

  if ( *a1 == 4 || *a1 == 1 )
    sub_80982CF(a1);
  MSG_Init(s, v2, 0x8000);
  MSG_WriteLong(s, a1[16783]);
  if ( *a1 == 4 || *a1 == 1 )
  {
    SV_UpdateServerCommandsToClient(a1, s);
    SV_WriteSnapshotToClient(a1, s);
  }
  if ( *a1 != 1 )
    SV_WriteDownloadToClient(a1, s);
  MSG_WriteByte(s, 8);
  if ( s[0] )
  {
    Com_Printf("WARNING: msg overflowed for %s, trying to recover\n", a1 + 68);
    if ( *a1 == 4 || *a1 == 1 )
    {
      sub_8096A94(a1);
      MSG_Init(s, v2, 0x8000);
      MSG_WriteLong(s, a1[16783]);
      sub_80969C1(a1, s, 0x8000);
      MSG_WriteByte(s, 8);
    }
    if ( s[0] )
    {
      Com_Printf("WARNING: client disconnected for msg overflow: %s\n", a1 + 68);
      sub_8084D76(1, a1[158738], a1[158739], a1[158740], a1[158741], a1[158742], "disconnect");
      SV_DropClient(a1, "EXE_SERVERMESSAGEOVERFLOW");
    }
  }
  return SV_SendMessageToClient(s, a1);
}

//----- (08098E10) --------------------------------------------------------
void sub_8098E10()
{
  int *v0; // eax
  int *v1; // eax
  _DWORD *v2; // ebx
  int v3[32768]; // [esp+40h] [ebp-246C8h] BYREF
  int s; // [esp+20040h] [ebp-46C8h] BYREF
  void *src; // [esp+20044h] [ebp-46C4h]
  size_t n; // [esp+2004Ch] [ebp-46BCh]
  int v7; // [esp+20068h] [ebp-46A0h]
  int v8; // [esp+2006Ch] [ebp-469Ch]
  int v9; // [esp+20070h] [ebp-4698h]
  int v10; // [esp+20074h] [ebp-4694h]
  int v11; // [esp+20078h] [ebp-4690h]
  char v12[4]; // [esp+2007Ch] [ebp-468Ch]
  int v13; // [esp+20080h] [ebp-4688h]
  int v14; // [esp+20084h] [ebp-4684h]
  int v15; // [esp+20088h] [ebp-4680h]
  int *v16; // [esp+2008Ch] [ebp-467Ch]
  _DWORD v17[4422]; // [esp+20090h] [ebp-4678h] BYREF
  size_t v18; // [esp+245A8h] [ebp-160h]
  int v19; // [esp+245ACh] [ebp-15Ch]
  _DWORD *v20; // [esp+245B0h] [ebp-158h]
  int *v21; // [esp+245B4h] [ebp-154h]
  int i; // [esp+245B8h] [ebp-150h]
  int v23; // [esp+245BCh] [ebp-14Ch]
  int v24[61]; // [esp+245C0h] [ebp-148h] BYREF
  int v25; // [esp+246B4h] [ebp-54h]
  int v26; // [esp+246B8h] [ebp-50h]
  int v27; // [esp+246BCh] [ebp-4Ch]
  int v28; // [esp+246C0h] [ebp-48h]
  int v29; // [esp+246C4h] [ebp-44h]
  int v30; // [esp+246C8h] [ebp-40h]
  int v31; // [esp+246CCh] [ebp-3Ch]
  int v32; // [esp+246D0h] [ebp-38h]
  int *v33; // [esp+246E8h] [ebp-20h]
  int j; // [esp+246ECh] [ebp-1Ch]

  if ( dword_8494A80 == 2 && dword_84F702C )
  {
    MSG_Init(&s, v3, 0x20000);
    v15 = dword_84F7048 - 512;
    if ( dword_84F7048 - 512 < 0 )
      v15 = 0;
    v14 = dword_84F7030 - *(dword_8494A34 + 32);
    for ( i = dword_84F7048 - 1; i >= v15; --i )
    {
      v16 = (dword_84F7054 + 28 * (i % 512));
      if ( *v16 >= v14 && !v16[6] )
      {
        if ( v16[3] >= dword_84F7040 - 0x4000 && v16[5] >= dword_84F7044 - 4096 )
        {
          sub_808024E(&s);
          MSG_WriteLong(&s, *v16);
          MSG_WriteLong(&s, dword_84F7004);
          v11 = *(dword_8494A64 + 32);
          v10 = v16[4];
          v13 = 0;
          v9 = 0;
          v8 = 0;
          while ( v9 < v11 || v8 < v10 )
          {
            if ( v9 >= v11 || *(svs_clients + 175149 * v9) > 1 )
            {
              if ( v8 < v10 )
              {
                v13 = dword_84F7050 + 17764 * ((v8 + v16[5]) % 4096);
                v7 = *(v13 + 4);
              }
              else
              {
                v7 = 9999;
              }
              if ( v9 == v7 )
              {
                v0 = sub_8097250(v9);
                sub_8081EF2(&s, (v13 + 4), v0, 1);
                if ( sub_8097E9D(v9, v17) )
                {
                  sub_80802AB(&s);
                  sub_8082826(&s, (v13 + 96), v17);
                }
                else
                {
                  sub_808024E(&s);
                }
                ++v8;
                ++v9;
              }
              else if ( v9 >= v7 )
              {
                if ( v9 > v7 )
                  ++v8;
              }
              else
              {
                v1 = sub_8097250(v9);
                sub_8081EF2(&s, 0, v1, 1);
                if ( sub_8097E9D(v9, v17) )
                {
                  sub_80802AB(&s);
                  sub_8082826(&s, 0, v17);
                }
                else
                {
                  sub_808024E(&s);
                }
                ++v9;
              }
            }
            else
            {
              ++v9;
            }
          }
          sub_808024E(&s);
          for ( j = 0; j < dword_84F6EA4; ++j )
          {
            v33 = SV_GentityNum(j);
            if ( v33[61] )
            {
              if ( (v33[62] & 1) == 0 )
              {
                v23 = sub_808E122(v33);
                if ( (v33[62] & 0x18) != 0 || *(v23 + 284) || v33[64] )
                {
                  qmemcpy(v24, v33, sizeof(v24));
                  v25 = v33[62];
                  if ( v33[64] )
                    v25 |= 8u;
                  v26 = v33[63];
                  v27 = v33[73];
                  v28 = v33[74];
                  v29 = v33[75];
                  v30 = v33[76];
                  v31 = v33[77];
                  v32 = v33[78];
                  sub_8081E9C(&s, (384 * *v33 + 139030176), v24, 1);
                }
              }
            }
          }
          goto LABEL_69;
        }
        break;
      }
    }
    sub_80802AB(&s);
    MSG_WriteLong(&s, dword_84F7004);
    v16 = (dword_84F7054 + 28 * (dword_84F7048 % 512));
    *v16 = dword_84F7030;
    v16[2] = 0;
    v16[3] = dword_84F7040;
    v16[4] = 0;
    v16[5] = dword_84F7044;
    v16[6] = 0;
    v16[1] = dword_84F7004;
    i = 0;
    v21 = svs_clients;
    while ( i < *(dword_8494A64 + 32) )
    {
      if ( *v21 > 1 )
      {
        v13 = dword_84F7050 + 17764 * (dword_84F7044 % 4096);
        qmemcpy((v13 + 4), sub_8097250(i), 0x5Cu);
        sub_8081EF2(&s, 0, (v13 + 4), 1);
        v2 = v13;
        *v2 = sub_8097E9D(i, v13 + 96);
        if ( *v13 )
        {
          sub_80802AB(&s);
          sub_8082826(&s, 0, (v13 + 96));
        }
        else
        {
          sub_808024E(&s);
        }
        if ( ++dword_84F7044 > 2147483645 )
          sub_80704AC(0, &byte_80E6740);
        ++v16[4];
      }
      ++i;
      v21 += 175149;
    }
    sub_808024E(&s);
    for ( j = 0; j < dword_84F6EA4; ++j )
    {
      v33 = SV_GentityNum(j);
      if ( v33[61] )
      {
        if ( (v33[62] & 1) == 0 )
        {
          v23 = sub_808E122(v33);
          if ( (v33[62] & 0x18) != 0 || *(v23 + 284) || v33[64] )
          {
            *v12 = dword_84F704C + 276 * (dword_84F7040 % 0x4000);
            qmemcpy(*v12, v33, 0xF4u);
            *(*v12 + 244) = v33[62];
            if ( v33[64] )
              *(*v12 + 244) |= 8u;
            *(*v12 + 248) = v33[63];
            *(*v12 + 252) = v33[73];
            *(*v12 + 256) = v33[74];
            *(*v12 + 260) = v33[75];
            *(*v12 + 264) = v33[76];
            *(*v12 + 268) = v33[77];
            *(*v12 + 272) = v33[78];
            sub_8081E9C(&s, (384 * *v33 + 139030176), *v12, 1);
            if ( ++dword_84F7040 > 2147483645 )
              sub_80704AC(0, &byte_80E6780);
            ++v16[2];
          }
        }
      }
    }
    if ( ++dword_84F7048 > 2147483645 )
      sub_80704AC(0, &byte_80E67C0);
LABEL_69:
    sub_8080188(&s, 1023, 10);
    v20 = dword_84F7034 + 8 * (dword_84F7030 % 1200);
    *v20 = dword_84F703C;
    v20[1] = n;
    v19 = dword_84F703C % 0x2000000;
    dword_84F703C += n;
    if ( dword_84F703C > 2147483645 )
      sub_80704AC(0, &byte_80E6960);
    v18 = 0x2000000 - v19;
    if ( n > 0x2000000 - v19 )
    {
      memcpy(dword_84F7038 + v19, src, v18);
      memcpy(dword_84F7038, src + v18, n - v18);
    }
    else
    {
      memcpy(dword_84F7038 + v19, src, n);
    }
    if ( ++dword_84F7030 > 2147483645 )
      sub_80704AC(0, &byte_80E69A0);
  }
}
// 8097250: using guessed type _DWORD __cdecl sub_8097250(_DWORD);
// 8097E9D: using guessed type _DWORD __cdecl sub_8097E9D(_DWORD, _DWORD);
// 8494A34: using guessed type int dword_8494A34;
// 8494A64: using guessed type int dword_8494A64;
// 8494A80: using guessed type int dword_8494A80;
// 84F6EA4: using guessed type int dword_84F6EA4;
// 84F7004: using guessed type int dword_84F7004;
// 84F702C: using guessed type int dword_84F702C;
// 84F7030: using guessed type int dword_84F7030;
// 84F703C: using guessed type int dword_84F703C;
// 84F7040: using guessed type int dword_84F7040;
// 84F7044: using guessed type int dword_84F7044;
// 84F7048: using guessed type int dword_84F7048;

//----- (08099A2C) --------------------------------------------------------
int sub_8099A2C()
{
  int result; // eax
  float v1; // [esp+3Ch] [ebp-1Ch]
  float v2; // [esp+40h] [ebp-18h]
  float v3; // [esp+40h] [ebp-18h]
  float v4; // [esp+40h] [ebp-18h]
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+44h] [ebp-14h]
  int v8; // [esp+48h] [ebp-10h]
  _DWORD *v9; // [esp+4Ch] [ebp-Ch]
  int v10; // [esp+50h] [ebp-8h]
  int i; // [esp+50h] [ebp-8h]

  v8 = 0;
  dword_84F6F04 = 0;
  dword_84F6F5C = 0;
  v10 = 0;
  v9 = svs_clients;
  while ( v10 < *(dword_8494A64 + 32) )
  {
    if ( *v9 && svs_time >= v9[17161] )
    {
      ++v8;
      if ( v9[166940] )
      {
        v9[17161] = svs_time + sub_809899F(v9, v9[166942] - v9[166941]);
        SV_Netchan_TransmitNextFragment(v9 + 158736);
      }
      else
      {
        SV_SendClientSnapshot(v9);
      }
    }
    ++v10;
    v9 += 175149;
  }
  result = dword_8494A30;
  if ( *(dword_8494A30 + 32) && v8 > 0 )
  {
    v5 = 0.0;
    v2 = 0.0;
    for ( i = 0; i <= 18; ++i )
    {
      dword_84F6EB0[i] = dword_84F6EB4[i];
      v5 = dword_84F6EB0[i] + v5;
      dword_84F6F0C[i] = dword_84F6F10[i];
      v2 = dword_84F6F0C[i] + v2;
    }
    dword_84F6EFC = dword_84F6F04;
    v6 = dword_84F6F04 + v5;
    dword_84F6F58 = dword_84F6F5C;
    v3 = dword_84F6F5C + v2;
    if ( dword_84F6F04 >= dword_84F6F08 )
      dword_84F6F08 = dword_84F6F04;
    result = dword_84F6F5C;
    if ( dword_84F6F5C >= dword_84F6F60 )
    {
      result = dword_84F6F5C;
      dword_84F6F60 = dword_84F6F5C;
    }
    if ( ++dword_84F6F00 > 19 )
    {
      dword_84F6F00 = 0;
      v7 = v6 / 20.0;
      v4 = v3 / 20.0;
      v1 = (1.0 - v7 / v4) * 100.0;
      flt_84F6F64 = flt_84F6F64 + v1;
      result = Com_DPrintf(
                 "bpspc(%2.0f) bps(%2.0f) pk(%i) ubps(%2.0f) upk(%i) cr(%2.2f) acr(%2.2f)\n",
                 (v7 / v8),
                 v7,
                 dword_84F6F08,
                 v4,
                 dword_84F6F60,
                 v1,
                 (flt_84F6F64 / ++dword_84F6F68));
    }
  }
  return result;
}
// 8494A30: using guessed type int dword_8494A30;
// 8494A64: using guessed type int dword_8494A64;
// 84F6EB0: using guessed type int dword_84F6EB0[];
// 84F6EFC: using guessed type int dword_84F6EFC;
// 84F6F00: using guessed type int dword_84F6F00;
// 84F6F04: using guessed type int dword_84F6F04;
// 84F6F08: using guessed type int dword_84F6F08;
// 84F6F0C: using guessed type int dword_84F6F0C[];
// 84F6F58: using guessed type int dword_84F6F58;
// 84F6F5C: using guessed type int dword_84F6F5C;
// 84F6F60: using guessed type int dword_84F6F60;
// 84F6F64: using guessed type float flt_84F6F64;
// 84F6F68: using guessed type int dword_84F6F68;
// 84F7008: using guessed type int svs_time;

//----- (08099CA0) --------------------------------------------------------
int __cdecl sub_8099CA0(int *a1)
{
  if ( a1[65] )
    return sub_804BD20(a1[35]);
  if ( (a1[62] & 0x200) != 0 )
    return sub_804BE53(a1 + 66, a1 + 69, a1[72], 1);
  return sub_804BE53(a1 + 66, a1 + 69, a1[72], 0);
}

//----- (08099D49) --------------------------------------------------------
int __cdecl sub_8099D49(int *a1)
{
  int *v2; // [esp+4h] [ebp-4h]

  v2 = sub_808E122(a1);
  a1[61] = 0;
  return sub_805D9DF(v2);
}

//----- (08099D77) --------------------------------------------------------
void __cdecl sub_8099D77(int a1)
{
  float v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    v2 = sub_809BC1F(*(a1 + 4 * i));
    v1 = v2 - *(a1 + 4 * i);
    if ( v1 * v1 < 0.0000010000001 )
      *(a1 + 4 * i) = v2;
  }
}

//----- (08099DEE) --------------------------------------------------------
int __cdecl sub_8099DEE(_DWORD *a1)
{
  int *v2; // edx
  int i; // [esp+28h] [ebp-260h]
  float v4; // [esp+2Ch] [ebp-25Ch]
  float v5; // [esp+30h] [ebp-258h] BYREF
  float v6; // [esp+34h] [ebp-254h]
  float v7; // [esp+40h] [ebp-248h] BYREF
  float v8; // [esp+44h] [ebp-244h]
  int v9; // [esp+54h] [ebp-234h]
  int *v10; // [esp+58h] [ebp-230h]
  float *v11; // [esp+5Ch] [ebp-22Ch]
  float *v12; // [esp+60h] [ebp-228h]
  int v13; // [esp+64h] [ebp-224h] BYREF
  int v14; // [esp+68h] [ebp-220h]
  int v15; // [esp+6Ch] [ebp-21Ch]
  int v16; // [esp+70h] [ebp-218h]
  int j; // [esp+74h] [ebp-214h]
  int v18; // [esp+78h] [ebp-210h]
  int v19; // [esp+7Ch] [ebp-20Ch]
  int v20[130]; // [esp+80h] [ebp-208h] BYREF

  v10 = sub_808E122(a1);
  if ( a1[65] )
  {
    a1[40] = 0xFFFFFF;
  }
  else if ( (a1[72] & 0x2000001) != 0 )
  {
    j = *(a1 + 69);
    if ( j <= 0 )
      j = 1;
    if ( j > 255 )
      j = 255;
    v16 = (1.0 - *(a1 + 68));
    if ( v16 <= 0 )
      v16 = 1;
    if ( v16 > 255 )
      v16 = 255;
    v15 = (*(a1 + 71) + 32.0);
    if ( v15 <= 0 )
      v15 = 1;
    if ( v15 > 255 )
      v15 = 255;
    a1[40] = j | (v15 << 16) | (v16 << 8);
  }
  else
  {
    a1[40] = 0;
  }
  sub_8099D77((a1 + 82));
  v11 = (a1 + 82);
  v12 = (a1 + 79);
  if ( !a1[65] || *v11 == 0.0 && v11[1] == 0.0 && v11[2] == 0.0 )
  {
    *(a1 + 73) = *v12 + *(a1 + 66);
    *(a1 + 74) = v12[1] + *(a1 + 67);
    *(a1 + 75) = v12[2] + *(a1 + 68);
    *(a1 + 76) = *v12 + *(a1 + 69);
    *(a1 + 77) = v12[1] + *(a1 + 70);
    *(a1 + 78) = v12[2] + *(a1 + 71);
  }
  else
  {
    v4 = sub_806A0C3((a1 + 66), (a1 + 69));
    for ( i = 0; i <= 2; ++i )
    {
      *&a1[i + 73] = v12[i] - v4;
      *&a1[i + 76] = v12[i] + v4;
    }
  }
  *(a1 + 73) = *(a1 + 73) - 1.0;
  *(a1 + 74) = *(a1 + 74) - 1.0;
  *(a1 + 75) = *(a1 + 75) - 1.0;
  *(a1 + 76) = *(a1 + 76) + 1.0;
  *(a1 + 77) = *(a1 + 77) + 1.0;
  *(a1 + 78) = *(a1 + 78) + 1.0;
  v10[71] = 0;
  v10[88] = 0;
  v10[89] = -1;
  v10[90] = -1;
  v18 = sub_8057491(a1 + 73, a1 + 76, v20, 128, &v13);
  if ( !v18 )
    return sub_805D9DF(v10);
  for ( j = 0; j < v18; ++j )
  {
    v14 = sub_804BD86(v20[j]);
    if ( v14 != -1 )
    {
      if ( v10[89] == -1 || v10[89] == v14 )
      {
        v10[89] = v14;
      }
      else
      {
        if ( v10[90] != -1 && v10[90] != v14 && dword_8494A80 == 1 )
          Com_DPrintf("Object %i touching 3 areas at %f %f %f\n", *a1, *(a1 + 73), *(a1 + 74), *(a1 + 75));
        v10[90] = v14;
      }
    }
  }
  v10[71] = 0;
  for ( j = 0; j < v18; ++j )
  {
    v19 = sub_804BD70(v20[j]);
    if ( v19 != -1 )
    {
      v2 = v10;
      v10[v10[71] + 72] = v19;
      ++v2[71];
      if ( v10[71] == 16 )
        break;
    }
  }
  if ( j != v18 )
    v10[88] = sub_804BD70(v13);
  a1[61] = 1;
  if ( !a1[72] )
    return sub_805D9DF(v10);
  v9 = sub_80725CB(*a1);
  if ( !v9 || (a1[62] & 6) == 0 )
    return sub_805DE1A(v10, a1 + 73, a1 + 76);
  if ( (a1[62] & 2) != 0 )
  {
    v7 = *v12 + flt_80F5110;
    v8 = v12[1] + flt_80F5114;
    v5 = *v12 + flt_80F511C;
    v6 = v12[1] + flt_80F5120;
  }
  else
  {
    sub_80C6B36(v9, &v7, &v5);
    v7 = v7 + *v12;
    v8 = v8 + v12[1];
    v5 = v5 + *v12;
    v6 = v6 + v12[1];
  }
  return sub_805DE1A(v10, &v7, &v5);
}
// 80F5110: using guessed type float flt_80F5110;
// 80F5114: using guessed type float flt_80F5114;
// 80F511C: using guessed type float flt_80F511C;
// 80F5120: using guessed type float flt_80F5120;
// 8494A80: using guessed type int dword_8494A80;

//----- (0809A594) --------------------------------------------------------
int __cdecl sub_809A594(int a1, int a2)
{
  int result; // eax
  int *v3; // [esp+38h] [ebp-50h]
  int v4; // [esp+3Ch] [ebp-4Ch]
  int v5[15]; // [esp+40h] [ebp-48h] BYREF
  int *v6; // [esp+7Ch] [ebp-Ch]

  v6 = SV_GentityNum(-1431655765 * ((a2 + -&dword_8494A80 - 9240) >> 7));
  result = *(a1 + 116) & v6[72];
  if ( result )
  {
    if ( *(a1 + 108) == 1023
      || (result = -1431655765 * ((a2 + -&dword_8494A80 - 9240) >> 7), result != *(a1 + 108))
      && (result = v6[85], result != *(a1 + 108))
      && (result = v6[85], result != *(a1 + 112)) )
    {
      v4 = sub_8099CA0(v6);
      v3 = v6 + 82;
      if ( !v6[65] )
        v3 = &dword_80DD708;
      v5[0] = *(a1 + 60);
      sub_805B19A(v5, (a1 + 36), (a1 + 48), a1, (a1 + 12), v4, *(a1 + 116), v6 + 79, v3, *(a1 + 120));
      if ( *v5 < *(a1 + 60) )
      {
        HIWORD(v5[11]) |= *(a1 + 106);
        LOWORD(v5[10]) = *v6;
        result = 12;
        qmemcpy((a1 + 60), v5, 0x30u);
      }
      else
      {
        *(a1 + 106) |= BYTE2(v5[11]);
        result = HIBYTE(v5[11]);
        LOBYTE(result) = *(a1 + 107) | HIBYTE(v5[11]);
        *(a1 + 107) = result;
      }
    }
  }
  return result;
}
// 80DD708: using guessed type int dword_80DD708;
// 8494A80: using guessed type int dword_8494A80;

//----- (0809A72A) --------------------------------------------------------
int __cdecl sub_809A72A(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-10Ch]
  int v4; // [esp+10h] [ebp-108h]
  int v5; // [esp+14h] [ebp-104h]
  int v6; // [esp+18h] [ebp-100h]
  int v7; // [esp+1Ch] [ebp-FCh]
  int v8; // [esp+20h] [ebp-F8h]
  int v9; // [esp+24h] [ebp-F4h]
  int v10; // [esp+28h] [ebp-F0h]
  int v11; // [esp+2Ch] [ebp-ECh]
  float v12[9]; // [esp+30h] [ebp-E8h] BYREF
  float v13; // [esp+54h] [ebp-C4h]
  float v14; // [esp+58h] [ebp-C0h]
  float v15; // [esp+5Ch] [ebp-BCh]
  float v16[4]; // [esp+60h] [ebp-B8h] BYREF
  float v17[4]; // [esp+70h] [ebp-A8h] BYREF
  int v18[2]; // [esp+80h] [ebp-98h] BYREF
  float v19[4]; // [esp+88h] [ebp-90h] BYREF
  unsigned __int8 v20; // [esp+98h] [ebp-80h]
  char v21; // [esp+99h] [ebp-7Fh]
  float v22; // [esp+A0h] [ebp-78h] BYREF
  float v23; // [esp+A4h] [ebp-74h]
  float v24; // [esp+A8h] [ebp-70h]
  float v25; // [esp+B0h] [ebp-68h] BYREF
  float v26; // [esp+B4h] [ebp-64h]
  float v27; // [esp+B8h] [ebp-60h]
  int v28; // [esp+C0h] [ebp-58h]
  int v29; // [esp+C4h] [ebp-54h]
  float *v30; // [esp+C8h] [ebp-50h]
  int v31; // [esp+CCh] [ebp-4Ch]
  int v32[15]; // [esp+D0h] [ebp-48h] BYREF
  int *v33; // [esp+10Ch] [ebp-Ch]

  v29 = -1431655765 * ((a2 + -&dword_8494A80 - 9240) >> 7);
  v33 = SV_GentityNum(v29);
  result = *(a1 + 80) & v33[72];
  if ( result )
  {
    if ( *(a1 + 72) == 1023
      || (result = v29, v29 != *(a1 + 72))
      && (result = v33[85], result != *(a1 + 72))
      && (result = v33[85], result != *(a1 + 76)) )
    {
      if ( !*(a1 + 84) || (v28 = sub_80725CB(*v33)) == 0 || (v33[62] & 6) == 0 )
      {
        v31 = sub_8099CA0(v33);
        v30 = (v33 + 82);
        if ( !v33[65] )
          v30 = &dword_80DD708;
        v32[0] = *(a1 + 24);
        sub_805B19A(v32, a1, (a1 + 12), &dword_80DD708, &dword_80DD708, v31, *(a1 + 80), v33 + 79, v30, 0);
        if ( *v32 >= *(a1 + 24) )
        {
          *(a1 + 70) |= BYTE2(v32[11]);
          result = HIBYTE(v32[11]);
          LOBYTE(result) = *(a1 + 71) | HIBYTE(v32[11]);
          *(a1 + 71) = result;
          return result;
        }
        goto LABEL_24;
      }
      if ( (v33[62] & 4) != 0 )
      {
        result = sub_80C7D32(v28, *(a1 + 80));
        if ( !result )
          return result;
        v13 = *(v33 + 79);
        v14 = *(v33 + 80);
        v15 = *(v33 + 81);
        sub_80C6B36(v28, &v25, &v22);
        v25 = v25 + v13;
        v26 = v26 + v14;
        v27 = v27 + v15;
        v22 = v22 + v13;
        v23 = v23 + v14;
        v24 = v24 + v15;
      }
      else
      {
        v13 = *(v33 + 79);
        v14 = *(v33 + 80);
        v15 = *(v33 + 81);
        v25 = v13 + flt_80F5110;
        v26 = v14 + flt_80F5114;
        v27 = v15 + flt_80F5118;
        v22 = v13 + flt_80F511C;
        v23 = v14 + flt_80F5120;
        v24 = v15 + flt_80F5124;
      }
      result = sub_805E387(a1, a1 + 12, &v25, &v22, *(a1 + 24));
      if ( !result )
      {
        VM_Call(gvm, 15, *v33, v3, v4, v5, v6, v7, v8, v9, v10, v11, SLODWORD(v12[0]), SLODWORD(v12[1]));
        sub_806A46E(v33 + 82, v12);
        sub_8069416(a1, v12, v17);
        sub_8069416((a1 + 12), v12, v16);
        v18[0] = *(a1 + 24);
        if ( (v33[62] & 4) != 0 )
          sub_80C7BE8(v28, v17, v16, *(a1 + 80), v18);
        else
          sub_80C7394(v28, v17, v16, *(a1 + 88), v18);
        if ( *v18 >= *(a1 + 24) )
        {
          *(a1 + 70) |= v21;
          result = v20;
          LOBYTE(result) = *(a1 + 71) | v20;
          *(a1 + 71) = result;
          return result;
        }
        v32[0] = v18[0];
        HIBYTE(v32[11]) = v20;
        v32[7] = v18[1];
        *(&v32[10] + 2) = v19[3];
        sub_8069154(v19, v12, &v32[4]);
        *&v32[1] = (*(a1 + 12) - *a1) * *v32 + *a1;
        *&v32[2] = (*(a1 + 16) - *(a1 + 4)) * *v32 + *(a1 + 4);
        *&v32[3] = (*(a1 + 20) - *(a1 + 8)) * *v32 + *(a1 + 8);
LABEL_24:
        HIWORD(v32[11]) |= *(a1 + 70);
        LOWORD(v32[10]) = *v33;
        v32[9] = 0;
        v32[8] = v33[72];
        result = 12;
        qmemcpy((a1 + 24), v32, 0x30u);
        return result;
      }
    }
  }
  return result;
}
// 809A994: variable 'v3' is possibly undefined
// 809A994: variable 'v4' is possibly undefined
// 809A994: variable 'v5' is possibly undefined
// 809A994: variable 'v6' is possibly undefined
// 809A994: variable 'v7' is possibly undefined
// 809A994: variable 'v8' is possibly undefined
// 809A994: variable 'v9' is possibly undefined
// 809A994: variable 'v10' is possibly undefined
// 809A994: variable 'v11' is possibly undefined
// 80DD708: using guessed type int dword_80DD708;
// 80F5110: using guessed type float flt_80F5110;
// 80F5114: using guessed type float flt_80F5114;
// 80F5118: using guessed type float flt_80F5118;
// 80F511C: using guessed type float flt_80F511C;
// 80F5120: using guessed type float flt_80F5120;
// 80F5124: using guessed type float flt_80F5124;
// 8494A80: using guessed type int dword_8494A80;

//----- (0809AC6D) --------------------------------------------------------
int __cdecl sub_809AC6D(int *a1, int a2)
{
  int v3; // [esp+30h] [ebp-18h]
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = -1431655765 * ((a2 + -&dword_8494A80 - 9240) >> 7);
  v7 = SV_GentityNum(v4);
  if ( (a1[19] & *(v7 + 288)) == 0 )
    return 0;
  if ( a1[15] != 1023 )
  {
    if ( v4 == a1[15] )
      return 0;
    if ( *(v7 + 340) == a1[15] )
      return 0;
    if ( *(v7 + 340) == a1[17] )
      return 0;
  }
  if ( a1[16] != 1023 )
  {
    if ( v4 == a1[16] )
      return 0;
    if ( *(v7 + 340) == a1[16] )
      return 0;
    if ( *(v7 + 340) == a1[18] )
      return 0;
  }
  v6 = sub_8099CA0(v7);
  v5 = (v7 + 328);
  if ( !*(v7 + 260) )
    v5 = &dword_80DD708;
  if ( sub_805D4AD(0, (a1 + 9), (a1 + 12), a1, a1 + 3, v6, a1[19], (v7 + 316), v5, a1[20]) )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}
// 80DD708: using guessed type int dword_80DD708;
// 8494A80: using guessed type int dword_8494A80;

//----- (0809AE1E) --------------------------------------------------------
int __cdecl sub_809AE1E(_DWORD *a1, int a2)
{
  int v3; // [esp+30h] [ebp-18h]
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = -1431655765 * ((a2 + -&dword_8494A80 - 9240) >> 7);
  v7 = SV_GentityNum(v4);
  if ( (a1[10] & *(v7 + 288)) == 0 )
    return 0;
  if ( a1[6] != 1023 )
  {
    if ( v4 == a1[6] )
      return 0;
    if ( *(v7 + 340) == a1[6] )
      return 0;
    if ( *(v7 + 340) == a1[8] )
      return 0;
  }
  if ( a1[7] != 1023 )
  {
    if ( v4 == a1[7] )
      return 0;
    if ( *(v7 + 340) == a1[7] )
      return 0;
    if ( *(v7 + 340) == a1[9] )
      return 0;
  }
  v6 = sub_8099CA0(v7);
  v5 = (v7 + 328);
  if ( !*(v7 + 260) )
    v5 = &dword_80DD708;
  if ( sub_805D4AD(0, a1, (a1 + 3), &dword_80DD708, &dword_80DD708, v6, a1[10], (v7 + 316), v5, 0) )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}
// 80DD708: using guessed type int dword_80DD708;
// 8494A80: using guessed type int dword_8494A80;

//----- (0809AFC9) --------------------------------------------------------
int __cdecl sub_809AFC9(void *a1, int a2, int *a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int result; // eax
  __int16 v12; // [esp+2Eh] [ebp-12Ah]
  float v13[6]; // [esp+30h] [ebp-128h] BYREF
  float v14; // [esp+48h] [ebp-110h]
  float v15; // [esp+4Ch] [ebp-10Ch]
  float v16; // [esp+50h] [ebp-108h]
  float v17; // [esp+54h] [ebp-104h]
  float v18; // [esp+58h] [ebp-100h]
  float v19; // [esp+5Ch] [ebp-FCh]
  float v20; // [esp+60h] [ebp-F8h]
  float v21; // [esp+64h] [ebp-F4h]
  float v22; // [esp+68h] [ebp-F0h]
  float v23[13]; // [esp+6Ch] [ebp-ECh] BYREF
  int v24; // [esp+A0h] [ebp-B8h]
  int v25; // [esp+A4h] [ebp-B4h]
  int v26; // [esp+A8h] [ebp-B0h]
  int v27[6]; // [esp+B0h] [ebp-A8h] BYREF
  char v28[48]; // [esp+C8h] [ebp-90h] BYREF
  int v29; // [esp+F8h] [ebp-60h]
  int v30; // [esp+FCh] [ebp-5Ch]
  int v31; // [esp+100h] [ebp-58h]
  int v32; // [esp+104h] [ebp-54h]
  int v33; // [esp+108h] [ebp-50h]
  float v34; // [esp+110h] [ebp-48h]
  float v35; // [esp+114h] [ebp-44h]
  float v36; // [esp+118h] [ebp-40h]
  float s[14]; // [esp+120h] [ebp-38h] BYREF

  if ( !a3 )
    a3 = &dword_80DD708;
  if ( !a4 )
    a4 = &dword_80DD708;
  memset(s, 0, 0x30u);
  sub_805B145(s, a2, a5, a3, a4, 0, a7, a8);
  if ( s[0] == 1.0 )
    v12 = 1023;
  else
    v12 = 1022;
  LOWORD(s[10]) = v12;
  if ( s[0] == 0.0 || a11 && (sub_805E7AF(s, a2, a5, a7), s[0] == 0.0) )
  {
    result = 12;
    qmemcpy(a1, s, 0x30u);
  }
  else if ( *a4 - *a3 + *(a4 + 1) - *(a3 + 1) + *(a4 + 2) - *(a3 + 2) == 0.0 )
  {
    qmemcpy(v28, s, sizeof(v28));
    v31 = a7;
    v27[0] = *a2;
    v27[1] = *(a2 + 4);
    v27[2] = *(a2 + 8);
    v27[3] = *a5;
    v27[4] = *(a5 + 4);
    v27[5] = *(a5 + 8);
    v29 = a6;
    v32 = a9;
    v33 = a10;
    if ( a6 == 1023 )
    {
      v30 = -1;
    }
    else
    {
      v30 = *(SV_GentityNum(a6) + 340);
      if ( v30 == 1023 )
        v30 = -1;
    }
    sub_805F2BE(v27);
    result = 12;
    qmemcpy(a1, v28, 0x30u);
  }
  else
  {
    qmemcpy(v23, s, 0x30u);
    v25 = a7;
    LODWORD(v23[12]) = a6;
    v26 = a8;
    if ( a6 == 1023 )
    {
      v24 = -1;
    }
    else
    {
      v24 = *(SV_GentityNum(a6) + 340);
      if ( v24 == 1023 )
        v24 = -1;
    }
    v14 = *a4 - *a3;
    v15 = *(a4 + 1) - *(a3 + 1);
    v16 = *(a4 + 2) - *(a3 + 2);
    v14 = v14 * 0.5;
    v15 = v15 * 0.5;
    v16 = v16 * 0.5;
    v13[3] = v14;
    v13[4] = v15;
    v13[5] = v16;
    v13[0] = v14 * -1.0;
    v13[1] = v15 * -1.0;
    v13[2] = v16 * -1.0;
    v14 = v14 + 1.0;
    v15 = v15 + 1.0;
    v16 = v16 + 1.0;
    v34 = *a4 + *a3;
    v35 = *(a4 + 1) + *(a3 + 1);
    v36 = *(a4 + 2) + *(a3 + 2);
    v34 = v34 * 0.5;
    v35 = v35 * 0.5;
    v36 = v36 * 0.5;
    v17 = *a2 + v34;
    v18 = *(a2 + 4) + v35;
    v19 = *(a2 + 8) + v36;
    v20 = *a5 + v34;
    v21 = *(a5 + 4) + v35;
    v22 = *(a5 + 8) + v36;
    sub_805EC45(v13);
    if ( s[0] > v23[0] )
    {
      v34 = *a5 - *a2;
      v35 = *(a5 + 4) - *(a2 + 4);
      v36 = *(a5 + 8) - *(a2 + 8);
      v23[1] = v34 * v23[0] + *a2;
      v23[2] = v35 * v23[0] + *(a2 + 4);
      v23[3] = v36 * v23[0] + *(a2 + 8);
    }
    result = 12;
    qmemcpy(a1, v23, 0x30u);
  }
  return result;
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0809B4F1) --------------------------------------------------------
int *__cdecl sub_809B4F1(int *a1, int *a2, int *a3, int *a4, int *a5, int a6, int a7, int a8, int a9)
{
  int *result; // eax
  int v10; // edx
  int v11; // edx
  float v12[6]; // [esp+20h] [ebp-A8h] BYREF
  float v13; // [esp+38h] [ebp-90h]
  float v14; // [esp+3Ch] [ebp-8Ch]
  float v15; // [esp+40h] [ebp-88h]
  float v16; // [esp+44h] [ebp-84h]
  float v17; // [esp+48h] [ebp-80h]
  float v18; // [esp+4Ch] [ebp-7Ch]
  float v19; // [esp+50h] [ebp-78h]
  float v20; // [esp+54h] [ebp-74h]
  float v21; // [esp+58h] [ebp-70h]
  int v22; // [esp+5Ch] [ebp-6Ch]
  int v23; // [esp+60h] [ebp-68h]
  int v24; // [esp+64h] [ebp-64h]
  int v25; // [esp+68h] [ebp-60h]
  int v26; // [esp+6Ch] [ebp-5Ch]
  int v27; // [esp+70h] [ebp-58h]
  int v28[8]; // [esp+80h] [ebp-48h] BYREF
  int v29; // [esp+A0h] [ebp-28h]
  int v30; // [esp+A4h] [ebp-24h]
  int v31; // [esp+A8h] [ebp-20h]
  float v32; // [esp+B0h] [ebp-18h]
  float v33; // [esp+B4h] [ebp-14h]
  float v34; // [esp+B8h] [ebp-10h]

  if ( !a3 )
    a3 = &dword_80DD708;
  if ( !a4 )
    a4 = &dword_80DD708;
  *a1 = sub_805D459(*a1, a2, a5, a3, a4, 0, a8, a9);
  result = a1;
  if ( !*a1 )
  {
    if ( *a4 - *a3 + *(a4 + 1) - *(a3 + 1) + *(a4 + 2) - *(a3 + 2) == 0.0 )
    {
      v31 = a8;
      v28[0] = *a2;
      v28[1] = a2[1];
      v28[2] = a2[2];
      v28[3] = *a5;
      v28[4] = a5[1];
      v28[5] = a5[2];
      v28[6] = a6;
      v28[7] = a7;
      if ( a6 == 1023 )
      {
        v29 = -1;
      }
      else
      {
        v29 = *(SV_GentityNum(a6) + 340);
        if ( v29 == 1023 )
          v29 = -1;
      }
      if ( a7 == 1023 )
      {
        v30 = -1;
      }
      else
      {
        v30 = *(SV_GentityNum(a7) + 340);
        if ( v30 == 1023 )
          v30 = -1;
      }
      v10 = sub_805F58C(v28);
      result = a1;
      *a1 = v10;
    }
    else
    {
      v26 = a8;
      v22 = a6;
      v23 = a7;
      v27 = a9;
      if ( a6 == 1023 )
      {
        v24 = -1;
      }
      else
      {
        v24 = *(SV_GentityNum(a6) + 340);
        if ( v24 == 1023 )
          v24 = -1;
      }
      if ( a7 == 1023 )
      {
        v25 = -1;
      }
      else
      {
        v25 = *(SV_GentityNum(a7) + 340);
        if ( v25 == 1023 )
          v25 = -1;
      }
      v13 = *a4 - *a3;
      v14 = *(a4 + 1) - *(a3 + 1);
      v15 = *(a4 + 2) - *(a3 + 2);
      v13 = v13 * 0.5;
      v14 = v14 * 0.5;
      v15 = v15 * 0.5;
      v12[3] = v13;
      v12[4] = v14;
      v12[5] = v15;
      v12[0] = v13 * -1.0;
      v12[1] = v14 * -1.0;
      v12[2] = v15 * -1.0;
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      v15 = v15 + 1.0;
      v32 = *a4 + *a3;
      v33 = *(a4 + 1) + *(a3 + 1);
      v34 = *(a4 + 2) + *(a3 + 2);
      v32 = v32 * 0.5;
      v33 = v33 * 0.5;
      v34 = v34 * 0.5;
      v16 = *a2 + v32;
      v17 = *(a2 + 1) + v33;
      v18 = *(a2 + 2) + v34;
      v19 = *a5 + v32;
      v20 = *(a5 + 1) + v33;
      v21 = *(a5 + 2) + v34;
      v11 = sub_805F042(v12);
      result = a1;
      *a1 = v11;
    }
  }
  return result;
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0809B8C5) --------------------------------------------------------
int __cdecl sub_809B8C5(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+38h] [ebp-50h]
  float v9[4]; // [esp+40h] [ebp-48h]
  float v10[7]; // [esp+50h] [ebp-38h]
  float *v11; // [esp+6Ch] [ebp-1Ch]
  float *v12; // [esp+70h] [ebp-18h]
  int v13; // [esp+74h] [ebp-14h]
  float *v14; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]

  v14 = SV_GentityNum(a5);
  if ( (a6 & v14[72]) == 0 )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(a4 + 4 * i) <= *(a1 + 4 * i) )
    {
      v10[i] = *(a4 + 4 * i) + *&a2[i] - 1.0;
      v9[i] = *(a1 + 4 * i) + *&a3[i] + 1.0;
    }
    else
    {
      v10[i] = *(a1 + 4 * i) + *&a2[i] - 1.0;
      v9[i] = *(a4 + 4 * i) + *&a3[i] + 1.0;
    }
  }
  if ( v14[73] > v9[0] || v14[74] > v9[1] || v14[75] > v9[2] || v10[0] > v14[76] || v10[1] > v14[77] || v10[2] > v14[78] )
    return 0;
  v13 = sub_8099CA0(v14);
  v12 = v14 + 79;
  v11 = v14 + 82;
  if ( !*(v14 + 65) )
    v11 = &dword_80DD708;
  if ( sub_805D4AD(0, a1, a4, a2, a3, v13, a6, v12, v11, a7) )
    v8 = -1;
  else
    v8 = 0;
  return v8;
}
// 80DD708: using guessed type int dword_80DD708;

//----- (0809BB17) --------------------------------------------------------
int __cdecl sub_809BB17(float *a1, int a2, int a3)
{
  int v4; // [esp+2Ch] [ebp-101Ch]
  int v5; // [esp+30h] [ebp-1018h]
  int v6; // [esp+34h] [ebp-1014h]
  int i; // [esp+38h] [ebp-1010h]
  int v8; // [esp+3Ch] [ebp-100Ch]
  int v9[1026]; // [esp+40h] [ebp-1008h] BYREF

  v5 = sub_80575A9(a1, 0);
  v6 = sub_805E344(a1, a1, v9, 1024, a3);
  for ( i = 0; i < v6; ++i )
  {
    if ( v9[i] != a2 )
    {
      v8 = SV_GentityNum(v9[i]);
      v4 = sub_8099CA0(v8);
      v5 |= sub_805772B(a1, v4, (v8 + 316), (v8 + 328));
    }
  }
  return v5 & a3;
}

//----- (0809BC1F) --------------------------------------------------------
int __cdecl sub_809BC1F(float a1)
{
  return (a1 + 0.5);
}

//----- (0809BC50) --------------------------------------------------------
void *sub_809BC50()
{
  return sub_80C837D(&unk_850C120, 0, 0x1B0u);
}

//----- (0809BC74) --------------------------------------------------------
int __cdecl sub_809BC74(char a1)
{
  return (*dword_80F5128)(&a1);
}
// 80F5128: using guessed type int dword_80F5128;

//----- (0809BCDB) --------------------------------------------------------
int __cdecl sub_809BCDB(char *src, int a2)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]

  if ( !src || !*src || !a2 )
    sub_80704AC(0, &byte_80E6AA0);
  sub_806C1F1();
  for ( i = 0; i <= 2; ++i )
  {
    if ( !sub_8086A5A((144 * i + 139510052), src) )
      return &unk_850C120 + 144 * i;
  }
  for ( j = 0; j <= 2 && byte_850C124[144 * j]; ++j )
    ;
  if ( j == 3 )
    sub_80704AC(0, &byte_80E6AB6);
  v6 = &unk_850C120 + 144 * j;
  Q_strncpyz(v6 + 4, src, 64);
  *v6 = a2;
  *(v6 + 34) = sub_80C9071(src, v6 + 68, (v6 + 140), sub_809BC74);
  if ( !*(v6 + 34) )
    sub_80C9055();
  return &unk_850C120 + 144 * j;
}

//----- (0809BEED) --------------------------------------------------------
void *__cdecl sub_809BEED(void *s)
{
  void *result; // eax

  sub_80C8FC8(*(s + 34));
  result = sub_80C837D(s, 0, 0x90u);
  dword_80F5128 = 0;
  return result;
}
// 80F5128: using guessed type int dword_80F5128;

//----- (0809BF2B) --------------------------------------------------------
int *sub_809BF2B()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    if ( dword_850C1A8[36 * i] )
      sub_80C8FC8(dword_850C1A8[36 * i]);
    sub_80C837D(&unk_850C120 + 144 * i, 0, 0x90u);
    result = &i;
  }
  dword_80F5128 = 0;
  return result;
}
// 80F5128: using guessed type int dword_80F5128;

//----- (0809BFB4) --------------------------------------------------------
int __cdecl VM_Call(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14)
{
  int result; // eax
  int v15; // [esp+44h] [ebp-4h]

  v15 = dword_80F5128;
  dword_80F5128 = a1;
  result = (*(a1 + 140))(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  dword_80F5128 = v15;
  return result;
}
// 80F5128: using guessed type int dword_80F5128;

//----- (0809C040) --------------------------------------------------------
int __cdecl sub_809C040(int a1)
{
  int result; // eax

  result = a1;
  dword_80F512C = a1;
  return result;
}
// 80F512C: using guessed type int dword_80F512C;

//----- (0809C04E) --------------------------------------------------------
void __cdecl __noreturn sub_809C04E(const char *a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_80856B1();
  sub_80852BD();
  sub_80A3D50(v1 - dword_829F1E4, "%s", a1);
}
// 829F1E4: using guessed type int dword_829F1E4;

//----- (0809C086) --------------------------------------------------------
int sub_809C086()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  while ( 1 )
  {
    s1 = sub_8085E6A(&dword_829F1E8);
    if ( !*s1 )
      return v1;
    for ( i = 0; i <= 2 && strcasecmp(s1, (&off_80F5130)[i]); ++i )
      ;
    if ( i == 1 )
    {
      v1 |= 2u;
    }
    else if ( i > 1 )
    {
      if ( i != 2 )
LABEL_16:
        sub_809C04E("unknown anim property");
      v1 |= 8u;
    }
    else
    {
      if ( i )
        goto LABEL_16;
      v1 |= 1u;
    }
  }
}
// 829F1E8: using guessed type int dword_829F1E8;

//----- (0809C13A) --------------------------------------------------------
int __cdecl sub_809C13A(int *a1, unsigned __int16 a2, unsigned __int16 a3, int a4)
{
  int result; // eax
  int *v5; // eax
  int *v6; // edx
  unsigned __int16 v7; // [esp+12h] [ebp-16h]
  unsigned __int16 v8; // [esp+12h] [ebp-16h]
  int v9[3]; // [esp+18h] [ebp-10h] BYREF
  unsigned __int16 v10; // [esp+24h] [ebp-4h]
  unsigned __int16 v11; // [esp+26h] [ebp-2h]

  v11 = a2;
  v10 = a3;
  if ( dword_829F820 )
    sub_80A3D50(a4, "cannot reference animation from /# ... #/ comment");
  v7 = sub_80A6E88(v10, v11);
  if ( v7 )
  {
    v5 = sub_80A7646(v7);
    *a1 = *v5;
    v6 = v5;
    result = a1;
    *v6 = a1;
  }
  else
  {
    v8 = sub_80A71D8(v10, v11);
    *a1 = 0;
    v9[1] = 6;
    v9[0] = a1;
    result = sub_80A7590(v8, v9);
  }
  return result;
}
// 829F820: using guessed type int dword_829F820;

//----- (0809C1F4) --------------------------------------------------------
int __cdecl sub_809C1F4(int *a1, unsigned __int16 a2, int a3)
{
  if ( !word_829F9F4 )
    sub_80A3D50(a3, "#using_animtree was not specified");
  return sub_809C13A(a1, a2, word_829F9F4, a3);
}
// 829F9F4: using guessed type __int16 word_829F9F4;

//----- (0809C248) --------------------------------------------------------
int __cdecl sub_809C248(unsigned __int16 a1, unsigned __int16 a2, char a3, char a4, char a5)
{
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v8; // [esp+10h] [ebp-38h]
  char v9; // [esp+1Dh] [ebp-2Bh]
  unsigned __int8 v10; // [esp+1Eh] [ebp-2Ah]
  char i; // [esp+1Fh] [ebp-29h]
  int v12; // [esp+20h] [ebp-28h]
  unsigned __int16 v13; // [esp+26h] [ebp-22h]
  int v14[2]; // [esp+28h] [ebp-20h] BYREF
  unsigned __int16 v15; // [esp+30h] [ebp-18h]
  unsigned __int16 v16; // [esp+32h] [ebp-16h]
  char *v17; // [esp+34h] [ebp-14h]
  char v18; // [esp+39h] [ebp-Fh]
  char v19; // [esp+3Ah] [ebp-Eh]
  char v20; // [esp+3Bh] [ebp-Dh]
  unsigned __int16 v21; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 v22; // [esp+3Eh] [ebp-Ah]

  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = a4;
  v18 = a5;
  v14[1] = 5;
  v15 = 0;
  v16 = 0;
  v12 = 0;
  for ( i = 0; ; i = 0 )
  {
    while ( 1 )
    {
      v17 = sub_8085E0B(&dword_829F1E8);
      if ( !dword_829F1E8 )
      {
        v10 = 1;
        goto LABEL_46;
      }
      if ( !sub_80A1FE4(v17) )
        break;
      if ( i )
        sub_80A7240(v22, v15);
      v15 = sub_80A4E42(v17, 2, 4);
      if ( sub_80A6E88(v22, v15) )
        sub_809C04E("duplicate animation");
      v16 = sub_80A71D8(v22, v15);
      v9 = 0;
      if ( !v18 && !sub_80A6E88(v21, v15) && !dword_80F512C )
        v9 = 1;
      i = v9;
      v12 = 0;
      v17 = sub_8085E6A(&dword_829F1E8);
      if ( *v17 )
      {
        if ( sub_80A1FE4(v17) )
          sub_809C04E("FIXME: aliases not yet implemented");
        if ( *v17 != 58 || v17[1] )
          sub_809C04E("bad token");
        v12 = sub_809C086();
        v17 = sub_8085E0B(&dword_829F1E8);
        if ( *v17 != 123 || v17[1] )
          sub_809C04E("properties cannot be applied to primitive animations");
        break;
      }
    }
    if ( *v17 != 123 )
      break;
    if ( v17[1] )
      sub_809C04E("bad token");
    if ( *sub_8085E6A(&dword_829F1E8) )
      sub_809C04E("token not allowed after '{'");
    if ( !v16 )
      sub_809C04E("no animation specified for this block");
    v13 = sub_80A7B26(v16);
    v8 = 0;
    if ( v18 || (v12 & 8) != 0 && !i )
      v8 = 1;
    if ( sub_809C248(v13, v21, i ^ 1, v12 & 1, v8) )
      sub_809C04E("unexpected end of file");
    if ( sub_80A79FE(v13) )
    {
      v14[0] = v12;
      v5 = sub_80A71AA(v13, 0);
      sub_80A7590(v5, v14);
    }
    else
    {
      sub_80A7240(v22, v15);
    }
    v16 = 0;
  }
  if ( *v17 != 125 )
    sub_809C04E("bad token");
  if ( v17[1] )
    sub_809C04E("bad token");
  if ( *sub_8085E6A(&dword_829F1E8) )
    sub_809C04E("token not allowed after '}'");
  v10 = 0;
LABEL_46:
  if ( i )
    sub_80A7240(v22, v15);
  if ( v20 && !sub_80A79FE(v22) )
  {
    if ( v19 )
      v6 = sub_80A4D5C("void_loop", 0);
    else
      v6 = sub_80A4D5C("void", 0);
    v15 = v6;
    sub_80A71D8(v22, v6);
    sub_80A509E(v15);
  }
  return v10;
}
// 80F512C: using guessed type int dword_80F512C;
// 829F1E8: using guessed type int dword_829F1E8;

//----- (0809C60C) --------------------------------------------------------
_DWORD *__cdecl sub_809C60C(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  sub_808521C("Scr_AnimTreeParse");
  dword_829F1E8 = a1;
  dword_829F1E4 = a1;
  if ( !sub_809C248(a2, a3, 1, 0, 0) )
    sub_809C04E("bad token");
  return sub_80852BD();
}
// 829F1E4: using guessed type int dword_829F1E4;
// 829F1E8: using guessed type int dword_829F1E8;

//----- (0809C67C) --------------------------------------------------------
void *__cdecl sub_809C67C(size_t n)
{
  return sub_806C3EF(n, 4);
}

//----- (0809C698) --------------------------------------------------------
int __cdecl sub_809C698(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int16 i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = sub_80A7A30(a1); i; i = sub_80A7A30(i) )
  {
    if ( sub_80A7AA4(i) <= 0xFFFF )
    {
      if ( sub_80A7D0A(i) == 7 )
      {
        v1 = sub_80A7B82(i);
        v3 += sub_809C698(v1);
      }
      else
      {
        ++v3;
      }
    }
  }
  if ( v3 )
    ++v3;
  return v3;
}

//----- (0809C738) --------------------------------------------------------
int __cdecl sub_809C738(unsigned __int16 a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5)
{
  int result; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+20h] [ebp-18h]
  _DWORD *i; // [esp+24h] [ebp-14h]
  int *v11; // [esp+28h] [ebp-10h]

  result = sub_80A6E88(a1, a4);
  if ( result )
  {
    v11 = sub_80A7646(result);
    if ( !*v11 )
    {
      v6 = sub_80A4458(a3);
      v7 = sub_80A4458(a4);
      sub_80704AC(1, &byte_80E6CC0, v7, v6);
    }
    LOWORD(v8) = a2;
    HIWORD(v8) = a5;
    for ( i = *v11; i; i = v9 )
    {
      v9 = *i;
      *i = v8;
    }
    result = v11;
    *v11 = 0;
  }
  return result;
}

//----- (0809C80A) --------------------------------------------------------
int __cdecl sub_809C80A(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = dword_829F800[dword_8456180]; i && dword_829F200[128 * dword_8456180 + i] != a1; --i )
    ;
  return i;
}
// 829F800: using guessed type int dword_829F800[];
// 8456180: using guessed type int dword_8456180;

//----- (0809C85E) --------------------------------------------------------
int __cdecl sub_809C85E(int a1)
{
  return dword_829F200[128 * dword_8456180 + a1];
}
// 8456180: using guessed type int dword_8456180;

//----- (0809C876) --------------------------------------------------------
int __cdecl sub_809C876(unsigned __int16 a1, unsigned __int16 a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, int a8)
{
  int v8; // ebx
  unsigned __int16 v9; // ax
  int v10; // eax
  unsigned __int16 v12; // [esp+2Eh] [ebp-1Ah]
  unsigned __int16 v13; // [esp+32h] [ebp-16h]
  int v14; // [esp+34h] [ebp-14h]
  unsigned int v15; // [esp+38h] [ebp-10h]
  unsigned __int16 i; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 j; // [esp+3Ch] [ebp-Ch]
  int v18; // [esp+5Ch] [ebp+14h]
  int v19; // [esp+64h] [ebp+1Ch]

  v14 = 0;
  for ( i = sub_80A7A30(a1); i; i = sub_80A7A30(i) )
  {
    if ( sub_80A7AA4(i) <= 0xFFFF )
      ++v14;
  }
  v13 = sub_80A6E5A(a1, 0);
  if ( v13 )
    v12 = *sub_80A7646(v13);
  else
    v12 = 0;
  dword_80F51A4 *= 31;
  dword_80F51A4 += a6;
  dword_80F51A4 *= 31;
  dword_80F51A4 += a4;
  dword_80F51A4 *= 31;
  dword_80F51A4 += v14;
  dword_80F51A4 *= 31;
  dword_80F51A4 += v12;
  sub_80B95E2(a3, a6, a5, a4, v14, v12);
  v19 = a4;
  v18 = v14 + a4;
  for ( j = sub_80A7A30(a1); j; j = sub_80A7A30(j) )
  {
    v15 = sub_80A7AA4(j);
    if ( v15 <= 0xFFFF )
    {
      sub_809C738(a2, v19, a7, v15, a8);
      if ( sub_80A7D0A(j) == 7 )
      {
        v8 = sub_80A4458(v15);
        v9 = sub_80A7B82(j);
        v18 = sub_809C876(v9, a2, a3, v18, v8, v19, a7, a8);
      }
      else
      {
        dword_80F51A4 *= 31;
        dword_80F51A4 += v19;
        v10 = sub_80A4458(v15);
        sub_80B9570(a3, v19, v10);
      }
      ++v19;
    }
  }
  return v18;
}
// 80F51A4: using guessed type int dword_80F51A4;

//----- (0809CB02) --------------------------------------------------------
int __cdecl sub_809CB02(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  const char *v3; // ebx
  const char *v4; // eax
  char *v5; // [esp+10h] [ebp-18h]
  int *v6; // [esp+14h] [ebp-14h]
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v8; // [esp+1Ch] [ebp-Ch]

  result = sub_80A7A30(a1);
  for ( i = result; i; i = result )
  {
    v8 = sub_80A7AA4(i);
    v6 = sub_80A7646(i);
    if ( *v6 )
    {
      v3 = sub_80A4458(a2);
      v4 = sub_80A4458(v8);
      v5 = sub_8086D78("animation '%s' not defined in anim tree '%s'", v4, v3);
      if ( !sub_80A1F50(*v6) && !sub_80A1F84(*v6) )
        sub_80704AC(1, &byte_80E6D2D, v5);
      sub_80A3E12(*v6, "%s", v5);
    }
    result = sub_80A7A30(i);
  }
  return result;
}

//----- (0809CC08) --------------------------------------------------------
int __cdecl sub_809CC08(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  const char *v3; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 i; // [esp+14h] [ebp-4h]

  result = sub_80A7A30(a1);
  for ( i = result; i; i = result )
  {
    v4 = sub_80A7AA4(i);
    if ( v4 <= 0xFFFF )
    {
      if ( sub_80A7D0A(i) == 7 )
      {
        v2 = sub_80A7B82(i);
        sub_809CC08(v2);
      }
      else
      {
        v3 = sub_80A4458(v4);
        sub_80B816E(v3, sub_809C67C);
      }
    }
    result = sub_80A7A30(i);
  }
  return result;
}

//----- (0809CCA2) --------------------------------------------------------
int __cdecl sub_809CCA2(char *a1, int *a2)
{
  unsigned __int16 v2; // ax
  int i; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+10h] [ebp-8h]
  unsigned __int16 v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+12h] [ebp-6h]
  unsigned __int16 v8; // [esp+12h] [ebp-6h]
  unsigned __int16 v9; // [esp+14h] [ebp-4h]
  unsigned __int16 v10; // [esp+16h] [ebp-2h]

  v10 = sub_80A53FC(a1);
  v7 = sub_80A6E88(word_829F9F2, v10);
  if ( v7 )
  {
    v6 = sub_80A7B82(v7);
    *a2 = 0;
    for ( i = 1; i <= dword_829F800[dword_8456180]; ++i )
    {
      if ( word_829F600[128 * dword_8456180 + i] == v7 )
      {
        *a2 = i;
        break;
      }
    }
    v2 = sub_80A71D8(v6, 0);
  }
  else
  {
    v8 = sub_80A71D8(word_829F9F2, v10);
    v5 = sub_80A7ACA(v8);
    word_829F600[128 * dword_8456180 + ++dword_829F800[dword_8456180]] = v8;
    *a2 = dword_829F800[dword_8456180];
    v2 = sub_80A71D8(v5, 0);
  }
  v9 = sub_80A7B26(v2);
  sub_80A509E(v10);
  return v9;
}
// 829F600: using guessed type __int16 word_829F600[];
// 829F800: using guessed type int dword_829F800[];
// 829F9F2: using guessed type __int16 word_829F9F2;
// 8456180: using guessed type int dword_8456180;

//----- (0809CDE8) --------------------------------------------------------
int __cdecl sub_809CDE8(char *a1, int a2)
{
  int result; // eax

  if ( !sub_80A1FE4(a1) )
    sub_80A3D50(a2, "bad anim tree name");
  result = sub_809CCA2(a1, &dword_829F1EC);
  word_829F9F4 = result;
  return result;
}
// 829F1EC: using guessed type int dword_829F1EC;
// 829F9F4: using guessed type __int16 word_829F9F4;

//----- (0809CE2E) --------------------------------------------------------
_BOOL4 __cdecl sub_809CE2E(const char *a1, unsigned __int16 a2, unsigned __int16 a3)
{
  int v5; // [esp+24h] [ebp-64h]
  int v6; // [esp+28h] [ebp-60h]
  int v7; // [esp+2Ch] [ebp-5Ch]
  char s[76]; // [esp+30h] [ebp-58h] BYREF
  unsigned __int16 v9; // [esp+7Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+7Eh] [ebp-Ah]

  v10 = a2;
  v9 = a3;
  sprintf(s, "animtrees/%s.atr", a1);
  v5 = *dword_80F5174;
  v7 = sub_80A3806(s, 0, 0);
  if ( !v7 )
    return 0;
  v6 = *dword_80F5178;
  *dword_80F5178 = s;
  sub_809C60C(v7, v10, v9);
  *dword_80F5178 = v6;
  *dword_80F5174 = v5;
  sub_806C522();
  return sub_80A79FE(v10) != 0;
}

//----- (0809CEFC) --------------------------------------------------------
int __cdecl sub_809CEFC(int a1, int (__cdecl *a2)(int))
{
  int result; // eax
  const char *v3; // eax
  int v4; // eax
  _DWORD *v5; // eax
  unsigned __int16 v6; // ax
  int *v7; // [esp+30h] [ebp-28h]
  unsigned __int16 v8; // [esp+36h] [ebp-22h]
  unsigned __int16 v9; // [esp+38h] [ebp-20h]
  unsigned __int16 v10; // [esp+3Ah] [ebp-1Eh]
  _DWORD *v11; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v12; // [esp+42h] [ebp-16h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned __int16 v14; // [esp+4Eh] [ebp-Ah]
  unsigned __int16 v15; // [esp+4Eh] [ebp-Ah]
  int v16[2]; // [esp+50h] [ebp-8h] BYREF

  v8 = word_829F600[128 * dword_8456180 + a1];
  v12 = sub_80A7AA4(v8);
  v9 = sub_80A7B82(v8);
  result = sub_80A6E88(v9, 1);
  if ( !result )
  {
    v14 = sub_80A6E88(v9, 0);
    if ( v14 )
    {
      v15 = sub_80A7B82(v14);
      word_829F1E0 = sub_80A6AAC();
      v3 = sub_80A4458(v12);
      if ( sub_809CE2E(v3, word_829F1E0, v15) )
      {
        v13 = sub_809C698(word_829F1E0);
        v4 = sub_80A4458(v12);
        v7 = sub_8064FC5("animtrees", v4, ".atr");
        if ( v7 )
          v5 = sub_80B966A(*v7, v13, a2);
        else
          v5 = sub_80B966A("(savegame)", v13, a2);
        v11 = v5;
        v10 = sub_80A4D5C("root", 0);
        sub_809C738(v15, 0, v12, v10, a1);
        sub_80A509E(v10);
        sub_809C876(word_829F1E0, v15, v11, 1, "root", 0, v12, a1);
        sub_809CB02(v15, v12);
        sub_809CC08(word_829F1E0);
        sub_80A7240(v9, 0);
        sub_80A6C02(word_829F1E0);
        word_829F1E0 = 0;
        v16[1] = 6;
        v16[0] = v11;
        v6 = sub_80A71D8(v9, 1u);
        sub_80A7590(v6, v16);
        sub_80C0AA8(v11);
        result = v11;
        dword_829F200[128 * dword_8456180 + a1] = v11;
      }
      else
      {
        sub_80A7240(word_829F9F2, v12);
        sub_80A6C02(word_829F1E0);
        word_829F1E0 = 0;
        result = 0;
        dword_829F200[128 * dword_8456180 + a1] = 0;
      }
    }
    else
    {
      result = 0;
      dword_829F200[128 * dword_8456180 + a1] = 0;
    }
  }
  return result;
}
// 829F1E0: using guessed type __int16 word_829F1E0;
// 829F600: using guessed type __int16 word_829F600[];
// 829F9F2: using guessed type __int16 word_829F9F2;
// 8456180: using guessed type int dword_8456180;

//----- (0809D1DE) --------------------------------------------------------
_DWORD *__userpurge sub_809D1DE@<eax>(_DWORD *a1, char *a2)
{
  int v3; // [esp+8h] [ebp-10h] BYREF
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v5 = sub_80A53FC(a2);
  v6 = sub_80A6E88(word_829F9F2, v5);
  sub_80A509E(v5);
  *a1 = 0;
  if ( v6 )
  {
    v5 = sub_80A7AA4(v6);
    v6 = sub_80A7B82(v6);
    v4 = sub_80A6E88(v6, 1);
    if ( v4 )
    {
      sub_80A779A(v4, &v3);
      *a1 = v3;
    }
  }
  return a1;
}
// 829F9F2: using guessed type __int16 word_829F9F2;

//----- (0809D290) --------------------------------------------------------
int __cdecl sub_809D290(char *a1, char *s, int *a3)
{
  unsigned __int16 v3; // ax
  int v5; // [esp+10h] [ebp-8h] BYREF
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = sub_80A4E42(s, 0, 4);
  v3 = sub_809CCA2(a1, &v5);
  sub_809C13A(a3, v6, v3, 0);
  return sub_80A509E(v6);
}

//----- (0809D2F8) --------------------------------------------------------
int __cdecl sub_809D2F8(int a1)
{
  int result; // eax

  result = a1;
  if ( !byte_829F81C )
    result = sub_80A509E(a1);
  return result;
}
// 829F81C: using guessed type char byte_829F81C;

//----- (0809D31E) --------------------------------------------------------
_DWORD *__cdecl sub_809D31E(unsigned __int16 a1)
{
  _DWORD *result; // eax
  __int16 v2; // dx

  dword_829F808 = sub_80A5458(2);
  if ( dword_829F820 == 2 )
    return sub_809D2F8(a1);
  if ( byte_829F81C )
    sub_80A4F00(a1);
  if ( dword_829F820 )
  {
    *dword_829F808 = a1;
    result = sub_806BB38(8u);
    *result = dword_829F808 + dword_829F82C - dword_829F828;
    **result = 0;
    result[1] = dword_80F5148;
    dword_80F5148 = result;
  }
  else
  {
    v2 = sub_80A2150(a1);
    result = dword_829F808;
    *dword_829F808 = v2;
  }
  return result;
}
// 829F808: using guessed type int dword_829F808;
// 829F81C: using guessed type char byte_829F81C;
// 829F820: using guessed type int dword_829F820;

//----- (0809D3E0) --------------------------------------------------------
int __cdecl sub_809D3E0(unsigned __int16 a1, unsigned __int8 a2)
{
  if ( dword_829F820 == 2 )
    return sub_809D2F8(a1);
  if ( byte_829F81C )
    sub_80A4F00(a1);
  return sub_80A4EAC(a1, a2);
}
// 829F81C: using guessed type char byte_829F81C;
// 829F820: using guessed type int dword_829F820;

//----- (0809D436) --------------------------------------------------------
int __cdecl sub_809D436(unsigned __int8 a1, int a2, int a3)
{
  int result; // eax

  if ( byte_829F824 && !dword_829F820 )
  {
    byte_829F824 = 0;
    sub_80A11EC();
  }
  dword_829F810 += a2;
  if ( dword_829F814 < dword_829F810 )
    dword_829F814 = dword_829F810;
  if ( a3 )
  {
    if ( dword_829F818 < dword_829F810 )
    {
      dword_829F818 = dword_829F810;
      if ( a3 == 3 )
        ++dword_829F818;
    }
  }
  dword_829F808 = sub_80A5458(1);
  dword_831FD88 = dword_829F808;
  *dword_829F808 = a1;
  dword_80F51A4 *= 31;
  result = a1;
  dword_80F51A4 += a1;
  return result;
}
// 80F51A4: using guessed type int dword_80F51A4;
// 829F808: using guessed type int dword_829F808;
// 829F810: using guessed type int dword_829F810;
// 829F814: using guessed type int dword_829F814;
// 829F818: using guessed type int dword_829F818;
// 829F820: using guessed type int dword_829F820;
// 829F824: using guessed type char byte_829F824;
// 831FD88: using guessed type int dword_831FD88;

//----- (0809D4EE) --------------------------------------------------------
int sub_809D4EE()
{
  return sub_809D436(0x56u, 0, 0);
}

//----- (0809D512) --------------------------------------------------------
int __cdecl sub_809D512(int a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D536) --------------------------------------------------------
int __cdecl sub_809D536(unsigned __int16 a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(2);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D564) --------------------------------------------------------
int __cdecl sub_809D564(unsigned __int8 a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(1);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D590) --------------------------------------------------------
int __cdecl sub_809D590(int a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D5B4) --------------------------------------------------------
int __cdecl sub_809D5B4(unsigned __int16 a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(2);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D5E2) --------------------------------------------------------
int sub_809D5E2()
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = dword_829F808;
  *dword_829F808 = 0;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D606) --------------------------------------------------------
int __cdecl sub_809D606(int a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D62A) --------------------------------------------------------
int __cdecl sub_809D62A(int a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D64E) --------------------------------------------------------
int __cdecl sub_809D64E(int a1)
{
  int result; // eax

  dword_829F808 = sub_80A5458(4);
  result = a1;
  *dword_829F808 = a1;
  return result;
}
// 829F808: using guessed type int dword_829F808;

//----- (0809D672) --------------------------------------------------------
int sub_809D672()
{
  return sub_809D436(2u, 1, 0);
}

//----- (0809D696) --------------------------------------------------------
int __cdecl sub_809D696(int a1)
{
  sub_809D436(3u, 1, 0);
  return sub_809D512(a1);
}

//----- (0809D6C6) --------------------------------------------------------
int __cdecl sub_809D6C6(int a1)
{
  sub_809D436(4u, 1, 0);
  return sub_809D590(a1);
}

//----- (0809D6F6) --------------------------------------------------------
int sub_809D6F6()
{
  sub_809D436(3u, 1, 0);
  return sub_809D512(0);
}

//----- (0809D726) --------------------------------------------------------
int sub_809D726()
{
  sub_809D436(3u, 1, 0);
  return sub_809D512(1);
}

//----- (0809D756) --------------------------------------------------------
int __cdecl sub_809D756(int a1)
{
  if ( !dword_829F1EC )
    sub_80A3D50(a1, "#using_animtree was not specified");
  sub_809D436(3u, 1, 0);
  return sub_809D512(dword_829F1EC);
}
// 829F1EC: using guessed type int dword_829F1EC;

//----- (0809D7A6) --------------------------------------------------------
void __cdecl sub_809D7A6(int a1)
{
  sub_809D436(0x20u, -1, 0);
  sub_80A3226(a1);
}

//----- (0809D7D6) --------------------------------------------------------
_DWORD *__cdecl sub_809D7D6(unsigned __int16 a1, int a2)
{
  sub_809D436(0x1Cu, 0, 0);
  sub_80A3226(a2);
  return sub_809D31E(a1);
}

//----- (0809D812) --------------------------------------------------------
_DWORD *__cdecl sub_809D812(unsigned __int16 a1, int a2)
{
  sub_809D436(0x1Du, 0, 0);
  sub_80A3226(a2);
  return sub_809D31E(a1);
}

//----- (0809D84E) --------------------------------------------------------
int __cdecl sub_809D84E(unsigned __int16 a1)
{
  sub_809D436(5u, 1, 0);
  sub_809D5B4(a1);
  return sub_809D3E0(a1, 1u);
}

//----- (0809D89A) --------------------------------------------------------
int __cdecl sub_809D89A(unsigned __int16 a1)
{
  sub_809D436(6u, 1, 0);
  sub_809D5B4(a1);
  return sub_809D3E0(a1, 1u);
}

//----- (0809D8E6) --------------------------------------------------------
void __cdecl sub_809D8E6(int a1)
{
  sub_809D436(0x2Fu, 0, 0);
  sub_80A3226(a1);
}

//----- (0809D916) --------------------------------------------------------
void __cdecl sub_809D916(int a1)
{
  sub_809D436(0x30u, 0, 0);
  sub_80A3226(a1);
}

//----- (0809D946) --------------------------------------------------------
void __cdecl sub_809D946(int a1)
{
  sub_809D436(0x31u, 0, 0);
  sub_80A3226(a1);
}

//----- (0809D976) --------------------------------------------------------
void __cdecl sub_809D976(int a1)
{
  sub_809D436(0x32u, 0, 0);
  sub_80A3226(a1);
}

//----- (0809D9A6) --------------------------------------------------------
void __cdecl sub_809D9A6(int a1)
{
  sub_809D436(0x33u, 0, 0);
  sub_80A3226(a1);
}

//----- (0809D9D6) --------------------------------------------------------
void __cdecl sub_809D9D6(int a1)
{
  sub_809D436(0x34u, 0, 0);
  sub_80A3226(a1);
}

//----- (0809DA06) --------------------------------------------------------
void __cdecl sub_809DA06(int a1, int a2)
{
  sub_809F364(a1);
  sub_809D436(0x4Du, 0, 0);
  sub_80A3226(a2);
}
// 809F364: using guessed type _DWORD __cdecl sub_809F364(_DWORD);

//----- (0809DA40) --------------------------------------------------------
int sub_809DA40()
{
  return sub_809D436(0xAu, 1, 0);
}

//----- (0809DA64) --------------------------------------------------------
int sub_809DA64()
{
  return sub_809D436(0xBu, 1, 0);
}

//----- (0809DA88) --------------------------------------------------------
int sub_809DA88()
{
  return sub_809D436(0xCu, 1, 0);
}

//----- (0809DAAC) --------------------------------------------------------
int sub_809DAAC()
{
  return sub_809D436(0xDu, 1, 0);
}

//----- (0809DAD0) --------------------------------------------------------
int sub_809DAD0()
{
  return sub_809D436(7u, 0, 0);
}

//----- (0809DAF4) --------------------------------------------------------
int sub_809DAF4()
{
  return sub_809D436(8u, 0, 0);
}

//----- (0809DB18) --------------------------------------------------------
int sub_809DB18()
{
  return sub_809D436(9u, 0, 0);
}

//----- (0809DB3C) --------------------------------------------------------
_DWORD *__cdecl sub_809DB3C(unsigned __int16 a1)
{
  sub_809D436(0x11u, 1, 0);
  return sub_809D31E(a1);
}

//----- (0809DB6C) --------------------------------------------------------
_DWORD *__cdecl sub_809DB6C(unsigned __int16 a1)
{
  sub_809D436(0x12u, 0, 0);
  return sub_809D31E(a1);
}

//----- (0809DB9C) --------------------------------------------------------
int sub_809DB9C()
{
  return sub_809D436(0xFu, 0, 0);
}

//----- (0809DBC0) --------------------------------------------------------
_DWORD *__cdecl sub_809DBC0(unsigned __int16 a1)
{
  sub_809D436(0x13u, 0, 0);
  return sub_809D31E(a1);
}

//----- (0809DBF0) --------------------------------------------------------
void __cdecl sub_809DBF0(int a1, int a2)
{
  sub_809D436(0x14u, -1, 0);
  sub_80A3226(a2);
  sub_80A3226(a1);
}

//----- (0809DC2A) --------------------------------------------------------
void __cdecl sub_809DC2A(int a1, int a2)
{
  sub_809D436(0x15u, -1, 0);
  sub_80A3226(a2);
  sub_80A3226(a1);
}

//----- (0809DC64) --------------------------------------------------------
void __cdecl sub_809DC64(int a1, int a2)
{
  sub_809D436(0x16u, -1, 0);
  sub_80A3226(a2);
  sub_80A3226(a1);
}

//----- (0809DC9E) --------------------------------------------------------
int sub_809DC9E()
{
  return sub_809D436(0x17u, 1, 0);
}

//----- (0809DCC2) --------------------------------------------------------
int __cdecl sub_809DCC2(unsigned __int16 a1, int a2)
{
  sub_809D436(0xEu, 1, 0);
  sub_809D512(-1);
  sub_80A3226(a2);
  sub_809C1F4(dword_829F808, a1, a2);
  return sub_809D2F8(a1);
}
// 829F808: using guessed type int dword_829F808;

//----- (0809DD26) --------------------------------------------------------
_DWORD *__cdecl sub_809DD26(_DWORD *a1, unsigned __int16 a2, int a3)
{
  sub_809FA00(a1, a3);
  sub_809D436(0x18u, 1, 0);
  sub_80A3226(a3);
  return sub_809D31E(a2);
}

//----- (0809DD74) --------------------------------------------------------
_DWORD *__cdecl sub_809DD74(_DWORD *a1, unsigned __int16 a2, int a3)
{
  sub_809FA00(a1, a3);
  sub_809D436(0x19u, 0, 0);
  return sub_809D31E(a2);
}

//----- (0809DDB6) --------------------------------------------------------
_DWORD *__cdecl sub_809DDB6(_DWORD *a1, unsigned __int16 a2, int a3, int a4)
{
  sub_809FA00(a1, a3);
  sub_809D436(0x1Au, 0, 0);
  sub_80A3226(a4);
  return sub_809D31E(a2);
}

//----- (0809DE04) --------------------------------------------------------
int __cdecl sub_809DE04(_DWORD *a1, int *a2)
{
  sub_809E8A4(a1, a2, 0);
  return sub_809D436(0x1Bu, -1, 0);
}

//----- (0809DE42) --------------------------------------------------------
int __cdecl sub_809DE42(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  sub_809EAE0(a1, a2, a3, a4, 0);
  return sub_809D436(0x1Bu, -1, 0);
}

//----- (0809DE8E) --------------------------------------------------------
int sub_809DE8E()
{
  return sub_809D436(0x2Du, -1, 0);
}

//----- (0809DEB2) --------------------------------------------------------
void __cdecl sub_809DEB2(int a1)
{
  sub_809D436(0x2Eu, -1, 0);
  sub_80A3226(a1);
}

//----- (0809DEE2) --------------------------------------------------------
void __cdecl sub_809DEE2(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  sub_809F6C6(a2);
  sub_809F364(a1);
  sub_809DBF0(a3, a4);
}

//----- (0809DF12) --------------------------------------------------------
void __cdecl sub_809DF12(int *a1, _DWORD *a2, int a3, int a4)
{
  sub_809F6C6(a2);
  sub_809F91C(a1, a3);
  sub_809DC2A(a3, a4);
}

//----- (0809DF4A) --------------------------------------------------------
void __cdecl sub_809DF4A(int *a1, _DWORD *a2, int a3, int a4)
{
  sub_809F6C6(a2);
  sub_809F91C(a1, a3);
  sub_809DC64(a3, a4);
}

//----- (0809DF82) --------------------------------------------------------
void __cdecl sub_809DF82(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *a1;
  if ( *a1 == 11 )
  {
    sub_809DEE2(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809DD26(*(a1 + 4), *(a1 + 8), *(a1 + 12));
  }
  else if ( v1 == 3 )
  {
    sub_809DB3C(*(a1 + 4));
  }
}

//----- (0809E01E) --------------------------------------------------------
int __cdecl sub_809E01E(int *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = *a1; i; i = *(i + 4) )
  {
    sub_809F6C6(**i);
    ++v2;
  }
  return v2;
}

//----- (0809E062) --------------------------------------------------------
int __cdecl sub_809E062(int a1)
{
  if ( !*a1 )
    return 0;
  if ( *(*a1 + 4) )
    return 0;
  return *a1;
}

//----- (0809E09E) --------------------------------------------------------
_DWORD *__cdecl sub_809E09E(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  if ( dword_829FA00 )
  {
    result = *a1;
    for ( i = *a1; i; i = result )
    {
      sub_80A3226(*(*i + 4));
      result = i[1];
    }
  }
  return result;
}
// 829FA00: using guessed type int dword_829FA00;

//----- (0809E0E0) --------------------------------------------------------
int __cdecl sub_809E0E0(unsigned __int16 a1, int a2)
{
  unsigned __int16 v2; // ax

  sub_80A4F00(a1);
  *dword_829F830 = a1;
  *(dword_829F830 + 4) = a2;
  dword_829F830 += 8;
  v2 = sub_80A71D8(word_829F9EE, a1);
  return sub_80A7ACA(v2);
}
// 829F830: using guessed type int dword_829F830;
// 829F9EE: using guessed type __int16 word_829F9EE;

//----- (0809E140) --------------------------------------------------------
void __cdecl sub_809E140(int a1, int a2)
{
  char *v2; // eax
  bool v3; // [esp+1Bh] [ebp-1Dh]
  unsigned __int16 v4; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v5; // [esp+1Eh] [ebp-1Ah]
  unsigned __int16 v6; // [esp+20h] [ebp-18h]
  unsigned __int16 v7; // [esp+22h] [ebp-16h]
  unsigned __int16 v8; // [esp+24h] [ebp-14h]
  unsigned __int16 v9; // [esp+24h] [ebp-14h]
  unsigned __int16 v10; // [esp+26h] [ebp-12h]
  int v11; // [esp+28h] [ebp-10h] BYREF
  int v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+30h] [ebp-8h] BYREF
  int v14; // [esp+34h] [ebp-4h]

  if ( dword_829F820 == 2 )
  {
    sub_809D2F8(*(a1 + 4));
    if ( *a1 == 17 )
    {
      sub_809D2F8(*(a1 + 8));
      --dword_829FA0C;
    }
    return;
  }
  v10 = 0;
  if ( *a1 == 16 )
  {
    v8 = sub_80A6E88(word_829F80C, *(a1 + 4));
    sub_809D3E0(*(a1 + 4), 2u);
    if ( !v8 )
      sub_80A3D50(a2, "unknown function");
    v10 = sub_80A7B82(v8);
    goto LABEL_21;
  }
  if ( *a1 == 17 )
  {
    v2 = sub_80A4458(*(a1 + 4));
    v4 = sub_80A53FC(v2);
    sub_809D2F8(*(a1 + 4));
    v3 = sub_80A6E88(word_829F9F0, v4) != 0;
    v5 = sub_809E0E0(v4, a2);
    sub_809D2F8(v4);
    if ( v3 )
    {
      v9 = sub_80A6E88(v5, *(a1 + 8));
      sub_809D3E0(*(a1 + 8), 2u);
      if ( !v9 )
        sub_80A3D50(a2, "unknown function");
    }
    else
    {
      v9 = sub_80A71D8(v5, *(a1 + 8));
      sub_809D3E0(*(a1 + 8), 2u);
    }
    sub_80A779A(v9, &v11);
    if ( v12 != 6 )
    {
      if ( v12 != 5 )
      {
        v10 = sub_80A7ACA(v9);
        goto LABEL_21;
      }
      if ( dword_829F820 != 1 )
        sub_80A3D50(a2, "normal script cannot reference /# ... #/ comment");
    }
    sub_809D606(v11);
    return;
  }
LABEL_21:
  sub_809D5E2();
  if ( dword_829F820 != 2 )
  {
    v7 = sub_80A71D8(v10, 0);
    sub_80A779A(v7, &v13);
    if ( !v14 )
    {
      v14 = 5;
      v13 = 0;
    }
    v6 = sub_80A71D8(v10, v13 + 2);
    v11 = dword_829F808;
    if ( dword_829F820 == 1 )
    {
      v12 = 5;
      v11 += dword_829F82C - dword_829F828;
    }
    else
    {
      v12 = 6;
    }
    sub_80A7600(v6, &v11);
    ++v13;
    sub_80A7590(v7, &v13);
    sub_80A3226(a2);
  }
}
// 829F808: using guessed type int dword_829F808;
// 829F80C: using guessed type __int16 word_829F80C;
// 829F820: using guessed type int dword_829F820;
// 829F9F0: using guessed type __int16 word_829F9F0;
// 829FA0C: using guessed type int dword_829FA0C;

//----- (0809E45A) --------------------------------------------------------
void __cdecl sub_809E45A(int a1, int a2)
{
  sub_809D436(0x10u, 1, 0);
  sub_809E140(a1, a2);
}

//----- (0809E490) --------------------------------------------------------
int __cdecl sub_809E490(int a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_809D436(0x27u, -a2 - 2, 3);
  else
    sub_809D436(0x25u, -a2 - 1, 3);
  sub_809E140(a1, a4);
  return sub_809D512(a2);
}

//----- (0809E502) --------------------------------------------------------
int __cdecl sub_809E502(int a1, int a2, char a3, int a4, int a5)
{
  sub_809F6C6(a1);
  if ( a3 )
    sub_809D436(0x28u, -a2 - 3, 3);
  else
    sub_809D436(0x26u, -a2 - 2, 3);
  sub_80A3226(a5);
  sub_80A3226(a4);
  return sub_809D512(a2);
}
// 809F6C6: using guessed type _DWORD __cdecl sub_809F6C6(_DWORD);

//----- (0809E584) --------------------------------------------------------
int __cdecl sub_809E584(int a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_809D436(0x2Bu, -a2, 2);
  else
    sub_809D436(0x29u, 1 - a2, 2);
  sub_809E140(a1, a4);
  return sub_809D512(a2);
}

//----- (0809E5F4) --------------------------------------------------------
int __cdecl sub_809E5F4(int a1, int a2, char a3, int a4)
{
  sub_809F6C6(a1);
  if ( a3 )
    sub_809D436(0x2Cu, -a2 - 1, 2);
  else
    sub_809D436(0x2Au, -a2, 2);
  sub_80A3226(a4);
  return sub_809D512(a2);
}
// 809F6C6: using guessed type _DWORD __cdecl sub_809F6C6(_DWORD);

//----- (0809E666) --------------------------------------------------------
int __cdecl sub_809E666(int *a1, int a2, char a3, int a4)
{
  int result; // eax

  result = *a1;
  if ( *a1 == 14 )
    return sub_809E490(a1[1], a2, a3, a4);
  if ( *a1 == 18 )
    result = sub_809E502(a1[1], a2, a3, a4, a1[2]);
  return result;
}

//----- (0809E6E4) --------------------------------------------------------
void __cdecl sub_809E6E4(_DWORD *a1, int a2, char a3, int a4, int a5)
{
  if ( *a1 == 14 )
  {
    sub_809E584(a1[1], a2, a3, a5);
  }
  else if ( *a1 == 18 )
  {
    sub_809E5F4(a1[1], a2, a3, a1[2]);
  }
  sub_80A3226(a4);
}

//----- (0809E766) --------------------------------------------------------
int __cdecl sub_809E766(_DWORD *a1)
{
  int result; // eax

  result = a1;
  if ( *a1 == 22 )
    result = sub_809D436(0x24u, 2, 0);
  return result;
}

//----- (0809E792) --------------------------------------------------------
void __cdecl sub_809E792(int a1, int a2, char a3)
{
  if ( *a1 == 22 )
  {
    sub_809E666(*(a1 + 4), a2, a3, *(a1 + 8));
  }
  else if ( *a1 == 26 )
  {
    sub_809E6E4(*(a1 + 4), a2, a3, *(a1 + 8), *(a1 + 12));
  }
}

//----- (0809E81A) --------------------------------------------------------
int __cdecl sub_809E81A(_DWORD *a1)
{
  _DWORD *v3; // [esp+20h] [ebp+8h]
  int v4; // [esp+20h] [ebp+8h]

  if ( *a1 != 22 )
    return 0;
  v3 = a1[1];
  if ( *v3 != 14 )
    return 0;
  v4 = v3[1];
  if ( *v4 != 16 )
    return 0;
  if ( sub_80A6E88(word_829F80C, *(v4 + 4)) )
    return 0;
  return *(v4 + 4);
}
// 829F80C: using guessed type __int16 word_829F80C;

//----- (0809E8A4) --------------------------------------------------------
_DWORD *__cdecl sub_809E8A4(_DWORD *a1, int *a2, char a3)
{
  _DWORD *result; // eax
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  char v8[4]; // [esp+24h] [ebp-14h] BYREF
  int v9; // [esp+28h] [ebp-10h]
  unsigned __int16 v10; // [esp+2Eh] [ebp-Ah]
  int v11; // [esp+30h] [ebp-8h]
  char v12; // [esp+37h] [ebp-1h]

  v12 = a3;
  v10 = sub_809E81A(a1);
  if ( v10 )
  {
    *v8 = sub_80A4458(v10);
    v7 = 0;
    v6 = sub_80A1AAC(v8, &v7);
    v9 = a1[2];
    v5 = dword_80F51A4;
    v4 = sub_80A5458(0);
    if ( v7 )
    {
      if ( dword_829F820 )
      {
        v7 = 0;
      }
      else
      {
        if ( !v12 )
          sub_80A3D50(v9, "developer command can only be used as a statement if not in a /# ... #/ comment");
        if ( dword_829FA04 )
        {
          if ( !byte_829F824 )
          {
            sub_809D436(0x57u, 0, 0);
            dword_829F828 = dword_829F808;
          }
          dword_829F820 = 1;
        }
        else
        {
          dword_829F820 = 2;
        }
      }
    }
    v11 = sub_809E01E(a2);
    if ( v11 > 255 )
    {
      sub_809D2F8(v10);
      sub_80A3D50(v9, "parameter count exceeds 256");
    }
    if ( !v6 )
      sub_80A3D50(v9, "unknown (builtin) function '%s'", *v8);
    sub_809D2F8(v10);
    sub_809D436(0x21u, 1 - v11, 1);
    sub_809D564(v11);
    sub_809D62A(v6);
    sub_80A3226(v9);
    result = sub_809E09E(a2);
    if ( v12 )
      result = sub_809DE8E();
    if ( v7 )
    {
      dword_829F820 = 0;
      if ( dword_829FA04 )
        byte_829F824 = 1;
      else
        sub_80A548C(v4);
      result = v5;
      dword_80F51A4 = v5;
    }
  }
  else
  {
    sub_809E766(a1);
    v11 = sub_809E01E(a2);
    sub_809E792(a1, v11, 0);
    result = sub_809E09E(a2);
    if ( v12 )
      result = sub_809DE8E();
  }
  return result;
}
// 80F51A4: using guessed type int dword_80F51A4;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;
// 829F824: using guessed type char byte_829F824;
// 829FA04: using guessed type int dword_829FA04;

//----- (0809EAE0) --------------------------------------------------------
_DWORD *__cdecl sub_809EAE0(int a1, _DWORD *a2, _DWORD *a3, int a4, char a5)
{
  _DWORD *result; // eax
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h] BYREF
  char v10[4]; // [esp+24h] [ebp-14h] BYREF
  int v11; // [esp+28h] [ebp-10h]
  unsigned __int16 v12; // [esp+2Eh] [ebp-Ah]
  int v13; // [esp+30h] [ebp-8h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = a5;
  v12 = sub_809E81A(a2);
  if ( v12 )
  {
    *v10 = sub_80A4458(v12);
    v9 = 0;
    v8 = sub_80A1AC8(v10, &v9);
    v11 = a2[2];
    v7 = dword_80F51A4;
    v6 = sub_80A5458(0);
    if ( v9 )
    {
      if ( dword_829F820 )
      {
        v9 = 0;
      }
      else
      {
        if ( !v14 )
          sub_80A3D50(v11, "developer command can only be used as a statement if not in a /# ... #/ comment");
        if ( dword_829FA04 )
        {
          if ( !byte_829F824 )
          {
            sub_809D436(0x57u, 0, 0);
            dword_829F828 = dword_829F808;
          }
          dword_829F820 = 1;
        }
        else
        {
          dword_829F820 = 2;
        }
      }
    }
    v13 = sub_809E01E(a3);
    sub_809F364(a1);
    if ( v13 > 255 )
    {
      sub_809D2F8(v12);
      sub_80A3D50(v11, "parameter count exceeds 256");
    }
    if ( !v8 )
      sub_80A3D50(v11, "unknown (builtin) method '%s'", *v10);
    sub_809D2F8(v12);
    sub_809D436(0x22u, -v13, 1);
    sub_809D564(v13);
    sub_809D64E(v8);
    sub_80A3226(v11);
    sub_80A3226(a4);
    result = sub_809E09E(a3);
    if ( v14 )
      result = sub_809DE8E();
    if ( v9 )
    {
      dword_829F820 = 0;
      if ( dword_829FA04 )
        byte_829F824 = 1;
      else
        sub_80A548C(v6);
      result = v7;
      dword_80F51A4 = v7;
    }
  }
  else
  {
    sub_809E766(a2);
    v13 = sub_809E01E(a3);
    sub_809F364(a1);
    sub_809E792(a2, v13, 1);
    sub_80A3226(a4);
    result = sub_809E09E(a3);
    if ( v14 )
      result = sub_809DE8E();
  }
  return result;
}
// 809E01E: using guessed type _DWORD __cdecl sub_809E01E(_DWORD);
// 809F364: using guessed type _DWORD __cdecl sub_809F364(_DWORD);
// 80F51A4: using guessed type int dword_80F51A4;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;
// 829F824: using guessed type char byte_829F824;
// 829FA04: using guessed type int dword_829FA04;

//----- (0809ED4A) --------------------------------------------------------
int sub_809ED4A()
{
  int result; // eax
  int j; // [esp+8h] [ebp-30h]
  unsigned __int16 v2; // [esp+Eh] [ebp-2Ah]
  int *v3; // [esp+10h] [ebp-28h]
  unsigned __int16 v4; // [esp+16h] [ebp-22h]
  int v5; // [esp+18h] [ebp-20h] BYREF
  int v6; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v7; // [esp+26h] [ebp-12h]
  int v8[3]; // [esp+28h] [ebp-10h] BYREF
  unsigned __int16 v9; // [esp+34h] [ebp-4h]
  unsigned __int16 i; // [esp+36h] [ebp-2h]

  v6 = 0;
  v5 = 0;
  result = sub_80A7A30(word_829F80C);
  for ( i = result; i; i = result )
  {
    v9 = sub_80A7B82(i);
    v4 = sub_80A6E88(v9, 1);
    if ( v4 )
      sub_80A779A(v4, &v5);
    v7 = sub_80A6E88(v9, 0);
    if ( v7 )
    {
      sub_80A779A(v7, v8);
      for ( j = 0; j < v8[0]; ++j )
      {
        v2 = sub_80A6E88(v9, j + 2);
        v3 = sub_80A7646(v2);
        if ( v6 == 5 && sub_80A7D0A(v2) == 6 )
          sub_80A3E12(*v3, "normal script cannot reference /# ... #/ comment");
        if ( !v4 )
          sub_80A3E12(*v3, "unknown function");
        **v3 = v5;
      }
    }
    if ( v4 )
      sub_80A7590(i, &v5);
    result = sub_80A7A30(i);
  }
  return result;
}
// 829F80C: using guessed type __int16 word_829F80C;

//----- (0809EEC4) --------------------------------------------------------
int __cdecl sub_809EEC4(unsigned __int16 a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+26h] [ebp-2h]

  v6 = a1;
  v3 = sub_80A71D8(a1, 1u);
  sub_80A779A(v3, &v4);
  if ( v5 )
    sub_80A3D50(a2, "function already defined");
  v5 = 6;
  v4 = 0;
  return sub_80A7600(v3, &v4);
}

//----- (0809EF3A) --------------------------------------------------------
int __cdecl sub_809EF3A(int a1, int a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+26h] [ebp-2h]

  result = a1;
  v6 = a1;
  if ( dword_829FA04 )
  {
    v3 = sub_80A71D8(v6, 1u);
    sub_80A779A(v3, &v4);
    if ( v5 )
      sub_80A3D50(a2, "function already defined");
    v5 = 5;
    v4 = 0;
    result = sub_80A7600(v3, &v4);
  }
  return result;
}
// 829FA04: using guessed type int dword_829FA04;

//----- (0809EFBC) --------------------------------------------------------
int __cdecl sub_809EFBC(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // ebx
  int result; // eax

  v1 = sub_80A6E88(a1, 1);
  v2 = sub_80A7646(v1);
  result = sub_80A5458(0);
  *v2 = result;
  return result;
}

//----- (0809F000) --------------------------------------------------------
int __cdecl sub_809F000(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // ebx
  int result; // eax

  v1 = sub_80A6E88(a1, 1);
  v2 = sub_80A7646(v1);
  result = dword_829F82C - dword_829F828 + sub_80A5458(0);
  *v2 = result;
  return result;
}

//----- (0809F056) --------------------------------------------------------
_DWORD *__cdecl sub_809F056(int a1, unsigned __int8 a2)
{
  _DWORD *result; // eax

  result = *a1;
  if ( *a1 == 19 )
    return sub_809E8A4(*(a1 + 4), *(a1 + 8), a2);
  if ( *a1 == 20 )
    result = sub_809EAE0(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), a2);
  return result;
}
// 809E8A4: using guessed type _DWORD __cdecl sub_809E8A4(_DWORD, _DWORD, _DWORD);

//----- (0809F0DC) --------------------------------------------------------
int __cdecl sub_809F0DC(int a1)
{
  int result; // eax

  result = *a1;
  if ( *a1 == 19 )
    return sub_809DE04(*(a1 + 4), *(a1 + 8));
  if ( *a1 == 20 )
    result = sub_809DE42(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
  return result;
}

//----- (0809F158) --------------------------------------------------------
void __cdecl sub_809F158(int a1)
{
  if ( *a1 == 19 )
  {
    sub_809E8A4(*(a1 + 4), *(a1 + 8), 0);
    sub_809DEB2(*(a1 + 12));
  }
  else if ( *a1 == 20 )
  {
    sub_809EAE0(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16), 0);
    sub_809DEB2(*(a1 + 20));
  }
}

//----- (0809F1FC) --------------------------------------------------------
_DWORD *__cdecl sub_809F1FC(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = sub_809E01E(a1);
  if ( result != 1 )
  {
    if ( result != 3 )
      sub_80A3D50(a2, "expression list must have 1 or 3 parameters");
    sub_809D436(0x55u, -2, 0);
    result = sub_809E09E(a1);
  }
  return result;
}
// 809E01E: using guessed type _DWORD __cdecl sub_809E01E(_DWORD);

//----- (0809F262) --------------------------------------------------------
int __cdecl sub_809F262(int *a1, int a2)
{
  _DWORD ***v3; // [esp+14h] [ebp-4h]

  v3 = sub_809E062(a1);
  if ( v3 )
    return sub_809F9B0(**v3, (*v3)[1]);
  if ( sub_809E01E(a1) != 3 )
    sub_80A3D50(a2, "not an array, string, or vector");
  sub_809D436(0x55u, -2, 0);
  sub_809E09E(a1);
  return sub_809D436(0x1Bu, -1, 0);
}

//----- (0809F30A) --------------------------------------------------------
int __cdecl sub_809F30A(int a1, int a2)
{
  _DWORD ***v3; // [esp+14h] [ebp-4h]

  v3 = sub_809E062(a1);
  if ( !v3 )
    sub_80A3D50(a2, "not an object");
  return sub_809FAA6(**v3, (*v3)[1]);
}

//----- (0809F364) --------------------------------------------------------
void __cdecl sub_809F364(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 5:
      sub_809D696(a1[1]);
      break;
    case 6:
      sub_809D6C6(a1[1]);
      break;
    case 7:
      sub_809D696(-a1[1]);
      break;
    case 8:
      sub_809D6C6(a1[1] ^ 0x80000000);
      break;
    case 9:
      sub_809D84E(*(a1 + 2));
      break;
    case 0xA:
      sub_809D89A(*(a1 + 2));
      break;
    case 0xD:
      sub_809DF82(a1[1]);
      break;
    case 0xE:
      sub_809E45A(a1[1], a1[2]);
      break;
    case 0xF:
      sub_809F056(a1[1], 0);
      break;
    case 0x1B:
      sub_809D672();
      break;
    case 0x1C:
      sub_809DA40();
      break;
    case 0x1D:
      sub_809DA64();
      break;
    case 0x1E:
      sub_809DA88();
      break;
    case 0x1F:
      sub_809DAAC();
      break;
    case 0x2A:
      sub_809F1FC(a1[1], a1[2]);
      break;
    case 0x34:
      sub_809DA06(a1[1], a1[2]);
      break;
    case 0x40:
      sub_809DC9E();
      break;
    case 0x41:
      sub_809DCC2(a1[1], a1[2]);
      break;
    case 0x45:
      sub_809D6F6();
      break;
    case 0x46:
      sub_809D726();
      break;
    case 0x47:
      sub_809D756(a1[1]);
      break;
    default:
      return;
  }
}
// 809DF82: using guessed type _DWORD __cdecl sub_809DF82(_DWORD);

//----- (0809F516) --------------------------------------------------------
int __cdecl sub_809F516(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+10h] [ebp-8h]

  sub_809F6C6(a1);
  sub_809D436(0x38u, -1, 0);
  sub_80A3226(a2);
  sub_809D512(0);
  v5 = dword_829F808;
  sub_809F6C6(a3);
  sub_809D8E6(a4);
  result = sub_80A5458(0) - v5 - 4;
  *v5 = result;
  return result;
}
// 809F6C6: using guessed type _DWORD __cdecl sub_809F6C6(_DWORD);
// 829F808: using guessed type int dword_829F808;

//----- (0809F596) --------------------------------------------------------
int __cdecl sub_809F596(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+10h] [ebp-8h]

  sub_809F6C6(a1);
  sub_809D436(0x37u, -1, 0);
  sub_80A3226(a2);
  sub_809D512(0);
  v5 = dword_829F808;
  sub_809F6C6(a3);
  sub_809D8E6(a4);
  result = sub_80A5458(0) - v5 - 4;
  *v5 = result;
  return result;
}
// 809F6C6: using guessed type _DWORD __cdecl sub_809F6C6(_DWORD);
// 829F808: using guessed type int dword_829F808;

//----- (0809F616) --------------------------------------------------------
void __cdecl sub_809F616(int a1, int a2, unsigned __int8 a3, int a4)
{
  sub_809F6C6(a1);
  sub_809F6C6(a2);
  sub_809D436(a3, -1, 0);
  sub_80A3226(a4);
}
// 809F6C6: using guessed type _DWORD __cdecl sub_809F6C6(_DWORD);

//----- (0809F65C) --------------------------------------------------------
void __cdecl sub_809F65C(int a1, _DWORD *a2, unsigned __int8 a3, int a4)
{
  byte_829F81C = 1;
  sub_809DF82(a1);
  byte_829F81C = 0;
  sub_809F6C6(a2);
  sub_809D436(a3, -1, 0);
  sub_80A3226(a4);
  sub_809F880(a1);
  sub_809D7A6(a4);
}
// 829F81C: using guessed type char byte_829F81C;

//----- (0809F6C6) --------------------------------------------------------
void __cdecl sub_809F6C6(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 4:
      sub_809F364(a1[1]);
      break;
    case 0x2B:
      sub_809F516(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2C:
      sub_809F596(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2D:
      sub_809F616(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2E:
      sub_809F6C6(a1[1]);
      sub_809D8E6(a1[2]);
      break;
    case 0x2F:
      sub_809F6C6(a1[1]);
      sub_809D916(a1[2]);
      break;
    case 0x30:
      sub_809F6C6(a1[1]);
      sub_809D946(a1[2]);
      break;
    case 0x31:
      sub_809F6C6(a1[1]);
      sub_809D976(a1[2]);
      break;
    case 0x32:
      sub_809F6C6(a1[1]);
      sub_809D9A6(a1[2]);
      break;
    case 0x33:
      sub_809F6C6(a1[1]);
      sub_809D9D6(a1[2]);
      break;
    default:
      return;
  }
}

//----- (0809F880) --------------------------------------------------------
void __cdecl sub_809F880(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *a1;
  if ( *a1 == 11 )
  {
    sub_809DF12(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809DD74(*(a1 + 4), *(a1 + 8), *(a1 + 12));
  }
  else if ( v1 == 3 )
  {
    sub_809DB6C(*(a1 + 4));
  }
}

//----- (0809F91C) --------------------------------------------------------
int __cdecl sub_809F91C(int *a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = *a1;
  if ( *a1 == 15 )
    return sub_809F0DC(a1[1]);
  if ( v3 > 15 )
  {
    if ( v3 == 30 )
    {
      result = sub_809DB9C();
    }
    else
    {
      if ( v3 != 42 )
        goto LABEL_11;
      result = sub_809F262(a1[1], a2);
    }
  }
  else
  {
    if ( v3 != 13 )
LABEL_11:
      sub_80A3D50(a2, "not an array, string, or vector");
    result = sub_809F880(a1[1]);
  }
  return result;
}
// 809F880: using guessed type _DWORD __cdecl sub_809F880(_DWORD);

//----- (0809F9B0) --------------------------------------------------------
int __cdecl sub_809F9B0(_DWORD *a1, int a2)
{
  if ( *a1 != 4 )
    sub_80A3D50(a2, "not an array, string, or vector");
  return sub_809F91C(a1[1], a1[2]);
}
// 809F91C: using guessed type _DWORD __cdecl sub_809F91C(_DWORD, _DWORD);

//----- (0809FA00) --------------------------------------------------------
void __cdecl sub_809FA00(_DWORD *a1, int a2)
{
  switch ( *a1 )
  {
    case 0xD:
      sub_809DF82(a1[1]);
      sub_809DEB2(a1[2]);
      break;
    case 0xF:
      sub_809F158(a1[1]);
      break;
    case 0x1C:
      sub_809DAD0();
      break;
    case 0x1D:
      sub_809DAF4();
      break;
    case 0x1F:
      sub_809DB18();
      break;
    case 0x2A:
      sub_809F30A(a1[1], a2);
      break;
    default:
      sub_80A3D50(a2, "not an object");
  }
}
// 809DF82: using guessed type _DWORD __cdecl sub_809DF82(_DWORD);

//----- (0809FAA6) --------------------------------------------------------
int __cdecl sub_809FAA6(_DWORD *a1, int a2)
{
  if ( *a1 != 4 )
    sub_80A3D50(a2, "not an object");
  return sub_809FA00(a1[1], a1[2]);
}
// 809FA00: using guessed type _DWORD __cdecl sub_809FA00(_DWORD, _DWORD);

//----- (0809FAF6) --------------------------------------------------------
int sub_809FAF6()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_80A5458(0);
  result = dword_80F5150;
  for ( i = dword_80F5150; i; i = result )
  {
    **i = v2 - *i;
    result = *(i + 4);
  }
  return result;
}
// 80F5150: using guessed type int dword_80F5150;

//----- (0809FB3A) --------------------------------------------------------
int sub_809FB3A()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  sub_809D4EE();
  v2 = sub_80A5458(0);
  result = dword_80F5158;
  for ( i = dword_80F5158; i; i = result )
  {
    **i = v2 - *i;
    result = *(i + 4);
  }
  return result;
}
// 80F5158: using guessed type int dword_80F5158;

//----- (0809FB82) --------------------------------------------------------
_BOOL4 __cdecl sub_809FB82(_DWORD *a1)
{
  return *a1 == 27;
}

//----- (0809FB94) --------------------------------------------------------
_BOOL4 __cdecl sub_809FB94(int a1)
{
  _BOOL4 v2; // [esp+4h] [ebp-4h]

  if ( *a1 == 4 )
    v2 = sub_809FB82(*(a1 + 4));
  else
    v2 = 0;
  return v2;
}

//----- (0809FBC6) --------------------------------------------------------
void __cdecl sub_809FBC6(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *a1;
  if ( *a1 == 11 )
  {
    sub_809DF4A(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809DDB6(*(a1 + 4), *(a1 + 8), *(a1 + 12), *(a1 + 16));
  }
  else if ( v1 == 3 )
  {
    sub_809DBC0(*(a1 + 4));
  }
}

//----- (0809FC72) --------------------------------------------------------
void __cdecl sub_809FC72(int a1, _DWORD *a2, int a3)
{
  if ( sub_809FB94(a2) )
  {
    sub_809FBC6(a1);
  }
  else
  {
    sub_809F6C6(a2);
    sub_809F880(a1);
    sub_809D7A6(a3);
  }
}

//----- (0809FCB8) --------------------------------------------------------
_DWORD *__cdecl sub_809FCB8(int a1)
{
  return sub_809F056(a1, 1u);
}

//----- (0809FCD4) --------------------------------------------------------
int __cdecl sub_809FCD4(_DWORD *a1)
{
  sub_809F6C6(a1);
  return sub_809D436(1u, -1, 0);
}

//----- (0809FD04) --------------------------------------------------------
int sub_809FD04()
{
  return sub_809D436(0, 0, 0);
}

//----- (0809FD28) --------------------------------------------------------
void __cdecl sub_809FD28(_DWORD *a1, int a2, int a3)
{
  if ( dword_829F820 )
    sub_80A3D50(a3, "wait not allowed in /# ... #/ comment");
  sub_809F6C6(a1);
  sub_809D436(0x23u, -1, 0);
  sub_80A3226(a3);
  sub_80A3226(a2);
}
// 829F820: using guessed type int dword_829F820;

//----- (0809FD8A) --------------------------------------------------------
int __cdecl sub_809FD8A(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int *v4; // [esp+10h] [ebp-8h]

  sub_809F6C6(a1);
  sub_809D436(0x35u, -1, 0);
  sub_80A3226(a3);
  sub_809D512(0);
  v4 = dword_829F808;
  sub_80A0D50(a2);
  sub_809D4EE();
  result = sub_80A5458(0) - v4 - 4;
  *v4 = result;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 829F808: using guessed type int dword_829F808;

//----- (0809FE04) --------------------------------------------------------
int __cdecl sub_809FE04(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  sub_809F6C6(a1);
  sub_809D436(0x35u, -1, 0);
  sub_80A3226(a4);
  sub_809D512(0);
  v6 = dword_829F808;
  sub_80A0D50(a2);
  sub_809D436(0x39u, 0, 0);
  sub_809D512(0);
  v5 = dword_829F808;
  *v6 = sub_80A5458(0) - v6 - 4;
  sub_80A0D50(a3);
  sub_809D4EE();
  result = sub_80A5458(0) - v5;
  *v5 = result;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 829F808: using guessed type int dword_829F808;

//----- (0809FECE) --------------------------------------------------------
int __cdecl sub_809FECE(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  char v7; // [esp+12h] [ebp-16h]
  char v8; // [esp+13h] [ebp-15h]
  int v9; // [esp+14h] [ebp-14h]
  char v10; // [esp+1Ah] [ebp-Eh]
  char v11; // [esp+1Bh] [ebp-Dh]
  _DWORD *v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]

  sub_809D4EE();
  v11 = byte_80F514C;
  v10 = byte_80F514D;
  v9 = dword_80F5150;
  byte_80F514C = 0;
  byte_80F514D = 0;
  v8 = byte_80F5154;
  v7 = byte_80F5155;
  v6 = dword_80F5158;
  byte_80F5154 = 0;
  byte_80F5155 = 0;
  v13 = sub_80A5458(0);
  sub_809F6C6(a1);
  sub_809D436(0x35u, -1, 0);
  sub_80A3226(a3);
  sub_809D512(0);
  v12 = dword_829F808;
  byte_80F514C = 1;
  byte_80F514D = dword_829F820 != 0;
  dword_80F5150 = 0;
  byte_80F5154 = 1;
  byte_80F5155 = dword_829F820 != 0;
  dword_80F5158 = 0;
  sub_80A0D50(a2);
  byte_80F514C = 0;
  byte_80F514D = 0;
  byte_80F5154 = 0;
  byte_80F5155 = 0;
  sub_809FB3A();
  sub_809D436(0x3Au, 0, 0);
  sub_80A3226(a4);
  v4 = sub_80A5458(0);
  sub_809D512(v13 - v4);
  *v12 = sub_80A5458(0) - v12 - 4;
  sub_809FAF6();
  byte_80F514C = v11;
  byte_80F514D = v10;
  dword_80F5150 = v9;
  byte_80F5154 = v8;
  byte_80F5155 = v7;
  result = v6;
  dword_80F5158 = v6;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 80F514C: using guessed type char byte_80F514C;
// 80F514D: using guessed type char byte_80F514D;
// 80F5150: using guessed type int dword_80F5150;
// 80F5154: using guessed type char byte_80F5154;
// 80F5155: using guessed type char byte_80F5155;
// 80F5158: using guessed type int dword_80F5158;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;

//----- (080A0088) --------------------------------------------------------
int __cdecl sub_80A0088(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // [esp+14h] [ebp-14h]
  char v7; // [esp+1Ah] [ebp-Eh]
  char v8; // [esp+1Bh] [ebp-Dh]
  int v9; // [esp+1Ch] [ebp-Ch]
  char v10; // [esp+22h] [ebp-6h]
  char v11; // [esp+23h] [ebp-5h]
  int v12; // [esp+24h] [ebp-4h]

  sub_809D4EE();
  v11 = byte_80F514C;
  v10 = byte_80F514D;
  v9 = dword_80F5150;
  v8 = byte_80F5154;
  v7 = byte_80F5155;
  v6 = dword_80F5158;
  byte_80F514C = 1;
  byte_80F514D = dword_829F820 != 0;
  dword_80F5150 = 0;
  byte_80F5154 = 1;
  byte_80F5155 = dword_829F820 != 0;
  dword_80F5158 = 0;
  v12 = sub_80A5458(0);
  sub_80A0D50(a1);
  byte_80F514C = 0;
  byte_80F514D = 0;
  byte_80F5154 = 0;
  byte_80F5155 = 0;
  sub_809FB3A();
  sub_809F6C6(a2);
  sub_809D436(0x36u, -1, 0);
  sub_80A3226(a4);
  sub_80A3226(a3);
  v4 = sub_80A5458(0);
  sub_809D512(v12 - v4);
  sub_809FAF6();
  byte_80F514C = v11;
  byte_80F514D = v10;
  dword_80F5150 = v9;
  byte_80F5154 = v8;
  byte_80F5155 = v7;
  result = v6;
  dword_80F5158 = v6;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 80F514C: using guessed type char byte_80F514C;
// 80F514D: using guessed type char byte_80F514D;
// 80F5150: using guessed type int dword_80F5150;
// 80F5154: using guessed type char byte_80F5154;
// 80F5155: using guessed type char byte_80F5155;
// 80F5158: using guessed type int dword_80F5158;
// 829F820: using guessed type int dword_829F820;

//----- (080A01DA) --------------------------------------------------------
int __cdecl sub_80A01DA(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int result; // eax
  int v8; // [esp+Ch] [ebp-1Ch]
  char v9; // [esp+12h] [ebp-16h]
  char v10; // [esp+13h] [ebp-15h]
  int v11; // [esp+14h] [ebp-14h]
  char v12; // [esp+1Ah] [ebp-Eh]
  char v13; // [esp+1Bh] [ebp-Dh]
  _DWORD *v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]

  v13 = byte_80F514C;
  v12 = byte_80F514D;
  v11 = dword_80F5150;
  byte_80F514C = 0;
  byte_80F514D = 0;
  v10 = byte_80F5154;
  v9 = byte_80F5155;
  v8 = dword_80F5158;
  byte_80F5154 = 0;
  byte_80F5155 = 0;
  sub_80A0D50(a1);
  sub_809D4EE();
  v15 = sub_80A5458(0);
  if ( *a2 == 63 )
  {
    sub_809F6C6(*(a2 + 4));
    sub_809D436(0x35u, -1, 0);
    sub_80A3226(a5);
    sub_809D512(0);
    v14 = dword_829F808;
  }
  else
  {
    v14 = 0;
  }
  byte_80F514C = 1;
  byte_80F514D = dword_829F820 != 0;
  dword_80F5150 = 0;
  byte_80F5154 = 1;
  byte_80F5155 = dword_829F820 != 0;
  dword_80F5158 = 0;
  sub_80A0D50(a4);
  byte_80F514C = 0;
  byte_80F514D = 0;
  byte_80F5154 = 0;
  byte_80F5155 = 0;
  sub_809FB3A();
  sub_80A0D50(a3);
  sub_809D436(0x3Au, 0, 0);
  sub_80A3226(a6);
  v6 = sub_80A5458(0);
  sub_809D512(v15 - v6);
  if ( v14 )
    *v14 = sub_80A5458(0) - v14 - 4;
  sub_809FAF6();
  byte_80F514C = v13;
  byte_80F514D = v12;
  dword_80F5150 = v11;
  byte_80F5154 = v10;
  byte_80F5155 = v9;
  result = v8;
  dword_80F5158 = v8;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 80F514C: using guessed type char byte_80F514C;
// 80F514D: using guessed type char byte_80F514D;
// 80F5150: using guessed type int dword_80F5150;
// 80F5154: using guessed type char byte_80F5154;
// 80F5155: using guessed type char byte_80F5155;
// 80F5158: using guessed type int dword_80F5158;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;

//----- (080A03C6) --------------------------------------------------------
void __cdecl sub_80A03C6(int a1, int a2)
{
  sub_809F880(a1);
  sub_809D436(0x3Bu, 1, 0);
  sub_80A3226(a2);
  sub_809D7A6(a2);
}

//----- (080A040C) --------------------------------------------------------
void __cdecl sub_80A040C(int a1, int a2)
{
  sub_809F880(a1);
  sub_809D436(0x3Cu, 1, 0);
  sub_80A3226(a2);
  sub_809D7A6(a2);
}

//----- (080A0452) --------------------------------------------------------
int __cdecl sub_80A0452(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = *(a1 + 4);
    a1 = result;
    if ( !result )
      break;
    sub_809D7D6(**result, *(*result + 4));
  }
  return result;
}

//----- (080A048E) --------------------------------------------------------
int __cdecl sub_80A048E(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = *(a1 + 4);
    a1 = result;
    if ( !result )
      break;
    sub_809D812(**result, *(*result + 4));
  }
  return result;
}

//----- (080A04CA) --------------------------------------------------------
int __cdecl sub_80A04CA(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD ***v5; // [esp+14h] [ebp-4h]

  if ( dword_829F820 )
    sub_80A3D50(a4, "waittill not allowed in developer script");
  v5 = *(*a2 + 4);
  sub_809F6C6(**v5);
  sub_809F364(a1);
  sub_809D436(0x4Fu, -2, 0);
  sub_80A3226(a4);
  sub_80A3226((*v5)[1]);
  sub_80A3226(a3);
  sub_80A048E(v5);
  return sub_809D436(0x1Eu, 0, 0);
}
// 829F820: using guessed type int dword_829F820;

//----- (080A0580) --------------------------------------------------------
int __cdecl sub_80A0580(_DWORD *a1, int a2, int a3, int a4)
{
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]
  int v7; // [esp+14h] [ebp-4h]

  if ( dword_829F820 )
    sub_80A3D50(a4, "waittillmatch not allowed in developer script");
  v6 = *(*a2 + 4);
  for ( i = 0; ; ++i )
  {
    v6 = *(v6 + 4);
    if ( !v6 )
      break;
    sub_809F6C6(**v6);
  }
  v7 = *(*a2 + 4);
  sub_809F6C6(**v7);
  sub_809F364(a1);
  sub_809D436(0x4Eu, -2 - i, 0);
  sub_80A3226(a4);
  sub_80A3226(*(*v7 + 4));
  sub_80A3226(a3);
  while ( 1 )
  {
    v7 = *(v7 + 4);
    if ( !v7 )
      break;
    sub_80A3226(*(*v7 + 4));
  }
  sub_809D564(i);
  return sub_809D436(0x1Eu, 0, 0);
}
// 829F820: using guessed type int dword_829F820;

//----- (080A06A0) --------------------------------------------------------
void __cdecl sub_80A06A0(_DWORD *a1, int *a2, int a3, int a4)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_809D436(0x52u, 1, 0);
  v4 = 0;
  v6 = 0;
  for ( i = *a2; i; i = *(i + 4) )
  {
    v6 = i;
    sub_809F6C6(**i);
    ++v4;
  }
  sub_809F364(a1);
  sub_809D436(0x50u, -v4 - 2, 0);
  sub_80A3226(a4);
  sub_80A3226(*(*v6 + 4));
  sub_80A3226(a3);
}

//----- (080A075C) --------------------------------------------------------
void __cdecl sub_80A075C(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  sub_809F6C6(a2);
  sub_809F364(a1);
  sub_809D436(0x51u, -2, 0);
  sub_80A3226(a4);
  sub_80A3226(a3);
}

//----- (080A07AC) --------------------------------------------------------
int __cdecl sub_80A07AC(const void *a1, const void *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  if ( *a1 <= *a2 )
    v3 = *a1 < *a2;
  else
    v3 = -1;
  return v3;
}

//----- (080A07E8) --------------------------------------------------------
int __cdecl sub_80A07E8(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int nmemb; // [esp+18h] [ebp-20h]
  char *base; // [esp+1Ch] [ebp-1Ch]
  char *v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  char v8; // [esp+2Ah] [ebp-Eh]
  char v9; // [esp+2Bh] [ebp-Dh]
  int *v10; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  char v13; // [esp+36h] [ebp-2h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = byte_80F515C;
  v13 = byte_80F515D;
  v12 = dword_80F5160;
  byte_80F515C = 0;
  byte_80F515D = 0;
  v9 = byte_80F514C;
  v8 = byte_80F514D;
  v7 = dword_80F5150;
  byte_80F514C = 0;
  byte_80F514D = 0;
  sub_809F6C6(a1);
  sub_809D436(0x53u, -1, 0);
  sub_809D512(0);
  v6 = dword_829F808;
  byte_80F515C = 1;
  byte_80F515D = dword_829F820 != 0;
  dword_80F5160 = 0;
  byte_80F514C = 1;
  byte_80F514D = dword_829F820 != 0;
  dword_80F5150 = 0;
  sub_80A0D50(a2);
  byte_80F515C = 0;
  byte_80F515D = 0;
  byte_80F514C = 0;
  byte_80F514D = 0;
  sub_809D436(0x54u, 0, 0);
  sub_80A3226(a3);
  sub_809D536(0);
  base = sub_80A5458(0);
  *v6 = base - v6;
  nmemb = 0;
  v10 = dword_80F5160;
  while ( v10 )
  {
    sub_809D512(*v10);
    sub_809D606(v10[1]);
    v10 = v10[3];
    ++nmemb;
  }
  *(base - 1) = nmemb;
  qsort(base, nmemb, 8u, sub_80A07AC);
  while ( nmemb > 1 )
  {
    if ( *base == *(base + 2) )
    {
      for ( i = dword_80F5160; i; i = i[3] )
      {
        if ( *i == *base )
          sub_80A3D50(i[2], "duplicate case expression");
      }
    }
    --nmemb;
    base += 8;
  }
  sub_809FAF6();
  byte_80F515C = v14;
  byte_80F515D = v13;
  dword_80F5160 = v12;
  byte_80F514C = v9;
  byte_80F514D = v8;
  result = v7;
  dword_80F5150 = v7;
  return result;
}
// 80A0D50: using guessed type _DWORD __cdecl sub_80A0D50(_DWORD);
// 80F514C: using guessed type char byte_80F514C;
// 80F514D: using guessed type char byte_80F514D;
// 80F5150: using guessed type int dword_80F5150;
// 80F515C: using guessed type char byte_80F515C;
// 80F515D: using guessed type char byte_80F515D;
// 80F5160: using guessed type int dword_80F5160;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;

//----- (080A0A40) --------------------------------------------------------
void __cdecl sub_80A0A40(int a1, int a2)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  if ( dword_829F820 != 2 )
  {
    v2 = sub_806C4B7(16);
    *v2 = a1;
    v2[1] = sub_80A5458(0);
    if ( dword_829F820 == 1 )
      v2[1] += dword_829F82C - dword_829F828;
    v2[2] = a2;
    v2[3] = dword_80F5160;
    dword_80F5160 = v2;
  }
}
// 80F5160: using guessed type int dword_80F5160;
// 829F820: using guessed type int dword_829F820;

//----- (080A0AC0) --------------------------------------------------------
void __cdecl sub_80A0AC0(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  if ( *a1 == 5 )
  {
    if ( !sub_80A6DF2(a1[1]) )
    {
      v2 = sub_8086D78("case index %d out of range", a1[1]);
      sub_80A3D50(a2, v2);
    }
    v3 = sub_80A6E18(a1[1]);
  }
  else
  {
    if ( *a1 != 9 )
      sub_80A3D50(a2, "case expression must be an int or string");
    v3 = *(a1 + 2);
    sub_809D3E0(*(a1 + 2), 1u);
  }
  if ( !byte_80F515C )
    sub_80A3D50(a2, "illegal case statement");
  if ( !byte_80F515D && dword_829F820 )
    sub_80A3D50(a2, "cannot use /# ... #/ comments directly around a case statement");
  sub_80A0A40(v3, a2);
}
// 80F515C: using guessed type char byte_80F515C;
// 80F515D: using guessed type char byte_80F515D;
// 829F820: using guessed type int dword_829F820;

//----- (080A0BD2) --------------------------------------------------------
void __cdecl sub_80A0BD2(int a1)
{
  if ( !byte_80F515C )
    sub_80A3D50(a1, "illegal default statement");
  sub_80A0A40(0, a1);
}
// 80F515C: using guessed type char byte_80F515C;

//----- (080A0C0C) --------------------------------------------------------
_DWORD *__cdecl sub_80A0C0C(int a1)
{
  _DWORD *result; // eax

  if ( !byte_80F514C )
    sub_80A3D50(a1, "illegal break statement");
  if ( !byte_80F514D && dword_829F820 )
    sub_80A3D50(a1, "cannot use /# ... #/ comments directly around a break statement");
  sub_809D436(0x39u, 0, 0);
  sub_809D512(0);
  result = sub_806C4B7(8);
  *result = dword_829F808;
  result[1] = dword_80F5150;
  dword_80F5150 = result;
  return result;
}
// 80F514C: using guessed type char byte_80F514C;
// 80F514D: using guessed type char byte_80F514D;
// 80F5150: using guessed type int dword_80F5150;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;

//----- (080A0CAE) --------------------------------------------------------
_DWORD *__cdecl sub_80A0CAE(int a1)
{
  _DWORD *result; // eax

  if ( !byte_80F5154 )
    sub_80A3D50(a1, "illegal continue statement");
  if ( !byte_80F5155 && dword_829F820 )
    sub_80A3D50(a1, "cannot use /# ... #/ comments directly around a continue statement");
  sub_809D436(0x39u, 0, 0);
  sub_809D512(0);
  result = sub_806C4B7(8);
  *result = dword_829F808;
  result[1] = dword_80F5158;
  dword_80F5158 = result;
  return result;
}
// 80F5154: using guessed type char byte_80F5154;
// 80F5155: using guessed type char byte_80F5155;
// 80F5158: using guessed type int dword_80F5158;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;

//----- (080A0D50) --------------------------------------------------------
void __cdecl sub_80A0D50(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 2:
      sub_809FC72(a1[1], a1[2], a1[3]);
      break;
    case 0x15:
      sub_809FCB8(a1[1]);
      break;
    case 0x17:
      sub_809FCD4(a1[1]);
      break;
    case 0x18:
      sub_809FD04();
      break;
    case 0x19:
      sub_809FD28(a1[1], a1[2], a1[3]);
      break;
    case 0x20:
      sub_809FD8A(a1[1], a1[2], a1[3]);
      break;
    case 0x21:
      sub_809FE04(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x22:
      sub_809FECE(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x23:
      sub_80A0088(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x24:
      sub_80A01DA(a1[1], a1[2], a1[3], a1[4], a1[5], a1[6]);
      break;
    case 0x25:
      sub_80A03C6(a1[1], a1[2]);
      break;
    case 0x26:
      sub_80A040C(a1[1], a1[2]);
      break;
    case 0x27:
      sub_809F65C(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x28:
      sub_80A1140(a1[1]);
      break;
    case 0x29:
      sub_80A12FE(a1[1], a1[2]);
      break;
    case 0x36:
      sub_80A04CA(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x37:
      sub_80A0580(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x38:
      sub_80A06A0(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x39:
      sub_80A075C(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x3A:
      sub_80A07E8(a1[1], a1[2], a1[3]);
      break;
    case 0x3B:
      sub_80A0AC0(a1[1], a1[2]);
      break;
    case 0x3C:
      sub_80A0BD2(a1[1]);
      break;
    case 0x3D:
      sub_80A0C0C(a1[1]);
      break;
    case 0x3E:
      sub_80A0CAE(a1[1]);
      break;
    default:
      return;
  }
}
// 80A1140: using guessed type _DWORD __cdecl sub_80A1140(_DWORD);

//----- (080A1140) --------------------------------------------------------
int __cdecl sub_80A1140(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = *(*a1 + 4);
  for ( i = result; i; i = result )
  {
    sub_80A0D50(*i);
    result = *(i + 4);
  }
  return result;
}

//----- (080A1178) --------------------------------------------------------
int sub_80A1178()
{
  int result; // eax
  int n; // [esp+14h] [ebp-4h]

  n = sub_80A5458(0) - dword_829F828;
  if ( n + dword_829F82C - dword_80F513C > 0x100000 )
    sub_80704AC(1, "max developer script size exceeded - increase DEV_OP_BUF_SIZE");
  sub_80C835C(dword_829F82C, dword_829F828, n);
  result = n;
  dword_829F82C = dword_829F82C + n;
  return result;
}

//----- (080A11EC) --------------------------------------------------------
int sub_80A11EC()
{
  int v1; // [esp+18h] [ebp-10h]
  int v2; // [esp+1Ch] [ebp-Ch]
  char *dest; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v2 = dword_80F51A4;
  sub_809D436(88, 0, 0);
  dword_80F51A4 = v2;
  v4 = dword_829F828 - dword_80F5164;
  if ( dword_829F828 - dword_80F5164 >= dword_80F5140 )
  {
    v1 = 2 * dword_80F5140;
    if ( 2 * dword_80F5140 <= v4 )
      v1 = 2 * v4;
    dest = sub_806BB38(4 * v1);
    sub_80C835C(dest, dword_80F5144, 4 * dword_80F5140);
    sub_80C837D(&dest[4 * dword_80F5140], 0, 4 * (v1 - dword_80F5140));
    dword_80F5140 = v1;
    sub_806BB25(dword_80F5144);
    dword_80F5144 = dest;
  }
  *(dword_80F5144 + v4) = dword_829F82C;
  sub_80A1178();
  return sub_80A548C(dword_829F828);
}
// 809D436: using guessed type _DWORD __cdecl sub_809D436(_DWORD, _DWORD, _DWORD);
// 80F5140: using guessed type int dword_80F5140;
// 80F5164: using guessed type int dword_80F5164;
// 80F51A4: using guessed type int dword_80F51A4;

//----- (080A12FE) --------------------------------------------------------
int __cdecl sub_80A12FE(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( dword_829F820 )
    sub_80A3D50(a2, "cannot recurse /#");
  v4 = dword_80F51A4;
  if ( dword_829FA04 )
  {
    if ( !byte_829F824 )
    {
      sub_809D436(0x57u, 0, 0);
      dword_829F828 = dword_829F808;
    }
    dword_829F820 = 1;
    sub_80A1140(a1);
    byte_829F824 = 1;
  }
  else
  {
    v3 = sub_80A5458(0);
    dword_829F820 = 2;
    sub_80A1140(a1);
    sub_80A548C(v3);
  }
  dword_829F820 = 0;
  result = v4;
  dword_80F51A4 = v4;
  return result;
}
// 80A1140: using guessed type _DWORD __cdecl sub_80A1140(_DWORD);
// 80F51A4: using guessed type int dword_80F51A4;
// 829F808: using guessed type int dword_829F808;
// 829F820: using guessed type int dword_829F820;
// 829F824: using guessed type char byte_829F824;
// 829FA04: using guessed type int dword_829FA04;

//----- (080A13C2) --------------------------------------------------------
void sub_80A13C2()
{
  if ( dword_829FA04 )
  {
    dword_80F513C = sub_806BB38(0x100000u);
    dword_80F5140 = 0x10000;
    dword_80F5144 = sub_806BB38(0x40000u);
    sub_80C837D(dword_80F5144, 0, 0x40000u);
    dword_829F82C = dword_80F513C;
    sub_80C837D(&dword_8433EC0, 0, 0x80u);
    dword_80F5148 = 0;
  }
}
// 80F5140: using guessed type int dword_80F5140;
// 829FA04: using guessed type int dword_829FA04;
// 8433EC0: using guessed type int dword_8433EC0;

//----- (080A144E) --------------------------------------------------------
void sub_80A144E()
{
  void *v0; // [esp+Ch] [ebp-Ch]
  _BYTE *v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_829FA04 )
  {
    for ( i = 0; i < dword_80F5140; ++i )
    {
      v1 = *(dword_80F5144 + i);
      if ( v1 )
      {
        *v1 = *(dword_80F5164 + i);
        *(dword_80F5164 + i) = 87;
      }
    }
    while ( dword_80F5148 )
    {
      if ( **dword_80F5148 )
        **dword_80F5148 = sub_80A2150(**dword_80F5148);
      v0 = *(dword_80F5148 + 1);
      sub_806BB25(dword_80F5148);
      dword_80F5148 = v0;
    }
  }
}
// 80F5140: using guessed type int dword_80F5140;
// 80F5164: using guessed type int dword_80F5164;
// 829FA04: using guessed type int dword_829FA04;

//----- (080A1512) --------------------------------------------------------
void sub_80A1512()
{
  if ( dword_829FA04 )
  {
    if ( dword_80F513C )
    {
      sub_806BB25(dword_80F513C);
      dword_80F513C = 0;
    }
    if ( dword_80F5144 )
    {
      sub_806BB25(dword_80F5144);
      dword_80F5144 = 0;
    }
  }
}
// 829FA04: using guessed type int dword_829FA04;

//----- (080A1566) --------------------------------------------------------
void __cdecl sub_80A1566(int *a1, int a2)
{
  sub_80A0452(*a1);
  sub_809D436(0x1Fu, 0, 0);
  sub_80A3226(a2);
}

//----- (080A15A2) --------------------------------------------------------
int __cdecl sub_80A15A2(int a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax

  result = *a1;
  if ( *a1 == 66 )
  {
    v2 = sub_80A71D8(word_829F80C, *(a1 + 4));
    v3 = sub_80A7ACA(v2);
    result = sub_809EEC4(v3, *(a1 + 16));
  }
  else if ( *a1 == 67 )
  {
    v4 = sub_80A71D8(word_829F80C, *(a1 + 4));
    v5 = sub_80A7ACA(v4);
    result = sub_809EF3A(v5, *(a1 + 16));
  }
  return result;
}
// 829F80C: using guessed type __int16 word_829F80C;

//----- (080A163E) --------------------------------------------------------
int __cdecl sub_80A163E(int a1, int a2)
{
  int result; // eax

  sub_80A3226(a2);
  dword_829F810 = 0;
  dword_829F814 = 0;
  dword_829F818 = 0;
  sub_809D3E0(*(a1 + 4), 2u);
  sub_80A1566(*(a1 + 8), a2);
  sub_80A1140(*(a1 + 12));
  sub_809D436(0, 0, 0);
  result = dword_829F814 + 32 * dword_829F818;
  if ( result > 2047 )
    sub_80A3D50(a2, "function exceeds operand stack size");
  return result;
}
// 829F810: using guessed type int dword_829F810;
// 829F814: using guessed type int dword_829F814;
// 829F818: using guessed type int dword_829F818;

//----- (080A16F4) --------------------------------------------------------
int __cdecl sub_80A16F4(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax

  v2 = sub_80A6E88(word_829F80C, *(a1 + 4));
  v3 = sub_80A7B82(v2);
  sub_809EFBC(v3);
  return sub_80A163E(a1, a2);
}
// 829F80C: using guessed type __int16 word_829F80C;

//----- (080A174C) --------------------------------------------------------
int __cdecl sub_80A174C(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int result; // eax
  int v5; // [esp+14h] [ebp-4h]

  if ( dword_829F820 )
    sub_80A3D50(a2, "cannot recurse /#");
  dword_829F828 = sub_80A5458(0);
  v5 = dword_80F51A4;
  if ( dword_829FA04 )
  {
    dword_829F820 = 1;
    v2 = sub_80A6E88(word_829F80C, *(a1 + 4));
    v3 = sub_80A7B82(v2);
    sub_809F000(v3);
    sub_80A163E(a1, a2);
    sub_80A1178();
  }
  else
  {
    dword_829F820 = 2;
    sub_80A163E(a1, a2);
  }
  dword_829F820 = 0;
  sub_80A548C(dword_829F828);
  result = v5;
  dword_80F51A4 = v5;
  return result;
}
// 80F51A4: using guessed type int dword_80F51A4;
// 829F80C: using guessed type __int16 word_829F80C;
// 829F820: using guessed type int dword_829F820;
// 829FA04: using guessed type int dword_829FA04;

//----- (080A182E) --------------------------------------------------------
int __cdecl sub_80A182E(int a1, int a2)
{
  int result; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  result = *a1;
  v4 = *a1;
  if ( *a1 == 67 )
    return sub_80A174C(a1, a2);
  if ( v4 > 67 )
  {
    if ( v4 == 68 )
    {
      v3 = sub_80A4458(*(a1 + 4));
      sub_809CDE8(v3, *(a1 + 8));
      result = sub_809D2F8(*(a1 + 4));
    }
  }
  else if ( v4 == 66 )
  {
    result = sub_80A16F4(a1, a2);
  }
  return result;
}

//----- (080A18BA) --------------------------------------------------------
int __cdecl sub_80A18BA(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(*a1 + 4); i; i = *(i + 4) )
    sub_80A15A2(**i);
  result = *(*a1 + 4);
  for ( j = result; j; j = result )
  {
    sub_80A182E(**j, *(*j + 4));
    result = *(j + 4);
  }
  return result;
}

//----- (080A1932) --------------------------------------------------------
int __cdecl sub_80A1932(int a1, __int16 a2)
{
  void *v2; // esp
  int result; // eax
  int v4; // eax
  const char *v5; // eax
  int v6; // [esp+Ch] [ebp-1Ch] BYREF
  int *v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  __int16 v11; // [esp+26h] [ebp-2h]

  v11 = a2;
  word_829F80C = a2;
  dword_829F808 = sub_80A5458(0);
  byte_829F81C = 0;
  dword_829F1EC = 0;
  dword_829F820 = 0;
  byte_829F824 = 0;
  if ( dword_829FA0C )
  {
    v2 = alloca(16 * ((8 * dword_829FA0C + 15) >> 4));
    v7 = &v6;
  }
  else
  {
    v7 = 0;
  }
  v10 = v7;
  dword_829F830 = v7;
  sub_809D436(0, 0, 0);
  sub_80A18BA(*(a1 + 4));
  dword_80F516C = sub_80A5458(0) - dword_80F5164;
  sub_809ED4A();
  sub_806C5F1();
  sub_806C522();
  v8 = dword_829FA0C;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v4 = sub_80A4458(v10[2 * i]);
    if ( !sub_80A229A(v4) )
    {
      v5 = sub_80A4458(v10[2 * i]);
      sub_80A3D50(v10[2 * i + 1], "Could not find script '%s'", v5);
    }
    sub_80A509E(v10[2 * i]);
  }
  return result;
}
// 80A229A: using guessed type _DWORD __cdecl sub_80A229A(_DWORD);
// 80F5164: using guessed type int dword_80F5164;
// 80F516C: using guessed type int dword_80F516C;
// 829F1EC: using guessed type int dword_829F1EC;
// 829F808: using guessed type int dword_829F808;
// 829F80C: using guessed type __int16 word_829F80C;
// 829F81C: using guessed type char byte_829F81C;
// 829F820: using guessed type int dword_829F820;
// 829F824: using guessed type char byte_829F824;
// 829F830: using guessed type int dword_829F830;
// 829FA0C: using guessed type int dword_829FA0C;

//----- (080A1AAC) --------------------------------------------------------
int __cdecl sub_80A1AAC(int a1, int a2)
{
  return dword_829F9D8(a1, a2);
}
// 829F9D8: using guessed type int (__cdecl *dword_829F9D8)(_DWORD, _DWORD);

//----- (080A1AC8) --------------------------------------------------------
int __cdecl sub_80A1AC8(int a1, int a2)
{
  return dword_829F9DC(a1, a2);
}
// 829F9DC: using guessed type int (__cdecl *dword_829F9DC)(_DWORD, _DWORD);

//----- (080A1AE4) --------------------------------------------------------
int __cdecl sub_80A1AE4(int a1, int a2, int a3)
{
  return dword_829F9E0(a1, a2, a3);
}
// 829F9E0: using guessed type int (__cdecl *dword_829F9E0)(_DWORD, _DWORD, _DWORD);

//----- (080A1B07) --------------------------------------------------------
int __cdecl sub_80A1B07(int a1, int a2, int a3)
{
  return dword_829F9E4(a1, a2, a3);
}
// 829F9E4: using guessed type int (__cdecl *dword_829F9E4)(_DWORD, _DWORD, _DWORD);

//----- (080A1B2A) --------------------------------------------------------
int __cdecl sub_80A1B2A(int a1)
{
  return dword_829F9E8(a1);
}
// 829F9E8: using guessed type int (__cdecl *dword_829F9E8)(_DWORD);

//----- (080A1B3F) --------------------------------------------------------
int *__cdecl sub_80A1B3F(int a1)
{
  if ( a1 )
  {
    dword_829F9D8 = *a1;
    dword_829F9DC = *(a1 + 4);
    dword_829F9E0 = *(a1 + 8);
    dword_829F9E4 = *(a1 + 12);
    dword_829F9E8 = *(a1 + 16);
  }
  dword_829F840 = sub_80AF5F0;
  dword_829F844 = sub_80AF6C6;
  dword_829F848 = sub_80AF762;
  dword_829F84C = sub_80AF91C;
  dword_829F850 = sub_80AFA72;
  dword_829F854 = sub_80AFBAA;
  dword_829F858 = sub_80AFB0C;
  dword_829F85C = sub_80AFBEE;
  dword_829F860 = sub_80AFE0E;
  dword_829F864 = sub_80AFD70;
  dword_829F868 = sub_80AFE52;
  dword_829F86C = sub_80AFF2C;
  dword_829F878 = sub_80AFFD4;
  dword_829F870 = sub_80B00D0;
  dword_829F874 = sub_80B0142;
  dword_829F87C = sub_80B01F8;
  dword_829F880 = sub_80B0202;
  dword_829F884 = sub_80B0226;
  dword_829F888 = sub_80B024A;
  dword_829F88C = sub_80B026E;
  dword_829F890 = sub_80B0292;
  dword_829F894 = sub_80B02E6;
  dword_829F898 = sub_80B030C;
  dword_829F89C = sub_80B0336;
  dword_829F8A0 = sub_80B0370;
  dword_829F8A4 = sub_80B03AA;
  dword_829F8A8 = sub_80B03E4;
  dword_829F8AC = sub_80B02AC;
  dword_829F8B8 = sub_80B0416;
  dword_829F8B0 = sub_80B0442;
  dword_829F8B4 = sub_80B0498;
  dword_829F8F4 = sub_80B04E8;
  dword_829F8F8 = sub_80B051E;
  dword_829F8FC = sub_80B05A0;
  dword_829F900 = sub_80B05DC;
  dword_829F904 = sub_80B06B4;
  dword_829F908 = sub_80A7D30;
  dword_829F90C = sub_80A80E8;
  dword_829F910 = sub_80A7E1A;
  dword_829F914 = sub_80A7EA4;
  dword_829F920 = sub_80A7EFE;
  dword_829F924 = sub_80AA49A;
  dword_829F928 = sub_80AA19A;
  dword_829F92C = sub_80A800C;
  dword_829F930 = sub_80A8D5A;
  dword_829F934 = sub_80AA818;
  dword_829F938 = sub_80AA872;
  dword_829F93C = sub_80AA88A;
  dword_829F940 = sub_80AA8A0;
  dword_829F944 = sub_80AF442;
  dword_829F948 = sub_80AA678;
  dword_829F94C = sub_80AA6FA;
  dword_829F950 = sub_80A3540;
  dword_829F954 = sub_80A354A;
  dword_829F958 = sub_80A360A;
  dword_829F95C = sub_80A370C;
  dword_829F960 = sub_80A9D06;
  dword_829F964 = sub_80A9EE0;
  dword_829F968 = sub_80A9FC0;
  dword_829F970 = sub_80A9FCE;
  dword_829F974 = sub_80AA144;
  dword_829F97C = sub_80A229A;
  dword_829F980 = sub_809D1DE;
  dword_829F984 = sub_809D290;
  dword_829F988 = sub_80A2032;
  dword_829F8E8 = sub_80AF1F2;
  dword_829F8EC = sub_80AF270;
  dword_829F8F0 = sub_80A7BF8;
  dword_829F8BC = sub_80A21EC;
  dword_829F8C0 = sub_80A2254;
  dword_829F8C4 = sub_80A242E;
  dword_829F8C8 = sub_80A24DE;
  dword_829F8CC = sub_80A24A2;
  dword_829F8D0 = sub_80A254A;
  dword_829F8D4 = sub_80AA6A6;
  dword_829F8D8 = sub_80AF484;
  dword_829F8DC = sub_80AF5D4;
  dword_829F8E0 = sub_80AF2FC;
  dword_829F8E4 = sub_80AF356;
  dword_829F98C = sub_80AF3BE;
  dword_829F990 = sub_80A9120;
  dword_829F994 = sub_80A9162;
  dword_829F998 = sub_80A5152;
  dword_829F99C = sub_80A5196;
  dword_829F9A0 = sub_80AEBB6;
  dword_829F9A4 = sub_80AEAEA;
  dword_829F9A8 = sub_80A4458;
  dword_829F9AC = sub_80A4D9A;
  dword_829F9B0 = sub_80A4E80;
  dword_829F9B4 = sub_80A480E;
  dword_829F9B8 = sub_80A53FC;
  dword_829F9BC = sub_80B0718;
  dword_829F9C0 = sub_80B0760;
  dword_829F9C4 = sub_80B076E;
  dword_829F9C8 = sub_809C80A;
  dword_829F9CC = sub_809C85E;
  dword_829F9D0 = sub_80A2F68;
  dword_829F9D4 = sub_80A2F8E;
  return &dword_829F840;
}
// 829F840: using guessed type int dword_829F840;
// 829F844: using guessed type int dword_829F844;
// 829F848: using guessed type int dword_829F848;
// 829F84C: using guessed type int dword_829F84C;
// 829F850: using guessed type int dword_829F850;
// 829F854: using guessed type int dword_829F854;
// 829F858: using guessed type int dword_829F858;
// 829F85C: using guessed type int dword_829F85C;
// 829F860: using guessed type int dword_829F860;
// 829F864: using guessed type int dword_829F864;
// 829F868: using guessed type int dword_829F868;
// 829F86C: using guessed type int dword_829F86C;
// 829F870: using guessed type int dword_829F870;
// 829F874: using guessed type int dword_829F874;
// 829F878: using guessed type int dword_829F878;
// 829F87C: using guessed type int dword_829F87C;
// 829F880: using guessed type int dword_829F880;
// 829F884: using guessed type int dword_829F884;
// 829F888: using guessed type int dword_829F888;
// 829F88C: using guessed type int dword_829F88C;
// 829F890: using guessed type int dword_829F890;
// 829F894: using guessed type int dword_829F894;
// 829F898: using guessed type int dword_829F898;
// 829F89C: using guessed type int dword_829F89C;
// 829F8A0: using guessed type int dword_829F8A0;
// 829F8A4: using guessed type int dword_829F8A4;
// 829F8A8: using guessed type int dword_829F8A8;
// 829F8AC: using guessed type int dword_829F8AC;
// 829F8B0: using guessed type int dword_829F8B0;
// 829F8B4: using guessed type int dword_829F8B4;
// 829F8B8: using guessed type int dword_829F8B8;
// 829F8BC: using guessed type int dword_829F8BC;
// 829F8C0: using guessed type int dword_829F8C0;
// 829F8C4: using guessed type int dword_829F8C4;
// 829F8C8: using guessed type int dword_829F8C8;
// 829F8CC: using guessed type int dword_829F8CC;
// 829F8D0: using guessed type int dword_829F8D0;
// 829F8D4: using guessed type int dword_829F8D4;
// 829F8D8: using guessed type int dword_829F8D8;
// 829F8DC: using guessed type int dword_829F8DC;
// 829F8E0: using guessed type int dword_829F8E0;
// 829F8E4: using guessed type int dword_829F8E4;
// 829F8E8: using guessed type int dword_829F8E8;
// 829F8EC: using guessed type int dword_829F8EC;
// 829F8F0: using guessed type int dword_829F8F0;
// 829F8F4: using guessed type int dword_829F8F4;
// 829F8F8: using guessed type int dword_829F8F8;
// 829F8FC: using guessed type int dword_829F8FC;
// 829F900: using guessed type int dword_829F900;
// 829F904: using guessed type int dword_829F904;
// 829F908: using guessed type int dword_829F908;
// 829F90C: using guessed type int dword_829F90C;
// 829F910: using guessed type int dword_829F910;
// 829F914: using guessed type int dword_829F914;
// 829F920: using guessed type int dword_829F920;
// 829F924: using guessed type int dword_829F924;
// 829F928: using guessed type int dword_829F928;
// 829F92C: using guessed type int dword_829F92C;
// 829F930: using guessed type int dword_829F930;
// 829F934: using guessed type int dword_829F934;
// 829F938: using guessed type int dword_829F938;
// 829F93C: using guessed type int dword_829F93C;
// 829F940: using guessed type int dword_829F940;
// 829F944: using guessed type int dword_829F944;
// 829F948: using guessed type int dword_829F948;
// 829F94C: using guessed type int dword_829F94C;
// 829F950: using guessed type int dword_829F950;
// 829F954: using guessed type int dword_829F954;
// 829F958: using guessed type int dword_829F958;
// 829F95C: using guessed type int dword_829F95C;
// 829F960: using guessed type int dword_829F960;
// 829F964: using guessed type int dword_829F964;
// 829F968: using guessed type int dword_829F968;
// 829F970: using guessed type int dword_829F970;
// 829F974: using guessed type int dword_829F974;
// 829F97C: using guessed type int dword_829F97C;
// 829F980: using guessed type int dword_829F980;
// 829F984: using guessed type int dword_829F984;
// 829F988: using guessed type int dword_829F988;
// 829F98C: using guessed type int dword_829F98C;
// 829F990: using guessed type int dword_829F990;
// 829F994: using guessed type int dword_829F994;
// 829F998: using guessed type int dword_829F998;
// 829F99C: using guessed type int dword_829F99C;
// 829F9A0: using guessed type int dword_829F9A0;
// 829F9A4: using guessed type int dword_829F9A4;
// 829F9A8: using guessed type int dword_829F9A8;
// 829F9AC: using guessed type int dword_829F9AC;
// 829F9B0: using guessed type int dword_829F9B0;
// 829F9B4: using guessed type int dword_829F9B4;
// 829F9B8: using guessed type int dword_829F9B8;
// 829F9BC: using guessed type int dword_829F9BC;
// 829F9C0: using guessed type int dword_829F9C0;
// 829F9C4: using guessed type int dword_829F9C4;
// 829F9C8: using guessed type int dword_829F9C8;
// 829F9CC: using guessed type int dword_829F9CC;
// 829F9D0: using guessed type int dword_829F9D0;
// 829F9D4: using guessed type int dword_829F9D4;
// 829F9D8: using guessed type int (__cdecl *dword_829F9D8)(_DWORD, _DWORD);
// 829F9DC: using guessed type int (__cdecl *dword_829F9DC)(_DWORD, _DWORD);
// 829F9E0: using guessed type int (__cdecl *dword_829F9E0)(_DWORD, _DWORD, _DWORD);
// 829F9E4: using guessed type int (__cdecl *dword_829F9E4)(_DWORD, _DWORD, _DWORD);
// 829F9E8: using guessed type int (__cdecl *dword_829F9E8)(_DWORD);

//----- (080A1F50) --------------------------------------------------------
int __cdecl sub_80A1F50(unsigned int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 >= dword_80F5164 && a1 < dword_80F5164 + dword_80F516C )
    v2 = 1;
  return v2;
}
// 80F5164: using guessed type int dword_80F5164;
// 80F516C: using guessed type int dword_80F516C;

//----- (080A1F84) --------------------------------------------------------
int __cdecl sub_80A1F84(unsigned int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 >= dword_80F513C && a1 < dword_829F82C )
    v2 = 1;
  return v2;
}

//----- (080A1FE4) --------------------------------------------------------
int __cdecl sub_80A1FE4(_BYTE *a1)
{
  while ( *a1 )
  {
    if ( (*(_ctype_b + 2 * *a1) & 8) == 0 && *a1 != 95 )
      return 0;
    ++a1;
  }
  return 1;
}
// 80FE1E8: using guessed type int _ctype_b;

//----- (080A2032) --------------------------------------------------------
int __cdecl sub_80A2032(int a1, char *s)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  unsigned __int16 v9; // [esp+26h] [ebp-2h]

  v5 = sub_80A53FC(a1);
  v9 = sub_80A6E88(word_829F9EE, v5);
  sub_80A509E(v5);
  if ( !v9 )
    return 0;
  v7 = sub_80A7B82(v9);
  v6 = sub_80A480E(s);
  if ( !v6 )
    return 0;
  v8 = sub_80A6E88(v7, v6);
  if ( !v8 )
    return 0;
  v4 = *sub_80A7646(v8);
  if ( sub_80A1F50(v4) )
    v3 = v4 - dword_80F5164;
  else
    v3 = 0;
  return v3;
}
// 80F5164: using guessed type int dword_80F5164;
// 829F9EE: using guessed type __int16 word_829F9EE;

//----- (080A211A) --------------------------------------------------------
void *sub_80A211A()
{
  void *result; // eax

  sub_806C267();
  result = sub_806C3D4(0x20000u);
  dword_829F9F8 = result;
  word_829F9FC = 0;
  return result;
}
// 829F9F8: using guessed type int dword_829F9F8;
// 829F9FC: using guessed type __int16 word_829F9FC;

//----- (080A2142) --------------------------------------------------------
_DWORD *sub_80A2142()
{
  return sub_806C2B1();
}

//----- (080A2150) --------------------------------------------------------
int __cdecl sub_80A2150(unsigned __int16 a1)
{
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  sub_80A4EAC(a1, 2u);
  v3 = *(dword_829F9F8 + 2 * a1);
  if ( v3 )
    return v3;
  *(dword_829F9F8 + 2 * a1) = ++word_829F9FC;
  return word_829F9FC;
}
// 829F9F8: using guessed type int dword_829F9F8;
// 829F9FC: using guessed type __int16 word_829F9FC;

//----- (080A21CA) --------------------------------------------------------
int __cdecl sub_80A21CA(char *s)
{
  return *(dword_829F9F8 + 2 * sub_80A47E8(s));
}
// 829F9F8: using guessed type int dword_829F9F8;

//----- (080A21EC) --------------------------------------------------------
int sub_80A21EC()
{
  byte_829F9EC = 1;
  sub_80A2FE4();
  sub_80A13C2();
  word_829F9EE = sub_80A6AAC();
  word_829F9F0 = sub_80A6AAC();
  dword_80F5164 = sub_806C531(0);
  dword_80F516C = 0;
  dword_80F5168 = 0;
  sub_80A211A();
  dword_842FDF8 = 0;
  return sub_80A2254();
}
// 80F5164: using guessed type int dword_80F5164;
// 80F5168: using guessed type int dword_80F5168;
// 80F516C: using guessed type int dword_80F516C;
// 829F9EC: using guessed type char byte_829F9EC;
// 829F9EE: using guessed type __int16 word_829F9EE;
// 829F9F0: using guessed type __int16 word_829F9F0;
// 842FDF8: using guessed type int dword_842FDF8;

//----- (080A2254) --------------------------------------------------------
int sub_80A2254()
{
  int result; // eax

  byte_829F9ED = 1;
  dword_829F800[dword_8456180] = 0;
  dword_829F200[128 * dword_8456180] = 0;
  result = sub_80A6AAC();
  word_829F9F2 = result;
  word_829F1E0 = 0;
  return result;
}
// 829F1E0: using guessed type __int16 word_829F1E0;
// 829F800: using guessed type int dword_829F800[];
// 829F9ED: using guessed type char byte_829F9ED;
// 829F9F2: using guessed type __int16 word_829F9F2;
// 8456180: using guessed type int dword_8456180;

//----- (080A229A) --------------------------------------------------------
_BOOL4 __cdecl sub_80A229A(char *a1)
{
  const char *v1; // eax
  void *v2; // eax
  unsigned __int16 v3; // ax
  __int16 v4; // ax
  _BOOL4 v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  char dest[70]; // [esp+20h] [ebp-58h] BYREF
  unsigned __int16 v10; // [esp+66h] [ebp-12h]
  int v11; // [esp+68h] [ebp-10h] BYREF
  int v12; // [esp+6Ch] [ebp-Ch]

  v10 = sub_80A53FC(a1);
  if ( sub_80A6E88(word_829F9F0, v10) )
  {
    sub_80A509E(v10);
    v6 = sub_80A6E88(word_829F9EE, v10) != 0;
  }
  else
  {
    sub_80A71D8(word_829F9F0, v10);
    sub_80A509E(v10);
    sub_80A5448();
    v1 = sub_80A4458(v10);
    strncpy(dest, v1, 0x40u);
    strncat(dest, ".gsc", 0x40u);
    v7 = *dword_80F5174;
    v2 = sub_806C531(0);
    v12 = sub_80A3806(dest, v2, dword_829F82C);
    if ( v12 )
    {
      word_829F9F4 = 0;
      dword_829FA0C = 0;
      v8 = *dword_80F5178;
      *dword_80F5178 = dest;
      sub_80B284E(v12, &v11);
      v3 = sub_80A71D8(word_829F9EE, v10);
      v4 = sub_80A7ACA(v3);
      sub_80A1932(v11, v4);
      *dword_80F5178 = v8;
      *dword_80F5174 = v7;
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  return v6;
}
// 829F9EE: using guessed type __int16 word_829F9EE;
// 829F9F0: using guessed type __int16 word_829F9F0;
// 829F9F4: using guessed type __int16 word_829F9F4;
// 829FA0C: using guessed type int dword_829FA0C;

//----- (080A242E) --------------------------------------------------------
unsigned int *sub_80A242E()
{
  byte_829F9EC = 0;
  sub_80A2142();
  sub_80A64B0(word_829F9F0);
  sub_80A6C02(word_829F9F0);
  word_829F9F0 = 0;
  sub_80A64B0(word_829F9EE);
  sub_80A6C02(word_829F9EE);
  word_829F9EE = 0;
  sub_80A144E();
  return sub_80A52AC(2);
}
// 829F9EC: using guessed type char byte_829F9EC;
// 829F9EE: using guessed type __int16 word_829F9EE;
// 829F9F0: using guessed type __int16 word_829F9F0;

//----- (080A24A2) --------------------------------------------------------
int __cdecl sub_80A24A2(int (__cdecl *a1)(int))
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_829F800[dword_8456180] )
      break;
    sub_809CEFC(i, a1);
  }
  return result;
}
// 829F800: using guessed type int dword_829F800[];
// 8456180: using guessed type int dword_8456180;

//----- (080A24DE) --------------------------------------------------------
void *sub_80A24DE()
{
  void *result; // eax

  byte_829F9ED = 0;
  sub_80A64B0(word_829F9F2);
  sub_80A6C02(word_829F9F2);
  word_829F9F2 = 0;
  if ( word_829F1E0 )
    sub_80A6C02(word_829F1E0);
  sub_80A52AC(2);
  result = sub_806C531(0);
  dword_80F5168 = result;
  return result;
}
// 80F5168: using guessed type int dword_80F5168;
// 829F1E0: using guessed type __int16 word_829F1E0;
// 829F9ED: using guessed type char byte_829F9ED;
// 829F9F2: using guessed type __int16 word_829F9F2;

//----- (080A254A) --------------------------------------------------------
void sub_80A254A()
{
  if ( byte_829F9EC )
    sub_80A242E();
  if ( byte_829F9ED )
    sub_80A24DE();
  dword_80F5164 = 0;
  dword_80F516C = 0;
  dword_80F5168 = 0;
  dword_80F51A4 = 0;
  byte_829F9EC = 0;
  sub_80A52AC(1);
  sub_80A30EA();
  sub_80A1512();
}
// 80F5164: using guessed type int dword_80F5164;
// 80F5168: using guessed type int dword_80F5168;
// 80F516C: using guessed type int dword_80F516C;
// 80F51A4: using guessed type int dword_80F51A4;
// 829F9EC: using guessed type char byte_829F9EC;
// 829F9ED: using guessed type char byte_829F9ED;

//----- (080A25BC) --------------------------------------------------------
int __cdecl sub_80A25BC(int a1)
{
  int v1; // ebx

  if ( !a1 )
    return 0;
  v1 = sub_80A25BC(LOWORD(dword_829FA20[2 * a1]));
  return sub_80A25BC(HIWORD(dword_829FA20[2 * a1])) + v1 + 1;
}
// 829FA20: using guessed type int dword_829FA20[];

//----- (080A2614) --------------------------------------------------------
int sub_80A2614()
{
  char v1; // [esp+4h] [ebp-24h]
  char v2; // [esp+4h] [ebp-24h]
  char v3; // [esp+4h] [ebp-24h]
  char v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+24h] [ebp-4h]

  Com_Printf("********************************\n", v1);
  v5 = *dword_831FD84;
  for ( i = 0; i <= 16; ++i )
  {
    v5 += sub_80A25BC(word_831FA40[i]) << i;
    Com_Printf("%d subtree has %d * %d = %d free buckets\n", i);
  }
  Com_Printf("********************************\n", v2);
  Com_Printf("********************************\n", v3);
  Com_Printf("total memory alloc buckets: %d (%d instances)\n", dword_831FD84[0]);
  Com_Printf("total memory free buckets: %d\n", -1 - dword_831FD84[0]);
  return Com_Printf("********************************\n", v4);
}
// 80A2621: variable 'v1' is possibly undefined
// 80A26A5: variable 'v2' is possibly undefined
// 80A26B1: variable 'v3' is possibly undefined
// 80A26F6: variable 'v4' is possibly undefined

//----- (080A2708) --------------------------------------------------------
int *sub_80A2708()
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int l; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char k; // [esp+4h] [ebp-8h]
  char v5; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h] BYREF

  for ( i = 0; i <= 255; ++i )
  {
    v3 = 0;
    for ( j = i; j; j >>= 1 )
    {
      if ( (j & 1) != 0 )
        ++v3;
    }
    *(i + 137493376) = v3;
    for ( k = 8; (i & ((1 << k) - 1)) != 0; --k )
      ;
    *(i + 137493120) = k;
    v5 = 0;
    for ( l = i; l; l >>= 1 )
      ++v5;
    *(i + 137493632) = v5;
    result = &i;
  }
  return result;
}

//----- (080A27CA) --------------------------------------------------------
int __cdecl sub_80A27CA(int a1)
{
  char v2; // [esp+8h] [ebp-8h]
  int v3; // [esp+18h] [ebp+8h]

  v3 = 0x10000 - a1;
  v2 = byte_831FA80[v3];
  if ( !v3 )
    v2 += byte_831FA80[BYTE1(v3)];
  return v3 - (byte_831FA80[BYTE1(v3) + 256] + byte_831FA80[v3 + 256]) + (1 << v2);
}

//----- (080A283E) --------------------------------------------------------
int __cdecl sub_80A283E(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = &word_831FA40[a2];
  v8 = *v7;
  if ( *v7 )
  {
    v6 = sub_80A27CA(a1);
    v5 = 0;
    v4 = 0x10000;
    while ( sub_80A27CA(v8) >= v6 )
    {
      v4 >>= 1;
      if ( a1 >= v5 )
      {
        v7 = (8 * v8 + 136968738);
        v5 += v4;
      }
      else
      {
        v7 = &dword_829FA20[2 * v8];
        v5 -= v4;
      }
      v8 = *v7;
      if ( !*v7 )
        goto LABEL_13;
    }
    while ( 1 )
    {
      *v7 = a1;
      v2 = dword_829FA24[2 * v8];
      result = dword_829FA20[2 * v8];
      dword_829FA20[2 * a1] = result;
      dword_829FA24[2 * a1] = v2;
      if ( !v8 )
        break;
      v4 >>= 1;
      if ( v8 >= v5 )
      {
        v7 = (8 * a1 + 136968738);
        v5 += v4;
      }
      else
      {
        v7 = &dword_829FA20[2 * a1];
        v5 -= v4;
      }
      a1 = v8;
      v8 = *v7;
    }
  }
  else
  {
LABEL_13:
    *v7 = a1;
    LOWORD(dword_829FA20[2 * a1]) = 0;
    result = a1;
    HIWORD(dword_829FA20[2 * a1]) = 0;
  }
  return result;
}
// 829FA20: using guessed type int dword_829FA20[];

//----- (080A29A2) --------------------------------------------------------
int __cdecl sub_80A29A2(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int *v11; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int v13; // [esp+40h] [ebp+8h]

  v9 = 0;
  v8 = 0x10000;
  v11 = &word_831FA40[a2];
  for ( i = *v11; ; i = *v11 )
  {
    if ( !i )
      return 0;
    if ( a1 == i )
      break;
    if ( a1 == v9 )
      return 0;
    v8 >>= 1;
    if ( a1 >= v9 )
    {
      v11 = (8 * i + 136968738);
      v9 += v8;
    }
    else
    {
      v11 = &dword_829FA20[2 * i];
      v9 -= v8;
    }
  }
  v6 = dword_829FA20[2 * a1];
  v7 = dword_829FA24[2 * a1];
  while ( v6 )
  {
    if ( HIWORD(v6) )
    {
      v10 = sub_80A27CA(v6);
      if ( v10 >= sub_80A27CA(HIWORD(v6)) )
      {
        v13 = v6;
        *v11 = v6;
        v11 = &dword_829FA20[2 * v6];
      }
      else
      {
        v13 = HIWORD(v6);
        *v11 = HIWORD(v6);
        v11 = (8 * HIWORD(v6) + 136968738);
      }
    }
    else
    {
      v13 = v6;
      *v11 = v6;
      v11 = &dword_829FA20[2 * v6];
    }
LABEL_14:
    v4 = v6;
    v5 = v7;
    v6 = dword_829FA20[2 * v13];
    v7 = dword_829FA24[2 * v13];
    dword_829FA20[2 * v13] = v4;
    dword_829FA24[2 * v13] = v5;
  }
  v13 = HIWORD(v6);
  *v11 = HIWORD(v6);
  if ( HIWORD(v6) )
  {
    v11 = (8 * HIWORD(v6) + 136968738);
    goto LABEL_14;
  }
  return 1;
}
// 829FA20: using guessed type int dword_829FA20[];

//----- (080A2B7C) --------------------------------------------------------
int __cdecl sub_80A2B7C(int a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+24h] [ebp-4h]

  v7 = &word_831FA40[a1];
  v8 = *v7;
  v4 = dword_829FA20[2 * v8];
  v5 = dword_829FA24[2 * v8];
  while ( v4 )
  {
    if ( HIWORD(v4) )
    {
      v6 = sub_80A27CA(v4);
      if ( v6 >= sub_80A27CA(HIWORD(v4)) )
      {
        v9 = v4;
        *v7 = v4;
        v7 = &dword_829FA20[2 * v4];
      }
      else
      {
        v9 = HIWORD(v4);
        *v7 = HIWORD(v4);
        v7 = (8 * HIWORD(v4) + 136968738);
      }
    }
    else
    {
      v9 = v4;
      *v7 = v4;
      v7 = &dword_829FA20[2 * v4];
    }
LABEL_10:
    v2 = v4;
    v3 = v5;
    v4 = dword_829FA20[2 * v9];
    v5 = dword_829FA24[2 * v9];
    dword_829FA20[2 * v9] = v2;
    dword_829FA24[2 * v9] = v3;
  }
  v9 = HIWORD(v4);
  result = HIWORD(v4);
  *v7 = HIWORD(v4);
  if ( HIWORD(v4) )
  {
    v7 = (8 * HIWORD(v4) + 136968738);
    goto LABEL_10;
  }
  return result;
}
// 829FA20: using guessed type int dword_829FA20[];

//----- (080A2CC4) --------------------------------------------------------
int *sub_80A2CC4()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  dword_831FA20 = dword_829FA20;
  sub_80A2708();
  for ( i = 0; i <= 16; ++i )
    word_831FA40[i] = 0;
  dword_829FA20[0] = 0;
  dword_831FA24 = &dword_831FA20;
  result = &dword_831FA20;
  dword_831FA28 = &dword_831FA20;
  dword_831FA2C = 0;
  for ( i = 0; i <= 15; ++i )
  {
    sub_80A283E(1 << i, i);
    result = &i;
  }
  dword_831FD80 = 0;
  *dword_831FD84 = 0;
  return result;
}
// 829FA20: using guessed type int dword_829FA20[];
// 831FA20: using guessed type int dword_831FA20;
// 831FA24: using guessed type int dword_831FA24;
// 831FA28: using guessed type int dword_831FA28;
// 831FA2C: using guessed type int dword_831FA2C;
// 831FD80: using guessed type int dword_831FD80;

//----- (080A2D72) --------------------------------------------------------
void __cdecl __noreturn sub_80A2D72(const char *a1, int a2)
{
  char *v2; // eax

  sub_80A2614();
  v2 = sub_8086D78("%s: failed allocation of %d bytes for script usage", a1, a2);
  sub_80B055C(v2);
}

//----- (080A2DA2) --------------------------------------------------------
int __cdecl sub_80A2DA2(int a1)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+14h] [ebp-4h]

  if ( a1 > 0xFFFF )
    sub_80A2D72("MT_GetSize: max allocation exceeded", a1);
  v3 = (a1 + 7) / 8 - 1;
  if ( v3 > 255 )
    v2 = byte_831FC80[v3 >> 8] + 8;
  else
    v2 = byte_831FC80[(a1 + 7) / 8 - 1];
  return v2;
}

//----- (080A2E22) --------------------------------------------------------
int __cdecl sub_80A2E22(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = sub_80A2DA2(a1);
  for ( i = v3; ; ++i )
  {
    if ( i > 16 )
      sub_80A2D72("MT_AllocIndex", a1);
    v4 = word_831FA40[i];
    if ( word_831FA40[i] )
      break;
  }
  sub_80A2B7C(i);
  while ( i != v3 )
  {
    --i;
    sub_80A283E(v4 + (1 << i), i);
  }
  ++dword_831FD80;
  *dword_831FD84 += 1 << v3;
  return v4;
}
// 831FD80: using guessed type int dword_831FD80;

//----- (080A2EDA) --------------------------------------------------------
int __cdecl sub_80A2EDA(unsigned __int16 a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v3 = sub_80A2DA2(a2);
  --dword_831FD80;
  *dword_831FD84 -= 1 << v3;
  while ( 1 )
  {
    v4 = 1 << v3;
    if ( v3 == 16 || !sub_80A29A2(v4 ^ a1, v3) )
      break;
    a1 &= ~v4;
    ++v3;
  }
  return sub_80A283E(a1, v3);
}
// 831FD80: using guessed type int dword_831FD80;

//----- (080A2F68) --------------------------------------------------------
int __cdecl sub_80A2F68(int a1)
{
  return 8 * sub_80A2E22(a1) + 136968736;
}

//----- (080A2F8E) --------------------------------------------------------
int __cdecl sub_80A2F8E(int a1, int a2)
{
  return sub_80A2EDA((a1 - dword_829FA20) >> 3, a2);
}
// 829FA20: using guessed type int dword_829FA20[];

//----- (080A2FB4) --------------------------------------------------------
_BOOL4 __cdecl sub_80A2FB4(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = sub_80A2DA2(a1);
  return v3 == sub_80A2DA2(a2);
}

//----- (080A2FE4) --------------------------------------------------------
void sub_80A2FE4()
{
  int i; // [esp+10h] [ebp-8h]

  if ( dword_829FA00 )
  {
    for ( i = 0; i <= 1; ++i )
    {
      dword_831FD94[i] = 0x10000;
      dword_831FD9C[i] = 0;
      *(&dword_831FD8C + i) = sub_806BB38(16 * dword_831FD94[i]);
      memset(*(&dword_831FD8C + i), 0, 16 * dword_831FD94[i]);
    }
    dword_831FDA4 = 0x10000;
    dword_831FDA8 = 0;
    dword_80F5170 = sub_806BB38(0x40000u);
    dword_831FDB4 = 0;
    dword_831FDB8 = 0;
    dword_831FDAC = 16;
    dword_831FDB0 = 0;
    dword_80F517C = sub_806BB38(0x140u);
  }
}
// 829FA00: using guessed type int dword_829FA00;
// 831FD94: using guessed type int dword_831FD94[];
// 831FD9C: using guessed type int dword_831FD9C[];
// 831FDA4: using guessed type int dword_831FDA4;
// 831FDA8: using guessed type int dword_831FDA8;
// 831FDAC: using guessed type int dword_831FDAC;
// 831FDB0: using guessed type int dword_831FDB0;
// 831FDB4: using guessed type int dword_831FDB4;
// 831FDB8: using guessed type int dword_831FDB8;

//----- (080A30EA) --------------------------------------------------------
void sub_80A30EA()
{
  int i; // [esp+4h] [ebp-4h]
  unsigned int j; // [esp+4h] [ebp-4h]
  int k; // [esp+4h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    if ( *(&dword_831FD8C + i) )
    {
      sub_806BB25(*(&dword_831FD8C + i));
      *(&dword_831FD8C + i) = 0;
    }
  }
  if ( dword_80F5170 )
  {
    sub_806BB25(dword_80F5170);
    dword_80F5170 = 0;
  }
  if ( dword_80F517C )
  {
    for ( j = 0; j < dword_831FDB0; ++j )
      sub_806BB25(*(dword_80F517C + 5 * j + 2));
    sub_806BB25(dword_80F517C);
    dword_80F517C = 0;
  }
  if ( dword_80F5180 )
  {
    for ( k = 0; k < dword_80F5184; ++k )
    {
      if ( *(dword_80F5180 + 2 * k) )
        sub_806BB25(*(dword_80F5180 + 2 * k));
    }
    sub_806BB25(dword_80F5180);
    dword_80F5184 = -1;
    dword_80F5180 = 0;
  }
}
// 80F5184: using guessed type int dword_80F5184;
// 831FDB0: using guessed type int dword_831FDB0;

//----- (080A3226) --------------------------------------------------------
void __cdecl sub_80A3226(int a1)
{
  _BOOL4 v1; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]
  void *s; // [esp+20h] [ebp-8h]

  if ( dword_829FA00 && dword_829F820 != 2 )
  {
    v1 = dword_829F820 == 1;
    if ( dword_831FD9C[v1] >= dword_831FD94[v1] )
    {
      dword_831FD94[v1] *= 2;
      s = sub_806BB38(16 * dword_831FD94[v1]);
      memset(s, 0, 16 * dword_831FD94[v1]);
      sub_80C835C(s, *(&dword_831FD8C + v1), 16 * dword_831FD9C[v1]);
      sub_806BB25(*(&dword_831FD8C + v1));
      *(&dword_831FD8C + v1) = s;
    }
    if ( dword_831FDA8 >= dword_831FDA4 )
    {
      dword_831FDA4 *= 2;
      dest = sub_806BB38(4 * dword_831FDA4);
      sub_80C835C(dest, dword_80F5170, 4 * dword_831FDA8);
      sub_806BB25(dword_80F5170);
      dword_80F5170 = dest;
    }
    if ( dword_831FD88 == dword_831FDB4 )
    {
      --dword_831FD9C[v1];
    }
    else
    {
      dword_831FDB8 = 0;
      dword_831FDB4 = dword_831FD88;
      *(*(&dword_831FD8C + v1) + 4 * dword_831FD9C[v1] + 1) = dword_831FDA8;
    }
    if ( dword_829F820 == 1 )
      *(dword_831FD90 + 16 * dword_831FDA0) = dword_831FDB4 + dword_829F82C - dword_829F828;
    else
      *(dword_831FD8C + 4 * dword_831FD9C[0]) = dword_831FDB4;
    *(dword_80F5170 + *(*(&dword_831FD8C + v1) + 4 * dword_831FD9C[v1]++ + 1) + dword_831FDB8++) = a1;
    ++dword_831FDA8;
  }
}
// 829F820: using guessed type int dword_829F820;
// 829FA00: using guessed type int dword_829FA00;
// 831FD88: using guessed type int dword_831FD88;
// 831FD90: using guessed type int dword_831FD90;
// 831FD94: using guessed type int dword_831FD94[];
// 831FD9C: using guessed type int dword_831FD9C[];
// 831FDA0: using guessed type int dword_831FDA0;
// 831FDA4: using guessed type int dword_831FDA4;
// 831FDA8: using guessed type int dword_831FDA8;
// 831FDB4: using guessed type int dword_831FDB4;
// 831FDB8: using guessed type int dword_831FDB8;

//----- (080A3458) --------------------------------------------------------
int __cdecl sub_80A3458(unsigned int a1, int a2)
{
  _BOOL4 v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v4 = sub_80A1F50(a1) == 0;
  v7 = 0;
  v6 = dword_831FD9C[v4] - 1;
  while ( v7 <= v6 )
  {
    v5 = (v6 + v7) / 2;
    if ( a1 <= *(*(&dword_831FD8C + v4) + 4 * v5) )
    {
      v6 = v5 - 1;
    }
    else
    {
      v7 = v5 + 1;
      if ( v5 + 1 == dword_831FD9C[v4] || a1 <= *(*(&dword_831FD8C + v4) + 4 * v7) )
        return *(dword_80F5170 + *(*(&dword_831FD8C + v4) + 4 * v5 + 1) + a2);
    }
  }
  return 0;
}
// 831FD9C: using guessed type int dword_831FD9C[];

//----- (080A3540) --------------------------------------------------------
int sub_80A3540()
{
  return dword_829FA00;
}
// 829FA00: using guessed type int dword_829FA00;

//----- (080A354A) --------------------------------------------------------
unsigned int __cdecl sub_80A354A(void (__cdecl *a1)(int *, int))
{
  unsigned int result; // eax
  unsigned int i; // [esp+14h] [ebp-4h]

  a1(&dword_831FDB0, 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_831FDB0 )
      break;
    a1(dword_80F517C + 5 * i + 4, 4);
    if ( *(dword_80F517C + 5 * i + 4) > 0 )
      a1(*(dword_80F517C + 5 * i + 3), *(dword_80F517C + 5 * i + 4));
  }
  return result;
}
// 831FDB0: using guessed type int dword_831FDB0;

//----- (080A360A) --------------------------------------------------------
int *__cdecl sub_80A360A(void (__cdecl *a1)(int *, int))
{
  int *result; // eax
  int v2; // ebx
  char *v3; // esi
  int i; // [esp+Ch] [ebp-Ch] BYREF

  a1(&dword_80F5184, 4);
  dword_80F5180 = sub_806BB38(8 * dword_80F5184);
  result = (dword_80F5184 - 1);
  for ( i = dword_80F5184 - 1; i >= 0; --i )
  {
    a1(dword_80F5180 + 2 * i + 1, 4);
    if ( *(dword_80F5180 + 2 * i + 1) <= 0 )
    {
      *(dword_80F5180 + 2 * i) = 0;
    }
    else
    {
      v2 = 8 * i;
      v3 = dword_80F5180;
      *&v3[v2] = sub_806BB38(*(dword_80F5180 + 2 * i + 1));
      a1(*(dword_80F5180 + 2 * i), *(dword_80F5180 + 2 * i + 1));
    }
    result = &i;
  }
  return result;
}
// 80F5184: using guessed type int dword_80F5184;

//----- (080A370C) --------------------------------------------------------
int *__cdecl sub_80A370C(void (__cdecl *a1)(int *, int))
{
  int *result; // eax
  int v2; // [esp+Ch] [ebp-Ch] BYREF
  int v3; // [esp+10h] [ebp-8h] BYREF
  int i; // [esp+14h] [ebp-4h] BYREF

  a1(&v2, 4);
  result = (v2 - 1);
  for ( i = v2 - 1; i >= 0; --i )
  {
    a1(&v3, 4);
    if ( v3 > 0 )
      a1(0, v3);
    result = &i;
  }
  return result;
}

//----- (080A376A) --------------------------------------------------------
char *sub_80A376A()
{
  void *dest; // [esp+14h] [ebp-4h]

  if ( dword_831FDB0 >= dword_831FDAC )
  {
    dword_831FDAC *= 2;
    dest = sub_806BB38(20 * dword_831FDAC);
    sub_80C835C(dest, dword_80F517C, 20 * dword_831FDB0);
    sub_806BB25(dword_80F517C);
    dword_80F517C = dest;
  }
  return dword_80F517C + 20 * dword_831FDB0++;
}
// 831FDAC: using guessed type int dword_831FDAC;
// 831FDB0: using guessed type int dword_831FDB0;

//----- (080A3806) --------------------------------------------------------
int __cdecl sub_80A3806(char *s, int a2, int a3)
{
  char *v3; // eax
  char v5; // [esp+17h] [ebp-41h]
  char v6; // [esp+1Fh] [ebp-39h]
  int v7; // [esp+24h] [ebp-34h]
  char *v8; // [esp+28h] [ebp-30h]
  char *v9; // [esp+2Ch] [ebp-2Ch]
  char *v10; // [esp+2Ch] [ebp-2Ch]
  signed int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h] BYREF
  char *v13; // [esp+38h] [ebp-20h]
  char v14; // [esp+3Fh] [ebp-19h]
  int i; // [esp+40h] [ebp-18h]
  char *v16; // [esp+44h] [ebp-14h]
  char *v17; // [esp+48h] [ebp-10h]
  size_t size; // [esp+4Ch] [ebp-Ch]
  size_t v19; // [esp+50h] [ebp-8h]
  char *dest; // [esp+54h] [ebp-4h]

  if ( dword_80F5180 )
  {
    --dword_80F5184;
    v11 = *(dword_80F5180 + 2 * dword_80F5184 + 1);
    if ( v11 >= 0 )
    {
      v13 = sub_806C4B7(v11 + 1);
      v9 = *(dword_80F5180 + 2 * dword_80F5184);
      v17 = v13;
      for ( i = 0; i < v11; ++i )
      {
        v14 = *v9++;
        v6 = v14;
        if ( !v14 )
          v6 = 10;
        *v17++ = v6;
      }
      *v17 = 0;
      if ( *(dword_80F5180 + 2 * dword_80F5184) )
        sub_806BB25(*(dword_80F5180 + 2 * dword_80F5184));
      goto LABEL_12;
    }
  }
  else
  {
    v11 = sub_8065D85(s, &v12, 0);
    if ( v11 >= 0 )
    {
      v13 = sub_806C4B7(v11 + 1);
      sub_8062853(v13, v11, v12);
      v13[v11] = 0;
      FS_FCloseFile(v12);
LABEL_12:
      if ( dword_80F517C )
      {
        v19 = strlen(s) + 1;
        size = v19 + v11 + 2;
        dest = sub_806BB38(size);
        strcpy(dest, s);
        v16 = &dest[v19];
        v10 = v13;
        v17 = &dest[v19];
        for ( i = 0; i <= v11; ++i )
        {
          v14 = *v10++;
          if ( v14 == 10 )
            v5 = 0;
          else
            v5 = v14;
          *v17++ = v5;
        }
        v3 = sub_80A376A();
        *v3 = a2;
        *(v3 + 1) = a3;
        *(v3 + 2) = dest;
        *(v3 + 3) = v16;
        *(v3 + 4) = v11;
        *dword_80F5174 = v16;
        v7 = v13;
      }
      else
      {
        *dword_80F5174 = 0;
        v7 = v13;
      }
      return v7;
    }
  }
  if ( dword_80F517C )
  {
    v8 = sub_80A376A();
    *v8 = 0;
    *(v8 + 1) = 0;
    *(v8 + 2) = 0;
    *(v8 + 3) = 0;
    *(v8 + 4) = -1;
  }
  return 0;
}
// 80F5184: using guessed type int dword_80F5184;

//----- (080A3AAA) --------------------------------------------------------
int __cdecl sub_80A3AAA(int a1, const char *a2, char *a3, int a4)
{
  void *v4; // esp
  char *v5; // eax
  char *v6; // eax
  void *v7; // esp
  char *v8; // eax
  _BYTE v10[12]; // [esp+10h] [ebp-38h] BYREF
  const char *v11; // [esp+1Ch] [ebp-2Ch]
  char v12; // [esp+23h] [ebp-25h]
  _BYTE *v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  char v15; // [esp+2Fh] [ebp-19h]
  int i; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  void *v19; // [esp+3Ch] [ebp-Ch]
  char v20[4]; // [esp+40h] [ebp-8h]
  char *s; // [esp+44h] [ebp-4h]

  s = a3;
  v14 = 1;
  while ( a4 )
  {
    if ( !*a3 )
    {
      s = a3 + 1;
      ++v14;
    }
    ++a3;
    --a4;
  }
  v17 = strlen(s);
  v4 = alloca(16 * ((v17 + 16) >> 4));
  *v20 = v10;
  for ( i = 0; i <= v17; ++i )
  {
    v15 = s[i];
    v13 = (i + *v20);
    if ( v15 == 9 )
      v12 = 32;
    else
      v12 = v15;
    *v13 = v12;
  }
  if ( dword_80F5180 )
    v11 = " (savegame)";
  else
    v11 = &unk_80E772C;
  v5 = sub_8086D78("(file '%s'%s, line %d)\n", a2, v11, v14);
  sub_806FE5F(a1, v5);
  v6 = sub_8086D78("%s\n", *v20);
  sub_806FE5F(a1, v6);
  n = a3 - s;
  v7 = alloca(16 * ((a3 - s + 17) >> 4));
  v19 = v10;
  sub_80C837D(v10, 32, a3 - s);
  *(v19 + n) = 42;
  *(v19 + n + 1) = 0;
  v8 = sub_8086D78("%s\n", v19);
  return sub_806FE5F(a1, v8);
}

//----- (080A3C34) --------------------------------------------------------
int __cdecl sub_80A3C34(int a1, unsigned int a2, int a3)
{
  char *v3; // eax
  int result; // eax
  int v5; // eax
  _BOOL4 v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_829FA00 )
  {
    v6 = sub_80A1F50(a2) == 0;
    for ( i = dword_831FDB0 - 1; i > 0 && (!*(dword_80F517C + 5 * i + v6) || *(dword_80F517C + 5 * i + v6) >= a2); --i )
      ;
    v5 = sub_80A3458(a2, a3);
    result = sub_80A3AAA(a1, *(dword_80F517C + 5 * i + 2), *(dword_80F517C + 5 * i + 3), v5);
  }
  else
  {
    v3 = sub_8086D78("@ %d\n", a2 - dword_80F5164);
    result = sub_806FE5F(a1, v3);
  }
  return result;
}
// 80F5164: using guessed type int dword_80F5164;
// 829FA00: using guessed type int dword_829FA00;
// 831FDB0: using guessed type int dword_831FDB0;

//----- (080A3D50) --------------------------------------------------------
void __noreturn sub_80A3D50(int a1, char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  Com_Printf("\n");
  Com_Printf("******* script compile error *******\n");
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( dword_829FA00 )
  {
    Com_Printf("%s: ", s);
    sub_80A3AAA(0, *dword_80F5178, *dword_80F5174, a1);
  }
  else
  {
    Com_Printf("%s\n", s);
  }
  Com_Printf("************************************\n");
  sub_80704AC(1, &byte_80E77E0);
}
// 829FA00: using guessed type int dword_829FA00;

//----- (080A3E12) --------------------------------------------------------
void __noreturn sub_80A3E12(unsigned int a1, char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  Com_Printf("\n");
  Com_Printf("******* script compile error *******\n");
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Printf("%s: ", s);
  sub_80A3C34(0, a1, 0);
  Com_Printf("************************************\n");
  sub_80704AC(1, &byte_80E77E0);
}

//----- (080A3EA8) --------------------------------------------------------
void __cdecl sub_80A3EA8(int a1, unsigned int a2, int a3, const char *a4)
{
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  v4 = sub_8086D78("\n******* script runtime error *******\n%s: ", a4);
  sub_806FE5F(a1, v4);
  sub_80A3C34(a1, a2, a3);
  for ( i = dword_80F520C - 1; i >= 0; --i )
  {
    sub_806FE5F(a1, "called from:\n");
    sub_80A3C34(a1, dword_8433E20[i], 0);
  }
  sub_806FE5F(a1, "************************************\n");
}
// 80F520C: using guessed type int dword_80F520C;

//----- (080A3F4A) --------------------------------------------------------
void __cdecl sub_80A3F4A(unsigned int a1, int a2, const char *a3, void *a4)
{
  const char *v4; // [esp+18h] [ebp-10h]
  void *v5; // [esp+1Ch] [ebp-Ch]
  char v6; // [esp+27h] [ebp-1h]

  if ( dword_829FA00 || byte_8433EAC )
  {
    v6 = 0;
    if ( dword_829FA08 || byte_8433EAC )
      v6 = 1;
    if ( v6 )
      sub_80A3EA8(0, a1, a2, a3);
    else
      sub_80A3EA8(4, a1, a2, a3);
    if ( v6 )
    {
      v5 = a4;
      if ( !a4 )
        v5 = &unk_80E772C;
      if ( a4 )
        v4 = "\n";
      else
        v4 = &unk_80E772C;
      if ( byte_8433EAC )
        sub_80704AC(1, &byte_80E7860, v4, v5, a4);
      sub_80704AC(6, &byte_80E7860, v4, v5, a4);
    }
  }
}
// 829FA00: using guessed type int dword_829FA00;
// 829FA08: using guessed type int dword_829FA08;
// 8433EAC: using guessed type char byte_8433EAC;

//----- (080A4030) --------------------------------------------------------
_DWORD *__userpurge sub_80A4030@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080A4042) --------------------------------------------------------
_DWORD *__userpurge sub_80A4042@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080A4054) --------------------------------------------------------
int *__userpurge sub_80A4054@<eax>(int *a1, int a2)
{
  *a1 = sub_806C4B7(4);
  **a1 = a2;
  return a1;
}

//----- (080A407E) --------------------------------------------------------
int __userpurge sub_80A407E@<eax>(int a1, int a2, int a3)
{
  *a1 = sub_806C4B7(8);
  **a1 = a2;
  *(*a1 + 4) = a3;
  return a1;
}

//----- (080A40B2) --------------------------------------------------------
int __userpurge sub_80A40B2@<eax>(int a1, int a2, int a3, int a4)
{
  *a1 = sub_806C4B7(12);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  return a1;
}

//----- (080A40F0) --------------------------------------------------------
int __userpurge sub_80A40F0@<eax>(int a1, int a2, int a3)
{
  *a1 = sub_806C4B7(8);
  **a1 = a2;
  *(*a1 + 4) = a3;
  return a1;
}

//----- (080A4124) --------------------------------------------------------
int __userpurge sub_80A4124@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *a1 = sub_806C4B7(16);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  *(*a1 + 12) = a5;
  return a1;
}

//----- (080A416C) --------------------------------------------------------
int __userpurge sub_80A416C@<eax>(int a1, int a2, int a3, int a4)
{
  *a1 = sub_806C4B7(12);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  return a1;
}

//----- (080A41AA) --------------------------------------------------------
int __userpurge sub_80A41AA@<eax>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *a1 = sub_806C4B7(20);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  *(*a1 + 12) = a5;
  *(*a1 + 16) = a6;
  return a1;
}

//----- (080A41FC) --------------------------------------------------------
int __userpurge sub_80A41FC@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *a1 = sub_806C4B7(16);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  *(*a1 + 12) = a5;
  return a1;
}

//----- (080A4244) --------------------------------------------------------
int __userpurge sub_80A4244@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *a1 = sub_806C4B7(24);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  *(*a1 + 12) = a5;
  *(*a1 + 16) = a6;
  *(*a1 + 20) = a7;
  return a1;
}

//----- (080A42A0) --------------------------------------------------------
int __userpurge sub_80A42A0@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *a1 = sub_806C4B7(28);
  **a1 = a2;
  *(*a1 + 4) = a3;
  *(*a1 + 8) = a4;
  *(*a1 + 12) = a5;
  *(*a1 + 16) = a6;
  *(*a1 + 20) = a7;
  *(*a1 + 24) = a8;
  return a1;
}

//----- (080A4306) --------------------------------------------------------
int __userpurge sub_80A4306@<eax>(int a1, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_806C4B7(8);
  *v3 = a2;
  v3[1] = 0;
  *a1 = sub_806C4B7(8);
  **a1 = v3;
  *(*a1 + 4) = v3;
  return a1;
}

//----- (080A435C) --------------------------------------------------------
_DWORD *__userpurge sub_80A435C@<eax>(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = sub_806C4B7(8);
  *v3 = a2;
  v3[1] = *a3;
  *a3 = v3;
  *a1 = a3;
  return a1;
}

//----- (080A43A2) --------------------------------------------------------
_DWORD *__userpurge sub_80A43A2@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax

  v3 = sub_806C4B7(8);
  *v3 = a3;
  v3[1] = 0;
  *(*(a2 + 4) + 4) = v3;
  *(a2 + 4) = v3;
  *a1 = a2;
  return a1;
}

//----- (080A4430) --------------------------------------------------------
int __cdecl sub_80A4430(unsigned __int16 a1)
{
  return dword_831FA20 + 8 * a1;
}
// 831FA20: using guessed type int dword_831FA20;

//----- (080A444C) --------------------------------------------------------
int __cdecl sub_80A444C(int a1)
{
  return a1 - 4;
}

//----- (080A4458) --------------------------------------------------------
int __cdecl sub_80A4458(unsigned __int16 a1)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a1 )
    v2 = sub_80A4430(a1) + 4;
  else
    v2 = 0;
  return v2;
}

//----- (080A448E) --------------------------------------------------------
int __cdecl sub_80A448E(int a1)
{
  return ((sub_80A444C(a1) - dword_831FA20) / 8);
}
// 831FA20: using guessed type int dword_831FA20;

//----- (080A44BE) --------------------------------------------------------
int __cdecl sub_80A44BE(char *a1, unsigned int a2)
{
  unsigned int v5; // [esp+Ch] [ebp-8h]

  if ( a2 > 0xFF )
    return ((a2 >> 2)
          - 0x3FFF * ((((262161 * (a2 >> 2)) >> 32) + (((a2 >> 2) - ((262161 * (a2 >> 2)) >> 32)) >> 1)) >> 13)
          + 1);
  v5 = 0;
  while ( a2 )
  {
    v5 = *a1++ + 31 * v5;
    --a2;
  }
  return (v5 % 0x3FFF + 1);
}

//----- (080A4572) --------------------------------------------------------
int sub_80A4572()
{
  int result; // eax
  unsigned __int16 v1; // [esp+Eh] [ebp-Ah]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80A2CC4();
  word_831FDC0[0] = 0;
  v1 = 0;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    word_831FDC0[2 * i] = 0;
    word_831FDC0[2 * v1] |= i;
    word_831FDC0[2 * i + 1] = v1;
    v1 = i;
  }
  result = v1;
  word_831FDC2[0] = v1;
  return result;
}
// 831FDC0: using guessed type __int16 word_831FDC0[];

//----- (080A45FC) --------------------------------------------------------
int __cdecl sub_80A45FC(void *s2, size_t n)
{
  unsigned __int16 v4; // [esp+12h] [ebp-16h]
  unsigned __int16 v5; // [esp+14h] [ebp-14h]
  __int16 v6; // [esp+16h] [ebp-12h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+18h] [ebp-10h]
  __int16 *i; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]
  __int16 *v11; // [esp+24h] [ebp-4h]

  v5 = sub_80A44BE(s2, n);
  v11 = &word_831FDC0[2 * v5];
  if ( (*v11 & 0xC000) != 0x8000 )
    return 0;
  v7 = sub_80A4430(v11[1]);
  if ( *(v7 + 2) != n || memcmp((v7 + 4), s2, n) )
  {
    v10 = v5;
    v4 = *v11 & 0x3FFF;
    for ( i = &word_831FDC0[2 * v4]; i != v11; i = &word_831FDC0[2 * v4] )
    {
      v8 = sub_80A4430(i[1]);
      if ( *(v8 + 2) == n && !memcmp((v8 + 4), s2, n) )
      {
        word_831FDC0[2 * v10] = word_831FDC0[2 * v10] & 0xC000 | *i & 0x3FFF;
        *i = *i & 0xC000 | *v11 & 0x3FFF;
        *v11 = *v11 & 0xC000 | v4;
        v6 = i[1];
        i[1] = v11[1];
        v11[1] = v6;
        return v11[1];
      }
      v10 = v4;
      v4 = *i & 0x3FFF;
    }
    return 0;
  }
  return v11[1];
}
// 831FDC0: using guessed type __int16 word_831FDC0[];

//----- (080A47E8) --------------------------------------------------------
int __cdecl sub_80A47E8(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_80A45FC(s, v1 + 1);
}

//----- (080A480E) --------------------------------------------------------
int __cdecl sub_80A480E(char *s)
{
  size_t v1; // eax
  void *v2; // esp
  _BYTE *v3; // ebx
  size_t n; // [esp+8h] [ebp-10h] BYREF
  int i; // [esp+Ch] [ebp-Ch]
  void *s2; // [esp+10h] [ebp-8h]

  v1 = strlen(s);
  n = v1 + 1;
  v2 = alloca(16 * ((v1 + 16) >> 4));
  s2 = &n;
  for ( i = v1; i >= 0; --i )
  {
    v3 = s2 + i;
    *v3 = tolower(s[i]);
  }
  return sub_80A45FC(s2, n);
}

//----- (080A4884) --------------------------------------------------------
int __cdecl sub_80A4884(void *s2, int a2, size_t n)
{
  unsigned __int16 v5; // [esp+16h] [ebp-22h]
  __int16 v6; // [esp+16h] [ebp-22h]
  __int16 v7; // [esp+16h] [ebp-22h]
  unsigned __int16 v8; // [esp+18h] [ebp-20h]
  __int16 v9; // [esp+1Ah] [ebp-1Eh]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-1Ch]
  __int16 *j; // [esp+20h] [ebp-18h]
  __int16 *v14; // [esp+20h] [ebp-18h]
  __int16 *v15; // [esp+20h] [ebp-18h]
  unsigned __int16 v16; // [esp+28h] [ebp-10h]
  unsigned __int16 v17; // [esp+28h] [ebp-10h]
  unsigned __int16 v18; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v19; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 i; // [esp+2Ah] [ebp-Eh]
  __int16 *v21; // [esp+2Ch] [ebp-Ch]

  v8 = sub_80A44BE(s2, n);
  v21 = &word_831FDC0[2 * v8];
  if ( (*v21 & 0xC000) != 0x8000 )
  {
    if ( (*v21 & 0xC000) != 0 )
    {
      v17 = *v21 & 0x3FFF;
      for ( i = v17; v8 != (word_831FDC0[2 * i] & 0x3FFF); i = word_831FDC0[2 * i] & 0x3FFF )
        ;
      v7 = word_831FDC0[0];
      if ( !word_831FDC0[0] )
      {
        sub_80A5540();
        sub_80A59C2();
        sub_80704AC(1, &byte_80E78A0);
      }
      v15 = &word_831FDC0[2 * word_831FDC0[0]];
      word_831FDC0[0] = *v15 & 0x3FFF;
      word_831FDC2[2 * word_831FDC0[0]] = 0;
      word_831FDC0[2 * i] = word_831FDC0[2 * i] & 0xC000 | v7;
      *v15 = v17 | 0x4000;
      v15[1] = v21[1];
    }
    else
    {
      v19 = v21[1];
      v16 = *v21 & 0x3FFF;
      word_831FDC0[2 * v19] = word_831FDC0[2 * v19] & 0xC000 | v16;
      word_831FDC2[2 * v16] = v19;
    }
    *v21 = v8 | 0x8000;
LABEL_27:
    v21[1] = sub_80A2E22(n + 4);
    v12 = sub_80A4430(v21[1]);
    sub_80C835C((v12 + 4), s2, n);
    *(v12 + 3) = a2;
    *v12 = 0;
    *(v12 + 2) = n;
    return v21[1];
  }
  v10 = sub_80A4430(v21[1]);
  if ( *(v10 + 2) != n || memcmp((v10 + 4), s2, n) )
  {
    v18 = v8;
    v5 = *v21 & 0x3FFF;
    for ( j = &word_831FDC0[2 * v5]; j != v21; j = &word_831FDC0[2 * v5] )
    {
      v11 = sub_80A4430(j[1]);
      if ( *(v11 + 2) == n && !memcmp((v11 + 4), s2, n) )
      {
        word_831FDC0[2 * v18] = word_831FDC0[2 * v18] & 0xC000 | *j & 0x3FFF;
        *j = *j & 0xC000 | *v21 & 0x3FFF;
        *v21 = *v21 & 0xC000 | v5;
        v9 = j[1];
        j[1] = v21[1];
        v21[1] = v9;
        if ( (*(v11 + 3) & a2) == 0 )
        {
          *(v11 + 3) |= a2;
          ++*v11;
        }
        return v21[1];
      }
      v18 = v5;
      v5 = *j & 0x3FFF;
    }
    v6 = word_831FDC0[0];
    if ( !word_831FDC0[0] )
    {
      sub_80A5540();
      sub_80A59C2();
      sub_80704AC(1, &byte_80E78A0);
    }
    v14 = &word_831FDC0[2 * word_831FDC0[0]];
    word_831FDC0[0] = *v14 & 0x3FFF;
    word_831FDC2[2 * word_831FDC0[0]] = 0;
    *v14 = *v21 & 0x3FFF | 0x4000;
    *v21 = *v21 & 0xC000 | v6 & 0x3FFF;
    v14[1] = v21[1];
    goto LABEL_27;
  }
  if ( (*(v10 + 3) & a2) == 0 )
  {
    *(v10 + 3) |= a2;
    ++*v10;
  }
  return v21[1];
}
// 831FDC0: using guessed type __int16 word_831FDC0[];

//----- (080A4D5C) --------------------------------------------------------
int __cdecl sub_80A4D5C(char *s, int a2)
{
  size_t v2; // eax

  v2 = strlen(s);
  return sub_80A4884(s, a2, v2 + 1);
}

//----- (080A4D9A) --------------------------------------------------------
int __cdecl sub_80A4D9A(char *s, int a2)
{
  return sub_80A4D5C(s, a2);
}

//----- (080A4DC6) --------------------------------------------------------
int __cdecl sub_80A4DC6(int a1, int a2, size_t n, int a4)
{
  void *v4; // esp
  _BYTE *v5; // ebx
  char v7; // [esp+Fh] [ebp-19h]
  int v8; // [esp+10h] [ebp-18h] BYREF
  int i; // [esp+18h] [ebp-10h]
  void *s2; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 v11; // [esp+23h] [ebp-5h]

  v11 = a2;
  v4 = alloca(16 * ((n + 15) >> 4));
  s2 = &v8;
  for ( i = n - 1; i >= 0; --i )
  {
    v5 = s2 + i;
    *v5 = tolower(*(a1 + i));
  }
  v7 = HIBYTE(a4);
  return sub_80A4884(s2, v11, n);
}

//----- (080A4E42) --------------------------------------------------------
int __cdecl sub_80A4E42(char *s, int a2, int a3)
{
  size_t v3; // eax

  v3 = strlen(s);
  return sub_80A4DC6(s, a2, v3 + 1, a3);
}

//----- (080A4E80) --------------------------------------------------------
int __cdecl sub_80A4E80(char *s, int a2)
{
  return sub_80A4E42(s, a2, 6);
}

//----- (080A4EAC) --------------------------------------------------------
int __cdecl sub_80A4EAC(unsigned __int16 a1, unsigned __int8 a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80A4430(a1);
  if ( (*(v3 + 3) & a2) != 0 )
  {
    result = *v3 - 1;
    *v3 = result;
  }
  else
  {
    result = a2;
    LOBYTE(result) = *(v3 + 3) | a2;
    *(v3 + 3) = result;
  }
  return result;
}

//----- (080A4F00) --------------------------------------------------------
int __cdecl sub_80A4F00(unsigned __int16 a1)
{
  _WORD *v1; // edx
  int result; // eax

  v1 = sub_80A4430(a1);
  result = *v1 + 1;
  *v1 = result;
  return result;
}

//----- (080A4F2C) --------------------------------------------------------
int __cdecl sub_80A4F2C(unsigned __int16 a1, char *a2, unsigned int a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+16h] [ebp-12h]
  int v6; // [esp+18h] [ebp-10h]
  __int16 *v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+20h] [ebp-8h]

  HIWORD(v6) = sub_80A44BE(a2, a3);
  v8 = &word_831FDC0[2 * HIWORD(v6)];
  sub_80A2EDA(a1, a3 + 4);
  LOWORD(v6) = *v8 & 0x3FFF;
  v7 = &word_831FDC0[2 * v6];
  if ( v8[1] == a1 )
  {
    if ( v7 == v8 )
    {
      v7 = &word_831FDC0[2 * HIWORD(v6)];
      LOWORD(v6) = HIWORD(v6);
    }
    else
    {
      *v8 = *v7 & 0x3FFF | 0x8000;
      v8[1] = v7[1];
      dword_832FDC0 = &word_831FDC0[2 * HIWORD(v6)];
    }
  }
  else
  {
    v4 = HIWORD(v6);
    while ( v7[1] != a1 )
    {
      v4 = v6;
      LOWORD(v6) = *v7 & 0x3FFF;
      v7 = &word_831FDC0[2 * v6];
    }
    word_831FDC0[2 * v4] = word_831FDC0[2 * v4] & 0xC000 | *v7 & 0x3FFF;
  }
  v5 = word_831FDC0[0];
  *v7 = word_831FDC0[0];
  v7[1] = 0;
  word_831FDC2[2 * v5] = v6;
  result = v6;
  word_831FDC0[0] = v6;
  return result;
}
// 831FDC0: using guessed type __int16 word_831FDC0[];
// 832FDC0: using guessed type int dword_832FDC0;

//----- (080A509E) --------------------------------------------------------
int __cdecl sub_80A509E(unsigned __int16 a1)
{
  int result; // eax
  size_t v2; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80A4430(a1);
  if ( *v3 )
  {
    result = *v3 - 1;
    *v3 = result;
  }
  else
  {
    v2 = strlen(v3 + 4);
    result = sub_80A4F2C(a1, v3 + 4, v2 + 1);
  }
  return result;
}

//----- (080A50FE) --------------------------------------------------------
int __cdecl sub_80A50FE(unsigned __int16 a1, unsigned int a2)
{
  int result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80A4430(a1);
  if ( !*v3 )
    return sub_80A4F2C(a1, v3 + 4, a2);
  result = *v3 - 1;
  *v3 = result;
  return result;
}

//----- (080A5152) --------------------------------------------------------
int __cdecl sub_80A5152(unsigned __int16 *a1, unsigned __int16 a2)
{
  int result; // eax

  if ( *a1 )
    sub_80A509E(*a1);
  if ( a2 )
    sub_80A4F00(a2);
  result = a2;
  *a1 = a2;
  return result;
}

//----- (080A5196) --------------------------------------------------------
int __cdecl sub_80A5196(char *s)
{
  return sub_80A4D9A(s, 1);
}

//----- (080A51B4) --------------------------------------------------------
int __cdecl sub_80A51B4(float a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%g", a1);
  return sub_80A4D5C(s, 0);
}

//----- (080A51FE) --------------------------------------------------------
int __cdecl sub_80A51FE(int a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%i", a1);
  return sub_80A4D5C(s, 0);
}

//----- (080A5248) --------------------------------------------------------
int __cdecl sub_80A5248(float *a1)
{
  char s[136]; // [esp+20h] [ebp-88h] BYREF

  sprintf(s, "(%.2f, %.2f, %.2f)", *a1, a1[1], a1[2]);
  return sub_80A4D5C(s, 0);
}

//----- (080A52AC) --------------------------------------------------------
unsigned int *__cdecl sub_80A52AC(unsigned int *a1)
{
  unsigned int *result; // eax
  int v2; // [esp+8h] [ebp-10h]
  __int16 *v3; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h] BYREF
  unsigned __int8 v5; // [esp+17h] [ebp-1h]

  result = a1;
  v5 = a1;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      v3 = &word_831FDC0[2 * i];
      if ( (*v3 & 0xC000) == 0 )
        break;
      v2 = sub_80A4430(v3[1]);
      if ( (*(v2 + 3) & v5) == 0 )
        break;
      *(v2 + 3) &= ~v5;
      dword_832FDC0 = 0;
      sub_80A509E(v3[1]);
    }
    while ( dword_832FDC0 );
    result = &i;
  }
  return result;
}
// 831FDC0: using guessed type __int16 word_831FDC0[];
// 832FDC0: using guessed type int dword_832FDC0;

//----- (080A5358) --------------------------------------------------------
_BYTE *__cdecl sub_80A5358(_BYTE *a1, char *a2, int a3)
{
  _BYTE *result; // eax
  char v4; // [esp+13h] [ebp-5h]

  do
  {
    do
    {
      do
        v4 = *a2++;
      while ( v4 == 92 );
    }
    while ( v4 == 47 );
    while ( v4 > 0x1Fu )
    {
      *a1++ = tolower(v4);
      if ( !--a3 )
        sub_80704AC(1, &byte_80E7900, a2, 0);
      if ( v4 == 92 )
        break;
      v4 = *a2++;
      if ( v4 == 47 )
        v4 = 92;
    }
  }
  while ( v4 );
  result = a1;
  *a1 = 0;
  return result;
}

//----- (080A53FC) --------------------------------------------------------
int __cdecl sub_80A53FC(char *a1)
{
  char s[1032]; // [esp+10h] [ebp-408h] BYREF

  sub_80A5358(s, a1, 1024);
  return sub_80A4D5C(s, 0);
}

//----- (080A5448) --------------------------------------------------------
void sub_80A5448()
{
  dword_80F5188 = 0;
}
// 80F5188: using guessed type int dword_80F5188;

//----- (080A5458) --------------------------------------------------------
int __cdecl sub_80A5458(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = dword_80F5188 + a1;
  v3 = dword_80F5188 + sub_806C6D0(dword_80F5188 + a1);
  dword_80F5188 = v2;
  return v3;
}
// 80F5188: using guessed type int dword_80F5188;

//----- (080A548C) --------------------------------------------------------
int __cdecl sub_80A548C(int a1)
{
  dword_80F5188 -= sub_80A5458(0) - a1;
  return sub_806C6D0(dword_80F5188);
}
// 80F5188: using guessed type int dword_80F5188;

//----- (080A54C0) --------------------------------------------------------
int __cdecl sub_80A54C0(const void *a1, const void *a2)
{
  int v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= *(a1 + 32) || i >= *(a2 + 32) )
      return *(a1 + 32) - *(a2 + 32);
    v5 = *(a1 + i);
    v4 = *(a2 + i);
    if ( v5 != v4 )
      break;
  }
  return v5 - v4;
}

//----- (080A5540) --------------------------------------------------------
int sub_80A5540()
{
  float *v0; // ebx
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  long double v3; // fst7
  char v5; // [esp+4h] [ebp-F4h]
  char v6; // [esp+4h] [ebp-F4h]
  char v7; // [esp+4h] [ebp-F4h]
  int v8; // [esp+18h] [ebp-E0h]
  char v9; // [esp+1Fh] [ebp-D9h]
  _BYTE *v10; // [esp+20h] [ebp-D8h]
  _DWORD *v11; // [esp+20h] [ebp-D8h]
  int v12; // [esp+24h] [ebp-D4h]
  int v13; // [esp+28h] [ebp-D0h]
  int v14; // [esp+2Ch] [ebp-CCh]
  int v15[32]; // [esp+30h] [ebp-C8h]
  int v16; // [esp+B0h] [ebp-48h]
  float v17; // [esp+B4h] [ebp-44h]
  float v18; // [esp+B8h] [ebp-40h]
  unsigned __int16 l; // [esp+CAh] [ebp-2Eh]
  unsigned int k; // [esp+CCh] [ebp-2Ch]
  char v21[4]; // [esp+D0h] [ebp-28h]
  int j; // [esp+D4h] [ebp-24h]
  int v23; // [esp+D8h] [ebp-20h]
  void *v24; // [esp+DCh] [ebp-1Ch]
  size_t nmemb; // [esp+E0h] [ebp-18h]
  void *base; // [esp+E4h] [ebp-14h]
  int *v27; // [esp+E8h] [ebp-10h]
  unsigned int i; // [esp+ECh] [ebp-Ch]

  base = sub_806BB38(0x8C0000u);
  nmemb = 0;
  for ( i = 1; i <= 0xFFFF; ++i )
  {
    v27 = &dword_832FDE0[3 * i];
    if ( (v27[1] & 0x60) != 0 && (v27[1] & 0x1F) == 10 )
    {
      v24 = base + 140 * nmemb++;
      v16 = 0;
      v14 = *v27;
      v13 = *(*v27 + 8);
      v12 = *(*v27 + 4);
      v10 = (*v27 + 12);
      while ( v13 )
      {
        --v13;
        v9 = *v10;
        v11 = v10 + 1;
        v8 = *v11;
        v10 = v11 + 1;
        if ( v9 == 6 )
          v15[v16++] = v8;
      }
      v15[v16++] = v12;
      v0 = v24;
      v0[33] = sub_80A98F0(v14, v24 + 34);
      *(v24 + 32) = v16--;
      for ( j = 0; j < *(v24 + 32); ++j )
        *(v24 + j) = v15[v16 - j];
    }
  }
  qsort(base, nmemb, 0x8Cu, sub_80A54C0);
  Com_Printf("********************************\n", v5);
  v23 = 0;
  while ( v23 < nmemb )
  {
    v24 = base + 140 * v23;
    *v21 = 0;
    v17 = 0.0;
    v18 = 0.0;
    do
    {
      ++*v21;
      v17 = v17 + *(base + 35 * v23 + 33);
      v18 = v18 + *(base + 35 * v23++ + 34);
    }
    while ( v23 < nmemb && !sub_80A54C0(v24, base + 140 * v23) );
    Com_Printf("count: %d, var usage: %d, endon usage: %d\n", v21[0]);
    sub_80A3C34(0, *v24, 0);
    for ( j = 1; j < *(v24 + 32); ++j )
    {
      Com_Printf("called from:\n", v6);
      sub_80A3C34(0, *(v24 + j), 0);
    }
  }
  sub_806BB25(base);
  Com_Printf("********************************\n", v6);
  for ( k = 0; k < dword_842FDE4; ++k )
  {
    if ( sub_80A6E88(word_80F51A2, k) )
    {
      v17 = 0.0;
      *v21 = 0;
      v1 = sub_80A6E88(word_80F51A2, k);
      v2 = sub_80A7B82(v1);
      for ( l = sub_80A7A30(v2); l; l = sub_80A7A30(l) )
      {
        ++*v21;
        v3 = sub_80A9862(dword_832FDE0[3 * l]);
        v17 = v3 + v17;
      }
      Com_Printf("ent type '%s'... count: %d, var usage: %d\n", *(dword_842FDE0 + 8 * k + 4));
    }
  }
  return Com_Printf("********************************\n", v7);
}
// 80A571B: variable 'v5' is possibly undefined
// 80A5850: variable 'v6' is possibly undefined
// 80A59B3: variable 'v7' is possibly undefined
// 80F51A2: using guessed type __int16 word_80F51A2;
// 832FDE0: using guessed type int dword_832FDE0[];
// 842FDE0: using guessed type int dword_842FDE0;
// 842FDE4: using guessed type int dword_842FDE4;

//----- (080A59C2) --------------------------------------------------------
void sub_80A59C2()
{
  ;
}

//----- (080A59C8) --------------------------------------------------------
int sub_80A59C8()
{
  int result; // eax
  unsigned __int16 v1; // [esp+6h] [ebp-Ah]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v1 = 0;
  for ( i = 1; i <= 0xFFFF; ++i )
  {
    dword_832FDE0[3 * i + 1] = 0;
    word_83EFDE0[2 * i] = i;
    word_832FDE8[6 * v1] = i;
    LOWORD(dword_832FDE0[3 * i]) = v1;
    v1 = i;
  }
  dword_832FDE0[1] = 0;
  word_83EFDE0[0] = 0;
  word_832FDE8[6 * v1] = 0;
  result = v1;
  LOWORD(dword_832FDE0[0]) = v1;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE8: using guessed type __int16 word_832FDE8[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A5A96) --------------------------------------------------------
int sub_80A5A96()
{
  int result; // eax

  sub_80A4572();
  sub_80A59C8();
  word_80F51A0 = sub_80A6A28();
  result = sub_80A6A28();
  word_80F51A2 = result;
  return result;
}
// 80F51A0: using guessed type __int16 word_80F51A0;
// 80F51A2: using guessed type __int16 word_80F51A2;

//----- (080A5AC8) --------------------------------------------------------
int __cdecl sub_80A5AC8(unsigned __int16 a1)
{
  return (dword_832FDE4[3 * a1] >> 8);
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A5AF0) --------------------------------------------------------
unsigned int __cdecl sub_80A5AF0(unsigned __int16 a1)
{
  return dword_832FDE0[3 * a1 + 1] >> 8;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A5B24) --------------------------------------------------------
int __cdecl sub_80A5B24(unsigned __int16 a1, int a2)
{
  int *v4; // [esp+4h] [ebp-18h]
  int *v5; // [esp+8h] [ebp-14h]
  unsigned __int16 v6; // [esp+Eh] [ebp-Eh]
  __int16 *v7; // [esp+10h] [ebp-Ch]
  unsigned __int16 v8; // [esp+18h] [ebp-4h]

  v8 = (a2 + 31 * a1) % 0xFFFF + 1;
  v5 = &dword_832FDE0[3 * word_83EFDE0[2 * v8]];
  if ( (v5[1] & 0x60) != 64 )
    return 0;
  if ( v5[1] >> 8 != a2 )
  {
    v6 = *(v5 + 4);
    v7 = &word_83EFDE0[2 * v6];
    v4 = &dword_832FDE0[3 * *v7];
    while ( v7 != &word_83EFDE0[2 * v8] )
    {
      if ( v4[1] >> 8 == a2 )
        return v6;
      v6 = *(v4 + 4);
      v7 = &word_83EFDE0[2 * v6];
      v4 = &dword_832FDE0[3 * *v7];
    }
    return 0;
  }
  return v8;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A5C62) --------------------------------------------------------
int __cdecl sub_80A5C62(unsigned __int16 a1, unsigned int a2)
{
  int *v4; // [esp+8h] [ebp-30h]
  int *v5; // [esp+10h] [ebp-28h]
  int *v6; // [esp+10h] [ebp-28h]
  int *v7; // [esp+14h] [ebp-24h]
  unsigned __int16 v8; // [esp+18h] [ebp-20h]
  unsigned __int16 v9; // [esp+18h] [ebp-20h]
  __int16 v10; // [esp+18h] [ebp-20h]
  __int16 v11; // [esp+1Ah] [ebp-1Eh]
  unsigned __int16 v12; // [esp+22h] [ebp-16h]
  __int16 *v13; // [esp+24h] [ebp-14h]
  __int16 *v14; // [esp+24h] [ebp-14h]
  __int16 *v15; // [esp+24h] [ebp-14h]
  unsigned __int16 i; // [esp+28h] [ebp-10h]
  unsigned __int16 v17; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v18; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v19; // [esp+2Eh] [ebp-Ah]
  __int16 *v20; // [esp+30h] [ebp-8h]
  unsigned __int16 v21; // [esp+34h] [ebp-4h]

  v21 = (a2 + 31 * a1) % 0xFFFF + 1;
  v20 = &word_83EFDE0[2 * v21];
  v7 = &dword_832FDE0[3 * *v20];
  if ( (v7[1] & 0x60) == 64 )
  {
    if ( v7[1] >> 8 == a2 )
      return v21;
    v8 = *(v7 + 4);
    v13 = &word_83EFDE0[2 * v8];
    v5 = &dword_832FDE0[3 * *v13];
    while ( v13 != v20 )
    {
      if ( v5[1] >> 8 == a2 )
        return v8;
      v8 = *(v5 + 4);
      v13 = &word_83EFDE0[2 * v8];
      v5 = &dword_832FDE0[3 * *v13];
    }
    v9 = word_832FDE8[0];
    if ( !word_832FDE8[0] )
      sub_80B055C("exceeded maximum number of script variables");
    v14 = &word_83EFDE0[2 * word_832FDE8[0]];
    v6 = &dword_832FDE0[3 * *v14];
    word_832FDE8[0] = *(v6 + 4);
    LOWORD(dword_832FDE0[3 * word_83EFDE0[2 * word_832FDE8[0]]]) = 0;
    v6[1] = 32;
    *(v6 + 4) = *(v7 + 4);
    *(v7 + 4) = v9;
  }
  else
  {
    if ( (v7[1] & 0x60) != 0 )
    {
      v10 = word_832FDE8[0];
      if ( !word_832FDE8[0] )
        sub_80B055C("exceeded maximum number of script variables");
      v15 = &word_83EFDE0[2 * word_832FDE8[0]];
      v6 = &dword_832FDE0[3 * *v15];
      word_832FDE8[0] = *(v6 + 4);
      LOWORD(dword_832FDE0[3 * word_83EFDE0[2 * word_832FDE8[0]]]) = 0;
      v19 = *(v7 + 5);
      word_832FDEA[6 * word_83EFDE0[2 * v20[1]]] = v10;
      word_83EFDE2[2 * v19] = v10;
      if ( (v7[1] & 0x60) == 32 )
      {
        for ( i = word_83EFDE0[2 * *(v7 + 4)]; word_832FDE8[6 * i] != v21; i = word_83EFDE0[2 * word_832FDE8[6 * i]] )
          ;
        word_832FDE8[6 * i] = v10;
      }
      else
      {
        *(v7 + 4) = v10;
      }
      v15[1] = v20[1];
      v11 = *v15;
      *v15 = *v20;
      *v20 = v11;
    }
    else
    {
      v18 = dword_832FDE0[3 * *v20];
      v17 = *(v7 + 4);
      word_832FDE8[6 * word_83EFDE0[2 * v18]] = v17;
      LOWORD(dword_832FDE0[3 * word_83EFDE0[2 * v17]]) = v18;
      v6 = &dword_832FDE0[3 * *v20];
    }
    v9 = (a2 + 31 * a1) % 0xFFFF + 1;
    v14 = &word_83EFDE0[2 * v21];
    v6[1] = 64;
    *(v6 + 4) = v21;
  }
  v4 = &dword_832FDE0[3 * a1];
  v12 = *(v4 + 5);
  *(v6 + 5) = v12;
  word_83EFDE0[2 * v12 + 1] = v9;
  v14[1] = *(v4 + 4);
  *(v4 + 5) = v9;
  v6[1] = *(v6 + 4);
  v6[1] |= a2 << 8;
  if ( (v4[1] & 0x1F) == 15 )
  {
    ++*(v4 + 1);
    if ( a2 > 0xFFFF )
    {
      if ( a2 <= 0x1FFFF )
        sub_80A6BC6(a2);
    }
    else
    {
      sub_80A4F00(a2);
    }
  }
  return v9;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE8: using guessed type __int16 word_832FDE8[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A6158) --------------------------------------------------------
int __cdecl sub_80A6158(__int16 *a1, int a2)
{
  int result; // eax
  unsigned int v3; // [esp+10h] [ebp-28h]
  unsigned __int16 v4; // [esp+16h] [ebp-22h]
  unsigned __int16 v5; // [esp+18h] [ebp-20h]
  unsigned __int16 v6; // [esp+1Ah] [ebp-1Eh]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int *v8; // [esp+20h] [ebp-18h]
  int *v9; // [esp+20h] [ebp-18h]
  int *v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  __int16 *v12; // [esp+2Ch] [ebp-Ch]
  __int16 *v13; // [esp+30h] [ebp-8h]
  __int16 *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 v15; // [esp+36h] [ebp-2h]

  v11 = (a1 - word_83EFDE0) >> 2;
  v10 = &dword_832FDE0[3 * *a1];
  if ( (*(a2 + 4) & 0x1F) == 15 )
  {
    --*(a2 + 2);
    v3 = v10[1] >> 8;
    if ( v3 > 0xFFFF )
    {
      if ( v3 <= 0x1FFFF )
        sub_80A6C02(v3);
    }
    else
    {
      sub_80A509E(v3);
    }
  }
  if ( (v10[1] & 0x60) == 64 )
  {
    v15 = *(v10 + 4);
    v13 = &word_83EFDE0[2 * v15];
    v8 = &dword_832FDE0[3 * *v13];
    if ( v13 != a1 )
    {
      v8[1] &= 0xFFFFFF9F;
      v8[1] |= 0x40u;
      v6 = a1[1];
      v5 = *(v10 + 5);
      v4 = v13[1];
      word_83EFDE2[2 * *(v8 + 5)] = v11;
      word_832FDEA[6 * word_83EFDE0[2 * v4]] = v11;
      word_83EFDE2[2 * v5] = v15;
      word_832FDEA[6 * word_83EFDE0[2 * v6]] = v15;
      v7 = *a1;
      *a1 = *v13;
      *v13 = v7;
      v11 = v15;
    }
  }
  else
  {
    v14 = a1;
    v9 = v10;
    do
    {
      v12 = v14;
      v14 = &word_83EFDE0[2 * *(v9 + 4)];
      v9 = &dword_832FDE0[3 * *v14];
    }
    while ( v14 != a1 );
    word_832FDE8[6 * *v12] = *(v10 + 4);
  }
  v10[1] &= 0xFFFFFF9F;
  v10[1] |= 0x60u;
  result = v11;
  *(v10 + 4) = v11;
  return result;
}
// 80A6C02: using guessed type _DWORD __cdecl sub_80A6C02(_DWORD);
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE8: using guessed type __int16 word_832FDE8[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A63BA) --------------------------------------------------------
int __cdecl sub_80A63BA(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 i; // [esp+16h] [ebp-12h]
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int *v4; // [esp+18h] [ebp-10h]
  int *v5; // [esp+1Ch] [ebp-Ch]
  __int16 *v6; // [esp+20h] [ebp-8h]

  v5 = &dword_832FDE0[3 * a1];
  v6 = &word_83EFDE0[2 * *(v5 + 5)];
  for ( i = *v6; i != a1; i = *v6 )
  {
    sub_80A6158(v6, v5);
    v6 = &word_83EFDE0[2 * word_832FDEA[6 * i]];
  }
  v3 = word_83EFDE0[2 * *(v5 + 5)];
  while ( 1 )
  {
    result = v3;
    if ( v3 == a1 )
      break;
    v4 = &dword_832FDE0[3 * v3];
    v3 = word_83EFDE0[2 * *(v4 + 5)];
    sub_80A6B58(v4);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A64B0) --------------------------------------------------------
int __cdecl sub_80A64B0(unsigned __int16 a1)
{
  sub_80A6BC6(a1);
  sub_80A63BA(a1);
  return sub_80A6C02(a1);
}
// 80A6C02: using guessed type _DWORD __cdecl sub_80A6C02(_DWORD);

//----- (080A64E4) --------------------------------------------------------
int __cdecl sub_80A64E4(unsigned __int16 a1)
{
  return (dword_832FDE4[3 * a1] >> 8);
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A650C) --------------------------------------------------------
int __cdecl sub_80A650C(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax

  sub_80A4F00(a2);
  result = dword_832FDE4[3 * a1] | (a2 << 8);
  dword_832FDE4[3 * a1] = result;
  return result;
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A6564) --------------------------------------------------------
int __cdecl sub_80A6564(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+4h] [ebp-4h]

  v2 = sub_80A64E4(a1);
  sub_80A509E(v2);
  result = LOBYTE(dword_832FDE4[3 * a1]);
  dword_832FDE4[3 * a1] = result;
  return result;
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A65BA) --------------------------------------------------------
int __cdecl sub_80A65BA(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // eax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  int *v5; // eax
  unsigned __int16 v6; // ax
  unsigned __int16 v8; // [esp+Eh] [ebp-1Ah]
  unsigned __int16 v9; // [esp+12h] [ebp-16h]
  unsigned __int16 v10; // [esp+14h] [ebp-14h]
  unsigned __int16 v11; // [esp+16h] [ebp-12h]
  unsigned __int16 v12; // [esp+16h] [ebp-12h]
  unsigned __int16 v13; // [esp+18h] [ebp-10h]
  unsigned __int16 v14; // [esp+1Ah] [ebp-Eh]
  int *v15; // [esp+20h] [ebp-8h]

  v15 = &dword_832FDE0[3 * a1];
  sub_80A6BC6(a1);
  sub_80A63BA(a1);
  sub_80A6C02(*(v15 + 1));
  v14 = sub_80A6B34(a1);
  v13 = sub_80A6EB6(word_8433F70, a1);
  if ( v13 )
  {
    v11 = sub_80A7B82(v13);
    while ( 1 )
    {
      v10 = sub_80A7A30(v11);
      if ( !v10 )
        break;
      v9 = dword_832FDE4[3 * v10] >> 8;
      sub_80A64E4(v9);
      v1 = sub_80A6EB6(v11, v9);
      v2 = sub_80A7646(v1);
      sub_80AE2B6(*v2, v9);
      dword_832FDE4[3 * v9] &= 0xFFFFFFE0;
      dword_832FDE4[3 * v9] |= 0x10u;
      sub_80A72CA(v11, v9);
      sub_80A6C02(a1);
    }
    sub_80A72CA(word_8433F70, a1);
  }
  if ( sub_80A64E4(a1) )
  {
    v3 = sub_80A6EB6(word_8433F70, v14);
    v8 = sub_80A7B82(v3);
    v4 = sub_80A6EB6(v8, a1);
    v5 = sub_80A7646(v4);
    sub_80AE2B6(*v5, a1);
    v6 = sub_80A6EB6(word_8433F70, v14);
    v12 = sub_80A7B82(v6);
    sub_80A72CA(v12, a1);
    if ( !sub_80A79FE(v12) )
      sub_80A72CA(word_8433F70, v14);
  }
  v15[1] &= 0xFFFFFFE0;
  v15[1] |= 0x10u;
  return sub_80A6C02(a1);
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE4: using guessed type int dword_832FDE4[];
// 8433F70: using guessed type __int16 word_8433F70;

//----- (080A6864) --------------------------------------------------------
int *sub_80A6864()
{
  int *v1; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = word_832FDE8[0];
  if ( !word_832FDE8[0] )
    sub_80B055C("exceeded maximum number of script variables");
  v1 = &dword_832FDE0[3 * word_83EFDE0[2 * word_832FDE8[0]]];
  word_832FDE8[0] = *(v1 + 4);
  LOWORD(dword_832FDE0[3 * word_83EFDE0[2 * word_832FDE8[0]]]) = 0;
  *(v1 + 4) = v2;
  *(v1 + 5) = v2;
  word_83EFDE0[2 * v2 + 1] = v2;
  return v1;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE8: using guessed type __int16 word_832FDE8[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A6914) --------------------------------------------------------
int __cdecl sub_80A6914(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+2h] [ebp-Eh]
  unsigned __int16 v3; // [esp+4h] [ebp-Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-Ah]
  int *v5; // [esp+8h] [ebp-8h]

  v5 = &dword_832FDE0[3 * a1];
  v2 = *(v5 + 4);
  v4 = word_83EFDE2[2 * v2];
  v3 = *(v5 + 5);
  word_83EFDE2[2 * v3] = v4;
  word_832FDEA[6 * word_83EFDE0[2 * v4]] = v3;
  v5[1] &= 0xFFFFFF9F;
  v5[1] = v5[1];
  *(v5 + 4) = word_832FDE8[0];
  *v5 = 0;
  LOWORD(dword_832FDE0[3 * word_83EFDE0[2 * word_832FDE8[0]]]) = v2;
  result = v2;
  word_832FDE8[0] = v2;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE8: using guessed type __int16 word_832FDE8[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A69FA) --------------------------------------------------------
int sub_80A69FA()
{
  int *v0; // eax

  v0 = sub_80A6864();
  v0[1] = 96;
  return (-21845 * (v0 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6A28) --------------------------------------------------------
int sub_80A6A28()
{
  int *v0; // eax

  v0 = sub_80A6864();
  v0[1] = 110;
  *v0 = 0;
  return (-21845 * (v0 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6A5E) --------------------------------------------------------
int __cdecl sub_80A6A5E(int a1, __int16 a2)
{
  int *v2; // eax

  v2 = sub_80A6864();
  v2[1] = (a1 << 8) | 0x6D;
  *v2 = 0;
  *(v2 + 1) = a2;
  return (-21845 * (v2 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6AAC) --------------------------------------------------------
int sub_80A6AAC()
{
  int *v0; // eax

  v0 = sub_80A6864();
  v0[1] = 111;
  *v0 = 0;
  *(v0 + 1) = 0;
  return (-21845 * (v0 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6AEC) --------------------------------------------------------
int __cdecl sub_80A6AEC(__int16 a1)
{
  int *v1; // eax

  v1 = sub_80A6864();
  v1[1] = 108;
  *v1 = 0;
  *(v1 + 1) = a1;
  return (-21845 * (v1 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6B34) --------------------------------------------------------
int __cdecl sub_80A6B34(unsigned __int16 a1)
{
  return HIWORD(dword_832FDE0[3 * a1]);
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6B58) --------------------------------------------------------
int __cdecl sub_80A6B58(int *a1)
{
  sub_80A6DA0(a1[1] & 0x1F, *a1);
  return sub_80A6914(-21845 * (a1 - dword_832FDE0));
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6B96) --------------------------------------------------------
int __cdecl sub_80A6B96(unsigned __int16 a1)
{
  return sub_80A6B58(&dword_832FDE0[3 * a1]);
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6BC6) --------------------------------------------------------
int __cdecl sub_80A6BC6(unsigned __int16 a1)
{
  int result; // eax

  result = LOWORD(dword_832FDE0[3 * a1]) + 1;
  LOWORD(dword_832FDE0[3 * a1]) = result;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6C02) --------------------------------------------------------
int __cdecl sub_80A6C02(unsigned __int16 a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]

  v2 = &dword_832FDE0[3 * a1];
  if ( *v2 )
  {
    result = *v2 - 1;
    *v2 = result;
  }
  else
  {
    sub_80A64B0(a1);
    result = sub_80A6914(a1);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A6C5C) --------------------------------------------------------
_WORD *sub_80A6C5C()
{
  _WORD *v0; // eax

  v0 = sub_80A2F68(14);
  *v0 = 0;
  return v0 + 1;
}

//----- (080A6C8C) --------------------------------------------------------
_DWORD *__cdecl sub_80A6C8C(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_80A6C5C();
  *result = *a1;
  result[1] = a1[1];
  result[2] = a1[2];
  return result;
}

//----- (080A6CCA) --------------------------------------------------------
int __cdecl sub_80A6CCA(int a1)
{
  int result; // eax

  result = a1 - dword_831FA24;
  if ( a1 - dword_831FA24 >= dword_831FA2C )
  {
    result = *(a1 - 2) + 1;
    *(a1 - 2) = result;
  }
  return result;
}
// 831FA24: using guessed type int dword_831FA24;
// 831FA2C: using guessed type int dword_831FA2C;

//----- (080A6CF8) --------------------------------------------------------
int __cdecl sub_80A6CF8(int a1)
{
  int result; // eax

  result = a1 - dword_831FA24;
  if ( a1 - dword_831FA24 >= dword_831FA2C )
  {
    if ( *(a1 - 2) )
    {
      result = *(a1 - 2) - 1;
      *(a1 - 2) = result;
    }
    else
    {
      result = sub_80A2F8E(a1 - 2, 14);
    }
  }
  return result;
}
// 831FA24: using guessed type int dword_831FA24;
// 831FA2C: using guessed type int dword_831FA2C;

//----- (080A6D4E) --------------------------------------------------------
int __cdecl sub_80A6D4E(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 3 )
    return sub_80A6CCA(a2);
  if ( a1 > 3 )
  {
    if ( a1 == 7 )
      result = sub_80A6BC6(a2);
  }
  else if ( a1 >= 1 )
  {
    result = sub_80A4F00(a2);
  }
  return result;
}

//----- (080A6DA0) --------------------------------------------------------
int __cdecl sub_80A6DA0(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 3 )
    return sub_80A6CF8(a2);
  if ( a1 > 3 )
  {
    if ( a1 == 7 )
      result = sub_80A6C02(a2);
  }
  else if ( a1 >= 1 )
  {
    result = sub_80A509E(a2);
  }
  return result;
}
// 80A6C02: using guessed type _DWORD __cdecl sub_80A6C02(_DWORD);

//----- (080A6DF2) --------------------------------------------------------
_BOOL4 __cdecl sub_80A6DF2(int a1)
{
  return (a1 + 8257536) <= 0xFDFFFF;
}

//----- (080A6E18) --------------------------------------------------------
int __cdecl sub_80A6E18(int a1)
{
  return (a1 + 0x800000) & 0xFFFFFF;
}

//----- (080A6E2A) --------------------------------------------------------
int __cdecl sub_80A6E2A(unsigned __int16 a1, int a2)
{
  return sub_80A5B24(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A6E5A) --------------------------------------------------------
int __cdecl sub_80A6E5A(unsigned __int16 a1, int a2)
{
  return word_83EFDE0[2 * sub_80A6E2A(a1, a2)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A6E88) --------------------------------------------------------
int __cdecl sub_80A6E88(unsigned __int16 a1, int a2)
{
  return word_83EFDE0[2 * sub_80A5B24(a1, a2)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A6EB6) --------------------------------------------------------
int __cdecl sub_80A6EB6(unsigned __int16 a1, unsigned __int16 a2)
{
  return word_83EFDE0[2 * sub_80A5B24(a1, a2 + 0x10000)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A6EF0) --------------------------------------------------------
int __cdecl sub_80A6EF0(unsigned __int16 a1, int a2)
{
  return sub_80A5C62(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A6F20) --------------------------------------------------------
int __cdecl sub_80A6F20(unsigned __int16 a1, unsigned __int16 a2)
{
  int v3; // [esp+10h] [ebp-18h]
  __int16 v4; // [esp+16h] [ebp-12h]
  int *v5; // [esp+18h] [ebp-10h]
  int *v6; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+20h] [ebp-8h]
  unsigned __int16 v8; // [esp+22h] [ebp-6h]

  v8 = sub_80A5B24(a1, a2);
  if ( v8 )
    return word_83EFDE0[2 * v8];
  v5 = &dword_832FDE0[3 * a1];
  if ( (v5[1] & 0x1Fu) > 0xF )
  {
    sub_80A7674(word_80F5212);
    v3 = word_80F5212;
  }
  else if ( (v5[1] & 0x1F) == 13 && (v7 = sub_80A6E5A(*(dword_842FDE0 + 8 * (v5[1] >> 8)), a2)) != 0 )
  {
    v4 = *(v5 + 1);
    sub_80A7674(word_80F5212);
    v6 = &dword_832FDE0[3 * word_80F5212];
    v6[1] |= v5[1] & 0xFFFFFF00 | 8;
    *v6 = v4;
    *(v6 + 1) = HIWORD(dword_832FDE0[3 * v7]);
    v3 = word_80F5212;
  }
  else
  {
    v3 = sub_80A71D8(a1, a2);
  }
  return v3;
}
// 80F5212: using guessed type __int16 word_80F5212;
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];
// 842FDE0: using guessed type int dword_842FDE0;

//----- (080A70B6) --------------------------------------------------------
unsigned int __cdecl sub_80A70B6(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int result; // eax
  int *v3; // [esp+Ch] [ebp-Ch]

  if ( sub_80A5B24(a1, a2) )
    return sub_80A7240(a1, a2);
  v3 = &dword_832FDE0[3 * a1];
  result = v3[1] & 0x1F;
  if ( result <= 0xF )
  {
    result = v3[1] & 0x1F;
    if ( result == 13 )
    {
      result = sub_80A6E5A(*(dword_842FDE0 + 8 * (v3[1] >> 8)), a2);
      if ( result )
        sub_80B04E8("cannot set entity builtin key/value to undefined");
    }
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 842FDE0: using guessed type int dword_842FDE0;

//----- (080A717C) --------------------------------------------------------
int __cdecl sub_80A717C(unsigned __int16 a1, int a2)
{
  return word_83EFDE0[2 * sub_80A6EF0(a1, a2)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A71AA) --------------------------------------------------------
int __cdecl sub_80A71AA(unsigned __int16 a1, int a2)
{
  return word_83EFDE0[2 * sub_80A6EF0(a1, a2)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A71D8) --------------------------------------------------------
int __cdecl sub_80A71D8(unsigned __int16 a1, unsigned int a2)
{
  return word_83EFDE0[2 * sub_80A5C62(a1, a2)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A7206) --------------------------------------------------------
int __cdecl sub_80A7206(unsigned __int16 a1, unsigned __int16 a2)
{
  return word_83EFDE0[2 * sub_80A5C62(a1, a2 + 0x10000)];
}
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A7240) --------------------------------------------------------
int __cdecl sub_80A7240(unsigned __int16 a1, int a2)
{
  int *v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+10h] [ebp-8h]

  v4 = &word_83EFDE0[2 * sub_80A5B24(a1, a2)];
  v3 = &dword_832FDE0[3 * *v4];
  sub_80A6158(v4, &dword_832FDE0[3 * a1]);
  return sub_80A6B58(v3);
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A72CA) --------------------------------------------------------
int __cdecl sub_80A72CA(unsigned __int16 a1, unsigned __int16 a2)
{
  return sub_80A7240(a1, a2 + 0x10000);
}

//----- (080A72FA) --------------------------------------------------------
int __cdecl sub_80A72FA(unsigned __int16 a1, int a2)
{
  return sub_80A7352(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A7326) --------------------------------------------------------
int __cdecl sub_80A7326(unsigned __int16 a1, int a2)
{
  return sub_80A7240(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A7352) --------------------------------------------------------
int __cdecl sub_80A7352(unsigned __int16 a1, int a2)
{
  int result; // eax
  int *v3; // [esp+Ch] [ebp-Ch]

  result = sub_80A5B24(a1, a2);
  if ( result )
  {
    v3 = &dword_832FDE0[3 * word_83EFDE0[2 * result]];
    sub_80A6158(&word_83EFDE0[2 * result], &dword_832FDE0[3 * a1]);
    result = sub_80A6B58(v3);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A73E6) --------------------------------------------------------
int __cdecl sub_80A73E6(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 i; // [esp+16h] [ebp-22h]
  int *v4; // [esp+1Ch] [ebp-1Ch]
  int *v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]

  for ( i = word_83EFDE0[2 * word_832FDEA[6 * a1]]; ; i = word_83EFDE0[2 * word_832FDEA[6 * i]] )
  {
    result = i;
    if ( i == a1 )
      break;
    v5 = &dword_832FDE0[3 * i];
    v6 = v5[1] & 0x1F;
    v4 = &dword_832FDE0[3 * word_83EFDE0[2 * sub_80A5C62(a2, v5[1] >> 8)]];
    v4[1] |= v6;
    if ( v6 == 7 )
    {
      if ( (dword_832FDE4[3 * *v5] & 0x1F) == 15 )
      {
        *v4 = sub_80A6AAC();
        sub_80A73E6(*v5, *v4);
      }
      else
      {
        *v4 = *v5;
        sub_80A6BC6(*v5);
      }
    }
    else
    {
      *v4 = *v5;
      sub_80A6D4E(v6, *v5);
    }
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE4: using guessed type int dword_832FDE4[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A7590) --------------------------------------------------------
int __cdecl sub_80A7590(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+10h] [ebp-8h]

  v3 = &dword_832FDE0[3 * a1];
  sub_80A6DA0(v3[1] & 0x1F, *v3);
  v3[1] &= 0xFFFFFFE0;
  v3[1] |= a2[1];
  result = *a2;
  *v3 = *a2;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7600) --------------------------------------------------------
int __cdecl sub_80A7600(unsigned __int16 a1, int *a2)
{
  int result; // eax

  dword_832FDE0[3 * a1 + 1] |= a2[1];
  result = *a2;
  dword_832FDE0[3 * a1] = *a2;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7646) --------------------------------------------------------
int *__cdecl sub_80A7646(unsigned __int16 a1)
{
  return &dword_832FDE0[3 * a1];
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7674) --------------------------------------------------------
int __cdecl sub_80A7674(unsigned __int16 a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]

  v2 = &dword_832FDE0[3 * a1];
  sub_80A6DA0(v2[1] & 0x1F, *v2);
  result = v2[1] & 0x60;
  v2[1] = result;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A76C8) --------------------------------------------------------
int __cdecl sub_80A76C8(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+20h] [ebp-8h]

  v3 = &dword_832FDE0[3 * a1];
  switch ( v3[1] & 0x1F )
  {
    case 1:
    case 2:
      sub_80A509E(*v3);
      goto LABEL_6;
    case 3:
      sub_80A6CF8(*v3);
      goto LABEL_6;
    case 7:
      sub_80A6C02(*v3);
      goto LABEL_6;
    case 8:
      return sub_80B061A(v3[1] >> 8, *v3, *(v3 + 1), a2);
    default:
LABEL_6:
      v3[1] &= 0xFFFFFFE0;
      v3[1] |= a2[1];
      result = *a2;
      *v3 = *a2;
      return result;
  }
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A779A) --------------------------------------------------------
int __cdecl sub_80A779A(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+0h] [ebp-8h]

  v3 = &dword_832FDE0[3 * a1];
  a2[1] = v3[1] & 0x1F;
  result = *v3;
  *a2 = *v3;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A77DE) --------------------------------------------------------
int __cdecl sub_80A77DE(unsigned __int16 a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+22h] [ebp-6h]

  v4 = &dword_832FDE0[3 * a1];
  v3 = v4[1] & 0x1F;
  switch ( v3 )
  {
    case 1:
    case 2:
      sub_80A4F00(*v4);
      goto LABEL_8;
    case 3:
      sub_80A6CCA(*v4);
      goto LABEL_8;
    case 7:
      sub_80A6BC6(*v4);
      goto LABEL_8;
    case 8:
      sub_80B0674(v4[1] >> 8, *v4, *(v4 + 1), a2);
      result = a2;
      if ( *(a2 + 1) == 7 )
      {
        result = dword_832FDE0[3 * *a2 + 1] & 0x1F;
        if ( result == 15 )
        {
          v5 = *a2;
          sub_80A6C02(*a2);
          *a2 = sub_80A6AAC();
          result = sub_80A73E6(v5, *a2);
        }
      }
      return result;
    default:
LABEL_8:
      *(a2 + 1) = v3;
      result = *v4;
      *a2 = *v4;
      return result;
  }
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7912) --------------------------------------------------------
int __cdecl sub_80A7912(unsigned __int16 *a1)
{
  int result; // eax
  const char *v2; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  int *v7; // [esp+20h] [ebp-8h]

  if ( *(a1 + 1) == 7 )
  {
    v6 = *a1;
    v7 = &dword_832FDE0[3 * *a1];
    *(a1 + 1) = 5;
    if ( (v7[1] & 0x1F) == 15 )
      v4 = *(v7 + 1);
    else
      v4 = 1;
    *a1 = v4;
    result = sub_80A6C02(v6);
  }
  else
  {
    if ( *(a1 + 1) != 1 )
    {
      v3 = sub_8086D78("size cannot be applied to %s", *&off_80F51C0[4 * *(a1 + 1)]);
      sub_80B04E8(v3);
    }
    *(a1 + 1) = 5;
    v5 = *a1;
    v2 = sub_80A4458(*a1);
    *a1 = strlen(v2);
    result = sub_80A509E(v5);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A79FE) --------------------------------------------------------
int __cdecl sub_80A79FE(unsigned __int16 a1)
{
  return HIWORD(dword_832FDE0[3 * a1]);
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7A30) --------------------------------------------------------
int __cdecl sub_80A7A30(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-10h]
  unsigned __int16 v3; // [esp+6h] [ebp-Ah]

  v3 = word_832FDEA[6 * a1];
  if ( (dword_832FDE0[3 * word_83EFDE0[2 * v3] + 1] & 0x1Fu) > 0xB )
    v2 = 0;
  else
    v2 = word_83EFDE0[2 * v3];
  return v2;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A7AA4) --------------------------------------------------------
unsigned int __cdecl sub_80A7AA4(unsigned __int16 a1)
{
  return dword_832FDE4[3 * a1] >> 8;
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A7ACA) --------------------------------------------------------
int __cdecl sub_80A7ACA(unsigned __int16 a1)
{
  int *v2; // [esp+Ch] [ebp-Ch]

  v2 = &dword_832FDE0[3 * a1];
  if ( (v2[1] & 0x1F) == 0 )
  {
    v2[1] |= 7u;
    *v2 = sub_80A6A28();
  }
  return *v2;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7B26) --------------------------------------------------------
int __cdecl sub_80A7B26(unsigned __int16 a1)
{
  int *v2; // [esp+Ch] [ebp-Ch]

  v2 = &dword_832FDE0[3 * a1];
  if ( (v2[1] & 0x1F) == 0 )
  {
    v2[1] |= 7u;
    *v2 = sub_80A6AAC();
  }
  return *v2;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7B82) --------------------------------------------------------
int __cdecl sub_80A7B82(unsigned __int16 a1)
{
  return LOWORD(dword_832FDE0[3 * a1]);
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7BB2) --------------------------------------------------------
_BOOL4 __cdecl sub_80A7BB2(unsigned __int16 a1)
{
  return (dword_832FDE0[3 * a1 + 1] & 0x1Fu) <= 0xE;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7BF8) --------------------------------------------------------
_BOOL4 __cdecl sub_80A7BF8(unsigned __int16 a1)
{
  return (dword_832FDE0[3 * a1 + 1] & 0x1F) == 12;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7C3E) --------------------------------------------------------
int __cdecl sub_80A7C3E(unsigned __int16 *a1)
{
  char *v1; // eax
  char *v2; // eax
  int v4[3]; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+24h] [ebp-4h]

  if ( *(a1 + 1) != 7 )
  {
    v2 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * *(a1 + 1)]);
    sub_80B04E8(v2);
  }
  v5 = dword_832FDE4[3 * *a1] & 0x1F;
  if ( v5 > 14 )
  {
    v1 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * (dword_832FDE4[3 * *a1] & 0x1F)]);
    sub_80B04E8(v1);
  }
  v4[1] = 7;
  LOWORD(v4[0]) = *a1;
  sub_80A7590(word_80F5212, v4);
  return LOWORD(v4[0]);
}
// 80F5212: using guessed type __int16 word_80F5212;
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A7D0A) --------------------------------------------------------
int __cdecl sub_80A7D0A(unsigned __int16 a1)
{
  return dword_832FDE4[3 * a1] & 0x1F;
}
// 832FDE4: using guessed type int dword_832FDE4[];

//----- (080A7D30) --------------------------------------------------------
void __cdecl sub_80A7D30(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  unsigned __int16 v4; // [esp+14h] [ebp-4h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  if ( byte_80F5214 )
  {
    v2 = sub_80A6E88(word_80F51A2, a2);
    v5 = sub_80A7B82(v2);
    v4 = sub_80A6E5A(v5, a1);
    if ( v4 )
    {
      v3 = sub_80A7B82(v4);
      dword_832FDE0[3 * v3 + 1] &= 0xFFFFFFE0;
      dword_832FDE0[3 * v3 + 1] |= 0x11u;
      sub_80A6BC6(v3);
      sub_80AEC98(v3);
      sub_80A63BA(v3);
      sub_80A6C02(v3);
      sub_80A7326(v5, a1);
    }
  }
}
// 80F51A2: using guessed type __int16 word_80F51A2;
// 80F5214: using guessed type char byte_80F5214;
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A7E1A) --------------------------------------------------------
unsigned int __cdecl sub_80A7E1A(int a1, unsigned int a2)
{
  unsigned int result; // eax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  unsigned int i; // [esp+Ch] [ebp-Ch]

  dword_842FDE0 = a1;
  dword_842FDE4 = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v3 = sub_80A71D8(word_80F51A2, i);
    sub_80A7B26(v3);
    v4 = sub_80A71D8(word_80F51A0, i);
    *(a1 + 8 * i) = sub_80A7B26(v4);
  }
  return result;
}
// 80F51A0: using guessed type __int16 word_80F51A0;
// 80F51A2: using guessed type __int16 word_80F51A2;
// 842FDE0: using guessed type int dword_842FDE0;
// 842FDE4: using guessed type int dword_842FDE4;

//----- (080A7EA4) --------------------------------------------------------
unsigned int sub_80A7EA4()
{
  unsigned int result; // eax
  unsigned int i; // [esp+14h] [ebp-4h]

  if ( byte_80F5214 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_842FDE4 )
        break;
      sub_80A7352(word_80F51A0, i);
      sub_80A7352(word_80F51A2, i);
    }
  }
  return result;
}
// 80F51A0: using guessed type __int16 word_80F51A0;
// 80F51A2: using guessed type __int16 word_80F51A2;
// 80F5214: using guessed type char byte_80F5214;
// 842FDE4: using guessed type int dword_842FDE4;

//----- (080A7EFE) --------------------------------------------------------
int __cdecl sub_80A7EFE(int a1, char *s, int a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int *v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v8; // [esp+22h] [ebp-6h]
  int v9; // [esp+24h] [ebp-4h]

  HIWORD(v9) = a1;
  LOWORD(v9) = a3;
  v4 = sub_80A21CA(s);
  if ( v4 )
  {
    v6 = &dword_832FDE0[3 * sub_80A717C(a1, v4)];
    v6[1] &= 0xFFFFFFE0;
    v6[1] |= 5u;
    *(v6 + 1) = a3;
  }
  v5 = sub_80A4D5C(s, 0);
  v8 = sub_80A71D8(a1, v5);
  sub_80A509E(v5);
  v7 = &dword_832FDE0[3 * v8];
  v7[1] &= 0xFFFFFFE0;
  v7[1] |= 5u;
  result = v9;
  *(v7 + 1) = a3;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A800C) --------------------------------------------------------
int __cdecl sub_80A800C(unsigned __int16 a1, int a2)
{
  unsigned __int16 v2; // ax
  int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]

  v2 = sub_80A448E(a2);
  v5 = sub_80A6E88(a1, v2);
  if ( v5 )
    v4 = HIWORD(dword_832FDE0[3 * v5]);
  else
    v4 = -1;
  return v4;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A806C) --------------------------------------------------------
int __cdecl sub_80A806C(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v2 = sub_80A6E88(word_80F51A2, a2);
  v6 = sub_80A7B82(v2);
  v5 = sub_80A6E5A(v6, a1);
  if ( v5 )
    v4 = LOWORD(dword_832FDE0[3 * v5]);
  else
    v4 = 0;
  return v4;
}
// 80F51A2: using guessed type __int16 word_80F51A2;
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A80E8) --------------------------------------------------------
int __cdecl sub_80A80E8(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int *v6; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+14h] [ebp-4h]
  unsigned __int16 v8; // [esp+16h] [ebp-2h]

  v2 = sub_80A6E88(word_80F51A2, a2);
  v8 = sub_80A7B82(v2);
  v7 = sub_80A71AA(v8, a1);
  v6 = &dword_832FDE0[3 * v7];
  if ( (v6[1] & 0x1F) != 0 )
    return *v6;
  v3 = sub_80A6A5E(a2, a1);
  dword_832FDE0[3 * v7 + 1] |= 7u;
  LOWORD(dword_832FDE0[3 * v7]) = v3;
  return v3;
}
// 80F51A2: using guessed type __int16 word_80F51A2;
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A81B4) --------------------------------------------------------
int __cdecl sub_80A81B4(int *a1, unsigned __int16 *a2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  char s2[2]; // [esp+26h] [ebp-12h] BYREF
  char *s; // [esp+28h] [ebp-10h]
  unsigned __int16 v15; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v16; // [esp+2Eh] [ebp-Ah]
  int *v17; // [esp+30h] [ebp-8h]

  v11 = *(a2 + 1);
  if ( v11 == 3 )
  {
    if ( a1[1] != 5 )
    {
      v6 = sub_8086D78("%s is not a vector index", *&off_80F51C0[4 * a1[1]]);
      sub_80B04E8(v6);
    }
    if ( *a1 > 2 )
    {
      v5 = sub_8086D78("vector index %d out of range", *a1);
      sub_80B04E8(v5);
    }
    s = *a2;
    a1[1] = 4;
    *a1 = *&s[4 * *a1];
    result = sub_80A6CF8(s);
  }
  else if ( v11 > 3 )
  {
    if ( v11 != 7 )
    {
LABEL_30:
      dword_8433EA8 = 1;
      v10 = sub_8086D78("%s is not an array, string, or vector", *&off_80F51C0[4 * *(a2 + 1)]);
      sub_80B04E8(v10);
    }
    v17 = &dword_832FDE0[3 * *a2];
    if ( (v17[1] & 0x1F) != 15 )
    {
      dword_8433EA8 = 1;
      v7 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * (v17[1] & 0x1F)]);
      sub_80B04E8(v7);
    }
    v12 = a1[1];
    if ( v12 == 1 )
    {
      v16 = word_83EFDE0[2 * sub_80A5B24(*a2, *a1)];
      sub_80A509E(*a1);
    }
    else
    {
      if ( v12 != 5 )
      {
        v9 = sub_8086D78("%s is not an array index", *&off_80F51C0[4 * a1[1]]);
        sub_80B04E8(v9);
      }
      if ( !sub_80A6DF2(*a1) )
      {
        v8 = sub_8086D78("array index %d out of range", *a1);
        sub_80B04E8(v8);
      }
      v16 = word_83EFDE0[2 * sub_80A6E2A(*a2, *a1)];
    }
    if ( v16 )
    {
      sub_80A779A(v16, a1);
      sub_80AA72C(a1);
      result = sub_80A6C02(*a2);
    }
    else
    {
      sub_80A6C02(*a2);
      result = a1;
      a1[1] = 0;
    }
  }
  else
  {
    if ( v11 != 1 )
      goto LABEL_30;
    if ( a1[1] != 5 )
    {
      v4 = sub_8086D78("%s is not a string index", *&off_80F51C0[4 * a1[1]]);
      sub_80B04E8(v4);
    }
    if ( *a1 < 0 || (v15 = *a2, s = sub_80A4458(v15), *a1 >= strlen(s)) )
    {
      v3 = sub_8086D78("string index %d out of range", *a1);
      sub_80B04E8(v3);
    }
    a1[1] = 1;
    s2[0] = s[*a1];
    s2[1] = 0;
    *a1 = sub_80A4884(s2, 0, 2u);
    result = sub_80A509E(v15);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080A8506) --------------------------------------------------------
int __cdecl sub_80A8506(unsigned __int16 a1, unsigned __int16 *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v9; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+28h] [ebp-10h]
  __int16 v12; // [esp+2Ah] [ebp-Eh]
  int *v13; // [esp+2Ch] [ebp-Ch]
  int *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 v15; // [esp+36h] [ebp-2h]

  v15 = a1;
  v14 = &dword_832FDE0[3 * a1];
  v10 = v14[1] & 0x1F;
  v9 = *v14;
  while ( v10 != 7 )
  {
    if ( v10 != 8 )
    {
      dword_8433EA8 = 1;
      v3 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * v10]);
      sub_80B04E8(v3);
    }
    sub_80B0674(v14[1] >> 8, *v14, *(v14 + 1), (a2 + 4));
    v2 = *(a2 + 3);
    v9 = *(a2 + 2);
    v10 = v2;
    sub_80AA74C(&v9);
  }
  v12 = v9;
  v13 = &dword_832FDE0[3 * v9];
  if ( (v13[1] & 0x1F) != 15 )
  {
    dword_8433EA8 = 1;
    v4 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * (v13[1] & 0x1F)]);
    sub_80B04E8(v4);
  }
  if ( *(a2 + 1) != 5 )
  {
    if ( *(a2 + 1) != 1 )
    {
      v6 = sub_8086D78("%s is not an array index", *&off_80F51C0[4 * *(a2 + 1)]);
      sub_80B04E8(v6);
    }
    v11 = sub_80A5B24(v9, *a2);
    if ( v11 )
    {
      sub_80A509E(*a2);
      return word_83EFDE0[2 * v11];
    }
LABEL_17:
    sub_80B04E8("array index does not exist");
  }
  if ( !sub_80A6DF2(*a2) )
  {
    v5 = sub_8086D78("array index %d out of range", *a2);
    sub_80B04E8(v5);
  }
  v11 = sub_80A6E2A(v9, *a2);
  if ( !v11 )
    goto LABEL_17;
  return word_83EFDE0[2 * v11];
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080A8726) --------------------------------------------------------
int __cdecl sub_80A8726(unsigned __int16 a1, int *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  int *v12; // [esp+2Ch] [ebp-Ch]
  int *v13; // [esp+30h] [ebp-8h]
  unsigned __int16 v14; // [esp+36h] [ebp-2h]

  v14 = a1;
  v13 = &dword_832FDE0[3 * a1];
  v10 = v13[1] & 0x1F;
  for ( i = *v13; ; sub_80AA74C(&i) )
  {
    if ( !v10 )
    {
      v10 = 7;
      LOWORD(i) = sub_80A6AAC();
      v13[1] |= 7u;
      *v13 = i;
      goto LABEL_16;
    }
    if ( v10 == 7 )
      break;
    if ( v10 != 8 )
    {
      dword_8433EA8 = 1;
      if ( v10 != 1 )
      {
        if ( v10 != 3 )
        {
          v3 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * v10]);
          sub_80B04E8(v3);
        }
        sub_80B04E8("vector components cannot be individually changed");
      }
      sub_80B04E8("string characters cannot be individually changed");
    }
    sub_80B0674(v13[1] >> 8, *v13, *(v13 + 1), (a2 + 2));
    v2 = a2[3];
    i = a2[2];
    v10 = v2;
  }
  v12 = &dword_832FDE0[3 * i];
  if ( (v12[1] & 0x1F) != 15 )
  {
    dword_8433EA8 = 1;
    v4 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * (v12[1] & 0x1F)]);
    sub_80B04E8(v4);
  }
  if ( *v12 )
  {
    v11 = i;
    sub_80A6C02(i);
    LOWORD(i) = sub_80A6AAC();
    sub_80A73E6(v11, i);
    *v13 = i;
  }
LABEL_16:
  if ( a2[1] == 5 )
  {
    if ( !sub_80A6DF2(*a2) )
    {
      v5 = sub_8086D78("array index %d out of range", *a2);
      sub_80B04E8(v5);
    }
    v8 = word_83EFDE0[2 * sub_80A6EF0(i, *a2)];
  }
  else
  {
    if ( a2[1] != 1 )
    {
      v6 = sub_8086D78("%s is not an array index", *&off_80F51C0[4 * a2[1]]);
      sub_80B04E8(v6);
    }
    v11 = word_83EFDE0[2 * sub_80A5C62(i, *a2)];
    sub_80A509E(*a2);
    v8 = v11;
  }
  return v8;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080A89BE) --------------------------------------------------------
int __cdecl sub_80A89BE(unsigned __int16 a1, int *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // [esp+10h] [ebp-18h] BYREF
  int v9; // [esp+14h] [ebp-14h]
  unsigned __int16 v10; // [esp+1Ah] [ebp-Eh]
  int *v11; // [esp+1Ch] [ebp-Ch]
  int *v12; // [esp+20h] [ebp-8h]
  unsigned __int16 v13; // [esp+26h] [ebp-2h]

  v13 = a1;
  v12 = &dword_832FDE0[3 * a1];
  v9 = v12[1] & 0x1F;
  v8 = *v12;
  while ( v9 != 7 )
  {
    if ( v9 != 8 )
    {
      dword_8433EA8 = 1;
      v3 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * v9]);
      sub_80B04E8(v3);
    }
    sub_80B0674(v12[1] >> 8, *v12, *(v12 + 1), (a2 + 2));
    v2 = a2[3];
    v8 = a2[2];
    v9 = v2;
    sub_80AA74C(&v8);
  }
  v11 = &dword_832FDE0[3 * v8];
  if ( (v11[1] & 0x1F) != 15 )
  {
    dword_8433EA8 = 1;
    v4 = sub_8086D78("%s is not an array", *&off_80F51C0[4 * (v11[1] & 0x1F)]);
    sub_80B04E8(v4);
  }
  if ( *v11 )
  {
    v10 = v8;
    sub_80A6C02(v8);
    LOWORD(v8) = sub_80A6AAC();
    sub_80A73E6(v10, v8);
    *v12 = v8;
  }
  if ( a2[1] == 5 )
  {
    if ( !sub_80A6DF2(*a2) )
    {
      v6 = sub_8086D78("array index %d out of range", *a2);
      sub_80B04E8(v6);
    }
    result = sub_80A72FA(v8, *a2);
  }
  else
  {
    if ( a2[1] != 1 )
    {
      v7 = sub_8086D78("%s is not an array index", *&off_80F51C0[4 * a2[1]]);
      sub_80B04E8(v7);
    }
    sub_80A7352(v8, *a2);
    result = sub_80A509E(*a2);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080A8BC4) --------------------------------------------------------
int __cdecl sub_80A8BC4(int a1)
{
  int result; // eax

  *(a1 + 4) = 7;
  result = sub_80A6AAC();
  *a1 = result;
  return result;
}

//----- (080A8BE6) --------------------------------------------------------
int __cdecl sub_80A8BE6(unsigned __int16 a1)
{
  int result; // eax

  dword_832FDE0[3 * a1 + 1] |= 7u;
  result = sub_80A6AAC();
  LOWORD(dword_832FDE0[3 * a1]) = result;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A8C30) --------------------------------------------------------
int __cdecl sub_80A8C30(unsigned __int16 a1)
{
  return HIWORD(dword_832FDE0[3 * a1]);
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A8C54) --------------------------------------------------------
int __cdecl sub_80A8C54(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // ax
  int *v4; // ecx
  unsigned int v5; // [esp+Ch] [ebp-1Ch]
  int *v6; // [esp+14h] [ebp-14h]
  unsigned int v7; // [esp+18h] [ebp-10h]
  unsigned __int16 i; // [esp+1Eh] [ebp-Ah]

  result = sub_80A7A30(a1);
  for ( i = result; i; i = result )
  {
    v6 = &dword_832FDE0[3 * i];
    v7 = v6[1] >> 8;
    if ( v7 != 0x20000 )
    {
      v3 = sub_80A5C62(a2, v7);
      v5 = v6[1] & 0xFFFFFF9F;
      v4 = &dword_832FDE0[3 * word_83EFDE0[2 * v3]];
      v4[1] |= v5;
      *v4 = *v6;
      sub_80A6D4E(v5 & 0x1F, *v4);
    }
    result = sub_80A7A30(i);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A8D5A) --------------------------------------------------------
int __cdecl sub_80A8D5A(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  result = sub_80A806C(a1, a3);
  v5 = result;
  if ( result )
  {
    result = sub_80A7A30(result);
    if ( result )
    {
      v4 = sub_80A80E8(a2, a3);
      result = sub_80A8C54(v5, v4);
    }
  }
  return result;
}

//----- (080A8DB8) --------------------------------------------------------
int __cdecl sub_80A8DB8(unsigned __int8 a1)
{
  unsigned __int8 *v1; // edx
  int result; // eax

  v1 = sub_80A5458(1);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A8DDA) --------------------------------------------------------
int sub_80A8DDA()
{
  return *dword_842FDF4++;
}

//----- (080A8DF8) --------------------------------------------------------
int __cdecl sub_80A8DF8(unsigned __int16 a1)
{
  unsigned __int16 *v1; // edx
  int result; // eax

  v1 = sub_80A5458(2);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A8E1C) --------------------------------------------------------
int sub_80A8E1C()
{
  unsigned __int16 v1; // [esp+2h] [ebp-2h]

  v1 = *dword_842FDF4;
  dword_842FDF4 += 2;
  return v1;
}

//----- (080A8E3C) --------------------------------------------------------
char *__cdecl sub_80A8E3C(unsigned __int16 a1)
{
  size_t v1; // eax
  char *v2; // eax
  char *s; // [esp+10h] [ebp-8h]

  s = sub_80A4458(a1);
  v1 = strlen(s);
  v2 = sub_80A5458(v1 + 1);
  return strcpy(v2, s);
}

//----- (080A8E80) --------------------------------------------------------
char *__cdecl sub_80A8E80(unsigned __int16 a1)
{
  if ( !a1 )
    return sub_80A8DB8(0);
  sub_80A8DB8(1u);
  return sub_80A8E3C(a1);
}

//----- (080A8EBC) --------------------------------------------------------
int sub_80A8EBC()
{
  size_t n; // [esp+10h] [ebp-8h]
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  n = strlen(dword_842FDF4) + 1;
  v2 = sub_80A4884(dword_842FDF4, 0, n);
  dword_842FDF4 += n;
  return v2;
}

//----- (080A8F0A) --------------------------------------------------------
int sub_80A8F0A()
{
  int v1; // [esp+4h] [ebp-4h]

  if ( sub_80A8DDA() )
    v1 = sub_80A8EBC();
  else
    v1 = 0;
  return v1;
}

//----- (080A8F32) --------------------------------------------------------
int __cdecl sub_80A8F32(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_80A5458(4);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A8F4E) --------------------------------------------------------
long double sub_80A8F4E()
{
  float v1; // [esp+4h] [ebp-4h]

  v1 = *dword_842FDF4;
  dword_842FDF4 += 4;
  return v1;
}

//----- (080A8F70) --------------------------------------------------------
int __cdecl sub_80A8F70(int *a1)
{
  sub_80A8F32(*a1);
  sub_80A8F32(a1[1]);
  return sub_80A8F32(a1[2]);
}

//----- (080A8FA6) --------------------------------------------------------
_DWORD *sub_80A8FA6()
{
  float v1[6]; // [esp+10h] [ebp-18h] BYREF

  v1[0] = sub_80A8F4E();
  v1[1] = sub_80A8F4E();
  v1[2] = sub_80A8F4E();
  return sub_80A6C8C(v1);
}

//----- (080A8FD2) --------------------------------------------------------
int __cdecl sub_80A8FD2(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_80A5458(4);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A8FEE) --------------------------------------------------------
int sub_80A8FEE()
{
  int v1; // [esp+0h] [ebp-4h]

  v1 = *dword_842FDF4;
  dword_842FDF4 += 4;
  return v1;
}

//----- (080A900A) --------------------------------------------------------
int __cdecl sub_80A900A(int a1)
{
  int result; // eax

  if ( a1 )
    result = sub_80A8FD2(a1 - dword_80F5164);
  else
    result = sub_80A8FD2(-1);
  return result;
}
// 80F5164: using guessed type int dword_80F5164;

//----- (080A903A) --------------------------------------------------------
int sub_80A903A()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = sub_80A8FEE();
  if ( v2 < 0 )
    v1 = 0;
  else
    v1 = v2 + dword_80F5164;
  return v1;
}
// 80F5164: using guessed type int dword_80F5164;

//----- (080A9070) --------------------------------------------------------
int __cdecl sub_80A9070(unsigned __int16 a1)
{
  return sub_80A8DF8(*(dword_842FDEC + a1));
}

//----- (080A9098) --------------------------------------------------------
int sub_80A9098()
{
  unsigned __int16 v1; // [esp+6h] [ebp-2h]

  v1 = *(dword_842FDF0 + sub_80A8E1C());
  sub_80A6BC6(v1);
  return v1;
}

//----- (080A90C8) --------------------------------------------------------
void *__cdecl sub_80A90C8(void *src, size_t n)
{
  void *v2; // eax

  v2 = sub_80A5458(n);
  return sub_80C835C(v2, src, n);
}

//----- (080A90F4) --------------------------------------------------------
size_t __cdecl sub_80A90F4(void *dest, size_t n)
{
  size_t result; // eax

  sub_80C835C(dest, dword_842FDF4, n);
  result = n;
  dword_842FDF4 += n;
  return result;
}

//----- (080A9120) --------------------------------------------------------
int __cdecl sub_80A9120(unsigned __int16 a1)
{
  if ( !a1 )
    return 0;
  sub_80A96BE(a1);
  return *(dword_842FDEC + a1);
}

//----- (080A9162) --------------------------------------------------------
int __cdecl sub_80A9162(unsigned __int16 a1)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  if ( !a1 )
    return 0;
  v3 = *(dword_842FDF0 + a1);
  sub_80A6BC6(v3);
  return v3;
}

//----- (080A91AC) --------------------------------------------------------
int __cdecl sub_80A91AC(int a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+Ah] [ebp-Eh]
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v4; // [esp+13h] [ebp-5h]
  _BYTE *v5; // [esp+14h] [ebp-4h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  v2 = *(a1 + 8);
  sub_80A8DF8(v2);
  sub_80A8FD2(*a1);
  sub_80A900A(*(a1 + 4));
  sub_80A9070(*(a1 + 10));
  result = a1 + 12;
  v5 = (a1 + 12);
  while ( v2 )
  {
    --v2;
    v4 = *v5;
    v6 = v5 + 1;
    v3 = *v6;
    v5 = v6 + 1;
    result = sub_80A9456(v4, v3);
  }
  return result;
}
// 80A9456: using guessed type _DWORD __cdecl sub_80A9456(_DWORD, _DWORD);

//----- (080A9242) --------------------------------------------------------
int sub_80A9242()
{
  int v1; // [esp+8h] [ebp-20h] BYREF
  char v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+14h] [ebp-14h]
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80A8E1C();
  v3 = sub_80A2F68(5 * v4 + 12);
  *(v3 + 8) = v4;
  *v3 = sub_80A8FEE();
  *(v3 + 4) = sub_80A903A();
  *(v3 + 10) = sub_80A9098();
  v5 = (v3 + 12);
  while ( v4 )
  {
    --v4;
    sub_80A95A4(&v1);
    *v5 = v2;
    v5 = (v5 + 1);
    *v5++ = v1;
  }
  return v3;
}
// 80A95A4: using guessed type _DWORD __cdecl sub_80A95A4(_DWORD);

//----- (080A92EC) --------------------------------------------------------
int __cdecl sub_80A92EC(int a1)
{
  int result; // eax
  __int16 v2; // [esp+Ah] [ebp-Eh]
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v4; // [esp+13h] [ebp-5h]
  _BYTE *v5; // [esp+14h] [ebp-4h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  sub_80A96BE(*(a1 + 10));
  v2 = *(a1 + 8);
  result = a1 + 12;
  v5 = (a1 + 12);
  while ( v2 )
  {
    --v2;
    v4 = *v5;
    v6 = v5 + 1;
    v3 = *v6;
    v5 = v6 + 1;
    result = sub_80A935A(v4, v3);
  }
  return result;
}
// 80A935A: using guessed type _DWORD __cdecl sub_80A935A(_DWORD, _DWORD);
// 80A96BE: using guessed type _DWORD __cdecl sub_80A96BE(_DWORD);

//----- (080A935A) --------------------------------------------------------
int __cdecl sub_80A935A(unsigned __int8 a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 7 )
    return sub_80A96BE(a2);
  if ( a1 == 10 )
    result = sub_80A92EC(a2);
  return result;
}
// 80A96BE: using guessed type _DWORD __cdecl sub_80A96BE(_DWORD);

//----- (080A9396) --------------------------------------------------------
int __cdecl sub_80A9396(int a1)
{
  return sub_80A935A(*(a1 + 4) & 0x1F, *a1);
}

//----- (080A93BC) --------------------------------------------------------
long double __cdecl sub_80A93BC(char a1, unsigned __int16 a2)
{
  float v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]

  if ( a1 == 7 && (v4 = &dword_832FDE0[3 * a2], (v4[1] & 0x1F) == 15) )
    v3 = sub_80A9862(a2) / (*v4 + 1.0);
  else
    v3 = 0.0;
  return v3;
}
// 80A9862: using guessed type double __cdecl sub_80A9862(_DWORD);
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A942C) --------------------------------------------------------
long double __cdecl sub_80A942C(int a1)
{
  return sub_80A93BC(*(a1 + 4) & 0x1F, *a1) + 1.0;
}

//----- (080A9456) --------------------------------------------------------
char *__cdecl sub_80A9456(unsigned __int8 a1, int *a2)
{
  char *result; // eax

  sub_80A8DB8(a1);
  result = (a1 & 0x1F);
  switch ( a1 & 0x1F )
  {
    case 1:
    case 2:
      result = sub_80A8E3C(a2);
      break;
    case 3:
      result = sub_80A8F70(a2);
      break;
    case 4:
      result = sub_80A8F32(a2);
      break;
    case 5:
    case 0xB:
      result = sub_80A8FD2(a2);
      break;
    case 6:
    case 9:
      result = sub_80A900A(a2);
      break;
    case 7:
      result = sub_80A9070(a2);
      break;
    case 0xA:
      result = sub_80A91AC(a2);
      break;
    default:
      return result;
  }
  return result;
}

//----- (080A94F6) --------------------------------------------------------
char *__cdecl sub_80A94F6(int a1, unsigned int a2, char a3)
{
  char *result; // eax

  sub_80A9456(*(a1 + 4), *a1);
  if ( a3 && a2 <= 0x1FFFF )
  {
    if ( a2 > 0xFFFF )
    {
      sub_80A8DB8(3u);
      result = sub_80A9070(a2);
    }
    else
    {
      sub_80A8DB8(2u);
      result = sub_80A8E3C(a2);
    }
  }
  else if ( a2 > 0xFFFF )
  {
    sub_80A8DB8(1u);
    result = sub_80A8FD2(a2);
  }
  else
  {
    sub_80A8DB8(0);
    result = sub_80A8DF8(a2);
  }
  return result;
}

//----- (080A95A4) --------------------------------------------------------
void __cdecl sub_80A95A4(int a1)
{
  *(a1 + 4) = sub_80A8DDA();
  switch ( *(a1 + 4) & 0x1F )
  {
    case 1:
    case 2:
      *a1 = sub_80A8EBC();
      break;
    case 3:
      *a1 = sub_80A8FA6();
      break;
    case 4:
      *a1 = sub_80A8F4E();
      break;
    case 5:
    case 0xB:
      *a1 = sub_80A8FEE();
      break;
    case 6:
    case 9:
      *a1 = sub_80A903A();
      break;
    case 7:
      *a1 = sub_80A9098();
      break;
    case 0xA:
      *a1 = sub_80A9242();
      break;
    default:
      return;
  }
}

//----- (080A963E) --------------------------------------------------------
int __cdecl sub_80A963E(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  sub_80A95A4(a1);
  v2 = sub_80A8DDA();
  if ( v2 == 1 )
    return sub_80A8FEE();
  if ( v2 > 1 )
  {
    if ( v2 == 2 )
    {
      v3 = sub_80A8EBC();
    }
    else
    {
      if ( v2 != 3 )
        return 0;
      v3 = sub_80A9098() + 0x10000;
    }
  }
  else
  {
    if ( v2 )
      return 0;
    v3 = sub_80A8E1C();
  }
  return v3;
}

//----- (080A96BE) --------------------------------------------------------
void *__cdecl sub_80A96BE(unsigned __int16 a1)
{
  void *result; // eax
  int v2; // [esp+10h] [ebp-18h]
  unsigned int v3; // [esp+14h] [ebp-14h]
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  int *v5; // [esp+1Ch] [ebp-Ch]
  int *v6; // [esp+20h] [ebp-8h]

  result = dword_842FDEC;
  if ( !*(dword_842FDEC + a1) )
  {
    *(dword_842FDEC + a1) = ++word_842FDE8;
    *(dword_842FDF0 + word_842FDE8) = a1;
    v6 = &dword_832FDE0[3 * a1];
    v2 = v6[1];
    for ( i = sub_80A7A30(a1); i; i = sub_80A7A30(i) )
    {
      v5 = &dword_832FDE0[3 * i];
      if ( (v2 & 0x1F) == 15 )
      {
        v3 = v5[1] >> 8;
        if ( v3 > 0xFFFF && v3 <= 0x1FFFF )
          sub_80A96BE(v3);
      }
      sub_80A9396(v5);
    }
    result = (v2 & 0x1F);
    if ( result == 12 )
      result = sub_80A96BE(*(v6 + 1));
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 842FDE8: using guessed type __int16 word_842FDE8;

//----- (080A97F2) --------------------------------------------------------
long double __cdecl sub_80A97F2(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]

  v4 = sub_80A6EB6(word_8433F70, a1);
  if ( !v4 )
    return 0.0;
  v1 = sub_80A7B82(v4);
  return sub_80A9862(v1);
}
// 8433F70: using guessed type __int16 word_8433F70;

//----- (080A9862) --------------------------------------------------------
long double __cdecl sub_80A9862(unsigned __int16 a1)
{
  float v2; // [esp+8h] [ebp-10h]
  unsigned __int16 i; // [esp+Eh] [ebp-Ah]

  v2 = 1.0;
  for ( i = sub_80A7A30(a1); i; i = sub_80A7A30(i) )
    v2 = sub_80A942C(&dword_832FDE0[3 * i]) + v2;
  return v2;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A98F0) --------------------------------------------------------
long double __cdecl sub_80A98F0(int a1, float *a2)
{
  float v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+18h] [ebp-10h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-Ch]

  v4 = *(a1 + 8);
  v5 = (5 * v4 + a1 + 12);
  v3 = sub_80A9862(*(a1 + 10));
  *a2 = sub_80A97F2(*(a1 + 10));
  while ( v4 )
  {
    v6 = v5 - 4;
    v8 = *v6;
    v5 = v6 - 1;
    --v4;
    if ( *v5 == 6 )
    {
      v7 = v5 - 4;
      v9 = *v7;
      v5 = v7 - 1;
      --v4;
      v3 = sub_80A9862(v9) + v3;
      *a2 = sub_80A97F2(v9) + *a2;
    }
    else
    {
      v3 = sub_80A93BC(*v5, v8) + v3;
    }
  }
  return v3;
}

//----- (080A99E8) --------------------------------------------------------
int __cdecl sub_80A99E8(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+13h] [ebp-25h]
  int *v3; // [esp+14h] [ebp-24h]
  int v4[3]; // [esp+18h] [ebp-20h] BYREF
  bool v5; // [esp+27h] [ebp-11h]
  unsigned int v6; // [esp+28h] [ebp-10h]
  unsigned __int16 i; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v8; // [esp+2Eh] [ebp-Ah]
  int *v9; // [esp+30h] [ebp-8h]
  unsigned __int16 v10; // [esp+36h] [ebp-2h]

  v10 = a1;
  v9 = &dword_832FDE0[3 * a1];
  v2 = v9[1] & 0x9F;
  sub_80A8DB8(v2);
  if ( (v2 & 0x1F) == 12 )
  {
    sub_80A9070(*(v9 + 1));
    sub_80A8E80(v9[1] >> 8);
  }
  else if ( (v2 & 0x1F) == 13 || (v2 & 0x1F) == 17 )
  {
    sub_80A8DF8(*(v9 + 1));
    sub_80A8DF8(v9[1] >> 8);
  }
  v5 = (v9[1] & 0x1F) == 15;
  v8 = 0;
  for ( i = sub_80A7A30(v10); i; i = sub_80A7A30(i) )
    ++v8;
  sub_80A8DF8(v8);
  result = sub_80A7A30(v10);
  for ( i = result; i; i = result )
  {
    v3 = &dword_832FDE0[3 * i];
    v6 = v3[1] >> 8;
    v4[1] = v3[1] & 0x9F;
    v4[0] = *v3;
    sub_80A94F6(v4, v6, v5);
    result = sub_80A7A30(i);
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080A9B6E) --------------------------------------------------------
int __cdecl sub_80A9B6E(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+Bh] [ebp-2Dh]
  int *v3; // [esp+Ch] [ebp-2Ch]
  int v4[2]; // [esp+10h] [ebp-28h] BYREF
  bool v5; // [esp+1Bh] [ebp-1Dh]
  int i; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  unsigned __int16 v8; // [esp+26h] [ebp-12h]
  int *v9; // [esp+28h] [ebp-10h]
  unsigned __int16 v10; // [esp+2Eh] [ebp-Ah]

  v10 = a1;
  v9 = &dword_832FDE0[3 * a1];
  v2 = sub_80A8DDA();
  v9[1] &= 0xFFFFFFE0;
  v9[1] |= v2;
  switch ( v2 & 0x1F )
  {
    case 12:
      *(v9 + 1) = sub_80A9098();
      v9[1] |= sub_80A8F0A() << 8;
      break;
    case 13:
    case 17:
      *(v9 + 1) = sub_80A8E1C();
      v9[1] |= sub_80A8E1C() << 8;
      break;
    case 15:
      *(v9 + 1) = 0;
      break;
  }
  v5 = (v2 & 0x1F) == 15;
  v8 = sub_80A8E1C();
  for ( i = 0; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
      break;
    v7 = sub_80A963E(v4);
    v3 = &dword_832FDE0[3 * word_83EFDE0[2 * sub_80A5C62(v10, v7)]];
    if ( v5 )
    {
      if ( v7 > 0xFFFF )
      {
        if ( v7 <= 0x1FFFF )
          sub_80A6C02(v7);
      }
      else
      {
        sub_80A509E(v7);
      }
    }
    v3[1] |= v4[1];
    *v3 = v4[0];
  }
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 83EFDE0: using guessed type __int16 word_83EFDE0[];

//----- (080A9D06) --------------------------------------------------------
int sub_80A9D06()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  unsigned int i; // [esp+14h] [ebp-4h]

  dword_842FDEC = sub_806C4B7(0x20000);
  dword_842FDF0 = sub_806C4B7(0x20000);
  sub_80C837D(dword_842FDEC, 0, 0x20000u);
  word_842FDE8 = 0;
  sub_80A96BE(word_8433F72);
  sub_80A96BE(word_8433F76);
  sub_80A96BE(word_80F5210);
  sub_80A96BE(word_8433F70);
  for ( i = 0; i < dword_842FDE4; ++i )
  {
    v0 = sub_80A6E88(word_80F51A2, i);
    v1 = sub_80A7B82(v0);
    sub_80A96BE(v1);
    v2 = sub_80A6E88(word_80F51A0, i);
    v3 = sub_80A7B82(v2);
    sub_80A96BE(v3);
  }
  return sub_80A9396(&dword_832FDE0[3 * word_8433F74]);
}
// 80F51A0: using guessed type __int16 word_80F51A0;
// 80F51A2: using guessed type __int16 word_80F51A2;
// 80F5210: using guessed type __int16 word_80F5210;
// 832FDE0: using guessed type int dword_832FDE0[];
// 842FDE4: using guessed type int dword_842FDE4;
// 842FDE8: using guessed type __int16 word_842FDE8;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F74: using guessed type __int16 word_8433F74;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080A9E28) --------------------------------------------------------
char *sub_80A9E28()
{
  return sub_80A9456(dword_832FDE4[3 * word_8433F74] & 0x9F, dword_832FDE0[3 * word_8433F74]);
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE4: using guessed type int dword_832FDE4[];
// 8433F74: using guessed type __int16 word_8433F74;

//----- (080A9E6E) --------------------------------------------------------
int sub_80A9E6E()
{
  int result; // eax
  int v1[2]; // [esp+10h] [ebp-8h] BYREF

  word_8433F74 = sub_80A69FA();
  sub_80A95A4(v1);
  dword_832FDE4[3 * word_8433F74] |= v1[1];
  result = v1[0];
  dword_832FDE0[3 * word_8433F74] = v1[0];
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 832FDE4: using guessed type int dword_832FDE4[];
// 8433F74: using guessed type __int16 word_8433F74;

//----- (080A9EE0) --------------------------------------------------------
unsigned int sub_80A9EE0()
{
  unsigned int result; // eax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned int j; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80A8FD2(dword_8433F6C);
  sub_80A8DF8(word_842FDE8);
  for ( i = 1; i <= word_842FDE8; ++i )
    sub_80A99E8(*(dword_842FDF0 + i));
  sub_80A9E28();
  sub_80A9070(word_8433F72);
  sub_80A9070(word_8433F76);
  sub_80A9070(word_80F5210);
  sub_80A9070(word_8433F70);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_842FDE4 )
      break;
    v1 = sub_80A6E88(word_80F51A2, j);
    v2 = sub_80A7B82(v1);
    sub_80A9070(v2);
  }
  return result;
}
// 80F51A2: using guessed type __int16 word_80F51A2;
// 80F5210: using guessed type __int16 word_80F5210;
// 842FDE4: using guessed type int dword_842FDE4;
// 842FDE8: using guessed type __int16 word_842FDE8;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080A9FC0) --------------------------------------------------------
int sub_80A9FC0()
{
  return sub_806C522();
}

//----- (080A9FCE) --------------------------------------------------------
unsigned int sub_80A9FCE()
{
  unsigned int result; // eax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // [esp+12h] [ebp-16h]
  unsigned int j; // [esp+14h] [ebp-14h]
  int v4[2]; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]

  dword_842FDF4 = sub_80A1B2A(4);
  v5 = *dword_842FDF4;
  dword_842FDF4 = sub_80A1B2A(v5);
  dword_8433F6C = sub_80A8FEE();
  word_842FDE8 = sub_80A8E1C();
  dword_842FDEC = sub_806C600(0x20000u);
  dword_842FDF0 = sub_806C600(2 * word_842FDE8 + 2);
  for ( i = 1; i <= word_842FDE8; ++i )
  {
    v2 = sub_80A6A28();
    *(dword_842FDF0 + i) = v2;
    *(dword_842FDEC + v2) = i;
  }
  for ( i = 1; i <= word_842FDE8; ++i )
    sub_80A9B6E(*(dword_842FDF0 + i));
  sub_80A9E6E();
  word_8433F72 = sub_80A9098();
  word_8433F76 = sub_80A9098();
  word_80F5210 = sub_80A9098();
  word_8433F70 = sub_80A9098();
  v4[1] = 7;
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_842FDE4 )
      break;
    LOWORD(v4[0]) = sub_80A9098();
    v1 = sub_80A6E88(word_80F51A2, j);
    sub_80A7590(v1, v4);
  }
  return result;
}
// 80F51A2: using guessed type __int16 word_80F51A2;
// 80F5210: using guessed type __int16 word_80F5210;
// 842FDE4: using guessed type int dword_842FDE4;
// 842FDE8: using guessed type __int16 word_842FDE8;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080AA144) --------------------------------------------------------
void sub_80AA144()
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= word_842FDE8; ++i )
    sub_80A6C02(*(dword_842FDF0 + i));
  sub_806C742(dword_842FDF0);
  sub_806C742(dword_842FDEC);
}
// 842FDE8: using guessed type __int16 word_842FDE8;

//----- (080AA19A) --------------------------------------------------------
int __cdecl sub_80AA19A(char *s1, int a2)
{
  size_t v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  char *s; // [esp+14h] [ebp-4h]
  char *sa; // [esp+14h] [ebp-4h]

  for ( s = dword_842FDF8; *s; s += v4 + 3 )
  {
    v4 = strlen(s) + 1;
    if ( !strcasecmp(s1, s) )
    {
      sa = &s[v4];
      v5 = *sa;
      *a2 = sa[2];
      return v5;
    }
  }
  return 0;
}
// 842FDF8: using guessed type int dword_842FDF8;

//----- (080AA222) --------------------------------------------------------
int __cdecl sub_80AA222(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  size_t v4; // eax
  char *v5; // ebx
  int v7; // [esp+18h] [ebp-30h] BYREF
  int i; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  __int16 v10; // [esp+26h] [ebp-22h]
  int v11; // [esp+28h] [ebp-20h]
  char *dest; // [esp+2Ch] [ebp-1Ch]
  char *s1; // [esp+30h] [ebp-18h]
  char *v14; // [esp+34h] [ebp-14h] BYREF
  char *v15; // [esp+38h] [ebp-10h]
  char v16[4]; // [esp+3Ch] [ebp-Ch] BYREF
  signed int v17; // [esp+40h] [ebp-8h]

  v17 = sub_8065D85(src, v16, 0);
  if ( v17 < 0 )
  {
    v1 = sub_8086D78(&byte_80E7DB4, src);
    sub_80704AC(1, v1);
  }
  v15 = sub_806C4B7(v17 + 1);
  sub_8062853(v15, v17, *v16);
  v15[v17] = 0;
  FS_FCloseFile(*v16);
  v14 = v15;
  sub_808521C("Scr_AddFields");
  while ( 1 )
  {
    s1 = sub_8085E0B(&v14);
    if ( !v14 )
      break;
    if ( !strcmp(s1, "float") )
    {
      v11 = 4;
    }
    else if ( !strcmp(s1, "int") )
    {
      v11 = 5;
    }
    else
    {
      if ( strcmp(s1, "string") )
      {
        v2 = sub_8086D78(&byte_80E7DD4, s1, src);
        sub_80704AC(1, v2);
      }
      v11 = 1;
    }
    s1 = sub_8085E0B(&v14);
    if ( !v14 )
    {
      v3 = sub_8086D78(&byte_80E7DEF, src);
      sub_80704AC(1, v3);
    }
    v4 = strlen(s1);
    v17 = v4 + 1;
    for ( i = v4; i >= 0; --i )
    {
      v5 = &s1[i];
      *v5 = tolower(s1[i]);
    }
    v10 = sub_80A21CA(s1);
    if ( v10 )
    {
      if ( sub_80AA19A(s1, &v7) )
        sub_80704AC(1, &byte_80E7E0B, s1, src);
      v9 = v17 + 3;
      dest = sub_80A5458(v17 + 3);
      strcpy(dest, s1);
      dest += v17;
      *dest = v10;
      dest += 2;
      *dest++ = v11;
      *dest = 0;
    }
  }
  sub_80852BD();
  return sub_806C522();
}

//----- (080AA49A) --------------------------------------------------------
int __cdecl sub_80AA49A(char *a1, char *a2)
{
  char s[68]; // [esp+20h] [ebp-58h] BYREF
  int i; // [esp+64h] [ebp-14h]
  void *ptr; // [esp+68h] [ebp-10h]
  int v6[3]; // [esp+6Ch] [ebp-Ch] BYREF

  ptr = sub_8063EFC(a1, a2, v6);
  sub_80A5448();
  dword_842FDF8 = sub_806C531(0);
  *dword_842FDF8 = 0;
  for ( i = 0; i < v6[0]; ++i )
  {
    sprintf(s, "%s/%s", a1, *(ptr + i));
    sub_80AA222(s);
  }
  if ( ptr )
    sub_8063F25(ptr);
  *sub_80A5458(1) = 0;
  return sub_806C5F1();
}
// 842FDF8: using guessed type int dword_842FDF8;

//----- (080AA558) --------------------------------------------------------
int __cdecl sub_80AA558(unsigned __int16 a1)
{
  return sub_80A6C02(a1);
}

//----- (080AA574) --------------------------------------------------------
int __cdecl sub_80AA574(unsigned __int16 a1)
{
  int v3; // [esp+18h] [ebp-10h]
  unsigned __int16 v4; // [esp+1Eh] [ebp-Ah]

  if ( (dword_832FDE0[3 * a1 + 1] & 0x1F) != 15 )
    return 0;
  while ( 2 )
  {
    v4 = sub_80A7A30(a1);
LABEL_4:
    if ( v4 )
    {
      v3 = dword_832FDE0[3 * v4 + 1] >> 8;
      switch ( dword_832FDE0[3 * v4 + 1] & 0x1F )
      {
        case 6:
        case 9:
        case 0xA:
        case 0xB:
          goto LABEL_6;
        case 7:
          if ( sub_80AA574(LOWORD(dword_832FDE0[3 * v4])) )
            goto LABEL_8;
LABEL_6:
          sub_80A7240(a1, v3);
          continue;
        default:
LABEL_8:
          v4 = sub_80A7A30(v4);
          goto LABEL_4;
      }
    }
    return 1;
  }
}
// 832FDE0: using guessed type int dword_832FDE0[];

//----- (080AA678) --------------------------------------------------------
void sub_80AA678()
{
  if ( !word_8433F74 )
  {
    word_8433F74 = sub_80A69FA();
    sub_80A8BE6(word_8433F74);
  }
}
// 8433F74: using guessed type __int16 word_8433F74;

//----- (080AA6A6) --------------------------------------------------------
int __cdecl sub_80AA6A6(int a1)
{
  int result; // eax

  if ( !a1 )
    return sub_80AA574(dword_832FDE0[3 * word_8433F74]);
  result = sub_80A6B96(word_8433F74);
  word_8433F74 = 0;
  return result;
}
// 832FDE0: using guessed type int dword_832FDE0[];
// 8433F74: using guessed type __int16 word_8433F74;

//----- (080AA6FA) --------------------------------------------------------
int __cdecl sub_80AA6FA(_DWORD *a1)
{
  int result; // eax

  *a1 = dword_80F51A4;
  a1[1] = dword_80F516C;
  result = dword_80F5168 - dword_80F5164;
  a1[2] = dword_80F5168 - dword_80F5164;
  return result;
}
// 80F5164: using guessed type int dword_80F5164;
// 80F5168: using guessed type int dword_80F5168;
// 80F516C: using guessed type int dword_80F516C;
// 80F51A4: using guessed type int dword_80F51A4;

//----- (080AA72C) --------------------------------------------------------
int __cdecl sub_80AA72C(int *a1)
{
  return sub_80A6D4E(a1[1], *a1);
}

//----- (080AA74C) --------------------------------------------------------
int __cdecl sub_80AA74C(int *a1)
{
  return sub_80A6DA0(a1[1], *a1);
}

//----- (080AA76C) --------------------------------------------------------
int sub_80AA76C()
{
  int result; // eax

  dword_8433E00 = &unk_8433DF8;
  dword_8433F68 = &unk_842FE00;
  dword_80F520C = 0;
  *dword_8433EA0 = 0;
  dword_8433EA4 = 0;
  dword_8433EA8 = 0;
  byte_8433EAC = 0;
  dword_8433F64 = 0;
  dword_8433F60 = 0;
  result = sub_80A69FA();
  word_80F5212 = result;
  word_80F5210 = 0;
  word_8433F70 = 0;
  word_8433F72 = 0;
  word_8433F74 = 0;
  word_8433F76 = 0;
  dword_842FE04 = 6;
  dword_8433EB0 = 0;
  return result;
}
// 80F520C: using guessed type int dword_80F520C;
// 80F5210: using guessed type __int16 word_80F5210;
// 80F5212: using guessed type __int16 word_80F5212;
// 842FE04: using guessed type int dword_842FE04;
// 8433E00: using guessed type int dword_8433E00;
// 8433EA4: using guessed type int dword_8433EA4;
// 8433EA8: using guessed type int dword_8433EA8;
// 8433EAC: using guessed type char byte_8433EAC;
// 8433EB0: using guessed type int dword_8433EB0;
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F74: using guessed type __int16 word_8433F74;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080AA818) --------------------------------------------------------
int __cdecl sub_80AA818(int a1, int a2, int a3)
{
  int result; // eax

  dword_829FA00 = a1;
  dword_829FA04 = a2;
  dword_829FA08 = a3;
  sub_80A5A96();
  result = sub_80AA76C();
  byte_829F9EC = 0;
  byte_829F9ED = 0;
  word_829F9EE = 0;
  word_829F9F0 = 0;
  word_829F9F2 = 0;
  byte_80F5214 = 1;
  return result;
}
// 80F5214: using guessed type char byte_80F5214;
// 829F9EC: using guessed type char byte_829F9EC;
// 829F9ED: using guessed type char byte_829F9ED;
// 829F9EE: using guessed type __int16 word_829F9EE;
// 829F9F0: using guessed type __int16 word_829F9F0;
// 829F9F2: using guessed type __int16 word_829F9F2;
// 829FA00: using guessed type int dword_829FA00;
// 829FA04: using guessed type int dword_829FA04;
// 829FA08: using guessed type int dword_829FA08;

//----- (080AA872) --------------------------------------------------------
void sub_80AA872()
{
  if ( byte_80F5214 )
    byte_80F5214 = 0;
}
// 80F5214: using guessed type char byte_80F5214;

//----- (080AA88A) --------------------------------------------------------
void sub_80AA88A()
{
  word_80F5210 = 0;
  byte_80F5214 = 0;
}
// 80F5210: using guessed type __int16 word_80F5210;
// 80F5214: using guessed type char byte_80F5214;

//----- (080AA8A0) --------------------------------------------------------
int __cdecl sub_80AA8A0(int a1)
{
  int result; // eax

  result = a1;
  dword_8433EB0 = a1;
  return result;
}
// 8433EB0: using guessed type int dword_8433EB0;

//----- (080AA8AE) --------------------------------------------------------
void __noreturn sub_80AA8AE()
{
  void *v0; // ebx

  if ( dword_80F520C )
  {
    v0 = __cxa_allocate_exception(1u);
    sub_80B0892();
    __cxa_throw(v0, &`typeinfo for'ScriptErrorClass, 0);
  }
  sub_80704AC(1, &byte_80E7E60, dword_8433EA0[0]);
}
// 80AA8AE: using guessed type void __noreturn sub_80AA8AE();
// 80F520C: using guessed type int dword_80F520C;
// 80F5218: using guessed type char (*`typeinfo for'ScriptErrorClass)[44];

//----- (080AA922) --------------------------------------------------------
_BOOL4 __cdecl sub_80AA922(char *a1)
{
  while ( *a1 <= 32 )
  {
    if ( !*a1 )
      return 0;
    ++a1;
  }
  if ( *a1 == 45 || *a1 == 43 )
    ++a1;
  if ( *a1 == 48 )
    return 1;
  if ( *a1 == 46 )
    return a1[1] == 48;
  return 0;
}

//----- (080AA9A0) --------------------------------------------------------
int __cdecl sub_80AA9A0(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  if ( *(a1 + 4) == 4 )
  {
    *(a1 + 4) = 5;
    *a1 = 0.0 != *a1;
    v5 = 1;
  }
  else if ( *(a1 + 4) == 1 )
  {
    v6 = *a1;
    v1 = sub_80A4458(*a1);
    *a1 = atoi(v1) != 0;
    if ( *a1 || (v2 = sub_80A4458(v6), sub_80AA922(v2)) )
    {
      *(a1 + 4) = 5;
      sub_80A509E(v6);
      v5 = 1;
    }
    else
    {
      v3 = sub_80A4458(v6);
      *dword_8433EA0 = sub_8086D78("cannot cast \"%s\" to bool", v3);
      sub_80A509E(v6);
      *(a1 + 4) = 0;
      v5 = 0;
    }
  }
  else
  {
    *dword_8433EA0 = sub_8086D78("cannot cast %s to bool", *&off_80F51C0[4 * *(a1 + 4)]);
    sub_80AA74C(a1);
    *(a1 + 4) = 0;
    v5 = 0;
  }
  return v5;
}

//----- (080AAAE2) --------------------------------------------------------
int __cdecl sub_80AAAE2(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  switch ( *(a1 + 4) )
  {
    case 5:
      return 1;
    case 4:
      *(a1 + 4) = 5;
      *a1 = *a1;
      v5 = 1;
      break;
    case 1:
      v6 = *a1;
      v1 = sub_80A4458(*a1);
      *a1 = atoi(v1);
      if ( *a1 || (v2 = sub_80A4458(v6), sub_80AA922(v2)) )
      {
        *(a1 + 4) = 5;
        sub_80A509E(v6);
        v5 = 1;
      }
      else
      {
        v3 = sub_80A4458(v6);
        *dword_8433EA0 = sub_8086D78("cannot cast \"%s\" to int", v3);
        sub_80A509E(v6);
        *(a1 + 4) = 0;
        v5 = 0;
      }
      break;
    default:
      *dword_8433EA0 = sub_8086D78("cannot cast %s to int", *&off_80F51C0[4 * *(a1 + 4)]);
      sub_80AA74C(a1);
      *(a1 + 4) = 0;
      v5 = 0;
      break;
  }
  return v5;
}

//----- (080AAC34) --------------------------------------------------------
int __cdecl sub_80AAC34(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  switch ( *(a1 + 4) )
  {
    case 4:
      return 1;
    case 5:
      *(a1 + 4) = 4;
      *a1 = *a1;
      v5 = 1;
      break;
    case 1:
      v6 = *a1;
      v1 = sub_80A4458(*a1);
      *a1 = atof(v1);
      if ( *a1 == 0.0 && (v2 = sub_80A4458(v6), !sub_80AA922(v2)) )
      {
        v3 = sub_80A4458(v6);
        *dword_8433EA0 = sub_8086D78("cannot cast \"%s\" to float", v3);
        sub_80A509E(v6);
        *(a1 + 4) = 0;
        v5 = 0;
      }
      else
      {
        *(a1 + 4) = 4;
        sub_80A509E(v6);
        v5 = 1;
      }
      break;
    default:
      *dword_8433EA0 = sub_8086D78("cannot cast %s to float", *&off_80F51C0[4 * *(a1 + 4)]);
      sub_80AA74C(a1);
      *(a1 + 4) = 0;
      v5 = 0;
      break;
  }
  return v5;
}

//----- (080AAD7C) --------------------------------------------------------
int __cdecl sub_80AAD7C(int *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  switch ( a1[1] )
  {
    case 1:
      return 1;
    case 5:
      a1[1] = 1;
      *a1 = sub_80A51FE(*a1);
      v2 = 1;
      break;
    case 4:
      a1[1] = 1;
      *a1 = sub_80A51B4(*a1);
      v2 = 1;
      break;
    case 3:
      a1[1] = 1;
      v3 = *a1;
      *a1 = sub_80A5248(*a1);
      sub_80A6CF8(v3);
      v2 = 1;
      break;
    default:
      *dword_8433EA0 = sub_8086D78("cannot cast %s to string", *&off_80F51C0[4 * a1[1]]);
      sub_80AA74C(a1);
      a1[1] = 0;
      v2 = 0;
      break;
  }
  return v2;
}

//----- (080AAE80) --------------------------------------------------------
int __cdecl sub_80AAE80(int *a1)
{
  if ( a1[1] == 2 )
    return 1;
  *dword_8433EA0 = sub_8086D78("cannot cast %s to istring", *&off_80F51C0[4 * a1[1]]);
  sub_80AA74C(a1);
  a1[1] = 0;
  return 0;
}

//----- (080AAEDC) --------------------------------------------------------
int __cdecl sub_80AAEDC(int *a1)
{
  if ( a1[1] == 3 )
    return 1;
  *dword_8433EA0 = sub_8086D78("cannot cast %s to vector", *&off_80F51C0[4 * a1[1]]);
  sub_80AA74C(a1);
  a1[1] = 0;
  return 0;
}

//----- (080AAF38) --------------------------------------------------------
int __cdecl sub_80AAF38(int *a1)
{
  if ( a1[1] == 7 )
    return 1;
  *dword_8433EA0 = sub_8086D78("cannot cast %s to object", *&off_80F51C0[4 * a1[1]]);
  sub_80AA74C(a1);
  a1[1] = 0;
  return 0;
}

//----- (080AAF94) --------------------------------------------------------
_DWORD *__cdecl sub_80AAF94(_DWORD *a1)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-1Ch]
  int v3[6]; // [esp+20h] [ebp-18h] BYREF

  for ( i = 2; i >= 0; --i )
  {
    if ( !sub_80AAC34(&a1[2 * i]) )
    {
      dword_8433EA8 = i;
      sub_80AA8AE();
    }
    v3[2 - i] = a1[2 * i];
  }
  a1[1] = 3;
  result = sub_80A6C8C(v3);
  *a1 = result;
  return result;
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080AB014) --------------------------------------------------------
int __cdecl sub_80AB014(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 2; i >= 0; --i )
    sub_80AA74C((a1 + 8 * i));
  result = a1;
  *(a1 + 4) = 0;
  return result;
}

//----- (080AB04E) --------------------------------------------------------
int *__cdecl sub_80AB04E(int *a1, int *a2)
{
  int *result; // eax

  *dword_8433EA0 = sub_8086D78(
                     "pair has unmatching types '%s' and '%s'",
                     *&off_80F51C0[4 * dword_8433EB4],
                     *&off_80F51C0[4 * dword_8433EB8]);
  sub_80AA74C(a1);
  a1[1] = 0;
  sub_80AA74C(a2);
  result = a2;
  a2[1] = 0;
  return result;
}
// 8433EB4: using guessed type int dword_8433EB4;
// 8433EB8: using guessed type int dword_8433EB8;

//----- (080AB0B2) --------------------------------------------------------
int __cdecl sub_80AB0B2(int a1, int a2)
{
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+20h] [ebp-8h]

  dword_8433EB4 = *(a1 + 4);
  dword_8433EB8 = *(a2 + 4);
  if ( dword_8433EB4 != dword_8433EB8 )
  {
    if ( dword_8433EB4 >= dword_8433EB8 )
    {
      if ( dword_8433EB8 == 1 )
      {
        if ( dword_8433EB4 == 4 )
        {
          *(a1 + 4) = 1;
          *a1 = sub_80A51B4(*a1);
          return 1;
        }
        if ( dword_8433EB4 > 4 )
        {
          if ( dword_8433EB4 == 5 )
          {
            *(a1 + 4) = 1;
            *a1 = sub_80A51FE(*a1);
            return 1;
          }
        }
        else if ( dword_8433EB4 == 3 )
        {
          *(a1 + 4) = 1;
          v5 = *a1;
          *a1 = sub_80A5248(*a1);
          sub_80A6CF8(SLODWORD(v5));
          return 1;
        }
      }
      else if ( dword_8433EB8 != 4 )
      {
        goto LABEL_32;
      }
      if ( dword_8433EB4 == 5 )
      {
        *(a1 + 4) = 4;
        *a1 = *a1;
        return 1;
      }
    }
    else
    {
      if ( dword_8433EB4 == 1 )
      {
        if ( dword_8433EB8 == 4 )
        {
          *(a2 + 4) = 1;
          *a2 = sub_80A51B4(*a2);
          return 1;
        }
        if ( dword_8433EB8 > 4 )
        {
          if ( dword_8433EB8 == 5 )
          {
            *(a2 + 4) = 1;
            *a2 = sub_80A51FE(*a2);
            return 1;
          }
        }
        else if ( dword_8433EB8 == 3 )
        {
          *(a2 + 4) = 1;
          v4 = *a2;
          *a2 = sub_80A5248(*a2);
          sub_80A6CF8(SLODWORD(v4));
          return 1;
        }
      }
      else if ( dword_8433EB4 != 4 )
      {
        goto LABEL_32;
      }
      if ( dword_8433EB8 == 5 )
      {
        *(a2 + 4) = 4;
        *a2 = *a2;
        return 1;
      }
    }
LABEL_32:
    sub_80AB04E(a1, a2);
    return 0;
  }
  return 1;
}
// 8433EB4: using guessed type int dword_8433EB4;
// 8433EB8: using guessed type int dword_8433EB8;

//----- (080AB30E) --------------------------------------------------------
int __cdecl sub_80AB30E(int a1, unsigned __int16 *a2)
{
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  _BOOL4 v6; // [esp+20h] [ebp-8h]
  _BOOL4 v7; // [esp+20h] [ebp-8h]

  if ( !sub_80AB0B2(a1, a2) )
    return 0;
  switch ( *(a1 + 4) )
  {
    case 0:
      *(a1 + 4) = 5;
      *a1 = 1;
      v5 = 1;
      break;
    case 1:
    case 2:
      *(a1 + 4) = 5;
      v6 = *a1 == *a2;
      sub_80A509E(*a1);
      sub_80A509E(*a2);
      *a1 = v6;
      v5 = 1;
      break;
    case 3:
      *(a1 + 4) = 5;
      v4 = 0;
      if ( **a1 == **a2 && *(*a1 + 4) == *(*a2 + 4) && *(*a1 + 8) == *(*a2 + 8) )
        v4 = 1;
      sub_80A6CF8(*a1);
      sub_80A6CF8(*a2);
      *a1 = v4;
      v5 = 1;
      break;
    case 4:
      *(a1 + 4) = 5;
      v3 = *a1 - *a2;
      *a1 = sub_80B085C(v3) < 0.000001;
      v5 = 1;
      break;
    case 5:
      *a1 = *a1 == *a2;
      v5 = 1;
      break;
    case 7:
      *(a1 + 4) = 5;
      v7 = *a1 == *a2;
      sub_80A6C02(*a1);
      sub_80A6C02(*a2);
      *a1 = v7;
      v5 = 1;
      break;
    case 0xB:
      *(a1 + 4) = 5;
      *a1 = *a1 == *a2;
      v5 = 1;
      break;
    default:
      sub_80AB04E(a1, a2);
      v5 = 0;
      break;
  }
  return v5;
}

//----- (080AB56A) --------------------------------------------------------
int __cdecl sub_80AB56A(int *a1, char *a2, unsigned __int16 a3, unsigned __int16 a4, int a5)
{
  unsigned __int16 v5; // ax
  int v6; // edx
  int v7; // edx
  int v8; // edx
  unsigned __int16 v9; // ax
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // ax
  char *v14; // eax
  char *v15; // eax
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // ax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // eax
  char *v22; // eax
  char *v23; // eax
  int v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *v27; // eax
  unsigned __int16 v28; // ax
  unsigned __int16 v29; // ax
  char *v30; // eax
  unsigned __int16 v31; // ax
  int v32; // eax
  char *v33; // eax
  char *v34; // eax
  unsigned __int16 v35; // ax
  int v36; // eax
  char *v37; // eax
  char *v38; // eax
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  unsigned __int16 v43; // ax
  unsigned __int16 v44; // ax
  unsigned __int16 v45; // ax
  unsigned __int16 v46; // ax
  unsigned __int16 v47; // ax
  unsigned __int16 v48; // ax
  unsigned __int16 v49; // ax
  unsigned __int16 v50; // ax
  int v51; // eax
  char *v52; // eax
  char *v53; // eax
  int v54; // eax
  char *v55; // eax
  char *v56; // eax
  unsigned __int16 v57; // ax
  unsigned __int16 v58; // ax
  unsigned __int16 v59; // ax
  unsigned __int16 v60; // ax
  unsigned __int16 v61; // ax
  unsigned __int16 v62; // ax
  unsigned __int16 v63; // ax
  int v64; // eax
  char *v65; // eax
  char *v66; // eax
  char *v67; // eax
  char *v68; // eax
  float v70; // [esp+0h] [ebp-A8h]
  float v71; // [esp+0h] [ebp-A8h]
  int v72; // [esp+28h] [ebp-80h]
  int v73; // [esp+2Ch] [ebp-7Ch]
  int v74; // [esp+30h] [ebp-78h]
  int v75; // [esp+34h] [ebp-74h]
  int v76; // [esp+38h] [ebp-70h]
  int v77; // [esp+3Ch] [ebp-6Ch]
  int v78; // [esp+40h] [ebp-68h]
  int v79; // [esp+44h] [ebp-64h]
  int v80; // [esp+48h] [ebp-60h]
  int v81; // [esp+50h] [ebp-58h]
  int v83; // [esp+64h] [ebp-44h]
  char v84; // [esp+69h] [ebp-3Fh]
  unsigned __int16 v85; // [esp+6Ah] [ebp-3Eh]
  unsigned __int16 *v86; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v87; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v88; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v89; // [esp+6Ch] [ebp-3Ch]
  float *v90; // [esp+70h] [ebp-38h]
  float *v91; // [esp+70h] [ebp-38h]
  int v92; // [esp+74h] [ebp-34h]
  int v93; // [esp+74h] [ebp-34h]
  int v94; // [esp+74h] [ebp-34h]
  int v95; // [esp+74h] [ebp-34h]
  int v96; // [esp+78h] [ebp-30h]
  __int16 v97; // [esp+7Eh] [ebp-2Ah]
  unsigned __int16 v98; // [esp+7Eh] [ebp-2Ah]
  unsigned __int16 v99; // [esp+7Eh] [ebp-2Ah]
  float v100; // [esp+80h] [ebp-28h]
  int v101; // [esp+84h] [ebp-24h]
  int v102; // [esp+84h] [ebp-24h]
  int v103; // [esp+84h] [ebp-24h]
  int v104; // [esp+84h] [ebp-24h]
  int v105; // [esp+84h] [ebp-24h]
  int v106; // [esp+84h] [ebp-24h]
  int v107; // [esp+84h] [ebp-24h]
  int v108; // [esp+84h] [ebp-24h]
  _BOOL4 v109; // [esp+84h] [ebp-24h]
  _BOOL4 v110; // [esp+84h] [ebp-24h]
  int v111; // [esp+84h] [ebp-24h]
  int v112; // [esp+88h] [ebp-20h] BYREF
  int v113; // [esp+8Ch] [ebp-1Ch]
  int v114; // [esp+94h] [ebp-14h]
  unsigned __int16 v115; // [esp+9Ah] [ebp-Eh]
  unsigned __int16 v116; // [esp+9Ch] [ebp-Ch]
  unsigned __int16 v117; // [esp+9Eh] [ebp-Ah]
  int *i; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v119; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v120; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v121; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v122; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v123; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v124; // [esp+B0h] [ebp+8h]
  void (**v125)(void); // [esp+B4h] [ebp+Ch]
  void (__cdecl **v126)(int); // [esp+B4h] [ebp+Ch]
  _BYTE *v127; // [esp+B4h] [ebp+Ch]

  v117 = a3;
  v116 = a4;
  v83 = 0;
LABEL_2:
  while ( 2 )
  {
    v84 = *a2++;
LABEL_3:
    switch ( v84 )
    {
      case 0:
        sub_80A65BA(v117);
        while ( a1[1] != 6 )
        {
          sub_80AA74C(a1);
          a1 -= 2;
        }
        --dword_80F520C;
        if ( a1 == a5 )
        {
          *(a5 + 12) = 0;
          return v117;
        }
        sub_80A6C02(v117);
        a2 = *a1;
        a1 -= 2;
        v117 = *a1;
        a1[1] = 0;
        v5 = sub_80A6B34(v117);
        if ( !sub_80A7BB2(v5) )
          goto LABEL_10;
        continue;
      case 1:
        sub_80A65BA(v117);
        v6 = a1[1];
        v112 = *a1;
        v113 = v6;
        for ( i = a1 - 2; i[1] != 6; i -= 2 )
          sub_80AA74C(i);
        --dword_80F520C;
        if ( i == a5 )
        {
          v7 = v113;
          *(a5 + 8) = v112;
          *(a5 + 12) = v7;
          return v117;
        }
        sub_80A6C02(v117);
        a2 = *i;
        a1 = i - 2;
        v117 = *a1;
        v8 = v113;
        *a1 = v112;
        a1[1] = v8;
        v9 = sub_80A6B34(v117);
        if ( !sub_80A7BB2(v9) )
          goto LABEL_10;
        continue;
      case 2:
        a1 += 2;
        a1[1] = 0;
        continue;
      case 3:
        a1 += 2;
        a1[1] = 5;
        *a1 = *a2;
        a2 += 4;
        continue;
      case 4:
        a1 += 2;
        a1[1] = 4;
        *a1 = *a2;
        a2 += 4;
        continue;
      case 5:
        a1 += 2;
        a1[1] = 1;
        *a1 = *a2;
        sub_80A4F00(*a1);
        a2 += 2;
        continue;
      case 6:
        a1 += 2;
        a1[1] = 2;
        *a1 = *a2;
        sub_80A4F00(*a1);
        a2 += 2;
        continue;
      case 7:
        v115 = sub_80A6B34(v117);
        continue;
      case 8:
        v115 = word_8433F72;
        continue;
      case 9:
        v115 = word_8433F76;
        continue;
      case 10:
        a1 += 2;
        a1[1] = 7;
        *a1 = sub_80A6B34(v117);
        sub_80A6BC6(*a1);
        continue;
      case 11:
        a1 += 2;
        a1[1] = 7;
        *a1 = word_8433F72;
        sub_80A6BC6(word_8433F72);
        continue;
      case 12:
        a1 += 2;
        sub_80A779A(word_8433F74, a1);
        sub_80AA72C(a1);
        continue;
      case 13:
        a1 += 2;
        a1[1] = 7;
        *a1 = word_8433F76;
        sub_80A6BC6(word_8433F76);
        continue;
      case 14:
        a1 += 2;
        a1[1] = 11;
        *a1 = *a2;
        a2 += 4;
        continue;
      case 15:
        v115 = word_8433F74;
        continue;
      case 16:
        a1 += 2;
        a1[1] = 9;
        *a1 = *a2;
        a2 += 4;
        continue;
      case 17:
        a1 += 2;
        v10 = sub_80A71D8(v117, *a2);
        sub_80A779A(v10, a1);
        sub_80AA72C(a1);
        a2 += 2;
        continue;
      case 18:
        v115 = sub_80A71D8(v117, *a2);
        a2 += 2;
        continue;
      case 19:
        sub_80A7352(v117, *a2);
        a2 += 2;
        continue;
      case 20:
        a1 -= 2;
        sub_80A81B4(a1, a1 + 4);
        continue;
      case 21:
        v115 = sub_80A8726(v115, a1);
        a1 -= 2;
        continue;
      case 22:
        sub_80A89BE(v115, a1);
        a1 -= 2;
        continue;
      case 23:
        a1 += 2;
        sub_80A8BC4(a1);
        continue;
      case 24:
        a1 += 2;
        v11 = sub_80A6F20(v115, *a2);
        sub_80A77DE(v11, a1);
        a2 += 2;
        continue;
      case 25:
        v115 = sub_80A6F20(v115, *a2);
        a2 += 2;
        continue;
      case 26:
        sub_80A70B6(v115, *a2);
        a2 += 2;
        continue;
      case 27:
        v115 = word_80F5212;
        sub_80A7590(word_80F5212, a1);
        a1 -= 2;
        continue;
      case 28:
        if ( a1[1] != 6 )
        {
          v12 = sub_80A71D8(v117, *a2);
          sub_80A76C8(v12, a1);
          a1 -= 2;
        }
        a2 += 2;
        continue;
      case 29:
        if ( a1[1] == 6 )
        {
          sub_80A7352(v117, *a2);
        }
        else
        {
          v13 = sub_80A71D8(v117, *a2);
          sub_80A76C8(v13, a1);
          a1 -= 2;
        }
        a2 += 2;
        continue;
      case 30:
        while ( a1[1] != 6 )
        {
          sub_80AA74C(a1);
          a1 -= 2;
        }
        continue;
      case 31:
        if ( a1[1] != 6 )
          sub_80B04E8("function called with too many parameters");
        continue;
      case 32:
        sub_80A76C8(v115, a1);
        a1 -= 2;
        continue;
      case 33:
        dword_8433F64 = *a2;
        v125 = (a2 + 1);
        dword_8433F68 = a1;
        (*v125)();
        a2 = (v125 + 1);
        a1 = dword_8433F68;
        if ( dword_8433F64 )
        {
          v114 = dword_8433F64;
          dword_8433F64 = 0;
          dword_8433F68 -= 8 * v114;
          do
          {
            sub_80AA74C(a1);
            a1 -= 2;
            --v114;
          }
          while ( v114 );
        }
        if ( dword_8433F60 )
        {
          dword_8433F60 = 0;
        }
        else
        {
          a1 += 2;
          a1[1] = 0;
        }
        continue;
      case 34:
        dword_8433F64 = *a2;
        v126 = (a2 + 1);
        dword_8433F68 = (a1 - 2);
        if ( a1[1] != 7 )
        {
          v103 = a1[1];
          sub_80AA74C(a1);
          dword_8433EA8 = -1;
          v15 = sub_8086D78("%s is not an entity", *&off_80F51C0[4 * v103]);
          sub_80B04E8(v15);
        }
        v115 = *a1;
        if ( sub_80A7D0A(v115) != 13 )
        {
          v102 = sub_80A7D0A(v115);
          sub_80A6C02(v115);
          dword_8433EA8 = -1;
          v14 = sub_8086D78("%s is not an entity", *&off_80F51C0[4 * v102]);
          sub_80B04E8(v14);
        }
        v101 = sub_80A8C30(v115);
        sub_80A6C02(v115);
        (*v126)(v101);
        a2 = (v126 + 1);
        a1 = dword_8433F68;
        if ( dword_8433F64 )
        {
          v114 = dword_8433F64;
          dword_8433F64 = 0;
          dword_8433F68 -= 8 * v114;
          do
          {
            sub_80AA74C(a1);
            a1 -= 2;
            --v114;
          }
          while ( v114 );
        }
        if ( dword_8433F60 )
        {
          dword_8433F60 = 0;
        }
        else
        {
          a1 += 2;
          a1[1] = 0;
        }
        continue;
      case 35:
        if ( v83 )
          sub_80B04E8("wait not allowed in /# ... #/ comment (call as a thread to fix)");
        if ( !sub_80AAC34(a1) )
          sub_80AA8AE();
        v100 = *a1;
        if ( *a1 < 0.0 )
        {
          v19 = sub_8086D78("negative wait of %g is not allowed", v100);
          sub_80B04E8(v19);
        }
        if ( v100 >= 16777.0 )
        {
          v18 = sub_8086D78("wait of %.0f seconds is too long", v100);
          sub_80B04E8(v18);
        }
        v70 = v100 * 1000.0;
        v104 = (dword_8433F6C + sub_80B082E(v70)) & 0xFFFFFF;
        v16 = sub_80A71D8(word_80F5210, v104);
        v17 = sub_80A7B26(v16);
        sub_80A7206(v17, v116);
        sub_80AE052((a1 - a5 - 8) >> 3, a2, v117, v116, a5, v104);
        *(a5 + 12) = 0;
        return v116;
      case 36:
        v119 = (a1 + 2);
        sub_80A6BC6(v117);
        *(v119 + 1) = 7;
        *v119 = v117;
        a1 = (v119 + 4);
        a1[1] = 0;
        continue;
      case 37:
        sub_80A6C02(v117);
        if ( dword_80F520C > 31 )
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        dword_8433E20[dword_80F520C++] = a2;
        v115 = sub_80A6B34(v117);
        sub_80A6BC6(v115);
        v117 = sub_80A6AEC(v115);
        a1[-2 * *(a2 + 1) + 1] = 6;
        a1[-2 * *(a2 + 1)] = (a2 + 8);
        a2 = *a2;
        continue;
      case 38:
        sub_80A6C02(v117);
        if ( a1[1] != 9 )
        {
          v20 = sub_8086D78("%s is not a function pointer", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v20);
        }
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v92 = *a1;
        a1 -= 2;
        v115 = sub_80A6B34(v117);
        sub_80A6BC6(v115);
        v117 = sub_80A6AEC(v115);
        a1[-2 * *a2 + 1] = 6;
        a1[-2 * *a2] = (a2 + 4);
        a2 = v92;
        continue;
      case 39:
        sub_80A6C02(v117);
        if ( a1[1] != 7 )
        {
          v23 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v23);
        }
        if ( !sub_80A7BB2(*a1) )
        {
          dword_8433EA8 = 1;
          v21 = sub_80A7D0A(*a1);
          v22 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v21]);
          sub_80B04E8(v22);
        }
        if ( dword_80F520C > 31 )
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        dword_8433E20[dword_80F520C++] = a2;
        v117 = sub_80A6AEC(*a1);
        a1 -= 2;
        a1[-2 * *(a2 + 1) + 1] = 6;
        a1[-2 * *(a2 + 1)] = (a2 + 8);
        a2 = *a2;
        continue;
      case 40:
        sub_80A6C02(v117);
        if ( a1[1] != 9 )
        {
          sub_80AA74C(a1);
          v27 = sub_8086D78("%s is not a function pointer", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v27);
        }
        v93 = *a1;
        v120 = (a1 - 2);
        if ( *(v120 + 1) != 7 )
        {
          dword_8433EA8 = 2;
          v26 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * *(v120 + 1)]);
          sub_80B04E8(v26);
        }
        if ( !sub_80A7BB2(*v120) )
        {
          dword_8433EA8 = 2;
          v24 = sub_80A7D0A(*v120);
          v25 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v24]);
          sub_80B04E8(v25);
        }
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v117 = sub_80A6AEC(*v120);
        a1 = (v120 - 4);
        a1[-2 * *a2 + 1] = 6;
        a1[-2 * *a2] = (a2 + 4);
        a2 = v93;
        continue;
      case 41:
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v115 = sub_80A6B34(v117);
        sub_80A6BC6(v115);
        v115 = sub_80A6AEC(v115);
        v86 = &a1[-2 * *(a2 + 1)];
        v105 = *(v86 + 1);
        *(v86 + 1) = 6;
        v28 = sub_80AB56A(a1, *a2, v115, v115, v86);
        sub_80A6C02(v28);
        *(v86 + 1) = v105;
        a1 = (v86 + 4);
        a2 += 8;
        continue;
      case 42:
        if ( a1[1] != 9 )
        {
          v30 = sub_8086D78("%s is not a function pointer", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v30);
        }
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v94 = *a1;
        v121 = (a1 - 2);
        v115 = sub_80A6B34(v117);
        sub_80A6BC6(v115);
        v115 = sub_80A6AEC(v115);
        v87 = &v121[-4 * *a2];
        v106 = *(v87 + 1);
        *(v87 + 1) = 6;
        v29 = sub_80AB56A(v121, v94, v115, v115, v87);
        sub_80A6C02(v29);
        *(v87 + 1) = v106;
        a1 = (v87 + 4);
        a2 += 4;
        continue;
      case 43:
        if ( a1[1] != 7 )
        {
          dword_8433EA8 = 2;
          v34 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v34);
        }
        if ( !sub_80A7BB2(*a1) )
        {
          dword_8433EA8 = 2;
          v32 = sub_80A7D0A(*a1);
          v33 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v32]);
          sub_80B04E8(v33);
        }
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v115 = sub_80A6AEC(*a1);
        v122 = (a1 - 2);
        v88 = &v122[-4 * *(a2 + 1)];
        v107 = *(v88 + 1);
        *(v88 + 1) = 6;
        v31 = sub_80AB56A(v122, *a2, v115, v115, v88);
        sub_80A6C02(v31);
        *(v88 + 1) = v107;
        a1 = (v88 + 4);
        a2 += 8;
        continue;
      case 44:
        if ( a1[1] != 9 )
        {
          sub_80AA74C(a1);
          v39 = sub_8086D78("%s is not a function pointer", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v39);
        }
        v95 = *a1;
        v123 = (a1 - 2);
        if ( *(v123 + 1) != 7 )
        {
          dword_8433EA8 = 2;
          v38 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * *(v123 + 1)]);
          sub_80B04E8(v38);
        }
        if ( !sub_80A7BB2(*v123) )
        {
          dword_8433EA8 = 2;
          v36 = sub_80A7D0A(*v123);
          v37 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v36]);
          sub_80B04E8(v37);
        }
        if ( dword_80F520C > 31 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("script stack overflow (too many embedded function calls)");
        }
        dword_8433E20[dword_80F520C++] = a2;
        v115 = sub_80A6AEC(*v123);
        v124 = v123 - 4;
        v89 = &v124[-4 * *a2];
        v108 = *(v89 + 1);
        *(v89 + 1) = 6;
        v35 = sub_80AB56A(v124, v95, v115, v115, v89);
        sub_80A6C02(v35);
        *(v89 + 1) = v108;
        a1 = (v89 + 4);
        a2 += 4;
        continue;
      case 45:
        sub_80AA74C(a1);
        a1 -= 2;
        continue;
      case 46:
        v115 = sub_80A7C3E(a1);
        a1 -= 2;
        continue;
      case 47:
        if ( a1[1] == 5 )
        {
          *a1 = *a1 != 0;
        }
        else if ( !sub_80AA9A0(a1) )
        {
          sub_80AA8AE();
        }
        continue;
      case 48:
        if ( !sub_80AAAE2(a1) )
          sub_80AA8AE();
        continue;
      case 49:
        if ( !sub_80AAC34(a1) )
          sub_80AA8AE();
        continue;
      case 50:
        if ( !sub_80AAD7C(a1) )
          sub_80AA8AE();
        continue;
      case 51:
        if ( a1[1] != 5 && !sub_80AA9A0(a1) )
          sub_80AA8AE();
        *a1 = *a1 == 0;
        continue;
      case 52:
        if ( a1[1] != 5 )
        {
          v40 = sub_8086D78("~ cannot be applied to \"%s\"", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v40);
        }
        *a1 = ~*a1;
        continue;
      case 53:
        if ( a1[1] != 5 && !sub_80AA9A0(a1) )
          sub_80AA8AE();
        if ( !*a1 )
          a2 += *a2;
        a2 += 4;
        a1 -= 2;
        continue;
      case 54:
        if ( a1[1] != 5 && !sub_80AA9A0(a1) )
        {
          dword_8433EA8 = 1;
          sub_80AA8AE();
        }
        if ( !*a1 )
        {
          a2 += 4;
          a1 -= 2;
          continue;
        }
        a1 -= 2;
LABEL_181:
        if ( (sub_80B0876() - dword_8433F78) >= 0 )
        {
          a2 += *a2;
          continue;
        }
        if ( dword_8433EB0 )
        {
          Com_Printf("script runtime warning: potential infinite loop in script.\n");
          sub_80A3C34(0, a2, 0);
          a2 += *a2;
          dword_8433F78 = sub_80B0876();
          continue;
        }
        if ( dword_829FA08 )
          sub_80B055C("potential infinite loop in script");
        Com_Printf("script runtime error: potential infinite loop in script - killing thread.\n");
        sub_80A3C34(0, a2, 0);
        dword_8433F78 = sub_80B0876();
LABEL_10:
        while ( 1 )
        {
          sub_80A65BA(v117);
          while ( a1[1] != 6 )
          {
            sub_80AA74C(a1);
            a1 -= 2;
          }
          --dword_80F520C;
          if ( a1 == a5 )
            break;
          sub_80A6C02(v117);
          a1 -= 2;
          v117 = *a1;
          a1[1] = 0;
        }
        *(a5 + 12) = 0;
        return v117;
      case 55:
        if ( a1[1] != 5 && !sub_80AA9A0(a1) )
          sub_80AA8AE();
        if ( *a1 )
          a1 -= 2;
        else
          a2 += *a2;
        a2 += 4;
        continue;
      case 56:
        if ( a1[1] != 5 && !sub_80AA9A0(a1) )
          sub_80AA8AE();
        if ( *a1 )
          a2 += *a2;
        else
          a1 -= 2;
        a2 += 4;
        continue;
      case 57:
        a2 += *a2;
        continue;
      case 58:
        goto LABEL_181;
      case 59:
        a1 += 2;
        sub_80A77DE(v115, a1);
        if ( a1[1] != 5 )
        {
          v41 = sub_8086D78("++ must be applied to an int (applied to %s)", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v41);
        }
        ++*a1;
        continue;
      case 60:
        a1 += 2;
        sub_80A77DE(v115, a1);
        if ( a1[1] != 5 )
        {
          v42 = sub_8086D78("-- must be applied to an int (applied to %s)", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v42);
        }
        --*a1;
        continue;
      case 61:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        *a1 |= a1[2];
        continue;
      case 62:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        *a1 ^= a1[2];
        continue;
      case 63:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        *a1 &= a1[2];
        continue;
      case 64:
        a1 -= 2;
        if ( !sub_80AB30E(a1, a1 + 4) )
          sub_80AA8AE();
        continue;
      case 65:
        a1 -= 2;
        if ( sub_80B0898(a1) && a1[1] <= 0xB )
        {
          switch ( a1[1] )
          {
            case 0:
              a1[1] = 5;
              *a1 = 0;
              continue;
            case 1:
            case 2:
              a1[1] = 5;
              v109 = *a1 != *(a1 + 4);
              sub_80A509E(*a1);
              sub_80A509E(*(a1 + 4));
              *a1 = v109;
              continue;
            case 3:
              a1[1] = 5;
              v81 = 0;
              if ( **a1 != *a1[2] || *(*a1 + 4) != *(a1[2] + 4) || *(*a1 + 8) != *(a1[2] + 8) )
                v81 = 1;
              sub_80A6CF8(*a1);
              sub_80A6CF8(a1[2]);
              *a1 = v81;
              continue;
            case 4:
              a1[1] = 5;
              v71 = *a1 - *(a1 + 2);
              *a1 = sub_80B085C(v71) >= 0.000001;
              continue;
            case 5:
              *a1 = *a1 != a1[2];
              continue;
            case 6:
            case 8:
            case 9:
            case 10:
              goto LABEL_315;
            case 7:
              a1[1] = 5;
              v110 = *a1 != *(a1 + 4);
              sub_80A6C02(*a1);
              sub_80A6C02(*(a1 + 4));
              *a1 = v110;
              continue;
            case 11:
              a1[1] = 5;
              *a1 = *a1 != a1[2];
              continue;
          }
        }
        goto LABEL_315;
      case 66:
        a1 -= 2;
        sub_80B0898(a1);
        v80 = a1[1];
        if ( v80 == 4 )
        {
          a1[1] = 5;
          *a1 = *(a1 + 2) > *a1;
        }
        else
        {
          if ( v80 != 5 )
            goto LABEL_315;
          *a1 = *a1 < a1[2];
        }
        continue;
      case 67:
        a1 -= 2;
        sub_80B0898(a1);
        v79 = a1[1];
        if ( v79 == 4 )
        {
          a1[1] = 5;
          *a1 = *a1 > *(a1 + 2);
        }
        else
        {
          if ( v79 != 5 )
            goto LABEL_315;
          *a1 = *a1 > a1[2];
        }
        continue;
      case 68:
        a1 -= 2;
        sub_80B0898(a1);
        v78 = a1[1];
        if ( v78 == 4 )
        {
          a1[1] = 5;
          *a1 = *(a1 + 2) >= *a1;
        }
        else
        {
          if ( v78 != 5 )
            goto LABEL_315;
          *a1 = *a1 <= a1[2];
        }
        continue;
      case 69:
        a1 -= 2;
        sub_80B0898(a1);
        v77 = a1[1];
        if ( v77 == 4 )
        {
          a1[1] = 5;
          *a1 = *a1 >= *(a1 + 2);
        }
        else
        {
          if ( v77 != 5 )
            goto LABEL_315;
          *a1 = *a1 >= a1[2];
        }
        continue;
      case 70:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        *a1 <<= *(a1 + 8);
        continue;
      case 71:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        *a1 >>= *(a1 + 8);
        continue;
      case 72:
        a1 -= 2;
        sub_80B0898(a1);
        v76 = a1[1];
        if ( v76 == 3 )
        {
          v90 = sub_80A6C5C();
          *v90 = **a1 + *a1[2];
          v90[1] = *(*a1 + 4) + *(a1[2] + 4);
          v90[2] = *(*a1 + 8) + *(a1[2] + 8);
          sub_80A6CF8(*a1);
          sub_80A6CF8(a1[2]);
          *a1 = v90;
        }
        else if ( v76 > 3 )
        {
          if ( v76 == 4 )
          {
            *a1 = *a1 + *(a1 + 2);
          }
          else
          {
            if ( v76 != 5 )
              goto LABEL_315;
            *a1 += a1[2];
          }
        }
        else
        {
          if ( v76 != 1 )
            goto LABEL_315;
          v97 = sub_80B0780(a1);
          sub_80A509E(*a1);
          sub_80A509E(*(a1 + 4));
          *a1 = v97;
        }
        continue;
      case 73:
        a1 -= 2;
        sub_80B0898(a1);
        v75 = a1[1];
        if ( v75 == 4 )
        {
          *a1 = *a1 - *(a1 + 2);
        }
        else if ( v75 > 4 )
        {
          if ( v75 != 5 )
            goto LABEL_315;
          *a1 -= a1[2];
        }
        else
        {
          if ( v75 != 3 )
            goto LABEL_315;
          v91 = sub_80A6C5C();
          *v91 = **a1 - *a1[2];
          v91[1] = *(*a1 + 4) - *(a1[2] + 4);
          v91[2] = *(*a1 + 8) - *(a1[2] + 8);
          sub_80A6CF8(*a1);
          sub_80A6CF8(a1[2]);
          *a1 = v91;
        }
        continue;
      case 74:
        a1 -= 2;
        sub_80B0898(a1);
        v74 = a1[1];
        if ( v74 == 4 )
        {
          *a1 = *a1 * *(a1 + 2);
        }
        else
        {
          if ( v74 != 5 )
            goto LABEL_315;
          *a1 *= a1[2];
        }
        continue;
      case 75:
        a1 -= 2;
        sub_80B0898(a1);
        v73 = a1[1];
        if ( v73 == 4 )
        {
          if ( *(a1 + 2) == 0.0 )
          {
            *a1 = 0;
            sub_80B04E8("divide by 0");
          }
          *a1 = *a1 / *(a1 + 2);
        }
        else
        {
          if ( v73 != 5 )
          {
LABEL_315:
            if ( !*dword_8433EA0 )
              sub_80AB04E(a1, a1 + 2);
            sub_80AA8AE();
          }
          if ( !a1[2] )
          {
            *a1 = 0;
            sub_80B04E8("divide by 0");
          }
          *a1 /= a1[2];
        }
        continue;
      case 76:
        a1 -= 2;
        sub_80B0898(a1);
        if ( a1[1] != 5 )
          goto LABEL_315;
        if ( !a1[2] )
        {
          *a1 = 0;
          sub_80B04E8("divide by 0");
        }
        *a1 %= a1[2];
        continue;
      case 77:
        sub_80A7912(a1);
        continue;
      case 78:
      case 79:
        if ( v83 )
          sub_80B04E8("waittill not allowed in /# ... #/ comment (call as a thread to fix)");
        if ( a1[1] != 7 )
        {
          dword_8433EA8 = 2;
          v53 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v53);
        }
        if ( !sub_80A7BB2(*a1) )
        {
          dword_8433EA8 = 2;
          v51 = sub_80A7D0A(*a1);
          v52 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v51]);
          sub_80B04E8(v52);
        }
        if ( *(a1 - 1) != 1 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("first parameter of waittill must evaluate to a string");
        }
        v98 = *(a1 - 4);
        v43 = sub_80A71D8(*a1, 0x20000u);
        v44 = sub_80A7B26(v43);
        v45 = sub_80A71D8(v44, v98);
        v46 = sub_80A7B26(v45);
        sub_80A7206(v46, v116);
        v113 = 7;
        LOWORD(v112) = *a1;
        v47 = sub_80A6B34(v116);
        v48 = sub_80A7206(word_8433F70, v47);
        v49 = sub_80A7B26(v48);
        v50 = sub_80A7206(v49, v116);
        sub_80A7600(v50, &v112);
        sub_80A650C(v116, v98);
        sub_80A509E(v98);
        sub_80AE052((a1 - a5 - 16) >> 3, a2, v117, v116, a5, 0);
        *(a5 + 12) = 0;
        return v116;
      case 80:
        if ( a1[1] != 7 )
        {
          dword_8433EA8 = 2;
          v56 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v56);
        }
        if ( !sub_80A7BB2(*a1) )
        {
          dword_8433EA8 = 2;
          v54 = sub_80A7D0A(*a1);
          v55 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v54]);
          sub_80B04E8(v55);
        }
        if ( *(a1 - 1) != 1 )
        {
          dword_8433EA8 = 1;
          sub_80B04E8("first parameter of notify must evaluate to a string");
        }
        sub_80AE54E(*a1, *(a1 - 4), a1 - 4);
        while ( a1[1] != 6 )
        {
          sub_80AA74C(a1);
          a1 -= 2;
        }
        a1 -= 2;
        continue;
      case 81:
        if ( a1[1] != 7 )
        {
          dword_8433EA8 = 1;
          v66 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * a1[1]]);
          sub_80B04E8(v66);
        }
        if ( !sub_80A7BB2(*a1) )
        {
          dword_8433EA8 = 1;
          v64 = sub_80A7D0A(*a1);
          v65 = sub_8086D78("%s is not an object", *&off_80F51C0[4 * v64]);
          sub_80B04E8(v65);
        }
        if ( *(a1 - 1) != 1 )
          sub_80B04E8("first parameter of endof must evaluate to a string");
        v99 = *(a1 - 4);
        sub_80A6BC6(v116);
        v85 = sub_80A6AEC(v116);
        v57 = sub_80A71D8(*a1, 0x20000u);
        v58 = sub_80A7B26(v57);
        v59 = sub_80A71D8(v58, v99);
        v60 = sub_80A7B26(v59);
        sub_80A7206(v60, v85);
        sub_80A6C02(v85);
        v113 = 7;
        LOWORD(v112) = *a1;
        v61 = sub_80A7206(word_8433F70, v116);
        v62 = sub_80A7B26(v61);
        v63 = sub_80A7206(v62, v85);
        sub_80A7600(v63, &v112);
        sub_80A650C(v85, v99);
        sub_80A509E(v99);
        a1 -= 4;
        continue;
      case 82:
        a1 += 2;
        a1[1] = 6;
        *a1 = 0;
        continue;
      case 83:
        a2 += *a2;
        v111 = *(a2 - 1);
        v72 = a1[1];
        if ( v72 == 1 )
        {
          v96 = *a1;
          sub_80A509E(*a1);
        }
        else
        {
          if ( v72 != 5 )
          {
            v68 = sub_8086D78("cannot switch on %s", *&off_80F51C0[4 * a1[1]]);
            sub_80B04E8(v68);
          }
          if ( !sub_80A6DF2(*a1) )
          {
            v67 = sub_8086D78("switch index %d out of range", *a1);
            sub_80B04E8(v67);
          }
          v96 = sub_80A6E18(*a1);
        }
        a1 -= 2;
        if ( !v111 )
          continue;
        do
        {
          if ( *a2 == v96 )
          {
            a2 = *(a2 + 1);
            goto LABEL_2;
          }
          a2 += 8;
          --v111;
        }
        while ( v111 );
        if ( !*(a2 - 2) )
          a2 = *(a2 - 1);
        continue;
      case 84:
        a2 += 8 * *a2 + 2;
        continue;
      case 85:
        a1 -= 4;
        sub_80AAF94(a1);
        continue;
      case 86:
        continue;
      case 87:
        dword_8433EC0[dword_80F520C] = a2;
        v127 = *(dword_80F5144 + &a2[-dword_80F5164] - 1);
        *(dword_80F520C + 138624832) = *v127;
        a2 = v127 + 1;
        ++v83;
        continue;
      case 88:
        a2 = dword_8433EC0[dword_80F520C];
        v84 = *(dword_80F520C + 138624832);
        dword_8433EC0[dword_80F520C] = 0;
        --v83;
        goto LABEL_3;
      default:
        goto LABEL_315;
    }
  }
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 80F5164: using guessed type int dword_80F5164;
// 80F520C: using guessed type int dword_80F520C;
// 80F5210: using guessed type __int16 word_80F5210;
// 80F5212: using guessed type __int16 word_80F5212;
// 829FA08: using guessed type int dword_829FA08;
// 8433EA8: using guessed type int dword_8433EA8;
// 8433EB0: using guessed type int dword_8433EB0;
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F74: using guessed type __int16 word_8433F74;
// 8433F76: using guessed type __int16 word_8433F76;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AE052) --------------------------------------------------------
int __cdecl sub_80AE052(int a1, int a2, __int16 a3, unsigned __int16 a4, int a5, int a6)
{
  unsigned __int16 v6; // ax
  _BYTE *v8; // [esp+10h] [ebp-18h]
  _DWORD *v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11[3]; // [esp+18h] [ebp-10h] BYREF
  unsigned __int16 v12; // [esp+24h] [ebp-4h]
  __int16 v13; // [esp+26h] [ebp-2h]

  v13 = a3;
  v12 = a4;
  v10 = sub_80A2F68(5 * a1 + 12);
  *(v10 + 10) = a3;
  sub_80A6BC6(v12);
  *(v10 + 8) = a1;
  *v10 = a6;
  *(v10 + 4) = a2;
  v8 = (v10 + 12);
  --dword_80F520C;
  while ( a1 )
  {
    --a1;
    a5 += 8;
    *v8 = *(a5 + 4);
    if ( *(a5 + 4) == 6 )
      --dword_80F520C;
    v9 = v8 + 1;
    *v9 = *a5;
    v8 = v9 + 1;
  }
  v11[1] = 10;
  v11[0] = v10;
  v6 = sub_80A71D8(v12, 0x20001u);
  return sub_80A7600(v6, v11);
}
// 80F520C: using guessed type int dword_80F520C;

//----- (080AE146) --------------------------------------------------------
int __cdecl sub_80AE146(unsigned __int16 a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  _BYTE *v4; // [esp+1Ch] [ebp-Ch]
  int *v5; // [esp+1Ch] [ebp-Ch]
  int *v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  unsigned __int16 v9; // [esp+24h] [ebp-4h]

  sub_80A7240(a1, 131073);
  sub_80A6C02(a1);
  v3 = *(a2 + 8);
  v9 = *(a2 + 10);
  v4 = (5 * v3 + a2 + 12);
  sub_80A65BA(v9);
  sub_80A6C02(v9);
  while ( v3 )
  {
    v5 = (v4 - 4);
    v7 = *v5;
    v4 = v5 - 1;
    --v3;
    if ( *v4 == 6 )
    {
      v6 = (v4 - 4);
      v8 = *v6;
      v4 = v6 - 1;
      --v3;
      sub_80A65BA(v8);
      sub_80A6C02(v8);
    }
    else
    {
      sub_80A6DA0(*v4, v7);
    }
  }
  return sub_80A2F8E(a2, 5 * *(a2 + 8) + 12);
}

//----- (080AE250) --------------------------------------------------------
int __cdecl sub_80AE250(unsigned __int16 a1)
{
  int *v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  v3 = sub_80A6E88(a1, 131073);
  if ( v3 )
  {
    v1 = sub_80A7646(v3);
    result = sub_80AE146(a1, *v1);
  }
  else
  {
    sub_80A65BA(a1);
    result = sub_80A6C02(a1);
  }
  return result;
}

//----- (080AE2B6) --------------------------------------------------------
int __cdecl sub_80AE2B6(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int result; // eax
  unsigned __int16 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+12h] [ebp-6h]

  v7 = sub_80A64E4(a2);
  sub_80A6564(a2);
  v2 = sub_80A6E88(a1, 0x20000);
  v6 = sub_80A7B82(v2);
  v3 = sub_80A6E88(v6, v7);
  v5 = sub_80A7B82(v3);
  sub_80A72CA(v5, a2);
  result = sub_80A79FE(v5);
  if ( !result )
  {
    sub_80A7240(v6, v7);
    result = sub_80A79FE(v6);
    if ( !result )
      result = sub_80A7240(a1, 0x20000);
  }
  return result;
}

//----- (080AE38A) --------------------------------------------------------
int __cdecl sub_80AE38A(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  int v3; // [esp+10h] [ebp-18h]
  unsigned __int16 v4; // [esp+16h] [ebp-12h]
  int *v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  unsigned __int16 v9; // [esp+24h] [ebp-4h]
  unsigned __int16 v10; // [esp+24h] [ebp-4h]

  result = sub_80A6E88(a1, 131073);
  if ( result )
  {
    v5 = *sub_80A7646(result);
    v7 = sub_80A6B34(a1);
    v8 = sub_80A6EB6(word_8433F70, v7);
    if ( v8 && (v6 = sub_80A7B82(v8), (v9 = sub_80A6EB6(v6, a1)) != 0) )
    {
      v4 = *sub_80A7646(v9);
      sub_80AE2B6(v4, a1);
      sub_80A6BC6(a1);
      sub_80A72CA(v6, a1);
      if ( !sub_80A79FE(v6) )
        sub_80A72CA(word_8433F70, v7);
    }
    else
    {
      v3 = *v5;
      v2 = sub_80A6E88(word_80F5210, *v5);
      v10 = sub_80A7B82(v2);
      sub_80A6BC6(a1);
      sub_80A72CA(v10, a1);
      if ( !sub_80A79FE(v10) && v3 != dword_8433F6C )
        sub_80A7240(word_80F5210, v3);
    }
    result = sub_80AE146(a1, v5);
  }
  return result;
}
// 80F5210: using guessed type __int16 word_80F5210;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;

//----- (080AE54E) --------------------------------------------------------
int __cdecl sub_80AE54E(unsigned __int16 a1, unsigned __int16 a2, int *a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  int v5; // edx
  unsigned __int16 v6; // ax
  unsigned __int16 v7; // ax
  int v8; // [esp+18h] [ebp-50h] BYREF
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10[2]; // [esp+20h] [ebp-48h] BYREF
  bool v11; // [esp+2Bh] [ebp-3Dh]
  unsigned __int16 i; // [esp+2Ch] [ebp-3Ch]
  unsigned __int16 v13; // [esp+2Eh] [ebp-3Ah]
  unsigned __int16 v14; // [esp+30h] [ebp-38h]
  unsigned __int16 v15; // [esp+32h] [ebp-36h]
  int v16; // [esp+34h] [ebp-34h]
  int v17; // [esp+38h] [ebp-30h]
  size_t n; // [esp+3Ch] [ebp-2Ch]
  int v19; // [esp+40h] [ebp-28h]
  int v20; // [esp+44h] [ebp-24h]
  unsigned __int8 *v21; // [esp+48h] [ebp-20h]
  int v22; // [esp+4Ch] [ebp-1Ch]
  int v23; // [esp+50h] [ebp-18h]
  int *v24; // [esp+54h] [ebp-14h]
  int *j; // [esp+58h] [ebp-10h]
  unsigned __int16 v26; // [esp+5Eh] [ebp-Ah]
  unsigned __int16 v27; // [esp+60h] [ebp-8h]
  unsigned __int16 v28; // [esp+62h] [ebp-6h]
  unsigned __int16 v29; // [esp+64h] [ebp-4h]
  unsigned __int16 v30; // [esp+66h] [ebp-2h]

  v30 = a1;
  v29 = a2;
  result = sub_80A6E88(a1, 0x20000);
  v27 = result;
  if ( result )
  {
    v27 = sub_80A7B82(v27);
    result = sub_80A6E88(v27, v29);
    v28 = result;
    if ( result )
    {
      v28 = sub_80A7B82(v28);
      sub_80A6BC6(v28);
LABEL_4:
      for ( i = sub_80A7A30(v28); i; i = sub_80A7A30(i) )
      {
        v26 = sub_80A5AC8(i);
        v15 = sub_80A6B34(v26);
        v4 = sub_80A6EB6(word_8433F70, v15);
        v13 = sub_80A7B82(v4);
        v14 = sub_80A6E88(v26, 131073);
        if ( !v14 )
        {
          sub_80A6564(v26);
          sub_80A6BC6(v26);
          sub_80A72CA(v28, v26);
          if ( !sub_80A79FE(v28) )
          {
            sub_80A7240(v27, v29);
            if ( !sub_80A79FE(v27) )
              sub_80A7240(v30, 0x20000);
          }
          sub_80A72CA(v13, v26);
          if ( !sub_80A79FE(v13) )
            sub_80A72CA(word_8433F70, v15);
          sub_80A6BC6(v15);
          sub_80A65BA(v26);
          sub_80A6C02(v26);
          sub_80AE38A(v15);
          sub_80A6C02(v15);
          goto LABEL_4;
        }
        v24 = sub_80A7646(v14);
        v23 = *v24;
        if ( *(*(v23 + 4) - 1) != 78 )
        {
          v11 = a3[1] == 6;
LABEL_24:
          sub_80A6564(v26);
          sub_80A72CA(v28, v26);
          if ( !sub_80A79FE(v28) )
          {
            sub_80A7240(v27, v29);
            if ( !sub_80A79FE(v27) )
              sub_80A7240(v30, 0x20000);
          }
          *v23 = dword_8433F6C;
          v6 = sub_80A71D8(word_80F5210, dword_8433F6C);
          v7 = sub_80A7B26(v6);
          sub_80A7206(v7, v26);
          sub_80A72CA(v13, v26);
          if ( !sub_80A79FE(v13) )
            sub_80A72CA(word_8433F70, v15);
          if ( !v11 )
          {
            v20 = *(v23 + 8);
            v19 = v20;
            j = a3;
            do
            {
              ++v19;
              j -= 2;
            }
            while ( j[1] != 6 );
            n = 5 * v20;
            v17 = 5 * v19 + 12;
            v16 = 5 * v20 + 12;
            if ( !sub_80A2FB4(v16, v17) )
            {
              v22 = sub_80A2F68(v17);
              *v22 = *v23;
              *(v22 + 4) = *(v23 + 4);
              *(v22 + 10) = *(v23 + 10);
              sub_80C835C((v22 + 12), (v23 + 12), n);
              sub_80A2F8E(v23, v16);
              v23 = v22;
              *v24 = v22;
            }
            *(v23 + 8) = v19;
            v21 = (v23 + n + 12);
            v19 -= v20;
            do
            {
              j += 2;
              sub_80AA72C(j);
              *v21++ = *(j + 4);
              *v21 = *j;
              v21 += 4;
              --v19;
            }
            while ( v19 );
          }
          goto LABEL_4;
        }
        v20 = **(v23 + 4);
        v21 = (v23 + 5 * (*(v23 + 8) - v20) + 12);
        for ( j = a3; ; j -= 2 )
        {
          if ( !v20 )
            goto LABEL_22;
          if ( j[1] == 6 )
            goto LABEL_37;
          --v20;
          v9 = *v21;
          if ( v9 == 6 )
          {
LABEL_22:
            ++*(v23 + 4);
            v11 = 1;
            goto LABEL_24;
          }
          v8 = *++v21;
          v21 += 4;
          sub_80AA72C(&v8);
          v5 = j[1];
          v10[0] = *j;
          v10[1] = v5;
          sub_80AA72C(v10);
          if ( !sub_80AB30E(&v8, v10) )
            break;
          if ( !v8 )
            goto LABEL_37;
        }
        sub_80A3F4A(*(v23 + 4), **(v23 + 4) - v20 + 2, *dword_8433EA0, dword_8433EA4);
        *dword_8433EA0 = 0;
        dword_8433EA4 = 0;
LABEL_37:
        ;
      }
      result = sub_80A6C02(v28);
    }
  }
  return result;
}
// 80F5210: using guessed type __int16 word_80F5210;
// 8433EA4: using guessed type int dword_8433EA4;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;

//----- (080AEAEA) --------------------------------------------------------
int __cdecl sub_80AEAEA(unsigned __int16 a1, unsigned __int16 a2, int a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+28h] [ebp+10h]

  while ( dword_8433F64 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
    --dword_8433F64;
  }
  v5 = dword_8433F68 - 8 * a3;
  v6 = dword_8433F60 - a3;
  v4 = *(v5 + 4);
  *(v5 + 4) = 6;
  dword_8433F60 = 0;
  sub_80AE54E(a1, a2, dword_8433F68);
  *(v5 + 4) = v4;
  while ( dword_8433F68 != v5 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
  }
  result = v6;
  dword_8433F60 = v6;
  return result;
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AEBB6) --------------------------------------------------------
int __cdecl sub_80AEBB6(int a1, int a2, unsigned __int16 a3, int a4)
{
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+2Ch] [ebp+14h]

  while ( dword_8433F64 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
    --dword_8433F64;
  }
  v6 = dword_8433F68 - 8 * a4;
  v8 = dword_8433F60 - a4;
  v7 = sub_80A806C(a1, a2);
  if ( v7 )
  {
    v5 = *(v6 + 4);
    *(v6 + 4) = 6;
    dword_8433F60 = 0;
    sub_80AE54E(v7, a3, dword_8433F68);
    *(v6 + 4) = v5;
  }
  while ( dword_8433F68 != v6 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
  }
  result = v8;
  dword_8433F60 = v8;
  return result;
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AEC98) --------------------------------------------------------
int __cdecl sub_80AEC98(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v3; // [esp+10h] [ebp-8h]
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  while ( 1 )
  {
    result = sub_80A6E88(a1, 0x20000);
    if ( !result )
      break;
    v3 = sub_80A7B82(result);
    result = sub_80A7A30(v3);
    if ( !result )
      break;
    v4 = sub_80A7B82(result);
    result = sub_80A7A30(v4);
    if ( !result )
      break;
    v2 = sub_80A5AC8(result);
    sub_80A6BC6(v2);
    sub_80AE250(v2);
  }
  return result;
}

//----- (080AED48) --------------------------------------------------------
int __cdecl sub_80AED48(unsigned __int16 a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  sub_80A6BC6(a1);
  while ( 1 )
  {
    v3 = sub_80A7A30(a1);
    if ( !v3 )
      break;
    v2 = sub_80A5AC8(v3);
    sub_80A6BC6(v2);
    sub_80A72CA(a1, v2);
    sub_80AE250(v2);
  }
  return sub_80A6C02(a1);
}

//----- (080AEDC6) --------------------------------------------------------
int __cdecl sub_80AEDC6(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v5; // [esp+18h] [ebp-20h]
  unsigned __int8 *v6; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  unsigned __int16 v9; // [esp+26h] [ebp-12h]
  unsigned __int16 v10; // [esp+28h] [ebp-10h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v12; // [esp+2Ah] [ebp-Eh]
  char *v13; // [esp+2Ch] [ebp-Ch]
  int *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 *v15; // [esp+30h] [ebp-8h]

  dword_8433F78 = sub_80B0876();
  sub_80A6BC6(a1);
  while ( 1 )
  {
    v9 = sub_80A7A30(a1);
    if ( !v9 )
      break;
    v10 = sub_80A5AC8(v9);
    sub_80A72CA(a1, v10);
    v1 = sub_80A6E88(v10, 131073);
    v8 = *sub_80A7646(v1);
    sub_80A7240(v10, 131073);
    v5 = *(v8 + 8);
    v13 = *(v8 + 4);
    v11 = *(v8 + 10);
    v6 = (v8 + 12);
    v14 = &unk_842FE00;
    while ( v5 )
    {
      v14 += 2;
      --v5;
      v14[1] = *v6;
      v7 = v6 + 1;
      *v14 = *v7;
      v6 = (v7 + 1);
      if ( v14[1] == 6 )
        dword_8433E20[dword_80F520C++] = *v14;
    }
    dword_8433E20[dword_80F520C++] = v13;
    sub_80A2F8E(v8, 5 * *(v8 + 8) + 12);
    v2 = sub_80A6B34(v11);
    if ( sub_80A7BB2(v2) )
    {
      v3 = sub_80AB56A(v14, v13, v11, v10, &unk_842FE00);
      sub_80A6C02(v3);
      sub_80AA74C(dword_842FE08);
    }
    else
    {
      sub_80A65BA(v11);
      sub_80A6C02(v11);
      while ( 1 )
      {
        while ( v14[1] != 6 )
        {
          sub_80AA74C(v14);
          v14 -= 2;
        }
        --dword_80F520C;
        if ( v14 == &unk_842FE00 )
          break;
        v15 = (v14 - 2);
        v12 = *v15;
        v14 = (v15 - 4);
        sub_80A65BA(v12);
        sub_80A6C02(v12);
      }
    }
  }
  sub_80A6C02(a1);
  return sub_80A7674(word_80F5212);
}
// 80F520C: using guessed type int dword_80F520C;
// 80F5212: using guessed type __int16 word_80F5212;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AF004) --------------------------------------------------------
int sub_80AF004()
{
  int result; // eax

  while ( dword_8433F64 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
    --dword_8433F64;
  }
  dword_8433F68 += 8;
  ++dword_8433F60;
  result = dword_8433F68;
  if ( dword_8433F68 > dword_8433E00 )
    sub_80704AC(1, &byte_80E86C0);
  return result;
}
// 8433E00: using guessed type int dword_8433E00;
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AF062) --------------------------------------------------------
int __cdecl sub_80AF062(__int16 a1, char *a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+24h] [ebp-4h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+38h] [ebp+10h]

  while ( dword_8433F64 )
  {
    sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
    --dword_8433F64;
  }
  v6 = dword_8433F68 - 8 * a3;
  v9 = dword_8433F60 - a3;
  sub_80A6BC6(a1);
  v7 = sub_80A6AEC(a1);
  if ( dword_80F520C > 31 )
  {
    sub_80A65BA(v7);
    dword_8433F60 = v9 + 1;
    while ( v9 )
    {
      sub_80AA74C(dword_8433F68);
      dword_8433F68 -= 8;
      --v9;
    }
    dword_8433F68 += 8;
    *(dword_8433F68 + 4) = 0;
    sub_80A3F4A(a2, 0, "script stack overflow (too many embedded function calls)", 0);
    v4 = v7;
  }
  else
  {
    dword_8433E20[dword_80F520C++] = a2;
    v5 = *(v6 + 4);
    *(v6 + 4) = 6;
    dword_8433F60 = 0;
    v8 = sub_80AB56A(dword_8433F68, a2, v7, v7, v6);
    *(v6 + 4) = v5;
    dword_8433F68 = v6 + 8;
    dword_8433F60 = v9 + 1;
    sub_80A7674(word_80F5212);
    v4 = v8;
  }
  return v4;
}
// 80F520C: using guessed type int dword_80F520C;
// 80F5212: using guessed type __int16 word_80F5212;
// 8433F60: using guessed type int dword_8433F60;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AF1F2) --------------------------------------------------------
int __cdecl sub_80AF1F2(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  if ( !dword_80F520C )
    dword_8433F78 = sub_80B0876();
  sub_80A1F50(dword_80F5164 + a1);
  v3 = sub_80AF062(word_8433F72, (dword_80F5164 + a1), a2);
  sub_80AA74C(dword_8433F68);
  *(dword_8433F68 + 4) = 0;
  dword_8433F68 -= 8;
  --dword_8433F60;
  return v3;
}
// 80F5164: using guessed type int dword_80F5164;
// 80F520C: using guessed type int dword_80F520C;
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AF270) --------------------------------------------------------
int __cdecl sub_80AF270(int a1, int a2, int a3, int a4)
{
  __int16 v4; // ax
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  if ( !dword_80F520C )
    dword_8433F78 = sub_80B0876();
  sub_80A1F50(dword_80F5164 + a3);
  v4 = sub_80A80E8(a1, a2);
  v6 = sub_80AF062(v4, (dword_80F5164 + a3), a4);
  sub_80AA74C(dword_8433F68);
  *(dword_8433F68 + 4) = 0;
  dword_8433F68 -= 8;
  --dword_8433F60;
  return v6;
}
// 80F5164: using guessed type int dword_80F5164;
// 80F520C: using guessed type int dword_80F520C;
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AF2FC) --------------------------------------------------------
int __cdecl sub_80AF2FC(int a1, int a2)
{
  unsigned __int16 v2; // ax

  if ( !dword_80F520C )
    dword_8433F78 = sub_80B0876();
  sub_80A1F50(dword_80F5164 + a1);
  v2 = sub_80AF062(word_8433F72, (dword_80F5164 + a1), a2);
  return sub_80A6C02(v2);
}
// 80F5164: using guessed type int dword_80F5164;
// 80F520C: using guessed type int dword_80F520C;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AF356) --------------------------------------------------------
int __cdecl sub_80AF356(int a1, int a2, int a3, int a4)
{
  __int16 v4; // ax
  unsigned __int16 v5; // ax

  if ( !dword_80F520C )
    dword_8433F78 = sub_80B0876();
  sub_80A1F50(dword_80F5164 + a3);
  v4 = sub_80A80E8(a1, a2);
  v5 = sub_80AF062(v4, (dword_80F5164 + a3), a4);
  return sub_80A6C02(v5);
}
// 80F5164: using guessed type int dword_80F5164;
// 80F520C: using guessed type int dword_80F520C;
// 8433F78: using guessed type int dword_8433F78;

//----- (080AF3BE) --------------------------------------------------------
int __cdecl sub_80AF3BE(unsigned __int16 a1)
{
  return sub_80A6C02(a1);
}

//----- (080AF3DA) --------------------------------------------------------
void sub_80AF3DA()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // [esp+16h] [ebp-2h]

  if ( word_80F5210 )
  {
    v1 = sub_80A6E88(word_80F5210, dword_8433F6C);
    if ( v1 )
    {
      v0 = sub_80A7B82(v1);
      sub_80AEDC6(v0);
      sub_80A7352(word_80F5210, dword_8433F6C);
    }
  }
}
// 80F5210: using guessed type __int16 word_80F5210;
// 8433F6C: using guessed type int dword_8433F6C;

//----- (080AF442) --------------------------------------------------------
int __cdecl sub_80AF442(int a1, int a2)
{
  int result; // eax

  word_80F5210 = sub_80A6A28();
  word_8433F70 = sub_80A6AAC();
  word_8433F72 = sub_80A6A28();
  word_8433F76 = sub_80A6A28();
  result = a2 & 0xFFFFFF;
  dword_8433F6C = a2 & 0xFFFFFF;
  return result;
}
// 80F5210: using guessed type __int16 word_80F5210;
// 8433F6C: using guessed type int dword_8433F6C;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080AF484) --------------------------------------------------------
int sub_80AF484()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // ax
  int result; // eax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  unsigned __int16 i; // [esp+14h] [ebp-4h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+14h] [ebp-4h]

  for ( i = sub_80A7A30(word_80F5210); i; i = sub_80A7A30(i) )
  {
    v0 = sub_80A7B82(i);
    sub_80AED48(v0);
  }
  while ( 1 )
  {
    v5 = sub_80A7A30(word_8433F70);
    if ( !v5 )
      break;
    v1 = sub_80A7B82(v5);
    v6 = sub_80A7A30(v1);
    v3 = *sub_80A7646(v6);
    sub_80A6BC6(v3);
    sub_80AEC98(v3);
    sub_80A6C02(v3);
  }
  sub_80A64B0(word_8433F72);
  sub_80A6C02(word_8433F72);
  word_8433F72 = 0;
  sub_80A64B0(word_8433F76);
  sub_80A6C02(word_8433F76);
  word_8433F76 = 0;
  sub_80A64B0(word_80F5210);
  sub_80A6C02(word_80F5210);
  word_80F5210 = 0;
  result = sub_80A6C02(word_8433F70);
  word_8433F70 = 0;
  return result;
}
// 80F5210: using guessed type __int16 word_80F5210;
// 8433F70: using guessed type __int16 word_8433F70;
// 8433F72: using guessed type __int16 word_8433F72;
// 8433F76: using guessed type __int16 word_8433F76;

//----- (080AF5D4) --------------------------------------------------------
_BOOL4 sub_80AF5D4()
{
  return word_80F5210 != 0;
}
// 80F5210: using guessed type __int16 word_80F5210;

//----- (080AF5F0) --------------------------------------------------------
int __cdecl sub_80AF5F0(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( *(dword_8433F68 - 8 * a1 + 4) == 5 )
    return *(dword_8433F68 - 8 * a1) != 0;
  if ( !sub_80AA9A0(dword_8433F68 - 8 * a1) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AF6C6) --------------------------------------------------------
int __cdecl sub_80AF6C6(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( !sub_80AAAE2(dword_8433F68 - 8 * a1) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AF762) --------------------------------------------------------
unsigned __int16 *__userpurge sub_80AF762@<eax>(unsigned __int16 *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  const char *v6; // eax
  char *v7; // eax
  const char *v9; // [esp+18h] [ebp-10h]
  const char *v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]

  if ( a2 >= dword_8433F64 )
  {
    v7 = sub_8086D78("parameter %d does not exist", a2 + 1);
    sub_80B04E8(v7);
  }
  if ( *(dword_8433F68 - 8 * a2 + 4) != 11 )
  {
    *dword_8433EA0 = sub_8086D78("cannot cast %s to anim", *&off_80F51C0[4 * *(dword_8433F68 - 8 * a2 + 4)]);
LABEL_7:
    sub_80AA74C((dword_8433F68 - 8 * a2));
    *(dword_8433F68 - 8 * a2 + 4) = 0;
    dword_8433EA8 = a2 + 1;
    sub_80AA8AE();
  }
  *a1 = *(dword_8433F68 - 8 * a2);
  if ( a3 )
  {
    v11 = sub_809C85E(a1[1]);
    if ( v11 != sub_80B9748(a3) )
    {
      v3 = sub_80B9748(a3);
      v10 = sub_80BF0DE(v3);
      v4 = sub_809C85E(a1[1]);
      v9 = sub_80BF0DE(v4);
      v5 = sub_809C85E(a1[1]);
      v6 = sub_80BF0A6(v5, *a1);
      *dword_8433EA0 = sub_8086D78(
                         "anim '%s' in animtree '%s' does not belong to the entity's animtree '%s'",
                         v6,
                         v9,
                         v10);
      goto LABEL_7;
    }
  }
  return a1;
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AF91C) --------------------------------------------------------
_DWORD *__userpurge sub_80AF91C@<eax>(_DWORD *a1, unsigned int a2)
{
  char *v2; // eax
  unsigned int v4; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_8433F64 )
  {
    v2 = sub_8086D78("parameter %d does not exist", a2 + 1);
    sub_80B04E8(v2);
  }
  if ( *(dword_8433F68 - 8 * a2 + 4) != 5 )
  {
    *dword_8433EA0 = sub_8086D78("cannot cast %s to animtree", *&off_80F51C0[4 * *(dword_8433F68 - 8 * a2 + 4)]);
LABEL_8:
    sub_80AA74C((dword_8433F68 - 8 * a2));
    *(dword_8433F68 - 8 * a2 + 4) = 0;
    dword_8433EA8 = a2 + 1;
    sub_80AA8AE();
  }
  v4 = *(dword_8433F68 - 8 * a2);
  if ( v4 > dword_829F800[dword_8456180] || !dword_829F200[128 * dword_8456180 + v4] )
  {
    *dword_8433EA0 = "bad anim tree";
    goto LABEL_8;
  }
  *a1 = dword_829F200[128 * dword_8456180 + v4];
  return a1;
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 829F800: using guessed type int dword_829F800[];
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;
// 8456180: using guessed type int dword_8456180;

//----- (080AFA72) --------------------------------------------------------
long double __cdecl sub_80AFA72(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( !sub_80AAC34(dword_8433F68 - 8 * a1) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFB0C) --------------------------------------------------------
int __cdecl sub_80AFB0C(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( !sub_80AAD7C((dword_8433F68 - 8 * a1)) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFBAA) --------------------------------------------------------
int __cdecl sub_80AFBAA(unsigned int a1)
{
  unsigned __int16 v1; // ax

  v1 = sub_80AFB0C(a1);
  return sub_80A4458(v1);
}

//----- (080AFBEE) --------------------------------------------------------
const char *__cdecl sub_80AFBEE(unsigned int a1)
{
  int v1; // eax
  char *v2; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  if ( a1 >= dword_8433F64 )
  {
    v2 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v2);
  }
  v7 = *(dword_8433F68 - 8 * a1 + 4);
  if ( v7 == 7 )
    v4 = sub_80A7D0A(*(dword_8433F68 - 8 * a1));
  else
    v4 = *(dword_8433F68 - 8 * a1 + 4);
  v8 = *&off_80F51C0[4 * v4];
  if ( !sub_80AAD7C((dword_8433F68 - 8 * a1)) )
  {
    *dword_8433EA0 = 0;
    dword_8433EA4 = 0;
    dword_8433EA8 = 0;
    if ( v7 == 11 )
    {
      v6 = *(dword_8433F68 - 8 * a1);
      v1 = sub_809C85E(HIWORD(v6));
      return sub_80BF0A6(v1, v6);
    }
    if ( v7 != 2 )
      return v8;
  }
  return sub_80A4458(*(dword_8433F68 - 8 * a1));
}
// 8433EA4: using guessed type int dword_8433EA4;
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFD70) --------------------------------------------------------
int __cdecl sub_80AFD70(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( !sub_80AAE80((dword_8433F68 - 8 * a1)) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFE0E) --------------------------------------------------------
int __cdecl sub_80AFE0E(unsigned int a1)
{
  unsigned __int16 v1; // ax

  v1 = sub_80AFD70(a1);
  return sub_80A4458(v1);
}

//----- (080AFE52) --------------------------------------------------------
int __cdecl sub_80AFE52(unsigned int a1, _DWORD *a2)
{
  int result; // eax
  char *v3; // eax

  if ( a1 >= dword_8433F64 )
  {
    v3 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v3);
  }
  if ( !sub_80AAEDC((dword_8433F68 - 8 * a1)) )
  {
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  *a2 = **(dword_8433F68 - 8 * a1);
  a2[1] = *(*(dword_8433F68 - 8 * a1) + 4);
  result = *(*(dword_8433F68 - 8 * a1) + 8);
  a2[2] = result;
  return result;
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFF2C) --------------------------------------------------------
int __cdecl sub_80AFF2C(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  if ( *(dword_8433F68 - 8 * a1 + 4) != 9 )
  {
    *dword_8433EA0 = "not a function";
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  return *(dword_8433F68 - 8 * a1) - dword_80F5164;
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 80F5164: using guessed type int dword_80F5164;
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080AFFD4) --------------------------------------------------------
int __cdecl sub_80AFFD4(unsigned int a1, unsigned int *a2)
{
  int v2; // eax
  char *v3; // eax
  unsigned __int16 v5; // [esp+26h] [ebp-2h]

  if ( a1 >= dword_8433F64 )
  {
    v3 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v3);
  }
  if ( !sub_80AAF38((dword_8433F68 - 8 * a1)) )
  {
LABEL_6:
    dword_8433EA8 = a1 + 1;
    sub_80AA8AE();
  }
  v5 = *(dword_8433F68 - 8 * a1);
  if ( sub_80A7D0A(v5) != 13 )
  {
    v2 = sub_80A7D0A(v5);
    *dword_8433EA0 = sub_8086D78("cannot cast %s to entity", *&off_80F51C0[4 * v2]);
    goto LABEL_6;
  }
  *a2 = sub_80A5AF0(v5);
  return sub_80A8C30(v5);
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA8: using guessed type int dword_8433EA8;
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B00D0) --------------------------------------------------------
int __cdecl sub_80B00D0(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_8433F64 )
  {
    v1 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v1);
  }
  return *(dword_8433F68 - 8 * a1 + 4);
}
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0142) --------------------------------------------------------
int __cdecl sub_80B0142(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( a1 >= dword_8433F64 )
  {
    v2 = sub_8086D78("parameter %d does not exist", a1 + 1);
    sub_80B04E8(v2);
  }
  if ( *(dword_8433F68 - 8 * a1 + 4) != 7 )
  {
    v1 = sub_8086D78("parameter %d is not a pointer", a1 + 1);
    sub_80B04E8(v1);
  }
  return sub_80A7D0A(*(dword_8433F68 - 8 * a1));
}
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B01F8) --------------------------------------------------------
int sub_80B01F8()
{
  return dword_8433F64;
}
// 8433F64: using guessed type int dword_8433F64;

//----- (080B0202) --------------------------------------------------------
int __cdecl sub_80B0202(int a1)
{
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 5;
  result = a1;
  *dword_8433F68 = a1;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0226) --------------------------------------------------------
int __cdecl sub_80B0226(int a1)
{
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 5;
  result = a1;
  *dword_8433F68 = a1;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B024A) --------------------------------------------------------
int __cdecl sub_80B024A(int a1)
{
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 4;
  result = a1;
  *dword_8433F68 = a1;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B026E) --------------------------------------------------------
int __cdecl sub_80B026E(int a1)
{
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 11;
  result = a1;
  *dword_8433F68 = a1;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0292) --------------------------------------------------------
int sub_80B0292()
{
  int result; // eax

  sub_80AF004();
  result = dword_8433F68;
  *(dword_8433F68 + 4) = 0;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B02AC) --------------------------------------------------------
int __cdecl sub_80B02AC(unsigned __int16 a1)
{
  sub_80AF004();
  *(dword_8433F68 + 4) = 7;
  *dword_8433F68 = a1;
  return sub_80A6BC6(a1);
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B02E6) --------------------------------------------------------
int __cdecl sub_80B02E6(int a1, int a2)
{
  unsigned __int16 v2; // ax

  v2 = sub_80A80E8(a1, a2);
  return sub_80B02AC(v2);
}

//----- (080B030C) --------------------------------------------------------
int sub_80B030C()
{
  unsigned __int16 v1; // [esp+6h] [ebp-2h]

  v1 = sub_80A6A28();
  sub_80B02AC(v1);
  return sub_80A6C02(v1);
}

//----- (080B0336) --------------------------------------------------------
int __cdecl sub_80B0336(char *s)
{
  _WORD *v1; // ebx
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 1;
  v1 = dword_8433F68;
  result = sub_80A4D9A(s, 0);
  *v1 = result;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0370) --------------------------------------------------------
int __cdecl sub_80B0370(char *s)
{
  _WORD *v1; // ebx
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 2;
  v1 = dword_8433F68;
  result = sub_80A4D9A(s, 0);
  *v1 = result;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B03AA) --------------------------------------------------------
int __cdecl sub_80B03AA(unsigned __int16 a1)
{
  sub_80AF004();
  *(dword_8433F68 + 4) = 1;
  *dword_8433F68 = a1;
  return sub_80A4F00(a1);
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B03E4) --------------------------------------------------------
_DWORD *__cdecl sub_80B03E4(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 3;
  v1 = dword_8433F68;
  result = sub_80A6C8C(a1);
  *v1 = result;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0416) --------------------------------------------------------
int sub_80B0416()
{
  _WORD *v0; // ebx
  int result; // eax

  sub_80AF004();
  *(dword_8433F68 + 4) = 7;
  v0 = dword_8433F68;
  result = sub_80A6AAC();
  *v0 = result;
  return result;
}
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0442) --------------------------------------------------------
int sub_80B0442()
{
  int v0; // eax
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  dword_8433F68 -= 8;
  --dword_8433F60;
  v0 = sub_80A79FE(*dword_8433F68);
  v2 = sub_80A71AA(*dword_8433F68, v0);
  return sub_80A7600(v2, (dword_8433F68 + 8));
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0498) --------------------------------------------------------
int __cdecl sub_80B0498(unsigned __int16 a1)
{
  unsigned __int16 v2; // [esp+14h] [ebp-4h]

  dword_8433F68 -= 8;
  --dword_8433F60;
  v2 = sub_80A71D8(*dword_8433F68, a1);
  return sub_80A7600(v2, (dword_8433F68 + 8));
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B04E8) --------------------------------------------------------
void __cdecl __noreturn sub_80B04E8(int a1)
{
  *dword_8433EA0 = a1;
  sub_80AA8AE();
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);

//----- (080B051E) --------------------------------------------------------
void __cdecl __noreturn sub_80B051E(int a1, int a2)
{
  *dword_8433EA0 = a1;
  dword_8433EA4 = a2;
  sub_80AA8AE();
}
// 80AA8AE: using guessed type int sub_80AA8AE(void);
// 8433EA4: using guessed type int dword_8433EA4;

//----- (080B055C) --------------------------------------------------------
void __cdecl __noreturn sub_80B055C(int a1)
{
  sub_80A5540();
  sub_80A59C2();
  byte_8433EAC = 1;
  sub_80B04E8(a1);
}
// 8433EAC: using guessed type char byte_8433EAC;

//----- (080B05A0) --------------------------------------------------------
void __cdecl __noreturn sub_80B05A0(int a1, int a2)
{
  dword_8433EA8 = a1 + 1;
  sub_80B04E8(a2);
}
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080B05DC) --------------------------------------------------------
void __cdecl __noreturn sub_80B05DC(int a1)
{
  dword_8433EA8 = -1;
  sub_80B04E8(a1);
}
// 8433EA8: using guessed type int dword_8433EA8;

//----- (080B061A) --------------------------------------------------------
int __cdecl sub_80B061A(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_8433F64 = 1;
  dword_8433F68 = a4;
  result = sub_80A1AE4(a1, a2, a3);
  while ( dword_8433F64 )
  {
    result = sub_80AA74C(dword_8433F68);
    dword_8433F68 -= 8;
    --dword_8433F64;
  }
  return result;
}
// 8433F64: using guessed type int dword_8433F64;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0674) --------------------------------------------------------
int __cdecl sub_80B0674(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_8433F68 = a4 - 8;
  *(a4 + 4) = 0;
  result = sub_80A1B07(a1, a2, a3);
  dword_8433F60 = 0;
  return result;
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B06B4) --------------------------------------------------------
int __cdecl sub_80B06B4(int a1, int a2, unsigned __int16 a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]

  v5 = sub_80A80E8(a1, a2);
  v4 = sub_80A6F20(v5, a3);
  result = sub_80A76C8(v4, dword_8433F68);
  dword_8433F68 -= 8;
  dword_8433F60 = 0;
  return result;
}
// 8433F60: using guessed type int dword_8433F60;
// 8433F68: using guessed type int dword_8433F68;

//----- (080B0718) --------------------------------------------------------
int __cdecl sub_80B0718(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp+8h]

  v2 = a1 & 0xFFFFFF;
  if ( v2 - dword_8433F6C <= 0 )
  {
    result = v2;
    dword_8433F6C = v2;
  }
  else
  {
    do
    {
      sub_80AF3DA();
      ++dword_8433F6C;
      dword_8433F6C &= 0xFFFFFFu;
      result = dword_8433F6C;
    }
    while ( dword_8433F6C != v2 );
  }
  return result;
}
// 8433F6C: using guessed type int dword_8433F6C;

//----- (080B0760) --------------------------------------------------------
void sub_80B0760()
{
  sub_80AF3DA();
}

//----- (080B076E) --------------------------------------------------------
unsigned __int64 sub_80B076E()
{
  unsigned __int64 result; // rax

  result = sub_80B0876();
  dword_8433F78 = result;
  return result;
}
// 8433F78: using guessed type int dword_8433F78;

//----- (080B0780) --------------------------------------------------------
int __cdecl sub_80B0780(unsigned __int16 *a1)
{
  size_t v1; // eax
  void *v2; // esp
  char v4[4]; // [esp+10h] [ebp-18h] BYREF
  char *src; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]
  size_t n; // [esp+20h] [ebp-8h]
  char *dest; // [esp+24h] [ebp-4h]

  s = sub_80A4458(*a1);
  src = sub_80A4458(a1[4]);
  v7 = strlen(s);
  v1 = strlen(src);
  n = v7 + v1 + 1;
  v2 = alloca(16 * ((v7 + v1 + 16) >> 4));
  dest = v4;
  strcpy(v4, s);
  strcpy(&dest[v7], src);
  return sub_80A4884(dest, 0, n);
}

//----- (080B082E) --------------------------------------------------------
int __cdecl sub_80B082E(float a1)
{
  return (a1 + 0.5);
}

//----- (080B085C) --------------------------------------------------------
long double __cdecl sub_80B085C(float a1)
{
  return fabs(a1);
}

//----- (080B0876) --------------------------------------------------------
unsigned __int64 sub_80B0876()
{
  return __rdtsc();
}

//----- (080B0892) --------------------------------------------------------
void sub_80B0892()
{
  ;
}

//----- (080B0898) --------------------------------------------------------
int __cdecl sub_80B0898(int a1)
{
  return sub_80AB0B2(a1, a1 + 8);
}

//----- (080B08B8) --------------------------------------------------------
int __cdecl sub_80B08B8(int a1, int a2)
{
  int result; // eax

  result = sub_80A4DC6(a1, 0, a2 + 1, 13);
  LOWORD(dword_850C6EC) = result;
  return result;
}
// 850C6EC: using guessed type int dword_850C6EC;

//----- (080B08E9) --------------------------------------------------------
int __cdecl sub_80B08E9(_BYTE *a1, int a2)
{
  void *v2; // esp
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch] BYREF
  char *s; // [esp+10h] [ebp-8h]
  int *v6; // [esp+14h] [ebp-4h]
  _BYTE *v7; // [esp+20h] [ebp+8h]
  int v8; // [esp+24h] [ebp+Ch]

  v2 = alloca(16 * ((a2 + 16) >> 4));
  s = &v4;
  v6 = &v4;
  while ( a2 )
  {
    if ( *a1 == 92 )
    {
      v8 = a2 - 1;
      if ( !v8 )
        break;
      v7 = a1 + 1;
      v4 = *v7;
      if ( v4 == 114 )
      {
        *v6 = 13;
        v6 = (v6 + 1);
        goto LABEL_16;
      }
      if ( v4 > 114 )
      {
        if ( v4 == 116 )
        {
          *v6 = 9;
          v6 = (v6 + 1);
          goto LABEL_16;
        }
      }
      else if ( v4 == 110 )
      {
        *v6 = 10;
        v6 = (v6 + 1);
        goto LABEL_16;
      }
      *v6 = *v7;
      v6 = (v6 + 1);
LABEL_16:
      a2 = v8 - 1;
      a1 = v7 + 1;
    }
    else
    {
      --a2;
      *v6 = *a1++;
      v6 = (v6 + 1);
    }
  }
  *v6 = 0;
  result = sub_80A4D5C(s, 0);
  LOWORD(dword_850C6EC) = result;
  return result;
}
// 850C6EC: using guessed type int dword_850C6EC;

//----- (080B09DE) --------------------------------------------------------
int __cdecl sub_80B09DE(char *s)
{
  return sscanf(s, "%d", &dword_850C6EC);
}
// 850C6EC: using guessed type int dword_850C6EC;

//----- (080B0A01) --------------------------------------------------------
int __cdecl sub_80B0A01(char *s)
{
  return sscanf(s, "%f", &dword_850C6EC);
}
// 850C6EC: using guessed type int dword_850C6EC;

//----- (080B0A24) --------------------------------------------------------
int sub_80B0A24()
{
  int v1; // [esp+14h] [ebp-24h]
  unsigned __int8 v2; // [esp+1Bh] [ebp-1Dh]
  int v3; // [esp+1Ch] [ebp-1Ch]
  char *v4; // [esp+20h] [ebp-18h]
  char *v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v8; // [esp+30h] [ebp-8h]
  int v9; // [esp+34h] [ebp-4h]

  if ( dword_80F72CC )
  {
    dword_80F72CC = 0;
    if ( !dword_80F72D0 )
      dword_80F72D0 = 1;
    if ( !dword_80F72D4 )
      dword_80F72D4 = stdin;
    if ( !dword_80F72D8 )
      dword_80F72D8 = stdout;
    if ( !dword_80F72C4 )
      dword_80F72C4 = sub_80B245F(dword_80F72D4, 0x4000);
    sub_80B2422();
  }
LABEL_11:
  v5 = dword_80F72C8;
  *dword_80F72C8 = byte_8433F90;
  v4 = v5;
  v6 = dword_80F72D0;
  do
  {
LABEL_12:
    v2 = byte_80E8A00[4 * *v5];
    if ( word_80E8800[v6] )
    {
      dword_8433F9C = v6;
      dword_8433FA0 = v5;
    }
    while ( word_80E96A0[v2 + word_80E8F00[v6]] != v6 )
    {
      v6 = word_80E9100[v6];
      if ( v6 > 244 )
        v2 = byte_80E8E00[4 * v2];
    }
    v6 = word_80E9300[v2 + word_80E8F00[v6]];
    ++v5;
  }
  while ( word_80E8F00[v6] != 395 );
  while ( 1 )
  {
    v3 = word_80E8800[v6];
    if ( !word_80E8800[v6] )
    {
      v5 = dword_8433FA0;
      v3 = word_80E8800[dword_8433F9C];
    }
    dword_850C2E4 = v4;
    size = v5 - v4;
    byte_8433F90 = *v5;
    *v5 = 0;
    dword_80F72C8 = v5;
LABEL_21:
    switch ( v3 )
    {
      case 0:
        *v5 = byte_8433F90;
        v5 = dword_8433FA0;
        v6 = dword_8433F9C;
        continue;
      case 1:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        goto LABEL_11;
      case 2:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        dword_80F72D0 = 3;
        goto LABEL_11;
      case 3:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        goto LABEL_11;
      case 4:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        goto LABEL_11;
      case 5:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        goto LABEL_11;
      case 6:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        dword_80F72D0 = 5;
        goto LABEL_11;
      case 7:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B08E9(dword_850C2E4 + 1, size - 2);
        return 259;
      case 8:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B08E9(dword_850C2E4 + 2, size - 3);
        return 260;
      case 9:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 261;
      case 10:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 262;
      case 11:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 263;
      case 12:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 264;
      case 13:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 265;
      case 14:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 266;
      case 15:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 267;
      case 16:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 268;
      case 17:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 269;
      case 18:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 270;
      case 19:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 271;
      case 20:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 272;
      case 21:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 273;
      case 22:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 274;
      case 23:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 275;
      case 24:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 276;
      case 25:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 277;
      case 26:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 278;
      case 27:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 279;
      case 28:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 280;
      case 29:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 281;
      case 30:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 282;
      case 31:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 283;
      case 32:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 284;
      case 33:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 285;
      case 34:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 286;
      case 35:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B09DE(dword_850C2E4);
        return 287;
      case 36:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B0A01(dword_850C2E4);
        return 288;
      case 37:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 290;
      case 38:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 289;
      case 39:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 295;
      case 40:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 291;
      case 41:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 294;
      case 42:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 292;
      case 43:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 293;
      case 44:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 296;
      case 45:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 297;
      case 46:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 298;
      case 47:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 299;
      case 48:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 300;
      case 49:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 301;
      case 50:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 302;
      case 51:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 303;
      case 52:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 304;
      case 53:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 305;
      case 54:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 306;
      case 55:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 307;
      case 56:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 308;
      case 57:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 309;
      case 58:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 310;
      case 59:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 311;
      case 60:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 312;
      case 61:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 313;
      case 62:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 314;
      case 63:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 315;
      case 64:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 316;
      case 65:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 317;
      case 66:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 318;
      case 67:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 319;
      case 68:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 320;
      case 69:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 321;
      case 70:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 322;
      case 71:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 323;
      case 72:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 324;
      case 73:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 325;
      case 74:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 326;
      case 75:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 327;
      case 76:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 329;
      case 77:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 330;
      case 78:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 331;
      case 79:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 332;
      case 80:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 333;
      case 81:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 334;
      case 82:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 335;
      case 83:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 336;
      case 84:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 337;
      case 85:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 338;
      case 86:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 339;
      case 87:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 340;
      case 88:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 341;
      case 89:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        return 342;
      case 90:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B08B8(dword_850C2E4, size);
        return 258;
      case 91:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80B08B8(dword_850C2E4, size);
        return 328;
      case 92:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        sub_80A3D50(dword_8433F8C, "bad token '%s'", dword_850C2E4);
      case 93:
        dword_850C6F0 = dword_8433F84;
        dword_8433F8C = dword_8433F84;
        dword_8433F84 += size;
        fwrite(dword_850C2E4, size, 1u, dword_80F72D8);
        goto LABEL_11;
      case 94:
        v9 = v5 - dword_850C2E4 - 1;
        *v5 = byte_8433F90;
        if ( !*(dword_80F72C4 + 36) )
        {
          dword_8433F94 = *(dword_80F72C4 + 16);
          *dword_80F72C4 = dword_80F72D4;
          *(dword_80F72C4 + 36) = 1;
        }
        if ( dword_80F72C8 <= (dword_8433F94 + *(dword_80F72C4 + 4)) )
        {
          dword_80F72C8 = &dword_850C2E4[v9];
          v6 = sub_80B20EA();
          v8 = sub_80B21C2(v6);
          v4 = dword_850C2E4;
          if ( v8 )
          {
            v5 = ++dword_80F72C8;
            v6 = v8;
            goto LABEL_12;
          }
          v5 = dword_80F72C8;
          continue;
        }
        v1 = sub_80B1E14();
        if ( v1 == 1 )
        {
          dword_8433F98 = 0;
          if ( sub_80B28D4() )
          {
            dword_80F72C8 = dword_850C2E4;
            v3 = (dword_80F72D0 - 1) / 2 + 95;
            goto LABEL_21;
          }
          if ( !dword_8433F98 )
            sub_80B237F(dword_80F72D4);
          goto LABEL_11;
        }
        if ( v1 <= 1 )
        {
          if ( v1 )
            goto LABEL_11;
          dword_80F72C8 = &dword_850C2E4[v9];
          v6 = sub_80B20EA();
          v5 = dword_80F72C8;
          v4 = dword_850C2E4;
          goto LABEL_12;
        }
        if ( v1 != 2 )
          goto LABEL_11;
        dword_80F72C8 = dword_8433F94 + *(dword_80F72C4 + 4);
        v6 = sub_80B20EA();
        v5 = dword_80F72C8;
        v4 = dword_850C2E4;
        break;
      case 95:
      case 96:
      case 97:
        return 0;
      default:
        sub_80B2792("fatal flex scanner internal error--no action found");
    }
  }
}
// 80F72C8: using guessed type int dword_80F72C8;
// 80F72CC: using guessed type int dword_80F72CC;
// 80F72D0: using guessed type int dword_80F72D0;
// 80FE1EC: using guessed type int stdin;
// 8433F84: using guessed type int dword_8433F84;
// 8433F90: using guessed type char byte_8433F90;
// 8433F94: using guessed type int dword_8433F94;
// 8433F98: using guessed type int dword_8433F98;
// 8433F9C: using guessed type int dword_8433F9C;
// 8433FA0: using guessed type int dword_8433FA0;
// 850C6F0: using guessed type int dword_850C6F0;

//----- (080B1E14) --------------------------------------------------------
int sub_80B1E14()
{
  int v0; // eax
  int i; // [esp+8h] [ebp-30h]
  int v3; // [esp+Ch] [ebp-2Ch]
  char *v4; // [esp+10h] [ebp-28h]
  _BYTE *v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  char v7; // [esp+1Fh] [ebp-19h]
  int k; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v5 = *(dword_80F72C4 + 4);
  v4 = dword_850C2E4;
  if ( dword_80F72C8 > &v5[dword_8433F94 + 1] )
    sub_80B2792("fatal flex scanner internal error--end of buffer missed");
  if ( *(dword_80F72C4 + 32) )
  {
    v3 = dword_80F72C8 - dword_850C2E4 - 1;
    for ( i = 0; i < v3; ++i )
      *v5++ = *v4++;
    if ( *(dword_80F72C4 + 36) == 2 )
    {
      dword_8433F94 = 0;
      *(dword_80F72C4 + 16) = 0;
    }
    else
    {
      for ( j = *(dword_80F72C4 + 12) - v3 - 1; j <= 0; j = *(dword_80F72C4 + 12) - v3 - 1 )
      {
        v10 = dword_80F72C4;
        v9 = dword_80F72C8 - *(dword_80F72C4 + 4);
        if ( *(dword_80F72C4 + 20) )
        {
          if ( 2 * *(dword_80F72C4 + 12) > 0 )
            v0 = 2 * *(dword_80F72C4 + 12);
          else
            v0 = *(dword_80F72C4 + 12) + (*(dword_80F72C4 + 12) >> 3);
          *(dword_80F72C4 + 12) = v0;
          *(v10 + 4) = sub_80B27D3(*(v10 + 4), *(v10 + 12) + 2);
        }
        else
        {
          *(dword_80F72C4 + 4) = 0;
        }
        if ( !*(v10 + 4) )
          sub_80B2792("fatal error - scanner input buffer overflow");
        dword_80F72C8 = *(v10 + 4) + v9;
      }
      if ( j > 0x2000 )
        j = 0x2000;
      v7 = 42;
      for ( k = 0; k < j; ++k )
      {
        v7 = *dword_8433F88++;
        if ( !v7 || v7 == 10 )
          break;
        *(k + *(dword_80F72C4 + 4) + v3) = v7;
      }
      if ( v7 == 10 )
      {
        *(k + *(dword_80F72C4 + 4) + v3) = 10;
        ++k;
      }
      else if ( !v7 )
      {
        --dword_8433F88;
      }
      dword_8433F94 = k;
      *(dword_80F72C4 + 16) = k;
    }
    if ( dword_8433F94 )
    {
      v12 = 0;
    }
    else if ( v3 )
    {
      v12 = 2;
      *(dword_80F72C4 + 36) = 2;
    }
    else
    {
      v12 = 1;
      sub_80B237F(dword_80F72D4);
    }
    dword_8433F94 += v3;
    *(*(dword_80F72C4 + 4) + dword_8433F94) = 0;
    *(*(dword_80F72C4 + 4) + dword_8433F94 + 1) = 0;
    dword_850C2E4 = *(dword_80F72C4 + 4);
    v6 = v12;
  }
  else if ( dword_80F72C8 - dword_850C2E4 == 1 )
  {
    v6 = 1;
  }
  else
  {
    v6 = 2;
  }
  return v6;
}
// 80F72C8: using guessed type int dword_80F72C8;
// 8433F88: using guessed type int dword_8433F88;
// 8433F94: using guessed type int dword_8433F94;

//----- (080B20EA) --------------------------------------------------------
int sub_80B20EA()
{
  unsigned __int8 v1; // [esp+3h] [ebp-9h]
  char *i; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  v3 = dword_80F72D0;
  for ( i = dword_850C2E4; i < dword_80F72C8; ++i )
  {
    if ( *i )
      v1 = byte_80E8A00[4 * *i];
    else
      v1 = 1;
    if ( word_80E8800[v3] )
    {
      dword_8433F9C = v3;
      dword_8433FA0 = i;
    }
    while ( word_80E96A0[v1 + word_80E8F00[v3]] != v3 )
    {
      v3 = word_80E9100[v3];
      if ( v3 > 244 )
        v1 = byte_80E8E00[4 * v1];
    }
    v3 = word_80E9300[v1 + word_80E8F00[v3]];
  }
  return v3;
}
// 80F72C8: using guessed type int dword_80F72C8;
// 80F72D0: using guessed type int dword_80F72D0;
// 8433F9C: using guessed type int dword_8433F9C;
// 8433FA0: using guessed type int dword_8433FA0;

//----- (080B21C2) --------------------------------------------------------
int __cdecl sub_80B21C2(int a1)
{
  int v2; // [esp+0h] [ebp-Ch]
  unsigned __int8 v3; // [esp+7h] [ebp-5h]
  int v4; // [esp+14h] [ebp+8h]

  v3 = 1;
  if ( word_80E8800[a1] )
  {
    dword_8433F9C = a1;
    dword_8433FA0 = dword_80F72C8;
  }
  while ( word_80E96A0[v3 + word_80E8F00[a1]] != a1 )
  {
    a1 = word_80E9100[a1];
    if ( a1 > 244 )
      v3 = byte_80E8E00[4 * v3];
  }
  v4 = word_80E9300[v3 + word_80E8F00[a1]];
  if ( v4 == 244 )
    v2 = 0;
  else
    v2 = v4;
  return v2;
}
// 80F72C8: using guessed type int dword_80F72C8;
// 8433F9C: using guessed type int dword_8433F9C;
// 8433FA0: using guessed type int dword_8433FA0;

//----- (080B227E) --------------------------------------------------------
int sub_80B227E()
{
  int v1; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  *dword_80F72C8 = byte_8433F90;
  if ( *dword_80F72C8 )
    goto LABEL_16;
  if ( dword_80F72C8 < (dword_8433F94 + *(dword_80F72C4 + 4)) )
  {
    *dword_80F72C8 = 0;
    goto LABEL_16;
  }
  v3 = dword_80F72C8 - dword_850C2E4;
  ++dword_80F72C8;
  v1 = sub_80B1E14();
  if ( v1 != 1 )
  {
    if ( v1 <= 1 )
    {
      if ( !v1 )
        dword_80F72C8 = &dword_850C2E4[v3];
      goto LABEL_16;
    }
    if ( v1 != 2 )
    {
LABEL_16:
      v4 = *dword_80F72C8;
      *dword_80F72C8++ = 0;
      byte_8433F90 = *dword_80F72C8;
      return v4;
    }
    sub_80B237F(dword_80F72D4);
  }
  if ( sub_80B28D4() )
    return -1;
  if ( !dword_8433F98 )
    sub_80B237F(dword_80F72D4);
  return sub_80B227E();
}
// 80F72C8: using guessed type int dword_80F72C8;
// 8433F90: using guessed type char byte_8433F90;
// 8433F94: using guessed type int dword_8433F94;
// 8433F98: using guessed type int dword_8433F98;

//----- (080B237F) --------------------------------------------------------
int __cdecl sub_80B237F(FILE *stream)
{
  if ( !dword_80F72C4 )
    dword_80F72C4 = sub_80B245F(dword_80F72D4, 0x4000);
  sub_80B2528(dword_80F72C4, stream);
  return sub_80B2422();
}

//----- (080B23C3) --------------------------------------------------------
int __cdecl sub_80B23C3(int a1)
{
  int result; // eax

  result = dword_80F72C4;
  if ( dword_80F72C4 != a1 )
  {
    if ( dword_80F72C4 )
    {
      *dword_80F72C8 = byte_8433F90;
      *(dword_80F72C4 + 8) = dword_80F72C8;
      *(dword_80F72C4 + 16) = dword_8433F94;
    }
    dword_80F72C4 = a1;
    result = sub_80B2422();
    dword_8433F98 = 1;
  }
  return result;
}
// 80F72C8: using guessed type int dword_80F72C8;
// 8433F90: using guessed type char byte_8433F90;
// 8433F94: using guessed type int dword_8433F94;
// 8433F98: using guessed type int dword_8433F98;

//----- (080B2422) --------------------------------------------------------
int sub_80B2422()
{
  int result; // eax

  dword_8433F94 = *(dword_80F72C4 + 16);
  dword_80F72C8 = *(dword_80F72C4 + 8);
  dword_850C2E4 = dword_80F72C8;
  dword_80F72D4 = *dword_80F72C4;
  result = *dword_80F72C8;
  byte_8433F90 = *dword_80F72C8;
  return result;
}
// 80F72C8: using guessed type int dword_80F72C8;
// 8433F90: using guessed type char byte_8433F90;
// 8433F94: using guessed type int dword_8433F94;

//----- (080B245F) --------------------------------------------------------
_DWORD *__cdecl sub_80B245F(FILE *stream, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80B27C0(0x28u);
  if ( !v3 )
    sub_80B2792("out of dynamic memory in yy_create_buffer()");
  v3[3] = a2;
  v3[1] = sub_80B27C0(v3[3] + 2);
  if ( !v3[1] )
    sub_80B2792("out of dynamic memory in yy_create_buffer()");
  v3[5] = 1;
  sub_80B2528(v3, stream);
  return v3;
}

//----- (080B2528) --------------------------------------------------------
_BOOL4 __cdecl sub_80B2528(int a1, FILE *stream)
{
  int v2; // eax
  _BOOL4 result; // eax
  _BOOL4 v4; // [esp+10h] [ebp-8h]

  sub_80B258E(a1);
  *a1 = stream;
  *(a1 + 32) = 1;
  if ( stream )
  {
    v2 = fileno(stream);
    v4 = isatty(v2) > 0;
  }
  else
  {
    v4 = 0;
  }
  result = v4;
  *(a1 + 24) = v4;
  return result;
}

//----- (080B258E) --------------------------------------------------------
int __cdecl sub_80B258E(int a1)
{
  int result; // eax

  if ( a1 )
  {
    *(a1 + 16) = 0;
    **(a1 + 4) = 0;
    *(*(a1 + 4) + 1) = 0;
    *(a1 + 8) = *(a1 + 4);
    *(a1 + 28) = 1;
    *(a1 + 36) = 0;
    result = a1;
    if ( a1 == dword_80F72C4 )
      result = sub_80B2422();
  }
  return result;
}

//----- (080B25EB) --------------------------------------------------------
_DWORD *__cdecl sub_80B25EB(int a1, unsigned int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( a2 <= 1 || *(a1 + a2 - 2) || *(a1 + a2 - 1) )
    return 0;
  v4 = sub_80B27C0(0x28u);
  if ( !v4 )
    sub_80B2792("out of dynamic memory in yy_scan_buffer()");
  v4[3] = a2 - 2;
  v4[1] = a1;
  v4[2] = a1;
  v4[5] = 0;
  *v4 = 0;
  v4[4] = v4[3];
  v4[6] = 0;
  v4[7] = 1;
  v4[8] = 0;
  v4[9] = 0;
  sub_80B23C3(v4);
  return v4;
}

//----- (080B26ED) --------------------------------------------------------
_DWORD *__cdecl sub_80B26ED(int a1, int a2)
{
  int i; // [esp+8h] [ebp-10h]
  _BYTE *v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v4 = sub_80B27C0(a2 + 2);
  if ( !v4 )
    sub_80B2792("out of dynamic memory in yy_scan_bytes()");
  for ( i = 0; i < a2; ++i )
    v4[i] = *(a1 + i);
  v4[a2 + 1] = 0;
  v4[a2] = 0;
  v5 = sub_80B25EB(v4, a2 + 2);
  if ( !v5 )
    sub_80B2792("bad buffer in yy_scan_bytes()");
  v5[5] = 1;
  return v5;
}

//----- (080B2792) --------------------------------------------------------
void __cdecl __noreturn sub_80B2792(const char *a1)
{
  fprintf(stderr, "%s\n", a1);
  exit(2);
}

//----- (080B27C0) --------------------------------------------------------
void *__cdecl sub_80B27C0(size_t size)
{
  return malloc(size);
}

//----- (080B27D3) --------------------------------------------------------
void *__cdecl sub_80B27D3(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (080B27ED) --------------------------------------------------------
void __cdecl sub_80B27ED(void *ptr)
{
  free(ptr);
}

//----- (080B2800) --------------------------------------------------------
int sub_80B2800()
{
  if ( !dword_850D6A0 )
    sub_80A3D50(dword_8433F8C, "unexpected end of file found");
  if ( dword_850D6A0 != 257 )
    sub_80A3D50(dword_8433F8C, "bad syntax");
  return 0;
}
// 850D6A0: using guessed type int dword_850D6A0;

//----- (080B284E) --------------------------------------------------------
int __cdecl sub_80B284E(int a1, _DWORD *a2)
{
  int result; // eax
  char v3; // [esp+10h] [ebp-4048h] BYREF
  int v4[14]; // [esp+4020h] [ebp-38h] BYREF

  dword_8433F88 = a1;
  dword_8433F84 = 0;
  dword_8433F8C = 0;
  dword_80F72CC = 1;
  v4[3] = 0x4000;
  v4[1] = &v3;
  v4[5] = 0;
  sub_80B2528(v4, 0);
  dword_80F72C4 = v4;
  dword_80F72D0 = 3;
  sub_80B28DE();
  result = dword_8433F80;
  *a2 = dword_8433F80;
  return result;
}
// 80F72CC: using guessed type int dword_80F72CC;
// 80F72D0: using guessed type int dword_80F72D0;
// 8433F80: using guessed type int dword_8433F80;
// 8433F84: using guessed type int dword_8433F84;
// 8433F88: using guessed type int dword_8433F88;

//----- (080B28D4) --------------------------------------------------------
int sub_80B28D4()
{
  return 1;
}

//----- (080B28DE) --------------------------------------------------------
int sub_80B28DE()
{
  int v0; // ecx
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int *v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v12; // [esp+20h] [ebp-2B8h]
  int v13; // [esp+20h] [ebp-2B8h]
  int v14; // [esp+24h] [ebp-2B4h]
  int v15; // [esp+24h] [ebp-2B4h]
  int v16; // [esp+24h] [ebp-2B4h]
  int v17; // [esp+24h] [ebp-2B4h]
  int v18; // [esp+24h] [ebp-2B4h]
  int v19; // [esp+28h] [ebp-2B0h]
  int v20; // [esp+28h] [ebp-2B0h]
  int v22; // [esp+30h] [ebp-2A8h] BYREF
  int v23; // [esp+34h] [ebp-2A4h] BYREF
  int v24; // [esp+38h] [ebp-2A0h] BYREF
  int v25; // [esp+3Ch] [ebp-29Ch] BYREF
  int v26; // [esp+40h] [ebp-298h] BYREF
  int v27; // [esp+44h] [ebp-294h] BYREF
  int v28; // [esp+48h] [ebp-290h] BYREF
  int v29; // [esp+4Ch] [ebp-28Ch] BYREF
  int v30; // [esp+50h] [ebp-288h] BYREF
  _DWORD *v31; // [esp+54h] [ebp-284h] BYREF
  int v32; // [esp+58h] [ebp-280h] BYREF
  int v33; // [esp+5Ch] [ebp-27Ch] BYREF
  int v34; // [esp+60h] [ebp-278h] BYREF
  int v35; // [esp+64h] [ebp-274h] BYREF
  int v36; // [esp+68h] [ebp-270h] BYREF
  int v37; // [esp+6Ch] [ebp-26Ch] BYREF
  int v38; // [esp+70h] [ebp-268h] BYREF
  int v39; // [esp+74h] [ebp-264h] BYREF
  int v40; // [esp+78h] [ebp-260h] BYREF
  int v41; // [esp+7Ch] [ebp-25Ch] BYREF
  int v42; // [esp+80h] [ebp-258h] BYREF
  int v43; // [esp+84h] [ebp-254h] BYREF
  int v44; // [esp+88h] [ebp-250h] BYREF
  int v45; // [esp+8Ch] [ebp-24Ch] BYREF
  int v46; // [esp+90h] [ebp-248h] BYREF
  int v47; // [esp+94h] [ebp-244h] BYREF
  int v48; // [esp+98h] [ebp-240h] BYREF
  int v49; // [esp+9Ch] [ebp-23Ch] BYREF
  int v50; // [esp+A0h] [ebp-238h] BYREF
  int v51; // [esp+A4h] [ebp-234h] BYREF
  int v52; // [esp+A8h] [ebp-230h] BYREF
  int v53; // [esp+ACh] [ebp-22Ch] BYREF
  int v54; // [esp+B0h] [ebp-228h] BYREF
  _DWORD *v55; // [esp+B4h] [ebp-224h] BYREF
  int v56; // [esp+B8h] [ebp-220h] BYREF
  int v57; // [esp+BCh] [ebp-21Ch] BYREF
  int v58; // [esp+C0h] [ebp-218h] BYREF
  int v59; // [esp+C4h] [ebp-214h] BYREF
  int v60; // [esp+C8h] [ebp-210h] BYREF
  int v61; // [esp+CCh] [ebp-20Ch] BYREF
  int v62; // [esp+D0h] [ebp-208h] BYREF
  int v63; // [esp+D4h] [ebp-204h] BYREF
  int v64; // [esp+D8h] [ebp-200h] BYREF
  int v65; // [esp+DCh] [ebp-1FCh] BYREF
  int v66; // [esp+E0h] [ebp-1F8h] BYREF
  int v67; // [esp+E4h] [ebp-1F4h] BYREF
  int v68; // [esp+E8h] [ebp-1F0h] BYREF
  int v69; // [esp+ECh] [ebp-1ECh] BYREF
  int v70; // [esp+F0h] [ebp-1E8h] BYREF
  int v71; // [esp+F4h] [ebp-1E4h] BYREF
  int v72; // [esp+F8h] [ebp-1E0h] BYREF
  int v73; // [esp+FCh] [ebp-1DCh] BYREF
  int v74; // [esp+100h] [ebp-1D8h] BYREF
  int v75; // [esp+104h] [ebp-1D4h] BYREF
  int v76; // [esp+108h] [ebp-1D0h] BYREF
  int v77; // [esp+10Ch] [ebp-1CCh] BYREF
  int v78; // [esp+110h] [ebp-1C8h] BYREF
  int v79; // [esp+114h] [ebp-1C4h] BYREF
  int v80; // [esp+118h] [ebp-1C0h] BYREF
  int v81; // [esp+11Ch] [ebp-1BCh] BYREF
  int v82; // [esp+120h] [ebp-1B8h] BYREF
  int v83; // [esp+124h] [ebp-1B4h] BYREF
  int v84; // [esp+128h] [ebp-1B0h] BYREF
  int v85; // [esp+12Ch] [ebp-1ACh] BYREF
  int v86; // [esp+130h] [ebp-1A8h] BYREF
  int v87; // [esp+134h] [ebp-1A4h] BYREF
  int v88; // [esp+138h] [ebp-1A0h] BYREF
  int v89; // [esp+13Ch] [ebp-19Ch] BYREF
  int v90; // [esp+140h] [ebp-198h] BYREF
  int v91; // [esp+144h] [ebp-194h] BYREF
  int v92; // [esp+148h] [ebp-190h] BYREF
  int v93; // [esp+14Ch] [ebp-18Ch] BYREF
  int v94; // [esp+150h] [ebp-188h] BYREF
  int v95; // [esp+154h] [ebp-184h] BYREF
  int v96; // [esp+158h] [ebp-180h] BYREF
  int v97; // [esp+15Ch] [ebp-17Ch] BYREF
  int v98; // [esp+160h] [ebp-178h] BYREF
  int v99; // [esp+164h] [ebp-174h] BYREF
  int v100; // [esp+168h] [ebp-170h] BYREF
  int v101; // [esp+16Ch] [ebp-16Ch] BYREF
  int v102; // [esp+170h] [ebp-168h] BYREF
  int v103; // [esp+174h] [ebp-164h] BYREF
  int v104; // [esp+178h] [ebp-160h] BYREF
  int v105; // [esp+17Ch] [ebp-15Ch] BYREF
  int v106; // [esp+180h] [ebp-158h] BYREF
  int v107; // [esp+184h] [ebp-154h] BYREF
  int v108; // [esp+188h] [ebp-150h] BYREF
  int v109; // [esp+18Ch] [ebp-14Ch] BYREF
  int v110; // [esp+190h] [ebp-148h] BYREF
  int v111; // [esp+194h] [ebp-144h] BYREF
  int v112; // [esp+198h] [ebp-140h] BYREF
  int v113; // [esp+19Ch] [ebp-13Ch] BYREF
  int v114; // [esp+1A0h] [ebp-138h] BYREF
  int v115; // [esp+1A4h] [ebp-134h] BYREF
  int v116; // [esp+1A8h] [ebp-130h] BYREF
  int v117; // [esp+1ACh] [ebp-12Ch] BYREF
  int v118; // [esp+1B0h] [ebp-128h] BYREF
  int v119; // [esp+1B4h] [ebp-124h] BYREF
  int v120; // [esp+1B8h] [ebp-120h] BYREF
  int v121; // [esp+1BCh] [ebp-11Ch] BYREF
  int v122; // [esp+1C0h] [ebp-118h] BYREF
  int v123; // [esp+1C4h] [ebp-114h] BYREF
  int v124; // [esp+1C8h] [ebp-110h] BYREF
  int v125; // [esp+1CCh] [ebp-10Ch] BYREF
  int v126; // [esp+1D0h] [ebp-108h] BYREF
  int v127; // [esp+1D4h] [ebp-104h] BYREF
  int v128; // [esp+1D8h] [ebp-100h] BYREF
  int v129; // [esp+1DCh] [ebp-FCh] BYREF
  int v130; // [esp+1E0h] [ebp-F8h] BYREF
  int v131; // [esp+1E4h] [ebp-F4h] BYREF
  int v132; // [esp+1E8h] [ebp-F0h] BYREF
  int v133; // [esp+1ECh] [ebp-ECh] BYREF
  int v134; // [esp+1F0h] [ebp-E8h] BYREF
  int v135; // [esp+1F4h] [ebp-E4h] BYREF
  int v136; // [esp+1F8h] [ebp-E0h] BYREF
  int v137; // [esp+1FCh] [ebp-DCh] BYREF
  int v138; // [esp+200h] [ebp-D8h] BYREF
  int v139; // [esp+204h] [ebp-D4h] BYREF
  int v140; // [esp+208h] [ebp-D0h] BYREF
  int v141; // [esp+20Ch] [ebp-CCh] BYREF
  int v142; // [esp+210h] [ebp-C8h] BYREF
  int v143; // [esp+214h] [ebp-C4h] BYREF
  int v144; // [esp+218h] [ebp-C0h] BYREF
  int v145; // [esp+21Ch] [ebp-BCh] BYREF
  int v146; // [esp+220h] [ebp-B8h] BYREF
  int v147; // [esp+224h] [ebp-B4h] BYREF
  int v148; // [esp+228h] [ebp-B0h] BYREF
  int v149; // [esp+22Ch] [ebp-ACh] BYREF
  int v150; // [esp+230h] [ebp-A8h] BYREF
  int v151; // [esp+234h] [ebp-A4h] BYREF
  int v152; // [esp+238h] [ebp-A0h] BYREF
  int v153; // [esp+23Ch] [ebp-9Ch] BYREF
  int v154; // [esp+240h] [ebp-98h] BYREF
  int v155; // [esp+244h] [ebp-94h] BYREF
  int v156; // [esp+248h] [ebp-90h] BYREF
  int v157; // [esp+24Ch] [ebp-8Ch] BYREF
  int v158; // [esp+250h] [ebp-88h] BYREF
  int v159; // [esp+254h] [ebp-84h] BYREF
  int v160; // [esp+258h] [ebp-80h] BYREF
  int v161; // [esp+25Ch] [ebp-7Ch] BYREF
  int v162; // [esp+260h] [ebp-78h] BYREF
  int v163; // [esp+264h] [ebp-74h] BYREF
  int v164; // [esp+268h] [ebp-70h] BYREF
  int v165; // [esp+26Ch] [ebp-6Ch] BYREF
  int v166; // [esp+270h] [ebp-68h] BYREF
  int v167; // [esp+274h] [ebp-64h] BYREF
  int v168; // [esp+278h] [ebp-60h] BYREF
  int v169; // [esp+27Ch] [ebp-5Ch] BYREF
  int v170; // [esp+280h] [ebp-58h] BYREF
  int v171; // [esp+284h] [ebp-54h] BYREF
  int v172; // [esp+288h] [ebp-50h] BYREF
  int v173; // [esp+28Ch] [ebp-4Ch] BYREF
  int v174; // [esp+290h] [ebp-48h] BYREF
  int v175; // [esp+294h] [ebp-44h] BYREF
  int v176; // [esp+298h] [ebp-40h] BYREF
  int v177; // [esp+29Ch] [ebp-3Ch] BYREF
  int v178; // [esp+2A0h] [ebp-38h] BYREF
  int v179; // [esp+2A4h] [ebp-34h] BYREF
  int v180; // [esp+2A8h] [ebp-30h] BYREF
  int v181; // [esp+2ACh] [ebp-2Ch] BYREF
  int v182; // [esp+2B0h] [ebp-28h] BYREF
  int v183; // [esp+2B4h] [ebp-24h] BYREF
  int v184; // [esp+2B8h] [ebp-20h] BYREF
  int v185; // [esp+2BCh] [ebp-1Ch] BYREF
  int v186; // [esp+2C0h] [ebp-18h] BYREF
  int v187; // [esp+2C4h] [ebp-14h] BYREF
  int v188; // [esp+2C8h] [ebp-10h] BYREF
  int v189[3]; // [esp+2CCh] [ebp-Ch] BYREF

  dword_850C2F0 = 0;
  dword_850C2E0 = 0;
  dword_850D6A0 = -1;
  dword_850C2EC = word_850C300;
  dword_850C2E8 = &unk_850C700;
  v12 = 0;
  word_850C300[0] = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v14 = word_80F5460[v12];
          if ( !word_80F5460[v12] )
            break;
LABEL_32:
          v19 = word_80F5360[v14];
          v4 = (dword_850C2E8 + 8 * (1 - v19));
          v5 = *v4;
          v6 = v4[1];
          dword_850C2F4 = v5;
          dword_850C2F8 = v6;
          switch ( v14 )
          {
            case 1:
              sub_80A40F0(&dword_8433F80, dword_850C2F4, *dword_850C2E8);
              break;
            case 2:
              sub_80A4042(v189, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 4, dword_850C2F4, v189[0]);
              break;
            case 3:
              sub_80A4042(&v188, *(dword_850C2E8 - 8 + 4));
              sub_80A4042(&v187, *(dword_850C2E8 + 4));
              sub_80A4042(&v186, dword_850C2F8);
              sub_80A4244(&dword_850C2F4, 43, dword_850C2F4, v186, *dword_850C2E8, v187, v188);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 4:
              sub_80A4042(&v185, *(dword_850C2E8 - 8 + 4));
              sub_80A4042(&v184, *(dword_850C2E8 + 4));
              sub_80A4042(&v183, dword_850C2F8);
              sub_80A4244(&dword_850C2F4, 44, dword_850C2F4, v183, *dword_850C2E8, v184, v185);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 5:
              sub_80A4042(&v182, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v181, 61);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v181, v182);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 6:
              sub_80A4042(&v180, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v179, 62);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v179, v180);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 7:
              sub_80A4042(&v178, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v177, 63);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v177, v178);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 8:
              sub_80A4042(&v176, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v175, 64);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v175, v176);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 9:
              sub_80A4042(&v174, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v173, 65);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v173, v174);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 10:
              sub_80A4042(&v172, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v171, 66);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v171, v172);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 11:
              sub_80A4042(&v170, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v169, 67);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v169, v170);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 12:
              sub_80A4042(&v168, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v167, 68);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v167, v168);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 13:
              sub_80A4042(&v166, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v165, 69);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v165, v166);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 14:
              sub_80A4042(&v164, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v163, 70);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v163, v164);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 15:
              sub_80A4042(&v162, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v161, 71);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v161, v162);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 16:
              sub_80A4042(&v160, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v159, 72);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v159, v160);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 17:
              sub_80A4042(&v158, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v157, 73);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v157, v158);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 18:
              sub_80A4042(&v156, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v155, 74);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v155, v156);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 19:
              sub_80A4042(&v154, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v153, 75);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v153, v154);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 20:
              sub_80A4042(&v152, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v151, 76);
              sub_80A41AA(&dword_850C2F4, 45, dword_850C2F4, *dword_850C2E8, v151, v152);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              break;
            case 21:
              sub_80A4042(&v150, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 46, *dword_850C2E8, v150);
              break;
            case 22:
              sub_80A4042(&v149, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 47, *dword_850C2E8, v149);
              break;
            case 23:
              sub_80A4042(&v148, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 48, *dword_850C2E8, v148);
              break;
            case 24:
              sub_80A4042(&v147, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 49, *dword_850C2E8, v147);
              break;
            case 25:
              sub_80A4042(&v146, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 50, *dword_850C2E8, v146);
              break;
            case 26:
              sub_80A4042(&v145, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 51, *dword_850C2E8, v145);
              break;
            case 27:
              sub_80A407E(&dword_850C2F4, 63, dword_850C2F4);
              break;
            case 28:
            case 89:
            case 99:
            case 107:
            case 122:
              sub_80A4054(&dword_850C2F4, 0);
              break;
            case 31:
              sub_80A4042(&v144, dword_850C2F8);
              sub_80A4124(&dword_850C2F4, 17, dword_850C2F4, *dword_850C2E8, v144);
              ++dword_829FA0C;
              break;
            case 32:
              sub_80A4042(&v143, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 16, dword_850C2F4, v143);
              break;
            case 33:
              sub_80A4042(&v142, dword_850C2F8);
              sub_80A4124(&dword_850C2F4, 17, dword_850C2F4, *dword_850C2E8, v142);
              dword_850C2F8 = *(dword_850C2E8 - 8 + 4);
              ++dword_829FA0C;
              break;
            case 34:
              sub_80A4042(&v141, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 16, *dword_850C2E8, v141);
              break;
            case 35:
              sub_80A4042(&v140, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 14, dword_850C2F4, v140);
              break;
            case 36:
              sub_80A4042(&v139, *(dword_850C2E8 - 16 + 4));
              sub_80A40B2(&dword_850C2F4, 18, *(dword_850C2E8 - 16), v139);
              break;
            case 37:
              sub_80A4042(&v138, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 22, dword_850C2F4, v138);
              break;
            case 38:
              sub_80A4042(&v137, *(dword_850C2E8 + 4));
              sub_80A4042(&v136, dword_850C2F8);
              sub_80A4124(&dword_850C2F4, 26, *dword_850C2E8, v136, v137);
              dword_850C2F8 = *(dword_850C2E8 + 4);
              break;
            case 39:
              sub_80A4042(&v135, *(dword_850C2E8 - 16 + 4));
              sub_80A4124(&dword_850C2F4, 19, dword_850C2F4, *(dword_850C2E8 - 8), v135);
              dword_850C2F8 = *(dword_850C2E8 - 16 + 4);
              break;
            case 40:
              sub_80A4042(&v134, *(dword_850C2E8 - 16 + 4));
              sub_80A4042(&v133, dword_850C2F8);
              sub_80A4244(&dword_850C2F4, 20, dword_850C2F4, *(dword_850C2E8 - 24), *(dword_850C2E8 - 8), v133, v134);
              dword_850C2F8 = *(dword_850C2E8 - 16 + 4);
              break;
            case 41:
              sub_80A4042(&v132, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 42, *(dword_850C2E8 - 8), v132);
              break;
            case 42:
              sub_80A4042(&v131, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 5, dword_850C2F4, v131);
              break;
            case 43:
              sub_80A4042(&v130, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 6, dword_850C2F4, v130);
              break;
            case 44:
              sub_80A4042(&v129, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 7, *dword_850C2E8, v129);
              break;
            case 45:
              sub_80A4042(&v128, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 8, *dword_850C2E8, v128);
              break;
            case 46:
              sub_80A4042(&v127, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 9, dword_850C2F4, v127);
              break;
            case 47:
              sub_80A4042(&v126, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 10, dword_850C2F4, v126);
              break;
            case 48:
              sub_80A407E(&dword_850C2F4, 15, dword_850C2F4);
              break;
            case 49:
              sub_80A4042(&v125, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 13, dword_850C2F4, v125);
              break;
            case 50:
              sub_80A4042(&v124, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 27, v124);
              break;
            case 51:
              sub_80A4042(&v123, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 28, v123);
              break;
            case 52:
              sub_80A4042(&v122, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 29, v122);
              break;
            case 53:
              sub_80A4042(&v121, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 30, v121);
              break;
            case 54:
              sub_80A4042(&v120, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 31, v120);
              break;
            case 55:
              sub_80A4042(&v119, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 52, dword_850C2F4, v119);
              dword_850C2F8 = *(dword_850C2E8 + 4);
              break;
            case 56:
              sub_80A4042(&v118, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 14, dword_850C2F4, v118);
              break;
            case 57:
              sub_80A4054(&dword_850C2F4, 64);
              break;
            case 58:
              sub_80A4042(&v117, *(dword_850C2E8 + 4));
              sub_80A40B2(&dword_850C2F4, 65, *dword_850C2E8, v117);
              break;
            case 59:
              sub_80A4042(&v116, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 69, dword_850C2F4, v116);
              break;
            case 60:
              sub_80A4042(&v115, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 70, dword_850C2F4, v115);
              break;
            case 61:
              sub_80A4042(&v114, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 71, v114);
              break;
            case 62:
              sub_80A4042(&v113, *(dword_850C2E8 + 4));
              sub_80A4042(&v112, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 12, dword_850C2F4, *dword_850C2E8, v112, v113);
              dword_850C2F8 = *(dword_850C2E8 + 4);
              break;
            case 63:
              sub_80A4042(&v111, *(dword_850C2E8 - 8 + 4));
              sub_80A4042(&v110, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 11, dword_850C2F4, *(dword_850C2E8 - 8), v110, v111);
              dword_850C2F8 = *(dword_850C2E8 - 16 + 4);
              break;
            case 64:
              sub_80A4042(&v109, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 3, dword_850C2F4, v109);
              break;
            case 65:
              sub_80A407E(&dword_850C2F4, 21, dword_850C2F4);
              break;
            case 66:
              sub_80A4042(&v108, *(dword_850C2E8 - 8 + 4));
              sub_80A4124(&dword_850C2F4, 2, dword_850C2F4, *dword_850C2E8, v108);
              break;
            case 67:
              sub_80A4042(&v107, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 23, *dword_850C2E8, v107);
              break;
            case 68:
              sub_80A4042(&v106, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 24, v106);
              break;
            case 69:
              sub_80A4042(&v105, dword_850C2F8);
              sub_80A4042(&v104, *(dword_850C2E8 + 4));
              sub_80A4124(&dword_850C2F4, 25, *dword_850C2E8, v104, v105);
              break;
            case 70:
              sub_80A4042(&v103, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 37, dword_850C2F4, v103);
              break;
            case 71:
              sub_80A4042(&v102, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 38, dword_850C2F4, v102);
              break;
            case 72:
              sub_80A4042(&v101, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v100, 61);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v100, v101);
              break;
            case 73:
              sub_80A4042(&v99, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v98, 62);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v98, v99);
              break;
            case 74:
              sub_80A4042(&v97, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v96, 63);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v96, v97);
              break;
            case 75:
              sub_80A4042(&v95, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v94, 70);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v94, v95);
              break;
            case 76:
              sub_80A4042(&v93, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v92, 71);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v92, v93);
              break;
            case 77:
              sub_80A4042(&v91, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v90, 72);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v90, v91);
              break;
            case 78:
              sub_80A4042(&v89, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v88, 73);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v88, v89);
              break;
            case 79:
              sub_80A4042(&v87, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v86, 74);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v86, v87);
              break;
            case 80:
              sub_80A4042(&v85, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v84, 75);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v84, v85);
              break;
            case 81:
              sub_80A4042(&v83, *(dword_850C2E8 - 8 + 4));
              sub_80A4030(&v82, 76);
              sub_80A41AA(&dword_850C2F4, 39, dword_850C2F4, *dword_850C2E8, v82, v83);
              break;
            case 82:
              sub_80A4042(&v81, *(dword_850C2E8 - 24 + 4));
              sub_80A4042(&v80, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 54, dword_850C2F4, *(dword_850C2E8 - 8), v80, v81);
              break;
            case 83:
              sub_80A4042(&v79, *(dword_850C2E8 - 24 + 4));
              sub_80A4042(&v78, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 55, dword_850C2F4, *(dword_850C2E8 - 8), v78, v79);
              break;
            case 84:
              sub_80A4042(&v77, *(dword_850C2E8 - 24 + 4));
              sub_80A4042(&v76, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 56, dword_850C2F4, *(dword_850C2E8 - 8), v76, v77);
              break;
            case 85:
              sub_80A4042(&v75, *(dword_850C2E8 - 8 + 4));
              sub_80A4042(&v74, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 57, dword_850C2F4, *(dword_850C2E8 - 8), v74, v75);
              break;
            case 86:
              sub_80A4042(&v73, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 61, v73);
              break;
            case 87:
              sub_80A4042(&v72, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 62, v72);
              break;
            case 88:
              sub_80A4042(&v71, *(dword_850C2E8 - 24 + 4));
              sub_80A4042(&v70, *(dword_850C2E8 - 8 + 4));
              sub_80A41AA(&dword_850C2F4, 35, *(dword_850C2E8 - 32), *(dword_850C2E8 - 8), v70, v71);
              break;
            case 92:
              sub_80A4042(&v69, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 40, *(dword_850C2E8 - 8), v69);
              break;
            case 93:
              sub_80A4042(&v68, *(dword_850C2E8 - 16 + 4));
              sub_80A4124(&dword_850C2F4, 32, *(dword_850C2E8 - 16), *dword_850C2E8, v68);
              break;
            case 94:
              sub_80A4042(&v67, *(dword_850C2E8 - 32 + 4));
              sub_80A41AA(&dword_850C2F4, 33, *(dword_850C2E8 - 32), *(dword_850C2E8 - 16), *dword_850C2E8, v67);
              break;
            case 95:
              sub_80A4042(&v66, dword_850C2F8);
              sub_80A4042(&v65, *(dword_850C2E8 - 16 + 4));
              sub_80A41AA(&dword_850C2F4, 34, *(dword_850C2E8 - 16), *dword_850C2E8, v65, v66);
              break;
            case 96:
              sub_80A4042(&v64, dword_850C2F8);
              sub_80A4042(&v63, *(dword_850C2E8 - 32 + 4));
              sub_80A42A0(
                &dword_850C2F4,
                36,
                *(dword_850C2E8 - 40),
                *(dword_850C2E8 - 32),
                *(dword_850C2E8 - 16),
                *dword_850C2E8,
                v63,
                v64);
              break;
            case 97:
              sub_80A4042(&v62, *(dword_850C2E8 - 16 + 4));
              sub_80A4124(&dword_850C2F4, 58, *(dword_850C2E8 - 16), *dword_850C2E8, v62);
              break;
            case 98:
              sub_80A4042(&v61, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 41, *(dword_850C2E8 - 8), v61);
              break;
            case 100:
              sub_80A4042(&v60, dword_850C2F8);
              sub_80A40B2(&dword_850C2F4, 59, *(dword_850C2E8 - 8), v60);
              break;
            case 101:
              sub_80A4042(&v59, dword_850C2F8);
              sub_80A407E(&dword_850C2F4, 60, v59);
              break;
            case 103:
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, *dword_850C2E8);
              break;
            case 104:
              sub_80A4054(&v58, 0);
              sub_80A4306(&dword_850C2F4, v58);
              break;
            case 105:
              sub_80A4042(&v56, *(dword_850C2E8 + 4));
              sub_80A40F0(&v57, *dword_850C2E8, v56);
              sub_80A435C(&dword_850C2F4, v57, dword_850C2F4);
              break;
            case 106:
              sub_80A4054(&v55, 0);
              sub_80A4042(&v53, dword_850C2F8);
              sub_80A40F0(&v54, dword_850C2F4, v53);
              sub_80A435C(&dword_850C2F4, v54, v55);
              break;
            case 108:
              sub_80A4042(&v51, *(dword_850C2E8 + 4));
              sub_80A40F0(&v52, *dword_850C2E8, v51);
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, v52);
              break;
            case 109:
              sub_80A4042(&v49, dword_850C2F8);
              sub_80A40F0(&v50, dword_850C2F4, v49);
              sub_80A4054(&v47, 0);
              sub_80A4306(&v48, v47);
              sub_80A43A2(&dword_850C2F4, v48, v50);
              break;
            case 110:
              sub_80A4054(&v46, 0);
              sub_80A4306(&dword_850C2F4, v46);
              break;
            case 111:
              sub_80A4042(&v44, *(dword_850C2E8 + 4));
              sub_80A40F0(&v45, *dword_850C2E8, v44);
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, v45);
              break;
            case 112:
              sub_80A4042(&v42, dword_850C2F8);
              sub_80A40F0(&v43, dword_850C2F4, v42);
              sub_80A4054(&v40, 0);
              sub_80A4306(&v41, v40);
              sub_80A43A2(&dword_850C2F4, v41, v43);
              break;
            case 113:
              sub_80A4042(&v38, *(dword_850C2E8 + 4));
              sub_80A40F0(&v39, *dword_850C2E8, v38);
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, v39);
              break;
            case 114:
              sub_80A4042(&v36, dword_850C2F8);
              sub_80A40F0(&v37, dword_850C2F4, v36);
              sub_80A4054(&v34, 0);
              sub_80A4306(&v35, v34);
              sub_80A43A2(&dword_850C2F4, v35, v37);
              break;
            case 115:
              sub_80A4042(&v32, *(dword_850C2E8 + 4));
              sub_80A40F0(&v33, *dword_850C2E8, v32);
              sub_80A435C(&dword_850C2F4, v33, dword_850C2F4);
              break;
            case 116:
              sub_80A4054(&v31, 0);
              sub_80A4042(&v29, dword_850C2F8);
              sub_80A40F0(&v30, dword_850C2F4, v29);
              sub_80A435C(&dword_850C2F4, v30, v31);
              break;
            case 117:
              sub_80A4042(&v28, dword_850C2F8);
              sub_80A41AA(&dword_850C2F4, 66, dword_850C2F4, *(dword_850C2E8 - 32), *(dword_850C2E8 - 8), v28);
              break;
            case 118:
              sub_80A4042(&v27, *(dword_850C2E8 - 56 + 4));
              sub_80A41AA(&dword_850C2F4, 67, *(dword_850C2E8 - 56), *(dword_850C2E8 - 40), *(dword_850C2E8 - 16), v27);
              break;
            case 119:
              sub_80A4042(&v26, *(dword_850C2E8 - 16 + 4));
              sub_80A40B2(&dword_850C2F4, 68, *(dword_850C2E8 - 16), v26);
              break;
            case 120:
              sub_80A4042(&v24, *(dword_850C2E8 + 4));
              sub_80A40F0(&v25, *dword_850C2E8, v24);
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, v25);
              break;
            case 121:
              sub_80A4054(&v23, 0);
              sub_80A4306(&dword_850C2F4, v23);
              break;
            case 123:
              sub_80A43A2(&dword_850C2F4, dword_850C2F4, *(dword_850C2E8 - 8));
              break;
            case 124:
              sub_80A4054(&v22, 0);
              sub_80A4306(&dword_850C2F4, v22);
              break;
            default:
              break;
          }
          dword_850C2EC -= 2 * v19;
          v13 = *dword_850C2EC;
          dword_850C2E8 -= 8 * v19;
          v20 = word_80F5260[v14];
          if ( v13 || word_80F5260[v14] )
          {
            if ( word_80F5AA0[v20]
              && (v18 = v13 + word_80F5AA0[v20], v18 >= 0)
              && v18 <= 1521
              && word_80F66E0[v18] == v13 )
            {
              v12 = word_80F5AE0[v18];
            }
            else
            {
              v12 = word_80F5660[v20];
            }
            if ( dword_850C2EC >= &unk_850C6E6 )
              goto LABEL_163;
            dword_850C2EC += 2;
            *dword_850C2EC = v12;
            dword_850C2E8 += 8;
            v9 = dword_850C2E8;
            v10 = dword_850C2F8;
            *dword_850C2E8 = dword_850C2F4;
            *(v9 + 4) = v10;
          }
          else
          {
            v12 = 1;
            dword_850C2EC += 2;
            *dword_850C2EC = 1;
            dword_850C2E8 += 8;
            v7 = dword_850C2E8;
            v8 = dword_850C2F8;
            *dword_850C2E8 = dword_850C2F4;
            *(v7 + 4) = v8;
            if ( dword_850D6A0 < 0 )
            {
              dword_850D6A0 = sub_80B0A24();
              if ( dword_850D6A0 < 0 )
                dword_850D6A0 = 0;
            }
            if ( !dword_850D6A0 )
              return 0;
          }
        }
        if ( dword_850D6A0 < 0 )
        {
          dword_850D6A0 = sub_80B0A24();
          if ( dword_850D6A0 < 0 )
            dword_850D6A0 = 0;
        }
        if ( !word_80F56A0[v12] )
          break;
        v15 = dword_850D6A0 + word_80F56A0[v12];
        if ( v15 < 0 || v15 > 1521 || word_80F66E0[v15] != dword_850D6A0 )
          break;
        if ( dword_850C2EC >= &unk_850C6E6 )
          goto LABEL_163;
        dword_850C2EC += 2;
        v12 = word_80F5AE0[v15];
        *dword_850C2EC = v12;
        dword_850C2E8 += 8;
        v0 = dword_850C2E8;
        v1 = dword_850C6F0;
        *dword_850C2E8 = dword_850C6EC;
        *(v0 + 4) = v1;
        dword_850D6A0 = -1;
        if ( dword_850C2E0 > 0 )
          --dword_850C2E0;
      }
      if ( word_80F58A0[v12] )
      {
        v16 = dword_850D6A0 + word_80F58A0[v12];
        if ( v16 >= 0 && v16 <= 1521 && word_80F66E0[v16] == dword_850D6A0 )
        {
          v14 = word_80F5AE0[v16];
          goto LABEL_32;
        }
      }
      if ( !dword_850C2E0 )
      {
        sub_80B2800();
        ++dword_850C2F0;
      }
      if ( dword_850C2E0 <= 2 )
        break;
      if ( !dword_850D6A0 )
        return 1;
      dword_850D6A0 = -1;
    }
    dword_850C2E0 = 3;
    while ( 1 )
    {
      if ( word_80F56A0[*dword_850C2EC] )
      {
        v17 = word_80F56A0[*dword_850C2EC] + 256;
        if ( v17 >= 0 && v17 <= 1521 && word_80F66E0[v17] == 256 )
          break;
      }
      if ( dword_850C2EC <= word_850C300 )
        return 1;
      dword_850C2EC -= 2;
      dword_850C2E8 -= 8;
    }
    if ( dword_850C2EC >= &unk_850C6E6 )
      break;
    dword_850C2EC += 2;
    v12 = word_80F5AE0[v17];
    *dword_850C2EC = v12;
    dword_850C2E8 += 8;
    v2 = dword_850C2E8;
    v3 = dword_850C6F0;
    *dword_850C2E8 = dword_850C6EC;
    *(v2 + 4) = v3;
  }
LABEL_163:
  sub_80B2800();
  return 1;
}
// 80F5260: using guessed type __int16 word_80F5260[];
// 80F5460: using guessed type __int16 word_80F5460[];
// 80F58A0: using guessed type __int16 word_80F58A0[];
// 80F66E0: using guessed type __int16 word_80F66E0[];
// 829FA0C: using guessed type int dword_829FA0C;
// 8433F80: using guessed type int dword_8433F80;
// 850C2E0: using guessed type int dword_850C2E0;
// 850C2E8: using guessed type int dword_850C2E8;
// 850C2EC: using guessed type int dword_850C2EC;
// 850C2F0: using guessed type int dword_850C2F0;
// 850C2F4: using guessed type int dword_850C2F4;
// 850C2F8: using guessed type int dword_850C2F8;
// 850C6EC: using guessed type int dword_850C6EC;
// 850C6F0: using guessed type int dword_850C6F0;
// 850D6A0: using guessed type int dword_850D6A0;

//----- (080B5AB0) --------------------------------------------------------
int __cdecl sub_80B5AB0(_DWORD *a1, _DWORD *a2)
{
  int v2; // et0
  int v3; // et0
  int v4; // et0
  int v5; // et0
  int v6; // et0
  int v7; // et0
  int v8; // et0
  int v9; // et0
  int v10; // et0
  int v11; // et0
  int v12; // et0
  int v13; // et0
  int v14; // et0
  int v15; // et0
  int v16; // et0
  int v17; // et0
  int v18; // et0
  int v19; // et0
  int v20; // et0
  int v21; // et0
  int v22; // et0
  int v23; // et0
  int v24; // et0
  int v25; // et0
  int v26; // et0
  int v27; // et0
  int v28; // et0
  int v29; // et0
  int v30; // et0
  int v31; // et0
  int v32; // et0
  int v33; // et0
  int v34; // et0
  int v35; // et0
  int v36; // et0
  int v37; // et0
  int v38; // et0
  int v39; // et0
  int v40; // et0
  int v41; // et0
  int v42; // et0
  int v43; // et0
  int v44; // et0
  int v45; // et0
  int v46; // et0
  int v47; // et0
  int v48; // et0
  int v49; // et0
  int result; // eax
  int v51; // [esp+0h] [ebp-10h]
  int v52; // [esp+0h] [ebp-10h]
  int v53; // [esp+0h] [ebp-10h]
  int v54; // [esp+0h] [ebp-10h]
  int v55; // [esp+0h] [ebp-10h]
  int v56; // [esp+0h] [ebp-10h]
  int v57; // [esp+0h] [ebp-10h]
  int v58; // [esp+0h] [ebp-10h]
  int v59; // [esp+0h] [ebp-10h]
  int v60; // [esp+0h] [ebp-10h]
  int v61; // [esp+0h] [ebp-10h]
  int v62; // [esp+0h] [ebp-10h]
  int v63; // [esp+0h] [ebp-10h]
  int v64; // [esp+0h] [ebp-10h]
  int v65; // [esp+0h] [ebp-10h]
  int v66; // [esp+0h] [ebp-10h]
  int v67; // [esp+0h] [ebp-10h]
  int v68; // [esp+4h] [ebp-Ch]
  int v69; // [esp+4h] [ebp-Ch]
  int v70; // [esp+4h] [ebp-Ch]
  int v71; // [esp+4h] [ebp-Ch]
  int v72; // [esp+4h] [ebp-Ch]
  int v73; // [esp+4h] [ebp-Ch]
  int v74; // [esp+4h] [ebp-Ch]
  int v75; // [esp+4h] [ebp-Ch]
  int v76; // [esp+4h] [ebp-Ch]
  int v77; // [esp+4h] [ebp-Ch]
  int v78; // [esp+4h] [ebp-Ch]
  int v79; // [esp+4h] [ebp-Ch]
  int v80; // [esp+4h] [ebp-Ch]
  int v81; // [esp+4h] [ebp-Ch]
  int v82; // [esp+4h] [ebp-Ch]
  int v83; // [esp+4h] [ebp-Ch]
  int v84; // [esp+8h] [ebp-8h]
  int v85; // [esp+8h] [ebp-8h]
  int v86; // [esp+8h] [ebp-8h]
  int v87; // [esp+8h] [ebp-8h]
  int v88; // [esp+8h] [ebp-8h]
  int v89; // [esp+8h] [ebp-8h]
  int v90; // [esp+8h] [ebp-8h]
  int v91; // [esp+8h] [ebp-8h]
  int v92; // [esp+8h] [ebp-8h]
  int v93; // [esp+8h] [ebp-8h]
  int v94; // [esp+8h] [ebp-8h]
  int v95; // [esp+8h] [ebp-8h]
  int v96; // [esp+8h] [ebp-8h]
  int v97; // [esp+8h] [ebp-8h]
  int v98; // [esp+8h] [ebp-8h]
  int v99; // [esp+8h] [ebp-8h]
  int v100; // [esp+8h] [ebp-8h]
  int v101; // [esp+Ch] [ebp-4h]
  int v102; // [esp+Ch] [ebp-4h]
  int v103; // [esp+Ch] [ebp-4h]
  int v104; // [esp+Ch] [ebp-4h]
  int v105; // [esp+Ch] [ebp-4h]
  int v106; // [esp+Ch] [ebp-4h]
  int v107; // [esp+Ch] [ebp-4h]
  int v108; // [esp+Ch] [ebp-4h]
  int v109; // [esp+Ch] [ebp-4h]
  int v110; // [esp+Ch] [ebp-4h]
  int v111; // [esp+Ch] [ebp-4h]
  int v112; // [esp+Ch] [ebp-4h]
  int v113; // [esp+Ch] [ebp-4h]
  int v114; // [esp+Ch] [ebp-4h]
  int v115; // [esp+Ch] [ebp-4h]
  int v116; // [esp+Ch] [ebp-4h]

  v84 = a1[1];
  v68 = a1[2];
  v51 = a1[3];
  v101 = v84 + __ROL4__(*a1 + *a2 + (v51 & ~v84 | v68 & v84) - 680876936, 7);
  v52 = v101 + __ROL4__(v51 + a2[1] + (v68 & ~v101 | v84 & v101) - 389564586, 12);
  v69 = v52 + __ROL4__(v68 + a2[2] + (v84 & ~v52 | v101 & v52) + 606105819, 17);
  v85 = v69 + __ROL4__(v84 + a2[3] + (v101 & ~v69 | v52 & v69) - 1044525330, 22);
  v102 = v85 + __ROL4__(v101 + a2[4] + (v52 & ~v85 | v69 & v85) - 176418897, 7);
  v53 = v102 + __ROL4__(v52 + a2[5] + (v69 & ~v102 | v85 & v102) + 1200080426, 12);
  v70 = v53 + __ROL4__(v69 + a2[6] + (v85 & ~v53 | v102 & v53) - 1473231341, 17);
  v86 = v70 + __ROL4__(v85 + a2[7] + (v102 & ~v70 | v53 & v70) - 45705983, 22);
  v103 = v86 + __ROL4__(v102 + a2[8] + (v53 & ~v86 | v70 & v86) + 1770035416, 7);
  v54 = v103 + __ROL4__(v53 + a2[9] + (v70 & ~v103 | v86 & v103) - 1958414417, 12);
  v71 = v54 + __ROL4__(v70 + a2[10] + (v86 & ~v54 | v103 & v54) - 42063, 17);
  v87 = v71 + __ROL4__(v86 + a2[11] + (v103 & ~v71 | v54 & v71) - 1990404162, 22);
  v104 = v87 + __ROL4__(v103 + a2[12] + (v54 & ~v87 | v71 & v87) + 1804603682, 7);
  v55 = v104 + __ROL4__(v54 + a2[13] + (v71 & ~v104 | v87 & v104) - 40341101, 12);
  v72 = v55 + __ROL4__(v71 + a2[14] + (v87 & ~v55 | v104 & v55) - 1502002290, 17);
  v2 = __ROL4__(v87 + a2[15] + (v104 & ~v72 | v55 & v72) + 1236535329, 22);
  v88 = v72 + v2;
  v3 = __ROL4__(v104 + a2[1] + (v72 & ~v55 | v55 & (v72 + v2)) - 165796510, 5);
  v105 = v88 + v3;
  v4 = __ROL4__(v55 + a2[6] + (v88 & ~v72 | v72 & (v88 + v3)) - 1069501632, 9);
  v56 = v105 + v4;
  v5 = __ROL4__(v72 + a2[11] + (v105 & ~v88 | v88 & (v105 + v4)) + 643717713, 14);
  v73 = v56 + v5;
  v6 = __ROL4__(v88 + *a2 + (v56 & ~v105 | v105 & (v56 + v5)) - 373897302, 20);
  v89 = v73 + v6;
  v7 = __ROL4__(v105 + a2[5] + (v73 & ~v56 | v56 & (v73 + v6)) - 701558691, 5);
  v106 = v89 + v7;
  v8 = __ROL4__(v56 + a2[10] + (v89 & ~v73 | v73 & (v89 + v7)) + 38016083, 9);
  v57 = v106 + v8;
  v9 = __ROL4__(v73 + a2[15] + (v106 & ~v89 | v89 & (v106 + v8)) - 660478335, 14);
  v74 = v57 + v9;
  v10 = __ROL4__(v89 + a2[4] + (v57 & ~v106 | v106 & (v57 + v9)) - 405537848, 20);
  v90 = v74 + v10;
  v11 = __ROL4__(v106 + a2[9] + (v74 & ~v57 | v57 & (v74 + v10)) + 568446438, 5);
  v107 = v90 + v11;
  v12 = __ROL4__(v57 + a2[14] + (v90 & ~v74 | v74 & (v90 + v11)) - 1019803690, 9);
  v58 = v107 + v12;
  v13 = __ROL4__(v74 + a2[3] + (v107 & ~v90 | v90 & (v107 + v12)) - 187363961, 14);
  v75 = v58 + v13;
  v14 = __ROL4__(v90 + a2[8] + (v58 & ~v107 | v107 & (v58 + v13)) + 1163531501, 20);
  v91 = v75 + v14;
  v15 = __ROL4__(v107 + a2[13] + (v75 & ~v58 | v58 & (v75 + v14)) - 1444681467, 5);
  v108 = v91 + v15;
  v16 = __ROL4__(v58 + a2[2] + (v91 & ~v75 | v75 & (v91 + v15)) - 51403784, 9);
  v59 = v108 + v16;
  v17 = __ROL4__(v75 + a2[7] + (v108 & ~v91 | v91 & (v108 + v16)) + 1735328473, 14);
  v76 = v59 + v17;
  v18 = __ROL4__(v91 + a2[12] + (v59 & ~v108 | v108 & (v59 + v17)) - 1926607734, 20);
  v92 = v76 + v18;
  v19 = __ROL4__(v108 + a2[5] + (v59 ^ (v76 + v18) ^ v76) - 378558, 4);
  v109 = v92 + v19;
  v20 = __ROL4__(v59 + a2[8] + (v76 ^ (v92 + v19) ^ v92) - 2022574463, 11);
  v60 = v109 + v20;
  v21 = __ROL4__(v76 + a2[11] + (v92 ^ (v109 + v20) ^ v109) + 1839030562, 16);
  v77 = v60 + v21;
  v22 = __ROL4__(v92 + a2[14] + (v109 ^ (v60 + v21) ^ v60) - 35309556, 23);
  v93 = v77 + v22;
  v23 = __ROL4__(v109 + a2[1] + (v60 ^ (v77 + v22) ^ v77) - 1530992060, 4);
  v110 = v93 + v23;
  v24 = __ROL4__(v60 + a2[4] + (v77 ^ (v93 + v23) ^ v93) + 1272893353, 11);
  v61 = v110 + v24;
  v25 = __ROL4__(v77 + a2[7] + (v93 ^ (v110 + v24) ^ v110) - 155497632, 16);
  v78 = v61 + v25;
  v26 = __ROL4__(v93 + a2[10] + (v110 ^ (v61 + v25) ^ v61) - 1094730640, 23);
  v94 = v78 + v26;
  v27 = __ROL4__(v110 + a2[13] + (v61 ^ (v78 + v26) ^ v78) + 681279174, 4);
  v111 = v94 + v27;
  v28 = __ROL4__(v61 + *a2 + (v78 ^ (v94 + v27) ^ v94) - 358537222, 11);
  v62 = v111 + v28;
  v29 = __ROL4__(v78 + a2[3] + (v94 ^ (v111 + v28) ^ v111) - 722521979, 16);
  v79 = v62 + v29;
  v30 = __ROL4__(v94 + a2[6] + (v111 ^ (v62 + v29) ^ v62) + 76029189, 23);
  v95 = v79 + v30;
  v31 = __ROL4__(v111 + a2[9] + (v62 ^ (v79 + v30) ^ v79) - 640364487, 4);
  v112 = v95 + v31;
  v32 = __ROL4__(v62 + a2[12] + (v79 ^ (v95 + v31) ^ v95) - 421815835, 11);
  v63 = v112 + v32;
  v33 = __ROL4__(v79 + a2[15] + (v95 ^ (v112 + v32) ^ v112) + 530742520, 16);
  v80 = v63 + v33;
  v34 = __ROL4__(v95 + a2[2] + (v112 ^ (v63 + v33) ^ v63) - 995338651, 23);
  v96 = v80 + v34;
  v35 = __ROL4__(v112 + *a2 + (v80 ^ ((v80 + v34) | ~v63)) - 198630844, 6);
  v113 = v96 + v35;
  v36 = __ROL4__(v63 + a2[7] + (v96 ^ ((v96 + v35) | ~v80)) + 1126891415, 10);
  v64 = v113 + v36;
  v37 = __ROL4__(v80 + a2[14] + (v113 ^ ((v113 + v36) | ~v96)) - 1416354905, 15);
  v81 = v64 + v37;
  v38 = __ROL4__(v96 + a2[5] + (v64 ^ ((v64 + v37) | ~v113)) - 57434055, 21);
  v97 = v81 + v38;
  v39 = __ROL4__(v113 + a2[12] + (v81 ^ ((v81 + v38) | ~v64)) + 1700485571, 6);
  v114 = v97 + v39;
  v40 = __ROL4__(v64 + a2[3] + (v97 ^ ((v97 + v39) | ~v81)) - 1894986606, 10);
  v65 = v114 + v40;
  v41 = __ROL4__(v81 + a2[10] + (v114 ^ ((v114 + v40) | ~v97)) - 1051523, 15);
  v82 = v65 + v41;
  v42 = __ROL4__(v97 + a2[1] + (v65 ^ ((v65 + v41) | ~v114)) - 2054922799, 21);
  v98 = v82 + v42;
  v43 = __ROL4__(v114 + a2[8] + (v82 ^ ((v82 + v42) | ~v65)) + 1873313359, 6);
  v115 = v98 + v43;
  v44 = __ROL4__(v65 + a2[15] + (v98 ^ ((v98 + v43) | ~v82)) - 30611744, 10);
  v66 = v115 + v44;
  v45 = __ROL4__(v82 + a2[6] + (v115 ^ ((v115 + v44) | ~v98)) - 1560198380, 15);
  v83 = v66 + v45;
  v46 = __ROL4__(v98 + a2[13] + (v66 ^ ((v66 + v45) | ~v115)) + 1309151649, 21);
  v99 = v83 + v46;
  v47 = __ROL4__(v115 + a2[4] + (v83 ^ ((v83 + v46) | ~v66)) - 145523070, 6);
  v116 = v99 + v47;
  v48 = __ROL4__(v66 + a2[11] + (v99 ^ ((v99 + v47) | ~v83)) - 1120210379, 10);
  v67 = v116 + v48;
  v49 = __ROL4__(v83 + a2[2] + (v116 ^ ((v116 + v48) | ~v99)) + 718787259, 15);
  v100 = v67 + v49 + __ROL4__(v99 + a2[9] + (v67 ^ ((v67 + v49) | ~v116)) - 343485551, 21);
  *a1 += v116;
  a1[1] += v100;
  a1[2] += v67 + v49;
  result = a1[3] + v67;
  a1[3] = result;
  return result;
}

//----- (080B685A) --------------------------------------------------------
unsigned int *__cdecl sub_80B685A(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int *result; // eax
  int v4; // [esp+14h] [ebp-54h]
  unsigned int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7[18]; // [esp+20h] [ebp-48h] BYREF

  v6 = (*a1 >> 3) & 0x3F;
  if ( *a1 + 8 * a3 < *a1 )
    ++a1[1];
  *a1 += 8 * a3;
  a1[1] += a3 >> 29;
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    *(a1 + v6 + 24) = *a2++;
    if ( ++v6 == 64 )
    {
      v5 = 0;
      v4 = 0;
      while ( v5 <= 0xF )
      {
        v7[v5++] = (BYTE1(a1[v4 + 6]) << 8) | (BYTE2(a1[v4 + 6]) << 16) | (HIBYTE(a1[v4 + 6]) << 24) | LOBYTE(a1[v4 + 6]);
        ++v4;
      }
      sub_80B5AB0(a1 + 2, v7);
      v6 = 0;
    }
  }
  return result;
}

//----- (080B6AE0) --------------------------------------------------------
int __cdecl sub_80B6AE0(int a1, int a2, int a3, int a4)
{
  return sub_80B7330(&unk_8433FC0, a1, a2, a3, a4, 0);
}

//----- (080B6B18) --------------------------------------------------------
unsigned int __cdecl sub_80B6B18(int a1, char *s, char *src)
{
  size_t v3; // ebx
  unsigned int result; // eax
  int v5; // eax
  char dest[2072]; // [esp+10h] [ebp-818h] BYREF

  v3 = strlen(s);
  result = strlen(src) + v3;
  if ( result <= 0x800 )
  {
    strcpy(dest, s);
    strcat(dest, " ");
    strcat(dest, src);
    v5 = strlen(dest);
    result = sub_80B6AE0(15, a1, v5, dest);
  }
  return result;
}

//----- (080B6BC0) --------------------------------------------------------
int sub_80B6BC0()
{
  int result; // eax

  sub_80B72DC(dword_8433FC0);
  result = sub_80B6AE0(16, -1, 0, &unk_80E9FA2);
  if ( !dword_843410C )
    result = sub_80921F6("0");
  return result;
}
// 843410C: using guessed type int dword_843410C;

//----- (080B6C0E) --------------------------------------------------------
int sub_80B6C0E()
{
  return sub_80B73F0(dword_8433FC0, 0);
}

//----- (080B6C2A) --------------------------------------------------------
int sub_80B6C2A()
{
  return sub_80B73F0(&unk_8433FC0, -1);
}

//----- (080B6C46) --------------------------------------------------------
int __cdecl sub_80B6C46(int a1, int a2)
{
  return sub_80B7330(dword_8433FC0, 51, -1, a2, a1, 0);
}

//----- (080B6C80) --------------------------------------------------------
int __cdecl sub_80B6C80(int a1, int a2)
{
  int result; // eax

  if ( dword_8434118 )
    result = dword_8434118(&unk_8433FC0, a1, a2);
  return result;
}
// 8434118: using guessed type int (__cdecl *dword_8434118)(_DWORD, _DWORD, _DWORD);

//----- (080B6CB0) --------------------------------------------------------
int __cdecl sub_80B6CB0(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( dword_843411C )
    v4 = dword_843411C(&unk_8433FC0, a1, a2, a3);
  else
    v4 = 0;
  return v4;
}
// 843411C: using guessed type int (__cdecl *dword_843411C)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080B6CF4) --------------------------------------------------------
int sub_80B6CF4()
{
  return sub_80B7330(dword_8433FC0, 113, -1, 0, 0, 0);
}

//----- (080B6D30) --------------------------------------------------------
int sub_80B6D30()
{
  return sub_80B7330(&unk_8433FC0, 117, -1, 0, 0, 0);
}

//----- (080B6D6C) --------------------------------------------------------
int sub_80B6D6C()
{
  return sub_80B7330(&unk_8433FC0, 118, -1, 0, 0, 0);
}

//----- (080B6DA8) --------------------------------------------------------
void __cdecl sub_80B6DA8(char *s, int a2)
{
  size_t v2; // [esp+14h] [ebp-4h]

  if ( dword_8434120 )
    dword_8434120(&unk_8433FC0, s, a2);
  if ( dword_80F7320 )
  {
    v2 = strlen(dword_80F7320);
    if ( (v2 + strlen(s)) < dword_80F7324 )
      strcpy(&dword_80F7320[v2], s);
  }
}
// 80F7324: using guessed type int dword_80F7324;
// 8434120: using guessed type int (__cdecl *dword_8434120)(_DWORD, _DWORD, _DWORD);

//----- (080B6E20) --------------------------------------------------------
int __cdecl sub_80B6E20(char *s1, char *nptr)
{
  int v2; // eax
  char v4; // [esp+Fh] [ebp-9h]
  char *v5; // [esp+10h] [ebp-8h]
  _BOOL4 v6; // [esp+14h] [ebp-4h]
  char *i; // [esp+14h] [ebp-4h]

  if ( !strcasecmp(s1, "set_sv_punkbuster") )
  {
    sub_80921F6(nptr);
  }
  else if ( !strcasecmp(s1, "ConCapBufLen") )
  {
    dword_80F7324 = nptr;
  }
  else if ( !strcasecmp(s1, "ConCapBuf") )
  {
    dword_80F7320 = nptr;
  }
  else if ( !strcasecmp(s1, "Cmd_Exec") )
  {
    v6 = strncasecmp(nptr, "pb_", 3u) == 0;
    sub_80603E9(nptr);
    if ( v6 )
      sub_80B6C2A();
  }
  else
  {
    for ( i = nptr; *i == 32; ++i )
      ;
    while ( *i && *i != 32 )
      ++i;
    v5 = i;
    while ( *i == 32 )
      ++i;
    if ( !strcasecmp(s1, "DropClient") )
    {
      v2 = atoi(nptr);
      sub_808BC22(v2, i);
    }
    else if ( !strcasecmp(s1, "Cvar_Set") )
    {
      v4 = *v5;
      *v5 = 0;
      sub_80745C5(nptr, i);
      *v5 = v4;
    }
  }
  return 0;
}
// 80F7324: using guessed type int dword_80F7324;

//----- (080B6FB6) --------------------------------------------------------
const char *__cdecl sub_80B6FB6(int a1, char *nptr)
{
  int v2; // eax
  const char *v3; // eax
  int v6; // [esp+14h] [ebp-4h]
  int v7; // [esp+14h] [ebp-4h]

  nptr[255] = 0;
  if ( a1 != 102 )
  {
    if ( a1 <= 102 )
    {
      if ( a1 == 101 )
      {
        v2 = sub_809475B();
        sub_80B71D0(v2, nptr, 10);
      }
      return 0;
    }
    if ( a1 == 103 )
    {
      v3 = sub_8073B14(nptr);
      strncpy(nptr, v3, 0xFFu);
    }
    else if ( a1 == 114 )
    {
      v7 = atoi(nptr);
      if ( !sub_8094895(v7, nptr) )
        return "PB Error: Query Failed";
    }
    return 0;
  }
  v6 = atoi(nptr);
  if ( sub_8094768(v6, nptr) )
    return 0;
  return "PB Error: Query Failed";
}

//----- (080B70A0) --------------------------------------------------------
int __cdecl sub_80B70A0(const char *a1)
{
  if ( !strncasecmp(byte_8433FD4, "[skipnotify]", 0xCu) )
    Com_Printf("%s: %s\n", byte_8433FE0, a1);
  else
    sub_80956DE(byte_8433FD4, a1);
  return 0;
}

//----- (080B70FE) --------------------------------------------------------
int __cdecl sub_80B70FE(size_t n, void *src, int a3)
{
  sub_8094930(n, src, a3);
  return 0;
}

//----- (080B7124) --------------------------------------------------------
int __cdecl sub_80B7124(char *cp, unsigned __int16 a2, size_t n, void *buf)
{
  sub_80CA149(cp, a2, n, buf);
  return 0;
}

//----- (080B715A) --------------------------------------------------------
int __cdecl sub_80B715A(int a1, int a2)
{
  int result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_80B74A0(&unk_8433FC0);
  if ( a2 == 0xFFFF && !a1 )
    result = sub_80B7542(&unk_8433FC0);
  return result;
}

//----- (080B7198) --------------------------------------------------------
int ctor_001()
{
  return sub_80B715A(1, 0xFFFF);
}

//----- (080B71B4) --------------------------------------------------------
int dtor_001()
{
  return sub_80B715A(0, 0xFFFF);
}

//----- (080B71D0) --------------------------------------------------------
char *__cdecl sub_80B71D0(int a1, char *dest, int a3)
{
  char v4; // [esp+2Bh] [ebp-4Dh]
  unsigned int v6; // [esp+34h] [ebp-44h]
  int v7; // [esp+38h] [ebp-40h]
  unsigned int v8; // [esp+3Ch] [ebp-3Ch]
  char v9[56]; // [esp+40h] [ebp-38h] BYREF

  if ( !dest )
    return 0;
  strcpy(dest, "0");
  if ( a1 && a3 > 1 && a3 <= 36 )
  {
    v8 = a1;
    v7 = 34;
    v9[34] = 0;
    if ( a1 < 0 && a3 == 10 )
      v8 = -a1;
    while ( v8 )
    {
      v6 = v8 % a3;
      --v7;
      if ( v8 % a3 > 9 )
        v4 = v6 + 87;
      else
        v4 = v6 + 48;
      v9[v7] = v4;
      v8 /= a3;
    }
    if ( a1 < 0 && a3 == 10 )
      v9[--v7] = 45;
    strcpy(dest, &v9[v7]);
  }
  return dest;
}

//----- (080B72DC) --------------------------------------------------------
_DWORD *__cdecl sub_80B72DC(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_80B75CC(a1);
  a1[79] = sub_80B6E20;
  a1[80] = sub_80B6FB6;
  a1[81] = sub_80B70A0;
  a1[82] = sub_80B70FE;
  result = a1;
  a1[85] = sub_80B7124;
  return result;
}

//----- (080B7330) --------------------------------------------------------
int __cdecl sub_80B7330(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v7; // [esp+20h] [ebp-8h]
  const char *v8; // [esp+24h] [ebp-4h]

  if ( !*(a1 + 316) )
    return 0;
  if ( !*(a1 + 312) && *(a1 + 8) )
    return (*(a1 + 332))(a1, a2, a3, a4, a5, a6);
  if ( *(a1 + 8) )
  {
    sub_80B7606(a1);
    return 0;
  }
  v8 = sub_80B767A(a1);
  if ( !v8 )
    return (*(a1 + 332))(a1, a2, a3, a4, a5, a6);
  if ( a2 == 113 || a2 == 114 )
    v7 = 0;
  else
    v7 = v8;
  return v7;
}

//----- (080B73F0) --------------------------------------------------------
int __cdecl sub_80B73F0(int a1, int a2)
{
  int v3; // [esp+24h] [ebp-4h]

  if ( !*(a1 + 316) )
    return 0;
  if ( *(a1 + 8) )
  {
    if ( *(a1 + 312) )
    {
      sub_80B7606(a1);
      v3 = 0;
    }
    else
    {
      v3 = (*(a1 + 336))(a1, a2);
    }
  }
  else
  {
    if ( *(a1 + 312) )
      sub_80B7330(a1, 16, -1, 0, &unk_80E9FA2, 0);
    v3 = 0;
  }
  return v3;
}

//----- (080B74A0) --------------------------------------------------------
int __cdecl sub_80B74A0(int a1)
{
  int result; // eax

  *a1 = 897252889;
  strcpy((a1 + 20), "PunkBuster Server");
  *(a1 + 8) = 0;
  *(a1 + 312) = 1;
  sub_80B75CC(a1);
  *(a1 + 4) = 0;
  *(a1 + 332) = 0;
  *(a1 + 336) = 0;
  *(a1 + 340) = 0;
  *(a1 + 344) = 0;
  *(a1 + 348) = 0;
  result = a1;
  *(a1 + 352) = 0;
  return result;
}

//----- (080B7542) --------------------------------------------------------
int __cdecl sub_80B7542(int a1)
{
  sub_80B7606(a1);
  sub_80B756C(a1);
  return sub_80B7596(a1);
}

//----- (080B756C) --------------------------------------------------------
int __cdecl sub_80B756C(int a1)
{
  int result; // eax

  if ( *(a1 + 12) )
    dlclose(*(a1 + 12));
  result = a1;
  *(a1 + 12) = 0;
  return result;
}

//----- (080B7596) --------------------------------------------------------
int __cdecl sub_80B7596(int a1)
{
  int result; // eax

  *(a1 + 356) = 0;
  if ( *(a1 + 16) )
    dlclose(*(a1 + 16));
  result = a1;
  *(a1 + 16) = 0;
  return result;
}

//----- (080B75CC) --------------------------------------------------------
_DWORD *__cdecl sub_80B75CC(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[79] = 0;
  a1[80] = 0;
  a1[81] = 0;
  result = a1;
  a1[82] = 0;
  return result;
}

//----- (080B7606) --------------------------------------------------------
int __cdecl sub_80B7606(int a1)
{
  int result; // eax

  *(a1 + 4) = 0;
  *(a1 + 336) = 0;
  *(a1 + 332) = 0;
  *(a1 + 344) = 0;
  *(a1 + 348) = 0;
  *(a1 + 352) = 0;
  if ( *(a1 + 8) )
    dlclose(*(a1 + 8));
  result = a1;
  *(a1 + 8) = 0;
  return result;
}

//----- (080B767A) --------------------------------------------------------
const char *__cdecl sub_80B767A(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // eax
  const char *v12; // [esp+18h] [ebp-410h]
  FILE *stream; // [esp+1Ch] [ebp-40Ch]
  char v14[512]; // [esp+20h] [ebp-408h] BYREF
  char dest[520]; // [esp+220h] [ebp-208h] BYREF

  if ( *(a1 + 8) )
    return 0;
  sub_80B7606(a1);
  v1 = sub_80B7914(a1, dest, "pbsvnew.so");
  stream = fopen(v1, "rb");
  if ( stream )
  {
    fclose(stream);
    v2 = sub_80B7914(a1, dest, "pbsvold.so");
    sub_80B78F8(v2);
    v3 = sub_80B7914(a1, dest, "pbsvold.so");
    remove(v3);
    v4 = sub_80B7914(a1, v14, "pbsvold.so");
    v5 = sub_80B7914(a1, dest, "pbsv.so");
    rename(v5, v4);
    v6 = sub_80B7914(a1, dest, "pbsv.so");
    sub_80B78F8(v6);
    v7 = sub_80B7914(a1, dest, "pbsv.so");
    remove(v7);
    v8 = sub_80B7914(a1, v14, "pbsv.so");
    v9 = sub_80B7914(a1, dest, "pbsvnew.so");
    rename(v9, v8);
  }
  v10 = sub_80B7914(a1, dest, "pbsv.so");
  *(a1 + 8) = dlopen(v10, 1);
  if ( !*(a1 + 8) )
    return "PB Error: Server DLL Load Failure";
  *(a1 + 336) = dlsym(*(a1 + 8), "sa");
  *(a1 + 332) = dlsym(*(a1 + 8), "sb");
  if ( *(a1 + 336) && *(a1 + 332) )
  {
    *(a1 + 312) = 0;
    v12 = 0;
  }
  else
  {
    sub_80B7606(a1);
    v12 = "PB Error: Server DLL Get Procedure Failure";
  }
  return v12;
}

//----- (080B78F8) --------------------------------------------------------
int __cdecl sub_80B78F8(char *file)
{
  return chmod(file, 0x1FFu);
}

//----- (080B7914) --------------------------------------------------------
char *__cdecl sub_80B7914(int a1, char *dest, char *src)
{
  char s[280]; // [esp+10h] [ebp-118h] BYREF

  if ( !*(a1 + 52) )
  {
    sub_80B7B5A(a1);
    sub_80B7A62(a1, s);
    if ( s[strlen(s) - 1] != 47 )
      strcat(s, "/");
    strcat(s, "pb/");
    if ( strcasecmp(s, (a1 + 52)) && s[0] && *(a1 + 52) )
    {
      mkdir((a1 + 52), 0x1FFu);
      sub_80B7AA2(a1, "pbsv.so", s);
      sub_80B7AA2(a1, "pbcl.so", s);
      sub_80B7AA2(a1, "pbag.so", s);
    }
  }
  strcpy(dest, (a1 + 52));
  strcat(dest, src);
  return dest;
}

//----- (080B7A62) --------------------------------------------------------
int __cdecl sub_80B7A62(int a1, char *dest)
{
  int result; // eax
  char *v3; // eax

  result = a1;
  if ( *(a1 + 320) )
  {
    v3 = strcpy(dest, "fs_basepath");
    result = (*(a1 + 320))(103, v3);
  }
  return result;
}

//----- (080B7AA2) --------------------------------------------------------
int __cdecl sub_80B7AA2(int a1, char *src, char *a3)
{
  FILE *stream; // [esp+1Ch] [ebp-40Ch]
  char dest[512]; // [esp+20h] [ebp-408h] BYREF
  char filename[520]; // [esp+220h] [ebp-208h] BYREF

  strcpy(dest, (a1 + 52));
  strcat(dest, src);
  stream = fopen(dest, "rb");
  if ( stream )
    return fclose(stream);
  strcpy(filename, a3);
  strcat(filename, src);
  return sub_80B7C18(filename, dest, 0);
}

//----- (080B7B5A) --------------------------------------------------------
char *__cdecl sub_80B7B5A(int a1)
{
  char *result; // eax
  char *v2; // eax

  result = a1;
  if ( *(a1 + 320) )
  {
    v2 = strcpy((a1 + 52), "fs_homepath");
    (*(a1 + 320))(103, v2);
    if ( !*(a1 + 52) )
      getcwd((a1 + 52), 0xFBu);
    if ( *(a1 + 52) )
    {
      if ( *(a1 + strlen((a1 + 52)) + 51) != 47 )
        strcat((a1 + 52), "/");
    }
    result = strcat((a1 + 52), "pb/");
  }
  return result;
}

//----- (080B7C18) --------------------------------------------------------
int __cdecl sub_80B7C18(char *filename, char *a2, int a3)
{
  size_t v4; // [esp+1Ch] [ebp-1Ch]
  size_t v5; // [esp+20h] [ebp-18h]
  void *ptr; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  FILE *s; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]
  FILE *stream; // [esp+34h] [ebp-4h]

  stream = fopen(filename, "rb");
  v9 = 0;
  if ( stream )
  {
    s = fopen(a2, "wb");
    if ( s )
    {
      fseek(stream, 0, 2);
      n = ftell(stream);
      if ( n > 0 && (!a3 || n < a3) )
      {
        ptr = operator new[](n);
        if ( ptr )
        {
          fseek(stream, 0, 0);
          v5 = fread(ptr, 1u, n, stream);
          v4 = fwrite(ptr, 1u, v5, s);
          operator delete(ptr);
          if ( v4 == n )
            v9 = 1;
        }
      }
      fclose(s);
    }
    fclose(stream);
  }
  return v9;
}

//----- (080B7D84) --------------------------------------------------------
int sub_80B7D84()
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    word_8434148[34 * i] = (i + 2047) % 2048;
    word_843414A[34 * i] = (i + 1) % 2048;
  }
  dword_843414C[0] = 0;
  dword_8434150[0] = 0;
  dword_8434168 = 0;
  dword_843416C = 0;
  word_8434154 = 0;
  word_8434156 = 0;
  word_8434170 = 0;
  word_8434172 = 0;
  result = sub_80A4D5C("end", 0);
  word_80F732A = result;
  dword_84567C4 = 1;
  dword_84567C8 = 1;
  return result;
}
// 80F732A: using guessed type __int16 word_80F732A;
// 8434148: using guessed type __int16 word_8434148[];
// 843414A: using guessed type __int16 word_843414A[];
// 843414C: using guessed type int dword_843414C[];
// 8434150: using guessed type int dword_8434150[];
// 8434154: using guessed type __int16 word_8434154;
// 8434156: using guessed type __int16 word_8434156;
// 8434168: using guessed type int dword_8434168;
// 843416C: using guessed type int dword_843416C;
// 8434170: using guessed type __int16 word_8434170;
// 8434172: using guessed type __int16 word_8434172;
// 84567C4: using guessed type int dword_84567C4;
// 84567C8: using guessed type int dword_84567C8;

//----- (080B7EBA) --------------------------------------------------------
int sub_80B7EBA()
{
  int result; // eax

  if ( word_80F732A )
  {
    result = sub_80A509E(word_80F732A);
    word_80F732A = 0;
  }
  return result;
}
// 80F732A: using guessed type __int16 word_80F732A;

//----- (080B7EE4) --------------------------------------------------------
int sub_80B7EE4()
{
  int result; // eax

  result = sub_80A6AAC();
  word_80F7328 = result;
  return result;
}
// 80F7328: using guessed type __int16 word_80F7328;

//----- (080B7EF8) --------------------------------------------------------
int __cdecl sub_80B7EF8(int (__cdecl *a1)(int))
{
  const char *v1; // eax
  int result; // eax
  unsigned __int16 i; // [esp+12h] [ebp-6h]
  unsigned __int16 v4; // [esp+14h] [ebp-4h]

  for ( i = sub_80A7A30(word_80F7328); i; i = sub_80A7A30(i) )
  {
    v4 = sub_80A7AA4(i);
    v1 = sub_80A4458(v4);
    sub_80B816E(v1, a1);
  }
  result = sub_80A6C02(word_80F7328);
  word_80F7328 = 0;
  return result;
}
// 80F7328: using guessed type __int16 word_80F7328;

//----- (080B7F72) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80B7F72(int a1)
{
  unsigned __int16 *result; // eax
  __int16 j; // [esp+1Ah] [ebp-1Eh]
  unsigned __int16 *v3; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v4; // [esp+22h] [ebp-16h]
  int v5; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  __int16 *v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  v8 = *(a1 + 4);
  if ( word_80F7328 )
  {
    v4 = sub_80A4E42(*a1, 0, 7);
    sub_80A71D8(word_80F7328, v4);
    sub_80A509E(v4);
  }
  v7 = *(v8 + 12);
  v5 = *v7;
  for ( i = 0; i < v5; ++i )
    sub_80A509E(v7[i + 1]);
  result = *(v8 + 20);
  v3 = result;
  if ( result )
  {
    for ( j = 0; ; ++j )
    {
      result = v3;
      if ( !*v3 )
        break;
      sub_80A509E(*v3);
      v3 += 4;
    }
  }
  return result;
}
// 80F7328: using guessed type __int16 word_80F7328;

//----- (080B8058) --------------------------------------------------------
char *__cdecl sub_80B8058(int a1, char *s, int a3, int a4)
{
  float v5; // [esp+Ch] [ebp-1Ch]
  float v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  char *sa; // [esp+34h] [ebp+Ch]
  char *sb; // [esp+34h] [ebp+Ch]

  v10 = *s;
  sa = s + 1;
  v7 = (a4)(8 * v10 + 10);
  *(a3 + 20) = v7;
  for ( i = 0; i < v10; ++i )
  {
    *v7 = sub_80A4D5C(sa, 0);
    sb = &sa[strlen(sa) + 1];
    v8 = *sb;
    sa = sb + 2;
    if ( *a3 )
    {
      v5 = v8;
      v6 = v5 / *a3;
    }
    else
    {
      v6 = 0.0;
    }
    *(v7 + 4) = v6;
    v7 += 8;
  }
  *v7 = sub_80A4D5C("end", 0);
  *(v7 + 4) = 1065353216;
  *(v7 + 8) = 0;
  return sa;
}

//----- (080B816E) --------------------------------------------------------
int __cdecl sub_80B816E(const char *a1, int (__cdecl *a2)(int))
{
  int result; // eax
  _DWORD **v3; // ebx
  _DWORD **v4; // ebx
  _DWORD **v5; // ebx
  _DWORD *v6; // ebx
  _DWORD *v7; // ebx
  _DWORD *v8; // ebx
  _DWORD *v9; // ebx
  _DWORD *v10; // ebx
  __int16 v11; // cx
  void *v12; // esp
  void *v13; // esp
  int v14; // ebx
  _DWORD **v15; // ebx
  _DWORD **v16; // ebx
  _DWORD **v17; // ebx
  _DWORD **v18; // ebx
  _DWORD **v19; // ebx
  _DWORD *v20; // ebx
  _DWORD *v21; // ebx
  _DWORD *v22; // ebx
  _DWORD *v23; // ebx
  _DWORD *v24; // ebx
  _DWORD *v25; // ebx
  _DWORD *v26; // ebx
  _BYTE v27[24]; // [esp+14h] [ebp-4B4h] BYREF
  float v28; // [esp+2Ch] [ebp-49Ch]
  int v29; // [esp+30h] [ebp-498h]
  int v30; // [esp+34h] [ebp-494h]
  void *dest; // [esp+38h] [ebp-490h]
  int v32; // [esp+3Ch] [ebp-48Ch]
  __int16 *v33; // [esp+40h] [ebp-488h]
  __int16 *v34; // [esp+44h] [ebp-484h]
  int i; // [esp+48h] [ebp-480h]
  size_t n; // [esp+4Ch] [ebp-47Ch]
  int v37; // [esp+50h] [ebp-478h]
  int v38; // [esp+54h] [ebp-474h]
  int v39; // [esp+58h] [ebp-470h]
  int v40; // [esp+60h] [ebp-468h] BYREF
  int v41; // [esp+64h] [ebp-464h]
  bool v42; // [esp+6Fh] [ebp-459h]
  int v43; // [esp+70h] [ebp-458h]
  _BYTE *v44; // [esp+74h] [ebp-454h]
  _BYTE *v45; // [esp+78h] [ebp-450h]
  bool v46; // [esp+7Dh] [ebp-44Bh]
  char v47; // [esp+7Eh] [ebp-44Ah]
  char v48; // [esp+7Fh] [ebp-449h]
  int v49; // [esp+80h] [ebp-448h]
  __int16 v50; // [esp+86h] [ebp-442h]
  size_t v51; // [esp+88h] [ebp-440h]
  int v52; // [esp+8Ch] [ebp-43Ch]
  char s[1028]; // [esp+90h] [ebp-438h] BYREF
  int j; // [esp+494h] [ebp-34h]
  char *v55; // [esp+498h] [ebp-30h]
  void *src; // [esp+49Ch] [ebp-2Ch]
  int v57; // [esp+4A0h] [ebp-28h] BYREF
  _DWORD **v58; // [esp+4A4h] [ebp-24h]
  _DWORD **v59; // [esp+4A8h] [ebp-20h]
  unsigned __int16 v60; // [esp+4AEh] [ebp-1Ah]
  int v61; // [esp+4B0h] [ebp-18h]
  int v62; // [esp+4B4h] [ebp-14h]
  _WORD *v63; // [esp+4B8h] [ebp-10h]
  _WORD *v64; // [esp+4BCh] [ebp-Ch]

  v52 = sub_8064FC5("xanim", a1, &unk_80EA104);
  if ( !v52 )
    sub_80704AC(1, &byte_80EA10B, a1);
  result = v52;
  if ( !*(v52 + 4) )
  {
    sprintf(s, "xanim/%s", a1);
    if ( (sub_8062EB0(s, &v57) & 0x80000000) != 0 )
      sub_80704AC(1, &byte_80EA131, a1);
    src = v57;
    v49 = sub_80C182E(*v57);
    src = src + 2;
    if ( v49 != 14 )
    {
      sub_8063207(v57);
      sub_80704AC(1, &byte_80EA160, a1, v49, 14);
    }
    LOWORD(v61) = sub_80C182E(*src);
    src = src + 2;
    HIWORD(v61) = sub_80C182E(*src);
    src = src + 2;
    v64 = a2(2 * SHIWORD(v61) + 2);
    v63 = v64 + 1;
    *v64 = HIWORD(v61);
    v48 = *src;
    src = src + 1;
    v47 = v48 & 1;
    v46 = (v48 & 2) != 0;
    v50 = *src;
    src = src + 2;
    v50 = sub_80C182E(v50);
    v62 = a2(32);
    *(v62 + 12) = v64;
    *(v62 + 4) = v50;
    *(v62 + 2) = v47;
    *(v62 + 3) = v46;
    if ( v47 )
      LOWORD(v30) = v61 + 1;
    else
      LOWORD(v30) = v61;
    v60 = v30;
    v42 = v30 <= 0x100u;
    *v62 = v30 - 1;
    v29 = v62;
    if ( *v62 )
      v28 = *(v62 + 4) / *v62;
    else
      v28 = 0.0;
    *(v29 + 8) = v28;
    if ( v46 )
    {
      v58 = a2(8);
      *(v62 + 24) = v58;
      HIWORD(v43) = *src;
      src = src + 2;
      if ( HIWORD(v43) )
      {
        if ( HIWORD(v43) == 1 )
        {
          sub_80C1966(src, &v40);
          src = src + 2;
          v3 = v58;
          v3[1] = a2(8);
          *v58[1] = v40;
          *(v58[1] + 2) = 0;
        }
        else
        {
          if ( HIWORD(v43) >= v60 )
          {
            v5 = v58;
            v5[1] = a2(8);
          }
          else
          {
            v4 = v58;
            if ( v42 )
            {
              v4[1] = a2(HIWORD(v43) + 7);
              n = HIWORD(v43);
              memcpy(v58[1] + 6, src, HIWORD(v43));
              src = src + HIWORD(v43);
            }
            else
            {
              v4[1] = a2(2 * HIWORD(v43) + 6);
              n = 2 * HIWORD(v43);
              memcpy(v58[1] + 6, src, n);
              src = src + n;
            }
          }
          n = 4 * HIWORD(v43);
          v6 = v58[1];
          *v6 = a2(n);
          sub_80C1966(src, &v40);
          src = src + 2;
          **v58[1] = v40;
          for ( i = 1; i < HIWORD(v43); ++i )
          {
            sub_80C1966(src, &v40);
            src = src + 2;
            *(*v58[1] + 4 * i) = v40;
          }
          for ( i = 1; i < HIWORD(v43); ++i )
          {
            v34 = (*v58[1] + 4 * i);
            v33 = (*v58[1] + 4 * i - 4);
            v32 = v34[1] * v33[1] + *v33 * *v34;
            if ( v32 < 0 )
            {
              *v34 = -*v34;
              v34[1] = -v34[1];
            }
          }
          *(v58[1] + 2) = HIWORD(v43) - 1;
        }
      }
      else
      {
        v58[1] = 0;
      }
      LOWORD(v43) = *src;
      src = src + 2;
      if ( v43 )
      {
        if ( v43 == 1 )
        {
          v37 = *src;
          v38 = *(src + 1);
          v39 = *(src + 2);
          src = src + 12;
          v7 = v58;
          *v7 = a2(16);
          **v58 = v37;
          (*v58)[2] = v38;
          (*v58)[3] = v39;
          *(*v58 + 2) = 0;
        }
        else
        {
          if ( v43 >= v60 )
          {
            v9 = v58;
            *v9 = a2(8);
          }
          else
          {
            v8 = v58;
            if ( v42 )
            {
              *v8 = a2(v43 + 7);
              n = v43;
              memcpy(*v58 + 6, src, v43);
            }
            else
            {
              *v8 = a2(2 * v43 + 6);
              n = 2 * v43;
              memcpy(*v58 + 6, src, n);
            }
            src = src + n;
          }
          n = 12 * v43;
          v10 = *v58;
          *v10 = a2(n);
          for ( i = 0; i < v43; ++i )
          {
            *(**v58 + 12 * i) = *src;
            *(**v58 + 12 * i + 4) = *(src + 1);
            *(**v58 + 12 * i + 8) = *(src + 2);
            src = src + 12;
          }
          *(*v58 + 2) = v43 - 1;
        }
      }
      else
      {
        *v58 = 0;
      }
    }
    v51 = ((SHIWORD(v61) - 1) >> 3) + 1;
    v55 = src;
    src = src + v51;
    dest = a2(v51);
    memcpy(dest, src, v51);
    src = src + v51;
    *(v62 + 28) = dest;
    for ( j = 0; j < SHIWORD(v61); ++j )
    {
      v51 = strlen(src) + 1;
      v11 = sub_80A4884(src, 0, v51);
      v63[j] = v11;
      src = src + v51;
    }
    v12 = alloca(16 * ((8 * SHIWORD(v61) + 15) >> 4));
    v45 = v27;
    v13 = alloca(16 * ((12 * SHIWORD(v61) + 15) >> 4));
    v44 = v27;
    v14 = v62;
    *(v14 + 16) = a2(8 * SHIWORD(v61));
    for ( j = 0; j < SHIWORD(v61); ++j )
    {
      HIBYTE(v30) = (v55[j >> 3] >> (j & 7)) & 1;
      BYTE2(v30) = (*(dest + (j >> 3)) >> (j & 7)) & 1;
      v59 = (*(v62 + 16) + 8 * j);
      HIWORD(v43) = *src;
      src = src + 2;
      if ( HIWORD(v43) )
      {
        if ( HIWORD(v43) == 1 )
        {
          if ( BYTE2(v30) )
          {
            sub_80C1966(src, &v40);
            src = src + 2;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -v40;
              HIWORD(v40) = -HIWORD(v40);
            }
            v15 = v59;
            v15[1] = a2(8);
            *v59[1] = v40;
          }
          else
          {
            sub_80C1876(src, &v40);
            src = src + 6;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -v40;
              HIWORD(v40) = -HIWORD(v40);
              LOWORD(v41) = -v41;
              HIWORD(v41) = -HIWORD(v41);
            }
            v16 = v59;
            v16[1] = a2(10);
            *v59[1] = v40;
            *(v59[1] + 6) = v41;
          }
          *(v59[1] + 2) = 0;
        }
        else
        {
          if ( HIWORD(v43) >= v60 )
          {
            v19 = v59;
            v19[1] = a2(8);
          }
          else
          {
            if ( v42 )
            {
              n = HIWORD(v43) + 7;
              v17 = v59;
              v17[1] = a2(n);
              n = HIWORD(v43);
              memcpy(v59[1] + 6, src, HIWORD(v43));
            }
            else
            {
              n = 2 * HIWORD(v43) + 6;
              v18 = v59;
              v18[1] = a2(n);
              n = 2 * HIWORD(v43);
              memcpy(v59[1] + 6, src, n);
            }
            src = src + n;
          }
          if ( BYTE2(v30) )
          {
            n = 4 * HIWORD(v43);
            v20 = v59[1];
            *v20 = a2(n);
            sub_80C1966(src, &v40);
            src = src + 2;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -v40;
              HIWORD(v40) = -HIWORD(v40);
            }
            **v59[1] = v40;
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              sub_80C1966(src, &v40);
              src = src + 2;
              *(*v59[1] + 4 * i) = v40;
            }
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              v34 = (*v59[1] + 4 * i);
              v33 = (*v59[1] + 4 * i - 4);
              v32 = v34[1] * v33[1] + *v33 * *v34;
              if ( v32 < 0 )
              {
                *v34 = -*v34;
                v34[1] = -v34[1];
              }
            }
          }
          else
          {
            n = 8 * HIWORD(v43);
            v21 = v59[1];
            *v21 = a2(n);
            sub_80C1876(src, &v40);
            src = src + 6;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -v40;
              HIWORD(v40) = -HIWORD(v40);
              LOWORD(v41) = -v41;
              HIWORD(v41) = -HIWORD(v41);
            }
            **v59[1] = v40;
            *(*v59[1] + 4) = v41;
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              sub_80C1876(src, &v40);
              src = src + 6;
              *(*v59[1] + 8 * i) = v40;
              *(*v59[1] + 8 * i + 4) = v41;
            }
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              v34 = (*v59[1] + 8 * i);
              v33 = (*v59[1] + 8 * i - 8);
              v32 = v34[1] * v33[1] + *v33 * *v34 + v34[3] * v33[3] + v33[2] * v34[2];
              if ( v32 < 0 )
              {
                *v34 = -*v34;
                v34[1] = -v34[1];
                v34[2] = -v34[2];
                v34[3] = -v34[3];
              }
            }
          }
          *(v59[1] + 2) = HIWORD(v43) - 1;
        }
      }
      else
      {
        v59[1] = 0;
      }
      LOWORD(v43) = *src;
      src = src + 2;
      if ( v43 )
      {
        if ( v43 == 1 )
        {
          v37 = *src;
          v38 = *(src + 1);
          v39 = *(src + 2);
          src = src + 12;
          v22 = v59;
          *v22 = a2(16);
          **v59 = v37;
          (*v59)[2] = v38;
          (*v59)[3] = v39;
          *(*v59 + 2) = 0;
        }
        else
        {
          if ( v43 >= v60 )
          {
            v25 = v59;
            *v25 = a2(8);
          }
          else
          {
            if ( v42 )
            {
              n = v43 + 7;
              v23 = v59;
              *v23 = a2(n);
              n = v43;
              memcpy(*v59 + 6, src, v43);
            }
            else
            {
              n = 2 * v43 + 6;
              v24 = v59;
              *v24 = a2(n);
              n = 2 * v43;
              memcpy(*v59 + 6, src, n);
            }
            src = src + n;
          }
          n = 12 * v43;
          v26 = *v59;
          *v26 = a2(n);
          for ( i = 0; i < v43; ++i )
          {
            *(**v59 + 12 * i) = *src;
            *(**v59 + 12 * i + 4) = *(src + 1);
            *(**v59 + 12 * i + 8) = *(src + 2);
            src = src + 12;
          }
          *(*v59 + 2) = v43 - 1;
        }
      }
      else
      {
        *v59 = 0;
      }
    }
    src = sub_80B8058(a1, src, v62, a2);
    sub_8063207(v57);
    *(v52 + 4) = v62;
    result = v52;
    *(v52 + 8) = sub_80B7F72;
  }
  return result;
}

//----- (080B9570) --------------------------------------------------------
int __cdecl sub_80B9570(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  int v6; // [esp+10h] [ebp-8h]

  v6 = sub_8064FC5("xanim", a3, &unk_80EA104);
  if ( !v6 )
    sub_80704AC(1, &byte_80EA193, a3);
  v3 = a1 + 8 * a2;
  *(v3 + 8) = 0;
  v4 = v3 + 8;
  result = v6;
  *(v4 + 4) = v6;
  return result;
}

//----- (080B95E2) --------------------------------------------------------
int __cdecl sub_80B95E2(int a1, unsigned __int16 a2, int a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  _WORD *v6; // eax
  int result; // eax
  _WORD *v8; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]

  v6 = (a1 + 8 * a2);
  v8 = v6 + 4;
  v6[4] = a5;
  v6[6] = a6;
  v6[7] = a4;
  for ( i = 0; ; ++i )
  {
    result = a5;
    if ( i >= a5 )
      break;
    *(a1 + 8 * (i + v8[3]) + 10) = a2;
  }
  return result;
}

//----- (080B966A) --------------------------------------------------------
_DWORD *__cdecl sub_80B966A(int a1, int a2, int (__cdecl *a3)(int))
{
  _DWORD *result; // eax

  result = a3(8 * a2 + 8);
  *result = a1;
  result[1] = a2;
  return result;
}

//----- (080B969A) --------------------------------------------------------
_DWORD *__cdecl sub_80B969A(int a1, int (__cdecl *a2)(int))
{
  int n; // [esp+20h] [ebp-8h]
  _DWORD *s; // [esp+24h] [ebp-4h]

  n = 2 * *(a1 + 4) + 12 + 2 * (3 * *(a1 + 4) + 1);
  s = a2(n);
  sub_80C837D(s, 0, n);
  *s = a1;
  return s;
}

//----- (080B9700) --------------------------------------------------------
int __cdecl sub_80B9700(int a1, int (__cdecl *a2)(int, int))
{
  return a2(a1, 2 * *(*a1 + 4) + 12 + 2 * (3 * *(*a1 + 4) + 1));
}

//----- (080B9748) --------------------------------------------------------
int __cdecl sub_80B9748(int a1)
{
  return *a1;
}

//----- (080B9752) --------------------------------------------------------
int __cdecl sub_80B9752(int a1, int a2, int a3)
{
  void *v3; // esp
  int v5; // [esp+10h] [ebp-48h] BYREF
  int i; // [esp+14h] [ebp-44h]
  size_t n; // [esp+18h] [ebp-40h]
  __int16 v8; // [esp+1Eh] [ebp-3Ah]
  __int16 *v9; // [esp+20h] [ebp-38h]
  __int16 *v10; // [esp+24h] [ebp-34h]
  __int16 *v11; // [esp+28h] [ebp-30h]
  __int16 *v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  void *s2; // [esp+48h] [ebp-10h]

  v15 = *(*(a1 + 4) + 4);
  v12 = *(v15 + 12);
  v14 = *v12;
  v10 = v12 + 1;
  n = v14 + 16;
  v3 = alloca(16 * ((v14 + 31) >> 4));
  s2 = &v5;
  for ( i = 0; i <= 3; ++i )
    *(s2 + i) = 0;
  for ( j = v14 - 1; j >= 0; --j )
    *(s2 + j + 16) = 127;
  v17 = 0;
  for ( i = 0; i < a3; ++i )
  {
    v11 = ***(**(*(a2 + 4 * i) + 4) + 4);
    v9 = v11 + 1;
    v13 = *v11;
    v16 = 0;
    while ( v16 < v13 )
    {
      v8 = v9[v16];
      for ( j = v14 - 1; j >= 0; --j )
      {
        if ( v8 == v10[j] )
        {
          if ( *(s2 + j + 16) == 127 )
          {
            *(s2 + j + 16) = v17;
            *(s2 + (v17 >> 3)) |= 1 << (v17 & 7);
          }
          break;
        }
      }
      ++v16;
      ++v17;
    }
  }
  return sub_80A4884(s2, 0, n);
}

//----- (080B9914) --------------------------------------------------------
int __cdecl sub_80B9914(float a1, int a2, int a3, int a4)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]
  int v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+1Ch] [ebp+10h]

  v6 = 0;
  v5 = (a3 * a1);
  if ( a4 >= *(a2 + v5) )
  {
    if ( a4 >= *(a2 + v5 + 1) )
    {
      v7 = v5 + 1;
      do
      {
        while ( 1 )
        {
          v5 = (a3 + v7) / 2;
          if ( a4 < *(a2 + v5) )
            break;
          if ( a4 < *(a2 + v5 + 1) )
            return v5;
          v7 = v5 + 1;
        }
        a3 = (a3 + v7++) / 2;
      }
      while ( a4 >= *(a2 + v7) );
      v5 = v7 - 1;
    }
  }
  else
  {
    v8 = (a3 * a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = (v8 + v6) / 2;
        if ( a4 >= *(a2 + v5) )
          break;
        v8 = (v8 + v6) / 2;
      }
      if ( a4 < *(a2 + v5 + 1) )
        break;
      v6 = v5 + 1;
      --v8;
      if ( a4 >= *(a2 + v8) )
        return v8;
    }
  }
  return v5;
}

//----- (080B9A32) --------------------------------------------------------
int __cdecl sub_80B9A32(float a1, int a2, int a3, int a4)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]
  int v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+1Ch] [ebp+10h]

  v6 = 0;
  v5 = (a3 * a1);
  if ( a4 >= *(a2 + 2 * v5) )
  {
    if ( a4 >= *(a2 + 2 * v5 + 2) )
    {
      v7 = v5 + 1;
      do
      {
        while ( 1 )
        {
          v5 = (a3 + v7) / 2;
          if ( a4 < *(a2 + 2 * v5) )
            break;
          if ( a4 < *(a2 + 2 * v5 + 2) )
            return v5;
          v7 = v5 + 1;
        }
        a3 = (a3 + v7++) / 2;
      }
      while ( a4 >= *(a2 + 2 * v7) );
      v5 = v7 - 1;
    }
  }
  else
  {
    v8 = (a3 * a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = (v8 + v6) / 2;
        if ( a4 >= *(a2 + 2 * v5) )
          break;
        v8 = (v8 + v6) / 2;
      }
      if ( a4 < *(a2 + 2 * v5 + 2) )
        break;
      v6 = v5 + 1;
      --v8;
      if ( a4 >= *(a2 + 2 * v8) )
        return v8;
    }
  }
  return v5;
}

//----- (080B9B72) --------------------------------------------------------
int __cdecl sub_80B9B72(int a1, int a2, float a3, float a4, int a5)
{
  int result; // eax
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  float v11; // [esp+2Ch] [ebp-4Ch]
  float v12; // [esp+2Ch] [ebp-4Ch]
  float v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+34h] [ebp-44h]
  int v19; // [esp+34h] [ebp-44h]
  float v20; // [esp+38h] [ebp-40h]
  int v21; // [esp+3Ch] [ebp-3Ch]
  int v22; // [esp+40h] [ebp-38h]
  float v23; // [esp+44h] [ebp-34h]
  int *v24; // [esp+48h] [ebp-30h]
  float *v25; // [esp+5Ch] [ebp-1Ch]
  __int16 *v26; // [esp+64h] [ebp-14h]
  __int16 *v27; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  float *v29; // [esp+6Ch] [ebp-Ch]

  v7 = *a1;
  v23 = a4 * 0.000030518509;
  v20 = v7 * a3;
  v21 = v20;
  v6 = *(a1 + 28);
  v8 = **(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v22 = *(a2 + i);
    if ( ((*(&dword_8456170 + (v22 >> 3)) >> (v22 & 7)) & 1) == 0 )
    {
      v29 = (a5 + 32 * v22);
      v24 = (*(a1 + 16) + 8 * i);
      v10 = v24[1];
      if ( ((*((i >> 3) + v6) >> (i & 7)) & 1) != 0 )
      {
        if ( v10 )
        {
          v17 = *(v10 + 4);
          if ( *(v10 + 4) )
          {
            if ( v17 >= v7 )
            {
              v14 = v20;
              v11 = v20 - v21;
            }
            else
            {
              v14 = sub_80B9914(a3, v10 + 6, v17, v21);
              v11 = (v20 - *(v14 + v10 + 6)) / (*(v14 + v10 + 7) - *(v14 + v10 + 6));
            }
            v26 = (*v10 + 4 * v14);
            v29[2] = (*v26 + (v26[2] - *v26) * v11) * v23 + v29[2];
            v29[3] = (v26[1] + (v26[3] - v26[1]) * v11) * v23 + v29[3];
          }
          else
          {
            v29[2] = *v10 * v23 + v29[2];
            v29[3] = *(v10 + 2) * v23 + v29[3];
          }
        }
        else
        {
          v29[3] = v29[3] + a4;
        }
      }
      else
      {
        v18 = *(v10 + 4);
        if ( *(v10 + 4) )
        {
          if ( v18 >= v7 )
          {
            v15 = v20;
            v12 = v20 - v21;
          }
          else
          {
            v15 = sub_80B9914(a3, v10 + 6, v18, v21);
            v12 = (v20 - *(v15 + v10 + 6)) / (*(v15 + v10 + 7) - *(v15 + v10 + 6));
          }
          v27 = (*v10 + 8 * v15);
          *v29 = (*v27 + (v27[4] - *v27) * v12) * v23 + *v29;
          v29[1] = (v27[1] + (v27[5] - v27[1]) * v12) * v23 + v29[1];
          v29[2] = (v27[2] + (v27[6] - v27[2]) * v12) * v23 + v29[2];
          v29[3] = (v27[3] + (v27[7] - v27[3]) * v12) * v23 + v29[3];
        }
        else
        {
          *v29 = *v10 * v23 + *v29;
          v29[1] = *(v10 + 2) * v23 + v29[1];
          v29[2] = *(v10 + 6) * v23 + v29[2];
          v29[3] = *(v10 + 8) * v23 + v29[3];
        }
      }
      v9 = *v24;
      if ( *v24 )
      {
        v19 = *(v9 + 4);
        if ( *(v9 + 4) )
        {
          if ( v19 >= v7 )
          {
            v16 = v20;
            v13 = v20 - v21;
          }
          else
          {
            v16 = sub_80B9914(a3, v9 + 6, v19, v21);
            v13 = (v20 - *(v16 + v9 + 6)) / (*(v16 + v9 + 7) - *(v16 + v9 + 6));
          }
          v25 = (*v9 + 12 * v16);
          v29[5] = ((v25[3] - *v25) * v13 + *v25) * a4 + v29[5];
          v29[6] = ((v25[4] - v25[1]) * v13 + v25[1]) * a4 + v29[6];
          v29[7] = ((v25[5] - v25[2]) * v13 + v25[2]) * a4 + v29[7];
        }
        else
        {
          v29[5] = a4 * *v9 + v29[5];
          v29[6] = a4 * *(v9 + 8) + v29[6];
          v29[7] = a4 * *(v9 + 12) + v29[7];
        }
      }
      v29[4] = v29[4] + a4;
    }
  }
  return result;
}
// 8456170: using guessed type int dword_8456170;

//----- (080BA17A) --------------------------------------------------------
int __cdecl sub_80BA17A(int a1, int a2, float a3, float a4, int a5)
{
  int result; // eax
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  float v11; // [esp+2Ch] [ebp-4Ch]
  float v12; // [esp+2Ch] [ebp-4Ch]
  float v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+34h] [ebp-44h]
  int v19; // [esp+34h] [ebp-44h]
  float v20; // [esp+38h] [ebp-40h]
  int v21; // [esp+3Ch] [ebp-3Ch]
  int v22; // [esp+40h] [ebp-38h]
  float v23; // [esp+44h] [ebp-34h]
  int *v24; // [esp+48h] [ebp-30h]
  float *v25; // [esp+5Ch] [ebp-1Ch]
  __int16 *v26; // [esp+64h] [ebp-14h]
  __int16 *v27; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  float *v29; // [esp+6Ch] [ebp-Ch]

  v7 = *a1;
  v23 = a4 * 0.000030518509;
  v20 = v7 * a3;
  v21 = v20;
  v6 = *(a1 + 28);
  v8 = **(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v22 = *(a2 + i);
    if ( ((*(&dword_8456170 + (v22 >> 3)) >> (v22 & 7)) & 1) == 0 )
    {
      v29 = (a5 + 32 * v22);
      v24 = (*(a1 + 16) + 8 * i);
      v10 = v24[1];
      if ( ((*((i >> 3) + v6) >> (i & 7)) & 1) != 0 )
      {
        if ( v10 )
        {
          v17 = *(v10 + 4);
          if ( *(v10 + 4) )
          {
            if ( v17 >= v7 )
            {
              v14 = v20;
              v11 = v20 - v21;
            }
            else
            {
              v14 = sub_80B9A32(a3, v10 + 6, v17, v21);
              v11 = (v20 - *(v10 + 2 * v14 + 6)) / (*(v10 + 2 * v14 + 8) - *(v10 + 2 * v14 + 6));
            }
            v26 = (*v10 + 4 * v14);
            v29[2] = (*v26 + (v26[2] - *v26) * v11) * v23 + v29[2];
            v29[3] = (v26[1] + (v26[3] - v26[1]) * v11) * v23 + v29[3];
          }
          else
          {
            v29[2] = *v10 * v23 + v29[2];
            v29[3] = *(v10 + 2) * v23 + v29[3];
          }
        }
        else
        {
          v29[3] = v29[3] + a4;
        }
      }
      else
      {
        v18 = *(v10 + 4);
        if ( *(v10 + 4) )
        {
          if ( v18 >= v7 )
          {
            v15 = v20;
            v12 = v20 - v21;
          }
          else
          {
            v15 = sub_80B9A32(a3, v10 + 6, v18, v21);
            v12 = (v20 - *(v10 + 2 * v15 + 6)) / (*(v10 + 2 * v15 + 8) - *(v10 + 2 * v15 + 6));
          }
          v27 = (*v10 + 8 * v15);
          *v29 = (*v27 + (v27[4] - *v27) * v12) * v23 + *v29;
          v29[1] = (v27[1] + (v27[5] - v27[1]) * v12) * v23 + v29[1];
          v29[2] = (v27[2] + (v27[6] - v27[2]) * v12) * v23 + v29[2];
          v29[3] = (v27[3] + (v27[7] - v27[3]) * v12) * v23 + v29[3];
        }
        else
        {
          *v29 = *v10 * v23 + *v29;
          v29[1] = *(v10 + 2) * v23 + v29[1];
          v29[2] = *(v10 + 6) * v23 + v29[2];
          v29[3] = *(v10 + 8) * v23 + v29[3];
        }
      }
      v9 = *v24;
      if ( *v24 )
      {
        v19 = *(v9 + 4);
        if ( *(v9 + 4) )
        {
          if ( v19 >= v7 )
          {
            v16 = v20;
            v13 = v20 - v21;
          }
          else
          {
            v16 = sub_80B9A32(a3, v9 + 6, v19, v21);
            v13 = (v20 - *(v9 + 2 * v16 + 6)) / (*(v9 + 2 * v16 + 8) - *(v9 + 2 * v16 + 6));
          }
          v25 = (*v9 + 12 * v16);
          v29[5] = ((v25[3] - *v25) * v13 + *v25) * a4 + v29[5];
          v29[6] = ((v25[4] - v25[1]) * v13 + v25[1]) * a4 + v29[6];
          v29[7] = ((v25[5] - v25[2]) * v13 + v25[2]) * a4 + v29[7];
        }
        else
        {
          v29[5] = a4 * *v9 + v29[5];
          v29[6] = a4 * *(v9 + 8) + v29[6];
          v29[7] = a4 * *(v9 + 12) + v29[7];
        }
      }
      v29[4] = v29[4] + a4;
    }
  }
  return result;
}
// 8456170: using guessed type int dword_8456170;

//----- (080BA782) --------------------------------------------------------
int __cdecl sub_80BA782(int a1, int a2, float a3, int a4)
{
  int result; // eax
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  int v8; // [esp+0h] [ebp-2Ch]
  int v9; // [esp+4h] [ebp-28h]
  int v10; // [esp+8h] [ebp-24h]
  int v11; // [esp+Ch] [ebp-20h]
  int v12; // [esp+10h] [ebp-1Ch]
  float v13; // [esp+14h] [ebp-18h]
  int *v14; // [esp+18h] [ebp-14h]
  float *v15; // [esp+1Ch] [ebp-10h]
  __int16 *v16; // [esp+20h] [ebp-Ch]
  __int16 *v17; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  float *v19; // [esp+28h] [ebp-4h]

  v13 = a3 * 0.000030518509;
  v8 = *(a1 + 28);
  v9 = **(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v9 )
      break;
    v12 = *(a2 + i);
    if ( ((*(&dword_8456170 + (v12 >> 3)) >> (v12 & 7)) & 1) == 0 )
    {
      v19 = (a4 + 32 * v12);
      v14 = (*(a1 + 16) + 8 * i);
      v11 = v14[1];
      if ( ((*((i >> 3) + v8) >> (i & 7)) & 1) != 0 )
      {
        if ( v11 )
        {
          if ( *(v11 + 4) )
          {
            v16 = (*v11 + 4 * *(v11 + 4));
            v19[2] = *v16 * v13 + v19[2];
            v5 = v16[1] * v13 + v19[3];
          }
          else
          {
            v19[2] = *v11 * v13 + v19[2];
            v5 = *(v11 + 2) * v13 + v19[3];
          }
          v19[3] = v5;
        }
        else
        {
          v19[3] = v19[3] + a3;
        }
      }
      else
      {
        if ( *(v11 + 4) )
        {
          v17 = (*v11 + 8 * *(v11 + 4));
          *v19 = *v17 * v13 + *v19;
          v19[1] = v17[1] * v13 + v19[1];
          v19[2] = v17[2] * v13 + v19[2];
          v6 = v17[3] * v13 + v19[3];
        }
        else
        {
          *v19 = *v11 * v13 + *v19;
          v19[1] = *(v11 + 2) * v13 + v19[1];
          v19[2] = *(v11 + 6) * v13 + v19[2];
          v6 = *(v11 + 8) * v13 + v19[3];
        }
        v19[3] = v6;
      }
      v10 = *v14;
      if ( *v14 )
      {
        if ( *(v10 + 4) )
        {
          v15 = (*v10 + 12 * *(v10 + 4));
          v19[5] = a3 * *v15 + v19[5];
          v19[6] = a3 * v15[1] + v19[6];
          v7 = a3 * v15[2] + v19[7];
        }
        else
        {
          v19[5] = a3 * *v10 + v19[5];
          v19[6] = a3 * *(v10 + 8) + v19[6];
          v7 = a3 * *(v10 + 12) + v19[7];
        }
        v19[7] = v7;
      }
      v19[4] = v19[4] + a3;
    }
  }
  return result;
}
// 8456170: using guessed type int dword_8456170;

//----- (080BAA8A) --------------------------------------------------------
int __cdecl sub_80BAA8A(_DWORD *a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_8456184 )
      break;
    if ( ((*(&dword_8456170 + (i >> 3)) >> (i & 7)) & 1) == 0 )
    {
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      a1[4] = 0;
      a1[7] = 0;
      a1[6] = 0;
      a1[5] = 0;
    }
    a1 += 8;
  }
  return result;
}
// 8456170: using guessed type int dword_8456170;
// 8456184: using guessed type int dword_8456184;

//----- (080BAB1C) --------------------------------------------------------
int __cdecl sub_80BAB1C(int a1, int a2, float a3, int a4, float a5)
{
  int i; // [esp+18h] [ebp-10h]
  _WORD *v7; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 3; ++i )
    dword_8456160[i] |= *(a2 + 4 * i) & ~dword_8456170[i];
  v7 = *(a1 + 4);
  if ( a5 == 1.0 || !*v7 )
    return sub_80BA782(v7, a2 + 16, a3, a4);
  if ( *v7 > 0xFFu )
    return sub_80BA17A(v7, a2 + 16, a5, a3, a4);
  return sub_80B9B72(v7, a2 + 16, a5, a3, a4);
}
// 8456160: using guessed type int dword_8456160[];

//----- (080BAC12) --------------------------------------------------------
float *__cdecl sub_80BAC12(int a1, int a2, int a3, float a4)
{
  long double v4; // fst7
  float *result; // eax
  int v6; // [esp+18h] [ebp-40h]
  float v7; // [esp+1Ch] [ebp-3Ch]
  float v8; // [esp+1Ch] [ebp-3Ch]
  float v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+20h] [ebp-38h]
  int v11; // [esp+20h] [ebp-38h]
  int v12; // [esp+20h] [ebp-38h]
  int v13; // [esp+24h] [ebp-34h]
  int v14; // [esp+24h] [ebp-34h]
  int v15; // [esp+24h] [ebp-34h]
  int v16; // [esp+24h] [ebp-34h]
  int v17; // [esp+28h] [ebp-30h]
  int v18; // [esp+28h] [ebp-30h]
  int v19; // [esp+2Ch] [ebp-2Ch]
  int v20; // [esp+2Ch] [ebp-2Ch]
  int v21; // [esp+2Ch] [ebp-2Ch]
  int *v22; // [esp+30h] [ebp-28h]
  int *v23; // [esp+30h] [ebp-28h]
  int v24; // [esp+34h] [ebp-24h]
  float v25; // [esp+38h] [ebp-20h]
  _DWORD *v26; // [esp+48h] [ebp-10h]
  float *v27; // [esp+48h] [ebp-10h]
  __int16 *v28; // [esp+50h] [ebp-8h]
  __int16 *v29; // [esp+50h] [ebp-8h]
  __int16 *v30; // [esp+50h] [ebp-8h]

  v6 = *a1;
  if ( a4 != 1.0 && *a1 )
  {
    v25 = v6 * a4;
    v24 = v25;
    v23 = *(a1 + 24);
    if ( *a1 > 0xFFu )
    {
      v21 = v23[1];
      if ( v21 )
      {
        v15 = *(v21 + 4);
        if ( *(v21 + 4) )
        {
          if ( v15 >= v6 )
          {
            v12 = v25;
            v9 = v25 - v24;
          }
          else
          {
            v12 = sub_80B9A32(a4, v21 + 6, v15, v24);
            v9 = (v25 - *(v21 + 2 * v12 + 6)) / (*(v21 + 2 * v12 + 8) - *(v21 + 2 * v12 + 6));
          }
          v30 = (*v21 + 4 * v12);
          *a2 = *v30 + (v30[2] - *v30) * v9;
          *(a2 + 4) = v30[1] + (v30[3] - v30[1]) * v9;
        }
        else
        {
          *a2 = *v21;
          *(a2 + 4) = *(v21 + 2);
        }
      }
      else
      {
        *a2 = 0;
        *(a2 + 4) = 1191181824;
      }
      v18 = *v23;
      if ( !*v23 )
      {
        result = 0;
        *(a3 + 8) = 0;
        *(a3 + 4) = 0;
        *a3 = 0;
        return result;
      }
      v16 = *(v18 + 4);
      if ( !*(v18 + 4) )
      {
        *a3 = *v18;
        *(a3 + 4) = *(v18 + 8);
        result = *(v18 + 12);
        *(a3 + 8) = result;
        return result;
      }
      if ( v16 >= v6 )
      {
        v11 = v25;
        v8 = v25 - v24;
      }
      else
      {
        v11 = sub_80B9A32(a4, v18 + 6, v16, v24);
        v8 = (v25 - *(v18 + 2 * v11 + 6)) / (*(v18 + 2 * v11 + 8) - *(v18 + 2 * v11 + 6));
      }
    }
    else
    {
      v20 = v23[1];
      if ( v20 )
      {
        v13 = *(v20 + 4);
        if ( *(v20 + 4) )
        {
          if ( v13 >= v6 )
          {
            v10 = v25;
            v7 = v25 - v24;
          }
          else
          {
            v10 = sub_80B9914(a4, v20 + 6, v13, v24);
            v7 = (v25 - *(v10 + v20 + 6)) / (*(v10 + v20 + 7) - *(v10 + v20 + 6));
          }
          v29 = (*v20 + 4 * v10);
          *a2 = *v29 + (v29[2] - *v29) * v7;
          *(a2 + 4) = v29[1] + (v29[3] - v29[1]) * v7;
        }
        else
        {
          *a2 = *v20;
          *(a2 + 4) = *(v20 + 2);
        }
      }
      else
      {
        *a2 = 0;
        *(a2 + 4) = 1191181824;
      }
      v18 = *v23;
      if ( !*v23 )
      {
        result = 0;
        *(a3 + 8) = 0;
        *(a3 + 4) = 0;
        *a3 = 0;
        return result;
      }
      v14 = *(v18 + 4);
      if ( !*(v18 + 4) )
      {
        *a3 = *v18;
        *(a3 + 4) = *(v18 + 8);
        result = *(v18 + 12);
        *(a3 + 8) = result;
        return result;
      }
      if ( v14 >= v6 )
      {
        v11 = v25;
        v8 = v25 - v24;
      }
      else
      {
        v11 = sub_80B9914(a4, v18 + 6, v14, v24);
        v8 = (v25 - *(v11 + v18 + 6)) / (*(v11 + v18 + 7) - *(v11 + v18 + 6));
      }
    }
    v27 = (*v18 + 12 * v11);
    *a3 = (v27[3] - *v27) * v8 + *v27;
    *(a3 + 4) = (v27[4] - v27[1]) * v8 + v27[1];
    result = v27 + 5;
    *(a3 + 8) = (v27[5] - v27[2]) * v8 + v27[2];
    return result;
  }
  v22 = *(a1 + 24);
  v19 = v22[1];
  if ( v19 )
  {
    if ( *(v19 + 4) )
    {
      v28 = (*v19 + 4 * *(v19 + 4));
      *a2 = *v28;
      v4 = v28[1];
    }
    else
    {
      *a2 = *v19;
      v4 = *(v19 + 2);
    }
    *(a2 + 4) = v4;
  }
  else
  {
    *a2 = 0;
    *(a2 + 4) = 1191181824;
  }
  v17 = *v22;
  if ( *v22 )
  {
    if ( *(v17 + 4) )
    {
      v26 = (*v17 + 12 * *(v17 + 4));
      *a3 = *v26;
      *(a3 + 4) = v26[1];
      result = v26[2];
    }
    else
    {
      *a3 = *v17;
      *(a3 + 4) = *(v17 + 8);
      result = *(v17 + 12);
    }
    *(a3 + 8) = result;
  }
  else
  {
    result = 0;
    *(a3 + 8) = 0;
    *(a3 + 4) = 0;
    *a3 = 0;
  }
  return result;
}

//----- (080BB35C) --------------------------------------------------------
void __cdecl sub_80BB35C(float *a1, float *a2)
{
  float v2; // [esp+0h] [ebp-10h]
  float v3; // [esp+4h] [ebp-Ch]
  float v4; // [esp+4h] [ebp-Ch]
  float v5; // [esp+8h] [ebp-8h]
  float v6; // [esp+Ch] [ebp-4h]
  float v7; // [esp+Ch] [ebp-4h]

  v6 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v6;
  if ( v3 != 0.0 )
  {
    v4 = 2.0 / v3;
    v7 = v6 * v4;
    v5 = *a1 * a1[1] * v4;
    v2 = (1.0 - v7) * *a2 + v5 * a2[1];
    a2[1] = a2[1] - (v5 * *a2 + v7 * a2[1]);
    *a2 = v2;
  }
}

//----- (080BB40A) --------------------------------------------------------
int __cdecl sub_80BB40A(int a1, float a2, int a3, float a4, float a5)
{
  long double v5; // fst7
  int result; // eax
  int v7; // [esp+10h] [ebp-58h]
  float v8; // [esp+18h] [ebp-50h]
  float *v9; // [esp+1Ch] [ebp-4Ch]
  float v10; // [esp+20h] [ebp-48h] BYREF
  float v11; // [esp+24h] [ebp-44h]
  float v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+30h] [ebp-38h] BYREF
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  int v16[4]; // [esp+40h] [ebp-28h] BYREF
  int v17; // [esp+50h] [ebp-18h] BYREF
  float v18; // [esp+54h] [ebp-14h]
  int v19; // [esp+58h] [ebp-10h] BYREF
  float v20; // [esp+5Ch] [ebp-Ch]

  sub_80BAC12(a1, &v19, v16, a4);
  sub_80BAC12(a1, &v17, &v13, a5);
  if ( *(a1 + 2) )
  {
    if ( a4 > a5 )
    {
      v7 = **(a1 + 24);
      if ( v7 )
      {
        if ( *(v7 + 4) )
        {
          v9 = (*v7 + 12 * *(v7 + 4));
          *&v13 = *&v13 + *v9;
          v14 = v14 + v9[1];
          v5 = v15 + v9[2];
        }
        else
        {
          *&v13 = *&v13 + *v7;
          v14 = v14 + *(v7 + 8);
          v5 = v15 + *(v7 + 12);
        }
        v15 = v5;
      }
    }
  }
  v8 = a2 * 9.3137942e-10;
  *a3 = (*&v17 * v20 - v18 * *&v19) * v8 + *a3;
  *(a3 + 4) = (*&v17 * *&v19 + v18 * v20) * v8 + *(a3 + 4);
  v10 = *&v13 - *v16;
  v11 = v14 - *&v16[1];
  v12 = v15 - *&v16[2];
  sub_80BB35C(&v17, &v10);
  *(a3 + 8) = *(a3 + 8) + a2;
  *(a3 + 12) = a2 * v10 + *(a3 + 12);
  *(a3 + 16) = a2 * v11 + *(a3 + 16);
  result = a3 + 20;
  *(a3 + 20) = a2 * v12 + *(a3 + 20);
  return result;
}

//----- (080BB5D0) --------------------------------------------------------
int __cdecl sub_80BB5D0(int a1, float a2, int a3, float a4)
{
  int result; // eax
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v6[6]; // [esp+20h] [ebp-28h] BYREF
  int v7[4]; // [esp+38h] [ebp-10h] BYREF

  sub_80BAC12(a1, v7, v6, a4);
  v5 = a2 * 0.000030518509;
  *a3 = v5 * *v7 + *a3;
  *(a3 + 4) = v5 * *&v7[1] + *(a3 + 4);
  *(a3 + 8) = *(a3 + 8) + a2;
  *(a3 + 12) = a2 * *v6 + *(a3 + 12);
  *(a3 + 16) = a2 * *&v6[1] + *(a3 + 16);
  result = a3 + 20;
  *(a3 + 20) = a2 * *&v6[2] + *(a3 + 20);
  return result;
}

//----- (080BB68C) --------------------------------------------------------
int __cdecl sub_80BB68C(int a1)
{
  int result; // eax

  result = a1;
  if ( *(a1 + 4) )
    result = sub_80A509E(*(a1 + 4));
  return result;
}

//----- (080BB6AE) --------------------------------------------------------
int __cdecl sub_80BB6AE(int a1, unsigned __int16 a2)
{
  int result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = &unk_8434140 + 68 * a2;
  sub_80BB68C(v3);
  *(v3 + 4) = 0;
  *(v3 + 5) = word_843414A[0];
  word_8434148[34 * word_843414A[0]] = a2;
  word_843414A[0] = a2;
  --dword_84567C4;
  result = a1;
  --*(a1 + 4);
  return result;
}
// 8434148: using guessed type __int16 word_8434148[];
// 843414A: using guessed type __int16 word_843414A[];
// 84567C4: using guessed type int dword_84567C4;

//----- (080BB732) --------------------------------------------------------
long double __cdecl sub_80BB732(int a1)
{
  float v2; // [esp+4h] [ebp-30h]
  float v4; // [esp+Ch] [ebp-28h]
  unsigned __int16 *v5; // [esp+14h] [ebp-20h]
  float v6; // [esp+18h] [ebp-1Ch]
  float v7; // [esp+1Ch] [ebp-18h]
  float v8; // [esp+20h] [ebp-14h]
  unsigned __int16 v9; // [esp+2Ah] [ebp-Ah]
  int i; // [esp+2Ch] [ebp-8h]
  int v11; // [esp+30h] [ebp-4h]

  v5 = (*dword_8456158 + 8 * a1 + 8);
  v11 = *v5;
  if ( !*v5 )
    return *(*(*(*dword_8456158 + 8 * a1 + 12) + 4) + 8);
  v7 = 0.0;
  v6 = 0.0;
  for ( i = 0; i < v11; ++i )
  {
    v9 = *(dword_8456158 + 2 * (i + v5[3]) + 12);
    if ( v9 )
    {
      v8 = *(&unk_8434140 + 17 * v9 + 7 * dword_8456180 + 8);
      if ( v8 != 0.0 )
      {
        v4 = sub_80BB732(i + v5[3]);
        if ( v4 != 0.0 )
        {
          v7 = v7 + v8;
          v6 = v4 * v8 * *(&unk_8434140 + 17 * v9 + 7 * dword_8456180 + 9) + v6;
        }
      }
    }
  }
  if ( v7 == 0.0 )
    v2 = 0.0;
  else
    v2 = v6 / v7;
  return v2;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080BB892) --------------------------------------------------------
int __cdecl sub_80BB892(int a1)
{
  unsigned __int16 *v3; // [esp+Ch] [ebp-1Ch]
  char *v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  char v8; // [esp+27h] [ebp-1h]

  v5 = *(dword_8456158 + 2 * a1 + 12);
  if ( !v5 )
    return 0;
  v4 = &unk_8434140 + 68 * v5;
  *(v4 + 8) = *(v4 + 7);
  *(v4 + 6) = 0;
  v3 = (*dword_8456158 + 8 * a1 + 8);
  v6 = *v3;
  if ( *v3 )
  {
    v8 = 0;
    for ( i = 0; i < v6; ++i )
    {
      if ( sub_80BB892(i + v3[3]) )
        v8 = 1;
    }
    if ( v8
      || *(&unk_8434140 + 17 * v5 + 8) != 0.0
      || *(&unk_8434140 + 17 * v5 + 7) != 0.0
      || *(v4 + 15) != 0.0
      || *(v4 + 14) != 0.0 )
    {
      return 1;
    }
  }
  else if ( *(&unk_8434140 + 17 * v5 + 8) != 0.0
         || *(&unk_8434140 + 17 * v5 + 7) != 0.0
         || *(v4 + 15) != 0.0
         || *(v4 + 14) != 0.0 )
  {
    return 1;
  }
  sub_80BB6AE(dword_8456158, v5);
  *(dword_8456158 + 2 * a1 + 12) = 0;
  return 0;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BBA7E) --------------------------------------------------------
int __cdecl sub_80BBA7E(int a1, int a2, float a3)
{
  int v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]

  v8 = *(*(a1 + 4) + 4);
  v4 = 0;
  v5 = 2.0;
  for ( i = *(v8 + 20); *i; i += 8 )
  {
    v6 = *(i + 4);
    if ( a3 <= v6 && v5 > v6 )
    {
      v5 = *(i + 4);
      v4 = i;
    }
  }
  return ((v4 - *(v8 + 20)) >> 3);
}

//----- (080BBB04) --------------------------------------------------------
long double __cdecl sub_80BBB04(float a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( flt_845614C == 1.0 )
    return 1.0;
  if ( flt_845614C <= flt_8456148 )
  {
    if ( (flt_8456148 > a1 || flt_8456148 == 1.0) && a1 >= flt_845614C )
      v2 = ((word_8456154 - word_8456150) + a1 - flt_8456144) / flt_8456140;
    else
      v2 = 1.0;
  }
  else if ( flt_8456148 <= a1 )
  {
    if ( a1 < flt_845614C )
      v2 = 1.0;
    else
      v2 = ((word_8456154 - word_8456150) + a1 - flt_8456144) / flt_8456140;
  }
  else
  {
    v2 = ((word_8456154 - word_8456150 + 1) + a1 - flt_8456144) / flt_8456140;
  }
  return v2;
}
// 8456140: using guessed type float flt_8456140;
// 845614C: using guessed type float flt_845614C;
// 8456150: using guessed type __int16 word_8456150;
// 8456154: using guessed type __int16 word_8456154;

//----- (080BBC46) --------------------------------------------------------
long double __cdecl sub_80BBC46(unsigned __int16 *a1, int a2)
{
  long double v2; // fst7

  if ( !word_845618C || !a1[2] )
    return 1.0;
  if ( *a2 )
  {
    if ( !*a1 )
      return sub_80BBB04(1.0);
    a2 = *dword_8456158 + 8 * *a1 + 8;
  }
  if ( (a1[1] & 0x8000u) != 0 )
    v2 = sub_80BBB04(1.0);
  else
    v2 = sub_80BBB04(*(*(*(*(a2 + 4) + 4) + 20) + 8 * a1[1] + 4));
  return v2;
}
// 8456158: using guessed type int dword_8456158;
// 845618C: using guessed type __int16 word_845618C;

//----- (080BBCF6) --------------------------------------------------------
int __cdecl sub_80BBCF6(int a1, int a2, int a3, float a4, int a5)
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  float *v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]

  HIWORD(v9) = a3;
  LOWORD(v9) = a5;
  for ( i = dword_84567C0 - 1; i >= 0; --i )
  {
    v7 = (&unk_84561C0 + 12 * i);
    if ( a4 >= v7[2] )
      break;
    v7[3] = *v7;
    v7[4] = v7[1];
    v7[5] = v7[2];
  }
  v8 = 12 * i + 138764748;
  dword_84561CC[3 * i] = sub_80A4458(a3);
  *(v8 + 8) = a4;
  result = v9;
  *(v8 + 4) = a5;
  ++dword_84567C0;
  return result;
}
// 84567C0: using guessed type int dword_84567C0;

//----- (080BBDAC) --------------------------------------------------------
void __cdecl sub_80BBDAC(int a1, int a2, unsigned __int16 a3)
{
  float v3; // [esp+Ch] [ebp-1Ch]
  float v4; // [esp+Ch] [ebp-1Ch]
  float v5; // [esp+Ch] [ebp-1Ch]
  float v6; // [esp+Ch] [ebp-1Ch]
  float v7; // [esp+Ch] [ebp-1Ch]
  float v8; // [esp+Ch] [ebp-1Ch]
  float *v9; // [esp+18h] [ebp-10h]
  float *i; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  *(a1 + 16) = flt_8456144;
  *(a1 + 22) = word_8456150;
  *(a1 + 12) = flt_8456148;
  *(a1 + 20) = word_8456152;
  if ( a3 && flt_8456140 != 0.0 )
  {
    flt_845614C = flt_8456144;
    word_8456154 = word_8456150;
    if ( flt_8456144 == 1.0 )
    {
LABEL_4:
      v3 = sub_80BBB04(1.0);
      sub_80BBCF6(a1, a2, word_80F732A, v3, a3);
      return;
    }
    if ( *a2 )
    {
      if ( flt_8456144 > flt_8456148 || flt_8456148 == 1.0 )
        goto LABEL_4;
    }
    else
    {
      v11 = *(*(a2 + 4) + 4);
      v9 = (*(v11 + 20) + 8 * sub_80BBA7E(a2, a1, flt_8456144));
      if ( flt_8456144 <= flt_8456148 )
      {
        if ( flt_8456148 == 1.0 )
        {
          if ( flt_8456144 <= v9[1] )
          {
            do
            {
              v7 = sub_80BBB04(v9[1]);
              sub_80BBCF6(a1, a2, *v9, v7, a3);
              v9 += 2;
            }
            while ( *v9 );
          }
        }
        else if ( v9[1] < flt_8456148 && flt_8456144 <= v9[1] )
        {
          do
          {
            v8 = sub_80BBB04(v9[1]);
            sub_80BBCF6(a1, a2, *v9, v8, a3);
            v9 += 2;
          }
          while ( *v9 && flt_8456148 > v9[1] );
        }
      }
      else if ( flt_8456148 <= v9[1] )
      {
        if ( flt_8456144 <= v9[1] )
        {
          do
          {
            v5 = sub_80BBB04(v9[1]);
            sub_80BBCF6(a1, a2, *v9, v5, a3);
            v9 += 2;
          }
          while ( *v9 );
          for ( i = *(v11 + 20); flt_8456148 > i[1]; i += 4 )
          {
            v6 = sub_80BBB04(i[1]);
            sub_80BBCF6(a1, a2, *i, v6, a3);
          }
        }
      }
      else
      {
        do
        {
          v4 = sub_80BBB04(v9[1]);
          sub_80BBCF6(a1, a2, *v9, v4, a3);
          v9 += 2;
        }
        while ( *v9 && flt_8456148 > v9[1] );
      }
    }
  }
}
// 80F732A: using guessed type __int16 word_80F732A;
// 8456140: using guessed type float flt_8456140;
// 845614C: using guessed type float flt_845614C;
// 8456150: using guessed type __int16 word_8456150;
// 8456152: using guessed type __int16 word_8456152;
// 8456154: using guessed type __int16 word_8456154;

//----- (080BC178) --------------------------------------------------------
void __cdecl sub_80BC178(int a1, unsigned __int8 a2)
{
  unsigned __int16 *v2; // [esp+18h] [ebp-20h]
  char *v3; // [esp+20h] [ebp-18h]
  unsigned __int16 v4; // [esp+26h] [ebp-12h]
  int v5; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+2Ch] [ebp-Ch]
  char v8; // [esp+32h] [ebp-6h]

  v4 = *(dword_8456158 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = &unk_8434140 + 68 * v4;
    if ( *(v3 + 7) == 0.0 )
      a2 = 0;
    if ( flt_8456190 + 0.001 <= *(v3 + 6) )
    {
      *(v3 + 8) = (*(v3 + 7) - *(v3 + 8)) * flt_8456190 / *(v3 + 6) + *(v3 + 8);
      if ( *(v3 + 8) < 0.0000010000001 )
        *(v3 + 8) = *(v3 + 7) * 0.001;
      *(v3 + 6) = *(v3 + 6) - flt_8456190;
    }
    else
    {
      *(v3 + 8) = *(v3 + 7);
      *(v3 + 6) = 0;
    }
    v2 = (*dword_8456158 + 8 * a1 + 8);
    if ( a2 )
      sub_80BBDAC(v3, v2, *(v3 + 3));
    else
      sub_80BBDAC(v3, v2, 0);
    v5 = *v2;
    if ( *v2 )
    {
      if ( *(v3 + 8) == 0.0 && *(v3 + 7) == 0.0 )
      {
        v8 = 0;
        for ( i = 0; i < v5; ++i )
        {
          if ( sub_80BB892(i + v2[3]) )
            v8 = 1;
        }
        if ( !v8 && *(v3 + 15) == 0.0 && *(v3 + 14) == 0.0 )
          goto LABEL_17;
      }
      else
      {
        for ( j = 0; j < v5; ++j )
          sub_80BC178(j + v2[3], a2);
      }
    }
    else if ( *(v3 + 8) == 0.0 && *(v3 + 7) == 0.0 && *(v3 + 15) == 0.0 && *(v3 + 14) == 0.0 )
    {
LABEL_17:
      sub_80BB6AE(dword_8456158, v4);
      *(dword_8456158 + 2 * a1 + 12) = 0;
      return;
    }
  }
}
// 8456158: using guessed type int dword_8456158;
// 8456190: using guessed type float flt_8456190;

//----- (080BC456) --------------------------------------------------------
void __cdecl sub_80BC456(int a1, float a2, int a3)
{
  __int16 v3; // [esp+1Ah] [ebp-2Eh]
  __int16 v4; // [esp+1Ah] [ebp-2Eh]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  unsigned __int16 *v8; // [esp+28h] [ebp-20h]
  float *v9; // [esp+2Ch] [ebp-1Ch]
  char *v10; // [esp+30h] [ebp-18h]
  unsigned __int16 v11; // [esp+36h] [ebp-12h]
  int v12; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+3Ch] [ebp-Ch]
  int k; // [esp+3Ch] [ebp-Ch]
  char v16; // [esp+42h] [ebp-6h]
  unsigned __int8 v17; // [esp+43h] [ebp-5h]
  float v18; // [esp+54h] [ebp+Ch]
  float v19; // [esp+54h] [ebp+Ch]
  float v20; // [esp+54h] [ebp+Ch]

  v17 = a3;
  v11 = *(dword_8456158 + 2 * a1 + 12);
  if ( v11 )
  {
    v10 = &unk_8434140 + 68 * v11;
    v9 = (v10 + 12);
    if ( *(v10 + 7) == 0.0 )
      v17 = 0;
    if ( flt_8456190 + 0.001 <= *(v10 + 6) )
    {
      *(v10 + 8) = (*(v10 + 7) - *(v10 + 8)) * flt_8456190 / *(v10 + 6) + *(v10 + 8);
      if ( *(v10 + 8) < 0.0000010000001 )
        *(v10 + 8) = *(v10 + 7) * 0.001;
      *(v10 + 6) = *(v10 + 6) - flt_8456190;
    }
    else
    {
      *(v10 + 8) = *(v10 + 7);
      *(v10 + 6) = 0;
    }
    v8 = (*dword_8456158 + 8 * a1 + 8);
    v12 = *v8;
    if ( *v8 )
    {
      if ( *(v10 + 8) == 0.0 && *(v10 + 7) == 0.0 )
      {
        v16 = 0;
        for ( i = 0; i < v12; ++i )
        {
          if ( sub_80BB892(i + v8[3]) )
            v16 = 1;
        }
        if ( !v16 && *(v10 + 15) == 0.0 && *(v10 + 14) == 0.0 )
          goto LABEL_14;
      }
      else if ( (*(*dword_8456158 + 8 * a1 + 12) & 3) != 0 )
      {
        v19 = sub_80BB732(a1) * *(v10 + 9) * a2;
        v6 = *v9 + v19;
        v4 = *(v10 + 10);
        if ( v6 >= 1.0 )
        {
          if ( (v8[2] & 2) != 0 )
          {
            v6 = 1.0;
          }
          else
          {
            do
            {
              v6 = v6 - 1.0;
              ++v4;
            }
            while ( v6 >= 1.0 );
          }
        }
        flt_8456140 = v19;
        flt_8456144 = *v9;
        word_8456150 = *(v10 + 10);
        flt_8456148 = v6;
        word_8456152 = v4;
        if ( v17 )
          sub_80BBDAC(v10, v8, *(v10 + 3));
        else
          sub_80BBDAC(v10, v8, 0);
        flt_8456144 = *(v10 + 4);
        word_8456150 = *(v10 + 11);
        flt_8456148 = *v9;
        word_8456152 = *(v10 + 10);
        for ( j = 0; j < v12; ++j )
          sub_80BC178(j + v8[3], v17);
      }
      else
      {
        v20 = a2 * *(v10 + 9);
        for ( k = 0; k < v12; ++k )
          sub_80BC456(k + v8[3], v20, v17);
      }
    }
    else if ( *(v10 + 8) == 0.0 && *(v10 + 7) == 0.0 )
    {
      if ( *(v10 + 15) == 0.0 && *(v10 + 14) == 0.0 )
      {
LABEL_14:
        sub_80BB6AE(dword_8456158, v11);
        *(dword_8456158 + 2 * a1 + 12) = 0;
        return;
      }
    }
    else
    {
      v7 = *(*(*dword_8456158 + 8 * a1 + 12) + 4);
      v18 = *(v10 + 9) * *(v7 + 8) * a2;
      v5 = *v9 + v18;
      v3 = *(v10 + 10);
      if ( v5 >= 1.0 )
      {
        if ( *(v7 + 2) )
        {
          do
          {
            v5 = v5 - 1.0;
            ++v3;
          }
          while ( v5 >= 1.0 );
        }
        else
        {
          v5 = 1.0;
        }
      }
      flt_8456140 = v18;
      flt_8456144 = *v9;
      word_8456150 = *(v10 + 10);
      flt_8456148 = v5;
      word_8456152 = v3;
      if ( v17 )
        sub_80BBDAC(v10, v8, *(v10 + 3));
      else
        sub_80BBDAC(v10, v8, 0);
    }
  }
}
// 8456140: using guessed type float flt_8456140;
// 8456150: using guessed type __int16 word_8456150;
// 8456152: using guessed type __int16 word_8456152;
// 8456158: using guessed type int dword_8456158;
// 8456190: using guessed type float flt_8456190;

//----- (080BC94E) --------------------------------------------------------
int __cdecl sub_80BC94E(int a1)
{
  int result; // eax
  unsigned __int16 *v2; // [esp+4h] [ebp-1Ch]
  char *v3; // [esp+8h] [ebp-18h]
  unsigned __int16 v4; // [esp+16h] [ebp-Ah]
  int v5; // [esp+18h] [ebp-8h]
  int i; // [esp+1Ch] [ebp-4h]

  result = *(dword_8456158 + 2 * a1 + 12);
  v4 = *(dword_8456158 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = &unk_8434140 + 68 * v4 + 12;
    *v3 = *(&unk_8434140 + 17 * v4 + 11);
    *(v3 + 4) = *(&unk_8434140 + 34 * v4 + 25);
    *(v3 + 4) = *(&unk_8434140 + 17 * v4 + 14);
    *(v3 + 6) = *(&unk_8434140 + 17 * v4 + 16);
    *(v3 + 3) = *(&unk_8434140 + 17 * v4 + 13);
    *(v3 + 5) = *(&unk_8434140 + 17 * v4 + 15);
    v2 = (*dword_8456158 + 8 * a1 + 8);
    v5 = *v2;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v5 )
        break;
      sub_80BC94E(i + v2[3]);
    }
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BCA32) --------------------------------------------------------
int __cdecl sub_80BCA32(int a1)
{
  unsigned __int16 *v3; // [esp+Ch] [ebp-1Ch]
  char *v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  char v8; // [esp+27h] [ebp-1h]

  v5 = *(dword_8456158 + 2 * a1 + 12);
  if ( !v5 )
    return 0;
  v4 = &unk_8434140 + 68 * v5;
  *(v4 + 15) = *(v4 + 14);
  *(v4 + 13) = 0;
  v3 = (*dword_8456158 + 8 * a1 + 8);
  v6 = *v3;
  if ( *v3 )
  {
    v8 = 0;
    for ( i = 0; i < v6; ++i )
    {
      if ( sub_80BCA32(i + v3[3]) )
        v8 = 1;
    }
    if ( v8
      || *(&unk_8434140 + 17 * v5 + 15) != 0.0
      || *(&unk_8434140 + 17 * v5 + 14) != 0.0
      || *(v4 + 8) != 0.0
      || *(v4 + 7) != 0.0 )
    {
      return 1;
    }
  }
  else if ( *(&unk_8434140 + 17 * v5 + 15) != 0.0
         || *(&unk_8434140 + 17 * v5 + 14) != 0.0
         || *(v4 + 8) != 0.0
         || *(v4 + 7) != 0.0 )
  {
    return 1;
  }
  sub_80BB6AE(dword_8456158, v5);
  *(dword_8456158 + 2 * a1 + 12) = 0;
  return 0;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BCC1E) --------------------------------------------------------
void __cdecl sub_80BCC1E(int a1)
{
  char v1; // [esp+Bh] [ebp-1Dh]
  unsigned __int16 *v2; // [esp+Ch] [ebp-1Ch]
  char *v3; // [esp+14h] [ebp-14h]
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  int v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  v4 = *(dword_8456158 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = &unk_8434140 + 68 * v4;
    *(v3 + 11) = *(v3 + 10);
    *(v3 + 25) = *(v3 + 24);
    if ( flt_8456190 + 0.001 <= *(v3 + 13) )
    {
      *(v3 + 15) = (*(v3 + 14) - *(v3 + 15)) * flt_8456190 / *(v3 + 13) + *(v3 + 15);
      if ( *(v3 + 15) < 0.0000010000001 )
        *(v3 + 15) = *(v3 + 14) * 0.001;
      *(v3 + 13) = *(v3 + 13) - flt_8456190;
    }
    else
    {
      *(v3 + 15) = *(v3 + 14);
      *(v3 + 13) = 0;
    }
    v2 = (*dword_8456158 + 8 * a1 + 8);
    v5 = *v2;
    if ( *v2 )
    {
      if ( *(v3 + 15) == 0.0 && *(v3 + 14) == 0.0 )
      {
        v1 = 0;
        for ( i = 0; i < v5; ++i )
        {
          if ( sub_80BCA32(i + v2[3]) )
            v1 = 1;
        }
        if ( !v1 && *(v3 + 8) == 0.0 && *(v3 + 7) == 0.0 )
          goto LABEL_12;
      }
      else
      {
        for ( j = 0; j < v5; ++j )
          sub_80BCC1E(j + v2[3]);
      }
    }
    else if ( *(v3 + 15) == 0.0 && *(v3 + 14) == 0.0 && *(v3 + 8) == 0.0 && *(v3 + 7) == 0.0 )
    {
LABEL_12:
      sub_80BB6AE(dword_8456158, v4);
      *(dword_8456158 + 2 * a1 + 12) = 0;
      return;
    }
  }
}
// 8456158: using guessed type int dword_8456158;
// 8456190: using guessed type float flt_8456190;

//----- (080BCEB6) --------------------------------------------------------
int __cdecl sub_80BCEB6(int a1)
{
  int result; // eax

  if ( *(a1 + 4) )
  {
    sub_80A509E(*(a1 + 4));
    *(a1 + 4) = 0;
  }
  result = a1;
  *(a1 + 2) = -1;
  return result;
}

//----- (080BCEEA) --------------------------------------------------------
int __cdecl sub_80BCEEA(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  sub_80B03AA(a3);
  return sub_80AEAEA(a1, a2, 1);
}

//----- (080BCF30) --------------------------------------------------------
long double __cdecl sub_80BCF30(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]
  float *v8; // [esp+30h] [ebp+8h]

  v7 = sub_80BBC46(a1, a2);
  for ( i = 0; i < *a2; ++i )
  {
    v4 = i + a2[3];
    v3 = *(dword_8456158 + 2 * v4 + 12);
    if ( v3 )
    {
      v8 = (&unk_8434140 + 68 * v3);
      if ( v8[15] != 0.0 && v8[14] != 0.0 )
      {
        v5 = sub_80BCF30(v8, *dword_8456158 + 8 * v4 + 8);
        if ( v7 > v5 )
          v7 = v5;
      }
    }
  }
  return v7;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BD01A) --------------------------------------------------------
long double __cdecl sub_80BD01A(int a1, float a2)
{
  long double v2; // fst7
  float v4; // [esp+14h] [ebp-34h]
  float v5; // [esp+18h] [ebp-30h]
  float v6; // [esp+1Ch] [ebp-2Ch]
  __int16 v7; // [esp+22h] [ebp-26h]
  __int16 v8; // [esp+22h] [ebp-26h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  unsigned __int16 *v12; // [esp+30h] [ebp-18h]
  float *v13; // [esp+34h] [ebp-14h]
  float *v14; // [esp+38h] [ebp-10h]
  unsigned __int16 v15; // [esp+3Eh] [ebp-Ah]
  int v16; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  float v18; // [esp+54h] [ebp+Ch]
  float v19; // [esp+54h] [ebp+Ch]
  float v20; // [esp+54h] [ebp+Ch]

  v15 = *(dword_8456158 + 2 * a1 + 12);
  if ( !v15 )
    return 1.0;
  v14 = (&unk_8434140 + 68 * v15);
  v13 = v14 + 10;
  if ( v14[15] == 0.0 || v14[14] == 0.0 )
    return 1.0;
  v12 = (*dword_8456158 + 8 * a1 + 8);
  v16 = *v12;
  if ( *v12 )
  {
    if ( (*(*dword_8456158 + 8 * a1 + 12) & 3) != 0 )
    {
      v19 = sub_80BB732(a1) * v14[16] * a2;
      if ( v19 == 0.0 )
      {
        v4 = 1.0;
      }
      else
      {
        v10 = v14[11] + v19;
        v8 = *(v14 + 25);
        if ( (v12[2] & 2) != 0 )
        {
          if ( v10 >= 1.0 )
            v10 = 1.0;
        }
        else
        {
          while ( v10 >= 1.0 )
          {
            v10 = v10 - 1.0;
            ++v8;
          }
        }
        if ( *v13 - v10 <= (v8 - *(v14 + 24)) )
        {
          flt_8456140 = v19;
          flt_8456144 = v14[11];
          word_8456150 = *(v14 + 25);
          flt_8456148 = v10;
          flt_845614C = *v13;
          word_8456154 = *(v14 + 24);
          v4 = sub_80BCF30(v14, v12);
        }
        else
        {
          v4 = 1.0;
        }
      }
    }
    else
    {
      v20 = a2 * v14[16];
      v2 = 0.0;
      if ( v20 == 0.0 )
      {
        v4 = 1.0;
      }
      else
      {
        v5 = 1.0;
        for ( i = 0; i < v16; ++i )
        {
          sub_80BD01A(i + v12[3], v20);
          v6 = v2;
          v2 = v6;
          if ( v5 > v6 )
            v5 = v6;
        }
        v4 = v5;
      }
    }
  }
  else
  {
    v11 = *(*(*dword_8456158 + 8 * a1 + 12) + 4);
    v18 = v14[16] * *(v11 + 8) * a2;
    if ( v18 == 0.0 )
    {
      v4 = 1.0;
    }
    else
    {
      v9 = v14[11] + v18;
      v7 = *(v14 + 25);
      if ( *(v11 + 2) )
      {
        while ( v9 >= 1.0 )
        {
          v9 = v9 - 1.0;
          ++v7;
        }
      }
      else if ( v9 >= 1.0 )
      {
        v9 = 1.0;
      }
      if ( *v13 - v9 <= (v7 - *(v14 + 24)) )
      {
        flt_8456140 = v18;
        flt_8456144 = v14[11];
        word_8456150 = *(v14 + 25);
        flt_8456148 = v9;
        flt_845614C = *v13;
        word_8456154 = *(v14 + 24);
        v4 = sub_80BBC46(v14, v12);
      }
      else
      {
        v4 = 1.0;
      }
    }
  }
  return v4;
}
// 8456140: using guessed type float flt_8456140;
// 845614C: using guessed type float flt_845614C;
// 8456150: using guessed type __int16 word_8456150;
// 8456154: using guessed type __int16 word_8456154;
// 8456158: using guessed type int dword_8456158;

//----- (080BD3A0) --------------------------------------------------------
void __cdecl sub_80BD3A0(unsigned __int16 *a1, int a2)
{
  int v2; // [esp+18h] [ebp-10h]
  int i; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  if ( !word_845618C || !a1[2] )
    return;
  if ( flt_8456144 == 1.0 )
  {
LABEL_4:
    sub_80B03AA(word_80F732A);
    sub_80AEAEA(word_845618C, a1[2], 1);
    return;
  }
  if ( !*a2 )
  {
LABEL_11:
    v4 = *(*(a2 + 4) + 4);
    v2 = *(v4 + 20) + 8 * a1[1];
    if ( flt_8456144 <= flt_8456148 )
    {
      if ( flt_8456148 == 1.0 )
      {
        if ( flt_8456144 <= *(v2 + 4) )
        {
          do
          {
            sub_80BCEEA(word_845618C, a1[2], *v2);
            v2 += 8;
          }
          while ( *v2 );
        }
        return;
      }
      if ( *(v2 + 4) >= flt_8456148 || flt_8456144 > *(v2 + 4) )
        return;
      do
      {
        sub_80BCEEA(word_845618C, a1[2], *v2);
        v2 += 8;
      }
      while ( *v2 && flt_8456148 > *(v2 + 4) );
    }
    else if ( flt_8456148 <= *(v2 + 4) )
    {
      if ( flt_8456144 > *(v2 + 4) )
        return;
      do
      {
        sub_80BCEEA(word_845618C, a1[2], *v2);
        v2 += 8;
      }
      while ( *v2 );
      for ( i = *(v4 + 20); flt_8456148 > *(i + 4); i += 8 )
        sub_80BCEEA(word_845618C, a1[2], *i);
    }
    else
    {
      do
      {
        sub_80BCEEA(word_845618C, a1[2], *v2);
        v2 += 8;
      }
      while ( *v2 && flt_8456148 > *(v2 + 4) );
    }
    a1[1] = sub_80BBA7E(a2, a1, flt_8456148);
    return;
  }
  if ( *a1 )
  {
    a2 = *dword_8456158 + 8 * *a1 + 8;
    goto LABEL_11;
  }
  if ( flt_8456144 > flt_8456148 || flt_8456148 == 1.0 )
    goto LABEL_4;
}
// 80F732A: using guessed type __int16 word_80F732A;
// 8456158: using guessed type int dword_8456158;
// 845618C: using guessed type __int16 word_845618C;

//----- (080BD71E) --------------------------------------------------------
int __cdecl sub_80BD71E(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]
  float *v6; // [esp+20h] [ebp+8h]

  sub_80BD3A0(a1, a2);
  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v3 = i + a2[3];
    v4 = *(dword_8456158 + 2 * v3 + 12);
    if ( v4 )
    {
      v6 = (&unk_8434140 + 68 * v4);
      if ( v6[15] != 0.0 && v6[14] != 0.0 )
        sub_80BD71E(v6, *dword_8456158 + 8 * v3 + 8);
    }
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BD7E4) --------------------------------------------------------
int __cdecl sub_80BD7E4(int a1)
{
  int result; // eax
  unsigned __int16 *v2; // [esp+4h] [ebp-14h]
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  result = *(dword_8456158 + 2 * a1 + 12);
  v3 = *(dword_8456158 + 2 * a1 + 12);
  if ( v3 )
  {
    *(&unk_8434140 + 17 * v3 + 10) = flt_8456148;
    *(&unk_8434140 + 34 * v3 + 24) = word_8456152;
    v2 = (*dword_8456158 + 8 * a1 + 8);
    for ( i = 0; ; ++i )
    {
      result = *v2;
      if ( i >= result )
        break;
      sub_80BD7E4(i + v2[3]);
    }
  }
  return result;
}
// 8456152: using guessed type __int16 word_8456152;
// 8456158: using guessed type int dword_8456158;

//----- (080BD884) --------------------------------------------------------
void __cdecl sub_80BD884(int a1, float a2, int a3)
{
  __int16 v3; // [esp+Eh] [ebp-2Ah]
  __int16 v4; // [esp+Eh] [ebp-2Ah]
  float v5; // [esp+10h] [ebp-28h]
  float v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  unsigned __int16 *v8; // [esp+1Ch] [ebp-1Ch]
  float *v9; // [esp+20h] [ebp-18h]
  char *v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  int v12; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  unsigned __int8 v14; // [esp+37h] [ebp-1h]
  float v15; // [esp+44h] [ebp+Ch]
  float v16; // [esp+44h] [ebp+Ch]

  v14 = a3;
  v11 = *(dword_8456158 + 2 * a1 + 12);
  if ( v11 )
  {
    v10 = &unk_8434140 + 68 * v11;
    v9 = (v10 + 40);
    if ( *(v10 + 15) != 0.0 )
    {
      if ( *(v10 + 14) == 0.0 )
        v14 = 0;
      v8 = (*dword_8456158 + 8 * a1 + 8);
      v12 = *v8;
      if ( *v8 )
      {
        if ( (*(*dword_8456158 + 8 * a1 + 12) & 3) != 0 )
        {
          v15 = sub_80BB732(a1) * *(v10 + 16) * a2;
          v6 = *(v10 + 11) + v15;
          v4 = *(v10 + 25);
          if ( (v8[2] & 2) != 0 )
          {
            if ( v6 < 1.0 )
            {
              if ( v6 <= 0.0 )
                return;
            }
            else
            {
              v6 = 1.0;
            }
          }
          else
          {
            while ( v6 < 0.0 )
            {
              v6 = v6 + 1.0;
              --v4;
            }
            while ( v6 >= 1.0 )
            {
              v6 = v6 - 1.0;
              ++v4;
            }
          }
          if ( *v9 - v6 <= (v4 - *(v10 + 24)) )
          {
            flt_8456148 = v6;
            if ( v14 )
            {
              flt_8456144 = *v9;
              word_8456150 = *(v10 + 24);
              sub_80BD71E(v10, v8);
            }
            word_8456152 = v4;
            sub_80BD7E4(a1);
          }
        }
        else
        {
          v16 = a2 * *(v10 + 16);
          for ( i = 0; i < v12; ++i )
            sub_80BD884(i + v8[3], v16, v14);
        }
      }
      else
      {
        v7 = *(*(*dword_8456158 + 8 * a1 + 12) + 4);
        v5 = a2 * *(v10 + 16) * *(v7 + 8) + *(v10 + 11);
        v3 = *(v10 + 25);
        if ( *(v7 + 2) )
        {
          while ( v5 < 0.0 )
          {
            v5 = v5 + 1.0;
            --v3;
          }
          while ( v5 >= 1.0 )
          {
            v5 = v5 - 1.0;
            ++v3;
          }
        }
        else if ( v5 < 1.0 )
        {
          if ( v5 <= 0.0 )
            return;
        }
        else
        {
          v5 = 1.0;
        }
        if ( *v9 - v5 <= (v3 - *(v10 + 24)) )
        {
          if ( v14 )
          {
            flt_8456148 = v5;
            flt_8456144 = *v9;
            word_8456150 = *(v10 + 24);
            sub_80BD3A0(v10, v8);
          }
          *v9 = v5;
          *(v10 + 24) = v3;
        }
      }
    }
  }
}
// 8456150: using guessed type __int16 word_8456150;
// 8456152: using guessed type __int16 word_8456152;
// 8456158: using guessed type int dword_8456158;

//----- (080BDBDC) --------------------------------------------------------
int __cdecl sub_80BDBDC(int a1, float a2, int a3, int a4, int a5)
{
  int v5; // eax
  int result; // eax
  void *v7; // esp
  int v8; // [esp+14h] [ebp-44h] BYREF
  int *v9; // [esp+20h] [ebp-38h]
  float v10; // [esp+24h] [ebp-34h]
  _BYTE *v11; // [esp+28h] [ebp-30h]
  unsigned __int16 *v12; // [esp+2Ch] [ebp-2Ch]
  unsigned __int16 v13; // [esp+32h] [ebp-26h]
  float v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int j; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  float v19; // [esp+48h] [ebp-10h]
  float v20; // [esp+4Ch] [ebp-Ch]
  unsigned __int8 v21; // [esp+52h] [ebp-6h]
  unsigned __int8 v22; // [esp+53h] [ebp-5h]

  v22 = a4;
  v21 = a5;
  v12 = (*dword_8456158 + 8 * a1 + 8);
  v16 = *v12;
  if ( v16 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v16 )
      {
        if ( v22 )
          result = sub_80BAA8A(a3);
        return result;
      }
      v13 = *(dword_8456158 + 2 * (i + v12[3]) + 12);
      if ( v13 )
      {
        v19 = *(&unk_8434160 + 17 * v13 + 7 * dword_8456180);
        if ( v19 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v16 )
        return sub_80BDBDC(i + v12[3], a2, a3, v22, v21);
      v13 = *(dword_8456158 + 2 * (j + v12[3]) + 12);
      if ( v13 )
      {
        v20 = *(&unk_8434160 + 17 * v13 + 7 * dword_8456180);
        if ( v20 != 0.0 )
          break;
      }
    }
    if ( v22 )
    {
      v9 = a3;
    }
    else
    {
      v7 = alloca(16 * ((dword_8456188 + 15) >> 4));
      v9 = &v8;
    }
    v15 = v9;
    sub_80BDBDC(i + v12[3], v19, v9, 1, 1);
    sub_80BDBDC(j + v12[3], v20, v15, 0, 1);
    ++j;
    while ( j < v16 )
    {
      v13 = *(dword_8456158 + 2 * (j + v12[3]) + 12);
      if ( v13 )
      {
        v20 = *(&unk_8434160 + 17 * v13 + 7 * dword_8456180);
        if ( v20 != 0.0 )
          sub_80BDBDC(j + v12[3], v20, v15, 0, 1);
      }
      ++j;
    }
    if ( v21 )
    {
      if ( v22 )
      {
        i = 0;
        while ( 1 )
        {
          result = i;
          if ( i >= dword_8456184 )
            break;
          if ( ((dword_8456170[i >> 3] >> (i & 7)) & 1) == 0 )
          {
            v14 = *a3 * *a3 + *(a3 + 4) * *(a3 + 4) + *(a3 + 8) * *(a3 + 8) + *(a3 + 12) * *(a3 + 12);
            if ( v14 != 0.0 )
            {
              v10 = sqrt(v14);
              v14 = a2 / v10;
              *a3 = *a3 * v14;
              *(a3 + 4) = *(a3 + 4) * v14;
              *(a3 + 8) = *(a3 + 8) * v14;
              *(a3 + 12) = *(a3 + 12) * v14;
            }
            if ( *(a3 + 16) != 0.0 )
            {
              v14 = a2 / *(a3 + 16);
              *(a3 + 16) = a2;
              *(a3 + 20) = *(a3 + 20) * v14;
              *(a3 + 24) = *(a3 + 24) * v14;
              *(a3 + 28) = *(a3 + 28) * v14;
            }
          }
          ++i;
          a3 += 32;
        }
      }
      else
      {
        i = 0;
        while ( 1 )
        {
          result = i;
          if ( i >= dword_8456184 )
            break;
          if ( ((dword_8456170[i >> 3] >> (i & 7)) & 1) == 0 )
          {
            v14 = *v15 * *v15 + *(v15 + 4) * *(v15 + 4) + *(v15 + 8) * *(v15 + 8) + *(v15 + 12) * *(v15 + 12);
            if ( v14 != 0.0 )
            {
              v10 = sqrt(v14);
              v14 = a2 / v10;
              *a3 = *v15 * v14 + *a3;
              *(a3 + 4) = *(v15 + 4) * v14 + *(a3 + 4);
              *(a3 + 8) = *(v15 + 8) * v14 + *(a3 + 8);
              *(a3 + 12) = *(v15 + 12) * v14 + *(a3 + 12);
            }
            if ( *(v15 + 16) != 0.0 )
            {
              v14 = a2 / *(v15 + 16);
              *(a3 + 16) = *(a3 + 16) + a2;
              *(a3 + 20) = *(v15 + 20) * v14 + *(a3 + 20);
              *(a3 + 24) = *(v15 + 24) * v14 + *(a3 + 24);
              *(a3 + 28) = *(v15 + 28) * v14 + *(a3 + 28);
            }
          }
          ++i;
          a3 += 32;
          v15 += 32;
        }
      }
    }
    else
    {
      i = 0;
      while ( 1 )
      {
        result = i;
        if ( i >= dword_8456184 )
          break;
        if ( ((dword_8456170[i >> 3] >> (i & 7)) & 1) == 0 && *(a3 + 16) != 0.0 )
        {
          v14 = 1.0 / *(a3 + 16);
          *a3 = *a3 * v14;
          *(a3 + 4) = *(a3 + 4) * v14;
          *(a3 + 8) = *(a3 + 8) * v14;
          *(a3 + 12) = *(a3 + 12) * v14;
          *(a3 + 20) = *(a3 + 20) * v14;
          *(a3 + 24) = *(a3 + 24) * v14;
          *(a3 + 28) = *(a3 + 28) * v14;
        }
        ++i;
        a3 += 32;
      }
    }
  }
  else
  {
    if ( v22 )
      sub_80BAA8A(a3);
    v11 = (*(dword_845615C + 12) + 2 * *(*dword_8456158 + 4));
    if ( *(*(dword_845615C + 12) + 2 * a1) )
    {
      if ( v11[a1 + 1] != *v11 )
      {
        v11[a1 + 1] = *v11;
        sub_80A50FE(*(*(dword_845615C + 12) + 2 * a1), **(*(*(v12 + 1) + 4) + 12) + 16);
        *(*(dword_845615C + 12) + 2 * a1) = sub_80B9752(v12, dword_8456194, dword_8456198);
      }
    }
    else
    {
      v11[a1 + 1] = *v11;
      *(*(dword_845615C + 12) + 2 * a1) = sub_80B9752(v12, dword_8456194, dword_8456198);
    }
    v5 = sub_80A4458(*(*(dword_845615C + 12) + 2 * a1));
    result = sub_80BAB1C(
               *(v12 + 1),
               v5,
               a2,
               a3,
               *&dword_843414C[17 * *(dword_8456158 + 2 * a1 + 12) + 7 * dword_8456180]);
  }
  return result;
}
// 843414C: using guessed type int dword_843414C[];
// 8456158: using guessed type int dword_8456158;
// 845615C: using guessed type int dword_845615C;
// 8456180: using guessed type int dword_8456180;
// 8456184: using guessed type int dword_8456184;
// 8456188: using guessed type int dword_8456188;
// 8456194: using guessed type int dword_8456194;
// 8456198: using guessed type int dword_8456198;

//----- (080BE3CA) --------------------------------------------------------
void __cdecl sub_80BE3CA(int *a1, int a2, int a3)
{
  const char *v3; // eax
  const char *v4; // eax
  double v5; // [esp+40h] [ebp-48h]
  const char *v6; // [esp+4Ch] [ebp-3Ch]
  double v7; // [esp+50h] [ebp-38h]
  const char *v8; // [esp+58h] [ebp-30h]
  float v9; // [esp+5Ch] [ebp-2Ch]
  float v10; // [esp+64h] [ebp-24h]
  int v11; // [esp+68h] [ebp-20h]
  float *v12; // [esp+70h] [ebp-18h]
  unsigned __int16 *v13; // [esp+74h] [ebp-14h]
  unsigned __int16 *v14; // [esp+78h] [ebp-10h]
  unsigned __int16 v15; // [esp+7Eh] [ebp-Ah]
  int v16; // [esp+80h] [ebp-8h]
  int i; // [esp+84h] [ebp-4h]
  int j; // [esp+84h] [ebp-4h]

  v15 = *(a1 + a2 + 6);
  if ( v15 )
  {
    v14 = (*a1 + 8 * a2 + 8);
    v16 = *v14;
    v13 = (&unk_8434140 + 68 * v15);
    v12 = &v13[14 * dword_8456180 + 6];
    if ( *&v13[14 * dword_8456180 + 16] != 0.0 )
    {
      for ( i = 0; i < a3; ++i )
        Com_Printf(" ");
      if ( v16 )
      {
        if ( dword_8456180 && v13[2] )
        {
          if ( sub_80C0AC4(*a1, a2) )
          {
            if ( *v13 )
            {
              v6 = sub_80A4458(v13[2]);
              if ( (v13[1] & 0x8000u) != 0 )
                v5 = 1.0;
              else
                v5 = *(*(*(*(*a1 + 8 * *v13 + 12) + 4) + 20) + 8 * v13[1] + 4);
              Com_Printf(
                "(index) %d: (weight) %f -> %f, (time) %f -> %f, '%s', (%f)\n",
                a2,
                v12[5],
                v12[4],
                v12[1],
                *v12,
                v6,
                v5);
            }
            else
            {
              v3 = sub_80A4458(v13[2]);
              Com_Printf("(index) %d: (weight) %f -> %f, (time) %f -> %f, '%s'\n", a2, v12[5], v12[4], v12[1], *v12, v3);
            }
          }
          else
          {
            v4 = sub_80A4458(v13[2]);
            Com_Printf("(index) %d: (weight) %f -> %f, '%s'\n", a2, v12[5], v12[4], v4);
          }
        }
        else if ( sub_80C0AC4(*a1, a2) )
        {
          Com_Printf("(index) %d: (weight) %f -> %f, (time) %f -> %f\n", a2, v12[5], v12[4], v12[1], *v12);
        }
        else
        {
          Com_Printf("(index) %d: (weight) %f -> %f\n", a2, v12[5], v12[4]);
        }
        for ( j = 0; j < v16; ++j )
          sub_80BE3CA(a1, j + v14[3], a3 + 1);
      }
      else
      {
        v11 = *(*(v14 + 1) + 4);
        v10 = *v12 - v12[1];
        if ( v10 < 0.0 )
          v10 = v10 + 1.0;
        if ( *(v11 + 8) == 0.0 )
          v9 = 0.0;
        else
          v9 = v10 / *(v11 + 8);
        if ( dword_8456180 && v13[2] )
        {
          v8 = sub_80A4458(v13[2]);
          if ( (v13[1] & 0x8000u) != 0 )
            v7 = 1.0;
          else
            v7 = *(*(*(*(v14 + 1) + 4) + 20) + 8 * v13[1] + 4);
          Com_Printf(
            "(name) %s: (weight) %f -> %f, (time) %f -> %f, (realtimedelta) %f, '%s' (%f)\n",
            **(v14 + 1),
            v12[5],
            v12[4],
            v12[1],
            *v12,
            v9,
            v8,
            v7);
        }
        else
        {
          Com_Printf(
            "(name) %s: (weight) %f -> %f, (time) %f -> %f, (realtimedelta) %f\n",
            **(v14 + 1),
            v12[5],
            v12[4],
            v12[1],
            *v12,
            v9);
        }
      }
    }
  }
}
// 8456180: using guessed type int dword_8456180;

//----- (080BE810) --------------------------------------------------------
void __cdecl sub_80BE810(int a1, int a2, float a3, int a4, int a5, int a6)
{
  float v6; // [esp+24h] [ebp-74h]
  char *v7; // [esp+28h] [ebp-70h]
  float v8; // [esp+2Ch] [ebp-6Ch]
  float v9; // [esp+30h] [ebp-68h]
  float v10; // [esp+34h] [ebp-64h]
  float v11; // [esp+34h] [ebp-64h]
  float *v12; // [esp+38h] [ebp-60h]
  int v13; // [esp+40h] [ebp-58h]
  unsigned __int16 *v14; // [esp+48h] [ebp-50h]
  unsigned __int16 v15; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v16; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v17; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v18; // [esp+4Eh] [ebp-4Ah]
  char v19; // [esp+50h] [ebp-48h] BYREF
  float v20; // [esp+70h] [ebp-28h]
  int v21; // [esp+74h] [ebp-24h]
  int v22; // [esp+78h] [ebp-20h]
  int j; // [esp+7Ch] [ebp-1Ch]
  int i; // [esp+80h] [ebp-18h]
  float v25; // [esp+84h] [ebp-14h]
  float v26; // [esp+88h] [ebp-10h]
  unsigned __int8 v27; // [esp+8Eh] [ebp-Ah]
  unsigned __int8 v28; // [esp+8Fh] [ebp-9h]

  v28 = a5;
  v27 = a6;
  v14 = (*a1 + 8 * a2 + 8);
  v22 = *v14;
  if ( v22 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v22 )
      {
        if ( v28 )
        {
          *a4 = 0;
          *(a4 + 4) = 0;
          *(a4 + 8) = 0;
          *(a4 + 12) = 0;
          *(a4 + 16) = 0;
          *(a4 + 20) = 0;
        }
        return;
      }
      v16 = *(a1 + 2 * (i + v14[3]) + 12);
      if ( v16 )
      {
        v9 = dword_84561A0 ? *(&unk_843415C + 17 * v16 + 7 * dword_8456180) : *(&unk_8434160
                                                                              + 17 * v16
                                                                              + 7 * dword_8456180);
        v25 = v9;
        if ( v9 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v22 )
      {
        sub_80BE810(a1, i + v14[3], a3, a4, v28, v27);
        return;
      }
      v17 = *(a1 + 2 * (j + v14[3]) + 12);
      if ( v17 )
      {
        v8 = dword_84561A0 ? *(&unk_843415C + 17 * v17 + 7 * dword_8456180) : *(&unk_8434160
                                                                              + 17 * v17
                                                                              + 7 * dword_8456180);
        v26 = v8;
        if ( v8 != 0.0 )
          break;
      }
    }
    if ( v28 )
      v7 = a4;
    else
      v7 = &v19;
    v21 = v7;
    sub_80BE810(a1, i + v14[3], v25, v7, 1, 1);
    sub_80BE810(a1, j + v14[3], v26, v21, 0, 1);
    ++j;
    while ( j < v22 )
    {
      v18 = *(a1 + 2 * (j + v14[3]) + 12);
      if ( v18 )
      {
        v6 = dword_84561A0 ? *(&unk_843415C + 17 * v18 + 7 * dword_8456180) : *(&unk_8434160
                                                                              + 17 * v18
                                                                              + 7 * dword_8456180);
        v26 = v6;
        if ( v6 != 0.0 )
          sub_80BE810(a1, j + v14[3], v26, v21, 0, 1);
      }
      ++j;
    }
    if ( v27 )
    {
      if ( v28 )
      {
        v20 = *a4 * *a4 + *(a4 + 4) * *(a4 + 4);
        if ( v20 != 0.0 )
        {
          v10 = sqrt(v20);
          v20 = a3 / v10;
          *a4 = *a4 * v20;
          *(a4 + 4) = *(a4 + 4) * v20;
        }
        if ( *(a4 + 8) != 0.0 )
        {
          v20 = a3 / *(a4 + 8);
          *(a4 + 8) = a3;
          *(a4 + 12) = *(a4 + 12) * v20;
          *(a4 + 16) = *(a4 + 16) * v20;
          *(a4 + 20) = *(a4 + 20) * v20;
        }
      }
      else
      {
        v20 = *v21 * *v21 + *(v21 + 4) * *(v21 + 4);
        if ( v20 != 0.0 )
        {
          v11 = sqrt(v20);
          v20 = a3 / v11;
          *a4 = *v21 * v20 + *a4;
          *(a4 + 4) = *(v21 + 4) * v20 + *(a4 + 4);
        }
        if ( *(v21 + 8) != 0.0 )
        {
          v20 = a3 / *(v21 + 8);
          *(a4 + 8) = *(a4 + 8) + a3;
          *(a4 + 12) = *(v21 + 12) * v20 + *(a4 + 12);
          *(a4 + 16) = *(v21 + 16) * v20 + *(a4 + 16);
          *(a4 + 20) = *(v21 + 20) * v20 + *(a4 + 20);
        }
      }
    }
    else if ( *(a4 + 8) != 0.0 )
    {
      v20 = 1.0 / *(a4 + 8);
      *(a4 + 12) = *(a4 + 12) * v20;
      *(a4 + 16) = *(a4 + 16) * v20;
      *(a4 + 20) = *(a4 + 20) * v20;
    }
  }
  else
  {
    if ( v28 )
    {
      *a4 = 0;
      *(a4 + 4) = 0;
      *(a4 + 8) = 0;
      *(a4 + 12) = 0;
      *(a4 + 16) = 0;
      *(a4 + 20) = 0;
    }
    v13 = *(*(v14 + 1) + 4);
    if ( *(v13 + 3) )
    {
      v15 = *(a1 + 2 * a2 + 12);
      if ( v15 )
      {
        v12 = (&unk_8434140 + 68 * v15 + 28 * dword_8456180 + 12);
        if ( byte_845619C )
          sub_80BB5D0(v13, a3, a4, *v12);
        else
          sub_80BB40A(v13, a3, a4, v12[1], *v12);
      }
    }
  }
}
// 8456180: using guessed type int dword_8456180;
// 845619C: using guessed type char byte_845619C;
// 84561A0: using guessed type int dword_84561A0;

//----- (080BEEF2) --------------------------------------------------------
long double __cdecl sub_80BEEF2(int a1, int a2)
{
  return **(*(a1 + 8 * a2 + 12) + 4) / *(*(*(a1 + 8 * a2 + 12) + 4) + 4);
}

//----- (080BEF30) --------------------------------------------------------
long double __cdecl sub_80BEF30(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-4h]

  if ( *(a1 + 2 * a2 + 12) )
    v3 = *&dword_843414C[17 * *(a1 + 2 * a2 + 12) + 7 * dword_8456180];
  else
    v3 = 0.0;
  return v3;
}
// 843414C: using guessed type int dword_843414C[];
// 8456180: using guessed type int dword_8456180;

//----- (080BEF88) --------------------------------------------------------
long double __cdecl sub_80BEF88(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-4h]

  if ( *(a1 + 2 * a2 + 12) )
    v3 = *(&unk_8434160 + 17 * *(a1 + 2 * a2 + 12) + 7 * dword_8456180);
  else
    v3 = 0.0;
  return v3;
}
// 8456180: using guessed type int dword_8456180;

//----- (080BEFE0) --------------------------------------------------------
int __cdecl sub_80BEFE0(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-10h]
  int v5; // [esp+8h] [ebp-8h]
  unsigned __int16 v6; // [esp+Eh] [ebp-2h]

  v6 = *(a1 + 2 * a2 + 12);
  if ( !v6 )
    return 1;
  v3 = 0;
  if ( *&dword_8434150[17 * v6 + 7 * dword_8456180] > *&dword_843414C[17 * v6 + 7 * dword_8456180]
    || *&dword_843414C[17 * v6 + 7 * dword_8456180] == 1.0
    || (v5 = 28 * dword_8456180 + 68 * v6 + 138625356, *(v5 + 8) > *(v5 + 10)) )
  {
    v3 = 1;
  }
  return v3;
}
// 843414C: using guessed type int dword_843414C[];
// 8434150: using guessed type int dword_8434150[];
// 8456180: using guessed type int dword_8456180;

//----- (080BF082) --------------------------------------------------------
int __cdecl sub_80BF082(int a1, int a2)
{
  return *(a1 + 8 * a2 + 8);
}

//----- (080BF092) --------------------------------------------------------
int __cdecl sub_80BF092(int a1, int a2, int a3)
{
  return a3 + *(a1 + 8 * a2 + 14);
}

//----- (080BF0A6) --------------------------------------------------------
const char *__cdecl sub_80BF0A6(int a1, int a2)
{
  const char *v3; // [esp+0h] [ebp-8h]

  if ( *(a1 + 8 * a2 + 8) )
    v3 = "<non-leaf anim>";
  else
    v3 = **(a1 + 8 * a2 + 12);
  return v3;
}

//----- (080BF0DE) --------------------------------------------------------
int __cdecl sub_80BF0DE(int a1)
{
  return *a1;
}

//----- (080BF0E8) --------------------------------------------------------
int __cdecl sub_80BF0E8(int a1)
{
  return *(a1 + 4);
}

//----- (080BF0F4) --------------------------------------------------------
int __cdecl sub_80BF0F4(int *a1)
{
  int result; // eax

  result = a1;
  if ( *a1 )
  {
    dword_8456158 = *a1;
    result = sub_80BC94E(0);
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;

//----- (080BF11C) --------------------------------------------------------
void __cdecl sub_80BF11C(int *a1, float a2)
{
  if ( *a1 )
  {
    flt_8456190 = a2;
    dword_8456158 = *a1;
    sub_80BCC1E(0);
  }
}
// 8456158: using guessed type int dword_8456158;
// 8456190: using guessed type float flt_8456190;

//----- (080BF14C) --------------------------------------------------------
void __cdecl sub_80BF14C(int a1, float a2)
{
  dword_84567C0 = 0;
  if ( *a1 )
  {
    word_845618C = *(a1 + 18);
    flt_8456190 = a2;
    dword_8456158 = *a1;
    sub_80BC456(0, a2, 1);
  }
}
// 8456158: using guessed type int dword_8456158;
// 845618C: using guessed type __int16 word_845618C;
// 8456190: using guessed type float flt_8456190;
// 84567C0: using guessed type int dword_84567C0;

//----- (080BF1A2) --------------------------------------------------------
int __cdecl sub_80BF1A2(int a1, float a2, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]
  float v6; // [esp+14h] [ebp-4h]

  if ( !*a1 )
    return 0;
  word_845618C = *(a1 + 18);
  dword_8456158 = *a1;
  if ( a3 )
  {
    v6 = sub_80BD01A(0, a2);
    if ( v6 == 1.0 || (v5 = a2 * v6 + 0.001, a2 < v5) )
    {
      sub_80BD884(0, a2, 1);
      v4 = 0;
    }
    else
    {
      sub_80BD884(0, v5, 1);
      v4 = 1;
    }
  }
  else
  {
    sub_80BD884(0, a2, 0);
    v4 = 0;
  }
  return v4;
}
// 8456158: using guessed type int dword_8456158;
// 845618C: using guessed type __int16 word_845618C;

//----- (080BF2A8) --------------------------------------------------------
int *__cdecl sub_80BF2A8(int a1, int a2)
{
  int *result; // eax
  char v3; // [esp+1Bh] [ebp-2Dh]
  int v4; // [esp+20h] [ebp-28h]
  __int16 *v5; // [esp+24h] [ebp-24h]
  __int16 ***v6; // [esp+28h] [ebp-20h]
  int j; // [esp+2Ch] [ebp-1Ch]
  float *v8; // [esp+30h] [ebp-18h]
  int *v9; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h] BYREF

  result = *(a1 + 4);
  v9 = result;
  v3 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    dword_8456160[i] = v9[i] | ~*(a2 + 4 * i);
    if ( dword_8456160[i] != -1 )
      v3 = 0;
    result = &i;
  }
  if ( !v3 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      v9[i] |= *(a2 + 4 * i);
      *&dword_8456170[4 * i] = dword_8456160[i];
    }
    dword_845615C = a1;
    dword_8456158 = *a1;
    dword_8456198 = *(a1 + 22);
    dword_8456194 = a1 + 28;
    dword_8456184 = *(a1 + 23);
    v8 = &v9[16 * dword_8456184 + 12];
    if ( dword_8456158 )
    {
      dword_8456188 = 32 * dword_8456184;
      byte_845617F |= 0x80u;
      sub_80BDBDC(0, 1.0, v8, 1, 0);
    }
    v4 = 0;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= dword_8456198 )
        break;
      v6 = *(**(*(dword_8456194 + 4 * j) + 4) + 4);
      i = *(v6 + 2);
      while ( i )
      {
        if ( ((*(dword_8456160 + (v4 >> 3)) >> (v4 & 7)) & 1) == 0 )
        {
          *v8 = 0.0;
          v8[1] = 0.0;
          v8[2] = 0.0;
          v8[3] = 1.0;
          v8[7] = 0.0;
          v8[6] = 0.0;
          v8[5] = 0.0;
        }
        --i;
        v8 += 8;
        ++v4;
      }
      v5 = v6[3];
      i = ***v6 - *(v6 + 2);
      while ( i )
      {
        if ( ((*(dword_8456160 + (v4 >> 3)) >> (v4 & 7)) & 1) == 0 )
        {
          *v8 = *v5 * 0.000030518509;
          v8[1] = v5[1] * 0.000030518509;
          v8[2] = v5[2] * 0.000030518509;
          v8[3] = v5[3] * 0.000030518509;
          v8[7] = 0.0;
          v8[6] = 0.0;
          v8[5] = 0.0;
        }
        --i;
        v8 += 8;
        ++v4;
        v5 += 4;
      }
    }
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;
// 845615C: using guessed type int dword_845615C;
// 8456160: using guessed type int dword_8456160[];
// 845617F: using guessed type char byte_845617F;
// 8456184: using guessed type int dword_8456184;
// 8456188: using guessed type int dword_8456188;
// 8456194: using guessed type int dword_8456194;
// 8456198: using guessed type int dword_8456198;

//----- (080BF59A) --------------------------------------------------------
void __cdecl sub_80BF59A(int **a1)
{
  if ( *a1 )
  {
    sub_80BE3CA(*a1, 0, 0);
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("NO TREE\n");
  }
}

//----- (080BF5E2) --------------------------------------------------------
int __cdecl sub_80BF5E2(int a1, int a2, float *a3, _DWORD *a4, int a5)
{
  int result; // eax
  int v6; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int v10; // [esp+34h] [ebp-14h]

  byte_845619C = 0;
  dword_84561A0 = a5;
  sub_80BE810(a1, a2, 1.0, &v6, 1, 0);
  if ( *&v6 == 0.0 || v7 == 0.0 )
  {
    *a3 = 0.0;
    a3[1] = 1.0;
  }
  else
  {
    *a3 = *&v6;
    a3[1] = v7;
  }
  *a4 = v8;
  a4[1] = v9;
  result = v10;
  a4[2] = v10;
  return result;
}
// 845619C: using guessed type char byte_845619C;
// 84561A0: using guessed type int dword_84561A0;

//----- (080BF696) --------------------------------------------------------
int __cdecl sub_80BF696(int a1, int a2, float *a3, _DWORD *a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]

  byte_845619C = 1;
  dword_84561A0 = 1;
  sub_80BE810(a1, a2, 1.0, &v5, 1, 0);
  if ( *&v5 == 0.0 && v6 == 0.0 )
  {
    *a3 = 0.0;
    a3[1] = 1.0;
  }
  else
  {
    *a3 = *&v5;
    a3[1] = v6;
  }
  *a4 = v7;
  a4[1] = v8;
  result = v9;
  a4[2] = v9;
  return result;
}
// 845619C: using guessed type char byte_845619C;
// 84561A0: using guessed type int dword_84561A0;

//----- (080BF74A) --------------------------------------------------------
int __cdecl sub_80BF74A(int a1, int a2, int a3, int a4, float a5, float a6)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+30h] [ebp-28h] BYREF
  float v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]

  if ( *(a1 + 8 * a2 + 8) || (v7 = *(*(a1 + 8 * a2 + 12) + 4), !*(v7 + 3)) )
  {
    *a3 = 0;
    *(a3 + 4) = 1065353216;
    *a4 = 0;
    *(a4 + 4) = 0;
    result = a4 + 8;
    *(a4 + 8) = 0;
  }
  else
  {
    *&v8 = 0.0;
    v9 = 0.0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    sub_80BB40A(v7, 1.0, &v8, a5, a6);
    if ( *&v8 == 0.0 && v9 == 0.0 )
    {
      *a3 = 0;
      *(a3 + 4) = 1065353216;
    }
    else
    {
      *a3 = *&v8;
      *(a3 + 4) = v9;
    }
    *a4 = v11;
    *(a4 + 4) = v12;
    result = v13;
    *(a4 + 8) = v13;
  }
  return result;
}

//----- (080BF888) --------------------------------------------------------
int __cdecl sub_80BF888(int a1, int a2, int a3, int a4, float a5)
{
  int result; // eax
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+20h] [ebp-28h] BYREF
  float v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]

  if ( *(a1 + 8 * a2 + 8) || (v6 = *(*(a1 + 8 * a2 + 12) + 4), !*(v6 + 3)) )
  {
    *a3 = 0;
    *(a3 + 4) = 1065353216;
    *a4 = 0;
    *(a4 + 4) = 0;
    result = a4 + 8;
    *(a4 + 8) = 0;
  }
  else
  {
    *&v7 = 0.0;
    v8 = 0.0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    sub_80BB5D0(v6, 1.0, &v7, a5);
    if ( *&v7 == 0.0 && v8 == 0.0 )
    {
      *a3 = 0;
      *(a3 + 4) = 1065353216;
    }
    else
    {
      *a3 = *&v7;
      *(a3 + 4) = v8;
    }
    *a4 = v10;
    *(a4 + 4) = v11;
    result = v12;
    *(a4 + 8) = v12;
  }
  return result;
}

//----- (080BF9BE) --------------------------------------------------------
int __cdecl sub_80BF9BE(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = word_843414A[0];
  if ( !word_843414A[0] )
    sub_80704AC(1, &byte_80EA400);
  if ( ++dword_84567C4 > dword_84567C8 )
    dword_84567C8 = dword_84567C4;
  ++*(a1 + 4);
  word_843414A[0] = word_843414A[34 * v3];
  word_8434148[34 * word_843414A[0]] = 0;
  *(a1 + 2 * a2 + 12) = v3;
  return 68 * v3 + 138625344;
}
// 8434148: using guessed type __int16 word_8434148[];
// 843414A: using guessed type __int16 word_843414A[];
// 84567C4: using guessed type int dword_84567C4;
// 84567C8: using guessed type int dword_84567C8;

//----- (080BFA7C) --------------------------------------------------------
int __cdecl sub_80BFA7C(_DWORD *a1, int a2)
{
  while ( a2 )
  {
    a2 = *(*a1 + 8 * a2 + 10);
    if ( *(&unk_8434160 + 17 * *(a1 + a2 + 6) + 7 * dword_8456180) == 0.0 )
      return 0;
  }
  return 1;
}
// 8456180: using guessed type int dword_8456180;

//----- (080BFAFC) --------------------------------------------------------
int __cdecl sub_80BFAFC(_DWORD *a1, int a2)
{
  int i; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  unsigned __int16 *v6; // [esp+14h] [ebp-8h]
  unsigned __int16 v7; // [esp+1Ah] [ebp-2h]

  v7 = *(a1 + a2 + 6);
  if ( !v7 )
    return 0;
  if ( *(&unk_8434160 + 17 * v7 + 7 * dword_8456180) == 0.0 )
    return 0;
  v6 = (*a1 + 8 * a2 + 8);
  v5 = *v6;
  if ( !*v6 )
    return 1;
  for ( i = 0; i < v5; ++i )
  {
    if ( sub_80BFAFC(a1, i + v6[3]) )
      return 1;
  }
  return 0;
}
// 8456180: using guessed type int dword_8456180;

//----- (080BFBDC) --------------------------------------------------------
int __cdecl sub_80BFBDC(_DWORD *a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( sub_80BFA7C(a1, a2) && sub_80BFAFC(a1, a2) )
    v3 = 1;
  return v3;
}

//----- (080BFC22) --------------------------------------------------------
void __cdecl sub_80BFC22(_DWORD *a1, int a2, float a3)
{
  int v3; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *(a1 + a2 + 6);
  if ( v5 )
  {
    v4 = &unk_8434140 + 68 * v5;
    v3 = &v4[28 * dword_8456180 + 12];
    if ( sub_80BFBDC(a1, a2) )
    {
      if ( *(v3 + 16) == 0.0 )
      {
        if ( *(v3 + 12) > a3 )
          *(v3 + 12) = a3;
      }
      else
      {
        *(v3 + 16) = 0;
        *(v3 + 12) = a3;
      }
    }
    else
    {
      *(v3 + 20) = 0;
      *(v3 + 12) = 0;
      *(v3 + 16) = 0;
    }
    if ( dword_8456180 )
      sub_80BCEB6(v4);
  }
}
// 8456180: using guessed type int dword_8456180;

//----- (080BFD0C) --------------------------------------------------------
int __cdecl sub_80BFD0C(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = a2;
  if ( *(a1 + a2 + 6) )
  {
    sub_80BFC22(a1, a2, a3);
    v4 = (*a1 + 8 * a2 + 8);
    v6 = *v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v6 )
        break;
      sub_80BFD0C(a1, i + v4[3], LODWORD(a3));
    }
  }
  return result;
}

//----- (080BFD90) --------------------------------------------------------
int __cdecl sub_80BFD90(int a1, int a2, float a3)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  return sub_80BFD0C(a1, a2, a3);
}

//----- (080BFDCA) --------------------------------------------------------
int __cdecl sub_80BFDCA(int a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v4 = (*a1 + 8 * a2 + 8);
  v6 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    sub_80BFD0C(a1, i + v4[3], a3);
  }
  return result;
}

//----- (080BFE3E) --------------------------------------------------------
int __cdecl sub_80BFE3E(int a1, int a2, float a3, float a4)
{
  int result; // eax
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  unsigned __int16 v8; // [esp+22h] [ebp-26h]
  float v9; // [esp+28h] [ebp-20h]
  float v10; // [esp+30h] [ebp-18h]
  unsigned __int16 *v11; // [esp+38h] [ebp-10h]
  int v12; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  int j; // [esp+44h] [ebp-4h]

  if ( a2 )
  {
    v11 = (*a1 + 8 * *(*a1 + 8 * a2 + 10) + 8);
    v9 = 0.0;
    v12 = *v11;
    for ( i = 0; i < v12; ++i )
    {
      v8 = *(a1 + 2 * (i + v11[3]) + 12);
      if ( v8 )
        v7 = *(&unk_8434160 + 17 * v8 + 7 * dword_8456180);
      else
        v7 = 0.0;
      if ( i + v11[3] == a2 )
      {
        v5 = a3 - v7;
        v6 = sub_80C1814(v5);
      }
      else
      {
        v6 = v7;
      }
      if ( v6 > v9 )
        v9 = v6;
    }
    v10 = v9 * a4;
    if ( v10 < 0.001 )
      v10 = 0.0;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v12 )
        break;
      if ( j + v11[3] != a2 )
        sub_80BFC22(a1, j + v11[3], v10);
    }
  }
  return result;
}
// 8456180: using guessed type int dword_8456180;

//----- (080BFFBC) --------------------------------------------------------
float *__cdecl sub_80BFFBC(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BFE3E(a1, a2, a3, a4);
  return sub_80C11FA(a1, a2, a3, SLODWORD(a4), a5, a6, a7, a8);
}

//----- (080C004A) --------------------------------------------------------
int __cdecl sub_80C004A(int a1, int a2, int a3, float a4, float a5, int a6, int a7, int a8, int a9)
{
  int v11; // [esp+20h] [ebp-8h]

  dword_8456158 = a1;
  if ( a4 < 0.001 )
    a4 = 0.0;
  sub_80BFE3E(a1, a2, a4, a5);
  v11 = sub_80C05A2(a2, a4, SLODWORD(a5), a6, 0, a7, a8);
  sub_80C0FFA(a2, SLODWORD(a5));
  sub_80C0E0E(a2, a9);
  if ( dword_8456180 )
  {
LABEL_4:
    sub_80C0C90(a2);
    goto LABEL_5;
  }
  while ( 1 )
  {
LABEL_5:
    if ( !a2 )
      return 1;
    a2 = *(*a1 + 8 * a2 + 10);
    if ( a2 == a3 )
      return v11;
    sub_80BFE3E(a1, a2, 1.0, a5);
    sub_80C05A2(a2, 1.0, SLODWORD(a5), 1065353216, 0, 0, 0);
    sub_80C0E0E(a2, a9);
    if ( dword_8456180 )
      goto LABEL_4;
  }
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C01D6) --------------------------------------------------------
int __cdecl sub_80C01D6(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80BFE3E(a1, a2, a3, a4);
  return sub_80C1072(a1, a2, a3, SLODWORD(a4), a5, a6, a7, a8);
}

//----- (080C0264) --------------------------------------------------------
int __cdecl sub_80C0264(int a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v4 = (*a1 + 8 * a2 + 8);
  v5 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    sub_80BFC22(a1, i + v4[3], a3);
  }
  return result;
}

//----- (080C02D8) --------------------------------------------------------
int __cdecl sub_80C02D8(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = *(a1 + a2 + 6);
  v4 = *(a1 + a2 + 6);
  if ( v4 )
  {
    v3 = (*a1 + 8 * a2 + 8);
    v6 = *v3;
    for ( i = 0; i < v6; ++i )
      sub_80C02D8(a1, i + v3[3]);
    sub_80BB6AE(a1, v4);
    result = a2;
    *(a1 + a2 + 6) = 0;
  }
  return result;
}

//----- (080C0364) --------------------------------------------------------
int *__cdecl sub_80C0364(_DWORD *a1)
{
  int *result; // eax
  int i; // [esp+20h] [ebp-18h] BYREF
  int j; // [esp+24h] [ebp-14h]
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+2Ch] [ebp-Ch]
  int v6; // [esp+30h] [ebp-8h]
  int v7; // [esp+34h] [ebp-4h]

  sub_80C02D8(a1, 0);
  v5 = *(*a1 + 4);
  v6 = 2 * v5 + 12;
  v7 = 3 * v5 + 1;
  result = (a1 + v6);
  v4 = a1 + v6;
  for ( i = 2; i; --i )
  {
    for ( j = *(*a1 + 4) - 1; j >= 0; --j )
    {
      if ( *(v4 + 2 * j) )
      {
        sub_80A50FE(*(v4 + 2 * j), **(*(*(*a1 + 8 * j + 12) + 4) + 12) + 16);
        *(v4 + 2 * j) = 0;
      }
    }
    v4 = a1 + v6 + v7;
    result = &i;
  }
  return result;
}

//----- (080C0456) --------------------------------------------------------
int __cdecl sub_80C0456(int a1)
{
  int result; // eax

  *(a1 + 40) = 0;
  *(a1 + 48) = 0;
  *(a1 + 44) = 0;
  result = a1 + 40;
  *(a1 + 50) = 0;
  return result;
}

//----- (080C048C) --------------------------------------------------------
int __cdecl sub_80C048C(int a1)
{
  int result; // eax

  *(a1 + 12) = 0;
  *(a1 + 20) = 0;
  *(a1 + 16) = 0;
  result = a1 + 12;
  *(a1 + 22) = 0;
  return result;
}

//----- (080C04C2) --------------------------------------------------------
int __cdecl sub_80C04C2(int a1)
{
  unsigned __int16 *v3; // [esp+8h] [ebp-18h]
  int i; // [esp+Ch] [ebp-14h]
  int v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+14h] [ebp-Ch]
  float v7; // [esp+18h] [ebp-8h]
  float v8; // [esp+1Ch] [ebp-4h]

  v3 = (*dword_8456158 + 8 * a1 + 8);
  if ( !*v3 )
    return a1;
  v8 = 0.0;
  v5 = 0;
  for ( i = 0; i < *v3; ++i )
  {
    v7 = *(&unk_843415C + 17 * *(dword_8456158 + 2 * (i + v3[3]) + 12) + 7 * dword_8456180);
    if ( v8 < v7 )
    {
      v6 = sub_80C04C2(i + v3[3]);
      if ( v6 )
      {
        v8 = v7;
        v5 = v6;
      }
    }
  }
  return v5;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C05A2) --------------------------------------------------------
int __cdecl sub_80C05A2(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  float *v7; // eax
  float v9; // [esp+0h] [ebp-28h]
  float *v11; // [esp+14h] [ebp-14h]
  _WORD *v12; // [esp+18h] [ebp-10h]
  unsigned __int16 v13; // [esp+1Ch] [ebp-Ch]

  v13 = *(dword_8456158 + 2 * a1 + 12);
  if ( v13 )
  {
    v12 = (&unk_8434140 + 68 * v13);
    if ( dword_8456180 && v12[2] )
      sub_80A509E(v12[2]);
LABEL_9:
    if ( !a1 )
    {
      a2 = 1.0;
      *&a3 = 0.0;
      a4 = 1065353216;
    }
    v7 = &v12[14 * dword_8456180];
    v11 = v7 + 3;
    v7[7] = a2;
    v9 = a2 - v7[8];
    v7[6] = sub_80C1814(v9) * *&a3;
    if ( v11[3] >= 0.001 )
    {
      if ( v11[5] == 0.0 )
        v11[5] = a2 * 0.001;
    }
    else
    {
      v11[3] = 0.0;
      v11[5] = a2;
    }
    *&v12[14 * dword_8456180 + 18] = a4;
    if ( dword_8456180 )
    {
      v12[2] = a6;
      if ( a6 )
        sub_80A4F00(a6);
      v12[1] = -1;
      if ( a6 && *(*dword_8456158 + 8 * a1 + 8) && (*(*dword_8456158 + 8 * a1 + 12) & 3) != 0 )
      {
        *v12 = sub_80C04C2(a1);
        if ( !*v12 )
          return 2;
      }
      else
      {
        *v12 = 0;
      }
    }
    else
    {
      v12[3] = a7;
    }
    return 0;
  }
  if ( a2 != 0.0 || a5 )
  {
    v12 = sub_80BF9BE(dword_8456158, a1);
    sub_80C837D(v12 + 6, 0, 0x38u);
    v12[2] = 0;
    v12[1] = -1;
    *v12 = 0;
    v12[3] = 0;
    goto LABEL_9;
  }
  return 0;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C0804) --------------------------------------------------------
int __cdecl sub_80C0804(int a1, int a2)
{
  int result; // eax

  result = a2;
  dword_8434150[17 * *(dword_8456158 + 2 * a1 + 12) + 5 + 7 * dword_8456180] = a2;
  return result;
}
// 8434150: using guessed type int dword_8434150[];
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C0850) --------------------------------------------------------
int __cdecl sub_80C0850(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int result; // eax
  __int16 v4; // [esp+18h] [ebp-20h]
  __int16 v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 *v9; // [esp+30h] [ebp-8h]

  v9 = &a1[2 * a2 + 2];
  v8 = *v9;
  if ( *v9 )
  {
    if ( (a1[2 * a2 + 3] & 3) != 0 )
    {
      v6 = 0;
      do
      {
        ++v6;
        v9 = &a1[2 * v9[3] + 2];
      }
      while ( *v9 );
      sub_80704AC(1, &byte_80EA4E0, *a1, v6, **(v9 + 1));
    }
    v4 = a1[2 * a2 + 3];
    if ( a3 )
      v5 = v4 | 1;
    else
      v5 = v4 | 2;
    LOWORD(a1[2 * a2 + 3]) = v5;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v8 )
        break;
      sub_80C0850(a1, i + HIWORD(a1[2 * a2 + 3]), a3);
    }
  }
  else
  {
    result = *(*(a1[2 * a2 + 3] + 4) + 2);
    if ( result != a3 )
    {
      if ( a3 )
        sub_80704AC(1, &byte_80EA460, *a1[2 * a2 + 3], *a1);
      sub_80704AC(1, &byte_80EA4A0, *a1[2 * a2 + 3], *a1);
    }
  }
  return result;
}

//----- (080C09C8) --------------------------------------------------------
int __cdecl sub_80C09C8(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  result = LOWORD(a1[2 * a2 + 2]);
  v6 = result;
  if ( LOWORD(a1[2 * a2 + 2]) )
  {
    v3 = a1[2 * a2 + 3] & 3;
    if ( (a1[2 * a2 + 3] & 3) != 0 )
    {
      if ( v3 == 3 )
        sub_80704AC(1, &byte_80EA540);
      LOWORD(a1[2 * a2 + 3]) |= 4u;
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v6 )
          break;
        sub_80C0850(a1, i + HIWORD(a1[2 * a2 + 3]), v3 == 1);
      }
    }
    else
    {
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= v6 )
          break;
        sub_80C09C8(a1, j + HIWORD(a1[2 * a2 + 3]));
      }
    }
  }
  return result;
}

//----- (080C0AA8) --------------------------------------------------------
int __cdecl sub_80C0AA8(_DWORD *a1)
{
  return sub_80C09C8(a1, 0);
}

//----- (080C0AC4) --------------------------------------------------------
int __cdecl sub_80C0AC4(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( !*(a1 + 8 * a2 + 8) || (*(a1 + 8 * a2 + 12) & 3) != 0 )
    v3 = 1;
  return v3;
}

//----- (080C0B06) --------------------------------------------------------
_BOOL4 __cdecl sub_80C0B06(int a1, int a2)
{
  return *(a1 + 8 * a2 + 8) == 0;
}

//----- (080C0B1E) --------------------------------------------------------
char *__cdecl sub_80C0B1E(int a1, int a2, int a3)
{
  char *result; // eax
  char *v4; // eax
  unsigned __int16 v5; // [esp+Eh] [ebp-2h]

  result = *(a1 + 2 * a2 + 12);
  v5 = *(a1 + 2 * a2 + 12);
  if ( v5 )
  {
    v4 = &unk_8434140 + 68 * v5 + 28 * dword_8456180;
    *(v4 + 3) = a3;
    *(v4 + 10) = 0;
    *(v4 + 4) = a3;
    result = v4 + 12;
    *(result + 5) = 0;
  }
  return result;
}
// 8456180: using guessed type int dword_8456180;

//----- (080C0BA8) --------------------------------------------------------
int __cdecl sub_80C0BA8(int a1, int a2)
{
  int result; // eax

  *(a2 + 28 * dword_8456180 + 12) = *(a1 + 28 * dword_8456180 + 12);
  *(a2 + 28 * dword_8456180 + 20) = *(a1 + 28 * dword_8456180 + 20);
  *(a2 + 28 * dword_8456180 + 16) = *(a1 + 28 * dword_8456180 + 16);
  result = *(a1 + 28 * dword_8456180 + 22);
  *(a2 + 28 * dword_8456180 + 22) = result;
  return result;
}
// 8456180: using guessed type int dword_8456180;

//----- (080C0C82) --------------------------------------------------------
int __cdecl sub_80C0C82(int a1)
{
  int result; // eax

  result = a1;
  dword_8456180 = a1;
  return result;
}
// 8456180: using guessed type int dword_8456180;

//----- (080C0C90) --------------------------------------------------------
float *__cdecl sub_80C0C90(int a1)
{
  float *result; // eax
  _WORD *v2; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  v3 = (&unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
  result = v3;
  if ( *(v3 + 2) )
  {
    if ( v3[10] == 1.0 )
    {
      result = (&unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
      *(v3 + 1) = -1;
      return result;
    }
    v2 = (*dword_8456158 + 8 * a1 + 8);
    if ( *v2 )
    {
      result = (&unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
      if ( !*v3 )
        return result;
      v2 = (*dword_8456158 + 8 * *v3 + 8);
    }
    result = sub_80BBA7E(v2, v3, v3[10]);
    *(v3 + 1) = result;
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;

//----- (080C0D54) --------------------------------------------------------
int __cdecl sub_80C0D54(int a1, int a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+Ah] [ebp-Eh]
  int i; // [esp+Ch] [ebp-Ch]
  unsigned __int16 *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+20h] [ebp+8h]

  v5 = (*dword_8456158 + 8 * a1 + 8);
  for ( i = 0; ; ++i )
  {
    result = *v5;
    if ( i >= result )
      break;
    v6 = i + v5[3];
    v3 = *(dword_8456158 + 2 * v6 + 12);
    if ( v3 )
    {
      sub_80C0BA8(a2, &unk_8434140 + 68 * v3);
      if ( dword_8456180 )
        sub_80C0C90(v6);
      sub_80C0D54(v6, a2);
    }
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C0E0E) --------------------------------------------------------
int __cdecl sub_80C0E0E(int a1, int a2)
{
  int result; // eax
  _WORD *v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h]

  for ( i = a1; i; i = *(*dword_8456158 + 8 * i + 10) )
  {
    v5 = &unk_8434140 + 68 * *(dword_8456158 + 2 * i + 12);
    if ( *(*dword_8456158 + 8 * i + 8) && (*(*dword_8456158 + 8 * i + 12) & 4) != 0 )
    {
      if ( a2 || !sub_80BFBDC(dword_8456158, i) )
      {
        if ( dword_8456180 )
          sub_80C0456(v5);
        else
          sub_80C048C(v5);
      }
      sub_80C0D54(a1, v5);
      while ( 1 )
      {
        result = a1;
        if ( a1 == i )
          break;
        sub_80C0BA8(v5, &unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
        if ( dword_8456180 )
          sub_80C0C90(a1);
        a1 = *(*dword_8456158 + 8 * a1 + 10);
      }
      return result;
    }
  }
  v3 = (*dword_8456158 + 8 * a1 + 8);
  result = *v3;
  if ( !*v3 )
  {
    if ( a2 || (result = sub_80BFBDC(dword_8456158, a1), !result) )
    {
      if ( dword_8456180 )
        result = sub_80C0456(&unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
      else
        result = sub_80C048C(&unk_8434140 + 68 * *(dword_8456158 + 2 * a1 + 12));
    }
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C0FFA) --------------------------------------------------------
int __cdecl sub_80C0FFA(int a1, int a2)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  result = a1;
  for ( i = a1; i; result = sub_80C05A2(i, 0.0, a2, 1065353216, 1, 0, 0) )
  {
    i = *(*dword_8456158 + 8 * i + 10);
    result = i;
    if ( *(dword_8456158 + 2 * i + 12) )
      break;
  }
  return result;
}
// 8456158: using guessed type int dword_8456158;

//----- (080C1072) --------------------------------------------------------
int __cdecl sub_80C1072(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // [esp+20h] [ebp-8h]

  dword_8456158 = a1;
  if ( a3 < 0.001 )
    a3 = 0.0;
  v9 = sub_80C05A2(a2, a3, a4, a5, 0, a6, a7);
  sub_80C0FFA(a2, a4);
  sub_80C0E0E(a2, a8);
  if ( dword_8456180 )
    sub_80C0C90(a2);
  return v9;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C1120) --------------------------------------------------------
int __cdecl sub_80C1120(int a1, int a2, int a3)
{
  dword_8456158 = a1;
  return sub_80C0804(a2, a3);
}
// 8456158: using guessed type int dword_8456158;

//----- (080C1142) --------------------------------------------------------
int __cdecl sub_80C1142(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  if ( *(a1 + 8 * a2 + 8) )
    v3 = *(a1 + 8 * a2 + 12) & 1;
  else
    v3 = *(*(*(a1 + 8 * a2 + 12) + 4) + 2);
  return v3;
}

//----- (080C1186) --------------------------------------------------------
int __cdecl sub_80C1186(int a1, int a2, __int16 a3)
{
  _WORD *v5; // [esp+4h] [ebp-10h]

  v5 = *(*(*(a1 + 8 * a2 + 12) + 4) + 20);
  if ( !v5 )
    return 0;
  while ( *v5 )
  {
    if ( *v5 == a3 )
      return 1;
    v5 += 4;
  }
  return 0;
}

//----- (080C11FA) --------------------------------------------------------
float *__cdecl sub_80C11FA(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  float *result; // eax
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  dword_8456158 = a1;
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80C05A2(a2, a3, a4, a5, 0, a6, a7);
  v9 = a2;
  while ( v9 )
  {
    v9 = *(*a1 + 8 * v9 + 10);
    v10 = *(a1 + 2 * v9 + 12);
    if ( !v10 || *(&unk_843415C + 17 * v10 + 7 * dword_8456180) == 0.0 )
      sub_80C05A2(v9, 1.0, a4, 1065353216, 0, 0, 0);
  }
  result = sub_80C0E0E(a2, a8);
  if ( dword_8456180 )
    result = sub_80C0C90(a2);
  return result;
}
// 8456158: using guessed type int dword_8456158;
// 8456180: using guessed type int dword_8456180;

//----- (080C1340) --------------------------------------------------------
void __cdecl sub_80C1340(int a1)
{
  *a1 = sub_80A8F4E();
  *(a1 + 4) = sub_80A8F4E();
  *(a1 + 8) = sub_80A8E1C();
  *(a1 + 10) = sub_80A8E1C();
  *(a1 + 16) = sub_80A8F4E();
  *(a1 + 24) = sub_80A8F4E();
  *(a1 + 12) = sub_80A8F4E();
  *(a1 + 20) = sub_80A8F4E();
}

//----- (080C13A6) --------------------------------------------------------
int __cdecl sub_80C13A6(int a1)
{
  sub_80A8F32(*a1);
  sub_80A8F32(*(a1 + 4));
  sub_80A8DF8(*(a1 + 8));
  sub_80A8DF8(*(a1 + 10));
  sub_80A8F32(*(a1 + 16));
  sub_80A8F32(*(a1 + 24));
  sub_80A8F32(*(a1 + 12));
  return sub_80A8F32(*(a1 + 20));
}

//----- (080C1420) --------------------------------------------------------
void __cdecl sub_80C1420(_WORD *a1)
{
  __int16 v1; // [esp+Eh] [ebp-Ah]

  a1[1] = sub_80A8E1C();
  *a1 = sub_80A8E1C();
  a1[3] = sub_80A8E1C();
  if ( sub_80A8DDA() )
    v1 = sub_80A8EBC();
  else
    v1 = 0;
  a1[2] = v1;
  sub_80C1340((a1 + 6));
  sub_80C1340((a1 + 20));
}

//----- (080C1498) --------------------------------------------------------
int __cdecl sub_80C1498(unsigned __int16 *a1)
{
  sub_80A8DF8(a1[1]);
  sub_80A8DF8(*a1);
  sub_80A8DF8(a1[3]);
  if ( a1[2] )
  {
    sub_80A8DB8(1u);
    sub_80A8E3C(a1[2]);
  }
  else
  {
    sub_80A8DB8(0);
  }
  sub_80C13A6((a1 + 6));
  return sub_80C13A6((a1 + 20));
}

//----- (080C151C) --------------------------------------------------------
int __cdecl sub_80C151C(const void *a1, unsigned __int16 *a2)
{
  int result; // eax

  qmemcpy(a2, a1, 0x44u);
  result = a2;
  if ( a2[2] )
    result = sub_80A4F00(a2[2]);
  return result;
}

//----- (080C155C) --------------------------------------------------------
int __cdecl sub_80C155C(int a1)
{
  void *v1; // esp
  int result; // eax
  _WORD *v3; // [esp+8h] [ebp-10h] BYREF
  size_t n; // [esp+Ch] [ebp-Ch]
  void *dest; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  n = ((*(*a1 + 4) - 1) >> 3) + 1;
  v1 = alloca(16 * ((n + 15) >> 4));
  dest = &v3;
  sub_80A90F4(&v3, n);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(*a1 + 4) )
      break;
    if ( (((*(dest + (i >> 3)) >> (i & 7)) ^ 1) & 1) == 0 )
    {
      v3 = sub_80BF9BE(a1, i);
      sub_80C1420(v3);
    }
  }
  return result;
}

//----- (080C15FA) --------------------------------------------------------
unsigned int __cdecl sub_80C15FA(int a1)
{
  void *v1; // esp
  unsigned int result; // eax
  _BYTE v3[12]; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int16 *v4; // [esp+18h] [ebp-20h]
  unsigned __int16 v5; // [esp+1Eh] [ebp-1Ah]
  size_t n; // [esp+20h] [ebp-18h]
  void *s; // [esp+24h] [ebp-14h]
  unsigned int i; // [esp+28h] [ebp-10h]

  n = ((*(*a1 + 4) - 1) >> 3) + 1;
  v1 = alloca(16 * ((n + 15) >> 4));
  s = v3;
  sub_80C837D(v3, 0, n);
  for ( i = 0; i < *(*a1 + 4); ++i )
  {
    v5 = *(a1 + 2 * i + 12);
    if ( v5 )
      *(s + (i >> 3)) |= 1 << (i & 7);
  }
  sub_80A90C8(s, n);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(*a1 + 4) )
      break;
    v5 = *(a1 + 2 * i + 12);
    if ( v5 )
    {
      v4 = (&unk_8434140 + 68 * v5);
      sub_80C1498(v4);
    }
  }
  return result;
}

//----- (080C1716) --------------------------------------------------------
int __cdecl sub_80C1716(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  v3 = *(*a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(a1 + 2 * i + 12);
    if ( v5 )
    {
      if ( *(a2 + 2 * i + 12) )
      {
        v4 = (&unk_8434140 + 68 * *(a2 + 2 * i + 12));
        sub_80BB68C(v4);
      }
      else
      {
        v4 = sub_80BF9BE(a2, i);
      }
      sub_80C151C(&unk_8434140 + 68 * v5, v4);
    }
    else
    {
      v6 = *(a2 + 2 * i + 12);
      if ( v6 )
      {
        sub_80BB6AE(a2, v6);
        *(a2 + 2 * i + 12) = 0;
      }
    }
  }
  return result;
}

//----- (080C1814) --------------------------------------------------------
long double __cdecl sub_80C1814(float a1)
{
  return fabs(a1);
}

//----- (080C182E) --------------------------------------------------------
int __cdecl sub_80C182E(__int16 a1)
{
  return a1;
}

//----- (080C1844) --------------------------------------------------------
int __cdecl sub_80C1844(int a1)
{
  int result; // eax

  result = a1;
  dword_80F7330 = a1;
  return result;
}
// 80F7330: using guessed type int dword_80F7330;

//----- (080C1852) --------------------------------------------------------
_BOOL4 __cdecl sub_80C1852(int a1)
{
  return *(a1 + 4) == &unk_8456824;
}

//----- (080C1876) --------------------------------------------------------
int __cdecl sub_80C1876(__int16 *a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80C4E86(*a1);
  a2[1] = sub_80C4E86(a1[1]);
  a2[2] = sub_80C4E86(a1[2]);
  v5 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v5 <= 0 )
  {
    v4 = 0;
  }
  else
  {
    v2 = sqrt(v5);
    v4 = floor(v2 + 0.5);
  }
  result = v4;
  a2[3] = v4;
  return result;
}

//----- (080C1966) --------------------------------------------------------
int __cdecl sub_80C1966(__int16 *a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+1Ch] [ebp-Ch]

  *a2 = sub_80C4E86(*a1);
  v5 = 1073676289 - *a2 * *a2;
  if ( v5 <= 0 )
  {
    v4 = 0;
  }
  else
  {
    v2 = sqrt(v5);
    v4 = floor(v2 + 0.5);
  }
  result = v4;
  a2[1] = v4;
  return result;
}

//----- (080C19F4) --------------------------------------------------------
void sub_80C19F4()
{
  ;
}

//----- (080C19FA) --------------------------------------------------------
int __cdecl sub_80C19FA(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  __int16 *v4; // [esp+1Ch] [ebp-Ch]

  v4 = ***(a1 + 4);
  v2 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    sub_80A509E(v4[i + 1]);
  }
  return result;
}

//----- (080C1A5A) --------------------------------------------------------
int *__cdecl sub_80C1A5A(int a1)
{
  int *result; // eax
  int *v2; // [esp+Ch] [ebp-Ch]
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = *(a1 + 4);
  v2 = result;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v2[5 * i + 4] )
    {
      for ( j = 0; j < SLOWORD(v2[5 * i + 3]); ++j )
        sub_80A509E(*(v2[5 * i + 4] + 2 * j));
      v2[5 * i + 4] = 0;
    }
    result = &i;
  }
  return result;
}

//----- (080C1B12) --------------------------------------------------------
int __cdecl sub_80C1B12(int a1, int a2, __int16 **a3)
{
  __int16 v3; // ax
  int result; // eax

  v3 = sub_80C4E86(**a3);
  *(a1 + (v3 >> 3) + 8) |= 1 << (v3 & 7);
  *(a2 + 12) = v3 << 6;
  *a2 = sub_80C4EA2(*++*a3);
  *a3 += 2;
  *(a2 + 4) = sub_80C4EA2(**a3);
  *a3 += 2;
  *(a2 + 8) = sub_80C4EA2(**a3);
  result = (*a3 + 2);
  *a3 = result;
  return result;
}

//----- (080C1BDA) --------------------------------------------------------
int __cdecl sub_80C1BDA(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int j; // [esp+4h] [ebp-24h]
  int v5; // [esp+4h] [ebp-24h]
  int i; // [esp+8h] [ebp-20h]
  int *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  __int16 v9; // [esp+14h] [ebp-14h]
  __int16 v10; // [esp+14h] [ebp-14h]

  v7 = a1[2];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *a1 )
      break;
    v3 = *(a1[1] + i);
    v8 = *v7;
    v9 = *(v7 + 2);
    v7 = (v7 + 6);
    if ( v8 != HIWORD(v8) && v8 != v9 && HIWORD(v8) != v9 )
    {
      *a2 = v8;
      *(a2 + 4) = v9;
      a2 += 6;
    }
    for ( j = 3; j < v3; j = v5 + 1 )
    {
      LOWORD(v8) = v9;
      v10 = *v7;
      v7 = (v7 + 2);
      if ( v8 != HIWORD(v8) && v8 != v10 && HIWORD(v8) != v10 )
      {
        *a2 = v8;
        *(a2 + 4) = v10;
        a2 += 6;
      }
      v5 = j + 1;
      if ( v5 >= v3 )
        break;
      HIWORD(v8) = v10;
      v9 = *v7;
      v7 = (v7 + 2);
      if ( v8 != HIWORD(v8) && v8 != v9 && HIWORD(v8) != v9 )
      {
        *a2 = v8;
        *(a2 + 4) = v9;
        a2 += 6;
      }
    }
  }
  return result;
}

//----- (080C1D6C) --------------------------------------------------------
int __cdecl sub_80C1D6C(int a1, __int16 **a2, int (__cdecl *a3)(int))
{
  void *v3; // esp
  void *v4; // esp
  float *v5; // ebx
  int v6; // ebx
  int v7; // ebx
  long double v8; // fst7
  long double v9; // fst7
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int result; // eax
  int v17; // [esp+Ch] [ebp-4Ch] BYREF
  int v18; // [esp+10h] [ebp-48h] BYREF
  int *v19; // [esp+14h] [ebp-44h]
  int *v20; // [esp+18h] [ebp-40h]
  int v21; // [esp+20h] [ebp-38h]
  int v22; // [esp+24h] [ebp-34h]
  unsigned __int8 v23; // [esp+2Bh] [ebp-2Dh]
  int v24; // [esp+2Ch] [ebp-2Ch]
  int v25; // [esp+30h] [ebp-28h]
  int v26; // [esp+34h] [ebp-24h]
  float *v27; // [esp+38h] [ebp-20h]
  int v28; // [esp+3Ch] [ebp-1Ch]
  int v29; // [esp+40h] [ebp-18h]
  void *dest; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  *a1 = **a2;
  *a2 = (*a2 + 1);
  *(a1 + 2) = sub_80C4E86(**a2);
  *(a1 + 4) = sub_80C4E86(*++*a2);
  v18 = sub_80C4E86(*++*a2);
  v24 = sub_80C4E86(*++*a2);
  ++*a2;
  sub_80C837D((a1 + 8), 0, 0x10u);
  if ( v24 == -1 )
  {
    v29 = sub_80C4E86(**a2);
    v25 = sub_80C4E86(*++*a2);
    ++*a2;
    *(a1 + 6) = -1;
    *(a1 + 32) = a3(36 * (*(a1 + 2) - v25) + 32 * v25);
    *(a1 + 24) = a3(20 * v29);
  }
  else
  {
    v29 = 0;
    *(a1 + 6) = v24 << 6;
    *(a1 + (v24 >> 3) + 8) |= 1 << (v24 & 7);
    *(a1 + 32) = a3(24 * *(a1 + 2));
    *(a1 + 24) = 0;
  }
  *(a1 + 36) = a3(8 * *(a1 + 2));
  v22 = 0;
  v21 = 0;
  for ( i = 0; i < v18; ++i )
  {
    v23 = *(*a2 + v21);
    v22 += v23;
    v21 += 2 * v23 + 1;
  }
  v3 = alloca(16 * ((v18 + 15) >> 4));
  v19 = &v17;
  v4 = alloca(16 * ((2 * v22 + 15) >> 4));
  v20 = &v17;
  dest = &v17;
  for ( i = 0; i < v18; ++i )
  {
    v23 = **a2;
    *(v19 + i) = v23;
    *a2 = (*a2 + 1);
    memcpy(dest, *a2, 2 * v23);
    *a2 += v23;
    dest = dest + 2 * v23;
  }
  v28 = *(a1 + 32);
  v27 = *(a1 + 36);
  for ( j = 0; j < *(a1 + 2); ++j )
  {
    v5 = v28;
    *v5 = sub_80C4EA2(**a2);
    *a2 += 2;
    v6 = v28;
    *(v6 + 4) = sub_80C4EA2(**a2);
    *a2 += 2;
    v7 = v28;
    *(v7 + 8) = sub_80C4EA2(**a2);
    *a2 += 2;
    v8 = sub_80C4EA2(**a2);
    *v27 = v8;
    *a2 += 2;
    v9 = sub_80C4EA2(**a2);
    v27[1] = v9;
    *a2 += 2;
    if ( v24 == -1 )
    {
      v10 = v28;
      *(v10 + 12) = sub_80C4E86(**a2);
      ++*a2;
      sub_80C1B12(a1, v28 + 16, a2);
      if ( *(v28 + 12) )
      {
        v11 = v28;
        *(v11 + 32) = sub_80C4EA2(**a2);
        *a2 += 2;
        v28 += 36;
      }
      else
      {
        v28 += 32;
      }
      v27 += 2;
    }
    else
    {
      v12 = v28;
      *(v12 + 12) = sub_80C4EA2(**a2);
      *a2 += 2;
      v13 = v28;
      *(v13 + 16) = sub_80C4EA2(**a2);
      *a2 += 2;
      v14 = v28;
      *(v14 + 20) = sub_80C4EA2(**a2);
      *a2 += 2;
      v28 += 24;
      v27 += 2;
    }
  }
  v26 = *(a1 + 24);
  for ( j = 0; j < v29; ++j )
  {
    sub_80C1B12(a1, v26, a2);
    v15 = v26;
    *(v15 + 16) = sub_80C4EA2(**a2);
    *a2 += 2;
    v26 += 20;
  }
  if ( (*(a1 + 4) & 1) != 0 )
  {
    *(a1 + 28) = a3(6 * ++*(a1 + 4));
    sub_80C1BDA(&v18, *(a1 + 28));
    *(*(a1 + 28) + 6 * *(a1 + 4) - 6) = *(*(a1 + 28) + 6 * *(a1 + 4) - 8);
    *(*(a1 + 28) + 6 * *(a1 + 4) - 4) = *(*(a1 + 28) + 6 * *(a1 + 4) - 8);
    result = *(*(a1 + 28) + 6 * *(a1 + 4) - 8);
    *(*(a1 + 28) + 6 * *(a1 + 4) - 2) = result;
  }
  else
  {
    *(a1 + 28) = a3(6 * *(a1 + 4));
    result = sub_80C1BDA(&v18, *(a1 + 28));
  }
  return result;
}

//----- (080C23BC) --------------------------------------------------------
int __cdecl sub_80C23BC(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]

  *(a1 + 4) = 1;
  *(a1 + 2) = 3;
  sub_80C837D((a1 + 8), 0, 0x10u);
  *(a1 + 6) = 0;
  *(a1 + 32) = &unk_84568FC;
  *(a1 + 36) = &unk_8456944;
  *(a1 + 24) = 0;
  *(a1 + 28) = word_845695E;
  word_845695E[0] = 0;
  word_845695E[1] = 1;
  word_845695E[2] = 2;
  v3 = *(a1 + 32);
  v2 = *(a1 + 36);
  for ( i = 0; ; ++i )
  {
    result = *(a1 + 2);
    if ( i >= result )
      break;
    *v3 = 1065353216;
    v3[1] = 0;
    v3[2] = 0;
    *v2 = 0;
    v2[1] = 0;
    v3[3] = 0;
    v3[4] = 0;
    v3[5] = 0;
    v3 += 6;
    v2 += 2;
  }
  return result;
}

//----- (080C24DA) --------------------------------------------------------
_DWORD *sub_80C24DA()
{
  word_84567E0[0] = 1;
  dword_84567E4[0] = word_84567E0;
  unk_845688C = dword_84567E4;
  *(&unk_845688C + 3) = 0;
  *(&unk_845688C + 4) = 0;
  *(&unk_845688C + 2) = 1;
  *(&unk_845688C + 5) = &byte_8456964;
  byte_8456964 = 0;
  word_84567E0[1] = 0;
  dword_84568B0[0] = -1048576000;
  dword_84568B0[1] = -1048576000;
  dword_84568B0[2] = -1048576000;
  dword_84568B0[3] = 1098907648;
  dword_84568B0[4] = 1098907648;
  dword_84568B0[5] = 1098907648;
  *(&unk_845688C + 2) = dword_84568B0;
  dword_84568E4[1] = &unk_845688C;
  dword_84568E4[2] = 0;
  dword_84568E4[0] = "DEFAULT";
  return dword_84568E4;
}
// 8456964: using guessed type char byte_8456964;

//----- (080C25E4) --------------------------------------------------------
_DWORD *sub_80C25E4()
{
  *(&unk_84568A4 + 2) = 1;
  dword_8456820 = &unk_84567EC;
  *(&unk_84568A4 + 2) = &dword_8456820;
  sub_80C23BC(**(&unk_84568A4 + 2));
  dword_84568F0[1] = &unk_84568A4;
  dword_84568F0[2] = 0;
  dword_84568F0[0] = "DEFAULT";
  return dword_84568F0;
}
// 8456820: using guessed type int dword_8456820;

//----- (080C2646) --------------------------------------------------------
void *__cdecl sub_80C2646(int a1)
{
  void *result; // eax
  int i; // [esp+Ch] [ebp-Ch]

  unk_8456824 = sub_80C24DA();
  for ( i = 0; i <= 2; ++i )
  {
    *(&unk_8456824 + 5 * i + 5) = 0;
    *(&unk_8456824 + 5 * i + 2) = &unk_80EA598;
    *(&unk_8456824 + 5 * i + 1) = 0;
    *(&unk_8456824 + 10 * i + 6) = 1;
    *(&unk_8456824 + 5 * i + 4) = &word_8456966;
    word_8456966 = 0;
  }
  *(&unk_8456824 + 5) = sub_80C25E4();
  *(a1 + 4) = &unk_8456824;
  *(a1 + 8) = 0;
  *(&unk_8456824 + 50) = 1;
  result = &unk_8456824;
  *(&unk_8456824 + 51) = 0;
  return result;
}
// 8456966: using guessed type __int16 word_8456966;

//----- (080C273C) --------------------------------------------------------
int *sub_80C273C()
{
  sub_80C2646(&dword_84568D8);
  dword_84568D8 = "DEFAULT";
  return &dword_84568D8;
}
// 84568D8: using guessed type int dword_84568D8;

//----- (080C2760) --------------------------------------------------------
_DWORD *__cdecl sub_80C2760(_DWORD *a1, int (__cdecl *a2)(int))
{
  _DWORD *result; // eax
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = a2(12);
  *(v3 + 4) = *(a1[1] + 4);
  *(v3 + 8) = a2(4 * *(v3 + 4));
  sub_80C835C(*(v3 + 8), *(a1[1] + 8), 4 * *(v3 + 4));
  *v3 = dword_80F732C;
  dword_80F732C = v3;
  result = a2(12);
  result[1] = v3;
  result[2] = sub_80C19F4;
  *result = *a1;
  return result;
}
// 80F732C: using guessed type int dword_80F732C;

//----- (080C2810) --------------------------------------------------------
_DWORD *__cdecl sub_80C2810(const char *a1, int (__cdecl *a2)(int))
{
  _DWORD *v3; // [esp+20h] [ebp-438h]
  int v4; // [esp+24h] [ebp-434h]
  int v5; // [esp+28h] [ebp-430h]
  int v6; // [esp+2Ch] [ebp-42Ch]
  char s[1036]; // [esp+30h] [ebp-428h] BYREF
  int i; // [esp+43Ch] [ebp-1Ch]
  __int16 v9; // [esp+442h] [ebp-16h]
  __int16 *v10; // [esp+444h] [ebp-14h] BYREF
  int v11; // [esp+448h] [ebp-10h] BYREF
  _DWORD *v12; // [esp+44Ch] [ebp-Ch]

  v12 = sub_8064FC5("xmodelsurfs", a1, &unk_80EA598);
  if ( v12 )
  {
    if ( v12[1] )
    {
      v3 = sub_80C2760(v12, a2);
    }
    else
    {
      sprintf(s, "xmodelsurfs/%s", a1);
      if ( (sub_8062EB0(s, &v11) & 0x80000000) != 0 )
        sub_80704AC(1, &byte_80EA660, a1);
      v10 = v11;
      v4 = sub_80C4E86(*v11);
      ++v10;
      if ( v4 != 14 )
      {
        sub_8063207(v11);
        sub_80704AC(1, &byte_80EA680, a1, v4, 14);
      }
      v9 = sub_80C4E86(*v10++);
      v5 = a2(12);
      *(v5 + 4) = v9;
      *(v5 + 8) = a2(4 * v9);
      v6 = a2(52 * v9);
      for ( i = 0; i < v9; ++i )
      {
        *(*(v5 + 8) + 4 * i) = v6 + 52 * i;
        sub_80C1D6C(*(*(v5 + 8) + 4 * i), &v10, a2);
      }
      sub_8063207(v11);
      v12[1] = v5;
      v12[2] = sub_80C19F4;
      *v5 = dword_80F732C;
      dword_80F732C = v5;
      v3 = v12;
    }
  }
  else
  {
    if ( dword_80F7330 )
      sub_80704AC(1, &byte_80EA5C0, a1);
    Com_Printf("ERROR: Cannot precache 'xmodelsurfs/%s'", a1);
    v3 = 0;
  }
  return v3;
}
// 80F732C: using guessed type int dword_80F732C;
// 80F7330: using guessed type int dword_80F7330;

//----- (080C2ABE) --------------------------------------------------------
int __cdecl sub_80C2ABE(const char *a1, int (__cdecl *a2)(int))
{
  int v2; // ebx
  int v4; // [esp+24h] [ebp-484h]
  int v5; // [esp+2Ch] [ebp-47Ch]
  float v6; // [esp+30h] [ebp-478h]
  float v7; // [esp+34h] [ebp-474h]
  float v8; // [esp+38h] [ebp-470h]
  __int16 *v9; // [esp+48h] [ebp-460h]
  int v10; // [esp+4Ch] [ebp-45Ch]
  char v11; // [esp+50h] [ebp-458h]
  size_t n; // [esp+54h] [ebp-454h]
  float *v13; // [esp+60h] [ebp-448h]
  float *v14; // [esp+64h] [ebp-444h]
  int v15; // [esp+68h] [ebp-440h]
  int i; // [esp+68h] [ebp-440h]
  __int16 v17; // [esp+6Eh] [ebp-43Ah]
  __int16 v18; // [esp+70h] [ebp-438h]
  __int16 v19; // [esp+72h] [ebp-436h]
  int v20; // [esp+74h] [ebp-434h]
  _BYTE *v21; // [esp+78h] [ebp-430h]
  _WORD *v22; // [esp+80h] [ebp-428h]
  _DWORD *v23; // [esp+84h] [ebp-424h]
  char *v24; // [esp+88h] [ebp-420h]
  __int16 *v25; // [esp+88h] [ebp-420h]
  __int16 *v26; // [esp+88h] [ebp-420h]
  char *v27; // [esp+88h] [ebp-420h]
  char *v28; // [esp+88h] [ebp-420h]
  char *v29; // [esp+88h] [ebp-420h]
  int v30; // [esp+8Ch] [ebp-41Ch] BYREF
  char s[1032]; // [esp+90h] [ebp-418h] BYREF
  int v32; // [esp+498h] [ebp-10h]
  int v33; // [esp+49Ch] [ebp-Ch]

  v32 = sub_8064FC5("xmodelparts", a1, &unk_80EA598);
  if ( v32 )
  {
    if ( *(v32 + 4) )
    {
      v5 = v32;
    }
    else
    {
      sprintf(s, "xmodelparts/%s", a1);
      if ( (sub_8062EB0(s, &v30) & 0x80000000) != 0 )
        sub_80704AC(1, &byte_80EA780, a1);
      v24 = v30;
      v10 = sub_80C4E86(*v30);
      v25 = (v24 + 2);
      if ( v10 != 14 )
      {
        sub_8063207(v30);
        sub_80704AC(1, &byte_80EA7A0, a1, v10, 14);
      }
      v17 = sub_80C4E86(*v25);
      v26 = v25 + 1;
      v18 = sub_80C4E86(*v26);
      v27 = (v26 + 1);
      v19 = v18 + v17;
      v22 = a2(2 * (v18 + v17) + 2);
      *v22 = v18 + v17;
      if ( (v18 + v17) > 127 )
        sub_80704AC(1, &byte_80EA7E0, a1, 127);
      v23 = a2(v17 + 7);
      *v23 = v22;
      v21 = v23 + 1;
      v33 = a2(24 * v17 + 104);
      *v33 = v23;
      *(v33 + 12) = v33 + 24;
      if ( v17 )
        v4 = 8 * v17 + *(v33 + 12);
      else
        v4 = 0;
      *(v33 + 16) = v4;
      v2 = v33;
      *(v2 + 20) = a2(v19);
      *(v33 + 4) = v18;
      v20 = a2(40 * v19);
      v9 = *(v33 + 12);
      v14 = *(v33 + 16);
      v15 = v18;
      while ( v15 < v19 )
      {
        v11 = *v27;
        v28 = v27 + 1;
        *v21 = v15 - v11;
        *v14 = *v28;
        v14[1] = *(v28 + 1);
        v14[2] = *(v28 + 2);
        v28 += 12;
        *v14 = sub_80C4EA2(*v14);
        v14[1] = sub_80C4EA2(v14[1]);
        v14[2] = sub_80C4EA2(v14[2]);
        sub_80C1876(v28, v9);
        v27 = v28 + 6;
        ++v15;
        v9 += 4;
        v14 += 3;
        ++v21;
      }
      for ( i = 0; i < v19; ++i )
      {
        n = strlen(v27) + 1;
        v22[i + 1] = sub_80A4884(v27, 0, n);
        v29 = &v27[n];
        v13 = (v20 + 40 * i);
        *v13 = *v29;
        v13[1] = *(v29 + 1);
        v13[2] = *(v29 + 2);
        v29 += 12;
        *v13 = sub_80C4EA2(*v13);
        v13[1] = sub_80C4EA2(v13[1]);
        v13[2] = sub_80C4EA2(v13[2]);
        v13[3] = *v29;
        v13[4] = *(v29 + 1);
        v13[5] = *(v29 + 2);
        v27 = v29 + 12;
        v13[3] = sub_80C4EA2(v13[3]);
        v13[4] = sub_80C4EA2(v13[4]);
        v13[5] = sub_80C4EA2(v13[5]);
        v13[6] = *v13 + v13[3];
        v13[7] = v13[1] + v13[4];
        v13[8] = v13[2] + v13[5];
        v13[6] = v13[6] * 0.5;
        v13[7] = v13[7] * 0.5;
        v13[8] = v13[8] * 0.5;
        v6 = v13[3] - v13[6];
        v7 = v13[4] - v13[7];
        v8 = v13[5] - v13[8];
        v13[9] = v6 * v6 + v7 * v7 + v8 * v8;
      }
      memcpy(*(v33 + 20), v27, v19);
      sub_8063207(v30);
      *(v33 + 8) = v20;
      *(v32 + 4) = v33;
      *(v32 + 8) = sub_80C19FA;
      v5 = v32;
    }
  }
  else
  {
    if ( dword_80F7330 )
      sub_80704AC(1, &byte_80EA6E0, a1);
    Com_Printf("ERROR: Cannot precache 'xmodelparts/%s'", a1);
    v5 = 0;
  }
  return v5;
}
// 80F7330: using guessed type int dword_80F7330;

//----- (080C3310) --------------------------------------------------------
float *__cdecl sub_80C3310(int a1, char *src, int a3)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  char *srca; // [esp+34h] [ebp+Ch]
  float *srcc; // [esp+34h] [ebp+Ch]
  float *srcb; // [esp+34h] [ebp+Ch]
  char *srcd; // [esp+34h] [ebp+Ch]

  v5 = sub_80C4E86(*src);
  srca = src + 2;
  if ( v5 != 14 )
    sub_80704AC(1, &byte_80EA820, a1, v5, 14);
  *(a3 + 3084) = sub_80C4EA2(*srca);
  srcc = (srca + 4);
  *(a3 + 3088) = sub_80C4EA2(*srcc++);
  *(a3 + 3092) = sub_80C4EA2(*srcc++);
  *(a3 + 3096) = sub_80C4EA2(*srcc++);
  *(a3 + 3100) = sub_80C4EA2(*srcc++);
  *(a3 + 3104) = sub_80C4EA2(*srcc);
  srcb = srcc + 1;
  for ( i = 0; i <= 2; ++i )
  {
    *(a3 + 1028 * i + 1024) = sub_80C4EA2(*srcb);
    srcd = (srcb + 1);
    strcpy((a3 + 1028 * i), srcd);
    srcb = &srcd[strlen(srcd) + 1];
  }
  *(a3 + 3108) = sub_80C4E9A(*srcb);
  return srcb + 1;
}

//----- (080C34B2) --------------------------------------------------------
int *__cdecl sub_80C34B2(int *a1, _DWORD *a2, int (__cdecl *a3)(int))
{
  int *v4; // [esp+10h] [ebp-18h]
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float *v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int *v9; // [esp+30h] [ebp+8h]
  float *v10; // [esp+30h] [ebp+8h]
  float *v11; // [esp+30h] [ebp+8h]
  float *v12; // [esp+30h] [ebp+8h]

  a2[17] = sub_80C4E9A(*a1);
  v9 = a1 + 1;
  a2[18] = 0;
  if ( a2[17] )
  {
    a2[16] = a3(44 * a2[17]);
    for ( i = 0; i < a2[17]; ++i )
    {
      v8 = a2[16] + 44 * i;
      *(v8 + 4) = sub_80C4E9A(*v9);
      v10 = (v9 + 1);
      *v8 = a3(48 * *(v8 + 4));
      for ( j = 0; j < *(v8 + 4); ++j )
      {
        v7 = (*v8 + 48 * j);
        *v7 = sub_80C4EA2(*v10);
        v11 = v10 + 1;
        v7[1] = sub_80C4EA2(*v11++);
        v7[2] = sub_80C4EA2(*v11++);
        v7[3] = sub_80C4EA2(*v11++);
        v7[4] = sub_80C4EA2(*v11++);
        v7[5] = sub_80C4EA2(*v11++);
        v7[6] = sub_80C4EA2(*v11++);
        v7[7] = sub_80C4EA2(*v11++);
        v7[8] = sub_80C4EA2(*v11++);
        v7[9] = sub_80C4EA2(*v11++);
        v7[10] = sub_80C4EA2(*v11++);
        v7[11] = sub_80C4EA2(*v11);
        v10 = v11 + 1;
      }
      *(v8 + 8) = sub_80C4EA2(*v10) - 0.001;
      v12 = v10 + 1;
      *(v8 + 12) = sub_80C4EA2(*v12++) - 0.001;
      *(v8 + 16) = sub_80C4EA2(*v12++) - 0.001;
      *(v8 + 20) = sub_80C4EA2(*v12++) + 0.001;
      *(v8 + 24) = sub_80C4EA2(*v12++) + 0.001;
      *(v8 + 28) = sub_80C4EA2(*v12++) + 0.001;
      *(v8 + 32) = sub_80C4E9A(*v12++);
      *(v8 + 36) = sub_80C4E9A(*v12++) & 0xDFFF7FFB;
      *(v8 + 40) = sub_80C4E9A(*v12);
      v9 = (v12 + 1);
      a2[18] |= *(v8 + 36);
    }
    v4 = v9;
  }
  else
  {
    a2[16] = 0;
    v4 = v9;
  }
  return v4;
}

//----- (080C37F6) --------------------------------------------------------
_BOOL4 __cdecl sub_80C37F6(int a1)
{
  return sub_8064FC5("xmodel", a1, &unk_80EA598) != 0;
}

//----- (080C382C) --------------------------------------------------------
int __cdecl sub_80C382C(const char *a1, int a2, int (__cdecl *a3)(int))
{
  int v3; // ebx
  _DWORD *v4; // ebx
  size_t v5; // eax
  __int16 v6; // ax
  int *v7; // ebx
  _DWORD *v8; // ebx
  int *v10; // [esp+14h] [ebp-1094h]
  char *v11; // [esp+18h] [ebp-1090h]
  char *src; // [esp+1Ch] [ebp-108Ch] BYREF
  char s[1036]; // [esp+20h] [ebp-1088h] BYREF
  int j; // [esp+42Ch] [ebp-C7Ch]
  int i; // [esp+430h] [ebp-C78h]
  int v16; // [esp+434h] [ebp-C74h]
  char *dest; // [esp+438h] [ebp-C70h]
  int *v18; // [esp+43Ch] [ebp-C6Ch]
  int v19[7]; // [esp+440h] [ebp-C68h]
  _DWORD *v20; // [esp+45Ch] [ebp-C4Ch]
  int v21[777]; // [esp+460h] [ebp-C48h] BYREF
  int v22; // [esp+1084h] [ebp-24h]
  int *v23; // [esp+109Ch] [ebp-Ch]
  _DWORD v24[2]; // [esp+10A0h] [ebp-8h] BYREF

  v23 = sub_8064FC5("xmodel", a1, &unk_80EA598);
  if ( v23 )
  {
    v20 = v23[1];
    if ( v20 )
    {
      if ( sub_80C1852(v23) )
        return v23;
    }
    else
    {
      sprintf(s, "xmodel/%s", a1);
      if ( (sub_8062EB0(s, &src) & 0x80000000) != 0 )
        sub_80704AC(1, &byte_80EA8ED, a1);
      v18 = sub_80C3310(a1, src, v21);
      if ( !v18 )
      {
        sub_8063207(src);
        return 0;
      }
      v16 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        v3 = i;
        v19[v3] = strlen(&v21[257 * i]) + 1;
        v16 += v19[i];
      }
      v20 = a3(v16 + 104);
      v18 = sub_80C34B2(v18, v20, a3);
      dest = (v20 + 26);
      *(v20 + 50) = 0;
      for ( i = 0; i <= 2; ++i )
      {
        strcpy(dest, &v21[257 * i]);
        v20[5 * i + 2] = dest;
        if ( *dest )
        {
          ++*(v20 + 50);
          LOWORD(v20[5 * i + 3]) = *v18;
          v18 = (v18 + 2);
          v4 = &v20[5 * i + 4];
          *v4 = a3(2 * SLOWORD(v20[5 * i + 3]));
          for ( j = 0; j < SLOWORD(v20[5 * i + 3]); ++j )
          {
            v11 = v18;
            v5 = strlen(v18);
            v18 = (v18 + v5 + 1);
            v6 = sub_80A4D5C(v11, 0);
            *(v20[5 * i + 4] + 2 * j) = v6;
          }
        }
        else
        {
          v20[5 * i + 4] = 0;
        }
        v20[5 * i + 1] = v24[257 * i - 528];
        dest += v19[i];
      }
      sub_8063207(src);
      v20[19] = v21[771];
      v20[20] = v21[772];
      v20[21] = v21[773];
      v20[22] = v21[774];
      v20[23] = v21[775];
      v20[24] = v21[776];
      *(v20 + 51) = v22;
      v23[1] = v20;
      v23[2] = sub_80C1A5A;
      v20[5] = 0;
      v20[10] = 0;
      v20[15] = 0;
    }
    v7 = v20;
    *v7 = sub_80C2ABE(v20[2], a3);
    if ( *v20 )
    {
      if ( a2 )
      {
        for ( i = 0; i <= 2 && *v20[5 * i + 2]; ++i )
        {
          v8 = &v20[5 * i + 5];
          *v8 = sub_80C2810(v20[5 * i + 2], a3);
          if ( !v20[5 * i + 5] )
            goto LABEL_25;
        }
        v10 = v23;
      }
      else
      {
        v10 = v23;
      }
    }
    else
    {
LABEL_25:
      sub_80C1A5A(v23);
      sub_80C2646(v23);
      v10 = v23;
    }
  }
  else
  {
    if ( dword_80F7330 )
      sub_80704AC(1, &byte_80EA860, a1);
    Com_Printf("ERROR: Cannot precache 'xmodel/%s'", a1);
    v10 = sub_80C273C();
  }
  return v10;
}
// 80F7330: using guessed type int dword_80F7330;

//----- (080C3E74) --------------------------------------------------------
int __cdecl sub_80C3E74(unsigned int a1, unsigned int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-10h]
  int j; // [esp+4h] [ebp-Ch]
  int k; // [esp+4h] [ebp-Ch]
  int *v6; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v6 = &dword_80F732C;
  result = dword_80F732C;
  for ( i = dword_80F732C; i; i = *i )
  {
    if ( i < a1 || i >= a2 )
    {
      for ( j = 0; j < *(i + 4); ++j )
      {
        v3 = *(*(i + 8) + 4 * j);
        if ( v3 )
        {
          if ( *(v3 + 48) >= a1 && *(v3 + 48) < a2 )
            *(v3 + 48) = 0;
          if ( *(v3 + 44) >= a1 && *(v3 + 44) < a2 )
            *(v3 + 44) = 0;
        }
      }
      for ( k = 0; k < *(i + 4); ++k )
        ;
      v6 = i;
    }
    else
    {
      *v6 = *i;
    }
    result = *i;
  }
  return result;
}
// 80F732C: using guessed type int dword_80F732C;

//----- (080C3F5E) --------------------------------------------------------
int __cdecl sub_80C3F5E(int a1)
{
  return ****(**(a1 + 4) + 4);
}

//----- (080C3F76) --------------------------------------------------------
int __cdecl sub_80C3F76(int a1)
{
  return ***(**(a1 + 4) + 4) + 2;
}

//----- (080C3F8E) --------------------------------------------------------
int __cdecl sub_80C3F8E(int a1, __int16 a2)
{
  __int16 *v3; // [esp+4h] [ebp-10h]
  int i; // [esp+Ch] [ebp-8h]

  v3 = ***(**(a1 + 4) + 4);
  for ( i = *v3 - 1; i >= 0 && a2 != v3[i + 1]; --i )
    ;
  return i;
}

//----- (080C3FF0) --------------------------------------------------------
int __cdecl sub_80C3FF0(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  _DWORD *v4; // [esp+0h] [ebp-4h]

  v4 = *(a1 + 4);
  *a2 = v4[19];
  a2[1] = v4[20];
  a2[2] = v4[21];
  *a3 = v4[22];
  a3[1] = v4[23];
  result = v4[24];
  a3[2] = result;
  return result;
}

//----- (080C409E) --------------------------------------------------------
const char *__cdecl sub_80C409E(int a1, int a2, int a3)
{
  const char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *(*(*(a1 + 4) + 20 * a3 + 16) + 2 * a2);
  if ( v5 )
    v4 = sub_80A4458(v5);
  else
    v4 = "DEFAULT";
  return v4;
}

//----- (080C40F0) --------------------------------------------------------
int __cdecl sub_80C40F0(void **a1, int (__cdecl *a2)(int))
{
  int v3; // [esp+18h] [ebp-10h]

  v3 = a2(52);
  qmemcpy(v3, a1, 0x34u);
  *(v3 + 44) = 0;
  *(v3 + 48) = 0;
  *(v3 + 36) = a2(8 * *(v3 + 2));
  sub_80C835C(*(v3 + 36), a1[9], 8 * *(v3 + 2));
  return v3;
}

//----- (080C4296) --------------------------------------------------------
int __cdecl sub_80C4296(int a1)
{
  return *(a1 + 6);
}

//----- (080C4334) --------------------------------------------------------
int __cdecl sub_80C4334(int a1)
{
  return *(*(a1 + 4) + 72);
}

//----- (080C4342) --------------------------------------------------------
int *__cdecl sub_80C4342(int a1, int a2, int a3, void *dest, int a5)
{
  int *result; // eax
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int *j; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+1Ch] [ebp-Ch]
  float *v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]

  v8 = *(a1 + 32);
  v12 = sub_80C4296(a1);
  if ( dest )
    memcpy(dest, *(a1 + 36), 8 * *(a1 + 2));
  if ( v12 == -1 )
  {
    v7 = *(a1 + 24);
    result = *(a1 + 2);
    for ( i = result; i; i = (i - 1) )
    {
      if ( a5 )
      {
        sub_80C5204(v8, (a2 + *(v8 + 28)), a5);
        a5 += 12;
      }
      sub_80C5086((v8 + 16), (a2 + *(v8 + 28)), a3);
      v6 = *(v8 + 12);
      if ( v6 )
      {
        *a3 = *a3 * *(v8 + 32);
        *(a3 + 4) = *(a3 + 4) * *(v8 + 32);
        *(a3 + 8) = *(a3 + 8) * *(v8 + 32);
        do
        {
          sub_80C5132(v7, *(v7 + 16), a2 + *(v7 + 12), a3);
          --v6;
          v7 += 20;
        }
        while ( v6 );
        v8 += 36;
      }
      else
      {
        v8 += 32;
      }
      result = &a3;
      a3 += 12;
    }
  }
  else
  {
    v11 = (a2 + v12);
    result = *(a1 + 2);
    for ( j = result; j; j = (j - 1) )
    {
      if ( a5 )
      {
        sub_80C5204(v8, v11, a5);
        a5 += 12;
      }
      sub_80C5086((v8 + 12), v11, a3);
      v8 += 24;
      result = &a3;
      a3 += 12;
    }
  }
  return result;
}

//----- (080C4512) --------------------------------------------------------
int __cdecl sub_80C4512(int a1)
{
  return *(*(a1 + 4) + 100);
}

//----- (080C45AE) --------------------------------------------------------
int __cdecl sub_80C45AE(int a1, float a2)
{
  int *v3; // [esp+4h] [ebp-14h]
  int i; // [esp+Ch] [ebp-Ch]
  float *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  if ( byte_84569BC )
    v3 = &dword_8456980;
  else
    v3 = (*(a1 + 4) + 4);
  v6 = v3;
  if ( flt_84569C0 != 0.0 )
    a2 = flt_84569C0;
  v7 = sub_80C4512(a1);
  for ( i = 0; i < v7; ++i )
  {
    if ( *v6 == 0.0 || *v6 > a2 )
      return i;
    v6 += 5;
  }
  return -1;
}
// 8456980: using guessed type int dword_8456980;
// 84569BC: using guessed type char byte_84569BC;
// 84569C0: using guessed type float flt_84569C0;

//----- (080C4658) --------------------------------------------------------
unsigned __int8 **__cdecl sub_80C4658(int a1, int a2)
{
  unsigned __int8 **result; // eax
  float v3[4]; // [esp+10h] [ebp-38h] BYREF
  unsigned __int8 *v4; // [esp+20h] [ebp-28h] BYREF
  float *v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  __int16 **v7; // [esp+2Ch] [ebp-1Ch]
  float *v8; // [esp+30h] [ebp-18h]
  __int16 *v9; // [esp+34h] [ebp-14h]
  __int16 ***v10; // [esp+38h] [ebp-10h]
  unsigned __int8 **v11; // [esp+3Ch] [ebp-Ch]

  v10 = *(**(a1 + 4) + 4);
  v7 = *v10;
  v4 = (v7 + 1);
  v6 = **v7;
  v9 = v10[3];
  v8 = v10[4];
  v5 = a2;
  v11 = *(v10 + 2);
  while ( v11 )
  {
    *v5 = 0.0;
    v5[1] = 0.0;
    v5[2] = 0.0;
    v5[3] = 1.0;
    v11 = (v11 - 1);
    v5 += 16;
  }
  v11 = (v6 - *(v10 + 2));
  while ( v11 )
  {
    v3[0] = *v9 * 0.000030518509;
    v3[1] = v9[1] * 0.000030518509;
    v3[2] = v9[2] * 0.000030518509;
    v3[3] = v9[3] * 0.000030518509;
    sub_806960C(v3, &v5[-16 * *v4], v5);
    v11 = (v11 - 1);
    v9 += 4;
    v5 += 16;
    ++v4;
  }
  v11 = *(v10 + 2);
  while ( v11 )
  {
    *a2 = 1065353216;
    *(a2 + 4) = 0;
    *(a2 + 8) = 0;
    *(a2 + 16) = 0;
    *(a2 + 20) = 1065353216;
    *(a2 + 24) = 0;
    *(a2 + 32) = 0;
    *(a2 + 36) = 0;
    *(a2 + 40) = 1065353216;
    *(a2 + 56) = 0;
    *(a2 + 52) = 0;
    *(a2 + 48) = 0;
    v11 = (v11 - 1);
    a2 += 64;
  }
  v4 = (v7 + 1);
  result = (v6 - *(v10 + 2));
  v11 = result;
  while ( v11 )
  {
    sub_80C4EB4(a2);
    sub_80C5086(v8, (a2 - (*v4 << 6)), (a2 + 48));
    v11 = (v11 - 1);
    a2 += 64;
    v8 += 3;
    result = &v4;
    ++v4;
  }
  return result;
}

//----- (080C4892) --------------------------------------------------------
int __cdecl sub_80C4892(int a1, int a2, int a3, float *a4, float *a5, int a6)
{
  int v8[4]; // [esp+30h] [ebp-A8h] BYREF
  int j; // [esp+40h] [ebp-98h]
  int i; // [esp+44h] [ebp-94h]
  float v11; // [esp+48h] [ebp-90h]
  float v12; // [esp+4Ch] [ebp-8Ch]
  float v13; // [esp+50h] [ebp-88h]
  float v14; // [esp+54h] [ebp-84h]
  float v15; // [esp+58h] [ebp-80h]
  float v16; // [esp+5Ch] [ebp-7Ch]
  float v17; // [esp+60h] [ebp-78h]
  float v18; // [esp+64h] [ebp-74h]
  float v19; // [esp+68h] [ebp-70h]
  float v20; // [esp+70h] [ebp-68h]
  float v21; // [esp+74h] [ebp-64h]
  float v22; // [esp+78h] [ebp-60h]
  float *v23; // [esp+80h] [ebp-58h]
  _DWORD *v24; // [esp+84h] [ebp-54h]
  int v25; // [esp+88h] [ebp-50h]
  int v26; // [esp+8Ch] [ebp-4Ch]
  float v27; // [esp+90h] [ebp-48h] BYREF
  float v28; // [esp+94h] [ebp-44h]
  float v29; // [esp+98h] [ebp-40h]
  float v30; // [esp+A0h] [ebp-38h] BYREF
  float v31; // [esp+A4h] [ebp-34h]
  float v32; // [esp+A8h] [ebp-30h]
  float v33; // [esp+B0h] [ebp-28h] BYREF
  float v34; // [esp+B4h] [ebp-24h]
  float v35; // [esp+B8h] [ebp-20h]
  float *v36; // [esp+C4h] [ebp-14h]
  int v37; // [esp+C8h] [ebp-10h]
  int v38; // [esp+CCh] [ebp-Ch]

  v26 = -1;
  v25 = *(a1 + 4);
  v37 = sub_80C3F5E(a1);
  for ( i = 0; i < *(v25 + 68); ++i )
  {
    v24 = (*(v25 + 64) + 44 * i);
    if ( (v24[9] & a6) != 0 )
    {
      v38 = v24[8];
      v36 = (a3 + (v38 << 6));
      v33 = *a4 - v36[12];
      v34 = a4[1] - v36[13];
      v35 = a4[2] - v36[14];
      sub_80C529E(&v33, v36, &v27);
      v33 = *a5 - v36[12];
      v34 = a5[1] - v36[13];
      v35 = a5[2] - v36[14];
      sub_80C529E(&v33, v36, &v30);
      v20 = v30 - v27;
      v21 = v31 - v28;
      v22 = v32 - v29;
      if ( !sub_805E387(&v27, &v30, (v24 + 2), (v24 + 5), *a2) )
      {
        for ( j = 0; j < v24[1]; ++j )
        {
          v23 = (*v24 + 48 * j);
          v16 = v30 * *v23 + v31 * v23[1] + v32 * v23[2] - v23[3];
          if ( v16 < 0.0 )
          {
            v15 = v27 * *v23 + v28 * v23[1] + v29 * v23[2] - v23[3];
            if ( v15 > 0.0 )
            {
              v14 = (v15 - 0.125) / (v15 - v16);
              if ( v14 < *a2 )
              {
                v13 = v15 / (v15 - v16);
                v17 = v20 * v13 + v27;
                v18 = v21 * v13 + v28;
                v19 = v22 * v13 + v29;
                v12 = v17 * v23[4] + v18 * v23[5] + v19 * v23[6] - v23[7];
                if ( v12 >= -0.001 && v12 <= 1.001 )
                {
                  v11 = v17 * v23[8] + v18 * v23[9] + v19 * v23[10] - v23[11];
                  if ( v11 >= -0.001 && v12 + v11 <= 1.001 )
                  {
                    v26 = v38;
                    *(a2 + 47) = 0;
                    *(a2 + 46) = 0;
                    *a2 = v14;
                    *(a2 + 28) = v24[10];
                    *(a2 + 32) = v24[9];
                    *(a2 + 16) = *v23;
                    *(a2 + 20) = v23[1];
                    *(a2 + 24) = v23[2];
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v26 < 0 )
    return -1;
  v36 = (a3 + (v26 << 6));
  sub_80C5204((a2 + 16), v36, v8);
  *(a2 + 16) = v8[0];
  *(a2 + 20) = v8[1];
  *(a2 + 24) = v8[2];
  return v26;
}

//----- (080C4CB2) --------------------------------------------------------
int __cdecl sub_80C4CB2(int a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  float v5; // [esp+10h] [ebp-58h]
  float v6; // [esp+14h] [ebp-54h]
  float v7; // [esp+18h] [ebp-50h]
  float v9[4]; // [esp+20h] [ebp-48h] BYREF
  float v10[7]; // [esp+30h] [ebp-38h] BYREF
  int j; // [esp+4Ch] [ebp-1Ch]
  int k; // [esp+50h] [ebp-18h]
  int i; // [esp+54h] [ebp-14h]
  float *v14; // [esp+58h] [ebp-10h]
  int v15; // [esp+5Ch] [ebp-Ch]

  v15 = *(a1 + 4);
  if ( !*(v15 + 68) )
    return 0;
  *a3 = 2139095039;
  a3[1] = 2139095039;
  a3[2] = 2139095039;
  *a4 = -8388609;
  a4[1] = -8388609;
  a4[2] = -8388609;
  for ( i = 0; i < *(v15 + 68); ++i )
  {
    v14 = (*(v15 + 64) + 44 * i);
    for ( j = 0; j <= 7; ++j )
    {
      if ( (j & 1) != 0 )
        v7 = v14[2];
      else
        v7 = v14[5];
      v10[0] = v7;
      if ( (j & 2) != 0 )
        v6 = v14[3];
      else
        v6 = v14[6];
      v10[1] = v6;
      if ( (j & 4) != 0 )
        v5 = v14[4];
      else
        v5 = v14[7];
      v10[2] = v5;
      sub_8069154(v10, a2, v9);
      for ( k = 0; k <= 2; ++k )
      {
        if ( *&a3[k] > v9[k] )
          a3[k] = LODWORD(v9[k]);
        if ( v9[k] > *&a4[k] )
          a4[k] = LODWORD(v9[k]);
      }
    }
  }
  return 1;
}

//----- (080C4E86) --------------------------------------------------------
int __cdecl sub_80C4E86(__int16 a1)
{
  return a1;
}

//----- (080C4E9A) --------------------------------------------------------
int __cdecl sub_80C4E9A(int a1)
{
  return a1;
}

//----- (080C4EA2) --------------------------------------------------------
long double __cdecl sub_80C4EA2(float a1)
{
  return a1;
}

//----- (080C4EB4) --------------------------------------------------------
int __cdecl sub_80C4EB4(int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-28h]
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+8h] [ebp-20h]
  float v7; // [esp+Ch] [ebp-1Ch]
  float v8; // [esp+10h] [ebp-18h]
  float v9; // [esp+14h] [ebp-14h]
  float v10; // [esp+14h] [ebp-14h]
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+1Ch] [ebp-Ch]
  float v13; // [esp+20h] [ebp-8h]
  float v14; // [esp+24h] [ebp-4h]
  float v15; // [esp+24h] [ebp-4h]

  v14 = *a1 * *a1;
  v9 = *(a1 + 4) * *(a1 + 4);
  v5 = *(a1 + 8) * *(a1 + 8);
  v2 = v14 + v9 + v5 + *(a1 + 12) * *(a1 + 12);
  if ( v2 == 0.0 )
  {
    *a1 = 1065353216;
    *(a1 + 4) = 0;
    *(a1 + 8) = 0;
    *(a1 + 16) = 0;
    *(a1 + 20) = 1065353216;
    *(a1 + 24) = 0;
    *(a1 + 32) = 0;
    *(a1 + 36) = 0;
    result = a1;
    *(a1 + 40) = 1065353216;
  }
  else
  {
    v3 = 2.0 / v2;
    v15 = v14 * v3;
    v10 = v9 * v3;
    v6 = v5 * v3;
    *a1 = *a1 * v3;
    v13 = *a1 * *(a1 + 4);
    v12 = *a1 * *(a1 + 8);
    v11 = *a1 * *(a1 + 12);
    *(a1 + 4) = *(a1 + 4) * v3;
    v8 = *(a1 + 4) * *(a1 + 8);
    v7 = *(a1 + 4) * *(a1 + 12);
    v4 = *(a1 + 8) * *(a1 + 12) * v3;
    *a1 = 1.0 - (v10 + v6);
    *(a1 + 4) = v13 + v4;
    *(a1 + 8) = v12 - v7;
    *(a1 + 16) = v13 - v4;
    *(a1 + 20) = 1.0 - (v15 + v6);
    *(a1 + 24) = v8 + v11;
    *(a1 + 32) = v12 + v7;
    *(a1 + 36) = v8 - v11;
    result = a1;
    *(a1 + 40) = 1.0 - (v15 + v10);
  }
  return result;
}

//----- (080C5086) --------------------------------------------------------
float *__cdecl sub_80C5086(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (080C5132) --------------------------------------------------------
int __cdecl sub_80C5132(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *a4 = (*a1 * *a3 + *(a1 + 4) * *(a3 + 16) + *(a1 + 8) * *(a3 + 32) + *(a3 + 48)) * a2 + *a4;
  *(a4 + 4) = (*a1 * *(a3 + 4) + *(a1 + 4) * *(a3 + 20) + *(a1 + 8) * *(a3 + 36) + *(a3 + 52)) * a2 + *(a4 + 4);
  result = a3;
  *(a4 + 8) = (*a1 * *(a3 + 8) + *(a1 + 4) * *(a3 + 24) + *(a1 + 8) * *(a3 + 40) + *(a3 + 56)) * a2 + *(a4 + 8);
  return result;
}

//----- (080C5204) --------------------------------------------------------
float *__cdecl sub_80C5204(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10];
  return result;
}

//----- (080C529E) --------------------------------------------------------
float *__cdecl sub_80C529E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[4] + a1[1] * a2[5] + a1[2] * a2[6];
  result = a1 + 2;
  a3[2] = *a1 * a2[8] + a1[1] * a2[9] + a1[2] * a2[10];
  return result;
}

//----- (080C5338) --------------------------------------------------------
int sub_80C5338()
{
  int result; // eax
  char s[40]; // [esp+10h] [ebp-28h] BYREF

  sub_80C837D(s, 0, 0x14u);
  result = sub_80A4884(s, 0, 0x11u);
  word_80F7338 = result;
  return result;
}
// 80F7338: using guessed type __int16 word_80F7338;

//----- (080C5384) --------------------------------------------------------
int sub_80C5384()
{
  int result; // eax

  if ( word_80F7338 )
  {
    result = sub_80A50FE(word_80F7338, 0x11u);
    word_80F7338 = 0;
  }
  return result;
}
// 80F7338: using guessed type __int16 word_80F7338;

//----- (080C53B6) --------------------------------------------------------
void __cdecl sub_80C53B6(int a1)
{
  const char *v1; // eax
  const char *v2; // ebx
  const char *v3; // eax
  int v4; // [esp+14h] [ebp-24h]
  unsigned __int8 *k; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]

  if ( a1 )
  {
    Com_Printf("\nModels:\n");
    v7 = *(a1 + 22);
    v6 = 0;
    for ( i = 0; i < v7; ++i )
    {
      v4 = *(a1 + 4 * i + 28);
      Com_Printf("%d: '%s'\n", v6, *v4);
      v6 += ****(**(v4 + 4) + 4);
    }
    Com_Printf("\nBones:\n");
    v8 = *(a1 + 23);
    for ( j = 0; j < v8; ++j )
    {
      v1 = sub_80C7136(a1, j);
      Com_Printf("Bone %d: '%s'\n", j, v1);
    }
    if ( *(a1 + 20) )
    {
      Com_Printf("\nPart duplicates:\n");
      for ( k = (sub_80A4458(*(a1 + 20)) + 16); *k; k += 2 )
      {
        v2 = sub_80C7136(a1, k[1] - 1);
        v3 = sub_80C7136(a1, *k - 1);
        Com_Printf("%d ('%s') -> %d ('%s')\n", *k - 1, v3, k[1] - 1, v2);
      }
    }
    else
    {
      Com_Printf("\nNo part duplicates.\n");
    }
    Com_Printf("\n");
  }
  else
  {
    Com_Printf("No Dobj\n");
  }
}

//----- (080C557A) --------------------------------------------------------
int __cdecl sub_80C557A(int a1, __int16 a2)
{
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  v8 = *(a1 + 22);
  v6 = 0;
  for ( i = 0; i < v8; ++i )
  {
    v5 = *(a1 + 4 * i + 28);
    v4 = sub_80C3F8E(v5, a2);
    if ( v4 >= 0 )
      return v6 + v4;
    v6 += ****(**(v5 + 4) + 4);
  }
  return -1;
}

//----- (080C5608) --------------------------------------------------------
int __cdecl sub_80C5608(int a1)
{
  void *v1; // esp
  const char *v2; // eax
  int result; // eax
  _BYTE v4[12]; // [esp+10h] [ebp-48h] BYREF
  int v5; // [esp+1Ch] [ebp-3Ch]
  char v6; // [esp+23h] [ebp-35h]
  size_t n; // [esp+24h] [ebp-34h]
  void *s; // [esp+28h] [ebp-30h]
  unsigned __int16 *v9; // [esp+2Ch] [ebp-2Ch]
  __int16 *v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int i; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]

  v1 = alloca(16 * ((2 * *(a1 + 23) + 32) >> 4));
  s = v4;
  sub_80C837D(v4, 0, 0x10u);
  v15 = ****(**(*(a1 + 28) + 4) + 4);
  n = 16;
  v16 = 1;
  while ( v16 < *(a1 + 22) )
  {
    v14 = *(a1 + 4 * v16 + 28);
    if ( *(v16 + a1 + 76) == 0xFF )
    {
      v10 = ***(**(v14 + 4) + 4);
      v9 = (v10 + 1);
      v11 = *v10;
      v6 = 0;
      v13 = -1;
      for ( i = 0; i < v11; ++i )
      {
        v13 = sub_80C557A(a1, v9[i]);
        if ( v13 != v15 + i )
        {
          if ( !i )
            v6 = 1;
          v5 = v15 + i;
          *(s + n) = v15 + i + 1;
          *(s + (v5 >> 3)) |= 1 << (v5 & 7);
          *(s + ++n) = v13 + 1;
          ++n;
        }
      }
      if ( !v6 )
      {
        v2 = sub_80A4458(*v9);
        Com_Printf(
          "WARNING: Attempting to meld model, but root part '%s' of model '%s' not found in model '%s' or any of its descendants\n",
          v2,
          *v14,
          **(a1 + 28));
      }
    }
    ++v16;
    v15 += ****(**(v14 + 4) + 4);
  }
  if ( n <= 0x10 )
  {
    result = word_80F7338;
    *(a1 + 20) = word_80F7338;
  }
  else
  {
    *(s + n++) = 0;
    result = sub_80A4884(s, 0, n);
    *(a1 + 20) = result;
  }
  return result;
}
// 80F7338: using guessed type __int16 word_80F7338;

//----- (080C5832) --------------------------------------------------------
int __cdecl sub_80C5832(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *k; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  __int16 **j; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 ***v11; // [esp+54h] [ebp-24h]
  int i; // [esp+58h] [ebp-20h]
  int v13; // [esp+5Ch] [ebp-1Ch]

  for ( i = 0; i <= 3; ++i )
    *(a3 + 4 * i) = 0;
  v13 = *(a1 + 22);
  if ( !*(a1 + 20) )
    sub_80C5608(a1);
  v4 = sub_80A4458(*(a1 + 20));
  v10 = (v4 + 16);
  k = (v4 + 16);
  v5[0] = 0;
  for ( i = 0; ; v5[i] = v6 )
  {
    v11 = *(**(*(a1 + 4 * i + 28) + 4) + 4);
    v6 = v5[i] + ***v11;
    if ( v6 > a2 )
    {
      for ( j = *v11 + 1; ; a2 -= *(j + v6) )
      {
        v8 = a2 - v5[i];
        while ( 1 )
        {
          *((a2 >> 3) + a3) |= 1 << (a2 & 7);
          if ( (((*((a2 >> 3) + v4) >> (a2 & 7)) ^ 1) & 1) == 0 )
          {
            for ( k = v10; a2 != *k - 1; k += 2 )
              ;
            a2 = k[1] - 1;
            goto LABEL_21;
          }
          v6 = v8 - *(v11 + 2);
          if ( v6 >= 0 )
            break;
          result = *(i + a1 + 76);
          a2 = result;
          if ( result == 255 )
            return result;
          do
LABEL_21:
            v8 = a2 - v5[--i];
          while ( v8 < 0 );
          v11 = *(**(*(a1 + 4 * i + 28) + 4) + 4);
          j = *v11 + 1;
        }
      }
    }
    result = ++i;
    if ( i == v13 )
      break;
  }
  return result;
}

//----- (080C5A16) --------------------------------------------------------
int *__cdecl sub_80C5A16(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-60h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *j; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  __int16 **i; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 ***v11; // [esp+54h] [ebp-24h]
  int v12[8]; // [esp+58h] [ebp-20h] BYREF

  v3 = *(a1 + 23) - 1;
  v12[1] = *(a1 + 22);
  if ( !*(a1 + 20) )
    sub_80C5608(a1);
  v4 = sub_80A4458(*(a1 + 20));
  v10 = (v4 + 16);
  j = (v4 + 16);
  v5[0] = 0;
  for ( v12[0] = 0; ; v5[v12[0]] = v6 )
  {
    v11 = *(**(*(a1 + 4 * v12[0] + 28) + 4) + 4);
    v6 = v5[v12[0]] + ***v11;
    if ( v6 > v3 )
      break;
    ++v12[0];
  }
  for ( i = *v11 + 1; ; i = *v11 + 1 )
  {
    while ( 1 )
    {
      v8 = v3 - v5[v12[0]];
      if ( v8 < 0 )
        break;
      if ( *((v3 >> 3) + a2) || ((1 << (v3 & 7)) & 1) == 0 )
      {
        if ( (((*((v3 >> 3) + v4) >> (v3 & 7)) ^ 1) & 1) == 0 )
        {
          for ( j = v10; v3 != *j - 1; j += 2 )
            ;
          v6 = j[1] - 1;
          goto LABEL_22;
        }
        v6 = v8 - *(v11 + 2);
        if ( v6 >= 0 )
        {
          v6 = v3 - *(i + v6);
          goto LABEL_22;
        }
        v6 = *(v12[0] + a1 + 76);
        if ( v6 == 255 )
        {
          --v3;
        }
        else
        {
LABEL_22:
          *((v6 >> 3) + a2) |= 1 << (v6 & 7);
          --v3;
        }
      }
      else
      {
        --v3;
      }
    }
    result = v12;
    if ( --v12[0] < 0 )
      break;
    v11 = *(**(*(a1 + 4 * v12[0] + 28) + 4) + 4);
  }
  return result;
}

//----- (080C5C08) --------------------------------------------------------
int __cdecl sub_80C5C08(int a1, int a2)
{
  return (*(*(a1 + 4) + (a2 >> 3) + 32) >> (a2 & 7)) & 1;
}

//----- (080C5C36) --------------------------------------------------------
int __cdecl sub_80C5C36(int a1, int a2)
{
  int i; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( (*(a2 + 4 * i) & ~*(*(a1 + 4) + 4 * i + 32)) != 0 )
      return 0;
  }
  return 1;
}

//----- (080C5C96) --------------------------------------------------------
int *__cdecl sub_80C5C96(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-B0h]
  char v4; // [esp+1Fh] [ebp-A9h]
  int *v5; // [esp+20h] [ebp-A8h]
  int v6; // [esp+24h] [ebp-A4h]
  int v7; // [esp+24h] [ebp-A4h]
  float *v8; // [esp+2Ch] [ebp-9Ch]
  float *v9; // [esp+2Ch] [ebp-9Ch]
  float *v10; // [esp+30h] [ebp-98h]
  float *v11; // [esp+30h] [ebp-98h]
  float *v12; // [esp+30h] [ebp-98h]
  float *v13; // [esp+30h] [ebp-98h]
  float *v14; // [esp+30h] [ebp-98h]
  unsigned __int8 *v15; // [esp+34h] [ebp-94h]
  unsigned __int8 *v16; // [esp+34h] [ebp-94h]
  __int16 **v17; // [esp+38h] [ebp-90h]
  __int16 **v18; // [esp+38h] [ebp-90h]
  int v19; // [esp+3Ch] [ebp-8Ch]
  int v20; // [esp+40h] [ebp-88h]
  int v21; // [esp+40h] [ebp-88h]
  int v22; // [esp+40h] [ebp-88h]
  int v23; // [esp+40h] [ebp-88h]
  int v24; // [esp+40h] [ebp-88h]
  int v25; // [esp+44h] [ebp-84h]
  int v26; // [esp+48h] [ebp-80h]
  int v27; // [esp+48h] [ebp-80h]
  __int16 **v28; // [esp+4Ch] [ebp-7Ch]
  int v29[13]; // [esp+50h] [ebp-78h] BYREF
  float *v30; // [esp+84h] [ebp-44h]
  float *v31; // [esp+88h] [ebp-40h]
  float *v32; // [esp+8Ch] [ebp-3Ch]
  float *v33; // [esp+90h] [ebp-38h]
  unsigned __int8 v34; // [esp+97h] [ebp-31h]
  unsigned __int8 *v35; // [esp+98h] [ebp-30h]
  __int16 ***v36; // [esp+9Ch] [ebp-2Ch]
  int j; // [esp+A0h] [ebp-28h]
  int i; // [esp+A4h] [ebp-24h] BYREF
  float *v39; // [esp+A8h] [ebp-20h]
  float *v40; // [esp+ACh] [ebp-1Ch]

  result = *(a1 + 4);
  v5 = result;
  v4 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v29[i + 4] = v5[i + 8] | ~*(a2 + 4 * i);
    if ( v29[i + 4] != -1 )
      v4 = 0;
    result = &i;
  }
  if ( !v4 )
  {
    if ( !*(a1 + 20) )
      sub_80C5608(a1);
    v3 = sub_80A4458(*(a1 + 20));
    for ( i = 0; i <= 3; ++i )
    {
      v5[i + 8] |= *(a2 + 4 * i);
      v29[i + 8] = v5[i + 4] & ~v29[i + 4];
      v29[i] = *(v3 + 4 * i) | v29[i + 8] | v29[i + 4];
    }
    v15 = (v3 + 16);
    for ( i = 0; i <= 3; ++i )
      v29[i + 8] |= ~v29[i];
    v19 = *(a1 + 22);
    v32 = (v5 + 12);
    v31 = &v5[16 * *(a1 + 23) + 12];
    v39 = v31;
    v26 = 0;
    for ( j = 0; j < v19; ++j )
    {
      v36 = *(**(*(a1 + 4 * j + 28) + 4) + 4);
      v34 = *(j + a1 + 76);
      if ( v34 == 0xFF )
      {
        i = *(v36 + 2);
        while ( i )
        {
          v20 = 1 << (v26 & 7);
          if ( (v20 & *(&v29[8] + (v26 >> 3))) == 0 && v26 == *v15 - 1 )
          {
            v15 += 2;
            if ( (v20 & *(&v29[4] + (v26 >> 3))) == 0 )
            {
              v10 = &v31[8 * *(v15 - 1) - 8];
              *v39 = *v10;
              v39[1] = v10[1];
              v39[2] = v10[2];
              v39[3] = v10[3];
            }
          }
          --i;
          v39 += 8;
          ++v26;
        }
      }
      else
      {
        v11 = &v31[8 * v34];
        i = *(v36 + 2);
        while ( i )
        {
          v21 = 1 << (v26 & 7);
          if ( (v21 & *(v29 + (v26 >> 3))) != 0 )
          {
            if ( (v21 & *(&v29[8] + (v26 >> 3))) != 0 )
              sub_80C818E(v11, v39);
          }
          else
          {
            sub_80C8056(v39, v11);
          }
          --i;
          v39 += 8;
          ++v26;
        }
      }
      v28 = v36[3];
      v17 = *v36;
      v35 = (*v36 + 1);
      i = **v17 - *(v36 + 2);
      while ( i )
      {
        v25 = v26 >> 3;
        v22 = 1 << (v26 & 7);
        if ( (v22 & *(v29 + (v26 >> 3))) != 0 )
        {
          if ( (v22 & *(&v29[8] + v25)) != 0 )
          {
            sub_80C818E(&v39[-8 * *v35], v39);
          }
          else if ( v26 == *v15 - 1 )
          {
            v15 += 2;
            if ( (v22 & *(&v29[4] + v25)) == 0 )
            {
              v12 = &v31[8 * *(v15 - 1) - 8];
              *v39 = *v12;
              v39[1] = v12[1];
              v39[2] = v12[2];
              v39[3] = v12[3];
            }
          }
        }
        else
        {
          sub_80C8056(v39, &v39[-8 * *v35]);
        }
        --i;
        v39 += 8;
        ++v35;
        ++v26;
        v28 += 2;
      }
    }
    v16 = (v3 + 16);
    v39 = v31;
    v40 = v32;
    v27 = 0;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v19 )
        break;
      v36 = *(**(*(a1 + 4 * j + 28) + 4) + 4);
      v34 = *(j + a1 + 76);
      if ( v34 == 0xFF )
      {
        i = *(v36 + 2);
        while ( i )
        {
          v23 = 1 << (v27 & 7);
          if ( (v23 & *(&v29[8] + (v27 >> 3))) != 0 )
          {
            sub_80C7D82(v39, v40);
            v40[12] = v39[5];
            v40[13] = v39[6];
            v40[14] = v39[7];
            v40[15] = 0.0;
          }
          else if ( v27 == *v16 - 1 )
          {
            v16 += 2;
            if ( (v23 & *(&v29[4] + (v27 >> 3))) == 0 )
            {
              v6 = *(v16 - 1) - 1;
              v13 = &v31[8 * v6];
              v8 = &v32[16 * v6];
              v39[5] = v13[5];
              v39[6] = v13[6];
              v39[7] = v13[7];
              qmemcpy(v40, v8, 0x40u);
            }
          }
          --i;
          v39 += 8;
          v40 += 16;
          ++v27;
        }
      }
      else
      {
        v33 = &v32[16 * v34];
        i = *(v36 + 2);
        while ( i )
        {
          if ( ((1 << (v27 & 7)) & *(&v29[8] + (v27 >> 3))) != 0 )
          {
            sub_80C7D82(v39, v40);
            sub_80C7F9A(v39 + 5, v33);
            v40[12] = v39[5];
            v40[13] = v39[6];
            v40[14] = v39[7];
            v40[15] = 0.0;
          }
          --i;
          v39 += 8;
          v40 += 16;
          ++v27;
        }
      }
      v30 = v36[4];
      v18 = *v36;
      v35 = (*v36 + 1);
      i = **v18 - *(v36 + 2);
      while ( i )
      {
        v24 = 1 << (v27 & 7);
        if ( (v24 & *(&v29[8] + (v27 >> 3))) != 0 )
        {
          sub_80C7D82(v39, v40);
          v39[5] = v39[5] + *v30;
          v39[6] = v39[6] + v30[1];
          v39[7] = v39[7] + v30[2];
          sub_80C7F9A(v39 + 5, &v40[-16 * *v35]);
          v40[12] = v39[5];
          v40[13] = v39[6];
          v40[14] = v39[7];
          v40[15] = 0.0;
        }
        else if ( v27 == *v16 - 1 )
        {
          v16 += 2;
          if ( (v24 & *(&v29[4] + (v27 >> 3))) == 0 )
          {
            v7 = *(v16 - 1) - 1;
            v14 = &v31[8 * v7];
            v9 = &v32[16 * v7];
            v39[5] = v14[5];
            v39[6] = v14[6];
            v39[7] = v14[7];
            qmemcpy(v40, v9, 0x40u);
          }
        }
        --i;
        v39 += 8;
        v40 += 16;
        v30 += 3;
        ++v35;
        ++v27;
      }
    }
  }
  return result;
}

//----- (080C665C) --------------------------------------------------------
int __cdecl sub_80C665C(int a1, int a2)
{
  return *(a1 + 4) + (*(a2 + a1 + 84) << 6) + 48;
}

//----- (080C667A) --------------------------------------------------------
int __cdecl sub_80C667A(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-58h]
  char v8; // [esp+27h] [ebp-51h]
  char *v9; // [esp+28h] [ebp-50h]
  size_t n; // [esp+2Ch] [ebp-4Ch]
  int v11; // [esp+48h] [ebp-30h]
  __int16 v12; // [esp+4Eh] [ebp-2Ah]
  char *s; // [esp+50h] [ebp-28h]
  int v14; // [esp+54h] [ebp-24h]
  int v15; // [esp+5Ch] [ebp-1Ch]
  int j; // [esp+60h] [ebp-18h]
  int i; // [esp+64h] [ebp-14h]

  *a4 = a3;
  *(a4 + 4) = 0;
  *(a4 + 8) = 0;
  *(a4 + 18) = a5;
  *(a4 + 20) = 0;
  *(a4 + 24) = 0;
  if ( a3 )
  {
    n = *(*a3 + 4);
    *(a4 + 12) = a3 + 2 * n + (3 * n + 1) * a3[2] + 12;
    v9 = (*(a4 + 12) + 2 * n);
    v8 = *v9 + 1;
    if ( *v9 == -1 )
    {
      v8 = 1;
      sub_80C837D(v9 + 1, 0, n);
    }
    *v9 = v8;
    a3[2] = 1 - a3[2];
  }
  else
  {
    *(a4 + 12) = 0;
  }
  v7 = 0;
  v15 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v14 = *a1;
    *(a4 + 4 * v7 + 28) = *a1;
    *(v7 + a4 + 76) = -1;
    *(a4 + 2 * v7 + 60) = *(a1 + 4);
    *(v7 + a4 + 84) = v15;
    if ( a1[3] )
      *(a4 + 24) |= 1 << i;
    if ( i && (s = a1[1]) != 0 && *s )
    {
      v12 = sub_80A47E8(s);
      if ( v12 )
      {
        for ( j = 0; j < v7; ++j )
        {
          v11 = sub_80C3F8E(*(a4 + 4 * j + 28), v12);
          if ( v11 >= 0 )
          {
            *(v7 + a4 + 76) = *(j + a4 + 84) + v11;
            goto LABEL_20;
          }
        }
      }
      Com_Printf("WARNING: Part '%s' not found in model '%s' or any of its descendants\n", s, **(a4 + 28));
    }
    else
    {
LABEL_20:
      if ( v15 + ****(**(v14 + 4) + 4) > 127 )
        sub_80704AC(1, &byte_80EAA80, **(a4 + 28), 127);
      v15 += ****(**(v14 + 4) + 4);
      ++v7;
    }
    a1 += 4;
  }
  *(a4 + 22) = v7;
  result = v15;
  *(a4 + 23) = v15;
  return result;
}

//----- (080C6962) --------------------------------------------------------
int __cdecl sub_80C6962(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  size_t v4; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v5 = *a1;
  if ( *a1 )
  {
    if ( a2 )
      sub_80C0364(v5);
    v5[2] = *(a1 + 12) != (v5 + 2 * *(*v5 + 4) + 12);
    *(a1 + 12) = 0;
    *a1 = 0;
  }
  result = a1;
  if ( *(a1 + 20) )
  {
    if ( *(a1 + 20) != word_80F7338 )
    {
      v3 = sub_80A4458(*(a1 + 20));
      v4 = strlen((v3 + 16));
      sub_80A50FE(*(a1 + 20), v4 + 17);
    }
    result = a1;
    *(a1 + 20) = 0;
  }
  return result;
}
// 80F7338: using guessed type __int16 word_80F7338;

//----- (080C6A24) --------------------------------------------------------
int __cdecl sub_80C6A24(int a1)
{
  return 96 * *(a1 + 23) + 48;
}

//----- (080C6A4A) --------------------------------------------------------
_BOOL4 __cdecl sub_80C6A4A(int a1, int a2)
{
  if ( *(a1 + 8) == a2 )
    return *(a1 + 4) != 0;
  *(a1 + 8) = a2;
  *(a1 + 16) = 0;
  *(a1 + 4) = 0;
  return 0;
}

//----- (080C6AC4) --------------------------------------------------------
int *__cdecl sub_80C6AC4(int a1, int *a2)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  result = a2;
  *(a1 + 4) = a2;
  for ( i = 0; i <= 3; ++i )
  {
    a2[i] = 0;
    a2[i + 4] = 0;
    a2[i + 8] = 0;
    result = &i;
  }
  return result;
}

//----- (080C6B36) --------------------------------------------------------
int __cdecl sub_80C6B36(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_80C3FF0(*(a1 + 28), a2, a3);
}

//----- (080C6B5A) --------------------------------------------------------
int __cdecl sub_80C6B5A(int a1)
{
  return *(a1 + 4) + (*(a1 + 23) << 6) + 48;
}

//----- (080C6BF4) --------------------------------------------------------
int __cdecl sub_80C6BF4(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v7 = a3 >> 3;
  v6 = 1 << (a3 & 7);
  if ( (v6 & *(a2 + (a3 >> 3))) == 0 )
    return 0;
  v5 = *(a1 + 4);
  if ( (v6 & *(v5 + v7 + 32)) != 0 )
    return 0;
  *(v7 + v5) |= v6;
  return 1;
}

//----- (080C6C76) --------------------------------------------------------
int __cdecl sub_80C6C76(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v7 = a3 >> 3;
  v6 = 1 << (a3 & 7);
  if ( (v6 & *(a2 + (a3 >> 3))) == 0 )
    return 0;
  v5 = *(a1 + 4);
  if ( (v6 & *(v5 + v7 + 32)) != 0 )
    return 0;
  *(v5 + v7 + 16) |= v6;
  *(v7 + v5) |= v6;
  return 1;
}

//----- (080C6DE2) --------------------------------------------------------
const char *__cdecl sub_80C6DE2(int a1, int a2, int a3, int a4)
{
  const char *v5; // [esp+10h] [ebp-8h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = *(*(*(*(a1 + 4 * a2 + 28) + 4) + 20 * *(a4 + 4 * a2) + 16) + 2 * a3);
  if ( v6 )
    v5 = sub_80A4458(v6);
  else
    v5 = "DEFAULT";
  return v5;
}

//----- (080C6E48) --------------------------------------------------------
int __cdecl sub_80C6E48(int a1, int a2, void *s, int a4)
{
  int result; // eax
  int v5; // [esp+10h] [ebp-48h]
  char v6; // [esp+14h] [ebp-44h]
  char v7; // [esp+18h] [ebp-40h]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+20h] [ebp-38h]
  int v11; // [esp+24h] [ebp-34h]
  int v12; // [esp+28h] [ebp-30h]
  int k; // [esp+2Ch] [ebp-2Ch]
  int m; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+30h] [ebp-28h]
  int v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int v18; // [esp+3Ch] [ebp-1Ch]
  int i; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  int l; // [esp+44h] [ebp-14h]
  int v22; // [esp+48h] [ebp-10h]

  sub_80C837D(s, 0, 0x10u);
  v22 = *(a1 + 22);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v22 )
      break;
    if ( *(a4 + 4 * i) >= 0 )
    {
      v10 = *(*(a1 + 4 * i + 28) + 4);
      v17 = *(v10 + 20 * *(a4 + 4 * i) + 20);
      if ( v17 )
      {
        v11 = (****(*v10 + 4) - 1) >> 5;
        v16 = *(v17 + 4);
        v18 = *(v16 + 4);
        v15 = *(i + a1 + 84);
        v12 = *(v16 + 8);
        v5 = v15 >> 5;
        v7 = v15 & 0x1F;
        if ( (v15 & 0x1F) != 0 )
        {
          v6 = 32 - v7;
          for ( j = 0; j < v18; ++j )
          {
            *(a2 + 2) = j;
            *a2 = i;
            *(s + v5) |= *(*v12 + 8) << v7;
            v8 = v5 + 1;
            for ( k = 0; k < v11; ++k )
              *(s + v8++) |= (*(*v12 + 4 * k + 8) >> v6) | (*(*v12 + 4 * k + 12) << v7);
            *(s + v8) |= *(*v12 + 4 * k + 8) >> v6;
            a2 += 4;
            v12 += 4;
          }
        }
        else
        {
          for ( l = 0; l < v18; ++l )
          {
            *(a2 + 2) = l;
            *a2 = i;
            v9 = v15 >> 5;
            for ( m = 0; m <= v11; ++m )
              *(s + v9++) |= *(*v12 + 4 * m + 8);
            a2 += 4;
            v12 += 4;
          }
        }
      }
    }
  }
  return result;
}

//----- (080C70F0) --------------------------------------------------------
int __cdecl sub_80C70F0(int a1, char *s)
{
  int v3; // [esp+Ch] [ebp-Ch]
  __int16 v4; // [esp+16h] [ebp-2h]

  v4 = sub_80A480E(s);
  if ( v4 )
    v3 = sub_80C557A(a1, v4);
  else
    v3 = -1;
  return v3;
}

//----- (080C7136) --------------------------------------------------------
int __cdecl sub_80C7136(int a1, int a2)
{
  __int16 *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v6 = 0;
  for ( i = 0; i < *(a1 + 22); ++i )
  {
    v5 = *(a1 + 4 * i + 28);
    v4 = ***(**(v5 + 4) + 4);
    if ( a2 - v6 < *v4 )
      return sub_80A4458(v4[a2 - v6 + 1]);
    v6 += ****(**(v5 + 4) + 4);
  }
  return 0;
}

//----- (080C71DC) --------------------------------------------------------
int __cdecl sub_80C71DC(int a1)
{
  return *a1;
}

//----- (080C71E6) --------------------------------------------------------
int __cdecl sub_80C71E6(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(a1 + 22) - 1; i >= 0; --i )
  {
    if ( sub_80C1852(*(a1 + 4 * i + 28)) )
      return 1;
  }
  return 0;
}

//----- (080C7232) --------------------------------------------------------
int __cdecl sub_80C7232(int a1)
{
  return *(a1 + 23);
}

//----- (080C723E) --------------------------------------------------------
float *__cdecl sub_80C723E(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (080C72EA) --------------------------------------------------------
float *__cdecl sub_80C72EA(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[12];
  v5 = a1[1] - a2[13];
  v6 = a1[2] - a2[14];
  *a3 = v4 * *a2 + v5 * a2[1] + v6 * a2[2];
  a3[1] = v4 * a2[4] + v5 * a2[5] + v6 * a2[6];
  result = a2;
  a3[2] = v4 * a2[8] + v5 * a2[9] + v6 * a2[10];
  return result;
}

//----- (080C7394) --------------------------------------------------------
int __cdecl sub_80C7394(int a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  __int16 v6; // [esp+1Ah] [ebp-21Eh]
  float v7[67]; // [esp+1Ch] [ebp-21Ch]
  int v8; // [esp+128h] [ebp-110h]
  int v9; // [esp+12Ch] [ebp-10Ch]
  __int16 **v10; // [esp+130h] [ebp-108h]
  unsigned __int8 *v11; // [esp+134h] [ebp-104h]
  __int16 *v12; // [esp+138h] [ebp-100h]
  unsigned int v13; // [esp+13Ch] [ebp-FCh]
  unsigned int v14; // [esp+140h] [ebp-F8h]
  int v15; // [esp+144h] [ebp-F4h]
  int v16; // [esp+148h] [ebp-F0h]
  int v17; // [esp+14Ch] [ebp-ECh]
  int v18; // [esp+150h] [ebp-E8h]
  float v19; // [esp+154h] [ebp-E4h]
  int v20; // [esp+158h] [ebp-E0h]
  float v21; // [esp+15Ch] [ebp-DCh]
  char v22; // [esp+162h] [ebp-D6h]
  char v23; // [esp+163h] [ebp-D5h]
  __int16 **i; // [esp+164h] [ebp-D4h]
  int j; // [esp+168h] [ebp-D0h]
  float v26; // [esp+16Ch] [ebp-CCh]
  float v27; // [esp+170h] [ebp-C8h]
  float v28; // [esp+174h] [ebp-C4h]
  float v29; // [esp+178h] [ebp-C0h]
  float v30; // [esp+17Ch] [ebp-BCh]
  float v31[4]; // [esp+180h] [ebp-B8h] BYREF
  float v32[7]; // [esp+190h] [ebp-A8h] BYREF
  float v33; // [esp+1ACh] [ebp-8Ch]
  float v34; // [esp+1B0h] [ebp-88h]
  float v35; // [esp+1B4h] [ebp-84h]
  float v36; // [esp+1B8h] [ebp-80h]
  float v37; // [esp+1CCh] [ebp-6Ch]
  float v38; // [esp+1D0h] [ebp-68h]
  float v39; // [esp+1D4h] [ebp-64h]
  float v40; // [esp+1D8h] [ebp-60h]
  float v41; // [esp+1E0h] [ebp-58h]
  float v42; // [esp+1E4h] [ebp-54h]
  float v43; // [esp+1E8h] [ebp-50h]
  float v44; // [esp+1F0h] [ebp-48h] BYREF
  float v45; // [esp+1F4h] [ebp-44h]
  float v46; // [esp+1F8h] [ebp-40h]
  float *v47; // [esp+20Ch] [ebp-2Ch]
  int v48; // [esp+210h] [ebp-28h]
  float v49; // [esp+214h] [ebp-24h]
  __int16 ***v50; // [esp+218h] [ebp-20h]
  float v51; // [esp+21Ch] [ebp-1Ch]
  float v52; // [esp+220h] [ebp-18h]
  float v53; // [esp+224h] [ebp-14h]
  float v54; // [esp+228h] [ebp-10h]

  v52 = *a3 - *a2;
  v53 = a3[1] - a2[1];
  v54 = a3[2] - a2[2];
  v51 = 1.0 / (v52 * v52 + v53 * v53 + v54 * v54);
  v47 = sub_80C665C(a1, 0);
  *(a5 + 4) = 0;
  *(a5 + 24) = 0;
  *(a5 + 25) = 0;
  *(a5 + 20) = 0;
  *(a5 + 22) = 0;
  *(a5 + 16) = 0;
  *(a5 + 12) = 0;
  *(a5 + 8) = 0;
  v14 = 2;
  v16 = *(a1 + 4);
  v11 = (sub_80A4458(*(a1 + 20)) + 16);
  v17 = 0;
  v18 = -1;
  v19 = 0.0;
  v15 = 0;
LABEL_2:
  result = *(a1 + 22);
  if ( v15 < result )
  {
    v50 = *(**(*(a1 + 4 * v15 + 28) + 4) + 4);
    v12 = **v50;
    v48 = *v12;
    v9 = *(a1 + 24) & (1 << v15);
    v20 = 0;
    while ( 1 )
    {
      if ( v20 >= v48 )
      {
        ++v15;
        goto LABEL_2;
      }
      LOWORD(v8) = *(v50[5] + v20);
      v13 = *(v8 + a4);
      if ( v17 == *v11 - 1 )
      {
        v11 += 2;
        if ( v13 == 1 )
        {
          LOWORD(v8) = *(v7 + *(v11 - 1) + 1);
          v13 = *(v8 + a4);
        }
      }
      else if ( v13 == 1 )
      {
        if ( v20 >= *(v50 + 2) )
        {
          LOWORD(v8) = *(&v7[1] + v17 - *(*v50 + v20 - *(v50 + 2) + 4));
        }
        else
        {
          HIBYTE(v8) = *(v15 + a1 + 76);
          if ( HIBYTE(v8) == 0xFF )
            v6 = 0;
          else
            v6 = *(&v7[1] + HIBYTE(v8));
          LOWORD(v8) = v6;
        }
        v13 = *(v8 + a4);
      }
      *(&v7[1] + v17) = v8;
      if ( !v9 )
      {
        v10 = &v50[2][10 * v20];
        if ( *(v10 + 9) != 0.0 && v14 <= v13 )
        {
          sub_80C723E(v10 + 6, v47, &v44);
          v41 = *a2 - v44;
          v42 = a2[1] - v45;
          v43 = a2[2] - v46;
          v37 = -(v41 * v52 + v42 * v53 + v43 * v54) * v51;
          if ( v37 >= 1.0 )
          {
            v38 = *a3 - v44;
            v39 = a3[1] - v45;
            v40 = a3[2] - v46;
            v49 = v38 * v38 + v39 * v39 + v40 * v40;
          }
          else if ( v37 <= 0.0 )
          {
            v49 = v41 * v41 + v42 * v42 + v43 * v43;
          }
          else
          {
            v34 = v52 * v37 + v41;
            v35 = v53 * v37 + v42;
            v36 = v54 * v37 + v43;
            v49 = v34 * v34 + v35 * v35 + v36 * v36;
          }
          v33 = *(v10 + 9) - v49;
          if ( v33 > 0.0 )
          {
            if ( v14 != v13 || (v7[0] = sqrt(v33 * v51), v37 - v7[0] < *a5) )
            {
              sub_80C72EA(a2, v47, v32);
              sub_80C72EA(a3, v47, v31);
              v30 = 0.0;
              v29 = *a5;
              v23 = 1;
              v22 = 1;
              v21 = -1.0;
              for ( i = v10; ; i += 3 )
              {
                for ( j = 0; j <= 2; ++j )
                {
                  v28 = (v32[j] - *&i[j]) * v21;
                  v27 = (v31[j] - *&i[j]) * v21;
                  if ( v28 <= 0.0 )
                  {
                    if ( v27 > 0.0 )
                    {
                      v22 = 0;
                      v26 = v28 - v27;
                      if ( v28 > v29 * v26 )
                      {
                        v29 = v28 / v26;
                        if ( v30 >= v29 )
                          goto LABEL_49;
                      }
                    }
                  }
                  else
                  {
                    if ( v27 > 0.0 )
                      goto LABEL_49;
                    v23 = 0;
                    v26 = v28 - v27;
                    if ( v28 > v30 * v26 )
                    {
                      v30 = v28 / v26;
                      if ( v30 >= v29 )
                        goto LABEL_49;
                      v19 = v21;
                      v18 = j;
                    }
                  }
                }
                if ( v21 == 1.0 )
                  break;
                v21 = 1.0;
              }
              if ( v23 )
              {
                *(a5 + 24) = 1;
                if ( v22 )
                {
                  *(a5 + 25) = 1;
                  *a5 = 0;
                  *(a5 + 20) = v12[v20 + 1];
                  *(a5 + 22) = v8;
                  result = 0;
                  *(a5 + 16) = 0;
                  *(a5 + 12) = 0;
                  *(a5 + 8) = 0;
                  return result;
                }
              }
              else
              {
                if ( v14 == v13 )
                {
                  if ( v30 >= *a5 )
                    goto LABEL_49;
                }
                else
                {
                  v14 = v13;
                }
                *a5 = v30;
                *(a5 + 20) = v12[v20 + 1];
                *(a5 + 22) = v8;
                *(a5 + 8) = v47[4 * v18] * v19;
                *(a5 + 12) = v47[4 * v18 + 1] * v19;
                *(a5 + 16) = v47[4 * v18 + 2] * v19;
              }
            }
          }
        }
      }
LABEL_49:
      ++v20;
      v47 += 16;
      ++v17;
    }
  }
  return result;
}

//----- (080C7BE8) --------------------------------------------------------
int __cdecl sub_80C7BE8(int a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // [esp+28h] [ebp-50h]
  __int16 *v7; // [esp+2Ch] [ebp-4Ch]
  int i; // [esp+30h] [ebp-48h]
  int v9; // [esp+34h] [ebp-44h]
  int v10; // [esp+3Ch] [ebp-3Ch]
  int v11[4]; // [esp+40h] [ebp-38h] BYREF
  int v12; // [esp+50h] [ebp-28h]
  int v13; // [esp+54h] [ebp-24h]
  int v14; // [esp+58h] [ebp-20h]
  int v15; // [esp+5Ch] [ebp-1Ch]

  v9 = sub_80C665C(a1, 0);
  *(a5 + 20) = 0;
  *(a5 + 22) = 0;
  *(a5 + 24) = 0;
  *(a5 + 25) = 0;
  v11[0] = *a5;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *(a1 + 22); ++i )
  {
    v10 = *(a1 + 4 * i + 28);
    v7 = ***(**(v10 + 4) + 4);
    v6 = sub_80C4892(v10, v11, v9, a2, a3, a4);
    if ( v6 >= 0 )
      *(a5 + 20) = v7[v6 + 1];
    v9 += *v7 << 6;
  }
  *a5 = v11[0];
  *(a5 + 4) = v15;
  *(a5 + 8) = v12;
  *(a5 + 12) = v13;
  result = v14;
  *(a5 + 16) = v14;
  return result;
}

//----- (080C7D10) --------------------------------------------------------
int __cdecl sub_80C7D10(int a1, int a2, float a3)
{
  return sub_80C45AE(*(a1 + 4 * a2 + 28), a3);
}

//----- (080C7D32) --------------------------------------------------------
int __cdecl sub_80C7D32(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(a1 + 22); ++i )
  {
    if ( (a2 & sub_80C4334(*(a1 + 4 * i + 28))) != 0 )
      return 1;
  }
  return 0;
}

//----- (080C7D82) --------------------------------------------------------
float *__cdecl sub_80C7D82(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-30h]
  float v4; // [esp+4h] [ebp-2Ch]
  float v5; // [esp+8h] [ebp-28h]
  float v6; // [esp+8h] [ebp-28h]
  float v7; // [esp+Ch] [ebp-24h]
  float v8; // [esp+10h] [ebp-20h]
  float v9; // [esp+10h] [ebp-20h]
  float v10; // [esp+14h] [ebp-1Ch]
  float v11; // [esp+18h] [ebp-18h]
  float v12; // [esp+1Ch] [ebp-14h]
  float v13; // [esp+1Ch] [ebp-14h]
  float v14; // [esp+20h] [ebp-10h]
  float v15; // [esp+24h] [ebp-Ch]
  float v16; // [esp+28h] [ebp-8h]
  float v17; // [esp+2Ch] [ebp-4h]
  float v18; // [esp+2Ch] [ebp-4h]

  v17 = *a1 * *a1;
  v12 = a1[1] * a1[1];
  v8 = a1[2] * a1[2];
  v5 = v17 + v12 + v8 + a1[3] * a1[3];
  if ( v5 == 0.0 )
  {
    *a2 = 1.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
    a2[3] = 0.0;
    a2[4] = 0.0;
    a2[5] = 1.0;
    a2[6] = 0.0;
    a2[7] = 0.0;
    a2[8] = 0.0;
    a2[9] = 0.0;
    a2[10] = 1.0;
  }
  else
  {
    v6 = 2.0 / v5;
    v18 = v17 * v6;
    v13 = v12 * v6;
    v9 = v8 * v6;
    v4 = *a1 * v6;
    v16 = v4 * a1[1];
    v15 = v4 * a1[2];
    v14 = v4 * a1[3];
    v3 = a1[1] * v6;
    v11 = v3 * a1[2];
    v10 = v3 * a1[3];
    v7 = a1[2] * a1[3] * v6;
    *a2 = 1.0 - (v13 + v9);
    a2[1] = v16 + v7;
    a2[2] = v15 - v10;
    a2[3] = 0.0;
    a2[4] = v16 - v7;
    a2[5] = 1.0 - (v18 + v9);
    a2[6] = v11 + v14;
    a2[7] = 0.0;
    a2[8] = v15 + v10;
    a2[9] = v11 - v14;
    a2[10] = 1.0 - (v18 + v13);
  }
  result = a2;
  a2[11] = 0.0;
  return result;
}

//----- (080C7F9A) --------------------------------------------------------
int __cdecl sub_80C7F9A(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  v4 = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  a1[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  *a1 = v3;
  result = LODWORD(v4);
  a1[1] = v4;
  return result;
}

//----- (080C8056) --------------------------------------------------------
int __cdecl sub_80C8056(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a1[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a1 = v3;
  a1[1] = v4;
  result = LODWORD(v5);
  a1[2] = v5;
  return result;
}

//----- (080C818E) --------------------------------------------------------
int __cdecl sub_80C818E(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a2[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a2 = v3;
  a2[1] = v4;
  result = LODWORD(v5);
  a2[2] = v5;
  return result;
}

//----- (080C82C8) --------------------------------------------------------
int __cdecl sub_80C82C8(char *name)
{
  int v3; // [esp+Ch] [ebp-Ch]
  struct dirent *v4; // [esp+10h] [ebp-8h]
  DIR *dirp; // [esp+14h] [ebp-4h]

  v3 = 0;
  dirp = opendir(name);
  if ( !dirp )
    return 0;
  while ( 1 )
  {
    v4 = readdir(dirp);
    if ( !v4 )
      break;
    if ( strcmp(v4->d_name, ".") && strcmp(v4->d_name, "..") )
    {
      v3 = 1;
      break;
    }
  }
  closedir(dirp);
  return v3;
}

//----- (080C835C) --------------------------------------------------------
void *__cdecl sub_80C835C(void *dest, void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (080C837D) --------------------------------------------------------
void *__cdecl sub_80C837D(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (080C83CD) --------------------------------------------------------
void sub_80C83CD()
{
  sub_8085206();
  sub_80851FC();
}

//----- (080C83DF) --------------------------------------------------------
ssize_t sub_80C83DF()
{
  ssize_t result; // eax
  char buf; // [esp+17h] [ebp-1h] BYREF

  do
    result = read(0, &buf, 1u);
  while ( result != -1 );
  return result;
}

//----- (080C8408) --------------------------------------------------------
ssize_t sub_80C8408()
{
  char buf; // [esp+17h] [ebp-1h] BYREF

  buf = 8;
  write(1, &buf, 1u);
  buf = 32;
  write(1, &buf, 1u);
  buf = 8;
  return write(1, &buf, 1u);
}

//----- (080C846D) --------------------------------------------------------
int sub_80C846D()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( dword_80F734C )
  {
    ++dword_80F734C;
  }
  else
  {
    if ( dword_8456B20 > 0 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_8456B20 )
          break;
        sub_80C8408();
      }
    }
    ++dword_80F734C;
  }
  return result;
}
// 80F734C: using guessed type int dword_80F734C;
// 8456B20: using guessed type int dword_8456B20;

//----- (080C84B5) --------------------------------------------------------
int sub_80C84B5()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( !--dword_80F734C && dword_8456B20 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_8456B20 )
        break;
      write(1, (i + 138767164), 1u);
    }
  }
  return result;
}
// 80F734C: using guessed type int dword_80F734C;
// 8456B20: using guessed type int dword_8456B20;

//----- (080C8510) --------------------------------------------------------
int sub_80C8510()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]

  if ( dword_80F7348 )
  {
    Com_Printf("Shutdown tty console\n", v1);
    result = tcsetattr(0, 1, &termios_p);
  }
  return result;
}
// 80C8526: variable 'v1' is possibly undefined
// 80F7348: using guessed type int dword_80F7348;

//----- (080C8549) --------------------------------------------------------
unsigned int __cdecl sub_80C8549(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  const void *v3; // [esp+4h] [ebp-20h]
  char *v4; // [esp+8h] [ebp-1Ch]
  unsigned int v5; // [esp+Ch] [ebp-18h]
  const void *v6; // [esp+10h] [ebp-14h]
  void *v7; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]

  for ( i = 31; i > 0; --i )
  {
    v7 = (284 * i + 138767424);
    v6 = (284 * i + 138767140);
    v5 = 284;
    if ( ((28 * i + 64) & 4) != 0 )
    {
      dword_8456C40[71 * i] = *(&unk_8456B24 + 71 * i);
      v7 = (284 * i + 138767428);
      v6 = (284 * i + 138767144);
      v5 = 280;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
  }
  v4 = dword_8456C40;
  v3 = a1;
  v2 = 284;
  result = dword_8456C40 & 4;
  if ( (dword_8456C40 & 4) != 0 )
  {
    result = *a1;
    dword_8456C40[0] = *a1;
    v4 = &dword_8456C40[1];
    v3 = a1 + 1;
    v2 = 280;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  if ( dword_80F735C <= 31 )
    ++dword_80F735C;
  dword_80F7358 = -1;
  return result;
}
// 80F7358: using guessed type int dword_80F7358;
// 80F735C: using guessed type int dword_80F735C;

//----- (080C8625) --------------------------------------------------------
int sub_80C8625()
{
  if ( dword_80F7358 + 1 >= dword_80F735C )
    return 0;
  ++dword_80F7358;
  return 284 * dword_80F7358 + 138767424;
}
// 80F7358: using guessed type int dword_80F7358;
// 80F735C: using guessed type int dword_80F735C;

//----- (080C8666) --------------------------------------------------------
int sub_80C8666()
{
  int v1; // [esp+0h] [ebp-4h]

  if ( dword_80F7358 >= 0 )
    --dword_80F7358;
  if ( dword_80F7358 == -1 )
    v1 = 0;
  else
    v1 = 284 * dword_80F7358 + 138767424;
  return v1;
}
// 80F7358: using guessed type int dword_80F7358;

//----- (080C86A5) --------------------------------------------------------
void __cdecl __noreturn sub_80C86A5(int status)
{
  sub_80C8510();
  if ( byte_80F7360 )
  {
    sleep(1u);
    sub_80C984F(&byte_80F7360);
    sleep(1u);
  }
  _exit(status);
}

//----- (080C86E8) --------------------------------------------------------
void __noreturn sub_80C86E8()
{
  int v0; // eax

  sub_8085138();
  sub_807300E();
  sub_8060376();
  sub_806C3AB();
  v0 = fcntl(0, 3, 0);
  fcntl(0, 4, v0 & 0xFFFFF7FF);
  sub_80C86A5(0);
}
// 80C86E8: using guessed type void __noreturn sub_80C86E8();

//----- (080C8749) --------------------------------------------------------
void sub_80C8749()
{
  char *v0; // eax

  sub_8060272("in_restart", sub_80C83CD);
  sub_8073798("arch", "linux i386");
  v0 = sub_80CB235();
  sub_8073798("username", v0);
  sub_80851FC();
}

//----- (080C8793) --------------------------------------------------------
void __noreturn sub_80C8793(char *format, ...)
{
  int v1; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  v1 = fcntl(0, 3, 0);
  fcntl(0, 4, v1 & 0xFFFFF7FF);
  if ( dword_80F7348 )
    sub_80C846D();
  sub_8085138();
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  fprintf(stderr, "Sys_Error: %s\n", s);
  sub_80C86A5(1);
}
// 80F7348: using guessed type int dword_80F7348;

//----- (080C88D3) --------------------------------------------------------
void handler()
{
  signal(8, handler);
}

//----- (080C88EF) --------------------------------------------------------
void sub_80C88EF()
{
  struct termios s; // [esp+10h] [ebp-48h] BYREF

  memset(&s, 0, sizeof(s));
  signal(21, 1);
  signal(22, 1);
  dword_80F7344 = sub_8073114("ttycon", "1", 0);
  if ( !dword_80F7344 || *(dword_80F7344 + 28) == 0.0 )
  {
    dword_80F7348 = 0;
  }
  else if ( isatty(0) == 1 )
  {
    Com_Printf("Started tty console (use +set ttycon 0 to disable)\n");
    sub_8072140(&dword_8456B20);
    tcgetattr(0, &termios_p);
    dword_80F7350 = s.c_cc[2];
    dword_80F7354 = s.c_cc[4];
    qmemcpy(&s, &termios_p, sizeof(s));
    s.c_lflag &= 0xFFFFFFF5;
    s.c_iflag &= 0xFFFFFFCF;
    s.c_cc[6] = 1;
    s.c_cc[5] = 0;
    tcsetattr(0, 1, &s);
    dword_80F7348 = 1;
  }
  else
  {
    Com_Printf("stdin is not a tty, tty console mode failed\n");
    sub_8073798("ttycon", "0");
    dword_80F7348 = 0;
  }
}
// 80F7344: using guessed type int dword_80F7344;
// 80F7348: using guessed type int dword_80F7348;
// 80F7350: using guessed type int dword_80F7350;
// 80F7354: using guessed type int dword_80F7354;
// 8456B20: using guessed type int dword_8456B20;

//----- (080C8A5E) --------------------------------------------------------
char *sub_80C8A5E()
{
  unsigned int v1; // [esp+24h] [ebp-D4h]
  int *v2; // [esp+28h] [ebp-D0h]
  int *v3; // [esp+2Ch] [ebp-CCh]
  unsigned int v4; // [esp+30h] [ebp-C8h]
  int *v5; // [esp+34h] [ebp-C4h]
  int *v6; // [esp+38h] [ebp-C0h]
  char *v7; // [esp+3Ch] [ebp-BCh]
  struct timeval timeout; // [esp+48h] [ebp-B0h] BYREF
  fd_set readfds; // [esp+50h] [ebp-A8h] BYREF
  ssize_t v10; // [esp+DCh] [ebp-1Ch]
  int *v11; // [esp+E0h] [ebp-18h]
  char buf; // [esp+E7h] [ebp-11h] BYREF
  ssize_t v13; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  buf = 0;
  if ( !dword_80F7344 || *(dword_80F7344 + 28) == 0.0 )
  {
    if ( !dword_84886E0 || *(dword_84886E0 + 28) == 0.0 )
      return 0;
    if ( !dword_80F7340 )
      return 0;
    memset(&readfds, 0, sizeof(readfds));
    readfds.__fds_bits[0] |= 1u;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    if ( select(1, &readfds, 0, 0, &timeout) == -1 || !_bittest(readfds.__fds_bits, 0) )
      return 0;
    v10 = read(0, ::buf, 0x100u);
    if ( v10 )
    {
      if ( v10 > 0 )
      {
        *(v10 + 138766815) = 0;
        v7 = ::buf;
      }
      else
      {
        v7 = 0;
      }
    }
    else
    {
      dword_80F7340 = 0;
      v7 = 0;
    }
    return v7;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 )
    return 0;
  if ( buf == dword_80F7350 || buf == 127 || buf == 8 )
  {
    if ( dword_8456B20 > 0 )
    {
      *(--dword_8456B20 + 138767164) = 0;
      sub_80C8408();
    }
    return 0;
  }
  if ( !buf || buf > 31 )
  {
    *(dword_8456B20 + 138767164) = buf;
    ++dword_8456B20;
    write(1, &buf, 1u);
    return 0;
  }
  if ( buf == 10 )
  {
    sub_80C8549(&dword_8456B20);
    strcpy(::buf, &byte_8456B3C);
    sub_8072140(&dword_8456B20);
    buf = 10;
    write(1, &buf, 1u);
    return ::buf;
  }
  if ( buf == 9 )
  {
    sub_80C846D();
    sub_80723B4(&dword_8456B20);
    dword_8456B20 = strlen(&byte_8456B3C);
    if ( dword_8456B20 > 0 && byte_8456B3C == 92 )
    {
      for ( i = 0; i <= dword_8456B20; ++i )
        *(i + 138767164) = *(i + 138767165);
      --dword_8456B20;
    }
    sub_80C84B5();
    return 0;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 || buf != 91 && buf != 79 || (v13 = read(0, &buf, 1u), v13 == -1) )
  {
LABEL_46:
    Com_DPrintf("droping ISCTL sequence: %d, tty_erase: %d\n", buf, dword_80F7350);
    sub_80C83DF();
    return 0;
  }
  if ( buf == 66 )
  {
    v11 = sub_80C8666();
    sub_80C846D();
    if ( v11 )
    {
      v3 = &dword_8456B20;
      v2 = v11;
      v1 = 284;
      if ( (&dword_8456B20 & 4) != 0 )
      {
        dword_8456B20 = *v11;
        v3 = &dword_8456B20 + 1;
        v2 = v11 + 1;
        v1 = 280;
      }
      qmemcpy(v3, v2, 4 * (v1 >> 2));
    }
    else
    {
      sub_8072140(&dword_8456B20);
    }
    sub_80C84B5();
    sub_80C83DF();
    return 0;
  }
  if ( buf > 66 )
  {
    if ( buf == 67 )
      return 0;
    if ( buf == 68 )
      return 0;
    goto LABEL_46;
  }
  if ( buf != 65 )
    goto LABEL_46;
  v11 = sub_80C8625();
  if ( v11 )
  {
    sub_80C846D();
    v6 = &dword_8456B20;
    v5 = v11;
    v4 = 284;
    if ( (&dword_8456B20 & 4) != 0 )
    {
      dword_8456B20 = *v11;
      v6 = &dword_8456B20 + 1;
      v5 = v11 + 1;
      v4 = 280;
    }
    qmemcpy(v6, v5, 4 * (v4 >> 2));
    sub_80C84B5();
  }
  sub_80C83DF();
  return 0;
}
// 80F7340: using guessed type int dword_80F7340;
// 80F7344: using guessed type int dword_80F7344;
// 80F7350: using guessed type int dword_80F7350;
// 8456B20: using guessed type int dword_8456B20;
// 84886E0: using guessed type int dword_84886E0;

//----- (080C8FC8) --------------------------------------------------------
char *__cdecl sub_80C8FC8(void *handle)
{
  char *result; // eax
  char v2; // [esp+4h] [ebp-14h]

  if ( !handle )
    return Com_Printf("Sys_UnloadDll(NULL)\n", v2);
  dlclose(handle);
  result = dlerror();
  if ( result )
    result = Com_Printf("Sys_UnloadGame failed on dlclose: \"%s\"!\n", result);
  return result;
}
// 80C8FDB: variable 'v2' is possibly undefined

//----- (080C9010) --------------------------------------------------------
void sub_80C9010()
{
  ;
}

//----- (080C901A) --------------------------------------------------------
int sub_80C901A()
{
  return 0;
}

//----- (080C9024) --------------------------------------------------------
int sub_80C9024()
{
  return 0;
}

//----- (080C902E) --------------------------------------------------------
void __noreturn sub_80C902E()
{
  fprintf(stderr, "OUT OF MEMORY! ABORTING!!!\n");
  exit(-1);
}
// 80C902E: using guessed type void __noreturn sub_80C902E();

//----- (080C9055) --------------------------------------------------------
void __noreturn sub_80C9055()
{
  sub_80704AC(0, "Unable to load shared library\n");
}

//----- (080C9071) --------------------------------------------------------
void *__cdecl sub_80C9071(const char *a1, char *dest, int a3, int a4)
{
  char *v4; // eax
  char *v5; // eax
  void *v7; // [esp+18h] [ebp-230h]
  char *v8; // [esp+1Ch] [ebp-22Ch]
  char file[256]; // [esp+20h] [ebp-228h] BYREF
  char *v10; // [esp+120h] [ebp-128h]
  char *v11; // [esp+124h] [ebp-124h]
  char *v12; // [esp+128h] [ebp-120h]
  char *v13; // [esp+12Ch] [ebp-11Ch]
  char s[264]; // [esp+130h] [ebp-118h] BYREF
  void (__cdecl *v15)(int); // [esp+238h] [ebp-10h]
  void *handle; // [esp+23Ch] [ebp-Ch]

  *dest = 0;
  snprintf(s, 0x100u, "%s.mp.uo.i386.so", a1);
  v13 = sub_80CB05A();
  v12 = sub_8073B14("fs_homepath");
  v11 = sub_8073B14("fs_basepath");
  v10 = sub_8073B14("fs_game");
  sub_8060B06(v12, v10, s, file);
  Com_Printf("Sys_LoadDll(%s)... ", file);
  handle = dlopen(file, 2);
  if ( handle )
  {
    Com_Printf("ok\n");
  }
  else
  {
    Com_Printf("failed\n");
    sub_8060B06(v11, v10, s, file);
    Com_Printf("Sys_LoadDll(%s)... ", file);
    handle = dlopen(file, 2);
    if ( handle )
    {
      Com_Printf("ok\n");
    }
    else
    {
      v4 = dlerror();
      Com_Printf("\nSys_LoadDll(%s) failed:\n\"%s\"\n", file, v4);
    }
    if ( !handle )
    {
      Com_Printf("Sys_LoadDll(%s) failed dlopen() completely!\n", a1);
      return 0;
    }
  }
  Q_strncpyz(dest, file, 64);
  v15 = dlsym(handle, "dllEntry");
  *a3 = dlsym(handle, "vmMain");
  if ( *a3 && v15 )
  {
    Com_Printf("Sys_LoadDll(%s) found **vmMain** at  %p  \n", a1, *a3);
    v15(a4);
    Com_Printf("Sys_LoadDll(%s) succeeded!\n", a1);
    v7 = handle;
  }
  else
  {
    v5 = dlerror();
    Com_Printf("Sys_LoadDll(%s) failed dlsym(vmMain):\n\"%s\" !\n", a1, v5);
    dlclose(handle);
    v8 = dlerror();
    if ( v8 )
      Com_Printf("Sys_LoadDll(%s) failed dlcose:\n\"%s\"\n", a1, v8);
    v7 = 0;
  }
  return v7;
}

//----- (080C934E) --------------------------------------------------------
void sub_80C934E()
{
  ;
}

//----- (080C9353) --------------------------------------------------------
int __cdecl sub_80C9353(int a1, int a2, int a3, int a4)
{
  return sub_8062853(a1, a3 * a2, a4);
}

//----- (080C9378) --------------------------------------------------------
int __cdecl sub_80C9378(int a1, int off, int a3)
{
  return sub_8062AD4(a1, off, a3);
}

//----- (080C9399) --------------------------------------------------------
int __cdecl sub_80C9399(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int *v7; // [esp+4h] [ebp-4h]

  v7 = &dword_850D7C0[6 * dword_80F7760];
  if ( dword_80F7760 - dword_80F7764 > 255 )
  {
    Com_Printf("Sys_QueEvent: overflow\n");
    if ( v7[5] )
      sub_806BB25(v7[5]);
    ++dword_80F7764;
  }
  ++dword_80F7760;
  if ( !a1 )
    a1 = sub_80CA93C();
  *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  v7[3] = a4;
  v7[4] = a5;
  result = a6;
  v7[5] = a6;
  return result;
}
// 80F7760: using guessed type int dword_80F7760;
// 80F7764: using guessed type int dword_80F7764;
// 850D7C0: using guessed type int dword_850D7C0[];

//----- (080C9445) --------------------------------------------------------
_DWORD *__stdcall sub_80C9445(_DWORD *a1)
{
  int v1; // edx
  size_t size; // [esp+28h] [ebp-80h]
  _DWORD *sizea; // [esp+28h] [ebp-80h]
  char *dest; // [esp+2Ch] [ebp-7Ch]
  char *desta; // [esp+2Ch] [ebp-7Ch]
  int v7[8]; // [esp+30h] [ebp-78h] BYREF
  char v8[4]; // [esp+50h] [ebp-58h] BYREF
  void *src; // [esp+54h] [ebp-54h]
  size_t n; // [esp+5Ch] [ebp-4Ch]
  char *s; // [esp+7Ch] [ebp-2Ch]
  int v12[10]; // [esp+80h] [ebp-28h] BYREF

  if ( dword_80F7760 > dword_80F7764 )
    goto LABEL_2;
  sub_808520B();
  s = sub_80C8A5E();
  if ( s )
  {
    size = strlen(s) + 1;
    dest = sub_806BB38(size);
    strcpy(dest, s);
    sub_80C9399(0, 5, 0, 0, size, dest);
  }
  sub_8085201();
  MSG_Init(v8, &unk_850EFE0, 0x8000);
  if ( sub_80C9ED8(v7, v8) )
  {
    desta = (n + 20);
    sizea = sub_806BB38(n + 20);
    *sizea = v7[0];
    sizea[1] = v7[1];
    sizea[2] = v7[2];
    sizea[3] = v7[3];
    sizea[4] = v7[4];
    memcpy(sizea + 5, src, n);
    sub_80C9399(0, 6, 0, 0, desta, sizea);
  }
  if ( dword_80F7760 > dword_80F7764 )
  {
LABEL_2:
    v1 = 6 * dword_80F7764++;
    *a1 = dword_850D7C0[v1];
    a1[1] = dword_850D7C4[v1];
    a1[2] = dword_850D7C8[v1];
    a1[3] = dword_850D7CC[v1];
    a1[4] = dword_850D7D0[v1];
    a1[5] = dword_850D7D4[v1];
  }
  else
  {
    memset(v12, 0, 0x18u);
    v12[0] = sub_80CA93C();
    *a1 = v12[0];
    a1[1] = v12[1];
    a1[2] = v12[2];
    a1[3] = v12[3];
    a1[4] = v12[4];
    a1[5] = v12[5];
  }
  return a1;
}
// 80F7760: using guessed type int dword_80F7760;
// 80F7764: using guessed type int dword_80F7764;
// 850D7C0: using guessed type int dword_850D7C0[];
// 850D7C4: using guessed type int dword_850D7C4[];
// 850D7C8: using guessed type int dword_850D7C8[];
// 850D7CC: using guessed type int dword_850D7CC[];
// 850D7D0: using guessed type int dword_850D7D0[];
// 850D7D4: using guessed type int dword_850D7D4[];

//----- (080C96E0) --------------------------------------------------------
int __cdecl sub_80C96E0(char *s)
{
  int result; // eax

  if ( dword_80F7348 )
    sub_80C846D();
  result = fputs(s, stderr);
  if ( dword_80F7348 )
    result = sub_80C84B5();
  return result;
}
// 80F7348: using guessed type int dword_80F7348;

//----- (080C9718) --------------------------------------------------------
void sub_80C9718()
{
  ;
}

//----- (080C9723) --------------------------------------------------------
int __cdecl sub_80C9723(const char *a1)
{
  fprintf(stdout, "\n\n%s\n", "==============================================================");
  fprintf(stdout, "Linux Quake3 Dedicated Server [%s %s]\n", "Feb 10 2005", "15:44:04");
  fprintf(stdout, " local install: %s\n", a1);
  return fprintf(stdout, "%s\n\n", "==============================================================");
}

//----- (080C984F) --------------------------------------------------------
__pid_t __cdecl sub_80C984F(char *s)
{
  __pid_t result; // eax

  result = fork();
  if ( result != -1 && !result )
  {
    if ( strchr(s, 32) )
      system(s);
    else
      execl(s, s, 0);
    _exit(0);
  }
  return result;
}

//----- (080C98B7) --------------------------------------------------------
void __cdecl sub_80C98B7(char *src, int a2)
{
  if ( a2 )
  {
    Com_DPrintf("Sys_StartProcess %s (delaying to final exit)\n", src);
    Q_strncpyz(&byte_80F7360, src, 1024);
    sub_805FAF4(2, "quit\n");
  }
  else
  {
    Com_DPrintf("Sys_StartProcess %s\n", src);
    sub_80C984F(src);
  }
}

//----- (080C9B14) --------------------------------------------------------
void __cdecl sub_80C9B14(int a1, const char **a2)
{
  if ( a1 == 2 && (!strcmp(a2[1], "--version") || !strcmp(a2[1], "-v")) )
  {
    sub_80C9723(*a2);
    sub_80C86A5(0);
  }
}

//----- (080C9B73) --------------------------------------------------------
void __cdecl __noreturn main(int a1, char **a2)
{
  void *v2; // esp
  __uid_t v3; // eax
  void *v4; // esp
  int v5; // eax
  char *dest; // [esp+Ch] [ebp-Ch] BYREF
  int i; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v2 = alloca(0);
  dword_850D7AC = geteuid();
  v3 = getuid();
  seteuid(v3);
  sub_80C9B14(a1, a2);
  sub_80CB082(&byte_80EB05F);
  v8 = 1;
  for ( i = 1; i < a1; ++i )
    v8 += strlen(a2[i]) + 1;
  v4 = alloca(16 * ((v8 + 15) >> 4));
  dest = &dest;
  LOBYTE(dest) = 0;
  for ( i = 1; i < a1; ++i )
  {
    if ( i > 1 )
      strcat(dest, " ");
    strcat(dest, a2[i]);
  }
  memset(dword_850D7C0, 0, 0x1800u);
  memset(&unk_850EFE0, 0, 0x8000u);
  sub_807154E(dest);
  sub_80CA5E0();
  sub_80C88EF();
  v5 = fcntl(0, 3, 0);
  fcntl(0, 4, v5 | 0x800);
  sub_80B6BC0();
  while ( 1 )
  {
    sub_80C9718();
    usleep(0x1388u);
    sub_8071E2E();
    sub_80B6C0E();
  }
}
// 850D7AC: using guessed type int dword_850D7AC;
// 850D7C0: using guessed type int dword_850D7C0[];

//----- (080C9D0C) --------------------------------------------------------
int __cdecl sub_80C9D0C(int a1, void *s)
{
  int result; // eax

  memset(s, 0, 0x10u);
  if ( *a1 == 3 )
  {
    *s = 2;
    *(s + 1) = *(a1 + 18);
    result = s + 4;
    *(s + 1) = -1;
  }
  else
  {
    result = a1;
    if ( *a1 == 4 )
    {
      *s = 2;
      *(s + 1) = *(a1 + 4);
      result = *(a1 + 18);
      *(s + 1) = result;
    }
  }
  return result;
}

//----- (080C9D89) --------------------------------------------------------
int __cdecl sub_80C9D89(int a1, int a2)
{
  int result; // eax

  *(a2 + 4) = *(a1 + 4);
  *(a2 + 18) = *(a1 + 2);
  result = a2;
  *a2 = 4;
  return result;
}

//----- (080C9DFE) --------------------------------------------------------
int __cdecl sub_80C9DFE(char *cp, void *s)
{
  struct hostent *v4; // [esp+10h] [ebp-8h]

  memset(s, 0, 0x10u);
  *s = 2;
  *(s + 1) = 0;
  if ( *cp > 47 && *cp <= 57 )
  {
    *(s + 1) = inet_addr(cp);
    return 1;
  }
  v4 = gethostbyname(cp);
  if ( v4 )
  {
    *(s + 1) = **v4->h_addr_list;
    return 1;
  }
  return 0;
}

//----- (080C9E95) --------------------------------------------------------
int __cdecl sub_80C9E95(char *cp, int a2)
{
  char s[24]; // [esp+20h] [ebp-18h] BYREF

  if ( !sub_80C9DFE(cp, s) )
    return 0;
  sub_80C9D89(s, a2);
  return 1;
}

//----- (080C9ED8) --------------------------------------------------------
int __cdecl sub_80C9ED8(int *a1, int a2)
{
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  int v7; // [esp+30h] [ebp-38h]
  int i; // [esp+34h] [ebp-34h]
  int fd; // [esp+38h] [ebp-30h]
  socklen_t addr_len; // [esp+3Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+40h] [ebp-28h] BYREF
  ssize_t v12; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
      fd = dword_8516FE0;
    else
      fd = dword_80F776C;
    if ( fd )
    {
      addr_len = 16;
      v12 = recvfrom(fd, *(a2 + 4), *(a2 + 8), 0, &addr, &addr_len);
      sub_80C9D89(&addr, a1);
      *(a2 + 16) = 0;
      if ( v12 == -1 )
      {
        v7 = *__errno_location();
        if ( v7 != 11 && v7 != 111 )
        {
          v2 = sub_80848F8(*a1, a1[1], a1[2], a1[3], a1[4]);
          v3 = sub_80CA82C();
          Com_Printf("NET_GetPacket: %s from %s\n", v3, v2);
        }
      }
      else
      {
        if ( v12 != *(a2 + 8) )
        {
          *(a2 + 12) = v12;
          return 1;
        }
        v4 = sub_80848F8(*a1, a1[1], a1[2], a1[3], a1[4]);
        Com_Printf("Oversize packet from %s\n", v4);
      }
    }
  }
  return 0;
}
// 80F776C: using guessed type int dword_80F776C;
// 8516FE0: using guessed type int dword_8516FE0;

//----- (080CA04B) --------------------------------------------------------
ssize_t __cdecl sub_80CA04B(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7)
{
  ssize_t result; // eax
  char v8; // al
  char v9; // [esp+8h] [ebp-50h]
  int fd; // [esp+2Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  ssize_t v12; // [esp+4Ch] [ebp-Ch]

  switch ( a3 )
  {
    case 3:
      result = dword_80F776C;
      fd = dword_80F776C;
      break;
    case 4:
      result = dword_80F776C;
      fd = dword_80F776C;
      break;
    case 5:
      result = dword_8516FE0;
      fd = dword_8516FE0;
      break;
    case 6:
      result = dword_8516FE0;
      fd = dword_8516FE0;
      break;
    default:
      sub_80704AC(0, "NET_SendPacket: bad address type", v9);
  }
  if ( fd )
  {
    sub_80C9D0C(&a3, &addr);
    result = sendto(fd, buf, n, 0, &addr, 0x10u);
    v12 = result;
    if ( result == -1 )
    {
      sub_80848F8(a3, a4, a5, a6, a7);
      v8 = sub_80CA82C();
      result = Com_Printf("NET_SendPacket ERROR: %s to %s\n", v8);
    }
  }
  return result;
}
// 80CA0A1: variable 'v9' is possibly undefined
// 80F776C: using guessed type int dword_80F776C;
// 8516FE0: using guessed type int dword_8516FE0;

//----- (080CA149) --------------------------------------------------------
ssize_t __cdecl sub_80CA149(char *cp, int a2, size_t n, void *buf)
{
  ssize_t result; // eax
  int v5[4]; // [esp+20h] [ebp-38h] BYREF
  int v6; // [esp+30h] [ebp-28h]
  uint16_t v7; // [esp+4Eh] [ebp-Ah]

  v7 = a2;
  v5[0] = 4;
  result = sub_80C9E95(cp, v5);
  if ( result )
  {
    HIWORD(v6) = htons(v7);
    result = sub_80CA04B(n, buf, v5[0], v5[1], v5[2], v5[3], v6);
  }
  return result;
}

//----- (080CA1BC) --------------------------------------------------------
int __cdecl sub_80CA1BC(int a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  if ( a1 == 2 )
    return 1;
  if ( a1 == 5 )
    return 1;
  if ( a1 != 4 )
    return 0;
  if ( a2 == 10 )
    return 1;
  if ( a2 == 127 )
    return 1;
  if ( a2 == 0xFEA9 )
    return 1;
  if ( a2 == 0xAC && (BYTE1(a2) & 0xF0) == 16 )
    return 1;
  if ( a2 == 0xA8C0 )
    return 1;
  for ( i = 0; i < dword_8459004; ++i )
  {
    if ( a2 == byte_8459020[4 * i] && BYTE1(a2) == byte_8459021[4 * i] && BYTE2(a2) == byte_8459022[4 * i] )
      return 1;
  }
  return 0;
}
// 8459004: using guessed type int dword_8459004;

//----- (080CA32D) --------------------------------------------------------
struct hostent *sub_80CA32D()
{
  struct hostent *result; // eax
  int v1; // [esp+20h] [ebp-118h]
  uint32_t v2; // [esp+24h] [ebp-114h]
  const char *v3; // [esp+28h] [ebp-110h]
  char *v4; // [esp+28h] [ebp-110h]
  struct hostent *v5; // [esp+2Ch] [ebp-10Ch]
  char name[264]; // [esp+30h] [ebp-108h] BYREF

  result = gethostname(name, 0x100u);
  if ( result != -1 )
  {
    result = gethostbyname(name);
    v5 = result;
    if ( result )
    {
      Com_Printf("Hostname: %s\n", result->h_name);
      v1 = 0;
      while ( 1 )
      {
        v3 = v5->h_aliases[v1++];
        if ( !v3 )
          break;
        Com_Printf("Alias: %s\n", v3);
      }
      result = v5;
      if ( v5->h_addrtype == 2 )
      {
        dword_8459004 = 0;
        while ( 1 )
        {
          result = v5->h_addr_list[dword_8459004];
          v4 = result;
          ++dword_8459004;
          if ( !result || dword_8459004 > 15 )
            break;
          v2 = ntohl(result->h_name);
          byte_8459020[4 * dword_8459004] = *v4;
          byte_8459021[4 * dword_8459004] = v4[1];
          byte_8459022[4 * dword_8459004] = v4[2];
          byte_8459023[4 * dword_8459004] = v4[3];
          Com_Printf("IP: %i.%i.%i.%i\n", HIBYTE(v2), BYTE2(v2), BYTE1(v2), v2);
        }
      }
    }
  }
  return result;
}
// 8459004: using guessed type int dword_8459004;

//----- (080CA4FD) --------------------------------------------------------
struct hostent *sub_80CA4FD()
{
  char *v0; // eax
  float v2; // [esp+4h] [ebp-24h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int *v5; // [esp+24h] [ebp-4h]

  v5 = sub_8073114("net_ip", "localhost", 0);
  v0 = sub_8086D78("%i", 28960);
  v4 = *(sub_8073114("net_port", v0, 0) + 7);
  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
      sub_80704AC(0, "Couldn't allocate IP port");
    dword_80F776C = sub_80CA62E(v5[1], v4 + i);
    if ( dword_80F776C )
      break;
  }
  v2 = (v4 + i);
  sub_8073817("net_port", v2);
  return sub_80CA32D();
}
// 80F776C: using guessed type int dword_80F776C;

//----- (080CA5E0) --------------------------------------------------------
void sub_80CA5E0()
{
  dword_8459000 = sub_8073114("net_noudp", "0", 0);
  if ( *(dword_8459000 + 28) == 0.0 && !dword_80F776C )
    sub_80CA4FD();
}
// 80F776C: using guessed type int dword_80F776C;
// 8459000: using guessed type int dword_8459000;

//----- (080CA62E) --------------------------------------------------------
int __cdecl sub_80CA62E(char *cp, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  int v7; // [esp+24h] [ebp-34h]
  int optval; // [esp+28h] [ebp-30h] BYREF
  int v9; // [esp+2Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  int fd; // [esp+4Ch] [ebp-Ch]

  v9 = 1;
  optval = 1;
  if ( cp )
    Com_Printf("Opening IP socket: %s:%i\n", cp, a2);
  else
    Com_Printf("Opening IP socket: localhost:%i\n", a2);
  fd = socket(2, 2, 17);
  if ( fd == -1 )
  {
    v2 = sub_80CA82C();
    Com_Printf("ERROR: UDP_OpenSocket: socket: %s", v2);
    v7 = 0;
  }
  else if ( ioctl(fd, 0x5421u, &v9) == -1 )
  {
    v3 = sub_80CA82C();
    Com_Printf("ERROR: UDP_OpenSocket: ioctl FIONBIO:%s\n", v3);
    v7 = 0;
  }
  else if ( setsockopt(fd, 1, 6, &optval, 4u) == -1 )
  {
    v4 = sub_80CA82C();
    Com_Printf("ERROR: UDP_OpenSocket: setsockopt SO_BROADCAST:%s\n", v4);
    v7 = 0;
  }
  else
  {
    if ( cp && *cp && sub_8086A5A(cp, "localhost") )
      sub_80C9DFE(cp, &addr);
    else
      *&addr.sa_data[2] = 0;
    if ( a2 == -1 )
      *addr.sa_data = 0;
    else
      *addr.sa_data = htons(a2);
    addr.sa_family = 2;
    if ( bind(fd, &addr, 0x10u) == -1 )
    {
      v5 = sub_80CA82C();
      Com_Printf("ERROR: UDP_OpenSocket: bind: %s\n", v5);
      close(fd);
      v7 = 0;
    }
    else
    {
      v7 = fd;
    }
  }
  return v7;
}

//----- (080CA82C) --------------------------------------------------------
char *sub_80CA82C()
{
  int *v0; // eax

  v0 = __errno_location();
  return strerror(*v0);
}

//----- (080CA849) --------------------------------------------------------
int __cdecl sub_80CA849(int a1)
{
  int result; // eax
  fd_set readfds; // [esp+30h] [ebp-98h] BYREF
  struct timeval timeout; // [esp+B8h] [ebp-10h] BYREF

  if ( dword_80F776C )
  {
    result = dword_84886E0;
    if ( *(dword_84886E0 + 32) )
    {
      memset(&readfds, 0, sizeof(readfds));
      if ( dword_80F7340 )
        readfds.__fds_bits[0] |= 1u;
      _bittestandset(&readfds.__fds_bits[dword_80F776C >> 5], dword_80F776C & 0x1F);
      timeout.tv_sec = a1 / 1000;
      timeout.tv_usec = 1000 * (a1 % 1000);
      result = select(dword_80F776C + 1, &readfds, 0, 0, &timeout);
    }
  }
  return result;
}
// 80F7340: using guessed type int dword_80F7340;
// 80F776C: using guessed type int dword_80F776C;
// 84886E0: using guessed type int dword_84886E0;

//----- (080CA93C) --------------------------------------------------------
int sub_80CA93C()
{
  int v1; // [esp+Ch] [ebp-1Ch]
  struct timezone tz; // [esp+10h] [ebp-18h] BYREF
  struct timeval tv; // [esp+18h] [ebp-10h] BYREF

  gettimeofday(&tv, &tz);
  if ( dword_8516FF8 )
  {
    dword_8516FFC = tv.tv_usec / 1000 + 1000 * (tv.tv_sec - dword_8516FF8);
    v1 = dword_8516FFC;
  }
  else
  {
    dword_8516FF8 = tv.tv_sec;
    v1 = tv.tv_usec / 1000;
  }
  return v1;
}
// 8516FF8: using guessed type int dword_8516FF8;
// 8516FFC: using guessed type int dword_8516FFC;

//----- (080CA9C3) --------------------------------------------------------
int __cdecl sub_80CA9C3(char *path)
{
  return mkdir(path, 0x1FFu);
}

//----- (080CA9DE) --------------------------------------------------------
DIR *__cdecl sub_80CA9DE(const char *a1, const char *a2, int a3, int a4, int *a5)
{
  DIR *result; // eax
  struct stat stat_buf; // [esp+20h] [ebp-378h] BYREF
  struct dirent *v7; // [esp+88h] [ebp-310h]
  DIR *dirp; // [esp+8Ch] [ebp-30Ch]
  char s[256]; // [esp+90h] [ebp-308h] BYREF
  char v10[256]; // [esp+190h] [ebp-208h] BYREF
  char name[264]; // [esp+290h] [ebp-108h] BYREF

  result = a5;
  if ( *a5 <= 4094 )
  {
    if ( *a2 )
      Com_sprintf(name, 0x100u, "%s/%s", a1, a2);
    else
      Com_sprintf(name, 0x100u, "%s", a1);
    result = opendir(name);
    dirp = result;
    if ( result )
    {
      while ( 1 )
      {
        v7 = readdir(dirp);
        if ( !v7 )
          break;
        Com_sprintf(s, 0x100u, "%s/%s", name, v7->d_name);
        if ( sub_80DB9E4(s, &stat_buf) != -1 )
        {
          if ( (stat_buf.st_mode & 0x4000) != 0 && sub_8086A5A(v7->d_name, ".") && sub_8086A5A(v7->d_name, "..") )
          {
            if ( *a2 )
              Com_sprintf(v10, 0x100u, "%s/%s", a2, v7->d_name);
            else
              Com_sprintf(v10, 0x100u, "%s", v7->d_name);
            sub_80CA9DE(a1, v10, a3, a4, a5);
          }
          if ( *a5 > 4094 )
            break;
          Com_sprintf(s, 0x100u, "%s/%s", a2, v7->d_name);
          if ( sub_806B926(a3, s, 0) )
            *(a4 + 4 * (*a5)++) = sub_806BB76(s);
        }
      }
      result = closedir(dirp);
    }
  }
  return result;
}

//----- (080CAC75) --------------------------------------------------------
void *__cdecl sub_80CAC75(char *name, char *s, int a3, int a4, int a5)
{
  size_t v5; // ebx
  size_t v6; // eax
  char *v7; // ebx
  size_t v8; // eax
  int v9; // ebx
  void *v11; // [esp+28h] [ebp-41A0h]
  struct stat stat_buf; // [esp+30h] [ebp-4198h] BYREF
  int i; // [esp+9Ch] [ebp-412Ch]
  int v14[4098]; // [esp+A0h] [ebp-4128h] BYREF
  _DWORD *v15; // [esp+40A8h] [ebp-120h]
  int v16; // [esp+40ACh] [ebp-11Ch] BYREF
  char filename[260]; // [esp+40B0h] [ebp-118h] BYREF
  int v18; // [esp+41B4h] [ebp-14h]
  DIR *dirp; // [esp+41B8h] [ebp-10h]
  struct dirent *v20; // [esp+41BCh] [ebp-Ch]

  v18 = a5;
  if ( a3 )
  {
    v16 = 0;
    sub_80CA9DE(name, &unk_80EB30E, a3, v14, &v16);
    v14[v16] = 0;
    *a4 = v16;
    if ( v16 )
    {
      v15 = sub_806BB38(4 * v16 + 4);
      for ( i = 0; i < v16; ++i )
        v15[i] = v14[i];
      v15[i] = 0;
      v11 = v15;
    }
    else
    {
      v11 = 0;
    }
  }
  else
  {
    if ( !s )
      s = &unk_80EB30E;
    if ( *s == 47 && !s[1] )
    {
      s = &unk_80EB30E;
      v18 = 1;
    }
    strlen(s);
    v16 = 0;
    dirp = opendir(name);
    if ( dirp )
    {
      while ( 1 )
      {
        v20 = readdir(dirp);
        if ( !v20 )
          break;
        Com_sprintf(filename, 0x100u, "%s/%s", name, v20->d_name);
        if ( sub_80DB9E4(filename, &stat_buf) != -1
          && (!v18 || (stat_buf.st_mode & 0x4000) != 0)
          && (v18 || (stat_buf.st_mode & 0x4000) == 0) )
        {
          if ( !*s
            || (v5 = strlen(v20->d_name), v5 >= strlen(s))
            && (v6 = strlen(v20->d_name), v7 = v20 + v6, v8 = strlen(s), !sub_8086A5A(&v7[-v8 + 11], s)) )
          {
            if ( v16 == 4095 )
              break;
            v9 = v16;
            v14[v9] = sub_806BB76(v20->d_name);
            ++v16;
          }
        }
      }
      v14[v16] = 0;
      closedir(dirp);
      *a4 = v16;
      if ( v16 )
      {
        v15 = sub_806BB38(4 * v16 + 4);
        for ( i = 0; i < v16; ++i )
          v15[i] = v14[i];
        v15[i] = 0;
        v11 = v15;
      }
      else
      {
        v11 = 0;
      }
    }
    else
    {
      *a4 = 0;
      v11 = 0;
    }
  }
  return v11;
}

//----- (080CB004) --------------------------------------------------------
void __cdecl sub_80CB004(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  if ( ptr )
  {
    for ( i = 0; *(ptr + i); ++i )
      sub_806BB25(*(ptr + i));
    sub_806BB25(ptr);
  }
}

//----- (080CB05A) --------------------------------------------------------
char *sub_80CB05A()
{
  getcwd(byte_8459060, 0xFFu);
  byte_845915F = 0;
  return byte_8459060;
}
// 845915F: using guessed type char byte_845915F;

//----- (080CB082) --------------------------------------------------------
char *__cdecl sub_80CB082(char *src)
{
  return Q_strncpyz(byte_8459160, src, 256);
}

//----- (080CB0A5) --------------------------------------------------------
char *sub_80CB0A5()
{
  return byte_8459160;
}

//----- (080CB0F7) --------------------------------------------------------
char *sub_80CB0F7()
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( byte_8459260 )
    v1 = &byte_8459260;
  else
    v1 = sub_80CB05A();
  return v1;
}
// 8459260: using guessed type char byte_8459260;

//----- (080CB13F) --------------------------------------------------------
char *sub_80CB13F()
{
  int *v0; // ebx
  int *v1; // eax
  char *v2; // eax
  char *src; // [esp+20h] [ebp-8h]

  if ( path )
    return &path;
  src = getenv("HOME");
  if ( !src )
    return &unk_80EB30E;
  Q_strncpyz(&path, src, 256);
  sub_8086B0B(&path, 256, "/.callofduty");
  if ( mkdir(&path, 0x1FFu) && *__errno_location() != 17 )
  {
    v0 = __errno_location();
    v1 = __errno_location();
    v2 = strerror(*v1);
    sub_80C8793("Unable to create directory \"%s\", error is %s(%d)\n", &path, v2, *v0);
  }
  return &path;
}

//----- (080CB230) --------------------------------------------------------
void sub_80CB230()
{
  ;
}

//----- (080CB235) --------------------------------------------------------
const char *sub_80CB235()
{
  __uid_t v0; // eax
  const char *v2; // [esp+10h] [ebp-8h]
  struct passwd *v3; // [esp+14h] [ebp-4h]

  v0 = getuid();
  v3 = getpwuid(v0);
  if ( v3 )
    v2 = v3->pw_name;
  else
    v2 = "player";
  return v2;
}

//----- (080CB294) --------------------------------------------------------
int __cdecl sub_80CB294(float *a1, float *a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst5
  long double v6; // fst7
  long double v7; // fst6

  if ( *(a3 + 17) >= 8 )
    return MEMORY[1];
  v3 = *a3;
  v4 = v3;
  switch ( *(a3 + 17) )
  {
    case 0:
      v5 = *(a3 + 4) * a1[1] + v3 * *a1;
      v6 = *(a3 + 8) * a1[2];
      v7 = v4 * *a2 + *(a3 + 4) * a2[1] + *(a3 + 8) * a2[2];
      break;
    case 1:
      v5 = *(a3 + 4) * a1[1] + v3 * *a2;
      v6 = *(a3 + 8) * a1[2];
      v7 = v4 * *a1 + *(a3 + 4) * a2[1] + *(a3 + 8) * a2[2];
      break;
    case 2:
      v5 = *(a3 + 4) * a2[1] + v3 * *a1;
      v6 = *(a3 + 8) * a1[2];
      v7 = v4 * *a2 + *(a3 + 4) * a1[1] + *(a3 + 8) * a2[2];
      break;
    case 3:
      v5 = *(a3 + 4) * a2[1] + v3 * *a2;
      v6 = *(a3 + 8) * a1[2];
      v7 = v4 * *a1 + *(a3 + 4) * a1[1] + *(a3 + 8) * a2[2];
      break;
    case 4:
      v5 = *(a3 + 4) * a1[1] + v3 * *a1;
      v6 = *(a3 + 8) * a2[2];
      v7 = v4 * *a2 + *(a3 + 4) * a2[1] + *(a3 + 8) * a1[2];
      break;
    case 5:
      v5 = *(a3 + 4) * a1[1] + v3 * *a2;
      v6 = *(a3 + 8) * a2[2];
      v7 = v4 * *a1 + *(a3 + 4) * a2[1] + *(a3 + 8) * a1[2];
      break;
    case 6:
      v5 = *(a3 + 4) * a2[1] + v3 * *a1;
      v6 = *(a3 + 8) * a2[2];
      v7 = v4 * *a2 + *(a3 + 4) * a1[1] + *(a3 + 8) * a1[2];
      break;
    case 7:
      v5 = *(a3 + 4) * a2[1] + v3 * *a2;
      v6 = *(a3 + 8) * a2[2];
      v7 = v4 * *a1 + *(a3 + 4) * a1[1] + *(a3 + 8) * a1[2];
      break;
  }
  return (2 * (v6 + v5 < *(a3 + 12)) + (v7 >= *(a3 + 12)));
}

//----- (080CB470) --------------------------------------------------------
void __cdecl sub_80CB470(float *a1)
{
  *a1 = *a1;
  *a1 = *a1;
  *(a1 + 1) = a1[1];
  a1[1] = *(a1 + 1);
  *(a1 + 2) = a1[2];
  a1[2] = *(a1 + 2);
}

//----- (080CB520) --------------------------------------------------------
int __cdecl sub_80CB520(__int16 a1)
{
  return a1;
}

//----- (080CB590) --------------------------------------------------------
int __cdecl sub_80CB590(int a1)
{
  return a1;
}

//----- (080CB5DE) --------------------------------------------------------
int __cdecl sub_80CB5DE(FILE *stream, int a2)
{
  __int16 ptr[3]; // [esp+12h] [ebp-6h] BYREF

  fread(ptr, 2u, 1u, stream);
  *a2 = sub_80CB520(ptr[0]);
  return 0;
}

//----- (080CB624) --------------------------------------------------------
int __cdecl sub_80CB624(FILE *stream, int a2)
{
  int ptr; // [esp+10h] [ebp-8h] BYREF

  fread(&ptr, 4u, 1u, stream);
  *a2 = sub_80CB590(ptr);
  return 0;
}

//----- (080CB668) --------------------------------------------------------
int __cdecl sub_80CB668(char *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-Ch]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  while ( 1 )
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( v6 > 96 && v6 <= 122 )
      v6 -= 32;
    if ( v5 > 96 && v5 <= 122 )
      v5 -= 32;
    if ( !v6 )
      break;
    if ( !v5 )
      return 1;
    if ( v6 < v5 )
      return -1;
    if ( v6 > v5 )
      return 1;
  }
  if ( v5 )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}

//----- (080CB70C) --------------------------------------------------------
int __cdecl sub_80CB70C(char *s1, char *s2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !a3 )
    a3 = 1;
  if ( a3 == 1 )
    v4 = strcmp(s1, s2);
  else
    v4 = sub_80CB668(s1, s2);
  return v4;
}

//----- (080CB756) --------------------------------------------------------
size_t __cdecl sub_80CB756(FILE *stream)
{
  int v1; // edx
  size_t v3; // [esp+10h] [ebp-28h]
  size_t v5; // [esp+18h] [ebp-20h]
  int off; // [esp+1Ch] [ebp-1Ch]
  size_t v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  void *ptr; // [esp+34h] [ebp-4h]

  v8 = 0xFFFF;
  v7 = 0;
  if ( fseek(stream, 0, 2) )
    return 0;
  v10 = ftell(stream);
  if ( v10 < 0xFFFF )
    v8 = v10;
  ptr = malloc(0x404u);
  if ( !ptr )
    return 0;
  v9 = 4;
  do
  {
    if ( v9 >= v8 )
      break;
    if ( v9 + 1024 <= v8 )
      v9 += 1024;
    else
      v9 = v8;
    off = v10 - v9;
    v3 = v9;
    if ( v9 > 0x404 )
      v3 = 1028;
    if ( fseek(stream, off, 0) || fread(ptr, v3, 1u, stream) != 1 )
      break;
    v5 = v3 - 3;
    while ( 1 )
    {
      v1 = v5--;
      if ( v1 <= 0 )
        break;
      if ( *(ptr + v5) == 80 && *(ptr + v5 + 1) == 75 && *(ptr + v5 + 2) == 5 && *(ptr + v5 + 3) == 6 )
      {
        v7 = off + v5;
        break;
      }
    }
  }
  while ( !v7 );
  free(ptr);
  return v7;
}

//----- (080CB8F4) --------------------------------------------------------
_DWORD *__cdecl sub_80CB8F4(char *filename, void *src)
{
  FILE *v4; // [esp+10h] [ebp-8h]
  _DWORD *dest; // [esp+14h] [ebp-4h]

  v4 = fopen(filename, "rb");
  if ( !v4 )
    return 0;
  dest = malloc(0x80u);
  memcpy(dest, src, 0x80u);
  *dest = v4;
  return dest;
}

//----- (080CB95C) --------------------------------------------------------
int *__cdecl sub_80CB95C(char *filename)
{
  int *v2; // [esp+1Ch] [ebp-ACh]
  int v3; // [esp+20h] [ebp-A8h]
  int v4; // [esp+24h] [ebp-A4h] BYREF
  int v5; // [esp+28h] [ebp-A0h] BYREF
  int v6; // [esp+2Ch] [ebp-9Ch] BYREF
  FILE *stream; // [esp+30h] [ebp-98h]
  int v8; // [esp+34h] [ebp-94h] BYREF
  int off; // [esp+38h] [ebp-90h]
  int *v10; // [esp+3Ch] [ebp-8Ch]
  int v11[34]; // [esp+40h] [ebp-88h] BYREF

  v3 = 0;
  stream = fopen(filename, "rb");
  if ( !stream )
    return 0;
  off = sub_80CB756(stream);
  if ( !off )
    v3 = -1;
  if ( fseek(stream, off, 0) )
    v3 = -1;
  if ( sub_80CB624(stream, &v8) )
    v3 = -1;
  if ( sub_80CB5DE(stream, &v6) )
    v3 = -1;
  if ( sub_80CB5DE(stream, &v5) )
    v3 = -1;
  if ( sub_80CB5DE(stream, &v11[1]) )
    v3 = -1;
  if ( sub_80CB5DE(stream, &v4) )
    v3 = -1;
  if ( v4 != v11[1] || v5 || v6 )
    v3 = -103;
  if ( sub_80CB624(stream, &v11[8]) )
    v3 = -1;
  if ( sub_80CB624(stream, &v11[9]) )
    v3 = -1;
  if ( sub_80CB5DE(stream, &v11[2]) )
    v3 = -1;
  if ( off < (v11[9] + v11[8]) && !v3 )
    v3 = -103;
  if ( v3 )
  {
    fclose(stream);
    v2 = 0;
  }
  else
  {
    v11[0] = stream;
    v11[3] = off - (v11[8] + v11[9]);
    v11[7] = off;
    v11[31] = 0;
    v10 = malloc(0x80u);
    qmemcpy(v10, v11, 0x80u);
    v2 = v10;
  }
  return v2;
}

//----- (080CBC1C) --------------------------------------------------------
int __cdecl sub_80CBC1C(int a1)
{
  if ( !a1 )
    return -102;
  if ( *(a1 + 124) )
    sub_80CCE86(a1);
  fclose(*a1);
  free(a1);
  return 0;
}

//----- (080CBC70) --------------------------------------------------------
int __cdecl sub_80CBC70(int a1, _DWORD *a2)
{
  int v2; // edx

  if ( !a1 )
    return -102;
  v2 = *(a1 + 8);
  *a2 = *(a1 + 4);
  a2[1] = v2;
  return 0;
}

//----- (080CBCAA) --------------------------------------------------------
int __cdecl sub_80CBCAA(int a1, int *a2)
{
  int result; // eax

  a2[3] = BYTE2(a1) & 0x1F;
  a2[4] = ((HIWORD(a1) & 0x1E0) >> 5) - 1;
  a2[5] = ((HIWORD(a1) & 0xFE00) >> 9) + 1980;
  a2[2] = (a1 & 0xF800) >> 11;
  a2[1] = (a1 & 0x7E0) >> 5;
  result = 2 * (a1 & 0x1F);
  *a2 = result;
  return result;
}

//----- (080CBD1E) --------------------------------------------------------
int __cdecl sub_80CBD1E(int a1, int a2, int a3, void *ptr, int a5, void *a6, int a7, void *a8, int a9)
{
  int size; // [esp+1Ch] [ebp-7Ch]
  int sizea; // [esp+1Ch] [ebp-7Ch]
  int sizeb; // [esp+1Ch] [ebp-7Ch]
  int off; // [esp+20h] [ebp-78h]
  int offa; // [esp+20h] [ebp-78h]
  int v16; // [esp+24h] [ebp-74h] BYREF
  int v17; // [esp+28h] [ebp-70h]
  int v18; // [esp+2Ch] [ebp-6Ch] BYREF
  int v19[23]; // [esp+30h] [ebp-68h] BYREF
  FILE **v20; // [esp+8Ch] [ebp-Ch]

  v17 = 0;
  if ( !a1 )
    return -102;
  v20 = a1;
  if ( fseek(*a1, *(a1 + 20) + *(a1 + 12), 0) )
    v17 = -1;
  if ( !v17 )
  {
    if ( sub_80CB624(*v20, &v16) )
    {
      v17 = -1;
    }
    else if ( v16 != 33639248 )
    {
      v17 = -103;
    }
  }
  if ( sub_80CB5DE(*v20, v19) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[1]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[2]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[3]) )
    v17 = -1;
  if ( sub_80CB624(*v20, &v19[4]) )
    v17 = -1;
  sub_80CBCAA(v19[4], &v19[14]);
  if ( sub_80CB624(*v20, &v19[5]) )
    v17 = -1;
  if ( sub_80CB624(*v20, &v19[6]) )
    v17 = -1;
  if ( sub_80CB624(*v20, &v19[7]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[8]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[9]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[10]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[11]) )
    v17 = -1;
  if ( sub_80CB5DE(*v20, &v19[12]) )
    v17 = -1;
  if ( sub_80CB624(*v20, &v19[13]) )
    v17 = -1;
  if ( sub_80CB624(*v20, &v18) )
    v17 = -1;
  off = v19[8];
  if ( !v17 && ptr )
  {
    if ( v19[8] >= a5 )
    {
      size = a5;
    }
    else
    {
      *(ptr + v19[8]) = 0;
      size = v19[8];
    }
    if ( v19[8] && a5 && fread(ptr, size, 1u, *v20) != 1 )
      v17 = -1;
    off -= size;
  }
  if ( v17 || !a6 )
  {
    offa = v19[9] + off;
  }
  else
  {
    if ( v19[9] >= a7 )
      sizea = a7;
    else
      sizea = v19[9];
    if ( off )
    {
      if ( fseek(*v20, off, 1) )
        v17 = -1;
      else
        off = 0;
    }
    if ( v19[9] && a7 && fread(a6, sizea, 1u, *v20) != 1 )
      v17 = -1;
    offa = v19[9] - sizea + off;
  }
  if ( !v17 && a8 )
  {
    if ( v19[10] >= a9 )
    {
      sizeb = a9;
    }
    else
    {
      *(a8 + v19[10]) = 0;
      sizeb = v19[10];
    }
    if ( offa && fseek(*v20, offa, 1) )
      v17 = -1;
    if ( v19[10] && a9 && fread(a8, sizeb, 1u, *v20) != 1 )
      v17 = -1;
  }
  if ( !v17 && a2 )
    qmemcpy(a2, v19, 0x50u);
  if ( !v17 && a3 )
    *a3 = v18;
  return v17;
}

//----- (080CC1F2) --------------------------------------------------------
int __cdecl sub_80CC1F2(int a1, int a2, void *ptr, int a4, void *a5, int a6, void *a7, int a8)
{
  return sub_80CBD1E(a1, a2, 0, ptr, a4, a5, a6, a7, a8);
}

//----- (080CC23E) --------------------------------------------------------
int __cdecl sub_80CC23E(_DWORD *a1)
{
  int v3; // [esp+34h] [ebp-4h]

  if ( !a1 )
    return -102;
  a1[5] = a1[9];
  a1[4] = 0;
  v3 = sub_80CBD1E(a1, (a1 + 10), (a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v3 == 0;
  return v3;
}

//----- (080CC2E6) --------------------------------------------------------
int __cdecl sub_80CC2E6(_DWORD *a1)
{
  int v3; // [esp+28h] [ebp-10h]

  if ( !a1 )
    return -102;
  if ( !a1[6] )
    return -100;
  if ( a1[4] + 1 == a1[1] )
    return -100;
  a1[5] += a1[20] + a1[19] + a1[18] + 46;
  ++a1[4];
  v3 = sub_80CBD1E(a1, (a1 + 10), (a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v3 == 0;
  return v3;
}

//----- (080CC504) --------------------------------------------------------
int __cdecl sub_80CC504(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h] BYREF
  int v8; // [esp+18h] [ebp-10h] BYREF
  int v9; // [esp+1Ch] [ebp-Ch] BYREF
  int v10; // [esp+20h] [ebp-8h] BYREF
  int v11; // [esp+24h] [ebp-4h] BYREF

  v6 = 0;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if ( fseek(*a1, *(a1 + 120) + *(a1 + 12), 0) )
    return -1;
  if ( sub_80CB624(*a1, &v11) )
  {
    v6 = -1;
  }
  else if ( v11 != 67324752 )
  {
    v6 = -103;
  }
  if ( sub_80CB5DE(*a1, &v10) )
    v6 = -1;
  if ( sub_80CB5DE(*a1, &v9) )
    v6 = -1;
  if ( sub_80CB5DE(*a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(a1 + 52) )
  {
    v6 = -103;
  }
  if ( !v6 && *(a1 + 52) && *(a1 + 52) != 8 )
    v6 = -103;
  if ( sub_80CB624(*a1, &v10) )
    v6 = -1;
  if ( sub_80CB624(*a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(a1 + 60) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CB624(*a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(a1 + 64) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CB624(*a1, &v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(a1 + 68) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80CB5DE(*a1, &v8) )
  {
    v6 = -1;
  }
  else if ( !v6 && v8 != *(a1 + 72) )
  {
    v6 = -103;
  }
  *a2 += v8;
  if ( sub_80CB5DE(*a1, &v7) )
    v6 = -1;
  *a3 = *(a1 + 120) + v8 + 30;
  *a4 = v7;
  *a2 += v7;
  return v6;
}
// 80CC565: conditional instruction was optimized away because of '%var_18.4==0'

//----- (080CC7AC) --------------------------------------------------------
int __cdecl sub_80CC7AC(_DWORD *a1)
{
  _DWORD *v1; // ebx
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-1Ch] BYREF
  void *ptr; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h] BYREF
  _BOOL4 v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]

  v10 = 0;
  if ( !a1 )
    return -102;
  v7 = a1;
  if ( !a1[6] )
    return -102;
  if ( v7[31] )
    sub_80CCE86(a1);
  if ( sub_80CC504(v7, &v8, &v5, &v4) )
    return -103;
  ptr = malloc(0x6Cu);
  if ( !ptr )
    return -104;
  v1 = ptr;
  *v1 = malloc(0x10000u);
  *(ptr + 17) = v5;
  *(ptr + 18) = v4;
  *(ptr + 19) = 0;
  if ( *ptr )
  {
    *(ptr + 16) = 0;
    if ( v7[13] && v7[13] != 8 )
      v10 = -103;
    v9 = v7[13] == 0;
    *(ptr + 21) = v7[15];
    *(ptr + 20) = 0;
    *(ptr + 25) = v7[13];
    *(ptr + 24) = *v7;
    *(ptr + 26) = v7[3];
    *(ptr + 6) = 0;
    if ( !v9 )
    {
      *(ptr + 9) = 0;
      *(ptr + 10) = 0;
      *(ptr + 11) = 0;
      v10 = sub_80D0D68(ptr + 1, -15, "1.1.3", 56);
      if ( !v10 )
        *(ptr + 16) = 1;
    }
    *(ptr + 22) = v7[16];
    *(ptr + 23) = v7[17];
    *(ptr + 15) = v7[30] + v8 + 30;
    *(ptr + 2) = 0;
    v7[31] = ptr;
    v3 = 0;
  }
  else
  {
    free(ptr);
    v3 = -104;
  }
  return v3;
}

//----- (080CC9B8) --------------------------------------------------------
int __cdecl sub_80CC9B8(int a1, int a2, unsigned int a3)
{
  int v4; // [esp+1Ch] [ebp-2Ch]
  unsigned int v5; // [esp+24h] [ebp-24h]
  _BYTE *v6; // [esp+28h] [ebp-20h]
  unsigned int i; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+2Ch] [ebp-1Ch]
  size_t size; // [esp+30h] [ebp-18h]
  unsigned int sizea; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+3Ch] [ebp-Ch]
  int v13; // [esp+40h] [ebp-8h]

  v13 = 0;
  v12 = 0;
  if ( !a1 )
    return -102;
  v11 = *(a1 + 124);
  if ( !v11 )
    return -102;
  if ( !*v11 )
    return -100;
  if ( !a3 )
    return 0;
  *(v11 + 16) = a2;
  *(v11 + 20) = a3;
  if ( a3 > *(v11 + 92) )
    *(v11 + 20) = *(v11 + 92);
  while ( *(v11 + 20) )
  {
    if ( !*(v11 + 8) && *(v11 + 88) )
    {
      size = 0x10000;
      if ( *(v11 + 88) < 0x10000u )
        size = *(v11 + 88);
      if ( !size )
        return 0;
      if ( *(a1 + 64) == *(v11 + 88) && fseek(*(v11 + 96), *(v11 + 60) + *(v11 + 104), 0) )
        return -1;
      if ( fread(*v11, size, 1u, *(v11 + 96)) != 1 )
        return -1;
      *(v11 + 60) += size;
      *(v11 + 88) -= size;
      *(v11 + 4) = *v11;
      *(v11 + 8) = size;
    }
    if ( *(v11 + 100) )
    {
      v8 = *(v11 + 24);
      v6 = *(v11 + 16);
      v13 = sub_80D0F2A((v11 + 4), 2);
      v5 = *(v11 + 24) - v8;
      *(v11 + 80) = sub_80CD00E(*(v11 + 80), v6, v5);
      *(v11 + 92) -= v5;
      v12 += v5;
      if ( v13 == 1 )
        return v12;
      if ( v13 )
        break;
    }
    else
    {
      if ( *(v11 + 20) >= *(v11 + 8) )
        sizea = *(v11 + 8);
      else
        sizea = *(v11 + 20);
      for ( i = 0; i < sizea; ++i )
        *(i + *(v11 + 16)) = *(*(v11 + 4) + i);
      *(v11 + 80) = sub_80CD00E(*(v11 + 80), *(v11 + 16), sizea);
      *(v11 + 92) -= sizea;
      *(v11 + 8) -= sizea;
      *(v11 + 20) -= sizea;
      *(v11 + 16) += sizea;
      *(v11 + 4) += sizea;
      *(v11 + 24) += sizea;
      v12 += sizea;
    }
  }
  if ( v13 )
    v4 = v13;
  else
    v4 = v12;
  return v4;
}

//----- (080CCD02) --------------------------------------------------------
int __cdecl sub_80CCD02(int a1)
{
  int v2; // [esp+0h] [ebp-Ch]
  int v3; // [esp+4h] [ebp-8h]

  if ( !a1 )
    return -102;
  v3 = *(a1 + 124);
  if ( v3 )
    v2 = *(v3 + 24);
  else
    v2 = -102;
  return v2;
}

//----- (080CCE86) --------------------------------------------------------
int __cdecl sub_80CCE86(int a1)
{
  void **ptr; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+14h] [ebp-4h]

  v4 = 0;
  if ( !a1 )
    return -102;
  ptr = *(a1 + 124);
  if ( !ptr )
    return -102;
  if ( !ptr[23] && ptr[20] != ptr[21] )
    v4 = -105;
  free(*ptr);
  *ptr = 0;
  if ( ptr[16] )
    sub_80D0CEC(ptr + 1);
  ptr[16] = 0;
  free(ptr);
  *(a1 + 124) = 0;
  return v4;
}

//----- (080CD00E) --------------------------------------------------------
int __cdecl sub_80CD00E(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v5; // [esp+Ch] [ebp+8h]
  unsigned int v6; // [esp+Ch] [ebp+8h]
  unsigned int v7; // [esp+Ch] [ebp+8h]
  unsigned int v8; // [esp+Ch] [ebp+8h]
  unsigned int v9; // [esp+Ch] [ebp+8h]
  unsigned int v10; // [esp+Ch] [ebp+8h]
  unsigned int v11; // [esp+Ch] [ebp+8h]
  unsigned int v12; // [esp+Ch] [ebp+8h]
  _BYTE *v13; // [esp+10h] [ebp+Ch]

  if ( !a2 )
    return 0;
  v5 = ~a1;
  while ( a3 > 7 )
  {
    v6 = dword_80EB6A0[(v5 ^ *a2)] ^ (v5 >> 8);
    v13 = a2 + 1;
    v7 = dword_80EB6A0[(v6 ^ *v13++)] ^ (v6 >> 8);
    v8 = dword_80EB6A0[(v7 ^ *v13++)] ^ (v7 >> 8);
    v9 = dword_80EB6A0[(v8 ^ *v13++)] ^ (v8 >> 8);
    v10 = dword_80EB6A0[(v9 ^ *v13++)] ^ (v9 >> 8);
    v11 = dword_80EB6A0[(v10 ^ *v13++)] ^ (v10 >> 8);
    v12 = dword_80EB6A0[(v11 ^ *v13++)] ^ (v11 >> 8);
    v5 = dword_80EB6A0[(v12 ^ *v13)] ^ (v12 >> 8);
    a2 = v13 + 1;
    a3 -= 8;
  }
  for ( ; a3; --a3 )
    v5 = dword_80EB6A0[(v5 ^ *a2++)] ^ (v5 >> 8);
  return ~v5;
}

//----- (080CD186) --------------------------------------------------------
int __cdecl sub_80CD186(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax

  if ( a3 )
    *a3 = *(a1 + 60);
  if ( *a1 == 4 || *a1 == 5 )
    (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
  if ( *a1 == 6 )
    sub_80D09EA(*(a1 + 4), a2);
  *a1 = 0;
  *(a1 + 28) = 0;
  *(a1 + 32) = 0;
  v3 = *(a1 + 40);
  *(a1 + 52) = v3;
  *(a1 + 48) = v3;
  result = a1;
  if ( *(a1 + 56) )
  {
    *(a1 + 60) = (*(a1 + 56))(0, 0, 0);
    result = *(a1 + 60);
    *(a2 + 48) = result;
  }
  return result;
}

//----- (080CD256) --------------------------------------------------------
_DWORD *__cdecl sub_80CD256(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (*(a1 + 32))(*(a1 + 40), 1, 64);
  if ( !v5 )
    return 0;
  v5[9] = (*(a1 + 32))(*(a1 + 40), 8, 1440);
  if ( v5[9] )
  {
    v5[10] = (*(a1 + 32))(*(a1 + 40), 1, a3);
    if ( v5[10] )
    {
      v5[11] = v5[10] + a3;
      v5[14] = a2;
      *v5 = 0;
      sub_80CD186(v5, a1, 0);
      v4 = v5;
    }
    else
    {
      (*(a1 + 36))(*(a1 + 40), v5[9]);
      (*(a1 + 36))(*(a1 + 40), v5);
      v4 = 0;
    }
  }
  else
  {
    (*(a1 + 36))(*(a1 + 40), v5);
    v4 = 0;
  }
  return v4;
}

//----- (080CD398) --------------------------------------------------------
int __cdecl sub_80CD398(int a1, int a2, int a3)
{
  int v4; // [esp+28h] [ebp-70h]
  int v5; // [esp+2Ch] [ebp-6Ch]
  unsigned int v6; // [esp+30h] [ebp-68h]
  int v7; // [esp+34h] [ebp-64h]
  int v8; // [esp+38h] [ebp-60h]
  int v9; // [esp+3Ch] [ebp-5Ch]
  int v10; // [esp+44h] [ebp-54h]
  int v11; // [esp+48h] [ebp-50h]
  int v12; // [esp+4Ch] [ebp-4Ch]
  int v13; // [esp+50h] [ebp-48h]
  size_t v14; // [esp+58h] [ebp-40h]
  int v15; // [esp+5Ch] [ebp-3Ch]
  int v17; // [esp+64h] [ebp-34h]
  int v18; // [esp+68h] [ebp-30h] BYREF
  int v19; // [esp+6Ch] [ebp-2Ch] BYREF
  int v20; // [esp+70h] [ebp-28h] BYREF
  unsigned int v21; // [esp+74h] [ebp-24h] BYREF
  size_t v22; // [esp+78h] [ebp-20h]
  void *dest; // [esp+7Ch] [ebp-1Ch]
  size_t v24; // [esp+80h] [ebp-18h]
  void *src; // [esp+84h] [ebp-14h]
  size_t v26; // [esp+88h] [ebp-10h]
  unsigned int v27; // [esp+8Ch] [ebp-Ch]
  size_t n; // [esp+90h] [ebp-8h]
  int v29; // [esp+A8h] [ebp+10h]
  int v30; // [esp+A8h] [ebp+10h]

  src = *a2;
  v24 = *(a2 + 4);
  v27 = *(a1 + 32);
  v26 = *(a1 + 28);
  dest = *(a1 + 52);
  if ( dest >= *(a1 + 48) )
    v15 = *(a1 + 44) - dest;
  else
    v15 = *(a1 + 48) - dest - 1;
  v22 = v15;
  while ( 1 )
  {
    if ( *a1 > 9u )
    {
      *(a1 + 32) = v27;
      *(a1 + 28) = v26;
      *(a2 + 4) = v24;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80CE87C(a1, a2, -2);
    }
    switch ( *a1 )
    {
      case 0:
        while ( v26 <= 2 )
        {
          if ( !v24 )
            goto LABEL_53;
          a3 = 0;
          --v24;
          v27 |= *src << v26;
          src = src + 1;
          v26 += 8;
        }
        n = v27 & 7;
        *(a1 + 24) = v27 & 1;
        v14 = n >> 1;
        if ( n >> 1 == 1 )
        {
          sub_80CF562(&v21, &v20, &v19, &v18);
          *(a1 + 4) = sub_80CFC00(v21, v20, v19, v18, a2);
          if ( !*(a1 + 4) )
            goto LABEL_119;
          v27 >>= 3;
          v26 -= 3;
          *a1 = 6;
          continue;
        }
        if ( !v14 )
        {
          v27 >>= 3;
          v26 -= 3;
          n = v26 & 7;
          v27 >>= n;
          v26 -= n;
          *a1 = 1;
          continue;
        }
        if ( v14 == 2 )
        {
          v27 >>= 3;
          v26 -= 3;
          *a1 = 3;
          continue;
        }
        if ( v14 != 3 )
          continue;
        v27 >>= 3;
        v26 -= 3;
        *a1 = 9;
        *(a2 + 24) = "invalid block type";
        *(a1 + 32) = v27;
        *(a1 + 28) = v26;
        *(a2 + 4) = v24;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80CE87C(a1, a2, -3);
      case 1:
        while ( v26 <= 0x1F )
        {
          if ( !v24 )
            goto LABEL_53;
          a3 = 0;
          --v24;
          v27 |= *src << v26;
          src = src + 1;
          v26 += 8;
        }
        if ( ~v27 >> 16 == v27 )
        {
          *(a1 + 4) = v27;
          v26 = 0;
          v27 = 0;
          if ( *(a1 + 4) )
          {
            v13 = 2;
          }
          else if ( *(a1 + 24) )
          {
            v13 = 7;
          }
          else
          {
            v13 = 0;
          }
          *a1 = v13;
          continue;
        }
        *a1 = 9;
        *(a2 + 24) = "invalid stored block lengths";
        *(a1 + 32) = v27;
        *(a1 + 28) = v26;
        *(a2 + 4) = v24;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80CE87C(a1, a2, -3);
      case 2:
        if ( !v24 )
          goto LABEL_53;
        if ( !v22 )
        {
          if ( dest == *(a1 + 44) && *(a1 + 48) != *(a1 + 40) )
          {
            dest = *(a1 + 40);
            if ( dest >= *(a1 + 48) )
              v12 = *(a1 + 44) - dest;
            else
              v12 = *(a1 + 48) - dest - 1;
            v22 = v12;
          }
          if ( !v22 )
          {
            *(a1 + 52) = dest;
            a3 = sub_80CE87C(a1, a2, a3);
            dest = *(a1 + 52);
            if ( dest >= *(a1 + 48) )
              v11 = *(a1 + 44) - dest;
            else
              v11 = *(a1 + 48) - dest - 1;
            v22 = v11;
            if ( dest == *(a1 + 44) && *(a1 + 48) != *(a1 + 40) )
            {
              dest = *(a1 + 40);
              if ( dest >= *(a1 + 48) )
                v10 = *(a1 + 44) - dest;
              else
                v10 = *(a1 + 48) - dest - 1;
              v22 = v10;
            }
            if ( !v22 )
              goto LABEL_53;
          }
        }
        a3 = 0;
        n = *(a1 + 4);
        if ( n > v24 )
          n = v24;
        if ( n > v22 )
          n = v22;
        memcpy(dest, src, n);
        src = src + n;
        v24 -= n;
        dest = dest + n;
        v22 -= n;
        *(a1 + 4) -= n;
        if ( !*(a1 + 4) )
        {
          if ( *(a1 + 24) )
            v9 = 7;
          else
            v9 = 0;
          *a1 = v9;
        }
        continue;
      case 3:
        break;
      case 4:
        goto LABEL_72;
      case 5:
        goto LABEL_85;
      case 6:
        goto LABEL_121;
      case 7:
        goto LABEL_129;
      case 8:
        goto LABEL_135;
      case 9:
        *(a1 + 32) = v27;
        *(a1 + 28) = v26;
        *(a2 + 4) = v24;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80CE87C(a1, a2, -3);
    }
    while ( v26 <= 0xD )
    {
      if ( !v24 )
        goto LABEL_53;
      a3 = 0;
      --v24;
      v27 |= *src << v26;
      src = src + 1;
      v26 += 8;
    }
    n = v27 & 0x3FFF;
    *(a1 + 4) = n;
    if ( (n & 0x1F) > 0x1D || ((n >> 5) & 0x1F) > 0x1D )
    {
      *a1 = 9;
      *(a2 + 24) = "too many length or distance symbols";
      *(a1 + 32) = v27;
      *(a1 + 28) = v26;
      *(a2 + 4) = v24;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80CE87C(a1, a2, -3);
    }
    n = ((n >> 5) & 0x1F) + (n & 0x1F) + 258;
    *(a1 + 12) = (*(a2 + 32))(*(a2 + 40), n, 4);
    if ( !*(a1 + 12) )
      goto LABEL_119;
    v27 >>= 14;
    v26 -= 14;
    *(a1 + 8) = 0;
    *a1 = 4;
LABEL_72:
    while ( *(a1 + 8) < ((*(a1 + 4) >> 10) + 4) )
    {
      while ( v26 <= 2 )
      {
        if ( !v24 )
          goto LABEL_53;
        a3 = 0;
        --v24;
        v27 |= *src << v26;
        src = src + 1;
        v26 += 8;
      }
      *(*(a1 + 12) + 4 * dword_80EBAA0[(*(a1 + 8))++]) = v27 & 7;
      v27 >>= 3;
      v26 -= 3;
    }
    while ( *(a1 + 8) <= 0x12u )
      *(*(a1 + 12) + 4 * dword_80EBAA0[(*(a1 + 8))++]) = 0;
    *(a1 + 16) = 7;
    n = sub_80CF294(*(a1 + 12), (a1 + 16), (a1 + 20), *(a1 + 36), a2);
    if ( n )
    {
      (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
      a3 = n;
      if ( n == -3 )
        *a1 = 9;
LABEL_53:
      *(a1 + 32) = v27;
      *(a1 + 28) = v26;
      *(a2 + 4) = v24;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80CE87C(a1, a2, a3);
    }
    *(a1 + 8) = 0;
    *a1 = 5;
LABEL_85:
    while ( 1 )
    {
      n = *(a1 + 4);
      if ( *(a1 + 8) >= ((n >> 5) & 0x1F) + (n & 0x1F) + 258 )
        break;
      n = *(a1 + 16);
      while ( v26 < n )
      {
        if ( !v24 )
          goto LABEL_53;
        a3 = 0;
        --v24;
        v27 |= *src << v26;
        src = src + 1;
        v26 += 8;
      }
      v18 = *(a1 + 20) + 8 * (v27 & dword_80F77A0[n]);
      n = *(v18 + 1);
      v21 = *(v18 + 4);
      if ( v21 > 0xF )
      {
        if ( v21 == 18 )
          v8 = 7;
        else
          v8 = v21 - 14;
        v19 = v8;
        if ( v21 == 18 )
          v7 = 11;
        else
          v7 = 3;
        v20 = v7;
        while ( v26 < n + v19 )
        {
          if ( !v24 )
            goto LABEL_53;
          a3 = 0;
          --v24;
          v27 |= *src << v26;
          src = src + 1;
          v26 += 8;
        }
        v27 >>= n;
        v26 -= n;
        v20 += dword_80F77A0[v19] & v27;
        v27 >>= v19;
        v26 -= v19;
        v19 = *(a1 + 8);
        n = *(a1 + 4);
        if ( v20 + v19 > ((n >> 5) & 0x1F) + (n & 0x1F) + 258 || v21 == 16 && !v19 )
        {
          (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
          *a1 = 9;
          *(a2 + 24) = "invalid bit length repeat";
          *(a1 + 32) = v27;
          *(a1 + 28) = v26;
          *(a2 + 4) = v24;
          *(a2 + 8) += src - *a2;
          *a2 = src;
          *(a1 + 52) = dest;
          return sub_80CE87C(a1, a2, -3);
        }
        if ( v21 == 16 )
          v6 = *(*(a1 + 12) + 4 * v19 - 4);
        else
          v6 = 0;
        v21 = v6;
        do
        {
          *(*(a1 + 12) + 4 * v19++) = v21;
          --v20;
        }
        while ( v20 );
        *(a1 + 8) = v19;
      }
      else
      {
        v27 >>= n;
        v26 -= n;
        *(*(a1 + 12) + 4 * (*(a1 + 8))++) = v21;
      }
    }
    *(a1 + 20) = 0;
    v18 = 9;
    v19 = 6;
    n = *(a1 + 4);
    n = sub_80CF37E((n & 0x1F) + 257, ((n >> 5) & 0x1F) + 1, *(a1 + 12), &v18, &v19, &v20, &v21, *(a1 + 36), a2);
    (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
    if ( n )
    {
      if ( n == -3 )
        *a1 = 9;
      v29 = n;
      *(a1 + 32) = v27;
      *(a1 + 28) = v26;
      *(a2 + 4) = v24;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80CE87C(a1, a2, v29);
    }
    v17 = sub_80CFC00(v18, v19, v20, v21, a2);
    if ( !v17 )
    {
LABEL_119:
      *(a1 + 32) = v27;
      *(a1 + 28) = v26;
      *(a2 + 4) = v24;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80CE87C(a1, a2, -4);
    }
    *(a1 + 4) = v17;
    *a1 = 6;
LABEL_121:
    *(a1 + 32) = v27;
    *(a1 + 28) = v26;
    *(a2 + 4) = v24;
    *(a2 + 8) += src - *a2;
    *a2 = src;
    *(a1 + 52) = dest;
    v30 = sub_80CFC66(a1, a2, a3);
    if ( v30 != 1 )
      return sub_80CE87C(a1, a2, v30);
    a3 = 0;
    sub_80D09EA(*(a1 + 4), a2);
    src = *a2;
    v24 = *(a2 + 4);
    v27 = *(a1 + 32);
    v26 = *(a1 + 28);
    dest = *(a1 + 52);
    v5 = dest >= *(a1 + 48) ? *(a1 + 44) - dest : *(a1 + 48) - dest - 1;
    v22 = v5;
    if ( *(a1 + 24) )
      break;
    *a1 = 0;
  }
  *a1 = 7;
LABEL_129:
  *(a1 + 52) = dest;
  a3 = sub_80CE87C(a1, a2, a3);
  dest = *(a1 + 52);
  if ( dest >= *(a1 + 48) )
    v4 = *(a1 + 44) - dest;
  else
    v4 = *(a1 + 48) - dest - 1;
  v22 = v4;
  if ( *(a1 + 48) != *(a1 + 52) )
    goto LABEL_53;
  *a1 = 8;
LABEL_135:
  *(a1 + 32) = v27;
  *(a1 + 28) = v26;
  *(a2 + 4) = v24;
  *(a2 + 8) += src - *a2;
  *a2 = src;
  *(a1 + 52) = dest;
  return sub_80CE87C(a1, a2, 1);
}

//----- (080CE7B2) --------------------------------------------------------
int __cdecl sub_80CE7B2(int a1, int a2)
{
  sub_80CD186(a1, a2, 0);
  (*(a2 + 36))(*(a2 + 40), *(a1 + 40));
  (*(a2 + 36))(*(a2 + 40), *(a1 + 36));
  (*(a2 + 36))(*(a2 + 40), a1);
  return 0;
}

//----- (080CE828) --------------------------------------------------------
int __cdecl sub_80CE828(int a1, void *src, size_t n)
{
  int result; // eax

  memcpy(*(a1 + 40), src, n);
  *(a1 + 52) = *(a1 + 40) + n;
  result = *(a1 + 52);
  *(a1 + 48) = result;
  return result;
}

//----- (080CE86A) --------------------------------------------------------
_BOOL4 __cdecl sub_80CE86A(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (080CE87C) --------------------------------------------------------
int __cdecl sub_80CE87C(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *srcb; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  char *desta; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]

  dest = a2[3];
  src = *(a1 + 48);
  if ( src > *(a1 + 52) )
    v3 = *(a1 + 44);
  else
    v3 = *(a1 + 52);
  n = v3 - src;
  if ( (v3 - src) > a2[4] )
    n = a2[4];
  if ( n && a3 == -5 )
    a3 = 0;
  a2[4] -= n;
  a2[5] += n;
  if ( *(a1 + 56) )
  {
    *(a1 + 60) = (*(a1 + 56))(*(a1 + 60), src, n);
    a2[12] = *(a1 + 60);
  }
  memcpy(dest, src, n);
  desta = &dest[n];
  srca = &src[n];
  if ( srca == *(a1 + 44) )
  {
    srcb = *(a1 + 40);
    if ( *(a1 + 52) == *(a1 + 44) )
      *(a1 + 52) = *(a1 + 40);
    na = *(a1 + 52) - srcb;
    if ( na > a2[4] )
      na = a2[4];
    if ( na && a3 == -5 )
      a3 = 0;
    a2[4] -= na;
    a2[5] += na;
    if ( *(a1 + 56) )
    {
      *(a1 + 60) = (*(a1 + 56))(*(a1 + 60), srcb, na);
      a2[12] = *(a1 + 60);
    }
    memcpy(desta, srcb, na);
    desta += na;
    srca = &srcb[na];
  }
  a2[3] = desta;
  *(a1 + 48) = srca;
  return a3;
}

//----- (080CEA70) --------------------------------------------------------
int __cdecl sub_80CEA70(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10)
{
  int v10; // ebx
  int v11; // ecx
  int v12; // edx
  int v13; // ebx
  int v14; // ecx
  int v15; // edx
  int v17; // [esp+0h] [ebp-128h]
  char v18; // [esp+7h] [ebp-121h]
  unsigned int v19; // [esp+8h] [ebp-120h]
  int v20; // [esp+Ch] [ebp-11Ch]
  _DWORD *v21; // [esp+10h] [ebp-118h]
  _DWORD *v22; // [esp+10h] [ebp-118h]
  int *v23; // [esp+10h] [ebp-118h]
  int *v24; // [esp+10h] [ebp-118h]
  int v25; // [esp+14h] [ebp-114h]
  unsigned int i; // [esp+18h] [ebp-110h]
  int v27; // [esp+18h] [ebp-110h]
  int v28; // [esp+18h] [ebp-110h]
  unsigned int v29; // [esp+18h] [ebp-110h]
  unsigned int l; // [esp+18h] [ebp-110h]
  unsigned int m; // [esp+18h] [ebp-110h]
  unsigned int v32; // [esp+1Ch] [ebp-10Ch]
  unsigned int j; // [esp+1Ch] [ebp-10Ch]
  unsigned int v34; // [esp+1Ch] [ebp-10Ch]
  unsigned int v35; // [esp+1Ch] [ebp-10Ch]
  int v36; // [esp+20h] [ebp-108h]
  unsigned int v37; // [esp+24h] [ebp-104h]
  int v38; // [esp+28h] [ebp-100h]
  int v39; // [esp+28h] [ebp-100h]
  int v40; // [esp+28h] [ebp-100h]
  _DWORD *k; // [esp+2Ch] [ebp-FCh]
  int *v42; // [esp+2Ch] [ebp-FCh]
  int v43[2]; // [esp+30h] [ebp-F8h]
  _BYTE v44[56]; // [esp+38h] [ebp-F0h] BYREF
  int v45[16]; // [esp+70h] [ebp-B8h]
  int v46; // [esp+B0h] [ebp-78h]
  int v47; // [esp+B4h] [ebp-74h]
  int v48; // [esp+B8h] [ebp-70h]
  int n; // [esp+BCh] [ebp-6Ch]
  unsigned int v50; // [esp+C0h] [ebp-68h]
  int v51; // [esp+C4h] [ebp-64h]
  int v52; // [esp+C8h] [ebp-60h]
  unsigned int v53; // [esp+CCh] [ebp-5Ch]
  int v54[19]; // [esp+D0h] [ebp-58h] BYREF
  _DWORD v55[18]; // [esp+D4h] [ebp-54h] BYREF
  int v56; // [esp+11Ch] [ebp-Ch]
  int v57; // [esp+134h] [ebp+Ch]

  v54[0] = 0;
  v55[0] = 0;
  v55[1] = 0;
  v55[2] = 0;
  v55[3] = 0;
  v55[4] = 0;
  v55[5] = 0;
  v55[6] = 0;
  v55[7] = 0;
  v55[8] = 0;
  v55[9] = 0;
  v55[10] = 0;
  v55[11] = 0;
  v55[12] = 0;
  v55[13] = 0;
  v55[14] = 0;
  v21 = a1;
  v32 = a2;
  do
  {
    ++v54[*v21++];
    --v32;
  }
  while ( v32 );
  if ( v54[0] == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    v36 = 0;
  }
  else
  {
    v50 = *a7;
    for ( i = 1; i <= 0xF && !v54[i]; ++i )
      ;
    v25 = i;
    if ( v50 < i )
      v50 = i;
    for ( j = 15; j && !v54[j]; --j )
      ;
    v52 = j;
    if ( v50 > j )
      v50 = j;
    *a7 = v50;
    v38 = 1 << i;
    while ( i < j )
    {
      v39 = v38 - v54[i];
      if ( v39 < 0 )
        return -3;
      ++i;
      v38 = 2 * v39;
    }
    v40 = v38 - v54[j];
    if ( v40 >= 0 )
    {
      v54[j] += v40;
      v27 = 0;
      v43[1] = 0;
      v22 = v55;
      for ( k = v44; --j; ++k )
      {
        v27 += *v22;
        *k = v27;
        ++v22;
      }
      v23 = a1;
      v34 = 0;
      do
      {
        v28 = *v23++;
        if ( v28 )
          a10[v43[v28]++] = v34;
        ++v34;
      }
      while ( v34 < a2 );
      v57 = v43[v52];
      v35 = 0;
      v43[0] = 0;
      v24 = a10;
      v51 = -1;
      v20 = -v50;
      v45[0] = 0;
      v48 = 0;
      v37 = 0;
      while ( v25 <= v52 )
      {
        v56 = v54[v25];
        while ( --v56 != -1 )
        {
          while ( v25 > (v50 + v20) )
          {
            ++v51;
            v20 += v50;
            v19 = v52 - v20;
            if ( v52 - v20 > v50 )
              v19 = v50;
            v29 = v25 - v20;
            v53 = 1 << (v25 - v20);
            if ( v53 > v56 + 1 )
            {
              v53 = v53 - v56 - 1;
              v42 = &v54[v25];
              if ( v29 < v19 )
              {
                while ( ++v29 < v19 )
                {
                  v53 *= 2;
                  if ( v53 <= *++v42 )
                    break;
                  v53 -= *v42;
                }
              }
            }
            v37 = 1 << v29;
            if ( (*a9 + (1 << v29)) > 0x5A0 )
              return -4;
            v48 = a8 + 8 * *a9;
            v45[v51] = v48;
            *a9 += v37;
            if ( v51 )
            {
              v43[v51] = v35;
              BYTE1(v46) = v50;
              LOBYTE(v46) = v29;
              v47 = ((v48 - *&v44[4 * v51 + 52]) >> 3) - (v35 >> (v20 - v50));
              v10 = 8 * (v35 >> (v20 - v50));
              v11 = *&v44[4 * v51 + 52];
              v12 = v47;
              *(v11 + v10) = v46;
              *(v11 + v10 + 4) = v12;
            }
            else
            {
              *a6 = v48;
            }
          }
          BYTE1(v46) = v25 - v20;
          if ( v24 < &a10[v57] )
          {
            if ( *v24 >= a3 )
            {
              LOBYTE(v46) = *(a5 + 4 * (*v24 - a3)) + 80;
              v47 = *(a4 + 4 * (*v24++ - a3));
            }
            else
            {
              if ( *v24 <= 0xFF )
                v18 = 0;
              else
                v18 = 96;
              LOBYTE(v46) = v18;
              v47 = *v24++;
            }
          }
          else
          {
            LOBYTE(v46) = -64;
          }
          v53 = 1 << (v25 - v20);
          for ( l = v35 >> v20; l < v37; l += v53 )
          {
            v13 = 8 * l;
            v14 = v48;
            v15 = v47;
            *(v48 + v13) = v46;
            *(v14 + v13 + 4) = v15;
          }
          for ( m = 1 << (v25 - 1); (m & v35) != 0; m >>= 1 )
            v35 ^= m;
          v35 ^= m;
          for ( n = (1 << v20) - 1; (n & v35) != v43[v51]; n = (1 << v20) - 1 )
          {
            --v51;
            v20 -= v50;
          }
        }
        ++v25;
      }
      if ( !v40 || v52 == 1 )
        v17 = 0;
      else
        v17 = -5;
      v36 = v17;
    }
    else
    {
      v36 = -3;
    }
  }
  return v36;
}
// 80CEA70: using guessed type int var_58[19];

//----- (080CF294) --------------------------------------------------------
int __cdecl sub_80CF294(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  int *v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h] BYREF
  int v9; // [esp+34h] [ebp-4h]

  v8 = 0;
  v7 = (*(a5 + 32))(*(a5 + 40), 19, 4);
  if ( !v7 )
    return -4;
  v9 = sub_80CEA70(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v8, v7);
  if ( v9 == -3 )
  {
    *(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v9 == -5 || !*a2 )
  {
    *(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(a5 + 36))(*(a5 + 40), v7);
  return v9;
}

//----- (080CF37E) --------------------------------------------------------
int __cdecl sub_80CF37E(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9)
{
  int *v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v11 = (*(a9 + 32))(*(a9 + 40), 288, 4);
  if ( !v11 )
    return -4;
  v13 = sub_80CEA70(a3, a1, 0x101u, &unk_80EBB40, &unk_80EBBC0, a6, a4, a8, &v12, v11);
  if ( !v13 && *a4 )
  {
    v13 = sub_80CEA70(&a3[a1], a2, 0, &unk_80EBC40, &unk_80EBCC0, a7, a5, a8, &v12, v11);
    if ( !v13 && (*a5 || a1 <= 0x101) )
    {
      (*(a9 + 36))(*(a9 + 40), v11);
      return 0;
    }
    if ( v13 == -3 )
    {
      *(a9 + 24) = "oversubscribed distance tree";
    }
    else if ( v13 == -5 )
    {
      *(a9 + 24) = "incomplete distance tree";
      v13 = -3;
    }
    else if ( v13 != -4 )
    {
      *(a9 + 24) = "empty distance tree with lengths";
      v13 = -3;
    }
  }
  else if ( v13 == -3 )
  {
    *(a9 + 24) = "oversubscribed literal/length tree";
  }
  else if ( v13 != -4 )
  {
    *(a9 + 24) = "incomplete literal/length tree";
    v13 = -3;
  }
  (*(a9 + 36))(*(a9 + 40), v11);
  return v13;
}

//----- (080CF562) --------------------------------------------------------
int __cdecl sub_80CF562(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_80F77E4;
  *a2 = dword_80F77E8;
  *a3 = &unk_80F7800;
  *a4 = &unk_80F8800;
  return 0;
}
// 80F77E4: using guessed type int dword_80F77E4;
// 80F77E8: using guessed type int dword_80F77E8;

//----- (080CF592) --------------------------------------------------------
int __cdecl sub_80CF592(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  unsigned int v7; // [esp+0h] [ebp-60h]
  unsigned int v8; // [esp+8h] [ebp-58h]
  unsigned int v9; // [esp+10h] [ebp-50h]
  unsigned int v10; // [esp+18h] [ebp-48h]
  int v11; // [esp+20h] [ebp-40h]
  int v12; // [esp+24h] [ebp-3Ch]
  _BYTE *v13; // [esp+28h] [ebp-38h]
  _BYTE *v14; // [esp+28h] [ebp-38h]
  unsigned int v15; // [esp+2Ch] [ebp-34h]
  unsigned int v16; // [esp+30h] [ebp-30h]
  int v17; // [esp+34h] [ebp-2Ch]
  int v18; // [esp+38h] [ebp-28h]
  unsigned int v19; // [esp+3Ch] [ebp-24h]
  _BYTE *v20; // [esp+40h] [ebp-20h]
  _BYTE *v21; // [esp+40h] [ebp-20h]
  unsigned int v22; // [esp+44h] [ebp-1Ch]
  unsigned __int8 *v23; // [esp+48h] [ebp-18h]
  unsigned __int8 *v24; // [esp+48h] [ebp-18h]
  unsigned __int8 *v25; // [esp+48h] [ebp-18h]
  unsigned __int8 *v26; // [esp+48h] [ebp-18h]
  unsigned __int8 *v27; // [esp+48h] [ebp-18h]
  unsigned int v28; // [esp+4Ch] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-14h]
  unsigned int v30; // [esp+50h] [ebp-10h]
  unsigned int v31; // [esp+50h] [ebp-10h]
  int v32; // [esp+54h] [ebp-Ch]
  int v33; // [esp+54h] [ebp-Ch]
  int j; // [esp+54h] [ebp-Ch]
  unsigned int v35; // [esp+54h] [ebp-Ch]
  unsigned int v36; // [esp+54h] [ebp-Ch]
  unsigned __int8 *v37; // [esp+58h] [ebp-8h]
  unsigned __int8 *v38; // [esp+58h] [ebp-8h]

  v23 = *a6;
  v22 = a6[1];
  v30 = a5[8];
  v28 = a5[7];
  v20 = a5[13];
  if ( v20 >= a5[12] )
    v11 = a5[11] - v20;
  else
    v11 = a5[12] - v20 - 1;
  v19 = v11;
  v18 = dword_80F77A0[a1];
  v17 = dword_80F77A0[a2];
  while ( 1 )
  {
    while ( v28 <= 0x13 )
    {
      --v22;
      v30 |= *v23++ << v28;
      v28 += 8;
    }
    v37 = (a3 + 8 * (v30 & v18));
    v32 = *v37;
    if ( *v37 )
      break;
    v30 >>= v37[1];
    v28 -= v37[1];
    *v20++ = v37[4];
    --v19;
LABEL_41:
    if ( v19 <= 0x101 || v22 <= 9 )
    {
      v7 = a6[1] - v22;
      if ( v7 > v28 >> 3 )
        v7 = v28 >> 3;
      v27 = &v23[-v7];
      a5[8] = v30;
      a5[7] = v28 - 8 * v7;
      a6[1] = v7 + v22;
      a6[2] += &v27[-*a6];
      *a6 = v27;
      a5[13] = v20;
      return 0;
    }
  }
  while ( 1 )
  {
    v30 >>= v37[1];
    v28 -= v37[1];
    if ( (v32 & 0x10) != 0 )
      break;
    if ( (v32 & 0x40) != 0 )
    {
      if ( (v32 & 0x20) != 0 )
      {
        v9 = a6[1] - v22;
        if ( v9 > v28 >> 3 )
          v9 = v28 >> 3;
        v25 = &v23[-v9];
        a5[8] = v30;
        a5[7] = v28 - 8 * v9;
        a6[1] = v9 + v22;
        a6[2] += &v25[-*a6];
        *a6 = v25;
        a5[13] = v20;
        v12 = 1;
      }
      else
      {
        a6[6] = "invalid literal/length code";
        v8 = a6[1] - v22;
        if ( v8 > v28 >> 3 )
          v8 = v28 >> 3;
        v26 = &v23[-v8];
        a5[8] = v30;
        a5[7] = v28 - 8 * v8;
        a6[1] = v8 + v22;
        a6[2] += &v26[-*a6];
        *a6 = v26;
        a5[13] = v20;
        v12 = -3;
      }
      return v12;
    }
    v37 += 8 * (v30 & dword_80F77A0[v32]) + 8 * *(v37 + 1);
    v32 = *v37;
    if ( !*v37 )
    {
      v30 >>= v37[1];
      v28 -= v37[1];
      *v20++ = v37[4];
      --v19;
      goto LABEL_41;
    }
  }
  v33 = v32 & 0xF;
  v16 = *(v37 + 1) + (v30 & dword_80F77A0[v33]);
  v31 = v30 >> v33;
  for ( i = v28 - v33; i <= 0xE; i += 8 )
  {
    --v22;
    v31 |= *v23++ << i;
  }
  v38 = (a4 + 8 * (v31 & v17));
  for ( j = *v38; ; j = *v38 )
  {
    v31 >>= v38[1];
    i -= v38[1];
    if ( (j & 0x10) != 0 )
    {
      v35 = j & 0xF;
      while ( i < v35 )
      {
        --v22;
        v31 |= *v23++ << i;
        i += 8;
      }
      v15 = *(v38 + 1) + (v31 & dword_80F77A0[v35]);
      v30 = v31 >> v35;
      v28 = i - v35;
      v19 -= v16;
      if ( &v20[-a5[10]] < v15 )
      {
        v36 = v15 - &v20[-a5[10]];
        v14 = (a5[11] - v36);
        if ( v16 > v36 )
        {
          v16 -= v36;
          do
          {
            *v20++ = *v14++;
            --v36;
          }
          while ( v36 );
          v14 = a5[10];
        }
      }
      else
      {
        *v20 = v20[-v15];
        v13 = &v20[-v15 + 1];
        v21 = v20 + 1;
        *v21 = *v13;
        v14 = v13 + 1;
        v20 = v21 + 1;
        v16 -= 2;
      }
      do
      {
        *v20++ = *v14++;
        --v16;
      }
      while ( v16 );
      goto LABEL_41;
    }
    if ( (j & 0x40) != 0 )
      break;
    v38 += 8 * (v31 & dword_80F77A0[j]) + 8 * *(v38 + 1);
  }
  a6[6] = "invalid distance code";
  v10 = a6[1] - v22;
  if ( v10 > i >> 3 )
    v10 = i >> 3;
  v24 = &v23[-v10];
  a5[8] = v31;
  a5[7] = i - 8 * v10;
  a6[1] = v10 + v22;
  a6[2] += &v24[-*a6];
  *a6 = v24;
  a5[13] = v20;
  return -3;
}

//----- (080CFC00) --------------------------------------------------------
int __cdecl sub_80CFC00(char a1, char a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = (*(a5 + 32))(*(a5 + 40), 1, 28);
  if ( v6 )
  {
    *v6 = 0;
    *(v6 + 16) = a1;
    *(v6 + 17) = a2;
    *(v6 + 20) = a3;
    *(v6 + 24) = a4;
  }
  return v6;
}

//----- (080CFC66) --------------------------------------------------------
int __cdecl sub_80CFC66(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+28h] [ebp-60h]
  int v5; // [esp+2Ch] [ebp-5Ch]
  int v6; // [esp+30h] [ebp-58h]
  int v7; // [esp+34h] [ebp-54h]
  int v8; // [esp+38h] [ebp-50h]
  int v9; // [esp+3Ch] [ebp-4Ch]
  int v10; // [esp+40h] [ebp-48h]
  int v11; // [esp+44h] [ebp-44h]
  int v12; // [esp+4Ch] [ebp-3Ch]
  int v13; // [esp+50h] [ebp-38h]
  int v15; // [esp+58h] [ebp-30h]
  _BYTE *v16; // [esp+5Ch] [ebp-2Ch]
  unsigned int v17; // [esp+60h] [ebp-28h]
  _BYTE *v18; // [esp+64h] [ebp-24h]
  unsigned int v19; // [esp+68h] [ebp-20h]
  unsigned __int8 *v20; // [esp+6Ch] [ebp-1Ch]
  unsigned int v21; // [esp+70h] [ebp-18h]
  unsigned int v22; // [esp+74h] [ebp-14h]
  int v23; // [esp+78h] [ebp-10h]
  int v24; // [esp+78h] [ebp-10h]
  unsigned __int8 *v25; // [esp+7Ch] [ebp-Ch]
  unsigned __int8 *v26; // [esp+7Ch] [ebp-Ch]
  unsigned int v27; // [esp+80h] [ebp-8h]
  unsigned int v28; // [esp+80h] [ebp-8h]
  unsigned int v29; // [esp+80h] [ebp-8h]
  unsigned int v30; // [esp+80h] [ebp-8h]
  int v31; // [esp+98h] [ebp+10h]

  v15 = a1[1];
  v20 = *a2;
  v19 = a2[1];
  v22 = a1[8];
  v21 = a1[7];
  v18 = a1[13];
  if ( v18 >= a1[12] )
    v13 = a1[11] - v18;
  else
    v13 = a1[12] - v18 - 1;
  v17 = v13;
  while ( 2 )
  {
    if ( *v15 > 9u )
    {
      a1[8] = v22;
      a1[7] = v21;
      a2[1] = v19;
      a2[2] += &v20[-*a2];
      *a2 = v20;
      a1[13] = v18;
      return sub_80CE87C(a1, a2, -2);
    }
    switch ( *v15 )
    {
      case 0:
        if ( v17 <= 0x101 || v19 <= 9 )
          goto LABEL_17;
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        a3 = sub_80CF592(*(v15 + 16), *(v15 + 17), *(v15 + 20), *(v15 + 24), a1, a2);
        v20 = *a2;
        v19 = a2[1];
        v22 = a1[8];
        v21 = a1[7];
        v18 = a1[13];
        v12 = v18 >= a1[12] ? a1[11] - v18 : a1[12] - v18 - 1;
        v17 = v12;
        if ( !a3 )
        {
LABEL_17:
          *(v15 + 12) = *(v15 + 16);
          *(v15 + 8) = *(v15 + 20);
          *v15 = 1;
          goto LABEL_18;
        }
        if ( a3 == 1 )
          v11 = 7;
        else
          v11 = 9;
        *v15 = v11;
        continue;
      case 1:
LABEL_18:
        v27 = *(v15 + 12);
        while ( 2 )
        {
          if ( v21 < v27 )
          {
            if ( v19 )
            {
              a3 = 0;
              --v19;
              v22 |= *v20++ << v21;
              v21 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        v25 = (*(v15 + 8) + 8 * (v22 & dword_80F77A0[v27]));
        v22 >>= v25[1];
        v21 -= v25[1];
        v23 = *v25;
        if ( *v25 )
        {
          if ( (v23 & 0x10) != 0 )
          {
            *(v15 + 8) = v23 & 0xF;
            *(v15 + 4) = *(v25 + 1);
            *v15 = 2;
          }
          else if ( (v23 & 0x40) != 0 )
          {
            if ( (v23 & 0x20) == 0 )
            {
              *v15 = 9;
              a2[6] = "invalid literal/length code";
              a1[8] = v22;
              a1[7] = v21;
              a2[1] = v19;
              a2[2] += &v20[-*a2];
              *a2 = v20;
              a1[13] = v18;
              return sub_80CE87C(a1, a2, -3);
            }
            *v15 = 7;
          }
          else
          {
            *(v15 + 12) = v23;
            *(v15 + 8) = &v25[8 * *(v25 + 1)];
          }
        }
        else
        {
          *(v15 + 8) = *(v25 + 1);
          *v15 = 6;
        }
        continue;
      case 2:
        v28 = *(v15 + 8);
        while ( 2 )
        {
          if ( v21 < v28 )
          {
            if ( v19 )
            {
              a3 = 0;
              --v19;
              v22 |= *v20++ << v21;
              v21 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        *(v15 + 4) += v22 & dword_80F77A0[v28];
        v22 >>= v28;
        v21 -= v28;
        *(v15 + 12) = *(v15 + 17);
        *(v15 + 8) = *(v15 + 24);
        *v15 = 3;
LABEL_38:
        v29 = *(v15 + 12);
        while ( v21 < v29 )
        {
          if ( !v19 )
            goto LABEL_52;
          a3 = 0;
          --v19;
          v22 |= *v20++ << v21;
          v21 += 8;
        }
        v26 = (*(v15 + 8) + 8 * (v22 & dword_80F77A0[v29]));
        v22 >>= v26[1];
        v21 -= v26[1];
        v24 = *v26;
        if ( (v24 & 0x10) != 0 )
        {
          *(v15 + 8) = v24 & 0xF;
          *(v15 + 12) = *(v26 + 1);
          *v15 = 4;
        }
        else
        {
          if ( (v24 & 0x40) != 0 )
          {
            *v15 = 9;
            a2[6] = "invalid distance code";
            a1[8] = v22;
            a1[7] = v21;
            a2[1] = v19;
            a2[2] += &v20[-*a2];
            *a2 = v20;
            a1[13] = v18;
            return sub_80CE87C(a1, a2, -3);
          }
          *(v15 + 12) = v24;
          *(v15 + 8) = &v26[8 * *(v26 + 1)];
        }
        continue;
      case 3:
        goto LABEL_38;
      case 4:
        v30 = *(v15 + 8);
LABEL_49:
        if ( v21 >= v30 )
        {
          *(v15 + 12) += v22 & dword_80F77A0[v30];
          v22 >>= v30;
          v21 -= v30;
          *v15 = 5;
LABEL_54:
          if ( &v18[-a1[10]] >= *(v15 + 12) )
            v10 = &v18[-*(v15 + 12)];
          else
            v10 = a1[11] - (*(v15 + 12) - &v18[-a1[10]]);
          v16 = v10;
          while ( *(v15 + 4) )
          {
            if ( !v17 )
            {
              if ( v18 == a1[11] && a1[12] != a1[10] )
              {
                v18 = a1[10];
                if ( v18 >= a1[12] )
                  v9 = a1[11] - v18;
                else
                  v9 = a1[12] - v18 - 1;
                v17 = v9;
              }
              if ( !v17 )
              {
                a1[13] = v18;
                v31 = sub_80CE87C(a1, a2, a3);
                v18 = a1[13];
                if ( v18 >= a1[12] )
                  v8 = a1[11] - v18;
                else
                  v8 = a1[12] - v18 - 1;
                v17 = v8;
                if ( v18 == a1[11] && a1[12] != a1[10] )
                {
                  v18 = a1[10];
                  if ( v18 >= a1[12] )
                    v7 = a1[11] - v18;
                  else
                    v7 = a1[12] - v18 - 1;
                  v17 = v7;
                }
                if ( !v17 )
                {
LABEL_100:
                  a1[8] = v22;
                  a1[7] = v21;
                  a2[1] = v19;
                  a2[2] += &v20[-*a2];
                  *a2 = v20;
                  a1[13] = v18;
                  return sub_80CE87C(a1, a2, v31);
                }
              }
            }
            a3 = 0;
            *v18++ = *v16++;
            --v17;
            if ( v16 == a1[11] )
              v16 = a1[10];
            --*(v15 + 4);
          }
          *v15 = 0;
          continue;
        }
        if ( v19 )
        {
          a3 = 0;
          --v19;
          v22 |= *v20++ << v21;
          v21 += 8;
          goto LABEL_49;
        }
LABEL_52:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = 0;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CE87C(a1, a2, a3);
      case 5:
        goto LABEL_54;
      case 6:
        if ( !v17 )
        {
          if ( v18 == a1[11] && a1[12] != a1[10] )
          {
            v18 = a1[10];
            if ( v18 >= a1[12] )
              v6 = a1[11] - v18;
            else
              v6 = a1[12] - v18 - 1;
            v17 = v6;
          }
          if ( !v17 )
          {
            a1[13] = v18;
            v31 = sub_80CE87C(a1, a2, a3);
            v18 = a1[13];
            if ( v18 >= a1[12] )
              v5 = a1[11] - v18;
            else
              v5 = a1[12] - v18 - 1;
            v17 = v5;
            if ( v18 == a1[11] && a1[12] != a1[10] )
            {
              v18 = a1[10];
              if ( v18 >= a1[12] )
                v4 = a1[11] - v18;
              else
                v4 = a1[12] - v18 - 1;
              v17 = v4;
            }
            if ( !v17 )
              goto LABEL_100;
          }
        }
        a3 = 0;
        *v18++ = *(v15 + 8);
        --v17;
        *v15 = 0;
        continue;
      case 7:
        if ( v21 > 7 )
        {
          v21 -= 8;
          ++v19;
          --v20;
        }
        a1[13] = v18;
        v31 = sub_80CE87C(a1, a2, a3);
        v18 = a1[13];
        if ( a1[12] != v18 )
          goto LABEL_100;
        *v15 = 8;
LABEL_106:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CE87C(a1, a2, 1);
      case 8:
        goto LABEL_106;
      case 9:
        a1[8] = v22;
        a1[7] = v21;
        a2[1] = v19;
        a2[2] += &v20[-*a2];
        *a2 = v20;
        a1[13] = v18;
        return sub_80CE87C(a1, a2, -3);
    }
  }
}

//----- (080D09EA) --------------------------------------------------------
int __cdecl sub_80D09EA(int a1, int a2)
{
  return (*(a2 + 36))(*(a2 + 40), a1);
}

//----- (080D0A0A) --------------------------------------------------------
int __cdecl sub_80D0A0A(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-14h]
  int v6; // [esp+8h] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  unsigned int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+10h] [ebp-4h]
  int v26; // [esp+10h] [ebp-4h]
  int v27; // [esp+10h] [ebp-4h]
  int v28; // [esp+10h] [ebp-4h]
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+10h] [ebp-4h]
  int v31; // [esp+10h] [ebp-4h]
  int v32; // [esp+10h] [ebp-4h]
  int v33; // [esp+10h] [ebp-4h]
  int v34; // [esp+10h] [ebp-4h]
  int v35; // [esp+10h] [ebp-4h]
  int v36; // [esp+10h] [ebp-4h]
  int v37; // [esp+10h] [ebp-4h]
  int v38; // [esp+10h] [ebp-4h]

  v23 = a1;
  v7 = HIWORD(a1);
  if ( !a2 )
    return 1;
  while ( a3 )
  {
    v4 = a3;
    if ( a3 > 0x15B0 )
      v4 = 5552;
    v6 = v4;
    a3 -= v4;
    while ( v6 > 15 )
    {
      v24 = *a2 + v23;
      v8 = v24 + v7;
      v25 = a2[1] + v24;
      v9 = v25 + v8;
      v26 = a2[2] + v25;
      v10 = v26 + v9;
      v27 = a2[3] + v26;
      v11 = v27 + v10;
      v28 = a2[4] + v27;
      v12 = v28 + v11;
      v29 = a2[5] + v28;
      v13 = v29 + v12;
      v30 = a2[6] + v29;
      v14 = v30 + v13;
      v31 = a2[7] + v30;
      v15 = v31 + v14;
      v32 = a2[8] + v31;
      v16 = v32 + v15;
      v33 = a2[9] + v32;
      v17 = v33 + v16;
      v34 = a2[10] + v33;
      v18 = v34 + v17;
      v35 = a2[11] + v34;
      v19 = v35 + v18;
      v36 = a2[12] + v35;
      v20 = v36 + v19;
      v37 = a2[13] + v36;
      v21 = v37 + v20;
      v38 = a2[14] + v37;
      v22 = v38 + v21;
      v23 = a2[15] + v38;
      v7 = v23 + v22;
      a2 += 16;
      v6 -= 16;
    }
    for ( ; v6; --v6 )
    {
      v23 += *a2++;
      v7 += v23;
    }
    v23 %= 0xFFF1u;
    v7 %= 0xFFF1u;
  }
  return v23 | (v7 << 16);
}

//----- (080D0C56) --------------------------------------------------------
int __cdecl sub_80D0C56(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  if ( !a1 || !a1[7] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( *(a1[7] + 12) )
    v2 = 7;
  else
    v2 = 0;
  *a1[7] = v2;
  sub_80CD186(*(a1[7] + 20), a1, 0);
  return 0;
}

//----- (080D0CEC) --------------------------------------------------------
int __cdecl sub_80D0CEC(_DWORD *a1)
{
  if ( !a1 || !a1[7] || !a1[9] )
    return -2;
  if ( *(a1[7] + 20) )
    sub_80CE7B2(*(a1[7] + 20), a1);
  (a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (080D0D68) --------------------------------------------------------
int __cdecl sub_80D0D68(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // eax
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80D1754;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80D176C;
  a1[7] = (a1[8])(a1[10], 1, 24);
  if ( !a1[7] )
    return -4;
  *(a1[7] + 20) = 0;
  *(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    a2 = -a2;
    *(a1[7] + 12) = 1;
  }
  if ( a2 > 7 && a2 <= 15 )
  {
    *(a1[7] + 16) = a2;
    v7 = a1[7];
    v6 = 1 << a2;
    if ( *(v7 + 12) )
      v4 = sub_80CD256(a1, 0, v6);
    else
      v4 = sub_80CD256(a1, sub_80D0A0A, v6);
    *(v7 + 20) = v4;
    if ( *(v7 + 20) )
    {
      sub_80D0C56(a1);
      v8 = 0;
    }
    else
    {
      sub_80D0CEC(a1);
      v8 = -4;
    }
  }
  else
  {
    sub_80D0CEC(a1);
    v8 = -2;
  }
  return v8;
}

//----- (080D0F00) --------------------------------------------------------
int __cdecl sub_80D0F00(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_80D0D68(a1, 15, a2, a3);
}

//----- (080D0F2A) --------------------------------------------------------
int __cdecl sub_80D0F2A(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int v3; // eax
  unsigned int v4; // ebx
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // ebx
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  if ( a2 == 4 )
    v14 = -5;
  else
    v14 = 0;
  v17 = -5;
  while ( 2 )
  {
    switch ( *a1[7] )
    {
      case 0:
        if ( a1[1] )
        {
          v17 = v14;
          v2 = a1[7];
          --a1[1];
          ++a1[2];
          *(v2 + 1) = **a1;
          v3 = *(v2 + 1) & 0xF;
          ++*a1;
          if ( v3 != 8 )
          {
            *a1[7] = 13;
            a1[6] = "unknown compression method";
            *(a1[7] + 1) = 5;
            continue;
          }
          if ( ((*(a1[7] + 1) >> 4) + 8) > *(a1[7] + 4) )
          {
            *a1[7] = 13;
            a1[6] = "invalid window size";
            *(a1[7] + 1) = 5;
            continue;
          }
          *a1[7] = 1;
          goto LABEL_17;
        }
        v15 = v17;
        break;
      case 1:
LABEL_17:
        if ( a1[1] )
        {
          v17 = v14;
          --a1[1];
          ++a1[2];
          v16 = *(*a1)++;
          v4 = v16 + (*(a1[7] + 1) << 8);
          if ( v4 != 31 * ((((v4 * &unk_8421085) >> 32) + ((v4 - ((v4 * &unk_8421085) >> 32)) >> 1)) >> 4) )
          {
            *a1[7] = 13;
            a1[6] = "incorrect header check";
            *(a1[7] + 1) = 5;
            continue;
          }
          if ( (v16 & 0x20) == 0 )
          {
            *a1[7] = 7;
            continue;
          }
          *a1[7] = 2;
          goto LABEL_24;
        }
        v15 = v17;
        break;
      case 2:
LABEL_24:
        if ( a1[1] )
        {
          v17 = v14;
          v5 = a1[7];
          --a1[1];
          ++a1[2];
          *(v5 + 2) = *(*a1)++ << 24;
          *a1[7] = 3;
          goto LABEL_27;
        }
        v15 = v17;
        break;
      case 3:
LABEL_27:
        if ( a1[1] )
        {
          v17 = v14;
          v6 = a1[7];
          --a1[1];
          ++a1[2];
          *(v6 + 2) = *(a1[7] + 2) + (*(*a1)++ << 16);
          *a1[7] = 4;
          goto LABEL_30;
        }
        v15 = v17;
        break;
      case 4:
LABEL_30:
        if ( a1[1] )
        {
          v17 = v14;
          v7 = a1[7];
          --a1[1];
          ++a1[2];
          *(v7 + 2) = *(a1[7] + 2) + (*(*a1)++ << 8);
          *a1[7] = 5;
          goto LABEL_33;
        }
        v15 = v17;
        break;
      case 5:
LABEL_33:
        if ( a1[1] )
        {
          v8 = a1[7];
          --a1[1];
          ++a1[2];
          *(v8 + 2) = *(a1[7] + 2) + *(*a1)++;
          a1[12] = *(a1[7] + 2);
          *a1[7] = 6;
          v15 = 2;
        }
        else
        {
          v15 = v17;
        }
        break;
      case 6:
        *a1[7] = 13;
        a1[6] = "need dictionary";
        *(a1[7] + 1) = 0;
        v15 = -2;
        break;
      case 7:
        v17 = sub_80CD398(*(a1[7] + 5), a1, v17);
        if ( v17 == -3 )
        {
          *a1[7] = 13;
          *(a1[7] + 1) = 0;
          continue;
        }
        if ( !v17 )
          v17 = v14;
        if ( v17 == 1 )
        {
          v17 = v14;
          sub_80CD186(*(a1[7] + 5), a1, a1[7] + 1);
          if ( *(a1[7] + 3) )
          {
            *a1[7] = 12;
            continue;
          }
          *a1[7] = 8;
          goto LABEL_46;
        }
        v15 = v17;
        break;
      case 8:
LABEL_46:
        if ( a1[1] )
        {
          v17 = v14;
          v9 = a1[7];
          --a1[1];
          ++a1[2];
          *(v9 + 2) = *(*a1)++ << 24;
          *a1[7] = 9;
          goto LABEL_49;
        }
        v15 = v17;
        break;
      case 9:
LABEL_49:
        if ( a1[1] )
        {
          v17 = v14;
          v10 = a1[7];
          --a1[1];
          ++a1[2];
          *(v10 + 2) = *(a1[7] + 2) + (*(*a1)++ << 16);
          *a1[7] = 10;
          goto LABEL_52;
        }
        v15 = v17;
        break;
      case 0xA:
LABEL_52:
        if ( a1[1] )
        {
          v17 = v14;
          v11 = a1[7];
          --a1[1];
          ++a1[2];
          *(v11 + 2) = *(a1[7] + 2) + (*(*a1)++ << 8);
          *a1[7] = 11;
          goto LABEL_55;
        }
        v15 = v17;
        break;
      case 0xB:
LABEL_55:
        if ( a1[1] )
        {
          v17 = v14;
          v12 = a1[7];
          --a1[1];
          ++a1[2];
          *(v12 + 2) = *(a1[7] + 2) + *(*a1)++;
          if ( *(a1[7] + 1) != *(a1[7] + 2) )
          {
            *a1[7] = 13;
            a1[6] = "incorrect data check";
            *(a1[7] + 1) = 5;
            continue;
          }
          *a1[7] = 12;
          goto LABEL_60;
        }
        v15 = v17;
        break;
      case 0xC:
LABEL_60:
        v15 = 1;
        break;
      case 0xD:
        v15 = -3;
        break;
      default:
        v15 = -2;
        break;
    }
    return v15;
  }
}

//----- (080D15BE) --------------------------------------------------------
int __cdecl sub_80D15BE(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+18h] [ebp-10h]
  _BYTE *v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] )
    return -2;
  if ( *a1[7] != 13 )
  {
    *a1[7] = 13;
    *(a1[7] + 4) = 0;
  }
  v7 = a1[1];
  if ( !v7 )
    return -5;
  v6 = *a1;
  v5 = *(a1[7] + 4);
  while ( v7 && v5 <= 3 )
  {
    if ( *v6 == *(v5 + 135181952) )
    {
      ++v5;
    }
    else if ( *v6 )
    {
      v5 = 0;
    }
    else
    {
      v5 = 4 - v5;
    }
    ++v6;
    --v7;
  }
  a1[2] += &v6[-*a1];
  *a1 = v6;
  a1[1] = v7;
  *(a1[7] + 4) = v5;
  if ( v5 != 4 )
    return -3;
  v4 = a1[2];
  v3 = a1[5];
  sub_80D0C56(a1);
  a1[2] = v4;
  a1[5] = v3;
  *a1[7] = 7;
  return 0;
}

//----- (080D1754) --------------------------------------------------------
void *__cdecl sub_80D1754(int a1, int a2, int a3)
{
  return malloc(a3 * a2);
}

//----- (080D176C) --------------------------------------------------------
void __cdecl sub_80D176C(int a1, void *ptr)
{
  free(ptr);
}

//----- (080D1780) --------------------------------------------------------
int __cdecl sub_80D1780(int a1, _DWORD *a2)
{
  if ( !a1 )
    return -102;
  *a2 = *(a1 + 20);
  return 0;
}

//----- (080D17B2) --------------------------------------------------------
int __cdecl sub_80D17B2(int a1, int a2)
{
  if ( !a1 )
    return -102;
  *(a1 + 20) = a2;
  *(a1 + 24) = sub_80CBD1E(a1, a1 + 40, a1 + 120, 0, 0, 0, 0, 0, 0) == 0;
  return 0;
}

//----- (080D1844) --------------------------------------------------------
int __cdecl sub_80D1844(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-14h]
  int v6; // [esp+8h] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  unsigned int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+10h] [ebp-4h]
  int v26; // [esp+10h] [ebp-4h]
  int v27; // [esp+10h] [ebp-4h]
  int v28; // [esp+10h] [ebp-4h]
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+10h] [ebp-4h]
  int v31; // [esp+10h] [ebp-4h]
  int v32; // [esp+10h] [ebp-4h]
  int v33; // [esp+10h] [ebp-4h]
  int v34; // [esp+10h] [ebp-4h]
  int v35; // [esp+10h] [ebp-4h]
  int v36; // [esp+10h] [ebp-4h]
  int v37; // [esp+10h] [ebp-4h]
  int v38; // [esp+10h] [ebp-4h]

  v23 = a1;
  v7 = HIWORD(a1);
  if ( !a2 )
    return 1;
  while ( a3 )
  {
    v4 = a3;
    if ( a3 > 0x15B0 )
      v4 = 5552;
    v6 = v4;
    a3 -= v4;
    while ( v6 > 15 )
    {
      v24 = *a2 + v23;
      v8 = v24 + v7;
      v25 = a2[1] + v24;
      v9 = v25 + v8;
      v26 = a2[2] + v25;
      v10 = v26 + v9;
      v27 = a2[3] + v26;
      v11 = v27 + v10;
      v28 = a2[4] + v27;
      v12 = v28 + v11;
      v29 = a2[5] + v28;
      v13 = v29 + v12;
      v30 = a2[6] + v29;
      v14 = v30 + v13;
      v31 = a2[7] + v30;
      v15 = v31 + v14;
      v32 = a2[8] + v31;
      v16 = v32 + v15;
      v33 = a2[9] + v32;
      v17 = v33 + v16;
      v34 = a2[10] + v33;
      v18 = v34 + v17;
      v35 = a2[11] + v34;
      v19 = v35 + v18;
      v36 = a2[12] + v35;
      v20 = v36 + v19;
      v37 = a2[13] + v36;
      v21 = v37 + v20;
      v38 = a2[14] + v37;
      v22 = v38 + v21;
      v23 = a2[15] + v38;
      v7 = v23 + v22;
      a2 += 16;
      v6 -= 16;
    }
    for ( ; v6; --v6 )
    {
      v23 += *a2++;
      v7 += v23;
    }
    v23 %= 0xFFF1u;
    v7 %= 0xFFF1u;
  }
  return v23 | (v7 << 16);
}

//----- (080D1A90) --------------------------------------------------------
int __cdecl sub_80D1A90(int a1, int *a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-54h]
  int v7; // [esp+18h] [ebp-50h]
  int v8; // [esp+1Ch] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10[4]; // [esp+20h] [ebp-48h] BYREF
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+40h] [ebp-28h]
  int v14; // [esp+44h] [ebp-24h]
  int v15; // [esp+48h] [ebp-20h]

  v10[0] = a3;
  v10[1] = a4;
  v10[3] = a1;
  v11 = *a2;
  if ( v11 != *a2 )
    return -5;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = sub_80D1D28(v10, a5, "1.1.4", 56);
  if ( v8 )
    return v8;
  v9 = sub_80D25AB(v10, 4);
  if ( v9 == 1 )
  {
    *a2 = v12;
    v7 = sub_80D2994(v10);
  }
  else
  {
    sub_80D2994(v10);
    v6 = v9;
    if ( !v9 )
      v6 = -5;
    v7 = v6;
  }
  return v7;
}

//----- (080D1D28) --------------------------------------------------------
int __cdecl sub_80D1D28(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  return sub_80D1D70(a1, a2, 8, 15, 8, 0, a3, a4);
}

//----- (080D1D70) --------------------------------------------------------
int __cdecl sub_80D1D70(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8)
{
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]

  v11 = 0;
  if ( !a7 || *a7 != *off_80F8900 || a8 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80DB9B6;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80DB9D0;
  if ( a2 == -1 )
    a2 = 6;
  if ( a4 < 0 )
  {
    v11 = 1;
    a4 = -a4;
  }
  if ( a5 <= 0 || a5 > 9 || a3 != 8 || a4 <= 8 || a4 > 15 || a2 < 0 || a2 > 9 || a6 < 0 || a6 > 2 )
    return -2;
  v12 = (a1[8])(a1[10], 1, 5816);
  if ( !v12 )
    return -4;
  a1[7] = v12;
  *v12 = a1;
  *(v12 + 24) = v11;
  *(v12 + 40) = a4;
  *(v12 + 36) = 1 << *(v12 + 40);
  *(v12 + 44) = *(v12 + 36) - 1;
  *(v12 + 72) = a5 + 7;
  *(v12 + 68) = 1 << *(v12 + 72);
  *(v12 + 76) = *(v12 + 68) - 1;
  *(v12 + 80) = (*(v12 + 72) + 2) / 3u;
  *(v12 + 48) = (a1[8])(a1[10], *(v12 + 36), 2);
  *(v12 + 56) = (a1[8])(a1[10], *(v12 + 36), 2);
  *(v12 + 60) = (a1[8])(a1[10], *(v12 + 68), 2);
  *(v12 + 5780) = 1 << (a5 + 6);
  v10 = (a1[8])(a1[10], *(v12 + 5780), 4);
  *(v12 + 8) = v10;
  *(v12 + 12) = 4 * *(v12 + 5780);
  if ( *(v12 + 48) && *(v12 + 56) && *(v12 + 60) && *(v12 + 8) )
  {
    *(v12 + 5788) = v10 + 2 * (*(v12 + 5780) >> 1);
    *(v12 + 5776) = *(v12 + 8) + 3 * *(v12 + 5780);
    *(v12 + 124) = a2;
    *(v12 + 128) = a6;
    *(v12 + 29) = 8;
    v9 = sub_80D226E(a1);
  }
  else
  {
    a1[6] = off_80F9AD8[0];
    sub_80D2994(a1);
    v9 = -4;
  }
  return v9;
}
// 80F8900: using guessed type char *off_80F8900;
// 80F9AD8: using guessed type char *off_80F9AD8[3];

//----- (080D226E) --------------------------------------------------------
int __cdecl sub_80D226E(_DWORD *a1)
{
  int v2; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !a1[7] || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v4 = a1[7];
  v4[5] = 0;
  v4[4] = v4[2];
  if ( v4[6] < 0 )
    v4[6] = 0;
  if ( v4[6] )
    v2 = 113;
  else
    v2 = 42;
  v4[1] = v2;
  a1[12] = 1;
  v4[8] = 0;
  sub_80D8811(v4);
  sub_80D2E60(v4);
  return 0;
}

//----- (080D24A4) --------------------------------------------------------
int __cdecl sub_80D24A4(int a1, __int16 a2)
{
  int result; // eax

  *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(a2);
  result = a2;
  *(*(a1 + 8) + (*(a1 + 20))++) = a2;
  return result;
}

//----- (080D24DD) --------------------------------------------------------
size_t __cdecl sub_80D24DD(int a1)
{
  size_t result; // eax
  size_t n; // [esp+14h] [ebp-4h]

  n = *(*(a1 + 28) + 20);
  result = n;
  if ( n > *(a1 + 16) )
  {
    result = *(a1 + 16);
    n = result;
  }
  if ( n )
  {
    memcpy(*(a1 + 12), *(*(a1 + 28) + 16), n);
    *(a1 + 12) += n;
    *(*(a1 + 28) + 16) += n;
    *(a1 + 20) += n;
    *(a1 + 16) -= n;
    *(*(a1 + 28) + 20) -= n;
    result = *(a1 + 28);
    if ( !*(result + 20) )
    {
      result = *(*(a1 + 28) + 8);
      *(*(a1 + 28) + 16) = result;
    }
  }
  return result;
}

//----- (080D25AB) --------------------------------------------------------
int __cdecl sub_80D25AB(int a1, int a2)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a1 || !*(a1 + 28) || a2 > 4 || a2 < 0 )
    return -2;
  v7 = *(a1 + 28);
  if ( !*(a1 + 12) || !*a1 && *(a1 + 4) || *(v7 + 4) == 666 && a2 != 4 )
  {
    *(a1 + 24) = off_80F9AD0[0];
    return -2;
  }
  if ( !*(a1 + 16) )
  {
    *(a1 + 24) = off_80F9ADC[0];
    return -5;
  }
  *v7 = a1;
  v8 = *(v7 + 32);
  *(v7 + 32) = a2;
  if ( *(v7 + 4) == 42 )
  {
    v4 = (*(v7 + 124) - 1) >> 1;
    if ( v4 > 3 )
      v4 = 3;
    v6 = (v4 << 6) | ((16 * (*(v7 + 40) - 8) + 8) << 8);
    if ( *(v7 + 100) )
      v6 |= 0x20u;
    *(v7 + 4) = 113;
    sub_80D24A4(v7, 31 * ((((v6 * &unk_8421085) >> 32) + ((v6 - ((v6 * &unk_8421085) >> 32)) >> 1)) >> 4) + 31);
    if ( *(v7 + 100) )
    {
      sub_80D24A4(v7, HIWORD(*(a1 + 48)));
      sub_80D24A4(v7, *(a1 + 48));
    }
    *(a1 + 48) = 1;
  }
  if ( *(v7 + 20) )
  {
    sub_80D24DD(a1);
    if ( !*(a1 + 16) )
    {
      *(v7 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(a1 + 4) && a2 <= v8 && a2 != 4 )
  {
    *(a1 + 24) = off_80F9ADC[0];
    return -5;
  }
  if ( *(v7 + 4) == 666 && *(a1 + 4) )
  {
    *(a1 + 24) = off_80F9ADC[0];
    return -5;
  }
  if ( !*(a1 + 4) && !*(v7 + 108) && (!a2 || *(v7 + 4) == 666) )
    goto LABEL_51;
  v5 = off_80EC188[3 * *(v7 + 124)](v7, a2);
  if ( v5 == 2 || v5 == 3 )
    *(v7 + 4) = 666;
  if ( v5 && v5 != 2 )
  {
    if ( v5 == 1 )
    {
      if ( a2 == 1 )
      {
        sub_80DA4A3(v7);
      }
      else
      {
        sub_80DA375(v7, 0, 0, 0);
        if ( a2 == 3 )
        {
          *(*(v7 + 60) + 2 * *(v7 + 68) - 2) = 0;
          memset(*(v7 + 60), 0, 2 * *(v7 + 68) - 2);
        }
      }
      sub_80D24DD(a1);
      if ( !*(a1 + 16) )
      {
        *(v7 + 32) = -1;
        return 0;
      }
    }
LABEL_51:
    if ( a2 != 4 )
      return 0;
    if ( *(v7 + 24) )
      return 1;
    sub_80D24A4(v7, HIWORD(*(a1 + 48)));
    sub_80D24A4(v7, *(a1 + 48));
    sub_80D24DD(a1);
    *(v7 + 24) = -1;
    return *(v7 + 20) == 0;
  }
  if ( !*(a1 + 16) )
    *(v7 + 32) = -1;
  return 0;
}
// 80F9AD0: using guessed type char *off_80F9AD0[5];
// 80F9ADC: using guessed type char *off_80F9ADC[2];

//----- (080D2994) --------------------------------------------------------
int __cdecl sub_80D2994(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !*(a1 + 28) )
    return -2;
  v4 = *(*(a1 + 28) + 4);
  if ( v4 != 42 && v4 != 113 && v4 != 666 )
    return -2;
  if ( *(*(a1 + 28) + 8) )
    (*(a1 + 36))(*(a1 + 40), *(*(a1 + 28) + 8));
  if ( *(*(a1 + 28) + 60) )
    (*(a1 + 36))(*(a1 + 40), *(*(a1 + 28) + 60));
  if ( *(*(a1 + 28) + 56) )
    (*(a1 + 36))(*(a1 + 40), *(*(a1 + 28) + 56));
  if ( *(*(a1 + 28) + 48) )
    (*(a1 + 36))(*(a1 + 40), *(*(a1 + 28) + 48));
  (*(a1 + 36))(*(a1 + 40), *(a1 + 28));
  *(a1 + 28) = 0;
  if ( v4 == 113 )
    v2 = -3;
  else
    v2 = 0;
  return v2;
}

//----- (080D2DAC) --------------------------------------------------------
unsigned int __cdecl sub_80D2DAC(int a1, void *dest, int a3)
{
  unsigned int n; // [esp+10h] [ebp-8h]

  n = *(a1 + 4);
  if ( n > a3 )
    n = a3;
  if ( !n )
    return 0;
  *(a1 + 4) -= n;
  if ( !*(*(a1 + 28) + 24) )
    *(a1 + 48) = sub_80D1844(*(a1 + 48), *a1, n);
  memcpy(dest, *a1, n);
  *a1 += n;
  *(a1 + 8) += n;
  return n;
}

//----- (080D2E60) --------------------------------------------------------
int __cdecl sub_80D2E60(int a1)
{
  int result; // eax

  *(a1 + 52) = 2 * *(a1 + 36);
  *(*(a1 + 60) + 2 * *(a1 + 68) - 2) = 0;
  memset(*(a1 + 60), 0, 2 * *(a1 + 68) - 2);
  *(a1 + 120) = word_80EC182[6 * *(a1 + 124)];
  *(a1 + 132) = word_80EC180[6 * *(a1 + 124)];
  *(a1 + 136) = word_80EC184[6 * *(a1 + 124)];
  *(a1 + 116) = word_80EC186[6 * *(a1 + 124)];
  *(a1 + 100) = 0;
  *(a1 + 84) = 0;
  *(a1 + 108) = 0;
  *(a1 + 112) = 2;
  *(a1 + 88) = 2;
  *(a1 + 96) = 0;
  result = a1;
  *(a1 + 64) = 0;
  return result;
}
// 80EC180: using guessed type __int16 word_80EC180[];
// 80EC182: using guessed type __int16 word_80EC182[];
// 80EC184: using guessed type __int16 word_80EC184[];
// 80EC186: using guessed type __int16 word_80EC186[];

//----- (080D2F6D) --------------------------------------------------------
int __cdecl sub_80D2F6D(_DWORD *a1, unsigned int a2)
{
  char v3; // [esp+2h] [ebp-32h]
  char v4; // [esp+3h] [ebp-31h]
  unsigned int v5; // [esp+4h] [ebp-30h]
  unsigned int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  _BYTE *v8; // [esp+10h] [ebp-24h]
  _BYTE *v9; // [esp+10h] [ebp-24h]
  _BYTE *v10; // [esp+10h] [ebp-24h]
  _BYTE *v11; // [esp+10h] [ebp-24h]
  _BYTE *v12; // [esp+10h] [ebp-24h]
  _BYTE *v13; // [esp+10h] [ebp-24h]
  _BYTE *v14; // [esp+10h] [ebp-24h]
  _BYTE *v15; // [esp+10h] [ebp-24h]
  _BYTE *v16; // [esp+10h] [ebp-24h]
  _BYTE *v17; // [esp+10h] [ebp-24h]
  _BYTE *v18; // [esp+14h] [ebp-20h]
  _BYTE *v19; // [esp+14h] [ebp-20h]
  int v20; // [esp+18h] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-18h]
  int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+28h] [ebp-Ch]
  int v24; // [esp+2Ch] [ebp-8h]
  unsigned int v25; // [esp+30h] [ebp-4h]

  v25 = a1[29];
  v18 = (a1[25] + a1[12]);
  v24 = a1[28];
  v23 = a1[34];
  if ( a1[25] <= (a1[9] - 262) )
    v6 = 0;
  else
    v6 = a1[25] - a1[9] + 262;
  v22 = a1[14];
  v21 = a1[11];
  v5 = a1[25] + a1[12] + 258;
  v4 = v18[v24 - 1];
  v3 = v18[v24];
  if ( a1[28] >= a1[33] )
    v25 >>= 2;
  if ( v23 > a1[27] )
    v23 = a1[27];
  do
  {
    v8 = (a2 + a1[12]);
    if ( v8[v24] == v3 && v8[v24 - 1] == v4 && *v8 == *v18 )
    {
      v9 = v8 + 1;
      if ( *v9 == v18[1] )
      {
        v19 = v18 + 2;
        v10 = v9 + 1;
        do
        {
          ++v19;
          v11 = v10 + 1;
          if ( *v19 != *v11 )
            break;
          ++v19;
          v12 = v11 + 1;
          if ( *v19 != *v12 )
            break;
          ++v19;
          v13 = v12 + 1;
          if ( *v19 != *v13 )
            break;
          ++v19;
          v14 = v13 + 1;
          if ( *v19 != *v14 )
            break;
          ++v19;
          v15 = v14 + 1;
          if ( *v19 != *v15 )
            break;
          ++v19;
          v16 = v15 + 1;
          if ( *v19 != *v16 )
            break;
          ++v19;
          v17 = v16 + 1;
          if ( *v19 != *v17 )
            break;
          ++v19;
          v10 = v17 + 1;
          if ( *v19 != *v10 )
            break;
        }
        while ( v19 < v5 );
        v7 = 258 - (v5 - v19);
        v18 = (v5 - 258);
        if ( v7 > v24 )
        {
          a1[26] = a2;
          v24 = v7;
          if ( v7 >= v23 )
            break;
          v4 = v18[v7 - 1];
          v3 = v18[v7];
        }
      }
    }
    a2 = *(v22 + 2 * (a2 & v21));
    if ( a2 <= v6 )
      break;
    --v25;
  }
  while ( v25 );
  if ( v24 > a1[27] )
    v20 = a1[27];
  else
    v20 = v24;
  return v20;
}

//----- (080D31F7) --------------------------------------------------------
int __cdecl sub_80D31F7(int a1)
{
  int result; // eax
  __int16 v2; // [esp+10h] [ebp-48h]
  __int16 v3; // [esp+20h] [ebp-38h]
  _WORD *v4; // [esp+3Ch] [ebp-1Ch]
  _WORD *v5; // [esp+3Ch] [ebp-1Ch]
  unsigned int v6; // [esp+40h] [ebp-18h]
  unsigned int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+44h] [ebp-14h]
  size_t v9; // [esp+44h] [ebp-14h]
  size_t n; // [esp+48h] [ebp-10h]
  int v11; // [esp+4Ch] [ebp-Ch]

  n = *(a1 + 36);
  do
  {
    v11 = *(a1 + 52) - *(a1 + 108) - *(a1 + 100);
    if ( v11 || *(a1 + 100) || *(a1 + 108) )
    {
      if ( v11 == -1 )
      {
        v11 = -2;
      }
      else if ( *(a1 + 100) >= n + *(a1 + 36) - 262 )
      {
        memcpy(*(a1 + 48), (*(a1 + 48) + n), n);
        *(a1 + 104) -= n;
        *(a1 + 100) -= n;
        *(a1 + 84) -= n;
        v8 = *(a1 + 68);
        v4 = (2 * v8 + *(a1 + 60));
        do
        {
          v6 = *--v4;
          if ( v6 < n )
            v3 = 0;
          else
            v3 = v6 - n;
          *v4 = v3;
          --v8;
        }
        while ( v8 );
        v9 = n;
        v5 = (2 * n + *(a1 + 56));
        do
        {
          v7 = *--v5;
          if ( v7 < n )
            v2 = 0;
          else
            v2 = v7 - n;
          *v5 = v2;
          --v9;
        }
        while ( v9 );
        v11 += n;
      }
    }
    else
    {
      v11 = n;
    }
    result = *a1;
    if ( !*(*a1 + 4) )
      break;
    *(a1 + 108) += sub_80D2DAC(*a1, (*(a1 + 108) + *(a1 + 100) + *(a1 + 48)), v11);
    if ( *(a1 + 108) > 2u )
    {
      *(a1 + 64) = *(*(a1 + 48) + *(a1 + 100));
      *(a1 + 64) = *(a1 + 76) & (*(*(a1 + 48) + *(a1 + 100) + 1) ^ (*(a1 + 64) << *(a1 + 80)));
    }
    result = a1;
    if ( *(a1 + 108) > 0x105u )
      break;
    result = *a1;
  }
  while ( *(*a1 + 4) );
  return result;
}

//----- (080D3448) --------------------------------------------------------
int __cdecl sub_80D3448(int *a1, int a2)
{
  int v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0xFFFF;
  if ( (a1[3] - 5) < 0xFFFF )
    v11 = a1[3] - 5;
  while ( 1 )
  {
    if ( a1[27] <= 1 )
    {
      sub_80D31F7(a1);
      if ( !a1[27] && !a2 )
        return 0;
      if ( !a1[27] )
        break;
    }
    a1[25] += a1[27];
    a1[27] = 0;
    v10 = a1[21] + v11;
    if ( !a1[25] || a1[25] >= v10 )
    {
      a1[27] = a1[25] - v10;
      a1[25] = v10;
      v3 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80DA911(a1, 0, v3, 0);
      else
        sub_80DA911(a1, (a1[21] + a1[12]), v3, 0);
      a1[21] = a1[25];
      sub_80D24DD(*a1);
      if ( !*(*a1 + 16) )
        return 0;
    }
    if ( a1[25] - a1[21] >= (a1[9] - 262) )
    {
      v4 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80DA911(a1, 0, v4, 0);
      else
        sub_80DA911(a1, (a1[21] + a1[12]), v4, 0);
      a1[21] = a1[25];
      sub_80D24DD(*a1);
      if ( !*(*a1 + 16) )
        return 0;
    }
  }
  v6 = a2 == 4;
  v5 = a1[25] - a1[21];
  if ( a1[21] < 0 )
    sub_80DA911(a1, 0, v5, v6);
  else
    sub_80DA911(a1, (a1[21] + a1[12]), v5, v6);
  a1[21] = a1[25];
  sub_80D24DD(*a1);
  if ( *(*a1 + 16) )
  {
    if ( a2 == 4 )
      v7 = 3;
    else
      v7 = 1;
    v9 = v7;
  }
  else
  {
    if ( a2 == 4 )
      v8 = 2;
    else
      v8 = 0;
    v9 = v8;
  }
  return v9;
}

//----- (080D43EC) --------------------------------------------------------
int __cdecl sub_80D43EC(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax

  if ( a3 )
    *a3 = *(a1 + 60);
  if ( *a1 == 4 || *a1 == 5 )
    (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
  if ( *a1 == 6 )
    sub_80D68DE(*(a1 + 4), a2);
  *a1 = 0;
  *(a1 + 28) = 0;
  *(a1 + 32) = 0;
  v3 = *(a1 + 40);
  *(a1 + 52) = v3;
  *(a1 + 48) = v3;
  result = a1;
  if ( *(a1 + 56) )
  {
    *(a1 + 60) = (*(a1 + 56))(0, 0, 0);
    result = *(a1 + 60);
    *(a2 + 48) = result;
  }
  return result;
}

//----- (080D44BC) --------------------------------------------------------
_DWORD *__cdecl sub_80D44BC(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (*(a1 + 32))(*(a1 + 40), 1, 64);
  if ( !v5 )
    return 0;
  v5[9] = (*(a1 + 32))(*(a1 + 40), 8, 1440);
  if ( v5[9] )
  {
    v5[10] = (*(a1 + 32))(*(a1 + 40), 1, a3);
    if ( v5[10] )
    {
      v5[11] = v5[10] + a3;
      v5[14] = a2;
      *v5 = 0;
      sub_80D43EC(v5, a1, 0);
      v4 = v5;
    }
    else
    {
      (*(a1 + 36))(*(a1 + 40), v5[9]);
      (*(a1 + 36))(*(a1 + 40), v5);
      v4 = 0;
    }
  }
  else
  {
    (*(a1 + 36))(*(a1 + 40), v5);
    v4 = 0;
  }
  return v4;
}

//----- (080D45FE) --------------------------------------------------------
int __cdecl sub_80D45FE(int a1, int a2, int a3)
{
  int v4; // [esp+28h] [ebp-80h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  unsigned int v6; // [esp+30h] [ebp-78h]
  unsigned int v7; // [esp+34h] [ebp-74h]
  int v8; // [esp+38h] [ebp-70h]
  int v9; // [esp+3Ch] [ebp-6Ch]
  int v10; // [esp+44h] [ebp-64h]
  int v11; // [esp+48h] [ebp-60h]
  int v12; // [esp+4Ch] [ebp-5Ch]
  int v13; // [esp+50h] [ebp-58h]
  size_t v14; // [esp+58h] [ebp-50h]
  int v15; // [esp+5Ch] [ebp-4Ch]
  int v17; // [esp+64h] [ebp-44h]
  unsigned int v18; // [esp+68h] [ebp-40h] BYREF
  unsigned int v19; // [esp+6Ch] [ebp-3Ch] BYREF
  int v20; // [esp+70h] [ebp-38h] BYREF
  int v21; // [esp+74h] [ebp-34h] BYREF
  int v22; // [esp+78h] [ebp-30h] BYREF
  int v23; // [esp+7Ch] [ebp-2Ch] BYREF
  int v24; // [esp+80h] [ebp-28h] BYREF
  int v25; // [esp+84h] [ebp-24h] BYREF
  size_t v26; // [esp+88h] [ebp-20h]
  void *dest; // [esp+8Ch] [ebp-1Ch]
  size_t v28; // [esp+90h] [ebp-18h]
  void *src; // [esp+94h] [ebp-14h]
  size_t v30; // [esp+98h] [ebp-10h]
  unsigned int v31; // [esp+9Ch] [ebp-Ch]
  size_t n; // [esp+A0h] [ebp-8h]
  int v33; // [esp+B8h] [ebp+10h]
  int v34; // [esp+B8h] [ebp+10h]

  src = *a2;
  v28 = *(a2 + 4);
  v31 = *(a1 + 32);
  v30 = *(a1 + 28);
  dest = *(a1 + 52);
  if ( dest >= *(a1 + 48) )
    v15 = *(a1 + 44) - dest;
  else
    v15 = *(a1 + 48) - dest - 1;
  v26 = v15;
  while ( 1 )
  {
    if ( *a1 > 9u )
    {
      *(a1 + 32) = v31;
      *(a1 + 28) = v30;
      *(a2 + 4) = v28;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80D8618(a1, a2, -2);
    }
    switch ( *a1 )
    {
      case 0:
        while ( v30 <= 2 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *src << v30;
          src = src + 1;
          v30 += 8;
        }
        n = v31 & 7;
        *(a1 + 24) = v31 & 1;
        v14 = n >> 1;
        if ( n >> 1 == 1 )
        {
          sub_80D85E5(&v25, &v24, &v23, &v22);
          *(a1 + 4) = sub_80D5B0C(v25, v24, v23, v22, a2);
          if ( !*(a1 + 4) )
            goto LABEL_119;
          v31 >>= 3;
          v30 -= 3;
          *a1 = 6;
          continue;
        }
        if ( !v14 )
        {
          v31 >>= 3;
          v30 -= 3;
          n = v30 & 7;
          v31 >>= n;
          v30 -= n;
          *a1 = 1;
          continue;
        }
        if ( v14 == 2 )
        {
          v31 >>= 3;
          v30 -= 3;
          *a1 = 3;
          continue;
        }
        if ( v14 != 3 )
          continue;
        v31 >>= 3;
        v30 -= 3;
        *a1 = 9;
        *(a2 + 24) = "invalid block type";
        *(a1 + 32) = v31;
        *(a1 + 28) = v30;
        *(a2 + 4) = v28;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80D8618(a1, a2, -3);
      case 1:
        while ( v30 <= 0x1F )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *src << v30;
          src = src + 1;
          v30 += 8;
        }
        if ( ~v31 >> 16 == v31 )
        {
          *(a1 + 4) = v31;
          v30 = 0;
          v31 = 0;
          if ( *(a1 + 4) )
          {
            v13 = 2;
          }
          else if ( *(a1 + 24) )
          {
            v13 = 7;
          }
          else
          {
            v13 = 0;
          }
          *a1 = v13;
          continue;
        }
        *a1 = 9;
        *(a2 + 24) = "invalid stored block lengths";
        *(a1 + 32) = v31;
        *(a1 + 28) = v30;
        *(a2 + 4) = v28;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80D8618(a1, a2, -3);
      case 2:
        if ( !v28 )
          goto LABEL_53;
        if ( !v26 )
        {
          if ( dest == *(a1 + 44) && *(a1 + 48) != *(a1 + 40) )
          {
            dest = *(a1 + 40);
            if ( dest >= *(a1 + 48) )
              v12 = *(a1 + 44) - dest;
            else
              v12 = *(a1 + 48) - dest - 1;
            v26 = v12;
          }
          if ( !v26 )
          {
            *(a1 + 52) = dest;
            a3 = sub_80D8618(a1, a2, a3);
            dest = *(a1 + 52);
            if ( dest >= *(a1 + 48) )
              v11 = *(a1 + 44) - dest;
            else
              v11 = *(a1 + 48) - dest - 1;
            v26 = v11;
            if ( dest == *(a1 + 44) && *(a1 + 48) != *(a1 + 40) )
            {
              dest = *(a1 + 40);
              if ( dest >= *(a1 + 48) )
                v10 = *(a1 + 44) - dest;
              else
                v10 = *(a1 + 48) - dest - 1;
              v26 = v10;
            }
            if ( !v26 )
              goto LABEL_53;
          }
        }
        a3 = 0;
        n = *(a1 + 4);
        if ( n > v28 )
          n = v28;
        if ( n > v26 )
          n = v26;
        memcpy(dest, src, n);
        src = src + n;
        v28 -= n;
        dest = dest + n;
        v26 -= n;
        *(a1 + 4) -= n;
        if ( !*(a1 + 4) )
        {
          if ( *(a1 + 24) )
            v9 = 7;
          else
            v9 = 0;
          *a1 = v9;
        }
        continue;
      case 3:
        break;
      case 4:
        goto LABEL_72;
      case 5:
        goto LABEL_85;
      case 6:
        goto LABEL_121;
      case 7:
        goto LABEL_129;
      case 8:
        goto LABEL_135;
      case 9:
        *(a1 + 32) = v31;
        *(a1 + 28) = v30;
        *(a2 + 4) = v28;
        *(a2 + 8) += src - *a2;
        *a2 = src;
        *(a1 + 52) = dest;
        return sub_80D8618(a1, a2, -3);
    }
    while ( v30 <= 0xD )
    {
      if ( !v28 )
        goto LABEL_53;
      a3 = 0;
      --v28;
      v31 |= *src << v30;
      src = src + 1;
      v30 += 8;
    }
    n = v31 & 0x3FFF;
    *(a1 + 4) = n;
    if ( (n & 0x1F) > 0x1D || ((n >> 5) & 0x1F) > 0x1D )
    {
      *a1 = 9;
      *(a2 + 24) = "too many length or distance symbols";
      *(a1 + 32) = v31;
      *(a1 + 28) = v30;
      *(a2 + 4) = v28;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80D8618(a1, a2, -3);
    }
    n = ((n >> 5) & 0x1F) + (n & 0x1F) + 258;
    *(a1 + 12) = (*(a2 + 32))(*(a2 + 40), n, 4);
    if ( !*(a1 + 12) )
      goto LABEL_119;
    v31 >>= 14;
    v30 -= 14;
    *(a1 + 8) = 0;
    *a1 = 4;
LABEL_72:
    while ( *(a1 + 8) < ((*(a1 + 4) >> 10) + 4) )
    {
      while ( v30 <= 2 )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *src << v30;
        src = src + 1;
        v30 += 8;
      }
      *(*(a1 + 12) + 4 * dword_80EC200[(*(a1 + 8))++]) = v31 & 7;
      v31 >>= 3;
      v30 -= 3;
    }
    while ( *(a1 + 8) <= 0x12u )
      *(*(a1 + 12) + 4 * dword_80EC200[(*(a1 + 8))++]) = 0;
    *(a1 + 16) = 7;
    n = sub_80D8319(*(a1 + 12), (a1 + 16), (a1 + 20), *(a1 + 36), a2);
    if ( n )
    {
      a3 = n;
      if ( n == -3 )
      {
        (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
        *a1 = 9;
      }
LABEL_53:
      *(a1 + 32) = v31;
      *(a1 + 28) = v30;
      *(a2 + 4) = v28;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80D8618(a1, a2, a3);
    }
    *(a1 + 8) = 0;
    *a1 = 5;
LABEL_85:
    while ( 1 )
    {
      n = *(a1 + 4);
      if ( *(a1 + 8) >= ((n >> 5) & 0x1F) + (n & 0x1F) + 258 )
        break;
      n = *(a1 + 16);
      while ( v30 < n )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *src << v30;
        src = src + 1;
        v30 += 8;
      }
      v21 = *(a1 + 20) + 8 * (v31 & dword_80F9A40[n]);
      n = *(v21 + 1);
      v18 = *(v21 + 4);
      if ( v18 > 0xF )
      {
        if ( v18 == 18 )
          v8 = 7;
        else
          v8 = v18 - 14;
        v20 = v8;
        if ( v18 == 18 )
          v7 = 11;
        else
          v7 = 3;
        v19 = v7;
        while ( v30 < n + v20 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *src << v30;
          src = src + 1;
          v30 += 8;
        }
        v31 >>= n;
        v30 -= n;
        v19 += dword_80F9A40[v20] & v31;
        v31 >>= v20;
        v30 -= v20;
        v20 = *(a1 + 8);
        n = *(a1 + 4);
        if ( v19 + v20 > ((n >> 5) & 0x1F) + (n & 0x1F) + 258 || v18 == 16 && !v20 )
        {
          (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
          *a1 = 9;
          *(a2 + 24) = "invalid bit length repeat";
          *(a1 + 32) = v31;
          *(a1 + 28) = v30;
          *(a2 + 4) = v28;
          *(a2 + 8) += src - *a2;
          *a2 = src;
          *(a1 + 52) = dest;
          return sub_80D8618(a1, a2, -3);
        }
        if ( v18 == 16 )
          v6 = *(*(a1 + 12) + 4 * v20 - 4);
        else
          v6 = 0;
        v18 = v6;
        do
        {
          *(*(a1 + 12) + 4 * v20++) = v18;
          --v19;
        }
        while ( v19 );
        *(a1 + 8) = v20;
      }
      else
      {
        v31 >>= n;
        v30 -= n;
        *(*(a1 + 12) + 4 * (*(a1 + 8))++) = v18;
      }
    }
    *(a1 + 20) = 0;
    v18 = 9;
    v19 = 6;
    n = *(a1 + 4);
    n = sub_80D8402((n & 0x1F) + 257, ((n >> 5) & 0x1F) + 1, *(a1 + 12), &v18, &v19, &v20, &v21, *(a1 + 36), a2);
    if ( n )
    {
      if ( n == -3 )
      {
        (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
        *a1 = 9;
      }
      v33 = n;
      *(a1 + 32) = v31;
      *(a1 + 28) = v30;
      *(a2 + 4) = v28;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80D8618(a1, a2, v33);
    }
    v17 = sub_80D5B0C(v18, v19, v20, v21, a2);
    if ( !v17 )
    {
LABEL_119:
      *(a1 + 32) = v31;
      *(a1 + 28) = v30;
      *(a2 + 4) = v28;
      *(a2 + 8) += src - *a2;
      *a2 = src;
      *(a1 + 52) = dest;
      return sub_80D8618(a1, a2, -4);
    }
    *(a1 + 4) = v17;
    (*(a2 + 36))(*(a2 + 40), *(a1 + 12));
    *a1 = 6;
LABEL_121:
    *(a1 + 32) = v31;
    *(a1 + 28) = v30;
    *(a2 + 4) = v28;
    *(a2 + 8) += src - *a2;
    *a2 = src;
    *(a1 + 52) = dest;
    v34 = sub_80D5B71(a1, a2, a3);
    if ( v34 != 1 )
      return sub_80D8618(a1, a2, v34);
    a3 = 0;
    sub_80D68DE(*(a1 + 4), a2);
    src = *a2;
    v28 = *(a2 + 4);
    v31 = *(a1 + 32);
    v30 = *(a1 + 28);
    dest = *(a1 + 52);
    v5 = dest >= *(a1 + 48) ? *(a1 + 44) - dest : *(a1 + 48) - dest - 1;
    v26 = v5;
    if ( *(a1 + 24) )
      break;
    *a1 = 0;
  }
  *a1 = 7;
LABEL_129:
  *(a1 + 52) = dest;
  a3 = sub_80D8618(a1, a2, a3);
  dest = *(a1 + 52);
  if ( dest >= *(a1 + 48) )
    v4 = *(a1 + 44) - dest;
  else
    v4 = *(a1 + 48) - dest - 1;
  v26 = v4;
  if ( *(a1 + 48) != *(a1 + 52) )
    goto LABEL_53;
  *a1 = 8;
LABEL_135:
  *(a1 + 32) = v31;
  *(a1 + 28) = v30;
  *(a2 + 4) = v28;
  *(a2 + 8) += src - *a2;
  *a2 = src;
  *(a1 + 52) = dest;
  return sub_80D8618(a1, a2, 1);
}

//----- (080D5A45) --------------------------------------------------------
int __cdecl sub_80D5A45(int a1, int a2)
{
  sub_80D43EC(a1, a2, 0);
  (*(a2 + 36))(*(a2 + 40), *(a1 + 40));
  (*(a2 + 36))(*(a2 + 40), *(a1 + 36));
  (*(a2 + 36))(*(a2 + 40), a1);
  return 0;
}

//----- (080D5ABA) --------------------------------------------------------
int __cdecl sub_80D5ABA(int a1, void *src, size_t n)
{
  int result; // eax

  memcpy(*(a1 + 40), src, n);
  *(a1 + 52) = *(a1 + 40) + n;
  result = *(a1 + 52);
  *(a1 + 48) = result;
  return result;
}

//----- (080D5AFB) --------------------------------------------------------
_BOOL4 __cdecl sub_80D5AFB(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (080D5B0C) --------------------------------------------------------
int __cdecl sub_80D5B0C(char a1, char a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = (*(a5 + 32))(*(a5 + 40), 1, 28);
  if ( v6 )
  {
    *v6 = 0;
    *(v6 + 16) = a1;
    *(v6 + 17) = a2;
    *(v6 + 20) = a3;
    *(v6 + 24) = a4;
  }
  return v6;
}

//----- (080D5B71) --------------------------------------------------------
int __cdecl sub_80D5B71(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+2Ch] [ebp-5Ch]
  int v5; // [esp+30h] [ebp-58h]
  int v6; // [esp+34h] [ebp-54h]
  int v7; // [esp+38h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-4Ch]
  int v9; // [esp+40h] [ebp-48h]
  int v10; // [esp+44h] [ebp-44h]
  int v11; // [esp+4Ch] [ebp-3Ch]
  int v12; // [esp+50h] [ebp-38h]
  int v14; // [esp+58h] [ebp-30h]
  _BYTE *i; // [esp+5Ch] [ebp-2Ch]
  unsigned int v16; // [esp+60h] [ebp-28h]
  _BYTE *v17; // [esp+64h] [ebp-24h]
  unsigned int v18; // [esp+68h] [ebp-20h]
  unsigned __int8 *v19; // [esp+6Ch] [ebp-1Ch]
  unsigned int v20; // [esp+70h] [ebp-18h]
  unsigned int v21; // [esp+74h] [ebp-14h]
  int v22; // [esp+78h] [ebp-10h]
  int v23; // [esp+78h] [ebp-10h]
  unsigned __int8 *v24; // [esp+7Ch] [ebp-Ch]
  unsigned __int8 *v25; // [esp+7Ch] [ebp-Ch]
  unsigned int v26; // [esp+80h] [ebp-8h]
  unsigned int v27; // [esp+80h] [ebp-8h]
  unsigned int v28; // [esp+80h] [ebp-8h]
  unsigned int v29; // [esp+80h] [ebp-8h]
  int v30; // [esp+98h] [ebp+10h]

  v14 = a1[1];
  v19 = *a2;
  v18 = a2[1];
  v21 = a1[8];
  v20 = a1[7];
  v17 = a1[13];
  if ( v17 >= a1[12] )
    v12 = a1[11] - v17;
  else
    v12 = a1[12] - v17 - 1;
  v16 = v12;
  while ( 2 )
  {
    if ( *v14 > 9u )
    {
      a1[8] = v21;
      a1[7] = v20;
      a2[1] = v18;
      a2[2] += &v19[-*a2];
      *a2 = v19;
      a1[13] = v17;
      return sub_80D8618(a1, a2, -2);
    }
    switch ( *v14 )
    {
      case 0:
        if ( v16 <= 0x101 || v18 <= 9 )
          goto LABEL_17;
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        a3 = sub_80D6900(*(v14 + 16), *(v14 + 17), *(v14 + 20), *(v14 + 24), a1, a2);
        v19 = *a2;
        v18 = a2[1];
        v21 = a1[8];
        v20 = a1[7];
        v17 = a1[13];
        v11 = v17 >= a1[12] ? a1[11] - v17 : a1[12] - v17 - 1;
        v16 = v11;
        if ( !a3 )
        {
LABEL_17:
          *(v14 + 12) = *(v14 + 16);
          *(v14 + 8) = *(v14 + 20);
          *v14 = 1;
          goto LABEL_18;
        }
        if ( a3 == 1 )
          v10 = 7;
        else
          v10 = 9;
        *v14 = v10;
        continue;
      case 1:
LABEL_18:
        v26 = *(v14 + 12);
        while ( 2 )
        {
          if ( v20 < v26 )
          {
            if ( v18 )
            {
              a3 = 0;
              --v18;
              v21 |= *v19++ << v20;
              v20 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        v24 = (*(v14 + 8) + 8 * (v21 & dword_80F9A40[v26]));
        v21 >>= v24[1];
        v20 -= v24[1];
        v22 = *v24;
        if ( *v24 )
        {
          if ( (v22 & 0x10) != 0 )
          {
            *(v14 + 8) = v22 & 0xF;
            *(v14 + 4) = *(v24 + 1);
            *v14 = 2;
          }
          else if ( (v22 & 0x40) != 0 )
          {
            if ( (v22 & 0x20) == 0 )
            {
              *v14 = 9;
              a2[6] = "invalid literal/length code";
              a1[8] = v21;
              a1[7] = v20;
              a2[1] = v18;
              a2[2] += &v19[-*a2];
              *a2 = v19;
              a1[13] = v17;
              return sub_80D8618(a1, a2, -3);
            }
            *v14 = 7;
          }
          else
          {
            *(v14 + 12) = v22;
            *(v14 + 8) = &v24[8 * *(v24 + 1)];
          }
        }
        else
        {
          *(v14 + 8) = *(v24 + 1);
          *v14 = 6;
        }
        continue;
      case 2:
        v27 = *(v14 + 8);
        while ( 2 )
        {
          if ( v20 < v27 )
          {
            if ( v18 )
            {
              a3 = 0;
              --v18;
              v21 |= *v19++ << v20;
              v20 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        *(v14 + 4) += v21 & dword_80F9A40[v27];
        v21 >>= v27;
        v20 -= v27;
        *(v14 + 12) = *(v14 + 17);
        *(v14 + 8) = *(v14 + 24);
        *v14 = 3;
LABEL_38:
        v28 = *(v14 + 12);
        while ( v20 < v28 )
        {
          if ( !v18 )
            goto LABEL_52;
          a3 = 0;
          --v18;
          v21 |= *v19++ << v20;
          v20 += 8;
        }
        v25 = (*(v14 + 8) + 8 * (v21 & dword_80F9A40[v28]));
        v21 >>= v25[1];
        v20 -= v25[1];
        v23 = *v25;
        if ( (v23 & 0x10) != 0 )
        {
          *(v14 + 8) = v23 & 0xF;
          *(v14 + 12) = *(v25 + 1);
          *v14 = 4;
        }
        else
        {
          if ( (v23 & 0x40) != 0 )
          {
            *v14 = 9;
            a2[6] = "invalid distance code";
            a1[8] = v21;
            a1[7] = v20;
            a2[1] = v18;
            a2[2] += &v19[-*a2];
            *a2 = v19;
            a1[13] = v17;
            return sub_80D8618(a1, a2, -3);
          }
          *(v14 + 12) = v23;
          *(v14 + 8) = &v25[8 * *(v25 + 1)];
        }
        continue;
      case 3:
        goto LABEL_38;
      case 4:
        v29 = *(v14 + 8);
LABEL_49:
        if ( v20 >= v29 )
        {
          *(v14 + 12) += v21 & dword_80F9A40[v29];
          v21 >>= v29;
          v20 -= v29;
          *v14 = 5;
LABEL_54:
          for ( i = &v17[-*(v14 + 12)]; i < a1[10]; i += a1[11] - a1[10] )
            ;
          while ( *(v14 + 4) )
          {
            if ( !v16 )
            {
              if ( v17 == a1[11] && a1[12] != a1[10] )
              {
                v17 = a1[10];
                if ( v17 >= a1[12] )
                  v9 = a1[11] - v17;
                else
                  v9 = a1[12] - v17 - 1;
                v16 = v9;
              }
              if ( !v16 )
              {
                a1[13] = v17;
                v30 = sub_80D8618(a1, a2, a3);
                v17 = a1[13];
                if ( v17 >= a1[12] )
                  v8 = a1[11] - v17;
                else
                  v8 = a1[12] - v17 - 1;
                v16 = v8;
                if ( v17 == a1[11] && a1[12] != a1[10] )
                {
                  v17 = a1[10];
                  if ( v17 >= a1[12] )
                    v7 = a1[11] - v17;
                  else
                    v7 = a1[12] - v17 - 1;
                  v16 = v7;
                }
                if ( !v16 )
                {
LABEL_99:
                  a1[8] = v21;
                  a1[7] = v20;
                  a2[1] = v18;
                  a2[2] += &v19[-*a2];
                  *a2 = v19;
                  a1[13] = v17;
                  return sub_80D8618(a1, a2, v30);
                }
              }
            }
            a3 = 0;
            *v17++ = *i++;
            --v16;
            if ( i == a1[11] )
              i = a1[10];
            --*(v14 + 4);
          }
          *v14 = 0;
          continue;
        }
        if ( v18 )
        {
          a3 = 0;
          --v18;
          v21 |= *v19++ << v20;
          v20 += 8;
          goto LABEL_49;
        }
LABEL_52:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = 0;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80D8618(a1, a2, a3);
      case 5:
        goto LABEL_54;
      case 6:
        if ( !v16 )
        {
          if ( v17 == a1[11] && a1[12] != a1[10] )
          {
            v17 = a1[10];
            if ( v17 >= a1[12] )
              v6 = a1[11] - v17;
            else
              v6 = a1[12] - v17 - 1;
            v16 = v6;
          }
          if ( !v16 )
          {
            a1[13] = v17;
            v30 = sub_80D8618(a1, a2, a3);
            v17 = a1[13];
            if ( v17 >= a1[12] )
              v5 = a1[11] - v17;
            else
              v5 = a1[12] - v17 - 1;
            v16 = v5;
            if ( v17 == a1[11] && a1[12] != a1[10] )
            {
              v17 = a1[10];
              if ( v17 >= a1[12] )
                v4 = a1[11] - v17;
              else
                v4 = a1[12] - v17 - 1;
              v16 = v4;
            }
            if ( !v16 )
              goto LABEL_99;
          }
        }
        a3 = 0;
        *v17++ = *(v14 + 8);
        --v16;
        *v14 = 0;
        continue;
      case 7:
        if ( v20 > 7 )
        {
          v20 -= 8;
          ++v18;
          --v19;
        }
        a1[13] = v17;
        v30 = sub_80D8618(a1, a2, a3);
        v17 = a1[13];
        if ( a1[12] != v17 )
          goto LABEL_99;
        *v14 = 8;
LABEL_105:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80D8618(a1, a2, 1);
      case 8:
        goto LABEL_105;
      case 9:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80D8618(a1, a2, -3);
    }
  }
}

//----- (080D68DE) --------------------------------------------------------
int __cdecl sub_80D68DE(int a1, int a2)
{
  return (*(a2 + 36))(*(a2 + 40), a1);
}

//----- (080D6900) --------------------------------------------------------
int __cdecl sub_80D6900(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  unsigned int v7; // [esp+0h] [ebp-60h]
  unsigned int v8; // [esp+8h] [ebp-58h]
  unsigned int v9; // [esp+10h] [ebp-50h]
  unsigned int v10; // [esp+18h] [ebp-48h]
  int v11; // [esp+20h] [ebp-40h]
  int v12; // [esp+24h] [ebp-3Ch]
  _BYTE *v13; // [esp+28h] [ebp-38h]
  _BYTE *v14; // [esp+28h] [ebp-38h]
  _BYTE *v15; // [esp+28h] [ebp-38h]
  _BYTE *v16; // [esp+28h] [ebp-38h]
  _BYTE *v17; // [esp+28h] [ebp-38h]
  _BYTE *v18; // [esp+28h] [ebp-38h]
  int v19; // [esp+2Ch] [ebp-34h]
  unsigned int v20; // [esp+30h] [ebp-30h]
  unsigned int v21; // [esp+30h] [ebp-30h]
  unsigned int v22; // [esp+30h] [ebp-30h]
  unsigned int v23; // [esp+30h] [ebp-30h]
  int v24; // [esp+34h] [ebp-2Ch]
  int v25; // [esp+38h] [ebp-28h]
  unsigned int v26; // [esp+3Ch] [ebp-24h]
  _BYTE *v27; // [esp+40h] [ebp-20h]
  _BYTE *v28; // [esp+40h] [ebp-20h]
  _BYTE *v29; // [esp+40h] [ebp-20h]
  unsigned int v30; // [esp+44h] [ebp-1Ch]
  unsigned __int8 *v31; // [esp+48h] [ebp-18h]
  unsigned __int8 *v32; // [esp+48h] [ebp-18h]
  unsigned __int8 *v33; // [esp+48h] [ebp-18h]
  unsigned __int8 *v34; // [esp+48h] [ebp-18h]
  unsigned __int8 *v35; // [esp+48h] [ebp-18h]
  unsigned int v36; // [esp+4Ch] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-14h]
  unsigned int v38; // [esp+50h] [ebp-10h]
  unsigned int v39; // [esp+50h] [ebp-10h]
  int v40; // [esp+54h] [ebp-Ch]
  int v41; // [esp+54h] [ebp-Ch]
  int j; // [esp+54h] [ebp-Ch]
  unsigned int v43; // [esp+54h] [ebp-Ch]
  unsigned int v44; // [esp+54h] [ebp-Ch]
  unsigned __int8 *v45; // [esp+58h] [ebp-8h]
  unsigned __int8 *v46; // [esp+58h] [ebp-8h]

  v31 = *a6;
  v30 = a6[1];
  v38 = a5[8];
  v36 = a5[7];
  v27 = a5[13];
  if ( v27 >= a5[12] )
    v11 = a5[11] - v27;
  else
    v11 = a5[12] - v27 - 1;
  v26 = v11;
  v25 = dword_80F9A40[a1];
  v24 = dword_80F9A40[a2];
  while ( 1 )
  {
    while ( v36 <= 0x13 )
    {
      --v30;
      v38 |= *v31++ << v36;
      v36 += 8;
    }
    v45 = (a3 + 8 * (v38 & v25));
    v40 = *v45;
    if ( *v45 )
      break;
    v38 >>= v45[1];
    v36 -= v45[1];
    *v27++ = v45[4];
    --v26;
LABEL_47:
    if ( v26 <= 0x101 || v30 <= 9 )
    {
      v7 = a6[1] - v30;
      if ( v7 > v36 >> 3 )
        v7 = v36 >> 3;
      v35 = &v31[-v7];
      a5[8] = v38;
      a5[7] = v36 - 8 * v7;
      a6[1] = v7 + v30;
      a6[2] += &v35[-*a6];
      *a6 = v35;
      a5[13] = v27;
      return 0;
    }
  }
  while ( 1 )
  {
    v38 >>= v45[1];
    v36 -= v45[1];
    if ( (v40 & 0x10) != 0 )
      break;
    if ( (v40 & 0x40) != 0 )
    {
      if ( (v40 & 0x20) != 0 )
      {
        v9 = a6[1] - v30;
        if ( v9 > v36 >> 3 )
          v9 = v36 >> 3;
        v33 = &v31[-v9];
        a5[8] = v38;
        a5[7] = v36 - 8 * v9;
        a6[1] = v9 + v30;
        a6[2] += &v33[-*a6];
        *a6 = v33;
        a5[13] = v27;
        v12 = 1;
      }
      else
      {
        a6[6] = "invalid literal/length code";
        v8 = a6[1] - v30;
        if ( v8 > v36 >> 3 )
          v8 = v36 >> 3;
        v34 = &v31[-v8];
        a5[8] = v38;
        a5[7] = v36 - 8 * v8;
        a6[1] = v8 + v30;
        a6[2] += &v34[-*a6];
        *a6 = v34;
        a5[13] = v27;
        v12 = -3;
      }
      return v12;
    }
    v45 += 8 * (v38 & dword_80F9A40[v40]) + 8 * *(v45 + 1);
    v40 = *v45;
    if ( !*v45 )
    {
      v38 >>= v45[1];
      v36 -= v45[1];
      *v27++ = v45[4];
      --v26;
      goto LABEL_47;
    }
  }
  v41 = v40 & 0xF;
  v20 = *(v45 + 1) + (v38 & dword_80F9A40[v41]);
  v39 = v38 >> v41;
  for ( i = v36 - v41; i <= 0xE; i += 8 )
  {
    --v30;
    v39 |= *v31++ << i;
  }
  v46 = (a4 + 8 * (v39 & v24));
  for ( j = *v46; ; j = *v46 )
  {
    v39 >>= v46[1];
    i -= v46[1];
    if ( (j & 0x10) != 0 )
    {
      v43 = j & 0xF;
      while ( i < v43 )
      {
        --v30;
        v39 |= *v31++ << i;
        i += 8;
      }
      v19 = *(v46 + 1) + (v39 & dword_80F9A40[v43]);
      v38 = v39 >> v43;
      v36 = i - v43;
      v26 -= v20;
      v13 = &v27[-v19];
      if ( &v27[-v19] >= a5[10] )
      {
        *v27 = *v13;
        v17 = v13 + 1;
        v29 = v27 + 1;
        *v29 = *v17;
        v18 = v17 + 1;
        v27 = v29 + 1;
        v23 = v20 - 2;
        do
        {
          *v27++ = *v18++;
          --v23;
        }
        while ( v23 );
      }
      else
      {
        do
          v13 += a5[11] - a5[10];
        while ( v13 < a5[10] );
        v44 = a5[11] - v13;
        if ( v20 <= v44 )
        {
          *v27 = *v13;
          v15 = v13 + 1;
          v28 = v27 + 1;
          *v28 = *v15;
          v16 = v15 + 1;
          v27 = v28 + 1;
          v22 = v20 - 2;
          do
          {
            *v27++ = *v16++;
            --v22;
          }
          while ( v22 );
        }
        else
        {
          v21 = v20 - v44;
          do
          {
            *v27++ = *v13++;
            --v44;
          }
          while ( v44 );
          v14 = a5[10];
          do
          {
            *v27++ = *v14++;
            --v21;
          }
          while ( v21 );
        }
      }
      goto LABEL_47;
    }
    if ( (j & 0x40) != 0 )
      break;
    v46 += 8 * (v39 & dword_80F9A40[j]) + 8 * *(v46 + 1);
  }
  a6[6] = "invalid distance code";
  v10 = a6[1] - v30;
  if ( v10 > i >> 3 )
    v10 = i >> 3;
  v32 = &v31[-v10];
  a5[8] = v39;
  a5[7] = i - 8 * v10;
  a6[1] = v10 + v30;
  a6[2] += &v32[-*a6];
  *a6 = v32;
  a5[13] = v27;
  return -3;
}

//----- (080D7000) --------------------------------------------------------
int __cdecl sub_80D7000(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  if ( !a1 || !a1[7] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( *(a1[7] + 12) )
    v2 = 7;
  else
    v2 = 0;
  *a1[7] = v2;
  sub_80D43EC(*(a1[7] + 20), a1, 0);
  return 0;
}

//----- (080D7095) --------------------------------------------------------
int __cdecl sub_80D7095(_DWORD *a1)
{
  if ( !a1 || !a1[7] || !a1[9] )
    return -2;
  if ( *(a1[7] + 20) )
    sub_80D5A45(*(a1[7] + 20), a1);
  (a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (080D7111) --------------------------------------------------------
int __cdecl sub_80D7111(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // eax
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80DB9B6;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80DB9D0;
  a1[7] = (a1[8])(a1[10], 1, 24);
  if ( !a1[7] )
    return -4;
  *(a1[7] + 20) = 0;
  *(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    a2 = -a2;
    *(a1[7] + 12) = 1;
  }
  if ( a2 > 7 && a2 <= 15 )
  {
    *(a1[7] + 16) = a2;
    v7 = a1[7];
    v6 = 1 << a2;
    if ( *(v7 + 12) )
      v4 = sub_80D44BC(a1, 0, v6);
    else
      v4 = sub_80D44BC(a1, sub_80D1844, v6);
    *(v7 + 20) = v4;
    if ( *(v7 + 20) )
    {
      sub_80D7000(a1);
      v8 = 0;
    }
    else
    {
      sub_80D7095(a1);
      v8 = -4;
    }
  }
  else
  {
    sub_80D7095(a1);
    v8 = -2;
  }
  return v8;
}

//----- (080D72A8) --------------------------------------------------------
int __cdecl sub_80D72A8(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_80D7111(a1, 15, a2, a3);
}

//----- (080D72D1) --------------------------------------------------------
int __cdecl sub_80D72D1(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int v3; // eax
  unsigned int v4; // ebx
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // ebx
  int v14; // [esp+14h] [ebp-14h]
  int v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  int v17; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  if ( a2 == 4 )
    v14 = -5;
  else
    v14 = 0;
  v17 = -5;
  while ( 2 )
  {
    switch ( *a1[7] )
    {
      case 0:
        if ( a1[1] )
        {
          v17 = v14;
          v2 = a1[7];
          --a1[1];
          ++a1[2];
          *(v2 + 1) = **a1;
          v3 = *(v2 + 1) & 0xF;
          ++*a1;
          if ( v3 != 8 )
          {
            *a1[7] = 13;
            a1[6] = "unknown compression method";
            *(a1[7] + 1) = 5;
            continue;
          }
          if ( ((*(a1[7] + 1) >> 4) + 8) > *(a1[7] + 4) )
          {
            *a1[7] = 13;
            a1[6] = "invalid window size";
            *(a1[7] + 1) = 5;
            continue;
          }
          *a1[7] = 1;
          goto LABEL_17;
        }
        v15 = v17;
        break;
      case 1:
LABEL_17:
        if ( a1[1] )
        {
          v17 = v14;
          --a1[1];
          ++a1[2];
          v16 = *(*a1)++;
          v4 = v16 + (*(a1[7] + 1) << 8);
          if ( v4 != 31 * ((((v4 * &unk_8421085) >> 32) + ((v4 - ((v4 * &unk_8421085) >> 32)) >> 1)) >> 4) )
          {
            *a1[7] = 13;
            a1[6] = "incorrect header check";
            *(a1[7] + 1) = 5;
            continue;
          }
          if ( (v16 & 0x20) == 0 )
          {
            *a1[7] = 7;
            continue;
          }
          *a1[7] = 2;
          goto LABEL_24;
        }
        v15 = v17;
        break;
      case 2:
LABEL_24:
        if ( a1[1] )
        {
          v17 = v14;
          v5 = a1[7];
          --a1[1];
          ++a1[2];
          *(v5 + 2) = *(*a1)++ << 24;
          *a1[7] = 3;
          goto LABEL_27;
        }
        v15 = v17;
        break;
      case 3:
LABEL_27:
        if ( a1[1] )
        {
          v17 = v14;
          v6 = a1[7];
          --a1[1];
          ++a1[2];
          *(v6 + 2) = *(a1[7] + 2) + (*(*a1)++ << 16);
          *a1[7] = 4;
          goto LABEL_30;
        }
        v15 = v17;
        break;
      case 4:
LABEL_30:
        if ( a1[1] )
        {
          v17 = v14;
          v7 = a1[7];
          --a1[1];
          ++a1[2];
          *(v7 + 2) = *(a1[7] + 2) + (*(*a1)++ << 8);
          *a1[7] = 5;
          goto LABEL_33;
        }
        v15 = v17;
        break;
      case 5:
LABEL_33:
        if ( a1[1] )
        {
          v8 = a1[7];
          --a1[1];
          ++a1[2];
          *(v8 + 2) = *(a1[7] + 2) + *(*a1)++;
          a1[12] = *(a1[7] + 2);
          *a1[7] = 6;
          v15 = 2;
        }
        else
        {
          v15 = v17;
        }
        break;
      case 6:
        *a1[7] = 13;
        a1[6] = "need dictionary";
        *(a1[7] + 1) = 0;
        v15 = -2;
        break;
      case 7:
        v17 = sub_80D45FE(*(a1[7] + 5), a1, v17);
        if ( v17 == -3 )
        {
          *a1[7] = 13;
          *(a1[7] + 1) = 0;
          continue;
        }
        if ( !v17 )
          v17 = v14;
        if ( v17 == 1 )
        {
          v17 = v14;
          sub_80D43EC(*(a1[7] + 5), a1, a1[7] + 1);
          if ( *(a1[7] + 3) )
          {
            *a1[7] = 12;
            continue;
          }
          *a1[7] = 8;
          goto LABEL_46;
        }
        v15 = v17;
        break;
      case 8:
LABEL_46:
        if ( a1[1] )
        {
          v17 = v14;
          v9 = a1[7];
          --a1[1];
          ++a1[2];
          *(v9 + 2) = *(*a1)++ << 24;
          *a1[7] = 9;
          goto LABEL_49;
        }
        v15 = v17;
        break;
      case 9:
LABEL_49:
        if ( a1[1] )
        {
          v17 = v14;
          v10 = a1[7];
          --a1[1];
          ++a1[2];
          *(v10 + 2) = *(a1[7] + 2) + (*(*a1)++ << 16);
          *a1[7] = 10;
          goto LABEL_52;
        }
        v15 = v17;
        break;
      case 0xA:
LABEL_52:
        if ( a1[1] )
        {
          v17 = v14;
          v11 = a1[7];
          --a1[1];
          ++a1[2];
          *(v11 + 2) = *(a1[7] + 2) + (*(*a1)++ << 8);
          *a1[7] = 11;
          goto LABEL_55;
        }
        v15 = v17;
        break;
      case 0xB:
LABEL_55:
        if ( a1[1] )
        {
          v17 = v14;
          v12 = a1[7];
          --a1[1];
          ++a1[2];
          *(v12 + 2) = *(a1[7] + 2) + *(*a1)++;
          if ( *(a1[7] + 1) != *(a1[7] + 2) )
          {
            *a1[7] = 13;
            a1[6] = "incorrect data check";
            *(a1[7] + 1) = 5;
            continue;
          }
          *a1[7] = 12;
          goto LABEL_60;
        }
        v15 = v17;
        break;
      case 0xC:
LABEL_60:
        v15 = 1;
        break;
      case 0xD:
        v15 = -3;
        break;
      default:
        v15 = -2;
        break;
    }
    return v15;
  }
}

//----- (080D7AF4) --------------------------------------------------------
int __cdecl sub_80D7AF4(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10)
{
  int v10; // ebx
  int v11; // ecx
  int v12; // edx
  int v13; // ebx
  int v14; // ecx
  int v15; // edx
  int v17; // [esp+0h] [ebp-128h]
  char v18; // [esp+7h] [ebp-121h]
  unsigned int v19; // [esp+8h] [ebp-120h]
  int v20; // [esp+Ch] [ebp-11Ch]
  _DWORD *v21; // [esp+10h] [ebp-118h]
  _DWORD *v22; // [esp+10h] [ebp-118h]
  int *v23; // [esp+10h] [ebp-118h]
  int *v24; // [esp+10h] [ebp-118h]
  int v25; // [esp+14h] [ebp-114h]
  unsigned int i; // [esp+18h] [ebp-110h]
  int v27; // [esp+18h] [ebp-110h]
  int v28; // [esp+18h] [ebp-110h]
  unsigned int v29; // [esp+18h] [ebp-110h]
  unsigned int l; // [esp+18h] [ebp-110h]
  unsigned int m; // [esp+18h] [ebp-110h]
  unsigned int v32; // [esp+1Ch] [ebp-10Ch]
  unsigned int j; // [esp+1Ch] [ebp-10Ch]
  unsigned int v34; // [esp+1Ch] [ebp-10Ch]
  unsigned int v35; // [esp+1Ch] [ebp-10Ch]
  int v36; // [esp+20h] [ebp-108h]
  unsigned int v37; // [esp+24h] [ebp-104h]
  int v38; // [esp+28h] [ebp-100h]
  int v39; // [esp+28h] [ebp-100h]
  int v40; // [esp+28h] [ebp-100h]
  _DWORD *k; // [esp+2Ch] [ebp-FCh]
  int *v42; // [esp+2Ch] [ebp-FCh]
  int v43[2]; // [esp+30h] [ebp-F8h]
  _BYTE v44[56]; // [esp+38h] [ebp-F0h] BYREF
  int v45[16]; // [esp+70h] [ebp-B8h]
  int v46; // [esp+B0h] [ebp-78h]
  int v47; // [esp+B4h] [ebp-74h]
  int v48; // [esp+B8h] [ebp-70h]
  int n; // [esp+BCh] [ebp-6Ch]
  unsigned int v50; // [esp+C0h] [ebp-68h]
  int v51; // [esp+C4h] [ebp-64h]
  int v52; // [esp+C8h] [ebp-60h]
  unsigned int v53; // [esp+CCh] [ebp-5Ch]
  int v54[19]; // [esp+D0h] [ebp-58h] BYREF
  _DWORD v55[18]; // [esp+D4h] [ebp-54h] BYREF
  int v56; // [esp+11Ch] [ebp-Ch]
  int v57; // [esp+134h] [ebp+Ch]

  v54[0] = 0;
  v55[0] = 0;
  v55[1] = 0;
  v55[2] = 0;
  v55[3] = 0;
  v55[4] = 0;
  v55[5] = 0;
  v55[6] = 0;
  v55[7] = 0;
  v55[8] = 0;
  v55[9] = 0;
  v55[10] = 0;
  v55[11] = 0;
  v55[12] = 0;
  v55[13] = 0;
  v55[14] = 0;
  v21 = a1;
  v32 = a2;
  do
  {
    ++v54[*v21++];
    --v32;
  }
  while ( v32 );
  if ( v54[0] == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    v36 = 0;
  }
  else
  {
    v50 = *a7;
    for ( i = 1; i <= 0xF && !v54[i]; ++i )
      ;
    v25 = i;
    if ( v50 < i )
      v50 = i;
    for ( j = 15; j && !v54[j]; --j )
      ;
    v52 = j;
    if ( v50 > j )
      v50 = j;
    *a7 = v50;
    v38 = 1 << i;
    while ( i < j )
    {
      v39 = v38 - v54[i];
      if ( v39 < 0 )
        return -3;
      ++i;
      v38 = 2 * v39;
    }
    v40 = v38 - v54[j];
    if ( v40 >= 0 )
    {
      v54[j] += v40;
      v27 = 0;
      v43[1] = 0;
      v22 = v55;
      for ( k = v44; --j; ++k )
      {
        v27 += *v22;
        *k = v27;
        ++v22;
      }
      v23 = a1;
      v34 = 0;
      do
      {
        v28 = *v23++;
        if ( v28 )
          a10[v43[v28]++] = v34;
        ++v34;
      }
      while ( v34 < a2 );
      v57 = v43[v52];
      v35 = 0;
      v43[0] = 0;
      v24 = a10;
      v51 = -1;
      v20 = -v50;
      v45[0] = 0;
      v48 = 0;
      v37 = 0;
      while ( v25 <= v52 )
      {
        v56 = v54[v25];
        while ( --v56 != -1 )
        {
          while ( v25 > (v50 + v20) )
          {
            ++v51;
            v20 += v50;
            v19 = v52 - v20;
            if ( v52 - v20 > v50 )
              v19 = v50;
            v29 = v25 - v20;
            v53 = 1 << (v25 - v20);
            if ( v53 > v56 + 1 )
            {
              v53 = v53 - v56 - 1;
              v42 = &v54[v25];
              if ( v29 < v19 )
              {
                while ( ++v29 < v19 )
                {
                  v53 *= 2;
                  if ( v53 <= *++v42 )
                    break;
                  v53 -= *v42;
                }
              }
            }
            v37 = 1 << v29;
            if ( (*a9 + (1 << v29)) > 0x5A0 )
              return -3;
            v48 = a8 + 8 * *a9;
            v45[v51] = v48;
            *a9 += v37;
            if ( v51 )
            {
              v43[v51] = v35;
              BYTE1(v46) = v50;
              LOBYTE(v46) = v29;
              v47 = ((v48 - *&v44[4 * v51 + 52]) >> 3) - (v35 >> (v20 - v50));
              v10 = 8 * (v35 >> (v20 - v50));
              v11 = *&v44[4 * v51 + 52];
              v12 = v47;
              *(v11 + v10) = v46;
              *(v11 + v10 + 4) = v12;
            }
            else
            {
              *a6 = v48;
            }
          }
          BYTE1(v46) = v25 - v20;
          if ( v24 < &a10[v57] )
          {
            if ( *v24 >= a3 )
            {
              LOBYTE(v46) = *(a5 + 4 * (*v24 - a3)) + 80;
              v47 = *(a4 + 4 * (*v24++ - a3));
            }
            else
            {
              if ( *v24 <= 0xFF )
                v18 = 0;
              else
                v18 = 96;
              LOBYTE(v46) = v18;
              v47 = *v24++;
            }
          }
          else
          {
            LOBYTE(v46) = -64;
          }
          v53 = 1 << (v25 - v20);
          for ( l = v35 >> v20; l < v37; l += v53 )
          {
            v13 = 8 * l;
            v14 = v48;
            v15 = v47;
            *(v48 + v13) = v46;
            *(v14 + v13 + 4) = v15;
          }
          for ( m = 1 << (v25 - 1); (m & v35) != 0; m >>= 1 )
            v35 ^= m;
          v35 ^= m;
          for ( n = (1 << v20) - 1; (n & v35) != v43[v51]; n = (1 << v20) - 1 )
          {
            --v51;
            v20 -= v50;
          }
        }
        ++v25;
      }
      if ( !v40 || v52 == 1 )
        v17 = 0;
      else
        v17 = -5;
      v36 = v17;
    }
    else
    {
      v36 = -3;
    }
  }
  return v36;
}
// 80D7AF4: using guessed type int var_58[19];

//----- (080D8319) --------------------------------------------------------
int __cdecl sub_80D8319(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  int *v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h] BYREF
  int v9; // [esp+34h] [ebp-4h]

  v8 = 0;
  v7 = (*(a5 + 32))(*(a5 + 40), 19, 4);
  if ( !v7 )
    return -4;
  v9 = sub_80D7AF4(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v8, v7);
  if ( v9 == -3 )
  {
    *(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v9 == -5 || !*a2 )
  {
    *(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(a5 + 36))(*(a5 + 40), v7);
  return v9;
}

//----- (080D8402) --------------------------------------------------------
int __cdecl sub_80D8402(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9)
{
  int *v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v11 = (*(a9 + 32))(*(a9 + 40), 288, 4);
  if ( !v11 )
    return -4;
  v13 = sub_80D7AF4(a3, a1, 0x101u, &unk_80EC460, &unk_80EC4E0, a6, a4, a8, &v12, v11);
  if ( !v13 && *a4 )
  {
    v13 = sub_80D7AF4(&a3[a1], a2, 0, &unk_80EC560, &unk_80EC5E0, a7, a5, a8, &v12, v11);
    if ( !v13 && (*a5 || a1 <= 0x101) )
    {
      (*(a9 + 36))(*(a9 + 40), v11);
      return 0;
    }
    if ( v13 == -3 )
    {
      *(a9 + 24) = "oversubscribed distance tree";
    }
    else if ( v13 == -5 )
    {
      *(a9 + 24) = "incomplete distance tree";
      v13 = -3;
    }
    else if ( v13 != -4 )
    {
      *(a9 + 24) = "empty distance tree with lengths";
      v13 = -3;
    }
  }
  else if ( v13 == -3 )
  {
    *(a9 + 24) = "oversubscribed literal/length tree";
  }
  else if ( v13 != -4 )
  {
    *(a9 + 24) = "incomplete literal/length tree";
    v13 = -3;
  }
  (*(a9 + 36))(*(a9 + 40), v11);
  return v13;
}

//----- (080D85E5) --------------------------------------------------------
int __cdecl sub_80D85E5(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_80F8920;
  *a2 = dword_80F8924;
  *a3 = &unk_80F8940;
  *a4 = &unk_80F9940;
  return 0;
}
// 80F8920: using guessed type int dword_80F8920;
// 80F8924: using guessed type int dword_80F8924;

//----- (080D8618) --------------------------------------------------------
int __cdecl sub_80D8618(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *srcb; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  char *desta; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]

  dest = a2[3];
  src = *(a1 + 48);
  if ( src > *(a1 + 52) )
    v3 = *(a1 + 44);
  else
    v3 = *(a1 + 52);
  n = v3 - src;
  if ( (v3 - src) > a2[4] )
    n = a2[4];
  if ( n && a3 == -5 )
    a3 = 0;
  a2[4] -= n;
  a2[5] += n;
  if ( *(a1 + 56) )
  {
    *(a1 + 60) = (*(a1 + 56))(*(a1 + 60), src, n);
    a2[12] = *(a1 + 60);
  }
  memcpy(dest, src, n);
  desta = &dest[n];
  srca = &src[n];
  if ( srca == *(a1 + 44) )
  {
    srcb = *(a1 + 40);
    if ( *(a1 + 52) == *(a1 + 44) )
      *(a1 + 52) = *(a1 + 40);
    na = *(a1 + 52) - srcb;
    if ( na > a2[4] )
      na = a2[4];
    if ( na && a3 == -5 )
      a3 = 0;
    a2[4] -= na;
    a2[5] += na;
    if ( *(a1 + 56) )
    {
      *(a1 + 60) = (*(a1 + 56))(*(a1 + 60), srcb, na);
      a2[12] = *(a1 + 60);
    }
    memcpy(desta, srcb, na);
    desta += na;
    srca = &srcb[na];
  }
  a2[3] = desta;
  *(a1 + 48) = srca;
  return a3;
}

//----- (080D880C) --------------------------------------------------------
void sub_80D880C()
{
  ;
}

//----- (080D8811) --------------------------------------------------------
int __cdecl sub_80D8811(int a1)
{
  sub_80D880C();
  *(a1 + 2832) = a1 + 140;
  *(a1 + 2840) = &off_80F9A84;
  *(a1 + 2844) = a1 + 2432;
  *(a1 + 2852) = &off_80F9A98;
  *(a1 + 2856) = a1 + 2676;
  *(a1 + 2864) = &unk_80F9AAC;
  *(a1 + 5808) = 0;
  *(a1 + 5812) = 0;
  *(a1 + 5804) = 8;
  return sub_80D88A9(a1);
}
// 80F9A84: using guessed type void *off_80F9A84;
// 80F9A98: using guessed type void *off_80F9A98;

//----- (080D88A9) --------------------------------------------------------
int __cdecl sub_80D88A9(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]
  int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 285; ++i )
    *(a1 + 4 * i + 140) = 0;
  for ( j = 0; j <= 29; ++j )
    *(a1 + 4 * j + 2432) = 0;
  for ( k = 0; k <= 18; ++k )
    *(a1 + 4 * k + 2676) = 0;
  *(a1 + 1164) = 1;
  *(a1 + 5796) = 0;
  *(a1 + 5792) = 0;
  result = a1;
  *(a1 + 5800) = 0;
  *(a1 + 5784) = 0;
  return result;
}

//----- (080D8966) --------------------------------------------------------
int __cdecl sub_80D8966(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  v5 = *(a1 + 4 * a3 + 2900);
  for ( i = 2 * a3; i <= *(a1 + 5192); i *= 2 )
  {
    if ( i < *(a1 + 5192)
      && (*(a2 + 4 * *(a1 + 4 * i + 2904)) < *(a2 + 4 * *(a1 + 4 * i + 2900))
       || *(a2 + 4 * *(a1 + 4 * i + 2904)) == *(a2 + 4 * *(a1 + 4 * i + 2900))
       && *(*(a1 + 4 * i + 2904) + a1 + 5200) <= *(*(a1 + 4 * i + 2900) + a1 + 5200)) )
    {
      ++i;
    }
    if ( *(a2 + 4 * v5) < *(a2 + 4 * *(a1 + 4 * i + 2900))
      || *(a2 + 4 * v5) == *(a2 + 4 * *(a1 + 4 * i + 2900)) && *(v5 + a1 + 5200) <= *(*(a1 + 4 * i + 2900) + a1 + 5200) )
    {
      break;
    }
    *(a1 + 4 * a3 + 2900) = *(a1 + 4 * i + 2900);
    a3 = i;
  }
  result = v5;
  *(a1 + 4 * a3 + 2900) = v5;
  return result;
}

//----- (080D8B28) --------------------------------------------------------
int *__cdecl sub_80D8B28(_DWORD *a1, int a2)
{
  int *result; // eax
  int v3; // [esp+0h] [ebp-3Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-36h]
  int v5; // [esp+8h] [ebp-34h]
  int i; // [esp+Ch] [ebp-30h] BYREF
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int *j; // [esp+18h] [ebp-24h] BYREF
  int *v10; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-18h]
  int v13; // [esp+28h] [ebp-14h]
  int v14; // [esp+2Ch] [ebp-10h]
  int v15; // [esp+30h] [ebp-Ch]

  v15 = *a2;
  v14 = *(a2 + 4);
  v13 = **(a2 + 8);
  v12 = *(*(a2 + 8) + 4);
  v11 = *(*(a2 + 8) + 8);
  v10 = *(*(a2 + 8) + 16);
  v3 = 0;
  for ( i = 0; i <= 15; ++i )
    *(a1 + i + 1434) = 0;
  *(v15 + 4 * a1[a1[1299] + 725] + 2) = 0;
  result = (a1[1299] + 1);
  for ( j = result; j <= 572; j = (j + 1) )
  {
    v8 = a1[j + 725];
    i = *(v15 + 4 * *(v15 + 4 * v8 + 2) + 2) + 1;
    if ( i > v10 )
    {
      i = v10;
      ++v3;
    }
    *(v15 + 4 * v8 + 2) = i;
    if ( v8 <= v14 )
    {
      ++*(a1 + i + 1434);
      v5 = 0;
      if ( v8 >= v11 )
        v5 = *(v12 + 4 * (v8 - v11));
      v4 = *(v15 + 4 * v8);
      a1[1448] += v4 * (i + v5);
      if ( v13 )
        a1[1449] += v4 * (v5 + *(v13 + 4 * v8 + 2));
    }
    result = &j;
  }
  if ( v3 )
  {
    do
    {
      for ( i = v10 - 1; !*(a1 + i + 1434); --i )
        ;
      --*(a1 + i + 1434);
      *(a1 + i + 1435) += 2;
      --*(a1 + v10 + 1434);
      v3 -= 2;
    }
    while ( v3 > 0 );
    result = v10;
    for ( i = v10; i; --i )
    {
      v8 = *(a1 + i + 1434);
      while ( v8 )
      {
        j = (j - 1);
        v7 = a1[j + 725];
        if ( v7 <= v14 )
        {
          if ( *(v15 + 4 * v7 + 2) != i )
          {
            a1[1448] += (i - *(v15 + 4 * v7 + 2)) * *(v15 + 4 * v7);
            *(v15 + 4 * v7 + 2) = i;
          }
          --v8;
        }
      }
      result = &i;
    }
  }
  return result;
}

//----- (080D8E64) --------------------------------------------------------
int __cdecl sub_80D8E64(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // cx
  int v5; // [esp+10h] [ebp-38h]
  int j; // [esp+14h] [ebp-34h]
  int i; // [esp+18h] [ebp-30h]
  __int16 v8; // [esp+1Eh] [ebp-2Ah]
  __int16 v9[20]; // [esp+20h] [ebp-28h]

  v8 = 0;
  for ( i = 1; i <= 15; ++i )
  {
    v8 = 2 * (*(a3 + 2 * i - 2) + v8);
    v9[i] = v8;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j > a2 )
      break;
    v5 = *(a1 + 4 * j + 2);
    if ( *(a1 + 4 * j + 2) )
    {
      v4 = v9[v5];
      v9[v5] = v4 + 1;
      *(a1 + 4 * j) = sub_80DB660(v4, v5);
    }
  }
  return result;
}

//----- (080D8F1A) --------------------------------------------------------
int __cdecl sub_80D8F1A(_DWORD *a1, int a2)
{
  char v2; // al
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+20h] [ebp-28h]
  int v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]

  v13 = *a2;
  v12 = **(a2 + 8);
  v11 = *(*(a2 + 8) + 12);
  v6 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  for ( i = 0; i < v11; ++i )
  {
    if ( *(v13 + 4 * i) )
    {
      ++a1[1298];
      v6 = i;
      a1[a1[1298] + 725] = i;
      *(a1 + i + 5200) = 0;
    }
    else
    {
      *(v13 + 4 * i + 2) = 0;
    }
  }
  while ( a1[1298] <= 1 )
  {
    ++a1[1298];
    if ( v6 > 1 )
      v4 = 0;
    else
      v4 = ++v6;
    a1[a1[1298] + 725] = v4;
    *(v13 + 4 * v4) = 1;
    *(a1 + v4 + 5200) = 0;
    --a1[1448];
    if ( v12 )
      a1[1449] -= *(v12 + 4 * v4 + 2);
  }
  *(a2 + 4) = v6;
  for ( j = a1[1298] / 2; j > 0; --j )
    sub_80D8966(a1, v13, j);
  v5 = v11;
  do
  {
    v10 = a1[726];
    a1[726] = a1[a1[1298]-- + 725];
    sub_80D8966(a1, v13, 1);
    v7 = a1[726];
    --a1[1299];
    a1[a1[1299]-- + 725] = v10;
    a1[a1[1299] + 725] = v7;
    *(v13 + 4 * v5) = *(v13 + 4 * v7) + *(v13 + 4 * v10);
    if ( *(a1 + v10 + 5200) < *(a1 + v7 + 5200) )
      v2 = *(a1 + v7 + 5200);
    else
      v2 = *(a1 + v10 + 5200);
    *(a1 + v5 + 5200) = v2 + 1;
    *(v13 + 4 * v7 + 2) = v5;
    *(v13 + 4 * v10 + 2) = *(v13 + 4 * v7 + 2);
    a1[726] = v5++;
    sub_80D8966(a1, v13, 1);
  }
  while ( a1[1298] > 1 );
  a1[--a1[1299] + 725] = a1[726];
  sub_80D8B28(a1, a2);
  return sub_80D8E64(v13, v6, (a1 + 717));
}

//----- (080D92B9) --------------------------------------------------------
int __cdecl sub_80D92B9(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  v9 = -1;
  v7 = *(a2 + 2);
  v6 = 0;
  v5 = 7;
  v4 = 4;
  if ( !*(a2 + 2) )
  {
    v5 = 138;
    v4 = 3;
  }
  *(a2 + 4 * a3 + 6) = -1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v8 = v7;
    v7 = *(a2 + 4 * i + 6);
    if ( ++v6 >= v5 || v8 != v7 )
    {
      if ( v6 >= v4 )
      {
        if ( v8 )
        {
          if ( v8 != v9 )
            ++a1[2 * v8 + 1338];
          ++a1[1370];
        }
        else if ( v6 > 10 )
        {
          ++a1[1374];
        }
        else
        {
          ++a1[1372];
        }
      }
      else
      {
        a1[2 * v8 + 1338] += v6;
      }
      v6 = 0;
      v9 = v8;
      if ( v7 )
      {
        if ( v8 == v7 )
        {
          v5 = 6;
          v4 = 3;
        }
        else
        {
          v5 = 7;
          v4 = 4;
        }
      }
      else
      {
        v5 = 138;
        v4 = 3;
      }
    }
  }
  return result;
}

//----- (080D944C) --------------------------------------------------------
int __cdecl sub_80D944C(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp+0h] [ebp-2Ch]
  int v13; // [esp+0h] [ebp-2Ch]
  int v14; // [esp+0h] [ebp-2Ch]
  int v15; // [esp+0h] [ebp-2Ch]
  int v16; // [esp+0h] [ebp-2Ch]
  int v17; // [esp+4h] [ebp-28h]
  int v18; // [esp+4h] [ebp-28h]
  int v19; // [esp+4h] [ebp-28h]
  int v20; // [esp+4h] [ebp-28h]
  int v21; // [esp+4h] [ebp-28h]
  int v22; // [esp+8h] [ebp-24h]
  int v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  int v27; // [esp+1Ch] [ebp-10h]
  int i; // [esp+20h] [ebp-Ch]

  v27 = -1;
  v25 = *(a2 + 2);
  v24 = 0;
  v23 = 7;
  v22 = 4;
  if ( !*(a2 + 2) )
  {
    v23 = 138;
    v22 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v26 = v25;
    v25 = *(a2 + 4 * i + 6);
    if ( ++v24 >= v23 || v26 != v25 )
    {
      if ( v24 >= v22 )
      {
        if ( v26 )
        {
          if ( v26 != v27 )
          {
            v13 = *(a1 + 4 * v26 + 2678);
            if ( *(a1 + 5812) <= 16 - v13 )
            {
              *(a1 + 5808) |= *(a1 + 4 * v26 + 2676) << *(a1 + 5812);
              v5 = *(a1 + 5812) + v13;
            }
            else
            {
              v18 = *(a1 + 4 * v26 + 2676);
              *(a1 + 5808) |= v18 << *(a1 + 5812);
              *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
              *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
              *(a1 + 5808) = v18 >> (16 - *(a1 + 5812));
              v5 = *(a1 + 5812) + v13 - 16;
            }
            *(a1 + 5812) = v5;
            --v24;
          }
          v14 = *(a1 + 2742);
          if ( *(a1 + 5812) <= 16 - v14 )
          {
            *(a1 + 5808) |= *(a1 + 2740) << *(a1 + 5812);
            v6 = *(a1 + 5812) + v14;
          }
          else
          {
            v19 = *(a1 + 2740);
            *(a1 + 5808) |= v19 << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = v19 >> (16 - *(a1 + 5812));
            v6 = *(a1 + 5812) + v14 - 16;
          }
          *(a1 + 5812) = v6;
          if ( *(a1 + 5812) <= 14 )
          {
            *(a1 + 5808) |= (v24 - 3) << *(a1 + 5812);
            v7 = *(a1 + 5812) + 2;
          }
          else
          {
            *(a1 + 5808) |= (v24 - 3) << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = (v24 - 3) >> (16 - *(a1 + 5812));
            v7 = *(a1 + 5812) - 14;
          }
          *(a1 + 5812) = v7;
        }
        else if ( v24 > 10 )
        {
          v16 = *(a1 + 2750);
          if ( *(a1 + 5812) <= 16 - v16 )
          {
            *(a1 + 5808) |= *(a1 + 2748) << *(a1 + 5812);
            v10 = *(a1 + 5812) + v16;
          }
          else
          {
            v21 = *(a1 + 2748);
            *(a1 + 5808) |= v21 << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = v21 >> (16 - *(a1 + 5812));
            v10 = *(a1 + 5812) + v16 - 16;
          }
          *(a1 + 5812) = v10;
          if ( *(a1 + 5812) <= 9 )
          {
            *(a1 + 5808) |= (v24 - 11) << *(a1 + 5812);
            v11 = *(a1 + 5812) + 7;
          }
          else
          {
            *(a1 + 5808) |= (v24 - 11) << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = (v24 - 11) >> (16 - *(a1 + 5812));
            v11 = *(a1 + 5812) - 9;
          }
          *(a1 + 5812) = v11;
        }
        else
        {
          v15 = *(a1 + 2746);
          if ( *(a1 + 5812) <= 16 - v15 )
          {
            *(a1 + 5808) |= *(a1 + 2744) << *(a1 + 5812);
            v8 = *(a1 + 5812) + v15;
          }
          else
          {
            v20 = *(a1 + 2744);
            *(a1 + 5808) |= v20 << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = v20 >> (16 - *(a1 + 5812));
            v8 = *(a1 + 5812) + v15 - 16;
          }
          *(a1 + 5812) = v8;
          if ( *(a1 + 5812) <= 13 )
          {
            *(a1 + 5808) |= (v24 - 3) << *(a1 + 5812);
            v9 = *(a1 + 5812) + 3;
          }
          else
          {
            *(a1 + 5808) |= (v24 - 3) << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = (v24 - 3) >> (16 - *(a1 + 5812));
            v9 = *(a1 + 5812) - 13;
          }
          *(a1 + 5812) = v9;
        }
      }
      else
      {
        do
        {
          v17 = *(a1 + 4 * v26 + 2678);
          if ( *(a1 + 5812) <= 16 - v17 )
          {
            *(a1 + 5808) |= *(a1 + 4 * v26 + 2676) << *(a1 + 5812);
            v4 = *(a1 + 5812) + v17;
          }
          else
          {
            v12 = *(a1 + 4 * v26 + 2676);
            *(a1 + 5808) |= v12 << *(a1 + 5812);
            *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
            *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
            *(a1 + 5808) = v12 >> (16 - *(a1 + 5812));
            v4 = *(a1 + 5812) + v17 - 16;
          }
          *(a1 + 5812) = v4;
          --v24;
        }
        while ( v24 );
      }
      v24 = 0;
      v27 = v26;
      if ( v25 )
      {
        if ( v26 == v25 )
        {
          v23 = 6;
          v22 = 3;
        }
        else
        {
          v23 = 7;
          v22 = 4;
        }
      }
      else
      {
        v23 = 138;
        v22 = 3;
      }
    }
  }
  return result;
}

//----- (080D9E12) --------------------------------------------------------
int __cdecl sub_80D9E12(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  sub_80D92B9(a1, a1 + 140, *(a1 + 2836));
  sub_80D92B9(a1, a1 + 2432, *(a1 + 2848));
  sub_80D8F1A(a1, a1 + 2856);
  for ( i = 18; i > 2 && !*(a1 + 4 * *(i + 135186700) + 2678); --i )
    ;
  *(a1 + 5792) += 3 * i + 17;
  return i;
}

//----- (080D9ED1) --------------------------------------------------------
int __cdecl sub_80D9ED1(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( *(a1 + 5812) <= 11 )
  {
    *(a1 + 5808) |= (a2 - 257) << *(a1 + 5812);
    v4 = *(a1 + 5812) + 5;
  }
  else
  {
    *(a1 + 5808) |= (a2 - 257) << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = (a2 - 257) >> (16 - *(a1 + 5812));
    v4 = *(a1 + 5812) - 11;
  }
  *(a1 + 5812) = v4;
  if ( *(a1 + 5812) <= 11 )
  {
    *(a1 + 5808) |= (a3 - 1) << *(a1 + 5812);
    v5 = *(a1 + 5812) + 5;
  }
  else
  {
    *(a1 + 5808) |= (a3 - 1) << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = (a3 - 1) >> (16 - *(a1 + 5812));
    v5 = *(a1 + 5812) - 11;
  }
  *(a1 + 5812) = v5;
  if ( *(a1 + 5812) <= 12 )
  {
    *(a1 + 5808) |= (a4 - 4) << *(a1 + 5812);
    v6 = *(a1 + 5812) + 4;
  }
  else
  {
    *(a1 + 5808) |= (a4 - 4) << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = (a4 - 4) >> (16 - *(a1 + 5812));
    v6 = *(a1 + 5812) - 12;
  }
  *(a1 + 5812) = v6;
  for ( i = 0; i < a4; ++i )
  {
    if ( *(a1 + 5812) <= 13 )
    {
      *(a1 + 5808) |= *(a1 + 4 * *(i + 135186700) + 2678) << *(a1 + 5812);
      v7 = *(a1 + 5812) + 3;
    }
    else
    {
      v9 = *(a1 + 4 * *(i + 135186700) + 2678);
      *(a1 + 5808) |= v9 << *(a1 + 5812);
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
      *(a1 + 5808) = v9 >> (16 - *(a1 + 5812));
      v7 = *(a1 + 5812) - 13;
    }
    *(a1 + 5812) = v7;
  }
  sub_80D944C(a1, a1 + 140, a2 - 1);
  return sub_80D944C(a1, a1 + 2432, a3 - 1);
}

//----- (080DA375) --------------------------------------------------------
int *__cdecl sub_80DA375(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax

  if ( *(a1 + 5812) <= 13 )
  {
    *(a1 + 5808) |= a4 << *(a1 + 5812);
    v4 = *(a1 + 5812) + 3;
  }
  else
  {
    *(a1 + 5808) |= a4 << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = a4 >> (16 - *(a1 + 5812));
    v4 = *(a1 + 5812) - 13;
  }
  *(a1 + 5812) = v4;
  return sub_80DB7E8(a1, a2, a3, 1);
}

//----- (080DA4A3) --------------------------------------------------------
int __cdecl sub_80DA4A3(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax

  if ( *(a1 + 5812) <= 13 )
  {
    *(a1 + 5808) |= 2 << *(a1 + 5812);
    v1 = *(a1 + 5812) + 3;
  }
  else
  {
    *(a1 + 5808) |= 2 << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = 2 >> (16 - *(a1 + 5812));
    v1 = *(a1 + 5812) - 13;
  }
  *(a1 + 5812) = v1;
  if ( *(a1 + 5812) <= 9 )
  {
    *(a1 + 5808) = *(a1 + 5808);
    v2 = *(a1 + 5812) + 7;
  }
  else
  {
    *(a1 + 5808) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = 0;
    v2 = *(a1 + 5812) - 9;
  }
  *(a1 + 5812) = v2;
  sub_80DB68E(a1);
  if ( *(a1 + 5804) - *(a1 + 5812) + 11 <= 8 )
  {
    if ( *(a1 + 5812) <= 13 )
    {
      *(a1 + 5808) |= 2 << *(a1 + 5812);
      v3 = *(a1 + 5812) + 3;
    }
    else
    {
      *(a1 + 5808) |= 2 << *(a1 + 5812);
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
      *(a1 + 5808) = 2 >> (16 - *(a1 + 5812));
      v3 = *(a1 + 5812) - 13;
    }
    *(a1 + 5812) = v3;
    if ( *(a1 + 5812) <= 9 )
    {
      *(a1 + 5808) = *(a1 + 5808);
      v4 = *(a1 + 5812) + 7;
    }
    else
    {
      *(a1 + 5808) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
      *(a1 + 5808) = 0;
      v4 = *(a1 + 5812) - 9;
    }
    *(a1 + 5812) = v4;
    sub_80DB68E(a1);
  }
  result = a1;
  *(a1 + 5804) = 7;
  return result;
}

//----- (080DA911) --------------------------------------------------------
int __cdecl sub_80DA911(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  if ( *(a1 + 124) <= 0 )
  {
    v8 = a3 + 5;
    v9 = a3 + 5;
  }
  else
  {
    if ( *(a1 + 28) == 2 )
      sub_80DB5C6(a1);
    sub_80D8F1A(a1, a1 + 2832);
    sub_80D8F1A(a1, a1 + 2844);
    v7 = sub_80D9E12(a1);
    v9 = (*(a1 + 5792) + 10) >> 3;
    v8 = (*(a1 + 5796) + 10) >> 3;
    if ( v8 <= v9 )
      v9 = (*(a1 + 5796) + 10) >> 3;
  }
  if ( a3 + 4 <= v9 && a2 )
  {
    sub_80DA375(a1, a2, a3, a4);
  }
  else if ( v8 == v9 )
  {
    if ( *(a1 + 5812) <= 13 )
    {
      *(a1 + 5808) |= (a4 + 2) << *(a1 + 5812);
      v4 = *(a1 + 5812) + 3;
    }
    else
    {
      *(a1 + 5808) |= (a4 + 2) << *(a1 + 5812);
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
      *(a1 + 5808) = (a4 + 2) >> (16 - *(a1 + 5812));
      v4 = *(a1 + 5812) - 13;
    }
    *(a1 + 5812) = v4;
    sub_80DAE1B(a1, &unk_80EC920, &unk_80ECDA0);
  }
  else
  {
    if ( *(a1 + 5812) <= 13 )
    {
      *(a1 + 5808) |= (a4 + 4) << *(a1 + 5812);
      v5 = *(a1 + 5812) + 3;
    }
    else
    {
      *(a1 + 5808) |= (a4 + 4) << *(a1 + 5812);
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
      *(a1 + 5808) = (a4 + 4) >> (16 - *(a1 + 5812));
      v5 = *(a1 + 5812) - 13;
    }
    *(a1 + 5812) = v5;
    sub_80D9ED1(a1, *(a1 + 2836) + 1, *(a1 + 2848) + 1, v7 + 1);
    sub_80DAE1B(a1, a1 + 140, a1 + 2432);
  }
  result = sub_80D88A9(a1);
  if ( a4 )
    result = sub_80DB751(a1);
  return result;
}

//----- (080DAE1B) --------------------------------------------------------
int __cdecl sub_80DAE1B(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+4h] [ebp-24h]
  int v14; // [esp+4h] [ebp-24h]
  int v15; // [esp+8h] [ebp-20h]
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+8h] [ebp-20h]
  int v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  unsigned int i; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  unsigned int v26; // [esp+1Ch] [ebp-Ch]
  unsigned int v27; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i < *(a1 + 5784); ++i )
  {
    v25 = *(*(a1 + 5788) + 2 * i);
    v23 = *(*(a1 + 5776) + i);
    if ( v25 )
    {
      v21 = *(v23 + 135188512);
      v12 = *(a2 + 4 * v21 + 1030);
      if ( *(a1 + 5812) <= 16 - v12 )
      {
        *(a1 + 5808) |= *(a2 + 4 * v21 + 1028) << *(a1 + 5812);
        v4 = *(a1 + 5812) + v12;
      }
      else
      {
        v16 = *(a2 + 4 * v21 + 1028);
        *(a1 + 5808) |= v16 << *(a1 + 5812);
        *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
        *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
        *(a1 + 5808) = v16 >> (16 - *(a1 + 5812));
        v4 = *(a1 + 5812) + v12 - 16;
      }
      *(a1 + 5812) = v4;
      v19 = dword_80EC7C0[v21];
      if ( v19 )
      {
        v24 = v23 - dword_80ED120[v21];
        if ( *(a1 + 5812) <= 16 - v19 )
        {
          *(a1 + 5808) |= v24 << *(a1 + 5812);
          v5 = *(a1 + 5812) + v19;
        }
        else
        {
          *(a1 + 5808) |= v24 << *(a1 + 5812);
          *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
          *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
          *(a1 + 5808) = v24 >> (16 - *(a1 + 5812));
          v5 = *(a1 + 5812) + v19 - 16;
        }
        *(a1 + 5812) = v5;
      }
      v26 = v25 - 1;
      if ( v26 > 0xFF )
        v10 = byte_80ECF20[v26 >> 7];
      else
        v10 = *(v26 + 135188000);
      v13 = *(a3 + 4 * v10 + 2);
      if ( *(a1 + 5812) <= 16 - v13 )
      {
        *(a1 + 5808) |= *(a3 + 4 * v10) << *(a1 + 5812);
        v6 = *(a1 + 5812) + v13;
      }
      else
      {
        v17 = *(a3 + 4 * v10);
        *(a1 + 5808) |= v17 << *(a1 + 5812);
        *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
        *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
        *(a1 + 5808) = v17 >> (16 - *(a1 + 5812));
        v6 = *(a1 + 5812) + v13 - 16;
      }
      *(a1 + 5812) = v6;
      v20 = dword_80EC840[v10];
      if ( v20 )
      {
        v27 = v26 - dword_80ED1A0[v10];
        if ( *(a1 + 5812) <= 16 - v20 )
        {
          *(a1 + 5808) |= v27 << *(a1 + 5812);
          v7 = *(a1 + 5812) + v20;
        }
        else
        {
          *(a1 + 5808) |= v27 << *(a1 + 5812);
          *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
          *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
          *(a1 + 5808) = v27 >> (16 - *(a1 + 5812));
          v7 = *(a1 + 5812) + v20 - 16;
        }
        *(a1 + 5812) = v7;
      }
    }
    else
    {
      v15 = *(a2 + 4 * v23 + 2);
      if ( *(a1 + 5812) <= 16 - v15 )
      {
        *(a1 + 5808) |= *(a2 + 4 * v23) << *(a1 + 5812);
        v3 = *(a1 + 5812) + v15;
      }
      else
      {
        v11 = *(a2 + 4 * v23);
        *(a1 + 5808) |= v11 << *(a1 + 5812);
        *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
        *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
        *(a1 + 5808) = v11 >> (16 - *(a1 + 5812));
        v3 = *(a1 + 5812) + v15 - 16;
      }
      *(a1 + 5812) = v3;
    }
  }
  v14 = *(a2 + 1026);
  if ( *(a1 + 5812) <= 16 - v14 )
  {
    *(a1 + 5808) |= *(a2 + 1024) << *(a1 + 5812);
    v8 = *(a1 + 5812) + v14;
  }
  else
  {
    v18 = *(a2 + 1024);
    *(a1 + 5808) |= v18 << *(a1 + 5812);
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = v18 >> (16 - *(a1 + 5812));
    v8 = *(a1 + 5812) + v14 - 16;
  }
  *(a1 + 5812) = v8;
  result = a1;
  *(a1 + 5804) = *(a2 + 1026);
  return result;
}
// 80EC7C0: using guessed type int dword_80EC7C0[];
// 80EC840: using guessed type int dword_80EC840[];

//----- (080DB5C6) --------------------------------------------------------
bool __cdecl sub_80DB5C6(int a1)
{
  bool result; // al
  unsigned int v2; // [esp+0h] [ebp-Ch]
  unsigned int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  v3 = 0;
  v2 = 0;
  while ( v4 <= 6 )
    v2 += *(a1 + 4 * v4++ + 140);
  while ( v4 <= 127 )
    v3 += *(a1 + 4 * v4++ + 140);
  while ( v4 <= 255 )
    v2 += *(a1 + 4 * v4++ + 140);
  result = v2 <= v3 >> 2;
  *(a1 + 28) = result;
  return result;
}

//----- (080DB660) --------------------------------------------------------
unsigned int __cdecl sub_80DB660(unsigned int a1, int a2)
{
  unsigned int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = 0;
  do
  {
    v4 = a1 & 1 | v3;
    a1 >>= 1;
    v3 = 2 * v4;
    --a2;
  }
  while ( a2 > 0 );
  return v3 >> 1;
}

//----- (080DB68E) --------------------------------------------------------
int __cdecl sub_80DB68E(int a1)
{
  int result; // eax

  if ( *(a1 + 5812) == 16 )
  {
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
    *(a1 + 5808) = 0;
    result = a1;
    *(a1 + 5812) = 0;
  }
  else
  {
    result = a1;
    if ( *(a1 + 5812) > 7 )
    {
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
      *(a1 + 5808) >>= 8;
      result = *(a1 + 5812) - 8;
      *(a1 + 5812) = result;
    }
  }
  return result;
}

//----- (080DB751) --------------------------------------------------------
int __cdecl sub_80DB751(int a1)
{
  int result; // eax

  if ( *(a1 + 5812) <= 8 )
  {
    if ( *(a1 + 5812) > 0 )
      *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
  }
  else
  {
    *(*(a1 + 8) + (*(a1 + 20))++) = *(a1 + 5808);
    *(*(a1 + 8) + (*(a1 + 20))++) = HIBYTE(*(a1 + 5808));
  }
  *(a1 + 5808) = 0;
  result = a1;
  *(a1 + 5812) = 0;
  return result;
}

//----- (080DB7E8) --------------------------------------------------------
int *__cdecl sub_80DB7E8(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax

  sub_80DB751(a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(a1[2] + a1[5]++) = a3;
    *(a1[2] + a1[5]++) = BYTE1(a3);
    *(a1[2] + a1[5]++) = ~a3;
    *(a1[2] + a1[5]++) = ~a3 >> 8;
  }
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    *(a1[2] + a1[5]++) = *a2++;
  }
  return result;
}

//----- (080DB9B6) --------------------------------------------------------
void *__cdecl sub_80DB9B6(int a1, size_t nmemb, size_t size)
{
  return calloc(nmemb, size);
}

//----- (080DB9D0) --------------------------------------------------------
void __cdecl sub_80DB9D0(int a1, void *ptr)
{
  free(ptr);
}

//----- (080DB9E4) --------------------------------------------------------
int __cdecl sub_80DB9E4(char *filename, struct stat *stat_buf)
{
  return __xstat(3, filename, stat_buf);
}

//----- (080DBA10) --------------------------------------------------------
int sub_80DBA10()
{
  void (__cdecl *v0)(); // eax
  void (__cdecl **v1)(); // ebx
  int v3; // [esp+0h] [ebp-8h]

  v0 = off_80FDFCC;
  v1 = &off_80FDFCC;
  if ( off_80FDFCC != -1 )
  {
    do
    {
      --v1;
      v0();
      v0 = *v1;
    }
    while ( *v1 != -1 );
  }
  return v3;
}
// 80DBA3C: variable 'v3' is possibly undefined
// 80FDFCC: using guessed type int (*off_80FDFCC)();

//----- (080DBA40) --------------------------------------------------------
void term_proc(void)
{
  sub_8049F70();
}

// nfuncs=2149 queued=1908 decompiled=1908 lumina nreq=0 worse=0 better=0
#error "There were 18 decompilation failure(s) on 1908 function(s)"
