/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void init_proc(void); // idb
void sub_804973C();
// int usleep(__useconds_t useconds);
// int mkdir(const char *path, __mode_t mode);
// double cos(double x);
// uint32_t ntohl(uint32_t netlong);
// int rename(const char *old, const char *new);
// int execl(const char *path, const char *arg, ...);
// char *strncat(char *dest, const char *src, size_t n);
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
// ssize_t write(int fd, const void *buf, size_t n);
// struct tm *localtime(const time_t *timer);
// ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len);
// int fileno(FILE *stream);
// int strcmp(const char *s1, const char *s2);
// int close(int fd);
// void *dlsym(void *handle, const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// __pid_t fork(void);
// char *getenv(const char *name);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int fflush(FILE *stream);
// int seteuid(__uid_t uid);
// int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
// char *strerror(int errnum);
// void __cdecl __noreturn __cxa_call_unexpected(void *);
// int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
// struct passwd *getpwuid(__uid_t uid);
// void __cdecl operator delete(void *); idb
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
// int *__errno_location(void);
// int ftell(FILE *stream);
// int system(const char *command);
// int chmod(const char *file, __mode_t mode);
// int tolower(int c);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// void *malloc(size_t size);
// size_t fread(void *ptr, size_t size, size_t n, FILE *stream);
// void *memmove(void *dest, const void *src, size_t n);
// ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len);
// int remove(const char *filename);
// int __sigsetjmp(struct __jmp_buf_tag *env, int savemask);
// int __xstat(int ver, const char *filename, struct stat *stat_buf);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// int vfprintf(FILE *s, const char *format, __gnuc_va_list arg);
// int fseek(FILE *stream, int off, int whence);
// time_t time(time_t *timer);
// int fputs(const char *s, FILE *stream);
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
// void longjmp(struct __jmp_buf_tag env[1], int val);
// unsigned int sleep(unsigned int seconds);
// void __cxa_end_catch(void);
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
// double atof(const char *nptr);
// double atan2(double y, double x);
// int strncmp(const char *s1, const char *s2, size_t n);
// in_addr_t inet_addr(const char *cp);
// double floor(double x);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *dlerror(void);
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int toupper(int c);
// void *realloc(void *ptr, size_t size);
// char *strcat(char *dest, const char *src);
// char *asctime(const struct tm *tp);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// __uid_t getuid(void);
// int fcntl(int fd, int cmd, ...);
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
// int fclose(FILE *stream);
// char *ctime(const time_t *timer);
// int closedir(DIR *dirp);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void srand(unsigned int seed);
// DIR *opendir(const char *name);
// int snprintf(char *s, size_t maxlen, const char *format, ...);
// int gethostname(char *name, size_t len);
// struct hostent *gethostbyname(const char *name);
// int strcasecmp(const char *s1, const char *s2);
// int dlclose(void *handle);
// void exit(int status);
// int atoi(const char *nptr);
// void *calloc(size_t nmemb, size_t size);
// int sscanf(const char *s, const char *format, ...);
// void free(void *ptr);
// int ioctl(int fd, unsigned int request, ...);
// uint16_t htons(uint16_t hostshort);
// char *getcwd(char *buf, size_t size);
// void *__cdecl __cxa_begin_catch(void *);
// int isatty(int fd);
// void *memset(void *s, int c, size_t n);
// void _exit(int status);
// int strncasecmp(const char *s1, const char *s2, size_t n);
// char *strncpy(char *dest, const char *src, size_t n);
// FILE *fopen(const char *filename, const char *modes);
// int __cdecl _Unwind_Resume(_DWORD); weak
// _DWORD __cdecl operator new[](unsigned int); idb
// int sprintf(char *s, const char *format, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// double sin(double x);
// int socket(int domain, int type, int protocol);
// struct dirent *readdir(DIR *dirp);
// int rand(void);
// int tcgetattr(int fd, struct termios *termios_p);
// ssize_t read(int fd, void *buf, size_t nbytes);
// __uid_t geteuid(void);
// int __gmon_start__(void); weak
// double ceil(double x);
// void *dlopen(const char *file, int mode);
// char *strcpy(char *dest, const char *src);
// void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>);
void sub_8049EF0();
int sub_8049F50();
char *sub_8049FB0();
int __cdecl CMod_LoadShaders(_DWORD *a1);
signed int __cdecl CMod_LoadSubmodels(_DWORD *a1);
signed int __cdecl CMod_LoadNodes(_DWORD *a1);
int __cdecl CMod_LoadBrushes(_DWORD *a1, _DWORD *a2);
void *__cdecl CMod_LoadLeafs(_DWORD *a1);
int __cdecl CMod_LoadPlanes(_DWORD *a1);
int __cdecl CMod_LoadLeafBrushes(_DWORD *a1);
int __cdecl CMod_LoadLeafSurfaces(_DWORD *a1);
int __cdecl CMod_LoadLeafCurvesAndTerrain(_DWORD *a1, _DWORD *a2, _DWORD *a3);
void *__cdecl CMod_LoadEntityString(size_t *a1);
void *__cdecl CMod_LoadVisibility(size_t *a1);
char *__cdecl CM_LoadMap(char *src, int a2, int a3);
int *__cdecl sub_804BBD8(int a1);
int __cdecl sub_804BCA0(int a1);
void *sub_804BCE6();
int __cdecl sub_804BCF0(int a1);
int __cdecl sub_804BD06(int a1);
int CM_InitBoxHull();
int __cdecl sub_804BDD3(int *a1, int *a2, int a3, int a4);
int sub_804BEA7();
int __cdecl sub_804BEB3(int a1, int *a2, _DWORD *a3);
int __cdecl sub_804BF16(__int16 a1);
int __cdecl sub_804BF29(int a1);
long double __cdecl sub_804BF31(float a1);
int __cdecl sub_804BF44(int a1);
int __cdecl sub_804BF99(float *a1, float *a2, float *a3, float *a4);
_BOOL4 __cdecl sub_804C083(int a1, int a2, int a3, int a4);
int *__cdecl sub_804C123(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804C1F8(int *a1);
_DWORD *__cdecl sub_804C82F(_DWORD *a1);
int __cdecl sub_804C905(_DWORD *a1, int a2);
_BOOL4 __cdecl sub_804CD1C(float *a1, float *a2);
int __cdecl sub_804CDEB(int *a1);
int __cdecl sub_804CFCC(float *a1, float *a2, _DWORD *a3);
int *__cdecl sub_804D121(int *a1);
int __cdecl sub_804D1F8(int a1, _DWORD *a2);
int __cdecl sub_804D342(float *a1, float *a2, float *a3);
int __cdecl sub_804D677(float *a1, int a2);
int __cdecl sub_804D727(int a1, int a2, int a3, int a4);
int __cdecl sub_804D7B0(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_804DE63(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_804E12C(_DWORD *a1);
int __cdecl sub_804E38B(_DWORD *a1);
void *__cdecl sub_804EBE6(_DWORD *a1, int a2);
void *__cdecl sub_804F60B(int a1, int a2, int a3, int a4, float *a5);
int __cdecl sub_804F9B3(int a1, _DWORD *a2);
int __cdecl sub_804FEAB(int a1, _DWORD *a2);
int __cdecl sub_805036E(float *a1, float *a2, float *a3, float *a4, float *a5, _DWORD *a6);
int __cdecl sub_805050A(int a1, _DWORD *a2);
int __cdecl sub_8050B4F(int a1, _DWORD *a2);
int __cdecl sub_805111E(int a1, _DWORD *a2);
void *__cdecl sub_80515DC(int a1);
int __cdecl sub_8051624(void *ptr); // idb
float *__cdecl sub_80518FC(float *a1, float *a2, float *a3);
long double __cdecl sub_80519BB(int a1);
int __cdecl sub_8051AF6(_DWORD *a1, _DWORD *a2, _DWORD *a3);
float *__cdecl sub_8051CDF(int a1, float a2);
void *__cdecl sub_8052013(void *src);
int *__cdecl sub_8052140(void *src, int a2, float a3, float a4, int a5, int a6);
int *__cdecl sub_80528B5(int a1, int a2, float a3, float a4);
void *__cdecl sub_80537C4(size_t a1);
void *__cdecl sub_80537D7(size_t a1);
int __cdecl sub_80537EA(int a1, const char *a2, float *a3, int a4, float *a5);
char *CM_LoadStaticModels();
int __cdecl sub_8053ED2(int a1, int *a2, float *a3, float *a4, int a5);
int __cdecl sub_80540DC(int a1, int a2, __int16 a3, __int16 a4);
unsigned __int16 *__cdecl sub_8054176(int a1, int a2, unsigned int a3, int a4, int a5);
int __cdecl sub_8055763(int a1, unsigned __int16 *a2);
int __cdecl sub_8055AAB(int a1, unsigned __int16 *a2);
int __cdecl sub_8056941(float *a1, unsigned __int16 *a2);
int __cdecl sub_8057125(_DWORD *a1, unsigned __int16 *a2);
int __cdecl sub_80571C3(_DWORD *a1, unsigned __int16 *a2);
_BOOL4 __cdecl sub_8057241(int *a1, unsigned __int16 *a2);
int __cdecl sub_80572F0(int a1, unsigned __int16 *a2);
int __cdecl sub_8057350(float *a1, int a2);
int __cdecl sub_805740A(float *a1);
_DWORD *__cdecl sub_8057425(_DWORD *a1, int a2);
int __cdecl sub_805748D(_DWORD *a1, int a2);
int __cdecl sub_80575B2(int a1, int a2);
int __cdecl sub_805765D(int *a1, int *a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_8057775(float *a1, int a2);
int __cdecl sub_80578F7(float *a1, int a2, float *a3, float *a4);
char *__cdecl sub_8057A1A(int a1);
int __cdecl sub_8057A5C(int a1, int a2);
int CM_FloodAreaConnections();
int __cdecl sub_8057B6F(int a1, int a2, int a3);
_BOOL4 __cdecl sub_8057C89(int a1, int a2);
float *__cdecl sub_8057CE4(float *a1, float *a2);
int *__cdecl sub_8057D8B(int a1, int a2);
unsigned int __cdecl sub_8057DF6(float *a1, int a2);
float *__cdecl sub_8057E32(float *a1, float *a2, float *a3, float *a4);
void __cdecl sub_80581AF(int a1, int a2);
int __cdecl sub_8058494(int a1, int a2);
void __cdecl sub_805865B(int a1);
void __cdecl sub_8058A60(int a1);
int __cdecl sub_8058BCA(int a1);
_BOOL4 __cdecl sub_8058D51(int a1, float *a2, float *a3);
void __cdecl sub_8058FFC(int a1, int a2);
void __cdecl sub_80590D6(int a1, _DWORD *a2);
void __cdecl sub_8059A41(int a1, int a2);
int __cdecl sub_8059BB2(int, int, int, int, float); // idb
int __cdecl sub_8059E37(int, int, float, float); // idb
void __cdecl sub_805A181(float *a1);
void __cdecl sub_805A5BB(int a1);
void __cdecl sub_805A75B(int a1, int a2, float a3, int a4, int a5, int a6);
int __cdecl sub_805ABA1(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8, int a9);
int __cdecl sub_805B311(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8);
int __cdecl sub_805B366(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
int __cdecl sub_805B77C(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
int __cdecl sub_805B7D7(int *a1, int a2);
int __cdecl sub_805B849(int a1, int a2);
int __cdecl sub_805BF79(int *a1, int a2);
_BOOL4 __cdecl sub_805C0FC(int a1, int a2, int a3, int a4, float a5);
_BOOL4 __cdecl sub_805C272(int a1, int a2, float a3, float a4);
int __cdecl sub_805C498(float *a1);
int __cdecl sub_805C936(int a1);
int __cdecl sub_805CAD6(int *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805CF2E(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl sub_805D625(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8);
int __cdecl sub_805D679(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10);
long double __cdecl sub_805D9B8(float a1);
int __cdecl sub_805D9D4(float *a1, float *a2);
__int64 CM_ClearWorld();
int __cdecl sub_805DBAB(int *a1);
int __cdecl sub_805DD00(float *a1, float *a2, float *a3);
int __cdecl sub_805DFE6(int a1, _DWORD *a2, _DWORD *a3);
int sub_805E1ED();
int __cdecl sub_805E1F7(int a1);
void __cdecl sub_805E332(int a1, int a2);
int __cdecl sub_805E510(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_805E553(int a1, int a2, int a3, int a4, float a5);
void __cdecl sub_805E6C9(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805E97B(int *a1, int *a2, int *a3, int a4);
void __cdecl sub_805EAB1(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805EE11(int a1);
int __cdecl sub_805EE52(int *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805F20E(int a1);
void __cdecl sub_805F253(int a1, int a2, float a3, int a4, int a5, int a6);
void __cdecl sub_805F48A(int a1);
int __cdecl sub_805F4C8(_DWORD *a1, int a2, float a3, float a4, float *a5, float *a6);
int __cdecl sub_805F758(int a1);
int __cdecl sub_805F79A(int a1, int a2, float a3, float a4, float *a5, float *a6);
int sub_805FB6C(); // weak
void Cbuf_Init();
int __cdecl Cbuf_AddText(char *s); // idb
int __cdecl Cbuf_InsertText(char *s);
void __cdecl Cbuf_ExecuteText(int a1, char *s);
void Cbuf_Execute();
int sub_805FE66(); // weak
int sub_805FF7A(); // weak
int Cmd_Vstr_f(); // weak
int sub_80600A1(); // weak
int Cmd_Argc();
char *__cdecl Cmd_Argv(unsigned int a1);
char *__cdecl sub_8060120(int a1, char *dest, int a3);
char *__cdecl sub_806014B(int a1);
char **__cdecl sub_80601DC(char **a1, int a2);
char **__cdecl Cmd_TokenizeString(char **a1);
_DWORD *__cdecl sub_806043E(char *s1, int a2);
int __cdecl sub_80604D4(char *s1); // idb
int sub_8060542();
int __cdecl sub_8060585(void (__cdecl *a1)(int));
void __cdecl Cmd_ExecuteString(char *s);
int sub_806072D(); // weak
_DWORD *Cmd_Init();
_BOOL4 sub_8060850();
void sub_8060862();
int __cdecl sub_8060867(int a1);
int sub_80608C4();
_BOOL4 __cdecl sub_80608CE(int a1);
int __cdecl sub_8060946(int a1, int a2);
int __cdecl sub_80609D9(int a1);
int __cdecl sub_8060AA0(int a1);
int __cdecl sub_8060AB8(int a1);
int __cdecl sub_8060AF1(int a1);
_BYTE *__cdecl sub_8060B9F(_BYTE *a1);
void *__cdecl sub_8060BD6(char *s, char *a2, char *a3, void *dest, int a5);
void *__cdecl sub_8060CD2(char *s, char *a2, char *a3, void *dest);
int __cdecl sub_8060D02(char *haystack); // idb
void __cdecl sub_8060D97(char *haystack, char *filename);
int __cdecl sub_806111C(char *filename); // idb
int __cdecl sub_806112F(char *); // idb
int __cdecl sub_80611A9(char *, char *); // idb
void *__cdecl FS_FCloseFile(int a1);
int __cdecl sub_80613C7(char *src); // idb
int __cdecl sub_8061529(char *src); // idb
int __cdecl sub_806168B(char *src); // idb
int __cdecl FS_FilenameCompare(char *a1, char *a2);
char *__cdecl sub_8061AE4(char *haystack, int a2, char a3);
const char *__cdecl sub_8061B58(_BYTE *a1);
_BOOL4 __cdecl sub_8061BA3(char *s1);
int __cdecl sub_8061C40(char *haystack, int, int, int); // idb
int __cdecl FS_FOpenFileRead(char *haystack, int, int); // idb
int __cdecl sub_8062698(char *haystack); // idb
_BOOL4 __cdecl sub_806288F(char *a1, int a2);
int __cdecl FS_Read(char *a1, size_t a2, int a3);
size_t __cdecl FS_Write(char *a1, size_t a2, int a3);
size_t sub_8062B8B(int a1, char *format, ...);
int __cdecl sub_8062BE1(int, int off, int); // idb
size_t __cdecl FS_ReadFile(char *haystack, int a2);
void sub_8063305();
int __cdecl FS_FreeFile(void *ptr);
void *__cdecl FS_WriteFile(char *src, int a2, int a3);
char *__cdecl sub_80633C6(char *src, char *a2);
int __cdecl sub_8063980(char *src, char *dest, int); // idb
int __cdecl sub_8063A0E(char *s, int, int); // idb
void *__cdecl FS_ListFilteredFiles(char *s, char *a2, int a3, int a4);
void *__cdecl sub_8064009(char *s, char *a2, int a3);
void __cdecl sub_8064032(void *ptr);
int __cdecl sub_806408D(char *s, char *, char *dest, int); // idb
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1);
int __cdecl sub_80641B7(char *a1, char *a2);
int __cdecl FS_SortFileList(void *dest, int); // idb
char *__cdecl sub_806437E(int a1);
char *sub_80644D1();
char *sub_80644E5();
int __cdecl sub_80644F9(char *s); // idb
int compar(const void *, const void *); // idb
_DWORD *__cdecl sub_80646A4(_DWORD *a1);
int __cdecl sub_806470A(char *, char *src); // idb
void *__cdecl sub_8064A1B(char *a1, char *src, int a3, int a4);
void *__cdecl sub_8064C65(char *a1, char *src);
void __cdecl sub_8064CB1(char *a1, int a2, char *a3, char *a4);
char *__cdecl sub_806507A(char *a1, char *a2);
int __cdecl sub_80650D2(char *s2, int, int); // idb
_DWORD *__cdecl sub_80652A4(unsigned int a1, unsigned int a2);
void *__cdecl sub_8065423(void *ptr);
void *__cdecl sub_80654A5(void *ptr);
void *sub_80654E6();
int sub_8065536();
int sub_8065590();
int __cdecl sub_80655EA(int a1);
int __cdecl sub_80656E5(char *src); // idb
_DWORD *__cdecl sub_8065B5A(int a1);
char *FS_InitFilesystem();
char *__cdecl sub_8065CAC(int a1);
int __cdecl FS_FOpenFileByMode(char *src, int, int); // idb
int __cdecl FS_Flush(int a1);
int __cdecl sub_80660B8(int a1);
int __cdecl sub_80660C0(int a1);
long double __cdecl sub_80660DB(int a1);
long double __cdecl sub_806619F(float a1);
long double __cdecl sub_80666D0(float *a1, float *a2);
float *__cdecl sub_80667A1(float *a1, float *a2, float *a3);
long double __cdecl sub_8066845(float *a1);
long double __cdecl sub_8066A90(float *a1, float *a2);
unsigned int __cdecl sub_8066B4E(_DWORD *a1);
float *__cdecl sub_8066CE8(int a1, int a2, int a3, float a4);
long double __cdecl sub_80671DE(float *a1);
long double __cdecl sub_80672AE(float *a1);
int __cdecl sub_8067362(float *a1, int a2);
int __cdecl sub_806749D(float *a1, int a2);
float *__cdecl sub_806759D(float *a1, int a2, float *a3, float *a4);
float *__cdecl sub_8067726(float a1, int a2, int a3);
void __cdecl sub_80677A4(float *a1, float *a2);
float *__cdecl sub_80679EC(float *a1, float *a2, float *a3);
int __cdecl sub_806890D(_DWORD *a1, _DWORD *a2);
float *__cdecl sub_806899C(float *a1, float *a2);
float *__cdecl sub_8069244(float *a1, float *a2, float *a3);
float *__cdecl sub_80692EE(float *a1, float *a2, float *a3);
float *__cdecl sub_8069506(float *a1, float *a2, float *a3);
float *__cdecl sub_80696FC(float *a1, float *a2, float *a3);
unsigned int __cdecl sub_806981E(_DWORD *a1, unsigned int *a2);
long double __cdecl sub_8069A7F(float *a1);
long double __cdecl sub_8069F4B(float a1, float a2);
long double __cdecl sub_806A017(float a1);
long double __cdecl sub_806A05A(float a1);
double sub_806A1B3(); // weak
int __cdecl sub_806A254(_DWORD, _DWORD); // weak
int __cdecl sub_806A28F(_DWORD, _DWORD, _DWORD); // weak
int __cdecl sub_806A55E(_DWORD, _DWORD, _DWORD); // weak
int sub_806AA54(); // weak
float *__cdecl sub_806AB3E(float *a1, float *a2, float *a3);
int __cdecl loc_806AC6E(int, int, int, float); // idb
int __cdecl sub_806B014(int *a1, int a2, _DWORD *a3);
float *__cdecl sub_806B570(float a1, float *a2, float *a3);
double *__cdecl sub_806B588(double a1, double *a2, double *a3);
char *__cdecl sub_806B5CC(char *s, char *a2, int a3);
int __cdecl sub_806B69A(int, char *, int); // idb
int __cdecl sub_806B9BA(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Com_HashKey(int a1, int a2);
int sub_806BB0A(); // weak
int __cdecl Z_FreeInternal(void *ptr); // idb
void *__cdecl Z_MallocInternal(size_t size);
char *__cdecl sub_806BC0A(char *s);
int sub_806BC3E();
void sub_806BE13();
_DWORD __cdecl sub_806BEC9(size_t maxlen, char *format, char); // weak
_DWORD *sub_806C15B();
int sub_806C29F();
_DWORD *sub_806C2B8();
int sub_806C315();
_DWORD *sub_806C35F();
int sub_806C39F();
_DWORD *Hunk_ClearToMarkLow();
void *sub_806C3CA();
int *sub_806C442();
void sub_806C459();
void *__cdecl sub_806C482(size_t n);
void *__cdecl sub_806C49D(size_t n, int a2);
int __cdecl sub_806C565(int a1);
int sub_806C5D0();
void *__cdecl sub_806C5DF(size_t n);
void *__cdecl sub_806C5FA(size_t n, int a2);
int sub_806C69F();
_DWORD *__cdecl sub_806C6AE(size_t size);
int __cdecl sub_806C77E(int a1);
int sub_806C7D2();
int sub_806C7E1();
int __cdecl sub_806C7F0(void *ptr); // idb
int Hunk_ClearTempMemoryInternal();
int __cdecl sub_806C894(_BYTE *a1);
int __cdecl sub_806C8DA(char *a1);
int __cdecl sub_806C96A(char *a1, int a2);
char *__cdecl sub_806C9DF(char *dest, int a2);
int __cdecl sub_806CAE3(char *a1);
int __cdecl sub_806CC0C(char *a1);
int __cdecl sub_806CC82(char *a1);
_BOOL4 __cdecl sub_806CCF8(char *s, char *src);
void __cdecl sub_806CE7B(char *s1, int a2);
void __cdecl sub_806CEDD(char *a1, char *s, int a3, int a4, int a5);
void __cdecl sub_806D261(int a1);
int __cdecl sub_806D439(_DWORD *a1);
int __cdecl sub_806D4AF(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_806D5E6(char *, char *haystack, int, int); // idb
int __cdecl sub_806D87C(int a1, _DWORD *a2);
int __cdecl sub_806DA87(int a1, int a2);
int __cdecl sub_806DE0A(char *s2, int); // idb
int __cdecl sub_806DFEB(int a1);
int __cdecl sub_806E08C(char *a1, int a2);
float *__cdecl sub_806E0C3(char *a1, int a2);
int __cdecl sub_806E264(int a1, int a2);
int __cdecl sub_806E2C2(char *a1);
char *__cdecl sub_806E3C8(char *a1);
size_t __cdecl sub_806E527(char *a1, char *a2, int a3);
void *__cdecl sub_806E5F3(int a1, char *a2);
int __cdecl sub_806E946(char *); // idb
void __cdecl sub_806F42A(char *filename, char *a2);
_BYTE *__cdecl sub_806F768(_BYTE *a1);
char *__cdecl Com_BeginRedirect(char *a1, int a2, int (__cdecl *a3)(_DWORD));
int Com_EndRedirect();
void __cdecl Com_PrintMessage(int a1, char *s);
int __cdecl Com_Printf(char *format, char);
int Com_DPrintf(char *format, ...);
void __cdecl sub_806FCC4(const char *a1);
void *Com_ErrorCleanup();
void sub_806FDFD();
int sub_806FE17();
void sub_806FE2E();
int *__cdecl sub_806FE3D(char *s1);
void __noreturn Com_Error(int a1, char *format, ...);
void __noreturn sub_8070034();
char *__cdecl Com_ParseCommandLine(char *a1);
int sub_80700DF();
int __cdecl Com_StartupVariable(char *s2); // idb
int Com_AddStartupCommands();
int __cdecl Info_Print(char *a1);
int Com_InitJournaling();
_DWORD *__stdcall sub_807054F(_DWORD *a1);
void *Com_InitPushEvent();
int __cdecl sub_80706FE(int *a1);
_DWORD *__stdcall sub_8070829(_DWORD *a1);
int __cdecl sub_80708B6(int *a1, int a2);
int sub_8070944();
int Com_Milliseconds();
void __noreturn sub_8070C45();
void sub_8070C81();
void sub_8070CEE();
char *sub_8070CFD();
char *sub_8070D19();
int __cdecl sub_8070DE3(int a1, int a2);
int sub_8070E33();
void sub_8070E96();
int Script_Init();
int __cdecl Com_Init(int a1);
void *__cdecl sub_80714C7(char *src);
void *__cdecl sub_807152C(char *src);
void *sub_8071586();
void *sub_80715BA();
void *sub_8071636();
int __cdecl sub_80716B2(int a1);
int __cdecl sub_8071743(int a1);
int sub_80717B0();
void sub_8071A4B();
_DWORD *__cdecl sub_8071AA7(_DWORD *a1);
char *__cdecl sub_8071AEA(char *src);
int __cdecl sub_8071B9E(char *a1);
int sub_8071BE0();
char *__cdecl sub_8071CC0(char *haystack, char *needle);
char *__cdecl sub_8071D1B(char **a1);
int __cdecl sub_8071F32(int a1);
int sub_8071F6A();
int __cdecl sub_80720BC(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5);
int __cdecl sub_807214C(int a1, int a2);
int __cdecl sub_80721EB(int a1, int a2);
void *sub_8072313();
void sub_8072383();
void *sub_807239D();
void *__cdecl sub_80723CD(size_t a1);
void *__cdecl sub_80723E0(size_t a1);
_DWORD *__cdecl sub_8072406(int a1);
int __cdecl sub_8072421(int a1);
_DWORD *__cdecl sub_807243C(int a1);
int __cdecl sub_8072457(int a1);
int __cdecl sub_8072472(signed int a1, _DWORD *a2, int a3);
int __cdecl sub_80724DB(int a1, int a2);
int sub_8072731();
const char *sub_807273B();
int __cdecl Com_AddToString(_BYTE *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8072820(int a1);
_BOOL4 __cdecl Cvar_ValidateString(char *s);
_DWORD *__cdecl Cvar_FindVar(int a1);
unsigned int *sub_8072976();
int *__cdecl Cvar_Get(char *s, char *s2, int a3);
int *__cdecl sub_8072DA8(char *s, char *s1, int a3);
int *__cdecl Cvar_Set(char *s, char *s1);
int *__cdecl sub_807315D(char *s, char *s1);
int *__cdecl sub_807317F(char *a1, float a2);
int *__cdecl sub_8073219(char *s);
int *__cdecl sub_807323C(int a1, char *s, char *s2, int a4);
int *__cdecl sub_8073293(int a1);
_DWORD *Cvar_Init();
int sub_80733E6();
long double __cdecl Cvar_VariableValue(int a1);
int __cdecl sub_807344B(int a1);
void *__cdecl Cvar_VariableString(int a1);
char *__cdecl sub_80734AD(int a1, char *dest, int a3);
int __cdecl sub_80734ED(void (__cdecl *a1)(_DWORD));
int sub_8073582();
int *sub_807363D();
int *sub_8073790();
_DWORD *sub_8073872();
_DWORD *sub_80738C5();
_DWORD *sub_8073918();
int *sub_807396B();
int *sub_80739DF();
const char **__cdecl sub_8073A13(int a1);
int __cdecl sub_8073AF8(int a1);
int sub_8073B9E();
void sub_8073D7C();
void __cdecl sub_8073D90(int a1);
_DWORD *__cdecl sub_8073F2D(char *s, char *s1);
int sub_807407C();
int __cdecl SV_SetConfig(int a1, int a2, int a3);
char *__cdecl Cvar_InfoString(int a1);
char *__cdecl Cvar_InfoString_Big(int a1);
_DWORD *sub_80742B0();
int __cdecl sub_8074380(char *); // idb
int __cdecl FS_SV_FOpenFileRead(char *src, int); // idb
void *__cdecl sub_80749E8(char *s, char a2);
int __cdecl sub_8074AEF(char *haystack, int); // idb
int __cdecl sub_8074C70(_DWORD *a1);
_DWORD *__cdecl sub_8074C9D(void *ptr, void *a2, void *a3);
int __cdecl sub_8074DCC(char *, int); // idb
void sub_80752D3();
void FS_NewDir_f();
int sub_80754B6();
int __cdecl FS_iwPak(char *haystack, int); // idb
_BOOL4 __cdecl sub_80756BF(char *src);
_DWORD __cdecl sub_80759D9(char); // weak
_DWORD *sub_8075A4A();
_DWORD *sub_8075AB6();
char *sub_8075B76();
char *sub_8075BEE();
char *sub_8075C7A();
char *FS_ReferencedPakChecksums();
char *FS_ReferencedPakNames();
void *__cdecl sub_807603C(char **a1, char **a2);
int __cdecl sub_80763FB(char a1, int a2);
int __cdecl get_bit(int a1);
_DWORD *__cdecl sub_8076497(int a1);
_DWORD *__cdecl sub_80764E7(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8076506(int a1, int a2, int a3);
int __cdecl sub_807658E(int a1, int a2);
void __cdecl sub_807664E(int a1, int a2);
void __cdecl sub_80767B5(_DWORD *a1, unsigned __int8 a2);
int __cdecl sub_8076A3A(_DWORD *a1, _DWORD *a2, int a3);
_DWORD *__cdecl Huff_offsetReceive(_DWORD *a1, _DWORD *a2, int a3, int *a4);
int __cdecl sub_8076B0B(int a1, int a2, int a3);
int *__cdecl sub_8076B71(int a1, int a2, int a3);
int __cdecl sub_8076BF4(int a1, int a2, int a3, int *a4);
unsigned __int8 *__cdecl Huff_Decompress(_DWORD *a1, int a2);
unsigned __int8 *__cdecl sub_8076E5E(int a1, int a2);
int __cdecl sub_8077008(void *s); // idb
long double __cdecl sub_80771A0(char *a1);
char **__cdecl sub_807725D(char *s);
int __cdecl sub_80772CE(int a1);
int __cdecl sub_807733C(char *a1);
char **__cdecl sub_80773E9(char *a1, char *s);
long double __cdecl sub_8077499(char *a1, char *s);
int __cdecl sub_80775A8(char *filename); // idb
void sub_8077687();
int sub_80776F5(char *format, ...);
_DWORD *__cdecl sub_8077760(int a1);
_DWORD *__cdecl sub_80777A3(size_t n);
_DWORD *__cdecl sub_80777D6(int a1);
int __cdecl sub_807784C(int a1);
int sub_8077880(int a1, char *format, ...);
int sub_80778E6(int a1, char *format, ...);
_DWORD *__cdecl sub_807794C(_DWORD *a1, int a2, int a3);
int __cdecl sub_80779BD(_DWORD *a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_8077A58(int a1, int a2);
void sub_8077AD2();
_DWORD *__cdecl sub_8077AD7(void *src);
int __cdecl sub_8077B47(int a1);
int __cdecl sub_8077B60(int, void *dest); // idb
int __cdecl sub_8077CB5(int, void *src); // idb
int __cdecl sub_8077CEE(int a1, const char **a2, int a3, int a4);
int __cdecl sub_8078095(int, char *dest); // idb
int __cdecl sub_8078153(char *dest, char *src); // idb
int __cdecl sub_807826D(int a1);
int *__cdecl sub_80782CC(int *a1, int a2);
int __cdecl sub_807830D(int, char *s2); // idb
int __cdecl sub_8078373(int, char *s2); // idb
int __cdecl sub_80783BE(int, char *s2); // idb
int __cdecl sub_8078419(int a1);
int __cdecl sub_8078589(int, void *src, int, int, int); // idb
int __cdecl sub_80787FF(int, void *, int, int, int); // idb
int __cdecl sub_8078CB9(int, void *, int); // idb
char *__cdecl sub_8078D32(char *a1);
int __cdecl sub_8078DBB(int a1);
int __cdecl sub_8079039(int, char *s1); // idb
_BOOL4 __cdecl sub_80790B8(int a1);
_DWORD *__cdecl sub_80790E7(_DWORD *a1);
int __cdecl sub_8079113(int a1);
int __cdecl sub_80792D2(int a1);
int __cdecl sub_807986E(char *s); // idb
char **__cdecl sub_8079B14(int a1, int a2);
int __cdecl sub_8079C6F(int a1);
int __cdecl sub_8079CBF(_DWORD *a1, int a2);
int __cdecl sub_8079DB5(_DWORD *a1);
int __cdecl sub_8079DD0(_DWORD *a1);
int __cdecl sub_8079DEB(_DWORD *a1);
int __cdecl sub_8079E7B(_DWORD *a1);
int __cdecl sub_8079EC8(int a1);
int __cdecl sub_8079FD7(int a1, char *a2, _DWORD *a3, _DWORD *a4, int a5);
int __cdecl sub_807AF86(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_807B2D9(int a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl sub_807B68E(_DWORD *a1);
int __cdecl sub_807B739(_DWORD *a1);
int __cdecl sub_807B7A1(int a1);
int __cdecl sub_807B7C1(int a1);
int __cdecl sub_807B819(int a1);
int __cdecl sub_807B855(int a1);
int __cdecl sub_807B8CD(int a1);
int __cdecl sub_807B9AF(int a1);
int __cdecl sub_807BA99(int a1);
int __cdecl sub_807BBB5(int a1);
int __cdecl sub_807BCA3(int a1);
int __cdecl sub_807BDCF(int a1);
int __cdecl sub_807BF00(int, char *s); // idb
int __cdecl sub_807C4C1(int, char *s2); // idb
int __cdecl sub_807C647(int, void *src); // idb
_DWORD *__cdecl sub_807C6E2(char *src);
int __cdecl sub_807C8C8(_DWORD *a1);
int __cdecl sub_807CCE0(int a1, int a2);
int sub_807CEB0(int a1, char *format, ...);
int sub_807CF19(int a1, char *format, ...);
int __cdecl sub_807CF82(int a1, int a2);
int __cdecl sub_807CFD2(int a1);
int __cdecl sub_807D122(int a1, char *a2);
int __cdecl sub_807D339(_DWORD *a1, int a2, int a3);
int __cdecl sub_807D55C(int a1, int a2);
int __cdecl sub_807D61C(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4);
int __cdecl sub_807D8D0(int a1, int a2);
int __cdecl sub_807DE20(int, char *dest); // idb
int __cdecl sub_807DEFE(int a1, void *src);
int __cdecl sub_807DFA6(_DWORD *a1, void *dest);
int __cdecl sub_807E2E7(_DWORD *a1, int a2, int a3, void *a4);
int __cdecl sub_807E611(_DWORD *a1, void *dest);
char *__cdecl sub_807E819(char *dest);
_BOOL4 __cdecl sub_807EAAC(int a1);
char **__cdecl sub_807EB4F(char *src);
_DWORD *__cdecl sub_807ECED(void *a1, size_t n, char *src);
int __cdecl sub_807EDD5(int a1);
int __cdecl sub_807EDFF(char *format); // idb
_DWORD *__cdecl sub_807EE24(_DWORD *a1);
void *__cdecl sub_807EE64(int a1, void *src, int a3);
void *__cdecl sub_807EF60(int a1, void *s);
void *__cdecl sub_807F021(int *a1, int a2);
unsigned int __cdecl sub_807F72D(int a1, int a2, unsigned int a3);
unsigned int __cdecl sub_807F7D5(int a1, int a2, unsigned int a3);
int __cdecl sub_807F851(void *src, int); // idb
int sub_807F8AD(void *a1, int a2, ...);
int __cdecl MSG_Init(void *s, int, int); // idb
int __cdecl MSG_BeginReading(int a1);
int __cdecl MSG_WriteBits(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl MSG_WriteBit0(_DWORD *a1);
_DWORD *__cdecl MSG_WriteBit1(_DWORD *a1);
int __cdecl MSG_ReadBits(_DWORD *a1, int a2);
int __cdecl sub_807FBC2(_DWORD *a1);
int __cdecl MSG_WriteBitsCompress(unsigned __int8 *a1, int a2, int a3);
_BYTE *__cdecl MSG_ReadBitsCompress(int a1, _BYTE *a2, int a3);
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2);
int __cdecl MSG_WriteData(int, void *src, size_t n); // idb
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2);
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2);
int __cdecl MSG_WriteString(int, char *s); // idb
int __cdecl MSG_WriteBigString(int, char *s); // idb
int __cdecl MSG_ReadByte(_DWORD *a1);
int __cdecl MSG_ReadShort(_DWORD *a1);
int __cdecl MSG_ReadLong(_DWORD *a1);
void *__cdecl MSG_ReadString(int a1);
void *__cdecl MSG_ReadStringLine(int a1);
_DWORD *__cdecl sub_8080389(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_80803CD(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8080415(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_8080439(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_8080466(_DWORD *a1, char a2, char a3, char a4);
int __cdecl sub_80804A4(_DWORD *a1, char a2, int a3);
_DWORD *__cdecl sub_80804DA(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4);
int __cdecl sub_8080518(_DWORD *a1, __int16 a2, int a3);
_BYTE *__cdecl MSG_WriteReliableCommandToBuffer(char *s, int a2, int a3);
void __cdecl MSG_SetDefaultUserCmd(int a1, void *s);
int __cdecl sub_8080780(int a1, int a2);
int __cdecl sub_80807C6(int a1);
_BYTE *__cdecl sub_80807F2(char a1, _BYTE *a2, _BYTE *a3);
_BYTE *__cdecl sub_808084B(char a1, _BYTE *a2);
_BYTE *__cdecl sub_8080CAB(_DWORD *a1, int a2, int a3, int a4);
int *__cdecl MSG_WriteDeltaField(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8081210(_DWORD *a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__cdecl MSG_WriteDeltaStruct(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
_DWORD *__cdecl MSG_WriteDeltaEntity(int a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_80814E8(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4);
_DWORD *__cdecl sub_8081536(_DWORD *a1, char *a2, _DWORD *a3, int a4);
int __cdecl sub_80815AE(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5);
int __cdecl sub_808179B(_DWORD *a1, int a2, int a3, int a4, int a5);
int __cdecl sub_808184D(int, void *src, void *dest, int, int, int, int); // idb
int __cdecl sub_8081A49(int, void *src, void *dest, int); // idb
int __cdecl sub_8081A8F(int, void *src, void *dest, int); // idb
int __cdecl MSG_WriteDeltaHudElems(_DWORD *a1, int a2, int a3, int a4);
void *__cdecl sub_8081C74(_DWORD *a1, int a2, int a3, int a4);
_DWORD *__cdecl sub_8081DD3(_DWORD *a1, char *a2, _DWORD *a3);
void *__cdecl sub_8082640(_DWORD *a1, char *a2, char *a3);
int *sub_8082D03();
int __cdecl sub_8082D81(__int16 a1);
int __cdecl sub_8082D94(int a1);
void *__cdecl NetProf_PrepProfiling(void **a1);
int __cdecl sub_8082E8B(int a1, int a2, int a3);
int __cdecl NetProf_NewSendPacket(_DWORD *a1, int a2, int a3);
int __cdecl NetProf_NewRecievePacket(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl sub_8083018(_DWORD *a1);
int sub_808334C(); // weak
_DWORD *__cdecl Netchan_Init(unsigned __int16 a1);
void *__cdecl sub_808346F(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8);
int *__cdecl Netchan_TransmitNextFragment(int *a1);
int *__cdecl sub_80836E6(int a1, size_t n, void *src);
int __cdecl Netchan_Process(_DWORD *a1, _DWORD *a2);
int __cdecl NET_CompareBaseAdrSigned(int a1, int a2);
_BOOL4 NET_CompareBaseAdr(int a1, int a2, int a3, int a4, int a5, ...);
char *__cdecl NET_AdrToString(int a1, int a2, int a3, int a4, int a5);
int __cdecl NET_CompareAdrSigned(int a1, int a2);
_BOOL4 NET_CompareAdr(int a1, int a2, int a3, int a4, int a5, ...);
int __cdecl NET_IsLocalAddress(int a1);
int __cdecl sub_8084061(int, void *s, int); // idb
size_t __cdecl sub_8084164(int a1, size_t n, void *src);
void *__cdecl NET_SendPacket(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8);
void *NET_OutOfBandPrint(int a1, int a2, int a3, int a4, int a5, int a6, char *format, ...);
void *__cdecl sub_808442C(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n);
int __cdecl NET_StringToAdr(char *s1, void *s); // idb
int __cdecl sub_8084648(int a1);
void sub_8084650();
int *CL_Init();
void sub_808469F();
void sub_80846A4();
void sub_80846A9();
void sub_80846AE();
void sub_80846B3();
void sub_80846B8();
void sub_80846BD();
int sub_80846C2();
void sub_80846CC();
int sub_80846D1();
void sub_80846DB();
void sub_80846E0();
void sub_80846EA();
void CL_InitKeyCommands();
void sub_80846F4();
void CL_StartHunkUsers();
void sub_80846FE();
int sub_8084703();
void sub_8084714();
void sub_8084719();
void sub_808471E();
void sub_8084723();
char *__cdecl sub_8084734(char *src);
_DWORD *sub_80847D5();
void *sub_8084819();
int __cdecl sub_8084855(int a1);
void __noreturn sub_808488D(char *format, ...);
int sub_80848F5(char *format, ...);
int sub_8084955();
_BYTE *__cdecl sub_8084A3A(_BYTE *a1, _DWORD *a2);
int __cdecl sub_8084A8D(_BYTE *a1);
int sub_8084BC9();
void *__cdecl sub_8084BD3(_BYTE **a1, int a2);
void *__cdecl sub_8084D4E(char **a1, int a2);
void *__cdecl Com_Parse(_DWORD *a1);
void *__cdecl sub_8085382(char **a1);
int __cdecl sub_80853FF(int, char *s2, int); // idb
_BYTE *__cdecl sub_80854D2(_DWORD *a1);
int __cdecl sub_80855FD(_DWORD *a1, int a2, int a3);
int __cdecl sub_8085683(_DWORD *a1, int a2, int a3, int a4);
_BYTE *__cdecl sub_80857F1(_BYTE *a1);
char *__cdecl sub_8085892(char *s, size_t maxlen, int a3);
int __cdecl BigShort(__int16 a1);
int __cdecl sub_8085A6E(__int16 a1);
int __cdecl sub_8085AA5(__int16 a1);
int __cdecl sub_8085AB8(int a1);
int __cdecl sub_8085B14(int a1);
// _DWORD *__userpurge sub_8085B1C@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge sub_8085B7A@<eax>(_DWORD *a1, int a2, int a3);
long double __cdecl sub_8085B9E(int a1);
long double __cdecl sub_8085BD1(float a1);
void Swap_Init();
_BOOL4 __cdecl sub_8085CC2(int a1);
_BOOL4 __cdecl sub_8085D10(int a1);
_BOOL4 __cdecl sub_8085D45(int a1);
_BOOL4 __cdecl sub_8085D6C(int a1);
char *__cdecl Q_strncpyz(char *dest, char *src, int a3);
int __cdecl Q_stricmpn(char *a1, char *a2, int a3);
int __cdecl Q_strncmp(char *a1, char *a2, int a3);
int __cdecl Q_stricmp(char *a1, char *a2);
_BYTE *__cdecl sub_8085FAF(_BYTE *a1);
_BYTE *__cdecl sub_8085FE9(_BYTE *a1);
char *__cdecl sub_8086023(char *s, int a2, char *src);
int __cdecl sub_8086076(_BYTE *a1);
char *__cdecl sub_80860DE(char *a1);
int __cdecl sub_8086166(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
int __cdecl sub_80861E4(char *a1, char *a2, int a3);
int __cdecl Q_strcasecmp(char *a1, char *a2);
char *va(char *format, ...);
void *__cdecl Info_ValueForKey(char *s, int a2);
char *__cdecl sub_808659F(char *s, char *s1);
char *__cdecl sub_80866D1(char *s, char *s1);
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3);
char *__cdecl sub_8086A88(char *s, char *s1, int a3);
long double __cdecl sub_8086EE2(float a1);
void __cdecl sub_8086F1F(int a1, int a2, float a3, float a4, float a5);
int sub_808725A();
long double __cdecl sub_80872E6(float a1);
char *sub_8087300();
char *SV_GetPlayerByNum();
char *__cdecl sub_8087538(char *s);
char *sub_80875E1();
int *SV_MapRestart_f();
void *UI_GetMapRotationToken();
void sub_8087AFA();
int __cdecl sub_8087CEB(int, char *dest, int); // idb
int __cdecl sub_8087D89(char *dest, int); // idb
int __cdecl sub_8087E9D(char *dest, int); // idb
int sub_8087F2A(); // weak
char *sub_8087F73();
char *sub_8087FC7();
int sub_808801B(); // weak
int sub_808804F(); // weak
int sub_808806B(); // weak
int sub_8088087(); // weak
int sub_80880D0(); // weak
int sub_8088368();
int sub_808841A();
void SV_Heartbeat_f();
int SV_Serverinfo_f();
int sub_808856C(); // weak
char *sub_8088594();
void sub_8088603();
void sub_8088617();
int sub_8088624(); // weak
int sub_8088631(); // weak
int *sub_808863E();
int *sub_80886A9();
int *sub_8088714();
_DWORD *sub_808877F();
void sub_808897B();
_DWORD *sub_8088980();
void __cdecl SV_GetChallenge(int a1, int a2, int a3, int a4, int a5);
void __cdecl sub_8088E3B(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_8088F75(int a1);
int __cdecl sub_8088FF8(int a1);
unsigned int sub_8089096();
int __cdecl sub_80890F5(int a1);
int __cdecl sub_8089121(int a1);
int __cdecl sub_808921D(char *src); // idb
int __cdecl SV_AuthorizeIpPacket(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_8089DAF(int a1);
void sub_8089E27();
void __cdecl SV_DirectConnect(int a1, int a2, int a3, int a4, int a5);
int sub_808ABB1();
void __cdecl SV_DropClient(int a1, int a2);
_DWORD *__cdecl SV_DelayDropClient(_DWORD *a1, _DWORD *a2);
void __cdecl sub_808AE1E(int a1, int a2);
char *__cdecl SV_SendClientGameState(char *a1);
int __cdecl SV_ClientEnterWorld(char *a1, _DWORD *a2);
int *__cdecl sub_808B20F(int a1);
int *__cdecl SV_StopDownload_f(int a1);
char *__cdecl SV_DoneDownload_f(int a1);
int __cdecl SV_RetransmitDownload_f(int a1);
void __cdecl SV_NextDownload_f(int a1);
char *__cdecl SV_BeginDownload_f(int a1);
void __cdecl sub_808B491(int a1);
int __cdecl sub_808B6FC(int a1, _DWORD *a2);
int __cdecl sub_808B853(int a1, _DWORD *a2);
int sub_808B89F();
int __cdecl SV_WriteDownloadToClient(int a1, _DWORD *a2);
void __cdecl SV_Disconnect_f(int a1);
int __cdecl SV_VerifyPaks_f(int a1);
int __cdecl SV_ResetPureClient_f(int a1);
const char *__cdecl SV_UserinfoChanged(int a1);
int __cdecl sub_808C743(int a1);
char **__cdecl SV_ExecuteClientCommand(int a1, int a2, int a3);
int __cdecl SV_ClientCommand(int a1, int a2);
_DWORD *__cdecl SV_ClientThink(_DWORD *a1, _DWORD *a2);
void __cdecl SV_UserMove(int a1, int a2, int a3);
void __cdecl SV_ExecuteClientMessage(int a1, _DWORD *a2);
int SV_AddTestClient();
int __cdecl sub_808D314(int a1);
int __cdecl SV_GameClientNum(int a1);
int __cdecl sub_808D34E(int *a1);
int __cdecl sub_808D395(int a1);
int __cdecl sub_808D3C3(int a1, int a2, const char *a3);
void __cdecl sub_808D436(int a1, int a2);
int __cdecl sub_808D470(_DWORD *a1);
_BOOL4 __cdecl sub_808D512(float *a1, float *a2);
int __cdecl sub_808D5D2(float *a1, int a2);
_BOOL4 __cdecl sub_808D837(float *a1, float *a2);
int __cdecl sub_808D8BC(int *a1, int a2);
int __cdecl sub_808D905(int *a1, int *a2, int a3, int a4);
char *__cdecl sub_808D982(char *dest, int a2);
void *__cdecl sub_808D9CD(size_t a1);
void *__cdecl sub_808D9FD(size_t a1);
void *__cdecl sub_808DA2D(size_t n, int a2);
void *__cdecl sub_808DA64(size_t n, int a2);
_DWORD *__cdecl sub_808DA9B(size_t size);
int __cdecl sub_808DAAE(void *ptr); // idb
int __cdecl sub_808DAC1(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_808DAEE(int a1, _DWORD *a2);
int __cdecl sub_808DB7B(int a1);
int __cdecl sub_808DB8C(char *s1); // idb
int __cdecl sub_808DC0C(int a1);
int __cdecl sub_808DC4E(int a1, int a2);
int __cdecl sub_808DCCB(int a1, int a2);
int __cdecl sub_808DD48(int a1, float a2, int a3);
void __cdecl sub_808DD8C(int a1, float a2);
int __cdecl sub_808DDBC(int a1, int a2, int a3);
int *__cdecl sub_808DDEB(int a1, int a2);
int *__cdecl sub_808DE13(int a1, int a2);
int __cdecl sub_808DE3B(int a1);
int __cdecl sub_808DE5C(int, char *s); // idb
int __cdecl sub_808DE99(int a1);
int **__cdecl sub_808DEC2(int a1);
int __cdecl sub_808DEEB(int a1);
int __cdecl sub_808DF0C(int a1, int a2, int a3);
int __cdecl sub_808DF3B(int a1, int a2, int a3);
int __cdecl sub_808DF6A(int a1);
void sub_808E037();
_BOOL4 __cdecl sub_808E03C(char *s);
void *sub_808E08C();
int __cdecl sub_808E09E(int); // weak
void *sub_808FD11();
void SV_InitGameVM();
void __cdecl SV_RestartGameProgs();
void __cdecl sub_808FE88();
int sub_808FF1F();
char *__cdecl SV_SetConfigstring(int a1, char *s1);
char *__cdecl sub_8090144(int a1, char *dest, int a3);
const char *__cdecl sub_80901CE(int a1);
char *__cdecl sub_8090270(int a1, int a2, char *s1, char *a4);
char *__cdecl sub_809030B(int a1, char *src);
char *__cdecl sub_80903B5(int a1, char *dest, int a3);
int sub_8090437();
int *__cdecl sub_809057F(int a1);
int *sub_8090610();
int sub_8090700();
int *__cdecl CL_SetExpectedHunkUsage(int a1);
void *sub_8090ADA();
void *__cdecl sub_8090B36(int a1);
void SV_InitArchivedSnapshot();
int sub_8090BF2();
int SV_InitCvar();
int __cdecl SV_SpawnServer(char *s1); // idb
int *__cdecl sub_8091398(char *s1);
int *SV_Init();
int *__cdecl sub_8091963(const char *a1);
void __cdecl sub_8091A22(const char *a1);
_BYTE *__cdecl sub_8091AD8(_BYTE *a1);
int __cdecl sub_8091B66(_BYTE *a1, _BYTE *a2);
int __cdecl SV_CanReplaceServerCommand(int a1, char *a2);
int __cdecl SV_CullIgnorableServerCommands(int a1);
int __cdecl SV_AddServerCommand(int, int, char *s); // idb
int SV_SendServerCommand(int a1, int a2, char *format, ...);
int *SV_MasterAddress();
void __cdecl SV_MasterHeartbeat(const char *a1);
void sub_80923A2();
void sub_8092403();
int SV_GetClientScore();
void *__cdecl SVC_Status(int a1, int a2, int a3, int a4, int a5);
void *__cdecl SVC_GameCompleteStatus(int a1, int a2, int a3, int a4, int a5);
void *__cdecl SVC_Info(int a1, int a2, int a3, int a4, int a5);
void *__cdecl SV_FlushRedirect(char *s);
int __cdecl SVC_RemoteCommand(int a1, int a2, int a3, int a4, int a5);
void __cdecl SV_ConnectionlessPacket(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_80937FA();
int __cdecl sub_8093807(int, void *s); // idb
int __cdecl sub_8093934(int, char *s); // idb
int __cdecl sub_80939CF(size_t n, void *src, int); // idb
void __cdecl SV_ReadPackets(int a1, int a2, int a3, int a4, int a5, int a6);
int sub_8093D4C();
int __cdecl sub_8093E86(int a1);
int sub_8093EAC();
int sub_8093FD9();
int SV_RunFrame();
_DWORD *__cdecl sub_80940D2(_DWORD *a1);
int sub_809421B();
void __cdecl sub_80942A1(int a1);
int __cdecl sub_8094776(char a1);
int __cdecl sub_8094798(int a1, _BYTE *a2, int a3);
int __cdecl SV_Netchan_Decode(int a1, _BYTE *a2, int a3);
int *__cdecl SV_Netchan_TransmitNextFragment(int *a1);
int *__cdecl SV_Netchan_Transmit(int a1, void *src, size_t n);
int __cdecl SV_Netchan_AddOOBProfilePacket(int a1);
int sub_80949D3();
int __cdecl sub_8094A7F(int a1);
int __cdecl sub_809544C(int a1, int a2, int a3, int a4, _DWORD *a5);
_DWORD *__cdecl sub_80955C0(int a1, int a2, int a3, int a4, _DWORD *a5);
int __cdecl sub_809570C(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl SV_UpdateServerCommandsToClient(_DWORD *a1, _DWORD *a2);
int __cdecl sub_8095A5A(_DWORD *a1, _DWORD *a2, signed int a3);
int __cdecl sub_8095B2D(int a1);
_DWORD *__cdecl sub_8095BE4(int a1, _DWORD *a2);
_DWORD *__cdecl sub_8095C0A(int a1, _DWORD *a2);
int __cdecl sub_8095C30(float *a1, int a2, _DWORD *a3);
int sub_8095F4C();
int __cdecl sub_8095F70(int a1, int a2, float *a3, int a4, _DWORD *a5, int a6);
int sub_8096273();
int sub_8096297();
int *__cdecl sub_80962C2(int a1);
int *__cdecl sub_8096D9E(int *a1);
int sub_8096EBE();
int __cdecl sub_8096EE9(int a1, int a2, void *a3);
int __cdecl sub_8096F65(int a1, int *a2, int a3, void *a4);
char *__cdecl sub_80972D8(char *a1);
int __cdecl sub_80979AB(int a1, int a2);
size_t __cdecl SV_SendMessageToClient(int a1, int a2);
size_t __cdecl SV_SendClientSnapshot(int a1);
void sub_8097E1C();
int SV_SendClientMessages();
int __cdecl sub_8098CA8(int *a1);
int __cdecl sub_8098D51(int *a1);
void __cdecl sub_8098D7F(int a1);
int __cdecl sub_8098DF6(_DWORD *a1);
int __cdecl sub_809959C(int a1, int a2);
int __cdecl sub_8099732(int a1, int a2);
int __cdecl sub_8099C75(int *a1, int a2);
int __cdecl sub_8099E26(_DWORD *a1, int a2);
int __cdecl sub_8099FD1(void *a1, int a2, int *a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
int *__cdecl sub_809A4F9(int *a1, int *a2, int *a3, int *a4, int *a5, int a6, int a7, int a8, int a9);
int __cdecl sub_809A8CD(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7);
int __cdecl sub_809AB1F(float *a1, int a2, int a3);
int __cdecl sub_809AC27(float); // idb
void *VM_Init();
int __cdecl sub_809AC7C(char a1);
int __cdecl sub_809ACE3(char *src, int); // idb
void *__cdecl sub_809AEF5(void *s);
int *sub_809AF33();
int __cdecl VM_Call(int, int);
int __cdecl sub_809B048(int a1);
void __cdecl __noreturn sub_809B056(const char *a1);
int sub_809B08E();
int __cdecl sub_809B142(int *a1, unsigned __int16 a2, unsigned __int16 a3, int a4);
int __cdecl sub_809B1FC(int *a1, unsigned __int16 a2, int a3);
int __cdecl sub_809B250(unsigned __int16 a1, unsigned __int16 a2, char a3, char a4, char a5);
_DWORD *__cdecl sub_809B614(int a1, unsigned __int16 a2, unsigned __int16 a3);
void *__cdecl sub_809B684(size_t n);
int __cdecl sub_809B6A0(unsigned __int16 a1);
int __cdecl sub_809B740(unsigned __int16 a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5);
int __cdecl sub_809B812(int a1);
int __cdecl sub_809B866(int a1);
int __cdecl sub_809B87E(unsigned __int16 a1, unsigned __int16 a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, int a8);
int __cdecl Scr_CheckAnimsDefined(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_809BC10(unsigned __int16 a1);
int __cdecl sub_809BCAA(char *a1, int *a2);
int __cdecl sub_809BDF0(char *a1, int a2);
_BOOL4 __cdecl sub_809BE36(const char *a1, unsigned __int16 a2, unsigned __int16 a3);
int __cdecl sub_809BF04(int a1, int (__cdecl *a2)(int));
// _DWORD *__userpurge sub_809C1E6@<eax>(_DWORD *a1, char *a2);
int __cdecl sub_809C298(char *a1, char *s, int *a3);
int __cdecl sub_809C300(int a1);
_DWORD *__cdecl sub_809C326(unsigned __int16 a1);
int __cdecl sub_809C3E8(unsigned __int16 a1, unsigned __int8 a2);
int __cdecl sub_809C43E(unsigned __int8 a1, int a2, int a3);
int sub_809C4F6();
int __cdecl sub_809C51A(int a1);
int __cdecl sub_809C53E(unsigned __int16 a1);
int __cdecl sub_809C56C(unsigned __int8 a1);
int __cdecl sub_809C598(int a1);
int __cdecl sub_809C5BC(unsigned __int16 a1);
int sub_809C5EA();
int __cdecl sub_809C60E(int a1);
int __cdecl sub_809C632(int a1);
int __cdecl sub_809C656(int a1);
int sub_809C67A();
int __cdecl sub_809C69E(int a1);
int __cdecl sub_809C6CE(int a1);
int sub_809C6FE();
int sub_809C72E();
int __cdecl sub_809C75E(int a1);
void __cdecl sub_809C7AE(int a1);
_DWORD *__cdecl sub_809C7DE(unsigned __int16 a1, int a2);
_DWORD *__cdecl sub_809C81A(unsigned __int16 a1, int a2);
int __cdecl sub_809C856(unsigned __int16 a1);
int __cdecl sub_809C8A2(unsigned __int16 a1);
void __cdecl sub_809C8EE(int a1);
void __cdecl sub_809C91E(int a1);
void __cdecl sub_809C94E(int a1);
void __cdecl sub_809C97E(int a1);
void __cdecl sub_809C9AE(int a1);
void __cdecl sub_809C9DE(int a1);
void __cdecl sub_809CA0E(int a1, int a2);
int sub_809CA48();
int sub_809CA6C();
int sub_809CA90();
int sub_809CAB4();
int sub_809CAD8();
int sub_809CAFC();
int sub_809CB20();
_DWORD *__cdecl sub_809CB44(unsigned __int16 a1);
_DWORD *__cdecl sub_809CB74(unsigned __int16 a1);
int sub_809CBA4();
_DWORD *__cdecl sub_809CBC8(unsigned __int16 a1);
void __cdecl sub_809CBF8(int a1, int a2);
void __cdecl sub_809CC32(int a1, int a2);
void __cdecl sub_809CC6C(int a1, int a2);
int sub_809CCA6();
int __cdecl sub_809CCCA(unsigned __int16 a1, int a2);
_DWORD *__cdecl sub_809CD2E(_DWORD *a1, unsigned __int16 a2, int a3);
_DWORD *__cdecl sub_809CD7C(_DWORD *a1, unsigned __int16 a2, int a3);
_DWORD *__cdecl sub_809CDBE(_DWORD *a1, unsigned __int16 a2, int a3, int a4);
int __cdecl sub_809CE0C(int a1, int a2);
int __cdecl sub_809CE4A(int a1, int a2, int a3, int a4);
int sub_809CE96();
void __cdecl sub_809CEBA(int a1);
void __cdecl sub_809CEEA(_DWORD *a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809CF1A(int a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809CF52(int a1, _DWORD *a2, int a3, int a4);
void __cdecl sub_809CF8A(int a1);
int __cdecl sub_809D026(int *a1);
int __cdecl sub_809D06A(int a1);
_DWORD *__cdecl sub_809D0A6(_DWORD *a1);
int __cdecl sub_809D0E8(unsigned __int16 a1, int a2);
void __cdecl sub_809D148(int a1, int a2);
void __cdecl sub_809D462(int a1, int a2);
int __cdecl sub_809D498(int a1, int a2, char a3, int a4);
int __cdecl sub_809D50A(int a1, int a2, char a3, int a4, int a5);
int __cdecl sub_809D58C(int a1, int a2, char a3, int a4);
int __cdecl sub_809D5FC(int a1, int a2, char a3, int a4);
int __cdecl sub_809D66E(int *a1, int a2, char a3, int a4);
void __cdecl sub_809D6EC(_DWORD *a1, int a2, char a3, int a4, int a5);
int __cdecl sub_809D76E(_DWORD *a1);
void __cdecl sub_809D79A(int a1, int a2, char a3);
int __cdecl sub_809D822(_DWORD *a1);
_DWORD *__cdecl sub_809D8AC(int a1, int a2, char a3);
_DWORD *__cdecl sub_809DAE8(int a1, int a2, int a3, int a4, char a5);
int sub_809DD52();
int __cdecl sub_809DECC(unsigned __int16 a1, int a2);
int __cdecl sub_809DF42(int a1, int a2);
int __cdecl sub_809DFC4(unsigned __int16 a1);
int __cdecl sub_809E008(unsigned __int16 a1);
_DWORD *__cdecl sub_809E05E(_DWORD *a1, char a2);
int __cdecl sub_809E0E4(int *a1);
void __cdecl sub_809E160(_DWORD *a1);
_DWORD *__cdecl sub_809E204(_DWORD *a1, int a2);
int __cdecl sub_809E26A(int *a1, int a2);
int __cdecl sub_809E312(int a1, int a2);
void __cdecl sub_809E36C(_DWORD *a1);
int __cdecl sub_809E51E(int a1, int a2, int a3, int a4);
int __cdecl sub_809E59E(int a1, int a2, int a3, int a4);
void __cdecl sub_809E61E(int a1, int a2, unsigned __int8 a3, int a4);
void __cdecl sub_809E664(int a1, _DWORD *a2, unsigned __int8 a3, int a4);
void __cdecl sub_809E6CE(_DWORD *a1);
void __cdecl sub_809E888(int a1);
int __cdecl sub_809E924(int a1, int a2);
int __cdecl sub_809E9B8(_DWORD *a1, int a2);
void __cdecl sub_809EA08(_DWORD *a1, int a2);
int __cdecl sub_809EAAE(_DWORD *a1, int a2);
int sub_809EAFE();
int sub_809EB42();
_BOOL4 __cdecl sub_809EB8A(_DWORD *a1);
_BOOL4 __cdecl sub_809EB9C(int a1);
void __cdecl sub_809EBCE(int a1);
void __cdecl sub_809EC7A(int a1, _DWORD *a2, int a3);
_DWORD *__cdecl sub_809ECC0(_DWORD *a1);
int __cdecl sub_809ECDC(_DWORD *a1);
int sub_809ED0C();
void __cdecl sub_809ED30(_DWORD *a1, int a2, int a3);
int __cdecl sub_809ED92(_DWORD *a1, int a2, int a3);
int __cdecl sub_809EE0C(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_809EED6(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_809F090(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_809F1E2(int a1, int a2, int a3, int a4, int a5, int a6);
void __cdecl sub_809F3CE(int a1, int a2);
void __cdecl sub_809F414(int a1, int a2);
int __cdecl sub_809F45A(int a1);
int __cdecl sub_809F496(int a1);
int __cdecl sub_809F4D2(_DWORD *a1, int a2, int a3, int a4);
int __cdecl sub_809F588(_DWORD *a1, int a2, int a3, int a4);
void __cdecl sub_809F6A8(_DWORD *a1, int *a2, int a3, int a4);
void __cdecl sub_809F764(_DWORD *a1, _DWORD *a2, int a3, int a4);
int sub_809F7B4(const void *, const void *); // idb
int __cdecl sub_809F7F0(_DWORD *a1, int a2, int a3);
void __cdecl sub_809FA48(int a1, int a2);
void __cdecl sub_809FAC8(_DWORD *a1, int a2);
void __cdecl sub_809FBDA(int a1);
_DWORD *__cdecl sub_809FC14(int a1);
_DWORD *__cdecl sub_809FCB6(int a1);
void __cdecl sub_809FD58(_DWORD *a1);
int __cdecl sub_80A0148(int a1);
int sub_80A0180();
int sub_80A01F4();
int __cdecl sub_80A0306(int a1, int a2);
void sub_80A03CA();
void sub_80A0456();
int sub_80A051A();
void __cdecl sub_80A056E(int *a1, int a2);
int __cdecl sub_80A05AA(int a1);
int __cdecl sub_80A0646(int a1, int a2);
int __cdecl sub_80A06FC(int a1, int a2);
int __cdecl sub_80A0754(int a1, int a2);
int __cdecl sub_80A0836(int a1, int a2);
int __cdecl sub_80A08C2(int a1);
int __cdecl sub_80A093A(int a1, __int16 a2);
int __cdecl Scr_GetCustomFunction(int a1, int a2);
int __cdecl sub_80A0AD0(int a1, int a2);
int __cdecl sub_80A0AEC(int a1, int a2, int a3);
int __cdecl sub_80A0B0F(int a1, int a2, int a3);
int __cdecl sub_80A0B32(int a1);
int *__cdecl sub_80A0B47(int a1);
int __cdecl sub_80A0F58(unsigned int a1);
int __cdecl sub_80A0F8C(unsigned int a1);
int __cdecl sub_80A0FEC(_BYTE *a1);
int __cdecl sub_80A103A(int, char *s); // idb
void *sub_80A1122();
_DWORD *sub_80A114A();
int __cdecl sub_80A1158(unsigned __int16 a1);
int __cdecl sub_80A11D2(char *s); // idb
int sub_80A11F4();
int sub_80A125C();
_BOOL4 __cdecl sub_80A12A2(char *a1);
unsigned int *sub_80A1436();
int __cdecl sub_80A14AA(int (__cdecl *a1)(int));
void *sub_80A14E6();
int sub_80A1552();
int __cdecl sub_80A15C4(int a1);
int sub_80A161C();
int *sub_80A1710();
int __cdecl sub_80A17D2(int a1);
int __cdecl sub_80A1846(int a1, int a2);
int __cdecl sub_80A19AA(int a1, int a2);
int __cdecl sub_80A1B84(int a1);
int *sub_80A1CCC();
int __cdecl sub_80A1D7A(const char *a1, int a2);
int __cdecl sub_80A1DAA(int a1);
int __cdecl sub_80A1E2A(int a1);
int __cdecl sub_80A1EE2(unsigned __int16 a1, int a2);
int __cdecl sub_80A1F70(int a1);
int __cdecl sub_80A1F96(int a1, int a2);
_BOOL4 __cdecl sub_80A1FBC(int a1, int a2);
void sub_80A1FEC();
int *sub_80A20F2();
void __cdecl sub_80A222E(int a1);
int __cdecl sub_80A2460(unsigned int a1, int a2);
int sub_80A2548();
unsigned int __cdecl sub_80A2552(void (__cdecl *a1)(int *, int));
int *__cdecl sub_80A2612(void (__cdecl *a1)(int *, int));
int *__cdecl sub_80A2714(void (__cdecl *a1)(int *, int));
char *sub_80A2772();
char *__cdecl sub_80A280E(char *s, int a2, int a3);
int __cdecl sub_80A2AB2(int a1, const char *a2, char *a3, int a4);
int __cdecl sub_80A2C3C(int a1, unsigned int a2, int a3);
void __noreturn sub_80A2D58(int a1, char *format, ...);
void __noreturn CompileError2(unsigned int a1, char *format, ...);
void __cdecl sub_80A2EB0(int a1, unsigned int a2, int a3, const char *a4);
void __cdecl sub_80A2F52(unsigned int a1, int a2, const char *a3, void *a4);
// _DWORD *__userpurge sub_80A3038@<eax>(_DWORD *a1, int a2);
// _DWORD *__userpurge sub_80A304A@<eax>(_DWORD *a1, int a2);
// int *__userpurge sub_80A305C@<eax>(int *a1, int a2);
// int __userpurge sub_80A3086@<eax>(int a1, int a2, int a3);
// int __userpurge sub_80A30BA@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_80A30F8@<eax>(int a1, int a2, int a3);
// int __userpurge sub_80A312C@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80A3174@<eax>(int a1, int a2, int a3, int a4);
// int __userpurge sub_80A31B2@<eax>(int a1, int a2, int a3, int a4, int a5, int a6);
// int __userpurge sub_80A3204@<eax>(int a1, int a2, int a3, int a4, int a5);
// int __userpurge sub_80A324C@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// int __userpurge sub_80A32A8@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_80A330E@<eax>(int a1, int a2);
// _DWORD *__userpurge sub_80A3364@<eax>(_DWORD *a1, int a2, _DWORD *a3);
// _DWORD *__userpurge sub_80A33AA@<eax>(_DWORD *a1, int a2, int a3);
int __cdecl sub_80A3438(unsigned __int16 a1);
int __cdecl sub_80A3454(int a1);
int __cdecl SL_ConvertToString(unsigned __int16 a1);
int __cdecl sub_80A3496(int a1);
int __cdecl sub_80A34C6(char *a1, unsigned int a2);
int sub_80A357A();
int __cdecl sub_80A3604(void *s2, size_t n); // idb
int __cdecl sub_80A37F0(char *s); // idb
int __cdecl sub_80A3816(char *s); // idb
int __cdecl sub_80A388C(void *s2, int a2, size_t n);
int __cdecl sub_80A3D64(char *s, int a2);
int __cdecl sub_80A3DA2(char *s, int); // idb
int __cdecl sub_80A3DCE(int, int, size_t n, int); // idb
int __cdecl sub_80A3E4A(char *s, int, int); // idb
int __cdecl sub_80A3E88(char *s, int); // idb
int __cdecl sub_80A3EB4(unsigned __int16 a1, unsigned __int8 a2);
int __cdecl sub_80A3F08(unsigned __int16 a1);
int __cdecl sub_80A3F34(unsigned __int16 a1, char *a2, unsigned int a3);
int __cdecl sub_80A40A6(unsigned __int16 a1);
int __cdecl sub_80A4106(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A415A(unsigned __int16 *a1, unsigned __int16 a2);
int __cdecl sub_80A419E(char *s); // idb
int __cdecl sub_80A41BC(float); // idb
int __cdecl sub_80A4206(int a1);
int __cdecl sub_80A4250(float *a1);
unsigned int *__cdecl sub_80A42B4(unsigned int *a1);
_BYTE *__cdecl sub_80A4360(_BYTE *a1, char *a2, int a3);
int __cdecl sub_80A4404(char *a1);
void sub_80A4450();
int __cdecl sub_80A4460(int a1);
int __cdecl sub_80A4494(int a1);
int sub_80A44C8(const void *, const void *); // idb
int Scr_DumpScriptThreads();
void sub_80A49CA();
int sub_80A49D0();
int sub_80A4A9E();
int __cdecl sub_80A4AD0(unsigned __int16 a1);
unsigned int __cdecl sub_80A4AF8(unsigned __int16 a1);
int __cdecl sub_80A4B2C(unsigned __int16 a1, int a2);
int __cdecl sub_80A4C6A(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A5160(__int16 *a1, int a2);
int __cdecl sub_80A53C2(unsigned __int16 a1);
int __cdecl sub_80A54B8(unsigned __int16 a1);
int __cdecl sub_80A54EC(unsigned __int16 a1);
int __cdecl sub_80A5514(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A556C(unsigned __int16 a1);
int __cdecl sub_80A55C2(unsigned __int16 a1);
int *sub_80A586C();
int __cdecl sub_80A591C(unsigned __int16 a1);
int sub_80A5A02();
int sub_80A5A30();
int __cdecl sub_80A5A66(int a1, __int16 a2);
int sub_80A5AB4();
int __cdecl sub_80A5AF4(__int16 a1);
int __cdecl sub_80A5B3C(unsigned __int16 a1);
int __cdecl sub_80A5B60(int *a1);
int __cdecl sub_80A5B9E(unsigned __int16 a1);
int __cdecl sub_80A5BCE(unsigned __int16 a1);
int __cdecl sub_80A5C0A(unsigned __int16 a1);
_WORD *sub_80A5C64();
_DWORD *__cdecl sub_80A5C94(_DWORD *a1);
int __cdecl sub_80A5CD2(int a1);
int __cdecl sub_80A5D00(int a1);
int __cdecl sub_80A5D56(int a1, int a2);
int __cdecl sub_80A5DA8(int a1, int a2);
_BOOL4 __cdecl sub_80A5DFA(int a1);
int __cdecl sub_80A5E20(int a1);
int __cdecl sub_80A5E32(unsigned __int16 a1, int a2);
int __cdecl sub_80A5E62(unsigned __int16 a1, int a2);
int __cdecl sub_80A5E90(unsigned __int16 a1, int a2);
int __cdecl sub_80A5EBE(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A5EF8(unsigned __int16 a1, int a2);
int __cdecl sub_80A5F28(unsigned __int16 a1, unsigned __int16 a2);
unsigned int __cdecl sub_80A60BE(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6184(unsigned __int16 a1, int a2);
int __cdecl sub_80A61B2(unsigned __int16 a1, int a2);
int __cdecl sub_80A61E0(unsigned __int16 a1, unsigned int a2);
int __cdecl sub_80A620E(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6248(unsigned __int16 a1, int a2);
int __cdecl sub_80A62D2(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6302(unsigned __int16 a1, int a2);
int __cdecl sub_80A632E(unsigned __int16 a1, int a2);
int __cdecl sub_80A635A(unsigned __int16 a1, int a2);
int __cdecl sub_80A63EE(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A6598(unsigned __int16 a1, int *a2);
int __cdecl sub_80A6608(unsigned __int16 a1, int *a2);
int *__cdecl GetVariableValueAddress(unsigned __int16 a1);
int __cdecl sub_80A667C(unsigned __int16 a1);
int __cdecl sub_80A66D0(unsigned __int16 a1, int *a2);
int __cdecl sub_80A67A2(unsigned __int16 a1, int *a2);
int __cdecl sub_80A67E6(unsigned __int16 a1, unsigned __int16 *a2);
int __cdecl sub_80A691A(unsigned __int16 *a1);
int __cdecl sub_80A6A06(unsigned __int16 a1);
int __cdecl FindNextSibling(unsigned __int16 a1);
unsigned int __cdecl GetVariableName(unsigned __int16 a1);
int __cdecl sub_80A6AD2(unsigned __int16 a1);
int __cdecl sub_80A6B2E(unsigned __int16 a1);
int __cdecl sub_80A6B8A(unsigned __int16 a1);
_BOOL4 __cdecl sub_80A6BBA(unsigned __int16 a1);
_BOOL4 __cdecl sub_80A6C00(unsigned __int16 a1);
int __cdecl sub_80A6C46(unsigned __int16 *a1);
int __cdecl sub_80A6D12(unsigned __int16 a1);
void __cdecl sub_80A6D38(int a1, int a2);
unsigned int __cdecl sub_80A6E22(int a1, unsigned int a2);
unsigned int sub_80A6EAC();
int __cdecl sub_80A6F06(int, char *s, int); // idb
int __cdecl sub_80A7014(unsigned __int16 a1, int a2);
int __cdecl sub_80A7074(int a1, int a2);
int __cdecl sub_80A70F0(int a1, int a2);
int __cdecl sub_80A71BC(int *a1, unsigned __int16 *a2);
int __cdecl sub_80A750E(unsigned __int16 a1, unsigned __int16 *a2);
int __cdecl sub_80A772E(unsigned __int16 a1, int *a2);
int __cdecl sub_80A79C6(unsigned __int16 a1, int *a2);
int __cdecl sub_80A7BCC(int a1);
int __cdecl sub_80A7BEE(unsigned __int16 a1);
int __cdecl sub_80A7C38(unsigned __int16 a1);
int __cdecl sub_80A7C5C(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80A7D62(int a1, int a2, int a3);
int __cdecl sub_80A7DC0(unsigned __int8 a1);
int sub_80A7DE2();
int __cdecl sub_80A7E00(unsigned __int16 a1);
int sub_80A7E24();
char *__cdecl sub_80A7E44(unsigned __int16 a1);
char *__cdecl sub_80A7E88(unsigned __int16 a1);
int sub_80A7EC4();
int sub_80A7F12();
int __cdecl sub_80A7F3A(int a1);
long double sub_80A7F56();
int __cdecl sub_80A7F78(int *a1);
_DWORD *sub_80A7FAE();
int __cdecl sub_80A7FDA(int a1);
int sub_80A7FF6();
int __cdecl sub_80A8012(int a1);
int sub_80A8042();
int __cdecl sub_80A8078(unsigned __int16 a1);
int sub_80A80A0();
void *__cdecl sub_80A80D0(void *src, size_t n);
size_t __cdecl sub_80A80FC(void *dest, size_t n);
int __cdecl sub_80A8128(unsigned __int16 a1);
int __cdecl sub_80A816A(unsigned __int16 a1);
int __cdecl sub_80A81B4(int a1);
int sub_80A824A();
int __cdecl sub_80A82F4(int a1);
int __cdecl sub_80A8362(unsigned __int8 a1, int a2);
int __cdecl sub_80A839E(int a1);
long double __cdecl sub_80A83C4(char a1, unsigned __int16 a2);
long double __cdecl sub_80A8434(int a1);
char *__cdecl sub_80A845E(unsigned __int8 a1, int *a2);
char *__cdecl sub_80A84FE(int a1, unsigned int a2, char a3);
void __cdecl sub_80A85AC(int a1);
int __cdecl sub_80A8646(int a1);
void *__cdecl sub_80A86C6(unsigned __int16 a1);
long double __cdecl sub_80A87FA(unsigned __int16 a1);
long double __cdecl sub_80A886A(unsigned __int16 a1);
long double __cdecl sub_80A88F8(int a1, float *a2);
int __cdecl sub_80A89F0(unsigned __int16 a1);
int __cdecl sub_80A8B76(unsigned __int16 a1);
int sub_80A8D0E();
char *sub_80A8E30();
int sub_80A8E76();
unsigned int sub_80A8EE8();
int sub_80A8FC8();
unsigned int sub_80A8FD6();
int sub_80A914C();
int __cdecl sub_80A91A2(char *s1, int); // idb
int __cdecl sub_80A922A(char *src); // idb
int __cdecl sub_80A94A2(char *, char *); // idb
int __cdecl sub_80A9560(unsigned __int16 a1);
int __cdecl sub_80A957C(unsigned __int16 a1);
void sub_80A9680();
int __cdecl sub_80A96AE(int a1);
int __cdecl sub_80A9702(_DWORD *a1);
int __cdecl sub_80A9734(int *a1);
int __cdecl sub_80A9754(int *a1);
int sub_80A9774();
int __cdecl sub_80A9820(int a1, int a2, int a3);
void sub_80A987A();
void sub_80A9892();
void sub_80A98A8();
int sub_80A98AE();
_BOOL4 __cdecl sub_80A98D8(char *a1);
int __cdecl sub_80A9956(float *a1);
int __cdecl sub_80A9A98(int a1);
int __cdecl CastFloat(unsigned __int16 *a1);
int __cdecl sub_80A9D32(int *a1);
int __cdecl sub_80A9E36(int *a1);
int __cdecl sub_80A9E92(int *a1);
int __cdecl sub_80A9EEE(int *a1);
_DWORD *__cdecl sub_80A9F4A(_DWORD *a1);
int __cdecl sub_80A9FCA(int a1);
int *__cdecl sub_80AA004(int *a1, int *a2);
int __cdecl sub_80AA068(int a1, int a2);
int __cdecl sub_80AA2C4(int a1, unsigned __int16 *a2);
int __cdecl sub_80AA520(unsigned __int16 *a1, _DWORD *a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 *a5);
int __cdecl sub_80AD008(int a1, int a2, __int16 a3, unsigned __int16 a4, int a5, int a6);
int __cdecl sub_80AD0FC(unsigned __int16 a1, int a2);
int __cdecl sub_80AD206(unsigned __int16 a1);
int __cdecl sub_80AD26C(unsigned __int16 a1, unsigned __int16 a2);
int __cdecl sub_80AD340(unsigned __int16 a1);
int __cdecl sub_80AD504(unsigned __int16 a1, unsigned __int16 a2, int *a3);
int __cdecl sub_80ADAA0(unsigned __int16 a1, unsigned __int16 a2, int a3);
int __cdecl sub_80ADB6C(int a1, int a2, unsigned __int16 a3, int a4);
int __cdecl sub_80ADC4E(unsigned __int16 a1);
int __cdecl sub_80ADCFE(unsigned __int16 a1);
int __cdecl sub_80ADD7C(unsigned __int16 a1);
int sub_80ADFBA();
int __cdecl sub_80AE018(__int16 a1, _DWORD *a2, int a3);
int __cdecl sub_80AE1A8(int a1, int a2);
int __cdecl sub_80AE226(int a1, int a2, int a3, int a4);
int __cdecl sub_80AE2B2(int a1, int a2);
int __cdecl sub_80AE30C(int a1, int a2, int a3, int a4);
int __cdecl sub_80AE374(unsigned __int16 a1);
void sub_80AE390();
int __cdecl sub_80AE3F8(int a1, int a2);
int sub_80AE43A();
_BOOL4 sub_80AE58A();
int __cdecl Scr_GetPointerType(unsigned int a1);
int __cdecl sub_80AE67C(unsigned int a1);
// unsigned __int16 *__userpurge sub_80AE718@<eax>(unsigned __int16 *a1, unsigned int a2, int a3);
// _DWORD *__userpurge sub_80AE8D2@<eax>(_DWORD *a1, unsigned int a2);
long double __cdecl sub_80AEA28(unsigned int a1);
int __cdecl sub_80AEAC2(unsigned int a1);
int __cdecl sub_80AEB60(unsigned int a1);
const char *__cdecl sub_80AEBA4(unsigned int a1);
int __cdecl sub_80AED26(unsigned int a1);
int __cdecl sub_80AEDC4(unsigned int a1);
int __cdecl sub_80AEE08(unsigned int a1, _DWORD *a2);
int __cdecl sub_80AEEE2(unsigned int a1);
int __cdecl sub_80AEF8A(unsigned int a1, unsigned int *a2);
int __cdecl sub_80AF086(unsigned int a1);
int __cdecl sub_80AF0F8(unsigned int a1);
int sub_80AF1AE();
int __cdecl sub_80AF1B8(int a1);
int __cdecl sub_80AF1DC(int a1);
int __cdecl sub_80AF200(int a1);
int __cdecl sub_80AF224(int a1);
int sub_80AF248();
int __cdecl sub_80AF262(unsigned __int16 a1);
int __cdecl sub_80AF29C(int a1, int a2);
int sub_80AF2C2();
int __cdecl sub_80AF2EC(char *s); // idb
int __cdecl sub_80AF326(char *s); // idb
int __cdecl sub_80AF360(unsigned __int16 a1);
_DWORD *__cdecl sub_80AF39A(_DWORD *a1);
int sub_80AF3CC();
int sub_80AF3F8();
int __cdecl sub_80AF44E(unsigned __int16 a1);
int __cdecl Scr_Error(int a1);
int __cdecl sub_80AF4D4(int a1, int a2);
int __cdecl sub_80AF512(int a1);
int __cdecl sub_80AF556(int a1, int a2);
int __cdecl sub_80AF592(int a1);
int __cdecl sub_80AF5D0(int a1, int a2, int a3, int a4);
int __cdecl sub_80AF62A(int a1, int a2, int a3, int a4);
int __cdecl sub_80AF66A(int a1, int a2, unsigned __int16 a3);
int __cdecl sub_80AF6CE(int a1);
void sub_80AF716();
unsigned __int64 sub_80AF724();
int __cdecl sub_80AF736(unsigned __int16 *a1);
int __cdecl sub_80AF7E4(float); // idb
long double __cdecl sub_80AF812(float a1);
unsigned __int64 sub_80AF82C();
int __cdecl sub_80AF848(int a1);
int __cdecl sub_80AF868(int a1, int a2);
int __cdecl sub_80AF899(_BYTE *a1, int a2);
int __cdecl sub_80AF98E(char *s); // idb
int __cdecl sub_80AF9B1(char *s); // idb
int sub_80AF9D4();
int sub_80B0DC4();
int sub_80B109A();
int __cdecl sub_80B1172(int a1);
int sub_80B122E();
int __cdecl sub_80B132F(FILE *stream); // idb
int __cdecl sub_80B1373(int a1);
int sub_80B13D2();
_DWORD *__cdecl sub_80B140F(FILE *stream, int a2);
_BOOL4 __cdecl sub_80B14D8(int a1, FILE *stream);
int __cdecl sub_80B153E(int a1);
_DWORD *__cdecl sub_80B159B(int a1, unsigned int a2);
_DWORD *__cdecl sub_80B169D(int a1, int a2);
void __cdecl __noreturn sub_80B1742(const char *a1);
void *__cdecl sub_80B1770(size_t size);
void *__cdecl sub_80B1783(void *ptr, size_t size);
void __cdecl sub_80B179D(void *ptr);
int sub_80B17B0();
int __cdecl sub_80B17FE(int a1, _DWORD *a2);
int sub_80B1884();
int sub_80B188E();
int __cdecl sub_80B4A60(int a1, unsigned __int8 *a2, unsigned int a3);
int __cdecl sub_80B4CAC(int a1, int *a2, int a3, int a4, int a5);
int __cdecl sub_80B4DCA(int a1, _BYTE *a2, unsigned int a3);
int __cdecl sub_80B4F44(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80B4F8C(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8);
int __cdecl sub_80B548A(_DWORD *a1);
int __cdecl sub_80B56C0(int a1, __int16 a2);
size_t __cdecl sub_80B56F9(int a1);
int __cdecl sub_80B57C7(int a1, int a2);
int __cdecl sub_80B5BB0(int a1);
unsigned int __cdecl sub_80B5FC8(int a1, void *dest, int a3);
int __cdecl sub_80B607C(int a1);
int __cdecl sub_80B6189(_DWORD *a1, unsigned int a2);
int __cdecl sub_80B6413(int a1);
int __cdecl sub_80B6664(int *a1, int a2);
int __cdecl sub_80B7608(int a1, int a2, _DWORD *a3);
_DWORD *__cdecl sub_80B76D8(int a1, int a2, int a3);
int __cdecl sub_80B781A(int a1, int a2, int a3);
int __cdecl sub_80B8C61(int a1, int a2);
int __cdecl sub_80B8CD6(int, void *src, size_t n); // idb
_BOOL4 __cdecl sub_80B8D17(_DWORD *a1);
int __cdecl sub_80B8D28(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_80B8D8D(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl sub_80B9AFA(int a1, int a2);
int __cdecl sub_80B9B1C(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6);
int __cdecl sub_80BA21C(_DWORD *a1);
int __cdecl sub_80BA2B1(_DWORD *a1);
int __cdecl sub_80BA32D(_DWORD *a1, int a2, _BYTE *a3, int a4);
int __cdecl sub_80BA4C4(_DWORD *a1, _BYTE *a2, int a3);
int __cdecl sub_80BA4ED(unsigned __int8 **a1, int a2);
int __cdecl sub_80BAD10(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10);
int __cdecl sub_80BB535(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5);
int __cdecl sub_80BB61E(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9);
int __cdecl sub_80BB801(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80BB834(int a1, _DWORD *a2, int a3);
void sub_80BBA28();
int __cdecl sub_80BBA2D(int a1);
int __cdecl sub_80BBAC5(int a1);
int __cdecl sub_80BBB82(int a1, int a2, int a3);
int *__cdecl sub_80BBD44(_DWORD *a1, int a2);
int __cdecl sub_80BC080(int a1, int a2, int a3);
int __cdecl sub_80BC136(_DWORD *a1, int a2);
int __cdecl sub_80BC4D5(_WORD *a1, int a2, int a3);
int __cdecl sub_80BC668(int a1, int a2, int a3);
int __cdecl sub_80BD02E(int a1);
int __cdecl sub_80BD0ED(int a1, int a2, int a3, int a4);
int *__cdecl sub_80BD591(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80BD6BF(int a1);
int __cdecl sub_80BDB2D(int a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80BE037(int a1, int a2, int a3);
bool __cdecl sub_80BE7E2(int a1);
unsigned int __cdecl sub_80BE87C(unsigned int a1, int a2);
int __cdecl sub_80BE8AA(int a1);
int __cdecl sub_80BE96D(int a1);
int *__cdecl sub_80BEA04(_DWORD *a1, _BYTE *a2, int a3, int a4);
int __cdecl sub_80BEBB4(FILE *stream, int); // idb
int __cdecl sub_80BEBFA(FILE *stream, int); // idb
int __cdecl sub_80BEC3E(char *a1, char *a2);
int __cdecl sub_80BECE1(char *s1, char *s2, int); // idb
size_t __cdecl sub_80BED2B(FILE *stream);
_DWORD *__cdecl sub_80BEEC9(char *filename, void *src);
int *__cdecl sub_80BEF3A(char *filename);
int __cdecl sub_80BF21F(int a1);
int __cdecl sub_80BF272(int a1, _DWORD *a2);
int __cdecl sub_80BF2AA(int a1, int *a2);
int __cdecl sub_80BF31E(int, int, int, void *ptr, int, void *, int, void *, int); // idb
int __cdecl sub_80BF7F2(int, int, void *ptr, int, void *, int, void *, int); // idb
int __cdecl sub_80BF83E(_DWORD *a1);
int __cdecl sub_80BF8E6(_DWORD *a1);
int __cdecl sub_80BF9D4(int a1, _DWORD *a2);
int __cdecl sub_80BFA06(int a1, int a2);
int __cdecl sub_80BFBC7(int a1, _DWORD *a2, _DWORD *a3, int *a4);
int __cdecl sub_80BFE6F(_DWORD *a1);
int __cdecl sub_80C007B(int a1, int a2, unsigned int a3);
int __cdecl sub_80C03B7(int a1);
int __cdecl sub_80C0539(int a1);
int __cdecl sub_80C06B7(__int16 a1);
int __cdecl sub_80C06CA(int a1);
void *__cdecl sub_80C06F2(int a1, int a2, int a3);
int __cdecl sub_80C0709(int, void *ptr); // idb
int __cdecl sub_80C071C(_DWORD *a1, _DWORD *a2);
unsigned int *__cdecl sub_80C14C6(_DWORD *a1, _BYTE *a2, unsigned int a3);
int __cdecl PbSvAddEvent(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_80C1784(int a1, char *s, char *src);
int *sub_80C182C();
int sub_80C187A();
int PbServerForceProcess();
int __cdecl sub_80C18B2(int a1, int a2);
int __cdecl PbPassConnectString(int a1, int a2);
int __cdecl sub_80C191C(int a1, int a2, int a3);
int sub_80C1960();
int sub_80C199C();
int sub_80C19D8();
void __cdecl sub_80C1A14(char *s, int a2);
int __cdecl sub_80C1A8C(char *s1, char *nptr); // idb
const char *__cdecl sub_80C1C22(int a1, char *nptr);
int sub_80C1D0C();
int __cdecl sub_80C1D6A(size_t n, void *src, int); // idb
int __cdecl sub_80C1D90(char *cp, unsigned __int16 a2, size_t n, void *buf);
int __cdecl sub_80C1DC6(int a1, int a2);
int ctor_001();
int dtor_001();
char *__cdecl sub_80C1E3C(int a1, char *dest, int a3);
_DWORD *__cdecl sub_80C1F48(_DWORD *a1);
int __cdecl sub_80C1F9C(int a1, int a2, int a3, int a4, int a5, int a6);
int __cdecl sub_80C205C(int a1, int a2);
int __cdecl sub_80C210C(int a1);
int __cdecl sub_80C21AE(int a1);
int __cdecl sub_80C21D8(int a1);
int __cdecl sub_80C2202(int a1);
_DWORD *__cdecl sub_80C2238(_DWORD *a1);
int __cdecl sub_80C2272(int a1);
const char *__cdecl sub_80C22E6(int a1);
int __cdecl sub_80C2564(char *file); // idb
char *__cdecl sub_80C2580(int a1, char *dest, char *src);
int __cdecl sub_80C26CE(int, char *dest); // idb
int __cdecl sub_80C270E(int, char *src, char *); // idb
char *__cdecl sub_80C27C6(int a1);
int __cdecl sub_80C2884(char *filename, char *, int); // idb
int XAnimInit();
int sub_80C2B26();
int sub_80C2B50();
int __cdecl sub_80C2B64(int (__cdecl *a1)(int));
unsigned __int16 *__cdecl sub_80C2BDE(int a1);
char *__cdecl sub_80C2CC4(int a1, char *s, int a3, int a4);
int __cdecl sub_80C2DDA(const char *a1, int (__cdecl *a2)(int));
int __cdecl sub_80C41DC(int a1, unsigned __int16 a2, int a3);
int __cdecl sub_80C424E(int a1, unsigned __int16 a2, int a3, __int16 a4, unsigned __int16 a5, __int16 a6);
_DWORD *__cdecl sub_80C42D6(int a1, int a2, int (__cdecl *a3)(int));
_DWORD *__cdecl sub_80C4306(int a1, int (__cdecl *a2)(int));
int __cdecl sub_80C436C(int a1, int (__cdecl *a2)(int, int));
int __cdecl sub_80C43B4(int a1);
int __cdecl sub_80C43BE(int a1, int a2, int a3);
int __cdecl sub_80C4580(float, int, int, int); // idb
int __cdecl sub_80C469E(float, int, int, int); // idb
int __cdecl sub_80C47DE(int, int, float, float, int); // idb
int __cdecl sub_80C4DE6(int, int, float, float, int); // idb
int __cdecl sub_80C53EE(int, int, float, int); // idb
int __cdecl sub_80C56F6(_DWORD *a1);
int __cdecl sub_80C5788(int, int, float, int, float); // idb
float *__cdecl sub_80C587E(int a1, int a2, int a3, float a4);
void __cdecl sub_80C5FC8(float *a1, float *a2);
int __cdecl sub_80C6076(int, float, int, float, float); // idb
int __cdecl sub_80C623C(int, float, int, float); // idb
int __cdecl sub_80C62F8(int a1);
int __cdecl sub_80C631A(int a1, unsigned __int16 a2);
long double __cdecl sub_80C639E(int a1);
int __cdecl sub_80C64FE(int a1);
int __cdecl sub_80C66EA(int, int, float); // idb
long double __cdecl sub_80C6770(float a1);
long double __cdecl sub_80C68B2(unsigned __int16 *a1, int a2);
int __cdecl sub_80C6962(int, int, int, float, int); // idb
void __cdecl sub_80C6A18(int a1, int a2, unsigned __int16 a3);
void __cdecl sub_80C6DE4(int a1, unsigned __int8 a2);
void __cdecl sub_80C70C2(int a1, float a2, int a3);
int __cdecl sub_80C75BA(int a1);
int __cdecl sub_80C769E(int a1);
void __cdecl sub_80C788A(int a1);
int __cdecl sub_80C7B22(int a1);
int __cdecl sub_80C7B56(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3);
long double __cdecl sub_80C7B9C(unsigned __int16 *a1, unsigned __int16 *a2);
long double __cdecl sub_80C7C86(int a1, float a2);
void __cdecl sub_80C800C(unsigned __int16 *a1, int a2);
int __cdecl sub_80C838A(unsigned __int16 *a1, unsigned __int16 *a2);
int __cdecl sub_80C8450(int a1);
void __cdecl sub_80C84F0(int a1, float a2, int a3);
int __cdecl sub_80C8848(int, float, int, int, int); // idb
void __cdecl sub_80C9036(int *a1, int a2, int a3);
void __cdecl sub_80C947C(int a1, int a2, float a3, int a4, int a5, int a6);
long double __cdecl sub_80C9B5E(int a1, int a2);
long double __cdecl sub_80C9B9C(int a1, int a2);
long double __cdecl sub_80C9BF4(int a1, int a2);
int __cdecl sub_80C9C4C(int a1, int a2);
int __cdecl sub_80C9CEE(int a1, int a2);
int __cdecl sub_80C9CFE(int a1, int a2, int a3);
const char *__cdecl sub_80C9D12(int a1, int a2);
int __cdecl sub_80C9D4A(int a1);
int __cdecl sub_80C9D54(int a1);
int __cdecl sub_80C9D60(int *a1);
void __cdecl sub_80C9D88(int *a1, float a2);
void __cdecl sub_80C9DB8(int a1, float a2);
int __cdecl sub_80C9E0E(int, float, int); // idb
int *__cdecl sub_80C9F14(int a1, int a2);
int __cdecl sub_80CA206(int **a1);
int __cdecl sub_80CA24E(int a1, int a2, float *a3, _DWORD *a4, int a5);
int __cdecl sub_80CA302(int a1, int a2, float *a3, _DWORD *a4);
int __cdecl sub_80CA3B6(int, int, int, int, float, float); // idb
int __cdecl sub_80CA4F4(int, int, int, int, float); // idb
int __cdecl sub_80CA62A(int a1, int a2);
int __cdecl sub_80CA6E8(_DWORD *a1, int a2);
int __cdecl sub_80CA768(_DWORD *a1, int a2);
int __cdecl sub_80CA848(_DWORD *a1, int a2);
void __cdecl sub_80CA88E(_DWORD *a1, int a2, float a3);
int __cdecl sub_80CA978(_DWORD *a1, int a2, float a3);
int __cdecl sub_80CA9FC(int, int, float); // idb
int __cdecl sub_80CAA36(int, int, float); // idb
int __cdecl sub_80CAAAA(int, int, float, float); // idb
float *__cdecl sub_80CAC28(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8);
int __cdecl sub_80CACB6(int, int, int, float, float, int, int, int, int); // idb
int __cdecl sub_80CAE42(int, int, float, float, int, int, int, int); // idb
int __cdecl sub_80CAED0(int, int, float); // idb
int __cdecl sub_80CAF44(_DWORD *a1, int a2);
int *__cdecl sub_80CAFD0(_DWORD *a1);
int __cdecl sub_80CB0C2(int a1);
int __cdecl sub_80CB0F8(int a1);
int __cdecl sub_80CB12E(int a1);
int __cdecl sub_80CB20E(int, float, int, int, int, int, int); // idb
int __cdecl sub_80CB470(int a1, int a2);
int __cdecl sub_80CB4BC(_DWORD *a1, int a2, unsigned __int8 a3);
int __cdecl sub_80CB634(_DWORD *a1, int a2);
int __cdecl sub_80CB714(_DWORD *a1);
int __cdecl sub_80CB730(int a1, int a2);
_BOOL4 __cdecl sub_80CB772(int a1, int a2);
char *__cdecl sub_80CB78A(int a1, int a2, int a3);
int __cdecl sub_80CB814(int a1, int a2);
int __cdecl XAnimSetUser(int a1);
float *__cdecl sub_80CB8FC(int a1);
int __cdecl sub_80CB9C0(int a1, int a2);
int __cdecl sub_80CBA7A(int a1, int a2);
int __cdecl sub_80CBC66(int a1, int a2);
int __cdecl sub_80CBCDE(int, int, float, int, int, int, int, int); // idb
int __cdecl sub_80CBD8C(int a1, int a2, int a3);
int __cdecl sub_80CBDAE(int a1, int a2);
int __cdecl sub_80CBDF2(int a1, int a2, __int16 a3);
float *__cdecl sub_80CBE66(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8);
void __cdecl sub_80CBFAC(int a1);
int __cdecl sub_80CC012(int a1);
void __cdecl sub_80CC08C(_WORD *a1);
int __cdecl sub_80CC104(unsigned __int16 *a1);
int __cdecl sub_80CC188(const void *a1, unsigned __int16 *a2);
int __cdecl sub_80CC1C8(int a1);
unsigned int __cdecl sub_80CC266(int a1);
int __cdecl sub_80CC382(int a1, int a2);
long double __cdecl sub_80CC480(float a1);
int __cdecl sub_80CC49A(__int16 a1);
int __cdecl XModelEnforceExist(int a1);
_BOOL4 __cdecl sub_80CC4BE(int a1);
int __cdecl sub_80CC4E2(__int16 *a1, __int16 *a2);
int __cdecl sub_80CC5D2(__int16 *a1, __int16 *a2);
void sub_80CC660();
int __cdecl sub_80CC666(int a1);
int *__cdecl sub_80CC6C6(int a1);
int __cdecl sub_80CC77E(int a1, int a2, __int16 **a3);
int __cdecl sub_80CC846(_DWORD *a1, int a2);
int __cdecl sub_80CC9D8(int a1, __int16 **a2, int (__cdecl *a3)(int));
int __cdecl sub_80CD028(int a1);
_DWORD *sub_80CD146();
_DWORD *sub_80CD250();
void *__cdecl sub_80CD2B2(int a1);
int *sub_80CD3A8();
_DWORD *__cdecl sub_80CD3CC(_DWORD *a1, int (__cdecl *a2)(int));
_DWORD *__cdecl sub_80CD47C(const char *a1, int (__cdecl *a2)(int));
int __cdecl sub_80CD72A(const char *a1, int (__cdecl *a2)(int));
float *__cdecl sub_80CDF7C(int a1, char *src, int a3);
int *__cdecl sub_80CE11E(int *a1, _DWORD *a2, int (__cdecl *a3)(int));
_BOOL4 __cdecl sub_80CE462(int a1);
int __cdecl sub_80CE498(const char *a1, int a2, int (__cdecl *a3)(int));
int __cdecl sub_80CEAE0(unsigned int a1, unsigned int a2);
int __cdecl sub_80CEBCA(int a1);
int __cdecl sub_80CEBE2(int a1);
int __cdecl sub_80CEBFA(int a1, __int16 a2);
int __cdecl sub_80CEC5C(int a1, _DWORD *a2, _DWORD *a3);
const char *__cdecl sub_80CED0A(int a1, int a2, int a3);
int __cdecl sub_80CED5C(void **a1, int (__cdecl *a2)(int));
int __cdecl sub_80CEF02(int a1);
int __cdecl sub_80CEFA0(int a1);
int *__cdecl sub_80CEFAE(int a1, int a2, int a3, void *dest, int a5);
int __cdecl sub_80CF17E(int a1);
int __cdecl sub_80CF21A(int a1, float a2);
unsigned __int8 **__cdecl sub_80CF2C4(int a1, int a2);
int __cdecl sub_80CF4FE(int a1, int a2, int a3, float *a4, float *a5, int a6);
int __cdecl sub_80CF91E(int a1, float *a2, _DWORD *a3, _DWORD *a4);
int __cdecl sub_80CFAF2(__int16 a1);
int __cdecl sub_80CFB06(int a1);
long double __cdecl sub_80CFB0E(float a1);
int __cdecl sub_80CFB20(int a1);
float *__cdecl sub_80CFCF2(float *a1, float *a2, float *a3);
int __cdecl sub_80CFD9E(int, float, int, int); // idb
float *__cdecl sub_80CFE70(float *a1, float *a2, float *a3);
float *__cdecl sub_80CFF0A(float *a1, float *a2, float *a3);
int DObjInit();
int sub_80CFFF0();
int __cdecl sub_80D0022(int a1);
int __cdecl sub_80D01E6(int a1, __int16 a2);
int __cdecl sub_80D0274(int a1);
int __cdecl sub_80D049E(int a1, int a2, int a3);
int *__cdecl sub_80D0682(int a1, int a2);
int __cdecl sub_80D0874(int a1, int a2);
int __cdecl sub_80D08A2(int a1, int a2);
int *__cdecl sub_80D0902(int a1, int a2);
int __cdecl sub_80D12C8(int a1, int a2);
int __cdecl sub_80D12E6(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5);
int __cdecl sub_80D15CE(int a1, int a2);
int __cdecl sub_80D1690(int a1);
_BOOL4 __cdecl sub_80D16B6(int a1, int a2);
int *__cdecl sub_80D1730(int a1, int *a2);
int __cdecl sub_80D17A2(int a1, _DWORD *a2, _DWORD *a3);
int __cdecl sub_80D17C6(int a1);
int __cdecl sub_80D1860(int a1, int a2, int a3);
int __cdecl sub_80D18E2(int a1, int a2, int a3);
const char *__cdecl sub_80D1A4E(int a1, int a2, int a3, int a4);
int __cdecl sub_80D1AB4(int, int, void *s, int); // idb
int __cdecl sub_80D1D5C(int, char *s); // idb
int __cdecl sub_80D1DA2(int a1, int a2);
int __cdecl sub_80D1E48(int a1);
int __cdecl sub_80D1E52(int a1);
int __cdecl sub_80D1E9E(int a1);
float *__cdecl sub_80D1EAA(float *a1, float *a2, float *a3);
float *__cdecl sub_80D1F56(float *a1, float *a2, float *a3);
int __cdecl sub_80D2000(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80D2854(int a1, float *a2, float *a3, int a4, int a5);
int __cdecl sub_80D297C(int a1, int a2, float a3);
int __cdecl sub_80D299E(int a1, int a2);
float *__cdecl sub_80D29EE(float *a1, float *a2);
int __cdecl sub_80D2C06(float *a1, float *a2);
int __cdecl sub_80D2CC2(float *a1, float *a2);
int __cdecl sub_80D2DFA(float *a1, float *a2);
int __cdecl sub_80D2F34(char *name); // idb
void *__cdecl sub_80D2FC8(void *dest, void *src, size_t n);
void *__cdecl sub_80D2FE9(void *s, int c, size_t n);
void sub_80D3039();
ssize_t sub_80D304B();
ssize_t sub_80D3074();
int sub_80D30D9();
int sub_80D3121();
int sub_80D317C();
unsigned int __cdecl sub_80D31B5(_DWORD *a1);
int sub_80D3291();
int sub_80D32D2();
void __cdecl __noreturn sub_80D3311(int status); // idb
void __noreturn sub_80D3354();
void Sys_Init();
void __noreturn Sys_Error(char *format, ...);
void handler();
void sub_80D355B();
char *sub_80D36CA();
char *__cdecl sub_80D3C34(void *handle);
void sub_80D3C7C();
int sub_80D3C86();
int sub_80D3C90();
void __noreturn sub_80D3C9A();
void __noreturn sub_80D3CC1();
void *__cdecl Sys_LoadDLL(const char *a1, char *dest, int a3, int a4);
void sub_80D4049();
int __cdecl sub_80D404E(char *a1, int a2, int a3, int a4);
int __cdecl sub_80D4073(int, int off, int); // idb
int __cdecl sub_80D4094(int a1, int a2, int a3, int a4, int a5, int a6);
_DWORD *__stdcall sub_80D4140(_DWORD *a1);
int __cdecl sub_80D43DB(char *s); // idb
void sub_80D4413();
int __cdecl sub_80D4425(const char *a1);
__pid_t __cdecl sub_80D4551(char *s);
void __cdecl sub_80D45B9(char *src, int a2);
void __cdecl sub_80D4816(int a1, const char **a2);
void __cdecl __noreturn main(int a1, char **a2);
int __cdecl sub_80D4A0C(int, void *s); // idb
int __cdecl sub_80D4A89(int a1, int a2);
int __cdecl sub_80D4AFE(char *cp, void *s); // idb
int __cdecl sub_80D4B95(char *cp, int); // idb
int __cdecl sub_80D4BD8(int *a1, int a2);
ssize_t __cdecl sub_80D4D4B(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7);
ssize_t __cdecl sub_80D4E49(char *cp, int a2, size_t n, void *buf);
int __cdecl Sys_IsLANAddress(int a1, int a2);
struct hostent *sub_80D502D();
struct hostent *sub_80D51FD();
void sub_80D52E0();
int __cdecl sub_80D532E(char *cp, int a2);
char *sub_80D552C();
int __cdecl sub_80D5549(int a1);
int sub_80D563C();
int __cdecl sub_80D56C3(char *path); // idb
DIR *__cdecl sub_80D56DE(const char *a1, const char *a2, int a3, int a4, int *a5);
void *__cdecl sub_80D5975(char *name, char *s, int a3, int a4, int a5);
int __cdecl sub_80D5D04(void *ptr); // idb
char *sub_80D5D5A();
char *__cdecl sub_80D5D82(char *src);
char *sub_80D5DA5();
char *sub_80D5DF7();
char *sub_80D5E3F();
void Sys_ShowConsole();
const char *sub_80D5F35();
int __cdecl sub_80D5F94(float *a1, float *a2, int a3);
void __cdecl sub_80D6170(float *a1);
int __cdecl sub_80D61E8(char *filename, struct stat *stat_buf); // idb
int sub_80D6210();
void term_proc(void); // idb
// int sprintf(char *s, const char *format, ...);

//-------------------------------------------------------------------------
// Data declarations

const char byte_80D62A0 = '\x15'; // idb
const char byte_80D62C3 = '\x15'; // idb
const char byte_80D62E0 = '\x15'; // idb
const char byte_80D6305 = '\x15'; // idb
const char byte_80D6319 = '\x15'; // idb
const char byte_80D6340 = '\x15'; // idb
const char byte_80D6380 = '\x15'; // idb
const char byte_80D63C0 = '\x15'; // idb
const char byte_80D6400 = '\x15'; // idb
const char byte_80D6421 = '\x15'; // idb
const char byte_80D6440 = '\x15'; // idb
const char byte_80D6480 = '\x15'; // idb
const char byte_80D64C0 = '\x15'; // idb
const char byte_80D6500 = '\x15'; // idb
const char byte_80D6540 = '\x15'; // idb
const char byte_80D6580 = '\x15'; // idb
const char byte_80D65C0 = '\x15'; // idb
const char byte_80D65E1 = '\x15'; // idb
const char byte_80D6600 = '\x15'; // idb
const char byte_80D6640 = '\x15'; // idb
const char byte_80D6680 = '\x15'; // idb
const char byte_80D66A0 = '\x15'; // idb
const char byte_80D66E0 = '\x15'; // idb
const char byte_80D6720 = '\x15'; // idb
const char byte_80D674A = '\x15'; // idb
const char byte_80D6760 = '\x15'; // idb
const char byte_80D67A0 = '\x15'; // idb
const char byte_80D67E0 = '\x15'; // idb
const char byte_80D6820 = '\x15'; // idb
const char byte_80D6880 = '\x15'; // idb
const char byte_80D68BE = '\x15'; // idb
const char aExeErrCouldntL[20] = "EXE_ERR_COULDNT_LOAD"; // idb
const char aExeErrWrongMap[29] = "EXE_ERR_WRONG_MAP_VERSION_NUM"; // idb
const char byte_80D6980 = '\x15'; // idb
const char byte_80D69C0 = '\x15'; // idb
const char byte_80D69EF = '\x15'; // idb
const char byte_80D6A64 = '\x15'; // idb
const char byte_80D6AA0 = '\x15'; // idb
const char byte_80D6AE0 = '\x15'; // idb
const char byte_80D6C10 = '\x15'; // idb
const char byte_80D6C20 = '\x15'; // idb
const char byte_80D6C60 = '\x15'; // idb
const char byte_80D6CC0 = '\x15'; // idb
const char byte_80D6D20 = '\x15'; // idb
const char byte_80D6D60 = '\x15'; // idb
const char byte_80D6DA0 = '\x15'; // idb
const char byte_80D6DE0 = '\x15'; // idb
const char byte_80D6EE0 = '\x15'; // idb
const char byte_80D6F00 = '\x15'; // idb
const char byte_80D6F40 = '\x15'; // idb
const char byte_80D6F80 = '\x15'; // idb
const char byte_80D7000 = '\x15'; // idb
const char byte_80D7040 = '\x15'; // idb
const char byte_80D7080 = '\x15'; // idb
const char byte_80D70C0 = '\x15'; // idb
const char byte_80D7180 = '\x15'; // idb
const char byte_80D71A0 = '\x15'; // idb
const char byte_80D71E0 = '\x15'; // idb
const char byte_80D72E0 = '\x15'; // idb
_UNKNOWN unk_80D749C; // weak
const char byte_80D7530 = '\x15'; // idb
const char byte_80D7560 = '\x15'; // idb
const char byte_80D7600 = '\x15'; // idb
const char byte_80D7640 = '\x15'; // idb
const char byte_80D7741 = '\0'; // idb
const char byte_80D77D4 = '\x15'; // idb
const char aExeUnpureclien_0[24] = "EXE_UNPURECLIENTDETECTED"; // idb
const char byte_80D78A0 = '\x15'; // idb
const char byte_80D78EF = '\x15'; // idb
const char byte_80D79E2 = '\x15'; // idb
const char byte_80D79F7 = '\x15'; // idb
const char byte_80D7EAB = '\x15'; // idb
int dword_80D7EC8 = 0; // weak
const char byte_80D82E0 = '\x15'; // idb
const char byte_80D8400 = '\x15'; // idb
const char byte_80D8435 = '\x15'; // idb
const char byte_80D8460 = '\x15'; // idb
const char byte_80D84A0 = '\x15'; // idb
const char byte_80D84E0 = '\x15'; // idb
const char byte_80D8520 = '\x15'; // idb
const char byte_80D8560 = '\x15'; // idb
const char byte_80D8660 = '\x15'; // idb
const char byte_80D86C0 = '\x15'; // idb
const char byte_80D8720 = '\x15'; // idb
const char byte_80D8780 = '\x15'; // idb
const char byte_80D87E0 = '\x15'; // idb
const char byte_80D8820 = '\x15'; // idb
const char byte_80D8880 = '\x15'; // idb
const char byte_80D88C0 = '\x15'; // idb
const char byte_80D8920 = '\x15'; // idb
const char byte_80D8980 = '\x15'; // idb
const char byte_80D8A20 = '\x15'; // idb
const char byte_80D8A60 = '\x15'; // idb
const char byte_80D8AA0 = '\x15'; // idb
const char byte_80D8AE0 = '\x15'; // idb
const char byte_80D8B20 = '\x15'; // idb
const char byte_80D8B60 = '\x15'; // idb
const char byte_80D8BA0 = '\x15'; // idb
const char byte_80D8D40 = '\x15'; // idb
const char byte_80D8EFB = '\0'; // idb
const char byte_80D8F60 = '\x15'; // idb
const char byte_80D8FA0 = '\x15'; // idb
const char byte_80D91F1 = '\0'; // idb
const char aExeServerFatal[24] = "EXE_SERVER_FATAL_CRASHED"; // idb
const char byte_80D9380 = '\x15'; // idb
const char byte_80D93FC = '\x15'; // idb
const char byte_80D9410 = '\x15'; // idb
const char aExeErrNotFound[17] = "EXE_ERR_NOT_FOUND"; // idb
const char byte_80D9891 = '\x15'; // idb
const char byte_80D9960 = '\x15'; // idb
const char byte_80D9980 = '\x15'; // idb
const char byte_80D9AE0 = '\x15'; // idb
const char byte_80D9B20 = '\x15'; // idb
_UNKNOWN unk_80D9B80; // weak
const char aSurialc[] = "S\x00U\x00R\x00I\x00A\x00L\x00C"; // idb
const char byte_80D9F00 = '\0'; // idb
const char byte_80DA000 = '\x15'; // idb
const char byte_80DAD69 = '\0'; // idb
char *entityStateFields = "pos.trTime"; // weak
char *off_80DBB80 = "absmin[1]"; // weak
char *off_80DBFE0 = "team"; // weak
char *playerStateFields = "commandTime"; // weak
_UNKNOWN unk_80DCB28; // weak
const char byte_80DCE40 = '\x15'; // idb
const char byte_80DD0C0 = '\x15'; // idb
const char byte_80DD100 = '\x15'; // idb
const char byte_80DD128 = '\x15'; // idb
const char byte_80DD16B = '\x15'; // idb
const char byte_80DD2F5 = '\x15'; // idb
const char byte_80DD320 = '\x15'; // idb
_UNKNOWN unk_80DD34E; // weak
const char byte_80DD360 = '\x15'; // idb
const char byte_80DD3A0 = '\x15'; // idb
const char byte_80DD3E0 = '\x15'; // idb
const char byte_80DD420 = '\x15'; // idb
const char byte_80DD460 = '\x15'; // idb
const char byte_80DD4A0 = '\x15'; // idb
const char byte_80DD4E0 = '\x15'; // idb
const char byte_80DD520 = '\x15'; // idb
const char byte_80DD580 = '\x15'; // idb
const char byte_80DD5E0 = '\x15'; // idb
const char byte_80DD84E = '\0'; // idb
const char asc_80DDCB2[3] = "h \""; // idb
const char byte_80DDF5B = '\0'; // idb
const char aError_2[6] = "error\n"; // idb
const char aError_3[6] = "error\n"; // idb
const char aErrorExeServer_0[33] = "error\nEXE_SERVER_IS_DIFFERENT_VER"; // idb
const char aE[3] = "e \""; // idb
const char aExeCantautodlg[21] = "EXE_CANTAUTODLGAMEPAK"; // idb
const char aExeAutodlServe[30] = "EXE_AUTODL_SERVERDISABLED_PURE"; // idb
const char aExeAutodlServe_0[25] = "EXE_AUTODL_SERVERDISABLED"; // idb
const char aExeAutodlFilen[26] = "EXE_AUTODL_FILENOTONSERVER"; // idb
const char byte_80DEF60 = '\x15'; // idb
const char byte_80DEFA0 = '\x15'; // idb
const char byte_80DEFE0 = '\x15'; // idb
const char byte_80DF040 = '\x15'; // idb
const char byte_80DF0A0 = '\x15'; // idb
const char byte_80DF100 = '\x15'; // idb
const char byte_80DF180 = '\x15'; // idb
const char byte_80DF1A8 = '\x15'; // idb
const char byte_80DF1D7 = '\x15'; // idb
const char byte_80DF1DB = '\x15'; // idb
const char byte_80DF551 = '\x15'; // idb
const char byte_80DF580 = '\x15'; // idb
const char byte_80DF5C0 = '\x15'; // idb
const char byte_80DF5E3 = '\0'; // idb
__int16 aXzy[3] = { 120, 122, 121 }; // weak
const char byte_80DF600 = '\x15'; // idb
const char byte_80DF640 = '\x15'; // idb
const char byte_80DF680 = '\x15'; // idb
const char byte_80DF6C0 = '\x15'; // idb
const char byte_80DF700 = '\x15'; // idb
const char byte_80DF740 = '\x15'; // idb
const char byte_80DF773 = '\x15'; // idb
const char byte_80DF7A0 = '\x15'; // idb
const char aExeServerresta_6[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_5[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_4[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_3[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_2[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_1[] = "EXE_SERVERRESTARTMISC"; // idb
const char aExeServerresta_0[] = "EXE_SERVERRESTARTMISC"; // idb
const char byte_80E07C0 = '\x15'; // idb
const char byte_80E0800 = '\x15'; // idb
const char byte_80E0840 = '\x15'; // idb
const char byte_80E0880 = '\x15'; // idb
const char byte_80E08C0 = '\x15'; // idb
const char byte_80E0900 = '\x15'; // idb
const char byte_80E0940 = '\x15'; // idb
const char byte_80E0A20 = '\x15'; // idb
const char byte_80E0A60 = '\x15'; // idb
const char byte_80E0B60 = '\x15'; // idb
const char byte_80E0B76 = '\x15'; // idb
const char byte_80E0D80 = '\x15'; // idb
const char byte_80E0DED = '\x15'; // idb
_UNKNOWN unk_80E17EC; // weak
const char byte_80E18A0 = '\x15'; // idb
const char byte_80E1920 = '\x15'; // idb
const char byte_80E1960 = '\x15'; // idb
const char byte_80E19C0 = '\x15'; // idb
const char byte_80E1E74 = '\x15'; // idb
const char byte_80E1E94 = '\x15'; // idb
const char byte_80E1EAF = '\x15'; // idb
const char byte_80E1ECB = '\x15'; // idb
const char byte_80E2800 = '\x15'; // idb
__int16 word_80E2940[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  94,
  92,
  1,
  4,
  33,
  92,
  43,
  32,
  19,
  11,
  12,
  30,
  28,
  37,
  29,
  38,
  31,
  35,
  40,
  42,
  22,
  41,
  23,
  39,
  90,
  13,
  14,
  18,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  9,
  17,
  10,
  34,
  3,
  3,
  4,
  21,
  0,
  7,
  0,
  89,
  0,
  0,
  67,
  0,
  16,
  60,
  0,
  0,
  0,
  0,
  65,
  56,
  63,
  57,
  64,
  36,
  0,
  88,
  6,
  5,
  66,
  0,
  35,
  0,
  75,
  26,
  24,
  20,
  25,
  27,
  90,
  0,
  59,
  90,
  90,
  90,
  90,
  90,
  84,
  90,
  90,
  90,
  90,
  90,
  52,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  58,
  15,
  2,
  0,
  0,
  0,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  5,
  0,
  36,
  61,
  62,
  91,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  55,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  90,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  91,
  51,
  90,
  80,
  90,
  90,
  53,
  90,
  90,
  50,
  90,
  90,
  90,
  48,
  90,
  90,
  87,
  90,
  45,
  90,
  0,
  0,
  0,
  0,
  69,
  0,
  72,
  82,
  90,
  90,
  85,
  86,
  49,
  90,
  90,
  90,
  90,
  90,
  90,
  54,
  0,
  0,
  68,
  0,
  0,
  90,
  90,
  78,
  44,
  79,
  46,
  90,
  90,
  0,
  0,
  70,
  0,
  90,
  81,
  90,
  90,
  0,
  0,
  71,
  83,
  90,
  76,
  74,
  0,
  47,
  90,
  0,
  90,
  0,
  90,
  0,
  90,
  0,
  77,
  0,
  73,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char byte_80E2B40[] = { '\0' }; // weak
char byte_80E2F40[] = { '\0' }; // weak
__int16 word_80E3040[256] =
{
  0,
  391,
  390,
  0,
  0,
  54,
  55,
  392,
  395,
  395,
  389,
  369,
  54,
  44,
  368,
  56,
  37,
  395,
  367,
  50,
  395,
  49,
  50,
  68,
  63,
  369,
  395,
  65,
  365,
  69,
  395,
  358,
  395,
  395,
  363,
  55,
  60,
  66,
  67,
  72,
  73,
  41,
  76,
  74,
  79,
  81,
  87,
  80,
  92,
  93,
  395,
  74,
  395,
  395,
  395,
  367,
  380,
  395,
  116,
  395,
  0,
  395,
  338,
  334,
  395,
  121,
  395,
  395,
  335,
  337,
  334,
  329,
  395,
  395,
  395,
  395,
  395,
  113,
  336,
  395,
  395,
  0,
  395,
  357,
  117,
  127,
  395,
  352,
  395,
  395,
  395,
  351,
  344,
  0,
  395,
  106,
  119,
  109,
  113,
  122,
  343,
  120,
  123,
  124,
  125,
  126,
  342,
  132,
  133,
  135,
  134,
  137,
  140,
  136,
  144,
  147,
  150,
  395,
  395,
  395,
  329,
  328,
  164,
  395,
  0,
  322,
  321,
  317,
  318,
  310,
  0,
  344,
  343,
  395,
  395,
  332,
  145,
  152,
  161,
  146,
  163,
  165,
  168,
  170,
  331,
  171,
  172,
  174,
  175,
  178,
  177,
  176,
  182,
  183,
  181,
  188,
  315,
  313,
  314,
  323,
  343,
  313,
  316,
  323,
  322,
  192,
  321,
  194,
  193,
  320,
  195,
  199,
  319,
  198,
  200,
  203,
  318,
  204,
  213,
  317,
  215,
  208,
  218,
  296,
  305,
  331,
  293,
  395,
  296,
  395,
  311,
  216,
  219,
  310,
  309,
  308,
  220,
  222,
  223,
  229,
  225,
  227,
  307,
  288,
  302,
  395,
  321,
  293,
  230,
  235,
  302,
  301,
  300,
  299,
  231,
  240,
  290,
  293,
  395,
  313,
  241,
  295,
  242,
  243,
  286,
  273,
  395,
  285,
  245,
  246,
  395,
  267,
  267,
  256,
  251,
  248,
  245,
  253,
  246,
  258,
  255,
  262,
  94,
  395,
  395,
  296,
  300,
  304,
  306,
  310,
  314,
  123,
  316,
  0,
  0,
  0
}; // idb
__int16 word_80E3240[256] =
{
  0,
  245,
  245,
  244,
  3,
  246,
  246,
  244,
  244,
  244,
  244,
  244,
  247,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  247,
  244,
  247,
  244,
  244,
  244,
  244,
  249,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  250,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  251,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  249,
  244,
  249,
  244,
  244,
  244,
  244,
  244,
  250,
  244,
  244,
  244,
  244,
  252,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  252,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  244,
  248,
  248,
  248,
  248,
  244,
  244,
  244,
  248,
  248,
  248,
  244,
  244,
  248,
  248,
  244,
  248,
  244,
  248,
  244,
  248,
  244,
  248,
  244,
  244,
  0,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  0,
  0,
  0
}; // idb
__int16 word_80E3440[464] =
{
  0,
  8,
  10,
  9,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  31,
  32,
  8,
  33,
  34,
  31,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  31,
  42,
  31,
  43,
  31,
  44,
  31,
  45,
  46,
  47,
  48,
  31,
  49,
  31,
  31,
  50,
  51,
  52,
  53,
  9,
  9,
  59,
  61,
  65,
  73,
  75,
  66,
  55,
  55,
  77,
  93,
  68,
  76,
  74,
  105,
  69,
  79,
  62,
  70,
  67,
  83,
  80,
  84,
  60,
  93,
  71,
  81,
  87,
  88,
  93,
  85,
  82,
  90,
  91,
  63,
  93,
  93,
  117,
  78,
  97,
  95,
  93,
  93,
  93,
  99,
  93,
  103,
  96,
  93,
  93,
  93,
  107,
  98,
  100,
  106,
  101,
  93,
  102,
  109,
  104,
  112,
  93,
  93,
  59,
  110,
  108,
  115,
  113,
  123,
  135,
  118,
  243,
  77,
  116,
  83,
  93,
  84,
  114,
  93,
  111,
  85,
  131,
  93,
  131,
  85,
  60,
  132,
  136,
  93,
  93,
  124,
  93,
  93,
  93,
  93,
  93,
  137,
  138,
  139,
  142,
  140,
  93,
  93,
  93,
  93,
  93,
  93,
  143,
  141,
  93,
  145,
  123,
  144,
  93,
  93,
  93,
  93,
  149,
  150,
  93,
  153,
  93,
  147,
  146,
  148,
  165,
  152,
  151,
  154,
  164,
  93,
  155,
  93,
  124,
  93,
  167,
  168,
  93,
  166,
  93,
  93,
  93,
  169,
  93,
  93,
  93,
  93,
  93,
  172,
  173,
  93,
  93,
  93,
  178,
  170,
  174,
  176,
  93,
  171,
  179,
  180,
  93,
  93,
  93,
  93,
  175,
  177,
  93,
  93,
  93,
  181,
  182,
  93,
  93,
  190,
  191,
  194,
  93,
  196,
  198,
  193,
  195,
  93,
  192,
  93,
  93,
  199,
  93,
  93,
  93,
  197,
  93,
  93,
  200,
  93,
  202,
  93,
  201,
  93,
  93,
  93,
  208,
  209,
  212,
  93,
  213,
  214,
  211,
  215,
  93,
  93,
  93,
  93,
  210,
  93,
  93,
  222,
  93,
  227,
  228,
  220,
  232,
  93,
  223,
  221,
  93,
  229,
  93,
  239,
  235,
  233,
  93,
  242,
  240,
  238,
  236,
  93,
  237,
  241,
  8,
  8,
  8,
  8,
  54,
  54,
  54,
  54,
  58,
  234,
  58,
  58,
  92,
  92,
  122,
  93,
  122,
  122,
  130,
  231,
  130,
  130,
  163,
  163,
  230,
  93,
  226,
  225,
  224,
  93,
  93,
  93,
  93,
  219,
  218,
  217,
  216,
  93,
  93,
  93,
  93,
  93,
  207,
  206,
  205,
  204,
  203,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  189,
  188,
  187,
  186,
  185,
  184,
  183,
  93,
  93,
  132,
  132,
  162,
  161,
  160,
  159,
  158,
  157,
  156,
  93,
  93,
  93,
  134,
  133,
  77,
  129,
  128,
  127,
  126,
  125,
  121,
  120,
  56,
  119,
  94,
  93,
  89,
  86,
  72,
  64,
  57,
  56,
  244,
  9,
  9,
  7,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80E37E0[452] =
{
  0,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  6,
  12,
  13,
  15,
  19,
  21,
  15,
  5,
  6,
  22,
  41,
  16,
  21,
  19,
  41,
  16,
  23,
  13,
  16,
  15,
  24,
  23,
  24,
  12,
  35,
  16,
  23,
  27,
  27,
  36,
  24,
  23,
  29,
  29,
  13,
  37,
  38,
  51,
  22,
  37,
  35,
  39,
  40,
  43,
  38,
  42,
  40,
  36,
  44,
  47,
  45,
  43,
  37,
  38,
  42,
  39,
  46,
  39,
  45,
  40,
  47,
  48,
  49,
  58,
  46,
  44,
  49,
  47,
  65,
  251,
  51,
  242,
  77,
  49,
  84,
  95,
  84,
  48,
  97,
  46,
  77,
  85,
  98,
  85,
  84,
  58,
  85,
  95,
  96,
  101,
  65,
  99,
  102,
  103,
  104,
  105,
  96,
  97,
  98,
  102,
  99,
  107,
  108,
  110,
  109,
  113,
  111,
  103,
  101,
  112,
  105,
  122,
  104,
  114,
  136,
  139,
  115,
  110,
  111,
  116,
  114,
  137,
  108,
  107,
  109,
  137,
  113,
  112,
  115,
  136,
  138,
  116,
  140,
  122,
  141,
  139,
  140,
  142,
  138,
  143,
  145,
  146,
  141,
  147,
  148,
  151,
  150,
  149,
  145,
  146,
  154,
  152,
  153,
  151,
  142,
  147,
  149,
  155,
  143,
  152,
  153,
  165,
  168,
  167,
  170,
  148,
  150,
  173,
  171,
  174,
  154,
  155,
  175,
  177,
  165,
  167,
  171,
  181,
  174,
  177,
  170,
  173,
  178,
  168,
  180,
  191,
  178,
  182,
  192,
  196,
  175,
  197,
  198,
  180,
  200,
  182,
  201,
  181,
  199,
  208,
  214,
  191,
  192,
  198,
  209,
  199,
  200,
  197,
  201,
  215,
  220,
  222,
  223,
  196,
  228,
  229,
  214,
  235,
  220,
  222,
  208,
  228,
  237,
  215,
  209,
  233,
  223,
  239,
  237,
  233,
  229,
  241,
  240,
  238,
  236,
  234,
  232,
  235,
  239,
  245,
  245,
  245,
  245,
  246,
  246,
  246,
  246,
  247,
  231,
  247,
  247,
  248,
  248,
  249,
  227,
  249,
  249,
  250,
  225,
  250,
  250,
  252,
  252,
  224,
  221,
  219,
  217,
  216,
  213,
  212,
  211,
  210,
  207,
  206,
  204,
  203,
  202,
  195,
  194,
  193,
  190,
  188,
  186,
  185,
  184,
  183,
  179,
  176,
  172,
  169,
  166,
  164,
  163,
  162,
  161,
  160,
  159,
  158,
  157,
  156,
  144,
  135,
  132,
  131,
  129,
  128,
  127,
  126,
  125,
  121,
  120,
  106,
  100,
  92,
  91,
  87,
  83,
  78,
  71,
  70,
  69,
  68,
  63,
  62,
  56,
  55,
  34,
  31,
  28,
  25,
  18,
  14,
  11,
  10,
  7,
  2,
  1,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244,
  244
}; // idb
int dword_80E40E0[272] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  1717920800,
  1702125932,
  825110816,
  1126183982,
  1920561263,
  1952999273,
  960049440,
  808594741,
  1243623984,
  762208613,
  1886744428,
  1767982880,
  544828524,
  0,
  0,
  0
}; // idb
__int16 word_80E4520[] = { 0 }; // weak
__int16 word_80E4522[] = { 0 }; // weak
__int16 word_80E4524[] = { 0 }; // weak
__int16 word_80E4526[] = { 0 }; // weak
int (__cdecl *off_80E4528[28])(int, int) =
{
  &sub_80B6664,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x40008,
  &loc_80B6901,
  (int (__cdecl *)(int, int))0x50004,
  (int (__cdecl *)(int, int))0x80010,
  &loc_80B6901,
  (int (__cdecl *)(int, int))0x60004,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80B6901,
  (int (__cdecl *)(int, int))0x40004,
  (int (__cdecl *)(int, int))0x100010,
  &loc_80B6EC0,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x200020,
  &loc_80B6EC0,
  (int (__cdecl *)(int, int))0x100008,
  (int (__cdecl *)(int, int))0x800080,
  &loc_80B6EC0,
  (int (__cdecl *)(int, int))0x200008,
  (int (__cdecl *)(int, int))0x1000080,
  &loc_80B6EC0,
  (int (__cdecl *)(int, int))0x800020,
  (int (__cdecl *)(int, int))0x4000102,
  &loc_80B6EC0,
  (int (__cdecl *)(int, int))0x1020020,
  (int (__cdecl *)(int, int))0x10000102,
  &loc_80B6EC0
}; // idb
int dword_80E45A0[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; // idb
_UNKNOWN unk_80E4800; // weak
_UNKNOWN unk_80E4880; // weak
_UNKNOWN unk_80E4900; // weak
_UNKNOWN unk_80E4980; // weak
int dword_80E4B60[] = { 0 }; // weak
int dword_80E4BE0[] = { 0 }; // weak
_UNKNOWN unk_80E4CC0; // weak
_UNKNOWN unk_80E5140; // weak
char byte_80E52C0[] = { '\0' }; // weak
int dword_80E54C0[32] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  12,
  14,
  16,
  20,
  24,
  28,
  32,
  40,
  48,
  56,
  64,
  80,
  96,
  112,
  128,
  160,
  192,
  224,
  0,
  0,
  0,
  0
}; // idb
int dword_80E5540[30] =
{
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
}; // idb
_UNKNOWN unk_80E5682; // weak
_UNKNOWN unk_80E57E4; // weak
const char byte_80E57EB = '\x15'; // idb
const char byte_80E5811 = '\x15'; // idb
const char byte_80E5840 = '\x15'; // idb
const char byte_80E5873 = '\x15'; // idb
const char byte_80E5AE0 = '\x15'; // idb
const char byte_80E5B40 = '\x15'; // idb
const char byte_80E5B80 = '\x15'; // idb
const char byte_80E5BC0 = '\x15'; // idb
const char byte_80E5C20 = '\x15'; // idb
_UNKNOWN unk_80E5C78; // weak
const char byte_80E5CA0 = '\x15'; // idb
const char byte_80E5D40 = '\x15'; // idb
const char byte_80E5D60 = '\x15'; // idb
const char byte_80E5DC0 = '\x15'; // idb
const char byte_80E5E60 = '\x15'; // idb
const char byte_80E5E80 = '\x15'; // idb
const char byte_80E5EC0 = '\x15'; // idb
const char byte_80E5F00 = '\x15'; // idb
const char byte_80E5F40 = '\x15'; // idb
const char byte_80E5FCD = '\x15'; // idb
const char byte_80E6160 = '\x15'; // idb
const char byte_80E673F = '\0'; // idb
_UNKNOWN unk_80E69EE; // weak
int (**off_80E8C28)() = &off_80F6330; // weak
int dword_80E8C2C = 0; // weak
void *fs_searchpaths = NULL; // idb
void *dword_80E8C34 = NULL; // idb
void *dword_80E8C38 = NULL; // idb
void *dword_80E8C3C = NULL; // idb
char dword_80E8C40[] = { '\0', '\0', '\0', '\0' }; // idb
int dword_80E8C44 = 0; // weak
int dword_80E93FC = 0; // weak
void *ptr = NULL; // idb
int dword_80E9420[] = { 0 }; // weak
char *off_80E9480[10] =
{
  "auto",
  "menu",
  "weapon",
  "voice",
  "item",
  "body",
  "local",
  "music",
  "announcer",
  "shellshock"
}; // weak
int dword_80E94C0 = 0; // weak
int dword_80E94C4 = 0; // weak
int dword_80E94C8 = 0; // weak
int dword_80E94CC = 0; // weak
int dword_80E94D0 = 0; // weak
int dword_80E94DC = 0; // weak
char a123456789[] = "123456789"; // idb
char byte_80E94F0 = '\0'; // weak
_UNKNOWN unk_80E9502; // weak
char byte_80E9506 = '\0'; // weak
int dword_80E950C = 0; // weak
int dword_80E9510 = 0; // weak
int dword_80E95B8 = 0; // weak
char *off_80E95C0 = "if"; // idb
int (__cdecl *off_80E95C4)(int) = &sub_807B739; // weak
char *off_80E9660 = "evalint"; // idb
int (__cdecl *off_80E9664)(int) = &sub_807BBB5; // weak
char *off_80E9700 = ">>="; // weak
_UNKNOWN unk_80E9980; // weak
int dword_80E99C0 = 0; // weak
int dword_80E99E0[40] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  131071,
  262143,
  524287,
  1048575,
  2097151,
  4194303,
  8388607,
  16777215,
  33554431,
  67108863,
  134217727,
  268435455,
  536870911,
  1073741823,
  2147483647,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
char *off_80E9A80 = "origin[0]"; // weak
char *off_80E9AE0 = "color.rgba"; // weak
int dword_80E9AE4[87] =
{
  28,
  32,
  135121491,
  0,
  4,
  135121496,
  12,
  0,
  135121506,
  8,
  10,
  135121508,
  4,
  10,
  135121510,
  24,
  2,
  135121517,
  20,
  2,
  135116813,
  92,
  32,
  135121524,
  16,
  4,
  135121529,
  104,
  8,
  135121534,
  56,
  8,
  135121546,
  48,
  10,
  135121552,
  52,
  10,
  135121559,
  108,
  0,
  135121564,
  32,
  32,
  135121579,
  36,
  32,
  135121593,
  40,
  16,
  135121602,
  68,
  32,
  135121617,
  72,
  16,
  135121627,
  64,
  10,
  135121638,
  100,
  0,
  135121644,
  44,
  8,
  135121650,
  60,
  10,
  135121660,
  84,
  32,
  135121674,
  88,
  16,
  135121683,
  76,
  10,
  135121689,
  80,
  10,
  135121695,
  96,
  32,
  0,
  0,
  0,
  0
}; // idb
int dword_80E9C40[255] =
{
  250315,
  41193,
  6292,
  7106,
  3730,
  3750,
  6110,
  23283,
  33317,
  6950,
  7838,
  9714,
  9257,
  17259,
  3949,
  1778,
  8288,
  1604,
  1590,
  1663,
  1100,
  1213,
  1238,
  1134,
  1749,
  1059,
  1246,
  1149,
  1273,
  4486,
  2805,
  3472,
  21819,
  1159,
  1670,
  1066,
  1043,
  1012,
  1053,
  1070,
  1726,
  888,
  1180,
  850,
  960,
  780,
  1752,
  3296,
  10630,
  4514,
  5881,
  2685,
  4650,
  3837,
  2093,
  1867,
  2584,
  1949,
  1972,
  940,
  1134,
  1788,
  1670,
  1206,
  5719,
  6128,
  7222,
  6654,
  3710,
  3795,
  1492,
  1524,
  2215,
  1140,
  1355,
  971,
  2180,
  1248,
  1328,
  1195,
  1770,
  1078,
  1264,
  1266,
  1168,
  965,
  1155,
  1186,
  1347,
  1228,
  1529,
  1600,
  2617,
  2048,
  2546,
  3275,
  2410,
  3585,
  2504,
  2800,
  2675,
  6146,
  3663,
  2840,
  14253,
  3164,
  2221,
  1687,
  3208,
  2739,
  3512,
  4796,
  4091,
  3515,
  5288,
  4016,
  7937,
  6031,
  5360,
  3924,
  4892,
  3743,
  4566,
  4807,
  5852,
  6400,
  6225,
  8291,
  23243,
  7838,
  7073,
  8935,
  5437,
  4483,
  3641,
  5256,
  5312,
  5328,
  5370,
  3492,
  2458,
  1694,
  1821,
  2121,
  1916,
  1149,
  1516,
  1367,
  1236,
  1029,
  1258,
  1104,
  1245,
  1006,
  1149,
  1025,
  1241,
  952,
  1287,
  997,
  1713,
  1009,
  1187,
  879,
  1099,
  929,
  1078,
  951,
  1656,
  930,
  1153,
  1030,
  1262,
  1062,
  1214,
  1060,
  1621,
  930,
  1106,
  912,
  1034,
  892,
  1158,
  990,
  1175,
  850,
  1121,
  903,
  1087,
  920,
  1144,
  1056,
  3462,
  2240,
  4397,
  12136,
  7758,
  1345,
  1307,
  3278,
  1950,
  886,
  1023,
  1112,
  1077,
  1042,
  1061,
  1071,
  1484,
  1001,
  1096,
  915,
  1052,
  995,
  1070,
  876,
  1111,
  851,
  1059,
  805,
  1112,
  923,
  1103,
  817,
  1899,
  1872,
  976,
  841,
  1127,
  956,
  1159,
  950,
  7791,
  954,
  1289,
  933,
  1127,
  3207,
  1020,
  927,
  1355,
  768,
  1040,
  745,
  952,
  805,
  1073,
  740,
  1013,
  805,
  1008,
  796,
  996,
  1057,
  11457
}; // idb
char dword_80EA03C[] = { '\xC0', '4', '\0', '\0' }; // idb
char off_80EA040[] = { '\xC0', '\xCC', '\r', '\b' }; // idb
int dword_80EA048 = 0; // weak
char *off_80EA060[14] =
{
  "+=",
  "-=",
  "*=",
  "/=",
  "&=",
  "|=",
  "++",
  "--",
  "&&",
  "||",
  "<=",
  ">=",
  "==",
  "!="
}; // weak
_DWORD dword_80EA0A0[4464] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
void *off_80EE660 = &dword_80EA0A0; // idb
int dword_80EE664 = 0; // weak
int dword_80EE668 = 0; // weak
char *off_80EE680 = "userinfo"; // weak
int dword_80EE6D8 = 0; // weak
char dword_80EE800[] = { '\0', '\0', '\0', '\0' }; // idb
void *gvm = NULL; // idb
int dword_80EE808 = 0; // weak
int dword_80EE80C = 0; // weak
float flt_80EE810 = -64.0; // weak
float flt_80EE814 = -64.0; // weak
float flt_80EE818 = -32.0; // weak
float flt_80EE81C =  64.0; // weak
float flt_80EE820 =  64.0; // weak
float flt_80EE824 =  72.0; // weak
int dword_80EE828 = 0; // weak
int dword_80EE82C = 0; // weak
char *off_80EE830 = "loopsync"; // idb
void *dword_80EE83C = NULL; // idb
int dword_80EE840 = 0; // weak
void *dword_80EE844 = NULL; // idb
void *dword_80EE848 = NULL; // idb
char byte_80EE84C = '\0'; // weak
char byte_80EE84D = '\0'; // weak
int dword_80EE850 = 0; // weak
char byte_80EE854 = '\0'; // weak
char byte_80EE855 = '\0'; // weak
int dword_80EE858 = 0; // weak
char byte_80EE85C = '\0'; // weak
char byte_80EE85D = '\0'; // weak
int dword_80EE860 = 0; // weak
int dword_80EE864 = 0; // weak
int dword_80EE868 = 0; // weak
int dword_80EE86C = 0; // weak
void *dword_80EE870 = NULL; // idb
char dword_80EE874[] = { '\0', '\0', '\0', '\0' }; // idb
char dword_80EE878[] = { '\0', '\0', '\0', '\0' }; // idb
void *dword_80EE87C = NULL; // idb
void *dword_80EE880 = NULL; // idb
int dword_80EE884 = -1; // weak
int dword_80EE888 = 0; // weak
__int16 word_80EE8A0 = 0; // weak
__int16 word_80EE8A2 = 0; // weak
int dword_80EE8A4 = 0; // weak
char off_80EE8C0[] = { '\0', '\x1A', '\x0E', '\b' }; // idb
__int16 word_80EE90C = 0; // weak
__int16 word_80EE90E = 0; // weak
char byte_80EE910 = '\0'; // weak
__int16 word_80EE960[] = { -1 }; // weak
__int16 word_80EEA60[128] =
{
  2,
  2,
  1,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  0,
  1,
  1,
  3,
  1,
  3,
  2,
  1,
  5,
  1,
  2,
  4,
  5,
  3,
  1,
  1,
  2,
  2,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  1,
  2,
  2,
  1,
  1,
  1,
  3,
  4,
  1,
  1,
  3,
  2,
  1,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  5,
  5,
  5,
  5,
  1,
  1,
  6,
  0,
  1,
  2,
  3,
  5,
  7,
  5,
  8,
  5,
  3,
  1,
  3,
  2,
  1,
  2,
  0,
  3,
  1,
  0,
  3,
  1,
  0,
  3,
  1,
  3,
  1,
  3,
  1,
  7,
  9,
  5,
  2,
  0,
  0,
  3,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80EEB60[] = { 124 }; // weak
__int16 word_80EED60[32] =
{
  1,
  2,
  3,
  81,
  82,
  213,
  63,
  64,
  65,
  66,
  67,
  83,
  84,
  85,
  70,
  218,
  220,
  222,
  71,
  242,
  25,
  72,
  14,
  8,
  4,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80EEDA0[256] =
{
  0,
  0,
  0,
  -250,
  -283,
  -244,
  -233,
  -222,
  0,
  0,
  -221,
  -218,
  -204,
  0,
  -247,
  -172,
  -221,
  -219,
  -162,
  -198,
  -169,
  0,
  0,
  0,
  -152,
  147,
  0,
  0,
  0,
  0,
  0,
  0,
  576,
  -260,
  -265,
  -159,
  0,
  0,
  0,
  576,
  576,
  -255,
  0,
  0,
  0,
  0,
  0,
  -153,
  -112,
  -111,
  0,
  -105,
  0,
  -106,
  745,
  -133,
  0,
  0,
  483,
  0,
  0,
  0,
  171,
  -167,
  0,
  0,
  0,
  -102,
  0,
  316,
  -122,
  0,
  0,
  231,
  315,
  576,
  576,
  576,
  576,
  576,
  576,
  1151,
  -201,
  0,
  -95,
  0,
  576,
  0,
  0,
  0,
  0,
  1151,
  1151,
  0,
  -66,
  -119,
  0,
  576,
  576,
  399,
  0,
  576,
  -245,
  0,
  -93,
  62,
  654,
  -49,
  0,
  -47,
  -44,
  -42,
  -39,
  -31,
  -38,
  576,
  576,
  0,
  0,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  0,
  -116,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  576,
  0,
  576,
  1114,
  7,
  440,
  524,
  576,
  1053,
  0,
  -30,
  0,
  567,
  1133,
  0,
  576,
  576,
  576,
  576,
  576,
  0,
  -62,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  1151,
  0,
  1168,
  1184,
  1199,
  1213,
  1226,
  1237,
  1237,
  267,
  267,
  267,
  267,
  100,
  100,
  -256,
  -256,
  0,
  0,
  0,
  1151,
  18,
  0,
  483,
  483,
  1151,
  -7,
  483,
  576,
  0,
  1151,
  -20,
  1151,
  2,
  1151,
  17,
  1074,
  24,
  0,
  0,
  -16,
  0,
  662,
  0,
  1095,
  0,
  9,
  0,
  576,
  0,
  576,
  0,
  0,
  483,
  0,
  23,
  0,
  0,
  1151,
  1151,
  0,
  483,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80EEFA0[] = { 0 }; // weak
__int16 word_80EF1A0[32] =
{
  0,
  0,
  0,
  -8,
  -25,
  0,
  -37,
  0,
  0,
  259,
  -48,
  -23,
  -97,
  -18,
  72,
  0,
  0,
  0,
  -43,
  0,
  -14,
  206,
  303,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80EF1E0[1536] =
{
  62,
  121,
  68,
  93,
  95,
  86,
  87,
  69,
  5,
  9,
  94,
  68,
  73,
  93,
  113,
  104,
  74,
  17,
  176,
  10,
  106,
  32,
  88,
  89,
  67,
  95,
  153,
  154,
  155,
  102,
  11,
  91,
  92,
  62,
  113,
  68,
  12,
  13,
  69,
  68,
  69,
  15,
  21,
  18,
  107,
  95,
  164,
  105,
  62,
  62,
  68,
  68,
  67,
  41,
  113,
  69,
  69,
  93,
  5,
  16,
  5,
  5,
  5,
  5,
  106,
  95,
  69,
  132,
  133,
  134,
  135,
  136,
  137,
  52,
  62,
  6,
  68,
  224,
  158,
  108,
  62,
  69,
  68,
  52,
  5,
  29,
  5,
  69,
  107,
  160,
  161,
  7,
  19,
  163,
  23,
  24,
  22,
  41,
  168,
  90,
  7,
  66,
  7,
  7,
  7,
  7,
  7,
  7,
  177,
  26,
  97,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  18,
  3,
  108,
  3,
  3,
  7,
  52,
  7,
  66,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  3,
  207,
  3,
  98,
  99,
  100,
  212,
  72,
  73,
  101,
  103,
  158,
  114,
  115,
  217,
  219,
  221,
  223,
  74,
  227,
  228,
  156,
  129,
  230,
  8,
  75,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  76,
  72,
  73,
  62,
  62,
  68,
  68,
  62,
  77,
  68,
  69,
  69,
  74,
  157,
  69,
  247,
  8,
  86,
  8,
  75,
  225,
  78,
  62,
  249,
  68,
  231,
  159,
  169,
  76,
  69,
  79,
  165,
  80,
  62,
  170,
  68,
  77,
  171,
  175,
  172,
  69,
  62,
  173,
  68,
  188,
  245,
  157,
  246,
  69,
  78,
  174,
  215,
  93,
  93,
  93,
  93,
  93,
  93,
  79,
  93,
  80,
  10,
  232,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  10,
  93,
  81,
  121,
  93,
  93,
  93,
  93,
  93,
  209,
  234,
  244,
  93,
  10,
  233,
  10,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  93,
  236,
  93,
  93,
  226,
  229,
  81,
  248,
  239,
  240,
  1,
  28,
  235,
  122,
  89,
  27,
  93,
  93,
  93,
  93,
  96,
  241,
  93,
  93,
  93,
  162,
  0,
  237,
  93,
  93,
  93,
  93,
  93,
  93,
  157,
  93,
  93,
  93,
  93,
  20,
  27,
  28,
  29,
  30,
  0,
  32,
  121,
  33,
  0,
  9,
  110,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  9,
  0,
  0,
  107,
  121,
  34,
  106,
  48,
  35,
  105,
  112,
  36,
  37,
  65,
  48,
  0,
  38,
  9,
  110,
  9,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  107,
  48,
  49,
  106,
  0,
  0,
  105,
  112,
  0,
  48,
  0,
  0,
  65,
  151,
  152,
  153,
  154,
  155,
  48,
  0,
  114,
  50,
  51,
  52,
  0,
  0,
  116,
  53,
  54,
  55,
  56,
  57,
  58,
  113,
  59,
  60,
  61,
  166,
  27,
  28,
  29,
  30,
  31,
  32,
  48,
  33,
  114,
  0,
  48,
  48,
  48,
  48,
  116,
  0,
  0,
  0,
  0,
  0,
  48,
  113,
  0,
  34,
  93,
  115,
  35,
  0,
  0,
  36,
  37,
  106,
  0,
  4,
  38,
  4,
  4,
  4,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  115,
  0,
  0,
  0,
  107,
  0,
  0,
  0,
  4,
  0,
  4,
  0,
  0,
  41,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  130,
  32,
  108,
  33,
  0,
  0,
  52,
  109,
  110,
  111,
  0,
  0,
  0,
  0,
  0,
  0,
  112,
  0,
  0,
  34,
  49,
  0,
  35,
  0,
  0,
  36,
  37,
  49,
  0,
  0,
  38,
  0,
  0,
  0,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  0,
  0,
  0,
  0,
  49,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  0,
  49,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  131,
  32,
  49,
  33,
  0,
  0,
  49,
  49,
  49,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  49,
  0,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  38,
  0,
  0,
  116,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  0,
  48,
  49,
  0,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  0,
  0,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  0,
  32,
  0,
  33,
  0,
  11,
  0,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  11,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  38,
  11,
  0,
  11,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  210,
  48,
  49,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  54,
  55,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  30,
  0,
  32,
  0,
  33,
  12,
  0,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  12,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  12,
  0,
  12,
  0,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  211,
  48,
  49,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  50,
  51,
  52,
  0,
  0,
  0,
  53,
  0,
  0,
  56,
  57,
  58,
  0,
  59,
  60,
  61,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  167,
  87,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  0,
  59,
  60,
  0,
  0,
  0,
  0,
  27,
  28,
  29,
  59,
  60,
  32,
  0,
  167,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  34,
  0,
  0,
  35,
  75,
  76,
  36,
  37,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  77,
  78,
  79,
  80,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  0,
  0,
  0,
  50,
  51,
  52,
  0,
  0,
  59,
  60,
  0,
  0,
  56,
  57,
  58,
  0,
  59,
  60,
  27,
  28,
  29,
  0,
  0,
  32,
  0,
  33,
  13,
  0,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  13,
  0,
  34,
  0,
  0,
  35,
  0,
  0,
  36,
  37,
  0,
  0,
  0,
  13,
  0,
  13,
  0,
  0,
  0,
  41,
  42,
  43,
  44,
  45,
  46,
  2,
  0,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  0,
  50,
  51,
  52,
  0,
  2,
  0,
  2,
  0,
  0,
  0,
  64,
  0,
  0,
  59,
  60,
  32,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  0,
  0,
  0,
  0,
  64,
  64,
  64,
  64,
  0,
  64,
  0,
  0,
  6,
  64,
  6,
  6,
  6,
  6,
  6,
  0,
  0,
  0,
  0,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  64,
  0,
  0,
  0,
  6,
  64,
  6,
  0,
  29,
  64,
  64,
  64,
  64,
  0,
  0,
  33,
  0,
  0,
  0,
  64,
  31,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  16,
  33,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  33,
  16,
  0,
  0,
  33,
  33,
  33,
  33,
  0,
  0,
  0,
  0,
  0,
  17,
  33,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  17,
  14,
  17,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  14,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  14,
  15,
  14,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  15,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  15,
  214,
  15,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  238,
  0,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  243,
  0,
  0,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  208,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  216,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
__int16 word_80EFDE0[] = { 25 }; // weak
int dword_80F09C4 = 0; // idb
int dword_80F09C8 = 0; // weak
int dword_80F09CC = 1; // weak
int dword_80F09D0 = 0; // weak
FILE *dword_80F09D4 = NULL; // idb
FILE *dword_80F09D8 = NULL; // idb
char *off_80F09DC = "1.1.4"; // weak
int dword_80F09E0 = 9; // weak
int dword_80F09E4 = 5; // weak
_UNKNOWN unk_80F0A00; // weak
_UNKNOWN unk_80F1A00; // weak
int dword_80F1B00[17] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
}; // idb
void *off_80F1B44 = &unk_80E4CC0; // weak
void *off_80F1B58 = &unk_80E5140; // weak
_UNKNOWN unk_80F1B6C; // weak
char *off_80F1B90[5] =
{
  "stream error",
  "data error",
  "insufficient memory",
  "buffer error",
  "incompatible version"
}; // weak
char *off_80F1B98[3] = { "insufficient memory", "buffer error", "incompatible version" }; // weak
char *off_80F1B9C[2] = { "buffer error", "incompatible version" }; // weak
char *dword_80F1C00 = NULL; // idb
int dword_80F1C04 = 0; // weak
__int16 word_80F1C08 = 0; // weak
__int16 word_80F1C0A = 0; // weak
int dword_80F1C0C = 0; // weak
int dword_80F1C10 = 1; // weak
__int16 word_80F1C18 = 0; // weak
int dword_80F1C20 = 1; // weak
int dword_80F1C24 = 0; // weak
int dword_80F1C28 = 0; // weak
int dword_80F1C2C = 0; // weak
int dword_80F1C30 = 0; // weak
int dword_80F1C34 = 0; // weak
int dword_80F1C38 = -1; // weak
int dword_80F1C3C = 0; // weak
char byte_80F1C40 = '\0'; // idb
int dword_80F2040 = 0; // weak
int dword_80F2044 = 0; // weak
int dword_80F204C = 0; // weak
_UNKNOWN unk_80F2078; // weak
int (*off_80F6324)() = &ctor_001; // weak
int dword_80F6338 = 0; // weak
Elf32_Dyn *off_80F633C = &stru_80F6230; // weak
FILE *stdout; // idb
FILE *stderr; // idb
int _ctype_b; // weak
int stdin; // weak
char byte_80F6550; // weak
_UNKNOWN unk_80F6554; // weak
int dword_80F656C; // weak
int dword_80F6580; // weak
int dword_80F65A0[]; // weak
int dword_80F65A4[]; // weak
int dword_80F65A8[]; // weak
int dword_80F65AC[]; // weak
int dword_80F65B0[]; // weak
float flt_810A5A0; // weak
float flt_810A5A4; // weak
int dword_810A5C0; // weak
char *src; // idb
_UNKNOWN unk_810ADE0; // weak
int dword_810CFE0; // weak
char byte_810D000; // idb
char byte_810F400[]; // weak
char dword_810F488[]; // idb
int dword_810F48C; // weak
char dword_810F490[]; // idb
char dword_810F494[]; // idb
char dword_810F498[]; // idb
int dword_810F49C; // weak
char dword_810F4A0[]; // idb
char dword_810F4A4[]; // idb
char dword_810F4A8[]; // idb
char dword_810F4AC[]; // idb
char byte_810F4C0[1024]; // idb
char *dword_810F8C0; // idb
int dword_810F8C8[256]; // idb
_UNKNOWN unk_810FCC8; // weak
_UNKNOWN unk_81100C8; // weak
void *dword_81104C8; // idb
int dword_81104CC; // weak
int dword_81104D0; // weak
int dword_81104D4[]; // weak
int dword_81104D8; // weak
int dword_81104DC; // weak
int dword_81104E0; // weak
char s1; // idb
int dword_8110524[]; // weak
int dword_8110540; // weak
int dword_8110544; // weak
int dword_8110548; // weak
int dword_8110550; // weak
struct __jmp_buf_tag env[1]; // idb
int dword_81105FC; // weak
int dword_8110600[]; // weak
int dword_8110604[]; // weak
int dword_8110608[]; // weak
int dword_811060C[]; // weak
int dword_8110610[]; // weak
int dword_8110614[]; // weak
char *dword_8111E00; // idb
char byte_8111E20; // idb
int dword_8112220; // weak
void *dword_8112224; // idb
_UNKNOWN unk_8112240; // weak
char byte_8129240[256]; // idb
__int16 word_8129340[1088]; // idb
__int16 word_8129BC0[1024]; // idb
int dword_812A3C0; // weak
char *dword_812A3C4; // idb
int dword_812A3C8; // idb
int (__cdecl *dword_812A3CC)(_DWORD); // weak
int dword_812A3E0; // weak
int dword_812A3E4; // weak
int dword_812A400[22528]; // idb
int dword_8140400[]; // weak
char byte_8140800; // idb
char byte_8140C00; // idb
_UNKNOWN unk_8142C00; // weak
char byte_8143100; // idb
char byte_8145100; // idb
char byte_8147100; // idb
char byte_8149100; // idb
char byte_814F100; // idb
char byte_8151100[1024]; // idb
FILE *stream; // idb
_UNKNOWN unk_8151520; // weak
_UNKNOWN unk_8153920; // weak
_DWORD dword_8153D20[7175]; // idb
_DWORD dword_815AD3C[2]; // idb
int dword_815AD44; // weak
char byte_8161D60[64]; // idb
int dword_81621A0; // weak
int dword_81621A4; // weak
int dword_81621A8; // weak
char byte_8162240[31999]; // idb
char byte_8169F3F; // weak
_UNKNOWN unk_8169F40; // weak
_UNKNOWN unk_8171C40; // weak
int (__cdecl *dword_8175C40)(_DWORD); // weak
int dword_8175C44; // weak
int dword_8175C48; // weak
int dword_8175C4C; // weak
int dword_8175C50; // weak
int dword_8175C54; // weak
int dword_8175C58; // weak
int dword_8175C5C; // weak
int dword_8175C60; // weak
_BYTE byte_8175C80[1024]; // idb
int dword_8176080; // weak
char byte_8176084; // weak
__int16 word_8176092; // weak
__int16 word_81760A0; // weak
int dword_81760A4; // weak
int dword_81760A8; // weak
int dword_81760AC; // weak
int dword_81760C0[256]; // idb
__int16 word_81764C0[256]; // idb
int dword_81766C0[]; // weak
int dword_81766C8; // weak
__int16 word_81766CC; // weak
int dword_81766D0; // weak
int dword_81766D4; // weak
int dword_81766D8; // weak
char byte_81766DC; // weak
int dword_81766E0; // weak
char byte_81766E4; // weak
void *dword_81766E8; // idb
void *dword_81766EC; // idb
int dword_81766F0; // weak
int dword_8176700; // weak
int dword_8176704; // weak
int dword_8176708; // weak
int dword_817670C; // weak
int dword_8176710; // weak
int dword_8176714; // weak
int dword_8176718; // weak
int dword_817671C; // weak
int dword_8176720; // weak
int dword_8176724; // weak
int dword_8176728; // weak
int dword_817672C; // weak
int dword_8176730; // weak
int dword_8176734; // weak
int dword_8176738; // weak
int dword_817673C; // weak
int dword_8176740; // weak
int dword_8176744; // weak
int dword_8176748; // weak
int dword_817674C; // weak
int dword_8176750; // weak
int dword_8176754; // weak
int dword_8176758; // weak
int dword_817675C; // weak
int dword_8176760; // weak
int dword_8176764; // weak
int dword_8176768; // weak
int dword_817676C; // weak
int dword_8176770; // weak
int dword_8176774; // weak
int dword_8176778; // weak
int dword_817677C; // weak
int dword_8176780; // weak
int dword_8176784; // weak
int dword_8176788; // weak
int dword_817678C; // weak
int dword_8176790; // weak
int dword_8176794; // weak
int dword_8176798; // weak
int dword_817679C; // weak
int dword_81767A0; // weak
int dword_81767A4; // weak
int dword_81767A8; // weak
int dword_81767AC; // weak
int dword_81767B0; // weak
int dword_81767B4; // weak
int dword_81767B8; // weak
int dword_81767BC; // weak
int dword_81767C0; // weak
int dword_81767C4; // weak
int dword_81767C8; // weak
int dword_81767CC; // weak
int dword_81767D0; // weak
int dword_81767D4; // weak
int dword_81767E0; // weak
int dword_81767E4; // weak
int dword_81767E8; // weak
int dword_81767EC; // weak
int dword_81767F0; // weak
int dword_81767F4; // weak
int dword_81767F8; // weak
int dword_81767FC; // weak
int dword_8176800; // weak
int dword_8176804; // weak
int dword_8176808; // weak
int dword_817680C; // weak
int dword_8176810; // weak
int dword_8176814; // weak
int dword_8176818; // weak
int dword_817681C; // weak
int dword_8176820; // weak
int dword_8176824; // weak
int dword_8176828; // weak
int dword_8176830; // weak
int dword_8176834; // weak
int dword_817683C; // weak
int dword_8176840; // weak
int dword_8176844; // weak
int dword_8176848; // weak
int dword_817684C; // weak
int dword_8176850; // weak
int dword_8176854; // weak
int dword_8176858; // weak
int dword_817685C; // weak
int dword_8176860; // weak
int dword_8176864; // weak
int dword_8176868; // weak
int dword_817686C; // weak
int dword_8176870; // weak
int dword_8176874; // weak
int dword_8176878; // weak
int dword_817687C; // weak
int dword_8176880; // weak
int dword_8176884; // weak
int dword_8176888; // weak
int dword_817688C; // weak
int dword_8176890; // weak
int dword_8176894; // weak
int (__cdecl *dword_8176898)(_DWORD, _DWORD); // weak
int (__cdecl *dword_817689C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_81768A0)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_81768A4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_81768A8)(_DWORD); // weak
char byte_81768AC; // weak
char byte_81768AD; // weak
__int16 word_81768AE; // weak
__int16 word_81768B0; // weak
__int16 word_81768B2; // weak
__int16 word_81768B4; // weak
int dword_81768B8; // weak
__int16 word_81768BC; // weak
int dword_81768C0; // weak
int dword_81768C4; // weak
int dword_81768C8; // weak
int dword_81768CC; // weak
int dword_81768E0[]; // weak
int dword_81768E4[131071]; // idb
int dword_81F68E0; // weak
int dword_81F68E4; // weak
int dword_81F68E8; // weak
int dword_81F68EC; // weak
__int16 word_81F6900[32]; // idb
_BYTE byte_81F6940[512]; // idb
char byte_81F6B40[256]; // idb
int dword_81F6C40; // weak
char dword_81F6C44[]; // idb
int dword_81F6C48; // weak
void *dword_81F6C4C; // idb
int dword_81F6C50; // weak
int dword_81F6C54[]; // weak
int dword_81F6C5C[]; // weak
int dword_81F6C60; // weak
int dword_81F6C64; // weak
int dword_81F6C68; // weak
int dword_81F6C6C; // weak
int dword_81F6C70; // weak
int dword_81F6C74; // weak
int dword_81F6C78; // weak
__int16 word_81F6C80[]; // weak
__int16 word_81F6C82[32767]; // idb
int dword_8206C80; // weak
int dword_8206CA0[]; // weak
int dword_8206CA4[]; // weak
__int16 word_8206CA8[]; // weak
__int16 word_8206CAA[393211]; // idb
__int16 word_82C6CA0[]; // weak
__int16 word_82C6CA2[131071]; // idb
int dword_8306CA0; // weak
int dword_8306CA4; // weak
__int16 word_8306CA8; // weak
void *dword_8306CAC; // idb
void *dword_8306CB0; // idb
char *dword_8306CB4; // idb
int scrVarPub; // weak
unsigned __int16 word_8306CC0[2]; // idb
int dword_8306CC4; // weak
int dword_8306CC8[4092]; // idb
_UNKNOWN unk_830ACB8; // weak
int dword_830ACC0; // weak
int dword_830ACC4; // weak
int dword_830ACE0[32]; // idb
int dword_830AD60; // weak
int dword_830AD64; // weak
int dword_830AD68; // weak
char byte_830AD6C; // weak
int dword_830AD70; // weak
int dword_830AD74; // weak
int dword_830AD78; // weak
int dword_830AD80[40]; // idb
int dword_830AE20; // weak
int dword_830AE24; // weak
int dword_830AE28; // weak
int dword_830AE2C; // weak
__int16 word_830AE30; // weak
__int16 word_830AE32; // weak
__int16 word_830AE34; // weak
__int16 word_830AE36; // weak
int dword_830AE38; // weak
int dword_830AE40; // weak
int dword_830AE44; // weak
int dword_830AE48; // weak
int dword_830AE4C; // idb
char byte_830AE50; // weak
int dword_830AE54; // weak
int dword_830AE58; // weak
int dword_830AE5C; // weak
int dword_830AE60; // weak
_DWORD dword_830AE80[5]; // idb
char byte_830AE94[12]; // idb
_UNKNOWN unk_830AEA0; // weak
int dword_830AFCC; // weak
int (__cdecl *dword_830AFD8)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_830AFDC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_830AFE0)(_DWORD, _DWORD, _DWORD); // weak
_UNKNOWN unk_830B000; // weak
__int16 word_830B008[]; // weak
__int16 word_830B00A[]; // weak
int dword_830B00C[]; // weak
int dword_830B010[]; // weak
__int16 word_830B014; // weak
__int16 word_830B016; // weak
_UNKNOWN unk_830B01C; // weak
_UNKNOWN unk_830B020; // weak
int dword_830B028; // weak
int dword_830B02C; // weak
__int16 word_830B030; // weak
__int16 word_830B032; // weak
float flt_832D000; // weak
float flt_832D004; // idb
float flt_832D008; // idb
float flt_832D00C; // weak
__int16 word_832D010; // weak
__int16 word_832D012; // weak
__int16 word_832D014; // weak
int dword_832D018; // weak
int dword_832D01C; // weak
int dword_832D020[]; // weak
char dword_832D030[15]; // idb
char byte_832D03F; // weak
int dword_832D040; // weak
int dword_832D044; // weak
int dword_832D048; // weak
__int16 word_832D04C; // weak
float flt_832D050; // weak
int dword_832D054; // weak
int dword_832D058; // weak
char byte_832D05C; // weak
int dword_832D060; // weak
_UNKNOWN unk_832D080; // weak
_DWORD dword_832D08C[381]; // idb
int dword_832D680; // weak
int dword_832D684; // weak
int dword_832D688; // weak
_WORD word_832D6A0[2]; // idb
_DWORD dword_832D6A4[2]; // idb
_UNKNOWN unk_832D6AC; // weak
int dword_832D6E0; // weak
_UNKNOWN unk_832D6E4; // weak
_UNKNOWN unk_832D74C; // weak
_UNKNOWN unk_832D764; // weak
_DWORD dword_832D770[10]; // idb
int dword_832D798; // weak
_DWORD dword_832D7A4[3]; // idb
_DWORD dword_832D7B0[3]; // idb
_UNKNOWN unk_832D7BC; // weak
_UNKNOWN unk_832D804; // weak
_WORD word_832D81E[3]; // idb
char byte_832D824; // weak
__int16 word_832D826; // weak
int dword_832D840; // weak
char byte_832D87C; // weak
float flt_832D880; // weak
char buf[256]; // idb
struct termios termios_p; // idb
int dword_832D9E0; // weak
_UNKNOWN unk_832D9E4; // weak
char byte_832D9FC; // idb
_DWORD dword_832DB00[2272]; // idb
int dword_832FEC0; // weak
int dword_832FEC4; // weak
char byte_832FEE0[]; // weak
char byte_832FEE1[]; // weak
char byte_832FEE2[]; // weak
char byte_832FEE3[61]; // idb
char byte_832FF20[255]; // idb
char byte_833001F; // weak
char byte_8330020[256]; // idb
char byte_8330120; // weak
char path; // idb
char s[1024]; // idb
int dword_8330720; // weak
int dword_8330724; // weak
char byte_8330740[64]; // idb
int dword_8330780; // weak
int dword_8330784; // weak
int dword_8330788; // weak
void *dword_833078C; // idb
int dword_8330790; // weak
int dword_8330794; // weak
int dword_8330798; // weak
int dword_833079C; // weak
int dword_83307A0; // weak
int dword_83307A4; // weak
int dword_83307A8; // weak
int dword_83307AC; // weak
int dword_83307B0; // weak
int dword_83307B4; // weak
int dword_83307B8; // weak
int dword_83307BC; // weak
char dword_83307C0[]; // idb
int dword_83307C4; // weak
int dword_83307C8; // weak
int dword_83307CC; // weak
int dword_83307D0; // weak
size_t dword_83307D4; // idb
void *dword_83307D8; // idb
int dword_83307DC; // weak
int dword_83307E0; // weak
void *dword_83307E4; // idb
int dword_83307E8; // weak
int dword_83307EC; // weak
int dword_83307F0; // weak
int dword_83307F4; // weak
int dword_83307F8; // weak
int dword_83307FC; // weak
int dword_8330800; // weak
float flt_8330804[]; // weak
float flt_8330808; // weak
float flt_8330810[]; // weak
float flt_8330814; // weak
int dword_833081C; // weak
int dword_8330820[]; // weak
int dword_8330824; // weak
int dword_8330828; // weak
int dword_833082C[]; // weak
int dword_8330830; // weak
int dword_8330834; // weak
int dword_833083C; // weak
__int16 word_8330840; // weak
int dword_8330848; // weak
float flt_8330858; // weak
int dword_8330868; // weak
int dword_833086C; // weak
int dword_8330870; // weak
_UNKNOWN unk_8330874; // weak
_UNKNOWN unk_833089C; // weak
int dword_83308B8[10230]; // idb
int dword_833A890; // weak
int dword_833A89C; // weak
int dword_833A8A8; // weak
int dword_833A8AC; // weak
_UNKNOWN unk_833A8C0; // weak
int dword_834A8C0; // weak
void *dest; // idb
int dword_834A8C8; // weak
size_t n; // idb
void *dword_834A8E0; // idb
int dword_834E8E0; // weak
int dword_834E8E4; // weak
int dword_834E900[]; // weak
int dword_834E904[]; // weak
int dword_834E908[]; // weak
int dword_834E90C[]; // weak
int dword_834E910[]; // weak
int dword_834E914[]; // weak
int dword_834E918[]; // weak
int dword_834E91C[4601]; // idb
char byte_8353100; // idb
int dword_8357200; // weak
int dword_8357220[4096]; // idb
int dword_835B220; // weak
int dword_835B224; // weak
int dword_835B228; // weak
int dword_835B22C; // weak
int dword_835B230; // weak
int dword_835B234; // weak
int dword_835B238; // weak
int dword_835B23C; // weak
int dword_835B240; // weak
int dword_835B244; // weak
int dword_835B248; // weak
void *dword_835B260; // idb
char byte_835F260; // idb
int dword_835F360; // weak
char byte_835F380[256]; // idb
int dword_835F480; // weak
int dword_835F484; // weak
int dword_835F488; // weak
int dword_835F4A0; // weak
int dword_835F4A4; // weak
int dword_835F4A8; // weak
int dword_835F4B0; // weak
int dword_835F4B4; // weak
int dword_835F4B8; // weak
int dword_835F4BC; // weak
char byte_835F4C0[4096]; // idb
int dword_83604C0; // weak
char dword_83604C8[]; // idb
int dword_83604CC; // weak
int dword_83604D0; // weak
char *dword_83604E0; // idb
int dword_8360560; // weak
int dword_8360564; // weak
int dword_8360568; // weak
char dword_8360570[]; // idb
int dword_8360574; // weak
int dword_8360578; // weak
int com_errorEntered_; // weak
int dword_836064C; // weak
char dword_8360650[]; // idb
int dword_8360654; // weak
int dword_8360658; // weak
int dword_836065C; // weak
int dword_8360660; // weak
int dword_8360664; // weak
int dword_836066C; // weak
int dword_8360670; // weak
char dword_8360674[]; // idb
int dword_8360678; // weak
int dword_836067C; // weak
int dword_83607A0; // weak
int dword_83607A4; // weak
char byte_83607C0; // idb
int dword_8360800; // weak
int dword_8360804; // weak
int dword_8360808; // weak
int dword_836080C; // weak
int dword_8360810; // weak
int dword_8360814; // weak
_UNKNOWN unk_8360820; // weak
int dword_836B7B0; // weak
int dword_836B7B4; // weak
int dword_836B7C0; // weak
int dword_836B7C4; // weak
int dword_836B7C8; // weak
int dword_836B7CC; // weak
int dword_836B7D0; // weak
int dword_836B7D4; // weak
int dword_836B7D8; // weak
int dword_836B7DC; // weak
int dword_836B7E0; // weak
int dword_836B7E4; // weak
int dword_836B7E8; // weak
int dword_836B7EC; // weak
int dword_836B7F0; // weak
int dword_836B7F4; // weak
int dword_836B7F8; // weak
int dword_836B7FC; // weak
int dword_836B800; // weak
int dword_836B804; // weak
int dword_836B808; // weak
int dword_836B80C; // weak
int sv; // weak
int dword_836B824; // weak
int dword_836B828; // weak
int dword_836B82C; // weak
int dword_836B830; // weak
char *dword_836BC38; // idb
_UNKNOWN unk_836DC40; // weak
int dword_836DD30[]; // weak
int dword_836DD34[]; // weak
int dword_836DD38[]; // weak
int dword_836DD3C[]; // weak
int dword_836DD40[]; // weak
int dword_836DD44[]; // weak
int dword_836DD48[]; // weak
int dword_836DD4C[97211]; // idb
int dword_83CCC38; // weak
int dword_83CCC3C; // weak
int dword_83CCC40; // weak
int dword_83CCC44; // weak
int dword_83CCC48; // weak
int dword_83CCC4C; // weak
int dword_83CCC50[]; // weak
int dword_83CCC54[18]; // idb
int dword_83CCC9C; // weak
int dword_83CCCA0; // weak
int dword_83CCCA4; // weak
int dword_83CCCA8; // weak
int dword_83CCCAC[]; // weak
int dword_83CCCB0[18]; // idb
int dword_83CCCF8; // weak
int dword_83CCCFC; // weak
int dword_83CCD00; // weak
float flt_83CCD04; // weak
int dword_83CCD08; // weak
char byte_83CCD0C[64]; // idb
int dword_83CCD4C; // weak
int dword_83CCD50; // weak
int dword_83CCD54; // weak
int dword_83CCD58; // weak
int dword_83CCD5C; // weak
int dword_83CCD60; // weak
int dword_83CCD64; // weak
int dword_83CCD68; // weak
int dword_83CCD6C; // weak
int dword_83CCD70; // weak
int dword_83CCD74; // weak
int dword_83CCD78; // weak
int svs; // weak
int dword_83CCD84; // weak
int dword_83CCD88; // weak
int sv_serverId_value; // weak
void *dword_83CCD90; // idb
int dword_83CCD94; // weak
int dword_83CCD98; // weak
int dword_83CCD9C; // weak
int dword_83CCDA0; // weak
int dword_83CCDA4; // weak
int dword_83CCDA8; // weak
int dword_83CCDAC; // weak
int dword_83CCDB0; // weak
void *dword_83CCDB4; // idb
void *dword_83CCDB8; // idb
int dword_83CCDBC; // weak
int dword_83CCDC0; // weak
int dword_83CCDC4; // weak
int dword_83CCDC8; // weak
void *dword_83CCDCC; // idb
void *dword_83CCDD0; // idb
void *dword_83CCDD4; // idb
int dword_83CCDD8; // weak
int dword_83CCDDC; // weak
int dword_83CCDE0[]; // weak
int dword_83CCDE4[]; // weak
int dword_83CCDE8[]; // weak
int dword_83CCDEC[]; // weak
int dword_83CCDF0[]; // weak
int dword_83CCDF4[]; // weak
int dword_83CCDFC[]; // weak
int dword_83CCE04[]; // weak
int dword_83CCE08[]; // weak
int dword_83CCE0C[21493]; // idb
int dword_83E1DE0; // idb
int dword_83E1DE4; // idb
int dword_83E1DE8; // idb
int dword_83E1DEC; // idb
int dword_83E1DF0; // idb
int dword_83E1DF4; // idb
int dword_83E1DF8; // idb
char dword_83E1DFC[]; // idb
int dword_83E1E00; // idb
int unk_83E1E04; // idb
__int16 word_83E1E06; // weak
int dword_83E1E08; // weak
int dword_83E1E0C[]; // weak
int dword_83E1E10[31]; // idb
int dword_83E1E8C; // weak
int dword_83E1E90; // weak
_UNKNOWN unk_83E1EA0; // weak
char byte_83E1EA4[]; // weak
int dword_83E1F28[78]; // idb
int dword_83E2060; // weak
char *dword_83E2064; // idb
int dword_83E2068; // weak
int dword_83E206C; // weak
int dword_83E2070; // weak
int dword_83E2074; // weak
int dword_83E2078; // weak
size_t size; // idb
_WORD word_83E2080[499]; // idb
_UNKNOWN unk_83E2466; // weak
int dword_83E246C; // weak
int dword_83E2470; // weak
_UNKNOWN unk_83E2480; // weak
int dword_83E3420; // weak
int dword_83E3524; // weak
int dword_83E3540[]; // weak
int dword_83E3544[]; // weak
int dword_83E3548[]; // weak
int dword_83E354C[]; // weak
int dword_83E3550[]; // weak
int dword_83E3554[]; // weak
_UNKNOWN unk_83E4D60; // weak
int dword_83E8D60; // weak
int dword_83E8D78; // weak
int dword_83E8D7C; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (0804970C) --------------------------------------------------------
void init_proc(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_8049F50();
  sub_80D6210();
}
// 8049E7C: using guessed type int __gmon_start__(void);

//----- (0804973C) --------------------------------------------------------
void sub_804973C()
{
  JUMPOUT(0);
}
// 8049742: control flows out of bounds to 0

//----- (08049EC0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, init_proc, term_proc, a2, &v3);
  __halt();
}
// 8049EC3: positive sp value 4 has been found

//----- (08049EF0) --------------------------------------------------------
void sub_8049EF0()
{
  int (**v0)(); // eax
  void (*i)(void); // edx

  if ( !byte_80F6550 )
  {
    v0 = off_80E8C28;
    for ( i = (void (*)(void))*off_80E8C28; *off_80E8C28; i = (void (*)(void))*off_80E8C28 )
    {
      off_80E8C28 = v0 + 1;
      i();
      v0 = off_80E8C28;
    }
    if ( __deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_80F2078);
    byte_80F6550 = 1;
  }
}
// 804991C: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// 80E8C28: using guessed type int (**off_80E8C28)();
// 80F6550: using guessed type char byte_80F6550;

//----- (08049F50) --------------------------------------------------------
int sub_8049F50()
{
  int result; // eax

  if ( __register_frame_info_bases )
    __register_frame_info_bases(&unk_80F2078, &unk_80F6554, 0, &off_80F633C);
  result = dword_80F6338;
  if ( dword_80F6338 )
    result = 0;
  return result;
}
// 8049B4C: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 80F6338: using guessed type int dword_80F6338;
// 80F633C: using guessed type Elf32_Dyn *off_80F633C;

//----- (08049FB0) --------------------------------------------------------
char *sub_8049FB0()
{
  sprintf(s, "%d %s %s", 650, "Nov 15 2004", "10:34:24");
  return s;
}

//----- (08049FEC) --------------------------------------------------------
int __cdecl CMod_LoadShaders(_DWORD *a1)
{
  int result; // eax
  signed int v2; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]

  src = (char *)(dword_833A89C + a1[1]);
  if ( *a1 % 0x48u )
    Com_Error(1, (char *)&byte_80D62A0);
  v2 = *a1 / 0x48u;
  if ( v2 <= 0 )
    Com_Error(1, (char *)&byte_80D62C3);
  dword_833078C = (char *)sub_806C482(72 * v2 + 72) + 72;
  dword_8330788 = v2;
  sub_80D2FC8(dword_833078C, src, 72 * v2);
  result = sub_804BF29(1);
  if ( result != 1 )
  {
    v4 = dword_833078C;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v2 )
        break;
      v4[17] = sub_804BF29(v4[17]);
      v4[16] = sub_804BF29(v4[16]);
      src += 72;
      v4 += 18;
    }
  }
  return result;
}
// 8330788: using guessed type int dword_8330788;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804A11D) --------------------------------------------------------
signed int __cdecl CMod_LoadSubmodels(_DWORD *a1)
{
  signed int result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  _DWORD *v5; // [esp+18h] [ebp-20h]
  signed int v6; // [esp+1Ch] [ebp-1Ch]
  int j; // [esp+20h] [ebp-18h]
  int k; // [esp+20h] [ebp-18h]
  signed int i; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int *v11; // [esp+2Ch] [ebp-Ch]

  v11 = (int *)(dword_833A89C + a1[1]);
  if ( *a1 % 0x30u )
    Com_Error(1, (char *)&byte_80D62E0);
  v6 = *a1 / 0x30u;
  if ( v6 <= 0 )
    Com_Error(1, (char *)&byte_80D6305);
  dword_83307C4 = (int)sub_806C482(40 * v6);
  *(_DWORD *)dword_83307C0 = v6;
  if ( v6 > 512 )
    Com_Error(1, (char *)&byte_80D6319);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v10 = dword_83307C4 + 40 * i;
    for ( j = 0; j <= 2; ++j )
    {
      *(float *)(v10 + 4 * j) = sub_804BF31(*(float *)&v11[j]) - 1.0;
      *(float *)(v10 + 4 * j + 12) = sub_804BF31(*(float *)&v11[j + 3]) + 1.0;
    }
    if ( i )
    {
      v4 = sub_804BF29(v11[11]);
      *(_WORD *)(v10 + 32) = v4;
      if ( *(unsigned __int16 *)(v10 + 32) != v4 )
        Com_Error(1, (char *)&byte_80D6340);
      v5 = sub_806C482(4 * v4);
      *(_DWORD *)(v10 + 28) = ((int)v5 - dword_83307B4) >> 2;
      for ( k = 0; k < v4; ++k )
        v5[k] = k + sub_804BF29(v11[10]);
      v3 = sub_804BF29(v11[9]);
      *(_WORD *)(v10 + 36) = v3;
      if ( *(unsigned __int16 *)(v10 + 36) != v3 )
        Com_Error(1, (char *)&byte_80D6380);
      v2 = sub_804BF29(v11[8]);
      *(_WORD *)(v10 + 34) = v2;
      if ( *(unsigned __int16 *)(v10 + 34) != v2 )
        Com_Error(1, (char *)&byte_80D63C0);
    }
    v11 += 12;
  }
  return result;
}
// 83307B4: using guessed type int dword_83307B4;
// 83307C4: using guessed type int dword_83307C4;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804A38A) --------------------------------------------------------
signed int __cdecl CMod_LoadNodes(_DWORD *a1)
{
  signed int result; // eax
  signed int v2; // [esp+Ch] [ebp-1Ch]
  int j; // [esp+10h] [ebp-18h]
  signed int i; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]

  v7 = (int *)(dword_833A89C + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, (char *)&byte_80D6400);
  v2 = *a1 / 0x24u;
  if ( v2 <= 0 )
    Com_Error(1, (char *)&byte_80D6421);
  dword_83307A4 = (int)sub_806C482(8 * v2);
  dword_83307A0 = v2;
  v5 = (_DWORD *)dword_83307A4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v5 = dword_833079C + 20 * sub_804BF29(*v7);
    for ( j = 0; j <= 1; ++j )
    {
      v6 = sub_804BF29(v7[j + 1]);
      *((_WORD *)v5 + j + 2) = v6;
      if ( *((__int16 *)v5 + j + 2) != v6 )
        Com_Error(1, (char *)&byte_80D6440);
    }
    v5 += 2;
    v7 += 9;
  }
  return result;
}
// 833079C: using guessed type int dword_833079C;
// 83307A0: using guessed type int dword_83307A0;
// 83307A4: using guessed type int dword_83307A4;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804A4D7) --------------------------------------------------------
int __cdecl CMod_LoadBrushes(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  _DWORD *v3; // [esp+14h] [ebp-44h]
  _DWORD *v4; // [esp+1Ch] [ebp-3Ch]
  int k; // [esp+24h] [ebp-34h]
  int v6; // [esp+2Ch] [ebp-2Ch]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8; // [esp+30h] [ebp-28h]
  int v9; // [esp+34h] [ebp-24h]
  int j; // [esp+38h] [ebp-20h]
  signed int l; // [esp+38h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-1Ch]
  _DWORD *v13; // [esp+40h] [ebp-18h]
  unsigned int *v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  __int16 *v16; // [esp+4Ch] [ebp-Ch]

  v16 = (__int16 *)(dword_833A89C + a1[1]);
  if ( (*a1 & 3) != 0 )
    Com_Error(1, (char *)&byte_80D6480);
  v9 = *a1 >> 2;
  v15 = dword_833A89C + a2[1];
  if ( (*a2 & 7) != 0 )
    Com_Error(1, (char *)&byte_80D6480);
  v8 = (*a2 >> 3) - 6 * v9;
  if ( v8 < 0 )
    Com_Error(1, (char *)&byte_80D64C0);
  if ( v8 )
    v4 = sub_806C482(8 * v8);
  else
    v4 = 0;
  dword_8330794 = (int)v4;
  dword_8330790 = v8;
  v13 = v4;
  dword_83307CC = (int)sub_806C482(52 * v9 + 52);
  dword_83307C8 = v9;
  v14 = (unsigned int *)dword_83307CC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v9 )
      break;
    v14[7] = sub_804BF29(*v16) - 6;
    if ( (v14[7] & 0x80000000) != 0 )
      Com_Error(1, (char *)&byte_80D6500);
    if ( v14[7] )
      v3 = v13;
    else
      v3 = 0;
    v14[8] = (unsigned int)v3;
    for ( j = 0; j <= 2; ++j )
    {
      for ( k = 0; k <= 1; ++k )
      {
        *(float *)&v14[3 * k + 1 + j] = sub_804BF31(*(float *)v15);
        v6 = sub_804BF29(*(_DWORD *)(v15 + 4));
        if ( v6 < 0 || v6 >= dword_8330788 )
          Com_Error(1, (char *)&byte_80D6540, v6);
        *((_WORD *)v14 + 3 * k + j + 20) = v6;
        if ( *((__int16 *)v14 + 3 * k + j + 20) != v6 )
          Com_Error(1, (char *)&byte_80D6580);
        v15 += 8;
      }
    }
    for ( l = 0; l < (int)v14[7]; ++l )
    {
      *v13 = dword_833079C + 20 * sub_804BF29(*(_DWORD *)v15);
      v13[1] = sub_804BF29(*(_DWORD *)(v15 + 4));
      if ( (int)v13[1] < 0 || v13[1] >= dword_8330788 )
        Com_Error(1, (char *)&byte_80D6540, v13[1]);
      v15 += 8;
      v13 += 2;
    }
    v7 = sub_804BF29(v16[1]);
    if ( v7 < 0 || v7 >= dword_8330788 )
      Com_Error(1, (char *)&byte_80D6540, v7);
    *v14 = *((_DWORD *)dword_833078C + 18 * v7 + 17) & 0xDFFF7FFB;
    v14 += 13;
    v16 += 2;
  }
  return result;
}
// 8330788: using guessed type int dword_8330788;
// 8330790: using guessed type int dword_8330790;
// 8330794: using guessed type int dword_8330794;
// 833079C: using guessed type int dword_833079C;
// 83307C8: using guessed type int dword_83307C8;
// 83307CC: using guessed type int dword_83307CC;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804A86A) --------------------------------------------------------
void *__cdecl CMod_LoadLeafs(_DWORD *a1)
{
  void *result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  signed int v8; // [esp+24h] [ebp-14h]
  int *v9; // [esp+28h] [ebp-10h]
  __int16 *v10; // [esp+2Ch] [ebp-Ch]
  signed int i; // [esp+30h] [ebp-8h]

  v9 = (int *)(dword_833A89C + a1[1]);
  if ( *a1 % 0x24u )
    Com_Error(1, (char *)&byte_80D65C0);
  v8 = *a1 / 0x24u;
  if ( v8 <= 0 )
    Com_Error(1, (char *)&byte_80D65E1);
  dword_83307AC = (int)sub_806C482(16 * v8);
  dword_83307A8 = v8;
  v10 = (__int16 *)dword_83307AC;
  for ( i = 0; i < v8; ++i )
  {
    v7 = v9[6];
    v10[7] = v7;
    if ( v10[7] != v7 )
      Com_Error(1, (char *)&byte_80D6600);
    v6 = sub_804BF29(*v9);
    *v10 = v6;
    if ( *v10 != v6 )
      Com_Error(1, (char *)&byte_80D6640);
    v5 = sub_804BF29(v9[1]);
    v10[1] = v5;
    if ( v10[1] != v5 )
      Com_Error(1, (char *)&byte_80D6680);
    *((_DWORD *)v10 + 1) = sub_804BF29(v9[4]);
    v4 = sub_804BF29(v9[5]);
    v10[4] = v4;
    if ( (unsigned __int16)v10[4] != v4 )
      Com_Error(1, (char *)&byte_80D66A0);
    v3 = sub_804BF29(v9[2]);
    v10[5] = v3;
    if ( (unsigned __int16)v10[5] != v3 )
      Com_Error(1, (char *)&byte_80D66E0);
    v2 = sub_804BF29(v9[3]);
    v10[6] = v2;
    if ( (unsigned __int16)v10[6] != v2 )
      Com_Error(1, (char *)&byte_80D6720);
    if ( v6 >= dword_83307D0 )
      dword_83307D0 = v6 + 1;
    if ( v5 >= dword_83307E8 )
      dword_83307E8 = v5 + 1;
    v9 += 9;
    v10 += 8;
  }
  dword_83307EC = (int)sub_806C482(8 * dword_83307E8);
  result = sub_806C482(4 * dword_83307E8 * dword_83307E8);
  dword_83307F0 = (int)result;
  return result;
}
// 83307A8: using guessed type int dword_83307A8;
// 83307AC: using guessed type int dword_83307AC;
// 83307D0: using guessed type int dword_83307D0;
// 83307E8: using guessed type int dword_83307E8;
// 83307EC: using guessed type int dword_83307EC;
// 83307F0: using guessed type int dword_83307F0;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804AB01) --------------------------------------------------------
int __cdecl CMod_LoadPlanes(_DWORD *a1)
{
  int result; // eax
  char v2; // [esp+13h] [ebp-25h]
  char v3; // [esp+1Bh] [ebp-1Dh]
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v5 = dword_833A89C + a1[1];
  if ( (*a1 & 0xF) != 0 )
    Com_Error(1, (char *)&byte_80D6400);
  v4 = *a1 >> 4;
  if ( !v4 )
    Com_Error(1, (char *)&byte_80D674A);
  dword_833079C = (int)sub_806C482(20 * v4);
  dword_8330798 = v4;
  v6 = dword_833079C;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v4 )
      break;
    v3 = 0;
    for ( j = 0; j <= 2; ++j )
    {
      *(float *)(v6 + 4 * j) = sub_804BF31(*(float *)(v5 + 4 * j));
      if ( *(float *)(v6 + 4 * j) < 0.0 )
        v3 |= 1 << j;
    }
    *(float *)(v6 + 12) = sub_804BF31(*(float *)(v5 + 12));
    if ( *(float *)v6 == 1.0 )
    {
      v2 = 0;
    }
    else if ( *(float *)(v6 + 4) == 1.0 )
    {
      v2 = 1;
    }
    else if ( *(float *)(v6 + 8) == 1.0 )
    {
      v2 = 2;
    }
    else
    {
      v2 = 3;
    }
    *(_BYTE *)(v6 + 16) = v2;
    *(_BYTE *)(v6 + 17) = v3;
    v5 += 16;
    v6 += 20;
  }
  return result;
}
// 8330798: using guessed type int dword_8330798;
// 833079C: using guessed type int dword_833079C;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804AC94) --------------------------------------------------------
int __cdecl CMod_LoadLeafBrushes(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int *v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = (int *)(dword_833A89C + a1[1]);
  if ( (*a1 & 3) != 0 )
    Com_Error(1, (char *)&byte_80D6400);
  v2 = *a1 >> 2;
  dword_83307B4 = (int)sub_806C482(4 * v2 + 4);
  dword_83307B0 = v2;
  v4 = (int *)dword_83307B4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v4++ = sub_804BF29(*v3++);
  }
  return result;
}
// 83307B0: using guessed type int dword_83307B0;
// 83307B4: using guessed type int dword_83307B4;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804AD34) --------------------------------------------------------
int __cdecl CMod_LoadLeafSurfaces(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int *v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v3 = (int *)(dword_833A89C + a1[1]);
  if ( (*a1 & 3) != 0 )
    Com_Error(1, (char *)&byte_80D6760);
  v2 = *a1 >> 2;
  dword_83307BC = (int)sub_806C482(4 * v2);
  dword_83307B8 = v2;
  v4 = (int *)dword_83307BC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    *v4++ = sub_804BF29(*v3++);
  }
  return result;
}
// 83307B8: using guessed type int dword_83307B8;
// 83307BC: using guessed type int dword_83307BC;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804ADD1) --------------------------------------------------------
int __cdecl CMod_LoadLeafCurvesAndTerrain(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4; // eax
  float *v5; // ebx
  float *v6; // ebx
  float *v7; // ebx
  int v8; // eax
  int v9; // ebx
  int v10; // ebx
  int v11; // eax
  float *v12; // ebx
  float *v13; // ebx
  float *v14; // ebx
  int v15; // ebx
  int v16; // eax
  __int16 *v17; // [esp+2Ch] [ebp-3005Ch]
  __int16 v18[49158]; // [esp+30h] [ebp-30058h] BYREF
  int v19; // [esp+1803Ch] [ebp-1804Ch]
  _DWORD v20[24578]; // [esp+18040h] [ebp-18048h] BYREF
  signed int v21; // [esp+30048h] [ebp-40h]
  float *v22; // [esp+3004Ch] [ebp-3Ch]
  int v23; // [esp+30050h] [ebp-38h]
  int v24; // [esp+30054h] [ebp-34h]
  int v25; // [esp+30058h] [ebp-30h]
  int v26; // [esp+3005Ch] [ebp-2Ch]
  int v27; // [esp+30060h] [ebp-28h]
  int v28; // [esp+30064h] [ebp-24h]
  unsigned int v29; // [esp+30068h] [ebp-20h]
  int v30; // [esp+3006Ch] [ebp-1Ch]
  int v31; // [esp+30070h] [ebp-18h]
  int v32; // [esp+30074h] [ebp-14h]
  int v33; // [esp+30078h] [ebp-10h]
  int v34; // [esp+3007Ch] [ebp-Ch]
  _DWORD v35[2]; // [esp+30080h] [ebp-8h] BYREF

  v34 = dword_833A89C + a1[1];
  if ( (*a1 & 0xF) != 0 )
    Com_Error(1, (char *)&byte_80D67A0);
  v30 = *a1 >> 4;
  v32 = dword_833A89C + a2[1];
  if ( *a2 % 0xCu )
    Com_Error(1, (char *)&byte_80D67A0);
  v29 = *a2 / 0xCu;
  v31 = dword_833A89C + a3[1];
  if ( (*a3 & 1) != 0 )
    Com_Error(1, (char *)&byte_80D67A0);
  v28 = *a3 >> 1;
  dword_83307F4 = v30;
  dword_83307F8 = (int)sub_806C482(44 * v30);
  v33 = dword_83307F8;
  v27 = 0;
  while ( 1 )
  {
    result = v27;
    if ( v27 >= v30 )
      break;
    v25 = (__int16)sub_804BF16(*(_WORD *)v34);
    *(_DWORD *)v33 = 0;
    *(_DWORD *)(v33 + 4) = v25;
    *(_DWORD *)(v33 + 8) = *((_DWORD *)dword_833078C + 18 * v25 + 17);
    if ( *(_BYTE *)(v34 + 2) )
    {
      v21 = (__int16)sub_804BF16(*(_WORD *)(v34 + 4));
      if ( (unsigned int)v21 > 0x2000 )
        Com_Error(1, (char *)&byte_80D67E0, 0x2000);
      v4 = sub_804BF29(*(_DWORD *)(v34 + 8));
      v22 = (float *)(v32 + 12 * v4);
      v26 = 0;
      while ( v26 < v21 )
      {
        v5 = (float *)&v20[3 * v26];
        *v5 = sub_804BF31(*v22);
        v6 = (float *)&v35[3 * v26 - 24591];
        *v6 = sub_804BF31(v22[1]);
        v7 = (float *)&v35[3 * v26 - 24590];
        *v7 = sub_804BF31(v22[2]);
        ++v26;
        v22 += 3;
      }
      v19 = (__int16)sub_804BF16(*(_WORD *)(v34 + 6));
      if ( (unsigned int)v19 > 0xC000 )
        Com_Error(1, (char *)&byte_80D6820, 49152);
      v8 = sub_804BF29(*(_DWORD *)(v34 + 12));
      v17 = (__int16 *)(v31 + 2 * v8);
      v26 = 0;
      while ( v26 < v19 )
      {
        v9 = v26;
        v18[v9] = sub_804BF16(*v17);
        ++v26;
        ++v17;
      }
      *(_DWORD *)(v33 + 36) = 0;
      v10 = v33;
      *(_DWORD *)(v10 + 40) = sub_8054176(v19, (int)v18, v21, (int)v20, v33 + 12);
    }
    else
    {
      v24 = (__int16)sub_804BF16(*(_WORD *)(v34 + 4));
      v23 = (__int16)sub_804BF16(*(_WORD *)(v34 + 6));
      v21 = v23 * v24;
      if ( (unsigned int)(v23 * v24) > 0x2000 )
        Com_Error(1, (char *)&byte_80D6880, 0x2000);
      v11 = sub_804BF29(*(_DWORD *)(v34 + 12));
      v22 = (float *)(v32 + 12 * v11);
      v26 = 0;
      while ( v26 < v21 )
      {
        v12 = (float *)&v20[3 * v26];
        *v12 = sub_804BF31(*v22);
        v13 = (float *)&v35[3 * v26 - 24591];
        *v13 = sub_804BF31(v22[1]);
        v14 = (float *)&v35[3 * v26 - 24590];
        *v14 = sub_804BF31(v22[2]);
        ++v26;
        v22 += 3;
      }
      v15 = v33;
      v16 = sub_804BF29(*(_DWORD *)(v34 + 8));
      *(_DWORD *)(v15 + 36) = sub_804F60B(v24, v23, v16, (int)v20, (float *)(v33 + 12));
      *(_DWORD *)(v33 + 40) = 0;
    }
    if ( (v30 & 3) == 3 )
      sub_80D3C7C();
    ++v27;
    v34 += 16;
    v33 += 44;
  }
  return result;
}
// 83307F4: using guessed type int dword_83307F4;
// 83307F8: using guessed type int dword_83307F8;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804B296) --------------------------------------------------------
void *__cdecl CMod_LoadEntityString(size_t *a1)
{
  dword_83307E4 = sub_806C482(*a1);
  dword_83307E0 = *a1;
  return sub_80D2FC8(dword_83307E4, (void *)(dword_833A89C + a1[1]), *a1);
}
// 83307E0: using guessed type int dword_83307E0;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804B2E0) --------------------------------------------------------
void *__cdecl CMod_LoadVisibility(size_t *a1)
{
  void *result; // eax
  int *v2; // [esp+10h] [ebp-8h]
  size_t v3; // [esp+14h] [ebp-4h]

  v3 = *a1;
  if ( *a1 )
  {
    v2 = (int *)(dword_833A89C + a1[1]);
    dword_83307DC = 1;
    dword_83307D8 = sub_806C482(v3);
    dword_83307D0 = sub_804BF29(*v2);
    dword_83307D4 = sub_804BF29(v2[1]);
    result = sub_80D2FC8(dword_83307D8, v2 + 2, v3 - 8);
  }
  else
  {
    dword_83307D4 = (dword_83307D0 + 31) & 0xFFFFFFE0;
    dword_83307D8 = sub_806C482((dword_83307D0 + 31) & 0xFFFFFFE0);
    result = sub_80D2FE9(dword_83307D8, 255, dword_83307D4);
  }
  return result;
}
// 83307D0: using guessed type int dword_83307D0;
// 83307DC: using guessed type int dword_83307DC;
// 833A89C: using guessed type int dword_833A89C;

//----- (0804B3A9) --------------------------------------------------------
char *__cdecl CM_LoadMap(char *src, int a2, int a3)
{
  char *result; // eax
  char *v4; // eax
  int v5; // edx
  char *v6; // eax
  unsigned int v7; // [esp+14h] [ebp-184h]
  char *v8; // [esp+18h] [ebp-180h]
  char *v9; // [esp+1Ch] [ebp-17Ch]
  char dest[76]; // [esp+20h] [ebp-178h] BYREF
  int v11; // [esp+6Ch] [ebp-12Ch]
  int v12; // [esp+70h] [ebp-128h] BYREF
  char v13[4]; // [esp+74h] [ebp-124h] BYREF
  int v14[4]; // [esp+78h] [ebp-120h] BYREF
  int v15; // [esp+88h] [ebp-110h] BYREF
  int v16; // [esp+90h] [ebp-108h] BYREF
  int v17[32]; // [esp+98h] [ebp-100h] BYREF
  int v18; // [esp+118h] [ebp-80h] BYREF
  int v19; // [esp+120h] [ebp-78h] BYREF
  int v20; // [esp+128h] [ebp-70h] BYREF
  int v21; // [esp+130h] [ebp-68h] BYREF
  int v22; // [esp+138h] [ebp-60h] BYREF
  int v23; // [esp+140h] [ebp-58h] BYREF
  int v24; // [esp+148h] [ebp-50h] BYREF
  int v25; // [esp+150h] [ebp-48h] BYREF
  size_t v26[2]; // [esp+158h] [ebp-40h] BYREF
  size_t v27[10]; // [esp+160h] [ebp-38h] BYREF
  unsigned int i; // [esp+188h] [ebp-10h]
  void *v29; // [esp+18Ch] [ebp-Ch] BYREF

  if ( !src || !*src )
    Com_Error(1, (char *)&byte_80D68BE);
  Q_strncpyz(dest, src, 64);
  dword_8330720 = (int)Cvar_Get("cm_noCurves", "0", 512);
  dword_8330724 = (int)Cvar_Get("cm_playerCurveClip", "1", 513);
  Com_DPrintf("CM_LoadMap( %s, %i )\n", dest, a2);
  if ( a2 && *(_DWORD *)(dword_8360560 + 32) )
  {
    result = (char *)dword_80F656C;
    *(_DWORD *)a3 = dword_80F656C;
  }
  else
  {
    sub_80D2FE9(byte_8330740, 0, 0xA15Cu);
    v11 = FS_ReadFile(dest, (int)&v29);
    if ( !v29 )
    {
      v4 = va(aExeErrCouldntL, dest);
      Com_Error(1, v4);
    }
    dword_80F656C = sub_807F851(v29, v11);
    *(_DWORD *)a3 = dword_80F656C;
    v9 = (char *)&v12;
    v8 = (char *)v29;
    v7 = 272;
    if ( ((unsigned __int8)&v12 & 4) != 0 )
    {
      v12 = *(_DWORD *)v29;
      v9 = v13;
      v8 = (char *)v29 + 4;
      v7 = 268;
    }
    qmemcpy(v9, v8, 4 * (v7 >> 2));
    for ( i = 0; i <= 0x43; ++i )
    {
      v5 = sub_804BF29(*(&v12 + i));
      *(&v12 + i) = v5;
    }
    if ( *(_DWORD *)v13 != 59 )
    {
      v6 = va(aExeErrWrongMap, dest, *(_DWORD *)v13, 59);
      Com_Error(1, v6);
    }
    dword_833A89C = (int)v29;
    CMod_LoadShaders(v14);
    CMod_LoadPlanes(&v15);
    CMod_LoadBrushes(v17, &v16);
    CMod_LoadNodes(&v18);
    CMod_LoadLeafs(&v19);
    CMod_LoadLeafBrushes(&v20);
    CMod_LoadLeafSurfaces(&v21);
    CMod_LoadLeafCurvesAndTerrain(&v22, &v23, &v24);
    CMod_LoadSubmodels(&v25);
    CMod_LoadVisibility(v26);
    CMod_LoadEntityString(v27);
    FS_FreeFile(v29);
    CM_InitBoxHull();
    CM_FloodAreaConnections();
    CM_ClearWorld();
    result = CM_LoadStaticModels();
    if ( !a2 )
      result = Q_strncpyz(byte_8330740, dest, 64);
  }
  return result;
}
// 80F656C: using guessed type int dword_80F656C;
// 8330720: using guessed type int dword_8330720;
// 8330724: using guessed type int dword_8330724;
// 833A89C: using guessed type int dword_833A89C;
// 8360560: using guessed type int dword_8360560;

//----- (0804BBD8) --------------------------------------------------------
int *__cdecl sub_804BBD8(int a1)
{
  if ( a1 < 0 )
    Com_Error(1, (char *)&byte_80D6980, a1);
  if ( a1 < *(int *)dword_83307C0 )
    return (int *)(dword_83307C4 + 40 * a1);
  if ( a1 != 511 && a1 != 510 )
  {
    if ( a1 <= 511 )
      Com_Error(1, (char *)&byte_80D69C0, *(_DWORD *)dword_83307C0, a1, 512);
    Com_Error(1, (char *)&byte_80D6980, a1 + 512);
  }
  return dword_8330820;
}
// 83307C4: using guessed type int dword_83307C4;
// 8330820: using guessed type int dword_8330820[];

//----- (0804BCA0) --------------------------------------------------------
int __cdecl sub_804BCA0(int a1)
{
  if ( a1 < 0 || a1 >= *(int *)dword_83307C0 )
    Com_Error(1, (char *)&byte_80D69EF);
  return a1;
}

//----- (0804BCE6) --------------------------------------------------------
void *sub_804BCE6()
{
  return dword_83307E4;
}

//----- (0804BCF0) --------------------------------------------------------
int __cdecl sub_804BCF0(int a1)
{
  return *(__int16 *)(dword_83307AC + 16 * a1);
}
// 83307AC: using guessed type int dword_83307AC;

//----- (0804BD06) --------------------------------------------------------
int __cdecl sub_804BD06(int a1)
{
  return *(__int16 *)(dword_83307AC + 16 * a1 + 2);
}
// 83307AC: using guessed type int dword_83307AC;

//----- (0804BD1D) --------------------------------------------------------
int CM_InitBoxHull()
{
  int result; // eax

  dword_833081C = dword_83307CC + 52 * dword_83307C8;
  *(_DWORD *)(dword_83307CC + 52 * dword_83307C8 + 28) = 0;
  *(_DWORD *)(dword_833081C + 32) = 0;
  *(_DWORD *)dword_833081C = -1;
  *(_WORD *)(dword_833081C + 40) = -1;
  *(_WORD *)(dword_833081C + 42) = -1;
  *(_WORD *)(dword_833081C + 44) = -1;
  *(_WORD *)(dword_833081C + 46) = -1;
  *(_WORD *)(dword_833081C + 48) = -1;
  *(_WORD *)(dword_833081C + 50) = -1;
  word_8330840 = 1;
  dword_833083C = dword_83307B0;
  result = dword_83307C8;
  *(_DWORD *)(dword_83307B4 + 4 * dword_83307B0) = dword_83307C8;
  return result;
}
// 83307B0: using guessed type int dword_83307B0;
// 83307B4: using guessed type int dword_83307B4;
// 83307C8: using guessed type int dword_83307C8;
// 83307CC: using guessed type int dword_83307CC;
// 833081C: using guessed type int dword_833081C;
// 833083C: using guessed type int dword_833083C;
// 8330840: using guessed type __int16 word_8330840;

//----- (0804BDD3) --------------------------------------------------------
int __cdecl sub_804BDD3(int *a1, int *a2, int a3, int a4)
{
  int v5; // [esp+0h] [ebp-4h]

  dword_8330820 = *a1;
  dword_8330824 = a1[1];
  dword_8330828 = a1[2];
  dword_833082C = *a2;
  dword_8330830 = a2[1];
  dword_8330834 = a2[2];
  *(_DWORD *)(dword_833081C + 4) = *a1;
  *(_DWORD *)(dword_833081C + 8) = a1[1];
  *(_DWORD *)(dword_833081C + 12) = a1[2];
  *(_DWORD *)(dword_833081C + 16) = *a2;
  *(_DWORD *)(dword_833081C + 20) = a2[1];
  *(_DWORD *)(dword_833081C + 24) = a2[2];
  *(_DWORD *)dword_833081C = a3;
  if ( a4 )
    v5 = 510;
  else
    v5 = 511;
  return v5;
}
// 833081C: using guessed type int dword_833081C;
// 8330820: using guessed type int dword_8330820;
// 8330824: using guessed type int dword_8330824;
// 8330828: using guessed type int dword_8330828;
// 833082C: using guessed type int dword_833082C;
// 8330830: using guessed type int dword_8330830;
// 8330834: using guessed type int dword_8330834;

//----- (0804BEA7) --------------------------------------------------------
int sub_804BEA7()
{
  return *(_DWORD *)dword_833081C;
}
// 833081C: using guessed type int dword_833081C;

//----- (0804BEB3) --------------------------------------------------------
int __cdecl sub_804BEB3(int a1, int *a2, _DWORD *a3)
{
  int *v3; // eax
  int result; // eax

  v3 = sub_804BBD8(a1);
  *a2 = *v3;
  a2[1] = v3[1];
  a2[2] = v3[2];
  *a3 = v3[3];
  a3[1] = v3[4];
  result = v3[5];
  a3[2] = result;
  return result;
}

//----- (0804BF16) --------------------------------------------------------
int __cdecl sub_804BF16(__int16 a1)
{
  return a1;
}

//----- (0804BF29) --------------------------------------------------------
int __cdecl sub_804BF29(int a1)
{
  return a1;
}

//----- (0804BF31) --------------------------------------------------------
long double __cdecl sub_804BF31(float a1)
{
  return a1;
}

//----- (0804BF44) --------------------------------------------------------
int __cdecl sub_804BF44(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a1 + 4 * i) < 0.0 )
      v3 |= 1 << i;
  }
  return v3;
}

//----- (0804BF99) --------------------------------------------------------
int __cdecl sub_804BF99(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  v7[0] = *a3 - *a2;
  v7[1] = a3[1] - a2[1];
  v7[2] = a3[2] - a2[2];
  v6[0] = *a4 - *a2;
  v6[1] = a4[1] - a2[1];
  v6[2] = a4[2] - a2[2];
  sub_80667A1(v6, v7, a1);
  if ( sub_8066845(a1) == 0.0 )
    return 0;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return 1;
}

//----- (0804C083) --------------------------------------------------------
_BOOL4 __cdecl sub_804C083(int a1, int a2, int a3, int a4)
{
  float v5; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  float v7; // [esp+1Ch] [ebp-1Ch]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]

  for ( i = 0; i <= 2; ++i )
    *(&v8 + i) = *(float *)(a1 + 4 * i) + *(float *)(a3 + 4 * i) - (*(float *)(a2 + 4 * i) + *(float *)(a2 + 4 * i));
  v5 = sqrt(v8 * v8 + v9 * v9 + v10 * v10);
  v7 = v5 * 0.25;
  return v7 > (long double)a4;
}

//----- (0804C123) --------------------------------------------------------
int *__cdecl sub_804C123(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int *result; // eax
  int i; // [esp+0h] [ebp-10h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a4 + 4 * i) = (*(float *)(a1 + 4 * i) + *(float *)(a2 + 4 * i)) * 0.5;
    *(float *)(a6 + 4 * i) = (*(float *)(a2 + 4 * i) + *(float *)(a3 + 4 * i)) * 0.5;
    *(float *)(a5 + 4 * i) = (*(float *)(a4 + 4 * i) + *(float *)(a6 + 4 * i)) * 0.5;
    result = &i;
  }
  return result;
}

//----- (0804C1F8) --------------------------------------------------------
int __cdecl sub_804C1F8(int *a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+24h] [ebp-14h]
  int l; // [esp+28h] [ebp-10h]
  int j; // [esp+28h] [ebp-10h]
  int k; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( *a1 <= a1[1] )
  {
    for ( i = 0; i < *a1; ++i )
    {
      for ( j = i + 1; j < a1[1]; ++j )
      {
        if ( j >= *a1 )
        {
          a1[387 * j + 4 + 3 * i] = a1[387 * i + 4 + 3 * j];
          a1[387 * j + 5 + 3 * i] = a1[387 * i + 5 + 3 * j];
          a1[387 * j + 6 + 3 * i] = a1[387 * i + 6 + 3 * j];
        }
        else
        {
          v4 = a1[387 * j + 4 + 3 * i];
          v6 = a1[387 * j + 5 + 3 * i];
          v8 = a1[387 * j + 6 + 3 * i];
          a1[387 * j + 4 + 3 * i] = a1[387 * i + 4 + 3 * j];
          a1[387 * j + 5 + 3 * i] = a1[387 * i + 5 + 3 * j];
          a1[387 * j + 6 + 3 * i] = a1[387 * i + 6 + 3 * j];
          a1[387 * i + 4 + 3 * j] = v4;
          a1[387 * i + 5 + 3 * j] = v6;
          a1[387 * i + 6 + 3 * j] = v8;
        }
      }
    }
  }
  else
  {
    for ( k = 0; k < a1[1]; ++k )
    {
      for ( l = k + 1; l < *a1; ++l )
      {
        if ( l >= a1[1] )
        {
          a1[387 * k + 4 + 3 * l] = a1[387 * l + 4 + 3 * k];
          a1[387 * k + 5 + 3 * l] = a1[387 * l + 5 + 3 * k];
          a1[387 * k + 6 + 3 * l] = a1[387 * l + 6 + 3 * k];
        }
        else
        {
          v3 = a1[387 * k + 4 + 3 * l];
          v5 = a1[387 * k + 5 + 3 * l];
          v7 = a1[387 * k + 6 + 3 * l];
          a1[387 * k + 4 + 3 * l] = a1[387 * l + 4 + 3 * k];
          a1[387 * k + 5 + 3 * l] = a1[387 * l + 5 + 3 * k];
          a1[387 * k + 6 + 3 * l] = a1[387 * l + 6 + 3 * k];
          a1[387 * l + 4 + 3 * k] = v3;
          a1[387 * l + 5 + 3 * k] = v5;
          a1[387 * l + 6 + 3 * k] = v7;
        }
      }
    }
  }
  v9 = *a1;
  *a1 = a1[1];
  a1[1] = v9;
  v2 = a1[2];
  a1[2] = a1[3];
  result = v2;
  a1[3] = v2;
  return result;
}

//----- (0804C82F) --------------------------------------------------------
_DWORD *__cdecl sub_804C82F(_DWORD *a1)
{
  _DWORD *result; // eax
  float v2; // [esp+0h] [ebp-18h]
  int j; // [esp+4h] [ebp-14h]
  int i; // [esp+8h] [ebp-10h]

  for ( i = 0; i < a1[1]; ++i )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v2 = *(float *)&a1[3 * i + 4 + j] - *(float *)&a1[387 * *a1 - 383 + 3 * i + j];
      if ( v2 < -0.1 || v2 > 0.1 )
        break;
    }
    if ( j != 3 )
      break;
  }
  result = a1;
  a1[2] = i == a1[1];
  return result;
}

//----- (0804C905) --------------------------------------------------------
int __cdecl sub_804C905(_DWORD *a1, int a2)
{
  int result; // eax
  int v3[4]; // [esp+20h] [ebp-48h] BYREF
  int v4[4]; // [esp+30h] [ebp-38h] BYREF
  int v5[5]; // [esp+40h] [ebp-28h] BYREF
  int j; // [esp+54h] [ebp-14h]
  int i; // [esp+58h] [ebp-10h]
  int v8; // [esp+5Ch] [ebp-Ch]

  v8 = 0;
  while ( 1 )
  {
    result = *a1 - 2;
    if ( v8 >= result )
      break;
    for ( i = 0;
          i < a1[1]
       && !sub_804C083(
             (int)&a1[387 * v8 + 4 + 3 * i],
             (int)&a1[387 * v8 + 391 + 3 * i],
             (int)&a1[387 * v8 + 778 + 3 * i],
             a2);
          ++i )
    {
      ;
    }
    if ( i == a1[1] )
    {
      v8 += 2;
    }
    else
    {
      for ( i = 0; i < a1[1]; ++i )
      {
        v5[0] = a1[387 * v8 + 4 + 3 * i];
        v5[1] = a1[387 * v8 + 5 + 3 * i];
        v5[2] = a1[387 * v8 + 6 + 3 * i];
        v4[0] = a1[387 * v8 + 391 + 3 * i];
        v4[1] = a1[387 * v8 + 392 + 3 * i];
        v4[2] = a1[387 * v8 + 393 + 3 * i];
        v3[0] = a1[387 * v8 + 778 + 3 * i];
        v3[1] = a1[387 * v8 + 779 + 3 * i];
        v3[2] = a1[387 * v8 + 780 + 3 * i];
        for ( j = *a1 - 1; j > v8 + 1; --j )
        {
          a1[387 * j + 778 + 3 * i] = a1[387 * j + 4 + 3 * i];
          a1[387 * j + 779 + 3 * i] = a1[387 * j + 5 + 3 * i];
          a1[387 * j + 780 + 3 * i] = a1[387 * j + 6 + 3 * i];
        }
        sub_804C123(
          (int)v5,
          (int)v4,
          (int)v3,
          (int)&a1[387 * v8 + 391 + 3 * i],
          (int)&a1[387 * v8 + 778 + 3 * i],
          (int)&a1[387 * v8 + 1165 + 3 * i]);
      }
      *a1 += 2;
    }
  }
  return result;
}

//----- (0804CD1C) --------------------------------------------------------
_BOOL4 __cdecl sub_804CD1C(float *a1, float *a2)
{
  float v4; // [esp+4h] [ebp-4h]
  float v5; // [esp+4h] [ebp-4h]
  float v6; // [esp+4h] [ebp-4h]

  v4 = *a1 - *a2;
  if ( v4 < -0.1 || v4 > 0.1 )
    return 0;
  v5 = a1[1] - a2[1];
  if ( v5 < -0.1 || v5 > 0.1 )
    return 0;
  v6 = a1[2] - a2[2];
  return v6 >= -0.1 && v6 <= 0.1;
}

//----- (0804CDEB) --------------------------------------------------------
int __cdecl sub_804CDEB(int *a1)
{
  int result; // eax
  int l; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int k; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = *a1 - 1;
    if ( i >= result )
      break;
    for ( j = 0; j < a1[1] && sub_804CD1C((float *)&a1[387 * i + 4 + 3 * j], (float *)&a1[387 * i + 391 + 3 * j]); ++j )
      ;
    if ( j == a1[1] )
    {
      for ( k = 0; k < a1[1]; ++k )
      {
        for ( l = i + 2; l < *a1; ++l )
        {
          a1[387 * l - 383 + 3 * k] = a1[387 * l + 4 + 3 * k];
          a1[387 * l - 382 + 3 * k] = a1[387 * l + 5 + 3 * k];
          a1[387 * l - 381 + 3 * k] = a1[387 * l + 6 + 3 * k];
        }
      }
      --*a1;
      --i;
    }
  }
  return result;
}

//----- (0804CFCC) --------------------------------------------------------
int __cdecl sub_804CFCC(float *a1, float *a2, _DWORD *a3)
{
  int v4; // [esp+Ch] [ebp-1Ch]

  if ( fabs(*a1 - *a2) >= 0.0001
    || fabs(a1[1] - a2[1]) >= 0.0001
    || fabs(a1[2] - a2[2]) >= 0.0001
    || fabs(a1[3] - a2[3]) >= 0.02 )
  {
    if ( fabs(*a1 - COERCE_FLOAT(*(_DWORD *)a2 ^ 0x80000000)) >= 0.0001
      || fabs(a1[1] - COERCE_FLOAT(*((_DWORD *)a2 + 1) ^ 0x80000000)) >= 0.0001
      || fabs(a1[2] - COERCE_FLOAT(*((_DWORD *)a2 + 2) ^ 0x80000000)) >= 0.0001
      || fabs(a1[3] - COERCE_FLOAT(*((_DWORD *)a2 + 3) ^ 0x80000000)) >= 0.02 )
    {
      v4 = 0;
    }
    else
    {
      *a3 = 1;
      v4 = 1;
    }
  }
  else
  {
    *a3 = 0;
    v4 = 1;
  }
  return v4;
}

//----- (0804D121) --------------------------------------------------------
int *__cdecl sub_804D121(int *a1)
{
  int *result; // eax
  int i; // [esp+0h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    if ( fabs(*(float *)&a1[i] - 1.0) < 0.0001 )
    {
      a1[2] = 0;
      a1[1] = 0;
      *a1 = 0;
      result = a1;
      a1[i] = 1065353216;
      return result;
    }
    if ( fabs(*(float *)&a1[i] - -1.0) < 0.0001 )
    {
      a1[2] = 0;
      a1[1] = 0;
      *a1 = 0;
      result = a1;
      a1[i] = -1082130432;
      return result;
    }
    result = &i;
  }
  return result;
}

//----- (0804D1F8) --------------------------------------------------------
int __cdecl sub_804D1F8(int a1, _DWORD *a2)
{
  int v2; // ebx
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_80F6580; ++i )
  {
    if ( sub_804CFCC((float *)&dword_80F65A0[5 * i], (float *)a1, a2) )
      return i;
  }
  if ( dword_80F6580 == 4096 )
    Com_Error(1, (char *)&byte_80D6A64);
  dword_80F65A0[5 * dword_80F6580] = *(_DWORD *)a1;
  dword_80F65A4[5 * dword_80F6580] = *(_DWORD *)(a1 + 4);
  dword_80F65A8[5 * dword_80F6580] = *(_DWORD *)(a1 + 8);
  dword_80F65AC[5 * dword_80F6580] = *(_DWORD *)(a1 + 12);
  v2 = 5 * dword_80F6580;
  dword_80F65B0[v2] = sub_804BF44(a1);
  ++dword_80F6580;
  *a2 = 0;
  return dword_80F6580 - 1;
}
// 80F6580: using guessed type int dword_80F6580;
// 80F65A0: using guessed type int dword_80F65A0[];
// 80F65A4: using guessed type int dword_80F65A4[];
// 80F65A8: using guessed type int dword_80F65A8[];
// 80F65AC: using guessed type int dword_80F65AC[];
// 80F65B0: using guessed type int dword_80F65B0[];

//----- (0804D342) --------------------------------------------------------
int __cdecl sub_804D342(float *a1, float *a2, float *a3)
{
  int v3; // ebx
  float v6; // [esp+18h] [ebp-20h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h] BYREF
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( !sub_804BF99((float *)&v10, a1, a2, a3) )
    return -1;
  for ( i = 0; i < dword_80F6580; ++i )
  {
    if ( *(float *)&v10 * *(float *)&dword_80F65A0[5 * i]
       + *(float *)&v11 * *(float *)&dword_80F65A4[5 * i]
       + *(float *)&v12 * *(float *)&dword_80F65A8[5 * i] >= 0.0 )
    {
      v6 = *a1 * *(float *)&dword_80F65A0[5 * i]
         + a1[1] * *(float *)&dword_80F65A4[5 * i]
         + a1[2] * *(float *)&dword_80F65A8[5 * i]
         - *(float *)&dword_80F65AC[5 * i];
      if ( v6 >= -0.1 && v6 <= 0.1 )
      {
        v7 = *a2 * *(float *)&dword_80F65A0[5 * i]
           + a2[1] * *(float *)&dword_80F65A4[5 * i]
           + a2[2] * *(float *)&dword_80F65A8[5 * i]
           - *(float *)&dword_80F65AC[5 * i];
        if ( v7 >= -0.1 && v7 <= 0.1 )
        {
          v8 = *a3 * *(float *)&dword_80F65A0[5 * i]
             + a3[1] * *(float *)&dword_80F65A4[5 * i]
             + a3[2] * *(float *)&dword_80F65A8[5 * i]
             - *(float *)&dword_80F65AC[5 * i];
          if ( v8 >= -0.1 && v8 <= 0.1 )
            return i;
        }
      }
    }
  }
  if ( dword_80F6580 == 4096 )
    Com_Error(1, (char *)&byte_80D6A64);
  dword_80F65A0[5 * dword_80F6580] = v10;
  dword_80F65A4[5 * dword_80F6580] = v11;
  dword_80F65A8[5 * dword_80F6580] = v12;
  dword_80F65AC[5 * dword_80F6580] = v13;
  v3 = 5 * dword_80F6580;
  dword_80F65B0[v3] = sub_804BF44((int)&v10);
  return dword_80F6580++;
}
// 80F6580: using guessed type int dword_80F6580;
// 80F65A0: using guessed type int dword_80F65A0[];
// 80F65A4: using guessed type int dword_80F65A4[];
// 80F65A8: using guessed type int dword_80F65A8[];
// 80F65AC: using guessed type int dword_80F65AC[];
// 80F65B0: using guessed type int dword_80F65B0[];

//----- (0804D677) --------------------------------------------------------
int __cdecl sub_804D677(float *a1, int a2)
{
  float v4; // [esp+4h] [ebp-8h]

  if ( a2 == -1 )
    return 2;
  v4 = *a1 * *(float *)&dword_80F65A0[5 * a2]
     + a1[1] * *(float *)&dword_80F65A0[5 * a2 + 1]
     + a1[2] * *(float *)&dword_80F65A0[5 * a2 + 2]
     - *(float *)&dword_80F65A0[5 * a2 + 3];
  if ( v4 > 0.1 )
    return 0;
  if ( v4 >= -0.1 )
    return 2;
  return 1;
}
// 80F65A0: using guessed type int dword_80F65A0[];

//----- (0804D727) --------------------------------------------------------
int __cdecl sub_804D727(int a1, int a2, int a3, int a4)
{
  int *v5; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 4 * (a4 + 2 * (a3 + 129 * a2))) != -1 )
    return *(_DWORD *)(a1 + 4 * (a4 + 2 * (a3 + 129 * a2)));
  v5 = (int *)(8 * (a3 + 129 * a2) + a1);
  if ( !a4 )
    ++v5;
  if ( *v5 == -1 )
    v6 = -1;
  else
    v6 = *v5;
  return v6;
}

//----- (0804D7B0) --------------------------------------------------------
int __cdecl sub_804D7B0(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp+18h] [ebp-30h]
  int v7; // [esp+1Ch] [ebp-2Ch]
  int v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+20h] [ebp-28h] BYREF
  float v10; // [esp+24h] [ebp-24h]
  float v11; // [esp+28h] [ebp-20h]
  float *v12; // [esp+38h] [ebp-10h]
  float *v13; // [esp+3Ch] [ebp-Ch]

  switch ( a5 )
  {
    case 0:
      v13 = (float *)(12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (float *)(12 * a4 + a1 + 1548 * a3 + 1564);
      v7 = sub_804D727(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      return -1;
    case 1:
      v13 = (float *)(12 * a4 + a1 + 1548 * a3 + 1564);
      v12 = (float *)(a1 + 12 * a4 + 1548 * a3 + 1576);
      v7 = sub_804D727(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      return -1;
    case 2:
      v13 = (float *)(a1 + 12 * a4 + 1548 * a3 + 28);
      v12 = (float *)(a1 + 12 * a4 + 1548 * a3 + 1576);
      v8 = sub_804D727(a2, a3, a4, 1);
      if ( v8 >= 0 )
        goto LABEL_7;
      return -1;
    case 3:
      v13 = (float *)(12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (float *)(a1 + 12 * a4 + 1548 * a3 + 28);
      v8 = sub_804D727(a2, a3, a4, 1);
      if ( v8 < 0 )
        return -1;
LABEL_7:
      v9 = *(float *)&dword_80F65A0[5 * v8] * 4.0 + *v13;
      v10 = *(float *)&dword_80F65A4[5 * v8] * 4.0 + v13[1];
      v11 = *(float *)&dword_80F65A8[5 * v8] * 4.0 + v13[2];
      return sub_804D342(v12, v13, &v9);
    case 4:
      v13 = (float *)(a1 + 12 * a4 + 1548 * a3 + 1576);
      v12 = (float *)(12 * a4 + a1 + 1548 * a3 + 16);
      v7 = sub_804D727(a2, a3, a4, 0);
      if ( v7 >= 0 )
        goto LABEL_19;
      v6 = -1;
      break;
    case 5:
      v13 = (float *)(12 * a4 + a1 + 1548 * a3 + 16);
      v12 = (float *)(a1 + 12 * a4 + 1548 * a3 + 1576);
      v7 = sub_804D727(a2, a3, a4, 1);
      if ( v7 >= 0 )
      {
LABEL_19:
        v9 = *(float *)&dword_80F65A0[5 * v7] * 4.0 + *v13;
        v10 = *(float *)&dword_80F65A4[5 * v7] * 4.0 + v13[1];
        v11 = *(float *)&dword_80F65A8[5 * v7] * 4.0 + v13[2];
        v6 = sub_804D342(v13, v12, &v9);
      }
      else
      {
        v6 = -1;
      }
      break;
    default:
      Com_Error(1, (char *)&byte_80D6AA0);
  }
  return v6;
}
// 80F65A0: using guessed type int dword_80F65A0[];
// 80F65A4: using guessed type int dword_80F65A4[];
// 80F65A8: using guessed type int dword_80F65A8[];

//----- (0804DE63) --------------------------------------------------------
int __cdecl sub_804DE63(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h]
  int v13; // [esp+38h] [ebp-20h]
  int v14; // [esp+3Ch] [ebp-1Ch]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( a6 )
  {
    if ( a6 > 0 )
    {
      if ( a6 != 1 )
LABEL_10:
        Com_Error(0, (char *)&byte_80D6AE0);
      v11 = a2 + 12 * a5 + 1548 * a4 + 1576;
      v12 = a2 + 12 * a5 + 1548 * a4 + 28;
      v13 = 12 * a5 + a2 + 1548 * a4 + 16;
      v10 = 3;
    }
    else
    {
      if ( a6 != -1 )
        goto LABEL_10;
      v11 = 12 * a5 + a2 + 1548 * a4 + 16;
      v12 = 12 * a5 + a2 + 1548 * a4 + 1564;
      v13 = a2 + 12 * a5 + 1548 * a4 + 1576;
      v14 = a2 + 12 * a5 + 1548 * a4 + 28;
      v10 = 4;
    }
  }
  else
  {
    v11 = 12 * a5 + a2 + 1548 * a4 + 16;
    v12 = 12 * a5 + a2 + 1548 * a4 + 1564;
    v13 = a2 + 12 * a5 + 1548 * a4 + 1576;
    v10 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a1 + 4) )
      break;
    v9 = 0;
    v8 = 0;
    for ( j = 0; j < v10; ++j )
    {
      v7 = sub_804D677((float *)*(&v11 + j), *(_DWORD *)(a1 + 4 * i + 8));
      if ( v7 )
      {
        if ( v7 == 1 )
          ++v8;
      }
      else
      {
        ++v9;
      }
    }
    if ( !v9 || v8 )
    {
      if ( !v8 || v9 )
      {
        if ( v9 || v8 )
        {
          Com_DPrintf("WARNING: CM_SetBorderInward: mixed plane sides\n");
          *(_DWORD *)(a1 + 4 * i + 112) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 4 * i + 8) = -1;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 4 * i + 112) = 0;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4 * i + 112) = 1;
    }
  }
  return result;
}

//----- (0804E12C) --------------------------------------------------------
int __cdecl sub_804E12C(_DWORD *a1)
{
  float v3[3]; // [esp+20h] [ebp-48h] BYREF
  float v4[7]; // [esp+2Ch] [ebp-3Ch] BYREF
  void *ptr; // [esp+48h] [ebp-20h] BYREF
  int i; // [esp+4Ch] [ebp-1Ch]
  int v7; // [esp+50h] [ebp-18h] BYREF
  int v8; // [esp+54h] [ebp-14h]
  int v9; // [esp+58h] [ebp-10h]
  float v10; // [esp+5Ch] [ebp-Ch]

  if ( *a1 == -1 )
    return 0;
  v7 = dword_80F65A0[5 * *a1];
  v8 = dword_80F65A4[5 * *a1];
  v9 = dword_80F65A8[5 * *a1];
  LODWORD(v10) = dword_80F65AC[5 * *a1];
  ptr = sub_8051CDF((int)&v7, v10);
  for ( i = 0; i < a1[1] && ptr; ++i )
  {
    if ( a1[i + 2] == -1 )
    {
      sub_8051624(ptr);
      return 0;
    }
    v7 = dword_80F65A0[5 * a1[i + 2]];
    v8 = dword_80F65A4[5 * a1[i + 2]];
    v9 = dword_80F65A8[5 * a1[i + 2]];
    LODWORD(v10) = dword_80F65AC[5 * a1[i + 2]];
    if ( !a1[i + 28] )
    {
      HIBYTE(v7) ^= 0x80u;
      HIBYTE(v8) ^= 0x80u;
      HIBYTE(v9) ^= 0x80u;
      HIBYTE(v10) ^= 0x80u;
    }
    sub_80528B5((int)&ptr, (int)&v7, v10, 0.1);
  }
  if ( !ptr )
    return 0;
  sub_8051AF6(ptr, v3, v4);
  sub_8051624(ptr);
  for ( i = 0; i <= 2; ++i )
  {
    if ( v4[i] - v3[i] > 131072.0 )
      return 0;
    if ( v3[i] >= 131072.0 )
      return 0;
    if ( v4[i] <= -131072.0 )
      return 0;
  }
  return 1;
}
// 80F65A0: using guessed type int dword_80F65A0[];
// 80F65A4: using guessed type int dword_80F65A4[];
// 80F65A8: using guessed type int dword_80F65A8[];
// 80F65AC: using guessed type int dword_80F65AC[];

//----- (0804E38B) --------------------------------------------------------
int __cdecl sub_804E38B(_DWORD *a1)
{
  int result; // eax
  int v2; // ebx
  int v3; // ebx
  char v4; // [esp+4h] [ebp-D4h]
  char v5; // [esp+4h] [ebp-D4h]
  char v6; // [esp+4h] [ebp-D4h]
  int v7; // [esp+2Ch] [ebp-ACh]
  char v8[4]; // [esp+30h] [ebp-A8h] BYREF
  int v9; // [esp+34h] [ebp-A4h]
  int v10; // [esp+38h] [ebp-A0h]
  int v11[4]; // [esp+40h] [ebp-98h] BYREF
  float v12[4]; // [esp+50h] [ebp-88h] BYREF
  int v13[6]; // [esp+60h] [ebp-78h] BYREF
  void *ptr; // [esp+78h] [ebp-60h] BYREF
  void *src; // [esp+7Ch] [ebp-5Ch] BYREF
  char v16[4]; // [esp+80h] [ebp-58h] BYREF
  int v17; // [esp+84h] [ebp-54h]
  int v18; // [esp+88h] [ebp-50h]
  float v19; // [esp+8Ch] [ebp-4Ch]
  float v20; // [esp+9Ch] [ebp-3Ch]
  char v21[4]; // [esp+A0h] [ebp-38h] BYREF
  float v22; // [esp+A4h] [ebp-34h]
  float v23; // [esp+A8h] [ebp-30h]
  float v24; // [esp+ACh] [ebp-2Ch]
  char v25[4]; // [esp+B4h] [ebp-24h] BYREF
  int k; // [esp+B8h] [ebp-20h]
  int j; // [esp+BCh] [ebp-1Ch]
  int n; // [esp+C0h] [ebp-18h]
  int m; // [esp+C4h] [ebp-14h]
  int i; // [esp+C8h] [ebp-10h]
  int l; // [esp+CCh] [ebp-Ch]

  *(float *)v21 = *(float *)&dword_80F65A0[5 * *a1];
  v22 = *(float *)&dword_80F65A4[5 * *a1];
  v23 = *(float *)&dword_80F65A8[5 * *a1];
  v24 = *(float *)&dword_80F65AC[5 * *a1];
  src = sub_8051CDF((int)v21, v24);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a1[1] || !src )
      break;
    if ( a1[i + 2] != *a1 )
    {
      *(float *)v21 = *(float *)&dword_80F65A0[5 * a1[i + 2]];
      v22 = *(float *)&dword_80F65A4[5 * a1[i + 2]];
      v23 = *(float *)&dword_80F65A8[5 * a1[i + 2]];
      v24 = *(float *)&dword_80F65AC[5 * a1[i + 2]];
      if ( !a1[i + 28] )
      {
        v21[3] ^= 0x80u;
        HIBYTE(v22) ^= 0x80u;
        HIBYTE(v23) ^= 0x80u;
        HIBYTE(v24) ^= 0x80u;
      }
      sub_80528B5((int)&src, (int)v21, v24, 0.1);
    }
  }
  if ( src )
  {
    sub_8051AF6(src, v13, v12);
    for ( j = 0; j <= 2; ++j )
    {
      for ( k = -1; k <= 1; k += 2 )
      {
        v23 = 0.0;
        v22 = 0.0;
        *(float *)v21 = 0.0;
        *(float *)&v21[4 * j] = (float)k;
        if ( k == 1 )
          v24 = v12[j];
        else
          LODWORD(v24) = v13[j] ^ 0x80000000;
        if ( !sub_804CFCC((float *)&dword_80F65A0[5 * *a1], (float *)v21, v25) )
        {
          for ( l = 0; l < a1[1] && !sub_804CFCC((float *)&dword_80F65A0[5 * a1[l + 2]], (float *)v21, v25); ++l )
            ;
          if ( l == a1[1] )
          {
            if ( (int)a1[1] > 26 )
              Com_Printf("ERROR: too many bevels\n", v4);
            v2 = a1[1];
            a1[v2 + 2] = sub_804D1F8((int)v21, v25);
            a1[a1[1] + 54] = 0;
            a1[a1[1]++ + 28] = *(_DWORD *)v25;
          }
        }
      }
    }
    for ( i = 0; i < *(_DWORD *)src; ++i )
    {
      m = (i + 1) % *(_DWORD *)src;
      *(float *)v11 = *((float *)src + 3 * i + 1) - *((float *)src + 3 * m + 1);
      *(float *)&v11[1] = *((float *)src + 3 * i + 2) - *((float *)src + 3 * m + 2);
      *(float *)&v11[2] = *((float *)src + 3 * i + 3) - *((float *)src + 3 * m + 3);
      if ( sub_8066845((float *)v11) >= 0.5 )
      {
        sub_804D121(v11);
        for ( m = 0; m <= 2 && *(float *)&v11[m] != -1.0 && *(float *)&v11[m] != 1.0; ++m )
          ;
        if ( m > 2 )
        {
          for ( j = 0; j <= 2; ++j )
          {
            for ( k = -1; k <= 1; k += 2 )
            {
              v10 = 0;
              v9 = 0;
              *(_DWORD *)v8 = 0;
              *(float *)&v8[4 * j] = (float)k;
              sub_80667A1((float *)v11, (float *)v8, (float *)v21);
              if ( sub_8066845((float *)v21) >= 0.5 )
              {
                v24 = *((float *)src + 3 * i + 1) * *(float *)v21
                    + *((float *)src + 3 * i + 2) * v22
                    + *((float *)src + 3 * i + 3) * v23;
                v7 = 0;
                for ( n = 0; n < *(_DWORD *)src; ++n )
                {
                  v20 = *((float *)src + 3 * n + 1) * *(float *)v21
                      + *((float *)src + 3 * n + 2) * v22
                      + *((float *)src + 3 * n + 3) * v23
                      - v24;
                  if ( v20 > 0.1 )
                    break;
                  if ( v20 < -0.1 )
                    v7 = 1;
                }
                if ( n >= *(_DWORD *)src && v7 )
                {
                  for ( l = 0; l < a1[1] && !sub_804CFCC((float *)&dword_80F65A0[5 * a1[l + 2]], (float *)v21, v25); ++l )
                    ;
                  if ( l == a1[1] )
                  {
                    if ( (int)a1[1] > 26 )
                      Com_Printf("ERROR: too many bevels\n", v5);
                    v3 = a1[1];
                    a1[v3 + 2] = sub_804D1F8((int)v21, v25);
                    for ( m = 0; m < a1[1]; ++m )
                    {
                      if ( a1[a1[1] + 2] == a1[m + 2] )
                        Com_Printf("WARNING: bevel plane already used\n", v6);
                    }
                    a1[a1[1] + 54] = 0;
                    a1[a1[1] + 28] = *(_DWORD *)v25;
                    ptr = sub_8052013(src);
                    *(_DWORD *)v16 = dword_80F65A0[5 * a1[a1[1] + 2]];
                    v17 = dword_80F65A4[5 * a1[a1[1] + 2]];
                    v18 = dword_80F65A8[5 * a1[a1[1] + 2]];
                    LODWORD(v19) = dword_80F65AC[5 * a1[a1[1] + 2]];
                    if ( !a1[a1[1] + 28] )
                    {
                      v16[3] ^= 0x80u;
                      HIBYTE(v17) ^= 0x80u;
                      HIBYTE(v18) ^= 0x80u;
                      HIBYTE(v19) ^= 0x80u;
                    }
                    sub_80528B5((int)&ptr, (int)v16, v19, 0.1);
                    if ( ptr )
                    {
                      sub_8051624(ptr);
                      ++a1[1];
                    }
                    else
                    {
                      Com_DPrintf("WARNING: CM_AddFacetBevels... invalid bevel\n");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    sub_8051624(src);
    a1[a1[1] + 2] = *a1;
    a1[a1[1] + 54] = 0;
    a1[a1[1] + 28] = 1;
    result = (int)a1;
    ++a1[1];
  }
  return result;
}
// 804E63B: variable 'v4' is possibly undefined
// 804E9ED: variable 'v5' is possibly undefined
// 804EA45: variable 'v6' is possibly undefined
// 80F65A0: using guessed type int dword_80F65A0[];
// 80F65A4: using guessed type int dword_80F65A4[];
// 80F65A8: using guessed type int dword_80F65A8[];
// 80F65AC: using guessed type int dword_80F65AC[];

//----- (0804EBE6) --------------------------------------------------------
void *__cdecl sub_804EBE6(_DWORD *a1, int a2)
{
  int v2; // ebx
  int v3; // ebx
  _DWORD *v4; // ebx
  _DWORD *v5; // ebx
  _OWORD src[20480]; // [esp+20h] [ebp-70878h] BYREF
  int v8; // [esp+5002Ch] [ebp-2086Ch]
  _BOOL4 v9; // [esp+50030h] [ebp-20868h]
  _BOOL4 v10; // [esp+50034h] [ebp-20864h]
  _BOOL4 v11; // [esp+50038h] [ebp-20860h]
  _BOOL4 v12; // [esp+5003Ch] [ebp-2085Ch]
  int v13; // [esp+50040h] [ebp-20858h]
  int v14; // [esp+50044h] [ebp-20854h]
  int v15; // [esp+50048h] [ebp-20850h]
  int v16; // [esp+5004Ch] [ebp-2084Ch]
  int v17[2]; // [esp+50054h] [ebp-20844h]
  void *s; // [esp+5005Ch] [ebp-2083Ch]
  char v19[4]; // [esp+50060h] [ebp-20838h] BYREF
  int v20[33286]; // [esp+50064h] [ebp-20834h]
  float *v21; // [esp+7087Ch] [ebp-1Ch]
  float *v22; // [esp+70880h] [ebp-18h]
  float *v23; // [esp+70884h] [ebp-14h]
  int i; // [esp+70888h] [ebp-10h]
  char v25[4]; // [esp+7088Ch] [ebp-Ch]

  dword_80F6580 = 0;
  v8 = 0;
  *(_DWORD *)v25 = 0;
  while ( *(int *)v25 < *a1 - 1 )
  {
    for ( i = 0; i < a1[1] - 1; ++i )
    {
      v23 = (float *)&a1[387 * *(_DWORD *)v25 + 4 + 3 * i];
      v22 = (float *)&a1[387 * *(_DWORD *)v25 + 391 + 3 * i];
      v21 = (float *)&a1[387 * *(_DWORD *)v25 + 394 + 3 * i];
      v2 = i + 129 * *(_DWORD *)v25;
      *(_DWORD *)&v19[8 * v2] = sub_804D342(v23, v22, v21);
      v23 = (float *)&a1[387 * *(_DWORD *)v25 + 394 + 3 * i];
      v22 = (float *)&a1[387 * *(_DWORD *)v25 + 7 + 3 * i];
      v21 = (float *)&a1[387 * *(_DWORD *)v25 + 4 + 3 * i];
      v3 = i + 129 * *(_DWORD *)v25;
      v20[2 * v3] = sub_804D342(v23, v22, v21);
    }
    ++*(_DWORD *)v25;
  }
  *(_DWORD *)v25 = 0;
LABEL_8:
  if ( *(int *)v25 < *a1 - 1 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= a1[1] - 1 )
      {
        ++*(_DWORD *)v25;
        goto LABEL_8;
      }
      v13 = -1;
      if ( i <= 0 )
      {
        if ( a1[3] )
          v13 = v17[258 * *(_DWORD *)v25 + 2 * a1[1]];
      }
      else
      {
        v13 = (int)*(&s + 258 * *(_DWORD *)v25 + 2 * i);
      }
      v9 = v13 == *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i];
      if ( v13 == -1 || v9 )
        v13 = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 0);
      v15 = -1;
      if ( i >= a1[1] - 2 )
      {
        if ( a1[3] )
          v15 = *(_DWORD *)&v19[1032 * *(_DWORD *)v25];
      }
      else
      {
        v15 = v20[258 * *(_DWORD *)v25 + 1 + 2 * i];
      }
      v11 = v15 == v20[258 * *(_DWORD *)v25 + 2 * i];
      if ( v15 == -1 || v11 )
        v15 = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 2);
      v16 = -1;
      if ( *(int *)v25 <= 0 )
      {
        if ( a1[2] )
          v16 = *((_DWORD *)&src[20355] + 258 * *a1 + 2 * i);
      }
      else
      {
        v16 = *((_DWORD *)&src[20419] + 258 * *(_DWORD *)v25 + 2 * i + 2);
      }
      v12 = v16 == v20[258 * *(_DWORD *)v25 + 2 * i];
      if ( v16 == -1 || v12 )
        v16 = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 3);
      v14 = -1;
      if ( *(int *)v25 >= *a1 - 2 )
      {
        if ( a1[2] )
          v14 = v20[2 * i];
      }
      else
      {
        v14 = v20[258 * *(_DWORD *)v25 + 258 + 2 * i];
      }
      v10 = v14 == *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i];
      if ( v14 == -1 || v10 )
        v14 = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 1);
      if ( v8 == 1024 )
        Com_Error(1, (char *)&byte_80D6C10);
      s = &src[20 * v8];
      sub_80D2FE9(s, 0, 0x140u);
      if ( *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i] == v20[258 * *(_DWORD *)v25 + 2 * i] )
      {
        if ( *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i] != -1 )
        {
          *(_DWORD *)s = *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i];
          *((_DWORD *)s + 1) = 4;
          *((_DWORD *)s + 2) = v13;
          *((_DWORD *)s + 54) = v9;
          *((_DWORD *)s + 3) = v14;
          *((_DWORD *)s + 55) = v10;
          *((_DWORD *)s + 4) = v15;
          *((_DWORD *)s + 56) = v11;
          *((_DWORD *)s + 5) = v16;
          *((_DWORD *)s + 57) = v12;
          sub_804DE63((int)s, (int)a1, (int)v19, *(int *)v25, i, -1);
          if ( sub_804E12C(s) )
            goto LABEL_56;
        }
      }
      else
      {
        *(_DWORD *)s = *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i];
        *((_DWORD *)s + 1) = 3;
        *((_DWORD *)s + 2) = v13;
        *((_DWORD *)s + 54) = v9;
        *((_DWORD *)s + 3) = v14;
        *((_DWORD *)s + 55) = v10;
        *((_DWORD *)s + 4) = v20[258 * *(_DWORD *)v25 + 2 * i];
        if ( *((_DWORD *)s + 4) == -1 )
        {
          *((_DWORD *)s + 4) = v15;
          if ( *((_DWORD *)s + 4) == -1 )
          {
            v4 = s;
            v4[4] = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 4);
          }
        }
        sub_804DE63((int)s, (int)a1, (int)v19, *(int *)v25, i, 0);
        if ( sub_804E12C(s) )
        {
          sub_804E38B(s);
          ++v8;
        }
        if ( v8 == 1024 )
          Com_Error(1, (char *)&byte_80D6C10);
        s = &src[20 * v8];
        sub_80D2FE9(s, 0, 0x140u);
        *(_DWORD *)s = v20[258 * *(_DWORD *)v25 + 2 * i];
        *((_DWORD *)s + 1) = 3;
        *((_DWORD *)s + 2) = v15;
        *((_DWORD *)s + 54) = v11;
        *((_DWORD *)s + 3) = v16;
        *((_DWORD *)s + 55) = v12;
        *((_DWORD *)s + 4) = *(_DWORD *)&v19[1032 * *(_DWORD *)v25 + 8 * i];
        if ( *((_DWORD *)s + 4) == -1 )
        {
          *((_DWORD *)s + 4) = v13;
          if ( *((_DWORD *)s + 4) == -1 )
          {
            v5 = s;
            v5[4] = sub_804D7B0((int)a1, (int)v19, *(int *)v25, i, 5);
          }
        }
        sub_804DE63((int)s, (int)a1, (int)v19, *(int *)v25, i, 1);
        if ( sub_804E12C(s) )
        {
LABEL_56:
          sub_804E38B(s);
          ++v8;
          continue;
        }
      }
    }
  }
  *(_DWORD *)a2 = dword_80F6580;
  *(_DWORD *)(a2 + 8) = v8;
  *(_DWORD *)(a2 + 12) = sub_806C482(320 * v8);
  sub_80D2FC8(*(void **)(a2 + 12), src, 320 * v8);
  *(_DWORD *)(a2 + 4) = sub_806C482(20 * dword_80F6580);
  return sub_80D2FC8(*(void **)(a2 + 4), dword_80F65A0, 20 * dword_80F6580);
}
// 80F6580: using guessed type int dword_80F6580;
// 80F65A0: using guessed type int dword_80F65A0[];

//----- (0804F60B) --------------------------------------------------------
void *__cdecl sub_804F60B(int a1, int a2, int a3, int a4, float *a5)
{
  int j; // [esp+28h] [ebp-30C40h]
  int l; // [esp+28h] [ebp-30C40h]
  int i; // [esp+2Ch] [ebp-30C3Ch]
  int k; // [esp+2Ch] [ebp-30C3Ch]
  int v10; // [esp+30h] [ebp-30C38h] BYREF
  int v11; // [esp+34h] [ebp-30C34h]
  int v12; // [esp+38h] [ebp-30C30h]
  int v13; // [esp+3Ch] [ebp-30C2Ch]
  void *v14; // [esp+30C5Ch] [ebp-Ch]
  char v15[8]; // [esp+30C60h] [ebp-8h] BYREF

  if ( a1 <= 2 || a2 <= 2 || !a4 )
    Com_Error(1, (char *)&byte_80D6C20, a1, a2, a4);
  if ( (a1 & 1) == 0 || (a2 & 1) == 0 )
    Com_Error(1, (char *)&byte_80D6C60);
  if ( a1 > 129 || a2 > 129 )
    Com_Error(1, (char *)&byte_80D6CC0);
  v10 = a1;
  v11 = a2;
  v12 = 0;
  v13 = 0;
  for ( i = 0; i < a1; ++i )
  {
    for ( j = 0; j < a2; ++j )
    {
      *(_DWORD *)&v15[1548 * i - 199712 + 12 * j] = *(_DWORD *)(a4 + 12 * (i + a1 * j));
      *(_DWORD *)&v15[1548 * i - 199708 + 12 * j] = *(_DWORD *)(a4 + 12 * (i + a1 * j) + 4);
      *(_DWORD *)&v15[1548 * i - 199704 + 12 * j] = *(_DWORD *)(a4 + 12 * (i + a1 * j) + 8);
    }
  }
  sub_804C82F(&v10);
  sub_804C905(&v10, a3);
  sub_804CDEB(&v10);
  sub_804C1F8(&v10);
  sub_804C82F(&v10);
  sub_804C905(&v10, a3);
  sub_804CDEB(&v10);
  v14 = sub_806C482(0x10u);
  ((void (__cdecl *)(float *, float *))sub_806A254)(a5, a5 + 3);
  for ( k = 0; k < v10; ++k )
  {
    for ( l = 0; l < v11; ++l )
      ((void (__cdecl *)(int *, float *, float *))sub_806A28F)(&v10 + 387 * k + 3 * l + 4, a5, a5 + 3);
  }
  sub_804EBE6(&v10, (int)v14);
  *a5 = *a5 - 1.0;
  a5[1] = a5[1] - 1.0;
  a5[2] = a5[2] - 1.0;
  a5[3] = a5[3] + 1.0;
  a5[4] = a5[4] + 1.0;
  a5[5] = a5[5] + 1.0;
  return v14;
}
// 806A254: using guessed type int sub_806A254();
// 806A28F: using guessed type int sub_806A28F();

//----- (0804F9B3) --------------------------------------------------------
int __cdecl sub_804F9B3(int a1, _DWORD *a2)
{
  int result; // eax
  float v3; // [esp+Ch] [ebp-802Ch]
  float v4; // [esp+Ch] [ebp-802Ch]
  float v5; // [esp+10h] [ebp-8028h]
  float v6; // [esp+10h] [ebp-8028h]
  float v7; // [esp+14h] [ebp-8024h]
  float v8; // [esp+14h] [ebp-8024h]
  int v9; // [esp+18h] [ebp-8020h]
  int k; // [esp+1Ch] [ebp-801Ch]
  int i; // [esp+20h] [ebp-8018h]
  int j; // [esp+20h] [ebp-8018h]
  _DWORD *v13; // [esp+24h] [ebp-8014h]
  int v14; // [esp+28h] [ebp-8010h]
  int v15; // [esp+28h] [ebp-8010h]
  float v16; // [esp+2Ch] [ebp-800Ch]
  int v17[8194]; // [esp+30h] [ebp-8008h]

  result = dword_8330724;
  if ( *(_DWORD *)(dword_8330724 + 32) )
  {
    result = a1;
    if ( *(_DWORD *)(a1 + 192) )
    {
      v14 = a2[1];
      for ( i = 0; i < *a2; ++i )
      {
        v7 = *(float *)(a1 + 12 * *(_DWORD *)(v14 + 16) + 64) * *(float *)v14
           + *(float *)(a1 + 12 * *(_DWORD *)(v14 + 16) + 68) * *(float *)(v14 + 4)
           + *(float *)(a1 + 12 * *(_DWORD *)(v14 + 16) + 72) * *(float *)(v14 + 8);
        v5 = *(float *)a1 * *(float *)v14
           + *(float *)(a1 + 4) * *(float *)(v14 + 4)
           + *(float *)(a1 + 8) * *(float *)(v14 + 8)
           - *(float *)(v14 + 12)
           + v7;
        v3 = *(float *)(a1 + 12) * *(float *)v14
           + *(float *)(a1 + 16) * *(float *)(v14 + 4)
           + *(float *)(a1 + 20) * *(float *)(v14 + 8)
           - *(float *)(v14 + 12)
           + v7;
        v17[i + 4096] = v5 > 0.0;
        if ( v5 == v3 )
        {
          v17[i] = 1203982208;
        }
        else
        {
          *(float *)&v17[i] = v5 / (v5 - v3);
          if ( *(float *)&v17[i] <= 0.0 )
            v17[i] = 1203982208;
        }
        v14 += 20;
      }
      v13 = (_DWORD *)a2[3];
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= a2[2] )
          break;
        if ( v17[*v13 + 4096] )
        {
          v16 = *(float *)&v17[*v13];
          if ( v16 >= 0.0 && v16 <= (long double)*(float *)(a1 + 196) )
          {
            for ( k = 0; k < v13[1]; ++k )
            {
              v9 = v13[k + 2];
              if ( v17[v9 + 4096] == v13[k + 28] )
              {
                if ( v16 > (long double)*(float *)&v17[v9] )
                  break;
              }
              else if ( *(float *)&v17[v9] > (long double)v16 )
              {
                break;
              }
            }
            if ( k == v13[1] )
            {
              v15 = a2[1] + 20 * *v13;
              v8 = *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 64) * *(float *)v15
                 + *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 68) * *(float *)(v15 + 4)
                 + *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 72) * *(float *)(v15 + 8);
              v6 = *(float *)a1 * *(float *)v15
                 + *(float *)(a1 + 4) * *(float *)(v15 + 4)
                 + *(float *)(a1 + 8) * *(float *)(v15 + 8)
                 - *(float *)(v15 + 12)
                 + v8;
              v4 = *(float *)(a1 + 12) * *(float *)v15
                 + *(float *)(a1 + 16) * *(float *)(v15 + 4)
                 + *(float *)(a1 + 20) * *(float *)(v15 + 8)
                 - *(float *)(v15 + 12)
                 + v8;
              *(float *)(a1 + 196) = (v6 - 0.125) / (v6 - v4);
              if ( *(float *)(a1 + 196) < 0.0 )
                *(_DWORD *)(a1 + 196) = 0;
              *(_DWORD *)(a1 + 212) = *(_DWORD *)v15;
              *(_DWORD *)(a1 + 216) = *(_DWORD *)(v15 + 4);
              *(_DWORD *)(a1 + 220) = *(_DWORD *)(v15 + 8);
            }
          }
        }
        v13 += 80;
      }
    }
  }
  return result;
}
// 8330724: using guessed type int dword_8330724;

//----- (0804FEAB) --------------------------------------------------------
int __cdecl sub_804FEAB(int a1, _DWORD *a2)
{
  float v4; // [esp+Ch] [ebp-802Ch]
  float v5; // [esp+Ch] [ebp-802Ch]
  float v6; // [esp+10h] [ebp-8028h]
  float v7; // [esp+10h] [ebp-8028h]
  float v8; // [esp+14h] [ebp-8024h]
  float v9; // [esp+14h] [ebp-8024h]
  int v10; // [esp+18h] [ebp-8020h]
  int k; // [esp+1Ch] [ebp-801Ch]
  int i; // [esp+20h] [ebp-8018h]
  int j; // [esp+20h] [ebp-8018h]
  _DWORD *v14; // [esp+24h] [ebp-8014h]
  int v15; // [esp+28h] [ebp-8010h]
  int v16; // [esp+28h] [ebp-8010h]
  float v17; // [esp+2Ch] [ebp-800Ch]
  int v18[8194]; // [esp+30h] [ebp-8008h]

  if ( !*(_DWORD *)(dword_8330724 + 32) || !*(_DWORD *)(a1 + 192) )
    return 1;
  v15 = a2[1];
  for ( i = 0; i < *a2; ++i )
  {
    v8 = *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 64) * *(float *)v15
       + *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 68) * *(float *)(v15 + 4)
       + *(float *)(a1 + 12 * *(_DWORD *)(v15 + 16) + 72) * *(float *)(v15 + 8);
    v6 = *(float *)a1 * *(float *)v15
       + *(float *)(a1 + 4) * *(float *)(v15 + 4)
       + *(float *)(a1 + 8) * *(float *)(v15 + 8)
       - *(float *)(v15 + 12)
       + v8;
    v4 = *(float *)(a1 + 12) * *(float *)v15
       + *(float *)(a1 + 16) * *(float *)(v15 + 4)
       + *(float *)(a1 + 20) * *(float *)(v15 + 8)
       - *(float *)(v15 + 12)
       + v8;
    v18[i + 4096] = v6 > 0.0;
    if ( v6 == v4 )
    {
      v18[i] = 1203982208;
    }
    else
    {
      *(float *)&v18[i] = v6 / (v6 - v4);
      if ( *(float *)&v18[i] <= 0.0 )
        v18[i] = 1203982208;
    }
    v15 += 20;
  }
  v14 = (_DWORD *)a2[3];
  for ( j = 0; j < a2[2]; ++j )
  {
    if ( v18[*v14 + 4096] )
    {
      v17 = *(float *)&v18[*v14];
      if ( v17 >= 0.0 )
      {
        for ( k = 0; k < v14[1]; ++k )
        {
          v10 = v14[k + 2];
          if ( v18[v10 + 4096] == v14[k + 28] )
          {
            if ( v17 > (long double)*(float *)&v18[v10] )
              break;
          }
          else if ( *(float *)&v18[v10] > (long double)v17 )
          {
            break;
          }
        }
        if ( k == v14[1] )
        {
          v16 = a2[1] + 20 * *v14;
          v9 = *(float *)(a1 + 12 * *(_DWORD *)(v16 + 16) + 64) * *(float *)v16
             + *(float *)(a1 + 12 * *(_DWORD *)(v16 + 16) + 68) * *(float *)(v16 + 4)
             + *(float *)(a1 + 12 * *(_DWORD *)(v16 + 16) + 72) * *(float *)(v16 + 8);
          v7 = *(float *)a1 * *(float *)v16
             + *(float *)(a1 + 4) * *(float *)(v16 + 4)
             + *(float *)(a1 + 8) * *(float *)(v16 + 8)
             - *(float *)(v16 + 12)
             + v9;
          v5 = *(float *)(a1 + 12) * *(float *)v16
             + *(float *)(a1 + 16) * *(float *)(v16 + 4)
             + *(float *)(a1 + 20) * *(float *)(v16 + 8)
             - *(float *)(v16 + 12)
             + v9;
          if ( v7 - v5 > 0.0 && (v7 - 0.125) / (v7 - v5) < 1.0 )
            return 0;
        }
      }
    }
    v14 += 80;
  }
  return 1;
}
// 8330724: using guessed type int dword_8330724;

//----- (0805036E) --------------------------------------------------------
int __cdecl sub_805036E(float *a1, float *a2, float *a3, float *a4, float *a5, _DWORD *a6)
{
  float v8; // [esp+4h] [ebp-Ch]
  float v9; // [esp+4h] [ebp-Ch]
  float v10; // [esp+8h] [ebp-8h]
  float v11; // [esp+Ch] [ebp-4h]

  *a6 = 0;
  v11 = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2] - a1[3];
  v10 = *a3 * *a1 + a3[1] * a1[1] + a3[2] * a1[2] - a1[3];
  if ( v11 > 0.0 && (v10 >= 0.125 || v10 >= (long double)v11) )
    return 0;
  if ( v11 <= 0.0 && v10 <= 0.0 )
    return 1;
  if ( v11 <= (long double)v10 )
  {
    v9 = (v11 + 0.125) / (v11 - v10);
    if ( v9 > 1.0 )
      v9 = 1.0;
    if ( *a5 > (long double)v9 )
      *a5 = v9;
  }
  else
  {
    v8 = (v11 - 0.125) / (v11 - v10);
    if ( v8 < 0.0 )
      v8 = 0.0;
    if ( v8 > (long double)*a4 )
    {
      *a4 = v8;
      *a6 = 1;
    }
  }
  return 1;
}

//----- (0805050A) --------------------------------------------------------
int __cdecl sub_805050A(int a1, _DWORD *a2)
{
  int result; // eax
  float v3; // [esp+2Ch] [ebp-7Ch]
  float v4; // [esp+30h] [ebp-78h] BYREF
  float v5; // [esp+34h] [ebp-74h]
  float v6; // [esp+38h] [ebp-70h]
  float v7; // [esp+40h] [ebp-68h] BYREF
  float v8; // [esp+44h] [ebp-64h]
  float v9; // [esp+48h] [ebp-60h]
  unsigned int v10; // [esp+50h] [ebp-58h]
  unsigned int v11; // [esp+54h] [ebp-54h]
  unsigned int v12; // [esp+58h] [ebp-50h]
  unsigned int v13; // [esp+60h] [ebp-48h] BYREF
  unsigned int v14; // [esp+64h] [ebp-44h]
  unsigned int v15; // [esp+68h] [ebp-40h]
  float v16; // [esp+6Ch] [ebp-3Ch]
  _DWORD *v17; // [esp+78h] [ebp-30h]
  int *v18; // [esp+7Ch] [ebp-2Ch]
  float v19; // [esp+80h] [ebp-28h]
  float v20; // [esp+84h] [ebp-24h] BYREF
  float v21; // [esp+88h] [ebp-20h] BYREF
  float v22; // [esp+8Ch] [ebp-1Ch]
  int v23; // [esp+90h] [ebp-18h]
  int v24; // [esp+94h] [ebp-14h] BYREF
  int i; // [esp+98h] [ebp-10h]
  int v26; // [esp+9Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 192) )
    return sub_804F9B3(a1, a2);
  v17 = (_DWORD *)a2[3];
  v26 = 0;
  while ( 1 )
  {
    result = v26;
    if ( v26 >= a2[2] )
      break;
    v21 = -1.0;
    v20 = *(float *)(a1 + 196);
    v23 = -1;
    v18 = (int *)(a2[1] + 20 * *v17);
    v13 = *(unsigned int *)v18;
    v14 = *((unsigned int *)v18 + 1);
    v15 = *((unsigned int *)v18 + 2);
    v16 = *((float *)v18 + 3);
    if ( *(_DWORD *)(a1 + 244) )
    {
      v16 = v16 + *(float *)(a1 + 248);
      v19 = *(float *)&v13 * *(float *)(a1 + 256)
          + *(float *)&v14 * *(float *)(a1 + 260)
          + *(float *)&v15 * *(float *)(a1 + 264);
      if ( v19 <= 0.0 )
      {
        v7 = *(float *)a1 + *(float *)(a1 + 256);
        v8 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
        v9 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
        v4 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
        v5 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
        v6 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
      }
      else
      {
        v7 = *(float *)a1 - *(float *)(a1 + 256);
        v8 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
        v9 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
        v4 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
        v5 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
        v6 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
      }
    }
    else
    {
      v22 = *(float *)(a1 + 12 * v18[4] + 64) * *(float *)&v13
          + *(float *)(a1 + 12 * v18[4] + 68) * *(float *)&v14
          + *(float *)(a1 + 12 * v18[4] + 72) * *(float *)&v15;
      v16 = v16 - v22;
      v7 = *(float *)a1;
      v8 = *(float *)(a1 + 4);
      v9 = *(float *)(a1 + 8);
      v4 = *(float *)(a1 + 12);
      v5 = *(float *)(a1 + 16);
      v6 = *(float *)(a1 + 20);
    }
    if ( sub_805036E((float *)&v13, &v7, &v4, &v21, &v20, &v24) )
    {
      if ( v24 )
      {
        v10 = v13;
        v11 = v14;
        v12 = v15;
      }
      for ( i = 0; i < v17[1]; ++i )
      {
        v18 = (int *)(a2[1] + 20 * v17[i + 2]);
        if ( v17[i + 28] )
        {
          v13 = *v18 ^ 0x80000000;
          v14 = v18[1] ^ 0x80000000;
          v15 = v18[2] ^ 0x80000000;
          LODWORD(v16) = v18[3] ^ 0x80000000;
        }
        else
        {
          v13 = *(unsigned int *)v18;
          v14 = *((unsigned int *)v18 + 1);
          v15 = *((unsigned int *)v18 + 2);
          v16 = *((float *)v18 + 3);
        }
        if ( *(_DWORD *)(a1 + 244) )
        {
          v16 = v16 + *(float *)(a1 + 248);
          v19 = *(float *)&v13 * *(float *)(a1 + 256)
              + *(float *)&v14 * *(float *)(a1 + 260)
              + *(float *)&v15 * *(float *)(a1 + 264);
          if ( v19 <= 0.0 )
          {
            v7 = *(float *)a1 + *(float *)(a1 + 256);
            v8 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
            v9 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
            v4 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
            v5 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
            v6 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
          }
          else
          {
            v7 = *(float *)a1 - *(float *)(a1 + 256);
            v8 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
            v9 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
            v4 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
            v5 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
            v6 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
          }
        }
        else
        {
          v22 = *(float *)(a1 + 12 * v18[4] + 64) * *(float *)&v13
              + *(float *)(a1 + 12 * v18[4] + 68) * *(float *)&v14
              + *(float *)(a1 + 12 * v18[4] + 72) * *(float *)&v15;
          v3 = fabs(v22);
          v16 = v3 + v16;
          v7 = *(float *)a1;
          v8 = *(float *)(a1 + 4);
          v9 = *(float *)(a1 + 8);
          v4 = *(float *)(a1 + 12);
          v5 = *(float *)(a1 + 16);
          v6 = *(float *)(a1 + 20);
        }
        if ( !sub_805036E((float *)&v13, &v7, &v4, &v21, &v20, &v24) )
          break;
        if ( v24 )
        {
          v23 = i;
          v10 = v13;
          v11 = v14;
          v12 = v15;
        }
      }
      if ( i >= v17[1]
        && v23 != v17[1] - 1
        && v20 > (long double)v21
        && v21 >= 0.0
        && *(float *)(a1 + 196) > (long double)v21 )
      {
        if ( v21 < 0.0 )
          v21 = 0.0;
        *(float *)(a1 + 196) = v21;
        *(_DWORD *)(a1 + 212) = v10;
        *(_DWORD *)(a1 + 216) = v11;
        *(_DWORD *)(a1 + 220) = v12;
      }
    }
    ++v26;
    v17 += 80;
  }
  return result;
}

//----- (08050B4F) --------------------------------------------------------
int __cdecl sub_8050B4F(int a1, _DWORD *a2)
{
  float v4; // [esp+2Ch] [ebp-6Ch]
  float v5; // [esp+30h] [ebp-68h] BYREF
  float v6; // [esp+34h] [ebp-64h]
  float v7; // [esp+38h] [ebp-60h]
  float v8; // [esp+40h] [ebp-58h] BYREF
  float v9; // [esp+44h] [ebp-54h]
  float v10; // [esp+48h] [ebp-50h]
  unsigned int v11; // [esp+50h] [ebp-48h] BYREF
  float v12; // [esp+54h] [ebp-44h]
  float v13; // [esp+58h] [ebp-40h]
  float v14; // [esp+5Ch] [ebp-3Ch]
  _DWORD *v15; // [esp+68h] [ebp-30h]
  int *v16; // [esp+6Ch] [ebp-2Ch]
  float v17; // [esp+70h] [ebp-28h]
  float v18; // [esp+74h] [ebp-24h] BYREF
  float v19; // [esp+78h] [ebp-20h] BYREF
  float v20; // [esp+7Ch] [ebp-1Ch]
  int v21; // [esp+80h] [ebp-18h]
  int v22; // [esp+84h] [ebp-14h] BYREF
  int i; // [esp+88h] [ebp-10h]
  int v24; // [esp+8Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 192) )
    return sub_804FEAB(a1, a2);
  v15 = (_DWORD *)a2[3];
  v24 = 0;
  while ( v24 < a2[2] )
  {
    v19 = -1.0;
    v18 = 1.0;
    v21 = -1;
    v16 = (int *)(a2[1] + 20 * *v15);
    v11 = *(unsigned int *)v16;
    v12 = *((float *)v16 + 1);
    v13 = *((float *)v16 + 2);
    v14 = *((float *)v16 + 3);
    if ( *(_DWORD *)(a1 + 244) )
    {
      v14 = v14 + *(float *)(a1 + 248);
      v17 = *(float *)&v11 * *(float *)(a1 + 256) + v12 * *(float *)(a1 + 260) + v13 * *(float *)(a1 + 264);
      if ( v17 <= 0.0 )
      {
        v8 = *(float *)a1 + *(float *)(a1 + 256);
        v9 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
        v10 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
        v5 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
        v6 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
        v7 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
      }
      else
      {
        v8 = *(float *)a1 - *(float *)(a1 + 256);
        v9 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
        v10 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
        v5 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
        v6 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
        v7 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
      }
    }
    else
    {
      v20 = *(float *)(a1 + 12 * v16[4] + 64) * *(float *)&v11
          + *(float *)(a1 + 12 * v16[4] + 68) * v12
          + *(float *)(a1 + 12 * v16[4] + 72) * v13;
      v14 = v14 - v20;
      v8 = *(float *)a1;
      v9 = *(float *)(a1 + 4);
      v10 = *(float *)(a1 + 8);
      v5 = *(float *)(a1 + 12);
      v6 = *(float *)(a1 + 16);
      v7 = *(float *)(a1 + 20);
    }
    if ( sub_805036E((float *)&v11, &v8, &v5, &v19, &v18, &v22) )
    {
      for ( i = 0; i < v15[1]; ++i )
      {
        v16 = (int *)(a2[1] + 20 * v15[i + 2]);
        if ( v15[i + 28] )
        {
          v11 = *v16 ^ 0x80000000;
          LODWORD(v12) = v16[1] ^ 0x80000000;
          LODWORD(v13) = v16[2] ^ 0x80000000;
          LODWORD(v14) = v16[3] ^ 0x80000000;
        }
        else
        {
          v11 = *(unsigned int *)v16;
          v12 = *((float *)v16 + 1);
          v13 = *((float *)v16 + 2);
          v14 = *((float *)v16 + 3);
        }
        if ( *(_DWORD *)(a1 + 244) )
        {
          v14 = v14 + *(float *)(a1 + 248);
          v17 = *(float *)&v11 * *(float *)(a1 + 256) + v12 * *(float *)(a1 + 260) + v13 * *(float *)(a1 + 264);
          if ( v17 <= 0.0 )
          {
            v8 = *(float *)a1 + *(float *)(a1 + 256);
            v9 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
            v10 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
            v5 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
            v6 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
            v7 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
          }
          else
          {
            v8 = *(float *)a1 - *(float *)(a1 + 256);
            v9 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
            v10 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
            v5 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
            v6 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
            v7 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
          }
        }
        else
        {
          v20 = *(float *)(a1 + 12 * v16[4] + 64) * *(float *)&v11
              + *(float *)(a1 + 12 * v16[4] + 68) * v12
              + *(float *)(a1 + 12 * v16[4] + 72) * v13;
          v4 = fabs(v20);
          v14 = v4 + v14;
          v8 = *(float *)a1;
          v9 = *(float *)(a1 + 4);
          v10 = *(float *)(a1 + 8);
          v5 = *(float *)(a1 + 12);
          v6 = *(float *)(a1 + 16);
          v7 = *(float *)(a1 + 20);
        }
        if ( !sub_805036E((float *)&v11, &v8, &v5, &v19, &v18, &v22) )
          break;
        if ( v22 )
          v21 = i;
      }
      if ( i >= v15[1] && v21 != v15[1] - 1 && v18 > (long double)v19 && v19 >= 0.0 )
        return 0;
    }
    ++v24;
    v15 += 80;
  }
  return 1;
}

//----- (0805111E) --------------------------------------------------------
int __cdecl sub_805111E(int a1, _DWORD *a2)
{
  float v4; // [esp+Ch] [ebp-4Ch]
  float v5; // [esp+10h] [ebp-48h]
  float v6; // [esp+10h] [ebp-48h]
  float v7; // [esp+14h] [ebp-44h]
  float v8; // [esp+14h] [ebp-44h]
  float v9; // [esp+18h] [ebp-40h]
  float v10; // [esp+18h] [ebp-40h]
  float v11; // [esp+20h] [ebp-38h]
  float v12; // [esp+20h] [ebp-38h]
  float v13; // [esp+24h] [ebp-34h]
  float v14; // [esp+24h] [ebp-34h]
  float v15; // [esp+28h] [ebp-30h]
  float v16; // [esp+28h] [ebp-30h]
  float v17; // [esp+2Ch] [ebp-2Ch]
  float v18; // [esp+2Ch] [ebp-2Ch]
  float v19; // [esp+2Ch] [ebp-2Ch]
  float v20; // [esp+2Ch] [ebp-2Ch]
  _DWORD *v21; // [esp+38h] [ebp-20h]
  int v22; // [esp+3Ch] [ebp-1Ch]
  float *v23; // [esp+3Ch] [ebp-1Ch]
  float v24; // [esp+40h] [ebp-18h]
  float v25; // [esp+40h] [ebp-18h]
  float v26; // [esp+44h] [ebp-14h]
  float v27; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  if ( *(_DWORD *)(a1 + 192) )
    return 0;
  v21 = (_DWORD *)a2[3];
  for ( i = 0; i < a2[2]; ++i )
  {
    v22 = a2[1] + 20 * *v21;
    v11 = *(float *)v22;
    v13 = *(float *)(v22 + 4);
    v15 = *(float *)(v22 + 8);
    v17 = *(float *)(v22 + 12);
    if ( *(_DWORD *)(a1 + 244) )
    {
      v18 = v17 + *(float *)(a1 + 248);
      v24 = v11 * *(float *)(a1 + 256) + v13 * *(float *)(a1 + 260) + v15 * *(float *)(a1 + 264);
      if ( v24 <= 0.0 )
      {
        v5 = *(float *)a1 + *(float *)(a1 + 256);
        v7 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
        v9 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
      }
      else
      {
        v5 = *(float *)a1 - *(float *)(a1 + 256);
        v7 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
        v9 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
      }
    }
    else
    {
      v26 = *(float *)(a1 + 12 * *(_DWORD *)(v22 + 16) + 64) * v11
          + *(float *)(a1 + 12 * *(_DWORD *)(v22 + 16) + 68) * v13
          + *(float *)(a1 + 12 * *(_DWORD *)(v22 + 16) + 72) * v15;
      v18 = v17 - v26;
      v5 = *(float *)a1;
      v7 = *(float *)(a1 + 4);
      v9 = *(float *)(a1 + 8);
    }
    if ( v11 * v5 + v13 * v7 + v15 * v9 - v18 <= 0.0 )
    {
      for ( j = 0; j < v21[1]; ++j )
      {
        v23 = (float *)(a2[1] + 20 * v21[j + 2]);
        if ( v21[j + 28] )
        {
          LODWORD(v12) = *(_DWORD *)v23 ^ 0x80000000;
          LODWORD(v14) = *((_DWORD *)v23 + 1) ^ 0x80000000;
          LODWORD(v16) = *((_DWORD *)v23 + 2) ^ 0x80000000;
          LODWORD(v19) = *((_DWORD *)v23 + 3) ^ 0x80000000;
        }
        else
        {
          v12 = *v23;
          v14 = v23[1];
          v16 = v23[2];
          v19 = v23[3];
        }
        if ( *(_DWORD *)(a1 + 244) )
        {
          v20 = v19 + *(float *)(a1 + 248);
          v25 = v12 * *(float *)(a1 + 256) + v14 * *(float *)(a1 + 260) + v16 * *(float *)(a1 + 264);
          if ( v25 <= 0.0 )
          {
            v6 = *(float *)a1 + *(float *)(a1 + 256);
            v8 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
            v10 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
          }
          else
          {
            v6 = *(float *)a1 - *(float *)(a1 + 256);
            v8 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
            v10 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
          }
        }
        else
        {
          v27 = *(float *)(a1 + 12 * *((_DWORD *)v23 + 4) + 64) * v12
              + *(float *)(a1 + 12 * *((_DWORD *)v23 + 4) + 68) * v14
              + *(float *)(a1 + 12 * *((_DWORD *)v23 + 4) + 72) * v16;
          v4 = fabs(v27);
          v20 = v4 + v19;
          v6 = *(float *)a1;
          v8 = *(float *)(a1 + 4);
          v10 = *(float *)(a1 + 8);
        }
        if ( v12 * v6 + v14 * v8 + v16 * v10 - v20 > 0.0 )
          break;
      }
      if ( j >= v21[1] )
        return 1;
    }
    v21 += 80;
  }
  return 0;
}

//----- (080515DC) --------------------------------------------------------
void *__cdecl sub_80515DC(int a1)
{
  if ( ++dword_833A8AC > dword_833A8A8 )
    dword_833A8A8 = dword_833A8AC;
  return Z_MallocInternal(12 * a1 + 4);
}
// 833A8A8: using guessed type int dword_833A8A8;
// 833A8AC: using guessed type int dword_833A8AC;

//----- (08051624) --------------------------------------------------------
int __cdecl sub_8051624(void *ptr)
{
  if ( *(_DWORD *)ptr == -559030611 )
    Com_Error(0, (char *)&byte_80D6D20);
  *(_DWORD *)ptr = -559030611;
  --dword_833A8AC;
  return Z_FreeInternal(ptr);
}
// 833A8AC: using guessed type int dword_833A8AC;

//----- (080518FC) --------------------------------------------------------
float *__cdecl sub_80518FC(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4[4]; // [esp+10h] [ebp-28h] BYREF
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  v5[0] = a1[4] - a1[1];
  v5[1] = a1[5] - a1[2];
  v5[2] = a1[6] - a1[3];
  v4[0] = a1[7] - a1[1];
  v4[1] = a1[8] - a1[2];
  v4[2] = a1[9] - a1[3];
  sub_80667A1(v4, v5, a2);
  sub_8066A90(a2, a2);
  result = a1;
  *a3 = a1[1] * *a2 + a1[2] * a2[1] + a1[3] * a2[2];
  return result;
}

//----- (080519BB) --------------------------------------------------------
long double __cdecl sub_80519BB(int a1)
{
  float v2; // [esp+28h] [ebp-50h]
  float v3; // [esp+2Ch] [ebp-4Ch]
  float v4; // [esp+30h] [ebp-48h] BYREF
  float v5; // [esp+34h] [ebp-44h]
  float v6; // [esp+38h] [ebp-40h]
  float v7[4]; // [esp+40h] [ebp-38h] BYREF
  float v8[7]; // [esp+50h] [ebp-28h] BYREF
  int i; // [esp+6Ch] [ebp-Ch]

  v3 = 0.0;
  for ( i = 2; i < *(_DWORD *)a1; ++i )
  {
    v8[0] = *(float *)(a1 + 12 * i - 8) - *(float *)(a1 + 4);
    v8[1] = *(float *)(a1 + 12 * i - 4) - *(float *)(a1 + 8);
    v8[2] = *(float *)(a1 + 12 * i) - *(float *)(a1 + 12);
    v7[0] = *(float *)(a1 + 12 * i + 4) - *(float *)(a1 + 4);
    v7[1] = *(float *)(a1 + 12 * i + 8) - *(float *)(a1 + 8);
    v7[2] = *(float *)(a1 + 12 * i + 12) - *(float *)(a1 + 12);
    sub_80667A1(v8, v7, &v4);
    v2 = sqrt(v4 * v4 + v5 * v5 + v6 * v6);
    v3 = v2 * 0.5 + v3;
  }
  return v3;
}

//----- (08051AF6) --------------------------------------------------------
int __cdecl sub_8051AF6(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int j; // [esp+0h] [ebp-10h]
  int i; // [esp+4h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-8h]

  a2[2] = 1207959552;
  a2[1] = 1207959552;
  *a2 = 1207959552;
  a3[2] = -939524096;
  a3[1] = -939524096;
  *a3 = -939524096;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *a1 )
      break;
    for ( j = 0; j <= 2; ++j )
    {
      v6 = *(float *)&a1[3 * i + 1 + j];
      if ( *(float *)&a2[j] > (long double)v6 )
        *(float *)&a2[j] = v6;
      if ( v6 > (long double)*(float *)&a3[j] )
        *(float *)&a3[j] = v6;
    }
  }
  return result;
}

//----- (08051CDF) --------------------------------------------------------
float *__cdecl sub_8051CDF(int a1, float a2)
{
  float *result; // eax
  float v3; // [esp+30h] [ebp-48h] BYREF
  float v4; // [esp+34h] [ebp-44h]
  float v5; // [esp+38h] [ebp-40h]
  float v6; // [esp+40h] [ebp-38h] BYREF
  float v7; // [esp+44h] [ebp-34h]
  float v8; // [esp+48h] [ebp-30h]
  float v9; // [esp+50h] [ebp-28h]
  float v10; // [esp+54h] [ebp-24h]
  float v11; // [esp+58h] [ebp-20h]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  int v14; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v13 = -131072.0;
  v14 = -1;
  for ( i = 0; i <= 2; ++i )
  {
    v12 = fabs(*(float *)(a1 + 4 * i));
    if ( v12 > (long double)v13 )
    {
      v14 = i;
      v13 = v12;
    }
  }
  if ( v14 == -1 )
    Com_Error(1, (char *)&byte_80D6D60);
  v3 = 0.0;
  v4 = 0.0;
  v5 = 0.0;
  if ( v14 >= 0 )
  {
    if ( v14 <= 1 )
      v5 = 1.0;
    else
      v3 = 1.0;
  }
  v12 = v3 * *(float *)a1 + v4 * *(float *)(a1 + 4) + v5 * *(float *)(a1 + 8);
  v3 = -v12 * *(float *)a1 + v3;
  v4 = -v12 * *(float *)(a1 + 4) + v4;
  v5 = -v12 * *(float *)(a1 + 8) + v5;
  sub_8066A90(&v3, &v3);
  v9 = *(float *)a1 * a2;
  v10 = *(float *)(a1 + 4) * a2;
  v11 = *(float *)(a1 + 8) * a2;
  sub_80667A1(&v3, (float *)a1, &v6);
  v3 = v3 * 131072.0;
  v4 = v4 * 131072.0;
  v5 = v5 * 131072.0;
  v6 = v6 * 131072.0;
  v7 = v7 * 131072.0;
  v8 = v8 * 131072.0;
  result = (float *)sub_80515DC(4);
  result[1] = v9 - v6;
  result[2] = v10 - v7;
  result[3] = v11 - v8;
  result[1] = result[1] + v3;
  result[2] = result[2] + v4;
  result[3] = result[3] + v5;
  result[4] = v9 + v6;
  result[5] = v10 + v7;
  result[6] = v11 + v8;
  result[4] = result[4] + v3;
  result[5] = result[5] + v4;
  result[6] = result[6] + v5;
  result[7] = v9 + v6;
  result[8] = v10 + v7;
  result[9] = v11 + v8;
  result[7] = result[7] - v3;
  result[8] = result[8] - v4;
  result[9] = result[9] - v5;
  result[10] = v9 - v6;
  result[11] = v10 - v7;
  result[12] = v11 - v8;
  result[10] = result[10] - v3;
  result[11] = result[11] - v4;
  result[12] = result[12] - v5;
  *(_DWORD *)result = 4;
  return result;
}
// 8051D83: conditional instruction was optimized away because of '%var_54.4==2'

//----- (08052013) --------------------------------------------------------
void *__cdecl sub_8052013(void *src)
{
  void *dest; // [esp+10h] [ebp-8h]

  dest = sub_80515DC(*(_DWORD *)src);
  sub_80D2FC8(dest, src, 12 * *(_DWORD *)src + 4);
  return dest;
}

//----- (08052140) --------------------------------------------------------
int *__cdecl sub_8052140(void *src, int a2, float a3, float a4, int a5, int a6)
{
  void *v6; // edx
  int *result; // eax
  void *v8; // edx
  int v9; // [esp+24h] [ebp-274h]
  int *v10; // [esp+28h] [ebp-270h]
  int *v11; // [esp+2Ch] [ebp-26Ch]
  int v12; // [esp+30h] [ebp-268h]
  int v13; // [esp+34h] [ebp-264h]
  int v14; // [esp+38h] [ebp-260h]
  int v15; // [esp+40h] [ebp-258h]
  int *v16; // [esp+44h] [ebp-254h]
  int j; // [esp+48h] [ebp-250h]
  int i; // [esp+4Ch] [ebp-24Ch]
  int v19; // [esp+50h] [ebp-248h]
  int v20; // [esp+54h] [ebp-244h]
  int v21; // [esp+58h] [ebp-240h]
  int v22[68]; // [esp+60h] [ebp-238h]
  int v23[74]; // [esp+170h] [ebp-128h]

  v21 = 0;
  v20 = 0;
  v19 = 0;
  for ( i = 0; i < *(_DWORD *)src; ++i )
  {
    flt_810A5A0 = *((float *)src + 3 * i + 1) * *(float *)a2
                + *((float *)src + 3 * i + 2) * *(float *)(a2 + 4)
                + *((float *)src + 3 * i + 3) * *(float *)(a2 + 8);
    flt_810A5A0 = flt_810A5A0 - a3;
    v23[i] = LODWORD(flt_810A5A0);
    if ( flt_810A5A0 <= (long double)a4 )
    {
      if ( -a4 <= (long double)flt_810A5A0 )
        v22[i] = 2;
      else
        v22[i] = 1;
    }
    else
    {
      v22[i] = 0;
    }
    ++*(&v19 + v22[i]);
  }
  v22[i] = v22[0];
  v23[i] = v23[0];
  *(_DWORD *)a6 = 0;
  *(_DWORD *)a5 = 0;
  if ( v19 )
  {
    if ( v20 )
    {
      v9 = *(_DWORD *)src + 4;
      v11 = (int *)sub_80515DC(v9);
      *(_DWORD *)a5 = v11;
      v10 = (int *)sub_80515DC(v9);
      *(_DWORD *)a6 = v10;
      for ( i = 0; i < *(_DWORD *)src; ++i )
      {
        v16 = (int *)((char *)src + 12 * i + 4);
        if ( v22[i] == 2 )
        {
          v11[3 * *v11 + 1] = *v16;
          v11[3 * *v11 + 2] = v16[1];
          v11[3 * (*v11)++ + 3] = v16[2];
          v10[3 * *v10 + 1] = *v16;
          v10[3 * *v10 + 2] = v16[1];
          v10[3 * (*v10)++ + 3] = v16[2];
        }
        else
        {
          if ( !v22[i] )
          {
            v11[3 * *v11 + 1] = *v16;
            v11[3 * *v11 + 2] = v16[1];
            v11[3 * (*v11)++ + 3] = v16[2];
          }
          if ( v22[i] == 1 )
          {
            v10[3 * *v10 + 1] = *v16;
            v10[3 * *v10 + 2] = v16[1];
            v10[3 * (*v10)++ + 3] = v16[2];
          }
          if ( v22[i + 1] != 2 && v22[i + 1] != v22[i] )
          {
            v15 = (int)src + 12 * ((i + 1) % *(_DWORD *)src) + 4;
            flt_810A5A0 = *(float *)&v23[i] / (*(float *)&v23[i] - *(float *)&v23[i + 1]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( *(float *)(a2 + 4 * j) == 1.0 )
              {
                *((float *)&v12 + j) = a3;
              }
              else if ( *(float *)(a2 + 4 * j) == -1.0 )
              {
                *(&v12 + j) = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                *((float *)&v12 + j) = (*(float *)(v15 + 4 * j) - *(float *)&v16[j]) * flt_810A5A0 + *(float *)&v16[j];
              }
            }
            v11[3 * *v11 + 1] = v12;
            v11[3 * *v11 + 2] = v13;
            v11[3 * (*v11)++ + 3] = v14;
            v10[3 * *v10 + 1] = v12;
            v10[3 * *v10 + 2] = v13;
            v10[3 * (*v10)++ + 3] = v14;
          }
        }
      }
      if ( *v11 > v9 || *v10 > v9 )
        Com_Error(1, (char *)&byte_80D6DA0);
      if ( *v11 > 64 || (result = v10, *v10 > 64) )
        Com_Error(1, (char *)&byte_80D6DE0);
    }
    else
    {
      v8 = sub_8052013(src);
      result = (int *)a5;
      *(_DWORD *)a5 = v8;
    }
  }
  else
  {
    v6 = sub_8052013(src);
    result = (int *)a6;
    *(_DWORD *)a6 = v6;
  }
  return result;
}
// 810A5A0: using guessed type float flt_810A5A0;

//----- (080528B5) --------------------------------------------------------
int *__cdecl sub_80528B5(int a1, int a2, float a3, float a4)
{
  int *result; // eax
  int v5; // [esp+28h] [ebp-280h]
  int *v6; // [esp+2Ch] [ebp-27Ch]
  int v7[4]; // [esp+30h] [ebp-278h]
  int v8; // [esp+40h] [ebp-268h]
  int *v9; // [esp+44h] [ebp-264h]
  int j; // [esp+48h] [ebp-260h]
  int i; // [esp+4Ch] [ebp-25Ch]
  int v12; // [esp+50h] [ebp-258h]
  int v13; // [esp+54h] [ebp-254h]
  int v14; // [esp+58h] [ebp-250h]
  int v15[68]; // [esp+60h] [ebp-248h]
  int v16[71]; // [esp+170h] [ebp-138h]
  void *ptr; // [esp+28Ch] [ebp-1Ch]

  ptr = *(void **)a1;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *(_DWORD *)ptr; ++i )
  {
    flt_810A5A4 = *((float *)ptr + 3 * i + 1) * *(float *)a2
                + *((float *)ptr + 3 * i + 2) * *(float *)(a2 + 4)
                + *((float *)ptr + 3 * i + 3) * *(float *)(a2 + 8);
    flt_810A5A4 = flt_810A5A4 - a3;
    v16[i] = LODWORD(flt_810A5A4);
    if ( flt_810A5A4 <= (long double)a4 )
    {
      if ( -a4 <= (long double)flt_810A5A4 )
        v15[i] = 2;
      else
        v15[i] = 1;
    }
    else
    {
      v15[i] = 0;
    }
    ++*(&v12 + v15[i]);
  }
  v15[i] = v15[0];
  result = (int *)v16[0];
  v16[i] = v16[0];
  if ( v12 )
  {
    if ( v13 )
    {
      v5 = *(_DWORD *)ptr + 4;
      v6 = (int *)sub_80515DC(v5);
      for ( i = 0; i < *(_DWORD *)ptr; ++i )
      {
        v9 = (int *)((char *)ptr + 12 * i + 4);
        if ( v15[i] == 2 )
        {
          v6[3 * *v6 + 1] = *v9;
          v6[3 * *v6 + 2] = v9[1];
          v6[3 * (*v6)++ + 3] = v9[2];
        }
        else
        {
          if ( !v15[i] )
          {
            v6[3 * *v6 + 1] = *v9;
            v6[3 * *v6 + 2] = v9[1];
            v6[3 * (*v6)++ + 3] = v9[2];
          }
          if ( v15[i + 1] != 2 && v15[i + 1] != v15[i] )
          {
            v8 = (int)ptr + 12 * ((i + 1) % *(_DWORD *)ptr) + 4;
            flt_810A5A4 = *(float *)&v16[i] / (*(float *)&v16[i] - *(float *)&v16[i + 1]);
            for ( j = 0; j <= 2; ++j )
            {
              if ( *(float *)(a2 + 4 * j) == 1.0 )
              {
                *(float *)&v7[j] = a3;
              }
              else if ( *(float *)(a2 + 4 * j) == -1.0 )
              {
                v7[j] = LODWORD(a3) ^ 0x80000000;
              }
              else
              {
                *(float *)&v7[j] = (*(float *)(v8 + 4 * j) - *(float *)&v9[j]) * flt_810A5A4 + *(float *)&v9[j];
              }
            }
            v6[3 * *v6 + 1] = v7[0];
            v6[3 * *v6 + 2] = v7[1];
            v6[3 * (*v6)++ + 3] = v7[2];
          }
        }
      }
      if ( *v6 > v5 )
        Com_Error(1, (char *)&byte_80D6DA0);
      if ( *v6 > 64 )
        Com_Error(1, (char *)&byte_80D6DE0);
      sub_8051624(ptr);
      result = v6;
      *(_DWORD *)a1 = v6;
    }
  }
  else
  {
    sub_8051624(ptr);
    result = (int *)a1;
    *(_DWORD *)a1 = 0;
  }
  return result;
}
// 810A5A4: using guessed type float flt_810A5A4;

//----- (080537C4) --------------------------------------------------------
void *__cdecl sub_80537C4(size_t a1)
{
  return sub_806C482(a1);
}

//----- (080537D7) --------------------------------------------------------
void *__cdecl sub_80537D7(size_t a1)
{
  return sub_806C482(a1);
}

//----- (080537EA) --------------------------------------------------------
int __cdecl sub_80537EA(int a1, const char *a2, float *a3, int a4, float *a5)
{
  int result; // eax
  float v6; // [esp+10h] [ebp-38h] BYREF
  float v7; // [esp+14h] [ebp-34h]
  float v8; // [esp+18h] [ebp-30h]
  float v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+20h] [ebp-28h]
  float v11; // [esp+24h] [ebp-24h]
  float v12; // [esp+28h] [ebp-20h]
  float v13; // [esp+2Ch] [ebp-1Ch]
  float v14; // [esp+30h] [ebp-18h]

  if ( !a2 || !*a2 )
    Com_Error(1, (char *)&byte_80D6EE0);
  if ( *a5 == 0.0 )
    Com_Error(1, (char *)&byte_80D6F00, a2);
  if ( a5[1] == 0.0 )
    Com_Error(1, (char *)&byte_80D6F40, a2);
  if ( a5[2] == 0.0 )
    Com_Error(1, (char *)&byte_80D6F80, a2);
  *(_DWORD *)a1 = sub_80CE498(a2, 1, (int (__cdecl *)(int))sub_80537C4);
  *(float *)(a1 + 4) = *a3;
  *(float *)(a1 + 8) = a3[1];
  *(float *)(a1 + 12) = a3[2];
  ((void (__cdecl *)(int, float *))sub_806A55E)(a4, &v6);
  v6 = v6 * *a5;
  v7 = v7 * *a5;
  v8 = v8 * *a5;
  v9 = v9 * a5[1];
  v10 = v10 * a5[1];
  v11 = v11 * a5[1];
  v12 = v12 * a5[2];
  v13 = v13 * a5[2];
  v14 = v14 * a5[2];
  sub_806899C(&v6, (float *)(a1 + 16));
  result = sub_80CF91E(*(_DWORD *)a1, &v6, (_DWORD *)(a1 + 56), (_DWORD *)(a1 + 68));
  if ( result )
  {
    *(float *)(a1 + 56) = *(float *)(a1 + 56) + *a3;
    *(float *)(a1 + 60) = *(float *)(a1 + 60) + a3[1];
    *(float *)(a1 + 64) = *(float *)(a1 + 64) + a3[2];
    *(float *)(a1 + 68) = *(float *)(a1 + 68) + *a3;
    *(float *)(a1 + 72) = *(float *)(a1 + 72) + a3[1];
    *(float *)(a1 + 76) = *(float *)(a1 + 76) + a3[2];
    result = sub_80CEFA0(*(_DWORD *)a1);
    if ( result )
      result = sub_805E1F7(a1);
  }
  return result;
}
// 806A55E: using guessed type int sub_806A55E();

//----- (08053A56) --------------------------------------------------------
char *CM_LoadStaticModels()
{
  char *result; // eax
  int v1; // [esp+28h] [ebp-110h]
  int v2; // [esp+2Ch] [ebp-10Ch]
  int v3; // [esp+2Ch] [ebp-10Ch]
  int v4; // [esp+30h] [ebp-108h] BYREF
  int v5; // [esp+34h] [ebp-104h] BYREF
  float v6; // [esp+38h] [ebp-100h] BYREF
  int v7; // [esp+40h] [ebp-F8h] BYREF
  int v8; // [esp+44h] [ebp-F4h] BYREF
  int v9; // [esp+48h] [ebp-F0h] BYREF
  int v10; // [esp+50h] [ebp-E8h] BYREF
  int v11; // [esp+54h] [ebp-E4h] BYREF
  int v12; // [esp+58h] [ebp-E0h] BYREF
  char s1[64]; // [esp+60h] [ebp-D8h] BYREF
  char dest[64]; // [esp+A0h] [ebp-98h] BYREF
  char v15[7]; // [esp+E0h] [ebp-58h] BYREF
  char v16[65]; // [esp+E7h] [ebp-51h] BYREF
  void *v17; // [esp+128h] [ebp-10h] BYREF
  char *src; // [esp+12Ch] [ebp-Ch]

  v17 = dword_83307E4;
  dword_8330780 = 0;
  dword_8330784 = 0;
  while ( 1 )
  {
    result = (char *)Com_Parse(&v17);
    src = result;
    if ( !*result )
      break;
    result = src;
    if ( *src != 123 )
      break;
    v2 = 0;
    while ( 1 )
    {
      src = (char *)Com_Parse(&v17);
      if ( !*src )
        break;
      if ( *src == 125 )
        break;
      strcpy(dest, src);
      src = (char *)Com_Parse(&v17);
      if ( !*src )
        break;
      strcpy(s1, src);
      if ( !strcasecmp(dest, "classname") && !strcasecmp(s1, "misc_model") )
        v2 = 1;
    }
    if ( v2 )
      ++dword_8330780;
  }
  if ( dword_8330780 )
  {
    dword_8330784 = (int)sub_806C482(84 * dword_8330780);
    v17 = dword_83307E4;
    v1 = 0;
    while ( 1 )
    {
      result = (char *)Com_Parse(&v17);
      src = result;
      if ( !*result )
        break;
      result = src;
      if ( *src != 123 )
        break;
      v15[0] = 0;
      v12 = 0;
      v11 = 0;
      v10 = 0;
      v9 = 0;
      v8 = 0;
      v7 = 0;
      v6 = 1.0;
      v5 = 1065353216;
      v4 = 1065353216;
      v3 = 0;
      while ( 1 )
      {
        src = (char *)Com_Parse(&v17);
        if ( !*src )
          break;
        if ( *src == 125 )
          break;
        strcpy(dest, src);
        src = (char *)Com_Parse(&v17);
        if ( !*src )
          break;
        strcpy(s1, src);
        if ( !strcasecmp(dest, "classname") )
        {
          if ( !strcasecmp(s1, "misc_model") )
            v3 = 1;
        }
        else if ( !strcasecmp(dest, "model") )
        {
          strcpy(v15, s1);
        }
        else if ( !strcasecmp(dest, "origin") )
        {
          sscanf(s1, "%f %f %f", &v10, &v11, &v12);
        }
        else if ( !strcasecmp(dest, "angles") )
        {
          sscanf(s1, "%f %f %f", &v7, &v8, &v9);
        }
        else if ( !strcasecmp(dest, "modelscale_vec") )
        {
          sscanf(s1, "%f %f %f", &v4, &v5, &v6);
        }
        else if ( !strcasecmp(dest, "modelscale") )
        {
          v6 = atof(s1);
          v5 = LODWORD(v6);
          v4 = LODWORD(v6);
        }
      }
      if ( v3 )
        sub_80537EA(dword_8330784 + 84 * v1++, v16, (float *)&v10, (int)&v7, (float *)&v4);
    }
  }
  return result;
}
// 8330780: using guessed type int dword_8330780;
// 8330784: using guessed type int dword_8330784;

//----- (08053ED2) --------------------------------------------------------
int __cdecl sub_8053ED2(int a1, int *a2, float *a3, float *a4, int a5)
{
  void *v5; // esp
  int result; // eax
  _BYTE v7[20]; // [esp+18h] [ebp-B0h] BYREF
  int v8; // [esp+2Ch] [ebp-9Ch]
  int v9[4]; // [esp+30h] [ebp-98h] BYREF
  float v10; // [esp+40h] [ebp-88h]
  float v11; // [esp+44h] [ebp-84h]
  float v12; // [esp+48h] [ebp-80h]
  float v13; // [esp+50h] [ebp-78h] BYREF
  float v14; // [esp+54h] [ebp-74h]
  float v15; // [esp+58h] [ebp-70h]
  float v16[4]; // [esp+60h] [ebp-68h] BYREF
  float v17[4]; // [esp+70h] [ebp-58h] BYREF
  int v18[15]; // [esp+80h] [ebp-48h] BYREF
  _BYTE *v19; // [esp+BCh] [ebp-Ch]

  v18[0] = *a2;
  v8 = sub_80CEBCA(*(_DWORD *)a1);
  v5 = alloca(16 * ((unsigned int)((v8 << 6) + 15) >> 4));
  v19 = v7;
  sub_80CF2C4(*(_DWORD *)a1, (int)v7);
  v13 = *a3 - *(float *)(a1 + 4);
  v14 = a3[1] - *(float *)(a1 + 8);
  v15 = a3[2] - *(float *)(a1 + 12);
  sub_8069244(&v13, (float *)(a1 + 16), v16);
  v13 = *a4 - *(float *)(a1 + 4);
  v14 = a4[1] - *(float *)(a1 + 8);
  v15 = a4[2] - *(float *)(a1 + 12);
  sub_8069244(&v13, (float *)(a1 + 16), v17);
  result = sub_80CF4FE(*(_DWORD *)a1, (int)v18, (int)v19, v16, v17, a5);
  if ( result >= 0 )
  {
    LOWORD(v18[10]) = 1022;
    v10 = *a4 - *a3;
    v11 = a4[1] - a3[1];
    v12 = a4[2] - a3[2];
    *(float *)&v18[1] = v10 * *(float *)v18 + *a3;
    *(float *)&v18[2] = v11 * *(float *)v18 + a3[1];
    *(float *)&v18[3] = v12 * *(float *)v18 + a3[2];
    sub_80692EE((float *)&v18[4], (float *)(a1 + 16), (float *)v9);
    sub_8066845((float *)v9);
    v18[4] = v9[0];
    v18[5] = v9[1];
    v18[6] = v9[2];
    result = 12;
    qmemcpy(a2, v18, 0x30u);
  }
  return result;
}

//----- (080540DC) --------------------------------------------------------
int __cdecl sub_80540DC(int a1, int a2, __int16 a3, __int16 a4)
{
  int i; // [esp+4h] [ebp-8h]

  for ( i = 0; i < a1; ++i )
  {
    if ( *(_WORD *)(a2 + 4 * i) == a4 && *(_WORD *)(a2 + 4 * i + 2) == a3
      || *(_WORD *)(a2 + 4 * i) == a3 && *(_WORD *)(a2 + 4 * i + 2) == a4 )
    {
      return i;
    }
  }
  return -1;
}

//----- (08054176) --------------------------------------------------------
unsigned __int16 *__cdecl sub_8054176(int a1, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // esi
  char *v6; // ebx
  char v8; // [esp+2Fh] [ebp-80119h]
  char *v9; // [esp+34h] [ebp-80114h]
  char *v10; // [esp+3Ch] [ebp-8010Ch]
  char *v11; // [esp+44h] [ebp-80104h]
  char *v12; // [esp+4Ch] [ebp-800FCh]
  char *v13; // [esp+54h] [ebp-800F4h]
  char *v14; // [esp+5Ch] [ebp-800ECh]
  float v15; // [esp+64h] [ebp-800E4h]
  __int16 v16; // [esp+68h] [ebp-800E0h]
  int v17; // [esp+68h] [ebp-800E0h]
  __int16 v18; // [esp+6Ah] [ebp-800DEh]
  __int16 v19; // [esp+6Ch] [ebp-800DCh]
  __int16 v20; // [esp+6Ch] [ebp-800DCh]
  __int16 v21; // [esp+6Eh] [ebp-800DAh]
  float v22; // [esp+70h] [ebp-800D8h]
  float v23; // [esp+74h] [ebp-800D4h]
  float v24; // [esp+78h] [ebp-800D0h]
  float v25; // [esp+7Ch] [ebp-800CCh]
  float v26; // [esp+80h] [ebp-800C8h] BYREF
  float v27; // [esp+84h] [ebp-800C4h]
  float v28; // [esp+88h] [ebp-800C0h]
  float v29; // [esp+90h] [ebp-800B8h] BYREF
  float v30; // [esp+94h] [ebp-800B4h]
  float v31; // [esp+98h] [ebp-800B0h]
  int j; // [esp+A8h] [ebp-800A0h]
  int i; // [esp+ACh] [ebp-8009Ch]
  float v34; // [esp+B0h] [ebp-80098h]
  float v35; // [esp+B4h] [ebp-80094h]
  float v36; // [esp+B8h] [ebp-80090h]
  float v37; // [esp+BCh] [ebp-8008Ch]
  float v38; // [esp+C0h] [ebp-80088h] BYREF
  float v39; // [esp+C4h] [ebp-80084h]
  float v40; // [esp+C8h] [ebp-80080h]
  float v41; // [esp+D0h] [ebp-80078h]
  float v42; // [esp+D4h] [ebp-80074h]
  float v43; // [esp+D8h] [ebp-80070h]
  float v44[4]; // [esp+E0h] [ebp-80068h] BYREF
  float v45[7]; // [esp+F0h] [ebp-80058h] BYREF
  int v46; // [esp+10Ch] [ebp-8003Ch]
  __int16 s[131072]; // [esp+110h] [ebp-80038h] BYREF
  int v48[65538]; // [esp+40110h] [ebp-40038h] BYREF
  int v49; // [esp+80118h] [ebp-30h]
  int v50; // [esp+8011Ch] [ebp-2Ch]
  int v51; // [esp+80120h] [ebp-28h]
  char *v52; // [esp+80124h] [ebp-24h]
  _DWORD *v53; // [esp+80128h] [ebp-20h]
  unsigned __int16 *v54; // [esp+8012Ch] [ebp-1Ch]

  if ( a1 % 3 )
    Com_Error(1, (char *)&byte_80D7000);
  if ( a3 > 0xFFFF )
    Com_Error(1, (char *)&byte_80D7040);
  v51 = 0;
  v50 = 0;
  for ( i = 0; i < a1; i += 3 )
  {
    for ( j = 0; j <= 2; ++j )
    {
      v19 = *(_WORD *)(a2 + 2 * (i + j));
      v18 = *(_WORD *)(a2 + 2 * (i + (j + 1) % 3));
      v16 = *(_WORD *)(a2 + 2 * (i + (j + 2) % 3));
      if ( v19 == v18 )
        Com_Error(1, (char *)&byte_80D7080);
      v46 = sub_80540DC(v51, (int)v48, v19, v18);
      if ( v46 >= 0 )
      {
        v45[0] = *(float *)(a4 + 12 * v19) - *(float *)(a4 + 12 * v16);
        v45[1] = *(float *)(a4 + 12 * v19 + 4) - *(float *)(a4 + 12 * v16 + 4);
        v45[2] = *(float *)(a4 + 12 * v19 + 8) - *(float *)(a4 + 12 * v16 + 8);
        v44[0] = *(float *)(a4 + 12 * v18) - *(float *)(a4 + 12 * v16);
        v44[1] = *(float *)(a4 + 12 * v18 + 4) - *(float *)(a4 + 12 * v16 + 4);
        v44[2] = *(float *)(a4 + 12 * v18 + 8) - *(float *)(a4 + 12 * v16 + 8);
        v41 = *(float *)(a4 + 12 * s[v46 + 0x10000]) - *(float *)(a4 + 12 * v16);
        v42 = *(float *)(a4 + 12 * s[v46 + 0x10000] + 4) - *(float *)(a4 + 12 * v16 + 4);
        v43 = *(float *)(a4 + 12 * s[v46 + 0x10000] + 8) - *(float *)(a4 + 12 * v16 + 8);
        sub_80667A1(v44, v45, &v38);
        v37 = v38 * v41 + v39 * v42 + v40 * v43;
        if ( v37 > 0.0 )
        {
          v34 = sub_80666D0((float *)(a4 + 12 * v19), (float *)(a4 + 12 * s[v46 + 0x10000]));
          v35 = sub_80666D0((float *)(a4 + 12 * v18), (float *)(a4 + 12 * s[v46 + 0x10000]));
          v15 = v34 <= (long double)v35 ? v35 : v34;
          v36 = v15;
          if ( v15 * 0.0000000064000001 > v38 * v38 + v39 * v39 + v40 * v40 )
          {
            --v51;
            ++v50;
            LOWORD(v48[v46]) = v48[v51];
            HIWORD(v48[v46]) = HIWORD(v48[v51]);
            s[v46 + 0x10000] = s[v51 + 0x10000];
          }
        }
      }
      else
      {
        if ( (unsigned int)v51 > 0xFFFF )
          Com_Error(1, (char *)&byte_80D70C0);
        LOWORD(v48[v51]) = v19;
        HIWORD(v48[v51]) = v18;
        s[v51++ + 0x10000] = v16;
      }
    }
  }
  memset(s, -1, 0x20000u);
  v49 = 0;
  for ( i = 0; i < v51; ++i )
  {
    if ( s[SLOWORD(v48[i])] < 0 )
      s[SLOWORD(v48[i])] = v49++;
    if ( s[SHIWORD(v48[i])] < 0 )
      s[SHIWORD(v48[i])] = v49++;
  }
  v54 = (unsigned __int16 *)sub_806C482(72 * (a1 / 3) + 4);
  v53 = sub_806C482(16 * v49);
  v52 = (char *)sub_806C482(56 * v51);
  v21 = 0;
  *v54 = a1 / 3;
  for ( i = 0; i < *v54; ++i )
  {
    v17 = *(_DWORD *)(a2 + 6 * i);
    v20 = *(_WORD *)(a2 + 6 * i + 4);
    ((void (__cdecl *)(unsigned __int16 *, int, int, int))sub_806AA54)(
      &v54[36 * i + 2],
      a4 + 12 * (__int16)v17,
      a4 + 12 * SHIWORD(v17),
      a4 + 12 * v20);
    if ( *(float *)&v54[36 * i + 6] >= -0.001 )
    {
      if ( *(float *)&v54[36 * i + 6] > 0.001 )
        LOBYTE(v21) = 1;
    }
    else
    {
      HIBYTE(v21) = 1;
    }
    v29 = *(float *)(a4 + 12 * SHIWORD(v17)) - *(float *)(a4 + 12 * (__int16)v17);
    v30 = *(float *)(a4 + 12 * SHIWORD(v17) + 4) - *(float *)(a4 + 12 * (__int16)v17 + 4);
    v31 = *(float *)(a4 + 12 * SHIWORD(v17) + 8) - *(float *)(a4 + 12 * (__int16)v17 + 8);
    v25 = sub_8066845(&v29);
    v26 = *(float *)(a4 + 12 * v20) - *(float *)(a4 + 12 * (__int16)v17);
    v27 = *(float *)(a4 + 12 * v20 + 4) - *(float *)(a4 + 12 * (__int16)v17 + 4);
    v28 = *(float *)(a4 + 12 * v20 + 8) - *(float *)(a4 + 12 * (__int16)v17 + 8);
    v24 = sub_8066845(&v26);
    v23 = v29 * v26 + v30 * v27 + v31 * v28;
    v22 = 1.0 / (1.0 - v23 * v23);
    v29 = v29 * v22;
    v30 = v30 * v22;
    v31 = v31 * v22;
    v26 = v26 * v22;
    v27 = v27 * v22;
    v28 = v28 * v22;
    *(float *)&v54[36 * i + 10] = -v23 * v26 + v29;
    *(float *)&v54[36 * i + 12] = -v23 * v27 + v30;
    *(float *)&v54[36 * i + 14] = -v23 * v28 + v31;
    *(float *)&v54[36 * i + 10] = 1.0 / v25 * *(float *)&v54[36 * i + 10];
    *(float *)&v54[36 * i + 12] = 1.0 / v25 * *(float *)&v54[36 * i + 12];
    *(float *)&v54[36 * i + 14] = 1.0 / v25 * *(float *)&v54[36 * i + 14];
    *(float *)&v54[36 * i + 16] = *(float *)&v54[36 * i + 10] * *(float *)(a4 + 12 * (__int16)v17)
                                + *(float *)&v54[36 * i + 12] * *(float *)(a4 + 12 * (__int16)v17 + 4)
                                + *(float *)&v54[36 * i + 14] * *(float *)(a4 + 12 * (__int16)v17 + 8);
    *(float *)&v54[36 * i + 18] = -v23 * v29 + v26;
    *(float *)&v54[36 * i + 20] = -v23 * v30 + v27;
    *(float *)&v54[36 * i + 22] = -v23 * v31 + v28;
    *(float *)&v54[36 * i + 18] = 1.0 / v24 * *(float *)&v54[36 * i + 18];
    *(float *)&v54[36 * i + 20] = 1.0 / v24 * *(float *)&v54[36 * i + 20];
    *(float *)&v54[36 * i + 22] = 1.0 / v24 * *(float *)&v54[36 * i + 22];
    *(float *)&v54[36 * i + 24] = *(float *)&v54[36 * i + 18] * *(float *)(a4 + 12 * (__int16)v17)
                                + *(float *)&v54[36 * i + 20] * *(float *)(a4 + 12 * (__int16)v17 + 4)
                                + *(float *)&v54[36 * i + 22] * *(float *)(a4 + 12 * (__int16)v17 + 8);
    if ( s[(__int16)v17] < 0 )
      v14 = 0;
    else
      v14 = (char *)&v53[4 * s[(__int16)v17]];
    *(_DWORD *)&v54[36 * i + 26] = v14;
    if ( s[SHIWORD(v17)] < 0 )
      v13 = 0;
    else
      v13 = (char *)&v53[4 * s[SHIWORD(v17)]];
    *(_DWORD *)&v54[36 * i + 28] = v13;
    if ( s[v20] < 0 )
      v12 = 0;
    else
      v12 = (char *)&v53[4 * s[v20]];
    *(_DWORD *)&v54[36 * i + 30] = v12;
    v46 = sub_80540DC(v51, (int)v48, SHIWORD(v17), v20);
    if ( v46 < 0 )
      v11 = 0;
    else
      v11 = &v52[56 * v46];
    *(_DWORD *)&v54[36 * i + 32] = v11;
    v46 = sub_80540DC(v51, (int)v48, v20, v17);
    if ( v46 < 0 )
      v10 = 0;
    else
      v10 = &v52[56 * v46];
    *(_DWORD *)&v54[36 * i + 34] = v10;
    v46 = sub_80540DC(v51, (int)v48, v17, SHIWORD(v17));
    if ( v46 < 0 )
      v9 = 0;
    else
      v9 = &v52[56 * v46];
    *(_DWORD *)&v54[36 * i + 36] = v9;
  }
  v8 = 0;
  if ( HIBYTE(v21) && !(_BYTE)v21 )
    v8 = 1;
  *((_BYTE *)v54 + 2) = v8;
  sub_806A254(a5, a5 + 12);
  for ( i = 0; i < (int)a3; ++i )
  {
    sub_806A28F(a4 + 12 * i, a5, a5 + 12);
    if ( s[i] >= 0 )
    {
      v53[4 * s[i]] = 0;
      v53[4 * s[i] + 1] = *(_DWORD *)(a4 + 12 * i);
      v53[4 * s[i] + 2] = *(_DWORD *)(a4 + 12 * i + 4);
      v53[4 * s[i] + 3] = *(_DWORD *)(a4 + 12 * i + 8);
    }
  }
  for ( i = 0; i < v51; ++i )
  {
    *(_DWORD *)&v52[56 * i] = 0;
    *(_DWORD *)&v52[56 * i + 4] = *(_DWORD *)(a4 + 12 * SLOWORD(v48[i]));
    *(_DWORD *)&v52[56 * i + 8] = *(_DWORD *)(a4 + 12 * SLOWORD(v48[i]) + 4);
    *(_DWORD *)&v52[56 * i + 12] = *(_DWORD *)(a4 + 12 * SLOWORD(v48[i]) + 8);
    *(float *)&v52[56 * i + 40] = *(float *)(a4 + 12 * SHIWORD(v48[i])) - *(float *)(a4 + 12 * SLOWORD(v48[i]));
    *(float *)&v52[56 * i + 44] = *(float *)(a4 + 12 * SHIWORD(v48[i]) + 4) - *(float *)(a4 + 12 * SLOWORD(v48[i]) + 4);
    *(float *)&v52[56 * i + 48] = *(float *)(a4 + 12 * SHIWORD(v48[i]) + 8) - *(float *)(a4 + 12 * SLOWORD(v48[i]) + 8);
    v5 = 56 * i;
    v6 = v52;
    *(float *)&v6[v5 + 52] = sub_8066845((float *)&v52[56 * i + 40]);
    sub_80677A4((float *)&v52[56 * i + 16], (float *)&v52[56 * i + 40]);
    sub_80667A1((float *)&v52[56 * i + 40], (float *)&v52[56 * i + 16], (float *)&v52[56 * i + 28]);
  }
  return v54;
}
// 806A254: using guessed type int __cdecl sub_806A254(_DWORD, _DWORD);
// 806A28F: using guessed type int __cdecl sub_806A28F(_DWORD, _DWORD, _DWORD);
// 806AA54: using guessed type int sub_806AA54();

//----- (08055763) --------------------------------------------------------
int __cdecl sub_8055763(int a1, unsigned __int16 *a2)
{
  int result; // eax
  float v3; // [esp+8h] [ebp-40h]
  float v4; // [esp+Ch] [ebp-3Ch]
  float v5; // [esp+10h] [ebp-38h]
  float v6; // [esp+14h] [ebp-34h]
  float v7; // [esp+18h] [ebp-30h]
  float v8; // [esp+2Ch] [ebp-1Ch]
  float v9; // [esp+30h] [ebp-18h]
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v10 = *(float *)(a1 + 12) * *(float *)&a2[36 * i + 2]
        + *(float *)(a1 + 16) * *(float *)&a2[36 * i + 4]
        + *(float *)(a1 + 20) * *(float *)&a2[36 * i + 6]
        - *(float *)&a2[36 * i + 8];
    if ( v10 < 0.0 )
    {
      v11 = *(float *)a1 * *(float *)&a2[36 * i + 2]
          + *(float *)(a1 + 4) * *(float *)&a2[36 * i + 4]
          + *(float *)(a1 + 8) * *(float *)&a2[36 * i + 6]
          - *(float *)&a2[36 * i + 8];
      if ( v11 > 0.0 )
      {
        v9 = (v11 - 0.125) / (v11 - v10);
        if ( v9 < (long double)*(float *)(a1 + 196) )
        {
          v8 = v11 / (v11 - v10);
          v5 = *(float *)(a1 + 24) * v8 + *(float *)a1;
          v6 = *(float *)(a1 + 28) * v8 + *(float *)(a1 + 4);
          v7 = *(float *)(a1 + 32) * v8 + *(float *)(a1 + 8);
          v4 = v5 * *(float *)&a2[36 * i + 10]
             + v6 * *(float *)&a2[36 * i + 12]
             + v7 * *(float *)&a2[36 * i + 14]
             - *(float *)&a2[36 * i + 16];
          if ( v4 >= -0.001 && v4 <= 1.001 )
          {
            v3 = v5 * *(float *)&a2[36 * i + 18]
               + v6 * *(float *)&a2[36 * i + 20]
               + v7 * *(float *)&a2[36 * i + 22]
               - *(float *)&a2[36 * i + 24];
            if ( v3 >= -0.001 && v4 + v3 <= 1.001 )
            {
              *(float *)(a1 + 196) = v9;
              *(_DWORD *)(a1 + 212) = *(_DWORD *)&a2[36 * i + 2];
              *(_DWORD *)(a1 + 216) = *(_DWORD *)&a2[36 * i + 4];
              *(_DWORD *)(a1 + 220) = *(_DWORD *)&a2[36 * i + 6];
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (08055AAB) --------------------------------------------------------
int __cdecl sub_8055AAB(int a1, unsigned __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+18h] [ebp-A0h]
  int v5; // [esp+1Ch] [ebp-9Ch]
  int v6; // [esp+20h] [ebp-98h]
  float v7; // [esp+28h] [ebp-90h]
  float v8; // [esp+2Ch] [ebp-8Ch]
  float v9; // [esp+30h] [ebp-88h]
  float v10; // [esp+30h] [ebp-88h]
  float v11; // [esp+34h] [ebp-84h]
  float v12; // [esp+38h] [ebp-80h]
  int v13; // [esp+3Ch] [ebp-7Ch]
  float v14; // [esp+40h] [ebp-78h]
  float v15; // [esp+40h] [ebp-78h]
  float v16; // [esp+44h] [ebp-74h]
  float v17; // [esp+44h] [ebp-74h]
  float v18; // [esp+48h] [ebp-70h]
  float v19; // [esp+48h] [ebp-70h]
  float v20; // [esp+4Ch] [ebp-6Ch]
  float v21; // [esp+4Ch] [ebp-6Ch]
  float v22; // [esp+50h] [ebp-68h]
  float v23; // [esp+54h] [ebp-64h]
  float v24; // [esp+58h] [ebp-60h]
  float v25; // [esp+60h] [ebp-58h]
  float v26; // [esp+60h] [ebp-58h]
  float v27; // [esp+60h] [ebp-58h]
  float v28; // [esp+64h] [ebp-54h]
  float v29; // [esp+64h] [ebp-54h]
  float v30; // [esp+64h] [ebp-54h]
  float v31; // [esp+68h] [ebp-50h]
  float v32; // [esp+68h] [ebp-50h]
  float v33; // [esp+68h] [ebp-50h]
  float v34; // [esp+78h] [ebp-40h]
  float v35; // [esp+78h] [ebp-40h]
  float v36; // [esp+78h] [ebp-40h]
  float v37; // [esp+7Ch] [ebp-3Ch]
  float v38; // [esp+7Ch] [ebp-3Ch]
  float v39; // [esp+7Ch] [ebp-3Ch]
  float v40; // [esp+80h] [ebp-38h]
  float v41; // [esp+80h] [ebp-38h]
  float v42; // [esp+84h] [ebp-34h]
  float v43; // [esp+84h] [ebp-34h]
  float v44; // [esp+88h] [ebp-30h]
  float v45; // [esp+88h] [ebp-30h]
  float v46; // [esp+94h] [ebp-24h]
  float v47; // [esp+94h] [ebp-24h]
  float v48; // [esp+94h] [ebp-24h]
  float v49; // [esp+94h] [ebp-24h]
  float v50; // [esp+94h] [ebp-24h]
  float v51; // [esp+98h] [ebp-20h]
  float v52; // [esp+9Ch] [ebp-1Ch]
  float v53; // [esp+A0h] [ebp-18h]
  float v54; // [esp+A4h] [ebp-14h]
  int j; // [esp+A8h] [ebp-10h]
  int i; // [esp+ACh] [ebp-Ch]

  v9 = *(float *)(a1 + 252) - *(float *)(a1 + 248);
  if ( *((_BYTE *)a2 + 2) )
  {
    v11 = v9 * -2.0;
    *(float *)(a1 + 8) = *(float *)(a1 + 8) + v9;
    v2 = *(float *)(a1 + 20) + v9;
  }
  else
  {
    v11 = v9 + v9;
    *(float *)(a1 + 8) = *(float *)(a1 + 8) - v9;
    v2 = *(float *)(a1 + 20) - v9;
  }
  *(float *)(a1 + 20) = v2;
  v53 = *(float *)(a1 + 248) + 0.125;
  LODWORD(v54) = LODWORD(v53) ^ 0x80000000;
  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v51 = *(float *)(a1 + 12) * *(float *)&a2[36 * i + 2]
        + *(float *)(a1 + 16) * *(float *)&a2[36 * i + 4]
        + *(float *)(a1 + 20) * *(float *)&a2[36 * i + 6]
        - *(float *)&a2[36 * i + 8];
    if ( v51 < (long double)v53 )
    {
      v52 = *(float *)a1 * *(float *)&a2[36 * i + 2]
          + *(float *)(a1 + 4) * *(float *)&a2[36 * i + 4]
          + *(float *)(a1 + 8) * *(float *)&a2[36 * i + 6]
          - *(float *)&a2[36 * i + 8];
      v10 = v52 - v51;
      if ( v10 > 0.0 )
      {
        if ( v54 < (long double)v52 )
        {
          if ( v53 <= (long double)v52 )
          {
            v48 = (v52 - v53) / v10;
            if ( v48 > (long double)*(float *)(a1 + 196) )
              continue;
            v40 = *(float *)(a1 + 24) * v48 + *(float *)a1;
            v42 = *(float *)(a1 + 28) * v48 + *(float *)(a1 + 4);
            v44 = *(float *)(a1 + 32) * v48 + *(float *)(a1 + 8);
          }
          else
          {
            v48 = 0.0;
            v40 = *(float *)a1;
            v42 = *(float *)(a1 + 4);
            v44 = *(float *)(a1 + 8);
          }
          v39 = v40 * *(float *)&a2[36 * i + 10]
              + v42 * *(float *)&a2[36 * i + 12]
              + v44 * *(float *)&a2[36 * i + 14]
              - *(float *)&a2[36 * i + 16];
          v36 = v40 * *(float *)&a2[36 * i + 18]
              + v42 * *(float *)&a2[36 * i + 20]
              + v44 * *(float *)&a2[36 * i + 22]
              - *(float *)&a2[36 * i + 24];
          v5 = v39 + v36 > 1.0;
          if ( v39 < 0.0 )
            v5 |= 2u;
          v4 = v5;
          if ( v36 < 0.0 )
            v4 = v5 | 4;
          if ( v4 )
          {
            for ( j = 0; j <= 2; ++j )
            {
              if ( ((v4 >> j) & 1) != 0 )
              {
                v13 = *(_DWORD *)&a2[36 * i + 32 + 2 * j];
                if ( v13 && *(_DWORD *)v13 != dword_8330800 )
                {
                  *(_DWORD *)v13 = dword_8330800;
                  v25 = *(float *)a1 - *(float *)(v13 + 4);
                  v28 = *(float *)(a1 + 4) - *(float *)(v13 + 8);
                  v31 = *(float *)(a1 + 8) - *(float *)(v13 + 12);
                  v22 = v25 * *(float *)(v13 + 16) + v28 * *(float *)(v13 + 20) + v31 * *(float *)(v13 + 24);
                  v23 = v25 * *(float *)(v13 + 28) + v28 * *(float *)(v13 + 32) + v31 * *(float *)(v13 + 36);
                  v24 = v25 * *(float *)(v13 + 40) + v28 * *(float *)(v13 + 44) + v31 * *(float *)(v13 + 48);
                  v14 = v22 * v22 + v23 * v23 - v53 * v53;
                  if ( v14 > 0.0 )
                  {
                    v26 = *(float *)(a1 + 24) * *(float *)(v13 + 16)
                        + *(float *)(a1 + 28) * *(float *)(v13 + 20)
                        + *(float *)(a1 + 32) * *(float *)(v13 + 24);
                    v29 = *(float *)(a1 + 24) * *(float *)(v13 + 28)
                        + *(float *)(a1 + 28) * *(float *)(v13 + 32)
                        + *(float *)(a1 + 32) * *(float *)(v13 + 36);
                    v16 = v26 * v22 + v29 * v23;
                    if ( v16 < 0.0 )
                    {
                      v18 = v26 * v26 + v29 * v29;
                      v20 = v16 * v16 - v18 * v14;
                      if ( v20 > 0.0 )
                      {
                        v49 = (-sqrt(v20) - v16) / v18;
                        if ( *(float *)(a1 + 196) > (long double)v49 )
                        {
                          v32 = *(float *)(a1 + 24) * *(float *)(v13 + 40)
                              + *(float *)(a1 + 28) * *(float *)(v13 + 44)
                              + *(float *)(a1 + 32) * *(float *)(v13 + 48);
                          v45 = v49 * v32 + v24;
                          if ( v45 >= 0.0 && v45 <= (long double)*(float *)(v13 + 52) )
                          {
                            v41 = (v49 * v26 + v22) / v53;
                            v43 = (v49 * v29 + v23) / v53;
                            *(float *)(a1 + 212) = *(float *)(v13 + 16) * v41;
                            *(float *)(a1 + 216) = *(float *)(v13 + 20) * v41;
                            *(float *)(a1 + 220) = *(float *)(v13 + 24) * v41;
                            *(float *)(a1 + 212) = *(float *)(v13 + 28) * v43 + *(float *)(a1 + 212);
                            *(float *)(a1 + 216) = *(float *)(v13 + 32) * v43 + *(float *)(a1 + 216);
                            *(float *)(a1 + 220) = *(float *)(v13 + 36) * v43 + *(float *)(a1 + 220);
                            if ( *(float *)(a1 + 196) <= 0.0000099999997 )
                            {
                              *(_DWORD *)(a1 + 196) = 0;
                              result = a1;
                              *(_BYTE *)(a1 + 243) = 1;
                              return result;
                            }
                            *(float *)(a1 + 196) = v49 - 0.0000099999997;
                          }
                        }
                      }
                    }
                  }
                  else if ( v24 >= 0.0 && v24 <= (long double)*(float *)(v13 + 52) )
                  {
                    goto LABEL_52;
                  }
                }
              }
              else
              {
                v6 = *(_DWORD *)&a2[36 * i + 26 + 2 * j];
                if ( v6 && *(_DWORD *)v6 != dword_8330800 )
                {
                  *(_DWORD *)v6 = dword_8330800;
                  v27 = *(float *)a1 - *(float *)(v6 + 4);
                  v30 = *(float *)(a1 + 4) - *(float *)(v6 + 8);
                  v33 = *(float *)(a1 + 8) - *(float *)(v6 + 12);
                  v15 = v27 * v27 + v30 * v30 + v33 * v33 - v53 * v53;
                  if ( v15 <= 0.0 )
                    goto LABEL_52;
                  v17 = *(float *)(a1 + 24) * v27 + *(float *)(a1 + 28) * v30 + *(float *)(a1 + 32) * v33;
                  if ( v17 < 0.0 )
                  {
                    v19 = *(float *)(a1 + 36);
                    v21 = v17 * v17 - v19 * v15;
                    if ( v21 >= 0.0 )
                    {
                      v50 = (-sqrt(v21) - v17) / v19;
                      if ( *(float *)(a1 + 196) > (long double)v50 )
                      {
                        *(float *)(a1 + 212) = *(float *)(a1 + 24) * v50 + v27;
                        *(float *)(a1 + 216) = *(float *)(a1 + 28) * v50 + v30;
                        *(float *)(a1 + 220) = *(float *)(a1 + 32) * v50 + v33;
                        *(float *)(a1 + 212) = 1.0 / v53 * *(float *)(a1 + 212);
                        *(float *)(a1 + 216) = 1.0 / v53 * *(float *)(a1 + 216);
                        *(float *)(a1 + 220) = 1.0 / v53 * *(float *)(a1 + 220);
                        if ( *(float *)(a1 + 196) <= 0.0000099999997 )
                        {
                          *(_DWORD *)(a1 + 196) = 0;
                          result = a1;
                          *(_BYTE *)(a1 + 243) = 1;
                          return result;
                        }
                        *(float *)(a1 + 196) = v50 - 0.0000099999997;
                      }
                    }
                  }
                }
              }
            }
          }
          else
          {
            *(_DWORD *)(a1 + 212) = *(_DWORD *)&a2[36 * i + 2];
            *(_DWORD *)(a1 + 216) = *(_DWORD *)&a2[36 * i + 4];
            *(_DWORD *)(a1 + 220) = *(_DWORD *)&a2[36 * i + 6];
            if ( v48 <= 0.0000099999997 )
            {
              *(_DWORD *)(a1 + 196) = 0;
              result = a1;
              *(_BYTE *)(a1 + 243) = 1;
              return result;
            }
            *(float *)(a1 + 196) = v48 - 0.0000099999997;
          }
        }
        else
        {
          v12 = v11 * *(float *)&a2[36 * i + 6] + v52;
          if ( v54 < (long double)v12 )
          {
            v46 = (v54 - v52) / *(float *)&a2[36 * i + 6];
            v8 = *(float *)a1 * *(float *)&a2[36 * i + 10]
               + *(float *)(a1 + 4) * *(float *)&a2[36 * i + 12]
               + *(float *)(a1 + 8) * *(float *)&a2[36 * i + 14]
               - *(float *)&a2[36 * i + 16];
            v7 = *(float *)a1 * *(float *)&a2[36 * i + 18]
               + *(float *)(a1 + 4) * *(float *)&a2[36 * i + 20]
               + *(float *)(a1 + 8) * *(float *)&a2[36 * i + 22]
               - *(float *)&a2[36 * i + 24];
            v37 = v46 * *(float *)&a2[36 * i + 14] + v8;
            if ( v37 >= 0.0 )
            {
              v34 = v46 * *(float *)&a2[36 * i + 22] + v7;
              if ( v34 >= 0.0 && v37 + v34 <= 1.0 )
                goto LABEL_52;
            }
            v47 = v53 <= (long double)v12 ? (float)((v53 - v52) / *(float *)&a2[36 * i + 6]) : v11;
            v38 = v47 * *(float *)&a2[36 * i + 14] + v8;
            if ( v38 >= 0.0 )
            {
              v35 = v47 * *(float *)&a2[36 * i + 22] + v7;
              if ( v35 >= 0.0 && v38 + v35 <= 1.0 )
              {
LABEL_52:
                *(_DWORD *)(a1 + 212) = *(_DWORD *)&a2[36 * i + 2];
                *(_DWORD *)(a1 + 216) = *(_DWORD *)&a2[36 * i + 4];
                *(_DWORD *)(a1 + 220) = *(_DWORD *)&a2[36 * i + 6];
                *(_DWORD *)(a1 + 196) = 0;
                result = a1;
                *(_BYTE *)(a1 + 243) = 1;
                return result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 8330800: using guessed type int dword_8330800;

//----- (08056941) --------------------------------------------------------
int __cdecl sub_8056941(float *a1, unsigned __int16 *a2)
{
  long double v2; // fst7
  int v4; // [esp+18h] [ebp-80h]
  int v5; // [esp+1Ch] [ebp-7Ch]
  float v7; // [esp+28h] [ebp-70h]
  float v8; // [esp+2Ch] [ebp-6Ch]
  float v9; // [esp+30h] [ebp-68h]
  float v10; // [esp+34h] [ebp-64h]
  float v11; // [esp+38h] [ebp-60h]
  float v12; // [esp+3Ch] [ebp-5Ch]
  float v13; // [esp+3Ch] [ebp-5Ch]
  float v14; // [esp+40h] [ebp-58h]
  float v15; // [esp+44h] [ebp-54h]
  float *v16; // [esp+48h] [ebp-50h]
  float v17; // [esp+4Ch] [ebp-4Ch]
  float v18; // [esp+50h] [ebp-48h]
  float v19; // [esp+50h] [ebp-48h]
  float v20; // [esp+50h] [ebp-48h]
  float v21; // [esp+54h] [ebp-44h]
  float v22; // [esp+54h] [ebp-44h]
  float v23; // [esp+54h] [ebp-44h]
  float v24; // [esp+58h] [ebp-40h]
  float v25; // [esp+58h] [ebp-40h]
  float v26; // [esp+58h] [ebp-40h]
  float v27; // [esp+68h] [ebp-30h]
  float v28; // [esp+68h] [ebp-30h]
  float v29; // [esp+68h] [ebp-30h]
  float v30; // [esp+6Ch] [ebp-2Ch]
  float v31; // [esp+6Ch] [ebp-2Ch]
  float v32; // [esp+6Ch] [ebp-2Ch]
  float v33; // [esp+70h] [ebp-28h]
  float v34; // [esp+74h] [ebp-24h]
  float v35; // [esp+78h] [ebp-20h]
  float v36; // [esp+84h] [ebp-14h]
  int j; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  v9 = a1[63] - a1[62];
  if ( *((_BYTE *)a2 + 2) )
  {
    v10 = v9 * -2.0;
    a1[2] = a1[2] + v9;
    v2 = a1[5] + v9;
  }
  else
  {
    v10 = v9 + v9;
    a1[2] = a1[2] - v9;
    v2 = a1[5] - v9;
  }
  a1[5] = v2;
  v14 = a1[62];
  LODWORD(v15) = LODWORD(v14) ^ 0x80000000;
  for ( i = 0; i < *a2; ++i )
  {
    v36 = *a1 * *(float *)&a2[36 * i + 2]
        + a1[1] * *(float *)&a2[36 * i + 4]
        + a1[2] * *(float *)&a2[36 * i + 6]
        - *(float *)&a2[36 * i + 8];
    if ( v36 < (long double)v14 )
    {
      if ( v15 < (long double)v36 )
      {
        v33 = -v36 * *(float *)&a2[36 * i + 2] + *a1;
        v34 = -v36 * *(float *)&a2[36 * i + 4] + a1[1];
        v35 = -v36 * *(float *)&a2[36 * i + 6] + a1[2];
        v32 = v33 * *(float *)&a2[36 * i + 10]
            + v34 * *(float *)&a2[36 * i + 12]
            + v35 * *(float *)&a2[36 * i + 14]
            - *(float *)&a2[36 * i + 16];
        v29 = v33 * *(float *)&a2[36 * i + 18]
            + v34 * *(float *)&a2[36 * i + 20]
            + v35 * *(float *)&a2[36 * i + 22]
            - *(float *)&a2[36 * i + 24];
        v5 = v32 + v29 > 1.0;
        if ( v32 < 0.0 )
          v5 = (v32 + v29 > 1.0) | 2;
        v4 = v5;
        if ( v29 < 0.0 )
          v4 = v5 | 4;
        if ( !v4 )
          return 1;
        for ( j = 0; j <= 2; ++j )
        {
          if ( ((v4 >> j) & 1) != 0 )
          {
            v16 = *(float **)&a2[36 * i + 32 + 2 * j];
            if ( v16 )
            {
              v18 = *a1 - v16[1];
              v21 = a1[1] - v16[2];
              v24 = a1[2] - v16[3];
              v17 = v18 * v16[10] + v21 * v16[11] + v24 * v16[12];
              if ( v17 >= 0.0 && v16[13] >= (long double)v17 )
              {
                v19 = -v17 * v16[10] + v18;
                v22 = -v17 * v16[11] + v21;
                v25 = -v17 * v16[12] + v24;
                if ( a1[62] * a1[62] > v19 * v19 + v22 * v22 + v25 * v25 )
                  return 1;
              }
            }
          }
          else if ( *(_DWORD *)&a2[36 * i + 26 + 2 * j] )
          {
            v20 = *a1 - *(float *)(*(_DWORD *)&a2[36 * i + 26 + 2 * j] + 4);
            v23 = a1[1] - *(float *)(*(_DWORD *)&a2[36 * i + 26 + 2 * j] + 8);
            v26 = a1[2] - *(float *)(*(_DWORD *)&a2[36 * i + 26 + 2 * j] + 12);
            if ( a1[62] * a1[62] > v20 * v20 + v23 * v23 + v26 * v26 )
              return 1;
          }
        }
      }
      else
      {
        v11 = v10 * *(float *)&a2[36 * i + 6] + v36;
        if ( v15 < (long double)v11 )
        {
          v12 = (v15 - v36) / *(float *)&a2[36 * i + 6];
          v8 = *a1 * *(float *)&a2[36 * i + 10]
             + a1[1] * *(float *)&a2[36 * i + 12]
             + a1[2] * *(float *)&a2[36 * i + 14]
             - *(float *)&a2[36 * i + 16];
          v7 = *a1 * *(float *)&a2[36 * i + 18]
             + a1[1] * *(float *)&a2[36 * i + 20]
             + a1[2] * *(float *)&a2[36 * i + 22]
             - *(float *)&a2[36 * i + 24];
          v30 = v12 * *(float *)&a2[36 * i + 14] + v8;
          if ( v30 >= 0.0 )
          {
            v27 = v12 * *(float *)&a2[36 * i + 22] + v7;
            if ( v27 >= 0.0 && v30 + v27 <= 1.0 )
              return 1;
          }
          v13 = v14 <= (long double)v11 ? (float)((v14 - v36) / *(float *)&a2[36 * i + 6]) : v10;
          v31 = v13 * *(float *)&a2[36 * i + 14] + v8;
          if ( v31 >= 0.0 )
          {
            v28 = v13 * *(float *)&a2[36 * i + 22] + v7;
            if ( v28 >= 0.0 && v31 + v28 <= 1.0 )
              return 1;
          }
        }
      }
    }
  }
  return 0;
}

//----- (08057125) --------------------------------------------------------
int __cdecl sub_8057125(_DWORD *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( !dword_80E8C2C )
  {
    dword_80E8C2C = 1;
    Com_DPrintf("^1Box collision on terrain currently being faked with capsule collision\n");
  }
  a1[61] = 1;
  v5 = a1[2];
  v4 = a1[5];
  v3 = a1[62];
  a1[62] = a1[13];
  sub_8055AAB((int)a1, a2);
  a1[61] = 0;
  a1[2] = v5;
  a1[5] = v4;
  result = v3;
  a1[62] = v3;
  return result;
}
// 80E8C2C: using guessed type int dword_80E8C2C;

//----- (080571C3) --------------------------------------------------------
int __cdecl sub_80571C3(_DWORD *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( a1[48] )
    return sub_8055763((int)a1, a2);
  if ( !a1[61] )
    return sub_8057125(a1, a2);
  v4 = a1[2];
  v3 = a1[5];
  sub_8055AAB((int)a1, a2);
  a1[2] = v4;
  result = v3;
  a1[5] = v3;
  return result;
}

//----- (08057241) --------------------------------------------------------
_BOOL4 __cdecl sub_8057241(int *a1, unsigned __int16 *a2)
{
  unsigned int v3; // [esp+14h] [ebp-134h]
  int *v4; // [esp+18h] [ebp-130h]
  int *v5; // [esp+1Ch] [ebp-12Ch]
  int v6; // [esp+20h] [ebp-128h] BYREF
  int v7; // [esp+24h] [ebp-124h] BYREF
  float v8; // [esp+E4h] [ebp-64h]

  v5 = &v6;
  v4 = a1;
  v3 = 280;
  if ( ((unsigned __int8)&v6 & 4) != 0 )
  {
    v6 = *a1;
    v5 = &v7;
    v4 = a1 + 1;
    v3 = 276;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  v8 = 1.0;
  sub_80571C3(&v6, a2);
  return 1.0 == v8;
}

//----- (080572F0) --------------------------------------------------------
int __cdecl sub_80572F0(int a1, unsigned __int16 *a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 192) )
    return 0;
  v5 = *(_DWORD *)(a1 + 8);
  v4 = *(_DWORD *)(a1 + 20);
  v6 = sub_8056941((float *)a1, a2);
  *(_DWORD *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  return v6;
}

//----- (08057350) --------------------------------------------------------
int __cdecl sub_8057350(float *a1, int a2)
{
  long double v2; // fst7
  int v4; // [esp+0h] [ebp-Ch]
  __int16 *v5; // [esp+4h] [ebp-8h]
  float v6; // [esp+8h] [ebp-4h]

  while ( a2 >= 0 )
  {
    v5 = (__int16 *)(dword_83307A4 + 8 * a2);
    v4 = *(_DWORD *)v5;
    if ( *(_BYTE *)(*(_DWORD *)v5 + 16) > 2u )
      v2 = *(float *)v4 * *a1 + *(float *)(v4 + 4) * a1[1] + *(float *)(v4 + 8) * a1[2] - *(float *)(v4 + 12);
    else
      v2 = a1[*(unsigned __int8 *)(v4 + 16)] - *(float *)(v4 + 12);
    v6 = v2;
    if ( v6 >= 0.0 )
      a2 = v5[2];
    else
      a2 = v5[3];
  }
  return -1 - a2;
}
// 83307A4: using guessed type int dword_83307A4;

//----- (0805740A) --------------------------------------------------------
int __cdecl sub_805740A(float *a1)
{
  return sub_8057350(a1, 0);
}

//----- (08057425) --------------------------------------------------------
_DWORD *__cdecl sub_8057425(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+0h] [ebp-8h]

  v3 = -1 - a2;
  if ( *(_WORD *)(dword_83307AC + 16 * (-1 - a2)) != 0xFFFF )
    a1[10] = v3;
  if ( *a1 < a1[1] )
  {
    result = (_DWORD *)(-1 - a2);
    *(_DWORD *)(a1[3] + 4 * (*a1)++) = v3;
  }
  else
  {
    result = a1;
    a1[2] = 1;
  }
  return result;
}
// 83307AC: using guessed type int dword_83307AC;

//----- (0805748D) --------------------------------------------------------
int __cdecl sub_805748D(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-1Ch]
  int v4; // [esp+4h] [ebp-18h]
  int i; // [esp+10h] [ebp-Ch]
  int j; // [esp+14h] [ebp-8h]

  v4 = dword_83307AC + 16 * (-1 - a2);
  for ( i = 0; ; ++i )
  {
    result = *(unsigned __int16 *)(v4 + 8);
    if ( i >= result )
      break;
    v3 = dword_83307CC + 52 * *(_DWORD *)(dword_83307B4 + 4 * (*(_DWORD *)(v4 + 4) + i));
    if ( *(_DWORD *)(v3 + 36) != dword_8330800 )
    {
      *(_DWORD *)(v3 + 36) = dword_8330800;
      for ( j = 0;
            j <= 2
         && *(float *)(v3 + 4 * j + 4) < (long double)*(float *)&a1[j + 7]
         && *(float *)&a1[j + 4] < (long double)*(float *)(v3 + 4 * j + 16);
            ++j )
      {
        ;
      }
      if ( j == 3 )
      {
        if ( *a1 >= a1[1] )
        {
          result = (int)a1;
          a1[2] = 1;
          return result;
        }
        *(_DWORD *)(a1[3] + 4 * (*a1)++) = v3;
      }
    }
  }
  return result;
}
// 83307AC: using guessed type int dword_83307AC;
// 83307B4: using guessed type int dword_83307B4;
// 83307CC: using guessed type int dword_83307CC;
// 8330800: using guessed type int dword_8330800;

//----- (080575B2) --------------------------------------------------------
int __cdecl sub_80575B2(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  while ( a2 >= 0 )
  {
    v4 = dword_83307A4 + 8 * a2;
    v3 = sub_80D5F94((float *)(a1 + 16), (float *)(a1 + 28), *(_DWORD *)v4);
    if ( v3 == 1 )
    {
      a2 = *(__int16 *)(v4 + 4);
    }
    else
    {
      if ( v3 != 2 )
        sub_80575B2(a1, *(__int16 *)(v4 + 4));
      a2 = *(__int16 *)(v4 + 6);
    }
  }
  return (*(int (__cdecl **)(int, int))(a1 + 44))(a1, a2);
}
// 83307A4: using guessed type int dword_83307A4;

//----- (0805765D) --------------------------------------------------------
int __cdecl sub_805765D(int *a1, int *a2, int a3, int a4, _DWORD *a5)
{
  int v6[10]; // [esp+10h] [ebp-38h] BYREF
  int v7; // [esp+38h] [ebp-10h]
  _DWORD *(__cdecl *v8)(_DWORD *, int); // [esp+3Ch] [ebp-Ch]

  ++dword_8330800;
  v6[4] = *a1;
  v6[5] = a1[1];
  v6[6] = a1[2];
  v6[7] = *a2;
  v6[8] = a2[1];
  v6[9] = a2[2];
  v6[0] = 0;
  v6[1] = a4;
  v6[3] = a3;
  v8 = sub_8057425;
  v7 = 0;
  v6[2] = 0;
  sub_80575B2((int)v6, 0);
  *a5 = v7;
  return v6[0];
}
// 8330800: using guessed type int dword_8330800;

//----- (08057775) --------------------------------------------------------
int __cdecl sub_8057775(float *a1, int a2)
{
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+18h] [ebp-20h]
  _DWORD *v5; // [esp+1Ch] [ebp-1Ch]
  int *v6; // [esp+20h] [ebp-18h]
  int i; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int k; // [esp+2Ch] [ebp-Ch]

  if ( a2 )
    v6 = sub_804BBD8(a2) + 6;
  else
    v6 = (int *)(dword_83307AC + 16 * sub_8057350(a1, 0));
  v4 = 0;
  for ( i = 0; i < *((unsigned __int16 *)v6 + 4); ++i )
  {
    v5 = (_DWORD *)(dword_83307CC + 52 * *(_DWORD *)(dword_83307B4 + 4 * (v6[1] + i)));
    for ( j = 0; j <= 2; ++j )
    {
      if ( *(float *)&v5[j + 1] > (long double)a1[j] || a1[j] > (long double)*(float *)&v5[j + 4] )
        goto LABEL_16;
    }
    v3 = v5[8];
    for ( k = v5[7]; k; --k )
    {
      if ( *a1 * **(float **)v3 + a1[1] * *(float *)(*(_DWORD *)v3 + 4) + a1[2] * *(float *)(*(_DWORD *)v3 + 8) > (long double)*(float *)(*(_DWORD *)v3 + 12) )
        goto LABEL_16;
      v3 += 8;
    }
    v4 |= *v5;
LABEL_16:
    ;
  }
  return v4;
}
// 83307AC: using guessed type int dword_83307AC;
// 83307B4: using guessed type int dword_83307B4;
// 83307CC: using guessed type int dword_83307CC;

//----- (080578F7) --------------------------------------------------------
int __cdecl sub_80578F7(float *a1, int a2, float *a3, float *a4)
{
  float v5; // [esp+1Ch] [ebp-5Ch]
  float v6[4]; // [esp+20h] [ebp-58h] BYREF
  float v7[4]; // [esp+30h] [ebp-48h] BYREF
  float v8[4]; // [esp+40h] [ebp-38h] BYREF
  float v9; // [esp+50h] [ebp-28h]
  float v10; // [esp+54h] [ebp-24h]
  float v11; // [esp+58h] [ebp-20h]
  float v12; // [esp+60h] [ebp-18h] BYREF
  unsigned int v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]

  v12 = *a1 - *a3;
  *(float *)&v13 = a1[1] - a3[1];
  v14 = a1[2] - a3[2];
  if ( a2 != 511 && (*a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0) )
  {
    sub_806759D(a4, (int)v8, v7, v6);
    v9 = v12;
    v10 = *(float *)&v13;
    v11 = v14;
    v12 = v12 * v8[0] + *(float *)&v13 * v8[1] + v14 * v8[2];
    v5 = v9 * v7[0] + *(float *)&v13 * v7[1] + v14 * v7[2];
    v13 = LODWORD(v5) ^ 0x80000000;
    v14 = v9 * v6[0] + v10 * v6[1] + v14 * v6[2];
  }
  return sub_8057775(&v12, a2);
}

//----- (08057A1A) --------------------------------------------------------
char *__cdecl sub_8057A1A(int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 >= 0 && a1 < dword_83307D0 && dword_83307DC )
    v2 = (char *)dword_83307D8 + dword_83307D4 * a1;
  else
    v2 = (char *)dword_83307D8;
  return v2;
}
// 83307D0: using guessed type int dword_83307D0;
// 83307DC: using guessed type int dword_83307DC;

//----- (08057A5C) --------------------------------------------------------
int __cdecl sub_8057A5C(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (int *)(dword_83307EC + 8 * a1);
  if ( v4[1] == dword_83307FC )
  {
    result = *v4;
    if ( *v4 != a2 )
      Com_Error(1, (char *)&byte_80D7180);
  }
  else
  {
    *v4 = a2;
    v4[1] = dword_83307FC;
    v3 = dword_83307F0 + 4 * dword_83307E8 * a1;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_83307E8 )
        break;
      if ( *(int *)(v3 + 4 * i) > 0 )
        sub_8057A5C(i, a2);
    }
  }
  return result;
}
// 83307E8: using guessed type int dword_83307E8;
// 83307EC: using guessed type int dword_83307EC;
// 83307F0: using guessed type int dword_83307F0;
// 83307FC: using guessed type int dword_83307FC;

//----- (08057B0A) --------------------------------------------------------
int CM_FloodAreaConnections()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  ++dword_83307FC;
  v1 = 0;
  v2 = dword_83307EC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_83307E8 )
      break;
    if ( *(_DWORD *)(v2 + 4) != dword_83307FC )
      sub_8057A5C(i, ++v1);
    v2 += 8;
  }
  return result;
}
// 83307E8: using guessed type int dword_83307E8;
// 83307EC: using guessed type int dword_83307EC;
// 83307FC: using guessed type int dword_83307FC;

//----- (08057B6F) --------------------------------------------------------
int __cdecl sub_8057B6F(int a1, int a2, int a3)
{
  int result; // eax

  if ( a1 >= 0 && a2 >= 0 )
  {
    if ( a1 >= dword_83307E8 || a2 >= dword_83307E8 )
      Com_Error(1, (char *)&byte_80D71A0);
    if ( a3 )
    {
      ++*(_DWORD *)(dword_83307F0 + 4 * (a2 + dword_83307E8 * a1));
      ++*(_DWORD *)(dword_83307F0 + 4 * (a1 + dword_83307E8 * a2));
    }
    else if ( *(_DWORD *)(dword_83307F0 + 4 * (a1 + dword_83307E8 * a2)) )
    {
      --*(_DWORD *)(dword_83307F0 + 4 * (a2 + dword_83307E8 * a1));
      if ( (int)--*(_DWORD *)(dword_83307F0 + 4 * (a1 + dword_83307E8 * a2)) < 0 )
        Com_Error(1, (char *)&byte_80D71E0);
    }
    result = CM_FloodAreaConnections();
  }
  return result;
}
// 83307E8: using guessed type int dword_83307E8;
// 83307F0: using guessed type int dword_83307F0;

//----- (08057C89) --------------------------------------------------------
_BOOL4 __cdecl sub_8057C89(int a1, int a2)
{
  _BOOL4 v3; // [esp+0h] [ebp-Ch]

  if ( a1 >= 0 && a2 >= 0 )
    v3 = *(_DWORD *)(dword_83307EC + 8 * a1) == *(_DWORD *)(dword_83307EC + 8 * a2);
  else
    v3 = 0;
  return v3;
}
// 83307EC: using guessed type int dword_83307EC;

//----- (08057CE4) --------------------------------------------------------
float *__cdecl sub_8057CE4(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  *a1 = *a2 * *a1 + a2[1] * v4 + a2[2] * v5;
  a1[1] = a2[3] * v3 + a2[4] * v4 + a2[5] * v5;
  result = a2 + 8;
  a1[2] = a2[6] * v3 + a2[7] * v4 + a2[8] * v5;
  return result;
}

//----- (08057D8B) --------------------------------------------------------
int *__cdecl sub_8057D8B(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (08057DF6) --------------------------------------------------------
unsigned int __cdecl sub_8057DF6(float *a1, int a2)
{
  sub_806759D(a1, a2, (float *)(a2 + 12), (float *)(a2 + 24));
  return sub_8066B4E((_DWORD *)(a2 + 12));
}

//----- (08057E32) --------------------------------------------------------
float *__cdecl sub_8057E32(float *a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+0h] [ebp-18h]
  float v6; // [esp+4h] [ebp-14h]
  float v7; // [esp+8h] [ebp-10h]

  v5 = *a1 - *a2;
  v6 = a1[1] - a2[1];
  v7 = a1[2] - a2[2];
  *a4 = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * *a3 + *a2;
  a4[1] = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * a3[1] + a2[1];
  result = a3 + 2;
  a4[2] = (v5 * *a3 + v6 * a3[1] + v7 * a3[2]) * a3[2] + a2[2];
  return result;
}

//----- (080581AF) --------------------------------------------------------
void __cdecl sub_80581AF(int a1, int a2)
{
  float v2; // [esp+0h] [ebp-38h]
  float v3; // [esp+4h] [ebp-34h]
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+18h] [ebp-20h]
  float **v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+24h] [ebp-14h]
  float *v11; // [esp+28h] [ebp-10h]
  float *v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]

  if ( *(float *)(a1 + 164) <= (long double)*(float *)(a2 + 16)
    && *(float *)(a1 + 168) <= (long double)*(float *)(a2 + 20)
    && *(float *)(a1 + 172) <= (long double)*(float *)(a2 + 24)
    && *(float *)(a2 + 4) <= (long double)*(float *)(a1 + 176)
    && *(float *)(a2 + 8) <= (long double)*(float *)(a1 + 180)
    && *(float *)(a2 + 12) <= (long double)*(float *)(a1 + 184) )
  {
    v6 = *(float ***)(a2 + 32);
    v13 = *(_DWORD *)(a2 + 28);
    if ( *(_DWORD *)(a1 + 244) )
    {
      while ( v13 )
      {
        v11 = *v6;
        v5 = *v11 * *(float *)(a1 + 256) + v11[1] * *(float *)(a1 + 260) + v11[2] * *(float *)(a1 + 264);
        if ( v5 <= 0.0 )
        {
          v2 = *(float *)a1 + *(float *)(a1 + 256);
          v3 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
          v4 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
        }
        else
        {
          v2 = *(float *)a1 - *(float *)(a1 + 256);
          v3 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
          v4 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
        }
        v9 = (*v6)[3] + *(float *)(a1 + 248);
        v7 = v2 * *v11 + v3 * v11[1] + v4 * v11[2] - v9;
        if ( v7 > 0.0 )
          return;
        --v13;
        v6 += 2;
      }
    }
    else
    {
      while ( v13 )
      {
        v12 = *v6;
        v10 = v12[3]
            - (*(float *)(a1 + 12 * *((unsigned __int8 *)v12 + 17) + 64) * *v12
             + *(float *)(a1 + 12 * *((unsigned __int8 *)v12 + 17) + 68) * v12[1]
             + *(float *)(a1 + 12 * *((unsigned __int8 *)*v6 + 17) + 72) * v12[2]);
        v8 = *(float *)a1 * *v12 + *(float *)(a1 + 4) * v12[1] + *(float *)(a1 + 8) * v12[2] - v10;
        if ( v8 > 0.0 )
          return;
        --v13;
        v6 += 2;
      }
    }
    *(_BYTE *)(a1 + 242) = 1;
    *(_BYTE *)(a1 + 243) = 1;
    *(_DWORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 228) = *(_DWORD *)a2;
  }
}

//----- (08058494) --------------------------------------------------------
int __cdecl sub_8058494(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int16 *)(a2 + 8); ++i )
  {
    v4 = (_DWORD *)(dword_83307CC + 52 * *(_DWORD *)(dword_83307B4 + 4 * (*(_DWORD *)(a2 + 4) + i)));
    if ( v4[9] != dword_8330800 )
    {
      v4[9] = dword_8330800;
      if ( (*v4 & *(_DWORD *)(a1 + 188)) != 0 )
      {
        sub_80581AF(a1, (int)v4);
        result = a1;
        if ( *(_BYTE *)(a1 + 242) )
          return result;
      }
    }
  }
  result = dword_8330720;
  if ( !*(_DWORD *)(dword_8330720 + 32) )
  {
    for ( j = 0; ; ++j )
    {
      result = *(unsigned __int16 *)(a2 + 12);
      if ( j >= result )
        break;
      v3 = dword_83307F8 + 44 * *(_DWORD *)(dword_83307BC + 4 * (j + *(unsigned __int16 *)(a2 + 10)));
      if ( *(_DWORD *)v3 != dword_8330800 )
      {
        *(_DWORD *)v3 = dword_8330800;
        if ( (*(_DWORD *)(v3 + 8) & *(_DWORD *)(a1 + 188)) != 0 )
        {
          if ( *(_DWORD *)(v3 + 36) )
          {
            if ( sub_805111E(a1, *(_DWORD **)(v3 + 36)) )
            {
              *(_BYTE *)(a1 + 242) = 1;
              *(_BYTE *)(a1 + 243) = 1;
              result = a1;
              *(_DWORD *)(a1 + 196) = 0;
              return result;
            }
          }
          else if ( sub_80572F0(a1, *(unsigned __int16 **)(v3 + 40)) )
          {
            *(_BYTE *)(a1 + 242) = 1;
            *(_BYTE *)(a1 + 243) = 1;
            result = a1;
            *(_DWORD *)(a1 + 196) = 0;
            return result;
          }
        }
      }
    }
  }
  return result;
}
// 8330720: using guessed type int dword_8330720;
// 83307B4: using guessed type int dword_83307B4;
// 83307BC: using guessed type int dword_83307BC;
// 83307CC: using guessed type int dword_83307CC;
// 83307F8: using guessed type int dword_83307F8;
// 8330800: using guessed type int dword_8330800;

//----- (0805865B) --------------------------------------------------------
void __cdecl sub_805865B(int a1)
{
  float v1; // [esp+10h] [ebp-B8h]
  float v2; // [esp+14h] [ebp-B4h]
  float v3; // [esp+18h] [ebp-B0h]
  float v4; // [esp+1Ch] [ebp-ACh]
  float v5; // [esp+20h] [ebp-A8h]
  float v6[3]; // [esp+30h] [ebp-98h]
  float v7[2]; // [esp+3Ch] [ebp-8Ch]
  float v8; // [esp+44h] [ebp-84h]
  float v9; // [esp+50h] [ebp-78h]
  float v10; // [esp+54h] [ebp-74h]
  float v11; // [esp+58h] [ebp-70h]
  float v12; // [esp+60h] [ebp-68h]
  float v13; // [esp+64h] [ebp-64h]
  float v14; // [esp+68h] [ebp-60h]
  float v15; // [esp+70h] [ebp-58h]
  float v16; // [esp+74h] [ebp-54h]
  float v17; // [esp+78h] [ebp-50h]
  float v18; // [esp+80h] [ebp-48h]
  float v19; // [esp+84h] [ebp-44h]
  float v20; // [esp+88h] [ebp-40h]
  float v21; // [esp+90h] [ebp-38h]
  float v22; // [esp+94h] [ebp-34h]
  float v23; // [esp+98h] [ebp-30h]
  float v24; // [esp+A0h] [ebp-28h]
  float v25; // [esp+A4h] [ebp-24h]
  float v26; // [esp+A8h] [ebp-20h]
  int i; // [esp+BCh] [ebp-Ch]

  v24 = *(float *)a1 + *(float *)(a1 + 256);
  v25 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
  v26 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
  v21 = *(float *)a1 - *(float *)(a1 + 256);
  v22 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
  v23 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
  for ( i = 0; i <= 2; ++i )
  {
    *(&v9 + i) = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
    v6[i] = *(float *)&dword_8330820[i] - *(&v9 + i);
    v7[i] = *(float *)&dword_833082C[i] - *(&v9 + i);
  }
  if ( v7[0] <= (long double)v8 )
    v1 = v7[0];
  else
    v1 = v8;
  v5 = v8 - v1;
  v4 = (*(float *)(a1 + 248) + v1) * (*(float *)(a1 + 248) + v1);
  v18 = v9;
  v19 = v10;
  v20 = v11 + v5;
  v12 = v9 - v24;
  v13 = v10 - v25;
  v14 = v20 - v26;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(_BYTE *)(a1 + 242) = 1;
    *(_BYTE *)(a1 + 243) = 1;
    *(_DWORD *)(a1 + 196) = 0;
  }
  v12 = v18 - v21;
  v13 = v19 - v22;
  v14 = v20 - v23;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(_BYTE *)(a1 + 242) = 1;
    *(_BYTE *)(a1 + 243) = 1;
    *(_DWORD *)(a1 + 196) = 0;
  }
  v15 = v9;
  v16 = v10;
  v17 = v11 - v5;
  v12 = v9 - v24;
  v13 = v10 - v25;
  v14 = v17 - v26;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(_BYTE *)(a1 + 242) = 1;
    *(_BYTE *)(a1 + 243) = 1;
    *(_DWORD *)(a1 + 196) = 0;
  }
  v12 = v15 - v21;
  v13 = v16 - v22;
  v14 = v17 - v23;
  if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
  {
    *(_BYTE *)(a1 + 242) = 1;
    *(_BYTE *)(a1 + 243) = 1;
    *(_DWORD *)(a1 + 196) = 0;
  }
  v3 = *(float *)(a1 + 8) - v11;
  v2 = v5 + *(float *)(a1 + 252) - *(float *)(a1 + 248);
  if ( v2 >= (long double)v3 && v3 >= -v2 )
  {
    v20 = 0.0;
    v26 = 0.0;
    v12 = v24 - v18;
    v13 = v25 - v19;
    v14 = 0.0 - 0.0;
    if ( v4 > v12 * v12 + v13 * v13 + v14 * v14 )
    {
      *(_BYTE *)(a1 + 242) = 1;
      *(_BYTE *)(a1 + 243) = 1;
      *(_DWORD *)(a1 + 196) = 0;
    }
  }
}
// 8330820: using guessed type int dword_8330820[];
// 833082C: using guessed type int dword_833082C[];

//----- (08058A60) --------------------------------------------------------
void __cdecl sub_8058A60(int a1)
{
  float v1; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v3[3]; // [esp+20h] [ebp-38h]
  float v4[2]; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+34h] [ebp-24h]
  float v6[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v6[i] = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
    v3[i] = *(float *)&dword_8330820[i] - v6[i];
    v4[i] = *(float *)&dword_833082C[i] - v6[i];
    *(float *)(a1 + 4 * i) = *(float *)(a1 + 4 * i) - v6[i];
    *(float *)(a1 + 4 * i + 12) = *(float *)(a1 + 4 * i + 12) - v6[i];
  }
  *(_DWORD *)(a1 + 244) = 1;
  if ( v4[0] <= (long double)v5 )
    v1 = v4[0];
  else
    v1 = v5;
  *(float *)(a1 + 248) = v1;
  *(float *)(a1 + 252) = v5;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(float *)(a1 + 264) = v5 - *(float *)(a1 + 248);
  sub_804BDD3((int *)(a1 + 40), (int *)(a1 + 52), *(_DWORD *)dword_833081C, 0);
  sub_80581AF(a1, dword_833081C);
}
// 833081C: using guessed type int dword_833081C;
// 8330820: using guessed type int dword_8330820[];
// 833082C: using guessed type int dword_833082C[];

//----- (08058BCA) --------------------------------------------------------
int __cdecl sub_8058BCA(int a1)
{
  int result; // eax
  int v2[4]; // [esp+10h] [ebp-1048h] BYREF
  float v3[3]; // [esp+20h] [ebp-1038h]
  float v4[8]; // [esp+2Ch] [ebp-102Ch]
  int i; // [esp+4Ch] [ebp-100Ch]
  int v6[1026]; // [esp+50h] [ebp-1008h] BYREF

  v3[0] = *(float *)a1 + *(float *)(a1 + 40);
  v3[1] = *(float *)(a1 + 4) + *(float *)(a1 + 44);
  v3[2] = *(float *)(a1 + 8) + *(float *)(a1 + 48);
  v4[0] = *(float *)a1 + *(float *)(a1 + 52);
  v4[1] = *(float *)(a1 + 4) + *(float *)(a1 + 56);
  v4[2] = *(float *)(a1 + 8) + *(float *)(a1 + 60);
  for ( i = 0; i <= 2; ++i )
  {
    v3[i] = v3[i] - 1.0;
    v4[i] = v4[i] + 1.0;
  }
  v2[0] = 0;
  v2[1] = 1024;
  v2[3] = (int)v6;
  LODWORD(v4[4]) = sub_8057425;
  v4[3] = 0.0;
  v2[2] = 0;
  ++dword_8330800;
  sub_80575B2((int)v2, 0);
  ++dword_8330800;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2[0] )
      break;
    sub_8058494(a1, dword_83307AC + 16 * v6[i]);
    result = a1;
    if ( *(_BYTE *)(a1 + 242) )
      break;
  }
  return result;
}
// 83307AC: using guessed type int dword_83307AC;
// 8330800: using guessed type int dword_8330800;

//----- (08058D51) --------------------------------------------------------
_BOOL4 __cdecl sub_8058D51(int a1, float *a2, float *a3)
{
  float v5; // [esp+Ch] [ebp-6Ch]
  float v6; // [esp+Ch] [ebp-6Ch]
  float v7; // [esp+Ch] [ebp-6Ch]
  float v8; // [esp+10h] [ebp-68h]
  float v9; // [esp+14h] [ebp-64h]
  float v10; // [esp+18h] [ebp-60h]
  float v11; // [esp+20h] [ebp-58h]
  float v12; // [esp+24h] [ebp-54h]
  float v13; // [esp+28h] [ebp-50h]
  float v14; // [esp+30h] [ebp-48h]
  float v15; // [esp+34h] [ebp-44h]
  float v16; // [esp+38h] [ebp-40h]
  float v17; // [esp+40h] [ebp-38h]
  float v18; // [esp+44h] [ebp-34h]
  float v19; // [esp+48h] [ebp-30h]
  float v20; // [esp+50h] [ebp-28h]
  float v21; // [esp+54h] [ebp-24h]
  float v22; // [esp+58h] [ebp-20h]
  float v23; // [esp+60h] [ebp-18h]
  float v24; // [esp+64h] [ebp-14h]
  float v25; // [esp+68h] [ebp-10h]

  if ( *(float *)(a1 + 164) > (long double)*a3 || *a2 > (long double)*(float *)(a1 + 176) )
    return 0;
  if ( *(float *)(a1 + 168) > (long double)a3[1] || a2[1] > (long double)*(float *)(a1 + 180) )
    return 0;
  if ( *(float *)(a1 + 172) > (long double)a3[2] || a2[2] > (long double)*(float *)(a1 + 184) )
    return 0;
  if ( !*(_DWORD *)(a1 + 192) )
    return 1;
  v11 = *a3 - *a2;
  v12 = a3[1] - a2[1];
  v13 = a3[2] - a2[2];
  v20 = *a3 + *a2;
  v21 = a3[1] + a2[1];
  v22 = a3[2] + a2[2];
  v23 = *(float *)(a1 + 12) + *(float *)a1;
  v24 = *(float *)(a1 + 16) + *(float *)(a1 + 4);
  v25 = *(float *)(a1 + 20) + *(float *)(a1 + 8);
  v17 = v23 - v20;
  v18 = v24 - v21;
  v19 = v25 - v22;
  v8 = *(float *)(a1 + 176) - *(float *)(a1 + 164);
  v9 = *(float *)(a1 + 180) - *(float *)(a1 + 168);
  v10 = *(float *)(a1 + 184) - *(float *)(a1 + 172);
  v14 = *(float *)(a1 + 28) * v19 - *(float *)(a1 + 32) * v18;
  v5 = v12 * v10 + v13 * v9;
  if ( v14 * v14 > v5 * v5 )
    return 0;
  v15 = *(float *)(a1 + 32) * v17 - *(float *)(a1 + 24) * v19;
  v6 = v11 * v10 + v13 * v8;
  if ( v15 * v15 > v6 * v6 )
    return 0;
  v16 = *(float *)(a1 + 24) * v18 - *(float *)(a1 + 28) * v17;
  v7 = v11 * v9 + v12 * v8;
  return v16 * v16 <= v7 * v7;
}

//----- (08058FFC) --------------------------------------------------------
void __cdecl sub_8058FFC(int a1, int a2)
{
  float v2; // [esp+14h] [ebp-4h]

  if ( sub_8058D51(a1, (float *)(a2 + 12), (float *)(a2 + 24)) )
  {
    v2 = *(float *)(a1 + 196);
    if ( *(_DWORD *)(a2 + 36) )
      sub_805050A(a1, *(_DWORD **)(a2 + 36));
    else
      sub_80571C3((_DWORD *)a1, *(unsigned __int16 **)(a2 + 40));
    if ( v2 > (long double)*(float *)(a1 + 196) )
    {
      *(_DWORD *)(a1 + 224) = *((_DWORD *)dword_833078C + 18 * *(_DWORD *)(a2 + 4) + 16);
      *(_DWORD *)(a1 + 228) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a1 + 232) = (char *)dword_833078C + 72 * *(_DWORD *)(a2 + 4);
    }
  }
}

//----- (080590D6) --------------------------------------------------------
void __cdecl sub_80590D6(int a1, _DWORD *a2)
{
  int v2; // [esp+Ch] [ebp-9Ch]
  int v3; // [esp+10h] [ebp-98h] BYREF
  int v4; // [esp+14h] [ebp-94h]
  int v5; // [esp+18h] [ebp-90h]
  int *v6; // [esp+38h] [ebp-70h] BYREF
  int v7; // [esp+3Ch] [ebp-6Ch]
  int i; // [esp+40h] [ebp-68h]
  _DWORD *v9; // [esp+44h] [ebp-64h]
  float v10; // [esp+48h] [ebp-60h]
  float v11; // [esp+4Ch] [ebp-5Ch]
  float v12; // [esp+50h] [ebp-58h]
  float v13; // [esp+54h] [ebp-54h]
  float v14; // [esp+58h] [ebp-50h]
  float v15; // [esp+60h] [ebp-48h]
  float v16; // [esp+64h] [ebp-44h]
  float v17; // [esp+68h] [ebp-40h]
  float v18; // [esp+70h] [ebp-38h]
  int **v19; // [esp+74h] [ebp-34h]
  int *v20; // [esp+78h] [ebp-30h]
  float v21; // [esp+7Ch] [ebp-2Ch]
  int v22; // [esp+80h] [ebp-28h]
  float v23; // [esp+84h] [ebp-24h]
  float v24; // [esp+88h] [ebp-20h]
  float v25; // [esp+8Ch] [ebp-1Ch]
  float v26; // [esp+90h] [ebp-18h]
  float v27; // [esp+94h] [ebp-14h]
  int v28; // [esp+98h] [ebp-10h]
  int v29; // [esp+9Ch] [ebp-Ch]

  v26 = 0.0;
  v25 = *(float *)(a1 + 196);
  v22 = 1;
  v19 = 0;
  v10 = -1.0;
  v9 = a2 + 1;
  v2 = 0;
  if ( *(_DWORD *)(a1 + 244) )
  {
LABEL_2:
    for ( i = 0; ; ++i )
    {
      if ( i > 2 )
      {
        if ( !v2 )
        {
          v10 = 1.0;
          v9 = a2 + 4;
          v2 = 1;
          goto LABEL_2;
        }
        v20 = (int *)a2[8];
        v29 = a2[7];
        while ( 2 )
        {
          if ( !v29 )
            goto LABEL_73;
          v28 = *v20;
          v27 = *(float *)(v28 + 12) + *(float *)(a1 + 248);
          v18 = *(float *)v28 * *(float *)(a1 + 256)
              + *(float *)(v28 + 4) * *(float *)(a1 + 260)
              + *(float *)(v28 + 8) * *(float *)(a1 + 264);
          if ( v18 <= 0.0 )
          {
            v15 = *(float *)a1 + *(float *)(a1 + 256);
            v16 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
            v17 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
            v12 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
            v13 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
            v14 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
          }
          else
          {
            v15 = *(float *)a1 - *(float *)(a1 + 256);
            v16 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
            v17 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
            v12 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
            v13 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
            v14 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
          }
          v24 = v15 * *(float *)v28 + v16 * *(float *)(v28 + 4) + v17 * *(float *)(v28 + 8) - v27;
          v23 = v12 * *(float *)v28 + v13 * *(float *)(v28 + 4) + v14 * *(float *)(v28 + 8) - v27;
          if ( v24 <= 0.0 )
          {
            if ( v23 > 0.0 )
            {
              v22 = 0;
              v11 = v24 - v23;
              if ( v24 > v25 * v11 )
              {
                v25 = v24 / v11;
                if ( v26 >= (long double)v25 )
                  return;
              }
            }
          }
          else
          {
            v11 = v24 - v23;
            if ( v23 > 0.0 )
            {
              if ( v11 <= 0.0 || v23 >= 0.125 )
                return;
              v22 = 0;
            }
            v21 = v24 - 0.125;
            if ( v21 <= v26 * v11 )
            {
              if ( !v19 )
                goto LABEL_34;
            }
            else
            {
              v26 = v21 / v11;
              if ( v26 >= (long double)v25 )
                return;
LABEL_34:
              v19 = (int **)v20;
            }
          }
          --v29;
          v20 += 2;
          continue;
        }
      }
      v24 = (*(float *)(a1 + 4 * i) - *(float *)&v9[i]) * v10 - *(float *)(a1 + 4 * i + 268);
      v23 = (*(float *)(a1 + 4 * i + 12) - *(float *)&v9[i]) * v10 - *(float *)(a1 + 4 * i + 268);
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= (long double)v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( v19 )
            continue;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= (long double)v25 )
            return;
        }
        v7 = *((__int16 *)a2 + 3 * v2 + i + 20);
        v5 = 0;
        v4 = 0;
        v3 = 0;
        *((float *)&v3 + i) = v10;
        v6 = &v3;
        v19 = &v6;
      }
    }
  }
  while ( 2 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v24 = (*(float *)(a1 + 4 * i) - *(float *)&v9[i]) * v10 - *(float *)(a1 + 4 * i + 52);
      v23 = (*(float *)(a1 + 4 * i + 12) - *(float *)&v9[i]) * v10 - *(float *)(a1 + 4 * i + 52);
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= (long double)v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( v19 )
            continue;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= (long double)v25 )
            return;
        }
        v7 = *((__int16 *)a2 + 3 * v2 + i + 20);
        v5 = 0;
        v4 = 0;
        v3 = 0;
        *((float *)&v3 + i) = v10;
        v6 = &v3;
        v19 = &v6;
      }
    }
    if ( !v2 )
    {
      v10 = 1.0;
      v9 = a2 + 4;
      v2 = 1;
      continue;
    }
    break;
  }
  v20 = (int *)a2[8];
  v29 = a2[7];
  while ( 2 )
  {
    if ( v29 )
    {
      v28 = *v20;
      v27 = *(float *)(v28 + 12)
          - (*(float *)(a1 + 12 * *(unsigned __int8 *)(v28 + 17) + 64) * *(float *)v28
           + *(float *)(a1 + 12 * *(unsigned __int8 *)(v28 + 17) + 68) * *(float *)(v28 + 4)
           + *(float *)(a1 + 12 * *(unsigned __int8 *)(v28 + 17) + 72) * *(float *)(v28 + 8));
      v24 = *(float *)a1 * *(float *)v28
          + *(float *)(a1 + 4) * *(float *)(v28 + 4)
          + *(float *)(a1 + 8) * *(float *)(v28 + 8)
          - v27;
      v23 = *(float *)(a1 + 12) * *(float *)v28
          + *(float *)(a1 + 16) * *(float *)(v28 + 4)
          + *(float *)(a1 + 20) * *(float *)(v28 + 8)
          - v27;
      if ( v24 <= 0.0 )
      {
        if ( v23 > 0.0 )
        {
          v22 = 0;
          v11 = v24 - v23;
          if ( v24 > v25 * v11 )
          {
            v25 = v24 / v11;
            if ( v26 >= (long double)v25 )
              return;
          }
        }
      }
      else
      {
        v11 = v24 - v23;
        if ( v23 > 0.0 )
        {
          if ( v11 <= 0.0 || v23 >= 0.125 )
            return;
          v22 = 0;
        }
        v21 = v24 - 0.125;
        if ( v21 <= v26 * v11 )
        {
          if ( !v19 )
            goto LABEL_68;
        }
        else
        {
          v26 = v21 / v11;
          if ( v26 >= (long double)v25 )
            return;
LABEL_68:
          v19 = (int **)v20;
        }
      }
      --v29;
      v20 += 2;
      continue;
    }
    break;
  }
LABEL_73:
  *(_DWORD *)(a1 + 228) = *a2;
  if ( v19 )
  {
    *(float *)(a1 + 196) = v26;
    *(_DWORD *)(a1 + 212) = **v19;
    *(_DWORD *)(a1 + 216) = (*v19)[1];
    *(_DWORD *)(a1 + 220) = (*v19)[2];
    *(_DWORD *)(a1 + 224) = *((_DWORD *)dword_833078C + 18 * (_DWORD)v19[1] + 16);
    *(_DWORD *)(a1 + 232) = (char *)dword_833078C + 72 * (_DWORD)v19[1];
  }
  else
  {
    *(_BYTE *)(a1 + 243) = 1;
    if ( v22 )
    {
      *(_BYTE *)(a1 + 242) = 1;
      *(_DWORD *)(a1 + 196) = 0;
    }
  }
}

//----- (08059A41) --------------------------------------------------------
void __cdecl sub_8059A41(int a1, int a2)
{
  _DWORD *v2; // [esp+8h] [ebp-10h]
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int16 *)(a2 + 8); ++i )
  {
    v3 = (_DWORD *)(dword_83307CC + 52 * *(_DWORD *)(dword_83307B4 + 4 * (*(_DWORD *)(a2 + 4) + i)));
    if ( v3[9] != dword_8330800 )
    {
      v3[9] = dword_8330800;
      if ( (*v3 & *(_DWORD *)(a1 + 188)) != 0 )
      {
        sub_80590D6(a1, v3);
        if ( *(float *)(a1 + 196) == 0.0 )
          return;
      }
    }
  }
  if ( !*(_DWORD *)(dword_8330720 + 32) )
  {
    for ( j = 0; j < *(unsigned __int16 *)(a2 + 12); ++j )
    {
      v2 = (_DWORD *)(dword_83307F8 + 44 * *(_DWORD *)(dword_83307BC + 4 * (j + *(unsigned __int16 *)(a2 + 10))));
      if ( *v2 != dword_8330800 )
      {
        *v2 = dword_8330800;
        if ( (v2[2] & *(_DWORD *)(a1 + 188)) != 0 )
        {
          sub_8058FFC(a1, (int)v2);
          if ( *(float *)(a1 + 196) == 0.0 )
            break;
        }
      }
    }
  }
}
// 8330720: using guessed type int dword_8330720;
// 83307B4: using guessed type int dword_83307B4;
// 83307BC: using guessed type int dword_83307BC;
// 83307CC: using guessed type int dword_83307CC;
// 83307F8: using guessed type int dword_83307F8;
// 8330800: using guessed type int dword_8330800;

//----- (08059BB2) --------------------------------------------------------
int __cdecl sub_8059BB2(int a1, int a2, int a3, int a4, float a5)
{
  long double v5; // fst7
  float v7; // [esp+28h] [ebp-60h]
  double v8; // [esp+30h] [ebp-58h]
  int v9; // [esp+38h] [ebp-50h]
  float v10; // [esp+3Ch] [ebp-4Ch]
  int v11[5]; // [esp+40h] [ebp-48h] BYREF
  float v12; // [esp+54h] [ebp-34h]
  float v13; // [esp+58h] [ebp-30h]
  float v14; // [esp+5Ch] [ebp-2Ch]
  float v15; // [esp+60h] [ebp-28h]
  float v16; // [esp+64h] [ebp-24h]
  float v17; // [esp+68h] [ebp-20h]
  float v18; // [esp+6Ch] [ebp-1Ch]
  float v19; // [esp+70h] [ebp-18h] BYREF
  float v20; // [esp+74h] [ebp-14h]
  float v21; // [esp+78h] [ebp-10h]

  v19 = *(float *)a2 - *(float *)a4;
  v20 = *(float *)(a2 + 4) - *(float *)(a4 + 4);
  v21 = *(float *)(a2 + 8) - *(float *)(a4 + 8);
  v14 = (a5 + *(float *)(a1 + 248)) * (a5 + *(float *)(a1 + 248));
  v16 = v19 * v19 + v20 * v20 + v21 * v21 - v14;
  if ( v16 > 0.0 )
  {
    v17 = *(float *)(a1 + 24) * v19 + *(float *)(a1 + 28) * v20 + *(float *)(a1 + 32) * v21;
    if ( v17 < 0.0 )
    {
      v18 = *(float *)(a1 + 36);
      v15 = v17 * v17 - v18 * v16;
      if ( v15 >= 0.0 )
      {
        v12 = sub_8066A90(&v19, (float *)v11);
        v8 = -v17;
        v5 = sqrt(v15);
        v10 = (v8 - v5) / v18;
        v13 = v10 + v12 * 0.125 / v17;
        if ( *(float *)(a1 + 196) <= (long double)v13 )
        {
          v9 = 1;
        }
        else
        {
          if ( v13 <= 0.0 )
            v7 = 0.0;
          else
            v7 = v13;
          *(float *)(a1 + 196) = v7;
          *(_DWORD *)(a1 + 212) = v11[0];
          *(_DWORD *)(a1 + 216) = v11[1];
          *(_DWORD *)(a1 + 220) = v11[2];
          *(_DWORD *)(a1 + 228) = sub_804BEA7();
          v9 = 0;
        }
      }
      else
      {
        v9 = 1;
      }
    }
    else
    {
      v9 = 1;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 196) = 0;
    *(_BYTE *)(a1 + 243) = 1;
    sub_8066A90(&v19, (float *)(a1 + 212));
    *(_DWORD *)(a1 + 228) = sub_804BEA7();
    v19 = *(float *)a3 - *(float *)a4;
    v20 = *(float *)(a3 + 4) - *(float *)(a4 + 4);
    v21 = *(float *)(a3 + 8) - *(float *)(a4 + 8);
    if ( v14 >= v19 * v19 + v20 * v20 + v21 * v21 )
      *(_BYTE *)(a1 + 242) = 1;
    v9 = 0;
  }
  return v9;
}

//----- (08059E37) --------------------------------------------------------
int __cdecl sub_8059E37(int a1, int a2, float a3, float a4)
{
  long double v4; // fst7
  float v6; // [esp+20h] [ebp-68h]
  double v7; // [esp+28h] [ebp-60h]
  int v8; // [esp+30h] [ebp-58h]
  float v9; // [esp+34h] [ebp-54h]
  float v10; // [esp+38h] [ebp-50h]
  float v11; // [esp+3Ch] [ebp-4Ch]
  float v12; // [esp+3Ch] [ebp-4Ch]
  int v13[4]; // [esp+40h] [ebp-48h] BYREF
  float v14; // [esp+50h] [ebp-38h]
  float v15; // [esp+54h] [ebp-34h]
  float v16; // [esp+58h] [ebp-30h]
  float v17; // [esp+5Ch] [ebp-2Ch]
  float v18; // [esp+60h] [ebp-28h]
  float v19; // [esp+64h] [ebp-24h]
  float v20; // [esp+68h] [ebp-20h]
  float v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h] BYREF
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]

  v22 = *(float *)a1 - *(float *)a2;
  v23 = *(float *)(a1 + 4) - *(float *)(a2 + 4);
  v24 = *(float *)(a1 + 8) - *(float *)(a2 + 8);
  v17 = (a4 + *(float *)(a1 + 248)) * (a4 + *(float *)(a1 + 248));
  v19 = v22 * v22 + v23 * v23 - v17;
  if ( v19 > 0.0 )
  {
    v20 = *(float *)(a1 + 24) * v22 + *(float *)(a1 + 28) * v23;
    if ( v20 < 0.0 )
    {
      v21 = *(float *)(a1 + 24) * *(float *)(a1 + 24) + *(float *)(a1 + 28) * *(float *)(a1 + 28);
      v18 = v20 * v20 - v21 * v19;
      if ( v18 >= 0.0 )
      {
        v24 = 0.0;
        v14 = sub_8066A90(&v22, (float *)v13);
        v15 = v14 * 0.125 / v20;
        v7 = -v20;
        v4 = sqrt(v18);
        v9 = (v7 - v4) / v21;
        v16 = v9 + v15;
        if ( *(float *)(a1 + 196) <= (long double)v16 )
        {
          v8 = 1;
        }
        else
        {
          v12 = *(float *)(a1 + 252) - *(float *)(a1 + 248) + a3;
          v10 = (v16 - v15) * *(float *)(a1 + 32) + *(float *)(a1 + 8) - *(float *)(a2 + 8);
          if ( v10 <= (long double)v12 && -v12 <= (long double)v10 )
          {
            if ( v16 <= 0.0 )
              v6 = 0.0;
            else
              v6 = v16;
            *(float *)(a1 + 196) = v6;
            *(_DWORD *)(a1 + 212) = v13[0];
            *(_DWORD *)(a1 + 216) = v13[1];
            *(_DWORD *)(a1 + 220) = v13[2];
            *(_DWORD *)(a1 + 228) = sub_804BEA7();
            v8 = 0;
          }
          else
          {
            v8 = 1;
          }
        }
      }
      else
      {
        v8 = 1;
      }
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v11 = *(float *)(a1 + 252) - *(float *)(a1 + 248) + a3;
    if ( v24 <= (long double)v11 && -v11 <= (long double)v24 )
    {
      *(_DWORD *)(a1 + 196) = 0;
      *(_BYTE *)(a1 + 243) = 1;
      v24 = 0.0;
      sub_8066A90(&v22, (float *)(a1 + 212));
      *(_DWORD *)(a1 + 228) = sub_804BEA7();
      v22 = *(float *)(a1 + 12) - *(float *)a2;
      v23 = *(float *)(a1 + 16) - *(float *)(a2 + 4);
      v24 = *(float *)(a1 + 20) - *(float *)(a2 + 8);
      if ( v11 >= (long double)v24 && v24 >= -v11 )
        *(_BYTE *)(a1 + 242) = 1;
      v8 = 0;
    }
    else
    {
      v8 = 1;
    }
  }
  return v8;
}

//----- (0805A181) --------------------------------------------------------
void __cdecl sub_805A181(float *a1)
{
  float v1; // [esp+2Ch] [ebp-BCh]
  float v2; // [esp+30h] [ebp-B8h]
  float v3[3]; // [esp+40h] [ebp-A8h]
  float v4[2]; // [esp+4Ch] [ebp-9Ch]
  float v5; // [esp+54h] [ebp-94h]
  int v6; // [esp+60h] [ebp-88h] BYREF
  int v7; // [esp+64h] [ebp-84h]
  float v8; // [esp+68h] [ebp-80h]
  int v9[2]; // [esp+70h] [ebp-78h] BYREF
  float v10; // [esp+78h] [ebp-70h]
  int v11[2]; // [esp+80h] [ebp-68h] BYREF
  float v12; // [esp+88h] [ebp-60h]
  int v13[2]; // [esp+90h] [ebp-58h] BYREF
  float v14; // [esp+98h] [ebp-50h]
  int v15[2]; // [esp+A0h] [ebp-48h] BYREF
  float v16; // [esp+A8h] [ebp-40h]
  int v17[2]; // [esp+B0h] [ebp-38h] BYREF
  float v18; // [esp+B8h] [ebp-30h]
  int v19[2]; // [esp+C0h] [ebp-28h] BYREF
  float v20; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( a1[41] <= *(float *)dword_833082C + 1.0
    && a1[42] <= *(float *)&dword_8330830 + 1.0
    && a1[43] <= *(float *)&dword_8330834 + 1.0
    && *(float *)dword_8330820 - 1.0 <= a1[44]
    && *(float *)&dword_8330824 - 1.0 <= a1[45]
    && *(float *)&dword_8330828 - 1.0 <= a1[46] )
  {
    *(float *)v15 = *a1 + a1[64];
    *(float *)&v15[1] = a1[1] + a1[65];
    v16 = a1[2] + a1[66];
    *(float *)v13 = *a1 - a1[64];
    *(float *)&v13[1] = a1[1] - a1[65];
    v14 = a1[2] - a1[66];
    *(float *)v11 = a1[3] + a1[64];
    *(float *)&v11[1] = a1[4] + a1[65];
    v12 = a1[5] + a1[66];
    *(float *)v9 = a1[3] - a1[64];
    *(float *)&v9[1] = a1[4] - a1[65];
    v10 = a1[5] - a1[66];
    for ( i = 0; i <= 2; ++i )
    {
      *((float *)&v6 + i) = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
      v3[i] = *(float *)&dword_8330820[i] - *((float *)&v6 + i);
      v4[i] = *(float *)&dword_833082C[i] - *((float *)&v6 + i);
    }
    if ( v4[0] <= (long double)v5 )
      v1 = v4[0];
    else
      v1 = v5;
    v2 = v5 - v1;
    v19[0] = v6;
    v19[1] = v7;
    v20 = v8 + v2;
    v17[0] = v6;
    v17[1] = v7;
    v18 = v8 - v2;
    if ( v14 <= (long double)v20 )
    {
      if ( v18 > (long double)v16 && (!sub_8059BB2((int)a1, (int)v15, (int)v11, (int)v17, v1) || a1[8] <= 0.0) )
        return;
    }
    else if ( !sub_8059BB2((int)a1, (int)v13, (int)v9, (int)v19, v1) || a1[8] >= 0.0 )
    {
      return;
    }
    if ( sub_8059E37((int)a1, (int)&v6, v2, v1) )
    {
      if ( v10 <= (long double)v20 )
      {
        if ( v18 > (long double)v12 && v16 >= (long double)v18 )
          sub_8059BB2((int)a1, (int)v15, (int)v11, (int)v17, v1);
      }
      else if ( v20 >= (long double)v14 )
      {
        sub_8059BB2((int)a1, (int)v13, (int)v9, (int)v19, v1);
      }
    }
  }
}
// 8330820: using guessed type int dword_8330820[];
// 8330824: using guessed type int dword_8330824;
// 8330828: using guessed type int dword_8330828;
// 833082C: using guessed type int dword_833082C[];
// 8330830: using guessed type int dword_8330830;
// 8330834: using guessed type int dword_8330834;

//----- (0805A5BB) --------------------------------------------------------
void __cdecl sub_805A5BB(int a1)
{
  float v1; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v3[3]; // [esp+20h] [ebp-38h]
  float v4[2]; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+34h] [ebp-24h]
  float v6[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v6[i] = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
    v3[i] = *(float *)&dword_8330820[i] - v6[i];
    v4[i] = *(float *)&dword_833082C[i] - v6[i];
    *(float *)(a1 + 4 * i) = *(float *)(a1 + 4 * i) - v6[i];
    *(float *)(a1 + 4 * i + 12) = *(float *)(a1 + 4 * i + 12) - v6[i];
  }
  *(_DWORD *)(a1 + 244) = 1;
  if ( v4[0] <= (long double)v5 )
    v1 = v4[0];
  else
    v1 = v5;
  *(float *)(a1 + 248) = v1;
  *(float *)(a1 + 252) = v5;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(float *)(a1 + 264) = v5 - *(float *)(a1 + 248);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 276) = *(_DWORD *)(a1 + 252);
  sub_804BDD3((int *)(a1 + 40), (int *)(a1 + 52), *(_DWORD *)dword_833081C, 0);
  sub_80590D6(a1, (_DWORD *)dword_833081C);
}
// 833081C: using guessed type int dword_833081C;
// 8330820: using guessed type int dword_8330820[];
// 833082C: using guessed type int dword_833082C[];

//----- (0805A75B) --------------------------------------------------------
void __cdecl sub_805A75B(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int v6; // [esp+28h] [ebp-40h]
  float v7; // [esp+28h] [ebp-40h]
  int v8; // [esp+2Ch] [ebp-3Ch]
  int v9; // [esp+30h] [ebp-38h] BYREF
  float v10; // [esp+34h] [ebp-34h]
  float v11; // [esp+38h] [ebp-30h]
  float v12; // [esp+40h] [ebp-28h]
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+4Ch] [ebp-1Ch]
  float v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  int v18; // [esp+58h] [ebp-10h]
  int v19; // [esp+5Ch] [ebp-Ch]

  if ( a3 < (long double)*(float *)(a1 + 196) )
  {
    if ( a2 >= 0 )
    {
      v19 = dword_83307A4 + 8 * a2;
      v18 = *(_DWORD *)v19;
      if ( *(_BYTE *)(v18 + 16) > 2u )
      {
        v17 = *(float *)v18 * *(float *)a5
            + *(float *)(v18 + 4) * *(float *)(a5 + 4)
            + *(float *)(v18 + 8) * *(float *)(a5 + 8)
            - *(float *)(v18 + 12);
        v16 = *(float *)v18 * *(float *)a6
            + *(float *)(v18 + 4) * *(float *)(a6 + 4)
            + *(float *)(v18 + 8) * *(float *)(a6 + 8)
            - *(float *)(v18 + 12);
        if ( *(_DWORD *)(a1 + 192) )
          v15 = 0.0;
        else
          v15 = 2048.0;
      }
      else
      {
        v17 = *(float *)(a5 + 4 * *(unsigned __int8 *)(v18 + 16)) - *(float *)(v18 + 12);
        v16 = *(float *)(a6 + 4 * *(unsigned __int8 *)(v18 + 16)) - *(float *)(v18 + 12);
        v15 = *(float *)(a1 + 4 * *(unsigned __int8 *)(v18 + 16) + 52);
      }
      if ( v17 < v15 + 1.0 || v16 < v15 + 1.0 )
      {
        if ( -1.0 - v15 <= v17 || -1.0 - v15 <= v16 )
        {
          if ( v16 <= (long double)v17 )
          {
            if ( v17 <= (long double)v16 )
            {
              v8 = 0;
              v14 = 1.0;
              v13 = 0.0;
            }
            else
            {
              v12 = 1.0 / (v17 - v16);
              v8 = 0;
              v13 = (v17 - v15 - 0.125) * v12;
              v14 = (v17 + v15 + 0.125) * v12;
            }
          }
          else
          {
            v12 = 1.0 / (v17 - v16);
            v8 = 1;
            v13 = (v17 + v15 + 0.125) * v12;
            v14 = (v17 - v15 + 0.125) * v12;
          }
          if ( v14 < 0.0 )
            v14 = 0.0;
          if ( v14 > 1.0 )
            v14 = 1.0;
          *(float *)&v6 = (*(float *)&a4 - a3) * v14 + a3;
          *(float *)&v9 = (*(float *)a6 - *(float *)a5) * v14 + *(float *)a5;
          v10 = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v14 + *(float *)(a5 + 4);
          v11 = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v14 + *(float *)(a5 + 8);
          sub_805A75B(a1, *(__int16 *)(v19 + 2 * v8 + 4), a3, v6, a5, (int)&v9);
          if ( v13 < 0.0 )
            v13 = 0.0;
          if ( v13 > 1.0 )
            v13 = 1.0;
          v7 = (*(float *)&a4 - a3) * v13 + a3;
          *(float *)&v9 = (*(float *)a6 - *(float *)a5) * v13 + *(float *)a5;
          v10 = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v13 + *(float *)(a5 + 4);
          v11 = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v13 + *(float *)(a5 + 8);
          sub_805A75B(a1, *(__int16 *)(v19 + 2 * (v8 ^ 1) + 4), v7, a4, (int)&v9, a6);
        }
        else
        {
          sub_805A75B(a1, *(__int16 *)(v19 + 6), a3, a4, a5, a6);
        }
      }
      else
      {
        sub_805A75B(a1, *(__int16 *)(v19 + 4), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_8059A41(a1, dword_83307AC + 16 * (-1 - a2));
    }
  }
}
// 83307A4: using guessed type int dword_83307A4;
// 83307AC: using guessed type int dword_83307AC;

//----- (0805ABA1) --------------------------------------------------------
int __cdecl sub_805ABA1(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8, int a9)
{
  int v9; // ebx
  long double v10; // fst7
  int result; // eax
  float v12; // [esp+24h] [ebp-164h]
  float v13; // [esp+28h] [ebp-160h]
  float v14; // [esp+28h] [ebp-160h]
  float v15; // [esp+28h] [ebp-160h]
  int *v16; // [esp+2Ch] [ebp-15Ch]
  float v17[4]; // [esp+30h] [ebp-158h]
  float s[3]; // [esp+40h] [ebp-148h] BYREF
  float v19[3]; // [esp+4Ch] [ebp-13Ch] BYREF
  float v20; // [esp+58h] [ebp-130h]
  float v21; // [esp+5Ch] [ebp-12Ch]
  float v22; // [esp+60h] [ebp-128h]
  float v23; // [esp+64h] [ebp-124h]
  int v24; // [esp+68h] [ebp-120h]
  int v25; // [esp+6Ch] [ebp-11Ch]
  int v26; // [esp+70h] [ebp-118h]
  int v27; // [esp+74h] [ebp-114h]
  int v28; // [esp+78h] [ebp-110h]
  int v29; // [esp+7Ch] [ebp-10Ch]
  int v30; // [esp+80h] [ebp-108h]
  int v31; // [esp+84h] [ebp-104h]
  int v32; // [esp+88h] [ebp-100h]
  int v33; // [esp+8Ch] [ebp-FCh]
  int v34; // [esp+90h] [ebp-F8h]
  int v35; // [esp+94h] [ebp-F4h]
  int v36; // [esp+98h] [ebp-F0h]
  int v37; // [esp+9Ch] [ebp-ECh]
  int v38; // [esp+A0h] [ebp-E8h]
  int v39; // [esp+A4h] [ebp-E4h]
  int v40; // [esp+A8h] [ebp-E0h]
  int v41; // [esp+ACh] [ebp-DCh]
  int v42; // [esp+B0h] [ebp-D8h]
  int v43; // [esp+B4h] [ebp-D4h]
  int v44; // [esp+B8h] [ebp-D0h]
  int v45; // [esp+BCh] [ebp-CCh]
  int v46; // [esp+C0h] [ebp-C8h]
  int v47; // [esp+C4h] [ebp-C4h]
  float v48; // [esp+C8h] [ebp-C0h]
  int v49; // [esp+CCh] [ebp-BCh]
  int v50; // [esp+D0h] [ebp-B8h]
  float v51; // [esp+D4h] [ebp-B4h]
  float v52; // [esp+D8h] [ebp-B0h]
  int v53; // [esp+DCh] [ebp-ACh]
  float v54; // [esp+E0h] [ebp-A8h]
  float v55[6]; // [esp+E4h] [ebp-A4h]
  int v56; // [esp+FCh] [ebp-8Ch]
  _BOOL4 v57; // [esp+100h] [ebp-88h]
  int v58[12]; // [esp+104h] [ebp-84h] BYREF
  int v59; // [esp+134h] [ebp-54h]
  float v60; // [esp+138h] [ebp-50h]
  float v61; // [esp+13Ch] [ebp-4Ch]
  float v62; // [esp+140h] [ebp-48h]
  int v63; // [esp+144h] [ebp-44h]
  float v64; // [esp+148h] [ebp-40h]
  int v65[8]; // [esp+14Ch] [ebp-3Ch]
  int i; // [esp+16Ch] [ebp-1Ch]

  v16 = sub_804BBD8(a6);
  ++dword_8330800;
  sub_80D2FE9(s, 0, 0x118u);
  v58[0] = *a1;
  if ( !a4 )
    a4 = &dword_80D7EC8;
  if ( !a5 )
    a5 = &dword_80D7EC8;
  v56 = a7;
  for ( i = 0; i <= 2; ++i )
  {
    v17[i] = (*(float *)&a4[i] + *(float *)&a5[i]) * 0.5;
    *((float *)&v24 + i) = *(float *)&a4[i] - v17[i];
    *((float *)&v27 + i) = *(float *)&a5[i] - v17[i];
    s[i] = a2[i] + v17[i];
    v19[i] = a3[i] + v17[i];
    *(&v20 + i) = v19[i] - s[i];
  }
  v23 = v20 * v20 + v21 * v21 + v22 * v22;
  if ( a9 )
  {
    v59 = *(_DWORD *)a9;
    v60 = *(float *)(a9 + 4);
    v61 = *(float *)(a9 + 8);
    v62 = *(float *)(a9 + 12);
    v63 = *(_DWORD *)(a9 + 16);
    v64 = *(float *)(a9 + 20);
    v65[0] = *(_DWORD *)(a9 + 24);
    v65[1] = *(_DWORD *)(a9 + 28);
    v65[2] = *(_DWORD *)(a9 + 32);
  }
  else
  {
    v59 = a8;
    if ( *(float *)&v27 <= (long double)*(float *)&v29 )
      v12 = *(float *)&v27;
    else
      v12 = *(float *)&v29;
    v60 = v12;
    v61 = *(float *)&v29;
    v62 = 0.0;
    v63 = 0;
    v64 = *(float *)&v29 - v12;
  }
  v54 = *(float *)&v27 + *(float *)&v28 + *(float *)&v29;
  v30 = v24;
  v31 = v25;
  v32 = v26;
  v33 = v27;
  v34 = v25;
  v35 = v26;
  v36 = v24;
  v37 = v28;
  v38 = v26;
  v39 = v27;
  v40 = v28;
  v41 = v26;
  v42 = v24;
  v43 = v25;
  v44 = v29;
  v45 = v27;
  v46 = v25;
  v47 = v29;
  v48 = *(float *)&v24;
  v49 = v28;
  v50 = v29;
  v51 = *(float *)&v27;
  v52 = *(float *)&v28;
  v53 = v29;
  if ( v59 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v13 = fabs(*(&v62 + i));
      if ( v19[i] <= (long double)s[i] )
      {
        v55[i] = v19[i] - v13 - v60;
        v15 = fabs(*(&v62 + i));
        v55[i + 3] = v15 + s[i] + v60;
      }
      else
      {
        v55[i] = s[i] - v13 - v60;
        v14 = fabs(*(&v62 + i));
        v55[i + 3] = v14 + v19[i] + v60;
      }
    }
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( v19[i] <= (long double)s[i] )
      {
        v55[i] = v19[i] + *((float *)&v24 + i);
        v55[i + 3] = s[i] + *((float *)&v27 + i);
      }
      else
      {
        v55[i] = s[i] + *((float *)&v24 + i);
        v55[i + 3] = v19[i] + *((float *)&v27 + i);
      }
    }
  }
  if ( *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] )
  {
    if ( a6 )
    {
      if ( a6 == 510 )
      {
        if ( (v56 & *(_DWORD *)dword_833081C) != 0 )
        {
          if ( v59 )
            sub_805865B((int)s);
          else
            sub_8058A60((int)s);
        }
      }
      else
      {
        sub_8058494((int)s, (int)(v16 + 6));
      }
    }
    else
    {
      sub_8058BCA((int)s);
    }
  }
  else
  {
    v57 = 0.0 == *(float *)&v27 + *(float *)&v28 + *(float *)&v29;
    if ( v59 )
    {
      for ( i = 0; i <= 2; ++i )
      {
        v9 = i;
        v10 = sub_805D9B8(*(&v62 + i));
        *(float *)&v65[v9] = v10 + v60;
      }
    }
    if ( a6 )
    {
      if ( a6 == 510 )
      {
        if ( (v56 & *(_DWORD *)dword_833081C) != 0 )
        {
          if ( v59 )
            sub_805A181(s);
          else
            sub_805A5BB((int)s);
        }
      }
      else
      {
        sub_8059A41((int)s, (int)(v16 + 6));
      }
    }
    else
    {
      sub_805A75B((int)s, 0, 0.0, v58[0], (int)s, (int)v19);
    }
  }
  *(float *)&v58[1] = v20 * *(float *)v58 + *a2;
  *(float *)&v58[2] = v21 * *(float *)v58 + a2[1];
  *(float *)&v58[3] = v22 * *(float *)v58 + a2[2];
  result = 12;
  qmemcpy(a1, v58, 0x30u);
  return result;
}
// 80D7EC8: using guessed type int dword_80D7EC8;
// 8330800: using guessed type int dword_8330800;
// 833081C: using guessed type int dword_833081C;

//----- (0805B311) --------------------------------------------------------
int __cdecl sub_805B311(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, int a8)
{
  *a1 = 1065353216;
  return sub_805ABA1(a1, a2, a3, a4, a5, a6, a7, a8, 0);
}

//----- (0805B366) --------------------------------------------------------
int __cdecl sub_805B366(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  int result; // eax
  int v11; // [esp+4Ch] [ebp-14Ch]
  int v12[3]; // [esp+50h] [ebp-148h] BYREF
  float v13; // [esp+5Ch] [ebp-13Ch]
  float v14; // [esp+60h] [ebp-138h]
  float v15; // [esp+64h] [ebp-134h]
  float v16; // [esp+80h] [ebp-118h]
  int v17; // [esp+84h] [ebp-114h]
  int v18; // [esp+88h] [ebp-110h]
  int i; // [esp+8Ch] [ebp-10Ch]
  float v20[12]; // [esp+90h] [ebp-108h] BYREF
  float v21[12]; // [esp+C0h] [ebp-D8h] BYREF
  int v22[3]; // [esp+F0h] [ebp-A8h] BYREF
  float v23[2]; // [esp+FCh] [ebp-9Ch] BYREF
  float v24; // [esp+104h] [ebp-94h]
  float v25[7]; // [esp+110h] [ebp-88h]
  _BOOL4 v26; // [esp+12Ch] [ebp-6Ch]
  float v27; // [esp+130h] [ebp-68h] BYREF
  float v28; // [esp+134h] [ebp-64h]
  float v29; // [esp+138h] [ebp-60h]
  float v30; // [esp+140h] [ebp-58h] BYREF
  float v31; // [esp+144h] [ebp-54h]
  float v32; // [esp+148h] [ebp-50h]
  int v33[18]; // [esp+150h] [ebp-48h] BYREF

  if ( !a4 )
    a4 = &dword_80D7EC8;
  if ( !a5 )
    a5 = &dword_80D7EC8;
  for ( i = 0; i <= 2; ++i )
  {
    v25[i] = (*(float *)&a4[i] + *(float *)&a5[i]) * 0.5;
    *(float *)&v22[i] = *(float *)&a4[i] - v25[i];
    v23[i] = *(float *)&a5[i] - v25[i];
    *(&v30 + i) = a2[i] + v25[i];
    *(&v27 + i) = a3[i] + v25[i];
  }
  v30 = v30 - *a8;
  v31 = v31 - a8[1];
  v32 = v32 - a8[2];
  v27 = v27 - *a8;
  v28 = v28 - a8[1];
  v29 = v29 - a8[2];
  v26 = a6 != 511 && (*a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0);
  v18 = SLODWORD(v23[0]);
  *(float *)&v17 = v24;
  v12[0] = a10;
  if ( v23[0] <= (long double)v24 )
    v11 = v18;
  else
    v11 = v17;
  v12[1] = v11;
  v12[2] = v17;
  v16 = *(float *)&v17 - *(float *)&v11;
  if ( v26 )
  {
    sub_8057DF6(a9, (int)v21);
    sub_8057CE4(&v30, v21);
    sub_8057CE4(&v27, v21);
    v13 = v21[2] * v16;
    v14 = -v21[5] * v16;
    v15 = v21[8] * v16;
  }
  else
  {
    v13 = 0.0;
    v14 = 0.0;
    v15 = v16;
  }
  v33[0] = *a1;
  sub_805ABA1(v33, &v30, &v27, v22, (int *)v23, a6, a7, a10, (int)v12);
  if ( v26 && *(float *)a1 > (long double)*(float *)v33 )
  {
    sub_8057D8B((int)v21, (int)v20);
    sub_8057CE4((float *)&v33[4], v20);
  }
  *(float *)&v33[1] = (*a3 - *a2) * *(float *)v33 + *a2;
  *(float *)&v33[2] = (a3[1] - a2[1]) * *(float *)v33 + a2[1];
  *(float *)&v33[3] = (a3[2] - a2[2]) * *(float *)v33 + a2[2];
  result = 12;
  qmemcpy(a1, v33, 0x30u);
  return result;
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0805B77C) --------------------------------------------------------
int __cdecl sub_805B77C(int *a1, float *a2, float *a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  *a1 = 1065353216;
  return sub_805B366(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0805B7D7) --------------------------------------------------------
int __cdecl sub_805B7D7(int *a1, int a2)
{
  if ( !sub_8058D51((int)a1, (float *)(a2 + 12), (float *)(a2 + 24)) )
    return 1;
  if ( *(_DWORD *)(a2 + 36) )
    return sub_8050B4F((int)a1, *(_DWORD **)(a2 + 36));
  return sub_8057241(a1, *(unsigned __int16 **)(a2 + 40));
}

//----- (0805B849) --------------------------------------------------------
int __cdecl sub_805B849(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-6Ch]
  int i; // [esp+10h] [ebp-68h]
  int k; // [esp+10h] [ebp-68h]
  int v7; // [esp+14h] [ebp-64h]
  float v8; // [esp+18h] [ebp-60h]
  float v9; // [esp+1Ch] [ebp-5Ch]
  float v10; // [esp+1Ch] [ebp-5Ch]
  float v11; // [esp+1Ch] [ebp-5Ch]
  float v12; // [esp+1Ch] [ebp-5Ch]
  float v13; // [esp+1Ch] [ebp-5Ch]
  float v14; // [esp+1Ch] [ebp-5Ch]
  float v15; // [esp+1Ch] [ebp-5Ch]
  float v16; // [esp+1Ch] [ebp-5Ch]
  float v17; // [esp+20h] [ebp-58h]
  float v18; // [esp+24h] [ebp-54h]
  float v19; // [esp+28h] [ebp-50h]
  float v20; // [esp+30h] [ebp-48h]
  float v21; // [esp+34h] [ebp-44h]
  float v22; // [esp+38h] [ebp-40h]
  float v23; // [esp+4Ch] [ebp-2Ch]
  float **v24; // [esp+50h] [ebp-28h]
  int *v25; // [esp+50h] [ebp-28h]
  float v26; // [esp+54h] [ebp-24h]
  float v27; // [esp+54h] [ebp-24h]
  float v28; // [esp+54h] [ebp-24h]
  float v29; // [esp+54h] [ebp-24h]
  float v30; // [esp+58h] [ebp-20h]
  float v31; // [esp+58h] [ebp-20h]
  float v32; // [esp+58h] [ebp-20h]
  float v33; // [esp+58h] [ebp-20h]
  float v34; // [esp+5Ch] [ebp-1Ch]
  float v35; // [esp+60h] [ebp-18h]
  float v36; // [esp+64h] [ebp-14h]
  float v37; // [esp+64h] [ebp-14h]
  float *v38; // [esp+68h] [ebp-10h]
  int v39; // [esp+68h] [ebp-10h]
  int j; // [esp+6Ch] [ebp-Ch]
  int l; // [esp+6Ch] [ebp-Ch]

  v35 = 0.0;
  v34 = 1.0;
  v8 = -1.0;
  v7 = a2 + 4;
  v4 = 0;
  if ( *(_DWORD *)(a1 + 244) )
  {
    while ( 1 )
    {
      for ( i = 0; i <= 2; ++i )
      {
        v30 = (*(float *)(a1 + 4 * i) - *(float *)(v7 + 4 * i)) * v8 - *(float *)(a1 + 4 * i + 268);
        v26 = (*(float *)(a1 + 4 * i + 12) - *(float *)(v7 + 4 * i)) * v8 - *(float *)(a1 + 4 * i + 268);
        if ( v30 <= 0.0 )
        {
          if ( v26 > 0.0 )
          {
            v10 = v30 - v26;
            if ( v30 > v34 * v10 )
            {
              v34 = v30 / v10;
              if ( v35 >= (long double)v34 )
                return 0;
            }
          }
        }
        else
        {
          v9 = v30 - v26;
          if ( v26 > 0.0 )
            return 0;
          if ( v30 > v35 * v9 )
          {
            v35 = v30 / v9;
            if ( v35 >= (long double)v34 )
              return 0;
          }
        }
      }
      if ( v4 )
        break;
      v8 = 1.0;
      v7 = a2 + 16;
      v4 = 1;
    }
    v24 = *(float ***)(a2 + 32);
    for ( j = *(_DWORD *)(a2 + 28); j; --j )
    {
      v38 = *v24;
      v36 = (*v24)[3] + *(float *)(a1 + 248);
      v23 = *v38 * *(float *)(a1 + 256) + v38[1] * *(float *)(a1 + 260) + v38[2] * *(float *)(a1 + 264);
      if ( v23 <= 0.0 )
      {
        v20 = *(float *)a1 + *(float *)(a1 + 256);
        v21 = *(float *)(a1 + 4) + *(float *)(a1 + 260);
        v22 = *(float *)(a1 + 8) + *(float *)(a1 + 264);
        v17 = *(float *)(a1 + 12) + *(float *)(a1 + 256);
        v18 = *(float *)(a1 + 16) + *(float *)(a1 + 260);
        v19 = *(float *)(a1 + 20) + *(float *)(a1 + 264);
      }
      else
      {
        v20 = *(float *)a1 - *(float *)(a1 + 256);
        v21 = *(float *)(a1 + 4) - *(float *)(a1 + 260);
        v22 = *(float *)(a1 + 8) - *(float *)(a1 + 264);
        v17 = *(float *)(a1 + 12) - *(float *)(a1 + 256);
        v18 = *(float *)(a1 + 16) - *(float *)(a1 + 260);
        v19 = *(float *)(a1 + 20) - *(float *)(a1 + 264);
      }
      v31 = v20 * *v38 + v21 * v38[1] + v22 * v38[2] - v36;
      v27 = v17 * *v38 + v18 * v38[1] + v19 * v38[2] - v36;
      if ( v31 <= 0.0 )
      {
        if ( v27 > 0.0 )
        {
          v12 = v31 - v27;
          if ( v31 > v34 * v12 )
          {
            v34 = v31 / v12;
            if ( v35 >= (long double)v34 )
              return 0;
          }
        }
      }
      else
      {
        v11 = v31 - v27;
        if ( v27 > 0.0 )
          return 0;
        if ( v31 > v35 * v11 )
        {
          v35 = v31 / v11;
          if ( v35 >= (long double)v34 )
            return 0;
        }
      }
      v24 += 2;
    }
  }
  else
  {
    while ( 1 )
    {
      for ( k = 0; k <= 2; ++k )
      {
        v32 = (*(float *)(a1 + 4 * k) - *(float *)(v7 + 4 * k)) * v8 - *(float *)(a1 + 4 * k + 52);
        v28 = (*(float *)(a1 + 4 * k + 12) - *(float *)(v7 + 4 * k)) * v8 - *(float *)(a1 + 4 * k + 52);
        if ( v32 <= 0.0 )
        {
          if ( v28 > 0.0 )
          {
            v14 = v32 - v28;
            if ( v32 > v34 * v14 )
            {
              v34 = v32 / v14;
              if ( v35 >= (long double)v34 )
                return 0;
            }
          }
        }
        else
        {
          v13 = v32 - v28;
          if ( v28 > 0.0 )
            return 0;
          if ( v32 > v35 * v13 )
          {
            v35 = v32 / v13;
            if ( v35 >= (long double)v34 )
              return 0;
          }
        }
      }
      if ( v4 )
        break;
      v8 = 1.0;
      v7 = a2 + 16;
      v4 = 1;
    }
    v25 = *(int **)(a2 + 32);
    for ( l = *(_DWORD *)(a2 + 28); l; --l )
    {
      v39 = *v25;
      v37 = *(float *)(v39 + 12)
          - (*(float *)(a1 + 12 * *(unsigned __int8 *)(v39 + 17) + 64) * *(float *)v39
           + *(float *)(a1 + 12 * *(unsigned __int8 *)(v39 + 17) + 68) * *(float *)(v39 + 4)
           + *(float *)(a1 + 12 * *(unsigned __int8 *)(*v25 + 17) + 72) * *(float *)(v39 + 8));
      v33 = *(float *)a1 * *(float *)v39
          + *(float *)(a1 + 4) * *(float *)(v39 + 4)
          + *(float *)(a1 + 8) * *(float *)(v39 + 8)
          - v37;
      v29 = *(float *)(a1 + 12) * *(float *)v39
          + *(float *)(a1 + 16) * *(float *)(v39 + 4)
          + *(float *)(a1 + 20) * *(float *)(v39 + 8)
          - v37;
      if ( v33 <= 0.0 )
      {
        if ( v29 > 0.0 )
        {
          v16 = v33 - v29;
          if ( v33 > v34 * v16 )
          {
            v34 = v33 / v16;
            if ( v35 >= (long double)v34 )
              return 0;
          }
        }
      }
      else
      {
        v15 = v33 - v29;
        if ( v29 > 0.0 )
          return 0;
        if ( v33 > v35 * v15 )
        {
          v35 = v33 / v15;
          if ( v35 >= (long double)v34 )
            return 0;
        }
      }
      v25 += 2;
    }
  }
  return -991146299 * ((a2 - dword_83307CC) >> 2) + 1;
}
// 83307CC: using guessed type int dword_83307CC;

//----- (0805BF79) --------------------------------------------------------
int __cdecl sub_805BF79(int *a1, int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int16 *)(a2 + 8); ++i )
  {
    v5 = (_DWORD *)(dword_83307CC + 52 * *(_DWORD *)(dword_83307B4 + 4 * (*(_DWORD *)(a2 + 4) + i)));
    if ( v5[9] != dword_8330800 )
    {
      v5[9] = dword_8330800;
      if ( (*v5 & a1[47]) != 0 )
      {
        v6 = sub_805B849((int)a1, (int)v5);
        if ( v6 )
          return v6;
      }
    }
  }
  if ( !*(_DWORD *)(dword_8330720 + 32) )
  {
    for ( j = 0; j < *(unsigned __int16 *)(a2 + 12); ++j )
    {
      v4 = (_DWORD *)(dword_83307F8 + 44 * *(_DWORD *)(dword_83307BC + 4 * (j + *(unsigned __int16 *)(a2 + 10))));
      if ( *v4 != dword_8330800 )
      {
        *v4 = dword_8330800;
        if ( (v4[2] & a1[47]) != 0 && !sub_805B7D7(a1, (int)v4) )
          return dword_83307C8 - 1171354717 * (((int)v4 - dword_83307F8) >> 2) + 1;
      }
    }
  }
  return 0;
}
// 8330720: using guessed type int dword_8330720;
// 83307B4: using guessed type int dword_83307B4;
// 83307BC: using guessed type int dword_83307BC;
// 83307C8: using guessed type int dword_83307C8;
// 83307CC: using guessed type int dword_83307CC;
// 83307F8: using guessed type int dword_83307F8;
// 8330800: using guessed type int dword_8330800;

//----- (0805C0FC) --------------------------------------------------------
_BOOL4 __cdecl sub_805C0FC(int a1, int a2, int a3, int a4, float a5)
{
  long double v5; // fst7
  double v7; // [esp+20h] [ebp-58h]
  float v9; // [esp+2Ch] [ebp-4Ch]
  float v10[5]; // [esp+30h] [ebp-48h] BYREF
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+4Ch] [ebp-2Ch]
  float v14; // [esp+50h] [ebp-28h]
  float v15; // [esp+54h] [ebp-24h]
  float v16; // [esp+58h] [ebp-20h]
  float v17; // [esp+5Ch] [ebp-1Ch]
  float v18; // [esp+60h] [ebp-18h] BYREF
  float v19; // [esp+64h] [ebp-14h]
  float v20; // [esp+68h] [ebp-10h]

  v18 = *(float *)a2 - *(float *)a4;
  v19 = *(float *)(a2 + 4) - *(float *)(a4 + 4);
  v20 = *(float *)(a2 + 8) - *(float *)(a4 + 8);
  v13 = (a5 + *(float *)(a1 + 248)) * (a5 + *(float *)(a1 + 248));
  v15 = v18 * v18 + v19 * v19 + v20 * v20 - v13;
  if ( v15 <= 0.0 )
    return 0;
  v16 = *(float *)(a1 + 24) * v18 + *(float *)(a1 + 28) * v19 + *(float *)(a1 + 32) * v20;
  if ( v16 >= 0.0 )
    return 1;
  v17 = *(float *)(a1 + 36);
  v14 = v16 * v16 - v17 * v15;
  if ( v14 < 0.0 )
    return 1;
  v11 = sub_8066A90(&v18, v10);
  v7 = -v16;
  v5 = sqrt(v14);
  v9 = (v7 - v5) / v17;
  v12 = v9 + v16 * 0.125 / v11;
  return *(float *)(a1 + 196) <= (long double)v12;
}

//----- (0805C272) --------------------------------------------------------
_BOOL4 __cdecl sub_805C272(int a1, int a2, float a3, float a4)
{
  long double v4; // fst7
  int v6; // [esp+24h] [ebp-64h]
  double v7; // [esp+28h] [ebp-60h]
  _BOOL4 v8; // [esp+30h] [ebp-58h]
  float v9; // [esp+34h] [ebp-54h]
  float v10; // [esp+38h] [ebp-50h]
  float v11; // [esp+3Ch] [ebp-4Ch]
  float v12; // [esp+3Ch] [ebp-4Ch]
  float v13[4]; // [esp+40h] [ebp-48h] BYREF
  float v14; // [esp+50h] [ebp-38h]
  float v15; // [esp+54h] [ebp-34h]
  float v16; // [esp+58h] [ebp-30h]
  float v17; // [esp+5Ch] [ebp-2Ch]
  float v18; // [esp+60h] [ebp-28h]
  float v19; // [esp+64h] [ebp-24h]
  float v20; // [esp+68h] [ebp-20h]
  float v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h] BYREF
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]

  v22 = *(float *)a1 - *(float *)a2;
  v23 = *(float *)(a1 + 4) - *(float *)(a2 + 4);
  v24 = *(float *)(a1 + 8) - *(float *)(a2 + 8);
  v17 = (a4 + *(float *)(a1 + 248)) * (a4 + *(float *)(a1 + 248));
  v19 = v22 * v22 + v23 * v23 - v17;
  if ( v19 > 0.0 )
  {
    v20 = *(float *)(a1 + 24) * v22 + *(float *)(a1 + 28) * v23;
    if ( v20 < 0.0 )
    {
      v21 = *(float *)(a1 + 36);
      v18 = v20 * v20 - v21 * v19;
      if ( v18 >= 0.0 )
      {
        v24 = 0.0;
        v14 = sub_8066A90(&v22, v13);
        v15 = v20 * 0.125 / v14;
        v7 = -v20;
        v4 = sqrt(v18);
        v9 = (v7 - v4) / v21;
        v16 = v9 + v15;
        if ( *(float *)(a1 + 196) <= (long double)v16 )
        {
          v8 = 1;
        }
        else
        {
          v12 = *(float *)(a1 + 252) - *(float *)(a1 + 248) + a3;
          v10 = (v16 - v15) * *(float *)(a1 + 32) + *(float *)(a1 + 8) - *(float *)(a2 + 8);
          v6 = 0;
          if ( v10 > (long double)v12 || -v12 > (long double)v10 )
            v6 = 1;
          v8 = v6;
        }
      }
      else
      {
        v8 = 1;
      }
    }
    else
    {
      v8 = 1;
    }
  }
  else
  {
    v11 = *(float *)(a1 + 252) - *(float *)(a1 + 248) + a3;
    v8 = v24 > (long double)v11 || -v11 > (long double)v24;
  }
  return v8;
}

//----- (0805C498) --------------------------------------------------------
int __cdecl sub_805C498(float *a1)
{
  float v2; // [esp+28h] [ebp-C0h]
  float v4; // [esp+30h] [ebp-B8h]
  float v5[3]; // [esp+40h] [ebp-A8h]
  float v6[2]; // [esp+4Ch] [ebp-9Ch]
  float v7; // [esp+54h] [ebp-94h]
  int v8; // [esp+60h] [ebp-88h] BYREF
  int v9; // [esp+64h] [ebp-84h]
  float v10; // [esp+68h] [ebp-80h]
  int v11[2]; // [esp+70h] [ebp-78h] BYREF
  float v12; // [esp+78h] [ebp-70h]
  int v13[2]; // [esp+80h] [ebp-68h] BYREF
  float v14; // [esp+88h] [ebp-60h]
  int v15[2]; // [esp+90h] [ebp-58h] BYREF
  float v16; // [esp+98h] [ebp-50h]
  int v17[2]; // [esp+A0h] [ebp-48h] BYREF
  float v18; // [esp+A8h] [ebp-40h]
  int v19[2]; // [esp+B0h] [ebp-38h] BYREF
  float v20; // [esp+B8h] [ebp-30h]
  int v21[2]; // [esp+C0h] [ebp-28h] BYREF
  float v22; // [esp+C8h] [ebp-20h]
  int i; // [esp+DCh] [ebp-Ch]

  if ( a1[41] > *(float *)dword_833082C + 1.0
    || a1[42] > *(float *)&dword_8330830 + 1.0
    || a1[43] > *(float *)&dword_8330834 + 1.0
    || *(float *)dword_8330820 - 1.0 > a1[44]
    || *(float *)&dword_8330824 - 1.0 > a1[45]
    || *(float *)&dword_8330828 - 1.0 > a1[46] )
  {
    return 0;
  }
  *(float *)v17 = *a1 + a1[64];
  *(float *)&v17[1] = a1[1] + a1[65];
  v18 = a1[2] + a1[66];
  *(float *)v15 = *a1 - a1[64];
  *(float *)&v15[1] = a1[1] - a1[65];
  v16 = a1[2] - a1[66];
  *(float *)v13 = a1[3] + a1[64];
  *(float *)&v13[1] = a1[4] + a1[65];
  v14 = a1[5] + a1[66];
  *(float *)v11 = a1[3] - a1[64];
  *(float *)&v11[1] = a1[4] - a1[65];
  v12 = a1[5] - a1[66];
  for ( i = 0; i <= 2; ++i )
  {
    *((float *)&v8 + i) = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
    v5[i] = *(float *)&dword_8330820[i] - *((float *)&v8 + i);
    v6[i] = *(float *)&dword_833082C[i] - *((float *)&v8 + i);
  }
  if ( v6[0] <= (long double)v7 )
    v2 = v6[0];
  else
    v2 = v7;
  v4 = v7 - v2;
  v21[0] = v8;
  v21[1] = v9;
  v22 = v10 + v4;
  v19[0] = v8;
  v19[1] = v9;
  v20 = v10 - v4;
  if ( v16 <= (long double)v22 )
  {
    if ( v20 > (long double)v18 )
    {
      if ( !sub_805C0FC((int)a1, (int)v17, (int)v13, (int)v19, v2) )
        return -1;
      if ( a1[8] <= 0.0 )
        return 0;
    }
  }
  else
  {
    if ( !sub_805C0FC((int)a1, (int)v15, (int)v11, (int)v21, v2) )
      return -1;
    if ( a1[8] >= 0.0 )
      return 0;
  }
  if ( sub_805C272((int)a1, (int)&v8, v4, v2) )
  {
    if ( v12 <= (long double)v22 )
    {
      if ( v20 > (long double)v14 && v18 >= (long double)v20 && !sub_805C0FC((int)a1, (int)v17, (int)v13, (int)v19, v2) )
        return -1;
    }
    else if ( v22 >= (long double)v16 && !sub_805C0FC((int)a1, (int)v15, (int)v11, (int)v21, v2) )
    {
      return -1;
    }
    return 0;
  }
  return -1;
}
// 8330820: using guessed type int dword_8330820[];
// 8330824: using guessed type int dword_8330824;
// 8330828: using guessed type int dword_8330828;
// 833082C: using guessed type int dword_833082C[];
// 8330830: using guessed type int dword_8330830;
// 8330834: using guessed type int dword_8330834;

//----- (0805C936) --------------------------------------------------------
int __cdecl sub_805C936(int a1)
{
  float v2; // [esp+14h] [ebp-44h]
  int i; // [esp+1Ch] [ebp-3Ch]
  float v4[3]; // [esp+20h] [ebp-38h]
  float v5[2]; // [esp+2Ch] [ebp-2Ch]
  float v6; // [esp+34h] [ebp-24h]
  float v7[6]; // [esp+40h] [ebp-18h]

  for ( i = 0; i <= 2; ++i )
  {
    v7[i] = (*(float *)&dword_8330820[i] + *(float *)&dword_833082C[i]) * 0.5;
    v4[i] = *(float *)&dword_8330820[i] - v7[i];
    v5[i] = *(float *)&dword_833082C[i] - v7[i];
    *(float *)(a1 + 4 * i) = *(float *)(a1 + 4 * i) - v7[i];
    *(float *)(a1 + 4 * i + 12) = *(float *)(a1 + 4 * i + 12) - v7[i];
  }
  *(_DWORD *)(a1 + 244) = 1;
  if ( v5[0] <= (long double)v6 )
    v2 = v5[0];
  else
    v2 = v6;
  *(float *)(a1 + 248) = v2;
  *(float *)(a1 + 252) = v6;
  *(_DWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 260) = 0;
  *(float *)(a1 + 264) = v6 - *(float *)(a1 + 248);
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a1 + 248);
  *(_DWORD *)(a1 + 276) = *(_DWORD *)(a1 + 252);
  sub_804BDD3((int *)(a1 + 40), (int *)(a1 + 52), *(_DWORD *)dword_833081C, 0);
  return sub_805B849(a1, dword_833081C);
}
// 833081C: using guessed type int dword_833081C;
// 8330820: using guessed type int dword_8330820[];
// 833082C: using guessed type int dword_833082C[];

//----- (0805CAD6) --------------------------------------------------------
int __cdecl sub_805CAD6(int *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+24h] [ebp-44h]
  float v9; // [esp+28h] [ebp-40h]
  float v10; // [esp+28h] [ebp-40h]
  int v11; // [esp+2Ch] [ebp-3Ch]
  float v12; // [esp+30h] [ebp-38h] BYREF
  float v13; // [esp+34h] [ebp-34h]
  float v14; // [esp+38h] [ebp-30h]
  float v15; // [esp+40h] [ebp-28h]
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  float v18; // [esp+4Ch] [ebp-1Ch]
  float v19; // [esp+50h] [ebp-18h]
  float v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  if ( a2 < 0 )
    return sub_805BF79(a1, dword_83307AC + 16 * (-1 - a2));
  v22 = dword_83307A4 + 8 * a2;
  v21 = *(_DWORD *)v22;
  if ( *(_BYTE *)(v21 + 16) > 2u )
  {
    v20 = *(float *)v21 * *a5 + *(float *)(v21 + 4) * a5[1] + *(float *)(v21 + 8) * a5[2] - *(float *)(v21 + 12);
    v19 = *(float *)v21 * *a6 + *(float *)(v21 + 4) * a6[1] + *(float *)(v21 + 8) * a6[2] - *(float *)(v21 + 12);
    if ( a1[48] )
      v18 = 0.0;
    else
      v18 = 2048.0;
  }
  else
  {
    v20 = a5[*(unsigned __int8 *)(v21 + 16)] - *(float *)(v21 + 12);
    v19 = a6[*(unsigned __int8 *)(v21 + 16)] - *(float *)(v21 + 12);
    v18 = *(float *)&a1[*(unsigned __int8 *)(v21 + 16) + 13];
  }
  if ( v20 >= v18 + 1.0 && v19 >= v18 + 1.0 )
    return sub_805CAD6(a1, *(__int16 *)(v22 + 4), LODWORD(a3), LODWORD(a4), a5, a6);
  if ( -1.0 - v18 > v20 && -1.0 - v18 > v19 )
    return sub_805CAD6(a1, *(__int16 *)(v22 + 6), LODWORD(a3), LODWORD(a4), a5, a6);
  if ( v19 <= (long double)v20 )
  {
    if ( v20 <= (long double)v19 )
    {
      v11 = 0;
      v17 = 1.0;
      v16 = 0.0;
    }
    else
    {
      v15 = 1.0 / (v20 - v19);
      v11 = 0;
      v16 = (v20 - v18 - 0.125) * v15;
      v17 = (v20 + v18 + 0.125) * v15;
    }
  }
  else
  {
    v15 = 1.0 / (v20 - v19);
    v11 = 1;
    v16 = (v20 + v18 + 0.125) * v15;
    v17 = (v20 - v18 + 0.125) * v15;
  }
  if ( v17 < 0.0 )
    v17 = 0.0;
  if ( v17 > 1.0 )
    v17 = 1.0;
  v9 = (a4 - a3) * v17 + a3;
  v12 = (*a6 - *a5) * v17 + *a5;
  v13 = (a6[1] - a5[1]) * v17 + a5[1];
  v14 = (a6[2] - a5[2]) * v17 + a5[2];
  v8 = sub_805CAD6(a1, *(__int16 *)(v22 + 2 * v11 + 4), LODWORD(a3), LODWORD(v9), a5, &v12);
  if ( v8 )
    return v8;
  if ( v16 < 0.0 )
    v16 = 0.0;
  if ( v16 > 1.0 )
    v16 = 1.0;
  v10 = (a4 - a3) * v16 + a3;
  v12 = (*a6 - *a5) * v16 + *a5;
  v13 = (a6[1] - a5[1]) * v16 + a5[1];
  v14 = (a6[2] - a5[2]) * v16 + a5[2];
  return sub_805CAD6(a1, *(__int16 *)(v22 + 2 * (v11 ^ 1) + 4), LODWORD(v10), LODWORD(a4), &v12, a6);
}
// 83307A4: using guessed type int dword_83307A4;
// 83307AC: using guessed type int dword_83307AC;

//----- (0805CF2E) --------------------------------------------------------
int __cdecl sub_805CF2E(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8, int a9, int a10)
{
  int v10; // ebx
  long double v11; // fst7
  float v13; // [esp+20h] [ebp-158h]
  float v14; // [esp+24h] [ebp-154h]
  float v15; // [esp+24h] [ebp-154h]
  float v16; // [esp+24h] [ebp-154h]
  int v17; // [esp+28h] [ebp-150h]
  int *v18; // [esp+2Ch] [ebp-14Ch]
  float v19[4]; // [esp+30h] [ebp-148h]
  float s[3]; // [esp+40h] [ebp-138h] BYREF
  float v21[3]; // [esp+4Ch] [ebp-12Ch] BYREF
  float v22; // [esp+58h] [ebp-120h]
  float v23; // [esp+5Ch] [ebp-11Ch]
  float v24; // [esp+60h] [ebp-118h]
  float v25; // [esp+64h] [ebp-114h]
  int v26; // [esp+68h] [ebp-110h]
  int v27; // [esp+6Ch] [ebp-10Ch]
  int v28; // [esp+70h] [ebp-108h]
  int v29; // [esp+74h] [ebp-104h]
  int v30; // [esp+78h] [ebp-100h]
  int v31; // [esp+7Ch] [ebp-FCh]
  int v32; // [esp+80h] [ebp-F8h]
  int v33; // [esp+84h] [ebp-F4h]
  int v34; // [esp+88h] [ebp-F0h]
  int v35; // [esp+8Ch] [ebp-ECh]
  int v36; // [esp+90h] [ebp-E8h]
  int v37; // [esp+94h] [ebp-E4h]
  int v38; // [esp+98h] [ebp-E0h]
  int v39; // [esp+9Ch] [ebp-DCh]
  int v40; // [esp+A0h] [ebp-D8h]
  int v41; // [esp+A4h] [ebp-D4h]
  int v42; // [esp+A8h] [ebp-D0h]
  int v43; // [esp+ACh] [ebp-CCh]
  int v44; // [esp+B0h] [ebp-C8h]
  int v45; // [esp+B4h] [ebp-C4h]
  int v46; // [esp+B8h] [ebp-C0h]
  int v47; // [esp+BCh] [ebp-BCh]
  int v48; // [esp+C0h] [ebp-B8h]
  int v49; // [esp+C4h] [ebp-B4h]
  float v50; // [esp+C8h] [ebp-B0h]
  int v51; // [esp+CCh] [ebp-ACh]
  int v52; // [esp+D0h] [ebp-A8h]
  float v53; // [esp+D4h] [ebp-A4h]
  float v54; // [esp+D8h] [ebp-A0h]
  int v55; // [esp+DCh] [ebp-9Ch]
  float v56; // [esp+E0h] [ebp-98h]
  float v57[6]; // [esp+E4h] [ebp-94h]
  int v58; // [esp+FCh] [ebp-7Ch]
  _BOOL4 v59; // [esp+100h] [ebp-78h]
  int v60; // [esp+104h] [ebp-74h]
  int v61; // [esp+134h] [ebp-44h]
  float v62; // [esp+138h] [ebp-40h]
  float v63; // [esp+13Ch] [ebp-3Ch]
  float v64; // [esp+140h] [ebp-38h]
  int v65; // [esp+144h] [ebp-34h]
  float v66; // [esp+148h] [ebp-30h]
  int v67[8]; // [esp+14Ch] [ebp-2Ch]
  int i; // [esp+16Ch] [ebp-Ch]
  int v69; // [esp+180h] [ebp+8h]
  int v70; // [esp+180h] [ebp+8h]

  v18 = sub_804BBD8(a6);
  ++dword_8330800;
  sub_80D2FE9(s, 0, 0x118u);
  v60 = 1065353216;
  if ( !a4 )
    a4 = &dword_80D7EC8;
  if ( !a5 )
    a5 = &dword_80D7EC8;
  v58 = a8;
  for ( i = 0; i <= 2; ++i )
  {
    v19[i] = (*(float *)&a4[i] + *(float *)&a5[i]) * 0.5;
    *((float *)&v26 + i) = *(float *)&a4[i] - v19[i];
    *((float *)&v29 + i) = *(float *)&a5[i] - v19[i];
    s[i] = *(float *)(a2 + 4 * i) + v19[i];
    v21[i] = *(float *)(a3 + 4 * i) + v19[i];
    *(&v22 + i) = v21[i] - s[i];
  }
  v25 = v22 * v22 + v23 * v23 + v24 * v24;
  if ( a10 )
  {
    v61 = *(_DWORD *)a10;
    v62 = *(float *)(a10 + 4);
    v63 = *(float *)(a10 + 8);
    v64 = *(float *)(a10 + 12);
    v65 = *(_DWORD *)(a10 + 16);
    v66 = *(float *)(a10 + 20);
    v67[0] = *(_DWORD *)(a10 + 24);
    v67[1] = *(_DWORD *)(a10 + 28);
    v67[2] = *(_DWORD *)(a10 + 32);
  }
  else
  {
    v61 = a9;
    if ( *(float *)&v29 <= (long double)*(float *)&v31 )
      v13 = *(float *)&v29;
    else
      v13 = *(float *)&v31;
    v62 = v13;
    v63 = *(float *)&v31;
    v64 = 0.0;
    v65 = 0;
    v66 = *(float *)&v31 - v13;
  }
  v56 = *(float *)&v29 + *(float *)&v30 + *(float *)&v31;
  v32 = v26;
  v33 = v27;
  v34 = v28;
  v35 = v29;
  v36 = v27;
  v37 = v28;
  v38 = v26;
  v39 = v30;
  v40 = v28;
  v41 = v29;
  v42 = v30;
  v43 = v28;
  v44 = v26;
  v45 = v27;
  v46 = v31;
  v47 = v29;
  v48 = v27;
  v49 = v31;
  v50 = *(float *)&v26;
  v51 = v30;
  v52 = v31;
  v53 = *(float *)&v29;
  v54 = *(float *)&v30;
  v55 = v31;
  if ( v61 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v14 = fabs(*(&v64 + i));
      if ( v21[i] <= (long double)s[i] )
      {
        v57[i] = v21[i] - v14 - v62;
        v16 = fabs(*(&v64 + i));
        v57[i + 3] = v16 + s[i] + v62;
      }
      else
      {
        v57[i] = s[i] - v14 - v62;
        v15 = fabs(*(&v64 + i));
        v57[i + 3] = v15 + v21[i] + v62;
      }
    }
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( v21[i] <= (long double)s[i] )
      {
        v57[i] = v21[i] + *((float *)&v26 + i);
        v57[i + 3] = s[i] + *((float *)&v29 + i);
      }
      else
      {
        v57[i] = s[i] + *((float *)&v26 + i);
        v57[i + 3] = v21[i] + *((float *)&v29 + i);
      }
    }
  }
  v59 = 0.0 == *(float *)&v29 + *(float *)&v30 + *(float *)&v31;
  if ( v61 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v10 = i;
      v11 = sub_805D9B8(*(&v64 + i));
      *(float *)&v67[v10] = v11 + v62;
    }
  }
  if ( a6 )
  {
    if ( a6 == 510 )
    {
      if ( (v58 & *(_DWORD *)dword_833081C) != 0 )
      {
        if ( v61 )
          v17 = sub_805C498(s);
        else
          v17 = sub_805C936((int)s);
      }
      else
      {
        v17 = 0;
      }
    }
    else
    {
      v17 = sub_805BF79((int *)s, (int)(v18 + 6));
    }
  }
  else
  {
    v17 = 0;
    if ( a1 > 0 )
    {
      v69 = a1 - 1;
      if ( v69 >= dword_83307C8 )
      {
        v70 = v69 - dword_83307C8;
        if ( v70 < dword_83307F4 )
          v17 = sub_805B7D7((int *)s, dword_83307F8 + 44 * v70);
      }
      else
      {
        v17 = sub_805B849((int)s, dword_83307CC + 52 * v69);
      }
    }
    if ( !v17 )
      v17 = sub_805CAD6((int *)s, 0, 0.0, 1.0, s, v21);
  }
  return v17;
}
// 80D7EC8: using guessed type int dword_80D7EC8;
// 83307C8: using guessed type int dword_83307C8;
// 83307CC: using guessed type int dword_83307CC;
// 83307F4: using guessed type int dword_83307F4;
// 83307F8: using guessed type int dword_83307F8;
// 8330800: using guessed type int dword_8330800;
// 833081C: using guessed type int dword_833081C;

//----- (0805D625) --------------------------------------------------------
int __cdecl sub_805D625(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, int a8)
{
  return sub_805CF2E(a1, a2, a3, a4, a5, a6, (int)&dword_80D7EC8, a7, a8, 0);
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0805D679) --------------------------------------------------------
int __cdecl sub_805D679(int a1, int a2, int a3, int *a4, int *a5, int a6, int a7, float *a8, float *a9, int a10)
{
  int v11; // [esp+4Ch] [ebp-DCh]
  int v12[3]; // [esp+50h] [ebp-D8h] BYREF
  float v13; // [esp+5Ch] [ebp-CCh]
  float v14; // [esp+60h] [ebp-C8h]
  float v15; // [esp+64h] [ebp-C4h]
  float v16; // [esp+80h] [ebp-A8h]
  int v17; // [esp+84h] [ebp-A4h]
  int v18; // [esp+88h] [ebp-A0h]
  int i; // [esp+8Ch] [ebp-9Ch]
  float v20[12]; // [esp+90h] [ebp-98h] BYREF
  int v21[3]; // [esp+C0h] [ebp-68h] BYREF
  float v22[2]; // [esp+CCh] [ebp-5Ch] BYREF
  float v23; // [esp+D4h] [ebp-54h]
  float v24[7]; // [esp+E0h] [ebp-48h]
  _BOOL4 v25; // [esp+FCh] [ebp-2Ch]
  float v26; // [esp+100h] [ebp-28h] BYREF
  float v27; // [esp+104h] [ebp-24h]
  float v28; // [esp+108h] [ebp-20h]
  float v29; // [esp+110h] [ebp-18h] BYREF
  float v30; // [esp+114h] [ebp-14h]
  float v31; // [esp+118h] [ebp-10h]

  if ( !a4 )
    a4 = &dword_80D7EC8;
  if ( !a5 )
    a5 = &dword_80D7EC8;
  for ( i = 0; i <= 2; ++i )
  {
    v24[i] = (*(float *)&a4[i] + *(float *)&a5[i]) * 0.5;
    *(float *)&v21[i] = *(float *)&a4[i] - v24[i];
    v22[i] = *(float *)&a5[i] - v24[i];
    *(&v29 + i) = *(float *)(a2 + 4 * i) + v24[i];
    *(&v26 + i) = *(float *)(a3 + 4 * i) + v24[i];
  }
  v29 = v29 - *a8;
  v30 = v30 - a8[1];
  v31 = v31 - a8[2];
  v26 = v26 - *a8;
  v27 = v27 - a8[1];
  v28 = v28 - a8[2];
  v25 = a6 != 511 && (*a9 != 0.0 || a9[1] != 0.0 || a9[2] != 0.0);
  v18 = SLODWORD(v22[0]);
  *(float *)&v17 = v23;
  v12[0] = a10;
  if ( v22[0] <= (long double)v23 )
    v11 = v18;
  else
    v11 = v17;
  v12[1] = v11;
  v12[2] = v17;
  v16 = *(float *)&v17 - *(float *)&v11;
  if ( v25 )
  {
    sub_8057DF6(a9, (int)v20);
    sub_8057CE4(&v29, v20);
    sub_8057CE4(&v26, v20);
    v13 = v20[2] * v16;
    v14 = -v20[5] * v16;
    v15 = v20[8] * v16;
  }
  else
  {
    v13 = 0.0;
    v14 = 0.0;
    v15 = v16;
  }
  return sub_805CF2E(a1, (int)&v29, (int)&v26, v21, (int *)v22, a6, (int)a8, a7, a10, (int)v12);
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0805D9B8) --------------------------------------------------------
long double __cdecl sub_805D9B8(float a1)
{
  return (float)fabs(a1);
}

//----- (0805D9D4) --------------------------------------------------------
int __cdecl sub_805D9D4(float *a1, float *a2)
{
  _BOOL4 v4; // [esp+8h] [ebp-18h]
  int v5; // [esp+Ch] [ebp-14h]
  float v6; // [esp+10h] [ebp-10h]
  float v7; // [esp+14h] [ebp-Ch]

  v5 = dword_8330870;
  if ( !dword_8330870 )
    return 0;
  v6 = *a2 - *a1;
  v7 = a2[1] - a1[1];
  v4 = v7 >= (long double)v6;
  if ( *(&v6 + v4) <= 512.0 )
    return 0;
  dword_8330870 = *(_DWORD *)(dword_8330870 + 28);
  *(_DWORD *)v5 = v4;
  *(float *)(v5 + 16) = (a2[v4] + a1[v4]) * 0.5;
  *(_DWORD *)(v5 + 32) = &unk_8330874;
  *(_DWORD *)(v5 + 36) = &unk_8330874;
  return v5;
}
// 8330870: using guessed type int dword_8330870;

//----- (0805DAB2) --------------------------------------------------------
__int64 CM_ClearWorld()
{
  __int64 result; // rax
  float v1; // [esp+18h] [ebp-10h]
  float v2; // [esp+1Ch] [ebp-Ch]
  unsigned int i; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v4 = sub_804BCA0(0);
  sub_804BEB3(v4, (int *)flt_8330804, flt_8330810);
  dword_8330870 = (int)&unk_833089C;
  for ( i = 0; i <= 0x3FE; ++i )
    dword_83308B8[10 * i] = 40 * i + 137562308;
  dword_833A890 = 0;
  v1 = flt_8330810[0] - flt_8330804[0];
  v2 = flt_8330814 - flt_8330808;
  dword_8330848 = v2 >= (long double)v1;
  LODWORD(result) = dword_8330848;
  HIDWORD(result) = dword_8330848;
  flt_8330858 = (flt_8330810[dword_8330848] + flt_8330804[dword_8330848]) * 0.5;
  dword_8330868 = (int)&unk_8330874;
  dword_833086C = (int)&unk_8330874;
  return result;
}
// 8330804: using guessed type float flt_8330804[];
// 8330808: using guessed type float flt_8330808;
// 8330810: using guessed type float flt_8330810[];
// 8330814: using guessed type float flt_8330814;
// 8330848: using guessed type int dword_8330848;
// 8330858: using guessed type float flt_8330858;
// 8330868: using guessed type int dword_8330868;
// 833086C: using guessed type int dword_833086C;
// 8330870: using guessed type int dword_8330870;
// 833A890: using guessed type int dword_833A890;

//----- (0805DBAB) --------------------------------------------------------
int __cdecl sub_805DBAB(int *a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  result = *a1;
  v3 = *a1;
  if ( *a1 )
  {
    *a1 = 0;
    if ( *(int **)(v3 + 20) == a1 )
    {
      *(_DWORD *)(v3 + 20) = a1[1];
    }
    else
    {
      for ( i = *(_DWORD *)(v3 + 20); *(int **)(i + 4) != a1; i = *(_DWORD *)(i + 4) )
        ;
      *(_DWORD *)(i + 4) = a1[1];
    }
    while ( 1 )
    {
      result = v3;
      if ( *(_DWORD *)(v3 + 20) )
        break;
      result = v3;
      if ( *(_DWORD *)(v3 + 24) )
        break;
      result = v3;
      if ( *(_UNKNOWN **)(v3 + 32) != &unk_8330874 )
        break;
      result = v3;
      if ( *(_UNKNOWN **)(v3 + 36) != &unk_8330874 )
        break;
      *(_DWORD *)(v3 + 12) = 0;
      result = *(_DWORD *)(v3 + 28);
      if ( !result )
        break;
      *(_DWORD *)(v3 + 28) = dword_8330870;
      dword_8330870 = v3;
      if ( *(_DWORD *)(result + 32) == v3 )
        *(_DWORD *)(result + 32) = &unk_8330874;
      else
        *(_DWORD *)(result + 36) = &unk_8330874;
      v3 = result;
    }
    while ( v3 )
    {
      v2 = *(_DWORD *)(*(_DWORD *)(v3 + 32) + 12) | *(_DWORD *)(*(_DWORD *)(v3 + 36) + 12);
      for ( j = *(_DWORD *)(v3 + 20); j; j = *(_DWORD *)(j + 4) )
        v2 |= *(_DWORD *)(sub_808D395(j) + 284);
      *(_DWORD *)(v3 + 12) = v2;
      result = *(_DWORD *)(v3 + 28);
      v3 = result;
    }
  }
  return result;
}
// 8330870: using guessed type int dword_8330870;

//----- (0805DD00) --------------------------------------------------------
int __cdecl sub_805DD00(float *a1, float *a2, float *a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-2Ch]
  int v5; // [esp+Ch] [ebp-2Ch]
  int *v6; // [esp+10h] [ebp-28h]
  int *v7; // [esp+14h] [ebp-24h]
  int *v8; // [esp+18h] [ebp-20h]
  int *v9; // [esp+1Ch] [ebp-1Ch]
  float v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  int *v12; // [esp+28h] [ebp-10h]
  int *i; // [esp+2Ch] [ebp-Ch]

  v11 = *a1;
  v10 = a1[4];
  v9 = 0;
  for ( i = (int *)*((_DWORD *)a1 + 5); ; i = (int *)i[1] )
  {
    while ( 1 )
    {
      if ( !i )
      {
        v8 = 0;
        result = *((_DWORD *)a1 + 6);
        v12 = (int *)result;
        while ( 1 )
        {
          if ( !v12 )
            return result;
          if ( *(float *)&v12[LODWORD(v11) + 14] > (long double)v10 )
            break;
          if ( v10 <= (long double)*(float *)&v12[LODWORD(v11) + 17] )
          {
            v8 = v12;
            result = v12[13];
            v12 = (int *)result;
          }
          else
          {
            v5 = *((_DWORD *)a1 + 9);
            if ( (_UNKNOWN *)v5 == &unk_8330874 )
            {
              result = sub_805D9D4(a2, a3);
              v5 = result;
              if ( !result )
                return result;
              *((_DWORD *)a1 + 9) = result;
              *(_DWORD *)(result + 28) = a1;
            }
LABEL_27:
            v6 = (int *)v12[13];
            v12[13] = *(_DWORD *)(v5 + 24);
            *(_DWORD *)(v5 + 24) = v12;
            *(_DWORD *)(v5 + 4) |= sub_80CEFA0(*v12);
            if ( v12[20] )
              *(_DWORD *)(v5 + 8) |= sub_80CEFA0(*v12);
            if ( v8 )
              v8[13] = (int)v6;
            else
              *((_DWORD *)a1 + 6) = v6;
            result = (int)v6;
            v12 = v6;
          }
        }
        v5 = *((_DWORD *)a1 + 8);
        if ( (_UNKNOWN *)v5 == &unk_8330874 )
        {
          result = sub_805D9D4(a2, a3);
          v5 = result;
          if ( !result )
            return result;
          *((_DWORD *)a1 + 8) = result;
          *(_DWORD *)(result + 28) = a1;
        }
        goto LABEL_27;
      }
      if ( *(float *)&i[LODWORD(v11) + 91] <= (long double)v10 )
        break;
      v4 = *((_DWORD *)a1 + 8);
      if ( (_UNKNOWN *)v4 == &unk_8330874 )
      {
        result = sub_805D9D4(a2, a3);
        v4 = result;
        if ( !result )
          return result;
        *((_DWORD *)a1 + 8) = result;
        *(_DWORD *)(result + 28) = a1;
      }
LABEL_12:
      v7 = (int *)i[1];
      *i = v4;
      i[1] = *(_DWORD *)(v4 + 20);
      *(_DWORD *)(v4 + 20) = i;
      *(_DWORD *)(v4 + 12) |= *(_DWORD *)(sub_808D395((int)i) + 284);
      if ( v9 )
        v9[1] = (int)v7;
      else
        *((_DWORD *)a1 + 5) = v7;
      i = v7;
    }
    if ( v10 > (long double)*(float *)&i[LODWORD(v11) + 93] )
      break;
    v9 = i;
  }
  v4 = *((_DWORD *)a1 + 9);
  if ( (_UNKNOWN *)v4 != &unk_8330874 )
    goto LABEL_12;
  result = sub_805D9D4(a2, a3);
  v4 = result;
  if ( result )
  {
    *((_DWORD *)a1 + 9) = result;
    *(_DWORD *)(result + 28) = a1;
    goto LABEL_12;
  }
  return result;
}

//----- (0805DFE6) --------------------------------------------------------
int __cdecl sub_805DFE6(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  int v4[2]; // [esp+18h] [ebp-20h] BYREF
  int v5[2]; // [esp+20h] [ebp-18h] BYREF
  int v6; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]
  float *i; // [esp+34h] [ebp-4h]

  v6 = *(_DWORD *)(sub_808D395(a1) + 284);
  while ( 1 )
  {
    *(float *)v5 = flt_8330804[0];
    *(float *)&v5[1] = flt_8330808;
    *(float *)v4 = flt_8330810[0];
    *(float *)&v4[1] = flt_8330814;
    for ( i = (float *)&dword_8330848; ; i = (float *)*((_DWORD *)i + 9) )
    {
      while ( 1 )
      {
        *((_DWORD *)i + 3) |= v6;
        v8 = *(_DWORD *)i;
        v7 = *((int *)i + 4);
        if ( *(float *)&a2[v8] <= (long double)*(float *)&v7 )
          break;
        v5[v8] = v7;
        if ( *((_UNKNOWN **)i + 8) == &unk_8330874 )
          goto LABEL_12;
        i = (float *)*((_DWORD *)i + 8);
      }
      if ( *(float *)&v7 <= (long double)*(float *)&a3[v8] )
        break;
      v4[v8] = v7;
      if ( *((_UNKNOWN **)i + 9) == &unk_8330874 )
        goto LABEL_12;
    }
    if ( i == *(float **)a1 && (*(_DWORD *)(a1 + 360) & ~v6) == 0 )
    {
      *(_DWORD *)(a1 + 360) = v6;
      *(_DWORD *)(a1 + 364) = *a2;
      *(_DWORD *)(a1 + 368) = a2[1];
      *(_DWORD *)(a1 + 372) = *a3;
      result = a3[1];
      *(_DWORD *)(a1 + 376) = result;
      return result;
    }
LABEL_12:
    if ( !*(_DWORD *)a1 )
      break;
    if ( i == *(float **)a1 && (*(_DWORD *)(a1 + 360) & ~v6) == 0 )
      goto LABEL_17;
    sub_805DBAB((int *)a1);
  }
  *(_DWORD *)a1 = i;
  *(float *)(a1 + 4) = i[5];
  *((_DWORD *)i + 5) = a1;
LABEL_17:
  *(_DWORD *)(a1 + 360) = v6;
  *(_DWORD *)(a1 + 364) = *a2;
  *(_DWORD *)(a1 + 368) = a2[1];
  *(_DWORD *)(a1 + 372) = *a3;
  *(_DWORD *)(a1 + 376) = a3[1];
  return sub_805DD00(i, (float *)v5, (float *)v4);
}
// 8330804: using guessed type float flt_8330804[];
// 8330808: using guessed type float flt_8330808;
// 8330810: using guessed type float flt_8330810[];
// 8330814: using guessed type float flt_8330814;
// 8330848: using guessed type int dword_8330848;

//----- (0805E1ED) --------------------------------------------------------
int sub_805E1ED()
{
  return 0;
}

//----- (0805E1F7) --------------------------------------------------------
int __cdecl sub_805E1F7(int a1)
{
  int v2[2]; // [esp+10h] [ebp-28h] BYREF
  int v3[2]; // [esp+18h] [ebp-20h] BYREF
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  float *i; // [esp+2Ch] [ebp-Ch]

  *(_DWORD *)(a1 + 80) = sub_805E1ED();
  v4 = sub_80CEFA0(*(_DWORD *)a1);
  *(float *)v3 = flt_8330804[0];
  *(float *)&v3[1] = flt_8330808;
  *(float *)v2 = flt_8330810[0];
  *(float *)&v2[1] = flt_8330814;
  for ( i = (float *)&dword_8330848; ; i = (float *)*((_DWORD *)i + 9) )
  {
    while ( 1 )
    {
      *((_DWORD *)i + 1) |= v4;
      if ( *(_DWORD *)(a1 + 80) )
        *((_DWORD *)i + 2) |= v4;
      v6 = *(_DWORD *)i;
      v5 = *((int *)i + 4);
      if ( *(float *)(a1 + 4 * v6 + 56) <= (long double)*(float *)&v5 )
        break;
      v3[v6] = v5;
      if ( *((_UNKNOWN **)i + 8) == &unk_8330874 )
        goto LABEL_10;
      i = (float *)*((_DWORD *)i + 8);
    }
    if ( *(float *)&v5 <= (long double)*(float *)(a1 + 4 * v6 + 68) )
      break;
    v2[v6] = v5;
    if ( *((_UNKNOWN **)i + 9) == &unk_8330874 )
      break;
  }
LABEL_10:
  *(float *)(a1 + 52) = i[6];
  *((_DWORD *)i + 6) = a1;
  return sub_805DD00(i, (float *)v3, (float *)v2);
}
// 8330804: using guessed type float flt_8330804[];
// 8330808: using guessed type float flt_8330808;
// 8330810: using guessed type float flt_8330810[];
// 8330814: using guessed type float flt_8330814;
// 8330848: using guessed type int dword_8330848;

//----- (0805E332) --------------------------------------------------------
void __cdecl sub_805E332(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( (*(_DWORD *)(a1 + 12) & *(_DWORD *)(a2 + 24)) != 0 )
  {
    for ( i = *(_DWORD *)(a1 + 20); i; i = *(_DWORD *)(i + 4) )
    {
      v2 = sub_808D395(i);
      if ( (*(_DWORD *)(v2 + 284) & *(_DWORD *)(a2 + 24)) != 0
        && *(float *)(v2 + 288) <= (long double)**(float **)(a2 + 8)
        && **(float **)(a2 + 4) <= (long double)*(float *)(v2 + 300)
        && *(float *)(v2 + 292) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 4)
        && *(float *)(*(_DWORD *)(a2 + 4) + 4) <= (long double)*(float *)(v2 + 304)
        && *(float *)(v2 + 296) <= (long double)*(float *)(*(_DWORD *)(a2 + 8) + 8)
        && *(float *)(*(_DWORD *)(a2 + 4) + 8) <= (long double)*(float *)(v2 + 308) )
      {
        if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 20) )
        {
          Com_DPrintf("CM_AreaEntities: MAXCOUNT\n");
          return;
        }
        *(_DWORD *)(*(_DWORD *)(a2 + 12) + 4 * (*(_DWORD *)(a2 + 16))++) = -723362913 * ((i + -(int)&sv - 9240) >> 2);
      }
    }
    if ( *(float *)(*(_DWORD *)(a2 + 8) + 4 * *(_DWORD *)a1) > (long double)*(float *)(a1 + 16) )
      sub_805E332(*(_DWORD *)(a1 + 32), a2);
    if ( *(float *)(a1 + 16) > (long double)*(float *)(*(_DWORD *)(a2 + 4) + 4 * *(_DWORD *)a1) )
      sub_805E332(*(_DWORD *)(a1 + 36), a2);
  }
}
// 836B820: using guessed type int sv;

//----- (0805E510) --------------------------------------------------------
int __cdecl sub_805E510(int a1, int a2, int a3, int a4, int a5)
{
  char v6[4]; // [esp+10h] [ebp-28h] BYREF
  int v7; // [esp+14h] [ebp-24h]
  int v8; // [esp+18h] [ebp-20h]
  int v9; // [esp+1Ch] [ebp-1Ch]
  int v10; // [esp+20h] [ebp-18h]
  int v11; // [esp+24h] [ebp-14h]
  int v12; // [esp+28h] [ebp-10h]

  v7 = a1;
  v8 = a2;
  v9 = a3;
  v10 = 0;
  v11 = a4;
  v12 = a5;
  sub_805E332((int)&dword_8330848, (int)v6);
  return v10;
}
// 8330848: using guessed type int dword_8330848;

//----- (0805E553) --------------------------------------------------------
int __cdecl sub_805E553(int a1, int a2, int a3, int a4, float a5)
{
  float v8; // [esp+8h] [ebp-20h]
  float v9; // [esp+8h] [ebp-20h]
  int i; // [esp+Ch] [ebp-1Ch]
  float v11; // [esp+10h] [ebp-18h]
  float v12; // [esp+14h] [ebp-14h]
  float v13; // [esp+18h] [ebp-10h]
  float v15; // [esp+20h] [ebp-8h]

  v15 = 0.0;
  v13 = -1.0;
  while ( 1 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v12 = (*(float *)(a1 + 4 * i) - *(float *)(a3 + 4 * i)) * v13;
      v11 = (*(float *)(a2 + 4 * i) - *(float *)(a3 + 4 * i)) * v13;
      if ( v12 <= 0.0 )
      {
        if ( v11 > 0.0 )
        {
          v9 = v12 - v11;
          if ( v12 > a5 * v9 )
          {
            a5 = v12 / v9;
            if ( v15 >= (long double)a5 )
              return 1;
          }
        }
      }
      else
      {
        if ( v11 > 0.0 )
          return 1;
        v8 = v12 - v11;
        if ( v12 > v15 * v8 )
        {
          v15 = v12 / v8;
          if ( v15 >= (long double)a5 )
            return 1;
        }
      }
    }
    if ( v13 == 1.0 )
      break;
    v13 = 1.0;
    a3 = a4;
  }
  return 0;
}

//----- (0805E6C9) --------------------------------------------------------
void __cdecl sub_805E6C9(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int *i; // [esp+2Ch] [ebp-3Ch]
  int v7[7]; // [esp+30h] [ebp-38h] BYREF
  float v8; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( a3 < (long double)*(float *)a1 && (*(_DWORD *)(a2 + 4) & *(_DWORD *)(a1 + 48)) != 0 )
  {
    v12 = *(float *)(a5 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    v11 = *(float *)(a6 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    if ( v12 < 0.0 || v11 < 0.0 )
    {
      if ( v12 > 0.0 || v11 > 0.0 )
      {
        v10 = v12 / (v12 - v11);
        v8 = (*(float *)&a4 - a3) * v10 + a3;
        *(float *)v7 = (*(float *)a6 - *(float *)a5) * v10 + *(float *)a5;
        *(float *)&v7[1] = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v10 + *(float *)(a5 + 4);
        *(float *)&v7[2] = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v10 + *(float *)(a5 + 8);
        v9 = v12 < 0.0;
        sub_805E6C9(a1, *(_DWORD *)(a2 + 4 * v9 + 32), a3, SLODWORD(v8), a5, (int)v7);
        sub_805E6C9(a1, *(_DWORD *)(a2 + 4 * (1 - v9) + 32), v8, a4, (int)v7, a6);
      }
      else
      {
        sub_805E6C9(a1, *(_DWORD *)(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805E6C9(a1, *(_DWORD *)(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(int **)(a2 + 24); i; i = (int *)i[13] )
    {
      if ( (*(_DWORD *)(a1 + 48) & sub_80CEFA0(*i)) != 0
        && !sub_805E553(a1 + 52, a1 + 64, (int)(i + 14), (int)(i + 17), *(float *)a1) )
      {
        sub_8053ED2((int)i, (int *)a1, (float *)(a1 + 52), (float *)(a1 + 64), *(_DWORD *)(a1 + 48));
      }
    }
  }
}

//----- (0805E97B) --------------------------------------------------------
void __cdecl sub_805E97B(int *a1, int *a2, int *a3, int a4)
{
  float v4; // [esp+20h] [ebp-68h]
  float v5; // [esp+24h] [ebp-64h]
  float v6; // [esp+28h] [ebp-60h]
  int s[13]; // [esp+30h] [ebp-58h] BYREF
  int v8[3]; // [esp+64h] [ebp-24h] BYREF
  int v9[6]; // [esp+70h] [ebp-18h] BYREF

  memset(s, 0, 0x30u);
  s[0] = *a1;
  s[12] = a4;
  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v9[0] = *a3;
  v9[1] = a3[1];
  v9[2] = a3[2];
  sub_805E6C9((int)s, (int)&dword_8330848, 0.0, s[0], (int)v8, (int)v9);
  if ( *(float *)a1 > (long double)*(float *)s )
  {
    v4 = *(float *)a3 - *(float *)a2;
    v5 = *((float *)a3 + 1) - *((float *)a2 + 1);
    v6 = *((float *)a3 + 2) - *((float *)a2 + 2);
    *(float *)&s[1] = v4 * *(float *)s + *(float *)a2;
    *(float *)&s[2] = v5 * *(float *)s + *((float *)a2 + 1);
    *(float *)&s[3] = v6 * *(float *)s + *((float *)a2 + 2);
    qmemcpy(a1, s, 0x30u);
  }
}
// 8330848: using guessed type int dword_8330848;

//----- (0805EAB1) --------------------------------------------------------
void __cdecl sub_805EAB1(int a1, int a2, float a3, int a4, int a5, int a6)
{
  float v6; // [esp+34h] [ebp-44h]
  float v7; // [esp+34h] [ebp-44h]
  float v8; // [esp+38h] [ebp-40h]
  int i; // [esp+3Ch] [ebp-3Ch]
  int v10; // [esp+40h] [ebp-38h] BYREF
  float v11; // [esp+44h] [ebp-34h]
  float v12; // [esp+48h] [ebp-30h]
  float v13; // [esp+58h] [ebp-20h]
  int v14; // [esp+5Ch] [ebp-1Ch]
  float v15; // [esp+60h] [ebp-18h]
  float v16; // [esp+64h] [ebp-14h]
  float v17; // [esp+68h] [ebp-10h]
  float v18; // [esp+6Ch] [ebp-Ch]

  if ( a3 < (long double)*(float *)(a1 + 60) && (*(_DWORD *)(a2 + 12) & *(_DWORD *)(a1 + 116)) != 0 )
  {
    v18 = *(float *)(a5 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    v17 = *(float *)(a6 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    v8 = *(float *)(a1 + 4 * *(_DWORD *)a2 + 24);
    if ( v18 < (long double)v8 || v17 < (long double)v8 )
    {
      if ( -v8 < (long double)v18 || -v8 < (long double)v17 )
      {
        if ( v17 <= (long double)v18 )
        {
          if ( v18 <= (long double)v17 )
          {
            v14 = 0;
            v16 = 1.0;
            v15 = 0.0;
          }
          else
          {
            v7 = 1.0 / (v18 - v17);
            v14 = 0;
            v15 = (v18 - v8) * v7;
            v16 = (v18 + v8) * v7;
          }
        }
        else
        {
          v6 = 1.0 / (v18 - v17);
          v14 = 1;
          v15 = (v18 + v8) * v6;
          v16 = (v18 - v8) * v6;
        }
        if ( v16 > 1.0 )
          v16 = 1.0;
        v13 = (*(float *)&a4 - a3) * v16 + a3;
        *(float *)&v10 = (*(float *)a6 - *(float *)a5) * v16 + *(float *)a5;
        v11 = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v16 + *(float *)(a5 + 4);
        v12 = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v16 + *(float *)(a5 + 8);
        sub_805EAB1(a1, *(_DWORD *)(a2 + 4 * v14 + 32), a3, SLODWORD(v13), a5, (int)&v10);
        if ( v15 < 0.0 )
          v15 = 0.0;
        v13 = (*(float *)&a4 - a3) * v15 + a3;
        *(float *)&v10 = (*(float *)a6 - *(float *)a5) * v15 + *(float *)a5;
        v11 = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v15 + *(float *)(a5 + 4);
        v12 = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v15 + *(float *)(a5 + 8);
        sub_805EAB1(a1, *(_DWORD *)(a2 + 4 * (1 - v14) + 32), v13, a4, (int)&v10, a6);
      }
      else
      {
        sub_805EAB1(a1, *(_DWORD *)(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805EAB1(a1, *(_DWORD *)(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(_DWORD *)(a2 + 20); i; i = *(_DWORD *)(i + 4) )
      sub_809959C(a1, i);
  }
}

//----- (0805EE11) --------------------------------------------------------
void __cdecl sub_805EE11(int a1)
{
  sub_805EAB1(a1, (int)&dword_8330848, 0.0, *(_DWORD *)(a1 + 60), a1 + 36, a1 + 48);
}
// 8330848: using guessed type int dword_8330848;

//----- (0805EE52) --------------------------------------------------------
int __cdecl sub_805EE52(int *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+40h] [ebp-48h]
  int v9; // [esp+40h] [ebp-48h]
  int v10; // [esp+40h] [ebp-48h]
  int v11; // [esp+40h] [ebp-48h]
  int v12; // [esp+40h] [ebp-48h]
  float v13; // [esp+44h] [ebp-44h]
  float v14; // [esp+44h] [ebp-44h]
  float v15; // [esp+48h] [ebp-40h]
  int i; // [esp+4Ch] [ebp-3Ch]
  float v17; // [esp+50h] [ebp-38h] BYREF
  float v18; // [esp+54h] [ebp-34h]
  float v19; // [esp+58h] [ebp-30h]
  float v20; // [esp+68h] [ebp-20h]
  int v21; // [esp+6Ch] [ebp-1Ch]
  float v22; // [esp+70h] [ebp-18h]
  float v23; // [esp+74h] [ebp-14h]
  float v24; // [esp+78h] [ebp-10h]
  float v25; // [esp+7Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a2 + 12) & a1[19]) == 0 )
    return 0;
  v25 = a5[*(_DWORD *)a2] - *(float *)(a2 + 16);
  v24 = a6[*(_DWORD *)a2] - *(float *)(a2 + 16);
  v15 = *(float *)&a1[*(_DWORD *)a2 + 6];
  if ( v25 < (long double)v15 || v24 < (long double)v15 )
  {
    if ( -v15 < (long double)v25 || -v15 < (long double)v24 )
    {
      if ( v24 <= (long double)v25 )
      {
        if ( v25 <= (long double)v24 )
        {
          v21 = 0;
          v23 = 1.0;
          v22 = 0.0;
        }
        else
        {
          v14 = 1.0 / (v25 - v24);
          v21 = 0;
          v22 = (v25 - v15) * v14;
          v23 = (v25 + v15) * v14;
        }
      }
      else
      {
        v13 = 1.0 / (v25 - v24);
        v21 = 1;
        v22 = (v25 + v15) * v13;
        v23 = (v25 - v15) * v13;
      }
      if ( v23 > 1.0 )
        v23 = 1.0;
      v20 = (a4 - a3) * v23 + a3;
      v17 = (*a6 - *a5) * v23 + *a5;
      v18 = (a6[1] - a5[1]) * v23 + a5[1];
      v19 = (a6[2] - a5[2]) * v23 + a5[2];
      v10 = sub_805EE52(a1, *(_DWORD *)(a2 + 4 * v21 + 32), LODWORD(a3), LODWORD(v20), a5, &v17);
      if ( v10 )
        return v10;
      if ( v22 < 0.0 )
        v22 = 0.0;
      v20 = (a4 - a3) * v22 + a3;
      v17 = (*a6 - *a5) * v22 + *a5;
      v18 = (a6[1] - a5[1]) * v22 + a5[1];
      v19 = (a6[2] - a5[2]) * v22 + a5[2];
      v11 = sub_805EE52(a1, *(_DWORD *)(a2 + 4 * (1 - v21) + 32), LODWORD(v20), LODWORD(a4), &v17, a6);
      if ( v11 )
        return v11;
    }
    else
    {
      v9 = sub_805EE52(a1, *(_DWORD *)(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6);
      if ( v9 )
        return v9;
    }
  }
  else
  {
    v8 = sub_805EE52(a1, *(_DWORD *)(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6);
    if ( v8 )
      return v8;
  }
  for ( i = *(_DWORD *)(a2 + 20); i; i = *(_DWORD *)(i + 4) )
  {
    v12 = sub_8099C75(a1, i);
    if ( v12 )
      return v12;
  }
  return 0;
}

//----- (0805F20E) --------------------------------------------------------
int __cdecl sub_805F20E(int a1)
{
  return sub_805EE52((int *)a1, (int)&dword_8330848, 0.0, 1.0, (float *)(a1 + 36), (float *)(a1 + 48));
}
// 8330848: using guessed type int dword_8330848;

//----- (0805F253) --------------------------------------------------------
void __cdecl sub_805F253(int a1, int a2, float a3, int a4, int a5, int a6)
{
  int i; // [esp+2Ch] [ebp-3Ch]
  int v7[7]; // [esp+30h] [ebp-38h] BYREF
  float v8; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h]
  float v11; // [esp+58h] [ebp-10h]
  float v12; // [esp+5Ch] [ebp-Ch]

  if ( a3 < (long double)*(float *)(a1 + 24) && (*(_DWORD *)(a2 + 12) & *(_DWORD *)(a1 + 80)) != 0 )
  {
    v12 = *(float *)(a5 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    v11 = *(float *)(a6 + 4 * *(_DWORD *)a2) - *(float *)(a2 + 16);
    if ( v12 < 0.0 || v11 < 0.0 )
    {
      if ( v12 > 0.0 || v11 > 0.0 )
      {
        v10 = v12 / (v12 - v11);
        v8 = (*(float *)&a4 - a3) * v10 + a3;
        *(float *)v7 = (*(float *)a6 - *(float *)a5) * v10 + *(float *)a5;
        *(float *)&v7[1] = (*(float *)(a6 + 4) - *(float *)(a5 + 4)) * v10 + *(float *)(a5 + 4);
        *(float *)&v7[2] = (*(float *)(a6 + 8) - *(float *)(a5 + 8)) * v10 + *(float *)(a5 + 8);
        v9 = v12 < 0.0;
        sub_805F253(a1, *(_DWORD *)(a2 + 4 * v9 + 32), a3, SLODWORD(v8), a5, (int)v7);
        sub_805F253(a1, *(_DWORD *)(a2 + 4 * (1 - v9) + 32), v8, a4, (int)v7, a6);
      }
      else
      {
        sub_805F253(a1, *(_DWORD *)(a2 + 36), a3, a4, a5, a6);
      }
    }
    else
    {
      sub_805F253(a1, *(_DWORD *)(a2 + 32), a3, a4, a5, a6);
    }
    for ( i = *(_DWORD *)(a2 + 20); i; i = *(_DWORD *)(i + 4) )
      sub_8099732(a1, i);
  }
}

//----- (0805F48A) --------------------------------------------------------
void __cdecl sub_805F48A(int a1)
{
  sub_805F253(a1, (int)&dword_8330848, 0.0, *(_DWORD *)(a1 + 24), a1, a1 + 12);
}
// 8330848: using guessed type int dword_8330848;

//----- (0805F4C8) --------------------------------------------------------
int __cdecl sub_805F4C8(_DWORD *a1, int a2, float a3, float a4, float *a5, float *a6)
{
  int v8; // [esp+28h] [ebp-40h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+28h] [ebp-40h]
  int v11; // [esp+28h] [ebp-40h]
  int v12; // [esp+28h] [ebp-40h]
  int i; // [esp+2Ch] [ebp-3Ch]
  float v14[7]; // [esp+30h] [ebp-38h] BYREF
  float v15; // [esp+4Ch] [ebp-1Ch]
  _BOOL4 v16; // [esp+50h] [ebp-18h]
  float v17; // [esp+54h] [ebp-14h]
  float v18; // [esp+58h] [ebp-10h]
  float v19; // [esp+5Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a2 + 12) & a1[10]) == 0 )
    return 0;
  v19 = a5[*(_DWORD *)a2] - *(float *)(a2 + 16);
  v18 = a6[*(_DWORD *)a2] - *(float *)(a2 + 16);
  if ( v19 < 0.0 || v18 < 0.0 )
  {
    if ( v19 > 0.0 || v18 > 0.0 )
    {
      v17 = v19 / (v19 - v18);
      v15 = (a4 - a3) * v17 + a3;
      v14[0] = (*a6 - *a5) * v17 + *a5;
      v14[1] = (a6[1] - a5[1]) * v17 + a5[1];
      v14[2] = (a6[2] - a5[2]) * v17 + a5[2];
      v16 = v19 < 0.0;
      v10 = sub_805F4C8(a1, *(_DWORD *)(a2 + 4 * v16 + 32), LODWORD(a3), LODWORD(v15), a5, v14);
      if ( v10 )
        return v10;
      v11 = sub_805F4C8(a1, *(_DWORD *)(a2 + 4 * (1 - v16) + 32), LODWORD(v15), LODWORD(a4), v14, a6);
      if ( v11 )
        return v11;
    }
    else
    {
      v9 = sub_805F4C8(a1, *(_DWORD *)(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6);
      if ( v9 )
        return v9;
    }
  }
  else
  {
    v8 = sub_805F4C8(a1, *(_DWORD *)(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6);
    if ( v8 )
      return v8;
  }
  for ( i = *(_DWORD *)(a2 + 20); i; i = *(_DWORD *)(i + 4) )
  {
    v12 = sub_8099E26(a1, i);
    if ( v12 )
      return v12;
  }
  return 0;
}

//----- (0805F758) --------------------------------------------------------
int __cdecl sub_805F758(int a1)
{
  return sub_805F4C8((_DWORD *)a1, (int)&dword_8330848, 0.0, 1.0, (float *)a1, (float *)(a1 + 12));
}
// 8330848: using guessed type int dword_8330848;

//----- (0805F79A) --------------------------------------------------------
int __cdecl sub_805F79A(int a1, int a2, float a3, float a4, float *a5, float *a6)
{
  float v8[15]; // [esp+30h] [ebp-78h] BYREF
  int *i; // [esp+6Ch] [ebp-3Ch]
  float v10[7]; // [esp+70h] [ebp-38h] BYREF
  float v11; // [esp+8Ch] [ebp-1Ch]
  _BOOL4 v12; // [esp+90h] [ebp-18h]
  float v13; // [esp+94h] [ebp-14h]
  float v14; // [esp+98h] [ebp-10h]
  float v15; // [esp+9Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a2 + 8) & *(_DWORD *)a1) == 0 )
    return 1;
  v15 = a5[*(_DWORD *)a2] - *(float *)(a2 + 16);
  v14 = a6[*(_DWORD *)a2] - *(float *)(a2 + 16);
  if ( v15 < 0.0 || v14 < 0.0 )
  {
    if ( v15 > 0.0 || v14 > 0.0 )
    {
      v13 = v15 / (v15 - v14);
      v11 = (a4 - a3) * v13 + a3;
      v10[0] = (*a6 - *a5) * v13 + *a5;
      v10[1] = (a6[1] - a5[1]) * v13 + a5[1];
      v10[2] = (a6[2] - a5[2]) * v13 + a5[2];
      v12 = v15 < 0.0;
      if ( !sub_805F79A(a1, *(_DWORD *)(a2 + 4 * v12 + 32), LODWORD(a3), LODWORD(v11), a5, v10) )
        return 0;
      if ( !sub_805F79A(a1, *(_DWORD *)(a2 + 4 * (1 - v12) + 32), LODWORD(v11), LODWORD(a4), v10, a6) )
        return 0;
    }
    else if ( !sub_805F79A(a1, *(_DWORD *)(a2 + 36), LODWORD(a3), LODWORD(a4), a5, a6) )
    {
      return 0;
    }
  }
  else if ( !sub_805F79A(a1, *(_DWORD *)(a2 + 32), LODWORD(a3), LODWORD(a4), a5, a6) )
  {
    return 0;
  }
  v8[0] = 1.0;
  for ( i = *(int **)(a2 + 24); i; i = (int *)i[13] )
  {
    if ( i[20] )
    {
      if ( (*(_DWORD *)a1 & sub_80CEFA0(*i)) != 0 && !sub_805E553(a1 + 4, a1 + 16, (int)(i + 14), (int)(i + 17), 1.0) )
      {
        sub_8053ED2((int)i, (int *)v8, (float *)(a1 + 4), (float *)(a1 + 16), *(_DWORD *)a1);
        if ( v8[0] != 1.0 )
          return 0;
      }
    }
  }
  return 1;
}

//----- (0805FB6C) --------------------------------------------------------
int sub_805FB6C()
{
  int result; // eax
  char *v1; // eax

  result = Cmd_Argc();
  if ( result == 2 )
  {
    v1 = Cmd_Argv(1u);
    result = atoi(v1);
    dword_834A8C0 = result;
  }
  else
  {
    dword_834A8C0 = 1;
  }
  return result;
}
// 805FB6C: using guessed type int sub_805FB6C();
// 834A8C0: using guessed type int dword_834A8C0;

//----- (0805FBA3) --------------------------------------------------------
void Cbuf_Init()
{
  dest = &unk_833A8C0;
  dword_834A8C8 = 0x10000;
  n = 0;
}
// 834A8C8: using guessed type int dword_834A8C8;

//----- (0805FBC6) --------------------------------------------------------
int __cdecl Cbuf_AddText(char *s)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  int n; // [esp+14h] [ebp-4h]

  n = strlen(s);
  if ( (int)(::n + n) >= dword_834A8C8 )
    return Com_Printf("Cbuf_AddText: overflow\n", v2);
  memcpy((char *)dest + ::n, s, n);
  result = n;
  ::n += n;
  return result;
}
// 805FBF2: variable 'v2' is possibly undefined
// 834A8C8: using guessed type int dword_834A8C8;

//----- (0805FC25) --------------------------------------------------------
int __cdecl Cbuf_InsertText(char *s)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  signed int i; // [esp+10h] [ebp-8h]
  size_t v4; // [esp+14h] [ebp-4h]

  v4 = strlen(s) + 1;
  if ( (int)(v4 + n) > dword_834A8C8 )
    return Com_Printf("Cbuf_InsertText overflowed\n", v2);
  for ( i = n - 1; i >= 0; --i )
    *((_BYTE *)dest + i + v4) = *((_BYTE *)dest + i);
  memcpy(dest, s, v4 - 1);
  *((char *)dest + v4 - 1) = 10;
  result = v4;
  n += v4;
  return result;
}
// 805FC51: variable 'v2' is possibly undefined
// 834A8C8: using guessed type int dword_834A8C8;

//----- (0805FCC0) --------------------------------------------------------
void __cdecl Cbuf_ExecuteText(int a1, char *s)
{
  if ( a1 == 1 )
  {
    Cbuf_InsertText(s);
  }
  else if ( a1 > 1 )
  {
    if ( a1 != 2 )
LABEL_13:
      Com_Error(0, (char *)&byte_80D72E0);
    Cbuf_AddText(s);
  }
  else
  {
    if ( a1 )
      goto LABEL_13;
    if ( s && *s )
      Cmd_ExecuteString(s);
    else
      Cbuf_Execute();
  }
}

//----- (0805FD3A) --------------------------------------------------------
void Cbuf_Execute()
{
  char v0; // [esp+1Ch] [ebp-101Ch]
  char dest[4104]; // [esp+20h] [ebp-1018h] BYREF
  void *src; // [esp+1028h] [ebp-10h]
  size_t n; // [esp+102Ch] [ebp-Ch]

  while ( ::n )
  {
    if ( dword_834A8C0 )
    {
      --dword_834A8C0;
      return;
    }
    src = ::dest;
    v0 = 0;
    for ( n = 0; (int)n < (int)::n; ++n )
    {
      if ( *((_BYTE *)src + n) == 34 )
        ++v0;
      if ( (v0 & 1) == 0 && *((_BYTE *)src + n) == 59 || *((_BYTE *)src + n) == 10 || *((_BYTE *)src + n) == 13 )
        break;
    }
    if ( (int)n > 4094 )
      n = 4095;
    memcpy(dest, src, n);
    dest[n] = 0;
    if ( n == ::n )
    {
      ::n = 0;
    }
    else
    {
      ::n -= ++n;
      memmove(src, (char *)src + n, ::n);
    }
    Cmd_ExecuteString(dest);
  }
}
// 834A8C0: using guessed type int dword_834A8C0;

//----- (0805FE66) --------------------------------------------------------
int sub_805FE66()
{
  int result; // eax
  char *v1; // eax
  char v2; // al
  char v3; // al
  int v4; // eax
  char *v5; // eax
  char v6; // [esp+4h] [ebp-74h]
  size_t v7; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  void *src; // [esp+6Ch] [ebp-Ch] BYREF

  if ( Cmd_Argc() != 2 )
    return Com_Printf("exec <filename> : execute a script file\n", v6);
  v1 = Cmd_Argv(1u);
  Q_strncpyz(dest, v1, 64);
  sub_8085892(dest, 0x40u, (int)".cfg");
  v7 = FS_ReadFile(dest, (int)&src);
  if ( src )
  {
    v3 = (unsigned __int8)Cmd_Argv(1u);
    Com_Printf("execing %s\n", v3);
    if ( sub_807344B((int)"sv_console_lockout") )
    {
      v4 = sub_807F851(src, v7);
      v5 = va("say Server exec: %s, size: %i, checksum: %i", dest, v7, v4);
      Cbuf_InsertText(v5);
    }
    Cbuf_InsertText((char *)src);
    result = FS_FreeFile(src);
  }
  else
  {
    v2 = (unsigned __int8)Cmd_Argv(1u);
    result = Com_Printf("couldn't exec %s\n", v2);
  }
  return result;
}
// 805FE7D: variable 'v6' is possibly undefined
// 805FE66: using guessed type int sub_805FE66();

//----- (0805FF7A) --------------------------------------------------------
int sub_805FF7A()
{
  int result; // eax
  char *v1; // eax
  char v2; // al
  char v3; // [esp+4h] [ebp-74h]
  size_t v4; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  void *src; // [esp+6Ch] [ebp-Ch] BYREF

  if ( Cmd_Argc() != 2 )
    return Com_Printf("showchecksum <filename> : prints size and checksum of a file\n", v3);
  v1 = Cmd_Argv(1u);
  Q_strncpyz(dest, v1, 64);
  sub_8085892(dest, 0x40u, (int)".cfg");
  v4 = FS_ReadFile(dest, (int)&src);
  if ( src )
  {
    sub_807F851(src, v4);
    Com_Printf("ShowChecksum: %s, size: %i, checksum: %i", (char)dest);
    result = FS_FreeFile(src);
  }
  else
  {
    v2 = (unsigned __int8)Cmd_Argv(1u);
    result = Com_Printf("couldn't find %s\n", v2);
  }
  return result;
}
// 805FF91: variable 'v3' is possibly undefined
// 805FF7A: using guessed type int sub_805FF7A();

//----- (0806004F) --------------------------------------------------------
int Cmd_Vstr_f()
{
  char *v1; // eax
  char *v2; // eax
  char v3; // [esp+4h] [ebp-14h]
  const char *v4; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() != 2 )
    return Com_Printf("vstr <variablename> : execute a variable command\n", v3);
  v1 = Cmd_Argv(1u);
  v4 = (const char *)Cvar_VariableString((int)v1);
  v2 = va("%s\n", v4);
  return Cbuf_InsertText(v2);
}
// 8060066: variable 'v3' is possibly undefined
// 806004F: using guessed type int Cmd_Vstr_f();

//----- (080600A1) --------------------------------------------------------
int sub_80600A1()
{
  char v0; // al
  char v2; // [esp+4h] [ebp-14h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; i < Cmd_Argc(); ++i )
  {
    v0 = (unsigned __int8)Cmd_Argv(i);
    Com_Printf("%s ", v0);
  }
  return Com_Printf("\n", v2);
}
// 80600E3: variable 'v2' is possibly undefined
// 80600A1: using guessed type int sub_80600A1();

//----- (080600EA) --------------------------------------------------------
int Cmd_Argc()
{
  return dword_810A5C0;
}
// 810A5C0: using guessed type int dword_810A5C0;

//----- (080600F4) --------------------------------------------------------
char *__cdecl Cmd_Argv(unsigned int a1)
{
  char *v2; // [esp+0h] [ebp-4h]

  if ( a1 < dword_810A5C0 )
    v2 = (&src)[a1];
  else
    v2 = (char *)&unk_80D749C;
  return v2;
}
// 810A5C0: using guessed type int dword_810A5C0;

//----- (08060120) --------------------------------------------------------
char *__cdecl sub_8060120(int a1, char *dest, int a3)
{
  char *v3; // eax

  v3 = Cmd_Argv(a1);
  return Q_strncpyz(dest, v3, a3);
}

//----- (0806014B) --------------------------------------------------------
char *__cdecl sub_806014B(int a1)
{
  byte_810D000 = 0;
  while ( a1 < dword_810A5C0 )
  {
    strcat(&byte_810D000, (&src)[a1]);
    if ( a1 != dword_810A5C0 - 1 )
      strcat(&byte_810D000, " ");
    ++a1;
  }
  return &byte_810D000;
}
// 810A5C0: using guessed type int dword_810A5C0;

//----- (080601DC) --------------------------------------------------------
char **__cdecl sub_80601DC(char **a1, int a2)
{
  char **result; // eax
  char *v3; // [esp+0h] [ebp-8h] BYREF
  char *v4; // [esp+4h] [ebp-4h] BYREF

  dword_810A5C0 = 0;
  if ( a1 )
  {
    result = a1;
    v4 = (char *)a1;
    v3 = (char *)&unk_810ADE0;
LABEL_3:
    if ( dword_810A5C0 != 512 )
    {
      if ( --a2 )
      {
        while ( 1 )
        {
          while ( *v4 && *v4 <= 32 )
            ++v4;
          result = (char **)v4;
          if ( !*v4 )
            break;
          if ( *v4 == 47 )
          {
            result = (char **)(v4 + 1);
            if ( v4[1] == 47 )
              break;
          }
          if ( *v4 != 47 || v4[1] != 42 )
          {
            if ( *v4 == 34 )
            {
              (&src)[dword_810A5C0++] = v3;
              ++v4;
              while ( *v4 && *v4 != 34 )
                *v3++ = *v4++;
              *v3++ = 0;
              result = (char **)v4;
              if ( !*v4 )
                return result;
              result = (char **)++v4;
              if ( !*v4 )
                return result;
              result = (char **)v4;
              if ( *v4 <= 32 )
              {
                result = &v4;
                ++v4;
              }
            }
            else
            {
              (&src)[dword_810A5C0++] = v3;
              while ( *v4 > 32 && *v4 != 34 && (*v4 != 47 || v4[1] != 47) && (*v4 != 47 || v4[1] != 42) )
                *v3++ = *v4++;
              *v3++ = 0;
              result = (char **)v4;
              if ( !*v4 )
                return result;
              result = (char **)v4;
              if ( *v4 <= 32 )
              {
                result = &v4;
                ++v4;
              }
            }
            goto LABEL_3;
          }
          while ( *v4 && (*v4 != 42 || v4[1] != 47) )
            ++v4;
          result = (char **)v4;
          if ( !*v4 )
            return result;
          v4 += 2;
        }
      }
      else
      {
        result = (char **)v4;
        if ( *v4 )
        {
          (&src)[dword_810A5C0++] = v3;
          while ( *v4 )
            *v3++ = *v4++;
          *v3 = 0;
          result = &v3;
          ++v3;
        }
      }
    }
  }
  return result;
}
// 806041C: returning address of temporary local variable '%var_8'
// 810A5C0: using guessed type int dword_810A5C0;

//----- (08060423) --------------------------------------------------------
char **__cdecl Cmd_TokenizeString(char **a1)
{
  return sub_80601DC(a1, 0);
}

//----- (0806043E) --------------------------------------------------------
_DWORD *__cdecl sub_806043E(char *s1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // ebx
  int i; // [esp+10h] [ebp-8h]

  for ( i = dword_810CFE0; ; i = *(_DWORD *)i )
  {
    if ( !i )
    {
      v3 = Z_MallocInternal(0xCu);
      v3[1] = sub_806BC0A(s1);
      v3[2] = a2;
      *v3 = dword_810CFE0;
      result = v3;
      dword_810CFE0 = (int)v3;
      return result;
    }
    result = (_DWORD *)strcmp(s1, *(const char **)(i + 4));
    if ( !result )
      break;
  }
  if ( a2 )
    result = (_DWORD *)Com_Printf("Cmd_AddCommand: %s already defined\n", (char)s1);
  return result;
}
// 810CFE0: using guessed type int dword_810CFE0;

//----- (080604D4) --------------------------------------------------------
int __cdecl sub_80604D4(char *s1)
{
  int result; // eax
  int *i; // [esp+10h] [ebp-8h]
  const char **ptr; // [esp+14h] [ebp-4h]

  for ( i = &dword_810CFE0; ; i = (int *)ptr )
  {
    result = *i;
    ptr = (const char **)*i;
    if ( !*i )
      break;
    if ( !strcmp(s1, ptr[1]) )
    {
      *i = (int)*ptr;
      if ( ptr[1] )
        Z_FreeInternal((void *)ptr[1]);
      return Z_FreeInternal(ptr);
    }
  }
  return result;
}
// 810CFE0: using guessed type int dword_810CFE0;

//----- (08060542) --------------------------------------------------------
int sub_8060542()
{
  int result; // eax
  void **ptr; // [esp+4h] [ebp-4h]

  while ( dword_810CFE0 )
  {
    ptr = (void **)dword_810CFE0;
    dword_810CFE0 = *(_DWORD *)dword_810CFE0;
    Z_FreeInternal(ptr[1]);
    result = Z_FreeInternal(ptr);
  }
  return result;
}
// 810CFE0: using guessed type int dword_810CFE0;

//----- (08060585) --------------------------------------------------------
int __cdecl sub_8060585(void (__cdecl *a1)(int))
{
  int result; // eax
  int *i; // [esp+4h] [ebp-4h]

  result = dword_810CFE0;
  for ( i = (int *)dword_810CFE0; i; i = (int *)*i )
  {
    a1(i[1]);
    result = *i;
  }
  return result;
}
// 810CFE0: using guessed type int dword_810CFE0;

//----- (080605B5) --------------------------------------------------------
void __cdecl Cmd_ExecuteString(char *s)
{
  size_t v1; // eax
  int *i; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  Cmd_TokenizeString((char **)s);
  if ( Cmd_Argc() )
  {
    for ( i = &dword_810CFE0; *i; i = (int *)v3 )
    {
      v3 = *i;
      if ( !Q_stricmp(src, *(char **)(*i + 4)) )
      {
        *i = *(_DWORD *)v3;
        *(_DWORD *)v3 = dword_810CFE0;
        dword_810CFE0 = v3;
        if ( *(_DWORD *)(v3 + 8) )
        {
          (*(void (**)(void))(v3 + 8))();
          return;
        }
        break;
      }
    }
    if ( Q_stricmpn(s, "pb_", 3) )
    {
      if ( !sub_8073582()
        && (!dword_8360658 || !*(_DWORD *)(dword_8360658 + 32) || !sub_80846C2())
        && (!dword_8360560 || !*(_DWORD *)(dword_8360560 + 32) || !sub_808FF1F())
        && (!dword_8360658 || !*(_DWORD *)(dword_8360658 + 32) || !sub_80846D1()) )
      {
        sub_80846DB();
      }
    }
    else if ( !Q_stricmpn(s + 3, "sv_", 3) )
    {
      v1 = strlen(s);
      PbSvAddEvent(14, -1, v1 + 1, (int)s);
    }
  }
}
// 810CFE0: using guessed type int dword_810CFE0;
// 8360560: using guessed type int dword_8360560;
// 8360658: using guessed type int dword_8360658;

//----- (0806072D) --------------------------------------------------------
int sub_806072D()
{
  char *v1; // [esp+Ch] [ebp-Ch]
  char v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v1 = 0;
  else
    v1 = Cmd_Argv(1u);
  v2 = 0;
  for ( i = dword_810CFE0; i; i = *(_DWORD *)i )
  {
    if ( !v1 || sub_806B69A((int)v1, *(char **)(i + 4), 0) )
    {
      Com_Printf("%s\n", *(_DWORD *)(i + 4));
      ++v2;
    }
  }
  return Com_Printf("%i commands\n", v2);
}
// 806072D: using guessed type int sub_806072D();
// 810CFE0: using guessed type int dword_810CFE0;

//----- (080607CF) --------------------------------------------------------
_DWORD *Cmd_Init()
{
  sub_806043E("cmdlist", (int)sub_806072D);
  sub_806043E("exec", (int)sub_805FE66);
  sub_806043E("vstr", (int)Cmd_Vstr_f);
  sub_806043E("echo", (int)sub_80600A1);
  sub_806043E("wait", (int)sub_805FB6C);
  return sub_806043E("showchecksum", (int)sub_805FF7A);
}
// 805FB6C: using guessed type int sub_805FB6C();
// 805FE66: using guessed type int sub_805FE66();
// 805FF7A: using guessed type int sub_805FF7A();
// 806004F: using guessed type int Cmd_Vstr_f();
// 80600A1: using guessed type int sub_80600A1();
// 806072D: using guessed type int sub_806072D();

//----- (08060850) --------------------------------------------------------
_BOOL4 sub_8060850()
{
  return fs_searchpaths != 0;
}

//----- (08060862) --------------------------------------------------------
void sub_8060862()
{
  ;
}

//----- (08060867) --------------------------------------------------------
int __cdecl sub_8060867(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  if ( !dword_835B22C )
    return 1;
  for ( i = 0; i < dword_835B22C; ++i )
  {
    if ( *(_DWORD *)(a1 + 772) == dword_8357220[i] )
      return 1;
  }
  return 0;
}
// 835B22C: using guessed type int dword_835B22C;

//----- (080608C4) --------------------------------------------------------
int sub_80608C4()
{
  return dword_834E8E0;
}
// 834E8E0: using guessed type int dword_834E8E0;

//----- (080608CE) --------------------------------------------------------
_BOOL4 __cdecl sub_80608CE(int a1)
{
  return !*(_DWORD *)(a1 + 12) || !*(_DWORD *)(dword_834E8E4 + 32);
}
// 834E8E4: using guessed type int dword_834E8E4;

//----- (08060946) --------------------------------------------------------
int __cdecl sub_8060946(int a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
  {
    v3 = tolower(*(char *)(a1 + i));
    if ( v3 == 46 )
      break;
    if ( v3 == 92 )
      v3 = 47;
    if ( v3 == 47 )
      v3 = 47;
    v4 += v3 * (i + 119);
  }
  return (a2 - 1) & (v4 ^ (v4 >> 10) ^ (v4 >> 20));
}

//----- (080609D9) --------------------------------------------------------
int __cdecl sub_80609D9(int a1)
{
  int v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( a1 )
  {
    v3 = 51;
    v2 = 13;
  }
  else
  {
    v3 = 1;
    v2 = 50;
  }
  for ( i = 0; ; ++i )
  {
    if ( i >= v2 )
    {
      for ( j = 1; j <= 63; ++j )
        Com_Printf("FILE %2i: '%s'\n", j);
      Com_Error(1, (char *)&byte_80D7530);
    }
    if ( !dword_834E900[72 * i + 72 * v3] )
      break;
  }
  return v3 + i;
}
// 834E900: using guessed type int dword_834E900[];

//----- (08060AA0) --------------------------------------------------------
int __cdecl sub_8060AA0(int a1)
{
  return dword_834E900[72 * a1];
}
// 834E900: using guessed type int dword_834E900[];

//----- (08060AB8) --------------------------------------------------------
int __cdecl sub_8060AB8(int a1)
{
  FILE *stream; // [esp+14h] [ebp-4h]

  stream = (FILE *)sub_8060AA0(a1);
  return setvbuf(stream, 0, 2, 0);
}

//----- (08060AF1) --------------------------------------------------------
int __cdecl sub_8060AF1(int a1)
{
  FILE *stream; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int off; // [esp+24h] [ebp-4h]

  sub_8060862();
  if ( dword_834E918[72 * a1] )
    return *(_DWORD *)(dword_834E900[72 * a1] + 68);
  stream = (FILE *)sub_8060AA0(a1);
  off = ftell(stream);
  fseek(stream, 0, 2);
  v4 = ftell(stream);
  fseek(stream, off, 0);
  return v4;
}
// 834E900: using guessed type int dword_834E900[];
// 834E918: using guessed type int dword_834E918[];

//----- (08060B9F) --------------------------------------------------------
_BYTE *__cdecl sub_8060B9F(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 47 || *a1 == 92 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (08060BD6) --------------------------------------------------------
void *__cdecl sub_8060BD6(char *s, char *a2, char *a3, void *dest, int a5)
{
  void *result; // eax
  size_t v6; // [esp+Ch] [ebp-Ch]
  size_t v7; // [esp+10h] [ebp-8h]
  size_t n; // [esp+14h] [ebp-4h]

  if ( !a2 || !*a2 )
    a2 = byte_835F380;
  n = strlen(s);
  v7 = strlen(a2);
  v6 = strlen(a3);
  if ( (int)(v6 + n + v7 + 2) <= 255 )
  {
    memcpy(dest, s, n);
    *((_BYTE *)dest + n) = 47;
    memcpy((char *)dest + n + 1, a2, v7);
    *((_BYTE *)dest + n + v7 + 1) = 47;
    memcpy((char *)dest + n + v7 + 2, a3, v6 + 1);
    result = sub_8060B9F((_BYTE *)dest + n);
  }
  else
  {
    if ( !a5 )
      Com_Error(0, (char *)&byte_80D7560);
    result = dest;
    *(_BYTE *)dest = 0;
  }
  return result;
}

//----- (08060CD2) --------------------------------------------------------
void *__cdecl sub_8060CD2(char *s, char *a2, char *a3, void *dest)
{
  return sub_8060BD6(s, a2, a3, dest, 0);
}

//----- (08060D02) --------------------------------------------------------
int __cdecl sub_8060D02(char *haystack)
{
  int v2; // [esp+10h] [ebp-8h]
  char *i; // [esp+14h] [ebp-4h]

  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    Com_Printf("WARNING: refusing to create relative path \"%s\"\n", (char)haystack);
    v2 = 1;
  }
  else
  {
    for ( i = haystack + 1; *i; ++i )
    {
      if ( *i == 47 )
      {
        *i = 0;
        sub_80D56C3(haystack);
        *i = 47;
      }
    }
    v2 = 0;
  }
  return v2;
}

//----- (08060D97) --------------------------------------------------------
void __cdecl sub_8060D97(char *haystack, char *filename)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  if ( !strstr(haystack, "journal.dat") && !strstr(haystack, "journaldata.dat") )
  {
    stream = fopen(haystack, "rb");
    if ( stream )
    {
      fseek(stream, 0, 2);
      size = ftell(stream);
      fseek(stream, 0, 0);
      ptr = malloc(size);
      if ( fread(ptr, 1u, size, stream) != size )
        Com_Error(0, (char *)&byte_80D7600);
      fclose(stream);
      if ( sub_8060D02(filename) || (streama = fopen(filename, "wb")) == 0 )
      {
        free(ptr);
      }
      else
      {
        if ( fwrite(ptr, 1u, size, streama) != size )
          Com_Error(0, (char *)&byte_80D7640);
        fclose(streama);
        free(ptr);
      }
    }
  }
}

//----- (0806111C) --------------------------------------------------------
int __cdecl sub_806111C(char *filename)
{
  return remove(filename);
}

//----- (0806112F) --------------------------------------------------------
int __cdecl sub_806112F(char *a1)
{
  char filename[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, a1, filename);
  stream = fopen(filename, "rb");
  if ( !stream )
    return 0;
  fclose(stream);
  return 1;
}
// 835B230: using guessed type int dword_835B230;

//----- (080611A9) --------------------------------------------------------
int __cdecl sub_80611A9(char *a1, char *a2)
{
  int result; // eax
  char newa[256]; // [esp+10h] [ebp-208h] BYREF
  char old[264]; // [esp+110h] [ebp-108h] BYREF

  sub_8060862();
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, a1, old);
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, a2, newa);
  if ( *(_DWORD *)(dword_835B240 + 32) )
    Com_Printf("FS_Rename: %s --> %s\n", (char)old);
  result = rename(old, newa);
  if ( result )
  {
    sub_806111C(newa);
    result = rename(old, newa);
    if ( result )
    {
      sub_8060D97(old, newa);
      result = sub_806111C(old);
    }
  }
  return result;
}
// 835B230: using guessed type int dword_835B230;
// 835B240: using guessed type int dword_835B240;

//----- (080612A2) --------------------------------------------------------
void *__cdecl FS_FCloseFile(int a1)
{
  sub_8060862();
  if ( dword_834E91C[72 * a1] )
    sub_80D4049();
  if ( dword_834E918[72 * a1] )
  {
    sub_80C0539(dword_834E900[72 * a1]);
    if ( dword_834E904[72 * a1] )
      sub_80BF21F(dword_834E900[72 * a1]);
  }
  else if ( dword_834E900[72 * a1] )
  {
    fclose((FILE *)dword_834E900[72 * a1]);
  }
  return sub_80D2FE9(&dword_834E900[72 * a1], 0, 0x120u);
}
// 834E900: using guessed type int dword_834E900[];
// 834E904: using guessed type int dword_834E904[];
// 834E918: using guessed type int dword_834E918[];

//----- (080613C7) --------------------------------------------------------
int __cdecl sub_80613C7(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060862();
  v3 = sub_80609D9(0);
  dword_834E918[72 * v3] = 0;
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, src, filename);
  if ( *(_DWORD *)(dword_835B240 + 32) )
    Com_Printf("FS_FOpenFileWrite: %s\n", (char)filename);
  if ( sub_8060D02(filename) )
    return 0;
  dword_834E900[72 * v3] = (int)fopen(filename, "wb");
  Q_strncpyz((char *)(288 * v3 + 137685280), src, 256);
  dword_834E908[72 * v3] = 0;
  if ( !dword_834E900[72 * v3] )
    v3 = 0;
  return v3;
}
// 834E900: using guessed type int dword_834E900[];
// 834E908: using guessed type int dword_834E908[];
// 834E918: using guessed type int dword_834E918[];
// 835B230: using guessed type int dword_835B230;
// 835B240: using guessed type int dword_835B240;

//----- (08061529) --------------------------------------------------------
int __cdecl sub_8061529(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060862();
  v3 = sub_80609D9(0);
  dword_834E918[72 * v3] = 0;
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, src, filename);
  if ( *(_DWORD *)(dword_835B240 + 32) )
    Com_Printf("FS_FOpenFileWrite: %s\n", (char)filename);
  if ( sub_8060D02(filename) )
    return 0;
  dword_834E900[72 * v3] = (int)fopen(filename, "wt");
  Q_strncpyz((char *)(288 * v3 + 137685280), src, 256);
  dword_834E908[72 * v3] = 0;
  if ( !dword_834E900[72 * v3] )
    v3 = 0;
  return v3;
}
// 834E900: using guessed type int dword_834E900[];
// 834E908: using guessed type int dword_834E908[];
// 834E918: using guessed type int dword_834E918[];
// 835B230: using guessed type int dword_835B230;
// 835B240: using guessed type int dword_835B240;

//----- (0806168B) --------------------------------------------------------
int __cdecl sub_806168B(char *src)
{
  int v3; // [esp+1Ch] [ebp-10Ch]
  char filename[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060862();
  v3 = sub_80609D9(0);
  dword_834E918[72 * v3] = 0;
  Q_strncpyz((char *)(288 * v3 + 137685280), src, 256);
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, src, filename);
  if ( *(_DWORD *)(dword_835B240 + 32) )
    Com_Printf("FS_FOpenFileAppend: %s\n", (char)filename);
  if ( sub_8060D02(filename) )
    return 0;
  dword_834E900[72 * v3] = (int)fopen(filename, "ab");
  dword_834E908[72 * v3] = 0;
  if ( !dword_834E900[72 * v3] )
    v3 = 0;
  return v3;
}
// 834E900: using guessed type int dword_834E900[];
// 834E908: using guessed type int dword_834E908[];
// 834E918: using guessed type int dword_834E918[];
// 835B230: using guessed type int dword_835B230;
// 835B240: using guessed type int dword_835B240;

//----- (080617EA) --------------------------------------------------------
int __cdecl FS_FilenameCompare(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( sub_8085CC2(v5) )
      v5 -= 32;
    if ( sub_8085CC2(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 != v4 )
      return -1;
  }
  while ( v5 );
  return 0;
}

//----- (08061AE4) --------------------------------------------------------
char *__cdecl sub_8061AE4(char *haystack, int a2, char a3)
{
  int i; // [esp+1Ch] [ebp-10Ch]
  char needle[264]; // [esp+20h] [ebp-108h] BYREF

  for ( i = 0; *(_BYTE *)(a2 + i); ++i )
    needle[i] = *(_BYTE *)(i + a2) + a3;
  needle[i] = 0;
  return strstr(haystack, needle);
}

//----- (08061B58) --------------------------------------------------------
const char *__cdecl sub_8061B58(_BYTE *a1)
{
  const char *v2; // [esp+0h] [ebp-4h]

  v2 = &byte_80D7741;
  while ( *a1 )
  {
    if ( *a1 == 46 )
    {
      v2 = a1 + 1;
    }
    else if ( *a1 == 47 || *a1 == 92 )
    {
      v2 = &byte_80D7741;
    }
    ++a1;
  }
  return v2;
}

//----- (08061BA3) --------------------------------------------------------
_BOOL4 __cdecl sub_8061BA3(char *s1)
{
  if ( *s1 == 46 )
    ++s1;
  if ( !strcasecmp(s1, "cfg") )
    return 1;
  if ( !Q_stricmp(s1, "menu") )
    return 1;
  if ( Q_stricmp(s1, ".dm_NETWORK_PROTOCOL_VERSION") )
    return Q_stricmp(s1, "dat") == 0;
  return 1;
}

//----- (08061C40) --------------------------------------------------------
int __cdecl sub_8061C40(char *haystack, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  char v9[268]; // [esp+30h] [ebp-248h] BYREF
  char v10[4]; // [esp+13Ch] [ebp-13Ch]
  char *s1; // [esp+140h] [ebp-138h]
  size_t v12; // [esp+144h] [ebp-134h]
  FILE *stream; // [esp+148h] [ebp-130h]
  void *dest; // [esp+14Ch] [ebp-12Ch]
  int v15; // [esp+150h] [ebp-128h]
  char *s; // [esp+154h] [ebp-124h]
  int v17; // [esp+158h] [ebp-120h]
  char *v18; // [esp+15Ch] [ebp-11Ch]
  char filename[268]; // [esp+160h] [ebp-118h] BYREF
  void *i; // [esp+26Ch] [ebp-Ch]

  v15 = 0;
  sub_8060862();
  if ( !a2 )
  {
    for ( i = fs_searchpaths; ; i = *(void **)i )
    {
      if ( !i )
        return 0;
      if ( sub_80608CE((int)i) )
      {
        if ( *((_DWORD *)i + 1) )
          v15 = sub_8060946((int)haystack, *(_DWORD *)(*((_DWORD *)i + 1) + 788));
        if ( *((_DWORD *)i + 1) && *(_DWORD *)(*(_DWORD *)(*((_DWORD *)i + 1) + 792) + 4 * v15) )
        {
          v18 = (char *)*((_DWORD *)i + 1);
          v17 = *(_DWORD *)(*((_DWORD *)v18 + 198) + 4 * v15);
          while ( FS_FilenameCompare(*(char **)(v17 + 16), haystack) )
          {
            v17 = *(_DWORD *)(v17 + 20);
            if ( !v17 )
              goto LABEL_17;
          }
          return 1;
        }
        if ( *((_DWORD *)i + 2) )
        {
          s = (char *)*((_DWORD *)i + 2);
          sub_8060BD6(s, s + 256, haystack, filename, a4);
          stream = fopen(filename, "rb");
          if ( stream )
          {
            fclose(stream);
            return 1;
          }
        }
      }
LABEL_17:
      ;
    }
  }
  while ( *haystack == 47 || *haystack == 92 )
    ++haystack;
  if ( strstr(haystack, "..") || strstr(haystack, "::") )
  {
    *(_DWORD *)a2 = 0;
    return -1;
  }
  *(_DWORD *)a2 = sub_80609D9(a4);
  dword_834E904[72 * *(_DWORD *)a2] = a3;
  *(_DWORD *)v10 = 0;
  for ( i = fs_searchpaths; ; i = *(void **)i )
  {
    if ( !i )
    {
      if ( *(_DWORD *)(dword_835B240 + 32) && !a4 )
        Com_Printf("Can't find %s\n", (char)haystack);
      *(_DWORD *)a2 = 0;
      if ( *(_DWORD *)v10 )
      {
        v6 = va(aExeUnpureclien_0, *(_DWORD *)v10);
        Com_Error(1, v6);
      }
      return -1;
    }
    if ( sub_80608CE((int)i) )
      break;
LABEL_84:
    ;
  }
  v18 = (char *)*((_DWORD *)i + 1);
  if ( v18 )
    v15 = sub_8060946((int)haystack, *((_DWORD *)v18 + 197));
  if ( !v18 || !*(_DWORD *)(*((_DWORD *)v18 + 198) + 4 * v15) )
  {
    if ( *((_DWORD *)i + 2) )
    {
      if ( (s1 = (char *)sub_8061B58(haystack), !*(_DWORD *)(dword_835B23C + 32)) && !dword_835B22C
        || *((_DWORD *)i + 3)
        || sub_8061BA3(s1) )
      {
        s = (char *)*((_DWORD *)i + 2);
        sub_8060BD6(s, s + 256, haystack, filename, a4);
        v5 = 72 * *(_DWORD *)a2;
        dword_834E900[v5] = (int)fopen(filename, "rb");
        if ( dword_834E900[72 * *(_DWORD *)a2] )
        {
          if ( !*((_DWORD *)i + 3) && !sub_8061BA3(s1) )
            dword_835B238 = rand() + 1;
          Q_strncpyz((char *)(288 * *(_DWORD *)a2 + 137685280), haystack, 256);
          dword_834E918[72 * *(_DWORD *)a2] = 0;
          if ( *(_DWORD *)(dword_835B240 + 32) && !a4 )
            Com_Printf("FS_FOpenFileRead: %s (found in '%s/%s')\n", (char)haystack);
          if ( *(_DWORD *)(dword_835B224 + 32) && !Q_stricmp(s, *(char **)(dword_835B248 + 4)) )
          {
            sub_8060BD6(*(char **)(dword_8357200 + 4), s + 256, haystack, v9, a4);
            sub_8060D97(filename, v9);
          }
          return sub_8060AF1(*(_DWORD *)a2);
        }
      }
    }
    goto LABEL_84;
  }
  v17 = *(_DWORD *)(*((_DWORD *)v18 + 198) + 4 * v15);
  while ( FS_FilenameCompare(*(char **)(v17 + 16), haystack) )
  {
    v17 = *(_DWORD *)(v17 + 20);
    if ( !v17 )
      goto LABEL_84;
  }
  if ( !*((_DWORD *)i + 3) && !sub_8060867((int)v18) )
  {
    *(_DWORD *)v10 = v18;
    goto LABEL_84;
  }
  v12 = strlen(haystack);
  if ( !v18[784]
    && Q_stricmp(&haystack[v12 - 7], ".shader")
    && Q_stricmp(&haystack[v12 - 4], ".txt")
    && Q_stricmp(&haystack[v12 - 4], ".cfg")
    && Q_stricmp(&haystack[v12 - 7], ".config")
    && !strstr(haystack, "levelshots")
    && Q_stricmp(&haystack[v12 - 4], ".bot")
    && Q_stricmp(&haystack[v12 - 6], ".arena")
    && Q_stricmp(&haystack[v12 - 5], ".menu") )
  {
    v18[784] = 1;
  }
  if ( !v18[787] && sub_8061AE4(haystack, (int)"wgmgskesve~><4jrr", -6) )
    v18[787] = 1;
  if ( !v18[786] && sub_8061AE4(haystack, (int)"eicogaoraz:80fnn", -2) )
    v18[786] = 1;
  if ( !v18[785] && sub_8061AE4(haystack, (int)"zndrud}=;3iqq", -5) )
    v18[785] = 1;
  if ( a3 )
  {
    v4 = 72 * *(_DWORD *)a2;
    dword_834E900[v4] = (int)sub_80BEEC9(v18, *((void **)v18 + 192));
    if ( !dword_834E900[72 * *(_DWORD *)a2] )
    {
      if ( !a4 )
        Com_Error(0, (char *)&byte_80D77D4, v18);
      FS_FCloseFile(*(_DWORD *)a2);
      *(_DWORD *)a2 = 0;
      return -1;
    }
  }
  else
  {
    dword_834E900[72 * *(_DWORD *)a2] = *((_DWORD *)v18 + 192);
  }
  Q_strncpyz((char *)(288 * *(_DWORD *)a2 + 137685280), haystack, 256);
  dword_834E918[72 * *(_DWORD *)a2] = (int)v18;
  dest = (void *)dword_834E900[72 * *(_DWORD *)a2];
  stream = *(FILE **)dest;
  sub_80BFA06(*((_DWORD *)v18 + 192), *(_DWORD *)v17);
  sub_80D2FC8(dest, *((void **)v18 + 192), 0x80u);
  *(_DWORD *)dest = stream;
  sub_80BFE6F((_DWORD *)dword_834E900[72 * *(_DWORD *)a2]);
  dword_834E914[72 * *(_DWORD *)a2] = *(_DWORD *)v17;
  if ( *(_DWORD *)(dword_835B240 + 32) && !a4 )
    Com_Printf("FS_FOpenFileRead: %s (found in '%s')\n", (char)haystack);
  return *((_DWORD *)dest + 17);
}
// 834E900: using guessed type int dword_834E900[];
// 834E904: using guessed type int dword_834E904[];
// 834E914: using guessed type int dword_834E914[];
// 834E918: using guessed type int dword_834E918[];
// 8357200: using guessed type int dword_8357200;
// 835B224: using guessed type int dword_835B224;
// 835B22C: using guessed type int dword_835B22C;
// 835B238: using guessed type int dword_835B238;
// 835B23C: using guessed type int dword_835B23C;
// 835B240: using guessed type int dword_835B240;
// 835B248: using guessed type int dword_835B248;

//----- (08062665) --------------------------------------------------------
int __cdecl FS_FOpenFileRead(char *haystack, int a2, int a3)
{
  dword_835F360 = 1;
  return sub_8061C40(haystack, a2, a3, 0);
}
// 835F360: using guessed type int dword_835F360;

//----- (08062698) --------------------------------------------------------
int __cdecl sub_8062698(char *haystack)
{
  int v3; // [esp+14h] [ebp-4h] BYREF

  FS_FOpenFileRead(haystack, (int)&v3, 0);
  if ( !v3 )
    return 0;
  FS_FCloseFile(v3);
  return 1;
}

//----- (0806288F) --------------------------------------------------------
_BOOL4 __cdecl sub_806288F(char *a1, int a2)
{
  __mode_t v3; // [esp+18h] [ebp-180h]
  struct stat stat_buf; // [esp+20h] [ebp-178h] BYREF
  char file[264]; // [esp+90h] [ebp-108h] BYREF

  sub_8060862();
  sub_8060CD2(*(char **)(dword_835B230 + 4), byte_835F380, a1, file);
  if ( sub_80D61E8(file, &stat_buf) == -1 )
    return 0;
  if ( a2 )
    v3 = stat_buf.st_mode & 0xFFFFFEFF;
  else
    v3 = stat_buf.st_mode | 0x100;
  stat_buf.st_mode = v3;
  return chmod(file, v3) != -1;
}
// 835B230: using guessed type int dword_835B230;

//----- (08062960) --------------------------------------------------------
int __cdecl FS_Read(char *a1, size_t a2, int a3)
{
  int v5; // [esp+14h] [ebp-14h]
  char *ptr; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]
  size_t v8; // [esp+20h] [ebp-8h]

  sub_8060862();
  if ( !a3 )
    return 0;
  ptr = a1;
  if ( dword_834E918[72 * a3] )
    return sub_80C007B(dword_834E900[72 * a3], (int)a1, a2);
  v8 = a2;
  v5 = 0;
  while ( 1 )
  {
    if ( !v8 )
      return a2;
    v7 = fread(ptr, 1u, v8, (FILE *)dword_834E900[72 * a3]);
    if ( !v7 )
    {
      if ( v5 )
        return a2 - v8;
      v5 = 1;
    }
    if ( v7 == -1 )
      break;
    v8 -= v7;
    ptr += v7;
  }
  if ( a3 <= 50 || a3 > 63 )
    Com_Error(0, (char *)&byte_80D78A0);
  return -1;
}
// 834E900: using guessed type int dword_834E900[];
// 834E918: using guessed type int dword_834E918[];

//----- (08062A90) --------------------------------------------------------
size_t __cdecl FS_Write(char *a1, size_t a2, int a3)
{
  char v4; // [esp+4h] [ebp-34h]
  FILE *s; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  size_t v9; // [esp+2Ch] [ebp-Ch]
  size_t v10; // [esp+30h] [ebp-8h]

  sub_8060862();
  if ( !a3 )
    return 0;
  s = (FILE *)sub_8060AA0(a3);
  v10 = a2;
  v7 = 0;
  while ( v10 )
  {
    v9 = fwrite(a1, 1u, v10, s);
    if ( !v9 )
    {
      if ( v7 )
      {
        Com_Printf("FS_Write: 0 bytes written\n", v4);
        return 0;
      }
      v7 = 1;
    }
    if ( v9 == -1 )
    {
      Com_Printf("FS_Write: -1 bytes written\n", v4);
      return 0;
    }
    v10 -= v9;
    a1 += v9;
  }
  if ( dword_834E908[72 * a3] )
    fflush(s);
  return a2;
}
// 8062B1F: variable 'v4' is possibly undefined
// 834E908: using guessed type int dword_834E908[];

//----- (08062B8B) --------------------------------------------------------
size_t sub_8062B8B(int a1, char *format, ...)
{
  size_t v2; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  v2 = strlen(s);
  return FS_Write(s, v2, a1);
}

//----- (08062BE1) --------------------------------------------------------
int __cdecl sub_8062BE1(int a1, int off, int a3)
{
  int v4; // [esp+14h] [ebp-10024h]
  FILE *stream; // [esp+18h] [ebp-10020h]
  char v6[65536]; // [esp+20h] [ebp-10018h] BYREF
  int whence; // [esp+10020h] [ebp-18h]
  int v8; // [esp+10024h] [ebp-14h]
  int v9; // [esp+10028h] [ebp-10h]
  int v10; // [esp+1002Ch] [ebp-Ch]

  sub_8060862();
  if ( dword_834E91C[72 * a1] )
  {
    dword_834E91C[72 * a1] = 0;
    sub_80D4073(a1, off, a3);
    dword_834E91C[72 * a1] = 1;
  }
  if ( !dword_834E918[72 * a1] )
  {
    stream = (FILE *)sub_8060AA0(a1);
    if ( a3 == 1 )
    {
      whence = 2;
    }
    else if ( a3 > 1 )
    {
      if ( a3 != 2 )
        return 0;
      whence = 0;
    }
    else
    {
      if ( a3 )
        return 0;
      whence = 1;
    }
    return fseek(stream, off, whence);
  }
  if ( off || a3 != 2 )
  {
    if ( off || a3 )
    {
      v9 = sub_80C03B7(dword_834E900[72 * a1]);
      switch ( a3 )
      {
        case 0:
          if ( off >= 0 )
          {
            v8 = off;
          }
          else
          {
            sub_80BFA06(dword_834E900[72 * a1], dword_834E914[72 * a1]);
            sub_80BFE6F((_DWORD *)dword_834E900[72 * a1]);
            v8 = v9 + off;
          }
          goto LABEL_23;
        case 1:
          if ( off + sub_8060AF1(a1) >= v9 )
          {
            v8 = off + sub_8060AF1(a1) - v9;
          }
          else
          {
            sub_80BFA06(dword_834E900[72 * a1], dword_834E914[72 * a1]);
            sub_80BFE6F((_DWORD *)dword_834E900[72 * a1]);
            v8 = off + sub_8060AF1(a1);
          }
          goto LABEL_23;
        case 2:
          if ( off >= v9 )
          {
            v8 = off - v9;
          }
          else
          {
            sub_80BFA06(dword_834E900[72 * a1], dword_834E914[72 * a1]);
            sub_80BFE6F((_DWORD *)dword_834E900[72 * a1]);
            v8 = off;
          }
LABEL_23:
          while ( v8 )
          {
            if ( v8 >= 0x10000 )
            {
              v10 = FS_Read(v6, 0x10000u, a1);
              v8 -= 0x10000;
            }
            else
            {
              v10 = FS_Read(v6, v8, a1);
              v8 = 0;
            }
            if ( !v10 )
              return -1;
          }
          v4 = 0;
          break;
        default:
          v4 = -1;
          break;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    sub_80BFA06(dword_834E900[72 * a1], dword_834E914[72 * a1]);
    v4 = sub_80BFE6F((_DWORD *)dword_834E900[72 * a1]);
  }
  return v4;
}
// 834E900: using guessed type int dword_834E900[];
// 834E914: using guessed type int dword_834E914[];
// 834E918: using guessed type int dword_834E918[];

//----- (08062FBD) --------------------------------------------------------
size_t __cdecl FS_ReadFile(char *haystack, int a2)
{
  size_t v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  size_t v5; // [esp+18h] [ebp-10h] BYREF
  int v6; // [esp+1Ch] [ebp-Ch]
  char *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h] BYREF

  sub_8060862();
  if ( !haystack || !*haystack )
    Com_Error(0, (char *)&byte_80D78EF);
  v7 = 0;
  if ( strstr(haystack, ".cfg") )
  {
    v6 = 1;
    if ( dword_83604D0 && *(_DWORD *)(dword_83604D0 + 32) == 2 )
    {
      Com_DPrintf("Loading %s from journal file.\n", haystack);
      if ( FS_Read((char *)&v5, 4u, *(int *)dword_8360570) == 4 )
      {
        if ( v5 )
        {
          if ( a2 )
          {
            v7 = (char *)sub_806C6AE(v5 + 1);
            *(_DWORD *)a2 = v7;
            v4 = FS_Read(v7, v5, *(int *)dword_8360570);
            if ( v4 != v5 )
              Com_Error(0, "EXE_ERR_JOURNAL_FILE_READ");
            ++dword_834E8E0;
            v7[v5] = 0;
            v3 = v5;
          }
          else
          {
            v3 = v5;
          }
        }
        else if ( a2 )
        {
          *(_DWORD *)a2 = 0;
          v3 = -1;
        }
        else
        {
          v3 = 1;
        }
      }
      else
      {
        if ( a2 )
          *(_DWORD *)a2 = 0;
        v3 = -1;
      }
      return v3;
    }
  }
  else
  {
    v6 = 0;
  }
  v5 = FS_FOpenFileRead(haystack, (int)&v8, 0);
  if ( v8 )
  {
    if ( a2 )
    {
      ++dword_834E8E0;
      v7 = (char *)sub_806C6AE(v5 + 1);
      *(_DWORD *)a2 = v7;
      FS_Read(v7, v5, v8);
      v7[v5] = 0;
      FS_FCloseFile(v8);
      if ( v6 && dword_83604D0 && *(_DWORD *)(dword_83604D0 + 32) == 1 )
      {
        Com_DPrintf("Writing %s to journal file.\n", haystack);
        FS_Write((char *)&v5, 4u, *(int *)dword_8360570);
        FS_Write(v7, v5, *(int *)dword_8360570);
        FS_Flush(*(int *)dword_8360570);
      }
      v3 = v5;
    }
    else
    {
      if ( v6 && dword_83604D0 && *(_DWORD *)(dword_83604D0 + 32) == 1 )
      {
        Com_DPrintf("Writing len for %s to journal file.\n", haystack);
        FS_Write((char *)&v5, 4u, *(int *)dword_8360570);
        FS_Flush(*(int *)dword_8360570);
      }
      FS_FCloseFile(v8);
      v3 = v5;
    }
  }
  else
  {
    if ( a2 )
      *(_DWORD *)a2 = 0;
    if ( v6 && dword_83604D0 && *(_DWORD *)(dword_83604D0 + 32) == 1 )
    {
      Com_DPrintf("Writing zero for %s to journal file.\n", haystack);
      v5 = 0;
      FS_Write((char *)&v5, 4u, *(int *)dword_8360570);
      FS_Flush(*(int *)dword_8360570);
    }
    v3 = -1;
  }
  return v3;
}
// 834E8E0: using guessed type int dword_834E8E0;
// 83604D0: using guessed type int dword_83604D0;

//----- (08063305) --------------------------------------------------------
void sub_8063305()
{
  dword_834E8E0 = 0;
}
// 834E8E0: using guessed type int dword_834E8E0;

//----- (08063314) --------------------------------------------------------
int __cdecl FS_FreeFile(void *ptr)
{
  sub_8060862();
  if ( !ptr )
    Com_Error(0, (char *)&byte_80D79E2);
  --dword_834E8E0;
  return sub_806C7F0(ptr);
}
// 834E8E0: using guessed type int dword_834E8E0;

//----- (0806334C) --------------------------------------------------------
void *__cdecl FS_WriteFile(char *src, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  sub_8060862();
  if ( !src || !a2 )
    Com_Error(0, (char *)&byte_80D79F7);
  v4 = sub_80613C7(src);
  if ( !v4 )
    return (void *)Com_Printf("Failed to open %s\n", (char)src);
  FS_Write((char *)a2, a3, v4);
  return FS_FCloseFile(v4);
}

//----- (080633C6) --------------------------------------------------------
char *__cdecl sub_80633C6(char *src, char *a2)
{
  size_t v2; // eax
  char *v3; // ebx
  char *v4; // ebx
  char *v5; // ebx
  int v6; // eax
  char *v7; // ebx
  char *v8; // ebx
  signed int m; // [esp+24h] [ebp-194h]
  char *v12; // [esp+28h] [ebp-190h]
  _DWORD *ptr; // [esp+2Ch] [ebp-18Ch]
  int v14; // [esp+30h] [ebp-188h]
  int v15; // [esp+34h] [ebp-184h]
  int v16; // [esp+38h] [ebp-180h]
  unsigned int i; // [esp+3Ch] [ebp-17Ch]
  int j; // [esp+3Ch] [ebp-17Ch]
  int k; // [esp+3Ch] [ebp-17Ch]
  unsigned int l; // [esp+3Ch] [ebp-17Ch]
  int v21[20]; // [esp+40h] [ebp-178h] BYREF
  char s[264]; // [esp+90h] [ebp-128h] BYREF
  unsigned int v23; // [esp+198h] [ebp-20h] BYREF
  int v24; // [esp+1A0h] [ebp-18h]
  int v25; // [esp+1A4h] [ebp-14h]
  char *dest; // [esp+1A8h] [ebp-10h]
  _DWORD *v27; // [esp+1ACh] [ebp-Ch]

  v14 = 0;
  v25 = (int)sub_80BEF3A(src);
  v24 = sub_80BF272(v25, &v23);
  if ( v24 )
    return 0;
  *(_DWORD *)dword_80E8C40 += v23;
  v16 = 0;
  sub_80BF83E((_DWORD *)v25);
  for ( i = 0; i < v23; ++i )
  {
    v24 = sub_80BF7F2(v25, (int)v21, s, 256, 0, 0, 0, 0);
    if ( v24 )
      break;
    v16 += strlen(s) + 1;
    sub_80BF8E6((_DWORD *)v25);
  }
  v27 = Z_MallocInternal(v16 + 24 * v23);
  v12 = (char *)&v27[6 * v23];
  ptr = Z_MallocInternal(4 * v23);
  for ( j = 1; j <= 1024 && j <= v23; j *= 2 )
    ;
  dest = (char *)Z_MallocInternal(4 * j + 800);
  *((_DWORD *)dest + 197) = j;
  *((_DWORD *)dest + 198) = dest + 800;
  for ( k = 0; k < *((_DWORD *)dest + 197); ++k )
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * k) = 0;
  Q_strncpyz(dest, src, 256);
  Q_strncpyz(dest + 256, a2, 256);
  if ( strlen(dest + 256) > 4 )
  {
    v2 = strlen(dest + 256);
    if ( !Q_stricmp(&dest[v2 + 252], ".pk3") )
    {
      v3 = dest;
      v3[strlen(dest + 256) + 252] = 0;
    }
  }
  *((_DWORD *)dest + 192) = v25;
  *((_DWORD *)dest + 195) = v23;
  sub_80BF83E((_DWORD *)v25);
  for ( l = 0; l < v23; ++l )
  {
    v24 = sub_80BF7F2(v25, (int)v21, s, 256, 0, 0, 0, 0);
    if ( v24 )
      break;
    if ( v21[7] )
      ptr[v14++] = sub_80660B8(v21[5]);
    sub_8085FAF(s);
    v15 = sub_8060946((int)s, *((_DWORD *)dest + 197));
    v27[6 * l + 4] = v12;
    strcpy((char *)v27[6 * l + 4], s);
    for ( m = strlen(v12) - 1; m >= 0 && v12[m] != 47 && v12[m] != 92; --m )
      ;
    v27[6 * l + 1] = &v12[m + 1];
    v12 += strlen(s) + 1;
    sub_80BF9D4(v25, &v27[6 * l]);
    v27[6 * l + 5] = *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v15);
    *(_DWORD *)(*((_DWORD *)dest + 198) + 4 * v15) = &v27[6 * l];
    sub_80BF8E6((_DWORD *)v25);
  }
  v4 = dest;
  *((_DWORD *)v4 + 193) = sub_807F851(ptr, 4 * v14);
  v5 = dest;
  v6 = sub_80660B8(dword_835B234);
  *((_DWORD *)v5 + 194) = sub_807F8AD(ptr, 4 * v14, v6);
  v7 = dest;
  *((_DWORD *)v7 + 193) = sub_80660B8(*((_DWORD *)dest + 193));
  v8 = dest;
  *((_DWORD *)v8 + 194) = sub_80660B8(*((_DWORD *)dest + 194));
  Z_FreeInternal(ptr);
  *((_DWORD *)dest + 199) = v27;
  return dest;
}
// 835B234: using guessed type int dword_835B234;

//----- (08063980) --------------------------------------------------------
int __cdecl sub_8063980(char *src, char *dest, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v4 = 0;
  *dest = 0;
  v6 = 0;
  for ( i = 0; src[i]; ++i )
  {
    if ( src[i] == 47 || src[i] == 92 )
    {
      v6 = i;
      ++v4;
    }
  }
  strcpy(dest, src);
  dest[v6] = 0;
  if ( v6 + 1 == i )
    --v4;
  *(_DWORD *)a3 = v4;
  return v6;
}

//----- (08063A0E) --------------------------------------------------------
int __cdecl sub_8063A0E(char *s, int a2, int a3)
{
  int i; // [esp+14h] [ebp-4h]

  if ( a3 == 4095 )
    return 4095;
  for ( i = 0; i < a3; ++i )
  {
    if ( !Q_stricmp(s, *(char **)(a2 + 4 * i)) )
      return a3;
  }
  *(_DWORD *)(a2 + 4 * a3) = sub_806BC0A(s);
  return a3 + 1;
}

//----- (08063A95) --------------------------------------------------------
void *__cdecl FS_ListFilteredFiles(char *s, char *a2, int a3, int a4)
{
  void *v5; // [esp+2Ch] [ebp-429Ch]
  char name[256]; // [esp+30h] [ebp-4298h] BYREF
  char dest[64]; // [esp+130h] [ebp-4198h] BYREF
  int v8; // [esp+170h] [ebp-4158h] BYREF
  void *ptr; // [esp+174h] [ebp-4154h]
  char *src; // [esp+178h] [ebp-4150h]
  int v11; // [esp+17Ch] [ebp-414Ch]
  char v12[268]; // [esp+180h] [ebp-4148h] BYREF
  int v13; // [esp+28Ch] [ebp-403Ch]
  int v14; // [esp+290h] [ebp-4038h]
  int v15; // [esp+294h] [ebp-4034h]
  int v16; // [esp+298h] [ebp-4030h] BYREF
  int v17; // [esp+29Ch] [ebp-402Ch]
  int v18; // [esp+2A0h] [ebp-4028h]
  int v19; // [esp+2A4h] [ebp-4024h]
  int j; // [esp+2A8h] [ebp-4020h]
  void *i; // [esp+2ACh] [ebp-401Ch]
  int v22[4098]; // [esp+2B0h] [ebp-4018h] BYREF
  _DWORD *v23; // [esp+42B8h] [ebp-10h]
  int v24; // [esp+42BCh] [ebp-Ch]

  sub_8060862();
  if ( s )
  {
    if ( !a2 )
      a2 = (char *)&byte_80D7741;
    if ( *s == 47 || *s == 92 )
      ++s;
    v11 = Q_stricmp(a2, "/") == 0;
    v19 = strlen(s);
    if ( v19 && (s[v19 - 1] == 92 || s[v19 - 1] == 47) )
      --v19;
    v18 = strlen(a2);
    v24 = 0;
    sub_8063980(s, v12, (int)&v16);
    if ( *s )
      ++v16;
    for ( i = fs_searchpaths; i; i = *(void **)i )
    {
      if ( sub_80608CE((int)i) )
      {
        if ( *((_DWORD *)i + 1) )
        {
          if ( *((_DWORD *)i + 3) || sub_8060867(*((_DWORD *)i + 1)) )
          {
            v14 = *((_DWORD *)i + 1);
            v13 = *(_DWORD *)(v14 + 796);
            for ( j = 0; j < *(_DWORD *)(v14 + 780); ++j )
            {
              src = *(char **)(v13 + 24 * j + 16);
              if ( a3 )
              {
                if ( sub_806B9BA(a3, src, 0) )
                  v24 = sub_8063A0E(src, (int)v22, v24);
              }
              else
              {
                ptr = (void *)sub_8063980(src, v12, (int)&v8);
                if ( v8 == v16 && v19 <= (int)ptr && (v19 <= 0 || src[v19] == 47) && !Q_stricmpn(src, s, v19) )
                {
                  v17 = strlen(src);
                  if ( v17 >= v18 && !Q_stricmp(&src[v17 - v18], a2) )
                  {
                    v15 = v19;
                    if ( v19 )
                      ++v15;
                    if ( v11 )
                    {
                      strcpy(dest, &src[v15]);
                      dest[strlen(dest) - 1] = 0;
                      v24 = sub_8063A0E(dest, (int)v22, v24);
                    }
                    else
                    {
                      v24 = sub_8063A0E(&src[v15], (int)v22, v24);
                    }
                  }
                }
              }
            }
          }
        }
        else if ( *((_DWORD *)i + 2) && (!*(_DWORD *)(dword_835B23C + 32) && !dword_835B22C || !Q_stricmp(a2, "svg")) )
        {
          sub_8060CD2(*((char **)i + 2), (char *)(*((_DWORD *)i + 2) + 256), s, name);
          ptr = sub_80D5975(name, a2, a3, (int)&v8, v11);
          for ( j = 0; j < v8; ++j )
          {
            src = (char *)*((_DWORD *)ptr + j);
            v24 = sub_8063A0E(src, (int)v22, v24);
          }
          sub_80D5D04(ptr);
        }
      }
    }
    *(_DWORD *)a4 = v24;
    if ( v24 )
    {
      v23 = Z_MallocInternal(4 * v24 + 4);
      for ( j = 0; j < v24; ++j )
        v23[j] = v22[j];
      v23[j] = 0;
      v5 = v23;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    *(_DWORD *)a4 = 0;
    v5 = 0;
  }
  return v5;
}
// 806B9BA: using guessed type int __cdecl sub_806B9BA(_DWORD, _DWORD, _DWORD);
// 835B22C: using guessed type int dword_835B22C;
// 835B23C: using guessed type int dword_835B23C;

//----- (08064009) --------------------------------------------------------
void *__cdecl sub_8064009(char *s, char *a2, int a3)
{
  return FS_ListFilteredFiles(s, a2, 0, a3);
}

//----- (08064032) --------------------------------------------------------
void __cdecl sub_8064032(void *ptr)
{
  int i; // [esp+4h] [ebp-4h]

  sub_8060862();
  if ( ptr )
  {
    for ( i = 0; *((_DWORD *)ptr + i); ++i )
      Z_FreeInternal(*((void **)ptr + i));
    Z_FreeInternal(ptr);
  }
}

//----- (0806408D) --------------------------------------------------------
int __cdecl sub_806408D(char *s, char *a2, char *dest, int a4)
{
  const char **ptr; // [esp+14h] [ebp-14h]
  size_t v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int v10; // [esp+24h] [ebp-4h] BYREF

  *dest = 0;
  v10 = 0;
  v8 = 0;
  if ( !Q_stricmp(s, "$modlist") )
    return sub_8074DCC(dest, a4);
  ptr = (const char **)sub_8064009(s, a2, (int)&v10);
  for ( i = 0; i < v10; ++i )
  {
    v7 = strlen(ptr[i]) + 1;
    if ( (int)(v8 + v7 + 1) >= a4 )
    {
      v10 = i;
      break;
    }
    strcpy(dest, ptr[i]);
    dest += v7;
    v8 += v7;
  }
  sub_8064032(ptr);
  return v10;
}

//----- (0806418A) --------------------------------------------------------
_BYTE *__cdecl FS_ConvertPath(_BYTE *a1)
{
  _BYTE *result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    if ( *a1 == 92 || *a1 == 58 )
      *a1 = 47;
    ++a1;
  }
  return result;
}

//----- (080641B7) --------------------------------------------------------
int __cdecl sub_80641B7(char *a1, char *a2)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  do
  {
    v5 = *a1++;
    v4 = *a2++;
    if ( sub_8085CC2(v5) )
      v5 -= 32;
    if ( sub_8085CC2(v4) )
      v4 -= 32;
    if ( v5 == 92 || v5 == 58 )
      v5 = 47;
    if ( v4 == 92 || v4 == 58 )
      v4 = 47;
    if ( v5 < v4 )
      return -1;
    if ( v5 > v4 )
      return 1;
  }
  while ( v5 );
  return 0;
}

//----- (08064264) --------------------------------------------------------
int __cdecl FS_SortFileList(void *dest, int a2)
{
  _DWORD *ptr; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int k; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  ptr = Z_MallocInternal(4 * a2 + 4);
  *ptr = 0;
  v4 = 0;
  for ( i = 0; i < a2; ++i )
  {
    for ( j = 0; j < v4 && sub_80641B7(*((char **)dest + i), (char *)ptr[j]) >= 0; ++j )
      ;
    for ( k = v4; k > j; --k )
      ptr[k] = ptr[k - 1];
    ptr[j] = *((_DWORD *)dest + i);
    ++v4;
  }
  sub_80D2FC8(dest, ptr, 4 * a2);
  return Z_FreeInternal(ptr);
}

//----- (0806437E) --------------------------------------------------------
char *__cdecl sub_806437E(int a1)
{
  char *result; // eax
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  char v4[4]; // [esp+10h] [ebp-8h] BYREF
  int *i; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(dword_834E8E4 + 32) )
    Com_Printf("    localized assets are being ignored\n", v2);
  Com_Printf("Current search path:\n", v2);
  for ( i = (int *)fs_searchpaths; i; i = (int *)*i )
  {
    if ( !a1 || sub_80608CE((int)i) )
    {
      if ( i[1] )
      {
        Com_Printf("%s (%i files)\n", i[1]);
        if ( dword_835B22C )
        {
          if ( sub_8060867(i[1]) )
            Com_Printf("    on the pure list\n", v3);
          else
            Com_Printf("    not on the pure list\n", v3);
        }
      }
      else
      {
        Com_Printf("%s/%s\n", i[2]);
      }
    }
  }
  result = (char *)Com_Printf("\nFile Handles:\n", v3);
  *(_DWORD *)v4 = 1;
  while ( *(int *)v4 <= 63 )
  {
    if ( dword_834E900[72 * *(_DWORD *)v4] )
      Com_Printf("handle %i: %s\n", v4[0]);
    result = v4;
    ++*(_DWORD *)v4;
  }
  return result;
}
// 8064396: variable 'v2' is possibly undefined
// 8064425: variable 'v3' is possibly undefined
// 834E8E4: using guessed type int dword_834E8E4;
// 834E900: using guessed type int dword_834E900[];
// 835B22C: using guessed type int dword_835B22C;

//----- (080644D1) --------------------------------------------------------
char *sub_80644D1()
{
  return sub_806437E(0);
}

//----- (080644E5) --------------------------------------------------------
char *sub_80644E5()
{
  return sub_806437E(0);
}

//----- (080644F9) --------------------------------------------------------
int __cdecl sub_80644F9(char *s)
{
  int v2; // [esp+14h] [ebp-4h]

  dword_80E8C44 ^= 1u;
  if ( strlen(s) > 9 )
  {
    v2 = 10;
    memset(&byte_810F400[64 * dword_80E8C44], 0, 0x40u);
    while ( v2 <= 63 && s[v2] && (*(_WORD *)(_ctype_b + 2 * s[v2]) & 0x400) != 0 )
    {
      byte_810F400[64 * dword_80E8C44 - 10 + v2] = s[v2];
      ++v2;
    }
  }
  else
  {
    byte_810F400[64 * dword_80E8C44] = 0;
  }
  return (dword_80E8C44 << 6) + 135328768;
}
// 80E8C44: using guessed type int dword_80E8C44;
// 80F6548: using guessed type int _ctype_b;

//----- (080645BF) --------------------------------------------------------
int __cdecl compar(const void *a1, const void *a2)
{
  char *v4; // [esp+18h] [ebp-10h]
  char *v5; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  s = *(char **)a1;
  v6 = *(char **)a2;
  if ( Q_strncmp(*(char **)a1, "          ", 10) || Q_strncmp(v6, "          ", 10) )
    return sub_80641B7(s, v6);
  v5 = (char *)sub_80644F9(s);
  v4 = (char *)sub_80644F9(v6);
  if ( Q_stricmp(v5, "english") )
  {
    if ( !Q_stricmp(v4, "english") )
      return 1;
    return sub_80641B7(s, v6);
  }
  if ( !Q_stricmp(v4, "english") )
    return sub_80641B7(s, v6);
  return -1;
}

//----- (080646A4) --------------------------------------------------------
_DWORD *__cdecl sub_80646A4(_DWORD *a1)
{
  _DWORD *result; // eax
  void *i; // [esp+0h] [ebp-4h]

  if ( a1[3] && fs_searchpaths )
  {
    for ( i = fs_searchpaths; *(_DWORD *)i && !*(_DWORD *)(*(_DWORD *)i + 12); i = *(void **)i )
      ;
    *a1 = *(_DWORD *)i;
    result = a1;
    *(_DWORD *)i = a1;
  }
  else
  {
    *a1 = fs_searchpaths;
    result = a1;
    fs_searchpaths = a1;
  }
  return result;
}

//----- (0806470A) --------------------------------------------------------
int __cdecl sub_806470A(char *a1, char *src)
{
  char *v3; // [esp+20h] [ebp-1128h]
  _DWORD *v4; // [esp+24h] [ebp-1124h]
  char *v5; // [esp+28h] [ebp-1120h]
  _DWORD *ptr; // [esp+2Ch] [ebp-111Ch]
  void *dest[1024]; // [esp+30h] [ebp-1118h] BYREF
  char s[256]; // [esp+1030h] [ebp-118h] BYREF
  int v9; // [esp+1130h] [ebp-18h]
  size_t nmemb; // [esp+1134h] [ebp-14h] BYREF
  int v11; // [esp+1138h] [ebp-10h]
  int i; // [esp+113Ch] [ebp-Ch]

  sub_8060CD2(a1, src, (char *)&byte_80D7741, s);
  s[strlen(s) - 1] = 0;
  ptr = sub_80D5975(s, ".pk3", 0, (int)&nmemb, 0);
  if ( (int)nmemb > 1024 )
  {
    Com_Printf("WARNING: Exceeded max number of pak files in %s/%s (%1/%1)\n", (char)a1);
    nmemb = 1024;
  }
  for ( i = 0; i < (int)nmemb; ++i )
  {
    dest[i] = (void *)ptr[i];
    if ( !Q_strncmp((char *)dest[i], "localized_", 10) )
      memcpy(dest[i], "          ", 0xAu);
  }
  qsort(dest, nmemb, 4u, compar);
  for ( i = 0; i < (int)nmemb; ++i )
  {
    if ( Q_strncmp((char *)dest[i], "          ", 10) )
    {
      v9 = 0;
      v11 = 0;
LABEL_16:
      sub_8060CD2(a1, src, (char *)dest[i], s);
      v3 = sub_80633C6(s, (char *)dest[i]);
      if ( v3 )
      {
        strcpy(v3 + 512, src);
        v4 = Z_MallocInternal(0x14u);
        v4[1] = v3;
        v4[3] = v9;
        v4[4] = v11;
        sub_80646A4(v4);
      }
      continue;
    }
    memcpy(dest[i], "localized_", 0xAu);
    v9 = 1;
    v5 = (char *)sub_80644F9((char *)dest[i]);
    if ( !*v5 )
    {
      Com_Printf(
        "WARNING: Localized assets pak file %s/%s/%s has invalid name (no language specified). Proper naming convention i"
        "s: localized_[language]_pak#.pk3\n",
        (char)a1);
      continue;
    }
    if ( !Q_stricmp(v5, "english") )
    {
      v11 = 0;
      goto LABEL_16;
    }
  }
  return sub_80D5D04(ptr);
}

//----- (08064A1B) --------------------------------------------------------
void *__cdecl sub_8064A1B(char *a1, char *src, int a3, int a4)
{
  void *result; // eax
  _DWORD *v5; // ebx
  char v6; // [esp+4h] [ebp-184h]
  const char *v7; // [esp+2Ch] [ebp-15Ch]
  char s[260]; // [esp+30h] [ebp-158h] BYREF
  _DWORD *v9; // [esp+134h] [ebp-54h]
  void *i; // [esp+138h] [ebp-50h]
  const char *v11; // [esp+13Ch] [ebp-4Ch]
  char dest[72]; // [esp+140h] [ebp-48h] BYREF

  if ( a3 )
  {
    v11 = "english";
    Com_sprintf(dest, 0x40u, "%s_%s", src, "english");
  }
  else
  {
    Q_strncpyz(dest, src, 64);
  }
  for ( i = fs_searchpaths; i; i = *(void **)i )
  {
    if ( *((_DWORD *)i + 2) && !Q_stricmp(*((char **)i + 2), a1) && !Q_stricmp((char *)(*((_DWORD *)i + 2) + 256), dest) )
    {
      if ( *((_DWORD *)i + 3) != a3 )
      {
        if ( *((_DWORD *)i + 3) )
          v7 = "localized";
        else
          v7 = "non-localized";
        Com_Printf("WARNING: game folder %s/%s added as both localized & non-localized. Using folder as %s\n", (char)a1);
      }
      result = i;
      if ( *((_DWORD *)i + 3) )
      {
        result = (void *)*((_DWORD *)i + 4);
        if ( result != (void *)a4 )
          result = (void *)Com_Printf(
                             "WARNING: game golder %s/%s re-added as localized folder with different language\n",
                             v6);
      }
      return result;
    }
  }
  if ( a3 )
  {
    sub_8060CD2(a1, dest, (char *)&byte_80D7741, s);
    s[strlen(s) - 1] = 0;
    result = (void *)sub_80D2F34(s);
    if ( !result )
      return result;
  }
  else
  {
    Q_strncpyz(byte_835F380, dest, 256);
  }
  v9 = Z_MallocInternal(0x14u);
  v5 = v9;
  v5[2] = Z_MallocInternal(0x200u);
  Q_strncpyz((char *)v9[2], a1, 256);
  Q_strncpyz((char *)(v9[2] + 256), dest, 256);
  v9[3] = a3;
  v9[4] = a4;
  sub_80646A4(v9);
  return (void *)sub_806470A(a1, dest);
}
// 8064B43: variable 'v6' is possibly undefined

//----- (08064C65) --------------------------------------------------------
void *__cdecl sub_8064C65(char *a1, char *src)
{
  sub_8064A1B(a1, src, 1, 0);
  return sub_8064A1B(a1, src, 0, 0);
}

//----- (08064CB1) --------------------------------------------------------
void __cdecl sub_8064CB1(char *a1, int a2, char *a3, char *a4)
{
  size_t v4; // eax
  size_t v5; // eax
  char s[268]; // [esp+20h] [ebp-238h] BYREF
  _DWORD *v7; // [esp+12Ch] [ebp-12Ch]
  int v8; // [esp+130h] [ebp-128h]
  int v9; // [esp+134h] [ebp-124h]
  int i; // [esp+138h] [ebp-120h]
  char *src; // [esp+13Ch] [ebp-11Ch]
  _DWORD *v12; // [esp+140h] [ebp-118h]
  char *dest; // [esp+144h] [ebp-114h]
  void *ptr; // [esp+148h] [ebp-110h]
  int v15; // [esp+14Ch] [ebp-10Ch] BYREF
  char name[264]; // [esp+150h] [ebp-108h] BYREF

  sprintf(s, "%s/%s", (const char *)a2, a3);
  sub_8060CD2(a1, s, (char *)&byte_80D7741, name);
  name[strlen(name) - 1] = 0;
  ptr = sub_80D5975(name, a4, 0, (int)&v15, 0);
  v9 = 0;
  for ( i = 0; i < v15; ++i )
  {
    v4 = strlen(*((const char **)ptr + i));
    v9 += v4 + 1;
  }
  for ( i = 1; i <= 1024 && i <= v15; i *= 2 )
    ;
  dest = (char *)Z_MallocInternal(4 * i + 276);
  *((_DWORD *)dest + 65) = i;
  *((_DWORD *)dest + 66) = dest + 276;
  for ( i = 0; i < *((_DWORD *)dest + 65); ++i )
    *(_DWORD *)(*((_DWORD *)dest + 66) + 4 * i) = 0;
  Q_strncpyz(dest, a3, 256);
  *((_DWORD *)dest + 68) = dword_80E8C34;
  dword_80E8C34 = dest;
  *((_DWORD *)dest + 64) = v15;
  v12 = Z_MallocInternal(v9 + 16 * v15);
  v7 = &v12[4 * v15];
  for ( i = 0; i < v15; ++i )
  {
    src = (char *)*((_DWORD *)ptr + i);
    sub_8085FAF(src);
    v8 = sub_8060946((int)src, *((_DWORD *)dest + 65));
    v12[4 * i] = v7;
    strcpy((char *)v12[4 * i], src);
    v5 = strlen(src);
    v7 = (_DWORD *)((char *)v7 + v5 + 1);
    v12[4 * i + 3] = *(_DWORD *)(*((_DWORD *)dest + 66) + 4 * v8);
    v12[4 * i + 1] = 0;
    v12[4 * i + 2] = 0;
    *(_DWORD *)(*((_DWORD *)dest + 66) + 4 * v8) = &v12[4 * i];
  }
  *((_DWORD *)dest + 67) = v12;
  sub_80D5D04(ptr);
  sub_80D3C7C();
}

//----- (0806507A) --------------------------------------------------------
char *__cdecl sub_806507A(char *a1, char *a2)
{
  char *result; // eax
  char *i; // [esp+14h] [ebp-4h]

  result = (char *)fs_searchpaths;
  for ( i = (char *)fs_searchpaths; i; i = *(char **)i )
  {
    if ( !*((_DWORD *)i + 1) )
      sub_8064CB1(*((char **)i + 2), *((_DWORD *)i + 2) + 256, a1, a2);
    result = *(char **)i;
  }
  return result;
}

//----- (080650D2) --------------------------------------------------------
int __cdecl sub_80650D2(char *s2, int a2, int a3)
{
  char s[1036]; // [esp+30h] [ebp-428h] BYREF
  int v6; // [esp+43Ch] [ebp-1Ch]
  int k; // [esp+440h] [ebp-18h]
  int j; // [esp+444h] [ebp-14h]
  char *s1; // [esp+448h] [ebp-10h]
  int *i; // [esp+44Ch] [ebp-Ch]

  sprintf(s, "%s/%s%s", s2, (const char *)a2, (const char *)a3);
  for ( i = (int *)dword_80E8C38; i; i = (int *)*i )
  {
    if ( sub_80608CE((int)i) && i[1] )
    {
      v6 = sub_8060946((int)s, *(_DWORD *)(i[1] + 788));
      for ( j = *(_DWORD *)(*(_DWORD *)(i[1] + 792) + 4 * v6); j; j = *(_DWORD *)(j + 20) )
      {
        if ( !FS_FilenameCompare(*(char **)(j + 16), s) )
          return j + 4;
      }
    }
  }
  sprintf(s, "%s%s", (const char *)a2, (const char *)a3);
  for ( s1 = (char *)dword_80E8C3C; s1; s1 = (char *)*((_DWORD *)s1 + 68) )
  {
    if ( !strcasecmp(s1, s2) )
    {
      v6 = sub_8060946((int)s, *((_DWORD *)s1 + 65));
      for ( k = *(_DWORD *)(*((_DWORD *)s1 + 66) + 4 * v6); k; k = *(_DWORD *)(k + 12) )
      {
        if ( !FS_FilenameCompare(*(char **)k, s) )
          return k;
      }
    }
  }
  return 0;
}

//----- (080652A4) --------------------------------------------------------
_DWORD *__cdecl sub_80652A4(unsigned int a1, unsigned int a2)
{
  _DWORD *result; // eax
  int j; // [esp+4h] [ebp-14h]
  int m; // [esp+4h] [ebp-14h]
  int n; // [esp+8h] [ebp-10h]
  int k; // [esp+Ch] [ebp-Ch]
  _DWORD *l; // [esp+10h] [ebp-8h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  for ( i = dword_80E8C38; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      for ( j = 0; j < *(_DWORD *)(i[1] + 788); ++j )
      {
        for ( k = *(_DWORD *)(*(_DWORD *)(i[1] + 792) + 4 * j); k; k = *(_DWORD *)(k + 20) )
        {
          if ( *(_DWORD *)(k + 8) >= a1 && *(_DWORD *)(k + 8) < a2 )
          {
            if ( *(_DWORD *)(k + 12) )
            {
              (*(void (__cdecl **)(int))(k + 12))(k + 4);
              *(_DWORD *)(k + 12) = 0;
            }
            *(_DWORD *)(k + 8) = 0;
          }
        }
      }
    }
  }
  result = dword_80E8C3C;
  for ( l = dword_80E8C3C; l; l = result )
  {
    for ( m = 0; m < l[65]; ++m )
    {
      for ( n = *(_DWORD *)(l[66] + 4 * m); n; n = *(_DWORD *)(n + 12) )
      {
        if ( *(_DWORD *)(n + 4) >= a1 && *(_DWORD *)(n + 4) < a2 )
        {
          if ( *(_DWORD *)(n + 8) )
          {
            (*(void (__cdecl **)(int))(n + 8))(n);
            *(_DWORD *)(n + 8) = 0;
          }
          *(_DWORD *)(n + 4) = 0;
        }
      }
    }
    result = (_DWORD *)l[68];
  }
  return result;
}

//----- (08065423) --------------------------------------------------------
void *__cdecl sub_8065423(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = *(void **)ptr;
    if ( *((_DWORD *)ptr + 1) )
    {
      sub_80BF21F(*(_DWORD *)(*((_DWORD *)ptr + 1) + 768));
      Z_FreeInternal(*(void **)(*((_DWORD *)ptr + 1) + 796));
      Z_FreeInternal(*((void **)ptr + 1));
    }
    if ( *((_DWORD *)ptr + 2) )
      Z_FreeInternal(*((void **)ptr + 2));
    Z_FreeInternal(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (080654A5) --------------------------------------------------------
void *__cdecl sub_80654A5(void *ptr)
{
  void *result; // eax
  void *v2; // [esp+4h] [ebp-4h]

  while ( ptr )
  {
    v2 = (void *)*((_DWORD *)ptr + 68);
    Z_FreeInternal(*((void **)ptr + 67));
    Z_FreeInternal(ptr);
    result = v2;
    ptr = v2;
  }
  return result;
}

//----- (080654E6) --------------------------------------------------------
void *sub_80654E6()
{
  void *result; // eax

  if ( dword_80E8C38 != fs_searchpaths )
  {
    sub_8065423(dword_80E8C38);
    dword_80E8C38 = fs_searchpaths;
  }
  result = dword_80E8C3C;
  if ( dword_80E8C3C != dword_80E8C34 )
  {
    sub_80654A5(dword_80E8C3C);
    result = dword_80E8C34;
    dword_80E8C3C = dword_80E8C34;
  }
  return result;
}

//----- (08065536) --------------------------------------------------------
int sub_8065536()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_835B22C )
      break;
    if ( *(&dword_835B260 + i) )
      Z_FreeInternal(*(&dword_835B260 + i));
    *(&dword_835B260 + i) = 0;
  }
  dword_835B22C = 0;
  return result;
}
// 835B22C: using guessed type int dword_835B22C;

//----- (08065590) --------------------------------------------------------
int sub_8065590()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_835B228 )
      break;
    if ( *(&dword_834A8E0 + i) )
      Z_FreeInternal(*(&dword_834A8E0 + i));
    *(&dword_834A8E0 + i) = 0;
  }
  dword_835B228 = 0;
  return result;
}
// 835B228: using guessed type int dword_835B228;

//----- (080655EA) --------------------------------------------------------
int __cdecl sub_80655EA(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= 63; ++i )
  {
    if ( dword_834E910[72 * i] )
      FS_FCloseFile(i);
  }
  if ( a1 )
  {
    sub_8065423(fs_searchpaths);
    sub_80654A5(dword_80E8C34);
    dword_80E8C38 = 0;
    dword_80E8C3C = 0;
  }
  else
  {
    if ( dword_80E8C38 != fs_searchpaths )
      sub_8065423(fs_searchpaths);
    if ( dword_80E8C3C != dword_80E8C34 )
      sub_80654A5(dword_80E8C34);
  }
  fs_searchpaths = 0;
  dword_80E8C34 = 0;
  sub_80604D4("path");
  sub_80604D4("fullpath");
  sub_80604D4("dir");
  sub_80604D4("fdir");
  return sub_80604D4("touchFile");
}
// 834E910: using guessed type int dword_834E910[];

//----- (080656E5) --------------------------------------------------------
int __cdecl sub_80656E5(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char v4; // [esp+4h] [ebp-14h]
  char v5; // [esp+4h] [ebp-14h]
  char *s2; // [esp+14h] [ebp-4h]

  Com_Printf("----- FS_Startup -----\n", v4);
  *(_DWORD *)dword_80E8C40 = 0;
  dword_835B240 = (int)Cvar_Get("fs_debug", "0", 0);
  dword_835B224 = (int)Cvar_Get("fs_copyfiles", "0", 16);
  v1 = sub_80D5DA5();
  dword_835B248 = (int)Cvar_Get("fs_cdpath", v1, 16);
  v2 = sub_80D5DF7();
  dword_8357200 = (int)Cvar_Get("fs_basepath", v2, 16);
  dword_835B220 = (int)Cvar_Get("fs_basegame", (char *)&byte_80D7741, 16);
  s2 = sub_80D5E3F();
  if ( !s2 || !*s2 )
    s2 = *(char **)(dword_8357200 + 4);
  dword_835B230 = (int)Cvar_Get("fs_homepath", s2, 16);
  dword_835B244 = (int)Cvar_Get("fs_game", (char *)&byte_80D7741, 24);
  dword_835B23C = (int)Cvar_Get("fs_restrict", (char *)&byte_80D7741, 16);
  dword_834E8E4 = (int)Cvar_Get("fs_ignoreLozalized", "0", 544);
  if ( **(_BYTE **)(dword_835B248 + 4) )
    sub_8064C65(*(char **)(dword_835B248 + 4), src);
  if ( **(_BYTE **)(dword_8357200 + 4) )
    sub_8064C65(*(char **)(dword_8357200 + 4), src);
  if ( **(_BYTE **)(dword_8357200 + 4) && Q_stricmp(*(char **)(dword_835B230 + 4), *(char **)(dword_8357200 + 4)) )
    sub_8064C65(*(char **)(dword_835B230 + 4), src);
  if ( **(_BYTE **)(dword_835B220 + 4) && !Q_stricmp(src, "main") && Q_stricmp(*(char **)(dword_835B220 + 4), src) )
  {
    if ( **(_BYTE **)(dword_835B248 + 4) )
      sub_8064C65(*(char **)(dword_835B248 + 4), *(char **)(dword_835B220 + 4));
    if ( **(_BYTE **)(dword_8357200 + 4) )
      sub_8064C65(*(char **)(dword_8357200 + 4), *(char **)(dword_835B220 + 4));
    if ( **(_BYTE **)(dword_835B230 + 4) && Q_stricmp(*(char **)(dword_835B230 + 4), *(char **)(dword_8357200 + 4)) )
      sub_8064C65(*(char **)(dword_835B230 + 4), *(char **)(dword_835B220 + 4));
  }
  if ( **(_BYTE **)(dword_835B244 + 4) && !Q_stricmp(src, "main") && Q_stricmp(*(char **)(dword_835B244 + 4), src) )
  {
    if ( **(_BYTE **)(dword_835B248 + 4) )
      sub_8064C65(*(char **)(dword_835B248 + 4), *(char **)(dword_835B244 + 4));
    if ( **(_BYTE **)(dword_8357200 + 4) )
      sub_8064C65(*(char **)(dword_8357200 + 4), *(char **)(dword_835B244 + 4));
    if ( **(_BYTE **)(dword_835B230 + 4) && Q_stricmp(*(char **)(dword_835B230 + 4), *(char **)(dword_8357200 + 4)) )
      sub_8064C65(*(char **)(dword_835B230 + 4), *(char **)(dword_835B244 + 4));
  }
  sub_806507A("xanim", (char *)&byte_80D7741);
  sub_806507A("xmodel", (char *)&byte_80D7741);
  sub_806507A("xmodelparts", (char *)&byte_80D7741);
  sub_806507A("xmodelsurfs", (char *)&byte_80D7741);
  sub_806507A("weapons", (char *)&byte_80D7741);
  sub_806507A("animtrees", ".atr");
  sub_8070D19();
  sub_8075A4A();
  sub_80644E5();
  *(_DWORD *)(dword_835B244 + 20) = 0;
  Com_Printf("----------------------\n", v5);
  return Com_Printf("%d files in pk3 files\n", dword_80E8C40[0]);
}
// 80656F2: variable 'v4' is possibly undefined
// 8065B3E: variable 'v5' is possibly undefined
// 834E8E4: using guessed type int dword_834E8E4;
// 8357200: using guessed type int dword_8357200;
// 835B220: using guessed type int dword_835B220;
// 835B224: using guessed type int dword_835B224;
// 835B230: using guessed type int dword_835B230;
// 835B23C: using guessed type int dword_835B23C;
// 835B240: using guessed type int dword_835B240;
// 835B244: using guessed type int dword_835B244;
// 835B248: using guessed type int dword_835B248;

//----- (08065B5A) --------------------------------------------------------
_DWORD *__cdecl sub_8065B5A(int a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+0h] [ebp-4h]

  result = fs_searchpaths;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      *(_BYTE *)(i[1] + 786) = 0;
      *(_BYTE *)(i[1] + 785) = 0;
      if ( !a1 )
      {
        *(_BYTE *)(i[1] + 784) = 0;
        *(_BYTE *)(i[1] + 787) = 0;
      }
    }
    result = (_DWORD *)*i;
  }
  return result;
}

//----- (08065BBF) --------------------------------------------------------
char *FS_InitFilesystem()
{
  Com_StartupVariable("fs_cdpath");
  Com_StartupVariable("fs_basepath");
  Com_StartupVariable("fs_homepath");
  Com_StartupVariable("fs_game");
  Com_StartupVariable("fs_copyfiles");
  Com_StartupVariable("fs_restrict");
  Com_StartupVariable("fs_usewolf");
  Com_StartupVariable("cl_language");
  sub_80656E5("main");
  sub_8075AB6();
  if ( (int)FS_ReadFile("default_mp.cfg", 0) <= 0 )
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  Q_strncpyz(&byte_835F260, *(char **)(dword_8357200 + 4), 256);
  return Q_strncpyz(&byte_8353100, *(char **)(dword_835B244 + 4), 256);
}
// 8357200: using guessed type int dword_8357200;
// 835B244: using guessed type int dword_835B244;

//----- (08065CAC) --------------------------------------------------------
char *__cdecl sub_8065CAC(int a1)
{
  char *v1; // eax

  sub_80655EA(0);
  dword_835B234 = a1;
  sub_8065B5A(0);
  sub_80656E5("main");
  sub_8075AB6();
  if ( (int)FS_ReadFile("default_mp.cfg", 0) <= 0 )
  {
    if ( byte_835F260 )
    {
      sub_807603C((char **)&byte_80D7741, (char **)&byte_80D7741);
      Cvar_Set("fs_basepath", &byte_835F260);
      Cvar_Set("fs_gamedirvar", &byte_8353100);
      byte_835F260 = 0;
      byte_8353100 = 0;
      Cvar_Set("fs_restrict", "0");
      sub_8065CAC(a1);
      Com_Error(1, "Invalid game folder\n");
    }
    Com_Error(0, "Couldn't load %s.  Make sure Call of Duty is run from the correct folder.", "default_mp.cfg");
  }
  if ( Q_stricmp(*(char **)(dword_835B244 + 4), &byte_8353100) && !sub_80700DF() )
  {
    v1 = va("exec %s\n", "config_mp_server.cfg");
    Cbuf_AddText(v1);
  }
  Q_strncpyz(&byte_835F260, *(char **)(dword_8357200 + 4), 256);
  return Q_strncpyz(&byte_8353100, *(char **)(dword_835B244 + 4), 256);
}
// 8357200: using guessed type int dword_8357200;
// 835B234: using guessed type int dword_835B234;
// 835B244: using guessed type int dword_835B244;

//----- (08065E76) --------------------------------------------------------
int __cdecl FS_FOpenFileByMode(char *src, int a2, int a3)
{
  int v3; // ebx
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  v6 = 0;
  if ( a3 == 1 )
  {
    *(_DWORD *)a2 = sub_80613C7(src);
    v7 = 0;
    if ( !*(_DWORD *)a2 )
      v7 = -1;
  }
  else if ( a3 )
  {
    if ( a3 != 2 )
    {
      if ( a3 != 3 )
        Com_Error(0, (char *)&byte_80D7EAB);
      v6 = 1;
    }
    *(_DWORD *)a2 = sub_806168B(src);
    v7 = 0;
    if ( !*(_DWORD *)a2 )
      v7 = -1;
  }
  else
  {
    v7 = FS_FOpenFileRead(src, a2, 1);
  }
  if ( !a2 )
    return v7;
  if ( *(_DWORD *)a2 )
  {
    v3 = 72 * *(_DWORD *)a2;
    if ( dword_834E918[v3] )
      dword_834E90C[v3] = sub_80C03B7(dword_834E900[72 * *(_DWORD *)a2]);
    else
      dword_834E90C[v3] = ftell((FILE *)dword_834E900[72 * *(_DWORD *)a2]);
    dword_834E910[72 * *(_DWORD *)a2] = v7;
    dword_834E91C[72 * *(_DWORD *)a2] = 0;
  }
  dword_834E908[72 * *(_DWORD *)a2] = v6;
  return v7;
}
// 834E900: using guessed type int dword_834E900[];
// 834E908: using guessed type int dword_834E908[];
// 834E90C: using guessed type int dword_834E90C[];
// 834E910: using guessed type int dword_834E910[];
// 834E918: using guessed type int dword_834E918[];

//----- (08066095) --------------------------------------------------------
int __cdecl FS_Flush(int a1)
{
  return fflush((FILE *)dword_834E900[72 * a1]);
}
// 834E900: using guessed type int dword_834E900[];

//----- (080660B8) --------------------------------------------------------
int __cdecl sub_80660B8(int a1)
{
  return a1;
}

//----- (080660C0) --------------------------------------------------------
int __cdecl sub_80660C0(int a1)
{
  *(_DWORD *)a1 = 69069 * *(_DWORD *)a1 + 1;
  return *(_DWORD *)a1;
}

//----- (080660DB) --------------------------------------------------------
long double __cdecl sub_80660DB(int a1)
{
  return (long double)(unsigned __int16)sub_80660C0(a1) / 65536.0;
}

//----- (0806619F) --------------------------------------------------------
long double __cdecl sub_806619F(float a1)
{
  float v3; // [esp+Ch] [ebp-8h]

  v3 = a1 * 0.5;
  return (float)((1.5
                - v3 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
               * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (080666D0) --------------------------------------------------------
long double __cdecl sub_80666D0(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  v5 = a2[2] - a1[2];
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (080667A1) --------------------------------------------------------
float *__cdecl sub_80667A1(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = a1 + 1;
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (08066845) --------------------------------------------------------
long double __cdecl sub_8066845(float *a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]
  float v4; // [esp+14h] [ebp-4h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (08066A90) --------------------------------------------------------
long double __cdecl sub_8066A90(float *a1, float *a2)
{
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+20h] [ebp-8h]

  v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sqrt(v4);
  if ( v5 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    v3 = 1.0 / v5;
    *a2 = *a1 * v3;
    a2[1] = a1[1] * v3;
    a2[2] = a1[2] * v3;
  }
  return v5;
}

//----- (08066B4E) --------------------------------------------------------
unsigned int __cdecl sub_8066B4E(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (08066CE8) --------------------------------------------------------
float *__cdecl sub_8066CE8(int a1, int a2, int a3, float a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-13Ch]
  float v6; // [esp+20h] [ebp-138h] BYREF
  float v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9[4]; // [esp+30h] [ebp-128h] BYREF
  int v10[7]; // [esp+40h] [ebp-118h] BYREF
  int i; // [esp+5Ch] [ebp-FCh] BYREF
  float v12[12]; // [esp+60h] [ebp-F8h] BYREF
  float v13[12]; // [esp+90h] [ebp-C8h] BYREF
  int s; // [esp+C0h] [ebp-98h] BYREF
  int v15[3]; // [esp+C4h] [ebp-94h] BYREF
  int v16; // [esp+D0h] [ebp-88h]
  int v17; // [esp+E0h] [ebp-78h]
  float dest[12]; // [esp+F0h] [ebp-68h] BYREF
  int src; // [esp+120h] [ebp-38h] BYREF
  int v20; // [esp+124h] [ebp-34h]
  float v21; // [esp+128h] [ebp-30h]
  int v22; // [esp+12Ch] [ebp-2Ch]
  int v23; // [esp+130h] [ebp-28h]
  float v24; // [esp+134h] [ebp-24h]
  int v25; // [esp+138h] [ebp-20h]
  int v26; // [esp+13Ch] [ebp-1Ch]
  int v27; // [esp+140h] [ebp-18h]
  _DWORD v28[2]; // [esp+150h] [ebp-8h] BYREF

  v6 = *(float *)a2;
  v7 = *(float *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  sub_80677A4((float *)v10, (float *)a2);
  sub_80667A1((float *)v10, &v6, (float *)v9);
  src = v10[0];
  v22 = v10[1];
  v25 = v10[2];
  v20 = v9[0];
  v23 = v9[1];
  v26 = v9[2];
  v21 = v6;
  v24 = v7;
  v27 = v8;
  memcpy(dest, &src, 0x24u);
  LODWORD(dest[1]) = v22;
  LODWORD(dest[2]) = v25;
  LODWORD(dest[3]) = v20;
  LODWORD(dest[5]) = v26;
  dest[6] = v21;
  dest[7] = v24;
  memset(&s, 0, 0x24u);
  v17 = 1065353216;
  v16 = 1065353216;
  s = 1065353216;
  v5 = a4 * 3.141592653589793 / 180.0;
  sub_806B570(v5, (float *)v15, (float *)&s);
  v15[2] = v15[0] ^ 0x80000000;
  v16 = s;
  sub_80679EC((float *)&src, (float *)&s, v13);
  result = sub_80679EC(v13, dest, v12);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a1 + 4 * i) = v12[3 * i] * *(float *)a3
                           + *(float *)&v28[3 * i - 59] * *(float *)(a3 + 4)
                           + *(float *)&v28[3 * i - 58] * *(float *)(a3 + 8);
    result = (float *)&i;
  }
  return result;
}

//----- (080671DE) --------------------------------------------------------
long double __cdecl sub_80671DE(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = 270.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      v2 = v2 + 360.0;
  }
  return v2;
}

//----- (080672AE) --------------------------------------------------------
long double __cdecl sub_80672AE(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]
  float v3; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = -90.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
  }
  return v2;
}

//----- (08067362) --------------------------------------------------------
int __cdecl sub_8067362(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = 270.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
    if ( v3 < 0.0 )
      v3 = v3 + 360.0;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (0806749D) --------------------------------------------------------
int __cdecl sub_806749D(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+24h] [ebp-4h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = -90.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (0806759D) --------------------------------------------------------
float *__cdecl sub_806759D(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+1Ch] [ebp-1Ch] BYREF
  float v6; // [esp+20h] [ebp-18h] BYREF
  float v7; // [esp+24h] [ebp-14h] BYREF
  float v8; // [esp+28h] [ebp-10h] BYREF
  float v9; // [esp+2Ch] [ebp-Ch] BYREF
  float v10; // [esp+30h] [ebp-8h] BYREF
  float v11; // [esp+34h] [ebp-4h]

  v11 = a1[1] * 0.0174532925199433;
  sub_806B570(v11, &v8, &v5);
  v11 = *a1 * 0.0174532925199433;
  result = sub_806B570(v11, &v9, &v6);
  if ( a2 )
  {
    *(float *)a2 = v6 * v5;
    *(float *)(a2 + 4) = v6 * v8;
    result = (float *)(LODWORD(v9) ^ 0x80000000);
    *(_DWORD *)(a2 + 8) = LODWORD(v9) ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v11 = a1[2] * 0.0174532925199433;
    result = sub_806B570(v11, &v10, &v7);
    if ( a3 )
    {
      *a3 = v10 * -1.0 * v9 * v5 + v7 * -1.0 * -v8;
      a3[1] = v10 * -1.0 * v9 * v8 + v7 * -1.0 * v5;
      result = a3 + 2;
      a3[2] = v10 * -1.0 * v6;
    }
    if ( a4 )
    {
      *a4 = v7 * v9 * v5 + v10 * v8;
      a4[1] = v7 * v9 * v8 + -v10 * v5;
      result = a4 + 2;
      a4[2] = v7 * v6;
    }
  }
  return result;
}

//----- (08067726) --------------------------------------------------------
float *__cdecl sub_8067726(float a1, int a2, int a3)
{
  float *result; // eax
  int v4; // [esp+1Ch] [ebp-Ch] BYREF
  int v5; // [esp+20h] [ebp-8h] BYREF
  float v6; // [esp+24h] [ebp-4h]

  v6 = a1 * 0.0174532925199433;
  result = sub_806B570(v6, (float *)&v5, (float *)&v4);
  if ( a2 )
  {
    *(_DWORD *)a2 = v4;
    *(_DWORD *)(a2 + 4) = v5;
    result = (float *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = v5;
    *(_DWORD *)(a3 + 4) = v4 ^ 0x80000000;
    result = (float *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = 0;
  }
  return result;
}

//----- (080677A4) --------------------------------------------------------
void __cdecl sub_80677A4(float *a1, float *a2)
{
  int v2[5]; // [esp+20h] [ebp-28h] BYREF
  float v3; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v3 = 1.0;
  v5 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v3 > fabs(a2[i]) )
    {
      v3 = fabs(a2[i]);
      v5 = i;
    }
  }
  v2[2] = 0;
  v2[1] = 0;
  v2[0] = 0;
  v2[v5] = 1065353216;
  sub_806AB3E(a1, (float *)v2, a2);
  sub_8066845(a1);
}

//----- (080679EC) --------------------------------------------------------
float *__cdecl sub_80679EC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = a1 + 8;
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (0806890D) --------------------------------------------------------
int __cdecl sub_806890D(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (0806899C) --------------------------------------------------------
float *__cdecl sub_806899C(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-4h]
  float v4; // [esp+0h] [ebp-4h]

  v3 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v4 = 1.0 / v3;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v4;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v4;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v4;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v4;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v4;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v4;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v4;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v4;
  result = a1 + 3;
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v4;
  return result;
}

//----- (08069244) --------------------------------------------------------
float *__cdecl sub_8069244(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (080692EE) --------------------------------------------------------
float *__cdecl sub_80692EE(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (08069506) --------------------------------------------------------
float *__cdecl sub_8069506(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[9];
  v5 = a1[1] - a2[10];
  v6 = a1[2] - a2[11];
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = a2 + 8;
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (080696FC) --------------------------------------------------------
float *__cdecl sub_80696FC(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = a1 + 2;
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (0806981E) --------------------------------------------------------
unsigned int __cdecl sub_806981E(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (08069A7F) --------------------------------------------------------
long double __cdecl sub_8069A7F(float *a1)
{
  float v3; // [esp+4h] [ebp-10h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]
  float v6; // [esp+8h] [ebp-Ch]
  float v7; // [esp+Ch] [ebp-8h]
  float v8; // [esp+Ch] [ebp-8h]
  float v9; // [esp+10h] [ebp-4h]
  float v10; // [esp+10h] [ebp-4h]

  v9 = *a1 * *a1;
  v7 = a1[1] * a1[1];
  v5 = a1[2] * a1[2];
  v3 = v9 + v7 + v5 + a1[3] * a1[3];
  if ( v3 == 0.0 )
    return (float)0.0;
  v4 = 1.0 / v3;
  v10 = v9 * v4;
  v8 = v7 * v4;
  v6 = v5 * v4;
  return (float)(v10 + v8 + v6);
}

//----- (08069F4B) --------------------------------------------------------
long double __cdecl sub_8069F4B(float a1, float a2)
{
  float i; // [esp+4h] [ebp-4h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (0806A017) --------------------------------------------------------
long double __cdecl sub_806A017(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (0806A05A) --------------------------------------------------------
long double __cdecl sub_806A05A(float a1)
{
  float v2; // [esp+14h] [ebp-4h]

  v2 = sub_806A017(a1);
  if ( v2 > 180.0 )
    v2 = v2 - 360.0;
  return v2;
}

//----- (0806AB3E) --------------------------------------------------------
float *__cdecl sub_806AB3E(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+Ch] [ebp-2Ch]
  float v6; // [esp+10h] [ebp-28h]
  float v7; // [esp+14h] [ebp-24h]
  float v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-Ch]

  v4 = *a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2];
  v5 = 1.0 / v4;
  v9 = (*a3 * *a2 + a3[1] * a2[1] + a3[2] * a2[2]) * v5;
  v6 = *a3 * v5;
  v7 = a3[1] * v5;
  v8 = a3[2] * v5;
  *a1 = *a2 - v9 * v6;
  a1[1] = a2[1] - v9 * v7;
  result = a2 + 2;
  a1[2] = a2[2] - v9 * v8;
  return result;
}

//----- (0806B014) --------------------------------------------------------
int __cdecl sub_806B014(int *a1, int a2, _DWORD *a3)
{
  int result; // eax
  double v4; // [esp+20h] [ebp-68h] BYREF
  double v5; // [esp+28h] [ebp-60h] BYREF
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9[7]; // [esp+44h] [ebp-44h]
  int v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  int v12; // [esp+68h] [ebp-20h]
  int v13; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]

  v10 = *a1;
  v11 = a1[1];
  v12 = a1[2];
  v13 = v10;
  v14 = v11;
  v15 = v12;
  v8 = 1;
  v9[0] = 2;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i) != 0.0 )
    {
      v6 = *(float *)(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_806B588(v6, &v4, &v5);
      *((float *)&v13 + *(&v8 + 2 * i)) = *((float *)&v10 + *(&v8 + 2 * i)) * v5 - *((float *)&v10 + v9[2 * i]) * v4;
      *((float *)&v13 + v9[2 * i]) = *((float *)&v10 + *(&v8 + 2 * i)) * v4 + *((float *)&v10 + v9[2 * i]) * v5;
    }
    v10 = v13;
    v11 = v14;
    v12 = v15;
  }
  *a3 = v13;
  a3[1] = v14;
  result = v15;
  a3[2] = v15;
  return result;
}

//----- (0806B570) --------------------------------------------------------
float *__cdecl sub_806B570(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0806B588) --------------------------------------------------------
double *__cdecl sub_806B588(double a1, double *a2, double *a3)
{
  long double v3; // fst7
  double *result; // eax

  *a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *a3 = v3;
  return result;
}

//----- (0806B5CC) --------------------------------------------------------
char *__cdecl sub_806B5CC(char *s, char *a2, int a3)
{
  size_t v3; // ebx
  int v4; // ebx
  int j; // [esp+8h] [ebp-10h]
  signed int i; // [esp+Ch] [ebp-Ch]
  signed int v9; // [esp+10h] [ebp-8h]

  v3 = strlen(s);
  v9 = v3 - strlen(a2);
  for ( i = 0; i <= v9; ++i )
  {
    for ( j = 0; a2[j]; ++j )
    {
      if ( a3 )
      {
        if ( s[j] != a2[j] )
          break;
      }
      else
      {
        v4 = toupper(s[j]);
        if ( v4 != toupper(a2[j]) )
          break;
      }
    }
    if ( !a2[j] )
      return s;
    ++s;
  }
  return 0;
}

//----- (0806B69A) --------------------------------------------------------
int __cdecl sub_806B69A(int a1, char *s, int a3)
{
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v6; // ebx
  int v9; // [esp+14h] [ebp-414h]
  int v10; // [esp+18h] [ebp-410h]
  char *v11; // [esp+1Ch] [ebp-40Ch]
  char v12[1032]; // [esp+20h] [ebp-408h] BYREF
  char *v13; // [esp+430h] [ebp+8h]

  while ( *(_BYTE *)a1 )
  {
    if ( *(_BYTE *)a1 == 42 )
    {
      ++a1;
      v10 = 0;
      while ( *(_BYTE *)a1 && *(_BYTE *)a1 != 42 && *(_BYTE *)a1 != 63 )
        v12[v10++] = *(_BYTE *)a1++;
      v12[v10] = 0;
      if ( v12[0] )
      {
        v11 = sub_806B5CC(s, v12, a3);
        if ( !v11 )
          return 0;
        s = &v11[strlen(v12)];
      }
    }
    else if ( *(_BYTE *)a1 == 63 )
    {
      ++a1;
      ++s;
    }
    else if ( *(_BYTE *)a1 == 91 && *(_BYTE *)(a1 + 1) == 91 )
    {
      ++a1;
    }
    else if ( *(_BYTE *)a1 == 91 )
    {
      v13 = (char *)(a1 + 1);
      v9 = 0;
      while ( *v13 && !v9 && (*v13 != 93 || v13[1] == 93) )
      {
        if ( v13[1] == 45 && v13[2] && (v13[2] != 93 || v13[3] == 93) )
        {
          if ( a3 )
          {
            if ( *s >= *v13 && *s <= v13[2] )
              v9 = 1;
          }
          else
          {
            v3 = toupper(*s);
            if ( v3 >= toupper(*v13) )
            {
              v4 = toupper(*s);
              if ( v4 <= toupper(v13[2]) )
                v9 = 1;
            }
          }
          v13 += 3;
        }
        else
        {
          if ( a3 )
          {
            if ( *v13 == *s )
              v9 = 1;
          }
          else
          {
            v5 = toupper(*v13);
            if ( v5 == toupper(*s) )
              v9 = 1;
          }
          ++v13;
        }
      }
      if ( !v9 )
        return 0;
      while ( *v13 && (*v13 != 93 || v13[1] == 93) )
        ++v13;
      a1 = (int)(v13 + 1);
      ++s;
    }
    else
    {
      if ( a3 )
      {
        if ( *(_BYTE *)a1 != *s )
          return 0;
      }
      else
      {
        v6 = toupper(*(char *)a1);
        if ( v6 != toupper(*s) )
          return 0;
      }
      ++a1;
      ++s;
    }
  }
  return 1;
}

//----- (0806BAAA) --------------------------------------------------------
int __cdecl Com_HashKey(int a1, int a2)
{
  int i; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < a2 && *(_BYTE *)(i + a1); ++i )
    v4 += *(char *)(i + a1) * (i + 119);
  return (v4 >> 20) ^ (v4 >> 10) ^ v4;
}

//----- (0806BBCC) --------------------------------------------------------
void *__cdecl Z_MallocInternal(size_t size)
{
  void *s; // [esp+14h] [ebp-4h]

  s = malloc(size);
  if ( !s )
    sub_80D3C9A();
  sub_80D2FE9(s, 0, size);
  return s;
}

//----- (0806BC0A) --------------------------------------------------------
char *__cdecl sub_806BC0A(char *s)
{
  size_t v1; // eax
  char *dest; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  dest = (char *)Z_MallocInternal(v1 + 1);
  strcpy(dest, s);
  return dest;
}

//----- (0806BC3E) --------------------------------------------------------
int sub_806BC3E()
{
  char v1; // [esp+4h] [ebp-4h]
  char v2; // [esp+4h] [ebp-4h]
  char v3; // [esp+4h] [ebp-4h]
  char v4; // [esp+4h] [ebp-4h]

  Com_Printf("%8i bytes total hunk\n", dword_810F4A8[0]);
  Com_Printf("%8i bytes total zone\n", dword_810F4AC[0]);
  Com_Printf("\n", v1);
  Com_Printf("%8i low mark\n", dword_810F488[0]);
  Com_Printf("%8i low permanent\n", dword_810F490[0]);
  if ( *(_DWORD *)dword_810F494 != *(_DWORD *)dword_810F490 )
    Com_Printf("%8i low temp\n", dword_810F494[0]);
  Com_Printf("\n", v2);
  Com_Printf("%8i high mark\n", dword_810F498[0]);
  Com_Printf("%8i high permanent\n", dword_810F4A0[0]);
  if ( *(_DWORD *)dword_810F4A4 != *(_DWORD *)dword_810F4A0 )
    Com_Printf("%8i high temp\n", dword_810F4A4[0]);
  Com_Printf("\n", v3);
  Com_Printf("%8i total hunk in use\n", dword_810F490[0] + dword_810F4A0[0]);
  return Com_Printf("\n", v4);
}
// 806BC75: variable 'v1' is possibly undefined
// 806BCCD: variable 'v2' is possibly undefined
// 806BD25: variable 'v3' is possibly undefined
// 806BD4C: variable 'v4' is possibly undefined

//----- (0806BE13) --------------------------------------------------------
void sub_806BE13()
{
  ;
}

//----- (0806BEC9) --------------------------------------------------------
#error "806BEEC: call analysis failed (funcsize=36)"

//----- (0806C15B) --------------------------------------------------------
_DWORD *sub_806C15B()
{
  char v1; // [esp+4h] [ebp-24h]
  char *format; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]
  int *v4; // [esp+24h] [ebp-4h]

  if ( dword_80E93FC )
    return (_DWORD *)Com_Printf("Hunk memory already initialized; not reallocating.\n", v1);
  if ( sub_80608C4() )
    Com_Error(0, (char *)&byte_80D82E0);
  v4 = Cvar_Get("com_hunkMegs", "128", 33);
  if ( dword_835F480 && *(_DWORD *)(dword_835F480 + 32) )
  {
    v3 = 1;
    format = "Minimum com_hunkMegs for a dedicated server is %i, allocating %i megs.\n";
  }
  else
  {
    v3 = 80;
    format = "Minimum com_hunkMegs is %i, allocating %i megs.\n";
  }
  if ( v4[8] >= v3 )
  {
    *(_DWORD *)dword_810F4A8 = v4[8] << 20;
  }
  else
  {
    *(_DWORD *)dword_810F4A8 = v3 << 20;
    Com_Printf(format, v3);
  }
  dword_80E93FC = (int)malloc(*(_DWORD *)dword_810F4A8 + 31);
  if ( !dword_80E93FC )
    sub_80D3C9A();
  ptr = (void *)dword_80E93FC;
  dword_80E93FC = (dword_80E93FC + 31) & 0xFFFFFFE0;
  sub_806C442();
  return sub_806043E("meminfo", (int)sub_806BC3E);
}
// 806C178: variable 'v1' is possibly undefined
// 80E93FC: using guessed type int dword_80E93FC;
// 835F480: using guessed type int dword_835F480;

//----- (0806C29F) --------------------------------------------------------
int sub_806C29F()
{
  return *(_DWORD *)dword_810F4A8 - (*(_DWORD *)dword_810F4A4 + *(_DWORD *)dword_810F494);
}

//----- (0806C2B8) --------------------------------------------------------
_DWORD *sub_806C2B8()
{
  unsigned int v1; // [esp+10h] [ebp-8h]
  unsigned int v2; // [esp+14h] [ebp-4h]

  v2 = dword_80E93FC + *(_DWORD *)dword_810F490;
  v1 = dword_80E93FC + *(_DWORD *)dword_810F4A8 - *(_DWORD *)dword_810F4A0;
  sub_80CEAE0(dword_80E93FC + *(_DWORD *)dword_810F490, v1);
  return sub_80652A4(v2, v1);
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C315) --------------------------------------------------------
int sub_806C315()
{
  int result; // eax

  result = *(_DWORD *)dword_810F4A0;
  dword_810F49C = *(_DWORD *)dword_810F4A0;
  return result;
}
// 810F49C: using guessed type int dword_810F49C;

//----- (0806C35F) --------------------------------------------------------
_DWORD *sub_806C35F()
{
  *(_DWORD *)dword_810F4A4 = dword_810F49C;
  *(_DWORD *)dword_810F4A0 = dword_810F49C;
  return sub_806C2B8();
}
// 810F49C: using guessed type int dword_810F49C;

//----- (0806C39F) --------------------------------------------------------
int sub_806C39F()
{
  int result; // eax

  result = *(_DWORD *)dword_810F490;
  *(_DWORD *)dword_810F488 = *(_DWORD *)dword_810F490;
  return result;
}

//----- (0806C3AE) --------------------------------------------------------
_DWORD *Hunk_ClearToMarkLow()
{
  *(_DWORD *)dword_810F494 = *(_DWORD *)dword_810F488;
  *(_DWORD *)dword_810F490 = *(_DWORD *)dword_810F488;
  return sub_806C2B8();
}

//----- (0806C3CA) --------------------------------------------------------
void *sub_806C3CA()
{
  char v1; // [esp+4h] [ebp-4h]

  *(_DWORD *)dword_810F488 = 0;
  dword_810F48C = 0;
  *(_DWORD *)dword_810F490 = 0;
  *(_DWORD *)dword_810F494 = 0;
  *(_DWORD *)dword_810F498 = 0;
  dword_810F49C = 0;
  *(_DWORD *)dword_810F4A0 = 0;
  *(_DWORD *)dword_810F4A4 = 0;
  dword_835F484 = 0;
  Com_Printf("Hunk_Clear: reset the hunk ok\n", v1);
  sub_806C2B8();
  return sub_80654E6();
}
// 806C431: variable 'v1' is possibly undefined
// 810F48C: using guessed type int dword_810F48C;
// 810F49C: using guessed type int dword_810F49C;
// 835F484: using guessed type int dword_835F484;

//----- (0806C442) --------------------------------------------------------
int *sub_806C442()
{
  sub_808FD11();
  sub_806C3CA();
  return sub_809AF33();
}

//----- (0806C459) --------------------------------------------------------
void sub_806C459()
{
  free(ptr);
  dword_80E93FC = 0;
  ptr = 0;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C482) --------------------------------------------------------
void *__cdecl sub_806C482(size_t n)
{
  return sub_806C49D(n, 32);
}

//----- (0806C49D) --------------------------------------------------------
void *__cdecl sub_806C49D(size_t n, int a2)
{
  void *s; // [esp+14h] [ebp-4h]
  int v4; // [esp+24h] [ebp+Ch]

  v4 = a2 - 1;
  if ( !dword_80E93FC )
    Com_Error(0, (char *)&byte_80D8400);
  *(_DWORD *)dword_810F4A0 += n;
  *(_DWORD *)dword_810F4A0 = (v4 + *(_DWORD *)dword_810F4A0) & ~v4;
  s = (void *)(dword_80E93FC + *(_DWORD *)dword_810F4A8 - *(_DWORD *)dword_810F4A0);
  *(_DWORD *)dword_810F4A4 = *(_DWORD *)dword_810F4A0;
  if ( *(_DWORD *)dword_810F494 + *(_DWORD *)dword_810F4A0 > *(int *)dword_810F4A8 )
  {
    sub_806BC3E();
    Com_Error(1, (char *)&byte_80D8435, n);
  }
  dword_835F484 = *(_DWORD *)dword_810F490 + *(_DWORD *)dword_810F4A0;
  memset(s, 0, n);
  return s;
}
// 80E93FC: using guessed type int dword_80E93FC;
// 835F484: using guessed type int dword_835F484;

//----- (0806C565) --------------------------------------------------------
int __cdecl sub_806C565(int a1)
{
  *(_DWORD *)dword_810F4A4 += a1;
  *(_DWORD *)dword_810F4A4 = (*(_DWORD *)dword_810F4A4 + 15) & 0xFFFFFFF0;
  if ( *(_DWORD *)dword_810F494 + *(_DWORD *)dword_810F4A4 > *(int *)dword_810F4A8 )
  {
    sub_806BC3E();
    Com_Error(1, (char *)&byte_80D8460, a1);
  }
  return dword_80E93FC + *(_DWORD *)dword_810F4A8 - *(_DWORD *)dword_810F4A4;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C5D0) --------------------------------------------------------
int sub_806C5D0()
{
  int result; // eax

  result = *(_DWORD *)dword_810F4A0;
  *(_DWORD *)dword_810F4A4 = *(_DWORD *)dword_810F4A0;
  return result;
}

//----- (0806C5DF) --------------------------------------------------------
void *__cdecl sub_806C5DF(size_t n)
{
  return sub_806C5FA(n, 32);
}

//----- (0806C5FA) --------------------------------------------------------
void *__cdecl sub_806C5FA(size_t n, int a2)
{
  void *s; // [esp+14h] [ebp-4h]

  *(_DWORD *)dword_810F490 = (a2 - 1 + *(_DWORD *)dword_810F490) & ~(a2 - 1);
  s = (void *)(dword_80E93FC + *(_DWORD *)dword_810F490);
  *(_DWORD *)dword_810F490 += n;
  *(_DWORD *)dword_810F494 = *(_DWORD *)dword_810F490;
  if ( *(_DWORD *)dword_810F490 + *(_DWORD *)dword_810F4A4 > *(int *)dword_810F4A8 )
  {
    sub_806BC3E();
    Com_Error(1, (char *)&byte_80D84A0, n);
  }
  dword_835F484 = *(_DWORD *)dword_810F490 + *(_DWORD *)dword_810F4A0;
  memset(s, 0, n);
  return s;
}
// 80E93FC: using guessed type int dword_80E93FC;
// 835F484: using guessed type int dword_835F484;

//----- (0806C69F) --------------------------------------------------------
int sub_806C69F()
{
  int result; // eax

  result = *(_DWORD *)dword_810F494;
  *(_DWORD *)dword_810F490 = *(_DWORD *)dword_810F494;
  return result;
}

//----- (0806C6AE) --------------------------------------------------------
_DWORD *__cdecl sub_806C6AE(size_t size)
{
  int v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *v4; // [esp+24h] [ebp-4h]
  size_t sizea; // [esp+30h] [ebp+8h]

  if ( !dword_80E93FC )
    return Z_MallocInternal(size);
  sizea = size + 16;
  v3 = *(_DWORD *)dword_810F494;
  *(_DWORD *)dword_810F494 = (*(_DWORD *)dword_810F494 + 15) & 0xFFFFFFF0;
  v4 = (_DWORD *)(dword_80E93FC + *(_DWORD *)dword_810F494);
  *(_DWORD *)dword_810F494 += sizea;
  if ( *(_DWORD *)dword_810F494 + *(_DWORD *)dword_810F4A4 > *(int *)dword_810F4A8 )
  {
    sub_806BC3E();
    Com_Error(
      1,
      (char *)&byte_80D84E0,
      sizea,
      *(_DWORD *)dword_810F494 + *(_DWORD *)dword_810F4A4 - *(_DWORD *)dword_810F4A8);
  }
  *v4 = -1991018350;
  v4[1] = *(_DWORD *)dword_810F494 - v3;
  return v4 + 4;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C77E) --------------------------------------------------------
int __cdecl sub_806C77E(int a1)
{
  *(_DWORD *)dword_810F494 = *(_DWORD *)dword_810F490 + a1;
  if ( *(_DWORD *)dword_810F490 + a1 + *(_DWORD *)dword_810F4A4 > *(int *)dword_810F4A8 )
  {
    sub_806BC3E();
    Com_Error(1, (char *)&byte_80D8520, a1);
  }
  return dword_80E93FC + *(_DWORD *)dword_810F490;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C7D2) --------------------------------------------------------
int sub_806C7D2()
{
  int result; // eax

  result = dword_810F48C;
  *(_DWORD *)dword_810F494 = dword_810F48C;
  return result;
}
// 810F48C: using guessed type int dword_810F48C;

//----- (0806C7E1) --------------------------------------------------------
int sub_806C7E1()
{
  int result; // eax

  result = *(_DWORD *)dword_810F494;
  dword_810F48C = *(_DWORD *)dword_810F494;
  return result;
}
// 810F48C: using guessed type int dword_810F48C;

//----- (0806C7F0) --------------------------------------------------------
int __cdecl sub_806C7F0(void *ptr)
{
  int result; // eax
  _DWORD *v2; // [esp+14h] [ebp-4h]

  if ( !dword_80E93FC )
    return Z_FreeInternal(ptr);
  v2 = (char *)ptr - 16;
  if ( *((_DWORD *)ptr - 4) != -1991018350 )
    Com_Error(0, (char *)&byte_80D8560);
  *v2 = -1991018349;
  result = v2[1];
  *(_DWORD *)dword_810F494 -= result;
  return result;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C84B) --------------------------------------------------------
int Hunk_ClearTempMemoryInternal()
{
  int result; // eax

  if ( dword_80E93FC )
  {
    result = *(_DWORD *)dword_810F490;
    *(_DWORD *)dword_810F494 = *(_DWORD *)dword_810F490;
  }
  return result;
}
// 80E93FC: using guessed type int dword_80E93FC;

//----- (0806C894) --------------------------------------------------------
int __cdecl sub_806C894(_BYTE *a1)
{
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
    v2 = tolower((char)*a1++) + 31337 * v2;
  return (unsigned __int8)v2;
}

//----- (0806C8DA) --------------------------------------------------------
int __cdecl sub_806C8DA(char *a1)
{
  char *i; // [esp+Ch] [ebp+8h]

  if ( *a1 <= 31 || (*(_WORD *)(_ctype_b + 2 * *a1) & 0x400) == 0 && *a1 != 95 )
    return 0;
  for ( i = a1 + 1; *i; ++i )
  {
    if ( *i <= 31 || (*(_WORD *)(_ctype_b + 2 * *i) & 8) == 0 && *i != 95 )
      return 0;
  }
  return 1;
}
// 80F6548: using guessed type int _ctype_b;

//----- (0806C96A) --------------------------------------------------------
int __cdecl sub_806C96A(char *a1, int a2)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !a1 )
    return 0;
  for ( i = dword_810F8C8[256 * a2 + sub_806C894(a1)]; i; i = *(_DWORD *)(i + 64) )
  {
    if ( !Q_stricmp(a1, *(char **)i) )
      return i;
  }
  return 0;
}

//----- (0806C9DF) --------------------------------------------------------
char *__cdecl sub_806C9DF(char *dest, int a2)
{
  char *result; // eax

  strcpy(dest, dword_810F8C0);
  dest[64] = 0;
  *((_DWORD *)dest + 1056) = 0;
  dest[4228] = 0;
  dest[128] = 0;
  *((_DWORD *)dest + 1074) = 1065353216;
  *((_DWORD *)dest + 1075) = 1065353216;
  *((_DWORD *)dest + 1076) = 1065353216;
  *((_DWORD *)dest + 1077) = 1065353216;
  *((_DWORD *)dest + 1078) = 1123024896;
  *((_DWORD *)dest + 1079) = 0;
  *((_DWORD *)dest + 1080) = 0;
  *((_DWORD *)dest + 1081) = 1;
  dest[4328] = 0;
  *((_DWORD *)dest + 1084) = 1065353216;
  *((_DWORD *)dest + 1085) = a2 != 0;
  dest[4329] = 0;
  dest[4330] = 0;
  *((_DWORD *)dest + 1083) = 1065353216;
  result = dest;
  *((_DWORD *)dest + 1087) = 0;
  return result;
}

//----- (0806CAE3) --------------------------------------------------------
int __cdecl sub_806CAE3(char *a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char v5[16392]; // [esp+30h] [ebp-4018h] BYREF
  int v6; // [esp+4038h] [ebp-10h]
  int i; // [esp+403Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
    {
      v6 = 0;
      for ( i = 0; i <= 9; ++i )
      {
        v1 = sprintf(&v5[v6], "%s", off_80E9480[i]);
        v6 += v1;
        if ( i > 7 )
        {
          if ( i == 8 )
          {
            v3 = sprintf(&v5[v6], " or ");
            v6 += v3;
          }
        }
        else
        {
          v2 = sprintf(&v5[v6], ", ");
          v6 += v2;
        }
      }
      Com_Error(1, (char *)&byte_80D8660, dword_810F8C0, a1, v5);
    }
    if ( !Q_stricmp(a1, off_80E9480[i]) )
      break;
  }
  return i;
}
// 80E9480: using guessed type char *off_80E9480[10];

//----- (0806CC0C) --------------------------------------------------------
int __cdecl sub_806CC0C(char *a1)
{
  if ( !Q_stricmp(a1, "streamed") )
    return 2;
  if ( Q_stricmp(a1, "loaded") )
    Com_Error(1, (char *)&byte_80D86C0, dword_810F8C0, a1);
  return 1;
}

//----- (0806CC82) --------------------------------------------------------
int __cdecl sub_806CC82(char *a1)
{
  if ( !Q_stricmp(a1, "looping") )
    return 1;
  if ( Q_stricmp(a1, "nonlooping") )
    Com_Error(1, (char *)&byte_80D8720, dword_810F8C0, a1);
  return 0;
}

//----- (0806CCF8) --------------------------------------------------------
_BOOL4 __cdecl sub_806CCF8(char *s, char *src)
{
  _BOOL4 v3; // [esp+18h] [ebp-10020h]
  size_t v4; // [esp+1Ch] [ebp-1001Ch]
  char dest[65535]; // [esp+20h] [ebp-10018h] BYREF
  char v6; // [esp+1001Fh] [ebp-19h]
  char *s1; // [esp+10028h] [ebp-10h]
  char *v8; // [esp+1002Ch] [ebp-Ch]

  v4 = strlen(s);
  v6 = 0;
  strncpy(dest, src, 0x10000u);
  if ( v6 )
    Com_Error(1, (char *)&byte_80D8780, dword_810F8C0, 0xFFFF);
  sub_806F768(dest);
  s1 = dest;
  if ( dest[0] == 33 )
  {
    do
      ++s1;
    while ( *s1 <= 32 && *s1 );
    if ( !strcmp(s1, s) )
      v3 = 0;
    else
      v3 = strcmp(s1, "all_mp") != 0;
  }
  else
  {
    while ( 1 )
    {
      v8 = strstr(s1, s);
      if ( !v8 )
        return strcmp(s1, "all_mp") == 0;
      if ( (v8 == dest || *(v8 - 1) <= 32) && v8[v4] <= 32 )
        break;
      s1 = v8 + 1;
    }
    v3 = 1;
  }
  return v3;
}

//----- (0806CE7B) --------------------------------------------------------
void __cdecl sub_806CE7B(char *s1, int a2)
{
  if ( !strcasecmp(s1, "master") )
  {
    *(_BYTE *)(a2 + 4329) = 1;
    *(_BYTE *)(a2 + 4330) = 0;
  }
  else
  {
    *(_BYTE *)(a2 + 4329) = 0;
    *(_BYTE *)(a2 + 4330) = 1;
    *(float *)(a2 + 4332) = atof(s1);
  }
}

//----- (0806CEDD) --------------------------------------------------------
void __cdecl sub_806CEDD(char *a1, char *s, int a3, int a4, int a5)
{
  int i; // [esp+20h] [ebp-8h]

  if ( a3 )
  {
    if ( *(_BYTE *)(a4 + a3) )
      Com_Error(1, (char *)&byte_80D87E0, dword_810F8C0, dword_80E9420[a3]);
    *(_BYTE *)(a4 + a3) = 1;
    switch ( a3 )
    {
      case 1:
        if ( strlen(s) > 0x3E )
          Com_Error(1, (char *)&byte_80D8820, dword_810F8C0, s, 63);
        if ( !sub_806C8DA(s) )
          Com_Error(1, (char *)&byte_80D8880, dword_810F8C0, s);
        strcpy((char *)(a5 + 64), s);
        break;
      case 2:
        *(_DWORD *)(a5 + 4224) = atoi(s);
        break;
      case 3:
        if ( strlen(s) > 0x3E )
          Com_Error(1, (char *)&byte_80D88C0, dword_810F8C0, s, 63);
        strcpy((char *)(a5 + 4228), s);
        break;
      case 4:
        if ( strlen(s) > 0xFFE )
          Com_Error(1, (char *)&byte_80D8920, dword_810F8C0, s, 4095);
        for ( i = 0; s[i]; ++i )
        {
          if ( s[i] < 0 )
            Com_Error(1, (char *)&byte_80D8980, dword_810F8C0, s, s[i], (unsigned __int8)s[i]);
        }
        strcpy((char *)(a5 + 128), s);
        break;
      case 5:
        *(float *)(a5 + 4296) = atof(s);
        if ( !*(_BYTE *)(a4 + 6) )
          *(_DWORD *)(a5 + 4300) = *(_DWORD *)(a5 + 4296);
        break;
      case 6:
        *(float *)(a5 + 4300) = atof(s);
        break;
      case 7:
        *(float *)(a5 + 4304) = atof(s);
        if ( !*(_BYTE *)(a4 + 8) )
          *(_DWORD *)(a5 + 4308) = *(_DWORD *)(a5 + 4304);
        break;
      case 8:
        *(float *)(a5 + 4308) = atof(s);
        break;
      case 9:
        *(float *)(a5 + 4312) = atof(s);
        break;
      case 10:
        *(float *)(a5 + 4316) = atof(s);
        break;
      case 11:
        *(_DWORD *)(a5 + 4320) = sub_806CAE3(s);
        break;
      case 12:
        *(_DWORD *)(a5 + 4324) = sub_806CC0C(s);
        break;
      case 13:
        *(_BYTE *)(a5 + 4328) = sub_806CC82(s);
        break;
      case 14:
        *(float *)(a5 + 4336) = atof(s);
        break;
      case 15:
        *(_DWORD *)(a5 + 4340) = sub_806CCF8(a1, s);
        break;
      case 16:
        sub_806CE7B(s, a5);
        break;
      default:
        return;
    }
  }
}
// 80E9420: using guessed type int dword_80E9420[];

//----- (0806D261) --------------------------------------------------------
void __cdecl sub_806D261(int a1)
{
  int v1; // [esp+24h] [ebp-4h]
  int v2; // [esp+24h] [ebp-4h]

  if ( *(float *)(a1 + 4304) > (long double)*(float *)(a1 + 4308) )
  {
    v1 = *(_DWORD *)(a1 + 4308);
    *(_DWORD *)(a1 + 4308) = *(_DWORD *)(a1 + 4304);
    *(_DWORD *)(a1 + 4304) = v1;
  }
  if ( *(float *)(a1 + 4304) <= 0.0 )
    Com_Error(1, (char *)&byte_80D8A20, a1 + 64, *(float *)(a1 + 4304));
  if ( *(float *)(a1 + 4296) > (long double)*(float *)(a1 + 4300) )
  {
    v2 = *(_DWORD *)(a1 + 4300);
    *(_DWORD *)(a1 + 4300) = *(_DWORD *)(a1 + 4296);
    *(_DWORD *)(a1 + 4296) = v2;
  }
  if ( *(float *)(a1 + 4296) < 0.0 )
    Com_Error(1, (char *)&byte_80D8A60, a1 + 64, *(float *)(a1 + 4296));
  if ( *(float *)(a1 + 4316) == 0.0 )
    *(float *)(a1 + 4316) = *(float *)(a1 + 4312) * 5.0;
  if ( *(float *)(a1 + 4312) > (long double)*(float *)(a1 + 4316) )
    Com_Error(1, (char *)&byte_80D8AA0, a1 + 64, *(float *)(a1 + 4312), *(float *)(a1 + 4316));
  if ( *(float *)(a1 + 4312) <= 0.0 )
    Com_Error(1, (char *)&byte_80D8AE0, a1 + 64, *(float *)(a1 + 4312));
}

//----- (0806D439) --------------------------------------------------------
int __cdecl sub_806D439(_DWORD *a1)
{
  int result; // eax
  unsigned int v2; // [esp+10h] [ebp-18h]
  const void *v3; // [esp+14h] [ebp-14h]
  void *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v5 = (int)sub_806C6AE(0x1100u);
  v4 = (void *)v5;
  v3 = a1;
  v2 = 4352;
  if ( (v5 & 4) != 0 )
  {
    *(_DWORD *)v5 = *a1;
    v4 = (void *)(v5 + 4);
    v3 = a1 + 1;
    v2 = 4348;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  *(_DWORD *)(v5 + 4348) = dword_81104E0;
  result = v5;
  dword_81104E0 = v5;
  return result;
}
// 81104E0: using guessed type int dword_81104E0;

//----- (0806D4AF) --------------------------------------------------------
int __cdecl sub_806D4AF(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int result; // eax

  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = a4;
  *(_DWORD *)(a2 + 8) = a5;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 4296);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 4300);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 4304);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 4308);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 4312);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 4316);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 4320);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 4324);
  *(_BYTE *)(a2 + 52) = *(_BYTE *)(a1 + 4328);
  *(_BYTE *)(a2 + 53) = *(_BYTE *)(a1 + 4329);
  *(_BYTE *)(a2 + 54) = *(_BYTE *)(a1 + 4330);
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 4332);
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 4336);
  v6 = sub_806C894(*(_BYTE **)a2);
  *(_DWORD *)(a2 + 64) = dword_810F8C8[256 * a6 + v6];
  v7 = v6 + (a6 << 8);
  result = a2;
  dword_810F8C8[v7] = a2;
  return result;
}

//----- (0806D5E6) --------------------------------------------------------
int __cdecl sub_806D5E6(char *a1, char *haystack, int a3, int a4)
{
  int v6; // [esp+28h] [ebp-1550h]
  int v7; // [esp+2Ch] [ebp-154Ch]
  char s[32]; // [esp+30h] [ebp-1548h] BYREF
  char dest[4340]; // [esp+50h] [ebp-1528h] BYREF
  int v10; // [esp+1144h] [ebp-434h]
  int v11[259]; // [esp+1150h] [ebp-428h]
  int v12; // [esp+155Ch] [ebp-1Ch]
  int i; // [esp+1560h] [ebp-18h]
  char *v14; // [esp+1564h] [ebp-14h]
  char *v15; // [esp+1568h] [ebp-10h] BYREF
  int v16[3]; // [esp+156Ch] [ebp-Ch] BYREF

  if ( (FS_ReadFile(haystack, (int)v16) & 0x80000000) != 0 )
    return a3;
  sub_8084734(haystack);
  sub_8084855(1);
  v15 = (char *)v16[0];
  v12 = 0;
  while ( 1 )
  {
    v14 = (char *)Com_Parse(&v15);
    if ( !v15 )
      break;
    if ( *v14 && *v14 != 35 )
    {
      if ( v12 )
      {
        memset(s, 0, 0x11u);
        sub_806C9DF(dest, a4);
        i = 0;
        while ( 1 )
        {
          if ( *v14 )
            sub_806CEDD(a1, v14, v11[i], (int)s, (int)dest);
          if ( ++i == v12 )
            break;
          v14 = (char *)sub_8085382(&v15);
        }
        if ( !s[1] || !s[3] )
          Com_Error(1, (char *)&byte_80D8B60, dword_810F8C0);
        if ( v10 )
        {
          sub_806D261((int)dest);
          sub_806D439(dest);
          ++a3;
        }
      }
      else
      {
        v7 = 0;
        v6 = 0;
        while ( 2 )
        {
          v11[v12] = 0;
          for ( i = 1; i <= 16; ++i )
          {
            if ( !Q_stricmp((char *)dword_80E9420[i], v14) )
            {
              v11[v12] = i;
              if ( i == 1 )
              {
                v7 = 1;
              }
              else if ( i == 3 )
              {
                v6 = 1;
              }
              break;
            }
          }
          if ( ++v12 != 256 && v15 && *v15 != 10 )
          {
            v14 = (char *)sub_8085382(&v15);
            continue;
          }
          break;
        }
        if ( !v7 || !v6 )
          Com_Error(1, (char *)&byte_80D8B20, dword_810F8C0);
      }
    }
    sub_80854D2(&v15);
  }
  sub_80847D5();
  return a3;
}
// 80E9420: using guessed type int dword_80E9420[];

//----- (0806D87C) --------------------------------------------------------
int __cdecl sub_806D87C(int a1, _DWORD *a2)
{
  int v2; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h] BYREF
  int v9; // [esp+28h] [ebp-10h] BYREF
  int *v10; // [esp+2Ch] [ebp-Ch]
  char *v11; // [esp+30h] [ebp-8h]
  char v12[4]; // [esp+34h] [ebp-4h]

  if ( *a2 == 1 )
  {
    *(_DWORD *)(a1 + 4348) = 0;
    v4 = a1;
  }
  else
  {
    v9 = *a2 / 2;
    v8 = *a2 - v9;
    v5 = 0;
    v11 = (char *)a1;
    while ( v5 < v9 )
    {
      ++v5;
      v11 = (char *)*((_DWORD *)v11 + 1087);
    }
    *(_DWORD *)v12 = sub_806D87C(a1, &v9);
    v11 = (char *)sub_806D87C(v11, &v8);
    *a2 = 0;
    a1 = 0;
    v10 = &a1;
    while ( v9 && v8 )
    {
      v6 = Q_stricmp((char *)(*(_DWORD *)v12 + 64), v11 + 64);
      if ( v6 || (v6 = *(_DWORD *)(*(_DWORD *)v12 + 4224) - *((_DWORD *)v11 + 1056)) != 0 )
      {
        if ( v6 >= 0 )
        {
          *v10 = (int)v11;
          v11 = (char *)*((_DWORD *)v11 + 1087);
          --v8;
        }
        else
        {
          *v10 = *(_DWORD *)v12;
          *(_DWORD *)v12 = *(_DWORD *)(*(_DWORD *)v12 + 4348);
          --v9;
        }
        ++*a2;
        v10 = (int *)(*v10 + 4348);
      }
      else
      {
        v7 = Q_stricmp(*(char **)v12, v11);
        if ( !v7 )
          Com_Error(1, (char *)&byte_80D8BA0, *(_DWORD *)v12, *(_DWORD *)v12 + 64);
        if ( v7 >= 0 )
        {
          v11 = (char *)*((_DWORD *)v11 + 1087);
          --v8;
        }
        else
        {
          *(_DWORD *)v12 = *(_DWORD *)(*(_DWORD *)v12 + 4348);
          --v9;
        }
      }
    }
    if ( v9 )
    {
      *v10 = *(_DWORD *)v12;
      v2 = *a2 + v9;
    }
    else
    {
      *v10 = (int)v11;
      v2 = *a2 + v8;
    }
    *a2 = v2;
    v4 = a1;
  }
  return v4;
}

//----- (0806DA87) --------------------------------------------------------
int __cdecl sub_806DA87(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+28h] [ebp-30h]
  int v4; // [esp+2Ch] [ebp-2Ch]
  size_t v5; // [esp+30h] [ebp-28h]
  size_t v6; // [esp+30h] [ebp-28h]
  int v7; // [esp+34h] [ebp-24h]
  int l; // [esp+34h] [ebp-24h]
  char *v9; // [esp+38h] [ebp-20h]
  char *v10; // [esp+3Ch] [ebp-1Ch]
  char *v11; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  int i; // [esp+48h] [ebp-10h]
  int k; // [esp+48h] [ebp-10h]
  char *s; // [esp+4Ch] [ebp-Ch]
  char *v16; // [esp+50h] [ebp-8h]
  char *dest; // [esp+54h] [ebp-4h]
  char *desta; // [esp+54h] [ebp-4h]

  dword_81104E0 = sub_806D87C(dword_81104E0, &a1);
  v4 = 0;
  v3 = 0;
  dest = 0;
  for ( i = dword_81104E0; i; i = *(_DWORD *)(i + 4348) )
  {
    v5 = strlen((const char *)(i + 64)) + 1;
    if ( dest && !Q_stricmp(dest, (char *)(i + 64)) )
    {
      v3 += v5;
    }
    else
    {
      v4 += v5;
      dest = (char *)(i + 64);
    }
    if ( *(_BYTE *)(i + 128) )
      v4 += strlen((const char *)(i + 128)) + 1;
    v6 = strlen((const char *)(i + 4228)) + 1;
    for ( j = dword_81104E0; j != i; j = *(_DWORD *)(j + 4348) )
    {
      if ( !Q_stricmp((char *)(j + 4228), (char *)(i + 4228)) )
      {
        v3 += v6;
        *(_DWORD *)(i + 4344) = j;
        goto LABEL_15;
      }
    }
    *(_DWORD *)(i + 4344) = 0;
    v4 += v6;
LABEL_15:
    ;
  }
  Com_DPrintf(
    "Sound alias strings use %.1f KB; %.1f KB saved by string sharing\n",
    (double)((long double)v4 / 1024.0),
    (double)((long double)v3 / 1024.0));
  v9 = (char *)Z_MallocInternal(v4 + 68 * a1);
  v10 = &v9[68 * a1];
  v11 = v10;
  desta = 0;
  v7 = 0;
  for ( k = dword_81104E0; k; k = *(_DWORD *)(k + 4348) )
  {
    if ( !desta || Q_stricmp(desta, (char *)(k + 64)) )
    {
      desta = v10;
      strcpy(v10, (const char *)(k + 64));
      v10 += strlen(v10) + 1;
    }
    if ( *(_BYTE *)(k + 128) )
    {
      s = v10;
      strcpy(v10, (const char *)(k + 128));
      v10 += strlen(v10) + 1;
    }
    else
    {
      s = 0;
    }
    if ( *(_DWORD *)(k + 4344) )
    {
      v16 = *(char **)(*(_DWORD *)(k + 4344) + 4292);
    }
    else
    {
      v16 = v10;
      strcpy(v10, (const char *)(k + 4228));
      v10 += strlen(v10) + 1;
    }
    *(_DWORD *)(k + 4292) = v16;
    sub_806D4AF(k, (int)&v9[68 * v7++], (int)desta, (int)v16, (int)s, a2);
  }
  *(&dword_81104C8 + a2) = v9;
  dword_81104D4[a2] = a1;
  dword_8110524[a2] = v4 * a1;
  for ( l = 0; ; ++l )
  {
    result = l;
    if ( l >= v4 )
      break;
    dword_8110524[a2] *= 31337;
    dword_8110524[a2] += v11[l];
  }
  return result;
}
// 81104D4: using guessed type int dword_81104D4[];
// 81104E0: using guessed type int dword_81104E0;
// 8110524: using guessed type int dword_8110524[];

//----- (0806DE0A) --------------------------------------------------------
int __cdecl sub_806DE0A(char *s2, int a2)
{
  int result; // eax
  char *v3; // eax
  char v4; // [esp+4h] [ebp-74h]
  int v5; // [esp+18h] [ebp-60h]
  size_t v6; // [esp+1Ch] [ebp-5Ch]
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  int i; // [esp+64h] [ebp-14h]
  int v9; // [esp+68h] [ebp-10h] BYREF
  void *ptr; // [esp+6Ch] [ebp-Ch]

  v5 = 0;
  if ( a2 == 1 && !strcasecmp(&s1, s2) )
  {
    dword_81104CC = dword_81104D0;
    dword_81104D8 = dword_81104DC;
    sub_80D2FC8(&unk_810FCC8, &unk_81100C8, 0x400u);
  }
  else
  {
    if ( !strncasecmp(s2, "maps/", 5u) )
    {
      strcpy(dest, s2 + 5);
      v6 = strlen(dest);
      if ( !strcasecmp(&dest[v6 - 4], ".bsp") )
      {
        v6 -= 4;
        dest[v6] = 0;
      }
    }
    else
    {
      strcpy(dest, s2);
    }
    sub_806F768(dest);
    ptr = sub_8064009("soundaliases", "csv", (int)&v9);
    if ( !v9 )
      return Com_Printf("WARNING: can't find any sound alias files (soundaliases/*.csv)\n", v4);
    sub_806C7E1();
    for ( i = 0; i < v9; ++i )
    {
      dword_810F8C0 = (char *)*((_DWORD *)ptr + i);
      v3 = va("soundaliases/%s", dword_810F8C0);
      v5 = sub_806D5E6(dest, v3, v5, a2);
    }
    if ( v5 )
      sub_806DA87(v5, a2);
    sub_806C7D2();
    sub_8064032(ptr);
    if ( a2 == 2 )
      strcpy(&s1, s2);
  }
  result = a2 + 135329984;
  *(_BYTE *)(a2 + 135329988) = 1;
  return result;
}
// 806DFAB: conditional instruction was optimized away because of '%arg_4.4==1'
// 806DEF1: variable 'v4' is possibly undefined
// 81104CC: using guessed type int dword_81104CC;
// 81104D0: using guessed type int dword_81104D0;
// 81104D8: using guessed type int dword_81104D8;
// 81104DC: using guessed type int dword_81104DC;

//----- (0806DFEB) --------------------------------------------------------
int __cdecl sub_806DFEB(int a1)
{
  int result; // eax

  result = a1 + 135329984;
  if ( *(_BYTE *)(a1 + 135329988) )
  {
    if ( a1 == 2 )
      s1 = 0;
    if ( *(&dword_81104C8 + a1) )
    {
      if ( a1 != 1 || !dword_81104D0 )
        Z_FreeInternal(*(&dword_81104C8 + a1));
      *(&dword_81104C8 + a1) = 0;
      dword_81104D4[a1] = 0;
      memset((void *)((a1 << 10) + 135329992), 0, 0x400u);
    }
    result = a1 + 135329984;
    *(_BYTE *)(a1 + 135329988) = 0;
  }
  return result;
}
// 81104D0: using guessed type int dword_81104D0;
// 81104D4: using guessed type int dword_81104D4[];

//----- (0806E08C) --------------------------------------------------------
int __cdecl sub_806E08C(char *a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]
  int *v4; // [esp+14h] [ebp-4h]

  v4 = (int *)sub_806C96A(a1, a2);
  if ( v4 )
    v3 = *v4;
  else
    v3 = 0;
  return v3;
}

//----- (0806E0C3) --------------------------------------------------------
float *__cdecl sub_806E0C3(char *a1, int a2)
{
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float v7; // [esp+18h] [ebp-10h]
  float *v8; // [esp+1Ch] [ebp-Ch]
  float *v9; // [esp+20h] [ebp-8h]
  float *v10; // [esp+20h] [ebp-8h]
  float *v11; // [esp+24h] [ebp-4h]

  v9 = (float *)sub_806C96A(a1, a2);
  if ( !v9 )
    return 0;
  v11 = v9;
  v8 = v9;
  v6 = v9[15];
  v5 = 1;
  v4 = *((_DWORD *)v9 + 4);
  while ( v9 != *(&dword_81104C8 + a2) )
  {
    v9 -= 17;
    if ( *(_DWORD *)v9 != *(_DWORD *)v8 )
      break;
    ++v5;
    v6 = v6 + v9[15];
    if ( v9[15] * -2147483600.0 > (long double)rand() * v6 )
      v8 = v9;
    if ( v4 < *((_DWORD *)v9 + 4) )
      v4 = *((_DWORD *)v9 + 4);
  }
  if ( v5 > 2 && v4 == *((_DWORD *)v8 + 4) )
  {
    v7 = 0.0;
    v10 = v11;
    while ( v5 )
    {
      if ( v4 != *((_DWORD *)v10 + 4) )
      {
        v7 = v7 + v10[15];
        if ( v10[15] * -2147483600.0 > (long double)rand() * v7 )
          v8 = v10;
      }
      v10 -= 17;
      --v5;
    }
  }
  *((_DWORD *)v8 + 4) = v4 + 1;
  return v8;
}

//----- (0806E264) --------------------------------------------------------
int __cdecl sub_806E264(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v4 = -252645135 * ((a1 - (int)*(&dword_81104C8 + a2) + 68) >> 2);
  if ( v4 > 0 && v4 <= dword_81104D4[a2] )
    v3 = -252645135 * ((a1 - (int)*(&dword_81104C8 + a2) + 68) >> 2);
  else
    v3 = 0;
  return v3;
}
// 81104D4: using guessed type int dword_81104D4[];

//----- (0806E2C2) --------------------------------------------------------
int __cdecl sub_806E2C2(char *a1)
{
  int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  int v7; // [esp+24h] [ebp-4h] BYREF

  v3 = 0;
  if ( Q_strncmp(a1, "SUBTITLE_", 9) )
    return 0;
  if ( (FS_ReadFile("soundaliases/subtitle.st", (int)&v7) & 0x80000000) == 0 )
  {
    sub_8084734("soundaliases/subtitle.st");
    for ( i = (char *)v7; ; sub_80854D2(&i) )
    {
      s1 = (char *)Com_Parse(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1a = (char *)sub_8085382(&i);
        if ( !Q_stricmp(a1 + 9, s1a) )
        {
          v3 = 1;
          break;
        }
      }
    }
    sub_80847D5();
    FS_FreeFile((void *)v7);
    v2 = v3;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", (char)"soundaliases/subtitle.st");
    v2 = 0;
  }
  return v2;
}

//----- (0806E3C8) --------------------------------------------------------
char *__cdecl sub_806E3C8(char *a1)
{
  int v2; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  char *s1b; // [esp+1Ch] [ebp-Ch]
  char *s1a; // [esp+1Ch] [ebp-Ch]
  char *s1c; // [esp+1Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp-8h] BYREF
  int v8; // [esp+24h] [ebp-4h] BYREF

  if ( (FS_ReadFile("soundaliases/subtitle.st", (int)&v8) & 0x80000000) == 0 )
  {
    sub_8084734("soundaliases/subtitle.st");
    for ( i = (char *)v8; ; sub_80854D2(&i) )
    {
      s1 = (char *)Com_Parse(&i);
      if ( !i )
        break;
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1b = (char *)sub_8085382(&i);
        strcpy(byte_810F4C0, s1b);
        sub_80854D2(&i);
        do
        {
          s1a = (char *)Com_Parse(&i);
          if ( !i )
            Com_Error(1, (char *)&byte_80D8D40, "soundaliases/subtitle.st");
        }
        while ( strcmp(s1a, "LANG_ENGLISH") );
        s1c = (char *)sub_8085382(&i);
        if ( !Q_stricmp(a1, s1c) )
        {
          sub_80847D5();
          FS_FreeFile((void *)v8);
          return byte_810F4C0;
        }
      }
    }
    sub_80847D5();
    FS_FreeFile((void *)v8);
    v2 = 0;
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", (char)"soundaliases/subtitle.st");
    v2 = 0;
  }
  return (char *)v2;
}

//----- (0806E527) --------------------------------------------------------
size_t __cdecl sub_806E527(char *a1, char *a2, int a3)
{
  size_t v3; // eax
  size_t v4; // eax
  size_t v5; // eax
  size_t v6; // eax
  size_t v7; // eax

  v3 = strlen("REFERENCE           ");
  FS_Write("REFERENCE           ", v3, a3);
  v4 = strlen(a1);
  FS_Write(a1, v4, a3);
  v5 = strlen("\r\nLANG_ENGLISH        \"");
  FS_Write("\r\nLANG_ENGLISH        \"", v5, a3);
  v6 = strlen(a2);
  FS_Write(a2, v6, a3);
  v7 = strlen("\"\r\n\r\n");
  return FS_Write("\"\r\n\r\n", v7, a3);
}

//----- (0806E5F3) --------------------------------------------------------
void *__cdecl sub_806E5F3(int a1, char *a2)
{
  void *result; // eax
  size_t v3; // eax
  int v4; // [esp+1Ch] [ebp-22Ch]
  int v5; // [esp+20h] [ebp-228h]
  unsigned int v6; // [esp+24h] [ebp-224h]
  char *s1; // [esp+28h] [ebp-220h]
  char *s1b; // [esp+28h] [ebp-220h]
  char *s1a; // [esp+28h] [ebp-220h]
  char *s2; // [esp+2Ch] [ebp-21Ch]
  char dest[256]; // [esp+30h] [ebp-218h] BYREF
  char filename[260]; // [esp+130h] [ebp-118h] BYREF
  char *v13; // [esp+234h] [ebp-14h] BYREF
  int v14; // [esp+238h] [ebp-10h] BYREF
  char *v15; // [esp+23Ch] [ebp-Ch]

  v4 = 0;
  s2 = (char *)(a1 + 9);
  v5 = sub_80613C7("soundaliases/temp.st");
  if ( !v5 )
    return (void *)Com_Printf("WARNING: Could not open output file %s for writing\n", (char)"soundaliases/temp.st");
  if ( (FS_ReadFile("soundaliases/subtitle.st", (int)&v14) & 0x80000000) == 0 )
  {
    sub_8084734("soundaliases/subtitle.st");
    v13 = (char *)v14;
    v6 = v14;
    while ( 1 )
    {
      s1 = (char *)Com_Parse(&v13);
      if ( !v13 )
        break;
      if ( !strcmp(s1, "ENDMARKER") )
      {
        if ( v6 < (unsigned int)v13 )
        {
          v15 = &v13[-v6 - 11];
          FS_Write((char *)v6, (size_t)v15, v5);
        }
        break;
      }
      if ( !strcmp(s1, "REFERENCE") )
      {
        s1b = (char *)sub_8085382(&v13);
        if ( !strcmp(s1b, s2) )
        {
          if ( v6 < (unsigned int)v13 )
          {
            v15 = &v13[-v6];
            FS_Write((char *)v6, (size_t)&v13[-v6], v5);
          }
          sub_806E527(s2, a2, v5);
          v4 = 1;
          do
          {
            v6 = (unsigned int)v13;
            s1a = (char *)Com_Parse(&v13);
            if ( !v13 )
            {
              v6 = 0;
              goto LABEL_20;
            }
          }
          while ( strcmp(s1a, "REFERENCE") && strcmp(s1a, "ENDMARKER") );
          sub_8084955();
        }
      }
LABEL_20:
      sub_80854D2(&v13);
    }
    if ( !v4 )
      sub_806E527(s2, a2, v5);
    sub_80847D5();
    FS_FreeFile((void *)v14);
    v3 = strlen("\r\nENDMARKER\r\n\r\n\r\n");
    FS_Write("\r\nENDMARKER\r\n\r\n\r\n", v3, v5);
    FS_FCloseFile(v5);
    sub_8060CD2(*(char **)(dword_8357200 + 4), byte_835F380, "soundaliases/temp.st", filename);
    sub_8060CD2(*(char **)(dword_8357200 + 4), byte_835F380, "soundaliases/subtitle.st", dest);
    sub_8060D97(filename, dest);
    result = (void *)sub_806111C(filename);
  }
  else
  {
    Com_Printf("WARNING: Could not read local copy of StringEd file %s\n", (char)"soundaliases/subtitle.st");
    result = FS_FCloseFile(v5);
  }
  return result;
}
// 8357200: using guessed type int dword_8357200;

//----- (0806E946) --------------------------------------------------------
int __cdecl sub_806E946(char *a1)
{
  int v2; // [esp+24h] [ebp-6074h]
  int v3; // [esp+28h] [ebp-6070h]
  char dest[4352]; // [esp+30h] [ebp-6068h] BYREF
  int v5[257]; // [esp+1130h] [ebp-4F68h]
  FILE *stream; // [esp+1534h] [ebp-4B64h]
  int v7; // [esp+1538h] [ebp-4B60h]
  int v8; // [esp+153Ch] [ebp-4B5Ch]
  char s[36]; // [esp+1540h] [ebp-4B58h] BYREF
  char *v10; // [esp+1564h] [ebp-4B34h]
  char *v11; // [esp+1568h] [ebp-4B30h]
  char *src; // [esp+156Ch] [ebp-4B2Ch]
  char v13[256]; // [esp+1570h] [ebp-4B28h] BYREF
  char haystack[256]; // [esp+1670h] [ebp-4A28h] BYREF
  char v15[2048]; // [esp+1770h] [ebp-4928h] BYREF
  char v16[1024]; // [esp+1F70h] [ebp-4128h] BYREF
  char v17[2048]; // [esp+2370h] [ebp-3D28h] BYREF
  char v18[13312]; // [esp+2B70h] [ebp-3528h] BYREF
  char filename[264]; // [esp+5F70h] [ebp-128h] BYREF
  char *v20; // [esp+6078h] [ebp-20h] BYREF
  int v21; // [esp+607Ch] [ebp-1Ch] BYREF
  char v22[4]; // [esp+6080h] [ebp-18h]
  int v23; // [esp+6084h] [ebp-14h]
  int v24; // [esp+6088h] [ebp-10h]
  int i; // [esp+608Ch] [ebp-Ch]

  sub_8060CD2(*(char **)(dword_8357200 + 4), byte_835F380, a1, filename);
  Com_Printf("Processing sound alias file %s..\n", (char)filename);
  stream = fopen(filename, "r+");
  if ( !stream )
    return Com_Printf("WARNING: Can not write to sound alias file %s\n", (char)filename);
  fclose(stream);
  if ( (FS_ReadFile(a1, (int)&v21) & 0x80000000) != 0 )
    return Com_Printf("WARNING: Could not read sound alias file %s\n", (char)a1);
  v7 = sub_80613C7("soundaliases/temp.csv");
  if ( !v7 )
    return Com_Printf("WARNING: Could not open output file %s for writing\n", (char)"soundaliases/temp.csv");
  sub_8084734(a1);
  sub_8084855(1);
  v20 = (char *)v21;
  v24 = 0;
  *(_DWORD *)v22 = 0;
  while ( v20 )
  {
    if ( *v20 == 13 )
    {
      while ( *v20 == 13 )
        ++v20;
    }
    if ( *v20 == 10 )
    {
      ++v20;
      FS_Write("\r\n", 2u, v7);
    }
    v11 = v20;
    src = (char *)Com_Parse(&v20);
    if ( !v20 )
      break;
    if ( !Q_stricmp(src, "#Chateau") )
      i = 0;
    if ( !*src || *src == 35 )
    {
      sub_80854D2(&v20);
      if ( *v11 == 10 )
        FS_Write("\r", 1u, v7);
      goto LABEL_21;
    }
    if ( v24 )
    {
      memset(s, 0, 0x11u);
      sub_806C9DF(dest, 0);
      i = 0;
      while ( 1 )
      {
        strcpy(&v15[1024 * v5[i] + 1024], src);
        if ( *src )
          sub_806CEDD((char *)&byte_80D8EFB, src, v5[i], (int)s, (int)dest);
        if ( ++i == v24 )
          break;
        src = (char *)sub_8085382(&v20);
      }
      if ( !s[1] || !s[3] )
        Com_Error(1, (char *)&byte_80D8B60, dword_810F8C0);
      v8 = 0;
      if ( s[4] )
      {
        v23 = strlen(v18);
        for ( i = 0; i < v23 && (v18[i] > 64 && v18[i] <= 90 || v18[i] > 47 && v18[i] <= 57 || v18[i] == 95); ++i )
          ;
        if ( i < v23 || Q_strncmp(v18, "SUBTITLE_", 9) || !sub_806E2C2(v18) )
          v8 = 1;
      }
      if ( v8 )
      {
        for ( i = 0; i < v24; ++i )
        {
          if ( v5[i] && s[v5[i]] )
          {
            if ( v5[i] == 4 )
            {
              src = sub_806E3C8(v18);
              if ( src )
              {
                Com_sprintf(v15, 0x400u, "%s%s", "SUBTITLE_", src);
                src = sub_8085FE9(v15);
              }
              else
              {
                if ( s[2] )
                  Com_sprintf(v15, 0x400u, "%s%s_%s", "SUBTITLE_", v16, v17);
                else
                  Com_sprintf(v15, 0x400u, "%s%s", "SUBTITLE_", v16);
                src = sub_8085FE9(v15);
                sub_806E5F3((int)v15, v18);
                ++*(_DWORD *)v22;
              }
            }
            else if ( i == v24 - 1 )
            {
              if ( strchr(&v15[1024 * v5[i] + 1024], 44)
                || strchr(&v15[1024 * v5[i] + 1024], 32)
                || strchr(&v15[1024 * v5[i] + 1024], 10)
                || strchr(&v15[1024 * v5[i] + 1024], 13) )
              {
                src = va("\"%s\"", &v15[1024 * v5[i] + 1024]);
              }
              else
              {
                src = va("%s", &v15[1024 * v5[i] + 1024]);
              }
            }
            else if ( strchr(&v15[1024 * v5[i] + 1024], 44)
                   || strchr(&v15[1024 * v5[i] + 1024], 32)
                   || strchr(&v15[1024 * v5[i] + 1024], 10)
                   || strchr(&v15[1024 * v5[i] + 1024], 13) )
            {
              src = va("\"%s\",", &v15[1024 * v5[i] + 1024]);
            }
            else
            {
              src = va("%s,", &v15[1024 * v5[i] + 1024]);
            }
            v23 = strlen(src);
            FS_Write(src, v23, v7);
          }
          else if ( i != v24 - 1 )
          {
            FS_Write(",", 1u, v7);
          }
        }
        FS_Write("\r\n", 2u, v7);
        sub_80854D2(&v20);
      }
      else
      {
        sub_80854D2(&v20);
        v10 = v20;
        FS_Write(v11, v20 - v11, v7);
      }
    }
    else
    {
      v3 = 0;
      v2 = 0;
      while ( 2 )
      {
        v5[v24] = 0;
        for ( i = 1; i <= 16; ++i )
        {
          if ( !Q_stricmp((char *)dword_80E9420[i], src) )
          {
            v5[v24] = i;
            if ( i == 1 )
            {
              v3 = 1;
            }
            else if ( i == 3 )
            {
              v2 = 1;
            }
            break;
          }
        }
        if ( ++v24 != 256 && v20 && *v20 != 10 )
        {
          src = (char *)sub_8085382(&v20);
          continue;
        }
        break;
      }
      if ( !v3 || !v2 )
        Com_Error(1, (char *)&byte_80D8B20, dword_810F8C0);
      sub_80854D2(&v20);
      if ( *v11 == 10 )
        FS_Write("\r", 1u, v7);
LABEL_21:
      v10 = v20;
      FS_Write(v11, v20 - v11, v7);
    }
  }
  sub_80847D5();
  FS_FCloseFile(v7);
  sub_8060CD2(*(char **)(dword_8357200 + 4), byte_835F380, "soundaliases/temp.csv", haystack);
  sub_8060CD2(*(char **)(dword_8357200 + 4), byte_835F380, a1, v13);
  if ( *(_DWORD *)v22 )
    sub_8060D97(haystack, v13);
  sub_806111C(haystack);
  return Com_Printf("Localized %i sound alias subtitles\n", v22[0]);
}
// 80E9420: using guessed type int dword_80E9420[];
// 8357200: using guessed type int dword_8357200;

//----- (0806F42A) --------------------------------------------------------
void __cdecl sub_806F42A(char *filename, char *a2)
{
  void *ptr; // [esp+1Ch] [ebp-Ch]
  int size; // [esp+20h] [ebp-8h]
  FILE *stream; // [esp+24h] [ebp-4h]
  FILE *streama; // [esp+24h] [ebp-4h]

  stream = fopen(filename, "rb");
  if ( stream )
  {
    fseek(stream, 0, 2);
    size = ftell(stream);
    fseek(stream, 0, 0);
    ptr = malloc(size);
    if ( fread(ptr, 1u, size, stream) != size )
      Com_Error(0, (char *)&byte_80D8F60);
    fclose(stream);
    streama = fopen(a2, "wb");
    if ( streama )
    {
      if ( fwrite(ptr, 1u, size, streama) != size )
        Com_Error(0, (char *)&byte_80D8FA0);
      fclose(streama);
      free(ptr);
    }
    else
    {
      free(ptr);
    }
  }
}

//----- (0806F768) --------------------------------------------------------
_BYTE *__cdecl sub_806F768(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower((char)*a1);
    ++a1;
  }
  return a1;
}

//----- (0806F7B0) --------------------------------------------------------
char *__cdecl Com_BeginRedirect(char *a1, int a2, int (__cdecl *a3)(_DWORD))
{
  char *result; // eax

  if ( a1 && a2 )
  {
    if ( a3 )
    {
      dword_812A3C4 = a1;
      dword_812A3C8 = a2;
      dword_812A3CC = a3;
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 812A3CC: using guessed type int (__cdecl *dword_812A3CC)(_DWORD);

//----- (0806F7E9) --------------------------------------------------------
int Com_EndRedirect()
{
  int result; // eax

  if ( dword_812A3CC )
    result = dword_812A3CC(dword_812A3C4);
  dword_812A3C4 = 0;
  dword_812A3C8 = 0;
  dword_812A3CC = 0;
  return result;
}
// 812A3CC: using guessed type int (__cdecl *dword_812A3CC)(_DWORD);

//----- (0806F827) --------------------------------------------------------
void __cdecl Com_PrintMessage(int a1, char *s)
{
  size_t v2; // ebx
  char v3; // al
  size_t v4; // eax
  time_t timer; // [esp+1Ch] [ebp-Ch] BYREF
  struct tm *tp; // [esp+20h] [ebp-8h]

  sub_80C1A14(s, 4096);
  if ( dword_812A3C4 )
  {
    if ( a1 != 4 )
    {
      v2 = strlen(s);
      if ( strlen(dword_812A3C4) + v2 > dword_812A3C8 - 1 )
      {
        dword_812A3CC(dword_812A3C4);
        *dword_812A3C4 = 0;
      }
      sub_8086023(dword_812A3C4, dword_812A3C8, s);
    }
  }
  else
  {
    if ( a1 != 4 )
    {
      if ( dword_835F480 && !*(_DWORD *)(dword_835F480 + 32) )
        sub_80846E0();
      sub_80D43DB(s);
    }
    if ( dword_836066C && *(_DWORD *)(dword_836066C + 32) )
    {
      if ( !dword_81105FC && sub_8060850() && !dword_80E94D0 )
      {
        dword_80E94D0 = 1;
        time(&timer);
        tp = localtime(&timer);
        dword_81105FC = sub_8061529("console_mp_server.log");
        v3 = (unsigned __int8)asctime(tp);
        Com_Printf("logfile opened on %s\n", v3);
        if ( *(int *)(dword_836066C + 32) > 1 )
          sub_8060AB8(dword_81105FC);
        dword_80E94D0 = 0;
      }
      if ( dword_81105FC && sub_8060850() )
      {
        v4 = strlen(s);
        FS_Write(s, v4, dword_81105FC);
      }
    }
  }
}
// 80E94D0: using guessed type int dword_80E94D0;
// 81105FC: using guessed type int dword_81105FC;
// 812A3CC: using guessed type int (__cdecl *dword_812A3CC)(_DWORD);
// 835F480: using guessed type int dword_835F480;
// 836066C: using guessed type int dword_836066C;

//----- (0806FC10) --------------------------------------------------------
int __cdecl Com_Printf(char *format, char a2)
{
  int result; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]

  __varargs = &a2;
  vsnprintf(s, 0x1000u, format, &a2);
  s[4095] = 0;
  Com_PrintMessage(0, s);
  return result;
}

//----- (0806FC5F) --------------------------------------------------------
int Com_DPrintf(char *format, ...)
{
  int result; // eax
  char s[4108]; // [esp+10h] [ebp-1018h] BYREF
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1034h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( dword_835F4A8 )
  {
    result = dword_835F4A8;
    if ( *(_DWORD *)(dword_835F4A8 + 32) )
    {
      va_copy(__varargs, va);
      vsnprintf(s, 0x1000u, format, va);
      s[4095] = 0;
      result = Com_Printf("%s", (char)s);
    }
  }
  return result;
}
// 835F4A8: using guessed type int dword_835F4A8;

//----- (0806FCC4) --------------------------------------------------------
void __cdecl sub_806FCC4(const char *a1)
{
  sub_80846B8();
  sub_80846FE();
  sub_8091A22(a1);
  sub_806C442();
  CL_StartHunkUsers();
}

//----- (0806FCF2) --------------------------------------------------------
void *Com_ErrorCleanup()
{
  char v1; // [esp+4h] [ebp-14h]

  switch ( dword_8110550 )
  {
    case 2:
      sub_806FCC4("EXE_DISCONNECTEDFROMOWNLISTENSERVER");
      com_errorEntered_ = 0;
      break;
    case 5:
      sub_806FCC4("EXE_ENDOFGAME");
      com_errorEntered_ = 0;
      break;
    case 1:
    case 3:
      Com_Printf("********************\nERROR: %s\n********************\n", (char)byte_835F4C0);
      sub_806FCC4(byte_835F4C0);
      com_errorEntered_ = 0;
      if ( dword_8110550 == 1 && Cvar_Get("r_vc_compile", "0", 0)[8] == 2 )
        sub_8070034();
      break;
    case 4:
      sub_806FCC4("EXE_SERVERDIDNTHAVECD");
      if ( dword_8360658 && *(_DWORD *)(dword_8360658 + 32) )
      {
        com_errorEntered_ = 0;
        sub_80846F4();
      }
      else
      {
        Com_Printf("Server didn't have CD\n", v1);
      }
      break;
  }
  return sub_807239D();
}
// 806FDF1: variable 'v1' is possibly undefined
// 8110550: using guessed type int dword_8110550;
// 836057C: using guessed type int com_errorEntered_;
// 8360658: using guessed type int dword_8360658;

//----- (0806FDFD) --------------------------------------------------------
void sub_806FDFD()
{
  if ( !++dword_835F4A4 )
    ++dword_835F4A4;
}
// 835F4A4: using guessed type int dword_835F4A4;

//----- (0806FE17) --------------------------------------------------------
int sub_806FE17()
{
  sub_806FDFD();
  Hunk_ClearTempMemoryInternal();
  return sub_806C5D0();
}

//----- (0806FE2E) --------------------------------------------------------
void sub_806FE2E()
{
  dword_80EE80C = 0;
}
// 80EE80C: using guessed type int dword_80EE80C;

//----- (0806FE3D) --------------------------------------------------------
int *__cdecl sub_806FE3D(char *s1)
{
  Cvar_Get("com_errorMessage", (char *)&byte_80D91F1, 64);
  return Cvar_Set("com_errorMessage", s1);
}

//----- (0806FE74) --------------------------------------------------------
void __noreturn Com_Error(int a1, char *format, ...)
{
  char *v2; // eax
  char dest[4104]; // [esp+10h] [ebp-1018h] BYREF
  int v4; // [esp+1018h] [ebp-10h]
  __gnuc_va_list __varargs; // [esp+101Ch] [ebp-Ch]
  va_list va; // [esp+1038h] [ebp+10h] BYREF

  va_start(va, format);
  if ( com_errorEntered_ )
    Sys_Error("recursive error after: %s", byte_835F4C0);
  sub_806FE17();
  va_copy(__varargs, va);
  vsprintf(byte_835F4C0, format, va);
  strcpy(dest, byte_835F4C0);
  if ( a1 == 6 || a1 == 7 )
    a1 = 1;
  com_errorEntered_ = 1;
  sub_807603C((char **)&byte_80D91F1, (char **)&byte_80D91F1);
  if ( a1 != 3 && a1 != 4 && a1 != 5 )
    sub_806FE3D(byte_835F4C0);
  if ( a1 != 3 )
    sub_80A9892();
  sub_806FE2E();
  sub_8084819();
  sub_8063305();
  if ( a1 == 1 )
    Cbuf_Init();
  sub_80724DB(1, 0);
  sub_80724DB(2, 0);
  v4 = sub_80D563C();
  if ( v4 - dword_8110540 > 99 )
  {
    dword_8110544 = 0;
  }
  else if ( ++dword_8110544 > 3 )
  {
    a1 = 0;
  }
  dword_8110540 = v4;
  if ( a1 != 2 && a1 != 5 && a1 != 1 && a1 != 3 && a1 != 4 )
  {
    sub_8084650();
    v2 = ::va(aExeServerFatal, dest);
    sub_8091A22(v2);
    sub_806C3CA();
    sub_8071A4B();
    Sys_Error("%s", byte_835F4C0);
  }
  dword_8110550 = a1;
  longjmp(env, -1);
}
// 8110540: using guessed type int dword_8110540;
// 8110544: using guessed type int dword_8110544;
// 8110550: using guessed type int dword_8110550;
// 836057C: using guessed type int com_errorEntered_;

//----- (08070034) --------------------------------------------------------
void __noreturn sub_8070034()
{
  if ( !com_errorEntered_ )
  {
    sub_806FE17();
    sub_806FE2E();
    sub_8091A22("EXE_SERVERQUIT");
    sub_806C3CA();
    sub_8071A4B();
    sub_80655EA(1);
    sub_8065536();
    sub_8065590();
  }
  sub_80D3354();
}
// 836057C: using guessed type int com_errorEntered_;

//----- (08070080) --------------------------------------------------------
char *__cdecl Com_ParseCommandLine(char *a1)
{
  char *result; // eax

  dword_83604E0 = a1;
  dword_835F4B8 = 1;
  while ( 1 )
  {
    result = a1;
    if ( !*a1 )
      break;
    result = a1;
    if ( *a1 == 43 || (result = a1, *a1 == 10) )
    {
      if ( dword_835F4B8 == 32 )
        return result;
      (&dword_83604E0)[dword_835F4B8++] = a1 + 1;
      *a1 = 0;
    }
    ++a1;
  }
  return result;
}
// 835F4B8: using guessed type int dword_835F4B8;

//----- (080700DF) --------------------------------------------------------
int sub_80700DF()
{
  char *v0; // eax
  char *v1; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < dword_835F4B8; ++i )
  {
    Cmd_TokenizeString((char **)(&dword_83604E0)[i]);
    v0 = Cmd_Argv(0);
    if ( Q_stricmp(v0, "safe") )
    {
      v1 = Cmd_Argv(0);
      if ( Q_stricmp(v1, "cvar_restart") )
        continue;
    }
    *(&dword_83604E0)[i] = 0;
    return 1;
  }
  return dword_80E94CC;
}
// 80E94CC: using guessed type int dword_80E94CC;
// 835F4B8: using guessed type int dword_835F4B8;

//----- (08070184) --------------------------------------------------------
int __cdecl Com_StartupVariable(char *s2)
{
  int result; // eax
  char *v2; // eax
  char *v3; // eax
  int *v4; // edx
  char *s1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_835F4B8 )
      break;
    Cmd_TokenizeString((char **)(&dword_83604E0)[i]);
    v2 = Cmd_Argv(0);
    if ( !strcmp(v2, "set") )
    {
      s1 = Cmd_Argv(1u);
      if ( !s2 || !strcmp(s1, s2) )
      {
        v3 = Cmd_Argv(2u);
        Cvar_Set(s1, v3);
        v4 = Cvar_Get(s1, (char *)&byte_80D91F1, 0);
        v4[4] |= 0x80u;
      }
    }
  }
  return result;
}
// 835F4B8: using guessed type int dword_835F4B8;

//----- (08070256) --------------------------------------------------------
int Com_AddStartupCommands()
{
  int v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v1 = 0;
  for ( i = 0; i < dword_835F4B8; ++i )
  {
    if ( (&dword_83604E0)[i] && *(&dword_83604E0)[i] )
    {
      if ( Q_stricmpn((&dword_83604E0)[i], "set", 3) )
        v1 = 1;
      Cbuf_AddText((&dword_83604E0)[i]);
      Cbuf_AddText("\n");
    }
  }
  return v1;
}
// 835F4B8: using guessed type int dword_835F4B8;

//----- (080702EC) --------------------------------------------------------
int __cdecl Info_Print(char *a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-424h]
  char *s; // [esp+1Ch] [ebp-40Ch]
  char *sa; // [esp+1Ch] [ebp-40Ch]
  char v5[512]; // [esp+20h] [ebp-408h] BYREF
  char v6[520]; // [esp+220h] [ebp-208h] BYREF

  if ( *a1 == 92 )
    ++a1;
  while ( 1 )
  {
    result = (int)a1;
    if ( !*a1 )
      break;
    s = v6;
    while ( *a1 && *a1 != 92 )
      *s++ = *a1++;
    if ( s - v6 > 19 )
    {
      *s = 0;
    }
    else
    {
      memset(s, 32, 20 - (s - v6));
      v6[20] = 0;
    }
    Com_Printf("%s", (char)v6);
    if ( !*a1 )
      return Com_Printf("MISSING VALUE\n", v2);
    sa = v5;
    ++a1;
    while ( *a1 && *a1 != 92 )
      *sa++ = *a1++;
    *sa = 0;
    if ( *a1 )
      ++a1;
    Com_Printf("%s\n", (char)v5);
  }
  return result;
}
// 80703C4: variable 'v2' is possibly undefined

//----- (0807043A) --------------------------------------------------------
int Com_InitJournaling()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]

  Com_StartupVariable("journal");
  dword_83604D0 = (int)Cvar_Get("journal", "0", 16);
  result = dword_83604D0;
  if ( *(_DWORD *)(dword_83604D0 + 32) )
  {
    if ( *(_DWORD *)(dword_83604D0 + 32) == 1 )
    {
      Com_Printf("Journaling events\n", v1);
      *(_DWORD *)dword_8360650 = sub_80613C7("journal.dat");
      result = sub_80613C7("journaldata.dat");
      *(_DWORD *)dword_8360570 = result;
    }
    else
    {
      result = dword_83604D0;
      if ( *(_DWORD *)(dword_83604D0 + 32) == 2 )
      {
        Com_Printf("Replaying journaled events\n", v1);
        FS_FOpenFileRead("journal.dat", (int)dword_8360650, 1);
        result = FS_FOpenFileRead("journaldata.dat", (int)dword_8360570, 1);
      }
    }
    if ( !*(_DWORD *)dword_8360650 || !*(_DWORD *)dword_8360570 )
    {
      Cvar_Set("com_journal", "0");
      *(_DWORD *)dword_8360650 = 0;
      *(_DWORD *)dword_8360570 = 0;
      result = Com_Printf("Couldn't open journal files\n", v2);
    }
  }
  return result;
}
// 807048F: variable 'v1' is possibly undefined
// 8070548: variable 'v2' is possibly undefined
// 83604D0: using guessed type int dword_83604D0;

//----- (0807054F) --------------------------------------------------------
_DWORD *__stdcall sub_807054F(_DWORD *a1)
{
  int v2[4]; // [esp+10h] [ebp-38h] BYREF
  size_t size; // [esp+20h] [ebp-28h]
  char *v4; // [esp+24h] [ebp-24h]
  size_t v5; // [esp+3Ch] [ebp-Ch]

  if ( *(_DWORD *)(dword_83604D0 + 32) == 2 )
  {
    v5 = FS_Read((char *)v2, 0x18u, *(int *)dword_8360650);
    if ( v5 != 24 )
      Com_Error(0, "EXE_ERR_JOURNAL_FILE_READ");
    if ( size )
    {
      v4 = (char *)Z_MallocInternal(size);
      v5 = FS_Read(v4, size, *(int *)dword_8360650);
      if ( v5 != size )
        Com_Error(0, "EXE_ERR_JOURNAL_FILE_READ");
    }
  }
  else
  {
    sub_80D4140(v2);
    if ( *(_DWORD *)(dword_83604D0 + 32) == 1 )
    {
      v5 = FS_Write((char *)v2, 0x18u, *(int *)dword_8360650);
      if ( v5 != 24 )
        Com_Error(0, "EXE_ERR_JOURNAL_FILE_WRITE");
      if ( size )
      {
        v5 = FS_Write(v4, size, *(int *)dword_8360650);
        if ( v5 != size )
          Com_Error(0, "EXE_ERR_JOURNAL_FILE_WRITE");
      }
    }
  }
  *a1 = v2[0];
  a1[1] = v2[1];
  a1[2] = v2[2];
  a1[3] = v2[3];
  a1[4] = size;
  a1[5] = v4;
  return a1;
}
// 83604D0: using guessed type int dword_83604D0;

//----- (080706C6) --------------------------------------------------------
void *Com_InitPushEvent()
{
  void *result; // eax

  result = memset(dword_8110600, 0, 0x1800u);
  dword_80E94C0 = 0;
  dword_80E94C4 = 0;
  return result;
}
// 80E94C0: using guessed type int dword_80E94C0;
// 80E94C4: using guessed type int dword_80E94C4;
// 8110600: using guessed type int dword_8110600[];

//----- (080706FE) --------------------------------------------------------
int __cdecl sub_80706FE(int *a1)
{
  int result; // eax
  int *v2; // [esp+4h] [ebp-4h]

  v2 = &dword_8110600[6 * (unsigned __int8)dword_80E94C0];
  if ( dword_80E94C0 - dword_80E94C4 <= 255 )
  {
    dword_80E94DC = 0;
  }
  else
  {
    if ( !dword_80E94DC )
    {
      dword_80E94DC = 1;
      Com_Printf("WARNING: Com_PushEvent overflow\n", (char)v2);
    }
    if ( v2[5] )
      Z_FreeInternal((void *)v2[5]);
    ++dword_80E94C4;
  }
  *v2 = *a1;
  v2[1] = a1[1];
  v2[2] = a1[2];
  v2[3] = a1[3];
  v2[4] = a1[4];
  result = a1[5];
  v2[5] = result;
  ++dword_80E94C0;
  return result;
}
// 8070758: variable 'v2' is possibly undefined
// 80E94C0: using guessed type int dword_80E94C0;
// 80E94C4: using guessed type int dword_80E94C4;
// 80E94DC: using guessed type int dword_80E94DC;
// 8110600: using guessed type int dword_8110600[];

//----- (08070829) --------------------------------------------------------
_DWORD *__stdcall sub_8070829(_DWORD *a1)
{
  int v1; // edx

  if ( dword_80E94C0 <= dword_80E94C4 )
  {
    sub_807054F(a1);
  }
  else
  {
    v1 = 6 * (unsigned __int8)dword_80E94C4++;
    *a1 = dword_8110600[v1];
    a1[1] = dword_8110604[v1];
    a1[2] = dword_8110608[v1];
    a1[3] = dword_811060C[v1];
    a1[4] = dword_8110610[v1];
    a1[5] = dword_8110614[v1];
  }
  return a1;
}
// 80E94C0: using guessed type int dword_80E94C0;
// 80E94C4: using guessed type int dword_80E94C4;
// 8110600: using guessed type int dword_8110600[];
// 8110604: using guessed type int dword_8110604[];
// 8110608: using guessed type int dword_8110608[];
// 811060C: using guessed type int dword_811060C[];
// 8110610: using guessed type int dword_8110610[];
// 8110614: using guessed type int dword_8110614[];

//----- (080708B6) --------------------------------------------------------
int __cdecl sub_80708B6(int *a1, int a2)
{
  int result; // eax
  char v3; // [esp+1Ch] [ebp-Ch]
  char v4; // [esp+24h] [ebp-4h]

  v4 = 0;
  if ( *(_DWORD *)(dword_8360660 + 32) )
    v4 = sub_80D563C();
  SV_ReadPackets(*a1, a1[1], a1[2], a1[3], a1[4], a2);
  result = dword_8360660;
  if ( *(_DWORD *)(dword_8360660 + 32) )
  {
    v3 = sub_80D563C() - v4;
    result = dword_8360660;
    if ( *(_DWORD *)(dword_8360660 + 32) == 3 )
      result = Com_Printf("SV_PacketEvent time: %i\n", v3);
  }
  return result;
}
// 8360660: using guessed type int dword_8360660;

//----- (08070944) --------------------------------------------------------
int sub_8070944()
{
  char v1; // [esp+4h] [ebp-4094h]
  int v2[3]; // [esp+30h] [ebp-4068h] BYREF
  size_t n; // [esp+3Ch] [ebp-405Ch]
  char v4[4]; // [esp+50h] [ebp-4048h] BYREF
  int s; // [esp+4050h] [ebp-48h] BYREF
  int v6; // [esp+4054h] [ebp-44h]
  int v7; // [esp+4058h] [ebp-40h]
  int v8; // [esp+405Ch] [ebp-3Ch]
  int v9; // [esp+4060h] [ebp-38h]
  int v10; // [esp+4070h] [ebp-28h] BYREF
  char v11[4]; // [esp+4074h] [ebp-24h]
  int v12; // [esp+407Ch] [ebp-1Ch]
  int v13; // [esp+4080h] [ebp-18h]
  void *ptr; // [esp+4084h] [ebp-14h]

  MSG_Init(v2, (int)v4, 0x4000);
  while ( 1 )
  {
    sub_8070829(&v10);
    if ( !*(_DWORD *)v11 )
      break;
    switch ( *(_DWORD *)v11 )
    {
      case 0:
        continue;
      case 1:
        v1 = v12;
        sub_80846CC();
        break;
      case 2:
        sub_80846B3();
        break;
      case 3:
        v1 = v12;
        sub_808469F();
        break;
      case 4:
        v1 = v12;
        sub_80846EA();
        break;
      case 5:
        Cbuf_AddText((char *)ptr);
        Z_FreeInternal(ptr);
        Cbuf_AddText("\n");
        break;
      case 6:
        s = *(_DWORD *)ptr;
        v6 = *((_DWORD *)ptr + 1);
        v7 = *((_DWORD *)ptr + 2);
        v8 = *((_DWORD *)ptr + 3);
        v9 = *((_DWORD *)ptr + 4);
        n = v13 - 20;
        if ( (unsigned int)(v13 - 20) <= v2[2] )
        {
          memcpy((void *)v2[1], (char *)ptr + 20, n);
          Z_FreeInternal(ptr);
          if ( *(_DWORD *)(dword_8360560 + 32) )
          {
            sub_80708B6(&s, (int)v2);
          }
          else
          {
            v1 = v6;
            sub_80846AE();
          }
        }
        else
        {
          Z_FreeInternal(ptr);
          Com_Printf("Com_EventLoop: oversize packet\n", v1);
        }
        break;
      default:
        Com_Error(0, (char *)&byte_80D9380, *(_DWORD *)v11);
    }
  }
  while ( sub_8084061(0, &s, (int)v2) )
    sub_80846AE();
  while ( sub_8084061(1, &s, (int)v2) )
  {
    if ( *(_DWORD *)(dword_8360560 + 32) )
      sub_80708B6(&s, (int)v2);
  }
  return v10;
}
// 8070B47: variable 'v1' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (08070BE8) --------------------------------------------------------
int Com_Milliseconds()
{
  int v1; // [esp+10h] [ebp-28h] BYREF
  int v2; // [esp+14h] [ebp-24h]

  do
  {
    sub_807054F(&v1);
    if ( v2 )
      sub_80706FE(&v1);
  }
  while ( v2 );
  return v1;
}

//----- (08070C45) --------------------------------------------------------
void __noreturn sub_8070C45()
{
  if ( Cmd_Argc() > 1 )
    Com_Error(1, (char *)&byte_80D93FC);
  Com_Error(0, (char *)&byte_80D9410);
}

//----- (08070C81) --------------------------------------------------------
void sub_8070C81()
{
  char *v0; // eax
  char v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    v0 = Cmd_Argv(1u);
    v3 = atof(v0);
    v2 = Com_Milliseconds();
    while ( (long double)(Com_Milliseconds() - v2) * 0.001 <= v3 )
      ;
  }
  else
  {
    Com_Printf("freeze <seconds>\n", v1);
  }
}
// 8070C98: variable 'v1' is possibly undefined

//----- (08070CEE) --------------------------------------------------------
void sub_8070CEE()
{
  MEMORY[0] = 305419896;
}

//----- (08070CFD) --------------------------------------------------------
char *sub_8070CFD()
{
  return strcpy(a123456789, "                ");
}

//----- (08070D19) --------------------------------------------------------
char *sub_8070D19()
{
  char *result; // eax
  size_t n; // [esp+18h] [ebp-30h]
  void *src; // [esp+1Ch] [ebp-2Ch] BYREF
  char dest[16]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+30h] [ebp-18h] BYREF

  n = FS_ReadFile("cdkey", 0);
  if ( FS_ReadFile("cdkey", (int)&src)
    || (memcpy(dest, src, n), n != 21)
    || (memcpy(a123456789, dest, 0x10u),
        byte_80E94F0 = 0,
        memcpy(&unk_80E9502, &v4, 4u),
        byte_80E9506 = 0,
        (result = (char *)sub_8084703()) == 0) )
  {
    result = sub_8070CFD();
  }
  return result;
}
// 80E94F0: using guessed type char byte_80E94F0;
// 80E9506: using guessed type char byte_80E9506;

//----- (08070DE3) --------------------------------------------------------
int __cdecl sub_8070DE3(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < a2; ++i )
    v3 = *(char *)(a1 + i) + 31337 * v3;
  return (v3 & 0xFFFFFFF) + 1;
}

//----- (08070E33) --------------------------------------------------------
int sub_8070E33()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h] BYREF

  v1 = FS_ReadFile("configure_mp.csv", (int)&v2);
  if ( v1 < 0 )
    Com_Error(0, aExeErrNotFound);
  sub_8070DE3(v2, v1);
  FS_FreeFile((void *)v2);
  return sub_80D3C90();
}

//----- (08070E96) --------------------------------------------------------
void sub_8070E96()
{
  ;
}

//----- (08070E9B) --------------------------------------------------------
int Script_Init()
{
  int v1; // [esp+Ch] [ebp-Ch]

  v1 = 0;
  if ( *(_DWORD *)(dword_835F4A8 + 32) || *(_DWORD *)(dword_836066C + 32) )
    v1 = 1;
  return sub_80A9820(v1, *(_DWORD *)(dword_8360568 + 32), *(_DWORD *)(dword_835F4A8 + 32));
}
// 835F4A8: using guessed type int dword_835F4A8;
// 8360568: using guessed type int dword_8360568;
// 836066C: using guessed type int dword_836066C;

//----- (08070EF8) --------------------------------------------------------
int __cdecl Com_Init(int a1)
{
  char *v1; // eax
  unsigned __int16 v2; // ax
  char v4; // [esp+4h] [ebp-24h]
  char *s2; // [esp+18h] [ebp-10h]

  Com_Printf("%s %s build %s %s\n", (char)"COD MP");
  if ( __sigsetjmp(env, 0) )
  {
    Com_ErrorCleanup();
    Sys_Error("Error during initialization");
  }
  Com_InitPushEvent();
  Cvar_Init();
  Com_ParseCommandLine((char *)a1);
  Swap_Init();
  Cbuf_Init();
  sub_806BE13();
  Cmd_Init();
  Com_StartupVariable(0);
  Com_StartupVariable("developer");
  CL_InitKeyCommands();
  FS_InitFilesystem();
  Com_InitJournaling();
  Cbuf_AddText("exec default_mp.cfg\n");
  Cbuf_AddText("exec language.cfg\n");
  Cbuf_AddText("exec config_mp_server.cfg\n");
  Cbuf_AddText("exec autoexec_mp.cfg\n");
  if ( sub_80700DF() )
    Cbuf_AddText("exec safemode_mp_server.cfg\n");
  Cbuf_Execute();
  dword_8360564 = (int)Cvar_Get("com_recommendedSet", "0", 1);
  if ( !*(_DWORD *)(dword_8360564 + 32) || sub_8070E33() )
  {
    sub_8070E96();
    Cvar_Set("com_recommendedSet", "1");
  }
  if ( sub_80D3C86() )
    sub_8070E96();
  Com_StartupVariable(0);
  dword_835F480 = (int)Cvar_Get("dedicated", "2", 64);
  sub_806C15B();
  dword_8360678 &= 0xFFFFFFFE;
  dword_83604C0 = (int)Cvar_Get("com_maxfps", "85", 1);
  dword_835F4A8 = (int)Cvar_Get("developer", "0", 256);
  dword_8360568 = (int)Cvar_Get("developer_script", "0", 256);
  dword_836066C = (int)Cvar_Get("logfile", "0", 0);
  dword_835F4B4 = (int)Cvar_Get("timescale", "1", 2560);
  dword_8360574 = (int)Cvar_Get("fixedtime", "0", 512);
  dword_835F4B0 = (int)Cvar_Get("viewlog", "0", 512);
  dword_8360660 = (int)Cvar_Get("com_speeds", "0", 0);
  dword_835F4A0 = (int)Cvar_Get("sv_paused", "0", 64);
  dword_8360654 = (int)Cvar_Get("cl_paused", "0", 64);
  dword_8360560 = (int)Cvar_Get("sv_running", "0", 64);
  dword_8360658 = (int)Cvar_Get("cl_running", "0", 64);
  dword_8360578 = (int)Cvar_Get("com_introplayed", "0", 1);
  dword_836064C = (int)Cvar_Get("com_animCheck", "0", 0);
  dword_835F484 = 0;
  if ( *(_DWORD *)(dword_835F480 + 32) && !*(_DWORD *)(dword_835F4B0 + 32) )
    Cvar_Set("viewlog", "1");
  if ( dword_835F4A8 && *(_DWORD *)(dword_835F4A8 + 32) )
  {
    sub_806043E("error", (int)sub_8070C45);
    sub_806043E("crash", (int)sub_8070CEE);
    sub_806043E("freeze", (int)sub_8070C81);
  }
  sub_806043E("quit", (int)sub_8070034);
  sub_806043E("writeconfig", (int)sub_80715BA);
  sub_806043E("writedefaults", (int)sub_8071636);
  v1 = sub_8049FB0();
  s2 = va("%s %s build %s %s", "COD MP", "1.5", v1, "linux-i386");
  dword_8360664 = (int)Cvar_Get("version", s2, 64);
  dword_836065C = (int)Cvar_Get("shortversion", "1.5", 68);
  Sys_Init();
  v2 = Com_Milliseconds();
  Netchan_Init(v2);
  Script_Init();
  XAnimInit();
  DObjInit();
  VM_Init();
  SV_Init();
  sub_80D52E0();
  *(_DWORD *)(dword_835F480 + 20) = 0;
  if ( !*(_DWORD *)(dword_835F480 + 32) )
  {
    CL_Init();
    Sys_ShowConsole();
  }
  dword_835F4BC = Com_Milliseconds();
  Com_AddStartupCommands();
  Cvar_Set("r_uiFullScreen", "1");
  CL_StartHunkUsers();
  if ( !*(_DWORD *)(dword_835F480 + 32) )
    Sys_ShowConsole();
  if ( !*(_DWORD *)(dword_835F480 + 32) && !*(_DWORD *)(dword_8360578 + 32) )
  {
    Cvar_Set(*(char **)dword_8360578, "1");
    Cbuf_AddText("cinematic atvi.RoQ\n");
    Cvar_Set("nextmap", "cinematic iw_logo.roq");
  }
  Cvar_Set("com_statmon", "0");
  dword_835F488 = 1;
  return Com_Printf("--- Common Initialization Complete ---\n", v4);
}
// 80714BA: variable 'v4' is possibly undefined
// 835F480: using guessed type int dword_835F480;
// 835F484: using guessed type int dword_835F484;
// 835F488: using guessed type int dword_835F488;
// 835F4A0: using guessed type int dword_835F4A0;
// 835F4A8: using guessed type int dword_835F4A8;
// 835F4B0: using guessed type int dword_835F4B0;
// 835F4B4: using guessed type int dword_835F4B4;
// 835F4BC: using guessed type int dword_835F4BC;
// 83604C0: using guessed type int dword_83604C0;
// 8360560: using guessed type int dword_8360560;
// 8360564: using guessed type int dword_8360564;
// 8360568: using guessed type int dword_8360568;
// 8360574: using guessed type int dword_8360574;
// 8360578: using guessed type int dword_8360578;
// 836064C: using guessed type int dword_836064C;
// 8360654: using guessed type int dword_8360654;
// 8360658: using guessed type int dword_8360658;
// 836065C: using guessed type int dword_836065C;
// 8360660: using guessed type int dword_8360660;
// 8360664: using guessed type int dword_8360664;
// 836066C: using guessed type int dword_836066C;
// 8360678: using guessed type int dword_8360678;

//----- (080714C7) --------------------------------------------------------
void *__cdecl sub_80714C7(char *src)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_80613C7(src);
  if ( !v2 )
    return (void *)Com_Printf("Couldn't write %s.\n", (char)src);
  sub_8062B8B(v2, "// generated by Call of Duty, do not modify\n");
  sub_80846A4();
  sub_8073A13(v2);
  return FS_FCloseFile(v2);
}

//----- (0807152C) --------------------------------------------------------
void *__cdecl sub_807152C(char *src)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_80613C7(src);
  if ( !v2 )
    return (void *)Com_Printf("Couldn't write %s.\n", (char)src);
  sub_8062B8B(v2, "// generated by Call of Duty, do not modify\n");
  sub_8073AF8(v2);
  return FS_FCloseFile(v2);
}

//----- (08071586) --------------------------------------------------------
void *sub_8071586()
{
  void *result; // eax

  if ( dword_835F488 )
  {
    result = (void *)(dword_8360678 & 1);
    if ( (dword_8360678 & 1) != 0 )
    {
      dword_8360678 &= 0xFFFFFFFE;
      result = sub_80714C7("config_mp_server.cfg");
    }
  }
  return result;
}
// 835F488: using guessed type int dword_835F488;
// 8360678: using guessed type int dword_8360678;

//----- (080715BA) --------------------------------------------------------
void *sub_80715BA()
{
  char *v1; // eax
  char v2; // [esp+4h] [ebp-54h]
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( Cmd_Argc() != 2 )
    return (void *)Com_Printf("Usage: writeconfig <filename>\n", v2);
  v1 = Cmd_Argv(1u);
  Q_strncpyz(dest, v1, 64);
  sub_8085892(dest, 0x40u, (int)".cfg");
  Com_Printf("Writing %s.\n", (char)dest);
  return sub_80714C7(dest);
}
// 80715D1: variable 'v2' is possibly undefined

//----- (08071636) --------------------------------------------------------
void *sub_8071636()
{
  char *v1; // eax
  char v2; // [esp+4h] [ebp-54h]
  char dest[72]; // [esp+10h] [ebp-48h] BYREF

  if ( Cmd_Argc() != 2 )
    return (void *)Com_Printf("Usage: writedefaults <filename>\n", v2);
  v1 = Cmd_Argv(1u);
  Q_strncpyz(dest, v1, 64);
  sub_8085892(dest, 0x40u, (int)".cfg");
  Com_Printf("Writing %s.\n", (char)dest);
  return sub_807152C(dest);
}
// 807164D: variable 'v2' is possibly undefined

//----- (080716B2) --------------------------------------------------------
int __cdecl sub_80716B2(int a1)
{
  int v2; // [esp+20h] [ebp+8h]

  if ( *(float *)(dword_835F4B4 + 28) < 0.0 )
    Cvar_Set("timescale", "0");
  if ( *(_DWORD *)(dword_8360574 + 32) )
    v2 = *(_DWORD *)(dword_8360574 + 32);
  else
    v2 = (int)((long double)a1 * *(float *)(dword_835F4B4 + 28));
  if ( v2 <= 0 && *(float *)(dword_835F4B4 + 28) != 0.0 )
    v2 = 1;
  return v2;
}
// 835F4B4: using guessed type int dword_835F4B4;
// 8360574: using guessed type int dword_8360574;

//----- (08071743) --------------------------------------------------------
int __cdecl sub_8071743(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(dword_835F480 + 32) )
  {
    if ( a1 > 500 && a1 <= 499999 )
      Com_Printf("Hitch warning: %i msec frame time\n", a1);
    v2 = 5000;
  }
  else if ( *(_DWORD *)(dword_8360560 + 32) )
  {
    v2 = 200;
  }
  else
  {
    v2 = 5000;
  }
  if ( a1 > v2 )
    a1 = v2;
  return a1;
}
// 835F480: using guessed type int dword_835F480;
// 8360560: using guessed type int dword_8360560;

//----- (080717B0) --------------------------------------------------------
int sub_80717B0()
{
  int result; // eax
  int v1; // [esp+50h] [ebp-18h]
  int v2; // [esp+58h] [ebp-10h]
  int v3; // [esp+58h] [ebp-10h]

  if ( __sigsetjmp(env, 0) )
    return (int)Com_ErrorCleanup();
  sub_8071586();
  if ( *(_DWORD *)(dword_835F4B0 + 20) )
  {
    if ( *(float *)(dword_835F480 + 28) == 0.0 )
      Sys_ShowConsole();
    *(_DWORD *)(dword_835F4B0 + 20) = 0;
  }
  sub_809B048(*(_DWORD *)(dword_836064C + 32));
  if ( *(_DWORD *)(dword_8360660 + 32) )
    sub_80D563C();
  v1 = 1;
  if ( *(int *)(dword_83604C0 + 32) > 0 && !*(_DWORD *)(dword_835F480 + 32) )
    v1 = 1000 / *(_DWORD *)(dword_83604C0 + 32);
  do
  {
    dword_835F4BC = sub_8070944();
    if ( dword_8110548 > dword_835F4BC )
      dword_8110548 = dword_835F4BC;
    v2 = dword_835F4BC - dword_8110548;
  }
  while ( dword_835F4BC - dword_8110548 < v1 );
  Cbuf_Execute();
  dword_8110548 = dword_835F4BC;
  v3 = sub_8071743(v2);
  sub_80716B2(v3);
  if ( *(_DWORD *)(dword_8360660 + 32) )
    sub_80D563C();
  sub_80942A1(v3);
  if ( !*(_DWORD *)(dword_835F480 + 32) )
  {
    if ( *(_DWORD *)(dword_8360660 + 32) )
      sub_80D563C();
    sub_8070944();
    Cbuf_Execute();
    if ( *(_DWORD *)(dword_8360660 + 32) )
      sub_80D563C();
    sub_80846A9();
    if ( *(_DWORD *)(dword_8360660 + 32) )
      sub_80D563C();
  }
  if ( *(_DWORD *)(dword_8360660 + 32) )
    Com_Printf("frame:%i all:%3i sv:%3i ev:%3i cl:%3i gm:%3i rf:%3i bk:%3i\n", dword_83604C8[0]);
  result = -2027669113 * dword_8110548;
  ++*(_DWORD *)dword_83604C8;
  return result;
}
// 8110548: using guessed type int dword_8110548;
// 835F480: using guessed type int dword_835F480;
// 835F4B0: using guessed type int dword_835F4B0;
// 835F4BC: using guessed type int dword_835F4BC;
// 83604C0: using guessed type int dword_83604C0;
// 83604CC: using guessed type int dword_83604CC;
// 836064C: using guessed type int dword_836064C;
// 8360660: using guessed type int dword_8360660;

//----- (08071A4B) --------------------------------------------------------
void sub_8071A4B()
{
  sub_8072383();
  sub_80CFFF0();
  sub_80C2B26();
  sub_80A987A();
  if ( dword_81105FC )
  {
    FS_FCloseFile(dword_81105FC);
    dword_81105FC = 0;
  }
  if ( *(_DWORD *)dword_8360650 )
  {
    FS_FCloseFile(*(int *)dword_8360650);
    *(_DWORD *)dword_8360650 = 0;
  }
}
// 81105FC: using guessed type int dword_81105FC;

//----- (08071AA7) --------------------------------------------------------
_DWORD *__cdecl sub_8071AA7(_DWORD *a1)
{
  _DWORD *result; // eax

  memset(a1 + 7, 0, 0x100u);
  *a1 = 0;
  a1[1] = 0;
  result = a1;
  a1[2] = 256;
  return result;
}

//----- (08071AEA) --------------------------------------------------------
char *__cdecl sub_8071AEA(char *src)
{
  int v1; // eax
  char *result; // eax
  int v3; // ebx
  int i; // [esp+10h] [ebp-8h]

  v1 = strlen(dword_8111E00);
  result = (char *)Q_stricmpn(src, dword_8111E00, v1);
  if ( !result )
  {
    if ( ++dword_8112220 == 1 )
    {
      result = Q_strncpyz(&byte_8111E20, src, 1024);
    }
    else
    {
      for ( i = 0; ; ++i )
      {
        result = &src[i];
        if ( !src[i] )
          break;
        v3 = tolower(*(char *)(i + 135339552));
        if ( v3 != tolower(src[i]) )
          *(_BYTE *)(i + 135339552) = 0;
      }
    }
  }
  return result;
}
// 8112220: using guessed type int dword_8112220;

//----- (08071B9E) --------------------------------------------------------
int __cdecl sub_8071B9E(char *a1)
{
  int v1; // eax
  int result; // eax

  v1 = strlen(&byte_8111E20);
  result = Q_stricmpn(a1, &byte_8111E20, v1);
  if ( !result )
    result = Com_Printf("    %s\n", (char)a1);
  return result;
}

//----- (08071BE0) --------------------------------------------------------
int sub_8071BE0()
{
  int result; // eax
  char *v1; // eax
  char *j; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = Cmd_Argc();
    if ( i >= result )
      break;
    sub_8086023((char *)dword_8112224 + 28, 256, " ");
    for ( j = Cmd_Argv(i); *j; ++j )
    {
      if ( *j == 32 )
      {
        sub_8086023((char *)dword_8112224 + 28, 256, "\"");
        break;
      }
    }
    v1 = Cmd_Argv(i);
    sub_8086023((char *)dword_8112224 + 28, 256, v1);
    if ( *j == 32 )
      sub_8086023((char *)dword_8112224 + 28, 256, "\"");
  }
  return result;
}

//----- (08071CC0) --------------------------------------------------------
char *__cdecl sub_8071CC0(char *haystack, char *needle)
{
  size_t v3; // eax
  char *src; // [esp+14h] [ebp-4h]

  src = strstr(haystack, needle);
  if ( !src )
    return (char *)sub_8071BE0();
  v3 = strlen(needle);
  return sub_8086023((char *)dword_8112224 + 28, 256, &src[v3]);
}

//----- (08071D1B) --------------------------------------------------------
char *__cdecl sub_8071D1B(char **a1)
{
  char *result; // eax
  char **v2; // ebx
  size_t *v3; // ebx
  char dest[28]; // [esp+10h] [ebp-128h] BYREF
  char v5[268]; // [esp+2Ch] [ebp-10Ch] BYREF

  dword_8112224 = a1;
  Cmd_TokenizeString(a1 + 7);
  dword_8111E00 = Cmd_Argv(0);
  if ( *dword_8111E00 == 92 || *dword_8111E00 == 47 )
    ++dword_8111E00;
  dword_8112220 = 0;
  byte_8111E20 = 0;
  result = dword_8111E00;
  if ( *dword_8111E00 )
  {
    sub_8060585((void (__cdecl *)(int))sub_8071AEA);
    result = (char *)sub_80734ED((void (__cdecl *)(_DWORD))sub_8071AEA);
    if ( dword_8112220 )
    {
      sub_80D2FC8(dest, dword_8112224, 0x11Cu);
      if ( dword_8112220 == 1 )
      {
        Com_sprintf((char *)dword_8112224 + 28, 0x100u, "\\%s", &byte_8111E20);
        if ( Cmd_Argc() == 1 )
          sub_8086023((char *)dword_8112224 + 28, 256, " ");
        else
          sub_8071CC0(v5, dword_8111E00);
        v2 = (char **)dword_8112224;
        result = (char *)strlen((const char *)dword_8112224 + 28);
        *v2 = result;
      }
      else
      {
        Com_sprintf((char *)dword_8112224 + 28, 0x100u, "\\%s", &byte_8111E20);
        v3 = (size_t *)dword_8112224;
        *v3 = strlen((const char *)dword_8112224 + 28);
        sub_8071CC0(v5, dword_8111E00);
        Com_Printf("]%s\n", (_BYTE)dword_8112224 + 28);
        sub_8060585((void (__cdecl *)(int))sub_8071B9E);
        result = (char *)sub_80734ED((void (__cdecl *)(_DWORD))sub_8071B9E);
      }
    }
  }
  return result;
}
// 8112220: using guessed type int dword_8112220;

//----- (08071F32) --------------------------------------------------------
int __cdecl sub_8071F32(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( word_8129BC0[a1] )
    v2 = 92 * word_8129BC0[a1] + 135340608;
  else
    v2 = 0;
  return v2;
}

//----- (08071F6A) --------------------------------------------------------
int sub_8071F6A()
{
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = dword_812A3C0 + 1; i <= 1023; ++i )
  {
    if ( ((unsigned __int8)byte_8129240[i >> 2] & (3 << (2 * (i & 3)))) == 0 )
    {
      dword_812A3C0 = i;
      return i;
    }
  }
  for ( j = 1; ; ++j )
  {
    if ( j > dword_812A3C0 )
      Com_Error(1, (char *)&byte_80D9891);
    if ( ((unsigned __int8)byte_8129240[j >> 2] & (3 << (2 * (j & 3)))) == 0 )
      break;
  }
  dword_812A3C0 = j;
  return j;
}
// 812A3C0: using guessed type int dword_812A3C0;

//----- (080720BC) --------------------------------------------------------
int __cdecl sub_80720BC(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5)
{
  int v6; // [esp+1Ch] [ebp-Ch]

  v6 = sub_8071F6A();
  byte_8129240[v6 >> 2] |= 2 << (2 * (v6 & 3));
  word_8129BC0[a4] = v6;
  return sub_80D12E6(a1, a2, a3, (int)&unk_8112240 + 92 * v6, a5);
}

//----- (0807214C) --------------------------------------------------------
int __cdecl sub_807214C(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  result = word_8129340[a1];
  v3 = result;
  if ( word_8129340[a1] )
  {
    word_8129340[a1] = 0;
    byte_8129240[result >> 2] &= ~(unsigned __int8)(1 << (2 * (result & 3)));
    result = (unsigned __int8)byte_8129240[result >> 2] & (3 << (2 * (result & 3)));
    if ( !result )
      result = sub_80D15CE((int)&unk_8112240 + 92 * v3, a2);
  }
  return result;
}

//----- (080721EB) --------------------------------------------------------
int __cdecl sub_80721EB(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  result = word_8129BC0[a1];
  v3 = result;
  if ( word_8129BC0[a1] )
  {
    word_8129BC0[a1] = 0;
    byte_8129240[result >> 2] &= ~(unsigned __int8)(2 << (2 * (result & 3)));
    result = (unsigned __int8)byte_8129240[result >> 2] & (3 << (2 * (result & 3)));
    if ( !result )
      result = sub_80D15CE((int)&unk_8112240 + 92 * v3, a2);
  }
  return result;
}

//----- (08072313) --------------------------------------------------------
void *sub_8072313()
{
  void *result; // eax

  sub_80D2FE9(&byte_8129240, 0, 0x100u);
  sub_80D2FE9(&word_8129340, 0, 0x880u);
  result = sub_80D2FE9(word_8129BC0, 0, 0x800u);
  dword_812A3C0 = 1;
  dword_80E94C8 = 1;
  return result;
}
// 80E94C8: using guessed type int dword_80E94C8;
// 8129240: using guessed type char byte_8129240;
// 8129340: using guessed type __int16 word_8129340;
// 812A3C0: using guessed type int dword_812A3C0;

//----- (08072383) --------------------------------------------------------
void sub_8072383()
{
  if ( dword_80E94C8 )
    dword_80E94C8 = 0;
}
// 80E94C8: using guessed type int dword_80E94C8;

//----- (0807239D) --------------------------------------------------------
void *sub_807239D()
{
  sub_8072383();
  sub_80CFFF0();
  sub_80C2B26();
  sub_80A987A();
  Script_Init();
  XAnimInit();
  DObjInit();
  return sub_8072313();
}

//----- (080723CD) --------------------------------------------------------
void *__cdecl sub_80723CD(size_t a1)
{
  return sub_806C5DF(a1);
}

//----- (080723E0) --------------------------------------------------------
void *__cdecl sub_80723E0(size_t a1)
{
  return sub_806C482(a1);
}

//----- (08072406) --------------------------------------------------------
_DWORD *__cdecl sub_8072406(int a1)
{
  return sub_80C4306(a1, (int (__cdecl *)(int))sub_80723CD);
}

//----- (08072421) --------------------------------------------------------
int __cdecl sub_8072421(int a1)
{
  return sub_80A1F70(a1);
}

//----- (0807243C) --------------------------------------------------------
_DWORD *__cdecl sub_807243C(int a1)
{
  return sub_80C4306(a1, sub_8072421);
}

//----- (08072457) --------------------------------------------------------
int __cdecl sub_8072457(int a1)
{
  return sub_80C436C(a1, sub_80A1F96);
}

//----- (08072472) --------------------------------------------------------
int __cdecl sub_8072472(signed int a1, _DWORD *a2, int a3)
{
  if ( a1 <= 0 )
    return 0;
  if ( dword_80E950C )
  {
    *a2 = dword_80E9510;
    if ( !dword_80E9510 )
      dword_80E9510 = a3;
  }
  else
  {
    dword_80E950C = (int)sub_806C5DF(a1);
    dword_80E9510 = a3;
    *a2 = 0;
  }
  return dword_80E950C;
}
// 80E950C: using guessed type int dword_80E950C;
// 80E9510: using guessed type int dword_80E9510;

//----- (080724DB) --------------------------------------------------------
int __cdecl sub_80724DB(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == dword_80E9510 )
  {
    if ( !a2 )
      dword_80E950C = 0;
    dword_80E9510 = 0;
  }
  return result;
}
// 80E950C: using guessed type int dword_80E950C;
// 80E9510: using guessed type int dword_80E9510;

//----- (08072731) --------------------------------------------------------
int sub_8072731()
{
  return -1;
}

//----- (0807273B) --------------------------------------------------------
const char *sub_807273B()
{
  return "default";
}

//----- (08072745) --------------------------------------------------------
int __cdecl Com_AddToString(_BYTE *a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+0h] [ebp-8h]
  int j; // [esp+0h] [ebp-8h]
  int v8; // [esp+4h] [ebp-4h]

  v8 = 0;
  if ( a5 )
  {
    if ( *a1 )
    {
      for ( i = 0; i < a4 - a3 && a1[i]; ++i )
      {
        if ( (char)a1[i] <= 32 )
        {
          v8 = 1;
          break;
        }
      }
    }
    else
    {
      v8 = 1;
    }
  }
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  for ( j = 0; a3 < a4 && a1[j]; ++j )
    *(_BYTE *)(a2 + a3++) = a1[j];
  if ( v8 && a3 < a4 )
    *(_BYTE *)(a2 + a3++) = 34;
  return a3;
}

//----- (08072820) --------------------------------------------------------
int __cdecl sub_8072820(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( !a1 )
    Com_Error(1, (char *)&byte_80D9960);
  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += tolower(*(char *)(a1 + i)) * (i + 119);
  return (unsigned __int8)v2;
}

//----- (08072895) --------------------------------------------------------
_BOOL4 __cdecl Cvar_ValidateString(char *s)
{
  if ( !s )
    return 0;
  if ( strchr(s, 92) )
    return 0;
  if ( strchr(s, 34) )
    return 0;
  return strchr(s, 59) == 0;
}

//----- (08072916) --------------------------------------------------------
_DWORD *__cdecl Cvar_FindVar(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_8140400[sub_8072820(a1)]; i; i = *(_DWORD *)(i + 40) )
  {
    if ( !Q_stricmp((char *)a1, *(char **)i) )
      return (_DWORD *)i;
  }
  return 0;
}
// 8140400: using guessed type int dword_8140400[];

//----- (08072976) --------------------------------------------------------
unsigned int *sub_8072976()
{
  unsigned int *result; // eax
  unsigned int i; // [esp+10h] [ebp-8h] BYREF
  int j; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 0xFF; ++i )
  {
    for ( j = dword_8140400[i]; j; j = *(_DWORD *)(j + 40) )
    {
      if ( *(_DWORD *)(j + 12) )
      {
        Z_FreeInternal(*(void **)(j + 12));
        *(_DWORD *)(j + 12) = 0;
      }
      if ( *(_DWORD *)(j + 4) )
      {
        Z_FreeInternal(*(void **)(j + 4));
        *(_DWORD *)(j + 4) = 0;
      }
      if ( *(_DWORD *)(j + 8) )
      {
        Z_FreeInternal(*(void **)(j + 8));
        *(_DWORD *)(j + 8) = 0;
      }
      Z_FreeInternal(*(void **)j);
      *(_DWORD *)j = 0;
    }
    dword_8140400[i] = 0;
    result = &i;
  }
  *(_DWORD *)dword_8360674 = 0;
  dword_8360670 = 0;
  dword_812A3E0 = 0;
  dword_812A3E4 = 0;
  dword_8360678 = 0;
  return result;
}
// 812A3E0: using guessed type int dword_812A3E0;
// 812A3E4: using guessed type int dword_812A3E4;
// 8140400: using guessed type int dword_8140400[];
// 8360670: using guessed type int dword_8360670;
// 8360678: using guessed type int dword_8360678;

//----- (08072A7C) --------------------------------------------------------
int *__cdecl Cvar_Get(char *s, char *s2, int a3)
{
  char *v3; // eax
  int v4; // eax
  int *v6; // [esp+1Ch] [ebp-1Ch]
  char *ptr; // [esp+24h] [ebp-14h]
  const char ***i; // [esp+2Ch] [ebp-Ch]
  int *v9; // [esp+30h] [ebp-8h]
  int *v10; // [esp+30h] [ebp-8h]

  if ( !s || !s2 )
    Com_Error(0, (char *)&byte_80D9980);
  if ( !Cvar_ValidateString(s) )
  {
    v3 = va("invalid cvar name string: %s", s);
    Com_Error(0, v3);
  }
  v9 = Cvar_FindVar((int)s);
  if ( v9 )
  {
    if ( (v9[4] & 0x1080) != 0 && (a3 & 0x1080) == 0 && (*s2 || (a3 & 0x200) != 0) )
    {
      v9[4] &= 0xFFFFEF7F;
      Z_FreeInternal((void *)v9[2]);
      v9[2] = (int)sub_806BC0A(s2);
      dword_8360678 |= a3;
    }
    v9[4] |= a3;
    if ( *(_BYTE *)v9[2] )
    {
      if ( *s2 && strcmp((const char *)v9[2], s2) )
        Com_DPrintf("Warning: cvar \"%s\" given initial values: \"%s\" and \"%s\"\n", s, (const char *)v9[2], s2);
    }
    else
    {
      Z_FreeInternal((void *)v9[2]);
      v9[2] = (int)sub_806BC0A(s2);
    }
    if ( v9[3] )
    {
      ptr = (char *)v9[3];
      v9[3] = 0;
      sub_8072DA8(s, ptr, 1);
      Z_FreeInternal(ptr);
    }
    if ( (v9[4] & 0x200) != 0 && dword_812A3E0 && !*(_DWORD *)(dword_812A3E0 + 32) )
      sub_8072DA8(s, s2, 1);
    v6 = v9;
  }
  else
  {
    if ( *(int *)dword_8360674 > 2047 )
      Com_Error(0, "MAX_CVARS");
    v10 = &dword_812A400[11 * (*(_DWORD *)dword_8360674)++];
    *v10 = (int)sub_806BC0A(s);
    v10[1] = (int)sub_806BC0A(s2);
    v10[5] = 1;
    v10[6] = 1;
    *((float *)v10 + 7) = atof((const char *)v10[1]);
    v10[8] = atoi((const char *)v10[1]);
    v10[2] = (int)sub_806BC0A(s2);
    for ( i = (const char ***)&dword_8360670; *i && strcasecmp((const char *)*v10, **i) >= 0; i = (const char ***)(*i + 9) )
      ;
    v10[9] = (int)*i;
    *i = (const char **)v10;
    v10[4] = a3;
    v4 = sub_8072820((int)s);
    v10[10] = dword_8140400[v4];
    dword_8140400[v4] = (int)v10;
    v6 = v10;
  }
  return v6;
}
// 812A3E0: using guessed type int dword_812A3E0;
// 8140400: using guessed type int dword_8140400[];
// 8360670: using guessed type int dword_8360670;
// 8360678: using guessed type int dword_8360678;

//----- (08072DA8) --------------------------------------------------------
int *__cdecl sub_8072DA8(char *s, char *s1, int a3)
{
  char *v3; // eax
  char *v4; // eax
  char v6; // [esp+4h] [ebp-24h]
  int *v7; // [esp+18h] [ebp-10h]
  int *v8; // [esp+20h] [ebp-8h]

  v3 = va("      cvar set %s %s\n", s, s1);
  Com_PrintMessage(4, v3);
  if ( !Cvar_ValidateString(s) )
  {
    v4 = va("invalid cvar name string: %s", s);
    Com_Error(0, v4);
  }
  v8 = Cvar_FindVar((int)s);
  if ( v8 )
  {
    if ( !s1 )
      s1 = (char *)v8[2];
    if ( !strcmp(s1, (const char *)v8[1]) )
    {
      if ( (v8[4] & 0x20) != 0 && v8[3] )
      {
        Z_FreeInternal((void *)v8[3]);
        v8[3] = 0;
      }
      v7 = v8;
    }
    else
    {
      dword_8360678 |= v8[4];
      if ( a3 )
      {
        if ( v8[3] )
        {
          Z_FreeInternal((void *)v8[3]);
          v8[3] = 0;
        }
      }
      else
      {
        if ( (v8[4] & 0x40) != 0 )
        {
          Com_Printf("%s is read only.\n", (char)s);
          return v8;
        }
        if ( (v8[4] & 0x10) != 0 )
        {
          Com_Printf("%s is write protected.\n", (char)s);
          return v8;
        }
        if ( (v8[4] & 0x200) != 0 && !*(_DWORD *)(dword_812A3E0 + 32) )
        {
          Com_Printf("%s is cheat protected.\n", (char)s);
          return v8;
        }
        if ( *(_DWORD *)(dword_812A3E4 + 32) && *(_DWORD *)(dword_8360560 + 32) )
        {
          Com_Printf("Console is locked out, cannot change cvars.\n", v6);
          return v8;
        }
        if ( (v8[4] & 0x20) != 0 )
        {
          if ( v8[3] )
          {
            if ( !strcmp(s1, (const char *)v8[3]) )
              return v8;
            Z_FreeInternal((void *)v8[3]);
          }
          else if ( !strcmp(s1, (const char *)v8[1]) )
          {
            return v8;
          }
          Com_Printf("%s will be changed upon restarting.\n", (char)s);
          v8[3] = (int)sub_806BC0A(s1);
          v8[5] = 1;
          return v8;
        }
      }
      if ( strcmp(s1, (const char *)v8[1]) )
      {
        v8[5] = 1;
        ++v8[6];
        Z_FreeInternal((void *)v8[1]);
        v8[1] = (int)sub_806BC0A(s1);
        *((float *)v8 + 7) = atof((const char *)v8[1]);
        v8[8] = atoi((const char *)v8[1]);
      }
      v7 = v8;
    }
  }
  else if ( s1 )
  {
    if ( a3 )
      v7 = Cvar_Get(s, s1, 0);
    else
      v7 = Cvar_Get(s, s1, 128);
  }
  else
  {
    v7 = 0;
  }
  return v7;
}
// 8072F9D: variable 'v6' is possibly undefined
// 812A3E0: using guessed type int dword_812A3E0;
// 812A3E4: using guessed type int dword_812A3E4;
// 8360560: using guessed type int dword_8360560;
// 8360678: using guessed type int dword_8360678;

//----- (08073100) --------------------------------------------------------
int *__cdecl Cvar_Set(char *s, char *s1)
{
  return sub_8072DA8(s, s1, 1);
}

//----- (0807315D) --------------------------------------------------------
int *__cdecl sub_807315D(char *s, char *s1)
{
  return sub_8072DA8(s, s1, 0);
}

//----- (0807317F) --------------------------------------------------------
int *__cdecl sub_807317F(char *a1, float a2)
{
  char s[40]; // [esp+30h] [ebp-28h] BYREF

  if ( a2 == (long double)(int)a2 )
    Com_sprintf(s, 0x20u, "%i", (int)a2);
  else
    Com_sprintf(s, 0x20u, "%f", a2);
  return Cvar_Set(a1, s);
}

//----- (08073219) --------------------------------------------------------
int *__cdecl sub_8073219(char *s)
{
  return sub_8072DA8(s, 0, 0);
}

//----- (0807323C) --------------------------------------------------------
int *__cdecl sub_807323C(int a1, char *s, char *s2, int a4)
{
  int *result; // eax

  result = Cvar_Get(s, s2, a4);
  if ( a1 )
  {
    *(_DWORD *)a1 = -1171354717 * (result - dword_812A400);
    *(_DWORD *)(a1 + 4) = -1;
    result = sub_8073293(a1);
  }
  return result;
}

//----- (08073293) --------------------------------------------------------
int *__cdecl sub_8073293(int a1)
{
  int *result; // eax
  size_t v2; // eax
  int *v3; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)a1 >= *(_DWORD *)dword_8360674 )
    Com_Error(1, (char *)&byte_80D9AE0);
  v3 = &dword_812A400[11 * *(_DWORD *)a1];
  result = (int *)v3[6];
  if ( result != *(int **)(a1 + 4) )
  {
    result = &dword_812A400[11 * *(_DWORD *)a1];
    if ( v3[1] )
    {
      *(_DWORD *)(a1 + 4) = v3[6];
      if ( strlen((const char *)v3[1]) + 1 > 0x100 )
      {
        v2 = strlen((const char *)v3[1]);
        Com_Error(1, (char *)&byte_80D9B20, v3[1], v2, 256);
      }
      Q_strncpyz((char *)(a1 + 16), (char *)v3[1], 256);
      *(_DWORD *)(a1 + 8) = v3[7];
      result = (int *)v3[8];
      *(_DWORD *)(a1 + 12) = result;
    }
  }
  return result;
}

//----- (08073397) --------------------------------------------------------
_DWORD *Cvar_Init()
{
  dword_812A3E0 = (int)Cvar_Get("sv_cheats", "0", 72);
  dword_812A3E4 = (int)Cvar_Get("sv_console_lockout", "0", 72);
  return sub_80742B0();
}
// 812A3E0: using guessed type int dword_812A3E0;
// 812A3E4: using guessed type int dword_812A3E4;

//----- (080733E6) --------------------------------------------------------
int sub_80733E6()
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]

  result = dword_8360670;
  for ( i = dword_8360670; i; i = result )
  {
    *(_DWORD *)(i + 16) &= 0xFFFFDFFF;
    result = *(_DWORD *)(i + 36);
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (0807341C) --------------------------------------------------------
long double __cdecl Cvar_VariableValue(int a1)
{
  float v2; // [esp+10h] [ebp-8h]
  float *v3; // [esp+14h] [ebp-4h]

  v3 = (float *)Cvar_FindVar(a1);
  if ( v3 )
    v2 = v3[7];
  else
    v2 = 0.0;
  return v2;
}

//----- (0807344B) --------------------------------------------------------
int __cdecl sub_807344B(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Cvar_FindVar(a1);
  if ( v3 )
    v2 = v3[8];
  else
    v2 = 0;
  return v2;
}

//----- (0807347C) --------------------------------------------------------
void *__cdecl Cvar_VariableString(int a1)
{
  void *v2; // [esp+10h] [ebp-8h]
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Cvar_FindVar(a1);
  if ( v3 )
    v2 = (void *)v3[1];
  else
    v2 = &unk_80D9B80;
  return v2;
}

//----- (080734AD) --------------------------------------------------------
char *__cdecl sub_80734AD(int a1, char *dest, int a3)
{
  char *result; // eax
  _DWORD *v4; // [esp+14h] [ebp-4h]

  v4 = Cvar_FindVar(a1);
  if ( v4 )
    return Q_strncpyz(dest, (char *)v4[1], a3);
  result = dest;
  *dest = 0;
  return result;
}

//----- (080734ED) --------------------------------------------------------
int __cdecl sub_80734ED(void (__cdecl *a1)(_DWORD))
{
  int result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  result = dword_8360670;
  for ( i = (_DWORD *)dword_8360670; i; i = (_DWORD *)result )
  {
    a1(*i);
    result = i[9];
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (08073582) --------------------------------------------------------
int sub_8073582()
{
  char *v0; // eax
  char *v1; // eax
  int v3; // [esp+10h] [ebp-8h]
  char **v4; // [esp+14h] [ebp-4h]

  v0 = Cmd_Argv(0);
  v4 = (char **)Cvar_FindVar((int)v0);
  if ( !v4 )
    return 0;
  if ( Cmd_Argc() == 1 )
  {
    Com_Printf("\"%s\" is:\"%s^7\" default:\"%s^7\"\n", (char)*v4);
    if ( v4[3] )
      Com_Printf("latched: \"%s\"\n", (char)v4[3]);
    v3 = 1;
  }
  else
  {
    v1 = Cmd_Argv(1u);
    sub_8072DA8(*v4, v1, 0);
    v3 = 1;
  }
  return v3;
}

//----- (0807363D) --------------------------------------------------------
int *sub_807363D()
{
  int *result; // eax
  char *v1; // eax
  char *v2; // ebx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // ebx
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char v10; // [esp+4h] [ebp-24h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  _BOOL4 v12; // [esp+20h] [ebp-8h]
  signed int i; // [esp+20h] [ebp-8h]

  if ( Cmd_Argc() <= 1 )
    return (int *)Com_Printf("usage: toggle <variable> <optional value sequence>\n", v10);
  if ( Cmd_Argc() == 2 )
  {
    v1 = Cmd_Argv(1u);
    v12 = (int)Cvar_VariableValue((int)v1) == 0;
    v2 = va("%i", v12);
    v3 = Cmd_Argv(1u);
    result = sub_8072DA8(v3, v2, 0);
  }
  else
  {
    v4 = Cmd_Argv(1u);
    s1 = (char *)Cvar_VariableString((int)v4);
    for ( i = 2; i < Cmd_Argc() - 1; ++i )
    {
      v5 = Cmd_Argv(i);
      if ( !strcmp(s1, v5) )
      {
        v6 = Cmd_Argv(i + 1);
        v7 = Cmd_Argv(1u);
        return sub_8072DA8(v7, v6, 0);
      }
    }
    v8 = Cmd_Argv(2u);
    v9 = Cmd_Argv(1u);
    result = sub_8072DA8(v9, v8, 0);
  }
  return result;
}
// 8073655: variable 'v10' is possibly undefined

//----- (08073790) --------------------------------------------------------
int *sub_8073790()
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char v4; // [esp+4h] [ebp-1024h]
  char dest[4096]; // [esp+10h] [ebp-1018h] BYREF
  size_t v6; // [esp+1010h] [ebp-18h]
  int v7; // [esp+1014h] [ebp-14h]
  int v8; // [esp+1018h] [ebp-10h]
  signed int i; // [esp+101Ch] [ebp-Ch]

  v8 = Cmd_Argc();
  if ( v8 <= 2 )
    return (int *)Com_Printf("usage: set <variable> <value>\n", v4);
  dest[0] = 0;
  v7 = 0;
  for ( i = 2; i < v8; ++i )
  {
    v1 = Cmd_Argv(i);
    v6 = strlen(v1 + 1);
    if ( (int)(v7 + v6) > 4093 )
      break;
    v2 = Cmd_Argv(i);
    strcat(dest, v2);
    if ( i != v8 - 1 )
      strcat(dest, " ");
    v7 += v6;
  }
  v3 = Cmd_Argv(1u);
  return sub_8072DA8(v3, dest, 0);
}
// 80737AE: variable 'v4' is possibly undefined

//----- (08073872) --------------------------------------------------------
_DWORD *sub_8073872()
{
  _DWORD *result; // eax
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 3 )
    return (_DWORD *)Com_Printf("usage: setu <variable> <value>\n", v2);
  sub_8073790();
  v1 = Cmd_Argv(1u);
  result = Cvar_FindVar((int)v1);
  if ( result )
    result[4] |= 2u;
  return result;
}
// 8073889: variable 'v2' is possibly undefined

//----- (080738C5) --------------------------------------------------------
_DWORD *sub_80738C5()
{
  _DWORD *result; // eax
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 3 )
    return (_DWORD *)Com_Printf("usage: sets <variable> <value>\n", v2);
  sub_8073790();
  v1 = Cmd_Argv(1u);
  result = Cvar_FindVar((int)v1);
  if ( result )
    result[4] |= 4u;
  return result;
}
// 80738DC: variable 'v2' is possibly undefined

//----- (08073918) --------------------------------------------------------
_DWORD *sub_8073918()
{
  _DWORD *result; // eax
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 3 )
    return (_DWORD *)Com_Printf("usage: seta <variable> <value>\n", v2);
  sub_8073790();
  v1 = Cmd_Argv(1u);
  result = Cvar_FindVar((int)v1);
  if ( result )
    result[4] |= 1u;
  return result;
}
// 807392F: variable 'v2' is possibly undefined

//----- (0807396B) --------------------------------------------------------
int *sub_807396B()
{
  char *v1; // eax
  char *v2; // eax
  char v3; // [esp+4h] [ebp-14h]
  char *s1; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() != 3 )
    return (int *)Com_Printf("usage: setfromcvar <variable> <variablein>\n", v3);
  v1 = Cmd_Argv(2u);
  v5 = Cvar_FindVar((int)v1);
  if ( v5 )
    s1 = (char *)v5[1];
  else
    s1 = (char *)&unk_80D9B80;
  v2 = Cmd_Argv(1u);
  return sub_8072DA8(v2, s1, 0);
}
// 8073982: variable 'v3' is possibly undefined

//----- (080739DF) --------------------------------------------------------
int *sub_80739DF()
{
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 2 )
    return (int *)Com_Printf("usage: reset <variable>\n", v2);
  v1 = Cmd_Argv(1u);
  return sub_8073219(v1);
}
// 80739F6: variable 'v2' is possibly undefined

//----- (08073A13) --------------------------------------------------------
const char **__cdecl sub_8073A13(int a1)
{
  const char **result; // eax
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  const char **i; // [esp+42Ch] [ebp-Ch]

  result = (const char **)dword_8360670;
  for ( i = (const char **)dword_8360670; i; i = result )
  {
    if ( Q_stricmp((char *)*i, "cl_cdkey") && ((unsigned int)i[4] & 1) != 0 )
    {
      if ( i[3] )
        Com_sprintf(s, 0x400u, "seta %s \"%s\"\n", *i, i[3]);
      else
        Com_sprintf(s, 0x400u, "seta %s \"%s\"\n", *i, i[1]);
      sub_8062B8B(a1, "%s", s);
    }
    result = (const char **)i[9];
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (08073AF8) --------------------------------------------------------
int __cdecl sub_8073AF8(int a1)
{
  int result; // eax
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  result = dword_8360670;
  for ( i = dword_8360670; i; i = result )
  {
    if ( Q_stricmp(*(char **)i, "cl_cdkey") )
    {
      if ( (*(_DWORD *)(i + 16) & 0x12C0) == 0 )
      {
        Com_sprintf(s, 0x400u, "set %s \"%s\"\n", *(const char **)i, *(const char **)(i + 8));
        sub_8062B8B(a1, "%s", s);
      }
    }
    result = *(_DWORD *)(i + 36);
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (08073B9E) --------------------------------------------------------
int sub_8073B9E()
{
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  char v4; // [esp+4h] [ebp-14h]
  char v5; // [esp+4h] [ebp-14h]
  char v6; // [esp+4h] [ebp-14h]
  char v7; // [esp+4h] [ebp-14h]
  char *v8; // [esp+Ch] [ebp-Ch]
  char v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() <= 1 )
    v8 = 0;
  else
    v8 = Cmd_Argv(1u);
  v9 = 0;
  v10 = dword_8360670;
  while ( v10 )
  {
    if ( !v8 || sub_806B69A((int)v8, *(char **)v10, 0) )
    {
      if ( (*(_DWORD *)(v10 + 16) & 0x2004) != 0 )
        Com_Printf((char *)aSurialc, v1);
      else
        Com_Printf(" ", v1);
      if ( (*(_DWORD *)(v10 + 16) & 2) != 0 )
        Com_Printf((char *)&aSurialc[2], v2);
      else
        Com_Printf(" ", v2);
      if ( (*(_DWORD *)(v10 + 16) & 0x40) != 0 )
        Com_Printf((char *)&aSurialc[4], v3);
      else
        Com_Printf(" ", v3);
      if ( (*(_DWORD *)(v10 + 16) & 0x10) != 0 )
        Com_Printf((char *)&aSurialc[6], v4);
      else
        Com_Printf(" ", v4);
      if ( (*(_DWORD *)(v10 + 16) & 1) != 0 )
        Com_Printf((char *)&aSurialc[8], v5);
      else
        Com_Printf(" ", v5);
      if ( (*(_DWORD *)(v10 + 16) & 0x20) != 0 )
        Com_Printf((char *)&aSurialc[10], v6);
      else
        Com_Printf(" ", v6);
      if ( (*(_DWORD *)(v10 + 16) & 0x200) != 0 )
        Com_Printf((char *)&aSurialc[12], v7);
      else
        Com_Printf(" ", v7);
      Com_Printf(" %s \"%s\"\n", *(_DWORD *)v10);
    }
    v10 = *(_DWORD *)(v10 + 36);
    ++v9;
  }
  Com_Printf("\n%i total cvars\n", v9);
  return Com_Printf("%i cvar indexes\n", dword_8360674[0]);
}
// 8073C21: variable 'v1' is possibly undefined
// 8073C48: variable 'v2' is possibly undefined
// 8073C6F: variable 'v3' is possibly undefined
// 8073C96: variable 'v4' is possibly undefined
// 8073CBD: variable 'v5' is possibly undefined
// 8073CE4: variable 'v6' is possibly undefined
// 8073D0D: variable 'v7' is possibly undefined
// 8360670: using guessed type int dword_8360670;

//----- (08073D7C) --------------------------------------------------------
void sub_8073D7C()
{
  sub_8073D90(0);
}

//----- (08073D90) --------------------------------------------------------
void __cdecl sub_8073D90(int a1)
{
  char s[8196]; // [esp+20h] [ebp-2018h] BYREF
  int v2; // [esp+2024h] [ebp-14h]
  char v3[4]; // [esp+2028h] [ebp-10h]
  const char **v4; // [esp+202Ch] [ebp-Ch]

  if ( Cmd_Argc() <= 1 )
    v2 = 0;
  else
    v2 = (int)Cmd_Argv(1u);
  if ( a1 || dword_836066C && *(_DWORD *)(dword_836066C + 32) )
  {
    *(_DWORD *)v3 = 0;
    Com_PrintMessage(a1, "=============================== CVAR DUMP ========================================\n");
    v4 = (const char **)dword_8360670;
    while ( v4 )
    {
      if ( !v2 || sub_806B69A(v2, (char *)*v4, 0) )
      {
        if ( v4[3] )
          Com_sprintf(s, 0x2000u, "      %s \"%s\" -- latched \"%s\"\n", *v4, v4[1], v4[3]);
        else
          Com_sprintf(s, 0x2000u, "      %s \"%s\"\n", *v4, v4[1]);
        Com_PrintMessage(a1, s);
      }
      v4 = (const char **)v4[9];
      ++*(_DWORD *)v3;
    }
    Com_sprintf(s, 0x2000u, "\n%i total cvars\n%i cvar indexes\n", *(_DWORD *)v3, *(_DWORD *)dword_8360674);
    Com_PrintMessage(a1, s);
    Com_PrintMessage(a1, "=============================== END CVAR DUMP =====================================\n");
  }
}
// 836066C: using guessed type int dword_836066C;
// 8360670: using guessed type int dword_8360670;

//----- (08073F2D) --------------------------------------------------------
_DWORD *__cdecl sub_8073F2D(char *s, char *s1)
{
  _DWORD *result; // eax

  result = Cvar_FindVar((int)s);
  if ( result )
  {
    if ( (result[4] & 0x20) != 0 )
      result = sub_807315D(s, s1);
    else
      result = Cvar_Set(s, s1);
  }
  return result;
}

//----- (0807407C) --------------------------------------------------------
int sub_807407C()
{
  int result; // eax
  int *v1; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h]

  v1 = &dword_8360670;
  while ( 1 )
  {
    result = *v1;
    s = (char *)*v1;
    if ( !*v1 )
      break;
    if ( (*((_DWORD *)s + 4) & 0x450) != 0 )
    {
      v1 = (int *)(s + 36);
    }
    else if ( s[16] >= 0 )
    {
      Cvar_Set(*(char **)s, *((char **)s + 2));
      v1 = (int *)(s + 36);
    }
    else
    {
      *v1 = *((_DWORD *)s + 9);
      if ( *(_DWORD *)s )
        Z_FreeInternal(*(void **)s);
      if ( *((_DWORD *)s + 1) )
        Z_FreeInternal(*((void **)s + 1));
      if ( *((_DWORD *)s + 3) )
        Z_FreeInternal(*((void **)s + 3));
      if ( *((_DWORD *)s + 2) )
        Z_FreeInternal(*((void **)s + 2));
      memset(s, 0, 4u);
    }
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (08074174) --------------------------------------------------------
int __cdecl SV_SetConfig(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  result = dword_8360670;
  for ( i = dword_8360670; i; i = result )
  {
    if ( (a3 & *(_DWORD *)(i + 16)) != 0 )
      sub_8090270(a1, a2, *(char **)i, *(char **)(i + 4));
    result = *(_DWORD *)(i + 36);
  }
  return result;
}
// 8360670: using guessed type int dword_8360670;

//----- (080741CB) --------------------------------------------------------
char *__cdecl Cvar_InfoString(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  byte_8140800 = 0;
  for ( i = dword_8360670; i; i = *(_DWORD *)(i + 36) )
  {
    if ( (a1 & *(_DWORD *)(i + 16)) != 0 )
      Info_SetValueForKey(&byte_8140800, *(char **)i, *(_DWORD *)(i + 4));
  }
  return &byte_8140800;
}
// 8360670: using guessed type int dword_8360670;

//----- (08074228) --------------------------------------------------------
char *__cdecl Cvar_InfoString_Big(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  byte_8140C00 = 0;
  for ( i = dword_8360670; i; i = *(_DWORD *)(i + 36) )
  {
    if ( (a1 & *(_DWORD *)(i + 16)) != 0 )
      sub_8086A88(&byte_8140C00, *(char **)i, *(_DWORD *)(i + 4));
  }
  return &byte_8140C00;
}
// 8360670: using guessed type int dword_8360670;

//----- (080742B0) --------------------------------------------------------
_DWORD *sub_80742B0()
{
  sub_806043E("toggle", (int)sub_807363D);
  sub_806043E("set", (int)sub_8073790);
  sub_806043E("sets", (int)sub_80738C5);
  sub_806043E("setu", (int)sub_8073872);
  sub_806043E("seta", (int)sub_8073918);
  sub_806043E("setfromcvar", (int)sub_807396B);
  sub_806043E("reset", (int)sub_80739DF);
  sub_806043E("cvarlist", (int)sub_8073B9E);
  sub_806043E("cvardump", (int)sub_8073D7C);
  return sub_806043E("cvar_restart", (int)sub_807407C);
}

//----- (08074380) --------------------------------------------------------
int __cdecl sub_8074380(char *a1)
{
  char s[268]; // [esp+20h] [ebp-118h] BYREF
  FILE *stream; // [esp+12Ch] [ebp-Ch]

  sub_8060CD2(*(char **)(dword_835B230 + 4), a1, (char *)&byte_80D9F00, s);
  s[strlen(s) - 1] = 0;
  stream = fopen(s, "rb");
  if ( !stream )
    return 0;
  fclose(stream);
  return 1;
}
// 835B230: using guessed type int dword_835B230;

//----- (08074596) --------------------------------------------------------
int __cdecl FS_SV_FOpenFileRead(char *src, int a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx
  int v7; // [esp+18h] [ebp-110h]
  int v8; // [esp+1Ch] [ebp-10Ch]
  char s[264]; // [esp+20h] [ebp-108h] BYREF

  sub_8060862();
  v2 = sub_80609D9(0);
  v8 = v2;
  dword_834E918[72 * v2] = 0;
  Q_strncpyz((char *)(288 * v2 + 137685280), src, 256);
  sub_8060CD2(*(char **)(dword_835B230 + 4), src, (char *)&byte_80D9F00, s);
  s[strlen(s) - 1] = 0;
  if ( *(_DWORD *)(dword_835B240 + 32) )
    Com_Printf("FS_SV_FOpenFileRead (fs_homepath): %s\n", (char)s);
  v3 = 72 * v8;
  dword_834E900[v3] = (int)fopen(s, "rb");
  dword_834E908[72 * v8] = 0;
  if ( !dword_834E900[72 * v8] && Q_stricmp(*(char **)(dword_835B230 + 4), *(char **)(dword_8357200 + 4)) )
  {
    sub_8060CD2(*(char **)(dword_8357200 + 4), src, (char *)&byte_80D9F00, s);
    s[strlen(s) - 1] = 0;
    if ( *(_DWORD *)(dword_835B240 + 32) )
      Com_Printf("FS_SV_FOpenFileRead (fs_basepath): %s\n", (char)s);
    v4 = 72 * v8;
    dword_834E900[v4] = (int)fopen(s, "rb");
    dword_834E908[72 * v8] = 0;
    if ( !dword_834E900[72 * v8] )
      v8 = 0;
  }
  if ( !dword_834E900[72 * v8] )
  {
    sub_8060CD2(*(char **)(dword_835B248 + 4), src, (char *)&byte_80D9F00, s);
    s[strlen(s) - 1] = 0;
    if ( *(_DWORD *)(dword_835B240 + 32) )
      Com_Printf("FS_SV_FOpenFileRead (fs_cdpath) : %s\n", (char)s);
    v5 = 72 * v8;
    dword_834E900[v5] = (int)fopen(s, "rb");
    dword_834E908[72 * v8] = 0;
    if ( !dword_834E900[72 * v8] )
      v8 = 0;
  }
  *(_DWORD *)a2 = v8;
  if ( v8 )
    v7 = sub_8060AF1(v8);
  else
    v7 = 0;
  return v7;
}
// 80609D9: using guessed type _DWORD __cdecl sub_80609D9(_DWORD);
// 834E900: using guessed type int dword_834E900[];
// 834E908: using guessed type int dword_834E908[];
// 834E918: using guessed type int dword_834E918[];
// 8357200: using guessed type int dword_8357200;
// 835B230: using guessed type int dword_835B230;
// 835B240: using guessed type int dword_835B240;
// 835B248: using guessed type int dword_835B248;

//----- (080749E8) --------------------------------------------------------
void *__cdecl sub_80749E8(char *s, char a2)
{
  signed int v3; // [esp+10h] [ebp-8h]
  signed int i; // [esp+14h] [ebp-4h]

  v3 = strlen(s);
  for ( i = 0; i < v3; ++i )
    *(_BYTE *)(i + 135539712) = s[i] + a2;
  *(_BYTE *)(i + 135539712) = 0;
  return &unk_8142C00;
}

//----- (08074AEF) --------------------------------------------------------
int __cdecl sub_8074AEF(char *haystack, int a2)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  _DWORD *i; // [esp+24h] [ebp-4h]

  v4 = 0;
  sub_8060862();
  if ( !haystack )
    Com_Error(0, (char *)&byte_80DA000);
  if ( *haystack == 47 || *haystack == 92 )
    ++haystack;
  if ( strstr(haystack, "..") || strstr(haystack, "::") )
    return -1;
  for ( i = fs_searchpaths; ; i = (_DWORD *)*i )
  {
    if ( !i )
      return -1;
    if ( i[1] )
      v4 = sub_8060946((int)haystack, *(_DWORD *)(i[1] + 788));
    if ( i[1] && *(_DWORD *)(*(_DWORD *)(i[1] + 792) + 4 * v4) && (i[3] || sub_8060867(i[1])) )
      break;
LABEL_23:
    ;
  }
  v6 = i[1];
  v5 = *(_DWORD *)(*(_DWORD *)(v6 + 792) + 4 * v4);
  while ( FS_FilenameCompare(*(char **)(v5 + 16), haystack) )
  {
    v5 = *(_DWORD *)(v5 + 20);
    if ( !v5 )
      goto LABEL_23;
  }
  if ( a2 )
    *(_DWORD *)a2 = *(_DWORD *)(v6 + 776);
  return 1;
}

//----- (08074C70) --------------------------------------------------------
int __cdecl sub_8074C70(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 )
  {
    while ( *a1 )
    {
      ++a1;
      ++v2;
    }
  }
  return v2;
}

//----- (08074C9D) --------------------------------------------------------
_DWORD *__cdecl sub_8074C9D(void *ptr, void *a2, void *a3)
{
  int v3; // eax
  _DWORD *i; // [esp+8h] [ebp-10h]
  _DWORD *j; // [esp+8h] [ebp-10h]
  _DWORD *k; // [esp+8h] [ebp-10h]
  _DWORD *v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+14h] [ebp-4h]

  v10 = sub_8074C70(ptr);
  v11 = sub_8074C70(a2) + v10;
  v3 = sub_8074C70(a3);
  v9 = Z_MallocInternal(4 * (v3 + v11) + 4);
  v8 = v9;
  if ( ptr )
  {
    for ( i = ptr; *i; ++i )
      *v8++ = *i;
  }
  if ( a2 )
  {
    for ( j = a2; *j; ++j )
      *v8++ = *j;
  }
  if ( a3 )
  {
    for ( k = a3; *k; ++k )
      *v8++ = *k;
  }
  *v8 = 0;
  if ( ptr )
    Z_FreeInternal(ptr);
  if ( a2 )
    Z_FreeInternal(a2);
  if ( a3 )
    Z_FreeInternal(a3);
  return v9;
}

//----- (08074DCC) --------------------------------------------------------
int __cdecl sub_8074DCC(char *a1, int a2)
{
  FILE *stream; // [esp+24h] [ebp-254h]
  int v4; // [esp+28h] [ebp-250h]
  void *v5; // [esp+2Ch] [ebp-24Ch]
  void *v6; // [esp+30h] [ebp-248h]
  void *v7; // [esp+34h] [ebp-244h]
  int v8; // [esp+38h] [ebp-240h] BYREF
  int v9; // [esp+3Ch] [ebp-23Ch] BYREF
  char dest[256]; // [esp+40h] [ebp-238h] BYREF
  char name[260]; // [esp+140h] [ebp-138h] BYREF
  char *s; // [esp+244h] [ebp-34h]
  void *ptr; // [esp+248h] [ebp-30h]
  void *v14; // [esp+24Ch] [ebp-2Ch]
  int v15; // [esp+250h] [ebp-28h]
  int v16; // [esp+254h] [ebp-24h]
  int v17; // [esp+258h] [ebp-20h] BYREF
  size_t v18; // [esp+25Ch] [ebp-1Ch]
  int v19; // [esp+260h] [ebp-18h]
  int j; // [esp+264h] [ebp-14h]
  int i; // [esp+268h] [ebp-10h]
  int v22; // [esp+26Ch] [ebp-Ch]
  char *v23; // [esp+280h] [ebp+8h]

  v14 = 0;
  ptr = 0;
  v5 = 0;
  v4 = 0;
  *a1 = 0;
  v19 = 0;
  v16 = 0;
  v22 = 0;
  v7 = sub_80D5975(*(char **)(dword_835B230 + 4), 0, 0, (int)&v8, 1);
  v6 = sub_80D5975(*(char **)(dword_8357200 + 4), 0, 0, (int)&v8, 1);
  if ( *(_DWORD *)(dword_835B248 + 4) && **(_BYTE **)(dword_835B248 + 4) )
    v5 = sub_80D5975(*(char **)(dword_835B248 + 4), 0, 0, (int)&v8, 1);
  v14 = sub_8074C9D(v7, v6, v5);
  v16 = sub_8074C70(v14);
  for ( i = 0; i < v16; ++i )
  {
    s = (char *)*((_DWORD *)v14 + i);
    if ( i )
    {
      v4 = 0;
      for ( j = 0; j < i; ++j )
      {
        if ( !Q_stricmp(*((char **)v14 + j), s) )
        {
          v4 = 1;
          break;
        }
      }
    }
    if ( !v4 && Q_stricmpn(s, ".", 1) )
    {
      sub_8060CD2(*(char **)(dword_8357200 + 4), s, (char *)&byte_80D9F00, name);
      v17 = 0;
      ptr = sub_80D5975(name, ".pk3", 0, (int)&v17, 0);
      sub_80D5D04(ptr);
      if ( v17 <= 0 )
      {
        sub_8060CD2(*(char **)(dword_835B248 + 4), s, (char *)&byte_80D9F00, name);
        v17 = 0;
        ptr = sub_80D5975(name, ".pk3", 0, (int)&v17, 0);
        sub_80D5D04(ptr);
      }
      if ( v17 <= 0 )
      {
        sub_8060CD2(*(char **)(dword_835B230 + 4), s, (char *)&byte_80D9F00, name);
        v17 = 0;
        ptr = sub_80D5975(name, ".pk3", 0, (int)&v17, 0);
        sub_80D5D04(ptr);
      }
      if ( v17 > 0 )
      {
        v18 = strlen(s) + 1;
        dest[0] = 0;
        strcpy(dest, s);
        strcat(dest, "/description.txt");
        v15 = FS_SV_FOpenFileRead(dest, (int)&v9);
        if ( v15 > 0 && v9 )
        {
          stream = (FILE *)sub_8060AA0(v9);
          sub_80D2FE9(dest, 0, 0x100u);
          v15 = fread(dest, 1u, 0x30u, stream);
          if ( v15 >= 0 )
            dest[v15] = 0;
          FS_FCloseFile(v9);
        }
        else if ( Q_stricmp(s, "main") )
        {
          strcpy(dest, s);
        }
        else
        {
          strcpy(dest, "Call of Duty Multiplayer");
        }
        v15 = strlen(dest) + 1;
        if ( (int)(v15 + v19 + v18 + 2) >= a2 )
          break;
        strcpy(a1, s);
        v23 = &a1[v18];
        strcpy(v23, dest);
        a1 = &v23[v15];
        v19 += v15 + v18;
        ++v22;
      }
    }
  }
  sub_80D5D04(v14);
  return v22;
}
// 8357200: using guessed type int dword_8357200;
// 835B230: using guessed type int dword_835B230;
// 835B248: using guessed type int dword_835B248;

//----- (080752D3) --------------------------------------------------------
void sub_80752D3()
{
  char v0; // [esp+4h] [ebp-24h]
  char v1; // [esp+4h] [ebp-24h]
  int i; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h] BYREF
  void *ptr; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h]
  char *s; // [esp+24h] [ebp-4h]

  if ( Cmd_Argc() > 1 && Cmd_Argc() <= 3 )
  {
    if ( Cmd_Argc() == 2 )
    {
      s = Cmd_Argv(1u);
      v5 = (char *)&byte_80D9F00;
    }
    else
    {
      s = Cmd_Argv(1u);
      v5 = Cmd_Argv(2u);
    }
    Com_Printf("Directory of %s %s\n", (char)s);
    Com_Printf("---------------\n", v1);
    ptr = sub_8064009(s, v5, (int)&v3);
    for ( i = 0; i < v3; ++i )
      Com_Printf("%s\n", *((_DWORD *)ptr + i));
    sub_8064032(ptr);
  }
  else
  {
    Com_Printf("usage: dir <directory> [extension]\n", v0);
  }
}
// 80752F6: variable 'v0' is possibly undefined
// 8075361: variable 'v1' is possibly undefined

//----- (080753C7) --------------------------------------------------------
void FS_NewDir_f()
{
  char v0; // [esp+4h] [ebp-24h]
  char v1; // [esp+4h] [ebp-24h]
  int ww; // [esp+18h] [ebp-10h]
  char v3[4]; // [esp+1Ch] [ebp-Ch] BYREF
  void *ptr; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  if ( Cmd_Argc() > 1 )
  {
    v5 = (int)Cmd_Argv(1u);
    Com_Printf("---------------\n", v0);
    ptr = FS_ListFilteredFiles((char *)&byte_80D9F00, (char *)&byte_80D9F00, v5, (int)v3);
    FS_SortFileList(ptr, *(int *)v3);
    for ( ww = 0; ww < *(int *)v3; ++ww )
    {
      FS_ConvertPath(*((_BYTE **)ptr + ww));
      Com_Printf("%s\n", *((_DWORD *)ptr + ww));
    }
    Com_Printf("%d files listed\n", v3[0]);
    sub_8064032(ptr);
  }
  else
  {
    Com_Printf("usage: fdir <filter>\n", v0);
    Com_Printf("example: fdir *q3dm*.bsp\n", v1);
  }
}
// 80753DE: variable 'v0' is possibly undefined
// 80753EA: variable 'v1' is possibly undefined

//----- (080754B6) --------------------------------------------------------
int sub_80754B6()
{
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 2 )
    return Com_Printf("Usage: touchFile <file>\n", v2);
  v1 = Cmd_Argv(1u);
  return sub_8062698(v1);
}
// 80754CD: variable 'v2' is possibly undefined

//----- (080754EA) --------------------------------------------------------
int __cdecl FS_iwPak(char *haystack, int a2)
{
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v10; // [esp+1Ch] [ebp-5Ch]
  char dest[76]; // [esp+20h] [ebp-58h] BYREF
  int v12[3]; // [esp+6Ch] [ebp-Ch]

  v2 = va("%s/mp_bin", (const char *)a2);
  if ( !FS_FilenameCompare(haystack, v2) )
    return 1;
  for ( v12[0] = 0; v12[0] <= 15; ++v12[0] )
  {
    v3 = va("%s/pak%x", (const char *)a2, v12[0]);
    if ( !FS_FilenameCompare(haystack, v3) )
      return 1;
    v4 = va("%s/mp_pak%x", (const char *)a2, v12[0]);
    if ( !FS_FilenameCompare(haystack, v4) )
      return 1;
    v5 = va("%s/sp_pak%x", (const char *)a2, v12[0]);
    if ( !FS_FilenameCompare(haystack, v5) )
      return 1;
  }
  v10 = strstr(haystack, "localized_");
  if ( v10 )
  {
    strcpy(dest, haystack);
    dest[v10 - haystack + 10] = 0;
    v6 = va("%s/localized_", (const char *)a2);
    if ( !FS_FilenameCompare(dest, v6) )
    {
      strcpy(dest, v10 + 10);
      sub_8085FAF(dest);
      for ( v12[0] = 0; v12[0] <= 15; ++v12[0] )
      {
        v7 = va("_pak%x", v12[0]);
        if ( strstr(dest, v7) )
          return 1;
      }
    }
  }
  return 0;
}

//----- (080756BF) --------------------------------------------------------
_BOOL4 __cdecl sub_80756BF(char *src)
{
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  strcpy(dest, src);
  sub_8085FAF(dest);
  return strstr(dest, "_svr_") != 0;
}

//----- (080759D9) --------------------------------------------------------
#error "80759EF: call analysis failed (funcsize=13)"

//----- (08075A4A) --------------------------------------------------------
_DWORD *sub_8075A4A()
{
  sub_806043E("path", (int)sub_80644E5);
  sub_806043E("fullpath", (int)sub_80644D1);
  sub_806043E("dir", (int)sub_80752D3);
  sub_806043E("fdir", (int)FS_NewDir_f);
  return sub_806043E("touchFile", (int)sub_80754B6);
}

//----- (08075AB6) --------------------------------------------------------
_DWORD *sub_8075AB6()
{
  _DWORD *result; // eax
  char v1; // [esp+4h] [ebp-14h]
  _DWORD *i; // [esp+14h] [ebp-4h]

  result = (_DWORD *)dword_835B23C;
  if ( *(_DWORD *)(dword_835B23C + 32) )
  {
    Cvar_Set("fs_restrict", "1");
    Com_Printf("\nRunning in restricted demo mode.\n\n", v1);
    sub_80655EA(0);
    sub_80656E5("demomain");
    result = fs_searchpaths;
    for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
    {
      if ( sub_80608CE((int)i) && i[1] && (*(_DWORD *)(i[1] + 772) ^ 0x2261994) != -1277981599 )
        Com_Error(0, "Corrupted pak0.pk3: %u", *(_DWORD *)(i[1] + 772));
      result = (_DWORD *)*i;
    }
  }
  return result;
}
// 8075AE7: variable 'v1' is possibly undefined
// 835B23C: using guessed type int dword_835B23C;

//----- (08075B76) --------------------------------------------------------
char *sub_8075B76()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8143100 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 772));
        sub_8086023(&byte_8143100, 0x2000, v0);
      }
    }
  }
  return &byte_8143100;
}

//----- (08075BEE) --------------------------------------------------------
char *sub_8075BEE()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8145100 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && !i[3] )
    {
      if ( byte_8145100 )
        sub_8086023(&byte_8145100, 0x2000, " ");
      sub_8086023(&byte_8145100, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_8145100;
}

//----- (08075C7A) --------------------------------------------------------
char *sub_8075C7A()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8147100 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] )
    {
      if ( !i[3] )
      {
        v0 = va("%i ", *(_DWORD *)(i[1] + 776));
        sub_8086023(&byte_8147100, 0x2000, v0);
      }
    }
  }
  return &byte_8147100;
}

//----- (08075CF2) --------------------------------------------------------
char *FS_ReferencedPakChecksums()
{
  char *v0; // eax
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_8149100 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_DWORD *)(i[1] + 784) || Q_stricmpn((char *)(i[1] + 512), "main", 4)) )
    {
      v0 = va("%i ", *(_DWORD *)(i[1] + 772));
      sub_8086023(&byte_8149100, 0x2000, v0);
    }
  }
  return &byte_8149100;
}

//----- (08075D9E) --------------------------------------------------------
char *FS_ReferencedPakNames()
{
  _DWORD *i; // [esp+14h] [ebp-4h]

  byte_814F100 = 0;
  for ( i = fs_searchpaths; i; i = (_DWORD *)*i )
  {
    if ( i[1] && (*(_DWORD *)(i[1] + 784) || Q_stricmpn((char *)(i[1] + 512), "main", 4)) )
    {
      if ( byte_814F100 )
        sub_8086023(&byte_814F100, 0x2000, " ");
      sub_8086023(&byte_814F100, 0x2000, (char *)(i[1] + 512));
      sub_8086023(&byte_814F100, 0x2000, "/");
      sub_8086023(&byte_814F100, 0x2000, (char *)(i[1] + 256));
    }
  }
  return &byte_814F100;
}

//----- (0807603C) --------------------------------------------------------
void *__cdecl sub_807603C(char **a1, char **a2)
{
  signed int v2; // ebx
  char *v3; // eax
  signed int v4; // ebx
  char *v5; // eax
  void *result; // eax
  void *ptr[4096]; // [esp+10h] [ebp-8018h] BYREF
  int src[4096]; // [esp+4010h] [ebp-4018h] BYREF
  int v9; // [esp+8010h] [ebp-18h]
  int v10; // [esp+8014h] [ebp-14h]
  int j; // [esp+8018h] [ebp-10h]
  signed int i; // [esp+801Ch] [ebp-Ch]

  Cmd_TokenizeString(a1);
  v10 = Cmd_Argc();
  if ( v10 > 4096 )
    v10 = 4096;
  for ( i = 0; i < v10; ++i )
  {
    v2 = i;
    v3 = Cmd_Argv(i);
    src[v2] = atoi(v3);
  }
  Cmd_TokenizeString(a2);
  v9 = Cmd_Argc();
  if ( v9 > 4096 )
    v9 = 4096;
  for ( i = 0; i < v9; ++i )
  {
    v4 = i;
    v5 = Cmd_Argv(i);
    ptr[v4] = sub_806BC0A(v5);
  }
  if ( v10 != v9 )
    Com_Error(1, "pak sum/name mismatch");
  if ( v10 == dword_835B22C )
  {
    i = 0;
LABEL_15:
    if ( i >= v10 )
    {
      for ( i = 0; ; ++i )
      {
        result = (void *)i;
        if ( i >= v9 )
          break;
        Z_FreeInternal(ptr[i]);
      }
      return result;
    }
    for ( j = 0; j < dword_835B22C; ++j )
    {
      if ( src[i] == dword_8357220[j] && !Q_stricmp((char *)ptr[i], (char *)*(&dword_835B260 + j)) )
      {
        ++i;
        goto LABEL_15;
      }
    }
  }
  sub_8065536();
  result = (void *)v10;
  dword_835B22C = v10;
  if ( v10 )
  {
    Com_DPrintf("Connected to a pure server.\n");
    sub_80D2FC8(dword_8357220, src, 4 * dword_835B22C);
    result = sub_80D2FC8(&dword_835B260, ptr, 4 * dword_835B22C);
    dword_835B238 = 0;
  }
  return result;
}
// 835B22C: using guessed type int dword_835B22C;
// 835B238: using guessed type int dword_835B238;

//----- (080763FB) --------------------------------------------------------
int __cdecl sub_80763FB(char a1, int a2)
{
  int result; // eax

  if ( (dword_80E95B8 & 7) == 0 )
    *(_BYTE *)((dword_80E95B8 >> 3) + a2) = 0;
  result = a1 << (dword_80E95B8 & 7);
  LOBYTE(result) = *(_BYTE *)((dword_80E95B8 >> 3) + a2) | result;
  *(_BYTE *)((dword_80E95B8++ >> 3) + a2) = result;
  return result;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08076464) --------------------------------------------------------
int __cdecl get_bit(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = ((int)*(unsigned __int8 *)((dword_80E95B8 >> 3) + a1) >> (dword_80E95B8 & 7)) & 1;
  ++dword_80E95B8;
  return v2;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08076497) --------------------------------------------------------
_DWORD *__cdecl sub_8076497(int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 1048) )
  {
    v4 = *(_DWORD **)(a1 + 1048);
    *(_DWORD *)(a1 + 1048) = *v4;
    v3 = v4;
  }
  else
  {
    v1 = a1 + 4 * (*(_DWORD *)(a1 + 4))++;
    v3 = (_DWORD *)(v1 + 25628);
  }
  return v3;
}

//----- (080764E7) --------------------------------------------------------
_DWORD *__cdecl sub_80764E7(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = *(_DWORD *)(a1 + 1048);
  result = a2;
  *(_DWORD *)(a1 + 1048) = a2;
  return result;
}

//----- (08076506) --------------------------------------------------------
_DWORD *__cdecl sub_8076506(int a1, int a2, int a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+0h] [ebp-8h]
  _DWORD *v5; // [esp+4h] [ebp-4h]

  v5 = *(_DWORD **)(a2 + 8);
  v4 = *(_DWORD **)(a3 + 8);
  if ( v5 )
  {
    if ( *v5 == a2 )
      *v5 = a3;
    else
      v5[1] = a3;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a3;
  }
  if ( v4 )
  {
    if ( *v4 == a3 )
      *v4 = a2;
    else
      v4[1] = a2;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a2;
  }
  *(_DWORD *)(a2 + 8) = v4;
  result = v5;
  *(_DWORD *)(a3 + 8) = v5;
  return result;
}

//----- (0807658E) --------------------------------------------------------
int __cdecl sub_807658E(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a2 + 12) = v3;
  v4 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v4;
  if ( *(_DWORD *)(a1 + 12) == a1 )
    *(_DWORD *)(a1 + 12) = a2;
  if ( *(_DWORD *)(a2 + 12) == a2 )
    *(_DWORD *)(a2 + 12) = a1;
  if ( *(_DWORD *)(a1 + 12) )
    *(_DWORD *)(*(_DWORD *)(a1 + 12) + 16) = a1;
  if ( *(_DWORD *)(a2 + 12) )
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16) = a2;
  if ( *(_DWORD *)(a1 + 16) )
    *(_DWORD *)(*(_DWORD *)(a1 + 16) + 12) = a1;
  result = a2;
  if ( *(_DWORD *)(a2 + 16) )
  {
    result = a2;
    *(_DWORD *)(*(_DWORD *)(a2 + 16) + 12) = a2;
  }
  return result;
}

//----- (0807664E) --------------------------------------------------------
void __cdecl sub_807664E(int a1, int a2)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a2 )
  {
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      v2 = **(_DWORD **)(a2 + 20);
      if ( v2 != *(_DWORD *)(a2 + 8) )
        sub_8076506(a1, v2, a2);
      sub_807658E(v2, a2);
    }
    if ( *(_DWORD *)(a2 + 16) && *(_DWORD *)(*(_DWORD *)(a2 + 16) + 24) == *(_DWORD *)(a2 + 24) )
    {
      **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 16);
    }
    else
    {
      **(_DWORD **)(a2 + 20) = 0;
      sub_80764E7(a1, *(_DWORD **)(a2 + 20));
    }
    ++*(_DWORD *)(a2 + 24);
    if ( *(_DWORD *)(a2 + 12) && *(_DWORD *)(*(_DWORD *)(a2 + 12) + 24) == *(_DWORD *)(a2 + 24) )
    {
      *(_DWORD *)(a2 + 20) = *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20);
    }
    else
    {
      *(_DWORD *)(a2 + 20) = sub_8076497(a1);
      **(_DWORD **)(a2 + 20) = a2;
    }
    if ( *(_DWORD *)(a2 + 8) )
    {
      sub_807664E(a1, *(_DWORD *)(a2 + 8));
      if ( *(_DWORD *)(a2 + 16) == *(_DWORD *)(a2 + 8) )
      {
        sub_807658E(a2, *(_DWORD *)(a2 + 8));
        if ( **(_DWORD **)(a2 + 20) == a2 )
          **(_DWORD **)(a2 + 20) = *(_DWORD *)(a2 + 8);
      }
    }
  }
}

//----- (080767B5) --------------------------------------------------------
void __cdecl sub_80767B5(_DWORD *a1, unsigned __int8 a2)
{
  int v2; // ecx
  _DWORD *v3; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]

  if ( a1[a2 + 5] )
  {
    sub_807664E((int)a1, a1[a2 + 5]);
  }
  else
  {
    v4 = &a1[8 * (*a1)++ + 263];
    v3 = &a1[8 * (*a1)++ + 263];
    v3[7] = 257;
    v3[6] = 1;
    v3[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12)
      && (*(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v3, *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1) )
    {
      v3[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
    }
    else
    {
      v3[5] = sub_8076497((int)a1);
      *(_DWORD *)v3[5] = v3;
    }
    *(_DWORD *)(a1[3] + 12) = v3;
    v3[4] = a1[3];
    v4[7] = a2;
    v4[6] = 1;
    v4[3] = *(_DWORD *)(a1[3] + 12);
    if ( *(_DWORD *)(a1[3] + 12) )
    {
      *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 16) = v4;
      if ( *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 24) == 1 )
      {
        v4[5] = *(_DWORD *)(*(_DWORD *)(a1[3] + 12) + 20);
      }
      else
      {
        v4[5] = sub_8076497((int)a1);
        *(_DWORD *)v4[5] = v3;
      }
    }
    else
    {
      v4[5] = sub_8076497((int)a1);
      *(_DWORD *)v4[5] = v4;
    }
    *(_DWORD *)(a1[3] + 12) = v4;
    v4[4] = a1[3];
    v4[1] = 0;
    *v4 = 0;
    if ( *(_DWORD *)(a1[3] + 8) )
    {
      if ( **(_DWORD **)(a1[3] + 8) == a1[3] )
        **(_DWORD **)(a1[3] + 8) = v3;
      else
        *(_DWORD *)(*(_DWORD *)(a1[3] + 8) + 4) = v3;
    }
    else
    {
      a1[2] = v3;
    }
    v3[1] = v4;
    *v3 = a1[3];
    v3[2] = *(_DWORD *)(a1[3] + 8);
    v2 = a1[3];
    v4[2] = v3;
    *(_DWORD *)(v2 + 8) = v3;
    a1[a2 + 5] = v4;
    sub_807664E((int)a1, v3[2]);
  }
}

//----- (08076A3A) --------------------------------------------------------
int __cdecl sub_8076A3A(_DWORD *a1, _DWORD *a2, int a3)
{
  int v3; // edx

  while ( a1 && a1[7] == 257 )
  {
    if ( get_bit(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( !a1 )
    return 0;
  v3 = a1[7];
  *a2 = v3;
  return v3;
}

//----- (08076A9B) --------------------------------------------------------
_DWORD *__cdecl Huff_offsetReceive(_DWORD *a1, _DWORD *a2, int a3, int *a4)
{
  _DWORD *result; // eax

  dword_80E95B8 = *a4;
  while ( a1 && a1[7] == 257 )
  {
    if ( get_bit(a3) )
      a1 = (_DWORD *)a1[1];
    else
      a1 = (_DWORD *)*a1;
  }
  if ( a1 )
  {
    *a2 = a1[7];
    result = (_DWORD *)dword_80E95B8;
    *a4 = dword_80E95B8;
  }
  else
  {
    result = a2;
    *a2 = 0;
  }
  return result;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08076B0B) --------------------------------------------------------
int __cdecl sub_8076B0B(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 8) )
    result = sub_8076B0B(*(_DWORD *)(a1 + 8), a1, a3);
  if ( a2 )
  {
    if ( *(_DWORD *)(a1 + 4) == a2 )
      result = sub_80763FB(1, a3);
    else
      result = sub_80763FB(0, a3);
  }
  return result;
}

//----- (08076B71) --------------------------------------------------------
int *__cdecl sub_8076B71(int a1, int a2, int a3)
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 4 * a2 + 20) )
    return (int *)sub_8076B0B(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = (int *)sub_8076B71(a1, 256, a3);
  for ( i = 7; i >= 0; --i )
  {
    sub_80763FB((a2 >> i) & 1, a3);
    result = &i;
  }
  return result;
}

//----- (08076BF4) --------------------------------------------------------
int __cdecl sub_8076BF4(int a1, int a2, int a3, int *a4)
{
  int result; // eax

  dword_80E95B8 = *a4;
  sub_8076B0B(*(_DWORD *)(a1 + 4 * a2 + 20), 0, a3);
  result = dword_80E95B8;
  *a4 = dword_80E95B8;
  return result;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08076C31) --------------------------------------------------------
unsigned __int8 *__cdecl Huff_Decompress(_DWORD *a1, int a2)
{
  unsigned __int8 *result; // eax
  int v3; // edx
  int *v4; // ecx
  int *v5; // edx
  int v6; // ebx
  int s[2]; // [esp+10h] [ebp-17058h] BYREF
  int *v8; // [esp+18h] [ebp-17050h]
  int *v9; // [esp+1Ch] [ebp-1704Ch]
  int *v10; // [esp+20h] [ebp-17048h]
  int *v11; // [esp+424h] [ebp-16C44h]
  unsigned __int8 *v12; // [esp+703Ch] [ebp-1002Ch]
  char src[65548]; // [esp+7040h] [ebp-10028h] BYREF
  int v14; // [esp+1704Ch] [ebp-1Ch]
  int i; // [esp+17050h] [ebp-18h]
  int j; // [esp+17054h] [ebp-14h]
  size_t n; // [esp+17058h] [ebp-10h]
  int v18[3]; // [esp+1705Ch] [ebp-Ch] BYREF

  v14 = a1[3] - a2;
  result = (unsigned __int8 *)(a1[1] + a2);
  v12 = result;
  if ( v14 > 0 )
  {
    sub_80D2FE9(s, 0, 0x701Cu);
    v11 = &s[8 * s[0] + 263];
    v10 = v11;
    v9 = v11;
    v8 = v11;
    ++s[0];
    v11[7] = 256;
    v8[6] = 0;
    v3 = (int)v9;
    v9[4] = 0;
    *(_DWORD *)(v3 + 12) = 0;
    v4 = v8;
    v5 = v8;
    v8[1] = 0;
    *v5 = 0;
    v4[2] = 0;
    n = v12[1] + (*v12 << 8);
    if ( (int)n > a1[2] - a2 )
      n = a1[2] - a2;
    dword_80E95B8 = 16;
    for ( i = 0; i < (int)n; ++i )
    {
      v18[0] = 0;
      if ( dword_80E95B8 >> 3 > v14 )
      {
        src[i] = 0;
        break;
      }
      sub_8076A3A(v8, v18, (int)v12);
      if ( v18[0] == 256 )
      {
        v18[0] = 0;
        for ( j = 0; j <= 7; ++j )
        {
          v6 = 2 * v18[0];
          v18[0] = get_bit((int)v12) + v6;
        }
      }
      src[i] = v18[0];
      sub_80767B5(s, v18[0]);
    }
    a1[3] = n + a2;
    result = (unsigned __int8 *)sub_80D2FC8((void *)(a1[1] + a2), src, n);
  }
  return result;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08076E5E) --------------------------------------------------------
unsigned __int8 *__cdecl sub_8076E5E(int a1, int a2)
{
  unsigned __int8 *result; // eax
  int v3; // edx
  int v4; // ecx
  int *v5; // edx
  int s[2]; // [esp+10h] [ebp-17048h] BYREF
  int *v7; // [esp+18h] [ebp-17040h]
  int *v8; // [esp+1Ch] [ebp-1703Ch]
  int *v9; // [esp+424h] [ebp-16C34h]
  unsigned __int8 *v10; // [esp+703Ch] [ebp-1001Ch]
  char src[65540]; // [esp+7040h] [ebp-10018h] BYREF
  int v12; // [esp+17044h] [ebp-14h]
  int v13; // [esp+17048h] [ebp-10h]
  int i; // [esp+1704Ch] [ebp-Ch]

  v12 = *(_DWORD *)(a1 + 12) - a2;
  result = (unsigned __int8 *)(*(_DWORD *)(a1 + 4) + a2);
  v10 = result;
  if ( v12 > 0 )
  {
    sub_80D2FE9(s, 0, 0x701Cu);
    v8 = &s[8 * s[0] + 263];
    v7 = v8;
    ++s[0];
    v8[7] = 256;
    v7[6] = 0;
    v3 = (int)v8;
    v8[4] = 0;
    *(_DWORD *)(v3 + 12) = 0;
    v4 = (int)v7;
    v5 = v7;
    v7[1] = 0;
    *v5 = 0;
    *(_DWORD *)(v4 + 8) = 0;
    v9 = v7;
    src[0] = BYTE1(v12);
    src[1] = v12;
    dword_80E95B8 = 16;
    for ( i = 0; i < v12; ++i )
    {
      v13 = v10[i];
      sub_8076B71((int)s, v13, (int)src);
      sub_80767B5(s, v13);
    }
    dword_80E95B8 += 8;
    *(_DWORD *)(a1 + 12) = a2 + (dword_80E95B8 >> 3);
    result = (unsigned __int8 *)sub_80D2FC8((void *)(*(_DWORD *)(a1 + 4) + a2), src, dword_80E95B8 >> 3);
  }
  return result;
}
// 80E95B8: using guessed type int dword_80E95B8;

//----- (08077008) --------------------------------------------------------
int __cdecl sub_8077008(void *s)
{
  int v1; // eax
  int v2; // edx
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  _DWORD *v6; // ecx
  int result; // eax

  sub_80D2FE9(s, 0, 0x701Cu);
  sub_80D2FE9((char *)s + 28700, 0, 0x701Cu);
  *((_DWORD *)s + 7436) = (char *)s + 32 * *((_DWORD *)s + 7175) + 29752;
  v1 = *((_DWORD *)s + 7436);
  *((_DWORD *)s + 7179) = v1;
  *((_DWORD *)s + 7178) = v1;
  *((_DWORD *)s + 7177) = v1;
  ++*((_DWORD *)s + 7175);
  *(_DWORD *)(*((_DWORD *)s + 7177) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 7177) + 24) = 0;
  v2 = *((_DWORD *)s + 7178);
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  v3 = (_DWORD *)*((_DWORD *)s + 7177);
  v3[1] = 0;
  *v3 = 0;
  v3[2] = 0;
  *((_DWORD *)s + 261) = (char *)s + 32 * *(_DWORD *)s + 1052;
  v4 = *((_DWORD *)s + 261);
  *((_DWORD *)s + 3) = v4;
  *((_DWORD *)s + 2) = v4;
  ++*(_DWORD *)s;
  *(_DWORD *)(*((_DWORD *)s + 2) + 28) = 256;
  *(_DWORD *)(*((_DWORD *)s + 2) + 24) = 0;
  v5 = *((_DWORD *)s + 3);
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 12) = 0;
  v6 = (_DWORD *)*((_DWORD *)s + 2);
  v6[1] = 0;
  *v6 = 0;
  v6[2] = 0;
  result = *((_DWORD *)s + 2);
  *((_DWORD *)s + 261) = result;
  return result;
}

//----- (080771A0) --------------------------------------------------------
long double __cdecl sub_80771A0(char *a1)
{
  float v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v3 = 0.0;
  while ( *a1 )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      if ( v4 || *a1 != 46 )
        return (float)0.0;
      v4 = 10;
      ++a1;
    }
    if ( v4 )
    {
      v3 = (long double)(*a1 - 48) / (long double)v4 + v3;
      v4 *= 10;
    }
    else
    {
      v3 = v3 * 10.0 + (long double)(*a1 - 48);
    }
    ++a1;
  }
  return v3;
}

//----- (0807725D) --------------------------------------------------------
char **__cdecl sub_807725D(char *s)
{
  size_t v1; // eax
  char **v3; // [esp+14h] [ebp-4h]

  v1 = strlen(s);
  v3 = (char **)sub_8077760(v1 + 25);
  memset(v3, 0, 0x18u);
  *v3 = (char *)(v3 + 6);
  strcpy(*v3, s);
  v3[5] = (char *)dword_836067C;
  dword_836067C = (int)v3;
  return v3;
}
// 836067C: using guessed type int dword_836067C;

//----- (080772CE) --------------------------------------------------------
int __cdecl sub_80772CE(int a1)
{
  if ( *(_DWORD *)(a1 + 4) )
    sub_807784C(*(_DWORD *)(a1 + 4));
  return sub_807784C(a1);
}

//----- (0807733C) --------------------------------------------------------
int __cdecl sub_807733C(char *a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = dword_836067C; i; i = *(_DWORD *)(i + 20) )
  {
    if ( !Q_stricmp(*(char **)i, a1) )
      return i;
  }
  return 0;
}
// 836067C: using guessed type int dword_836067C;

//----- (080773E9) --------------------------------------------------------
char **__cdecl sub_80773E9(char *a1, char *s)
{
  size_t v2; // eax
  char **v4; // [esp+10h] [ebp-8h]

  v4 = (char **)sub_807733C(a1);
  if ( !v4 )
  {
    v4 = sub_807725D(a1);
    v2 = strlen(s);
    v4[1] = (char *)sub_8077760(v2 + 1);
    strcpy(v4[1], s);
    *((float *)v4 + 4) = sub_80771A0(v4[1]);
    v4[3] = (char *)1;
  }
  return v4;
}

//----- (08077499) --------------------------------------------------------
long double __cdecl sub_8077499(char *a1, char *s)
{
  return *((float *)sub_80773E9(a1, s) + 4);
}

//----- (080775A8) --------------------------------------------------------
int __cdecl sub_80775A8(char *filename)
{
  char v2; // [esp+4h] [ebp-14h]

  if ( !filename || !*filename )
    return Com_Printf("openlog <filename>\n", v2);
  if ( stream )
    return Com_Printf("^1Error: log file %s is already opened\n", (char)byte_8151100);
  stream = fopen(filename, "wb");
  if ( !stream )
    return Com_Printf("^1Error: can't open the log file %s\n", (char)filename);
  strncpy(byte_8151100, filename, 0x400u);
  return Com_Printf("Opened log %s\n", (char)byte_8151100);
}
// 80775C3: variable 'v2' is possibly undefined

//----- (08077687) --------------------------------------------------------
void sub_8077687()
{
  if ( stream )
  {
    if ( fclose(stream) )
    {
      Com_Printf("^1Error: can't close log file %s\n", (char)byte_8151100);
    }
    else
    {
      stream = 0;
      Com_Printf("Closed log %s\n", (char)byte_8151100);
    }
  }
}

//----- (080776F5) --------------------------------------------------------
int sub_80776F5(char *format, ...)
{
  int result; // eax
  va_list va; // [esp+24h] [ebp+Ch] BYREF

  va_start(va, format);
  if ( stream )
  {
    vfprintf(stream, format, va);
    result = fflush(stream);
  }
  return result;
}

//----- (08077760) --------------------------------------------------------
_DWORD *__cdecl sub_8077760(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = Z_MallocInternal(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = 305419896;
  return v3 + 1;
}

//----- (080777A3) --------------------------------------------------------
_DWORD *__cdecl sub_80777A3(size_t n)
{
  _DWORD *s; // [esp+14h] [ebp-4h]

  s = sub_8077760(n);
  memset(s, 0, n);
  return s;
}

//----- (080777D6) --------------------------------------------------------
_DWORD *__cdecl sub_80777D6(int a1)
{
  _DWORD *v3; // [esp+14h] [ebp-4h]

  v3 = sub_806C482(a1 + 4);
  if ( !v3 )
    return 0;
  *v3 = -2023406815;
  return v3 + 1;
}

//----- (0807784C) --------------------------------------------------------
int __cdecl sub_807784C(int a1)
{
  int result; // eax

  result = a1 - 4;
  if ( *(_DWORD *)(a1 - 4) == 305419896 )
    result = Z_FreeInternal((void *)(a1 - 4));
  return result;
}

//----- (08077880) --------------------------------------------------------
int sub_8077880(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  return Com_Printf("^1Error: file %s, line %d: %s\n", *(_DWORD *)(a1 + 132));
}

//----- (080778E6) --------------------------------------------------------
int sub_80778E6(int a1, char *format, ...)
{
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  vsprintf(s, format, va);
  return Com_Printf("file %s, line %d: %s\n", *(_DWORD *)(a1 + 132));
}

//----- (0807794C) --------------------------------------------------------
_DWORD *__cdecl sub_807794C(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = sub_8077760(16);
  *result = a2;
  result[2] = a1[33];
  result[1] = a3 != 0;
  a1[38] += result[1];
  result[3] = a1[37];
  a1[37] = result;
  return result;
}

//----- (080779BD) --------------------------------------------------------
int __cdecl sub_80779BD(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  *a2 = 0;
  *a3 = 0;
  result = a1[37];
  v4 = (_DWORD *)result;
  if ( result )
  {
    result = *(_DWORD *)(a1[37] + 8);
    if ( result == a1[33] )
    {
      *a2 = *v4;
      *a3 = v4[1];
      a1[37] = *(_DWORD *)(a1[37] + 12);
      a1[38] -= v4[1];
      result = sub_807784C((int)v4);
    }
  }
  return result;
}

//----- (08077A58) --------------------------------------------------------
int __cdecl sub_8077A58(int a1, int a2)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 132); i; i = *(_DWORD *)(i + 1184) )
  {
    if ( !Q_stricmp((char *)i, (char *)a2) )
      return sub_8077880(a1, "%s recursively included", (const char *)a2);
  }
  *(_DWORD *)(a2 + 1184) = *(_DWORD *)(a1 + 132);
  result = a2;
  *(_DWORD *)(a1 + 132) = a2;
  return result;
}

//----- (08077AD2) --------------------------------------------------------
void sub_8077AD2()
{
  ;
}

//----- (08077AD7) --------------------------------------------------------
_DWORD *__cdecl sub_8077AD7(void *src)
{
  _DWORD *dest; // [esp+14h] [ebp-4h]

  dest = sub_8077760(1068);
  if ( !dest )
    Com_Error(0, "EXE_ERR_OUT_OF_MEMORY");
  memcpy(dest, src, 0x42Cu);
  dest[266] = 0;
  ++dword_83607A0;
  return dest;
}
// 83607A0: using guessed type int dword_83607A0;

//----- (08077B47) --------------------------------------------------------
int __cdecl sub_8077B47(int a1)
{
  int result; // eax

  result = sub_807784C(a1);
  --dword_83607A0;
  return result;
}
// 83607A0: using guessed type int dword_83607A0;

//----- (08077B60) --------------------------------------------------------
int __cdecl sub_8077B60(int a1, void *dest)
{
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h]

  while ( !*(_DWORD *)(a1 + 136) )
  {
    if ( sub_807DFA6(*(_DWORD **)(a1 + 132), dest) )
      return 1;
    if ( sub_807EAAC(*(_DWORD *)(a1 + 132)) )
    {
      while ( *(_DWORD *)(a1 + 148) && *(_DWORD *)(*(_DWORD *)(a1 + 148) + 8) == *(_DWORD *)(a1 + 132) )
      {
        sub_80778E6(a1, "missing #endif");
        sub_80779BD((_DWORD *)a1, &v5, &v4);
      }
    }
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184) )
      return 0;
    v6 = *(_DWORD *)(a1 + 132);
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 1184);
    sub_807EDD5(v6);
  }
  memcpy(dest, *(const void **)(a1 + 136), 0x42Cu);
  v7 = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(*(_DWORD *)(a1 + 136) + 1064);
  sub_8077B47(v7);
  return 1;
}

//----- (08077CB5) --------------------------------------------------------
int __cdecl sub_8077CB5(int a1, void *src)
{
  _DWORD *v2; // eax

  v2 = sub_8077AD7(src);
  v2[266] = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v2;
  return 1;
}

//----- (08077CEE) --------------------------------------------------------
int __cdecl sub_8077CEE(int a1, const char **a2, int a3, int a4)
{
  int v5; // [esp+10h] [ebp-458h]
  int v6; // [esp+14h] [ebp-454h]
  int v7; // [esp+18h] [ebp-450h]
  int v8; // [esp+1Ch] [ebp-44Ch]
  int v9; // [esp+20h] [ebp-448h]
  int i; // [esp+24h] [ebp-444h]
  _DWORD *v11; // [esp+28h] [ebp-440h]
  _DWORD *v12; // [esp+2Ch] [ebp-43Ch]
  char s1[1080]; // [esp+30h] [ebp-438h] BYREF

  if ( sub_8077B60(a1, s1) )
  {
    if ( (int)a2[3] <= a4 )
    {
      for ( i = 0; i < (int)a2[3]; ++i )
        *(_DWORD *)(a3 + 4 * i) = 0;
      if ( !strcmp(s1, "(") )
      {
        v9 = 0;
        v7 = 0;
        v6 = 0;
        while ( !v9 )
        {
          if ( v7 >= a4 )
          {
            sub_8077880(a1, "define %s with too many parms", *a2);
            return 0;
          }
          if ( v7 >= (int)a2[3] )
          {
            sub_80778E6(a1, "define %s has too many parms", *a2);
            return 0;
          }
          *(_DWORD *)(a3 + 4 * v7) = 0;
          v8 = 1;
          v11 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              if ( !sub_8077B60(a1, s1) )
              {
                sub_8077880(a1, "define %s incomplete", *a2);
                return 0;
              }
              if ( !strcmp(s1, ",") && v6 <= 0 )
              {
                if ( v8 )
                  sub_80778E6(a1, "too many comma's");
                goto LABEL_36;
              }
              v8 = 0;
              if ( strcmp(s1, "(") )
                break;
              ++v6;
            }
            if ( !strcmp(s1, ")") && --v6 <= 0 )
              break;
            if ( v7 < (int)a2[3] )
            {
              v12 = sub_8077AD7(s1);
              v12[266] = 0;
              if ( v11 )
                v11[266] = v12;
              else
                *(_DWORD *)(a3 + 4 * v7) = v12;
              v11 = v12;
            }
          }
          if ( !*(_DWORD *)(a3 + 4 * (_DWORD)a2[3] - 4) )
            sub_80778E6(a1, "too few define parms");
          v9 = 1;
LABEL_36:
          ++v7;
        }
        v5 = 1;
      }
      else
      {
        sub_8077CB5(a1, s1);
        sub_8077880(a1, "define %s missing parms", *a2);
        v5 = 0;
      }
    }
    else
    {
      sub_8077880(a1, "define with more than %d parameters", a4);
      v5 = 0;
    }
  }
  else
  {
    sub_8077880(a1, "define %s missing parms", *a2);
    v5 = 0;
  }
  return v5;
}
// 8077ED1: conditional instruction was optimized away because of '%var_448.4==0'

//----- (08078095) --------------------------------------------------------
int __cdecl sub_8078095(int a1, char *dest)
{
  size_t v2; // eax
  size_t v3; // eax

  *((_DWORD *)dest + 256) = 1;
  *((_DWORD *)dest + 262) = 0;
  *((_DWORD *)dest + 263) = 0;
  *dest = 0;
  strcat(dest, "\"");
  while ( a1 )
  {
    v2 = strlen(dest);
    strncat(dest, (const char *)a1, 1024 - v2);
    a1 = *(_DWORD *)(a1 + 1064);
  }
  v3 = strlen(dest);
  strncat(dest, "\"", 1024 - v3);
  return 1;
}

//----- (08078153) --------------------------------------------------------
int __cdecl sub_8078153(char *dest, char *src)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( *((_DWORD *)dest + 256) == 4 && (*((_DWORD *)src + 256) == 4 || *((_DWORD *)src + 256) == 3) )
  {
    strcat(dest, src);
    v3 = 1;
  }
  else if ( *((_DWORD *)dest + 256) == 1 && *((_DWORD *)src + 256) == 1 )
  {
    dest[strlen(dest) - 1] = 0;
    strcat(dest, src + 1);
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  return v3;
}

//----- (0807826D) --------------------------------------------------------
int __cdecl sub_807826D(int a1)
{
  int i; // [esp+0h] [ebp-8h]
  int v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; *(_BYTE *)(i + a1); ++i )
    v3 += *(char *)(i + a1) * (i + 119);
  return ((unsigned __int16)(v3 >> 20) ^ (unsigned __int16)((v3 >> 10) ^ v3)) & 0x3FF;
}

//----- (080782CC) --------------------------------------------------------
int *__cdecl sub_80782CC(int *a1, int a2)
{
  int v2; // eax
  int v3; // ecx
  int *result; // eax

  v2 = sub_807826D(*a1);
  a1[7] = *(_DWORD *)(a2 + 4 * v2);
  v3 = 4 * v2;
  result = a1;
  *(_DWORD *)(a2 + v3) = a1;
  return result;
}

//----- (0807830D) --------------------------------------------------------
int __cdecl sub_807830D(int a1, char *s2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 4 * sub_807826D((int)s2)); i; i = *(_DWORD *)(i + 28) )
  {
    if ( !strcmp(*(const char **)i, s2) )
      return i;
  }
  return 0;
}

//----- (08078373) --------------------------------------------------------
int __cdecl sub_8078373(int a1, char *s2)
{
  while ( a1 )
  {
    if ( !strcmp(*(const char **)a1, s2) )
      return a1;
    a1 = *(_DWORD *)(a1 + 24);
  }
  return 0;
}

//----- (080783BE) --------------------------------------------------------
int __cdecl sub_80783BE(int a1, char *s2)
{
  int v4; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v4 = 0;
  for ( s1 = *(char **)(a1 + 16); s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    if ( !strcmp(s1, s2) )
      return v4;
    ++v4;
  }
  return -1;
}

//----- (08078419) --------------------------------------------------------
int __cdecl sub_8078419(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(a1 + 16); i; i = v2 )
  {
    v2 = *(_DWORD *)(i + 1064);
    sub_8077B47(i);
  }
  for ( j = *(_DWORD *)(a1 + 20); j; j = v3 )
  {
    v3 = *(_DWORD *)(j + 1064);
    sub_8077B47(j);
  }
  return sub_807784C(a1);
}

//----- (08078589) --------------------------------------------------------
int __cdecl sub_8078589(int a1, void *src, int a3, int a4, int a5)
{
  char *v5; // ebx
  char *v6; // ebx
  char *ptr; // [esp+18h] [ebp-10h]
  char *ptra; // [esp+18h] [ebp-10h]
  time_t timer; // [esp+1Ch] [ebp-Ch] BYREF
  char *s; // [esp+20h] [ebp-8h]

  s = (char *)sub_8077AD7(src);
  switch ( *(_DWORD *)(a3 + 8) )
  {
    case 1:
      sprintf(s, "%d", *((_DWORD *)src + 264));
      *((_DWORD *)s + 258) = *((_DWORD *)src + 264);
      *(long double *)(s + 1036) = (long double)*((int *)src + 264);
      *((_DWORD *)s + 256) = 3;
      *((_DWORD *)s + 257) = 4104;
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 2:
      strcpy(s, *(const char **)(a1 + 132));
      *((_DWORD *)s + 256) = 4;
      *((_DWORD *)s + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 3:
      timer = time(0);
      ptr = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptr + 4, 7u);
      strncat(s + 7, ptr + 20, 4u);
      strcat(s, "\"");
      free(ptr);
      *((_DWORD *)s + 256) = 4;
      v5 = s;
      *((_DWORD *)v5 + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    case 4:
      timer = time(0);
      ptra = ctime(&timer);
      strcpy(s, "\"");
      strncat(s, ptra + 11, 8u);
      strcat(s, "\"");
      free(ptra);
      *((_DWORD *)s + 256) = 4;
      v6 = s;
      *((_DWORD *)v6 + 257) = strlen(s);
      *(_DWORD *)a4 = s;
      *(_DWORD *)a5 = s;
      break;
    default:
      *(_DWORD *)a4 = 0;
      *(_DWORD *)a5 = 0;
      break;
  }
  return 1;
}

//----- (080787FF) --------------------------------------------------------
int __cdecl sub_80787FF(int a1, void *a2, int a3, int a4, int a5)
{
  int j; // [esp+28h] [ebp-660h]
  int v8; // [esp+2Ch] [ebp-65Ch]
  int v9; // [esp+2Ch] [ebp-65Ch]
  char dest[1072]; // [esp+30h] [ebp-658h] BYREF
  void *v11; // [esp+460h] [ebp-228h]
  char *v12; // [esp+464h] [ebp-224h]
  _DWORD *v13; // [esp+468h] [ebp-220h]
  char *src; // [esp+46Ch] [ebp-21Ch]
  char *v15; // [esp+470h] [ebp-218h]
  _DWORD *v16; // [esp+474h] [ebp-214h]
  void *i; // [esp+478h] [ebp-210h]
  char *s2; // [esp+47Ch] [ebp-20Ch]
  int v19[130]; // [esp+480h] [ebp-208h] BYREF

  if ( *(_DWORD *)(a3 + 8) )
    return sub_8078589(a1, a2, a3, a4, a5);
  if ( *(_DWORD *)(a3 + 12) && !sub_8077CEE(a1, (const char **)a3, (int)v19, 128) )
    return 0;
  v13 = 0;
  v12 = 0;
  for ( s2 = *(char **)(a3 + 20); s2; s2 = (char *)*((_DWORD *)s2 + 266) )
  {
    v8 = -1;
    if ( *((_DWORD *)s2 + 256) == 4 )
      v8 = sub_80783BE(a3, s2);
    if ( v8 < 0 )
    {
      if ( *s2 != 35 || s2[1] )
      {
        v16 = sub_8077AD7(s2);
      }
      else
      {
        if ( *((_DWORD *)s2 + 266) )
          v9 = sub_80783BE(a3, *((char **)s2 + 266));
        else
          v9 = -1;
        if ( v9 < 0 )
        {
          sub_80778E6(a1, "stringizing operator without define parameter");
          continue;
        }
        s2 = (char *)*((_DWORD *)s2 + 266);
        if ( !sub_8078095(v19[v9], dest) )
        {
          sub_8077880(a1, "can't stringize tokens");
          return 0;
        }
        v16 = sub_8077AD7(dest);
      }
      v16[266] = 0;
      if ( v12 )
        *((_DWORD *)v12 + 266) = v16;
      else
        v13 = v16;
      v12 = (char *)v16;
    }
    else
    {
      for ( i = (void *)v19[v8]; i; i = (void *)*((_DWORD *)i + 266) )
      {
        v16 = sub_8077AD7(i);
        v16[266] = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v16;
        else
          v13 = v16;
        v12 = (char *)v16;
      }
    }
  }
  v16 = v13;
  while ( v16 )
  {
    if ( v16[266]
      && *(_BYTE *)v16[266] == 35
      && *(_BYTE *)(v16[266] + 1) == 35
      && (v15 = (char *)v16, (src = *(char **)(v16[266] + 1064)) != 0) )
    {
      if ( !sub_8078153(v15, src) )
      {
        sub_8077880(a1, "can't merge %s with %s", v15, src);
        return 0;
      }
      sub_8077B47(*((_DWORD *)v15 + 266));
      *((_DWORD *)v15 + 266) = *((_DWORD *)src + 266);
      if ( src == v12 )
        v12 = v15;
      sub_8077B47((int)src);
    }
    else
    {
      v16 = (_DWORD *)v16[266];
    }
  }
  *(_DWORD *)a4 = v13;
  *(_DWORD *)a5 = v12;
  for ( j = 0; j < *(_DWORD *)(a3 + 12); ++j )
  {
    for ( i = (void *)v19[j]; i; i = v11 )
    {
      v11 = (void *)*((_DWORD *)i + 266);
      sub_8077B47((int)i);
    }
  }
  return 1;
}

//----- (08078CB9) --------------------------------------------------------
int __cdecl sub_8078CB9(int a1, void *a2, int a3)
{
  int v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  if ( !sub_80787FF(a1, a2, a3, (int)&v6, (int)&v5) )
    return 0;
  if ( !v6 || !v5 )
    return 0;
  *(_DWORD *)(v5 + 1064) = *(_DWORD *)(a1 + 136);
  *(_DWORD *)(a1 + 136) = v6;
  return 1;
}

//----- (08078D32) --------------------------------------------------------
char *__cdecl sub_8078D32(char *a1)
{
  char *result; // eax
  char *dest; // [esp+14h] [ebp-4h]
  char *desta; // [esp+14h] [ebp-4h]

  dest = a1;
  while ( *dest )
  {
    if ( (*dest == 92 || *dest == 47) && (dest[1] == 92 || dest[1] == 47) )
      strcpy(dest, dest + 1);
    else
      ++dest;
  }
  for ( desta = a1; ; ++desta )
  {
    result = desta;
    if ( !*desta )
      break;
    if ( *desta == 47 || *desta == 92 )
      *desta = 47;
  }
  return result;
}

//----- (08078DBB) --------------------------------------------------------
int __cdecl sub_8078DBB(int a1)
{
  int v2; // [esp+1Ch] [ebp-48Ch]
  char dest[64]; // [esp+20h] [ebp-488h] BYREF
  char src[1024]; // [esp+60h] [ebp-448h] BYREF
  int v5; // [esp+460h] [ebp-48h]
  int v6; // [esp+484h] [ebp-24h]
  char **v7; // [esp+49Ch] [ebp-Ch]

  if ( *(int *)(a1 + 152) > 0 )
    return 1;
  if ( !sub_8077B60(a1, src) || v6 > 0 )
    goto LABEL_4;
  if ( v5 != 1 )
  {
    if ( v5 == 5 && src[0] == 60 )
    {
      strcpy(dest, (const char *)(a1 + 64));
      while ( sub_8077B60(a1, src) )
      {
        if ( v6 > 0 )
        {
          sub_8077CB5(a1, src);
          break;
        }
        if ( v5 == 5 && src[0] == 62 )
          break;
        strncat(dest, src, 0x40u);
      }
      if ( src[0] != 62 )
        sub_80778E6(a1, "#include missing trailing >");
      if ( !dest[0] )
      {
        sub_8077880(a1, "#include without file name between < >");
        return 0;
      }
      sub_8078D32(dest);
      v7 = sub_807EB4F(dest);
      goto LABEL_24;
    }
LABEL_4:
    sub_8077880(a1, "#include without file name");
    return 0;
  }
  sub_807E819(src);
  sub_8078D32(src);
  v7 = sub_807EB4F(src);
  if ( !v7 )
  {
    strcpy(dest, (const char *)(a1 + 64));
    strcat(dest, src);
    v7 = sub_807EB4F(dest);
  }
LABEL_24:
  if ( v7 )
  {
    sub_8077A58(a1, (int)v7);
    v2 = 1;
  }
  else
  {
    sub_8077880(a1, "file %s not found", dest);
    v2 = 0;
  }
  return v2;
}

//----- (08079039) --------------------------------------------------------
int __cdecl sub_8079039(int a1, char *s1)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = 0;
  do
  {
    if ( !sub_8077B60(a1, s1) )
      return 0;
    if ( *((_DWORD *)s1 + 265) > v4 )
    {
      sub_8077CB5(a1, s1);
      return 0;
    }
    v4 = 1;
  }
  while ( !strcmp(s1, "\\") );
  return 1;
}

//----- (080790B8) --------------------------------------------------------
_BOOL4 __cdecl sub_80790B8(int a1)
{
  return *(_DWORD *)(a1 + 1052) - *(_DWORD *)(a1 + 1048) > 0;
}

//----- (080790E7) --------------------------------------------------------
_DWORD *__cdecl sub_80790E7(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[262] = 0;
  a1[263] = 0;
  result = a1;
  a1[265] = 0;
  return result;
}

//----- (08079113) --------------------------------------------------------
int __cdecl sub_8079113(int a1)
{
  int v2; // [esp+10h] [ebp-448h]
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v7; // [esp+420h] [ebp-38h]

  if ( *(int *)(a1 + 152) > 0 )
    return 1;
  if ( sub_8079039(a1, s2) )
  {
    if ( v7 == 4 )
    {
      v3 = sub_807826D((int)s2);
      v4 = 0;
      for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3); i; i = *(_DWORD *)(i + 28) )
      {
        if ( !strcmp(*(const char **)i, s2) )
        {
          if ( (*(_DWORD *)(i + 4) & 1) != 0 )
          {
            sub_80778E6(a1, "can't undef %s", s2);
          }
          else
          {
            if ( v4 )
              *(_DWORD *)(v4 + 28) = *(_DWORD *)(i + 28);
            else
              *(_DWORD *)(*(_DWORD *)(a1 + 144) + 4 * v3) = *(_DWORD *)(i + 28);
            sub_8078419(i);
          }
          break;
        }
        v4 = i;
      }
      v2 = 1;
    }
    else
    {
      sub_8077CB5(a1, s2);
      sub_8077880(a1, "expected name, found %s", s2);
      v2 = 0;
    }
  }
  else
  {
    sub_8077880(a1, "undef without name");
    v2 = 0;
  }
  return v2;
}

//----- (080792D2) --------------------------------------------------------
int __cdecl sub_80792D2(int a1)
{
  size_t v1; // eax
  _DWORD *v4; // [esp+14h] [ebp-444h]
  char **v5; // [esp+14h] [ebp-444h]
  char *v6; // [esp+18h] [ebp-440h]
  char *v7; // [esp+18h] [ebp-440h]
  char *s1; // [esp+1Ch] [ebp-43Ch]
  char *s1a; // [esp+1Ch] [ebp-43Ch]
  char s[1024]; // [esp+20h] [ebp-438h] BYREF
  int v11; // [esp+420h] [ebp-38h]

  if ( *(int *)(a1 + 152) > 0 )
    return 1;
  if ( !sub_8079039(a1, s) )
  {
    sub_8077880(a1, "#define without name");
    return 0;
  }
  if ( v11 != 4 )
  {
    sub_8077CB5(a1, s);
    sub_8077880(a1, "expected name after #define, found %s", s);
    return 0;
  }
  v4 = (_DWORD *)sub_807830D(*(_DWORD *)(a1 + 144), s);
  if ( v4 )
  {
    if ( (v4[1] & 1) != 0 )
    {
      sub_8077880(a1, "can't redefine %s", s);
      return 0;
    }
    sub_80778E6(a1, "redefinition of %s", s);
    sub_8077CB5(a1, s);
    if ( !sub_8079113(a1) )
      return 0;
    sub_807830D(*(_DWORD *)(a1 + 144), s);
  }
  v1 = strlen(s);
  v5 = (char **)sub_8077760(v1 + 33);
  memset(v5, 0, 0x20u);
  *v5 = (char *)(v5 + 8);
  strcpy(*v5, s);
  sub_80782CC((int *)v5, *(_DWORD *)(a1 + 144));
  if ( !sub_8079039(a1, s) )
    return 1;
  if ( sub_80790B8((int)s) || strcmp(s, "(") )
    goto LABEL_34;
  v6 = 0;
  if ( sub_807C4C1(a1, ")") )
  {
LABEL_32:
    if ( !sub_8079039(a1, s) )
      return 1;
LABEL_34:
    v7 = 0;
    do
    {
      s1a = (char *)sub_8077AD7(s);
      if ( *((_DWORD *)s1a + 256) == 4 && !strcmp(s1a, *v5) )
      {
        sub_8077880(a1, "recursive define (removed recursion)");
      }
      else
      {
        sub_80790E7(s1a);
        *((_DWORD *)s1a + 266) = 0;
        if ( v7 )
          *((_DWORD *)v7 + 266) = s1a;
        else
          v5[5] = s1a;
        v7 = s1a;
      }
    }
    while ( sub_8079039(a1, s) );
    if ( !v7 || strcmp(v5[5], "##") && strcmp(v7, "##") )
      return 1;
    sub_8077880(a1, "define with misplaced ##");
    return 0;
  }
  do
  {
    if ( !sub_8079039(a1, s) )
    {
      sub_8077880(a1, "expected define parameter");
      return 0;
    }
    if ( v11 != 4 )
    {
      sub_8077880(a1, "invalid define parameter");
      return 0;
    }
    if ( sub_80783BE((int)v5, s) >= 0 )
    {
      sub_8077880(a1, "two the same define parameters");
      return 0;
    }
    s1 = (char *)sub_8077AD7(s);
    sub_80790E7(s1);
    *((_DWORD *)s1 + 266) = 0;
    if ( v6 )
      *((_DWORD *)v6 + 266) = s1;
    else
      v5[4] = s1;
    v6 = s1;
    ++v5[3];
    if ( !sub_8079039(a1, s) )
    {
      sub_8077880(a1, "define parameters not terminated");
      return 0;
    }
    if ( !strcmp(s, ")") )
      goto LABEL_32;
  }
  while ( !strcmp(s, ",") );
  sub_8077880(a1, "define not terminated");
  return 0;
}

//----- (0807986E) --------------------------------------------------------
int __cdecl sub_807986E(char *s)
{
  size_t v1; // eax
  int v4; // [esp+20h] [ebp-4F8h]
  int j; // [esp+24h] [ebp-4F4h]
  int v6; // [esp+28h] [ebp-4F0h]
  int i; // [esp+2Ch] [ebp-4ECh]
  char dest[132]; // [esp+30h] [ebp-4E8h] BYREF
  _DWORD *v9; // [esp+B4h] [ebp-464h]
  int v10; // [esp+B8h] [ebp-460h]
  int v11; // [esp+BCh] [ebp-45Ch]
  _DWORD *v12; // [esp+C0h] [ebp-458h]
  _DWORD *v13; // [esp+50Ch] [ebp-Ch]

  sub_8077AD2();
  v1 = strlen(s);
  v13 = sub_807ECED(s, v1, "*extern");
  memset(dest, 0, 0x4C8u);
  strncpy(dest, "*extern", 0x40u);
  v9 = v13;
  v12 = sub_80777A3(0x1000u);
  v6 = sub_80792D2((int)dest);
  for ( i = v10; i; i = v10 )
  {
    v10 = *(_DWORD *)(v10 + 1064);
    sub_8077B47(i);
  }
  v4 = 0;
  for ( j = 0; j <= 1023; ++j )
  {
    if ( v12[j] )
    {
      v4 = v12[j];
      break;
    }
  }
  sub_807784C((int)v12);
  sub_807EDD5((int)v13);
  if ( v6 > 0 )
    return v4;
  if ( v11 )
    sub_8078419(v4);
  return 0;
}

//----- (08079B14) --------------------------------------------------------
char **__cdecl sub_8079B14(int a1, int a2)
{
  size_t v2; // eax
  char *v4; // [esp+8h] [ebp-10h]
  char *v5; // [esp+8h] [ebp-10h]
  char *v6; // [esp+Ch] [ebp-Ch]
  char *v7; // [esp+Ch] [ebp-Ch]
  _DWORD *src; // [esp+10h] [ebp-8h]
  _DWORD *srca; // [esp+10h] [ebp-8h]
  char **v10; // [esp+14h] [ebp-4h]

  v2 = strlen(*(const char **)a2);
  v10 = (char **)sub_8077760(v2 + 33);
  *v10 = (char *)(v10 + 8);
  strcpy(*v10, *(const char **)a2);
  v10[1] = *(char **)(a2 + 4);
  v10[2] = *(char **)(a2 + 8);
  v10[3] = *(char **)(a2 + 12);
  v10[6] = 0;
  v10[7] = 0;
  v10[5] = 0;
  v4 = 0;
  for ( src = *(_DWORD **)(a2 + 20); src; src = (_DWORD *)src[266] )
  {
    v6 = (char *)sub_8077AD7(src);
    *((_DWORD *)v6 + 266) = 0;
    if ( v4 )
      *((_DWORD *)v4 + 266) = v6;
    else
      v10[5] = v6;
    v4 = v6;
  }
  v10[4] = 0;
  v5 = 0;
  for ( srca = *(_DWORD **)(a2 + 16); srca; srca = (_DWORD *)srca[266] )
  {
    v7 = (char *)sub_8077AD7(srca);
    *((_DWORD *)v7 + 266) = 0;
    if ( v5 )
      *((_DWORD *)v5 + 266) = v7;
    else
      v10[4] = v7;
    v5 = v7;
  }
  return v10;
}

//----- (08079C6F) --------------------------------------------------------
int __cdecl sub_8079C6F(int a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  result = dword_83607A4;
  for ( i = dword_83607A4; i; i = result )
  {
    v2 = (int *)sub_8079B14(a1, i);
    sub_80782CC(v2, *(_DWORD *)(a1 + 144));
    result = *(_DWORD *)(i + 24);
  }
  return result;
}
// 83607A4: using guessed type int dword_83607A4;

//----- (08079CBF) --------------------------------------------------------
int __cdecl sub_8079CBF(_DWORD *a1, int a2)
{
  int v3; // [esp+14h] [ebp-444h]
  int v4; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v6; // [esp+420h] [ebp-38h]

  if ( sub_8079039((int)a1, s2) )
  {
    if ( v6 == 4 )
    {
      v4 = sub_807830D(a1[36], s2);
      sub_807794C(a1, a2, (a2 != 8) ^ (v4 == 0));
      v3 = 1;
    }
    else
    {
      sub_8077CB5((int)a1, s2);
      sub_8077880((int)a1, "expected name after #ifdef, found %s", s2);
      v3 = 0;
    }
  }
  else
  {
    sub_8077880((int)a1, "#ifdef without name");
    v3 = 0;
  }
  return v3;
}

//----- (08079DB5) --------------------------------------------------------
int __cdecl sub_8079DB5(_DWORD *a1)
{
  return sub_8079CBF(a1, 8);
}

//----- (08079DD0) --------------------------------------------------------
int __cdecl sub_8079DD0(_DWORD *a1)
{
  return sub_8079CBF(a1, 16);
}

//----- (08079DEB) --------------------------------------------------------
int __cdecl sub_8079DEB(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  char v3[4]; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  sub_80779BD(a1, &v4, v3);
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      sub_8077880((int)a1, "#else after #else");
      v2 = 0;
    }
    else
    {
      sub_807794C(a1, 2, *(_DWORD *)v3 == 0);
      v2 = 1;
    }
  }
  else
  {
    sub_8077880((int)a1, "misplaced #else");
    v2 = 0;
  }
  return v2;
}

//----- (08079E7B) --------------------------------------------------------
int __cdecl sub_8079E7B(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h] BYREF
  int v4; // [esp+14h] [ebp-4h] BYREF

  sub_80779BD(a1, &v4, &v3);
  if ( v4 )
    return 1;
  sub_8077880((int)a1, "misplaced #endif");
  return 0;
}

//----- (08079EC8) --------------------------------------------------------
int __cdecl sub_8079EC8(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  switch ( a1 )
  {
    case 5:
      v2 = 7;
      break;
    case 6:
      v2 = 6;
      break;
    case 7:
      v2 = 12;
      break;
    case 8:
      v2 = 12;
      break;
    case 9:
      v2 = 11;
      break;
    case 10:
      v2 = 11;
      break;
    case 21:
      v2 = 13;
      break;
    case 22:
      v2 = 13;
      break;
    case 26:
      v2 = 15;
      break;
    case 27:
      v2 = 15;
      break;
    case 28:
      v2 = 15;
      break;
    case 29:
      v2 = 14;
      break;
    case 30:
      v2 = 14;
      break;
    case 32:
      v2 = 10;
      break;
    case 33:
      v2 = 8;
      break;
    case 34:
      v2 = 9;
      break;
    case 35:
      v2 = 16;
      break;
    case 36:
      v2 = 16;
      break;
    case 37:
      v2 = 12;
      break;
    case 38:
      v2 = 12;
      break;
    case 42:
      v2 = 5;
      break;
    case 43:
      v2 = 5;
      break;
    default:
      v2 = 0;
      break;
  }
  return v2;
}

//----- (08079FD7) --------------------------------------------------------
int __cdecl sub_8079FD7(int a1, char *a2, _DWORD *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  int *v8; // ecx
  int v9; // edx
  int v10; // edx
  int v11; // edx
  double v13; // [esp+38h] [ebp-C10h]
  double v14; // [esp+48h] [ebp-C00h]
  double v15; // [esp+58h] [ebp-BF0h]
  double v16; // [esp+68h] [ebp-BE0h]
  double v17; // [esp+78h] [ebp-BD0h]
  double v18; // [esp+88h] [ebp-BC0h]
  int v19; // [esp+98h] [ebp-BB0h]
  int v20; // [esp+A0h] [ebp-BA8h]
  int v21; // [esp+A8h] [ebp-BA0h]
  int v22; // [esp+B0h] [ebp-B98h]
  double v23; // [esp+B8h] [ebp-B90h]
  int v24; // [esp+C4h] [ebp-B84h]
  int v26; // [esp+DCh] [ebp-B6Ch]
  _QWORD v27[193]; // [esp+E0h] [ebp-B68h] BYREF
  int v28; // [esp+6ECh] [ebp-55Ch]
  _DWORD v29[320]; // [esp+6F0h] [ebp-558h] BYREF
  int v30; // [esp+BF0h] [ebp-58h]
  int v31; // [esp+BF4h] [ebp-54h]
  double v32; // [esp+BF8h] [ebp-50h]
  int v33; // [esp+C04h] [ebp-44h]
  int v34; // [esp+C08h] [ebp-40h]
  int v35; // [esp+C0Ch] [ebp-3Ch]
  int v36; // [esp+C10h] [ebp-38h]
  int v37; // [esp+C14h] [ebp-34h]
  int v38; // [esp+C18h] [ebp-30h]
  char *s1; // [esp+C1Ch] [ebp-2Ch]
  int v40; // [esp+C20h] [ebp-28h]
  int *v41; // [esp+C24h] [ebp-24h]
  _DWORD *v42; // [esp+C28h] [ebp-20h]
  _DWORD *v43; // [esp+C2Ch] [ebp-1Ch]
  _DWORD *j; // [esp+C30h] [ebp-18h]
  _DWORD *v45; // [esp+C34h] [ebp-14h]
  _DWORD *v46; // [esp+C38h] [ebp-10h]
  _DWORD *i; // [esp+C3Ch] [ebp-Ch]

  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v32 = 0.0;
  v31 = 0;
  v30 = 0;
  v28 = 0;
  v26 = 0;
  v45 = 0;
  v46 = 0;
  v42 = 0;
  v43 = 0;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
  {
    *a4 = 0;
    a4[1] = 0;
  }
  for ( s1 = a2; s1; s1 = (char *)*((_DWORD *)s1 + 266) )
  {
    v24 = *((_DWORD *)s1 + 256);
    if ( v24 == 4 )
    {
      if ( v35 || v34 )
      {
LABEL_37:
        sub_8077880(a1, "syntax error in #if/#elif");
        v36 = 1;
        goto LABEL_80;
      }
      if ( strcmp(s1, "defined") )
      {
        sub_8077880(a1, "undefined name %s in #if/#elif", s1);
        v36 = 1;
        goto LABEL_80;
      }
      s1 = (char *)*((_DWORD *)s1 + 266);
      if ( !strcmp(s1, "(") )
      {
        v38 = 1;
        s1 = (char *)*((_DWORD *)s1 + 266);
      }
      if ( !s1 || *((_DWORD *)s1 + 256) != 4 )
      {
        sub_8077880(a1, "defined without name in #if/#elif");
        v36 = 1;
        goto LABEL_80;
      }
      if ( v26 > 63 )
      {
LABEL_24:
        sub_8077880(a1, "out of value space\n");
        v36 = 1;
        goto LABEL_80;
      }
      j = &v27[3 * v26++];
      if ( sub_807830D(*(_DWORD *)(a1 + 144), s1) )
      {
        *j = 1;
        v5 = j;
        j[1] = 0;
        v5[2] = 1072693248;
      }
      else
      {
        *j = 0;
        v6 = j;
        j[1] = 0;
        v6[2] = 0;
      }
      j[3] = v37;
      j[5] = 0;
      j[4] = v42;
      if ( v42 )
        v42[5] = j;
      else
        v43 = j;
      v42 = j;
      if ( !v38 || (s1 = (char *)*((_DWORD *)s1 + 266)) != 0 && !strcmp(s1, ")") )
      {
        v38 = 0;
        v35 = 1;
      }
      else
      {
        sub_8077880(a1, "defined without ) in #if/#elif");
        v36 = 1;
      }
    }
    else if ( v24 > 4 )
    {
      if ( v24 != 5 )
      {
LABEL_79:
        sub_8077880(a1, "unknown %s in #if/#elif", s1);
        v36 = 1;
        goto LABEL_80;
      }
      if ( v34 )
      {
        sub_8077880(a1, "misplaced minus sign in #if/#elif");
        v36 = 1;
      }
      else if ( *((_DWORD *)s1 + 257) == 44 )
      {
        ++v37;
      }
      else if ( *((_DWORD *)s1 + 257) == 45 )
      {
        if ( --v37 < 0 )
        {
          sub_8077880(a1, "too many ) in #if/#elsif");
          v36 = 1;
        }
      }
      else if ( !a5
             && (*((_DWORD *)s1 + 257) == 35
              || *((_DWORD *)s1 + 257) == 28
              || *((_DWORD *)s1 + 257) == 21
              || *((_DWORD *)s1 + 257) == 22
              || *((_DWORD *)s1 + 257) == 32
              || *((_DWORD *)s1 + 257) == 33
              || *((_DWORD *)s1 + 257) == 34) )
      {
        sub_8077880(a1, "illigal operator %s on floating point operands\n", s1);
        v36 = 1;
      }
      else
      {
        switch ( *((_DWORD *)s1 + 257) )
        {
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 0xA:
          case 0x15:
          case 0x16:
          case 0x1A:
          case 0x1B:
          case 0x1C:
          case 0x1D:
          case 0x20:
          case 0x21:
          case 0x22:
          case 0x25:
          case 0x26:
          case 0x2A:
          case 0x2B:
            goto LABEL_68;
          case 0x10:
          case 0x11:
            sub_8077880(a1, "++ or -- used in #if/#elif");
            break;
          case 0x1E:
            if ( v35 )
            {
LABEL_68:
              if ( !v35 )
              {
                sub_8077880(a1, "operator %s after operator in #if/#elif", s1);
                v36 = 1;
              }
            }
            else
            {
              v34 = 1;
            }
            break;
          case 0x23:
          case 0x24:
            if ( v35 )
            {
              sub_8077880(a1, "! or ~ after value in #if/#elif");
              v36 = 1;
            }
            break;
          default:
            sub_8077880(a1, "invalid operator %s in #if/#elif", s1);
            v36 = 1;
            break;
        }
        if ( !v36 && !v34 )
        {
          if ( v28 <= 63 )
          {
            i = &v29[5 * v28++];
            *i = *((_DWORD *)s1 + 257);
            v7 = i;
            v7[1] = sub_8079EC8(*((_DWORD *)s1 + 257));
            i[2] = v37;
            i[4] = 0;
            i[3] = v45;
            if ( v45 )
              v45[4] = i;
            else
              v46 = i;
            v45 = i;
            v35 = 0;
          }
          else
          {
            sub_8077880(a1, "out of operator space\n");
            v36 = 1;
          }
        }
      }
    }
    else
    {
      if ( v24 != 3 )
        goto LABEL_79;
      if ( v35 )
        goto LABEL_37;
      if ( v26 > 63 )
        goto LABEL_24;
      j = &v27[3 * v26++];
      if ( v34 )
      {
        *j = -*((_DWORD *)s1 + 258);
        *(double *)(j + 1) = -*(long double *)(s1 + 1036);
      }
      else
      {
        *j = *((_DWORD *)s1 + 258);
        *(double *)(j + 1) = *(long double *)(s1 + 1036);
      }
      j[3] = v37;
      j[5] = 0;
      j[4] = v42;
      if ( v42 )
        v42[5] = j;
      else
        v43 = j;
      v42 = j;
      v35 = 1;
      v34 = 0;
    }
LABEL_80:
    if ( v36 )
      break;
  }
  if ( !v36 )
  {
    if ( v35 )
    {
      if ( v37 )
      {
        sub_8077880(a1, "too many ( in #if/#elif");
        v36 = 1;
      }
    }
    else
    {
      sub_8077880(a1, "trailing operator in #if/#elif");
      v36 = 1;
    }
  }
  v31 = 0;
  v33 = 0;
  v32 = 0.0;
  while ( !v36 && v46 )
  {
    j = v43;
    for ( i = v46;
          i[4] && i[2] <= *(_DWORD *)(i[4] + 8) && (i[2] != *(_DWORD *)(i[4] + 8) || i[1] < *(_DWORD *)(i[4] + 4));
          i = (_DWORD *)i[4] )
    {
      if ( *i != 36 && *i != 35 )
        j = (_DWORD *)j[5];
      if ( !j )
      {
        sub_8077880(a1, "mising values in #if/#elif");
        v36 = 1;
        break;
      }
    }
    if ( v36 )
      break;
    v41 = j;
    v40 = j[5];
    switch ( *i )
    {
      case 5:
        v22 = 0;
        if ( *v41 && *(_DWORD *)v40 )
          v22 = 1;
        *v41 = v22;
        v21 = 0;
        if ( *(double *)(v41 + 1) != 0.0 && *(double *)(v40 + 4) != 0.0 )
          v21 = 1;
        *(double *)(v41 + 1) = (double)v21;
        break;
      case 6:
        v20 = 0;
        if ( *v41 || *(_DWORD *)v40 )
          v20 = 1;
        *v41 = v20;
        v19 = 0;
        if ( *(double *)(v41 + 1) != 0.0 || *(double *)(v40 + 4) != 0.0 )
          v19 = 1;
        *(double *)(v41 + 1) = (double)v19;
        break;
      case 7:
        *v41 = *v41 >= *(_DWORD *)v40;
        if ( *(double *)(v41 + 1) < (long double)*(double *)(v40 + 4) )
          v18 = 0.0;
        else
          v18 = 1.0;
        *(double *)(v41 + 1) = v18;
        break;
      case 8:
        *v41 = *v41 <= *(_DWORD *)v40;
        if ( *(double *)(v40 + 4) < (long double)*(double *)(v41 + 1) )
          v17 = 0.0;
        else
          v17 = 1.0;
        *(double *)(v41 + 1) = v17;
        break;
      case 9:
        *v41 = *v41 == *(_DWORD *)v40;
        if ( *(double *)(v41 + 1) == *(double *)(v40 + 4) )
          v16 = 1.0;
        else
          v16 = 0.0;
        *(double *)(v41 + 1) = v16;
        break;
      case 0xA:
        *v41 = *v41 != *(_DWORD *)v40;
        if ( *(double *)(v41 + 1) == *(double *)(v40 + 4) )
          v15 = 0.0;
        else
          v15 = 1.0;
        *(double *)(v41 + 1) = v15;
        break;
      case 0x15:
        *v41 >>= *(_BYTE *)v40;
        break;
      case 0x16:
        *v41 <<= *(_BYTE *)v40;
        break;
      case 0x1A:
        *v41 *= *(_DWORD *)v40;
        *(double *)(v41 + 1) = *(double *)(v41 + 1) * *(double *)(v40 + 4);
        break;
      case 0x1B:
        if ( !*(_DWORD *)v40 || *(double *)(v40 + 4) == 0.0 )
          goto LABEL_114;
        *v41 /= *(int *)v40;
        *(double *)(v41 + 1) = *(double *)(v41 + 1) / *(double *)(v40 + 4);
        break;
      case 0x1C:
        if ( *(_DWORD *)v40 )
        {
          *v41 %= *(_DWORD *)v40;
        }
        else
        {
LABEL_114:
          sub_8077880(a1, "divide by zero in #if/#elif\n");
          v36 = 1;
        }
        break;
      case 0x1D:
        *v41 += *(_DWORD *)v40;
        *(double *)(v41 + 1) = *(double *)(v41 + 1) + *(double *)(v40 + 4);
        break;
      case 0x1E:
        *v41 -= *(_DWORD *)v40;
        *(double *)(v41 + 1) = *(double *)(v41 + 1) - *(double *)(v40 + 4);
        break;
      case 0x20:
        *v41 &= *(_DWORD *)v40;
        break;
      case 0x21:
        *v41 |= *(_DWORD *)v40;
        break;
      case 0x22:
        *v41 ^= *(_DWORD *)v40;
        break;
      case 0x23:
        *v41 = ~*v41;
        break;
      case 0x24:
        *v41 = *v41 == 0;
        if ( *(double *)(v41 + 1) == 0.0 )
          v23 = 1.0;
        else
          v23 = 0.0;
        *(double *)(v41 + 1) = v23;
        break;
      case 0x25:
        *v41 = *v41 > *(_DWORD *)v40;
        if ( *(double *)(v41 + 1) <= (long double)*(double *)(v40 + 4) )
          v14 = 0.0;
        else
          v14 = 1.0;
        *(double *)(v41 + 1) = v14;
        break;
      case 0x26:
        *v41 = *v41 < *(_DWORD *)v40;
        if ( *(double *)(v40 + 4) <= (long double)*(double *)(v41 + 1) )
          v13 = 0.0;
        else
          v13 = 1.0;
        *(double *)(v41 + 1) = v13;
        break;
      case 0x2A:
        if ( v31 )
        {
          if ( a5 )
          {
            if ( !v33 )
              *v41 = *(_DWORD *)v40;
          }
          else if ( v32 == 0.0 )
          {
            v8 = v41;
            v9 = *(_DWORD *)(v40 + 8);
            v41[1] = *(_DWORD *)(v40 + 4);
            v8[2] = v9;
          }
          v31 = 0;
        }
        else
        {
          sub_8077880(a1, ": without ? in #if/#elif");
          v36 = 1;
        }
        break;
      case 0x2B:
        if ( v31 )
        {
          sub_8077880(a1, "? after ? in #if/#elif");
          v36 = 1;
        }
        else
        {
          v33 = *v41;
          v10 = v41[2];
          LODWORD(v32) = v41[1];
          HIDWORD(v32) = v10;
          v31 = 1;
        }
        break;
      default:
        break;
    }
    if ( v36 )
      break;
    v30 = *i;
    if ( *i != 36 && *i != 35 )
    {
      if ( *i != 43 )
        j = (_DWORD *)j[5];
      if ( j[4] )
        *(_DWORD *)(j[4] + 20) = j[5];
      else
        v43 = (_DWORD *)j[5];
      if ( j[5] )
        *(_DWORD *)(j[5] + 16) = j[4];
      else
        v42 = (_DWORD *)j[4];
    }
    if ( i[3] )
      *(_DWORD *)(i[3] + 16) = i[4];
    else
      v46 = (_DWORD *)i[4];
    if ( i[4] )
      *(_DWORD *)(i[4] + 12) = i[3];
    else
      v45 = (_DWORD *)i[3];
  }
  if ( v43 )
  {
    if ( a3 )
      *a3 = *v43;
    if ( a4 )
    {
      v11 = v43[2];
      *a4 = v43[1];
      a4[1] = v11;
    }
  }
  for ( i = v46; i; i = v45 )
    v45 = (_DWORD *)i[4];
  for ( j = v43; j; j = v42 )
    v42 = (_DWORD *)j[5];
  if ( !v36 )
    return 1;
  if ( a3 )
    *a3 = 0;
  if ( a4 )
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return 0;
}

//----- (0807AF86) --------------------------------------------------------
int __cdecl sub_807AF86(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v5; // [esp+24h] [ebp-454h]
  int v6; // [esp+28h] [ebp-450h]
  int v7; // [esp+2Ch] [ebp-44Ch]
  int v8; // [esp+30h] [ebp-448h]
  char *v9; // [esp+34h] [ebp-444h]
  char *v10; // [esp+34h] [ebp-444h]
  char *v11; // [esp+34h] [ebp-444h]
  int i; // [esp+34h] [ebp-444h]
  char *v13; // [esp+38h] [ebp-440h]
  char *v14; // [esp+3Ch] [ebp-43Ch]
  char s1[1024]; // [esp+40h] [ebp-438h] BYREF
  int v16; // [esp+440h] [ebp-38h]

  v6 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
  {
    *a3 = 0;
    a3[1] = 0;
  }
  if ( sub_8079039(a1, s1) )
  {
    v14 = 0;
    v13 = 0;
    do
    {
      if ( v16 == 4 )
      {
        if ( v6 )
        {
          v6 = 0;
          v9 = (char *)sub_8077AD7(s1);
          *((_DWORD *)v9 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v9;
          else
            v14 = v9;
          v13 = v9;
        }
        else if ( !strcmp(s1, "defined") )
        {
          v6 = 1;
          v10 = (char *)sub_8077AD7(s1);
          *((_DWORD *)v10 + 266) = 0;
          if ( v13 )
            *((_DWORD *)v13 + 266) = v10;
          else
            v14 = v10;
          v13 = v10;
        }
        else
        {
          v7 = sub_807830D(*(_DWORD *)(a1 + 144), s1);
          if ( !v7 )
          {
            sub_8077880(a1, "can't evaluate %s, not defined", s1);
            return 0;
          }
          if ( !sub_8078CB9(a1, s1, v7) )
            return 0;
        }
      }
      else
      {
        if ( v16 != 3 && v16 != 5 )
        {
          sub_8077880(a1, "can't evaluate %s", s1);
          return 0;
        }
        v11 = (char *)sub_8077AD7(s1);
        *((_DWORD *)v11 + 266) = 0;
        if ( v13 )
          *((_DWORD *)v13 + 266) = v11;
        else
          v14 = v11;
        v13 = v11;
      }
    }
    while ( sub_8079039(a1, s1) );
    if ( sub_8079FD7(a1, v14, a2, a3, a4) )
    {
      for ( i = (int)v14; i; i = v8 )
      {
        v8 = *(_DWORD *)(i + 1064);
        sub_8077B47(i);
      }
      v5 = 1;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    sub_8077880(a1, "no value after #if/#elif");
    v5 = 0;
  }
  return v5;
}

//----- (0807B2D9) --------------------------------------------------------
int __cdecl sub_807B2D9(int a1, _DWORD *a2, _DWORD *a3, int a4)
{
  int v6; // [esp+2Ch] [ebp-45Ch]
  int v7; // [esp+30h] [ebp-458h]
  char *v8; // [esp+34h] [ebp-454h]
  char *v9; // [esp+34h] [ebp-454h]
  char *v10; // [esp+34h] [ebp-454h]
  int i; // [esp+34h] [ebp-454h]
  char *v12; // [esp+38h] [ebp-450h]
  char *v13; // [esp+3Ch] [ebp-44Ch]
  char s1[1024]; // [esp+40h] [ebp-448h] BYREF
  int v15; // [esp+440h] [ebp-48h]
  int v16; // [esp+478h] [ebp-10h]
  int v17; // [esp+47Ch] [ebp-Ch]

  v16 = 0;
  if ( a2 )
    *a2 = 0;
  if ( a3 )
  {
    *a3 = 0;
    a3[1] = 0;
  }
  if ( !sub_8077B60(a1, s1) )
  {
    sub_8077880(a1, "no leading ( after $evalint/$evalfloat");
    return 0;
  }
  if ( !sub_8077B60(a1, s1) )
  {
    sub_8077880(a1, "nothing to evaluate");
    return 0;
  }
  v17 = 1;
  v13 = 0;
  v12 = 0;
  do
  {
    if ( v15 == 4 )
    {
      if ( v16 )
      {
        v16 = 0;
        v8 = (char *)sub_8077AD7(s1);
        *((_DWORD *)v8 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v8;
        else
          v13 = v8;
        v12 = v8;
      }
      else if ( !strcmp(s1, "defined") )
      {
        v16 = 1;
        v9 = (char *)sub_8077AD7(s1);
        *((_DWORD *)v9 + 266) = 0;
        if ( v12 )
          *((_DWORD *)v12 + 266) = v9;
        else
          v13 = v9;
        v12 = v9;
      }
      else
      {
        v6 = sub_807830D(*(_DWORD *)(a1 + 144), s1);
        if ( !v6 )
        {
          sub_8077880(a1, "can't evaluate %s, not defined", s1);
          return 0;
        }
        if ( !sub_8078CB9(a1, s1, v6) )
          return 0;
      }
      continue;
    }
    if ( v15 != 3 && v15 != 5 )
    {
      sub_8077880(a1, "can't evaluate %s", s1);
      return 0;
    }
    if ( s1[0] == 40 )
    {
      ++v17;
    }
    else if ( s1[0] == 41 )
    {
      --v17;
    }
    if ( v17 <= 0 )
      break;
    v10 = (char *)sub_8077AD7(s1);
    *((_DWORD *)v10 + 266) = 0;
    if ( v12 )
      *((_DWORD *)v12 + 266) = v10;
    else
      v13 = v10;
    v12 = v10;
  }
  while ( sub_8077B60(a1, s1) );
  if ( !sub_8079FD7(a1, v13, a2, a3, a4) )
    return 0;
  for ( i = (int)v13; i; i = v7 )
  {
    v7 = *(_DWORD *)(i + 1064);
    sub_8077B47(i);
  }
  return 1;
}

//----- (0807B68E) --------------------------------------------------------
int __cdecl sub_807B68E(_DWORD *a1)
{
  int v2; // [esp+18h] [ebp-10h]
  char v3[4]; // [esp+1Ch] [ebp-Ch] BYREF
  int v4; // [esp+20h] [ebp-8h] BYREF
  int v5; // [esp+24h] [ebp-4h] BYREF

  sub_80779BD(a1, &v4, v3);
  if ( v4 && v4 != 2 )
  {
    if ( sub_807AF86((int)a1, &v5, 0, 1) )
    {
      *(_DWORD *)v3 = v5 == 0;
      sub_807794C(a1, 4, *(int *)v3);
      v2 = 1;
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    sub_8077880((int)a1, "misplaced #elif");
    v2 = 0;
  }
  return v2;
}

//----- (0807B739) --------------------------------------------------------
int __cdecl sub_807B739(_DWORD *a1)
{
  int v3; // [esp+24h] [ebp-4h] BYREF

  if ( !sub_807AF86((int)a1, &v3, 0, 1) )
    return 0;
  sub_807794C(a1, 1, v3 == 0);
  return 1;
}

//----- (0807B7A1) --------------------------------------------------------
int __cdecl sub_807B7A1(int a1)
{
  sub_8077880(a1, "#line directive not supported");
  return 0;
}

//----- (0807B7C1) --------------------------------------------------------
int __cdecl sub_807B7C1(int a1)
{
  char dest[1080]; // [esp+10h] [ebp-438h] BYREF

  strcpy(dest, &byte_80DAD69);
  sub_8077B60(a1, dest);
  sub_8077880(a1, "#error directive: %s", dest);
  return 0;
}

//----- (0807B819) --------------------------------------------------------
int __cdecl sub_807B819(int a1)
{
  char s1[1080]; // [esp+10h] [ebp-438h] BYREF

  sub_80778E6(a1, "#pragma directive not supported");
  while ( sub_8079039(a1, s1) )
    ;
  return 1;
}

//----- (0807B855) --------------------------------------------------------
int __cdecl sub_807B855(int a1)
{
  char dest[1024]; // [esp+10h] [ebp-438h] BYREF
  int v3; // [esp+410h] [ebp-38h]
  int v4; // [esp+414h] [ebp-34h]
  int v5; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int v7; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]

  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = 0;
  strcpy(dest, "-");
  v3 = 5;
  v4 = 30;
  return sub_8077CB5(a1, dest);
}

//----- (0807B8CD) --------------------------------------------------------
int __cdecl sub_807B8CD(int a1)
{
  int v2; // [esp+8h] [ebp-460h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+438h] [ebp-30h]
  int v8; // [esp+43Ch] [ebp-2Ch]
  int v9; // [esp+440h] [ebp-28h]
  int v10; // [esp+444h] [ebp-24h]
  int v11[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !sub_807AF86(a1, v11, 0, 1) )
    return 0;
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = 0;
  v2 = v11[0];
  if ( v11[0] < 0 )
    v2 = -v11[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  sub_8077CB5(a1, s);
  if ( v11[0] < 0 )
    sub_807B855(a1);
  return 1;
}

//----- (0807B9AF) --------------------------------------------------------
int __cdecl sub_807B9AF(int a1)
{
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v4; // [esp+420h] [ebp-48h]
  int v5; // [esp+424h] [ebp-44h]
  int v6; // [esp+438h] [ebp-30h]
  int v7; // [esp+43Ch] [ebp-2Ch]
  int v8; // [esp+440h] [ebp-28h]
  int v9; // [esp+444h] [ebp-24h]
  double v10[2]; // [esp+458h] [ebp-10h] BYREF

  if ( !sub_807AF86(a1, 0, v10, 0) )
    return 0;
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v9 = 0;
  sprintf(s, "%1.2f", COERCE_DOUBLE(*(_QWORD *)&v10[0] & 0x7FFFFFFFFFFFFFFFLL));
  v4 = 3;
  v5 = 10248;
  sub_8077CB5(a1, s);
  if ( v10[0] < 0.0 )
    sub_807B855(a1);
  return 1;
}

//----- (0807BA99) --------------------------------------------------------
int __cdecl sub_807BA99(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_8077B60(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_80E95C0)[2 * i]; ++i )
        {
          if ( !strcmp((&off_80E95C0)[2 * i], s2) )
            return (*(&off_80E95C4 + 2 * i))(a1);
        }
      }
      sub_8077880(a1, "unknown precompiler directive %s", s2);
      v2 = 0;
    }
    else
    {
      sub_8077CB5(a1, s2);
      sub_8077880(a1, "found # at end of line");
      v2 = 0;
    }
  }
  else
  {
    sub_8077880(a1, "found # without name");
    v2 = 0;
  }
  return v2;
}
// 80E95C4: using guessed type int (__cdecl *off_80E95C4)(int);

//----- (0807BBB5) --------------------------------------------------------
int __cdecl sub_807BBB5(int a1)
{
  int v2; // [esp+8h] [ebp-460h]
  char s[1024]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+420h] [ebp-48h]
  int v6; // [esp+424h] [ebp-44h]
  int v7; // [esp+428h] [ebp-40h]
  long double v8; // [esp+42Ch] [ebp-3Ch]
  int v9; // [esp+438h] [ebp-30h]
  int v10; // [esp+43Ch] [ebp-2Ch]
  int v11; // [esp+440h] [ebp-28h]
  int v12; // [esp+444h] [ebp-24h]
  int v13[3]; // [esp+45Ch] [ebp-Ch] BYREF

  if ( !sub_807B2D9(a1, v13, 0, 1) )
    return 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v12 = 0;
  v2 = v13[0];
  if ( v13[0] < 0 )
    v2 = -v13[0];
  sprintf(s, "%d", v2);
  v5 = 3;
  v6 = 12296;
  v7 = v13[0];
  v8 = (long double)v13[0];
  sub_8077CB5(a1, s);
  if ( v13[0] < 0 )
    sub_807B855(a1);
  return 1;
}

//----- (0807BCA3) --------------------------------------------------------
int __cdecl sub_807BCA3(int a1)
{
  char s[1024]; // [esp+30h] [ebp-448h] BYREF
  int v4; // [esp+430h] [ebp-48h]
  int v5; // [esp+434h] [ebp-44h]
  int v6; // [esp+438h] [ebp-40h]
  long double v7; // [esp+43Ch] [ebp-3Ch]
  int v8; // [esp+448h] [ebp-30h]
  int v9; // [esp+44Ch] [ebp-2Ch]
  int v10; // [esp+450h] [ebp-28h]
  int v11; // [esp+454h] [ebp-24h]
  double v12[2]; // [esp+468h] [ebp-10h] BYREF

  if ( !sub_807B2D9(a1, 0, v12, 0) )
    return 0;
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 92);
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 132) + 68);
  v11 = 0;
  sprintf(s, "%1.2f", COERCE_DOUBLE(*(_QWORD *)&v12[0] & 0x7FFFFFFFFFFFFFFFLL));
  v4 = 3;
  v5 = 10248;
  v6 = (__int64)v12[0];
  v7 = v12[0];
  sub_8077CB5(a1, s);
  if ( v12[0] < 0.0 )
    sub_807B855(a1);
  return 1;
}

//----- (0807BDCF) --------------------------------------------------------
int __cdecl sub_807BDCF(int a1)
{
  int v2; // [esp+18h] [ebp-440h]
  int i; // [esp+1Ch] [ebp-43Ch]
  char s2[1024]; // [esp+20h] [ebp-438h] BYREF
  int v5; // [esp+420h] [ebp-38h]
  int v6; // [esp+444h] [ebp-14h]

  if ( sub_8077B60(a1, s2) )
  {
    if ( v6 <= 0 )
    {
      if ( v5 == 4 )
      {
        for ( i = 0; (&off_80E9660)[2 * i]; ++i )
        {
          if ( !strcmp((&off_80E9660)[2 * i], s2) )
            return (*(&off_80E9664 + 2 * i))(a1);
        }
      }
      sub_8077CB5(a1, s2);
      sub_8077880(a1, "unknown precompiler directive %s", s2);
      v2 = 0;
    }
    else
    {
      sub_8077CB5(a1, s2);
      sub_8077880(a1, "found $ at end of line");
      v2 = 0;
    }
  }
  else
  {
    sub_8077880(a1, "found $ without name");
    v2 = 0;
  }
  return v2;
}
// 80E9664: using guessed type int (__cdecl *off_80E9664)(int);

//----- (0807BF00) --------------------------------------------------------
int __cdecl sub_807BF00(int a1, char *s)
{
  size_t v2; // ebx
  char src; // [esp+20h] [ebp-448h] BYREF
  char v6[1023]; // [esp+21h] [ebp-447h] BYREF
  int v7; // [esp+420h] [ebp-48h]
  int v8; // [esp+45Ch] [ebp-Ch]

  while ( 1 )
  {
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( !sub_8077B60(a1, s) )
            return 0;
          if ( *((_DWORD *)s + 256) != 5 || *s != 35 )
            break;
          if ( !sub_807BA99(a1) )
            return 0;
        }
        if ( *((_DWORD *)s + 256) != 5 || *s != 36 )
          break;
        if ( !sub_807BDCF(a1) )
          return 0;
      }
      if ( *((_DWORD *)s + 256) == 1 && sub_807BF00(a1, &src) )
      {
        if ( v7 == 1 )
        {
          s[strlen(s) - 1] = 0;
          v2 = strlen(s);
          if ( strlen(v6) + v2 + 1 > 0x3FF )
          {
            sub_8077880(a1, "string longer than MAX_TOKEN %d\n", 1024);
            return 0;
          }
          strcat(s, v6);
        }
        else
        {
          sub_807C647(a1, &src);
        }
      }
    }
    while ( *(_DWORD *)(a1 + 152) );
    if ( *((_DWORD *)s + 256) != 4 )
      break;
    v8 = sub_807830D(*(_DWORD *)(a1 + 144), s);
    if ( !v8 )
      break;
    if ( !sub_8078CB9(a1, s, v8) )
      return 0;
  }
  memcpy((void *)(a1 + 156), s, 0x42Cu);
  return 1;
}

//----- (0807C4C1) --------------------------------------------------------
int __cdecl sub_807C4C1(int a1, char *s2)
{
  char s1[1080]; // [esp+20h] [ebp-438h] BYREF

  if ( !sub_807BF00(a1, s1) )
    return 0;
  if ( !strcmp(s1, s2) )
    return 1;
  sub_8077CB5(a1, s1);
  return 0;
}

//----- (0807C647) --------------------------------------------------------
int __cdecl sub_807C647(int a1, void *src)
{
  return sub_8077CB5(a1, src);
}

//----- (0807C6E2) --------------------------------------------------------
_DWORD *__cdecl sub_807C6E2(char *src)
{
  char **v3; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  sub_8077AD2();
  v3 = sub_807EB4F(src);
  if ( !v3 )
    return 0;
  v3[296] = 0;
  s = sub_8077760(1224);
  memset(s, 0, 0x4C8u);
  strncpy((char *)s, src, 0x40u);
  s[33] = v3;
  s[34] = 0;
  s[35] = 0;
  s[37] = 0;
  s[38] = 0;
  s[36] = sub_80777A3(0x1000u);
  sub_8079C6F((int)s);
  return s;
}

//----- (0807C8C8) --------------------------------------------------------
int __cdecl sub_807C8C8(_DWORD *a1)
{
  int i; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  while ( a1[33] )
  {
    v6 = a1[33];
    a1[33] = *(_DWORD *)(v6 + 1184);
    sub_807EDD5(v6);
  }
  while ( a1[34] )
  {
    v5 = a1[34];
    a1[34] = *(_DWORD *)(v5 + 1064);
    sub_8077B47(v5);
  }
  for ( i = 0; i <= 1023; ++i )
  {
    while ( *(_DWORD *)(a1[36] + 4 * i) )
    {
      v4 = *(_DWORD *)(a1[36] + 4 * i);
      *(_DWORD *)(a1[36] + 4 * i) = *(_DWORD *)(v4 + 28);
      sub_8078419(v4);
    }
  }
  while ( a1[37] )
  {
    v3 = a1[37];
    a1[37] = *(_DWORD *)(v3 + 12);
    sub_807784C(v3);
  }
  if ( a1[36] )
    sub_807784C(a1[36]);
  return sub_807784C((int)a1);
}

//----- (0807CCE0) --------------------------------------------------------
int __cdecl sub_807CCE0(int a1, int a2)
{
  int result; // eax
  size_t v3; // ebx
  const char **v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)(a1 + 112) )
    *(_DWORD *)(a1 + 112) = sub_8077760(1024);
  memset(*(void **)(a1 + 112), 0, 0x400u);
  for ( i = 0; ; ++i )
  {
    result = a2;
    if ( !*(_DWORD *)(a2 + 12 * i) )
      break;
    v4 = (const char **)(a2 + 12 * i);
    v5 = 0;
    for ( j = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4); j; j = *(_DWORD *)(j + 8) )
    {
      v3 = strlen(*(const char **)j);
      if ( v3 < strlen(*v4) )
      {
        v4[2] = (const char *)j;
        if ( v5 )
          *(_DWORD *)(v5 + 8) = v4;
        else
          *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
        break;
      }
      v5 = j;
    }
    if ( !j )
    {
      v4[2] = 0;
      if ( v5 )
        *(_DWORD *)(v5 + 8) = v4;
      else
        *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **v4) = v4;
    }
  }
  return result;
}

//----- (0807CEB0) --------------------------------------------------------
int sub_807CEB0(int a1, char *format, ...)
{
  int result; // eax
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  result = *(_DWORD *)(a1 + 104) & 1;
  if ( !result )
  {
    vsprintf(s, format, va);
    result = Com_Printf("^1Error: file %s, line %d: %s\n", a1);
  }
  return result;
}

//----- (0807CF19) --------------------------------------------------------
int sub_807CF19(int a1, char *format, ...)
{
  int result; // eax
  char s[1032]; // [esp+20h] [ebp-408h] BYREF
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  result = *(_DWORD *)(a1 + 104) & 2;
  if ( !result )
  {
    vsprintf(s, format, va);
    result = Com_Printf("file %s, line %d: %s\n", a1);
  }
  return result;
}

//----- (0807CF82) --------------------------------------------------------
int __cdecl sub_807CF82(int a1, int a2)
{
  int result; // eax

  if ( a2 )
    sub_807CCE0(a1, a2);
  else
    sub_807CCE0(a1, (int)&off_80E9700);
  if ( a2 )
  {
    result = a2;
    *(_DWORD *)(a1 + 108) = a2;
  }
  else
  {
    result = a1;
    *(_DWORD *)(a1 + 108) = &off_80E9700;
  }
  return result;
}
// 80E9700: using guessed type char *off_80E9700;

//----- (0807CFD2) --------------------------------------------------------
int __cdecl sub_807CFD2(int a1)
{
  while ( 1 )
  {
    while ( **(char **)(a1 + 68) <= 32 )
    {
      if ( !**(_BYTE **)(a1 + 68) )
        return 0;
      if ( **(_BYTE **)(a1 + 68) == 10 )
        ++*(_DWORD *)(a1 + 92);
      ++*(_DWORD *)(a1 + 68);
    }
    if ( **(_BYTE **)(a1 + 68) != 47 )
      break;
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 47 )
    {
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
      }
      while ( **(_BYTE **)(a1 + 68) != 10 );
      ++*(_DWORD *)(a1 + 92);
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
    else
    {
      if ( *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 42 )
        return 1;
      ++*(_DWORD *)(a1 + 68);
      do
      {
        if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
          return 0;
        if ( **(_BYTE **)(a1 + 68) == 10 )
          ++*(_DWORD *)(a1 + 92);
      }
      while ( **(_BYTE **)(a1 + 68) != 42 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) != 47 );
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
      if ( !*(_BYTE *)++*(_DWORD *)(a1 + 68) )
        return 0;
    }
  }
  return 1;
}

//----- (0807D122) --------------------------------------------------------
int __cdecl sub_807D122(int a1, char *a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+10h] [ebp-8h]
  char v8; // [esp+14h] [ebp-4h]
  int v9; // [esp+14h] [ebp-4h]
  int v10; // [esp+14h] [ebp-4h]
  int v11; // [esp+14h] [ebp-4h]

  v3 = *(char *)++*(_DWORD *)(a1 + 68) - 34;
  switch ( **(_BYTE **)(a1 + 68) )
  {
    case '"':
      v8 = 34;
      goto LABEL_37;
    case '\'':
      v8 = 39;
      goto LABEL_37;
    case '?':
      v8 = 63;
      goto LABEL_37;
    case '\\':
      v8 = 92;
      goto LABEL_37;
    case 'a':
      v8 = 7;
      goto LABEL_37;
    case 'b':
      v8 = 8;
      goto LABEL_37;
    case 'f':
      v8 = 12;
      goto LABEL_37;
    case 'n':
      v8 = 10;
      goto LABEL_37;
    case 'r':
      v8 = 13;
      goto LABEL_37;
    case 't':
      v8 = 9;
      goto LABEL_37;
    case 'v':
      v8 = 11;
      goto LABEL_37;
    case 'x':
      ++*(_DWORD *)(a1 + 68);
      v4 = 0;
      v6 = 0;
      break;
    default:
      if ( **(char **)(a1 + 68) <= 47 || **(char **)(a1 + 68) > 57 )
        sub_807CEB0(a1, "unknown escape char", v3);
      v5 = 0;
      v7 = 0;
      while ( 1 )
      {
        v11 = **(char **)(a1 + 68);
        if ( v11 <= 47 || v11 > 57 )
          break;
        v7 = v11 - 48 + 10 * v7;
        ++v5;
        ++*(_DWORD *)(a1 + 68);
      }
      --*(_DWORD *)(a1 + 68);
      if ( v7 > 255 )
      {
        sub_807CF19(a1, "too large value in escape character");
        LOBYTE(v7) = -1;
      }
      v8 = v7;
      goto LABEL_37;
  }
  while ( 1 )
  {
    v9 = **(char **)(a1 + 68);
    if ( v9 > 47 && v9 <= 57 )
    {
      v10 = v9 - 48;
      goto LABEL_23;
    }
    if ( v9 > 64 && v9 <= 90 )
    {
      v10 = v9 - 55;
      goto LABEL_23;
    }
    if ( v9 <= 96 || v9 > 122 )
      break;
    v10 = v9 - 87;
LABEL_23:
    v6 = v10 + 16 * v6;
    ++v4;
    ++*(_DWORD *)(a1 + 68);
  }
  --*(_DWORD *)(a1 + 68);
  if ( v6 > 255 )
  {
    sub_807CF19(a1, "too large value in escape character", v3);
    LOBYTE(v6) = -1;
  }
  v8 = v6;
LABEL_37:
  ++*(_DWORD *)(a1 + 68);
  *a2 = v8;
  return 1;
}

//----- (0807D339) --------------------------------------------------------
int __cdecl sub_807D339(_DWORD *a1, int a2, int a3)
{
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]

  if ( a3 == 34 )
    *(_DWORD *)(a2 + 1024) = 1;
  else
    *(_DWORD *)(a2 + 1024) = 2;
  *(_BYTE *)a2 = *(_BYTE *)a1[17]++;
  v7 = 1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v7 > 1021 )
        {
          sub_807CEB0((int)a1, "string longer than MAX_TOKEN = %d", 1024);
          return 0;
        }
        if ( *(_BYTE *)a1[17] != 92 || (a1[26] & 8) != 0 )
          break;
        if ( !sub_807D122((int)a1, (char *)(a2 + v7)) )
        {
          *(_BYTE *)(v7 + a2) = 0;
          return 0;
        }
        ++v7;
      }
      if ( *(char *)a1[17] == a3 )
        break;
      if ( !*(_BYTE *)a1[17] )
      {
        *(_BYTE *)(v7 + a2) = 0;
        sub_807CEB0((int)a1, "missing trailing quote");
        return 0;
      }
      if ( *(_BYTE *)a1[17] == 10 )
      {
        *(_BYTE *)(v7 + a2) = 0;
        sub_807CEB0((int)a1, "newline inside string %s", (const char *)a2);
        return 0;
      }
      *(_BYTE *)(a2 + v7++) = *(_BYTE *)a1[17]++;
    }
    ++a1[17];
    if ( (a1[26] & 4) != 0 )
      break;
    v5 = a1[17];
    v6 = a1[23];
    if ( !sub_807CFD2((int)a1) )
    {
      a1[17] = v5;
      a1[23] = v6;
      break;
    }
    if ( *(char *)a1[17] != a3 )
    {
      a1[17] = v5;
      a1[23] = v6;
      break;
    }
    ++a1[17];
  }
  *(_BYTE *)(a2 + v7) = a3;
  v8 = v7 + 1;
  *(_BYTE *)(v8 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v8;
  return 1;
}

//----- (0807D55C) --------------------------------------------------------
int __cdecl sub_807D55C(int a1, int a2)
{
  char v4; // [esp+1Fh] [ebp-9h]
  int v5; // [esp+20h] [ebp-8h]

  v5 = 0;
  *(_DWORD *)(a2 + 1024) = 4;
  do
  {
    *(_BYTE *)(a2 + v5) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    if ( ++v5 > 1023 )
    {
      sub_807CEB0(a1, "name longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    v4 = **(_BYTE **)(a1 + 68);
  }
  while ( v4 > 96 && v4 <= 122 || v4 > 64 && v4 <= 90 || v4 > 47 && v4 <= 57 || v4 == 95 );
  *(_BYTE *)(v5 + a2) = 0;
  *(_DWORD *)(a2 + 1028) = v5;
  return 1;
}

//----- (0807D61C) --------------------------------------------------------
int __cdecl sub_807D61C(_BYTE *a1, __int16 a2, _DWORD *a3, long double *a4)
{
  __int64 v4; // rax
  int v6; // [esp+Ch] [ebp-Ch]
  char *i; // [esp+20h] [ebp+8h]
  _BYTE *j; // [esp+20h] [ebp+8h]
  _BYTE *k; // [esp+20h] [ebp+8h]

  v6 = 0;
  *a3 = 0;
  *(_DWORD *)a4 = 0;
  *((_DWORD *)a4 + 1) = 0;
  *((_DWORD *)a4 + 2) = 0;
  if ( (a2 & 0x800) != 0 )
  {
    while ( *a1 )
    {
      LODWORD(v4) = a1;
      if ( *a1 == 46 )
      {
        if ( v6 )
          return v4;
        v6 = 10;
        ++a1;
      }
      if ( v6 )
      {
        *a4 = (long double)((char)*a1 - 48) / (long double)(unsigned int)v6 + *a4;
        v6 *= 10;
      }
      else
      {
        *a4 = *a4 * 10.0 + (long double)((char)*a1 - 48);
      }
      ++a1;
    }
    v4 = (__int64)*a4;
    *a3 = v4;
  }
  else if ( (a2 & 8) != 0 )
  {
    while ( *a1 )
      *a3 = (char)*a1++ + 10 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( (a2 & 0x100) != 0 )
  {
    for ( i = a1 + 2; *i; ++i )
    {
      *a3 *= 16;
      if ( *i <= 96 || *i > 102 )
      {
        if ( *i <= 64 || *i > 70 )
          *a3 = *a3 + *i - 48;
        else
          *a3 = *a3 + *i - 55;
      }
      else
      {
        *a3 = *a3 + *i - 87;
      }
    }
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else if ( (a2 & 0x200) != 0 )
  {
    for ( j = a1 + 1; *j; ++j )
      *a3 = (char)*j + 8 * *a3 - 48;
    LODWORD(v4) = *a3;
    *a4 = (long double)(unsigned int)*a3;
  }
  else
  {
    LODWORD(v4) = a2 & 0x400;
    if ( (a2 & 0x400) != 0 )
    {
      for ( k = a1 + 2; *k; ++k )
        *a3 = (char)*k + 2 * *a3 - 48;
      LODWORD(v4) = *a3;
      *a4 = (long double)(unsigned int)*a3;
    }
  }
  return v4;
}

//----- (0807D8D0) --------------------------------------------------------
int __cdecl sub_807D8D0(int a1, int a2)
{
  int v2; // edx
  char i; // [esp+23h] [ebp-15h]
  char j; // [esp+23h] [ebp-15h]
  char v7; // [esp+23h] [ebp-15h]
  char v8; // [esp+23h] [ebp-15h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int k; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v12 = 0;
  *(_DWORD *)(a2 + 1024) = 3;
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 120 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 88) )
  {
    *(_BYTE *)a2 = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + 1) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    v12 = 2;
    for ( i = **(_BYTE **)(a1 + 68); i > 47 && i <= 57 || i > 96 && i <= 102 || i > 64 && i <= 65; i = **(_BYTE **)(a1 + 68) )
    {
      *(_BYTE *)(a2 + v12) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
      if ( ++v12 > 1023 )
      {
        sub_807CEB0(a1, "hexadecimal number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x100u;
    goto LABEL_41;
  }
  if ( **(_BYTE **)(a1 + 68) == 48
    && (*(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 98 || *(_BYTE *)(*(_DWORD *)(a1 + 68) + 1) == 66) )
  {
    *(_BYTE *)a2 = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    *(_BYTE *)(a2 + 1) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    v12 = 2;
    for ( j = **(_BYTE **)(a1 + 68); j == 48 || j == 49; j = **(_BYTE **)(a1 + 68) )
    {
      *(_BYTE *)(a2 + v12) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
      if ( ++v12 > 1023 )
      {
        sub_807CEB0(a1, "binary number longer than MAX_TOKEN = %d", 1024);
        return 0;
      }
    }
    *(_DWORD *)(a2 + 1028) |= 0x400u;
    goto LABEL_41;
  }
  v10 = 0;
  v9 = 0;
  if ( **(_BYTE **)(a1 + 68) == 48 )
    v10 = 1;
  while ( 1 )
  {
    v7 = **(_BYTE **)(a1 + 68);
    if ( v7 != 46 )
      break;
    v9 = 1;
LABEL_34:
    *(_BYTE *)(a2 + v12) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
    if ( ++v12 > 1022 )
    {
      sub_807CEB0(a1, "number longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
  }
  if ( v7 == 56 || v7 == 57 )
  {
    v10 = 0;
    goto LABEL_34;
  }
  if ( v7 > 47 && v7 <= 57 )
    goto LABEL_34;
  if ( v10 )
    v2 = *(_DWORD *)(a2 + 1028) | 0x200;
  else
    v2 = *(_DWORD *)(a2 + 1028) | 8;
  *(_DWORD *)(a2 + 1028) = v2;
  if ( v9 )
    *(_DWORD *)(a2 + 1028) |= 0x800u;
LABEL_41:
  for ( k = 0; k <= 1; ++k )
  {
    v8 = **(_BYTE **)(a1 + 68);
    if ( (v8 == 108 || v8 == 76) && (*(_DWORD *)(a2 + 1028) & 0x2000) == 0 )
    {
      ++*(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 1028) |= 0x2000u;
    }
    else if ( (v8 == 117 || v8 == 85) && (*(_DWORD *)(a2 + 1028) & 0x4800) == 0 )
    {
      ++*(_DWORD *)(a1 + 68);
      *(_DWORD *)(a2 + 1028) |= 0x4000u;
    }
  }
  *(_BYTE *)(v12 + a2) = 0;
  sub_807D61C((_BYTE *)a2, *(_DWORD *)(a2 + 1028), (_DWORD *)(a2 + 1032), (long double *)(a2 + 1036));
  if ( (*(_DWORD *)(a2 + 1028) & 0x800) == 0 )
    *(_DWORD *)(a2 + 1028) |= 0x1000u;
  return 1;
}

//----- (0807DE20) --------------------------------------------------------
int __cdecl sub_807DE20(int a1, char *dest)
{
  int i; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h]
  size_t n; // [esp+24h] [ebp-4h]

  for ( i = *(_DWORD *)(*(_DWORD *)(a1 + 112) + 4 * **(char **)(a1 + 68)); i; i = *(_DWORD *)(i + 8) )
  {
    s = *(char **)i;
    n = strlen(*(const char **)i);
    if ( n + *(_DWORD *)(a1 + 68) <= *(_DWORD *)(a1 + 72) && !strncmp(*(const char **)(a1 + 68), s, n) )
    {
      strncpy(dest, s, 0x400u);
      *(_DWORD *)(a1 + 68) += n;
      *((_DWORD *)dest + 256) = 5;
      *((_DWORD *)dest + 257) = *(_DWORD *)(i + 4);
      return 1;
    }
  }
  return 0;
}

//----- (0807DEFE) --------------------------------------------------------
int __cdecl sub_807DEFE(int a1, void *src)
{
  int v4; // [esp+10h] [ebp-8h]

  v4 = 0;
  while ( **(char **)(a1 + 68) > 32 && **(_BYTE **)(a1 + 68) != 59 )
  {
    if ( v4 > 1023 )
    {
      sub_807CEB0(a1, "primitive token longer than MAX_TOKEN = %d", 1024);
      return 0;
    }
    *((_BYTE *)src + v4++) = *(_BYTE *)(*(_DWORD *)(a1 + 68))++;
  }
  *((_BYTE *)src + v4) = 0;
  memcpy((void *)(a1 + 116), src, 0x42Cu);
  return 1;
}

//----- (0807DFA6) --------------------------------------------------------
int __cdecl sub_807DFA6(_DWORD *a1, void *dest)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( a1[25] )
  {
    a1[25] = 0;
    memcpy(dest, a1 + 29, 0x42Cu);
    v3 = 1;
  }
  else
  {
    a1[19] = a1[17];
    a1[24] = a1[23];
    memset(dest, 0, 0x42Cu);
    a1[20] = a1[17];
    *((_DWORD *)dest + 262) = a1[17];
    if ( sub_807CFD2((int)a1) )
    {
      a1[21] = a1[17];
      *((_DWORD *)dest + 263) = a1[17];
      *((_DWORD *)dest + 264) = a1[23];
      *((_DWORD *)dest + 265) = a1[23] - a1[24];
      if ( *(_BYTE *)a1[17] == 34 )
      {
        if ( !sub_807D339(a1, (int)dest, 34) )
          return 0;
      }
      else if ( *(_BYTE *)a1[17] == 39 )
      {
        if ( !sub_807D339(a1, (int)dest, 39) )
          return 0;
      }
      else if ( *(char *)a1[17] > 47 && *(char *)a1[17] <= 57
             || *(_BYTE *)a1[17] == 46 && *(char *)(a1[17] + 1) > 47 && *(char *)(a1[17] + 1) <= 57 )
      {
        if ( !sub_807D8D0((int)a1, (int)dest) )
          return 0;
      }
      else
      {
        if ( (a1[26] & 0x10) != 0 )
          return sub_807DEFE((int)a1, dest);
        if ( *(char *)a1[17] > 96 && *(char *)a1[17] <= 122
          || *(char *)a1[17] > 64 && *(char *)a1[17] <= 90
          || *(_BYTE *)a1[17] == 95 )
        {
          if ( !sub_807D55C((int)a1, (int)dest) )
            return 0;
        }
        else if ( !sub_807DE20((int)a1, (char *)dest) )
        {
          sub_807CEB0((int)a1, "can't read token");
          return 0;
        }
      }
      memcpy(a1 + 29, dest, 0x42Cu);
      return 1;
    }
    v3 = 0;
  }
  return v3;
}

//----- (0807E2E7) --------------------------------------------------------
int __cdecl sub_807E2E7(_DWORD *a1, int a2, int a3, void *a4)
{
  char dest[1032]; // [esp+30h] [ebp-408h] BYREF

  if ( !sub_807DFA6(a1, a4) )
  {
    sub_807CEB0((int)a1, "couldn't read expected token");
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != a2 )
  {
    if ( a2 == 1 )
      strcpy(dest, "string");
    if ( a2 == 2 )
      strcpy(dest, "literal");
    if ( a2 == 3 )
      strcpy(dest, "number");
    if ( a2 == 4 )
      strcpy(dest, "name");
    if ( a2 == 5 )
      strcpy(dest, "punctuation");
    sub_807CEB0((int)a1, "expected a %s, found %s", dest, (const char *)a4);
    return 0;
  }
  if ( *((_DWORD *)a4 + 256) != 3 )
  {
    if ( *((_DWORD *)a4 + 256) == 5 )
    {
      if ( a3 < 0 )
      {
        sub_807CEB0((int)a1, "BUG: wrong punctuation subtype");
        return 0;
      }
      if ( *((_DWORD *)a4 + 257) != a3 )
      {
        sub_807CEB0(
          (int)a1,
          "expected %s, found %s",
          *(const char **)(a1[27] + 12 * a3),
          *(const char **)(a1[27] + 12 * a3 + 4));
        return 0;
      }
    }
    return 1;
  }
  if ( (a3 & *((_DWORD *)a4 + 257)) == a3 )
    return 1;
  if ( (a3 & 8) != 0 )
    strcpy(dest, "decimal");
  if ( (a3 & 0x100) != 0 )
    strcpy(dest, "hex");
  if ( (a3 & 0x200) != 0 )
    strcpy(dest, "octal");
  if ( (a3 & 0x400) != 0 )
    strcpy(dest, "binary");
  if ( (a3 & 0x2000) != 0 )
    strcat(dest, " long");
  if ( (a3 & 0x4000) != 0 )
    strcat(dest, " unsigned");
  if ( (a3 & 0x800) != 0 )
    strcat(dest, " float");
  if ( (a3 & 0x1000) != 0 )
    strcat(dest, " integer");
  sub_807CEB0((int)a1, "expected %s, found %s", dest, (const char *)a4);
  return 0;
}

//----- (0807E611) --------------------------------------------------------
int __cdecl sub_807E611(_DWORD *a1, void *dest)
{
  if ( sub_807DFA6(a1, dest) )
    return 1;
  sub_807CEB0((int)a1, "couldn't read expected token");
  return 0;
}

//----- (0807E819) --------------------------------------------------------
char *__cdecl sub_807E819(char *dest)
{
  char *result; // eax

  if ( *dest == 34 )
    strcpy(dest, dest + 1);
  result = &dest[strlen(dest) - 1];
  if ( *result == 34 )
  {
    result = &dest[strlen(dest) - 1];
    *result = 0;
  }
  return result;
}

//----- (0807EAAC) --------------------------------------------------------
_BOOL4 __cdecl sub_807EAAC(int a1)
{
  return *(_DWORD *)(a1 + 68) >= *(_DWORD *)(a1 + 72);
}

//----- (0807EB4F) --------------------------------------------------------
char **__cdecl sub_807EB4F(char *src)
{
  _DWORD *s; // [esp+24h] [ebp-64h]
  size_t v4; // [esp+2Ch] [ebp-5Ch]
  char v5[76]; // [esp+30h] [ebp-58h] BYREF
  int v6[3]; // [esp+7Ch] [ebp-Ch] BYREF

  if ( byte_83607C0 )
    Com_sprintf(v5, 0x40u, "%s/%s", &byte_83607C0, src);
  else
    Com_sprintf(v5, 0x40u, "%s", src);
  v4 = FS_FOpenFileByMode(v5, (int)v6, 0);
  if ( !v6[0] )
    return 0;
  s = sub_80777A3(v4 + 1189);
  memset(s, 0, 0x4A4u);
  strcpy((char *)s, src);
  s[16] = s + 297;
  *(_BYTE *)(s[16] + v4) = 0;
  s[22] = v4;
  s[17] = s[16];
  s[19] = s[16];
  s[18] = s[16] + v4;
  s[25] = 0;
  s[23] = 1;
  s[24] = 1;
  sub_807CF82((int)s, 0);
  FS_Read((char *)s[16], v4, v6[0]);
  FS_FCloseFile(v6[0]);
  s[22] = sub_8084A8D((_BYTE *)s[16]);
  return (char **)s;
}

//----- (0807ECED) --------------------------------------------------------
_DWORD *__cdecl sub_807ECED(void *a1, size_t n, char *src)
{
  _DWORD *s; // [esp+10h] [ebp-8h]

  s = sub_80777A3(n + 1189);
  memset(s, 0, 0x4A4u);
  strcpy((char *)s, src);
  s[16] = s + 297;
  *(_BYTE *)(s[16] + n) = 0;
  s[22] = n;
  s[17] = s[16];
  s[19] = s[16];
  s[18] = s[16] + n;
  s[25] = 0;
  s[23] = 1;
  s[24] = 1;
  sub_807CF82((int)s, 0);
  memcpy((void *)s[16], a1, n);
  return s;
}

//----- (0807EDD5) --------------------------------------------------------
int __cdecl sub_807EDD5(int a1)
{
  if ( *(_DWORD *)(a1 + 112) )
    sub_807784C(*(_DWORD *)(a1 + 112));
  return sub_807784C(a1);
}

//----- (0807EDFF) --------------------------------------------------------
int __cdecl sub_807EDFF(char *format)
{
  return Com_sprintf(&byte_83607C0, 0x40u, format);
}

//----- (0807EE24) --------------------------------------------------------
_DWORD *__cdecl sub_807EE24(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[5] = 0;
  a1[4] = 0;
  *a1 = 1732584193;
  a1[1] = -271733879;
  a1[2] = -1732584194;
  result = a1;
  a1[3] = 271733878;
  return result;
}

//----- (0807EE64) --------------------------------------------------------
void *__cdecl sub_807EE64(int a1, void *src, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v4 = (*(_DWORD *)(a1 + 16) >> 3) & 0x3F;
  *(_DWORD *)(a1 + 16) += 8 * a3;
  if ( *(_DWORD *)(a1 + 16) < (unsigned int)(8 * a3) )
    ++*(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 20) += (unsigned int)a3 >> 29;
  if ( a3 < (unsigned int)(64 - v4) )
  {
    i = 0;
  }
  else
  {
    sub_80D2FC8((void *)(a1 + v4 + 24), src, 64 - v4);
    sub_807F021((int *)a1, a1 + 24);
    for ( i = 64 - v4; i + 63 < (unsigned int)a3; i += 64 )
      sub_807F021((int *)a1, (int)src + i);
    v4 = 0;
  }
  return sub_80D2FC8((void *)(a1 + v4 + 24), (char *)src + i, a3 - i);
}

//----- (0807EF60) --------------------------------------------------------
void *__cdecl sub_807EF60(int a1, void *s)
{
  int v3; // [esp+14h] [ebp-14h]
  unsigned int v4; // [esp+1Ch] [ebp-Ch]
  char src[8]; // [esp+20h] [ebp-8h] BYREF

  sub_807F72D((int)src, (int)s + 16, 8u);
  v4 = (*((_DWORD *)s + 4) >> 3) & 0x3F;
  if ( v4 > 0x37 )
    v3 = 120 - v4;
  else
    v3 = 56 - v4;
  sub_807EE64((int)s, &unk_80E9980, v3);
  sub_807EE64((int)s, src, 8);
  sub_807F72D(a1, (int)s, 0x10u);
  return sub_80D2FE9(s, 0, 0x58u);
}

//----- (0807F021) --------------------------------------------------------
void *__cdecl sub_807F021(int *a1, int a2)
{
  int s; // [esp+10h] [ebp-58h] BYREF
  int v4; // [esp+14h] [ebp-54h]
  int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7; // [esp+20h] [ebp-48h]
  int v8; // [esp+24h] [ebp-44h]
  int v9; // [esp+28h] [ebp-40h]
  int v10; // [esp+2Ch] [ebp-3Ch]
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+38h] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-2Ch]
  int v15; // [esp+40h] [ebp-28h]
  int v16; // [esp+44h] [ebp-24h]
  int v17; // [esp+48h] [ebp-20h]
  int v18; // [esp+4Ch] [ebp-1Ch]
  int v19; // [esp+50h] [ebp-18h]
  int v20; // [esp+54h] [ebp-14h]
  int v21; // [esp+58h] [ebp-10h]
  int v22; // [esp+5Ch] [ebp-Ch]

  v22 = *a1;
  v21 = a1[1];
  v20 = a1[2];
  v19 = a1[3];
  sub_807F7D5((int)&s, a2, 0x40u);
  v22 += s + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v4 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v5 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v6 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v7 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v9 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v10 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v11 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v13 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v14 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += v15 + (v20 & v21 | v19 & ~v21);
  v22 = __ROL4__(v22, 3);
  v19 += v16 + (v21 & v22 | v20 & ~v22);
  v19 = __ROL4__(v19, 7);
  v20 += v17 + (v22 & v19 | v21 & ~v19);
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v19 & v20 | v22 & ~v20);
  v21 = __ROL4__(v21, 19);
  v22 += s + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v7 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v11 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v15 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v4 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v8 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v12 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v16 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v5 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v9 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v13 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v17 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += v6 + (v21 & (v20 | v19) | v20 & v19) + 1518500249;
  v22 = __ROL4__(v22, 3);
  v19 += v10 + (v22 & (v21 | v20) | v21 & v20) + 1518500249;
  v19 = __ROL4__(v19, 5);
  v20 += v14 + (v19 & (v22 | v21) | v22 & v21) + 1518500249;
  v20 = __ROL4__(v20, 9);
  v21 += v18 + (v20 & (v19 | v22) | v19 & v22) + 1518500249;
  v21 = __ROL4__(v21, 13);
  v22 += s + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v11 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v7 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v15 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v5 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v13 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v9 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v17 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v4 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v12 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v8 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v16 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  v22 += v6 + (v19 ^ v21 ^ v20) + 1859775393;
  v22 = __ROL4__(v22, 3);
  v19 += v14 + (v20 ^ v22 ^ v21) + 1859775393;
  v19 = __ROL4__(v19, 9);
  v20 += v10 + (v21 ^ v19 ^ v22) + 1859775393;
  v20 = __ROL4__(v20, 11);
  v21 += v18 + (v22 ^ v20 ^ v19) + 1859775393;
  v21 = __ROL4__(v21, 15);
  *a1 += v22;
  a1[1] += v21;
  a1[2] += v20;
  a1[3] += v19;
  return sub_80D2FE9(&s, 0, 0x40u);
}

//----- (0807F72D) --------------------------------------------------------
unsigned int __cdecl sub_807F72D(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-8h]
  int v5; // [esp+4h] [ebp-4h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_WORD *)(i + a1) = __PAIR16__(BYTE1(*(_DWORD *)(a2 + 4 * v5)), *(_BYTE *)(a2 + 4 * v5));
    *(_BYTE *)(a1 + i + 2) = BYTE2(*(_DWORD *)(a2 + 4 * v5));
    *(_BYTE *)(a1 + i + 3) = HIBYTE(*(_DWORD *)(a2 + 4 * v5++));
  }
  return result;
}

//----- (0807F7D5) --------------------------------------------------------
unsigned int __cdecl sub_807F7D5(int a1, int a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+0h] [ebp-Ch]
  int v5; // [esp+4h] [ebp-8h]

  v5 = 0;
  for ( i = 0; ; i += 4 )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_DWORD *)(a1 + 4 * v5++) = (*(unsigned __int8 *)(a2 + i + 2) << 16) | *(unsigned __int16 *)(a2 + i) | (*(unsigned __int8 *)(a2 + i + 3) << 24);
  }
  return result;
}

//----- (0807F851) --------------------------------------------------------
int __cdecl sub_807F851(void *src, int a2)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF

  sub_807EE24(s);
  sub_807EE64((int)s, src, a2);
  sub_807EF60((int)v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (0807F8AD) --------------------------------------------------------
int sub_807F8AD(void *a1, int a2, ...)
{
  int s[27]; // [esp+10h] [ebp-88h] BYREF
  int v4[6]; // [esp+80h] [ebp-18h] BYREF
  va_list va; // [esp+A8h] [ebp+10h] BYREF

  va_start(va, a2);
  sub_807EE24(s);
  sub_807EE64((int)s, va, 4);
  sub_807EE64((int)s, a1, a2);
  sub_807EF60((int)v4, s);
  return v4[3] ^ v4[2] ^ v4[0] ^ v4[1];
}

//----- (0807F928) --------------------------------------------------------
int __cdecl MSG_Init(void *s, int a2, int a3)
{
  int result; // eax

  if ( !dword_80E99C0 )
    sub_8082D03();
  memset(s, 0, 0x18u);
  *((_DWORD *)s + 1) = a2;
  result = a3;
  *((_DWORD *)s + 2) = a3;
  return result;
}
// 80E99C0: using guessed type int dword_80E99C0;

//----- (0807F96B) --------------------------------------------------------
int __cdecl MSG_BeginReading(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 16) = 0;
  result = a1;
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

//----- (0807F984) --------------------------------------------------------
int __cdecl MSG_WriteBits(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]

  result = a1[2] - a1[3];
  if ( result > 3 )
  {
    while ( a3 )
    {
      --a3;
      v4 = a1[5] & 7;
      if ( !v4 )
      {
        a1[5] = 8 * a1[3];
        *(_BYTE *)(a1[1] + a1[3]++) = 0;
      }
      if ( (a2 & 1) != 0 )
        *(_BYTE *)(((int)a1[5] >> 3) + a1[1]) |= 1 << v4;
      ++a1[5];
      result = (int)&a2;
      a2 >>= 1;
    }
  }
  else
  {
    result = (int)a1;
    *a1 = 1;
  }
  return result;
}

//----- (0807FA4A) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteBit0(_DWORD *a1)
{
  _DWORD *result; // eax

  if ( a1[3] < a1[2] )
  {
    if ( (a1[5] & 7) == 0 )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (0807FAA7) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteBit1(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+0h] [ebp-10h]

  if ( a1[3] < a1[2] )
  {
    v2 = a1[5] & 7;
    if ( !v2 )
    {
      a1[5] = 8 * a1[3];
      *(_BYTE *)(a1[1] + a1[3]++) = 0;
    }
    *(_BYTE *)(((int)a1[5] >> 3) + a1[1]) |= 1 << v2;
    result = a1;
    ++a1[5];
  }
  else
  {
    result = a1;
    *a1 = 1;
  }
  return result;
}

//----- (0807FB40) --------------------------------------------------------
int __cdecl MSG_ReadBits(_DWORD *a1, int a2)
{
  int i; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v4 = a1[5] & 7;
    if ( !v4 )
      a1[5] = 8 * a1[4]++;
    v5 |= (((int)*(unsigned __int8 *)(((int)a1[5]++ >> 3) + a1[1]) >> v4) & 1) << i;
  }
  return v5;
}

//----- (0807FBC2) --------------------------------------------------------
int __cdecl sub_807FBC2(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = a1[5] & 7;
  if ( !v2 )
    a1[5] = 8 * a1[4]++;
  return ((int)*(unsigned __int8 *)(((int)a1[5]++ >> 3) + a1[1]) >> v2) & 1;
}

//----- (0807FC1B) --------------------------------------------------------
int __cdecl MSG_WriteBitsCompress(unsigned __int8 *a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v4 = 0;
  v5 = a3;
  while ( v5 )
  {
    sub_8076BF4((int)dword_8153D20, *a1, a2, &v4);
    --v5;
    ++a1;
  }
  return (v4 + 7) >> 3;
}

//----- (0807FC6F) --------------------------------------------------------
_BYTE *__cdecl MSG_ReadBitsCompress(int a1, _BYTE *a2, int a3)
{
  _BYTE *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  int v6; // [esp+20h] [ebp-8h]
  char v7[4]; // [esp+24h] [ebp-4h] BYREF

  v6 = 8 * a3;
  v4 = a2;
  v5 = 0;
  while ( v5 < v6 )
  {
    Huff_offsetReceive((_DWORD *)dword_815AD44, v7, a1, &v5);
    *v4++ = v7[0];
  }
  return (_BYTE *)(v4 - a2);
}
// 815AD44: using guessed type int dword_815AD44;

//----- (0807FCD8) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteByte(_DWORD *a1, char a2)
{
  _DWORD *result; // eax

  if ( a1[3] >= a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_BYTE *)(a1[3] + a1[1]) = a2;
    result = a1;
    ++a1[3];
  }
  return result;
}

//----- (0807FD10) --------------------------------------------------------
int __cdecl MSG_WriteData(int a1, void *src, size_t n)
{
  int result; // eax
  signed int v4; // [esp+14h] [ebp-4h]

  v4 = *(_DWORD *)(a1 + 12) + n;
  if ( v4 > *(_DWORD *)(a1 + 8) )
  {
    result = a1;
    *(_DWORD *)a1 = 1;
  }
  else
  {
    memcpy((void *)(*(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 12)), src, n);
    result = v4;
    *(_DWORD *)(a1 + 12) = v4;
  }
  return result;
}

//----- (0807FD65) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteShort(_DWORD *a1, __int16 a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  v3 = (_DWORD *)(a1[3] + 2);
  if ( (int)v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_WORD *)(a1[1] + a1[3]) = sub_8082D81(a2);
    result = v3;
    a1[3] = v3;
  }
  return result;
}

//----- (0807FDB5) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteLong(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  _DWORD *v3; // [esp+4h] [ebp-4h]

  v3 = (_DWORD *)(a1[3] + 4);
  if ( (int)v3 > a1[2] )
  {
    result = a1;
    *a1 = 1;
  }
  else
  {
    *(_DWORD *)(a1[1] + a1[3]) = sub_8082D94(a2);
    result = v3;
    a1[3] = v3;
  }
  return result;
}

//----- (0807FE03) --------------------------------------------------------
int __cdecl MSG_WriteString(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char v4; // [esp+4h] [ebp-424h]
  char src[1032]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+418h] [ebp-10h]
  int v7; // [esp+41Ch] [ebp-Ch]

  if ( !s )
    return MSG_WriteData(a1, &unk_80DCB28, 1u);
  v7 = strlen(s);
  if ( v7 <= 1023 )
  {
    for ( i = 0; i < v7; ++i )
    {
      v3 = &src[i];
      *v3 = sub_8086166(s[i]);
    }
    src[i] = 0;
    result = MSG_WriteData(a1, src, v7 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: MAX_STRING_CHARS", v4);
    result = MSG_WriteData(a1, &unk_80DCB28, 1u);
  }
  return result;
}
// 807FE51: variable 'v4' is possibly undefined

//----- (0807FEDB) --------------------------------------------------------
int __cdecl MSG_WriteBigString(int a1, char *s)
{
  int result; // eax
  char *v3; // ebx
  char v4; // [esp+4h] [ebp-2024h]
  char src[8200]; // [esp+10h] [ebp-2018h] BYREF
  int i; // [esp+2018h] [ebp-10h]
  int v7; // [esp+201Ch] [ebp-Ch]

  if ( !s )
    return MSG_WriteData(a1, &unk_80DCB28, 1u);
  v7 = strlen(s);
  if ( v7 <= 0x1FFF )
  {
    Q_strncpyz(src, s, 0x2000);
    for ( i = 0; i < v7; ++i )
    {
      v3 = &src[i];
      *v3 = sub_8086166(src[i]);
    }
    result = MSG_WriteData(a1, src, v7 + 1);
  }
  else
  {
    Com_Printf("MSG_WriteString: BIG_INFO_STRING", v4);
    result = MSG_WriteData(a1, &unk_80DCB28, 1u);
  }
  return result;
}
// 807FF29: variable 'v4' is possibly undefined

//----- (08080053) --------------------------------------------------------
int __cdecl MSG_ReadByte(_DWORD *a1)
{
  if ( a1[4] >= a1[3] )
    return -1;
  return *(unsigned __int8 *)(a1[1] + a1[4]++);
}

//----- (08080093) --------------------------------------------------------
int __cdecl MSG_ReadShort(_DWORD *a1)
{
  __int16 v1; // ax
  int v4; // [esp+10h] [ebp-8h]

  v4 = a1[4] + 2;
  if ( v4 > a1[3] )
    return -1;
  v1 = sub_8082D81(*(_WORD *)(a1[1] + a1[4]));
  a1[4] = v4;
  return v1;
}

//----- (080800E8) --------------------------------------------------------
int __cdecl MSG_ReadLong(_DWORD *a1)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v3 = a1[4] + 4;
  if ( v3 > a1[3] )
    return -1;
  v4 = sub_8082D94(*(_DWORD *)(a1[1] + a1[4]));
  a1[4] = v3;
  return v4;
}

//----- (0808013B) --------------------------------------------------------
void *__cdecl MSG_ReadString(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FE; ++i )
  {
    v2 = MSG_ReadByte((_DWORD *)a1);
    if ( v2 == -1 )
      break;
    if ( !v2 )
      break;
    *(_BYTE *)(i + 135599392) = sub_8086166(v2);
  }
  *(_BYTE *)(i + 135599392) = 0;
  return &unk_8151520;
}

//----- (08080212) --------------------------------------------------------
void *__cdecl MSG_ReadStringLine(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FE; ++i )
  {
    v2 = MSG_ReadByte((_DWORD *)a1);
    if ( v2 == -1 || !v2 || v2 == 10 )
      break;
    if ( v2 == 37 )
      LOBYTE(v2) = 46;
    *(_BYTE *)(i + 135608608) = sub_8086166(v2);
  }
  *(_BYTE *)(i + 135608608) = 0;
  return &unk_8153920;
}

//----- (08080389) --------------------------------------------------------
_DWORD *__cdecl sub_8080389(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  if ( a3 == a4 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  return (_DWORD *)MSG_WriteBits(a1, a4 ^ a2, a5);
}

//----- (080803CD) --------------------------------------------------------
int __cdecl sub_80803CD(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-4h]

  if ( sub_807FBC2(a1) )
    v5 = a2 & dword_80E99E0[a4] ^ MSG_ReadBits(a1, a4);
  else
    v5 = a3;
  return v5;
}

//----- (08080415) --------------------------------------------------------
int __cdecl sub_8080415(_DWORD *a1, int a2, int a3, int a4)
{
  return MSG_WriteBits(a1, a3 ^ a2, a4);
}

//----- (08080439) --------------------------------------------------------
int __cdecl sub_8080439(_DWORD *a1, int a2, int a3)
{
  return a2 & dword_80E99E0[a3] ^ MSG_ReadBits(a1, a3);
}

//----- (08080466) --------------------------------------------------------
_DWORD *__cdecl sub_8080466(_DWORD *a1, char a2, char a3, char a4)
{
  if ( a3 == a4 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  return MSG_WriteByte(a1, a4 ^ a2);
}

//----- (080804A4) --------------------------------------------------------
int __cdecl sub_80804A4(_DWORD *a1, char a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( sub_807FBC2(a1) )
    v4 = (unsigned __int8)(a2 ^ MSG_ReadByte(a1));
  else
    v4 = a3;
  return v4;
}

//----- (080804DA) --------------------------------------------------------
_DWORD *__cdecl sub_80804DA(_DWORD *a1, __int16 a2, __int16 a3, __int16 a4)
{
  if ( a3 == a4 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  return MSG_WriteShort(a1, a4 ^ a2);
}

//----- (08080518) --------------------------------------------------------
int __cdecl sub_8080518(_DWORD *a1, __int16 a2, int a3)
{
  int v4; // [esp+4h] [ebp-4h]

  if ( sub_807FBC2(a1) )
    v4 = (__int16)(MSG_ReadShort(a1) ^ a2);
  else
    v4 = a3;
  return v4;
}

//----- (08080550) --------------------------------------------------------
_BYTE *__cdecl MSG_WriteReliableCommandToBuffer(char *s, int a2, int a3)
{
  _BYTE *result; // eax
  char v4; // [esp+4h] [ebp-24h]
  _BYTE *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int i; // [esp+24h] [ebp-4h]

  v6 = strlen(s);
  if ( v6 >= a3 )
    Com_Printf("WARNING: Reliable command is too long (%i/%i) and will be truncated: '%s'\n", v6);
  if ( !v6 )
    Com_Printf("WARNING: Empty reliable command\n", v4);
  v5 = (_BYTE *)a2;
  for ( i = 0; i < a3 && s[i]; ++i )
  {
    *v5 = sub_8086166(s[i]);
    if ( *v5 == 37 )
      *v5 = 46;
    ++v5;
  }
  if ( i >= a3 )
  {
    result = (_BYTE *)(a2 + a3 - 1);
    *result = 0;
  }
  else
  {
    result = (_BYTE *)(a2 + i);
    *(_BYTE *)(a2 + i) = 0;
  }
  return result;
}
// 808059A: variable 'v4' is possibly undefined

//----- (08080612) --------------------------------------------------------
void __cdecl MSG_SetDefaultUserCmd(int a1, void *s)
{
  int i; // [esp+1Ch] [ebp-Ch]

  memset(s, 0, 0x18u);
  *((_BYTE *)s + 6) = *(_BYTE *)(a1 + 176);
  for ( i = 0; i <= 1; ++i )
    *((_DWORD *)s + i + 2) = (unsigned __int16)((int)(*(float *)(a1 + 4 * i + 192) * 182.04445)
                                              - *(_WORD *)(a1 + 4 * i + 72));
  if ( (*(_DWORD *)(a1 + 12) & 0x20000) != 0 )
  {
    if ( (*(_DWORD *)(a1 + 128) & 0x40) != 0 )
    {
      *((_BYTE *)s + 5) |= 0x40u;
      *((_BYTE *)s + 22) = -127;
    }
    else if ( (*(_DWORD *)(a1 + 128) & 0x20) != 0 )
    {
      *((_BYTE *)s + 5) |= 0x80u;
      *((_BYTE *)s + 22) = -127;
    }
    if ( *(float *)(a1 + 64) <= 0.0 )
    {
      if ( *(float *)(a1 + 64) < 0.0 )
        *((_BYTE *)s + 5) |= 0x10u;
    }
    else
    {
      *((_BYTE *)s + 5) |= 0x20u;
    }
    if ( *(float *)(a1 + 184) != 0.0 )
      *((_BYTE *)s + 4) |= 0x10u;
  }
}

//----- (08080780) --------------------------------------------------------
int __cdecl sub_8080780(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( a1 <= 10 )
  {
    if ( a1 < -10 )
      v3 = 2;
  }
  else
  {
    v3 = 1;
  }
  if ( a2 > 10 )
    return v3 | 4;
  if ( a2 < -10 )
    v3 |= 8u;
  return v3;
}

//----- (080807C6) --------------------------------------------------------
int __cdecl sub_80807C6(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 > 10 )
    return 1;
  if ( a1 < -10 )
    v2 = 2;
  return v2;
}

//----- (080807F2) --------------------------------------------------------
_BYTE *__cdecl sub_80807F2(char a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax

  if ( (a1 & 1) != 0 )
  {
    *a2 = 127;
  }
  else if ( (a1 & 2) != 0 )
  {
    *a2 = -127;
  }
  else
  {
    *a2 = 0;
  }
  if ( (a1 & 4) != 0 )
  {
    result = a3;
    *a3 = 127;
  }
  else
  {
    result = a3;
    if ( (a1 & 8) != 0 )
      *a3 = -127;
    else
      *a3 = 0;
  }
  return result;
}

//----- (0808084B) --------------------------------------------------------
_BYTE *__cdecl sub_808084B(char a1, _BYTE *a2)
{
  _BYTE *result; // eax

  if ( (a1 & 1) != 0 )
  {
    result = a2;
    *a2 = 127;
  }
  else
  {
    result = a2;
    if ( (a1 & 2) != 0 )
      *a2 = -127;
    else
      *a2 = 0;
  }
  return result;
}

//----- (08080CAB) --------------------------------------------------------
_BYTE *__cdecl sub_8080CAB(_DWORD *a1, int a2, int a3, int a4)
{
  _BYTE *result; // eax
  int v5; // [esp+10h] [ebp-18h]
  char v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+18h] [ebp-10h]
  char v9; // [esp+1Ch] [ebp-Ch]
  char v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+34h] [ebp+Ch]
  int v12; // [esp+34h] [ebp+Ch]

  *(_DWORD *)a4 = *(_DWORD *)a3;
  *(_DWORD *)(a4 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(a4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(a4 + 20) = *(_DWORD *)(a3 + 20);
  if ( sub_807FBC2(a1) )
    *(_DWORD *)a4 = *(_DWORD *)a3 + MSG_ReadByte(a1);
  else
    *(_DWORD *)a4 = MSG_ReadLong(a1);
  result = (_BYTE *)sub_8080439(a1, a2, 1);
  if ( result )
  {
    *(_BYTE *)(a4 + 4) &= 0xFEu;
    if ( sub_8080439(a1, a2, 1) )
    {
      *(_BYTE *)(a4 + 4) |= sub_8080439(a1, a2, 1);
      *(_DWORD *)(a4 + 8) = (unsigned __int16)sub_8080518(a1, a2, *(_DWORD *)(a3 + 8));
      *(_DWORD *)(a4 + 12) = (unsigned __int16)sub_8080518(a1, a2, *(_DWORD *)(a3 + 12));
      v8 = sub_8080780(*(char *)(a3 + 20), *(char *)(a3 + 21));
      v10 = sub_80803CD(a1, a2, v8, 4);
      sub_80807F2(v10, (_BYTE *)(a4 + 20), (_BYTE *)(a4 + 21));
      v12 = *(_DWORD *)a4 ^ a2;
      *(_DWORD *)(a4 + 16) = (unsigned __int16)sub_8080518(a1, v12, *(_DWORD *)(a3 + 16));
      *(_BYTE *)(a4 + 4) &= 1u;
      *(_BYTE *)(a4 + 4) |= 2 * (unsigned __int8)sub_80803CD(a1, v12, *(_BYTE *)(a3 + 4) >> 1, 6);
      *(_BYTE *)(a4 + 5) = sub_80804A4(a1, v12, *(unsigned __int8 *)(a3 + 5));
      v5 = sub_80807C6(*(char *)(a3 + 22));
      v6 = sub_80803CD(a1, v12, v5, 2);
      sub_808084B(v6, (_BYTE *)(a4 + 22));
      result = (_BYTE *)sub_80803CD(a1, v12, *(unsigned __int8 *)(a3 + 6), 6);
      *(_BYTE *)(a4 + 6) = (_BYTE)result;
    }
    else
    {
      v11 = *(_DWORD *)a4 ^ a2;
      *(_BYTE *)(a4 + 4) |= sub_8080439(a1, v11, 1);
      *(_DWORD *)(a4 + 8) = (unsigned __int16)sub_8080518(a1, v11, *(_DWORD *)(a3 + 8));
      *(_DWORD *)(a4 + 12) = (unsigned __int16)sub_8080518(a1, v11, *(_DWORD *)(a3 + 12));
      v7 = sub_8080780(*(char *)(a3 + 20), *(char *)(a3 + 21));
      v9 = sub_80803CD(a1, v11, v7, 4);
      result = sub_80807F2(v9, (_BYTE *)(a4 + 20), (_BYTE *)(a4 + 21));
    }
  }
  return result;
}

//----- (0808102D) --------------------------------------------------------
int *__cdecl MSG_WriteDeltaField(_DWORD *a1, int a2, int a3, int a4)
{
  int *result; // eax
  int v5; // [esp+14h] [ebp-24h]
  int *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  int v8; // [esp+24h] [ebp-14h] BYREF
  float v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int *v11; // [esp+30h] [ebp-8h]
  _DWORD *v12; // [esp+34h] [ebp-4h]

  v12 = (_DWORD *)(a2 + *(_DWORD *)(a4 + 4));
  v11 = (int *)(a3 + *(_DWORD *)(a4 + 4));
  if ( *v12 == *v11 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  if ( !*(_DWORD *)(a4 + 8) )
  {
    v9 = *(float *)v11;
    v10 = (int)v9;
    if ( v9 != 0.0 )
    {
      MSG_WriteBit1(a1);
      if ( (long double)v10 == v9 && v10 + 4096 >= 0 && v10 + 4096 <= 0x1FFF )
      {
        MSG_WriteBit0(a1);
        v10 += 4096;
        MSG_WriteBits(a1, v10, 5);
        result = MSG_WriteByte(a1, v10 >> 5);
      }
      else
      {
        MSG_WriteBit1(a1);
        result = MSG_WriteLong(a1, *v11);
      }
      return result;
    }
    return MSG_WriteBit0(a1);
  }
  if ( !*v11 )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  v8 = *v11;
  v5 = *(_DWORD *)(a4 + 8);
  if ( v5 < 0 )
    v5 = -v5;
  v7 = v5;
  result = (int *)(v5 & 7);
  v6 = result;
  if ( (v5 & 7) != 0 )
  {
    MSG_WriteBits(a1, v8, (int)result);
    v7 -= (int)v6;
    result = &v8;
    v8 >>= (char)v6;
  }
  while ( v7 )
  {
    MSG_WriteByte(a1, v8);
    v8 >>= 8;
    result = &v7;
    v7 -= 8;
  }
  return result;
}

//----- (08081210) --------------------------------------------------------
_DWORD *__cdecl sub_8081210(_DWORD *a1, int a2, int a3, int a4, int a5, int a6)
{
  _DWORD *result; // eax
  int j; // [esp+24h] [ebp-4h]
  int i; // [esp+24h] [ebp-4h]

  if ( a4 )
  {
LABEL_7:
    MSG_WriteBit1(a1);
    for ( i = 0; ; ++i )
    {
      result = (_DWORD *)i;
      if ( i >= a5 )
        break;
      MSG_WriteDeltaField(a1, a2, a3, a6 + 12 * i);
    }
  }
  else
  {
    for ( j = 0; j < a5; ++j )
    {
      if ( *(_DWORD *)(a2 + *(_DWORD *)(a6 + 12 * j + 4)) != *(_DWORD *)(a3 + *(_DWORD *)(a6 + 12 * j + 4)) )
        goto LABEL_7;
    }
    result = MSG_WriteBit0(a1);
  }
  return result;
}

//----- (080812CA) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaStruct(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  char *v11; // [esp+20h] [ebp-8h]
  _DWORD *v12; // [esp+24h] [ebp-4h]
  _DWORD *v13; // [esp+24h] [ebp-4h]

  if ( a3 )
  {
    v11 = 0;
    v12 = 0;
    for ( i = a7; ; i += 12 )
    {
      result = v12;
      if ( (int)v12 >= a5 )
        break;
      if ( *(_DWORD *)((char *)a2 + *(_DWORD *)(i + 4)) != *(_DWORD *)((char *)a3 + *(_DWORD *)(i + 4)) )
        v11 = (char *)v12 + 1;
      v12 = (_DWORD *)((char *)v12 + 1);
    }
    if ( v11 )
    {
      if ( a8 )
        MSG_WriteBit1(a1);
      MSG_WriteBits(a1, *a3, a6);
      MSG_WriteBit0(a1);
      MSG_WriteBit1(a1);
      MSG_WriteByte(a1, (char)v11);
      v13 = 0;
      for ( j = a7; ; j += 12 )
      {
        result = v13;
        if ( (int)v13 >= (int)v11 )
          break;
        MSG_WriteDeltaField(a1, (int)a2, (int)a3, j);
        v13 = (_DWORD *)((char *)v13 + 1);
      }
    }
    else if ( a4 )
    {
      if ( a8 )
        MSG_WriteBit1(a1);
      MSG_WriteBits(a1, *a3, a6);
      MSG_WriteBit0(a1);
      result = MSG_WriteBit0(a1);
    }
  }
  else
  {
    if ( dword_836B7B4 && (*(int *)(dword_836B7B4 + 32) > 1 || *(_DWORD *)(dword_836B7B4 + 32) == -1) )
      Com_Printf("W|%3i: #%-3i remove\n", a1[3]);
    if ( a8 )
      MSG_WriteBit1(a1);
    MSG_WriteBits(a1, *a2, a6);
    result = MSG_WriteBit1(a1);
  }
  return result;
}
// 836B7B4: using guessed type int dword_836B7B4;

//----- (0808149A) --------------------------------------------------------
_DWORD *__cdecl MSG_WriteDeltaEntity(int a1, int a2, int a3, int a4)
{
  return MSG_WriteDeltaStruct((_DWORD *)a1, (_DWORD *)a2, (_DWORD *)a3, a4, 59, 10, (int)&entityStateFields, 0);
}
// 80DB860: using guessed type char *entityStateFields;

//----- (080814E8) --------------------------------------------------------
_DWORD *__cdecl sub_80814E8(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  return MSG_WriteDeltaStruct(a1, a2, a3, a4, 67, 10, (int)&off_80DBB80, 0);
}
// 80DBB80: using guessed type char *off_80DBB80;

//----- (08081536) --------------------------------------------------------
_DWORD *__cdecl sub_8081536(_DWORD *a1, char *a2, _DWORD *a3, int a4)
{
  char s[108]; // [esp+20h] [ebp-78h] BYREF
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x5Cu);
  }
  return MSG_WriteDeltaStruct(a1, a2, a3, a4, v6, 6, (int)&off_80DBFE0, 1);
}
// 80DBFE0: using guessed type char *off_80DBFE0;

//----- (080815AE) --------------------------------------------------------
int __cdecl sub_80815AE(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax
  int v6; // edx
  int v7; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int i; // [esp+18h] [ebp-20h]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+2Ch] [ebp-Ch]
  int *v13; // [esp+30h] [ebp-8h]
  int *v14; // [esp+34h] [ebp-4h]

  v14 = (int *)(a2 + a4[1]);
  v13 = (int *)(a3 + a4[1]);
  if ( !sub_807FBC2(a1) )
  {
    result = (int)v13;
    *v13 = *v14;
    return result;
  }
  if ( a4[2] )
  {
    if ( !sub_807FBC2(a1) )
    {
      result = (int)v13;
      *v13 = 0;
      return result;
    }
    v8 = a4[2];
    if ( v8 < 0 )
      v8 = -v8;
    if ( (v8 & 7) != 0 )
      v7 = MSG_ReadBits(a1, v8 & 7);
    else
      v7 = 0;
    v10 = v7;
    for ( i = v8 & 7; i < v8; i += 8 )
      v10 |= MSG_ReadByte(a1) << i;
    result = v10;
    *v13 = v10;
    if ( a5 )
      return Com_Printf("%s:%i ", *a4);
  }
  else
  {
    if ( !sub_807FBC2(a1) )
    {
      result = (int)v13;
      *v13 = 0;
      return result;
    }
    if ( !sub_807FBC2(a1) )
    {
      v11 = MSG_ReadBits(a1, 5);
      v12 = 32 * MSG_ReadByte(a1) + v11 - 4096;
      result = (int)v13;
      *(float *)v13 = (float)v12;
      if ( !a5 )
        return result;
      return Com_Printf("%s:%i ", *a4);
    }
    v6 = MSG_ReadLong(a1);
    result = (int)v13;
    *v13 = v6;
    if ( a5 )
      result = Com_Printf("%s:%f ", *a4);
  }
  return result;
}

//----- (0808179B) --------------------------------------------------------
int __cdecl sub_808179B(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]
  int j; // [esp+24h] [ebp-4h]

  if ( sub_807FBC2(a1) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a4 )
        break;
      sub_80815AE(a1, a2, a3, (_DWORD *)(a5 + 12 * i), 0);
    }
  }
  else
  {
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= a4 )
        break;
      *(_DWORD *)(a3 + *(_DWORD *)(a5 + 12 * j + 4)) = *(_DWORD *)(a2 + *(_DWORD *)(a5 + 12 * j + 4));
    }
  }
  return result;
}

//----- (0808184D) --------------------------------------------------------
int __cdecl sub_808184D(int a1, void *src, void *dest, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h]
  _DWORD *v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  int v13; // [esp+34h] [ebp-4h]
  int v14; // [esp+34h] [ebp-4h]

  if ( sub_807FBC2((_DWORD *)a1) == 1 )
  {
    if ( dword_836B7B4 && (*(int *)(dword_836B7B4 + 32) > 1 || *(_DWORD *)(dword_836B7B4 + 32) == -1) )
      Com_Printf("%3i: #%-3i remove\n", *(_DWORD *)(a1 + 16));
    v8 = 1;
  }
  else if ( sub_807FBC2((_DWORD *)a1) )
  {
    v12 = MSG_ReadByte((_DWORD *)a1);
    if ( v12 > a5 )
      v12 = a5;
    if ( dword_836B7B4 && (*(int *)(dword_836B7B4 + 32) > 1 || *(_DWORD *)(dword_836B7B4 + 32) == -1) )
    {
      v9 = 1;
      Com_Printf("%3i: #%-3i ", *(_DWORD *)(a1 + 16));
    }
    else
    {
      v9 = 0;
    }
    *(_DWORD *)dest = a4;
    v13 = 0;
    v10 = (_DWORD *)a7;
    while ( v13 < v12 )
    {
      sub_80815AE((_DWORD *)a1, (int)src, (int)dest, v10, v9);
      ++v13;
      v10 += 3;
    }
    v14 = v12;
    v11 = a7 + 12 * v12;
    while ( v14 < a5 )
    {
      *(_DWORD *)((char *)dest + *(_DWORD *)(v11 + 4)) = *(_DWORD *)((char *)src + *(_DWORD *)(v11 + 4));
      ++v14;
      v11 += 12;
    }
    v8 = 0;
  }
  else
  {
    memcpy(dest, src, 4 * a5 + 4);
    v8 = 0;
  }
  return v8;
}
// 836B7B4: using guessed type int dword_836B7B4;

//----- (08081A49) --------------------------------------------------------
int __cdecl sub_8081A49(int a1, void *src, void *dest, int a4)
{
  return sub_808184D(a1, src, dest, a4, 67, 10, (int)&off_80DBB80);
}
// 80DBB80: using guessed type char *off_80DBB80;

//----- (08081A8F) --------------------------------------------------------
int __cdecl sub_8081A8F(int a1, void *src, void *dest, int a4)
{
  char s[108]; // [esp+20h] [ebp-78h] BYREF
  int v6; // [esp+8Ch] [ebp-Ch]

  v6 = 22;
  if ( !src )
  {
    src = s;
    memset(s, 0, 0x5Cu);
  }
  return sub_808184D(a1, src, dest, a4, v6, 6, (int)&off_80DBFE0);
}
// 80DBFE0: using guessed type char *off_80DBFE0;

//----- (08081AFF) --------------------------------------------------------
int __cdecl MSG_WriteDeltaHudElems(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  unsigned int k; // [esp+20h] [ebp-8h]
  int l; // [esp+20h] [ebp-8h]
  int j; // [esp+24h] [ebp-4h]

  for ( i = 0; i < a4 && *(_DWORD *)(a3 + 112 * i); ++i )
    ;
  MSG_WriteBits(a1, i, 5);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= i )
      break;
    v5 = 0;
    for ( k = 0; k <= 0x1B; ++k )
    {
      if ( *(_DWORD *)(dword_80E9AE4[3 * k] + a2 + 112 * j) != *(_DWORD *)(dword_80E9AE4[3 * k] + a3 + 112 * j) )
        v5 = k;
    }
    MSG_WriteBits(a1, v5, 5);
    for ( l = 0; l <= v5; ++l )
      MSG_WriteDeltaField(a1, a2 + 112 * j, a3 + 112 * j, (int)&(&off_80E9AE0)[3 * l]);
  }
  return result;
}
// 80E9AE0: using guessed type char *off_80E9AE0;

//----- (08081C74) --------------------------------------------------------
void *__cdecl sub_8081C74(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  unsigned int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v6 = MSG_ReadBits(a1, 5);
  for ( i = 0; i < v6; ++i )
  {
    v5 = MSG_ReadBits(a1, 5);
    for ( j = 0; (int)j <= v5; ++j )
      sub_80815AE(a1, a2 + 112 * i, a3 + 112 * i, &(&off_80E9AE0)[3 * j], 0);
    while ( j <= 0x1B )
    {
      *(_DWORD *)(dword_80E9AE4[3 * j] + a3 + 112 * i) = *(_DWORD *)(dword_80E9AE4[3 * j] + a2 + 112 * i);
      ++j;
    }
  }
  return memset((void *)(a3 + 112 * v6), 0, 112 * (a4 - v6));
}
// 80E9AE0: using guessed type char *off_80E9AE0;

//----- (08081DD3) --------------------------------------------------------
_DWORD *__cdecl sub_8081DD3(_DWORD *a1, char *a2, _DWORD *a3)
{
  int v4; // [esp+20h] [ebp-2138h]
  int v5; // [esp+28h] [ebp-2130h]
  int v6; // [esp+2Ch] [ebp-212Ch]
  int v7; // [esp+30h] [ebp-2128h]
  int v8; // [esp+34h] [ebp-2124h]
  int v9; // [esp+34h] [ebp-2124h]
  int *v10; // [esp+3Ch] [ebp-211Ch]
  char **v11; // [esp+44h] [ebp-2114h]
  char **v12; // [esp+44h] [ebp-2114h]
  int v13; // [esp+4Ch] [ebp-210Ch]
  int v14[7]; // [esp+50h] [ebp-2108h]
  int v15; // [esp+6Ch] [ebp-20ECh]
  char s[8404]; // [esp+70h] [ebp-20E8h] BYREF
  int v17; // [esp+2144h] [ebp-14h]
  int j; // [esp+2148h] [ebp-10h]
  int i; // [esp+214Ch] [ebp-Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x20CCu);
  }
  v17 = 0;
  i = 0;
  v11 = &playerStateFields;
  while ( i < 103 )
  {
    if ( *(_DWORD *)&v11[1][(_DWORD)a2] != *(_DWORD *)&v11[1][(_DWORD)a3] )
      v17 = i + 1;
    ++i;
    v11 += 3;
  }
  MSG_WriteByte(a1, v17);
  i = 0;
  v12 = &playerStateFields;
  while ( i < v17 )
  {
    v10 = (int *)&v12[1][(_DWORD)a3];
    if ( *(_DWORD *)&v12[1][(_DWORD)a2] == *v10 )
    {
      MSG_WriteBit0(a1);
    }
    else
    {
      MSG_WriteBit1(a1);
      if ( v12[2] )
      {
        v7 = *v10;
        v4 = (int)v12[2];
        if ( v4 < 0 )
          v4 = -v4;
        v6 = v4;
        v5 = v4 & 7;
        if ( (v4 & 7) != 0 )
        {
          MSG_WriteBits(a1, v7, v5);
          v6 = v4 - v5;
          v7 >>= v5;
        }
        while ( v6 )
        {
          MSG_WriteByte(a1, v7);
          v7 >>= 8;
          v6 -= 8;
        }
      }
      else
      {
        v8 = (int)*(float *)v10;
        if ( (long double)v8 == *(float *)v10 && v8 + 4096 >= 0 && v8 + 4096 <= 0x1FFF )
        {
          MSG_WriteBit0(a1);
          v9 = v8 + 4096;
          MSG_WriteBits(a1, v9, 5);
          MSG_WriteByte(a1, v9 >> 5);
        }
        else
        {
          MSG_WriteBit1(a1);
          MSG_WriteLong(a1, *v10);
        }
      }
    }
    ++i;
    v12 += 3;
  }
  v15 = 0;
  for ( i = 0; i <= 5; ++i )
  {
    if ( a3[i + 61] != *(_DWORD *)&a2[4 * i + 244] )
      v15 |= 1 << i;
  }
  if ( v15 )
  {
    MSG_WriteBit1(a1);
    MSG_WriteBits(a1, v15, 6);
    if ( (v15 & 1) != 0 )
      MSG_WriteShort(a1, a3[61]);
    if ( (v15 & 2) != 0 )
      MSG_WriteShort(a1, a3[62]);
    if ( (v15 & 4) != 0 )
      MSG_WriteShort(a1, a3[63]);
    if ( (v15 & 8) != 0 )
      MSG_WriteBits(a1, a3[64], 6);
    if ( (v15 & 0x10) != 0 )
      MSG_WriteShort(a1, a3[65]);
    if ( (v15 & 0x20) != 0 )
      MSG_WriteByte(a1, a3[66]);
  }
  else
  {
    MSG_WriteBit0(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v14[j] = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 67 + i] != *(_DWORD *)&a2[64 * j + 268 + 4 * i] )
        v14[j] |= 1 << i;
    }
  }
  if ( v14[0] || v14[1] || v14[2] || v14[3] )
  {
    MSG_WriteBit1(a1);
    for ( j = 0; j <= 3; ++j )
    {
      if ( v14[j] )
      {
        MSG_WriteBit1(a1);
        MSG_WriteShort(a1, v14[j]);
        for ( i = 0; i <= 15; ++i )
        {
          if ( ((v14[j] >> i) & 1) != 0 )
            MSG_WriteShort(a1, a3[16 * j + 67 + i]);
        }
      }
      else
      {
        MSG_WriteBit0(a1);
      }
    }
  }
  else
  {
    MSG_WriteBit0(a1);
  }
  for ( j = 0; j <= 3; ++j )
  {
    v13 = 0;
    for ( i = 0; i <= 15; ++i )
    {
      if ( a3[16 * j + 131 + i] != *(_DWORD *)&a2[64 * j + 524 + 4 * i] )
        v13 |= 1 << i;
    }
    if ( v13 )
    {
      MSG_WriteBit1(a1);
      MSG_WriteShort(a1, v13);
      for ( i = 0; i <= 15; ++i )
      {
        if ( ((v13 >> i) & 1) != 0 )
          MSG_WriteShort(a1, a3[16 * j + 131 + i]);
      }
    }
    else
    {
      MSG_WriteBit0(a1);
    }
  }
  if ( !memcmp(a2 + 1000, a3 + 250, 0x1C0u) )
  {
    MSG_WriteBit0(a1);
  }
  else
  {
    MSG_WriteBit1(a1);
    for ( i = 0; i <= 15; ++i )
    {
      MSG_WriteBits(a1, a3[7 * i + 250], 3);
      sub_8081210(a1, (int)&a2[28 * i + 1000], (int)&a3[7 * i + 250], 0, 6, (int)&off_80E9A80);
    }
  }
  if ( !memcmp(a2 + 1448, a3 + 362, 6944u) )
    return MSG_WriteBit0(a1);
  MSG_WriteBit1(a1);
  MSG_WriteDeltaHudElems(a1, (int)(a2 + 4920), (int)(a3 + 1230), 31);
  return (_DWORD *)MSG_WriteDeltaHudElems(a1, (int)(a2 + 1448), (int)(a3 + 362), 31);
}
// 80DC560: using guessed type char *playerStateFields;
// 80E9A80: using guessed type char *off_80E9A80;

//----- (08082640) --------------------------------------------------------
void *__cdecl sub_8082640(_DWORD *a1, char *a2, char *a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // ebx
  char *v8; // ebx
  void *result; // eax
  int v10; // [esp+2Ch] [ebp-213Ch]
  int v11; // [esp+30h] [ebp-2138h]
  unsigned int v12; // [esp+34h] [ebp-2134h]
  char *v13; // [esp+38h] [ebp-2130h]
  char *v14; // [esp+3Ch] [ebp-212Ch]
  char s[8412]; // [esp+40h] [ebp-2128h] BYREF
  int v16; // [esp+211Ch] [ebp-4Ch]
  int v17; // [esp+2120h] [ebp-48h]
  unsigned int v18; // [esp+2124h] [ebp-44h]
  int v19; // [esp+2128h] [ebp-40h]
  char *v20; // [esp+212Ch] [ebp-3Ch]
  char *v21; // [esp+2130h] [ebp-38h]
  int v22; // [esp+2134h] [ebp-34h]
  int v23; // [esp+2138h] [ebp-30h]
  char **v24; // [esp+213Ch] [ebp-2Ch]
  int v25; // [esp+2140h] [ebp-28h]
  int v26; // [esp+2144h] [ebp-24h]
  int i; // [esp+2148h] [ebp-20h]
  int j; // [esp+214Ch] [ebp-1Ch]

  if ( !a2 )
  {
    a2 = s;
    memset(s, 0, 0x20CCu);
  }
  v14 = a3;
  v13 = a2;
  v12 = 8396;
  if ( ((unsigned __int8)a3 & 4) != 0 )
  {
    *(_DWORD *)a3 = *(_DWORD *)a2;
    v14 = a3 + 4;
    v13 = a2 + 4;
    v12 = 8392;
  }
  qmemcpy(v14, v13, 4 * (v12 >> 2));
  if ( dword_836B7B4 && (*(int *)(dword_836B7B4 + 32) > 1 || *(_DWORD *)(dword_836B7B4 + 32) == -2) )
  {
    v22 = 1;
    Com_Printf("%3i: playerstate ", a1[4]);
  }
  else
  {
    v22 = 0;
  }
  v23 = 103;
  v26 = MSG_ReadByte(a1);
  j = 0;
  v24 = &playerStateFields;
  while ( j < v26 )
  {
    v21 = &v24[1][(_DWORD)a2];
    v20 = &v24[1][(_DWORD)a3];
    if ( !sub_807FBC2(a1) )
    {
      *(_DWORD *)v20 = *(_DWORD *)v21;
      goto LABEL_30;
    }
    if ( v24[2] )
    {
      v18 = (unsigned int)v24[2] >> 31;
      v11 = (int)v24[2];
      if ( v18 )
        v11 = -v11;
      v25 = v11;
      v17 = v11 & 7;
      if ( (v11 & 7) != 0 )
        v10 = MSG_ReadBits(a1, v17);
      else
        v10 = 0;
      v16 = v10;
      for ( i = v17; i < v25; i += 8 )
      {
        v5 = MSG_ReadByte(a1);
        v16 |= v5 << i;
      }
      *(_DWORD *)v20 = v16;
      if ( v22 )
        goto LABEL_29;
    }
    else
    {
      if ( !sub_807FBC2(a1) )
      {
        v19 = MSG_ReadBits(a1, 5);
        v3 = MSG_ReadByte(a1);
        v19 += 32 * v3;
        v19 -= 4096;
        *(float *)v20 = (float)v19;
        if ( !v22 )
          goto LABEL_30;
LABEL_29:
        Com_Printf("%s:%i ", (char)*v24);
        goto LABEL_30;
      }
      v4 = MSG_ReadLong(a1);
      *(_DWORD *)v20 = v4;
      if ( v22 )
        Com_Printf("%s:%f ", (char)*v24);
    }
LABEL_30:
    ++j;
    v24 += 3;
  }
  j = v26;
  v24 = &(&playerStateFields)[3 * v26];
  while ( j < v23 )
  {
    v21 = &v24[1][(_DWORD)a2];
    v20 = &v24[1][(_DWORD)a3];
    *(_DWORD *)v20 = *(_DWORD *)v21;
    ++j;
    v24 += 3;
  }
  if ( sub_807FBC2(a1) )
  {
    if ( dword_836B7B4 && *(_DWORD *)(dword_836B7B4 + 32) == 4 )
      Com_Printf("%s ", (char)"PS_STATS");
    v25 = MSG_ReadBits(a1, 6);
    if ( (v25 & 1) != 0 )
      *((_DWORD *)a3 + 61) = MSG_ReadShort(a1);
    if ( (v25 & 2) != 0 )
      *((_DWORD *)a3 + 62) = MSG_ReadShort(a1);
    if ( (v25 & 4) != 0 )
      *((_DWORD *)a3 + 63) = MSG_ReadShort(a1);
    if ( (v25 & 8) != 0 )
      *((_DWORD *)a3 + 64) = MSG_ReadBits(a1, 6);
    if ( (v25 & 0x10) != 0 )
      *((_DWORD *)a3 + 65) = MSG_ReadShort(a1);
    if ( (v25 & 0x20) != 0 )
      *((_DWORD *)a3 + 66) = MSG_ReadByte(a1);
  }
  if ( sub_807FBC2(a1) )
  {
    for ( i = 0; i <= 3; ++i )
    {
      if ( sub_807FBC2(a1) )
      {
        if ( dword_836B7B4 && *(_DWORD *)(dword_836B7B4 + 32) == 4 )
          Com_Printf("%s ", (char)"PS_AMMO");
        v25 = MSG_ReadShort(a1);
        for ( j = 0; j <= 15; ++j )
        {
          if ( ((v25 >> j) & 1) != 0 )
          {
            v6 = j + 16 * i;
            *(_DWORD *)&a3[4 * v6 + 268] = MSG_ReadShort(a1);
          }
        }
      }
    }
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( sub_807FBC2(a1) )
    {
      if ( dword_836B7B4 && *(_DWORD *)(dword_836B7B4 + 32) == 4 )
        Com_Printf("%s ", (char)"PS_AMMOCLIP");
      v25 = MSG_ReadShort(a1);
      for ( j = 0; j <= 15; ++j )
      {
        if ( ((v25 >> j) & 1) != 0 )
        {
          v7 = j + 16 * i;
          *(_DWORD *)&a3[4 * v7 + 524] = MSG_ReadShort(a1);
        }
      }
    }
  }
  if ( sub_807FBC2(a1) )
  {
    for ( j = 0; j <= 15; ++j )
    {
      v8 = &a3[28 * j + 1000];
      *(_DWORD *)v8 = MSG_ReadBits(a1, 3);
      sub_808179B(a1, (int)&a2[28 * j + 1000], (int)&a3[28 * j + 1000], 6, (int)&off_80E9A80);
    }
  }
  result = (void *)sub_807FBC2(a1);
  if ( result )
  {
    sub_8081C74(a1, (int)(a2 + 4920), (int)(a3 + 4920), 31);
    result = sub_8081C74(a1, (int)(a2 + 1448), (int)(a3 + 1448), 31);
  }
  return result;
}
// 80DC560: using guessed type char *playerStateFields;
// 80E9A80: using guessed type char *off_80E9A80;
// 836B7B4: using guessed type int dword_836B7B4;

//----- (08082D03) --------------------------------------------------------
int *sub_8082D03()
{
  int *result; // eax
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  dword_80E99C0 = 1;
  result = (int *)sub_8077008(dword_8153D20);
  for ( i = 0; i <= 255; ++i )
  {
    for ( j = 0; j < dword_80E9C40[i]; ++j )
    {
      sub_80767B5(dword_8153D20, i);
      sub_80767B5(dword_815AD3C, i);
    }
    result = &i;
  }
  return result;
}
// 80E99C0: using guessed type int dword_80E99C0;

//----- (08082D81) --------------------------------------------------------
int __cdecl sub_8082D81(__int16 a1)
{
  return a1;
}

//----- (08082D94) --------------------------------------------------------
int __cdecl sub_8082D94(int a1)
{
  return a1;
}

//----- (08082D9C) --------------------------------------------------------
void *__cdecl NetProf_PrepProfiling(void **a1)
{
  void *result; // eax
  char v2; // [esp+4h] [ebp-14h]

  if ( *(_DWORD *)(dword_8360804 + 32) )
  {
    if ( !dword_80EA048 )
    {
      if ( !*(_DWORD *)(dword_8360560 + 32) || *(_DWORD *)(dword_8360658 + 32) && *(_DWORD *)(dword_8360804 + 32) == 2 )
        dword_80EA048 = 1;
      else
        dword_80EA048 = 2;
      Com_Printf("Net Profiling turned on: %s\n", *(_DWORD *)&dword_80EA03C[4 * dword_80EA048]);
    }
    result = a1;
    if ( !*a1 )
    {
      *a1 = malloc(0x5E0u);
      result = memset(*a1, 0, 0x5E0u);
    }
  }
  else
  {
    if ( dword_80EA048 )
    {
      dword_80EA048 = 0;
      Com_Printf("Net Profiling turned off\n", v2);
    }
    result = a1;
    if ( *a1 )
    {
      free(*a1);
      result = a1;
      *a1 = 0;
    }
  }
  return result;
}
// 8082E62: variable 'v2' is possibly undefined
// 80EA048: using guessed type int dword_80EA048;
// 8360560: using guessed type int dword_8360560;
// 8360658: using guessed type int dword_8360658;
// 8360804: using guessed type int dword_8360804;

//----- (08082E8B) --------------------------------------------------------
int __cdecl sub_8082E8B(int a1, int a2, int a3)
{
  int v3; // ecx
  int result; // eax
  int *v5; // [esp+0h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 720) + 1;
  *(_DWORD *)(a1 + 720) = v3 / 60;
  *(_DWORD *)(a1 + 720) = v3 - 60 * *(_DWORD *)(a1 + 720);
  v5 = (int *)(a1 + 12 * *(_DWORD *)(a1 + 720));
  *v5 = sub_80D563C();
  v5[1] = a2;
  result = a3;
  v5[2] = a3;
  return result;
}

//----- (08082F11) --------------------------------------------------------
int __cdecl NetProf_NewSendPacket(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( dword_80EA048 )
  {
    sub_8082E8B(a1[8207], a2, a3);
    result = *(_DWORD *)(dword_836080C + 32) & 2;
    if ( result )
      result = Com_Printf("%s send%s: %i\n", *(_DWORD *)&off_80EA040[4 * *a1]);
  }
  return result;
}
// 80EA048: using guessed type int dword_80EA048;
// 836080C: using guessed type int dword_836080C;

//----- (08082F92) --------------------------------------------------------
int __cdecl NetProf_NewRecievePacket(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( dword_80EA048 )
  {
    sub_8082E8B(a1[8207] + 752, a2, a3);
    result = *(_DWORD *)(dword_836080C + 32) & 2;
    if ( result )
      result = Com_Printf("%s recieve%s: %i\n", *(_DWORD *)&off_80EA040[4 * *a1]);
  }
  return result;
}
// 80EA048: using guessed type int dword_80EA048;
// 836080C: using guessed type int dword_836080C;

//----- (08083018) --------------------------------------------------------
_DWORD *__cdecl sub_8083018(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ebx
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  _DWORD *v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v10 = 0;
  v9 = 0;
  v8 = -1;
  v7 = sub_80D563C();
  v5 = 0;
  v4 = 9999;
  v3 = 0;
  for ( i = 0; i <= 59; ++i )
  {
    if ( a1[3 * i] && sub_80D563C() <= a1[3 * i] + 1000 )
    {
      ++v10;
      if ( a1[3 * i + 2] )
        v9 = (_DWORD *)((char *)v9 + 1);
      if ( a1[3 * i] < v7 )
      {
        v8 = i;
        v7 = a1[3 * i];
      }
      v5 += a1[3 * i + 1];
      if ( a1[3 * i + 1] < v4 )
        v4 = a1[3 * i + 1];
      if ( a1[3 * i + 1] > v3 )
        v3 = a1[3 * i + 1];
    }
  }
  if ( v10 )
  {
    if ( v9 )
      a1[185] = 100 * (int)v9 / v10;
    else
      a1[185] = 0;
    a1[186] = v3;
    a1[187] = v4;
    v2 = a1[182] + 100;
    if ( v2 < sub_80D563C() )
    {
      v6 = sub_80D563C() - v7;
      if ( v8 != -1 )
      {
        v5 -= a1[3 * v8 + 1];
        --v10;
        if ( a1[3 * v8 + 2] )
          v9 = (_DWORD *)((char *)v9 - 1);
      }
      if ( v6 > 0 && v10 )
      {
        if ( v5 )
          a1[181] = (int)((long double)v5 / ((long double)v6 * 0.001));
        else
          a1[181] = 0;
        a1[182] = sub_80D563C();
      }
      else
      {
        a1[181] = 0;
      }
    }
    a1[183] = v10;
    result = v9;
    a1[184] = v9;
  }
  else
  {
    a1[181] = 0;
    a1[182] = 0;
    a1[183] = 0;
    a1[184] = 0;
    a1[185] = 0;
    a1[186] = 0;
    result = a1;
    a1[187] = 0;
  }
  return result;
}

//----- (0808334C) --------------------------------------------------------
int sub_808334C()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-4h]

  if ( dword_80EA048 )
    result = sub_8094A7F(1);
  else
    result = Com_Printf("Network profiling is not on. Set net_profile to turn on network profiling\n", v1);
  return result;
}
// 8083362: variable 'v1' is possibly undefined
// 808334C: using guessed type int sub_808334C();
// 80EA048: using guessed type int dword_80EA048;

//----- (08083377) --------------------------------------------------------
_DWORD *__cdecl Netchan_Init(unsigned __int16 a1)
{
  char *v1; // eax

  dword_8360814 = (int)Cvar_Get("showpackets", "0", 256);
  dword_8360808 = (int)Cvar_Get("showdrop", "0", 256);
  v1 = va("%i", a1);
  dword_8360810 = (int)Cvar_Get("net_qport", v1, 16);
  dword_8360804 = (int)Cvar_Get("net_profile", "0", 256);
  dword_836080C = (int)Cvar_Get("net_showprofile", "0", 256);
  dword_8360800 = (int)Cvar_Get("net_lanauthorize", "0", 0);
  return sub_806043E("net_dumpprofile", (int)sub_808334C);
}
// 808334C: using guessed type int sub_808334C();
// 8360800: using guessed type int dword_8360800;
// 8360804: using guessed type int dword_8360804;
// 8360808: using guessed type int dword_8360808;
// 836080C: using guessed type int dword_836080C;
// 8360810: using guessed type int dword_8360810;
// 8360814: using guessed type int dword_8360814;

//----- (0808346F) --------------------------------------------------------
void *__cdecl sub_808346F(int a1, void *s, int a3, int a4, int a5, int a6, int a7, int a8)
{
  memset(s, 0, 0x8040u);
  *(_DWORD *)s = a1;
  *((_DWORD *)s + 2) = a3;
  *((_DWORD *)s + 3) = a4;
  *((_DWORD *)s + 4) = a5;
  *((_DWORD *)s + 5) = a6;
  *((_DWORD *)s + 6) = a7;
  *((_DWORD *)s + 7) = a8;
  *((_DWORD *)s + 8) = 0;
  *((_DWORD *)s + 9) = 1;
  return NetProf_PrepProfiling((void **)s + 8207);
}

//----- (080834E8) --------------------------------------------------------
int *__cdecl Netchan_TransmitNextFragment(int *a1)
{
  int *result; // eax
  int n; // [esp+2Ch] [ebp-5ACh]
  int v3[352]; // [esp+30h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5B0h] [ebp-28h] BYREF
  size_t v5; // [esp+5BCh] [ebp-1Ch]

  NetProf_PrepProfiling((void **)a1 + 8207);
  MSG_Init(s, (int)v3, 1400);
  MSG_WriteLong(s, a1[9] | 0x80000000);
  if ( !*a1 )
    MSG_WriteShort(s, *(_DWORD *)(dword_8360810 + 32));
  n = 1300;
  if ( a1[4109] + 1300 > a1[4110] )
    n = a1[4110] - a1[4109];
  MSG_WriteShort(s, a1[4109]);
  MSG_WriteShort(s, n);
  MSG_WriteData((int)s, (char *)a1 + a1[4109] + 16444, n);
  NET_SendPacket(*a1, v5, (void *)s[1], a1[2], a1[3], a1[4], a1[5], a1[6]);
  NetProf_NewSendPacket(a1, v5, 1);
  if ( *(_DWORD *)(dword_8360814 + 32) )
    Com_Printf("%s send %4i : s=%i fragment=%i,%i\n", *(_DWORD *)&off_80EA040[4 * *a1]);
  a1[4109] += n;
  result = (int *)a1[4109];
  if ( result == (int *)a1[4110] && n != 1300 )
  {
    ++a1[9];
    result = a1;
    a1[4108] = 0;
  }
  return result;
}
// 8360810: using guessed type int dword_8360810;
// 8360814: using guessed type int dword_8360814;

//----- (080836E6) --------------------------------------------------------
int *__cdecl sub_80836E6(int a1, size_t n, void *src)
{
  int *result; // eax
  int v4[352]; // [esp+20h] [ebp-5A8h] BYREF
  int s[3]; // [esp+5A0h] [ebp-28h] BYREF
  size_t v6; // [esp+5ACh] [ebp-1Ch]

  if ( (int)n > 0x4000 )
    Com_Error(1, (char *)&byte_80DCE40, n);
  *(_DWORD *)(a1 + 16436) = 0;
  if ( (int)n <= 1299 )
  {
    NetProf_PrepProfiling((void **)(a1 + 32828));
    MSG_Init(s, (int)v4, 1400);
    MSG_WriteLong(s, *(_DWORD *)(a1 + 36));
    ++*(_DWORD *)(a1 + 36);
    if ( !*(_DWORD *)a1 )
      MSG_WriteShort(s, *(_DWORD *)(dword_8360810 + 32));
    MSG_WriteData((int)s, src, n);
    NET_SendPacket(
      *(_DWORD *)a1,
      v6,
      (void *)s[1],
      *(_DWORD *)(a1 + 8),
      *(_DWORD *)(a1 + 12),
      *(_DWORD *)(a1 + 16),
      *(_DWORD *)(a1 + 20),
      *(_DWORD *)(a1 + 24));
    NetProf_NewSendPacket((_DWORD *)a1, v6, 0);
    result = (int *)dword_8360814;
    if ( *(_DWORD *)(dword_8360814 + 32) )
      result = (int *)Com_Printf("%s send %4i : s=%i ack=%i\n", *(_DWORD *)&off_80EA040[4 * *(_DWORD *)a1]);
  }
  else
  {
    *(_DWORD *)(a1 + 16432) = 1;
    *(_DWORD *)(a1 + 16440) = n;
    sub_80D2FC8((void *)(a1 + 16444), src, n);
    result = Netchan_TransmitNextFragment((int *)a1);
  }
  return result;
}
// 8360810: using guessed type int dword_8360810;
// 8360814: using guessed type int dword_8360814;

//----- (08083890) --------------------------------------------------------
int __cdecl Netchan_Process(_DWORD *a1, _DWORD *a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  char v6; // al
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  int v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+34h] [ebp-4h]

  NetProf_PrepProfiling((void **)a1 + 8207);
  MSG_BeginReading((int)a2);
  v12 = MSG_ReadLong(a2);
  if ( (v12 & 0x80000000) != 0 )
  {
    v12 &= 0x7FFFFFFFu;
    v9 = 1;
  }
  else
  {
    v9 = 0;
  }
  if ( *a1 == 1 )
    MSG_ReadShort(a2);
  if ( v9 )
  {
    v11 = MSG_ReadShort(a2);
    n = MSG_ReadShort(a2);
  }
  else
  {
    v11 = 0;
    n = 0;
  }
  NetProf_NewRecievePacket(a1, a2[3], v9);
  if ( *(_DWORD *)(dword_8360814 + 32) )
  {
    if ( v9 )
      Com_Printf("%s recv %4i : s=%i fragment=%i,%i\n", *(_DWORD *)&off_80EA040[4 * *a1]);
    else
      Com_Printf("%s recv %4i : s=%i\n", *(_DWORD *)&off_80EA040[4 * *a1]);
  }
  if ( v12 > a1[8] )
  {
    a1[1] = v12 - a1[8] - 1;
    if ( (int)a1[1] > 0 && (*(_DWORD *)(dword_8360808 + 32) || *(_DWORD *)(dword_8360814 + 32)) )
    {
      v3 = (unsigned __int8)NET_AdrToString(a1[2], a1[3], a1[4], a1[5], a1[6]);
      Com_Printf("%s:Dropped %i packets at %i\n", v3);
    }
    if ( v9 )
    {
      if ( v12 != a1[10] )
      {
        a1[10] = v12;
        a1[11] = 0;
      }
      if ( v11 == a1[11] )
      {
        if ( n >= 0 && n + a2[4] <= a2[3] && (unsigned int)(n + a1[11]) <= 0x4000 )
        {
          memcpy((char *)a1 + a1[11] + 48, (const void *)(a2[1] + a2[4]), n);
          a1[11] += n;
          if ( n == 1300 )
          {
            v8 = 0;
          }
          else if ( a1[11] <= a2[2] )
          {
            *(_DWORD *)a2[1] = sub_8084648(v12);
            memcpy((void *)(a2[1] + 4), a1 + 12, a1[11]);
            a2[3] = a1[11] + 4;
            a1[11] = 0;
            MSG_BeginReading((int)a2);
            MSG_ReadLong(a2);
            v8 = 1;
          }
          else
          {
            v6 = (unsigned __int8)NET_AdrToString(a1[2], a1[3], a1[4], a1[5], a1[6]);
            Com_Printf("%s:fragmentLength %i > msg->maxsize\n", v6);
            v8 = 0;
          }
        }
        else
        {
          if ( *(_DWORD *)(dword_8360808 + 32) || *(_DWORD *)(dword_8360814 + 32) )
          {
            v5 = (unsigned __int8)NET_AdrToString(a1[2], a1[3], a1[4], a1[5], a1[6]);
            Com_Printf("%s:illegal fragment length\n", v5);
          }
          v8 = 0;
        }
      }
      else
      {
        if ( *(_DWORD *)(dword_8360808 + 32) || *(_DWORD *)(dword_8360814 + 32) )
        {
          v4 = (unsigned __int8)NET_AdrToString(a1[2], a1[3], a1[4], a1[5], a1[6]);
          Com_Printf("%s:Dropped a message fragment\n", v4);
        }
        v8 = 0;
      }
    }
    else
    {
      a1[8] = v12;
      v8 = 1;
    }
  }
  else
  {
    if ( *(_DWORD *)(dword_8360808 + 32) || *(_DWORD *)(dword_8360814 + 32) )
    {
      v2 = (unsigned __int8)NET_AdrToString(a1[2], a1[3], a1[4], a1[5], a1[6]);
      Com_Printf("%s:Out of order packet %i at %i\n", v2);
    }
    v8 = 0;
  }
  return v8;
}
// 8360808: using guessed type int dword_8360808;
// 8360814: using guessed type int dword_8360814;

//----- (08083D1A) --------------------------------------------------------
int __cdecl NET_CompareBaseAdrSigned(int a1, int a2)
{
  char v3; // [esp+4h] [ebp-14h]

  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return 0;
    case 0:
      return *(unsigned __int16 *)(a1 + 18) - *(unsigned __int16 *)(a2 + 18);
    case 4:
      return memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
    case 5:
      return memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0xAu);
  }
  Com_Printf("NET_CompareBaseAdrSigned: bad address type\n", v3);
  return 0;
}
// 8083DD2: variable 'v3' is possibly undefined

//----- (08083DE3) --------------------------------------------------------
_BOOL4 NET_CompareBaseAdr(int a1, int a2, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+34h] [ebp+1Ch] BYREF

  va_start(va, a5);
  return NET_CompareBaseAdrSigned((int)&a1, (int)va) == 0;
}

//----- (08083E10) --------------------------------------------------------
char *__cdecl NET_AdrToString(int a1, int a2, int a3, int a4, int a5)
{
  __int16 v5; // ax

  if ( a1 == 2 )
  {
    Com_sprintf(byte_8161D60, 0x40u, "loopback");
  }
  else
  {
    v5 = BigShort(SHIWORD(a5));
    if ( a1 == 4 )
      Com_sprintf(byte_8161D60, 0x40u, "%i.%i.%i.%i:%i", (unsigned __int8)a2, BYTE1(a2), BYTE2(a2), HIBYTE(a2), v5);
    else
      Com_sprintf(
        byte_8161D60,
        0x40u,
        "%02x%02x%02x%02x.%02x%02x%02x%02x%02x%02x:%i",
        (unsigned __int8)a3,
        BYTE1(a3),
        BYTE2(a3),
        HIBYTE(a3),
        (unsigned __int8)a4,
        BYTE1(a4),
        BYTE2(a4),
        HIBYTE(a4),
        (unsigned __int8)a5,
        BYTE1(a5),
        v5);
  }
  return byte_8161D60;
}

//----- (08083F16) --------------------------------------------------------
int __cdecl NET_CompareAdrSigned(int a1, int a2)
{
  char v3; // [esp+4h] [ebp-14h]
  int v4; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)a1 != *(_DWORD *)a2 )
    return *(_DWORD *)a1 - *(_DWORD *)a2;
  switch ( *(_DWORD *)a1 )
  {
    case 2:
      return 0;
    case 4:
      if ( *(_WORD *)(a1 + 18) == *(_WORD *)(a2 + 18) )
        v4 = memcmp((const void *)(a1 + 4), (const void *)(a2 + 4), 4u);
      else
        v4 = *(unsigned __int16 *)(a1 + 18) - *(unsigned __int16 *)(a2 + 18);
      break;
    case 5:
      if ( *(_WORD *)(a1 + 18) == *(_WORD *)(a2 + 18) )
        v4 = memcmp((const void *)(a1 + 8), (const void *)(a2 + 8), 0xAu);
      else
        v4 = *(unsigned __int16 *)(a1 + 18) - *(unsigned __int16 *)(a2 + 18);
      break;
    default:
      Com_Printf("NET_CompareAdrSigned: bad address type\n", v3);
      v4 = 0;
      break;
  }
  return v4;
}
// 8083FFE: variable 'v3' is possibly undefined

//----- (0808400F) --------------------------------------------------------
_BOOL4 NET_CompareAdr(int a1, int a2, int a3, int a4, int a5, ...)
{
  va_list va; // [esp+34h] [ebp+1Ch] BYREF

  va_start(va, a5);
  return NET_CompareAdrSigned((int)&a1, (int)va) == 0;
}

//----- (0808403C) --------------------------------------------------------
int __cdecl NET_IsLocalAddress(int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 == 2 || !a1 )
    v2 = 1;
  return v2;
}

//----- (08084061) --------------------------------------------------------
int __cdecl sub_8084061(int a1, void *s, int a3)
{
  char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v5 = (char *)&unk_8360820 + 22472 * a1;
  if ( *((_DWORD *)v5 + 5617) - *((_DWORD *)v5 + 5616) > 16 )
    *((_DWORD *)v5 + 5616) = *((_DWORD *)v5 + 5617) - 16;
  if ( *((_DWORD *)v5 + 5616) >= *((_DWORD *)v5 + 5617) )
    return 0;
  v6 = (*((_DWORD *)v5 + 5616))++ & 0xF;
  memcpy(*(void **)(a3 + 4), &v5[1404 * v6], *(_DWORD *)&v5[1404 * v6 + 1400]);
  *(_DWORD *)(a3 + 12) = *(_DWORD *)&v5[1404 * v6 + 1400];
  memset(s, 0, 0x14u);
  *(_DWORD *)s = 2;
  return 1;
}

//----- (08084164) --------------------------------------------------------
size_t __cdecl sub_8084164(int a1, size_t n, void *src)
{
  size_t result; // eax
  char *v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = (char *)&unk_8360820 + 22472 * (a1 ^ 1);
  v5 = (*((_DWORD *)v4 + 5617))++ & 0xF;
  memcpy(&v4[1404 * v5], src, n);
  result = n;
  *(_DWORD *)&v4[1404 * v5 + 1400] = n;
  return result;
}

//----- (080841D7) --------------------------------------------------------
void *__cdecl NET_SendPacket(int a1, size_t n, void *src, int a4, int a5, int a6, int a7, int a8)
{
  void *result; // eax

  result = (void *)dword_8360814;
  if ( *(_DWORD *)(dword_8360814 + 32) )
  {
    result = src;
    if ( *(_DWORD *)src == -1 )
      result = (void *)Com_Printf("send packet %4i\n", n);
  }
  if ( a4 == 2 )
    return (void *)sub_8084164(a1, n, src);
  if ( a4 != 1 )
  {
    if ( a4 )
      result = (void *)sub_80D4D4B(n, src, a4, a5, a6, a7, a8);
  }
  return result;
}
// 8360814: using guessed type int dword_8360814;

//----- (0808428E) --------------------------------------------------------
void *NET_OutOfBandPrint(int a1, int a2, int a3, int a4, int a5, int a6, char *format, ...)
{
  void *result; // eax
  size_t n; // [esp+2Ch] [ebp-401Ch]
  char s[4]; // [esp+30h] [ebp-4018h] BYREF
  char v10[16392]; // [esp+34h] [ebp-4014h] BYREF
  __gnuc_va_list __varargs; // [esp+403Ch] [ebp-Ch]
  va_list va; // [esp+406Ch] [ebp+24h] BYREF

  va_start(va, format);
  s[0] = -1;
  s[1] = -1;
  s[2] = -1;
  s[3] = -1;
  va_copy(__varargs, va);
  vsprintf(v10, format, va);
  n = strlen(s);
  result = NET_SendPacket(a1, n, s, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    result = (void *)SV_Netchan_AddOOBProfilePacket(n);
  return result;
}

//----- (0808442C) --------------------------------------------------------
void *__cdecl sub_808442C(int a1, int a2, int a3, int a4, int a5, int a6, void *src, size_t n)
{
  void *result; // eax
  char v9[4]; // [esp+40h] [ebp-8008h] BYREF
  int v10; // [esp+44h] [ebp-8004h] BYREF

  v9[0] = -1;
  v9[1] = -1;
  v9[2] = -1;
  v9[3] = -1;
  memcpy(&v10, src, n);
  result = NET_SendPacket(a1, n + 4, v9, a2, a3, a4, a5, a6);
  if ( a1 == 1 )
    result = (void *)SV_Netchan_AddOOBProfilePacket(n + 4);
  return result;
}

//----- (080844E0) --------------------------------------------------------
int __cdecl NET_StringToAdr(char *s1, void *s)
{
  __int16 v2; // ax
  int v4; // [esp+18h] [ebp-420h]
  const char *nptr; // [esp+1Ch] [ebp-41Ch]
  char haystack[1036]; // [esp+20h] [ebp-418h] BYREF

  if ( !strcmp(s1, "localhost") )
  {
    memset(s, 0, 0x14u);
    *(_DWORD *)s = 2;
    v4 = 1;
  }
  else
  {
    Q_strncpyz(haystack, s1, 1024);
    nptr = strstr(haystack, ":");
    if ( nptr )
      *nptr++ = 0;
    if ( sub_80D4B95(haystack, (int)s) )
    {
      if ( *((_BYTE *)s + 4) == 255
        && *((_BYTE *)s + 5) == 0xFF
        && *((_BYTE *)s + 6) == 0xFF
        && *((_BYTE *)s + 7) == 0xFF )
      {
        *(_DWORD *)s = 1;
        v4 = 0;
      }
      else
      {
        if ( nptr )
        {
          v2 = atoi(nptr);
          *((_WORD *)s + 9) = BigShort(v2);
        }
        else
        {
          *((_WORD *)s + 9) = BigShort(28960);
        }
        v4 = 1;
      }
    }
    else
    {
      *(_DWORD *)s = 1;
      v4 = 0;
    }
  }
  return v4;
}

//----- (08084648) --------------------------------------------------------
int __cdecl sub_8084648(int a1)
{
  return a1;
}

//----- (08084650) --------------------------------------------------------
void sub_8084650()
{
  ;
}

//----- (08084655) --------------------------------------------------------
int *CL_Init()
{
  int *result; // eax

  dword_836B7B4 = (int)Cvar_Get("cl_shownet", "0", 256);
  result = Cvar_Get("cl_language", "0", 1);
  dword_836B7B0 = (int)result;
  return result;
}
// 836B7B0: using guessed type int dword_836B7B0;
// 836B7B4: using guessed type int dword_836B7B4;

//----- (0808469F) --------------------------------------------------------
void sub_808469F()
{
  ;
}

//----- (080846A4) --------------------------------------------------------
void sub_80846A4()
{
  ;
}

//----- (080846A9) --------------------------------------------------------
void sub_80846A9()
{
  ;
}

//----- (080846AE) --------------------------------------------------------
void sub_80846AE()
{
  ;
}

//----- (080846B3) --------------------------------------------------------
void sub_80846B3()
{
  ;
}

//----- (080846B8) --------------------------------------------------------
void sub_80846B8()
{
  ;
}

//----- (080846BD) --------------------------------------------------------
void sub_80846BD()
{
  ;
}

//----- (080846C2) --------------------------------------------------------
int sub_80846C2()
{
  return 0;
}

//----- (080846CC) --------------------------------------------------------
void sub_80846CC()
{
  ;
}

//----- (080846D1) --------------------------------------------------------
int sub_80846D1()
{
  return 0;
}

//----- (080846DB) --------------------------------------------------------
void sub_80846DB()
{
  ;
}

//----- (080846E0) --------------------------------------------------------
void sub_80846E0()
{
  ;
}

//----- (080846EA) --------------------------------------------------------
void sub_80846EA()
{
  ;
}

//----- (080846EF) --------------------------------------------------------
void CL_InitKeyCommands()
{
  ;
}

//----- (080846F4) --------------------------------------------------------
void sub_80846F4()
{
  ;
}

//----- (080846F9) --------------------------------------------------------
void CL_StartHunkUsers()
{
  ;
}

//----- (080846FE) --------------------------------------------------------
void sub_80846FE()
{
  ;
}

//----- (08084703) --------------------------------------------------------
int sub_8084703()
{
  return 1;
}

//----- (08084714) --------------------------------------------------------
void sub_8084714()
{
  ;
}

//----- (08084719) --------------------------------------------------------
void sub_8084719()
{
  ;
}

//----- (0808471E) --------------------------------------------------------
void sub_808471E()
{
  ;
}

//----- (08084723) --------------------------------------------------------
void sub_8084723()
{
  ;
}

//----- (08084734) --------------------------------------------------------
char *__cdecl sub_8084734(char *src)
{
  if ( dword_81621A0 == 15 )
    Com_Error(0, (char *)&byte_80DD0C0);
  ++dword_81621A0;
  off_80EE660 = &dword_80EA0A0[279 * dword_81621A0];
  dword_80EA0A0[279 * dword_81621A0 + 256] = 1;
  *((_DWORD *)off_80EE660 + 257) = 0;
  *((_DWORD *)off_80EE660 + 258) = 1;
  *((_DWORD *)off_80EE660 + 259) = 0;
  return Q_strncpyz((char *)off_80EE660 + 1052, src, 64);
}
// 81621A0: using guessed type int dword_81621A0;

//----- (080847D5) --------------------------------------------------------
_DWORD *sub_80847D5()
{
  _DWORD *result; // eax

  if ( !dword_81621A0 )
    Com_Error(0, (char *)&byte_80DD100);
  --dword_81621A0;
  result = &dword_80EA0A0[279 * dword_81621A0];
  off_80EE660 = result;
  return result;
}
// 81621A0: using guessed type int dword_81621A0;

//----- (08084819) --------------------------------------------------------
void *sub_8084819()
{
  void *result; // eax

  dword_81621A0 = 0;
  result = &unk_80EA0A0;
  off_80EE660 = &unk_80EA0A0;
  return result;
}
// 81621A0: using guessed type int dword_81621A0;

//----- (08084855) --------------------------------------------------------
int __cdecl sub_8084855(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_80EE660 + 259) = a1;
  return result;
}

//----- (0808488D) --------------------------------------------------------
void __noreturn sub_808488D(char *format, ...)
{
  char s[32012]; // [esp+20h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D2Ch] [ebp-Ch]
  va_list va; // [esp+7D44h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Error(1, (char *)&byte_80DD128, (char *)off_80EE660 + 1052, *((_DWORD *)off_80EE660 + 256), s);
}

//----- (080848F5) --------------------------------------------------------
int sub_80848F5(char *format, ...)
{
  char s[32012]; // [esp+10h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D1Ch] [ebp-Ch]
  va_list va; // [esp+7D34h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return Com_Printf("File %s, line %i: %s", (_BYTE)off_80EE660 + 28);
}

//----- (08084955) --------------------------------------------------------
int sub_8084955()
{
  int result; // eax

  if ( *((_DWORD *)off_80EE660 + 257) )
    sub_808488D("UngetToken called twice");
  *((_DWORD *)off_80EE660 + 257) = 1;
  result = dword_81621A8;
  dword_81621A4 = dword_81621A8;
  return result;
}
// 81621A4: using guessed type int dword_81621A4;
// 81621A8: using guessed type int dword_81621A8;

//----- (08084A3A) --------------------------------------------------------
_BYTE *__cdecl sub_8084A3A(_BYTE *a1, _DWORD *a2)
{
  int v4; // [esp+4h] [ebp-4h]

  while ( 1 )
  {
    v4 = (char)*a1;
    if ( v4 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v4 == 10 )
    {
      ++*((_DWORD *)off_80EE660 + 256);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}

//----- (08084A8D) --------------------------------------------------------
int __cdecl sub_8084A8D(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 == 13 || v3 == 10 )
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
      else if ( v3 == 47 && v5[1] == 47 )
      {
        while ( *v5 && *v5 != 10 )
          ++v5;
      }
      else if ( v3 == 47 && v5[1] == 42 )
      {
        while ( *v5 && (*v5 != 42 || v5[1] != 47) )
        {
          if ( *v5 == 10 )
          {
            *v4++ = 10;
            ++v2;
          }
          ++v5;
        }
        if ( *v5 )
          v5 += 2;
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}
// 8084B8D: conditional instruction was optimized away because of '%var_14.4==0'

//----- (08084BC9) --------------------------------------------------------
int sub_8084BC9()
{
  return dword_81621A4;
}
// 81621A4: using guessed type int dword_81621A4;

//----- (08084BD3) --------------------------------------------------------
void *__cdecl sub_8084BD3(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+4h] [ebp-8h]
  _BYTE *i; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]

  v4 = *a1;
  v6 = 0;
  *(_BYTE *)off_80EE660 = 0;
  if ( a2 )
  {
    while ( *v4 == 13 || *v4 == 10 )
      ++v4;
  }
  else if ( *v4 == 13 || *v4 == 10 )
  {
    return off_80EE660;
  }
  dword_81621A8 = dword_81621A4;
  dword_81621A4 = (int)v4;
  while ( *v4 && *v4 != 44 && *v4 != 10 )
  {
    if ( *v4 == 13 )
    {
      ++v4;
    }
    else if ( *v4 == 34 )
    {
      for ( i = v4 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v6 <= 1022 )
            *((_BYTE *)off_80EE660 + v6++) = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v6 <= 1022 )
          *((_BYTE *)off_80EE660 + v6++) = 34;
      }
      v4 = i + 1;
    }
    else
    {
      if ( v6 <= 1022 )
        *((_BYTE *)off_80EE660 + v6++) = *v4;
      ++v4;
    }
  }
  if ( *v4 )
  {
    if ( *v4 != 10 )
      ++v4;
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
  }
  *((_BYTE *)off_80EE660 + v6) = 0;
  return off_80EE660;
}
// 81621A4: using guessed type int dword_81621A4;
// 81621A8: using guessed type int dword_81621A8;

//----- (08084D4E) --------------------------------------------------------
void *__cdecl sub_8084D4E(char **a1, int a2)
{
  void *v3; // [esp+18h] [ebp-20h]
  signed int j; // [esp+1Ch] [ebp-1Ch]
  signed int n; // [esp+20h] [ebp-18h]
  const char **i; // [esp+24h] [ebp-14h]
  char *v7; // [esp+28h] [ebp-10h]
  char *v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch] BYREF
  int v10; // [esp+30h] [ebp-8h]
  char v11; // [esp+37h] [ebp-1h]

  v11 = 0;
  v9 = 0;
  if ( !a1 )
    Com_Error(0, (char *)&byte_80DD16B);
  v7 = *a1;
  v10 = 0;
  *(_BYTE *)off_80EE660 = 0;
  if ( v7 )
  {
    *((_DWORD *)off_80EE660 + 261) = *((_DWORD *)off_80EE660 + 256);
    *((_DWORD *)off_80EE660 + 262) = *a1;
    if ( *((_DWORD *)off_80EE660 + 259) )
    {
      v3 = sub_8084BD3(a1, a2);
    }
    else
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v7 = sub_8084A3A(v7, &v9);
          if ( !v7 )
          {
            *a1 = 0;
            return off_80EE660;
          }
          if ( v9 && !a2 )
          {
            *a1 = v7;
            return off_80EE660;
          }
          v11 = *v7;
          if ( v11 != 47 || v7[1] != 47 )
            break;
          while ( *v7 && *v7 != 10 )
            ++v7;
        }
        if ( v11 != 47 || v7[1] != 42 )
          break;
        while ( *v7 && (*v7 != 42 || v7[1] != 47) )
        {
          if ( *v7 == 10 )
            ++*((_DWORD *)off_80EE660 + 256);
          ++v7;
        }
        if ( *v7 )
          v7 += 2;
      }
      dword_81621A8 = dword_81621A4;
      dword_81621A4 = (int)v7;
      if ( v11 == 34 )
      {
        v8 = v7 + 1;
        while ( 1 )
        {
          v11 = *v8++;
          if ( v11 == 92 && *v8 == 34 )
          {
            v11 = *v8++;
          }
          else
          {
            if ( v11 == 34 || !v11 )
            {
              *((_BYTE *)off_80EE660 + v10) = 0;
              *a1 = v8;
              return off_80EE660;
            }
            if ( *v8 == 10 )
              ++*((_DWORD *)off_80EE660 + 256);
          }
          if ( v10 <= 1022 )
            *((_BYTE *)off_80EE660 + v10++) = v11;
        }
      }
      if ( *((_DWORD *)off_80EE660 + 258) )
      {
        do
        {
          if ( v10 <= 1022 )
            *((_BYTE *)off_80EE660 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 32 );
        if ( v10 == 1024 )
          v10 = 0;
        *((_BYTE *)off_80EE660 + v10) = 0;
        *a1 = v7;
        v3 = off_80EE660;
      }
      else if ( v11 > 47 && v11 <= 57
             || *((_DWORD *)off_80EE660 + 260) && v11 == 45 && v7[1] > 47 && v7[1] <= 57
             || v11 == 46 && v7[1] > 47 && v7[1] <= 57 )
      {
        do
        {
          if ( v10 <= 1022 )
            *((_BYTE *)off_80EE660 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 47 && v11 <= 57 || v11 == 46 );
        if ( v11 == 101 || v11 == 69 )
        {
          if ( v10 <= 1022 )
            *((_BYTE *)off_80EE660 + v10++) = v11;
          v11 = *++v7;
          if ( v11 == 45 || v11 == 43 )
          {
            if ( v10 <= 1022 )
              *((_BYTE *)off_80EE660 + v10++) = v11;
            v11 = *++v7;
          }
          do
          {
            if ( v10 <= 1022 )
              *((_BYTE *)off_80EE660 + v10++) = v11;
            v11 = *++v7;
          }
          while ( v11 > 47 && v11 <= 57 );
        }
        if ( v10 == 1024 )
          v10 = 0;
        *((_BYTE *)off_80EE660 + v10) = 0;
        *a1 = v7;
        v3 = off_80EE660;
      }
      else if ( v11 > 96 && v11 <= 122 || v11 > 64 && v11 <= 90 || v11 == 95 || v11 == 47 || v11 == 92 )
      {
        do
        {
          if ( v10 <= 1022 )
            *((_BYTE *)off_80EE660 + v10++) = v11;
          v11 = *++v7;
        }
        while ( v11 > 96 && v11 <= 122
             || v11 > 64 && v11 <= 90
             || v11 == 95
             || v11 > 47 && v11 <= 57
             || v11 == 47
             || v11 == 92
             || v11 == 58
             || v11 == 46 );
        if ( v10 == 1024 )
          v10 = 0;
        *((_BYTE *)off_80EE660 + v10) = 0;
        *a1 = v7;
        v3 = off_80EE660;
      }
      else
      {
        for ( i = (const char **)off_80EA060; ; ++i )
        {
          if ( !*i )
          {
            *(_BYTE *)off_80EE660 = *v7;
            *((_BYTE *)off_80EE660 + 1) = 0;
            *a1 = v7 + 1;
            return off_80EE660;
          }
          n = strlen(*i);
          for ( j = 0; j < n && v7[j] == (*i)[j]; ++j )
            ;
          if ( j == n )
            break;
        }
        memcpy(off_80EE660, *i, n);
        *((_BYTE *)off_80EE660 + n) = 0;
        *a1 = &v7[n];
        v3 = off_80EE660;
      }
    }
  }
  else
  {
    *a1 = 0;
    v3 = off_80EE660;
  }
  return v3;
}
// 80EA060: using guessed type char *off_80EA060[14];
// 81621A4: using guessed type int dword_81621A4;
// 81621A8: using guessed type int dword_81621A8;

//----- (08085323) --------------------------------------------------------
void *__cdecl Com_Parse(_DWORD *a1)
{
  if ( *((_DWORD *)off_80EE660 + 257) )
  {
    *((_DWORD *)off_80EE660 + 257) = 0;
    *a1 = *((_DWORD *)off_80EE660 + 262);
    *((_DWORD *)off_80EE660 + 256) = *((_DWORD *)off_80EE660 + 261);
  }
  return sub_8084D4E((char **)a1, 1);
}

//----- (08085382) --------------------------------------------------------
void *__cdecl sub_8085382(char **a1)
{
  if ( !*((_DWORD *)off_80EE660 + 257) )
    return sub_8084D4E(a1, 0);
  *((_DWORD *)off_80EE660 + 257) = 0;
  if ( *((_DWORD *)off_80EE660 + 258) )
  {
    *a1 = (char *)*((_DWORD *)off_80EE660 + 262);
    *((_DWORD *)off_80EE660 + 256) = *((_DWORD *)off_80EE660 + 261);
    return sub_8084D4E(a1, 0);
  }
  return off_80EE660;
}

//----- (080853FF) --------------------------------------------------------
int __cdecl sub_80853FF(int a1, char *s2, int a3)
{
  int result; // eax
  char *s1; // [esp+14h] [ebp-4h]

  s1 = (char *)Com_Parse((_DWORD *)a1);
  result = strcmp(s1, s2);
  if ( result )
  {
    if ( !a3 )
      sub_808488D("MatchToken: %s != %s", s1, s2);
    result = sub_80848F5("MatchToken: %s != %s", s1, s2);
  }
  return result;
}

//----- (080854D2) --------------------------------------------------------
_BYTE *__cdecl sub_80854D2(_DWORD *a1)
{
  _BYTE *result; // eax
  int v2; // [esp+0h] [ebp-8h]
  _BYTE *v3; // [esp+4h] [ebp-4h]

  result = (_BYTE *)*a1;
  v3 = (_BYTE *)*a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = (char)*v3;
      if ( !*v3 )
        break;
      ++v3;
      if ( v2 == 10 )
      {
        ++*((_DWORD *)off_80EE660 + 256);
        break;
      }
    }
    result = v3;
    *a1 = v3;
  }
  return result;
}

//----- (080855FD) --------------------------------------------------------
int __cdecl sub_80855FD(_DWORD *a1, int a2, int a3)
{
  int i; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch]

  sub_80853FF((int)a1, "(", 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = (char *)Com_Parse(a1);
    *(float *)(a3 + 4 * i) = atof(nptr);
  }
  return sub_80853FF((int)a1, ")", 0);
}

//----- (08085683) --------------------------------------------------------
int __cdecl sub_8085683(_DWORD *a1, int a2, int a3, int a4)
{
  int i; // [esp+14h] [ebp-4h]

  sub_80853FF((int)a1, "(", 0);
  for ( i = 0; i < a2; ++i )
    sub_80855FD(a1, a3, a4 + 4 * a3 * i);
  return sub_80853FF((int)a1, ")", 0);
}

//----- (080857F1) --------------------------------------------------------
_BYTE *__cdecl sub_80857F1(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = a1 + 1;
    ++a1;
  }
  return v2;
}

//----- (08085892) --------------------------------------------------------
char *__cdecl sub_8085892(char *s, size_t maxlen, int a3)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest[72]; // [esp+30h] [ebp-48h] BYREF

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  Q_strncpyz(dest, s, 64);
  return (char *)Com_sprintf(s, maxlen, "%s%s", dest, (const char *)a3);
}

//----- (080859B2) --------------------------------------------------------
int __cdecl BigShort(__int16 a1)
{
  return (__int16)dword_8175C40(a1);
}
// 8175C40: using guessed type int (__cdecl *dword_8175C40)(_DWORD);

//----- (08085A6E) --------------------------------------------------------
int __cdecl sub_8085A6E(__int16 a1)
{
  return (__int16)(((unsigned __int8)a1 << 8) + HIBYTE(a1));
}

//----- (08085AA5) --------------------------------------------------------
int __cdecl sub_8085AA5(__int16 a1)
{
  return a1;
}

//----- (08085AB8) --------------------------------------------------------
int __cdecl sub_8085AB8(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + ((unsigned __int8)a1 << 24);
}

//----- (08085B14) --------------------------------------------------------
int __cdecl sub_8085B14(int a1)
{
  return a1;
}

//----- (08085B1C) --------------------------------------------------------
_DWORD *__userpurge sub_8085B1C@<eax>(_DWORD *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  LOBYTE(v4) = HIBYTE(a3);
  BYTE1(v4) = BYTE2(a3);
  BYTE2(v4) = BYTE1(a3);
  HIBYTE(v4) = a3;
  LOBYTE(v5) = HIBYTE(a2);
  BYTE1(v5) = BYTE2(a2);
  BYTE2(v5) = BYTE1(a2);
  HIBYTE(v5) = a2;
  *a1 = v4;
  a1[1] = v5;
  return a1;
}

//----- (08085B7A) --------------------------------------------------------
_DWORD *__userpurge sub_8085B7A@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (08085B9E) --------------------------------------------------------
long double __cdecl sub_8085B9E(int a1)
{
  float v2; // [esp+4h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (08085BD1) --------------------------------------------------------
long double __cdecl sub_8085BD1(float a1)
{
  return a1;
}

//----- (08085BE2) --------------------------------------------------------
void Swap_Init()
{
  dword_8175C40 = (int (__cdecl *)(_DWORD))sub_8085A6E;
  dword_8175C44 = (int)sub_8085AA5;
  dword_8175C48 = (int)sub_8085AB8;
  dword_8175C4C = (int)sub_8085B14;
  dword_8175C50 = (int)sub_8085B1C;
  dword_8175C54 = (int)sub_8085B7A;
  dword_8175C58 = (int)sub_8085B9E;
  dword_8175C5C = (int)sub_8085BD1;
}
// 8175C40: using guessed type int (__cdecl *dword_8175C40)(_DWORD);
// 8175C44: using guessed type int dword_8175C44;
// 8175C48: using guessed type int dword_8175C48;
// 8175C4C: using guessed type int dword_8175C4C;
// 8175C50: using guessed type int dword_8175C50;
// 8175C54: using guessed type int dword_8175C54;
// 8175C58: using guessed type int dword_8175C58;
// 8175C5C: using guessed type int dword_8175C5C;

//----- (08085CC2) --------------------------------------------------------
_BOOL4 __cdecl sub_8085CC2(int a1)
{
  return a1 > 96 && a1 <= 122;
}

//----- (08085D10) --------------------------------------------------------
_BOOL4 __cdecl sub_8085D10(int a1)
{
  return a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90;
}

//----- (08085D45) --------------------------------------------------------
_BOOL4 __cdecl sub_8085D45(int a1)
{
  return a1 > 47 && a1 <= 57;
}

//----- (08085D6C) --------------------------------------------------------
_BOOL4 __cdecl sub_8085D6C(int a1)
{
  return sub_8085D10(a1) || sub_8085D45(a1);
}

//----- (08085E32) --------------------------------------------------------
char *__cdecl Q_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (08085E5E) --------------------------------------------------------
int __cdecl Q_stricmpn(char *a1, char *a2, int a3)
{
  int v4; // [esp+8h] [ebp-10h]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( sub_8085CC2(v7) )
        v7 -= 32;
      if ( sub_8085CC2(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (08085F03) --------------------------------------------------------
int __cdecl Q_strncmp(char *a1, char *a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (08085F72) --------------------------------------------------------
int __cdecl Q_stricmp(char *a1, char *a2)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( a1 && a2 )
    v3 = Q_stricmpn(a1, a2, 99999);
  else
    v3 = -1;
  return v3;
}

//----- (08085FAF) --------------------------------------------------------
_BYTE *__cdecl sub_8085FAF(_BYTE *a1)
{
  _BYTE *i; // [esp+10h] [ebp-8h]

  for ( i = a1; *i; ++i )
    *i = tolower((char)*i);
  return a1;
}

//----- (08085FE9) --------------------------------------------------------
_BYTE *__cdecl sub_8085FE9(_BYTE *a1)
{
  _BYTE *i; // [esp+10h] [ebp-8h]

  for ( i = a1; *i; ++i )
    *i = toupper((char)*i);
  return a1;
}

//----- (08086023) --------------------------------------------------------
char *__cdecl sub_8086023(char *s, int a2, char *src)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = strlen(s);
  if ( v4 >= a2 )
    Com_Error(0, (char *)&byte_80DD2F5);
  return Q_strncpyz(&s[v4], src, a2 - v4);
}

//----- (08086076) --------------------------------------------------------
int __cdecl sub_8086076(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
  {
    if ( a1 && *a1 == 94 && a1[1] && a1[1] != 94 && (char)a1[1] > 47 && (char)a1[1] <= 57 )
    {
      a1 += 2;
    }
    else
    {
      ++v2;
      ++a1;
    }
  }
  return v2;
}

//----- (080860DE) --------------------------------------------------------
char *__cdecl sub_80860DE(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (08086166) --------------------------------------------------------
int __cdecl sub_8086166(char a1)
{
  if ( (unsigned __int8)a1 == 146 )
    return 39;
  if ( a1 >= 0 )
    return a1;
  return 46;
}

//----- (080861A6) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+2Ch] [ebp+14h] BYREF

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (080861E4) --------------------------------------------------------
int __cdecl sub_80861E4(char *a1, char *a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  do
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v6 != v5 )
    {
      if ( sub_8085CC2(v6) )
        v6 -= 32;
      if ( sub_8085CC2(v5) )
        v5 -= 32;
      if ( v6 != v5 )
        return -1;
    }
  }
  while ( v6 );
  return 0;
}

//----- (0808626E) --------------------------------------------------------
int __cdecl Q_strcasecmp(char *a1, char *a2)
{
  return sub_80861E4(a1, a2, 99999);
}

//----- (08086290) --------------------------------------------------------
char *va(char *format, ...)
{
  int v2; // [esp+1Ch] [ebp-Ch]
  char *dest; // [esp+20h] [ebp-8h]
  va_list v4; // [esp+34h] [ebp+Ch] BYREF

  va_start(v4, format);
  v2 = vsnprintf(byte_8162240, 0x7D00u, format, v4);
  byte_8169F3F = 0;
  if ( v2 < 0 || v2 > 31999 )
    Com_Error(1, (char *)&byte_80DD320);
  if ( v2 + dword_80EE664 > 31998 )
    dword_80EE664 = 0;
  dest = (char *)&unk_8169F40 + dword_80EE664;
  memcpy((char *)&unk_8169F40 + dword_80EE664, byte_8162240, v2 + 1);
  dword_80EE664 += v2 + 1;
  return dest;
}
// 80EE664: using guessed type int dword_80EE664;
// 8169F3F: using guessed type char byte_8169F3F;

//----- (08086397) --------------------------------------------------------
void *__cdecl Info_ValueForKey(char *s, int a2)
{
  char *v4; // [esp+1Ch] [ebp-200Ch]
  _BYTE *v5; // [esp+1Ch] [ebp-200Ch]
  char v6[8200]; // [esp+20h] [ebp-2008h] BYREF
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return &unk_80DD34E;
  if ( strlen(s) > 0x1FFF )
    Com_Error(1, (char *)&byte_80DD360);
  dword_80EE668 ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v4 = v6;
    while ( *s != 92 )
    {
      if ( !*s )
        return &unk_80DD34E;
      *v4++ = *s++;
    }
    *v4 = 0;
    sa = s + 1;
    v5 = (char *)&unk_8171C40 + 0x2000 * dword_80EE668;
    while ( *sa != 92 && *sa )
      *v5++ = *sa++;
    *v5 = 0;
    if ( !Q_stricmp((char *)a2, v6) )
      return (void *)((dword_80EE668 << 13) + 135732288);
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return &unk_80DD34E;
}
// 80EE668: using guessed type int dword_80EE668;

//----- (0808659F) --------------------------------------------------------
char *__cdecl sub_808659F(char *s, char *s1)
{
  char *result; // eax
  char *v3; // [esp+1Ch] [ebp-81Ch]
  char *v4; // [esp+1Ch] [ebp-81Ch]
  char v5; // [esp+20h] [ebp-818h] BYREF
  char s2[1036]; // [esp+420h] [ebp-418h] BYREF
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    Com_Error(1, (char *)&byte_80DD3A0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v3 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v3++ = *s++;
      }
      *v3 = 0;
      ++s;
      v4 = &v5;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}

//----- (080866D1) --------------------------------------------------------
char *__cdecl sub_80866D1(char *s, char *s1)
{
  char *result; // eax
  char *v3; // [esp+1Ch] [ebp-401Ch]
  char *v4; // [esp+1Ch] [ebp-401Ch]
  char v5; // [esp+20h] [ebp-4018h] BYREF
  char s2[8204]; // [esp+2020h] [ebp-2018h] BYREF
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    Com_Error(1, (char *)&byte_80DD3E0);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v3 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v3++ = *s++;
      }
      *v3 = 0;
      ++s;
      v4 = &v5;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}

//----- (08086855) --------------------------------------------------------
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // ebx
  char v5; // [esp+4h] [ebp-834h]
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+23h] [ebp-815h]
  int v8; // [esp+28h] [ebp-810h]
  int i; // [esp+2Ch] [ebp-80Ch]
  char v10[1024]; // [esp+30h] [ebp-808h] BYREF
  char src[1032]; // [esp+430h] [ebp-408h] BYREF

  if ( strlen(s) > 0x3FF )
    return (char *)Com_Printf((char *)&byte_80DD420, v5);
  v8 = 0;
  for ( i = 0; i <= 1022; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf((char *)&byte_80DD460, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf((char *)&byte_80DD4A0, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf((char *)&byte_80DD4E0, (char)s1);
  result = sub_808659F(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x400u, "\\%s\\%s", s1, v10) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x400 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf((char *)&byte_80DD580, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf((char *)&byte_80DD520, v6);
    }
  }
  return result;
}
// 8086878: variable 'v5' is possibly undefined
// 8086A1B: variable 'v6' is possibly undefined

//----- (08086A88) --------------------------------------------------------
char *__cdecl sub_8086A88(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // ebx
  char v5; // [esp+4h] [ebp-4034h]
  char v6; // [esp+4h] [ebp-4034h]
  char v7; // [esp+23h] [ebp-4015h]
  int v8; // [esp+28h] [ebp-4010h]
  int i; // [esp+2Ch] [ebp-400Ch]
  char v10[8192]; // [esp+30h] [ebp-4008h] BYREF
  char src[8200]; // [esp+2030h] [ebp-2008h] BYREF

  if ( strlen(s) > 0x1FFF )
    return (char *)Com_Printf((char *)&byte_80DD420, v5);
  v8 = 0;
  for ( i = 0; i <= 8190; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf((char *)&byte_80DD460, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf((char *)&byte_80DD4A0, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf((char *)&byte_80DD4E0, (char)s1);
  result = sub_80866D1(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x2000u, "\\%s\\%s", s1, v10) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x2000 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf((char *)&byte_80DD5E0, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf((char *)&byte_80DD520, v6);
    }
  }
  return result;
}
// 8086AAB: variable 'v5' is possibly undefined
// 8086C4E: variable 'v6' is possibly undefined

//----- (08086EE2) --------------------------------------------------------
long double __cdecl sub_8086EE2(float a1)
{
  return (2.0 - sub_80872E6(a1)) * a1;
}

//----- (08086F1F) --------------------------------------------------------
void __cdecl sub_8086F1F(int a1, int a2, float a3, float a4, float a5)
{
  int v5[4]; // [esp+10h] [ebp-38h] BYREF
  float v6[7]; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    v7 = sub_8086EE2(a3);
    v5[0] = 0;
    v5[1] = a2;
    *(float *)&v5[2] = v7 * a4;
    sub_806759D((float *)v5, 0, v6, 0);
    v7 = v7 * a5;
    *(float *)a1 = v6[0] * v7 + *(float *)a1;
    *(float *)(a1 + 4) = v6[1] * v7 + *(float *)(a1 + 4);
    *(float *)(a1 + 8) = v6[2] * v7 + *(float *)(a1 + 8);
  }
}

//----- (0808725A) --------------------------------------------------------
int sub_808725A()
{
  return 46;
}

//----- (080872E6) --------------------------------------------------------
long double __cdecl sub_80872E6(float a1)
{
  return (float)fabs(a1);
}

//----- (08087300) --------------------------------------------------------
char *sub_8087300()
{
  char v1; // [esp+4h] [ebp-74h]
  int v2; // [esp+1Ch] [ebp-5Ch]
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  char v4[4]; // [esp+64h] [ebp-14h]
  int v5; // [esp+68h] [ebp-10h]
  char *v6; // [esp+6Ch] [ebp-Ch]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return 0;
  if ( Cmd_Argc() > 1 )
  {
    *(_DWORD *)v4 = Cmd_Argv(1u);
    v5 = 0;
    v6 = (char *)dword_83CCD90;
    while ( v5 < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *(_DWORD *)v6 )
      {
        if ( !Q_stricmp(v6 + 68164, *(char **)v4) )
          return v6;
        Q_strncpyz(dest, v6 + 68164, 64);
        sub_80860DE(dest);
        if ( !Q_stricmp(dest, *(char **)v4) )
          return v6;
      }
      ++v5;
      v6 += 371124;
    }
    Com_Printf("Player %s is not on the server\n", v4[0]);
    v2 = 0;
  }
  else
  {
    Com_Printf("No player specified.\n", v1);
    v2 = 0;
  }
  return (char *)v2;
}
// 808732E: variable 'v1' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 836B804: using guessed type int dword_836B804;

//----- (08087417) --------------------------------------------------------
char *SV_GetPlayerByNum()
{
  char v1; // [esp+4h] [ebp-24h]
  char *v2; // [esp+14h] [ebp-14h]
  const char *nptr; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return 0;
  if ( Cmd_Argc() > 1 )
  {
    nptr = Cmd_Argv(1u);
    for ( i = 0; nptr[i]; ++i )
    {
      if ( nptr[i] <= 47 || nptr[i] > 57 )
      {
        Com_Printf("Bad slot number: %s\n", (char)nptr);
        return 0;
      }
    }
    v4 = atoi(nptr);
    if ( v4 >= 0 && v4 < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *((_DWORD *)dword_83CCD90 + 92781 * v4) )
      {
        v2 = (char *)dword_83CCD90 + 371124 * v4;
      }
      else
      {
        Com_Printf("Client %i is not active\n", v4);
        v2 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v4);
      v2 = 0;
    }
  }
  else
  {
    Com_Printf("No player specified.\n", v1);
    v2 = 0;
  }
  return v2;
}
// 8087445: variable 'v1' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 836B804: using guessed type int dword_836B804;

//----- (08087538) --------------------------------------------------------
char *__cdecl sub_8087538(char *s)
{
  size_t n; // [esp+1Ch] [ebp-4Ch]
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  if ( !Q_stricmpn(s, "mp", 2) && (s[2] == 47 || s[2] == 92) )
    s += 3;
  n = strlen(s);
  if ( !strcmp(&s[n - 4], ".bsp") )
    n -= 4;
  memcpy(dest, s, n);
  dest[n] = 0;
  return va("%s", dest);
}

//----- (080875E1) --------------------------------------------------------
char *sub_80875E1()
{
  char *result; // eax
  _BOOL4 v1; // [esp+1Ch] [ebp-5Ch]
  char dest[64]; // [esp+20h] [ebp-58h] BYREF
  char *haystack; // [esp+60h] [ebp-18h]
  char *s1; // [esp+64h] [ebp-14h]
  char *s; // [esp+68h] [ebp-10h]
  char *v6; // [esp+6Ch] [ebp-Ch]

  result = Cmd_Argv(1u);
  s = result;
  if ( *result )
  {
    s1 = sub_8087538(s);
    haystack = va("maps/mp/%s.bsp", s1);
    if ( FS_ReadFile(haystack, 0) == -1 )
    {
      result = (char *)Com_Printf("Can't find map %s\n", (char)haystack);
    }
    else
    {
      v6 = Cmd_Argv(0);
      v1 = Q_stricmp(v6, "devmap") == 0;
      if ( *(_DWORD *)(dword_8360560 + 32) && *(float *)(dword_835F4B4 + 28) <= 0.0 )
        sub_807317F("timescale", 1.0);
      if ( *(_DWORD *)(dword_8360560 + 32) && !strcasecmp(s1, *(const char **)(dword_836B7E8 + 4)) )
      {
        SV_MapRestart_f();
      }
      else
      {
        Q_strncpyz(dest, s1, 64);
        SV_SpawnServer(dest);
      }
      if ( v1 )
        result = (char *)Cvar_Set("sv_cheats", "1");
      else
        result = (char *)Cvar_Set("sv_cheats", "0");
    }
  }
  return result;
}
// 835F4B4: using guessed type int dword_835F4B4;
// 8360560: using guessed type int dword_8360560;
// 836B7E8: using guessed type int dword_836B7E8;

//----- (0808773A) --------------------------------------------------------
int *SV_MapRestart_f()
{
  int *result; // eax
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char v4; // [esp+4h] [ebp-74h]
  char v5; // [esp+4h] [ebp-74h]
  int v6; // [esp+1Ch] [ebp-5Ch]
  int dest; // [esp+20h] [ebp-58h] BYREF
  int v8; // [esp+64h] [ebp-14h]
  int v9; // [esp+68h] [ebp-10h]
  int v10[3]; // [esp+6Ch] [ebp-Ch]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return (int *)Com_Printf("Server is not running.\n", v4);
  if ( *(float *)(dword_835F4B4 + 28) <= 0.0 )
    sub_807317F("timescale", 1.0);
  Cvar_Get("g_gametype", "dm", 36);
  v6 = VM_Call((int)gvm, 18);
  if ( v6 )
  {
    Cvar_Set("g_gametype", byte_83CCD0C);
  }
  else
  {
    if ( strcasecmp(byte_83CCD0C, *(const char **)(dword_83CCD68 + 4)) )
    {
      Com_Printf("g_gametype variable change -- restarting.\n", v5);
      v1 = (char *)Cvar_VariableString((int)"mapname");
      Q_strncpyz((char *)&dest, v1, 64);
      return (int *)SV_SpawnServer((char *)&dest);
    }
    if ( *(_DWORD *)(dword_836B804 + 20) )
    {
      Com_Printf("sv_maxclients variable change -- restarting.\n", v5);
      v2 = (char *)Cvar_VariableString((int)"mapname");
      Q_strncpyz((char *)&dest, v2, 64);
      return (int *)SV_SpawnServer((char *)&dest);
    }
  }
  result = (int *)dword_835F4BC;
  if ( dword_835F4BC != dword_836B828 )
  {
    SV_InitCvar();
    SV_InitArchivedSnapshot();
    sv_serverId_value ^= 4u;
    *(_DWORD *)dword_80EE800 = ((dword_80EE800[0] + 1) & 0xF) + (dword_80EE800[0] & 0xF0);
    v3 = va("%i", *(_DWORD *)dword_80EE800);
    Cvar_Set("sv_serverid", v3);
    dword_836B828 = dword_835F4BC;
    sv = 1;
    dword_836B824 = 1;
    Cvar_Set("sv_serverRestarting", "1");
    XAnimSetUser(1);
    SV_RestartGameProgs();
    for ( v10[0] = 0; v10[0] <= 2; ++v10[0] )
    {
      dword_83CCD88 += 100;
      dword_83CCD84 += 100;
      SV_RunFrame();
    }
    for ( v10[0] = 0; v10[0] < *(_DWORD *)(dword_836B804 + 32); ++v10[0] )
    {
      v9 = (int)dword_83CCD90 + 371124 * v10[0];
      if ( *(int *)v9 > 1 )
      {
        if ( v6 )
          SV_AddServerCommand(v9, 1, "n");
        else
          SV_AddServerCommand(v9, 1, "B");
        v8 = VM_Call((int)gvm, 4);
        if ( v8 )
        {
          SV_DropClient(v9, v8);
          Com_Printf("SV_MapRestart_f: dropped client %i - denied!\n", v10[0]);
        }
        else if ( *(_DWORD *)v9 == 4 )
        {
          SV_ClientEnterWorld((char *)v9, (_DWORD *)(v9 + 67108));
        }
      }
    }
    sv = 2;
    dword_836B824 = 0;
    result = Cvar_Set("sv_serverRestarting", "0");
  }
  return result;
}
// 8087752: variable 'v4' is possibly undefined
// 80877F9: variable 'v5' is possibly undefined
// 835F4B4: using guessed type int dword_835F4B4;
// 835F4BC: using guessed type int dword_835F4BC;
// 8360560: using guessed type int dword_8360560;
// 836B804: using guessed type int dword_836B804;
// 836B820: using guessed type int sv;
// 836B824: using guessed type int dword_836B824;
// 836B828: using guessed type int dword_836B828;
// 83CCD68: using guessed type int dword_83CCD68;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCD8C: using guessed type int sv_serverId_value;

//----- (08087A6A) --------------------------------------------------------
void *UI_GetMapRotationToken()
{
  void *v0; // esp
  void *v2; // [esp+8h] [ebp-10h] BYREF
  void *v3; // [esp+Ch] [ebp-Ch]
  char *dest; // [esp+10h] [ebp-8h]
  char *s; // [esp+14h] [ebp-4h] BYREF

  s = *(char **)(dword_836B7C4 + 4);
  v3 = Com_Parse(&s);
  if ( s )
  {
    v0 = alloca(16 * ((strlen(s) + 16) >> 4));
    dest = (char *)&v2;
    strcpy((char *)&v2, s);
    Cvar_Set("sv_mapRotationCurrent", dest);
    v2 = v3;
  }
  else
  {
    Cvar_Set("sv_mapRotationCurrent", (char *)&byte_80DD84E);
    v2 = 0;
  }
  return v2;
}
// 836B7C4: using guessed type int dword_836B7C4;

//----- (08087AFA) --------------------------------------------------------
void sub_8087AFA()
{
  char *v0; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  char v4; // [esp+4h] [ebp-14h]
  char *s1; // [esp+14h] [ebp-4h]
  char *s1a; // [esp+14h] [ebp-4h]
  char *s1b; // [esp+14h] [ebp-4h]

  Com_Printf("map_rotate...\n\n", v1);
  Com_Printf("\"sv_mapRotation\" is:\"%s\"\n\n", *(_DWORD *)(dword_836B7E0 + 4));
  Com_Printf("\"sv_mapRotationCurrent\" is:\"%s\"\n\n", *(_DWORD *)(dword_836B7C4 + 4));
  if ( !**(_BYTE **)(dword_836B7C4 + 4) )
    Cvar_Set("sv_mapRotationCurrent", *(char **)(dword_836B7E0 + 4));
  s1 = (char *)UI_GetMapRotationToken();
  if ( !s1 )
  {
    Cvar_Set("sv_mapRotationCurrent", *(char **)(dword_836B7E0 + 4));
    s1 = (char *)UI_GetMapRotationToken();
  }
  while ( 1 )
  {
    if ( !s1 )
    {
      Com_Printf("No map specified in sv_mapRotation - forcing map_restart.\n", v2);
      SV_MapRestart_f();
      return;
    }
    if ( strcasecmp(s1, "gametype") )
      break;
    s1a = (char *)UI_GetMapRotationToken();
    if ( !s1a )
    {
      Com_Printf("No gametype specified after 'gametype' keyword in sv_mapRotation - forcing map_restart.\n", v3);
      SV_MapRestart_f();
      return;
    }
    Com_Printf("Setting g_gametype: %s.\n", (char)s1a);
    if ( *(_DWORD *)(dword_8360560 + 32) )
    {
      if ( strcasecmp(*(const char **)(dword_83CCD68 + 4), s1a) )
        VM_Call((int)gvm, 17);
    }
    Cvar_Set("g_gametype", s1a);
LABEL_19:
    s1 = (char *)UI_GetMapRotationToken();
  }
  if ( strcasecmp(s1, "map") )
  {
    Com_Printf("Unknown keyword '%s' in sv_mapRotation.\n", (char)s1);
    goto LABEL_19;
  }
  s1b = (char *)UI_GetMapRotationToken();
  if ( s1b )
  {
    Com_Printf("Setting map: %s.\n", (char)s1b);
    v0 = va("map %s\n", s1b);
    Cbuf_ExecuteText(0, v0);
  }
  else
  {
    Com_Printf("No map specified after 'map' keyword in sv_mapRotation - forcing map_restart.\n", v4);
    SV_MapRestart_f();
  }
}
// 8087B07: variable 'v1' is possibly undefined
// 8087B9D: variable 'v2' is possibly undefined
// 8087BDC: variable 'v3' is possibly undefined
// 8087C85: variable 'v4' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 836B7C4: using guessed type int dword_836B7C4;
// 836B7E0: using guessed type int dword_836B7E0;
// 83CCD68: using guessed type int dword_83CCD68;

//----- (08087CEB) --------------------------------------------------------
int __cdecl sub_8087CEB(int a1, char *dest, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(a1 + 338248) == 2 )
  {
    SV_SendServerCommand(0, 0, "e \"EXE_CANNOTKICKHOSTPLAYER\"");
    v4 = 0;
  }
  else
  {
    if ( dest )
    {
      Q_strncpyz(dest, (char *)(a1 + 68164), a3);
      sub_80860DE(dest);
    }
    v5 = *(_DWORD *)(a1 + 371072);
    SV_DropClient(a1, (int)"EXE_PLAYERKICKED");
    *(_DWORD *)(a1 + 68636) = dword_83CCD88;
    v4 = v5;
  }
  return v4;
}
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08087D89) --------------------------------------------------------
int __cdecl sub_8087D89(char *dest, int a2)
{
  char *v2; // eax
  char v4; // [esp+4h] [ebp-24h]
  char v5; // [esp+8h] [ebp-20h]
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  char *v8; // [esp+20h] [ebp-8h]
  _DWORD *v9; // [esp+20h] [ebp-8h]

  if ( *(_DWORD *)(dword_8360560 + 32) )
  {
    if ( Cmd_Argc() == 2 )
    {
      v8 = sub_8087300();
      if ( v8 )
      {
        v6 = sub_8087CEB((int)v8, dest, a2);
      }
      else
      {
        v2 = Cmd_Argv(1u);
        if ( !Q_stricmp(v2, "all") )
        {
          v7 = 0;
          v9 = dword_83CCD90;
          while ( v7 < *(_DWORD *)(dword_836B804 + 32) )
          {
            if ( *v9 )
              sub_8087CEB((int)v9, 0, 0);
            ++v7;
            v9 += 92781;
          }
        }
        v6 = 0;
      }
    }
    else
    {
      v5 = (unsigned __int8)Cmd_Argv(0);
      Com_Printf("Usage: %s <player name>\n%s all = kick everyone\n", v5);
      v6 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n", v4);
    v6 = 0;
  }
  return v6;
}
// 8087DA1: variable 'v4' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 836B804: using guessed type int dword_836B804;

//----- (08087E9D) --------------------------------------------------------
int __cdecl sub_8087E9D(char *dest, int a2)
{
  char v2; // al
  char v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+10h] [ebp-8h]
  char *v6; // [esp+14h] [ebp-4h]

  if ( *(_DWORD *)(dword_8360560 + 32) )
  {
    if ( Cmd_Argc() == 2 )
    {
      v6 = SV_GetPlayerByNum();
      if ( v6 )
        v5 = sub_8087CEB((int)v6, dest, a2);
      else
        v5 = 0;
    }
    else
    {
      v2 = (unsigned __int8)Cmd_Argv(0);
      Com_Printf("Usage: %s <client number>\n", v2);
      v5 = 0;
    }
  }
  else
  {
    Com_Printf("Server is not running.\n", v4);
    v5 = 0;
  }
  return v5;
}
// 8087EB5: variable 'v4' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (08087F2A) --------------------------------------------------------
int sub_8087F2A()
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v2; // [esp+5Ch] [ebp-Ch]

  result = sub_8087D89(dest, 64);
  v2 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", (char)dest);
    result = sub_80890F5(v2);
  }
  return result;
}
// 8087F2A: using guessed type int sub_8087F2A();

//----- (08087F73) --------------------------------------------------------
char *sub_8087F73()
{
  char *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return (char *)Com_Printf("Server is not running.\n", v1);
  if ( Cmd_Argc() != 2 )
    return (char *)Com_Printf("Usage: banUser <player name>\n", v1);
  result = sub_8087300();
  if ( result )
    result = (char *)sub_8089121((int)result);
  return result;
}
// 8087F8B: variable 'v1' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (08087FC7) --------------------------------------------------------
char *sub_8087FC7()
{
  char *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return (char *)Com_Printf("Server is not running.\n", v1);
  if ( Cmd_Argc() != 2 )
    return (char *)Com_Printf("Usage: banClient <client number>\n", v1);
  result = SV_GetPlayerByNum();
  if ( result )
    result = (char *)sub_8089121((int)result);
  return result;
}
// 8087FDF: variable 'v1' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (0808801B) --------------------------------------------------------
int sub_808801B()
{
  char *v1; // eax
  char v2; // [esp+4h] [ebp-4h]

  if ( Cmd_Argc() != 2 )
    return Com_Printf("Usage: unban <client name>\n", v2);
  v1 = Cmd_Argv(1u);
  return sub_808921D(v1);
}
// 8088032: variable 'v2' is possibly undefined
// 808801B: using guessed type int sub_808801B();

//----- (0808804F) --------------------------------------------------------
int sub_808804F()
{
  return sub_8087D89(0, 0);
}
// 808804F: using guessed type int sub_808804F();

//----- (0808806B) --------------------------------------------------------
int sub_808806B()
{
  return sub_8087E9D(0, 0);
}
// 808806B: using guessed type int sub_808806B();

//----- (08088087) --------------------------------------------------------
int sub_8088087()
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v2; // [esp+5Ch] [ebp-Ch]

  result = sub_8087E9D(dest, 64);
  v2 = result;
  if ( result )
  {
    Com_Printf("%s (guid %i) was kicked for cheating\n", (char)dest);
    result = sub_80890F5(v2);
  }
  return result;
}
// 8088087: using guessed type int sub_8088087();

//----- (080880D0) --------------------------------------------------------
int sub_80880D0()
{
  char v1; // al
  char v2; // [esp+4h] [ebp-34h]
  char v3; // [esp+4h] [ebp-34h]
  char v4; // [esp+4h] [ebp-34h]
  char v5; // [esp+4h] [ebp-34h]
  char v6; // [esp+4h] [ebp-34h]
  char v7; // [esp+4h] [ebp-34h]
  char v8; // [esp+4h] [ebp-34h]
  char v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+18h] [ebp-20h]
  const char *s; // [esp+20h] [ebp-18h]
  _DWORD *v12; // [esp+28h] [ebp-10h]
  int v13; // [esp+2Ch] [ebp-Ch]
  signed int v14; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  signed int j; // [esp+30h] [ebp-8h]
  int v17; // [esp+34h] [ebp-4h]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return Com_Printf("Server is not running.\n", v2);
  Com_Printf("map: %s\n", *(_DWORD *)(dword_836B7E8 + 4));
  Com_Printf("num score ping guid   name            lastmsg address               qport rate\n", v3);
  Com_Printf("--- ----- ---- ------ --------------- ------- --------------------- ----- -----\n", v4);
  v17 = 0;
  v12 = dword_83CCD90;
  while ( v17 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *v12 )
    {
      Com_Printf("%3i ", v17);
      SV_GameClientNum(v17);
      v1 = SV_GetClientScore();
      Com_Printf("%5i ", v1);
      if ( *v12 == 2 )
      {
        Com_Printf("CNCT ", v6);
      }
      else if ( *v12 == 1 )
      {
        Com_Printf("ZMBI ", v6);
      }
      else
      {
        v10 = v12[84556];
        if ( v10 > 9999 )
          LOBYTE(v10) = 15;
        Com_Printf("%4i ", v10);
      }
      Com_Printf("%6i ", v12[92768]);
      Com_Printf("%s^7", (_BYTE)v12 + 68);
      v13 = 16 - sub_8086076((_BYTE *)v12 + 68164);
      for ( i = 0; i < v13; ++i )
        Com_Printf(" ", v7);
      Com_Printf("%7i ", dword_83CCD88 - v12[17159]);
      s = NET_AdrToString(v12[84562], v12[84563], v12[84564], v12[84565], v12[84566]);
      Com_Printf("%s", (char)s);
      v14 = 22 - strlen(s);
      for ( j = 0; j < v14; ++j )
        Com_Printf(" ", v8);
      Com_Printf("%5i", v12[84567]);
      Com_Printf(" %5i", v12[84557]);
      Com_Printf("\n", v9);
    }
    ++v17;
    v12 += 92781;
  }
  return Com_Printf("\n", v5);
}
// 80880E8: variable 'v2' is possibly undefined
// 8088111: variable 'v3' is possibly undefined
// 808811D: variable 'v4' is possibly undefined
// 808819C: variable 'v6' is possibly undefined
// 8088253: variable 'v7' is possibly undefined
// 80882FD: variable 'v8' is possibly undefined
// 8088342: variable 'v9' is possibly undefined
// 8088361: variable 'v5' is possibly undefined
// 80880D0: using guessed type int sub_80880D0();
// 8360560: using guessed type int dword_8360560;
// 836B7E8: using guessed type int dword_836B7E8;
// 836B804: using guessed type int dword_836B804;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08088368) --------------------------------------------------------
int sub_8088368()
{
  int result; // eax
  size_t v1; // eax
  char v2; // [esp+4h] [ebp-424h]
  char dest[1036]; // [esp+10h] [ebp-418h] BYREF
  char *s; // [esp+41Ch] [ebp-Ch]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return Com_Printf("Server is not running.\n", v2);
  result = Cmd_Argc();
  if ( result > 1 )
  {
    strcpy(dest, "console: ");
    s = sub_806014B(1);
    if ( *s == 34 )
    {
      v1 = strlen(++s);
      s[v1 - 1] = 0;
    }
    strcat(dest, s);
    result = SV_SendServerCommand(0, 0, asc_80DDCB2, dest);
  }
  return result;
}
// 8088383: variable 'v2' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (0808841A) --------------------------------------------------------
int sub_808841A()
{
  int result; // eax
  char *v1; // eax
  size_t v2; // eax
  char v3; // [esp+4h] [ebp-434h]
  _DWORD *v4; // [esp+1Ch] [ebp-41Ch]
  char dest[1036]; // [esp+20h] [ebp-418h] BYREF
  char *s; // [esp+42Ch] [ebp-Ch]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return Com_Printf("Server is not running.\n", v3);
  result = Cmd_Argc();
  if ( result > 2 )
  {
    v1 = Cmd_Argv(1u);
    result = atoi(v1);
    if ( result >= 0 && result < *(_DWORD *)(dword_836B804 + 32) )
    {
      v4 = (char *)dword_83CCD90 + 371124 * result;
      result = (int)v4;
      if ( *v4 == 4 )
      {
        strcpy(dest, "console: ");
        s = sub_806014B(2);
        if ( *s == 34 )
        {
          v2 = strlen(++s);
          s[v2 - 1] = 0;
        }
        strcat(dest, s);
        result = SV_SendServerCommand((int)v4, 0, asc_80DDCB2, dest);
      }
    }
  }
  return result;
}
// 8088435: variable 'v3' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 836B804: using guessed type int dword_836B804;

//----- (08088535) --------------------------------------------------------
void SV_Heartbeat_f()
{
  dword_83CCDD8 = 0x80000000;
}
// 83CCDD8: using guessed type int dword_83CCDD8;

//----- (08088544) --------------------------------------------------------
int SV_Serverinfo_f()
{
  char *v0; // eax
  char v2; // [esp+4h] [ebp-4h]

  Com_Printf("Server info settings:\n", v2);
  v0 = Cvar_InfoString(8196);
  return Info_Print(v0);
}
// 8088551: variable 'v2' is possibly undefined

//----- (0808856C) --------------------------------------------------------
int sub_808856C()
{
  char *v0; // eax
  char v2; // [esp+4h] [ebp-4h]

  Com_Printf("System info settings:\n", v2);
  v0 = Cvar_InfoString(8);
  return Info_Print(v0);
}
// 8088579: variable 'v2' is possibly undefined
// 808856C: using guessed type int sub_808856C();

//----- (08088594) --------------------------------------------------------
char *sub_8088594()
{
  char *result; // eax
  char v1; // [esp+4h] [ebp-4h]
  char v2; // [esp+4h] [ebp-4h]
  int v3; // [esp+4h] [ebp-4h]

  if ( !*(_DWORD *)(dword_8360560 + 32) )
    return (char *)Com_Printf("Server is not running.\n", v1);
  if ( Cmd_Argc() != 2 )
    return (char *)Com_Printf("Usage: info <userid>\n", v1);
  result = sub_8087300();
  if ( result )
  {
    Com_Printf("userinfo\n", (char)result);
    Com_Printf("--------\n", v2);
    result = (char *)Info_Print((char *)(v3 + 12));
  }
  return result;
}
// 80885AC: variable 'v1' is possibly undefined
// 80885EE: variable 'v2' is possibly undefined
// 80885F9: variable 'v3' is possibly undefined
// 8360560: using guessed type int dword_8360560;

//----- (08088603) --------------------------------------------------------
void sub_8088603()
{
  sub_806FCC4("EXE_SERVERKILLED");
}

//----- (08088617) --------------------------------------------------------
void sub_8088617()
{
  sub_80923A2();
}

//----- (08088624) --------------------------------------------------------
int sub_8088624()
{
  return Scr_DumpScriptThreads();
}
// 8088624: using guessed type int sub_8088624();

//----- (08088631) --------------------------------------------------------
int sub_8088631()
{
  return sub_80A161C();
}
// 8088631: using guessed type int sub_8088631();

//----- (0808863E) --------------------------------------------------------
int *sub_808863E()
{
  int *result; // eax
  char *s1; // [esp+10h] [ebp-8h]
  unsigned __int8 v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 2 )
  {
    s1 = Cmd_Argv(1u);
    Cvar_Set("scr_drawfriend", s1);
    result = Cvar_Set("ui_drawfriend", s1);
  }
  else
  {
    v2 = (unsigned __int8)Cmd_Argv(0);
    result = (int *)Com_Printf("Usage: %s <integer>\n", v2);
  }
  return result;
}

//----- (080886A9) --------------------------------------------------------
int *sub_80886A9()
{
  int *result; // eax
  char *s1; // [esp+10h] [ebp-8h]
  unsigned __int8 v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 1 )
  {
    v2 = (unsigned __int8)Cmd_Argv(0);
    result = (int *)Com_Printf("Usage: %s <integer>\n", v2);
  }
  else
  {
    s1 = Cmd_Argv(1u);
    Cvar_Set("scr_friendlyfire", s1);
    result = Cvar_Set("ui_friendlyfire", s1);
  }
  return result;
}

//----- (08088714) --------------------------------------------------------
int *sub_8088714()
{
  int *result; // eax
  char *s1; // [esp+10h] [ebp-8h]
  unsigned __int8 v2; // [esp+14h] [ebp-4h]

  if ( Cmd_Argc() == 1 )
  {
    v2 = (unsigned __int8)Cmd_Argv(0);
    result = (int *)Com_Printf("Usage: %s <integer>\n", v2);
  }
  else
  {
    s1 = Cmd_Argv(1u);
    Cvar_Set("scr_killcam", s1);
    result = Cvar_Set("ui_killcam", s1);
  }
  return result;
}

//----- (0808877F) --------------------------------------------------------
_DWORD *sub_808877F()
{
  _DWORD *result; // eax

  if ( !dword_8175C60 )
  {
    dword_8175C60 = 1;
    sub_806043E("heartbeat", (int)SV_Heartbeat_f);
    sub_806043E("kick", (int)sub_808804F);
    sub_806043E("banUser", (int)sub_8087F73);
    sub_806043E("banClient", (int)sub_8087FC7);
    sub_806043E("tempBanUser", (int)sub_8087F2A);
    sub_806043E("tempBanClient", (int)sub_8088087);
    sub_806043E("unbanUser", (int)sub_808801B);
    sub_806043E("clientkick", (int)sub_808806B);
    sub_806043E("status", (int)sub_80880D0);
    sub_806043E("serverinfo", (int)SV_Serverinfo_f);
    sub_806043E("systeminfo", (int)sub_808856C);
    sub_806043E("dumpuser", (int)sub_8088594);
    sub_806043E("map_restart", (int)SV_MapRestart_f);
    sub_806043E("map", (int)sub_80875E1);
    sub_806043E("map_rotate", (int)sub_8087AFA);
    sub_806043E("gameCompleteStatus", (int)sub_8088617);
    sub_806043E("devmap", (int)sub_80875E1);
    sub_806043E("killserver", (int)sub_8088603);
    if ( *(_DWORD *)(dword_835F480 + 32) )
      sub_8088980();
    sub_806043E("scriptUsage", (int)sub_8088624);
    sub_806043E("stringUsage", (int)sub_8088631);
    sub_806043E("setdrawfriend", (int)sub_808863E);
    sub_806043E("setfriendlyfire", (int)sub_80886A9);
    result = sub_806043E("setkillcam", (int)sub_8088714);
  }
  return result;
}
// 8087F2A: using guessed type int sub_8087F2A();
// 808801B: using guessed type int sub_808801B();
// 808804F: using guessed type int sub_808804F();
// 808806B: using guessed type int sub_808806B();
// 8088087: using guessed type int sub_8088087();
// 80880D0: using guessed type int sub_80880D0();
// 808856C: using guessed type int sub_808856C();
// 8088624: using guessed type int sub_8088624();
// 8088631: using guessed type int sub_8088631();
// 8175C60: using guessed type int dword_8175C60;
// 835F480: using guessed type int dword_835F480;

//----- (0808897B) --------------------------------------------------------
void sub_808897B()
{
  ;
}

//----- (08088980) --------------------------------------------------------
_DWORD *sub_8088980()
{
  sub_806043E("say", (int)sub_8088368);
  return sub_806043E("tell", (int)sub_808841A);
}

//----- (080889D0) --------------------------------------------------------
void __cdecl SV_GetChallenge(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int *v6; // eax
  char v7; // [esp+4h] [ebp-44h]
  int *v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v10 = 0;
  v9 = 0x7FFFFFFF;
  v8 = dword_83CCDE0;
  for ( i = 0; i <= 1023 && (v8[10] || !NET_CompareAdr(a1, a2, a3, a4, a5, *v8, v8[1], v8[2], v8[3], v8[4])); ++i )
  {
    if ( v8[6] < v9 )
    {
      v9 = v8[6];
      v10 = i;
    }
    v8 += 21;
  }
  if ( i == 1024 )
  {
    v8 = (int *)(84 * v10 + 138202592);
    v5 = rand() << 16;
    dword_83CCDF4[21 * v10] = dword_83CCD84 ^ v5 ^ rand();
    *v8 = a1;
    v8[1] = a2;
    v8[2] = a3;
    v8[3] = a4;
    v8[4] = a5;
    v8[8] = dword_83CCD88;
    v8[9] = 0;
    v8[6] = dword_83CCD88;
    v8[10] = 0;
    i = v10;
  }
  if ( *(_DWORD *)(dword_8360800 + 32) || !Sys_IsLANAddress(a1, a2) )
  {
    if ( !(_BYTE)dword_83E1DF8 && dword_83E1DF4 != 1 )
    {
      Com_Printf("Resolving %s\n", (char)"codauthorize.activision.com");
      if ( !NET_StringToAdr("codauthorize.activision.com", &dword_83E1DF4) )
      {
        Com_Printf("Couldn't resolve address\n", v7);
        return;
      }
      word_83E1E06 = BigShort(20500);
      BigShort(word_83E1E06);
      Com_Printf("%s resolved to %i.%i.%i.%i:%i\n", (char)"codauthorize.activision.com");
    }
    if ( dword_83CCD88 - v8[8] <= 5000
      || (v6 = SV_MasterAddress(), NET_CompareAdr(a1, a2, a3, a4, a5, *v6, v6[1], v6[2], v6[3], v6[4])) )
    {
      sub_8088E3B(a1, a2, a3, a4, a5, dword_83CCDF4[21 * i]);
    }
    else
    {
      Com_DPrintf("authorize server timed out\n");
      v8[7] = dword_83CCD88;
      if ( *(_DWORD *)(dword_83CCD64 + 32) )
        NET_OutOfBandPrint(
          1,
          *v8,
          v8[1],
          v8[2],
          v8[3],
          v8[4],
          "challengeResponse %i %i",
          v8[5],
          *(_DWORD *)(dword_83CCD64 + 32));
      else
        NET_OutOfBandPrint(1, *v8, v8[1], v8[2], v8[3], v8[4], "challengeResponse %i", v8[5]);
    }
  }
  else
  {
    v8[7] = dword_83CCD88;
    if ( *(_DWORD *)(dword_83CCD64 + 32) )
      NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "challengeResponse %i %i", v8[5], *(_DWORD *)(dword_83CCD64 + 32));
    else
      NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "challengeResponse %i", v8[5]);
  }
}
// 8088C55: variable 'v7' is possibly undefined
// 8360800: using guessed type int dword_8360800;
// 83CCD64: using guessed type int dword_83CCD64;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCDE0: using guessed type int dword_83CCDE0[];
// 83CCDF4: using guessed type int dword_83CCDF4[];
// 83E1E06: using guessed type __int16 word_83E1E06;

//----- (08088E3B) --------------------------------------------------------
void __cdecl sub_8088E3B(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char *v6; // eax
  char dest[1036]; // [esp+40h] [ebp-418h] BYREF
  int *v8; // [esp+44Ch] [ebp-Ch]

  if ( dword_83E1DF4 != 1 )
  {
    dest[0] = 0;
    v8 = Cvar_Get("fs_game", (char *)&byte_80DDF5B, 24);
    if ( v8 )
    {
      if ( *(_BYTE *)v8[1] )
        strcpy(dest, (const char *)v8[1]);
    }
    v6 = NET_AdrToString(a1, a2, a3, a4, a5);
    Com_DPrintf("sending getIpAuthorize for %s\n", v6);
    v8 = Cvar_Get("sv_allowAnonymous", "0", 4);
    NET_OutOfBandPrint(
      1,
      dword_83E1DF4,
      dword_83E1DF8,
      *(int *)dword_83E1DFC,
      dword_83E1E00,
      unk_83E1E04,
      "getIpAuthorize %i %i.%i.%i.%i %s %i",
      a6,
      (unsigned __int8)a2,
      BYTE1(a2),
      BYTE2(a2),
      HIBYTE(a2),
      dest,
      v8[8]);
  }
}

//----- (08088F75) --------------------------------------------------------
int __cdecl sub_8088F75(int a1)
{
  unsigned int i; // [esp+4h] [ebp-4h]

  if ( !a1 )
    return 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( dword_83E1E0C[2 * i] == a1
      && (long double)(dword_83CCD84 - dword_83E1E10[2 * i]) <= *(float *)(dword_836B7C8 + 28) * 1000.0 )
    {
      return 1;
    }
  }
  return 0;
}
// 836B7C8: using guessed type int dword_836B7C8;
// 83CCD84: using guessed type int dword_83CCD84;
// 83E1E0C: using guessed type int dword_83E1E0C[];

//----- (08088FF8) --------------------------------------------------------
int __cdecl sub_8088FF8(int a1)
{
  int v3; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h] BYREF
  int v6; // [esp+24h] [ebp-4h] BYREF

  if ( !a1 )
    return 0;
  if ( (FS_ReadFile("ban.txt", (int)&v6) & 0x80000000) != 0 )
    return 0;
  v5 = v6;
  v3 = 0;
  while ( 1 )
  {
    nptr = (char *)Com_Parse(&v5);
    if ( !*nptr )
      break;
    if ( atoi(nptr) == a1 )
    {
      v3 = 1;
      break;
    }
    sub_80854D2(&v5);
  }
  FS_FreeFile((void *)v6);
  return v3;
}

//----- (08089096) --------------------------------------------------------
unsigned int sub_8089096()
{
  unsigned int v2; // [esp+4h] [ebp-8h]
  unsigned int i; // [esp+8h] [ebp-4h]

  v2 = 0;
  for ( i = 0; i <= 0xF; ++i )
  {
    if ( !dword_83E1E0C[2 * i] )
      return i;
    if ( dword_83E1E10[2 * i] < dword_83E1E10[2 * v2] )
      v2 = i;
  }
  return v2;
}
// 83E1E0C: using guessed type int dword_83E1E0C[];

//----- (080890F5) --------------------------------------------------------
int __cdecl sub_80890F5(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  int result; // eax

  v1 = sub_8089096();
  dword_83E1E0C[2 * v1] = a1;
  v2 = v1;
  result = dword_83CCD84;
  dword_83E1E10[2 * v2] = dword_83CCD84;
  return result;
}
// 83CCD84: using guessed type int dword_83CCD84;
// 83E1E0C: using guessed type int dword_83E1E0C[];

//----- (08089121) --------------------------------------------------------
int __cdecl sub_8089121(int a1)
{
  int result; // eax
  char dest[76]; // [esp+10h] [ebp-58h] BYREF
  int v3[3]; // [esp+5Ch] [ebp-Ch] BYREF

  if ( *(_DWORD *)(a1 + 338248) == 2 )
    return SV_SendServerCommand(0, 0, "e \"EXE_CANNOTKICKHOSTPLAYER\"");
  result = a1;
  if ( *(_DWORD *)(a1 + 371072) )
  {
    result = sub_8088FF8(*(_DWORD *)(a1 + 371072));
    if ( !result )
    {
      result = FS_FOpenFileByMode("ban.txt", (int)v3, 2);
      if ( result >= 0 )
      {
        Q_strncpyz(dest, (char *)(a1 + 68164), 64);
        sub_80860DE(dest);
        sub_8062B8B(v3[0], "%i %s\r\n", *(_DWORD *)(a1 + 371072), dest);
        FS_FCloseFile(v3[0]);
        SV_DropClient(a1, (int)"EXE_PLAYERKICKED");
        result = dword_83CCD88;
        *(_DWORD *)(a1 + 68636) = dword_83CCD88;
      }
    }
  }
  return result;
}
// 83CCD88: using guessed type int dword_83CCD88;

//----- (0808921D) --------------------------------------------------------
int __cdecl sub_808921D(char *src)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-6Ch]
  int v3; // [esp+20h] [ebp-68h]
  size_t n; // [esp+28h] [ebp-60h]
  char *dest; // [esp+30h] [ebp-58h]
  char *s1; // [esp+34h] [ebp-54h] BYREF
  int v7; // [esp+38h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-4Ch] BYREF
  char s[72]; // [esp+40h] [ebp-48h] BYREF

  result = FS_ReadFile("ban.txt", (int)&v8);
  v7 = result;
  if ( result >= 0 )
  {
    Q_strncpyz(s, src, 64);
    sub_80860DE(s);
    n = strlen(s);
    v3 = 0;
    s1 = (char *)v8;
    while ( 1 )
    {
      dest = s1;
      if ( !*(_BYTE *)Com_Parse(&s1) )
        break;
      while ( *s1 && *s1 <= 32 )
        ++s1;
      v2 = 0;
      if ( !strncasecmp(s1, s, n) && (s1[n] == 13 || s1[n] == 10) )
        v2 = 1;
      sub_80854D2(&s1);
      if ( v2 )
      {
        ++v3;
        memmove(dest, s1, v7 - (_DWORD)&s1[-v8] + 1);
        v7 -= s1 - dest;
        s1 = dest;
      }
    }
    FS_WriteFile("ban.txt", v8, v7);
    FS_FreeFile((void *)v8);
    if ( v3 )
      result = Com_Printf("unbanned %i user(s) named %s\n", v3);
    else
      result = Com_Printf("no banned user has name %s\n", (char)s);
  }
  return result;
}

//----- (080893C1) --------------------------------------------------------
int __cdecl SV_AuthorizeIpPacket(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char v9; // [esp+4h] [ebp-444h]
  char s[1024]; // [esp+30h] [ebp-418h] BYREF
  char *v11; // [esp+430h] [ebp-18h]
  char *v12; // [esp+434h] [ebp-14h]
  int i; // [esp+438h] [ebp-10h]
  int v14; // [esp+43Ch] [ebp-Ch]

  if ( !NET_CompareBaseAdr(a1, a2, a3, a4, a5) )
    return Com_Printf("SV_AuthorizeIpPacket: not from authorize server\n", v9);
  v6 = Cmd_Argv(1u);
  v14 = atoi(v6);
  for ( i = 0; i <= 1023 && dword_83CCDF4[21 * i] != v14; ++i )
    ;
  if ( i == 1024 )
    return Com_Printf("SV_AuthorizeIpPacket: challenge not found\n", v9);
  dword_83CCDFC[21 * i] = dword_83CCD88;
  v12 = Cmd_Argv(2u);
  v11 = Cmd_Argv(3u);
  v7 = Cmd_Argv(5u);
  Q_strncpyz((char *)(84 * i + 138202640), v7, 32);
  if ( !Q_stricmp(v12, "demo") )
  {
    if ( Cvar_VariableValue((int)"fs_restrict") == 0.0 )
    {
      NET_OutOfBandPrint(
        1,
        dword_83CCDE0[21 * i],
        dword_83CCDE4[21 * i],
        dword_83CCDE8[21 * i],
        dword_83CCDEC[21 * i],
        dword_83CCDF0[21 * i],
        "error\nEXE_ERR_NOT_A_DEMO_SERVER");
      return (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
    }
    return (int)NET_OutOfBandPrint(
                  1,
                  dword_83CCDE0[21 * i],
                  dword_83CCDE4[21 * i],
                  dword_83CCDE8[21 * i],
                  dword_83CCDEC[21 * i],
                  dword_83CCDF0[21 * i],
                  "challengeResponse %i",
                  dword_83CCDF4[21 * i]);
  }
  if ( Q_stricmp(v12, "accept") )
  {
    if ( Q_stricmp(v12, "deny") )
    {
      if ( v11 && *v11 )
      {
        sprintf(s, "error\n%s", v11);
        NET_OutOfBandPrint(
          1,
          dword_83CCDE0[21 * i],
          dword_83CCDE4[21 * i],
          dword_83CCDE8[21 * i],
          dword_83CCDEC[21 * i],
          dword_83CCDF0[21 * i],
          s);
      }
      else
      {
        NET_OutOfBandPrint(
          1,
          dword_83CCDE0[21 * i],
          dword_83CCDE4[21 * i],
          dword_83CCDE8[21 * i],
          dword_83CCDEC[21 * i],
          dword_83CCDF0[21 * i],
          "error\nEXE_ERR_BAD_CDKEY");
      }
      return (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
    }
    if ( v11 && *v11 )
    {
      if ( !Q_stricmp(v11, "CLIENT_UNKNOWN_TO_AUTH") || !Q_stricmp(v11, "BAD_CDKEY") )
      {
        NET_OutOfBandPrint(
          1,
          dword_83CCDE0[21 * i],
          dword_83CCDE4[21 * i],
          dword_83CCDE8[21 * i],
          dword_83CCDEC[21 * i],
          dword_83CCDF0[21 * i],
          "needcdkey");
        return (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
      }
      if ( Q_stricmp(v11, "INVALID_CDKEY") )
      {
        Q_stricmp(v11, "BANNED_CDKEY");
        NET_OutOfBandPrint(
          1,
          dword_83CCDE0[21 * i],
          dword_83CCDE4[21 * i],
          dword_83CCDE8[21 * i],
          dword_83CCDEC[21 * i],
          dword_83CCDF0[21 * i],
          "error\nEXE_ERR_BAD_CDKEY");
        return (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
      }
    }
    NET_OutOfBandPrint(
      1,
      dword_83CCDE0[21 * i],
      dword_83CCDE4[21 * i],
      dword_83CCDE8[21 * i],
      dword_83CCDEC[21 * i],
      dword_83CCDF0[21 * i],
      "error\nEXE_ERR_CDKEY_IN_USE");
    return (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
  }
  v8 = Cmd_Argv(4u);
  dword_83CCE0C[21 * i] = atoi(v8);
  if ( sub_8088FF8(dword_83CCE0C[21 * i]) )
  {
    Com_Printf("rejected connection from permanently banned GUID %i\n", dword_83CCE0C[21 * i]);
    NET_OutOfBandPrint(
      1,
      dword_83CCDE0[21 * i],
      dword_83CCDE4[21 * i],
      dword_83CCDE8[21 * i],
      dword_83CCDEC[21 * i],
      dword_83CCDF0[21 * i],
      aError_2);
    result = (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
  }
  else if ( sub_8088F75(dword_83CCE0C[21 * i]) )
  {
    Com_Printf("rejected connection from temporarily banned GUID %i\n", dword_83CCE0C[21 * i]);
    NET_OutOfBandPrint(
      1,
      dword_83CCDE0[21 * i],
      dword_83CCDE4[21 * i],
      dword_83CCDE8[21 * i],
      dword_83CCDEC[21 * i],
      dword_83CCDF0[21 * i],
      aError_3);
    result = (int)memset((void *)(84 * i + 138202592), 0, 0x54u);
  }
  else
  {
    result = 84 * i;
    if ( !dword_83CCE08[21 * i] )
    {
      if ( !*(_DWORD *)(dword_83CCD64 + 32) )
        return (int)NET_OutOfBandPrint(
                      1,
                      dword_83CCDE0[21 * i],
                      dword_83CCDE4[21 * i],
                      dword_83CCDE8[21 * i],
                      dword_83CCDEC[21 * i],
                      dword_83CCDF0[21 * i],
                      "challengeResponse %i",
                      dword_83CCDF4[21 * i]);
      result = (int)NET_OutOfBandPrint(
                      1,
                      dword_83CCDE0[21 * i],
                      dword_83CCDE4[21 * i],
                      dword_83CCDE8[21 * i],
                      dword_83CCDEC[21 * i],
                      dword_83CCDF0[21 * i],
                      "challengeResponse %i %i",
                      dword_83CCDF4[21 * i],
                      *(_DWORD *)(dword_83CCD64 + 32));
    }
  }
  return result;
}
// 808942A: variable 'v9' is possibly undefined
// 83CCD64: using guessed type int dword_83CCD64;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCDE0: using guessed type int dword_83CCDE0[];
// 83CCDE4: using guessed type int dword_83CCDE4[];
// 83CCDE8: using guessed type int dword_83CCDE8[];
// 83CCDEC: using guessed type int dword_83CCDEC[];
// 83CCDF0: using guessed type int dword_83CCDF0[];
// 83CCDF4: using guessed type int dword_83CCDF4[];
// 83CCDFC: using guessed type int dword_83CCDFC[];
// 83CCE08: using guessed type int dword_83CCE08[];

//----- (08089DAF) --------------------------------------------------------
int __cdecl sub_8089DAF(int a1)
{
  sub_808B20F(a1);
  if ( sv == 2 )
    VM_Call((int)gvm, 7);
  sub_809030B(-266129563 * ((a1 - (int)dword_83CCD90) >> 2), (char *)&byte_80DDF5B);
  return sub_8093E86(a1);
}
// 836B820: using guessed type int sv;

//----- (08089E27) --------------------------------------------------------
void sub_8089E27()
{
  int *v0; // [esp+10h] [ebp-8h]
  int v1; // [esp+14h] [ebp-4h]

  v1 = 0;
  v0 = (int *)dword_83CCD90;
  while ( v1 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *v0 > 1 )
      sub_8089DAF((int)v0);
    ++v1;
    v0 += 92781;
  }
  free(dword_83CCD90);
}
// 836B804: using guessed type int dword_836B804;

//----- (08089E7E) --------------------------------------------------------
void __cdecl SV_DirectConnect(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  char v12; // al
  _WORD *v13; // ebx
  unsigned int v14; // [esp+3Ch] [ebp-5AE2Ch]
  int *v15; // [esp+40h] [ebp-5AE28h]
  int *v16; // [esp+44h] [ebp-5AE24h]
  char *v17; // [esp+48h] [ebp-5AE20h]
  int v18; // [esp+4Ch] [ebp-5AE1Ch]
  char *s1; // [esp+50h] [ebp-5AE18h]
  void *v20; // [esp+54h] [ebp-5AE14h]
  int v21; // [esp+58h] [ebp-5AE10h]
  int v22; // [esp+5Ch] [ebp-5AE0Ch]
  const char *v23; // [esp+60h] [ebp-5AE08h]
  int v24; // [esp+64h] [ebp-5AE04h]
  char *v25; // [esp+68h] [ebp-5AE00h]
  int v26; // [esp+6Ch] [ebp-5ADFCh]
  int v27; // [esp+70h] [ebp-5ADF8h]
  int v28; // [esp+74h] [ebp-5ADF4h]
  int v29; // [esp+80h] [ebp-5ADE8h] BYREF
  int v30; // [esp+84h] [ebp-5ADE4h] BYREF
  void *s; // [esp+5AA40h] [ebp-428h]
  char *v32; // [esp+5AA44h] [ebp-424h]
  int v33; // [esp+5AA48h] [ebp-420h]
  char v34[4]; // [esp+5AA4Ch] [ebp-41Ch]
  char dest[1048]; // [esp+5AA50h] [ebp-418h] BYREF

  Com_DPrintf("SVC_DirectConnect ()\n");
  v5 = Cmd_Argv(1u);
  Q_strncpyz(dest, v5, 1024);
  v6 = (const char *)Info_ValueForKey(dest, (int)"protocol");
  v28 = atoi(v6);
  if ( v28 != 6 )
  {
    NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, aErrorExeServer_0, "1.5");
    Com_DPrintf("    rejected connect from protocol version %i (should be %i)\n", v28, 6);
    return;
  }
  v7 = (const char *)Info_ValueForKey(dest, (int)"challenge");
  v26 = atoi(v7);
  v8 = (const char *)Info_ValueForKey(dest, (int)"qport");
  v27 = atoi(v8);
  *(_DWORD *)v34 = 0;
  v32 = (char *)dword_83CCD90;
  while ( *(int *)v34 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( NET_CompareBaseAdr(
           a1,
           a2,
           a3,
           a4,
           a5,
           *((_DWORD *)v32 + 84562),
           *((_DWORD *)v32 + 84563),
           *((_DWORD *)v32 + 84564),
           *((_DWORD *)v32 + 84565),
           *((_DWORD *)v32 + 84566))
      && (*((_DWORD *)v32 + 84567) == v27 || HIWORD(a5) == *((_WORD *)v32 + 169133)) )
    {
      if ( dword_83CCD88 - *((_DWORD *)v32 + 17160) < 1000 * *(_DWORD *)(dword_83CCD74 + 32) )
      {
        v9 = NET_AdrToString(a1, a2, a3, a4, a5);
        Com_DPrintf("%s:reconnect rejected : too soon\n", v9);
        return;
      }
      break;
    }
    ++*(_DWORD *)v34;
    v32 += 371124;
  }
  v33 = 0;
  if ( NET_IsLocalAddress(a1) )
    goto LABEL_30;
  *(_DWORD *)v34 = 0;
  while ( *(int *)v34 <= 1023 )
  {
    if ( NET_CompareAdr(
           a1,
           a2,
           a3,
           a4,
           a5,
           dword_83CCDE0[21 * *(_DWORD *)v34],
           dword_83CCDE4[21 * *(_DWORD *)v34],
           dword_83CCDE8[21 * *(_DWORD *)v34],
           dword_83CCDEC[21 * *(_DWORD *)v34],
           dword_83CCDF0[21 * *(_DWORD *)v34])
      && v26 == dword_83CCDF4[21 * *(_DWORD *)v34] )
    {
      v33 = dword_83CCE0C[21 * *(_DWORD *)v34];
      break;
    }
    ++*(_DWORD *)v34;
  }
  if ( *(_DWORD *)v34 == 1024 )
  {
    NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "error\nEXE_BAD_CHALLENGE");
    return;
  }
  if ( dword_83CCE04[21 * *(_DWORD *)v34] )
  {
    v18 = dword_83CCE04[21 * *(_DWORD *)v34];
  }
  else
  {
    v18 = dword_83CCD88 - dword_83CCDFC[21 * *(_DWORD *)v34];
    dword_83CCE04[21 * *(_DWORD *)v34] = v18;
  }
  NET_AdrToString(a1, a2, a3, a4, a5);
  Com_Printf("Client %i connecting with %i challenge ping from %s\n", v34[0]);
  dword_83CCE08[21 * *(_DWORD *)v34] = 1;
  if ( Sys_IsLANAddress(a1, a2) )
    goto LABEL_30;
  if ( *(float *)(dword_83CCD78 + 28) != 0.0 && *(float *)(dword_83CCD78 + 28) > (long double)v18 )
  {
    NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "error\nEXE_ERR_HIGH_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too low ping\n", *(_DWORD *)v34);
    return;
  }
  if ( *(float *)(dword_83CCD54 + 28) == 0.0 || (long double)v18 <= *(float *)(dword_83CCD54 + 28) )
  {
LABEL_30:
    v10 = (const char *)Info_ValueForKey(dest, (int)"cl_punkbuster");
    v21 = atoi(v10);
    v20 = Info_ValueForKey(dest, (int)"cl_guid");
    if ( NET_IsLocalAddress(a1) )
    {
      v11 = (const char *)sub_80C191C((int)"localhost", v21, (int)v20);
    }
    else
    {
      v17 = NET_AdrToString(a1, a2, a3, a4, a5);
      v11 = (const char *)sub_80C191C((int)v17, v21, (int)v20);
    }
    s1 = (char *)v11;
    if ( v11 )
    {
      if ( !strncasecmp(v11, "error\n", 6u) )
        NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, s1);
    }
    else
    {
      s = &v29;
      memset(&v29, 0, 0x5A9B4u);
      *(_DWORD *)v34 = 0;
      v32 = (char *)dword_83CCD90;
      while ( *(int *)v34 < *(_DWORD *)(dword_836B804 + 32) )
      {
        if ( *(_DWORD *)v32
          && NET_CompareBaseAdr(
               a1,
               a2,
               a3,
               a4,
               a5,
               *((_DWORD *)v32 + 84562),
               *((_DWORD *)v32 + 84563),
               *((_DWORD *)v32 + 84564),
               *((_DWORD *)v32 + 84565),
               *((_DWORD *)v32 + 84566))
          && (*((_DWORD *)v32 + 84567) == v27 || HIWORD(a5) == *((_WORD *)v32 + 169133)) )
        {
          v12 = (unsigned __int8)NET_AdrToString(a1, a2, a3, a4, a5);
          Com_Printf("%s:reconnect\n", v12);
          if ( *(int *)v32 > 1 )
            sub_8089DAF((int)v32);
          s = v32;
          goto LABEL_57;
        }
        ++*(_DWORD *)v34;
        v32 += 371124;
      }
      v25 = (char *)Info_ValueForKey(dest, (int)"password");
      if ( !strcmp(v25, *(const char **)(dword_836B7EC + 4)) )
        v24 = 0;
      else
        v24 = *(_DWORD *)(dword_836B7C0 + 32);
      s = 0;
      *(_DWORD *)v34 = v24;
      while ( *(int *)v34 < *(_DWORD *)(dword_836B804 + 32) )
      {
        v32 = (char *)dword_83CCD90 + 371124 * *(_DWORD *)v34;
        if ( !*(_DWORD *)v32 )
        {
          s = v32;
          break;
        }
        ++*(_DWORD *)v34;
      }
      if ( !s )
      {
        NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "error\nEXE_SERVERISFULL");
        Com_DPrintf("Rejected a connection.\n");
        return;
      }
      *((_DWORD *)v32 + 16772) = 0;
      *((_DWORD *)v32 + 16771) = 0;
LABEL_57:
      v16 = (int *)s;
      v15 = &v29;
      v14 = 371124;
      if ( ((unsigned __int8)s & 4) != 0 )
      {
        *(_DWORD *)s = v29;
        ++v16;
        v15 = &v30;
        v14 = 371120;
      }
      qmemcpy(v16, v15, 4 * (v14 >> 2));
      *((_DWORD *)s + 17040) = sub_808D314(-266129563 * (((_BYTE *)s - (_BYTE *)dword_83CCD90) >> 2));
      v13 = s;
      v13[185538] = sub_80A5AB4();
      *((_DWORD *)s + 16776) = v26;
      *((_DWORD *)s + 92768) = v33;
      sub_808346F(1, (char *)s + 338240, a1, a2, a3, a4, a5, v27);
      Q_strncpyz((char *)s + 12, dest, 1024);
      v23 = (const char *)VM_Call((int)gvm, 4);
      if ( v23 )
      {
        NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "error\n%s", v23);
        Com_DPrintf("Game rejected a connection: %s.\n", v23);
        sub_8093E86((int)s);
      }
      else
      {
        SV_UserinfoChanged((int)s);
        dword_83CCE04[21 * *(_DWORD *)v34] = 0;
        NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "connectResponse");
        Com_Printf("Going from CS_FREE to CS_CONNECTED for %s (num %i guid %i)\n", (_BYTE)s + 68);
        *(_DWORD *)s = 2;
        *((_DWORD *)s + 17159) = dword_83CCD88;
        *((_DWORD *)s + 17160) = dword_83CCD88;
        *((_DWORD *)s + 17161) = dword_83CCD88;
        *((_DWORD *)s + 16775) = -1;
        v22 = 0;
        *(_DWORD *)v34 = 0;
        v32 = (char *)dword_83CCD90;
        while ( *(int *)v34 < *(_DWORD *)(dword_836B804 + 32) )
        {
          if ( *((int *)dword_83CCD90 + 92781 * *(_DWORD *)v34) > 1 )
            ++v22;
          ++*(_DWORD *)v34;
          v32 += 371124;
        }
        if ( v22 == 1 || v22 == *(_DWORD *)(dword_836B804 + 32) )
          SV_Heartbeat_f();
      }
    }
  }
  else
  {
    NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "error\nEXE_ERR_LOW_PING_ONLY");
    Com_DPrintf("Client %i rejected on a too high ping: %i\n", *(_DWORD *)v34, v18);
  }
}
// 836B7C0: using guessed type int dword_836B7C0;
// 836B7EC: using guessed type int dword_836B7EC;
// 836B804: using guessed type int dword_836B804;
// 83CCD54: using guessed type int dword_83CCD54;
// 83CCD74: using guessed type int dword_83CCD74;
// 83CCD78: using guessed type int dword_83CCD78;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCDE0: using guessed type int dword_83CCDE0[];
// 83CCDE4: using guessed type int dword_83CCDE4[];
// 83CCDE8: using guessed type int dword_83CCDE8[];
// 83CCDEC: using guessed type int dword_83CCDEC[];
// 83CCDF0: using guessed type int dword_83CCDF0[];
// 83CCDF4: using guessed type int dword_83CCDF4[];
// 83CCDFC: using guessed type int dword_83CCDFC[];
// 83CCE04: using guessed type int dword_83CCE04[];
// 83CCE08: using guessed type int dword_83CCE08[];

//----- (0808ABB1) --------------------------------------------------------
int sub_808ABB1()
{
  int result; // eax
  int *i; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = (int *)dword_83CCD90; ; i += 92781 )
  {
    result = v2;
    if ( v2 >= *(_DWORD *)(dword_836B804 + 32) )
      break;
    if ( *i > 1 )
    {
      sub_8093E86((int)i);
      *((_WORD *)i + 185538) = sub_80A5AB4();
    }
    ++v2;
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (0808AC11) --------------------------------------------------------
void __cdecl SV_DropClient(int a1, int a2)
{
  char *v2; // eax
  char dest[40]; // [esp+30h] [ebp-38h] BYREF
  int *v4; // [esp+58h] [ebp-10h]
  int i; // [esp+5Ch] [ebp-Ch]

  if ( *(_DWORD *)a1 != 1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    strcpy(dest, (const char *)(a1 + 68164));
    sub_8089DAF(a1);
    Com_DPrintf("Going to CS_ZOMBIE for %s\n", dest);
    *(_DWORD *)a1 = 1;
    if ( !*(_DWORD *)(a1 + 68160) )
    {
      v4 = dword_83CCDE0;
      i = 0;
      while ( i <= 1023 )
      {
        if ( NET_CompareAdr(
               *(_DWORD *)(a1 + 338248),
               *(_DWORD *)(a1 + 338252),
               *(_DWORD *)(a1 + 338256),
               *(_DWORD *)(a1 + 338260),
               *(_DWORD *)(a1 + 338264),
               *v4,
               v4[1],
               v4[2],
               v4[3],
               v4[4]) )
        {
          v4[10] = 0;
          break;
        }
        ++i;
        v4 += 21;
      }
    }
    if ( Q_stricmp((char *)a2, "EXE_DISCONNECTED") )
      SV_SendServerCommand(0, 0, aE, dest, a2);
    Com_Printf("%i:%s %s\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
    v2 = va("w \"%s\"", (const char *)a2);
    SV_SendServerCommand(a1, 1, v2, a2);
    for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32) && *((int *)dword_83CCD90 + 92781 * i) <= 1; ++i )
      ;
    if ( i == *(_DWORD *)(dword_836B804 + 32) )
      SV_Heartbeat_f();
  }
}
// 836B804: using guessed type int dword_836B804;
// 83CCDE0: using guessed type int dword_83CCDE0[];

//----- (0808ADFB) --------------------------------------------------------
_DWORD *__cdecl SV_DelayDropClient(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( *a1 != 1 )
  {
    result = a1;
    if ( !a1[2] )
    {
      result = a2;
      a1[2] = a2;
    }
  }
  return result;
}

//----- (0808AE1E) --------------------------------------------------------
void __cdecl sub_808AE1E(int a1, int a2)
{
  SV_DropClient((int)dword_83CCD90 + 371124 * a1, a2);
}

//----- (0808AE44) --------------------------------------------------------
char *__cdecl SV_SendClientGameState(char *a1)
{
  char *result; // eax
  int v2[4096]; // [esp+10h] [ebp-4128h] BYREF
  int v3[3]; // [esp+4010h] [ebp-128h] BYREF
  _DWORD v4[5]; // [esp+401Ch] [ebp-11Ch]
  char s[248]; // [esp+4030h] [ebp-108h] BYREF
  int v6; // [esp+4128h] [ebp-10h]
  int i; // [esp+412Ch] [ebp-Ch]

  while ( *(_DWORD *)a1 && *((_DWORD *)a1 + 88668) )
    SV_Netchan_TransmitNextFragment((int *)a1 + 84560);
  Com_DPrintf("SV_SendClientGameState() for %s\n", a1 + 68164);
  Com_DPrintf("Going from CS_CONNECTED to CS_PRIMED for %s\n", a1 + 68164);
  *(_DWORD *)a1 = 3;
  *((_DWORD *)a1 + 84559) = 0;
  *((_DWORD *)a1 + 16775) = *((_DWORD *)a1 + 84569);
  MSG_Init(v3, (int)v2, 0x4000);
  MSG_WriteLong(v3, *((_DWORD *)a1 + 16783));
  SV_UpdateServerCommandsToClient(a1, v3);
  MSG_WriteByte(v3, 2);
  MSG_WriteLong(v3, *((_DWORD *)a1 + 16771));
  for ( i = 0; i <= 2047; ++i )
  {
    if ( *(&dword_836BC38)[i] )
    {
      MSG_WriteByte(v3, 3);
      MSG_WriteShort(v3, i);
      MSG_WriteBigString((int)v3, (&dword_836BC38)[i]);
    }
  }
  memset(s, 0, 0xF0u);
  for ( i = 0; i <= 1023; ++i )
  {
    v6 = 380 * i + 137813056;
    if ( *((_DWORD *)&unk_836DC40 + 95 * i) )
    {
      MSG_WriteByte(v3, 4);
      MSG_WriteDeltaEntity((int)v3, (int)s, v6, 1);
    }
  }
  MSG_WriteByte(v3, 8);
  MSG_WriteLong(v3, -266129563 * ((a1 - (_BYTE *)dword_83CCD90) >> 2));
  MSG_WriteLong(v3, dword_836B82C);
  MSG_WriteByte(v3, 8);
  Com_DPrintf("Sending %i bytes in gamestate to client: %i\n", v4[0], -266129563 * ((a1 - (_BYTE *)dword_83CCD90) >> 2));
  SV_SendMessageToClient((int)v3, (int)a1);
  result = (char *)dword_835F4B4;
  if ( !*(_DWORD *)(dword_835F4B4 + 32) )
  {
    result = a1;
    if ( *(_DWORD *)a1 )
    {
      result = a1;
      if ( *((_DWORD *)a1 + 88668) )
        result = (char *)SV_Netchan_TransmitNextFragment((int *)a1 + 84560);
    }
  }
  return result;
}
// 835F4B4: using guessed type int dword_835F4B4;
// 836B82C: using guessed type int dword_836B82C;

//----- (0808B12A) --------------------------------------------------------
int __cdecl SV_ClientEnterWorld(char *a1, _DWORD *a2)
{
  int *v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  Com_DPrintf("Going from CS_PRIMED to CS_ACTIVE for %s\n", a1 + 68164);
  *(_DWORD *)a1 = 4;
  v4 = -266129563 * ((a1 - (_BYTE *)dword_83CCD90) >> 2);
  v3 = (int *)sub_808D314(v4);
  *v3 = v4;
  *((_DWORD *)a1 + 17040) = v3;
  *((_DWORD *)a1 + 17157) = -1;
  *((_DWORD *)a1 + 17161) = dword_83CCD88;
  *((_DWORD *)a1 + 16777) = *a2;
  *((_DWORD *)a1 + 16778) = a2[1];
  *((_DWORD *)a1 + 16779) = a2[2];
  *((_DWORD *)a1 + 16780) = a2[3];
  *((_DWORD *)a1 + 16781) = a2[4];
  *((_DWORD *)a1 + 16782) = a2[5];
  return VM_Call((int)gvm, 5);
}
// 83CCD88: using guessed type int dword_83CCD88;

//----- (0808B20F) --------------------------------------------------------
int *__cdecl sub_808B20F(int a1)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  if ( *(_DWORD *)(a1 + 68260) )
    FS_FCloseFile(*(_DWORD *)(a1 + 68260));
  *(_DWORD *)(a1 + 68260) = 0;
  result = (int *)(a1 + 68196);
  *(_BYTE *)(a1 + 68196) = 0;
  for ( i = 0; i <= 7; ++i )
  {
    if ( *(_DWORD *)(a1 + 4 * i + 68284) )
    {
      Z_FreeInternal(*(void **)(a1 + 4 * i + 68284));
      *(_DWORD *)(a1 + 4 * i + 68284) = 0;
    }
    result = &i;
  }
  return result;
}

//----- (0808B298) --------------------------------------------------------
int *__cdecl SV_StopDownload_f(int a1)
{
  if ( *(_BYTE *)(a1 + 68196) )
    Com_DPrintf(
      "clientDownload: %d : file \"%s\" aborted\n",
      -266129563 * ((a1 - (int)dword_83CCD90) >> 2),
      (const char *)(a1 + 68196));
  return sub_808B20F(a1);
}

//----- (0808B2E8) --------------------------------------------------------
char *__cdecl SV_DoneDownload_f(int a1)
{
  Com_DPrintf("clientDownload: %s Done\n", (const char *)(a1 + 68164));
  return SV_SendClientGameState((char *)a1);
}

//----- (0808B313) --------------------------------------------------------
int __cdecl SV_RetransmitDownload_f(int a1)
{
  char *v1; // eax
  int result; // eax

  v1 = Cmd_Argv(1u);
  result = atoi(v1);
  if ( result == *(_DWORD *)(a1 + 68272) )
  {
    result = a1;
    *(_DWORD *)(a1 + 68280) = *(_DWORD *)(a1 + 68272);
  }
  return result;
}

//----- (0808B352) --------------------------------------------------------
void __cdecl SV_NextDownload_f(int a1)
{
  char *v1; // eax
  int v2; // [esp+24h] [ebp-4h]

  v1 = Cmd_Argv(1u);
  v2 = atoi(v1);
  if ( v2 == *(_DWORD *)(a1 + 68272) )
  {
    Com_DPrintf(
      "clientDownload: %d : client acknowledge of block %d\n",
      -266129563 * ((a1 - (int)dword_83CCD90) >> 2),
      v2);
    if ( *(_DWORD *)(a1 + 4 * (*(_DWORD *)(a1 + 68272) % 8) + 68316) )
    {
      *(_DWORD *)(a1 + 68352) = dword_83CCD88;
      ++*(_DWORD *)(a1 + 68272);
    }
    else
    {
      Com_Printf("clientDownload: %d : file \"%s\" completed\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
      sub_808B20F(a1);
    }
  }
  else
  {
    SV_DropClient(a1, (int)"broken download");
  }
}
// 83CCD88: using guessed type int dword_83CCD88;

//----- (0808B456) --------------------------------------------------------
char *__cdecl SV_BeginDownload_f(int a1)
{
  char *v1; // eax

  sub_808B20F(a1);
  v1 = Cmd_Argv(1u);
  return Q_strncpyz((char *)(a1 + 68196), v1, 64);
}

//----- (0808B491) --------------------------------------------------------
void __cdecl sub_808B491(int a1)
{
  char v1; // [esp+4h] [ebp-14h]
  char *v2; // [esp+14h] [ebp-4h]

  v2 = Cmd_Argv(1u);
  if ( !*(_DWORD *)(a1 + 68616) )
    goto LABEL_2;
  if ( Q_stricmp(v2, "ack") )
  {
    if ( Q_stricmp(v2, "bbl8r") )
    {
      if ( !*(_DWORD *)(a1 + 68620) )
      {
LABEL_2:
        Com_Printf("SV_WWWDownload: unexpected wwwdl '%s' for client '%s'\n", (char)v2);
        SV_DropClient(a1, (int)"PATCH_1_5_WWW_UNEXPECTEDDOWLOADMESSAGE");
        return;
      }
      if ( Q_stricmp(v2, "done") )
      {
        if ( Q_stricmp(v2, "fail") )
        {
          if ( Q_stricmp(v2, "chkfail") )
          {
            Com_Printf("SV_WWWDownload: unknown wwwdl subcommand '%s' for client '%s'\n", (char)v2);
            SV_DropClient(a1, (int)"PATCH_1_5_WWW_UNEXPECTEDDOWLOADMESSAGE");
          }
          else
          {
            Com_Printf(
              "WARNING: client '%s' reports that the redirect download for '%s' had wrong checksum.\n",
              a1 + 68);
            Com_Printf("         you should check your download redirect configuration.\n", v1);
            *(_DWORD *)(a1 + 68260) = 0;
            *(_BYTE *)(a1 + 68196) = 0;
            *(_DWORD *)(a1 + 68620) = 0;
            *(_DWORD *)(a1 + 68624) = 1;
            SV_SendClientGameState((char *)a1);
          }
        }
        else
        {
          *(_DWORD *)(a1 + 68260) = 0;
          *(_BYTE *)(a1 + 68196) = 0;
          *(_DWORD *)(a1 + 68620) = 0;
          *(_DWORD *)(a1 + 68624) = 1;
          SV_SendClientGameState((char *)a1);
        }
      }
      else
      {
        *(_DWORD *)(a1 + 68260) = 0;
        *(_BYTE *)(a1 + 68196) = 0;
        *(_DWORD *)(a1 + 68620) = 0;
      }
    }
    else
    {
      SV_DropClient(a1, (int)"PATCH_1_5_WWW_DOWNLOADDISCONNECTED");
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 68620) )
      Com_Printf("WARNING: dupe wwwdl ack from client '%s'\n", a1 + 68);
    *(_DWORD *)(a1 + 68620) = 1;
  }
}
// 808B684: variable 'v1' is possibly undefined

//----- (0808B6FC) --------------------------------------------------------
int __cdecl sub_808B6FC(int a1, _DWORD *a2)
{
  char *v2; // eax
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+24h] [ebp-4h] BYREF

  v6 = 0;
  v5 = FS_SV_FOpenFileRead((char *)(a1 + 68196), (int)&v7);
  if ( v5 )
  {
    FS_FCloseFile(v7);
    v2 = va("%s/%s", *(const char **)(dword_836B7E4 + 4), (const char *)(a1 + 68196));
    Q_strncpyz((char *)(a1 + 68356), v2, 256);
    Com_Printf("Redirecting client '%s' to %s\n", a1 + 68);
    *(_DWORD *)(a1 + 68616) = 1;
    MSG_WriteByte(a2, 6);
    MSG_WriteShort(a2, -1);
    MSG_WriteString((int)a2, (char *)(a1 + 68356));
    MSG_WriteLong(a2, v5);
    if ( *(_DWORD *)(dword_836B7FC + 32) )
      v6 = 1;
    MSG_WriteLong(a2, v6);
    *(_BYTE *)(a1 + 68196) = 0;
    v4 = 1;
  }
  else
  {
    Com_Printf("ERROR: Client '%s': couldn't extract file size for %s\n", a1 + 100);
    v4 = 0;
  }
  return v4;
}
// 836B7E4: using guessed type int dword_836B7E4;
// 836B7FC: using guessed type int dword_836B7FC;

//----- (0808B853) --------------------------------------------------------
int __cdecl sub_808B853(int a1, _DWORD *a2)
{
  int result; // eax

  MSG_WriteByte(a2, 6);
  MSG_WriteShort(a2, 0);
  MSG_WriteLong(a2, -1);
  result = a1 + 68196;
  *(_BYTE *)(a1 + 68196) = 0;
  return result;
}

//----- (0808B89F) --------------------------------------------------------
int sub_808B89F()
{
  return 1;
}

//----- (0808B8A9) --------------------------------------------------------
int __cdecl SV_WriteDownloadToClient(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+2Ch] [ebp-41Ch]
  char s[1024]; // [esp+30h] [ebp-418h] BYREF
  int v5; // [esp+430h] [ebp-18h]
  int v6; // [esp+434h] [ebp-14h] BYREF
  int v7; // [esp+438h] [ebp-10h]
  int v8; // [esp+43Ch] [ebp-Ch]

  result = a1 + 68196;
  if ( *(_BYTE *)(a1 + 68196) )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 68620) )
    {
      if ( *(_DWORD *)(a1 + 68260) )
      {
LABEL_27:
        while ( *(_DWORD *)(a1 + 68276) - *(_DWORD *)(a1 + 68272) <= 7
             && *(_DWORD *)(a1 + 68264) != *(_DWORD *)(a1 + 68268) )
        {
          v3 = *(_DWORD *)(a1 + 68276);
          v8 = v3 % 8;
          if ( !*(_DWORD *)(a1 + 4 * (v3 % 8) + 68284) )
            *(_DWORD *)(a1 + 4 * v8 + 68284) = Z_MallocInternal(0x800u);
          *(_DWORD *)(a1 + 4 * v8 + 68316) = FS_Read(*(char **)(a1 + 4 * v8 + 68284), 0x800u, *(_DWORD *)(a1 + 68260));
          if ( *(int *)(a1 + 4 * v8 + 68316) < 0 )
          {
            *(_DWORD *)(a1 + 68268) = *(_DWORD *)(a1 + 68264);
            break;
          }
          *(_DWORD *)(a1 + 68268) += *(_DWORD *)(a1 + 4 * v8 + 68316);
          ++*(_DWORD *)(a1 + 68276);
        }
        if ( *(_DWORD *)(a1 + 68268) == *(_DWORD *)(a1 + 68264)
          && !*(_DWORD *)(a1 + 68348)
          && *(_DWORD *)(a1 + 68276) - *(_DWORD *)(a1 + 68272) <= 7 )
        {
          *(_DWORD *)(a1 + 4 * ((*(_DWORD *)(a1 + 68276))++ % 8) + 68316) = 0;
          *(_DWORD *)(a1 + 68348) = 1;
        }
        v7 = *(_DWORD *)(a1 + 338228);
        if ( *(_DWORD *)(dword_83CCD4C + 32) )
        {
          if ( *(int *)(dword_83CCD4C + 32) <= 999 )
            Cvar_Set("sv_MaxRate", "1000");
          if ( *(_DWORD *)(dword_83CCD4C + 32) < v7 )
            v7 = *(_DWORD *)(dword_83CCD4C + 32);
        }
        if ( v7 )
          v6 = (*(_DWORD *)(a1 + 338232) * v7 / 1000 + 2048) / 2048;
        else
          v6 = 1;
        if ( v6 < 0 )
          v6 = 1;
        while ( 1 )
        {
          result = (int)&v6;
          if ( --v6 == -1 )
            break;
          result = *(_DWORD *)(a1 + 68272);
          if ( result == *(_DWORD *)(a1 + 68276) )
            break;
          if ( *(_DWORD *)(a1 + 68280) == *(_DWORD *)(a1 + 68276) )
          {
            result = dword_83CCD88 - *(_DWORD *)(a1 + 68352);
            if ( result <= 1000 )
              return result;
            *(_DWORD *)(a1 + 68280) = *(_DWORD *)(a1 + 68272);
          }
          v8 = *(_DWORD *)(a1 + 68280) % 8;
          MSG_WriteByte(a2, 6);
          MSG_WriteShort(a2, *(_DWORD *)(a1 + 68280));
          if ( !*(_DWORD *)(a1 + 68280) )
            MSG_WriteLong(a2, *(_DWORD *)(a1 + 68264));
          MSG_WriteShort(a2, *(_DWORD *)(a1 + 4 * v8 + 68316));
          if ( *(_DWORD *)(a1 + 4 * v8 + 68316) )
            MSG_WriteData((int)a2, *(void **)(a1 + 4 * v8 + 68284), *(_DWORD *)(a1 + 4 * v8 + 68316));
          Com_DPrintf(
            "clientDownload: %d : writing block %d\n",
            -266129563 * ((a1 - (int)dword_83CCD90) >> 2),
            *(_DWORD *)(a1 + 68280));
          ++*(_DWORD *)(a1 + 68280);
          *(_DWORD *)(a1 + 68352) = dword_83CCD88;
        }
      }
      else
      {
        Com_Printf("clientDownload: %d : beginning \"%s\"\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
        v5 = FS_iwPak((char *)(a1 + 68196), (int)"main");
        if ( *(_DWORD *)(dword_83CCD5C + 32)
          && !v5
          && (*(_DWORD *)(a1 + 68264) = FS_SV_FOpenFileRead((char *)(a1 + 68196), a1 + 68260), *(int *)(a1 + 68264) > 0) )
        {
          if ( *(_DWORD *)(dword_836B7F0 + 32) )
          {
            if ( *(_DWORD *)(a1 + 68612) )
            {
              if ( *(_DWORD *)(a1 + 68624) )
              {
                *(_DWORD *)(a1 + 68624) = 0;
                result = sub_808B89F();
                if ( result )
                  return result;
                Com_Printf("Client '%s': falling back to regular downloading for failed file %s\n", a1 + 100);
              }
              else
              {
                result = sub_808B6FC(a1, a2);
                if ( result )
                  return result;
              }
            }
            else
            {
              result = sub_808B89F();
              if ( result )
                return result;
              Com_Printf("Client '%s' is not configured for www download\n", a1 + 68);
            }
          }
          *(_DWORD *)(a1 + 68616) = 0;
          *(_DWORD *)(a1 + 68264) = FS_SV_FOpenFileRead((char *)(a1 + 68196), a1 + 68260);
          if ( *(int *)(a1 + 68264) > 0 )
          {
            *(_DWORD *)(a1 + 68280) = 0;
            *(_DWORD *)(a1 + 68272) = 0;
            *(_DWORD *)(a1 + 68276) = 0;
            *(_DWORD *)(a1 + 68268) = 0;
            *(_DWORD *)(a1 + 68348) = 0;
            goto LABEL_27;
          }
          Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
          Com_sprintf(s, 0x400u, aExeAutodlFilen, a1 + 68196);
          sub_808B853(a1, a2);
          result = MSG_WriteString((int)a2, s);
        }
        else
        {
          if ( v5 )
          {
            Com_Printf(
              "clientDownload: %d : \"%s\" cannot download id pk3 files\n",
              101 * ((a1 - (int)dword_83CCD90) >> 2));
            Com_sprintf(s, 0x400u, aExeCantautodlg, a1 + 68196);
          }
          else if ( *(_DWORD *)(dword_83CCD5C + 32) )
          {
            Com_Printf("clientDownload: %d : \"%s\" file not found on server\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
            Com_sprintf(s, 0x400u, aExeAutodlFilen, a1 + 68196);
          }
          else
          {
            Com_Printf("clientDownload: %d : \"%s\" download disabled", 101 * ((a1 - (int)dword_83CCD90) >> 2));
            if ( *(_DWORD *)(dword_83CCD58 + 32) )
              Com_sprintf(s, 0x400u, aExeAutodlServe, a1 + 68196);
            else
              Com_sprintf(s, 0x400u, aExeAutodlServe_0, a1 + 68196);
          }
          MSG_WriteByte(a2, 6);
          MSG_WriteShort(a2, 0);
          MSG_WriteLong(a2, -1);
          MSG_WriteString((int)a2, s);
          result = a1 + 68196;
          *(_BYTE *)(a1 + 68196) = 0;
        }
      }
    }
  }
  return result;
}
// 836B7F0: using guessed type int dword_836B7F0;
// 83CCD4C: using guessed type int dword_83CCD4C;
// 83CCD58: using guessed type int dword_83CCD58;
// 83CCD5C: using guessed type int dword_83CCD5C;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (0808C13E) --------------------------------------------------------
void __cdecl SV_Disconnect_f(int a1)
{
  SV_DropClient(a1, (int)"EXE_DISCONNECTED");
}

//----- (0808C159) --------------------------------------------------------
int __cdecl SV_VerifyPaks_f(int a1)
{
  char *v1; // eax
  int v2; // eax
  char *v3; // eax
  int v4; // eax
  int v5; // eax
  signed int v6; // ebx
  char *v7; // eax
  signed int v8; // ebx
  char *v9; // eax
  int result; // eax
  unsigned int v11; // [esp+0h] [ebp-2048h]
  unsigned int v12; // [esp+0h] [ebp-2048h]
  unsigned int v13; // [esp+0h] [ebp-2048h]
  unsigned int v14; // [esp+0h] [ebp-2048h]
  _BOOL4 v15; // [esp+14h] [ebp-2034h]
  char *nptr; // [esp+18h] [ebp-2030h]
  char *nptra; // [esp+18h] [ebp-2030h]
  char *v18; // [esp+1Ch] [ebp-202Ch]
  int v19[2049]; // [esp+20h] [ebp-2028h]
  int v20; // [esp+2024h] [ebp-24h]
  int j; // [esp+2028h] [ebp-20h]
  signed int i; // [esp+202Ch] [ebp-1Ch]
  int v23; // [esp+2030h] [ebp-18h]
  int v24; // [esp+2034h] [ebp-14h]
  int v25; // [esp+2038h] [ebp-10h] BYREF
  int v26[3]; // [esp+203Ch] [ebp-Ch] BYREF

  v25 = 0;
  v26[0] = 0;
  v1 = (char *)sub_80749E8("eicogaoraz:80fnn", -2);
  v2 = sub_8074AEF(v1, (int)v26);
  v15 = v2 == 1;
  if ( v2 == 1 )
  {
    v3 = (char *)sub_80749E8("zndrud}=;3iqq", -5);
    v15 = sub_8074AEF(v3, (int)&v25) == 1;
  }
  v24 = Cmd_Argc();
  v20 = 1;
  if ( v15 )
  {
    if ( v24 > 5 )
    {
      v11 = v20++;
      nptr = Cmd_Argv(v11);
      if ( nptr && *nptr != 64 && (v4 = atoi(nptr), v4 == v26[0]) )
      {
        v12 = v20++;
        nptra = Cmd_Argv(v12);
        if ( nptra && *nptra != 64 && (v5 = atoi(nptra), v5 == v25) )
        {
          v13 = v20++;
          if ( *Cmd_Argv(v13) == 64 )
          {
            i = 0;
            while ( v20 < v24 )
            {
              v6 = i;
              v14 = v20++;
              v7 = Cmd_Argv(v14);
              v19[v6 + 1024] = atoi(v7);
              ++i;
            }
            v24 = i - 1;
            for ( i = 0; i < v24; ++i )
            {
              for ( j = 0; j < v24; ++j )
              {
                if ( i != j && v19[i + 1024] == v19[j + 1024] )
                {
                  v15 = 0;
                  break;
                }
              }
              if ( !v15 )
                break;
            }
            if ( v15 )
            {
              v18 = sub_8075C7A();
              Cmd_TokenizeString((char **)v18);
              v23 = Cmd_Argc();
              if ( v23 > 1024 )
                v23 = 1024;
              for ( i = 0; i < v23; ++i )
              {
                v8 = i;
                v9 = Cmd_Argv(i);
                v19[v8] = atoi(v9);
              }
              for ( i = 0; i < v24; ++i )
              {
                for ( j = 0; j < v23 && v19[i + 1024] != v19[j]; ++j )
                  ;
                if ( j >= v23 )
                {
                  v15 = 0;
                  break;
                }
              }
              if ( v15 )
              {
                v26[0] = dword_836B82C;
                for ( i = 0; i < v24; ++i )
                  v26[0] ^= v19[i + 1024];
                v26[0] ^= v24;
                if ( v26[0] != v19[v24 + 1024] )
                  v15 = 0;
              }
            }
          }
          else
          {
            v15 = 0;
          }
        }
        else
        {
          v15 = 0;
        }
      }
      else
      {
        v15 = 0;
      }
    }
    else
    {
      v15 = 0;
    }
  }
  result = a1;
  if ( v15 )
    *(_DWORD *)(a1 + 338236) = 1;
  else
    *(_DWORD *)(a1 + 338236) = 2;
  return result;
}
// 836B82C: using guessed type int dword_836B82C;

//----- (0808C4EB) --------------------------------------------------------
int __cdecl SV_ResetPureClient_f(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 338236) = 0;
  return result;
}

//----- (0808C4FD) --------------------------------------------------------
const char *__cdecl SV_UserinfoChanged(int a1)
{
  char *v1; // eax
  const char *result; // eax
  int v3; // [esp+20h] [ebp-8h]
  int v4; // [esp+20h] [ebp-8h]
  char *nptr; // [esp+24h] [ebp-4h]
  char *nptra; // [esp+24h] [ebp-4h]
  char *nptrb; // [esp+24h] [ebp-4h]

  v1 = (char *)Info_ValueForKey((char *)(a1 + 12), (int)"name");
  Q_strncpyz((char *)(a1 + 68164), v1, 32);
  if ( !Sys_IsLANAddress(*(_DWORD *)(a1 + 338248), *(_DWORD *)(a1 + 338252)) || *(_DWORD *)(dword_835F480 + 32) == 2 )
  {
    nptr = (char *)Info_ValueForKey((char *)(a1 + 12), (int)"rate");
    if ( *nptr )
    {
      *(_DWORD *)(a1 + 338228) = atoi(nptr);
      if ( *(int *)(a1 + 338228) > 999 )
      {
        if ( *(int *)(a1 + 338228) > 90000 )
          *(_DWORD *)(a1 + 338228) = 90000;
      }
      else
      {
        *(_DWORD *)(a1 + 338228) = 1000;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 338228) = 5000;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 338228) = 99999;
  }
  nptra = (char *)Info_ValueForKey((char *)(a1 + 12), (int)"handicap");
  if ( *nptra )
  {
    v3 = atoi(nptra);
    if ( v3 <= 0 || v3 > 100 || strlen(nptra) > 4 )
      Info_SetValueForKey((char *)(a1 + 12), "handicap", (int)"100");
  }
  nptrb = (char *)Info_ValueForKey((char *)(a1 + 12), (int)"snaps");
  if ( *nptrb )
  {
    v4 = atoi(nptrb);
    if ( v4 > 0 )
    {
      if ( v4 > 30 )
        v4 = 30;
    }
    else
    {
      v4 = 1;
    }
    *(_DWORD *)(a1 + 338232) = 1000 / v4;
  }
  else
  {
    *(_DWORD *)(a1 + 338232) = 50;
  }
  result = (const char *)Info_ValueForKey((char *)(a1 + 12), (int)"cl_wwwDownload");
  *(_DWORD *)(a1 + 68612) = 0;
  if ( *result )
  {
    result = (const char *)atoi(result);
    if ( result )
    {
      result = (const char *)a1;
      *(_DWORD *)(a1 + 68612) = 1;
    }
  }
  return result;
}
// 835F480: using guessed type int dword_835F480;

//----- (0808C743) --------------------------------------------------------
int __cdecl sub_808C743(int a1)
{
  char *v1; // eax

  v1 = Cmd_Argv(1u);
  Q_strncpyz((char *)(a1 + 12), v1, 1024);
  SV_UserinfoChanged(a1);
  return VM_Call((int)gvm, 6);
}

//----- (0808C7A9) --------------------------------------------------------
char **__cdecl SV_ExecuteClientCommand(int a1, int a2, int a3)
{
  char **result; // eax
  char *v4; // eax
  char **i; // [esp+14h] [ebp-4h]

  XAnimSetUser(1);
  Cmd_TokenizeString((char **)a2);
  for ( i = &off_80EE680; ; i += 2 )
  {
    result = i;
    if ( !*i )
      break;
    v4 = Cmd_Argv(0);
    if ( !strcmp(v4, *i) )
    {
      result = (char **)((int (__cdecl *)(int))i[1])(a1);
      break;
    }
  }
  if ( a3 )
  {
    result = i;
    if ( !*i && sv == 2 )
      result = (char **)VM_Call((int)gvm, 8);
  }
  return result;
}
// 80EE680: using guessed type char *off_80EE680;
// 836B820: using guessed type int sv;

//----- (0808C858) --------------------------------------------------------
int __cdecl SV_ClientCommand(int a1, int a2)
{
  char *v2; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v6 = 1;
  v5 = 1;
  v8 = MSG_ReadLong((_DWORD *)a2);
  v7 = (char *)MSG_ReadString(a2);
  if ( *(_DWORD *)(a1 + 67132) >= v8 )
    return 1;
  if ( *(_DWORD *)(dword_83E1E90 + 32) )
    Com_Printf("clientCommand: %i : %s\n", v8);
  if ( v8 <= *(_DWORD *)(a1 + 67132) + 1 )
  {
    if ( !Q_strncmp("team ", v7, 5) || !Q_strncmp("score ", v7, 6) || !Q_strncmp("mr ", v7, 3) )
      v5 = 0;
    if ( !*(_DWORD *)(dword_8360658 + 32)
      && *(int *)a1 > 3
      && *(_DWORD *)(dword_836B7D8 + 32)
      && dword_83CCD88 < *(_DWORD *)(a1 + 68632)
      && v5 )
    {
      v6 = 0;
      v2 = Cmd_Argv(0);
      Com_DPrintf("client text ignored for %s: %s\n", (const char *)(a1 + 68164), v2);
    }
    if ( v5 )
      *(_DWORD *)(a1 + 68632) = dword_83CCD88 + 800;
    SV_ExecuteClientCommand(a1, (int)v7, v6);
    *(_DWORD *)(a1 + 67132) = v8;
    Com_sprintf((char *)(a1 + 67136), 0x400u, "%s", v7);
    v4 = 1;
  }
  else
  {
    Com_Printf("Client %s lost %i clientCommands\n", a1 + 68);
    SV_DropClient(a1, (int)"EXE_LOSTRELIABLECOMMANDS");
    v4 = 0;
  }
  return v4;
}
// 8360658: using guessed type int dword_8360658;
// 836B7D8: using guessed type int dword_836B7D8;
// 83CCD88: using guessed type int dword_83CCD88;
// 83E1E90: using guessed type int dword_83E1E90;

//----- (0808CA58) --------------------------------------------------------
_DWORD *__cdecl SV_ClientThink(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  a1[16777] = *a2;
  a1[16778] = a2[1];
  a1[16779] = a2[2];
  a1[16780] = a2[3];
  a1[16781] = a2[4];
  a1[16782] = a2[5];
  result = a1;
  if ( *a1 == 4 )
  {
    XAnimSetUser(1);
    result = (_DWORD *)VM_Call((int)gvm, 9);
  }
  return result;
}

//----- (0808CADE) --------------------------------------------------------
void __cdecl SV_UserMove(int a1, int a2, int a3)
{
  char v3; // [esp+4h] [ebp-354h]
  int v4[3]; // [esp+8h] [ebp-350h]
  int v5; // [esp+14h] [ebp-344h]
  char *v6; // [esp+18h] [ebp-340h]
  _DWORD *v7; // [esp+1Ch] [ebp-33Ch]
  _DWORD v8[192]; // [esp+20h] [ebp-338h] BYREF
  char s[36]; // [esp+320h] [ebp-38h] BYREF
  int v10; // [esp+344h] [ebp-14h]
  int v11; // [esp+348h] [ebp-10h]
  int i; // [esp+34Ch] [ebp-Ch]

  if ( a3 )
    *(_DWORD *)(a1 + 68628) = *(_DWORD *)(a1 + 67096);
  else
    *(_DWORD *)(a1 + 68628) = -1;
  if ( *(_DWORD *)(a1 + 67084) - *(_DWORD *)(a1 + 67088) <= 63 )
  {
    v10 = MSG_ReadByte((_DWORD *)a2);
    if ( v10 > 0 )
    {
      if ( v10 <= 32 )
      {
        v11 = dword_836B82C;
        v11 = *(_DWORD *)(a1 + 67096) ^ dword_836B82C;
        v11 ^= Com_HashKey(a1 + 1032 * (*(_DWORD *)(a1 + 67088) & 0x3F) + 1036, 32);
        v5 = SV_GameClientNum(-266129563 * ((a1 - (int)dword_83CCD90) >> 2));
        MSG_SetDefaultUserCmd(v5, s);
        v6 = s;
        for ( i = 0; i < v10; ++i )
        {
          v7 = &v8[6 * i];
          sub_8080CAB((_DWORD *)a2, v11, (int)v6, (int)v7);
          v4[0] = *((unsigned __int8 *)v7 + 6);
          if ( !VM_Call((int)gvm, 16) )
            *((_BYTE *)v7 + 6) = *(_BYTE *)(v5 + 176);
          v6 = (char *)v7;
        }
        *(_DWORD *)(a1 + 8424 * (*(_DWORD *)(a1 + 67096) & 0x1F) + 77072) = dword_83CCD88;
        if ( *(_DWORD *)a1 == 3 )
        {
          XAnimSetUser(1);
          SV_ClientEnterWorld((char *)a1, v8);
        }
        if ( !*(_DWORD *)(dword_83CCD58 + 32) || *(_DWORD *)(a1 + 338236) )
        {
          if ( *(_DWORD *)a1 == 4 )
          {
            for ( i = 0; i < v10; ++i )
            {
              if ( v8[6 * i] <= v4[6 * v10] && v8[6 * i] > *(_DWORD *)(a1 + 67108) )
                SV_ClientThink((_DWORD *)a1, &v8[6 * i]);
            }
          }
          else
          {
            *(_DWORD *)(a1 + 68628) = -1;
          }
        }
        else
        {
          SV_DropClient(a1, (int)"EXE_CANNOTVALIDATEPURECLIENT");
        }
      }
      else
      {
        Com_Printf("cmdCount > MAX_PACKET_USERCMDS\n", v3);
      }
    }
    else
    {
      Com_Printf("cmdCount < 1\n", v3);
    }
  }
}
// 808CB47: variable 'v3' is possibly undefined
// 836B82C: using guessed type int dword_836B82C;
// 83CCD58: using guessed type int dword_83CCD58;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (0808CDD0) --------------------------------------------------------
void __cdecl SV_ExecuteClientMessage(int a1, _DWORD *a2)
{
  _BYTE v2[16384]; // [esp+20h] [ebp-4038h] BYREF
  _DWORD s[11]; // [esp+4020h] [ebp-38h] BYREF
  char v4[4]; // [esp+404Ch] [ebp-Ch]

  MSG_Init(s, (int)v2, 0x4000);
  s[3] = MSG_ReadBitsCompress(a2[1] + a2[4], v2, a2[3] - a2[4]);
  if ( *(_DWORD *)(a1 + 371084) == *(_DWORD *)dword_80EE800 || *(_BYTE *)(a1 + 68196) )
  {
    while ( 1 )
    {
      *(_DWORD *)v4 = MSG_ReadBits(s, 2);
      if ( *(_DWORD *)v4 == 3 || *(_DWORD *)v4 != 2 )
        break;
      if ( !SV_ClientCommand(a1, (int)s) || *(_DWORD *)a1 == 1 )
        return;
    }
    if ( *(_DWORD *)(dword_83CCD58 + 32) && *(_DWORD *)(a1 + 338236) == 2 )
    {
      *(_DWORD *)(a1 + 68644) = -1;
      *(_DWORD *)a1 = 4;
      SV_SendClientSnapshot(a1);
      SV_DropClient(a1, (int)"EXE_UNPURECLIENTDETECTED");
    }
    if ( *(_DWORD *)v4 )
    {
      if ( *(_DWORD *)v4 == 1 )
      {
        SV_UserMove(a1, (int)s, 0);
      }
      else if ( *(_DWORD *)v4 != 3 )
      {
        Com_Printf("WARNING: bad command byte %i for client %i\n", v4[0]);
      }
    }
    else
    {
      SV_UserMove(a1, (int)s, 1);
    }
  }
  else if ( (*(_DWORD *)(a1 + 371084) & 0xF0) == (dword_80EE800[0] & 0xF0) )
  {
    if ( *(_DWORD *)a1 == 3 )
    {
      XAnimSetUser(1);
      SV_ClientEnterWorld((char *)a1, (_DWORD *)(a1 + 67108));
    }
  }
  else if ( *(_DWORD *)(a1 + 67096) > *(_DWORD *)(a1 + 67100) )
  {
    Com_DPrintf("%s : dropped gamestate, resending\n", (const char *)(a1 + 68164));
    SV_SendClientGameState((char *)a1);
    if ( *(_DWORD *)(dword_8360800 + 32) || !Sys_IsLANAddress(*(_DWORD *)(a1 + 338248), *(_DWORD *)(a1 + 338252)) )
      sub_8088E3B(
        *(_DWORD *)(a1 + 338248),
        *(_DWORD *)(a1 + 338252),
        *(_DWORD *)(a1 + 338256),
        *(_DWORD *)(a1 + 338260),
        *(_DWORD *)(a1 + 338264),
        *(_DWORD *)(a1 + 67104));
  }
}
// 8360800: using guessed type int dword_8360800;
// 83CCD58: using guessed type int dword_83CCD58;

//----- (0808D083) --------------------------------------------------------
int SV_AddTestClient()
{
  _DWORD v2[10]; // [esp+40h] [ebp-458h] BYREF
  char *i; // [esp+68h] [ebp-430h]
  int v4; // [esp+6Ch] [ebp-42Ch]
  int v5; // [esp+70h] [ebp-428h] BYREF
  int v6; // [esp+74h] [ebp-424h]
  int v7; // [esp+78h] [ebp-420h]
  int v8; // [esp+7Ch] [ebp-41Ch]
  int v9; // [esp+80h] [ebp-418h]
  char s[1032]; // [esp+90h] [ebp-408h] BYREF

  v4 = 0;
  for ( i = (char *)dword_83CCD90; v4 < *(_DWORD *)(dword_836B804 + 32) && *(_DWORD *)i; i += 371124 )
    ++v4;
  if ( v4 == *(_DWORD *)(dword_836B804 + 32) )
    return -1;
  sprintf(
    s,
    "connect \"\\cl_guid\\unknown\\cg_predictItems\\1\\cl_punkbuster\\0\\cl_anonymous\\0\\handicap\\100\\color\\4\\head\\"
    "default\\model\\multi\\snaps\\20\\rate\\5000\\name\\bot%d\\protocol\\%d\"",
    dword_80EE6D8,
    6);
  Cmd_TokenizeString((char **)s);
  memset(&v5, 0, 0x14u);
  v5 = 0;
  HIWORD(v9) = dword_80EE6D8++;
  SV_DirectConnect(0, v6, v7, v8, v9);
  v4 = 0;
  for ( i = (char *)dword_83CCD90;
        v4 < *(_DWORD *)(dword_836B804 + 32)
     && (!*(_DWORD *)i
      || !NET_CompareBaseAdr(
            v5,
            v6,
            v7,
            v8,
            v9,
            *((_DWORD *)i + 84562),
            *((_DWORD *)i + 84563),
            *((_DWORD *)i + 84564),
            *((_DWORD *)i + 84565),
            *((_DWORD *)i + 84566)));
        i += 371124 )
  {
    ++v4;
  }
  if ( v4 == *(_DWORD *)(dword_836B804 + 32) )
    return -1;
  XAnimSetUser(1);
  *((_DWORD *)i + 92770) = 1;
  SV_SendClientGameState(i);
  memset(v2, 0, 0x18u);
  SV_ClientEnterWorld(i, v2);
  return v4;
}
// 80EE6D8: using guessed type int dword_80EE6D8;
// 836B804: using guessed type int dword_836B804;

//----- (0808D314) --------------------------------------------------------
int __cdecl sub_808D314(int a1)
{
  return dword_83CCC3C + a1 * dword_83CCC40;
}
// 83CCC3C: using guessed type int dword_83CCC3C;
// 83CCC40: using guessed type int dword_83CCC40;

//----- (0808D331) --------------------------------------------------------
int __cdecl SV_GameClientNum(int a1)
{
  return dword_83CCC48 + a1 * dword_83CCC4C;
}
// 83CCC48: using guessed type int dword_83CCC48;
// 83CCC4C: using guessed type int dword_83CCC4C;

//----- (0808D34E) --------------------------------------------------------
int __cdecl sub_808D34E(int *a1)
{
  if ( !a1 || *a1 < 0 || *a1 > 1023 )
    Com_Error(1, (char *)&byte_80DEF60);
  return 380 * *a1 + 137813048;
}

//----- (0808D395) --------------------------------------------------------
int __cdecl sub_808D395(int a1)
{
  return sub_808D314(-723362913 * ((a1 + -(int)&sv - 9240) >> 2));
}
// 836B820: using guessed type int sv;

//----- (0808D3C3) --------------------------------------------------------
int __cdecl sub_808D3C3(int a1, int a2, const char *a3)
{
  int result; // eax

  if ( a1 == -1 )
    return SV_SendServerCommand(0, a2, "%s", a3);
  if ( a1 >= 0 )
  {
    result = a1;
    if ( a1 < *(_DWORD *)(dword_836B804 + 32) )
      result = SV_SendServerCommand((int)dword_83CCD90 + 371124 * a1, a2, "%s", a3);
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (0808D436) --------------------------------------------------------
void __cdecl sub_808D436(int a1, int a2)
{
  if ( a1 >= 0 && a1 < *(_DWORD *)(dword_836B804 + 32) )
    SV_DropClient((int)dword_83CCD90 + 371124 * a1, a2);
}
// 836B804: using guessed type int dword_836B804;

//----- (0808D470) --------------------------------------------------------
int __cdecl sub_808D470(_DWORD *a1)
{
  int v2[4]; // [esp+10h] [ebp-38h] BYREF
  int v3[7]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+3Ch] [ebp-Ch]

  v4 = sub_804BCA0(a1[35]);
  sub_804BEB3(v4, v3, v2);
  a1[65] = v3[0];
  a1[66] = v3[1];
  a1[67] = v3[2];
  a1[68] = v2[0];
  a1[69] = v2[1];
  a1[70] = v2[2];
  a1[64] = 1;
  a1[71] = -1;
  return sub_8098DF6(a1);
}

//----- (0808D512) --------------------------------------------------------
_BOOL4 __cdecl sub_808D512(float *a1, float *a2)
{
  _BOOL4 v3; // [esp+10h] [ebp-18h]
  char *v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+24h] [ebp-4h]
  int v10; // [esp+24h] [ebp-4h]

  v9 = sub_805740A(a1);
  v7 = sub_804BCF0(v9);
  v6 = sub_804BD06(v9);
  v4 = sub_8057A1A(v7);
  v10 = sub_805740A(a2);
  v8 = sub_804BCF0(v10);
  v5 = sub_804BD06(v10);
  if ( !v4 || (((int)(unsigned __int8)v4[v8 >> 3] >> (v8 & 7)) & 1) != 0 )
    v3 = sub_8057C89(v6, v5);
  else
    v3 = 0;
  return v3;
}

//----- (0808D5D2) --------------------------------------------------------
int __cdecl sub_808D5D2(float *a1, int a2)
{
  _BOOL4 v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  char *v5; // [esp+24h] [ebp-24h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int v7; // [esp+30h] [ebp-18h]
  int v8; // [esp+34h] [ebp-14h]
  int v9; // [esp+38h] [ebp-10h]
  int v10; // [esp+3Ch] [ebp-Ch]
  _DWORD *v11; // [esp+40h] [ebp-8h]
  int *v12; // [esp+44h] [ebp-4h]

  v12 = (int *)sub_808D314(a2);
  if ( !v12[60] )
    return 0;
  if ( (v12[61] & 1) != 0 )
    return 0;
  if ( (v12[61] & 0x18) != 0 || v12[63] )
    return 1;
  v11 = (_DWORD *)sub_808D34E(v12);
  v8 = sub_805740A(a1);
  v10 = sub_804BD06(v8);
  if ( !sub_8057C89(v10, v11[88]) && !sub_8057C89(v10, v11[89]) )
    return 0;
  if ( !v11[70] )
    return 0;
  v9 = sub_804BCF0(v8);
  v5 = sub_8057A1A(v9);
  v7 = 0;
  for ( i = 0; i < v11[70]; ++i )
  {
    v7 = v11[i + 71];
    if ( (((int)(unsigned __int8)v5[v7 >> 3] >> (v7 & 7)) & 1) != 0 )
      break;
  }
  if ( i != v11[70] )
    goto LABEL_25;
  if ( !v11[87] )
    return 0;
  while ( v7 <= v11[87] && (((int)(unsigned __int8)v5[v7 >> 3] >> (v7 & 7)) & 1) == 0 )
    ++v7;
  if ( v7 == v11[87] )
    return 0;
LABEL_25:
  v4 = COERCE_FLOAT(VM_Call((int)gvm, 23));
  if ( v4 == 3.4028235e38 )
    v3 = 1;
  else
    v3 = loc_806AC6E((int)(v12 + 72), (int)(v12 + 75), (int)a1, v4) == 0;
  return v3;
}

//----- (0808D837) --------------------------------------------------------
_BOOL4 __cdecl sub_808D837(float *a1, float *a2)
{
  int v2; // eax
  int v3; // eax
  char *v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v2 = sub_805740A(a1);
  v3 = sub_804BCF0(v2);
  v6 = sub_8057A1A(v3);
  v8 = sub_805740A(a2);
  v7 = sub_804BCF0(v8);
  return !v6 || (((int)(unsigned __int8)v6[v7 >> 3] >> (v7 & 7)) & 1) != 0;
}

//----- (0808D8BC) --------------------------------------------------------
int __cdecl sub_808D8BC(int *a1, int a2)
{
  int result; // eax

  result = sub_808D34E(a1);
  if ( *(_DWORD *)(result + 356) != -1 )
    result = sub_8057B6F(*(_DWORD *)(result + 352), *(_DWORD *)(result + 356), a2);
  return result;
}

//----- (0808D905) --------------------------------------------------------
int __cdecl sub_808D905(int *a1, int *a2, int a3, int a4)
{
  int v5[11]; // [esp+30h] [ebp-48h] BYREF
  unsigned __int8 v6; // [esp+5Fh] [ebp-19h]
  int v7; // [esp+64h] [ebp-14h]
  int v8; // [esp+68h] [ebp-10h]
  int v9; // [esp+6Ch] [ebp-Ch]

  v9 = a3 + 312;
  v8 = a3 + 324;
  v7 = sub_8098CA8((int *)a3);
  sub_805B77C(
    v5,
    (float *)&dword_80D7EC8,
    (float *)&dword_80D7EC8,
    a1,
    a2,
    v7,
    -1,
    (float *)(a3 + 312),
    (float *)(a3 + 324),
    a4);
  return v6;
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0808D982) --------------------------------------------------------
char *__cdecl sub_808D982(char *dest, int a2)
{
  char *v2; // eax

  if ( a2 <= 0 )
    Com_Error(1, (char *)&byte_80DEFA0, a2);
  v2 = Cvar_InfoString(8196);
  return Q_strncpyz(dest, v2, a2);
}

//----- (0808D9CD) --------------------------------------------------------
void *__cdecl sub_808D9CD(size_t a1)
{
  if ( sv != 1 )
    Com_Error(1, (char *)&byte_80DEFE0);
  return sub_806C482(a1);
}
// 836B820: using guessed type int sv;

//----- (0808D9FD) --------------------------------------------------------
void *__cdecl sub_808D9FD(size_t a1)
{
  if ( sv != 1 )
    Com_Error(1, (char *)&byte_80DF040);
  return sub_806C5DF(a1);
}
// 836B820: using guessed type int sv;

//----- (0808DA2D) --------------------------------------------------------
void *__cdecl sub_808DA2D(size_t n, int a2)
{
  if ( sv != 1 )
    Com_Error(1, (char *)&byte_80DF0A0);
  return sub_806C49D(n, a2);
}
// 836B820: using guessed type int sv;

//----- (0808DA64) --------------------------------------------------------
void *__cdecl sub_808DA64(size_t n, int a2)
{
  if ( sv != 1 )
    Com_Error(1, (char *)&byte_80DF100);
  return sub_806C5FA(n, a2);
}
// 836B820: using guessed type int sv;

//----- (0808DA9B) --------------------------------------------------------
_DWORD *__cdecl sub_808DA9B(size_t size)
{
  return sub_806C6AE(size);
}

//----- (0808DAAE) --------------------------------------------------------
int __cdecl sub_808DAAE(void *ptr)
{
  return sub_806C7F0(ptr);
}

//----- (0808DAC1) --------------------------------------------------------
int __cdecl sub_808DAC1(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  dword_83CCC3C = a1;
  dword_83CCC40 = a3;
  dword_83CCC44 = a2;
  dword_83CCC48 = a4;
  result = a5;
  dword_83CCC4C = a5;
  return result;
}
// 83CCC3C: using guessed type int dword_83CCC3C;
// 83CCC40: using guessed type int dword_83CCC40;
// 83CCC44: using guessed type int dword_83CCC44;
// 83CCC48: using guessed type int dword_83CCC48;
// 83CCC4C: using guessed type int dword_83CCC4C;

//----- (0808DAEE) --------------------------------------------------------
int __cdecl sub_808DAEE(int a1, _DWORD *a2)
{
  _DWORD *v2; // edx
  int result; // eax

  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_836B804 + 32) )
    Com_Error(1, (char *)&byte_80DF180, a1);
  v2 = dword_83CCD90;
  *a2 = *((_DWORD *)dword_83CCD90 + 92781 * a1 + 16777);
  a2[1] = v2[92781 * a1 + 16778];
  a2[2] = v2[92781 * a1 + 16779];
  a2[3] = v2[92781 * a1 + 16780];
  a2[4] = v2[92781 * a1 + 16781];
  result = v2[92781 * a1 + 16782];
  a2[5] = result;
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (0808DB7B) --------------------------------------------------------
int __cdecl sub_808DB7B(int a1)
{
  return a1;
}

//----- (0808DB8C) --------------------------------------------------------
int __cdecl sub_808DB8C(char *s1)
{
  if ( strncasecmp(s1, "xmodel", 6u) || s1[6] != 47 && s1[6] != 92 )
    Com_Error(1, (char *)&byte_80DF1A8, s1);
  return sub_80CE498(s1 + 7, 0, (int (__cdecl *)(int))sub_80723E0);
}

//----- (0808DC0C) --------------------------------------------------------
int __cdecl sub_808DC0C(int a1)
{
  int result; // eax
  int v2; // [esp+4h] [ebp-4h]

  result = dword_835F4A8;
  if ( *(_DWORD *)(dword_835F4A8 + 32) )
  {
    v2 = sub_8071F32(a1);
    if ( v2 )
      result = sub_80D0022(v2);
    else
      result = Com_Printf("no model.\n", 0);
  }
  return result;
}
// 835F4A8: using guessed type int dword_835F4A8;

//----- (0808DC4E) --------------------------------------------------------
int __cdecl sub_808DC4E(int a1, int a2)
{
  int *v4; // [esp+Ch] [ebp-Ch]
  int size; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_8071F32(a1);
  if ( sub_80D16B6(v6, dword_835F4A4) )
    return sub_80D0874(v6, a2);
  size = sub_80D1690(v6);
  v4 = sub_806C6AE(size);
  sub_80D1730(v6, v4);
  return 0;
}
// 835F4A4: using guessed type int dword_835F4A4;

//----- (0808DCCB) --------------------------------------------------------
int __cdecl sub_808DCCB(int a1, int a2)
{
  int *v4; // [esp+Ch] [ebp-Ch]
  int size; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  v6 = sub_8071F32(a1);
  if ( sub_80D16B6(v6, dword_835F4A4) )
    return sub_80D08A2(v6, a2);
  size = sub_80D1690(v6);
  v4 = sub_806C6AE(size);
  sub_80D1730(v6, v4);
  return 0;
}
// 835F4A4: using guessed type int dword_835F4A4;

//----- (0808DD48) --------------------------------------------------------
int __cdecl sub_808DD48(int a1, float a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v5 = sub_8071F32(a1);
  if ( v5 )
    v4 = sub_80C9E0E(v5, a2, a3);
  else
    v4 = 0;
  return v4;
}

//----- (0808DD8C) --------------------------------------------------------
void __cdecl sub_808DD8C(int a1, float a2)
{
  int *v2; // [esp+14h] [ebp-4h]

  v2 = (int *)sub_8071F32(a1);
  if ( v2 )
    sub_80C9D88(v2, a2);
}

//----- (0808DDBC) --------------------------------------------------------
int __cdecl sub_808DDBC(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_8071F32(a1);
  return sub_80D049E(v4, a2, a3);
}

//----- (0808DDEB) --------------------------------------------------------
int *__cdecl sub_808DDEB(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8071F32(a1);
  return sub_80C9F14(v3, a2);
}

//----- (0808DE13) --------------------------------------------------------
int *__cdecl sub_808DE13(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = sub_8071F32(a1);
  return sub_80D0902(v3, a2);
}

//----- (0808DE3B) --------------------------------------------------------
int __cdecl sub_808DE3B(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_8071F32(a1);
  return sub_80D1E9E(v2);
}

//----- (0808DE5C) --------------------------------------------------------
int __cdecl sub_808DE5C(int a1, char *s)
{
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_8071F32(a1);
  if ( v4 )
    v3 = sub_80D1D5C(v4, s);
  else
    v3 = -1;
  return v3;
}

//----- (0808DE99) --------------------------------------------------------
int __cdecl sub_808DE99(int a1)
{
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_8071F32(a1);
  return sub_80D12C8(v2, 0);
}

//----- (0808DEC2) --------------------------------------------------------
int **__cdecl sub_808DEC2(int a1)
{
  int **result; // eax

  result = (int **)sub_8071F32(a1);
  if ( result )
    result = (int **)sub_80CA206(result);
  return result;
}

//----- (0808DEEB) --------------------------------------------------------
int __cdecl sub_808DEEB(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_8071F32(a1);
  return sub_80D17C6(v2);
}

//----- (0808DF0C) --------------------------------------------------------
int __cdecl sub_808DF0C(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_8071F32(a1);
  return sub_80D1860(v4, a2, a3);
}

//----- (0808DF3B) --------------------------------------------------------
int __cdecl sub_808DF3B(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  v4 = sub_8071F32(a1);
  return sub_80D18E2(v4, a2, a3);
}

//----- (0808DF6A) --------------------------------------------------------
int __cdecl sub_808DF6A(int a1)
{
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_8071F32(a1);
  return sub_80D1E48(v2);
}

//----- (0808E037) --------------------------------------------------------
void sub_808E037()
{
  ;
}

//----- (0808E03C) --------------------------------------------------------
_BOOL4 __cdecl sub_808E03C(char *s)
{
  char *haystack; // [esp+10h] [ebp-8h]
  char *v3; // [esp+14h] [ebp-4h]

  v3 = sub_8087538(s);
  haystack = va("maps/mp/%s.bsp", v3);
  return (FS_ReadFile(haystack, 0) & 0x80000000) == 0;
}

//----- (0808E08C) --------------------------------------------------------
void *sub_808E08C()
{
  void *result; // eax

  result = sub_804BCE6();
  dword_83CCC38 = (int)result;
  return result;
}
// 83CCC38: using guessed type int dword_83CCC38;

//----- (0808E09E) --------------------------------------------------------
int __cdecl sub_808E09E(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v12; // [esp+0h] [ebp-58h]
  int v13; // [esp+0h] [ebp-58h]
  int v14; // [esp+0h] [ebp-58h]
  int v15; // [esp+40h] [ebp-18h]
  int v16; // [esp+4Ch] [ebp-Ch]
  int v17; // [esp+4Ch] [ebp-Ch]
  int v18; // [esp+4Ch] [ebp-Ch]
  int v19; // [esp+4Ch] [ebp-Ch]
  int v20; // [esp+4Ch] [ebp-Ch]
  int v21; // [esp+4Ch] [ebp-Ch]
  char *src; // [esp+50h] [ebp-8h]
  float v23; // [esp+54h] [ebp-4h]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
      Com_Printf("%s", *(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 1:
      Com_Error(1, (char *)&byte_80DF1D7, *(_DWORD *)(a1 + 4));
    case 2:
      Com_Error(1, "%s", *(const char **)(a1 + 4));
    case 3:
      v15 = sub_80D563C();
      break;
    case 4:
      sub_807323C(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8), *(char **)(a1 + 12), *(_DWORD *)(a1 + 16));
      v15 = 0;
      break;
    case 5:
      sub_8073293(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 6:
      Cvar_Set(*(char **)(a1 + 4), *(char **)(a1 + 8));
      v15 = 0;
      break;
    case 7:
      v15 = sub_807344B(*(_DWORD *)(a1 + 4));
      break;
    case 8:
      v23 = Cvar_VariableValue(*(_DWORD *)(a1 + 4));
      **(float **)(a1 + 8) = v23;
      v15 = 0;
      break;
    case 9:
      sub_80734AD(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0xA:
      v15 = Cmd_Argc();
      break;
    case 0xB:
      sub_8060120(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0xC:
      v15 = (int)sub_808D9CD(*(_DWORD *)(a1 + 4));
      break;
    case 0xD:
      v15 = (int)sub_808D9FD(*(_DWORD *)(a1 + 4));
      break;
    case 0xE:
      v15 = (int)sub_808DA2D(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0xF:
      v15 = (int)sub_808DA64(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x10:
      v15 = (int)sub_808DA9B(*(_DWORD *)(a1 + 4));
      break;
    case 0x11:
      sub_808DAAE(*(void **)(a1 + 4));
      v15 = 0;
      break;
    case 0x12:
      v15 = FS_FOpenFileByMode(*(char **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x13:
      FS_Read(*(char **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x14:
      v15 = FS_Write(*(char **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x15:
      sub_80611A9(*(char **)(a1 + 4), *(char **)(a1 + 8));
      v15 = 0;
      break;
    case 0x16:
      FS_FCloseFile(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x17:
      Cbuf_ExecuteText(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8));
      v15 = 0;
      break;
    case 0x18:
      sub_808DAC1(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20));
      v15 = 0;
      break;
    case 0x19:
      if ( *(int *)(a1 + 4) >= 0 && *(_DWORD *)(a1 + 4) < *(_DWORD *)(dword_836B804 + 32) )
        v15 = *((_DWORD *)dword_83CCD90 + 92781 * *(_DWORD *)(a1 + 4) + 92768);
      else
        v15 = 0;
      break;
    case 0x1A:
      sub_808D436(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x1B:
      sub_808D3C3(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(const char **)(a1 + 12));
      v15 = 0;
      break;
    case 0x1C:
      SV_SetConfigstring(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8));
      v15 = 0;
      break;
    case 0x1D:
      sub_8090144(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x1E:
      v15 = (int)sub_80901CE(*(_DWORD *)(a1 + 4));
      break;
    case 0x1F:
      v15 = NET_IsLocalAddress(*((_DWORD *)dword_83CCD90 + 92781 * *(_DWORD *)(a1 + 4) + 84562));
      break;
    case 0x20:
      v15 = *((_DWORD *)dword_83CCD90 + 92781 * *(_DWORD *)(a1 + 4) + 84556);
      break;
    case 0x21:
      sub_80903B5(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x22:
      sub_809030B(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8));
      v15 = 0;
      break;
    case 0x23:
      sub_808D982(*(char **)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x24:
      sub_808D470(*(_DWORD **)(a1 + 4));
      v15 = 0;
      break;
    case 0x25:
      sub_8099FD1(
        *(void **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(int **)(a1 + 12),
        *(int **)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        0,
        0,
        0,
        0);
      v15 = 0;
      break;
    case 0x26:
      sub_8099FD1(
        *(void **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(int **)(a1 + 12),
        *(int **)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        1,
        0,
        0,
        0);
      v15 = 0;
      break;
    case 0x27:
      sub_809A4F9(
        *(int **)(a1 + 4),
        *(int **)(a1 + 8),
        *(int **)(a1 + 12),
        *(int **)(a1 + 16),
        *(int **)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        *(_DWORD *)(a1 + 32),
        0);
      v15 = 0;
      break;
    case 0x28:
      sub_809A4F9(
        *(int **)(a1 + 4),
        *(int **)(a1 + 8),
        *(int **)(a1 + 12),
        *(int **)(a1 + 16),
        *(int **)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        *(_DWORD *)(a1 + 32),
        1);
      v15 = 0;
      break;
    case 0x29:
      v15 = sub_809A8CD(
              *(_DWORD *)(a1 + 4),
              *(int **)(a1 + 8),
              *(int **)(a1 + 12),
              *(_DWORD *)(a1 + 16),
              *(_DWORD *)(a1 + 20),
              *(_DWORD *)(a1 + 24),
              1);
      break;
    case 0x2A:
      sub_805B311(
        *(int **)(a1 + 4),
        *(float **)(a1 + 8),
        *(float **)(a1 + 12),
        *(int **)(a1 + 16),
        *(int **)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        0);
      v15 = 0;
      break;
    case 0x2B:
      sub_805B311(
        *(int **)(a1 + 4),
        *(float **)(a1 + 8),
        *(float **)(a1 + 12),
        *(int **)(a1 + 16),
        *(int **)(a1 + 20),
        *(_DWORD *)(a1 + 24),
        *(_DWORD *)(a1 + 28),
        1);
      v15 = 0;
      break;
    case 0x2C:
      v15 = sub_805D625(
              0,
              *(_DWORD *)(a1 + 4),
              *(_DWORD *)(a1 + 8),
              *(int **)(a1 + 12),
              *(int **)(a1 + 16),
              *(_DWORD *)(a1 + 20),
              *(_DWORD *)(a1 + 24),
              0);
      break;
    case 0x2D:
      v15 = sub_805D625(
              0,
              *(_DWORD *)(a1 + 4),
              *(_DWORD *)(a1 + 8),
              *(int **)(a1 + 12),
              *(int **)(a1 + 16),
              *(_DWORD *)(a1 + 20),
              *(_DWORD *)(a1 + 24),
              1);
      break;
    case 0x2E:
      sub_8099FD1(
        *(void **)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        0,
        0,
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        0,
        1,
        *(_DWORD *)(a1 + 24),
        1);
      v15 = 0;
      break;
    case 0x2F:
      v15 = sub_809AB1F(*(float **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x30:
      v15 = sub_808D512(*(float **)(a1 + 4), *(float **)(a1 + 8));
      break;
    case 0x31:
      v15 = sub_808D837(*(float **)(a1 + 4), *(float **)(a1 + 8));
      break;
    case 0x32:
      v15 = sub_808D5D2(*(float **)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x33:
      sub_808D8BC(*(int **)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x34:
      v15 = sub_8057C89(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x35:
      sub_8098DF6(*(_DWORD **)(a1 + 4));
      v15 = 0;
      break;
    case 0x36:
      sub_8098D51(*(int **)(a1 + 4));
      v15 = 0;
      break;
    case 0x37:
      v15 = sub_805E510(
              *(_DWORD *)(a1 + 4),
              *(_DWORD *)(a1 + 8),
              *(_DWORD *)(a1 + 12),
              *(_DWORD *)(a1 + 16),
              *(_DWORD *)(a1 + 20));
      break;
    case 0x38:
      v15 = sub_808D905(*(int **)(a1 + 4), *(int **)(a1 + 8), *(_DWORD *)(a1 + 12), 0);
      break;
    case 0x39:
      sub_808DAEE(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8));
      v15 = 0;
      break;
    case 0x3A:
      src = (char *)Com_Parse(&dword_83CCC38);
      Q_strncpyz(*(char **)(a1 + 4), src, *(_DWORD *)(a1 + 8));
      v15 = dword_83CCC38 || *src;
      break;
    case 0x3B:
      v15 = sub_806408D(*(char **)(a1 + 4), *(char **)(a1 + 8), *(char **)(a1 + 12), *(_DWORD *)(a1 + 16));
      break;
    case 0x3C:
      v15 = sub_808E03C(*(char **)(a1 + 4));
      break;
    case 0x3D:
      v15 = ((int (__cdecl *)(_DWORD))sub_806BB0A)(*(_DWORD *)(a1 + 4));
      break;
    case 0x3E:
      sub_80D6170(*(float **)(a1 + 4));
      v15 = 0;
      break;
    case 0x3F:
      v15 = sub_808D905(*(int **)(a1 + 4), *(int **)(a1 + 8), *(_DWORD *)(a1 + 12), 1);
      break;
    case 0x40:
      v15 = sub_806E08C(*(char **)(a1 + 4), 2);
      break;
    case 0x41:
      v15 = (int)sub_806E0C3(*(char **)(a1 + 4), 2);
      break;
    case 0x42:
      v15 = sub_806E264(*(_DWORD *)(a1 + 4), 2);
      break;
    case 0x43:
      v15 = sub_8072731();
      break;
    case 0x44:
      v15 = (int)sub_807273B();
      break;
    case 0x45:
      v15 = SV_AddTestClient();
      break;
    case 0x46:
      v15 = sub_8096F65(*(_DWORD *)(a1 + 4), *(int **)(a1 + 8), *(_DWORD *)(a1 + 12), *(void **)(a1 + 16));
      break;
    case 0x47:
      v15 = 0;
      break;
    case 0x48:
      v15 = 0;
      break;
    case 0x49:
      sub_8090B36(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x4A:
      v15 = (int)Z_MallocInternal(*(_DWORD *)(a1 + 4));
      break;
    case 0x4B:
      Z_FreeInternal(*(void **)(a1 + 4));
      v15 = 0;
      break;
    case 0x4C:
      v15 = (int)sub_8072406(*(_DWORD *)(a1 + 4));
      break;
    case 0x4D:
      v15 = (int)sub_807243C(*(_DWORD *)(a1 + 4));
      break;
    case 0x4E:
      sub_8072457(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x4F:
      v15 = sub_80CE462(*(_DWORD *)(a1 + 4));
      break;
    case 0x50:
      v15 = sub_808DB8C(*(char **)(a1 + 4));
      break;
    case 0x51:
      sub_80720BC(
        *(int **)(a1 + 4),
        *(_WORD *)(a1 + 8),
        *(_DWORD **)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_WORD *)(a1 + 20));
      v15 = 0;
      break;
    case 0x52:
      v15 = sub_8071F32(*(_DWORD *)(a1 + 4)) != 0;
      break;
    case 0x53:
      sub_80721EB(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x54:
      v15 = sub_80C43B4(*(_DWORD *)(a1 + 4));
      break;
    case 0x56:
      sub_80CA9FC(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(float *)(a1 + 12));
      v15 = 0;
      break;
    case 0x57:
      sub_80CA88E(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(float *)(a1 + 12));
      v15 = 0;
      break;
    case 0x58:
      sub_80CAA36(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(float *)(a1 + 12));
      v15 = 0;
      break;
    case 0x59:
      sub_80CAC28(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(float *)(a1 + 12),
        *(float *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(unsigned __int16 *)(a1 + 24),
        0,
        *(_DWORD *)(a1 + 28));
      v15 = 0;
      break;
    case 0x5A:
      v15 = sub_80CACB6(
              *(_DWORD *)(a1 + 4),
              *(_DWORD *)(a1 + 8),
              *(_DWORD *)(a1 + 12),
              *(float *)(a1 + 16),
              *(float *)(a1 + 20),
              *(_DWORD *)(a1 + 24),
              *(unsigned __int16 *)(a1 + 28),
              0,
              *(_DWORD *)(a1 + 32));
      break;
    case 0x5B:
      sub_80CBD8C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x5C:
      sub_80CB78A(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x5D:
      sub_80CAE42(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(float *)(a1 + 12),
        *(float *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(unsigned __int16 *)(a1 + 24),
        0,
        *(_DWORD *)(a1 + 28));
      v15 = 0;
      break;
    case 0x5E:
      sub_80CAFD0(*(_DWORD **)(a1 + 4));
      v15 = 0;
      break;
    case 0x5F:
      v1 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80CB730(v1, *(_DWORD *)(a1 + 8));
      break;
    case 0x60:
      v2 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80CB772(v2, *(_DWORD *)(a1 + 8));
      break;
    case 0x61:
      v15 = (int)(sub_80C9B5E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8)) * 1000.0);
      break;
    case 0x62:
      v3 = sub_809B866(*(_DWORD *)(a1 + 4));
      *(float *)&v12 = sub_80C9B5E(v3, *(_DWORD *)(a1 + 8));
      v15 = sub_808DB7B(v12);
      break;
    case 0x63:
      sub_80CBE66(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(float *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(unsigned __int16 *)(a1 + 24),
        0,
        *(_DWORD *)(a1 + 28));
      v15 = 0;
      break;
    case 0x64:
      sub_80CBCDE(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(float *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(_DWORD *)(a1 + 20),
        *(unsigned __int16 *)(a1 + 24),
        0,
        *(_DWORD *)(a1 + 28));
      v15 = 0;
      break;
    case 0x65:
      sub_80CA302(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(float **)(a1 + 12), *(_DWORD **)(a1 + 16));
      v15 = 0;
      break;
    case 0x66:
      sub_80CA24E(
        *(_DWORD *)(a1 + 4),
        *(_DWORD *)(a1 + 8),
        *(float **)(a1 + 12),
        *(_DWORD **)(a1 + 16),
        *(_DWORD *)(a1 + 20));
      v15 = 0;
      break;
    case 0x67:
      v4 = sub_809B866(*(_DWORD *)(a1 + 4));
      sub_80CA3B6(
        v4,
        *(_DWORD *)(a1 + 8),
        *(_DWORD *)(a1 + 12),
        *(_DWORD *)(a1 + 16),
        *(float *)(a1 + 20),
        *(float *)(a1 + 24));
      v15 = 0;
      break;
    case 0x68:
      v5 = sub_809B866(*(_DWORD *)(a1 + 4));
      sub_80CA4F4(v5, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16), *(float *)(a1 + 20));
      v15 = 0;
      break;
    case 0x69:
      v6 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80CBDAE(v6, *(_DWORD *)(a1 + 8));
      break;
    case 0x6A:
      v7 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80CBDF2(v7, *(_DWORD *)(a1 + 8), *(_WORD *)(a1 + 12));
      break;
    case 0x6B:
      *(float *)&v13 = sub_80C9B9C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = sub_808DB7B(v13);
      break;
    case 0x6C:
      *(float *)&v14 = sub_80C9BF4(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = sub_808DB7B(v14);
      break;
    case 0x6D:
      sub_808DC0C(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x6E:
      v15 = sub_808DC4E(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x6F:
      v15 = sub_808DCCB(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x70:
      v15 = sub_808DD48(*(_DWORD *)(a1 + 4), *(float *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x71:
      sub_808DD8C(*(_DWORD *)(a1 + 4), *(float *)(a1 + 8));
      v15 = 0;
      break;
    case 0x72:
      sub_808DDBC(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0x73:
      sub_808DDEB(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x74:
      sub_808DE13(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x75:
      sub_80CC1C8(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x76:
      sub_80CC266(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x77:
      sub_80CC382(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      v15 = 0;
      break;
    case 0x78:
      v15 = sub_808DE3B(*(_DWORD *)(a1 + 4));
      break;
    case 0x79:
      v15 = sub_808DE5C(*(_DWORD *)(a1 + 4), *(char **)(a1 + 8));
      break;
    case 0x7A:
      v15 = sub_808DE99(*(_DWORD *)(a1 + 4));
      break;
    case 0x7B:
      sub_808DEC2(*(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x7C:
      v15 = sub_80C9C4C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
      break;
    case 0x7D:
      v8 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80C9CEE(v8, *(_DWORD *)(a1 + 8));
      break;
    case 0x7E:
      v9 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = sub_80C9CFE(v9, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x7F:
      v15 = sub_80CEBCA(*(_DWORD *)(a1 + 4));
      break;
    case 0x80:
      v15 = sub_80CEBE2(*(_DWORD *)(a1 + 4));
      break;
    case 0x81:
      v15 = sub_808DEEB(*(_DWORD *)(a1 + 4));
      break;
    case 0x82:
      v15 = sub_808DF0C(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x83:
      v15 = sub_808DF3B(*(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0x84:
      v10 = sub_809B866(*(_DWORD *)(a1 + 4));
      v15 = (int)sub_80C9D12(v10, *(_DWORD *)(a1 + 8));
      break;
    case 0x85:
      v15 = sub_808DF6A(*(_DWORD *)(a1 + 4));
      break;
    case 0x86:
      v15 = sub_80C9D54(*(_DWORD *)(a1 + 4));
      break;
    case 0x87:
      sub_808E037();
      v15 = 0;
      break;
    case 0x88:
      v15 = sub_8072472(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), 1);
      break;
    case 0x89:
      sub_80724DB(1, *(_DWORD *)(a1 + 4));
      v15 = 0;
      break;
    case 0x8A:
      sub_808ABB1();
      v15 = 0;
      break;
    case 0x8B:
      sub_808E08C();
      v15 = 0;
      break;
    case 0xC8:
      memset(*(void **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0xC9:
      memcpy(*(void **)(a1 + 4), *(const void **)(a1 + 8), *(_DWORD *)(a1 + 12));
      v15 = 0;
      break;
    case 0xCA:
      v15 = (int)strncpy(*(char **)(a1 + 4), *(const char **)(a1 + 8), *(_DWORD *)(a1 + 12));
      break;
    case 0xCB:
      *(float *)&v16 = sin(*(float *)(a1 + 4));
      v15 = sub_808DB7B(v16);
      break;
    case 0xCC:
      *(float *)&v17 = cos(*(float *)(a1 + 4));
      v15 = sub_808DB7B(v17);
      break;
    case 0xCD:
      *(float *)&v18 = atan2(*(float *)(a1 + 4), *(float *)(a1 + 8));
      v15 = sub_808DB7B(v18);
      break;
    case 0xCE:
      *(float *)&v19 = sqrt(*(float *)(a1 + 4));
      v15 = sub_808DB7B(v19);
      break;
    case 0xCF:
      sub_80679EC(*(float **)(a1 + 4), *(float **)(a1 + 8), *(float **)(a1 + 12));
      v15 = 0;
      break;
    case 0xD0:
      sub_806759D(*(float **)(a1 + 4), *(_DWORD *)(a1 + 8), *(float **)(a1 + 12), *(float **)(a1 + 16));
      v15 = 0;
      break;
    case 0xD1:
      sub_80677A4(*(float **)(a1 + 4), *(float **)(a1 + 8));
      v15 = 0;
      break;
    case 0xD2:
      *(float *)&v20 = floor(*(float *)(a1 + 4));
      v15 = sub_808DB7B(v20);
      break;
    case 0xD3:
      *(float *)&v21 = ceil(*(float *)(a1 + 4));
      v15 = sub_808DB7B(v21);
      break;
    default:
      Com_Error(1, (char *)&byte_80DF1DB, *(_DWORD *)a1);
  }
  return v15;
}
// 806BB0A: using guessed type int sub_806BB0A();
// 808E09E: using guessed type int __cdecl sub_808E09E(int);
// 836B804: using guessed type int dword_836B804;
// 83CCC38: using guessed type int dword_83CCC38;

//----- (0808FD11) --------------------------------------------------------
void *sub_808FD11()
{
  void *result; // eax

  result = (void *)sub_806DFEB(2);
  if ( gvm )
  {
    XAnimSetUser(1);
    VM_Call((int)gvm, 3);
    Hunk_ClearToMarkLow();
    result = sub_809AEF5(gvm);
    gvm = 0;
  }
  return result;
}

//----- (0808FD75) --------------------------------------------------------
void SV_InitGameVM()
{
  int v0; // eax
  int i; // [esp+24h] [ebp-4h]

  dword_83CCC38 = (int)sub_804BCE6();
  sub_80A0B47(0);
  v0 = VM_Call((int)gvm, 14);
  sub_80A0B47(v0);
  sub_80D3C7C();
  Com_Milliseconds();
  VM_Call((int)gvm, 2);
  sub_80D3C7C();
  for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32); ++i )
    *((_DWORD *)dword_83CCD90 + 92781 * i + 17040) = 0;
  if ( *(_DWORD *)(dword_835F480 + 32) )
    sub_8073D90(4);
}
// 835F480: using guessed type int dword_835F480;
// 836B804: using guessed type int dword_836B804;
// 83CCC38: using guessed type int dword_83CCC38;
// 83CCD84: using guessed type int dword_83CCD84;

//----- (0808FE4B) --------------------------------------------------------
void __cdecl SV_RestartGameProgs()
{
  VM_Call((int)gvm, 3);
  Hunk_ClearToMarkLow();
  SV_InitGameVM();
}

//----- (0808FE88) --------------------------------------------------------
void __cdecl sub_808FE88()
{
  int v0; // [esp+14h] [ebp-4h]

  gvm = (void *)sub_809ACE3("game", (int)sub_808E09E);
  if ( !gvm )
    Com_Error(0, (char *)&byte_80DF551);
  v0 = VM_Call((int)gvm, 1);
  if ( v0 != 5 )
    Com_Error(0, (char *)&byte_80DF580, v0, 5);
  sub_806C39F();
  SV_InitGameVM();
}
// 808E09E: using guessed type int __cdecl sub_808E09E(int);

//----- (0808FF1F) --------------------------------------------------------
int sub_808FF1F()
{
  if ( sv != 2 )
    return 0;
  XAnimSetUser(1);
  return VM_Call((int)gvm, 13);
}
// 836B820: using guessed type int sv;

//----- (0808FF60) --------------------------------------------------------
char *__cdecl SV_SetConfigstring(int a1, char *s1)
{
  char *result; // eax
  char dest[1028]; // [esp+20h] [ebp-428h] BYREF
  char v4[4]; // [esp+424h] [ebp-24h]
  int j; // [esp+428h] [ebp-20h]
  int v6; // [esp+42Ch] [ebp-1Ch]
  int i; // [esp+430h] [ebp-18h]
  int v8; // [esp+434h] [ebp-14h]
  char *v9; // [esp+438h] [ebp-10h]
  int v10; // [esp+43Ch] [ebp-Ch]

  v8 = 1000;
  if ( a1 < 0 || a1 > 2047 )
    Com_Error(1, (char *)&byte_80DF5C0, a1);
  if ( !s1 )
    s1 = (char *)&byte_80DF5E3;
  result = (char *)strcmp(s1, (&dword_836BC38)[a1]);
  if ( result )
  {
    Z_FreeInternal((&dword_836BC38)[a1]);
    result = sub_806BC0A(s1);
    (&dword_836BC38)[a1] = result;
    if ( sv == 2 || dword_836B824 )
    {
      v9 = 0;
      for ( i = (int)dword_83CCD90; ; i += 371124 )
      {
        result = v9;
        if ( (int)v9 >= *(_DWORD *)(dword_836B804 + 32) )
          break;
        if ( *(int *)i > 2 )
        {
          v10 = strlen(s1);
          if ( v10 < v8 )
          {
            SV_SendServerCommand(i, 1, "d %i %s", a1, s1);
          }
          else
          {
            v6 = 0;
            for ( j = v10; j > 0; j = j - v8 + 1 )
            {
              if ( v6 )
              {
                if ( j >= v8 )
                  *(_DWORD *)v4 = 135132648;
                else
                  *(_DWORD *)v4 = 135132646;
              }
              else
              {
                *(_DWORD *)v4 = aXzy;
              }
              Q_strncpyz(dest, &s1[v6], v8);
              SV_SendServerCommand(i, 1, "%s %i %s", *(const char **)v4, a1, dest);
              v6 = v6 + v8 - 1;
            }
          }
        }
        ++v9;
      }
    }
  }
  return result;
}
// 80DF5E4: using guessed type __int16 aXzy[3];
// 836B804: using guessed type int dword_836B804;
// 836B820: using guessed type int sv;
// 836B824: using guessed type int dword_836B824;

//----- (08090144) --------------------------------------------------------
char *__cdecl sub_8090144(int a1, char *dest, int a3)
{
  char *result; // eax

  if ( a3 <= 0 )
    Com_Error(1, (char *)&byte_80DF600, a3);
  if ( a1 < 0 || a1 > 2047 )
    Com_Error(1, (char *)&byte_80DF640, a1);
  if ( (&dword_836BC38)[a1] )
    return Q_strncpyz(dest, (&dword_836BC38)[a1], a3);
  result = dest;
  *dest = 0;
  return result;
}

//----- (080901CE) --------------------------------------------------------
const char *__cdecl sub_80901CE(int a1)
{
  const char *v2; // [esp+0h] [ebp-4h]

  v2 = (&dword_836BC38)[a1];
  if ( !v2 )
    v2 = &byte_80DF5E3;
  return v2;
}

//----- (08090270) --------------------------------------------------------
char *__cdecl sub_8090270(int a1, int a2, char *s1, char *a4)
{
  char *s2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < a2; ++i )
  {
    s2 = (&(&dword_836BC38)[a1])[i];
    if ( !*s2 )
    {
      SV_SetConfigstring(a1 + i, s1);
      break;
    }
    if ( !strcasecmp(s1, s2) )
      break;
  }
  if ( i == a2 )
    Com_Error(1, (char *)&byte_80DF680);
  return SV_SetConfigstring(i + a1 + a2, a4);
}

//----- (0809030B) --------------------------------------------------------
char *__cdecl sub_809030B(int a1, char *src)
{
  char *v2; // eax

  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_836B804 + 32) )
    Com_Error(1, (char *)&byte_80DF6C0, a1);
  if ( !src )
    src = (char *)&byte_80DF5E3;
  Q_strncpyz((char *)dword_83CCD90 + 371124 * a1 + 12, src, 1024);
  v2 = (char *)Info_ValueForKey(src, (int)"name");
  return Q_strncpyz((char *)dword_83CCD90 + 371124 * a1 + 68164, v2, 32);
}
// 836B804: using guessed type int dword_836B804;

//----- (080903B5) --------------------------------------------------------
char *__cdecl sub_80903B5(int a1, char *dest, int a3)
{
  if ( a3 <= 0 )
    Com_Error(1, (char *)&byte_80DF700, a3);
  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_836B804 + 32) )
    Com_Error(1, (char *)&byte_80DF740, a1);
  return Q_strncpyz(dest, (char *)dword_83CCD90 + 371124 * a1 + 12, a3);
}
// 836B804: using guessed type int dword_836B804;

//----- (08090437) --------------------------------------------------------
int sub_8090437()
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  int *v2; // [esp+Ch] [ebp-Ch]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= dword_83CCC44 )
      break;
    v2 = (int *)sub_808D314(i);
    if ( v2[60] )
    {
      *v2 = i;
      qmemcpy((char *)&unk_836DC40 + 380 * i, v2, 0xF0u);
      dword_836DD30[95 * i] = v2[61];
      dword_836DD34[95 * i] = v2[62];
      dword_836DD38[95 * i] = v2[72];
      dword_836DD3C[95 * i] = v2[73];
      dword_836DD40[95 * i] = v2[74];
      dword_836DD44[95 * i] = v2[75];
      dword_836DD48[95 * i] = v2[76];
      dword_836DD4C[95 * i] = v2[77];
    }
  }
  return result;
}
// 836DD30: using guessed type int dword_836DD30[];
// 836DD34: using guessed type int dword_836DD34[];
// 836DD38: using guessed type int dword_836DD38[];
// 836DD3C: using guessed type int dword_836DD3C[];
// 836DD40: using guessed type int dword_836DD40[];
// 836DD44: using guessed type int dword_836DD44[];
// 836DD48: using guessed type int dword_836DD48[];
// 83CCC44: using guessed type int dword_83CCC44;

//----- (0809057F) --------------------------------------------------------
int *__cdecl sub_809057F(int a1)
{
  char *v1; // eax
  int *result; // eax
  char *v3; // eax

  Cvar_Get("sv_maxclients", "20", 0);
  *(_DWORD *)(dword_836B804 + 20) = 0;
  if ( *(_DWORD *)(dword_836B804 + 32) >= a1 )
  {
    result = (int *)dword_836B804;
    if ( *(int *)(dword_836B804 + 32) > 64 )
    {
      v3 = va("%i", 64);
      result = Cvar_Set("sv_maxclients", v3);
    }
  }
  else
  {
    v1 = va("%i", a1);
    result = Cvar_Set("sv_maxclients", v1);
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (08090610) --------------------------------------------------------
int *sub_8090610()
{
  if ( svs )
    Com_Error(0, (char *)&byte_80DF773);
  sub_809057F(1);
  dword_83CCD90 = calloc(371124 * *(_DWORD *)(dword_836B804 + 32), 1u);
  if ( !dword_83CCD90 )
    Com_Error(0, (char *)&byte_80DF7A0);
  if ( *(_DWORD *)(dword_835F480 + 32) )
  {
    dword_83CCD94 = *(_DWORD *)(dword_836B804 + 32) << 11;
    dword_83CCD98 = 32 * *(_DWORD *)(dword_836B804 + 32) * *(_DWORD *)(dword_836B804 + 32);
  }
  else
  {
    dword_83CCD94 = *(_DWORD *)(dword_836B804 + 32) << 8;
    dword_83CCD98 = 4 * *(_DWORD *)(dword_836B804 + 32) * *(_DWORD *)(dword_836B804 + 32);
  }
  svs = 1;
  return Cvar_Set("sv_running", "1");
}
// 835F480: using guessed type int dword_835F480;
// 836B804: using guessed type int dword_836B804;
// 83CCD80: using guessed type int svs;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD98: using guessed type int dword_83CCD98;

//----- (08090700) --------------------------------------------------------
int sub_8090700()
{
  int result; // eax
  unsigned int v1; // [esp+14h] [ebp-34h]
  _DWORD *v2; // [esp+18h] [ebp-30h]
  _DWORD *v3; // [esp+1Ch] [ebp-2Ch]
  unsigned int v4; // [esp+20h] [ebp-28h]
  _DWORD *v5; // [esp+24h] [ebp-24h]
  _DWORD *v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+2Ch] [ebp-1Ch]
  _DWORD *ptr; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  int j; // [esp+34h] [ebp-14h]
  int k; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]

  v7 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32); ++i )
  {
    if ( *((int *)dword_83CCD90 + 92781 * i) > 1 && i > v7 )
      v7 = i;
  }
  v8 = v7 + 1;
  v13 = *(_DWORD *)(dword_836B804 + 32);
  sub_809057F(v8);
  result = *(_DWORD *)(dword_836B804 + 32);
  if ( result != v13 )
  {
    ptr = sub_806C6AE(371124 * v8);
    for ( j = 0; j < v8; ++j )
    {
      if ( *((int *)dword_83CCD90 + 92781 * j) <= 1 )
      {
        sub_80D2FE9(&ptr[92781 * j], 0, 0x5A9B4u);
      }
      else
      {
        v6 = &ptr[92781 * j];
        v5 = (char *)dword_83CCD90 + 371124 * j;
        v4 = 371124;
        if ( (((_BYTE)ptr - 76 * (_BYTE)j) & 4) != 0 )
        {
          *v6++ = *v5++;
          v4 = 371120;
        }
        qmemcpy(v6, v5, 4 * (v4 >> 2));
      }
    }
    free(dword_83CCD90);
    dword_83CCD90 = calloc(371124 * *(_DWORD *)(dword_836B804 + 32), 1u);
    if ( !dword_83CCD90 )
      Com_Error(0, (char *)&byte_80DF7A0);
    sub_80D2FE9(dword_83CCD90, 0, 371124 * *(_DWORD *)(dword_836B804 + 32));
    for ( k = 0; k < v8; ++k )
    {
      if ( (int)ptr[92781 * k] > 1 )
      {
        v3 = (char *)dword_83CCD90 + 371124 * k;
        v2 = &ptr[92781 * k];
        v1 = 371124;
        if ( (((_BYTE)dword_83CCD90 - 76 * (_BYTE)k) & 4) != 0 )
        {
          *v3++ = *v2++;
          v1 = 371120;
        }
        qmemcpy(v3, v2, 4 * (v1 >> 2));
      }
    }
    sub_806C7F0(ptr);
    if ( *(_DWORD *)(dword_835F480 + 32) )
    {
      dword_83CCD94 = *(_DWORD *)(dword_836B804 + 32) << 11;
      result = 32 * *(_DWORD *)(dword_836B804 + 32) * *(_DWORD *)(dword_836B804 + 32);
    }
    else
    {
      dword_83CCD94 = *(_DWORD *)(dword_836B804 + 32) << 8;
      result = 4 * *(_DWORD *)(dword_836B804 + 32) * *(_DWORD *)(dword_836B804 + 32);
    }
    dword_83CCD98 = result;
  }
  return result;
}
// 835F480: using guessed type int dword_835F480;
// 836B804: using guessed type int dword_836B804;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD98: using guessed type int dword_83CCD98;

//----- (080909C1) --------------------------------------------------------
int *__cdecl CL_SetExpectedHunkUsage(int a1)
{
  signed int v2; // [esp+10h] [ebp-18h]
  char *s1; // [esp+14h] [ebp-14h]
  char *s1a; // [esp+14h] [ebp-14h]
  void *v5; // [esp+18h] [ebp-10h] BYREF
  void *s; // [esp+1Ch] [ebp-Ch]
  char *src; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h] BYREF

  src = "hunkusage.dat";
  v2 = FS_FOpenFileByMode("hunkusage.dat", (int)&v8, 0);
  if ( v2 >= 0 )
  {
    s = Z_MallocInternal(v2 + 1);
    memset(s, 0, v2 + 1);
    FS_Read((char *)s, v2, v8);
    FS_FCloseFile(v8);
    v5 = s;
    while ( 1 )
    {
      s1 = (char *)Com_Parse(&v5);
      if ( !s1 || !*s1 )
        break;
      if ( !Q_strcasecmp(s1, (char *)a1) )
      {
        s1a = (char *)Com_Parse(&v5);
        if ( s1a )
        {
          if ( *s1a )
          {
            Cvar_Set("com_expectedhunkusage", s1a);
            return (int *)Z_FreeInternal(s);
          }
        }
      }
    }
    Z_FreeInternal(s);
  }
  return Cvar_Set("com_expectedhunkusage", "-1");
}

//----- (08090ADA) --------------------------------------------------------
void *sub_8090ADA()
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    if ( (&dword_836BC38)[i] )
      Z_FreeInternal((&dword_836BC38)[i]);
  }
  return sub_80D2FE9(&sv, 0, 0x6152Cu);
}
// 836B820: using guessed type int sv;

//----- (08090B36) --------------------------------------------------------
void *__cdecl sub_8090B36(int a1)
{
  void *result; // eax

  result = (void *)a1;
  dword_83CCDAC = a1;
  if ( a1 )
  {
    if ( !dword_83CCDB4 )
    {
      dword_83CCDCC = Z_MallocInternal(0x440000u);
      dword_83CCDD0 = Z_MallocInternal(0x212C000u);
      dword_83CCDB4 = Z_MallocInternal(0x2580u);
      dword_83CCDB8 = Z_MallocInternal(0x2000000u);
      result = Z_MallocInternal(0x3800u);
      dword_83CCDD4 = result;
    }
  }
  return result;
}
// 83CCDAC: using guessed type int dword_83CCDAC;

//----- (08090BB1) --------------------------------------------------------
void SV_InitArchivedSnapshot()
{
  dword_83CCDAC = 0;
  dword_83CCDB0 = 0;
  dword_83CCDBC = 0;
  dword_83CCDC0 = 0;
  dword_83CCDC4 = 0;
  dword_83CCDC8 = 0;
}
// 83CCDAC: using guessed type int dword_83CCDAC;
// 83CCDB0: using guessed type int dword_83CCDB0;
// 83CCDBC: using guessed type int dword_83CCDBC;
// 83CCDC0: using guessed type int dword_83CCDC0;
// 83CCDC4: using guessed type int dword_83CCDC4;
// 83CCDC8: using guessed type int dword_83CCDC8;

//----- (08090BF2) --------------------------------------------------------
int sub_8090BF2()
{
  int result; // eax

  if ( dword_83CCDCC )
  {
    result = Z_FreeInternal(dword_83CCDCC);
    dword_83CCDCC = 0;
  }
  if ( dword_83CCDD0 )
  {
    result = Z_FreeInternal(dword_83CCDD0);
    dword_83CCDD0 = 0;
  }
  if ( dword_83CCDB4 )
  {
    result = Z_FreeInternal(dword_83CCDB4);
    dword_83CCDB4 = 0;
  }
  if ( dword_83CCDB8 )
  {
    result = Z_FreeInternal(dword_83CCDB8);
    dword_83CCDB8 = 0;
  }
  if ( dword_83CCDD4 )
  {
    result = Z_FreeInternal(dword_83CCDD4);
    dword_83CCDD4 = 0;
  }
  return result;
}

//----- (08090C9A) --------------------------------------------------------
int SV_InitCvar()
{
  char *v0; // eax
  char *i; // [esp+10h] [ebp-8h]

  v0 = (char *)Cvar_VariableString((int)"g_gametype");
  Q_strncpyz(byte_83CCD0C, v0, 64);
  for ( i = byte_83CCD0C; *i; ++i )
    *i = tolower(*i);
  Cvar_Set("g_gametype", byte_83CCD0C);
  return sub_80733E6();
}

//----- (08090D0F) --------------------------------------------------------
int __cdecl SV_SpawnServer(char *s1)
{
  int *v1; // eax
  char *v2; // eax
  int v3; // eax
  int v4; // ebx
  int v5; // ebx
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  int result; // eax
  char v14; // [esp+4h] [ebp-2044h]
  char v15; // [esp+4h] [ebp-2044h]
  char v16; // [esp+4h] [ebp-2044h]
  int v17; // [esp+20h] [ebp-2028h]
  int *v18; // [esp+28h] [ebp-2020h]
  char *v19; // [esp+2Ch] [ebp-201Ch]
  char *v20; // [esp+2Ch] [ebp-201Ch]
  char *v21; // [esp+2Ch] [ebp-201Ch]
  int dest; // [esp+30h] [ebp-2018h] BYREF
  int v23; // [esp+2038h] [ebp-10h] BYREF
  int i; // [esp+203Ch] [ebp-Ch]

  v1 = Cvar_Get("cl_xmodelcheck", "0", 33);
  XModelEnforceExist(v1[8]);
  Cvar_Get("g_gametype", "dm", 36);
  if ( Cvar_VariableValue((int)"sv_running") != 0.0 )
  {
    if ( VM_Call((int)gvm, 18) )
      Cvar_Set("g_gametype", byte_83CCD0C);
    i = 0;
    v18 = (int *)dword_83CCD90;
    while ( i < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *v18 > 2 )
      {
        v2 = va("loadingnewmap\n%s\n%s", s1, *(const char **)(dword_83CCD68 + 4));
        NET_OutOfBandPrint(1, v18[84562], v18[84563], v18[84564], v18[84565], v18[84566], v2);
      }
      ++i;
      v18 += 92781;
    }
    sub_80D5549(250);
  }
  sub_80846BD();
  sub_80846FE();
  sub_808FD11();
  Com_Printf("------ Server Initialization ------\n", v14);
  Com_Printf("Server: %s\n", (char)s1);
  sub_806C442();
  sub_8090ADA();
  sub_80655EA(1);
  sub_8065B5A(0);
  v3 = sub_80D563C();
  srand(v3);
  v4 = rand() << 16;
  v5 = rand() ^ v4;
  dword_836B82C = v5 ^ sub_80D563C();
  sub_8065CAC(dword_836B82C);
  sub_80654E6();
  for ( i = 0; i <= 2047; ++i )
    (&dword_836BC38)[i] = sub_806BC0A((char *)&byte_80DF5E3);
  if ( Cvar_VariableValue((int)"sv_running") == 0.0 )
  {
    sub_807239D();
    sub_8090610();
  }
  else
  {
    sub_8072313();
    if ( *(_DWORD *)(dword_836B804 + 20) )
      sub_8090700();
  }
  SV_InitCvar();
  dword_83CCDA4 = (int)sub_806C482(240 * dword_83CCD94);
  dword_83CCD9C = 0;
  dword_83CCDA8 = (int)sub_806C482(92 * dword_83CCD98);
  dword_83CCDA0 = 0;
  SV_InitArchivedSnapshot();
  sv_serverId_value ^= 4u;
  Cvar_Set("nextmap", "map_restart");
  v6 = va("maps/mp/%s.bsp", s1);
  CL_SetExpectedHunkUsage((int)v6);
  Cvar_Set("cl_paused", "0");
  v7 = va("maps/mp/%s.bsp", s1);
  CM_LoadMap(v7, 0, (int)&v23);
  Cvar_Set("mapname", s1);
  *(_DWORD *)dword_80EE800 = (unsigned __int8)(dword_80EE800[0] + 16);
  if ( (dword_80EE800[0] & 0xF0) == 0 )
    *(_DWORD *)dword_80EE800 += 16;
  v8 = va("%i", *(_DWORD *)dword_80EE800);
  Cvar_Set("sv_serverid", v8);
  dword_836B828 = dword_835F4BC;
  sv = 1;
  Cvar_Set("sv_serverRestarting", "1");
  v9 = va("maps/mp/%s.bsp", s1);
  sub_806DE0A(v9, 2);
  XAnimSetUser(1);
  sub_808FE88();
  for ( i = 0; i <= 2; ++i )
  {
    dword_83CCD88 += 100;
    dword_83CCD84 += 100;
    SV_RunFrame();
  }
  sub_8090437();
  for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32); ++i )
  {
    if ( *((int *)dword_83CCD90 + 92781 * i) > 1 )
    {
      v17 = VM_Call((int)gvm, 4);
      if ( v17 )
        SV_DropClient((int)dword_83CCD90 + 371124 * i, v17);
      else
        *((_DWORD *)dword_83CCD90 + 92781 * i) = 2;
    }
  }
  if ( *(_DWORD *)(dword_83CCD58 + 32) )
  {
    v19 = sub_8075B76();
    Cvar_Set("sv_paks", v19);
    if ( !*v19 )
      Com_Printf("WARNING: sv_pure set but no PK3 files loaded\n", v15);
    v20 = sub_8075BEE();
    Cvar_Set("sv_pakNames", v20);
  }
  else
  {
    Cvar_Set("sv_paks", (char *)&byte_80DF5E3);
    Cvar_Set("sv_pakNames", (char *)&byte_80DF5E3);
  }
  v10 = FS_ReferencedPakChecksums();
  Cvar_Set("sv_referencedPaks", v10);
  v21 = FS_ReferencedPakNames();
  Cvar_Set("sv_referencedPakNames", v21);
  v11 = Cvar_InfoString_Big(8);
  Q_strncpyz((char *)&dest, v11, 0x2000);
  dword_8360678 &= 0xFFFFFFF7;
  SV_SetConfigstring(1, (char *)&dest);
  v12 = Cvar_InfoString(8196);
  SV_SetConfigstring(0, v12);
  dword_8360678 &= 0xFFFFDFFB;
  SV_SetConfig(140, 64, 2048);
  dword_8360678 &= 0xFFFFF7FF;
  sv = 2;
  SV_Heartbeat_f();
  Cvar_Set("sv_serverRestarting", "0");
  Com_Printf("-----------------------------------\n", v16);
  if ( *(_BYTE *)Cvar_VariableString((int)"sv_punkbuster") == 49 )
    result = sub_80C199C();
  else
    result = sub_80C19D8();
  return result;
}
// 8090E8F: variable 'v14' is possibly undefined
// 8091222: variable 'v15' is possibly undefined
// 809136D: variable 'v16' is possibly undefined
// 835F4BC: using guessed type int dword_835F4BC;
// 8360678: using guessed type int dword_8360678;
// 836B804: using guessed type int dword_836B804;
// 836B820: using guessed type int sv;
// 836B828: using guessed type int dword_836B828;
// 836B82C: using guessed type int dword_836B82C;
// 83CCD58: using guessed type int dword_83CCD58;
// 83CCD68: using guessed type int dword_83CCD68;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCD8C: using guessed type int sv_serverId_value;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD98: using guessed type int dword_83CCD98;
// 83CCD9C: using guessed type int dword_83CCD9C;
// 83CCDA0: using guessed type int dword_83CCDA0;
// 83CCDA4: using guessed type int dword_83CCDA4;
// 83CCDA8: using guessed type int dword_83CCDA8;

//----- (08091398) --------------------------------------------------------
int *__cdecl sub_8091398(char *s1)
{
  return Cvar_Set("sv_punkbuster", s1);
}

//----- (080913B3) --------------------------------------------------------
int *SV_Init()
{
  int *result; // eax
  char *s2; // [esp+14h] [ebp-4h]

  sub_808877F();
  dword_83CCD68 = (int)Cvar_Get("g_gametype", "dm", 36);
  Cvar_Get("sv_keywords", (char *)&byte_80DF5E3, 4);
  s2 = va("%i", 6);
  Cvar_Get("protocol", s2, 68);
  Cvar_Set("protocol", s2);
  dword_836B7E8 = (int)Cvar_Get("mapname", "nomap", 68);
  dword_836B7C0 = (int)Cvar_Get("sv_privateClients", "0", 4);
  dword_836B7F8 = (int)Cvar_Get("sv_hostname", "CoDHost", 5);
  dword_836B804 = (int)Cvar_Get("sv_maxclients", "20", 36);
  dword_83CCD60 = (int)Cvar_Get("sv_punkbuster", "0", 69);
  dword_83CCD4C = (int)Cvar_Get("sv_maxRate", "0", 5);
  dword_83CCD78 = (int)Cvar_Get("sv_minPing", "0", 5);
  dword_83CCD54 = (int)Cvar_Get("sv_maxPing", "0", 5);
  dword_836B7D8 = (int)Cvar_Get("sv_floodProtect", "1", 5);
  dword_836B7F4 = (int)Cvar_Get("sv_allowAnonymous", "0", 4);
  dword_83E1E90 = (int)Cvar_Get("sv_showCommands", "0", 0);
  dword_836B80C = (int)Cvar_Get("sv_disableClientConsole", "0", 8);
  Cvar_Get("sv_cheats", "1", 72);
  dword_836B800 = (int)Cvar_Get("sv_serverid", "0", 72);
  dword_83CCD58 = (int)Cvar_Get("sv_pure", "1", 12);
  Cvar_Get("sv_paks", (char *)&byte_80DF5E3, 72);
  Cvar_Get("sv_pakNames", (char *)&byte_80DF5E3, 72);
  Cvar_Get("sv_referencedPaks", (char *)&byte_80DF5E3, 72);
  Cvar_Get("sv_referencedPakNames", (char *)&byte_80DF5E3, 72);
  dword_83CCD70 = (int)Cvar_Get("rconPassword", (char *)&byte_80DF5E3, 256);
  dword_836B7EC = (int)Cvar_Get("sv_privatePassword", (char *)&byte_80DF5E3, 256);
  dword_836B7D4 = (int)Cvar_Get("sv_fps", "20", 256);
  dword_83CCD50 = (int)Cvar_Get("sv_timeout", "240", 256);
  dword_83CCD6C = (int)Cvar_Get("sv_zombietime", "2", 256);
  Cvar_Get("nextmap", (char *)&byte_80DF5E3, 256);
  dword_83CCD5C = (int)Cvar_Get("sv_allowDownload", "1", 1);
  dword_83CCD74 = (int)Cvar_Get("sv_reconnectlimit", "3", 0);
  dword_83E1E8C = (int)Cvar_Get("sv_showloss", "0", 0);
  dword_836B808 = (int)Cvar_Get("sv_padPackets", "0", 0);
  dword_836B7DC = (int)Cvar_Get("sv_killserver", "0", 0);
  dword_83CCD64 = (int)Cvar_Get("sv_onlyVisibleClients", "0", 0);
  dword_836B7CC = (int)Cvar_Get("sv_packet_info", "0", 0);
  dword_836B7D0 = (int)Cvar_Get("sv_showAverageBPS", "0", 0);
  dword_836B7C8 = (int)Cvar_Get("sv_kickBanTime", "300", 0);
  Cvar_Get("g_complaintlimit", "3", 1);
  dword_836B7E0 = (int)Cvar_Get("sv_mapRotation", (char *)&byte_80DF5E3, 0);
  dword_836B7C4 = (int)Cvar_Get("sv_mapRotationCurrent", (char *)&byte_80DF5E3, 0);
  Cvar_Get("fs_game", (char *)&byte_80DF5E3, 12);
  dword_836B7F0 = (int)Cvar_Get("sv_wwwDownload", "0", 1);
  dword_836B7E4 = (int)Cvar_Get("sv_wwwBaseURL", (char *)&byte_80DF5E3, 1);
  result = Cvar_Get("sv_wwwDlDisconnected", "0", 1);
  dword_836B7FC = (int)result;
  return result;
}
// 836B7C0: using guessed type int dword_836B7C0;
// 836B7C4: using guessed type int dword_836B7C4;
// 836B7C8: using guessed type int dword_836B7C8;
// 836B7CC: using guessed type int dword_836B7CC;
// 836B7D0: using guessed type int dword_836B7D0;
// 836B7D4: using guessed type int dword_836B7D4;
// 836B7D8: using guessed type int dword_836B7D8;
// 836B7DC: using guessed type int dword_836B7DC;
// 836B7E0: using guessed type int dword_836B7E0;
// 836B7E4: using guessed type int dword_836B7E4;
// 836B7E8: using guessed type int dword_836B7E8;
// 836B7EC: using guessed type int dword_836B7EC;
// 836B7F0: using guessed type int dword_836B7F0;
// 836B7F4: using guessed type int dword_836B7F4;
// 836B7F8: using guessed type int dword_836B7F8;
// 836B7FC: using guessed type int dword_836B7FC;
// 836B800: using guessed type int dword_836B800;
// 836B804: using guessed type int dword_836B804;
// 836B808: using guessed type int dword_836B808;
// 836B80C: using guessed type int dword_836B80C;
// 83CCD4C: using guessed type int dword_83CCD4C;
// 83CCD50: using guessed type int dword_83CCD50;
// 83CCD54: using guessed type int dword_83CCD54;
// 83CCD58: using guessed type int dword_83CCD58;
// 83CCD5C: using guessed type int dword_83CCD5C;
// 83CCD60: using guessed type int dword_83CCD60;
// 83CCD64: using guessed type int dword_83CCD64;
// 83CCD68: using guessed type int dword_83CCD68;
// 83CCD6C: using guessed type int dword_83CCD6C;
// 83CCD70: using guessed type int dword_83CCD70;
// 83CCD74: using guessed type int dword_83CCD74;
// 83CCD78: using guessed type int dword_83CCD78;
// 83E1E8C: using guessed type int dword_83E1E8C;
// 83E1E90: using guessed type int dword_83E1E90;

//----- (08091963) --------------------------------------------------------
int *__cdecl sub_8091963(const char *a1)
{
  int *result; // eax
  int *v2; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h] BYREF
  int v4; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 1; ++i )
  {
    v4 = 0;
    v2 = (int *)dword_83CCD90;
    while ( v4 < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *v2 > 1 )
      {
        if ( v2[84562] != 2 )
        {
          SV_SendServerCommand((int)v2, 0, "e \"%s\"", a1);
          SV_SendServerCommand((int)v2, 1, "w");
        }
        v2[17161] = -1;
        SV_SendClientSnapshot((int)v2);
      }
      ++v4;
      v2 += 92781;
    }
    result = &i;
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (08091A22) --------------------------------------------------------
void __cdecl sub_8091A22(const char *a1)
{
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]

  if ( dword_8360560 && *(_DWORD *)(dword_8360560 + 32) )
  {
    Com_Printf("----- Server Shutdown -----\n", v1);
    if ( dword_83CCD90 )
      sub_8091963(a1);
    sub_808897B();
    sub_8092403();
    sub_808FD11();
    sub_8090ADA();
    if ( dword_83CCD90 )
      sub_8089E27();
    sub_8090BF2();
    memset(&svs, 0, 0x1510Cu);
    Cvar_Set("sv_running", "0");
    Com_Printf("---------------------------\n", v2);
    sub_80846B8();
  }
}
// 8091A4C: variable 'v1' is possibly undefined
// 8091AC3: variable 'v2' is possibly undefined
// 8360560: using guessed type int dword_8360560;
// 83CCD80: using guessed type int svs;

//----- (08091AD8) --------------------------------------------------------
_BYTE *__cdecl sub_8091AD8(_BYTE *a1)
{
  unsigned int v2; // [esp+0h] [ebp-4h]
  unsigned int v3; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( *a1 && v2 <= 0x3FC )
  {
    if ( *a1 == 10 )
    {
      *(_BYTE *)(v2 + 135748736) = 92;
      v3 = v2 + 1;
      *(_BYTE *)(v3 + 135748736) = 110;
      v2 = v3 + 1;
      goto LABEL_10;
    }
    if ( *a1 == 20 || *a1 == 21 )
    {
      ++a1;
    }
    else
    {
      byte_8175C80[v2++] = *a1;
LABEL_10:
      ++a1;
    }
  }
  *(_BYTE *)(v2 + 135748736) = 0;
  return byte_8175C80;
}

//----- (08091B66) --------------------------------------------------------
int __cdecl sub_8091B66(_BYTE *a1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-8h]

  while ( *a1 && *a2 && *a1 != 32 && *a2 != 32 )
  {
    if ( *a1 != *a2 )
      return 0;
    ++a1;
    ++a2;
  }
  v3 = 0;
  if ( (!*a1 || *a1 == 32) && (!*a2 || *a2 == 32) )
    v3 = 1;
  return v3;
}

//----- (08091BEC) --------------------------------------------------------
int __cdecl SV_CanReplaceServerCommand(int a1, char *a2)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  for ( i = *(_DWORD *)(a1 + 67092) + 1; ; ++i )
  {
    if ( i > *(_DWORD *)(a1 + 67084) )
      return -1;
    v4 = i & 0x3F;
    if ( *(_DWORD *)(a1 + 1032 * v4 + 2064) )
    {
      if ( *a2 == *(_BYTE *)(a1 + 1032 * v4 + 1036) && (unsigned int)(*a2 - 120) > 2 )
        break;
    }
LABEL_12:
    ;
  }
  if ( !strcmp(a2 + 1, (const char *)(a1 + 1032 * v4 + 1037)) )
    return i;
  switch ( *a2 )
  {
    case 'a':
    case 'b':
    case 'o':
    case 'p':
    case 'q':
    case 'r':
    case 't':
      v3 = i;
      break;
    case 'd':
    case 'v':
      if ( !sub_8091B66(a2 + 2, (_BYTE *)(a1 + 1032 * v4 + 1038)) )
        goto LABEL_12;
      v3 = i;
      break;
    default:
      goto LABEL_12;
  }
  return v3;
}

//----- (08091D1C) --------------------------------------------------------
int __cdecl SV_CullIgnorableServerCommands(int a1)
{
  int result; // eax
  unsigned int v2; // [esp+0h] [ebp-28h]
  _DWORD *v3; // [esp+4h] [ebp-24h]
  _DWORD *v4; // [esp+8h] [ebp-20h]
  int v5; // [esp+Ch] [ebp-1Ch]
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]

  v7 = *(_DWORD *)(a1 + 67092) + 1;
  for ( i = v7; i <= *(_DWORD *)(a1 + 67084); ++i )
  {
    v6 = i & 0x3F;
    if ( *(_DWORD *)(a1 + 1032 * v6 + 2064) )
    {
      v5 = v7 & 0x3F;
      if ( v5 != v6 )
      {
        v4 = (_DWORD *)(a1 + 1032 * v5 + 1036);
        v3 = (_DWORD *)(a1 + 1032 * v6 + 1036);
        v2 = 1032;
        if ( (((_BYTE)a1 + 8 * (_BYTE)v5 + 12) & 4) != 0 )
        {
          *v4 = *v3;
          v4 = (_DWORD *)(a1 + 1032 * v5 + 1040);
          v3 = (_DWORD *)(a1 + 1032 * v6 + 1040);
          v2 = 1028;
        }
        qmemcpy(v4, v3, 4 * (v2 >> 2));
      }
      ++v7;
    }
  }
  result = v7 - 1;
  *(_DWORD *)(a1 + 67084) = v7 - 1;
  return result;
}

//----- (08091E1B) --------------------------------------------------------
int __cdecl SV_AddServerCommand(int a1, int a2, char *s)
{
  int result; // eax
  char v4; // [esp+4h] [ebp-44h]
  unsigned int v5; // [esp+20h] [ebp-28h]
  _DWORD *v6; // [esp+24h] [ebp-24h]
  _DWORD *v7; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int j; // [esp+34h] [ebp-14h]
  int v11; // [esp+38h] [ebp-10h]

  result = a1;
  if ( !*(_DWORD *)(a1 + 371080) )
  {
    if ( *(_DWORD *)(a1 + 67084) - *(_DWORD *)(a1 + 67088) <= 31 && *(_DWORD *)a1 == 4
      || (result = SV_CullIgnorableServerCommands(a1), a2) )
    {
      v9 = SV_CanReplaceServerCommand(a1, s);
      if ( v9 < 0 )
      {
        ++*(_DWORD *)(a1 + 67084);
      }
      else
      {
        for ( i = v9 + 1; i <= *(_DWORD *)(a1 + 67084); ++i )
        {
          v7 = (_DWORD *)(a1 + 1032 * (v9 & 0x3F) + 1036);
          v6 = (_DWORD *)(a1 + 1032 * (i & 0x3F) + 1036);
          v5 = 1032;
          if ( (((_BYTE)a1 + 8 * (v9 & 0x3F) + 12) & 4) != 0 )
          {
            *v7 = *v6;
            v7 = (_DWORD *)(a1 + 1032 * (v9 & 0x3F) + 1040);
            v6 = (_DWORD *)(a1 + 1032 * (i & 0x3F) + 1040);
            v5 = 1028;
          }
          qmemcpy(v7, v6, 4 * (v5 >> 2));
          LOBYTE(v9) = v9 + 1;
        }
      }
      if ( *(_DWORD *)(a1 + 67084) - *(_DWORD *)(a1 + 67088) == 65 )
      {
        Com_Printf("===== pending server commands =====\n", v4);
        for ( j = *(_DWORD *)(a1 + 67088) + 1; j <= *(_DWORD *)(a1 + 67084); ++j )
          Com_Printf("cmd %5d: %8d: %s\n", j);
        Com_Printf("cmd %5d: %8d: %s\n", j);
        NET_OutOfBandPrint(
          1,
          *(_DWORD *)(a1 + 338248),
          *(_DWORD *)(a1 + 338252),
          *(_DWORD *)(a1 + 338256),
          *(_DWORD *)(a1 + 338260),
          *(_DWORD *)(a1 + 338264),
          "disconnect");
        SV_DelayDropClient((_DWORD *)a1, "EXE_SERVERCOMMANDOVERFLOW");
        a2 = 1;
        s = "w \"EXE_SERVERCOMMANDOVERFLOW\"";
      }
      v11 = *(_DWORD *)(a1 + 67084) & 0x3F;
      MSG_WriteReliableCommandToBuffer(s, a1 + 1032 * v11 + 1036, 1024);
      *(_DWORD *)(a1 + 1032 * v11 + 2060) = dword_83CCD88;
      result = a2;
      *(_DWORD *)(a1 + 1032 * v11 + 2064) = a2;
    }
  }
  return result;
}
// 8091F5A: variable 'v4' is possibly undefined
// 83CCD88: using guessed type int dword_83CCD88;

//----- (080920DE) --------------------------------------------------------
int SV_SendServerCommand(int a1, int a2, char *format, ...)
{
  int result; // eax
  char v4; // al
  int v5; // [esp+18h] [ebp-4020h]
  int *i; // [esp+1Ch] [ebp-401Ch]
  char s[16396]; // [esp+20h] [ebp-4018h] BYREF
  __gnuc_va_list __varargs; // [esp+402Ch] [ebp-Ch]
  va_list va; // [esp+404Ch] [ebp+14h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( a1 )
    return SV_AddServerCommand(a1, a2, s);
  if ( *(_DWORD *)(dword_835F480 + 32) && !strncmp(s, "print", 5u) )
  {
    v4 = (unsigned __int8)sub_8091AD8(s);
    Com_Printf("broadcast: %s\n", v4);
  }
  v5 = 0;
  for ( i = (int *)dword_83CCD90; ; i += 92781 )
  {
    result = v5;
    if ( v5 >= *(_DWORD *)(dword_836B804 + 32) )
      break;
    if ( *i > 2 )
      SV_AddServerCommand((int)i, a2, s);
    ++v5;
  }
  return result;
}
// 835F480: using guessed type int dword_835F480;
// 836B804: using guessed type int dword_836B804;

//----- (080921E7) --------------------------------------------------------
int *SV_MasterAddress()
{
  char v1; // [esp+4h] [ebp-14h]

  if ( !dword_8176080 )
  {
    Com_Printf("Resolving %s\n", (char)"codmaster.activision.com");
    if ( NET_StringToAdr("codmaster.activision.com", &dword_8176080) )
    {
      if ( !strstr(":", "codmaster.activision.com") )
        word_8176092 = BigShort(20510);
      BigShort(word_8176092);
      Com_Printf("codmaster.activision.com resolved to %i.%i.%i.%i:%i\n", byte_8176084);
    }
    else
    {
      Com_Printf("Couldn't resolve address: codmaster.activision.com\n", v1);
    }
  }
  return &dword_8176080;
}
// 809222D: variable 'v1' is possibly undefined
// 8176080: using guessed type int dword_8176080;
// 8176084: using guessed type char byte_8176084;
// 8176092: using guessed type __int16 word_8176092;

//----- (080922B1) --------------------------------------------------------
void __cdecl SV_MasterHeartbeat(const char *a1)
{
  char v1; // [esp+4h] [ebp-24h]
  int *v2; // [esp+24h] [ebp-4h]
  int *v3; // [esp+24h] [ebp-4h]

  if ( dword_835F480 && *(_DWORD *)(dword_835F480 + 32) == 2 )
  {
    if ( dword_83CCD88 >= dword_83CCDD8 )
    {
      dword_83CCDD8 = dword_83CCD88 + 180000;
      v2 = SV_MasterAddress();
      if ( *v2 != 1 )
      {
        Com_Printf("Sending heartbeat to codmaster.activision.com\n", v1);
        NET_OutOfBandPrint(1, *v2, v2[1], v2[2], v2[3], v2[4], "heartbeat %s\n", a1);
      }
    }
    if ( dword_83CCD88 >= dword_83CCDDC )
    {
      dword_83CCDDC = dword_83CCD88 + 600000;
      v3 = SV_MasterAddress();
      if ( *v3 != 1 )
        SVC_Status(*v3, v3[1], v3[2], v3[3], v3[4]);
    }
  }
}
// 8092306: variable 'v1' is possibly undefined
// 835F480: using guessed type int dword_835F480;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCDD8: using guessed type int dword_83CCDD8;
// 83CCDDC: using guessed type int dword_83CCDDC;

//----- (080923A2) --------------------------------------------------------
void sub_80923A2()
{
  char v0; // [esp+4h] [ebp-14h]
  int *v1; // [esp+14h] [ebp-4h]

  if ( dword_835F480 && *(_DWORD *)(dword_835F480 + 32) == 2 )
  {
    v1 = SV_MasterAddress();
    if ( *v1 != 1 )
    {
      Com_Printf("Sending gameCompleteStatus to codmaster.activision.com\n", v0);
      SVC_GameCompleteStatus(*v1, v1[1], v1[2], v1[3], v1[4]);
    }
  }
}
// 80923D3: variable 'v0' is possibly undefined
// 835F480: using guessed type int dword_835F480;

//----- (08092403) --------------------------------------------------------
void sub_8092403()
{
  dword_83CCDD8 = 0x80000000;
  SV_MasterHeartbeat("flatline");
}
// 83CCDD8: using guessed type int dword_83CCDD8;

//----- (08092421) --------------------------------------------------------
int SV_GetClientScore()
{
  int v1; // [esp+14h] [ebp-4h]

  if ( gvm )
    v1 = VM_Call((int)gvm, 22);
  else
    v1 = 0;
  return v1;
}

//----- (0809246E) --------------------------------------------------------
void *__cdecl SVC_Status(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  int v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char v13[1024]; // [esp+30h] [ebp-4C38h] BYREF
  char v14[4]; // [esp+430h] [ebp-4838h]
  char **v15; // [esp+434h] [ebp-4834h]
  _BYTE *v16; // [esp+438h] [ebp-4830h]
  _BYTE *v17; // [esp+43Ch] [ebp-482Ch]
  char dest[1032]; // [esp+440h] [ebp-4828h] BYREF
  size_t v19; // [esp+848h] [ebp-4420h]
  int v20; // [esp+84Ch] [ebp-441Ch]
  int v21; // [esp+850h] [ebp-4418h]
  int v22; // [esp+854h] [ebp-4414h]
  int v23; // [esp+858h] [ebp-4410h]
  int i; // [esp+85Ch] [ebp-440Ch]
  char v25[16384]; // [esp+860h] [ebp-4408h] BYREF
  char s[1032]; // [esp+4860h] [ebp-408h] BYREF

  *(_DWORD *)v14 = 0;
  v5 = Cvar_InfoString(8196);
  strcpy(dest, v5);
  v6 = Cmd_Argv(1u);
  Info_SetValueForKey(dest, "challenge", (int)v6);
  if ( Cvar_VariableValue((int)"fs_restrict") != 0.0 )
  {
    v7 = (const char *)Info_ValueForKey(dest, (int)"sv_keywords");
    Com_sprintf(v13, 0x400u, "demo %s", v7);
    Info_SetValueForKey(dest, "sv_keywords", (int)v13);
  }
  v25[0] = 0;
  v20 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32); ++i )
  {
    v22 = (int)dword_83CCD90 + 371124 * i;
    if ( *(int *)v22 > 1 )
    {
      v21 = SV_GameClientNum(i);
      v8 = SV_GetClientScore();
      Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v8, *(_DWORD *)(v22 + 338224), (const char *)(v22 + 68164));
      v19 = strlen(s);
      if ( v20 + v19 > 0x3FFF )
        break;
      strcpy(&v25[v20], s);
      v20 += v19;
    }
  }
  if ( *(_DWORD *)(dword_836B80C + 32) )
  {
    v9 = va("%i", *(_DWORD *)(dword_836B80C + 32));
    Info_SetValueForKey(dest, "con_disabled", (int)v9);
  }
  v17 = Cvar_VariableString((int)"g_password");
  if ( v17 && *v17 )
    Info_SetValueForKey(dest, "pswrd", (int)"1");
  else
    Info_SetValueForKey(dest, "pswrd", (int)"0");
  v16 = Cvar_VariableString((int)"fs_game");
  if ( !*(_DWORD *)(dword_83CCD58 + 32) || v16 && *v16 )
  {
    *(_DWORD *)v14 = 1;
  }
  else
  {
    v15 = (char **)Cvar_VariableString((int)"sv_referencedPakNames");
    if ( v15 && *(_BYTE *)v15 )
    {
      Cmd_TokenizeString(v15);
      v23 = Cmd_Argc();
      for ( i = 0; i < v23; ++i )
      {
        v10 = Cmd_Argv(i);
        if ( !FS_iwPak(v10, (int)"main") )
        {
          *(_DWORD *)v14 = 1;
          break;
        }
      }
    }
  }
  v11 = va("%i", *(_DWORD *)v14);
  Info_SetValueForKey(dest, "mod", (int)v11);
  return NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "statusResponse\n%s\n%s", dest, v25);
}
// 836B804: using guessed type int dword_836B804;
// 836B80C: using guessed type int dword_836B80C;
// 83CCD58: using guessed type int dword_83CCD58;

//----- (08092848) --------------------------------------------------------
void *__cdecl SVC_GameCompleteStatus(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  const char *v7; // eax
  int v8; // eax
  char v10[1024]; // [esp+30h] [ebp-4C28h] BYREF
  char dest[1036]; // [esp+430h] [ebp-4828h] BYREF
  size_t v12; // [esp+83Ch] [ebp-441Ch]
  int v13; // [esp+840h] [ebp-4418h]
  int v14; // [esp+844h] [ebp-4414h]
  int v15; // [esp+848h] [ebp-4410h]
  int i; // [esp+84Ch] [ebp-440Ch]
  char v17[16384]; // [esp+850h] [ebp-4408h] BYREF
  char s[1032]; // [esp+4850h] [ebp-408h] BYREF

  v5 = Cvar_InfoString(8196);
  strcpy(dest, v5);
  v6 = Cmd_Argv(1u);
  Info_SetValueForKey(dest, "challenge", (int)v6);
  if ( Cvar_VariableValue((int)"fs_restrict") != 0.0 )
  {
    v7 = (const char *)Info_ValueForKey(dest, (int)"sv_keywords");
    Com_sprintf(v10, 1024u, "demo %s", v7);
    Info_SetValueForKey(dest, "sv_keywords", (int)v10);
  }
  v17[0] = 0;
  v13 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_836B804 + 32); ++i )
  {
    v15 = (int)dword_83CCD90 + 371124 * i;
    if ( *(int *)v15 > 1 )
    {
      v14 = SV_GameClientNum(i);
      v8 = SV_GetClientScore();
      Com_sprintf(s, 0x400u, "%i %i \"%s\"\n", v8, *(_DWORD *)(v15 + 338224), (const char *)(v15 + 68164));
      v12 = strlen(s);
      if ( v13 + v12 > 0x3FFF )
        return NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "gameCompleteStatus\n%s\n%s", dest, v17);
      strcpy(&v17[v13], s);
      v13 += v12;
    }
  }
  return NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "gameCompleteStatus\n%s\n%s", dest, v17);
}
// 836B804: using guessed type int dword_836B804;

//----- (08092A74) --------------------------------------------------------
void *__cdecl SVC_Info(int a1, int a2, int a3, int a4, int a5)
{
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  char *v15; // eax
  char *v16; // eax
  char **v18; // [esp+2Ch] [ebp-43Ch]
  char s[1036]; // [esp+30h] [ebp-438h] BYREF
  char v20[4]; // [esp+43Ch] [ebp-2Ch]
  char *v21; // [esp+440h] [ebp-28h]
  char *v22; // [esp+444h] [ebp-24h]
  char *nptr; // [esp+448h] [ebp-20h]
  _BYTE *v24; // [esp+44Ch] [ebp-1Ch]
  int v25; // [esp+450h] [ebp-18h]
  int v26; // [esp+454h] [ebp-14h]
  char v27[4]; // [esp+458h] [ebp-10h]
  signed int i; // [esp+45Ch] [ebp-Ch]

  v26 = 0;
  for ( i = 0; i < *(_DWORD *)(dword_836B7C0 + 32); ++i )
  {
    if ( *((int *)dword_83CCD90 + 92781 * i) > 1 )
      ++v26;
  }
  *(_DWORD *)v27 = v26;
  while ( i < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *((int *)dword_83CCD90 + 92781 * i) > 1 )
      ++*(_DWORD *)v27;
    ++i;
  }
  s[0] = 0;
  v5 = Cmd_Argv(1u);
  Info_SetValueForKey(s, "challenge", (int)v5);
  v6 = va("%i", 6);
  Info_SetValueForKey(s, "protocol", (int)v6);
  Info_SetValueForKey(s, "hostname", *(_DWORD *)(dword_836B7F8 + 4));
  Info_SetValueForKey(s, "mapname", *(_DWORD *)(dword_836B7E8 + 4));
  if ( *(_DWORD *)v27 )
  {
    v7 = va("%i", *(_DWORD *)v27);
    Info_SetValueForKey(s, "clients", (int)v7);
  }
  *(_DWORD *)v20 = *(_DWORD *)(dword_836B804 + 32) - (*(_DWORD *)(dword_836B7C0 + 32) - v26);
  if ( *(int *)v20 > 0 )
  {
    v8 = va("%i", *(_DWORD *)v20);
    Info_SetValueForKey(s, "sv_maxclients", (int)v8);
  }
  Info_SetValueForKey(s, "gametype", *(_DWORD *)(dword_83CCD68 + 4));
  if ( *(_DWORD *)(dword_83CCD58 + 32) )
  {
    v9 = va("%i", *(_DWORD *)(dword_83CCD58 + 32));
    Info_SetValueForKey(s, "pure", (int)v9);
  }
  if ( *(_DWORD *)(dword_83CCD78 + 32) )
  {
    v10 = va("%i", *(_DWORD *)(dword_83CCD78 + 32));
    Info_SetValueForKey(s, "minPing", (int)v10);
  }
  if ( *(_DWORD *)(dword_83CCD54 + 32) )
  {
    v11 = va("%i", *(_DWORD *)(dword_83CCD54 + 32));
    Info_SetValueForKey(s, "maxPing", (int)v11);
  }
  v25 = (int)Cvar_VariableString((int)"fs_game");
  if ( v25 && *(_BYTE *)v25 )
    Info_SetValueForKey(s, "game", v25);
  if ( *(_DWORD *)(dword_836B7F4 + 32) )
  {
    v12 = va("%i", *(_DWORD *)(dword_836B7F4 + 32));
    Info_SetValueForKey(s, "sv_allowAnonymous", (int)v12);
  }
  v24 = Cvar_VariableString((int)"g_password");
  if ( v24 && *v24 )
    Info_SetValueForKey(s, "pswrd", (int)"1");
  nptr = (char *)Cvar_VariableString((int)"scr_friendlyfire");
  if ( nptr && atoi(nptr) )
    Info_SetValueForKey(s, "ff", (int)nptr);
  v22 = (char *)Cvar_VariableString((int)"scr_killcam");
  if ( v22 && atoi(v22) )
    Info_SetValueForKey(s, "kc", (int)v22);
  v21 = (char *)Cvar_VariableString((int)"g_timeoutsallowed");
  if ( v21 && atoi(v21) )
    Info_SetValueForKey(s, "timeoutsAllowed", (int)v21);
  v13 = va("%i", 1);
  Info_SetValueForKey(s, "hw", (int)v13);
  v14 = va("%i", *(_DWORD *)(dword_83CCD60 + 32));
  Info_SetValueForKey(s, "pb", (int)v14);
  if ( !*(_DWORD *)(dword_83CCD58 + 32) || v25 && *(_BYTE *)v25 )
  {
LABEL_47:
    v16 = va("%i", 1);
  }
  else
  {
    v18 = (char **)Cvar_VariableString((int)"sv_referencedPakNames");
    if ( v18 && *(_BYTE *)v18 )
    {
      Cmd_TokenizeString(v18);
      *(_DWORD *)v27 = Cmd_Argc();
      for ( i = 0; i < *(int *)v27; ++i )
      {
        v15 = Cmd_Argv(i);
        if ( !FS_iwPak(v15, (int)"main") )
          goto LABEL_47;
      }
    }
    v16 = va("%i", 0);
  }
  Info_SetValueForKey(s, "mod", (int)v16);
  return NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "infoResponse\n%s", s);
}
// 836B7C0: using guessed type int dword_836B7C0;
// 836B7E8: using guessed type int dword_836B7E8;
// 836B7F4: using guessed type int dword_836B7F4;
// 836B7F8: using guessed type int dword_836B7F8;
// 836B804: using guessed type int dword_836B804;
// 83CCD54: using guessed type int dword_83CCD54;
// 83CCD58: using guessed type int dword_83CCD58;
// 83CCD60: using guessed type int dword_83CCD60;
// 83CCD68: using guessed type int dword_83CCD68;
// 83CCD78: using guessed type int dword_83CCD78;

//----- (08092FE8) --------------------------------------------------------
void *__cdecl SV_FlushRedirect(char *s)
{
  char v2; // [esp+23h] [ebp-5h]
  signed int i; // [esp+24h] [ebp-4h]

  for ( i = strlen(s); i > 1300; i -= 1300 )
  {
    v2 = s[1300];
    s[1300] = 0;
    NET_OutOfBandPrint(1, dword_83E1DE0, dword_83E1DE4, dword_83E1DE8, dword_83E1DEC, dword_83E1DF0, "print\n%s", s);
    s += 1300;
    *s = v2;
  }
  return NET_OutOfBandPrint(
           1,
           dword_83E1DE0,
           dword_83E1DE4,
           dword_83E1DE8,
           dword_83E1DEC,
           dword_83E1DF0,
           "print\n%s",
           s);
}

//----- (080930D0) --------------------------------------------------------
int __cdecl SVC_RemoteCommand(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  char *v6; // eax
  char v7; // al
  char v8; // al
  char *v9; // eax
  char v10; // [esp+4h] [ebp-4434h]
  char v11[16376]; // [esp+20h] [ebp-4418h] BYREF
  int v12; // [esp+4018h] [ebp-420h]
  int v13; // [esp+401Ch] [ebp-41Ch]
  char s[1028]; // [esp+4020h] [ebp-418h] BYREF
  int v15; // [esp+4424h] [ebp-14h]
  signed int i; // [esp+4428h] [ebp-10h]
  int v17; // [esp+442Ch] [ebp-Ch]

  v15 = Com_Milliseconds();
  if ( !dword_80EE808 || (result = v15 - dword_80EE808, v15 - dword_80EE808 > 499) )
  {
    dword_80EE808 = v15;
    if ( **(_BYTE **)(dword_83CCD70 + 4) && (v6 = Cmd_Argv(1u), !strcmp(v6, *(const char **)(dword_83CCD70 + 4))) )
    {
      v17 = 1;
      Cmd_Argv(2u);
      v8 = (unsigned __int8)NET_AdrToString(a1, a2, a3, a4, a5);
      Com_Printf("Rcon from %s:\n%s\n", v8);
    }
    else
    {
      v17 = 0;
      Cmd_Argv(2u);
      v7 = (unsigned __int8)NET_AdrToString(a1, a2, a3, a4, a5);
      Com_Printf("Bad rcon from %s:\n%s\n", v7);
    }
    dword_83E1DE0 = a1;
    dword_83E1DE4 = a2;
    dword_83E1DE8 = a3;
    dword_83E1DEC = a4;
    dword_83E1DF0 = a5;
    Com_BeginRedirect(v11, 16368, (int (__cdecl *)(_DWORD))SV_FlushRedirect);
    if ( **(_BYTE **)(dword_83CCD70 + 4) )
    {
      if ( v17 )
      {
        v13 = 0;
        v12 = 1024;
        for ( i = 2; i < Cmd_Argc(); ++i )
        {
          v9 = Cmd_Argv(i);
          v13 = Com_AddToString(v9, (int)s, v13, v12, 1);
          v13 = Com_AddToString(" ", (int)s, v13, v12, 0);
        }
        if ( v13 < v12 )
        {
          s[v13] = 0;
          Cmd_ExecuteString(s);
          if ( !Q_stricmpn(s, "pb_sv_", 6) )
            PbServerForceProcess();
        }
      }
      else
      {
        Com_Printf("Bad rconpassword.\n", v10);
      }
    }
    else
    {
      Com_Printf("No rconpassword set on the server.\n", v10);
    }
    result = Com_EndRedirect();
  }
  return result;
}
// 809323C: variable 'v10' is possibly undefined
// 80EE808: using guessed type int dword_80EE808;
// 83CCD70: using guessed type int dword_83CCD70;

//----- (0809336A) --------------------------------------------------------
void __cdecl SV_ConnectionlessPacket(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // al
  char *v7; // eax
  char *v8; // [esp+30h] [ebp-18h]
  _DWORD *v9; // [esp+34h] [ebp-14h]
  int v10; // [esp+38h] [ebp-10h]
  int v11; // [esp+3Ch] [ebp-Ch]
  char *v12; // [esp+40h] [ebp-8h]
  char **v13; // [esp+44h] [ebp-4h]

  v10 = -1;
  MSG_BeginReading(a6);
  MSG_ReadLong((_DWORD *)a6);
  SV_Netchan_AddOOBProfilePacket(*(_DWORD *)(a6 + 12));
  if ( Q_stricmpn((char *)(*(_DWORD *)(a6 + 4) + 4), "pb_", 3) )
  {
    if ( !Q_strncmp("connect", (char *)(*(_DWORD *)(a6 + 4) + 4), 7) )
      Huff_Decompress((_DWORD *)a6, 12);
    v13 = (char **)MSG_ReadStringLine(a6);
    Cmd_TokenizeString(v13);
    v12 = Cmd_Argv(0);
    if ( *(_DWORD *)(dword_836B7CC + 32) )
    {
      v6 = (unsigned __int8)NET_AdrToString(a1, a2, a3, a4, a5);
      Com_Printf("SV packet %s : %s\n", v6);
    }
    if ( Q_stricmp(v12, "getstatus") )
    {
      if ( Q_stricmp(v12, "getinfo") )
      {
        if ( Q_stricmp(v12, "getchallenge") )
        {
          if ( Q_stricmp(v12, "connect") )
          {
            if ( Q_stricmp(v12, "ipAuthorize") )
            {
              if ( Q_stricmp(v12, "rcon") )
              {
                if ( Q_stricmp(v12, "disconnect") )
                {
                  v7 = NET_AdrToString(a1, a2, a3, a4, a5);
                  Com_DPrintf("bad connectionless packet from %s:\n%s\n", v7, (const char *)v13);
                }
              }
              else
              {
                SVC_RemoteCommand(a1, a2, a3, a4, a5);
              }
            }
            else
            {
              SV_AuthorizeIpPacket(a1, a2, a3, a4, a5);
            }
          }
          else
          {
            if ( NET_IsLocalAddress(a1) )
            {
              PbPassConnectString((int)"localhost", *(_DWORD *)(a6 + 4));
            }
            else
            {
              v8 = NET_AdrToString(a1, a2, a3, a4, a5);
              PbPassConnectString((int)v8, *(_DWORD *)(a6 + 4));
            }
            SV_DirectConnect(a1, a2, a3, a4, a5);
          }
        }
        else
        {
          SV_GetChallenge(a1, a2, a3, a4, a5);
        }
      }
      else
      {
        SVC_Info(a1, a2, a3, a4, a5);
      }
    }
    else
    {
      SVC_Status(a1, a2, a3, a4, a5);
    }
  }
  else
  {
    v11 = 0;
    v9 = dword_83CCD90;
    while ( v11 < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *v9
        && NET_CompareBaseAdr(a1, a2, a3, a4, a5, v9[84562], v9[84563], v9[84564], v9[84565], v9[84566])
        && *((_WORD *)v9 + 169133) == HIWORD(a5) )
      {
        v10 = v11;
        break;
      }
      ++v11;
      v9 += 92781;
    }
    if ( *(_BYTE *)(*(_DWORD *)(a6 + 4) + 7) != 67
      && *(_BYTE *)(*(_DWORD *)(a6 + 4) + 7) != 49
      && *(_BYTE *)(*(_DWORD *)(a6 + 4) + 7) != 74 )
    {
      PbSvAddEvent(13, v10, *(_DWORD *)(a6 + 12) - 4, *(_DWORD *)(a6 + 4) + 4);
    }
  }
}
// 836B7CC: using guessed type int dword_836B7CC;
// 836B804: using guessed type int dword_836B804;

//----- (080937FA) --------------------------------------------------------
int sub_80937FA()
{
  return *(_DWORD *)(dword_836B804 + 32);
}
// 836B804: using guessed type int dword_836B804;

//----- (08093807) --------------------------------------------------------
int __cdecl sub_8093807(int a1, void *s)
{
  char *v2; // eax

  memset(s, 0, 0x68u);
  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_836B804 + 32) )
    return 0;
  if ( !dword_83CCD90 )
    return 0;
  if ( *((int *)dword_83CCD90 + 92781 * a1) <= 3 )
    return 0;
  strcpy((char *)s, (const char *)dword_83CCD90 + 371124 * a1 + 68164);
  strcpy((char *)s + 33, (const char *)dword_83CCD90 + 371124 * a1 + 371088);
  v2 = NET_AdrToString(
         *((_DWORD *)dword_83CCD90 + 92781 * a1 + 84562),
         *((_DWORD *)dword_83CCD90 + 92781 * a1 + 84563),
         *((_DWORD *)dword_83CCD90 + 92781 * a1 + 84564),
         *((_DWORD *)dword_83CCD90 + 92781 * a1 + 84565),
         *((_DWORD *)dword_83CCD90 + 92781 * a1 + 84566));
  strcpy((char *)s + 66, v2);
  return 1;
}
// 836B804: using guessed type int dword_836B804;

//----- (08093934) --------------------------------------------------------
int __cdecl sub_8093934(int a1, char *s)
{
  int v2; // eax
  int *v5; // [esp+14h] [ebp-4h]

  *s = 0;
  if ( a1 < 0 || a1 >= *(_DWORD *)(dword_836B804 + 32) )
    return 0;
  if ( !dword_83CCD90 )
    return 0;
  v5 = (int *)((char *)dword_83CCD90 + 371124 * a1);
  if ( *v5 <= 3 )
    return 0;
  v2 = SV_GetClientScore();
  sprintf(s, "ping=%d score=%d", v5[84556], v2);
  return 1;
}
// 836B804: using guessed type int dword_836B804;

//----- (080939CF) --------------------------------------------------------
int __cdecl sub_80939CF(size_t n, void *src, int a3)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  if ( svs == 1 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(_DWORD *)(dword_836B804 + 32) )
        break;
      if ( (a3 < 0 || a3 == i) && *((int *)dword_83CCD90 + 92781 * i) > 1 )
        sub_808442C(
          1,
          *((_DWORD *)dword_83CCD90 + 92781 * i + 84562),
          *((_DWORD *)dword_83CCD90 + 92781 * i + 84563),
          *((_DWORD *)dword_83CCD90 + 92781 * i + 84564),
          *((_DWORD *)dword_83CCD90 + 92781 * i + 84565),
          *((_DWORD *)dword_83CCD90 + 92781 * i + 84566),
          src,
          n);
    }
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;
// 83CCD80: using guessed type int svs;

//----- (08093A93) --------------------------------------------------------
void __cdecl SV_ReadPackets(int a1, int a2, int a3, int a4, int a5, int a6)
{
  char v6; // [esp+4h] [ebp-34h]
  int v7; // [esp+28h] [ebp-10h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]

  if ( *(int *)(a6 + 12) > 3 && **(_DWORD **)(a6 + 4) == -1 )
  {
    SV_ConnectionlessPacket(a1, a2, a3, a4, a5, a6);
  }
  else
  {
    if ( !++dword_835F4A4 )
      ++dword_835F4A4;
    dword_80EE80C = 1;
    MSG_BeginReading(a6);
    MSG_ReadLong((_DWORD *)a6);
    v7 = (unsigned __int16)MSG_ReadShort((_DWORD *)a6);
    v9 = 0;
    for ( i = dword_83CCD90; ; i += 92781 )
    {
      if ( v9 >= *(_DWORD *)(dword_836B804 + 32) )
      {
        NET_OutOfBandPrint(1, a1, a2, a3, a4, a5, "disconnect");
        goto LABEL_21;
      }
      if ( *i && NET_CompareBaseAdr(a1, a2, a3, a4, a5) && i[84567] == v7 )
        break;
      ++v9;
    }
    if ( *((_WORD *)i + 169133) != HIWORD(a5) )
    {
      Com_Printf("SV_ReadPackets: fixing up a translated port\n", v6);
      *((_WORD *)i + 169133) = HIWORD(a5);
    }
    if ( Netchan_Process(i + 84560, (_DWORD *)a6) )
    {
      i[92771] = MSG_ReadByte((_DWORD *)a6);
      i[16774] = MSG_ReadLong((_DWORD *)a6);
      if ( (int)i[16774] >= 0 )
      {
        i[16772] = MSG_ReadLong((_DWORD *)a6);
        if ( i[16771] - i[16772] <= 63 )
        {
          SV_Netchan_Decode(
            (int)i,
            (_BYTE *)(*(_DWORD *)(a6 + 4) + *(_DWORD *)(a6 + 16)),
            *(_DWORD *)(a6 + 12) - *(_DWORD *)(a6 + 16));
          if ( *i != 1 )
          {
            i[17159] = dword_83CCD88;
            SV_ExecuteClientMessage((int)i, (_DWORD *)a6);
          }
        }
        else
        {
          i[16772] = i[16771];
        }
      }
    }
LABEL_21:
    dword_80EE80C = 0;
    Hunk_ClearTempMemoryInternal();
  }
}
// 8093BE7: variable 'v6' is possibly undefined
// 80EE80C: using guessed type int dword_80EE80C;
// 835F4A4: using guessed type int dword_835F4A4;
// 836B804: using guessed type int dword_836B804;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08093D4C) --------------------------------------------------------
int sub_8093D4C()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-14h]
  int v2; // [esp+Ch] [ebp-10h]
  _DWORD *v3; // [esp+10h] [ebp-Ch]
  int j; // [esp+14h] [ebp-8h]
  int i; // [esp+18h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(dword_836B804 + 32) )
      break;
    v3 = (char *)dword_83CCD90 + 371124 * i;
    if ( *v3 == 4 )
    {
      if ( v3[17040] )
      {
        v2 = 0;
        v1 = 0;
        for ( j = 0; j <= 31; ++j )
        {
          if ( (int)v3[2106 * j + 19268] > 0 )
          {
            ++v1;
            v2 += v3[2106 * j + 19268] - v3[2106 * j + 19267];
          }
        }
        if ( v1 )
        {
          v3[84556] = v2 / v1;
          if ( (int)v3[84556] > 999 )
            v3[84556] = 999;
        }
        else
        {
          v3[84556] = 999;
        }
      }
      else
      {
        v3[84556] = 999;
      }
    }
    else
    {
      v3[84556] = 999;
    }
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;

//----- (08093E86) --------------------------------------------------------
int __cdecl sub_8093E86(int a1)
{
  int result; // eax

  sub_80A9560(*(_WORD *)(a1 + 371076));
  result = a1;
  *(_WORD *)(a1 + 371076) = 0;
  return result;
}

//----- (08093EAC) --------------------------------------------------------
int sub_8093EAC()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  const char *i; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  v2 = dword_83CCD88 - 1000 * *(_DWORD *)(dword_83CCD50 + 32);
  v1 = dword_83CCD88 - 1000 * *(_DWORD *)(dword_83CCD6C + 32);
  v4 = 0;
  for ( i = (const char *)dword_83CCD90; ; i += 371124 )
  {
    result = v4;
    if ( v4 >= *(_DWORD *)(dword_836B804 + 32) )
      break;
    if ( *((_DWORD *)i + 17159) > dword_83CCD88 )
      *((_DWORD *)i + 17159) = dword_83CCD88;
    if ( !*((_DWORD *)i + 92770) )
    {
      if ( *(_DWORD *)i == 1 && *((_DWORD *)i + 17159) < v1 )
      {
        Com_DPrintf("Going from CS_ZOMBIE to CS_FREE for %s\n", i + 68164);
        *(_DWORD *)i = 0;
      }
      else if ( *(int *)i <= 1 || *((_DWORD *)i + 17159) >= v2 )
      {
        *((_DWORD *)i + 17163) = 0;
      }
      else if ( (int)++*((_DWORD *)i + 17163) > 5 )
      {
        SV_DropClient((int)i, (int)"EXE_TIMEDOUT");
        *(_DWORD *)i = 0;
      }
    }
    ++v4;
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;
// 83CCD50: using guessed type int dword_83CCD50;
// 83CCD6C: using guessed type int dword_83CCD6C;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08093FD9) --------------------------------------------------------
int sub_8093FD9()
{
  int v1; // [esp+0h] [ebp-10h]
  int v2; // [esp+4h] [ebp-Ch]
  int *v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  if ( !*(_DWORD *)(dword_8360654 + 32) )
    return 0;
  v4 = 0;
  v2 = 0;
  v3 = (int *)dword_83CCD90;
  while ( v2 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *v3 > 1 )
      ++v4;
    ++v2;
    v3 += 92781;
  }
  if ( v4 <= 1 )
  {
    *(_DWORD *)(dword_835F4A0 + 32) = 1;
    v1 = 1;
  }
  else
  {
    *(_DWORD *)(dword_835F4A0 + 32) = 0;
    v1 = 0;
  }
  return v1;
}
// 835F4A0: using guessed type int dword_835F4A0;
// 8360654: using guessed type int dword_8360654;
// 836B804: using guessed type int dword_836B804;

//----- (08094069) --------------------------------------------------------
int SV_RunFrame()
{
  VM_Call((int)gvm, 11);
  if ( !++dword_835F4A4 )
    ++dword_835F4A4;
  dword_80EE80C = 1;
  VM_Call((int)gvm, 12);
  dword_80EE80C = 0;
  return Hunk_ClearTempMemoryInternal();
}
// 80EE80C: using guessed type int dword_80EE80C;
// 835F4A4: using guessed type int dword_835F4A4;
// 83CCD84: using guessed type int dword_83CCD84;

//----- (080940D2) --------------------------------------------------------
_DWORD *__cdecl sub_80940D2(_DWORD *a1)
{
  _DWORD *result; // eax
  int s; // [esp+10h] [ebp-28h] BYREF
  char v3; // [esp+14h] [ebp-24h]
  char v4; // [esp+16h] [ebp-22h]
  char v5; // [esp+24h] [ebp-14h]

  result = a1;
  if ( a1[17040] )
  {
    memset(&s, 0, 0x18u);
    v4 = *(_BYTE *)(SV_GameClientNum(-266129563 * (((char *)a1 - (_BYTE *)dword_83CCD90) >> 2)) + 176);
    if ( !sub_8095F4C() )
    {
      if ( (long double)rand() / 2147483600.0 < 0.5 )
        v3 |= 1u;
      if ( (long double)rand() / 2147483600.0 < 0.5 )
        v3 |= 0x40u;
      if ( (long double)rand() / 2147483600.0 >= 0.33000001 )
      {
        if ( (long double)rand() / 2147483600.0 < 0.5 )
          v5 = -127;
      }
      else
      {
        v5 = 127;
      }
    }
    a1[17157] = a1[84569] - 1;
    result = SV_ClientThink(a1, &s);
  }
  return result;
}

//----- (0809421B) --------------------------------------------------------
int sub_809421B()
{
  _DWORD *v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( !++dword_835F4A4 )
    ++dword_835F4A4;
  dword_80EE80C = 1;
  v2 = 0;
  v1 = dword_83CCD90;
  while ( v2 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *v1 )
    {
      if ( !v1[84562] )
        sub_80940D2(v1);
    }
    ++v2;
    v1 += 92781;
  }
  dword_80EE80C = 0;
  return Hunk_ClearTempMemoryInternal();
}
// 80EE80C: using guessed type int dword_80EE80C;
// 835F4A4: using guessed type int dword_835F4A4;
// 836B804: using guessed type int dword_836B804;

//----- (080942A1) --------------------------------------------------------
void __cdecl sub_80942A1(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  char dest[68]; // [esp+20h] [ebp-58h] BYREF
  int v12; // [esp+64h] [ebp-14h]
  int v13; // [esp+68h] [ebp-10h]
  int v14; // [esp+6Ch] [ebp-Ch]

  if ( *(_DWORD *)(dword_836B7DC + 32) )
  {
    sub_806FCC4("EXE_SERVERKILLED");
    Cvar_Set("sv_killserver", "0");
  }
  else if ( *(_DWORD *)(dword_8360560 + 32) && !sub_8093FD9() )
  {
    if ( *(int *)(dword_836B7D4 + 32) <= 0 )
      Cvar_Set("sv_fps", "10");
    v14 = 1000 / *(_DWORD *)(dword_836B7D4 + 32);
    dword_836B830 += a1;
    if ( dword_836B830 >= v14 )
    {
      if ( dword_83CCD88 <= 1879048192 && dword_83CCD84 <= 1879048192 )
      {
        if ( dword_83CCD9C < 2147483646 - dword_83CCD94 )
        {
          if ( dword_83CCDC0 <= 2147467261 )
          {
            if ( dword_83CCDC4 <= 2147479549 )
            {
              if ( dword_83CCDB0 <= 2147482445 )
              {
                if ( dword_83CCDBC <= 2113929213 )
                {
                  if ( dword_83CCDC8 <= 2147483133 )
                  {
                    if ( dword_83CCDA0 < 2147483646 - dword_83CCD98 )
                    {
                      XAnimSetUser(1);
                      if ( (dword_8360678 & 0x2004) != 0 )
                      {
                        v9 = Cvar_InfoString(8196);
                        SV_SetConfigstring(0, v9);
                        dword_8360678 &= 0xFFFFDFFB;
                      }
                      if ( (dword_8360678 & 8) != 0 )
                      {
                        v10 = Cvar_InfoString_Big(8);
                        SV_SetConfigstring(1, v10);
                        dword_8360678 &= 0xFFFFFFF7;
                      }
                      if ( (dword_8360678 & 0x800) != 0 )
                      {
                        SV_SetConfig(140, 64, 2048);
                        dword_8360678 &= 0xFFFFF7FF;
                      }
                      sub_809421B();
                      if ( *(_DWORD *)(dword_8360660 + 32) )
                        v12 = sub_80D563C();
                      else
                        v12 = 0;
                      sub_8093D4C();
                      v13 = sub_80716B2(v14);
                      while ( 1 )
                      {
                        dword_836B830 -= v14;
                        dword_83CCD88 += v14;
                        dword_83CCD84 += v13;
                        SV_RunFrame();
                        sub_80A98A8();
                        if ( v14 <= 0 || dword_836B830 < v14 )
                          break;
                        sub_8097E1C();
                      }
                      if ( *(_DWORD *)(dword_8360660 + 32) )
                        dword_83604CC = sub_80D563C() - v12;
                      sub_8093EAC();
                      SV_SendClientMessages();
                      if ( *(float *)(dword_835F4B4 + 28) > 0.0 )
                        sub_8097E1C();
                      SV_MasterHeartbeat("COD-1");
                    }
                    else
                    {
                      Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
                      sub_806FCC4(aExeServerresta_0);
                      v8 = va("map %s\n", dest);
                      Cbuf_AddText(v8);
                    }
                  }
                  else
                  {
                    Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
                    sub_806FCC4(aExeServerresta_1);
                    v7 = va("map %s\n", dest);
                    Cbuf_AddText(v7);
                  }
                }
                else
                {
                  Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
                  sub_806FCC4(aExeServerresta_2);
                  v6 = va("map %s\n", dest);
                  Cbuf_AddText(v6);
                }
              }
              else
              {
                Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
                sub_806FCC4(aExeServerresta_3);
                v5 = va("map %s\n", dest);
                Cbuf_AddText(v5);
              }
            }
            else
            {
              Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
              sub_806FCC4(aExeServerresta_4);
              v4 = va("map %s\n", dest);
              Cbuf_AddText(v4);
            }
          }
          else
          {
            Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
            sub_806FCC4(aExeServerresta_5);
            v3 = va("map %s\n", dest);
            Cbuf_AddText(v3);
          }
        }
        else
        {
          Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
          sub_806FCC4(aExeServerresta_6);
          v2 = va("map %s\n", dest);
          Cbuf_AddText(v2);
        }
      }
      else
      {
        Q_strncpyz(dest, *(char **)(dword_836B7E8 + 4), 64);
        sub_806FCC4("EXE_SERVERRESTARTTIMEWRAP");
        v1 = va("map %s\n", dest);
        Cbuf_AddText(v1);
      }
    }
  }
}
// 835F4B4: using guessed type int dword_835F4B4;
// 83604CC: using guessed type int dword_83604CC;
// 8360560: using guessed type int dword_8360560;
// 8360660: using guessed type int dword_8360660;
// 8360678: using guessed type int dword_8360678;
// 836B7D4: using guessed type int dword_836B7D4;
// 836B7DC: using guessed type int dword_836B7DC;
// 836B7E8: using guessed type int dword_836B7E8;
// 836B830: using guessed type int dword_836B830;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD88: using guessed type int dword_83CCD88;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD98: using guessed type int dword_83CCD98;
// 83CCD9C: using guessed type int dword_83CCD9C;
// 83CCDA0: using guessed type int dword_83CCDA0;
// 83CCDB0: using guessed type int dword_83CCDB0;
// 83CCDBC: using guessed type int dword_83CCDBC;
// 83CCDC0: using guessed type int dword_83CCDC0;
// 83CCDC4: using guessed type int dword_83CCDC4;
// 83CCDC8: using guessed type int dword_83CCDC8;

//----- (08094776) --------------------------------------------------------
int __cdecl sub_8094776(char a1)
{
  return Com_Printf("%s: %s\n", a1);
}

//----- (08094798) --------------------------------------------------------
int __cdecl sub_8094798(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 67136;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 67104) ^ *(_BYTE *)(a1 + 338276));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (08094822) --------------------------------------------------------
int __cdecl SV_Netchan_Decode(int a1, _BYTE *a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-10h]
  _BYTE v5[5]; // [esp+7h] [ebp-9h]
  int i; // [esp+Ch] [ebp-4h]

  v4 = a1 + 1032 * (*(_DWORD *)(a1 + 67088) & 0x3F) + 1036;
  v5[4] = 0;
  *(_DWORD *)v5 = (unsigned __int8)(*(_BYTE *)(a1 + 67096) ^ *(_BYTE *)(a1 + 371084) ^ *(_BYTE *)(a1 + 67104));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    if ( !*(_BYTE *)(v4 + *(_DWORD *)&v5[1]) )
      *(_DWORD *)&v5[1] = 0;
    v5[0] ^= *(unsigned __int8 *)(v4 + (*(_DWORD *)&v5[1])++) << (i & 1);
    *a2++ ^= v5[0];
  }
  return result;
}

//----- (080948D0) --------------------------------------------------------
int *__cdecl SV_Netchan_TransmitNextFragment(int *a1)
{
  return Netchan_TransmitNextFragment(a1);
}

//----- (080948E3) --------------------------------------------------------
int *__cdecl SV_Netchan_Transmit(int a1, void *src, size_t n)
{
  sub_8094798(a1, (_BYTE *)src + 4, n - 4);
  return sub_80836E6(a1 + 338240, n, src);
}

//----- (08094928) --------------------------------------------------------
int __cdecl SV_Netchan_AddOOBProfilePacket(int a1)
{
  int result; // eax

  result = dword_8360804;
  if ( *(_DWORD *)(dword_8360804 + 32) )
  {
    NetProf_PrepProfiling((void **)&dword_83E1E08);
    result = sub_8082E8B(dword_83E1E08, a1, 0);
  }
  return result;
}
// 8360804: using guessed type int dword_8360804;
// 83E1E08: using guessed type int dword_83E1E08;

//----- (080949D3) --------------------------------------------------------
int sub_80949D3()
{
  int result; // eax
  _DWORD **i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  if ( dword_83CCD90 )
  {
    if ( dword_83E1E08 )
    {
      sub_8083018((_DWORD *)dword_83E1E08);
      sub_8083018((_DWORD *)(dword_83E1E08 + 752));
    }
    v2 = 0;
    for ( i = (_DWORD **)dword_83CCD90; ; i += 92781 )
    {
      result = v2;
      if ( v2 >= *(_DWORD *)(dword_836B804 + 32) )
        break;
      if ( *i )
      {
        if ( i[92767] )
        {
          sub_8083018(i[92767]);
          sub_8083018(i[92767] + 188);
        }
      }
      ++v2;
    }
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;
// 83E1E08: using guessed type int dword_83E1E08;

//----- (08094A7F) --------------------------------------------------------
int __cdecl sub_8094A7F(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-4F4h]
  int v3; // [esp+2Ch] [ebp-4CCh]
  int v4; // [esp+60h] [ebp-498h]
  int v5; // [esp+68h] [ebp-490h]
  int v6; // [esp+70h] [ebp-488h]
  int v7; // [esp+78h] [ebp-480h]
  int v8; // [esp+84h] [ebp-474h]
  int v9; // [esp+88h] [ebp-470h]
  int v10; // [esp+8Ch] [ebp-46Ch]
  char s[1024]; // [esp+90h] [ebp-468h] BYREF
  char dest[40]; // [esp+490h] [ebp-68h] BYREF
  char *i; // [esp+4B8h] [ebp-40h]
  _DWORD *v14; // [esp+4BCh] [ebp-3Ch]
  int v15; // [esp+4C0h] [ebp-38h]
  int v16; // [esp+4C4h] [ebp-34h]
  int v17; // [esp+4C8h] [ebp-30h]
  int v18; // [esp+4CCh] [ebp-2Ch]
  int v19; // [esp+4D0h] [ebp-28h]
  int v20; // [esp+4D4h] [ebp-24h]
  int v21; // [esp+4D8h] [ebp-20h]
  int v22; // [esp+4DCh] [ebp-1Ch]
  int v23; // [esp+4E0h] [ebp-18h]
  int v24; // [esp+4E4h] [ebp-14h]
  char v25[4]; // [esp+4E8h] [ebp-10h]
  int v26[3]; // [esp+4ECh] [ebp-Ch]

  *(_DWORD *)v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 9999;
  v17 = 0;
  v16 = 9999;
  if ( dword_83CCD90 )
  {
    sub_80949D3();
    if ( a1 )
      Com_Printf("\n\n", v2);
    Com_sprintf(s, 0x400u, "====================");
    if ( a1 )
      Com_Printf("%s\n", (char)s);
    Com_sprintf(s, 0x400u, "Server Network Profile:");
    if ( a1 )
      Com_Printf("%s\n\n", (char)s);
    Com_sprintf(
      s,
      0x400u,
      "                    | Sent To                | Recieved From          | Total Source Traffic   |");
    if ( a1 )
      Com_Printf("%s\n", (char)s);
    Com_sprintf(
      s,
      0x400u,
      "              Source|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|   bps|  max|  min|frag%%|");
    if ( a1 )
      Com_Printf("%s\n", (char)s);
    if ( dword_83E1E08 )
    {
      v14 = (_DWORD *)dword_83E1E08;
      *(_DWORD *)v25 += *(_DWORD *)(dword_83E1E08 + 724);
      v23 += *(_DWORD *)(dword_83E1E08 + 732);
      v22 += *(_DWORD *)(dword_83E1E08 + 736);
      v24 += *(_DWORD *)(dword_83E1E08 + 1476);
      v21 += *(_DWORD *)(dword_83E1E08 + 1484);
      v20 += *(_DWORD *)(dword_83E1E08 + 1488);
      if ( *(_DWORD *)(dword_83E1E08 + 744) > v19 )
        v19 = v14[186];
      if ( v14[187] < v18 )
        v18 = v14[187];
      if ( v14[374] > v17 )
        v17 = v14[374];
      if ( v14[375] < v16 )
        v16 = v14[375];
    }
    v26[0] = 0;
    i = (char *)dword_83CCD90;
    while ( v26[0] < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *(_DWORD *)i && *((_DWORD *)i + 92767) )
      {
        v14 = (_DWORD *)*((_DWORD *)i + 92767);
        *(_DWORD *)v25 += v14[181];
        v23 += v14[183];
        v22 += v14[184];
        v24 += v14[369];
        v21 += v14[371];
        v20 += v14[372];
        if ( v14[186] > v19 )
          v19 = v14[186];
        if ( v14[187] < v18 )
          v18 = v14[187];
        if ( v14[374] > v17 )
          v17 = v14[374];
        if ( v14[375] < v16 )
          v16 = v14[375];
      }
      ++v26[0];
      i += 371124;
    }
    if ( v23 + v21 <= 0 || v22 + v20 <= 0 )
      v15 = 0;
    else
      v15 = 100 * (v20 + v22) / (v21 + v23);
    v10 = v16;
    if ( v16 > v18 )
      v10 = v18;
    v9 = v17;
    if ( v17 < v19 )
      v9 = v19;
    v3 = *(_DWORD *)v25 + v24;
    if ( v21 )
      v8 = 100 * v20 / v21;
    else
      v8 = 0;
    if ( v23 )
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v25,
        v19,
        v18,
        100 * v22 / v23,
        v24,
        v17,
        v16,
        v8,
        v3,
        v9,
        v10,
        v15);
    else
      Com_sprintf(
        s,
        0x400u,
        "              Totals:%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|%6i|%5i|%5i| %3i%%|",
        *(_DWORD *)v25,
        v19,
        v18,
        0,
        v24,
        v17,
        v16,
        v8,
        v3,
        v9,
        v10,
        v15);
    if ( a1 )
      Com_Printf("%s\n", (char)s);
    if ( dword_83E1E08 )
    {
      v14 = (_DWORD *)dword_83E1E08;
      if ( *(_DWORD *)(dword_83E1E08 + 732) + *(_DWORD *)(dword_83E1E08 + 1484) <= 0 || v14[184] + v14[372] <= 0 )
        v15 = 0;
      else
        v15 = 100 * (v14[372] + v14[184]) / (v14[371] + v14[183]);
      v7 = v14[375];
      if ( v7 > v14[187] )
        v7 = v14[187];
      v6 = v14[374];
      if ( v6 < v14[186] )
        v6 = v14[186];
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
        v14[181],
        v14[186],
        v14[187],
        v14[185],
        v14[369],
        v14[374],
        v14[375],
        v14[373],
        v14[181] + v14[369],
        v6,
        v7,
        v15);
      if ( !a1 )
        goto LABEL_63;
    }
    else
    {
      Com_sprintf(
        s,
        0x400u,
        "  OutOfBand Messages:     0|    0|    0|   - |     0|    0|    0|   - |     0|    0|    0|   - |");
      if ( !a1 )
      {
LABEL_63:
        v26[0] = 0;
        for ( i = (char *)dword_83CCD90; ; i += 371124 )
        {
          result = v26[0];
          if ( v26[0] >= *(_DWORD *)(dword_836B804 + 32) )
            return result;
          if ( *(_DWORD *)i )
          {
            strncpy(dest, i + 68164, 0x11u);
            dest[16] = 0;
            v14 = (_DWORD *)*((_DWORD *)i + 92767);
            if ( !v14 )
            {
              Com_sprintf(
                s,
                0x400u,
                "#%2i-%16s:     0|    0|    0|   0%%|     0|    0|    0|   0%%|     0|    0|    0|   0%%|",
                v26[0],
                dest);
              if ( !a1 )
                goto LABEL_79;
LABEL_78:
              Com_Printf("%s\n", (char)s);
              goto LABEL_79;
            }
            if ( v14[183] + v14[371] <= 0 || v14[184] + v14[372] <= 0 )
              v15 = 0;
            else
              v15 = 100 * (v14[372] + v14[184]) / (v14[371] + v14[183]);
            v5 = v14[375];
            if ( v5 > v14[187] )
              v5 = v14[187];
            v4 = v14[374];
            if ( v4 < v14[186] )
              v4 = v14[186];
            Com_sprintf(
              s,
              0x400u,
              "#%2i-%16s: %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%| %5i|%5i|%5i| %3i%%|",
              v26[0],
              dest,
              v14[181],
              v14[186],
              v14[187],
              v14[185],
              v14[369],
              v14[374],
              v14[375],
              v14[373],
              v14[181] + v14[369],
              v4,
              v5,
              v15);
            if ( a1 )
              goto LABEL_78;
          }
LABEL_79:
          ++v26[0];
        }
      }
    }
    Com_Printf("%s\n", (char)s);
    goto LABEL_63;
  }
  return result;
}
// 8094AEE: variable 'v2' is possibly undefined
// 836B804: using guessed type int dword_836B804;
// 83E1E08: using guessed type int dword_83E1E08;

//----- (0809544C) --------------------------------------------------------
int __cdecl sub_809544C(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  int *v11; // [esp+24h] [ebp-4h]

  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  while ( v8 < a3 || v9 < a1 )
  {
    if ( v8 < a3 )
    {
      v10 = (int *)(dword_83CCDA4 + 240 * ((a4 + v8) % dword_83CCD94));
      v6 = *v10;
    }
    else
    {
      v6 = 9999;
    }
    if ( v9 < a1 )
    {
      v11 = (int *)(dword_83CCDA4 + 240 * ((a2 + v9) % dword_83CCD94));
      v7 = *v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v6 == v7 )
    {
      MSG_WriteDeltaEntity((int)a5, (int)v11, (int)v10, 0);
      ++v9;
      ++v8;
    }
    else if ( v6 >= v7 )
    {
      if ( v6 > v7 )
      {
        MSG_WriteDeltaEntity((int)a5, (int)v11, 0, 1);
        ++v9;
      }
    }
    else
    {
      MSG_WriteDeltaEntity((int)a5, 380 * v6 + 137813056, (int)v10, 1);
      ++v8;
    }
  }
  return MSG_WriteBits(a5, 1023, 10);
}
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCDA4: using guessed type int dword_83CCDA4;

//----- (080955C0) --------------------------------------------------------
_DWORD *__cdecl sub_80955C0(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  char *v11; // [esp+24h] [ebp-4h]

  v10 = 0;
  v11 = 0;
  v8 = 0;
  v9 = 0;
  while ( v8 < a3 || v9 < a1 )
  {
    if ( v8 < a3 )
    {
      v10 = (int *)(dword_83CCDA8 + 92 * ((a4 + v8) % dword_83CCD98));
      v6 = *v10;
    }
    else
    {
      v6 = 9999;
    }
    if ( v9 < a1 )
    {
      v11 = (char *)(dword_83CCDA8 + 92 * ((a2 + v9) % dword_83CCD98));
      v7 = *(_DWORD *)v11;
    }
    else
    {
      v7 = 9999;
    }
    if ( v6 == v7 )
    {
      sub_8081536(a5, v11, v10, 0);
      ++v9;
      ++v8;
    }
    else if ( v6 >= v7 )
    {
      if ( v6 > v7 )
      {
        sub_8081536(a5, v11, 0, 1);
        ++v9;
      }
    }
    else
    {
      sub_8081536(a5, 0, v10, 1);
      ++v8;
    }
  }
  return MSG_WriteBit0(a5);
}
// 83CCD98: using guessed type int dword_83CCD98;
// 83CCDA8: using guessed type int dword_83CCDA8;

//----- (0809570C) --------------------------------------------------------
int __cdecl sub_809570C(_DWORD *a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  char v5; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v7; // [esp+2Ch] [ebp-Ch]
  char *v8; // [esp+30h] [ebp-8h]
  _DWORD *v9; // [esp+34h] [ebp-4h]

  v9 = &a1[2106 * (a1[84569] & 0x1F) + 17164];
  if ( (int)a1[17157] > 0 && *a1 == 4 )
  {
    if ( a1[84569] - a1[17157] <= 28 )
    {
      v8 = (char *)&a1[2106 * (a1[17157] & 0x1F) + 17164];
      v7 = a1[84569] - a1[17157];
      if ( a1[2106 * (a1[17157] & 0x1F) + 19265] < dword_83CCD9C - dword_83CCD94 )
      {
        Com_DPrintf("%s: Delta request from out of date entities.\n", (const char *)a1 + 68164);
        v8 = 0;
        LOBYTE(v7) = 0;
      }
    }
    else
    {
      Com_DPrintf("%s: Delta request from out of date packet.\n", (const char *)a1 + 68164);
      v8 = 0;
      LOBYTE(v7) = 0;
    }
  }
  else
  {
    v8 = 0;
    LOBYTE(v7) = 0;
  }
  MSG_WriteByte(a2, 7);
  MSG_WriteLong(a2, dword_83CCD84);
  MSG_WriteByte(a2, v7);
  v5 = sv_serverId_value;
  if ( a1[17162] )
    v5 = sv_serverId_value | 1;
  if ( *a1 == 4 )
  {
    a1[1] = 1;
  }
  else if ( *a1 != 1 )
  {
    a1[1] = 0;
  }
  if ( !a1[1] )
    v5 |= 2u;
  MSG_WriteByte(a2, v5);
  if ( v8 )
  {
    sub_8081DD3(a2, v8, v9);
    v4 = *((_DWORD *)v8 + 2100);
    v3 = *((_DWORD *)v8 + 2102);
    sub_809544C(*((_DWORD *)v8 + 2099), *((_DWORD *)v8 + 2101), v9[2099], v9[2101], a2);
  }
  else
  {
    sub_8081DD3(a2, 0, v9);
    v4 = 0;
    v3 = 0;
    sub_809544C(0, 0, v9[2099], v9[2101], a2);
  }
  sub_80955C0(v4, v3, v9[2100], v9[2102], a2);
  result = dword_836B808;
  if ( *(_DWORD *)(dword_836B808 + 32) )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= *(_DWORD *)(dword_836B808 + 32) )
        break;
      MSG_WriteByte(a2, 1);
    }
  }
  return result;
}
// 836B808: using guessed type int dword_836B808;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD8C: using guessed type int sv_serverId_value;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD9C: using guessed type int dword_83CCD9C;

//----- (080959D0) --------------------------------------------------------
_DWORD *__cdecl SV_UpdateServerCommandsToClient(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = a1[16772] + 1; i <= a1[16771]; ++i )
  {
    MSG_WriteByte(a2, 5);
    MSG_WriteLong(a2, i);
    MSG_WriteString((int)a2, (char *)&a1[258 * (i & 0x3F) + 259]);
  }
  result = a1;
  a1[16773] = a1[16771];
  return result;
}

//----- (08095A5A) --------------------------------------------------------
int __cdecl sub_8095A5A(_DWORD *a1, _DWORD *a2, signed int a3)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int v5; // [esp+14h] [ebp-4h]

  for ( i = a1[16772] + 1; i <= a1[16771] && (int)(a2[3] + strlen((const char *)&a1[258 * (i & 0x3F) + 259]) + 6) < a3; ++i )
  {
    MSG_WriteByte(a2, 5);
    MSG_WriteLong(a2, i);
    MSG_WriteString((int)a2, (char *)&a1[258 * (i & 0x3F) + 259]);
  }
  v5 = i - 1;
  result = v5;
  if ( v5 > a1[16773] )
  {
    result = v5;
    a1[16773] = v5;
  }
  return result;
}

//----- (08095B2D) --------------------------------------------------------
int __cdecl sub_8095B2D(int a1)
{
  char v2; // [esp+4h] [ebp-14h]
  int i; // [esp+14h] [ebp-4h]

  Com_Printf("-- Unacknowledged Server Commands for client %i:%s --\n", 101 * ((a1 - (int)dword_83CCD90) >> 2));
  for ( i = *(_DWORD *)(a1 + 67088) + 1; i <= *(_DWORD *)(a1 + 67084); ++i )
    Com_Printf("cmd %5d: %8d: %s\n", i);
  return Com_Printf("----------", v2);
}
// 8095BDD: variable 'v2' is possibly undefined

//----- (08095BE4) --------------------------------------------------------
_DWORD *__cdecl sub_8095BE4(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (08095C0A) --------------------------------------------------------
_DWORD *__cdecl sub_8095C0A(int a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a2;
  if ( *a2 != 1024 )
  {
    a2[*a2 + 1] = a1;
    result = a2;
    ++*a2;
  }
  return result;
}

//----- (08095C30) --------------------------------------------------------
int __cdecl sub_8095C30(float *a1, int a2, _DWORD *a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+20h] [ebp-28h]
  char *v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]
  _DWORD *v10; // [esp+38h] [ebp-10h]
  int *v11; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]

  v5 = sub_805740A(a1);
  result = sub_804BD06(v5);
  v8 = result;
  if ( result >= 0 )
  {
    v7 = sub_804BCF0(v5);
    v6 = sub_8057A1A(v7);
    v4 = COERCE_FLOAT(VM_Call((int)gvm, 23));
    if ( v4 == 3.4028235e38 )
      v4 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_83CCC44 )
        return result;
      v11 = (int *)sub_808D314(i);
      if ( v11[60]
        && (v11[61] & 1) == 0
        && ((v11[61] & 0x800) == 0 || v11[62] == a2)
        && ((v11[61] & 0x2000) == 0 || v11[62] != a2)
        && i != a2 )
      {
        if ( (v11[61] & 0x18) != 0 )
          goto LABEL_34;
        if ( v11[63] )
        {
          if ( v11[63] < 0 || v11[63] - dword_83CCD84 >= 0 )
            goto LABEL_34;
          v11[63] = 0;
        }
        v10 = (_DWORD *)sub_808D34E(v11);
        if ( (sub_8057C89(v8, v10[88]) || sub_8057C89(v8, v10[89])) && v10[70] )
        {
          v9 = 0;
          for ( j = 0; j < v10[70]; ++j )
          {
            v9 = v10[j + 71];
            if ( (((int)(unsigned __int8)v6[v9 >> 3] >> (v9 & 7)) & 1) != 0 )
              break;
          }
          if ( j != v10[70] )
            goto LABEL_38;
          if ( v10[87] )
          {
            while ( v9 <= v10[87] && (((int)(unsigned __int8)v6[v9 >> 3] >> (v9 & 7)) & 1) == 0 )
              ++v9;
            if ( v9 != v10[87] )
            {
LABEL_38:
              if ( v4 == 0.0 || !loc_806AC6E((int)(v11 + 72), (int)(v11 + 75), (int)a1, v4) )
              {
LABEL_34:
                sub_8095BE4(i, a3);
                continue;
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 83CCC44: using guessed type int dword_83CCC44;
// 83CCD84: using guessed type int dword_83CCD84;

//----- (08095F4C) --------------------------------------------------------
int sub_8095F4C()
{
  return VM_Call((int)gvm, 20);
}

//----- (08095F70) --------------------------------------------------------
int __cdecl sub_8095F70(int a1, int a2, float *a3, int a4, _DWORD *a5, int a6)
{
  int result; // eax
  float v7; // [esp+28h] [ebp-240h]
  int v8; // [esp+30h] [ebp-238h]
  int v9; // [esp+34h] [ebp-234h]
  int v10; // [esp+38h] [ebp-230h]
  int v11; // [esp+3Ch] [ebp-22Ch] BYREF
  int v12[129]; // [esp+40h] [ebp-228h] BYREF
  int v13; // [esp+244h] [ebp-24h]
  char *v14; // [esp+248h] [ebp-20h]
  int v15; // [esp+24Ch] [ebp-1Ch]
  int v16; // [esp+250h] [ebp-18h]
  _DWORD *v17; // [esp+254h] [ebp-14h]
  int j; // [esp+258h] [ebp-10h]
  int i; // [esp+25Ch] [ebp-Ch]

  v8 = sub_805740A(a3);
  result = sub_804BD06(v8);
  v16 = result;
  if ( result >= 0 )
  {
    v15 = sub_804BCF0(v8);
    v14 = sub_8057A1A(v15);
    v7 = COERCE_FLOAT(VM_Call((int)gvm, 23));
    if ( v7 == 3.4028235e38 )
      v7 = 0.0;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a1 )
        break;
      v17 = (char *)dword_83CCDCC + 272 * ((i + a2) % 0x4000);
      if ( ((v17[60] & 0x800) == 0 || v17[61] == a4)
        && ((v17[60] & 0x2000) == 0 || v17[61] != a4)
        && (*v17 != a4 || (*(_DWORD *)(a6 + 12) & 0x10000) == 0) )
      {
        if ( (v17[60] & 0x18) != 0 )
          goto LABEL_27;
        v13 = sub_805765D(v17 + 62, v17 + 65, (int)v12, 128, &v11);
        if ( v13 )
        {
          for ( j = 0; j < v13; ++j )
          {
            v10 = sub_804BD06(v12[j]);
            if ( sub_8057C89(v16, v10) )
              break;
          }
          if ( j != v13 )
          {
            for ( j = 0; j < v13; ++j )
            {
              v9 = sub_804BCF0(v12[j]);
              if ( v9 != -1 && (((int)(unsigned __int8)v14[v9 >> 3] >> (v9 & 7)) & 1) != 0 )
                break;
            }
            if ( j != v13 && (v7 == 0.0 || !loc_806AC6E((int)(v17 + 62), (int)(v17 + 65), (int)a3, v7)) )
LABEL_27:
              sub_8095C0A(i, a5);
          }
        }
      }
    }
  }
  return result;
}

//----- (08096273) --------------------------------------------------------
int sub_8096273()
{
  return VM_Call((int)gvm, 19);
}

//----- (08096297) --------------------------------------------------------
int sub_8096297()
{
  return VM_Call((int)gvm, 21);
}

//----- (080962C2) --------------------------------------------------------
int *__cdecl sub_80962C2(int a1)
{
  int *v1; // ebx
  int *v2; // ebx
  int *v3; // ebx
  int *v4; // ebx
  int *v5; // ebx
  int v8[32768]; // [esp+80h] [ebp-20068h] BYREF
  int s; // [esp+20080h] [ebp-68h] BYREF
  void *dest; // [esp+20084h] [ebp-64h]
  size_t n; // [esp+2008Ch] [ebp-5Ch]
  int v12; // [esp+20090h] [ebp-58h]
  int v13; // [esp+200A8h] [ebp-40h]
  int v14; // [esp+200ACh] [ebp-3Ch]
  int v15; // [esp+200B0h] [ebp-38h]
  int v16; // [esp+200B4h] [ebp-34h]
  size_t v17; // [esp+200B8h] [ebp-30h]
  int v18; // [esp+200BCh] [ebp-2Ch]
  _DWORD *v19; // [esp+200C0h] [ebp-28h]
  int v20; // [esp+200C4h] [ebp-24h]
  int i; // [esp+200C8h] [ebp-20h]
  int v22; // [esp+200CCh] [ebp-1Ch]
  int v23; // [esp+200D0h] [ebp-18h]
  void *v24; // [esp+200D4h] [ebp-14h]
  _DWORD *v25; // [esp+200D8h] [ebp-10h]
  int *v26; // [esp+200DCh] [ebp-Ch]

  v19 = (char *)dword_83CCDB4 + 8 * (a1 % 1200);
  if ( *v19 >= dword_83CCDBC - 0x2000000 )
  {
    v16 = dword_83CCDC8 - 512;
    if ( dword_83CCDC8 - 512 < 0 )
      v16 = 0;
    for ( i = dword_83CCDC8 - 1; i >= v16; --i )
    {
      v26 = (int *)((char *)dword_83CCDD4 + 28 * (i % 512));
      if ( *v26 == a1 )
      {
        if ( v26[3] >= dword_83CCDC0 - 0x4000 && v26[5] >= dword_83CCDC4 - 4096 )
          return v26;
        break;
      }
    }
    MSG_Init(&s, (int)v8, 0x20000);
    n = v19[1];
    v18 = *v19 % 0x2000000;
    v17 = 0x2000000 - v18;
    if ( (int)n > 0x2000000 - v18 )
    {
      memcpy(dest, (char *)dword_83CCDB8 + v18, v17);
      memcpy((char *)dest + v17, dword_83CCDB8, n - v17);
    }
    else
    {
      memcpy(dest, (char *)dword_83CCDB8 + v18, n);
    }
    if ( sub_807FBC2(&s) )
    {
      v26 = (int *)((char *)dword_83CCDD4 + 28 * (dword_83CCDC8 % 512));
      *v26 = a1;
      v26[2] = 0;
      v26[3] = dword_83CCDC0;
      v26[4] = 0;
      v26[5] = dword_83CCDC4;
      v26[6] = 0;
      v4 = v26;
      v4[1] = MSG_ReadLong(&s);
      while ( sub_807FBC2(&s) )
      {
        v20 = MSG_ReadBits(&s, 6);
        if ( v12 > (int)n )
          Com_Error(1, (char *)&byte_80E07C0);
        v23 = (int)dword_83CCDD0 + 8492 * (dword_83CCDC4 % 4096);
        sub_8081A8F((int)&s, 0, (void *)(v23 + 4), v20);
        v5 = (int *)v23;
        *v5 = sub_807FBC2(&s);
        if ( *(_DWORD *)v23 )
          sub_8082640(&s, 0, (char *)(v23 + 96));
        if ( ++dword_83CCDC4 > 2147483645 )
          Com_Error(0, (char *)&byte_80E0800);
        ++v26[4];
      }
      while ( 1 )
      {
        v20 = MSG_ReadBits(&s, 10);
        if ( v20 == 1023 )
          break;
        if ( v12 > (int)n )
          Com_Error(1, (char *)&byte_80E07C0);
        v24 = (char *)dword_83CCDCC + 272 * (dword_83CCDC0 % 0x4000);
        sub_8081A49((int)&s, (void *)(380 * v20 + 137813056), v24, v20);
        if ( ++dword_83CCDC0 > 2147483645 )
          Com_Error(0, (char *)&byte_80E0840);
        ++v26[2];
      }
      if ( ++dword_83CCDC8 > 2147483645 )
        Com_Error(0, (char *)&byte_80E0880);
    }
    else
    {
      v15 = MSG_ReadLong(&s);
      if ( v15 < dword_83CCDB0 - 1200 )
        return 0;
      v19 = (char *)dword_83CCDB4 + 8 * (v15 % 1200);
      if ( *v19 < dword_83CCDBC - 0x2000000 )
        return 0;
      v25 = sub_80962C2(v15);
      if ( !v25 )
        return 0;
      v26 = (int *)((char *)dword_83CCDD4 + 28 * (dword_83CCDC8 % 512));
      *v26 = a1;
      v26[2] = 0;
      v26[3] = dword_83CCDC0;
      v26[4] = 0;
      v26[5] = dword_83CCDC4;
      v26[6] = 1;
      v1 = v26;
      v1[1] = MSG_ReadLong(&s);
      v14 = 0;
      v22 = 0;
      if ( (int)v25[4] > 0 )
      {
        v22 = (int)dword_83CCDD0 + 8492 * ((v14 + v25[5]) % 4096);
        v13 = *(_DWORD *)(v22 + 4);
      }
      else
      {
        v13 = 99999;
      }
      while ( sub_807FBC2(&s) )
      {
        v20 = MSG_ReadBits(&s, 6);
        if ( v12 > (int)n )
          Com_Error(1, (char *)&byte_80E07C0);
        while ( v13 < v20 )
        {
          if ( ++v14 < v25[4] )
          {
            v22 = (int)dword_83CCDD0 + 8492 * ((v14 + v25[5]) % 4096);
            v13 = *(_DWORD *)(v22 + 4);
          }
          else
          {
            v13 = 99999;
          }
        }
        if ( v13 == v20 )
        {
          v23 = (int)dword_83CCDD0 + 8492 * (dword_83CCDC4 % 4096);
          sub_8081A8F((int)&s, (void *)(v22 + 4), (void *)(v23 + 4), v20);
          v2 = (int *)v23;
          *v2 = sub_807FBC2(&s);
          if ( *(_DWORD *)v23 )
            sub_8082640(&s, (char *)(v22 + 96), (char *)(v23 + 96));
          if ( ++dword_83CCDC4 > 2147483645 )
            Com_Error(0, (char *)&byte_80E0800);
          ++v26[4];
          if ( ++v14 < v25[4] )
          {
            v22 = (int)dword_83CCDD0 + 8492 * ((v14 + v25[5]) % 4096);
            v13 = *(_DWORD *)(v22 + 4);
          }
          else
          {
            v13 = 99999;
          }
        }
        else
        {
          v23 = (int)dword_83CCDD0 + 8492 * (dword_83CCDC4 % 4096);
          sub_8081A8F((int)&s, 0, (void *)(v23 + 4), v20);
          v3 = (int *)v23;
          *v3 = sub_807FBC2(&s);
          if ( *(_DWORD *)v23 )
            sub_8082640(&s, 0, (char *)(v23 + 96));
          if ( ++dword_83CCDC4 > 2147483645 )
            Com_Error(0, (char *)&byte_80E0800);
          ++v26[4];
        }
      }
      while ( 1 )
      {
        v20 = MSG_ReadBits(&s, 10);
        if ( v20 == 1023 )
          break;
        if ( v12 > (int)n )
          Com_Error(1, (char *)&byte_80E07C0);
        v24 = (char *)dword_83CCDCC + 272 * (dword_83CCDC0 % 0x4000);
        sub_8081A49((int)&s, (void *)(380 * v20 + 137813056), v24, v20);
        if ( ++dword_83CCDC0 > 2147483645 )
          Com_Error(0, (char *)&byte_80E0840);
        ++v26[2];
      }
      if ( ++dword_83CCDC8 > 2147483645 )
        Com_Error(0, (char *)&byte_80E0880);
    }
    return v26;
  }
  return 0;
}
// 83CCDB0: using guessed type int dword_83CCDB0;
// 83CCDBC: using guessed type int dword_83CCDBC;
// 83CCDC0: using guessed type int dword_83CCDC0;
// 83CCDC4: using guessed type int dword_83CCDC4;
// 83CCDC8: using guessed type int dword_83CCDC8;

//----- (08096D9E) --------------------------------------------------------
int *__cdecl sub_8096D9E(int *a1)
{
  int v1; // edx
  int *v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]

  if ( !dword_83CCDAC )
    return 0;
  if ( *a1 <= 0 )
    return 0;
  v1 = *(_DWORD *)(dword_836B7D4 + 32) * *a1 / 1000;
  v5 = dword_83CCDB0 - v1;
  if ( dword_83CCDB0 - v1 < dword_83CCDB0 - 1200 )
  {
    v5 = dword_83CCDB0 - 1200;
    *a1 = 1000 * (dword_83CCDB0 - (dword_83CCDB0 - 1200)) / *(_DWORD *)(dword_836B7D4 + 32);
  }
  if ( v5 < 0 )
  {
    v5 = 0;
    *a1 = 1000 * dword_83CCDB0 / *(_DWORD *)(dword_836B7D4 + 32);
  }
  while ( v5 < dword_83CCDB0 )
  {
    v4 = sub_80962C2(v5);
    if ( v4 )
      return v4;
    ++v5;
  }
  *a1 = 0;
  return 0;
}
// 836B7D4: using guessed type int dword_836B7D4;
// 83CCDAC: using guessed type int dword_83CCDAC;
// 83CCDB0: using guessed type int dword_83CCDB0;

//----- (08096EBE) --------------------------------------------------------
int sub_8096EBE()
{
  return VM_Call((int)gvm, 10);
}

//----- (08096EE9) --------------------------------------------------------
int __cdecl sub_8096EE9(int a1, int a2, void *a3)
{
  if ( *((_DWORD *)dword_83CCD90 + 92781 * a1) != 4 )
    return 0;
  if ( !sub_8096EBE() )
    return 0;
  qmemcpy(a3, (const void *)sub_8096273(), 0x5Cu);
  return 1;
}

//----- (08096F65) --------------------------------------------------------
int __cdecl sub_8096F65(int a1, int *a2, int a3, void *a4)
{
  unsigned int v5; // [esp+10h] [ebp-38h]
  _DWORD *v6; // [esp+14h] [ebp-34h]
  void *v7; // [esp+18h] [ebp-30h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  _DWORD *v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int i; // [esp+34h] [ebp-14h]
  unsigned int j; // [esp+34h] [ebp-14h]
  int *v14; // [esp+38h] [ebp-10h]

  v14 = sub_8096D9E(a2);
  if ( v14 )
  {
    v11 = dword_83CCD84 - v14[1];
    for ( i = 0; ; ++i )
    {
      if ( i >= v14[4] )
        return 0;
      v10 = (char *)dword_83CCDD0 + 8492 * ((i + v14[5]) % 4096);
      if ( v10[1] == a1 )
        break;
    }
    if ( !*v10 )
      return 0;
    v7 = (void *)a3;
    v6 = v10 + 24;
    v5 = 8396;
    if ( (a3 & 4) != 0 )
    {
      *(_DWORD *)a3 = *v6;
      v7 = (void *)(a3 + 4);
      v6 = v10 + 25;
      v5 = 8392;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
    qmemcpy(a4, v10 + 1, 0x5Cu);
    if ( *(_DWORD *)a3 )
      *(_DWORD *)a3 += v11;
    if ( *(_DWORD *)(a3 + 16) )
      *(_DWORD *)(a3 + 16) += v11;
    if ( *(_DWORD *)(a3 + 56) )
      *(_DWORD *)(a3 + 56) += v11;
    if ( *(_DWORD *)(a3 + 100) )
      *(_DWORD *)(a3 + 100) += v11;
    if ( *(_DWORD *)(a3 + 212) )
      *(_DWORD *)(a3 + 212) += v11;
    if ( *(_DWORD *)(a3 + 992) )
      *(_DWORD *)(a3 + 992) += v11;
    for ( j = 0; j <= 0x1E; ++j )
    {
      if ( *(_DWORD *)(a3 + 112 * j + 5012) )
        *(_DWORD *)(a3 + 112 * j + 5012) += v11;
      if ( *(_DWORD *)(a3 + 112 * j + 4956) )
        *(_DWORD *)(a3 + 112 * j + 4956) += v11;
      if ( *(_DWORD *)(a3 + 112 * j + 4988) )
        *(_DWORD *)(a3 + 112 * j + 4988) += v11;
      if ( *(_DWORD *)(a3 + 112 * j + 5004) )
        *(_DWORD *)(a3 + 112 * j + 5004) += v11;
    }
    *(_DWORD *)(a3 + 8392) += v11;
    v9 = 1;
  }
  else
  {
    if ( *a2 > 0 )
      v8 = 0;
    else
      v8 = sub_8096EE9(a1, a3, a4);
    v9 = v8;
  }
  return v9;
}
// 83CCD84: using guessed type int dword_83CCD84;

//----- (080972D8) --------------------------------------------------------
char *__cdecl sub_80972D8(char *a1)
{
  char *result; // eax
  int v2; // [esp+30h] [ebp-1098h]
  unsigned int v3; // [esp+3Ch] [ebp-108Ch]
  _DWORD *v4; // [esp+40h] [ebp-1088h]
  int v5; // [esp+44h] [ebp-1084h]
  int v6; // [esp+48h] [ebp-1080h]
  int v7; // [esp+4Ch] [ebp-107Ch] BYREF
  int v8; // [esp+50h] [ebp-1078h]
  int v9; // [esp+54h] [ebp-1074h]
  char *v10; // [esp+58h] [ebp-1070h]
  int *v11; // [esp+5Ch] [ebp-106Ch]
  char *v12; // [esp+60h] [ebp-1068h]
  int v13; // [esp+64h] [ebp-1064h]
  char *v14; // [esp+68h] [ebp-1060h]
  int v15; // [esp+6Ch] [ebp-105Ch]
  void *v16; // [esp+70h] [ebp-1058h]
  void *v17; // [esp+74h] [ebp-1054h]
  const void *v18; // [esp+78h] [ebp-1050h]
  int i; // [esp+7Ch] [ebp-104Ch]
  char v20[4]; // [esp+80h] [ebp-1048h] BYREF
  int v21[1030]; // [esp+84h] [ebp-1044h]
  char *v22; // [esp+109Ch] [ebp-2Ch]
  char v23[4]; // [esp+10A0h] [ebp-28h] BYREF
  int v24; // [esp+10A4h] [ebp-24h]
  float v25; // [esp+10A8h] [ebp-20h]
  int *j; // [esp+10D0h] [ebp+8h]

  v22 = &a1[8424 * (*((_DWORD *)a1 + 84569) & 0x1F) + 68656];
  *((_DWORD *)v22 + 2099) = 0;
  *((_DWORD *)v22 + 2100) = 0;
  result = (char *)*((_DWORD *)a1 + 17040);
  v14 = result;
  if ( result )
  {
    result = a1;
    if ( *(_DWORD *)a1 != 1 )
    {
      *((_DWORD *)v22 + 2101) = dword_83CCD9C;
      result = (char *)dword_83CCDA0;
      *((_DWORD *)v22 + 2102) = dword_83CCDA0;
      if ( sv == 2 )
      {
        *(_DWORD *)v20 = 0;
        v13 = -266129563 * ((a1 - (_BYTE *)dword_83CCD90) >> 2);
        v7 = sub_8095F4C();
        v11 = sub_8096D9E(&v7);
        sub_8096297();
        if ( v11 )
          v6 = dword_83CCD84 - v11[1];
        else
          v6 = 0;
        v9 = v6;
        v12 = v22;
        v5 = (int)v22;
        v4 = (_DWORD *)SV_GameClientNum(v13);
        v3 = 8396;
        if ( (v5 & 4) != 0 )
        {
          *(_DWORD *)v5 = *v4;
          v5 += 4;
          ++v4;
          v3 = 8392;
        }
        qmemcpy((void *)v5, v4, 4 * (v3 >> 2));
        v13 = *((_DWORD *)v12 + 43);
        if ( v13 < 0 || v13 > 1023 )
          Com_Error(1, (char *)&byte_80E08C0);
        v15 = 380 * v13 + 137813048;
        *(_DWORD *)v23 = *((_DWORD *)v12 + 5);
        v24 = *((_DWORD *)v12 + 6);
        v25 = *((float *)v12 + 7);
        v25 = v25 + *((float *)v12 + 52);
        sub_8086F1F((int)v23, *((_DWORD *)v12 + 49), *((float *)v12 + 16), 16.0, 20.0);
        if ( v11 )
        {
          sub_8095F70(v11[2], v11[3], (float *)v23, v13, v20, (int)v12);
          for ( i = 0; i < *(int *)v20; ++i )
          {
            v10 = (char *)dword_83CCDCC + 272 * ((v21[i] + v11[3]) % 0x4000);
            v17 = (void *)(dword_83CCDA4 + 240 * (dword_83CCD9C % dword_83CCD94));
            qmemcpy(v17, v10, 0xF0u);
            if ( *((_DWORD *)v17 + 4) )
              *((_DWORD *)v17 + 4) += v9;
            if ( *((_DWORD *)v17 + 13) )
              *((_DWORD *)v17 + 13) += v9;
            if ( *((_DWORD *)v17 + 21) )
              *((_DWORD *)v17 + 21) += v9;
            if ( *((_DWORD *)v17 + 22) )
              *((_DWORD *)v17 + 22) += v9;
            if ( ++dword_83CCD9C > 2147483645 )
              Com_Error(0, (char *)&byte_80E0900);
            ++*((_DWORD *)v22 + 2099);
          }
          for ( i = 0; ; ++i )
          {
            result = (char *)i;
            if ( i >= v11[4] )
              break;
            v2 = i + v11[5];
            v8 = (int)dword_83CCDD0 + 8492 * (v2 % 4096);
            v16 = (void *)(dword_83CCDA8 + 92 * (dword_83CCDA0 % dword_83CCD98));
            qmemcpy(v16, (const void *)(v8 + 4), 0x5Cu);
            if ( ++dword_83CCDA0 > 2147483645 )
              Com_Error(0, (char *)&byte_80E0940);
            ++*((_DWORD *)v22 + 2100);
          }
        }
        else
        {
          sub_8095C30((float *)v23, v13, v20);
          for ( i = 0; i < *(int *)v20; ++i )
          {
            v18 = (const void *)sub_808D314(v21[i]);
            v17 = (void *)(dword_83CCDA4 + 240 * (dword_83CCD9C % dword_83CCD94));
            qmemcpy(v17, v18, 0xF0u);
            if ( ++dword_83CCD9C > 2147483645 )
              Com_Error(0, (char *)&byte_80E0900);
            ++*((_DWORD *)v22 + 2099);
          }
          i = 0;
          for ( j = (int *)dword_83CCD90; ; j += 92781 )
          {
            result = (char *)i;
            if ( i >= *(_DWORD *)(dword_836B804 + 32) )
              break;
            if ( *j > 1 )
            {
              v16 = (void *)(dword_83CCDA8 + 92 * (dword_83CCDA0 % dword_83CCD98));
              qmemcpy(v16, (const void *)sub_8096273(), 0x5Cu);
              if ( ++dword_83CCDA0 > 2147483645 )
                Com_Error(0, (char *)&byte_80E0940);
              ++*((_DWORD *)v22 + 2100);
            }
            ++i;
          }
        }
      }
    }
  }
  return result;
}
// 836B804: using guessed type int dword_836B804;
// 836B820: using guessed type int sv;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCD94: using guessed type int dword_83CCD94;
// 83CCD98: using guessed type int dword_83CCD98;
// 83CCD9C: using guessed type int dword_83CCD9C;
// 83CCDA0: using guessed type int dword_83CCDA0;
// 83CCDA4: using guessed type int dword_83CCDA4;
// 83CCDA8: using guessed type int dword_83CCDA8;

//----- (080979AB) --------------------------------------------------------
int __cdecl sub_80979AB(int a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  if ( a2 > 1500 )
    a2 = 1500;
  v3 = *(_DWORD *)(a1 + 338228);
  if ( *(_DWORD *)(dword_83CCD4C + 32) )
  {
    if ( *(int *)(dword_83CCD4C + 32) <= 999 )
      Cvar_Set("sv_MaxRate", "1000");
    if ( *(_DWORD *)(dword_83CCD4C + 32) < v3 )
      v3 = *(_DWORD *)(dword_83CCD4C + 32);
  }
  return (1000 * a2 + 48000) / v3;
}
// 83CCD4C: using guessed type int dword_83CCD4C;

//----- (08097A2F) --------------------------------------------------------
size_t __cdecl SV_SendMessageToClient(int a1, int a2)
{
  size_t result; // eax
  char dest[4]; // [esp+20h] [ebp-4018h] BYREF
  int v4; // [esp+24h] [ebp-4014h] BYREF
  size_t n; // [esp+4028h] [ebp-10h]
  int v6; // [esp+402Ch] [ebp-Ch]

  memcpy(dest, *(const void **)(a1 + 4), sizeof(dest));
  n = MSG_WriteBitsCompress((unsigned __int8 *)(*(_DWORD *)(a1 + 4) + 4), (int)&v4, *(_DWORD *)(a1 + 12) - 4) + 4;
  if ( *(_DWORD *)(a2 + 8) )
    SV_DropClient(a2, *(_DWORD *)(a2 + 8));
  *(_DWORD *)(a2 + 8424 * (*(_DWORD *)(a2 + 338276) & 0x1F) + 77076) = n;
  *(_DWORD *)(a2 + 8424 * (*(_DWORD *)(a2 + 338276) & 0x1F) + 77068) = dword_83CCD88;
  *(_DWORD *)(a2 + 8424 * (*(_DWORD *)(a2 + 338276) & 0x1F) + 77072) = -1;
  SV_Netchan_Transmit(a2, dest, n);
  if ( *(_DWORD *)(a2 + 338248) == 2 || Sys_IsLANAddress(*(_DWORD *)(a2 + 338248), *(_DWORD *)(a2 + 338252)) )
  {
    result = dword_83CCD88 - 1;
    *(_DWORD *)(a2 + 68644) = dword_83CCD88 - 1;
  }
  else
  {
    v6 = sub_80979AB(a2, n);
    if ( v6 >= *(_DWORD *)(a2 + 338232) )
    {
      *(_DWORD *)(a2 + 68648) = 1;
    }
    else
    {
      v6 = *(_DWORD *)(a2 + 338232);
      *(_DWORD *)(a2 + 68648) = 0;
    }
    *(_DWORD *)(a2 + 68644) = dword_83CCD88 + v6;
    if ( *(_DWORD *)a2 != 4 && !*(_BYTE *)(a2 + 68196) && *(_DWORD *)(a2 + 68644) < dword_83CCD88 + 1000 )
      *(_DWORD *)(a2 + 68644) = dword_83CCD88 + 1000;
    result = n;
    dword_83CCCA4 += n;
  }
  return result;
}
// 83CCCA4: using guessed type int dword_83CCCA4;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08097C2F) --------------------------------------------------------
size_t __cdecl SV_SendClientSnapshot(int a1)
{
  int v2[4096]; // [esp+20h] [ebp-4028h] BYREF
  int s[10]; // [esp+4020h] [ebp-28h] BYREF

  if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 1 )
    sub_80972D8((char *)a1);
  MSG_Init(s, (int)v2, 0x4000);
  MSG_WriteLong(s, *(_DWORD *)(a1 + 67132));
  if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 1 )
  {
    SV_UpdateServerCommandsToClient((_DWORD *)a1, s);
    sub_809570C((_DWORD *)a1, s);
  }
  if ( *(_DWORD *)a1 != 1 )
    SV_WriteDownloadToClient(a1, s);
  MSG_WriteByte(s, 8);
  if ( s[0] )
  {
    Com_Printf("WARNING: msg overflowed for %s, trying to recover\n", a1 + 68);
    if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 1 )
    {
      sub_8095B2D(a1);
      MSG_Init(s, (int)v2, 0x4000);
      MSG_WriteLong(s, *(_DWORD *)(a1 + 67132));
      sub_8095A5A((_DWORD *)a1, s, 0x4000);
      MSG_WriteByte(s, 8);
    }
    if ( s[0] )
    {
      Com_Printf("WARNING: client disconnected for msg overflow: %s\n", a1 + 68);
      NET_OutOfBandPrint(
        1,
        *(_DWORD *)(a1 + 338248),
        *(_DWORD *)(a1 + 338252),
        *(_DWORD *)(a1 + 338256),
        *(_DWORD *)(a1 + 338260),
        *(_DWORD *)(a1 + 338264),
        "disconnect");
      SV_DropClient(a1, (int)"EXE_SERVERMESSAGEOVERFLOW");
    }
  }
  return SV_SendMessageToClient((int)s, a1);
}

//----- (08097E1C) --------------------------------------------------------
void sub_8097E1C()
{
  _DWORD *v0; // eax
  _DWORD *v1; // eax
  int *v2; // ebx
  int v3[32768]; // [esp+40h] [ebp-22278h] BYREF
  int s; // [esp+20040h] [ebp-2278h] BYREF
  void *src; // [esp+20044h] [ebp-2274h]
  size_t n; // [esp+2004Ch] [ebp-226Ch]
  int v7; // [esp+20068h] [ebp-2250h]
  int v8; // [esp+2006Ch] [ebp-224Ch]
  int v9; // [esp+20070h] [ebp-2248h]
  int v10; // [esp+20074h] [ebp-2244h]
  int v11; // [esp+20078h] [ebp-2240h]
  char v12[4]; // [esp+2007Ch] [ebp-223Ch]
  int v13; // [esp+20080h] [ebp-2238h]
  int v14; // [esp+20084h] [ebp-2234h]
  int v15; // [esp+20088h] [ebp-2230h]
  int *v16; // [esp+2008Ch] [ebp-222Ch]
  _DWORD v17[2102]; // [esp+20090h] [ebp-2228h] BYREF
  size_t v18; // [esp+22168h] [ebp-150h]
  int v19; // [esp+2216Ch] [ebp-14Ch]
  _DWORD *v20; // [esp+22170h] [ebp-148h]
  int *v21; // [esp+22174h] [ebp-144h]
  int i; // [esp+22178h] [ebp-140h]
  int v23; // [esp+2217Ch] [ebp-13Ch]
  _DWORD v24[60]; // [esp+22180h] [ebp-138h] BYREF
  int v25; // [esp+22270h] [ebp-48h]
  int v26; // [esp+22274h] [ebp-44h]
  int v27; // [esp+22278h] [ebp-40h]
  int v28; // [esp+2227Ch] [ebp-3Ch]
  int v29; // [esp+22280h] [ebp-38h]
  int v30; // [esp+22284h] [ebp-34h]
  int v31; // [esp+22288h] [ebp-30h]
  int v32; // [esp+2228Ch] [ebp-2Ch]
  int *v33; // [esp+22298h] [ebp-20h]
  int j; // [esp+2229Ch] [ebp-1Ch]

  if ( sv == 2 && dword_83CCDAC )
  {
    MSG_Init(&s, (int)v3, 0x20000);
    v15 = dword_83CCDC8 - 512;
    if ( dword_83CCDC8 - 512 < 0 )
      v15 = 0;
    v14 = dword_83CCDB0 - *(_DWORD *)(dword_836B7D4 + 32);
    for ( i = dword_83CCDC8 - 1; i >= v15; --i )
    {
      v16 = (int *)((char *)dword_83CCDD4 + 28 * (i % 512));
      if ( *v16 >= v14 && !v16[6] )
      {
        if ( v16[3] >= dword_83CCDC0 - 0x4000 && v16[5] >= dword_83CCDC4 - 4096 )
        {
          MSG_WriteBit0(&s);
          MSG_WriteLong(&s, *v16);
          MSG_WriteLong(&s, dword_83CCD84);
          v11 = *(_DWORD *)(dword_836B804 + 32);
          v10 = v16[4];
          v13 = 0;
          v9 = 0;
          v8 = 0;
          while ( v9 < v11 || v8 < v10 )
          {
            if ( v9 >= v11 || *((int *)dword_83CCD90 + 92781 * v9) > 1 )
            {
              if ( v8 < v10 )
              {
                v13 = (int)dword_83CCDD0 + 8492 * ((v8 + v16[5]) % 4096);
                v7 = *(_DWORD *)(v13 + 4);
              }
              else
              {
                v7 = 9999;
              }
              if ( v9 == v7 )
              {
                v0 = (_DWORD *)sub_8096273();
                sub_8081536(&s, (char *)(v13 + 4), v0, 1);
                if ( sub_8096EBE() )
                {
                  MSG_WriteBit1(&s);
                  sub_8081DD3(&s, (char *)(v13 + 96), v17);
                }
                else
                {
                  MSG_WriteBit0(&s);
                }
                ++v8;
                ++v9;
              }
              else if ( v9 >= v7 )
              {
                if ( v9 > v7 )
                  ++v8;
              }
              else
              {
                v1 = (_DWORD *)sub_8096273();
                sub_8081536(&s, 0, v1, 1);
                if ( sub_8096EBE() )
                {
                  MSG_WriteBit1(&s);
                  sub_8081DD3(&s, 0, v17);
                }
                else
                {
                  MSG_WriteBit0(&s);
                }
                ++v9;
              }
            }
            else
            {
              ++v9;
            }
          }
          MSG_WriteBit0(&s);
          for ( j = 0; j < dword_83CCC44; ++j )
          {
            v33 = (int *)sub_808D314(j);
            if ( v33[60] )
            {
              if ( (v33[61] & 1) == 0 )
              {
                v23 = sub_808D34E(v33);
                if ( (v33[61] & 0x18) != 0 || *(_DWORD *)(v23 + 280) || v33[63] )
                {
                  qmemcpy(v24, v33, sizeof(v24));
                  v25 = v33[61];
                  if ( v33[63] )
                    v25 |= 8u;
                  v26 = v33[62];
                  v27 = v33[72];
                  v28 = v33[73];
                  v29 = v33[74];
                  v30 = v33[75];
                  v31 = v33[76];
                  v32 = v33[77];
                  sub_80814E8(&s, (_DWORD *)(380 * *v33 + 137813056), v24, 1);
                }
              }
            }
          }
          goto LABEL_69;
        }
        break;
      }
    }
    MSG_WriteBit1(&s);
    MSG_WriteLong(&s, dword_83CCD84);
    v16 = (int *)((char *)dword_83CCDD4 + 28 * (dword_83CCDC8 % 512));
    *v16 = dword_83CCDB0;
    v16[2] = 0;
    v16[3] = dword_83CCDC0;
    v16[4] = 0;
    v16[5] = dword_83CCDC4;
    v16[6] = 0;
    v16[1] = dword_83CCD84;
    i = 0;
    v21 = (int *)dword_83CCD90;
    while ( i < *(_DWORD *)(dword_836B804 + 32) )
    {
      if ( *v21 > 1 )
      {
        v13 = (int)dword_83CCDD0 + 8492 * (dword_83CCDC4 % 4096);
        qmemcpy((void *)(v13 + 4), (const void *)sub_8096273(), 0x5Cu);
        sub_8081536(&s, 0, (_DWORD *)(v13 + 4), 1);
        v2 = (int *)v13;
        *v2 = sub_8096EBE();
        if ( *(_DWORD *)v13 )
        {
          MSG_WriteBit1(&s);
          sub_8081DD3(&s, 0, (_DWORD *)(v13 + 96));
        }
        else
        {
          MSG_WriteBit0(&s);
        }
        if ( ++dword_83CCDC4 > 2147483645 )
          Com_Error(0, (char *)&byte_80E0800);
        ++v16[4];
      }
      ++i;
      v21 += 92781;
    }
    MSG_WriteBit0(&s);
    for ( j = 0; j < dword_83CCC44; ++j )
    {
      v33 = (int *)sub_808D314(j);
      if ( v33[60] )
      {
        if ( (v33[61] & 1) == 0 )
        {
          v23 = sub_808D34E(v33);
          if ( (v33[61] & 0x18) != 0 || *(_DWORD *)(v23 + 280) || v33[63] )
          {
            *(_DWORD *)v12 = (char *)dword_83CCDCC + 272 * (dword_83CCDC0 % 0x4000);
            qmemcpy(*(void **)v12, v33, 0xF0u);
            *(_DWORD *)(*(_DWORD *)v12 + 240) = v33[61];
            if ( v33[63] )
              *(_DWORD *)(*(_DWORD *)v12 + 240) |= 8u;
            *(_DWORD *)(*(_DWORD *)v12 + 244) = v33[62];
            *(_DWORD *)(*(_DWORD *)v12 + 248) = v33[72];
            *(_DWORD *)(*(_DWORD *)v12 + 252) = v33[73];
            *(_DWORD *)(*(_DWORD *)v12 + 256) = v33[74];
            *(_DWORD *)(*(_DWORD *)v12 + 260) = v33[75];
            *(_DWORD *)(*(_DWORD *)v12 + 264) = v33[76];
            *(_DWORD *)(*(_DWORD *)v12 + 268) = v33[77];
            sub_80814E8(&s, (_DWORD *)(380 * *v33 + 137813056), *(_DWORD **)v12, 1);
            if ( ++dword_83CCDC0 > 2147483645 )
              Com_Error(0, (char *)&byte_80E0840);
            ++v16[2];
          }
        }
      }
    }
    if ( ++dword_83CCDC8 > 2147483645 )
      Com_Error(0, (char *)&byte_80E0880);
LABEL_69:
    MSG_WriteBits(&s, 1023, 10);
    v20 = (char *)dword_83CCDB4 + 8 * (dword_83CCDB0 % 1200);
    *v20 = dword_83CCDBC;
    v20[1] = n;
    v19 = dword_83CCDBC % 0x2000000;
    dword_83CCDBC += n;
    if ( dword_83CCDBC > 2147483645 )
      Com_Error(0, (char *)&byte_80E0A20);
    v18 = 0x2000000 - v19;
    if ( (int)n > 0x2000000 - v19 )
    {
      memcpy((char *)dword_83CCDB8 + v19, src, v18);
      memcpy(dword_83CCDB8, (char *)src + v18, n - v18);
    }
    else
    {
      memcpy((char *)dword_83CCDB8 + v19, src, n);
    }
    if ( ++dword_83CCDB0 > 2147483645 )
      Com_Error(0, (char *)&byte_80E0A60);
  }
}
// 836B7D4: using guessed type int dword_836B7D4;
// 836B804: using guessed type int dword_836B804;
// 836B820: using guessed type int sv;
// 83CCC44: using guessed type int dword_83CCC44;
// 83CCD84: using guessed type int dword_83CCD84;
// 83CCDAC: using guessed type int dword_83CCDAC;
// 83CCDB0: using guessed type int dword_83CCDB0;
// 83CCDBC: using guessed type int dword_83CCDBC;
// 83CCDC0: using guessed type int dword_83CCDC0;
// 83CCDC4: using guessed type int dword_83CCDC4;
// 83CCDC8: using guessed type int dword_83CCDC8;

//----- (08098A34) --------------------------------------------------------
int SV_SendClientMessages()
{
  int result; // eax
  float v1; // [esp+3Ch] [ebp-1Ch]
  float v2; // [esp+40h] [ebp-18h]
  float v3; // [esp+40h] [ebp-18h]
  float v4; // [esp+40h] [ebp-18h]
  float v5; // [esp+44h] [ebp-14h]
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+44h] [ebp-14h]
  int v8; // [esp+48h] [ebp-10h]
  _DWORD *v9; // [esp+4Ch] [ebp-Ch]
  int v10; // [esp+50h] [ebp-8h]
  int i; // [esp+50h] [ebp-8h]

  v8 = 0;
  dword_83CCCA4 = 0;
  dword_83CCCFC = 0;
  v10 = 0;
  v9 = dword_83CCD90;
  while ( v10 < *(_DWORD *)(dword_836B804 + 32) )
  {
    if ( *v9 && dword_83CCD88 >= v9[17161] )
    {
      ++v8;
      if ( v9[88668] )
      {
        v9[17161] = dword_83CCD88 + sub_80979AB((int)v9, v9[88670] - v9[88669]);
        SV_Netchan_TransmitNextFragment(v9 + 84560);
      }
      else
      {
        SV_SendClientSnapshot((int)v9);
      }
    }
    ++v10;
    v9 += 92781;
  }
  result = dword_836B7D0;
  if ( *(_DWORD *)(dword_836B7D0 + 32) && v8 > 0 )
  {
    v5 = 0.0;
    v2 = 0.0;
    for ( i = 0; i <= 18; ++i )
    {
      dword_83CCC50[i] = dword_83CCC54[i];
      v5 = (long double)dword_83CCC50[i] + v5;
      dword_83CCCAC[i] = dword_83CCCB0[i];
      v2 = (long double)dword_83CCCAC[i] + v2;
    }
    dword_83CCC9C = dword_83CCCA4;
    v6 = (long double)dword_83CCCA4 + v5;
    dword_83CCCF8 = dword_83CCCFC;
    v3 = (long double)dword_83CCCFC + v2;
    if ( dword_83CCCA4 >= dword_83CCCA8 )
      dword_83CCCA8 = dword_83CCCA4;
    result = dword_83CCCFC;
    if ( dword_83CCCFC >= dword_83CCD00 )
    {
      result = dword_83CCCFC;
      dword_83CCD00 = dword_83CCCFC;
    }
    if ( ++dword_83CCCA0 > 19 )
    {
      dword_83CCCA0 = 0;
      v7 = v6 / 20.0;
      v4 = v3 / 20.0;
      v1 = (1.0 - v7 / v4) * 100.0;
      flt_83CCD04 = flt_83CCD04 + v1;
      result = Com_DPrintf(
                 "bpspc(%2.0f) bps(%2.0f) pk(%i) ubps(%2.0f) upk(%i) cr(%2.2f) acr(%2.2f)\n",
                 (double)(v7 / (long double)v8),
                 v7,
                 dword_83CCCA8,
                 v4,
                 dword_83CCD00,
                 v1,
                 (double)(flt_83CCD04 / (long double)++dword_83CCD08));
    }
  }
  return result;
}
// 836B7D0: using guessed type int dword_836B7D0;
// 836B804: using guessed type int dword_836B804;
// 83CCC50: using guessed type int dword_83CCC50[];
// 83CCC9C: using guessed type int dword_83CCC9C;
// 83CCCA0: using guessed type int dword_83CCCA0;
// 83CCCA4: using guessed type int dword_83CCCA4;
// 83CCCA8: using guessed type int dword_83CCCA8;
// 83CCCAC: using guessed type int dword_83CCCAC[];
// 83CCCF8: using guessed type int dword_83CCCF8;
// 83CCCFC: using guessed type int dword_83CCCFC;
// 83CCD00: using guessed type int dword_83CCD00;
// 83CCD04: using guessed type float flt_83CCD04;
// 83CCD08: using guessed type int dword_83CCD08;
// 83CCD88: using guessed type int dword_83CCD88;

//----- (08098CA8) --------------------------------------------------------
int __cdecl sub_8098CA8(int *a1)
{
  if ( a1[64] )
    return sub_804BCA0(a1[35]);
  if ( (a1[61] & 0x200) != 0 )
    return sub_804BDD3(a1 + 65, a1 + 68, a1[71], 1);
  return sub_804BDD3(a1 + 65, a1 + 68, a1[71], 0);
}

//----- (08098D51) --------------------------------------------------------
int __cdecl sub_8098D51(int *a1)
{
  int *v2; // [esp+4h] [ebp-4h]

  v2 = (int *)sub_808D34E(a1);
  a1[60] = 0;
  return sub_805DBAB(v2);
}

//----- (08098D7F) --------------------------------------------------------
void __cdecl sub_8098D7F(int a1)
{
  float v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i <= 2; ++i )
  {
    v2 = sub_809AC27(*(float *)(a1 + 4 * i));
    v1 = (long double)v2 - *(float *)(a1 + 4 * i);
    if ( v1 * v1 < 0.0000010000001 )
      *(float *)(a1 + 4 * i) = (float)v2;
  }
}

//----- (08098DF6) --------------------------------------------------------
int __cdecl sub_8098DF6(_DWORD *a1)
{
  int *v2; // edx
  int i; // [esp+28h] [ebp-260h]
  float v4; // [esp+2Ch] [ebp-25Ch]
  float v5; // [esp+30h] [ebp-258h] BYREF
  float v6; // [esp+34h] [ebp-254h]
  float v7; // [esp+40h] [ebp-248h] BYREF
  float v8; // [esp+44h] [ebp-244h]
  int v9; // [esp+54h] [ebp-234h]
  int *v10; // [esp+58h] [ebp-230h]
  float *v11; // [esp+5Ch] [ebp-22Ch]
  float *v12; // [esp+60h] [ebp-228h]
  int v13; // [esp+64h] [ebp-224h] BYREF
  int v14; // [esp+68h] [ebp-220h]
  int v15; // [esp+6Ch] [ebp-21Ch]
  int v16; // [esp+70h] [ebp-218h]
  int j; // [esp+74h] [ebp-214h]
  int v18; // [esp+78h] [ebp-210h]
  int v19; // [esp+7Ch] [ebp-20Ch]
  int v20[130]; // [esp+80h] [ebp-208h] BYREF

  v10 = (int *)sub_808D34E(a1);
  if ( a1[64] )
  {
    a1[39] = 0xFFFFFF;
  }
  else if ( (a1[71] & 0x2000001) != 0 )
  {
    j = (int)*((float *)a1 + 68);
    if ( j <= 0 )
      j = 1;
    if ( j > 255 )
      j = 255;
    v16 = (int)(1.0 - *((float *)a1 + 67));
    if ( v16 <= 0 )
      v16 = 1;
    if ( v16 > 255 )
      v16 = 255;
    v15 = (int)(*((float *)a1 + 70) + 32.0);
    if ( v15 <= 0 )
      v15 = 1;
    if ( v15 > 255 )
      v15 = 255;
    a1[39] = j | (v15 << 16) | (v16 << 8);
  }
  else
  {
    a1[39] = 0;
  }
  sub_8098D7F((int)(a1 + 81));
  v11 = (float *)(a1 + 81);
  v12 = (float *)(a1 + 78);
  if ( !a1[64] || *v11 == 0.0 && v11[1] == 0.0 && v11[2] == 0.0 )
  {
    *((float *)a1 + 72) = *v12 + *((float *)a1 + 65);
    *((float *)a1 + 73) = v12[1] + *((float *)a1 + 66);
    *((float *)a1 + 74) = v12[2] + *((float *)a1 + 67);
    *((float *)a1 + 75) = *v12 + *((float *)a1 + 68);
    *((float *)a1 + 76) = v12[1] + *((float *)a1 + 69);
    *((float *)a1 + 77) = v12[2] + *((float *)a1 + 70);
  }
  else
  {
    v4 = ((long double (__cdecl *)(_DWORD *, _DWORD *))sub_806A1B3)(a1 + 65, a1 + 68);
    for ( i = 0; i <= 2; ++i )
    {
      *(float *)&a1[i + 72] = v12[i] - v4;
      *(float *)&a1[i + 75] = v12[i] + v4;
    }
  }
  *((float *)a1 + 72) = *((float *)a1 + 72) - 1.0;
  *((float *)a1 + 73) = *((float *)a1 + 73) - 1.0;
  *((float *)a1 + 74) = *((float *)a1 + 74) - 1.0;
  *((float *)a1 + 75) = *((float *)a1 + 75) + 1.0;
  *((float *)a1 + 76) = *((float *)a1 + 76) + 1.0;
  *((float *)a1 + 77) = *((float *)a1 + 77) + 1.0;
  v10[70] = 0;
  v10[87] = 0;
  v10[88] = -1;
  v10[89] = -1;
  v18 = sub_805765D(a1 + 72, a1 + 75, (int)v20, 128, &v13);
  if ( !v18 )
    return sub_805DBAB(v10);
  for ( j = 0; j < v18; ++j )
  {
    v14 = sub_804BD06(v20[j]);
    if ( v14 != -1 )
    {
      if ( v10[88] == -1 || v10[88] == v14 )
      {
        v10[88] = v14;
      }
      else
      {
        if ( v10[89] != -1 && v10[89] != v14 && sv == 1 )
          Com_DPrintf(
            "Object %i touching 3 areas at %f %f %f\n",
            *a1,
            *((float *)a1 + 72),
            *((float *)a1 + 73),
            *((float *)a1 + 74));
        v10[89] = v14;
      }
    }
  }
  v10[70] = 0;
  for ( j = 0; j < v18; ++j )
  {
    v19 = sub_804BCF0(v20[j]);
    if ( v19 != -1 )
    {
      v2 = v10;
      v10[v10[70] + 71] = v19;
      ++v2[70];
      if ( v10[70] == 16 )
        break;
    }
  }
  if ( j != v18 )
    v10[87] = sub_804BCF0(v13);
  a1[60] = 1;
  if ( !a1[71] )
    return sub_805DBAB(v10);
  v9 = sub_8071F32(*a1);
  if ( !v9 || (a1[61] & 6) == 0 )
    return sub_805DFE6((int)v10, a1 + 72, a1 + 75);
  if ( (a1[61] & 2) != 0 )
  {
    v7 = *v12 + flt_80EE810;
    v8 = v12[1] + flt_80EE814;
    v5 = *v12 + flt_80EE81C;
    v6 = v12[1] + flt_80EE820;
  }
  else
  {
    sub_80D17A2(v9, &v7, &v5);
    v7 = v7 + *v12;
    v8 = v8 + v12[1];
    v5 = v5 + *v12;
    v6 = v6 + v12[1];
  }
  return sub_805DFE6((int)v10, &v7, &v5);
}
// 806A1B3: using guessed type double sub_806A1B3();
// 80EE810: using guessed type float flt_80EE810;
// 80EE814: using guessed type float flt_80EE814;
// 80EE81C: using guessed type float flt_80EE81C;
// 80EE820: using guessed type float flt_80EE820;
// 836B820: using guessed type int sv;

//----- (0809959C) --------------------------------------------------------
int __cdecl sub_809959C(int a1, int a2)
{
  int result; // eax
  int *v3; // [esp+38h] [ebp-50h]
  int v4; // [esp+3Ch] [ebp-4Ch]
  int v5[15]; // [esp+40h] [ebp-48h] BYREF
  int *v6; // [esp+7Ch] [ebp-Ch]

  v6 = (int *)sub_808D314(-723362913 * ((a2 + -(int)&sv - 9240) >> 2));
  result = *(_DWORD *)(a1 + 116) & v6[71];
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 108) == 1023
      || (result = -723362913 * ((a2 + -(int)&sv - 9240) >> 2), result != *(_DWORD *)(a1 + 108))
      && (result = v6[84], result != *(_DWORD *)(a1 + 108))
      && (result = v6[84], result != *(_DWORD *)(a1 + 112)) )
    {
      v4 = sub_8098CA8(v6);
      v3 = v6 + 81;
      if ( !v6[64] )
        v3 = &dword_80D7EC8;
      v5[0] = *(_DWORD *)(a1 + 60);
      sub_805B366(
        v5,
        (float *)(a1 + 36),
        (float *)(a1 + 48),
        (int *)a1,
        (int *)(a1 + 12),
        v4,
        *(_DWORD *)(a1 + 116),
        (float *)v6 + 78,
        (float *)v3,
        *(_DWORD *)(a1 + 120));
      if ( *(float *)v5 < (long double)*(float *)(a1 + 60) )
      {
        HIWORD(v5[11]) |= *(_WORD *)(a1 + 106);
        LOWORD(v5[10]) = *(_WORD *)v6;
        result = 12;
        qmemcpy((void *)(a1 + 60), v5, 0x30u);
      }
      else
      {
        *(_BYTE *)(a1 + 106) |= BYTE2(v5[11]);
        result = HIBYTE(v5[11]);
        LOBYTE(result) = *(_BYTE *)(a1 + 107) | HIBYTE(v5[11]);
        *(_BYTE *)(a1 + 107) = result;
      }
    }
  }
  return result;
}
// 80D7EC8: using guessed type int dword_80D7EC8;
// 836B820: using guessed type int sv;

//----- (08099732) --------------------------------------------------------
int __cdecl sub_8099732(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-110h]
  float v4[9]; // [esp+30h] [ebp-E8h] BYREF
  float v5; // [esp+54h] [ebp-C4h]
  float v6; // [esp+58h] [ebp-C0h]
  float v7; // [esp+5Ch] [ebp-BCh]
  float v8[4]; // [esp+60h] [ebp-B8h] BYREF
  float v9[4]; // [esp+70h] [ebp-A8h] BYREF
  int v10[2]; // [esp+80h] [ebp-98h] BYREF
  float v11[4]; // [esp+88h] [ebp-90h] BYREF
  unsigned __int8 v12; // [esp+98h] [ebp-80h]
  char v13; // [esp+99h] [ebp-7Fh]
  float v14; // [esp+A0h] [ebp-78h] BYREF
  float v15; // [esp+A4h] [ebp-74h]
  float v16; // [esp+A8h] [ebp-70h]
  float v17; // [esp+B0h] [ebp-68h] BYREF
  float v18; // [esp+B4h] [ebp-64h]
  float v19; // [esp+B8h] [ebp-60h]
  int v20; // [esp+C0h] [ebp-58h]
  int v21; // [esp+C4h] [ebp-54h]
  float *v22; // [esp+C8h] [ebp-50h]
  int v23; // [esp+CCh] [ebp-4Ch]
  int v24[15]; // [esp+D0h] [ebp-48h] BYREF
  int *v25; // [esp+10Ch] [ebp-Ch]

  v21 = -723362913 * ((a2 + -(int)&sv - 9240) >> 2);
  v25 = (int *)sub_808D314(v21);
  result = *(_DWORD *)(a1 + 80) & v25[71];
  if ( result )
  {
    if ( *(_DWORD *)(a1 + 72) == 1023
      || (result = v21, v21 != *(_DWORD *)(a1 + 72))
      && (result = v25[84], result != *(_DWORD *)(a1 + 72))
      && (result = v25[84], result != *(_DWORD *)(a1 + 76)) )
    {
      if ( !*(_DWORD *)(a1 + 84) || (v20 = sub_8071F32(*v25)) == 0 || (v25[61] & 6) == 0 )
      {
        v23 = sub_8098CA8(v25);
        v22 = (float *)(v25 + 81);
        if ( !v25[64] )
          v22 = (float *)&dword_80D7EC8;
        v24[0] = *(_DWORD *)(a1 + 24);
        sub_805B366(
          v24,
          (float *)a1,
          (float *)(a1 + 12),
          &dword_80D7EC8,
          &dword_80D7EC8,
          v23,
          *(_DWORD *)(a1 + 80),
          (float *)v25 + 78,
          v22,
          0);
        if ( *(float *)v24 >= (long double)*(float *)(a1 + 24) )
        {
          *(_BYTE *)(a1 + 70) |= BYTE2(v24[11]);
          result = HIBYTE(v24[11]);
          LOBYTE(result) = *(_BYTE *)(a1 + 71) | HIBYTE(v24[11]);
          *(_BYTE *)(a1 + 71) = result;
          return result;
        }
        goto LABEL_24;
      }
      if ( (v25[61] & 4) != 0 )
      {
        result = sub_80D299E(v20, *(_DWORD *)(a1 + 80));
        if ( !result )
          return result;
        v5 = *((float *)v25 + 78);
        v6 = *((float *)v25 + 79);
        v7 = *((float *)v25 + 80);
        sub_80D17A2(v20, &v17, &v14);
        v17 = v17 + v5;
        v18 = v18 + v6;
        v19 = v19 + v7;
        v14 = v14 + v5;
        v15 = v15 + v6;
        v16 = v16 + v7;
      }
      else
      {
        v5 = *((float *)v25 + 78);
        v6 = *((float *)v25 + 79);
        v7 = *((float *)v25 + 80);
        v17 = v5 + flt_80EE810;
        v18 = v6 + flt_80EE814;
        v19 = v7 + flt_80EE818;
        v14 = v5 + flt_80EE81C;
        v15 = v6 + flt_80EE820;
        v16 = v7 + flt_80EE824;
      }
      result = sub_805E553(a1, a1 + 12, (int)&v17, (int)&v14, *(float *)(a1 + 24));
      if ( !result )
      {
        v3 = *v25;
        VM_Call((int)gvm, 15);
        sub_806A55E(v25 + 81, v4, v3);
        sub_8069506((float *)a1, v4, v9);
        sub_8069506((float *)(a1 + 12), v4, v8);
        v10[0] = *(_DWORD *)(a1 + 24);
        if ( (v25[61] & 4) != 0 )
          sub_80D2854(v20, v9, v8, *(_DWORD *)(a1 + 80), (int)v10);
        else
          sub_80D2000(v20, v9, v8, *(_DWORD *)(a1 + 88), (int)v10);
        if ( *(float *)v10 >= (long double)*(float *)(a1 + 24) )
        {
          *(_BYTE *)(a1 + 70) |= v13;
          result = v12;
          LOBYTE(result) = *(_BYTE *)(a1 + 71) | v12;
          *(_BYTE *)(a1 + 71) = result;
          return result;
        }
        v24[0] = v10[0];
        HIBYTE(v24[11]) = v12;
        v24[7] = v10[1];
        *(float *)((char *)&v24[10] + 2) = v11[3];
        sub_8069244(v11, v4, (float *)&v24[4]);
        *(float *)&v24[1] = (*(float *)(a1 + 12) - *(float *)a1) * *(float *)v24 + *(float *)a1;
        *(float *)&v24[2] = (*(float *)(a1 + 16) - *(float *)(a1 + 4)) * *(float *)v24 + *(float *)(a1 + 4);
        *(float *)&v24[3] = (*(float *)(a1 + 20) - *(float *)(a1 + 8)) * *(float *)v24 + *(float *)(a1 + 8);
LABEL_24:
        HIWORD(v24[11]) |= *(_WORD *)(a1 + 70);
        LOWORD(v24[10]) = *(_WORD *)v25;
        v24[9] = 0;
        v24[8] = v25[71];
        result = 12;
        qmemcpy((void *)(a1 + 24), v24, 0x30u);
        return result;
      }
    }
  }
  return result;
}
// 806A55E: using guessed type int __cdecl sub_806A55E(_DWORD, _DWORD, _DWORD);
// 80D7EC8: using guessed type int dword_80D7EC8;
// 80EE810: using guessed type float flt_80EE810;
// 80EE814: using guessed type float flt_80EE814;
// 80EE818: using guessed type float flt_80EE818;
// 80EE81C: using guessed type float flt_80EE81C;
// 80EE820: using guessed type float flt_80EE820;
// 80EE824: using guessed type float flt_80EE824;
// 836B820: using guessed type int sv;

//----- (08099C75) --------------------------------------------------------
int __cdecl sub_8099C75(int *a1, int a2)
{
  int v3; // [esp+30h] [ebp-18h]
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = -723362913 * ((a2 + -(int)&sv - 9240) >> 2);
  v7 = sub_808D314(v4);
  if ( (a1[19] & *(_DWORD *)(v7 + 284)) == 0 )
    return 0;
  if ( a1[15] != 1023 )
  {
    if ( v4 == a1[15] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[15] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[17] )
      return 0;
  }
  if ( a1[16] != 1023 )
  {
    if ( v4 == a1[16] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[16] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[18] )
      return 0;
  }
  v6 = sub_8098CA8((int *)v7);
  v5 = (float *)(v7 + 324);
  if ( !*(_DWORD *)(v7 + 256) )
    v5 = (float *)&dword_80D7EC8;
  if ( sub_805D679(0, (int)(a1 + 9), (int)(a1 + 12), a1, a1 + 3, v6, a1[19], (float *)(v7 + 312), v5, a1[20]) )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}
// 80D7EC8: using guessed type int dword_80D7EC8;
// 836B820: using guessed type int sv;

//----- (08099E26) --------------------------------------------------------
int __cdecl sub_8099E26(_DWORD *a1, int a2)
{
  int v3; // [esp+30h] [ebp-18h]
  int v4; // [esp+38h] [ebp-10h]
  float *v5; // [esp+3Ch] [ebp-Ch]
  int v6; // [esp+40h] [ebp-8h]
  int v7; // [esp+44h] [ebp-4h]

  v4 = -723362913 * ((a2 + -(int)&sv - 9240) >> 2);
  v7 = sub_808D314(v4);
  if ( (a1[10] & *(_DWORD *)(v7 + 284)) == 0 )
    return 0;
  if ( a1[6] != 1023 )
  {
    if ( v4 == a1[6] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[6] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[8] )
      return 0;
  }
  if ( a1[7] != 1023 )
  {
    if ( v4 == a1[7] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[7] )
      return 0;
    if ( *(_DWORD *)(v7 + 336) == a1[9] )
      return 0;
  }
  v6 = sub_8098CA8((int *)v7);
  v5 = (float *)(v7 + 324);
  if ( !*(_DWORD *)(v7 + 256) )
    v5 = (float *)&dword_80D7EC8;
  if ( sub_805D679(0, (int)a1, (int)(a1 + 3), &dword_80D7EC8, &dword_80D7EC8, v6, a1[10], (float *)(v7 + 312), v5, 0) )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}
// 80D7EC8: using guessed type int dword_80D7EC8;
// 836B820: using guessed type int sv;

//----- (08099FD1) --------------------------------------------------------
int __cdecl sub_8099FD1(void *a1, int a2, int *a3, int *a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int result; // eax
  __int16 v12; // [esp+2Eh] [ebp-12Ah]
  float v13[6]; // [esp+30h] [ebp-128h] BYREF
  float v14; // [esp+48h] [ebp-110h]
  float v15; // [esp+4Ch] [ebp-10Ch]
  float v16; // [esp+50h] [ebp-108h]
  float v17; // [esp+54h] [ebp-104h]
  float v18; // [esp+58h] [ebp-100h]
  float v19; // [esp+5Ch] [ebp-FCh]
  float v20; // [esp+60h] [ebp-F8h]
  float v21; // [esp+64h] [ebp-F4h]
  float v22; // [esp+68h] [ebp-F0h]
  float v23[13]; // [esp+6Ch] [ebp-ECh] BYREF
  int v24; // [esp+A0h] [ebp-B8h]
  int v25; // [esp+A4h] [ebp-B4h]
  int v26; // [esp+A8h] [ebp-B0h]
  int v27[6]; // [esp+B0h] [ebp-A8h] BYREF
  char v28[48]; // [esp+C8h] [ebp-90h] BYREF
  int v29; // [esp+F8h] [ebp-60h]
  int v30; // [esp+FCh] [ebp-5Ch]
  int v31; // [esp+100h] [ebp-58h]
  int v32; // [esp+104h] [ebp-54h]
  int v33; // [esp+108h] [ebp-50h]
  float v34; // [esp+110h] [ebp-48h]
  float v35; // [esp+114h] [ebp-44h]
  float v36; // [esp+118h] [ebp-40h]
  float s[14]; // [esp+120h] [ebp-38h] BYREF

  if ( !a3 )
    a3 = &dword_80D7EC8;
  if ( !a4 )
    a4 = &dword_80D7EC8;
  memset(s, 0, 0x30u);
  sub_805B311((int *)s, (float *)a2, (float *)a5, a3, a4, 0, a7, a8);
  if ( s[0] == 1.0 )
    v12 = 1023;
  else
    v12 = 1022;
  LOWORD(s[10]) = v12;
  if ( s[0] == 0.0 || a11 && (sub_805E97B((int *)s, (int *)a2, (int *)a5, a7), s[0] == 0.0) )
  {
    result = 12;
    qmemcpy(a1, s, 0x30u);
  }
  else if ( *(float *)a4
          - *(float *)a3
          + *((float *)a4 + 1)
          - *((float *)a3 + 1)
          + *((float *)a4 + 2)
          - *((float *)a3 + 2) == 0.0 )
  {
    qmemcpy(v28, s, sizeof(v28));
    v31 = a7;
    v27[0] = *(_DWORD *)a2;
    v27[1] = *(_DWORD *)(a2 + 4);
    v27[2] = *(_DWORD *)(a2 + 8);
    v27[3] = *(_DWORD *)a5;
    v27[4] = *(_DWORD *)(a5 + 4);
    v27[5] = *(_DWORD *)(a5 + 8);
    v29 = a6;
    v32 = a9;
    v33 = a10;
    if ( a6 == 1023 )
    {
      v30 = -1;
    }
    else
    {
      v30 = *(_DWORD *)(sub_808D314(a6) + 336);
      if ( v30 == 1023 )
        v30 = -1;
    }
    sub_805F48A((int)v27);
    result = 12;
    qmemcpy(a1, v28, 0x30u);
  }
  else
  {
    qmemcpy(v23, s, 0x30u);
    v25 = a7;
    LODWORD(v23[12]) = a6;
    v26 = a8;
    if ( a6 == 1023 )
    {
      v24 = -1;
    }
    else
    {
      v24 = *(_DWORD *)(sub_808D314(a6) + 336);
      if ( v24 == 1023 )
        v24 = -1;
    }
    v14 = *(float *)a4 - *(float *)a3;
    v15 = *((float *)a4 + 1) - *((float *)a3 + 1);
    v16 = *((float *)a4 + 2) - *((float *)a3 + 2);
    v14 = v14 * 0.5;
    v15 = v15 * 0.5;
    v16 = v16 * 0.5;
    v13[3] = v14;
    v13[4] = v15;
    v13[5] = v16;
    v13[0] = v14 * -1.0;
    v13[1] = v15 * -1.0;
    v13[2] = v16 * -1.0;
    v14 = v14 + 1.0;
    v15 = v15 + 1.0;
    v16 = v16 + 1.0;
    v34 = *(float *)a4 + *(float *)a3;
    v35 = *((float *)a4 + 1) + *((float *)a3 + 1);
    v36 = *((float *)a4 + 2) + *((float *)a3 + 2);
    v34 = v34 * 0.5;
    v35 = v35 * 0.5;
    v36 = v36 * 0.5;
    v17 = *(float *)a2 + v34;
    v18 = *(float *)(a2 + 4) + v35;
    v19 = *(float *)(a2 + 8) + v36;
    v20 = *(float *)a5 + v34;
    v21 = *(float *)(a5 + 4) + v35;
    v22 = *(float *)(a5 + 8) + v36;
    sub_805EE11((int)v13);
    if ( s[0] > (long double)v23[0] )
    {
      v34 = *(float *)a5 - *(float *)a2;
      v35 = *(float *)(a5 + 4) - *(float *)(a2 + 4);
      v36 = *(float *)(a5 + 8) - *(float *)(a2 + 8);
      v23[1] = v34 * v23[0] + *(float *)a2;
      v23[2] = v35 * v23[0] + *(float *)(a2 + 4);
      v23[3] = v36 * v23[0] + *(float *)(a2 + 8);
    }
    result = 12;
    qmemcpy(a1, v23, 0x30u);
  }
  return result;
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0809A4F9) --------------------------------------------------------
int *__cdecl sub_809A4F9(int *a1, int *a2, int *a3, int *a4, int *a5, int a6, int a7, int a8, int a9)
{
  int *result; // eax
  int v10; // edx
  int v11; // edx
  float v12[6]; // [esp+20h] [ebp-A8h] BYREF
  float v13; // [esp+38h] [ebp-90h]
  float v14; // [esp+3Ch] [ebp-8Ch]
  float v15; // [esp+40h] [ebp-88h]
  float v16; // [esp+44h] [ebp-84h]
  float v17; // [esp+48h] [ebp-80h]
  float v18; // [esp+4Ch] [ebp-7Ch]
  float v19; // [esp+50h] [ebp-78h]
  float v20; // [esp+54h] [ebp-74h]
  float v21; // [esp+58h] [ebp-70h]
  int v22; // [esp+5Ch] [ebp-6Ch]
  int v23; // [esp+60h] [ebp-68h]
  int v24; // [esp+64h] [ebp-64h]
  int v25; // [esp+68h] [ebp-60h]
  int v26; // [esp+6Ch] [ebp-5Ch]
  int v27; // [esp+70h] [ebp-58h]
  int v28[8]; // [esp+80h] [ebp-48h] BYREF
  int v29; // [esp+A0h] [ebp-28h]
  int v30; // [esp+A4h] [ebp-24h]
  int v31; // [esp+A8h] [ebp-20h]
  float v32; // [esp+B0h] [ebp-18h]
  float v33; // [esp+B4h] [ebp-14h]
  float v34; // [esp+B8h] [ebp-10h]

  if ( !a3 )
    a3 = &dword_80D7EC8;
  if ( !a4 )
    a4 = &dword_80D7EC8;
  *a1 = sub_805D625(*a1, (int)a2, (int)a5, a3, a4, 0, a8, a9);
  result = a1;
  if ( !*a1 )
  {
    if ( *(float *)a4 - *(float *)a3 + *((float *)a4 + 1) - *((float *)a3 + 1) + *((float *)a4 + 2) - *((float *)a3 + 2) == 0.0 )
    {
      v31 = a8;
      v28[0] = *a2;
      v28[1] = a2[1];
      v28[2] = a2[2];
      v28[3] = *a5;
      v28[4] = a5[1];
      v28[5] = a5[2];
      v28[6] = a6;
      v28[7] = a7;
      if ( a6 == 1023 )
      {
        v29 = -1;
      }
      else
      {
        v29 = *(_DWORD *)(sub_808D314(a6) + 336);
        if ( v29 == 1023 )
          v29 = -1;
      }
      if ( a7 == 1023 )
      {
        v30 = -1;
      }
      else
      {
        v30 = *(_DWORD *)(sub_808D314(a7) + 336);
        if ( v30 == 1023 )
          v30 = -1;
      }
      v10 = sub_805F758((int)v28);
      result = a1;
      *a1 = v10;
    }
    else
    {
      v26 = a8;
      v22 = a6;
      v23 = a7;
      v27 = a9;
      if ( a6 == 1023 )
      {
        v24 = -1;
      }
      else
      {
        v24 = *(_DWORD *)(sub_808D314(a6) + 336);
        if ( v24 == 1023 )
          v24 = -1;
      }
      if ( a7 == 1023 )
      {
        v25 = -1;
      }
      else
      {
        v25 = *(_DWORD *)(sub_808D314(a7) + 336);
        if ( v25 == 1023 )
          v25 = -1;
      }
      v13 = *(float *)a4 - *(float *)a3;
      v14 = *((float *)a4 + 1) - *((float *)a3 + 1);
      v15 = *((float *)a4 + 2) - *((float *)a3 + 2);
      v13 = v13 * 0.5;
      v14 = v14 * 0.5;
      v15 = v15 * 0.5;
      v12[3] = v13;
      v12[4] = v14;
      v12[5] = v15;
      v12[0] = v13 * -1.0;
      v12[1] = v14 * -1.0;
      v12[2] = v15 * -1.0;
      v13 = v13 + 1.0;
      v14 = v14 + 1.0;
      v15 = v15 + 1.0;
      v32 = *(float *)a4 + *(float *)a3;
      v33 = *((float *)a4 + 1) + *((float *)a3 + 1);
      v34 = *((float *)a4 + 2) + *((float *)a3 + 2);
      v32 = v32 * 0.5;
      v33 = v33 * 0.5;
      v34 = v34 * 0.5;
      v16 = *(float *)a2 + v32;
      v17 = *((float *)a2 + 1) + v33;
      v18 = *((float *)a2 + 2) + v34;
      v19 = *(float *)a5 + v32;
      v20 = *((float *)a5 + 1) + v33;
      v21 = *((float *)a5 + 2) + v34;
      v11 = sub_805F20E((int)v12);
      result = a1;
      *a1 = v11;
    }
  }
  return result;
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0809A8CD) --------------------------------------------------------
int __cdecl sub_809A8CD(int a1, int *a2, int *a3, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+38h] [ebp-50h]
  float v9[4]; // [esp+40h] [ebp-48h]
  float v10[7]; // [esp+50h] [ebp-38h]
  float *v11; // [esp+6Ch] [ebp-1Ch]
  float *v12; // [esp+70h] [ebp-18h]
  int v13; // [esp+74h] [ebp-14h]
  float *v14; // [esp+78h] [ebp-10h]
  int i; // [esp+7Ch] [ebp-Ch]

  v14 = (float *)sub_808D314(a5);
  if ( (a6 & (_DWORD)v14[71]) == 0 )
    return 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a4 + 4 * i) <= (long double)*(float *)(a1 + 4 * i) )
    {
      v10[i] = *(float *)(a4 + 4 * i) + *(float *)&a2[i] - 1.0;
      v9[i] = *(float *)(a1 + 4 * i) + *(float *)&a3[i] + 1.0;
    }
    else
    {
      v10[i] = *(float *)(a1 + 4 * i) + *(float *)&a2[i] - 1.0;
      v9[i] = *(float *)(a4 + 4 * i) + *(float *)&a3[i] + 1.0;
    }
  }
  if ( v14[72] > (long double)v9[0]
    || v14[73] > (long double)v9[1]
    || v14[74] > (long double)v9[2]
    || v10[0] > (long double)v14[75]
    || v10[1] > (long double)v14[76]
    || v10[2] > (long double)v14[77] )
  {
    return 0;
  }
  v13 = sub_8098CA8((int *)v14);
  v12 = v14 + 78;
  v11 = v14 + 81;
  if ( !*((_DWORD *)v14 + 64) )
    v11 = (float *)&dword_80D7EC8;
  if ( sub_805D679(0, a1, a4, a2, a3, v13, a6, v12, v11, a7) )
    v8 = -1;
  else
    v8 = 0;
  return v8;
}
// 80D7EC8: using guessed type int dword_80D7EC8;

//----- (0809AB1F) --------------------------------------------------------
int __cdecl sub_809AB1F(float *a1, int a2, int a3)
{
  int v4; // [esp+2Ch] [ebp-101Ch]
  int v5; // [esp+30h] [ebp-1018h]
  int v6; // [esp+34h] [ebp-1014h]
  int i; // [esp+38h] [ebp-1010h]
  int v8; // [esp+3Ch] [ebp-100Ch]
  int v9[1026]; // [esp+40h] [ebp-1008h] BYREF

  v5 = sub_8057775(a1, 0);
  v6 = sub_805E510((int)a1, (int)a1, (int)v9, 1024, a3);
  for ( i = 0; i < v6; ++i )
  {
    if ( v9[i] != a2 )
    {
      v8 = sub_808D314(v9[i]);
      v4 = sub_8098CA8((int *)v8);
      v5 |= sub_80578F7(a1, v4, (float *)(v8 + 312), (float *)(v8 + 324));
    }
  }
  return v5 & a3;
}

//----- (0809AC27) --------------------------------------------------------
int __cdecl sub_809AC27(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (0809AC58) --------------------------------------------------------
void *VM_Init()
{
  return sub_80D2FE9(&unk_83E1EA0, 0, 0x1B0u);
}

//----- (0809AC7C) --------------------------------------------------------
int __cdecl sub_809AC7C(char a1)
{
  return (*(int (__cdecl **)(char *))dword_80EE828)(&a1);
}
// 80EE828: using guessed type int dword_80EE828;

//----- (0809ACE3) --------------------------------------------------------
int __cdecl sub_809ACE3(char *src, int a2)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  char *v6; // [esp+20h] [ebp-8h]

  if ( !src || !*src || !a2 )
    Com_Error(0, (char *)&byte_80E0B60);
  sub_806C29F();
  for ( i = 0; i <= 2; ++i )
  {
    if ( !Q_stricmp((char *)(144 * i + 138288804), src) )
      return (int)&unk_83E1EA0 + 144 * i;
  }
  for ( j = 0; j <= 2 && byte_83E1EA4[144 * j]; ++j )
    ;
  if ( j == 3 )
    Com_Error(0, (char *)&byte_80E0B76);
  v6 = (char *)&unk_83E1EA0 + 144 * j;
  Q_strncpyz(v6 + 4, src, 64);
  *(_DWORD *)v6 = a2;
  *((_DWORD *)v6 + 34) = Sys_LoadDLL(src, v6 + 68, (int)(v6 + 140), (int)sub_809AC7C);
  if ( !*((_DWORD *)v6 + 34) )
    sub_80D3CC1();
  return (int)&unk_83E1EA0 + 144 * j;
}

//----- (0809AEF5) --------------------------------------------------------
void *__cdecl sub_809AEF5(void *s)
{
  void *result; // eax

  sub_80D3C34(*((void **)s + 34));
  result = sub_80D2FE9(s, 0, 0x90u);
  dword_80EE828 = 0;
  return result;
}
// 80EE828: using guessed type int dword_80EE828;

//----- (0809AF33) --------------------------------------------------------
int *sub_809AF33()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    if ( dword_83E1F28[36 * i] )
      sub_80D3C34((void *)dword_83E1F28[36 * i]);
    sub_80D2FE9((char *)&unk_83E1EA0 + 144 * i, 0, 0x90u);
    result = &i;
  }
  dword_80EE828 = 0;
  return result;
}
// 80EE828: using guessed type int dword_80EE828;

//----- (0809AFBC) --------------------------------------------------------
int __cdecl VM_Call(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+44h] [ebp-4h]
  int v4; // [esp+58h] [ebp+10h]
  int v5; // [esp+5Ch] [ebp+14h]
  int v6; // [esp+60h] [ebp+18h]
  int v7; // [esp+64h] [ebp+1Ch]
  int v8; // [esp+68h] [ebp+20h]
  int v9; // [esp+6Ch] [ebp+24h]
  int v10; // [esp+70h] [ebp+28h]
  int v11; // [esp+74h] [ebp+2Ch]
  int v12; // [esp+78h] [ebp+30h]
  int v13; // [esp+7Ch] [ebp+34h]
  int v14; // [esp+80h] [ebp+38h]
  int v15; // [esp+84h] [ebp+3Ch]

  v3 = dword_80EE828;
  dword_80EE828 = a1;
  result = (*(int (__cdecl **)(int, int, int, int, int, int, int, int, int, int, int, int, int))(a1 + 140))(
             a2,
             v4,
             v5,
             v6,
             v7,
             v8,
             v9,
             v10,
             v11,
             v12,
             v13,
             v14,
             v15);
  dword_80EE828 = v3;
  return result;
}
// 80EE828: using guessed type int dword_80EE828;

//----- (0809B048) --------------------------------------------------------
int __cdecl sub_809B048(int a1)
{
  int result; // eax

  result = a1;
  dword_80EE82C = a1;
  return result;
}
// 80EE82C: using guessed type int dword_80EE82C;

//----- (0809B056) --------------------------------------------------------
void __cdecl __noreturn sub_809B056(const char *a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = sub_8084BC9();
  sub_80847D5();
  sub_80A2D58(v1 - dword_81760A4, "%s", a1);
}
// 81760A4: using guessed type int dword_81760A4;

//----- (0809B08E) --------------------------------------------------------
int sub_809B08E()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  char *s1; // [esp+14h] [ebp-4h]

  v1 = 0;
  while ( 1 )
  {
    s1 = (char *)sub_8085382((char **)&dword_81760A8);
    if ( !*s1 )
      return v1;
    for ( i = 0; (unsigned int)i <= 2 && strcasecmp(s1, (&off_80EE830)[i]); ++i )
      ;
    if ( i == 1 )
    {
      v1 |= 2u;
    }
    else if ( i > 1 )
    {
      if ( i != 2 )
LABEL_16:
        sub_809B056("unknown anim property");
      v1 |= 8u;
    }
    else
    {
      if ( i )
        goto LABEL_16;
      v1 |= 1u;
    }
  }
}
// 81760A8: using guessed type int dword_81760A8;

//----- (0809B142) --------------------------------------------------------
int __cdecl sub_809B142(int *a1, unsigned __int16 a2, unsigned __int16 a3, int a4)
{
  int result; // eax
  int *v5; // eax
  int *v6; // edx
  unsigned __int16 v7; // [esp+12h] [ebp-16h]
  unsigned __int16 v8; // [esp+12h] [ebp-16h]
  int v9[3]; // [esp+18h] [ebp-10h] BYREF
  unsigned __int16 v10; // [esp+24h] [ebp-4h]
  unsigned __int16 v11; // [esp+26h] [ebp-2h]

  v11 = a2;
  v10 = a3;
  if ( dword_81766E0 )
    sub_80A2D58(a4, "cannot reference animation from /# ... #/ comment");
  v7 = sub_80A5E90(v10, v11);
  if ( v7 )
  {
    v5 = GetVariableValueAddress(v7);
    *a1 = *v5;
    v6 = v5;
    result = (int)a1;
    *v6 = (int)a1;
  }
  else
  {
    v8 = sub_80A61E0(v10, v11);
    *a1 = 0;
    v9[1] = 6;
    v9[0] = (int)a1;
    result = sub_80A6598(v8, v9);
  }
  return result;
}
// 81766E0: using guessed type int dword_81766E0;

//----- (0809B1FC) --------------------------------------------------------
int __cdecl sub_809B1FC(int *a1, unsigned __int16 a2, int a3)
{
  if ( !word_81768B4 )
    sub_80A2D58(a3, "#using_animtree was not specified");
  return sub_809B142(a1, a2, word_81768B4, a3);
}
// 81768B4: using guessed type __int16 word_81768B4;

//----- (0809B250) --------------------------------------------------------
int __cdecl sub_809B250(unsigned __int16 a1, unsigned __int16 a2, char a3, char a4, char a5)
{
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  int v8; // [esp+10h] [ebp-38h]
  char v9; // [esp+1Dh] [ebp-2Bh]
  unsigned __int8 v10; // [esp+1Eh] [ebp-2Ah]
  char i; // [esp+1Fh] [ebp-29h]
  int v12; // [esp+20h] [ebp-28h]
  unsigned __int16 v13; // [esp+26h] [ebp-22h]
  int v14[2]; // [esp+28h] [ebp-20h] BYREF
  unsigned __int16 v15; // [esp+30h] [ebp-18h]
  unsigned __int16 v16; // [esp+32h] [ebp-16h]
  char *v17; // [esp+34h] [ebp-14h]
  char v18; // [esp+39h] [ebp-Fh]
  char v19; // [esp+3Ah] [ebp-Eh]
  char v20; // [esp+3Bh] [ebp-Dh]
  unsigned __int16 v21; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 v22; // [esp+3Eh] [ebp-Ah]

  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = a4;
  v18 = a5;
  v14[1] = 5;
  v15 = 0;
  v16 = 0;
  v12 = 0;
  for ( i = 0; ; i = 0 )
  {
    while ( 1 )
    {
      v17 = (char *)Com_Parse(&dword_81760A8);
      if ( !dword_81760A8 )
      {
        v10 = 1;
        goto LABEL_46;
      }
      if ( !(unsigned __int8)sub_80A0FEC(v17) )
        break;
      if ( i )
        sub_80A6248(v22, v15);
      v15 = sub_80A3E4A(v17, 2, 4);
      if ( (unsigned __int16)sub_80A5E90(v22, v15) )
        sub_809B056("duplicate animation");
      v16 = sub_80A61E0(v22, v15);
      v9 = 0;
      if ( !v18 && !(unsigned __int16)sub_80A5E90(v21, v15) && !dword_80EE82C )
        v9 = 1;
      i = v9;
      v12 = 0;
      v17 = (char *)sub_8085382((char **)&dword_81760A8);
      if ( *v17 )
      {
        if ( (unsigned __int8)sub_80A0FEC(v17) )
          sub_809B056("FIXME: aliases not yet implemented");
        if ( *v17 != 58 || v17[1] )
          sub_809B056("bad token");
        v12 = sub_809B08E();
        v17 = (char *)Com_Parse(&dword_81760A8);
        if ( *v17 != 123 || v17[1] )
          sub_809B056("properties cannot be applied to primitive animations");
        break;
      }
    }
    if ( *v17 != 123 )
      break;
    if ( v17[1] )
      sub_809B056("bad token");
    if ( *(_BYTE *)sub_8085382((char **)&dword_81760A8) )
      sub_809B056("token not allowed after '{'");
    if ( !v16 )
      sub_809B056("no animation specified for this block");
    v13 = sub_80A6B2E(v16);
    v8 = 0;
    if ( v18 || (v12 & 8) != 0 && !i )
      v8 = 1;
    if ( (unsigned __int8)sub_809B250(v13, v21, (unsigned __int8)i ^ 1, v12 & 1, v8) )
      sub_809B056("unexpected end of file");
    if ( sub_80A6A06(v13) )
    {
      v14[0] = v12;
      v5 = sub_80A61B2(v13, 0);
      sub_80A6598(v5, v14);
    }
    else
    {
      sub_80A6248(v22, v15);
    }
    v16 = 0;
  }
  if ( *v17 != 125 )
    sub_809B056("bad token");
  if ( v17[1] )
    sub_809B056("bad token");
  if ( *(_BYTE *)sub_8085382((char **)&dword_81760A8) )
    sub_809B056("token not allowed after '}'");
  v10 = 0;
LABEL_46:
  if ( i )
    sub_80A6248(v22, v15);
  if ( v20 && !sub_80A6A06(v22) )
  {
    if ( v19 )
      v6 = sub_80A3D64("void_loop", 0);
    else
      v6 = sub_80A3D64("void", 0);
    v15 = v6;
    sub_80A61E0(v22, v6);
    sub_80A40A6(v15);
  }
  return v10;
}
// 80EE82C: using guessed type int dword_80EE82C;
// 81760A8: using guessed type int dword_81760A8;

//----- (0809B614) --------------------------------------------------------
_DWORD *__cdecl sub_809B614(int a1, unsigned __int16 a2, unsigned __int16 a3)
{
  sub_8084734("Scr_AnimTreeParse");
  dword_81760A8 = a1;
  dword_81760A4 = a1;
  if ( !(unsigned __int8)sub_809B250(a2, a3, 1, 0, 0) )
    sub_809B056("bad token");
  return sub_80847D5();
}
// 81760A4: using guessed type int dword_81760A4;
// 81760A8: using guessed type int dword_81760A8;

//----- (0809B684) --------------------------------------------------------
void *__cdecl sub_809B684(size_t n)
{
  return sub_806C49D(n, 4);
}

//----- (0809B6A0) --------------------------------------------------------
int __cdecl sub_809B6A0(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int16 i; // [esp+14h] [ebp-4h]

  v3 = 0;
  for ( i = FindNextSibling(a1); i; i = FindNextSibling(i) )
  {
    if ( GetVariableName(i) <= 0xFFFF )
    {
      if ( sub_80A6D12(i) == 7 )
      {
        v1 = sub_80A6B8A(i);
        v3 += sub_809B6A0(v1);
      }
      else
      {
        ++v3;
      }
    }
  }
  if ( v3 )
    ++v3;
  return v3;
}

//----- (0809B740) --------------------------------------------------------
int __cdecl sub_809B740(unsigned __int16 a1, __int16 a2, unsigned __int16 a3, unsigned __int16 a4, __int16 a5)
{
  int result; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v9; // [esp+20h] [ebp-18h]
  _DWORD *i; // [esp+24h] [ebp-14h]
  int *v11; // [esp+28h] [ebp-10h]

  result = sub_80A5E90(a1, a4);
  if ( (_WORD)result )
  {
    v11 = GetVariableValueAddress(result);
    if ( !*v11 )
    {
      v6 = SL_ConvertToString(a3);
      v7 = SL_ConvertToString(a4);
      Com_Error(1, (char *)&byte_80E0D80, v7, v6);
    }
    LOWORD(v8) = a2;
    HIWORD(v8) = a5;
    for ( i = (_DWORD *)*v11; i; i = v9 )
    {
      v9 = (_DWORD *)*i;
      *i = v8;
    }
    result = (int)v11;
    *v11 = 0;
  }
  return result;
}

//----- (0809B812) --------------------------------------------------------
int __cdecl sub_809B812(int a1)
{
  int i; // [esp+4h] [ebp-4h]

  for ( i = dword_81766C0[dword_832D040]; i && dword_81760C0[128 * dword_832D040 + i] != a1; --i )
    ;
  return i;
}
// 81766C0: using guessed type int dword_81766C0[];
// 832D040: using guessed type int dword_832D040;

//----- (0809B866) --------------------------------------------------------
int __cdecl sub_809B866(int a1)
{
  return dword_81760C0[128 * dword_832D040 + a1];
}
// 832D040: using guessed type int dword_832D040;

//----- (0809B87E) --------------------------------------------------------
int __cdecl sub_809B87E(unsigned __int16 a1, unsigned __int16 a2, int a3, int a4, int a5, int a6, unsigned __int16 a7, int a8)
{
  int v8; // ebx
  unsigned __int16 v9; // ax
  int v10; // eax
  unsigned __int16 v12; // [esp+2Eh] [ebp-1Ah]
  unsigned __int16 v13; // [esp+32h] [ebp-16h]
  int v14; // [esp+34h] [ebp-14h]
  unsigned int v15; // [esp+38h] [ebp-10h]
  unsigned __int16 i; // [esp+3Ch] [ebp-Ch]
  unsigned __int16 j; // [esp+3Ch] [ebp-Ch]
  int v18; // [esp+5Ch] [ebp+14h]
  int v19; // [esp+64h] [ebp+1Ch]

  v14 = 0;
  for ( i = FindNextSibling(a1); i; i = FindNextSibling(i) )
  {
    if ( GetVariableName(i) <= 0xFFFF )
      ++v14;
  }
  v13 = sub_80A5E62(a1, 0);
  if ( v13 )
    v12 = *(_WORD *)GetVariableValueAddress(v13);
  else
    v12 = 0;
  dword_80EE8A4 *= 31;
  dword_80EE8A4 += a6;
  dword_80EE8A4 *= 31;
  dword_80EE8A4 += a4;
  dword_80EE8A4 *= 31;
  dword_80EE8A4 += v14;
  dword_80EE8A4 *= 31;
  dword_80EE8A4 += v12;
  sub_80C424E(a3, a6, a5, a4, v14, v12);
  v19 = a4;
  v18 = v14 + a4;
  for ( j = FindNextSibling(a1); j; j = FindNextSibling(j) )
  {
    v15 = GetVariableName(j);
    if ( v15 <= 0xFFFF )
    {
      sub_809B740(a2, v19, a7, v15, a8);
      if ( sub_80A6D12(j) == 7 )
      {
        v8 = SL_ConvertToString(v15);
        v9 = sub_80A6B8A(j);
        v18 = sub_809B87E(v9, a2, a3, v18, v8, v19, a7, a8);
      }
      else
      {
        dword_80EE8A4 *= 31;
        dword_80EE8A4 += v19;
        v10 = SL_ConvertToString(v15);
        sub_80C41DC(a3, v19, v10);
      }
      ++v19;
    }
  }
  return v18;
}
// 80EE8A4: using guessed type int dword_80EE8A4;

//----- (0809BB0A) --------------------------------------------------------
int __cdecl Scr_CheckAnimsDefined(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  const char *v3; // ebx
  const char *v4; // eax
  char *v5; // [esp+10h] [ebp-18h]
  int *v6; // [esp+14h] [ebp-14h]
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v8; // [esp+1Ch] [ebp-Ch]

  result = FindNextSibling(a1);
  for ( i = result; i; i = result )
  {
    v8 = GetVariableName(i);
    v6 = GetVariableValueAddress(i);
    if ( *v6 )
    {
      v3 = (const char *)SL_ConvertToString(a2);
      v4 = (const char *)SL_ConvertToString(v8);
      v5 = va("animation '%s' not defined in anim tree '%s'", v4, v3);
      if ( !sub_80A0F58(*v6) && !sub_80A0F8C(*v6) )
        Com_Error(1, (char *)&byte_80E0DED, v5);
      CompileError2(*v6, "%s", v5);
    }
    result = FindNextSibling(i);
  }
  return result;
}

//----- (0809BC10) --------------------------------------------------------
int __cdecl sub_809BC10(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  const char *v3; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 i; // [esp+14h] [ebp-4h]

  result = FindNextSibling(a1);
  for ( i = result; i; i = result )
  {
    v4 = GetVariableName(i);
    if ( v4 <= 0xFFFF )
    {
      if ( sub_80A6D12(i) == 7 )
      {
        v2 = sub_80A6B8A(i);
        sub_809BC10(v2);
      }
      else
      {
        v3 = (const char *)SL_ConvertToString(v4);
        sub_80C2DDA(v3, (int (__cdecl *)(int))sub_809B684);
      }
    }
    result = FindNextSibling(i);
  }
  return result;
}

//----- (0809BCAA) --------------------------------------------------------
int __cdecl sub_809BCAA(char *a1, int *a2)
{
  unsigned __int16 v2; // ax
  int i; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+10h] [ebp-8h]
  unsigned __int16 v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+12h] [ebp-6h]
  unsigned __int16 v8; // [esp+12h] [ebp-6h]
  unsigned __int16 v9; // [esp+14h] [ebp-4h]
  unsigned __int16 v10; // [esp+16h] [ebp-2h]

  v10 = sub_80A4404(a1);
  v7 = sub_80A5E90(word_81768B2, v10);
  if ( v7 )
  {
    v6 = sub_80A6B8A(v7);
    *a2 = 0;
    for ( i = 1; i <= dword_81766C0[dword_832D040]; ++i )
    {
      if ( word_81764C0[128 * dword_832D040 + i] == v7 )
      {
        *a2 = i;
        break;
      }
    }
    v2 = sub_80A61E0(v6, 0);
  }
  else
  {
    v8 = sub_80A61E0(word_81768B2, v10);
    v5 = sub_80A6AD2(v8);
    word_81764C0[128 * dword_832D040 + ++dword_81766C0[dword_832D040]] = v8;
    *a2 = dword_81766C0[dword_832D040];
    v2 = sub_80A61E0(v5, 0);
  }
  v9 = sub_80A6B2E(v2);
  sub_80A40A6(v10);
  return v9;
}
// 81766C0: using guessed type int dword_81766C0[];
// 81768B2: using guessed type __int16 word_81768B2;
// 832D040: using guessed type int dword_832D040;

//----- (0809BDF0) --------------------------------------------------------
int __cdecl sub_809BDF0(char *a1, int a2)
{
  int result; // eax

  if ( !(unsigned __int8)sub_80A0FEC(a1) )
    sub_80A2D58(a2, "bad anim tree name");
  result = sub_809BCAA(a1, &dword_81760AC);
  word_81768B4 = result;
  return result;
}
// 81760AC: using guessed type int dword_81760AC;
// 81768B4: using guessed type __int16 word_81768B4;

//----- (0809BE36) --------------------------------------------------------
_BOOL4 __cdecl sub_809BE36(const char *a1, unsigned __int16 a2, unsigned __int16 a3)
{
  int v5; // [esp+24h] [ebp-64h]
  int v6; // [esp+28h] [ebp-60h]
  char *v7; // [esp+2Ch] [ebp-5Ch]
  char s[76]; // [esp+30h] [ebp-58h] BYREF
  unsigned __int16 v9; // [esp+7Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+7Eh] [ebp-Ah]

  v10 = a2;
  v9 = a3;
  sprintf(s, "animtrees/%s.atr", a1);
  v5 = *(_DWORD *)dword_80EE874;
  v7 = sub_80A280E(s, 0, 0);
  if ( !v7 )
    return 0;
  v6 = *(_DWORD *)dword_80EE878;
  *(_DWORD *)dword_80EE878 = s;
  sub_809B614((int)v7, v10, v9);
  *(_DWORD *)dword_80EE878 = v6;
  *(_DWORD *)dword_80EE874 = v5;
  sub_806C5D0();
  return sub_80A6A06(v10) != 0;
}

//----- (0809BF04) --------------------------------------------------------
int __cdecl sub_809BF04(int a1, int (__cdecl *a2)(int))
{
  int result; // eax
  const char *v3; // eax
  int v4; // eax
  _DWORD *v5; // eax
  unsigned __int16 v6; // ax
  int *v7; // [esp+30h] [ebp-28h]
  unsigned __int16 v8; // [esp+36h] [ebp-22h]
  unsigned __int16 v9; // [esp+38h] [ebp-20h]
  unsigned __int16 v10; // [esp+3Ah] [ebp-1Eh]
  _DWORD *v11; // [esp+3Ch] [ebp-1Ch]
  unsigned __int16 v12; // [esp+42h] [ebp-16h]
  int v13; // [esp+48h] [ebp-10h]
  unsigned __int16 v14; // [esp+4Eh] [ebp-Ah]
  unsigned __int16 v15; // [esp+4Eh] [ebp-Ah]
  int v16[2]; // [esp+50h] [ebp-8h] BYREF

  v8 = word_81764C0[128 * dword_832D040 + a1];
  v12 = GetVariableName(v8);
  v9 = sub_80A6B8A(v8);
  result = sub_80A5E90(v9, 1);
  if ( !(_WORD)result )
  {
    v14 = sub_80A5E90(v9, 0);
    if ( v14 )
    {
      v15 = sub_80A6B8A(v14);
      word_81760A0 = sub_80A5AB4();
      v3 = (const char *)SL_ConvertToString(v12);
      if ( sub_809BE36(v3, word_81760A0, v15) )
      {
        v13 = sub_809B6A0(word_81760A0);
        v4 = SL_ConvertToString(v12);
        v7 = (int *)sub_80650D2("animtrees", v4, (int)".atr");
        if ( v7 )
          v5 = sub_80C42D6(*v7, v13, a2);
        else
          v5 = sub_80C42D6((int)"(savegame)", v13, a2);
        v11 = v5;
        v10 = sub_80A3D64("root", 0);
        sub_809B740(v15, 0, v12, v10, a1);
        sub_80A40A6(v10);
        sub_809B87E(word_81760A0, v15, (int)v11, 1, (int)"root", 0, v12, a1);
        Scr_CheckAnimsDefined(v15, v12);
        sub_809BC10(word_81760A0);
        sub_80A6248(v9, 0);
        sub_80A5C0A(word_81760A0);
        word_81760A0 = 0;
        v16[1] = 6;
        v16[0] = (int)v11;
        v6 = sub_80A61E0(v9, 1u);
        sub_80A6598(v6, v16);
        sub_80CB714(v11);
        result = (int)v11;
        dword_81760C0[128 * dword_832D040 + a1] = (int)v11;
      }
      else
      {
        sub_80A6248(word_81768B2, v12);
        sub_80A5C0A(word_81760A0);
        word_81760A0 = 0;
        result = 0;
        dword_81760C0[128 * dword_832D040 + a1] = 0;
      }
    }
    else
    {
      result = 0;
      dword_81760C0[128 * dword_832D040 + a1] = 0;
    }
  }
  return result;
}
// 81760A0: using guessed type __int16 word_81760A0;
// 81768B2: using guessed type __int16 word_81768B2;
// 832D040: using guessed type int dword_832D040;

//----- (0809C1E6) --------------------------------------------------------
_DWORD *__userpurge sub_809C1E6@<eax>(_DWORD *a1, char *a2)
{
  int v3; // [esp+8h] [ebp-10h] BYREF
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v5 = sub_80A4404(a2);
  v6 = sub_80A5E90(word_81768B2, v5);
  sub_80A40A6(v5);
  *a1 = 0;
  if ( v6 )
  {
    v5 = GetVariableName(v6);
    v6 = sub_80A6B8A(v6);
    v4 = sub_80A5E90(v6, 1);
    if ( v4 )
    {
      sub_80A67A2(v4, &v3);
      *a1 = v3;
    }
  }
  return a1;
}
// 81768B2: using guessed type __int16 word_81768B2;

//----- (0809C298) --------------------------------------------------------
int __cdecl sub_809C298(char *a1, char *s, int *a3)
{
  unsigned __int16 v3; // ax
  int v5; // [esp+10h] [ebp-8h] BYREF
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = sub_80A3E4A(s, 0, 4);
  v3 = sub_809BCAA(a1, &v5);
  sub_809B142(a3, v6, v3, 0);
  return sub_80A40A6(v6);
}

//----- (0809C300) --------------------------------------------------------
int __cdecl sub_809C300(int a1)
{
  int result; // eax

  result = a1;
  if ( !byte_81766DC )
    result = sub_80A40A6(a1);
  return result;
}
// 81766DC: using guessed type char byte_81766DC;

//----- (0809C326) --------------------------------------------------------
_DWORD *__cdecl sub_809C326(unsigned __int16 a1)
{
  _DWORD *result; // eax
  __int16 v2; // dx

  dword_81766C8 = sub_80A4460(2);
  if ( dword_81766E0 == 2 )
    return (_DWORD *)sub_809C300(a1);
  if ( byte_81766DC )
    sub_80A3F08(a1);
  if ( dword_81766E0 )
  {
    *(_WORD *)dword_81766C8 = a1;
    result = Z_MallocInternal(8u);
    *result = dword_81766C8 + (_BYTE *)dword_81766EC - (_BYTE *)dword_81766E8;
    *(_WORD *)*result = 0;
    result[1] = dword_80EE848;
    dword_80EE848 = result;
  }
  else
  {
    v2 = sub_80A1158(a1);
    result = (_DWORD *)dword_81766C8;
    *(_WORD *)dword_81766C8 = v2;
  }
  return result;
}
// 81766C8: using guessed type int dword_81766C8;
// 81766DC: using guessed type char byte_81766DC;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809C3E8) --------------------------------------------------------
int __cdecl sub_809C3E8(unsigned __int16 a1, unsigned __int8 a2)
{
  if ( dword_81766E0 == 2 )
    return sub_809C300(a1);
  if ( byte_81766DC )
    sub_80A3F08(a1);
  return sub_80A3EB4(a1, a2);
}
// 81766DC: using guessed type char byte_81766DC;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809C43E) --------------------------------------------------------
int __cdecl sub_809C43E(unsigned __int8 a1, int a2, int a3)
{
  int result; // eax

  if ( byte_81766E4 && !dword_81766E0 )
  {
    byte_81766E4 = 0;
    sub_80A01F4();
  }
  dword_81766D0 += a2;
  if ( dword_81766D4 < dword_81766D0 )
    dword_81766D4 = dword_81766D0;
  if ( a3 )
  {
    if ( dword_81766D8 < dword_81766D0 )
    {
      dword_81766D8 = dword_81766D0;
      if ( a3 == 3 )
        ++dword_81766D8;
    }
  }
  dword_81766C8 = sub_80A4460(1);
  dword_81F6C48 = dword_81766C8;
  *(_BYTE *)dword_81766C8 = a1;
  dword_80EE8A4 *= 31;
  result = a1;
  dword_80EE8A4 += a1;
  return result;
}
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81766C8: using guessed type int dword_81766C8;
// 81766D0: using guessed type int dword_81766D0;
// 81766D4: using guessed type int dword_81766D4;
// 81766D8: using guessed type int dword_81766D8;
// 81766E0: using guessed type int dword_81766E0;
// 81766E4: using guessed type char byte_81766E4;
// 81F6C48: using guessed type int dword_81F6C48;

//----- (0809C4F6) --------------------------------------------------------
int sub_809C4F6()
{
  return sub_809C43E(0x56u, 0, 0);
}

//----- (0809C51A) --------------------------------------------------------
int __cdecl sub_809C51A(int a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = a1;
  *(_DWORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C53E) --------------------------------------------------------
int __cdecl sub_809C53E(unsigned __int16 a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(2);
  result = a1;
  *(_WORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C56C) --------------------------------------------------------
int __cdecl sub_809C56C(unsigned __int8 a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(1);
  result = a1;
  *(_BYTE *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C598) --------------------------------------------------------
int __cdecl sub_809C598(int a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = a1;
  *(_DWORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C5BC) --------------------------------------------------------
int __cdecl sub_809C5BC(unsigned __int16 a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(2);
  result = a1;
  *(_WORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C5EA) --------------------------------------------------------
int sub_809C5EA()
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = dword_81766C8;
  *(_DWORD *)dword_81766C8 = 0;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C60E) --------------------------------------------------------
int __cdecl sub_809C60E(int a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = a1;
  *(_DWORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C632) --------------------------------------------------------
int __cdecl sub_809C632(int a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = a1;
  *(_DWORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C656) --------------------------------------------------------
int __cdecl sub_809C656(int a1)
{
  int result; // eax

  dword_81766C8 = sub_80A4460(4);
  result = a1;
  *(_DWORD *)dword_81766C8 = a1;
  return result;
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809C67A) --------------------------------------------------------
int sub_809C67A()
{
  return sub_809C43E(2u, 1, 0);
}

//----- (0809C69E) --------------------------------------------------------
int __cdecl sub_809C69E(int a1)
{
  sub_809C43E(3u, 1, 0);
  return sub_809C51A(a1);
}

//----- (0809C6CE) --------------------------------------------------------
int __cdecl sub_809C6CE(int a1)
{
  sub_809C43E(4u, 1, 0);
  return sub_809C598(a1);
}

//----- (0809C6FE) --------------------------------------------------------
int sub_809C6FE()
{
  sub_809C43E(3u, 1, 0);
  return sub_809C51A(0);
}

//----- (0809C72E) --------------------------------------------------------
int sub_809C72E()
{
  sub_809C43E(3u, 1, 0);
  return sub_809C51A(1);
}

//----- (0809C75E) --------------------------------------------------------
int __cdecl sub_809C75E(int a1)
{
  if ( !dword_81760AC )
    sub_80A2D58(a1, "#using_animtree was not specified");
  sub_809C43E(3u, 1, 0);
  return sub_809C51A(dword_81760AC);
}
// 81760AC: using guessed type int dword_81760AC;

//----- (0809C7AE) --------------------------------------------------------
void __cdecl sub_809C7AE(int a1)
{
  sub_809C43E(0x20u, -1, 0);
  sub_80A222E(a1);
}

//----- (0809C7DE) --------------------------------------------------------
_DWORD *__cdecl sub_809C7DE(unsigned __int16 a1, int a2)
{
  sub_809C43E(0x1Cu, 0, 0);
  sub_80A222E(a2);
  return sub_809C326(a1);
}

//----- (0809C81A) --------------------------------------------------------
_DWORD *__cdecl sub_809C81A(unsigned __int16 a1, int a2)
{
  sub_809C43E(0x1Du, 0, 0);
  sub_80A222E(a2);
  return sub_809C326(a1);
}

//----- (0809C856) --------------------------------------------------------
int __cdecl sub_809C856(unsigned __int16 a1)
{
  sub_809C43E(5u, 1, 0);
  sub_809C5BC(a1);
  return sub_809C3E8(a1, 1u);
}

//----- (0809C8A2) --------------------------------------------------------
int __cdecl sub_809C8A2(unsigned __int16 a1)
{
  sub_809C43E(6u, 1, 0);
  sub_809C5BC(a1);
  return sub_809C3E8(a1, 1u);
}

//----- (0809C8EE) --------------------------------------------------------
void __cdecl sub_809C8EE(int a1)
{
  sub_809C43E(0x2Fu, 0, 0);
  sub_80A222E(a1);
}

//----- (0809C91E) --------------------------------------------------------
void __cdecl sub_809C91E(int a1)
{
  sub_809C43E(0x30u, 0, 0);
  sub_80A222E(a1);
}

//----- (0809C94E) --------------------------------------------------------
void __cdecl sub_809C94E(int a1)
{
  sub_809C43E(0x31u, 0, 0);
  sub_80A222E(a1);
}

//----- (0809C97E) --------------------------------------------------------
void __cdecl sub_809C97E(int a1)
{
  sub_809C43E(0x32u, 0, 0);
  sub_80A222E(a1);
}

//----- (0809C9AE) --------------------------------------------------------
void __cdecl sub_809C9AE(int a1)
{
  sub_809C43E(0x33u, 0, 0);
  sub_80A222E(a1);
}

//----- (0809C9DE) --------------------------------------------------------
void __cdecl sub_809C9DE(int a1)
{
  sub_809C43E(0x34u, 0, 0);
  sub_80A222E(a1);
}

//----- (0809CA0E) --------------------------------------------------------
void __cdecl sub_809CA0E(int a1, int a2)
{
  sub_809E36C(a1);
  sub_809C43E(0x4Du, 0, 0);
  sub_80A222E(a2);
}
// 809E36C: using guessed type _DWORD __cdecl sub_809E36C(_DWORD);

//----- (0809CA48) --------------------------------------------------------
int sub_809CA48()
{
  return sub_809C43E(0xAu, 1, 0);
}

//----- (0809CA6C) --------------------------------------------------------
int sub_809CA6C()
{
  return sub_809C43E(0xBu, 1, 0);
}

//----- (0809CA90) --------------------------------------------------------
int sub_809CA90()
{
  return sub_809C43E(0xCu, 1, 0);
}

//----- (0809CAB4) --------------------------------------------------------
int sub_809CAB4()
{
  return sub_809C43E(0xDu, 1, 0);
}

//----- (0809CAD8) --------------------------------------------------------
int sub_809CAD8()
{
  return sub_809C43E(7u, 0, 0);
}

//----- (0809CAFC) --------------------------------------------------------
int sub_809CAFC()
{
  return sub_809C43E(8u, 0, 0);
}

//----- (0809CB20) --------------------------------------------------------
int sub_809CB20()
{
  return sub_809C43E(9u, 0, 0);
}

//----- (0809CB44) --------------------------------------------------------
_DWORD *__cdecl sub_809CB44(unsigned __int16 a1)
{
  sub_809C43E(0x11u, 1, 0);
  return sub_809C326(a1);
}

//----- (0809CB74) --------------------------------------------------------
_DWORD *__cdecl sub_809CB74(unsigned __int16 a1)
{
  sub_809C43E(0x12u, 0, 0);
  return sub_809C326(a1);
}

//----- (0809CBA4) --------------------------------------------------------
int sub_809CBA4()
{
  return sub_809C43E(0xFu, 0, 0);
}

//----- (0809CBC8) --------------------------------------------------------
_DWORD *__cdecl sub_809CBC8(unsigned __int16 a1)
{
  sub_809C43E(0x13u, 0, 0);
  return sub_809C326(a1);
}

//----- (0809CBF8) --------------------------------------------------------
void __cdecl sub_809CBF8(int a1, int a2)
{
  sub_809C43E(0x14u, -1, 0);
  sub_80A222E(a2);
  sub_80A222E(a1);
}

//----- (0809CC32) --------------------------------------------------------
void __cdecl sub_809CC32(int a1, int a2)
{
  sub_809C43E(0x15u, -1, 0);
  sub_80A222E(a2);
  sub_80A222E(a1);
}

//----- (0809CC6C) --------------------------------------------------------
void __cdecl sub_809CC6C(int a1, int a2)
{
  sub_809C43E(0x16u, -1, 0);
  sub_80A222E(a2);
  sub_80A222E(a1);
}

//----- (0809CCA6) --------------------------------------------------------
int sub_809CCA6()
{
  return sub_809C43E(0x17u, 1, 0);
}

//----- (0809CCCA) --------------------------------------------------------
int __cdecl sub_809CCCA(unsigned __int16 a1, int a2)
{
  sub_809C43E(0xEu, 1, 0);
  sub_809C51A(-1);
  sub_80A222E(a2);
  sub_809B1FC((int *)dword_81766C8, a1, a2);
  return sub_809C300(a1);
}
// 81766C8: using guessed type int dword_81766C8;

//----- (0809CD2E) --------------------------------------------------------
_DWORD *__cdecl sub_809CD2E(_DWORD *a1, unsigned __int16 a2, int a3)
{
  sub_809EA08(a1, a3);
  sub_809C43E(0x18u, 1, 0);
  sub_80A222E(a3);
  return sub_809C326(a2);
}

//----- (0809CD7C) --------------------------------------------------------
_DWORD *__cdecl sub_809CD7C(_DWORD *a1, unsigned __int16 a2, int a3)
{
  sub_809EA08(a1, a3);
  sub_809C43E(0x19u, 0, 0);
  return sub_809C326(a2);
}

//----- (0809CDBE) --------------------------------------------------------
_DWORD *__cdecl sub_809CDBE(_DWORD *a1, unsigned __int16 a2, int a3, int a4)
{
  sub_809EA08(a1, a3);
  sub_809C43E(0x1Au, 0, 0);
  sub_80A222E(a4);
  return sub_809C326(a2);
}

//----- (0809CE0C) --------------------------------------------------------
int __cdecl sub_809CE0C(int a1, int a2)
{
  sub_809D8AC(a1, a2, 0);
  return sub_809C43E(0x1Bu, -1, 0);
}

//----- (0809CE4A) --------------------------------------------------------
int __cdecl sub_809CE4A(int a1, int a2, int a3, int a4)
{
  sub_809DAE8(a1, a2, a3, a4, 0);
  return sub_809C43E(0x1Bu, -1, 0);
}

//----- (0809CE96) --------------------------------------------------------
int sub_809CE96()
{
  return sub_809C43E(0x2Du, -1, 0);
}

//----- (0809CEBA) --------------------------------------------------------
void __cdecl sub_809CEBA(int a1)
{
  sub_809C43E(0x2Eu, -1, 0);
  sub_80A222E(a1);
}

//----- (0809CEEA) --------------------------------------------------------
void __cdecl sub_809CEEA(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  sub_809E6CE(a2);
  sub_809E36C(a1);
  sub_809CBF8(a3, a4);
}

//----- (0809CF1A) --------------------------------------------------------
void __cdecl sub_809CF1A(int a1, _DWORD *a2, int a3, int a4)
{
  sub_809E6CE(a2);
  sub_809E924(a1, a3);
  sub_809CC32(a3, a4);
}

//----- (0809CF52) --------------------------------------------------------
void __cdecl sub_809CF52(int a1, _DWORD *a2, int a3, int a4)
{
  sub_809E6CE(a2);
  sub_809E924(a1, a3);
  sub_809CC6C(a3, a4);
}

//----- (0809CF8A) --------------------------------------------------------
void __cdecl sub_809CF8A(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 11 )
  {
    sub_809CEEA(*(_DWORD **)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809CD2E(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  }
  else if ( v1 == 3 )
  {
    sub_809CB44(*(_DWORD *)(a1 + 4));
  }
}

//----- (0809D026) --------------------------------------------------------
int __cdecl sub_809D026(int *a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = *a1; i; i = *(_DWORD *)(i + 4) )
  {
    sub_809E6CE(**(_DWORD ***)i);
    ++v2;
  }
  return v2;
}

//----- (0809D06A) --------------------------------------------------------
int __cdecl sub_809D06A(int a1)
{
  if ( !*(_DWORD *)a1 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)a1 + 4) )
    return 0;
  return *(_DWORD *)a1;
}

//----- (0809D0A6) --------------------------------------------------------
_DWORD *__cdecl sub_809D0A6(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *i; // [esp+4h] [ebp-4h]

  if ( dword_81768C0 )
  {
    result = (_DWORD *)*a1;
    for ( i = (_DWORD *)*a1; i; i = result )
    {
      sub_80A222E(*(_DWORD *)(*i + 4));
      result = (_DWORD *)i[1];
    }
  }
  return result;
}
// 81768C0: using guessed type int dword_81768C0;

//----- (0809D0E8) --------------------------------------------------------
int __cdecl sub_809D0E8(unsigned __int16 a1, int a2)
{
  unsigned __int16 v2; // ax

  sub_80A3F08(a1);
  *(_WORD *)dword_81766F0 = a1;
  *(_DWORD *)(dword_81766F0 + 4) = a2;
  dword_81766F0 += 8;
  v2 = sub_80A61E0(word_81768AE, a1);
  return (unsigned __int16)sub_80A6AD2(v2);
}
// 81766F0: using guessed type int dword_81766F0;
// 81768AE: using guessed type __int16 word_81768AE;

//----- (0809D148) --------------------------------------------------------
void __cdecl sub_809D148(int a1, int a2)
{
  char *v2; // eax
  bool v3; // [esp+1Bh] [ebp-1Dh]
  unsigned __int16 v4; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v5; // [esp+1Eh] [ebp-1Ah]
  unsigned __int16 v6; // [esp+20h] [ebp-18h]
  unsigned __int16 v7; // [esp+22h] [ebp-16h]
  unsigned __int16 v8; // [esp+24h] [ebp-14h]
  unsigned __int16 v9; // [esp+24h] [ebp-14h]
  unsigned __int16 v10; // [esp+26h] [ebp-12h]
  int v11; // [esp+28h] [ebp-10h] BYREF
  int v12; // [esp+2Ch] [ebp-Ch]
  int v13; // [esp+30h] [ebp-8h] BYREF
  int v14; // [esp+34h] [ebp-4h]

  if ( dword_81766E0 == 2 )
  {
    sub_809C300(*(unsigned __int16 *)(a1 + 4));
    if ( *(_DWORD *)a1 == 17 )
    {
      sub_809C300(*(unsigned __int16 *)(a1 + 8));
      --dword_81768CC;
    }
    return;
  }
  v10 = 0;
  if ( *(_DWORD *)a1 == 16 )
  {
    v8 = sub_80A5E90(word_81766CC, *(unsigned __int16 *)(a1 + 4));
    sub_809C3E8(*(_WORD *)(a1 + 4), 2u);
    if ( !v8 )
      sub_80A2D58(a2, "unknown function");
    v10 = sub_80A6B8A(v8);
    goto LABEL_21;
  }
  if ( *(_DWORD *)a1 == 17 )
  {
    v2 = (char *)SL_ConvertToString(*(_WORD *)(a1 + 4));
    v4 = sub_80A4404(v2);
    sub_809C300(*(unsigned __int16 *)(a1 + 4));
    v3 = (unsigned __int16)sub_80A5E90(word_81768B0, v4) != 0;
    v5 = sub_809D0E8(v4, a2);
    sub_809C300(v4);
    if ( v3 )
    {
      v9 = sub_80A5E90(v5, *(unsigned __int16 *)(a1 + 8));
      sub_809C3E8(*(_WORD *)(a1 + 8), 2u);
      if ( !v9 )
        sub_80A2D58(a2, "unknown function");
    }
    else
    {
      v9 = sub_80A61E0(v5, *(unsigned __int16 *)(a1 + 8));
      sub_809C3E8(*(_WORD *)(a1 + 8), 2u);
    }
    sub_80A67A2(v9, &v11);
    if ( v12 != 6 )
    {
      if ( v12 != 5 )
      {
        v10 = sub_80A6AD2(v9);
        goto LABEL_21;
      }
      if ( dword_81766E0 != 1 )
        sub_80A2D58(a2, "normal script cannot reference /# ... #/ comment");
    }
    sub_809C60E(v11);
    return;
  }
LABEL_21:
  sub_809C5EA();
  if ( dword_81766E0 != 2 )
  {
    v7 = sub_80A61E0(v10, 0);
    sub_80A67A2(v7, &v13);
    if ( !v14 )
    {
      v14 = 5;
      v13 = 0;
    }
    v6 = sub_80A61E0(v10, v13 + 2);
    v11 = dword_81766C8;
    if ( dword_81766E0 == 1 )
    {
      v12 = 5;
      v11 += (_BYTE *)dword_81766EC - (_BYTE *)dword_81766E8;
    }
    else
    {
      v12 = 6;
    }
    sub_80A6608(v6, &v11);
    ++v13;
    sub_80A6598(v7, &v13);
    sub_80A222E(a2);
  }
}
// 81766C8: using guessed type int dword_81766C8;
// 81766CC: using guessed type __int16 word_81766CC;
// 81766E0: using guessed type int dword_81766E0;
// 81768B0: using guessed type __int16 word_81768B0;
// 81768CC: using guessed type int dword_81768CC;

//----- (0809D462) --------------------------------------------------------
void __cdecl sub_809D462(int a1, int a2)
{
  sub_809C43E(0x10u, 1, 0);
  sub_809D148(a1, a2);
}

//----- (0809D498) --------------------------------------------------------
int __cdecl sub_809D498(int a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_809C43E(0x27u, -a2 - 2, 3);
  else
    sub_809C43E(0x25u, -a2 - 1, 3);
  sub_809D148(a1, a4);
  return sub_809C51A(a2);
}

//----- (0809D50A) --------------------------------------------------------
int __cdecl sub_809D50A(int a1, int a2, char a3, int a4, int a5)
{
  sub_809E6CE(a1);
  if ( a3 )
    sub_809C43E(0x28u, -a2 - 3, 3);
  else
    sub_809C43E(0x26u, -a2 - 2, 3);
  sub_80A222E(a5);
  sub_80A222E(a4);
  return sub_809C51A(a2);
}
// 809E6CE: using guessed type _DWORD __cdecl sub_809E6CE(_DWORD);

//----- (0809D58C) --------------------------------------------------------
int __cdecl sub_809D58C(int a1, int a2, char a3, int a4)
{
  if ( a3 )
    sub_809C43E(0x2Bu, -a2, 2);
  else
    sub_809C43E(0x29u, 1 - a2, 2);
  sub_809D148(a1, a4);
  return sub_809C51A(a2);
}

//----- (0809D5FC) --------------------------------------------------------
int __cdecl sub_809D5FC(int a1, int a2, char a3, int a4)
{
  sub_809E6CE(a1);
  if ( a3 )
    sub_809C43E(0x2Cu, -a2 - 1, 2);
  else
    sub_809C43E(0x2Au, -a2, 2);
  sub_80A222E(a4);
  return sub_809C51A(a2);
}
// 809E6CE: using guessed type _DWORD __cdecl sub_809E6CE(_DWORD);

//----- (0809D66E) --------------------------------------------------------
int __cdecl sub_809D66E(int *a1, int a2, char a3, int a4)
{
  int result; // eax

  result = *a1;
  if ( *a1 == 14 )
    return sub_809D498(a1[1], a2, a3, a4);
  if ( *a1 == 18 )
    result = sub_809D50A(a1[1], a2, a3, a4, a1[2]);
  return result;
}

//----- (0809D6EC) --------------------------------------------------------
void __cdecl sub_809D6EC(_DWORD *a1, int a2, char a3, int a4, int a5)
{
  if ( *a1 == 14 )
  {
    sub_809D58C(a1[1], a2, a3, a5);
  }
  else if ( *a1 == 18 )
  {
    sub_809D5FC(a1[1], a2, a3, a1[2]);
  }
  sub_80A222E(a4);
}

//----- (0809D76E) --------------------------------------------------------
int __cdecl sub_809D76E(_DWORD *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 == 22 )
    result = sub_809C43E(0x24u, 2, 0);
  return result;
}

//----- (0809D79A) --------------------------------------------------------
void __cdecl sub_809D79A(int a1, int a2, char a3)
{
  if ( *(_DWORD *)a1 == 22 )
  {
    sub_809D66E(*(int **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8));
  }
  else if ( *(_DWORD *)a1 == 26 )
  {
    sub_809D6EC(*(_DWORD **)(a1 + 4), a2, a3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  }
}

//----- (0809D822) --------------------------------------------------------
int __cdecl sub_809D822(_DWORD *a1)
{
  _DWORD *v3; // [esp+20h] [ebp+8h]
  int v4; // [esp+20h] [ebp+8h]

  if ( *a1 != 22 )
    return 0;
  v3 = (_DWORD *)a1[1];
  if ( *v3 != 14 )
    return 0;
  v4 = v3[1];
  if ( *(_DWORD *)v4 != 16 )
    return 0;
  if ( (unsigned __int16)sub_80A5E90(word_81766CC, *(unsigned __int16 *)(v4 + 4)) )
    return 0;
  return *(unsigned __int16 *)(v4 + 4);
}
// 81766CC: using guessed type __int16 word_81766CC;

//----- (0809D8AC) --------------------------------------------------------
_DWORD *__cdecl sub_809D8AC(int a1, int a2, char a3)
{
  _DWORD *result; // eax
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  char v8[4]; // [esp+24h] [ebp-14h] BYREF
  int v9; // [esp+28h] [ebp-10h]
  unsigned __int16 v10; // [esp+2Eh] [ebp-Ah]
  int v11; // [esp+30h] [ebp-8h]
  char v12; // [esp+37h] [ebp-1h]

  v12 = a3;
  v10 = sub_809D822((_DWORD *)a1);
  if ( v10 )
  {
    *(_DWORD *)v8 = SL_ConvertToString(v10);
    v7 = 0;
    v6 = Scr_GetCustomFunction((int)v8, (int)&v7);
    v9 = *(_DWORD *)(a1 + 8);
    v5 = dword_80EE8A4;
    v4 = sub_80A4460(0);
    if ( v7 )
    {
      if ( dword_81766E0 )
      {
        v7 = 0;
      }
      else
      {
        if ( !v12 )
          sub_80A2D58(v9, "developer command can only be used as a statement if not in a /# ... #/ comment");
        if ( dword_81768C4 )
        {
          if ( !byte_81766E4 )
          {
            sub_809C43E(0x57u, 0, 0);
            dword_81766E8 = (void *)dword_81766C8;
          }
          dword_81766E0 = 1;
        }
        else
        {
          dword_81766E0 = 2;
        }
      }
    }
    v11 = sub_809D026((int *)a2);
    if ( v11 > 255 )
    {
      sub_809C300(v10);
      sub_80A2D58(v9, "parameter count exceeds 256");
    }
    if ( !v6 )
      sub_80A2D58(v9, "unknown (builtin) function '%s'", *(const char **)v8);
    sub_809C300(v10);
    sub_809C43E(0x21u, 1 - v11, 1);
    sub_809C56C(v11);
    sub_809C632(v6);
    sub_80A222E(v9);
    result = sub_809D0A6((_DWORD *)a2);
    if ( v12 )
      result = (_DWORD *)sub_809CE96();
    if ( v7 )
    {
      dword_81766E0 = 0;
      if ( dword_81768C4 )
        byte_81766E4 = 1;
      else
        sub_80A4494(v4);
      result = (_DWORD *)v5;
      dword_80EE8A4 = v5;
    }
  }
  else
  {
    sub_809D76E((_DWORD *)a1);
    v11 = sub_809D026((int *)a2);
    sub_809D79A(a1, v11, 0);
    result = sub_809D0A6((_DWORD *)a2);
    if ( v12 )
      result = (_DWORD *)sub_809CE96();
  }
  return result;
}
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;
// 81766E4: using guessed type char byte_81766E4;
// 81768C4: using guessed type int dword_81768C4;

//----- (0809DAE8) --------------------------------------------------------
_DWORD *__cdecl sub_809DAE8(int a1, int a2, int a3, int a4, char a5)
{
  _DWORD *result; // eax
  int v6; // [esp+14h] [ebp-24h]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+20h] [ebp-18h] BYREF
  char v10[4]; // [esp+24h] [ebp-14h] BYREF
  int v11; // [esp+28h] [ebp-10h]
  unsigned __int16 v12; // [esp+2Eh] [ebp-Ah]
  int v13; // [esp+30h] [ebp-8h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = a5;
  v12 = sub_809D822((_DWORD *)a2);
  if ( v12 )
  {
    *(_DWORD *)v10 = SL_ConvertToString(v12);
    v9 = 0;
    v8 = sub_80A0AD0((int)v10, (int)&v9);
    v11 = *(_DWORD *)(a2 + 8);
    v7 = dword_80EE8A4;
    v6 = sub_80A4460(0);
    if ( v9 )
    {
      if ( dword_81766E0 )
      {
        v9 = 0;
      }
      else
      {
        if ( !v14 )
          sub_80A2D58(v11, "developer command can only be used as a statement if not in a /# ... #/ comment");
        if ( dword_81768C4 )
        {
          if ( !byte_81766E4 )
          {
            sub_809C43E(0x57u, 0, 0);
            dword_81766E8 = (void *)dword_81766C8;
          }
          dword_81766E0 = 1;
        }
        else
        {
          dword_81766E0 = 2;
        }
      }
    }
    v13 = sub_809D026(a3);
    sub_809E36C(a1);
    if ( v13 > 255 )
    {
      sub_809C300(v12);
      sub_80A2D58(v11, "parameter count exceeds 256");
    }
    if ( !v8 )
      sub_80A2D58(v11, "unknown (builtin) method '%s'", *(const char **)v10);
    sub_809C300(v12);
    sub_809C43E(0x22u, -v13, 1);
    sub_809C56C(v13);
    sub_809C656(v8);
    sub_80A222E(v11);
    sub_80A222E(a4);
    result = sub_809D0A6((_DWORD *)a3);
    if ( v14 )
      result = (_DWORD *)sub_809CE96();
    if ( v9 )
    {
      dword_81766E0 = 0;
      if ( dword_81768C4 )
        byte_81766E4 = 1;
      else
        sub_80A4494(v6);
      result = (_DWORD *)v7;
      dword_80EE8A4 = v7;
    }
  }
  else
  {
    sub_809D76E((_DWORD *)a2);
    v13 = sub_809D026(a3);
    sub_809E36C(a1);
    sub_809D79A(a2, v13, 1);
    sub_80A222E(a4);
    result = sub_809D0A6((_DWORD *)a3);
    if ( v14 )
      result = (_DWORD *)sub_809CE96();
  }
  return result;
}
// 809D026: using guessed type _DWORD __cdecl sub_809D026(_DWORD);
// 809E36C: using guessed type _DWORD __cdecl sub_809E36C(_DWORD);
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;
// 81766E4: using guessed type char byte_81766E4;
// 81768C4: using guessed type int dword_81768C4;

//----- (0809DD52) --------------------------------------------------------
int sub_809DD52()
{
  int result; // eax
  int j; // [esp+8h] [ebp-30h]
  unsigned __int16 v2; // [esp+Eh] [ebp-2Ah]
  int *v3; // [esp+10h] [ebp-28h]
  unsigned __int16 v4; // [esp+16h] [ebp-22h]
  int v5; // [esp+18h] [ebp-20h] BYREF
  int v6; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v7; // [esp+26h] [ebp-12h]
  int v8[3]; // [esp+28h] [ebp-10h] BYREF
  unsigned __int16 v9; // [esp+34h] [ebp-4h]
  unsigned __int16 i; // [esp+36h] [ebp-2h]

  v6 = 0;
  v5 = 0;
  result = FindNextSibling(word_81766CC);
  for ( i = result; i; i = result )
  {
    v9 = sub_80A6B8A(i);
    v4 = sub_80A5E90(v9, 1);
    if ( v4 )
      sub_80A67A2(v4, &v5);
    v7 = sub_80A5E90(v9, 0);
    if ( v7 )
    {
      sub_80A67A2(v7, v8);
      for ( j = 0; j < v8[0]; ++j )
      {
        v2 = sub_80A5E90(v9, j + 2);
        v3 = GetVariableValueAddress(v2);
        if ( v6 == 5 && sub_80A6D12(v2) == 6 )
          CompileError2(*v3, "normal script cannot reference /# ... #/ comment");
        if ( !v4 )
          CompileError2(*v3, "unknown function");
        *(_DWORD *)*v3 = v5;
      }
    }
    if ( v4 )
      sub_80A6598(i, &v5);
    result = FindNextSibling(i);
  }
  return result;
}
// 81766CC: using guessed type __int16 word_81766CC;

//----- (0809DECC) --------------------------------------------------------
int __cdecl sub_809DECC(unsigned __int16 a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+26h] [ebp-2h]

  v6 = a1;
  v3 = sub_80A61E0(a1, 1u);
  sub_80A67A2(v3, &v4);
  if ( v5 )
    sub_80A2D58(a2, "function already defined");
  v5 = 6;
  v4 = 0;
  return sub_80A6608(v3, &v4);
}

//----- (0809DF42) --------------------------------------------------------
int __cdecl sub_809DF42(int a1, int a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+26h] [ebp-2h]

  result = a1;
  v6 = a1;
  if ( dword_81768C4 )
  {
    v3 = sub_80A61E0(v6, 1u);
    sub_80A67A2(v3, &v4);
    if ( v5 )
      sub_80A2D58(a2, "function already defined");
    v5 = 5;
    v4 = 0;
    result = sub_80A6608(v3, &v4);
  }
  return result;
}
// 81768C4: using guessed type int dword_81768C4;

//----- (0809DFC4) --------------------------------------------------------
int __cdecl sub_809DFC4(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // ebx
  int result; // eax

  v1 = sub_80A5E90(a1, 1);
  v2 = GetVariableValueAddress(v1);
  result = sub_80A4460(0);
  *v2 = result;
  return result;
}

//----- (0809E008) --------------------------------------------------------
int __cdecl sub_809E008(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // ebx
  int result; // eax

  v1 = sub_80A5E90(a1, 1);
  v2 = GetVariableValueAddress(v1);
  result = (_BYTE *)dword_81766EC - (_BYTE *)dword_81766E8 + sub_80A4460(0);
  *v2 = result;
  return result;
}

//----- (0809E05E) --------------------------------------------------------
_DWORD *__cdecl sub_809E05E(_DWORD *a1, char a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)*a1;
  if ( *a1 == 19 )
    return (_DWORD *)sub_809D8AC(a1[1], a1[2], a2);
  if ( *a1 == 20 )
    result = sub_809DAE8(a1[1], a1[2], a1[3], a1[4], a2);
  return result;
}

//----- (0809E0E4) --------------------------------------------------------
int __cdecl sub_809E0E4(int *a1)
{
  int result; // eax

  result = *a1;
  if ( *a1 == 19 )
    return sub_809CE0C(a1[1], a1[2]);
  if ( *a1 == 20 )
    result = sub_809CE4A(a1[1], a1[2], a1[3], a1[4]);
  return result;
}

//----- (0809E160) --------------------------------------------------------
void __cdecl sub_809E160(_DWORD *a1)
{
  if ( *a1 == 19 )
  {
    sub_809D8AC(a1[1], a1[2], 0);
    sub_809CEBA(a1[3]);
  }
  else if ( *a1 == 20 )
  {
    sub_809DAE8(a1[1], a1[2], a1[3], a1[4], 0);
    sub_809CEBA(a1[5]);
  }
}

//----- (0809E204) --------------------------------------------------------
_DWORD *__cdecl sub_809E204(_DWORD *a1, int a2)
{
  _DWORD *result; // eax

  result = (_DWORD *)sub_809D026(a1);
  if ( result != (_DWORD *)1 )
  {
    if ( result != (_DWORD *)3 )
      sub_80A2D58(a2, "expression list must have 1 or 3 parameters");
    sub_809C43E(0x55u, -2, 0);
    result = sub_809D0A6(a1);
  }
  return result;
}
// 809D026: using guessed type _DWORD __cdecl sub_809D026(_DWORD);

//----- (0809E26A) --------------------------------------------------------
int __cdecl sub_809E26A(int *a1, int a2)
{
  _DWORD ***v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD ***)sub_809D06A((int)a1);
  if ( v3 )
    return sub_809E9B8(**v3, (int)(*v3)[1]);
  if ( sub_809D026(a1) != 3 )
    sub_80A2D58(a2, "not an array, string, or vector");
  sub_809C43E(0x55u, -2, 0);
  sub_809D0A6(a1);
  return sub_809C43E(0x1Bu, -1, 0);
}

//----- (0809E312) --------------------------------------------------------
int __cdecl sub_809E312(int a1, int a2)
{
  _DWORD ***v3; // [esp+14h] [ebp-4h]

  v3 = (_DWORD ***)sub_809D06A(a1);
  if ( !v3 )
    sub_80A2D58(a2, "not an object");
  return sub_809EAAE(**v3, (int)(*v3)[1]);
}

//----- (0809E36C) --------------------------------------------------------
void __cdecl sub_809E36C(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 5:
      sub_809C69E(a1[1]);
      break;
    case 6:
      sub_809C6CE(a1[1]);
      break;
    case 7:
      sub_809C69E(-a1[1]);
      break;
    case 8:
      sub_809C6CE(a1[1] ^ 0x80000000);
      break;
    case 9:
      sub_809C856(*((_WORD *)a1 + 2));
      break;
    case 0xA:
      sub_809C8A2(*((_WORD *)a1 + 2));
      break;
    case 0xD:
      sub_809CF8A(a1[1]);
      break;
    case 0xE:
      sub_809D462(a1[1], a1[2]);
      break;
    case 0xF:
      sub_809E05E((_DWORD *)a1[1], 0);
      break;
    case 0x1B:
      sub_809C67A();
      break;
    case 0x1C:
      sub_809CA48();
      break;
    case 0x1D:
      sub_809CA6C();
      break;
    case 0x1E:
      sub_809CA90();
      break;
    case 0x1F:
      sub_809CAB4();
      break;
    case 0x2A:
      sub_809E204((_DWORD *)a1[1], a1[2]);
      break;
    case 0x34:
      sub_809CA0E(a1[1], a1[2]);
      break;
    case 0x40:
      sub_809CCA6();
      break;
    case 0x41:
      sub_809CCCA(a1[1], a1[2]);
      break;
    case 0x45:
      sub_809C6FE();
      break;
    case 0x46:
      sub_809C72E();
      break;
    case 0x47:
      sub_809C75E(a1[1]);
      break;
    default:
      return;
  }
}
// 809CF8A: using guessed type _DWORD __cdecl sub_809CF8A(_DWORD);

//----- (0809E51E) --------------------------------------------------------
int __cdecl sub_809E51E(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+10h] [ebp-8h]

  sub_809E6CE(a1);
  sub_809C43E(0x38u, -1, 0);
  sub_80A222E(a2);
  sub_809C51A(0);
  v5 = (int *)dword_81766C8;
  sub_809E6CE(a3);
  sub_809C8EE(a4);
  result = sub_80A4460(0) - (_DWORD)v5 - 4;
  *v5 = result;
  return result;
}
// 809E6CE: using guessed type _DWORD __cdecl sub_809E6CE(_DWORD);
// 81766C8: using guessed type int dword_81766C8;

//----- (0809E59E) --------------------------------------------------------
int __cdecl sub_809E59E(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+10h] [ebp-8h]

  sub_809E6CE(a1);
  sub_809C43E(0x37u, -1, 0);
  sub_80A222E(a2);
  sub_809C51A(0);
  v5 = (int *)dword_81766C8;
  sub_809E6CE(a3);
  sub_809C8EE(a4);
  result = sub_80A4460(0) - (_DWORD)v5 - 4;
  *v5 = result;
  return result;
}
// 809E6CE: using guessed type _DWORD __cdecl sub_809E6CE(_DWORD);
// 81766C8: using guessed type int dword_81766C8;

//----- (0809E61E) --------------------------------------------------------
void __cdecl sub_809E61E(int a1, int a2, unsigned __int8 a3, int a4)
{
  sub_809E6CE(a1);
  sub_809E6CE(a2);
  sub_809C43E(a3, -1, 0);
  sub_80A222E(a4);
}
// 809E6CE: using guessed type _DWORD __cdecl sub_809E6CE(_DWORD);

//----- (0809E664) --------------------------------------------------------
void __cdecl sub_809E664(int a1, _DWORD *a2, unsigned __int8 a3, int a4)
{
  byte_81766DC = 1;
  sub_809CF8A(a1);
  byte_81766DC = 0;
  sub_809E6CE(a2);
  sub_809C43E(a3, -1, 0);
  sub_80A222E(a4);
  sub_809E888(a1);
  sub_809C7AE(a4);
}
// 81766DC: using guessed type char byte_81766DC;

//----- (0809E6CE) --------------------------------------------------------
void __cdecl sub_809E6CE(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 4:
      sub_809E36C((_DWORD *)a1[1]);
      break;
    case 0x2B:
      sub_809E51E(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2C:
      sub_809E59E(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2D:
      sub_809E61E(a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x2E:
      sub_809E6CE(a1[1]);
      sub_809C8EE(a1[2]);
      break;
    case 0x2F:
      sub_809E6CE(a1[1]);
      sub_809C91E(a1[2]);
      break;
    case 0x30:
      sub_809E6CE(a1[1]);
      sub_809C94E(a1[2]);
      break;
    case 0x31:
      sub_809E6CE(a1[1]);
      sub_809C97E(a1[2]);
      break;
    case 0x32:
      sub_809E6CE(a1[1]);
      sub_809C9AE(a1[2]);
      break;
    case 0x33:
      sub_809E6CE(a1[1]);
      sub_809C9DE(a1[2]);
      break;
    default:
      return;
  }
}

//----- (0809E888) --------------------------------------------------------
void __cdecl sub_809E888(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 11 )
  {
    sub_809CF1A(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809CD7C(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  }
  else if ( v1 == 3 )
  {
    sub_809CB74(*(_DWORD *)(a1 + 4));
  }
}

//----- (0809E924) --------------------------------------------------------
int __cdecl sub_809E924(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 15 )
    return sub_809E0E4(*(int **)(a1 + 4));
  if ( v3 > 15 )
  {
    if ( v3 == 30 )
    {
      result = sub_809CBA4();
    }
    else
    {
      if ( v3 != 42 )
        goto LABEL_11;
      result = sub_809E26A(*(int **)(a1 + 4), a2);
    }
  }
  else
  {
    if ( v3 != 13 )
LABEL_11:
      sub_80A2D58(a2, "not an array, string, or vector");
    result = sub_809E888(*(_DWORD *)(a1 + 4));
  }
  return result;
}
// 809E888: using guessed type _DWORD __cdecl sub_809E888(_DWORD);

//----- (0809E9B8) --------------------------------------------------------
int __cdecl sub_809E9B8(_DWORD *a1, int a2)
{
  if ( *a1 != 4 )
    sub_80A2D58(a2, "not an array, string, or vector");
  return sub_809E924(a1[1], a1[2]);
}
// 809E924: using guessed type _DWORD __cdecl sub_809E924(_DWORD, _DWORD);

//----- (0809EA08) --------------------------------------------------------
void __cdecl sub_809EA08(_DWORD *a1, int a2)
{
  switch ( *a1 )
  {
    case 0xD:
      sub_809CF8A(a1[1]);
      sub_809CEBA(a1[2]);
      break;
    case 0xF:
      sub_809E160((_DWORD *)a1[1]);
      break;
    case 0x1C:
      sub_809CAD8();
      break;
    case 0x1D:
      sub_809CAFC();
      break;
    case 0x1F:
      sub_809CB20();
      break;
    case 0x2A:
      sub_809E312(a1[1], a2);
      break;
    default:
      sub_80A2D58(a2, "not an object");
  }
}
// 809CF8A: using guessed type _DWORD __cdecl sub_809CF8A(_DWORD);

//----- (0809EAAE) --------------------------------------------------------
int __cdecl sub_809EAAE(_DWORD *a1, int a2)
{
  if ( *a1 != 4 )
    sub_80A2D58(a2, "not an object");
  return sub_809EA08(a1[1], a1[2]);
}
// 809EA08: using guessed type _DWORD __cdecl sub_809EA08(_DWORD, _DWORD);

//----- (0809EAFE) --------------------------------------------------------
int sub_809EAFE()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  v2 = sub_80A4460(0);
  result = dword_80EE850;
  for ( i = dword_80EE850; i; i = result )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)i;
    result = *(_DWORD *)(i + 4);
  }
  return result;
}
// 80EE850: using guessed type int dword_80EE850;

//----- (0809EB42) --------------------------------------------------------
int sub_809EB42()
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]
  int v2; // [esp+14h] [ebp-4h]

  sub_809C4F6();
  v2 = sub_80A4460(0);
  result = dword_80EE858;
  for ( i = dword_80EE858; i; i = result )
  {
    **(_DWORD **)i = v2 - *(_DWORD *)i;
    result = *(_DWORD *)(i + 4);
  }
  return result;
}
// 80EE858: using guessed type int dword_80EE858;

//----- (0809EB8A) --------------------------------------------------------
_BOOL4 __cdecl sub_809EB8A(_DWORD *a1)
{
  return *a1 == 27;
}

//----- (0809EB9C) --------------------------------------------------------
_BOOL4 __cdecl sub_809EB9C(int a1)
{
  _BOOL4 v2; // [esp+4h] [ebp-4h]

  if ( *(_DWORD *)a1 == 4 )
    v2 = sub_809EB8A(*(_DWORD **)(a1 + 4));
  else
    v2 = 0;
  return v2;
}

//----- (0809EBCE) --------------------------------------------------------
void __cdecl sub_809EBCE(int a1)
{
  int v1; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 11 )
  {
    sub_809CF52(*(_DWORD *)(a1 + 4), *(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  }
  else if ( v1 > 11 )
  {
    if ( v1 == 12 )
      sub_809CDBE(*(_DWORD **)(a1 + 4), *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 16));
  }
  else if ( v1 == 3 )
  {
    sub_809CBC8(*(_DWORD *)(a1 + 4));
  }
}

//----- (0809EC7A) --------------------------------------------------------
void __cdecl sub_809EC7A(int a1, _DWORD *a2, int a3)
{
  if ( sub_809EB9C((int)a2) )
  {
    sub_809EBCE(a1);
  }
  else
  {
    sub_809E6CE(a2);
    sub_809E888(a1);
    sub_809C7AE(a3);
  }
}

//----- (0809ECC0) --------------------------------------------------------
_DWORD *__cdecl sub_809ECC0(_DWORD *a1)
{
  return sub_809E05E(a1, 1);
}

//----- (0809ECDC) --------------------------------------------------------
int __cdecl sub_809ECDC(_DWORD *a1)
{
  sub_809E6CE(a1);
  return sub_809C43E(1u, -1, 0);
}

//----- (0809ED0C) --------------------------------------------------------
int sub_809ED0C()
{
  return sub_809C43E(0, 0, 0);
}

//----- (0809ED30) --------------------------------------------------------
void __cdecl sub_809ED30(_DWORD *a1, int a2, int a3)
{
  if ( dword_81766E0 )
    sub_80A2D58(a3, "wait not allowed in /# ... #/ comment");
  sub_809E6CE(a1);
  sub_809C43E(0x23u, -1, 0);
  sub_80A222E(a3);
  sub_80A222E(a2);
}
// 81766E0: using guessed type int dword_81766E0;

//----- (0809ED92) --------------------------------------------------------
int __cdecl sub_809ED92(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int *v4; // [esp+10h] [ebp-8h]

  sub_809E6CE(a1);
  sub_809C43E(0x35u, -1, 0);
  sub_80A222E(a3);
  sub_809C51A(0);
  v4 = (int *)dword_81766C8;
  sub_809FD58(a2);
  sub_809C4F6();
  result = sub_80A4460(0) - (_DWORD)v4 - 4;
  *v4 = result;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 81766C8: using guessed type int dword_81766C8;

//----- (0809EE0C) --------------------------------------------------------
int __cdecl sub_809EE0C(_DWORD *a1, int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  sub_809E6CE(a1);
  sub_809C43E(0x35u, -1, 0);
  sub_80A222E(a4);
  sub_809C51A(0);
  v6 = (_DWORD *)dword_81766C8;
  sub_809FD58(a2);
  sub_809C43E(0x39u, 0, 0);
  sub_809C51A(0);
  v5 = (int *)dword_81766C8;
  *v6 = sub_80A4460(0) - (_DWORD)v6 - 4;
  sub_809FD58(a3);
  sub_809C4F6();
  result = sub_80A4460(0) - (_DWORD)v5;
  *v5 = result;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 81766C8: using guessed type int dword_81766C8;

//----- (0809EED6) --------------------------------------------------------
int __cdecl sub_809EED6(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // [esp+Ch] [ebp-1Ch]
  char v7; // [esp+12h] [ebp-16h]
  char v8; // [esp+13h] [ebp-15h]
  int v9; // [esp+14h] [ebp-14h]
  char v10; // [esp+1Ah] [ebp-Eh]
  char v11; // [esp+1Bh] [ebp-Dh]
  _DWORD *v12; // [esp+1Ch] [ebp-Ch]
  int v13; // [esp+20h] [ebp-8h]

  sub_809C4F6();
  v11 = byte_80EE84C;
  v10 = byte_80EE84D;
  v9 = dword_80EE850;
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  v8 = byte_80EE854;
  v7 = byte_80EE855;
  v6 = dword_80EE858;
  byte_80EE854 = 0;
  byte_80EE855 = 0;
  v13 = sub_80A4460(0);
  sub_809E6CE(a1);
  sub_809C43E(0x35u, -1, 0);
  sub_80A222E(a3);
  sub_809C51A(0);
  v12 = (_DWORD *)dword_81766C8;
  byte_80EE84C = 1;
  byte_80EE84D = dword_81766E0 != 0;
  dword_80EE850 = 0;
  byte_80EE854 = 1;
  byte_80EE855 = dword_81766E0 != 0;
  dword_80EE858 = 0;
  sub_809FD58(a2);
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  byte_80EE854 = 0;
  byte_80EE855 = 0;
  sub_809EB42();
  sub_809C43E(0x3Au, 0, 0);
  sub_80A222E(a4);
  v4 = sub_80A4460(0);
  sub_809C51A(v13 - v4);
  *v12 = sub_80A4460(0) - (_DWORD)v12 - 4;
  sub_809EAFE();
  byte_80EE84C = v11;
  byte_80EE84D = v10;
  dword_80EE850 = v9;
  byte_80EE854 = v8;
  byte_80EE855 = v7;
  result = v6;
  dword_80EE858 = v6;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 80EE84C: using guessed type char byte_80EE84C;
// 80EE84D: using guessed type char byte_80EE84D;
// 80EE850: using guessed type int dword_80EE850;
// 80EE854: using guessed type char byte_80EE854;
// 80EE855: using guessed type char byte_80EE855;
// 80EE858: using guessed type int dword_80EE858;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809F090) --------------------------------------------------------
int __cdecl sub_809F090(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // [esp+14h] [ebp-14h]
  char v7; // [esp+1Ah] [ebp-Eh]
  char v8; // [esp+1Bh] [ebp-Dh]
  int v9; // [esp+1Ch] [ebp-Ch]
  char v10; // [esp+22h] [ebp-6h]
  char v11; // [esp+23h] [ebp-5h]
  int v12; // [esp+24h] [ebp-4h]

  sub_809C4F6();
  v11 = byte_80EE84C;
  v10 = byte_80EE84D;
  v9 = dword_80EE850;
  v8 = byte_80EE854;
  v7 = byte_80EE855;
  v6 = dword_80EE858;
  byte_80EE84C = 1;
  byte_80EE84D = dword_81766E0 != 0;
  dword_80EE850 = 0;
  byte_80EE854 = 1;
  byte_80EE855 = dword_81766E0 != 0;
  dword_80EE858 = 0;
  v12 = sub_80A4460(0);
  sub_809FD58(a1);
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  byte_80EE854 = 0;
  byte_80EE855 = 0;
  sub_809EB42();
  sub_809E6CE(a2);
  sub_809C43E(0x36u, -1, 0);
  sub_80A222E(a4);
  sub_80A222E(a3);
  v4 = sub_80A4460(0);
  sub_809C51A(v12 - v4);
  sub_809EAFE();
  byte_80EE84C = v11;
  byte_80EE84D = v10;
  dword_80EE850 = v9;
  byte_80EE854 = v8;
  byte_80EE855 = v7;
  result = v6;
  dword_80EE858 = v6;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 80EE84C: using guessed type char byte_80EE84C;
// 80EE84D: using guessed type char byte_80EE84D;
// 80EE850: using guessed type int dword_80EE850;
// 80EE854: using guessed type char byte_80EE854;
// 80EE855: using guessed type char byte_80EE855;
// 80EE858: using guessed type int dword_80EE858;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809F1E2) --------------------------------------------------------
int __cdecl sub_809F1E2(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int result; // eax
  int v8; // [esp+Ch] [ebp-1Ch]
  char v9; // [esp+12h] [ebp-16h]
  char v10; // [esp+13h] [ebp-15h]
  int v11; // [esp+14h] [ebp-14h]
  char v12; // [esp+1Ah] [ebp-Eh]
  char v13; // [esp+1Bh] [ebp-Dh]
  _DWORD *v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]

  v13 = byte_80EE84C;
  v12 = byte_80EE84D;
  v11 = dword_80EE850;
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  v10 = byte_80EE854;
  v9 = byte_80EE855;
  v8 = dword_80EE858;
  byte_80EE854 = 0;
  byte_80EE855 = 0;
  sub_809FD58(a1);
  sub_809C4F6();
  v15 = sub_80A4460(0);
  if ( *(_DWORD *)a2 == 63 )
  {
    sub_809E6CE(*(_DWORD **)(a2 + 4));
    sub_809C43E(0x35u, -1, 0);
    sub_80A222E(a5);
    sub_809C51A(0);
    v14 = (_DWORD *)dword_81766C8;
  }
  else
  {
    v14 = 0;
  }
  byte_80EE84C = 1;
  byte_80EE84D = dword_81766E0 != 0;
  dword_80EE850 = 0;
  byte_80EE854 = 1;
  byte_80EE855 = dword_81766E0 != 0;
  dword_80EE858 = 0;
  sub_809FD58(a4);
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  byte_80EE854 = 0;
  byte_80EE855 = 0;
  sub_809EB42();
  sub_809FD58(a3);
  sub_809C43E(0x3Au, 0, 0);
  sub_80A222E(a6);
  v6 = sub_80A4460(0);
  sub_809C51A(v15 - v6);
  if ( v14 )
    *v14 = sub_80A4460(0) - (_DWORD)v14 - 4;
  sub_809EAFE();
  byte_80EE84C = v13;
  byte_80EE84D = v12;
  dword_80EE850 = v11;
  byte_80EE854 = v10;
  byte_80EE855 = v9;
  result = v8;
  dword_80EE858 = v8;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 80EE84C: using guessed type char byte_80EE84C;
// 80EE84D: using guessed type char byte_80EE84D;
// 80EE850: using guessed type int dword_80EE850;
// 80EE854: using guessed type char byte_80EE854;
// 80EE855: using guessed type char byte_80EE855;
// 80EE858: using guessed type int dword_80EE858;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809F3CE) --------------------------------------------------------
void __cdecl sub_809F3CE(int a1, int a2)
{
  sub_809E888(a1);
  sub_809C43E(0x3Bu, 1, 0);
  sub_80A222E(a2);
  sub_809C7AE(a2);
}

//----- (0809F414) --------------------------------------------------------
void __cdecl sub_809F414(int a1, int a2)
{
  sub_809E888(a1);
  sub_809C43E(0x3Cu, 1, 0);
  sub_80A222E(a2);
  sub_809C7AE(a2);
}

//----- (0809F45A) --------------------------------------------------------
int __cdecl sub_809F45A(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 4);
    a1 = result;
    if ( !result )
      break;
    sub_809C7DE(**(_DWORD **)result, *(_DWORD *)(*(_DWORD *)result + 4));
  }
  return result;
}

//----- (0809F496) --------------------------------------------------------
int __cdecl sub_809F496(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = *(_DWORD *)(a1 + 4);
    a1 = result;
    if ( !result )
      break;
    sub_809C81A(**(_DWORD **)result, *(_DWORD *)(*(_DWORD *)result + 4));
  }
  return result;
}

//----- (0809F4D2) --------------------------------------------------------
int __cdecl sub_809F4D2(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD ***v5; // [esp+14h] [ebp-4h]

  if ( dword_81766E0 )
    sub_80A2D58(a4, "waittill not allowed in developer script");
  v5 = *(_DWORD ****)(*(_DWORD *)a2 + 4);
  sub_809E6CE(**v5);
  sub_809E36C(a1);
  sub_809C43E(0x4Fu, -2, 0);
  sub_80A222E(a4);
  sub_80A222E((int)(*v5)[1]);
  sub_80A222E(a3);
  sub_809F496((int)v5);
  return sub_809C43E(0x1Eu, 0, 0);
}
// 81766E0: using guessed type int dword_81766E0;

//----- (0809F588) --------------------------------------------------------
int __cdecl sub_809F588(_DWORD *a1, int a2, int a3, int a4)
{
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]
  int v7; // [esp+14h] [ebp-4h]

  if ( dword_81766E0 )
    sub_80A2D58(a4, "waittillmatch not allowed in developer script");
  v6 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  for ( i = 0; ; ++i )
  {
    v6 = *(_DWORD *)(v6 + 4);
    if ( !v6 )
      break;
    sub_809E6CE(**(_DWORD ***)v6);
  }
  v7 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  sub_809E6CE(**(_DWORD ***)v7);
  sub_809E36C(a1);
  sub_809C43E(0x4Eu, -2 - i, 0);
  sub_80A222E(a4);
  sub_80A222E(*(_DWORD *)(*(_DWORD *)v7 + 4));
  sub_80A222E(a3);
  while ( 1 )
  {
    v7 = *(_DWORD *)(v7 + 4);
    if ( !v7 )
      break;
    sub_80A222E(*(_DWORD *)(*(_DWORD *)v7 + 4));
  }
  sub_809C56C(i);
  return sub_809C43E(0x1Eu, 0, 0);
}
// 81766E0: using guessed type int dword_81766E0;

//----- (0809F6A8) --------------------------------------------------------
void __cdecl sub_809F6A8(_DWORD *a1, int *a2, int a3, int a4)
{
  int v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  sub_809C43E(0x52u, 1, 0);
  v4 = 0;
  v6 = 0;
  for ( i = *a2; i; i = *(_DWORD *)(i + 4) )
  {
    v6 = i;
    sub_809E6CE(**(_DWORD ***)i);
    ++v4;
  }
  sub_809E36C(a1);
  sub_809C43E(0x50u, -v4 - 2, 0);
  sub_80A222E(a4);
  sub_80A222E(*(_DWORD *)(*(_DWORD *)v6 + 4));
  sub_80A222E(a3);
}

//----- (0809F764) --------------------------------------------------------
void __cdecl sub_809F764(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  sub_809E6CE(a2);
  sub_809E36C(a1);
  sub_809C43E(0x51u, -2, 0);
  sub_80A222E(a4);
  sub_80A222E(a3);
}

//----- (0809F7B4) --------------------------------------------------------
int __cdecl sub_809F7B4(const void *a1, const void *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  if ( *(_DWORD *)a1 <= *(_DWORD *)a2 )
    v3 = *(_DWORD *)a1 < *(_DWORD *)a2;
  else
    v3 = -1;
  return v3;
}

//----- (0809F7F0) --------------------------------------------------------
int __cdecl sub_809F7F0(_DWORD *a1, int a2, int a3)
{
  int result; // eax
  int nmemb; // [esp+18h] [ebp-20h]
  char *base; // [esp+1Ch] [ebp-1Ch]
  char *v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  char v8; // [esp+2Ah] [ebp-Eh]
  char v9; // [esp+2Bh] [ebp-Dh]
  int *v10; // [esp+2Ch] [ebp-Ch]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]
  char v13; // [esp+36h] [ebp-2h]
  char v14; // [esp+37h] [ebp-1h]

  v14 = byte_80EE85C;
  v13 = byte_80EE85D;
  v12 = dword_80EE860;
  byte_80EE85C = 0;
  byte_80EE85D = 0;
  v9 = byte_80EE84C;
  v8 = byte_80EE84D;
  v7 = dword_80EE850;
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  sub_809E6CE(a1);
  sub_809C43E(0x53u, -1, 0);
  sub_809C51A(0);
  v6 = (char *)dword_81766C8;
  byte_80EE85C = 1;
  byte_80EE85D = dword_81766E0 != 0;
  dword_80EE860 = 0;
  byte_80EE84C = 1;
  byte_80EE84D = dword_81766E0 != 0;
  dword_80EE850 = 0;
  sub_809FD58(a2);
  byte_80EE85C = 0;
  byte_80EE85D = 0;
  byte_80EE84C = 0;
  byte_80EE84D = 0;
  sub_809C43E(0x54u, 0, 0);
  sub_80A222E(a3);
  sub_809C53E(0);
  base = (char *)sub_80A4460(0);
  *(_DWORD *)v6 = base - v6;
  nmemb = 0;
  v10 = (int *)dword_80EE860;
  while ( v10 )
  {
    sub_809C51A(*v10);
    sub_809C60E(v10[1]);
    v10 = (int *)v10[3];
    ++nmemb;
  }
  *((_WORD *)base - 1) = nmemb;
  qsort(base, nmemb, 8u, sub_809F7B4);
  while ( nmemb > 1 )
  {
    if ( *(_DWORD *)base == *((_DWORD *)base + 2) )
    {
      for ( i = (_DWORD *)dword_80EE860; i; i = (_DWORD *)i[3] )
      {
        if ( *i == *(_DWORD *)base )
          sub_80A2D58(i[2], "duplicate case expression");
      }
    }
    --nmemb;
    base += 8;
  }
  sub_809EAFE();
  byte_80EE85C = v14;
  byte_80EE85D = v13;
  dword_80EE860 = v12;
  byte_80EE84C = v9;
  byte_80EE84D = v8;
  result = v7;
  dword_80EE850 = v7;
  return result;
}
// 809FD58: using guessed type _DWORD __cdecl sub_809FD58(_DWORD);
// 80EE84C: using guessed type char byte_80EE84C;
// 80EE84D: using guessed type char byte_80EE84D;
// 80EE850: using guessed type int dword_80EE850;
// 80EE85C: using guessed type char byte_80EE85C;
// 80EE85D: using guessed type char byte_80EE85D;
// 80EE860: using guessed type int dword_80EE860;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809FA48) --------------------------------------------------------
void __cdecl sub_809FA48(int a1, int a2)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  if ( dword_81766E0 != 2 )
  {
    v2 = (_DWORD *)sub_806C565(16);
    *v2 = a1;
    v2[1] = sub_80A4460(0);
    if ( dword_81766E0 == 1 )
      v2[1] += (_BYTE *)dword_81766EC - (_BYTE *)dword_81766E8;
    v2[2] = a2;
    v2[3] = dword_80EE860;
    dword_80EE860 = (int)v2;
  }
}
// 80EE860: using guessed type int dword_80EE860;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809FAC8) --------------------------------------------------------
void __cdecl sub_809FAC8(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // [esp+14h] [ebp-4h]

  if ( *a1 == 5 )
  {
    if ( !sub_80A5DFA(a1[1]) )
    {
      v2 = va("case index %d out of range", a1[1]);
      sub_80A2D58(a2, v2);
    }
    v3 = sub_80A5E20(a1[1]);
  }
  else
  {
    if ( *a1 != 9 )
      sub_80A2D58(a2, "case expression must be an int or string");
    v3 = *((unsigned __int16 *)a1 + 2);
    sub_809C3E8(*((_WORD *)a1 + 2), 1u);
  }
  if ( !byte_80EE85C )
    sub_80A2D58(a2, "illegal case statement");
  if ( !byte_80EE85D && dword_81766E0 )
    sub_80A2D58(a2, "cannot use /# ... #/ comments directly around a case statement");
  sub_809FA48(v3, a2);
}
// 80EE85C: using guessed type char byte_80EE85C;
// 80EE85D: using guessed type char byte_80EE85D;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809FBDA) --------------------------------------------------------
void __cdecl sub_809FBDA(int a1)
{
  if ( !byte_80EE85C )
    sub_80A2D58(a1, "illegal default statement");
  sub_809FA48(0, a1);
}
// 80EE85C: using guessed type char byte_80EE85C;

//----- (0809FC14) --------------------------------------------------------
_DWORD *__cdecl sub_809FC14(int a1)
{
  _DWORD *result; // eax

  if ( !byte_80EE84C )
    sub_80A2D58(a1, "illegal break statement");
  if ( !byte_80EE84D && dword_81766E0 )
    sub_80A2D58(a1, "cannot use /# ... #/ comments directly around a break statement");
  sub_809C43E(0x39u, 0, 0);
  sub_809C51A(0);
  result = (_DWORD *)sub_806C565(8);
  *result = dword_81766C8;
  result[1] = dword_80EE850;
  dword_80EE850 = (int)result;
  return result;
}
// 80EE84C: using guessed type char byte_80EE84C;
// 80EE84D: using guessed type char byte_80EE84D;
// 80EE850: using guessed type int dword_80EE850;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809FCB6) --------------------------------------------------------
_DWORD *__cdecl sub_809FCB6(int a1)
{
  _DWORD *result; // eax

  if ( !byte_80EE854 )
    sub_80A2D58(a1, "illegal continue statement");
  if ( !byte_80EE855 && dword_81766E0 )
    sub_80A2D58(a1, "cannot use /# ... #/ comments directly around a continue statement");
  sub_809C43E(0x39u, 0, 0);
  sub_809C51A(0);
  result = (_DWORD *)sub_806C565(8);
  *result = dword_81766C8;
  result[1] = dword_80EE858;
  dword_80EE858 = (int)result;
  return result;
}
// 80EE854: using guessed type char byte_80EE854;
// 80EE855: using guessed type char byte_80EE855;
// 80EE858: using guessed type int dword_80EE858;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;

//----- (0809FD58) --------------------------------------------------------
void __cdecl sub_809FD58(_DWORD *a1)
{
  switch ( *a1 )
  {
    case 2:
      sub_809EC7A(a1[1], (_DWORD *)a1[2], a1[3]);
      break;
    case 0x15:
      sub_809ECC0((_DWORD *)a1[1]);
      break;
    case 0x17:
      sub_809ECDC((_DWORD *)a1[1]);
      break;
    case 0x18:
      sub_809ED0C();
      break;
    case 0x19:
      sub_809ED30((_DWORD *)a1[1], a1[2], a1[3]);
      break;
    case 0x20:
      sub_809ED92((_DWORD *)a1[1], a1[2], a1[3]);
      break;
    case 0x21:
      sub_809EE0C((_DWORD *)a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x22:
      sub_809EED6((_DWORD *)a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x23:
      sub_809F090(a1[1], (_DWORD *)a1[2], a1[3], a1[4]);
      break;
    case 0x24:
      sub_809F1E2(a1[1], a1[2], a1[3], a1[4], a1[5], a1[6]);
      break;
    case 0x25:
      sub_809F3CE(a1[1], a1[2]);
      break;
    case 0x26:
      sub_809F414(a1[1], a1[2]);
      break;
    case 0x27:
      sub_809E664(a1[1], (_DWORD *)a1[2], a1[3], a1[4]);
      break;
    case 0x28:
      sub_80A0148(a1[1]);
      break;
    case 0x29:
      sub_80A0306(a1[1], a1[2]);
      break;
    case 0x36:
      sub_809F4D2((_DWORD *)a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x37:
      sub_809F588((_DWORD *)a1[1], a1[2], a1[3], a1[4]);
      break;
    case 0x38:
      sub_809F6A8((_DWORD *)a1[1], (int *)a1[2], a1[3], a1[4]);
      break;
    case 0x39:
      sub_809F764((_DWORD *)a1[1], (_DWORD *)a1[2], a1[3], a1[4]);
      break;
    case 0x3A:
      sub_809F7F0((_DWORD *)a1[1], a1[2], a1[3]);
      break;
    case 0x3B:
      sub_809FAC8((_DWORD *)a1[1], a1[2]);
      break;
    case 0x3C:
      sub_809FBDA(a1[1]);
      break;
    case 0x3D:
      sub_809FC14(a1[1]);
      break;
    case 0x3E:
      sub_809FCB6(a1[1]);
      break;
    default:
      return;
  }
}
// 80A0148: using guessed type _DWORD __cdecl sub_80A0148(_DWORD);

//----- (080A0148) --------------------------------------------------------
int __cdecl sub_80A0148(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = result; i; i = result )
  {
    sub_809FD58(*(_DWORD **)i);
    result = *(_DWORD *)(i + 4);
  }
  return result;
}

//----- (080A0180) --------------------------------------------------------
int sub_80A0180()
{
  int result; // eax
  int n; // [esp+14h] [ebp-4h]

  n = sub_80A4460(0) - (_DWORD)dword_81766E8;
  if ( n + (_BYTE *)dword_81766EC - (_BYTE *)dword_80EE83C > 0x100000 )
    Com_Error(1, "max developer script size exceeded - increase DEV_OP_BUF_SIZE");
  sub_80D2FC8(dword_81766EC, dword_81766E8, n);
  result = n;
  dword_81766EC = (char *)dword_81766EC + n;
  return result;
}

//----- (080A01F4) --------------------------------------------------------
int sub_80A01F4()
{
  int v1; // [esp+18h] [ebp-10h]
  int v2; // [esp+1Ch] [ebp-Ch]
  char *dest; // [esp+20h] [ebp-8h]
  int v4; // [esp+24h] [ebp-4h]

  v2 = dword_80EE8A4;
  sub_809C43E(88, 0, 0);
  dword_80EE8A4 = v2;
  v4 = (int)dword_81766E8 - dword_80EE864;
  if ( (int)dword_81766E8 - dword_80EE864 >= dword_80EE840 )
  {
    v1 = 2 * dword_80EE840;
    if ( 2 * dword_80EE840 <= v4 )
      v1 = 2 * v4;
    dest = (char *)Z_MallocInternal(4 * v1);
    sub_80D2FC8(dest, dword_80EE844, 4 * dword_80EE840);
    sub_80D2FE9(&dest[4 * dword_80EE840], 0, 4 * (v1 - dword_80EE840));
    dword_80EE840 = v1;
    Z_FreeInternal(dword_80EE844);
    dword_80EE844 = dest;
  }
  *((_DWORD *)dword_80EE844 + v4) = dword_81766EC;
  sub_80A0180();
  return sub_80A4494((int)dword_81766E8);
}
// 809C43E: using guessed type _DWORD __cdecl sub_809C43E(_DWORD, _DWORD, _DWORD);
// 80EE840: using guessed type int dword_80EE840;
// 80EE864: using guessed type int dword_80EE864;
// 80EE8A4: using guessed type int dword_80EE8A4;

//----- (080A0306) --------------------------------------------------------
int __cdecl sub_80A0306(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( dword_81766E0 )
    sub_80A2D58(a2, "cannot recurse /#");
  v4 = dword_80EE8A4;
  if ( dword_81768C4 )
  {
    if ( !byte_81766E4 )
    {
      sub_809C43E(0x57u, 0, 0);
      dword_81766E8 = (void *)dword_81766C8;
    }
    dword_81766E0 = 1;
    sub_80A0148(a1);
    byte_81766E4 = 1;
  }
  else
  {
    v3 = sub_80A4460(0);
    dword_81766E0 = 2;
    sub_80A0148(a1);
    sub_80A4494(v3);
  }
  dword_81766E0 = 0;
  result = v4;
  dword_80EE8A4 = v4;
  return result;
}
// 80A0148: using guessed type _DWORD __cdecl sub_80A0148(_DWORD);
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81766C8: using guessed type int dword_81766C8;
// 81766E0: using guessed type int dword_81766E0;
// 81766E4: using guessed type char byte_81766E4;
// 81768C4: using guessed type int dword_81768C4;

//----- (080A03CA) --------------------------------------------------------
void sub_80A03CA()
{
  if ( dword_81768C4 )
  {
    dword_80EE83C = Z_MallocInternal(0x100000u);
    dword_80EE840 = 0x10000;
    dword_80EE844 = Z_MallocInternal(0x40000u);
    sub_80D2FE9(dword_80EE844, 0, 0x40000u);
    dword_81766EC = dword_80EE83C;
    sub_80D2FE9(dword_830AD80, 0, 0x80u);
    dword_80EE848 = 0;
  }
}
// 80EE840: using guessed type int dword_80EE840;
// 81768C4: using guessed type int dword_81768C4;

//----- (080A0456) --------------------------------------------------------
void sub_80A0456()
{
  void *v0; // [esp+Ch] [ebp-Ch]
  _BYTE *v1; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_81768C4 )
  {
    for ( i = 0; i < dword_80EE840; ++i )
    {
      v1 = (_BYTE *)*((_DWORD *)dword_80EE844 + i);
      if ( v1 )
      {
        *v1 = *(_BYTE *)(dword_80EE864 + i);
        *(_BYTE *)(dword_80EE864 + i) = 87;
      }
    }
    while ( dword_80EE848 )
    {
      if ( **(_WORD **)dword_80EE848 )
        **(_WORD **)dword_80EE848 = sub_80A1158(**(_WORD **)dword_80EE848);
      v0 = (void *)*((_DWORD *)dword_80EE848 + 1);
      Z_FreeInternal(dword_80EE848);
      dword_80EE848 = v0;
    }
  }
}
// 80EE840: using guessed type int dword_80EE840;
// 80EE864: using guessed type int dword_80EE864;
// 81768C4: using guessed type int dword_81768C4;

//----- (080A051A) --------------------------------------------------------
int sub_80A051A()
{
  int result; // eax

  if ( dword_81768C4 )
  {
    if ( dword_80EE83C )
    {
      result = Z_FreeInternal(dword_80EE83C);
      dword_80EE83C = 0;
    }
    if ( dword_80EE844 )
    {
      result = Z_FreeInternal(dword_80EE844);
      dword_80EE844 = 0;
    }
  }
  return result;
}
// 81768C4: using guessed type int dword_81768C4;

//----- (080A056E) --------------------------------------------------------
void __cdecl sub_80A056E(int *a1, int a2)
{
  sub_809F45A(*a1);
  sub_809C43E(0x1Fu, 0, 0);
  sub_80A222E(a2);
}

//----- (080A05AA) --------------------------------------------------------
int __cdecl sub_80A05AA(int a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // ax

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 66 )
  {
    v2 = sub_80A61E0(word_81766CC, *(unsigned __int16 *)(a1 + 4));
    v3 = sub_80A6AD2(v2);
    result = sub_809DECC(v3, *(_DWORD *)(a1 + 16));
  }
  else if ( *(_DWORD *)a1 == 67 )
  {
    v4 = sub_80A61E0(word_81766CC, *(unsigned __int16 *)(a1 + 4));
    v5 = sub_80A6AD2(v4);
    result = sub_809DF42(v5, *(_DWORD *)(a1 + 16));
  }
  return result;
}
// 81766CC: using guessed type __int16 word_81766CC;

//----- (080A0646) --------------------------------------------------------
int __cdecl sub_80A0646(int a1, int a2)
{
  int result; // eax

  sub_80A222E(a2);
  dword_81766D0 = 0;
  dword_81766D4 = 0;
  dword_81766D8 = 0;
  sub_809C3E8(*(_WORD *)(a1 + 4), 2u);
  sub_80A056E(*(int **)(a1 + 8), a2);
  sub_80A0148(*(_DWORD *)(a1 + 12));
  sub_809C43E(0, 0, 0);
  result = dword_81766D4 + 32 * dword_81766D8;
  if ( result > 2047 )
    sub_80A2D58(a2, "function exceeds operand stack size");
  return result;
}
// 81766D0: using guessed type int dword_81766D0;
// 81766D4: using guessed type int dword_81766D4;
// 81766D8: using guessed type int dword_81766D8;

//----- (080A06FC) --------------------------------------------------------
int __cdecl sub_80A06FC(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax

  v2 = sub_80A5E90(word_81766CC, *(unsigned __int16 *)(a1 + 4));
  v3 = sub_80A6B8A(v2);
  sub_809DFC4(v3);
  return sub_80A0646(a1, a2);
}
// 81766CC: using guessed type __int16 word_81766CC;

//----- (080A0754) --------------------------------------------------------
int __cdecl sub_80A0754(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int result; // eax
  int v5; // [esp+14h] [ebp-4h]

  if ( dword_81766E0 )
    sub_80A2D58(a2, "cannot recurse /#");
  dword_81766E8 = (void *)sub_80A4460(0);
  v5 = dword_80EE8A4;
  if ( dword_81768C4 )
  {
    dword_81766E0 = 1;
    v2 = sub_80A5E90(word_81766CC, *(unsigned __int16 *)(a1 + 4));
    v3 = sub_80A6B8A(v2);
    sub_809E008(v3);
    sub_80A0646(a1, a2);
    sub_80A0180();
  }
  else
  {
    dword_81766E0 = 2;
    sub_80A0646(a1, a2);
  }
  dword_81766E0 = 0;
  sub_80A4494((int)dword_81766E8);
  result = v5;
  dword_80EE8A4 = v5;
  return result;
}
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81766CC: using guessed type __int16 word_81766CC;
// 81766E0: using guessed type int dword_81766E0;
// 81768C4: using guessed type int dword_81768C4;

//----- (080A0836) --------------------------------------------------------
int __cdecl sub_80A0836(int a1, int a2)
{
  int result; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-4h]

  result = *(_DWORD *)a1;
  v4 = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 == 67 )
    return sub_80A0754(a1, a2);
  if ( v4 > 67 )
  {
    if ( v4 == 68 )
    {
      v3 = (char *)SL_ConvertToString(*(_WORD *)(a1 + 4));
      sub_809BDF0(v3, *(_DWORD *)(a1 + 8));
      result = sub_809C300(*(unsigned __int16 *)(a1 + 4));
    }
  }
  else if ( v4 == 66 )
  {
    result = sub_80A06FC(a1, a2);
  }
  return result;
}

//----- (080A08C2) --------------------------------------------------------
int __cdecl sub_80A08C2(int a1)
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]
  int j; // [esp+14h] [ebp-4h]

  for ( i = *(_DWORD *)(*(_DWORD *)a1 + 4); i; i = *(_DWORD *)(i + 4) )
    sub_80A05AA(**(_DWORD **)i);
  result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( j = result; j; j = result )
  {
    sub_80A0836(**(_DWORD **)j, *(_DWORD *)(*(_DWORD *)j + 4));
    result = *(_DWORD *)(j + 4);
  }
  return result;
}

//----- (080A093A) --------------------------------------------------------
int __cdecl sub_80A093A(int a1, __int16 a2)
{
  void *v2; // esp
  int result; // eax
  int v4; // eax
  const char *v5; // eax
  int v6; // [esp+Ch] [ebp-1Ch] BYREF
  int *v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int *v10; // [esp+20h] [ebp-8h]
  __int16 v11; // [esp+26h] [ebp-2h]

  v11 = a2;
  word_81766CC = a2;
  dword_81766C8 = sub_80A4460(0);
  byte_81766DC = 0;
  dword_81760AC = 0;
  dword_81766E0 = 0;
  byte_81766E4 = 0;
  if ( dword_81768CC )
  {
    v2 = alloca(16 * ((unsigned int)(8 * dword_81768CC + 15) >> 4));
    v7 = &v6;
  }
  else
  {
    v7 = 0;
  }
  v10 = v7;
  dword_81766F0 = (int)v7;
  sub_809C43E(0, 0, 0);
  sub_80A08C2(*(_DWORD *)(a1 + 4));
  dword_80EE86C = sub_80A4460(0) - dword_80EE864;
  sub_809DD52();
  sub_806C69F();
  sub_806C5D0();
  v8 = dword_81768CC;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v4 = SL_ConvertToString(v10[2 * i]);
    if ( !sub_80A12A2(v4) )
    {
      v5 = (const char *)SL_ConvertToString(v10[2 * i]);
      sub_80A2D58(v10[2 * i + 1], "Could not find script '%s'", v5);
    }
    sub_80A40A6(v10[2 * i]);
  }
  return result;
}
// 80A12A2: using guessed type _DWORD __cdecl sub_80A12A2(_DWORD);
// 80EE864: using guessed type int dword_80EE864;
// 80EE86C: using guessed type int dword_80EE86C;
// 81760AC: using guessed type int dword_81760AC;
// 81766C8: using guessed type int dword_81766C8;
// 81766CC: using guessed type __int16 word_81766CC;
// 81766DC: using guessed type char byte_81766DC;
// 81766E0: using guessed type int dword_81766E0;
// 81766E4: using guessed type char byte_81766E4;
// 81766F0: using guessed type int dword_81766F0;
// 81768CC: using guessed type int dword_81768CC;

//----- (080A0AB4) --------------------------------------------------------
int __cdecl Scr_GetCustomFunction(int a1, int a2)
{
  return dword_8176898(a1, a2);
}
// 8176898: using guessed type int (__cdecl *dword_8176898)(_DWORD, _DWORD);

//----- (080A0AD0) --------------------------------------------------------
int __cdecl sub_80A0AD0(int a1, int a2)
{
  return dword_817689C(a1, a2);
}
// 817689C: using guessed type int (__cdecl *dword_817689C)(_DWORD, _DWORD);

//----- (080A0AEC) --------------------------------------------------------
int __cdecl sub_80A0AEC(int a1, int a2, int a3)
{
  return dword_81768A0(a1, a2, a3);
}
// 81768A0: using guessed type int (__cdecl *dword_81768A0)(_DWORD, _DWORD, _DWORD);

//----- (080A0B0F) --------------------------------------------------------
int __cdecl sub_80A0B0F(int a1, int a2, int a3)
{
  return dword_81768A4(a1, a2, a3);
}
// 81768A4: using guessed type int (__cdecl *dword_81768A4)(_DWORD, _DWORD, _DWORD);

//----- (080A0B32) --------------------------------------------------------
int __cdecl sub_80A0B32(int a1)
{
  return dword_81768A8(a1);
}
// 81768A8: using guessed type int (__cdecl *dword_81768A8)(_DWORD);

//----- (080A0B47) --------------------------------------------------------
int *__cdecl sub_80A0B47(int a1)
{
  if ( a1 )
  {
    dword_8176898 = *(int (__cdecl **)(_DWORD, _DWORD))a1;
    dword_817689C = *(int (__cdecl **)(_DWORD, _DWORD))(a1 + 4);
    dword_81768A0 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 8);
    dword_81768A4 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 12);
    dword_81768A8 = *(int (__cdecl **)(_DWORD))(a1 + 16);
  }
  dword_8176700 = (int)Scr_GetPointerType;
  dword_8176704 = (int)sub_80AE67C;
  dword_8176708 = (int)sub_80AE718;
  dword_817670C = (int)sub_80AE8D2;
  dword_8176710 = (int)sub_80AEA28;
  dword_8176714 = (int)sub_80AEB60;
  dword_8176718 = (int)sub_80AEAC2;
  dword_817671C = (int)sub_80AEBA4;
  dword_8176720 = (int)sub_80AEDC4;
  dword_8176724 = (int)sub_80AED26;
  dword_8176728 = (int)sub_80AEE08;
  dword_817672C = (int)sub_80AEEE2;
  dword_8176738 = (int)sub_80AEF8A;
  dword_8176730 = (int)sub_80AF086;
  dword_8176734 = (int)sub_80AF0F8;
  dword_817673C = (int)sub_80AF1AE;
  dword_8176740 = (int)sub_80AF1B8;
  dword_8176744 = (int)sub_80AF1DC;
  dword_8176748 = (int)sub_80AF200;
  dword_817674C = (int)sub_80AF224;
  dword_8176750 = (int)sub_80AF248;
  dword_8176754 = (int)sub_80AF29C;
  dword_8176758 = (int)sub_80AF2C2;
  dword_817675C = (int)sub_80AF2EC;
  dword_8176760 = (int)sub_80AF326;
  dword_8176764 = (int)sub_80AF360;
  dword_8176768 = (int)sub_80AF39A;
  dword_817676C = (int)sub_80AF262;
  dword_8176778 = (int)sub_80AF3CC;
  dword_8176770 = (int)sub_80AF3F8;
  dword_8176774 = (int)sub_80AF44E;
  dword_81767B4 = (int)Scr_Error;
  dword_81767B8 = (int)sub_80AF4D4;
  dword_81767BC = (int)sub_80AF556;
  dword_81767C0 = (int)sub_80AF592;
  dword_81767C4 = (int)sub_80AF66A;
  dword_81767C8 = (int)sub_80A6D38;
  dword_81767CC = (int)sub_80A70F0;
  dword_81767D0 = (int)sub_80A6E22;
  dword_81767D4 = (int)sub_80A6EAC;
  dword_81767E0 = (int)sub_80A6F06;
  dword_81767E4 = (int)sub_80A94A2;
  dword_81767E8 = (int)sub_80A91A2;
  dword_81767EC = (int)sub_80A7014;
  dword_81767F0 = (int)sub_80A7D62;
  dword_81767F4 = (int)sub_80A9820;
  dword_81767F8 = (int)sub_80A987A;
  dword_81767FC = (int)sub_80A9892;
  dword_8176800 = (int)sub_80A98A8;
  dword_8176804 = (int)sub_80AE3F8;
  dword_8176808 = (int)sub_80A9680;
  dword_817680C = (int)sub_80A9702;
  dword_8176810 = (int)sub_80A2548;
  dword_8176814 = (int)sub_80A2552;
  dword_8176818 = (int)sub_80A2612;
  dword_817681C = (int)sub_80A2714;
  dword_8176820 = (int)sub_80A8D0E;
  dword_8176824 = (int)sub_80A8EE8;
  dword_8176828 = (int)sub_80A8FC8;
  dword_8176830 = (int)sub_80A8FD6;
  dword_8176834 = (int)sub_80A914C;
  dword_817683C = (int)sub_80A12A2;
  dword_8176840 = (int)sub_809C1E6;
  dword_8176844 = (int)sub_809C298;
  dword_8176848 = (int)sub_80A103A;
  dword_81767A8 = (int)sub_80AE1A8;
  dword_81767AC = (int)sub_80AE226;
  dword_81767B0 = (int)sub_80A6C00;
  dword_817677C = (int)sub_80A11F4;
  dword_8176780 = (int)sub_80A125C;
  dword_8176784 = (int)sub_80A1436;
  dword_8176788 = (int)sub_80A14E6;
  dword_817678C = (int)sub_80A14AA;
  dword_8176790 = (int)sub_80A1552;
  dword_8176794 = (int)sub_80A96AE;
  dword_8176798 = (int)sub_80AE43A;
  dword_817679C = (int)sub_80AE58A;
  dword_81767A0 = (int)sub_80AE2B2;
  dword_81767A4 = (int)sub_80AE30C;
  dword_817684C = (int)sub_80AE374;
  dword_8176850 = (int)sub_80A8128;
  dword_8176854 = (int)sub_80A816A;
  dword_8176858 = (int)sub_80A415A;
  dword_817685C = (int)sub_80A419E;
  dword_8176860 = (int)sub_80ADB6C;
  dword_8176864 = (int)sub_80ADAA0;
  dword_8176868 = (int)SL_ConvertToString;
  dword_817686C = (int)sub_80A3DA2;
  dword_8176870 = (int)sub_80A3E88;
  dword_8176874 = (int)sub_80A3816;
  dword_8176878 = (int)sub_80A4404;
  dword_817687C = (int)sub_80AF6CE;
  dword_8176880 = (int)sub_80AF716;
  dword_8176884 = (int)sub_80AF724;
  dword_8176888 = (int)sub_809B812;
  dword_817688C = (int)sub_809B866;
  dword_8176890 = (int)sub_80A1F70;
  dword_8176894 = (int)sub_80A1F96;
  return &dword_8176700;
}
// 8176700: using guessed type int dword_8176700;
// 8176704: using guessed type int dword_8176704;
// 8176708: using guessed type int dword_8176708;
// 817670C: using guessed type int dword_817670C;
// 8176710: using guessed type int dword_8176710;
// 8176714: using guessed type int dword_8176714;
// 8176718: using guessed type int dword_8176718;
// 817671C: using guessed type int dword_817671C;
// 8176720: using guessed type int dword_8176720;
// 8176724: using guessed type int dword_8176724;
// 8176728: using guessed type int dword_8176728;
// 817672C: using guessed type int dword_817672C;
// 8176730: using guessed type int dword_8176730;
// 8176734: using guessed type int dword_8176734;
// 8176738: using guessed type int dword_8176738;
// 817673C: using guessed type int dword_817673C;
// 8176740: using guessed type int dword_8176740;
// 8176744: using guessed type int dword_8176744;
// 8176748: using guessed type int dword_8176748;
// 817674C: using guessed type int dword_817674C;
// 8176750: using guessed type int dword_8176750;
// 8176754: using guessed type int dword_8176754;
// 8176758: using guessed type int dword_8176758;
// 817675C: using guessed type int dword_817675C;
// 8176760: using guessed type int dword_8176760;
// 8176764: using guessed type int dword_8176764;
// 8176768: using guessed type int dword_8176768;
// 817676C: using guessed type int dword_817676C;
// 8176770: using guessed type int dword_8176770;
// 8176774: using guessed type int dword_8176774;
// 8176778: using guessed type int dword_8176778;
// 817677C: using guessed type int dword_817677C;
// 8176780: using guessed type int dword_8176780;
// 8176784: using guessed type int dword_8176784;
// 8176788: using guessed type int dword_8176788;
// 817678C: using guessed type int dword_817678C;
// 8176790: using guessed type int dword_8176790;
// 8176794: using guessed type int dword_8176794;
// 8176798: using guessed type int dword_8176798;
// 817679C: using guessed type int dword_817679C;
// 81767A0: using guessed type int dword_81767A0;
// 81767A4: using guessed type int dword_81767A4;
// 81767A8: using guessed type int dword_81767A8;
// 81767AC: using guessed type int dword_81767AC;
// 81767B0: using guessed type int dword_81767B0;
// 81767B4: using guessed type int dword_81767B4;
// 81767B8: using guessed type int dword_81767B8;
// 81767BC: using guessed type int dword_81767BC;
// 81767C0: using guessed type int dword_81767C0;
// 81767C4: using guessed type int dword_81767C4;
// 81767C8: using guessed type int dword_81767C8;
// 81767CC: using guessed type int dword_81767CC;
// 81767D0: using guessed type int dword_81767D0;
// 81767D4: using guessed type int dword_81767D4;
// 81767E0: using guessed type int dword_81767E0;
// 81767E4: using guessed type int dword_81767E4;
// 81767E8: using guessed type int dword_81767E8;
// 81767EC: using guessed type int dword_81767EC;
// 81767F0: using guessed type int dword_81767F0;
// 81767F4: using guessed type int dword_81767F4;
// 81767F8: using guessed type int dword_81767F8;
// 81767FC: using guessed type int dword_81767FC;
// 8176800: using guessed type int dword_8176800;
// 8176804: using guessed type int dword_8176804;
// 8176808: using guessed type int dword_8176808;
// 817680C: using guessed type int dword_817680C;
// 8176810: using guessed type int dword_8176810;
// 8176814: using guessed type int dword_8176814;
// 8176818: using guessed type int dword_8176818;
// 817681C: using guessed type int dword_817681C;
// 8176820: using guessed type int dword_8176820;
// 8176824: using guessed type int dword_8176824;
// 8176828: using guessed type int dword_8176828;
// 8176830: using guessed type int dword_8176830;
// 8176834: using guessed type int dword_8176834;
// 817683C: using guessed type int dword_817683C;
// 8176840: using guessed type int dword_8176840;
// 8176844: using guessed type int dword_8176844;
// 8176848: using guessed type int dword_8176848;
// 817684C: using guessed type int dword_817684C;
// 8176850: using guessed type int dword_8176850;
// 8176854: using guessed type int dword_8176854;
// 8176858: using guessed type int dword_8176858;
// 817685C: using guessed type int dword_817685C;
// 8176860: using guessed type int dword_8176860;
// 8176864: using guessed type int dword_8176864;
// 8176868: using guessed type int dword_8176868;
// 817686C: using guessed type int dword_817686C;
// 8176870: using guessed type int dword_8176870;
// 8176874: using guessed type int dword_8176874;
// 8176878: using guessed type int dword_8176878;
// 817687C: using guessed type int dword_817687C;
// 8176880: using guessed type int dword_8176880;
// 8176884: using guessed type int dword_8176884;
// 8176888: using guessed type int dword_8176888;
// 817688C: using guessed type int dword_817688C;
// 8176890: using guessed type int dword_8176890;
// 8176894: using guessed type int dword_8176894;
// 8176898: using guessed type int (__cdecl *dword_8176898)(_DWORD, _DWORD);
// 817689C: using guessed type int (__cdecl *dword_817689C)(_DWORD, _DWORD);
// 81768A0: using guessed type int (__cdecl *dword_81768A0)(_DWORD, _DWORD, _DWORD);
// 81768A4: using guessed type int (__cdecl *dword_81768A4)(_DWORD, _DWORD, _DWORD);
// 81768A8: using guessed type int (__cdecl *dword_81768A8)(_DWORD);

//----- (080A0F58) --------------------------------------------------------
int __cdecl sub_80A0F58(unsigned int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 >= dword_80EE864 && a1 < dword_80EE864 + dword_80EE86C )
    v2 = 1;
  return v2;
}
// 80EE864: using guessed type int dword_80EE864;
// 80EE86C: using guessed type int dword_80EE86C;

//----- (080A0F8C) --------------------------------------------------------
int __cdecl sub_80A0F8C(unsigned int a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 >= (unsigned int)dword_80EE83C && a1 < (unsigned int)dword_81766EC )
    v2 = 1;
  return v2;
}

//----- (080A0FEC) --------------------------------------------------------
int __cdecl sub_80A0FEC(_BYTE *a1)
{
  while ( *a1 )
  {
    if ( (*(_WORD *)(_ctype_b + 2 * (char)*a1) & 8) == 0 && *a1 != 95 )
      return 0;
    ++a1;
  }
  return 1;
}
// 80F6548: using guessed type int _ctype_b;

//----- (080A103A) --------------------------------------------------------
int __cdecl sub_80A103A(int a1, char *s)
{
  int v3; // [esp+10h] [ebp-18h]
  int v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  unsigned __int16 v9; // [esp+26h] [ebp-2h]

  v5 = sub_80A4404((char *)a1);
  v9 = sub_80A5E90(word_81768AE, v5);
  sub_80A40A6(v5);
  if ( !v9 )
    return 0;
  v7 = sub_80A6B8A(v9);
  v6 = sub_80A3816(s);
  if ( !v6 )
    return 0;
  v8 = sub_80A5E90(v7, v6);
  if ( !v8 )
    return 0;
  v4 = *GetVariableValueAddress(v8);
  if ( sub_80A0F58(v4) )
    v3 = v4 - dword_80EE864;
  else
    v3 = 0;
  return v3;
}
// 80EE864: using guessed type int dword_80EE864;
// 81768AE: using guessed type __int16 word_81768AE;

//----- (080A1122) --------------------------------------------------------
void *sub_80A1122()
{
  void *result; // eax

  sub_806C315();
  result = sub_806C482(0x20000u);
  dword_81768B8 = (int)result;
  word_81768BC = 0;
  return result;
}
// 81768B8: using guessed type int dword_81768B8;
// 81768BC: using guessed type __int16 word_81768BC;

//----- (080A114A) --------------------------------------------------------
_DWORD *sub_80A114A()
{
  return sub_806C35F();
}

//----- (080A1158) --------------------------------------------------------
int __cdecl sub_80A1158(unsigned __int16 a1)
{
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  sub_80A3EB4(a1, 2u);
  v3 = *(_WORD *)(dword_81768B8 + 2 * a1);
  if ( v3 )
    return v3;
  *(_WORD *)(dword_81768B8 + 2 * a1) = ++word_81768BC;
  return (unsigned __int16)word_81768BC;
}
// 81768B8: using guessed type int dword_81768B8;
// 81768BC: using guessed type __int16 word_81768BC;

//----- (080A11D2) --------------------------------------------------------
int __cdecl sub_80A11D2(char *s)
{
  return *(unsigned __int16 *)(dword_81768B8 + 2 * (unsigned __int16)sub_80A37F0(s));
}
// 81768B8: using guessed type int dword_81768B8;

//----- (080A11F4) --------------------------------------------------------
int sub_80A11F4()
{
  byte_81768AC = 1;
  sub_80A1FEC();
  sub_80A03CA();
  word_81768AE = sub_80A5AB4();
  word_81768B0 = sub_80A5AB4();
  dword_80EE864 = (int)sub_806C5DF(0);
  dword_80EE86C = 0;
  dword_80EE868 = 0;
  sub_80A1122();
  scrVarPub = 0;
  return sub_80A125C();
}
// 80EE864: using guessed type int dword_80EE864;
// 80EE868: using guessed type int dword_80EE868;
// 80EE86C: using guessed type int dword_80EE86C;
// 81768AC: using guessed type char byte_81768AC;
// 81768AE: using guessed type __int16 word_81768AE;
// 81768B0: using guessed type __int16 word_81768B0;
// 8306CB8: using guessed type int scrVarPub;

//----- (080A125C) --------------------------------------------------------
int sub_80A125C()
{
  int result; // eax

  byte_81768AD = 1;
  dword_81766C0[dword_832D040] = 0;
  dword_81760C0[128 * dword_832D040] = 0;
  result = sub_80A5AB4();
  word_81768B2 = result;
  word_81760A0 = 0;
  return result;
}
// 81760A0: using guessed type __int16 word_81760A0;
// 81766C0: using guessed type int dword_81766C0[];
// 81768AD: using guessed type char byte_81768AD;
// 81768B2: using guessed type __int16 word_81768B2;
// 832D040: using guessed type int dword_832D040;

//----- (080A12A2) --------------------------------------------------------
_BOOL4 __cdecl sub_80A12A2(char *a1)
{
  const char *v1; // eax
  void *v2; // eax
  unsigned __int16 v3; // ax
  __int16 v4; // ax
  _BOOL4 v6; // [esp+14h] [ebp-64h]
  int v7; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  char dest[70]; // [esp+20h] [ebp-58h] BYREF
  unsigned __int16 v10; // [esp+66h] [ebp-12h]
  int v11; // [esp+68h] [ebp-10h] BYREF
  char *v12; // [esp+6Ch] [ebp-Ch]

  v10 = sub_80A4404(a1);
  if ( (unsigned __int16)sub_80A5E90(word_81768B0, v10) )
  {
    sub_80A40A6(v10);
    v6 = (unsigned __int16)sub_80A5E90(word_81768AE, v10) != 0;
  }
  else
  {
    sub_80A61E0(word_81768B0, v10);
    sub_80A40A6(v10);
    sub_80A4450();
    v1 = (const char *)SL_ConvertToString(v10);
    strncpy(dest, v1, 0x40u);
    strncat(dest, ".gsc", 0x40u);
    v7 = *(_DWORD *)dword_80EE874;
    v2 = sub_806C5DF(0);
    v12 = sub_80A280E(dest, (int)v2, (int)dword_81766EC);
    if ( v12 )
    {
      word_81768B4 = 0;
      dword_81768CC = 0;
      v8 = *(_DWORD *)dword_80EE878;
      *(_DWORD *)dword_80EE878 = dest;
      sub_80B17FE((int)v12, &v11);
      v3 = sub_80A61E0(word_81768AE, v10);
      v4 = sub_80A6AD2(v3);
      sub_80A093A(v11, v4);
      *(_DWORD *)dword_80EE878 = v8;
      *(_DWORD *)dword_80EE874 = v7;
      v6 = 1;
    }
    else
    {
      v6 = 0;
    }
  }
  return v6;
}
// 81768AE: using guessed type __int16 word_81768AE;
// 81768B0: using guessed type __int16 word_81768B0;
// 81768B4: using guessed type __int16 word_81768B4;
// 81768CC: using guessed type int dword_81768CC;

//----- (080A1436) --------------------------------------------------------
unsigned int *sub_80A1436()
{
  byte_81768AC = 0;
  sub_80A114A();
  sub_80A54B8(word_81768B0);
  sub_80A5C0A(word_81768B0);
  word_81768B0 = 0;
  sub_80A54B8(word_81768AE);
  sub_80A5C0A(word_81768AE);
  word_81768AE = 0;
  sub_80A0456();
  return sub_80A42B4((unsigned int *)2);
}
// 81768AC: using guessed type char byte_81768AC;
// 81768AE: using guessed type __int16 word_81768AE;
// 81768B0: using guessed type __int16 word_81768B0;

//----- (080A14AA) --------------------------------------------------------
int __cdecl sub_80A14AA(int (__cdecl *a1)(int))
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_81766C0[dword_832D040] )
      break;
    sub_809BF04(i, a1);
  }
  return result;
}
// 81766C0: using guessed type int dword_81766C0[];
// 832D040: using guessed type int dword_832D040;

//----- (080A14E6) --------------------------------------------------------
void *sub_80A14E6()
{
  void *result; // eax

  byte_81768AD = 0;
  sub_80A54B8(word_81768B2);
  sub_80A5C0A(word_81768B2);
  word_81768B2 = 0;
  if ( word_81760A0 )
    sub_80A5C0A(word_81760A0);
  sub_80A42B4((unsigned int *)2);
  result = sub_806C5DF(0);
  dword_80EE868 = (int)result;
  return result;
}
// 80EE868: using guessed type int dword_80EE868;
// 81760A0: using guessed type __int16 word_81760A0;
// 81768AD: using guessed type char byte_81768AD;
// 81768B2: using guessed type __int16 word_81768B2;

//----- (080A1552) --------------------------------------------------------
int sub_80A1552()
{
  if ( byte_81768AC )
    sub_80A1436();
  if ( byte_81768AD )
    sub_80A14E6();
  dword_80EE864 = 0;
  dword_80EE86C = 0;
  dword_80EE868 = 0;
  dword_80EE8A4 = 0;
  byte_81768AC = 0;
  sub_80A42B4((unsigned int *)1);
  sub_80A20F2();
  return sub_80A051A();
}
// 80EE864: using guessed type int dword_80EE864;
// 80EE868: using guessed type int dword_80EE868;
// 80EE86C: using guessed type int dword_80EE86C;
// 80EE8A4: using guessed type int dword_80EE8A4;
// 81768AC: using guessed type char byte_81768AC;
// 81768AD: using guessed type char byte_81768AD;

//----- (080A15C4) --------------------------------------------------------
int __cdecl sub_80A15C4(int a1)
{
  int v1; // ebx

  if ( !a1 )
    return 0;
  v1 = sub_80A15C4(LOWORD(dword_81768E0[2 * a1]));
  return sub_80A15C4(HIWORD(dword_81768E0[2 * a1])) + v1 + 1;
}
// 81768E0: using guessed type int dword_81768E0[];

//----- (080A161C) --------------------------------------------------------
int sub_80A161C()
{
  char v1; // [esp+4h] [ebp-24h]
  char v2; // [esp+4h] [ebp-24h]
  char v3; // [esp+4h] [ebp-24h]
  char v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+18h] [ebp-10h]
  int i; // [esp+24h] [ebp-4h]

  Com_Printf("********************************\n", v1);
  v5 = *(_DWORD *)dword_81F6C44;
  for ( i = 0; i <= 16; ++i )
  {
    v5 += sub_80A15C4((unsigned __int16)word_81F6900[i]) << i;
    Com_Printf("%d subtree has %d * %d = %d free buckets\n", i);
  }
  Com_Printf("********************************\n", v2);
  Com_Printf("********************************\n", v3);
  Com_Printf("total memory alloc buckets: %d (%d instances)\n", dword_81F6C44[0]);
  Com_Printf("total memory free buckets: %d\n", -1 - dword_81F6C44[0]);
  return Com_Printf("********************************\n", v4);
}
// 80A1629: variable 'v1' is possibly undefined
// 80A16AD: variable 'v2' is possibly undefined
// 80A16B9: variable 'v3' is possibly undefined
// 80A16FE: variable 'v4' is possibly undefined

//----- (080A1710) --------------------------------------------------------
int *sub_80A1710()
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int l; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char k; // [esp+4h] [ebp-8h]
  char v5; // [esp+4h] [ebp-8h]
  int i; // [esp+8h] [ebp-4h] BYREF

  for ( i = 0; i <= 255; ++i )
  {
    v3 = 0;
    for ( j = i; j; j >>= 1 )
    {
      if ( (j & 1) != 0 )
        ++v3;
    }
    *(_BYTE *)(i + 136276544) = v3;
    for ( k = 8; (i & ((1 << k) - 1)) != 0; --k )
      ;
    *(_BYTE *)(i + 136276288) = k;
    v5 = 0;
    for ( l = i; l; l >>= 1 )
      ++v5;
    *(_BYTE *)(i + 136276800) = v5;
    result = &i;
  }
  return result;
}

//----- (080A17D2) --------------------------------------------------------
int __cdecl sub_80A17D2(int a1)
{
  char v2; // [esp+8h] [ebp-8h]
  int v3; // [esp+18h] [ebp+8h]

  v3 = 0x10000 - a1;
  v2 = byte_81F6940[(unsigned __int8)v3];
  if ( !(_BYTE)v3 )
    v2 += byte_81F6940[BYTE1(v3)];
  return v3
       - ((unsigned __int8)byte_81F6940[BYTE1(v3) + 256]
        + (unsigned __int8)byte_81F6940[(unsigned __int8)v3 + 256])
       + (1 << v2);
}

//----- (080A1846) --------------------------------------------------------
int __cdecl sub_80A1846(int a1, int a2)
{
  int v2; // edx
  int result; // eax
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]

  v7 = (int *)&word_81F6900[a2];
  v8 = *(unsigned __int16 *)v7;
  if ( *(_WORD *)v7 )
  {
    v6 = sub_80A17D2(a1);
    v5 = 0;
    v4 = 0x10000;
    while ( sub_80A17D2(v8) >= v6 )
    {
      v4 >>= 1;
      if ( a1 >= v5 )
      {
        v7 = (int *)(8 * v8 + 135751906);
        v5 += v4;
      }
      else
      {
        v7 = &dword_81768E0[2 * v8];
        v5 -= v4;
      }
      v8 = *(unsigned __int16 *)v7;
      if ( !*(_WORD *)v7 )
        goto LABEL_13;
    }
    while ( 1 )
    {
      *(_WORD *)v7 = a1;
      v2 = dword_81768E4[2 * v8];
      result = dword_81768E0[2 * v8];
      dword_81768E0[2 * a1] = result;
      dword_81768E4[2 * a1] = v2;
      if ( !v8 )
        break;
      v4 >>= 1;
      if ( v8 >= v5 )
      {
        v7 = (int *)(8 * a1 + 135751906);
        v5 += v4;
      }
      else
      {
        v7 = &dword_81768E0[2 * a1];
        v5 -= v4;
      }
      a1 = v8;
      v8 = *(unsigned __int16 *)v7;
    }
  }
  else
  {
LABEL_13:
    *(_WORD *)v7 = a1;
    LOWORD(dword_81768E0[2 * a1]) = 0;
    result = a1;
    HIWORD(dword_81768E0[2 * a1]) = 0;
  }
  return result;
}
// 81768E0: using guessed type int dword_81768E0[];

//----- (080A19AA) --------------------------------------------------------
int __cdecl sub_80A19AA(int a1, int a2)
{
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int *v11; // [esp+30h] [ebp-8h]
  int i; // [esp+34h] [ebp-4h]
  int v13; // [esp+40h] [ebp+8h]

  v9 = 0;
  v8 = 0x10000;
  v11 = (int *)&word_81F6900[a2];
  for ( i = *(unsigned __int16 *)v11; ; i = *(unsigned __int16 *)v11 )
  {
    if ( !i )
      return 0;
    if ( a1 == i )
      break;
    if ( a1 == v9 )
      return 0;
    v8 >>= 1;
    if ( a1 >= v9 )
    {
      v11 = (int *)(8 * i + 135751906);
      v9 += v8;
    }
    else
    {
      v11 = &dword_81768E0[2 * i];
      v9 -= v8;
    }
  }
  v6 = dword_81768E0[2 * a1];
  v7 = dword_81768E4[2 * a1];
  while ( (_WORD)v6 )
  {
    if ( HIWORD(v6) )
    {
      v10 = sub_80A17D2((unsigned __int16)v6);
      if ( v10 >= sub_80A17D2(HIWORD(v6)) )
      {
        v13 = (unsigned __int16)v6;
        *(_WORD *)v11 = v6;
        v11 = &dword_81768E0[2 * (unsigned __int16)v6];
      }
      else
      {
        v13 = HIWORD(v6);
        *(_WORD *)v11 = HIWORD(v6);
        v11 = (int *)(8 * HIWORD(v6) + 135751906);
      }
    }
    else
    {
      v13 = (unsigned __int16)v6;
      *(_WORD *)v11 = v6;
      v11 = &dword_81768E0[2 * (unsigned __int16)v6];
    }
LABEL_14:
    v4 = v6;
    v5 = v7;
    v6 = dword_81768E0[2 * v13];
    v7 = dword_81768E4[2 * v13];
    dword_81768E0[2 * v13] = v4;
    dword_81768E4[2 * v13] = v5;
  }
  v13 = HIWORD(v6);
  *(_WORD *)v11 = HIWORD(v6);
  if ( HIWORD(v6) )
  {
    v11 = (int *)(8 * HIWORD(v6) + 135751906);
    goto LABEL_14;
  }
  return 1;
}
// 81768E0: using guessed type int dword_81768E0[];

//----- (080A1B84) --------------------------------------------------------
int __cdecl sub_80A1B84(int a1)
{
  int result; // eax
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 *v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+24h] [ebp-4h]

  v7 = &word_81F6900[a1];
  v8 = (unsigned __int16)*v7;
  v4 = dword_81768E0[2 * v8];
  v5 = dword_81768E4[2 * v8];
  while ( (_WORD)v4 )
  {
    if ( HIWORD(v4) )
    {
      v6 = sub_80A17D2((unsigned __int16)v4);
      if ( v6 >= sub_80A17D2(HIWORD(v4)) )
      {
        v9 = (unsigned __int16)v4;
        *v7 = v4;
        v7 = (__int16 *)&dword_81768E0[2 * (unsigned __int16)v4];
      }
      else
      {
        v9 = HIWORD(v4);
        *v7 = HIWORD(v4);
        v7 = (__int16 *)(8 * HIWORD(v4) + 135751906);
      }
    }
    else
    {
      v9 = (unsigned __int16)v4;
      *v7 = v4;
      v7 = (__int16 *)&dword_81768E0[2 * (unsigned __int16)v4];
    }
LABEL_10:
    v2 = v4;
    v3 = v5;
    v4 = dword_81768E0[2 * v9];
    v5 = dword_81768E4[2 * v9];
    dword_81768E0[2 * v9] = v2;
    dword_81768E4[2 * v9] = v3;
  }
  v9 = HIWORD(v4);
  result = HIWORD(v4);
  *v7 = HIWORD(v4);
  if ( HIWORD(v4) )
  {
    v7 = (__int16 *)(8 * HIWORD(v4) + 135751906);
    goto LABEL_10;
  }
  return result;
}
// 81768E0: using guessed type int dword_81768E0[];

//----- (080A1CCC) --------------------------------------------------------
int *sub_80A1CCC()
{
  int *result; // eax
  int i; // [esp+14h] [ebp-4h] BYREF

  dword_81F68E0 = (int)dword_81768E0;
  sub_80A1710();
  for ( i = 0; i <= 16; ++i )
    word_81F6900[i] = 0;
  dword_81768E0[0] = 0;
  dword_81F68E4 = (int)&dword_81F68E0;
  result = &dword_81F68E0;
  dword_81F68E8 = (int)&dword_81F68E0;
  dword_81F68EC = 0;
  for ( i = 0; i <= 15; ++i )
  {
    sub_80A1846(1 << i, i);
    result = &i;
  }
  dword_81F6C40 = 0;
  *(_DWORD *)dword_81F6C44 = 0;
  return result;
}
// 81768E0: using guessed type int dword_81768E0[];
// 81F68E0: using guessed type int dword_81F68E0;
// 81F68E4: using guessed type int dword_81F68E4;
// 81F68E8: using guessed type int dword_81F68E8;
// 81F68EC: using guessed type int dword_81F68EC;
// 81F6C40: using guessed type int dword_81F6C40;

//----- (080A1D7A) --------------------------------------------------------
int __cdecl sub_80A1D7A(const char *a1, int a2)
{
  char *v2; // eax

  sub_80A161C();
  v2 = va("%s: failed allocation of %d bytes for script usage", a1, a2);
  return sub_80AF512((int)v2);
}

//----- (080A1DAA) --------------------------------------------------------
int __cdecl sub_80A1DAA(int a1)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  if ( a1 > 0xFFFF )
  {
    sub_80A1D7A("MT_GetSize: max allocation exceeded", a1);
    v3 = 0;
  }
  else
  {
    v4 = (a1 + 7) / 8 - 1;
    if ( v4 > 255 )
      v2 = (unsigned __int8)byte_81F6B40[v4 >> 8] + 8;
    else
      v2 = (unsigned __int8)byte_81F6B40[(a1 + 7) / 8 - 1];
    v3 = v2;
  }
  return v3;
}

//----- (080A1E2A) --------------------------------------------------------
int __cdecl sub_80A1E2A(int a1)
{
  int i; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]
  int v5; // [esp+14h] [ebp-4h]

  v4 = sub_80A1DAA(a1);
  for ( i = v4; ; ++i )
  {
    if ( i > 16 )
    {
      sub_80A1D7A("MT_AllocIndex", a1);
      return 0;
    }
    v5 = (unsigned __int16)word_81F6900[i];
    if ( word_81F6900[i] )
      break;
  }
  sub_80A1B84(i);
  while ( i != v4 )
  {
    --i;
    sub_80A1846(v5 + (1 << i), i);
  }
  ++dword_81F6C40;
  *(_DWORD *)dword_81F6C44 += 1 << v4;
  return (unsigned __int16)v5;
}
// 81F6C40: using guessed type int dword_81F6C40;

//----- (080A1EE2) --------------------------------------------------------
int __cdecl sub_80A1EE2(unsigned __int16 a1, int a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v3 = sub_80A1DAA(a2);
  --dword_81F6C40;
  *(_DWORD *)dword_81F6C44 -= 1 << v3;
  while ( 1 )
  {
    v4 = 1 << v3;
    if ( v3 == 16 || !(unsigned __int8)sub_80A19AA(v4 ^ a1, v3) )
      break;
    a1 &= ~(_WORD)v4;
    ++v3;
  }
  return sub_80A1846(a1, v3);
}
// 81F6C40: using guessed type int dword_81F6C40;

//----- (080A1F70) --------------------------------------------------------
int __cdecl sub_80A1F70(int a1)
{
  return 8 * (unsigned __int16)sub_80A1E2A(a1) + 135751904;
}

//----- (080A1F96) --------------------------------------------------------
int __cdecl sub_80A1F96(int a1, int a2)
{
  return sub_80A1EE2((a1 - (int)dword_81768E0) >> 3, a2);
}
// 81768E0: using guessed type int dword_81768E0[];

//----- (080A1FBC) --------------------------------------------------------
_BOOL4 __cdecl sub_80A1FBC(int a1, int a2)
{
  int v3; // [esp+4h] [ebp-4h]

  v3 = sub_80A1DAA(a1);
  return v3 == sub_80A1DAA(a2);
}

//----- (080A1FEC) --------------------------------------------------------
void sub_80A1FEC()
{
  int i; // [esp+10h] [ebp-8h]

  if ( dword_81768C0 )
  {
    for ( i = 0; i <= 1; ++i )
    {
      dword_81F6C54[i] = 0x10000;
      dword_81F6C5C[i] = 0;
      *(&dword_81F6C4C + i) = Z_MallocInternal(16 * dword_81F6C54[i]);
      memset(*(&dword_81F6C4C + i), 0, 16 * dword_81F6C54[i]);
    }
    dword_81F6C64 = 0x10000;
    dword_81F6C68 = 0;
    dword_80EE870 = Z_MallocInternal(0x40000u);
    dword_81F6C74 = 0;
    dword_81F6C78 = 0;
    dword_81F6C6C = 16;
    dword_81F6C70 = 0;
    dword_80EE87C = Z_MallocInternal(0x140u);
  }
}
// 81768C0: using guessed type int dword_81768C0;
// 81F6C54: using guessed type int dword_81F6C54[];
// 81F6C5C: using guessed type int dword_81F6C5C[];
// 81F6C64: using guessed type int dword_81F6C64;
// 81F6C68: using guessed type int dword_81F6C68;
// 81F6C6C: using guessed type int dword_81F6C6C;
// 81F6C70: using guessed type int dword_81F6C70;
// 81F6C74: using guessed type int dword_81F6C74;
// 81F6C78: using guessed type int dword_81F6C78;

//----- (080A20F2) --------------------------------------------------------
int *sub_80A20F2()
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  for ( i = 0; i <= 1; ++i )
  {
    if ( *(&dword_81F6C4C + i) )
    {
      Z_FreeInternal(*(&dword_81F6C4C + i));
      *(&dword_81F6C4C + i) = 0;
    }
    result = &i;
  }
  if ( dword_80EE870 )
  {
    result = (int *)Z_FreeInternal(dword_80EE870);
    dword_80EE870 = 0;
  }
  if ( dword_80EE87C )
  {
    for ( i = 0; i < (unsigned int)dword_81F6C70; ++i )
      Z_FreeInternal(*((void **)dword_80EE87C + 5 * i + 2));
    result = (int *)Z_FreeInternal(dword_80EE87C);
    dword_80EE87C = 0;
  }
  if ( dword_80EE880 )
  {
    for ( i = 0; i < dword_80EE884; ++i )
    {
      if ( *((_DWORD *)dword_80EE880 + 2 * i) )
        Z_FreeInternal(*((void **)dword_80EE880 + 2 * i));
    }
    result = (int *)Z_FreeInternal(dword_80EE880);
    dword_80EE884 = -1;
    dword_80EE880 = 0;
  }
  return result;
}
// 80EE884: using guessed type int dword_80EE884;
// 81F6C70: using guessed type int dword_81F6C70;

//----- (080A222E) --------------------------------------------------------
void __cdecl sub_80A222E(int a1)
{
  _BOOL4 v1; // [esp+18h] [ebp-10h]
  void *dest; // [esp+1Ch] [ebp-Ch]
  void *s; // [esp+20h] [ebp-8h]

  if ( dword_81768C0 && dword_81766E0 != 2 )
  {
    v1 = dword_81766E0 == 1;
    if ( dword_81F6C5C[v1] >= (unsigned int)dword_81F6C54[v1] )
    {
      dword_81F6C54[v1] *= 2;
      s = Z_MallocInternal(16 * dword_81F6C54[v1]);
      memset(s, 0, 16 * dword_81F6C54[v1]);
      sub_80D2FC8(s, *(&dword_81F6C4C + v1), 16 * dword_81F6C5C[v1]);
      Z_FreeInternal(*(&dword_81F6C4C + v1));
      *(&dword_81F6C4C + v1) = s;
    }
    if ( dword_81F6C68 >= (unsigned int)dword_81F6C64 )
    {
      dword_81F6C64 *= 2;
      dest = Z_MallocInternal(4 * dword_81F6C64);
      sub_80D2FC8(dest, dword_80EE870, 4 * dword_81F6C68);
      Z_FreeInternal(dword_80EE870);
      dword_80EE870 = dest;
    }
    if ( dword_81F6C48 == dword_81F6C74 )
    {
      --dword_81F6C5C[v1];
    }
    else
    {
      dword_81F6C78 = 0;
      dword_81F6C74 = dword_81F6C48;
      *((_DWORD *)*(&dword_81F6C4C + v1) + 4 * dword_81F6C5C[v1] + 1) = dword_81F6C68;
    }
    if ( dword_81766E0 == 1 )
      *(_DWORD *)(dword_81F6C50 + 16 * dword_81F6C60) = dword_81F6C74 + (_BYTE *)dword_81766EC - (_BYTE *)dword_81766E8;
    else
      *((_DWORD *)dword_81F6C4C + 4 * dword_81F6C5C[0]) = dword_81F6C74;
    *((_DWORD *)dword_80EE870 + *((_DWORD *)*(&dword_81F6C4C + v1) + 4 * dword_81F6C5C[v1]++ + 1) + dword_81F6C78++) = a1;
    ++dword_81F6C68;
  }
}
// 81766E0: using guessed type int dword_81766E0;
// 81768C0: using guessed type int dword_81768C0;
// 81F6C48: using guessed type int dword_81F6C48;
// 81F6C50: using guessed type int dword_81F6C50;
// 81F6C54: using guessed type int dword_81F6C54[];
// 81F6C5C: using guessed type int dword_81F6C5C[];
// 81F6C60: using guessed type int dword_81F6C60;
// 81F6C64: using guessed type int dword_81F6C64;
// 81F6C68: using guessed type int dword_81F6C68;
// 81F6C74: using guessed type int dword_81F6C74;
// 81F6C78: using guessed type int dword_81F6C78;

//----- (080A2460) --------------------------------------------------------
int __cdecl sub_80A2460(unsigned int a1, int a2)
{
  _BOOL4 v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  v4 = sub_80A0F58(a1) == 0;
  v7 = 0;
  v6 = dword_81F6C5C[v4] - 1;
  while ( v7 <= v6 )
  {
    v5 = (v6 + v7) / 2;
    if ( a1 <= *((_DWORD *)*(&dword_81F6C4C + v4) + 4 * v5) )
    {
      v6 = v5 - 1;
    }
    else
    {
      v7 = v5 + 1;
      if ( v5 + 1 == dword_81F6C5C[v4] || a1 <= *((_DWORD *)*(&dword_81F6C4C + v4) + 4 * v7) )
        return *((_DWORD *)dword_80EE870 + *((_DWORD *)*(&dword_81F6C4C + v4) + 4 * v5 + 1) + a2);
    }
  }
  return 0;
}
// 81F6C5C: using guessed type int dword_81F6C5C[];

//----- (080A2548) --------------------------------------------------------
int sub_80A2548()
{
  return dword_81768C0;
}
// 81768C0: using guessed type int dword_81768C0;

//----- (080A2552) --------------------------------------------------------
unsigned int __cdecl sub_80A2552(void (__cdecl *a1)(int *, int))
{
  unsigned int result; // eax
  unsigned int i; // [esp+14h] [ebp-4h]

  a1(&dword_81F6C70, 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_81F6C70 )
      break;
    a1((int *)dword_80EE87C + 5 * i + 4, 4);
    if ( *((int *)dword_80EE87C + 5 * i + 4) > 0 )
      a1(*((int **)dword_80EE87C + 5 * i + 3), *((_DWORD *)dword_80EE87C + 5 * i + 4));
  }
  return result;
}
// 81F6C70: using guessed type int dword_81F6C70;

//----- (080A2612) --------------------------------------------------------
int *__cdecl sub_80A2612(void (__cdecl *a1)(int *, int))
{
  int *result; // eax
  int v2; // ebx
  char *v3; // esi
  int i; // [esp+Ch] [ebp-Ch] BYREF

  a1(&dword_80EE884, 4);
  dword_80EE880 = Z_MallocInternal(8 * dword_80EE884);
  result = (int *)(dword_80EE884 - 1);
  for ( i = dword_80EE884 - 1; i >= 0; --i )
  {
    a1((int *)dword_80EE880 + 2 * i + 1, 4);
    if ( *((int *)dword_80EE880 + 2 * i + 1) <= 0 )
    {
      *((_DWORD *)dword_80EE880 + 2 * i) = 0;
    }
    else
    {
      v2 = 8 * i;
      v3 = (char *)dword_80EE880;
      *(_DWORD *)&v3[v2] = Z_MallocInternal(*((_DWORD *)dword_80EE880 + 2 * i + 1));
      a1(*((int **)dword_80EE880 + 2 * i), *((_DWORD *)dword_80EE880 + 2 * i + 1));
    }
    result = &i;
  }
  return result;
}
// 80EE884: using guessed type int dword_80EE884;

//----- (080A2714) --------------------------------------------------------
int *__cdecl sub_80A2714(void (__cdecl *a1)(int *, int))
{
  int *result; // eax
  int v2; // [esp+Ch] [ebp-Ch] BYREF
  int v3; // [esp+10h] [ebp-8h] BYREF
  int i; // [esp+14h] [ebp-4h] BYREF

  a1(&v2, 4);
  result = (int *)(v2 - 1);
  for ( i = v2 - 1; i >= 0; --i )
  {
    a1(&v3, 4);
    if ( v3 > 0 )
      a1(0, v3);
    result = &i;
  }
  return result;
}

//----- (080A2772) --------------------------------------------------------
char *sub_80A2772()
{
  void *dest; // [esp+14h] [ebp-4h]

  if ( dword_81F6C70 >= (unsigned int)dword_81F6C6C )
  {
    dword_81F6C6C *= 2;
    dest = Z_MallocInternal(20 * dword_81F6C6C);
    sub_80D2FC8(dest, dword_80EE87C, 20 * dword_81F6C70);
    Z_FreeInternal(dword_80EE87C);
    dword_80EE87C = dest;
  }
  return (char *)dword_80EE87C + 20 * dword_81F6C70++;
}
// 81F6C6C: using guessed type int dword_81F6C6C;
// 81F6C70: using guessed type int dword_81F6C70;

//----- (080A280E) --------------------------------------------------------
char *__cdecl sub_80A280E(char *s, int a2, int a3)
{
  char *v3; // eax
  char v5; // [esp+17h] [ebp-41h]
  char v6; // [esp+1Fh] [ebp-39h]
  char *v7; // [esp+24h] [ebp-34h]
  char *v8; // [esp+28h] [ebp-30h]
  char *v9; // [esp+2Ch] [ebp-2Ch]
  char *v10; // [esp+2Ch] [ebp-2Ch]
  signed int v11; // [esp+30h] [ebp-28h]
  int v12; // [esp+34h] [ebp-24h] BYREF
  char *v13; // [esp+38h] [ebp-20h]
  char v14; // [esp+3Fh] [ebp-19h]
  int i; // [esp+40h] [ebp-18h]
  char *v16; // [esp+44h] [ebp-14h]
  char *v17; // [esp+48h] [ebp-10h]
  size_t size; // [esp+4Ch] [ebp-Ch]
  size_t v19; // [esp+50h] [ebp-8h]
  char *dest; // [esp+54h] [ebp-4h]

  if ( dword_80EE880 )
  {
    --dword_80EE884;
    v11 = *((_DWORD *)dword_80EE880 + 2 * dword_80EE884 + 1);
    if ( v11 >= 0 )
    {
      v13 = (char *)sub_806C565(v11 + 1);
      v9 = (char *)*((_DWORD *)dword_80EE880 + 2 * dword_80EE884);
      v17 = v13;
      for ( i = 0; i < v11; ++i )
      {
        v14 = *v9++;
        v6 = v14;
        if ( !v14 )
          v6 = 10;
        *v17++ = v6;
      }
      *v17 = 0;
      if ( *((_DWORD *)dword_80EE880 + 2 * dword_80EE884) )
        Z_FreeInternal(*((void **)dword_80EE880 + 2 * dword_80EE884));
      goto LABEL_12;
    }
  }
  else
  {
    v11 = FS_FOpenFileByMode(s, (int)&v12, 0);
    if ( v11 >= 0 )
    {
      v13 = (char *)sub_806C565(v11 + 1);
      FS_Read(v13, v11, v12);
      v13[v11] = 0;
      FS_FCloseFile(v12);
LABEL_12:
      if ( dword_80EE87C )
      {
        v19 = strlen(s) + 1;
        size = v19 + v11 + 2;
        dest = (char *)Z_MallocInternal(size);
        strcpy(dest, s);
        v16 = &dest[v19];
        v10 = v13;
        v17 = &dest[v19];
        for ( i = 0; i <= v11; ++i )
        {
          v14 = *v10++;
          if ( v14 == 10 )
            v5 = 0;
          else
            v5 = v14;
          *v17++ = v5;
        }
        v3 = sub_80A2772();
        *(_DWORD *)v3 = a2;
        *((_DWORD *)v3 + 1) = a3;
        *((_DWORD *)v3 + 2) = dest;
        *((_DWORD *)v3 + 3) = v16;
        *((_DWORD *)v3 + 4) = v11;
        *(_DWORD *)dword_80EE874 = v16;
        v7 = v13;
      }
      else
      {
        *(_DWORD *)dword_80EE874 = 0;
        v7 = v13;
      }
      return v7;
    }
  }
  if ( dword_80EE87C )
  {
    v8 = sub_80A2772();
    *(_DWORD *)v8 = 0;
    *((_DWORD *)v8 + 1) = 0;
    *((_DWORD *)v8 + 2) = 0;
    *((_DWORD *)v8 + 3) = 0;
    *((_DWORD *)v8 + 4) = -1;
  }
  return 0;
}
// 80EE884: using guessed type int dword_80EE884;

//----- (080A2AB2) --------------------------------------------------------
int __cdecl sub_80A2AB2(int a1, const char *a2, char *a3, int a4)
{
  void *v4; // esp
  char *v5; // eax
  char *v6; // eax
  void *v7; // esp
  char *v8; // eax
  _BYTE v10[12]; // [esp+10h] [ebp-38h] BYREF
  const char *v11; // [esp+1Ch] [ebp-2Ch]
  char v12; // [esp+23h] [ebp-25h]
  _BYTE *v13; // [esp+24h] [ebp-24h]
  int v14; // [esp+28h] [ebp-20h]
  char v15; // [esp+2Fh] [ebp-19h]
  int i; // [esp+30h] [ebp-18h]
  int v17; // [esp+34h] [ebp-14h]
  size_t n; // [esp+38h] [ebp-10h]
  void *v19; // [esp+3Ch] [ebp-Ch]
  char v20[4]; // [esp+40h] [ebp-8h]
  char *s; // [esp+44h] [ebp-4h]

  s = a3;
  v14 = 1;
  while ( a4 )
  {
    if ( !*a3 )
    {
      s = a3 + 1;
      ++v14;
    }
    ++a3;
    --a4;
  }
  v17 = strlen(s);
  v4 = alloca(16 * ((unsigned int)(v17 + 16) >> 4));
  *(_DWORD *)v20 = v10;
  for ( i = 0; i <= v17; ++i )
  {
    v15 = s[i];
    v13 = (_BYTE *)(i + *(_DWORD *)v20);
    if ( v15 == 9 )
      v12 = 32;
    else
      v12 = v15;
    *v13 = v12;
  }
  if ( dword_80EE880 )
    v11 = " (savegame)";
  else
    v11 = (const char *)&unk_80E17EC;
  v5 = va("(file '%s'%s, line %d)\n", a2, v11, v14);
  Com_PrintMessage(a1, v5);
  v6 = va("%s\n", *(const char **)v20);
  Com_PrintMessage(a1, v6);
  n = a3 - s;
  v7 = alloca(16 * ((unsigned int)(a3 - s + 17) >> 4));
  v19 = v10;
  sub_80D2FE9(v10, 32, a3 - s);
  *((_BYTE *)v19 + n) = 42;
  *((_BYTE *)v19 + n + 1) = 0;
  v8 = va("%s\n", (const char *)v19);
  return Com_PrintMessage(a1, v8);
}

//----- (080A2C3C) --------------------------------------------------------
int __cdecl sub_80A2C3C(int a1, unsigned int a2, int a3)
{
  char *v3; // eax
  int result; // eax
  int v5; // eax
  _BOOL4 v6; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( dword_81768C0 )
  {
    v6 = sub_80A0F58(a2) == 0;
    for ( i = dword_81F6C70 - 1;
          i > 0 && (!*((_DWORD *)dword_80EE87C + 5 * i + v6) || *((_DWORD *)dword_80EE87C + 5 * i + v6) >= a2);
          --i )
    {
      ;
    }
    v5 = sub_80A2460(a2, a3);
    result = sub_80A2AB2(a1, *((const char **)dword_80EE87C + 5 * i + 2), *((char **)dword_80EE87C + 5 * i + 3), v5);
  }
  else
  {
    v3 = va("@ %d\n", a2 - dword_80EE864);
    result = Com_PrintMessage(a1, v3);
  }
  return result;
}
// 80EE864: using guessed type int dword_80EE864;
// 81768C0: using guessed type int dword_81768C0;
// 81F6C70: using guessed type int dword_81F6C70;

//----- (080A2D58) --------------------------------------------------------
void __noreturn sub_80A2D58(int a1, char *format, ...)
{
  char v2; // [esp+4h] [ebp-424h]
  char v3; // [esp+4h] [ebp-424h]
  char v4; // [esp+4h] [ebp-424h]
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  Com_Printf("\n", v2);
  Com_Printf("******* script compile error *******\n", v3);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( dword_81768C0 )
  {
    Com_Printf("%s: ", (char)s);
    sub_80A2AB2(0, *(const char **)dword_80EE878, *(char **)dword_80EE874, a1);
  }
  else
  {
    Com_Printf("%s\n", (char)s);
  }
  Com_Printf("************************************\n", v4);
  Com_Error(1, (char *)&byte_80E18A0);
}
// 80A2D68: variable 'v2' is possibly undefined
// 80A2D74: variable 'v3' is possibly undefined
// 80A2DFE: variable 'v4' is possibly undefined
// 81768C0: using guessed type int dword_81768C0;

//----- (080A2E1A) --------------------------------------------------------
void __noreturn CompileError2(unsigned int a1, char *format, ...)
{
  char v2; // [esp+4h] [ebp-424h]
  char v3; // [esp+4h] [ebp-424h]
  char v4; // [esp+4h] [ebp-424h]
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  Com_Printf("\n", v2);
  Com_Printf("******* script compile error *******\n", v3);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  Com_Printf("%s: ", (char)s);
  sub_80A2C3C(0, a1, 0);
  Com_Printf("************************************\n", v4);
  Com_Error(1, (char *)&byte_80E18A0);
}
// 80A2E2A: variable 'v2' is possibly undefined
// 80A2E36: variable 'v3' is possibly undefined
// 80A2E95: variable 'v4' is possibly undefined

//----- (080A2EB0) --------------------------------------------------------
void __cdecl sub_80A2EB0(int a1, unsigned int a2, int a3, const char *a4)
{
  char *v4; // eax
  int i; // [esp+14h] [ebp-4h]

  v4 = va("\n******* script runtime error *******\n%s: ", a4);
  Com_PrintMessage(a1, v4);
  sub_80A2C3C(a1, a2, a3);
  for ( i = dword_830ACC4 - 1; i >= 0; --i )
  {
    Com_PrintMessage(a1, "called from:\n");
    sub_80A2C3C(a1, dword_830ACE0[i], 0);
  }
  Com_PrintMessage(a1, "************************************\n");
}
// 830ACC4: using guessed type int dword_830ACC4;

//----- (080A2F52) --------------------------------------------------------
void __cdecl sub_80A2F52(unsigned int a1, int a2, const char *a3, void *a4)
{
  const char *v4; // [esp+18h] [ebp-10h]
  void *v5; // [esp+1Ch] [ebp-Ch]
  char v6; // [esp+27h] [ebp-1h]

  if ( dword_81768C0 || byte_830AD6C )
  {
    v6 = 0;
    if ( dword_81768C8 || byte_830AD6C )
      v6 = 1;
    if ( v6 )
      sub_80A2EB0(0, a1, a2, a3);
    else
      sub_80A2EB0(4, a1, a2, a3);
    if ( v6 )
    {
      v5 = a4;
      if ( !a4 )
        v5 = &unk_80E17EC;
      if ( a4 )
        v4 = "\n";
      else
        v4 = (const char *)&unk_80E17EC;
      if ( byte_830AD6C )
        Com_Error(1, (char *)&byte_80E1920, v4, v5, a4);
      Com_Error(6, (char *)&byte_80E1920, v4, v5, a4);
    }
  }
}
// 81768C0: using guessed type int dword_81768C0;
// 81768C8: using guessed type int dword_81768C8;
// 830AD6C: using guessed type char byte_830AD6C;

//----- (080A3038) --------------------------------------------------------
_DWORD *__userpurge sub_80A3038@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080A304A) --------------------------------------------------------
_DWORD *__userpurge sub_80A304A@<eax>(_DWORD *a1, int a2)
{
  *a1 = a2;
  return a1;
}

//----- (080A305C) --------------------------------------------------------
int *__userpurge sub_80A305C@<eax>(int *a1, int a2)
{
  *a1 = sub_806C565(4);
  *(_DWORD *)*a1 = a2;
  return a1;
}

//----- (080A3086) --------------------------------------------------------
int __userpurge sub_80A3086@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = sub_806C565(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (080A30BA) --------------------------------------------------------
int __userpurge sub_80A30BA@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = sub_806C565(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (080A30F8) --------------------------------------------------------
int __userpurge sub_80A30F8@<eax>(int a1, int a2, int a3)
{
  *(_DWORD *)a1 = sub_806C565(8);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  return a1;
}

//----- (080A312C) --------------------------------------------------------
int __userpurge sub_80A312C@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = sub_806C565(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080A3174) --------------------------------------------------------
int __userpurge sub_80A3174@<eax>(int a1, int a2, int a3, int a4)
{
  *(_DWORD *)a1 = sub_806C565(12);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  return a1;
}

//----- (080A31B2) --------------------------------------------------------
int __userpurge sub_80A31B2@<eax>(int a1, int a2, int a3, int a4, int a5, int a6)
{
  *(_DWORD *)a1 = sub_806C565(20);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  return a1;
}

//----- (080A3204) --------------------------------------------------------
int __userpurge sub_80A3204@<eax>(int a1, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)a1 = sub_806C565(16);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  return a1;
}

//----- (080A324C) --------------------------------------------------------
int __userpurge sub_80A324C@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  *(_DWORD *)a1 = sub_806C565(24);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  return a1;
}

//----- (080A32A8) --------------------------------------------------------
int __userpurge sub_80A32A8@<eax>(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  *(_DWORD *)a1 = sub_806C565(28);
  **(_DWORD **)a1 = a2;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = a3;
  *(_DWORD *)(*(_DWORD *)a1 + 8) = a4;
  *(_DWORD *)(*(_DWORD *)a1 + 12) = a5;
  *(_DWORD *)(*(_DWORD *)a1 + 16) = a6;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = a7;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a8;
  return a1;
}

//----- (080A330E) --------------------------------------------------------
int __userpurge sub_80A330E@<eax>(int a1, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = (_DWORD *)sub_806C565(8);
  *v3 = a2;
  v3[1] = 0;
  *(_DWORD *)a1 = sub_806C565(8);
  **(_DWORD **)a1 = v3;
  *(_DWORD *)(*(_DWORD *)a1 + 4) = v3;
  return a1;
}

//----- (080A3364) --------------------------------------------------------
_DWORD *__userpurge sub_80A3364@<eax>(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_806C565(8);
  *v3 = a2;
  v3[1] = *a3;
  *a3 = v3;
  *a1 = a3;
  return a1;
}

//----- (080A33AA) --------------------------------------------------------
_DWORD *__userpurge sub_80A33AA@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // eax

  v3 = (_DWORD *)sub_806C565(8);
  *v3 = a3;
  v3[1] = 0;
  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) = v3;
  *(_DWORD *)(a2 + 4) = v3;
  *a1 = a2;
  return a1;
}

//----- (080A3438) --------------------------------------------------------
int __cdecl sub_80A3438(unsigned __int16 a1)
{
  return dword_81F68E0 + 8 * a1;
}
// 81F68E0: using guessed type int dword_81F68E0;

//----- (080A3454) --------------------------------------------------------
int __cdecl sub_80A3454(int a1)
{
  return a1 - 4;
}

//----- (080A3460) --------------------------------------------------------
int __cdecl SL_ConvertToString(unsigned __int16 a1)
{
  int v2; // [esp+10h] [ebp-8h]

  if ( a1 )
    v2 = sub_80A3438(a1) + 4;
  else
    v2 = 0;
  return v2;
}

//----- (080A3496) --------------------------------------------------------
int __cdecl sub_80A3496(int a1)
{
  return (unsigned __int16)((sub_80A3454(a1) - dword_81F68E0) / 8);
}
// 81F68E0: using guessed type int dword_81F68E0;

//----- (080A34C6) --------------------------------------------------------
int __cdecl sub_80A34C6(char *a1, unsigned int a2)
{
  unsigned int v5; // [esp+Ch] [ebp-8h]

  if ( a2 > 0xFF )
    return (unsigned __int16)((a2 >> 2)
                            - 0x3FFF
                            * ((unsigned int)(((262161 * (unsigned __int64)(a2 >> 2)) >> 32)
                                            + ((unsigned int)((a2 >> 2) - ((262161 * (unsigned __int64)(a2 >> 2)) >> 32)) >> 1)) >> 13)
                            + 1);
  v5 = 0;
  while ( a2 )
  {
    v5 = *a1++ + 31 * v5;
    --a2;
  }
  return (unsigned __int16)(v5 % 0x3FFF + 1);
}

//----- (080A357A) --------------------------------------------------------
int sub_80A357A()
{
  int result; // eax
  unsigned __int16 v1; // [esp+Eh] [ebp-Ah]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80A1CCC();
  word_81F6C80[0] = 0;
  v1 = 0;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    word_81F6C80[2 * i] = 0;
    word_81F6C80[2 * v1] |= i;
    word_81F6C80[2 * i + 1] = v1;
    v1 = i;
  }
  result = v1;
  word_81F6C82[0] = v1;
  return result;
}
// 81F6C80: using guessed type __int16 word_81F6C80[];

//----- (080A3604) --------------------------------------------------------
int __cdecl sub_80A3604(void *s2, size_t n)
{
  unsigned __int16 v4; // [esp+12h] [ebp-16h]
  unsigned __int16 v5; // [esp+14h] [ebp-14h]
  __int16 v6; // [esp+16h] [ebp-12h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+18h] [ebp-10h]
  __int16 *i; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]
  __int16 *v11; // [esp+24h] [ebp-4h]

  v5 = sub_80A34C6((char *)s2, n);
  v11 = &word_81F6C80[2 * v5];
  if ( (*v11 & 0xC000) != 0x8000 )
    return 0;
  v7 = sub_80A3438(v11[1]);
  if ( *(_BYTE *)(v7 + 2) != (_BYTE)n || memcmp((const void *)(v7 + 4), s2, n) )
  {
    v10 = v5;
    v4 = *v11 & 0x3FFF;
    for ( i = &word_81F6C80[2 * v4]; i != v11; i = &word_81F6C80[2 * v4] )
    {
      v8 = sub_80A3438(i[1]);
      if ( *(_BYTE *)(v8 + 2) == (_BYTE)n && !memcmp((const void *)(v8 + 4), s2, n) )
      {
        word_81F6C80[2 * v10] = word_81F6C80[2 * v10] & 0xC000 | *i & 0x3FFF;
        *i = *i & 0xC000 | *v11 & 0x3FFF;
        *v11 = *v11 & 0xC000 | v4;
        v6 = i[1];
        i[1] = v11[1];
        v11[1] = v6;
        return (unsigned __int16)v11[1];
      }
      v10 = v4;
      v4 = *i & 0x3FFF;
    }
    return 0;
  }
  return (unsigned __int16)v11[1];
}
// 81F6C80: using guessed type __int16 word_81F6C80[];

//----- (080A37F0) --------------------------------------------------------
int __cdecl sub_80A37F0(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return (unsigned __int16)sub_80A3604(s, v1 + 1);
}

//----- (080A3816) --------------------------------------------------------
int __cdecl sub_80A3816(char *s)
{
  size_t v1; // eax
  void *v2; // esp
  _BYTE *v3; // ebx
  size_t n; // [esp+8h] [ebp-10h] BYREF
  int i; // [esp+Ch] [ebp-Ch]
  void *s2; // [esp+10h] [ebp-8h]

  v1 = strlen(s);
  n = v1 + 1;
  v2 = alloca(16 * ((v1 + 16) >> 4));
  s2 = &n;
  for ( i = v1; i >= 0; --i )
  {
    v3 = (char *)s2 + i;
    *v3 = tolower(s[i]);
  }
  return (unsigned __int16)sub_80A3604(s2, n);
}

//----- (080A388C) --------------------------------------------------------
int __cdecl sub_80A388C(void *s2, int a2, size_t n)
{
  unsigned __int16 v5; // [esp+16h] [ebp-22h]
  __int16 v6; // [esp+16h] [ebp-22h]
  __int16 v7; // [esp+16h] [ebp-22h]
  unsigned __int16 v8; // [esp+18h] [ebp-20h]
  __int16 v9; // [esp+1Ah] [ebp-1Eh]
  int v10; // [esp+1Ch] [ebp-1Ch]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+1Ch] [ebp-1Ch]
  __int16 *j; // [esp+20h] [ebp-18h]
  __int16 *v14; // [esp+20h] [ebp-18h]
  __int16 *v15; // [esp+20h] [ebp-18h]
  unsigned __int16 v16; // [esp+28h] [ebp-10h]
  unsigned __int16 v17; // [esp+28h] [ebp-10h]
  unsigned __int16 v18; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v19; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 i; // [esp+2Ah] [ebp-Eh]
  __int16 *v21; // [esp+2Ch] [ebp-Ch]

  v8 = sub_80A34C6((char *)s2, n);
  v21 = &word_81F6C80[2 * v8];
  if ( (*v21 & 0xC000) != 0x8000 )
  {
    if ( (*v21 & 0xC000) != 0 )
    {
      v17 = *v21 & 0x3FFF;
      for ( i = v17; v8 != (word_81F6C80[2 * i] & 0x3FFF); i = word_81F6C80[2 * i] & 0x3FFF )
        ;
      v7 = word_81F6C80[0];
      if ( !word_81F6C80[0] )
      {
        Scr_DumpScriptThreads();
        sub_80A49CA();
        Com_Error(1, (char *)&byte_80E1960);
      }
      v15 = &word_81F6C80[2 * (unsigned __int16)word_81F6C80[0]];
      word_81F6C80[0] = *v15 & 0x3FFF;
      word_81F6C82[2 * (unsigned __int16)word_81F6C80[0]] = 0;
      word_81F6C80[2 * i] = word_81F6C80[2 * i] & 0xC000 | v7;
      *v15 = v17 | 0x4000;
      v15[1] = v21[1];
    }
    else
    {
      v19 = v21[1];
      v16 = *v21 & 0x3FFF;
      word_81F6C80[2 * v19] = word_81F6C80[2 * v19] & 0xC000 | v16;
      word_81F6C82[2 * v16] = v19;
    }
    *v21 = v8 | 0x8000;
LABEL_27:
    v21[1] = sub_80A1E2A(n + 4);
    v12 = sub_80A3438(v21[1]);
    sub_80D2FC8((void *)(v12 + 4), s2, n);
    *(_BYTE *)(v12 + 3) = a2;
    *(_WORD *)v12 = 0;
    *(_BYTE *)(v12 + 2) = n;
    return (unsigned __int16)v21[1];
  }
  v10 = sub_80A3438(v21[1]);
  if ( *(_BYTE *)(v10 + 2) != (_BYTE)n || memcmp((const void *)(v10 + 4), s2, n) )
  {
    v18 = v8;
    v5 = *v21 & 0x3FFF;
    for ( j = &word_81F6C80[2 * v5]; j != v21; j = &word_81F6C80[2 * v5] )
    {
      v11 = sub_80A3438(j[1]);
      if ( *(_BYTE *)(v11 + 2) == (_BYTE)n && !memcmp((const void *)(v11 + 4), s2, n) )
      {
        word_81F6C80[2 * v18] = word_81F6C80[2 * v18] & 0xC000 | *j & 0x3FFF;
        *j = *j & 0xC000 | *v21 & 0x3FFF;
        *v21 = *v21 & 0xC000 | v5;
        v9 = j[1];
        j[1] = v21[1];
        v21[1] = v9;
        if ( (*(char *)(v11 + 3) & (unsigned __int8)a2) == 0 )
        {
          *(_BYTE *)(v11 + 3) |= a2;
          ++*(_WORD *)v11;
        }
        return (unsigned __int16)v21[1];
      }
      v18 = v5;
      v5 = *j & 0x3FFF;
    }
    v6 = word_81F6C80[0];
    if ( !word_81F6C80[0] )
    {
      Scr_DumpScriptThreads();
      sub_80A49CA();
      Com_Error(1, (char *)&byte_80E1960);
    }
    v14 = &word_81F6C80[2 * (unsigned __int16)word_81F6C80[0]];
    word_81F6C80[0] = *v14 & 0x3FFF;
    word_81F6C82[2 * (unsigned __int16)word_81F6C80[0]] = 0;
    *v14 = *v21 & 0x3FFF | 0x4000;
    *v21 = *v21 & 0xC000 | v6 & 0x3FFF;
    v14[1] = v21[1];
    goto LABEL_27;
  }
  if ( (*(char *)(v10 + 3) & (unsigned __int8)a2) == 0 )
  {
    *(_BYTE *)(v10 + 3) |= a2;
    ++*(_WORD *)v10;
  }
  return (unsigned __int16)v21[1];
}
// 81F6C80: using guessed type __int16 word_81F6C80[];

//----- (080A3D64) --------------------------------------------------------
int __cdecl sub_80A3D64(char *s, int a2)
{
  size_t v2; // eax

  v2 = strlen(s);
  return (unsigned __int16)sub_80A388C(s, (unsigned __int8)a2, v2 + 1);
}

//----- (080A3DA2) --------------------------------------------------------
int __cdecl sub_80A3DA2(char *s, int a2)
{
  return (unsigned __int16)sub_80A3D64(s, (unsigned __int8)a2);
}

//----- (080A3DCE) --------------------------------------------------------
int __cdecl sub_80A3DCE(int a1, int a2, size_t n, int a4)
{
  void *v4; // esp
  _BYTE *v5; // ebx
  char v7; // [esp+Fh] [ebp-19h]
  int v8; // [esp+10h] [ebp-18h] BYREF
  int i; // [esp+18h] [ebp-10h]
  void *s2; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 v11; // [esp+23h] [ebp-5h]

  v11 = a2;
  v4 = alloca(16 * ((n + 15) >> 4));
  s2 = &v8;
  for ( i = n - 1; i >= 0; --i )
  {
    v5 = (char *)s2 + i;
    *v5 = tolower(*(char *)(a1 + i));
  }
  v7 = HIBYTE(a4);
  return (unsigned __int16)sub_80A388C(s2, v11, n);
}

//----- (080A3E4A) --------------------------------------------------------
int __cdecl sub_80A3E4A(char *s, int a2, int a3)
{
  size_t v3; // eax

  v3 = strlen(s);
  return (unsigned __int16)sub_80A3DCE((int)s, (unsigned __int8)a2, v3 + 1, a3);
}

//----- (080A3E88) --------------------------------------------------------
int __cdecl sub_80A3E88(char *s, int a2)
{
  return (unsigned __int16)sub_80A3E4A(s, (unsigned __int8)a2, 6);
}

//----- (080A3EB4) --------------------------------------------------------
int __cdecl sub_80A3EB4(unsigned __int16 a1, unsigned __int8 a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+10h] [ebp-8h]

  v3 = (unsigned __int16 *)sub_80A3438(a1);
  if ( (*((char *)v3 + 3) & a2) != 0 )
  {
    result = *v3 - 1;
    *v3 = result;
  }
  else
  {
    result = a2;
    LOBYTE(result) = *((_BYTE *)v3 + 3) | a2;
    *((_BYTE *)v3 + 3) = result;
  }
  return result;
}

//----- (080A3F08) --------------------------------------------------------
int __cdecl sub_80A3F08(unsigned __int16 a1)
{
  _WORD *v1; // edx
  int result; // eax

  v1 = (_WORD *)sub_80A3438(a1);
  result = (unsigned __int16)*v1 + 1;
  *v1 = result;
  return result;
}

//----- (080A3F34) --------------------------------------------------------
int __cdecl sub_80A3F34(unsigned __int16 a1, char *a2, unsigned int a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+16h] [ebp-12h]
  int v6; // [esp+18h] [ebp-10h]
  __int16 *v7; // [esp+1Ch] [ebp-Ch]
  __int16 *v8; // [esp+20h] [ebp-8h]

  HIWORD(v6) = sub_80A34C6(a2, a3);
  v8 = &word_81F6C80[2 * HIWORD(v6)];
  sub_80A1EE2(a1, a3 + 4);
  LOWORD(v6) = *v8 & 0x3FFF;
  v7 = &word_81F6C80[2 * (unsigned __int16)v6];
  if ( v8[1] == a1 )
  {
    if ( v7 == v8 )
    {
      v7 = &word_81F6C80[2 * HIWORD(v6)];
      LOWORD(v6) = HIWORD(v6);
    }
    else
    {
      *v8 = *v7 & 0x3FFF | 0x8000;
      v8[1] = v7[1];
      dword_8206C80 = (int)&word_81F6C80[2 * HIWORD(v6)];
    }
  }
  else
  {
    v4 = HIWORD(v6);
    while ( v7[1] != a1 )
    {
      v4 = v6;
      LOWORD(v6) = *v7 & 0x3FFF;
      v7 = &word_81F6C80[2 * (unsigned __int16)v6];
    }
    word_81F6C80[2 * v4] = word_81F6C80[2 * v4] & 0xC000 | *v7 & 0x3FFF;
  }
  v5 = word_81F6C80[0];
  *v7 = word_81F6C80[0];
  v7[1] = 0;
  word_81F6C82[2 * v5] = v6;
  result = v6;
  word_81F6C80[0] = v6;
  return result;
}
// 81F6C80: using guessed type __int16 word_81F6C80[];
// 8206C80: using guessed type int dword_8206C80;

//----- (080A40A6) --------------------------------------------------------
int __cdecl sub_80A40A6(unsigned __int16 a1)
{
  int result; // eax
  size_t v2; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)sub_80A3438(a1);
  if ( *(_WORD *)v3 )
  {
    result = *(unsigned __int16 *)v3 - 1;
    *(_WORD *)v3 = result;
  }
  else
  {
    v2 = strlen(v3 + 4);
    result = sub_80A3F34(a1, v3 + 4, v2 + 1);
  }
  return result;
}

//----- (080A4106) --------------------------------------------------------
int __cdecl sub_80A4106(unsigned __int16 a1, unsigned int a2)
{
  int result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)sub_80A3438(a1);
  if ( !*(_WORD *)v3 )
    return sub_80A3F34(a1, v3 + 4, a2);
  result = *(unsigned __int16 *)v3 - 1;
  *(_WORD *)v3 = result;
  return result;
}

//----- (080A415A) --------------------------------------------------------
int __cdecl sub_80A415A(unsigned __int16 *a1, unsigned __int16 a2)
{
  int result; // eax

  if ( *a1 )
    sub_80A40A6(*a1);
  if ( a2 )
    sub_80A3F08(a2);
  result = a2;
  *a1 = a2;
  return result;
}

//----- (080A419E) --------------------------------------------------------
int __cdecl sub_80A419E(char *s)
{
  return (unsigned __int16)sub_80A3DA2(s, 1);
}

//----- (080A41BC) --------------------------------------------------------
int __cdecl sub_80A41BC(float a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%g", a1);
  return (unsigned __int16)sub_80A3D64(s, 0);
}

//----- (080A4206) --------------------------------------------------------
int __cdecl sub_80A4206(int a1)
{
  char s[136]; // [esp+10h] [ebp-88h] BYREF

  sprintf(s, "%i", a1);
  return (unsigned __int16)sub_80A3D64(s, 0);
}

//----- (080A4250) --------------------------------------------------------
int __cdecl sub_80A4250(float *a1)
{
  char s[136]; // [esp+20h] [ebp-88h] BYREF

  sprintf(s, "(%.2f, %.2f, %.2f)", *a1, a1[1], a1[2]);
  return (unsigned __int16)sub_80A3D64(s, 0);
}

//----- (080A42B4) --------------------------------------------------------
unsigned int *__cdecl sub_80A42B4(unsigned int *a1)
{
  unsigned int *result; // eax
  int v2; // [esp+8h] [ebp-10h]
  __int16 *v3; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h] BYREF
  unsigned __int8 v5; // [esp+17h] [ebp-1h]

  result = a1;
  v5 = (unsigned __int8)a1;
  for ( i = 1; i <= 0x3FFF; ++i )
  {
    do
    {
      v3 = &word_81F6C80[2 * i];
      if ( (*v3 & 0xC000) == 0 )
        break;
      v2 = sub_80A3438(v3[1]);
      if ( (*(char *)(v2 + 3) & v5) == 0 )
        break;
      *(_BYTE *)(v2 + 3) &= ~v5;
      dword_8206C80 = 0;
      sub_80A40A6(v3[1]);
    }
    while ( dword_8206C80 );
    result = &i;
  }
  return result;
}
// 81F6C80: using guessed type __int16 word_81F6C80[];
// 8206C80: using guessed type int dword_8206C80;

//----- (080A4360) --------------------------------------------------------
_BYTE *__cdecl sub_80A4360(_BYTE *a1, char *a2, int a3)
{
  _BYTE *result; // eax
  char v4; // [esp+13h] [ebp-5h]

  do
  {
    do
    {
      do
        v4 = *a2++;
      while ( v4 == 92 );
    }
    while ( v4 == 47 );
    while ( (unsigned __int8)v4 > 0x1Fu )
    {
      *a1++ = tolower(v4);
      if ( !--a3 )
        Com_Error(1, (char *)&byte_80E19C0, a2, 0);
      if ( v4 == 92 )
        break;
      v4 = *a2++;
      if ( v4 == 47 )
        v4 = 92;
    }
  }
  while ( v4 );
  result = a1;
  *a1 = 0;
  return result;
}

//----- (080A4404) --------------------------------------------------------
int __cdecl sub_80A4404(char *a1)
{
  char s[1032]; // [esp+10h] [ebp-408h] BYREF

  sub_80A4360(s, a1, 1024);
  return (unsigned __int16)sub_80A3D64(s, 0);
}

//----- (080A4450) --------------------------------------------------------
void sub_80A4450()
{
  dword_80EE888 = 0;
}
// 80EE888: using guessed type int dword_80EE888;

//----- (080A4460) --------------------------------------------------------
int __cdecl sub_80A4460(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  v2 = dword_80EE888 + a1;
  v3 = dword_80EE888 + sub_806C77E(dword_80EE888 + a1);
  dword_80EE888 = v2;
  return v3;
}
// 80EE888: using guessed type int dword_80EE888;

//----- (080A4494) --------------------------------------------------------
int __cdecl sub_80A4494(int a1)
{
  dword_80EE888 -= sub_80A4460(0) - a1;
  return sub_806C77E(dword_80EE888);
}
// 80EE888: using guessed type int dword_80EE888;

//----- (080A44C8) --------------------------------------------------------
int __cdecl sub_80A44C8(const void *a1, const void *a2)
{
  int v4; // [esp+4h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-8h]
  int i; // [esp+Ch] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    if ( i >= *((_DWORD *)a1 + 32) || i >= *((_DWORD *)a2 + 32) )
      return *((_DWORD *)a1 + 32) - *((_DWORD *)a2 + 32);
    v5 = *((_DWORD *)a1 + i);
    v4 = *((_DWORD *)a2 + i);
    if ( v5 != v4 )
      break;
  }
  return v5 - v4;
}

//----- (080A4548) --------------------------------------------------------
int Scr_DumpScriptThreads()
{
  float *v0; // ebx
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  long double v3; // fst7
  char v5; // [esp+4h] [ebp-F4h]
  char v6; // [esp+4h] [ebp-F4h]
  char v7; // [esp+4h] [ebp-F4h]
  int v8; // [esp+18h] [ebp-E0h]
  char v9; // [esp+1Fh] [ebp-D9h]
  _BYTE *v10; // [esp+20h] [ebp-D8h]
  _DWORD *v11; // [esp+20h] [ebp-D8h]
  int v12; // [esp+24h] [ebp-D4h]
  int v13; // [esp+28h] [ebp-D0h]
  int v14; // [esp+2Ch] [ebp-CCh]
  int v15[32]; // [esp+30h] [ebp-C8h]
  int v16; // [esp+B0h] [ebp-48h]
  float v17; // [esp+B4h] [ebp-44h]
  float v18; // [esp+B8h] [ebp-40h]
  unsigned __int16 l; // [esp+CAh] [ebp-2Eh]
  unsigned int k; // [esp+CCh] [ebp-2Ch]
  char v21[4]; // [esp+D0h] [ebp-28h]
  int j; // [esp+D4h] [ebp-24h]
  int v23; // [esp+D8h] [ebp-20h]
  void *v24; // [esp+DCh] [ebp-1Ch]
  size_t nmemb; // [esp+E0h] [ebp-18h]
  void *base; // [esp+E4h] [ebp-14h]
  int *v27; // [esp+E8h] [ebp-10h]
  unsigned int i; // [esp+ECh] [ebp-Ch]

  base = Z_MallocInternal(0x8C0000u);
  nmemb = 0;
  for ( i = 1; i <= 0xFFFF; ++i )
  {
    v27 = &dword_8206CA0[3 * i];
    if ( (v27[1] & 0x60) != 0 && (v27[1] & 0x1F) == 10 )
    {
      v24 = (char *)base + 140 * nmemb++;
      v16 = 0;
      v14 = *v27;
      v13 = *(unsigned __int16 *)(*v27 + 8);
      v12 = *(_DWORD *)(*v27 + 4);
      v10 = (_BYTE *)(*v27 + 12);
      while ( v13 )
      {
        --v13;
        v9 = *v10;
        v11 = v10 + 1;
        v8 = *v11;
        v10 = v11 + 1;
        if ( v9 == 6 )
          v15[v16++] = v8;
      }
      v15[v16++] = v12;
      v0 = (float *)v24;
      v0[33] = sub_80A88F8(v14, (float *)v24 + 34);
      *((_DWORD *)v24 + 32) = v16--;
      for ( j = 0; j < *((_DWORD *)v24 + 32); ++j )
        *((_DWORD *)v24 + j) = v15[v16 - j];
    }
  }
  qsort(base, nmemb, 0x8Cu, sub_80A44C8);
  Com_Printf("********************************\n", v5);
  v23 = 0;
  while ( v23 < (int)nmemb )
  {
    v24 = (char *)base + 140 * v23;
    *(_DWORD *)v21 = 0;
    v17 = 0.0;
    v18 = 0.0;
    do
    {
      ++*(_DWORD *)v21;
      v17 = v17 + *((float *)base + 35 * v23 + 33);
      v18 = v18 + *((float *)base + 35 * v23++ + 34);
    }
    while ( v23 < (int)nmemb && !sub_80A44C8(v24, (char *)base + 140 * v23) );
    Com_Printf("count: %d, var usage: %d, endon usage: %d\n", v21[0]);
    sub_80A2C3C(0, *(_DWORD *)v24, 0);
    for ( j = 1; j < *((_DWORD *)v24 + 32); ++j )
    {
      Com_Printf("called from:\n", v6);
      sub_80A2C3C(0, *((_DWORD *)v24 + j), 0);
    }
  }
  Z_FreeInternal(base);
  Com_Printf("********************************\n", v6);
  for ( k = 0; k < dword_8306CA4; ++k )
  {
    if ( (unsigned __int16)sub_80A5E90(word_80EE8A2, k) )
    {
      v17 = 0.0;
      *(_DWORD *)v21 = 0;
      v1 = sub_80A5E90(word_80EE8A2, k);
      v2 = sub_80A6B8A(v1);
      for ( l = FindNextSibling(v2); l; l = FindNextSibling(l) )
      {
        ++*(_DWORD *)v21;
        v3 = sub_80A886A(dword_8206CA0[3 * l]);
        v17 = v3 + v17;
      }
      Com_Printf("ent type '%s'... count: %d, var usage: %d\n", *(_DWORD *)(dword_8306CA0 + 8 * k + 4));
    }
  }
  return Com_Printf("********************************\n", v7);
}
// 80A4723: variable 'v5' is possibly undefined
// 80A4858: variable 'v6' is possibly undefined
// 80A49BB: variable 'v7' is possibly undefined
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 8206CA0: using guessed type int dword_8206CA0[];
// 8306CA0: using guessed type int dword_8306CA0;
// 8306CA4: using guessed type int dword_8306CA4;

//----- (080A49CA) --------------------------------------------------------
void sub_80A49CA()
{
  ;
}

//----- (080A49D0) --------------------------------------------------------
int sub_80A49D0()
{
  int result; // eax
  unsigned __int16 v1; // [esp+6h] [ebp-Ah]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v1 = 0;
  for ( i = 1; i <= 0xFFFF; ++i )
  {
    dword_8206CA0[3 * i + 1] = 0;
    word_82C6CA0[2 * i] = i;
    word_8206CA8[6 * v1] = i;
    LOWORD(dword_8206CA0[3 * i]) = v1;
    v1 = i;
  }
  dword_8206CA0[1] = 0;
  word_82C6CA0[0] = 0;
  word_8206CA8[6 * v1] = 0;
  result = v1;
  LOWORD(dword_8206CA0[0]) = v1;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA8: using guessed type __int16 word_8206CA8[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A4A9E) --------------------------------------------------------
int sub_80A4A9E()
{
  int result; // eax

  sub_80A357A();
  sub_80A49D0();
  word_80EE8A0 = sub_80A5A30();
  result = sub_80A5A30();
  word_80EE8A2 = result;
  return result;
}
// 80EE8A0: using guessed type __int16 word_80EE8A0;
// 80EE8A2: using guessed type __int16 word_80EE8A2;

//----- (080A4AD0) --------------------------------------------------------
int __cdecl sub_80A4AD0(unsigned __int16 a1)
{
  return (unsigned __int16)((unsigned int)dword_8206CA4[3 * a1] >> 8);
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A4AF8) --------------------------------------------------------
unsigned int __cdecl sub_80A4AF8(unsigned __int16 a1)
{
  return (unsigned int)dword_8206CA0[3 * a1 + 1] >> 8;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A4B2C) --------------------------------------------------------
int __cdecl sub_80A4B2C(unsigned __int16 a1, int a2)
{
  int *v4; // [esp+4h] [ebp-18h]
  int *v5; // [esp+8h] [ebp-14h]
  unsigned __int16 v6; // [esp+Eh] [ebp-Eh]
  __int16 *v7; // [esp+10h] [ebp-Ch]
  unsigned __int16 v8; // [esp+18h] [ebp-4h]

  v8 = (a2 + 31 * (unsigned int)a1) % 0xFFFF + 1;
  v5 = &dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * v8]];
  if ( (v5[1] & 0x60) != 64 )
    return 0;
  if ( (unsigned int)v5[1] >> 8 != a2 )
  {
    v6 = *((_WORD *)v5 + 4);
    v7 = &word_82C6CA0[2 * v6];
    v4 = &dword_8206CA0[3 * (unsigned __int16)*v7];
    while ( v7 != &word_82C6CA0[2 * v8] )
    {
      if ( (unsigned int)v4[1] >> 8 == a2 )
        return v6;
      v6 = *((_WORD *)v4 + 4);
      v7 = &word_82C6CA0[2 * v6];
      v4 = &dword_8206CA0[3 * (unsigned __int16)*v7];
    }
    return 0;
  }
  return v8;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A4C6A) --------------------------------------------------------
int __cdecl sub_80A4C6A(unsigned __int16 a1, unsigned int a2)
{
  int *v4; // [esp+8h] [ebp-30h]
  int *v5; // [esp+10h] [ebp-28h]
  int *v6; // [esp+10h] [ebp-28h]
  int *v7; // [esp+14h] [ebp-24h]
  unsigned __int16 v8; // [esp+18h] [ebp-20h]
  unsigned __int16 v9; // [esp+18h] [ebp-20h]
  unsigned __int16 v10; // [esp+18h] [ebp-20h]
  __int16 v11; // [esp+1Ah] [ebp-1Eh]
  unsigned __int16 v12; // [esp+22h] [ebp-16h]
  __int16 *v13; // [esp+24h] [ebp-14h]
  __int16 *v14; // [esp+24h] [ebp-14h]
  __int16 *v15; // [esp+24h] [ebp-14h]
  unsigned __int16 i; // [esp+28h] [ebp-10h]
  unsigned __int16 v17; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v18; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v19; // [esp+2Eh] [ebp-Ah]
  __int16 *v20; // [esp+30h] [ebp-8h]
  unsigned __int16 v21; // [esp+34h] [ebp-4h]

  v21 = (a2 + 31 * a1) % 0xFFFF + 1;
  v20 = &word_82C6CA0[2 * v21];
  v7 = &dword_8206CA0[3 * (unsigned __int16)*v20];
  if ( (v7[1] & 0x60) == 64 )
  {
    if ( (unsigned int)v7[1] >> 8 == a2 )
      return v21;
    v8 = *((_WORD *)v7 + 4);
    v13 = &word_82C6CA0[2 * v8];
    v5 = &dword_8206CA0[3 * (unsigned __int16)*v13];
    while ( v13 != v20 )
    {
      if ( (unsigned int)v5[1] >> 8 == a2 )
        return v8;
      v8 = *((_WORD *)v5 + 4);
      v13 = &word_82C6CA0[2 * v8];
      v5 = &dword_8206CA0[3 * (unsigned __int16)*v13];
    }
    v9 = word_8206CA8[0];
    if ( !word_8206CA8[0] )
      sub_80AF512((int)"exceeded maximum number of script variables");
    v14 = &word_82C6CA0[2 * v9];
    v6 = &dword_8206CA0[3 * (unsigned __int16)*v14];
    word_8206CA8[0] = *((_WORD *)v6 + 4);
    LOWORD(dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)word_8206CA8[0]]]) = 0;
    v6[1] = 32;
    *((_WORD *)v6 + 4) = *((_WORD *)v7 + 4);
    *((_WORD *)v7 + 4) = v9;
  }
  else
  {
    if ( (v7[1] & 0x60) != 0 )
    {
      v10 = word_8206CA8[0];
      if ( !word_8206CA8[0] )
        sub_80AF512((int)"exceeded maximum number of script variables");
      v15 = &word_82C6CA0[2 * v10];
      v6 = &dword_8206CA0[3 * (unsigned __int16)*v15];
      word_8206CA8[0] = *((_WORD *)v6 + 4);
      LOWORD(dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)word_8206CA8[0]]]) = 0;
      v19 = *((_WORD *)v7 + 5);
      word_8206CAA[6 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)v20[1]]] = v10;
      word_82C6CA2[2 * v19] = v10;
      if ( (v7[1] & 0x60) == 32 )
      {
        for ( i = word_82C6CA0[2 * *((unsigned __int16 *)v7 + 4)];
              word_8206CA8[6 * i] != v21;
              i = word_82C6CA0[2 * (unsigned __int16)word_8206CA8[6 * i]] )
        {
          ;
        }
        word_8206CA8[6 * i] = v10;
      }
      else
      {
        *((_WORD *)v7 + 4) = v10;
      }
      v15[1] = v20[1];
      v11 = *v15;
      *v15 = *v20;
      *v20 = v11;
    }
    else
    {
      v18 = dword_8206CA0[3 * (unsigned __int16)*v20];
      v17 = *((_WORD *)v7 + 4);
      word_8206CA8[6 * (unsigned __int16)word_82C6CA0[2 * v18]] = v17;
      LOWORD(dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * v17]]) = v18;
      v6 = &dword_8206CA0[3 * (unsigned __int16)*v20];
    }
    v9 = (a2 + 31 * a1) % 0xFFFF + 1;
    v14 = &word_82C6CA0[2 * v21];
    v6[1] = 64;
    *((_WORD *)v6 + 4) = v21;
  }
  v4 = &dword_8206CA0[3 * a1];
  v12 = *((_WORD *)v4 + 5);
  *((_WORD *)v6 + 5) = v12;
  word_82C6CA0[2 * v12 + 1] = v9;
  v14[1] = *((_WORD *)v4 + 4);
  *((_WORD *)v4 + 5) = v9;
  v6[1] = *((unsigned __int8 *)v6 + 4);
  v6[1] |= a2 << 8;
  if ( (v4[1] & 0x1F) == 15 )
  {
    ++*((_WORD *)v4 + 1);
    if ( a2 > 0xFFFF )
    {
      if ( a2 <= 0x1FFFF )
        sub_80A5BCE(a2);
    }
    else
    {
      sub_80A3F08(a2);
    }
  }
  return v9;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA8: using guessed type __int16 word_8206CA8[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A5160) --------------------------------------------------------
int __cdecl sub_80A5160(__int16 *a1, int a2)
{
  int result; // eax
  unsigned int v3; // [esp+10h] [ebp-28h]
  unsigned __int16 v4; // [esp+16h] [ebp-22h]
  unsigned __int16 v5; // [esp+18h] [ebp-20h]
  unsigned __int16 v6; // [esp+1Ah] [ebp-1Eh]
  int v7; // [esp+1Ch] [ebp-1Ch]
  int *v8; // [esp+20h] [ebp-18h]
  int *v9; // [esp+20h] [ebp-18h]
  int *v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  __int16 *v12; // [esp+2Ch] [ebp-Ch]
  __int16 *v13; // [esp+30h] [ebp-8h]
  __int16 *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 v15; // [esp+36h] [ebp-2h]

  v11 = ((char *)a1 - (char *)word_82C6CA0) >> 2;
  v10 = &dword_8206CA0[3 * (unsigned __int16)*a1];
  if ( (*(_DWORD *)(a2 + 4) & 0x1F) == 15 )
  {
    --*(_WORD *)(a2 + 2);
    v3 = (unsigned int)v10[1] >> 8;
    if ( v3 > 0xFFFF )
    {
      if ( v3 <= 0x1FFFF )
        sub_80A5C0A((unsigned __int16)v3);
    }
    else
    {
      sub_80A40A6(v3);
    }
  }
  if ( (v10[1] & 0x60) == 64 )
  {
    v15 = *((_WORD *)v10 + 4);
    v13 = &word_82C6CA0[2 * v15];
    v8 = &dword_8206CA0[3 * (unsigned __int16)*v13];
    if ( v13 != a1 )
    {
      v8[1] &= 0xFFFFFF9F;
      v8[1] |= 0x40u;
      v6 = a1[1];
      v5 = *((_WORD *)v10 + 5);
      v4 = v13[1];
      word_82C6CA2[2 * *((unsigned __int16 *)v8 + 5)] = v11;
      word_8206CAA[6 * (unsigned __int16)word_82C6CA0[2 * v4]] = v11;
      word_82C6CA2[2 * v5] = v15;
      word_8206CAA[6 * (unsigned __int16)word_82C6CA0[2 * v6]] = v15;
      v7 = *(_DWORD *)a1;
      *(_DWORD *)a1 = *(_DWORD *)v13;
      *(_DWORD *)v13 = v7;
      v11 = v15;
    }
  }
  else
  {
    v14 = a1;
    v9 = v10;
    do
    {
      v12 = v14;
      v14 = &word_82C6CA0[2 * *((unsigned __int16 *)v9 + 4)];
      v9 = &dword_8206CA0[3 * (unsigned __int16)*v14];
    }
    while ( v14 != a1 );
    word_8206CA8[6 * (unsigned __int16)*v12] = *((_WORD *)v10 + 4);
  }
  v10[1] &= 0xFFFFFF9F;
  v10[1] |= 0x60u;
  result = v11;
  *((_WORD *)v10 + 4) = v11;
  return result;
}
// 80A5C0A: using guessed type _DWORD __cdecl sub_80A5C0A(_DWORD);
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA8: using guessed type __int16 word_8206CA8[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A53C2) --------------------------------------------------------
int __cdecl sub_80A53C2(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 i; // [esp+16h] [ebp-12h]
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int *v4; // [esp+18h] [ebp-10h]
  int *v5; // [esp+1Ch] [ebp-Ch]
  __int16 *v6; // [esp+20h] [ebp-8h]

  v5 = &dword_8206CA0[3 * a1];
  v6 = &word_82C6CA0[2 * *((unsigned __int16 *)v5 + 5)];
  for ( i = *v6; i != a1; i = *v6 )
  {
    sub_80A5160(v6, (int)v5);
    v6 = &word_82C6CA0[2 * (unsigned __int16)word_8206CAA[6 * i]];
  }
  v3 = word_82C6CA0[2 * *((unsigned __int16 *)v5 + 5)];
  while ( 1 )
  {
    result = v3;
    if ( v3 == a1 )
      break;
    v4 = &dword_8206CA0[3 * v3];
    v3 = word_82C6CA0[2 * *((unsigned __int16 *)v4 + 5)];
    sub_80A5B60(v4);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A54B8) --------------------------------------------------------
int __cdecl sub_80A54B8(unsigned __int16 a1)
{
  sub_80A5BCE(a1);
  sub_80A53C2(a1);
  return sub_80A5C0A(a1);
}
// 80A5C0A: using guessed type _DWORD __cdecl sub_80A5C0A(_DWORD);

//----- (080A54EC) --------------------------------------------------------
int __cdecl sub_80A54EC(unsigned __int16 a1)
{
  return (unsigned __int16)((unsigned int)dword_8206CA4[3 * a1] >> 8);
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A5514) --------------------------------------------------------
int __cdecl sub_80A5514(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax

  sub_80A3F08(a2);
  result = dword_8206CA4[3 * a1] | (a2 << 8);
  dword_8206CA4[3 * a1] = result;
  return result;
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A556C) --------------------------------------------------------
int __cdecl sub_80A556C(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+4h] [ebp-4h]

  v2 = sub_80A54EC(a1);
  sub_80A40A6(v2);
  result = LOBYTE(dword_8206CA4[3 * a1]);
  dword_8206CA4[3 * a1] = result;
  return result;
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A55C2) --------------------------------------------------------
int __cdecl sub_80A55C2(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  int *v2; // eax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  int *v5; // eax
  unsigned __int16 v6; // ax
  unsigned __int16 v8; // [esp+Eh] [ebp-1Ah]
  unsigned __int16 v9; // [esp+12h] [ebp-16h]
  unsigned __int16 v10; // [esp+14h] [ebp-14h]
  unsigned __int16 v11; // [esp+16h] [ebp-12h]
  unsigned __int16 v12; // [esp+16h] [ebp-12h]
  unsigned __int16 v13; // [esp+18h] [ebp-10h]
  unsigned __int16 v14; // [esp+1Ah] [ebp-Eh]
  int *v15; // [esp+20h] [ebp-8h]

  v15 = &dword_8206CA0[3 * a1];
  sub_80A5BCE(a1);
  sub_80A53C2(a1);
  sub_80A5C0A(*((_WORD *)v15 + 1));
  v14 = sub_80A5B3C(a1);
  v13 = sub_80A5EBE(word_830AE30, a1);
  if ( v13 )
  {
    v11 = sub_80A6B8A(v13);
    while ( 1 )
    {
      v10 = FindNextSibling(v11);
      if ( !v10 )
        break;
      v9 = (unsigned int)dword_8206CA4[3 * v10] >> 8;
      sub_80A54EC(v9);
      v1 = sub_80A5EBE(v11, v9);
      v2 = GetVariableValueAddress(v1);
      sub_80AD26C(*(_WORD *)v2, v9);
      dword_8206CA4[3 * v9] &= 0xFFFFFFE0;
      dword_8206CA4[3 * v9] |= 0x10u;
      sub_80A62D2(v11, v9);
      sub_80A5C0A(a1);
    }
    sub_80A62D2(word_830AE30, a1);
  }
  if ( (unsigned __int16)sub_80A54EC(a1) )
  {
    v3 = sub_80A5EBE(word_830AE30, v14);
    v8 = sub_80A6B8A(v3);
    v4 = sub_80A5EBE(v8, a1);
    v5 = GetVariableValueAddress(v4);
    sub_80AD26C(*(_WORD *)v5, a1);
    v6 = sub_80A5EBE(word_830AE30, v14);
    v12 = sub_80A6B8A(v6);
    sub_80A62D2(v12, a1);
    if ( !sub_80A6A06(v12) )
      sub_80A62D2(word_830AE30, v14);
  }
  v15[1] &= 0xFFFFFFE0;
  v15[1] |= 0x10u;
  return sub_80A5C0A(a1);
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA4: using guessed type int dword_8206CA4[];
// 830AE30: using guessed type __int16 word_830AE30;

//----- (080A586C) --------------------------------------------------------
int *sub_80A586C()
{
  int *v1; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  v2 = word_8206CA8[0];
  if ( !word_8206CA8[0] )
    sub_80AF512((int)"exceeded maximum number of script variables");
  v1 = &dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * v2]];
  word_8206CA8[0] = *((_WORD *)v1 + 4);
  LOWORD(dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)word_8206CA8[0]]]) = 0;
  *((_WORD *)v1 + 4) = v2;
  *((_WORD *)v1 + 5) = v2;
  word_82C6CA0[2 * v2 + 1] = v2;
  return v1;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA8: using guessed type __int16 word_8206CA8[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A591C) --------------------------------------------------------
int __cdecl sub_80A591C(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+2h] [ebp-Eh]
  unsigned __int16 v3; // [esp+4h] [ebp-Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-Ah]
  int *v5; // [esp+8h] [ebp-8h]

  v5 = &dword_8206CA0[3 * a1];
  v2 = *((_WORD *)v5 + 4);
  v4 = word_82C6CA2[2 * v2];
  v3 = *((_WORD *)v5 + 5);
  word_82C6CA2[2 * v3] = v4;
  word_8206CAA[6 * (unsigned __int16)word_82C6CA0[2 * v4]] = v3;
  v5[1] &= 0xFFFFFF9F;
  v5[1] = v5[1];
  *((_WORD *)v5 + 4) = word_8206CA8[0];
  *(_WORD *)v5 = 0;
  LOWORD(dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)word_8206CA8[0]]]) = v2;
  result = v2;
  word_8206CA8[0] = v2;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA8: using guessed type __int16 word_8206CA8[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A5A02) --------------------------------------------------------
int sub_80A5A02()
{
  int *v0; // eax

  v0 = sub_80A586C();
  v0[1] = 96;
  return (unsigned __int16)(-21845 * (v0 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5A30) --------------------------------------------------------
int sub_80A5A30()
{
  int *v0; // eax

  v0 = sub_80A586C();
  v0[1] = 110;
  *(_WORD *)v0 = 0;
  return (unsigned __int16)(-21845 * (v0 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5A66) --------------------------------------------------------
int __cdecl sub_80A5A66(int a1, __int16 a2)
{
  int *v2; // eax

  v2 = sub_80A586C();
  v2[1] = (a1 << 8) | 0x6D;
  *(_WORD *)v2 = 0;
  *((_WORD *)v2 + 1) = a2;
  return (unsigned __int16)(-21845 * (v2 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5AB4) --------------------------------------------------------
int sub_80A5AB4()
{
  int *v0; // eax

  v0 = sub_80A586C();
  v0[1] = 111;
  *(_WORD *)v0 = 0;
  *((_WORD *)v0 + 1) = 0;
  return (unsigned __int16)(-21845 * (v0 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5AF4) --------------------------------------------------------
int __cdecl sub_80A5AF4(__int16 a1)
{
  int *v1; // eax

  v1 = sub_80A586C();
  v1[1] = 108;
  *(_WORD *)v1 = 0;
  *((_WORD *)v1 + 1) = a1;
  return (unsigned __int16)(-21845 * (v1 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5B3C) --------------------------------------------------------
int __cdecl sub_80A5B3C(unsigned __int16 a1)
{
  return HIWORD(dword_8206CA0[3 * a1]);
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5B60) --------------------------------------------------------
int __cdecl sub_80A5B60(int *a1)
{
  sub_80A5DA8(a1[1] & 0x1F, *a1);
  return sub_80A591C(-21845 * (a1 - dword_8206CA0));
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5B9E) --------------------------------------------------------
int __cdecl sub_80A5B9E(unsigned __int16 a1)
{
  return sub_80A5B60(&dword_8206CA0[3 * a1]);
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5BCE) --------------------------------------------------------
int __cdecl sub_80A5BCE(unsigned __int16 a1)
{
  int result; // eax

  result = LOWORD(dword_8206CA0[3 * a1]) + 1;
  LOWORD(dword_8206CA0[3 * a1]) = result;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5C0A) --------------------------------------------------------
int __cdecl sub_80A5C0A(unsigned __int16 a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]

  v2 = &dword_8206CA0[3 * a1];
  if ( *(_WORD *)v2 )
  {
    result = *(unsigned __int16 *)v2 - 1;
    *(_WORD *)v2 = result;
  }
  else
  {
    sub_80A54B8(a1);
    result = sub_80A591C(a1);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A5C64) --------------------------------------------------------
_WORD *sub_80A5C64()
{
  _WORD *v0; // eax

  v0 = (_WORD *)sub_80A1F70(14);
  *v0 = 0;
  return v0 + 1;
}

//----- (080A5C94) --------------------------------------------------------
_DWORD *__cdecl sub_80A5C94(_DWORD *a1)
{
  _DWORD *result; // eax

  result = sub_80A5C64();
  *result = *a1;
  result[1] = a1[1];
  result[2] = a1[2];
  return result;
}

//----- (080A5CD2) --------------------------------------------------------
int __cdecl sub_80A5CD2(int a1)
{
  int result; // eax

  result = a1 - dword_81F68E4;
  if ( a1 - dword_81F68E4 >= (unsigned int)dword_81F68EC )
  {
    result = *(unsigned __int16 *)(a1 - 2) + 1;
    *(_WORD *)(a1 - 2) = result;
  }
  return result;
}
// 81F68E4: using guessed type int dword_81F68E4;
// 81F68EC: using guessed type int dword_81F68EC;

//----- (080A5D00) --------------------------------------------------------
int __cdecl sub_80A5D00(int a1)
{
  int result; // eax

  result = a1 - dword_81F68E4;
  if ( a1 - dword_81F68E4 >= (unsigned int)dword_81F68EC )
  {
    if ( *(_WORD *)(a1 - 2) )
    {
      result = *(unsigned __int16 *)(a1 - 2) - 1;
      *(_WORD *)(a1 - 2) = result;
    }
    else
    {
      result = sub_80A1F96(a1 - 2, 14);
    }
  }
  return result;
}
// 81F68E4: using guessed type int dword_81F68E4;
// 81F68EC: using guessed type int dword_81F68EC;

//----- (080A5D56) --------------------------------------------------------
int __cdecl sub_80A5D56(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 3 )
    return sub_80A5CD2(a2);
  if ( a1 > 3 )
  {
    if ( a1 == 7 )
      result = sub_80A5BCE(a2);
  }
  else if ( a1 >= 1 )
  {
    result = sub_80A3F08(a2);
  }
  return result;
}

//----- (080A5DA8) --------------------------------------------------------
int __cdecl sub_80A5DA8(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 3 )
    return sub_80A5D00(a2);
  if ( a1 > 3 )
  {
    if ( a1 == 7 )
      result = sub_80A5C0A((unsigned __int16)a2);
  }
  else if ( a1 >= 1 )
  {
    result = sub_80A40A6(a2);
  }
  return result;
}
// 80A5C0A: using guessed type _DWORD __cdecl sub_80A5C0A(_DWORD);

//----- (080A5DFA) --------------------------------------------------------
_BOOL4 __cdecl sub_80A5DFA(int a1)
{
  return (unsigned int)(a1 + 8257536) <= 0xFDFFFF;
}

//----- (080A5E20) --------------------------------------------------------
int __cdecl sub_80A5E20(int a1)
{
  return (a1 + 0x800000) & 0xFFFFFF;
}

//----- (080A5E32) --------------------------------------------------------
int __cdecl sub_80A5E32(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)sub_80A4B2C(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A5E62) --------------------------------------------------------
int __cdecl sub_80A5E62(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A5E32(a1, a2)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A5E90) --------------------------------------------------------
int __cdecl sub_80A5E90(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4B2C(a1, a2)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A5EBE) --------------------------------------------------------
int __cdecl sub_80A5EBE(unsigned __int16 a1, unsigned __int16 a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4B2C(a1, a2 + 0x10000)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A5EF8) --------------------------------------------------------
int __cdecl sub_80A5EF8(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)sub_80A4C6A(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A5F28) --------------------------------------------------------
int __cdecl sub_80A5F28(unsigned __int16 a1, unsigned __int16 a2)
{
  int v3; // [esp+10h] [ebp-18h]
  __int16 v4; // [esp+16h] [ebp-12h]
  int *v5; // [esp+18h] [ebp-10h]
  int *v6; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+20h] [ebp-8h]
  unsigned __int16 v8; // [esp+22h] [ebp-6h]

  v8 = sub_80A4B2C(a1, a2);
  if ( v8 )
    return (unsigned __int16)word_82C6CA0[2 * v8];
  v5 = &dword_8206CA0[3 * a1];
  if ( (v5[1] & 0x1Fu) > 0xF )
  {
    sub_80A667C(word_80EE90E);
    v3 = (unsigned __int16)word_80EE90E;
  }
  else if ( (v5[1] & 0x1F) == 13
         && (v7 = sub_80A5E62(*(_WORD *)(dword_8306CA0 + 8 * ((unsigned int)v5[1] >> 8)), a2)) != 0 )
  {
    v4 = *((_WORD *)v5 + 1);
    sub_80A667C(word_80EE90E);
    v6 = &dword_8206CA0[3 * (unsigned __int16)word_80EE90E];
    v6[1] |= v5[1] & 0xFFFFFF00 | 8;
    *(_WORD *)v6 = v4;
    *((_WORD *)v6 + 1) = HIWORD(dword_8206CA0[3 * v7]);
    v3 = (unsigned __int16)word_80EE90E;
  }
  else
  {
    v3 = (unsigned __int16)sub_80A61E0(a1, a2);
  }
  return v3;
}
// 80EE90E: using guessed type __int16 word_80EE90E;
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];
// 8306CA0: using guessed type int dword_8306CA0;

//----- (080A60BE) --------------------------------------------------------
unsigned int __cdecl sub_80A60BE(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned int result; // eax
  int *v3; // [esp+Ch] [ebp-Ch]

  if ( (unsigned __int16)sub_80A4B2C(a1, a2) )
    return sub_80A6248(a1, a2);
  v3 = &dword_8206CA0[3 * a1];
  result = v3[1] & 0x1F;
  if ( result <= 0xF )
  {
    result = v3[1] & 0x1F;
    if ( result == 13 )
    {
      result = sub_80A5E62(*(_WORD *)(dword_8306CA0 + 8 * ((unsigned int)v3[1] >> 8)), a2);
      if ( (_WORD)result )
        result = Scr_Error((int)"cannot set entity builtin key/value to undefined");
    }
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8306CA0: using guessed type int dword_8306CA0;

//----- (080A6184) --------------------------------------------------------
int __cdecl sub_80A6184(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A5EF8(a1, a2)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A61B2) --------------------------------------------------------
int __cdecl sub_80A61B2(unsigned __int16 a1, int a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A5EF8(a1, a2)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A61E0) --------------------------------------------------------
int __cdecl sub_80A61E0(unsigned __int16 a1, unsigned int a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4C6A(a1, a2)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A620E) --------------------------------------------------------
int __cdecl sub_80A620E(unsigned __int16 a1, unsigned __int16 a2)
{
  return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4C6A(a1, a2 + 0x10000)];
}
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A6248) --------------------------------------------------------
int __cdecl sub_80A6248(unsigned __int16 a1, int a2)
{
  int *v3; // [esp+Ch] [ebp-Ch]
  __int16 *v4; // [esp+10h] [ebp-8h]

  v4 = &word_82C6CA0[2 * (unsigned __int16)sub_80A4B2C(a1, a2)];
  v3 = &dword_8206CA0[3 * (unsigned __int16)*v4];
  sub_80A5160(v4, (int)&dword_8206CA0[3 * a1]);
  return sub_80A5B60(v3);
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A62D2) --------------------------------------------------------
int __cdecl sub_80A62D2(unsigned __int16 a1, unsigned __int16 a2)
{
  return sub_80A6248(a1, a2 + 0x10000);
}

//----- (080A6302) --------------------------------------------------------
int __cdecl sub_80A6302(unsigned __int16 a1, int a2)
{
  return sub_80A635A(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A632E) --------------------------------------------------------
int __cdecl sub_80A632E(unsigned __int16 a1, int a2)
{
  return sub_80A6248(a1, (a2 + 0x800000) & 0xFFFFFF);
}

//----- (080A635A) --------------------------------------------------------
int __cdecl sub_80A635A(unsigned __int16 a1, int a2)
{
  int result; // eax
  int *v3; // [esp+Ch] [ebp-Ch]

  result = sub_80A4B2C(a1, a2);
  if ( (_WORD)result )
  {
    v3 = &dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)result]];
    sub_80A5160(&word_82C6CA0[2 * (unsigned __int16)result], (int)&dword_8206CA0[3 * a1]);
    result = sub_80A5B60(v3);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A63EE) --------------------------------------------------------
int __cdecl sub_80A63EE(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 i; // [esp+16h] [ebp-22h]
  int *v4; // [esp+1Ch] [ebp-1Ch]
  int *v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+24h] [ebp-14h]

  for ( i = word_82C6CA0[2 * (unsigned __int16)word_8206CAA[6 * a1]];
        ;
        i = word_82C6CA0[2 * (unsigned __int16)word_8206CAA[6 * i]] )
  {
    result = i;
    if ( i == a1 )
      break;
    v5 = &dword_8206CA0[3 * i];
    v6 = v5[1] & 0x1F;
    v4 = &dword_8206CA0[3
                      * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4C6A(a2, (unsigned int)v5[1] >> 8)]];
    v4[1] |= v6;
    if ( v6 == 7 )
    {
      if ( (dword_8206CA4[3 * *(unsigned __int16 *)v5] & 0x1F) == 15 )
      {
        *(_WORD *)v4 = sub_80A5AB4();
        sub_80A63EE(*(unsigned __int16 *)v5, *(unsigned __int16 *)v4);
      }
      else
      {
        *(_WORD *)v4 = *(_WORD *)v5;
        sub_80A5BCE(*(_WORD *)v5);
      }
    }
    else
    {
      *v4 = *v5;
      sub_80A5D56(v6, *v5);
    }
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA4: using guessed type int dword_8206CA4[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A6598) --------------------------------------------------------
int __cdecl sub_80A6598(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+10h] [ebp-8h]

  v3 = &dword_8206CA0[3 * a1];
  sub_80A5DA8(v3[1] & 0x1F, *v3);
  v3[1] &= 0xFFFFFFE0;
  v3[1] |= a2[1];
  result = *a2;
  *v3 = *a2;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6608) --------------------------------------------------------
int __cdecl sub_80A6608(unsigned __int16 a1, int *a2)
{
  int result; // eax

  dword_8206CA0[3 * a1 + 1] |= a2[1];
  result = *a2;
  dword_8206CA0[3 * a1] = *a2;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A664E) --------------------------------------------------------
int *__cdecl GetVariableValueAddress(unsigned __int16 a1)
{
  return &dword_8206CA0[3 * a1];
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A667C) --------------------------------------------------------
int __cdecl sub_80A667C(unsigned __int16 a1)
{
  int result; // eax
  int *v2; // [esp+10h] [ebp-8h]

  v2 = &dword_8206CA0[3 * a1];
  sub_80A5DA8(v2[1] & 0x1F, *v2);
  result = v2[1] & 0x60;
  v2[1] = result;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A66D0) --------------------------------------------------------
int __cdecl sub_80A66D0(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+20h] [ebp-8h]

  v3 = &dword_8206CA0[3 * a1];
  switch ( v3[1] & 0x1F )
  {
    case 1:
    case 2:
      sub_80A40A6(*(_WORD *)v3);
      goto LABEL_6;
    case 3:
      sub_80A5D00(*v3);
      goto LABEL_6;
    case 7:
      sub_80A5C0A(*(_WORD *)v3);
      goto LABEL_6;
    case 8:
      return sub_80AF5D0((unsigned int)v3[1] >> 8, *(unsigned __int16 *)v3, *((unsigned __int16 *)v3 + 1), (int)a2);
    default:
LABEL_6:
      v3[1] &= 0xFFFFFFE0;
      v3[1] |= a2[1];
      result = *a2;
      *v3 = *a2;
      return result;
  }
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A67A2) --------------------------------------------------------
int __cdecl sub_80A67A2(unsigned __int16 a1, int *a2)
{
  int result; // eax
  int *v3; // [esp+0h] [ebp-8h]

  v3 = &dword_8206CA0[3 * a1];
  a2[1] = v3[1] & 0x1F;
  result = *v3;
  *a2 = *v3;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A67E6) --------------------------------------------------------
int __cdecl sub_80A67E6(unsigned __int16 a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int *v4; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+22h] [ebp-6h]

  v4 = &dword_8206CA0[3 * a1];
  v3 = v4[1] & 0x1F;
  switch ( v3 )
  {
    case 1:
    case 2:
      sub_80A3F08(*(_WORD *)v4);
      goto LABEL_8;
    case 3:
      sub_80A5CD2(*v4);
      goto LABEL_8;
    case 7:
      sub_80A5BCE(*(_WORD *)v4);
      goto LABEL_8;
    case 8:
      sub_80AF62A((unsigned int)v4[1] >> 8, *(unsigned __int16 *)v4, *((unsigned __int16 *)v4 + 1), (int)a2);
      result = (int)a2;
      if ( *((_DWORD *)a2 + 1) == 7 )
      {
        result = dword_8206CA0[3 * *a2 + 1] & 0x1F;
        if ( result == 15 )
        {
          v5 = *a2;
          sub_80A5C0A(*a2);
          *a2 = sub_80A5AB4();
          result = sub_80A63EE(v5, *a2);
        }
      }
      return result;
    default:
LABEL_8:
      *((_DWORD *)a2 + 1) = v3;
      result = *v4;
      *(_DWORD *)a2 = *v4;
      return result;
  }
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A691A) --------------------------------------------------------
int __cdecl sub_80A691A(unsigned __int16 *a1)
{
  int result; // eax
  const char *v2; // eax
  char *v3; // eax
  int v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  int *v7; // [esp+20h] [ebp-8h]

  if ( *((_DWORD *)a1 + 1) == 7 )
  {
    v6 = *a1;
    v7 = &dword_8206CA0[3 * *a1];
    *((_DWORD *)a1 + 1) = 5;
    if ( (v7[1] & 0x1F) == 15 )
      v4 = *((unsigned __int16 *)v7 + 1);
    else
      v4 = 1;
    *(_DWORD *)a1 = v4;
    result = sub_80A5C0A(v6);
  }
  else if ( *((_DWORD *)a1 + 1) == 1 )
  {
    *((_DWORD *)a1 + 1) = 5;
    v5 = *a1;
    v2 = (const char *)SL_ConvertToString(*a1);
    *(_DWORD *)a1 = strlen(v2);
    result = sub_80A40A6(v5);
  }
  else
  {
    v3 = va("size cannot be applied to %s", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
    result = Scr_Error((int)v3);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6A06) --------------------------------------------------------
int __cdecl sub_80A6A06(unsigned __int16 a1)
{
  return HIWORD(dword_8206CA0[3 * a1]);
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6A38) --------------------------------------------------------
int __cdecl FindNextSibling(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-10h]
  unsigned __int16 v3; // [esp+6h] [ebp-Ah]

  v3 = word_8206CAA[6 * a1];
  if ( (dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * v3] + 1] & 0x1Fu) > 0xB )
    v2 = 0;
  else
    v2 = (unsigned __int16)word_82C6CA0[2 * v3];
  return v2;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A6AAC) --------------------------------------------------------
unsigned int __cdecl GetVariableName(unsigned __int16 a1)
{
  return (unsigned int)dword_8206CA4[3 * a1] >> 8;
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A6AD2) --------------------------------------------------------
int __cdecl sub_80A6AD2(unsigned __int16 a1)
{
  int *v2; // [esp+Ch] [ebp-Ch]

  v2 = &dword_8206CA0[3 * a1];
  if ( (v2[1] & 0x1F) == 0 )
  {
    v2[1] |= 7u;
    *(_WORD *)v2 = sub_80A5A30();
  }
  return *(unsigned __int16 *)v2;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6B2E) --------------------------------------------------------
int __cdecl sub_80A6B2E(unsigned __int16 a1)
{
  int *v2; // [esp+Ch] [ebp-Ch]

  v2 = &dword_8206CA0[3 * a1];
  if ( (v2[1] & 0x1F) == 0 )
  {
    v2[1] |= 7u;
    *(_WORD *)v2 = sub_80A5AB4();
  }
  return *(unsigned __int16 *)v2;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6B8A) --------------------------------------------------------
int __cdecl sub_80A6B8A(unsigned __int16 a1)
{
  return LOWORD(dword_8206CA0[3 * a1]);
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6BBA) --------------------------------------------------------
_BOOL4 __cdecl sub_80A6BBA(unsigned __int16 a1)
{
  return (dword_8206CA0[3 * a1 + 1] & 0x1Fu) <= 0xE;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6C00) --------------------------------------------------------
_BOOL4 __cdecl sub_80A6C00(unsigned __int16 a1)
{
  return (dword_8206CA0[3 * a1 + 1] & 0x1F) == 12;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6C46) --------------------------------------------------------
int __cdecl sub_80A6C46(unsigned __int16 *a1)
{
  char *v1; // eax
  char *v2; // eax
  int v5[3]; // [esp+18h] [ebp-10h] BYREF
  int v6; // [esp+24h] [ebp-4h]

  if ( *((_DWORD *)a1 + 1) != 7 )
    goto LABEL_5;
  v6 = dword_8206CA4[3 * *a1] & 0x1F;
  if ( v6 > 14 )
  {
    v1 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * (dword_8206CA4[3 * *a1] & 0x1F)]);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
    Scr_Error((int)v2);
    return 0;
  }
  v5[1] = 7;
  LOWORD(v5[0]) = *a1;
  sub_80A6598(word_80EE90E, v5);
  return LOWORD(v5[0]);
}
// 80EE90E: using guessed type __int16 word_80EE90E;
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A6D12) --------------------------------------------------------
int __cdecl sub_80A6D12(unsigned __int16 a1)
{
  return dword_8206CA4[3 * a1] & 0x1F;
}
// 8206CA4: using guessed type int dword_8206CA4[];

//----- (080A6D38) --------------------------------------------------------
void __cdecl sub_80A6D38(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  unsigned __int16 v4; // [esp+14h] [ebp-4h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  if ( byte_80EE910 )
  {
    v2 = sub_80A5E90(word_80EE8A2, a2);
    v5 = sub_80A6B8A(v2);
    v4 = sub_80A5E62(v5, a1);
    if ( v4 )
    {
      v3 = sub_80A6B8A(v4);
      dword_8206CA0[3 * v3 + 1] &= 0xFFFFFFE0;
      dword_8206CA0[3 * v3 + 1] |= 0x11u;
      sub_80A5BCE(v3);
      sub_80ADC4E(v3);
      sub_80A53C2(v3);
      sub_80A5C0A(v3);
      sub_80A632E(v5, a1);
    }
  }
}
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 80EE910: using guessed type char byte_80EE910;
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A6E22) --------------------------------------------------------
unsigned int __cdecl sub_80A6E22(int a1, unsigned int a2)
{
  unsigned int result; // eax
  unsigned __int16 v3; // ax
  unsigned __int16 v4; // ax
  unsigned int i; // [esp+Ch] [ebp-Ch]

  dword_8306CA0 = a1;
  dword_8306CA4 = a2;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v3 = sub_80A61E0(word_80EE8A2, i);
    sub_80A6B2E(v3);
    v4 = sub_80A61E0(word_80EE8A0, i);
    *(_WORD *)(a1 + 8 * i) = sub_80A6B2E(v4);
  }
  return result;
}
// 80EE8A0: using guessed type __int16 word_80EE8A0;
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 8306CA0: using guessed type int dword_8306CA0;
// 8306CA4: using guessed type int dword_8306CA4;

//----- (080A6EAC) --------------------------------------------------------
unsigned int sub_80A6EAC()
{
  unsigned int result; // eax
  unsigned int i; // [esp+14h] [ebp-4h]

  if ( byte_80EE910 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_8306CA4 )
        break;
      sub_80A635A(word_80EE8A0, i);
      sub_80A635A(word_80EE8A2, i);
    }
  }
  return result;
}
// 80EE8A0: using guessed type __int16 word_80EE8A0;
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 80EE910: using guessed type char byte_80EE910;
// 8306CA4: using guessed type int dword_8306CA4;

//----- (080A6F06) --------------------------------------------------------
int __cdecl sub_80A6F06(int a1, char *s, int a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int *v6; // [esp+1Ch] [ebp-Ch]
  int *v7; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v8; // [esp+22h] [ebp-6h]
  int v9; // [esp+24h] [ebp-4h]

  HIWORD(v9) = a1;
  LOWORD(v9) = a3;
  v4 = sub_80A11D2(s);
  if ( v4 )
  {
    v6 = &dword_8206CA0[3 * (unsigned __int16)sub_80A6184(a1, v4)];
    v6[1] &= 0xFFFFFFE0;
    v6[1] |= 5u;
    *((_WORD *)v6 + 1) = a3;
  }
  v5 = sub_80A3D64(s, 0);
  v8 = sub_80A61E0(a1, v5);
  sub_80A40A6(v5);
  v7 = &dword_8206CA0[3 * v8];
  v7[1] &= 0xFFFFFFE0;
  v7[1] |= 5u;
  result = v9;
  *((_WORD *)v7 + 1) = a3;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A7014) --------------------------------------------------------
int __cdecl sub_80A7014(unsigned __int16 a1, int a2)
{
  unsigned __int16 v2; // ax
  int v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]

  v2 = sub_80A3496(a2);
  v5 = sub_80A5E90(a1, v2);
  if ( v5 )
    v4 = HIWORD(dword_8206CA0[3 * v5]);
  else
    v4 = -1;
  return v4;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A7074) --------------------------------------------------------
int __cdecl sub_80A7074(int a1, int a2)
{
  unsigned __int16 v2; // ax
  int v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v2 = sub_80A5E90(word_80EE8A2, a2);
  v6 = sub_80A6B8A(v2);
  v5 = sub_80A5E62(v6, a1);
  if ( v5 )
    v4 = LOWORD(dword_8206CA0[3 * v5]);
  else
    v4 = 0;
  return v4;
}
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A70F0) --------------------------------------------------------
int __cdecl sub_80A70F0(int a1, int a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int *v6; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+14h] [ebp-4h]
  unsigned __int16 v8; // [esp+16h] [ebp-2h]

  v2 = sub_80A5E90(word_80EE8A2, a2);
  v8 = sub_80A6B8A(v2);
  v7 = sub_80A61B2(v8, a1);
  v6 = &dword_8206CA0[3 * v7];
  if ( (v6[1] & 0x1F) != 0 )
    return *(unsigned __int16 *)v6;
  v3 = sub_80A5A66(a2, a1);
  dword_8206CA0[3 * v7 + 1] |= 7u;
  LOWORD(dword_8206CA0[3 * v7]) = v3;
  return v3;
}
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A71BC) --------------------------------------------------------
int __cdecl sub_80A71BC(int *a1, unsigned __int16 *a2)
{
  int result; // eax
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax
  char *v9; // eax
  char *v10; // eax
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  char s2[2]; // [esp+26h] [ebp-12h] BYREF
  char *s; // [esp+28h] [ebp-10h]
  unsigned __int16 v15; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v16; // [esp+2Eh] [ebp-Ah]
  int *v17; // [esp+30h] [ebp-8h]

  v11 = *((_DWORD *)a2 + 1);
  if ( v11 == 3 )
  {
LABEL_13:
    if ( a1[1] == 5 )
    {
      if ( (unsigned int)*a1 <= 2 )
      {
        s = *(char **)a2;
        a1[1] = 4;
        *a1 = *(_DWORD *)&s[4 * *a1];
        return sub_80A5D00((int)s);
      }
      v5 = va("vector index %d out of range", *a1);
      Scr_Error((int)v5);
    }
    v6 = va("%s is not a vector index", *(const char **)&off_80EE8C0[4 * a1[1]]);
    Scr_Error((int)v6);
    goto LABEL_18;
  }
  if ( v11 <= 3 )
  {
    if ( v11 != 1 )
    {
LABEL_30:
      dword_830AD68 = 1;
      v10 = va("%s is not an array, string, or vector", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a2 + 1)]);
      return Scr_Error((int)v10);
    }
    if ( a1[1] == 5 )
    {
      if ( *a1 >= 0 )
      {
        v15 = *a2;
        s = (char *)SL_ConvertToString(v15);
        if ( *a1 < strlen(s) )
        {
          a1[1] = 1;
          s2[0] = s[*a1];
          s2[1] = 0;
          *(_WORD *)a1 = sub_80A388C(s2, 0, 2u);
          return sub_80A40A6(v15);
        }
      }
      v3 = va("string index %d out of range", *a1);
      Scr_Error((int)v3);
    }
    v4 = va("%s is not a string index", *(const char **)&off_80EE8C0[4 * a1[1]]);
    Scr_Error((int)v4);
    goto LABEL_13;
  }
  if ( v11 != 7 )
    goto LABEL_30;
LABEL_18:
  v17 = &dword_8206CA0[3 * *a2];
  if ( (v17[1] & 0x1F) != 15 )
  {
    dword_830AD68 = 1;
    v7 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * (v17[1] & 0x1F)]);
    Scr_Error((int)v7);
  }
  v12 = a1[1];
  if ( v12 != 1 )
  {
    if ( v12 != 5 )
    {
      v9 = va("%s is not an array index", *(const char **)&off_80EE8C0[4 * a1[1]]);
      return Scr_Error((int)v9);
    }
    if ( sub_80A5DFA(*a1) )
    {
      v16 = word_82C6CA0[2 * (unsigned __int16)sub_80A5E32(*a2, *a1)];
      goto LABEL_27;
    }
    v8 = va("array index %d out of range", *a1);
    Scr_Error((int)v8);
  }
  v16 = word_82C6CA0[2 * (unsigned __int16)sub_80A4B2C(*a2, *(unsigned __int16 *)a1)];
  sub_80A40A6(*(_WORD *)a1);
LABEL_27:
  if ( v16 )
  {
    sub_80A67A2(v16, a1);
    sub_80A9734(a1);
    result = sub_80A5C0A(*a2);
  }
  else
  {
    sub_80A5C0A(*a2);
    result = (int)a1;
    a1[1] = 0;
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];
// 830AD68: using guessed type int dword_830AD68;

//----- (080A750E) --------------------------------------------------------
int __cdecl sub_80A750E(unsigned __int16 a1, unsigned __int16 *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v9; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+28h] [ebp-10h]
  __int16 v12; // [esp+2Ah] [ebp-Eh]
  int *v13; // [esp+2Ch] [ebp-Ch]
  int *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 v15; // [esp+36h] [ebp-2h]

  v15 = a1;
  v14 = &dword_8206CA0[3 * a1];
  v10 = v14[1] & 0x1F;
  v9 = *v14;
  while ( v10 != 7 )
  {
    if ( v10 != 8 )
    {
      dword_830AD68 = 1;
      v3 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * v10]);
      Scr_Error((int)v3);
      break;
    }
    sub_80AF62A((unsigned int)v14[1] >> 8, *(unsigned __int16 *)v14, *((unsigned __int16 *)v14 + 1), (int)(a2 + 4));
    v2 = *((_DWORD *)a2 + 3);
    v9 = *((_DWORD *)a2 + 2);
    v10 = v2;
    sub_80A9754(&v9);
  }
  v12 = v9;
  v13 = &dword_8206CA0[3 * (unsigned __int16)v9];
  if ( (v13[1] & 0x1F) != 15 )
  {
    dword_830AD68 = 1;
    v4 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * (v13[1] & 0x1F)]);
    Scr_Error((int)v4);
  }
  if ( *((_DWORD *)a2 + 1) != 5 )
  {
    if ( *((_DWORD *)a2 + 1) == 1 )
    {
      v11 = sub_80A4B2C(v9, *a2);
      if ( v11 )
      {
        sub_80A40A6(*a2);
        return (unsigned __int16)word_82C6CA0[2 * v11];
      }
    }
    else
    {
      v6 = va("%s is not an array index", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a2 + 1)]);
      Scr_Error((int)v6);
    }
    goto LABEL_17;
  }
  if ( !sub_80A5DFA(*(_DWORD *)a2) )
  {
    v5 = va("array index %d out of range", *(_DWORD *)a2);
    Scr_Error((int)v5);
    goto LABEL_17;
  }
  v11 = sub_80A5E32(v9, *(_DWORD *)a2);
  if ( !v11 )
  {
LABEL_17:
    Scr_Error((int)"array index does not exist");
    return 0;
  }
  return (unsigned __int16)word_82C6CA0[2 * v11];
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];
// 830AD68: using guessed type int dword_830AD68;

//----- (080A772E) --------------------------------------------------------
int __cdecl sub_80A772E(unsigned __int16 a1, int *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  int v8; // [esp+1Ch] [ebp-1Ch]
  int i; // [esp+20h] [ebp-18h] BYREF
  int v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  int *v12; // [esp+2Ch] [ebp-Ch]
  int *v13; // [esp+30h] [ebp-8h]
  unsigned __int16 v14; // [esp+36h] [ebp-2h]

  v14 = a1;
  v13 = &dword_8206CA0[3 * a1];
  v10 = v13[1] & 0x1F;
  for ( i = *v13; ; sub_80A9754(&i) )
  {
    if ( !v10 )
    {
      v10 = 7;
      LOWORD(i) = sub_80A5AB4();
      v13[1] |= 7u;
      *v13 = i;
      goto LABEL_17;
    }
    if ( v10 == 7 )
      break;
    if ( v10 != 8 )
    {
      dword_830AD68 = 1;
      if ( v10 == 1 )
      {
        Scr_Error((int)"string characters cannot be individually changed");
      }
      else if ( v10 != 3 )
      {
        goto LABEL_12;
      }
      Scr_Error((int)"vector components cannot be individually changed");
LABEL_12:
      v3 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * v10]);
      Scr_Error((int)v3);
      break;
    }
    sub_80AF62A((unsigned int)v13[1] >> 8, *(unsigned __int16 *)v13, *((unsigned __int16 *)v13 + 1), (int)(a2 + 2));
    v2 = a2[3];
    i = a2[2];
    v10 = v2;
  }
  v12 = &dword_8206CA0[3 * (unsigned __int16)i];
  if ( (v12[1] & 0x1F) != 15 )
  {
    dword_830AD68 = 1;
    v4 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * (v12[1] & 0x1F)]);
    Scr_Error((int)v4);
  }
  if ( *(_WORD *)v12 )
  {
    v11 = i;
    sub_80A5C0A(i);
    LOWORD(i) = sub_80A5AB4();
    sub_80A63EE(v11, i);
    *v13 = i;
  }
LABEL_17:
  if ( a2[1] == 5 )
  {
    if ( sub_80A5DFA(*a2) )
      return (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A5EF8(i, *a2)];
    v5 = va("array index %d out of range", *a2);
    Scr_Error((int)v5);
  }
  if ( a2[1] == 1 )
  {
    v11 = word_82C6CA0[2 * (unsigned __int16)sub_80A4C6A(i, *(unsigned __int16 *)a2)];
    sub_80A40A6(*(_WORD *)a2);
    v8 = v11;
  }
  else
  {
    v6 = va("%s is not an array index", *(const char **)&off_80EE8C0[4 * a2[1]]);
    Scr_Error((int)v6);
    v8 = 0;
  }
  return v8;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];
// 830AD68: using guessed type int dword_830AD68;

//----- (080A79C6) --------------------------------------------------------
int __cdecl sub_80A79C6(unsigned __int16 a1, int *a2)
{
  int v2; // edx
  char *v3; // eax
  char *v4; // eax
  int result; // eax
  char *v6; // eax
  char *v7; // eax
  int v8; // [esp+10h] [ebp-18h] BYREF
  int v9; // [esp+14h] [ebp-14h]
  unsigned __int16 v10; // [esp+1Ah] [ebp-Eh]
  int *v11; // [esp+1Ch] [ebp-Ch]
  int *v12; // [esp+20h] [ebp-8h]
  unsigned __int16 v13; // [esp+26h] [ebp-2h]

  v13 = a1;
  v12 = &dword_8206CA0[3 * a1];
  v9 = v12[1] & 0x1F;
  v8 = *v12;
  while ( v9 != 7 )
  {
    if ( v9 != 8 )
    {
      dword_830AD68 = 1;
      v3 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * v9]);
      Scr_Error((int)v3);
      break;
    }
    sub_80AF62A((unsigned int)v12[1] >> 8, *(unsigned __int16 *)v12, *((unsigned __int16 *)v12 + 1), (int)(a2 + 2));
    v2 = a2[3];
    v8 = a2[2];
    v9 = v2;
    sub_80A9754(&v8);
  }
  v11 = &dword_8206CA0[3 * (unsigned __int16)v8];
  if ( (v11[1] & 0x1F) != 15 )
  {
    dword_830AD68 = 1;
    v4 = va("%s is not an array", *(const char **)&off_80EE8C0[4 * (v11[1] & 0x1F)]);
    Scr_Error((int)v4);
  }
  if ( *(_WORD *)v11 )
  {
    v10 = v8;
    sub_80A5C0A(v8);
    LOWORD(v8) = sub_80A5AB4();
    sub_80A63EE(v10, v8);
    *v12 = v8;
  }
  if ( a2[1] == 5 )
  {
    if ( sub_80A5DFA(*a2) )
      return sub_80A6302(v8, *a2);
    v6 = va("array index %d out of range", *a2);
    Scr_Error((int)v6);
  }
  if ( a2[1] == 1 )
  {
    sub_80A635A(v8, *(unsigned __int16 *)a2);
    result = sub_80A40A6(*(_WORD *)a2);
  }
  else
  {
    v7 = va("%s is not an array index", *(const char **)&off_80EE8C0[4 * a2[1]]);
    result = Scr_Error((int)v7);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 830AD68: using guessed type int dword_830AD68;

//----- (080A7BCC) --------------------------------------------------------
int __cdecl sub_80A7BCC(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 4) = 7;
  result = sub_80A5AB4();
  *(_WORD *)a1 = result;
  return result;
}

//----- (080A7BEE) --------------------------------------------------------
int __cdecl sub_80A7BEE(unsigned __int16 a1)
{
  int result; // eax

  dword_8206CA0[3 * a1 + 1] |= 7u;
  result = sub_80A5AB4();
  LOWORD(dword_8206CA0[3 * a1]) = result;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A7C38) --------------------------------------------------------
int __cdecl sub_80A7C38(unsigned __int16 a1)
{
  return HIWORD(dword_8206CA0[3 * a1]);
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A7C5C) --------------------------------------------------------
int __cdecl sub_80A7C5C(unsigned __int16 a1, unsigned __int16 a2)
{
  int result; // eax
  unsigned __int16 v3; // ax
  int *v4; // ecx
  unsigned int v5; // [esp+Ch] [ebp-1Ch]
  int *v6; // [esp+14h] [ebp-14h]
  unsigned int v7; // [esp+18h] [ebp-10h]
  unsigned __int16 i; // [esp+1Eh] [ebp-Ah]

  result = FindNextSibling(a1);
  for ( i = result; i; i = result )
  {
    v6 = &dword_8206CA0[3 * i];
    v7 = (unsigned int)v6[1] >> 8;
    if ( v7 != 0x20000 )
    {
      v3 = sub_80A4C6A(a2, v7);
      v5 = v6[1] & 0xFFFFFF9F;
      v4 = &dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * v3]];
      v4[1] |= v5;
      *v4 = *v6;
      sub_80A5D56(v5 & 0x1F, *v4);
    }
    result = FindNextSibling(i);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A7D62) --------------------------------------------------------
int __cdecl sub_80A7D62(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  result = sub_80A7074(a1, a3);
  v5 = result;
  if ( (_WORD)result )
  {
    result = FindNextSibling(result);
    if ( (_WORD)result )
    {
      v4 = sub_80A70F0(a2, a3);
      result = sub_80A7C5C(v5, v4);
    }
  }
  return result;
}

//----- (080A7DC0) --------------------------------------------------------
int __cdecl sub_80A7DC0(unsigned __int8 a1)
{
  unsigned __int8 *v1; // edx
  int result; // eax

  v1 = (unsigned __int8 *)sub_80A4460(1);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A7DE2) --------------------------------------------------------
int sub_80A7DE2()
{
  return (unsigned __int8)*dword_8306CB4++;
}

//----- (080A7E00) --------------------------------------------------------
int __cdecl sub_80A7E00(unsigned __int16 a1)
{
  unsigned __int16 *v1; // edx
  int result; // eax

  v1 = (unsigned __int16 *)sub_80A4460(2);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A7E24) --------------------------------------------------------
int sub_80A7E24()
{
  unsigned __int16 v1; // [esp+2h] [ebp-2h]

  v1 = *(_WORD *)dword_8306CB4;
  dword_8306CB4 += 2;
  return v1;
}

//----- (080A7E44) --------------------------------------------------------
char *__cdecl sub_80A7E44(unsigned __int16 a1)
{
  size_t v1; // eax
  char *v2; // eax
  char *s; // [esp+10h] [ebp-8h]

  s = (char *)SL_ConvertToString(a1);
  v1 = strlen(s);
  v2 = (char *)sub_80A4460(v1 + 1);
  return strcpy(v2, s);
}

//----- (080A7E88) --------------------------------------------------------
char *__cdecl sub_80A7E88(unsigned __int16 a1)
{
  if ( !a1 )
    return (char *)sub_80A7DC0(0);
  sub_80A7DC0(1u);
  return sub_80A7E44(a1);
}

//----- (080A7EC4) --------------------------------------------------------
int sub_80A7EC4()
{
  size_t n; // [esp+10h] [ebp-8h]
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  n = strlen(dword_8306CB4) + 1;
  v2 = sub_80A388C(dword_8306CB4, 0, n);
  dword_8306CB4 += n;
  return v2;
}

//----- (080A7F12) --------------------------------------------------------
int sub_80A7F12()
{
  int v1; // [esp+4h] [ebp-4h]

  if ( (unsigned __int8)sub_80A7DE2() )
    v1 = (unsigned __int16)sub_80A7EC4();
  else
    v1 = 0;
  return v1;
}

//----- (080A7F3A) --------------------------------------------------------
int __cdecl sub_80A7F3A(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = (_DWORD *)sub_80A4460(4);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A7F56) --------------------------------------------------------
long double sub_80A7F56()
{
  float v1; // [esp+4h] [ebp-4h]

  v1 = *(float *)dword_8306CB4;
  dword_8306CB4 += 4;
  return v1;
}

//----- (080A7F78) --------------------------------------------------------
int __cdecl sub_80A7F78(int *a1)
{
  sub_80A7F3A(*a1);
  sub_80A7F3A(a1[1]);
  return sub_80A7F3A(a1[2]);
}

//----- (080A7FAE) --------------------------------------------------------
_DWORD *sub_80A7FAE()
{
  float v1[6]; // [esp+10h] [ebp-18h] BYREF

  v1[0] = sub_80A7F56();
  v1[1] = sub_80A7F56();
  v1[2] = sub_80A7F56();
  return sub_80A5C94(v1);
}

//----- (080A7FDA) --------------------------------------------------------
int __cdecl sub_80A7FDA(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = (_DWORD *)sub_80A4460(4);
  result = a1;
  *v1 = a1;
  return result;
}

//----- (080A7FF6) --------------------------------------------------------
int sub_80A7FF6()
{
  int v1; // [esp+0h] [ebp-4h]

  v1 = *(_DWORD *)dword_8306CB4;
  dword_8306CB4 += 4;
  return v1;
}

//----- (080A8012) --------------------------------------------------------
int __cdecl sub_80A8012(int a1)
{
  int result; // eax

  if ( a1 )
    result = sub_80A7FDA(a1 - dword_80EE864);
  else
    result = sub_80A7FDA(-1);
  return result;
}
// 80EE864: using guessed type int dword_80EE864;

//----- (080A8042) --------------------------------------------------------
int sub_80A8042()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = sub_80A7FF6();
  if ( v2 < 0 )
    v1 = 0;
  else
    v1 = v2 + dword_80EE864;
  return v1;
}
// 80EE864: using guessed type int dword_80EE864;

//----- (080A8078) --------------------------------------------------------
int __cdecl sub_80A8078(unsigned __int16 a1)
{
  return sub_80A7E00(*((_WORD *)dword_8306CAC + a1));
}

//----- (080A80A0) --------------------------------------------------------
int sub_80A80A0()
{
  unsigned __int16 v1; // [esp+6h] [ebp-2h]

  v1 = *((_WORD *)dword_8306CB0 + (unsigned __int16)sub_80A7E24());
  sub_80A5BCE(v1);
  return v1;
}

//----- (080A80D0) --------------------------------------------------------
void *__cdecl sub_80A80D0(void *src, size_t n)
{
  void *v2; // eax

  v2 = (void *)sub_80A4460(n);
  return sub_80D2FC8(v2, src, n);
}

//----- (080A80FC) --------------------------------------------------------
size_t __cdecl sub_80A80FC(void *dest, size_t n)
{
  size_t result; // eax

  sub_80D2FC8(dest, dword_8306CB4, n);
  result = n;
  dword_8306CB4 += n;
  return result;
}

//----- (080A8128) --------------------------------------------------------
int __cdecl sub_80A8128(unsigned __int16 a1)
{
  if ( !a1 )
    return 0;
  sub_80A86C6(a1);
  return *((unsigned __int16 *)dword_8306CAC + a1);
}

//----- (080A816A) --------------------------------------------------------
int __cdecl sub_80A816A(unsigned __int16 a1)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  if ( !a1 )
    return 0;
  v3 = *((_WORD *)dword_8306CB0 + a1);
  sub_80A5BCE(v3);
  return v3;
}

//----- (080A81B4) --------------------------------------------------------
int __cdecl sub_80A81B4(int a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+Ah] [ebp-Eh]
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v4; // [esp+13h] [ebp-5h]
  _BYTE *v5; // [esp+14h] [ebp-4h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  v2 = *(_WORD *)(a1 + 8);
  sub_80A7E00(v2);
  sub_80A7FDA(*(_DWORD *)a1);
  sub_80A8012(*(_DWORD *)(a1 + 4));
  sub_80A8078(*(_WORD *)(a1 + 10));
  result = a1 + 12;
  v5 = (_BYTE *)(a1 + 12);
  while ( v2 )
  {
    --v2;
    v4 = *v5;
    v6 = v5 + 1;
    v3 = *v6;
    v5 = v6 + 1;
    result = sub_80A845E(v4, v3);
  }
  return result;
}
// 80A845E: using guessed type _DWORD __cdecl sub_80A845E(_DWORD, _DWORD);

//----- (080A824A) --------------------------------------------------------
int sub_80A824A()
{
  int v1; // [esp+8h] [ebp-20h] BYREF
  char v2; // [esp+Ch] [ebp-1Ch]
  int v3; // [esp+14h] [ebp-14h]
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]

  v4 = sub_80A7E24();
  v3 = sub_80A1F70(5 * v4 + 12);
  *(_WORD *)(v3 + 8) = v4;
  *(_DWORD *)v3 = sub_80A7FF6();
  *(_DWORD *)(v3 + 4) = sub_80A8042();
  *(_WORD *)(v3 + 10) = sub_80A80A0();
  v5 = (_DWORD *)(v3 + 12);
  while ( v4 )
  {
    --v4;
    sub_80A85AC(&v1);
    *(_BYTE *)v5 = v2;
    v5 = (_DWORD *)((char *)v5 + 1);
    *v5++ = v1;
  }
  return v3;
}
// 80A85AC: using guessed type _DWORD __cdecl sub_80A85AC(_DWORD);

//----- (080A82F4) --------------------------------------------------------
int __cdecl sub_80A82F4(int a1)
{
  int result; // eax
  __int16 v2; // [esp+Ah] [ebp-Eh]
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int8 v4; // [esp+13h] [ebp-5h]
  _BYTE *v5; // [esp+14h] [ebp-4h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  sub_80A86C6(*(unsigned __int16 *)(a1 + 10));
  v2 = *(_WORD *)(a1 + 8);
  result = a1 + 12;
  v5 = (_BYTE *)(a1 + 12);
  while ( v2 )
  {
    --v2;
    v4 = *v5;
    v6 = v5 + 1;
    v3 = *v6;
    v5 = v6 + 1;
    result = sub_80A8362(v4, v3);
  }
  return result;
}
// 80A8362: using guessed type _DWORD __cdecl sub_80A8362(_DWORD, _DWORD);
// 80A86C6: using guessed type _DWORD __cdecl sub_80A86C6(_DWORD);

//----- (080A8362) --------------------------------------------------------
int __cdecl sub_80A8362(unsigned __int8 a1, int a2)
{
  int result; // eax

  result = a1;
  if ( a1 == 7 )
    return sub_80A86C6((unsigned __int16)a2);
  if ( a1 == 10 )
    result = sub_80A82F4(a2);
  return result;
}
// 80A86C6: using guessed type _DWORD __cdecl sub_80A86C6(_DWORD);

//----- (080A839E) --------------------------------------------------------
int __cdecl sub_80A839E(int a1)
{
  return sub_80A8362(*(_BYTE *)(a1 + 4) & 0x1F, *(_DWORD *)a1);
}

//----- (080A83C4) --------------------------------------------------------
long double __cdecl sub_80A83C4(char a1, unsigned __int16 a2)
{
  float v3; // [esp+Ch] [ebp-Ch]
  int *v4; // [esp+10h] [ebp-8h]

  if ( a1 == 7 && (v4 = &dword_8206CA0[3 * a2], (v4[1] & 0x1F) == 15) )
    v3 = sub_80A886A(a2) / ((long double)*(unsigned __int16 *)v4 + 1.0);
  else
    v3 = 0.0;
  return v3;
}
// 80A886A: using guessed type double __cdecl sub_80A886A(_DWORD);
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A8434) --------------------------------------------------------
long double __cdecl sub_80A8434(int a1)
{
  return sub_80A83C4(*(_BYTE *)(a1 + 4) & 0x1F, *(_DWORD *)a1) + 1.0;
}

//----- (080A845E) --------------------------------------------------------
char *__cdecl sub_80A845E(unsigned __int8 a1, int *a2)
{
  char *result; // eax

  sub_80A7DC0(a1);
  result = (char *)(a1 & 0x1F);
  switch ( a1 & 0x1F )
  {
    case 1:
    case 2:
      result = sub_80A7E44((unsigned __int16)a2);
      break;
    case 3:
      result = (char *)sub_80A7F78(a2);
      break;
    case 4:
      result = (char *)sub_80A7F3A((int)a2);
      break;
    case 5:
    case 0xB:
      result = (char *)sub_80A7FDA((int)a2);
      break;
    case 6:
    case 9:
      result = (char *)sub_80A8012((int)a2);
      break;
    case 7:
      result = (char *)sub_80A8078((unsigned __int16)a2);
      break;
    case 0xA:
      result = (char *)sub_80A81B4((int)a2);
      break;
    default:
      return result;
  }
  return result;
}

//----- (080A84FE) --------------------------------------------------------
char *__cdecl sub_80A84FE(int a1, unsigned int a2, char a3)
{
  char *result; // eax

  sub_80A845E(*(_BYTE *)(a1 + 4), *(int **)a1);
  if ( a3 && a2 <= 0x1FFFF )
  {
    if ( a2 > 0xFFFF )
    {
      sub_80A7DC0(3u);
      result = (char *)sub_80A8078(a2);
    }
    else
    {
      sub_80A7DC0(2u);
      result = sub_80A7E44(a2);
    }
  }
  else if ( a2 > 0xFFFF )
  {
    sub_80A7DC0(1u);
    result = (char *)sub_80A7FDA(a2);
  }
  else
  {
    sub_80A7DC0(0);
    result = (char *)sub_80A7E00(a2);
  }
  return result;
}

//----- (080A85AC) --------------------------------------------------------
void __cdecl sub_80A85AC(int a1)
{
  *(_DWORD *)(a1 + 4) = (unsigned __int8)sub_80A7DE2();
  switch ( *(_DWORD *)(a1 + 4) & 0x1F )
  {
    case 1:
    case 2:
      *(_WORD *)a1 = sub_80A7EC4();
      break;
    case 3:
      *(_DWORD *)a1 = sub_80A7FAE();
      break;
    case 4:
      *(float *)a1 = sub_80A7F56();
      break;
    case 5:
    case 0xB:
      *(_DWORD *)a1 = sub_80A7FF6();
      break;
    case 6:
    case 9:
      *(_DWORD *)a1 = sub_80A8042();
      break;
    case 7:
      *(_WORD *)a1 = sub_80A80A0();
      break;
    case 0xA:
      *(_DWORD *)a1 = sub_80A824A();
      break;
    default:
      return;
  }
}

//----- (080A8646) --------------------------------------------------------
int __cdecl sub_80A8646(int a1)
{
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+14h] [ebp-4h]

  sub_80A85AC(a1);
  v2 = (unsigned __int8)sub_80A7DE2();
  if ( v2 == 1 )
    return sub_80A7FF6();
  if ( v2 > 1 )
  {
    if ( v2 == 2 )
    {
      v3 = (unsigned __int16)sub_80A7EC4();
    }
    else
    {
      if ( v2 != 3 )
        return 0;
      v3 = (unsigned __int16)sub_80A80A0() + 0x10000;
    }
  }
  else
  {
    if ( v2 )
      return 0;
    v3 = (unsigned __int16)sub_80A7E24();
  }
  return v3;
}

//----- (080A86C6) --------------------------------------------------------
void *__cdecl sub_80A86C6(unsigned __int16 a1)
{
  void *result; // eax
  int v2; // [esp+10h] [ebp-18h]
  unsigned int v3; // [esp+14h] [ebp-14h]
  unsigned __int16 i; // [esp+1Ah] [ebp-Eh]
  int *v5; // [esp+1Ch] [ebp-Ch]
  int *v6; // [esp+20h] [ebp-8h]

  result = dword_8306CAC;
  if ( !*((_WORD *)dword_8306CAC + a1) )
  {
    *((_WORD *)dword_8306CAC + a1) = ++word_8306CA8;
    *((_WORD *)dword_8306CB0 + (unsigned __int16)word_8306CA8) = a1;
    v6 = &dword_8206CA0[3 * a1];
    v2 = v6[1];
    for ( i = FindNextSibling(a1); i; i = FindNextSibling(i) )
    {
      v5 = &dword_8206CA0[3 * i];
      if ( (v2 & 0x1F) == 15 )
      {
        v3 = (unsigned int)v5[1] >> 8;
        if ( v3 > 0xFFFF && v3 <= 0x1FFFF )
          sub_80A86C6((unsigned __int16)v3);
      }
      sub_80A839E((int)v5);
    }
    result = (void *)(v2 & 0x1F);
    if ( result == (void *)12 )
      result = (void *)sub_80A86C6(*((unsigned __int16 *)v6 + 1));
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8306CA8: using guessed type __int16 word_8306CA8;

//----- (080A87FA) --------------------------------------------------------
long double __cdecl sub_80A87FA(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]

  v4 = sub_80A5EBE(word_830AE30, a1);
  if ( !v4 )
    return (float)0.0;
  v1 = sub_80A6B8A(v4);
  return (float)sub_80A886A(v1);
}
// 830AE30: using guessed type __int16 word_830AE30;

//----- (080A886A) --------------------------------------------------------
long double __cdecl sub_80A886A(unsigned __int16 a1)
{
  float v2; // [esp+8h] [ebp-10h]
  unsigned __int16 i; // [esp+Eh] [ebp-Ah]

  v2 = 1.0;
  for ( i = FindNextSibling(a1); i; i = FindNextSibling(i) )
    v2 = sub_80A8434((int)&dword_8206CA0[3 * i]) + v2;
  return v2;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A88F8) --------------------------------------------------------
long double __cdecl sub_80A88F8(int a1, float *a2)
{
  float v3; // [esp+Ch] [ebp-1Ch]
  int v4; // [esp+14h] [ebp-14h]
  char *v5; // [esp+18h] [ebp-10h]
  char *v6; // [esp+18h] [ebp-10h]
  char *v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+1Ch] [ebp-Ch]

  v4 = *(unsigned __int16 *)(a1 + 8);
  v5 = (char *)(5 * v4 + a1 + 12);
  v3 = sub_80A886A(*(_WORD *)(a1 + 10));
  *a2 = sub_80A87FA(*(_WORD *)(a1 + 10));
  while ( v4 )
  {
    v6 = v5 - 4;
    v8 = *(_DWORD *)v6;
    v5 = v6 - 1;
    --v4;
    if ( *v5 == 6 )
    {
      v7 = v5 - 4;
      v9 = *(_DWORD *)v7;
      v5 = v7 - 1;
      --v4;
      v3 = sub_80A886A(v9) + v3;
      *a2 = sub_80A87FA(v9) + *a2;
    }
    else
    {
      v3 = sub_80A83C4(*v5, v8) + v3;
    }
  }
  return v3;
}

//----- (080A89F0) --------------------------------------------------------
int __cdecl sub_80A89F0(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+13h] [ebp-25h]
  int *v3; // [esp+14h] [ebp-24h]
  int v4[3]; // [esp+18h] [ebp-20h] BYREF
  bool v5; // [esp+27h] [ebp-11h]
  unsigned int v6; // [esp+28h] [ebp-10h]
  unsigned __int16 i; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 v8; // [esp+2Eh] [ebp-Ah]
  int *v9; // [esp+30h] [ebp-8h]
  unsigned __int16 v10; // [esp+36h] [ebp-2h]

  v10 = a1;
  v9 = &dword_8206CA0[3 * a1];
  v2 = v9[1] & 0x9F;
  sub_80A7DC0(v2);
  if ( (v2 & 0x1F) == 12 )
  {
    sub_80A8078(*((_WORD *)v9 + 1));
    sub_80A7E88((unsigned int)v9[1] >> 8);
  }
  else if ( (v2 & 0x1F) == 13 || (v2 & 0x1F) == 17 )
  {
    sub_80A7E00(*((_WORD *)v9 + 1));
    sub_80A7E00((unsigned int)v9[1] >> 8);
  }
  v5 = (v9[1] & 0x1F) == 15;
  v8 = 0;
  for ( i = FindNextSibling(v10); i; i = FindNextSibling(i) )
    ++v8;
  sub_80A7E00(v8);
  result = FindNextSibling(v10);
  for ( i = result; i; i = result )
  {
    v3 = &dword_8206CA0[3 * i];
    v6 = (unsigned int)v3[1] >> 8;
    v4[1] = v3[1] & 0x9F;
    v4[0] = *v3;
    sub_80A84FE((int)v4, v6, v5);
    result = FindNextSibling(i);
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A8B76) --------------------------------------------------------
int __cdecl sub_80A8B76(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int8 v2; // [esp+Bh] [ebp-2Dh]
  int *v3; // [esp+Ch] [ebp-2Ch]
  int v4[2]; // [esp+10h] [ebp-28h] BYREF
  bool v5; // [esp+1Bh] [ebp-1Dh]
  int i; // [esp+1Ch] [ebp-1Ch]
  unsigned int v7; // [esp+20h] [ebp-18h]
  unsigned __int16 v8; // [esp+26h] [ebp-12h]
  int *v9; // [esp+28h] [ebp-10h]
  unsigned __int16 v10; // [esp+2Eh] [ebp-Ah]

  v10 = a1;
  v9 = &dword_8206CA0[3 * a1];
  v2 = sub_80A7DE2();
  v9[1] &= 0xFFFFFFE0;
  v9[1] |= v2;
  switch ( v2 & 0x1F )
  {
    case 12:
      *((_WORD *)v9 + 1) = sub_80A80A0();
      v9[1] |= (unsigned __int16)sub_80A7F12() << 8;
      break;
    case 13:
    case 17:
      *((_WORD *)v9 + 1) = sub_80A7E24();
      v9[1] |= (unsigned __int16)sub_80A7E24() << 8;
      break;
    case 15:
      *((_WORD *)v9 + 1) = 0;
      break;
  }
  v5 = (v2 & 0x1F) == 15;
  v8 = sub_80A7E24();
  for ( i = 0; ; ++i )
  {
    result = v8;
    if ( i >= v8 )
      break;
    v7 = sub_80A8646((int)v4);
    v3 = &dword_8206CA0[3 * (unsigned __int16)word_82C6CA0[2 * (unsigned __int16)sub_80A4C6A(v10, v7)]];
    if ( v5 )
    {
      if ( v7 > 0xFFFF )
      {
        if ( v7 <= 0x1FFFF )
          sub_80A5C0A(v7);
      }
      else
      {
        sub_80A40A6(v7);
      }
    }
    v3[1] |= v4[1];
    *v3 = v4[0];
  }
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 82C6CA0: using guessed type __int16 word_82C6CA0[];

//----- (080A8D0E) --------------------------------------------------------
int sub_80A8D0E()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  unsigned int i; // [esp+14h] [ebp-4h]

  dword_8306CAC = (void *)sub_806C565(0x20000);
  dword_8306CB0 = (void *)sub_806C565(0x20000);
  sub_80D2FE9(dword_8306CAC, 0, 0x20000u);
  word_8306CA8 = 0;
  sub_80A86C6(word_830AE32);
  sub_80A86C6(word_830AE36);
  sub_80A86C6(word_80EE90C);
  sub_80A86C6(word_830AE30);
  for ( i = 0; i < dword_8306CA4; ++i )
  {
    v0 = sub_80A5E90(word_80EE8A2, i);
    v1 = sub_80A6B8A(v0);
    sub_80A86C6(v1);
    v2 = sub_80A5E90(word_80EE8A0, i);
    v3 = sub_80A6B8A(v2);
    sub_80A86C6(v3);
  }
  return sub_80A839E((int)&dword_8206CA0[3 * (unsigned __int16)word_830AE34]);
}
// 80EE8A0: using guessed type __int16 word_80EE8A0;
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 80EE90C: using guessed type __int16 word_80EE90C;
// 8206CA0: using guessed type int dword_8206CA0[];
// 8306CA4: using guessed type int dword_8306CA4;
// 8306CA8: using guessed type __int16 word_8306CA8;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE34: using guessed type __int16 word_830AE34;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080A8E30) --------------------------------------------------------
char *sub_80A8E30()
{
  return sub_80A845E(
           dword_8206CA4[3 * (unsigned __int16)word_830AE34] & 0x9F,
           (int *)dword_8206CA0[3 * (unsigned __int16)word_830AE34]);
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA4: using guessed type int dword_8206CA4[];
// 830AE34: using guessed type __int16 word_830AE34;

//----- (080A8E76) --------------------------------------------------------
int sub_80A8E76()
{
  int result; // eax
  int v1[2]; // [esp+10h] [ebp-8h] BYREF

  word_830AE34 = sub_80A5A02();
  sub_80A85AC((int)v1);
  dword_8206CA4[3 * (unsigned __int16)word_830AE34] |= v1[1];
  result = v1[0];
  dword_8206CA0[3 * (unsigned __int16)word_830AE34] = v1[0];
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 8206CA4: using guessed type int dword_8206CA4[];
// 830AE34: using guessed type __int16 word_830AE34;

//----- (080A8EE8) --------------------------------------------------------
unsigned int sub_80A8EE8()
{
  unsigned int result; // eax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned int j; // [esp+10h] [ebp-8h]
  unsigned int i; // [esp+14h] [ebp-4h]

  sub_80A7FDA(dword_830AE2C);
  sub_80A7E00(word_8306CA8);
  for ( i = 1; i <= (unsigned __int16)word_8306CA8; ++i )
    sub_80A89F0(*((_WORD *)dword_8306CB0 + i));
  sub_80A8E30();
  sub_80A8078(word_830AE32);
  sub_80A8078(word_830AE36);
  sub_80A8078(word_80EE90C);
  sub_80A8078(word_830AE30);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_8306CA4 )
      break;
    v1 = sub_80A5E90(word_80EE8A2, j);
    v2 = sub_80A6B8A(v1);
    sub_80A8078(v2);
  }
  return result;
}
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 80EE90C: using guessed type __int16 word_80EE90C;
// 8306CA4: using guessed type int dword_8306CA4;
// 8306CA8: using guessed type __int16 word_8306CA8;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080A8FC8) --------------------------------------------------------
int sub_80A8FC8()
{
  return sub_806C5D0();
}

//----- (080A8FD6) --------------------------------------------------------
unsigned int sub_80A8FD6()
{
  unsigned int result; // eax
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // [esp+12h] [ebp-16h]
  unsigned int j; // [esp+14h] [ebp-14h]
  int v4[2]; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+20h] [ebp-8h]
  unsigned int i; // [esp+24h] [ebp-4h]

  dword_8306CB4 = (char *)sub_80A0B32(4);
  v5 = *(_DWORD *)dword_8306CB4;
  dword_8306CB4 = (char *)sub_80A0B32(v5);
  dword_830AE2C = sub_80A7FF6();
  word_8306CA8 = sub_80A7E24();
  dword_8306CAC = sub_806C6AE(0x20000u);
  dword_8306CB0 = sub_806C6AE(2 * (unsigned __int16)word_8306CA8 + 2);
  for ( i = 1; i <= (unsigned __int16)word_8306CA8; ++i )
  {
    v2 = sub_80A5A30();
    *((_WORD *)dword_8306CB0 + i) = v2;
    *((_WORD *)dword_8306CAC + v2) = i;
  }
  for ( i = 1; i <= (unsigned __int16)word_8306CA8; ++i )
    sub_80A8B76(*((_WORD *)dword_8306CB0 + i));
  sub_80A8E76();
  word_830AE32 = sub_80A80A0();
  word_830AE36 = sub_80A80A0();
  word_80EE90C = sub_80A80A0();
  word_830AE30 = sub_80A80A0();
  v4[1] = 7;
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= dword_8306CA4 )
      break;
    LOWORD(v4[0]) = sub_80A80A0();
    v1 = sub_80A5E90(word_80EE8A2, j);
    sub_80A6598(v1, v4);
  }
  return result;
}
// 80EE8A2: using guessed type __int16 word_80EE8A2;
// 80EE90C: using guessed type __int16 word_80EE90C;
// 8306CA4: using guessed type int dword_8306CA4;
// 8306CA8: using guessed type __int16 word_8306CA8;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080A914C) --------------------------------------------------------
int sub_80A914C()
{
  unsigned int i; // [esp+4h] [ebp-4h]

  for ( i = 1; i <= (unsigned __int16)word_8306CA8; ++i )
    sub_80A5C0A(*((_WORD *)dword_8306CB0 + i));
  sub_806C7F0(dword_8306CB0);
  return sub_806C7F0(dword_8306CAC);
}
// 8306CA8: using guessed type __int16 word_8306CA8;

//----- (080A91A2) --------------------------------------------------------
int __cdecl sub_80A91A2(char *s1, int a2)
{
  size_t v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  char *s; // [esp+14h] [ebp-4h]
  char *sa; // [esp+14h] [ebp-4h]

  for ( s = (char *)scrVarPub; *s; s += v4 + 3 )
  {
    v4 = strlen(s) + 1;
    if ( !strcasecmp(s1, s) )
    {
      sa = &s[v4];
      v5 = *(_WORD *)sa;
      *(_DWORD *)a2 = sa[2];
      return v5;
    }
  }
  return 0;
}
// 8306CB8: using guessed type int scrVarPub;

//----- (080A922A) --------------------------------------------------------
int __cdecl sub_80A922A(char *src)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  size_t v4; // eax
  char *v5; // ebx
  int v7; // [esp+18h] [ebp-30h] BYREF
  int i; // [esp+1Ch] [ebp-2Ch]
  int v9; // [esp+20h] [ebp-28h]
  __int16 v10; // [esp+26h] [ebp-22h]
  int v11; // [esp+28h] [ebp-20h]
  char *dest; // [esp+2Ch] [ebp-1Ch]
  char *s1; // [esp+30h] [ebp-18h]
  char *v14; // [esp+34h] [ebp-14h] BYREF
  char *v15; // [esp+38h] [ebp-10h]
  char v16[4]; // [esp+3Ch] [ebp-Ch] BYREF
  signed int v17; // [esp+40h] [ebp-8h]

  v17 = FS_FOpenFileByMode(src, (int)v16, 0);
  if ( v17 < 0 )
  {
    v1 = va((char *)&byte_80E1E74, src);
    Com_Error(1, v1);
  }
  v15 = (char *)sub_806C565(v17 + 1);
  FS_Read(v15, v17, *(int *)v16);
  v15[v17] = 0;
  FS_FCloseFile(*(int *)v16);
  v14 = v15;
  sub_8084734("Scr_AddFields");
  while ( 1 )
  {
    s1 = (char *)Com_Parse(&v14);
    if ( !v14 )
      break;
    if ( !strcmp(s1, "float") )
    {
      v11 = 4;
    }
    else if ( !strcmp(s1, "int") )
    {
      v11 = 5;
    }
    else
    {
      if ( strcmp(s1, "string") )
      {
        v2 = va((char *)&byte_80E1E94, s1, src);
        Com_Error(1, v2);
      }
      v11 = 1;
    }
    s1 = (char *)Com_Parse(&v14);
    if ( !v14 )
    {
      v3 = va((char *)&byte_80E1EAF, src);
      Com_Error(1, v3);
    }
    v4 = strlen(s1);
    v17 = v4 + 1;
    for ( i = v4; i >= 0; --i )
    {
      v5 = &s1[i];
      *v5 = tolower(s1[i]);
    }
    v10 = sub_80A11D2(s1);
    if ( v10 )
    {
      if ( (unsigned __int16)sub_80A91A2(s1, (int)&v7) )
        Com_Error(1, (char *)&byte_80E1ECB, s1, src);
      v9 = v17 + 3;
      dest = (char *)sub_80A4460(v17 + 3);
      strcpy(dest, s1);
      dest += v17;
      *(_WORD *)dest = v10;
      dest += 2;
      *dest++ = v11;
      *dest = 0;
    }
  }
  sub_80847D5();
  return sub_806C5D0();
}

//----- (080A94A2) --------------------------------------------------------
int __cdecl sub_80A94A2(char *a1, char *a2)
{
  char s[68]; // [esp+20h] [ebp-58h] BYREF
  int i; // [esp+64h] [ebp-14h]
  void *ptr; // [esp+68h] [ebp-10h]
  int v6[3]; // [esp+6Ch] [ebp-Ch] BYREF

  ptr = sub_8064009(a1, a2, (int)v6);
  sub_80A4450();
  scrVarPub = (int)sub_806C5DF(0);
  *(_BYTE *)scrVarPub = 0;
  for ( i = 0; i < v6[0]; ++i )
  {
    sprintf(s, "%s/%s", a1, *((const char **)ptr + i));
    sub_80A922A(s);
  }
  if ( ptr )
    sub_8064032(ptr);
  *(_BYTE *)sub_80A4460(1) = 0;
  return sub_806C69F();
}
// 8306CB8: using guessed type int scrVarPub;

//----- (080A9560) --------------------------------------------------------
int __cdecl sub_80A9560(unsigned __int16 a1)
{
  return sub_80A5C0A(a1);
}

//----- (080A957C) --------------------------------------------------------
int __cdecl sub_80A957C(unsigned __int16 a1)
{
  int v3; // [esp+18h] [ebp-10h]
  unsigned __int16 v4; // [esp+1Eh] [ebp-Ah]

  if ( (dword_8206CA0[3 * a1 + 1] & 0x1F) != 15 )
    return 0;
  while ( 2 )
  {
    v4 = FindNextSibling(a1);
LABEL_4:
    if ( v4 )
    {
      v3 = (unsigned int)dword_8206CA0[3 * v4 + 1] >> 8;
      switch ( dword_8206CA0[3 * v4 + 1] & 0x1F )
      {
        case 6:
        case 9:
        case 0xA:
        case 0xB:
          goto LABEL_6;
        case 7:
          if ( sub_80A957C(LOWORD(dword_8206CA0[3 * v4])) )
            goto LABEL_8;
LABEL_6:
          sub_80A6248(a1, v3);
          continue;
        default:
LABEL_8:
          v4 = FindNextSibling(v4);
          goto LABEL_4;
      }
    }
    return 1;
  }
}
// 8206CA0: using guessed type int dword_8206CA0[];

//----- (080A9680) --------------------------------------------------------
void sub_80A9680()
{
  if ( !word_830AE34 )
  {
    word_830AE34 = sub_80A5A02();
    sub_80A7BEE(word_830AE34);
  }
}
// 830AE34: using guessed type __int16 word_830AE34;

//----- (080A96AE) --------------------------------------------------------
int __cdecl sub_80A96AE(int a1)
{
  int result; // eax

  if ( !a1 )
    return sub_80A957C(dword_8206CA0[3 * (unsigned __int16)word_830AE34]);
  result = sub_80A5B9E(word_830AE34);
  word_830AE34 = 0;
  return result;
}
// 8206CA0: using guessed type int dword_8206CA0[];
// 830AE34: using guessed type __int16 word_830AE34;

//----- (080A9702) --------------------------------------------------------
int __cdecl sub_80A9702(_DWORD *a1)
{
  int result; // eax

  *a1 = dword_80EE8A4;
  a1[1] = dword_80EE86C;
  result = dword_80EE868 - dword_80EE864;
  a1[2] = dword_80EE868 - dword_80EE864;
  return result;
}
// 80EE864: using guessed type int dword_80EE864;
// 80EE868: using guessed type int dword_80EE868;
// 80EE86C: using guessed type int dword_80EE86C;
// 80EE8A4: using guessed type int dword_80EE8A4;

//----- (080A9734) --------------------------------------------------------
int __cdecl sub_80A9734(int *a1)
{
  return sub_80A5D56(a1[1], *a1);
}

//----- (080A9754) --------------------------------------------------------
int __cdecl sub_80A9754(int *a1)
{
  return sub_80A5DA8(a1[1], *a1);
}

//----- (080A9774) --------------------------------------------------------
int sub_80A9774()
{
  int result; // eax

  dword_830ACC0 = (int)&unk_830ACB8;
  dword_830AE28 = (int)&unk_8306CC0;
  dword_830ACC4 = 0;
  dword_830AD60 = 0;
  dword_830AD64 = 0;
  dword_830AD68 = 0;
  byte_830AD6C = 0;
  dword_830AE24 = 0;
  dword_830AE20 = 0;
  result = sub_80A5A02();
  word_80EE90E = result;
  word_80EE90C = 0;
  word_830AE30 = 0;
  word_830AE32 = 0;
  word_830AE34 = 0;
  word_830AE36 = 0;
  dword_8306CC4 = 6;
  dword_830AD70 = 1;
  return result;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 80EE90E: using guessed type __int16 word_80EE90E;
// 8306CC4: using guessed type int dword_8306CC4;
// 830ACC0: using guessed type int dword_830ACC0;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AD60: using guessed type int dword_830AD60;
// 830AD64: using guessed type int dword_830AD64;
// 830AD68: using guessed type int dword_830AD68;
// 830AD6C: using guessed type char byte_830AD6C;
// 830AD70: using guessed type int dword_830AD70;
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE34: using guessed type __int16 word_830AE34;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080A9820) --------------------------------------------------------
int __cdecl sub_80A9820(int a1, int a2, int a3)
{
  int result; // eax

  dword_81768C0 = a1;
  dword_81768C4 = a2;
  dword_81768C8 = a3;
  sub_80A4A9E();
  result = sub_80A9774();
  byte_81768AC = 0;
  byte_81768AD = 0;
  word_81768AE = 0;
  word_81768B0 = 0;
  word_81768B2 = 0;
  byte_80EE910 = 1;
  return result;
}
// 80EE910: using guessed type char byte_80EE910;
// 81768AC: using guessed type char byte_81768AC;
// 81768AD: using guessed type char byte_81768AD;
// 81768AE: using guessed type __int16 word_81768AE;
// 81768B0: using guessed type __int16 word_81768B0;
// 81768B2: using guessed type __int16 word_81768B2;
// 81768C0: using guessed type int dword_81768C0;
// 81768C4: using guessed type int dword_81768C4;
// 81768C8: using guessed type int dword_81768C8;

//----- (080A987A) --------------------------------------------------------
void sub_80A987A()
{
  if ( byte_80EE910 )
    byte_80EE910 = 0;
}
// 80EE910: using guessed type char byte_80EE910;

//----- (080A9892) --------------------------------------------------------
void sub_80A9892()
{
  word_80EE90C = 0;
  byte_80EE910 = 0;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 80EE910: using guessed type char byte_80EE910;

//----- (080A98A8) --------------------------------------------------------
void sub_80A98A8()
{
  ;
}

//----- (080A98AE) --------------------------------------------------------
int sub_80A98AE()
{
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]

  Com_Printf("WARNING: Server should have crashed here!\n", v1);
  return Com_Printf("WARNING: Look for console commands player might be exploiting!\n", v2);
}
// 80A98BB: variable 'v1' is possibly undefined
// 80A98C7: variable 'v2' is possibly undefined

//----- (080A98D8) --------------------------------------------------------
_BOOL4 __cdecl sub_80A98D8(char *a1)
{
  while ( *a1 <= 32 )
  {
    if ( !*a1 )
      return 0;
    ++a1;
  }
  if ( *a1 == 45 || *a1 == 43 )
    ++a1;
  if ( *a1 == 48 )
    return 1;
  if ( *a1 == 46 )
    return a1[1] == 48;
  return 0;
}

//----- (080A9956) --------------------------------------------------------
int __cdecl sub_80A9956(float *a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  if ( *((_DWORD *)a1 + 1) == 4 )
  {
    *((_DWORD *)a1 + 1) = 5;
    *(_DWORD *)a1 = 0.0 != *a1;
    v5 = 1;
  }
  else if ( *((_DWORD *)a1 + 1) == 1 )
  {
    v6 = *(_WORD *)a1;
    v1 = (const char *)SL_ConvertToString(*(_WORD *)a1);
    *(_DWORD *)a1 = atoi(v1) != 0;
    if ( *(_DWORD *)a1 || (v2 = (char *)SL_ConvertToString(v6), sub_80A98D8(v2)) )
    {
      *((_DWORD *)a1 + 1) = 5;
      sub_80A40A6(v6);
      v5 = 1;
    }
    else
    {
      v3 = (const char *)SL_ConvertToString(v6);
      dword_830AD60 = (int)va("cannot cast \"%s\" to bool", v3);
      sub_80A40A6(v6);
      a1[1] = 0.0;
      v5 = 0;
    }
  }
  else
  {
    dword_830AD60 = (int)va("cannot cast %s to bool", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
    sub_80A9754((int *)a1);
    a1[1] = 0.0;
    v5 = 0;
  }
  return v5;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9A98) --------------------------------------------------------
int __cdecl sub_80A9A98(int a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  switch ( *(_DWORD *)(a1 + 4) )
  {
    case 5:
      return 1;
    case 4:
      *(_DWORD *)(a1 + 4) = 5;
      *(_DWORD *)a1 = (int)*(float *)a1;
      v5 = 1;
      break;
    case 1:
      v6 = *(_WORD *)a1;
      v1 = (const char *)SL_ConvertToString(*(_WORD *)a1);
      *(_DWORD *)a1 = atoi(v1);
      if ( *(_DWORD *)a1 || (v2 = (char *)SL_ConvertToString(v6), sub_80A98D8(v2)) )
      {
        *(_DWORD *)(a1 + 4) = 5;
        sub_80A40A6(v6);
        v5 = 1;
      }
      else
      {
        v3 = (const char *)SL_ConvertToString(v6);
        dword_830AD60 = (int)va("cannot cast \"%s\" to int", v3);
        sub_80A40A6(v6);
        *(_DWORD *)(a1 + 4) = 0;
        v5 = 0;
      }
      break;
    default:
      dword_830AD60 = (int)va("cannot cast %s to int", *(const char **)&off_80EE8C0[4 * *(_DWORD *)(a1 + 4)]);
      sub_80A9754((int *)a1);
      *(_DWORD *)(a1 + 4) = 0;
      v5 = 0;
      break;
  }
  return v5;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9BEA) --------------------------------------------------------
int __cdecl CastFloat(unsigned __int16 *a1)
{
  const char *v1; // eax
  char *v2; // eax
  const char *v3; // eax
  int v5; // [esp+8h] [ebp-10h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  switch ( *((_DWORD *)a1 + 1) )
  {
    case 4:
      return 1;
    case 5:
      *((_DWORD *)a1 + 1) = 4;
      *(float *)a1 = (float)*(int *)a1;
      v5 = 1;
      break;
    case 1:
      v6 = *a1;
      v1 = (const char *)SL_ConvertToString(*a1);
      *(float *)a1 = atof(v1);
      if ( *(float *)a1 == 0.0 && (v2 = (char *)SL_ConvertToString(v6), !sub_80A98D8(v2)) )
      {
        v3 = (const char *)SL_ConvertToString(v6);
        dword_830AD60 = (int)va("cannot cast \"%s\" to float", v3);
        sub_80A40A6(v6);
        *((_DWORD *)a1 + 1) = 0;
        v5 = 0;
      }
      else
      {
        *((_DWORD *)a1 + 1) = 4;
        sub_80A40A6(v6);
        v5 = 1;
      }
      break;
    default:
      dword_830AD60 = (int)va("cannot cast %s to float", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
      sub_80A9754((int *)a1);
      *((_DWORD *)a1 + 1) = 0;
      v5 = 0;
      break;
  }
  return v5;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9D32) --------------------------------------------------------
int __cdecl sub_80A9D32(int *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  switch ( a1[1] )
  {
    case 1:
      return 1;
    case 5:
      a1[1] = 1;
      *(_WORD *)a1 = sub_80A4206(*a1);
      v2 = 1;
      break;
    case 4:
      a1[1] = 1;
      *(_WORD *)a1 = sub_80A41BC(*(float *)a1);
      v2 = 1;
      break;
    case 3:
      a1[1] = 1;
      v3 = *a1;
      *(_WORD *)a1 = sub_80A4250((float *)*a1);
      sub_80A5D00(v3);
      v2 = 1;
      break;
    default:
      dword_830AD60 = (int)va("cannot cast %s to string", *(const char **)&off_80EE8C0[4 * a1[1]]);
      sub_80A9754(a1);
      a1[1] = 0;
      v2 = 0;
      break;
  }
  return v2;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9E36) --------------------------------------------------------
int __cdecl sub_80A9E36(int *a1)
{
  if ( a1[1] == 2 )
    return 1;
  dword_830AD60 = (int)va("cannot cast %s to istring", *(const char **)&off_80EE8C0[4 * a1[1]]);
  sub_80A9754(a1);
  a1[1] = 0;
  return 0;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9E92) --------------------------------------------------------
int __cdecl sub_80A9E92(int *a1)
{
  if ( a1[1] == 3 )
    return 1;
  dword_830AD60 = (int)va("cannot cast %s to vector", *(const char **)&off_80EE8C0[4 * a1[1]]);
  sub_80A9754(a1);
  a1[1] = 0;
  return 0;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9EEE) --------------------------------------------------------
int __cdecl sub_80A9EEE(int *a1)
{
  if ( a1[1] == 7 )
    return 1;
  dword_830AD60 = (int)va("cannot cast %s to object", *(const char **)&off_80EE8C0[4 * a1[1]]);
  sub_80A9754(a1);
  a1[1] = 0;
  return 0;
}
// 830AD60: using guessed type int dword_830AD60;

//----- (080A9F4A) --------------------------------------------------------
_DWORD *__cdecl sub_80A9F4A(_DWORD *a1)
{
  _DWORD *result; // eax
  int i; // [esp+1Ch] [ebp-1Ch]
  int v3[6]; // [esp+20h] [ebp-18h] BYREF

  for ( i = 2; i >= 0; --i )
  {
    if ( (unsigned __int8)CastFloat((unsigned __int16 *)&a1[2 * i]) )
    {
      v3[2 - i] = a1[2 * i];
    }
    else
    {
      dword_830AD68 = i;
      sub_80A98AE();
    }
  }
  a1[1] = 3;
  result = sub_80A5C94(v3);
  *a1 = result;
  return result;
}
// 830AD68: using guessed type int dword_830AD68;

//----- (080A9FCA) --------------------------------------------------------
int __cdecl sub_80A9FCA(int a1)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  for ( i = 2; i >= 0; --i )
    sub_80A9754((int *)(a1 + 8 * i));
  result = a1;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (080AA004) --------------------------------------------------------
int *__cdecl sub_80AA004(int *a1, int *a2)
{
  int *result; // eax

  dword_830AD60 = (int)va(
                         "pair has unmatching types '%s' and '%s'",
                         *(const char **)&off_80EE8C0[4 * dword_830AD74],
                         *(const char **)&off_80EE8C0[4 * dword_830AD78]);
  sub_80A9754(a1);
  a1[1] = 0;
  sub_80A9754(a2);
  result = a2;
  a2[1] = 0;
  return result;
}
// 830AD60: using guessed type int dword_830AD60;
// 830AD74: using guessed type int dword_830AD74;
// 830AD78: using guessed type int dword_830AD78;

//----- (080AA068) --------------------------------------------------------
int __cdecl sub_80AA068(int a1, int a2)
{
  float v4; // [esp+20h] [ebp-8h]
  float v5; // [esp+20h] [ebp-8h]

  dword_830AD74 = *(_DWORD *)(a1 + 4);
  dword_830AD78 = *(_DWORD *)(a2 + 4);
  if ( dword_830AD74 != dword_830AD78 )
  {
    if ( dword_830AD74 >= dword_830AD78 )
    {
      if ( dword_830AD78 == 1 )
      {
        if ( dword_830AD74 == 4 )
        {
          *(_DWORD *)(a1 + 4) = 1;
          *(_WORD *)a1 = sub_80A41BC(*(float *)a1);
          return 1;
        }
        if ( dword_830AD74 > 4 )
        {
          if ( dword_830AD74 == 5 )
          {
            *(_DWORD *)(a1 + 4) = 1;
            *(_WORD *)a1 = sub_80A4206(*(_DWORD *)a1);
            return 1;
          }
        }
        else if ( dword_830AD74 == 3 )
        {
          *(_DWORD *)(a1 + 4) = 1;
          v5 = *(float *)a1;
          *(_WORD *)a1 = sub_80A4250(*(float **)a1);
          sub_80A5D00(SLODWORD(v5));
          return 1;
        }
      }
      else if ( dword_830AD78 != 4 )
      {
        goto LABEL_32;
      }
      if ( dword_830AD74 == 5 )
      {
        *(_DWORD *)(a1 + 4) = 4;
        *(float *)a1 = (float)*(int *)a1;
        return 1;
      }
    }
    else
    {
      if ( dword_830AD74 == 1 )
      {
        if ( dword_830AD78 == 4 )
        {
          *(_DWORD *)(a2 + 4) = 1;
          *(_WORD *)a2 = sub_80A41BC(*(float *)a2);
          return 1;
        }
        if ( dword_830AD78 > 4 )
        {
          if ( dword_830AD78 == 5 )
          {
            *(_DWORD *)(a2 + 4) = 1;
            *(_WORD *)a2 = sub_80A4206(*(_DWORD *)a2);
            return 1;
          }
        }
        else if ( dword_830AD78 == 3 )
        {
          *(_DWORD *)(a2 + 4) = 1;
          v4 = *(float *)a2;
          *(_WORD *)a2 = sub_80A4250(*(float **)a2);
          sub_80A5D00(SLODWORD(v4));
          return 1;
        }
      }
      else if ( dword_830AD74 != 4 )
      {
        goto LABEL_32;
      }
      if ( dword_830AD78 == 5 )
      {
        *(_DWORD *)(a2 + 4) = 4;
        *(float *)a2 = (float)*(int *)a2;
        return 1;
      }
    }
LABEL_32:
    sub_80AA004((int *)a1, (int *)a2);
    return 0;
  }
  return 1;
}
// 830AD74: using guessed type int dword_830AD74;
// 830AD78: using guessed type int dword_830AD78;

//----- (080AA2C4) --------------------------------------------------------
int __cdecl sub_80AA2C4(int a1, unsigned __int16 *a2)
{
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  _BOOL4 v6; // [esp+20h] [ebp-8h]
  _BOOL4 v7; // [esp+20h] [ebp-8h]

  if ( !(unsigned __int8)sub_80AA068(a1, (int)a2) )
    return 0;
  switch ( *(_DWORD *)(a1 + 4) )
  {
    case 0:
      *(_DWORD *)(a1 + 4) = 5;
      *(_DWORD *)a1 = 1;
      v5 = 1;
      break;
    case 1:
    case 2:
      *(_DWORD *)(a1 + 4) = 5;
      v6 = *(_WORD *)a1 == *a2;
      sub_80A40A6(*(_WORD *)a1);
      sub_80A40A6(*a2);
      *(_DWORD *)a1 = v6;
      v5 = 1;
      break;
    case 3:
      *(_DWORD *)(a1 + 4) = 5;
      v4 = 0;
      if ( **(float **)a1 == **(float **)a2
        && *(float *)(*(_DWORD *)a1 + 4) == *(float *)(*(_DWORD *)a2 + 4)
        && *(float *)(*(_DWORD *)a1 + 8) == *(float *)(*(_DWORD *)a2 + 8) )
      {
        v4 = 1;
      }
      sub_80A5D00(*(_DWORD *)a1);
      sub_80A5D00(*(_DWORD *)a2);
      *(_DWORD *)a1 = v4;
      v5 = 1;
      break;
    case 4:
      *(_DWORD *)(a1 + 4) = 5;
      v3 = *(float *)a1 - *(float *)a2;
      *(_DWORD *)a1 = sub_80AF812(v3) < 0.000001;
      v5 = 1;
      break;
    case 5:
      *(_DWORD *)a1 = *(_DWORD *)a1 == *(_DWORD *)a2;
      v5 = 1;
      break;
    case 7:
      *(_DWORD *)(a1 + 4) = 5;
      v7 = *(_WORD *)a1 == *a2;
      sub_80A5C0A(*(_WORD *)a1);
      sub_80A5C0A(*a2);
      *(_DWORD *)a1 = v7;
      v5 = 1;
      break;
    case 0xB:
      *(_DWORD *)(a1 + 4) = 5;
      *(_DWORD *)a1 = *(_DWORD *)a1 == *(_DWORD *)a2;
      v5 = 1;
      break;
    default:
      sub_80AA004((int *)a1, (int *)a2);
      v5 = 0;
      break;
  }
  return v5;
}

//----- (080AA520) --------------------------------------------------------
int __cdecl sub_80AA520(unsigned __int16 *a1, _DWORD *a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 *a5)
{
  unsigned __int16 v5; // ax
  int v6; // edx
  int v7; // edx
  int v8; // edx
  unsigned __int16 v9; // ax
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // ax
  unsigned __int16 v12; // ax
  unsigned __int16 v13; // ax
  char *v14; // eax
  char *v15; // eax
  unsigned __int16 v16; // ax
  unsigned __int16 v17; // ax
  char *v18; // eax
  char *v19; // eax
  char *v20; // eax
  int v21; // eax
  char *v22; // eax
  char *v23; // eax
  int v24; // eax
  char *v25; // eax
  char *v26; // eax
  char *v27; // eax
  unsigned __int16 v28; // ax
  unsigned __int16 v29; // ax
  char *v30; // eax
  unsigned __int16 v31; // ax
  int v32; // eax
  char *v33; // eax
  char *v34; // eax
  unsigned __int16 v35; // ax
  int v36; // eax
  char *v37; // eax
  char *v38; // eax
  char *v39; // eax
  char *v40; // eax
  char *v41; // eax
  char *v42; // eax
  unsigned __int16 v43; // ax
  unsigned __int16 v44; // ax
  unsigned __int16 v45; // ax
  unsigned __int16 v46; // ax
  unsigned __int16 v47; // ax
  unsigned __int16 v48; // ax
  unsigned __int16 v49; // ax
  unsigned __int16 v50; // ax
  int v51; // eax
  char *v52; // eax
  char *v53; // eax
  int v54; // eax
  char *v55; // eax
  char *v56; // eax
  unsigned __int16 v57; // ax
  unsigned __int16 v58; // ax
  unsigned __int16 v59; // ax
  unsigned __int16 v60; // ax
  unsigned __int16 v61; // ax
  unsigned __int16 v62; // ax
  unsigned __int16 v63; // ax
  int v64; // eax
  char *v65; // eax
  char *v66; // eax
  char *v67; // eax
  char *v68; // eax
  float v70; // [esp+0h] [ebp-A8h]
  float v71; // [esp+0h] [ebp-A8h]
  char v72; // [esp+4h] [ebp-A4h]
  int v73; // [esp+28h] [ebp-80h]
  int v74; // [esp+2Ch] [ebp-7Ch]
  int v75; // [esp+30h] [ebp-78h]
  int v76; // [esp+34h] [ebp-74h]
  int v77; // [esp+38h] [ebp-70h]
  int v78; // [esp+3Ch] [ebp-6Ch]
  int v79; // [esp+40h] [ebp-68h]
  int v80; // [esp+44h] [ebp-64h]
  int v81; // [esp+48h] [ebp-60h]
  int v82; // [esp+50h] [ebp-58h]
  int v84; // [esp+64h] [ebp-44h]
  char v85; // [esp+69h] [ebp-3Fh]
  unsigned __int16 v86; // [esp+6Ah] [ebp-3Eh]
  unsigned __int16 *v87; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v88; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v89; // [esp+6Ch] [ebp-3Ch]
  unsigned __int16 *v90; // [esp+6Ch] [ebp-3Ch]
  float *v91; // [esp+70h] [ebp-38h]
  float *v92; // [esp+70h] [ebp-38h]
  _DWORD *v93; // [esp+74h] [ebp-34h]
  _DWORD *v94; // [esp+74h] [ebp-34h]
  _DWORD *v95; // [esp+74h] [ebp-34h]
  _DWORD *v96; // [esp+74h] [ebp-34h]
  int v97; // [esp+78h] [ebp-30h]
  unsigned __int16 v98; // [esp+7Eh] [ebp-2Ah]
  unsigned __int16 v99; // [esp+7Eh] [ebp-2Ah]
  unsigned __int16 v100; // [esp+7Eh] [ebp-2Ah]
  float v101; // [esp+80h] [ebp-28h]
  int v102; // [esp+84h] [ebp-24h]
  int v103; // [esp+84h] [ebp-24h]
  int v104; // [esp+84h] [ebp-24h]
  _DWORD *v105; // [esp+88h] [ebp-20h] BYREF
  int v106; // [esp+8Ch] [ebp-1Ch]
  int v107; // [esp+94h] [ebp-14h]
  __int16 v108; // [esp+9Ah] [ebp-Eh]
  unsigned __int16 v109; // [esp+9Ch] [ebp-Ch]
  unsigned __int16 v110; // [esp+9Eh] [ebp-Ah]
  int *i; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v112; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v113; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v114; // [esp+B0h] [ebp+8h]
  unsigned __int16 *v115; // [esp+B0h] [ebp+8h]
  int *v116; // [esp+B0h] [ebp+8h]
  char *v117; // [esp+B4h] [ebp+Ch]
  int v118; // [esp+B4h] [ebp+Ch]
  int *v119; // [esp+B4h] [ebp+Ch]

  v110 = a3;
  v109 = a4;
  v84 = 0;
LABEL_2:
  while ( 2 )
  {
    v85 = *(_BYTE *)a2;
    a2 = (_DWORD *)((char *)a2 + 1);
LABEL_3:
    switch ( v85 )
    {
      case 0:
        sub_80A55C2(v110);
        while ( *((_DWORD *)a1 + 1) != 6 )
        {
          sub_80A9754((int *)a1);
          a1 -= 4;
        }
        --dword_830ACC4;
        if ( a1 == a5 )
        {
          *((_DWORD *)a5 + 3) = 0;
          return v110;
        }
        sub_80A5C0A(v110);
        a2 = *(_DWORD **)a1;
        a1 -= 4;
        v110 = *a1;
        *((_DWORD *)a1 + 1) = 0;
        v5 = sub_80A5B3C(v110);
        if ( !sub_80A6BBA(v5) )
          goto LABEL_10;
        continue;
      case 1:
        sub_80A55C2(v110);
        v6 = *((_DWORD *)a1 + 1);
        v105 = *(_DWORD **)a1;
        v106 = v6;
        for ( i = (int *)(a1 - 4); i[1] != 6; i -= 2 )
          sub_80A9754(i);
        --dword_830ACC4;
        if ( i == (int *)a5 )
        {
          v7 = v106;
          *((_DWORD *)a5 + 2) = v105;
          *((_DWORD *)a5 + 3) = v7;
          return v110;
        }
        sub_80A5C0A(v110);
        a2 = (_DWORD *)*i;
        a1 = (unsigned __int16 *)(i - 2);
        v110 = *a1;
        v8 = v106;
        *(_DWORD *)a1 = v105;
        *((_DWORD *)a1 + 1) = v8;
        v9 = sub_80A5B3C(v110);
        if ( !sub_80A6BBA(v9) )
          goto LABEL_10;
        continue;
      case 2:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 0;
        continue;
      case 3:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 5;
        *(_DWORD *)a1 = *a2++;
        continue;
      case 4:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 4;
        *(_DWORD *)a1 = *a2++;
        continue;
      case 5:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 1;
        *a1 = *(_WORD *)a2;
        sub_80A3F08(*a1);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 6:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 2;
        *a1 = *(_WORD *)a2;
        sub_80A3F08(*a1);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 7:
        v108 = sub_80A5B3C(v110);
        continue;
      case 8:
        v108 = word_830AE32;
        continue;
      case 9:
        v108 = word_830AE36;
        continue;
      case 10:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 7;
        *a1 = sub_80A5B3C(v110);
        sub_80A5BCE(*a1);
        continue;
      case 11:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 7;
        *a1 = word_830AE32;
        sub_80A5BCE(word_830AE32);
        continue;
      case 12:
        a1 += 4;
        sub_80A67A2(word_830AE34, (int *)a1);
        sub_80A9734((int *)a1);
        continue;
      case 13:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 7;
        *a1 = word_830AE36;
        sub_80A5BCE(word_830AE36);
        continue;
      case 14:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 11;
        *(_DWORD *)a1 = *a2++;
        continue;
      case 15:
        v108 = word_830AE34;
        continue;
      case 16:
        a1 += 4;
        *((_DWORD *)a1 + 1) = 9;
        *(_DWORD *)a1 = *a2++;
        continue;
      case 17:
        a1 += 4;
        v10 = sub_80A61E0(v110, *(unsigned __int16 *)a2);
        sub_80A67A2(v10, (int *)a1);
        sub_80A9734((int *)a1);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 18:
        v108 = sub_80A61E0(v110, *(unsigned __int16 *)a2);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 19:
        sub_80A635A(v110, *(unsigned __int16 *)a2);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 20:
        a1 -= 4;
        sub_80A71BC((int *)a1, a1 + 4);
        continue;
      case 21:
        v108 = sub_80A772E(v108, (int *)a1);
        a1 -= 4;
        continue;
      case 22:
        sub_80A79C6(v108, (int *)a1);
        a1 -= 4;
        continue;
      case 23:
        a1 += 4;
        sub_80A7BCC((int)a1);
        continue;
      case 24:
        a1 += 4;
        v11 = sub_80A5F28(v108, *(_WORD *)a2);
        sub_80A67E6(v11, a1);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 25:
        v108 = sub_80A5F28(v108, *(_WORD *)a2);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 26:
        sub_80A60BE(v108, *(_WORD *)a2);
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 27:
        v108 = word_80EE90E;
        sub_80A6598(word_80EE90E, (int *)a1);
        a1 -= 4;
        continue;
      case 28:
        if ( *((_DWORD *)a1 + 1) != 6 )
        {
          v12 = sub_80A61E0(v110, *(unsigned __int16 *)a2);
          sub_80A66D0(v12, (int *)a1);
          a1 -= 4;
        }
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 29:
        if ( *((_DWORD *)a1 + 1) == 6 )
        {
          sub_80A635A(v110, *(unsigned __int16 *)a2);
        }
        else
        {
          v13 = sub_80A61E0(v110, *(unsigned __int16 *)a2);
          sub_80A66D0(v13, (int *)a1);
          a1 -= 4;
        }
        a2 = (_DWORD *)((char *)a2 + 2);
        continue;
      case 30:
        while ( *((_DWORD *)a1 + 1) != 6 )
        {
          sub_80A9754((int *)a1);
          a1 -= 4;
        }
        continue;
      case 31:
        if ( *((_DWORD *)a1 + 1) == 6 )
          continue;
        Scr_Error((int)"function called with too many parameters");
        goto LABEL_60;
      case 32:
LABEL_60:
        sub_80A66D0(v108, (int *)a1);
        a1 -= 4;
        continue;
      case 33:
        dword_830AE24 = *(unsigned __int8 *)a2;
        v117 = (char *)a2 + 1;
        dword_830AE28 = (int)a1;
        (*(void (**)(void))v117)();
        a2 = v117 + 4;
        a1 = (unsigned __int16 *)dword_830AE28;
        if ( dword_830AE24 )
        {
          v107 = dword_830AE24;
          dword_830AE24 = 0;
          dword_830AE28 -= 8 * v107;
          do
          {
            sub_80A9754((int *)a1);
            a1 -= 4;
            --v107;
          }
          while ( v107 );
        }
        if ( dword_830AE20 )
        {
          dword_830AE20 = 0;
        }
        else
        {
          a1 += 4;
          *((_DWORD *)a1 + 1) = 0;
        }
        continue;
      case 34:
        dword_830AE24 = *(unsigned __int8 *)a2;
        a2 = (_DWORD *)((char *)a2 + 1);
        dword_830AE28 = (int)(a1 - 4);
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_76;
        v108 = *a1;
        if ( sub_80A6D12(v108) == 13 )
        {
          v102 = sub_80A7C38(v108);
          sub_80A5C0A(v108);
          ((void (__cdecl *)(int))*a2++)(v102);
          a1 = (unsigned __int16 *)dword_830AE28;
          if ( dword_830AE24 )
          {
            v107 = dword_830AE24;
            dword_830AE24 = 0;
            dword_830AE28 -= 8 * v107;
            do
            {
              sub_80A9754((int *)a1);
              a1 -= 4;
              --v107;
            }
            while ( v107 );
          }
          if ( dword_830AE20 )
          {
            dword_830AE20 = 0;
          }
          else
          {
            a1 += 4;
            *((_DWORD *)a1 + 1) = 0;
          }
        }
        else
        {
          v103 = sub_80A6D12(v108);
          sub_80A5C0A(v108);
          dword_830AD68 = -1;
          v14 = va("%s is not an entity", *(const char **)&off_80EE8C0[4 * v103]);
          Scr_Error((int)v14);
LABEL_76:
          v102 = *((_DWORD *)a1 + 1);
          sub_80A9754((int *)a1);
          dword_830AD68 = -1;
          v15 = va("%s is not an entity", *(const char **)&off_80EE8C0[4 * v102]);
          Scr_Error((int)v15);
LABEL_77:
          if ( v84 )
            Scr_Error((int)"wait not allowed in /# ... #/ comment (call as a thread to fix)");
          if ( (unsigned __int8)CastFloat(a1) )
          {
            v101 = *(float *)a1;
            if ( *(float *)a1 >= 0.0 )
            {
              if ( v101 < 16777.0 )
              {
                v70 = v101 * 1000.0;
                v104 = (dword_830AE2C + sub_80AF7E4(v70)) & 0xFFFFFF;
                v16 = sub_80A61E0(word_80EE90C, v104);
                v17 = sub_80A6B2E(v16);
                sub_80A620E(v17, v109);
                sub_80AD008(((char *)(a1 - 4) - (char *)a5) >> 3, (int)a2, v110, v109, (int)a5, v104);
                *((_DWORD *)a5 + 3) = 0;
                return v109;
              }
              v18 = va("wait of %.0f seconds is too long", v101);
              Scr_Error((int)v18);
            }
            v19 = va("negative wait of %g is not allowed", v101);
            Scr_Error((int)v19);
          }
          sub_80A98AE();
LABEL_86:
          v112 = a1 + 4;
          sub_80A5BCE(v110);
          *((_DWORD *)v112 + 1) = 7;
          *v112 = v110;
          a1 = v112 + 4;
          *((_DWORD *)a1 + 1) = 0;
        }
        continue;
      case 35:
        goto LABEL_77;
      case 36:
        goto LABEL_86;
      case 37:
        sub_80A5C0A(v110);
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v108 = sub_80A5B3C(v110);
          sub_80A5BCE(v108);
          v110 = sub_80A5AF4(v108);
          *(_DWORD *)&a1[-4 * a2[1] + 2] = 6;
          *(_DWORD *)&a1[-4 * a2[1]] = a2 + 2;
          a2 = (_DWORD *)*a2;
          continue;
        }
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_90:
        sub_80A5C0A(v110);
        if ( *((_DWORD *)a1 + 1) != 9 )
          goto LABEL_94;
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v93 = *(_DWORD **)a1;
          a1 -= 4;
          v108 = sub_80A5B3C(v110);
          sub_80A5BCE(v108);
          v110 = sub_80A5AF4(v108);
          *(_DWORD *)&a1[-4 * *a2 + 2] = 6;
          *(_DWORD *)&a1[-4 * *a2] = a2 + 1;
          a2 = v93;
          continue;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_94:
        v20 = va("%s is not a function pointer", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v20);
LABEL_95:
        sub_80A5C0A(v110);
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_101;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_100;
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v110 = sub_80A5AF4(*a1);
          a1 -= 4;
          *(_DWORD *)&a1[-4 * a2[1] + 2] = 6;
          *(_DWORD *)&a1[-4 * a2[1]] = a2 + 2;
          a2 = (_DWORD *)*a2;
          continue;
        }
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_100:
        dword_830AD68 = 1;
        v21 = sub_80A6D12(*a1);
        v22 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v21]);
        Scr_Error((int)v22);
LABEL_101:
        v23 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v23);
LABEL_102:
        sub_80A5C0A(v110);
        if ( *((_DWORD *)a1 + 1) != 9 )
          goto LABEL_110;
        v94 = *(_DWORD **)a1;
        a1 -= 4;
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_109;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_108;
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v110 = sub_80A5AF4(*a1);
          a1 -= 4;
          *(_DWORD *)&a1[-4 * *a2 + 2] = 6;
          *(_DWORD *)&a1[-4 * *a2] = a2 + 1;
          a2 = v94;
          continue;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_108:
        dword_830AD68 = 2;
        v24 = sub_80A6D12(*a1);
        v25 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v24]);
        Scr_Error((int)v25);
LABEL_109:
        dword_830AD68 = 2;
        v26 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v26);
LABEL_110:
        sub_80A9754((int *)a1);
        a1 -= 4;
        v27 = va("%s is not a function pointer", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 3)]);
        Scr_Error((int)v27);
LABEL_111:
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v108 = sub_80A5B3C(v110);
          sub_80A5BCE(v108);
          v108 = sub_80A5AF4(v108);
          v87 = &a1[-4 * a2[1]];
          v102 = *((_DWORD *)v87 + 1);
          *((_DWORD *)v87 + 1) = 6;
          v28 = sub_80AA520(a1, (_DWORD *)*a2, v108, v108, v87);
          sub_80A5C0A(v28);
          *((_DWORD *)v87 + 1) = v102;
          a1 = v87 + 4;
          a2 += 2;
          continue;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_114:
        if ( *((_DWORD *)a1 + 1) != 9 )
          goto LABEL_118;
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v95 = *(_DWORD **)a1;
          v113 = a1 - 4;
          v108 = sub_80A5B3C(v110);
          sub_80A5BCE(v108);
          v108 = sub_80A5AF4(v108);
          v88 = &v113[-4 * *a2];
          v102 = *((_DWORD *)v88 + 1);
          *((_DWORD *)v88 + 1) = 6;
          v29 = sub_80AA520(v113, v95, v108, v108, v88);
          sub_80A5C0A(v29);
          *((_DWORD *)v88 + 1) = v102;
          a1 = v88 + 4;
          ++a2;
          continue;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_118:
        v30 = va("%s is not a function pointer", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v30);
LABEL_119:
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_125;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_124;
        if ( dword_830ACC4 <= 31 )
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v108 = sub_80A5AF4(*a1);
          v114 = a1 - 4;
          v89 = &v114[-4 * a2[1]];
          v102 = *((_DWORD *)v89 + 1);
          *((_DWORD *)v89 + 1) = 6;
          v31 = sub_80AA520(v114, (_DWORD *)*a2, v108, v108, v89);
          sub_80A5C0A(v31);
          *((_DWORD *)v89 + 1) = v102;
          a1 = v89 + 4;
          a2 += 2;
          continue;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_124:
        dword_830AD68 = 2;
        v32 = sub_80A6D12(*a1);
        v33 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v32]);
        Scr_Error((int)v33);
LABEL_125:
        dword_830AD68 = 2;
        v34 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v34);
LABEL_126:
        if ( *((_DWORD *)a1 + 1) != 9 )
          goto LABEL_134;
        v96 = *(_DWORD **)a1;
        a1 -= 4;
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_133;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_132;
        if ( dword_830ACC4 > 31 )
        {
          dword_830AD68 = 1;
          Scr_Error((int)"script stack overflow (too many embedded function calls)");
LABEL_132:
          dword_830AD68 = 2;
          v36 = sub_80A6D12(*a1);
          v37 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v36]);
          Scr_Error((int)v37);
LABEL_133:
          dword_830AD68 = 2;
          v38 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
          Scr_Error((int)v38);
LABEL_134:
          sub_80A9754((int *)a1);
          a1 -= 4;
          v39 = va("%s is not a function pointer", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 3)]);
          Scr_Error((int)v39);
LABEL_135:
          sub_80A9754((int *)a1);
          a1 -= 4;
        }
        else
        {
          dword_830ACE0[dword_830ACC4++] = (int)a2;
          v108 = sub_80A5AF4(*a1);
          v115 = a1 - 4;
          v90 = &v115[-4 * *a2];
          v102 = *((_DWORD *)v90 + 1);
          *((_DWORD *)v90 + 1) = 6;
          v35 = sub_80AA520(v115, v96, v108, v108, v90);
          sub_80A5C0A(v35);
          *((_DWORD *)v90 + 1) = v102;
          a1 = v90 + 4;
          ++a2;
        }
        continue;
      case 38:
        goto LABEL_90;
      case 39:
        goto LABEL_95;
      case 40:
        goto LABEL_102;
      case 41:
        goto LABEL_111;
      case 42:
        goto LABEL_114;
      case 43:
        goto LABEL_119;
      case 44:
        goto LABEL_126;
      case 45:
        goto LABEL_135;
      case 46:
        v108 = sub_80A6C46(a1);
        a1 -= 4;
        continue;
      case 47:
        if ( *((_DWORD *)a1 + 1) == 5 )
        {
          *(_DWORD *)a1 = *(_DWORD *)a1 != 0;
          continue;
        }
        if ( (unsigned __int8)sub_80A9956((float *)a1) )
          continue;
        sub_80A98AE();
LABEL_141:
        if ( (unsigned __int8)sub_80A9A98((int)a1) )
          continue;
        sub_80A98AE();
LABEL_143:
        if ( (unsigned __int8)CastFloat(a1) )
          continue;
        sub_80A98AE();
LABEL_145:
        if ( (unsigned __int8)sub_80A9D32((int *)a1) )
          continue;
        sub_80A98AE();
LABEL_147:
        if ( *((_DWORD *)a1 + 1) == 5 || (unsigned __int8)sub_80A9956((float *)a1) )
        {
          *(_DWORD *)a1 = *(_DWORD *)a1 == 0;
          continue;
        }
        sub_80A98AE();
LABEL_151:
        if ( *((_DWORD *)a1 + 1) == 5 )
        {
          *(_DWORD *)a1 = ~*(_DWORD *)a1;
          continue;
        }
        v40 = va("~ cannot be applied to \"%s\"", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v40);
LABEL_154:
        if ( *((_DWORD *)a1 + 1) == 5 || (unsigned __int8)sub_80A9956((float *)a1) )
        {
          if ( !*(_DWORD *)a1 )
            a2 = (_DWORD *)((char *)a2 + *a2);
          ++a2;
          a1 -= 4;
          continue;
        }
        sub_80A98AE();
LABEL_160:
        if ( *((_DWORD *)a1 + 1) != 5 && !(unsigned __int8)sub_80A9956((float *)a1) )
        {
          dword_830AD68 = 1;
          sub_80A98AE();
LABEL_166:
          if ( *((_DWORD *)a1 + 1) == 5 || (unsigned __int8)sub_80A9956((float *)a1) )
          {
            if ( *(_DWORD *)a1 )
              a1 -= 4;
            else
              a2 = (_DWORD *)((char *)a2 + *a2);
            ++a2;
          }
          else
          {
            sub_80A98AE();
LABEL_173:
            if ( *((_DWORD *)a1 + 1) == 5 || (unsigned __int8)sub_80A9956((float *)a1) )
            {
              if ( *(_DWORD *)a1 )
                a2 = (_DWORD *)((char *)a2 + *a2);
              else
                a1 -= 4;
              ++a2;
            }
            else
            {
              sub_80A98AE();
LABEL_180:
              a2 = (_DWORD *)((char *)a2 + *a2);
            }
          }
          continue;
        }
        if ( !*(_DWORD *)a1 )
        {
          ++a2;
          a1 -= 4;
          continue;
        }
        a1 -= 4;
LABEL_181:
        if ( (int)(sub_80AF82C() - dword_830AE38) >= 0 )
        {
          a2 = (_DWORD *)((char *)a2 + *a2);
          continue;
        }
        if ( dword_830AD70 )
        {
          Com_Printf("script runtime warning: potential infinite loop in script.\n", v72);
          sub_80A2C3C(0, (unsigned int)a2, 0);
          a2 = (_DWORD *)((char *)a2 + *a2);
          dword_830AE38 = sub_80AF82C();
          continue;
        }
        if ( dword_81768C8 )
        {
          sub_80AF512((int)"potential infinite loop in script");
LABEL_188:
          a1 += 4;
          sub_80A67E6(v108, a1);
          if ( *((_DWORD *)a1 + 1) == 5 )
          {
            ++*(_DWORD *)a1;
          }
          else
          {
            v41 = va(
                    "++ must be applied to an int (applied to %s)",
                    *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
            Scr_Error((int)v41);
LABEL_191:
            a1 += 4;
            sub_80A67E6(v108, a1);
            if ( *((_DWORD *)a1 + 1) == 5 )
            {
              --*(_DWORD *)a1;
            }
            else
            {
              v42 = va(
                      "-- must be applied to an int (applied to %s)",
                      *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
              Scr_Error((int)v42);
LABEL_194:
              a1 -= 4;
              sub_80AF848((int)a1);
              if ( *((_DWORD *)a1 + 1) == 5 )
              {
                *(_DWORD *)a1 |= *((_DWORD *)a1 + 2);
              }
              else
              {
LABEL_315:
                if ( !dword_830AD60 )
                  sub_80AA004((int *)a1, (int *)a1 + 2);
                sub_80A98AE();
                if ( byte_830AD6C )
                  sub_80A2F52((unsigned int)a2, dword_830AD68, (const char *)dword_830AD60, (void *)dword_830AD64);
                switch ( v85 )
                {
                  case 20:
                    sub_80A9754((int *)a1);
                    sub_80A9754((int *)a1 + 2);
                    *((_DWORD *)a1 + 1) = 0;
                    break;
                  case 21:
                    sub_80A667C(word_80EE90E);
                    v108 = word_80EE90E;
                    goto LABEL_321;
                  case 22:
LABEL_321:
                    if ( dword_830AD68 < 0 )
                      dword_830AD68 = 1;
                    goto LABEL_323;
                  case 24:
                  case 26:
                    goto LABEL_328;
                  case 28:
                  case 29:
                    while ( dword_830AE24 )
                    {
                      sub_80A9754((int *)dword_830AE28);
                      dword_830AE28 -= 8;
                      --dword_830AE24;
                    }
                    a1 -= 4;
LABEL_328:
                    dword_830AD68 = 0;
                    a2 = (_DWORD *)((char *)a2 + 2);
                    break;
                  case 31:
                    do
                    {
                      sub_80A9754((int *)a1);
                      a1 -= 4;
                    }
                    while ( *((_DWORD *)a1 + 1) != 6 );
                    break;
                  case 32:
                    while ( dword_830AE24 )
                    {
                      sub_80A9754((int *)dword_830AE28);
                      dword_830AE28 -= 8;
                      --dword_830AE24;
                    }
                    a1 -= 4;
                    dword_830AD68 = 0;
                    break;
                  case 33:
                    if ( dword_830AD68 > 0 )
                      dword_830AD68 = dword_830AE24 - dword_830AD68 + 1;
                    ++a2;
                    while ( dword_830AE24 )
                    {
                      sub_80A9754((int *)dword_830AE28);
                      dword_830AE28 -= 8;
                      --dword_830AE24;
                    }
                    a1 = (unsigned __int16 *)(dword_830AE28 + 8);
                    *(_DWORD *)(dword_830AE28 + 12) = 0;
                    break;
                  case 34:
                    if ( dword_830AD68 <= 0 )
                    {
                      if ( dword_830AD68 < 0 )
                        dword_830AD68 = 1;
                    }
                    else
                    {
                      dword_830AD68 = dword_830AE24 - dword_830AD68 + 2;
                    }
                    ++a2;
                    while ( dword_830AE24 )
                    {
                      sub_80A9754((int *)dword_830AE28);
                      dword_830AE28 -= 8;
                      --dword_830AE24;
                    }
                    a1 = (unsigned __int16 *)(dword_830AE28 + 8);
                    *(_DWORD *)(dword_830AE28 + 12) = 0;
                    break;
                  case 35:
                    a1 -= 4;
                    dword_830AD68 = 1;
                    break;
                  case 37:
                    v119 = a2 + 1;
                    dword_830AE24 = *v119;
                    a2 = v119 + 1;
                    while ( dword_830AE24 )
                    {
                      sub_80A9754((int *)a1);
                      a1 -= 4;
                      --dword_830AE24;
                    }
                    a1 -= 4;
                    *((_DWORD *)a1 + 1) = 0;
                    break;
                  case 38:
                  case 40:
                    goto LABEL_356;
                  case 39:
                    ++a2;
LABEL_356:
                    for ( dword_830AE24 = *a2++ + 1; dword_830AE24; --dword_830AE24 )
                    {
                      sub_80A9754((int *)a1);
                      a1 -= 4;
                    }
                    a1 -= 4;
                    *((_DWORD *)a1 + 1) = 0;
                    break;
                  case 42:
                  case 44:
                    goto LABEL_361;
                  case 43:
                    ++a2;
LABEL_361:
                    for ( dword_830AE24 = *a2++ + 1; dword_830AE24; --dword_830AE24 )
                    {
                      sub_80A9754((int *)a1);
                      a1 -= 4;
                    }
                    a1 += 4;
                    *((_DWORD *)a1 + 1) = 0;
                    break;
                  case 46:
                    sub_80A9754((int *)a1);
                    sub_80A667C(word_80EE90E);
                    v108 = sub_80A6AD2(word_80EE90E);
                    a1 -= 4;
                    break;
                  case 52:
                  case 77:
                    sub_80A9754((int *)a1);
                    *((_DWORD *)a1 + 1) = 0;
                    break;
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                    ++a2;
                    a1 -= 4;
                    break;
                  case 59:
                  case 60:
                    dword_830AD68 = 0;
                    break;
                  case 78:
                    a2 = (_DWORD *)((char *)a2 + 1);
                    goto LABEL_369;
                  case 79:
                  case 81:
LABEL_369:
                    sub_80A9754((int *)a1);
                    v116 = (int *)(a1 - 4);
                    sub_80A9754(v116);
                    a1 = (unsigned __int16 *)(v116 - 2);
                    break;
                  case 80:
                    while ( *((_DWORD *)a1 + 1) != 6 )
                    {
                      sub_80A9754((int *)a1);
                      a1 -= 4;
                    }
LABEL_323:
                    sub_80A9754((int *)a1);
                    a1 -= 4;
                    break;
                  case 83:
                    sub_80A9754((int *)a1);
                    a1 -= 4;
                    a2 += 2 * v102;
                    break;
                  case 85:
                    sub_80A9FCA((int)a1);
                    break;
                  default:
                    break;
                }
                sub_80A2F52((unsigned int)a2, dword_830AD68, (const char *)dword_830AD60, (void *)dword_830AD64);
                dword_830AD60 = 0;
                dword_830AD64 = 0;
                dword_830AD68 = 0;
              }
            }
          }
          continue;
        }
        Com_Printf("script runtime error: potential infinite loop in script - killing thread.\n", v72);
        sub_80A2C3C(0, (unsigned int)a2, 0);
        dword_830AE38 = sub_80AF82C();
LABEL_10:
        while ( 1 )
        {
          sub_80A55C2(v110);
          while ( *((_DWORD *)a1 + 1) != 6 )
          {
            sub_80A9754((int *)a1);
            a1 -= 4;
          }
          --dword_830ACC4;
          if ( a1 == a5 )
            break;
          sub_80A5C0A(v110);
          a1 -= 4;
          v110 = *a1;
          *((_DWORD *)a1 + 1) = 0;
        }
        *((_DWORD *)a5 + 3) = 0;
        return v110;
      case 48:
        goto LABEL_141;
      case 49:
        goto LABEL_143;
      case 50:
        goto LABEL_145;
      case 51:
        goto LABEL_147;
      case 52:
        goto LABEL_151;
      case 53:
        goto LABEL_154;
      case 54:
        goto LABEL_160;
      case 55:
        goto LABEL_166;
      case 56:
        goto LABEL_173;
      case 57:
        goto LABEL_180;
      case 58:
        goto LABEL_181;
      case 59:
        goto LABEL_188;
      case 60:
        goto LABEL_191;
      case 61:
        goto LABEL_194;
      case 62:
        a1 -= 4;
        sub_80AF848((int)a1);
        if ( *((_DWORD *)a1 + 1) != 5 )
          goto LABEL_315;
        *(_DWORD *)a1 ^= *((_DWORD *)a1 + 2);
        continue;
      case 63:
        a1 -= 4;
        sub_80AF848((int)a1);
        if ( *((_DWORD *)a1 + 1) != 5 )
          goto LABEL_315;
        *(_DWORD *)a1 &= *((_DWORD *)a1 + 2);
        continue;
      case 64:
        a1 -= 4;
        if ( (unsigned __int8)sub_80AA2C4((int)a1, a1 + 4) )
          continue;
        sub_80A98AE();
        goto LABEL_202;
      case 65:
LABEL_202:
        a1 -= 4;
        if ( !(unsigned __int8)sub_80AF848((int)a1) || *((_DWORD *)a1 + 1) > 0xBu )
          goto LABEL_315;
        switch ( *((_DWORD *)a1 + 1) )
        {
          case 0:
            *((_DWORD *)a1 + 1) = 5;
            *(_DWORD *)a1 = 0;
            break;
          case 1:
          case 2:
            *((_DWORD *)a1 + 1) = 5;
            v102 = *a1 != a1[4];
            sub_80A40A6(*a1);
            sub_80A40A6(a1[4]);
            *(_DWORD *)a1 = v102;
            break;
          case 3:
            *((_DWORD *)a1 + 1) = 5;
            v82 = 0;
            if ( **(float **)a1 != **((float **)a1 + 2)
              || *(float *)(*(_DWORD *)a1 + 4) != *(float *)(*((_DWORD *)a1 + 2) + 4)
              || *(float *)(*(_DWORD *)a1 + 8) != *(float *)(*((_DWORD *)a1 + 2) + 8) )
            {
              v82 = 1;
            }
            v102 = v82;
            sub_80A5D00(*(_DWORD *)a1);
            sub_80A5D00(*((_DWORD *)a1 + 2));
            *(_DWORD *)a1 = v82;
            break;
          case 4:
            *((_DWORD *)a1 + 1) = 5;
            v71 = *(float *)a1 - *((float *)a1 + 2);
            *(_DWORD *)a1 = sub_80AF812(v71) >= 0.000001;
            break;
          case 5:
            *(_DWORD *)a1 = *(_DWORD *)a1 != *((_DWORD *)a1 + 2);
            break;
          case 6:
          case 8:
          case 9:
          case 0xA:
            goto LABEL_315;
          case 7:
            *((_DWORD *)a1 + 1) = 5;
            v102 = *a1 != a1[4];
            sub_80A5C0A(*a1);
            sub_80A5C0A(a1[4]);
            *(_DWORD *)a1 = v102;
            break;
          case 0xB:
            *((_DWORD *)a1 + 1) = 5;
            *(_DWORD *)a1 = *(_DWORD *)a1 != *((_DWORD *)a1 + 2);
            break;
        }
        continue;
      case 66:
        a1 -= 4;
        sub_80AF848((int)a1);
        v81 = *((_DWORD *)a1 + 1);
        if ( v81 == 4 )
        {
          *((_DWORD *)a1 + 1) = 5;
          *(_DWORD *)a1 = *((float *)a1 + 2) > (long double)*(float *)a1;
        }
        else
        {
          if ( v81 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 = *(_DWORD *)a1 < *((_DWORD *)a1 + 2);
        }
        continue;
      case 67:
        a1 -= 4;
        sub_80AF848((int)a1);
        v80 = *((_DWORD *)a1 + 1);
        if ( v80 == 4 )
        {
          *((_DWORD *)a1 + 1) = 5;
          *(_DWORD *)a1 = *(float *)a1 > (long double)*((float *)a1 + 2);
        }
        else
        {
          if ( v80 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 = *(_DWORD *)a1 > *((_DWORD *)a1 + 2);
        }
        continue;
      case 68:
        a1 -= 4;
        sub_80AF848((int)a1);
        v79 = *((_DWORD *)a1 + 1);
        if ( v79 == 4 )
        {
          *((_DWORD *)a1 + 1) = 5;
          *(_DWORD *)a1 = *((float *)a1 + 2) >= (long double)*(float *)a1;
        }
        else
        {
          if ( v79 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 = *(_DWORD *)a1 <= *((_DWORD *)a1 + 2);
        }
        continue;
      case 69:
        a1 -= 4;
        sub_80AF848((int)a1);
        v78 = *((_DWORD *)a1 + 1);
        if ( v78 == 4 )
        {
          *((_DWORD *)a1 + 1) = 5;
          *(_DWORD *)a1 = *(float *)a1 >= (long double)*((float *)a1 + 2);
        }
        else
        {
          if ( v78 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 = *(_DWORD *)a1 >= *((_DWORD *)a1 + 2);
        }
        continue;
      case 70:
        a1 -= 4;
        sub_80AF848((int)a1);
        if ( *((_DWORD *)a1 + 1) != 5 )
          goto LABEL_315;
        *(_DWORD *)a1 <<= *((_BYTE *)a1 + 8);
        continue;
      case 71:
        a1 -= 4;
        sub_80AF848((int)a1);
        if ( *((_DWORD *)a1 + 1) != 5 )
          goto LABEL_315;
        *(int *)a1 >>= *((_BYTE *)a1 + 8);
        continue;
      case 72:
        a1 -= 4;
        sub_80AF848((int)a1);
        v77 = *((_DWORD *)a1 + 1);
        if ( v77 == 3 )
        {
          v91 = (float *)sub_80A5C64();
          *v91 = **(float **)a1 + **((float **)a1 + 2);
          v91[1] = *(float *)(*(_DWORD *)a1 + 4) + *(float *)(*((_DWORD *)a1 + 2) + 4);
          v91[2] = *(float *)(*(_DWORD *)a1 + 8) + *(float *)(*((_DWORD *)a1 + 2) + 8);
          sub_80A5D00(*(_DWORD *)a1);
          sub_80A5D00(*((_DWORD *)a1 + 2));
          *(_DWORD *)a1 = v91;
        }
        else if ( v77 > 3 )
        {
          if ( v77 == 4 )
          {
            *(float *)a1 = *(float *)a1 + *((float *)a1 + 2);
          }
          else
          {
            if ( v77 != 5 )
              goto LABEL_315;
            *(_DWORD *)a1 += *((_DWORD *)a1 + 2);
          }
        }
        else
        {
          if ( v77 != 1 )
            goto LABEL_315;
          v98 = sub_80AF736(a1);
          sub_80A40A6(*a1);
          sub_80A40A6(a1[4]);
          *a1 = v98;
        }
        continue;
      case 73:
        a1 -= 4;
        sub_80AF848((int)a1);
        v76 = *((_DWORD *)a1 + 1);
        if ( v76 == 4 )
        {
          *(float *)a1 = *(float *)a1 - *((float *)a1 + 2);
        }
        else if ( v76 > 4 )
        {
          if ( v76 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 -= *((_DWORD *)a1 + 2);
        }
        else
        {
          if ( v76 != 3 )
            goto LABEL_315;
          v92 = (float *)sub_80A5C64();
          *v92 = **(float **)a1 - **((float **)a1 + 2);
          v92[1] = *(float *)(*(_DWORD *)a1 + 4) - *(float *)(*((_DWORD *)a1 + 2) + 4);
          v92[2] = *(float *)(*(_DWORD *)a1 + 8) - *(float *)(*((_DWORD *)a1 + 2) + 8);
          sub_80A5D00(*(_DWORD *)a1);
          sub_80A5D00(*((_DWORD *)a1 + 2));
          *(_DWORD *)a1 = v92;
        }
        continue;
      case 74:
        a1 -= 4;
        sub_80AF848((int)a1);
        v75 = *((_DWORD *)a1 + 1);
        if ( v75 == 4 )
        {
          *(float *)a1 = *(float *)a1 * *((float *)a1 + 2);
        }
        else
        {
          if ( v75 != 5 )
            goto LABEL_315;
          *(_DWORD *)a1 *= *((_DWORD *)a1 + 2);
        }
        continue;
      case 75:
        a1 -= 4;
        sub_80AF848((int)a1);
        v74 = *((_DWORD *)a1 + 1);
        if ( v74 == 4 )
          goto LABEL_263;
        if ( v74 != 5 )
          goto LABEL_315;
        if ( *((_DWORD *)a1 + 2) )
        {
          *(int *)a1 /= *((int *)a1 + 2);
          continue;
        }
        *(_DWORD *)a1 = 0;
        Scr_Error((int)"divide by 0");
LABEL_263:
        if ( *((float *)a1 + 2) == 0.0 )
        {
LABEL_264:
          *(_DWORD *)a1 = 0;
          Scr_Error((int)"divide by 0");
          goto LABEL_315;
        }
        *(float *)a1 = *(float *)a1 / *((float *)a1 + 2);
        continue;
      case 76:
        a1 -= 4;
        sub_80AF848((int)a1);
        if ( *((_DWORD *)a1 + 1) != 5 )
          goto LABEL_315;
        if ( !*((_DWORD *)a1 + 2) )
          goto LABEL_264;
        *(int *)a1 %= *((_DWORD *)a1 + 2);
        continue;
      case 77:
        sub_80A691A(a1);
        continue;
      case 78:
      case 79:
        if ( v84 )
          Scr_Error((int)"waittill not allowed in /# ... #/ comment (call as a thread to fix)");
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_279;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_278;
        if ( *((_DWORD *)a1 - 1) == 1 )
        {
          v99 = *(a1 - 4);
          v43 = sub_80A61E0(*a1, 0x20000u);
          v44 = sub_80A6B2E(v43);
          v45 = sub_80A61E0(v44, v99);
          v46 = sub_80A6B2E(v45);
          sub_80A620E(v46, v109);
          v106 = 7;
          LOWORD(v105) = *a1;
          v47 = sub_80A5B3C(v109);
          v48 = sub_80A620E(word_830AE30, v47);
          v49 = sub_80A6B2E(v48);
          v50 = sub_80A620E(v49, v109);
          sub_80A6608(v50, (int *)&v105);
          sub_80A5514(v109, v99);
          sub_80A40A6(v99);
          sub_80AD008(((char *)(a1 - 8) - (char *)a5) >> 3, (int)a2, v110, v109, (int)a5, 0);
          *((_DWORD *)a5 + 3) = 0;
          return v109;
        }
        dword_830AD68 = 1;
        Scr_Error((int)"first parameter of waittill must evaluate to a string");
LABEL_278:
        dword_830AD68 = 2;
        v51 = sub_80A6D12(*a1);
        v52 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v51]);
        Scr_Error((int)v52);
LABEL_279:
        dword_830AD68 = 2;
        v53 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
        Scr_Error((int)v53);
LABEL_280:
        if ( *((_DWORD *)a1 + 1) != 7 )
          goto LABEL_289;
        if ( !sub_80A6BBA(*a1) )
          goto LABEL_288;
        if ( *((_DWORD *)a1 - 1) == 1 )
        {
          sub_80AD504(*a1, *(a1 - 4), (int *)a1 - 4);
          while ( *((_DWORD *)a1 + 1) != 6 )
          {
            sub_80A9754((int *)a1);
            a1 -= 4;
          }
          a1 -= 4;
        }
        else
        {
          dword_830AD68 = 1;
          Scr_Error((int)"first parameter of notify must evaluate to a string");
LABEL_288:
          dword_830AD68 = 2;
          v54 = sub_80A6D12(*a1);
          v55 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v54]);
          Scr_Error((int)v55);
LABEL_289:
          dword_830AD68 = 2;
          v56 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
          Scr_Error((int)v56);
LABEL_290:
          if ( *((_DWORD *)a1 + 1) == 7 )
          {
            if ( sub_80A6BBA(*a1) )
            {
              if ( *((_DWORD *)a1 - 1) == 1 )
              {
                v100 = *(a1 - 4);
                sub_80A5BCE(v109);
                v86 = sub_80A5AF4(v109);
                v57 = sub_80A61E0(*a1, 0x20000u);
                v58 = sub_80A6B2E(v57);
                v59 = sub_80A61E0(v58, v100);
                v60 = sub_80A6B2E(v59);
                sub_80A620E(v60, v86);
                sub_80A5C0A(v86);
                v106 = 7;
                LOWORD(v105) = *a1;
                v61 = sub_80A620E(word_830AE30, v109);
                v62 = sub_80A6B2E(v61);
                v63 = sub_80A620E(v62, v86);
                sub_80A6608(v63, (int *)&v105);
                sub_80A5514(v86, v100);
                sub_80A40A6(v100);
                a1 -= 8;
                continue;
              }
              Scr_Error((int)"first parameter of endof must evaluate to a string");
            }
            dword_830AD68 = 1;
            v64 = sub_80A6D12(*a1);
            v65 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * v64]);
            Scr_Error((int)v65);
          }
          dword_830AD68 = 1;
          v66 = va("%s is not an object", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
          Scr_Error((int)v66);
LABEL_297:
          a1 += 4;
          *((_DWORD *)a1 + 1) = 6;
          *(_DWORD *)a1 = 0;
        }
        continue;
      case 80:
        goto LABEL_280;
      case 81:
        goto LABEL_290;
      case 82:
        goto LABEL_297;
      case 83:
        a2 = (_DWORD *)((char *)a2 + *(__int16 *)a2);
        v102 = *((__int16 *)a2 - 1);
        v73 = *((_DWORD *)a1 + 1);
        if ( v73 == 1 )
          goto LABEL_303;
        if ( v73 == 5 )
        {
          if ( sub_80A5DFA(*(_DWORD *)a1) )
          {
            v97 = sub_80A5E20(*(_DWORD *)a1);
          }
          else
          {
            v67 = va("switch index %d out of range", *(_DWORD *)a1);
            Scr_Error((int)v67);
LABEL_303:
            v97 = *a1;
            sub_80A40A6(*a1);
          }
        }
        else
        {
          v68 = va("cannot switch on %s", *(const char **)&off_80EE8C0[4 * *((_DWORD *)a1 + 1)]);
          Scr_Error((int)v68);
        }
        a1 -= 4;
        if ( !v102 )
          continue;
        do
        {
          if ( *a2 == v97 )
          {
            a2 = (_DWORD *)a2[1];
            goto LABEL_2;
          }
          a2 += 2;
          --v102;
        }
        while ( v102 );
        if ( !*(a2 - 2) )
          a2 = (_DWORD *)*(a2 - 1);
        continue;
      case 84:
        a2 = (_DWORD *)((char *)a2 + 8 * *(__int16 *)a2 + 2);
        continue;
      case 85:
        a1 -= 8;
        sub_80A9F4A(a1);
        continue;
      case 86:
        continue;
      case 87:
        dword_830AD80[dword_830ACC4] = (int)a2;
        v118 = *((_DWORD *)dword_80EE844 + (_DWORD)a2 - dword_80EE864 - 1);
        *(_BYTE *)(dword_830ACC4 + 137408000) = *(_BYTE *)v118;
        a2 = (_DWORD *)(v118 + 1);
        ++v84;
        continue;
      case 88:
        a2 = (_DWORD *)dword_830AD80[dword_830ACC4];
        v85 = *(_BYTE *)(dword_830ACC4 + 137408000);
        dword_830AD80[dword_830ACC4] = 0;
        --v84;
        goto LABEL_3;
      default:
        goto LABEL_315;
    }
  }
}
// 80ABACB: variable 'v72' is possibly undefined
// 80ACA36: variable 'v97' is possibly undefined
// 80ACFA7: variable 'v102' is possibly undefined
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 80EE864: using guessed type int dword_80EE864;
// 80EE90C: using guessed type __int16 word_80EE90C;
// 80EE90E: using guessed type __int16 word_80EE90E;
// 81768C8: using guessed type int dword_81768C8;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AD60: using guessed type int dword_830AD60;
// 830AD64: using guessed type int dword_830AD64;
// 830AD68: using guessed type int dword_830AD68;
// 830AD6C: using guessed type char byte_830AD6C;
// 830AD70: using guessed type int dword_830AD70;
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE34: using guessed type __int16 word_830AE34;
// 830AE36: using guessed type __int16 word_830AE36;
// 830AE38: using guessed type int dword_830AE38;

//----- (080AD008) --------------------------------------------------------
int __cdecl sub_80AD008(int a1, int a2, __int16 a3, unsigned __int16 a4, int a5, int a6)
{
  unsigned __int16 v6; // ax
  _BYTE *v8; // [esp+10h] [ebp-18h]
  _DWORD *v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11[3]; // [esp+18h] [ebp-10h] BYREF
  unsigned __int16 v12; // [esp+24h] [ebp-4h]
  __int16 v13; // [esp+26h] [ebp-2h]

  v13 = a3;
  v12 = a4;
  v10 = sub_80A1F70(5 * a1 + 12);
  *(_WORD *)(v10 + 10) = a3;
  sub_80A5BCE(v12);
  *(_WORD *)(v10 + 8) = a1;
  *(_DWORD *)v10 = a6;
  *(_DWORD *)(v10 + 4) = a2;
  v8 = (_BYTE *)(v10 + 12);
  --dword_830ACC4;
  while ( a1 )
  {
    --a1;
    a5 += 8;
    *v8 = *(_BYTE *)(a5 + 4);
    if ( *(_DWORD *)(a5 + 4) == 6 )
      --dword_830ACC4;
    v9 = v8 + 1;
    *v9 = *(_DWORD *)a5;
    v8 = v9 + 1;
  }
  v11[1] = 10;
  v11[0] = v10;
  v6 = sub_80A61E0(v12, 0x20001u);
  return sub_80A6608(v6, v11);
}
// 830ACC4: using guessed type int dword_830ACC4;

//----- (080AD0FC) --------------------------------------------------------
int __cdecl sub_80AD0FC(unsigned __int16 a1, int a2)
{
  int v3; // [esp+18h] [ebp-10h]
  _BYTE *v4; // [esp+1Ch] [ebp-Ch]
  int *v5; // [esp+1Ch] [ebp-Ch]
  int *v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  unsigned __int16 v9; // [esp+24h] [ebp-4h]

  sub_80A6248(a1, 131073);
  sub_80A5C0A(a1);
  v3 = *(unsigned __int16 *)(a2 + 8);
  v9 = *(_WORD *)(a2 + 10);
  v4 = (_BYTE *)(5 * v3 + a2 + 12);
  sub_80A55C2(v9);
  sub_80A5C0A(v9);
  while ( v3 )
  {
    v5 = (int *)(v4 - 4);
    v7 = *v5;
    v4 = (char *)v5 - 1;
    --v3;
    if ( *v4 == 6 )
    {
      v6 = (int *)(v4 - 4);
      v8 = *v6;
      v4 = (char *)v6 - 1;
      --v3;
      sub_80A55C2(v8);
      sub_80A5C0A(v8);
    }
    else
    {
      sub_80A5DA8((unsigned __int8)*v4, v7);
    }
  }
  return sub_80A1F96(a2, 5 * *(unsigned __int16 *)(a2 + 8) + 12);
}

//----- (080AD206) --------------------------------------------------------
int __cdecl sub_80AD206(unsigned __int16 a1)
{
  int *v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  v3 = sub_80A5E90(a1, 131073);
  if ( v3 )
  {
    v1 = GetVariableValueAddress(v3);
    result = sub_80AD0FC(a1, *v1);
  }
  else
  {
    sub_80A55C2(a1);
    result = sub_80A5C0A(a1);
  }
  return result;
}

//----- (080AD26C) --------------------------------------------------------
int __cdecl sub_80AD26C(unsigned __int16 a1, unsigned __int16 a2)
{
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int result; // eax
  unsigned __int16 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+12h] [ebp-6h]

  v7 = sub_80A54EC(a2);
  sub_80A556C(a2);
  v2 = sub_80A5E90(a1, 0x20000);
  v6 = sub_80A6B8A(v2);
  v3 = sub_80A5E90(v6, v7);
  v5 = sub_80A6B8A(v3);
  sub_80A62D2(v5, a2);
  result = sub_80A6A06(v5);
  if ( !result )
  {
    sub_80A6248(v6, v7);
    result = sub_80A6A06(v6);
    if ( !result )
      result = sub_80A6248(a1, 0x20000);
  }
  return result;
}

//----- (080AD340) --------------------------------------------------------
int __cdecl sub_80AD340(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // ax
  int v3; // [esp+10h] [ebp-18h]
  unsigned __int16 v4; // [esp+16h] [ebp-12h]
  int *v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  unsigned __int16 v9; // [esp+24h] [ebp-4h]
  unsigned __int16 v10; // [esp+24h] [ebp-4h]

  result = sub_80A5E90(a1, 131073);
  if ( (_WORD)result )
  {
    v5 = (int *)*GetVariableValueAddress(result);
    v7 = sub_80A5B3C(a1);
    v8 = sub_80A5EBE(word_830AE30, v7);
    if ( v8 && (v6 = sub_80A6B8A(v8), (v9 = sub_80A5EBE(v6, a1)) != 0) )
    {
      v4 = *(_WORD *)GetVariableValueAddress(v9);
      sub_80AD26C(v4, a1);
      sub_80A5BCE(a1);
      sub_80A62D2(v6, a1);
      if ( !sub_80A6A06(v6) )
        sub_80A62D2(word_830AE30, v7);
    }
    else
    {
      v3 = *v5;
      v2 = sub_80A5E90(word_80EE90C, *v5);
      v10 = sub_80A6B8A(v2);
      sub_80A5BCE(a1);
      sub_80A62D2(v10, a1);
      if ( !sub_80A6A06(v10) && v3 != dword_830AE2C )
        sub_80A6248(word_80EE90C, v3);
    }
    result = sub_80AD0FC(a1, (int)v5);
  }
  return result;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;

//----- (080AD504) --------------------------------------------------------
int __cdecl sub_80AD504(unsigned __int16 a1, unsigned __int16 a2, int *a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  int v5; // edx
  unsigned __int16 v6; // ax
  unsigned __int16 v7; // ax
  int v8; // [esp+18h] [ebp-50h] BYREF
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10[2]; // [esp+20h] [ebp-48h] BYREF
  bool v11; // [esp+2Bh] [ebp-3Dh]
  unsigned __int16 i; // [esp+2Ch] [ebp-3Ch]
  unsigned __int16 v13; // [esp+2Eh] [ebp-3Ah]
  unsigned __int16 v14; // [esp+30h] [ebp-38h]
  unsigned __int16 v15; // [esp+32h] [ebp-36h]
  int v16; // [esp+34h] [ebp-34h]
  int v17; // [esp+38h] [ebp-30h]
  size_t n; // [esp+3Ch] [ebp-2Ch]
  int v19; // [esp+40h] [ebp-28h]
  int v20; // [esp+44h] [ebp-24h]
  unsigned __int8 *v21; // [esp+48h] [ebp-20h]
  int v22; // [esp+4Ch] [ebp-1Ch]
  int v23; // [esp+50h] [ebp-18h]
  int *v24; // [esp+54h] [ebp-14h]
  int *j; // [esp+58h] [ebp-10h]
  unsigned __int16 v26; // [esp+5Eh] [ebp-Ah]
  unsigned __int16 v27; // [esp+60h] [ebp-8h]
  unsigned __int16 v28; // [esp+62h] [ebp-6h]
  unsigned __int16 v29; // [esp+64h] [ebp-4h]
  unsigned __int16 v30; // [esp+66h] [ebp-2h]

  v30 = a1;
  v29 = a2;
  result = sub_80A5E90(a1, 0x20000);
  v27 = result;
  if ( (_WORD)result )
  {
    v27 = sub_80A6B8A(v27);
    result = sub_80A5E90(v27, v29);
    v28 = result;
    if ( (_WORD)result )
    {
      v28 = sub_80A6B8A(v28);
      sub_80A5BCE(v28);
LABEL_4:
      for ( i = FindNextSibling(v28); i; i = FindNextSibling(i) )
      {
        v26 = sub_80A4AD0(i);
        v15 = sub_80A5B3C(v26);
        v4 = sub_80A5EBE(word_830AE30, v15);
        v13 = sub_80A6B8A(v4);
        v14 = sub_80A5E90(v26, 131073);
        if ( !v14 )
        {
          sub_80A556C(v26);
          sub_80A5BCE(v26);
          sub_80A62D2(v28, v26);
          if ( !sub_80A6A06(v28) )
          {
            sub_80A6248(v27, v29);
            if ( !sub_80A6A06(v27) )
              sub_80A6248(v30, 0x20000);
          }
          sub_80A62D2(v13, v26);
          if ( !sub_80A6A06(v13) )
            sub_80A62D2(word_830AE30, v15);
          sub_80A5BCE(v15);
          sub_80A55C2(v26);
          sub_80A5C0A(v26);
          sub_80AD340(v15);
          sub_80A5C0A(v15);
          goto LABEL_4;
        }
        v24 = GetVariableValueAddress(v14);
        v23 = *v24;
        if ( *(_BYTE *)(*(_DWORD *)(v23 + 4) - 1) != 78 )
        {
          v11 = a3[1] == 6;
LABEL_24:
          sub_80A556C(v26);
          sub_80A62D2(v28, v26);
          if ( !sub_80A6A06(v28) )
          {
            sub_80A6248(v27, v29);
            if ( !sub_80A6A06(v27) )
              sub_80A6248(v30, 0x20000);
          }
          *(_DWORD *)v23 = dword_830AE2C;
          v6 = sub_80A61E0(word_80EE90C, dword_830AE2C);
          v7 = sub_80A6B2E(v6);
          sub_80A620E(v7, v26);
          sub_80A62D2(v13, v26);
          if ( !sub_80A6A06(v13) )
            sub_80A62D2(word_830AE30, v15);
          if ( !v11 )
          {
            v20 = *(unsigned __int16 *)(v23 + 8);
            v19 = v20;
            j = a3;
            do
            {
              ++v19;
              j -= 2;
            }
            while ( j[1] != 6 );
            n = 5 * v20;
            v17 = 5 * v19 + 12;
            v16 = 5 * v20 + 12;
            if ( !sub_80A1FBC(v16, v17) )
            {
              v22 = sub_80A1F70(v17);
              *(_DWORD *)v22 = *(_DWORD *)v23;
              *(_DWORD *)(v22 + 4) = *(_DWORD *)(v23 + 4);
              *(_WORD *)(v22 + 10) = *(_WORD *)(v23 + 10);
              sub_80D2FC8((void *)(v22 + 12), (void *)(v23 + 12), n);
              sub_80A1F96(v23, v16);
              v23 = v22;
              *v24 = v22;
            }
            *(_WORD *)(v23 + 8) = v19;
            v21 = (unsigned __int8 *)(v23 + n + 12);
            v19 -= v20;
            do
            {
              j += 2;
              sub_80A9734(j);
              *v21++ = *((_BYTE *)j + 4);
              *(_DWORD *)v21 = *j;
              v21 += 4;
              --v19;
            }
            while ( v19 );
          }
          goto LABEL_4;
        }
        v20 = **(char **)(v23 + 4);
        v21 = (unsigned __int8 *)(v23 + 5 * (*(unsigned __int16 *)(v23 + 8) - v20) + 12);
        for ( j = a3; ; j -= 2 )
        {
          if ( !v20 )
            goto LABEL_22;
          if ( j[1] == 6 )
            goto LABEL_37;
          --v20;
          v9 = *v21;
          if ( v9 == 6 )
          {
LABEL_22:
            ++*(_DWORD *)(v23 + 4);
            v11 = 1;
            goto LABEL_24;
          }
          v8 = *(_DWORD *)++v21;
          v21 += 4;
          sub_80A9734(&v8);
          v5 = j[1];
          v10[0] = *j;
          v10[1] = v5;
          sub_80A9734(v10);
          if ( !(unsigned __int8)sub_80AA2C4((int)&v8, (unsigned __int16 *)v10) )
            break;
          if ( !v8 )
            goto LABEL_37;
        }
        sub_80A2F52(
          *(_DWORD *)(v23 + 4),
          **(char **)(v23 + 4) - v20 + 2,
          (const char *)dword_830AD60,
          (void *)dword_830AD64);
        dword_830AD60 = 0;
        dword_830AD64 = 0;
LABEL_37:
        ;
      }
      result = sub_80A5C0A(v28);
    }
  }
  return result;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 830AD60: using guessed type int dword_830AD60;
// 830AD64: using guessed type int dword_830AD64;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;

//----- (080ADAA0) --------------------------------------------------------
int __cdecl sub_80ADAA0(unsigned __int16 a1, unsigned __int16 a2, int a3)
{
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+28h] [ebp+10h]

  while ( dword_830AE24 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
    --dword_830AE24;
  }
  v5 = dword_830AE28 - 8 * a3;
  v6 = dword_830AE20 - a3;
  v4 = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(v5 + 4) = 6;
  dword_830AE20 = 0;
  sub_80AD504(a1, a2, (int *)dword_830AE28);
  *(_DWORD *)(v5 + 4) = v4;
  while ( dword_830AE28 != v5 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
  }
  result = v6;
  dword_830AE20 = v6;
  return result;
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080ADB6C) --------------------------------------------------------
int __cdecl sub_80ADB6C(int a1, int a2, unsigned __int16 a3, int a4)
{
  int result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]
  unsigned __int16 v7; // [esp+14h] [ebp-4h]
  int v8; // [esp+2Ch] [ebp+14h]

  while ( dword_830AE24 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
    --dword_830AE24;
  }
  v6 = dword_830AE28 - 8 * a4;
  v8 = dword_830AE20 - a4;
  v7 = sub_80A7074(a1, a2);
  if ( v7 )
  {
    v5 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v6 + 4) = 6;
    dword_830AE20 = 0;
    sub_80AD504(v7, a3, (int *)dword_830AE28);
    *(_DWORD *)(v6 + 4) = v5;
  }
  while ( dword_830AE28 != v6 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
  }
  result = v8;
  dword_830AE20 = v8;
  return result;
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080ADC4E) --------------------------------------------------------
int __cdecl sub_80ADC4E(unsigned __int16 a1)
{
  int result; // eax
  unsigned __int16 v2; // [esp+Eh] [ebp-Ah]
  unsigned __int16 v3; // [esp+10h] [ebp-8h]
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  while ( 1 )
  {
    result = sub_80A5E90(a1, 0x20000);
    if ( !(_WORD)result )
      break;
    v3 = sub_80A6B8A(result);
    result = FindNextSibling(v3);
    if ( !(_WORD)result )
      break;
    v4 = sub_80A6B8A(result);
    result = FindNextSibling(v4);
    if ( !(_WORD)result )
      break;
    v2 = sub_80A4AD0(result);
    sub_80A5BCE(v2);
    sub_80AD206(v2);
  }
  return result;
}

//----- (080ADCFE) --------------------------------------------------------
int __cdecl sub_80ADCFE(unsigned __int16 a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]
  unsigned __int16 v3; // [esp+14h] [ebp-4h]

  sub_80A5BCE(a1);
  while ( 1 )
  {
    v3 = FindNextSibling(a1);
    if ( !v3 )
      break;
    v2 = sub_80A4AD0(v3);
    sub_80A5BCE(v2);
    sub_80A62D2(a1, v2);
    sub_80AD206(v2);
  }
  return sub_80A5C0A(a1);
}

//----- (080ADD7C) --------------------------------------------------------
int __cdecl sub_80ADD7C(unsigned __int16 a1)
{
  unsigned __int16 v1; // ax
  unsigned __int16 v2; // ax
  unsigned __int16 v3; // ax
  int v5; // [esp+18h] [ebp-20h]
  unsigned __int8 *v6; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v7; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  unsigned __int16 v9; // [esp+26h] [ebp-12h]
  unsigned __int16 v10; // [esp+28h] [ebp-10h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  unsigned __int16 v12; // [esp+2Ah] [ebp-Eh]
  _DWORD *v13; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 *v14; // [esp+30h] [ebp-8h]
  unsigned __int16 *v15; // [esp+30h] [ebp-8h]

  dword_830AE38 = sub_80AF82C();
  sub_80A5BCE(a1);
  while ( 1 )
  {
    v9 = FindNextSibling(a1);
    if ( !v9 )
      break;
    v10 = sub_80A4AD0(v9);
    sub_80A62D2(a1, v10);
    v1 = sub_80A5E90(v10, 131073);
    v8 = *GetVariableValueAddress(v1);
    sub_80A6248(v10, 131073);
    v5 = *(unsigned __int16 *)(v8 + 8);
    v13 = *(_DWORD **)(v8 + 4);
    v11 = *(_WORD *)(v8 + 10);
    v6 = (unsigned __int8 *)(v8 + 12);
    v14 = word_8306CC0;
    while ( v5 )
    {
      v14 += 4;
      --v5;
      *((_DWORD *)v14 + 1) = *v6;
      v7 = v6 + 1;
      *(_DWORD *)v14 = *v7;
      v6 = (unsigned __int8 *)(v7 + 1);
      if ( *((_DWORD *)v14 + 1) == 6 )
        dword_830ACE0[dword_830ACC4++] = *(_DWORD *)v14;
    }
    dword_830ACE0[dword_830ACC4++] = (int)v13;
    sub_80A1F96(v8, 5 * *(unsigned __int16 *)(v8 + 8) + 12);
    v2 = sub_80A5B3C(v11);
    if ( sub_80A6BBA(v2) )
    {
      v3 = sub_80AA520(v14, v13, v11, v10, word_8306CC0);
      sub_80A5C0A(v3);
      sub_80A9754(dword_8306CC8);
    }
    else
    {
      sub_80A55C2(v11);
      sub_80A5C0A(v11);
      while ( 1 )
      {
        while ( *((_DWORD *)v14 + 1) != 6 )
        {
          sub_80A9754((int *)v14);
          v14 -= 4;
        }
        --dword_830ACC4;
        if ( v14 == word_8306CC0 )
          break;
        v15 = v14 - 4;
        v12 = *v15;
        v14 = v15 - 4;
        sub_80A55C2(v12);
        sub_80A5C0A(v12);
      }
    }
  }
  sub_80A5C0A(a1);
  return sub_80A667C(word_80EE90E);
}
// 80EE90E: using guessed type __int16 word_80EE90E;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE38: using guessed type int dword_830AE38;

//----- (080ADFBA) --------------------------------------------------------
int sub_80ADFBA()
{
  int result; // eax

  while ( dword_830AE24 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
    --dword_830AE24;
  }
  dword_830AE28 += 8;
  ++dword_830AE20;
  result = dword_830AE28;
  if ( dword_830AE28 > (unsigned int)dword_830ACC0 )
    Com_Error(1, (char *)&byte_80E2800);
  return result;
}
// 830ACC0: using guessed type int dword_830ACC0;
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AE018) --------------------------------------------------------
int __cdecl sub_80AE018(__int16 a1, _DWORD *a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  unsigned __int16 v7; // [esp+24h] [ebp-4h]
  unsigned __int16 v8; // [esp+24h] [ebp-4h]
  int v9; // [esp+38h] [ebp+10h]

  while ( dword_830AE24 )
  {
    sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
    --dword_830AE24;
  }
  v6 = dword_830AE28 - 8 * a3;
  v9 = dword_830AE20 - a3;
  sub_80A5BCE(a1);
  v7 = sub_80A5AF4(a1);
  if ( dword_830ACC4 > 31 )
  {
    sub_80A55C2(v7);
    dword_830AE20 = v9 + 1;
    while ( v9 )
    {
      sub_80A9754((int *)dword_830AE28);
      dword_830AE28 -= 8;
      --v9;
    }
    dword_830AE28 += 8;
    *(_DWORD *)(dword_830AE28 + 4) = 0;
    sub_80A2F52((unsigned int)a2, 0, "script stack overflow (too many embedded function calls)", 0);
    v4 = v7;
  }
  else
  {
    dword_830ACE0[dword_830ACC4++] = (int)a2;
    v5 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(v6 + 4) = 6;
    dword_830AE20 = 0;
    v8 = sub_80AA520((unsigned __int16 *)dword_830AE28, a2, v7, v7, (unsigned __int16 *)v6);
    *(_DWORD *)(v6 + 4) = v5;
    dword_830AE28 = v6 + 8;
    dword_830AE20 = v9 + 1;
    sub_80A667C(word_80EE90E);
    v4 = v8;
  }
  return v4;
}
// 80EE90E: using guessed type __int16 word_80EE90E;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE20: using guessed type int dword_830AE20;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AE1A8) --------------------------------------------------------
int __cdecl sub_80AE1A8(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  if ( !dword_830ACC4 )
    dword_830AE38 = sub_80AF82C();
  sub_80A0F58(dword_80EE864 + a1);
  v3 = sub_80AE018(word_830AE32, (_DWORD *)(dword_80EE864 + a1), a2);
  sub_80A9754((int *)dword_830AE28);
  *(_DWORD *)(dword_830AE28 + 4) = 0;
  dword_830AE28 -= 8;
  --dword_830AE20;
  return v3;
}
// 80EE864: using guessed type int dword_80EE864;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE38: using guessed type int dword_830AE38;

//----- (080AE226) --------------------------------------------------------
int __cdecl sub_80AE226(int a1, int a2, int a3, int a4)
{
  __int16 v4; // ax
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  if ( !dword_830ACC4 )
    dword_830AE38 = sub_80AF82C();
  sub_80A0F58(dword_80EE864 + a3);
  v4 = sub_80A70F0(a1, a2);
  v6 = sub_80AE018(v4, (_DWORD *)(dword_80EE864 + a3), a4);
  sub_80A9754((int *)dword_830AE28);
  *(_DWORD *)(dword_830AE28 + 4) = 0;
  dword_830AE28 -= 8;
  --dword_830AE20;
  return v6;
}
// 80EE864: using guessed type int dword_80EE864;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;
// 830AE38: using guessed type int dword_830AE38;

//----- (080AE2B2) --------------------------------------------------------
int __cdecl sub_80AE2B2(int a1, int a2)
{
  unsigned __int16 v2; // ax

  if ( !dword_830ACC4 )
    dword_830AE38 = sub_80AF82C();
  sub_80A0F58(dword_80EE864 + a1);
  v2 = sub_80AE018(word_830AE32, (_DWORD *)(dword_80EE864 + a1), a2);
  return sub_80A5C0A(v2);
}
// 80EE864: using guessed type int dword_80EE864;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE38: using guessed type int dword_830AE38;

//----- (080AE30C) --------------------------------------------------------
int __cdecl sub_80AE30C(int a1, int a2, int a3, int a4)
{
  __int16 v4; // ax
  unsigned __int16 v5; // ax

  if ( !dword_830ACC4 )
    dword_830AE38 = sub_80AF82C();
  sub_80A0F58(dword_80EE864 + a3);
  v4 = sub_80A70F0(a1, a2);
  v5 = sub_80AE018(v4, (_DWORD *)(dword_80EE864 + a3), a4);
  return sub_80A5C0A(v5);
}
// 80EE864: using guessed type int dword_80EE864;
// 830ACC4: using guessed type int dword_830ACC4;
// 830AE38: using guessed type int dword_830AE38;

//----- (080AE374) --------------------------------------------------------
int __cdecl sub_80AE374(unsigned __int16 a1)
{
  return sub_80A5C0A(a1);
}

//----- (080AE390) --------------------------------------------------------
void sub_80AE390()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // [esp+16h] [ebp-2h]

  if ( word_80EE90C )
  {
    v1 = sub_80A5E90(word_80EE90C, dword_830AE2C);
    if ( v1 )
    {
      v0 = sub_80A6B8A(v1);
      sub_80ADD7C(v0);
      sub_80A635A(word_80EE90C, dword_830AE2C);
    }
  }
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 830AE2C: using guessed type int dword_830AE2C;

//----- (080AE3F8) --------------------------------------------------------
int __cdecl sub_80AE3F8(int a1, int a2)
{
  int result; // eax

  word_80EE90C = sub_80A5A30();
  word_830AE30 = sub_80A5AB4();
  word_830AE32 = sub_80A5A30();
  word_830AE36 = sub_80A5A30();
  result = a2 & 0xFFFFFF;
  dword_830AE2C = a2 & 0xFFFFFF;
  return result;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 830AE2C: using guessed type int dword_830AE2C;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080AE43A) --------------------------------------------------------
int sub_80AE43A()
{
  unsigned __int16 v0; // ax
  unsigned __int16 v1; // ax
  int result; // eax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  unsigned __int16 i; // [esp+14h] [ebp-4h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]
  unsigned __int16 v6; // [esp+14h] [ebp-4h]

  for ( i = FindNextSibling(word_80EE90C); i; i = FindNextSibling(i) )
  {
    v0 = sub_80A6B8A(i);
    sub_80ADCFE(v0);
  }
  while ( 1 )
  {
    v5 = FindNextSibling(word_830AE30);
    if ( !v5 )
      break;
    v1 = sub_80A6B8A(v5);
    v6 = FindNextSibling(v1);
    v3 = *(_WORD *)GetVariableValueAddress(v6);
    sub_80A5BCE(v3);
    sub_80ADC4E(v3);
    sub_80A5C0A(v3);
  }
  sub_80A54B8(word_830AE32);
  sub_80A5C0A(word_830AE32);
  word_830AE32 = 0;
  sub_80A54B8(word_830AE36);
  sub_80A5C0A(word_830AE36);
  word_830AE36 = 0;
  sub_80A54B8(word_80EE90C);
  sub_80A5C0A(word_80EE90C);
  word_80EE90C = 0;
  result = sub_80A5C0A(word_830AE30);
  word_830AE30 = 0;
  return result;
}
// 80EE90C: using guessed type __int16 word_80EE90C;
// 830AE30: using guessed type __int16 word_830AE30;
// 830AE32: using guessed type __int16 word_830AE32;
// 830AE36: using guessed type __int16 word_830AE36;

//----- (080AE58A) --------------------------------------------------------
_BOOL4 sub_80AE58A()
{
  return word_80EE90C != 0;
}
// 80EE90C: using guessed type __int16 word_80EE90C;

//----- (080AE5A6) --------------------------------------------------------
int __cdecl Scr_GetPointerType(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_7;
  if ( *(_DWORD *)(dword_830AE28 - 8 * a1 + 4) != 5 )
  {
    if ( (unsigned __int8)sub_80A9956((float *)(dword_830AE28 - 8 * a1)) )
      return *(_DWORD *)(dword_830AE28 - 8 * a1);
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_7:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *(_DWORD *)(dword_830AE28 - 8 * a1) != 0;
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AE67C) --------------------------------------------------------
int __cdecl sub_80AE67C(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( !(unsigned __int8)sub_80A9A98(dword_830AE28 - 8 * a1) )
  {
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *(_DWORD *)(dword_830AE28 - 8 * a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AE718) --------------------------------------------------------
unsigned __int16 *__userpurge sub_80AE718@<eax>(unsigned __int16 *a1, unsigned int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  const char *v6; // eax
  char *v7; // eax
  const char *v9; // [esp+18h] [ebp-10h]
  const char *v10; // [esp+1Ch] [ebp-Ch]
  int v11; // [esp+20h] [ebp-8h]

  if ( a2 >= dword_830AE24 )
    goto LABEL_8;
  if ( *(_DWORD *)(dword_830AE28 - 8 * a2 + 4) != 11 )
  {
    dword_830AD60 = (int)va(
                           "cannot cast %s to anim",
                           *(const char **)&off_80EE8C0[4 * *(_DWORD *)(dword_830AE28 - 8 * a2 + 4)]);
    goto LABEL_7;
  }
  *(_DWORD *)a1 = *(_DWORD *)(dword_830AE28 - 8 * a2);
  if ( a3 )
  {
    v11 = sub_809B866(a1[1]);
    if ( v11 != sub_80C43B4(a3) )
    {
      v3 = sub_80C43B4(a3);
      v10 = (const char *)sub_80C9D4A(v3);
      v4 = sub_809B866(a1[1]);
      v9 = (const char *)sub_80C9D4A(v4);
      v5 = sub_809B866(a1[1]);
      v6 = sub_80C9D12(v5, *a1);
      dword_830AD60 = (int)va("anim '%s' in animtree '%s' does not belong to the entity's animtree '%s'", v6, v9, v10);
LABEL_7:
      sub_80A9754((int *)(dword_830AE28 - 8 * a2));
      *(_DWORD *)(dword_830AE28 - 8 * a2 + 4) = 0;
      dword_830AD68 = a2 + 1;
      sub_80A98AE();
LABEL_8:
      v7 = va("parameter %d does not exist", a2 + 1);
      Scr_Error((int)v7);
      *a1 = 0;
      a1[1] = 0;
      return a1;
    }
  }
  return a1;
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD60: using guessed type int dword_830AD60;
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AE8D2) --------------------------------------------------------
_DWORD *__userpurge sub_80AE8D2@<eax>(_DWORD *a1, unsigned int a2)
{
  char *v2; // eax
  unsigned int v4; // [esp+14h] [ebp-4h]

  if ( a2 >= dword_830AE24 )
    goto LABEL_9;
  if ( *(_DWORD *)(dword_830AE28 - 8 * a2 + 4) != 5 )
  {
    dword_830AD60 = (int)va(
                           "cannot cast %s to animtree",
                           *(const char **)&off_80EE8C0[4 * *(_DWORD *)(dword_830AE28 - 8 * a2 + 4)]);
    goto LABEL_8;
  }
  v4 = *(_DWORD *)(dword_830AE28 - 8 * a2);
  if ( v4 > dword_81766C0[dword_832D040] || !dword_81760C0[128 * dword_832D040 + v4] )
  {
    dword_830AD60 = (int)"bad anim tree";
LABEL_8:
    sub_80A9754((int *)(dword_830AE28 - 8 * a2));
    *(_DWORD *)(dword_830AE28 - 8 * a2 + 4) = 0;
    dword_830AD68 = a2 + 1;
    sub_80A98AE();
LABEL_9:
    v2 = va("parameter %d does not exist", a2 + 1);
    Scr_Error((int)v2);
    *a1 = dword_81760C0[128 * dword_832D040];
    return a1;
  }
  *a1 = dword_81760C0[128 * dword_832D040 + v4];
  return a1;
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 81766C0: using guessed type int dword_81766C0[];
// 830AD60: using guessed type int dword_830AD60;
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;
// 832D040: using guessed type int dword_832D040;

//----- (080AEA28) --------------------------------------------------------
long double __cdecl sub_80AEA28(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( !(unsigned __int8)CastFloat((unsigned __int16 *)(dword_830AE28 - 8 * a1)) )
  {
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return (float)0.0;
  }
  return *(float *)(dword_830AE28 - 8 * a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AEAC2) --------------------------------------------------------
int __cdecl sub_80AEAC2(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( !(unsigned __int8)sub_80A9D32((int *)(dword_830AE28 - 8 * a1)) )
  {
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *(unsigned __int16 *)(dword_830AE28 - 8 * a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AEB60) --------------------------------------------------------
int __cdecl sub_80AEB60(unsigned int a1)
{
  unsigned __int16 v1; // ax

  v1 = sub_80AEAC2(a1);
  return SL_ConvertToString(v1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);

//----- (080AEBA4) --------------------------------------------------------
const char *__cdecl sub_80AEBA4(unsigned int a1)
{
  int v1; // eax
  char *v2; // eax
  int v4; // [esp+20h] [ebp-18h]
  int v6; // [esp+2Ch] [ebp-Ch]
  int v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  if ( a1 >= dword_830AE24 )
  {
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  v7 = *(_DWORD *)(dword_830AE28 - 8 * a1 + 4);
  if ( v7 == 7 )
    v4 = sub_80A6D12(*(_WORD *)(dword_830AE28 - 8 * a1));
  else
    v4 = *(_DWORD *)(dword_830AE28 - 8 * a1 + 4);
  v8 = *(_DWORD *)&off_80EE8C0[4 * v4];
  if ( !(unsigned __int8)sub_80A9D32((int *)(dword_830AE28 - 8 * a1)) )
  {
    dword_830AD60 = 0;
    dword_830AD64 = 0;
    dword_830AD68 = 0;
    if ( v7 == 11 )
    {
      v6 = *(_DWORD *)(dword_830AE28 - 8 * a1);
      v1 = sub_809B866(HIWORD(v6));
      return sub_80C9D12(v1, (unsigned __int16)v6);
    }
    if ( v7 != 2 )
      return (const char *)v8;
  }
  return (const char *)SL_ConvertToString(*(_WORD *)(dword_830AE28 - 8 * a1));
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD60: using guessed type int dword_830AD60;
// 830AD64: using guessed type int dword_830AD64;
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AED26) --------------------------------------------------------
int __cdecl sub_80AED26(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( !(unsigned __int8)sub_80A9E36((int *)(dword_830AE28 - 8 * a1)) )
  {
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *(unsigned __int16 *)(dword_830AE28 - 8 * a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AEDC4) --------------------------------------------------------
int __cdecl sub_80AEDC4(unsigned int a1)
{
  unsigned __int16 v1; // ax

  v1 = sub_80AED26(a1);
  return SL_ConvertToString(v1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);

//----- (080AEE08) --------------------------------------------------------
int __cdecl sub_80AEE08(unsigned int a1, _DWORD *a2)
{
  int result; // eax
  char *v3; // eax

  if ( a1 < dword_830AE24 )
  {
    if ( (unsigned __int8)sub_80A9E92((int *)(dword_830AE28 - 8 * a1)) )
    {
      *a2 = **(_DWORD **)(dword_830AE28 - 8 * a1);
      a2[1] = *(_DWORD *)(*(_DWORD *)(dword_830AE28 - 8 * a1) + 4);
      result = *(_DWORD *)(*(_DWORD *)(dword_830AE28 - 8 * a1) + 8);
      a2[2] = result;
      return result;
    }
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
  }
  v3 = va("parameter %d does not exist", a1 + 1);
  return Scr_Error((int)v3);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AEEE2) --------------------------------------------------------
int __cdecl sub_80AEEE2(unsigned int a1)
{
  char *v1; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( *(_DWORD *)(dword_830AE28 - 8 * a1 + 4) != 9 )
  {
    dword_830AD60 = (int)"not a function";
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_5:
    v1 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v1);
    return 0;
  }
  return *(_DWORD *)(dword_830AE28 - 8 * a1) - dword_80EE864;
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 80EE864: using guessed type int dword_80EE864;
// 830AD60: using guessed type int dword_830AD60;
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AEF8A) --------------------------------------------------------
int __cdecl sub_80AEF8A(unsigned int a1, unsigned int *a2)
{
  int v2; // eax
  char *v3; // eax
  unsigned __int16 v6; // [esp+26h] [ebp-2h]

  if ( a1 >= dword_830AE24 )
    goto LABEL_7;
  if ( !(unsigned __int8)sub_80A9EEE((int *)(dword_830AE28 - 8 * a1)) )
  {
LABEL_6:
    dword_830AD68 = a1 + 1;
    sub_80A98AE();
LABEL_7:
    v3 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v3);
    return 0;
  }
  v6 = *(_WORD *)(dword_830AE28 - 8 * a1);
  if ( sub_80A6D12(v6) != 13 )
  {
    v2 = sub_80A6D12(v6);
    dword_830AD60 = (int)va("cannot cast %s to entity", *(const char **)&off_80EE8C0[4 * v2]);
    goto LABEL_6;
  }
  *a2 = sub_80A4AF8(v6);
  return sub_80A7C38(v6);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD60: using guessed type int dword_830AD60;
// 830AD68: using guessed type int dword_830AD68;
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF086) --------------------------------------------------------
int __cdecl sub_80AF086(unsigned int a1)
{
  char *v1; // eax

  if ( a1 < dword_830AE24 )
    return *(_DWORD *)(dword_830AE28 - 8 * a1 + 4);
  v1 = va("parameter %d does not exist", a1 + 1);
  Scr_Error((int)v1);
  return 0;
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF0F8) --------------------------------------------------------
int __cdecl sub_80AF0F8(unsigned int a1)
{
  char *v1; // eax
  char *v2; // eax

  if ( a1 >= dword_830AE24 )
    goto LABEL_5;
  if ( *(_DWORD *)(dword_830AE28 - 8 * a1 + 4) != 7 )
  {
    v1 = va("parameter %d is not a pointer", a1 + 1);
    Scr_Error((int)v1);
LABEL_5:
    v2 = va("parameter %d does not exist", a1 + 1);
    Scr_Error((int)v2);
    return 0;
  }
  return sub_80A6D12(*(_WORD *)(dword_830AE28 - 8 * a1));
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF1AE) --------------------------------------------------------
int sub_80AF1AE()
{
  return dword_830AE24;
}
// 830AE24: using guessed type int dword_830AE24;

//----- (080AF1B8) --------------------------------------------------------
int __cdecl sub_80AF1B8(int a1)
{
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 5;
  result = a1;
  *(_DWORD *)dword_830AE28 = a1;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF1DC) --------------------------------------------------------
int __cdecl sub_80AF1DC(int a1)
{
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 5;
  result = a1;
  *(_DWORD *)dword_830AE28 = a1;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF200) --------------------------------------------------------
int __cdecl sub_80AF200(int a1)
{
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 4;
  result = a1;
  *(_DWORD *)dword_830AE28 = a1;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF224) --------------------------------------------------------
int __cdecl sub_80AF224(int a1)
{
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 11;
  result = a1;
  *(_DWORD *)dword_830AE28 = a1;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF248) --------------------------------------------------------
int sub_80AF248()
{
  int result; // eax

  sub_80ADFBA();
  result = dword_830AE28;
  *(_DWORD *)(dword_830AE28 + 4) = 0;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF262) --------------------------------------------------------
int __cdecl sub_80AF262(unsigned __int16 a1)
{
  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 7;
  *(_WORD *)dword_830AE28 = a1;
  return sub_80A5BCE(a1);
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF29C) --------------------------------------------------------
int __cdecl sub_80AF29C(int a1, int a2)
{
  unsigned __int16 v2; // ax

  v2 = sub_80A70F0(a1, a2);
  return sub_80AF262(v2);
}

//----- (080AF2C2) --------------------------------------------------------
int sub_80AF2C2()
{
  unsigned __int16 v1; // [esp+6h] [ebp-2h]

  v1 = sub_80A5A30();
  sub_80AF262(v1);
  return sub_80A5C0A(v1);
}

//----- (080AF2EC) --------------------------------------------------------
int __cdecl sub_80AF2EC(char *s)
{
  _WORD *v1; // ebx
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 1;
  v1 = (_WORD *)dword_830AE28;
  result = sub_80A3DA2(s, 0);
  *v1 = result;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF326) --------------------------------------------------------
int __cdecl sub_80AF326(char *s)
{
  _WORD *v1; // ebx
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 2;
  v1 = (_WORD *)dword_830AE28;
  result = sub_80A3DA2(s, 0);
  *v1 = result;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF360) --------------------------------------------------------
int __cdecl sub_80AF360(unsigned __int16 a1)
{
  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 1;
  *(_WORD *)dword_830AE28 = a1;
  return sub_80A3F08(a1);
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF39A) --------------------------------------------------------
_DWORD *__cdecl sub_80AF39A(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 3;
  v1 = (_DWORD *)dword_830AE28;
  result = sub_80A5C94(a1);
  *v1 = result;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF3CC) --------------------------------------------------------
int sub_80AF3CC()
{
  _WORD *v0; // ebx
  int result; // eax

  sub_80ADFBA();
  *(_DWORD *)(dword_830AE28 + 4) = 7;
  v0 = (_WORD *)dword_830AE28;
  result = sub_80A5AB4();
  *v0 = result;
  return result;
}
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF3F8) --------------------------------------------------------
int sub_80AF3F8()
{
  int v0; // eax
  unsigned __int16 v2; // [esp+16h] [ebp-2h]

  dword_830AE28 -= 8;
  --dword_830AE20;
  v0 = sub_80A6A06(*(_WORD *)dword_830AE28);
  v2 = sub_80A61B2(*(_WORD *)dword_830AE28, v0);
  return sub_80A6608(v2, (int *)(dword_830AE28 + 8));
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF44E) --------------------------------------------------------
int __cdecl sub_80AF44E(unsigned __int16 a1)
{
  unsigned __int16 v2; // [esp+14h] [ebp-4h]

  dword_830AE28 -= 8;
  --dword_830AE20;
  v2 = sub_80A61E0(*(_WORD *)dword_830AE28, a1);
  return sub_80A6608(v2, (int *)(dword_830AE28 + 8));
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF49E) --------------------------------------------------------
int __cdecl Scr_Error(int a1)
{
  dword_830AD60 = a1;
  return sub_80A98AE();
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD60: using guessed type int dword_830AD60;

//----- (080AF4D4) --------------------------------------------------------
int __cdecl sub_80AF4D4(int a1, int a2)
{
  dword_830AD60 = a1;
  dword_830AD64 = a2;
  return sub_80A98AE();
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD60: using guessed type int dword_830AD60;
// 830AD64: using guessed type int dword_830AD64;

//----- (080AF512) --------------------------------------------------------
int __cdecl sub_80AF512(int a1)
{
  Scr_DumpScriptThreads();
  sub_80A49CA();
  byte_830AD6C = 1;
  return Scr_Error(a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD6C: using guessed type char byte_830AD6C;

//----- (080AF556) --------------------------------------------------------
int __cdecl sub_80AF556(int a1, int a2)
{
  dword_830AD68 = a1 + 1;
  return Scr_Error(a2);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;

//----- (080AF592) --------------------------------------------------------
int __cdecl sub_80AF592(int a1)
{
  dword_830AD68 = -1;
  return Scr_Error(a1);
}
// 8049DBC: using guessed type int __cdecl _Unwind_Resume(_DWORD);
// 830AD68: using guessed type int dword_830AD68;

//----- (080AF5D0) --------------------------------------------------------
int __cdecl sub_80AF5D0(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_830AE24 = 1;
  dword_830AE28 = a4;
  result = sub_80A0AEC(a1, a2, a3);
  while ( dword_830AE24 )
  {
    result = sub_80A9754((int *)dword_830AE28);
    dword_830AE28 -= 8;
    --dword_830AE24;
  }
  return result;
}
// 830AE24: using guessed type int dword_830AE24;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF62A) --------------------------------------------------------
int __cdecl sub_80AF62A(int a1, int a2, int a3, int a4)
{
  int result; // eax

  dword_830AE28 = a4 - 8;
  *(_DWORD *)(a4 + 4) = 0;
  result = sub_80A0B0F(a1, a2, a3);
  dword_830AE20 = 0;
  return result;
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF66A) --------------------------------------------------------
int __cdecl sub_80AF66A(int a1, int a2, unsigned __int16 a3)
{
  int result; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  unsigned __int16 v5; // [esp+14h] [ebp-4h]

  v5 = sub_80A70F0(a1, a2);
  v4 = sub_80A5F28(v5, a3);
  result = sub_80A66D0(v4, (int *)dword_830AE28);
  dword_830AE28 -= 8;
  dword_830AE20 = 0;
  return result;
}
// 830AE20: using guessed type int dword_830AE20;
// 830AE28: using guessed type int dword_830AE28;

//----- (080AF6CE) --------------------------------------------------------
int __cdecl sub_80AF6CE(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp+8h]

  v2 = a1 & 0xFFFFFF;
  if ( v2 - dword_830AE2C <= 0 )
  {
    result = v2;
    dword_830AE2C = v2;
  }
  else
  {
    do
    {
      sub_80AE390();
      ++dword_830AE2C;
      dword_830AE2C &= 0xFFFFFFu;
      result = dword_830AE2C;
    }
    while ( dword_830AE2C != v2 );
  }
  return result;
}
// 830AE2C: using guessed type int dword_830AE2C;

//----- (080AF716) --------------------------------------------------------
void sub_80AF716()
{
  sub_80AE390();
}

//----- (080AF724) --------------------------------------------------------
unsigned __int64 sub_80AF724()
{
  unsigned __int64 result; // rax

  result = sub_80AF82C();
  dword_830AE38 = result;
  return result;
}
// 830AE38: using guessed type int dword_830AE38;

//----- (080AF736) --------------------------------------------------------
int __cdecl sub_80AF736(unsigned __int16 *a1)
{
  size_t v1; // eax
  void *v2; // esp
  char v4[4]; // [esp+10h] [ebp-18h] BYREF
  char *src; // [esp+14h] [ebp-14h]
  char *s; // [esp+18h] [ebp-10h]
  size_t v7; // [esp+1Ch] [ebp-Ch]
  size_t n; // [esp+20h] [ebp-8h]
  char *dest; // [esp+24h] [ebp-4h]

  s = (char *)SL_ConvertToString(*a1);
  src = (char *)SL_ConvertToString(a1[4]);
  v7 = strlen(s);
  v1 = strlen(src);
  n = v7 + v1 + 1;
  v2 = alloca(16 * ((v7 + v1 + 16) >> 4));
  dest = v4;
  strcpy(v4, s);
  strcpy(&dest[v7], src);
  return (unsigned __int16)sub_80A388C(dest, 0, n);
}

//----- (080AF7E4) --------------------------------------------------------
int __cdecl sub_80AF7E4(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (080AF812) --------------------------------------------------------
long double __cdecl sub_80AF812(float a1)
{
  return (float)fabs(a1);
}

//----- (080AF82C) --------------------------------------------------------
unsigned __int64 sub_80AF82C()
{
  return __rdtsc();
}

//----- (080AF848) --------------------------------------------------------
int __cdecl sub_80AF848(int a1)
{
  return (unsigned __int8)sub_80AA068(a1, a1 + 8);
}

//----- (080AF868) --------------------------------------------------------
int __cdecl sub_80AF868(int a1, int a2)
{
  int result; // eax

  result = sub_80A3DCE(a1, 0, a2 + 1, 13);
  LOWORD(dword_83E246C) = result;
  return result;
}
// 83E246C: using guessed type int dword_83E246C;

//----- (080AF899) --------------------------------------------------------
int __cdecl sub_80AF899(_BYTE *a1, int a2)
{
  void *v2; // esp
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch] BYREF
  char *s; // [esp+10h] [ebp-8h]
  int *v6; // [esp+14h] [ebp-4h]
  _BYTE *v7; // [esp+20h] [ebp+8h]
  int v8; // [esp+24h] [ebp+Ch]

  v2 = alloca(16 * ((unsigned int)(a2 + 16) >> 4));
  s = (char *)&v4;
  v6 = &v4;
  while ( a2 )
  {
    if ( *a1 == 92 )
    {
      v8 = a2 - 1;
      if ( !v8 )
        break;
      v7 = a1 + 1;
      v4 = (char)*v7;
      if ( v4 == 114 )
      {
        *(_BYTE *)v6 = 13;
        v6 = (int *)((char *)v6 + 1);
        goto LABEL_16;
      }
      if ( v4 > 114 )
      {
        if ( v4 == 116 )
        {
          *(_BYTE *)v6 = 9;
          v6 = (int *)((char *)v6 + 1);
          goto LABEL_16;
        }
      }
      else if ( v4 == 110 )
      {
        *(_BYTE *)v6 = 10;
        v6 = (int *)((char *)v6 + 1);
        goto LABEL_16;
      }
      *(_BYTE *)v6 = *v7;
      v6 = (int *)((char *)v6 + 1);
LABEL_16:
      a2 = v8 - 1;
      a1 = v7 + 1;
    }
    else
    {
      --a2;
      *(_BYTE *)v6 = *a1++;
      v6 = (int *)((char *)v6 + 1);
    }
  }
  *(_BYTE *)v6 = 0;
  result = sub_80A3D64(s, 0);
  LOWORD(dword_83E246C) = result;
  return result;
}
// 83E246C: using guessed type int dword_83E246C;

//----- (080AF98E) --------------------------------------------------------
int __cdecl sub_80AF98E(char *s)
{
  return sscanf(s, "%d", &dword_83E246C);
}
// 83E246C: using guessed type int dword_83E246C;

//----- (080AF9B1) --------------------------------------------------------
int __cdecl sub_80AF9B1(char *s)
{
  return sscanf(s, "%f", &dword_83E246C);
}
// 83E246C: using guessed type int dword_83E246C;

//----- (080AF9D4) --------------------------------------------------------
int sub_80AF9D4()
{
  int v1; // [esp+14h] [ebp-24h]
  unsigned __int8 v2; // [esp+1Bh] [ebp-1Dh]
  int v3; // [esp+1Ch] [ebp-1Ch]
  char *v4; // [esp+20h] [ebp-18h]
  char *v5; // [esp+24h] [ebp-14h]
  int v6; // [esp+28h] [ebp-10h]
  int v8; // [esp+30h] [ebp-8h]
  int v9; // [esp+34h] [ebp-4h]

  if ( dword_80F09CC )
  {
    dword_80F09CC = 0;
    if ( !dword_80F09D0 )
      dword_80F09D0 = 1;
    if ( !dword_80F09D4 )
      dword_80F09D4 = (FILE *)stdin;
    if ( !dword_80F09D8 )
      dword_80F09D8 = stdout;
    if ( !dword_80F09C4 )
      dword_80F09C4 = (int)sub_80B140F(dword_80F09D4, 0x4000);
    sub_80B13D2();
  }
LABEL_11:
  v5 = (char *)dword_80F09C8;
  *(_BYTE *)dword_80F09C8 = byte_830AE50;
  v4 = v5;
  v6 = dword_80F09D0;
  do
  {
LABEL_12:
    v2 = byte_80E2B40[4 * (unsigned __int8)*v5];
    if ( word_80E2940[v6] )
    {
      dword_830AE5C = v6;
      dword_830AE60 = (int)v5;
    }
    while ( word_80E37E0[v2 + word_80E3040[v6]] != v6 )
    {
      v6 = word_80E3240[v6];
      if ( v6 > 244 )
        v2 = byte_80E2F40[4 * v2];
    }
    v6 = word_80E3440[v2 + word_80E3040[v6]];
    ++v5;
  }
  while ( word_80E3040[v6] != 395 );
  while ( 1 )
  {
    v3 = word_80E2940[v6];
    if ( !word_80E2940[v6] )
    {
      v5 = (char *)dword_830AE60;
      v3 = word_80E2940[dword_830AE5C];
    }
    dword_83E2064 = v4;
    size = v5 - v4;
    byte_830AE50 = *v5;
    *v5 = 0;
    dword_80F09C8 = (int)v5;
LABEL_21:
    switch ( v3 )
    {
      case 0:
        *v5 = byte_830AE50;
        v5 = (char *)dword_830AE60;
        v6 = dword_830AE5C;
        continue;
      case 1:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        goto LABEL_11;
      case 2:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        dword_80F09D0 = 3;
        goto LABEL_11;
      case 3:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        goto LABEL_11;
      case 4:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        goto LABEL_11;
      case 5:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        goto LABEL_11;
      case 6:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        dword_80F09D0 = 5;
        goto LABEL_11;
      case 7:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF899(dword_83E2064 + 1, size - 2);
        return 259;
      case 8:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF899(dword_83E2064 + 2, size - 3);
        return 260;
      case 9:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 261;
      case 10:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 262;
      case 11:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 263;
      case 12:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 264;
      case 13:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 265;
      case 14:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 266;
      case 15:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 267;
      case 16:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 268;
      case 17:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 269;
      case 18:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 270;
      case 19:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 271;
      case 20:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 272;
      case 21:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 273;
      case 22:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 274;
      case 23:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 275;
      case 24:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 276;
      case 25:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 277;
      case 26:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 278;
      case 27:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 279;
      case 28:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 280;
      case 29:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 281;
      case 30:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 282;
      case 31:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 283;
      case 32:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 284;
      case 33:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 285;
      case 34:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 286;
      case 35:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF98E(dword_83E2064);
        return 287;
      case 36:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF9B1(dword_83E2064);
        return 288;
      case 37:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 290;
      case 38:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 289;
      case 39:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 295;
      case 40:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 291;
      case 41:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 294;
      case 42:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 292;
      case 43:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 293;
      case 44:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 296;
      case 45:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 297;
      case 46:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 298;
      case 47:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 299;
      case 48:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 300;
      case 49:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 301;
      case 50:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 302;
      case 51:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 303;
      case 52:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 304;
      case 53:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 305;
      case 54:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 306;
      case 55:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 307;
      case 56:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 308;
      case 57:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 309;
      case 58:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 310;
      case 59:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 311;
      case 60:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 312;
      case 61:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 313;
      case 62:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 314;
      case 63:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 315;
      case 64:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 316;
      case 65:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 317;
      case 66:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 318;
      case 67:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 319;
      case 68:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 320;
      case 69:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 321;
      case 70:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 322;
      case 71:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 323;
      case 72:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 324;
      case 73:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 325;
      case 74:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 326;
      case 75:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 327;
      case 76:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 329;
      case 77:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 330;
      case 78:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 331;
      case 79:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 332;
      case 80:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 333;
      case 81:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 334;
      case 82:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 335;
      case 83:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 336;
      case 84:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 337;
      case 85:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 338;
      case 86:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 339;
      case 87:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 340;
      case 88:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 341;
      case 89:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        return 342;
      case 90:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF868((int)dword_83E2064, size);
        return 258;
      case 91:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80AF868((int)dword_83E2064, size);
        return 328;
      case 92:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        sub_80A2D58(dword_830AE4C, "bad token '%s'", dword_83E2064);
      case 93:
        dword_83E2470 = dword_830AE44;
        dword_830AE4C = dword_830AE44;
        dword_830AE44 += size;
        fwrite(dword_83E2064, size, 1u, dword_80F09D8);
        goto LABEL_11;
      case 94:
        v9 = v5 - dword_83E2064 - 1;
        *v5 = byte_830AE50;
        if ( !*(_DWORD *)(dword_80F09C4 + 36) )
        {
          dword_830AE54 = *(_DWORD *)(dword_80F09C4 + 16);
          *(_DWORD *)dword_80F09C4 = dword_80F09D4;
          *(_DWORD *)(dword_80F09C4 + 36) = 1;
        }
        if ( dword_80F09C8 <= (unsigned int)(dword_830AE54 + *(_DWORD *)(dword_80F09C4 + 4)) )
        {
          dword_80F09C8 = (int)&dword_83E2064[v9];
          v6 = sub_80B109A();
          v8 = sub_80B1172(v6);
          v4 = dword_83E2064;
          if ( v8 )
          {
            v5 = (char *)++dword_80F09C8;
            v6 = v8;
            goto LABEL_12;
          }
          v5 = (char *)dword_80F09C8;
          continue;
        }
        v1 = sub_80B0DC4();
        if ( v1 == 1 )
        {
          dword_830AE58 = 0;
          if ( sub_80B1884() )
          {
            dword_80F09C8 = (int)dword_83E2064;
            v3 = (dword_80F09D0 - 1) / 2 + 95;
            goto LABEL_21;
          }
          if ( !dword_830AE58 )
            sub_80B132F(dword_80F09D4);
          goto LABEL_11;
        }
        if ( v1 <= 1 )
        {
          if ( v1 )
            goto LABEL_11;
          dword_80F09C8 = (int)&dword_83E2064[v9];
          v6 = sub_80B109A();
          v5 = (char *)dword_80F09C8;
          v4 = dword_83E2064;
          goto LABEL_12;
        }
        if ( v1 != 2 )
          goto LABEL_11;
        dword_80F09C8 = dword_830AE54 + *(_DWORD *)(dword_80F09C4 + 4);
        v6 = sub_80B109A();
        v5 = (char *)dword_80F09C8;
        v4 = dword_83E2064;
        break;
      case 95:
      case 96:
      case 97:
        return 0;
      default:
        sub_80B1742("fatal flex scanner internal error--no action found");
    }
  }
}
// 80F09C8: using guessed type int dword_80F09C8;
// 80F09CC: using guessed type int dword_80F09CC;
// 80F09D0: using guessed type int dword_80F09D0;
// 80F654C: using guessed type int stdin;
// 830AE44: using guessed type int dword_830AE44;
// 830AE50: using guessed type char byte_830AE50;
// 830AE54: using guessed type int dword_830AE54;
// 830AE58: using guessed type int dword_830AE58;
// 830AE5C: using guessed type int dword_830AE5C;
// 830AE60: using guessed type int dword_830AE60;
// 83E2470: using guessed type int dword_83E2470;

//----- (080B0DC4) --------------------------------------------------------
int sub_80B0DC4()
{
  int v0; // eax
  int i; // [esp+8h] [ebp-30h]
  int v3; // [esp+Ch] [ebp-2Ch]
  char *v4; // [esp+10h] [ebp-28h]
  _BYTE *v5; // [esp+14h] [ebp-24h]
  int v6; // [esp+18h] [ebp-20h]
  char v7; // [esp+1Fh] [ebp-19h]
  int k; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h]

  v5 = *(_BYTE **)(dword_80F09C4 + 4);
  v4 = dword_83E2064;
  if ( dword_80F09C8 > (unsigned int)&v5[dword_830AE54 + 1] )
    sub_80B1742("fatal flex scanner internal error--end of buffer missed");
  if ( *(_DWORD *)(dword_80F09C4 + 32) )
  {
    v3 = dword_80F09C8 - (_DWORD)dword_83E2064 - 1;
    for ( i = 0; i < v3; ++i )
      *v5++ = *v4++;
    if ( *(_DWORD *)(dword_80F09C4 + 36) == 2 )
    {
      dword_830AE54 = 0;
      *(_DWORD *)(dword_80F09C4 + 16) = 0;
    }
    else
    {
      for ( j = *(_DWORD *)(dword_80F09C4 + 12) - v3 - 1; j <= 0; j = *(_DWORD *)(dword_80F09C4 + 12) - v3 - 1 )
      {
        v10 = dword_80F09C4;
        v9 = dword_80F09C8 - *(_DWORD *)(dword_80F09C4 + 4);
        if ( *(_DWORD *)(dword_80F09C4 + 20) )
        {
          if ( 2 * *(_DWORD *)(dword_80F09C4 + 12) > 0 )
            v0 = 2 * *(_DWORD *)(dword_80F09C4 + 12);
          else
            v0 = *(_DWORD *)(dword_80F09C4 + 12) + (*(_DWORD *)(dword_80F09C4 + 12) >> 3);
          *(_DWORD *)(dword_80F09C4 + 12) = v0;
          *(_DWORD *)(v10 + 4) = sub_80B1783(*(void **)(v10 + 4), *(_DWORD *)(v10 + 12) + 2);
        }
        else
        {
          *(_DWORD *)(dword_80F09C4 + 4) = 0;
        }
        if ( !*(_DWORD *)(v10 + 4) )
          sub_80B1742("fatal error - scanner input buffer overflow");
        dword_80F09C8 = *(_DWORD *)(v10 + 4) + v9;
      }
      if ( j > 0x2000 )
        j = 0x2000;
      v7 = 42;
      for ( k = 0; k < j; ++k )
      {
        v7 = *(_BYTE *)dword_830AE48++;
        if ( !v7 || v7 == 10 )
          break;
        *(_BYTE *)(k + *(_DWORD *)(dword_80F09C4 + 4) + v3) = v7;
      }
      if ( v7 == 10 )
      {
        *(_BYTE *)(k + *(_DWORD *)(dword_80F09C4 + 4) + v3) = 10;
        ++k;
      }
      else if ( !v7 )
      {
        --dword_830AE48;
      }
      dword_830AE54 = k;
      *(_DWORD *)(dword_80F09C4 + 16) = k;
    }
    if ( dword_830AE54 )
    {
      v12 = 0;
    }
    else if ( v3 )
    {
      v12 = 2;
      *(_DWORD *)(dword_80F09C4 + 36) = 2;
    }
    else
    {
      v12 = 1;
      sub_80B132F(dword_80F09D4);
    }
    dword_830AE54 += v3;
    *(_BYTE *)(*(_DWORD *)(dword_80F09C4 + 4) + dword_830AE54) = 0;
    *(_BYTE *)(*(_DWORD *)(dword_80F09C4 + 4) + dword_830AE54 + 1) = 0;
    dword_83E2064 = *(char **)(dword_80F09C4 + 4);
    v6 = v12;
  }
  else if ( dword_80F09C8 - (_DWORD)dword_83E2064 == 1 )
  {
    v6 = 1;
  }
  else
  {
    v6 = 2;
  }
  return v6;
}
// 80F09C8: using guessed type int dword_80F09C8;
// 830AE48: using guessed type int dword_830AE48;
// 830AE54: using guessed type int dword_830AE54;

//----- (080B109A) --------------------------------------------------------
int sub_80B109A()
{
  unsigned __int8 v1; // [esp+3h] [ebp-9h]
  char *i; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  v3 = dword_80F09D0;
  for ( i = dword_83E2064; (unsigned int)i < dword_80F09C8; ++i )
  {
    if ( *i )
      v1 = byte_80E2B40[4 * (unsigned __int8)*i];
    else
      v1 = 1;
    if ( word_80E2940[v3] )
    {
      dword_830AE5C = v3;
      dword_830AE60 = (int)i;
    }
    while ( word_80E37E0[v1 + word_80E3040[v3]] != v3 )
    {
      v3 = word_80E3240[v3];
      if ( v3 > 244 )
        v1 = byte_80E2F40[4 * v1];
    }
    v3 = word_80E3440[v1 + word_80E3040[v3]];
  }
  return v3;
}
// 80F09C8: using guessed type int dword_80F09C8;
// 80F09D0: using guessed type int dword_80F09D0;
// 830AE5C: using guessed type int dword_830AE5C;
// 830AE60: using guessed type int dword_830AE60;

//----- (080B1172) --------------------------------------------------------
int __cdecl sub_80B1172(int a1)
{
  int v2; // [esp+0h] [ebp-Ch]
  unsigned __int8 v3; // [esp+7h] [ebp-5h]
  int v4; // [esp+14h] [ebp+8h]

  v3 = 1;
  if ( word_80E2940[a1] )
  {
    dword_830AE5C = a1;
    dword_830AE60 = dword_80F09C8;
  }
  while ( word_80E37E0[v3 + word_80E3040[a1]] != a1 )
  {
    a1 = word_80E3240[a1];
    if ( a1 > 244 )
      v3 = byte_80E2F40[4 * v3];
  }
  v4 = word_80E3440[v3 + word_80E3040[a1]];
  if ( v4 == 244 )
    v2 = 0;
  else
    v2 = v4;
  return v2;
}
// 80F09C8: using guessed type int dword_80F09C8;
// 830AE5C: using guessed type int dword_830AE5C;
// 830AE60: using guessed type int dword_830AE60;

//----- (080B122E) --------------------------------------------------------
int sub_80B122E()
{
  int v1; // [esp+8h] [ebp-10h]
  int v3; // [esp+10h] [ebp-8h]
  int v4; // [esp+14h] [ebp-4h]

  *(_BYTE *)dword_80F09C8 = byte_830AE50;
  if ( *(_BYTE *)dword_80F09C8 )
    goto LABEL_16;
  if ( dword_80F09C8 < (unsigned int)(dword_830AE54 + *(_DWORD *)(dword_80F09C4 + 4)) )
  {
    *(_BYTE *)dword_80F09C8 = 0;
    goto LABEL_16;
  }
  v3 = dword_80F09C8 - (_DWORD)dword_83E2064;
  ++dword_80F09C8;
  v1 = sub_80B0DC4();
  if ( v1 != 1 )
  {
    if ( v1 <= 1 )
    {
      if ( !v1 )
        dword_80F09C8 = (int)&dword_83E2064[v3];
      goto LABEL_16;
    }
    if ( v1 != 2 )
    {
LABEL_16:
      v4 = *(unsigned __int8 *)dword_80F09C8;
      *(_BYTE *)dword_80F09C8++ = 0;
      byte_830AE50 = *(_BYTE *)dword_80F09C8;
      return v4;
    }
    sub_80B132F(dword_80F09D4);
  }
  if ( sub_80B1884() )
    return -1;
  if ( !dword_830AE58 )
    sub_80B132F(dword_80F09D4);
  return sub_80B122E();
}
// 80F09C8: using guessed type int dword_80F09C8;
// 830AE50: using guessed type char byte_830AE50;
// 830AE54: using guessed type int dword_830AE54;
// 830AE58: using guessed type int dword_830AE58;

//----- (080B132F) --------------------------------------------------------
int __cdecl sub_80B132F(FILE *stream)
{
  if ( !dword_80F09C4 )
    dword_80F09C4 = (int)sub_80B140F(dword_80F09D4, 0x4000);
  sub_80B14D8(dword_80F09C4, stream);
  return sub_80B13D2();
}

//----- (080B1373) --------------------------------------------------------
int __cdecl sub_80B1373(int a1)
{
  int result; // eax

  result = dword_80F09C4;
  if ( dword_80F09C4 != a1 )
  {
    if ( dword_80F09C4 )
    {
      *(_BYTE *)dword_80F09C8 = byte_830AE50;
      *(_DWORD *)(dword_80F09C4 + 8) = dword_80F09C8;
      *(_DWORD *)(dword_80F09C4 + 16) = dword_830AE54;
    }
    dword_80F09C4 = a1;
    result = sub_80B13D2();
    dword_830AE58 = 1;
  }
  return result;
}
// 80F09C8: using guessed type int dword_80F09C8;
// 830AE50: using guessed type char byte_830AE50;
// 830AE54: using guessed type int dword_830AE54;
// 830AE58: using guessed type int dword_830AE58;

//----- (080B13D2) --------------------------------------------------------
int sub_80B13D2()
{
  int result; // eax

  dword_830AE54 = *(_DWORD *)(dword_80F09C4 + 16);
  dword_80F09C8 = *(_DWORD *)(dword_80F09C4 + 8);
  dword_83E2064 = (char *)dword_80F09C8;
  dword_80F09D4 = *(FILE **)dword_80F09C4;
  result = *(unsigned __int8 *)dword_80F09C8;
  byte_830AE50 = *(_BYTE *)dword_80F09C8;
  return result;
}
// 80F09C8: using guessed type int dword_80F09C8;
// 830AE50: using guessed type char byte_830AE50;
// 830AE54: using guessed type int dword_830AE54;

//----- (080B140F) --------------------------------------------------------
_DWORD *__cdecl sub_80B140F(FILE *stream, int a2)
{
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_80B1770(0x28u);
  if ( !v3 )
    sub_80B1742("out of dynamic memory in yy_create_buffer()");
  v3[3] = a2;
  v3[1] = sub_80B1770(v3[3] + 2);
  if ( !v3[1] )
    sub_80B1742("out of dynamic memory in yy_create_buffer()");
  v3[5] = 1;
  sub_80B14D8((int)v3, stream);
  return v3;
}

//----- (080B14D8) --------------------------------------------------------
_BOOL4 __cdecl sub_80B14D8(int a1, FILE *stream)
{
  int v2; // eax
  _BOOL4 result; // eax
  _BOOL4 v4; // [esp+10h] [ebp-8h]

  sub_80B153E(a1);
  *(_DWORD *)a1 = stream;
  *(_DWORD *)(a1 + 32) = 1;
  if ( stream )
  {
    v2 = fileno(stream);
    v4 = isatty(v2) > 0;
  }
  else
  {
    v4 = 0;
  }
  result = v4;
  *(_DWORD *)(a1 + 24) = v4;
  return result;
}

//----- (080B153E) --------------------------------------------------------
int __cdecl sub_80B153E(int a1)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a1 + 16) = 0;
    **(_BYTE **)(a1 + 4) = 0;
    *(_BYTE *)(*(_DWORD *)(a1 + 4) + 1) = 0;
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(a1 + 28) = 1;
    *(_DWORD *)(a1 + 36) = 0;
    result = a1;
    if ( a1 == dword_80F09C4 )
      result = sub_80B13D2();
  }
  return result;
}

//----- (080B159B) --------------------------------------------------------
_DWORD *__cdecl sub_80B159B(int a1, unsigned int a2)
{
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( a2 <= 1 || *(_BYTE *)(a1 + a2 - 2) || *(_BYTE *)(a1 + a2 - 1) )
    return 0;
  v4 = sub_80B1770(0x28u);
  if ( !v4 )
    sub_80B1742("out of dynamic memory in yy_scan_buffer()");
  v4[3] = a2 - 2;
  v4[1] = a1;
  v4[2] = a1;
  v4[5] = 0;
  *v4 = 0;
  v4[4] = v4[3];
  v4[6] = 0;
  v4[7] = 1;
  v4[8] = 0;
  v4[9] = 0;
  sub_80B1373((int)v4);
  return v4;
}

//----- (080B169D) --------------------------------------------------------
_DWORD *__cdecl sub_80B169D(int a1, int a2)
{
  int i; // [esp+8h] [ebp-10h]
  _BYTE *v4; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v4 = sub_80B1770(a2 + 2);
  if ( !v4 )
    sub_80B1742("out of dynamic memory in yy_scan_bytes()");
  for ( i = 0; i < a2; ++i )
    v4[i] = *(_BYTE *)(a1 + i);
  v4[a2 + 1] = 0;
  v4[a2] = 0;
  v5 = sub_80B159B((int)v4, a2 + 2);
  if ( !v5 )
    sub_80B1742("bad buffer in yy_scan_bytes()");
  v5[5] = 1;
  return v5;
}

//----- (080B1742) --------------------------------------------------------
void __cdecl __noreturn sub_80B1742(const char *a1)
{
  fprintf(stderr, "%s\n", a1);
  exit(2);
}

//----- (080B1770) --------------------------------------------------------
void *__cdecl sub_80B1770(size_t size)
{
  return malloc(size);
}

//----- (080B1783) --------------------------------------------------------
void *__cdecl sub_80B1783(void *ptr, size_t size)
{
  return realloc(ptr, size);
}

//----- (080B179D) --------------------------------------------------------
void __cdecl sub_80B179D(void *ptr)
{
  free(ptr);
}

//----- (080B17B0) --------------------------------------------------------
int sub_80B17B0()
{
  if ( !dword_83E3420 )
    sub_80A2D58(dword_830AE4C, "unexpected end of file found");
  if ( dword_83E3420 != 257 )
    sub_80A2D58(dword_830AE4C, "bad syntax");
  return 0;
}
// 83E3420: using guessed type int dword_83E3420;

//----- (080B17FE) --------------------------------------------------------
int __cdecl sub_80B17FE(int a1, _DWORD *a2)
{
  int result; // eax
  char v3; // [esp+10h] [ebp-4048h] BYREF
  int v4[14]; // [esp+4020h] [ebp-38h] BYREF

  dword_830AE48 = a1;
  dword_830AE44 = 0;
  dword_830AE4C = 0;
  dword_80F09CC = 1;
  v4[3] = 0x4000;
  v4[1] = (int)&v3;
  v4[5] = 0;
  sub_80B14D8((int)v4, 0);
  dword_80F09C4 = (int)v4;
  dword_80F09D0 = 3;
  sub_80B188E();
  result = dword_830AE40;
  *a2 = dword_830AE40;
  return result;
}
// 80F09CC: using guessed type int dword_80F09CC;
// 80F09D0: using guessed type int dword_80F09D0;
// 830AE40: using guessed type int dword_830AE40;
// 830AE44: using guessed type int dword_830AE44;
// 830AE48: using guessed type int dword_830AE48;

//----- (080B1884) --------------------------------------------------------
int sub_80B1884()
{
  return 1;
}

//----- (080B188E) --------------------------------------------------------
int sub_80B188E()
{
  int v0; // ecx
  int v1; // edx
  int v2; // ecx
  int v3; // edx
  int *v4; // edx
  int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  int v9; // ecx
  int v10; // edx
  int v12; // [esp+20h] [ebp-2B8h]
  int v13; // [esp+20h] [ebp-2B8h]
  int v14; // [esp+24h] [ebp-2B4h]
  int v15; // [esp+24h] [ebp-2B4h]
  int v16; // [esp+24h] [ebp-2B4h]
  int v17; // [esp+24h] [ebp-2B4h]
  int v18; // [esp+24h] [ebp-2B4h]
  int v19; // [esp+28h] [ebp-2B0h]
  int v20; // [esp+28h] [ebp-2B0h]
  int v22; // [esp+30h] [ebp-2A8h] BYREF
  int v23; // [esp+34h] [ebp-2A4h] BYREF
  int v24; // [esp+38h] [ebp-2A0h] BYREF
  int v25; // [esp+3Ch] [ebp-29Ch] BYREF
  int v26; // [esp+40h] [ebp-298h] BYREF
  int v27; // [esp+44h] [ebp-294h] BYREF
  int v28; // [esp+48h] [ebp-290h] BYREF
  int v29; // [esp+4Ch] [ebp-28Ch] BYREF
  int v30; // [esp+50h] [ebp-288h] BYREF
  _DWORD *v31; // [esp+54h] [ebp-284h] BYREF
  int v32; // [esp+58h] [ebp-280h] BYREF
  int v33; // [esp+5Ch] [ebp-27Ch] BYREF
  int v34; // [esp+60h] [ebp-278h] BYREF
  int v35; // [esp+64h] [ebp-274h] BYREF
  int v36; // [esp+68h] [ebp-270h] BYREF
  int v37; // [esp+6Ch] [ebp-26Ch] BYREF
  int v38; // [esp+70h] [ebp-268h] BYREF
  int v39; // [esp+74h] [ebp-264h] BYREF
  int v40; // [esp+78h] [ebp-260h] BYREF
  int v41; // [esp+7Ch] [ebp-25Ch] BYREF
  int v42; // [esp+80h] [ebp-258h] BYREF
  int v43; // [esp+84h] [ebp-254h] BYREF
  int v44; // [esp+88h] [ebp-250h] BYREF
  int v45; // [esp+8Ch] [ebp-24Ch] BYREF
  int v46; // [esp+90h] [ebp-248h] BYREF
  int v47; // [esp+94h] [ebp-244h] BYREF
  int v48; // [esp+98h] [ebp-240h] BYREF
  int v49; // [esp+9Ch] [ebp-23Ch] BYREF
  int v50; // [esp+A0h] [ebp-238h] BYREF
  int v51; // [esp+A4h] [ebp-234h] BYREF
  int v52; // [esp+A8h] [ebp-230h] BYREF
  int v53; // [esp+ACh] [ebp-22Ch] BYREF
  int v54; // [esp+B0h] [ebp-228h] BYREF
  _DWORD *v55; // [esp+B4h] [ebp-224h] BYREF
  int v56; // [esp+B8h] [ebp-220h] BYREF
  int v57; // [esp+BCh] [ebp-21Ch] BYREF
  int v58; // [esp+C0h] [ebp-218h] BYREF
  int v59; // [esp+C4h] [ebp-214h] BYREF
  int v60; // [esp+C8h] [ebp-210h] BYREF
  int v61; // [esp+CCh] [ebp-20Ch] BYREF
  int v62; // [esp+D0h] [ebp-208h] BYREF
  int v63; // [esp+D4h] [ebp-204h] BYREF
  int v64; // [esp+D8h] [ebp-200h] BYREF
  int v65; // [esp+DCh] [ebp-1FCh] BYREF
  int v66; // [esp+E0h] [ebp-1F8h] BYREF
  int v67; // [esp+E4h] [ebp-1F4h] BYREF
  int v68; // [esp+E8h] [ebp-1F0h] BYREF
  int v69; // [esp+ECh] [ebp-1ECh] BYREF
  int v70; // [esp+F0h] [ebp-1E8h] BYREF
  int v71; // [esp+F4h] [ebp-1E4h] BYREF
  int v72; // [esp+F8h] [ebp-1E0h] BYREF
  int v73; // [esp+FCh] [ebp-1DCh] BYREF
  int v74; // [esp+100h] [ebp-1D8h] BYREF
  int v75; // [esp+104h] [ebp-1D4h] BYREF
  int v76; // [esp+108h] [ebp-1D0h] BYREF
  int v77; // [esp+10Ch] [ebp-1CCh] BYREF
  int v78; // [esp+110h] [ebp-1C8h] BYREF
  int v79; // [esp+114h] [ebp-1C4h] BYREF
  int v80; // [esp+118h] [ebp-1C0h] BYREF
  int v81; // [esp+11Ch] [ebp-1BCh] BYREF
  int v82; // [esp+120h] [ebp-1B8h] BYREF
  int v83; // [esp+124h] [ebp-1B4h] BYREF
  int v84; // [esp+128h] [ebp-1B0h] BYREF
  int v85; // [esp+12Ch] [ebp-1ACh] BYREF
  int v86; // [esp+130h] [ebp-1A8h] BYREF
  int v87; // [esp+134h] [ebp-1A4h] BYREF
  int v88; // [esp+138h] [ebp-1A0h] BYREF
  int v89; // [esp+13Ch] [ebp-19Ch] BYREF
  int v90; // [esp+140h] [ebp-198h] BYREF
  int v91; // [esp+144h] [ebp-194h] BYREF
  int v92; // [esp+148h] [ebp-190h] BYREF
  int v93; // [esp+14Ch] [ebp-18Ch] BYREF
  int v94; // [esp+150h] [ebp-188h] BYREF
  int v95; // [esp+154h] [ebp-184h] BYREF
  int v96; // [esp+158h] [ebp-180h] BYREF
  int v97; // [esp+15Ch] [ebp-17Ch] BYREF
  int v98; // [esp+160h] [ebp-178h] BYREF
  int v99; // [esp+164h] [ebp-174h] BYREF
  int v100; // [esp+168h] [ebp-170h] BYREF
  int v101; // [esp+16Ch] [ebp-16Ch] BYREF
  int v102; // [esp+170h] [ebp-168h] BYREF
  int v103; // [esp+174h] [ebp-164h] BYREF
  int v104; // [esp+178h] [ebp-160h] BYREF
  int v105; // [esp+17Ch] [ebp-15Ch] BYREF
  int v106; // [esp+180h] [ebp-158h] BYREF
  int v107; // [esp+184h] [ebp-154h] BYREF
  int v108; // [esp+188h] [ebp-150h] BYREF
  int v109; // [esp+18Ch] [ebp-14Ch] BYREF
  int v110; // [esp+190h] [ebp-148h] BYREF
  int v111; // [esp+194h] [ebp-144h] BYREF
  int v112; // [esp+198h] [ebp-140h] BYREF
  int v113; // [esp+19Ch] [ebp-13Ch] BYREF
  int v114; // [esp+1A0h] [ebp-138h] BYREF
  int v115; // [esp+1A4h] [ebp-134h] BYREF
  int v116; // [esp+1A8h] [ebp-130h] BYREF
  int v117; // [esp+1ACh] [ebp-12Ch] BYREF
  int v118; // [esp+1B0h] [ebp-128h] BYREF
  int v119; // [esp+1B4h] [ebp-124h] BYREF
  int v120; // [esp+1B8h] [ebp-120h] BYREF
  int v121; // [esp+1BCh] [ebp-11Ch] BYREF
  int v122; // [esp+1C0h] [ebp-118h] BYREF
  int v123; // [esp+1C4h] [ebp-114h] BYREF
  int v124; // [esp+1C8h] [ebp-110h] BYREF
  int v125; // [esp+1CCh] [ebp-10Ch] BYREF
  int v126; // [esp+1D0h] [ebp-108h] BYREF
  int v127; // [esp+1D4h] [ebp-104h] BYREF
  int v128; // [esp+1D8h] [ebp-100h] BYREF
  int v129; // [esp+1DCh] [ebp-FCh] BYREF
  int v130; // [esp+1E0h] [ebp-F8h] BYREF
  int v131; // [esp+1E4h] [ebp-F4h] BYREF
  int v132; // [esp+1E8h] [ebp-F0h] BYREF
  int v133; // [esp+1ECh] [ebp-ECh] BYREF
  int v134; // [esp+1F0h] [ebp-E8h] BYREF
  int v135; // [esp+1F4h] [ebp-E4h] BYREF
  int v136; // [esp+1F8h] [ebp-E0h] BYREF
  int v137; // [esp+1FCh] [ebp-DCh] BYREF
  int v138; // [esp+200h] [ebp-D8h] BYREF
  int v139; // [esp+204h] [ebp-D4h] BYREF
  int v140; // [esp+208h] [ebp-D0h] BYREF
  int v141; // [esp+20Ch] [ebp-CCh] BYREF
  int v142; // [esp+210h] [ebp-C8h] BYREF
  int v143; // [esp+214h] [ebp-C4h] BYREF
  int v144; // [esp+218h] [ebp-C0h] BYREF
  int v145; // [esp+21Ch] [ebp-BCh] BYREF
  int v146; // [esp+220h] [ebp-B8h] BYREF
  int v147; // [esp+224h] [ebp-B4h] BYREF
  int v148; // [esp+228h] [ebp-B0h] BYREF
  int v149; // [esp+22Ch] [ebp-ACh] BYREF
  int v150; // [esp+230h] [ebp-A8h] BYREF
  int v151; // [esp+234h] [ebp-A4h] BYREF
  int v152; // [esp+238h] [ebp-A0h] BYREF
  int v153; // [esp+23Ch] [ebp-9Ch] BYREF
  int v154; // [esp+240h] [ebp-98h] BYREF
  int v155; // [esp+244h] [ebp-94h] BYREF
  int v156; // [esp+248h] [ebp-90h] BYREF
  int v157; // [esp+24Ch] [ebp-8Ch] BYREF
  int v158; // [esp+250h] [ebp-88h] BYREF
  int v159; // [esp+254h] [ebp-84h] BYREF
  int v160; // [esp+258h] [ebp-80h] BYREF
  int v161; // [esp+25Ch] [ebp-7Ch] BYREF
  int v162; // [esp+260h] [ebp-78h] BYREF
  int v163; // [esp+264h] [ebp-74h] BYREF
  int v164; // [esp+268h] [ebp-70h] BYREF
  int v165; // [esp+26Ch] [ebp-6Ch] BYREF
  int v166; // [esp+270h] [ebp-68h] BYREF
  int v167; // [esp+274h] [ebp-64h] BYREF
  int v168; // [esp+278h] [ebp-60h] BYREF
  int v169; // [esp+27Ch] [ebp-5Ch] BYREF
  int v170; // [esp+280h] [ebp-58h] BYREF
  int v171; // [esp+284h] [ebp-54h] BYREF
  int v172; // [esp+288h] [ebp-50h] BYREF
  int v173; // [esp+28Ch] [ebp-4Ch] BYREF
  int v174; // [esp+290h] [ebp-48h] BYREF
  int v175; // [esp+294h] [ebp-44h] BYREF
  int v176; // [esp+298h] [ebp-40h] BYREF
  int v177; // [esp+29Ch] [ebp-3Ch] BYREF
  int v178; // [esp+2A0h] [ebp-38h] BYREF
  int v179; // [esp+2A4h] [ebp-34h] BYREF
  int v180; // [esp+2A8h] [ebp-30h] BYREF
  int v181; // [esp+2ACh] [ebp-2Ch] BYREF
  int v182; // [esp+2B0h] [ebp-28h] BYREF
  int v183; // [esp+2B4h] [ebp-24h] BYREF
  int v184; // [esp+2B8h] [ebp-20h] BYREF
  int v185; // [esp+2BCh] [ebp-1Ch] BYREF
  int v186; // [esp+2C0h] [ebp-18h] BYREF
  int v187; // [esp+2C4h] [ebp-14h] BYREF
  int v188; // [esp+2C8h] [ebp-10h] BYREF
  int v189[3]; // [esp+2CCh] [ebp-Ch] BYREF

  dword_83E2070 = 0;
  dword_83E2060 = 0;
  dword_83E3420 = -1;
  dword_83E206C = (int)word_83E2080;
  dword_83E2068 = (int)&unk_83E2480;
  v12 = 0;
  word_83E2080[0] = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v14 = word_80EEB60[v12];
          if ( !word_80EEB60[v12] )
            break;
LABEL_32:
          v19 = word_80EEA60[v14];
          v4 = (int *)(dword_83E2068 + 8 * (1 - v19));
          v5 = *v4;
          v6 = v4[1];
          dword_83E2074 = v5;
          dword_83E2078 = v6;
          switch ( v14 )
          {
            case 1:
              sub_80A30F8((int)&dword_830AE40, dword_83E2074, *(_DWORD *)dword_83E2068);
              break;
            case 2:
              sub_80A304A(v189, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 4, dword_83E2074, v189[0]);
              break;
            case 3:
              sub_80A304A(&v188, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A304A(&v187, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A304A(&v186, dword_83E2078);
              sub_80A324C((int)&dword_83E2074, 43, dword_83E2074, v186, *(_DWORD *)dword_83E2068, v187, v188);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 4:
              sub_80A304A(&v185, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A304A(&v184, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A304A(&v183, dword_83E2078);
              sub_80A324C((int)&dword_83E2074, 44, dword_83E2074, v183, *(_DWORD *)dword_83E2068, v184, v185);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 5:
              sub_80A304A(&v182, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v181, 61);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v181, v182);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 6:
              sub_80A304A(&v180, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v179, 62);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v179, v180);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 7:
              sub_80A304A(&v178, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v177, 63);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v177, v178);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 8:
              sub_80A304A(&v176, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v175, 64);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v175, v176);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 9:
              sub_80A304A(&v174, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v173, 65);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v173, v174);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 10:
              sub_80A304A(&v172, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v171, 66);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v171, v172);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 11:
              sub_80A304A(&v170, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v169, 67);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v169, v170);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 12:
              sub_80A304A(&v168, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v167, 68);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v167, v168);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 13:
              sub_80A304A(&v166, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v165, 69);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v165, v166);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 14:
              sub_80A304A(&v164, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v163, 70);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v163, v164);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 15:
              sub_80A304A(&v162, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v161, 71);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v161, v162);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 16:
              sub_80A304A(&v160, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v159, 72);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v159, v160);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 17:
              sub_80A304A(&v158, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v157, 73);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v157, v158);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 18:
              sub_80A304A(&v156, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v155, 74);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v155, v156);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 19:
              sub_80A304A(&v154, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v153, 75);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v153, v154);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 20:
              sub_80A304A(&v152, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v151, 76);
              sub_80A31B2((int)&dword_83E2074, 45, dword_83E2074, *(_DWORD *)dword_83E2068, v151, v152);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              break;
            case 21:
              sub_80A304A(&v150, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 46, *(_DWORD *)dword_83E2068, v150);
              break;
            case 22:
              sub_80A304A(&v149, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 47, *(_DWORD *)dword_83E2068, v149);
              break;
            case 23:
              sub_80A304A(&v148, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 48, *(_DWORD *)dword_83E2068, v148);
              break;
            case 24:
              sub_80A304A(&v147, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 49, *(_DWORD *)dword_83E2068, v147);
              break;
            case 25:
              sub_80A304A(&v146, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 50, *(_DWORD *)dword_83E2068, v146);
              break;
            case 26:
              sub_80A304A(&v145, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 51, *(_DWORD *)dword_83E2068, v145);
              break;
            case 27:
              sub_80A3086((int)&dword_83E2074, 63, dword_83E2074);
              break;
            case 28:
            case 89:
            case 99:
            case 107:
            case 122:
              sub_80A305C(&dword_83E2074, 0);
              break;
            case 31:
              sub_80A304A(&v144, dword_83E2078);
              sub_80A312C((int)&dword_83E2074, 17, dword_83E2074, *(_DWORD *)dword_83E2068, v144);
              ++dword_81768CC;
              break;
            case 32:
              sub_80A304A(&v143, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 16, dword_83E2074, v143);
              break;
            case 33:
              sub_80A304A(&v142, dword_83E2078);
              sub_80A312C((int)&dword_83E2074, 17, dword_83E2074, *(_DWORD *)dword_83E2068, v142);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 8 + 4);
              ++dword_81768CC;
              break;
            case 34:
              sub_80A304A(&v141, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 16, *(_DWORD *)dword_83E2068, v141);
              break;
            case 35:
              sub_80A304A(&v140, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 14, dword_83E2074, v140);
              break;
            case 36:
              sub_80A304A(&v139, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A30BA((int)&dword_83E2074, 18, *(_DWORD *)(dword_83E2068 - 16), v139);
              break;
            case 37:
              sub_80A304A(&v138, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 22, dword_83E2074, v138);
              break;
            case 38:
              sub_80A304A(&v137, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A304A(&v136, dword_83E2078);
              sub_80A312C((int)&dword_83E2074, 26, *(_DWORD *)dword_83E2068, v136, v137);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 + 4);
              break;
            case 39:
              sub_80A304A(&v135, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A312C((int)&dword_83E2074, 19, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v135);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 16 + 4);
              break;
            case 40:
              sub_80A304A(&v134, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A304A(&v133, dword_83E2078);
              sub_80A324C(
                (int)&dword_83E2074,
                20,
                dword_83E2074,
                *(_DWORD *)(dword_83E2068 - 24),
                *(_DWORD *)(dword_83E2068 - 8),
                v133,
                v134);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 16 + 4);
              break;
            case 41:
              sub_80A304A(&v132, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 42, *(_DWORD *)(dword_83E2068 - 8), v132);
              break;
            case 42:
              sub_80A304A(&v131, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 5, dword_83E2074, v131);
              break;
            case 43:
              sub_80A304A(&v130, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 6, dword_83E2074, v130);
              break;
            case 44:
              sub_80A304A(&v129, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 7, *(_DWORD *)dword_83E2068, v129);
              break;
            case 45:
              sub_80A304A(&v128, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 8, *(_DWORD *)dword_83E2068, v128);
              break;
            case 46:
              sub_80A304A(&v127, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 9, dword_83E2074, v127);
              break;
            case 47:
              sub_80A304A(&v126, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 10, dword_83E2074, v126);
              break;
            case 48:
              sub_80A3086((int)&dword_83E2074, 15, dword_83E2074);
              break;
            case 49:
              sub_80A304A(&v125, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 13, dword_83E2074, v125);
              break;
            case 50:
              sub_80A304A(&v124, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 27, v124);
              break;
            case 51:
              sub_80A304A(&v123, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 28, v123);
              break;
            case 52:
              sub_80A304A(&v122, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 29, v122);
              break;
            case 53:
              sub_80A304A(&v121, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 30, v121);
              break;
            case 54:
              sub_80A304A(&v120, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 31, v120);
              break;
            case 55:
              sub_80A304A(&v119, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 52, dword_83E2074, v119);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 + 4);
              break;
            case 56:
              sub_80A304A(&v118, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 14, dword_83E2074, v118);
              break;
            case 57:
              sub_80A305C(&dword_83E2074, 64);
              break;
            case 58:
              sub_80A304A(&v117, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30BA((int)&dword_83E2074, 65, *(_DWORD *)dword_83E2068, v117);
              break;
            case 59:
              sub_80A304A(&v116, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 69, dword_83E2074, v116);
              break;
            case 60:
              sub_80A304A(&v115, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 70, dword_83E2074, v115);
              break;
            case 61:
              sub_80A304A(&v114, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 71, v114);
              break;
            case 62:
              sub_80A304A(&v113, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A304A(&v112, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 12, dword_83E2074, *(_DWORD *)dword_83E2068, v112, v113);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 + 4);
              break;
            case 63:
              sub_80A304A(&v111, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A304A(&v110, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 11, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v110, v111);
              dword_83E2078 = *(_DWORD *)(dword_83E2068 - 16 + 4);
              break;
            case 64:
              sub_80A304A(&v109, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 3, dword_83E2074, v109);
              break;
            case 65:
              sub_80A3086((int)&dword_83E2074, 21, dword_83E2074);
              break;
            case 66:
              sub_80A304A(&v108, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A312C((int)&dword_83E2074, 2, dword_83E2074, *(_DWORD *)dword_83E2068, v108);
              break;
            case 67:
              sub_80A304A(&v107, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 23, *(_DWORD *)dword_83E2068, v107);
              break;
            case 68:
              sub_80A304A(&v106, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 24, v106);
              break;
            case 69:
              sub_80A304A(&v105, dword_83E2078);
              sub_80A304A(&v104, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A312C((int)&dword_83E2074, 25, *(_DWORD *)dword_83E2068, v104, v105);
              break;
            case 70:
              sub_80A304A(&v103, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 37, dword_83E2074, v103);
              break;
            case 71:
              sub_80A304A(&v102, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 38, dword_83E2074, v102);
              break;
            case 72:
              sub_80A304A(&v101, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v100, 61);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v100, v101);
              break;
            case 73:
              sub_80A304A(&v99, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v98, 62);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v98, v99);
              break;
            case 74:
              sub_80A304A(&v97, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v96, 63);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v96, v97);
              break;
            case 75:
              sub_80A304A(&v95, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v94, 70);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v94, v95);
              break;
            case 76:
              sub_80A304A(&v93, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v92, 71);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v92, v93);
              break;
            case 77:
              sub_80A304A(&v91, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v90, 72);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v90, v91);
              break;
            case 78:
              sub_80A304A(&v89, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v88, 73);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v88, v89);
              break;
            case 79:
              sub_80A304A(&v87, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v86, 74);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v86, v87);
              break;
            case 80:
              sub_80A304A(&v85, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v84, 75);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v84, v85);
              break;
            case 81:
              sub_80A304A(&v83, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A3038(&v82, 76);
              sub_80A31B2((int)&dword_83E2074, 39, dword_83E2074, *(_DWORD *)dword_83E2068, v82, v83);
              break;
            case 82:
              sub_80A304A(&v81, *(_DWORD *)(dword_83E2068 - 24 + 4));
              sub_80A304A(&v80, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 54, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v80, v81);
              break;
            case 83:
              sub_80A304A(&v79, *(_DWORD *)(dword_83E2068 - 24 + 4));
              sub_80A304A(&v78, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 55, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v78, v79);
              break;
            case 84:
              sub_80A304A(&v77, *(_DWORD *)(dword_83E2068 - 24 + 4));
              sub_80A304A(&v76, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 56, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v76, v77);
              break;
            case 85:
              sub_80A304A(&v75, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A304A(&v74, dword_83E2078);
              sub_80A31B2((int)&dword_83E2074, 57, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8), v74, v75);
              break;
            case 86:
              sub_80A304A(&v73, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 61, v73);
              break;
            case 87:
              sub_80A304A(&v72, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 62, v72);
              break;
            case 88:
              sub_80A304A(&v71, *(_DWORD *)(dword_83E2068 - 24 + 4));
              sub_80A304A(&v70, *(_DWORD *)(dword_83E2068 - 8 + 4));
              sub_80A31B2(
                (int)&dword_83E2074,
                35,
                *(_DWORD *)(dword_83E2068 - 32),
                *(_DWORD *)(dword_83E2068 - 8),
                v70,
                v71);
              break;
            case 92:
              sub_80A304A(&v69, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 40, *(_DWORD *)(dword_83E2068 - 8), v69);
              break;
            case 93:
              sub_80A304A(&v68, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A312C((int)&dword_83E2074, 32, *(_DWORD *)(dword_83E2068 - 16), *(_DWORD *)dword_83E2068, v68);
              break;
            case 94:
              sub_80A304A(&v67, *(_DWORD *)(dword_83E2068 - 32 + 4));
              sub_80A31B2(
                (int)&dword_83E2074,
                33,
                *(_DWORD *)(dword_83E2068 - 32),
                *(_DWORD *)(dword_83E2068 - 16),
                *(_DWORD *)dword_83E2068,
                v67);
              break;
            case 95:
              sub_80A304A(&v66, dword_83E2078);
              sub_80A304A(&v65, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A31B2((int)&dword_83E2074, 34, *(_DWORD *)(dword_83E2068 - 16), *(_DWORD *)dword_83E2068, v65, v66);
              break;
            case 96:
              sub_80A304A(&v64, dword_83E2078);
              sub_80A304A(&v63, *(_DWORD *)(dword_83E2068 - 32 + 4));
              sub_80A32A8(
                (int)&dword_83E2074,
                36,
                *(_DWORD *)(dword_83E2068 - 40),
                *(_DWORD *)(dword_83E2068 - 32),
                *(_DWORD *)(dword_83E2068 - 16),
                *(_DWORD *)dword_83E2068,
                v63,
                v64);
              break;
            case 97:
              sub_80A304A(&v62, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A312C((int)&dword_83E2074, 58, *(_DWORD *)(dword_83E2068 - 16), *(_DWORD *)dword_83E2068, v62);
              break;
            case 98:
              sub_80A304A(&v61, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 41, *(_DWORD *)(dword_83E2068 - 8), v61);
              break;
            case 100:
              sub_80A304A(&v60, dword_83E2078);
              sub_80A30BA((int)&dword_83E2074, 59, *(_DWORD *)(dword_83E2068 - 8), v60);
              break;
            case 101:
              sub_80A304A(&v59, dword_83E2078);
              sub_80A3086((int)&dword_83E2074, 60, v59);
              break;
            case 103:
              sub_80A33AA(&dword_83E2074, dword_83E2074, *(_DWORD *)dword_83E2068);
              break;
            case 104:
              sub_80A305C(&v58, 0);
              sub_80A330E((int)&dword_83E2074, v58);
              break;
            case 105:
              sub_80A304A(&v56, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v57, *(_DWORD *)dword_83E2068, v56);
              sub_80A3364(&dword_83E2074, v57, (_DWORD *)dword_83E2074);
              break;
            case 106:
              sub_80A305C((int *)&v55, 0);
              sub_80A304A(&v53, dword_83E2078);
              sub_80A30F8((int)&v54, dword_83E2074, v53);
              sub_80A3364(&dword_83E2074, v54, v55);
              break;
            case 108:
              sub_80A304A(&v51, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v52, *(_DWORD *)dword_83E2068, v51);
              sub_80A33AA(&dword_83E2074, dword_83E2074, v52);
              break;
            case 109:
              sub_80A304A(&v49, dword_83E2078);
              sub_80A30F8((int)&v50, dword_83E2074, v49);
              sub_80A305C(&v47, 0);
              sub_80A330E((int)&v48, v47);
              sub_80A33AA(&dword_83E2074, v48, v50);
              break;
            case 110:
              sub_80A305C(&v46, 0);
              sub_80A330E((int)&dword_83E2074, v46);
              break;
            case 111:
              sub_80A304A(&v44, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v45, *(_DWORD *)dword_83E2068, v44);
              sub_80A33AA(&dword_83E2074, dword_83E2074, v45);
              break;
            case 112:
              sub_80A304A(&v42, dword_83E2078);
              sub_80A30F8((int)&v43, dword_83E2074, v42);
              sub_80A305C(&v40, 0);
              sub_80A330E((int)&v41, v40);
              sub_80A33AA(&dword_83E2074, v41, v43);
              break;
            case 113:
              sub_80A304A(&v38, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v39, *(_DWORD *)dword_83E2068, v38);
              sub_80A33AA(&dword_83E2074, dword_83E2074, v39);
              break;
            case 114:
              sub_80A304A(&v36, dword_83E2078);
              sub_80A30F8((int)&v37, dword_83E2074, v36);
              sub_80A305C(&v34, 0);
              sub_80A330E((int)&v35, v34);
              sub_80A33AA(&dword_83E2074, v35, v37);
              break;
            case 115:
              sub_80A304A(&v32, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v33, *(_DWORD *)dword_83E2068, v32);
              sub_80A3364(&dword_83E2074, v33, (_DWORD *)dword_83E2074);
              break;
            case 116:
              sub_80A305C((int *)&v31, 0);
              sub_80A304A(&v29, dword_83E2078);
              sub_80A30F8((int)&v30, dword_83E2074, v29);
              sub_80A3364(&dword_83E2074, v30, v31);
              break;
            case 117:
              sub_80A304A(&v28, dword_83E2078);
              sub_80A31B2(
                (int)&dword_83E2074,
                66,
                dword_83E2074,
                *(_DWORD *)(dword_83E2068 - 32),
                *(_DWORD *)(dword_83E2068 - 8),
                v28);
              break;
            case 118:
              sub_80A304A(&v27, *(_DWORD *)(dword_83E2068 - 56 + 4));
              sub_80A31B2(
                (int)&dword_83E2074,
                67,
                *(_DWORD *)(dword_83E2068 - 56),
                *(_DWORD *)(dword_83E2068 - 40),
                *(_DWORD *)(dword_83E2068 - 16),
                v27);
              break;
            case 119:
              sub_80A304A(&v26, *(_DWORD *)(dword_83E2068 - 16 + 4));
              sub_80A30BA((int)&dword_83E2074, 68, *(_DWORD *)(dword_83E2068 - 16), v26);
              break;
            case 120:
              sub_80A304A(&v24, *(_DWORD *)(dword_83E2068 + 4));
              sub_80A30F8((int)&v25, *(_DWORD *)dword_83E2068, v24);
              sub_80A33AA(&dword_83E2074, dword_83E2074, v25);
              break;
            case 121:
              sub_80A305C(&v23, 0);
              sub_80A330E((int)&dword_83E2074, v23);
              break;
            case 123:
              sub_80A33AA(&dword_83E2074, dword_83E2074, *(_DWORD *)(dword_83E2068 - 8));
              break;
            case 124:
              sub_80A305C(&v22, 0);
              sub_80A330E((int)&dword_83E2074, v22);
              break;
            default:
              break;
          }
          dword_83E206C -= 2 * v19;
          v13 = *(__int16 *)dword_83E206C;
          dword_83E2068 -= 8 * v19;
          v20 = word_80EE960[v14];
          if ( v13 || word_80EE960[v14] )
          {
            if ( word_80EF1A0[v20]
              && (v18 = v13 + word_80EF1A0[v20], v18 >= 0)
              && v18 <= 1521
              && word_80EFDE0[v18] == v13 )
            {
              v12 = word_80EF1E0[v18];
            }
            else
            {
              v12 = word_80EED60[v20];
            }
            if ( dword_83E206C >= (unsigned int)&unk_83E2466 )
              goto LABEL_163;
            dword_83E206C += 2;
            *(_WORD *)dword_83E206C = v12;
            dword_83E2068 += 8;
            v9 = dword_83E2068;
            v10 = dword_83E2078;
            *(_DWORD *)dword_83E2068 = dword_83E2074;
            *(_DWORD *)(v9 + 4) = v10;
          }
          else
          {
            v12 = 1;
            dword_83E206C += 2;
            *(_WORD *)dword_83E206C = 1;
            dword_83E2068 += 8;
            v7 = dword_83E2068;
            v8 = dword_83E2078;
            *(_DWORD *)dword_83E2068 = dword_83E2074;
            *(_DWORD *)(v7 + 4) = v8;
            if ( dword_83E3420 < 0 )
            {
              dword_83E3420 = sub_80AF9D4();
              if ( dword_83E3420 < 0 )
                dword_83E3420 = 0;
            }
            if ( !dword_83E3420 )
              return 0;
          }
        }
        if ( dword_83E3420 < 0 )
        {
          dword_83E3420 = sub_80AF9D4();
          if ( dword_83E3420 < 0 )
            dword_83E3420 = 0;
        }
        if ( !word_80EEDA0[v12] )
          break;
        v15 = dword_83E3420 + word_80EEDA0[v12];
        if ( v15 < 0 || v15 > 1521 || word_80EFDE0[v15] != dword_83E3420 )
          break;
        if ( dword_83E206C >= (unsigned int)&unk_83E2466 )
          goto LABEL_163;
        dword_83E206C += 2;
        v12 = word_80EF1E0[v15];
        *(_WORD *)dword_83E206C = v12;
        dword_83E2068 += 8;
        v0 = dword_83E2068;
        v1 = dword_83E2470;
        *(_DWORD *)dword_83E2068 = dword_83E246C;
        *(_DWORD *)(v0 + 4) = v1;
        dword_83E3420 = -1;
        if ( dword_83E2060 > 0 )
          --dword_83E2060;
      }
      if ( word_80EEFA0[v12] )
      {
        v16 = dword_83E3420 + word_80EEFA0[v12];
        if ( v16 >= 0 && v16 <= 1521 && word_80EFDE0[v16] == dword_83E3420 )
        {
          v14 = word_80EF1E0[v16];
          goto LABEL_32;
        }
      }
      if ( !dword_83E2060 )
      {
        sub_80B17B0();
        ++dword_83E2070;
      }
      if ( dword_83E2060 <= 2 )
        break;
      if ( !dword_83E3420 )
        return 1;
      dword_83E3420 = -1;
    }
    dword_83E2060 = 3;
    while ( 1 )
    {
      if ( word_80EEDA0[*(__int16 *)dword_83E206C] )
      {
        v17 = word_80EEDA0[*(__int16 *)dword_83E206C] + 256;
        if ( v17 >= 0 && v17 <= 1521 && word_80EFDE0[v17] == 256 )
          break;
      }
      if ( dword_83E206C <= (unsigned int)word_83E2080 )
        return 1;
      dword_83E206C -= 2;
      dword_83E2068 -= 8;
    }
    if ( dword_83E206C >= (unsigned int)&unk_83E2466 )
      break;
    dword_83E206C += 2;
    v12 = word_80EF1E0[v17];
    *(_WORD *)dword_83E206C = v12;
    dword_83E2068 += 8;
    v2 = dword_83E2068;
    v3 = dword_83E2470;
    *(_DWORD *)dword_83E2068 = dword_83E246C;
    *(_DWORD *)(v2 + 4) = v3;
  }
LABEL_163:
  sub_80B17B0();
  return 1;
}
// 80EE960: using guessed type __int16 word_80EE960[];
// 80EEB60: using guessed type __int16 word_80EEB60[];
// 80EEFA0: using guessed type __int16 word_80EEFA0[];
// 80EFDE0: using guessed type __int16 word_80EFDE0[];
// 81768CC: using guessed type int dword_81768CC;
// 830AE40: using guessed type int dword_830AE40;
// 83E2060: using guessed type int dword_83E2060;
// 83E2068: using guessed type int dword_83E2068;
// 83E206C: using guessed type int dword_83E206C;
// 83E2070: using guessed type int dword_83E2070;
// 83E2074: using guessed type int dword_83E2074;
// 83E2078: using guessed type int dword_83E2078;
// 83E246C: using guessed type int dword_83E246C;
// 83E2470: using guessed type int dword_83E2470;
// 83E3420: using guessed type int dword_83E3420;

//----- (080B4A60) --------------------------------------------------------
int __cdecl sub_80B4A60(int a1, unsigned __int8 *a2, unsigned int a3)
{
  int v4; // [esp+0h] [ebp-14h]
  int v6; // [esp+8h] [ebp-Ch]
  unsigned int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+Ch] [ebp-8h]
  int v12; // [esp+Ch] [ebp-8h]
  int v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+Ch] [ebp-8h]
  int v16; // [esp+Ch] [ebp-8h]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  unsigned int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+10h] [ebp-4h]
  int v26; // [esp+10h] [ebp-4h]
  int v27; // [esp+10h] [ebp-4h]
  int v28; // [esp+10h] [ebp-4h]
  int v29; // [esp+10h] [ebp-4h]
  int v30; // [esp+10h] [ebp-4h]
  int v31; // [esp+10h] [ebp-4h]
  int v32; // [esp+10h] [ebp-4h]
  int v33; // [esp+10h] [ebp-4h]
  int v34; // [esp+10h] [ebp-4h]
  int v35; // [esp+10h] [ebp-4h]
  int v36; // [esp+10h] [ebp-4h]
  int v37; // [esp+10h] [ebp-4h]
  int v38; // [esp+10h] [ebp-4h]

  v23 = (unsigned __int16)a1;
  v7 = HIWORD(a1);
  if ( !a2 )
    return 1;
  while ( a3 )
  {
    v4 = a3;
    if ( a3 > 0x15B0 )
      v4 = 5552;
    v6 = v4;
    a3 -= v4;
    while ( v6 > 15 )
    {
      v24 = *a2 + v23;
      v8 = v24 + v7;
      v25 = a2[1] + v24;
      v9 = v25 + v8;
      v26 = a2[2] + v25;
      v10 = v26 + v9;
      v27 = a2[3] + v26;
      v11 = v27 + v10;
      v28 = a2[4] + v27;
      v12 = v28 + v11;
      v29 = a2[5] + v28;
      v13 = v29 + v12;
      v30 = a2[6] + v29;
      v14 = v30 + v13;
      v31 = a2[7] + v30;
      v15 = v31 + v14;
      v32 = a2[8] + v31;
      v16 = v32 + v15;
      v33 = a2[9] + v32;
      v17 = v33 + v16;
      v34 = a2[10] + v33;
      v18 = v34 + v17;
      v35 = a2[11] + v34;
      v19 = v35 + v18;
      v36 = a2[12] + v35;
      v20 = v36 + v19;
      v37 = a2[13] + v36;
      v21 = v37 + v20;
      v38 = a2[14] + v37;
      v22 = v38 + v21;
      v23 = a2[15] + v38;
      v7 = v23 + v22;
      a2 += 16;
      v6 -= 16;
    }
    for ( ; v6; --v6 )
    {
      v23 += *a2++;
      v7 += v23;
    }
    v23 %= 0xFFF1u;
    v7 %= 0xFFF1u;
  }
  return v23 | (v7 << 16);
}

//----- (080B4CAC) --------------------------------------------------------
int __cdecl sub_80B4CAC(int a1, int *a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-54h]
  int v7; // [esp+18h] [ebp-50h]
  int v8; // [esp+1Ch] [ebp-4Ch]
  int v9; // [esp+1Ch] [ebp-4Ch]
  int v10[4]; // [esp+20h] [ebp-48h] BYREF
  int v11; // [esp+30h] [ebp-38h]
  int v12; // [esp+34h] [ebp-34h]
  int v13; // [esp+40h] [ebp-28h]
  int v14; // [esp+44h] [ebp-24h]
  int v15; // [esp+48h] [ebp-20h]

  v10[0] = a3;
  v10[1] = a4;
  v10[3] = a1;
  v11 = *a2;
  if ( v11 != *a2 )
    return -5;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v8 = sub_80B4F44(v10, a5, "1.1.4", 56);
  if ( v8 )
    return v8;
  v9 = sub_80B57C7((int)v10, 4);
  if ( v9 == 1 )
  {
    *a2 = v12;
    v7 = sub_80B5BB0((int)v10);
  }
  else
  {
    sub_80B5BB0((int)v10);
    v6 = v9;
    if ( !v9 )
      v6 = -5;
    v7 = v6;
  }
  return v7;
}

//----- (080B4DCA) --------------------------------------------------------
int __cdecl sub_80B4DCA(int a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v5; // [esp+Ch] [ebp+8h]
  unsigned int v6; // [esp+Ch] [ebp+8h]
  unsigned int v7; // [esp+Ch] [ebp+8h]
  unsigned int v8; // [esp+Ch] [ebp+8h]
  unsigned int v9; // [esp+Ch] [ebp+8h]
  unsigned int v10; // [esp+Ch] [ebp+8h]
  unsigned int v11; // [esp+Ch] [ebp+8h]
  unsigned int v12; // [esp+Ch] [ebp+8h]
  _BYTE *v13; // [esp+10h] [ebp+Ch]

  if ( !a2 )
    return 0;
  v5 = ~a1;
  while ( a3 > 7 )
  {
    v6 = dword_80E40E0[(unsigned __int8)(v5 ^ *a2)] ^ (v5 >> 8);
    v13 = a2 + 1;
    v7 = dword_80E40E0[(unsigned __int8)(v6 ^ *v13++)] ^ (v6 >> 8);
    v8 = dword_80E40E0[(unsigned __int8)(v7 ^ *v13++)] ^ (v7 >> 8);
    v9 = dword_80E40E0[(unsigned __int8)(v8 ^ *v13++)] ^ (v8 >> 8);
    v10 = dword_80E40E0[(unsigned __int8)(v9 ^ *v13++)] ^ (v9 >> 8);
    v11 = dword_80E40E0[(unsigned __int8)(v10 ^ *v13++)] ^ (v10 >> 8);
    v12 = dword_80E40E0[(unsigned __int8)(v11 ^ *v13++)] ^ (v11 >> 8);
    v5 = dword_80E40E0[(unsigned __int8)(v12 ^ *v13)] ^ (v12 >> 8);
    a2 = v13 + 1;
    a3 -= 8;
  }
  for ( ; a3; --a3 )
    v5 = dword_80E40E0[(unsigned __int8)(v5 ^ *a2++)] ^ (v5 >> 8);
  return ~v5;
}

//----- (080B4F44) --------------------------------------------------------
int __cdecl sub_80B4F44(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  return sub_80B4F8C(a1, a2, 8, 15, 8, 0, a3, a4);
}

//----- (080B4F8C) --------------------------------------------------------
int __cdecl sub_80B4F8C(_DWORD *a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7, int a8)
{
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  int v12; // [esp+20h] [ebp-8h]

  v11 = 0;
  if ( !a7 || *a7 != *off_80F09DC || a8 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80C06F2;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80C0709;
  if ( a2 == -1 )
    a2 = 6;
  if ( a4 < 0 )
  {
    v11 = 1;
    a4 = -a4;
  }
  if ( a5 <= 0 || a5 > 9 || a3 != 8 || a4 <= 8 || a4 > 15 || a2 < 0 || a2 > 9 || a6 < 0 || a6 > 2 )
    return -2;
  v12 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 5816);
  if ( !v12 )
    return -4;
  a1[7] = v12;
  *(_DWORD *)v12 = a1;
  *(_DWORD *)(v12 + 24) = v11;
  *(_DWORD *)(v12 + 40) = a4;
  *(_DWORD *)(v12 + 36) = 1 << *(_BYTE *)(v12 + 40);
  *(_DWORD *)(v12 + 44) = *(_DWORD *)(v12 + 36) - 1;
  *(_DWORD *)(v12 + 72) = a5 + 7;
  *(_DWORD *)(v12 + 68) = 1 << *(_BYTE *)(v12 + 72);
  *(_DWORD *)(v12 + 76) = *(_DWORD *)(v12 + 68) - 1;
  *(_DWORD *)(v12 + 80) = (*(_DWORD *)(v12 + 72) + 2) / 3u;
  *(_DWORD *)(v12 + 48) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 56) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 36), 2);
  *(_DWORD *)(v12 + 60) = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 68), 2);
  *(_DWORD *)(v12 + 5780) = 1 << (a5 + 6);
  v10 = ((int (__cdecl *)(_DWORD, _DWORD, int))a1[8])(a1[10], *(_DWORD *)(v12 + 5780), 4);
  *(_DWORD *)(v12 + 8) = v10;
  *(_DWORD *)(v12 + 12) = 4 * *(_DWORD *)(v12 + 5780);
  if ( *(_DWORD *)(v12 + 48) && *(_DWORD *)(v12 + 56) && *(_DWORD *)(v12 + 60) && *(_DWORD *)(v12 + 8) )
  {
    *(_DWORD *)(v12 + 5788) = v10 + 2 * (*(_DWORD *)(v12 + 5780) >> 1);
    *(_DWORD *)(v12 + 5776) = *(_DWORD *)(v12 + 8) + 3 * *(_DWORD *)(v12 + 5780);
    *(_DWORD *)(v12 + 124) = a2;
    *(_DWORD *)(v12 + 128) = a6;
    *(_BYTE *)(v12 + 29) = 8;
    v9 = sub_80B548A(a1);
  }
  else
  {
    a1[6] = off_80F1B98[0];
    sub_80B5BB0((int)a1);
    v9 = -4;
  }
  return v9;
}
// 80F09DC: using guessed type char *off_80F09DC;
// 80F1B98: using guessed type char *off_80F1B98[3];

//----- (080B548A) --------------------------------------------------------
int __cdecl sub_80B548A(_DWORD *a1)
{
  int v2; // [esp+8h] [ebp-10h]
  _DWORD *v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !a1[7] || !a1[8] || !a1[9] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  a1[11] = 2;
  v4 = (_DWORD *)a1[7];
  v4[5] = 0;
  v4[4] = v4[2];
  if ( (int)v4[6] < 0 )
    v4[6] = 0;
  if ( v4[6] )
    v2 = 113;
  else
    v2 = 42;
  v4[1] = v2;
  a1[12] = 1;
  v4[8] = 0;
  sub_80BBA2D((int)v4);
  sub_80B607C((int)v4);
  return 0;
}

//----- (080B56C0) --------------------------------------------------------
int __cdecl sub_80B56C0(int a1, __int16 a2)
{
  int result; // eax

  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(a2);
  result = (unsigned __int8)a2;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = a2;
  return result;
}

//----- (080B56F9) --------------------------------------------------------
size_t __cdecl sub_80B56F9(int a1)
{
  size_t result; // eax
  size_t n; // [esp+14h] [ebp-4h]

  n = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20);
  result = n;
  if ( n > *(_DWORD *)(a1 + 16) )
  {
    result = *(_DWORD *)(a1 + 16);
    n = result;
  }
  if ( n )
  {
    memcpy(*(void **)(a1 + 12), *(const void **)(*(_DWORD *)(a1 + 28) + 16), n);
    *(_DWORD *)(a1 + 12) += n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) += n;
    *(_DWORD *)(a1 + 20) += n;
    *(_DWORD *)(a1 + 16) -= n;
    *(_DWORD *)(*(_DWORD *)(a1 + 28) + 20) -= n;
    result = *(_DWORD *)(a1 + 28);
    if ( !*(_DWORD *)(result + 20) )
    {
      result = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8);
      *(_DWORD *)(*(_DWORD *)(a1 + 28) + 16) = result;
    }
  }
  return result;
}

//----- (080B57C7) --------------------------------------------------------
int __cdecl sub_80B57C7(int a1, int a2)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+14h] [ebp-14h]
  unsigned int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) || a2 > 4 || a2 < 0 )
    return -2;
  v7 = *(_DWORD *)(a1 + 28);
  if ( !*(_DWORD *)(a1 + 12) || !*(_DWORD *)a1 && *(_DWORD *)(a1 + 4) || *(_DWORD *)(v7 + 4) == 666 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_80F1B90[0];
    return -2;
  }
  if ( !*(_DWORD *)(a1 + 16) )
  {
    *(char **)(a1 + 24) = off_80F1B9C[0];
    return -5;
  }
  *(_DWORD *)v7 = a1;
  v8 = *(_DWORD *)(v7 + 32);
  *(_DWORD *)(v7 + 32) = a2;
  if ( *(_DWORD *)(v7 + 4) == 42 )
  {
    v4 = (*(_DWORD *)(v7 + 124) - 1) >> 1;
    if ( v4 > 3 )
      v4 = 3;
    v6 = (v4 << 6) | ((16 * (*(_DWORD *)(v7 + 40) - 8) + 8) << 8);
    if ( *(_DWORD *)(v7 + 100) )
      v6 |= 0x20u;
    *(_DWORD *)(v7 + 4) = 113;
    sub_80B56C0(v7, v6 - v6 % 0x1F + 31);
    if ( *(_DWORD *)(v7 + 100) )
    {
      sub_80B56C0(v7, HIWORD(*(_DWORD *)(a1 + 48)));
      sub_80B56C0(v7, *(_WORD *)(a1 + 48));
    }
    *(_DWORD *)(a1 + 48) = 1;
  }
  if ( *(_DWORD *)(v7 + 20) )
  {
    sub_80B56F9(a1);
    if ( !*(_DWORD *)(a1 + 16) )
    {
      *(_DWORD *)(v7 + 32) = -1;
      return 0;
    }
  }
  else if ( !*(_DWORD *)(a1 + 4) && a2 <= v8 && a2 != 4 )
  {
    *(char **)(a1 + 24) = off_80F1B9C[0];
    return -5;
  }
  if ( *(_DWORD *)(v7 + 4) == 666 && *(_DWORD *)(a1 + 4) )
  {
    *(char **)(a1 + 24) = off_80F1B9C[0];
    return -5;
  }
  if ( !*(_DWORD *)(a1 + 4) && !*(_DWORD *)(v7 + 108) && (!a2 || *(_DWORD *)(v7 + 4) == 666) )
    goto LABEL_51;
  v5 = off_80E4528[3 * *(_DWORD *)(v7 + 124)](v7, a2);
  if ( v5 == 2 || v5 == 3 )
    *(_DWORD *)(v7 + 4) = 666;
  if ( v5 && v5 != 2 )
  {
    if ( v5 == 1 )
    {
      if ( a2 == 1 )
      {
        sub_80BD6BF(v7);
      }
      else
      {
        sub_80BD591(v7, 0, 0, 0);
        if ( a2 == 3 )
        {
          *(_WORD *)(*(_DWORD *)(v7 + 60) + 2 * *(_DWORD *)(v7 + 68) - 2) = 0;
          memset(*(void **)(v7 + 60), 0, 2 * *(_DWORD *)(v7 + 68) - 2);
        }
      }
      sub_80B56F9(a1);
      if ( !*(_DWORD *)(a1 + 16) )
      {
        *(_DWORD *)(v7 + 32) = -1;
        return 0;
      }
    }
LABEL_51:
    if ( a2 != 4 )
      return 0;
    if ( *(_DWORD *)(v7 + 24) )
      return 1;
    sub_80B56C0(v7, HIWORD(*(_DWORD *)(a1 + 48)));
    sub_80B56C0(v7, *(_WORD *)(a1 + 48));
    sub_80B56F9(a1);
    *(_DWORD *)(v7 + 24) = -1;
    return *(_DWORD *)(v7 + 20) == 0;
  }
  if ( !*(_DWORD *)(a1 + 16) )
    *(_DWORD *)(v7 + 32) = -1;
  return 0;
}
// 80F1B90: using guessed type char *off_80F1B90[5];
// 80F1B9C: using guessed type char *off_80F1B9C[2];

//----- (080B5BB0) --------------------------------------------------------
int __cdecl sub_80B5BB0(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+14h] [ebp-4h]

  if ( !a1 || !*(_DWORD *)(a1 + 28) )
    return -2;
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4);
  if ( v4 != 42 && v4 != 113 && v4 != 666 )
    return -2;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 8));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 60));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 56));
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48) )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(*(_DWORD *)(a1 + 28) + 48));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a1 + 28) = 0;
  if ( v4 == 113 )
    v2 = -3;
  else
    v2 = 0;
  return v2;
}

//----- (080B5FC8) --------------------------------------------------------
unsigned int __cdecl sub_80B5FC8(int a1, void *dest, int a3)
{
  unsigned int n; // [esp+10h] [ebp-8h]

  n = *(_DWORD *)(a1 + 4);
  if ( n > a3 )
    n = a3;
  if ( !n )
    return 0;
  *(_DWORD *)(a1 + 4) -= n;
  if ( !*(_DWORD *)(*(_DWORD *)(a1 + 28) + 24) )
    *(_DWORD *)(a1 + 48) = sub_80B4A60(*(_DWORD *)(a1 + 48), *(unsigned __int8 **)a1, n);
  memcpy(dest, *(const void **)a1, n);
  *(_DWORD *)a1 += n;
  *(_DWORD *)(a1 + 8) += n;
  return n;
}

//----- (080B607C) --------------------------------------------------------
int __cdecl sub_80B607C(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 52) = 2 * *(_DWORD *)(a1 + 36);
  *(_WORD *)(*(_DWORD *)(a1 + 60) + 2 * *(_DWORD *)(a1 + 68) - 2) = 0;
  memset(*(void **)(a1 + 60), 0, 2 * *(_DWORD *)(a1 + 68) - 2);
  *(_DWORD *)(a1 + 120) = (unsigned __int16)word_80E4522[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 132) = (unsigned __int16)word_80E4520[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 136) = (unsigned __int16)word_80E4524[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 116) = (unsigned __int16)word_80E4526[6 * *(_DWORD *)(a1 + 124)];
  *(_DWORD *)(a1 + 100) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 112) = 2;
  *(_DWORD *)(a1 + 88) = 2;
  *(_DWORD *)(a1 + 96) = 0;
  result = a1;
  *(_DWORD *)(a1 + 64) = 0;
  return result;
}
// 80E4520: using guessed type __int16 word_80E4520[];
// 80E4522: using guessed type __int16 word_80E4522[];
// 80E4524: using guessed type __int16 word_80E4524[];
// 80E4526: using guessed type __int16 word_80E4526[];

//----- (080B6189) --------------------------------------------------------
int __cdecl sub_80B6189(_DWORD *a1, unsigned int a2)
{
  char v3; // [esp+2h] [ebp-32h]
  char v4; // [esp+3h] [ebp-31h]
  unsigned int v5; // [esp+4h] [ebp-30h]
  unsigned int v6; // [esp+8h] [ebp-2Ch]
  int v7; // [esp+Ch] [ebp-28h]
  _BYTE *v8; // [esp+10h] [ebp-24h]
  _BYTE *v9; // [esp+10h] [ebp-24h]
  _BYTE *v10; // [esp+10h] [ebp-24h]
  _BYTE *v11; // [esp+10h] [ebp-24h]
  _BYTE *v12; // [esp+10h] [ebp-24h]
  _BYTE *v13; // [esp+10h] [ebp-24h]
  _BYTE *v14; // [esp+10h] [ebp-24h]
  _BYTE *v15; // [esp+10h] [ebp-24h]
  _BYTE *v16; // [esp+10h] [ebp-24h]
  _BYTE *v17; // [esp+10h] [ebp-24h]
  _BYTE *v18; // [esp+14h] [ebp-20h]
  _BYTE *v19; // [esp+14h] [ebp-20h]
  int v20; // [esp+18h] [ebp-1Ch]
  int v21; // [esp+1Ch] [ebp-18h]
  int v22; // [esp+20h] [ebp-14h]
  int v23; // [esp+28h] [ebp-Ch]
  int v24; // [esp+2Ch] [ebp-8h]
  unsigned int v25; // [esp+30h] [ebp-4h]

  v25 = a1[29];
  v18 = (_BYTE *)(a1[25] + a1[12]);
  v24 = a1[28];
  v23 = a1[34];
  if ( a1[25] <= (unsigned int)(a1[9] - 262) )
    v6 = 0;
  else
    v6 = a1[25] - a1[9] + 262;
  v22 = a1[14];
  v21 = a1[11];
  v5 = a1[25] + a1[12] + 258;
  v4 = v18[v24 - 1];
  v3 = v18[v24];
  if ( a1[28] >= a1[33] )
    v25 >>= 2;
  if ( (unsigned int)v23 > a1[27] )
    v23 = a1[27];
  do
  {
    v8 = (_BYTE *)(a2 + a1[12]);
    if ( v8[v24] == v3 && v8[v24 - 1] == v4 && *v8 == *v18 )
    {
      v9 = v8 + 1;
      if ( *v9 == v18[1] )
      {
        v19 = v18 + 2;
        v10 = v9 + 1;
        do
        {
          ++v19;
          v11 = v10 + 1;
          if ( *v19 != *v11 )
            break;
          ++v19;
          v12 = v11 + 1;
          if ( *v19 != *v12 )
            break;
          ++v19;
          v13 = v12 + 1;
          if ( *v19 != *v13 )
            break;
          ++v19;
          v14 = v13 + 1;
          if ( *v19 != *v14 )
            break;
          ++v19;
          v15 = v14 + 1;
          if ( *v19 != *v15 )
            break;
          ++v19;
          v16 = v15 + 1;
          if ( *v19 != *v16 )
            break;
          ++v19;
          v17 = v16 + 1;
          if ( *v19 != *v17 )
            break;
          ++v19;
          v10 = v17 + 1;
          if ( *v19 != *v10 )
            break;
        }
        while ( (unsigned int)v19 < v5 );
        v7 = 258 - (v5 - (_DWORD)v19);
        v18 = (_BYTE *)(v5 - 258);
        if ( v7 > v24 )
        {
          a1[26] = a2;
          v24 = v7;
          if ( v7 >= v23 )
            break;
          v4 = v18[v7 - 1];
          v3 = v18[v7];
        }
      }
    }
    a2 = *(unsigned __int16 *)(v22 + 2 * (a2 & v21));
    if ( a2 <= v6 )
      break;
    --v25;
  }
  while ( v25 );
  if ( (unsigned int)v24 > a1[27] )
    v20 = a1[27];
  else
    v20 = v24;
  return v20;
}

//----- (080B6413) --------------------------------------------------------
int __cdecl sub_80B6413(int a1)
{
  int result; // eax
  __int16 v2; // [esp+10h] [ebp-48h]
  __int16 v3; // [esp+20h] [ebp-38h]
  _WORD *v4; // [esp+3Ch] [ebp-1Ch]
  _WORD *v5; // [esp+3Ch] [ebp-1Ch]
  unsigned int v6; // [esp+40h] [ebp-18h]
  unsigned int v7; // [esp+40h] [ebp-18h]
  int v8; // [esp+44h] [ebp-14h]
  size_t v9; // [esp+44h] [ebp-14h]
  size_t n; // [esp+48h] [ebp-10h]
  int v11; // [esp+4Ch] [ebp-Ch]

  n = *(_DWORD *)(a1 + 36);
  do
  {
    v11 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 108) - *(_DWORD *)(a1 + 100);
    if ( v11 || *(_DWORD *)(a1 + 100) || *(_DWORD *)(a1 + 108) )
    {
      if ( v11 == -1 )
      {
        v11 = -2;
      }
      else if ( *(_DWORD *)(a1 + 100) >= n + *(_DWORD *)(a1 + 36) - 262 )
      {
        memcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + n), n);
        *(_DWORD *)(a1 + 104) -= n;
        *(_DWORD *)(a1 + 100) -= n;
        *(_DWORD *)(a1 + 84) -= n;
        v8 = *(_DWORD *)(a1 + 68);
        v4 = (_WORD *)(2 * v8 + *(_DWORD *)(a1 + 60));
        do
        {
          v6 = (unsigned __int16)*--v4;
          if ( v6 < n )
            v3 = 0;
          else
            v3 = v6 - n;
          *v4 = v3;
          --v8;
        }
        while ( v8 );
        v9 = n;
        v5 = (_WORD *)(2 * n + *(_DWORD *)(a1 + 56));
        do
        {
          v7 = (unsigned __int16)*--v5;
          if ( v7 < n )
            v2 = 0;
          else
            v2 = v7 - n;
          *v5 = v2;
          --v9;
        }
        while ( v9 );
        v11 += n;
      }
    }
    else
    {
      v11 = n;
    }
    result = *(_DWORD *)a1;
    if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    *(_DWORD *)(a1 + 108) += sub_80B5FC8(
                               *(_DWORD *)a1,
                               (void *)(*(_DWORD *)(a1 + 108) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48)),
                               v11);
    if ( *(_DWORD *)(a1 + 108) > 2u )
    {
      *(_DWORD *)(a1 + 64) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100));
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 76) & (*(unsigned __int8 *)(*(_DWORD *)(a1 + 48)
                                                                        + *(_DWORD *)(a1 + 100)
                                                                        + 1) ^ (*(_DWORD *)(a1 + 64) << *(_BYTE *)(a1 + 80)));
    }
    result = a1;
    if ( *(_DWORD *)(a1 + 108) > 0x105u )
      break;
    result = *(_DWORD *)a1;
  }
  while ( *(_DWORD *)(*(_DWORD *)a1 + 4) );
  return result;
}

//----- (080B6664) --------------------------------------------------------
int __cdecl sub_80B6664(int *a1, int a2)
{
  int v3; // [esp+8h] [ebp-30h]
  int v4; // [esp+8h] [ebp-30h]
  int v5; // [esp+8h] [ebp-30h]
  int v6; // [esp+Ch] [ebp-2Ch]
  int v7; // [esp+18h] [ebp-20h]
  int v8; // [esp+1Ch] [ebp-1Ch]
  int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  int v11; // [esp+34h] [ebp-4h]

  v11 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v11 = a1[3] - 5;
  while ( 1 )
  {
    if ( (unsigned int)a1[27] <= 1 )
    {
      sub_80B6413((int)a1);
      if ( !a1[27] && !a2 )
        return 0;
      if ( !a1[27] )
        break;
    }
    a1[25] += a1[27];
    a1[27] = 0;
    v10 = a1[21] + v11;
    if ( !a1[25] || a1[25] >= v10 )
    {
      a1[27] = a1[25] - v10;
      a1[25] = v10;
      v3 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80BDB2D((int)a1, 0, v3, 0);
      else
        sub_80BDB2D((int)a1, (_BYTE *)(a1[21] + a1[12]), v3, 0);
      a1[21] = a1[25];
      sub_80B56F9(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
    if ( a1[25] - a1[21] >= (unsigned int)(a1[9] - 262) )
    {
      v4 = a1[25] - a1[21];
      if ( a1[21] < 0 )
        sub_80BDB2D((int)a1, 0, v4, 0);
      else
        sub_80BDB2D((int)a1, (_BYTE *)(a1[21] + a1[12]), v4, 0);
      a1[21] = a1[25];
      sub_80B56F9(*a1);
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
  }
  v6 = a2 == 4;
  v5 = a1[25] - a1[21];
  if ( a1[21] < 0 )
    sub_80BDB2D((int)a1, 0, v5, v6);
  else
    sub_80BDB2D((int)a1, (_BYTE *)(a1[21] + a1[12]), v5, v6);
  a1[21] = a1[25];
  sub_80B56F9(*a1);
  if ( *(_DWORD *)(*a1 + 16) )
  {
    if ( a2 == 4 )
      v7 = 3;
    else
      v7 = 1;
    v9 = v7;
  }
  else
  {
    if ( a2 == 4 )
      v8 = 2;
    else
      v8 = 0;
    v9 = v8;
  }
  return v9;
}

//----- (080B7608) --------------------------------------------------------
int __cdecl sub_80B7608(int a1, int a2, _DWORD *a3)
{
  int v3; // eax
  int result; // eax

  if ( a3 )
    *a3 = *(_DWORD *)(a1 + 60);
  if ( *(_DWORD *)a1 == 4 || *(_DWORD *)a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
  if ( *(_DWORD *)a1 == 6 )
    sub_80B9AFA(*(_DWORD *)(a1 + 4), a2);
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  v3 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a1 + 52) = v3;
  *(_DWORD *)(a1 + 48) = v3;
  result = a1;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, _DWORD, _DWORD))(a1 + 56))(0, 0, 0);
    result = *(_DWORD *)(a1 + 60);
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

//----- (080B76D8) --------------------------------------------------------
_DWORD *__cdecl sub_80B76D8(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = (_DWORD *)(*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  if ( !v5 )
    return 0;
  v5[9] = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
  if ( v5[9] )
  {
    v5[10] = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
    if ( v5[10] )
    {
      v5[11] = v5[10] + a3;
      v5[14] = a2;
      *v5 = 0;
      sub_80B7608((int)v5, a1, 0);
      v4 = v5;
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v5[9]);
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
      v4 = 0;
    }
  }
  else
  {
    (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v5);
    v4 = 0;
  }
  return v4;
}

//----- (080B781A) --------------------------------------------------------
int __cdecl sub_80B781A(int a1, int a2, int a3)
{
  int v4; // [esp+28h] [ebp-80h]
  int v5; // [esp+2Ch] [ebp-7Ch]
  unsigned int v6; // [esp+30h] [ebp-78h]
  unsigned int v7; // [esp+34h] [ebp-74h]
  int v8; // [esp+38h] [ebp-70h]
  int v9; // [esp+3Ch] [ebp-6Ch]
  int v10; // [esp+44h] [ebp-64h]
  int v11; // [esp+48h] [ebp-60h]
  int v12; // [esp+4Ch] [ebp-5Ch]
  int v13; // [esp+50h] [ebp-58h]
  size_t v14; // [esp+58h] [ebp-50h]
  int v15; // [esp+5Ch] [ebp-4Ch]
  int v17; // [esp+64h] [ebp-44h]
  unsigned int v18; // [esp+68h] [ebp-40h] BYREF
  unsigned int v19; // [esp+6Ch] [ebp-3Ch] BYREF
  int v20; // [esp+70h] [ebp-38h] BYREF
  int v21; // [esp+74h] [ebp-34h] BYREF
  int v22; // [esp+78h] [ebp-30h] BYREF
  int v23; // [esp+7Ch] [ebp-2Ch] BYREF
  int v24; // [esp+80h] [ebp-28h] BYREF
  int v25; // [esp+84h] [ebp-24h] BYREF
  size_t v26; // [esp+88h] [ebp-20h]
  void *dest; // [esp+8Ch] [ebp-1Ch]
  size_t v28; // [esp+90h] [ebp-18h]
  void *src; // [esp+94h] [ebp-14h]
  size_t v30; // [esp+98h] [ebp-10h]
  unsigned int v31; // [esp+9Ch] [ebp-Ch]
  size_t n; // [esp+A0h] [ebp-8h]
  int v33; // [esp+B8h] [ebp+10h]
  int v34; // [esp+B8h] [ebp+10h]

  src = *(void **)a2;
  v28 = *(_DWORD *)(a2 + 4);
  v31 = *(_DWORD *)(a1 + 32);
  v30 = *(_DWORD *)(a1 + 28);
  dest = *(void **)(a1 + 52);
  if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
    v15 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
  else
    v15 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
  v26 = v15;
  while ( 1 )
  {
    if ( *(_DWORD *)a1 > 9u )
    {
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80BB834(a1, (_DWORD *)a2, -2);
    }
    switch ( *(_DWORD *)a1 )
    {
      case 0:
        while ( v30 <= 2 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        n = v31 & 7;
        *(_DWORD *)(a1 + 24) = v31 & 1;
        v14 = n >> 1;
        if ( n >> 1 == 1 )
        {
          sub_80BB801(&v25, &v24, &v23, &v22);
          *(_DWORD *)(a1 + 4) = sub_80B8D28(v25, v24, v23, v22, a2);
          if ( !*(_DWORD *)(a1 + 4) )
            goto LABEL_119;
          v31 >>= 3;
          v30 -= 3;
          *(_DWORD *)a1 = 6;
          continue;
        }
        if ( !v14 )
        {
          v31 >>= 3;
          v30 -= 3;
          n = v30 & 7;
          v31 >>= n;
          v30 -= n;
          *(_DWORD *)a1 = 1;
          continue;
        }
        if ( v14 == 2 )
        {
          v31 >>= 3;
          v30 -= 3;
          *(_DWORD *)a1 = 3;
          continue;
        }
        if ( v14 != 3 )
          continue;
        v31 >>= 3;
        v30 -= 3;
        *(_DWORD *)a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid block type";
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80BB834(a1, (_DWORD *)a2, -3);
      case 1:
        while ( v30 <= 0x1F )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        if ( ~v31 >> 16 == (unsigned __int16)v31 )
        {
          *(_DWORD *)(a1 + 4) = (unsigned __int16)v31;
          v30 = 0;
          v31 = 0;
          if ( *(_DWORD *)(a1 + 4) )
          {
            v13 = 2;
          }
          else if ( *(_DWORD *)(a1 + 24) )
          {
            v13 = 7;
          }
          else
          {
            v13 = 0;
          }
          *(_DWORD *)a1 = v13;
          continue;
        }
        *(_DWORD *)a1 = 9;
        *(_DWORD *)(a2 + 24) = "invalid stored block lengths";
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80BB834(a1, (_DWORD *)a2, -3);
      case 2:
        if ( !v28 )
          goto LABEL_53;
        if ( !v26 )
        {
          if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
          {
            dest = *(void **)(a1 + 40);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v12 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v12 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v12;
          }
          if ( !v26 )
          {
            *(_DWORD *)(a1 + 52) = dest;
            a3 = sub_80BB834(a1, (_DWORD *)a2, a3);
            dest = *(void **)(a1 + 52);
            if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
              v11 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
            else
              v11 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
            v26 = v11;
            if ( dest == *(void **)(a1 + 44) && *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 40) )
            {
              dest = *(void **)(a1 + 40);
              if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
                v10 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
              else
                v10 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
              v26 = v10;
            }
            if ( !v26 )
              goto LABEL_53;
          }
        }
        a3 = 0;
        n = *(_DWORD *)(a1 + 4);
        if ( n > v28 )
          n = v28;
        if ( n > v26 )
          n = v26;
        memcpy(dest, src, n);
        src = (char *)src + n;
        v28 -= n;
        dest = (char *)dest + n;
        v26 -= n;
        *(_DWORD *)(a1 + 4) -= n;
        if ( !*(_DWORD *)(a1 + 4) )
        {
          if ( *(_DWORD *)(a1 + 24) )
            v9 = 7;
          else
            v9 = 0;
          *(_DWORD *)a1 = v9;
        }
        continue;
      case 3:
        break;
      case 4:
        goto LABEL_72;
      case 5:
        goto LABEL_85;
      case 6:
        goto LABEL_121;
      case 7:
        goto LABEL_129;
      case 8:
        goto LABEL_135;
      case 9:
        *(_DWORD *)(a1 + 32) = v31;
        *(_DWORD *)(a1 + 28) = v30;
        *(_DWORD *)(a2 + 4) = v28;
        *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
        *(_DWORD *)a2 = src;
        *(_DWORD *)(a1 + 52) = dest;
        return sub_80BB834(a1, (_DWORD *)a2, -3);
    }
    while ( v30 <= 0xD )
    {
      if ( !v28 )
        goto LABEL_53;
      a3 = 0;
      --v28;
      v31 |= *(unsigned __int8 *)src << v30;
      src = (char *)src + 1;
      v30 += 8;
    }
    n = v31 & 0x3FFF;
    *(_DWORD *)(a1 + 4) = n;
    if ( (n & 0x1F) > 0x1D || ((n >> 5) & 0x1F) > 0x1D )
    {
      *(_DWORD *)a1 = 9;
      *(_DWORD *)(a2 + 24) = "too many length or distance symbols";
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80BB834(a1, (_DWORD *)a2, -3);
    }
    n = ((n >> 5) & 0x1F) + (n & 0x1F) + 258;
    *(_DWORD *)(a1 + 12) = (*(int (__cdecl **)(_DWORD, size_t, int))(a2 + 32))(*(_DWORD *)(a2 + 40), n, 4);
    if ( !*(_DWORD *)(a1 + 12) )
      goto LABEL_119;
    v31 >>= 14;
    v30 -= 14;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 4;
LABEL_72:
    while ( *(_DWORD *)(a1 + 8) < (unsigned int)((*(_DWORD *)(a1 + 4) >> 10) + 4) )
    {
      while ( v30 <= 2 )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *(unsigned __int8 *)src << v30;
        src = (char *)src + 1;
        v30 += 8;
      }
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_80E45A0[(*(_DWORD *)(a1 + 8))++]) = v31 & 7;
      v31 >>= 3;
      v30 -= 3;
    }
    while ( *(_DWORD *)(a1 + 8) <= 0x12u )
      *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * dword_80E45A0[(*(_DWORD *)(a1 + 8))++]) = 0;
    *(_DWORD *)(a1 + 16) = 7;
    n = sub_80BB535(*(_DWORD **)(a1 + 12), (unsigned int *)(a1 + 16), (_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 36), a2);
    if ( n )
    {
      a3 = n;
      if ( n == -3 )
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
        *(_DWORD *)a1 = 9;
      }
LABEL_53:
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80BB834(a1, (_DWORD *)a2, a3);
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)a1 = 5;
LABEL_85:
    while ( 1 )
    {
      n = *(_DWORD *)(a1 + 4);
      if ( *(_DWORD *)(a1 + 8) >= ((n >> 5) & 0x1F) + (n & 0x1F) + 258 )
        break;
      n = *(_DWORD *)(a1 + 16);
      while ( v30 < n )
      {
        if ( !v28 )
          goto LABEL_53;
        a3 = 0;
        --v28;
        v31 |= *(unsigned __int8 *)src << v30;
        src = (char *)src + 1;
        v30 += 8;
      }
      v21 = *(_DWORD *)(a1 + 20) + 8 * (v31 & dword_80F1B00[n]);
      n = *(unsigned __int8 *)(v21 + 1);
      v18 = *(_DWORD *)(v21 + 4);
      if ( v18 > 0xF )
      {
        if ( v18 == 18 )
          v8 = 7;
        else
          v8 = v18 - 14;
        v20 = v8;
        if ( v18 == 18 )
          v7 = 11;
        else
          v7 = 3;
        v19 = v7;
        while ( v30 < n + v20 )
        {
          if ( !v28 )
            goto LABEL_53;
          a3 = 0;
          --v28;
          v31 |= *(unsigned __int8 *)src << v30;
          src = (char *)src + 1;
          v30 += 8;
        }
        v31 >>= n;
        v30 -= n;
        v19 += dword_80F1B00[v20] & v31;
        v31 >>= v20;
        v30 -= v20;
        v20 = *(_DWORD *)(a1 + 8);
        n = *(_DWORD *)(a1 + 4);
        if ( v19 + v20 > ((n >> 5) & 0x1F) + (n & 0x1F) + 258 || v18 == 16 && !v20 )
        {
          (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
          *(_DWORD *)a1 = 9;
          *(_DWORD *)(a2 + 24) = "invalid bit length repeat";
          *(_DWORD *)(a1 + 32) = v31;
          *(_DWORD *)(a1 + 28) = v30;
          *(_DWORD *)(a2 + 4) = v28;
          *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
          *(_DWORD *)a2 = src;
          *(_DWORD *)(a1 + 52) = dest;
          return sub_80BB834(a1, (_DWORD *)a2, -3);
        }
        if ( v18 == 16 )
          v6 = *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20 - 4);
        else
          v6 = 0;
        v18 = v6;
        do
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * v20++) = v18;
          --v19;
        }
        while ( v19 );
        *(_DWORD *)(a1 + 8) = v20;
      }
      else
      {
        v31 >>= n;
        v30 -= n;
        *(_DWORD *)(*(_DWORD *)(a1 + 12) + 4 * (*(_DWORD *)(a1 + 8))++) = v18;
      }
    }
    *(_DWORD *)(a1 + 20) = 0;
    v18 = 9;
    v19 = 6;
    n = *(_DWORD *)(a1 + 4);
    n = sub_80BB61E(
          (n & 0x1F) + 257,
          ((n >> 5) & 0x1F) + 1,
          *(_DWORD **)(a1 + 12),
          &v18,
          &v19,
          &v20,
          &v21,
          *(_DWORD *)(a1 + 36),
          a2);
    if ( n )
    {
      if ( n == -3 )
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
        *(_DWORD *)a1 = 9;
      }
      v33 = n;
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80BB834(a1, (_DWORD *)a2, v33);
    }
    v17 = sub_80B8D28(v18, v19, v20, v21, a2);
    if ( !v17 )
    {
LABEL_119:
      *(_DWORD *)(a1 + 32) = v31;
      *(_DWORD *)(a1 + 28) = v30;
      *(_DWORD *)(a2 + 4) = v28;
      *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
      *(_DWORD *)a2 = src;
      *(_DWORD *)(a1 + 52) = dest;
      return sub_80BB834(a1, (_DWORD *)a2, -4);
    }
    *(_DWORD *)(a1 + 4) = v17;
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 12));
    *(_DWORD *)a1 = 6;
LABEL_121:
    *(_DWORD *)(a1 + 32) = v31;
    *(_DWORD *)(a1 + 28) = v30;
    *(_DWORD *)(a2 + 4) = v28;
    *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
    *(_DWORD *)a2 = src;
    *(_DWORD *)(a1 + 52) = dest;
    v34 = sub_80B8D8D((_DWORD *)a1, (_DWORD *)a2, a3);
    if ( v34 != 1 )
      return sub_80BB834(a1, (_DWORD *)a2, v34);
    a3 = 0;
    sub_80B9AFA(*(_DWORD *)(a1 + 4), a2);
    src = *(void **)a2;
    v28 = *(_DWORD *)(a2 + 4);
    v31 = *(_DWORD *)(a1 + 32);
    v30 = *(_DWORD *)(a1 + 28);
    dest = *(void **)(a1 + 52);
    v5 = (unsigned int)dest >= *(_DWORD *)(a1 + 48) ? *(_DWORD *)(a1 + 44) - (_DWORD)dest : *(_DWORD *)(a1 + 48)
                                                                                          - (_DWORD)dest
                                                                                          - 1;
    v26 = v5;
    if ( *(_DWORD *)(a1 + 24) )
      break;
    *(_DWORD *)a1 = 0;
  }
  *(_DWORD *)a1 = 7;
LABEL_129:
  *(_DWORD *)(a1 + 52) = dest;
  a3 = sub_80BB834(a1, (_DWORD *)a2, a3);
  dest = *(void **)(a1 + 52);
  if ( (unsigned int)dest >= *(_DWORD *)(a1 + 48) )
    v4 = *(_DWORD *)(a1 + 44) - (_DWORD)dest;
  else
    v4 = *(_DWORD *)(a1 + 48) - (_DWORD)dest - 1;
  v26 = v4;
  if ( *(_DWORD *)(a1 + 48) != *(_DWORD *)(a1 + 52) )
    goto LABEL_53;
  *(_DWORD *)a1 = 8;
LABEL_135:
  *(_DWORD *)(a1 + 32) = v31;
  *(_DWORD *)(a1 + 28) = v30;
  *(_DWORD *)(a2 + 4) = v28;
  *(_DWORD *)(a2 + 8) += (char *)src - *(_DWORD *)a2;
  *(_DWORD *)a2 = src;
  *(_DWORD *)(a1 + 52) = dest;
  return sub_80BB834(a1, (_DWORD *)a2, 1);
}

//----- (080B8C61) --------------------------------------------------------
int __cdecl sub_80B8C61(int a1, int a2)
{
  sub_80B7608(a1, a2, 0);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 40));
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), *(_DWORD *)(a1 + 36));
  (*(void (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

//----- (080B8CD6) --------------------------------------------------------
int __cdecl sub_80B8CD6(int a1, void *src, size_t n)
{
  int result; // eax

  memcpy(*(void **)(a1 + 40), src, n);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40) + n;
  result = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 48) = result;
  return result;
}

//----- (080B8D17) --------------------------------------------------------
_BOOL4 __cdecl sub_80B8D17(_DWORD *a1)
{
  return *a1 == 1;
}

//----- (080B8D28) --------------------------------------------------------
int __cdecl sub_80B8D28(char a1, char a2, int a3, int a4, int a5)
{
  int v6; // [esp+14h] [ebp-4h]

  v6 = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( v6 )
  {
    *(_DWORD *)v6 = 0;
    *(_BYTE *)(v6 + 16) = a1;
    *(_BYTE *)(v6 + 17) = a2;
    *(_DWORD *)(v6 + 20) = a3;
    *(_DWORD *)(v6 + 24) = a4;
  }
  return v6;
}

//----- (080B8D8D) --------------------------------------------------------
int __cdecl sub_80B8D8D(_DWORD *a1, _DWORD *a2, int a3)
{
  int v4; // [esp+2Ch] [ebp-5Ch]
  int v5; // [esp+30h] [ebp-58h]
  int v6; // [esp+34h] [ebp-54h]
  int v7; // [esp+38h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-4Ch]
  int v9; // [esp+40h] [ebp-48h]
  int v10; // [esp+44h] [ebp-44h]
  int v11; // [esp+4Ch] [ebp-3Ch]
  int v12; // [esp+50h] [ebp-38h]
  int v14; // [esp+58h] [ebp-30h]
  _BYTE *i; // [esp+5Ch] [ebp-2Ch]
  unsigned int v16; // [esp+60h] [ebp-28h]
  _BYTE *v17; // [esp+64h] [ebp-24h]
  unsigned int v18; // [esp+68h] [ebp-20h]
  unsigned __int8 *v19; // [esp+6Ch] [ebp-1Ch]
  unsigned int v20; // [esp+70h] [ebp-18h]
  unsigned int v21; // [esp+74h] [ebp-14h]
  int v22; // [esp+78h] [ebp-10h]
  int v23; // [esp+78h] [ebp-10h]
  unsigned __int8 *v24; // [esp+7Ch] [ebp-Ch]
  unsigned __int8 *v25; // [esp+7Ch] [ebp-Ch]
  unsigned int v26; // [esp+80h] [ebp-8h]
  unsigned int v27; // [esp+80h] [ebp-8h]
  unsigned int v28; // [esp+80h] [ebp-8h]
  unsigned int v29; // [esp+80h] [ebp-8h]
  int v30; // [esp+98h] [ebp+10h]

  v14 = a1[1];
  v19 = (unsigned __int8 *)*a2;
  v18 = a2[1];
  v21 = a1[8];
  v20 = a1[7];
  v17 = (_BYTE *)a1[13];
  if ( (unsigned int)v17 >= a1[12] )
    v12 = a1[11] - (_DWORD)v17;
  else
    v12 = a1[12] - (_DWORD)v17 - 1;
  v16 = v12;
  while ( 2 )
  {
    if ( *(_DWORD *)v14 > 9u )
    {
      a1[8] = v21;
      a1[7] = v20;
      a2[1] = v18;
      a2[2] += &v19[-*a2];
      *a2 = v19;
      a1[13] = v17;
      return sub_80BB834((int)a1, a2, -2);
    }
    switch ( *(_DWORD *)v14 )
    {
      case 0:
        if ( v16 <= 0x101 || v18 <= 9 )
          goto LABEL_17;
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        a3 = sub_80B9B1C(
               *(unsigned __int8 *)(v14 + 16),
               *(unsigned __int8 *)(v14 + 17),
               *(_DWORD *)(v14 + 20),
               *(_DWORD *)(v14 + 24),
               a1,
               a2);
        v19 = (unsigned __int8 *)*a2;
        v18 = a2[1];
        v21 = a1[8];
        v20 = a1[7];
        v17 = (_BYTE *)a1[13];
        v11 = (unsigned int)v17 >= a1[12] ? a1[11] - (_DWORD)v17 : a1[12] - (_DWORD)v17 - 1;
        v16 = v11;
        if ( !a3 )
        {
LABEL_17:
          *(_DWORD *)(v14 + 12) = *(unsigned __int8 *)(v14 + 16);
          *(_DWORD *)(v14 + 8) = *(_DWORD *)(v14 + 20);
          *(_DWORD *)v14 = 1;
          goto LABEL_18;
        }
        if ( a3 == 1 )
          v10 = 7;
        else
          v10 = 9;
        *(_DWORD *)v14 = v10;
        continue;
      case 1:
LABEL_18:
        v26 = *(_DWORD *)(v14 + 12);
        while ( 2 )
        {
          if ( v20 < v26 )
          {
            if ( v18 )
            {
              a3 = 0;
              --v18;
              v21 |= *v19++ << v20;
              v20 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        v24 = (unsigned __int8 *)(*(_DWORD *)(v14 + 8) + 8 * (v21 & dword_80F1B00[v26]));
        v21 >>= v24[1];
        v20 -= v24[1];
        v22 = *v24;
        if ( *v24 )
        {
          if ( (v22 & 0x10) != 0 )
          {
            *(_DWORD *)(v14 + 8) = v22 & 0xF;
            *(_DWORD *)(v14 + 4) = *((_DWORD *)v24 + 1);
            *(_DWORD *)v14 = 2;
          }
          else if ( (v22 & 0x40) != 0 )
          {
            if ( (v22 & 0x20) == 0 )
            {
              *(_DWORD *)v14 = 9;
              a2[6] = "invalid literal/length code";
              a1[8] = v21;
              a1[7] = v20;
              a2[1] = v18;
              a2[2] += &v19[-*a2];
              *a2 = v19;
              a1[13] = v17;
              return sub_80BB834((int)a1, a2, -3);
            }
            *(_DWORD *)v14 = 7;
          }
          else
          {
            *(_DWORD *)(v14 + 12) = v22;
            *(_DWORD *)(v14 + 8) = &v24[8 * *((_DWORD *)v24 + 1)];
          }
        }
        else
        {
          *(_DWORD *)(v14 + 8) = *((_DWORD *)v24 + 1);
          *(_DWORD *)v14 = 6;
        }
        continue;
      case 2:
        v27 = *(_DWORD *)(v14 + 8);
        while ( 2 )
        {
          if ( v20 < v27 )
          {
            if ( v18 )
            {
              a3 = 0;
              --v18;
              v21 |= *v19++ << v20;
              v20 += 8;
              continue;
            }
            goto LABEL_52;
          }
          break;
        }
        *(_DWORD *)(v14 + 4) += v21 & dword_80F1B00[v27];
        v21 >>= v27;
        v20 -= v27;
        *(_DWORD *)(v14 + 12) = *(unsigned __int8 *)(v14 + 17);
        *(_DWORD *)(v14 + 8) = *(_DWORD *)(v14 + 24);
        *(_DWORD *)v14 = 3;
LABEL_38:
        v28 = *(_DWORD *)(v14 + 12);
        while ( v20 < v28 )
        {
          if ( !v18 )
            goto LABEL_52;
          a3 = 0;
          --v18;
          v21 |= *v19++ << v20;
          v20 += 8;
        }
        v25 = (unsigned __int8 *)(*(_DWORD *)(v14 + 8) + 8 * (v21 & dword_80F1B00[v28]));
        v21 >>= v25[1];
        v20 -= v25[1];
        v23 = *v25;
        if ( (v23 & 0x10) != 0 )
        {
          *(_DWORD *)(v14 + 8) = v23 & 0xF;
          *(_DWORD *)(v14 + 12) = *((_DWORD *)v25 + 1);
          *(_DWORD *)v14 = 4;
        }
        else
        {
          if ( (v23 & 0x40) != 0 )
          {
            *(_DWORD *)v14 = 9;
            a2[6] = "invalid distance code";
            a1[8] = v21;
            a1[7] = v20;
            a2[1] = v18;
            a2[2] += &v19[-*a2];
            *a2 = v19;
            a1[13] = v17;
            return sub_80BB834((int)a1, a2, -3);
          }
          *(_DWORD *)(v14 + 12) = v23;
          *(_DWORD *)(v14 + 8) = &v25[8 * *((_DWORD *)v25 + 1)];
        }
        continue;
      case 3:
        goto LABEL_38;
      case 4:
        v29 = *(_DWORD *)(v14 + 8);
LABEL_49:
        if ( v20 >= v29 )
        {
          *(_DWORD *)(v14 + 12) += v21 & dword_80F1B00[v29];
          v21 >>= v29;
          v20 -= v29;
          *(_DWORD *)v14 = 5;
LABEL_54:
          for ( i = &v17[-*(_DWORD *)(v14 + 12)]; (unsigned int)i < a1[10]; i += a1[11] - a1[10] )
            ;
          while ( *(_DWORD *)(v14 + 4) )
          {
            if ( !v16 )
            {
              if ( v17 == (_BYTE *)a1[11] && a1[12] != a1[10] )
              {
                v17 = (_BYTE *)a1[10];
                if ( (unsigned int)v17 >= a1[12] )
                  v9 = a1[11] - (_DWORD)v17;
                else
                  v9 = a1[12] - (_DWORD)v17 - 1;
                v16 = v9;
              }
              if ( !v16 )
              {
                a1[13] = v17;
                v30 = sub_80BB834((int)a1, a2, a3);
                v17 = (_BYTE *)a1[13];
                if ( (unsigned int)v17 >= a1[12] )
                  v8 = a1[11] - (_DWORD)v17;
                else
                  v8 = a1[12] - (_DWORD)v17 - 1;
                v16 = v8;
                if ( v17 == (_BYTE *)a1[11] && a1[12] != a1[10] )
                {
                  v17 = (_BYTE *)a1[10];
                  if ( (unsigned int)v17 >= a1[12] )
                    v7 = a1[11] - (_DWORD)v17;
                  else
                    v7 = a1[12] - (_DWORD)v17 - 1;
                  v16 = v7;
                }
                if ( !v16 )
                {
LABEL_99:
                  a1[8] = v21;
                  a1[7] = v20;
                  a2[1] = v18;
                  a2[2] += &v19[-*a2];
                  *a2 = v19;
                  a1[13] = v17;
                  return sub_80BB834((int)a1, a2, v30);
                }
              }
            }
            a3 = 0;
            *v17++ = *i++;
            --v16;
            if ( i == (_BYTE *)a1[11] )
              i = (_BYTE *)a1[10];
            --*(_DWORD *)(v14 + 4);
          }
          *(_DWORD *)v14 = 0;
          continue;
        }
        if ( v18 )
        {
          a3 = 0;
          --v18;
          v21 |= *v19++ << v20;
          v20 += 8;
          goto LABEL_49;
        }
LABEL_52:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = 0;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80BB834((int)a1, a2, a3);
      case 5:
        goto LABEL_54;
      case 6:
        if ( !v16 )
        {
          if ( v17 == (_BYTE *)a1[11] && a1[12] != a1[10] )
          {
            v17 = (_BYTE *)a1[10];
            if ( (unsigned int)v17 >= a1[12] )
              v6 = a1[11] - (_DWORD)v17;
            else
              v6 = a1[12] - (_DWORD)v17 - 1;
            v16 = v6;
          }
          if ( !v16 )
          {
            a1[13] = v17;
            v30 = sub_80BB834((int)a1, a2, a3);
            v17 = (_BYTE *)a1[13];
            if ( (unsigned int)v17 >= a1[12] )
              v5 = a1[11] - (_DWORD)v17;
            else
              v5 = a1[12] - (_DWORD)v17 - 1;
            v16 = v5;
            if ( v17 == (_BYTE *)a1[11] && a1[12] != a1[10] )
            {
              v17 = (_BYTE *)a1[10];
              if ( (unsigned int)v17 >= a1[12] )
                v4 = a1[11] - (_DWORD)v17;
              else
                v4 = a1[12] - (_DWORD)v17 - 1;
              v16 = v4;
            }
            if ( !v16 )
              goto LABEL_99;
          }
        }
        a3 = 0;
        *v17++ = *(_BYTE *)(v14 + 8);
        --v16;
        *(_DWORD *)v14 = 0;
        continue;
      case 7:
        if ( v20 > 7 )
        {
          v20 -= 8;
          ++v18;
          --v19;
        }
        a1[13] = v17;
        v30 = sub_80BB834((int)a1, a2, a3);
        v17 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] != v17 )
          goto LABEL_99;
        *(_DWORD *)v14 = 8;
LABEL_105:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80BB834((int)a1, a2, 1);
      case 8:
        goto LABEL_105;
      case 9:
        a1[8] = v21;
        a1[7] = v20;
        a2[1] = v18;
        a2[2] += &v19[-*a2];
        *a2 = v19;
        a1[13] = v17;
        return sub_80BB834((int)a1, a2, -3);
    }
  }
}

//----- (080B9AFA) --------------------------------------------------------
int __cdecl sub_80B9AFA(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

//----- (080B9B1C) --------------------------------------------------------
int __cdecl sub_80B9B1C(int a1, int a2, int a3, int a4, _DWORD *a5, _DWORD *a6)
{
  unsigned int v7; // [esp+0h] [ebp-60h]
  unsigned int v8; // [esp+8h] [ebp-58h]
  unsigned int v9; // [esp+10h] [ebp-50h]
  unsigned int v10; // [esp+18h] [ebp-48h]
  int v11; // [esp+20h] [ebp-40h]
  int v12; // [esp+24h] [ebp-3Ch]
  _BYTE *v13; // [esp+28h] [ebp-38h]
  _BYTE *v14; // [esp+28h] [ebp-38h]
  _BYTE *v15; // [esp+28h] [ebp-38h]
  _BYTE *v16; // [esp+28h] [ebp-38h]
  _BYTE *v17; // [esp+28h] [ebp-38h]
  _BYTE *v18; // [esp+28h] [ebp-38h]
  int v19; // [esp+2Ch] [ebp-34h]
  unsigned int v20; // [esp+30h] [ebp-30h]
  unsigned int v21; // [esp+30h] [ebp-30h]
  unsigned int v22; // [esp+30h] [ebp-30h]
  unsigned int v23; // [esp+30h] [ebp-30h]
  int v24; // [esp+34h] [ebp-2Ch]
  int v25; // [esp+38h] [ebp-28h]
  unsigned int v26; // [esp+3Ch] [ebp-24h]
  _BYTE *v27; // [esp+40h] [ebp-20h]
  _BYTE *v28; // [esp+40h] [ebp-20h]
  _BYTE *v29; // [esp+40h] [ebp-20h]
  unsigned int v30; // [esp+44h] [ebp-1Ch]
  unsigned __int8 *v31; // [esp+48h] [ebp-18h]
  unsigned __int8 *v32; // [esp+48h] [ebp-18h]
  unsigned __int8 *v33; // [esp+48h] [ebp-18h]
  unsigned __int8 *v34; // [esp+48h] [ebp-18h]
  unsigned __int8 *v35; // [esp+48h] [ebp-18h]
  unsigned int v36; // [esp+4Ch] [ebp-14h]
  unsigned int i; // [esp+4Ch] [ebp-14h]
  unsigned int v38; // [esp+50h] [ebp-10h]
  unsigned int v39; // [esp+50h] [ebp-10h]
  int v40; // [esp+54h] [ebp-Ch]
  int v41; // [esp+54h] [ebp-Ch]
  int j; // [esp+54h] [ebp-Ch]
  unsigned int v43; // [esp+54h] [ebp-Ch]
  unsigned int v44; // [esp+54h] [ebp-Ch]
  unsigned __int8 *v45; // [esp+58h] [ebp-8h]
  unsigned __int8 *v46; // [esp+58h] [ebp-8h]

  v31 = (unsigned __int8 *)*a6;
  v30 = a6[1];
  v38 = a5[8];
  v36 = a5[7];
  v27 = (_BYTE *)a5[13];
  if ( (unsigned int)v27 >= a5[12] )
    v11 = a5[11] - (_DWORD)v27;
  else
    v11 = a5[12] - (_DWORD)v27 - 1;
  v26 = v11;
  v25 = dword_80F1B00[a1];
  v24 = dword_80F1B00[a2];
  while ( 1 )
  {
    while ( v36 <= 0x13 )
    {
      --v30;
      v38 |= *v31++ << v36;
      v36 += 8;
    }
    v45 = (unsigned __int8 *)(a3 + 8 * (v38 & v25));
    v40 = *v45;
    if ( *v45 )
      break;
    v38 >>= v45[1];
    v36 -= v45[1];
    *v27++ = v45[4];
    --v26;
LABEL_47:
    if ( v26 <= 0x101 || v30 <= 9 )
    {
      v7 = a6[1] - v30;
      if ( v7 > v36 >> 3 )
        v7 = v36 >> 3;
      v35 = &v31[-v7];
      a5[8] = v38;
      a5[7] = v36 - 8 * v7;
      a6[1] = v7 + v30;
      a6[2] += &v35[-*a6];
      *a6 = v35;
      a5[13] = v27;
      return 0;
    }
  }
  while ( 1 )
  {
    v38 >>= v45[1];
    v36 -= v45[1];
    if ( (v40 & 0x10) != 0 )
      break;
    if ( (v40 & 0x40) != 0 )
    {
      if ( (v40 & 0x20) != 0 )
      {
        v9 = a6[1] - v30;
        if ( v9 > v36 >> 3 )
          v9 = v36 >> 3;
        v33 = &v31[-v9];
        a5[8] = v38;
        a5[7] = v36 - 8 * v9;
        a6[1] = v9 + v30;
        a6[2] += &v33[-*a6];
        *a6 = v33;
        a5[13] = v27;
        v12 = 1;
      }
      else
      {
        a6[6] = "invalid literal/length code";
        v8 = a6[1] - v30;
        if ( v8 > v36 >> 3 )
          v8 = v36 >> 3;
        v34 = &v31[-v8];
        a5[8] = v38;
        a5[7] = v36 - 8 * v8;
        a6[1] = v8 + v30;
        a6[2] += &v34[-*a6];
        *a6 = v34;
        a5[13] = v27;
        v12 = -3;
      }
      return v12;
    }
    v45 += 8 * (v38 & dword_80F1B00[v40]) + 8 * *((_DWORD *)v45 + 1);
    v40 = *v45;
    if ( !*v45 )
    {
      v38 >>= v45[1];
      v36 -= v45[1];
      *v27++ = v45[4];
      --v26;
      goto LABEL_47;
    }
  }
  v41 = v40 & 0xF;
  v20 = *((_DWORD *)v45 + 1) + (v38 & dword_80F1B00[v41]);
  v39 = v38 >> v41;
  for ( i = v36 - v41; i <= 0xE; i += 8 )
  {
    --v30;
    v39 |= *v31++ << i;
  }
  v46 = (unsigned __int8 *)(a4 + 8 * (v39 & v24));
  for ( j = *v46; ; j = *v46 )
  {
    v39 >>= v46[1];
    i -= v46[1];
    if ( (j & 0x10) != 0 )
    {
      v43 = j & 0xF;
      while ( i < v43 )
      {
        --v30;
        v39 |= *v31++ << i;
        i += 8;
      }
      v19 = *((_DWORD *)v46 + 1) + (v39 & dword_80F1B00[v43]);
      v38 = v39 >> v43;
      v36 = i - v43;
      v26 -= v20;
      v13 = &v27[-v19];
      if ( (unsigned int)&v27[-v19] >= a5[10] )
      {
        *v27 = *v13;
        v17 = v13 + 1;
        v29 = v27 + 1;
        *v29 = *v17;
        v18 = v17 + 1;
        v27 = v29 + 1;
        v23 = v20 - 2;
        do
        {
          *v27++ = *v18++;
          --v23;
        }
        while ( v23 );
      }
      else
      {
        do
          v13 += a5[11] - a5[10];
        while ( (unsigned int)v13 < a5[10] );
        v44 = a5[11] - (_DWORD)v13;
        if ( v20 <= v44 )
        {
          *v27 = *v13;
          v15 = v13 + 1;
          v28 = v27 + 1;
          *v28 = *v15;
          v16 = v15 + 1;
          v27 = v28 + 1;
          v22 = v20 - 2;
          do
          {
            *v27++ = *v16++;
            --v22;
          }
          while ( v22 );
        }
        else
        {
          v21 = v20 - v44;
          do
          {
            *v27++ = *v13++;
            --v44;
          }
          while ( v44 );
          v14 = (_BYTE *)a5[10];
          do
          {
            *v27++ = *v14++;
            --v21;
          }
          while ( v21 );
        }
      }
      goto LABEL_47;
    }
    if ( (j & 0x40) != 0 )
      break;
    v46 += 8 * (v39 & dword_80F1B00[j]) + 8 * *((_DWORD *)v46 + 1);
  }
  a6[6] = "invalid distance code";
  v10 = a6[1] - v30;
  if ( v10 > i >> 3 )
    v10 = i >> 3;
  v32 = &v31[-v10];
  a5[8] = v39;
  a5[7] = i - 8 * v10;
  a6[1] = v10 + v30;
  a6[2] += &v32[-*a6];
  *a6 = v32;
  a5[13] = v27;
  return -3;
}

//----- (080BA21C) --------------------------------------------------------
int __cdecl sub_80BA21C(_DWORD *a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  if ( !a1 || !a1[7] )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  if ( *(_DWORD *)(a1[7] + 12) )
    v2 = 7;
  else
    v2 = 0;
  *(_DWORD *)a1[7] = v2;
  sub_80B7608(*(_DWORD *)(a1[7] + 20), (int)a1, 0);
  return 0;
}

//----- (080BA2B1) --------------------------------------------------------
int __cdecl sub_80BA2B1(_DWORD *a1)
{
  if ( !a1 || !a1[7] || !a1[9] )
    return -2;
  if ( *(_DWORD *)(a1[7] + 20) )
    sub_80B8C61(*(_DWORD *)(a1[7] + 20), (int)a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

//----- (080BA32D) --------------------------------------------------------
int __cdecl sub_80BA32D(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // eax
  int v6; // [esp+8h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  a1[6] = 0;
  if ( !a1[8] )
  {
    a1[8] = sub_80C06F2;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = sub_80C0709;
  a1[7] = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  if ( !a1[7] )
    return -4;
  *(_DWORD *)(a1[7] + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    a2 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( a2 > 7 && a2 <= 15 )
  {
    *(_DWORD *)(a1[7] + 16) = a2;
    v7 = a1[7];
    v6 = 1 << a2;
    if ( *(_DWORD *)(v7 + 12) )
      v4 = sub_80B76D8((int)a1, 0, v6);
    else
      v4 = sub_80B76D8((int)a1, (int)sub_80B4A60, v6);
    *(_DWORD *)(v7 + 20) = v4;
    if ( *(_DWORD *)(v7 + 20) )
    {
      sub_80BA21C(a1);
      v8 = 0;
    }
    else
    {
      sub_80BA2B1(a1);
      v8 = -4;
    }
  }
  else
  {
    sub_80BA2B1(a1);
    v8 = -2;
  }
  return v8;
}

//----- (080BA4C4) --------------------------------------------------------
int __cdecl sub_80BA4C4(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_80BA32D(a1, 15, a2, a3);
}

//----- (080BA4ED) --------------------------------------------------------
int __cdecl sub_80BA4ED(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ecx
  int v3; // eax
  unsigned __int8 *v4; // ecx
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ecx
  unsigned __int8 *v9; // ebx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // ebx
  int v13; // [esp+14h] [ebp-14h]
  int v14; // [esp+18h] [ebp-10h]
  int v15; // [esp+1Ch] [ebp-Ch]
  int v16; // [esp+20h] [ebp-8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  if ( a2 == 4 )
    v13 = -5;
  else
    v13 = 0;
  v16 = -5;
  while ( 2 )
  {
    switch ( *(_DWORD *)a1[7] )
    {
      case 0:
        if ( a1[1] )
        {
          v16 = v13;
          v2 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v2 + 1) = **a1;
          v3 = *((_DWORD *)v2 + 1) & 0xF;
          ++*a1;
          if ( v3 != 8 )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "unknown compression method";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( (unsigned int)((*((_DWORD *)a1[7] + 1) >> 4) + 8) > *((_DWORD *)a1[7] + 4) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "invalid window size";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 1;
          goto LABEL_17;
        }
        v14 = v16;
        break;
      case 1:
LABEL_17:
        if ( a1[1] )
        {
          v16 = v13;
          --a1[1];
          ++a1[2];
          v15 = *(*a1)++;
          if ( (v15 + (*((_DWORD *)a1[7] + 1) << 8)) % 0x1Fu )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect header check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          if ( (v15 & 0x20) == 0 )
          {
            *(_DWORD *)a1[7] = 7;
            continue;
          }
          *(_DWORD *)a1[7] = 2;
          goto LABEL_24;
        }
        v14 = v16;
        break;
      case 2:
LABEL_24:
        if ( a1[1] )
        {
          v16 = v13;
          v4 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v4 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 3;
          goto LABEL_27;
        }
        v14 = v16;
        break;
      case 3:
LABEL_27:
        if ( a1[1] )
        {
          v16 = v13;
          v5 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v5 + 2) = *((_DWORD *)a1[7] + 2) + (*(*a1)++ << 16);
          *(_DWORD *)a1[7] = 4;
          goto LABEL_30;
        }
        v14 = v16;
        break;
      case 4:
LABEL_30:
        if ( a1[1] )
        {
          v16 = v13;
          v6 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v6 + 2) = *((_DWORD *)a1[7] + 2) + (*(*a1)++ << 8);
          *(_DWORD *)a1[7] = 5;
          goto LABEL_33;
        }
        v14 = v16;
        break;
      case 5:
LABEL_33:
        if ( a1[1] )
        {
          v7 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v7 + 2) = *((_DWORD *)a1[7] + 2) + *(*a1)++;
          a1[12] = (unsigned __int8 *)*((_DWORD *)a1[7] + 2);
          *(_DWORD *)a1[7] = 6;
          v14 = 2;
        }
        else
        {
          v14 = v16;
        }
        break;
      case 6:
        *(_DWORD *)a1[7] = 13;
        a1[6] = "need dictionary";
        *((_DWORD *)a1[7] + 1) = 0;
        v14 = -2;
        break;
      case 7:
        v16 = sub_80B781A(*((_DWORD *)a1[7] + 5), (int)a1, v16);
        if ( v16 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
          continue;
        }
        if ( !v16 )
          v16 = v13;
        if ( v16 == 1 )
        {
          v16 = v13;
          sub_80B7608(*((_DWORD *)a1[7] + 5), (int)a1, (_DWORD *)a1[7] + 1);
          if ( *((_DWORD *)a1[7] + 3) )
          {
            *(_DWORD *)a1[7] = 12;
            continue;
          }
          *(_DWORD *)a1[7] = 8;
          goto LABEL_46;
        }
        v14 = v16;
        break;
      case 8:
LABEL_46:
        if ( a1[1] )
        {
          v16 = v13;
          v8 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v8 + 2) = *(*a1)++ << 24;
          *(_DWORD *)a1[7] = 9;
          goto LABEL_49;
        }
        v14 = v16;
        break;
      case 9:
LABEL_49:
        if ( a1[1] )
        {
          v16 = v13;
          v9 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v9 + 2) = *((_DWORD *)a1[7] + 2) + (*(*a1)++ << 16);
          *(_DWORD *)a1[7] = 10;
          goto LABEL_52;
        }
        v14 = v16;
        break;
      case 0xA:
LABEL_52:
        if ( a1[1] )
        {
          v16 = v13;
          v10 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v10 + 2) = *((_DWORD *)a1[7] + 2) + (*(*a1)++ << 8);
          *(_DWORD *)a1[7] = 11;
          goto LABEL_55;
        }
        v14 = v16;
        break;
      case 0xB:
LABEL_55:
        if ( a1[1] )
        {
          v16 = v13;
          v11 = a1[7];
          --a1[1];
          ++a1[2];
          *((_DWORD *)v11 + 2) = *((_DWORD *)a1[7] + 2) + *(*a1)++;
          if ( *((_DWORD *)a1[7] + 1) != *((_DWORD *)a1[7] + 2) )
          {
            *(_DWORD *)a1[7] = 13;
            a1[6] = "incorrect data check";
            *((_DWORD *)a1[7] + 1) = 5;
            continue;
          }
          *(_DWORD *)a1[7] = 12;
          goto LABEL_60;
        }
        v14 = v16;
        break;
      case 0xC:
LABEL_60:
        v14 = 1;
        break;
      case 0xD:
        v14 = -3;
        break;
      default:
        v14 = -2;
        break;
    }
    return v14;
  }
}

//----- (080BAD10) --------------------------------------------------------
int __cdecl sub_80BAD10(_DWORD *a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int *a7, int a8, _DWORD *a9, int *a10)
{
  int v10; // ebx
  int v11; // ecx
  int v12; // edx
  int v13; // ebx
  int v14; // ecx
  int v15; // edx
  int v17; // [esp+0h] [ebp-128h]
  char v18; // [esp+7h] [ebp-121h]
  unsigned int v19; // [esp+8h] [ebp-120h]
  int v20; // [esp+Ch] [ebp-11Ch]
  _DWORD *v21; // [esp+10h] [ebp-118h]
  _DWORD *v22; // [esp+10h] [ebp-118h]
  int *v23; // [esp+10h] [ebp-118h]
  int *v24; // [esp+10h] [ebp-118h]
  int v25; // [esp+14h] [ebp-114h]
  unsigned int i; // [esp+18h] [ebp-110h]
  int v27; // [esp+18h] [ebp-110h]
  int v28; // [esp+18h] [ebp-110h]
  unsigned int v29; // [esp+18h] [ebp-110h]
  unsigned int l; // [esp+18h] [ebp-110h]
  unsigned int m; // [esp+18h] [ebp-110h]
  unsigned int v32; // [esp+1Ch] [ebp-10Ch]
  unsigned int j; // [esp+1Ch] [ebp-10Ch]
  unsigned int v34; // [esp+1Ch] [ebp-10Ch]
  unsigned int v35; // [esp+1Ch] [ebp-10Ch]
  int v36; // [esp+20h] [ebp-108h]
  unsigned int v37; // [esp+24h] [ebp-104h]
  int v38; // [esp+28h] [ebp-100h]
  int v39; // [esp+28h] [ebp-100h]
  int v40; // [esp+28h] [ebp-100h]
  _DWORD *k; // [esp+2Ch] [ebp-FCh]
  int *v42; // [esp+2Ch] [ebp-FCh]
  int v43[2]; // [esp+30h] [ebp-F8h]
  _BYTE v44[56]; // [esp+38h] [ebp-F0h] BYREF
  int v45[16]; // [esp+70h] [ebp-B8h]
  int v46; // [esp+B0h] [ebp-78h]
  int v47; // [esp+B4h] [ebp-74h]
  int v48; // [esp+B8h] [ebp-70h]
  int n; // [esp+BCh] [ebp-6Ch]
  unsigned int v50; // [esp+C0h] [ebp-68h]
  int v51; // [esp+C4h] [ebp-64h]
  int v52; // [esp+C8h] [ebp-60h]
  unsigned int v53; // [esp+CCh] [ebp-5Ch]
  int v54[19]; // [esp+D0h] [ebp-58h] BYREF
  _DWORD v55[18]; // [esp+D4h] [ebp-54h] BYREF
  int v56; // [esp+11Ch] [ebp-Ch]
  int v57; // [esp+134h] [ebp+Ch]

  v54[0] = 0;
  v55[0] = 0;
  v55[1] = 0;
  v55[2] = 0;
  v55[3] = 0;
  v55[4] = 0;
  v55[5] = 0;
  v55[6] = 0;
  v55[7] = 0;
  v55[8] = 0;
  v55[9] = 0;
  v55[10] = 0;
  v55[11] = 0;
  v55[12] = 0;
  v55[13] = 0;
  v55[14] = 0;
  v21 = a1;
  v32 = a2;
  do
  {
    ++v54[*v21++];
    --v32;
  }
  while ( v32 );
  if ( v54[0] == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    v36 = 0;
  }
  else
  {
    v50 = *a7;
    for ( i = 1; i <= 0xF && !v54[i]; ++i )
      ;
    v25 = i;
    if ( v50 < i )
      v50 = i;
    for ( j = 15; j && !v54[j]; --j )
      ;
    v52 = j;
    if ( v50 > j )
      v50 = j;
    *a7 = v50;
    v38 = 1 << i;
    while ( i < j )
    {
      v39 = v38 - v54[i];
      if ( v39 < 0 )
        return -3;
      ++i;
      v38 = 2 * v39;
    }
    v40 = v38 - v54[j];
    if ( v40 >= 0 )
    {
      v54[j] += v40;
      v27 = 0;
      v43[1] = 0;
      v22 = v55;
      for ( k = v44; --j; ++k )
      {
        v27 += *v22;
        *k = v27;
        ++v22;
      }
      v23 = a1;
      v34 = 0;
      do
      {
        v28 = *v23++;
        if ( v28 )
          a10[v43[v28]++] = v34;
        ++v34;
      }
      while ( v34 < a2 );
      v57 = v43[v52];
      v35 = 0;
      v43[0] = 0;
      v24 = a10;
      v51 = -1;
      v20 = -v50;
      v45[0] = 0;
      v48 = 0;
      v37 = 0;
      while ( v25 <= v52 )
      {
        v56 = v54[v25];
        while ( --v56 != -1 )
        {
          while ( v25 > (int)(v50 + v20) )
          {
            ++v51;
            v20 += v50;
            v19 = v52 - v20;
            if ( v52 - v20 > v50 )
              v19 = v50;
            v29 = v25 - v20;
            v53 = 1 << (v25 - v20);
            if ( v53 > v56 + 1 )
            {
              v53 = v53 - v56 - 1;
              v42 = &v54[v25];
              if ( v29 < v19 )
              {
                while ( ++v29 < v19 )
                {
                  v53 *= 2;
                  if ( v53 <= *++v42 )
                    break;
                  v53 -= *v42;
                }
              }
            }
            v37 = 1 << v29;
            if ( (unsigned int)(*a9 + (1 << v29)) > 0x5A0 )
              return -3;
            v48 = a8 + 8 * *a9;
            v45[v51] = v48;
            *a9 += v37;
            if ( v51 )
            {
              v43[v51] = v35;
              BYTE1(v46) = v50;
              LOBYTE(v46) = v29;
              v47 = ((v48 - *(_DWORD *)&v44[4 * v51 + 52]) >> 3) - (v35 >> (v20 - v50));
              v10 = 8 * (v35 >> (v20 - v50));
              v11 = *(_DWORD *)&v44[4 * v51 + 52];
              v12 = v47;
              *(_DWORD *)(v11 + v10) = v46;
              *(_DWORD *)(v11 + v10 + 4) = v12;
            }
            else
            {
              *a6 = v48;
            }
          }
          BYTE1(v46) = v25 - v20;
          if ( v24 < &a10[v57] )
          {
            if ( *v24 >= a3 )
            {
              LOBYTE(v46) = *(_BYTE *)(a5 + 4 * (*v24 - a3)) + 80;
              v47 = *(_DWORD *)(a4 + 4 * (*v24++ - a3));
            }
            else
            {
              if ( (unsigned int)*v24 <= 0xFF )
                v18 = 0;
              else
                v18 = 96;
              LOBYTE(v46) = v18;
              v47 = *v24++;
            }
          }
          else
          {
            LOBYTE(v46) = -64;
          }
          v53 = 1 << (v25 - v20);
          for ( l = v35 >> v20; l < v37; l += v53 )
          {
            v13 = 8 * l;
            v14 = v48;
            v15 = v47;
            *(_DWORD *)(v48 + v13) = v46;
            *(_DWORD *)(v14 + v13 + 4) = v15;
          }
          for ( m = 1 << (v25 - 1); (m & v35) != 0; m >>= 1 )
            v35 ^= m;
          v35 ^= m;
          for ( n = (1 << v20) - 1; (n & v35) != v43[v51]; n = (1 << v20) - 1 )
          {
            --v51;
            v20 -= v50;
          }
        }
        ++v25;
      }
      if ( !v40 || v52 == 1 )
        v17 = 0;
      else
        v17 = -5;
      v36 = v17;
    }
    else
    {
      v36 = -3;
    }
  }
  return v36;
}
// 80BAD10: using guessed type int var_58[19];

//----- (080BB535) --------------------------------------------------------
int __cdecl sub_80BB535(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  int *v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h] BYREF
  int v9; // [esp+34h] [ebp-4h]

  v8 = 0;
  v7 = (int *)(*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v7 )
    return -4;
  v9 = sub_80BAD10(a1, 0x13u, 0x13u, 0, 0, a3, a2, a4, &v8, v7);
  if ( v9 == -3 )
  {
    *(_DWORD *)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v9 == -5 || !*a2 )
  {
    *(_DWORD *)(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(void (__cdecl **)(_DWORD, int *))(a5 + 36))(*(_DWORD *)(a5 + 40), v7);
  return v9;
}

//----- (080BB61E) --------------------------------------------------------
int __cdecl sub_80BB61E(unsigned int a1, unsigned int a2, _DWORD *a3, unsigned int *a4, unsigned int *a5, _DWORD *a6, _DWORD *a7, int a8, int a9)
{
  int *v11; // [esp+2Ch] [ebp-Ch]
  int v12; // [esp+30h] [ebp-8h] BYREF
  int v13; // [esp+34h] [ebp-4h]

  v12 = 0;
  v11 = (int *)(*(int (__cdecl **)(_DWORD, int, int))(a9 + 32))(*(_DWORD *)(a9 + 40), 288, 4);
  if ( !v11 )
    return -4;
  v13 = sub_80BAD10(a3, a1, 0x101u, (int)&unk_80E4800, (int)&unk_80E4880, a6, a4, a8, &v12, v11);
  if ( !v13 && *a4 )
  {
    v13 = sub_80BAD10(&a3[a1], a2, 0, (int)&unk_80E4900, (int)&unk_80E4980, a7, a5, a8, &v12, v11);
    if ( !v13 && (*a5 || a1 <= 0x101) )
    {
      (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
      return 0;
    }
    if ( v13 == -3 )
    {
      *(_DWORD *)(a9 + 24) = "oversubscribed distance tree";
    }
    else if ( v13 == -5 )
    {
      *(_DWORD *)(a9 + 24) = "incomplete distance tree";
      v13 = -3;
    }
    else if ( v13 != -4 )
    {
      *(_DWORD *)(a9 + 24) = "empty distance tree with lengths";
      v13 = -3;
    }
  }
  else if ( v13 == -3 )
  {
    *(_DWORD *)(a9 + 24) = "oversubscribed literal/length tree";
  }
  else if ( v13 != -4 )
  {
    *(_DWORD *)(a9 + 24) = "incomplete literal/length tree";
    v13 = -3;
  }
  (*(void (__cdecl **)(_DWORD, int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v11);
  return v13;
}

//----- (080BB801) --------------------------------------------------------
int __cdecl sub_80BB801(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_80F09E0;
  *a2 = dword_80F09E4;
  *a3 = &unk_80F0A00;
  *a4 = &unk_80F1A00;
  return 0;
}
// 80F09E0: using guessed type int dword_80F09E0;
// 80F09E4: using guessed type int dword_80F09E4;

//----- (080BB834) --------------------------------------------------------
int __cdecl sub_80BB834(int a1, _DWORD *a2, int a3)
{
  int v3; // eax
  char *src; // [esp+14h] [ebp-14h]
  char *srca; // [esp+14h] [ebp-14h]
  char *srcb; // [esp+14h] [ebp-14h]
  char *dest; // [esp+18h] [ebp-10h]
  char *desta; // [esp+18h] [ebp-10h]
  size_t n; // [esp+1Ch] [ebp-Ch]
  size_t na; // [esp+1Ch] [ebp-Ch]

  dest = (char *)a2[3];
  src = *(char **)(a1 + 48);
  if ( (unsigned int)src > *(_DWORD *)(a1 + 52) )
    v3 = *(_DWORD *)(a1 + 44);
  else
    v3 = *(_DWORD *)(a1 + 52);
  n = v3 - (_DWORD)src;
  if ( (unsigned int)(v3 - (_DWORD)src) > a2[4] )
    n = a2[4];
  if ( n && a3 == -5 )
    a3 = 0;
  a2[4] -= n;
  a2[5] += n;
  if ( *(_DWORD *)(a1 + 56) )
  {
    *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, size_t))(a1 + 56))(*(_DWORD *)(a1 + 60), src, n);
    a2[12] = *(_DWORD *)(a1 + 60);
  }
  memcpy(dest, src, n);
  desta = &dest[n];
  srca = &src[n];
  if ( srca == *(char **)(a1 + 44) )
  {
    srcb = *(char **)(a1 + 40);
    if ( *(_DWORD *)(a1 + 52) == *(_DWORD *)(a1 + 44) )
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 40);
    na = *(_DWORD *)(a1 + 52) - (_DWORD)srcb;
    if ( na > a2[4] )
      na = a2[4];
    if ( na && a3 == -5 )
      a3 = 0;
    a2[4] -= na;
    a2[5] += na;
    if ( *(_DWORD *)(a1 + 56) )
    {
      *(_DWORD *)(a1 + 60) = (*(int (__cdecl **)(_DWORD, char *, size_t))(a1 + 56))(*(_DWORD *)(a1 + 60), srcb, na);
      a2[12] = *(_DWORD *)(a1 + 60);
    }
    memcpy(desta, srcb, na);
    desta += na;
    srca = &srcb[na];
  }
  a2[3] = desta;
  *(_DWORD *)(a1 + 48) = srca;
  return a3;
}

//----- (080BBA28) --------------------------------------------------------
void sub_80BBA28()
{
  ;
}

//----- (080BBA2D) --------------------------------------------------------
int __cdecl sub_80BBA2D(int a1)
{
  sub_80BBA28();
  *(_DWORD *)(a1 + 2832) = a1 + 140;
  *(_DWORD *)(a1 + 2840) = &off_80F1B44;
  *(_DWORD *)(a1 + 2844) = a1 + 2432;
  *(_DWORD *)(a1 + 2852) = &off_80F1B58;
  *(_DWORD *)(a1 + 2856) = a1 + 2676;
  *(_DWORD *)(a1 + 2864) = &unk_80F1B6C;
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  return sub_80BBAC5(a1);
}
// 80F1B44: using guessed type void *off_80F1B44;
// 80F1B58: using guessed type void *off_80F1B58;

//----- (080BBAC5) --------------------------------------------------------
int __cdecl sub_80BBAC5(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-4h]
  int j; // [esp+0h] [ebp-4h]
  int k; // [esp+0h] [ebp-4h]

  for ( i = 0; i <= 285; ++i )
    *(_WORD *)(a1 + 4 * i + 140) = 0;
  for ( j = 0; j <= 29; ++j )
    *(_WORD *)(a1 + 4 * j + 2432) = 0;
  for ( k = 0; k <= 18; ++k )
    *(_WORD *)(a1 + 4 * k + 2676) = 0;
  *(_WORD *)(a1 + 1164) = 1;
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  return result;
}

//----- (080BBB82) --------------------------------------------------------
int __cdecl sub_80BBB82(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  for ( i = 2 * a3; i <= *(_DWORD *)(a1 + 5192); i *= 2 )
  {
    if ( i < *(_DWORD *)(a1 + 5192)
      && (*(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       || *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2904)) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
       && *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2904) + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200)) )
    {
      ++i;
    }
    if ( *(_WORD *)(a2 + 4 * v5) < *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      || *(_WORD *)(a2 + 4 * v5) == *(_WORD *)(a2 + 4 * *(_DWORD *)(a1 + 4 * i + 2900))
      && *(_BYTE *)(v5 + a1 + 5200) <= *(_BYTE *)(*(_DWORD *)(a1 + 4 * i + 2900) + a1 + 5200) )
    {
      break;
    }
    *(_DWORD *)(a1 + 4 * a3 + 2900) = *(_DWORD *)(a1 + 4 * i + 2900);
    a3 = i;
  }
  result = v5;
  *(_DWORD *)(a1 + 4 * a3 + 2900) = v5;
  return result;
}

//----- (080BBD44) --------------------------------------------------------
int *__cdecl sub_80BBD44(_DWORD *a1, int a2)
{
  int *result; // eax
  int v3; // [esp+0h] [ebp-3Ch]
  unsigned __int16 v4; // [esp+6h] [ebp-36h]
  int v5; // [esp+8h] [ebp-34h]
  int i; // [esp+Ch] [ebp-30h] BYREF
  int v7; // [esp+10h] [ebp-2Ch]
  int v8; // [esp+14h] [ebp-28h]
  int *j; // [esp+18h] [ebp-24h] BYREF
  int *v10; // [esp+1Ch] [ebp-20h]
  int v11; // [esp+20h] [ebp-1Ch]
  int v12; // [esp+24h] [ebp-18h]
  int v13; // [esp+28h] [ebp-14h]
  int v14; // [esp+2Ch] [ebp-10h]
  int v15; // [esp+30h] [ebp-Ch]

  v15 = *(_DWORD *)a2;
  v14 = *(_DWORD *)(a2 + 4);
  v13 = **(_DWORD **)(a2 + 8);
  v12 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8);
  v10 = *(int **)(*(_DWORD *)(a2 + 8) + 16);
  v3 = 0;
  for ( i = 0; i <= 15; ++i )
    *((_WORD *)a1 + i + 1434) = 0;
  *(_WORD *)(v15 + 4 * a1[a1[1299] + 725] + 2) = 0;
  result = (int *)(a1[1299] + 1);
  for ( j = result; (int)j <= 572; j = (int *)((char *)j + 1) )
  {
    v8 = a1[(_DWORD)j + 725];
    i = *(unsigned __int16 *)(v15 + 4 * *(unsigned __int16 *)(v15 + 4 * v8 + 2) + 2) + 1;
    if ( i > (int)v10 )
    {
      i = (int)v10;
      ++v3;
    }
    *(_WORD *)(v15 + 4 * v8 + 2) = i;
    if ( v8 <= v14 )
    {
      ++*((_WORD *)a1 + i + 1434);
      v5 = 0;
      if ( v8 >= v11 )
        v5 = *(_DWORD *)(v12 + 4 * (v8 - v11));
      v4 = *(_WORD *)(v15 + 4 * v8);
      a1[1448] += v4 * (i + v5);
      if ( v13 )
        a1[1449] += v4 * (v5 + *(unsigned __int16 *)(v13 + 4 * v8 + 2));
    }
    result = (int *)&j;
  }
  if ( v3 )
  {
    do
    {
      for ( i = (int)v10 - 1; !*((_WORD *)a1 + i + 1434); --i )
        ;
      --*((_WORD *)a1 + i + 1434);
      *((_WORD *)a1 + i + 1435) += 2;
      --*((_WORD *)a1 + (_DWORD)v10 + 1434);
      v3 -= 2;
    }
    while ( v3 > 0 );
    result = v10;
    for ( i = (int)v10; i; --i )
    {
      v8 = *((unsigned __int16 *)a1 + i + 1434);
      while ( v8 )
      {
        j = (int *)((char *)j - 1);
        v7 = a1[(_DWORD)j + 725];
        if ( v7 <= v14 )
        {
          if ( *(unsigned __int16 *)(v15 + 4 * v7 + 2) != i )
          {
            a1[1448] += (i - *(unsigned __int16 *)(v15 + 4 * v7 + 2)) * *(unsigned __int16 *)(v15 + 4 * v7);
            *(_WORD *)(v15 + 4 * v7 + 2) = i;
          }
          --v8;
        }
      }
      result = &i;
    }
  }
  return result;
}

//----- (080BC080) --------------------------------------------------------
int __cdecl sub_80BC080(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // cx
  int v5; // [esp+10h] [ebp-38h]
  int j; // [esp+14h] [ebp-34h]
  int i; // [esp+18h] [ebp-30h]
  __int16 v8; // [esp+1Eh] [ebp-2Ah]
  __int16 v9[20]; // [esp+20h] [ebp-28h]

  v8 = 0;
  for ( i = 1; i <= 15; ++i )
  {
    v8 = 2 * (*(_WORD *)(a3 + 2 * i - 2) + v8);
    v9[i] = v8;
  }
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j > a2 )
      break;
    v5 = *(unsigned __int16 *)(a1 + 4 * j + 2);
    if ( *(_WORD *)(a1 + 4 * j + 2) )
    {
      v4 = v9[v5];
      v9[v5] = v4 + 1;
      *(_WORD *)(a1 + 4 * j) = sub_80BE87C(v4, v5);
    }
  }
  return result;
}

//----- (080BC136) --------------------------------------------------------
int __cdecl sub_80BC136(_DWORD *a1, int a2)
{
  char v2; // al
  int v4; // [esp+14h] [ebp-34h]
  int v5; // [esp+20h] [ebp-28h]
  int v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+28h] [ebp-20h]
  int i; // [esp+2Ch] [ebp-1Ch]
  int j; // [esp+2Ch] [ebp-1Ch]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]
  int v13; // [esp+38h] [ebp-10h]

  v13 = *(_DWORD *)a2;
  v12 = **(_DWORD **)(a2 + 8);
  v11 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 12);
  v6 = -1;
  a1[1298] = 0;
  a1[1299] = 573;
  for ( i = 0; i < v11; ++i )
  {
    if ( *(_WORD *)(v13 + 4 * i) )
    {
      ++a1[1298];
      v6 = i;
      a1[a1[1298] + 725] = i;
      *((_BYTE *)a1 + i + 5200) = 0;
    }
    else
    {
      *(_WORD *)(v13 + 4 * i + 2) = 0;
    }
  }
  while ( (int)a1[1298] <= 1 )
  {
    ++a1[1298];
    if ( v6 > 1 )
      v4 = 0;
    else
      v4 = ++v6;
    a1[a1[1298] + 725] = v4;
    *(_WORD *)(v13 + 4 * v4) = 1;
    *((_BYTE *)a1 + v4 + 5200) = 0;
    --a1[1448];
    if ( v12 )
      a1[1449] -= *(unsigned __int16 *)(v12 + 4 * v4 + 2);
  }
  *(_DWORD *)(a2 + 4) = v6;
  for ( j = a1[1298] / 2; j > 0; --j )
    sub_80BBB82((int)a1, v13, j);
  v5 = v11;
  do
  {
    v10 = a1[726];
    a1[726] = a1[a1[1298]-- + 725];
    sub_80BBB82((int)a1, v13, 1);
    v7 = a1[726];
    --a1[1299];
    a1[a1[1299]-- + 725] = v10;
    a1[a1[1299] + 725] = v7;
    *(_WORD *)(v13 + 4 * v5) = *(_WORD *)(v13 + 4 * v7) + *(_WORD *)(v13 + 4 * v10);
    if ( *((_BYTE *)a1 + v10 + 5200) < *((_BYTE *)a1 + v7 + 5200) )
      v2 = *((_BYTE *)a1 + v7 + 5200);
    else
      v2 = *((_BYTE *)a1 + v10 + 5200);
    *((_BYTE *)a1 + v5 + 5200) = v2 + 1;
    *(_WORD *)(v13 + 4 * v7 + 2) = v5;
    *(_WORD *)(v13 + 4 * v10 + 2) = *(_WORD *)(v13 + 4 * v7 + 2);
    a1[726] = v5++;
    sub_80BBB82((int)a1, v13, 1);
  }
  while ( (int)a1[1298] > 1 );
  a1[--a1[1299] + 725] = a1[726];
  sub_80BBD44(a1, a2);
  return sub_80BC080(v13, v6, (int)(a1 + 717));
}

//----- (080BC4D5) --------------------------------------------------------
int __cdecl sub_80BC4D5(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-20h]
  int v5; // [esp+4h] [ebp-1Ch]
  int v6; // [esp+8h] [ebp-18h]
  int v7; // [esp+Ch] [ebp-14h]
  int v8; // [esp+10h] [ebp-10h]
  int v9; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]

  v9 = -1;
  v7 = *(unsigned __int16 *)(a2 + 2);
  v6 = 0;
  v5 = 7;
  v4 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v5 = 138;
    v4 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v8 = v7;
    v7 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v6 >= v5 || v8 != v7 )
    {
      if ( v6 >= v4 )
      {
        if ( v8 )
        {
          if ( v8 != v9 )
            ++a1[2 * v8 + 1338];
          ++a1[1370];
        }
        else if ( v6 > 10 )
        {
          ++a1[1374];
        }
        else
        {
          ++a1[1372];
        }
      }
      else
      {
        a1[2 * v8 + 1338] += v6;
      }
      v6 = 0;
      v9 = v8;
      if ( v7 )
      {
        if ( v8 == v7 )
        {
          v5 = 6;
          v4 = 3;
        }
        else
        {
          v5 = 7;
          v4 = 4;
        }
      }
      else
      {
        v5 = 138;
        v4 = 3;
      }
    }
  }
  return result;
}

//----- (080BC668) --------------------------------------------------------
int __cdecl sub_80BC668(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // [esp+0h] [ebp-2Ch]
  int v13; // [esp+0h] [ebp-2Ch]
  int v14; // [esp+0h] [ebp-2Ch]
  int v15; // [esp+0h] [ebp-2Ch]
  int v16; // [esp+0h] [ebp-2Ch]
  int v17; // [esp+4h] [ebp-28h]
  int v18; // [esp+4h] [ebp-28h]
  int v19; // [esp+4h] [ebp-28h]
  int v20; // [esp+4h] [ebp-28h]
  int v21; // [esp+4h] [ebp-28h]
  int v22; // [esp+8h] [ebp-24h]
  int v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  int v25; // [esp+14h] [ebp-18h]
  int v26; // [esp+18h] [ebp-14h]
  int v27; // [esp+1Ch] [ebp-10h]
  int i; // [esp+20h] [ebp-Ch]

  v27 = -1;
  v25 = *(unsigned __int16 *)(a2 + 2);
  v24 = 0;
  v23 = 7;
  v22 = 4;
  if ( !*(_WORD *)(a2 + 2) )
  {
    v23 = 138;
    v22 = 3;
  }
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i > a3 )
      break;
    v26 = v25;
    v25 = *(unsigned __int16 *)(a2 + 4 * i + 6);
    if ( ++v24 >= v23 || v26 != v25 )
    {
      if ( v24 >= v22 )
      {
        if ( v26 )
        {
          if ( v26 != v27 )
          {
            v13 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
            if ( *(_DWORD *)(a1 + 5812) <= 16 - v13 )
            {
              *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
              v5 = *(_DWORD *)(a1 + 5812) + v13;
            }
            else
            {
              v18 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
              *(_WORD *)(a1 + 5808) |= v18 << *(_BYTE *)(a1 + 5812);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
              *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
              *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v18 >> (16 - *(_BYTE *)(a1 + 5812));
              v5 = *(_DWORD *)(a1 + 5812) + v13 - 16;
            }
            *(_DWORD *)(a1 + 5812) = v5;
            --v24;
          }
          v14 = *(unsigned __int16 *)(a1 + 2742);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v14 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2740) << *(_BYTE *)(a1 + 5812);
            v6 = *(_DWORD *)(a1 + 5812) + v14;
          }
          else
          {
            v19 = *(unsigned __int16 *)(a1 + 2740);
            *(_WORD *)(a1 + 5808) |= v19 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v19 >> (16 - *(_BYTE *)(a1 + 5812));
            v6 = *(_DWORD *)(a1 + 5812) + v14 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v6;
          if ( *(int *)(a1 + 5812) <= 14 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v7 = *(_DWORD *)(a1 + 5812) + 2;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v7 = *(_DWORD *)(a1 + 5812) - 14;
          }
          *(_DWORD *)(a1 + 5812) = v7;
        }
        else if ( v24 > 10 )
        {
          v16 = *(unsigned __int16 *)(a1 + 2750);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v16 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2748) << *(_BYTE *)(a1 + 5812);
            v10 = *(_DWORD *)(a1 + 5812) + v16;
          }
          else
          {
            v21 = *(unsigned __int16 *)(a1 + 2748);
            *(_WORD *)(a1 + 5808) |= v21 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v21 >> (16 - *(_BYTE *)(a1 + 5812));
            v10 = *(_DWORD *)(a1 + 5812) + v16 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v10;
          if ( *(int *)(a1 + 5812) <= 9 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            v11 = *(_DWORD *)(a1 + 5812) + 7;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 11) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 11) >> (16 - *(_BYTE *)(a1 + 5812));
            v11 = *(_DWORD *)(a1 + 5812) - 9;
          }
          *(_DWORD *)(a1 + 5812) = v11;
        }
        else
        {
          v15 = *(unsigned __int16 *)(a1 + 2746);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v15 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 2744) << *(_BYTE *)(a1 + 5812);
            v8 = *(_DWORD *)(a1 + 5812) + v15;
          }
          else
          {
            v20 = *(unsigned __int16 *)(a1 + 2744);
            *(_WORD *)(a1 + 5808) |= v20 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v20 >> (16 - *(_BYTE *)(a1 + 5812));
            v8 = *(_DWORD *)(a1 + 5812) + v15 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v8;
          if ( *(int *)(a1 + 5812) <= 13 )
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            v9 = *(_DWORD *)(a1 + 5812) + 3;
          }
          else
          {
            *(_WORD *)(a1 + 5808) |= (v24 - 3) << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(v24 - 3) >> (16 - *(_BYTE *)(a1 + 5812));
            v9 = *(_DWORD *)(a1 + 5812) - 13;
          }
          *(_DWORD *)(a1 + 5812) = v9;
        }
      }
      else
      {
        do
        {
          v17 = *(unsigned __int16 *)(a1 + 4 * v26 + 2678);
          if ( *(_DWORD *)(a1 + 5812) <= 16 - v17 )
          {
            *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * v26 + 2676) << *(_BYTE *)(a1 + 5812);
            v4 = *(_DWORD *)(a1 + 5812) + v17;
          }
          else
          {
            v12 = *(unsigned __int16 *)(a1 + 4 * v26 + 2676);
            *(_WORD *)(a1 + 5808) |= v12 << *(_BYTE *)(a1 + 5812);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
            *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
            *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v12 >> (16 - *(_BYTE *)(a1 + 5812));
            v4 = *(_DWORD *)(a1 + 5812) + v17 - 16;
          }
          *(_DWORD *)(a1 + 5812) = v4;
          --v24;
        }
        while ( v24 );
      }
      v24 = 0;
      v27 = v26;
      if ( v25 )
      {
        if ( v26 == v25 )
        {
          v23 = 6;
          v22 = 3;
        }
        else
        {
          v23 = 7;
          v22 = 4;
        }
      }
      else
      {
        v23 = 138;
        v22 = 3;
      }
    }
  }
  return result;
}

//----- (080BD02E) --------------------------------------------------------
int __cdecl sub_80BD02E(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  sub_80BC4D5((_WORD *)a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_80BC4D5((_WORD *)a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_80BC136((_DWORD *)a1, a1 + 2856);
  for ( i = 18; i > 2 && !*(_WORD *)(a1 + 4 * *(unsigned __int8 *)(i + 135154860) + 2678); --i )
    ;
  *(_DWORD *)(a1 + 5792) += 3 * i + 17;
  return i;
}

//----- (080BD0ED) --------------------------------------------------------
int __cdecl sub_80BD0ED(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( *(int *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a2 - 257) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a2 - 257) >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  if ( *(int *)(a1 + 5812) <= 11 )
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    v5 = *(_DWORD *)(a1 + 5812) + 5;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a3 - 1) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a3 - 1) >> (16 - *(_BYTE *)(a1 + 5812));
    v5 = *(_DWORD *)(a1 + 5812) - 11;
  }
  *(_DWORD *)(a1 + 5812) = v5;
  if ( *(int *)(a1 + 5812) <= 12 )
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    v6 = *(_DWORD *)(a1 + 5812) + 4;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= (a4 - 4) << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 - 4) >> (16 - *(_BYTE *)(a1 + 5812));
    v6 = *(_DWORD *)(a1 + 5812) - 12;
  }
  *(_DWORD *)(a1 + 5812) = v6;
  for ( i = 0; i < a4; ++i )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135154860) + 2678) << *(_BYTE *)(a1 + 5812);
      v7 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      v9 = *(unsigned __int16 *)(a1 + 4 * *(unsigned __int8 *)(i + 135154860) + 2678);
      *(_WORD *)(a1 + 5808) |= v9 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v9 >> (16 - *(_BYTE *)(a1 + 5812));
      v7 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v7;
  }
  sub_80BC668(a1, a1 + 140, a2 - 1);
  return sub_80BC668(a1, a1 + 2432, a3 - 1);
}

//----- (080BD591) --------------------------------------------------------
int *__cdecl sub_80BD591(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax

  if ( *(int *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    v4 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= a4 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)a4 >> (16 - *(_BYTE *)(a1 + 5812));
    v4 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v4;
  return sub_80BEA04((_DWORD *)a1, a2, a3, 1);
}

//----- (080BD6BF) --------------------------------------------------------
int __cdecl sub_80BD6BF(int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int result; // eax

  if ( *(int *)(a1 + 5812) <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    v1 = *(_DWORD *)(a1 + 5812) + 3;
  }
  else
  {
    *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
    v1 = *(_DWORD *)(a1 + 5812) - 13;
  }
  *(_DWORD *)(a1 + 5812) = v1;
  if ( *(int *)(a1 + 5812) <= 9 )
  {
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    v2 = *(_DWORD *)(a1 + 5812) + 7;
  }
  else
  {
    *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 0;
    v2 = *(_DWORD *)(a1 + 5812) - 9;
  }
  *(_DWORD *)(a1 + 5812) = v2;
  sub_80BE8AA(a1);
  if ( *(_DWORD *)(a1 + 5804) - *(_DWORD *)(a1 + 5812) + 11 <= 8 )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      v3 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= 2 << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = 2 >> (16 - *(_BYTE *)(a1 + 5812));
      v3 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v3;
    if ( *(int *)(a1 + 5812) <= 9 )
    {
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      v4 = *(_DWORD *)(a1 + 5812) + 7;
    }
    else
    {
      *(_WORD *)(a1 + 5808) = *(_WORD *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = 0;
      v4 = *(_DWORD *)(a1 + 5812) - 9;
    }
    *(_DWORD *)(a1 + 5812) = v4;
    sub_80BE8AA(a1);
  }
  result = a1;
  *(_DWORD *)(a1 + 5804) = 7;
  return result;
}

//----- (080BDB2D) --------------------------------------------------------
int __cdecl sub_80BDB2D(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int result; // eax
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v8 = a3 + 5;
    v9 = a3 + 5;
  }
  else
  {
    if ( *(_BYTE *)(a1 + 28) == 2 )
      sub_80BE7E2(a1);
    sub_80BC136((_DWORD *)a1, a1 + 2832);
    sub_80BC136((_DWORD *)a1, a1 + 2844);
    v7 = sub_80BD02E(a1);
    v9 = (unsigned int)(*(_DWORD *)(a1 + 5792) + 10) >> 3;
    v8 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
    if ( v8 <= v9 )
      v9 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  }
  if ( a3 + 4 <= v9 && a2 )
  {
    sub_80BD591(a1, a2, a3, a4);
  }
  else if ( v8 == v9 )
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      v4 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 2) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 + 2) >> (16 - *(_BYTE *)(a1 + 5812));
      v4 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v4;
    sub_80BE037(a1, (int)&unk_80E4CC0, (int)&unk_80E5140);
  }
  else
  {
    if ( *(int *)(a1 + 5812) <= 13 )
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      v5 = *(_DWORD *)(a1 + 5812) + 3;
    }
    else
    {
      *(_WORD *)(a1 + 5808) |= (a4 + 4) << *(_BYTE *)(a1 + 5812);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
      *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)(a4 + 4) >> (16 - *(_BYTE *)(a1 + 5812));
      v5 = *(_DWORD *)(a1 + 5812) - 13;
    }
    *(_DWORD *)(a1 + 5812) = v5;
    sub_80BD0ED(a1, *(_DWORD *)(a1 + 2836) + 1, *(_DWORD *)(a1 + 2848) + 1, v7 + 1);
    sub_80BE037(a1, a1 + 140, a1 + 2432);
  }
  result = sub_80BBAC5(a1);
  if ( a4 )
    result = sub_80BE96D(a1);
  return result;
}

//----- (080BE037) --------------------------------------------------------
int __cdecl sub_80BE037(int a1, int a2, int a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  int v10; // [esp+0h] [ebp-28h]
  int v11; // [esp+4h] [ebp-24h]
  int v12; // [esp+4h] [ebp-24h]
  int v13; // [esp+4h] [ebp-24h]
  int v14; // [esp+4h] [ebp-24h]
  int v15; // [esp+8h] [ebp-20h]
  int v16; // [esp+8h] [ebp-20h]
  int v17; // [esp+8h] [ebp-20h]
  int v18; // [esp+8h] [ebp-20h]
  int v19; // [esp+Ch] [ebp-1Ch]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  unsigned int i; // [esp+14h] [ebp-14h]
  int v23; // [esp+18h] [ebp-10h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  unsigned int v26; // [esp+1Ch] [ebp-Ch]
  unsigned int v27; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i < *(_DWORD *)(a1 + 5784); ++i )
  {
    v25 = *(unsigned __int16 *)(*(_DWORD *)(a1 + 5788) + 2 * i);
    v23 = *(unsigned __int8 *)(*(_DWORD *)(a1 + 5776) + i);
    if ( v25 )
    {
      v21 = *(unsigned __int8 *)(v23 + 135156672);
      v12 = *(unsigned __int16 *)(a2 + 4 * v21 + 1030);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v12 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v21 + 1028) << *(_BYTE *)(a1 + 5812);
        v4 = *(_DWORD *)(a1 + 5812) + v12;
      }
      else
      {
        v16 = *(unsigned __int16 *)(a2 + 4 * v21 + 1028);
        *(_WORD *)(a1 + 5808) |= v16 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v16 >> (16 - *(_BYTE *)(a1 + 5812));
        v4 = *(_DWORD *)(a1 + 5812) + v12 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v4;
      v19 = dword_80E4B60[v21];
      if ( v19 )
      {
        v24 = v23 - dword_80E54C0[v21];
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v19 )
        {
          *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
          v5 = *(_DWORD *)(a1 + 5812) + v19;
        }
        else
        {
          *(_WORD *)(a1 + 5808) |= v24 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
          *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v24 >> (16 - *(_BYTE *)(a1 + 5812));
          v5 = *(_DWORD *)(a1 + 5812) + v19 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v5;
      }
      v26 = v25 - 1;
      if ( v26 > 0xFF )
        v10 = (unsigned __int8)byte_80E52C0[v26 >> 7];
      else
        v10 = *(unsigned __int8 *)(v26 + 135156160);
      v13 = *(unsigned __int16 *)(a3 + 4 * v10 + 2);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v13 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a3 + 4 * v10) << *(_BYTE *)(a1 + 5812);
        v6 = *(_DWORD *)(a1 + 5812) + v13;
      }
      else
      {
        v17 = *(unsigned __int16 *)(a3 + 4 * v10);
        *(_WORD *)(a1 + 5808) |= v17 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v17 >> (16 - *(_BYTE *)(a1 + 5812));
        v6 = *(_DWORD *)(a1 + 5812) + v13 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v6;
      v20 = dword_80E4BE0[v10];
      if ( v20 )
      {
        v27 = v26 - dword_80E5540[v10];
        if ( *(_DWORD *)(a1 + 5812) <= 16 - v20 )
        {
          *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
          v7 = *(_DWORD *)(a1 + 5812) + v20;
        }
        else
        {
          *(_WORD *)(a1 + 5808) |= v27 << *(_BYTE *)(a1 + 5812);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
          *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
          *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v27 >> (16 - *(_BYTE *)(a1 + 5812));
          v7 = *(_DWORD *)(a1 + 5812) + v20 - 16;
        }
        *(_DWORD *)(a1 + 5812) = v7;
      }
    }
    else
    {
      v15 = *(unsigned __int16 *)(a2 + 4 * v23 + 2);
      if ( *(_DWORD *)(a1 + 5812) <= 16 - v15 )
      {
        *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 4 * v23) << *(_BYTE *)(a1 + 5812);
        v3 = *(_DWORD *)(a1 + 5812) + v15;
      }
      else
      {
        v11 = *(unsigned __int16 *)(a2 + 4 * v23);
        *(_WORD *)(a1 + 5808) |= v11 << *(_BYTE *)(a1 + 5812);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
        *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
        *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v11 >> (16 - *(_BYTE *)(a1 + 5812));
        v3 = *(_DWORD *)(a1 + 5812) + v15 - 16;
      }
      *(_DWORD *)(a1 + 5812) = v3;
    }
  }
  v14 = *(unsigned __int16 *)(a2 + 1026);
  if ( *(_DWORD *)(a1 + 5812) <= 16 - v14 )
  {
    *(_WORD *)(a1 + 5808) |= *(unsigned __int16 *)(a2 + 1024) << *(_BYTE *)(a1 + 5812);
    v8 = *(_DWORD *)(a1 + 5812) + v14;
  }
  else
  {
    v18 = *(unsigned __int16 *)(a2 + 1024);
    *(_WORD *)(a1 + 5808) |= v18 << *(_BYTE *)(a1 + 5812);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = (int)(unsigned __int16)v18 >> (16 - *(_BYTE *)(a1 + 5812));
    v8 = *(_DWORD *)(a1 + 5812) + v14 - 16;
  }
  *(_DWORD *)(a1 + 5812) = v8;
  result = a1;
  *(_DWORD *)(a1 + 5804) = *(unsigned __int16 *)(a2 + 1026);
  return result;
}
// 80E4B60: using guessed type int dword_80E4B60[];
// 80E4BE0: using guessed type int dword_80E4BE0[];

//----- (080BE7E2) --------------------------------------------------------
bool __cdecl sub_80BE7E2(int a1)
{
  bool result; // al
  unsigned int v2; // [esp+0h] [ebp-Ch]
  unsigned int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  v3 = 0;
  v2 = 0;
  while ( v4 <= 6 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 127 )
    v3 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  while ( v4 <= 255 )
    v2 += *(unsigned __int16 *)(a1 + 4 * v4++ + 140);
  result = v2 <= v3 >> 2;
  *(_BYTE *)(a1 + 28) = result;
  return result;
}

//----- (080BE87C) --------------------------------------------------------
unsigned int __cdecl sub_80BE87C(unsigned int a1, int a2)
{
  unsigned int v3; // [esp+0h] [ebp-4h]
  int v4; // [esp+0h] [ebp-4h]

  v3 = 0;
  do
  {
    v4 = a1 & 1 | v3;
    a1 >>= 1;
    v3 = 2 * v4;
    --a2;
  }
  while ( a2 > 0 );
  return v3 >> 1;
}

//----- (080BE8AA) --------------------------------------------------------
int __cdecl sub_80BE8AA(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 5812) == 16 )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
    *(_WORD *)(a1 + 5808) = 0;
    result = a1;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    result = a1;
    if ( *(int *)(a1 + 5812) > 7 )
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
      *(_WORD *)(a1 + 5808) >>= 8;
      result = *(_DWORD *)(a1 + 5812) - 8;
      *(_DWORD *)(a1 + 5812) = result;
    }
  }
  return result;
}

//----- (080BE96D) --------------------------------------------------------
int __cdecl sub_80BE96D(int a1)
{
  int result; // eax

  if ( *(int *)(a1 + 5812) <= 8 )
  {
    if ( *(int *)(a1 + 5812) > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = HIBYTE(*(_WORD *)(a1 + 5808));
  }
  *(_WORD *)(a1 + 5808) = 0;
  result = a1;
  *(_DWORD *)(a1 + 5812) = 0;
  return result;
}

//----- (080BEA04) --------------------------------------------------------
int *__cdecl sub_80BEA04(_DWORD *a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax

  sub_80BE96D((int)a1);
  a1[1451] = 8;
  if ( a4 )
  {
    *(_BYTE *)(a1[2] + a1[5]++) = a3;
    *(_BYTE *)(a1[2] + a1[5]++) = BYTE1(a3);
    *(_BYTE *)(a1[2] + a1[5]++) = ~(_BYTE)a3;
    *(_BYTE *)(a1[2] + a1[5]++) = (unsigned __int16)~(_WORD)a3 >> 8;
  }
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    *(_BYTE *)(a1[2] + a1[5]++) = *a2++;
  }
  return result;
}

//----- (080BEBB4) --------------------------------------------------------
int __cdecl sub_80BEBB4(FILE *stream, int a2)
{
  __int16 ptr[3]; // [esp+12h] [ebp-6h] BYREF

  fread(ptr, 2u, 1u, stream);
  *(_DWORD *)a2 = (__int16)sub_80C06B7(ptr[0]);
  return 0;
}

//----- (080BEBFA) --------------------------------------------------------
int __cdecl sub_80BEBFA(FILE *stream, int a2)
{
  int ptr; // [esp+10h] [ebp-8h] BYREF

  fread(&ptr, 4u, 1u, stream);
  *(_DWORD *)a2 = sub_80C06CA(ptr);
  return 0;
}

//----- (080BEC3E) --------------------------------------------------------
int __cdecl sub_80BEC3E(char *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-Ch]
  char v5; // [esp+Ah] [ebp-2h]
  char v6; // [esp+Bh] [ebp-1h]

  while ( 1 )
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( v6 > 96 && v6 <= 122 )
      v6 -= 32;
    if ( v5 > 96 && v5 <= 122 )
      v5 -= 32;
    if ( !v6 )
      break;
    if ( !v5 )
      return 1;
    if ( v6 < v5 )
      return -1;
    if ( v6 > v5 )
      return 1;
  }
  if ( v5 )
    v3 = -1;
  else
    v3 = 0;
  return v3;
}

//----- (080BECE1) --------------------------------------------------------
int __cdecl sub_80BECE1(char *s1, char *s2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( !a3 )
    a3 = 1;
  if ( a3 == 1 )
    v4 = strcmp(s1, s2);
  else
    v4 = sub_80BEC3E(s1, s2);
  return v4;
}

//----- (080BED2B) --------------------------------------------------------
size_t __cdecl sub_80BED2B(FILE *stream)
{
  int v1; // edx
  size_t v3; // [esp+10h] [ebp-28h]
  size_t v5; // [esp+18h] [ebp-20h]
  int off; // [esp+1Ch] [ebp-1Ch]
  size_t v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]
  unsigned int v9; // [esp+2Ch] [ebp-Ch]
  unsigned int v10; // [esp+30h] [ebp-8h]
  void *ptr; // [esp+34h] [ebp-4h]

  v8 = 0xFFFF;
  v7 = 0;
  if ( fseek(stream, 0, 2) )
    return 0;
  v10 = ftell(stream);
  if ( v10 < 0xFFFF )
    v8 = v10;
  ptr = malloc(0x404u);
  if ( !ptr )
    return 0;
  v9 = 4;
  do
  {
    if ( v9 >= v8 )
      break;
    if ( v9 + 1024 <= v8 )
      v9 += 1024;
    else
      v9 = v8;
    off = v10 - v9;
    v3 = v9;
    if ( v9 > 0x404 )
      v3 = 1028;
    if ( fseek(stream, off, 0) || fread(ptr, v3, 1u, stream) != 1 )
      break;
    v5 = v3 - 3;
    while ( 1 )
    {
      v1 = v5--;
      if ( v1 <= 0 )
        break;
      if ( *((_BYTE *)ptr + v5) == 80
        && *((_BYTE *)ptr + v5 + 1) == 75
        && *((_BYTE *)ptr + v5 + 2) == 5
        && *((_BYTE *)ptr + v5 + 3) == 6 )
      {
        v7 = off + v5;
        break;
      }
    }
  }
  while ( !v7 );
  free(ptr);
  return v7;
}

//----- (080BEEC9) --------------------------------------------------------
_DWORD *__cdecl sub_80BEEC9(char *filename, void *src)
{
  FILE *v4; // [esp+10h] [ebp-8h]
  _DWORD *dest; // [esp+14h] [ebp-4h]

  v4 = fopen(filename, "rb");
  if ( !v4 )
    return 0;
  dest = malloc(0x80u);
  sub_80D2FC8(dest, src, 0x80u);
  *dest = v4;
  dest[31] = 0;
  return dest;
}

//----- (080BEF3A) --------------------------------------------------------
int *__cdecl sub_80BEF3A(char *filename)
{
  int *v2; // [esp+1Ch] [ebp-ACh]
  int v3; // [esp+20h] [ebp-A8h]
  int v4; // [esp+24h] [ebp-A4h] BYREF
  int v5; // [esp+28h] [ebp-A0h] BYREF
  int v6; // [esp+2Ch] [ebp-9Ch] BYREF
  FILE *stream; // [esp+30h] [ebp-98h]
  int v8; // [esp+34h] [ebp-94h] BYREF
  int off; // [esp+38h] [ebp-90h]
  int *v10; // [esp+3Ch] [ebp-8Ch]
  int v11[34]; // [esp+40h] [ebp-88h] BYREF

  v3 = 0;
  stream = fopen(filename, "rb");
  if ( !stream )
    return 0;
  off = sub_80BED2B(stream);
  if ( !off )
    v3 = -1;
  if ( fseek(stream, off, 0) )
    v3 = -1;
  if ( sub_80BEBFA(stream, (int)&v8) )
    v3 = -1;
  if ( sub_80BEBB4(stream, (int)&v6) )
    v3 = -1;
  if ( sub_80BEBB4(stream, (int)&v5) )
    v3 = -1;
  if ( sub_80BEBB4(stream, (int)&v11[1]) )
    v3 = -1;
  if ( sub_80BEBB4(stream, (int)&v4) )
    v3 = -1;
  if ( v4 != v11[1] || v5 || v6 )
    v3 = -103;
  if ( sub_80BEBFA(stream, (int)&v11[8]) )
    v3 = -1;
  if ( sub_80BEBFA(stream, (int)&v11[9]) )
    v3 = -1;
  if ( sub_80BEBB4(stream, (int)&v11[2]) )
    v3 = -1;
  if ( off < (unsigned int)(v11[9] + v11[8]) && !v3 )
    v3 = -103;
  if ( v3 )
  {
    fclose(stream);
    v2 = 0;
  }
  else
  {
    v11[0] = (int)stream;
    v11[3] = off - (v11[8] + v11[9]);
    v11[7] = off;
    v11[31] = 0;
    v10 = (int *)malloc(0x80u);
    qmemcpy(v10, v11, 0x80u);
    sub_80BF83E(v10);
    v2 = v10;
  }
  return v2;
}

//----- (080BF21F) --------------------------------------------------------
int __cdecl sub_80BF21F(int a1)
{
  if ( !a1 )
    return -102;
  if ( *(_DWORD *)(a1 + 124) )
    sub_80C0539(a1);
  fclose(*(FILE **)a1);
  free((void *)a1);
  return 0;
}

//----- (080BF272) --------------------------------------------------------
int __cdecl sub_80BF272(int a1, _DWORD *a2)
{
  int v2; // edx

  if ( !a1 )
    return -102;
  v2 = *(_DWORD *)(a1 + 8);
  *a2 = *(_DWORD *)(a1 + 4);
  a2[1] = v2;
  return 0;
}

//----- (080BF2AA) --------------------------------------------------------
int __cdecl sub_80BF2AA(int a1, int *a2)
{
  int result; // eax

  a2[3] = BYTE2(a1) & 0x1F;
  a2[4] = ((unsigned __int16)(HIWORD(a1) & 0x1E0) >> 5) - 1;
  a2[5] = ((unsigned __int16)(HIWORD(a1) & 0xFE00) >> 9) + 1980;
  a2[2] = (unsigned __int16)(a1 & 0xF800) >> 11;
  a2[1] = (unsigned __int16)(a1 & 0x7E0) >> 5;
  result = 2 * (a1 & 0x1F);
  *a2 = result;
  return result;
}

//----- (080BF31E) --------------------------------------------------------
int __cdecl sub_80BF31E(int a1, int a2, int a3, void *ptr, int a5, void *a6, int a7, void *a8, int a9)
{
  int size; // [esp+1Ch] [ebp-7Ch]
  int sizea; // [esp+1Ch] [ebp-7Ch]
  int sizeb; // [esp+1Ch] [ebp-7Ch]
  int off; // [esp+20h] [ebp-78h]
  int offa; // [esp+20h] [ebp-78h]
  int v16; // [esp+24h] [ebp-74h] BYREF
  int v17; // [esp+28h] [ebp-70h]
  int v18; // [esp+2Ch] [ebp-6Ch] BYREF
  int v19[23]; // [esp+30h] [ebp-68h] BYREF
  FILE **v20; // [esp+8Ch] [ebp-Ch]

  v17 = 0;
  if ( !a1 )
    return -102;
  v20 = (FILE **)a1;
  if ( fseek(*(FILE **)a1, *(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 12), 0) )
    v17 = -1;
  if ( !v17 )
  {
    if ( sub_80BEBFA(*v20, (int)&v16) )
    {
      v17 = -1;
    }
    else if ( v16 != 33639248 )
    {
      v17 = -103;
    }
  }
  if ( sub_80BEBB4(*v20, (int)v19) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[1]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[2]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[3]) )
    v17 = -1;
  if ( sub_80BEBFA(*v20, (int)&v19[4]) )
    v17 = -1;
  sub_80BF2AA(v19[4], &v19[14]);
  if ( sub_80BEBFA(*v20, (int)&v19[5]) )
    v17 = -1;
  if ( sub_80BEBFA(*v20, (int)&v19[6]) )
    v17 = -1;
  if ( sub_80BEBFA(*v20, (int)&v19[7]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[8]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[9]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[10]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[11]) )
    v17 = -1;
  if ( sub_80BEBB4(*v20, (int)&v19[12]) )
    v17 = -1;
  if ( sub_80BEBFA(*v20, (int)&v19[13]) )
    v17 = -1;
  if ( sub_80BEBFA(*v20, (int)&v18) )
    v17 = -1;
  off = v19[8];
  if ( !v17 && ptr )
  {
    if ( v19[8] >= (unsigned int)a5 )
    {
      size = a5;
    }
    else
    {
      *((_BYTE *)ptr + v19[8]) = 0;
      size = v19[8];
    }
    if ( v19[8] && a5 && fread(ptr, size, 1u, *v20) != 1 )
      v17 = -1;
    off -= size;
  }
  if ( v17 || !a6 )
  {
    offa = v19[9] + off;
  }
  else
  {
    if ( v19[9] >= (unsigned int)a7 )
      sizea = a7;
    else
      sizea = v19[9];
    if ( off )
    {
      if ( fseek(*v20, off, 1) )
        v17 = -1;
      else
        off = 0;
    }
    if ( v19[9] && a7 && fread(a6, sizea, 1u, *v20) != 1 )
      v17 = -1;
    offa = v19[9] - sizea + off;
  }
  if ( !v17 && a8 )
  {
    if ( v19[10] >= (unsigned int)a9 )
    {
      sizeb = a9;
    }
    else
    {
      *((_BYTE *)a8 + v19[10]) = 0;
      sizeb = v19[10];
    }
    if ( offa && fseek(*v20, offa, 1) )
      v17 = -1;
    if ( v19[10] && a9 && fread(a8, sizeb, 1u, *v20) != 1 )
      v17 = -1;
  }
  if ( !v17 && a2 )
    qmemcpy((void *)a2, v19, 0x50u);
  if ( !v17 && a3 )
    *(_DWORD *)a3 = v18;
  return v17;
}

//----- (080BF7F2) --------------------------------------------------------
int __cdecl sub_80BF7F2(int a1, int a2, void *ptr, int a4, void *a5, int a6, void *a7, int a8)
{
  return sub_80BF31E(a1, a2, 0, ptr, a4, a5, a6, a7, a8);
}

//----- (080BF83E) --------------------------------------------------------
int __cdecl sub_80BF83E(_DWORD *a1)
{
  int v3; // [esp+34h] [ebp-4h]

  if ( !a1 )
    return -102;
  a1[5] = a1[9];
  a1[4] = 0;
  v3 = sub_80BF31E((int)a1, (int)(a1 + 10), (int)(a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v3 == 0;
  return v3;
}

//----- (080BF8E6) --------------------------------------------------------
int __cdecl sub_80BF8E6(_DWORD *a1)
{
  int v3; // [esp+28h] [ebp-10h]

  if ( !a1 )
    return -102;
  if ( !a1[6] )
    return -100;
  if ( a1[4] + 1 == a1[1] )
    return -100;
  a1[5] += a1[20] + a1[19] + a1[18] + 46;
  ++a1[4];
  v3 = sub_80BF31E((int)a1, (int)(a1 + 10), (int)(a1 + 30), 0, 0, 0, 0, 0, 0);
  a1[6] = v3 == 0;
  return v3;
}

//----- (080BF9D4) --------------------------------------------------------
int __cdecl sub_80BF9D4(int a1, _DWORD *a2)
{
  if ( !a1 )
    return -102;
  *a2 = *(_DWORD *)(a1 + 20);
  return 0;
}

//----- (080BFA06) --------------------------------------------------------
int __cdecl sub_80BFA06(int a1, int a2)
{
  if ( !a1 )
    return -102;
  *(_DWORD *)(a1 + 20) = a2;
  *(_DWORD *)(a1 + 24) = sub_80BF31E(a1, a1 + 40, a1 + 120, 0, 0, 0, 0, 0, 0) == 0;
  return 0;
}

//----- (080BFBC7) --------------------------------------------------------
int __cdecl sub_80BFBC7(int a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h] BYREF
  int v8; // [esp+18h] [ebp-10h] BYREF
  int v9; // [esp+1Ch] [ebp-Ch] BYREF
  int v10; // [esp+20h] [ebp-8h] BYREF
  int v11; // [esp+24h] [ebp-4h] BYREF

  v6 = 0;
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if ( fseek(*(FILE **)a1, *(_DWORD *)(a1 + 120) + *(_DWORD *)(a1 + 12), 0) )
    return -1;
  if ( sub_80BEBFA(*(FILE **)a1, (int)&v11) )
  {
    v6 = -1;
  }
  else if ( v11 != 67324752 )
  {
    v6 = -103;
  }
  if ( sub_80BEBB4(*(FILE **)a1, (int)&v10) )
    v6 = -1;
  if ( sub_80BEBB4(*(FILE **)a1, (int)&v9) )
    v6 = -1;
  if ( sub_80BEBB4(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 52) )
  {
    v6 = -103;
  }
  if ( !v6 && *(_DWORD *)(a1 + 52) && *(_DWORD *)(a1 + 52) != 8 )
    v6 = -103;
  if ( sub_80BEBFA(*(FILE **)a1, (int)&v10) )
    v6 = -1;
  if ( sub_80BEBFA(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 60) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80BEBFA(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 64) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80BEBFA(*(FILE **)a1, (int)&v10) )
  {
    v6 = -1;
  }
  else if ( !v6 && v10 != *(_DWORD *)(a1 + 68) && (v9 & 8) == 0 )
  {
    v6 = -103;
  }
  if ( sub_80BEBB4(*(FILE **)a1, (int)&v8) )
  {
    v6 = -1;
  }
  else if ( !v6 && v8 != *(_DWORD *)(a1 + 72) )
  {
    v6 = -103;
  }
  *a2 += v8;
  if ( sub_80BEBB4(*(FILE **)a1, (int)&v7) )
    v6 = -1;
  *a3 = *(_DWORD *)(a1 + 120) + v8 + 30;
  *a4 = v7;
  *a2 += v7;
  return v6;
}
// 80BFC28: conditional instruction was optimized away because of '%var_18.4==0'

//----- (080BFE6F) --------------------------------------------------------
int __cdecl sub_80BFE6F(_DWORD *a1)
{
  _DWORD *v1; // ebx
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h] BYREF
  int v5; // [esp+1Ch] [ebp-1Ch] BYREF
  void *ptr; // [esp+20h] [ebp-18h]
  _DWORD *v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h] BYREF
  _BOOL4 v9; // [esp+2Ch] [ebp-Ch]
  int v10; // [esp+30h] [ebp-8h]

  v10 = 0;
  if ( !a1 )
    return -102;
  v7 = a1;
  if ( !a1[6] )
    return -102;
  if ( v7[31] )
    sub_80C0539((int)a1);
  if ( sub_80BFBC7((int)v7, &v8, &v5, &v4) )
    return -103;
  ptr = malloc(0x6Cu);
  if ( !ptr )
    return -104;
  v1 = ptr;
  *v1 = malloc(0x4000u);
  *((_DWORD *)ptr + 17) = v5;
  *((_DWORD *)ptr + 18) = v4;
  *((_DWORD *)ptr + 19) = 0;
  if ( *(_DWORD *)ptr )
  {
    *((_DWORD *)ptr + 16) = 0;
    if ( v7[13] && v7[13] != 8 )
      v10 = -103;
    v9 = v7[13] == 0;
    *((_DWORD *)ptr + 21) = v7[15];
    *((_DWORD *)ptr + 20) = 0;
    *((_DWORD *)ptr + 25) = v7[13];
    *((_DWORD *)ptr + 24) = *v7;
    *((_DWORD *)ptr + 26) = v7[3];
    *((_DWORD *)ptr + 6) = 0;
    if ( !v9 )
    {
      *((_DWORD *)ptr + 9) = 0;
      *((_DWORD *)ptr + 10) = 0;
      *((_DWORD *)ptr + 11) = 0;
      v10 = sub_80BA32D((_DWORD *)ptr + 1, -15, "1.1.4", 56);
      if ( !v10 )
        *((_DWORD *)ptr + 16) = 1;
    }
    *((_DWORD *)ptr + 22) = v7[16];
    *((_DWORD *)ptr + 23) = v7[17];
    *((_DWORD *)ptr + 15) = v7[30] + v8 + 30;
    *((_DWORD *)ptr + 2) = 0;
    v7[31] = ptr;
    v3 = 0;
  }
  else
  {
    free(ptr);
    v3 = -104;
  }
  return v3;
}

//----- (080C007B) --------------------------------------------------------
int __cdecl sub_80C007B(int a1, int a2, unsigned int a3)
{
  int v4; // [esp+18h] [ebp-30h]
  unsigned int v5; // [esp+20h] [ebp-28h]
  _BYTE *v6; // [esp+24h] [ebp-24h]
  unsigned int i; // [esp+2Ch] [ebp-1Ch]
  size_t size; // [esp+30h] [ebp-18h]
  unsigned int sizea; // [esp+30h] [ebp-18h]
  size_t sizeb; // [esp+30h] [ebp-18h]
  int v11; // [esp+34h] [ebp-14h]
  int v12; // [esp+3Ch] [ebp-Ch]
  int v13; // [esp+40h] [ebp-8h]

  v13 = 0;
  v12 = 0;
  if ( !a1 )
    return -102;
  v11 = *(_DWORD *)(a1 + 124);
  if ( !v11 )
    return -102;
  if ( !*(_DWORD *)v11 )
    return -100;
  if ( !a3 )
    return 0;
  *(_DWORD *)(v11 + 16) = a2;
  *(_DWORD *)(v11 + 20) = a3;
  if ( a3 > *(_DWORD *)(v11 + 92) )
    *(_DWORD *)(v11 + 20) = *(_DWORD *)(v11 + 92);
  while ( *(_DWORD *)(v11 + 20) )
  {
    if ( !*(_DWORD *)(v11 + 8) && *(_DWORD *)(v11 + 88) )
    {
      size = 0x4000;
      if ( *(_DWORD *)(v11 + 88) < 0x4000u )
        size = *(_DWORD *)(v11 + 88);
      if ( !size )
        return 0;
      if ( fseek(*(FILE **)(v11 + 96), *(_DWORD *)(v11 + 60) + *(_DWORD *)(v11 + 104), 0) )
        return -1;
      if ( fread(*(void **)v11, size, 1u, *(FILE **)(v11 + 96)) != 1 )
        return -1;
      *(_DWORD *)(v11 + 60) += size;
      *(_DWORD *)(v11 + 88) -= size;
      *(_DWORD *)(v11 + 4) = *(_DWORD *)v11;
      *(_DWORD *)(v11 + 8) = size;
    }
    if ( *(_DWORD *)(v11 + 100) )
    {
      sizeb = *(_DWORD *)(v11 + 24);
      v6 = *(_BYTE **)(v11 + 16);
      v13 = sub_80BA4ED((unsigned __int8 **)(v11 + 4), 2);
      v5 = *(_DWORD *)(v11 + 24) - sizeb;
      *(_DWORD *)(v11 + 80) = sub_80B4DCA(*(_DWORD *)(v11 + 80), v6, v5);
      *(_DWORD *)(v11 + 92) -= v5;
      v12 += v5;
      if ( v13 == 1 )
        return v12;
      if ( v13 )
        break;
    }
    else
    {
      if ( *(_DWORD *)(v11 + 20) >= *(_DWORD *)(v11 + 8) )
        sizea = *(_DWORD *)(v11 + 8);
      else
        sizea = *(_DWORD *)(v11 + 20);
      for ( i = 0; i < sizea; ++i )
        *(_BYTE *)(i + *(_DWORD *)(v11 + 16)) = *(_BYTE *)(*(_DWORD *)(v11 + 4) + i);
      *(_DWORD *)(v11 + 80) = sub_80B4DCA(*(_DWORD *)(v11 + 80), *(_BYTE **)(v11 + 16), sizea);
      *(_DWORD *)(v11 + 92) -= sizea;
      *(_DWORD *)(v11 + 8) -= sizea;
      *(_DWORD *)(v11 + 20) -= sizea;
      *(_DWORD *)(v11 + 16) += sizea;
      *(_DWORD *)(v11 + 4) += sizea;
      *(_DWORD *)(v11 + 24) += sizea;
      v12 += sizea;
    }
  }
  if ( v13 )
    v4 = v13;
  else
    v4 = v12;
  return v4;
}

//----- (080C03B7) --------------------------------------------------------
int __cdecl sub_80C03B7(int a1)
{
  int v2; // [esp+0h] [ebp-Ch]
  int v3; // [esp+4h] [ebp-8h]

  if ( !a1 )
    return -102;
  v3 = *(_DWORD *)(a1 + 124);
  if ( v3 )
    v2 = *(_DWORD *)(v3 + 24);
  else
    v2 = -102;
  return v2;
}

//----- (080C0539) --------------------------------------------------------
int __cdecl sub_80C0539(int a1)
{
  void **ptr; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+14h] [ebp-4h]

  v4 = 0;
  if ( !a1 )
    return -102;
  ptr = *(void ***)(a1 + 124);
  if ( !ptr )
    return -102;
  if ( !ptr[23] && ptr[20] != ptr[21] )
    v4 = -105;
  free(*ptr);
  *ptr = 0;
  if ( ptr[16] )
    sub_80BA2B1(ptr + 1);
  ptr[16] = 0;
  free(ptr);
  *(_DWORD *)(a1 + 124) = 0;
  return v4;
}

//----- (080C06B7) --------------------------------------------------------
int __cdecl sub_80C06B7(__int16 a1)
{
  return a1;
}

//----- (080C06CA) --------------------------------------------------------
int __cdecl sub_80C06CA(int a1)
{
  return a1;
}

//----- (080C06F2) --------------------------------------------------------
void *__cdecl sub_80C06F2(int a1, int a2, int a3)
{
  return Z_MallocInternal(a3 * a2);
}

//----- (080C0709) --------------------------------------------------------
int __cdecl sub_80C0709(int a1, void *ptr)
{
  return Z_FreeInternal(ptr);
}

//----- (080C071C) --------------------------------------------------------
int __cdecl sub_80C071C(_DWORD *a1, _DWORD *a2)
{
  int v2; // et0
  int v3; // et0
  int v4; // et0
  int v5; // et0
  int v6; // et0
  int v7; // et0
  int v8; // et0
  int v9; // et0
  int v10; // et0
  int v11; // et0
  int v12; // et0
  int v13; // et0
  int v14; // et0
  int v15; // et0
  int v16; // et0
  int v17; // et0
  int v18; // et0
  int v19; // et0
  int v20; // et0
  int v21; // et0
  int v22; // et0
  int v23; // et0
  int v24; // et0
  int v25; // et0
  int v26; // et0
  int v27; // et0
  int v28; // et0
  int v29; // et0
  int v30; // et0
  int v31; // et0
  int v32; // et0
  int v33; // et0
  int v34; // et0
  int v35; // et0
  int v36; // et0
  int v37; // et0
  int v38; // et0
  int v39; // et0
  int v40; // et0
  int v41; // et0
  int v42; // et0
  int v43; // et0
  int v44; // et0
  int v45; // et0
  int v46; // et0
  int v47; // et0
  int v48; // et0
  int v49; // et0
  int result; // eax
  int v51; // [esp+0h] [ebp-10h]
  int v52; // [esp+0h] [ebp-10h]
  int v53; // [esp+0h] [ebp-10h]
  int v54; // [esp+0h] [ebp-10h]
  int v55; // [esp+0h] [ebp-10h]
  int v56; // [esp+0h] [ebp-10h]
  int v57; // [esp+0h] [ebp-10h]
  int v58; // [esp+0h] [ebp-10h]
  int v59; // [esp+0h] [ebp-10h]
  int v60; // [esp+0h] [ebp-10h]
  int v61; // [esp+0h] [ebp-10h]
  int v62; // [esp+0h] [ebp-10h]
  int v63; // [esp+0h] [ebp-10h]
  int v64; // [esp+0h] [ebp-10h]
  int v65; // [esp+0h] [ebp-10h]
  int v66; // [esp+0h] [ebp-10h]
  int v67; // [esp+0h] [ebp-10h]
  int v68; // [esp+4h] [ebp-Ch]
  int v69; // [esp+4h] [ebp-Ch]
  int v70; // [esp+4h] [ebp-Ch]
  int v71; // [esp+4h] [ebp-Ch]
  int v72; // [esp+4h] [ebp-Ch]
  int v73; // [esp+4h] [ebp-Ch]
  int v74; // [esp+4h] [ebp-Ch]
  int v75; // [esp+4h] [ebp-Ch]
  int v76; // [esp+4h] [ebp-Ch]
  int v77; // [esp+4h] [ebp-Ch]
  int v78; // [esp+4h] [ebp-Ch]
  int v79; // [esp+4h] [ebp-Ch]
  int v80; // [esp+4h] [ebp-Ch]
  int v81; // [esp+4h] [ebp-Ch]
  int v82; // [esp+4h] [ebp-Ch]
  int v83; // [esp+4h] [ebp-Ch]
  int v84; // [esp+8h] [ebp-8h]
  int v85; // [esp+8h] [ebp-8h]
  int v86; // [esp+8h] [ebp-8h]
  int v87; // [esp+8h] [ebp-8h]
  int v88; // [esp+8h] [ebp-8h]
  int v89; // [esp+8h] [ebp-8h]
  int v90; // [esp+8h] [ebp-8h]
  int v91; // [esp+8h] [ebp-8h]
  int v92; // [esp+8h] [ebp-8h]
  int v93; // [esp+8h] [ebp-8h]
  int v94; // [esp+8h] [ebp-8h]
  int v95; // [esp+8h] [ebp-8h]
  int v96; // [esp+8h] [ebp-8h]
  int v97; // [esp+8h] [ebp-8h]
  int v98; // [esp+8h] [ebp-8h]
  int v99; // [esp+8h] [ebp-8h]
  int v100; // [esp+8h] [ebp-8h]
  int v101; // [esp+Ch] [ebp-4h]
  int v102; // [esp+Ch] [ebp-4h]
  int v103; // [esp+Ch] [ebp-4h]
  int v104; // [esp+Ch] [ebp-4h]
  int v105; // [esp+Ch] [ebp-4h]
  int v106; // [esp+Ch] [ebp-4h]
  int v107; // [esp+Ch] [ebp-4h]
  int v108; // [esp+Ch] [ebp-4h]
  int v109; // [esp+Ch] [ebp-4h]
  int v110; // [esp+Ch] [ebp-4h]
  int v111; // [esp+Ch] [ebp-4h]
  int v112; // [esp+Ch] [ebp-4h]
  int v113; // [esp+Ch] [ebp-4h]
  int v114; // [esp+Ch] [ebp-4h]
  int v115; // [esp+Ch] [ebp-4h]
  int v116; // [esp+Ch] [ebp-4h]

  v84 = a1[1];
  v68 = a1[2];
  v51 = a1[3];
  v101 = v84 + __ROL4__(*a1 + *a2 + (v51 & ~v84 | v68 & v84) - 680876936, 7);
  v52 = v101 + __ROL4__(v51 + a2[1] + (v68 & ~v101 | v84 & v101) - 389564586, 12);
  v69 = v52 + __ROL4__(v68 + a2[2] + (v84 & ~v52 | v101 & v52) + 606105819, 17);
  v85 = v69 + __ROL4__(v84 + a2[3] + (v101 & ~v69 | v52 & v69) - 1044525330, 22);
  v102 = v85 + __ROL4__(v101 + a2[4] + (v52 & ~v85 | v69 & v85) - 176418897, 7);
  v53 = v102 + __ROL4__(v52 + a2[5] + (v69 & ~v102 | v85 & v102) + 1200080426, 12);
  v70 = v53 + __ROL4__(v69 + a2[6] + (v85 & ~v53 | v102 & v53) - 1473231341, 17);
  v86 = v70 + __ROL4__(v85 + a2[7] + (v102 & ~v70 | v53 & v70) - 45705983, 22);
  v103 = v86 + __ROL4__(v102 + a2[8] + (v53 & ~v86 | v70 & v86) + 1770035416, 7);
  v54 = v103 + __ROL4__(v53 + a2[9] + (v70 & ~v103 | v86 & v103) - 1958414417, 12);
  v71 = v54 + __ROL4__(v70 + a2[10] + (v86 & ~v54 | v103 & v54) - 42063, 17);
  v87 = v71 + __ROL4__(v86 + a2[11] + (v103 & ~v71 | v54 & v71) - 1990404162, 22);
  v104 = v87 + __ROL4__(v103 + a2[12] + (v54 & ~v87 | v71 & v87) + 1804603682, 7);
  v55 = v104 + __ROL4__(v54 + a2[13] + (v71 & ~v104 | v87 & v104) - 40341101, 12);
  v72 = v55 + __ROL4__(v71 + a2[14] + (v87 & ~v55 | v104 & v55) - 1502002290, 17);
  v2 = __ROL4__(v87 + a2[15] + (v104 & ~v72 | v55 & v72) + 1236535329, 22);
  v88 = v72 + v2;
  v3 = __ROL4__(v104 + a2[1] + (v72 & ~v55 | v55 & (v72 + v2)) - 165796510, 5);
  v105 = v88 + v3;
  v4 = __ROL4__(v55 + a2[6] + (v88 & ~v72 | v72 & (v88 + v3)) - 1069501632, 9);
  v56 = v105 + v4;
  v5 = __ROL4__(v72 + a2[11] + (v105 & ~v88 | v88 & (v105 + v4)) + 643717713, 14);
  v73 = v56 + v5;
  v6 = __ROL4__(v88 + *a2 + (v56 & ~v105 | v105 & (v56 + v5)) - 373897302, 20);
  v89 = v73 + v6;
  v7 = __ROL4__(v105 + a2[5] + (v73 & ~v56 | v56 & (v73 + v6)) - 701558691, 5);
  v106 = v89 + v7;
  v8 = __ROL4__(v56 + a2[10] + (v89 & ~v73 | v73 & (v89 + v7)) + 38016083, 9);
  v57 = v106 + v8;
  v9 = __ROL4__(v73 + a2[15] + (v106 & ~v89 | v89 & (v106 + v8)) - 660478335, 14);
  v74 = v57 + v9;
  v10 = __ROL4__(v89 + a2[4] + (v57 & ~v106 | v106 & (v57 + v9)) - 405537848, 20);
  v90 = v74 + v10;
  v11 = __ROL4__(v106 + a2[9] + (v74 & ~v57 | v57 & (v74 + v10)) + 568446438, 5);
  v107 = v90 + v11;
  v12 = __ROL4__(v57 + a2[14] + (v90 & ~v74 | v74 & (v90 + v11)) - 1019803690, 9);
  v58 = v107 + v12;
  v13 = __ROL4__(v74 + a2[3] + (v107 & ~v90 | v90 & (v107 + v12)) - 187363961, 14);
  v75 = v58 + v13;
  v14 = __ROL4__(v90 + a2[8] + (v58 & ~v107 | v107 & (v58 + v13)) + 1163531501, 20);
  v91 = v75 + v14;
  v15 = __ROL4__(v107 + a2[13] + (v75 & ~v58 | v58 & (v75 + v14)) - 1444681467, 5);
  v108 = v91 + v15;
  v16 = __ROL4__(v58 + a2[2] + (v91 & ~v75 | v75 & (v91 + v15)) - 51403784, 9);
  v59 = v108 + v16;
  v17 = __ROL4__(v75 + a2[7] + (v108 & ~v91 | v91 & (v108 + v16)) + 1735328473, 14);
  v76 = v59 + v17;
  v18 = __ROL4__(v91 + a2[12] + (v59 & ~v108 | v108 & (v59 + v17)) - 1926607734, 20);
  v92 = v76 + v18;
  v19 = __ROL4__(v108 + a2[5] + (v59 ^ (v76 + v18) ^ v76) - 378558, 4);
  v109 = v92 + v19;
  v20 = __ROL4__(v59 + a2[8] + (v76 ^ (v92 + v19) ^ v92) - 2022574463, 11);
  v60 = v109 + v20;
  v21 = __ROL4__(v76 + a2[11] + (v92 ^ (v109 + v20) ^ v109) + 1839030562, 16);
  v77 = v60 + v21;
  v22 = __ROL4__(v92 + a2[14] + (v109 ^ (v60 + v21) ^ v60) - 35309556, 23);
  v93 = v77 + v22;
  v23 = __ROL4__(v109 + a2[1] + (v60 ^ (v77 + v22) ^ v77) - 1530992060, 4);
  v110 = v93 + v23;
  v24 = __ROL4__(v60 + a2[4] + (v77 ^ (v93 + v23) ^ v93) + 1272893353, 11);
  v61 = v110 + v24;
  v25 = __ROL4__(v77 + a2[7] + (v93 ^ (v110 + v24) ^ v110) - 155497632, 16);
  v78 = v61 + v25;
  v26 = __ROL4__(v93 + a2[10] + (v110 ^ (v61 + v25) ^ v61) - 1094730640, 23);
  v94 = v78 + v26;
  v27 = __ROL4__(v110 + a2[13] + (v61 ^ (v78 + v26) ^ v78) + 681279174, 4);
  v111 = v94 + v27;
  v28 = __ROL4__(v61 + *a2 + (v78 ^ (v94 + v27) ^ v94) - 358537222, 11);
  v62 = v111 + v28;
  v29 = __ROL4__(v78 + a2[3] + (v94 ^ (v111 + v28) ^ v111) - 722521979, 16);
  v79 = v62 + v29;
  v30 = __ROL4__(v94 + a2[6] + (v111 ^ (v62 + v29) ^ v62) + 76029189, 23);
  v95 = v79 + v30;
  v31 = __ROL4__(v111 + a2[9] + (v62 ^ (v79 + v30) ^ v79) - 640364487, 4);
  v112 = v95 + v31;
  v32 = __ROL4__(v62 + a2[12] + (v79 ^ (v95 + v31) ^ v95) - 421815835, 11);
  v63 = v112 + v32;
  v33 = __ROL4__(v79 + a2[15] + (v95 ^ (v112 + v32) ^ v112) + 530742520, 16);
  v80 = v63 + v33;
  v34 = __ROL4__(v95 + a2[2] + (v112 ^ (v63 + v33) ^ v63) - 995338651, 23);
  v96 = v80 + v34;
  v35 = __ROL4__(v112 + *a2 + (v80 ^ ((v80 + v34) | ~v63)) - 198630844, 6);
  v113 = v96 + v35;
  v36 = __ROL4__(v63 + a2[7] + (v96 ^ ((v96 + v35) | ~v80)) + 1126891415, 10);
  v64 = v113 + v36;
  v37 = __ROL4__(v80 + a2[14] + (v113 ^ ((v113 + v36) | ~v96)) - 1416354905, 15);
  v81 = v64 + v37;
  v38 = __ROL4__(v96 + a2[5] + (v64 ^ ((v64 + v37) | ~v113)) - 57434055, 21);
  v97 = v81 + v38;
  v39 = __ROL4__(v113 + a2[12] + (v81 ^ ((v81 + v38) | ~v64)) + 1700485571, 6);
  v114 = v97 + v39;
  v40 = __ROL4__(v64 + a2[3] + (v97 ^ ((v97 + v39) | ~v81)) - 1894986606, 10);
  v65 = v114 + v40;
  v41 = __ROL4__(v81 + a2[10] + (v114 ^ ((v114 + v40) | ~v97)) - 1051523, 15);
  v82 = v65 + v41;
  v42 = __ROL4__(v97 + a2[1] + (v65 ^ ((v65 + v41) | ~v114)) - 2054922799, 21);
  v98 = v82 + v42;
  v43 = __ROL4__(v114 + a2[8] + (v82 ^ ((v82 + v42) | ~v65)) + 1873313359, 6);
  v115 = v98 + v43;
  v44 = __ROL4__(v65 + a2[15] + (v98 ^ ((v98 + v43) | ~v82)) - 30611744, 10);
  v66 = v115 + v44;
  v45 = __ROL4__(v82 + a2[6] + (v115 ^ ((v115 + v44) | ~v98)) - 1560198380, 15);
  v83 = v66 + v45;
  v46 = __ROL4__(v98 + a2[13] + (v66 ^ ((v66 + v45) | ~v115)) + 1309151649, 21);
  v99 = v83 + v46;
  v47 = __ROL4__(v115 + a2[4] + (v83 ^ ((v83 + v46) | ~v66)) - 145523070, 6);
  v116 = v99 + v47;
  v48 = __ROL4__(v66 + a2[11] + (v99 ^ ((v99 + v47) | ~v83)) - 1120210379, 10);
  v67 = v116 + v48;
  v49 = __ROL4__(v83 + a2[2] + (v116 ^ ((v116 + v48) | ~v99)) + 718787259, 15);
  v100 = v67 + v49 + __ROL4__(v99 + a2[9] + (v67 ^ ((v67 + v49) | ~v116)) - 343485551, 21);
  *a1 += v116;
  a1[1] += v100;
  a1[2] += v67 + v49;
  result = a1[3] + v67;
  a1[3] = result;
  return result;
}

//----- (080C14C6) --------------------------------------------------------
unsigned int *__cdecl sub_80C14C6(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int *result; // eax
  int v4; // [esp+14h] [ebp-54h]
  unsigned int v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  int v7[18]; // [esp+20h] [ebp-48h] BYREF

  v6 = (*a1 >> 3) & 0x3F;
  if ( *a1 + 8 * a3 < *a1 )
    ++a1[1];
  *a1 += 8 * a3;
  a1[1] += a3 >> 29;
  while ( 1 )
  {
    result = &a3;
    if ( --a3 == -1 )
      break;
    *((_BYTE *)a1 + v6 + 24) = *a2++;
    if ( ++v6 == 64 )
    {
      v5 = 0;
      v4 = 0;
      while ( v5 <= 0xF )
      {
        v7[v5++] = (BYTE1(a1[v4 + 6]) << 8) | (BYTE2(a1[v4 + 6]) << 16) | (HIBYTE(a1[v4 + 6]) << 24) | LOBYTE(a1[v4 + 6]);
        ++v4;
      }
      sub_80C071C(a1 + 2, v7);
      v6 = 0;
    }
  }
  return result;
}

//----- (080C174C) --------------------------------------------------------
int __cdecl PbSvAddEvent(int a1, int a2, int a3, int a4)
{
  return sub_80C1F9C((int)&unk_830AE80, a1, a2, a3, a4, 0);
}

//----- (080C1784) --------------------------------------------------------
unsigned int __cdecl sub_80C1784(int a1, char *s, char *src)
{
  size_t v3; // ebx
  unsigned int result; // eax
  int v5; // eax
  char dest[2072]; // [esp+10h] [ebp-818h] BYREF

  v3 = strlen(s);
  result = strlen(src) + v3;
  if ( result <= 0x800 )
  {
    strcpy(dest, s);
    strcat(dest, " ");
    strcat(dest, src);
    v5 = strlen(dest);
    result = PbSvAddEvent(15, a1, v5, (int)dest);
  }
  return result;
}

//----- (080C182C) --------------------------------------------------------
int *sub_80C182C()
{
  int *result; // eax

  sub_80C1F48(dword_830AE80);
  result = (int *)PbSvAddEvent(16, -1, 0, (int)&unk_80E5682);
  if ( !dword_830AFCC )
    result = sub_8091398("0");
  return result;
}
// 830AFCC: using guessed type int dword_830AFCC;

//----- (080C187A) --------------------------------------------------------
int sub_80C187A()
{
  return sub_80C205C((int)dword_830AE80, 0);
}

//----- (080C1896) --------------------------------------------------------
int PbServerForceProcess()
{
  return sub_80C205C((int)&unk_830AE80, -1);
}

//----- (080C18B2) --------------------------------------------------------
int __cdecl sub_80C18B2(int a1, int a2)
{
  return sub_80C1F9C((int)dword_830AE80, 51, -1, a2, a1, 0);
}

//----- (080C18EC) --------------------------------------------------------
int __cdecl PbPassConnectString(int a1, int a2)
{
  int result; // eax

  if ( dword_830AFD8 )
    result = dword_830AFD8(&unk_830AE80, a1, a2);
  return result;
}
// 830AFD8: using guessed type int (__cdecl *dword_830AFD8)(_DWORD, _DWORD, _DWORD);

//----- (080C191C) --------------------------------------------------------
int __cdecl sub_80C191C(int a1, int a2, int a3)
{
  int v4; // [esp+14h] [ebp-4h]

  if ( dword_830AFDC )
    v4 = dword_830AFDC(&unk_830AE80, a1, a2, a3);
  else
    v4 = 0;
  return v4;
}
// 830AFDC: using guessed type int (__cdecl *dword_830AFDC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (080C1960) --------------------------------------------------------
int sub_80C1960()
{
  return sub_80C1F9C((int)dword_830AE80, 113, -1, 0, 0, 0);
}

//----- (080C199C) --------------------------------------------------------
int sub_80C199C()
{
  return sub_80C1F9C((int)&unk_830AE80, 117, -1, 0, 0, 0);
}

//----- (080C19D8) --------------------------------------------------------
int sub_80C19D8()
{
  return sub_80C1F9C((int)&unk_830AE80, 118, -1, 0, 0, 0);
}

//----- (080C1A14) --------------------------------------------------------
void __cdecl sub_80C1A14(char *s, int a2)
{
  size_t v2; // [esp+14h] [ebp-4h]

  if ( dword_830AFE0 )
    dword_830AFE0(&unk_830AE80, s, a2);
  if ( dword_80F1C00 )
  {
    v2 = strlen(dword_80F1C00);
    if ( (int)(v2 + strlen(s)) < dword_80F1C04 )
      strcpy(&dword_80F1C00[v2], s);
  }
}
// 80F1C04: using guessed type int dword_80F1C04;
// 830AFE0: using guessed type int (__cdecl *dword_830AFE0)(_DWORD, _DWORD, _DWORD);

//----- (080C1A8C) --------------------------------------------------------
int __cdecl sub_80C1A8C(char *s1, char *nptr)
{
  int v2; // eax
  char v4; // [esp+Fh] [ebp-9h]
  char *v5; // [esp+10h] [ebp-8h]
  _BOOL4 v6; // [esp+14h] [ebp-4h]
  char *i; // [esp+14h] [ebp-4h]

  if ( !strcasecmp(s1, "set_sv_punkbuster") )
  {
    sub_8091398(nptr);
  }
  else if ( !strcasecmp(s1, "ConCapBufLen") )
  {
    dword_80F1C04 = (int)nptr;
  }
  else if ( !strcasecmp(s1, "ConCapBuf") )
  {
    dword_80F1C00 = nptr;
  }
  else if ( !strcasecmp(s1, "Cmd_Exec") )
  {
    v6 = strncasecmp(nptr, "pb_", 3u) == 0;
    Cmd_ExecuteString(nptr);
    if ( v6 )
      PbServerForceProcess();
  }
  else
  {
    for ( i = nptr; *i == 32; ++i )
      ;
    while ( *i && *i != 32 )
      ++i;
    v5 = i;
    while ( *i == 32 )
      ++i;
    if ( !strcasecmp(s1, "DropClient") )
    {
      v2 = atoi(nptr);
      sub_808AE1E(v2, (int)i);
    }
    else if ( !strcasecmp(s1, "Cvar_Set") )
    {
      v4 = *v5;
      *v5 = 0;
      sub_8073F2D(nptr, i);
      *v5 = v4;
    }
  }
  return 0;
}
// 80F1C04: using guessed type int dword_80F1C04;

//----- (080C1C22) --------------------------------------------------------
const char *__cdecl sub_80C1C22(int a1, char *nptr)
{
  int v2; // eax
  const char *v3; // eax
  int v6; // [esp+14h] [ebp-4h]
  int v7; // [esp+14h] [ebp-4h]

  nptr[255] = 0;
  if ( a1 != 102 )
  {
    if ( a1 <= 102 )
    {
      if ( a1 == 101 )
      {
        v2 = sub_80937FA();
        sub_80C1E3C(v2, nptr, 10);
      }
      return 0;
    }
    if ( a1 == 103 )
    {
      v3 = (const char *)Cvar_VariableString((int)nptr);
      strncpy(nptr, v3, 0xFFu);
    }
    else if ( a1 == 114 )
    {
      v7 = atoi(nptr);
      if ( !sub_8093934(v7, nptr) )
        return "PB Error: Query Failed";
    }
    return 0;
  }
  v6 = atoi(nptr);
  if ( sub_8093807(v6, nptr) )
    return 0;
  return "PB Error: Query Failed";
}

//----- (080C1D0C) --------------------------------------------------------
int sub_80C1D0C()
{
  if ( !strncasecmp(byte_830AE94, "[skipnotify]", 0xCu) )
    Com_Printf("%s: %s\n", (char)&unk_830AEA0);
  else
    sub_8094776((char)byte_830AE94);
  return 0;
}

//----- (080C1D6A) --------------------------------------------------------
int __cdecl sub_80C1D6A(size_t n, void *src, int a3)
{
  sub_80939CF(n, src, a3);
  return 0;
}

//----- (080C1D90) --------------------------------------------------------
int __cdecl sub_80C1D90(char *cp, unsigned __int16 a2, size_t n, void *buf)
{
  sub_80D4E49(cp, a2, n, buf);
  return 0;
}

//----- (080C1DC6) --------------------------------------------------------
int __cdecl sub_80C1DC6(int a1, int a2)
{
  int result; // eax

  if ( a2 == 0xFFFF && a1 == 1 )
    result = sub_80C210C((int)&unk_830AE80);
  if ( a2 == 0xFFFF && !a1 )
    result = sub_80C21AE((int)&unk_830AE80);
  return result;
}

//----- (080C1E04) --------------------------------------------------------
int ctor_001()
{
  return sub_80C1DC6(1, 0xFFFF);
}

//----- (080C1E20) --------------------------------------------------------
int dtor_001()
{
  return sub_80C1DC6(0, 0xFFFF);
}

//----- (080C1E3C) --------------------------------------------------------
char *__cdecl sub_80C1E3C(int a1, char *dest, int a3)
{
  char v4; // [esp+2Bh] [ebp-4Dh]
  unsigned int v6; // [esp+34h] [ebp-44h]
  int v7; // [esp+38h] [ebp-40h]
  unsigned int v8; // [esp+3Ch] [ebp-3Ch]
  char v9[56]; // [esp+40h] [ebp-38h] BYREF

  if ( !dest )
    return 0;
  strcpy(dest, "0");
  if ( a1 && a3 > 1 && a3 <= 36 )
  {
    v8 = a1;
    v7 = 34;
    v9[34] = 0;
    if ( a1 < 0 && a3 == 10 )
      v8 = -a1;
    while ( v8 )
    {
      v6 = v8 % a3;
      --v7;
      if ( v8 % a3 > 9 )
        v4 = v6 + 87;
      else
        v4 = v6 + 48;
      v9[v7] = v4;
      v8 /= (unsigned int)a3;
    }
    if ( a1 < 0 && a3 == 10 )
      v9[--v7] = 45;
    strcpy(dest, &v9[v7]);
  }
  return dest;
}

//----- (080C1F48) --------------------------------------------------------
_DWORD *__cdecl sub_80C1F48(_DWORD *a1)
{
  _DWORD *result; // eax

  sub_80C2238(a1);
  a1[79] = sub_80C1A8C;
  a1[80] = sub_80C1C22;
  a1[81] = sub_80C1D0C;
  a1[82] = sub_80C1D6A;
  result = a1;
  a1[85] = sub_80C1D90;
  return result;
}

//----- (080C1F9C) --------------------------------------------------------
int __cdecl sub_80C1F9C(int a1, int a2, int a3, int a4, int a5, int a6)
{
  const char *v7; // [esp+20h] [ebp-8h]
  const char *v8; // [esp+24h] [ebp-4h]

  if ( !*(_DWORD *)(a1 + 316) )
    return 0;
  if ( !*(_DWORD *)(a1 + 312) && *(_DWORD *)(a1 + 8) )
    return (*(int (__cdecl **)(int, int, int, int, int, int))(a1 + 332))(a1, a2, a3, a4, a5, a6);
  if ( *(_DWORD *)(a1 + 8) )
  {
    sub_80C2272(a1);
    return 0;
  }
  v8 = sub_80C22E6(a1);
  if ( !v8 )
    return (*(int (__cdecl **)(int, int, int, int, int, int))(a1 + 332))(a1, a2, a3, a4, a5, a6);
  if ( a2 == 113 || a2 == 114 )
    v7 = 0;
  else
    v7 = v8;
  return (int)v7;
}

//----- (080C205C) --------------------------------------------------------
int __cdecl sub_80C205C(int a1, int a2)
{
  int v3; // [esp+24h] [ebp-4h]

  if ( !*(_DWORD *)(a1 + 316) )
    return 0;
  if ( *(_DWORD *)(a1 + 8) )
  {
    if ( *(_DWORD *)(a1 + 312) )
    {
      sub_80C2272(a1);
      v3 = 0;
    }
    else
    {
      v3 = (*(int (__cdecl **)(int, int))(a1 + 336))(a1, a2);
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 312) )
      sub_80C1F9C(a1, 16, -1, 0, (int)&unk_80E5682, 0);
    v3 = 0;
  }
  return v3;
}

//----- (080C210C) --------------------------------------------------------
int __cdecl sub_80C210C(int a1)
{
  int result; // eax

  *(_DWORD *)a1 = 897252889;
  strcpy((char *)(a1 + 20), "PunkBuster Server");
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 312) = 1;
  sub_80C2238((_DWORD *)a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 332) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 340) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 348) = 0;
  result = a1;
  *(_DWORD *)(a1 + 352) = 0;
  return result;
}

//----- (080C21AE) --------------------------------------------------------
int __cdecl sub_80C21AE(int a1)
{
  sub_80C2272(a1);
  sub_80C21D8(a1);
  return sub_80C2202(a1);
}

//----- (080C21D8) --------------------------------------------------------
int __cdecl sub_80C21D8(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 12) )
    dlclose(*(void **)(a1 + 12));
  result = a1;
  *(_DWORD *)(a1 + 12) = 0;
  return result;
}

//----- (080C2202) --------------------------------------------------------
int __cdecl sub_80C2202(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 356) = 0;
  if ( *(_DWORD *)(a1 + 16) )
    dlclose(*(void **)(a1 + 16));
  result = a1;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

//----- (080C2238) --------------------------------------------------------
_DWORD *__cdecl sub_80C2238(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[79] = 0;
  a1[80] = 0;
  a1[81] = 0;
  result = a1;
  a1[82] = 0;
  return result;
}

//----- (080C2272) --------------------------------------------------------
int __cdecl sub_80C2272(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_DWORD *)(a1 + 332) = 0;
  *(_DWORD *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 348) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  if ( *(_DWORD *)(a1 + 8) )
    dlclose(*(void **)(a1 + 8));
  result = a1;
  *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (080C22E6) --------------------------------------------------------
const char *__cdecl sub_80C22E6(int a1)
{
  char *v1; // eax
  char *v2; // eax
  char *v3; // eax
  char *v4; // ebx
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // ebx
  char *v9; // eax
  char *v10; // eax
  const char *v12; // [esp+18h] [ebp-410h]
  FILE *stream; // [esp+1Ch] [ebp-40Ch]
  char v14[512]; // [esp+20h] [ebp-408h] BYREF
  char dest[520]; // [esp+220h] [ebp-208h] BYREF

  if ( *(_DWORD *)(a1 + 8) )
    return 0;
  sub_80C2272(a1);
  v1 = sub_80C2580(a1, dest, "pbsvnew.so");
  stream = fopen(v1, "rb");
  if ( stream )
  {
    fclose(stream);
    v2 = sub_80C2580(a1, dest, "pbsvold.so");
    sub_80C2564(v2);
    v3 = sub_80C2580(a1, dest, "pbsvold.so");
    remove(v3);
    v4 = sub_80C2580(a1, v14, "pbsvold.so");
    v5 = sub_80C2580(a1, dest, "pbsv.so");
    rename(v5, v4);
    v6 = sub_80C2580(a1, dest, "pbsv.so");
    sub_80C2564(v6);
    v7 = sub_80C2580(a1, dest, "pbsv.so");
    remove(v7);
    v8 = sub_80C2580(a1, v14, "pbsv.so");
    v9 = sub_80C2580(a1, dest, "pbsvnew.so");
    rename(v9, v8);
  }
  v10 = sub_80C2580(a1, dest, "pbsv.so");
  *(_DWORD *)(a1 + 8) = dlopen(v10, 1);
  if ( !*(_DWORD *)(a1 + 8) )
    return "PB Error: Server DLL Load Failure";
  *(_DWORD *)(a1 + 336) = dlsym(*(void **)(a1 + 8), "sa");
  *(_DWORD *)(a1 + 332) = dlsym(*(void **)(a1 + 8), "sb");
  if ( *(_DWORD *)(a1 + 336) && *(_DWORD *)(a1 + 332) )
  {
    *(_DWORD *)(a1 + 312) = 0;
    v12 = 0;
  }
  else
  {
    sub_80C2272(a1);
    v12 = "PB Error: Server DLL Get Procedure Failure";
  }
  return v12;
}

//----- (080C2564) --------------------------------------------------------
int __cdecl sub_80C2564(char *file)
{
  return chmod(file, 0x1FFu);
}

//----- (080C2580) --------------------------------------------------------
char *__cdecl sub_80C2580(int a1, char *dest, char *src)
{
  char s[280]; // [esp+10h] [ebp-118h] BYREF

  if ( !*(_BYTE *)(a1 + 52) )
  {
    sub_80C27C6(a1);
    sub_80C26CE(a1, s);
    if ( s[strlen(s) - 1] != 47 )
      strcat(s, "/");
    strcat(s, "pb/");
    if ( strcasecmp(s, (const char *)(a1 + 52)) && s[0] && *(_BYTE *)(a1 + 52) )
    {
      mkdir((const char *)(a1 + 52), 0x1FFu);
      sub_80C270E(a1, "pbsv.so", s);
      sub_80C270E(a1, "pbcl.so", s);
      sub_80C270E(a1, "pbag.so", s);
    }
  }
  strcpy(dest, (const char *)(a1 + 52));
  strcat(dest, src);
  return dest;
}

//----- (080C26CE) --------------------------------------------------------
int __cdecl sub_80C26CE(int a1, char *dest)
{
  int result; // eax
  char *v3; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 320) )
  {
    v3 = strcpy(dest, "fs_basepath");
    result = (*(int (__cdecl **)(int, char *))(a1 + 320))(103, v3);
  }
  return result;
}

//----- (080C270E) --------------------------------------------------------
int __cdecl sub_80C270E(int a1, char *src, char *a3)
{
  FILE *stream; // [esp+1Ch] [ebp-40Ch]
  char dest[512]; // [esp+20h] [ebp-408h] BYREF
  char filename[520]; // [esp+220h] [ebp-208h] BYREF

  strcpy(dest, (const char *)(a1 + 52));
  strcat(dest, src);
  stream = fopen(dest, "rb");
  if ( stream )
    return fclose(stream);
  strcpy(filename, a3);
  strcat(filename, src);
  return sub_80C2884(filename, dest, 0);
}

//----- (080C27C6) --------------------------------------------------------
char *__cdecl sub_80C27C6(int a1)
{
  char *result; // eax
  char *v2; // eax

  result = (char *)a1;
  if ( *(_DWORD *)(a1 + 320) )
  {
    v2 = strcpy((char *)(a1 + 52), "fs_homepath");
    (*(void (__cdecl **)(int, char *))(a1 + 320))(103, v2);
    if ( !*(_BYTE *)(a1 + 52) )
      getcwd((char *)(a1 + 52), 0xFBu);
    if ( *(_BYTE *)(a1 + 52) )
    {
      if ( *(_BYTE *)(a1 + strlen((const char *)(a1 + 52)) + 51) != 47 )
        strcat((char *)(a1 + 52), "/");
    }
    result = strcat((char *)(a1 + 52), "pb/");
  }
  return result;
}

//----- (080C2884) --------------------------------------------------------
int __cdecl sub_80C2884(char *filename, char *a2, int a3)
{
  size_t v4; // [esp+1Ch] [ebp-1Ch]
  size_t v5; // [esp+20h] [ebp-18h]
  void *ptr; // [esp+24h] [ebp-14h]
  int n; // [esp+28h] [ebp-10h]
  FILE *s; // [esp+2Ch] [ebp-Ch]
  int v9; // [esp+30h] [ebp-8h]
  FILE *stream; // [esp+34h] [ebp-4h]

  stream = fopen(filename, "rb");
  v9 = 0;
  if ( stream )
  {
    s = fopen(a2, "wb");
    if ( s )
    {
      fseek(stream, 0, 2);
      n = ftell(stream);
      if ( n > 0 && (!a3 || n < a3) )
      {
        ptr = (void *)operator new[](n);
        if ( ptr )
        {
          fseek(stream, 0, 0);
          v5 = fread(ptr, 1u, n, stream);
          v4 = fwrite(ptr, 1u, v5, s);
          operator delete(ptr);
          if ( v4 == n )
            v9 = 1;
        }
      }
      fclose(s);
    }
    fclose(stream);
  }
  return v9;
}

//----- (080C29F0) --------------------------------------------------------
int XAnimInit()
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  for ( i = 0; i <= 2047; ++i )
  {
    word_830B008[34 * i] = (i + 2047) % 2048;
    word_830B00A[34 * i] = (i + 1) % 2048;
  }
  dword_830B00C[0] = 0;
  dword_830B010[0] = 0;
  dword_830B028 = 0;
  dword_830B02C = 0;
  word_830B014 = 0;
  word_830B016 = 0;
  word_830B030 = 0;
  word_830B032 = 0;
  result = sub_80A3D64("end", 0);
  word_80F1C0A = result;
  dword_832D684 = 1;
  dword_832D688 = 1;
  return result;
}
// 80F1C0A: using guessed type __int16 word_80F1C0A;
// 830B008: using guessed type __int16 word_830B008[];
// 830B00A: using guessed type __int16 word_830B00A[];
// 830B00C: using guessed type int dword_830B00C[];
// 830B010: using guessed type int dword_830B010[];
// 830B014: using guessed type __int16 word_830B014;
// 830B016: using guessed type __int16 word_830B016;
// 830B028: using guessed type int dword_830B028;
// 830B02C: using guessed type int dword_830B02C;
// 830B030: using guessed type __int16 word_830B030;
// 830B032: using guessed type __int16 word_830B032;
// 832D684: using guessed type int dword_832D684;
// 832D688: using guessed type int dword_832D688;

//----- (080C2B26) --------------------------------------------------------
int sub_80C2B26()
{
  int result; // eax

  if ( word_80F1C0A )
  {
    result = sub_80A40A6(word_80F1C0A);
    word_80F1C0A = 0;
  }
  return result;
}
// 80F1C0A: using guessed type __int16 word_80F1C0A;

//----- (080C2B50) --------------------------------------------------------
int sub_80C2B50()
{
  int result; // eax

  result = sub_80A5AB4();
  word_80F1C08 = result;
  return result;
}
// 80F1C08: using guessed type __int16 word_80F1C08;

//----- (080C2B64) --------------------------------------------------------
int __cdecl sub_80C2B64(int (__cdecl *a1)(int))
{
  const char *v1; // eax
  int result; // eax
  unsigned __int16 i; // [esp+12h] [ebp-6h]
  unsigned __int16 v4; // [esp+14h] [ebp-4h]

  for ( i = FindNextSibling(word_80F1C08); i; i = FindNextSibling(i) )
  {
    v4 = GetVariableName(i);
    v1 = (const char *)SL_ConvertToString(v4);
    sub_80C2DDA(v1, a1);
  }
  result = sub_80A5C0A(word_80F1C08);
  word_80F1C08 = 0;
  return result;
}
// 80F1C08: using guessed type __int16 word_80F1C08;

//----- (080C2BDE) --------------------------------------------------------
unsigned __int16 *__cdecl sub_80C2BDE(int a1)
{
  unsigned __int16 *result; // eax
  __int16 j; // [esp+1Ah] [ebp-1Eh]
  unsigned __int16 *v3; // [esp+1Ch] [ebp-1Ch]
  unsigned __int16 v4; // [esp+22h] [ebp-16h]
  int v5; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  __int16 *v7; // [esp+30h] [ebp-8h]
  int v8; // [esp+34h] [ebp-4h]

  v8 = *(_DWORD *)(a1 + 4);
  if ( word_80F1C08 )
  {
    v4 = sub_80A3E4A(*(char **)a1, 0, 7);
    sub_80A61E0(word_80F1C08, v4);
    sub_80A40A6(v4);
  }
  v7 = *(__int16 **)(v8 + 12);
  v5 = *v7;
  for ( i = 0; i < v5; ++i )
    sub_80A40A6(v7[i + 1]);
  result = *(unsigned __int16 **)(v8 + 20);
  v3 = result;
  if ( result )
  {
    for ( j = 0; ; ++j )
    {
      result = v3;
      if ( !*v3 )
        break;
      sub_80A40A6(*v3);
      v3 += 4;
    }
  }
  return result;
}
// 80F1C08: using guessed type __int16 word_80F1C08;

//----- (080C2CC4) --------------------------------------------------------
char *__cdecl sub_80C2CC4(int a1, char *s, int a3, int a4)
{
  float v5; // [esp+Ch] [ebp-1Ch]
  float v6; // [esp+Ch] [ebp-1Ch]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v10; // [esp+20h] [ebp-8h]
  char *sa; // [esp+34h] [ebp+Ch]
  char *sb; // [esp+34h] [ebp+Ch]

  v10 = (unsigned __int8)*s;
  sa = s + 1;
  v7 = ((int (__cdecl *)(int))a4)(8 * v10 + 10);
  *(_DWORD *)(a3 + 20) = v7;
  for ( i = 0; i < v10; ++i )
  {
    *(_WORD *)v7 = sub_80A3D64(sa, 0);
    sb = &sa[strlen(sa) + 1];
    v8 = *(unsigned __int16 *)sb;
    sa = sb + 2;
    if ( *(_WORD *)a3 )
    {
      v5 = (float)v8;
      v6 = v5 / (long double)*(unsigned __int16 *)a3;
    }
    else
    {
      v6 = 0.0;
    }
    *(float *)(v7 + 4) = v6;
    v7 += 8;
  }
  *(_WORD *)v7 = sub_80A3D64("end", 0);
  *(_DWORD *)(v7 + 4) = 1065353216;
  *(_WORD *)(v7 + 8) = 0;
  return sa;
}

//----- (080C2DDA) --------------------------------------------------------
int __cdecl sub_80C2DDA(const char *a1, int (__cdecl *a2)(int))
{
  int result; // eax
  _DWORD **v3; // ebx
  _DWORD **v4; // ebx
  _DWORD **v5; // ebx
  _DWORD *v6; // ebx
  _DWORD *v7; // ebx
  _DWORD *v8; // ebx
  _DWORD *v9; // ebx
  _DWORD *v10; // ebx
  __int16 v11; // cx
  void *v12; // esp
  void *v13; // esp
  int v14; // ebx
  _DWORD **v15; // ebx
  _DWORD **v16; // ebx
  _DWORD **v17; // ebx
  _DWORD **v18; // ebx
  _DWORD **v19; // ebx
  _DWORD *v20; // ebx
  _DWORD *v21; // ebx
  _DWORD *v22; // ebx
  _DWORD *v23; // ebx
  _DWORD *v24; // ebx
  _DWORD *v25; // ebx
  _DWORD *v26; // ebx
  _BYTE v27[24]; // [esp+14h] [ebp-4B4h] BYREF
  float v28; // [esp+2Ch] [ebp-49Ch]
  int v29; // [esp+30h] [ebp-498h]
  int v30; // [esp+34h] [ebp-494h]
  void *dest; // [esp+38h] [ebp-490h]
  int v32; // [esp+3Ch] [ebp-48Ch]
  __int16 *v33; // [esp+40h] [ebp-488h]
  __int16 *v34; // [esp+44h] [ebp-484h]
  int i; // [esp+48h] [ebp-480h]
  size_t n; // [esp+4Ch] [ebp-47Ch]
  int v37; // [esp+50h] [ebp-478h]
  int v38; // [esp+54h] [ebp-474h]
  int v39; // [esp+58h] [ebp-470h]
  int v40; // [esp+60h] [ebp-468h] BYREF
  int v41; // [esp+64h] [ebp-464h]
  bool v42; // [esp+6Fh] [ebp-459h]
  int v43; // [esp+70h] [ebp-458h]
  _BYTE *v44; // [esp+74h] [ebp-454h]
  _BYTE *v45; // [esp+78h] [ebp-450h]
  bool v46; // [esp+7Dh] [ebp-44Bh]
  char v47; // [esp+7Eh] [ebp-44Ah]
  char v48; // [esp+7Fh] [ebp-449h]
  int v49; // [esp+80h] [ebp-448h]
  __int16 v50; // [esp+86h] [ebp-442h]
  size_t v51; // [esp+88h] [ebp-440h]
  int v52; // [esp+8Ch] [ebp-43Ch]
  char s[1028]; // [esp+90h] [ebp-438h] BYREF
  int j; // [esp+494h] [ebp-34h]
  char *v55; // [esp+498h] [ebp-30h]
  void *src; // [esp+49Ch] [ebp-2Ch]
  int v57; // [esp+4A0h] [ebp-28h] BYREF
  _DWORD **v58; // [esp+4A4h] [ebp-24h]
  _DWORD **v59; // [esp+4A8h] [ebp-20h]
  unsigned __int16 v60; // [esp+4AEh] [ebp-1Ah]
  int v61; // [esp+4B0h] [ebp-18h]
  int v62; // [esp+4B4h] [ebp-14h]
  _WORD *v63; // [esp+4B8h] [ebp-10h]
  _WORD *v64; // [esp+4BCh] [ebp-Ch]

  v52 = sub_80650D2("xanim", (int)a1, (int)&unk_80E57E4);
  if ( !v52 )
    Com_Error(1, (char *)&byte_80E57EB, a1);
  result = v52;
  if ( !*(_DWORD *)(v52 + 4) )
  {
    sprintf(s, "xanim/%s", a1);
    if ( (FS_ReadFile(s, (int)&v57) & 0x80000000) != 0 )
      Com_Error(1, (char *)&byte_80E5811, a1);
    src = (void *)v57;
    v49 = (__int16)sub_80CC49A(*(_WORD *)v57);
    src = (char *)src + 2;
    if ( v49 != 14 )
    {
      FS_FreeFile((void *)v57);
      Com_Error(1, (char *)&byte_80E5840, a1, v49, 14);
    }
    LOWORD(v61) = sub_80CC49A(*(_WORD *)src);
    src = (char *)src + 2;
    HIWORD(v61) = sub_80CC49A(*(_WORD *)src);
    src = (char *)src + 2;
    v64 = (_WORD *)a2(2 * SHIWORD(v61) + 2);
    v63 = v64 + 1;
    *v64 = HIWORD(v61);
    v48 = *(_BYTE *)src;
    src = (char *)src + 1;
    v47 = v48 & 1;
    v46 = (v48 & 2) != 0;
    v50 = *(_WORD *)src;
    src = (char *)src + 2;
    v50 = sub_80CC49A(v50);
    v62 = a2(32);
    *(_DWORD *)(v62 + 12) = v64;
    *(float *)(v62 + 4) = (float)v50;
    *(_BYTE *)(v62 + 2) = v47;
    *(_BYTE *)(v62 + 3) = v46;
    if ( v47 )
      LOWORD(v30) = v61 + 1;
    else
      LOWORD(v30) = v61;
    v60 = v30;
    v42 = (unsigned __int16)v30 <= 0x100u;
    *(_WORD *)v62 = v30 - 1;
    v29 = v62;
    if ( *(_WORD *)v62 )
      v28 = *(float *)(v62 + 4) / (long double)*(unsigned __int16 *)v62;
    else
      v28 = 0.0;
    *(float *)(v29 + 8) = v28;
    if ( v46 )
    {
      v58 = (_DWORD **)a2(8);
      *(_DWORD *)(v62 + 24) = v58;
      HIWORD(v43) = *(_WORD *)src;
      src = (char *)src + 2;
      if ( HIWORD(v43) )
      {
        if ( HIWORD(v43) == 1 )
        {
          sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
          src = (char *)src + 2;
          v3 = v58;
          v3[1] = (_DWORD *)a2(8);
          *v58[1] = v40;
          *((_WORD *)v58[1] + 2) = 0;
        }
        else
        {
          if ( HIWORD(v43) >= v60 )
          {
            v5 = v58;
            v5[1] = (_DWORD *)a2(8);
          }
          else
          {
            v4 = v58;
            if ( v42 )
            {
              v4[1] = (_DWORD *)a2(HIWORD(v43) + 7);
              n = HIWORD(v43);
              memcpy((char *)v58[1] + 6, src, HIWORD(v43));
              src = (char *)src + HIWORD(v43);
            }
            else
            {
              v4[1] = (_DWORD *)a2(2 * HIWORD(v43) + 6);
              n = 2 * HIWORD(v43);
              memcpy((char *)v58[1] + 6, src, n);
              src = (char *)src + n;
            }
          }
          n = 4 * HIWORD(v43);
          v6 = v58[1];
          *v6 = a2(n);
          sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
          src = (char *)src + 2;
          *(_DWORD *)*v58[1] = v40;
          for ( i = 1; i < HIWORD(v43); ++i )
          {
            sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
            src = (char *)src + 2;
            *(_DWORD *)(*v58[1] + 4 * i) = v40;
          }
          for ( i = 1; i < HIWORD(v43); ++i )
          {
            v34 = (__int16 *)(*v58[1] + 4 * i);
            v33 = (__int16 *)(*v58[1] + 4 * i - 4);
            v32 = v34[1] * v33[1] + *v33 * *v34;
            if ( v32 < 0 )
            {
              *v34 = -*v34;
              v34[1] = -v34[1];
            }
          }
          *((_WORD *)v58[1] + 2) = HIWORD(v43) - 1;
        }
      }
      else
      {
        v58[1] = 0;
      }
      LOWORD(v43) = *(_WORD *)src;
      src = (char *)src + 2;
      if ( (_WORD)v43 )
      {
        if ( (_WORD)v43 == 1 )
        {
          v37 = *(_DWORD *)src;
          v38 = *((_DWORD *)src + 1);
          v39 = *((_DWORD *)src + 2);
          src = (char *)src + 12;
          v7 = v58;
          *v7 = a2(16);
          **v58 = v37;
          (*v58)[2] = v38;
          (*v58)[3] = v39;
          *((_WORD *)*v58 + 2) = 0;
        }
        else
        {
          if ( (unsigned __int16)v43 >= v60 )
          {
            v9 = v58;
            *v9 = a2(8);
          }
          else
          {
            v8 = v58;
            if ( v42 )
            {
              *v8 = a2((unsigned __int16)v43 + 7);
              n = (unsigned __int16)v43;
              memcpy((char *)*v58 + 6, src, (unsigned __int16)v43);
            }
            else
            {
              *v8 = a2(2 * (unsigned __int16)v43 + 6);
              n = 2 * (unsigned __int16)v43;
              memcpy((char *)*v58 + 6, src, n);
            }
            src = (char *)src + n;
          }
          n = 12 * (unsigned __int16)v43;
          v10 = *v58;
          *v10 = a2(n);
          for ( i = 0; i < (unsigned __int16)v43; ++i )
          {
            *(_DWORD *)(**v58 + 12 * i) = *(_DWORD *)src;
            *(_DWORD *)(**v58 + 12 * i + 4) = *((_DWORD *)src + 1);
            *(_DWORD *)(**v58 + 12 * i + 8) = *((_DWORD *)src + 2);
            src = (char *)src + 12;
          }
          *((_WORD *)*v58 + 2) = v43 - 1;
        }
      }
      else
      {
        *v58 = 0;
      }
    }
    v51 = ((SHIWORD(v61) - 1) >> 3) + 1;
    v55 = (char *)src;
    src = (char *)src + v51;
    dest = (void *)a2(v51);
    memcpy(dest, src, v51);
    src = (char *)src + v51;
    *(_DWORD *)(v62 + 28) = dest;
    for ( j = 0; j < SHIWORD(v61); ++j )
    {
      v51 = strlen((const char *)src) + 1;
      v11 = sub_80A388C(src, 0, v51);
      v63[j] = v11;
      src = (char *)src + v51;
    }
    v12 = alloca(16 * ((unsigned int)(8 * SHIWORD(v61) + 15) >> 4));
    v45 = v27;
    v13 = alloca(16 * ((unsigned int)(12 * SHIWORD(v61) + 15) >> 4));
    v44 = v27;
    v14 = v62;
    *(_DWORD *)(v14 + 16) = a2(8 * SHIWORD(v61));
    for ( j = 0; j < SHIWORD(v61); ++j )
    {
      HIBYTE(v30) = (v55[j >> 3] >> (j & 7)) & 1;
      BYTE2(v30) = (*((char *)dest + (j >> 3)) >> (j & 7)) & 1;
      v59 = (_DWORD **)(*(_DWORD *)(v62 + 16) + 8 * j);
      HIWORD(v43) = *(_WORD *)src;
      src = (char *)src + 2;
      if ( HIWORD(v43) )
      {
        if ( HIWORD(v43) == 1 )
        {
          if ( BYTE2(v30) )
          {
            sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
            src = (char *)src + 2;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -(__int16)v40;
              HIWORD(v40) = -HIWORD(v40);
            }
            v15 = v59;
            v15[1] = (_DWORD *)a2(8);
            *v59[1] = v40;
          }
          else
          {
            sub_80CC4E2((__int16 *)src, (__int16 *)&v40);
            src = (char *)src + 6;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -(__int16)v40;
              HIWORD(v40) = -HIWORD(v40);
              LOWORD(v41) = -(__int16)v41;
              HIWORD(v41) = -HIWORD(v41);
            }
            v16 = v59;
            v16[1] = (_DWORD *)a2(10);
            *v59[1] = v40;
            *(_DWORD *)((char *)v59[1] + 6) = v41;
          }
          *((_WORD *)v59[1] + 2) = 0;
        }
        else
        {
          if ( HIWORD(v43) >= v60 )
          {
            v19 = v59;
            v19[1] = (_DWORD *)a2(8);
          }
          else
          {
            if ( v42 )
            {
              n = HIWORD(v43) + 7;
              v17 = v59;
              v17[1] = (_DWORD *)a2(n);
              n = HIWORD(v43);
              memcpy((char *)v59[1] + 6, src, HIWORD(v43));
            }
            else
            {
              n = 2 * HIWORD(v43) + 6;
              v18 = v59;
              v18[1] = (_DWORD *)a2(n);
              n = 2 * HIWORD(v43);
              memcpy((char *)v59[1] + 6, src, n);
            }
            src = (char *)src + n;
          }
          if ( BYTE2(v30) )
          {
            n = 4 * HIWORD(v43);
            v20 = v59[1];
            *v20 = a2(n);
            sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
            src = (char *)src + 2;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -(__int16)v40;
              HIWORD(v40) = -HIWORD(v40);
            }
            *(_DWORD *)*v59[1] = v40;
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              sub_80CC5D2((__int16 *)src, (__int16 *)&v40);
              src = (char *)src + 2;
              *(_DWORD *)(*v59[1] + 4 * i) = v40;
            }
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              v34 = (__int16 *)(*v59[1] + 4 * i);
              v33 = (__int16 *)(*v59[1] + 4 * i - 4);
              v32 = v34[1] * v33[1] + *v33 * *v34;
              if ( v32 < 0 )
              {
                *v34 = -*v34;
                v34[1] = -v34[1];
              }
            }
          }
          else
          {
            n = 8 * HIWORD(v43);
            v21 = v59[1];
            *v21 = a2(n);
            sub_80CC4E2((__int16 *)src, (__int16 *)&v40);
            src = (char *)src + 6;
            if ( HIBYTE(v30) )
            {
              LOWORD(v40) = -(__int16)v40;
              HIWORD(v40) = -HIWORD(v40);
              LOWORD(v41) = -(__int16)v41;
              HIWORD(v41) = -HIWORD(v41);
            }
            *(_DWORD *)*v59[1] = v40;
            *(_DWORD *)(*v59[1] + 4) = v41;
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              sub_80CC4E2((__int16 *)src, (__int16 *)&v40);
              src = (char *)src + 6;
              *(_DWORD *)(*v59[1] + 8 * i) = v40;
              *(_DWORD *)(*v59[1] + 8 * i + 4) = v41;
            }
            for ( i = 1; i < HIWORD(v43); ++i )
            {
              v34 = (__int16 *)(*v59[1] + 8 * i);
              v33 = (__int16 *)(*v59[1] + 8 * i - 8);
              v32 = v34[1] * v33[1] + *v33 * *v34 + v34[3] * v33[3] + v33[2] * v34[2];
              if ( v32 < 0 )
              {
                *v34 = -*v34;
                v34[1] = -v34[1];
                v34[2] = -v34[2];
                v34[3] = -v34[3];
              }
            }
          }
          *((_WORD *)v59[1] + 2) = HIWORD(v43) - 1;
        }
      }
      else
      {
        v59[1] = 0;
      }
      LOWORD(v43) = *(_WORD *)src;
      src = (char *)src + 2;
      if ( (_WORD)v43 )
      {
        if ( (_WORD)v43 == 1 )
        {
          v37 = *(_DWORD *)src;
          v38 = *((_DWORD *)src + 1);
          v39 = *((_DWORD *)src + 2);
          src = (char *)src + 12;
          v22 = v59;
          *v22 = a2(16);
          **v59 = v37;
          (*v59)[2] = v38;
          (*v59)[3] = v39;
          *((_WORD *)*v59 + 2) = 0;
        }
        else
        {
          if ( (unsigned __int16)v43 >= v60 )
          {
            v25 = v59;
            *v25 = a2(8);
          }
          else
          {
            if ( v42 )
            {
              n = (unsigned __int16)v43 + 7;
              v23 = v59;
              *v23 = a2(n);
              n = (unsigned __int16)v43;
              memcpy((char *)*v59 + 6, src, (unsigned __int16)v43);
            }
            else
            {
              n = 2 * (unsigned __int16)v43 + 6;
              v24 = v59;
              *v24 = a2(n);
              n = 2 * (unsigned __int16)v43;
              memcpy((char *)*v59 + 6, src, n);
            }
            src = (char *)src + n;
          }
          n = 12 * (unsigned __int16)v43;
          v26 = *v59;
          *v26 = a2(n);
          for ( i = 0; i < (unsigned __int16)v43; ++i )
          {
            *(_DWORD *)(**v59 + 12 * i) = *(_DWORD *)src;
            *(_DWORD *)(**v59 + 12 * i + 4) = *((_DWORD *)src + 1);
            *(_DWORD *)(**v59 + 12 * i + 8) = *((_DWORD *)src + 2);
            src = (char *)src + 12;
          }
          *((_WORD *)*v59 + 2) = v43 - 1;
        }
      }
      else
      {
        *v59 = 0;
      }
    }
    src = sub_80C2CC4((int)a1, (char *)src, v62, (int)a2);
    FS_FreeFile((void *)v57);
    *(_DWORD *)(v52 + 4) = v62;
    result = v52;
    *(_DWORD *)(v52 + 8) = sub_80C2BDE;
  }
  return result;
}

//----- (080C41DC) --------------------------------------------------------
int __cdecl sub_80C41DC(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax
  int v4; // edx
  int result; // eax
  int v6; // [esp+10h] [ebp-8h]

  v6 = sub_80650D2("xanim", a3, (int)&unk_80E57E4);
  if ( !v6 )
    Com_Error(1, (char *)&byte_80E5873, a3);
  v3 = a1 + 8 * a2;
  *(_WORD *)(v3 + 8) = 0;
  v4 = v3 + 8;
  result = v6;
  *(_DWORD *)(v4 + 4) = v6;
  return result;
}

//----- (080C424E) --------------------------------------------------------
int __cdecl sub_80C424E(int a1, unsigned __int16 a2, int a3, __int16 a4, unsigned __int16 a5, __int16 a6)
{
  _WORD *v6; // eax
  int result; // eax
  _WORD *v8; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]

  v6 = (_WORD *)(a1 + 8 * a2);
  v8 = v6 + 4;
  v6[4] = a5;
  v6[6] = a6;
  v6[7] = a4;
  for ( i = 0; ; ++i )
  {
    result = a5;
    if ( i >= a5 )
      break;
    *(_WORD *)(a1 + 8 * (i + (unsigned __int16)v8[3]) + 10) = a2;
  }
  return result;
}

//----- (080C42D6) --------------------------------------------------------
_DWORD *__cdecl sub_80C42D6(int a1, int a2, int (__cdecl *a3)(int))
{
  _DWORD *result; // eax

  result = (_DWORD *)a3(8 * a2 + 8);
  *result = a1;
  result[1] = a2;
  return result;
}

//----- (080C4306) --------------------------------------------------------
_DWORD *__cdecl sub_80C4306(int a1, int (__cdecl *a2)(int))
{
  int n; // [esp+20h] [ebp-8h]
  _DWORD *s; // [esp+24h] [ebp-4h]

  n = 2 * *(_DWORD *)(a1 + 4) + 12 + 2 * (3 * *(_DWORD *)(a1 + 4) + 1);
  s = (_DWORD *)a2(n);
  sub_80D2FE9(s, 0, n);
  *s = a1;
  return s;
}

//----- (080C436C) --------------------------------------------------------
int __cdecl sub_80C436C(int a1, int (__cdecl *a2)(int, int))
{
  return a2(a1, 2 * *(_DWORD *)(*(_DWORD *)a1 + 4) + 12 + 2 * (3 * *(_DWORD *)(*(_DWORD *)a1 + 4) + 1));
}

//----- (080C43B4) --------------------------------------------------------
int __cdecl sub_80C43B4(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080C43BE) --------------------------------------------------------
int __cdecl sub_80C43BE(int a1, int a2, int a3)
{
  void *v3; // esp
  int v5; // [esp+10h] [ebp-48h] BYREF
  int i; // [esp+14h] [ebp-44h]
  size_t n; // [esp+18h] [ebp-40h]
  __int16 v8; // [esp+1Eh] [ebp-3Ah]
  __int16 *v9; // [esp+20h] [ebp-38h]
  __int16 *v10; // [esp+24h] [ebp-34h]
  __int16 *v11; // [esp+28h] [ebp-30h]
  __int16 *v12; // [esp+2Ch] [ebp-2Ch]
  int v13; // [esp+30h] [ebp-28h]
  int v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int v17; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  void *s2; // [esp+48h] [ebp-10h]

  v15 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4);
  v12 = *(__int16 **)(v15 + 12);
  v14 = *v12;
  v10 = v12 + 1;
  n = v14 + 16;
  v3 = alloca(16 * ((unsigned int)(v14 + 31) >> 4));
  s2 = &v5;
  for ( i = 0; i <= 3; ++i )
    *((_DWORD *)s2 + i) = 0;
  for ( j = v14 - 1; j >= 0; --j )
    *((_BYTE *)s2 + j + 16) = 127;
  v17 = 0;
  for ( i = 0; i < a3; ++i )
  {
    v11 = ***(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a2 + 4 * i) + 4) + 4);
    v9 = v11 + 1;
    v13 = *v11;
    v16 = 0;
    while ( v16 < v13 )
    {
      v8 = v9[v16];
      for ( j = v14 - 1; j >= 0; --j )
      {
        if ( v8 == v10[j] )
        {
          if ( *((_BYTE *)s2 + j + 16) == 127 )
          {
            *((_BYTE *)s2 + j + 16) = v17;
            *((_BYTE *)s2 + (v17 >> 3)) |= 1 << (v17 & 7);
          }
          break;
        }
      }
      ++v16;
      ++v17;
    }
  }
  return (unsigned __int16)sub_80A388C(s2, 0, n);
}

//----- (080C4580) --------------------------------------------------------
int __cdecl sub_80C4580(float a1, int a2, int a3, int a4)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]
  int v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+1Ch] [ebp+10h]

  v6 = 0;
  v5 = (int)((long double)a3 * a1);
  if ( a4 >= *(unsigned __int8 *)(a2 + v5) )
  {
    if ( a4 >= *(unsigned __int8 *)(a2 + v5 + 1) )
    {
      v7 = v5 + 1;
      do
      {
        while ( 1 )
        {
          v5 = (a3 + v7) / 2;
          if ( a4 < *(unsigned __int8 *)(a2 + v5) )
            break;
          if ( a4 < *(unsigned __int8 *)(a2 + v5 + 1) )
            return v5;
          v7 = v5 + 1;
        }
        a3 = (a3 + v7++) / 2;
      }
      while ( a4 >= *(unsigned __int8 *)(a2 + v7) );
      v5 = v7 - 1;
    }
  }
  else
  {
    v8 = (int)((long double)a3 * a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = (v8 + v6) / 2;
        if ( a4 >= *(unsigned __int8 *)(a2 + v5) )
          break;
        v8 = (v8 + v6) / 2;
      }
      if ( a4 < *(unsigned __int8 *)(a2 + v5 + 1) )
        break;
      v6 = v5 + 1;
      --v8;
      if ( a4 >= *(unsigned __int8 *)(a2 + v8) )
        return v8;
    }
  }
  return v5;
}

//----- (080C469E) --------------------------------------------------------
int __cdecl sub_80C469E(float a1, int a2, int a3, int a4)
{
  int v5; // [esp+4h] [ebp-8h]
  int v6; // [esp+8h] [ebp-4h]
  int v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+1Ch] [ebp+10h]

  v6 = 0;
  v5 = (int)((long double)a3 * a1);
  if ( a4 >= *(unsigned __int16 *)(a2 + 2 * v5) )
  {
    if ( a4 >= *(unsigned __int16 *)(a2 + 2 * v5 + 2) )
    {
      v7 = v5 + 1;
      do
      {
        while ( 1 )
        {
          v5 = (a3 + v7) / 2;
          if ( a4 < *(unsigned __int16 *)(a2 + 2 * v5) )
            break;
          if ( a4 < *(unsigned __int16 *)(a2 + 2 * v5 + 2) )
            return v5;
          v7 = v5 + 1;
        }
        a3 = (a3 + v7++) / 2;
      }
      while ( a4 >= *(unsigned __int16 *)(a2 + 2 * v7) );
      v5 = v7 - 1;
    }
  }
  else
  {
    v8 = (int)((long double)a3 * a1);
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = (v8 + v6) / 2;
        if ( a4 >= *(unsigned __int16 *)(a2 + 2 * v5) )
          break;
        v8 = (v8 + v6) / 2;
      }
      if ( a4 < *(unsigned __int16 *)(a2 + 2 * v5 + 2) )
        break;
      v6 = v5 + 1;
      --v8;
      if ( a4 >= *(unsigned __int16 *)(a2 + 2 * v8) )
        return v8;
    }
  }
  return v5;
}

//----- (080C47DE) --------------------------------------------------------
int __cdecl sub_80C47DE(int a1, int a2, float a3, float a4, int a5)
{
  int result; // eax
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  float v11; // [esp+2Ch] [ebp-4Ch]
  float v12; // [esp+2Ch] [ebp-4Ch]
  float v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+34h] [ebp-44h]
  int v19; // [esp+34h] [ebp-44h]
  float v20; // [esp+38h] [ebp-40h]
  int v21; // [esp+3Ch] [ebp-3Ch]
  int v22; // [esp+40h] [ebp-38h]
  float v23; // [esp+44h] [ebp-34h]
  int *v24; // [esp+48h] [ebp-30h]
  float *v25; // [esp+5Ch] [ebp-1Ch]
  __int16 *v26; // [esp+64h] [ebp-14h]
  __int16 *v27; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  float *v29; // [esp+6Ch] [ebp-Ch]

  v7 = *(unsigned __int16 *)a1;
  v23 = a4 * 0.000030518509;
  v20 = (long double)v7 * a3;
  v21 = (int)v20;
  v6 = *(_DWORD *)(a1 + 28);
  v8 = **(__int16 **)(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v22 = *(unsigned __int8 *)(a2 + i);
    if ( ((*((char *)&dword_832D030 + (v22 >> 3)) >> (v22 & 7)) & 1) == 0 )
    {
      v29 = (float *)(a5 + 32 * v22);
      v24 = (int *)(*(_DWORD *)(a1 + 16) + 8 * i);
      v10 = v24[1];
      if ( ((*(char *)((i >> 3) + v6) >> (i & 7)) & 1) != 0 )
      {
        if ( v10 )
        {
          v17 = *(unsigned __int16 *)(v10 + 4);
          if ( *(_WORD *)(v10 + 4) )
          {
            if ( v17 >= v7 )
            {
              v14 = (int)v20;
              v11 = v20 - (long double)v21;
            }
            else
            {
              v14 = sub_80C4580(a3, v10 + 6, v17, v21);
              v11 = (v20 - (long double)*(unsigned __int8 *)(v14 + v10 + 6))
                  / (long double)(*(unsigned __int8 *)(v14 + v10 + 7) - *(unsigned __int8 *)(v14 + v10 + 6));
            }
            v26 = (__int16 *)(*(_DWORD *)v10 + 4 * v14);
            v29[2] = ((long double)*v26 + (long double)(v26[2] - *v26) * v11) * v23 + v29[2];
            v29[3] = ((long double)v26[1] + (long double)(v26[3] - v26[1]) * v11) * v23 + v29[3];
          }
          else
          {
            v29[2] = (long double)*(__int16 *)v10 * v23 + v29[2];
            v29[3] = (long double)*(__int16 *)(v10 + 2) * v23 + v29[3];
          }
        }
        else
        {
          v29[3] = v29[3] + a4;
        }
      }
      else
      {
        v18 = *(unsigned __int16 *)(v10 + 4);
        if ( *(_WORD *)(v10 + 4) )
        {
          if ( v18 >= v7 )
          {
            v15 = (int)v20;
            v12 = v20 - (long double)v21;
          }
          else
          {
            v15 = sub_80C4580(a3, v10 + 6, v18, v21);
            v12 = (v20 - (long double)*(unsigned __int8 *)(v15 + v10 + 6))
                / (long double)(*(unsigned __int8 *)(v15 + v10 + 7) - *(unsigned __int8 *)(v15 + v10 + 6));
          }
          v27 = (__int16 *)(*(_DWORD *)v10 + 8 * v15);
          *v29 = ((long double)*v27 + (long double)(v27[4] - *v27) * v12) * v23 + *v29;
          v29[1] = ((long double)v27[1] + (long double)(v27[5] - v27[1]) * v12) * v23 + v29[1];
          v29[2] = ((long double)v27[2] + (long double)(v27[6] - v27[2]) * v12) * v23 + v29[2];
          v29[3] = ((long double)v27[3] + (long double)(v27[7] - v27[3]) * v12) * v23 + v29[3];
        }
        else
        {
          *v29 = (long double)*(__int16 *)v10 * v23 + *v29;
          v29[1] = (long double)*(__int16 *)(v10 + 2) * v23 + v29[1];
          v29[2] = (long double)*(__int16 *)(v10 + 6) * v23 + v29[2];
          v29[3] = (long double)*(__int16 *)(v10 + 8) * v23 + v29[3];
        }
      }
      v9 = *v24;
      if ( *v24 )
      {
        v19 = *(unsigned __int16 *)(v9 + 4);
        if ( *(_WORD *)(v9 + 4) )
        {
          if ( v19 >= v7 )
          {
            v16 = (int)v20;
            v13 = v20 - (long double)v21;
          }
          else
          {
            v16 = sub_80C4580(a3, v9 + 6, v19, v21);
            v13 = (v20 - (long double)*(unsigned __int8 *)(v16 + v9 + 6))
                / (long double)(*(unsigned __int8 *)(v16 + v9 + 7) - *(unsigned __int8 *)(v16 + v9 + 6));
          }
          v25 = (float *)(*(_DWORD *)v9 + 12 * v16);
          v29[5] = ((v25[3] - *v25) * v13 + *v25) * a4 + v29[5];
          v29[6] = ((v25[4] - v25[1]) * v13 + v25[1]) * a4 + v29[6];
          v29[7] = ((v25[5] - v25[2]) * v13 + v25[2]) * a4 + v29[7];
        }
        else
        {
          v29[5] = a4 * *(float *)v9 + v29[5];
          v29[6] = a4 * *(float *)(v9 + 8) + v29[6];
          v29[7] = a4 * *(float *)(v9 + 12) + v29[7];
        }
      }
      v29[4] = v29[4] + a4;
    }
  }
  return result;
}
// 832D030: using guessed type int dword_832D030;

//----- (080C4DE6) --------------------------------------------------------
int __cdecl sub_80C4DE6(int a1, int a2, float a3, float a4, int a5)
{
  int result; // eax
  int v6; // [esp+18h] [ebp-60h]
  int v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+20h] [ebp-58h]
  int v9; // [esp+24h] [ebp-54h]
  int v10; // [esp+28h] [ebp-50h]
  float v11; // [esp+2Ch] [ebp-4Ch]
  float v12; // [esp+2Ch] [ebp-4Ch]
  float v13; // [esp+2Ch] [ebp-4Ch]
  int v14; // [esp+30h] [ebp-48h]
  int v15; // [esp+30h] [ebp-48h]
  int v16; // [esp+30h] [ebp-48h]
  int v17; // [esp+34h] [ebp-44h]
  int v18; // [esp+34h] [ebp-44h]
  int v19; // [esp+34h] [ebp-44h]
  float v20; // [esp+38h] [ebp-40h]
  int v21; // [esp+3Ch] [ebp-3Ch]
  int v22; // [esp+40h] [ebp-38h]
  float v23; // [esp+44h] [ebp-34h]
  int *v24; // [esp+48h] [ebp-30h]
  float *v25; // [esp+5Ch] [ebp-1Ch]
  __int16 *v26; // [esp+64h] [ebp-14h]
  __int16 *v27; // [esp+64h] [ebp-14h]
  int i; // [esp+68h] [ebp-10h]
  float *v29; // [esp+6Ch] [ebp-Ch]

  v7 = *(unsigned __int16 *)a1;
  v23 = a4 * 0.000030518509;
  v20 = (long double)v7 * a3;
  v21 = (int)v20;
  v6 = *(_DWORD *)(a1 + 28);
  v8 = **(__int16 **)(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v8 )
      break;
    v22 = *(unsigned __int8 *)(a2 + i);
    if ( ((*((char *)&dword_832D030 + (v22 >> 3)) >> (v22 & 7)) & 1) == 0 )
    {
      v29 = (float *)(a5 + 32 * v22);
      v24 = (int *)(*(_DWORD *)(a1 + 16) + 8 * i);
      v10 = v24[1];
      if ( ((*(char *)((i >> 3) + v6) >> (i & 7)) & 1) != 0 )
      {
        if ( v10 )
        {
          v17 = *(unsigned __int16 *)(v10 + 4);
          if ( *(_WORD *)(v10 + 4) )
          {
            if ( v17 >= v7 )
            {
              v14 = (int)v20;
              v11 = v20 - (long double)v21;
            }
            else
            {
              v14 = sub_80C469E(a3, v10 + 6, v17, v21);
              v11 = (v20 - (long double)*(unsigned __int16 *)(v10 + 2 * v14 + 6))
                  / (long double)(*(unsigned __int16 *)(v10 + 2 * v14 + 8) - *(unsigned __int16 *)(v10 + 2 * v14 + 6));
            }
            v26 = (__int16 *)(*(_DWORD *)v10 + 4 * v14);
            v29[2] = ((long double)*v26 + (long double)(v26[2] - *v26) * v11) * v23 + v29[2];
            v29[3] = ((long double)v26[1] + (long double)(v26[3] - v26[1]) * v11) * v23 + v29[3];
          }
          else
          {
            v29[2] = (long double)*(__int16 *)v10 * v23 + v29[2];
            v29[3] = (long double)*(__int16 *)(v10 + 2) * v23 + v29[3];
          }
        }
        else
        {
          v29[3] = v29[3] + a4;
        }
      }
      else
      {
        v18 = *(unsigned __int16 *)(v10 + 4);
        if ( *(_WORD *)(v10 + 4) )
        {
          if ( v18 >= v7 )
          {
            v15 = (int)v20;
            v12 = v20 - (long double)v21;
          }
          else
          {
            v15 = sub_80C469E(a3, v10 + 6, v18, v21);
            v12 = (v20 - (long double)*(unsigned __int16 *)(v10 + 2 * v15 + 6))
                / (long double)(*(unsigned __int16 *)(v10 + 2 * v15 + 8) - *(unsigned __int16 *)(v10 + 2 * v15 + 6));
          }
          v27 = (__int16 *)(*(_DWORD *)v10 + 8 * v15);
          *v29 = ((long double)*v27 + (long double)(v27[4] - *v27) * v12) * v23 + *v29;
          v29[1] = ((long double)v27[1] + (long double)(v27[5] - v27[1]) * v12) * v23 + v29[1];
          v29[2] = ((long double)v27[2] + (long double)(v27[6] - v27[2]) * v12) * v23 + v29[2];
          v29[3] = ((long double)v27[3] + (long double)(v27[7] - v27[3]) * v12) * v23 + v29[3];
        }
        else
        {
          *v29 = (long double)*(__int16 *)v10 * v23 + *v29;
          v29[1] = (long double)*(__int16 *)(v10 + 2) * v23 + v29[1];
          v29[2] = (long double)*(__int16 *)(v10 + 6) * v23 + v29[2];
          v29[3] = (long double)*(__int16 *)(v10 + 8) * v23 + v29[3];
        }
      }
      v9 = *v24;
      if ( *v24 )
      {
        v19 = *(unsigned __int16 *)(v9 + 4);
        if ( *(_WORD *)(v9 + 4) )
        {
          if ( v19 >= v7 )
          {
            v16 = (int)v20;
            v13 = v20 - (long double)v21;
          }
          else
          {
            v16 = sub_80C469E(a3, v9 + 6, v19, v21);
            v13 = (v20 - (long double)*(unsigned __int16 *)(v9 + 2 * v16 + 6))
                / (long double)(*(unsigned __int16 *)(v9 + 2 * v16 + 8) - *(unsigned __int16 *)(v9 + 2 * v16 + 6));
          }
          v25 = (float *)(*(_DWORD *)v9 + 12 * v16);
          v29[5] = ((v25[3] - *v25) * v13 + *v25) * a4 + v29[5];
          v29[6] = ((v25[4] - v25[1]) * v13 + v25[1]) * a4 + v29[6];
          v29[7] = ((v25[5] - v25[2]) * v13 + v25[2]) * a4 + v29[7];
        }
        else
        {
          v29[5] = a4 * *(float *)v9 + v29[5];
          v29[6] = a4 * *(float *)(v9 + 8) + v29[6];
          v29[7] = a4 * *(float *)(v9 + 12) + v29[7];
        }
      }
      v29[4] = v29[4] + a4;
    }
  }
  return result;
}
// 832D030: using guessed type int dword_832D030;

//----- (080C53EE) --------------------------------------------------------
int __cdecl sub_80C53EE(int a1, int a2, float a3, int a4)
{
  int result; // eax
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  int v8; // [esp+0h] [ebp-2Ch]
  int v9; // [esp+4h] [ebp-28h]
  int v10; // [esp+8h] [ebp-24h]
  int v11; // [esp+Ch] [ebp-20h]
  int v12; // [esp+10h] [ebp-1Ch]
  float v13; // [esp+14h] [ebp-18h]
  int *v14; // [esp+18h] [ebp-14h]
  float *v15; // [esp+1Ch] [ebp-10h]
  __int16 *v16; // [esp+20h] [ebp-Ch]
  __int16 *v17; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  float *v19; // [esp+28h] [ebp-4h]

  v13 = a3 * 0.000030518509;
  v8 = *(_DWORD *)(a1 + 28);
  v9 = **(__int16 **)(a1 + 12);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v9 )
      break;
    v12 = *(unsigned __int8 *)(a2 + i);
    if ( ((*((char *)&dword_832D030 + (v12 >> 3)) >> (v12 & 7)) & 1) == 0 )
    {
      v19 = (float *)(a4 + 32 * v12);
      v14 = (int *)(*(_DWORD *)(a1 + 16) + 8 * i);
      v11 = v14[1];
      if ( ((*(char *)((i >> 3) + v8) >> (i & 7)) & 1) != 0 )
      {
        if ( v11 )
        {
          if ( *(_WORD *)(v11 + 4) )
          {
            v16 = (__int16 *)(*(_DWORD *)v11 + 4 * *(unsigned __int16 *)(v11 + 4));
            v19[2] = (long double)*v16 * v13 + v19[2];
            v5 = (long double)v16[1] * v13 + v19[3];
          }
          else
          {
            v19[2] = (long double)*(__int16 *)v11 * v13 + v19[2];
            v5 = (long double)*(__int16 *)(v11 + 2) * v13 + v19[3];
          }
          v19[3] = v5;
        }
        else
        {
          v19[3] = v19[3] + a3;
        }
      }
      else
      {
        if ( *(_WORD *)(v11 + 4) )
        {
          v17 = (__int16 *)(*(_DWORD *)v11 + 8 * *(unsigned __int16 *)(v11 + 4));
          *v19 = (long double)*v17 * v13 + *v19;
          v19[1] = (long double)v17[1] * v13 + v19[1];
          v19[2] = (long double)v17[2] * v13 + v19[2];
          v6 = (long double)v17[3] * v13 + v19[3];
        }
        else
        {
          *v19 = (long double)*(__int16 *)v11 * v13 + *v19;
          v19[1] = (long double)*(__int16 *)(v11 + 2) * v13 + v19[1];
          v19[2] = (long double)*(__int16 *)(v11 + 6) * v13 + v19[2];
          v6 = (long double)*(__int16 *)(v11 + 8) * v13 + v19[3];
        }
        v19[3] = v6;
      }
      v10 = *v14;
      if ( *v14 )
      {
        if ( *(_WORD *)(v10 + 4) )
        {
          v15 = (float *)(*(_DWORD *)v10 + 12 * *(unsigned __int16 *)(v10 + 4));
          v19[5] = a3 * *v15 + v19[5];
          v19[6] = a3 * v15[1] + v19[6];
          v7 = a3 * v15[2] + v19[7];
        }
        else
        {
          v19[5] = a3 * *(float *)v10 + v19[5];
          v19[6] = a3 * *(float *)(v10 + 8) + v19[6];
          v7 = a3 * *(float *)(v10 + 12) + v19[7];
        }
        v19[7] = v7;
      }
      v19[4] = v19[4] + a3;
    }
  }
  return result;
}
// 832D030: using guessed type int dword_832D030;

//----- (080C56F6) --------------------------------------------------------
int __cdecl sub_80C56F6(_DWORD *a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= dword_832D044 )
      break;
    if ( ((*((char *)&dword_832D030 + (i >> 3)) >> (i & 7)) & 1) == 0 )
    {
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
      a1[3] = 0;
      a1[4] = 0;
      a1[7] = 0;
      a1[6] = 0;
      a1[5] = 0;
    }
    a1 += 8;
  }
  return result;
}
// 832D030: using guessed type int dword_832D030;
// 832D044: using guessed type int dword_832D044;

//----- (080C5788) --------------------------------------------------------
int __cdecl sub_80C5788(int a1, int a2, float a3, int a4, float a5)
{
  int i; // [esp+18h] [ebp-10h]
  _WORD *v7; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; i <= 3; ++i )
    dword_832D020[i] |= *(_DWORD *)(a2 + 4 * i) & ~dword_832D030[i];
  v7 = *(_WORD **)(a1 + 4);
  if ( a5 == 1.0 || !*v7 )
    return sub_80C53EE((int)v7, a2 + 16, a3, a4);
  if ( *v7 > 0xFFu )
    return sub_80C4DE6((int)v7, a2 + 16, a5, a3, a4);
  return sub_80C47DE((int)v7, a2 + 16, a5, a3, a4);
}
// 832D020: using guessed type int dword_832D020[];

//----- (080C587E) --------------------------------------------------------
float *__cdecl sub_80C587E(int a1, int a2, int a3, float a4)
{
  long double v4; // fst7
  float *result; // eax
  int v6; // [esp+18h] [ebp-40h]
  float v7; // [esp+1Ch] [ebp-3Ch]
  float v8; // [esp+1Ch] [ebp-3Ch]
  float v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+20h] [ebp-38h]
  int v11; // [esp+20h] [ebp-38h]
  int v12; // [esp+20h] [ebp-38h]
  int v13; // [esp+24h] [ebp-34h]
  int v14; // [esp+24h] [ebp-34h]
  int v15; // [esp+24h] [ebp-34h]
  int v16; // [esp+24h] [ebp-34h]
  int v17; // [esp+28h] [ebp-30h]
  int v18; // [esp+28h] [ebp-30h]
  int v19; // [esp+2Ch] [ebp-2Ch]
  int v20; // [esp+2Ch] [ebp-2Ch]
  int v21; // [esp+2Ch] [ebp-2Ch]
  int *v22; // [esp+30h] [ebp-28h]
  int *v23; // [esp+30h] [ebp-28h]
  int v24; // [esp+34h] [ebp-24h]
  float v25; // [esp+38h] [ebp-20h]
  _DWORD *v26; // [esp+48h] [ebp-10h]
  float *v27; // [esp+48h] [ebp-10h]
  __int16 *v28; // [esp+50h] [ebp-8h]
  __int16 *v29; // [esp+50h] [ebp-8h]
  __int16 *v30; // [esp+50h] [ebp-8h]

  v6 = *(unsigned __int16 *)a1;
  if ( a4 != 1.0 && *(_WORD *)a1 )
  {
    v25 = (long double)v6 * a4;
    v24 = (int)v25;
    v23 = *(int **)(a1 + 24);
    if ( *(unsigned __int16 *)a1 > 0xFFu )
    {
      v21 = v23[1];
      if ( v21 )
      {
        v15 = *(unsigned __int16 *)(v21 + 4);
        if ( *(_WORD *)(v21 + 4) )
        {
          if ( v15 >= v6 )
          {
            v12 = (int)v25;
            v9 = v25 - (long double)v24;
          }
          else
          {
            v12 = sub_80C469E(a4, v21 + 6, v15, v24);
            v9 = (v25 - (long double)*(unsigned __int16 *)(v21 + 2 * v12 + 6))
               / (long double)(*(unsigned __int16 *)(v21 + 2 * v12 + 8) - *(unsigned __int16 *)(v21 + 2 * v12 + 6));
          }
          v30 = (__int16 *)(*(_DWORD *)v21 + 4 * v12);
          *(float *)a2 = (long double)*v30 + (long double)(v30[2] - *v30) * v9;
          *(float *)(a2 + 4) = (long double)v30[1] + (long double)(v30[3] - v30[1]) * v9;
        }
        else
        {
          *(float *)a2 = (float)*(__int16 *)v21;
          *(float *)(a2 + 4) = (float)*(__int16 *)(v21 + 2);
        }
      }
      else
      {
        *(_DWORD *)a2 = 0;
        *(_DWORD *)(a2 + 4) = 1191181824;
      }
      v18 = *v23;
      if ( !*v23 )
      {
        result = 0;
        *(_DWORD *)(a3 + 8) = 0;
        *(_DWORD *)(a3 + 4) = 0;
        *(_DWORD *)a3 = 0;
        return result;
      }
      v16 = *(unsigned __int16 *)(v18 + 4);
      if ( !*(_WORD *)(v18 + 4) )
      {
        *(_DWORD *)a3 = *(_DWORD *)v18;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v18 + 8);
        result = *(float **)(v18 + 12);
        *(_DWORD *)(a3 + 8) = result;
        return result;
      }
      if ( v16 >= v6 )
      {
        v11 = (int)v25;
        v8 = v25 - (long double)v24;
      }
      else
      {
        v11 = sub_80C469E(a4, v18 + 6, v16, v24);
        v8 = (v25 - (long double)*(unsigned __int16 *)(v18 + 2 * v11 + 6))
           / (long double)(*(unsigned __int16 *)(v18 + 2 * v11 + 8) - *(unsigned __int16 *)(v18 + 2 * v11 + 6));
      }
    }
    else
    {
      v20 = v23[1];
      if ( v20 )
      {
        v13 = *(unsigned __int16 *)(v20 + 4);
        if ( *(_WORD *)(v20 + 4) )
        {
          if ( v13 >= v6 )
          {
            v10 = (int)v25;
            v7 = v25 - (long double)v24;
          }
          else
          {
            v10 = sub_80C4580(a4, v20 + 6, v13, v24);
            v7 = (v25 - (long double)*(unsigned __int8 *)(v10 + v20 + 6))
               / (long double)(*(unsigned __int8 *)(v10 + v20 + 7) - *(unsigned __int8 *)(v10 + v20 + 6));
          }
          v29 = (__int16 *)(*(_DWORD *)v20 + 4 * v10);
          *(float *)a2 = (long double)*v29 + (long double)(v29[2] - *v29) * v7;
          *(float *)(a2 + 4) = (long double)v29[1] + (long double)(v29[3] - v29[1]) * v7;
        }
        else
        {
          *(float *)a2 = (float)*(__int16 *)v20;
          *(float *)(a2 + 4) = (float)*(__int16 *)(v20 + 2);
        }
      }
      else
      {
        *(_DWORD *)a2 = 0;
        *(_DWORD *)(a2 + 4) = 1191181824;
      }
      v18 = *v23;
      if ( !*v23 )
      {
        result = 0;
        *(_DWORD *)(a3 + 8) = 0;
        *(_DWORD *)(a3 + 4) = 0;
        *(_DWORD *)a3 = 0;
        return result;
      }
      v14 = *(unsigned __int16 *)(v18 + 4);
      if ( !*(_WORD *)(v18 + 4) )
      {
        *(_DWORD *)a3 = *(_DWORD *)v18;
        *(_DWORD *)(a3 + 4) = *(_DWORD *)(v18 + 8);
        result = *(float **)(v18 + 12);
        *(_DWORD *)(a3 + 8) = result;
        return result;
      }
      if ( v14 >= v6 )
      {
        v11 = (int)v25;
        v8 = v25 - (long double)v24;
      }
      else
      {
        v11 = sub_80C4580(a4, v18 + 6, v14, v24);
        v8 = (v25 - (long double)*(unsigned __int8 *)(v11 + v18 + 6))
           / (long double)(*(unsigned __int8 *)(v11 + v18 + 7) - *(unsigned __int8 *)(v11 + v18 + 6));
      }
    }
    v27 = (float *)(*(_DWORD *)v18 + 12 * v11);
    *(float *)a3 = (v27[3] - *v27) * v8 + *v27;
    *(float *)(a3 + 4) = (v27[4] - v27[1]) * v8 + v27[1];
    result = v27 + 5;
    *(float *)(a3 + 8) = (v27[5] - v27[2]) * v8 + v27[2];
    return result;
  }
  v22 = *(int **)(a1 + 24);
  v19 = v22[1];
  if ( v19 )
  {
    if ( *(_WORD *)(v19 + 4) )
    {
      v28 = (__int16 *)(*(_DWORD *)v19 + 4 * *(unsigned __int16 *)(v19 + 4));
      *(float *)a2 = (float)*v28;
      v4 = (long double)v28[1];
    }
    else
    {
      *(float *)a2 = (float)*(__int16 *)v19;
      v4 = (long double)*(__int16 *)(v19 + 2);
    }
    *(float *)(a2 + 4) = v4;
  }
  else
  {
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 1191181824;
  }
  v17 = *v22;
  if ( *v22 )
  {
    if ( *(_WORD *)(v17 + 4) )
    {
      v26 = (_DWORD *)(*(_DWORD *)v17 + 12 * *(unsigned __int16 *)(v17 + 4));
      *(_DWORD *)a3 = *v26;
      *(_DWORD *)(a3 + 4) = v26[1];
      result = (float *)v26[2];
    }
    else
    {
      *(_DWORD *)a3 = *(_DWORD *)v17;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(v17 + 8);
      result = *(float **)(v17 + 12);
    }
    *(_DWORD *)(a3 + 8) = result;
  }
  else
  {
    result = 0;
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = 0;
    *(_DWORD *)a3 = 0;
  }
  return result;
}

//----- (080C5FC8) --------------------------------------------------------
void __cdecl sub_80C5FC8(float *a1, float *a2)
{
  float v2; // [esp+0h] [ebp-10h]
  float v3; // [esp+4h] [ebp-Ch]
  float v4; // [esp+4h] [ebp-Ch]
  float v5; // [esp+8h] [ebp-8h]
  float v6; // [esp+Ch] [ebp-4h]
  float v7; // [esp+Ch] [ebp-4h]

  v6 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v6;
  if ( v3 != 0.0 )
  {
    v4 = 2.0 / v3;
    v7 = v6 * v4;
    v5 = *a1 * a1[1] * v4;
    v2 = (1.0 - v7) * *a2 + v5 * a2[1];
    a2[1] = a2[1] - (v5 * *a2 + v7 * a2[1]);
    *a2 = v2;
  }
}

//----- (080C6076) --------------------------------------------------------
int __cdecl sub_80C6076(int a1, float a2, int a3, float a4, float a5)
{
  long double v5; // fst7
  int result; // eax
  int v7; // [esp+10h] [ebp-58h]
  float v8; // [esp+18h] [ebp-50h]
  float *v9; // [esp+1Ch] [ebp-4Ch]
  float v10; // [esp+20h] [ebp-48h] BYREF
  float v11; // [esp+24h] [ebp-44h]
  float v12; // [esp+28h] [ebp-40h]
  int v13; // [esp+30h] [ebp-38h] BYREF
  float v14; // [esp+34h] [ebp-34h]
  float v15; // [esp+38h] [ebp-30h]
  int v16[4]; // [esp+40h] [ebp-28h] BYREF
  int v17; // [esp+50h] [ebp-18h] BYREF
  float v18; // [esp+54h] [ebp-14h]
  int v19; // [esp+58h] [ebp-10h] BYREF
  float v20; // [esp+5Ch] [ebp-Ch]

  sub_80C587E(a1, (int)&v19, (int)v16, a4);
  sub_80C587E(a1, (int)&v17, (int)&v13, a5);
  if ( *(_BYTE *)(a1 + 2) )
  {
    if ( a4 > (long double)a5 )
    {
      v7 = **(_DWORD **)(a1 + 24);
      if ( v7 )
      {
        if ( *(_WORD *)(v7 + 4) )
        {
          v9 = (float *)(*(_DWORD *)v7 + 12 * *(unsigned __int16 *)(v7 + 4));
          *(float *)&v13 = *(float *)&v13 + *v9;
          v14 = v14 + v9[1];
          v5 = v15 + v9[2];
        }
        else
        {
          *(float *)&v13 = *(float *)&v13 + *(float *)v7;
          v14 = v14 + *(float *)(v7 + 8);
          v5 = v15 + *(float *)(v7 + 12);
        }
        v15 = v5;
      }
    }
  }
  v8 = a2 * 9.3137942e-10;
  *(float *)a3 = (*(float *)&v17 * v20 - v18 * *(float *)&v19) * v8 + *(float *)a3;
  *(float *)(a3 + 4) = (*(float *)&v17 * *(float *)&v19 + v18 * v20) * v8 + *(float *)(a3 + 4);
  v10 = *(float *)&v13 - *(float *)v16;
  v11 = v14 - *(float *)&v16[1];
  v12 = v15 - *(float *)&v16[2];
  sub_80C5FC8((float *)&v17, &v10);
  *(float *)(a3 + 8) = *(float *)(a3 + 8) + a2;
  *(float *)(a3 + 12) = a2 * v10 + *(float *)(a3 + 12);
  *(float *)(a3 + 16) = a2 * v11 + *(float *)(a3 + 16);
  result = a3 + 20;
  *(float *)(a3 + 20) = a2 * v12 + *(float *)(a3 + 20);
  return result;
}

//----- (080C623C) --------------------------------------------------------
int __cdecl sub_80C623C(int a1, float a2, int a3, float a4)
{
  int result; // eax
  float v5; // [esp+1Ch] [ebp-2Ch]
  int v6[6]; // [esp+20h] [ebp-28h] BYREF
  int v7[4]; // [esp+38h] [ebp-10h] BYREF

  sub_80C587E(a1, (int)v7, (int)v6, a4);
  v5 = a2 * 0.000030518509;
  *(float *)a3 = v5 * *(float *)v7 + *(float *)a3;
  *(float *)(a3 + 4) = v5 * *(float *)&v7[1] + *(float *)(a3 + 4);
  *(float *)(a3 + 8) = *(float *)(a3 + 8) + a2;
  *(float *)(a3 + 12) = a2 * *(float *)v6 + *(float *)(a3 + 12);
  *(float *)(a3 + 16) = a2 * *(float *)&v6[1] + *(float *)(a3 + 16);
  result = a3 + 20;
  *(float *)(a3 + 20) = a2 * *(float *)&v6[2] + *(float *)(a3 + 20);
  return result;
}

//----- (080C62F8) --------------------------------------------------------
int __cdecl sub_80C62F8(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_WORD *)(a1 + 4) )
    result = sub_80A40A6(*(_WORD *)(a1 + 4));
  return result;
}

//----- (080C631A) --------------------------------------------------------
int __cdecl sub_80C631A(int a1, unsigned __int16 a2)
{
  int result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)&unk_830B000 + 68 * a2;
  sub_80C62F8((int)v3);
  *((_WORD *)v3 + 4) = 0;
  *((_WORD *)v3 + 5) = word_830B00A[0];
  word_830B008[34 * (unsigned __int16)word_830B00A[0]] = a2;
  word_830B00A[0] = a2;
  --dword_832D684;
  result = a1;
  --*(_DWORD *)(a1 + 4);
  return result;
}
// 830B008: using guessed type __int16 word_830B008[];
// 830B00A: using guessed type __int16 word_830B00A[];
// 832D684: using guessed type int dword_832D684;

//----- (080C639E) --------------------------------------------------------
long double __cdecl sub_80C639E(int a1)
{
  float v2; // [esp+4h] [ebp-30h]
  float v4; // [esp+Ch] [ebp-28h]
  unsigned __int16 *v5; // [esp+14h] [ebp-20h]
  float v6; // [esp+18h] [ebp-1Ch]
  float v7; // [esp+1Ch] [ebp-18h]
  float v8; // [esp+20h] [ebp-14h]
  unsigned __int16 v9; // [esp+2Ah] [ebp-Ah]
  int i; // [esp+2Ch] [ebp-8h]
  int v11; // [esp+30h] [ebp-4h]

  v5 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  v11 = *v5;
  if ( !*v5 )
    return *(float *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) + 4) + 8);
  v7 = 0.0;
  v6 = 0.0;
  for ( i = 0; i < v11; ++i )
  {
    v9 = *(_WORD *)(dword_832D018 + 2 * (i + v5[3]) + 12);
    if ( v9 )
    {
      v8 = *((float *)&unk_830B000 + 17 * v9 + 7 * dword_832D040 + 8);
      if ( v8 != 0.0 )
      {
        v4 = sub_80C639E(i + (unsigned int)v5[3]);
        if ( v4 != 0.0 )
        {
          v7 = v7 + v8;
          v6 = v4 * v8 * *((float *)&unk_830B000 + 17 * v9 + 7 * dword_832D040 + 9) + v6;
        }
      }
    }
  }
  if ( v7 == 0.0 )
    v2 = 0.0;
  else
    v2 = v6 / v7;
  return v2;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080C64FE) --------------------------------------------------------
int __cdecl sub_80C64FE(int a1)
{
  unsigned __int16 *v3; // [esp+Ch] [ebp-1Ch]
  char *v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  char v8; // [esp+27h] [ebp-1h]

  v5 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( !v5 )
    return 0;
  v4 = (char *)&unk_830B000 + 68 * v5;
  *((_DWORD *)v4 + 8) = *((_DWORD *)v4 + 7);
  *((_DWORD *)v4 + 6) = 0;
  v3 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  v6 = *v3;
  if ( *v3 )
  {
    v8 = 0;
    for ( i = 0; i < v6; ++i )
    {
      if ( (unsigned __int8)sub_80C64FE(i + v3[3]) )
        v8 = 1;
    }
    if ( v8
      || *((float *)&unk_830B000 + 17 * v5 + 8) != 0.0
      || *((float *)&unk_830B000 + 17 * v5 + 7) != 0.0
      || *((float *)v4 + 15) != 0.0
      || *((float *)v4 + 14) != 0.0 )
    {
      return 1;
    }
  }
  else if ( *((float *)&unk_830B000 + 17 * v5 + 8) != 0.0
         || *((float *)&unk_830B000 + 17 * v5 + 7) != 0.0
         || *((float *)v4 + 15) != 0.0
         || *((float *)v4 + 14) != 0.0 )
  {
    return 1;
  }
  sub_80C631A(dword_832D018, v5);
  *(_WORD *)(dword_832D018 + 2 * a1 + 12) = 0;
  return 0;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C66EA) --------------------------------------------------------
int __cdecl sub_80C66EA(int a1, int a2, float a3)
{
  int v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]

  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4);
  v4 = 0;
  v5 = 2.0;
  for ( i = *(_DWORD *)(v8 + 20); *(_WORD *)i; i += 8 )
  {
    v6 = *(float *)(i + 4);
    if ( a3 <= (long double)v6 && v5 > (long double)v6 )
    {
      v5 = *(float *)(i + 4);
      v4 = i;
    }
  }
  return (unsigned __int16)((v4 - *(_DWORD *)(v8 + 20)) >> 3);
}

//----- (080C6770) --------------------------------------------------------
long double __cdecl sub_80C6770(float a1)
{
  float v2; // [esp+0h] [ebp-4h]

  if ( flt_832D00C == 1.0 )
    return (float)1.0;
  if ( flt_832D00C <= (long double)flt_832D008 )
  {
    if ( (flt_832D008 > (long double)a1 || flt_832D008 == 1.0) && a1 >= (long double)flt_832D00C )
      v2 = ((long double)(word_832D014 - word_832D010) + a1 - flt_832D004) / flt_832D000;
    else
      v2 = 1.0;
  }
  else if ( flt_832D008 <= (long double)a1 )
  {
    if ( a1 < (long double)flt_832D00C )
      v2 = 1.0;
    else
      v2 = ((long double)(word_832D014 - word_832D010) + a1 - flt_832D004) / flt_832D000;
  }
  else
  {
    v2 = ((long double)(word_832D014 - word_832D010 + 1) + a1 - flt_832D004) / flt_832D000;
  }
  return v2;
}
// 832D000: using guessed type float flt_832D000;
// 832D00C: using guessed type float flt_832D00C;
// 832D010: using guessed type __int16 word_832D010;
// 832D014: using guessed type __int16 word_832D014;

//----- (080C68B2) --------------------------------------------------------
long double __cdecl sub_80C68B2(unsigned __int16 *a1, int a2)
{
  long double v2; // fst7

  if ( !word_832D04C || !a1[2] )
    return (float)1.0;
  if ( *(_WORD *)a2 )
  {
    if ( !*a1 )
      return (float)sub_80C6770(1.0);
    a2 = *(_DWORD *)dword_832D018 + 8 * *a1 + 8;
  }
  if ( (a1[1] & 0x8000u) != 0 )
    v2 = sub_80C6770(1.0);
  else
    v2 = sub_80C6770(*(float *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + 4) + 20) + 8 * (__int16)a1[1] + 4));
  return (float)v2;
}
// 832D018: using guessed type int dword_832D018;
// 832D04C: using guessed type __int16 word_832D04C;

//----- (080C6962) --------------------------------------------------------
int __cdecl sub_80C6962(int a1, int a2, int a3, float a4, int a5)
{
  int result; // eax
  int i; // [esp+8h] [ebp-10h]
  float *v7; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+Ch] [ebp-Ch]
  int v9; // [esp+10h] [ebp-8h]

  HIWORD(v9) = a3;
  LOWORD(v9) = a5;
  for ( i = dword_832D680 - 1; i >= 0; --i )
  {
    v7 = (float *)((char *)&unk_832D080 + 12 * i);
    if ( a4 >= (long double)v7[2] )
      break;
    v7[3] = *v7;
    v7[4] = v7[1];
    v7[5] = v7[2];
  }
  v8 = 12 * i + 137547916;
  dword_832D08C[3 * i] = SL_ConvertToString(a3);
  *(float *)(v8 + 8) = a4;
  result = v9;
  *(_WORD *)(v8 + 4) = a5;
  ++dword_832D680;
  return result;
}
// 832D680: using guessed type int dword_832D680;

//----- (080C6A18) --------------------------------------------------------
void __cdecl sub_80C6A18(int a1, int a2, unsigned __int16 a3)
{
  float v3; // [esp+Ch] [ebp-1Ch]
  float v4; // [esp+Ch] [ebp-1Ch]
  float v5; // [esp+Ch] [ebp-1Ch]
  float v6; // [esp+Ch] [ebp-1Ch]
  float v7; // [esp+Ch] [ebp-1Ch]
  float v8; // [esp+Ch] [ebp-1Ch]
  float *v9; // [esp+18h] [ebp-10h]
  float *i; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]

  *(float *)(a1 + 16) = flt_832D004;
  *(_WORD *)(a1 + 22) = word_832D010;
  *(float *)(a1 + 12) = flt_832D008;
  *(_WORD *)(a1 + 20) = word_832D012;
  if ( a3 && flt_832D000 != 0.0 )
  {
    flt_832D00C = flt_832D004;
    word_832D014 = word_832D010;
    if ( flt_832D004 == 1.0 )
    {
LABEL_4:
      v3 = sub_80C6770(1.0);
      sub_80C6962(a1, a2, (unsigned __int16)word_80F1C0A, v3, a3);
      return;
    }
    if ( *(_WORD *)a2 )
    {
      if ( flt_832D004 > (long double)flt_832D008 || flt_832D008 == 1.0 )
        goto LABEL_4;
    }
    else
    {
      v11 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
      v9 = (float *)(*(_DWORD *)(v11 + 20) + 8 * (unsigned __int16)sub_80C66EA(a2, a1, flt_832D004));
      if ( flt_832D004 <= (long double)flt_832D008 )
      {
        if ( flt_832D008 == 1.0 )
        {
          if ( flt_832D004 <= (long double)v9[1] )
          {
            do
            {
              v7 = sub_80C6770(v9[1]);
              sub_80C6962(a1, a2, *(unsigned __int16 *)v9, v7, a3);
              v9 += 2;
            }
            while ( *(_WORD *)v9 );
          }
        }
        else if ( v9[1] < (long double)flt_832D008 && flt_832D004 <= (long double)v9[1] )
        {
          do
          {
            v8 = sub_80C6770(v9[1]);
            sub_80C6962(a1, a2, *(unsigned __int16 *)v9, v8, a3);
            v9 += 2;
          }
          while ( *(_WORD *)v9 && flt_832D008 > (long double)v9[1] );
        }
      }
      else if ( flt_832D008 <= (long double)v9[1] )
      {
        if ( flt_832D004 <= (long double)v9[1] )
        {
          do
          {
            v5 = sub_80C6770(v9[1]);
            sub_80C6962(a1, a2, *(unsigned __int16 *)v9, v5, a3);
            v9 += 2;
          }
          while ( *(_WORD *)v9 );
          for ( i = *(float **)(v11 + 20); flt_832D008 > (long double)i[1]; i += 4 )
          {
            v6 = sub_80C6770(i[1]);
            sub_80C6962(a1, a2, *(unsigned __int16 *)i, v6, a3);
          }
        }
      }
      else
      {
        do
        {
          v4 = sub_80C6770(v9[1]);
          sub_80C6962(a1, a2, *(unsigned __int16 *)v9, v4, a3);
          v9 += 2;
        }
        while ( *(_WORD *)v9 && flt_832D008 > (long double)v9[1] );
      }
    }
  }
}
// 80F1C0A: using guessed type __int16 word_80F1C0A;
// 832D000: using guessed type float flt_832D000;
// 832D00C: using guessed type float flt_832D00C;
// 832D010: using guessed type __int16 word_832D010;
// 832D012: using guessed type __int16 word_832D012;
// 832D014: using guessed type __int16 word_832D014;

//----- (080C6DE4) --------------------------------------------------------
void __cdecl sub_80C6DE4(int a1, unsigned __int8 a2)
{
  unsigned __int16 *v2; // [esp+18h] [ebp-20h]
  char *v3; // [esp+20h] [ebp-18h]
  unsigned __int16 v4; // [esp+26h] [ebp-12h]
  int v5; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+2Ch] [ebp-Ch]
  char v8; // [esp+32h] [ebp-6h]

  v4 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = (char *)&unk_830B000 + 68 * v4;
    if ( *((float *)v3 + 7) == 0.0 )
      a2 = 0;
    if ( flt_832D050 + 0.001 <= *((float *)v3 + 6) )
    {
      *((float *)v3 + 8) = (*((float *)v3 + 7) - *((float *)v3 + 8)) * flt_832D050 / *((float *)v3 + 6)
                         + *((float *)v3 + 8);
      if ( *((float *)v3 + 8) < 0.0000010000001 )
        *((float *)v3 + 8) = *((float *)v3 + 7) * 0.001;
      *((float *)v3 + 6) = *((float *)v3 + 6) - flt_832D050;
    }
    else
    {
      *((_DWORD *)v3 + 8) = *((_DWORD *)v3 + 7);
      *((_DWORD *)v3 + 6) = 0;
    }
    v2 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    if ( a2 )
      sub_80C6A18((int)v3, (int)v2, *((_WORD *)v3 + 3));
    else
      sub_80C6A18((int)v3, (int)v2, 0);
    v5 = *v2;
    if ( *v2 )
    {
      if ( *((float *)v3 + 8) == 0.0 && *((float *)v3 + 7) == 0.0 )
      {
        v8 = 0;
        for ( i = 0; i < v5; ++i )
        {
          if ( (unsigned __int8)sub_80C64FE(i + v2[3]) )
            v8 = 1;
        }
        if ( !v8 && *((float *)v3 + 15) == 0.0 && *((float *)v3 + 14) == 0.0 )
          goto LABEL_17;
      }
      else
      {
        for ( j = 0; j < v5; ++j )
          sub_80C6DE4(j + v2[3], a2);
      }
    }
    else if ( *((float *)v3 + 8) == 0.0
           && *((float *)v3 + 7) == 0.0
           && *((float *)v3 + 15) == 0.0
           && *((float *)v3 + 14) == 0.0 )
    {
LABEL_17:
      sub_80C631A(dword_832D018, v4);
      *(_WORD *)(dword_832D018 + 2 * a1 + 12) = 0;
      return;
    }
  }
}
// 832D018: using guessed type int dword_832D018;
// 832D050: using guessed type float flt_832D050;

//----- (080C70C2) --------------------------------------------------------
void __cdecl sub_80C70C2(int a1, float a2, int a3)
{
  __int16 v3; // [esp+1Ah] [ebp-2Eh]
  __int16 v4; // [esp+1Ah] [ebp-2Eh]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+1Ch] [ebp-2Ch]
  int v7; // [esp+20h] [ebp-28h]
  unsigned __int16 *v8; // [esp+28h] [ebp-20h]
  float *v9; // [esp+2Ch] [ebp-1Ch]
  char *v10; // [esp+30h] [ebp-18h]
  unsigned __int16 v11; // [esp+36h] [ebp-12h]
  int v12; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+3Ch] [ebp-Ch]
  int k; // [esp+3Ch] [ebp-Ch]
  char v16; // [esp+42h] [ebp-6h]
  unsigned __int8 v17; // [esp+43h] [ebp-5h]
  float v18; // [esp+54h] [ebp+Ch]
  float v19; // [esp+54h] [ebp+Ch]
  float v20; // [esp+54h] [ebp+Ch]

  v17 = a3;
  v11 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v11 )
  {
    v10 = (char *)&unk_830B000 + 68 * v11;
    v9 = (float *)(v10 + 12);
    if ( *((float *)v10 + 7) == 0.0 )
      v17 = 0;
    if ( flt_832D050 + 0.001 <= *((float *)v10 + 6) )
    {
      *((float *)v10 + 8) = (*((float *)v10 + 7) - *((float *)v10 + 8)) * flt_832D050 / *((float *)v10 + 6)
                          + *((float *)v10 + 8);
      if ( *((float *)v10 + 8) < 0.0000010000001 )
        *((float *)v10 + 8) = *((float *)v10 + 7) * 0.001;
      *((float *)v10 + 6) = *((float *)v10 + 6) - flt_832D050;
    }
    else
    {
      *((_DWORD *)v10 + 8) = *((_DWORD *)v10 + 7);
      *((_DWORD *)v10 + 6) = 0;
    }
    v8 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    v12 = *v8;
    if ( *v8 )
    {
      if ( *((float *)v10 + 8) == 0.0 && *((float *)v10 + 7) == 0.0 )
      {
        v16 = 0;
        for ( i = 0; i < v12; ++i )
        {
          if ( (unsigned __int8)sub_80C64FE(i + v8[3]) )
            v16 = 1;
        }
        if ( !v16 && *((float *)v10 + 15) == 0.0 && *((float *)v10 + 14) == 0.0 )
          goto LABEL_14;
      }
      else if ( (*(_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) & 3) != 0 )
      {
        v19 = sub_80C639E(a1) * *((float *)v10 + 9) * a2;
        v6 = *v9 + v19;
        v4 = *((_WORD *)v10 + 10);
        if ( v6 >= 1.0 )
        {
          if ( (v8[2] & 2) != 0 )
          {
            v6 = 1.0;
          }
          else
          {
            do
            {
              v6 = v6 - 1.0;
              ++v4;
            }
            while ( v6 >= 1.0 );
          }
        }
        flt_832D000 = v19;
        flt_832D004 = *v9;
        word_832D010 = *((_WORD *)v10 + 10);
        flt_832D008 = v6;
        word_832D012 = v4;
        if ( v17 )
          sub_80C6A18((int)v10, (int)v8, *((_WORD *)v10 + 3));
        else
          sub_80C6A18((int)v10, (int)v8, 0);
        flt_832D004 = *((float *)v10 + 4);
        word_832D010 = *((_WORD *)v10 + 11);
        flt_832D008 = *v9;
        word_832D012 = *((_WORD *)v10 + 10);
        for ( j = 0; j < v12; ++j )
          sub_80C6DE4(j + v8[3], v17);
      }
      else
      {
        v20 = a2 * *((float *)v10 + 9);
        for ( k = 0; k < v12; ++k )
          sub_80C70C2(k + v8[3], v20, v17);
      }
    }
    else if ( *((float *)v10 + 8) == 0.0 && *((float *)v10 + 7) == 0.0 )
    {
      if ( *((float *)v10 + 15) == 0.0 && *((float *)v10 + 14) == 0.0 )
      {
LABEL_14:
        sub_80C631A(dword_832D018, v11);
        *(_WORD *)(dword_832D018 + 2 * a1 + 12) = 0;
        return;
      }
    }
    else
    {
      v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) + 4);
      v18 = *((float *)v10 + 9) * *(float *)(v7 + 8) * a2;
      v5 = *v9 + v18;
      v3 = *((_WORD *)v10 + 10);
      if ( v5 >= 1.0 )
      {
        if ( *(_BYTE *)(v7 + 2) )
        {
          do
          {
            v5 = v5 - 1.0;
            ++v3;
          }
          while ( v5 >= 1.0 );
        }
        else
        {
          v5 = 1.0;
        }
      }
      flt_832D000 = v18;
      flt_832D004 = *v9;
      word_832D010 = *((_WORD *)v10 + 10);
      flt_832D008 = v5;
      word_832D012 = v3;
      if ( v17 )
        sub_80C6A18((int)v10, (int)v8, *((_WORD *)v10 + 3));
      else
        sub_80C6A18((int)v10, (int)v8, 0);
    }
  }
}
// 832D000: using guessed type float flt_832D000;
// 832D010: using guessed type __int16 word_832D010;
// 832D012: using guessed type __int16 word_832D012;
// 832D018: using guessed type int dword_832D018;
// 832D050: using guessed type float flt_832D050;

//----- (080C75BA) --------------------------------------------------------
int __cdecl sub_80C75BA(int a1)
{
  int result; // eax
  unsigned __int16 *v2; // [esp+4h] [ebp-1Ch]
  char *v3; // [esp+8h] [ebp-18h]
  unsigned __int16 v4; // [esp+16h] [ebp-Ah]
  int v5; // [esp+18h] [ebp-8h]
  int i; // [esp+1Ch] [ebp-4h]

  result = *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12);
  v4 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = (char *)&unk_830B000 + 68 * v4 + 12;
    *(_DWORD *)v3 = *((_DWORD *)&unk_830B000 + 17 * v4 + 11);
    *((_WORD *)v3 + 4) = *((_WORD *)&unk_830B000 + 34 * v4 + 25);
    *((_DWORD *)v3 + 4) = *((_DWORD *)&unk_830B000 + 17 * v4 + 14);
    *((_DWORD *)v3 + 6) = *((_DWORD *)&unk_830B000 + 17 * v4 + 16);
    *((_DWORD *)v3 + 3) = *((_DWORD *)&unk_830B000 + 17 * v4 + 13);
    *((_DWORD *)v3 + 5) = *((_DWORD *)&unk_830B000 + 17 * v4 + 15);
    v2 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    v5 = *v2;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v5 )
        break;
      sub_80C75BA(i + v2[3]);
    }
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C769E) --------------------------------------------------------
int __cdecl sub_80C769E(int a1)
{
  unsigned __int16 *v3; // [esp+Ch] [ebp-1Ch]
  char *v4; // [esp+14h] [ebp-14h]
  unsigned __int16 v5; // [esp+1Ah] [ebp-Eh]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  char v8; // [esp+27h] [ebp-1h]

  v5 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( !v5 )
    return 0;
  v4 = (char *)&unk_830B000 + 68 * v5;
  *((_DWORD *)v4 + 15) = *((_DWORD *)v4 + 14);
  *((_DWORD *)v4 + 13) = 0;
  v3 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  v6 = *v3;
  if ( *v3 )
  {
    v8 = 0;
    for ( i = 0; i < v6; ++i )
    {
      if ( (unsigned __int8)sub_80C769E(i + v3[3]) )
        v8 = 1;
    }
    if ( v8
      || *((float *)&unk_830B000 + 17 * v5 + 15) != 0.0
      || *((float *)&unk_830B000 + 17 * v5 + 14) != 0.0
      || *((float *)v4 + 8) != 0.0
      || *((float *)v4 + 7) != 0.0 )
    {
      return 1;
    }
  }
  else if ( *((float *)&unk_830B000 + 17 * v5 + 15) != 0.0
         || *((float *)&unk_830B000 + 17 * v5 + 14) != 0.0
         || *((float *)v4 + 8) != 0.0
         || *((float *)v4 + 7) != 0.0 )
  {
    return 1;
  }
  sub_80C631A(dword_832D018, v5);
  *(_WORD *)(dword_832D018 + 2 * a1 + 12) = 0;
  return 0;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C788A) --------------------------------------------------------
void __cdecl sub_80C788A(int a1)
{
  char v1; // [esp+Bh] [ebp-1Dh]
  unsigned __int16 *v2; // [esp+Ch] [ebp-1Ch]
  char *v3; // [esp+14h] [ebp-14h]
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  int v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  v4 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v4 )
  {
    v3 = (char *)&unk_830B000 + 68 * v4;
    *((_DWORD *)v3 + 11) = *((_DWORD *)v3 + 10);
    *((_WORD *)v3 + 25) = *((_WORD *)v3 + 24);
    if ( flt_832D050 + 0.001 <= *((float *)v3 + 13) )
    {
      *((float *)v3 + 15) = (*((float *)v3 + 14) - *((float *)v3 + 15)) * flt_832D050 / *((float *)v3 + 13)
                          + *((float *)v3 + 15);
      if ( *((float *)v3 + 15) < 0.0000010000001 )
        *((float *)v3 + 15) = *((float *)v3 + 14) * 0.001;
      *((float *)v3 + 13) = *((float *)v3 + 13) - flt_832D050;
    }
    else
    {
      *((_DWORD *)v3 + 15) = *((_DWORD *)v3 + 14);
      *((_DWORD *)v3 + 13) = 0;
    }
    v2 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    v5 = *v2;
    if ( *v2 )
    {
      if ( *((float *)v3 + 15) == 0.0 && *((float *)v3 + 14) == 0.0 )
      {
        v1 = 0;
        for ( i = 0; i < v5; ++i )
        {
          if ( (unsigned __int8)sub_80C769E(i + v2[3]) )
            v1 = 1;
        }
        if ( !v1 && *((float *)v3 + 8) == 0.0 && *((float *)v3 + 7) == 0.0 )
          goto LABEL_12;
      }
      else
      {
        for ( j = 0; j < v5; ++j )
          sub_80C788A(j + v2[3]);
      }
    }
    else if ( *((float *)v3 + 15) == 0.0
           && *((float *)v3 + 14) == 0.0
           && *((float *)v3 + 8) == 0.0
           && *((float *)v3 + 7) == 0.0 )
    {
LABEL_12:
      sub_80C631A(dword_832D018, v4);
      *(_WORD *)(dword_832D018 + 2 * a1 + 12) = 0;
      return;
    }
  }
}
// 832D018: using guessed type int dword_832D018;
// 832D050: using guessed type float flt_832D050;

//----- (080C7B22) --------------------------------------------------------
int __cdecl sub_80C7B22(int a1)
{
  int result; // eax

  if ( *(_WORD *)(a1 + 4) )
  {
    sub_80A40A6(*(_WORD *)(a1 + 4));
    *(_WORD *)(a1 + 4) = 0;
  }
  result = a1;
  *(_WORD *)(a1 + 2) = -1;
  return result;
}

//----- (080C7B56) --------------------------------------------------------
int __cdecl sub_80C7B56(unsigned __int16 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  sub_80AF360(a3);
  return sub_80ADAA0(a1, a2, 1);
}

//----- (080C7B9C) --------------------------------------------------------
long double __cdecl sub_80C7B9C(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  int v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  float v7; // [esp+24h] [ebp-4h]
  float *v8; // [esp+30h] [ebp+8h]

  v7 = sub_80C68B2(a1, (int)a2);
  for ( i = 0; i < *a2; ++i )
  {
    v4 = i + a2[3];
    v3 = *(_WORD *)(dword_832D018 + 2 * v4 + 12);
    if ( v3 )
    {
      v8 = (float *)((char *)&unk_830B000 + 68 * v3);
      if ( v8[15] != 0.0 && v8[14] != 0.0 )
      {
        v5 = sub_80C7B9C(v8, *(_DWORD *)dword_832D018 + 8 * v4 + 8);
        if ( v7 > (long double)v5 )
          v7 = v5;
      }
    }
  }
  return v7;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C7C86) --------------------------------------------------------
long double __cdecl sub_80C7C86(int a1, float a2)
{
  long double v2; // fst7
  float v4; // [esp+14h] [ebp-34h]
  float v5; // [esp+18h] [ebp-30h]
  float v6; // [esp+1Ch] [ebp-2Ch]
  __int16 v7; // [esp+22h] [ebp-26h]
  __int16 v8; // [esp+22h] [ebp-26h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+24h] [ebp-24h]
  int v11; // [esp+28h] [ebp-20h]
  unsigned __int16 *v12; // [esp+30h] [ebp-18h]
  float *v13; // [esp+34h] [ebp-14h]
  float *v14; // [esp+38h] [ebp-10h]
  unsigned __int16 v15; // [esp+3Eh] [ebp-Ah]
  int v16; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  float v18; // [esp+54h] [ebp+Ch]
  float v19; // [esp+54h] [ebp+Ch]
  float v20; // [esp+54h] [ebp+Ch]

  v15 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( !v15 )
    return (float)1.0;
  v14 = (float *)((char *)&unk_830B000 + 68 * v15);
  v13 = v14 + 10;
  if ( v14[15] == 0.0 || v14[14] == 0.0 )
    return (float)1.0;
  v12 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  v16 = *v12;
  if ( *v12 )
  {
    if ( (*(_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) & 3) != 0 )
    {
      v19 = sub_80C639E(a1) * v14[16] * a2;
      if ( v19 == 0.0 )
      {
        v4 = 1.0;
      }
      else
      {
        v10 = v14[11] + v19;
        v8 = *((_WORD *)v14 + 25);
        if ( (v12[2] & 2) != 0 )
        {
          if ( v10 >= 1.0 )
            v10 = 1.0;
        }
        else
        {
          while ( v10 >= 1.0 )
          {
            v10 = v10 - 1.0;
            ++v8;
          }
        }
        if ( *v13 - v10 <= (long double)(v8 - *((__int16 *)v14 + 24)) )
        {
          flt_832D000 = v19;
          flt_832D004 = v14[11];
          word_832D010 = *((_WORD *)v14 + 25);
          flt_832D008 = v10;
          flt_832D00C = *v13;
          word_832D014 = *((_WORD *)v14 + 24);
          v4 = sub_80C7B9C((unsigned __int16 *)v14, v12);
        }
        else
        {
          v4 = 1.0;
        }
      }
    }
    else
    {
      v20 = a2 * v14[16];
      v2 = 0.0;
      if ( v20 == 0.0 )
      {
        v4 = 1.0;
      }
      else
      {
        v5 = 1.0;
        for ( i = 0; i < v16; ++i )
        {
          sub_80C7C86(i + v12[3], v20);
          v6 = v2;
          v2 = v6;
          if ( v5 > (long double)v6 )
            v5 = v6;
        }
        v4 = v5;
      }
    }
  }
  else
  {
    v11 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) + 4);
    v18 = v14[16] * *(float *)(v11 + 8) * a2;
    if ( v18 == 0.0 )
    {
      v4 = 1.0;
    }
    else
    {
      v9 = v14[11] + v18;
      v7 = *((_WORD *)v14 + 25);
      if ( *(_BYTE *)(v11 + 2) )
      {
        while ( v9 >= 1.0 )
        {
          v9 = v9 - 1.0;
          ++v7;
        }
      }
      else if ( v9 >= 1.0 )
      {
        v9 = 1.0;
      }
      if ( *v13 - v9 <= (long double)(v7 - *((__int16 *)v14 + 24)) )
      {
        flt_832D000 = v18;
        flt_832D004 = v14[11];
        word_832D010 = *((_WORD *)v14 + 25);
        flt_832D008 = v9;
        flt_832D00C = *v13;
        word_832D014 = *((_WORD *)v14 + 24);
        v4 = sub_80C68B2((unsigned __int16 *)v14, (int)v12);
      }
      else
      {
        v4 = 1.0;
      }
    }
  }
  return v4;
}
// 832D000: using guessed type float flt_832D000;
// 832D00C: using guessed type float flt_832D00C;
// 832D010: using guessed type __int16 word_832D010;
// 832D014: using guessed type __int16 word_832D014;
// 832D018: using guessed type int dword_832D018;

//----- (080C800C) --------------------------------------------------------
void __cdecl sub_80C800C(unsigned __int16 *a1, int a2)
{
  int v2; // [esp+18h] [ebp-10h]
  int i; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]

  if ( !word_832D04C || !a1[2] )
    return;
  if ( flt_832D004 == 1.0 )
  {
LABEL_4:
    sub_80AF360(word_80F1C0A);
    sub_80ADAA0(word_832D04C, a1[2], 1);
    return;
  }
  if ( !*(_WORD *)a2 )
  {
LABEL_11:
    v4 = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4);
    v2 = *(_DWORD *)(v4 + 20) + 8 * (__int16)a1[1];
    if ( flt_832D004 <= (long double)flt_832D008 )
    {
      if ( flt_832D008 == 1.0 )
      {
        if ( flt_832D004 <= (long double)*(float *)(v2 + 4) )
        {
          do
          {
            sub_80C7B56(word_832D04C, a1[2], *(_WORD *)v2);
            v2 += 8;
          }
          while ( *(_WORD *)v2 );
        }
        return;
      }
      if ( *(float *)(v2 + 4) >= (long double)flt_832D008 || flt_832D004 > (long double)*(float *)(v2 + 4) )
        return;
      do
      {
        sub_80C7B56(word_832D04C, a1[2], *(_WORD *)v2);
        v2 += 8;
      }
      while ( *(_WORD *)v2 && flt_832D008 > (long double)*(float *)(v2 + 4) );
    }
    else if ( flt_832D008 <= (long double)*(float *)(v2 + 4) )
    {
      if ( flt_832D004 > (long double)*(float *)(v2 + 4) )
        return;
      do
      {
        sub_80C7B56(word_832D04C, a1[2], *(_WORD *)v2);
        v2 += 8;
      }
      while ( *(_WORD *)v2 );
      for ( i = *(_DWORD *)(v4 + 20); flt_832D008 > (long double)*(float *)(i + 4); i += 8 )
        sub_80C7B56(word_832D04C, a1[2], *(_WORD *)i);
    }
    else
    {
      do
      {
        sub_80C7B56(word_832D04C, a1[2], *(_WORD *)v2);
        v2 += 8;
      }
      while ( *(_WORD *)v2 && flt_832D008 > (long double)*(float *)(v2 + 4) );
    }
    a1[1] = sub_80C66EA(a2, (int)a1, flt_832D008);
    return;
  }
  if ( *a1 )
  {
    a2 = *(_DWORD *)dword_832D018 + 8 * *a1 + 8;
    goto LABEL_11;
  }
  if ( flt_832D004 > (long double)flt_832D008 || flt_832D008 == 1.0 )
    goto LABEL_4;
}
// 80F1C0A: using guessed type __int16 word_80F1C0A;
// 832D018: using guessed type int dword_832D018;
// 832D04C: using guessed type __int16 word_832D04C;

//----- (080C838A) --------------------------------------------------------
int __cdecl sub_80C838A(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v4; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]
  float *v6; // [esp+20h] [ebp+8h]

  sub_80C800C(a1, (int)a2);
  for ( i = 0; ; ++i )
  {
    result = *a2;
    if ( i >= result )
      break;
    v3 = i + a2[3];
    v4 = *(_WORD *)(dword_832D018 + 2 * v3 + 12);
    if ( v4 )
    {
      v6 = (float *)((char *)&unk_830B000 + 68 * v4);
      if ( v6[15] != 0.0 && v6[14] != 0.0 )
        sub_80C838A(v6, *(_DWORD *)dword_832D018 + 8 * v3 + 8);
    }
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C8450) --------------------------------------------------------
int __cdecl sub_80C8450(int a1)
{
  int result; // eax
  unsigned __int16 *v2; // [esp+4h] [ebp-14h]
  unsigned __int16 v3; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  result = *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12);
  v3 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v3 )
  {
    *((float *)&unk_830B000 + 17 * v3 + 10) = flt_832D008;
    *((_WORD *)&unk_830B000 + 34 * v3 + 24) = word_832D012;
    v2 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    for ( i = 0; ; ++i )
    {
      result = *v2;
      if ( i >= result )
        break;
      sub_80C8450(i + v2[3]);
    }
  }
  return result;
}
// 832D012: using guessed type __int16 word_832D012;
// 832D018: using guessed type int dword_832D018;

//----- (080C84F0) --------------------------------------------------------
void __cdecl sub_80C84F0(int a1, float a2, int a3)
{
  __int16 v3; // [esp+Eh] [ebp-2Ah]
  __int16 v4; // [esp+Eh] [ebp-2Ah]
  float v5; // [esp+10h] [ebp-28h]
  float v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  unsigned __int16 *v8; // [esp+1Ch] [ebp-1Ch]
  float *v9; // [esp+20h] [ebp-18h]
  char *v10; // [esp+24h] [ebp-14h]
  unsigned __int16 v11; // [esp+2Ah] [ebp-Eh]
  int v12; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  unsigned __int8 v14; // [esp+37h] [ebp-1h]
  float v15; // [esp+44h] [ebp+Ch]
  float v16; // [esp+44h] [ebp+Ch]

  v14 = a3;
  v11 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v11 )
  {
    v10 = (char *)&unk_830B000 + 68 * v11;
    v9 = (float *)(v10 + 40);
    if ( *((float *)v10 + 15) != 0.0 )
    {
      if ( *((float *)v10 + 14) == 0.0 )
        v14 = 0;
      v8 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
      v12 = *v8;
      if ( *v8 )
      {
        if ( (*(_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) & 3) != 0 )
        {
          v15 = sub_80C639E(a1) * *((float *)v10 + 16) * a2;
          v6 = *((float *)v10 + 11) + v15;
          v4 = *((_WORD *)v10 + 25);
          if ( (v8[2] & 2) != 0 )
          {
            if ( v6 < 1.0 )
            {
              if ( v6 <= 0.0 )
                return;
            }
            else
            {
              v6 = 1.0;
            }
          }
          else
          {
            while ( v6 < 0.0 )
            {
              v6 = v6 + 1.0;
              --v4;
            }
            while ( v6 >= 1.0 )
            {
              v6 = v6 - 1.0;
              ++v4;
            }
          }
          if ( *v9 - v6 <= (long double)(v4 - *((__int16 *)v10 + 24)) )
          {
            flt_832D008 = v6;
            if ( v14 )
            {
              flt_832D004 = *v9;
              word_832D010 = *((_WORD *)v10 + 24);
              sub_80C838A((unsigned __int16 *)v10, v8);
            }
            word_832D012 = v4;
            sub_80C8450(a1);
          }
        }
        else
        {
          v16 = a2 * *((float *)v10 + 16);
          for ( i = 0; i < v12; ++i )
            sub_80C84F0(i + v8[3], v16, v14);
        }
      }
      else
      {
        v7 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) + 4);
        v5 = a2 * *((float *)v10 + 16) * *(float *)(v7 + 8) + *((float *)v10 + 11);
        v3 = *((_WORD *)v10 + 25);
        if ( *(_BYTE *)(v7 + 2) )
        {
          while ( v5 < 0.0 )
          {
            v5 = v5 + 1.0;
            --v3;
          }
          while ( v5 >= 1.0 )
          {
            v5 = v5 - 1.0;
            ++v3;
          }
        }
        else if ( v5 < 1.0 )
        {
          if ( v5 <= 0.0 )
            return;
        }
        else
        {
          v5 = 1.0;
        }
        if ( *v9 - v5 <= (long double)(v3 - *((__int16 *)v10 + 24)) )
        {
          if ( v14 )
          {
            flt_832D008 = v5;
            flt_832D004 = *v9;
            word_832D010 = *((_WORD *)v10 + 24);
            sub_80C800C((unsigned __int16 *)v10, (int)v8);
          }
          *v9 = v5;
          *((_WORD *)v10 + 24) = v3;
        }
      }
    }
  }
}
// 832D010: using guessed type __int16 word_832D010;
// 832D012: using guessed type __int16 word_832D012;
// 832D018: using guessed type int dword_832D018;

//----- (080C8848) --------------------------------------------------------
int __cdecl sub_80C8848(int a1, float a2, int a3, int a4, int a5)
{
  int v5; // eax
  int result; // eax
  void *v7; // esp
  int v8; // [esp+14h] [ebp-44h] BYREF
  int *v9; // [esp+20h] [ebp-38h]
  float v10; // [esp+24h] [ebp-34h]
  _BYTE *v11; // [esp+28h] [ebp-30h]
  unsigned __int16 *v12; // [esp+2Ch] [ebp-2Ch]
  unsigned __int16 v13; // [esp+32h] [ebp-26h]
  float v14; // [esp+34h] [ebp-24h]
  int v15; // [esp+38h] [ebp-20h]
  int v16; // [esp+3Ch] [ebp-1Ch]
  int j; // [esp+40h] [ebp-18h]
  int i; // [esp+44h] [ebp-14h]
  float v19; // [esp+48h] [ebp-10h]
  float v20; // [esp+4Ch] [ebp-Ch]
  unsigned __int8 v21; // [esp+52h] [ebp-6h]
  unsigned __int8 v22; // [esp+53h] [ebp-5h]

  v22 = a4;
  v21 = a5;
  v12 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  v16 = *v12;
  if ( v16 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v16 )
      {
        if ( v22 )
          result = sub_80C56F6((_DWORD *)a3);
        return result;
      }
      v13 = *(_WORD *)(dword_832D018 + 2 * (i + v12[3]) + 12);
      if ( v13 )
      {
        v19 = *((float *)&unk_830B020 + 17 * v13 + 7 * dword_832D040);
        if ( v19 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v16 )
        return sub_80C8848(i + v12[3], a2, a3, v22, v21);
      v13 = *(_WORD *)(dword_832D018 + 2 * (j + v12[3]) + 12);
      if ( v13 )
      {
        v20 = *((float *)&unk_830B020 + 17 * v13 + 7 * dword_832D040);
        if ( v20 != 0.0 )
          break;
      }
    }
    if ( v22 )
    {
      v9 = (int *)a3;
    }
    else
    {
      v7 = alloca(16 * ((unsigned int)(dword_832D048 + 15) >> 4));
      v9 = &v8;
    }
    v15 = (int)v9;
    sub_80C8848(i + v12[3], v19, (int)v9, 1, 1);
    sub_80C8848(j + v12[3], v20, v15, 0, 1);
    ++j;
    while ( j < v16 )
    {
      v13 = *(_WORD *)(dword_832D018 + 2 * (j + v12[3]) + 12);
      if ( v13 )
      {
        v20 = *((float *)&unk_830B020 + 17 * v13 + 7 * dword_832D040);
        if ( v20 != 0.0 )
          sub_80C8848(j + v12[3], v20, v15, 0, 1);
      }
      ++j;
    }
    if ( v21 )
    {
      if ( v22 )
      {
        i = 0;
        while ( 1 )
        {
          result = i;
          if ( i >= dword_832D044 )
            break;
          if ( ((dword_832D030[i >> 3] >> (i & 7)) & 1) == 0 )
          {
            v14 = *(float *)a3 * *(float *)a3
                + *(float *)(a3 + 4) * *(float *)(a3 + 4)
                + *(float *)(a3 + 8) * *(float *)(a3 + 8)
                + *(float *)(a3 + 12) * *(float *)(a3 + 12);
            if ( v14 != 0.0 )
            {
              v10 = sqrt(v14);
              v14 = a2 / v10;
              *(float *)a3 = *(float *)a3 * v14;
              *(float *)(a3 + 4) = *(float *)(a3 + 4) * v14;
              *(float *)(a3 + 8) = *(float *)(a3 + 8) * v14;
              *(float *)(a3 + 12) = *(float *)(a3 + 12) * v14;
            }
            if ( *(float *)(a3 + 16) != 0.0 )
            {
              v14 = a2 / *(float *)(a3 + 16);
              *(float *)(a3 + 16) = a2;
              *(float *)(a3 + 20) = *(float *)(a3 + 20) * v14;
              *(float *)(a3 + 24) = *(float *)(a3 + 24) * v14;
              *(float *)(a3 + 28) = *(float *)(a3 + 28) * v14;
            }
          }
          ++i;
          a3 += 32;
        }
      }
      else
      {
        i = 0;
        while ( 1 )
        {
          result = i;
          if ( i >= dword_832D044 )
            break;
          if ( ((dword_832D030[i >> 3] >> (i & 7)) & 1) == 0 )
          {
            v14 = *(float *)v15 * *(float *)v15
                + *(float *)(v15 + 4) * *(float *)(v15 + 4)
                + *(float *)(v15 + 8) * *(float *)(v15 + 8)
                + *(float *)(v15 + 12) * *(float *)(v15 + 12);
            if ( v14 != 0.0 )
            {
              v10 = sqrt(v14);
              v14 = a2 / v10;
              *(float *)a3 = *(float *)v15 * v14 + *(float *)a3;
              *(float *)(a3 + 4) = *(float *)(v15 + 4) * v14 + *(float *)(a3 + 4);
              *(float *)(a3 + 8) = *(float *)(v15 + 8) * v14 + *(float *)(a3 + 8);
              *(float *)(a3 + 12) = *(float *)(v15 + 12) * v14 + *(float *)(a3 + 12);
            }
            if ( *(float *)(v15 + 16) != 0.0 )
            {
              v14 = a2 / *(float *)(v15 + 16);
              *(float *)(a3 + 16) = *(float *)(a3 + 16) + a2;
              *(float *)(a3 + 20) = *(float *)(v15 + 20) * v14 + *(float *)(a3 + 20);
              *(float *)(a3 + 24) = *(float *)(v15 + 24) * v14 + *(float *)(a3 + 24);
              *(float *)(a3 + 28) = *(float *)(v15 + 28) * v14 + *(float *)(a3 + 28);
            }
          }
          ++i;
          a3 += 32;
          v15 += 32;
        }
      }
    }
    else
    {
      i = 0;
      while ( 1 )
      {
        result = i;
        if ( i >= dword_832D044 )
          break;
        if ( ((dword_832D030[i >> 3] >> (i & 7)) & 1) == 0 && *(float *)(a3 + 16) != 0.0 )
        {
          v14 = 1.0 / *(float *)(a3 + 16);
          *(float *)a3 = *(float *)a3 * v14;
          *(float *)(a3 + 4) = *(float *)(a3 + 4) * v14;
          *(float *)(a3 + 8) = *(float *)(a3 + 8) * v14;
          *(float *)(a3 + 12) = *(float *)(a3 + 12) * v14;
          *(float *)(a3 + 20) = *(float *)(a3 + 20) * v14;
          *(float *)(a3 + 24) = *(float *)(a3 + 24) * v14;
          *(float *)(a3 + 28) = *(float *)(a3 + 28) * v14;
        }
        ++i;
        a3 += 32;
      }
    }
  }
  else
  {
    if ( v22 )
      sub_80C56F6((_DWORD *)a3);
    v11 = (_BYTE *)(*(_DWORD *)(dword_832D01C + 12) + 2 * *(_DWORD *)(*(_DWORD *)dword_832D018 + 4));
    if ( *(_WORD *)(*(_DWORD *)(dword_832D01C + 12) + 2 * a1) )
    {
      if ( v11[a1 + 1] != *v11 )
      {
        v11[a1 + 1] = *v11;
        sub_80A4106(
          *(_WORD *)(*(_DWORD *)(dword_832D01C + 12) + 2 * a1),
          **(__int16 **)(*(_DWORD *)(*((_DWORD *)v12 + 1) + 4) + 12) + 16);
        *(_WORD *)(*(_DWORD *)(dword_832D01C + 12) + 2 * a1) = sub_80C43BE((int)v12, dword_832D054, dword_832D058);
      }
    }
    else
    {
      v11[a1 + 1] = *v11;
      *(_WORD *)(*(_DWORD *)(dword_832D01C + 12) + 2 * a1) = sub_80C43BE((int)v12, dword_832D054, dword_832D058);
    }
    v5 = SL_ConvertToString(*(_WORD *)(*(_DWORD *)(dword_832D01C + 12) + 2 * a1));
    result = sub_80C5788(
               *((_DWORD *)v12 + 1),
               v5,
               a2,
               a3,
               *(float *)&dword_830B00C[17 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12) + 7 * dword_832D040]);
  }
  return result;
}
// 830B00C: using guessed type int dword_830B00C[];
// 832D018: using guessed type int dword_832D018;
// 832D01C: using guessed type int dword_832D01C;
// 832D040: using guessed type int dword_832D040;
// 832D044: using guessed type int dword_832D044;
// 832D048: using guessed type int dword_832D048;
// 832D054: using guessed type int dword_832D054;
// 832D058: using guessed type int dword_832D058;

//----- (080C9036) --------------------------------------------------------
void __cdecl sub_80C9036(int *a1, int a2, int a3)
{
  char v3; // [esp+4h] [ebp-84h]
  _WORD *v4; // [esp+74h] [ebp-14h]
  unsigned __int16 *v5; // [esp+78h] [ebp-10h]
  unsigned __int16 v6; // [esp+7Eh] [ebp-Ah]
  int v7; // [esp+80h] [ebp-8h]
  int i; // [esp+84h] [ebp-4h]
  int j; // [esp+84h] [ebp-4h]

  v6 = *((_WORD *)a1 + a2 + 6);
  if ( v6 )
  {
    v5 = (unsigned __int16 *)(*a1 + 8 * a2 + 8);
    v7 = *v5;
    v4 = (_WORD *)((char *)&unk_830B000 + 68 * v6);
    if ( *(float *)&v4[14 * dword_832D040 + 16] != 0.0 )
    {
      for ( i = 0; i < a3; ++i )
        Com_Printf(" ", v3);
      if ( v7 )
      {
        if ( dword_832D040 && v4[2] )
        {
          if ( sub_80CB730(*a1, a2) )
          {
            if ( *v4 )
            {
              SL_ConvertToString(v4[2]);
              Com_Printf("(index) %d: (weight) %f -> %f, (time) %f -> %f, '%s', (%f)\n", a2);
            }
            else
            {
              SL_ConvertToString(v4[2]);
              Com_Printf("(index) %d: (weight) %f -> %f, (time) %f -> %f, '%s'\n", a2);
            }
          }
          else
          {
            SL_ConvertToString(v4[2]);
            Com_Printf("(index) %d: (weight) %f -> %f, '%s'\n", a2);
          }
        }
        else if ( sub_80CB730(*a1, a2) )
        {
          Com_Printf("(index) %d: (weight) %f -> %f, (time) %f -> %f\n", a2);
        }
        else
        {
          Com_Printf("(index) %d: (weight) %f -> %f\n", a2);
        }
        for ( j = 0; j < v7; ++j )
          sub_80C9036(a1, j + v5[3], a3 + 1);
      }
      else if ( dword_832D040 && v4[2] )
      {
        SL_ConvertToString(v4[2]);
        Com_Printf(
          "(name) %s: (weight) %f -> %f, (time) %f -> %f, (realtimedelta) %f, '%s' (%f)\n",
          **((_DWORD **)v5 + 1));
      }
      else
      {
        Com_Printf("(name) %s: (weight) %f -> %f, (time) %f -> %f, (realtimedelta) %f\n", **((_DWORD **)v5 + 1));
      }
    }
  }
}
// 80C90D8: variable 'v3' is possibly undefined
// 832D040: using guessed type int dword_832D040;

//----- (080C947C) --------------------------------------------------------
void __cdecl sub_80C947C(int a1, int a2, float a3, int a4, int a5, int a6)
{
  float v6; // [esp+24h] [ebp-74h]
  char *v7; // [esp+28h] [ebp-70h]
  float v8; // [esp+2Ch] [ebp-6Ch]
  float v9; // [esp+30h] [ebp-68h]
  float v10; // [esp+34h] [ebp-64h]
  float v11; // [esp+34h] [ebp-64h]
  float *v12; // [esp+38h] [ebp-60h]
  int v13; // [esp+40h] [ebp-58h]
  unsigned __int16 *v14; // [esp+48h] [ebp-50h]
  unsigned __int16 v15; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v16; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v17; // [esp+4Eh] [ebp-4Ah]
  unsigned __int16 v18; // [esp+4Eh] [ebp-4Ah]
  char v19; // [esp+50h] [ebp-48h] BYREF
  float v20; // [esp+70h] [ebp-28h]
  int v21; // [esp+74h] [ebp-24h]
  int v22; // [esp+78h] [ebp-20h]
  int j; // [esp+7Ch] [ebp-1Ch]
  int i; // [esp+80h] [ebp-18h]
  float v25; // [esp+84h] [ebp-14h]
  float v26; // [esp+88h] [ebp-10h]
  unsigned __int8 v27; // [esp+8Eh] [ebp-Ah]
  unsigned __int8 v28; // [esp+8Fh] [ebp-9h]

  v28 = a5;
  v27 = a6;
  v14 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 8);
  v22 = *v14;
  if ( v22 )
  {
    for ( i = 0; ; ++i )
    {
      if ( i >= v22 )
      {
        if ( v28 )
        {
          *(_DWORD *)a4 = 0;
          *(_DWORD *)(a4 + 4) = 0;
          *(_DWORD *)(a4 + 8) = 0;
          *(_DWORD *)(a4 + 12) = 0;
          *(_DWORD *)(a4 + 16) = 0;
          *(_DWORD *)(a4 + 20) = 0;
        }
        return;
      }
      v16 = *(_WORD *)(a1 + 2 * (i + v14[3]) + 12);
      if ( v16 )
      {
        v9 = dword_832D060 ? *((float *)&unk_830B01C + 17 * v16 + 7 * dword_832D040) : *((float *)&unk_830B020
                                                                                       + 17 * v16
                                                                                       + 7 * dword_832D040);
        v25 = v9;
        if ( v9 != 0.0 )
          break;
      }
    }
    for ( j = i + 1; ; ++j )
    {
      if ( j >= v22 )
      {
        sub_80C947C(a1, i + v14[3], a3, a4, v28, v27);
        return;
      }
      v17 = *(_WORD *)(a1 + 2 * (j + v14[3]) + 12);
      if ( v17 )
      {
        v8 = dword_832D060 ? *((float *)&unk_830B01C + 17 * v17 + 7 * dword_832D040) : *((float *)&unk_830B020
                                                                                       + 17 * v17
                                                                                       + 7 * dword_832D040);
        v26 = v8;
        if ( v8 != 0.0 )
          break;
      }
    }
    if ( v28 )
      v7 = (char *)a4;
    else
      v7 = &v19;
    v21 = (int)v7;
    sub_80C947C(a1, i + v14[3], v25, (int)v7, 1, 1);
    sub_80C947C(a1, j + v14[3], v26, v21, 0, 1);
    ++j;
    while ( j < v22 )
    {
      v18 = *(_WORD *)(a1 + 2 * (j + v14[3]) + 12);
      if ( v18 )
      {
        v6 = dword_832D060 ? *((float *)&unk_830B01C + 17 * v18 + 7 * dword_832D040) : *((float *)&unk_830B020
                                                                                       + 17 * v18
                                                                                       + 7 * dword_832D040);
        v26 = v6;
        if ( v6 != 0.0 )
          sub_80C947C(a1, j + v14[3], v26, v21, 0, 1);
      }
      ++j;
    }
    if ( v27 )
    {
      if ( v28 )
      {
        v20 = *(float *)a4 * *(float *)a4 + *(float *)(a4 + 4) * *(float *)(a4 + 4);
        if ( v20 != 0.0 )
        {
          v10 = sqrt(v20);
          v20 = a3 / v10;
          *(float *)a4 = *(float *)a4 * v20;
          *(float *)(a4 + 4) = *(float *)(a4 + 4) * v20;
        }
        if ( *(float *)(a4 + 8) != 0.0 )
        {
          v20 = a3 / *(float *)(a4 + 8);
          *(float *)(a4 + 8) = a3;
          *(float *)(a4 + 12) = *(float *)(a4 + 12) * v20;
          *(float *)(a4 + 16) = *(float *)(a4 + 16) * v20;
          *(float *)(a4 + 20) = *(float *)(a4 + 20) * v20;
        }
      }
      else
      {
        v20 = *(float *)v21 * *(float *)v21 + *(float *)(v21 + 4) * *(float *)(v21 + 4);
        if ( v20 != 0.0 )
        {
          v11 = sqrt(v20);
          v20 = a3 / v11;
          *(float *)a4 = *(float *)v21 * v20 + *(float *)a4;
          *(float *)(a4 + 4) = *(float *)(v21 + 4) * v20 + *(float *)(a4 + 4);
        }
        if ( *(float *)(v21 + 8) != 0.0 )
        {
          v20 = a3 / *(float *)(v21 + 8);
          *(float *)(a4 + 8) = *(float *)(a4 + 8) + a3;
          *(float *)(a4 + 12) = *(float *)(v21 + 12) * v20 + *(float *)(a4 + 12);
          *(float *)(a4 + 16) = *(float *)(v21 + 16) * v20 + *(float *)(a4 + 16);
          *(float *)(a4 + 20) = *(float *)(v21 + 20) * v20 + *(float *)(a4 + 20);
        }
      }
    }
    else if ( *(float *)(a4 + 8) != 0.0 )
    {
      v20 = 1.0 / *(float *)(a4 + 8);
      *(float *)(a4 + 12) = *(float *)(a4 + 12) * v20;
      *(float *)(a4 + 16) = *(float *)(a4 + 16) * v20;
      *(float *)(a4 + 20) = *(float *)(a4 + 20) * v20;
    }
  }
  else
  {
    if ( v28 )
    {
      *(_DWORD *)a4 = 0;
      *(_DWORD *)(a4 + 4) = 0;
      *(_DWORD *)(a4 + 8) = 0;
      *(_DWORD *)(a4 + 12) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 20) = 0;
    }
    v13 = *(_DWORD *)(*((_DWORD *)v14 + 1) + 4);
    if ( *(_BYTE *)(v13 + 3) )
    {
      v15 = *(_WORD *)(a1 + 2 * a2 + 12);
      if ( v15 )
      {
        v12 = (float *)((char *)&unk_830B000 + 68 * v15 + 28 * dword_832D040 + 12);
        if ( byte_832D05C )
          sub_80C623C(v13, a3, a4, *v12);
        else
          sub_80C6076(v13, a3, a4, v12[1], *v12);
      }
    }
  }
}
// 832D040: using guessed type int dword_832D040;
// 832D05C: using guessed type char byte_832D05C;
// 832D060: using guessed type int dword_832D060;

//----- (080C9B5E) --------------------------------------------------------
long double __cdecl sub_80C9B5E(int a1, int a2)
{
  return (long double)**(unsigned __int16 **)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4)
       / *(float *)(*(_DWORD *)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4) + 4);
}

//----- (080C9B9C) --------------------------------------------------------
long double __cdecl sub_80C9B9C(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 2 * a2 + 12) )
    v3 = *(float *)&dword_830B00C[17 * *(unsigned __int16 *)(a1 + 2 * a2 + 12) + 7 * dword_832D040];
  else
    v3 = 0.0;
  return v3;
}
// 830B00C: using guessed type int dword_830B00C[];
// 832D040: using guessed type int dword_832D040;

//----- (080C9BF4) --------------------------------------------------------
long double __cdecl sub_80C9BF4(int a1, int a2)
{
  float v3; // [esp+0h] [ebp-4h]

  if ( *(_WORD *)(a1 + 2 * a2 + 12) )
    v3 = *((float *)&unk_830B020 + 17 * *(unsigned __int16 *)(a1 + 2 * a2 + 12) + 7 * dword_832D040);
  else
    v3 = 0.0;
  return v3;
}
// 832D040: using guessed type int dword_832D040;

//----- (080C9C4C) --------------------------------------------------------
int __cdecl sub_80C9C4C(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-10h]
  int v5; // [esp+8h] [ebp-8h]
  unsigned __int16 v6; // [esp+Eh] [ebp-2h]

  v6 = *(_WORD *)(a1 + 2 * a2 + 12);
  if ( !v6 )
    return 1;
  v3 = 0;
  if ( *(float *)&dword_830B010[17 * v6 + 7 * dword_832D040] > (long double)*(float *)&dword_830B00C[17 * v6 + 7 * dword_832D040]
    || *(float *)&dword_830B00C[17 * v6 + 7 * dword_832D040] == 1.0
    || (v5 = 28 * dword_832D040 + 68 * v6 + 137408524, *(_WORD *)(v5 + 8) > *(_WORD *)(v5 + 10)) )
  {
    v3 = 1;
  }
  return v3;
}
// 830B00C: using guessed type int dword_830B00C[];
// 830B010: using guessed type int dword_830B010[];
// 832D040: using guessed type int dword_832D040;

//----- (080C9CEE) --------------------------------------------------------
int __cdecl sub_80C9CEE(int a1, int a2)
{
  return *(unsigned __int16 *)(a1 + 8 * a2 + 8);
}

//----- (080C9CFE) --------------------------------------------------------
int __cdecl sub_80C9CFE(int a1, int a2, int a3)
{
  return a3 + *(unsigned __int16 *)(a1 + 8 * a2 + 14);
}

//----- (080C9D12) --------------------------------------------------------
const char *__cdecl sub_80C9D12(int a1, int a2)
{
  const char *v3; // [esp+0h] [ebp-8h]

  if ( *(_WORD *)(a1 + 8 * a2 + 8) )
    v3 = "<non-leaf anim>";
  else
    v3 = **(const char ***)(a1 + 8 * a2 + 12);
  return v3;
}

//----- (080C9D4A) --------------------------------------------------------
int __cdecl sub_80C9D4A(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080C9D54) --------------------------------------------------------
int __cdecl sub_80C9D54(int a1)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (080C9D60) --------------------------------------------------------
int __cdecl sub_80C9D60(int *a1)
{
  int result; // eax

  result = (int)a1;
  if ( *a1 )
  {
    dword_832D018 = *a1;
    result = sub_80C75BA(0);
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;

//----- (080C9D88) --------------------------------------------------------
void __cdecl sub_80C9D88(int *a1, float a2)
{
  if ( *a1 )
  {
    flt_832D050 = a2;
    dword_832D018 = *a1;
    sub_80C788A(0);
  }
}
// 832D018: using guessed type int dword_832D018;
// 832D050: using guessed type float flt_832D050;

//----- (080C9DB8) --------------------------------------------------------
void __cdecl sub_80C9DB8(int a1, float a2)
{
  dword_832D680 = 0;
  if ( *(_DWORD *)a1 )
  {
    word_832D04C = *(_WORD *)(a1 + 18);
    flt_832D050 = a2;
    dword_832D018 = *(_DWORD *)a1;
    sub_80C70C2(0, a2, 1);
  }
}
// 832D018: using guessed type int dword_832D018;
// 832D04C: using guessed type __int16 word_832D04C;
// 832D050: using guessed type float flt_832D050;
// 832D680: using guessed type int dword_832D680;

//----- (080C9E0E) --------------------------------------------------------
int __cdecl sub_80C9E0E(int a1, float a2, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]
  float v6; // [esp+14h] [ebp-4h]

  if ( !*(_DWORD *)a1 )
    return 0;
  word_832D04C = *(_WORD *)(a1 + 18);
  dword_832D018 = *(_DWORD *)a1;
  if ( a3 )
  {
    v6 = sub_80C7C86(0, a2);
    if ( v6 == 1.0 || (v5 = a2 * v6 + 0.001, a2 < (long double)v5) )
    {
      sub_80C84F0(0, a2, 1);
      v4 = 0;
    }
    else
    {
      sub_80C84F0(0, v5, 1);
      v4 = 1;
    }
  }
  else
  {
    sub_80C84F0(0, a2, 0);
    v4 = 0;
  }
  return v4;
}
// 832D018: using guessed type int dword_832D018;
// 832D04C: using guessed type __int16 word_832D04C;

//----- (080C9F14) --------------------------------------------------------
int *__cdecl sub_80C9F14(int a1, int a2)
{
  int *result; // eax
  char v3; // [esp+1Bh] [ebp-2Dh]
  int v4; // [esp+20h] [ebp-28h]
  __int16 *v5; // [esp+24h] [ebp-24h]
  __int16 ***v6; // [esp+28h] [ebp-20h]
  int j; // [esp+2Ch] [ebp-1Ch]
  float *v8; // [esp+30h] [ebp-18h]
  int *v9; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h] BYREF

  result = *(int **)(a1 + 4);
  v9 = result;
  v3 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    dword_832D020[i] = v9[i] | ~*(_DWORD *)(a2 + 4 * i);
    if ( dword_832D020[i] != -1 )
      v3 = 0;
    result = &i;
  }
  if ( !v3 )
  {
    for ( i = 0; i <= 3; ++i )
    {
      v9[i] |= *(_DWORD *)(a2 + 4 * i);
      *(_DWORD *)&dword_832D030[4 * i] = dword_832D020[i];
    }
    dword_832D01C = a1;
    dword_832D018 = *(_DWORD *)a1;
    dword_832D058 = *(unsigned __int8 *)(a1 + 22);
    dword_832D054 = a1 + 28;
    dword_832D044 = *(unsigned __int8 *)(a1 + 23);
    v8 = (float *)&v9[16 * dword_832D044 + 12];
    if ( dword_832D018 )
    {
      dword_832D048 = 32 * dword_832D044;
      byte_832D03F |= 0x80u;
      sub_80C8848(0, 1.0, (int)v8, 1, 0);
    }
    v4 = 0;
    for ( j = 0; ; ++j )
    {
      result = (int *)j;
      if ( j >= dword_832D058 )
        break;
      v6 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(dword_832D054 + 4 * j) + 4) + 4);
      i = *((__int16 *)v6 + 2);
      while ( i )
      {
        if ( ((*((char *)dword_832D020 + (v4 >> 3)) >> (v4 & 7)) & 1) == 0 )
        {
          *v8 = 0.0;
          v8[1] = 0.0;
          v8[2] = 0.0;
          v8[3] = 1.0;
          v8[7] = 0.0;
          v8[6] = 0.0;
          v8[5] = 0.0;
        }
        --i;
        v8 += 8;
        ++v4;
      }
      v5 = (__int16 *)v6[3];
      i = ***v6 - *((__int16 *)v6 + 2);
      while ( i )
      {
        if ( ((*((char *)dword_832D020 + (v4 >> 3)) >> (v4 & 7)) & 1) == 0 )
        {
          *v8 = (long double)*v5 * 0.000030518509;
          v8[1] = (long double)v5[1] * 0.000030518509;
          v8[2] = (long double)v5[2] * 0.000030518509;
          v8[3] = (long double)v5[3] * 0.000030518509;
          v8[7] = 0.0;
          v8[6] = 0.0;
          v8[5] = 0.0;
        }
        --i;
        v8 += 8;
        ++v4;
        v5 += 4;
      }
    }
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;
// 832D01C: using guessed type int dword_832D01C;
// 832D020: using guessed type int dword_832D020[];
// 832D03F: using guessed type char byte_832D03F;
// 832D044: using guessed type int dword_832D044;
// 832D048: using guessed type int dword_832D048;
// 832D054: using guessed type int dword_832D054;
// 832D058: using guessed type int dword_832D058;

//----- (080CA206) --------------------------------------------------------
int __cdecl sub_80CA206(int **a1)
{
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]

  if ( !*a1 )
    return Com_Printf("NO TREE\n", v2);
  sub_80C9036(*a1, 0, 0);
  return Com_Printf("\n", v3);
}
// 80CA21B: variable 'v2' is possibly undefined
// 80CA246: variable 'v3' is possibly undefined

//----- (080CA24E) --------------------------------------------------------
int __cdecl sub_80CA24E(int a1, int a2, float *a3, _DWORD *a4, int a5)
{
  int result; // eax
  int v6; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+24h] [ebp-24h]
  int v8; // [esp+2Ch] [ebp-1Ch]
  int v9; // [esp+30h] [ebp-18h]
  int v10; // [esp+34h] [ebp-14h]

  byte_832D05C = 0;
  dword_832D060 = a5;
  sub_80C947C(a1, a2, 1.0, (int)&v6, 1, 0);
  if ( *(float *)&v6 == 0.0 || v7 == 0.0 )
  {
    *a3 = 0.0;
    a3[1] = 1.0;
  }
  else
  {
    *a3 = *(float *)&v6;
    a3[1] = v7;
  }
  *a4 = v8;
  a4[1] = v9;
  result = v10;
  a4[2] = v10;
  return result;
}
// 832D05C: using guessed type char byte_832D05C;
// 832D060: using guessed type int dword_832D060;

//----- (080CA302) --------------------------------------------------------
int __cdecl sub_80CA302(int a1, int a2, float *a3, _DWORD *a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+2Ch] [ebp-1Ch]
  int v8; // [esp+30h] [ebp-18h]
  int v9; // [esp+34h] [ebp-14h]

  byte_832D05C = 1;
  dword_832D060 = 1;
  sub_80C947C(a1, a2, 1.0, (int)&v5, 1, 0);
  if ( *(float *)&v5 == 0.0 && v6 == 0.0 )
  {
    *a3 = 0.0;
    a3[1] = 1.0;
  }
  else
  {
    *a3 = *(float *)&v5;
    a3[1] = v6;
  }
  *a4 = v7;
  a4[1] = v8;
  result = v9;
  a4[2] = v9;
  return result;
}
// 832D05C: using guessed type char byte_832D05C;
// 832D060: using guessed type int dword_832D060;

//----- (080CA3B6) --------------------------------------------------------
int __cdecl sub_80CA3B6(int a1, int a2, int a3, int a4, float a5, float a6)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-38h]
  int v8; // [esp+30h] [ebp-28h] BYREF
  float v9; // [esp+34h] [ebp-24h]
  int v10; // [esp+38h] [ebp-20h]
  int v11; // [esp+3Ch] [ebp-1Ch]
  int v12; // [esp+40h] [ebp-18h]
  int v13; // [esp+44h] [ebp-14h]

  if ( *(_WORD *)(a1 + 8 * a2 + 8) || (v7 = *(_DWORD *)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4), !*(_BYTE *)(v7 + 3)) )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 1065353216;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = 0;
    result = a4 + 8;
    *(_DWORD *)(a4 + 8) = 0;
  }
  else
  {
    *(float *)&v8 = 0.0;
    v9 = 0.0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    sub_80C6076(v7, 1.0, (int)&v8, a5, a6);
    if ( *(float *)&v8 == 0.0 && v9 == 0.0 )
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 1065353216;
    }
    else
    {
      *(float *)a3 = *(float *)&v8;
      *(float *)(a3 + 4) = v9;
    }
    *(_DWORD *)a4 = v11;
    *(_DWORD *)(a4 + 4) = v12;
    result = v13;
    *(_DWORD *)(a4 + 8) = v13;
  }
  return result;
}

//----- (080CA4F4) --------------------------------------------------------
int __cdecl sub_80CA4F4(int a1, int a2, int a3, int a4, float a5)
{
  int result; // eax
  int v6; // [esp+10h] [ebp-38h]
  int v7; // [esp+20h] [ebp-28h] BYREF
  float v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  int v10; // [esp+2Ch] [ebp-1Ch]
  int v11; // [esp+30h] [ebp-18h]
  int v12; // [esp+34h] [ebp-14h]

  if ( *(_WORD *)(a1 + 8 * a2 + 8) || (v6 = *(_DWORD *)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4), !*(_BYTE *)(v6 + 3)) )
  {
    *(_DWORD *)a3 = 0;
    *(_DWORD *)(a3 + 4) = 1065353216;
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 4) = 0;
    result = a4 + 8;
    *(_DWORD *)(a4 + 8) = 0;
  }
  else
  {
    *(float *)&v7 = 0.0;
    v8 = 0.0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    sub_80C623C(v6, 1.0, (int)&v7, a5);
    if ( *(float *)&v7 == 0.0 && v8 == 0.0 )
    {
      *(_DWORD *)a3 = 0;
      *(_DWORD *)(a3 + 4) = 1065353216;
    }
    else
    {
      *(float *)a3 = *(float *)&v7;
      *(float *)(a3 + 4) = v8;
    }
    *(_DWORD *)a4 = v10;
    *(_DWORD *)(a4 + 4) = v11;
    result = v12;
    *(_DWORD *)(a4 + 8) = v12;
  }
  return result;
}

//----- (080CA62A) --------------------------------------------------------
int __cdecl sub_80CA62A(int a1, int a2)
{
  unsigned __int16 v3; // [esp+16h] [ebp-2h]

  v3 = word_830B00A[0];
  if ( !word_830B00A[0] )
    Com_Error(1, (char *)&byte_80E5AE0);
  if ( ++dword_832D684 > dword_832D688 )
    dword_832D688 = dword_832D684;
  ++*(_DWORD *)(a1 + 4);
  word_830B00A[0] = word_830B00A[34 * v3];
  word_830B008[34 * (unsigned __int16)word_830B00A[0]] = 0;
  *(_WORD *)(a1 + 2 * a2 + 12) = v3;
  return 68 * v3 + 137408512;
}
// 830B008: using guessed type __int16 word_830B008[];
// 830B00A: using guessed type __int16 word_830B00A[];
// 832D684: using guessed type int dword_832D684;
// 832D688: using guessed type int dword_832D688;

//----- (080CA6E8) --------------------------------------------------------
int __cdecl sub_80CA6E8(_DWORD *a1, int a2)
{
  while ( a2 )
  {
    a2 = *(unsigned __int16 *)(*a1 + 8 * a2 + 10);
    if ( *((float *)&unk_830B020 + 17 * *((unsigned __int16 *)a1 + a2 + 6) + 7 * dword_832D040) == 0.0 )
      return 0;
  }
  return 1;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CA768) --------------------------------------------------------
int __cdecl sub_80CA768(_DWORD *a1, int a2)
{
  int i; // [esp+Ch] [ebp-10h]
  int v5; // [esp+10h] [ebp-Ch]
  unsigned __int16 *v6; // [esp+14h] [ebp-8h]
  unsigned __int16 v7; // [esp+1Ah] [ebp-2h]

  v7 = *((_WORD *)a1 + a2 + 6);
  if ( !v7 )
    return 0;
  if ( *((float *)&unk_830B020 + 17 * v7 + 7 * dword_832D040) == 0.0 )
    return 0;
  v6 = (unsigned __int16 *)(*a1 + 8 * a2 + 8);
  v5 = *v6;
  if ( !*v6 )
    return 1;
  for ( i = 0; i < v5; ++i )
  {
    if ( (unsigned __int8)sub_80CA768(a1, i + v6[3]) )
      return 1;
  }
  return 0;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CA848) --------------------------------------------------------
int __cdecl sub_80CA848(_DWORD *a1, int a2)
{
  int v3; // [esp+14h] [ebp-4h]

  v3 = 0;
  if ( (unsigned __int8)sub_80CA6E8(a1, a2) && (unsigned __int8)sub_80CA768(a1, a2) )
    v3 = 1;
  return v3;
}

//----- (080CA88E) --------------------------------------------------------
void __cdecl sub_80CA88E(_DWORD *a1, int a2, float a3)
{
  int v3; // [esp+Ch] [ebp-Ch]
  char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *((_WORD *)a1 + a2 + 6);
  if ( v5 )
  {
    v4 = (char *)&unk_830B000 + 68 * v5;
    v3 = (int)&v4[28 * dword_832D040 + 12];
    if ( (unsigned __int8)sub_80CA848(a1, a2) )
    {
      if ( *(float *)(v3 + 16) == 0.0 )
      {
        if ( *(float *)(v3 + 12) > (long double)a3 )
          *(float *)(v3 + 12) = a3;
      }
      else
      {
        *(_DWORD *)(v3 + 16) = 0;
        *(float *)(v3 + 12) = a3;
      }
    }
    else
    {
      *(_DWORD *)(v3 + 20) = 0;
      *(_DWORD *)(v3 + 12) = 0;
      *(_DWORD *)(v3 + 16) = 0;
    }
    if ( dword_832D040 )
      sub_80C7B22((int)v4);
  }
}
// 832D040: using guessed type int dword_832D040;

//----- (080CA978) --------------------------------------------------------
int __cdecl sub_80CA978(_DWORD *a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = a2;
  if ( *((_WORD *)a1 + a2 + 6) )
  {
    sub_80CA88E(a1, a2, a3);
    v4 = (unsigned __int16 *)(*a1 + 8 * a2 + 8);
    v6 = *v4;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v6 )
        break;
      sub_80CA978(a1, i + v4[3], LODWORD(a3));
    }
  }
  return result;
}

//----- (080CA9FC) --------------------------------------------------------
int __cdecl sub_80CA9FC(int a1, int a2, float a3)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  return sub_80CA978((_DWORD *)a1, a2, a3);
}

//----- (080CAA36) --------------------------------------------------------
int __cdecl sub_80CAA36(int a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v4 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 8);
  v6 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    sub_80CA978((_DWORD *)a1, i + v4[3], a3);
  }
  return result;
}

//----- (080CAAAA) --------------------------------------------------------
int __cdecl sub_80CAAAA(int a1, int a2, float a3, float a4)
{
  int result; // eax
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  unsigned __int16 v8; // [esp+22h] [ebp-26h]
  float v9; // [esp+28h] [ebp-20h]
  float v10; // [esp+30h] [ebp-18h]
  unsigned __int16 *v11; // [esp+38h] [ebp-10h]
  int v12; // [esp+40h] [ebp-8h]
  int i; // [esp+44h] [ebp-4h]
  int j; // [esp+44h] [ebp-4h]

  if ( a2 )
  {
    v11 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 10) + 8);
    v9 = 0.0;
    v12 = *v11;
    for ( i = 0; i < v12; ++i )
    {
      v8 = *(_WORD *)(a1 + 2 * (i + v11[3]) + 12);
      if ( v8 )
        v7 = *((float *)&unk_830B020 + 17 * v8 + 7 * dword_832D040);
      else
        v7 = 0.0;
      if ( i + v11[3] == a2 )
      {
        v5 = a3 - v7;
        v6 = sub_80CC480(v5);
      }
      else
      {
        v6 = v7;
      }
      if ( v6 > (long double)v9 )
        v9 = v6;
    }
    v10 = v9 * a4;
    if ( v10 < 0.001 )
      v10 = 0.0;
    for ( j = 0; ; ++j )
    {
      result = j;
      if ( j >= v12 )
        break;
      if ( j + v11[3] != a2 )
        sub_80CA88E((_DWORD *)a1, j + v11[3], v10);
    }
  }
  return result;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CAC28) --------------------------------------------------------
float *__cdecl sub_80CAC28(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80CAAAA(a1, a2, a3, a4);
  return sub_80CBE66(a1, a2, a3, SLODWORD(a4), a5, (unsigned __int16)a6, (unsigned __int16)a7, a8);
}

//----- (080CACB6) --------------------------------------------------------
int __cdecl sub_80CACB6(int a1, int a2, int a3, float a4, float a5, int a6, int a7, int a8, int a9)
{
  int v11; // [esp+20h] [ebp-8h]

  dword_832D018 = a1;
  if ( a4 < 0.001 )
    a4 = 0.0;
  sub_80CAAAA(a1, a2, a4, a5);
  v11 = sub_80CB20E(a2, a4, SLODWORD(a5), a6, 0, (unsigned __int16)a7, (unsigned __int16)a8);
  sub_80CBC66(a2, SLODWORD(a5));
  sub_80CBA7A(a2, a9);
  if ( dword_832D040 )
  {
LABEL_4:
    sub_80CB8FC(a2);
    goto LABEL_5;
  }
  while ( 1 )
  {
LABEL_5:
    if ( !a2 )
      return 1;
    a2 = *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 10);
    if ( a2 == a3 )
      return v11;
    sub_80CAAAA(a1, a2, 1.0, a5);
    sub_80CB20E(a2, 1.0, SLODWORD(a5), 1065353216, 0, 0, 0);
    sub_80CBA7A(a2, a9);
    if ( dword_832D040 )
      goto LABEL_4;
  }
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CAE42) --------------------------------------------------------
int __cdecl sub_80CAE42(int a1, int a2, float a3, float a4, int a5, int a6, int a7, int a8)
{
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80CAAAA(a1, a2, a3, a4);
  return sub_80CBCDE(a1, a2, a3, SLODWORD(a4), a5, (unsigned __int16)a6, (unsigned __int16)a7, a8);
}

//----- (080CAED0) --------------------------------------------------------
int __cdecl sub_80CAED0(int a1, int a2, float a3)
{
  int result; // eax
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  if ( a3 < 0.001 )
    a3 = 0.0;
  v4 = (unsigned __int16 *)(*(_DWORD *)a1 + 8 * a2 + 8);
  v5 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v5 )
      break;
    sub_80CA88E((_DWORD *)a1, i + v4[3], a3);
  }
  return result;
}

//----- (080CAF44) --------------------------------------------------------
int __cdecl sub_80CAF44(_DWORD *a1, int a2)
{
  int result; // eax
  unsigned __int16 *v3; // [esp+8h] [ebp-10h]
  unsigned __int16 v4; // [esp+Eh] [ebp-Ah]
  int i; // [esp+10h] [ebp-8h]
  int v6; // [esp+14h] [ebp-4h]

  result = *((unsigned __int16 *)a1 + a2 + 6);
  v4 = *((_WORD *)a1 + a2 + 6);
  if ( v4 )
  {
    v3 = (unsigned __int16 *)(*a1 + 8 * a2 + 8);
    v6 = *v3;
    for ( i = 0; i < v6; ++i )
      sub_80CAF44(a1, i + v3[3]);
    sub_80C631A((int)a1, v4);
    result = a2;
    *((_WORD *)a1 + a2 + 6) = 0;
  }
  return result;
}

//----- (080CAFD0) --------------------------------------------------------
int *__cdecl sub_80CAFD0(_DWORD *a1)
{
  int *result; // eax
  int i; // [esp+20h] [ebp-18h] BYREF
  int j; // [esp+24h] [ebp-14h]
  int v4; // [esp+28h] [ebp-10h]
  int v5; // [esp+2Ch] [ebp-Ch]
  int v6; // [esp+30h] [ebp-8h]
  int v7; // [esp+34h] [ebp-4h]

  sub_80CAF44(a1, 0);
  v5 = *(_DWORD *)(*a1 + 4);
  v6 = 2 * v5 + 12;
  v7 = 3 * v5 + 1;
  result = (_DWORD *)((char *)a1 + v6);
  v4 = (int)a1 + v6;
  for ( i = 2; i; --i )
  {
    for ( j = *(_DWORD *)(*a1 + 4) - 1; j >= 0; --j )
    {
      if ( *(_WORD *)(v4 + 2 * j) )
      {
        sub_80A4106(*(_WORD *)(v4 + 2 * j), **(__int16 **)(*(_DWORD *)(*(_DWORD *)(*a1 + 8 * j + 12) + 4) + 12) + 16);
        *(_WORD *)(v4 + 2 * j) = 0;
      }
    }
    v4 = (int)a1 + v6 + v7;
    result = &i;
  }
  return result;
}

//----- (080CB0C2) --------------------------------------------------------
int __cdecl sub_80CB0C2(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  result = a1 + 40;
  *(_WORD *)(a1 + 50) = 0;
  return result;
}

//----- (080CB0F8) --------------------------------------------------------
int __cdecl sub_80CB0F8(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 12) = 0;
  *(_WORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  result = a1 + 12;
  *(_WORD *)(a1 + 22) = 0;
  return result;
}

//----- (080CB12E) --------------------------------------------------------
int __cdecl sub_80CB12E(int a1)
{
  unsigned __int16 *v3; // [esp+8h] [ebp-18h]
  int i; // [esp+Ch] [ebp-14h]
  int v5; // [esp+10h] [ebp-10h]
  int v6; // [esp+14h] [ebp-Ch]
  float v7; // [esp+18h] [ebp-8h]
  float v8; // [esp+1Ch] [ebp-4h]

  v3 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  if ( !*v3 )
    return a1;
  v8 = 0.0;
  v5 = 0;
  for ( i = 0; i < *v3; ++i )
  {
    v7 = *((float *)&unk_830B01C + 17 * *(unsigned __int16 *)(dword_832D018 + 2 * (i + v3[3]) + 12) + 7 * dword_832D040);
    if ( v8 < (long double)v7 )
    {
      v6 = sub_80CB12E(i + v3[3]);
      if ( v6 )
      {
        v8 = v7;
        v5 = v6;
      }
    }
  }
  return v5;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CB20E) --------------------------------------------------------
int __cdecl sub_80CB20E(int a1, float a2, int a3, int a4, int a5, int a6, int a7)
{
  float *v7; // eax
  float v9; // [esp+0h] [ebp-28h]
  float *v11; // [esp+14h] [ebp-14h]
  _WORD *v12; // [esp+18h] [ebp-10h]
  unsigned __int16 v13; // [esp+1Ch] [ebp-Ch]

  v13 = *(_WORD *)(dword_832D018 + 2 * a1 + 12);
  if ( v13 )
  {
    v12 = (_WORD *)((char *)&unk_830B000 + 68 * v13);
    if ( dword_832D040 && v12[2] )
      sub_80A40A6(v12[2]);
LABEL_9:
    if ( !a1 )
    {
      a2 = 1.0;
      *(float *)&a3 = 0.0;
      a4 = 1065353216;
    }
    v7 = (float *)&v12[14 * dword_832D040];
    v11 = v7 + 3;
    v7[7] = a2;
    v9 = a2 - v7[8];
    v7[6] = sub_80CC480(v9) * *(float *)&a3;
    if ( v11[3] >= 0.001 )
    {
      if ( v11[5] == 0.0 )
        v11[5] = a2 * 0.001;
    }
    else
    {
      v11[3] = 0.0;
      v11[5] = a2;
    }
    *(_DWORD *)&v12[14 * dword_832D040 + 18] = a4;
    if ( dword_832D040 )
    {
      v12[2] = a6;
      if ( (_WORD)a6 )
        sub_80A3F08(a6);
      v12[1] = -1;
      if ( (_WORD)a6
        && *(_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8)
        && (*(_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 12) & 3) != 0 )
      {
        *v12 = sub_80CB12E(a1);
        if ( !*v12 )
          return 2;
      }
      else
      {
        *v12 = 0;
      }
    }
    else
    {
      v12[3] = a7;
    }
    return 0;
  }
  if ( a2 != 0.0 || (_BYTE)a5 )
  {
    v12 = (_WORD *)sub_80CA62A(dword_832D018, a1);
    sub_80D2FE9(v12 + 6, 0, 0x38u);
    v12[2] = 0;
    v12[1] = -1;
    *v12 = 0;
    v12[3] = 0;
    goto LABEL_9;
  }
  return 0;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CB470) --------------------------------------------------------
int __cdecl sub_80CB470(int a1, int a2)
{
  int result; // eax

  result = a2;
  dword_830B010[17 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12) + 5 + 7 * dword_832D040] = a2;
  return result;
}
// 830B010: using guessed type int dword_830B010[];
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CB4BC) --------------------------------------------------------
int __cdecl sub_80CB4BC(_DWORD *a1, int a2, unsigned __int8 a3)
{
  int result; // eax
  __int16 v4; // [esp+18h] [ebp-20h]
  __int16 v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]
  int v8; // [esp+2Ch] [ebp-Ch]
  unsigned __int16 *v9; // [esp+30h] [ebp-8h]

  v9 = (unsigned __int16 *)&a1[2 * a2 + 2];
  v8 = *v9;
  if ( *v9 )
  {
    if ( (a1[2 * a2 + 3] & 3) != 0 )
    {
      v6 = 0;
      do
      {
        ++v6;
        v9 = (unsigned __int16 *)&a1[2 * v9[3] + 2];
      }
      while ( *v9 );
      Com_Error(1, (char *)&byte_80E5BC0, *a1, v6, **((_DWORD **)v9 + 1));
    }
    v4 = a1[2 * a2 + 3];
    if ( a3 )
      v5 = v4 | 1;
    else
      v5 = v4 | 2;
    LOWORD(a1[2 * a2 + 3]) = v5;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= v8 )
        break;
      sub_80CB4BC(a1, i + HIWORD(a1[2 * a2 + 3]), a3);
    }
  }
  else
  {
    result = *(unsigned __int8 *)(*(_DWORD *)(a1[2 * a2 + 3] + 4) + 2);
    if ( (_BYTE)result != a3 )
    {
      if ( a3 )
        Com_Error(1, (char *)&byte_80E5B40, *(_DWORD *)a1[2 * a2 + 3], *a1);
      Com_Error(1, (char *)&byte_80E5B80, *(_DWORD *)a1[2 * a2 + 3], *a1);
    }
  }
  return result;
}

//----- (080CB634) --------------------------------------------------------
int __cdecl sub_80CB634(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  result = LOWORD(a1[2 * a2 + 2]);
  v6 = result;
  if ( LOWORD(a1[2 * a2 + 2]) )
  {
    v3 = a1[2 * a2 + 3] & 3;
    if ( (a1[2 * a2 + 3] & 3) != 0 )
    {
      if ( v3 == 3 )
        Com_Error(1, (char *)&byte_80E5C20);
      LOWORD(a1[2 * a2 + 3]) |= 4u;
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v6 )
          break;
        sub_80CB4BC(a1, i + HIWORD(a1[2 * a2 + 3]), v3 == 1);
      }
    }
    else
    {
      for ( j = 0; ; ++j )
      {
        result = j;
        if ( j >= v6 )
          break;
        sub_80CB634(a1, j + HIWORD(a1[2 * a2 + 3]));
      }
    }
  }
  return result;
}

//----- (080CB714) --------------------------------------------------------
int __cdecl sub_80CB714(_DWORD *a1)
{
  return sub_80CB634(a1, 0);
}

//----- (080CB730) --------------------------------------------------------
int __cdecl sub_80CB730(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  if ( !*(_WORD *)(a1 + 8 * a2 + 8) || (*(_WORD *)(a1 + 8 * a2 + 12) & 3) != 0 )
    v3 = 1;
  return v3;
}

//----- (080CB772) --------------------------------------------------------
_BOOL4 __cdecl sub_80CB772(int a1, int a2)
{
  return *(_WORD *)(a1 + 8 * a2 + 8) == 0;
}

//----- (080CB78A) --------------------------------------------------------
char *__cdecl sub_80CB78A(int a1, int a2, int a3)
{
  char *result; // eax
  char *v4; // eax
  unsigned __int16 v5; // [esp+Eh] [ebp-2h]

  result = (char *)*(unsigned __int16 *)(a1 + 2 * a2 + 12);
  v5 = *(_WORD *)(a1 + 2 * a2 + 12);
  if ( v5 )
  {
    v4 = (char *)&unk_830B000 + 68 * v5 + 28 * dword_832D040;
    *((_DWORD *)v4 + 3) = a3;
    *((_WORD *)v4 + 10) = 0;
    *((_DWORD *)v4 + 4) = a3;
    result = v4 + 12;
    *((_WORD *)result + 5) = 0;
  }
  return result;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CB814) --------------------------------------------------------
int __cdecl sub_80CB814(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 28 * dword_832D040 + 12) = *(_DWORD *)(a1 + 28 * dword_832D040 + 12);
  *(_WORD *)(a2 + 28 * dword_832D040 + 20) = *(_WORD *)(a1 + 28 * dword_832D040 + 20);
  *(_DWORD *)(a2 + 28 * dword_832D040 + 16) = *(_DWORD *)(a1 + 28 * dword_832D040 + 16);
  result = *(unsigned __int16 *)(a1 + 28 * dword_832D040 + 22);
  *(_WORD *)(a2 + 28 * dword_832D040 + 22) = result;
  return result;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CB8EE) --------------------------------------------------------
int __cdecl XAnimSetUser(int a1)
{
  int result; // eax

  result = a1;
  dword_832D040 = a1;
  return result;
}
// 832D040: using guessed type int dword_832D040;

//----- (080CB8FC) --------------------------------------------------------
float *__cdecl sub_80CB8FC(int a1)
{
  float *result; // eax
  _WORD *v2; // [esp+Ch] [ebp-Ch]
  float *v3; // [esp+10h] [ebp-8h]

  v3 = (float *)((char *)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
  result = v3;
  if ( *((_WORD *)v3 + 2) )
  {
    if ( v3[10] == 1.0 )
    {
      result = (float *)((char *)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
      *((_WORD *)v3 + 1) = -1;
      return result;
    }
    v2 = (_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
    if ( *v2 )
    {
      result = (float *)((char *)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
      if ( !*(_WORD *)v3 )
        return result;
      v2 = (_WORD *)(*(_DWORD *)dword_832D018 + 8 * *(unsigned __int16 *)v3 + 8);
    }
    result = (float *)sub_80C66EA((int)v2, (int)v3, v3[10]);
    *((_WORD *)v3 + 1) = (_WORD)result;
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;

//----- (080CB9C0) --------------------------------------------------------
int __cdecl sub_80CB9C0(int a1, int a2)
{
  int result; // eax
  unsigned __int16 v3; // [esp+Ah] [ebp-Eh]
  int i; // [esp+Ch] [ebp-Ch]
  unsigned __int16 *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+20h] [ebp+8h]

  v5 = (unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  for ( i = 0; ; ++i )
  {
    result = *v5;
    if ( i >= result )
      break;
    v6 = i + v5[3];
    v3 = *(_WORD *)(dword_832D018 + 2 * v6 + 12);
    if ( v3 )
    {
      sub_80CB814(a2, (int)&unk_830B000 + 68 * v3);
      if ( dword_832D040 )
        sub_80CB8FC(v6);
      sub_80CB9C0(v6, a2);
    }
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CBA7A) --------------------------------------------------------
int __cdecl sub_80CBA7A(int a1, int a2)
{
  int result; // eax
  _WORD *v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  char *v5; // [esp+20h] [ebp-8h]

  for ( i = a1; i; i = *(unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * i + 10) )
  {
    v5 = (char *)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * i + 12);
    if ( *(_WORD *)(*(_DWORD *)dword_832D018 + 8 * i + 8)
      && (*(_WORD *)(*(_DWORD *)dword_832D018 + 8 * i + 12) & 4) != 0 )
    {
      if ( a2 || !(unsigned __int8)sub_80CA848((_DWORD *)dword_832D018, i) )
      {
        if ( dword_832D040 )
          sub_80CB0C2((int)v5);
        else
          sub_80CB0F8((int)v5);
      }
      sub_80CB9C0(a1, (int)v5);
      while ( 1 )
      {
        result = a1;
        if ( a1 == i )
          break;
        sub_80CB814((int)v5, (int)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
        if ( dword_832D040 )
          sub_80CB8FC(a1);
        a1 = *(unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * a1 + 10);
      }
      return result;
    }
  }
  v3 = (_WORD *)(*(_DWORD *)dword_832D018 + 8 * a1 + 8);
  result = (unsigned __int16)*v3;
  if ( !*v3 )
  {
    if ( a2 || (result = sub_80CA848((_DWORD *)dword_832D018, a1), !(_BYTE)result) )
    {
      if ( dword_832D040 )
        result = sub_80CB0C2((int)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
      else
        result = sub_80CB0F8((int)&unk_830B000 + 68 * *(unsigned __int16 *)(dword_832D018 + 2 * a1 + 12));
    }
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CBC66) --------------------------------------------------------
int __cdecl sub_80CBC66(int a1, int a2)
{
  int result; // eax
  int i; // [esp+24h] [ebp-4h]

  result = a1;
  for ( i = a1; i; result = sub_80CB20E(i, 0.0, a2, 1065353216, 1, 0, 0) )
  {
    i = *(unsigned __int16 *)(*(_DWORD *)dword_832D018 + 8 * i + 10);
    result = i;
    if ( *(_WORD *)(dword_832D018 + 2 * i + 12) )
      break;
  }
  return result;
}
// 832D018: using guessed type int dword_832D018;

//----- (080CBCDE) --------------------------------------------------------
int __cdecl sub_80CBCDE(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // [esp+20h] [ebp-8h]

  dword_832D018 = a1;
  if ( a3 < 0.001 )
    a3 = 0.0;
  v9 = sub_80CB20E(a2, a3, a4, a5, 0, (unsigned __int16)a6, (unsigned __int16)a7);
  sub_80CBC66(a2, a4);
  sub_80CBA7A(a2, a8);
  if ( dword_832D040 )
    sub_80CB8FC(a2);
  return v9;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CBD8C) --------------------------------------------------------
int __cdecl sub_80CBD8C(int a1, int a2, int a3)
{
  dword_832D018 = a1;
  return sub_80CB470(a2, a3);
}
// 832D018: using guessed type int dword_832D018;

//----- (080CBDAE) --------------------------------------------------------
int __cdecl sub_80CBDAE(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]

  if ( *(_WORD *)(a1 + 8 * a2 + 8) )
    v3 = *(_BYTE *)(a1 + 8 * a2 + 12) & 1;
  else
    v3 = *(unsigned __int8 *)(*(_DWORD *)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4) + 2);
  return v3;
}

//----- (080CBDF2) --------------------------------------------------------
int __cdecl sub_80CBDF2(int a1, int a2, __int16 a3)
{
  _WORD *v5; // [esp+4h] [ebp-10h]

  v5 = *(_WORD **)(*(_DWORD *)(*(_DWORD *)(a1 + 8 * a2 + 12) + 4) + 20);
  if ( !v5 )
    return 0;
  while ( *v5 )
  {
    if ( *v5 == a3 )
      return 1;
    v5 += 4;
  }
  return 0;
}

//----- (080CBE66) --------------------------------------------------------
float *__cdecl sub_80CBE66(int a1, int a2, float a3, int a4, int a5, int a6, int a7, int a8)
{
  float *result; // eax
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  dword_832D018 = a1;
  if ( a3 < 0.001 )
    a3 = 0.0;
  sub_80CB20E(a2, a3, a4, a5, 0, (unsigned __int16)a6, (unsigned __int16)a7);
  v9 = a2;
  while ( v9 )
  {
    v9 = *(unsigned __int16 *)(*(_DWORD *)a1 + 8 * v9 + 10);
    v10 = *(_WORD *)(a1 + 2 * v9 + 12);
    if ( !v10 || *((float *)&unk_830B01C + 17 * v10 + 7 * dword_832D040) == 0.0 )
      sub_80CB20E(v9, 1.0, a4, 1065353216, 0, 0, 0);
  }
  result = (float *)sub_80CBA7A(a2, a8);
  if ( dword_832D040 )
    result = sub_80CB8FC(a2);
  return result;
}
// 832D018: using guessed type int dword_832D018;
// 832D040: using guessed type int dword_832D040;

//----- (080CBFAC) --------------------------------------------------------
void __cdecl sub_80CBFAC(int a1)
{
  *(float *)a1 = sub_80A7F56();
  *(float *)(a1 + 4) = sub_80A7F56();
  *(_WORD *)(a1 + 8) = sub_80A7E24();
  *(_WORD *)(a1 + 10) = sub_80A7E24();
  *(float *)(a1 + 16) = sub_80A7F56();
  *(float *)(a1 + 24) = sub_80A7F56();
  *(float *)(a1 + 12) = sub_80A7F56();
  *(float *)(a1 + 20) = sub_80A7F56();
}

//----- (080CC012) --------------------------------------------------------
int __cdecl sub_80CC012(int a1)
{
  sub_80A7F3A(*(_DWORD *)a1);
  sub_80A7F3A(*(_DWORD *)(a1 + 4));
  sub_80A7E00(*(_WORD *)(a1 + 8));
  sub_80A7E00(*(_WORD *)(a1 + 10));
  sub_80A7F3A(*(_DWORD *)(a1 + 16));
  sub_80A7F3A(*(_DWORD *)(a1 + 24));
  sub_80A7F3A(*(_DWORD *)(a1 + 12));
  return sub_80A7F3A(*(_DWORD *)(a1 + 20));
}

//----- (080CC08C) --------------------------------------------------------
void __cdecl sub_80CC08C(_WORD *a1)
{
  __int16 v1; // [esp+Eh] [ebp-Ah]

  a1[1] = sub_80A7E24();
  *a1 = sub_80A7E24();
  a1[3] = sub_80A7E24();
  if ( (unsigned __int8)sub_80A7DE2() )
    v1 = sub_80A7EC4();
  else
    v1 = 0;
  a1[2] = v1;
  sub_80CBFAC((int)(a1 + 6));
  sub_80CBFAC((int)(a1 + 20));
}

//----- (080CC104) --------------------------------------------------------
int __cdecl sub_80CC104(unsigned __int16 *a1)
{
  sub_80A7E00(a1[1]);
  sub_80A7E00(*a1);
  sub_80A7E00(a1[3]);
  if ( a1[2] )
  {
    sub_80A7DC0(1u);
    sub_80A7E44(a1[2]);
  }
  else
  {
    sub_80A7DC0(0);
  }
  sub_80CC012((int)(a1 + 6));
  return sub_80CC012((int)(a1 + 20));
}

//----- (080CC188) --------------------------------------------------------
int __cdecl sub_80CC188(const void *a1, unsigned __int16 *a2)
{
  int result; // eax

  qmemcpy(a2, a1, 0x44u);
  result = (int)a2;
  if ( a2[2] )
    result = sub_80A3F08(a2[2]);
  return result;
}

//----- (080CC1C8) --------------------------------------------------------
int __cdecl sub_80CC1C8(int a1)
{
  void *v1; // esp
  int result; // eax
  _WORD *v3; // [esp+8h] [ebp-10h] BYREF
  size_t n; // [esp+Ch] [ebp-Ch]
  void *dest; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h]

  n = ((unsigned int)(*(_DWORD *)(*(_DWORD *)a1 + 4) - 1) >> 3) + 1;
  v1 = alloca(16 * ((n + 15) >> 4));
  dest = &v3;
  sub_80A80FC(&v3, n);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (unsigned int)i >= *(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    if ( (((unsigned __int8)(*((char *)dest + (i >> 3)) >> (i & 7)) ^ 1) & 1) == 0 )
    {
      v3 = (_WORD *)sub_80CA62A(a1, i);
      sub_80CC08C(v3);
    }
  }
  return result;
}

//----- (080CC266) --------------------------------------------------------
unsigned int __cdecl sub_80CC266(int a1)
{
  void *v1; // esp
  unsigned int result; // eax
  _BYTE v3[12]; // [esp+Ch] [ebp-2Ch] BYREF
  unsigned __int16 *v4; // [esp+18h] [ebp-20h]
  unsigned __int16 v5; // [esp+1Eh] [ebp-1Ah]
  size_t n; // [esp+20h] [ebp-18h]
  void *s; // [esp+24h] [ebp-14h]
  unsigned int i; // [esp+28h] [ebp-10h]

  n = ((unsigned int)(*(_DWORD *)(*(_DWORD *)a1 + 4) - 1) >> 3) + 1;
  v1 = alloca(16 * ((n + 15) >> 4));
  s = v3;
  sub_80D2FE9(v3, 0, n);
  for ( i = 0; i < *(_DWORD *)(*(_DWORD *)a1 + 4); ++i )
  {
    v5 = *(_WORD *)(a1 + 2 * i + 12);
    if ( v5 )
      *((_BYTE *)s + ((int)i >> 3)) |= 1 << (i & 7);
  }
  sub_80A80D0(s, n);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(*(_DWORD *)a1 + 4) )
      break;
    v5 = *(_WORD *)(a1 + 2 * i + 12);
    if ( v5 )
    {
      v4 = (unsigned __int16 *)((char *)&unk_830B000 + 68 * v5);
      sub_80CC104(v4);
    }
  }
  return result;
}

//----- (080CC382) --------------------------------------------------------
int __cdecl sub_80CC382(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-10h]
  unsigned __int16 *v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]
  int i; // [esp+14h] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v3 )
      break;
    v5 = *(_WORD *)(a1 + 2 * i + 12);
    if ( v5 )
    {
      if ( *(_WORD *)(a2 + 2 * i + 12) )
      {
        v4 = (unsigned __int16 *)((char *)&unk_830B000 + 68 * *(unsigned __int16 *)(a2 + 2 * i + 12));
        sub_80C62F8((int)v4);
      }
      else
      {
        v4 = (unsigned __int16 *)sub_80CA62A(a2, i);
      }
      sub_80CC188((char *)&unk_830B000 + 68 * v5, v4);
    }
    else
    {
      v6 = *(_WORD *)(a2 + 2 * i + 12);
      if ( v6 )
      {
        sub_80C631A(a2, v6);
        *(_WORD *)(a2 + 2 * i + 12) = 0;
      }
    }
  }
  return result;
}

//----- (080CC480) --------------------------------------------------------
long double __cdecl sub_80CC480(float a1)
{
  return (float)fabs(a1);
}

//----- (080CC49A) --------------------------------------------------------
int __cdecl sub_80CC49A(__int16 a1)
{
  return a1;
}

//----- (080CC4B0) --------------------------------------------------------
int __cdecl XModelEnforceExist(int a1)
{
  int result; // eax

  result = a1;
  dword_80F1C10 = a1;
  return result;
}
// 80F1C10: using guessed type int dword_80F1C10;

//----- (080CC4BE) --------------------------------------------------------
_BOOL4 __cdecl sub_80CC4BE(int a1)
{
  return *(_DWORD *)(a1 + 4) == (_DWORD)&unk_832D6E4;
}

//----- (080CC4E2) --------------------------------------------------------
int __cdecl sub_80CC4E2(__int16 *a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+10h] [ebp-28h]
  int v5; // [esp+1Ch] [ebp-1Ch]

  *a2 = sub_80CFAF2(*a1);
  a2[1] = sub_80CFAF2(a1[1]);
  a2[2] = sub_80CFAF2(a1[2]);
  v5 = 1073676289 - (a2[2] * a2[2] + a2[1] * a2[1] + *a2 * *a2);
  if ( v5 <= 0 )
  {
    v4 = 0;
  }
  else
  {
    v2 = sqrt((double)v5);
    v4 = (int)floor(v2 + 0.5);
  }
  result = v4;
  a2[3] = v4;
  return result;
}

//----- (080CC5D2) --------------------------------------------------------
int __cdecl sub_80CC5D2(__int16 *a1, __int16 *a2)
{
  long double v2; // fst7
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+1Ch] [ebp-Ch]

  *a2 = sub_80CFAF2(*a1);
  v5 = 1073676289 - *a2 * *a2;
  if ( v5 <= 0 )
  {
    v4 = 0;
  }
  else
  {
    v2 = sqrt((double)v5);
    v4 = (int)floor(v2 + 0.5);
  }
  result = v4;
  a2[1] = v4;
  return result;
}

//----- (080CC660) --------------------------------------------------------
void sub_80CC660()
{
  ;
}

//----- (080CC666) --------------------------------------------------------
int __cdecl sub_80CC666(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  __int16 *v4; // [esp+1Ch] [ebp-Ch]

  v4 = ***(__int16 ****)(a1 + 4);
  v2 = *v4;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v2 )
      break;
    sub_80A40A6(v4[i + 1]);
  }
  return result;
}

//----- (080CC6C6) --------------------------------------------------------
int *__cdecl sub_80CC6C6(int a1)
{
  int *result; // eax
  int *v2; // [esp+Ch] [ebp-Ch]
  int j; // [esp+10h] [ebp-8h]
  int i; // [esp+14h] [ebp-4h] BYREF

  result = *(int **)(a1 + 4);
  v2 = result;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v2[5 * i + 4] )
    {
      for ( j = 0; j < SLOWORD(v2[5 * i + 3]); ++j )
        sub_80A40A6(*(_WORD *)(v2[5 * i + 4] + 2 * j));
      v2[5 * i + 4] = 0;
    }
    result = &i;
  }
  return result;
}

//----- (080CC77E) --------------------------------------------------------
int __cdecl sub_80CC77E(int a1, int a2, __int16 **a3)
{
  __int16 v3; // ax
  int result; // eax

  v3 = sub_80CFAF2(**a3);
  *(_BYTE *)(a1 + (v3 >> 3) + 8) |= 1 << (v3 & 7);
  *(_DWORD *)(a2 + 12) = v3 << 6;
  *(float *)a2 = sub_80CFB0E(*(float *)++*a3);
  *a3 += 2;
  *(float *)(a2 + 4) = sub_80CFB0E(*(float *)*a3);
  *a3 += 2;
  *(float *)(a2 + 8) = sub_80CFB0E(*(float *)*a3);
  result = (int)(*a3 + 2);
  *a3 = (__int16 *)result;
  return result;
}

//----- (080CC846) --------------------------------------------------------
int __cdecl sub_80CC846(_DWORD *a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-28h]
  int j; // [esp+4h] [ebp-24h]
  int v5; // [esp+4h] [ebp-24h]
  int i; // [esp+8h] [ebp-20h]
  int *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  __int16 v9; // [esp+14h] [ebp-14h]
  __int16 v10; // [esp+14h] [ebp-14h]

  v7 = (int *)a1[2];
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *a1 )
      break;
    v3 = *(unsigned __int8 *)(a1[1] + i);
    v8 = *v7;
    v9 = *((_WORD *)v7 + 2);
    v7 = (int *)((char *)v7 + 6);
    if ( (_WORD)v8 != HIWORD(v8) && (_WORD)v8 != v9 && HIWORD(v8) != v9 )
    {
      *(_DWORD *)a2 = v8;
      *(_WORD *)(a2 + 4) = v9;
      a2 += 6;
    }
    for ( j = 3; j < v3; j = v5 + 1 )
    {
      LOWORD(v8) = v9;
      v10 = *(_WORD *)v7;
      v7 = (int *)((char *)v7 + 2);
      if ( (_WORD)v8 != HIWORD(v8) && (_WORD)v8 != v10 && HIWORD(v8) != v10 )
      {
        *(_DWORD *)a2 = v8;
        *(_WORD *)(a2 + 4) = v10;
        a2 += 6;
      }
      v5 = j + 1;
      if ( v5 >= v3 )
        break;
      HIWORD(v8) = v10;
      v9 = *(_WORD *)v7;
      v7 = (int *)((char *)v7 + 2);
      if ( (_WORD)v8 != HIWORD(v8) && (_WORD)v8 != v9 && HIWORD(v8) != v9 )
      {
        *(_DWORD *)a2 = v8;
        *(_WORD *)(a2 + 4) = v9;
        a2 += 6;
      }
    }
  }
  return result;
}

//----- (080CC9D8) --------------------------------------------------------
int __cdecl sub_80CC9D8(int a1, __int16 **a2, int (__cdecl *a3)(int))
{
  void *v3; // esp
  void *v4; // esp
  float *v5; // ebx
  int v6; // ebx
  int v7; // ebx
  long double v8; // fst7
  long double v9; // fst7
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int result; // eax
  int v17; // [esp+Ch] [ebp-4Ch] BYREF
  int v18; // [esp+10h] [ebp-48h] BYREF
  int *v19; // [esp+14h] [ebp-44h]
  int *v20; // [esp+18h] [ebp-40h]
  int v21; // [esp+20h] [ebp-38h]
  int v22; // [esp+24h] [ebp-34h]
  unsigned __int8 v23; // [esp+2Bh] [ebp-2Dh]
  int v24; // [esp+2Ch] [ebp-2Ch]
  int v25; // [esp+30h] [ebp-28h]
  int v26; // [esp+34h] [ebp-24h]
  float *v27; // [esp+38h] [ebp-20h]
  int v28; // [esp+3Ch] [ebp-1Ch]
  int v29; // [esp+40h] [ebp-18h]
  void *dest; // [esp+44h] [ebp-14h]
  int j; // [esp+48h] [ebp-10h]
  int i; // [esp+4Ch] [ebp-Ch]

  *(_BYTE *)a1 = *(_BYTE *)*a2;
  *a2 = (__int16 *)((char *)*a2 + 1);
  *(_WORD *)(a1 + 2) = sub_80CFAF2(**a2);
  *(_WORD *)(a1 + 4) = sub_80CFAF2(*++*a2);
  v18 = (__int16)sub_80CFAF2(*++*a2);
  v24 = (__int16)sub_80CFAF2(*++*a2);
  ++*a2;
  sub_80D2FE9((void *)(a1 + 8), 0, 0x10u);
  if ( v24 == -1 )
  {
    v29 = (__int16)sub_80CFAF2(**a2);
    v25 = (__int16)sub_80CFAF2(*++*a2);
    ++*a2;
    *(_WORD *)(a1 + 6) = -1;
    *(_DWORD *)(a1 + 32) = a3(36 * (*(__int16 *)(a1 + 2) - v25) + 32 * v25);
    *(_DWORD *)(a1 + 24) = a3(20 * v29);
  }
  else
  {
    v29 = 0;
    *(_WORD *)(a1 + 6) = (_WORD)v24 << 6;
    *(_BYTE *)(a1 + (v24 >> 3) + 8) |= 1 << (v24 & 7);
    *(_DWORD *)(a1 + 32) = a3(24 * *(__int16 *)(a1 + 2));
    *(_DWORD *)(a1 + 24) = 0;
  }
  *(_DWORD *)(a1 + 36) = a3(8 * *(__int16 *)(a1 + 2));
  v22 = 0;
  v21 = 0;
  for ( i = 0; i < v18; ++i )
  {
    v23 = *((_BYTE *)*a2 + v21);
    v22 += v23;
    v21 += 2 * v23 + 1;
  }
  v3 = alloca(16 * ((unsigned int)(v18 + 15) >> 4));
  v19 = &v17;
  v4 = alloca(16 * ((unsigned int)(2 * v22 + 15) >> 4));
  v20 = &v17;
  dest = &v17;
  for ( i = 0; i < v18; ++i )
  {
    v23 = *(_BYTE *)*a2;
    *((_BYTE *)v19 + i) = v23;
    *a2 = (__int16 *)((char *)*a2 + 1);
    memcpy(dest, *a2, 2 * v23);
    *a2 += v23;
    dest = (char *)dest + 2 * v23;
  }
  v28 = *(_DWORD *)(a1 + 32);
  v27 = *(float **)(a1 + 36);
  for ( j = 0; j < *(__int16 *)(a1 + 2); ++j )
  {
    v5 = (float *)v28;
    *v5 = sub_80CFB0E(*(float *)*a2);
    *a2 += 2;
    v6 = v28;
    *(float *)(v6 + 4) = sub_80CFB0E(*(float *)*a2);
    *a2 += 2;
    v7 = v28;
    *(float *)(v7 + 8) = sub_80CFB0E(*(float *)*a2);
    *a2 += 2;
    v8 = sub_80CFB0E(*(float *)*a2);
    *v27 = v8;
    *a2 += 2;
    v9 = sub_80CFB0E(*(float *)*a2);
    v27[1] = v9;
    *a2 += 2;
    if ( v24 == -1 )
    {
      v10 = v28;
      *(_DWORD *)(v10 + 12) = (__int16)sub_80CFAF2(**a2);
      ++*a2;
      sub_80CC77E(a1, v28 + 16, a2);
      if ( *(_DWORD *)(v28 + 12) )
      {
        v11 = v28;
        *(float *)(v11 + 32) = sub_80CFB0E(*(float *)*a2);
        *a2 += 2;
        v28 += 36;
      }
      else
      {
        v28 += 32;
      }
      v27 += 2;
    }
    else
    {
      v12 = v28;
      *(float *)(v12 + 12) = sub_80CFB0E(*(float *)*a2);
      *a2 += 2;
      v13 = v28;
      *(float *)(v13 + 16) = sub_80CFB0E(*(float *)*a2);
      *a2 += 2;
      v14 = v28;
      *(float *)(v14 + 20) = sub_80CFB0E(*(float *)*a2);
      *a2 += 2;
      v28 += 24;
      v27 += 2;
    }
  }
  v26 = *(_DWORD *)(a1 + 24);
  for ( j = 0; j < v29; ++j )
  {
    sub_80CC77E(a1, v26, a2);
    v15 = v26;
    *(float *)(v15 + 16) = sub_80CFB0E(*(float *)*a2);
    *a2 += 2;
    v26 += 20;
  }
  if ( (*(_BYTE *)(a1 + 4) & 1) != 0 )
  {
    *(_DWORD *)(a1 + 28) = a3(6 * (__int16)++*(_WORD *)(a1 + 4));
    sub_80CC846(&v18, *(_DWORD *)(a1 + 28));
    *(_WORD *)(*(_DWORD *)(a1 + 28) + 6 * *(__int16 *)(a1 + 4) - 6) = *(_WORD *)(*(_DWORD *)(a1 + 28)
                                                                               + 6 * *(__int16 *)(a1 + 4)
                                                                               - 8);
    *(_WORD *)(*(_DWORD *)(a1 + 28) + 6 * *(__int16 *)(a1 + 4) - 4) = *(_WORD *)(*(_DWORD *)(a1 + 28)
                                                                               + 6 * *(__int16 *)(a1 + 4)
                                                                               - 8);
    result = *(unsigned __int16 *)(*(_DWORD *)(a1 + 28) + 6 * *(__int16 *)(a1 + 4) - 8);
    *(_WORD *)(*(_DWORD *)(a1 + 28) + 6 * *(__int16 *)(a1 + 4) - 2) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 28) = a3(6 * *(__int16 *)(a1 + 4));
    result = sub_80CC846(&v18, *(_DWORD *)(a1 + 28));
  }
  return result;
}

//----- (080CD028) --------------------------------------------------------
int __cdecl sub_80CD028(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+18h] [ebp-10h]
  _DWORD *v3; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+24h] [ebp-4h]

  *(_WORD *)(a1 + 4) = 1;
  *(_WORD *)(a1 + 2) = 3;
  sub_80D2FE9((void *)(a1 + 8), 0, 0x10u);
  *(_WORD *)(a1 + 6) = 0;
  *(_DWORD *)(a1 + 32) = &unk_832D7BC;
  *(_DWORD *)(a1 + 36) = &unk_832D804;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = word_832D81E;
  word_832D81E[0] = 0;
  word_832D81E[1] = 1;
  word_832D81E[2] = 2;
  v3 = *(_DWORD **)(a1 + 32);
  v2 = *(_DWORD **)(a1 + 36);
  for ( i = 0; ; ++i )
  {
    result = *(__int16 *)(a1 + 2);
    if ( i >= result )
      break;
    *v3 = 1065353216;
    v3[1] = 0;
    v3[2] = 0;
    *v2 = 0;
    v2[1] = 0;
    v3[3] = 0;
    v3[4] = 0;
    v3[5] = 0;
    v3 += 6;
    v2 += 2;
  }
  return result;
}

//----- (080CD146) --------------------------------------------------------
_DWORD *sub_80CD146()
{
  word_832D6A0[0] = 1;
  dword_832D6A4[0] = word_832D6A0;
  unk_832D74C = dword_832D6A4;
  *((_DWORD *)&unk_832D74C + 3) = 0;
  *((_DWORD *)&unk_832D74C + 4) = 0;
  *((_WORD *)&unk_832D74C + 2) = 1;
  *((_DWORD *)&unk_832D74C + 5) = &byte_832D824;
  byte_832D824 = 0;
  word_832D6A0[1] = 0;
  dword_832D770[0] = -1048576000;
  dword_832D770[1] = -1048576000;
  dword_832D770[2] = -1048576000;
  dword_832D770[3] = 1098907648;
  dword_832D770[4] = 1098907648;
  dword_832D770[5] = 1098907648;
  *((_DWORD *)&unk_832D74C + 2) = dword_832D770;
  dword_832D7A4[1] = &unk_832D74C;
  dword_832D7A4[2] = 0;
  dword_832D7A4[0] = "DEFAULT";
  return dword_832D7A4;
}
// 832D824: using guessed type char byte_832D824;

//----- (080CD250) --------------------------------------------------------
_DWORD *sub_80CD250()
{
  *((_WORD *)&unk_832D764 + 2) = 1;
  dword_832D6E0 = (int)&unk_832D6AC;
  *((_DWORD *)&unk_832D764 + 2) = &dword_832D6E0;
  sub_80CD028(**((_DWORD **)&unk_832D764 + 2));
  dword_832D7B0[1] = &unk_832D764;
  dword_832D7B0[2] = 0;
  dword_832D7B0[0] = "DEFAULT";
  return dword_832D7B0;
}
// 832D6E0: using guessed type int dword_832D6E0;

//----- (080CD2B2) --------------------------------------------------------
void *__cdecl sub_80CD2B2(int a1)
{
  void *result; // eax
  int i; // [esp+Ch] [ebp-Ch]

  unk_832D6E4 = sub_80CD146();
  for ( i = 0; i <= 2; ++i )
  {
    *((_DWORD *)&unk_832D6E4 + 5 * i + 5) = 0;
    *((_DWORD *)&unk_832D6E4 + 5 * i + 2) = &unk_80E5C78;
    *((_DWORD *)&unk_832D6E4 + 5 * i + 1) = 0;
    *((_WORD *)&unk_832D6E4 + 10 * i + 6) = 1;
    *((_DWORD *)&unk_832D6E4 + 5 * i + 4) = &word_832D826;
    word_832D826 = 0;
  }
  *((_DWORD *)&unk_832D6E4 + 5) = sub_80CD250();
  *(_DWORD *)(a1 + 4) = &unk_832D6E4;
  *(_DWORD *)(a1 + 8) = 0;
  *((_WORD *)&unk_832D6E4 + 50) = 1;
  result = &unk_832D6E4;
  *((_WORD *)&unk_832D6E4 + 51) = 0;
  return result;
}
// 832D826: using guessed type __int16 word_832D826;

//----- (080CD3A8) --------------------------------------------------------
int *sub_80CD3A8()
{
  sub_80CD2B2((int)&dword_832D798);
  dword_832D798 = (int)"DEFAULT";
  return &dword_832D798;
}
// 832D798: using guessed type int dword_832D798;

//----- (080CD3CC) --------------------------------------------------------
_DWORD *__cdecl sub_80CD3CC(_DWORD *a1, int (__cdecl *a2)(int))
{
  _DWORD *result; // eax
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = a2(12);
  *(_WORD *)(v3 + 4) = *(_WORD *)(a1[1] + 4);
  *(_DWORD *)(v3 + 8) = a2(4 * *(__int16 *)(v3 + 4));
  sub_80D2FC8(*(void **)(v3 + 8), *(void **)(a1[1] + 8), 4 * *(__int16 *)(v3 + 4));
  *(_DWORD *)v3 = dword_80F1C0C;
  dword_80F1C0C = v3;
  result = (_DWORD *)a2(12);
  result[1] = v3;
  result[2] = sub_80CC660;
  *result = *a1;
  return result;
}
// 80F1C0C: using guessed type int dword_80F1C0C;

//----- (080CD47C) --------------------------------------------------------
_DWORD *__cdecl sub_80CD47C(const char *a1, int (__cdecl *a2)(int))
{
  _DWORD *v3; // [esp+20h] [ebp-438h]
  int v4; // [esp+24h] [ebp-434h]
  int v5; // [esp+28h] [ebp-430h]
  int v6; // [esp+2Ch] [ebp-42Ch]
  char s[1036]; // [esp+30h] [ebp-428h] BYREF
  int i; // [esp+43Ch] [ebp-1Ch]
  __int16 v9; // [esp+442h] [ebp-16h]
  __int16 *v10; // [esp+444h] [ebp-14h] BYREF
  int v11; // [esp+448h] [ebp-10h] BYREF
  _DWORD *v12; // [esp+44Ch] [ebp-Ch]

  v12 = (_DWORD *)sub_80650D2("xmodelsurfs", (int)a1, (int)&unk_80E5C78);
  if ( v12 )
  {
    if ( v12[1] )
    {
      v3 = sub_80CD3CC(v12, a2);
    }
    else
    {
      sprintf(s, "xmodelsurfs/%s", a1);
      if ( (FS_ReadFile(s, (int)&v11) & 0x80000000) != 0 )
        Com_Error(1, (char *)&byte_80E5D40, a1);
      v10 = (__int16 *)v11;
      v4 = (__int16)sub_80CFAF2(*(_WORD *)v11);
      ++v10;
      if ( v4 != 14 )
      {
        FS_FreeFile((void *)v11);
        Com_Error(1, (char *)&byte_80E5D60, a1, v4, 14);
      }
      v9 = sub_80CFAF2(*v10++);
      v5 = a2(12);
      *(_WORD *)(v5 + 4) = v9;
      *(_DWORD *)(v5 + 8) = a2(4 * v9);
      v6 = a2(52 * v9);
      for ( i = 0; i < v9; ++i )
      {
        *(_DWORD *)(*(_DWORD *)(v5 + 8) + 4 * i) = v6 + 52 * i;
        sub_80CC9D8(*(_DWORD *)(*(_DWORD *)(v5 + 8) + 4 * i), &v10, a2);
      }
      FS_FreeFile((void *)v11);
      v12[1] = v5;
      v12[2] = sub_80CC660;
      *(_DWORD *)v5 = dword_80F1C0C;
      dword_80F1C0C = v5;
      v3 = v12;
    }
  }
  else
  {
    if ( dword_80F1C10 )
      Com_Error(1, (char *)&byte_80E5CA0, a1);
    Com_Printf("ERROR: Cannot precache 'xmodelsurfs/%s'", (char)a1);
    v3 = 0;
  }
  return v3;
}
// 80F1C0C: using guessed type int dword_80F1C0C;
// 80F1C10: using guessed type int dword_80F1C10;

//----- (080CD72A) --------------------------------------------------------
int __cdecl sub_80CD72A(const char *a1, int (__cdecl *a2)(int))
{
  int v2; // ebx
  int v4; // [esp+24h] [ebp-484h]
  int v5; // [esp+2Ch] [ebp-47Ch]
  float v6; // [esp+30h] [ebp-478h]
  float v7; // [esp+34h] [ebp-474h]
  float v8; // [esp+38h] [ebp-470h]
  __int16 *v9; // [esp+48h] [ebp-460h]
  int v10; // [esp+4Ch] [ebp-45Ch]
  char v11; // [esp+50h] [ebp-458h]
  size_t n; // [esp+54h] [ebp-454h]
  float *v13; // [esp+60h] [ebp-448h]
  float *v14; // [esp+64h] [ebp-444h]
  int v15; // [esp+68h] [ebp-440h]
  int i; // [esp+68h] [ebp-440h]
  __int16 v17; // [esp+6Eh] [ebp-43Ah]
  __int16 v18; // [esp+70h] [ebp-438h]
  __int16 v19; // [esp+72h] [ebp-436h]
  int v20; // [esp+74h] [ebp-434h]
  _BYTE *v21; // [esp+78h] [ebp-430h]
  _WORD *v22; // [esp+80h] [ebp-428h]
  _DWORD *v23; // [esp+84h] [ebp-424h]
  char *v24; // [esp+88h] [ebp-420h]
  __int16 *v25; // [esp+88h] [ebp-420h]
  __int16 *v26; // [esp+88h] [ebp-420h]
  char *v27; // [esp+88h] [ebp-420h]
  char *v28; // [esp+88h] [ebp-420h]
  char *v29; // [esp+88h] [ebp-420h]
  int v30; // [esp+8Ch] [ebp-41Ch] BYREF
  char s[1032]; // [esp+90h] [ebp-418h] BYREF
  int v32; // [esp+498h] [ebp-10h]
  int v33; // [esp+49Ch] [ebp-Ch]

  v32 = sub_80650D2("xmodelparts", (int)a1, (int)&unk_80E5C78);
  if ( v32 )
  {
    if ( *(_DWORD *)(v32 + 4) )
    {
      v5 = v32;
    }
    else
    {
      sprintf(s, "xmodelparts/%s", a1);
      if ( (FS_ReadFile(s, (int)&v30) & 0x80000000) != 0 )
        Com_Error(1, (char *)&byte_80E5E60, a1);
      v24 = (char *)v30;
      v10 = (__int16)sub_80CFAF2(*(_WORD *)v30);
      v25 = (__int16 *)(v24 + 2);
      if ( v10 != 14 )
      {
        FS_FreeFile((void *)v30);
        Com_Error(1, (char *)&byte_80E5E80, a1, v10, 14);
      }
      v17 = sub_80CFAF2(*v25);
      v26 = v25 + 1;
      v18 = sub_80CFAF2(*v26);
      v27 = (char *)(v26 + 1);
      v19 = v18 + v17;
      v22 = (_WORD *)a2(2 * (__int16)(v18 + v17) + 2);
      *v22 = v18 + v17;
      if ( (__int16)(v18 + v17) > 127 )
        Com_Error(1, (char *)&byte_80E5EC0, a1, 127);
      v23 = (_DWORD *)a2(v17 + 7);
      *v23 = v22;
      v21 = v23 + 1;
      v33 = a2(24 * v17 + 104);
      *(_DWORD *)v33 = v23;
      *(_DWORD *)(v33 + 12) = v33 + 24;
      if ( v17 )
        v4 = 8 * v17 + *(_DWORD *)(v33 + 12);
      else
        v4 = 0;
      *(_DWORD *)(v33 + 16) = v4;
      v2 = v33;
      *(_DWORD *)(v2 + 20) = a2(v19);
      *(_WORD *)(v33 + 4) = v18;
      v20 = a2(40 * v19);
      v9 = *(__int16 **)(v33 + 12);
      v14 = *(float **)(v33 + 16);
      v15 = v18;
      while ( v15 < v19 )
      {
        v11 = *v27;
        v28 = v27 + 1;
        *v21 = v15 - v11;
        *v14 = *(float *)v28;
        v14[1] = *((float *)v28 + 1);
        v14[2] = *((float *)v28 + 2);
        v28 += 12;
        *v14 = sub_80CFB0E(*v14);
        v14[1] = sub_80CFB0E(v14[1]);
        v14[2] = sub_80CFB0E(v14[2]);
        sub_80CC4E2((__int16 *)v28, v9);
        v27 = v28 + 6;
        ++v15;
        v9 += 4;
        v14 += 3;
        ++v21;
      }
      for ( i = 0; i < v19; ++i )
      {
        n = strlen(v27) + 1;
        v22[i + 1] = sub_80A388C(v27, 0, n);
        v29 = &v27[n];
        v13 = (float *)(v20 + 40 * i);
        *v13 = *(float *)v29;
        v13[1] = *((float *)v29 + 1);
        v13[2] = *((float *)v29 + 2);
        v29 += 12;
        *v13 = sub_80CFB0E(*v13);
        v13[1] = sub_80CFB0E(v13[1]);
        v13[2] = sub_80CFB0E(v13[2]);
        v13[3] = *(float *)v29;
        v13[4] = *((float *)v29 + 1);
        v13[5] = *((float *)v29 + 2);
        v27 = v29 + 12;
        v13[3] = sub_80CFB0E(v13[3]);
        v13[4] = sub_80CFB0E(v13[4]);
        v13[5] = sub_80CFB0E(v13[5]);
        v13[6] = *v13 + v13[3];
        v13[7] = v13[1] + v13[4];
        v13[8] = v13[2] + v13[5];
        v13[6] = v13[6] * 0.5;
        v13[7] = v13[7] * 0.5;
        v13[8] = v13[8] * 0.5;
        v6 = v13[3] - v13[6];
        v7 = v13[4] - v13[7];
        v8 = v13[5] - v13[8];
        v13[9] = v6 * v6 + v7 * v7 + v8 * v8;
      }
      memcpy(*(void **)(v33 + 20), v27, v19);
      FS_FreeFile((void *)v30);
      *(_DWORD *)(v33 + 8) = v20;
      *(_DWORD *)(v32 + 4) = v33;
      *(_DWORD *)(v32 + 8) = sub_80CC666;
      v5 = v32;
    }
  }
  else
  {
    if ( dword_80F1C10 )
      Com_Error(1, (char *)&byte_80E5DC0, a1);
    Com_Printf("ERROR: Cannot precache 'xmodelparts/%s'", (char)a1);
    v5 = 0;
  }
  return v5;
}
// 80F1C10: using guessed type int dword_80F1C10;

//----- (080CDF7C) --------------------------------------------------------
float *__cdecl sub_80CDF7C(int a1, char *src, int a3)
{
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]
  char *srca; // [esp+34h] [ebp+Ch]
  float *srcc; // [esp+34h] [ebp+Ch]
  float *srcb; // [esp+34h] [ebp+Ch]
  char *srcd; // [esp+34h] [ebp+Ch]

  v5 = (__int16)sub_80CFAF2(*(_WORD *)src);
  srca = src + 2;
  if ( v5 != 14 )
    Com_Error(1, (char *)&byte_80E5F00, a1, v5, 14);
  *(float *)(a3 + 3084) = sub_80CFB0E(*(float *)srca);
  srcc = (float *)(srca + 4);
  *(float *)(a3 + 3088) = sub_80CFB0E(*srcc++);
  *(float *)(a3 + 3092) = sub_80CFB0E(*srcc++);
  *(float *)(a3 + 3096) = sub_80CFB0E(*srcc++);
  *(float *)(a3 + 3100) = sub_80CFB0E(*srcc++);
  *(float *)(a3 + 3104) = sub_80CFB0E(*srcc);
  srcb = srcc + 1;
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a3 + 1028 * i + 1024) = sub_80CFB0E(*srcb);
    srcd = (char *)(srcb + 1);
    strcpy((char *)(a3 + 1028 * i), srcd);
    srcb = (float *)&srcd[strlen(srcd) + 1];
  }
  *(_DWORD *)(a3 + 3108) = sub_80CFB06(*(_DWORD *)srcb);
  return srcb + 1;
}

//----- (080CE11E) --------------------------------------------------------
int *__cdecl sub_80CE11E(int *a1, _DWORD *a2, int (__cdecl *a3)(int))
{
  int *v4; // [esp+10h] [ebp-18h]
  int j; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  float *v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int *v9; // [esp+30h] [ebp+8h]
  float *v10; // [esp+30h] [ebp+8h]
  float *v11; // [esp+30h] [ebp+8h]
  float *v12; // [esp+30h] [ebp+8h]

  a2[17] = sub_80CFB06(*a1);
  v9 = a1 + 1;
  a2[18] = 0;
  if ( a2[17] )
  {
    a2[16] = a3(44 * a2[17]);
    for ( i = 0; i < a2[17]; ++i )
    {
      v8 = a2[16] + 44 * i;
      *(_DWORD *)(v8 + 4) = sub_80CFB06(*v9);
      v10 = (float *)(v9 + 1);
      *(_DWORD *)v8 = a3(48 * *(_DWORD *)(v8 + 4));
      for ( j = 0; j < *(_DWORD *)(v8 + 4); ++j )
      {
        v7 = (float *)(*(_DWORD *)v8 + 48 * j);
        *v7 = sub_80CFB0E(*v10);
        v11 = v10 + 1;
        v7[1] = sub_80CFB0E(*v11++);
        v7[2] = sub_80CFB0E(*v11++);
        v7[3] = sub_80CFB0E(*v11++);
        v7[4] = sub_80CFB0E(*v11++);
        v7[5] = sub_80CFB0E(*v11++);
        v7[6] = sub_80CFB0E(*v11++);
        v7[7] = sub_80CFB0E(*v11++);
        v7[8] = sub_80CFB0E(*v11++);
        v7[9] = sub_80CFB0E(*v11++);
        v7[10] = sub_80CFB0E(*v11++);
        v7[11] = sub_80CFB0E(*v11);
        v10 = v11 + 1;
      }
      *(float *)(v8 + 8) = sub_80CFB0E(*v10) - 0.001;
      v12 = v10 + 1;
      *(float *)(v8 + 12) = sub_80CFB0E(*v12++) - 0.001;
      *(float *)(v8 + 16) = sub_80CFB0E(*v12++) - 0.001;
      *(float *)(v8 + 20) = sub_80CFB0E(*v12++) + 0.001;
      *(float *)(v8 + 24) = sub_80CFB0E(*v12++) + 0.001;
      *(float *)(v8 + 28) = sub_80CFB0E(*v12++) + 0.001;
      *(_DWORD *)(v8 + 32) = sub_80CFB06(*(_DWORD *)v12++);
      *(_DWORD *)(v8 + 36) = sub_80CFB06(*(_DWORD *)v12++) & 0xDFFF7FFB;
      *(_DWORD *)(v8 + 40) = sub_80CFB06(*(_DWORD *)v12);
      v9 = (int *)(v12 + 1);
      a2[18] |= *(_DWORD *)(v8 + 36);
    }
    v4 = v9;
  }
  else
  {
    a2[16] = 0;
    v4 = v9;
  }
  return v4;
}

//----- (080CE462) --------------------------------------------------------
_BOOL4 __cdecl sub_80CE462(int a1)
{
  return sub_80650D2("xmodel", a1, (int)&unk_80E5C78) != 0;
}

//----- (080CE498) --------------------------------------------------------
int __cdecl sub_80CE498(const char *a1, int a2, int (__cdecl *a3)(int))
{
  int v3; // ebx
  _DWORD *v4; // ebx
  size_t v5; // eax
  __int16 v6; // ax
  int *v7; // ebx
  _DWORD *v8; // ebx
  int *v10; // [esp+14h] [ebp-1094h]
  char *v11; // [esp+18h] [ebp-1090h]
  char *src; // [esp+1Ch] [ebp-108Ch] BYREF
  char s[1036]; // [esp+20h] [ebp-1088h] BYREF
  int j; // [esp+42Ch] [ebp-C7Ch]
  int i; // [esp+430h] [ebp-C78h]
  int v16; // [esp+434h] [ebp-C74h]
  char *dest; // [esp+438h] [ebp-C70h]
  int *v18; // [esp+43Ch] [ebp-C6Ch]
  int v19[7]; // [esp+440h] [ebp-C68h]
  _DWORD *v20; // [esp+45Ch] [ebp-C4Ch]
  int v21[777]; // [esp+460h] [ebp-C48h] BYREF
  int v22; // [esp+1084h] [ebp-24h]
  int *v23; // [esp+109Ch] [ebp-Ch]
  _DWORD v24[2]; // [esp+10A0h] [ebp-8h] BYREF

  v23 = (int *)sub_80650D2("xmodel", (int)a1, (int)&unk_80E5C78);
  if ( v23 )
  {
    v20 = (_DWORD *)v23[1];
    if ( v20 )
    {
      if ( sub_80CC4BE((int)v23) )
        return (int)v23;
    }
    else
    {
      sprintf(s, "xmodel/%s", a1);
      if ( (FS_ReadFile(s, (int)&src) & 0x80000000) != 0 )
        Com_Error(1, (char *)&byte_80E5FCD, a1);
      v18 = (int *)sub_80CDF7C((int)a1, src, (int)v21);
      if ( !v18 )
      {
        FS_FreeFile(src);
        return 0;
      }
      v16 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        v3 = i;
        v19[v3] = strlen((const char *)&v21[257 * i]) + 1;
        v16 += v19[i];
      }
      v20 = (_DWORD *)a3(v16 + 104);
      v18 = sub_80CE11E(v18, v20, a3);
      dest = (char *)(v20 + 26);
      *((_WORD *)v20 + 50) = 0;
      for ( i = 0; i <= 2; ++i )
      {
        strcpy(dest, (const char *)&v21[257 * i]);
        v20[5 * i + 2] = dest;
        if ( *dest )
        {
          ++*((_WORD *)v20 + 50);
          LOWORD(v20[5 * i + 3]) = *(_WORD *)v18;
          v18 = (int *)((char *)v18 + 2);
          v4 = &v20[5 * i + 4];
          *v4 = a3(2 * SLOWORD(v20[5 * i + 3]));
          for ( j = 0; j < SLOWORD(v20[5 * i + 3]); ++j )
          {
            v11 = (char *)v18;
            v5 = strlen((const char *)v18);
            v18 = (int *)((char *)v18 + v5 + 1);
            v6 = sub_80A3D64(v11, 0);
            *(_WORD *)(v20[5 * i + 4] + 2 * j) = v6;
          }
        }
        else
        {
          v20[5 * i + 4] = 0;
        }
        v20[5 * i + 1] = v24[257 * i - 528];
        dest += v19[i];
      }
      FS_FreeFile(src);
      v20[19] = v21[771];
      v20[20] = v21[772];
      v20[21] = v21[773];
      v20[22] = v21[774];
      v20[23] = v21[775];
      v20[24] = v21[776];
      *((_WORD *)v20 + 51) = v22;
      v23[1] = (int)v20;
      v23[2] = (int)sub_80CC6C6;
      v20[5] = 0;
      v20[10] = 0;
      v20[15] = 0;
    }
    v7 = v20;
    *v7 = sub_80CD72A((const char *)v20[2], a3);
    if ( *v20 )
    {
      if ( a2 )
      {
        for ( i = 0; i <= 2 && *(_BYTE *)v20[5 * i + 2]; ++i )
        {
          v8 = &v20[5 * i + 5];
          *v8 = sub_80CD47C((const char *)v20[5 * i + 2], a3);
          if ( !v20[5 * i + 5] )
            goto LABEL_25;
        }
        v10 = v23;
      }
      else
      {
        v10 = v23;
      }
    }
    else
    {
LABEL_25:
      sub_80CC6C6((int)v23);
      sub_80CD2B2((int)v23);
      v10 = v23;
    }
  }
  else
  {
    if ( dword_80F1C10 )
      Com_Error(1, (char *)&byte_80E5F40, a1);
    Com_Printf("ERROR: Cannot precache 'xmodel/%s'", (char)a1);
    v10 = sub_80CD3A8();
  }
  return (int)v10;
}
// 80F1C10: using guessed type int dword_80F1C10;

//----- (080CEAE0) --------------------------------------------------------
int __cdecl sub_80CEAE0(unsigned int a1, unsigned int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-10h]
  int j; // [esp+4h] [ebp-Ch]
  int k; // [esp+4h] [ebp-Ch]
  int *v6; // [esp+8h] [ebp-8h]
  unsigned int i; // [esp+Ch] [ebp-4h]

  v6 = &dword_80F1C0C;
  result = dword_80F1C0C;
  for ( i = dword_80F1C0C; i; i = *(_DWORD *)i )
  {
    if ( i < a1 || i >= a2 )
    {
      for ( j = 0; j < *(__int16 *)(i + 4); ++j )
      {
        v3 = *(_DWORD *)(*(_DWORD *)(i + 8) + 4 * j);
        if ( v3 )
        {
          if ( *(_DWORD *)(v3 + 48) >= a1 && *(_DWORD *)(v3 + 48) < a2 )
            *(_DWORD *)(v3 + 48) = 0;
          if ( *(_DWORD *)(v3 + 44) >= a1 && *(_DWORD *)(v3 + 44) < a2 )
            *(_DWORD *)(v3 + 44) = 0;
        }
      }
      for ( k = 0; k < *(__int16 *)(i + 4); ++k )
        ;
      v6 = (int *)i;
    }
    else
    {
      *v6 = *(_DWORD *)i;
    }
    result = *(_DWORD *)i;
  }
  return result;
}
// 80F1C0C: using guessed type int dword_80F1C0C;

//----- (080CEBCA) --------------------------------------------------------
int __cdecl sub_80CEBCA(int a1)
{
  return ****(__int16 ****)(**(_DWORD **)(a1 + 4) + 4);
}

//----- (080CEBE2) --------------------------------------------------------
int __cdecl sub_80CEBE2(int a1)
{
  return ***(_DWORD ***)(**(_DWORD **)(a1 + 4) + 4) + 2;
}

//----- (080CEBFA) --------------------------------------------------------
int __cdecl sub_80CEBFA(int a1, __int16 a2)
{
  __int16 *v3; // [esp+4h] [ebp-10h]
  int i; // [esp+Ch] [ebp-8h]

  v3 = ***(__int16 ****)(**(_DWORD **)(a1 + 4) + 4);
  for ( i = *v3 - 1; i >= 0 && a2 != v3[i + 1]; --i )
    ;
  return i;
}

//----- (080CEC5C) --------------------------------------------------------
int __cdecl sub_80CEC5C(int a1, _DWORD *a2, _DWORD *a3)
{
  int result; // eax
  _DWORD *v4; // [esp+0h] [ebp-4h]

  v4 = *(_DWORD **)(a1 + 4);
  *a2 = v4[19];
  a2[1] = v4[20];
  a2[2] = v4[21];
  *a3 = v4[22];
  a3[1] = v4[23];
  result = v4[24];
  a3[2] = result;
  return result;
}

//----- (080CED0A) --------------------------------------------------------
const char *__cdecl sub_80CED0A(int a1, int a2, int a3)
{
  const char *v4; // [esp+10h] [ebp-8h]
  unsigned __int16 v5; // [esp+16h] [ebp-2h]

  v5 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4) + 20 * a3 + 16) + 2 * a2);
  if ( v5 )
    v4 = (const char *)SL_ConvertToString(v5);
  else
    v4 = "DEFAULT";
  return v4;
}

//----- (080CED5C) --------------------------------------------------------
int __cdecl sub_80CED5C(void **a1, int (__cdecl *a2)(int))
{
  int v3; // [esp+18h] [ebp-10h]

  v3 = a2(52);
  qmemcpy((void *)v3, a1, 0x34u);
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 36) = a2(8 * *(__int16 *)(v3 + 2));
  sub_80D2FC8(*(void **)(v3 + 36), a1[9], 8 * *(__int16 *)(v3 + 2));
  return v3;
}

//----- (080CEF02) --------------------------------------------------------
int __cdecl sub_80CEF02(int a1)
{
  return *(__int16 *)(a1 + 6);
}

//----- (080CEFA0) --------------------------------------------------------
int __cdecl sub_80CEFA0(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 4) + 72);
}

//----- (080CEFAE) --------------------------------------------------------
int *__cdecl sub_80CEFAE(int a1, int a2, int a3, void *dest, int a5)
{
  int *result; // eax
  int v6; // [esp+10h] [ebp-18h]
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]
  int *j; // [esp+1Ch] [ebp-Ch]
  int *i; // [esp+1Ch] [ebp-Ch]
  float *v11; // [esp+20h] [ebp-8h]
  int v12; // [esp+24h] [ebp-4h]

  v8 = *(_DWORD *)(a1 + 32);
  v12 = sub_80CEF02(a1);
  if ( dest )
    memcpy(dest, *(const void **)(a1 + 36), 8 * *(__int16 *)(a1 + 2));
  if ( v12 == -1 )
  {
    v7 = *(_DWORD *)(a1 + 24);
    result = (int *)*(__int16 *)(a1 + 2);
    for ( i = result; i; i = (int *)((char *)i - 1) )
    {
      if ( a5 )
      {
        sub_80CFE70((float *)v8, (float *)(a2 + *(_DWORD *)(v8 + 28)), (float *)a5);
        a5 += 12;
      }
      sub_80CFCF2((float *)(v8 + 16), (float *)(a2 + *(_DWORD *)(v8 + 28)), (float *)a3);
      v6 = *(_DWORD *)(v8 + 12);
      if ( v6 )
      {
        *(float *)a3 = *(float *)a3 * *(float *)(v8 + 32);
        *(float *)(a3 + 4) = *(float *)(a3 + 4) * *(float *)(v8 + 32);
        *(float *)(a3 + 8) = *(float *)(a3 + 8) * *(float *)(v8 + 32);
        do
        {
          sub_80CFD9E(v7, *(float *)(v7 + 16), a2 + *(_DWORD *)(v7 + 12), a3);
          --v6;
          v7 += 20;
        }
        while ( v6 );
        v8 += 36;
      }
      else
      {
        v8 += 32;
      }
      result = &a3;
      a3 += 12;
    }
  }
  else
  {
    v11 = (float *)(a2 + v12);
    result = (int *)*(__int16 *)(a1 + 2);
    for ( j = result; j; j = (int *)((char *)j - 1) )
    {
      if ( a5 )
      {
        sub_80CFE70((float *)v8, v11, (float *)a5);
        a5 += 12;
      }
      sub_80CFCF2((float *)(v8 + 12), v11, (float *)a3);
      v8 += 24;
      result = &a3;
      a3 += 12;
    }
  }
  return result;
}

//----- (080CF17E) --------------------------------------------------------
int __cdecl sub_80CF17E(int a1)
{
  return *(__int16 *)(*(_DWORD *)(a1 + 4) + 100);
}

//----- (080CF21A) --------------------------------------------------------
int __cdecl sub_80CF21A(int a1, float a2)
{
  int *v3; // [esp+4h] [ebp-14h]
  int i; // [esp+Ch] [ebp-Ch]
  float *v6; // [esp+10h] [ebp-8h]
  int v7; // [esp+14h] [ebp-4h]

  if ( byte_832D87C )
    v3 = &dword_832D840;
  else
    v3 = (int *)(*(_DWORD *)(a1 + 4) + 4);
  v6 = (float *)v3;
  if ( flt_832D880 != 0.0 )
    a2 = flt_832D880;
  v7 = sub_80CF17E(a1);
  for ( i = 0; i < v7; ++i )
  {
    if ( *v6 == 0.0 || *v6 > (long double)a2 )
      return i;
    v6 += 5;
  }
  return -1;
}
// 832D840: using guessed type int dword_832D840;
// 832D87C: using guessed type char byte_832D87C;
// 832D880: using guessed type float flt_832D880;

//----- (080CF2C4) --------------------------------------------------------
unsigned __int8 **__cdecl sub_80CF2C4(int a1, int a2)
{
  unsigned __int8 **result; // eax
  float v3[4]; // [esp+10h] [ebp-38h] BYREF
  unsigned __int8 *v4; // [esp+20h] [ebp-28h] BYREF
  float *v5; // [esp+24h] [ebp-24h]
  int v6; // [esp+28h] [ebp-20h]
  __int16 **v7; // [esp+2Ch] [ebp-1Ch]
  float *v8; // [esp+30h] [ebp-18h]
  __int16 *v9; // [esp+34h] [ebp-14h]
  __int16 ***v10; // [esp+38h] [ebp-10h]
  unsigned __int8 **v11; // [esp+3Ch] [ebp-Ch]

  v10 = *(__int16 ****)(**(_DWORD **)(a1 + 4) + 4);
  v7 = *v10;
  v4 = (unsigned __int8 *)(v7 + 1);
  v6 = **v7;
  v9 = (__int16 *)v10[3];
  v8 = (float *)v10[4];
  v5 = (float *)a2;
  v11 = (unsigned __int8 **)*((__int16 *)v10 + 2);
  while ( v11 )
  {
    *v5 = 0.0;
    v5[1] = 0.0;
    v5[2] = 0.0;
    v5[3] = 1.0;
    v11 = (unsigned __int8 **)((char *)v11 - 1);
    v5 += 16;
  }
  v11 = (unsigned __int8 **)(v6 - *((__int16 *)v10 + 2));
  while ( v11 )
  {
    v3[0] = (long double)*v9 * 0.000030518509;
    v3[1] = (long double)v9[1] * 0.000030518509;
    v3[2] = (long double)v9[2] * 0.000030518509;
    v3[3] = (long double)v9[3] * 0.000030518509;
    sub_80696FC(v3, &v5[-16 * *v4], v5);
    v11 = (unsigned __int8 **)((char *)v11 - 1);
    v9 += 4;
    v5 += 16;
    ++v4;
  }
  v11 = (unsigned __int8 **)*((__int16 *)v10 + 2);
  while ( v11 )
  {
    *(_DWORD *)a2 = 1065353216;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 20) = 1065353216;
    *(_DWORD *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 36) = 0;
    *(_DWORD *)(a2 + 40) = 1065353216;
    *(_DWORD *)(a2 + 56) = 0;
    *(_DWORD *)(a2 + 52) = 0;
    *(_DWORD *)(a2 + 48) = 0;
    v11 = (unsigned __int8 **)((char *)v11 - 1);
    a2 += 64;
  }
  v4 = (unsigned __int8 *)(v7 + 1);
  result = (unsigned __int8 **)(v6 - *((__int16 *)v10 + 2));
  v11 = result;
  while ( v11 )
  {
    sub_80CFB20(a2);
    sub_80CFCF2(v8, (float *)(a2 - (*v4 << 6)), (float *)(a2 + 48));
    v11 = (unsigned __int8 **)((char *)v11 - 1);
    a2 += 64;
    v8 += 3;
    result = &v4;
    ++v4;
  }
  return result;
}

//----- (080CF4FE) --------------------------------------------------------
int __cdecl sub_80CF4FE(int a1, int a2, int a3, float *a4, float *a5, int a6)
{
  int v8[4]; // [esp+30h] [ebp-A8h] BYREF
  int j; // [esp+40h] [ebp-98h]
  int i; // [esp+44h] [ebp-94h]
  float v11; // [esp+48h] [ebp-90h]
  float v12; // [esp+4Ch] [ebp-8Ch]
  float v13; // [esp+50h] [ebp-88h]
  float v14; // [esp+54h] [ebp-84h]
  float v15; // [esp+58h] [ebp-80h]
  float v16; // [esp+5Ch] [ebp-7Ch]
  float v17; // [esp+60h] [ebp-78h]
  float v18; // [esp+64h] [ebp-74h]
  float v19; // [esp+68h] [ebp-70h]
  float v20; // [esp+70h] [ebp-68h]
  float v21; // [esp+74h] [ebp-64h]
  float v22; // [esp+78h] [ebp-60h]
  float *v23; // [esp+80h] [ebp-58h]
  _DWORD *v24; // [esp+84h] [ebp-54h]
  int v25; // [esp+88h] [ebp-50h]
  int v26; // [esp+8Ch] [ebp-4Ch]
  float v27; // [esp+90h] [ebp-48h] BYREF
  float v28; // [esp+94h] [ebp-44h]
  float v29; // [esp+98h] [ebp-40h]
  float v30; // [esp+A0h] [ebp-38h] BYREF
  float v31; // [esp+A4h] [ebp-34h]
  float v32; // [esp+A8h] [ebp-30h]
  float v33; // [esp+B0h] [ebp-28h] BYREF
  float v34; // [esp+B4h] [ebp-24h]
  float v35; // [esp+B8h] [ebp-20h]
  float *v36; // [esp+C4h] [ebp-14h]
  int v37; // [esp+C8h] [ebp-10h]
  int v38; // [esp+CCh] [ebp-Ch]

  v26 = -1;
  v25 = *(_DWORD *)(a1 + 4);
  v37 = sub_80CEBCA(a1);
  for ( i = 0; i < *(_DWORD *)(v25 + 68); ++i )
  {
    v24 = (_DWORD *)(*(_DWORD *)(v25 + 64) + 44 * i);
    if ( (v24[9] & a6) != 0 )
    {
      v38 = v24[8];
      v36 = (float *)(a3 + (v38 << 6));
      v33 = *a4 - v36[12];
      v34 = a4[1] - v36[13];
      v35 = a4[2] - v36[14];
      sub_80CFF0A(&v33, v36, &v27);
      v33 = *a5 - v36[12];
      v34 = a5[1] - v36[13];
      v35 = a5[2] - v36[14];
      sub_80CFF0A(&v33, v36, &v30);
      v20 = v30 - v27;
      v21 = v31 - v28;
      v22 = v32 - v29;
      if ( !sub_805E553((int)&v27, (int)&v30, (int)(v24 + 2), (int)(v24 + 5), *(float *)a2) )
      {
        for ( j = 0; j < v24[1]; ++j )
        {
          v23 = (float *)(*v24 + 48 * j);
          v16 = v30 * *v23 + v31 * v23[1] + v32 * v23[2] - v23[3];
          if ( v16 < 0.0 )
          {
            v15 = v27 * *v23 + v28 * v23[1] + v29 * v23[2] - v23[3];
            if ( v15 > 0.0 )
            {
              v14 = (v15 - 0.125) / (v15 - v16);
              if ( v14 < (long double)*(float *)a2 )
              {
                v13 = v15 / (v15 - v16);
                v17 = v20 * v13 + v27;
                v18 = v21 * v13 + v28;
                v19 = v22 * v13 + v29;
                v12 = v17 * v23[4] + v18 * v23[5] + v19 * v23[6] - v23[7];
                if ( v12 >= -0.001 && v12 <= 1.001 )
                {
                  v11 = v17 * v23[8] + v18 * v23[9] + v19 * v23[10] - v23[11];
                  if ( v11 >= -0.001 && v12 + v11 <= 1.001 )
                  {
                    v26 = v38;
                    *(_BYTE *)(a2 + 47) = 0;
                    *(_BYTE *)(a2 + 46) = 0;
                    *(float *)a2 = v14;
                    *(_DWORD *)(a2 + 28) = v24[10];
                    *(_DWORD *)(a2 + 32) = v24[9];
                    *(float *)(a2 + 16) = *v23;
                    *(float *)(a2 + 20) = v23[1];
                    *(float *)(a2 + 24) = v23[2];
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if ( v26 < 0 )
    return -1;
  v36 = (float *)(a3 + (v26 << 6));
  sub_80CFE70((float *)(a2 + 16), v36, (float *)v8);
  *(_DWORD *)(a2 + 16) = v8[0];
  *(_DWORD *)(a2 + 20) = v8[1];
  *(_DWORD *)(a2 + 24) = v8[2];
  return v26;
}

//----- (080CF91E) --------------------------------------------------------
int __cdecl sub_80CF91E(int a1, float *a2, _DWORD *a3, _DWORD *a4)
{
  float v5; // [esp+10h] [ebp-58h]
  float v6; // [esp+14h] [ebp-54h]
  float v7; // [esp+18h] [ebp-50h]
  float v9[4]; // [esp+20h] [ebp-48h] BYREF
  float v10[7]; // [esp+30h] [ebp-38h] BYREF
  int j; // [esp+4Ch] [ebp-1Ch]
  int k; // [esp+50h] [ebp-18h]
  int i; // [esp+54h] [ebp-14h]
  float *v14; // [esp+58h] [ebp-10h]
  int v15; // [esp+5Ch] [ebp-Ch]

  v15 = *(_DWORD *)(a1 + 4);
  if ( !*(_DWORD *)(v15 + 68) )
    return 0;
  *a3 = 2139095039;
  a3[1] = 2139095039;
  a3[2] = 2139095039;
  *a4 = -8388609;
  a4[1] = -8388609;
  a4[2] = -8388609;
  for ( i = 0; i < *(_DWORD *)(v15 + 68); ++i )
  {
    v14 = (float *)(*(_DWORD *)(v15 + 64) + 44 * i);
    for ( j = 0; j <= 7; ++j )
    {
      if ( (j & 1) != 0 )
        v7 = v14[2];
      else
        v7 = v14[5];
      v10[0] = v7;
      if ( (j & 2) != 0 )
        v6 = v14[3];
      else
        v6 = v14[6];
      v10[1] = v6;
      if ( (j & 4) != 0 )
        v5 = v14[4];
      else
        v5 = v14[7];
      v10[2] = v5;
      sub_8069244(v10, a2, v9);
      for ( k = 0; k <= 2; ++k )
      {
        if ( *(float *)&a3[k] > (long double)v9[k] )
          a3[k] = LODWORD(v9[k]);
        if ( v9[k] > (long double)*(float *)&a4[k] )
          a4[k] = LODWORD(v9[k]);
      }
    }
  }
  return 1;
}

//----- (080CFAF2) --------------------------------------------------------
int __cdecl sub_80CFAF2(__int16 a1)
{
  return a1;
}

//----- (080CFB06) --------------------------------------------------------
int __cdecl sub_80CFB06(int a1)
{
  return a1;
}

//----- (080CFB0E) --------------------------------------------------------
long double __cdecl sub_80CFB0E(float a1)
{
  return a1;
}

//----- (080CFB20) --------------------------------------------------------
int __cdecl sub_80CFB20(int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-28h]
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+8h] [ebp-20h]
  float v7; // [esp+Ch] [ebp-1Ch]
  float v8; // [esp+10h] [ebp-18h]
  float v9; // [esp+14h] [ebp-14h]
  float v10; // [esp+14h] [ebp-14h]
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+1Ch] [ebp-Ch]
  float v13; // [esp+20h] [ebp-8h]
  float v14; // [esp+24h] [ebp-4h]
  float v15; // [esp+24h] [ebp-4h]

  v14 = *(float *)a1 * *(float *)a1;
  v9 = *(float *)(a1 + 4) * *(float *)(a1 + 4);
  v5 = *(float *)(a1 + 8) * *(float *)(a1 + 8);
  v2 = v14 + v9 + v5 + *(float *)(a1 + 12) * *(float *)(a1 + 12);
  if ( v2 == 0.0 )
  {
    *(_DWORD *)a1 = 1065353216;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 20) = 1065353216;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    result = a1;
    *(_DWORD *)(a1 + 40) = 1065353216;
  }
  else
  {
    v3 = 2.0 / v2;
    v15 = v14 * v3;
    v10 = v9 * v3;
    v6 = v5 * v3;
    *(float *)a1 = *(float *)a1 * v3;
    v13 = *(float *)a1 * *(float *)(a1 + 4);
    v12 = *(float *)a1 * *(float *)(a1 + 8);
    v11 = *(float *)a1 * *(float *)(a1 + 12);
    *(float *)(a1 + 4) = *(float *)(a1 + 4) * v3;
    v8 = *(float *)(a1 + 4) * *(float *)(a1 + 8);
    v7 = *(float *)(a1 + 4) * *(float *)(a1 + 12);
    v4 = *(float *)(a1 + 8) * *(float *)(a1 + 12) * v3;
    *(float *)a1 = 1.0 - (v10 + v6);
    *(float *)(a1 + 4) = v13 + v4;
    *(float *)(a1 + 8) = v12 - v7;
    *(float *)(a1 + 16) = v13 - v4;
    *(float *)(a1 + 20) = 1.0 - (v15 + v6);
    *(float *)(a1 + 24) = v8 + v11;
    *(float *)(a1 + 32) = v12 + v7;
    *(float *)(a1 + 36) = v8 - v11;
    result = a1;
    *(float *)(a1 + 40) = 1.0 - (v15 + v10);
  }
  return result;
}

//----- (080CFCF2) --------------------------------------------------------
float *__cdecl sub_80CFCF2(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (080CFD9E) --------------------------------------------------------
int __cdecl sub_80CFD9E(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = (*(float *)a1 * *(float *)a3
                + *(float *)(a1 + 4) * *(float *)(a3 + 16)
                + *(float *)(a1 + 8) * *(float *)(a3 + 32)
                + *(float *)(a3 + 48))
               * a2
               + *(float *)a4;
  *(float *)(a4 + 4) = (*(float *)a1 * *(float *)(a3 + 4)
                      + *(float *)(a1 + 4) * *(float *)(a3 + 20)
                      + *(float *)(a1 + 8) * *(float *)(a3 + 36)
                      + *(float *)(a3 + 52))
                     * a2
                     + *(float *)(a4 + 4);
  result = a3;
  *(float *)(a4 + 8) = (*(float *)a1 * *(float *)(a3 + 8)
                      + *(float *)(a1 + 4) * *(float *)(a3 + 24)
                      + *(float *)(a1 + 8) * *(float *)(a3 + 40)
                      + *(float *)(a3 + 56))
                     * a2
                     + *(float *)(a4 + 8);
  return result;
}

//----- (080CFE70) --------------------------------------------------------
float *__cdecl sub_80CFE70(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10];
  return result;
}

//----- (080CFF0A) --------------------------------------------------------
float *__cdecl sub_80CFF0A(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[4] + a1[1] * a2[5] + a1[2] * a2[6];
  result = a1 + 2;
  a3[2] = *a1 * a2[8] + a1[1] * a2[9] + a1[2] * a2[10];
  return result;
}

//----- (080CFFA4) --------------------------------------------------------
int DObjInit()
{
  int result; // eax
  char s[40]; // [esp+10h] [ebp-28h] BYREF

  sub_80D2FE9(s, 0, 0x14u);
  result = sub_80A388C(s, 0, 0x11u);
  word_80F1C18 = result;
  return result;
}
// 80F1C18: using guessed type __int16 word_80F1C18;

//----- (080CFFF0) --------------------------------------------------------
int sub_80CFFF0()
{
  int result; // eax

  if ( word_80F1C18 )
  {
    result = sub_80A4106(word_80F1C18, 0x11u);
    word_80F1C18 = 0;
  }
  return result;
}
// 80F1C18: using guessed type __int16 word_80F1C18;

//----- (080D0022) --------------------------------------------------------
int __cdecl sub_80D0022(int a1)
{
  char v2; // [esp+4h] [ebp-34h]
  char v3; // [esp+4h] [ebp-34h]
  char v4; // [esp+4h] [ebp-34h]
  char v5; // [esp+4h] [ebp-34h]
  int v6; // [esp+14h] [ebp-24h]
  unsigned __int8 *k; // [esp+1Ch] [ebp-1Ch]
  int v8; // [esp+20h] [ebp-18h]
  int v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]
  int j; // [esp+30h] [ebp-8h]

  if ( !a1 )
    return Com_Printf("No Dobj\n", v2);
  Com_Printf("\nModels:\n", v2);
  v9 = *(unsigned __int8 *)(a1 + 22);
  v8 = 0;
  for ( i = 0; i < v9; ++i )
  {
    v6 = *(_DWORD *)(a1 + 4 * i + 28);
    Com_Printf("%d: '%s'\n", v8);
    v8 += ****(__int16 ****)(**(_DWORD **)(v6 + 4) + 4);
  }
  Com_Printf("\nBones:\n", v3);
  v10 = *(unsigned __int8 *)(a1 + 23);
  for ( j = 0; j < v10; ++j )
  {
    sub_80D1DA2(a1, j);
    Com_Printf("Bone %d: '%s'\n", j);
  }
  if ( *(_WORD *)(a1 + 20) )
  {
    Com_Printf("\nPart duplicates:\n", v4);
    for ( k = (unsigned __int8 *)(SL_ConvertToString(*(_WORD *)(a1 + 20)) + 16); *k; k += 2 )
    {
      sub_80D1DA2(a1, k[1] - 1);
      sub_80D1DA2(a1, *k - 1);
      Com_Printf("%d ('%s') -> %d ('%s')\n", *k - 1);
    }
  }
  else
  {
    Com_Printf("\nNo part duplicates.\n", v4);
  }
  return Com_Printf("\n", v5);
}
// 80D0036: variable 'v2' is possibly undefined
// 80D00BC: variable 'v3' is possibly undefined
// 80D0121: variable 'v4' is possibly undefined
// 80D01C2: variable 'v5' is possibly undefined

//----- (080D01E6) --------------------------------------------------------
int __cdecl sub_80D01E6(int a1, __int16 a2)
{
  int v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  v8 = *(unsigned __int8 *)(a1 + 22);
  v6 = 0;
  for ( i = 0; i < v8; ++i )
  {
    v5 = *(_DWORD *)(a1 + 4 * i + 28);
    v4 = sub_80CEBFA(v5, a2);
    if ( v4 >= 0 )
      return v6 + v4;
    v6 += ****(__int16 ****)(**(_DWORD **)(v5 + 4) + 4);
  }
  return -1;
}

//----- (080D0274) --------------------------------------------------------
int __cdecl sub_80D0274(int a1)
{
  void *v1; // esp
  char v2; // al
  int result; // eax
  _BYTE v4[12]; // [esp+10h] [ebp-48h] BYREF
  int v5; // [esp+1Ch] [ebp-3Ch]
  char v6; // [esp+23h] [ebp-35h]
  size_t n; // [esp+24h] [ebp-34h]
  void *s; // [esp+28h] [ebp-30h]
  unsigned __int16 *v9; // [esp+2Ch] [ebp-2Ch]
  __int16 *v10; // [esp+30h] [ebp-28h]
  int v11; // [esp+34h] [ebp-24h]
  int i; // [esp+38h] [ebp-20h]
  int v13; // [esp+3Ch] [ebp-1Ch]
  int v14; // [esp+40h] [ebp-18h]
  int v15; // [esp+44h] [ebp-14h]
  int v16; // [esp+48h] [ebp-10h]

  v1 = alloca(16 * ((2 * (unsigned int)*(unsigned __int8 *)(a1 + 23) + 32) >> 4));
  s = v4;
  sub_80D2FE9(v4, 0, 0x10u);
  v15 = ****(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 28) + 4) + 4);
  n = 16;
  v16 = 1;
  while ( v16 < *(unsigned __int8 *)(a1 + 22) )
  {
    v14 = *(_DWORD *)(a1 + 4 * v16 + 28);
    if ( *(_BYTE *)(v16 + a1 + 76) == 0xFF )
    {
      v10 = ***(__int16 ****)(**(_DWORD **)(v14 + 4) + 4);
      v9 = (unsigned __int16 *)(v10 + 1);
      v11 = *v10;
      v6 = 0;
      v13 = -1;
      for ( i = 0; i < v11; ++i )
      {
        v13 = sub_80D01E6(a1, v9[i]);
        if ( v13 != v15 + i )
        {
          if ( !i )
            v6 = 1;
          v5 = v15 + i;
          *((_BYTE *)s + n) = v15 + i + 1;
          *((_BYTE *)s + (v5 >> 3)) |= 1 << (v5 & 7);
          *((_BYTE *)s + ++n) = v13 + 1;
          ++n;
        }
      }
      if ( !v6 )
      {
        v2 = SL_ConvertToString(*v9);
        Com_Printf(
          "WARNING: Attempting to meld model, but root part '%s' of model '%s' not found in model '%s' or any of its descendants\n",
          v2);
      }
    }
    ++v16;
    v15 += ****(__int16 ****)(**(_DWORD **)(v14 + 4) + 4);
  }
  if ( n <= 0x10 )
  {
    result = (unsigned __int16)word_80F1C18;
    *(_WORD *)(a1 + 20) = word_80F1C18;
  }
  else
  {
    *((_BYTE *)s + n++) = 0;
    result = sub_80A388C(s, 0, n);
    *(_WORD *)(a1 + 20) = result;
  }
  return result;
}
// 80F1C18: using guessed type __int16 word_80F1C18;

//----- (080D049E) --------------------------------------------------------
int __cdecl sub_80D049E(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *k; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  __int16 **j; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 ***v11; // [esp+54h] [ebp-24h]
  int i; // [esp+58h] [ebp-20h]
  int v13; // [esp+5Ch] [ebp-1Ch]

  for ( i = 0; i <= 3; ++i )
    *(_DWORD *)(a3 + 4 * i) = 0;
  v13 = *(unsigned __int8 *)(a1 + 22);
  if ( !*(_WORD *)(a1 + 20) )
    sub_80D0274(a1);
  v4 = SL_ConvertToString(*(_WORD *)(a1 + 20));
  v10 = (unsigned __int8 *)(v4 + 16);
  k = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( i = 0; ; v5[i] = v6 )
  {
    v11 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * i + 28) + 4) + 4);
    v6 = v5[i] + ***v11;
    if ( v6 > a2 )
    {
      for ( j = *v11 + 1; ; a2 -= *((unsigned __int8 *)j + v6) )
      {
        v8 = a2 - v5[i];
        while ( 1 )
        {
          *(_BYTE *)((a2 >> 3) + a3) |= 1 << (a2 & 7);
          if ( (((unsigned __int8)(*(char *)((a2 >> 3) + v4) >> (a2 & 7)) ^ 1) & 1) == 0 )
          {
            for ( k = v10; a2 != *k - 1; k += 2 )
              ;
            a2 = k[1] - 1;
            goto LABEL_21;
          }
          v6 = v8 - *((__int16 *)v11 + 2);
          if ( v6 >= 0 )
            break;
          result = *(unsigned __int8 *)(i + a1 + 76);
          a2 = result;
          if ( result == 255 )
            return result;
          do
LABEL_21:
            v8 = a2 - v5[--i];
          while ( v8 < 0 );
          v11 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * i + 28) + 4) + 4);
          j = *v11 + 1;
        }
      }
    }
    result = ++i;
    if ( i == v13 )
      break;
  }
  return result;
}

//----- (080D0682) --------------------------------------------------------
int *__cdecl sub_80D0682(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-60h]
  int v4; // [esp+1Ch] [ebp-5Ch]
  int v5[8]; // [esp+20h] [ebp-58h]
  int v6; // [esp+40h] [ebp-38h]
  unsigned __int8 *j; // [esp+44h] [ebp-34h]
  int v8; // [esp+48h] [ebp-30h]
  __int16 **i; // [esp+4Ch] [ebp-2Ch]
  unsigned __int8 *v10; // [esp+50h] [ebp-28h]
  __int16 ***v11; // [esp+54h] [ebp-24h]
  int v12[8]; // [esp+58h] [ebp-20h] BYREF

  v3 = *(unsigned __int8 *)(a1 + 23) - 1;
  v12[1] = *(unsigned __int8 *)(a1 + 22);
  if ( !*(_WORD *)(a1 + 20) )
    sub_80D0274(a1);
  v4 = SL_ConvertToString(*(_WORD *)(a1 + 20));
  v10 = (unsigned __int8 *)(v4 + 16);
  j = (unsigned __int8 *)(v4 + 16);
  v5[0] = 0;
  for ( v12[0] = 0; ; v5[v12[0]] = v6 )
  {
    v11 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * v12[0] + 28) + 4) + 4);
    v6 = v5[v12[0]] + ***v11;
    if ( v6 > v3 )
      break;
    ++v12[0];
  }
  for ( i = *v11 + 1; ; i = *v11 + 1 )
  {
    while ( 1 )
    {
      v8 = v3 - v5[v12[0]];
      if ( v8 < 0 )
        break;
      if ( *(_BYTE *)((v3 >> 3) + a2) || ((1 << (v3 & 7)) & 1) == 0 )
      {
        if ( (((unsigned __int8)(*(char *)((v3 >> 3) + v4) >> (v3 & 7)) ^ 1) & 1) == 0 )
        {
          for ( j = v10; v3 != *j - 1; j += 2 )
            ;
          v6 = j[1] - 1;
          goto LABEL_22;
        }
        v6 = v8 - *((__int16 *)v11 + 2);
        if ( v6 >= 0 )
        {
          v6 = v3 - *((unsigned __int8 *)i + v6);
          goto LABEL_22;
        }
        v6 = *(unsigned __int8 *)(v12[0] + a1 + 76);
        if ( v6 == 255 )
        {
          --v3;
        }
        else
        {
LABEL_22:
          *(_BYTE *)((v6 >> 3) + a2) |= 1 << (v6 & 7);
          --v3;
        }
      }
      else
      {
        --v3;
      }
    }
    result = v12;
    if ( --v12[0] < 0 )
      break;
    v11 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * v12[0] + 28) + 4) + 4);
  }
  return result;
}

//----- (080D0874) --------------------------------------------------------
int __cdecl sub_80D0874(int a1, int a2)
{
  return (*(char *)(*(_DWORD *)(a1 + 4) + (a2 >> 3) + 32) >> (a2 & 7)) & 1;
}

//----- (080D08A2) --------------------------------------------------------
int __cdecl sub_80D08A2(int a1, int a2)
{
  int i; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 3; ++i )
  {
    if ( (*(_DWORD *)(a2 + 4 * i) & ~*(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * i + 32)) != 0 )
      return 0;
  }
  return 1;
}

//----- (080D0902) --------------------------------------------------------
int *__cdecl sub_80D0902(int a1, int a2)
{
  int *result; // eax
  int v3; // [esp+18h] [ebp-B0h]
  char v4; // [esp+1Fh] [ebp-A9h]
  int *v5; // [esp+20h] [ebp-A8h]
  int v6; // [esp+24h] [ebp-A4h]
  int v7; // [esp+24h] [ebp-A4h]
  float *v8; // [esp+2Ch] [ebp-9Ch]
  float *v9; // [esp+2Ch] [ebp-9Ch]
  float *v10; // [esp+30h] [ebp-98h]
  float *v11; // [esp+30h] [ebp-98h]
  float *v12; // [esp+30h] [ebp-98h]
  float *v13; // [esp+30h] [ebp-98h]
  float *v14; // [esp+30h] [ebp-98h]
  unsigned __int8 *v15; // [esp+34h] [ebp-94h]
  unsigned __int8 *v16; // [esp+34h] [ebp-94h]
  __int16 **v17; // [esp+38h] [ebp-90h]
  __int16 **v18; // [esp+38h] [ebp-90h]
  int v19; // [esp+3Ch] [ebp-8Ch]
  int v20; // [esp+40h] [ebp-88h]
  int v21; // [esp+40h] [ebp-88h]
  int v22; // [esp+40h] [ebp-88h]
  int v23; // [esp+40h] [ebp-88h]
  int v24; // [esp+40h] [ebp-88h]
  int v25; // [esp+44h] [ebp-84h]
  int v26; // [esp+48h] [ebp-80h]
  int v27; // [esp+48h] [ebp-80h]
  __int16 **v28; // [esp+4Ch] [ebp-7Ch]
  int v29[13]; // [esp+50h] [ebp-78h] BYREF
  float *v30; // [esp+84h] [ebp-44h]
  float *v31; // [esp+88h] [ebp-40h]
  float *v32; // [esp+8Ch] [ebp-3Ch]
  float *v33; // [esp+90h] [ebp-38h]
  unsigned __int8 v34; // [esp+97h] [ebp-31h]
  unsigned __int8 *v35; // [esp+98h] [ebp-30h]
  __int16 ***v36; // [esp+9Ch] [ebp-2Ch]
  int j; // [esp+A0h] [ebp-28h]
  int i; // [esp+A4h] [ebp-24h] BYREF
  float *v39; // [esp+A8h] [ebp-20h]
  float *v40; // [esp+ACh] [ebp-1Ch]

  result = *(int **)(a1 + 4);
  v5 = result;
  v4 = 1;
  for ( i = 0; i <= 3; ++i )
  {
    v29[i + 4] = v5[i + 8] | ~*(_DWORD *)(a2 + 4 * i);
    if ( v29[i + 4] != -1 )
      v4 = 0;
    result = &i;
  }
  if ( !v4 )
  {
    if ( !*(_WORD *)(a1 + 20) )
      sub_80D0274(a1);
    v3 = SL_ConvertToString(*(_WORD *)(a1 + 20));
    for ( i = 0; i <= 3; ++i )
    {
      v5[i + 8] |= *(_DWORD *)(a2 + 4 * i);
      v29[i + 8] = v5[i + 4] & ~v29[i + 4];
      v29[i] = *(_DWORD *)(v3 + 4 * i) | v29[i + 8] | v29[i + 4];
    }
    v15 = (unsigned __int8 *)(v3 + 16);
    for ( i = 0; i <= 3; ++i )
      v29[i + 8] |= ~v29[i];
    v19 = *(unsigned __int8 *)(a1 + 22);
    v32 = (float *)(v5 + 12);
    v31 = (float *)&v5[16 * *(unsigned __int8 *)(a1 + 23) + 12];
    v39 = v31;
    v26 = 0;
    for ( j = 0; j < v19; ++j )
    {
      v36 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * j + 28) + 4) + 4);
      v34 = *(_BYTE *)(j + a1 + 76);
      if ( v34 == 0xFF )
      {
        i = *((__int16 *)v36 + 2);
        while ( i )
        {
          v20 = 1 << (v26 & 7);
          if ( (v20 & *((char *)&v29[8] + (v26 >> 3))) == 0 && v26 == *v15 - 1 )
          {
            v15 += 2;
            if ( (v20 & *((char *)&v29[4] + (v26 >> 3))) == 0 )
            {
              v10 = &v31[8 * *(v15 - 1) - 8];
              *v39 = *v10;
              v39[1] = v10[1];
              v39[2] = v10[2];
              v39[3] = v10[3];
            }
          }
          --i;
          v39 += 8;
          ++v26;
        }
      }
      else
      {
        v11 = &v31[8 * v34];
        i = *((__int16 *)v36 + 2);
        while ( i )
        {
          v21 = 1 << (v26 & 7);
          if ( (v21 & *((char *)v29 + (v26 >> 3))) != 0 )
          {
            if ( (v21 & *((char *)&v29[8] + (v26 >> 3))) != 0 )
              sub_80D2DFA(v11, v39);
          }
          else
          {
            sub_80D2CC2(v39, v11);
          }
          --i;
          v39 += 8;
          ++v26;
        }
      }
      v28 = v36[3];
      v17 = *v36;
      v35 = (unsigned __int8 *)(*v36 + 1);
      i = **v17 - *((__int16 *)v36 + 2);
      while ( i )
      {
        v25 = v26 >> 3;
        v22 = 1 << (v26 & 7);
        if ( (v22 & *((char *)v29 + (v26 >> 3))) != 0 )
        {
          if ( (v22 & *((char *)&v29[8] + v25)) != 0 )
          {
            sub_80D2DFA(&v39[-8 * *v35], v39);
          }
          else if ( v26 == *v15 - 1 )
          {
            v15 += 2;
            if ( (v22 & *((char *)&v29[4] + v25)) == 0 )
            {
              v12 = &v31[8 * *(v15 - 1) - 8];
              *v39 = *v12;
              v39[1] = v12[1];
              v39[2] = v12[2];
              v39[3] = v12[3];
            }
          }
        }
        else
        {
          sub_80D2CC2(v39, &v39[-8 * *v35]);
        }
        --i;
        v39 += 8;
        ++v35;
        ++v26;
        v28 += 2;
      }
    }
    v16 = (unsigned __int8 *)(v3 + 16);
    v39 = v31;
    v40 = v32;
    v27 = 0;
    for ( j = 0; ; ++j )
    {
      result = (int *)j;
      if ( j >= v19 )
        break;
      v36 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * j + 28) + 4) + 4);
      v34 = *(_BYTE *)(j + a1 + 76);
      if ( v34 == 0xFF )
      {
        i = *((__int16 *)v36 + 2);
        while ( i )
        {
          v23 = 1 << (v27 & 7);
          if ( (v23 & *((char *)&v29[8] + (v27 >> 3))) != 0 )
          {
            sub_80D29EE(v39, v40);
            v40[12] = v39[5];
            v40[13] = v39[6];
            v40[14] = v39[7];
            v40[15] = 0.0;
          }
          else if ( v27 == *v16 - 1 )
          {
            v16 += 2;
            if ( (v23 & *((char *)&v29[4] + (v27 >> 3))) == 0 )
            {
              v6 = *(v16 - 1) - 1;
              v13 = &v31[8 * v6];
              v8 = &v32[16 * v6];
              v39[5] = v13[5];
              v39[6] = v13[6];
              v39[7] = v13[7];
              qmemcpy(v40, v8, 0x40u);
            }
          }
          --i;
          v39 += 8;
          v40 += 16;
          ++v27;
        }
      }
      else
      {
        v33 = &v32[16 * v34];
        i = *((__int16 *)v36 + 2);
        while ( i )
        {
          if ( ((1 << (v27 & 7)) & *((char *)&v29[8] + (v27 >> 3))) != 0 )
          {
            sub_80D29EE(v39, v40);
            sub_80D2C06(v39 + 5, v33);
            v40[12] = v39[5];
            v40[13] = v39[6];
            v40[14] = v39[7];
            v40[15] = 0.0;
          }
          --i;
          v39 += 8;
          v40 += 16;
          ++v27;
        }
      }
      v30 = (float *)v36[4];
      v18 = *v36;
      v35 = (unsigned __int8 *)(*v36 + 1);
      i = **v18 - *((__int16 *)v36 + 2);
      while ( i )
      {
        v24 = 1 << (v27 & 7);
        if ( (v24 & *((char *)&v29[8] + (v27 >> 3))) != 0 )
        {
          sub_80D29EE(v39, v40);
          v39[5] = v39[5] + *v30;
          v39[6] = v39[6] + v30[1];
          v39[7] = v39[7] + v30[2];
          sub_80D2C06(v39 + 5, &v40[-16 * *v35]);
          v40[12] = v39[5];
          v40[13] = v39[6];
          v40[14] = v39[7];
          v40[15] = 0.0;
        }
        else if ( v27 == *v16 - 1 )
        {
          v16 += 2;
          if ( (v24 & *((char *)&v29[4] + (v27 >> 3))) == 0 )
          {
            v7 = *(v16 - 1) - 1;
            v14 = &v31[8 * v7];
            v9 = &v32[16 * v7];
            v39[5] = v14[5];
            v39[6] = v14[6];
            v39[7] = v14[7];
            qmemcpy(v40, v9, 0x40u);
          }
        }
        --i;
        v39 += 8;
        v40 += 16;
        v30 += 3;
        ++v35;
        ++v27;
      }
    }
  }
  return result;
}

//----- (080D12C8) --------------------------------------------------------
int __cdecl sub_80D12C8(int a1, int a2)
{
  return *(_DWORD *)(a1 + 4) + (*(unsigned __int8 *)(a2 + a1 + 84) << 6) + 48;
}

//----- (080D12E6) --------------------------------------------------------
int __cdecl sub_80D12E6(int *a1, unsigned __int16 a2, _DWORD *a3, int a4, __int16 a5)
{
  int result; // eax
  int v7; // [esp+20h] [ebp-58h]
  char v8; // [esp+27h] [ebp-51h]
  char *v9; // [esp+28h] [ebp-50h]
  size_t n; // [esp+2Ch] [ebp-4Ch]
  int v11; // [esp+48h] [ebp-30h]
  __int16 v12; // [esp+4Eh] [ebp-2Ah]
  char *s; // [esp+50h] [ebp-28h]
  int v14; // [esp+54h] [ebp-24h]
  int v15; // [esp+5Ch] [ebp-1Ch]
  int j; // [esp+60h] [ebp-18h]
  int i; // [esp+64h] [ebp-14h]

  *(_DWORD *)a4 = a3;
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)(a4 + 8) = 0;
  *(_WORD *)(a4 + 18) = a5;
  *(_WORD *)(a4 + 20) = 0;
  *(_DWORD *)(a4 + 24) = 0;
  if ( a3 )
  {
    n = *(_DWORD *)(*a3 + 4);
    *(_DWORD *)(a4 + 12) = (char *)a3 + 2 * n + (3 * n + 1) * a3[2] + 12;
    v9 = (char *)(*(_DWORD *)(a4 + 12) + 2 * n);
    v8 = *v9 + 1;
    if ( *v9 == -1 )
    {
      v8 = 1;
      sub_80D2FE9(v9 + 1, 0, n);
    }
    *v9 = v8;
    a3[2] = 1 - a3[2];
  }
  else
  {
    *(_DWORD *)(a4 + 12) = 0;
  }
  v7 = 0;
  v15 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v14 = *a1;
    *(_DWORD *)(a4 + 4 * v7 + 28) = *a1;
    *(_BYTE *)(v7 + a4 + 76) = -1;
    *(_WORD *)(a4 + 2 * v7 + 60) = *((_WORD *)a1 + 4);
    *(_BYTE *)(v7 + a4 + 84) = v15;
    if ( a1[3] )
      *(_DWORD *)(a4 + 24) |= 1 << i;
    if ( i && (s = (char *)a1[1]) != 0 && *s )
    {
      v12 = sub_80A37F0(s);
      if ( v12 )
      {
        for ( j = 0; j < v7; ++j )
        {
          v11 = sub_80CEBFA(*(_DWORD *)(a4 + 4 * j + 28), v12);
          if ( v11 >= 0 )
          {
            *(_BYTE *)(v7 + a4 + 76) = *(_BYTE *)(j + a4 + 84) + v11;
            goto LABEL_20;
          }
        }
      }
      Com_Printf("WARNING: Part '%s' not found in model '%s' or any of its descendants\n", (char)s);
    }
    else
    {
LABEL_20:
      if ( v15 + ****(__int16 ****)(**(_DWORD **)(v14 + 4) + 4) > 127 )
        Com_Error(1, (char *)&byte_80E6160, **(_DWORD **)(a4 + 28), 127);
      v15 += ****(__int16 ****)(**(_DWORD **)(v14 + 4) + 4);
      ++v7;
    }
    a1 += 4;
  }
  *(_BYTE *)(a4 + 22) = v7;
  result = (unsigned __int8)v15;
  *(_BYTE *)(a4 + 23) = v15;
  return result;
}

//----- (080D15CE) --------------------------------------------------------
int __cdecl sub_80D15CE(int a1, int a2)
{
  int result; // eax
  int v3; // eax
  size_t v4; // eax
  _DWORD *v5; // [esp+14h] [ebp-4h]

  v5 = *(_DWORD **)a1;
  if ( *(_DWORD *)a1 )
  {
    if ( a2 )
      sub_80CAFD0(v5);
    v5[2] = *(_DWORD **)(a1 + 12) != (_DWORD *)((char *)v5 + 2 * *(_DWORD *)(*v5 + 4) + 12);
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)a1 = 0;
  }
  result = a1;
  if ( *(_WORD *)(a1 + 20) )
  {
    if ( *(_WORD *)(a1 + 20) != word_80F1C18 )
    {
      v3 = SL_ConvertToString(*(_WORD *)(a1 + 20));
      v4 = strlen((const char *)(v3 + 16));
      sub_80A4106(*(_WORD *)(a1 + 20), v4 + 17);
    }
    result = a1;
    *(_WORD *)(a1 + 20) = 0;
  }
  return result;
}
// 80F1C18: using guessed type __int16 word_80F1C18;

//----- (080D1690) --------------------------------------------------------
int __cdecl sub_80D1690(int a1)
{
  return 96 * *(unsigned __int8 *)(a1 + 23) + 48;
}

//----- (080D16B6) --------------------------------------------------------
_BOOL4 __cdecl sub_80D16B6(int a1, int a2)
{
  if ( *(_DWORD *)(a1 + 8) == a2 )
    return *(_DWORD *)(a1 + 4) != 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_WORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return 0;
}

//----- (080D1730) --------------------------------------------------------
int *__cdecl sub_80D1730(int a1, int *a2)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-4h] BYREF

  result = a2;
  *(_DWORD *)(a1 + 4) = a2;
  for ( i = 0; i <= 3; ++i )
  {
    a2[i] = 0;
    a2[i + 4] = 0;
    a2[i + 8] = 0;
    result = &i;
  }
  return result;
}

//----- (080D17A2) --------------------------------------------------------
int __cdecl sub_80D17A2(int a1, _DWORD *a2, _DWORD *a3)
{
  return sub_80CEC5C(*(_DWORD *)(a1 + 28), a2, a3);
}

//----- (080D17C6) --------------------------------------------------------
int __cdecl sub_80D17C6(int a1)
{
  return *(_DWORD *)(a1 + 4) + (*(unsigned __int8 *)(a1 + 23) << 6) + 48;
}

//----- (080D1860) --------------------------------------------------------
int __cdecl sub_80D1860(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v7 = a3 >> 3;
  v6 = 1 << (a3 & 7);
  if ( (v6 & *(char *)(a2 + (a3 >> 3))) == 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( (v6 & *(char *)(v5 + v7 + 32)) != 0 )
    return 0;
  *(_BYTE *)(v7 + v5) |= v6;
  return 1;
}

//----- (080D18E2) --------------------------------------------------------
int __cdecl sub_80D18E2(int a1, int a2, int a3)
{
  int v5; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  v7 = a3 >> 3;
  v6 = 1 << (a3 & 7);
  if ( (v6 & *(char *)(a2 + (a3 >> 3))) == 0 )
    return 0;
  v5 = *(_DWORD *)(a1 + 4);
  if ( (v6 & *(char *)(v5 + v7 + 32)) != 0 )
    return 0;
  *(_BYTE *)(v5 + v7 + 16) |= v6;
  *(_BYTE *)(v7 + v5) |= v6;
  return 1;
}

//----- (080D1A4E) --------------------------------------------------------
const char *__cdecl sub_80D1A4E(int a1, int a2, int a3, int a4)
{
  const char *v5; // [esp+10h] [ebp-8h]
  unsigned __int16 v6; // [esp+16h] [ebp-2h]

  v6 = *(_WORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 4 * a2 + 28) + 4) + 20 * *(_DWORD *)(a4 + 4 * a2) + 16)
                + 2 * a3);
  if ( v6 )
    v5 = (const char *)SL_ConvertToString(v6);
  else
    v5 = "DEFAULT";
  return v5;
}

//----- (080D1AB4) --------------------------------------------------------
int __cdecl sub_80D1AB4(int a1, int a2, void *s, int a4)
{
  int result; // eax
  int v5; // [esp+10h] [ebp-48h]
  char v6; // [esp+14h] [ebp-44h]
  char v7; // [esp+18h] [ebp-40h]
  int v8; // [esp+1Ch] [ebp-3Ch]
  int v9; // [esp+1Ch] [ebp-3Ch]
  int v10; // [esp+20h] [ebp-38h]
  int v11; // [esp+24h] [ebp-34h]
  int v12; // [esp+28h] [ebp-30h]
  int k; // [esp+2Ch] [ebp-2Ch]
  int m; // [esp+2Ch] [ebp-2Ch]
  int v15; // [esp+30h] [ebp-28h]
  int v16; // [esp+34h] [ebp-24h]
  int v17; // [esp+38h] [ebp-20h]
  int v18; // [esp+3Ch] [ebp-1Ch]
  int i; // [esp+40h] [ebp-18h]
  int j; // [esp+44h] [ebp-14h]
  int l; // [esp+44h] [ebp-14h]
  int v22; // [esp+48h] [ebp-10h]

  sub_80D2FE9(s, 0, 0x10u);
  v22 = *(unsigned __int8 *)(a1 + 22);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v22 )
      break;
    if ( *(int *)(a4 + 4 * i) >= 0 )
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 4 * i + 28) + 4);
      v17 = *(_DWORD *)(v10 + 20 * *(_DWORD *)(a4 + 4 * i) + 20);
      if ( v17 )
      {
        v11 = (****(__int16 ****)(*(_DWORD *)v10 + 4) - 1) >> 5;
        v16 = *(_DWORD *)(v17 + 4);
        v18 = *(__int16 *)(v16 + 4);
        v15 = *(unsigned __int8 *)(i + a1 + 84);
        v12 = *(_DWORD *)(v16 + 8);
        v5 = v15 >> 5;
        v7 = v15 & 0x1F;
        if ( (v15 & 0x1F) != 0 )
        {
          v6 = 32 - v7;
          for ( j = 0; j < v18; ++j )
          {
            *(_WORD *)(a2 + 2) = j;
            *(_WORD *)a2 = i;
            *((_DWORD *)s + v5) |= *(_DWORD *)(*(_DWORD *)v12 + 8) << v7;
            v8 = v5 + 1;
            for ( k = 0; k < v11; ++k )
              *((_DWORD *)s + v8++) |= (*(_DWORD *)(*(_DWORD *)v12 + 4 * k + 8) >> v6) | (*(_DWORD *)(*(_DWORD *)v12 + 4 * k + 12) << v7);
            *((_DWORD *)s + v8) |= *(_DWORD *)(*(_DWORD *)v12 + 4 * k + 8) >> v6;
            a2 += 4;
            v12 += 4;
          }
        }
        else
        {
          for ( l = 0; l < v18; ++l )
          {
            *(_WORD *)(a2 + 2) = l;
            *(_WORD *)a2 = i;
            v9 = v15 >> 5;
            for ( m = 0; m <= v11; ++m )
              *((_DWORD *)s + v9++) |= *(_DWORD *)(*(_DWORD *)v12 + 4 * m + 8);
            a2 += 4;
            v12 += 4;
          }
        }
      }
    }
  }
  return result;
}

//----- (080D1D5C) --------------------------------------------------------
int __cdecl sub_80D1D5C(int a1, char *s)
{
  int v3; // [esp+Ch] [ebp-Ch]
  __int16 v4; // [esp+16h] [ebp-2h]

  v4 = sub_80A3816(s);
  if ( v4 )
    v3 = sub_80D01E6(a1, v4);
  else
    v3 = -1;
  return v3;
}

//----- (080D1DA2) --------------------------------------------------------
int __cdecl sub_80D1DA2(int a1, int a2)
{
  __int16 *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v6 = 0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 22); ++i )
  {
    v5 = *(_DWORD *)(a1 + 4 * i + 28);
    v4 = ***(__int16 ****)(**(_DWORD **)(v5 + 4) + 4);
    if ( a2 - v6 < *v4 )
      return SL_ConvertToString(v4[a2 - v6 + 1]);
    v6 += ****(__int16 ****)(**(_DWORD **)(v5 + 4) + 4);
  }
  return 0;
}

//----- (080D1E48) --------------------------------------------------------
int __cdecl sub_80D1E48(int a1)
{
  return *(_DWORD *)a1;
}

//----- (080D1E52) --------------------------------------------------------
int __cdecl sub_80D1E52(int a1)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = *(unsigned __int8 *)(a1 + 22) - 1; i >= 0; --i )
  {
    if ( sub_80CC4BE(*(_DWORD *)(a1 + 4 * i + 28)) )
      return 1;
  }
  return 0;
}

//----- (080D1E9E) --------------------------------------------------------
int __cdecl sub_80D1E9E(int a1)
{
  return *(unsigned __int8 *)(a1 + 23);
}

//----- (080D1EAA) --------------------------------------------------------
float *__cdecl sub_80D1EAA(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (080D1F56) --------------------------------------------------------
float *__cdecl sub_80D1F56(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[12];
  v5 = a1[1] - a2[13];
  v6 = a1[2] - a2[14];
  *a3 = v4 * *a2 + v5 * a2[1] + v6 * a2[2];
  a3[1] = v4 * a2[4] + v5 * a2[5] + v6 * a2[6];
  result = a2;
  a3[2] = v4 * a2[8] + v5 * a2[9] + v6 * a2[10];
  return result;
}

//----- (080D2000) --------------------------------------------------------
int __cdecl sub_80D2000(int a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  __int16 v6; // [esp+1Ah] [ebp-21Eh]
  float v7[67]; // [esp+1Ch] [ebp-21Ch]
  int v8; // [esp+128h] [ebp-110h]
  int v9; // [esp+12Ch] [ebp-10Ch]
  __int16 **v10; // [esp+130h] [ebp-108h]
  unsigned __int8 *v11; // [esp+134h] [ebp-104h]
  __int16 *v12; // [esp+138h] [ebp-100h]
  unsigned int v13; // [esp+13Ch] [ebp-FCh]
  unsigned int v14; // [esp+140h] [ebp-F8h]
  int v15; // [esp+144h] [ebp-F4h]
  int v16; // [esp+148h] [ebp-F0h]
  int v17; // [esp+14Ch] [ebp-ECh]
  int v18; // [esp+150h] [ebp-E8h]
  float v19; // [esp+154h] [ebp-E4h]
  int v20; // [esp+158h] [ebp-E0h]
  float v21; // [esp+15Ch] [ebp-DCh]
  char v22; // [esp+162h] [ebp-D6h]
  char v23; // [esp+163h] [ebp-D5h]
  __int16 **i; // [esp+164h] [ebp-D4h]
  int j; // [esp+168h] [ebp-D0h]
  float v26; // [esp+16Ch] [ebp-CCh]
  float v27; // [esp+170h] [ebp-C8h]
  float v28; // [esp+174h] [ebp-C4h]
  float v29; // [esp+178h] [ebp-C0h]
  float v30; // [esp+17Ch] [ebp-BCh]
  float v31[4]; // [esp+180h] [ebp-B8h] BYREF
  float v32[7]; // [esp+190h] [ebp-A8h] BYREF
  float v33; // [esp+1ACh] [ebp-8Ch]
  float v34; // [esp+1B0h] [ebp-88h]
  float v35; // [esp+1B4h] [ebp-84h]
  float v36; // [esp+1B8h] [ebp-80h]
  float v37; // [esp+1CCh] [ebp-6Ch]
  float v38; // [esp+1D0h] [ebp-68h]
  float v39; // [esp+1D4h] [ebp-64h]
  float v40; // [esp+1D8h] [ebp-60h]
  float v41; // [esp+1E0h] [ebp-58h]
  float v42; // [esp+1E4h] [ebp-54h]
  float v43; // [esp+1E8h] [ebp-50h]
  float v44; // [esp+1F0h] [ebp-48h] BYREF
  float v45; // [esp+1F4h] [ebp-44h]
  float v46; // [esp+1F8h] [ebp-40h]
  float *v47; // [esp+20Ch] [ebp-2Ch]
  int v48; // [esp+210h] [ebp-28h]
  float v49; // [esp+214h] [ebp-24h]
  __int16 ***v50; // [esp+218h] [ebp-20h]
  float v51; // [esp+21Ch] [ebp-1Ch]
  float v52; // [esp+220h] [ebp-18h]
  float v53; // [esp+224h] [ebp-14h]
  float v54; // [esp+228h] [ebp-10h]

  v52 = *a3 - *a2;
  v53 = a3[1] - a2[1];
  v54 = a3[2] - a2[2];
  v51 = 1.0 / (v52 * v52 + v53 * v53 + v54 * v54);
  v47 = (float *)sub_80D12C8(a1, 0);
  *(_DWORD *)(a5 + 4) = 0;
  *(_BYTE *)(a5 + 24) = 0;
  *(_BYTE *)(a5 + 25) = 0;
  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  *(_DWORD *)(a5 + 16) = 0;
  *(_DWORD *)(a5 + 12) = 0;
  *(_DWORD *)(a5 + 8) = 0;
  v14 = 2;
  v16 = *(_DWORD *)(a1 + 4);
  v11 = (unsigned __int8 *)(SL_ConvertToString(*(_WORD *)(a1 + 20)) + 16);
  v17 = 0;
  v18 = -1;
  v19 = 0.0;
  v15 = 0;
LABEL_2:
  result = *(unsigned __int8 *)(a1 + 22);
  if ( v15 < result )
  {
    v50 = *(__int16 ****)(**(_DWORD **)(*(_DWORD *)(a1 + 4 * v15 + 28) + 4) + 4);
    v12 = **v50;
    v48 = *v12;
    v9 = *(_DWORD *)(a1 + 24) & (1 << v15);
    v20 = 0;
    while ( 1 )
    {
      if ( v20 >= v48 )
      {
        ++v15;
        goto LABEL_2;
      }
      LOWORD(v8) = *((unsigned __int8 *)v50[5] + v20);
      v13 = *(unsigned __int8 *)((unsigned __int16)v8 + a4);
      if ( v17 == *v11 - 1 )
      {
        v11 += 2;
        if ( v13 == 1 )
        {
          LOWORD(v8) = *((_WORD *)v7 + *(v11 - 1) + 1);
          v13 = *(unsigned __int8 *)((unsigned __int16)v8 + a4);
        }
      }
      else if ( v13 == 1 )
      {
        if ( v20 >= *((__int16 *)v50 + 2) )
        {
          LOWORD(v8) = *((_WORD *)&v7[1] + v17 - *((unsigned __int8 *)*v50 + v20 - *((__int16 *)v50 + 2) + 4));
        }
        else
        {
          HIBYTE(v8) = *(_BYTE *)(v15 + a1 + 76);
          if ( HIBYTE(v8) == 0xFF )
            v6 = 0;
          else
            v6 = *((_WORD *)&v7[1] + HIBYTE(v8));
          LOWORD(v8) = v6;
        }
        v13 = *(unsigned __int8 *)((unsigned __int16)v8 + a4);
      }
      *((_WORD *)&v7[1] + v17) = v8;
      if ( !v9 )
      {
        v10 = &v50[2][10 * v20];
        if ( *((float *)v10 + 9) != 0.0 && v14 <= v13 )
        {
          sub_80D1EAA((float *)v10 + 6, v47, &v44);
          v41 = *a2 - v44;
          v42 = a2[1] - v45;
          v43 = a2[2] - v46;
          v37 = -(v41 * v52 + v42 * v53 + v43 * v54) * v51;
          if ( v37 >= 1.0 )
          {
            v38 = *a3 - v44;
            v39 = a3[1] - v45;
            v40 = a3[2] - v46;
            v49 = v38 * v38 + v39 * v39 + v40 * v40;
          }
          else if ( v37 <= 0.0 )
          {
            v49 = v41 * v41 + v42 * v42 + v43 * v43;
          }
          else
          {
            v34 = v52 * v37 + v41;
            v35 = v53 * v37 + v42;
            v36 = v54 * v37 + v43;
            v49 = v34 * v34 + v35 * v35 + v36 * v36;
          }
          v33 = *((float *)v10 + 9) - v49;
          if ( v33 > 0.0 )
          {
            if ( v14 != v13 || (v7[0] = sqrt(v33 * v51), v37 - v7[0] < (long double)*(float *)a5) )
            {
              sub_80D1F56(a2, v47, v32);
              sub_80D1F56(a3, v47, v31);
              v30 = 0.0;
              v29 = *(float *)a5;
              v23 = 1;
              v22 = 1;
              v21 = -1.0;
              for ( i = v10; ; i += 3 )
              {
                for ( j = 0; j <= 2; ++j )
                {
                  v28 = (v32[j] - *(float *)&i[j]) * v21;
                  v27 = (v31[j] - *(float *)&i[j]) * v21;
                  if ( v28 <= 0.0 )
                  {
                    if ( v27 > 0.0 )
                    {
                      v22 = 0;
                      v26 = v28 - v27;
                      if ( v28 > v29 * v26 )
                      {
                        v29 = v28 / v26;
                        if ( v30 >= (long double)v29 )
                          goto LABEL_49;
                      }
                    }
                  }
                  else
                  {
                    if ( v27 > 0.0 )
                      goto LABEL_49;
                    v23 = 0;
                    v26 = v28 - v27;
                    if ( v28 > v30 * v26 )
                    {
                      v30 = v28 / v26;
                      if ( v30 >= (long double)v29 )
                        goto LABEL_49;
                      v19 = v21;
                      v18 = j;
                    }
                  }
                }
                if ( v21 == 1.0 )
                  break;
                v21 = 1.0;
              }
              if ( v23 )
              {
                *(_BYTE *)(a5 + 24) = 1;
                if ( v22 )
                {
                  *(_BYTE *)(a5 + 25) = 1;
                  *(_DWORD *)a5 = 0;
                  *(_WORD *)(a5 + 20) = v12[v20 + 1];
                  *(_WORD *)(a5 + 22) = v8;
                  result = 0;
                  *(_DWORD *)(a5 + 16) = 0;
                  *(_DWORD *)(a5 + 12) = 0;
                  *(_DWORD *)(a5 + 8) = 0;
                  return result;
                }
              }
              else
              {
                if ( v14 == v13 )
                {
                  if ( v30 >= (long double)*(float *)a5 )
                    goto LABEL_49;
                }
                else
                {
                  v14 = v13;
                }
                *(float *)a5 = v30;
                *(_WORD *)(a5 + 20) = v12[v20 + 1];
                *(_WORD *)(a5 + 22) = v8;
                *(float *)(a5 + 8) = v47[4 * v18] * v19;
                *(float *)(a5 + 12) = v47[4 * v18 + 1] * v19;
                *(float *)(a5 + 16) = v47[4 * v18 + 2] * v19;
              }
            }
          }
        }
      }
LABEL_49:
      ++v20;
      v47 += 16;
      ++v17;
    }
  }
  return result;
}

//----- (080D2854) --------------------------------------------------------
int __cdecl sub_80D2854(int a1, float *a2, float *a3, int a4, int a5)
{
  int result; // eax
  int v6; // [esp+28h] [ebp-50h]
  __int16 *v7; // [esp+2Ch] [ebp-4Ch]
  int i; // [esp+30h] [ebp-48h]
  int v9; // [esp+34h] [ebp-44h]
  int v10; // [esp+3Ch] [ebp-3Ch]
  int v11[4]; // [esp+40h] [ebp-38h] BYREF
  int v12; // [esp+50h] [ebp-28h]
  int v13; // [esp+54h] [ebp-24h]
  int v14; // [esp+58h] [ebp-20h]
  int v15; // [esp+5Ch] [ebp-1Ch]

  v9 = sub_80D12C8(a1, 0);
  *(_WORD *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 22) = 0;
  *(_BYTE *)(a5 + 24) = 0;
  *(_BYTE *)(a5 + 25) = 0;
  v11[0] = *(_DWORD *)a5;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 22); ++i )
  {
    v10 = *(_DWORD *)(a1 + 4 * i + 28);
    v7 = ***(__int16 ****)(**(_DWORD **)(v10 + 4) + 4);
    v6 = sub_80CF4FE(v10, (int)v11, v9, a2, a3, a4);
    if ( v6 >= 0 )
      *(_WORD *)(a5 + 20) = v7[v6 + 1];
    v9 += *v7 << 6;
  }
  *(_DWORD *)a5 = v11[0];
  *(_DWORD *)(a5 + 4) = v15;
  *(_DWORD *)(a5 + 8) = v12;
  *(_DWORD *)(a5 + 12) = v13;
  result = v14;
  *(_DWORD *)(a5 + 16) = v14;
  return result;
}

//----- (080D297C) --------------------------------------------------------
int __cdecl sub_80D297C(int a1, int a2, float a3)
{
  return sub_80CF21A(*(_DWORD *)(a1 + 4 * a2 + 28), a3);
}

//----- (080D299E) --------------------------------------------------------
int __cdecl sub_80D299E(int a1, int a2)
{
  int i; // [esp+14h] [ebp-4h]

  for ( i = 0; i < *(unsigned __int8 *)(a1 + 22); ++i )
  {
    if ( (a2 & sub_80CEFA0(*(_DWORD *)(a1 + 4 * i + 28))) != 0 )
      return 1;
  }
  return 0;
}

//----- (080D29EE) --------------------------------------------------------
float *__cdecl sub_80D29EE(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-30h]
  float v4; // [esp+4h] [ebp-2Ch]
  float v5; // [esp+8h] [ebp-28h]
  float v6; // [esp+8h] [ebp-28h]
  float v7; // [esp+Ch] [ebp-24h]
  float v8; // [esp+10h] [ebp-20h]
  float v9; // [esp+10h] [ebp-20h]
  float v10; // [esp+14h] [ebp-1Ch]
  float v11; // [esp+18h] [ebp-18h]
  float v12; // [esp+1Ch] [ebp-14h]
  float v13; // [esp+1Ch] [ebp-14h]
  float v14; // [esp+20h] [ebp-10h]
  float v15; // [esp+24h] [ebp-Ch]
  float v16; // [esp+28h] [ebp-8h]
  float v17; // [esp+2Ch] [ebp-4h]
  float v18; // [esp+2Ch] [ebp-4h]

  v17 = *a1 * *a1;
  v12 = a1[1] * a1[1];
  v8 = a1[2] * a1[2];
  v5 = v17 + v12 + v8 + a1[3] * a1[3];
  if ( v5 == 0.0 )
  {
    *a2 = 1.0;
    a2[1] = 0.0;
    a2[2] = 0.0;
    a2[3] = 0.0;
    a2[4] = 0.0;
    a2[5] = 1.0;
    a2[6] = 0.0;
    a2[7] = 0.0;
    a2[8] = 0.0;
    a2[9] = 0.0;
    a2[10] = 1.0;
  }
  else
  {
    v6 = 2.0 / v5;
    v18 = v17 * v6;
    v13 = v12 * v6;
    v9 = v8 * v6;
    v4 = *a1 * v6;
    v16 = v4 * a1[1];
    v15 = v4 * a1[2];
    v14 = v4 * a1[3];
    v3 = a1[1] * v6;
    v11 = v3 * a1[2];
    v10 = v3 * a1[3];
    v7 = a1[2] * a1[3] * v6;
    *a2 = 1.0 - (v13 + v9);
    a2[1] = v16 + v7;
    a2[2] = v15 - v10;
    a2[3] = 0.0;
    a2[4] = v16 - v7;
    a2[5] = 1.0 - (v18 + v9);
    a2[6] = v11 + v14;
    a2[7] = 0.0;
    a2[8] = v15 + v10;
    a2[9] = v11 - v14;
    a2[10] = 1.0 - (v18 + v13);
  }
  result = a2;
  a2[11] = 0.0;
  return result;
}

//----- (080D2C06) --------------------------------------------------------
int __cdecl sub_80D2C06(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  v4 = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  a1[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  *a1 = v3;
  result = LODWORD(v4);
  a1[1] = v4;
  return result;
}

//----- (080D2CC2) --------------------------------------------------------
int __cdecl sub_80D2CC2(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a1[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a1 = v3;
  a1[1] = v4;
  result = LODWORD(v5);
  a1[2] = v5;
  return result;
}

//----- (080D2DFA) --------------------------------------------------------
int __cdecl sub_80D2DFA(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  v4 = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  v5 = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  a2[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  *a2 = v3;
  a2[1] = v4;
  result = LODWORD(v5);
  a2[2] = v5;
  return result;
}

//----- (080D2F34) --------------------------------------------------------
int __cdecl sub_80D2F34(char *name)
{
  int v3; // [esp+Ch] [ebp-Ch]
  struct dirent *v4; // [esp+10h] [ebp-8h]
  DIR *dirp; // [esp+14h] [ebp-4h]

  v3 = 0;
  dirp = opendir(name);
  if ( !dirp )
    return 0;
  while ( 1 )
  {
    v4 = readdir(dirp);
    if ( !v4 )
      break;
    if ( strcmp(v4->d_name, ".") && strcmp(v4->d_name, "..") )
    {
      v3 = 1;
      break;
    }
  }
  closedir(dirp);
  return v3;
}

//----- (080D2FC8) --------------------------------------------------------
void *__cdecl sub_80D2FC8(void *dest, void *src, size_t n)
{
  return memcpy(dest, src, n);
}

//----- (080D2FE9) --------------------------------------------------------
void *__cdecl sub_80D2FE9(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

//----- (080D3039) --------------------------------------------------------
void sub_80D3039()
{
  sub_808471E();
  sub_8084714();
}

//----- (080D304B) --------------------------------------------------------
ssize_t sub_80D304B()
{
  ssize_t result; // eax
  char buf; // [esp+17h] [ebp-1h] BYREF

  do
    result = read(0, &buf, 1u);
  while ( result != -1 );
  return result;
}

//----- (080D3074) --------------------------------------------------------
ssize_t sub_80D3074()
{
  char buf; // [esp+17h] [ebp-1h] BYREF

  buf = 8;
  write(1, &buf, 1u);
  buf = 32;
  write(1, &buf, 1u);
  buf = 8;
  return write(1, &buf, 1u);
}

//----- (080D30D9) --------------------------------------------------------
int sub_80D30D9()
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( dword_80F1C2C )
  {
    ++dword_80F1C2C;
  }
  else
  {
    if ( dword_832D9E0 > 0 )
    {
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= dword_832D9E0 )
          break;
        sub_80D3074();
      }
    }
    ++dword_80F1C2C;
  }
  return result;
}
// 80F1C2C: using guessed type int dword_80F1C2C;
// 832D9E0: using guessed type int dword_832D9E0;

//----- (080D3121) --------------------------------------------------------
int sub_80D3121()
{
  int result; // eax
  int i; // [esp+14h] [ebp-4h]

  if ( !--dword_80F1C2C && dword_832D9E0 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_832D9E0 )
        break;
      write(1, (const void *)(i + 137550332), 1u);
    }
  }
  return result;
}
// 80F1C2C: using guessed type int dword_80F1C2C;
// 832D9E0: using guessed type int dword_832D9E0;

//----- (080D317C) --------------------------------------------------------
int sub_80D317C()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]

  if ( dword_80F1C28 )
  {
    Com_Printf("Shutdown tty console\n", v1);
    result = tcsetattr(0, 1, &termios_p);
  }
  return result;
}
// 80D3192: variable 'v1' is possibly undefined
// 80F1C28: using guessed type int dword_80F1C28;

//----- (080D31B5) --------------------------------------------------------
unsigned int __cdecl sub_80D31B5(_DWORD *a1)
{
  unsigned int result; // eax
  unsigned int v2; // [esp+0h] [ebp-24h]
  const void *v3; // [esp+4h] [ebp-20h]
  char *v4; // [esp+8h] [ebp-1Ch]
  unsigned int v5; // [esp+Ch] [ebp-18h]
  const void *v6; // [esp+10h] [ebp-14h]
  void *v7; // [esp+14h] [ebp-10h]
  int i; // [esp+18h] [ebp-Ch]

  for ( i = 31; i > 0; --i )
  {
    v7 = (void *)(284 * i + 137550592);
    v6 = (const void *)(284 * i + 137550308);
    v5 = 284;
    if ( ((28 * (_BYTE)i) & 4) != 0 )
    {
      dword_832DB00[71 * i] = *((_DWORD *)&unk_832D9E4 + 71 * i);
      v7 = (void *)(284 * i + 137550596);
      v6 = (const void *)(284 * i + 137550312);
      v5 = 280;
    }
    qmemcpy(v7, v6, 4 * (v5 >> 2));
  }
  v4 = (char *)dword_832DB00;
  v3 = a1;
  v2 = 284;
  result = (unsigned int)dword_832DB00 & 4;
  if ( ((unsigned int)dword_832DB00 & 4) != 0 )
  {
    result = *a1;
    dword_832DB00[0] = *a1;
    v4 = (char *)&dword_832DB00[1];
    v3 = a1 + 1;
    v2 = 280;
  }
  qmemcpy(v4, v3, 4 * (v2 >> 2));
  if ( dword_80F1C3C <= 31 )
    ++dword_80F1C3C;
  dword_80F1C38 = -1;
  return result;
}
// 80F1C38: using guessed type int dword_80F1C38;
// 80F1C3C: using guessed type int dword_80F1C3C;

//----- (080D3291) --------------------------------------------------------
int sub_80D3291()
{
  if ( dword_80F1C38 + 1 >= dword_80F1C3C )
    return 0;
  ++dword_80F1C38;
  return 284 * dword_80F1C38 + 137550592;
}
// 80F1C38: using guessed type int dword_80F1C38;
// 80F1C3C: using guessed type int dword_80F1C3C;

//----- (080D32D2) --------------------------------------------------------
int sub_80D32D2()
{
  int v1; // [esp+0h] [ebp-4h]

  if ( dword_80F1C38 >= 0 )
    --dword_80F1C38;
  if ( dword_80F1C38 == -1 )
    v1 = 0;
  else
    v1 = 284 * dword_80F1C38 + 137550592;
  return v1;
}
// 80F1C38: using guessed type int dword_80F1C38;

//----- (080D3311) --------------------------------------------------------
void __cdecl __noreturn sub_80D3311(int status)
{
  sub_80D317C();
  if ( byte_80F1C40 )
  {
    sleep(1u);
    sub_80D4551(&byte_80F1C40);
    sleep(1u);
  }
  exit(status);
}

//----- (080D3354) --------------------------------------------------------
void __noreturn sub_80D3354()
{
  int v0; // eax

  sub_8084650();
  sub_8072976();
  sub_8060542();
  sub_806C459();
  v0 = fcntl(0, 3, 0);
  fcntl(0, 4, v0 & 0xFFFFF7FF);
  sub_80D3311(0);
}

//----- (080D33B5) --------------------------------------------------------
void Sys_Init()
{
  char *v0; // eax

  sub_806043E("in_restart", (int)sub_80D3039);
  Cvar_Set("arch", "linux i386");
  v0 = (char *)sub_80D5F35();
  Cvar_Set("username", v0);
  sub_8084714();
}

//----- (080D33FF) --------------------------------------------------------
void __noreturn Sys_Error(char *format, ...)
{
  int v1; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  v1 = fcntl(0, 3, 0);
  fcntl(0, 4, v1 & 0xFFFFF7FF);
  if ( dword_80F1C28 )
    sub_80D30D9();
  sub_8084650();
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  fprintf(stderr, "Sys_Error: %s\n", s);
  sub_80D3311(1);
}
// 80F1C28: using guessed type int dword_80F1C28;

//----- (080D353F) --------------------------------------------------------
void handler()
{
  signal(8, handler);
}

//----- (080D355B) --------------------------------------------------------
void sub_80D355B()
{
  char v0; // [esp+4h] [ebp-54h]
  struct termios s; // [esp+10h] [ebp-48h] BYREF

  memset(&s, 0, sizeof(s));
  signal(21, (__sighandler_t)1);
  signal(22, (__sighandler_t)1);
  dword_80F1C24 = (int)Cvar_Get("ttycon", "1", 0);
  if ( !dword_80F1C24 || *(float *)(dword_80F1C24 + 28) == 0.0 )
  {
    dword_80F1C28 = 0;
  }
  else if ( isatty(0) == 1 )
  {
    Com_Printf("Started tty console (use +set ttycon 0 to disable)\n", v0);
    sub_8071AA7(&dword_832D9E0);
    tcgetattr(0, &termios_p);
    dword_80F1C30 = s.c_cc[2];
    dword_80F1C34 = s.c_cc[4];
    qmemcpy(&s, &termios_p, sizeof(s));
    s.c_lflag &= 0xFFFFFFF5;
    s.c_iflag &= 0xFFFFFFCF;
    s.c_cc[6] = 1;
    s.c_cc[5] = 0;
    tcsetattr(0, 1, &s);
    dword_80F1C28 = 1;
  }
  else
  {
    Com_Printf("stdin is not a tty, tty console mode failed\n", v0);
    Cvar_Set("ttycon", "0");
    dword_80F1C28 = 0;
  }
}
// 80D3606: variable 'v0' is possibly undefined
// 80F1C24: using guessed type int dword_80F1C24;
// 80F1C28: using guessed type int dword_80F1C28;
// 80F1C30: using guessed type int dword_80F1C30;
// 80F1C34: using guessed type int dword_80F1C34;
// 832D9E0: using guessed type int dword_832D9E0;

//----- (080D36CA) --------------------------------------------------------
char *sub_80D36CA()
{
  unsigned int v1; // [esp+24h] [ebp-D4h]
  int *v2; // [esp+28h] [ebp-D0h]
  int *v3; // [esp+2Ch] [ebp-CCh]
  unsigned int v4; // [esp+30h] [ebp-C8h]
  int *v5; // [esp+34h] [ebp-C4h]
  int *v6; // [esp+38h] [ebp-C0h]
  char *v7; // [esp+3Ch] [ebp-BCh]
  struct timeval timeout; // [esp+48h] [ebp-B0h] BYREF
  fd_set readfds; // [esp+50h] [ebp-A8h] BYREF
  ssize_t v10; // [esp+DCh] [ebp-1Ch]
  int *v11; // [esp+E0h] [ebp-18h]
  char buf; // [esp+E7h] [ebp-11h] BYREF
  ssize_t v13; // [esp+E8h] [ebp-10h]
  int i; // [esp+ECh] [ebp-Ch]

  buf = 0;
  if ( !dword_80F1C24 || *(float *)(dword_80F1C24 + 28) == 0.0 )
  {
    if ( !dword_835F480 || *(float *)(dword_835F480 + 28) == 0.0 )
      return 0;
    if ( !dword_80F1C20 )
      return 0;
    memset(&readfds, 0, sizeof(readfds));
    readfds.__fds_bits[0] |= 1u;
    timeout.tv_sec = 0;
    timeout.tv_usec = 0;
    if ( select(1, &readfds, 0, 0, &timeout) == -1 || !_bittest(readfds.__fds_bits, 0) )
      return 0;
    v10 = read(0, ::buf, 0x100u);
    if ( v10 )
    {
      if ( v10 > 0 )
      {
        *(_BYTE *)(v10 + 137549983) = 0;
        v7 = ::buf;
      }
      else
      {
        v7 = 0;
      }
    }
    else
    {
      dword_80F1C20 = 0;
      v7 = 0;
    }
    return v7;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 )
    return 0;
  if ( buf == dword_80F1C30 || buf == 127 || buf == 8 )
  {
    if ( dword_832D9E0 > 0 )
    {
      *(_BYTE *)(--dword_832D9E0 + 137550332) = 0;
      sub_80D3074();
    }
    return 0;
  }
  if ( !buf || buf > 31 )
  {
    *(_BYTE *)(dword_832D9E0 + 137550332) = buf;
    ++dword_832D9E0;
    write(1, &buf, 1u);
    return 0;
  }
  if ( buf == 10 )
  {
    sub_80D31B5(&dword_832D9E0);
    strcpy(::buf, &byte_832D9FC);
    sub_8071AA7(&dword_832D9E0);
    buf = 10;
    write(1, &buf, 1u);
    return ::buf;
  }
  if ( buf == 9 )
  {
    sub_80D30D9();
    sub_8071D1B((char **)&dword_832D9E0);
    dword_832D9E0 = strlen(&byte_832D9FC);
    if ( dword_832D9E0 > 0 && byte_832D9FC == 92 )
    {
      for ( i = 0; i <= dword_832D9E0; ++i )
        *(_BYTE *)(i + 137550332) = *(_BYTE *)(i + 137550333);
      --dword_832D9E0;
    }
    sub_80D3121();
    return 0;
  }
  v13 = read(0, &buf, 1u);
  if ( v13 == -1 || buf != 91 && buf != 79 || (v13 = read(0, &buf, 1u), v13 == -1) )
  {
LABEL_46:
    Com_DPrintf("droping ISCTL sequence: %d, tty_erase: %d\n", buf, dword_80F1C30);
    sub_80D304B();
    return 0;
  }
  if ( buf == 66 )
  {
    v11 = (int *)sub_80D32D2();
    sub_80D30D9();
    if ( v11 )
    {
      v3 = &dword_832D9E0;
      v2 = v11;
      v1 = 284;
      if ( ((unsigned int)&dword_832D9E0 & 4) != 0 )
      {
        dword_832D9E0 = *v11;
        v3 = &dword_832D9E0 + 1;
        v2 = v11 + 1;
        v1 = 280;
      }
      qmemcpy(v3, v2, 4 * (v1 >> 2));
    }
    else
    {
      sub_8071AA7(&dword_832D9E0);
    }
    sub_80D3121();
    sub_80D304B();
    return 0;
  }
  if ( buf > 66 )
  {
    if ( buf == 67 )
      return 0;
    if ( buf == 68 )
      return 0;
    goto LABEL_46;
  }
  if ( buf != 65 )
    goto LABEL_46;
  v11 = (int *)sub_80D3291();
  if ( v11 )
  {
    sub_80D30D9();
    v6 = &dword_832D9E0;
    v5 = v11;
    v4 = 284;
    if ( ((unsigned int)&dword_832D9E0 & 4) != 0 )
    {
      dword_832D9E0 = *v11;
      v6 = &dword_832D9E0 + 1;
      v5 = v11 + 1;
      v4 = 280;
    }
    qmemcpy(v6, v5, 4 * (v4 >> 2));
    sub_80D3121();
  }
  sub_80D304B();
  return 0;
}
// 80F1C20: using guessed type int dword_80F1C20;
// 80F1C24: using guessed type int dword_80F1C24;
// 80F1C30: using guessed type int dword_80F1C30;
// 832D9E0: using guessed type int dword_832D9E0;
// 835F480: using guessed type int dword_835F480;

//----- (080D3C34) --------------------------------------------------------
char *__cdecl sub_80D3C34(void *handle)
{
  char *result; // eax
  char v2; // [esp+4h] [ebp-14h]

  if ( !handle )
    return (char *)Com_Printf("Sys_UnloadDll(NULL)\n", v2);
  dlclose(handle);
  result = dlerror();
  if ( result )
    result = (char *)Com_Printf("Sys_UnloadGame failed on dlclose: \"%s\"!\n", (char)result);
  return result;
}
// 80D3C47: variable 'v2' is possibly undefined

//----- (080D3C7C) --------------------------------------------------------
void sub_80D3C7C()
{
  ;
}

//----- (080D3C86) --------------------------------------------------------
int sub_80D3C86()
{
  return 0;
}

//----- (080D3C90) --------------------------------------------------------
int sub_80D3C90()
{
  return 0;
}

//----- (080D3C9A) --------------------------------------------------------
void __noreturn sub_80D3C9A()
{
  fprintf(stderr, "OUT OF MEMORY! ABORTING!!!\n");
  exit(-1);
}

//----- (080D3CC1) --------------------------------------------------------
void __noreturn sub_80D3CC1()
{
  Com_Error(0, "Unable to load shared library\n");
}

//----- (080D3CDD) --------------------------------------------------------
void *__cdecl Sys_LoadDLL(const char *a1, char *dest, int a3, int a4)
{
  char v5; // [esp+4h] [ebp-244h]
  char v6; // [esp+4h] [ebp-244h]
  char *v7; // [esp+1Ch] [ebp-22Ch]
  char file[256]; // [esp+20h] [ebp-228h] BYREF
  char *v9; // [esp+120h] [ebp-128h]
  char *v10; // [esp+124h] [ebp-124h]
  char *v11; // [esp+128h] [ebp-120h]
  char *v12; // [esp+12Ch] [ebp-11Ch]
  char s[264]; // [esp+130h] [ebp-118h] BYREF
  void (__cdecl *v14)(int); // [esp+238h] [ebp-10h]
  void *handle; // [esp+23Ch] [ebp-Ch]

  *dest = 0;
  snprintf(s, 0x100u, "%s.mp.i386.so", a1);
  v12 = sub_80D5D5A();
  v11 = (char *)Cvar_VariableString((int)"fs_homepath");
  v10 = (char *)Cvar_VariableString((int)"fs_basepath");
  v9 = (char *)Cvar_VariableString((int)"fs_game");
  sub_8060CD2(v12, v9, s, file);
  Com_Printf("Sys_LoadDll(%s)... ", (char)file);
  handle = dlopen(file, 2);
  if ( handle
    || (Com_Printf("failed\n", v5),
        sub_8060CD2(v11, v9, s, file),
        Com_Printf("Sys_LoadDll(%s)... ", (char)file),
        (handle = dlopen(file, 2)) != 0) )
  {
    Com_Printf("ok\n", v5);
  }
  else
  {
    Com_Printf("failed\n", v5);
    sub_8060CD2(v10, v9, s, file);
    Com_Printf("Sys_LoadDll(%s)... ", (char)file);
    handle = dlopen(file, 2);
    if ( handle )
    {
      Com_Printf("ok\n", v6);
    }
    else
    {
      dlerror();
      Com_Printf("\nSys_LoadDll(%s) failed:\n\"%s\"\n", (char)file);
    }
    if ( !handle )
      Com_Error(0, "Sys_LoadDll(%s) failed dlopen() completely!\n", a1);
  }
  Q_strncpyz(dest, file, 64);
  v14 = (void (__cdecl *)(int))dlsym(handle, "dllEntry");
  *(_DWORD *)a3 = dlsym(handle, "vmMain");
  if ( !*(_DWORD *)a3 || !v14 )
  {
    v7 = dlerror();
    Com_Error(0, "Sys_LoadDll(%s) failed dlsym(vmMain):\n\"%s\" !\n", a1, v7);
  }
  Com_Printf("Sys_LoadDll(%s) found **vmMain** at  %p  \n", (char)a1);
  v14(a4);
  Com_Printf("Sys_LoadDll(%s) succeeded!\n", (char)a1);
  return handle;
}
// 80D3DC9: variable 'v5' is possibly undefined
// 80D3EC8: variable 'v6' is possibly undefined

//----- (080D4049) --------------------------------------------------------
void sub_80D4049()
{
  ;
}

//----- (080D404E) --------------------------------------------------------
int __cdecl sub_80D404E(char *a1, int a2, int a3, int a4)
{
  return FS_Read(a1, a3 * a2, a4);
}

//----- (080D4073) --------------------------------------------------------
int __cdecl sub_80D4073(int a1, int off, int a3)
{
  return sub_8062BE1(a1, off, a3);
}

//----- (080D4094) --------------------------------------------------------
int __cdecl sub_80D4094(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax
  int *v7; // [esp+4h] [ebp-4h]

  v7 = &dword_83E3540[6 * (unsigned __int8)dword_80F2040];
  if ( dword_80F2040 - dword_80F2044 > 255 )
  {
    Com_Printf("Sys_QueEvent: overflow\n", (char)v7);
    if ( v7[5] )
      Z_FreeInternal((void *)v7[5]);
    ++dword_80F2044;
  }
  ++dword_80F2040;
  if ( !a1 )
    a1 = sub_80D563C();
  *v7 = a1;
  v7[1] = a2;
  v7[2] = a3;
  v7[3] = a4;
  v7[4] = a5;
  result = a6;
  v7[5] = a6;
  return result;
}
// 80D40DB: variable 'v7' is possibly undefined
// 80F2040: using guessed type int dword_80F2040;
// 80F2044: using guessed type int dword_80F2044;
// 83E3540: using guessed type int dword_83E3540[];

//----- (080D4140) --------------------------------------------------------
_DWORD *__stdcall sub_80D4140(_DWORD *a1)
{
  int v1; // edx
  size_t size; // [esp+28h] [ebp-80h]
  _DWORD *sizea; // [esp+28h] [ebp-80h]
  char *dest; // [esp+2Ch] [ebp-7Ch]
  char *desta; // [esp+2Ch] [ebp-7Ch]
  int v7[8]; // [esp+30h] [ebp-78h] BYREF
  char v8[4]; // [esp+50h] [ebp-58h] BYREF
  void *src; // [esp+54h] [ebp-54h]
  size_t n; // [esp+5Ch] [ebp-4Ch]
  char *s; // [esp+7Ch] [ebp-2Ch]
  int v12[10]; // [esp+80h] [ebp-28h] BYREF

  if ( dword_80F2040 > dword_80F2044 )
    goto LABEL_2;
  sub_8084723();
  s = sub_80D36CA();
  if ( s )
  {
    size = strlen(s) + 1;
    dest = (char *)Z_MallocInternal(size);
    strcpy(dest, s);
    sub_80D4094(0, 5, 0, 0, size, (int)dest);
  }
  sub_8084719();
  MSG_Init(v8, (int)&unk_83E4D60, 0x4000);
  if ( sub_80D4BD8(v7, (int)v8) )
  {
    desta = (char *)(n + 20);
    sizea = Z_MallocInternal(n + 20);
    *sizea = v7[0];
    sizea[1] = v7[1];
    sizea[2] = v7[2];
    sizea[3] = v7[3];
    sizea[4] = v7[4];
    memcpy(sizea + 5, src, n);
    sub_80D4094(0, 6, 0, 0, (int)desta, (int)sizea);
  }
  if ( dword_80F2040 > dword_80F2044 )
  {
LABEL_2:
    v1 = 6 * (unsigned __int8)dword_80F2044++;
    *a1 = dword_83E3540[v1];
    a1[1] = dword_83E3544[v1];
    a1[2] = dword_83E3548[v1];
    a1[3] = dword_83E354C[v1];
    a1[4] = dword_83E3550[v1];
    a1[5] = dword_83E3554[v1];
  }
  else
  {
    memset(v12, 0, 0x18u);
    v12[0] = sub_80D563C();
    *a1 = v12[0];
    a1[1] = v12[1];
    a1[2] = v12[2];
    a1[3] = v12[3];
    a1[4] = v12[4];
    a1[5] = v12[5];
  }
  return a1;
}
// 80F2040: using guessed type int dword_80F2040;
// 80F2044: using guessed type int dword_80F2044;
// 83E3540: using guessed type int dword_83E3540[];
// 83E3544: using guessed type int dword_83E3544[];
// 83E3548: using guessed type int dword_83E3548[];
// 83E354C: using guessed type int dword_83E354C[];
// 83E3550: using guessed type int dword_83E3550[];
// 83E3554: using guessed type int dword_83E3554[];

//----- (080D43DB) --------------------------------------------------------
int __cdecl sub_80D43DB(char *s)
{
  int result; // eax

  if ( dword_80F1C28 )
    sub_80D30D9();
  result = fputs(s, stderr);
  if ( dword_80F1C28 )
    result = sub_80D3121();
  return result;
}
// 80F1C28: using guessed type int dword_80F1C28;

//----- (080D4413) --------------------------------------------------------
void sub_80D4413()
{
  ;
}

//----- (080D4425) --------------------------------------------------------
int __cdecl sub_80D4425(const char *a1)
{
  fprintf(stdout, "\n\n%s\n", "==============================================================");
  fprintf(stdout, "Linux Quake3 Dedicated Server [%s %s]\n", "Nov 15 2004", "10:34:36");
  fprintf(stdout, " local install: %s\n", a1);
  return fprintf(stdout, "%s\n\n", "==============================================================");
}

//----- (080D4551) --------------------------------------------------------
__pid_t __cdecl sub_80D4551(char *s)
{
  __pid_t result; // eax

  result = fork();
  if ( result != -1 && !result )
  {
    if ( strchr(s, 32) )
      system(s);
    else
      execl(s, s, 0);
    _exit(0);
  }
  return result;
}

//----- (080D45B9) --------------------------------------------------------
void __cdecl sub_80D45B9(char *src, int a2)
{
  if ( a2 )
  {
    Com_DPrintf("Sys_StartProcess %s (delaying to final exit)\n", src);
    Q_strncpyz(&byte_80F1C40, src, 1024);
    Cbuf_ExecuteText(2, "quit\n");
  }
  else
  {
    Com_DPrintf("Sys_StartProcess %s\n", src);
    sub_80D4551(src);
  }
}

//----- (080D4816) --------------------------------------------------------
void __cdecl sub_80D4816(int a1, const char **a2)
{
  if ( a1 == 2 && (!strcmp(a2[1], "--version") || !strcmp(a2[1], "-v")) )
  {
    sub_80D4425(*a2);
    sub_80D3311(0);
  }
}

//----- (080D4875) --------------------------------------------------------
void __cdecl __noreturn main(int a1, char **a2)
{
  void *v2; // esp
  __uid_t v3; // eax
  void *v4; // esp
  int v5; // eax
  char *dest; // [esp+Ch] [ebp-Ch] BYREF
  int i; // [esp+10h] [ebp-8h]
  int v8; // [esp+14h] [ebp-4h]

  v2 = alloca(0);
  dword_83E3524 = geteuid();
  v3 = getuid();
  seteuid(v3);
  sub_80D4816(a1, (const char **)a2);
  sub_80D5D82((char *)&byte_80E673F);
  v8 = 1;
  for ( i = 1; i < a1; ++i )
    v8 += strlen(a2[i]) + 1;
  v4 = alloca(16 * ((unsigned int)(v8 + 15) >> 4));
  dest = (char *)&dest;
  LOBYTE(dest) = 0;
  for ( i = 1; i < a1; ++i )
  {
    if ( i > 1 )
      strcat(dest, " ");
    strcat(dest, a2[i]);
  }
  memset(dword_83E3540, 0, 0x1800u);
  memset(&unk_83E4D60, 0, 0x4000u);
  Com_Init((int)dest);
  sub_80D52E0();
  sub_80D355B();
  v5 = fcntl(0, 3, 0);
  fcntl(0, 4, v5 | 0x800);
  sub_80C182C();
  while ( 1 )
  {
    sub_80D4413();
    usleep(0x1388u);
    sub_80717B0();
    sub_80C187A();
  }
}
// 83E3524: using guessed type int dword_83E3524;
// 83E3540: using guessed type int dword_83E3540[];

//----- (080D4A0C) --------------------------------------------------------
int __cdecl sub_80D4A0C(int a1, void *s)
{
  int result; // eax

  memset(s, 0, 0x10u);
  if ( *(_DWORD *)a1 == 3 )
  {
    *(_WORD *)s = 2;
    *((_WORD *)s + 1) = *(_WORD *)(a1 + 18);
    result = (int)s + 4;
    *((_DWORD *)s + 1) = -1;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)a1 == 4 )
    {
      *(_WORD *)s = 2;
      *((_DWORD *)s + 1) = *(_DWORD *)(a1 + 4);
      result = *(unsigned __int16 *)(a1 + 18);
      *((_WORD *)s + 1) = result;
    }
  }
  return result;
}

//----- (080D4A89) --------------------------------------------------------
int __cdecl sub_80D4A89(int a1, int a2)
{
  int result; // eax

  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_WORD *)(a2 + 18) = *(_WORD *)(a1 + 2);
  result = a2;
  *(_DWORD *)a2 = 4;
  return result;
}

//----- (080D4AFE) --------------------------------------------------------
int __cdecl sub_80D4AFE(char *cp, void *s)
{
  struct hostent *v4; // [esp+10h] [ebp-8h]

  memset(s, 0, 0x10u);
  *(_WORD *)s = 2;
  *((_WORD *)s + 1) = 0;
  if ( *cp > 47 && *cp <= 57 )
  {
    *((_DWORD *)s + 1) = inet_addr(cp);
    return 1;
  }
  v4 = gethostbyname(cp);
  if ( v4 )
  {
    *((_DWORD *)s + 1) = **(_DWORD **)v4->h_addr_list;
    return 1;
  }
  return 0;
}

//----- (080D4B95) --------------------------------------------------------
int __cdecl sub_80D4B95(char *cp, int a2)
{
  char s[24]; // [esp+20h] [ebp-18h] BYREF

  if ( !sub_80D4AFE(cp, s) )
    return 0;
  sub_80D4A89((int)s, a2);
  return 1;
}

//----- (080D4BD8) --------------------------------------------------------
int __cdecl sub_80D4BD8(int *a1, int a2)
{
  char v2; // al
  char v3; // al
  int v6; // [esp+30h] [ebp-38h]
  int i; // [esp+34h] [ebp-34h]
  int fd; // [esp+38h] [ebp-30h]
  socklen_t addr_len; // [esp+3Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+40h] [ebp-28h] BYREF
  ssize_t v11; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 1; ++i )
  {
    if ( i )
      fd = dword_83E8D60;
    else
      fd = dword_80F204C;
    if ( fd )
    {
      addr_len = 16;
      v11 = recvfrom(fd, *(void **)(a2 + 4), *(_DWORD *)(a2 + 8), 0, &addr, &addr_len);
      sub_80D4A89((int)&addr, (int)a1);
      *(_DWORD *)(a2 + 16) = 0;
      if ( v11 == -1 )
      {
        v6 = *__errno_location();
        if ( v6 != 11 && v6 != 111 )
        {
          NET_AdrToString(*a1, a1[1], a1[2], a1[3], a1[4]);
          v2 = (unsigned __int8)sub_80D552C();
          Com_Printf("NET_GetPacket: %s from %s\n", v2);
        }
      }
      else
      {
        if ( v11 != *(_DWORD *)(a2 + 8) )
        {
          *(_DWORD *)(a2 + 12) = v11;
          return 1;
        }
        v3 = (unsigned __int8)NET_AdrToString(*a1, a1[1], a1[2], a1[3], a1[4]);
        Com_Printf("Oversize packet from %s\n", v3);
      }
    }
  }
  return 0;
}
// 80F204C: using guessed type int dword_80F204C;
// 83E8D60: using guessed type int dword_83E8D60;

//----- (080D4D4B) --------------------------------------------------------
ssize_t __cdecl sub_80D4D4B(size_t n, void *buf, int a3, int a4, int a5, int a6, int a7)
{
  ssize_t result; // eax
  char v8; // al
  int fd; // [esp+2Ch] [ebp-2Ch]
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  ssize_t v11; // [esp+4Ch] [ebp-Ch]

  switch ( a3 )
  {
    case 3:
      result = dword_80F204C;
      fd = dword_80F204C;
      break;
    case 4:
      result = dword_80F204C;
      fd = dword_80F204C;
      break;
    case 5:
      result = dword_83E8D60;
      fd = dword_83E8D60;
      break;
    case 6:
      result = dword_83E8D60;
      fd = dword_83E8D60;
      break;
    default:
      Com_Error(0, "NET_SendPacket: bad address type");
  }
  if ( fd )
  {
    sub_80D4A0C((int)&a3, &addr);
    result = sendto(fd, buf, n, 0, &addr, 0x10u);
    v11 = result;
    if ( result == -1 )
    {
      NET_AdrToString(a3, a4, a5, a6, a7);
      v8 = (unsigned __int8)sub_80D552C();
      result = Com_Printf("NET_SendPacket ERROR: %s to %s\n", v8);
    }
  }
  return result;
}
// 80F204C: using guessed type int dword_80F204C;
// 83E8D60: using guessed type int dword_83E8D60;

//----- (080D4E49) --------------------------------------------------------
ssize_t __cdecl sub_80D4E49(char *cp, int a2, size_t n, void *buf)
{
  ssize_t result; // eax
  int v5[4]; // [esp+20h] [ebp-38h] BYREF
  int v6; // [esp+30h] [ebp-28h]
  uint16_t v7; // [esp+4Eh] [ebp-Ah]

  v7 = a2;
  v5[0] = 4;
  result = sub_80D4B95(cp, (int)v5);
  if ( result )
  {
    HIWORD(v6) = htons(v7);
    result = sub_80D4D4B(n, buf, v5[0], v5[1], v5[2], v5[3], v6);
  }
  return result;
}

//----- (080D4EBC) --------------------------------------------------------
int __cdecl Sys_IsLANAddress(int a1, int a2)
{
  int i; // [esp+4h] [ebp-4h]

  if ( a1 == 2 )
    return 1;
  if ( a1 == 5 )
    return 1;
  if ( a1 != 4 )
    return 0;
  if ( (_BYTE)a2 == 10 )
    return 1;
  if ( (_BYTE)a2 == 127 )
    return 1;
  if ( (_WORD)a2 == 0xFEA9 )
    return 1;
  if ( (_BYTE)a2 == 0xAC && (BYTE1(a2) & 0xF0) == 16 )
    return 1;
  if ( (_WORD)a2 == 0xA8C0 )
    return 1;
  for ( i = 0; i < dword_832FEC4; ++i )
  {
    if ( (_BYTE)a2 == byte_832FEE0[4 * i] && BYTE1(a2) == byte_832FEE1[4 * i] && BYTE2(a2) == byte_832FEE2[4 * i] )
      return 1;
  }
  return 0;
}
// 832FEC4: using guessed type int dword_832FEC4;

//----- (080D502D) --------------------------------------------------------
struct hostent *sub_80D502D()
{
  struct hostent *result; // eax
  uint32_t v1; // eax
  int v2; // [esp+20h] [ebp-118h]
  char *v3; // [esp+28h] [ebp-110h]
  char *v4; // [esp+28h] [ebp-110h]
  struct hostent *v5; // [esp+2Ch] [ebp-10Ch]
  char name[264]; // [esp+30h] [ebp-108h] BYREF

  result = (struct hostent *)gethostname(name, 0x100u);
  if ( result != (struct hostent *)-1 )
  {
    result = gethostbyname(name);
    v5 = result;
    if ( result )
    {
      Com_Printf("Hostname: %s\n", (char)result->h_name);
      v2 = 0;
      while ( 1 )
      {
        v3 = v5->h_aliases[v2++];
        if ( !v3 )
          break;
        Com_Printf("Alias: %s\n", (char)v3);
      }
      result = v5;
      if ( v5->h_addrtype == 2 )
      {
        dword_832FEC4 = 0;
        while ( 1 )
        {
          result = (struct hostent *)v5->h_addr_list[dword_832FEC4];
          v4 = (char *)result;
          ++dword_832FEC4;
          if ( !result || dword_832FEC4 > 15 )
            break;
          v1 = ntohl((uint32_t)result->h_name);
          byte_832FEE0[4 * dword_832FEC4] = *v4;
          byte_832FEE1[4 * dword_832FEC4] = v4[1];
          byte_832FEE2[4 * dword_832FEC4] = v4[2];
          byte_832FEE3[4 * dword_832FEC4] = v4[3];
          Com_Printf("IP: %i.%i.%i.%i\n", SHIBYTE(v1));
        }
      }
    }
  }
  return result;
}
// 832FEC4: using guessed type int dword_832FEC4;

//----- (080D51FD) --------------------------------------------------------
struct hostent *sub_80D51FD()
{
  char *v0; // eax
  float v2; // [esp+4h] [ebp-24h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]
  int *v5; // [esp+24h] [ebp-4h]

  v5 = Cvar_Get("net_ip", "localhost", 0);
  v0 = va("%i", 28960);
  v4 = (int)*((float *)Cvar_Get("net_port", v0, 0) + 7);
  for ( i = 0; ; ++i )
  {
    if ( i > 9 )
      Com_Error(0, "Couldn't allocate IP port");
    dword_80F204C = sub_80D532E((char *)v5[1], v4 + i);
    if ( dword_80F204C )
      break;
  }
  v2 = (float)(v4 + i);
  sub_807317F("net_port", v2);
  return sub_80D502D();
}
// 80F204C: using guessed type int dword_80F204C;

//----- (080D52E0) --------------------------------------------------------
void sub_80D52E0()
{
  dword_832FEC0 = (int)Cvar_Get("net_noudp", "0", 0);
  if ( *(float *)(dword_832FEC0 + 28) == 0.0 && !dword_80F204C )
    sub_80D51FD();
}
// 80F204C: using guessed type int dword_80F204C;
// 832FEC0: using guessed type int dword_832FEC0;

//----- (080D532E) --------------------------------------------------------
int __cdecl sub_80D532E(char *cp, int a2)
{
  char v2; // al
  char v3; // al
  char v4; // al
  char v5; // al
  int v7; // [esp+24h] [ebp-34h]
  int optval; // [esp+28h] [ebp-30h] BYREF
  int v9; // [esp+2Ch] [ebp-2Ch] BYREF
  struct sockaddr addr; // [esp+30h] [ebp-28h] BYREF
  int fd; // [esp+4Ch] [ebp-Ch]

  v9 = 1;
  optval = 1;
  if ( cp )
    Com_Printf("Opening IP socket: %s:%i\n", (char)cp);
  else
    Com_Printf("Opening IP socket: localhost:%i\n", a2);
  fd = socket(2, 2, 17);
  if ( fd == -1 )
  {
    v2 = (unsigned __int8)sub_80D552C();
    Com_Printf("ERROR: UDP_OpenSocket: socket: %s", v2);
    v7 = 0;
  }
  else if ( ioctl(fd, 0x5421u, &v9) == -1 )
  {
    v3 = (unsigned __int8)sub_80D552C();
    Com_Printf("ERROR: UDP_OpenSocket: ioctl FIONBIO:%s\n", v3);
    v7 = 0;
  }
  else if ( setsockopt(fd, 1, 6, &optval, 4u) == -1 )
  {
    v4 = (unsigned __int8)sub_80D552C();
    Com_Printf("ERROR: UDP_OpenSocket: setsockopt SO_BROADCAST:%s\n", v4);
    v7 = 0;
  }
  else
  {
    if ( cp && *cp && Q_stricmp(cp, "localhost") )
      sub_80D4AFE(cp, &addr);
    else
      *(_DWORD *)&addr.sa_data[2] = 0;
    if ( a2 == -1 )
      *(_WORD *)addr.sa_data = 0;
    else
      *(_WORD *)addr.sa_data = htons(a2);
    addr.sa_family = 2;
    if ( bind(fd, &addr, 0x10u) == -1 )
    {
      v5 = (unsigned __int8)sub_80D552C();
      Com_Printf("ERROR: UDP_OpenSocket: bind: %s\n", v5);
      close(fd);
      v7 = 0;
    }
    else
    {
      v7 = fd;
    }
  }
  return v7;
}

//----- (080D552C) --------------------------------------------------------
char *sub_80D552C()
{
  int *v0; // eax

  v0 = __errno_location();
  return strerror(*v0);
}

//----- (080D5549) --------------------------------------------------------
int __cdecl sub_80D5549(int a1)
{
  int result; // eax
  fd_set readfds; // [esp+30h] [ebp-98h] BYREF
  struct timeval timeout; // [esp+B8h] [ebp-10h] BYREF

  if ( dword_80F204C )
  {
    result = dword_835F480;
    if ( *(_DWORD *)(dword_835F480 + 32) )
    {
      memset(&readfds, 0, sizeof(readfds));
      if ( dword_80F1C20 )
        readfds.__fds_bits[0] |= 1u;
      _bittestandset(&readfds.__fds_bits[(unsigned int)dword_80F204C >> 5], dword_80F204C & 0x1F);
      timeout.tv_sec = a1 / 1000;
      timeout.tv_usec = 1000 * (a1 % 1000);
      result = select(dword_80F204C + 1, &readfds, 0, 0, &timeout);
    }
  }
  return result;
}
// 80F1C20: using guessed type int dword_80F1C20;
// 80F204C: using guessed type int dword_80F204C;
// 835F480: using guessed type int dword_835F480;

//----- (080D563C) --------------------------------------------------------
int sub_80D563C()
{
  int v1; // [esp+Ch] [ebp-1Ch]
  struct timezone tz; // [esp+10h] [ebp-18h] BYREF
  struct timeval tv; // [esp+18h] [ebp-10h] BYREF

  gettimeofday(&tv, &tz);
  if ( dword_83E8D78 )
  {
    dword_83E8D7C = tv.tv_usec / 1000 + 1000 * (tv.tv_sec - dword_83E8D78);
    v1 = dword_83E8D7C;
  }
  else
  {
    dword_83E8D78 = tv.tv_sec;
    v1 = tv.tv_usec / 1000;
  }
  return v1;
}
// 83E8D78: using guessed type int dword_83E8D78;
// 83E8D7C: using guessed type int dword_83E8D7C;

//----- (080D56C3) --------------------------------------------------------
int __cdecl sub_80D56C3(char *path)
{
  return mkdir(path, 0x1FFu);
}

//----- (080D56DE) --------------------------------------------------------
DIR *__cdecl sub_80D56DE(const char *a1, const char *a2, int a3, int a4, int *a5)
{
  DIR *result; // eax
  struct stat stat_buf; // [esp+20h] [ebp-378h] BYREF
  struct dirent *v7; // [esp+88h] [ebp-310h]
  DIR *dirp; // [esp+8Ch] [ebp-30Ch]
  char s[256]; // [esp+90h] [ebp-308h] BYREF
  char v10[256]; // [esp+190h] [ebp-208h] BYREF
  char name[264]; // [esp+290h] [ebp-108h] BYREF

  result = (DIR *)a5;
  if ( *a5 <= 4094 )
  {
    if ( *a2 )
      Com_sprintf(name, 0x100u, "%s/%s", a1, a2);
    else
      Com_sprintf(name, 0x100u, "%s", a1);
    result = opendir(name);
    dirp = result;
    if ( result )
    {
      while ( 1 )
      {
        v7 = readdir(dirp);
        if ( !v7 )
          break;
        Com_sprintf(s, 0x100u, "%s/%s", name, v7->d_name);
        if ( sub_80D61E8(s, &stat_buf) != -1 )
        {
          if ( (stat_buf.st_mode & 0x4000) != 0 && Q_stricmp(v7->d_name, ".") && Q_stricmp(v7->d_name, "..") )
          {
            if ( *a2 )
              Com_sprintf(v10, 0x100u, "%s/%s", a2, v7->d_name);
            else
              Com_sprintf(v10, 0x100u, "%s", v7->d_name);
            sub_80D56DE((char)a1, (char)v10, a3, a4, a5);
          }
          if ( *a5 > 4094 )
            break;
          Com_sprintf(s, 0x100u, "%s/%s", a2, v7->d_name);
          if ( ((int (__cdecl *)(int, char *, _DWORD))sub_806B9BA)(a3, s, 0) )
            *(_DWORD *)(a4 + 4 * (*a5)++) = sub_806BC0A(s);
        }
      }
      result = (DIR *)closedir(dirp);
    }
  }
  return result;
}
// 806B9BA: using guessed type int sub_806B9BA();

//----- (080D5975) --------------------------------------------------------
void *__cdecl sub_80D5975(char *name, char *s, int a3, int a4, int a5)
{
  size_t v5; // ebx
  size_t v6; // eax
  char *v7; // ebx
  size_t v8; // eax
  int v9; // ebx
  void *v11; // [esp+28h] [ebp-41A0h]
  struct stat stat_buf; // [esp+30h] [ebp-4198h] BYREF
  int i; // [esp+9Ch] [ebp-412Ch]
  int v14[4098]; // [esp+A0h] [ebp-4128h] BYREF
  _DWORD *v15; // [esp+40A8h] [ebp-120h]
  int v16; // [esp+40ACh] [ebp-11Ch] BYREF
  char filename[260]; // [esp+40B0h] [ebp-118h] BYREF
  int v18; // [esp+41B4h] [ebp-14h]
  DIR *dirp; // [esp+41B8h] [ebp-10h]
  struct dirent *v20; // [esp+41BCh] [ebp-Ch]

  v18 = a5;
  if ( a3 )
  {
    v16 = 0;
    sub_80D56DE(name, (const char *)&unk_80E69EE, a3, (int)v14, &v16);
    v14[v16] = 0;
    *(_DWORD *)a4 = v16;
    if ( v16 )
    {
      v15 = Z_MallocInternal(4 * v16 + 4);
      for ( i = 0; i < v16; ++i )
        v15[i] = v14[i];
      v15[i] = 0;
      v11 = v15;
    }
    else
    {
      v11 = 0;
    }
  }
  else
  {
    if ( !s )
      s = (char *)&unk_80E69EE;
    if ( *s == 47 && !s[1] )
    {
      s = (char *)&unk_80E69EE;
      v18 = 1;
    }
    strlen(s);
    v16 = 0;
    dirp = opendir(name);
    if ( dirp )
    {
      while ( 1 )
      {
        v20 = readdir(dirp);
        if ( !v20 )
          break;
        Com_sprintf(filename, 0x100u, "%s/%s", name, v20->d_name);
        if ( sub_80D61E8(filename, &stat_buf) != -1
          && (!v18 || (stat_buf.st_mode & 0x4000) != 0)
          && (v18 || (stat_buf.st_mode & 0x4000) == 0) )
        {
          if ( !*s
            || (v5 = strlen(v20->d_name), v5 >= strlen(s))
            && (v6 = strlen(v20->d_name), v7 = (char *)v20 + v6, v8 = strlen(s), !Q_stricmp(&v7[-v8 + 11], s)) )
          {
            if ( v16 == 4095 )
              break;
            v9 = v16;
            v14[v9] = (int)sub_806BC0A(v20->d_name);
            ++v16;
          }
        }
      }
      v14[v16] = 0;
      closedir(dirp);
      *(_DWORD *)a4 = v16;
      if ( v16 )
      {
        v15 = Z_MallocInternal(4 * v16 + 4);
        for ( i = 0; i < v16; ++i )
          v15[i] = v14[i];
        v15[i] = 0;
        v11 = v15;
      }
      else
      {
        v11 = 0;
      }
    }
    else
    {
      *(_DWORD *)a4 = 0;
      v11 = 0;
    }
  }
  return v11;
}

//----- (080D5D04) --------------------------------------------------------
int __cdecl sub_80D5D04(void *ptr)
{
  int result; // eax
  int i; // [esp+4h] [ebp-4h]

  if ( ptr )
  {
    for ( i = 0; *((_DWORD *)ptr + i); ++i )
      Z_FreeInternal(*((void **)ptr + i));
    result = Z_FreeInternal(ptr);
  }
  return result;
}

//----- (080D5D5A) --------------------------------------------------------
char *sub_80D5D5A()
{
  getcwd(byte_832FF20, 0xFFu);
  byte_833001F = 0;
  return byte_832FF20;
}
// 833001F: using guessed type char byte_833001F;

//----- (080D5D82) --------------------------------------------------------
char *__cdecl sub_80D5D82(char *src)
{
  return Q_strncpyz(byte_8330020, src, 256);
}

//----- (080D5DA5) --------------------------------------------------------
char *sub_80D5DA5()
{
  return byte_8330020;
}

//----- (080D5DF7) --------------------------------------------------------
char *sub_80D5DF7()
{
  char *v1; // [esp+4h] [ebp-4h]

  if ( byte_8330120 )
    v1 = &byte_8330120;
  else
    v1 = sub_80D5D5A();
  return v1;
}
// 8330120: using guessed type char byte_8330120;

//----- (080D5E3F) --------------------------------------------------------
char *sub_80D5E3F()
{
  int *v0; // ebx
  int *v1; // eax
  char *v2; // eax
  char *src; // [esp+20h] [ebp-8h]

  if ( path )
    return &path;
  src = getenv("HOME");
  if ( !src )
    return (char *)&unk_80E69EE;
  Q_strncpyz(&path, src, 256);
  sub_8086023(&path, 256, "/.callofduty");
  if ( mkdir(&path, 0x1FFu) && *__errno_location() != 17 )
  {
    v0 = __errno_location();
    v1 = __errno_location();
    v2 = strerror(*v1);
    Sys_Error("Unable to create directory \"%s\", error is %s(%d)\n", &path, v2, *v0);
  }
  return &path;
}

//----- (080D5F30) --------------------------------------------------------
void Sys_ShowConsole()
{
  ;
}

//----- (080D5F35) --------------------------------------------------------
const char *sub_80D5F35()
{
  __uid_t v0; // eax
  const char *v2; // [esp+10h] [ebp-8h]
  struct passwd *v3; // [esp+14h] [ebp-4h]

  v0 = getuid();
  v3 = getpwuid(v0);
  if ( v3 )
    v2 = v3->pw_name;
  else
    v2 = "player";
  return v2;
}

//----- (080D5F94) --------------------------------------------------------
int __cdecl sub_80D5F94(float *a1, float *a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst6
  long double v5; // fst5
  long double v6; // fst7
  long double v7; // fst6

  if ( *(char *)(a3 + 17) >= 8 )
    return MEMORY[1];
  v3 = *(float *)a3;
  v4 = v3;
  switch ( *(_BYTE *)(a3 + 17) )
  {
    case 0:
      v5 = *(float *)(a3 + 4) * a1[1] + v3 * *a1;
      v6 = *(float *)(a3 + 8) * a1[2];
      v7 = v4 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
      break;
    case 1:
      v5 = *(float *)(a3 + 4) * a1[1] + v3 * *a2;
      v6 = *(float *)(a3 + 8) * a1[2];
      v7 = v4 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a2[2];
      break;
    case 2:
      v5 = *(float *)(a3 + 4) * a2[1] + v3 * *a1;
      v6 = *(float *)(a3 + 8) * a1[2];
      v7 = v4 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
      break;
    case 3:
      v5 = *(float *)(a3 + 4) * a2[1] + v3 * *a2;
      v6 = *(float *)(a3 + 8) * a1[2];
      v7 = v4 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a2[2];
      break;
    case 4:
      v5 = *(float *)(a3 + 4) * a1[1] + v3 * *a1;
      v6 = *(float *)(a3 + 8) * a2[2];
      v7 = v4 * *a2 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
      break;
    case 5:
      v5 = *(float *)(a3 + 4) * a1[1] + v3 * *a2;
      v6 = *(float *)(a3 + 8) * a2[2];
      v7 = v4 * *a1 + *(float *)(a3 + 4) * a2[1] + *(float *)(a3 + 8) * a1[2];
      break;
    case 6:
      v5 = *(float *)(a3 + 4) * a2[1] + v3 * *a1;
      v6 = *(float *)(a3 + 8) * a2[2];
      v7 = v4 * *a2 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
      break;
    case 7:
      v5 = *(float *)(a3 + 4) * a2[1] + v3 * *a2;
      v6 = *(float *)(a3 + 8) * a2[2];
      v7 = v4 * *a1 + *(float *)(a3 + 4) * a1[1] + *(float *)(a3 + 8) * a1[2];
      break;
  }
  return (unsigned __int8)(2 * (v6 + v5 < *(float *)(a3 + 12)) + (v7 >= *(float *)(a3 + 12)));
}

//----- (080D6170) --------------------------------------------------------
void __cdecl sub_80D6170(float *a1)
{
  *(_DWORD *)a1 = (int)*a1;
  *a1 = (float)*(int *)a1;
  *((_DWORD *)a1 + 1) = (int)a1[1];
  a1[1] = (float)*((int *)a1 + 1);
  *((_DWORD *)a1 + 2) = (int)a1[2];
  a1[2] = (float)*((int *)a1 + 2);
}

//----- (080D61E8) --------------------------------------------------------
int __cdecl sub_80D61E8(char *filename, struct stat *stat_buf)
{
  return __xstat(3, filename, stat_buf);
}

//----- (080D6210) --------------------------------------------------------
int sub_80D6210()
{
  void (__cdecl *v0)(); // eax
  void (__cdecl **v1)(); // ebx
  int v3; // [esp+0h] [ebp-8h]

  v0 = (void (__cdecl *)())off_80F6324;
  v1 = (void (__cdecl **)())&off_80F6324;
  if ( off_80F6324 != (int (*)())-1 )
  {
    do
    {
      --v1;
      v0();
      v0 = *v1;
    }
    while ( *v1 != (void (__cdecl *)())-1 );
  }
  return v3;
}
// 80D623C: variable 'v3' is possibly undefined
// 80F6324: using guessed type int (*off_80F6324)();

//----- (080D6240) --------------------------------------------------------
void term_proc(void)
{
  sub_8049EF0();
}

// nfuncs=2113 queued=1869 decompiled=1869 lumina nreq=0 worse=0 better=0
#error "There were 2 decompilation failure(s) on 1869 function(s)"
