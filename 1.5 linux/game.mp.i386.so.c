/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <math.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void (*init_proc())(void);
void sub_12E30();
int GScr_AddFieldsForHudElems(void); // weak
_DWORD __cdecl trap_DObjCreateSkelForBones(_DWORD, _DWORD); // weak
int __cdecl G_SpawnFloat(char *s1, int, int); // idb
int G_Spawn(void); // weak
double __cdecl BG_GetMinSpreadForWeapon(_DWORD, _DWORD, _DWORD); // weak
int __cdecl BG_CalculateWeaponPosition_Sway(int, int, int, int, float, int); // idb
_DWORD __cdecl Scr_AddFields(_DWORD, _DWORD); // weak
_DWORD __cdecl irand(_DWORD, _DWORD); // weak
_DWORD __cdecl GScr_GetHeadIconIndex(char); // weak
int G_SetUICvars(void); // weak
_DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl turret_think_client(_DWORD); // weak
_DWORD __cdecl G_EntLinkTo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetAmmoTypeMax(_DWORD); // weak
_DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD); // weak
_DWORD __cdecl Q_isalphanumeric(_DWORD); // weak
_DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int GScr_FreeScripts(void); // weak
// double cos(double x);
_DWORD __cdecl trap_XAnimSetCompleteGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
long double __cdecl vectoyaw(_DWORD); // weak
int PM_InteruptWeaponWithProneMove(void); // weak
_DWORD __cdecl ClientUserinfoChanged(_DWORD); // weak
_DWORD __cdecl weapon_grenadelauncher_fire(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetStackSlotForWeapon(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Error(_DWORD); // weak
_DWORD __cdecl MatrixInverseOrthogonal43(_DWORD, _DWORD); // weak
int PM_SetProneMovementOverride(void); // weak
_DWORD __cdecl BG_GetAmmoClipSize(_DWORD); // weak
_DWORD __cdecl ClientEvents(_DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjUpdateServerTime(_DWORD, _DWORD); // weak
int PM_UpdatePlayerWalkingFlag(void); // weak
_DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD); // weak
_DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD); // weak
_DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD); // weak
_DWORD __cdecl Weapon_Melee(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FarHook(_DWORD); // weak
_DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnims(_DWORD); // weak
int BG_SetupAmmoIndexes(void); // weak
_DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD); // weak
_DWORD __cdecl Com_Parse(_DWORD); // weak
_DWORD __cdecl Cmd_MatchTimeout_f(_DWORD); // weak
_DWORD __cdecl G_EntDetachAll(_DWORD); // weak
// char *strncat(char *dest, const char *src, size_t n);
int __cdecl Bullet_Endpos(float, int, int); // idb
// int vsprintf(char *s, const char *format, __gnuc_va_list arg);
// char *strchr(const char *s, int c);
int __cdecl G_FreeEntity(void *s); // idb
_DWORD __cdecl Cmd_Where_f(_DWORD); // weak
_DWORD __cdecl Scr_FreeScripts(_DWORD); // weak
long double __cdecl vectopitch(_DWORD); // weak
int __cdecl BG_AnimationIndexForString(char *src); // idb
_DWORD __cdecl AxisToAngles(_DWORD, _DWORD); // weak
_DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerDisconnect(_DWORD); // weak
_DWORD __cdecl Concussive_fx(_DWORD); // weak
int ConsoleCommand(void); // weak
_DWORD __cdecl BG_IsProneAnim(_DWORD, _DWORD); // weak
int __cdecl Q_strncpyz(char *dest, char *src, int); // idb
_DWORD __cdecl PM_UpdateViewAngles(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetIString(_DWORD); // weak
int __cdecl G_EntAttach(int, char *s2, int, int); // idb
int __cdecl G_RadiusDamage(int, int, int, float, float, float, int, int); // idb
double __cdecl BG_GetBobCycle(_DWORD); // weak
// double atan(double x);
_DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_DebugArc(int, float, float, float, int, int, int); // idb
_DWORD __cdecl BG_WeaponIsClipOnly(_DWORD); // weak
_DWORD __cdecl Respond_trigger_damage(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(_DWORD, __int16, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_Error(_DWORD); // weak
_DWORD __cdecl ClientInactivityTimer(_DWORD); // weak
_DWORD __cdecl trap_GetGuid(_DWORD); // weak
_DWORD __cdecl Q_CleanStr(_DWORD); // weak
int __cdecl Scr_LocalizationError(int, char *format); // idb
_DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD); // weak
int CalculateRanks(void); // weak
_DWORD __cdecl PM_FootstepEvent(char, char, _DWORD); // weak
_DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_CalcTagAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl G_TransposeMatrix(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_Score_f(_DWORD); // weak
int Scr_BeginLoadScripts(void); // weak
_DWORD __cdecl G_SetAngle(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntityField(_DWORD, _DWORD); // weak
int Scr_RemoveClassMap(void); // weak
_DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl GScr_AddVector(_DWORD); // weak
_DWORD __cdecl BG_AnimUpdatePlayerStateConditions(_DWORD); // weak
int G_InitTurrets(void); // weak
int __cdecl Bullet_Fire(int, float, int, int, int); // idb
_DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_EntDetach(int, char *s2, int); // idb
_DWORD __cdecl InitMoverRotate(_DWORD); // weak
int CheckVote(void); // weak
_DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_GetEffectiveStance(_DWORD); // weak
_DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_Say(int, int, int, char *src); // idb
_DWORD __cdecl BG_PlayerTouchesItem(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjCalcPose(_DWORD); // weak
_DWORD __cdecl G_ClientStopUsingTurret(_DWORD); // weak
_DWORD __cdecl FireWeaponMelee(_DWORD); // weak
int __cdecl G_DPrintf(char *format, char); // idb
int __cdecl Com_Printf(char *format, char); // idb
int Scr_LoadLevel(void); // weak
_DWORD __cdecl PM_UpdateLean(_DWORD, _DWORD, _DWORD); // weak
int BG_LoadAnimTreeInstances(void); // weak
int __cdecl BG_LerpOffset(int, float, int); // idb
_DWORD __cdecl trap_GetServerinfo(_DWORD, _DWORD); // weak
int __cdecl G_ModelIndex(char *s2); // idb
// int strcmp(const char *s1, const char *s2);
int ExitLevel(void); // weak
_DWORD __cdecl PM_WeaponUseAmmo(_DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char); // weak
int __cdecl Info_RemoveKey(char *s, char *s1); // idb
_DWORD __cdecl Scr_PlayerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_IsCrouchingAnim(_DWORD, _DWORD); // weak
// double asin(double x);
_DWORD __cdecl DObjSkelMatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeHudElemConstStrings(_DWORD); // weak
int __cdecl Info_ValueForKey(char *s, int); // idb
int Scr_EndLoadAnimTrees(void); // weak
int GScr_AddFieldsForEntity(void); // weak
_DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD); // weak
_DWORD __cdecl InitSentientTrigger(_DWORD); // weak
_DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD); // weak
_DWORD __cdecl LaunchItem(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_GetHitLocationIndexFromString(_DWORD); // weak
_DWORD __cdecl Com_Parse1DMatrix(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_SetModel(int, char *s2); // idb
int Scr_AddUndefined(void); // weak
_DWORD __cdecl Q_CleanCharacter(_DWORD); // weak
_DWORD __cdecl trap_GetEntityToken(_DWORD, _DWORD); // weak
int __cdecl Info_Validate(char *s); // idb
_DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl MT_Free(_DWORD, _DWORD); // weak
int trap_AddTestClient(void); // weak
_DWORD __cdecl G_UpdateTagInfoOfChildren(_DWORD, _DWORD); // weak
int __cdecl G_RunMissile(void *s); // idb
_DWORD __cdecl trap_Printf(_DWORD); // weak
_DWORD __cdecl RegisterItem(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetType(_DWORD); // weak
_DWORD __cdecl Cmd_GameCommand_f(_DWORD); // weak
_DWORD __cdecl Cmd_CallVote_f(_DWORD); // weak
int BG_SetupWeaponInfo(void); // weak
_DWORD __cdecl G_CheckForCursorHints(_DWORD); // weak
// int __cdecl __cxa_finalize(void *);
_DWORD __cdecl trap_XAnimClearTreeGoalWeightsStrict(_DWORD, __int16, _DWORD); // weak
_DWORD __cdecl trap_GetClientPing(_DWORD); // weak
int __cdecl VectorAngleMultiply(int, float); // idb
_DWORD __cdecl IsItemRegistered(_DWORD); // weak
int Svcmd_RemoveIP_f(void); // weak
int GScr_LoadGameTypeScript(void); // weak
_DWORD __cdecl G_SetConstString(_DWORD, _DWORD); // weak
_DWORD __cdecl OnSameTeam(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntity(_DWORD); // weak
int BG_GetNumWeapons(void); // weak
_DWORD __cdecl Scr_FreeHudElem(_DWORD); // weak
int BG_FinalizePlayerAnims(void); // weak
int __cdecl AngleNormalize360Accurate(float); // idb
_DWORD __cdecl G_DObjUpdate(_DWORD); // weak
int __cdecl Com_DPrintf(char *format, char); // idb
_DWORD __cdecl Cmd_UFO_f(_DWORD); // weak
_DWORD __cdecl SpectatorThink(_DWORD, _DWORD); // weak
int __cdecl Blocked_DoorRotate(int, void *s); // idb
int trap_Milliseconds(void); // weak
_DWORD __cdecl ClientThink_real(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Com_SkipPath(_DWORD); // weak
_DWORD __cdecl G_ModelName(_DWORD); // weak
_DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD); // weak
int __cdecl YawToAxis(float, int); // idb
_DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int CheckMatchTimeout(void); // weak
long double __cdecl VectorNormalize(_DWORD); // weak
_DWORD __cdecl Scr_AddConstString(_DWORD); // weak
int BG_FillInWeaponItems(void); // weak
// int vsnprintf(char *s, size_t maxlen, const char *format, __gnuc_va_list arg);
_DWORD __cdecl Com_BitCheck(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjExists(_DWORD); // weak
_DWORD __cdecl GScr_SetDynamicEntityField(_DWORD, _DWORD); // weak
_DWORD __cdecl QuatInverse(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int PM_UpdateAimDownSightFlag(void); // weak
int __cdecl BG_AnimParseError(char *format, char); // idb
_DWORD __cdecl G_FreeTurret(_DWORD); // weak
int DebugDumpAnims(void); // weak
_DWORD __cdecl BG_FindItem(_DWORD); // weak
_DWORD __cdecl Cmd_God_f(_DWORD); // weak
_DWORD __cdecl PM_WeaponClipEmpty(_DWORD); // weak
_DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl DObjSkel2MatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl IntermissionClientEndFrame(_DWORD); // weak
int G_UpdateHudElemsToClients(void); // weak
int G_CallSpawn(void); // weak
int __cdecl BG_GetHorizontalBobFactor(int, float, float, float); // idb
_DWORD __cdecl G_RunMover(_DWORD); // weak
_DWORD __cdecl HudElem_GetMethod(_DWORD); // weak
// int __cdecl __deregister_frame_info_bases(_DWORD); weak
_DWORD __cdecl trap_XAnimCreateTree(_DWORD); // weak
_DWORD __cdecl trap_FS_FCloseFile(_DWORD); // weak
_DWORD __cdecl Cmd_Kill_f(_DWORD); // weak
_DWORD __cdecl Scr_FindField(_DWORD, _DWORD); // weak
_DWORD __cdecl StopFollowing(_DWORD); // weak
// double pow(double x, double y);
int SendScoreboardMessageToAllIntermissionClients(void); // weak
_DWORD __cdecl Scr_LoadScript(_DWORD); // weak
_DWORD __cdecl G_TryPushingEntity(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Cvar_Update(_DWORD); // weak
int __cdecl Com_ScriptWarning(char *format, char); // idb
_DWORD __cdecl Scr_GetVector(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_WeaponFireRecoil(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_isnumeric(_DWORD); // weak
_DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetInfoForWeapon(_DWORD); // weak
_DWORD __cdecl Scr_GetDebugString(_DWORD); // weak
_DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD); // weak
int Scr_AddArray(void); // weak
_DWORD __cdecl vtos(_DWORD); // weak
int G_SetPlayerSize(void); // weak
// int tolower(int c);
_DWORD __cdecl Q_rand(_DWORD); // weak
_DWORD __cdecl SL_GetString(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_LinkEntity(_DWORD); // weak
_DWORD __cdecl G_SafeDObjFree(_DWORD); // weak
_DWORD __cdecl G_Voice(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_IsSystemActive(_DWORD); // weak
_DWORD __cdecl G_SpawnItem(_DWORD, _DWORD); // weak
_DWORD __cdecl Q_isalpha(_DWORD); // weak
int __cdecl BG_CheckProne(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float); // idb
_DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCreateSkelForBone(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl InitTrigger(_DWORD); // weak
int __cdecl G_SpawnVector(char *s1, int, int); // idb
_DWORD __cdecl VectorNormalize2D(_DWORD); // weak
int __cdecl G_ShaderIndex(char *s2); // idb
_DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl PM_ClipVelocity(int, int, int, float); // idb
int __cdecl Blocked_Door(int, void *s); // idb
_DWORD __cdecl Cmd_Give_f(_DWORD); // weak
int G_FindTeams(void); // weak
_DWORD __cdecl InSameSquad(_DWORD, _DWORD); // weak
_DWORD __cdecl ColorIndex(_DWORD); // weak
_DWORD __cdecl Cmd_MatchTimein_f(_DWORD); // weak
_DWORD __cdecl Scr_AddInt(_DWORD); // weak
_DWORD __cdecl G_Trigger(_DWORD, _DWORD); // weak
_DWORD __cdecl ClientDisconnect(_DWORD); // weak
int __cdecl G_ShellShockIndex(char *s2); // idb
_DWORD __cdecl trap_DObjInitServerTime(_DWORD, _DWORD); // weak
int SP_worldspawn(void); // weak
_DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetAnimsIndex(_DWORD); // weak
int __cdecl BG_CheckProneValid(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float); // idb
_DWORD __cdecl PM_AddEvent(_DWORD); // weak
_DWORD __cdecl Pmove(_DWORD); // weak
_DWORD __cdecl MatchTeamReverseAngleOnSlaves(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl SL_FindLowercaseString(_DWORD); // weak
_DWORD __cdecl G_GetHitLocationString(_DWORD); // weak
_DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD); // weak
int PM_ClearAimDownSightFlag(void); // weak
_DWORD __cdecl Scr_NotifyNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_strncasecmp(_DWORD, _DWORD, _DWORD); // weak
int PM_Weapon(void); // weak
_DWORD __cdecl G_AddPredictableEvent(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_SetViewpos_f(_DWORD); // weak
_DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD); // weak
int G_ParseSpawnVars(void); // weak
_DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XModelDebugBoxes(_DWORD); // weak
_DWORD __cdecl ClientThink(_DWORD); // weak
int G_ParseHitLocDmgTable(void); // weak
int __cdecl G_SpawnInt(char *s1, int, int); // idb
_DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl InitMover(_DWORD); // weak
_DWORD __cdecl trap_GetWeaponInfoMemory(_DWORD, _DWORD); // weak
int __cdecl AddLeanToPosition(int, int, float, float, float); // idb
int GScr_LoadScripts(void); // weak
int Com_EndParseSession(void); // weak
_DWORD __cdecl Cmd_Noclip_f(_DWORD); // weak
int __cdecl AngleDelta(float, float); // idb
_DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_CalculateWeaponAngles(_DWORD, _DWORD); // weak
int __cdecl Weapon_RocketLauncher_Fire(int, float, int); // idb
_DWORD __cdecl Scr_FreeEntity(_DWORD); // weak
_DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD); // weak
_DWORD __cdecl G_BounceMissile(_DWORD, _DWORD); // weak
_DWORD __cdecl G_GetGameId(_DWORD); // weak
_DWORD __cdecl Rand_Init(_DWORD); // weak
long double __cdecl Scr_GetFloat(_DWORD); // weak
_DWORD __cdecl BG_CalculateViewAngles(_DWORD, _DWORD); // weak
int __cdecl va(char *format, char); // idb
_DWORD __cdecl Q_islower(_DWORD); // weak
_DWORD __cdecl G_CheckForPreventFriendlyFire(_DWORD); // weak
_DWORD __cdecl DirToByte(_DWORD); // weak
_DWORD __cdecl multi_trigger(_DWORD, _DWORD); // weak
int __cdecl G_LogPrintf(char *format, char); // idb
_DWORD __cdecl LookAtKiller(_DWORD, _DWORD, _DWORD); // weak
int GScr_AddFieldsForRadiant(void); // weak
_DWORD __cdecl Scr_AddFloat(_DWORD); // weak
_DWORD __cdecl trap_DropClient(_DWORD, _DWORD); // weak
int __cdecl G_SoundAliasIndex(char *s2); // idb
_DWORD __cdecl CheatsOk(_DWORD); // weak
_DWORD __cdecl Scr_GetBool(_DWORD); // weak
long double __cdecl trap_XAnimGetWeight(_DWORD, __int16); // weak
_DWORD __cdecl Scr_ShutdownSystem(_DWORD); // weak
_DWORD __cdecl G_RunThink(_DWORD); // weak
int G_FreeEntities(void); // weak
_DWORD __cdecl gunrandom(_DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileImpact(_DWORD, _DWORD); // weak
_DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetEntityField(_DWORD, _DWORD); // weak
int CheckTeamStatus(void); // weak
_DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD); // weak
double __cdecl vectosignedyaw(_DWORD); // weak
_DWORD __cdecl Scr_ParamError(_DWORD, _DWORD); // weak
int __cdecl flrand(float, float); // idb
_DWORD __cdecl BG_ParseCommands(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl TeamplayInfoMessage(_DWORD); // weak
_DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD); // weak
int __cdecl Q_strcat(char *s, int, char *src); // idb
_DWORD __cdecl SL_ConvertToString(_DWORD); // weak
_DWORD __cdecl Scr_GetInt(_DWORD); // weak
_DWORD __cdecl Scr_GetPointerType(_DWORD); // weak
int __cdecl G_EffectIndex(char *s2); // idb
int Svcmd_AddIP_f(void); // weak
_DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_AddSpawnVarToken(char *s); // idb
int Scr_ParseGameTypeList(void); // weak
int __cdecl AngleSubtract(float, float); // idb
_DWORD __cdecl Scr_SetClassMap(_DWORD, _DWORD); // weak
_DWORD __cdecl G_InitGentity(_DWORD); // weak
_DWORD __cdecl trap_UnlinkEntity(_DWORD); // weak
_DWORD __cdecl PmoveSingle(_DWORD); // weak
int trap_Argc(void); // weak
_DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetDynamicEntityField(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD); // weak
// char *strstr(const char *haystack, const char *needle);
// size_t strlen(const char *s);
int ClearRegisteredItems(void); // weak
_DWORD __cdecl Axis4ToAngles(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_IsLocalClient(_DWORD); // weak
_DWORD __cdecl G_CreateRotationMatrix(_DWORD, _DWORD); // weak
_DWORD __stdcall Scr_FindAnimTree(_DWORD); // weak
_DWORD __cdecl trap_GetConfigstringConst(_DWORD); // weak
_DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetEntityId(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_ObjectError(_DWORD); // weak
_DWORD __cdecl MatrixTranspose(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SetBrushModel(_DWORD); // weak
_DWORD __cdecl trap_DObjUpdateServerTime(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Com_MatchToken(int, char *s2, int); // idb
_DWORD __cdecl trap_XAnimSetAnimRate(_DWORD, __int16, _DWORD); // weak
_DWORD __cdecl Cmd_Notarget_f(_DWORD); // weak
_DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl PM_SlideMove(_DWORD); // weak
_DWORD __cdecl G_AddLean(_DWORD, _DWORD); // weak
int __cdecl Drop_Item(int, int, float, int); // idb
int __cdecl Q_acos(float); // idb
_DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD); // weak
// void qsort(void *base, size_t nmemb, size_t size, __compar_fn_t compar);
_DWORD __cdecl G_IsPlaying(_DWORD); // weak
int __cdecl PitchToQuaternion(float, int); // idb
int __cdecl G_NewString(char *s); // idb
// double atof(const char *nptr);
// double atan2(double y, double x);
_DWORD __cdecl Scr_GetClientField(_DWORD, _DWORD); // weak
_DWORD __cdecl IsBinaryMoverBlocked(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl PASSFLOAT(_DWORD); // weak
_DWORD __cdecl G_DamageClient(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_SetClientContents(_DWORD); // weak
int __cdecl Com_sprintf(char *s, size_t maxlen, char *format, char); // idb
int __cdecl BG_GetWeaponSlotForName(char *s1); // idb
_DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD); // weak
int BG_FindAnimTrees(void); // weak
int G_UpdateObjectiveToClients(void); // weak
_DWORD __cdecl G_XAnimUpdateEnt(_DWORD); // weak
_DWORD __cdecl VectorInverse(_DWORD); // weak
int __cdecl G_RunItem(void *s); // idb
_DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_EntityContactCapsule(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_IsValidGameType(_DWORD); // weak
_DWORD __cdecl G_RunFrame(_DWORD); // weak
int G_UpdateCvars(void); // weak
int __cdecl G_InitGame(int, unsigned int seed, int, int); // idb
_DWORD __cdecl GScr_GetStatusIconIndex(char); // weak
_DWORD __cdecl trap_DObjGetRotTransArray(_DWORD); // weak
_DWORD __cdecl ClientBegin(_DWORD); // weak
// int strncmp(const char *s1, const char *s2, size_t n);
int BG_SetupSharedAmmoIndexes(void); // weak
_DWORD __cdecl StuckInClient(_DWORD); // weak
_DWORD __cdecl G_MoverTeam(_DWORD); // weak
_DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_GetActivateEnt(int, void *base); // idb
_DWORD __cdecl G_FreeEntityRefs(_DWORD); // weak
_DWORD __cdecl trap_InPVS(_DWORD, _DWORD); // weak
// double floor(double x);
double __cdecl CanDamage(_DWORD, _DWORD); // weak
int G_ProcessIPBans(void); // weak
_DWORD __cdecl trap_DObjGetMatrixArray(_DWORD); // weak
_DWORD __cdecl G_RotatePoint(_DWORD, _DWORD); // weak
int Scr_RunCurrentThreads(void); // weak
_DWORD __cdecl trap_MapExists(_DWORD); // weak
_DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimIsLooped(_DWORD); // weak
_DWORD __cdecl SanitizeString(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnimName(_DWORD); // weak
_DWORD __cdecl GScr_AddEntity(_DWORD); // weak
_DWORD __cdecl G_TouchTriggers(_DWORD); // weak
_DWORD __cdecl trap_XModelNumBones(_DWORD); // weak
_DWORD __cdecl BG_UpdatePlayerDObj(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Com_BitClear(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD); // weak
int __cdecl GetLeanFraction(float); // idb
_DWORD __cdecl trap_XAnimGetNumChildren(_DWORD); // weak
// int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD); weak
_DWORD __cdecl Scr_SetLoading(_DWORD); // weak
_DWORD __cdecl G_GeneralLink(_DWORD); // weak
_DWORD __cdecl BG_ClipForWeapon(_DWORD); // weak
_DWORD __cdecl ClientConnect(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimClearGoalWeight(_DWORD, __int16, _DWORD); // weak
_DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD); // weak
int G_InitObjectives(void); // weak
_DWORD __cdecl trap_XModelGet(_DWORD); // weak
_DWORD __cdecl SpectatorClientEndFrame(_DWORD); // weak
_DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl Team_GetLocationMsg(int, char *s, size_t maxlen); // idb
_DWORD __cdecl PM_AddTouchEnt(_DWORD); // weak
_DWORD __cdecl Scr_FreeEntityConstStrings(_DWORD); // weak
_DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD); // weak
// int toupper(int c);
_DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl vectosignedangles(_DWORD, _DWORD); // weak
_DWORD __cdecl RespawnItem(_DWORD); // weak
_DWORD __cdecl ClientCommand(_DWORD); // weak
_DWORD __cdecl infront(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD); // weak
int BG_InitWeaponStrings(void); // weak
// char *strcat(char *dest, const char *src);
int PM_UpdatePronePitch(void); // weak
int __cdecl G_GetHintStringIndex(int, char *s1); // idb
_DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD); // weak
_DWORD __cdecl fire_rocket(_DWORD, _DWORD, _DWORD); // weak
// double tan(double x);
int Svcmd_EntityList_f(void); // weak
_DWORD __cdecl trap_AddDebugString(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_TryDoor(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_InSnapshot(_DWORD, _DWORD); // weak
int BG_FindAnims(void); // weak
int __cdecl Info_RemoveKey_Big(char *s, char *s1); // idb
_DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int SaveRegisteredItems(void); // weak
_DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD); // weak
int __cdecl G_setfog(char *s); // idb
// void *memcpy(void *dest, const void *src, size_t n);
// double sqrt(double x);
long double __cdecl VectorNormalize2(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddString(_DWORD); // weak
_DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerConnect(_DWORD); // weak
_DWORD __cdecl Scr_SetClientField(_DWORD, _DWORD); // weak
_DWORD __cdecl G_SetClientSound(_DWORD); // weak
_DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetWeaponSlotNameForIndex(_DWORD); // weak
_DWORD __cdecl ConcatArgs(_DWORD); // weak
int __cdecl G_FindConfigstringIndex(char *s2, int, int, int, char); // idb
_DWORD __cdecl BG_GetSharedAmmoCapSize(_DWORD); // weak
int __cdecl G_ShutdownGame(_DWORD); // weak
_DWORD __cdecl trap_SetArchive(_DWORD); // weak
_DWORD __cdecl GetFollowPlayerState(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PrecacheAnimTrees(_DWORD); // weak
int trap_FreeClientScriptPers(void); // weak
_DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl GScr_AddFieldsForClient(_DWORD); // weak
_DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int Swap_Init(void); // weak
_DWORD __cdecl Q_strncmp(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_stricmp(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetHudElemField(_DWORD, _DWORD); // weak
int __cdecl G_SpawnString(char *s1, int, int); // idb
_DWORD __cdecl Scr_GetString(_DWORD); // weak
_DWORD __cdecl G_GrenadeTouchTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimNotetrackExists(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl ClientIntermissionThink(_DWORD); // weak
_DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char); // weak
_DWORD __cdecl G_DObjSetLocalTag(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_PlayerAnimation(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD); // weak
double __cdecl vectosignedpitch(_DWORD); // weak
_DWORD __cdecl Scr_AddArrayStringIndexed(_DWORD); // weak
_DWORD __stdcall Scr_GetAnim(_DWORD); // weak
_DWORD __cdecl Scr_GetFunctionHandle(_DWORD, _DWORD); // weak
// void srand(unsigned int seed);
_DWORD __cdecl trap_Error_Localized(_DWORD); // weak
_DWORD __cdecl DoorSetSounds(_DWORD); // weak
// int snprintf(char *s, size_t maxlen, const char *format, ...);
int BG_SetupClipIndexes(void); // weak
double __cdecl Q_random(_DWORD); // weak
_DWORD __cdecl HudElem_ClientDisconnect(_DWORD); // weak
_DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD); // weak
double __cdecl VectorDistanceSquared(_DWORD, _DWORD); // weak
int __cdecl G_TagIndex(char *s2); // idb
_DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD); // weak
double __cdecl RadiusFromBounds(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddVector(_DWORD); // weak
int G_XAnimUpdate(void); // weak
_DWORD __stdcall trap_XAnimGetChildAt(_DWORD); // weak
_DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD); // weak
_DWORD __cdecl G_SetMovedir(_DWORD, _DWORD); // weak
_DWORD __cdecl SnapVectorTowards(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_XAnimGetAnimTreeSize(_DWORD); // weak
int G_SpawnPlayerClone(void); // weak
int Com_GetCurrentParseLine(void); // weak
_DWORD __cdecl G_RunClient(_DWORD); // weak
int Scr_AllocGameVariable(void); // weak
_DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD); // weak
double __cdecl BG_GetSpeed(_DWORD, _DWORD); // weak
double __cdecl QuatEigenTrace(_DWORD); // weak
// int strcasecmp(const char *s1, const char *s2);
_DWORD __cdecl Scr_AddBool(_DWORD); // weak
_DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_SetTime(_DWORD); // weak
int __cdecl RollToQuaternion(float, int); // idb
_DWORD __cdecl Scr_SetString(_DWORD, _DWORD); // weak
int __cdecl Com_ScriptError(char *format, char); // idb
_DWORD __cdecl trap_XAnimCalcAbsDelta(_DWORD, __int16, _DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD); // weak
// int atoi(const char *nptr);
int __cdecl Com_BeginParseSession(char *src); // idb
int G_SpawnGEntityFromSpawnVars(void); // weak
_DWORD __cdecl Scr_GetHudElemField(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddEntity(_DWORD); // weak
_DWORD __cdecl Cmd_Take_f(_DWORD); // weak
_DWORD __cdecl PM_VerifyPronePosition(_DWORD, _DWORD); // weak
_DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD); // weak
int __cdecl Q_rsqrt(float); // idb
_DWORD __cdecl BG_AnimScriptAnimation(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Player_GetMethod(_DWORD); // weak
_DWORD __cdecl G_UpdateTagInfo(_DWORD, _DWORD); // weak
_DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int HudElem_DestroyAll(void); // weak
_DWORD __cdecl GScr_GetScriptMenuIndex(char); // weak
int __cdecl BG_CopyStringIntoBuffer(char *s, int, int, int); // idb
_DWORD __cdecl BG_Player_DoControllers(_DWORD, _DWORD, _DWORD, _DWORD); // weak
// int sscanf(const char *s, const char *format, ...);
long double __cdecl VectorDistance(_DWORD, _DWORD); // weak
double __cdecl RotationToYaw(_DWORD); // weak
int PM_AdjustAimSpreadScale(void); // weak
_DWORD __cdecl trap_DObjDumpInfo(_DWORD); // weak
_DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddHudElem(_DWORD); // weak
int __cdecl YawVectors(float, int, int); // idb
int __cdecl AngleNormalize360(float); // idb
int Scr_GetNumParam(void); // weak
_DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl Info_SetValueForKey(char *s, char *s1, int); // idb
// double acos(double x);
// void *memset(void *s, int c, size_t n);
_DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD); // weak
_DWORD __cdecl G_TempEntity(_DWORD, _DWORD); // weak
int __cdecl BG_GetVerticalBobFactor(int, float, float, float); // idb
int __cdecl Q_GetDecimalDelimiter(_DWORD); // weak
int __cdecl PitchForYawOnNormal(float, int); // idb
_DWORD __cdecl AnglesToAxis(_DWORD, _DWORD); // weak
_DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl DeathmatchScoreboardMessage(_DWORD); // weak
long double __cdecl trap_Cvar_VariableValue(_DWORD); // weak
int GScr_LoadConsts(void); // weak
_DWORD __cdecl G_BounceItem(_DWORD, _DWORD); // weak
int __cdecl Com_Error(int, char *format, char); // idb
_DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD); // weak
int Scr_StartupGameType(void); // weak
_DWORD __cdecl Scr_GetConstString(_DWORD); // weak
_DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_SurfaceTypeToName(_DWORD); // weak
_DWORD __cdecl InitScriptMover(_DWORD); // weak
_DWORD __cdecl Door_reverse_sounds(_DWORD); // weak
long double __cdecl trap_XAnimGetTime(_DWORD, __int16); // weak
long double __cdecl trap_XAnimGetLengthSeconds(_DWORD); // weak
_DWORD __cdecl HudElem_Free(_DWORD); // weak
_DWORD __cdecl Scr_InitSystem(_DWORD, _DWORD); // weak
// char *strncpy(char *dest, const char *src, size_t n);
_DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjSetControlRotTransIndex(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Cmd_MenuResponse_f(_DWORD); // weak
int __cdecl AngleNormalize180Accurate(float); // idb
_DWORD __cdecl G_IndexForMeansOfDeath(char); // weak
_DWORD __cdecl VectorRotateAngles(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl G_MissileLandAngles(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl G_Printf(char *format, char); // idb
_DWORD __cdecl trap_DObjSetRotTransIndex(_DWORD, _DWORD, _DWORD); // weak
int Scr_LoadGameType(void); // weak
int G_SpawnEntitiesFromString(void); // weak
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl G_DebugCircleEx(int, float, int, int, int, int); // idb
_DWORD __cdecl ClientImpacts(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_AddObject(_DWORD); // weak
_DWORD __cdecl Scr_AllocString(_DWORD, _DWORD); // weak
_DWORD __cdecl MT_Alloc(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD); // weak
_DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD); // weak
_DWORD __cdecl FireWeapon(_DWORD); // weak
_DWORD __cdecl BG_AmmoForWeapon(_DWORD); // weak
_DWORD __cdecl GScr_AllocString(_DWORD); // weak
_DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD); // weak
_DWORD __cdecl Fill_Clip(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD); // weak
_DWORD __cdecl PM_StepSlideMove(_DWORD); // weak
_DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Pickup_Health(_DWORD, _DWORD); // weak
_DWORD __cdecl BG_GetWeaponIndexForName(char); // weak
int G_RegisterCvars(void); // weak
_DWORD __cdecl Cmd_Activate_f(_DWORD); // weak
_DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int __cdecl RotatePointAroundVector(int, int, int, float); // idb
int PM_ShouldMakeFootsteps(void); // weak
_DWORD __cdecl trap_XModelGetBoneNames(_DWORD); // weak
int Scr_MakeArray(void); // weak
_DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FreeWeaponInfoMemory(_DWORD); // weak
_DWORD __cdecl G_SpawnTurret(_DWORD, char); // weak
_DWORD __cdecl trap_XAnimIsPrimitive(_DWORD); // weak
_DWORD __cdecl ScriptEnt_GetMethod(_DWORD); // weak
_DWORD __cdecl G_EntUnlink(_DWORD); // weak
int G_IsInMatchTimeout(void); // weak
// int sprintf(char *s, const char *format, ...);
int __cdecl ParseConfigStringToStruct(int, int, int, char *s, int, int, int); // idb
_DWORD __cdecl trap_XAnimSetTime(_DWORD, __int16, _DWORD); // weak
int __cdecl G_Error(char *format, char); // idb
_DWORD __cdecl trap_XAnimSetGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_Write(_DWORD, _DWORD, _DWORD); // weak
int __cdecl UnGetLeanFraction(float); // idb
_DWORD __cdecl G_GetNonPVSFriendlyInfo(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl vectoangles(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_CopyEntityNum(_DWORD, _DWORD, _DWORD); // weak
// double sin(double x);
_DWORD __cdecl Com_ParseOnLine(_DWORD); // weak
_DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD); // weak
int __cdecl Cmd_EntityCount_f(_DWORD); // weak
_DWORD __cdecl Com_Parse2DMatrix(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int Com_UngetToken(void); // weak
// int __cdecl _Jv_RegisterClasses(_DWORD); weak
int PM_LadderMove(void); // weak
// double modf(double x, double *iptr);
int __cdecl AngleMod(float); // idb
_DWORD __cdecl trap_DObjDisplayAnim(_DWORD); // weak
_DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeThread(_DWORD); // weak
_DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl BG_SetPlayerWeaponForSlot(_DWORD, _DWORD, _DWORD); // weak
// int rand(void);
_DWORD __cdecl P_DamageFeedback(_DWORD); // weak
_DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD); // weak
_DWORD __cdecl trap_DObjGetHierarchyBits(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Scr_PlayerKilled(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
int Scr_EndLoadScripts(void); // weak
_DWORD __cdecl ClientEndFrame(_DWORD); // weak
_DWORD __cdecl Scr_MakeGameMessage(_DWORD, char); // weak
_DWORD __cdecl G_CallSpawnEntity(_DWORD); // weak
_DWORD __cdecl Com_BitSet(_DWORD, _DWORD); // weak
_DWORD __cdecl Scr_FreeGameVariable(_DWORD); // weak
_DWORD __cdecl PerpendicularVector(_DWORD, _DWORD); // weak
_DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD); // weak
_DWORD __cdecl Team_GetLocation(_DWORD); // weak
_DWORD __cdecl trap_SnapVector(_DWORD); // weak
int __cdecl AngleNormalize180(float); // idb
_DWORD __cdecl Cmd_Vote_f(_DWORD); // weak
_DWORD __cdecl G_SetOrigin(_DWORD, _DWORD); // weak
// int __gmon_start__(void); weak
int __cdecl YawToQuaternion(float, int); // idb
// double ceil(double x);
int PM_UpdateAimDownSightLerp(void); // weak
// char *strcpy(char *dest, const char *src);
_DWORD __cdecl Scr_ExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD); // weak
_DWORD __cdecl Q_strlwr(_DWORD); // weak
int start();
void *sub_15B50();
void sub_15BC6();
int __cdecl sub_15BCC(int a1);
int BG_AnimParseError(char *format, ...);
int __cdecl BG_AnimationIndexForString(char *src); // idb
int __cdecl BG_AnimationForString(int a1);
int __cdecl BG_IndexForString(int a1, int *a2, int a3);
char *__cdecl BG_CopyStringIntoBuffer(char *s, int a2, int a3, int a4);
int BG_InitWeaponStrings();
unsigned __int16 *__cdecl sub_160FB(unsigned int a1);
int __cdecl sub_1619A(int a1);
int BG_FinalizePlayerAnims();
void *__cdecl sub_165B9(int a1, int a2, int a3, void *s);
int __cdecl sub_1696B(int a1, _DWORD *a2);
size_t __cdecl BG_ParseCommands(_DWORD *a1, _DWORD *a2, int a3);
int __cdecl BG_AnimParseAnimScript(int a1, int a2, int a3);
int __cdecl sub_17F5A(int a1, _DWORD *a2);
_DWORD *__cdecl sub_18023(int a1, _DWORD *a2);
int __cdecl BG_PlayAnim(_DWORD *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7);
int __cdecl BG_PlayAnimName(int, char *src, int, int, int, int); // idb
int __cdecl BG_ExecuteCommand(int a1, __int16 *a2, int a3, int a4, int a5);
int __cdecl BG_AnimScriptAnimation(int a1, int a2, int a3, int a4);
int __cdecl BG_AnimScriptStateChange(int a1, int a2, int a3);
int __cdecl BG_AnimScriptEvent(int a1, int a2, int a3, int a4);
int __cdecl BG_GetAnimString(int a1, unsigned int a2);
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4);
unsigned int __cdecl sub_188A4(int a1, int a2, int a3);
int __cdecl BG_GetAnimScriptEvent(int a1, int a2);
int __cdecl BG_GetAnimationForIndex(int a1, unsigned int a2);
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1);
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, int a2);
_BOOL4 __cdecl BG_IsProneAnim(int a1, int a2);
_DWORD *__cdecl sub_18CED(int *a1, int *a2, int a3, int a4);
unsigned int __cdecl sub_193FB(int *a1, unsigned int a2, int a3, int a4);
void __cdecl sub_197B0(int a1, _DWORD *a2);
// void __usercall sub_19842(long double a1@<st0>, float a2, float a3, float a4, float a5, int a6, int a7);
// void __usercall sub_19A3A(long double a1@<st0>, int a2, int a3);
int __cdecl sub_19FB4(_DWORD *a1, int a2);
int sub_1A314();
int __cdecl sub_1A31E(int a1);
int __cdecl sub_1A341(int a1, unsigned __int16 a2, int a3, int a4);
// void *__usercall sub_1A389@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, void *s);
int *__cdecl sub_1AB82(int a1, float a2, int a3);
void __cdecl BG_LerpOffset(int a1, float a2, int a3);
// int __usercall BG_Player_DoControllers@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5);
// unsigned int __usercall BG_PlayerAnimation@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int *a4);
int __cdecl BG_UpdatePlayerDObj(int a1, int *a2, int a3);
int BG_FindAnims();
// _DWORD *__userpurge sub_1B2FF@<eax>(_DWORD *a1, char a2, int a3);
int BG_FindAnimTrees();
int *BG_LoadAnimTreeInstances();
float *__cdecl sub_1B464(float a1, float *a2, float *a3);
void sub_1B47C();
char *__cdecl BG_FindItemForWeapon(int a1);
char *__cdecl BG_FindItem(int a1);
_BOOL4 __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3);
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3);
int __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3);
int __cdecl BG_EvaluateTrajectoryDelta(float *a1, int a2, float *a3);
int __cdecl BG_GetMarkDir(_DWORD *a1, float *a2, float *a3);
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3);
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3);
int __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4);
int __cdecl BG_CheckProneValid(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float); // idb
int __cdecl BG_CheckProne(int, int, int, int, float, int, int, int, int, int, int, int, int, int, float); // idb
void sub_1E732();
int __cdecl PM_trace(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
int __cdecl PM_AddEvent(int a1);
int __cdecl PM_AddTouchEnt(int a1);
void __cdecl PM_ClipVelocity(int a1, int a2, int a3, float a4);
int __cdecl PM_GetEffectiveStance(_DWORD *a1);
long double sub_1E9F1();
long double sub_1EA52();
float *sub_1EAB3();
void __cdecl sub_1ED62(int a1, float a2, float a3);
long double __cdecl sub_1EEC9(char *a1);
long double __cdecl sub_1F08B(_BYTE *a1);
// int __usercall sub_1F48F@<eax>(long double a1@<st0>);
int sub_1F7D7();
int sub_1F82A();
int __cdecl sub_1F882(float); // idb
int sub_1F985();
int sub_1FCF9();
int sub_1FE8D();
int sub_2003D();
_DWORD *sub_20707();
int sub_2084C();
int sub_20BAE();
int __cdecl sub_2105C(char a1);
int sub_210DE();
int sub_21109();
int sub_21132();
int sub_21148();
void sub_2115E();
int __cdecl sub_21761(int a1);
_DWORD *sub_21A17();
_DWORD *sub_21CCD();
int sub_2219F();
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3);
long double __cdecl sub_223F5(int a1, int a2, float *a3);
long double __cdecl sub_2251C(int a1, int a2);
void sub_226A6();
void sub_232C4();
char __cdecl PM_FootstepEvent(char a1, char a2, int a3);
_BOOL4 PM_ShouldMakeFootsteps();
void sub_24AE8();
int sub_25816();
_DWORD *sub_25A7F();
int sub_25AEF();
void __cdecl PM_UpdateLean(int a1, int a2, void (__cdecl *a3)(float *, int *, int *, int *, int *, _DWORD, int));
// int __usercall sub_25FF5@<eax>(long double a1@<st0>, int a2, float a3, int a4);
// int __usercall PM_UpdateViewAngles@<eax>(long double a1@<st0>, int a2, int a3, int a4);
// void __usercall PM_UpdatePronePitch(long double a1@<st0>);
int PM_SetProneMovementOverride();
char PM_UpdatePlayerWalkingFlag();
void sub_27330();
int PM_LadderMove();
void __cdecl PmoveSingle(int a1);
int __cdecl Pmove(int a1);
long double __cdecl BG_GetSpeed(int a1, int a2);
long double __cdecl sub_28B71(float a1);
int __cdecl sub_28B8A(float); // idb
_BOOL4 __cdecl sub_28BB0(float a1);
void sub_28BD8();
int __cdecl PM_VerifyPronePosition(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl PM_SlideMove(int a1);
void __cdecl PM_StepSlideMove(int a1);
int __cdecl sub_2A7B1(float); // idb
long double __cdecl sub_2A7EF(float a1);
void sub_2A808();
int __cdecl BG_GetWeaponTypeName(int a1);
int __cdecl sub_2A828(int a1, char *s1, int a3);
char *__cdecl sub_2AB58(int a1, char *s);
char *__cdecl sub_2ABBE(int a1, char *s);
_DWORD *__cdecl sub_2ABD8(int a1, int a2, int a3);
int __cdecl sub_2AC83(int a1, int a2);
int sub_2AFE4();
int BG_FillInWeaponItems();
int BG_SetupAmmoIndexes();
int BG_SetupSharedAmmoIndexes();
int BG_SetupClipIndexes();
int sub_2B893();
int sub_2BAB8();
int __cdecl compare_weaponfile_names(_DWORD *a1, _DWORD *a2);
int BG_SetupWeaponInfo();
int __cdecl BG_GetInfoForWeapon(int a1);
int __cdecl BG_GetWeaponForInfo(int a1);
int BG_GetNumWeapons();
int BG_GetNumAmmoTypes();
int __cdecl BG_GetAmmoTypeMax(int a1);
int BG_GetNumAmmoClips();
int __cdecl BG_GetAmmoClipSize(int a1);
int __cdecl BG_GetSharedAmmoCapSize(int a1);
int __cdecl BG_GetAmmoTypeName(int a1);
int __cdecl BG_GetAmmoClipName(int a1);
int __cdecl BG_GetAmmoTypeForName(int a1);
int __cdecl BG_GetAmmoClipForName(int a1);
int __cdecl BG_GetWeaponSlotForName(char *s1); // idb
int __cdecl BG_GetWeaponSlotNameForIndex(int a1);
int __cdecl BG_GetWeaponIndexForName(int a1);
int __cdecl BG_IsAimDownSightWeapon(int a1);
int __cdecl BG_GivePlayerWeapon(int a1, int a2);
int __cdecl BG_TakePlayerWeapon(int a1, int a2);
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3);
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3);
int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2);
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3);
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2);
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2);
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2);
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3);
int PM_UpdateAimDownSightFlag();
unsigned int PM_ClearAimDownSightFlag();
void PM_UpdateAimDownSightLerp();
int PM_InteruptWeaponWithProneMove();
int __cdecl BG_ClipForWeapon(int a1);
int __cdecl BG_AmmoForWeapon(int a1);
int __cdecl BG_WeaponIsClipOnly(int a1);
int __cdecl BG_WeaponAmmo(int a1, int a2);
int sub_2D6C3();
int __cdecl PM_WeaponUseAmmo(int a1, int a2);
int __cdecl PM_WeaponAmmoAvailable(int a1);
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1);
int __cdecl sub_2D9B8(int a1);
unsigned int __cdecl sub_2DA19(int a1);
int sub_2DA68();
int __cdecl sub_2DAA0(int a1);
int sub_2DD15();
int sub_2DF40();
int sub_2E04E();
void __cdecl sub_2E19F(int a1, int a2);
int sub_2E43D();
int sub_2E7F9();
int sub_2E857();
int sub_2E9AB();
int __cdecl sub_2EC3D(int a1);
int sub_2EF8B();
int sub_2F1D6();
void PM_AdjustAimSpreadScale();
int sub_2F5CE();
void sub_2F7BE();
int __cdecl sub_2FA94(int a1);
int __cdecl sub_2FB0A(int a1);
int sub_2FCF2();
int sub_2FCFC();
int sub_2FE12();
void sub_2FEB0();
int __cdecl sub_2FF54(int a1);
int sub_3007E();
int sub_30125();
int __cdecl sub_301A4(int a1);
int PM_Weapon();
int sub_306DD();
int sub_3084B();
long double __cdecl BG_GetBobCycle(int a1);
long double __cdecl BG_GetVerticalBobFactor(int a1, float a2, float a3, float a4);
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4);
void __cdecl sub_30BD3(float *a1, float *a2);
void __cdecl sub_31063(float *a1, float *a2);
float *__cdecl sub_310DE(float *a1, float *a2);
float *__cdecl sub_31312(float *a1, float *a2);
void __cdecl sub_31501(float *a1, float *a2);
int __cdecl sub_3171A(int, int, float, float, float, float, float, float); // idb
float *__cdecl sub_31940(float *a1, float *a2);
int __cdecl BG_CalculateWeaponAngles(float *a1, int a2);
void __cdecl sub_31C7E(float *a1, float *a2);
void __cdecl sub_31E31(float *a1, float *a2);
void __cdecl BG_CalculateViewAngles(float *a1, int a2);
long double __cdecl sub_31FE6(float a1, float a2, float a3, int a4);
int __cdecl BG_CalculateWeaponPosition_Sway(int, int, int, int, float, int); // idb
float *__cdecl BG_WeaponFireRecoil(int a1, float *a2, int a3);
void sub_3270C();
int __cdecl Q_rand(int a1);
long double __cdecl Q_random(int a1);
long double __cdecl Q_crandom(int a1);
float *__cdecl gunrandom(float *a1, float *a2);
long double __cdecl Q_rsqrt(float a1);
int __cdecl Q_log2(int a1);
long double __cdecl Q_acos(float a1);
int __cdecl ClampChar(int a1);
int __cdecl ClampShort(int a1);
int __cdecl DirToByte(float *a1);
int __cdecl ByteToDir(int a1, int a2);
long double __cdecl DotProduct(float *a1, float *a2);
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3);
float *__cdecl VectorAdd(float *a1, float *a2, float *a3);
int __cdecl VectorCopy(_DWORD *a1, _DWORD *a2);
int __cdecl VectorScale(int, float, int); // idb
int __cdecl VectorMA(int, float, int, int); // idb
int __cdecl VectorCompareEpsilon(int a1, int a2);
long double __cdecl VectorLength(float *a1);
long double __cdecl VectorDistance(float *a1, float *a2);
long double __cdecl VectorDistanceSquared(float *a1, float *a2);
long double __cdecl VectorDistance2D(float *a1, float *a2);
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2);
float *__cdecl CrossProduct(float *a1, float *a2, float *a3);
_DWORD *__cdecl CrossProductUp(_DWORD *a1, _DWORD *a2);
long double __cdecl VectorNormalize(float *a1);
long double __cdecl VectorNormalize2D(float *a1);
long double __cdecl VectorNormalize4D(float *a1);
float *__cdecl VectorNormalizeFast(float *a1);
long double __cdecl VectorNormalize2(float *a1, float *a2);
unsigned int __cdecl VectorInverse(_DWORD *a1);
int __cdecl Vector4Scale(int, float, int); // idb
long double __cdecl VectorMax(float *a1);
float *__cdecl VectorRotate(float *a1, float *a2, float *a3);
int *__cdecl RotatePointAroundVector(int a1, int a2, int a3, float a4);
int __cdecl RotateAroundDirection(int, float); // idb
int __cdecl MakeNormalVectors(float *a1, float *a2, int a3);
long double __cdecl vectoyaw(float *a1);
long double __cdecl vectosignedyaw(float *a1);
long double __cdecl vectopitch(float *a1);
long double __cdecl vectosignedpitch(float *a1);
int __cdecl vectoangles(float *a1, int a2);
int __cdecl vectosignedangles(float *a1, int a2);
float *__cdecl AngleVectors(float *a1, int a2, float *a3, float *a4);
float *__cdecl YawVectors(float a1, int a2, int a3);
void __cdecl PerpendicularVector(int a1, int a2);
void __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, int a4);
float *__cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4);
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3);
int __cdecl MatrixMultiplyEquals(float *a1, float *a2);
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3);
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3);
int __cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3);
int __cdecl MatrixTranspose(_DWORD *a1, _DWORD *a2);
float *__cdecl MatrixInverse(float *a1, float *a2);
int __cdecl MatrixInverseOrthogonal43(float *a1, int a2);
int *__cdecl MatrixInverse44(int a1, float *a2);
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3);
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3);
int __cdecl MatrixTransformVector43Equals(float *a1, float *a2);
int __cdecl VectorAngleMultiply(int, float); // idb
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3);
unsigned int __cdecl QuatInverse(_DWORD *a1, unsigned int *a2);
int __cdecl ConvertQuatToMat(int a1);
long double __cdecl QuatEigenTrace(float *a1);
long double __cdecl AngleEigenTrace(float a1);
void __cdecl QuatRatioEigenTrace(int a1, int a2);
long double __cdecl RotationToYaw(float *a1);
float *__cdecl PitchToQuaternion(float a1, int a2);
float *__cdecl YawToQuaternion(float a1, int a2);
float *__cdecl RollToQuaternion(float a1, int a2);
int __cdecl ColorBytes3(float, float, float); // idb
int __cdecl ColorBytes4(float, float, float, float); // idb
long double __cdecl NormalizeColor(float *a1, float *a2);
long double __cdecl AngleMod(float a1);
long double __cdecl LerpAngle(float a1, int a2, float a3);
long double __cdecl AngleSubtract(float a1, float a2);
// float *__usercall AnglesSubtract@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4);
long double __cdecl AngleNormalize360(float a1);
// long double __usercall AngleNormalize180@<st0>(long double a1@<st0>, float a2);
long double __cdecl AngleNormalize360Accurate(float a1);
long double __cdecl AngleNormalize180Accurate(float a1);
int __cdecl AngleDelta(float, float); // idb
long double __cdecl RadiusFromBounds(int a1, int a2);
int __cdecl ClearBounds(_DWORD *a1, _DWORD *a2);
void __cdecl AddPointToBounds(float *a1, float *a2, float *a3);
void __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4);
_DWORD *__cdecl AxisClear(_DWORD *a1);
int __cdecl AxisCopy(_DWORD *a1, _DWORD *a2);
_DWORD *__cdecl AnglesToAxis(int a1, float *a2);
_DWORD *__cdecl YawToAxis(float a1, int a2);
int __cdecl AxisToAngles(int *a1, int a2);
int __cdecl Axis4ToAngles(int *a1, int a2);
int __cdecl AxisToSignedAngles(int *a1, int a2);
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4);
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3);
int __cdecl SetPlaneSignbits(int a1);
_BOOL4 __cdecl BoxDistSqrdExceeds(int a1, int a2, int a3, float a4);
_BYTE *__cdecl NormalToLatLong(float *a1, _BYTE *a2);
int __cdecl Vec10Copy(_DWORD *a1, _DWORD *a2);
long double __cdecl Q_rint(float a1);
long double __cdecl ColorNormalize(float *a1, float *a2);
int __cdecl VectorRotateAngles(int *a1, int a2, _DWORD *a3);
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4);
int __cdecl VectorPolar(int, float, int); // idb
void __cdecl VectorSnap(float *a1);
float *__cdecl Vector5Add(float *a1, float *a2, float *a3);
int __cdecl Vector5Scale(int, float, int); // idb
int __cdecl Vector53Copy(_DWORD *a1, _DWORD *a2);
long double __cdecl RoundFloat(float a1, int a2);
void __cdecl PitchForYawOnNormal(float a1, int a2);
int __cdecl Rand_Init(int a1);
long double __cdecl flrand(float a1, float a2);
int __cdecl irand(int a1, int a2);
float *__cdecl sub_381A6(float a1, float *a2, float *a3);
double *__cdecl sub_381BE(double a1, double *a2, double *a3);
void sub_38210();
int __cdecl P_DamageFeedback(_DWORD *a1);
int __cdecl G_SetClientSound(int a1);
int __cdecl ClientImpacts(int a1, int a2);
int __cdecl G_TouchTriggers(int a1);
int __cdecl SpectatorThink(_DWORD *a1, int *a2);
int __cdecl ClientInactivityTimer(int a1);
int __cdecl ClientIntermissionThink(int a1);
_DWORD *__cdecl ClientEvents(_DWORD *a1, int a2);
int __cdecl G_SetClientContents(int a1);
int __cdecl ClientThink_real(int a1, int *a2);
_DWORD *__cdecl ClientThink(int a1);
int __cdecl G_RunClient(_DWORD *a1);
int __cdecl IntermissionClientEndFrame(int a1);
_DWORD *__cdecl SpectatorClientEndFrame(int a1);
int __cdecl G_ClientCanSpectateTeam(int a1, char a2);
int __cdecl GetFollowPlayerState(int a1, _DWORD *a2);
int __cdecl StuckInClient(int a1);
int __cdecl sub_3AACF(int a1, int a2);
float *__cdecl ClientEndFrame(_DWORD *a1);
int __cdecl G_PlayerEvent(int a1, int a2);
void sub_3B358();
int __cdecl sub_3B35C(int a1, int a2, _DWORD *a3);
int __cdecl sub_3B393(int a1);
int __cdecl sub_3B486(int a1);
int __cdecl sub_3B515(int a1);
int __cdecl sub_3B5E4(int a1);
int __cdecl sub_3B668(int a1);
int __cdecl sub_3B73E(int a1);
int __cdecl sub_3B7D3(_DWORD *a1);
int __cdecl sub_3B88E(int a1);
int __cdecl sub_3B911(int a1);
int __cdecl sub_3B949(int a1);
int __cdecl sub_3B998(int a1);
int __cdecl sub_3B9D5(int a1);
int __cdecl sub_3BA4F(int a1);
_DWORD *__cdecl sub_3BAB5(int a1);
_DWORD *__cdecl sub_3BB58(int a1);
int __cdecl sub_3BC51(int a1);
__int16 __cdecl sub_3BD0B(int a1);
int __cdecl sub_3BD57(int a1);
char **__cdecl GScr_AddFieldsForClient(unsigned __int16 a1);
int __cdecl Scr_SetClientField(int a1, int a2);
int __cdecl Scr_GetClientField(int a1, int a2);
void sub_3BF04();
// int __usercall SetClientViewAngle@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl sub_3C29D(char *a1, char *a2, int a3);
int __cdecl ClientUserinfoChanged(int a1);
const char *__cdecl ClientConnect(int a1, __int16 a2);
int __cdecl ClientBegin(int a1);
int __cdecl ClientSpawn(int a1, _DWORD *a2, int a3);
int __cdecl ClientDisconnect(int a1);
int G_SetPlayerSize();
int __cdecl G_AddLean(int a1, int a2);
unsigned int __cdecl G_GetNonPVSFriendlyInfo(_DWORD *a1, float *a2, int a3);
void sub_3D5CC();
int __cdecl PlayerCmd_giveWeapon(unsigned int a1);
int __cdecl PlayerCmd_takeWeapon(unsigned int a1);
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1);
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1);
int __cdecl PlayerCmd_hasWeapon(unsigned int a1);
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1);
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1);
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1);
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1);
int __cdecl sub_3E148(unsigned int a1);
int __cdecl sub_3E2C4(unsigned int a1);
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1);
int __cdecl PlayerCmd_isOnGround(unsigned int a1);
int __cdecl PlayerCmd_pingPlayer(unsigned int a1);
int __cdecl sub_3E70C(unsigned int a1);
int __cdecl sub_3E7C1(unsigned int a1);
int __cdecl sub_3E86C(unsigned int a1);
int __cdecl sub_3E9CC(unsigned int a1);
int __cdecl sub_3EA5D(unsigned int a1);
int __cdecl sub_3EB49(unsigned int a1);
int __cdecl sub_3EC84(unsigned int a1);
int __cdecl sub_3F4AC(unsigned int a1);
int __cdecl sub_3F5A8(unsigned int a1);
int __cdecl sub_3F69D(unsigned int a1);
int __cdecl sub_3F792(int a1);
_BOOL4 __cdecl sub_3F7C7(int a1);
int __cdecl sub_3F7E2(unsigned int a1);
int __cdecl sub_3F93D(unsigned int a1);
int __cdecl sub_3FBC2(unsigned int a1);
int __cdecl sub_3FD52(unsigned int a1);
int __cdecl sub_3FF2B(unsigned int a1);
int __cdecl sub_40095(unsigned int a1);
int __cdecl sub_40208(int a1);
int __cdecl sub_40235(int a1);
int __cdecl sub_40262(unsigned int a1);
int __cdecl sub_40327(unsigned int a1);
int __cdecl sub_403CA(int a1);
int __cdecl sub_403E1(unsigned int a1);
int __cdecl sub_4068A(unsigned int a1);
int __cdecl sub_4083D(unsigned int a1);
int __cdecl sub_408E0(unsigned int a1);
unsigned int __cdecl sub_40983(unsigned int a1);
int __cdecl sub_40A26(unsigned int a1);
int __cdecl sub_40B55(unsigned int a1);
int __cdecl sub_40C06(unsigned int a1);
int __cdecl sub_40CD2(unsigned int a1);
int __cdecl sub_40DBD(unsigned int a1);
int __cdecl sub_40EA8(unsigned int a1);
int __cdecl sub_40F93(unsigned int a1);
int __cdecl sub_4110B(unsigned int a1);
int __cdecl sub_411BB(unsigned int a1);
int __cdecl sub_41295(unsigned int a1);
int __cdecl sub_4136F(unsigned int a1);
int __cdecl Player_GetMethod(char **a1);
void sub_414C4();
int __cdecl DeathmatchScoreboardMessage(int a1);
int __cdecl Cmd_Score_f(int a1);
int __cdecl CheatsOk(int a1);
_BYTE *__cdecl ConcatArgs(int a1);
_BYTE *__cdecl SanitizeString(char *a1, _BYTE *a2);
int __cdecl ClientNumberFromString(int, char *nptr); // idb
void __cdecl G_setfog(char *s);
int Cmd_Fogswitch_f();
_DWORD *__cdecl Cmd_Give_f(_DWORD *a1);
int __cdecl Cmd_Take_f(int a1);
int __cdecl Cmd_God_f(int a1);
int __cdecl Cmd_Notarget_f(int a1);
int __cdecl Cmd_Noclip_f(int a1);
int __cdecl Cmd_UFO_f(int a1);
int __cdecl Cmd_Kill_f(_DWORD *a1);
int __cdecl StopFollowing(int a1);
int __cdecl Cmd_FollowCycle_f(int a1, int a2);
_BOOL4 __cdecl G_IsPlaying(int a1);
void __cdecl sub_42C8B(int a1, int a2, int a3);
int __cdecl G_Say(int, int, int, char *src); // idb
int __cdecl sub_434B7(int a1, int a2, int a3);
char *__cdecl sub_43528(_DWORD *a1);
void __cdecl sub_43704(int a1, int a2, int a3);
void __cdecl G_Voice(_DWORD *a1, int a2, int a3);
int __cdecl sub_43A08(int a1, int a2, int a3, int a4);
_DWORD *__cdecl Cmd_GameCommand_f(int a1);
int __cdecl Cmd_Where_f(int a1);
int __cdecl Cmd_CallVote_f(int a1);
_DWORD *__cdecl Cmd_Vote_f(int a1);
int __cdecl Cmd_SetViewpos_f(int a1);
int __cdecl Cmd_Activate_f(int a1);
_DWORD *Cmd_EntityCount_f();
int __cdecl Cmd_MatchTimeout_f(int a1);
int __cdecl Cmd_MatchTimein_f(int a1);
int __cdecl Cmd_MenuResponse_f(int a1);
char *__cdecl ClientCommand(int a1);
void sub_4689D();
char *__cdecl sub_468A4(char *dest, char *src);
int G_ParseHitLocDmgTable();
void AddScore();
void __cdecl LookAtKiller(int a1, float *a2, float *a3);
int __cdecl G_IndexForMeansOfDeath(int a1);
int __cdecl player_die(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8);
_DWORD *__cdecl G_DamageClient(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl G_Damage(int a1, char *a2, char *a3, int a4, _DWORD *a5, int a6, int a7, int a8, int a9);
long double __cdecl CanDamage(float *a1, float *a2);
int __cdecl G_RadiusDamage(int, int, int, float, float, float, int, int); // idb
int __cdecl G_GetHitLocationString(int a1);
int __cdecl G_GetHitLocationIndexFromString(__int16 a1);
void sub_4825F();
int __cdecl G_DebugLine(int a1, int a2, int a3, int a4, int a5);
int *__cdecl G_DebugBox(int a1, int a2, int a3, int a4, int a5);
int __cdecl G_DebugCircle(int, float, int, int, int, int); // idb
unsigned int *__cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4, int a5, int a6);
void __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5, int a6, int a7);
float *__cdecl sub_488F8(float a1, float *a2, float *a3);
void sub_48910();
_DWORD *__cdecl sub_48914(_DWORD *a1);
_DWORD *__cdecl sub_48987(_DWORD *a1);
char *__cdecl HudElem_Alloc(int a1, int a2);
_DWORD *__cdecl HudElem_Free(_DWORD *a1);
unsigned int *__cdecl HudElem_ClientDisconnect(_DWORD *a1);
void *HudElem_DestroyAll();
int __cdecl sub_48C3E(int a1, _DWORD *a2, int a3, int a4);
int __cdecl sub_48D49(int a1, int a2, int a3);
int *__cdecl sub_48D87(int a1, int a2);
int __cdecl sub_48DE2(int a1, int a2);
int __cdecl sub_48E35(_BYTE *a1);
int __cdecl sub_48FB3(unsigned __int8 *a1);
int __cdecl sub_49024(int a1);
int __cdecl sub_490BC(int a1);
int __cdecl sub_490F3(int a1);
int __cdecl sub_49152(int a1, int a2);
int __cdecl sub_491A4(int a1, int a2);
int __cdecl sub_491F6(int a1, int a2);
int __cdecl sub_49248(int a1, int a2);
int __cdecl sub_4929A(int a1, int a2);
int __cdecl sub_492EC(int a1, int a2);
int __cdecl Scr_GetHudElemField(int a1, int a2);
int __cdecl Scr_SetHudElemField(int a1, int a2);
void **__cdecl Scr_FreeHudElemConstStrings(int a1);
int GScr_NewHudElem();
int GScr_NewClientHudElem();
int GScr_NewTeamHudElem();
void **GScr_AddFieldsForHudElems();
int __cdecl sub_496EA(int a1);
int __cdecl sub_49773(int a1);
int __cdecl sub_49899(int a1, int a2, char a3);
int __cdecl sub_49974(int a1, int a2, char a3);
int __cdecl sub_49B70(int a1);
int __cdecl sub_49BA5(int a1);
int __cdecl sub_49BDA(int a1);
int __cdecl sub_49C0F(int a1);
int __cdecl sub_49C44(int a1);
int __cdecl sub_49C79(int a1);
int __cdecl sub_49CAE(int a1);
int __cdecl sub_49D2D(int a1);
int __cdecl sub_49E1B(int a1);
int __cdecl sub_49F5D(int a1);
_DWORD *__cdecl sub_4A057(int a1);
int __cdecl sub_4A090(int a1);
int __cdecl HudElem_GetMethod(char **a1);
_DWORD *__cdecl HudElem_UpdateClient(_DWORD *a1, int a2, char a3);
int __cdecl sub_4A2BA(float); // idb
int __cdecl sub_4A2F8(float); // idb
void sub_4A336();
int __cdecl Fill_Clip(int a1, int a2);
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4);
int __cdecl sub_4A6F6(int a1, int a2);
int __cdecl sub_4A86B(_DWORD *a1, int a2, _DWORD *a3, int a4);
int __cdecl Pickup_Health(int a1, int a2);
int __cdecl RespawnItem(int a1);
int __cdecl Touch_Item_Auto(int a1, int a2, int a3);
unsigned int __cdecl Touch_Item(int a1, _DWORD *a2, int a3);
int sub_4BB94();
int __cdecl DroppedItemClearOwner(int a1);
_DWORD *__cdecl LaunchItem(int a1, int a2, _DWORD *a3, int a4);
int __cdecl Drop_Item(int, int, float, int); // idb
int __cdecl Drop_Weapon(int a1, int a2, int a3);
int __cdecl Use_Item(int a1);
int __cdecl FinishSpawningItem(void *s); // idb
_DWORD *ClearRegisteredItems();
int SaveRegisteredItems();
_DWORD *__cdecl RegisterItem(int a1, int a2);
int __cdecl IsItemRegistered(int a1);
int (__cdecl *__cdecl G_SpawnItem(int a1, int a2))(void *s);
int __cdecl G_BounceItem(int a1, int a2);
void __cdecl G_RunItem(void *s);
int __cdecl sub_4D844(float); // idb
void sub_4D882();
int __cdecl vmMain(int, int, unsigned int seed, int, int); // idb
int G_Printf(char *format, ...);
_DWORD *G_DPrintf(char *format, ...);
int G_Error(char *format, ...);
int G_Error_Localized(char *format, ...);
int __cdecl sub_4DC12(int a1, int a2);
int __cdecl G_GetActivateEnt(int, void *base); // idb
int __cdecl G_CheckForCursorHints(int a1);
_DWORD *__cdecl G_CheckForPreventFriendlyFire(_DWORD *a1);
int G_FindTeams();
int G_RegisterCvars();
int G_UpdateCvars();
int G_SetUICvars();
_DWORD *G_FreeEntities();
_DWORD *__cdecl G_InitGame(int a1, unsigned int seed, int a3, int a4);
int __cdecl G_ShutdownGame(int a1);
int Com_Error(int a1, char *format, ...);
int Com_Printf(char *format, ...);
_DWORD *Com_DPrintf(char *format, ...);
_DWORD *SendScoreboardMessageToAllIntermissionClients();
int __cdecl sub_4F818(_DWORD *a1, _DWORD *a2);
_DWORD *CalculateRanks();
int ExitLevel();
_DWORD *G_LogPrintf(char *format, ...);
_DWORD *CheckVote();
_DWORD *CheckMatchTimeout();
int G_UpdateObjectiveToClients();
int G_UpdateHudElemsToClients();
int __cdecl G_RunThink(int a1);
int *DebugDumpAnims();
int __cdecl G_XAnimUpdateEnt(int a1);
int G_XAnimUpdate();
void *__cdecl sub_50409(void *s);
int __cdecl G_RunFrame(int a1);
void sub_50C9E();
int __cdecl SP_info_camp(int a1);
int __cdecl SP_info_null(void *s); // idb
int __cdecl SP_info_notnull(int a1);
int __cdecl SP_light(void *s); // idb
int __cdecl TeleportPlayer(_DWORD *a1, _DWORD *a2, int a3);
void SP_misc_teleporter_dest();
int __cdecl SP_misc_model(void *s); // idb
int __cdecl use_corona(int a1);
int __cdecl SP_corona(void *s); // idb
_BOOL4 G_IsInMatchTimeout();
int *G_InitTurrets();
int __cdecl sub_510A9(int a1, int a2, int a3);
int __cdecl sub_512A2(int a1, char *a2, int a3);
int __cdecl sub_51389(int a1, float *a2);
int __cdecl sub_520D3(int a1, int a2);
int __cdecl sub_5227C(_DWORD *a1, int a2);
int __cdecl sub_52305(int a1, int a2);
int __cdecl sub_523FD(int a1);
unsigned int __cdecl G_ClientStopUsingTurret(int a1);
int __cdecl turret_think_client(int a1);
int __cdecl sub_526A2(int a1, int a2, int a3);
int __cdecl sub_52951(int a1, int a2);
_DWORD *__cdecl turret_think(_DWORD *a1);
float *__cdecl turret_think_init(_DWORD *a1);
int __cdecl turret_controller(_DWORD *a1, int a2);
_BOOL4 __cdecl sub_52D73(int a1, int a2);
int __cdecl G_FreeTurret(int a1);
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2);
// int __usercall turret_use@<eax>(long double a1@<st0>, int a2, int a3);
int __cdecl G_SpawnTurret(int a1, char a2);
int __cdecl SP_turret(int a1);
int __cdecl misc_spawner_think(int a1);
int __cdecl misc_spawner_use(int a1);
int __cdecl SP_misc_spawner(int a1);
float *__cdecl miscGunnerEnemyScan(int a1);
long double __cdecl sub_53AB3(float a1);
void sub_53ACC();
void __cdecl G_MissileLandAngles(int a1, float *a2, int a3, int a4);
_BOOL4 __cdecl G_BounceMissile(int a1, int a2);
int __cdecl G_MissileImpact(int a1, int a2);
int __cdecl Concussive_think(int a1);
_DWORD *__cdecl Concussive_fx(float *a1);
int __cdecl G_ExplodeMissile(int a1);
int __cdecl G_MissileDie(int a1, int a2);
void __cdecl G_MissileTrace(int a1, float *a2, float *a3, int a4, int a5);
void *__cdecl G_RunMissile(void *s);
int __cdecl DynaSink(int a1);
int __cdecl fire_grenade(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4);
int __cdecl fire_rocket(_DWORD *a1, _DWORD *a2, float *a3);
void sub_5582E();
_DWORD *__cdecl G_TestEntityPosition(_DWORD *a1, int a2);
int __cdecl G_CreateRotationMatrix(int a1, int a2);
int *__cdecl G_TransposeMatrix(int a1, int a2);
float *__cdecl G_RotatePoint(float *a1, float *a2);
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, int a4);
int __cdecl sub_560D7(int a1, float *a2, float *a3, _DWORD *a4);
int __cdecl G_MoverTeam(int a1);
int __cdecl G_RunMover(int a1);
int __cdecl SetMoverState(int a1, int a2, int a3);
int __cdecl MatchTeam(int a1, int a2, int a3);
int __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3);
int __cdecl ReturnToPos1(int a1);
int __cdecl ReturnToPos2(int a1);
int __cdecl GotoPos3(int a1);
int __cdecl ReturnToPos1Rotate(int a1);
void __cdecl Reached_BinaryMover(int a1);
_BOOL4 __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3);
void __cdecl Use_BinaryMover(int a1, int a2, int a3);
void __cdecl InitMover(int a1);
int __cdecl InitMoverRotate(int a1);
int __cdecl Blocked_Door(int, void *s); // idb
int __cdecl Blocked_DoorRotate(int, void *s); // idb
int __cdecl Touch_DoorTrigger(int a1, int a2);
int __cdecl sub_58C48(int a1);
int __cdecl Think_SpawnNewDoorTrigger(int a1);
int __cdecl sub_58E62(int a1);
int __cdecl Think_SpawnNewAutoDoorTrigger(int a1);
int __cdecl Think_MatchTeam(int a1);
int __cdecl finishSpawningKeyedMover(int a1);
int __cdecl Door_reverse_sounds(_BYTE *a1);
int __cdecl DoorSetSounds(_BYTE *a1);
int __cdecl G_TryDoor(int a1, int a2, int a3);
int (__cdecl *__cdecl SP_func_door(int a1))(int a1);
int __cdecl Use_Static(int a1);
void __cdecl Static_Pain(int a1);
int __cdecl SP_func_leaky(_DWORD *a1);
int __cdecl SP_func_static(int a1);
int __cdecl Use_Func_Rotate(_DWORD *a1);
int __cdecl SP_func_rotating(float *a1);
int __cdecl SP_func_bobbing(int a1);
int __cdecl SP_func_pendulum(int a1);
int (__cdecl *__cdecl SP_func_door_rotating(int a1))(int, void *s);
void __cdecl use_trigger_use(int a1, int a2);
int __cdecl trigger_use(int a1);
int __cdecl G_Activate(int a1, int a2);
void sub_5A75B();
int __cdecl GScr_AllocString(int a1);
int GScr_LoadConsts();
_WORD *Scr_LoadLevel();
int __cdecl sub_5B505(int a1, int a2, int a3);
int GScr_LoadGameTypeScript();
int sub_5B6BE();
int sub_5B757();
int __cdecl sub_5B7CA(int a1);
int GScr_LoadScripts();
int GScr_FreeScripts();
_DWORD *__cdecl sub_5B894(unsigned int a1);
_DWORD *__cdecl sub_5B8E6(unsigned int a1);
_DWORD *sub_5B9AD();
_DWORD *sub_5BA10();
int __cdecl Scr_LocalizationError(int, char *format); // idb
int *__cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4);
int __cdecl Scr_MakeGameMessage(int a1, char a2);
int sub_5C005();
int sub_5C033();
int sub_5C061();
int sub_5C143();
void sub_5C231();
int sub_5C236();
int sub_5C298();
int sub_5C323();
int sub_5C37B();
int sub_5C3B5();
int sub_5C3EF();
int sub_5C5A2();
_DWORD *sub_5C5CE();
int sub_5C627();
int sub_5C6CC();
int sub_5C7CA();
int sub_5C837();
int sub_5C897();
int sub_5C932();
int sub_5CA21();
int sub_5CACC();
int __cdecl sub_5CB37(unsigned int a1);
int __cdecl sub_5CC31(unsigned int a1);
int __cdecl sub_5CD67(unsigned int a1);
int __cdecl sub_5CD98(unsigned int a1);
int __cdecl sub_5CDF2(unsigned int a1);
int __cdecl sub_5CE73(unsigned int a1);
int __cdecl sub_5CEEB(unsigned int a1);
int __cdecl sub_5CF68(unsigned int a1);
int __cdecl sub_5D180(unsigned int a1);
int __cdecl sub_5D1B1(unsigned int a1);
int __cdecl sub_5D2B9(unsigned int a1);
int __cdecl sub_5D30E(unsigned int a1);
int __cdecl sub_5D3B0(unsigned int a1);
int __cdecl sub_5D413(unsigned int a1);
int __cdecl sub_5D4A2(unsigned int a1);
_DWORD *__cdecl sub_5D6FA(unsigned int a1);
_DWORD *__cdecl sub_5D75B(unsigned int a1);
int __cdecl sub_5D7BC(unsigned int a1);
int __cdecl sub_5D836(unsigned int a1);
int __cdecl sub_5D8A9(unsigned int a1);
_DWORD *__cdecl sub_5D908(unsigned int a1);
int __cdecl sub_5D955(unsigned int a1);
int __cdecl sub_5DA0D(unsigned int a1);
int __cdecl sub_5DA6A(unsigned int a1);
int __cdecl sub_5DAEB(unsigned int a1);
unsigned int __cdecl ScrCmd_Show(unsigned int a1);
int __cdecl ScrCmd_Hide(unsigned int a1);
int __cdecl sub_5DC3C(unsigned int a1);
_DWORD *__cdecl sub_5DC99(unsigned int a1);
int __cdecl G_GetHintStringIndex(int, char *s1); // idb
_DWORD *__cdecl sub_5DED8(unsigned int a1);
int __cdecl sub_5DFDB(unsigned int a1);
_DWORD *__cdecl GScr_EnableGrenadeTouchDamage(unsigned int a1);
_DWORD *__cdecl GScr_DisableGrenadeTouchDamage(unsigned int a1);
unsigned int __cdecl GScr_EnableGrenadeBounce(unsigned int a1);
int __cdecl GScr_DisableGrenadeBounce(unsigned int a1);
int *G_InitObjectives();
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2);
int __cdecl sub_5E211(int a1);
_DWORD *__cdecl sub_5E279(_DWORD *a1);
int __cdecl sub_5E2CC(int a1, int a2);
float *sub_5E3AA();
_DWORD *sub_5E56C();
int sub_5E618();
int sub_5E710();
int sub_5E79F();
int sub_5E8B1();
char *sub_5E96D();
_DWORD *sub_5EA6F();
int sub_5EB86();
int sub_5EC2F();
int sub_5EC53();
int sub_5ED7B();
int sub_5EED3();
int sub_5EEFF();
int __cdecl GScr_GetScriptMenuIndex(int a1);
int sub_5F0BC();
int __cdecl GScr_GetStatusIconIndex(_BYTE *a1);
int sub_5F289();
int __cdecl GScr_GetHeadIconIndex(_BYTE *a1);
int sub_5F456();
int sub_5F6A8();
int sub_5F715();
int sub_5F757();
int sub_5F7D9();
int sub_5F862();
int sub_5F8AC();
int sub_5F8F6();
int sub_5F978();
int sub_5FA0F();
int sub_5FAA6();
int sub_5FAF6();
int sub_5FB4E();
int sub_5FBA6();
int sub_5FBFD();
int sub_5FC46();
int sub_5FCDC();
int sub_5FD38();
int sub_5FD8D();
int sub_5FDD5();
int sub_5FE2D();
int sub_5FE85();
int sub_5FEDD();
int sub_5FF2B();
int sub_5FFE4();
int sub_6007E();
int sub_600C4();
int sub_6010A();
int sub_601AE();
char *sub_60218();
int sub_6026C();
int sub_60364();
int sub_60421();
_DWORD *sub_60538();
int sub_60600();
int sub_60632();
int sub_60751();
int sub_60878();
int sub_608D8();
int sub_60A3E();
int sub_60BDA();
int __cdecl sub_60DC4(char, float, float, float, float, float, float, float); // idb
int sub_60F3A();
int sub_61004();
int sub_610F2();
int sub_61161();
int sub_611B0();
int sub_61286();
int sub_613CF();
int sub_61443();
int sub_614C7();
_DWORD *sub_61570();
_DWORD *sub_61689();
int sub_61709();
int sub_617F7();
int GScr_GetNumParts();
int GScr_GetPartName();
int sub_619F9();
int __cdecl sub_61A92(unsigned int a1);
int __cdecl sub_61BFB(unsigned int a1);
int __cdecl sub_61C71(unsigned int a1);
int __cdecl sub_61D95(unsigned int a1);
void __cdecl sub_61E36(unsigned int a1);
void __cdecl sub_61EBC(unsigned int a1);
void __cdecl sub_61F35(unsigned int a1);
void __cdecl sub_61FBB(unsigned int a1);
int __cdecl sub_62034(unsigned int a1);
int sub_62238();
int sub_622E6();
int sub_62383();
int sub_623B4();
int sub_624F4();
void Scr_Prof_Begin();
void Scr_Prof_End();
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2);
int __cdecl sub_625EA(char **a1);
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2);
int __cdecl Scr_SetOrigin(int a1);
int __cdecl Scr_SetAngles(int a1);
int __cdecl Scr_SetHealth(_DWORD *a1);
int __cdecl GScr_AddVector(int a1);
int __cdecl GScr_AddEntity(int a1);
int Scr_ParseGameTypeList();
int __cdecl Scr_GetGameTypeNameForScript(int a1);
_BOOL4 __cdecl Scr_IsValidGameType(int a1);
int Scr_LoadGameType();
int Scr_StartupGameType();
int __cdecl Scr_PlayerConnect(int a1);
int __cdecl Scr_PlayerDisconnect(int a1);
int __cdecl Scr_PlayerDamage(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10);
int __cdecl Scr_PlayerKilled(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int Scr_LoadRead();
int __cdecl sub_62F9D(float); // idb
float *__cdecl sub_62FDB(float a1, float *a2, float *a3);
_BYTE *__cdecl sub_62FF3(_BYTE *a1);
void sub_63047();
int __cdecl sub_6304C(int, int, float, float, float, int, int, int); // idb
// _DWORD *__usercall Reached_ScriptMover@<eax>(long double a1@<st0>, int a2);
int __cdecl sub_63546(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_63A5E(int, int, float, float, float, int, int, int, int, int, int, int); // idb
int __cdecl sub_63FAE(int, int, float, float, float); // idb
int __cdecl sub_6404F(int, int, float); // idb
int __cdecl sub_64137(int, int, float, float, float); // idb
int __cdecl sub_641D8(int, int, float, float, float); // idb
int __cdecl InitScriptMover(_DWORD *a1);
int __cdecl SP_script_brushmodel(int a1);
int __cdecl SP_script_model(int a1);
_DWORD *__cdecl SP_script_origin(_DWORD *a1);
void __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3);
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1);
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1);
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_MoveX(unsigned int a1);
int __cdecl ScriptEntCmd_MoveY(unsigned int a1);
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1);
// int __usercall ScriptEntCmd_RotateTo@<eax>(long double a1@<st0>, unsigned int a2);
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2);
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1);
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1);
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1);
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1);
int __cdecl ScriptEntCmd_Solid(unsigned int a1);
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1);
int __cdecl ScriptEnt_GetMethod(char **a1);
void sub_651A3();
int __cdecl G_SpawnString(char *s1, int, int); // idb
int __cdecl G_SpawnFloat(char *s1, int, int); // idb
int __cdecl G_SpawnInt(char *s1, int, int); // idb
int __cdecl G_SpawnVector(char *s1, int, int); // idb
int sub_65344();
int __cdecl sub_6536A(int a1, int a2);
int __cdecl sub_653FB(int, char *nptr, int); // idb
void __cdecl sub_654A2(int a1, char *s, int a3);
int __cdecl sub_65669(int a1);
char **__cdecl G_DuplicateEntityFields(int a1, int a2);
int __cdecl G_DuplicateScriptFields(_DWORD *a1, _DWORD *a2);
int G_CallSpawn();
int __cdecl G_CallSpawnEntity(int a1);
int __cdecl G_NewString(char *s); // idb
int GScr_AddFieldsForEntity();
int GScr_AddFieldsForRadiant();
int __cdecl Scr_SetEntityField(int a1, int a2);
int __cdecl Scr_SetGenericField(int a1, int a2, int a3);
int __cdecl Scr_SetObjectField(int a1, int a2, int a3);
int __cdecl Scr_GetEntityField(int a1, int a2);
int __cdecl Scr_GetGenericField(int a1, int a2, int a3);
int __cdecl Scr_GetObjectField(int a1, int a2, int a3);
int *__cdecl Scr_FreeEntityConstStrings(int a1);
int __cdecl Scr_FreeEntity(_DWORD *a1);
int __cdecl Scr_AddEntity(_DWORD *a1);
_DWORD *__cdecl Scr_GetEntity(int a1);
int __cdecl Scr_FreeHudElem(int a1);
int __cdecl Scr_AddHudElem(int a1);
_DWORD *__cdecl Scr_GetHudElem(int a1);
int __cdecl Scr_ExecEntThread(_DWORD *a1, int a2, int a3);
int __cdecl Scr_AddExecEntThread(_DWORD *a1, int a2, int a3);
int __cdecl Scr_Notify(_DWORD *a1, unsigned __int16 a2, int a3);
int Scr_GetEnt();
int Scr_GetEntArray();
int __cdecl GScr_SetDynamicEntityField(_DWORD *a1, unsigned __int16 a2);
int G_SpawnGEntityFromSpawnVars();
char *__cdecl G_AddSpawnVarToken(char *s);
int G_ParseSpawnVars();
_DWORD *SP_worldspawn();
_DWORD *G_SpawnEntitiesFromString();
void sub_66BDC();
int __cdecl sub_66BE0(char *a1, _DWORD *a2);
int sub_66D58();
_BOOL4 __cdecl G_FilterPacket(char *a1);
int __cdecl sub_66F3C(char *a1);
char *G_ProcessIPBans();
int Svcmd_AddIP_f();
int Svcmd_RemoveIP_f();
int Svcmd_EntityList_f();
int __cdecl ClientForString(char *nptr); // idb
int ConsoleCommand();
void sub_6762C();
int __cdecl dllEntry(int a1);
long double __cdecl sub_6764B(float a1);
int __cdecl PASSFLOAT(int a1);
int __cdecl trap_Printf(int a1);
int __cdecl trap_Error(int a1);
int __cdecl trap_Error_Localized(int a1);
int trap_Milliseconds();
int trap_Argc();
int __cdecl trap_Argv(int a1);
int __cdecl trap_Hunk_AllocInternal(int a1);
int __cdecl trap_Hunk_AllocLowInternal(int a1);
int __cdecl trap_Hunk_AllocAlignInternal(int a1);
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1);
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1);
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1);
int __cdecl trap_FS_FOpenFile(int a1);
int __cdecl trap_FS_Read(int a1);
int __cdecl trap_FS_Write(int a1);
int __cdecl trap_FS_Rename(int a1);
int __cdecl trap_FS_FCloseFile(int a1);
int __cdecl trap_FS_GetFileList(int a1);
int __cdecl trap_MapExists(int a1);
int __cdecl trap_SendConsoleCommand(int a1);
int __cdecl trap_Cvar_Register(int a1);
int __cdecl trap_Cvar_Update(int a1);
int __cdecl trap_Cvar_Set(int a1);
int __cdecl trap_Cvar_VariableIntegerValue(int a1);
long double __cdecl trap_Cvar_VariableValue(int a1);
int __cdecl trap_Cvar_VariableStringBuffer(int a1);
int __cdecl trap_LocateGameData(int a1);
int __cdecl trap_GetGuid(int a1);
int __cdecl trap_DropClient(int a1);
int __cdecl trap_SendServerCommand(int a1);
int __cdecl trap_SetConfigstring(int a1);
int __cdecl trap_GetConfigstring(int a1);
int __cdecl trap_GetConfigstringConst(int a1);
int __cdecl trap_IsLocalClient(int a1);
int __cdecl trap_GetClientPing(int a1);
int __cdecl trap_GetUserinfo(int a1);
int __cdecl trap_SetUserinfo(int a1);
int __cdecl trap_GetServerinfo(int a1);
int __cdecl trap_SetBrushModel(int a1);
int __cdecl trap_Trace(int a1);
int __cdecl trap_TraceCapsule(int a1);
int __cdecl trap_SightTrace(int a1);
int __cdecl trap_SightTraceCapsule(int a1);
int __cdecl trap_SightTraceToEntity(int a1);
int __cdecl trap_CM_BoxTrace(int a1);
int __cdecl trap_CM_CapsuleTrace(int a1);
int __cdecl trap_CM_BoxSightTrace(int a1);
int __cdecl trap_CM_CapsuleSightTrace(int a1);
int __cdecl trap_LocationalTrace(int a1);
int __cdecl trap_PointContents(int a1);
int __cdecl trap_InPVS(int a1);
int __cdecl trap_InPVSIgnorePortals(int a1);
int __cdecl trap_InSnapshot(int a1);
int __cdecl trap_AdjustAreaPortalState(int a1);
int __cdecl trap_AreasConnected(int a1);
int __cdecl trap_LinkEntity(int a1);
int __cdecl trap_UnlinkEntity(int a1);
int __cdecl trap_EntitiesInBox(int a1);
int __cdecl trap_EntityContact(int a1);
int __cdecl trap_EntityContactCapsule(int a1);
int __cdecl trap_GetUsercmd(int a1);
int __cdecl trap_GetEntityToken(int a1);
int __cdecl trap_AddDebugString(int a1, int a2, int a3, int a4);
int __cdecl trap_AddDebugLine(int a1);
int __cdecl trap_SetArchive(int a1);
int __cdecl trap_RealTime(int a1);
int __cdecl trap_SnapVector(int a1);
int __cdecl trap_Com_SoundAliasString(int); // weak
int __cdecl trap_Com_PickSoundAlias(int a1);
int __cdecl trap_Com_SoundAliasIndex(int a1);
int __cdecl trap_SurfaceTypeFromName(int a1);
int __cdecl trap_SurfaceTypeToName(int a1);
int __cdecl trap_Z_MallocInternal(int a1);
int __cdecl trap_Z_FreeInternal(int a1);
int trap_AddTestClient();
int __cdecl trap_GetArchivedClientInfo(int a1);
int __cdecl trap_XAnimCreateTree(int a1);
int __cdecl trap_XAnimCreateSmallTree(int a1);
int __cdecl trap_XAnimFreeSmallTree(int a1);
int __cdecl trap_XModelExists(int a1);
int __cdecl trap_XModelGet(int a1);
int __cdecl trap_DObjCreate(int a1);
int __cdecl trap_SafeDObjFree(int a1);
int __cdecl trap_DObjExists(_DWORD *a1);
int __cdecl trap_XAnimGetAnims(int a1);
// _DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2);
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4, int a5, int a6, unsigned __int16 a7, int a8);
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3);
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimClearTree(int a1);
int __cdecl trap_XAnimHasTime(int a1);
int __cdecl trap_XAnimIsPrimitive(int a1);
int __cdecl trap_XAnimGetLength(int a1);
long double __cdecl trap_XAnimGetLengthSeconds(int a1);
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7);
int __cdecl trap_XAnimCalcAbsDelta(int a1);
int __cdecl trap_XAnimCalcDelta(int a1);
int __cdecl trap_XAnimGetRelDelta(int a1, int a2, int a3, int a4, int a5);
int __cdecl trap_XAnimGetAbsDelta(int a1, int a2, int a3, int a4);
int __cdecl trap_XAnimIsLooped(int a1);
int __cdecl trap_XAnimNotetrackExists(int a1);
long double __cdecl trap_XAnimGetTime(int a1);
long double __cdecl trap_XAnimGetWeight(int a1);
int __cdecl trap_DObjDumpInfo(_DWORD *a1);
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1);
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1);
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3);
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2);
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1);
int __cdecl trap_DObjCalcAnim(_DWORD *a1);
int __cdecl trap_DObjCalcSkel(_DWORD *a1);
int __cdecl trap_XAnimLoadAnimTree(int a1);
int __cdecl trap_XAnimSaveAnimTree(int a1);
int __cdecl trap_XAnimCloneAnimTree(int a1);
int __cdecl trap_DObjNumBones(_DWORD *a1);
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1);
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1);
int __cdecl trap_DObjDisplayAnim(_DWORD *a1);
int __cdecl trap_XAnimHasFinished(int a1);
int __cdecl trap_XAnimGetNumChildren(int a1);
// _DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, int a2);
int __cdecl trap_XModelNumBones(int a1);
int __cdecl trap_XModelGetBoneNames(int a1);
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1);
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1);
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1);
int __cdecl trap_XAnimGetAnimName(int a1);
int __cdecl trap_DObjGetTree(_DWORD *a1);
int __cdecl trap_XAnimGetAnimTreeSize(int a1);
int __cdecl trap_XModelDebugBoxes(_DWORD *a1);
int __cdecl trap_GetWeaponInfoMemory(int a1);
int __cdecl trap_FreeWeaponInfoMemory(int a1);
int trap_FreeClientScriptPers();
int trap_ResetEntityParsePoint();
void sub_6977D();
_DWORD *target_location_linkup();
int __cdecl SP_target_location(int a1);
void sub_6990C();
_BOOL4 __cdecl OnSameTeam(int a1, int a2);
_BOOL4 __cdecl InSameSquad(int a1, int a2);
int __cdecl Team_GetLocation(int *a1);
int __cdecl Team_GetLocationMsg(int, char *s, size_t maxlen); // idb
int __cdecl TeamplayInfoMessage(int a1);
int CheckTeamStatus();
void sub_69F61();
int __cdecl G_Trigger(int a1, int a2);
int __cdecl InitTrigger(int a1);
int __cdecl InitSentientTrigger(int a1);
int __cdecl multi_wait(int a1);
int (__cdecl *__cdecl multi_trigger(int a1, int a2))(int);
int __cdecl Use_Multi(int a1, int a2, int a3);
int __cdecl Touch_Multi(int a1, int a2);
int __cdecl SP_trigger_multiple(int a1);
int __cdecl hurt_touch(int a1, int a2);
void __cdecl hurt_think(void *s);
void __cdecl hurt_use(int a1);
int __cdecl SP_trigger_hurt(int a1);
int __cdecl SP_trigger_once(_DWORD *a1);
int __cdecl Respond_trigger_damage(int a1, int a2);
int (__cdecl *__cdecl Activate_trigger_damage(int a1, int a2, int (__cdecl *a3)(int), int a4))(int);
int __cdecl Use_trigger_damage(int a1, int a2);
int __cdecl Pain_trigger_damage(int a1, int a2, int a3, int a4, int a5);
int __cdecl Die_trigger_damage(int a1, int a2, int a3, int a4, int a5);
int __cdecl SP_trigger_damage(int a1);
int __cdecl G_CheckHitTriggerDamage(int a1, int *a2, int a3, int a4, int a5);
int __cdecl G_GrenadeTouchTriggerDamage(int a1, int *a2, int a3, int a4, int a5);
int __cdecl explosive_indicator_think(_DWORD *a1);
int __cdecl SP_trigger_lookat(_DWORD *a1);
void sub_6B2FA();
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, int a5);
int __cdecl G_LocalizedStringIndex(char *s2); // idb
int __cdecl G_ShaderIndex(char *s2); // idb
int __cdecl G_ModelIndex(char *s2); // idb
int __cdecl sub_6B592(int a1);
int __cdecl G_ModelName(int a1);
int __cdecl G_TagIndex(char *s2); // idb
int __cdecl G_EffectIndex(char *s2); // idb
int __cdecl G_ShellShockIndex(char *s2); // idb
int __cdecl G_SoundAliasIndex(char *s2); // idb
int __cdecl G_GetGameId(_DWORD *a1);
int __cdecl G_DObjUpdate(int a1);
int __cdecl G_SetModel(int, char *s2); // idb
int __cdecl G_EntAttach(int, char *s2, int, int); // idb
int __cdecl G_EntDetach(int, char *s2, int); // idb
int __cdecl G_EntDetachAll(int a1);
int __cdecl sub_6BCC4(int a1, int a2, _BYTE *a3);
int __cdecl G_EntLinkTo(int a1, int a2, _BYTE *a3);
int __cdecl G_EntLinkToWithOffset(int a1, int a2, _BYTE *a3, _DWORD *a4, int a5);
_DWORD *__cdecl G_EntUnlink(int a1);
int __cdecl G_EntIsLinkedTo(int a1, int a2);
int __cdecl G_UpdateTagInfo(int a1, int a2);
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2);
int __cdecl G_CalcTagParentAxis(int a1, _DWORD *a2);
int __cdecl G_CalcTagParentRelAxis(int a1, int a2);
int __cdecl G_CalcTagAxis(_DWORD *a1, int a2);
void __cdecl G_SetFixedLink(int a1, int a2);
int __cdecl G_GeneralLink(int a1);
int __cdecl Think_GeneralLink(int); // weak
int __cdecl G_SafeDObjFree(_DWORD *a1);
int __cdecl G_DObjUpdateServerTime(int a1, int a2);
int __cdecl sub_6C5F3(int a1, _DWORD *a2, float *a3, int a4);
int __cdecl G_DObjSetLocalTag(int a1, int a2, int a3, _DWORD *a4, float *a5);
int __cdecl G_DObjSetControlTagAngles(int a1, int a2, int a3, float *a4);
int __cdecl G_DObjCalcPose(int a1);
int __cdecl G_DObjCalcBone(int a1, int a2);
int __cdecl G_DObjGetLocalTagMatrix(int a1, int a2);
int __cdecl G_DObjGetWorldTagMatrix(_DWORD *a1, int a2, int a3);
_DWORD *__cdecl G_Find(int a1, int a2, __int16 a3);
_DWORD *__cdecl G_FindStr(int a1, int a2, int a3);
int __cdecl G_PickTarget(unsigned __int16 a1);
char *__cdecl vtos(float *a1);
char *__cdecl vtosf(float *a1);
int __cdecl G_SetMovedir(float *a1, _DWORD *a2);
int __cdecl G_InitGentity(int a1);
int G_Spawn();
_DWORD *G_SpawnPlayerClone();
int *__cdecl G_FreeEntityRefs(int *a1);
int __cdecl G_FreeEntity(void *s); // idb
_DWORD *__cdecl G_TempEntity(int *a1, int a2);
int __cdecl G_KillBox(int a1);
int __cdecl G_AddPredictableEvent(int a1, int a2, char a3);
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3);
int __cdecl G_PlaySoundAliasAtPoint(int a1, int a2);
int __cdecl G_PlaySoundAlias(int a1, int a2);
int __cdecl G_AnimScriptSound(int, char *s2); // idb
int __cdecl G_SetOrigin(_DWORD *a1, _DWORD *a2);
int __cdecl G_SetAngle(_DWORD *a1, _DWORD *a2);
_BOOL4 __cdecl infront(float *a1, float *a2);
int DebugLine();
_WORD *__cdecl G_SetConstString(_WORD *a1, int a2);
void sub_6DB69();
void __cdecl Weapon_Melee(_DWORD *a1, float *a2);
int *__cdecl SnapVectorTowards(int a1, int a2);
int __cdecl Bullet_Endpos(float, int, int); // idb
int __cdecl Bullet_Fire(int, float, int, int, int); // idb
int __cdecl Bullet_Fire_Extended(_DWORD *a1, _DWORD *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8);
float *__cdecl weapon_grenadelauncher_fire(int a1, int a2, int a3);
int __cdecl Weapon_RocketLauncher_Fire(int, float, int); // idb
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2);
void __cdecl CalcMuzzlePoint(int a1, float *a2);
int __cdecl CalcMuzzlePoints(int a1, int a2);
int __cdecl FireWeapon(int a1);
int __cdecl FireWeaponMelee(int a1);
void sub_6EE32();
int __cdecl Com_BeginParseSession(char *src); // idb
char *Com_EndParseSession();
void *Com_ResetParseSessions();
int __cdecl Com_SetSpaceDelimited(int a1);
int __cdecl Com_SetCSV(int a1);
int __cdecl Com_SetParseNegativeNumbers(int a1);
int Com_GetCurrentParseLine();
int Com_ScriptError(char *format, ...);
int Com_ScriptWarning(char *format, ...);
int Com_UngetToken();
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2);
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2);
_BYTE *__cdecl sub_6F214(_BYTE *a1, _DWORD *a2);
int __cdecl Com_Compress(_BYTE *a1);
int Com_GetLastTokenPos();
void *__cdecl sub_6F3CC(_BYTE **a1, int a2);
void *__cdecl sub_6F55E(char **a1, int a2);
void *__cdecl Com_Parse(char **a1);
void *__cdecl Com_ParseOnLine(char **a1);
int __cdecl Com_MatchToken(int, char *s2, int); // idb
int __cdecl Com_SkipBracedSection(_DWORD *a1, int a2);
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1);
char *__cdecl Com_ParseRestOfLine(int a1);
long double __cdecl Com_ParseFloat(int a1);
int __cdecl Com_ParseInt(int a1);
int __cdecl Com_Parse1DMatrix(int a1, int a2, int a3);
int __cdecl Com_Parse2DMatrix(int a1, int a2, int a3, int a4);
int __cdecl Com_Parse3DMatrix(int a1, int a2, int a3, int a4, int a5);
void sub_7008C();
int __cdecl ColorIndex(char a1);
long double __cdecl Com_Clamp(float a1, float a2, float a3);
_BYTE *__cdecl Com_SkipPath(_BYTE *a1);
_BYTE *__cdecl Com_StripExtension(_BYTE *a1, _BYTE *a2);
_BYTE *__cdecl Com_StripFilename(char *s, char *dest);
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen);
int __cdecl Com_BitCheck(int a1, int a2);
int __cdecl Com_BitSet(int a1, int a2);
int __cdecl Com_BitClear(int a1, int a2);
int __cdecl BigShort(__int16 a1);
int __cdecl BigLong(int a1);
// int __userpurge BigLong64@<eax>(int a1, int a2, int a3);
// int __userpurge LittleLong64@<eax>(int a1, int a2, int a3);
int __cdecl BigFloat(int a1);
int __cdecl ShortSwap(__int16 a1);
int __cdecl ShortNoSwap(__int16 a1);
int __cdecl LongSwap(int a1);
int __cdecl LongNoSwap(int a1);
// _DWORD *__userpurge Long64Swap@<eax>(_DWORD *a1, int a2, int a3);
// _DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3);
long double __cdecl FloatSwap(int a1);
long double __cdecl FloatNoSwap(float a1);
long double (__cdecl *Swap_Init())(float a1);
_BOOL4 __cdecl Q_isprint(int a1);
_BOOL4 __cdecl Q_islower(int a1);
_BOOL4 __cdecl Q_isupper(int a1);
_BOOL4 __cdecl Q_isalpha(int a1);
_BOOL4 __cdecl Q_isnumeric(int a1);
_BOOL4 __cdecl Q_isalphanumeric(int a1);
_BOOL4 __cdecl Q_isforfilename(int a1);
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2);
char *__cdecl Q_strncpyz(char *dest, char *src, int a3);
int __cdecl Q_stricmpn(char *a1, char *a2, int a3);
int __cdecl Q_strncmp(char *a1, char *a2, int a3);
int __cdecl Q_stricmp(int a1, int a2);
_BYTE *__cdecl Q_strlwr(_BYTE *a1);
_BYTE *__cdecl Q_strupr(_BYTE *a1);
int __cdecl Q_strcat(char *s, int, char *src); // idb
int __cdecl Q_DrawStrlen(_BYTE *a1);
char *__cdecl Q_CleanStr(char *a1);
int __cdecl Q_CleanCharacter(char a1);
int Com_sprintf(char *s, size_t maxlen, char *format, ...);
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3);
int __cdecl Q_strcasecmp(int a1, int a2);
char *va(char *format, ...);
_DWORD *__cdecl tv(int a1, int a2, int a3);
char *__cdecl Info_ValueForKey(char *s, int a2);
_BYTE *__cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3);
char *__cdecl Info_RemoveKey(char *s, char *s1);
char *__cdecl Info_RemoveKey_Big(char *s, char *s1);
_BOOL4 __cdecl Info_Validate(char *s);
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3);
char *__cdecl Info_SetValueForKey_Big(char *s, char *s1, int a3);
_BOOL4 __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, char *s, int a5, int a6, int a7);
long double __cdecl GetLeanFraction(float a1);
long double __cdecl UnGetLeanFraction(float a1);
void __cdecl AddLeanToPosition(int a1, int a2, float a3, float a4, float a5);
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3);
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3);
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3);
int Q_GetDecimalDelimiter();
int __cdecl Q_LocalizedFloatToString(float, char *s, int, int, int); // idb
long double __cdecl sub_71E69(float a1);
void sub_71E82();
int __cdecl Scr_GetBool(int a1);
int __cdecl Scr_GetInt(int a1);
// int __userpurge Scr_GetAnim@<eax>(int a1, int a2, int a3);
// int __userpurge Scr_GetAnimTree@<eax>(int a1, int a2);
int __cdecl Scr_GetFloat(int a1);
int __cdecl Scr_GetString(int a1);
int __cdecl Scr_GetConstString(int a1);
int __cdecl Scr_GetDebugString(int a1);
int __cdecl Scr_GetIString(int a1);
int __cdecl Scr_GetConstIString(int a1);
int __cdecl Scr_GetVector(int a1, int a2);
int __cdecl Scr_GetFunc(int a1);
int __cdecl Scr_GetEntityNum(int a1, int a2);
int __cdecl Scr_GetType(int a1);
int __cdecl Scr_GetPointerType(int a1);
int Scr_GetNumParam();
int __cdecl Scr_AddBool(int a1);
int __cdecl Scr_AddInt(int a1);
int __cdecl Scr_AddFloat(int a1);
int __cdecl Scr_AddAnim(int a1);
int Scr_AddUndefined();
int __cdecl Scr_AddEntityNum(int a1, int a2);
int Scr_AddStruct();
int __cdecl Scr_AddString(int a1);
int __cdecl Scr_AddIString(int a1);
int __cdecl Scr_AddConstString(unsigned __int16 a1);
int __cdecl Scr_AddVector(int a1);
int __cdecl Scr_AddObject(unsigned __int16 a1);
int Scr_MakeArray();
int Scr_AddArray();
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1);
int __cdecl Scr_Error(int a1);
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2);
int __cdecl Scr_ParamError(int a1, int a2);
int __cdecl Scr_ObjectError(int a1);
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3);
int __cdecl Scr_FreeEntityNum(int a1, int a2);
int __cdecl Scr_GetEntityId(int a1, int a2);
int __cdecl Scr_SetClassMap(int a1, int a2);
int Scr_RemoveClassMap();
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3);
int __cdecl Scr_AddFields(int a1, int a2);
int __cdecl Scr_FindField(int a1, int a2);
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2);
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3);
int __cdecl Scr_Init(int a1, int a2, int a3);
int Scr_Shutdown();
int Scr_Abort();
int __cdecl Scr_SetLoading(int a1);
int Scr_AllocGameVariable();
int __cdecl Scr_InitSystem(int a1, int a2);
int __cdecl Scr_GetChecksum(int a1);
int Scr_HasSourceFiles();
int __cdecl Scr_SaveSource(int a1);
int __cdecl Scr_LoadSource(int a1);
int __cdecl Scr_SkipSource(int a1);
int __cdecl Scr_SavePre(int a1);
int __cdecl Scr_SavePost(int a1);
int Scr_SaveShutdown();
int __cdecl Scr_LoadPre(int a1, int a2);
int Scr_LoadShutdown();
int __cdecl Scr_LoadScript(int a1);
// int __userpurge Scr_FindAnimTree@<eax>(int a1, int a2);
int __cdecl Scr_FindAnim(int a1, int a2, int a3);
int __cdecl Scr_GetFunctionHandle(int a1, int a2);
int Scr_BeginLoadScripts();
int Scr_BeginLoadAnimTrees();
int Scr_EndLoadScripts();
int Scr_EndLoadAnimTrees();
int __cdecl Scr_PrecacheAnimTrees(int a1);
int __cdecl Scr_FreeScripts(unsigned __int8 a1);
int __cdecl Scr_FreeGameVariable(int a1);
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1);
int __cdecl Scr_IsSystemActive(unsigned __int8 a1);
int __cdecl Scr_ExecThread(int a1, int a2);
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_AddExecThread(int a1, int a2);
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4);
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1);
int __cdecl Scr_FreeThread(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1);
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1);
int __cdecl Scr_SetString(int a1, unsigned __int16 a2);
int __cdecl Scr_AllocString(int a1, int a2);
int __cdecl Scr_SetTime(int a1);
int Scr_RunCurrentThreads();
int Scr_ResetTimeout();
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4);
int __cdecl SL_ConvertToString(unsigned __int16 a1);
int __cdecl SL_GetString(int a1, unsigned __int8 a2);
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2);
int __cdecl SL_FindLowercaseString(int a1);
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3);
int __cdecl Scr_CreateCanonicalFilename(int a1);
int __cdecl Scr_GetAnimsIndex(int a1);
int __cdecl Scr_GetAnims(int a1);
int __cdecl MT_Alloc(int a1, int a2);
int __cdecl MT_Free(int a1, int a2);
int *__cdecl Scr_FarHook(int (__cdecl **a1)(_DWORD));
void sub_72F7F();
void (*sub_72F90())(void);
void sub_72FD0();
int term_proc();
// int __cdecl _cxa_finalize(void *);

//-------------------------------------------------------------------------
// Data declarations

int dword_0[] = { 1179403647 }; // weak
Elf32_Rel stru_10000 = { 539776u, 8u }; // weak
char byte_73248[19] =
{
  '\x15',
  '%',
  's',
  ':',
  ' ',
  '(',
  '%',
  's',
  ',',
  ' ',
  'l',
  'i',
  'n',
  'e',
  ' ',
  '%',
  'i',
  ')',
  '\0'
}; // idb
char byte_7325B[5] = { '\x15', '%', 's', '\0', '\0' }; // idb
char byte_732C0[64] =
{
  '\x15',
  'B',
  'G',
  '_',
  'A',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  'F',
  'o',
  'r',
  'S',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'p',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_73380[48] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  '%',
  'i',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  '0',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  '\0'
}; // idb
char byte_73740[43] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  'n',
  '\'',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'p',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  's',
  'c',
  'r',
  'i',
  'p',
  't',
  ' ',
  '%',
  's',
  '\n',
  '\0'
}; // idb
char byte_73BE0[48] =
{
  '\x15',
  'B',
  'G',
  '_',
  'G',
  'e',
  't',
  'A',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  'F',
  'o',
  'r',
  'I',
  'n',
  'd',
  'e',
  'x',
  ':',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'b',
  'o',
  'u',
  'n',
  'd',
  's',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_73C20[64] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  ' ',
  '(',
  '%',
  'i',
  ')',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_73E00[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'i',
  'n',
  'd',
  ' ',
  'a',
  'n',
  'i',
  'm',
  'a',
  't',
  'i',
  'o',
  'n',
  ' ',
  't',
  'r',
  'e',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_74DC0[48] =
{
  '\x15',
  'B',
  'G',
  '_',
  'F',
  'i',
  'n',
  'd',
  'I',
  't',
  'e',
  'm',
  'F',
  'o',
  'r',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ':',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_74E00[41] =
{
  '\x15',
  'B',
  'G',
  '_',
  'C',
  'a',
  'n',
  'I',
  't',
  'e',
  'm',
  'B',
  'e',
  'G',
  'r',
  'a',
  'b',
  'b',
  'e',
  'd',
  ':',
  ' ',
  'i',
  'n',
  'd',
  'e',
  'x',
  ' ',
  'o',
  'u',
  't',
  ' ',
  'o',
  'f',
  ' ',
  'r',
  'a',
  'n',
  'g',
  'e',
  '\0'
}; // idb
char byte_74E29[55] =
{
  '\x15',
  'B',
  'G',
  '_',
  'C',
  'a',
  'n',
  'I',
  't',
  'e',
  'm',
  'B',
  'e',
  'G',
  'r',
  'a',
  'b',
  'b',
  'e',
  'd',
  ':',
  ' ',
  'I',
  'T',
  '_',
  'B',
  'A',
  'D',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_74E60[44] =
{
  '\x15',
  'B',
  'G',
  '_',
  'E',
  'v',
  'a',
  'l',
  'u',
  'a',
  't',
  'e',
  'T',
  'r',
  'a',
  'j',
  'e',
  'c',
  't',
  'o',
  'r',
  'y',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  't',
  'r',
  'T',
  'y',
  'p',
  'e',
  ':',
  ' ',
  '%',
  'i',
  '\0',
  '\0'
}; // idb
char byte_74EE0[48] =
{
  '\x15',
  'B',
  'G',
  '_',
  'E',
  'v',
  'a',
  'l',
  'u',
  'a',
  't',
  'e',
  'T',
  'r',
  'a',
  'j',
  'e',
  'c',
  't',
  'o',
  'r',
  'y',
  'D',
  'e',
  'l',
  't',
  'a',
  ':',
  ' ',
  'u',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  't',
  'r',
  'T',
  'y',
  'p',
  'e',
  ':',
  ' ',
  '%',
  'i',
  '\0'
}; // idb
_UNKNOWN bg_numItems; // weak
_UNKNOWN pm_ladderJumpTime; // weak
_UNKNOWN pm_prone_accelerate; // weak
_UNKNOWN pm_ducked_accelerate; // weak
_UNKNOWN pm_accelerate; // weak
_UNKNOWN pm_airaccelerate; // weak
float flt_75820[78] =
{
   0.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   1.0,
   0.0,
   1.0,
   0.0,
   1.0,
   1.0,
  -1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
   1.0,
   0.0,
   0.0,
   0.0,
  -1.0,
  -1.0,
   0.0,
  -1.0,
   0.0,
  -1.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
   1.0,
   1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   0.0,
   1.0,
  -1.0,
   0.0,
   1.0,
   1.0,
   0.0,
  -1.0,
   1.0,
   0.0,
  -1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
   1.0,
  -1.0,
  -1.0,
   1.0,
  -1.0
}; // idb
_UNKNOWN bg_iNumWeaponInfoFields; // weak
char byte_76BC0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76C00[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'c',
  'l',
  'a',
  's',
  's',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76C40[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'l',
  'a',
  'y',
  ' ',
  'r',
  'e',
  't',
  'i',
  'c',
  'l',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76C80[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  'l',
  'o',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76CC0[64] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  's',
  't',
  'a',
  'n',
  'c',
  'e',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76D00[44] =
{
  '\x15',
  'U',
  'n',
  'k',
  'n',
  'o',
  'w',
  'n',
  ' ',
  'p',
  'r',
  'o',
  'j',
  'e',
  'c',
  't',
  'i',
  'l',
  'e',
  ' ',
  'e',
  'x',
  'p',
  'l',
  'o',
  's',
  'i',
  'o',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  'n',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  '\n',
  '\0'
}; // idb
char byte_76D2C[28] =
{
  '\x15',
  'B',
  'a',
  'd',
  ' ',
  'f',
  'i',
  'e',
  'l',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '%',
  'i',
  ' ',
  'i',
  'n',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_76D60; // weak
char byte_76DA0[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76DE0[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'p',
  'p',
  'e',
  'a',
  'r',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'e',
  ' ',
  'a',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76E20[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'I',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'l',
  'o',
  'n',
  'g',
  ' ',
  'o',
  'f',
  ' ',
  'a',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'a',
  'r',
  's',
  'e',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76E60[36] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  'v',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76EE0[85] =
{
  '\x15',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0'
}; // idb
char byte_76F40[128] =
{
  '\x15',
  'S',
  'h',
  'a',
  'r',
  'e',
  'd',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'c',
  'a',
  'p',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  's',
  'h',
  'a',
  'r',
  'e',
  'd',
  ' ',
  'a',
  'm',
  'm',
  'o',
  ' ',
  'c',
  'a',
  'p',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_76FC0[96] =
{
  '\x15',
  'C',
  'l',
  'i',
  'p',
  ' ',
  'S',
  'i',
  'z',
  'e',
  ' ',
  'm',
  'i',
  's',
  'm',
  'a',
  't',
  'c',
  'h',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'c',
  'l',
  'i',
  'p',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\"',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'b',
  'u',
  't',
  ' ',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  's',
  'e',
  't',
  ' ',
  'i',
  't',
  ' ',
  't',
  'o',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_77020[96] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'h',
  'a',
  'v',
  'e',
  ' ',
  's',
  'a',
  'm',
  'e',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'S',
  'l',
  'o',
  't',
  ' ',
  's',
  'e',
  't',
  't',
  'i',
  'n',
  'g',
  ' ',
  'a',
  's',
  ' ',
  'i',
  't',
  's',
  ' ',
  'a',
  'l',
  't',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_77080[96] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'h',
  'a',
  'v',
  'e',
  ' ',
  's',
  'a',
  'm',
  'e',
  ' ',
  's',
  'l',
  'o',
  't',
  'S',
  't',
  'a',
  'c',
  'k',
  'a',
  'b',
  'l',
  'e',
  ' ',
  's',
  'e',
  't',
  't',
  'i',
  'n',
  'g',
  ' ',
  'a',
  's',
  ' ',
  'i',
  't',
  's',
  ' ',
  'a',
  'l',
  't',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_770E0[64] =
{
  '\x15',
  'c',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'f',
  'i',
  'n',
  'd',
  ' ',
  'a',
  'l',
  't',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_77120[64] =
{
  '\x15',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'a',
  ' ',
  'b',
  'a',
  'd',
  ' ',
  'a',
  'l',
  't',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_77160[86] =
{
  '\x15',
  'T',
  'o',
  'o',
  ' ',
  'm',
  'a',
  'n',
  'y',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  'h',
  'i',
  'n',
  't',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  's',
  ' ',
  'o',
  'n',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  's',
  '.',
  ' ',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  's',
  '\0'
}; // idb
char byte_77200[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'c',
  'a',
  't',
  'e',
  ' ',
  'W',
  'e',
  'a',
  'p',
  'o',
  'n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  'a',
  'r',
  'r',
  'a',
  'y',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_77240[32] =
{
  '\x15',
  'N',
  'o',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  ' ',
  'f',
  'i',
  'l',
  'e',
  's',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  'i',
  'n',
  ' ',
  '%',
  's',
  '.',
  '\n',
  '\0',
  '\0'
}; // idb
char byte_77260[64] =
{
  '\x15',
  'M',
  'a',
  'x',
  ' ',
  'n',
  'u',
  'm',
  'b',
  'e',
  'r',
  ' ',
  'o',
  'f',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  's',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  ',',
  ' ',
  'f',
  'o',
  'u',
  'n',
  'd',
  ' ',
  '%',
  'i',
  '.',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_DWORD vec3_origin[3] = { 0, 0, 0 }; // idb
_UNKNOWN unk_77B44; // weak
_UNKNOWN unk_77D20; // weak
char aEGameBadclient[21] = "e \"GAME_BADCLIENTSLOT"; // weak
char aEGameClientnot_0[23] = "e \"GAME_CLIENTNOTACTIVE"; // weak
char aEGameUsernoton[23] = "e \"GAME_USERNOTONSERVER"; // weak
_UNKNOWN unk_785E0; // weak
char aGameGodmodeoff[16] = "GAME_GODMODEOFF"; // weak
char aGameGodmodeon[15] = "GAME_GODMODEON"; // weak
char aGameNotargetof[17] = "GAME_NOTARGETOFF"; // weak
char aGameNotargeton[16] = "GAME_NOTARGETON"; // weak
char aI[2] = "i"; // weak
char asc_786AC[2] = "h"; // weak
char aS_9[4] = "%s \""; // weak
_UNKNOWN unk_786C3; // weak
char byte_786C4[20] =
{
  '\x15',
  '(',
  '\x14',
  'G',
  'A',
  'M',
  'E',
  '_',
  'S',
  'P',
  'E',
  'C',
  'T',
  'A',
  'T',
  'O',
  'R',
  '\x15',
  ')',
  '\0'
}; // idb
char byte_786D8[17] =
{
  '\x15',
  '%',
  's',
  '(',
  '\x14',
  'G',
  'A',
  'M',
  'E',
  '_',
  'D',
  'E',
  'A',
  'D',
  '\x15',
  ')',
  '\0'
}; // idb
char byte_786E9[4] = { '\x15', '%', 's', '\0' }; // idb
char aGameAxis[10] = "GAME_AXIS"; // weak
char aGameAllies[12] = "GAME_ALLIES"; // weak
char aS_6[3] = "%s("; // weak
char aS_5[3] = "%s("; // weak
char aS_8[3] = "%s("; // weak
char aS_7[3] = "%s("; // weak
_UNKNOWN unk_78840; // weak
char aE_0[3] = "e \""; // weak
char aClientkick[11] = "clientkick"; // weak
char aTempbanclient[14] = "tempBanClient"; // weak
_UNKNOWN unk_78A40; // weak
void *off_78B49 = &unk_A7325; // weak
_UNKNOWN unk_78B80; // weak
char aGameVoteGamety_0[18] = "GAME_VOTE_GAMETYPE"; // weak
char aGameVoteMap[13] = "GAME_VOTE_MAP"; // weak
char aGameVoteGamety[18] = "GAME_VOTE_GAMETYPE"; // weak
char aGameVoteKick[14] = "GAME_VOTE_KICK"; // weak
_UNKNOWN unk_78CEB; // weak
char aEPatch15VoteAr[30] = "e \"PATCH_1_5_VOTE_ARG_NOTVALID"; // weak
char aMenuOn[8] = "MENU_ON"; // weak
char aMenuOff[9] = "MENU_OFF"; // weak
char aPatch15VoteDra[25] = "PATCH_1_5_VOTE_DRAWFRIEND"; // weak
char aPatch15VoteKil[22] = "PATCH_1_5_VOTE_KILLCAM"; // weak
char aPatch15VoteFri[27] = "PATCH_1_5_VOTE_FRIENDLYFIRE"; // weak
_UNKNOWN unk_78E7F; // weak
char aMenuReflect[13] = "MENU_REFLECT"; // weak
char aMenuShared[12] = "MENU_SHARED"; // weak
char aEGameCalledavo[19] = "e \"GAME_CALLEDAVOTE"; // weak
char aE_1[3] = "e \""; // weak
char aEGameUsage[13] = "e \"GAME_USAGE"; // weak
char aEPatch15Timeou_5[30] = "e \"PATCH_1_5_TIMEOUT_MAXCALLED"; // weak
char aEPatch15Timeou_6[32] = "e \"PATCH_1_5_TIMEOUT_MAXTIMEUSED"; // weak
char aPatch15Timeout[24] = "PATCH_1_5_TIMEOUT_CALLED"; // weak
char aEPatch15Timeou_7[38] = "e \"PATCH_1_5_TIMEOUT_CALLED_PLAYERNAME"; // weak
char aPatch15Timeout_0[24] = "PATCH_1_5_TIMEOUT_ENDING"; // weak
char aEPatch15Timein_1[37] = "e \"PATCH_1_5_TIMEIN_CALLED_PLAYERNAME"; // weak
char aEGameUnknowncl[28] = "e \"GAME_UNKNOWNCLIENTCOMMAND"; // weak
char byte_794C0[64] =
{
  '\x15',
  'C',
  'o',
  'u',
  'l',
  'd',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'l',
  'o',
  'a',
  'd',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_79500[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'd',
  'o',
  'e',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  'p',
  'p',
  'e',
  'a',
  'r',
  ' ',
  't',
  'o',
  ' ',
  'b',
  'e',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_79540[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'I',
  's',
  ' ',
  't',
  'o',
  'o',
  ' ',
  'l',
  'o',
  'n',
  'g',
  ' ',
  'o',
  'f',
  ' ',
  'a',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  ' ',
  't',
  'o',
  ' ',
  'p',
  'a',
  'r',
  's',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_79580[64] =
{
  '\x15',
  '\"',
  '%',
  's',
  '\"',
  ' ',
  'i',
  's',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'a',
  ' ',
  'v',
  'a',
  'l',
  'i',
  'd',
  ' ',
  'h',
  'i',
  't',
  'l',
  'o',
  'c',
  ' ',
  'd',
  'a',
  'm',
  'a',
  'g',
  'e',
  ' ',
  't',
  'a',
  'b',
  'l',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
int dword_79800 = 0; // weak
int dword_79804 = 1; // weak
char aFGamePickupCli[28] = "f \"GAME_PICKUP_CLIPONLY_AMMO"; // weak
char aFGamePickupAmm[19] = "f \"GAME_PICKUP_AMMO"; // weak
char aFGamePickupHea[21] = "f \"GAME_PICKUP_HEALTH"; // weak
char aFGamePickupCan[32] = "f \"GAME_PICKUP_CANTCARRYMOREAMMO"; // weak
_UNKNOWN unk_7A10A; // weak
char aCallOfDuty[13] = "Call of Duty"; // weak
char aNov152004[12] = "Nov 15 2004"; // weak
char aEGameServer[14] = "e \"GAME_SERVER"; // weak
void *off_7AD61 = &unk_A7325; // weak
char aPatch15Timeout_1[24] = "PATCH_1_5_TIMEOUT_ENDING"; // weak
char aTagFlash[10] = "tag_flash"; // weak
char aTagPlayer[11] = "tag_player"; // weak
char byte_7AEE0[34] =
{
  '\x15',
  'P',
  'l',
  'a',
  'y',
  'e',
  'r',
  ' ',
  'a',
  'n',
  'i',
  'm',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  'h',
  'a',
  's',
  ' ',
  'n',
  'o',
  ' ',
  'c',
  'h',
  'i',
  'l',
  'd',
  'r',
  'e',
  'n',
  '\0'
}; // idb
char byte_7AFE0[64] =
{
  '\x15',
  'G',
  '_',
  'S',
  'p',
  'a',
  'w',
  'n',
  'T',
  'u',
  'r',
  'r',
  'e',
  't',
  ':',
  ' ',
  'm',
  'a',
  'x',
  ' ',
  'n',
  'u',
  'm',
  'b',
  'e',
  'r',
  ' ',
  'o',
  'f',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  's',
  ' ',
  '(',
  '%',
  'd',
  ')',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7B020[42] =
{
  '\x15',
  'b',
  'a',
  'd',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'i',
  'n',
  'f',
  'o',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ' ',
  's',
  'p',
  'e',
  'c',
  'i',
  'f',
  'i',
  'e',
  'd',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  '\0'
}; // idb
_UNKNOWN unk_7B064; // weak
char byte_7B0C0[36] =
{
  '\x15',
  'n',
  'o',
  ' ',
  'w',
  'e',
  'a',
  'p',
  'o',
  'n',
  'i',
  'n',
  'f',
  'o',
  ' ',
  's',
  'p',
  'e',
  'c',
  'i',
  'f',
  'i',
  'e',
  'd',
  ' ',
  'f',
  'o',
  'r',
  ' ',
  't',
  'u',
  'r',
  'r',
  'e',
  't',
  '\0'
}; // idb
_UNKNOWN unk_7B200; // weak
_UNKNOWN unk_7B318; // weak
_UNKNOWN unk_7B438; // weak
_UNKNOWN unk_7B454; // weak
char byte_7B540[88] =
{
  '\x15',
  'T',
  'o',
  'o',
  ' ',
  'm',
  'a',
  'n',
  'y',
  ' ',
  'd',
  'i',
  'f',
  'f',
  'e',
  'r',
  'e',
  'n',
  't',
  ' ',
  'h',
  'i',
  'n',
  't',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'k',
  'e',
  'y',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  's',
  ' ',
  'o',
  'n',
  ' ',
  't',
  'r',
  'i',
  'g',
  'g',
  'e',
  'r',
  '_',
  'u',
  's',
  'e',
  ' ',
  'e',
  'n',
  't',
  'i',
  't',
  'i',
  'e',
  's',
  '.',
  ' ',
  'M',
  'a',
  'x',
  ' ',
  'a',
  'l',
  'l',
  'o',
  'w',
  'e',
  'd',
  ' ',
  'i',
  's',
  ' ',
  '%',
  'i',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_7BCAE; // weak
void *off_7C54E = &unk_A7325; // weak
char aSetcullfog[11] = "setCullFog"; // weak
char aSetexpfog[10] = "setExpFog"; // weak
_UNKNOWN unk_7E31C; // weak
_UNKNOWN unk_7E825; // weak
char byte_7E840[44] =
{
  '\x15',
  'c',
  'l',
  'a',
  's',
  's',
  'n',
  'a',
  'm',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ',',
  ' ',
  'k',
  'e',
  'y',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ',',
  ' ',
  'v',
  'a',
  'l',
  'u',
  'e',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  ':',
  ' ',
  '%',
  's',
  '\0',
  '\0',
  '\0'
}; // idb
char aEGameServer_0[14] = "e \"GAME_SERVER"; // weak
char byte_7EE43[12] = { '\x15', '%', 'c', '%', 'c', '\x14', '%', 's', '\x15', '^', '7', '\0' }; // idb
char byte_7EE4F[17] =
{
  '\x14',
  '%',
  's',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
_UNKNOWN unk_7EE70; // weak
char aLocalizedStrin[17] = "localized string"; // weak
char byte_7F260[64] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'B',
  'e',
  'g',
  'i',
  'n',
  'P',
  'a',
  'r',
  's',
  'e',
  'S',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ':',
  ' ',
  's',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F2A0[40] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'E',
  'n',
  'd',
  'P',
  'a',
  'r',
  's',
  'e',
  'S',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ':',
  ' ',
  's',
  'e',
  's',
  's',
  'i',
  'o',
  'n',
  ' ',
  'u',
  'n',
  'd',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  '\0'
}; // idb
char byte_7F2C8[22] =
{
  '\x15',
  'F',
  'i',
  'l',
  'e',
  ' ',
  '%',
  's',
  ',',
  ' ',
  'l',
  'i',
  'n',
  'e',
  ' ',
  '%',
  'i',
  ':',
  ' ',
  '%',
  's',
  '\0'
}; // idb
char byte_7F30B[27] =
{
  '\x15',
  'C',
  'o',
  'm',
  '_',
  'P',
  'a',
  'r',
  's',
  'e',
  'E',
  'x',
  't',
  ':',
  ' ',
  'N',
  'U',
  'L',
  'L',
  ' ',
  'd',
  'a',
  't',
  'a',
  '_',
  'p',
  '\0'
}; // idb
void *off_7F344 = &unk_290028; // weak
_UNKNOWN colorRed; // weak
_UNKNOWN colorGreen; // weak
_UNKNOWN colorYellow; // weak
_UNKNOWN colorMagenta; // weak
_UNKNOWN colorCyan; // weak
_UNKNOWN colorMdCyan; // weak
_UNKNOWN colorWhite; // weak
char byte_7F495[43] =
{
  '\x15',
  'Q',
  '_',
  's',
  't',
  'r',
  'c',
  'a',
  't',
  ':',
  ' ',
  'a',
  'l',
  'r',
  'e',
  'a',
  'd',
  'y',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'f',
  'l',
  'o',
  'w',
  'e',
  'd',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F4C0[46] =
{
  '\x15',
  'A',
  't',
  't',
  'e',
  'm',
  'p',
  't',
  'e',
  'd',
  ' ',
  't',
  'o',
  ' ',
  'o',
  'v',
  'e',
  'r',
  'r',
  'u',
  'n',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'i',
  'n',
  ' ',
  'c',
  'a',
  'l',
  'l',
  ' ',
  't',
  'o',
  ' ',
  'v',
  'a',
  '(',
  ')',
  '\n',
  '\0'
}; // idb
_UNKNOWN unk_7F4EE; // weak
char byte_7F500[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'V',
  'a',
  'l',
  'u',
  'e',
  'F',
  'o',
  'r',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F540[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'R',
  'e',
  'm',
  'o',
  'v',
  'e',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F580[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'R',
  'e',
  'm',
  'o',
  'v',
  'e',
  'K',
  'e',
  'y',
  '_',
  'B',
  'i',
  'g',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F5C0[64] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  '_',
  'S',
  'e',
  't',
  'V',
  'a',
  'l',
  'u',
  'e',
  'F',
  'o',
  'r',
  'K',
  'e',
  'y',
  ':',
  ' ',
  'o',
  'v',
  'e',
  'r',
  's',
  'i',
  'z',
  'e',
  ' ',
  'i',
  'n',
  'f',
  'o',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F600[64] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'k',
  'e',
  'y',
  's',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'a',
  ' ',
  '\\',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F640[64] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'k',
  'e',
  'y',
  's',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'a',
  ' ',
  's',
  'e',
  'm',
  'i',
  'c',
  'o',
  'l',
  'o',
  'n',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F680[47] =
{
  '\x15',
  'C',
  'a',
  'n',
  '\'',
  't',
  ' ',
  'u',
  's',
  'e',
  ' ',
  'k',
  'e',
  'y',
  's',
  ' ',
  'w',
  'i',
  't',
  'h',
  ' ',
  'a',
  ' ',
  '\"',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\0'
}; // idb
char byte_7F6C0[96] =
{
  '\x15',
  'S',
  'e',
  'r',
  'v',
  'e',
  'r',
  ' ',
  'i',
  'n',
  'f',
  'o',
  ' ',
  'b',
  'u',
  'f',
  'f',
  'e',
  'r',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  ',',
  ' ',
  'n',
  'o',
  't',
  ' ',
  'i',
  'n',
  'c',
  'l',
  'u',
  'd',
  'i',
  'n',
  'g',
  ' ',
  'k',
  'e',
  'y',
  '/',
  'v',
  'a',
  'l',
  'u',
  'e',
  ' ',
  'p',
  'a',
  'i',
  'r',
  ' ',
  'i',
  'n',
  ' ',
  'r',
  'e',
  's',
  'p',
  'o',
  'n',
  's',
  'e',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F720[96] =
{
  '\x15',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  '\n',
  '%',
  's',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // idb
char byte_7F780[72] =
{
  '\x15',
  'B',
  'I',
  'G',
  ' ',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ' ',
  'l',
  'e',
  'n',
  'g',
  't',
  'h',
  ' ',
  'e',
  'x',
  'c',
  'e',
  'e',
  'd',
  'e',
  'd',
  '\n',
  'k',
  'e',
  'y',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'v',
  'a',
  'l',
  'u',
  'e',
  ':',
  ' ',
  '\'',
  '%',
  's',
  '\'',
  '\n',
  'I',
  'n',
  'f',
  'o',
  ' ',
  's',
  't',
  'r',
  'i',
  'n',
  'g',
  ':',
  '\n',
  '%',
  's',
  '\n',
  '\0'
}; // idb
char byte_7F7C8[20] =
{
  '\x15',
  'B',
  'a',
  'd',
  ' ',
  'f',
  'i',
  'e',
  'l',
  'd',
  ' ',
  't',
  'y',
  'p',
  'e',
  ' ',
  '%',
  'i',
  '\n',
  '\0'
}; // idb
void *off_80000 = &off_80000; // weak
int off_80004[7] = { 560528, 0, 0, 0, 0, 0, 0 }; // weak
int dword_80008 = 0; // weak
int dword_8000C = 0; // weak
char *off_80020 = "mp/playeranim.script"; // weak
char *animStateStr = "RELAXED"; // weak
char *off_80080 = "** UNUSED **"; // weak
char *off_80120 = "PAIN"; // weak
char *animBodyPartsStr = "** UNUSED **"; // weak
char *off_802C0 = "WEAPONS"; // weak
char *off_80310[6] = { "back_low", "back_mid", "back_up", "neck", "head", "pelvis" }; // weak
char *off_80340 = "defines"; // weak
int dword_80380 = 0; // weak
int (*off_80384)[128] = &weaponStrings; // weak
void *pEventSingleClientList = &iSingleClientEvents; // weak
_DWORD bg_itemlist[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // idb
_UNKNOWN c_pmove; // weak
_UNKNOWN unk_814A0; // weak
_UNKNOWN unk_81520; // weak
_UNKNOWN unk_815A0; // weak
_UNKNOWN unk_81680; // weak
int dword_816E4 = 0; // weak
int dword_816E8 = 0; // weak
int dword_816EC = -1; // weak
int dword_816F0 = -1; // weak
char *bg_szWeaponsFolder[18] =
{
  "weapons/mp",
  "bullet",
  "grenade",
  "projectile",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "Gewehr43",
  "none",
  "primary",
  "primaryb",
  "pistol",
  "grenade",
  "smokegrenade",
  "stand",
  "duck",
  "prone"
}; // weak
char *off_81708[17] =
{
  "bullet",
  "grenade",
  "projectile",
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "Gewehr43",
  "none",
  "primary",
  "primaryb",
  "pistol",
  "grenade",
  "smokegrenade",
  "stand",
  "duck",
  "prone"
}; // weak
char *off_81714[14] =
{
  "none",
  "crosshair",
  "FG42",
  "Springfield",
  "Gewehr43",
  "none",
  "primary",
  "primaryb",
  "pistol",
  "grenade",
  "smokegrenade",
  "stand",
  "duck",
  "prone"
}; // weak
char *off_81728[9] =
{
  "none",
  "primary",
  "primaryb",
  "pistol",
  "grenade",
  "smokegrenade",
  "stand",
  "duck",
  "prone"
}; // weak
char *off_81740[3] = { "stand", "duck", "prone" }; // weak
char *off_81760[12] =
{
  "rifle",
  "mg",
  "smg",
  "pistol",
  "grenade",
  "rocketlauncher",
  "turret",
  "non-player",
  "grenade",
  "rocket",
  "molotov",
  "none"
}; // weak
char *off_81780[4] = { "grenade", "rocket", "molotov", "none" }; // weak
char *off_817A0 = "displayName"; // weak
float bytedirs[486] =
{
  -0.52573103,
   0.0,
   0.85065103,
  -0.44286299,
   0.238856,
   0.86418802,
  -0.29524201,
   0.0,
   0.955423,
  -0.309017,
   0.5,
   0.809017,
  -0.16246,
   0.26286599,
   0.951056,
   0.0,
   0.0,
   1.0,
   0.0,
   0.85065103,
   0.52573103,
  -0.14762101,
   0.71656698,
   0.68171799,
   0.14762101,
   0.71656698,
   0.68171799,
   0.0,
   0.52573103,
   0.85065103,
   0.309017,
   0.5,
   0.809017,
   0.52573103,
   0.0,
   0.85065103,
   0.29524201,
   0.0,
   0.955423,
   0.44286299,
   0.238856,
   0.86418802,
   0.16246,
   0.26286599,
   0.951056,
  -0.68171799,
   0.14762101,
   0.71656698,
  -0.809017,
   0.309017,
   0.5,
  -0.58778501,
   0.42532501,
   0.688191,
  -0.85065103,
   0.52573103,
   0.0,
  -0.86418802,
   0.44286299,
   0.238856,
  -0.71656698,
   0.68171799,
   0.14762101,
  -0.688191,
   0.58778501,
   0.42532501,
  -0.5,
   0.809017,
   0.309017,
  -0.238856,
   0.86418802,
   0.44286299,
  -0.42532501,
   0.688191,
   0.58778501,
  -0.71656698,
   0.68171799,
  -0.14762101,
  -0.5,
   0.809017,
  -0.309017,
  -0.52573103,
   0.85065103,
   0.0,
   0.0,
   0.85065103,
  -0.52573103,
  -0.238856,
   0.86418802,
  -0.44286299,
   0.0,
   0.955423,
  -0.29524201,
  -0.26286599,
   0.951056,
  -0.16246,
   0.0,
   1.0,
   0.0,
   0.0,
   0.955423,
   0.29524201,
  -0.26286599,
   0.951056,
   0.16246,
   0.238856,
   0.86418802,
   0.44286299,
   0.26286599,
   0.951056,
   0.16246,
   0.5,
   0.809017,
   0.309017,
   0.238856,
   0.86418802,
  -0.44286299,
   0.26286599,
   0.951056,
  -0.16246,
   0.5,
   0.809017,
  -0.309017,
   0.85065103,
   0.52573103,
   0.0,
   0.71656698,
   0.68171799,
   0.14762101,
   0.71656698,
   0.68171799,
  -0.14762101,
   0.52573103,
   0.85065103,
   0.0,
   0.42532501,
   0.688191,
   0.58778501,
   0.86418802,
   0.44286299,
   0.238856,
   0.688191,
   0.58778501,
   0.42532501,
   0.809017,
   0.309017,
   0.5,
   0.68171799,
   0.14762101,
   0.71656698,
   0.58778501,
   0.42532501,
   0.688191,
   0.955423,
   0.29524201,
   0.0,
   1.0,
   0.0,
   0.0,
   0.951056,
   0.16246,
   0.26286599,
   0.85065103,
  -0.52573103,
   0.0,
   0.955423,
  -0.29524201,
   0.0,
   0.86418802,
  -0.44286299,
   0.238856,
   0.951056,
  -0.16246,
   0.26286599,
   0.809017,
  -0.309017,
   0.5,
   0.68171799,
  -0.14762101,
   0.71656698,
   0.85065103,
   0.0,
   0.52573103,
   0.86418802,
   0.44286299,
  -0.238856,
   0.809017,
   0.309017,
  -0.5,
   0.951056,
   0.16246,
  -0.26286599,
   0.52573103,
   0.0,
  -0.85065103,
   0.68171799,
   0.14762101,
  -0.71656698,
   0.68171799,
  -0.14762101,
  -0.71656698,
   0.85065103,
   0.0,
  -0.52573103,
   0.809017,
  -0.309017,
  -0.5,
   0.86418802,
  -0.44286299,
  -0.238856,
   0.951056,
  -0.16246,
  -0.26286599,
   0.14762101,
   0.71656698,
  -0.68171799,
   0.309017,
   0.5,
  -0.809017,
   0.42532501,
   0.688191,
  -0.58778501,
   0.44286299,
   0.238856,
  -0.86418802,
   0.58778501,
   0.42532501,
  -0.688191,
   0.688191,
   0.58778501,
  -0.42532501,
  -0.14762101,
   0.71656698,
  -0.68171799,
  -0.309017,
   0.5,
  -0.809017,
   0.0,
   0.52573103,
  -0.85065103,
  -0.52573103,
   0.0,
  -0.85065103,
  -0.44286299,
   0.238856,
  -0.86418802,
  -0.29524201,
   0.0,
  -0.955423,
  -0.16246,
   0.26286599,
  -0.951056,
   0.0,
   0.0,
  -1.0,
   0.29524201,
   0.0,
  -0.955423,
   0.16246,
   0.26286599,
  -0.951056,
  -0.44286299,
  -0.238856,
  -0.86418802,
  -0.309017,
  -0.5,
  -0.809017,
  -0.16246,
  -0.26286599,
  -0.951056,
   0.0,
  -0.85065103,
  -0.52573103,
  -0.14762101,
  -0.71656698,
  -0.68171799,
   0.14762101,
  -0.71656698,
  -0.68171799,
   0.0,
  -0.52573103,
  -0.85065103,
   0.309017,
  -0.5,
  -0.809017,
   0.44286299,
  -0.238856,
  -0.86418802,
   0.16246,
  -0.26286599,
  -0.951056,
   0.238856,
  -0.86418802,
  -0.44286299,
   0.5,
  -0.809017,
  -0.309017,
   0.42532501,
  -0.688191,
  -0.58778501,
   0.71656698,
  -0.68171799,
  -0.14762101,
   0.688191,
  -0.58778501,
  -0.42532501,
   0.58778501,
  -0.42532501,
  -0.688191,
   0.0,
  -0.955423,
  -0.29524201,
   0.0,
  -1.0,
   0.0,
   0.26286599,
  -0.951056,
  -0.16246,
   0.0,
  -0.85065103,
   0.52573103,
   0.0,
  -0.955423,
   0.29524201,
   0.238856,
  -0.86418802,
   0.44286299,
   0.26286599,
  -0.951056,
   0.16246,
   0.5,
  -0.809017,
   0.309017,
   0.71656698,
  -0.68171799,
   0.14762101,
   0.52573103,
  -0.85065103,
   0.0,
  -0.238856,
  -0.86418802,
  -0.44286299,
  -0.5,
  -0.809017,
  -0.309017,
  -0.26286599,
  -0.951056,
  -0.16246,
  -0.85065103,
  -0.52573103,
   0.0,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.68171799,
   0.14762101,
  -0.52573103,
  -0.85065103,
   0.0,
  -0.5,
  -0.809017,
   0.309017,
  -0.238856,
  -0.86418802,
   0.44286299,
  -0.26286599,
  -0.951056,
   0.16246,
  -0.86418802,
  -0.44286299,
   0.238856,
  -0.809017,
  -0.309017,
   0.5,
  -0.688191,
  -0.58778501,
   0.42532501,
  -0.68171799,
  -0.14762101,
   0.71656698,
  -0.44286299,
  -0.238856,
   0.86418802,
  -0.58778501,
  -0.42532501,
   0.688191,
  -0.309017,
  -0.5,
   0.809017,
  -0.14762101,
  -0.71656698,
   0.68171799,
  -0.42532501,
  -0.688191,
   0.58778501,
  -0.16246,
  -0.26286599,
   0.951056,
   0.44286299,
  -0.238856,
   0.86418802,
   0.16246,
  -0.26286599,
   0.951056,
   0.309017,
  -0.5,
   0.809017,
   0.14762101,
  -0.71656698,
   0.68171799,
   0.0,
  -0.52573103,
   0.85065103,
   0.42532501,
  -0.688191,
   0.58778501,
   0.58778501,
  -0.42532501,
   0.688191,
   0.688191,
  -0.58778501,
   0.42532501,
  -0.955423,
   0.29524201,
   0.0,
  -0.951056,
   0.16246,
   0.26286599,
  -1.0,
   0.0,
   0.0,
  -0.85065103,
   0.0,
   0.52573103,
  -0.955423,
  -0.29524201,
   0.0,
  -0.951056,
  -0.16246,
   0.26286599,
  -0.86418802,
   0.44286299,
  -0.238856,
  -0.951056,
   0.16246,
  -0.26286599,
  -0.809017,
   0.309017,
  -0.5,
  -0.86418802,
  -0.44286299,
  -0.238856,
  -0.951056,
  -0.16246,
  -0.26286599,
  -0.809017,
  -0.309017,
  -0.5,
  -0.68171799,
   0.14762101,
  -0.71656698,
  -0.68171799,
  -0.14762101,
  -0.71656698,
  -0.85065103,
   0.0,
  -0.52573103,
  -0.688191,
   0.58778501,
  -0.42532501,
  -0.58778501,
   0.42532501,
  -0.688191,
  -0.42532501,
   0.688191,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.58778501,
  -0.58778501,
  -0.42532501,
  -0.688191,
  -0.688191,
  -0.58778501,
  -0.42532501
}; // idb
int dword_82B18 = -1985229329; // weak
float flt_82B1C =  40.0; // weak
float flt_82B20 =  40.0; // weak
float flt_82B24 =  52.0; // weak
char *off_82B40 = "name"; // weak
_DWORD playerMins[3] = { -1049624576, -1049624576, 0 }; // idb
_DWORD playerMaxs[5] = { 1097859072, 1097859072, 1116733440, 0, 0 }; // idb
char *off_82CA0 = "giveweapon"; // weak
int (__cdecl *off_82CA4)(char) = &PlayerCmd_giveWeapon; // weak
char *off_82E50[7] =
{
  "GAME_GC_HOLDYOURPOSITION",
  "GAME_GC_HOLDTHISPOSITION",
  "GAME_GC_COMEHERE",
  "GAME_GC_COVERME",
  "GAME_GC_GUARDLOCATION",
  "GAME_GC_SEARCHDESTROY",
  "GAME_GC_REPORT"
}; // weak
_UNKNOWN bulletPriorityMap; // weak
_UNKNOWN riflePriorityMap; // weak
char *off_82EA0[19] =
{
  "none",
  "helmet",
  "head",
  "neck",
  "torso_upper",
  "torso_lower",
  "right_arm_upper",
  "left_arm_upper",
  "right_arm_lower",
  "left_arm_lower",
  "right_hand",
  "left_hand",
  "right_leg_upper",
  "left_leg_upper",
  "right_leg_lower",
  "left_leg_lower",
  "right_foot",
  "left_foot",
  "gun"
}; // weak
char *modNames[25] =
{
  "MOD_UNKNOWN",
  "MOD_PISTOL_BULLET",
  "MOD_RIFLE_BULLET",
  "MOD_GRENADE",
  "MOD_GRENADE_SPLASH",
  "MOD_PROJECTILE",
  "MOD_PROJECTILE_SPLASH",
  "MOD_MELEE",
  "MOD_HEAD_SHOT",
  "MOD_MORTAR",
  "MOD_MORTAR_SPLASH",
  "MOD_KICKED",
  "MOD_GRABBER",
  "MOD_DYNAMITE",
  "MOD_DYNAMITE_SPLASH",
  "MOD_AIRSTRIKE",
  "MOD_WATER",
  "MOD_SLIME",
  "MOD_LAVA",
  "MOD_CRUSH",
  "MOD_TELEFRAG",
  "MOD_FALLING",
  "MOD_SUICIDE",
  "MOD_TRIGGER_HURT",
  "MOD_EXPLOSIVE"
}; // weak
void *off_82F80 = &unk_798A0; // weak
char *off_83080 = "settext"; // weak
int (__cdecl *off_83084)(int) = &sub_496EA; // weak
char *off_830F0[6] = { "default", "bigfixed", "smallfixed", "left", "center", "right" }; // weak
char *off_830FC[3] = { "left", "center", "right" }; // weak
void *off_83108 = &unk_7990F; // weak
int dword_83114 = 115; // weak
int (*gameCvarTable)[72] = &g_cheats; // weak
void *hintStrings = &unk_7B200; // weak
char *off_83C2C[2] = { "entity", "hudelem" }; // weak
char *functions = "print"; // weak
char *off_84180 = "attach"; // weak
int (__cdecl *off_84184)(int) = &sub_5CB37; // weak
char *off_842E0 = "moveto"; // weak
int (__cdecl *off_842E4)(char) = &ScriptEntCmd_MoveTo; // weak
char *off_84340 = "classname"; // weak
char *spawns = "info_null"; // weak
int (__cdecl *dword_84660)(_DWORD, _DWORD) = (int (__cdecl *)(_DWORD, _DWORD))0xFFFFFFFF; // weak
float flt_84664 =  0.0; // weak
float flt_84668 = -1.0; // weak
float flt_8466C =  0.0; // weak
int dword_84670 = 0; // weak
int dword_84674 = 0; // weak
int dword_84678 = 1065353216; // weak
float flt_8467C =  0.0; // weak
float flt_84680 = -2.0; // weak
float flt_84684 =  0.0; // weak
int dword_84688 = 0; // weak
int dword_8468C = 0; // weak
int dword_84690 = -1082130432; // weak
_UNKNOWN unk_846A0; // weak
void *off_88C60 = &unk_7F220; // weak
void *off_88C9C = &unk_846A0; // weak
int dword_88CA0 = 0; // weak
int dword_88CA4 = 0; // weak
_UNKNOWN unk_88CA8; // weak
int dword_88D88 = 0; // weak
int dword_88D94 = 0; // weak
Elf32_Dyn *GLOBAL_OFFSET_TABLE_ = &DYNAMIC; // weak
char byte_89BE0; // weak
_UNKNOWN unk_89BE4; // weak
int dword_89C00; // weak
_UNKNOWN unk_89C40; // weak
_UNKNOWN unk_8B300; // weak
int dword_8C350; // weak
int dword_8C360[]; // weak
int dword_8C364; // weak
int dword_8C7E0[]; // weak
int dword_8C7E4; // weak
int dword_8CC60; // weak
int dword_8CC64; // weak
int dword_8CC68; // weak
int dword_8CC6C; // weak
_BYTE byte_8CC80[59964]; // idb
int dword_9B6BC; // weak
int dword_9B6C0; // weak
int dword_9B6C4; // weak
int dword_9B6C8; // weak
int dword_9B6CC; // weak
int dword_9B6D0; // weak
int dword_9B6D4; // weak
int dword_9B6D8; // weak
int dword_9B6DC; // weak
int dword_9B6E0; // weak
int dword_9B6E4; // weak
int dword_9B6E8; // weak
_UNKNOWN unk_9B6EC; // weak
int dword_9BB48[]; // weak
int dword_9BB4C; // weak
_UNKNOWN unk_9BB94; // weak
int dword_A5320; // weak
int dword_A5420; // weak
int dword_A5520; // weak
int dword_A5540; // weak
int dword_A5640; // weak
int dword_A5740; // weak
int dword_A5760; // weak
int dword_A5860; // weak
int dword_A5960; // weak
int dword_A5964; // weak
_BYTE byte_A5980[1024]; // idb
__int16 word_A5D80; // weak
_DWORD dword_A5DC0[512]; // idb
int dword_A65C0; // weak
int dword_A65C4; // weak
int dword_A65C8; // weak
int dword_A65E0[]; // weak
int dword_A65E4; // weak
int dword_A85E0; // weak
int dword_A8600; // weak
_UNKNOWN unk_A8620; // weak
int dword_A8720; // weak
_UNKNOWN unk_A8740; // weak
int dword_A8940; // weak
char byte_A8D40; // weak
int dword_A9140; // weak
int dword_A9144; // weak
int dword_A9148; // weak
int dword_A9160; // weak
_UNKNOWN unk_A9180; // weak
char byte_A91E0[20748]; // idb
_UNKNOWN unk_AE2EC; // weak
char byte_B0EDF; // weak
_UNKNOWN unk_B0EE0; // weak
_UNKNOWN unk_B8BE0; // weak
int (__cdecl *dword_BCBE0)(_DWORD); // weak
int dword_BCBE4; // weak
int (__cdecl *dword_BCBE8)(_DWORD); // weak
int dword_BCBEC; // weak
int (__cdecl *dword_BCBF0)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCBF4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCBF8)(_DWORD); // weak
int dword_BCBFC; // weak
int (__cdecl *dword_BCC00)(_DWORD); // weak
int (__cdecl *dword_BCC04)(_DWORD); // weak
int (__cdecl *dword_BCC08)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCC0C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCC10)(_DWORD); // weak
int (__cdecl *dword_BCC14)(_DWORD); // weak
int (__cdecl *dword_BCC18)(_DWORD); // weak
int (__cdecl *dword_BCC1C)(_DWORD); // weak
int (__cdecl *dword_BCC20)(_DWORD); // weak
int (__cdecl *dword_BCC24)(_DWORD); // weak
int (__cdecl *dword_BCC28)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCC2C)(_DWORD); // weak
int (__cdecl *dword_BCC30)(_DWORD); // weak
int (__cdecl *dword_BCC34)(_DWORD); // weak
int (__cdecl *dword_BCC38)(_DWORD, _DWORD); // weak
int (*dword_BCC3C)(void); // weak
int (__cdecl *dword_BCC40)(_DWORD); // weak
int (__cdecl *dword_BCC44)(_DWORD); // weak
int (__cdecl *dword_BCC48)(_DWORD); // weak
int (__cdecl *dword_BCC4C)(_DWORD); // weak
int (*dword_BCC50)(void); // weak
int (__cdecl *dword_BCC54)(_DWORD, _DWORD); // weak
int (*dword_BCC58)(void); // weak
int (__cdecl *dword_BCC5C)(_DWORD); // weak
int (__cdecl *dword_BCC60)(_DWORD); // weak
int (__cdecl *dword_BCC64)(_DWORD); // weak
int (__cdecl *dword_BCC68)(_DWORD); // weak
int (__cdecl *dword_BCC6C)(_DWORD); // weak
int (*dword_BCC70)(void); // weak
int (__cdecl *dword_BCC74)(_DWORD); // weak
int (*dword_BCC78)(void); // weak
int (*dword_BCC7C)(void); // weak
int (*dword_BCC80)(void); // weak
int (*dword_BCC84)(void); // weak
int (*dword_BCC88)(void); // weak
int (__cdecl *dword_BCC8C)(_DWORD); // weak
int (__cdecl *dword_BCC90)(_DWORD); // weak
int (__cdecl *dword_BCC94)(_DWORD); // weak
int (__cdecl *dword_BCC98)(_DWORD); // weak
int (__cdecl *dword_BCC9C)(_DWORD); // weak
int (__cdecl *dword_BCCA0)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCA4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCCA8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCAC)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCCB0)(_DWORD); // weak
int (__cdecl *dword_BCCB4)(_DWORD); // weak
int (__cdecl *dword_BCCB8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCBC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCC0)(_DWORD); // weak
int (__cdecl *dword_BCCC4)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCCC8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCCC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCD0)(_DWORD, _DWORD); // weak
int (*dword_BCCD4)(void); // weak
int (__cdecl *dword_BCCE0)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCCE4)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCE8)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCEC)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCCF0)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCCF4)(_DWORD, _DWORD, _DWORD); // weak
int (*dword_BCCF8)(void); // weak
int (*dword_BCCFC)(void); // weak
int (__cdecl *dword_BCD00)(_DWORD); // weak
int (__cdecl *dword_BCD04)(_DWORD, _DWORD); // weak
int (*dword_BCD08)(void); // weak
int (__cdecl *dword_BCD0C)(_DWORD); // weak
int (*dword_BCD10)(void); // weak
int (__cdecl *dword_BCD14)(_DWORD); // weak
int (__cdecl *dword_BCD18)(_DWORD); // weak
int (__cdecl *dword_BCD1C)(_DWORD); // weak
int (__cdecl *dword_BCD20)(_DWORD); // weak
int (__cdecl *dword_BCD24)(_DWORD); // weak
int (*dword_BCD28)(void); // weak
int (__cdecl *dword_BCD30)(_DWORD, _DWORD); // weak
int (*dword_BCD34)(void); // weak
int (__cdecl *dword_BCD3C)(_DWORD); // weak
int (__cdecl *dword_BCD40)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD44)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCD48)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD4C)(_DWORD); // weak
int (__cdecl *dword_BCD50)(_DWORD); // weak
int (__cdecl *dword_BCD54)(_DWORD); // weak
int (__cdecl *dword_BCD58)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD5C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD60)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCD64)(_DWORD, _DWORD, _DWORD); // weak
int (__cdecl *dword_BCD68)(_DWORD); // weak
int (__cdecl *dword_BCD6C)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD70)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD74)(_DWORD); // weak
int (__cdecl *dword_BCD78)(_DWORD); // weak
int (__cdecl *dword_BCD7C)(_DWORD); // weak
int (*dword_BCD80)(void); // weak
int (*dword_BCD84)(void); // weak
int (__cdecl *dword_BCD88)(_DWORD); // weak
int (__cdecl *dword_BCD8C)(_DWORD); // weak
int (__cdecl *dword_BCD90)(_DWORD, _DWORD); // weak
int (__cdecl *dword_BCD94)(_DWORD, _DWORD); // weak
int dword_BCD98; // weak
int dword_BCD9C; // weak
int dword_BCDA0; // weak
int dword_BCDA4; // weak
int dword_BCDA8; // weak
_DWORD weaponStrings[128]; // idb
int bg[8]; // idb
_DWORD bgs[9850]; // idb
int dword_C69C8; // weak
int dword_C6B20; // weak
char byte_C6B2C[24]; // idb
_UNKNOWN unk_C6B44; // weak
int dword_C6B48; // weak
char byte_C6CE4[796]; // idb
_UNKNOWN unk_C7000; // weak
_DWORD bg_viewheight_prone[72]; // idb
int bg_foliagesnd_slowinterval[72]; // idb
_DWORD bg_foliagesnd_fastinterval[72]; // idb
int bg_foliagesnd_minspeed[72]; // idb
_DWORD bg_viewheight_crouched[72]; // idb
_DWORD bg_foliagesnd_resetinterval[72]; // idb
float bg_fallDamageMinHeight[72]; // idb
_DWORD bg_viewheight_standing[72]; // idb
_DWORD pml[40]; // idb
int bg_ladder_yawcap[72]; // idb
_DWORD bg_foliagesnd_maxspeed[72]; // idb
float bg_fallDamageMaxHeight[72]; // idb
float bg_prone_yawcap[68]; // idb
_UNKNOWN pm; // weak
_UNKNOWN bg_bobAmplitudeStanding; // weak
_DWORD bg_debugWeaponState[72]; // idb
float bg_bobMax[72]; // idb
_DWORD bg_debugWeaponAnim[72]; // idb
_UNKNOWN bg_bobAmplitudeDucked; // weak
float bg_bobAmplitudeProne[72]; // idb
_DWORD g_fHitLocDamageMult[24]; // idb
_DWORD g_hudelems[31744]; // idb
_DWORD itemRegistered[256]; // idb
_DWORD g_allowVoteDrawFriend[72]; // idb
_UNKNOWN g_gametype; // weak
_DWORD g_dedicated[72]; // idb
int g_timeoutsAllowed[72]; // idb
_DWORD g_listEntity[72]; // idb
_DWORD g_timeoutBank[72]; // idb
int g_timeoutLength[72]; // idb
int g_debugBullets[72]; // idb
float g_bounds_width[72]; // idb
_DWORD g_allowVoteMapRestart[72]; // idb
_DWORD g_logSync[72]; // idb
_DWORD g_allowVoteTempBanClient[72]; // idb
_DWORD g_debugProneCheckDepthCheck[72]; // idb
_UNKNOWN g_motd; // weak
_DWORD pmove_fixed[72]; // idb
_DWORD g_inactivity[72]; // idb
_DWORD g_allowVoteGameType[72]; // idb
_DWORD g_timeoutRecovery[72]; // idb
_DWORD g_bounds_height_standing[72]; // idb
int g_dumpAnims[72]; // idb
_DWORD g_debugProneCheck[72]; // idb
_DWORD g_cheats[72]; // idb
_DWORD g_languagewarnings[72]; // idb
_DWORD g_debugLocDamage[72]; // idb
_DWORD g_developer[72]; // idb
float g_knockback[72]; // idb
_DWORD g_allowVote[72]; // idb
char g_password[288]; // idb
int pmove_msec[72]; // idb
_DWORD level[2960]; // idb
_DWORD g_allowVoteTypeMap[72]; // idb
float g_gravity[72]; // idb
_UNKNOWN g_clients; // weak
_UNKNOWN unk_200000; // weak
_UNKNOWN unk_200004; // weak
_DWORD g_entities[117338]; // idb
_DWORD g_synchronousClients[72]; // idb
_DWORD g_NoScriptSpam[72]; // idb
_DWORD g_allowVoteKillCam[72]; // idb
_DWORD g_allowVoteFriendlyFire[72]; // idb
_DWORD g_complaintlimit[72]; // idb
float bg_swingSpeed[72]; // idb
_DWORD g_maxclients[72]; // idb
_DWORD g_voiceChatsAllowed[72]; // idb
_DWORD g_allowVoteMap[72]; // idb
_DWORD g_maxDroppedWeapons[72]; // idb
_DWORD g_debugMove[72]; // idb
_DWORD g_weaponRespawn[72]; // idb
_DWORD bg_debugAnim[72]; // idb
_DWORD g_speed[72]; // idb
_DWORD g_filterBan[72]; // idb
_DWORD g_allowVoteClientKick[72]; // idb
_DWORD g_deadChat[72]; // idb
_BYTE g_log[288]; // idb
_DWORD g_allowVoteKick[72]; // idb
_DWORD g_weaponAmmoPools[72]; // idb
char g_banIPs[288]; // idb
_DWORD g_debugDamage[72]; // idb
_DWORD g_allowVoteMapRotate[72]; // idb
_DWORD g_smoothClients[72]; // idb
_DWORD g_allowVoteTempBanUser[72]; // idb
_DWORD g_languagewarningsaserrors[72]; // idb
_UNKNOWN pushed; // weak
_WORD g_scr_data[224]; // idb
unsigned __int16 scr_const[132]; // idb
// extern _UNKNOWN _deregister_frame_info_bases; weak
// extern _UNKNOWN _register_frame_info_bases; weak
// extern int _ctype_b; weak
// extern _UNKNOWN Jv_RegisterClasses; weak
// extern _UNKNOWN _gmon_start__; weak


//----- (00012E00) --------------------------------------------------------
void (*init_proc())(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  sub_15B50();
  return sub_72F90();
}
// 15A50: using guessed type int __gmon_start__(void);

//----- (00012E30) --------------------------------------------------------
void sub_12E30()
{
  __asm { jmp     dword ptr [ebx+8] }
}

//----- (00015AC0) --------------------------------------------------------
int start()
{
  int v0; // eax
  void (*i)(void); // edx
  int v3; // [esp+0h] [ebp-8h]

  if ( !byte_89BE0 )
  {
    if ( &_cxa_finalize )
      __cxa_finalize(off_80000);
    v0 = off_80004[0];
    for ( i = *(void (**)(void))off_80004[0]; *(_DWORD *)off_80004[0]; i = *(void (**)(void))off_80004[0] )
    {
      off_80004[0] = v0 + 4;
      i();
      v0 = off_80004[0];
    }
    if ( &_deregister_frame_info_bases )
      __deregister_frame_info_bases(&unk_88CA8);
    byte_89BE0 = 1;
  }
  return v3;
}
// 15B28: variable 'v3' is possibly undefined
// 13B70: using guessed type int __cdecl __deregister_frame_info_bases(_DWORD);
// 80000: using guessed type void *off_80000;
// 80004: using guessed type int off_80004[7];
// 89BE0: using guessed type char byte_89BE0;

//----- (00015B50) --------------------------------------------------------
void *sub_15B50()
{
  void *result; // eax

  if ( &_register_frame_info_bases )
    __register_frame_info_bases(&unk_88CA8, &unk_89BE4, 0, &GLOBAL_OFFSET_TABLE_);
  result = (void *)dword_88D94;
  if ( dword_88D94 )
  {
    result = &Jv_RegisterClasses;
    if ( &Jv_RegisterClasses )
      result = (void *)_Jv_RegisterClasses(&dword_88D94);
  }
  return result;
}
// 149F0: using guessed type int __cdecl __register_frame_info_bases(_DWORD, _DWORD, _DWORD, _DWORD);
// 15880: using guessed type int __cdecl _Jv_RegisterClasses(_DWORD);
// 88D94: using guessed type int dword_88D94;
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00015BC6) --------------------------------------------------------
void sub_15BC6()
{
  ;
}

//----- (00015BCC) --------------------------------------------------------
int __cdecl sub_15BCC(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = 0;
  for ( i = 0; *(_BYTE *)(a1 + i); ++i )
    v2 += (i + 119) * (char)tolower(*(char *)(a1 + i));
  if ( v2 == -1 )
    v2 = 0;
  return v2;
}

//----- (00015C3C) --------------------------------------------------------
int BG_AnimParseError(char *format, ...)
{
  char s[1036]; // [esp+20h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+42Ch] [ebp-Ch]
  va_list va; // [esp+444h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  if ( !off_80020 )
    return Com_Error(1, byte_7325B, (char)s);
  Com_GetCurrentParseLine();
  return Com_Error(1, byte_73248, (char)s);
}
// 15040: using guessed type int Com_GetCurrentParseLine(void);
// 80020: using guessed type char *off_80020;

//----- (00015CDB) --------------------------------------------------------
int __cdecl BG_AnimationIndexForString(char *src)
{
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]

  if ( dword_8CC68 )
  {
    v9 = sub_15BCC((int)src);
    v7 = 0;
    v3 = dword_8CC68;
    while ( v7 < *(_DWORD *)dword_8CC6C )
    {
      if ( v9 == *(_DWORD *)(v3 + 4) && !Q_stricmp(src, v3 + 8) )
        return v7;
      ++v7;
      v3 += 72;
    }
    v4 = dword_8CC68 + 72 * *(_DWORD *)dword_8CC6C;
    Scr_FindAnim("multiplayer", src, v4);
    strcpy((char *)(v4 + 8), src);
    *(_DWORD *)(v4 + 4) = v9;
    v2 = (*(_DWORD *)dword_8CC6C)++;
  }
  else
  {
    v6 = sub_15BCC((int)src);
    v8 = 0;
    v5 = dword_80008;
    while ( v8 < *(_DWORD *)(dword_80008 + 47104) )
    {
      if ( v6 == *(_DWORD *)(v5 + 76) && !Q_stricmp(src, v5) )
        return v8;
      ++v8;
      v5 += 92;
    }
    BG_AnimParseError("BG_AnimationIndexForString: unknown player animation '%s'", (char)src);
    v2 = -1;
  }
  return v2;
}
// 14590: using guessed type _DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 80008: using guessed type int dword_80008;
// 8CC68: using guessed type int dword_8CC68;
// 8CC6C: using guessed type int dword_8CC6C;

//----- (00015E6B) --------------------------------------------------------
int __cdecl BG_AnimationForString(int a1)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  v4 = sub_15BCC(a1);
  v5 = 0;
  v3 = dword_80008;
  while ( v5 < *(_DWORD *)(dword_80008 + 47104) )
  {
    if ( v4 == *(_DWORD *)(v3 + 76) && !Q_stricmp(a1, v3) )
      return v3;
    ++v5;
    v3 += 92;
  }
  Com_Error(1, byte_732C0, a1);
  return 0;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 80008: using guessed type int dword_80008;

//----- (00015F11) --------------------------------------------------------
int __cdecl BG_IndexForString(int a1, int *a2, int a3)
{
  int v6; // [esp+18h] [ebp-10h]
  int v7; // [esp+1Ch] [ebp-Ch]

  v6 = sub_15BCC(a1);
  v7 = 0;
  while ( *a2 )
  {
    if ( a2[1] == -1 )
      a2[1] = sub_15BCC(*a2);
    if ( v6 == a2[1] && !Q_stricmp(a1, *a2) )
      return v7;
    a2 += 2;
    ++v7;
  }
  if ( !a3 )
    BG_AnimParseError("BG_IndexForString: unknown token '%s'", a1);
  return -1;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00015FC9) --------------------------------------------------------
char *__cdecl BG_CopyStringIntoBuffer(char *s, int a2, int a3, int a4)
{
  char v5; // [esp+4h] [ebp-14h]
  char *dest; // [esp+8h] [ebp-10h]

  if ( *(_DWORD *)a4 + strlen(s) + 1 >= a3 )
    BG_AnimParseError("BG_CopyStringIntoBuffer: out of buffer space", v5);
  dest = (char *)(a2 + *(_DWORD *)a4);
  strcpy(dest, s);
  *(_DWORD *)a4 += strlen(s) + 1;
  return dest;
}
// 15FFC: variable 'v5' is possibly undefined

//----- (0001603F) --------------------------------------------------------
int BG_InitWeaponStrings()
{
  int result; // eax
  int i; // [esp+18h] [ebp-10h]

  memset(weaponStrings, 0, sizeof(weaponStrings));
  weaponStrings[0] = "none";
  weaponStrings[1] = sub_15BCC((int)"none");
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    weaponStrings[2 * i] = *(_DWORD *)(BG_GetInfoForWeapon(i) + 4);
    weaponStrings[2 * i + 1] = sub_15BCC(weaponStrings[2 * i]);
  }
  return result;
}
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (000160FB) --------------------------------------------------------
unsigned __int16 *__cdecl sub_160FB(unsigned int a1)
{
  unsigned __int16 *v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  if ( a1 >= *(_DWORD *)(dword_80008 + 47104) )
    Com_Error(1, byte_73380, a1);
  v4 = 0;
  v3 = (unsigned __int16 *)dword_8CC68;
  while ( v4 < *(_DWORD *)dword_8CC6C )
  {
    if ( a1 == *v3 )
      return v3;
    ++v4;
    v3 += 36;
  }
  return 0;
}
// 80008: using guessed type int dword_80008;
// 8CC68: using guessed type int dword_8CC68;
// 8CC6C: using guessed type int dword_8CC6C;

//----- (0001619A) --------------------------------------------------------
int __cdecl sub_1619A(int a1)
{
  int result; // eax
  int k; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int j; // [esp+4h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-8h]
  _DWORD *v6; // [esp+10h] [ebp-4h]

  for ( i = 0; i < *(_DWORD *)(a1 + 47104); ++i )
    *(_DWORD *)(a1 + 92 * i + 88) = 0;
  v6 = (_DWORD *)(a1 + 134828);
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= *v6 )
      break;
    v5 = v6[j + 1];
    for ( k = 0; k < *(_DWORD *)(v5 + 112); ++k )
    {
      if ( *(_WORD *)(v5 + 16 * k + 116) )
        *(_DWORD *)(a1 + 92 * *(__int16 *)(v5 + 16 * k + 120) + 88) = 1;
      if ( *(_WORD *)(v5 + 16 * k + 118) )
        *(_DWORD *)(a1 + 92 * *(__int16 *)(v5 + 16 * k + 122) + 88) = 1;
    }
  }
  return result;
}

//----- (00016279) --------------------------------------------------------
int BG_FinalizePlayerAnims()
{
  char *v0; // eax
  char *v1; // esi
  char *v2; // esi
  float v4; // [esp+40h] [ebp-48h]
  unsigned __int16 *v5; // [esp+48h] [ebp-40h]
  int v6; // [esp+4Ch] [ebp-3Ch]
  float v7; // [esp+50h] [ebp-38h] BYREF
  float v8; // [esp+54h] [ebp-34h]
  float v9; // [esp+58h] [ebp-30h]
  char v10[8]; // [esp+60h] [ebp-28h] BYREF
  int v11; // [esp+68h] [ebp-20h]
  int v12; // [esp+6Ch] [ebp-1Ch]
  char *dest; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]
  signed int v16; // [esp+7Ch] [ebp-Ch]

  v14 = dword_80008;
  v12 = *(int *)((char *)&dword_9B6C0 + dword_80008);
  HIWORD(v11) = Scr_GetAnimsIndex(v12);
  v15 = trap_XAnimGetAnimTreeSize(v12);
  *(_DWORD *)(dword_80008 + 47104) = v15;
  dest = (char *)v14;
  *(_DWORD *)(v14 + 80) |= 0x101u;
  Q_strncpyz(dest, "root", 64);
  *((_DWORD *)dest + 19) = 0;
  dest += 92;
  v16 = 1;
  while ( v16 < v15 )
  {
    LOWORD(v11) = v16;
    v5 = sub_160FB(v16);
    if ( v5 )
    {
      if ( trap_XAnimIsPrimitive(v11) )
      {
        v0 = (char *)trap_XAnimGetAnimName(v11);
        Q_strncpyz(dest, v0, 64);
        v1 = dest;
        *((_DWORD *)v1 + 19) = sub_15BCC((int)dest);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        v2 = dest;
        *((_DWORD *)v2 + 18) = trap_XAnimGetLength(v12, (unsigned __int16)v16);
        if ( *((_DWORD *)dest + 18) )
        {
          trap_XAnimGetRelDelta(v11, v10, &v7, 0, 1065353216);
          v4 = sqrt(v7 * v7 + v8 * v8 + v9 * v9);
          v6 = (int)v4;
          if ( v6 )
            *((_DWORD *)dest + 17) = 1000 * v6 / *((_DWORD *)dest + 18);
          else
            *((_DWORD *)dest + 17) = 0;
        }
        else
        {
          *((_DWORD *)dest + 17) = 0;
        }
        if ( *((int *)dest + 18) < 500 )
          *((_DWORD *)dest + 18) = 500;
        if ( trap_XAnimIsLooped(v11) )
          *((_DWORD *)dest + 20) |= 0x80u;
      }
      else
      {
        *((_DWORD *)dest + 20) |= 1u;
        Q_strncpyz(dest, (char *)v5 + 8, 64);
        *((_DWORD *)dest + 19) = *((_DWORD *)v5 + 1);
        if ( !*((_DWORD *)dest + 16) )
          *((_DWORD *)dest + 16) = -1;
        *((_DWORD *)dest + 18) = 0;
        *((_DWORD *)dest + 17) = 0;
      }
    }
    else
    {
      *((_DWORD *)dest + 20) |= 0x100u;
      Q_strncpyz(dest, "unused", 64);
      *((_DWORD *)dest + 19) = 0;
    }
    ++v16;
    dest += 92;
  }
  BG_AnimParseAnimScript(dword_80008, 0, 0);
  return sub_1619A(dword_80008);
}
// 163AD: conditional instruction was optimized away because of '%var_40.4!=0'
// 134C0: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 137A0: using guessed type _DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD);
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 13FC0: using guessed type _DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD);
// 14940: using guessed type _DWORD __cdecl trap_XAnimIsLooped(_DWORD);
// 14960: using guessed type _DWORD __cdecl trap_XAnimGetAnimName(_DWORD);
// 15020: using guessed type _DWORD __cdecl trap_XAnimGetAnimTreeSize(_DWORD);
// 15740: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);
// 80008: using guessed type int dword_80008;
// 9B6C0: using guessed type int dword_9B6C0;

//----- (000165B9) --------------------------------------------------------
void *__cdecl sub_165B9(int a1, int a2, int a3, void *s)
{
  void *result; // eax
  int v5; // eax
  char v6; // [esp+4h] [ebp-74h]
  char *src; // [esp+18h] [ebp-60h]
  int v8; // [esp+1Ch] [ebp-5Ch]
  char v9[64]; // [esp+20h] [ebp-58h] BYREF
  int v10; // [esp+60h] [ebp-18h] BYREF
  int v11; // [esp+64h] [ebp-14h]
  int v12; // [esp+68h] [ebp-10h]
  int v13; // [esp+6Ch] [ebp-Ch]

  v13 = 0;
  v8 = 0;
  v9[0] = 0;
  memset(s, 0, 4u);
  result = memset(&v10, 0, 8u);
  while ( !v13 )
  {
    src = (char *)Com_ParseOnLine(a1);
    if ( !src || !*src )
    {
      result = (void *)Com_UngetToken();
      v13 = 1;
      if ( !v9[0] )
        break;
    }
    if ( !Q_stricmp(src, ",") )
      v13 = 1;
    if ( Q_stricmp(src, "none") )
    {
      if ( Q_stricmp(src, "none,") )
      {
        if ( !Q_stricmp(src, "NOT") )
          src = "MINUS";
        if ( !v13 && Q_stricmp(src, "AND") && Q_stricmp(src, "MINUS") )
        {
          if ( src[strlen(src) - 1] == 44 )
          {
            v13 = 1;
            src[strlen(src) - 1] = 0;
          }
          if ( v9[0] )
            Q_strcat(v9, 64, " ");
          Q_strcat(v9, 64, src);
        }
        if ( !Q_stricmp(src, "AND") || (result = (void *)Q_stricmp(src, "MINUS")) == 0 || v13 )
        {
          if ( v9[0] )
            goto LABEL_31;
          if ( v13 )
          {
            BG_AnimParseError("BG_ParseConditionBits: unexpected end of condition", v6);
            goto LABEL_31;
          }
          result = (void *)Q_stricmp(src, "MINUS");
          if ( result )
          {
            BG_AnimParseError("BG_ParseConditionBits: unexpected '%s'", (char)src);
LABEL_31:
            if ( Q_stricmp(v9, "all") )
            {
              v12 = BG_IndexForString(v9, &dword_8C360[32 * a3], 1);
              if ( v12 < 0 )
              {
                v12 = BG_IndexForString(v9, a2, 0);
                Com_BitSet(&v10, v12);
              }
              else
              {
                v10 = *(int *)((char *)&dword_8C7E0 + (_DWORD)&dword_0[32 * a3 + 2 * v12]);
                v11 = *(int *)((char *)&dword_8C7E4 + (_DWORD)&dword_0[32 * a3 + 2 * v12]);
              }
            }
            else
            {
              v10 = -1;
              v11 = -1;
            }
            if ( v8 )
            {
              *(_DWORD *)s &= ~v10;
              v5 = *((_DWORD *)s + 1) & ~v11;
            }
            else
            {
              *(_DWORD *)s |= v10;
              v5 = *((_DWORD *)s + 1) | v11;
            }
            *((_DWORD *)s + 1) = v5;
            v9[0] = 0;
            result = (void *)Q_stricmp(src, "MINUS");
            if ( !result )
              v8 = 1;
          }
          else
          {
            v8 = 1;
          }
        }
      }
      else
      {
        result = (void *)Com_BitSet(s, 0);
        v13 = 1;
      }
    }
    else
    {
      result = (void *)Com_BitSet(s, 0);
    }
  }
  return result;
}
// 167F8: variable 'v6' is possibly undefined
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15130: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 15830: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 15870: using guessed type int Com_UngetToken(void);
// 159C0: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);
// 8C360: using guessed type int dword_8C360[];
// 8C7E0: using guessed type int dword_8C7E0;
// 8C7E4: using guessed type int dword_8C7E4;

//----- (0001696B) --------------------------------------------------------
int __cdecl sub_1696B(int a1, _DWORD *a2)
{
  char v3; // [esp+4h] [ebp-34h]
  int v4; // [esp+18h] [ebp-20h]
  char *s; // [esp+1Ch] [ebp-1Ch]
  char *sa; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h] BYREF
  int i; // [esp+24h] [ebp-14h]
  int v9; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  for ( i = 0; ; a2[3 * (*a2)++ + 3] = i )
  {
    s = (char *)Com_ParseOnLine(a1);
    if ( !s || !*s )
      break;
    if ( !Q_stricmp(s, "default") )
      return 1;
    v9 = BG_IndexForString(s, &off_802C0, 0);
    v4 = *(int *)((char *)&dword_80380 + (_DWORD)&dword_0[2 * v9]);
    if ( v4 )
    {
      if ( v4 == 1 )
      {
        if ( *(int (**)[128])((char *)&off_80384 + (_DWORD)&dword_0[2 * v9]) )
        {
          sa = (char *)Com_ParseOnLine(a1);
          if ( !sa || !*sa )
            BG_AnimParseError("BG_ParseConditions: expected condition value, found end of line", v3);
          if ( sa[strlen(sa) - 1] == 44 )
            sa[strlen(sa) - 1] = 0;
          v7 = BG_IndexForString(sa, *(int (**)[128])((char *)&off_80384 + (_DWORD)&dword_0[2 * v9]), 0);
        }
        else
        {
          v7 = 1;
        }
      }
    }
    else
    {
      sub_165B9(a1, *(int *)((char *)&off_80384 + (_DWORD)&dword_0[2 * v9]), v9, &v7);
    }
    a2[3 * *a2 + 1] = v9;
    a2[3 * *a2 + 2] = v7;
  }
  if ( !*a2 )
    BG_AnimParseError("BG_ParseConditions: no conditions found", v3);
  return 1;
}
// 16A6A: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15130: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 15830: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 802C0: using guessed type char *off_802C0;
// 80380: using guessed type int dword_80380;
// 80384: using guessed type int (*off_80384)[128];

//----- (00016B3E) --------------------------------------------------------
size_t __cdecl BG_ParseCommands(_DWORD *a1, _DWORD *a2, int a3)
{
  size_t result; // eax
  int *v4; // esi
  int v5; // edx
  char v6; // [esp+4h] [ebp-34h]
  char v7; // [esp+4h] [ebp-34h]
  char v8; // [esp+4h] [ebp-34h]
  char v9; // [esp+4h] [ebp-34h]
  char v10; // [esp+4h] [ebp-34h]
  char v11; // [esp+4h] [ebp-34h]
  const char *v12; // [esp+14h] [ebp-24h]
  int v13; // [esp+18h] [ebp-20h]
  int i; // [esp+1Ch] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-18h]
  _DWORD *v16; // [esp+24h] [ebp-14h]
  char *s; // [esp+28h] [ebp-10h]
  char *sa; // [esp+28h] [ebp-10h]
  char *sb; // [esp+28h] [ebp-10h]
  char *sc; // [esp+28h] [ebp-10h]
  char *sd; // [esp+28h] [ebp-10h]
  char *se; // [esp+28h] [ebp-10h]

  v16 = 0;
  v15 = 0;
  while ( 1 )
  {
    v12 = (const char *)(v15 > 0 ? Com_ParseOnLine(a1) : Com_Parse(a1));
    result = (size_t)v12;
    if ( !v12 )
      return result;
    result = (size_t)v12;
    if ( !*v12 )
      return result;
    if ( !Q_stricmp(v12, "}") )
    {
      result = *a1 - strlen(v12);
      *a1 = result;
      return result;
    }
    if ( !v15 )
    {
      if ( (int)a2[28] > 7 )
        BG_AnimParseError("BG_ParseCommands: exceeded maximum number of animations (%i)", 8);
      v16 = &a2[4 * a2[28]++ + 29];
      memset(v16, 0, sizeof(_DWORD));
    }
    *((_WORD *)v16 + v15) = BG_IndexForString(v12, &animBodyPartsStr, 1);
    if ( *((__int16 *)v16 + v15) <= 0 )
    {
      *a1 -= strlen(v12);
      goto LABEL_60;
    }
    s = (char *)Com_ParseOnLine(a1);
    if ( !s || !*s )
      BG_AnimParseError("BG_ParseCommands: expected animation", v6);
    *((_WORD *)v16 + v15 + 2) = BG_AnimationIndexForString(s);
    *((_WORD *)v16 + v15 + 4) = *(_WORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 72);
    if ( !dword_8CC68 )
    {
      if ( dword_8CC60 && *((_WORD *)v16 + v15) != 2 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 84) |= 1 << dword_8CC60;
        if ( (dword_8CC60 == 16 || dword_8CC60 == 17) && *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 68) )
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 2u;
        for ( i = 0; ; ++i )
        {
          if ( i >= *a2 )
            goto LABEL_32;
          if ( a2[3 * i + 1] == 8 )
            break;
        }
        if ( a2[3 * i + 2] == 1 )
        {
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x10u;
        }
        else if ( a2[3 * i + 2] == 2 )
        {
          *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x20u;
        }
      }
LABEL_32:
      if ( dword_8CC64 == 2 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 8u;
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 64) = 30;
      }
      else if ( dword_8CC64 == 1 )
      {
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 68) = 0;
        *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 0x40u;
      }
      goto LABEL_36;
    }
    do
    {
LABEL_36:
      v13 = 0;
      sa = (char *)Com_ParseOnLine(a1);
      if ( !sa || !*sa )
      {
LABEL_54:
        Com_UngetToken();
        continue;
      }
      if ( Q_stricmp(sa, "duration") )
      {
        if ( Q_stricmp(sa, "turretanim") )
        {
          if ( Q_stricmp(sa, "blendtime") )
            goto LABEL_54;
          v13 = 1;
          sc = (char *)Com_ParseOnLine(a1);
          if ( !sc || !*sc )
            BG_AnimParseError("BG_ParseCommands: expected blendtime value", v9);
          if ( !dword_8CC68 )
          {
            v4 = (int *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 64);
            *v4 = atoi(sc);
          }
        }
        else
        {
          v13 = 1;
          if ( !dword_8CC68 )
            *(_DWORD *)(a3 + 92 * *((__int16 *)v16 + v15 + 2) + 80) |= 4u;
          if ( *((_WORD *)v16 + v15) != 3 )
            BG_AnimParseError("BG_ParseCommands: Turret animations can only be played on the 'both' body part", v8);
        }
      }
      else
      {
        v13 = 1;
        sb = (char *)Com_ParseOnLine(a1);
        if ( !sb || !*sb )
          BG_AnimParseError("BG_ParseCommands: expected duration value", v7);
        *((_WORD *)v16 + v15 + 4) = atoi(sb);
      }
    }
    while ( v13 );
    if ( *((_WORD *)v16 + v15) != 3 )
    {
      v5 = v15++;
      if ( v5 <= 0 )
        continue;
    }
LABEL_60:
    while ( 1 )
    {
      sd = (char *)Com_ParseOnLine(a1);
      if ( !sd || !*sd )
        break;
      if ( Q_stricmp(sd, "sound") )
      {
        BG_AnimParseError("BG_ParseCommands: unknown parameter '%s'", (char)sd);
      }
      else
      {
        se = (char *)Com_ParseOnLine(a1);
        if ( !se || !*se )
          BG_AnimParseError("BG_ParseCommands: expected sound", v10);
        if ( strstr(se, ".wav") )
          BG_AnimParseError("BG_ParseCommands: wav files not supported, only sound scripts", v11);
        v16[3] = (*(int (__cdecl **)(char *))((char *)&dword_9B6D0 + dword_80008))(se);
      }
    }
    v15 = 0;
  }
}
// 16C8A: variable 'v6' is possibly undefined
// 16F90: variable 'v7' is possibly undefined
// 17026: variable 'v8' is possibly undefined
// 17075: variable 'v9' is possibly undefined
// 17159: variable 'v10' is possibly undefined
// 17180: variable 'v11' is possibly undefined
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15130: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 15830: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 15870: using guessed type int Com_UngetToken(void);
// 80008: using guessed type int dword_80008;
// 801A0: using guessed type char *animBodyPartsStr;
// 8CC60: using guessed type int dword_8CC60;
// 8CC64: using guessed type int dword_8CC64;
// 8CC68: using guessed type int dword_8CC68;
// 9B6D0: using guessed type int dword_9B6D0;

//----- (000171D2) --------------------------------------------------------
int __cdecl BG_AnimParseAnimScript(int a1, int a2, int a3)
{
  int v3; // esi
  int v4; // esi
  int v5; // esi
  int v6; // esi
  size_t v7; // eax
  size_t v8; // eax
  int v9; // esi
  size_t v10; // eax
  size_t v11; // eax
  int v12; // esi
  int v13; // esi
  size_t v14; // eax
  size_t v15; // eax
  int v16; // esi
  size_t v17; // eax
  size_t v18; // eax
  char v20; // [esp+4h] [ebp-174h]
  char v21; // [esp+4h] [ebp-174h]
  char v22; // [esp+4h] [ebp-174h]
  char v23; // [esp+4h] [ebp-174h]
  char v24; // [esp+4h] [ebp-174h]
  char v25; // [esp+4h] [ebp-174h]
  char v26; // [esp+4h] [ebp-174h]
  char v27; // [esp+4h] [ebp-174h]
  char v28; // [esp+4h] [ebp-174h]
  char v29; // [esp+4h] [ebp-174h]
  char v30; // [esp+4h] [ebp-174h]
  int v31; // [esp+14h] [ebp-164h]
  int v32; // [esp+18h] [ebp-160h] BYREF
  int v33; // [esp+1Ch] [ebp-15Ch]
  int i; // [esp+20h] [ebp-158h]
  int v35; // [esp+24h] [ebp-154h]
  int v36; // [esp+28h] [ebp-150h]
  int v37; // [esp+2Ch] [ebp-14Ch]
  int v38; // [esp+30h] [ebp-148h]
  int v39; // [esp+34h] [ebp-144h]
  int v40; // [esp+38h] [ebp-140h]
  void **v41; // [esp+4Ch] [ebp-12Ch]
  _DWORD v42[64]; // [esp+50h] [ebp-128h] BYREF
  void *s; // [esp+150h] [ebp-28h]
  int v44; // [esp+154h] [ebp-24h]
  char *v45; // [esp+158h] [ebp-20h]
  int v46[7]; // [esp+15Ch] [ebp-1Ch] BYREF

  v41 = 0;
  if ( !dword_8000C )
  {
    v31 = trap_FS_FOpenFile(off_80020, &v32, 0);
    if ( v31 <= 0 )
      Com_Error(1, byte_73740, (char)off_80020);
    if ( (unsigned int)v31 > 0x1869E )
      Com_Error(1, byte_73740, (char)off_80020);
    trap_FS_Read(byte_8CC80, v31, v32);
    byte_8CC80[v31] = 0;
    trap_FS_FCloseFile(v32);
    dword_8000C = 1;
  }
  dword_80008 = a1;
  dword_8CC68 = a2;
  dword_8CC6C = a3;
  v44 = 0;
  BG_InitWeaponStrings();
  memset(dword_8C360, 0, 0x480u);
  memset(&unk_89C40, 0, 0x2710u);
  memset(&dword_89C00, 0, 0x24u);
  dword_8C350 = 0;
  for ( i = 0; i <= 2; ++i )
    *(&v38 + i) = -1;
  v37 = 0;
  s = 0;
  v46[0] = (int)byte_8CC80;
  Com_BeginParseSession("BG_AnimParseAnimScript");
  while ( 1 )
  {
    v45 = (char *)Com_Parse(v46);
    if ( !v45 || !*v45 )
      break;
    v35 = BG_IndexForString(v45, &off_80340, 1);
    if ( v35 < 0 )
    {
      switch ( v44 )
      {
        case 0:
          if ( !Q_stricmp(v45, "set") )
          {
            v45 = (char *)Com_ParseOnLine(v46);
            if ( !v45 || !*v45 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition type string", v20);
            v33 = BG_IndexForString(v45, &off_802C0, 0);
            if ( *(int *)((char *)&dword_80380 + (_DWORD)&dword_0[2 * v33]) )
              BG_AnimParseError("BG_AnimParseAnimScript: can not make a define of type '%s'", (char)v45);
            v45 = (char *)Com_ParseOnLine(v46);
            if ( !v45 || !*v45 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected condition define string", v21);
            v3 = *(int *)((char *)&dword_89C00 + (_DWORD)&dword_0[v33]) + 16 * v33;
            *(int *)((char *)dword_8C360 + (_DWORD)&dword_0[2 * v3]) = BG_CopyStringIntoBuffer(
                                                                         v45,
                                                                         (int)&unk_89C40,
                                                                         10000,
                                                                         (int)&dword_8C350);
            v4 = *(int *)((char *)&dword_89C00 + (_DWORD)&dword_0[v33]) + 16 * v33;
            *(int *)((char *)&dword_8C364 + (_DWORD)&dword_0[2 * v4]) = sub_15BCC(*(int *)((char *)dword_8C360
                                                                                         + (_DWORD)&dword_0[2 * v4]));
            v45 = (char *)Com_ParseOnLine(v46);
            if ( !v45 )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found end of line", v22);
            if ( Q_stricmp(v45, "=") )
              BG_AnimParseError("BG_AnimParseAnimScript: expected '=', found '%s'", (char)v45);
            sub_165B9(
              (int)v46,
              *(int *)((char *)&off_80384 + (_DWORD)&dword_0[2 * v33]),
              v33,
              &dword_8C7E0[32 * v33 + 2 * *(int *)((char *)&dword_89C00 + (_DWORD)&dword_0[v33])]);
            ++*(int *)((char *)&dword_89C00 + (_DWORD)&dword_0[v33]);
          }
          break;
        case 1:
        case 2:
          if ( Q_stricmp(v45, "{") )
          {
            if ( Q_stricmp(v45, "}") )
            {
              if ( v37 || v38 >= 0 )
              {
                if ( v37 == 1 && v39 < 0 )
                {
                  v6 = v37;
                  *(&v38 + v6) = BG_IndexForString(v45, &off_80080, 0);
                  if ( v44 == 1 )
                  {
                    s = (void *)(516 * v39 + a1 + 9288 * v38 + 47108);
                    dword_8CC60 = v39;
                  }
                  else if ( v44 == 2 )
                  {
                    s = (void *)(516 * v39 + a1 + 9288 * v38 + 84260);
                  }
                  goto LABEL_103;
                }
                if ( v37 == 2 && v40 < 0 )
                {
                  v7 = strlen(v45);
                  v46[0] -= v7;
                  v8 = strlen(v45);
                  if ( Q_strncmp(v46[0], v45, v8) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v24);
                  memset(v42, 0, 0xF4u);
                  v9 = v37;
                  *(&v38 + v9) = sub_1696B((int)v46, v42);
                  if ( *(int *)s > 127 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(int *)((char *)&dword_9B6BC + a1) > 2047 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 0);
                  goto LABEL_71;
                }
                if ( v37 != 3 )
                  goto LABEL_76;
                v10 = strlen(v45);
                v46[0] -= v10;
                v11 = strlen(v45);
                if ( Q_strncmp(v46[0], v45, v11) )
                  BG_AnimParseError("BG_AnimParseAnimScript: internal error", v25);
                goto LABEL_75;
              }
              if ( Q_stricmp(v45, "state") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected 'state'", v23);
              v45 = (char *)Com_ParseOnLine(v46);
              if ( !v45 )
                BG_AnimParseError("BG_AnimParseAnimScript: expected state type", v23);
              v5 = v37;
              *(&v38 + v5) = BG_IndexForString(v45, &animStateStr, 0);
              v45 = (char *)Com_Parse(v46);
              if ( !v45 || Q_stricmp(v45, "{") )
                BG_AnimParseError("BG_AnimParseAnimScript: expected '{'", v20);
              ++v37;
            }
            else
            {
              if ( --v37 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
              if ( v37 == 1 )
                s = 0;
              *(&v38 + v37) = -1;
            }
          }
          else
          {
            if ( v37 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
            if ( *(&v38 + v37) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
            ++v37;
          }
          break;
        case 3:
        case 4:
          if ( Q_stricmp(v45, "{") )
          {
            if ( Q_stricmp(v45, "}") )
            {
              if ( v37 || v38 >= 0 )
              {
                if ( v37 == 1 && v39 < 0 )
                {
                  v14 = strlen(v45);
                  v46[0] -= v14;
                  v15 = strlen(v45);
                  if ( Q_strncmp(v46[0], v45, v15) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v29);
                  memset(v42, 0, 0xF4u);
                  v16 = v37;
                  *(&v38 + v16) = sub_1696B((int)v46, v42);
                  if ( *(int *)s > 127 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum items per script (%i)", 128);
                  if ( *(int *)((char *)&dword_9B6BC + a1) > 2047 )
                    BG_AnimParseError("BG_AnimParseAnimScript: exceeded maximum global items (%i)", 0);
LABEL_71:
                  *((_DWORD *)s + *(_DWORD *)s + 1) = a1 + 244 * (*(int *)((char *)&dword_9B6BC + a1))++ + 136892;
                  v41 = (void **)*((_DWORD *)s + ++*(_DWORD *)s);
                  qmemcpy(v41, v42, 0xF4u);
                }
                else if ( v37 == 2 )
                {
                  v17 = strlen(v45);
                  v46[0] -= v17;
                  v18 = strlen(v45);
                  if ( Q_strncmp(v46[0], v45, v18) )
                    BG_AnimParseError("BG_AnimParseAnimScript: internal error", v30);
LABEL_75:
                  BG_ParseCommands(v46, v41, a1);
                }
                else
                {
LABEL_76:
                  BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
                }
              }
              else
              {
                if ( v44 == 3 )
                {
                  if ( Q_stricmp(v45, "statechange") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected 'statechange', got '%s'", (char)v45);
                  v45 = (char *)Com_ParseOnLine(v46);
                  if ( !v45 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>", v26);
                  v36 = BG_IndexForString(v45, &animStateStr, 0);
                  v45 = (char *)Com_ParseOnLine(v46);
                  if ( !v45 )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected <state type>", v27);
                  v12 = v37;
                  *(&v38 + v12) = BG_IndexForString(v45, &animStateStr, 0);
                  s = (void *)(516 * *(&v38 + v37) + a1 + 2064 * v36 + 121412);
                  v45 = (char *)Com_Parse(v46);
                  if ( !v45 || Q_stricmp(v45, "{") )
                    BG_AnimParseError("BG_AnimParseAnimScript: expected '{'", v28);
                  ++v37;
                }
                else
                {
                  v13 = v37;
                  *(&v38 + v13) = BG_IndexForString(v45, &off_80120, 0);
                  s = (void *)(a1 + 516 * v38 + 129668);
                  dword_8CC64 = *(&v38 + v37);
                }
LABEL_103:
                memset(s, 0, 0x204u);
              }
            }
            else
            {
              if ( --v37 < 0 )
                BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
              if ( !v37 )
                s = 0;
              *(&v38 + v37) = -1;
            }
          }
          else
          {
            if ( v37 > 2 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
            if ( *(&v38 + v37) < 0 )
              BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
            ++v37;
          }
          break;
        default:
          continue;
      }
    }
    else
    {
      if ( v37 )
        BG_AnimParseError("BG_AnimParseAnimScript: unexpected '%s'", (char)v45);
      v44 = v35;
      dword_8CC60 = 0;
      dword_8CC64 = -1;
    }
  }
  if ( v37 )
    BG_AnimParseError("BG_AnimParseAnimScript: unexpected end of file: %s", v20);
  off_80020 = 0;
  return Com_EndParseSession();
}
// 173DA: variable 'v20' is possibly undefined
// 1751F: variable 'v21' is possibly undefined
// 175CB: variable 'v22' is possibly undefined
// 17776: variable 'v23' is possibly undefined
// 1794F: variable 'v24' is possibly undefined
// 17A80: variable 'v25' is possibly undefined
// 17C04: variable 'v26' is possibly undefined
// 17C49: variable 'v27' is possibly undefined
// 17CE7: variable 'v28' is possibly undefined
// 17DCF: variable 'v29' is possibly undefined
// 17F00: variable 'v30' is possibly undefined
// 0: using guessed type int dword_0[];
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 13450: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 13B90: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 14110: using guessed type int Com_EndParseSession(void);
// 14390: using guessed type _DWORD __cdecl BG_ParseCommands(_DWORD, _DWORD, _DWORD);
// 14B50: using guessed type int BG_InitWeaponStrings(void);
// 14DE0: using guessed type _DWORD __cdecl Q_strncmp(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15130: using guessed type _DWORD __cdecl BG_IndexForString(_DWORD, _DWORD, _DWORD);
// 15830: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// 15960: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// 80008: using guessed type int dword_80008;
// 8000C: using guessed type int dword_8000C;
// 80020: using guessed type char *off_80020;
// 80040: using guessed type char *animStateStr;
// 80080: using guessed type char *off_80080;
// 80120: using guessed type char *off_80120;
// 802C0: using guessed type char *off_802C0;
// 80340: using guessed type char *off_80340;
// 80380: using guessed type int dword_80380;
// 80384: using guessed type int (*off_80384)[128];
// 89C00: using guessed type int dword_89C00;
// 8C350: using guessed type int dword_8C350;
// 8C360: using guessed type int dword_8C360[];
// 8C364: using guessed type int dword_8C364;
// 8C7E0: using guessed type int dword_8C7E0[];
// 8CC60: using guessed type int dword_8CC60;
// 8CC64: using guessed type int dword_8CC64;
// 8CC68: using guessed type int dword_8CC68;
// 8CC6C: using guessed type int dword_8CC6C;
// 9B6BC: using guessed type int dword_9B6BC;

//----- (00017F5A) --------------------------------------------------------
int __cdecl sub_17F5A(int a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-14h]
  _DWORD *v5; // [esp+8h] [ebp-Ch]
  int v6; // [esp+Ch] [ebp-8h]

  v6 = 0;
  v5 = a2 + 1;
  while ( v6 < *a2 )
  {
    v3 = *(int *)((char *)&dword_80380 + (_DWORD)&dword_0[2 * *v5]);
    if ( v3 )
    {
      if ( v3 == 1 && *(_DWORD *)(a1 + 8 * *v5 + 1116) != v5[1] )
        return 0;
    }
    else if ( (*(_DWORD *)(a1 + 8 * *v5 + 1116) & v5[1]) == 0 && (*(_DWORD *)(a1 + 8 * *v5 + 1120) & v5[2]) == 0 )
    {
      return 0;
    }
    ++v6;
    v5 += 3;
  }
  return 1;
}
// 0: using guessed type int dword_0[];
// 80380: using guessed type int dword_80380;

//----- (00018023) --------------------------------------------------------
_DWORD *__cdecl sub_18023(int a1, _DWORD *a2)
{
  int v4; // [esp+Ch] [ebp-Ch]
  _DWORD **v5; // [esp+10h] [ebp-8h]

  v4 = 0;
  v5 = (_DWORD **)(a2 + 1);
  while ( v4 < *a2 )
  {
    if ( sub_17F5A((int)&unk_9B6EC + 1200 * a1 + (_DWORD)&bgs, *v5) )
      return *v5;
    ++v4;
    ++v5;
  }
  return 0;
}

//----- (000180A7) --------------------------------------------------------
int __cdecl BG_PlayAnim(_DWORD *a1, int a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  int v8; // [esp+4h] [ebp-10h]
  int v9; // [esp+8h] [ebp-Ch]
  int v10; // [esp+Ch] [ebp-8h]

  v9 = 0;
  if ( a4 )
    v10 = a4;
  else
    v10 = *(_DWORD *)(dword_80008 + 92 * a2 + 72) + 50;
  if ( a3 == 2 )
  {
LABEL_20:
    if ( (int)a1[29] <= 49 || a7 )
    {
      if ( a6 && (a1[30] & 0xFFFFFDFF) == a2 )
      {
        if ( a5 && (*(_BYTE *)(dword_80008 + 92 * a2 + 80) & 0x80) != 0 )
          a1[29] = v10;
      }
      else
      {
        a1[30] = a2 | a1[30] & 0x200 ^ 0x200;
        if ( a5 )
          a1[29] = v10;
      }
    }
    goto LABEL_29;
  }
  if ( a3 > 2 )
  {
    if ( a3 != 3 )
      goto LABEL_29;
  }
  else if ( a3 != 1 )
  {
    goto LABEL_29;
  }
  if ( (int)a1[27] <= 49 || a7 )
  {
    if ( a6 && (a1[28] & 0xFFFFFDFF) == a2 )
    {
      if ( a5 && (*(_BYTE *)(dword_80008 + 92 * a2 + 80) & 0x80) != 0 )
        a1[27] = v10;
    }
    else
    {
      v9 = 1;
      a1[28] = a2 | a1[28] & 0x200 ^ 0x200;
      if ( a5 )
        a1[27] = v10;
    }
  }
  if ( a3 == 3 )
  {
    a2 = 0;
    goto LABEL_20;
  }
LABEL_29:
  if ( v9 )
    v8 = v10;
  else
    v8 = -1;
  return v8;
}
// 80008: using guessed type int dword_80008;

//----- (0001823F) --------------------------------------------------------
int __cdecl BG_PlayAnimName(int a1, char *src, int a3, int a4, int a5, int a6)
{
  int v6; // eax

  v6 = BG_AnimationIndexForString(src);
  return BG_PlayAnim(a1, v6, a3, 0, a4, a5, a6);
}
// 139B0: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00018297) --------------------------------------------------------
int __cdecl BG_ExecuteCommand(int a1, __int16 *a2, int a3, int a4, int a5)
{
  int v6; // [esp+28h] [ebp-10h]
  _BOOL4 v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v8 = -1;
  v7 = 0;
  if ( *a2 )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = BG_PlayAnim(a1, a2[2], *a2, v8, a3, a4, a5) >= 0;
    else
      BG_PlayAnim(a1, a2[2], *a2, v8, a3, a4, a5);
  }
  if ( a2[1] )
  {
    v8 = a2[4] + 50;
    if ( *a2 == 1 || *a2 == 3 )
      v7 = BG_PlayAnim(a1, a2[3], a2[1], v8, a3, a4, a5) >= 0;
    else
      BG_PlayAnim(a1, a2[3], a2[1], v8, a3, a4, a5);
  }
  if ( *((_DWORD *)a2 + 3) )
    (*(void (__cdecl **)(_DWORD, _DWORD))((char *)&dword_9B6D4 + dword_80008))(
      *(_DWORD *)(a1 + 172),
      *((_DWORD *)a2 + 3));
  if ( v7 )
    v6 = v8;
  else
    v6 = -1;
  return v6;
}
// 139B0: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80008: using guessed type int dword_80008;
// 9B6D4: using guessed type int dword_9B6D4;

//----- (00018465) --------------------------------------------------------
int __cdecl BG_AnimScriptAnimation(int a1, int a2, int a3, int a4)
{
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  v6 = 0;
  if ( *(int *)(a1 + 4) > 5 )
    return -1;
  while ( !v6 && a2 >= 0 )
  {
    if ( *(_DWORD *)(516 * a3 + dword_80008 + 9288 * a2 + 47108) )
    {
      v6 = sub_18023(*(_DWORD *)(a1 + 172), (_DWORD *)(516 * a3 + dword_80008 + 9288 * a2 + 47108));
      if ( !v6 )
        --a2;
    }
    else
    {
      --a2;
    }
  }
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  BG_UpdateConditionValue(*(_DWORD *)(a1 + 172), 3, a3, 1);
  return BG_ExecuteCommand(a1, &v6[4 * (*(_DWORD *)(a1 + 172) % v6[28]) + 29], 0, a4, 0) != -1;
}
// 13D20: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// 80008: using guessed type int dword_80008;

//----- (000185C9) --------------------------------------------------------
int __cdecl BG_AnimScriptStateChange(int a1, int a2, int a3)
{
  int v5; // [esp+28h] [ebp-10h]
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  if ( *(int *)(a1 + 4) > 5 )
    return -1;
  if ( !*(_DWORD *)(516 * a2 + dword_80008 + 2064 * a3 + 121412) )
    return -1;
  v6 = sub_18023(*(_DWORD *)(a1 + 172), (_DWORD *)(516 * a2 + dword_80008 + 2064 * a3 + 121412));
  if ( !v6 )
    return -1;
  if ( !v6[28] )
    return -1;
  v5 = (int)&v6[4 * (rand() % v6[28]) + 29];
  return BG_ExecuteCommand(a1, v5, 1, 0, 0);
}
// 13D20: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80008: using guessed type int dword_80008;

//----- (000186C1) --------------------------------------------------------
int __cdecl BG_AnimScriptEvent(int a1, int a2, int a3, int a4)
{
  int v6; // [esp+28h] [ebp-10h]
  _DWORD *v7; // [esp+2Ch] [ebp-Ch]
  _DWORD *v8; // [esp+30h] [ebp-8h]

  if ( a2 != 1 && *(int *)(a1 + 4) > 5 )
    return -1;
  v8 = (_DWORD *)(dword_80008 + 516 * a2 + 129668);
  if ( !*v8 )
    return -1;
  v7 = sub_18023(*(_DWORD *)(a1 + 172), v8);
  if ( !v7 )
    return -1;
  if ( !v7[28] )
    return -1;
  v6 = (int)&v7[4 * (rand() % v7[28]) + 29];
  return BG_ExecuteCommand(a1, v6, 1, a3, a4);
}
// 13D20: using guessed type _DWORD __cdecl BG_ExecuteCommand(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80008: using guessed type int dword_80008;

//----- (000187AB) --------------------------------------------------------
int __cdecl BG_GetAnimString(int a1, unsigned int a2)
{
  char v3; // [esp+4h] [ebp-4h]

  if ( a2 >= *(_DWORD *)(dword_80008 + 47104) )
    BG_AnimParseError("BG_GetAnimString: anim index is out of range", v3);
  return dword_80008 + 92 * a2;
}
// 187D7: variable 'v3' is possibly undefined
// 80008: using guessed type int dword_80008;

//----- (000187EE) --------------------------------------------------------
int __cdecl BG_UpdateConditionValue(int a1, int a2, int a3, int a4)
{
  int result; // eax

  if ( !a4 || *(int *)((char *)&dword_80380 + (_DWORD)&dword_0[2 * a2]) )
  {
    result = a3;
    *(int *)((char *)dword_9BB48 + (_DWORD)&bgs + 1200 * a1 + 8 * a2) = a3;
  }
  else
  {
    *(int *)((char *)dword_9BB48 + (_DWORD)&bgs + 1200 * a1 + 8 * a2) = 0;
    *(int *)((char *)&dword_9BB4C + (_DWORD)&bgs + 1200 * a1 + 8 * a2) = 0;
    result = Com_BitSet((char *)&dword_9BB48[300 * a1 + 2 * a2] + (_DWORD)&bgs, a3);
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 159C0: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);
// 80380: using guessed type int dword_80380;
// 9BB48: using guessed type int dword_9BB48[];
// 9BB4C: using guessed type int dword_9BB4C;

//----- (000188A4) --------------------------------------------------------
unsigned int __cdecl sub_188A4(int a1, int a2, int a3)
{
  unsigned int i; // [esp+Ch] [ebp-Ch]

  if ( !a3 || *(int *)((char *)&dword_80380 + (_DWORD)&dword_0[2 * a2]) )
    return *(_DWORD *)(a1 + 8 * a2 + 1116);
  for ( i = 0; i <= 0x3F; ++i )
  {
    if ( Com_BitCheck(a1 + 8 * a2 + 1116, i) )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 80380: using guessed type int dword_80380;

//----- (00018930) --------------------------------------------------------
int __cdecl BG_GetAnimScriptEvent(int a1, int a2)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  _DWORD *v5; // [esp+20h] [ebp-8h]

  if ( a2 != 1 && *(int *)(a1 + 4) > 5 )
    return -1;
  v5 = (_DWORD *)(dword_80008 + 516 * a2 + 129668);
  if ( !*v5 )
    return -1;
  v4 = sub_18023(*(_DWORD *)(a1 + 172), v5);
  if ( !v4 )
    return -1;
  if ( v4[28] )
    return SLOWORD(v4[4 * (rand() % v4[28]) + 30]);
  return -1;
}
// 80008: using guessed type int dword_80008;

//----- (000189F6) --------------------------------------------------------
int __cdecl BG_GetAnimationForIndex(int a1, unsigned int a2)
{
  char v3; // [esp+8h] [ebp-10h]

  if ( a2 >= *(_DWORD *)(dword_80008 + 47104) )
    Com_Error(1, byte_73BE0, v3);
  return dword_80008 + 92 * a2;
}
// 18A2A: variable 'v3' is possibly undefined
// 80008: using guessed type int dword_80008;

//----- (00018A41) --------------------------------------------------------
int __cdecl BG_AnimUpdatePlayerStateConditions(_BYTE *a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)a1;
  BG_UpdateConditionValue(*(_DWORD *)(*(_DWORD *)a1 + 172), 0, *(_DWORD *)(*(_DWORD *)a1 + 176), 1);
  v1 = BG_GetInfoForWeapon(*(_DWORD *)(v3 + 176));
  BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 1, *(_DWORD *)(v1 + 116), 1);
  if ( (*(_DWORD *)(v3 + 128) & 0x200) != 0 )
    BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 7, 1, 1);
  else
    BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 7, 0, 1);
  if ( (*(_WORD *)(v3 + 128) & 0xC000) != 0 )
    BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 2, 1, 1);
  else
    BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 2, 0, 1);
  BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 4, *(float *)(v3 + 192) > 0.0, 1);
  if ( (a1[8] & 1) != 0 )
    result = BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 6, 1, 1);
  else
    result = BG_UpdateConditionValue(*(_DWORD *)(v3 + 172), 6, 0, 1);
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00018C3A) --------------------------------------------------------
_BOOL4 __cdecl BG_IsCrouchingAnim(int a1, int a2)
{
  return (*(_BYTE *)(BG_GetAnimationForIndex(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0xC4) != 0;
}
// 13490: using guessed type _DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD);

//----- (00018C92) --------------------------------------------------------
_BOOL4 __cdecl BG_IsProneAnim(int a1, int a2)
{
  return (*(_DWORD *)(BG_GetAnimationForIndex(*(_DWORD *)(a1 + 8), a2 & 0xFFFFFDFF) + 84) & 0x308) != 0;
}
// 13490: using guessed type _DWORD __cdecl BG_GetAnimationForIndex(_DWORD, _DWORD);

//----- (00018CED) --------------------------------------------------------
_DWORD *__cdecl sub_18CED(int *a1, int *a2, int a3, int a4)
{
  int v4; // esi
  int v5; // esi
  _DWORD *result; // eax
  float v7; // [esp+8h] [ebp-70h]
  float v8; // [esp+Ch] [ebp-6Ch]
  float v9; // [esp+Ch] [ebp-6Ch]
  float v10; // [esp+Ch] [ebp-6Ch]
  float v11; // [esp+Ch] [ebp-6Ch]
  float v12; // [esp+Ch] [ebp-6Ch]
  float v13; // [esp+Ch] [ebp-6Ch]
  int v14; // [esp+28h] [ebp-50h]
  int v15; // [esp+40h] [ebp-38h]
  int v16; // [esp+44h] [ebp-34h]
  int v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  float v19; // [esp+54h] [ebp-24h]
  float v20; // [esp+54h] [ebp-24h]
  int v21; // [esp+58h] [ebp-20h]
  int v22; // [esp+5Ch] [ebp-1Ch]
  int v23; // [esp+64h] [ebp-14h]
  int v24; // [esp+68h] [ebp-10h]
  char *v25; // [esp+6Ch] [ebp-Ch]
  unsigned int v26; // [esp+88h] [ebp+10h]

  v23 = -1;
  v21 = 0;
  v19 = 0.0;
  v24 = a2[5];
  v22 = a2[4];
  if ( !v24 )
    v21 = 1;
  a2[4] = a3;
  v26 = a3 & 0xFFFFFDFF;
  if ( v26 >= *((_DWORD *)&bgs + 11776) )
    Com_Error(1, byte_73C20, *((_DWORD *)&bgs + 11776));
  v18 = a1[298];
  v17 = *(int *)((char *)&dword_9B6C0 + (_DWORD)&bgs);
  HIWORD(v16) = Scr_GetAnimsIndex(v17);
  if ( v26 )
  {
    v25 = (char *)&bgs + 92 * v26;
    a2[5] = (int)v25;
    a2[6] = *((_DWORD *)v25 + 16);
    if ( a2 == a1 + 224 )
    {
      v4 = BG_IsCrouchingAnim(a1, v26);
      if ( v4 != BG_IsCrouchingAnim(a1, v22) || (v5 = BG_IsProneAnim(a1, v26), v5 != BG_IsProneAnim(a1, v22)) )
        a1[297] = bg[0] + 400;
    }
  }
  else
  {
    v25 = 0;
    a2[5] = 0;
    a2[6] = 200;
  }
  if ( v21 && a2 == a1 + 224 )
  {
    a2[6] = 0;
  }
  else
  {
    if ( !v25 || a2[6] <= 0 )
    {
      if ( v25 && *((_DWORD *)v25 + 17) )
      {
        v23 = 120;
      }
      else if ( v24 && *(_DWORD *)(v24 + 68) )
      {
        v23 = 250;
      }
      else
      {
        v23 = 170;
      }
    }
    if ( a1[297] - bg[0] > v23 )
      v23 = a1[297] - bg[0];
    if ( a2[6] < v23 )
      a2[6] = v23;
  }
  if ( v25 )
  {
    if ( *((_DWORD *)v25 + 17) )
    {
      LOWORD(v16) = v26;
      if ( trap_XAnimIsLooped(v16) )
      {
        LOWORD(v16) = v22 & 0xFDFF;
        if ( v24 && *(_DWORD *)(v24 + 68) && trap_XAnimIsLooped(v16) )
        {
          v19 = trap_XAnimGetTime(v18, v16);
        }
        else
        {
          if ( trap_XAnimIsPrimitive(v16) )
            v15 = trap_XAnimGetLength(v17, (unsigned __int16)v16) + 200;
          else
            v15 = 1000;
          v20 = (long double)(bg[0] % v15) / (long double)v15 + (long double)a1[2] * 0.36000001;
          v19 = v20 - (long double)(int)v20;
        }
      }
    }
  }
  if ( v24 )
  {
    v7 = (long double)a2[6] * 0.001;
    trap_XAnimClearGoalWeight(v18, v22 & 0xFDFF, LODWORD(v7));
  }
  if ( v26 )
  {
    if ( a2 != a1 + 224 )
    {
      a1[253] = 0;
      a1[254] = 1;
    }
    LOWORD(v16) = v26;
    if ( (*((_DWORD *)v25 + 20) & 0x40) != 0 )
    {
      if ( trap_XAnimIsLooped(v16) )
        Com_Error(1, "death animation '%s' is looping", (char)v25);
      if ( a4 )
      {
        v8 = (long double)a2[6] * 0.001;
        trap_XAnimSetCompleteGoalWeight(v18, v26, 1065353216, LODWORD(v8), 1065353216, 0, 0);
      }
      else
      {
        trap_XAnimSetCompleteGoalWeightKnobAll(
          v18,
          v26,
          *(int *)((char *)&dword_9B6DC + (_DWORD)&bgs),
          1065353216,
          0,
          1065353216,
          0,
          0);
        trap_XAnimSetTime(v18, v26, 1065353216);
      }
    }
    else
    {
      v14 = 0;
      if ( *((_DWORD *)v25 + 17) && trap_XAnimGetWeight(v18, v26) == 0.0 )
        v14 = 1;
      v9 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        v26,
        1065353216,
        LODWORD(v9),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        a2 != a1 + 224);
      if ( v14 )
        trap_XAnimSetTime(v18, v26, LODWORD(v19));
    }
    if ( a2 != a1 + 224 )
    {
      v10 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        *(int *)((char *)&dword_9B6C4 + (_DWORD)&bgs),
        1065353216,
        LODWORD(v10),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        0);
      v11 = (long double)a2[6] * 0.001;
      trap_XAnimSetCompleteGoalWeight(
        v18,
        *(int *)((char *)&dword_9B6C8 + (_DWORD)&bgs),
        1008981770,
        LODWORD(v11),
        1065353216,
        *((unsigned __int16 *)v25 + 44),
        0);
    }
  }
  else if ( a2 != a1 + 224 )
  {
    v12 = (long double)a2[6] * 0.001;
    trap_XAnimSetCompleteGoalWeight(
      v18,
      *(int *)((char *)&dword_9B6C4 + (_DWORD)&bgs),
      0,
      LODWORD(v12),
      1065353216,
      0,
      0);
    v13 = (long double)a2[6] * 0.001;
    trap_XAnimSetCompleteGoalWeight(
      v18,
      *(int *)((char *)&dword_9B6C8 + (_DWORD)&bgs),
      1065353216,
      LODWORD(v13),
      1065353216,
      0,
      0);
  }
  result = bg_debugAnim;
  if ( bg_debugAnim[3] == 1 )
  {
    if ( a2 == a1 + 224 )
      result = (_DWORD *)Com_Printf("Anim-%s: %i, %s, (blend time) %i\n", (char)"legs ");
    else
      result = (_DWORD *)Com_Printf("Anim-%s: %i, %s, (blend time) %i\n", (char)"torso");
  }
  return result;
}
// 12F70: using guessed type _DWORD __cdecl trap_XAnimSetCompleteGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 131F0: using guessed type _DWORD __cdecl BG_IsProneAnim(_DWORD, _DWORD);
// 132D0: using guessed type _DWORD __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(_DWORD, __int16, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13600: using guessed type _DWORD __cdecl BG_IsCrouchingAnim(_DWORD, _DWORD);
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 13FC0: using guessed type _DWORD __cdecl trap_XAnimGetLength(_DWORD, _DWORD);
// 142C0: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 14940: using guessed type _DWORD __cdecl trap_XAnimIsLooped(_DWORD);
// 14A40: using guessed type _DWORD __cdecl trap_XAnimClearGoalWeight(_DWORD, __int16, _DWORD);
// 15470: using guessed type long double __cdecl trap_XAnimGetTime(_DWORD, __int16);
// 15740: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);
// 157A0: using guessed type _DWORD __cdecl trap_XAnimSetTime(_DWORD, __int16, _DWORD);
// 9B6C0: using guessed type int dword_9B6C0;
// 9B6C4: using guessed type int dword_9B6C4;
// 9B6C8: using guessed type int dword_9B6C8;
// 9B6DC: using guessed type int dword_9B6DC;

//----- (000193FB) --------------------------------------------------------
unsigned int __cdecl sub_193FB(int *a1, unsigned int a2, int a3, int a4)
{
  unsigned int result; // eax
  int v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+2Ch] [ebp-2Ch]
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+40h] [ebp-18h]
  int v10; // [esp+50h] [ebp-8h]

  v5 = 0;
  if ( *(_DWORD *)(a2 + 20) && (*(_DWORD *)(*(_DWORD *)(a2 + 20) + 80) & 2) != 0 )
    v5 = 1;
  v9 = a1[298];
  Scr_GetAnimsIndex(*(int *)((char *)&dword_9B6C0 + (_DWORD)&bgs));
  if ( a3 != *(_DWORD *)(a2 + 16) || !*(_DWORD *)(a2 + 20) && (a3 & 0xFFFFFDFF) != 0 )
    sub_18CED(a1, (int *)a2, a3, (*(_DWORD *)(a4 + 8) >> 11) & 1);
  result = a3 & 0xFFFFFDFF;
  if ( (a3 & 0xFFFFFDFF) != 0 )
  {
    v10 = *(_DWORD *)(a2 + 20);
    if ( *(_DWORD *)(v10 + 68) && *(_DWORD *)(a2 + 44) )
    {
      if ( bg[1] != *(_DWORD *)(a2 + 44) )
      {
        if ( v5 )
          v7 = fabs(*(float *)(a2 + 36) - *(float *)(a4 + 32));
        else
          v7 = VectorDistance(a2 + 28, a4 + 24);
        v8 = v7 / ((long double)(bg[1] - *(_DWORD *)(a2 + 44)) * 0.001);
        *(float *)(a2 + 40) = v8 / (long double)*(int *)(v10 + 68);
        *(_DWORD *)(a2 + 44) = bg[1];
        *(_DWORD *)(a2 + 28) = *(_DWORD *)(a4 + 24);
        *(_DWORD *)(a2 + 32) = *(_DWORD *)(a4 + 28);
        *(_DWORD *)(a2 + 36) = *(_DWORD *)(a4 + 32);
        if ( *(float *)(a2 + 40) >= 0.1 )
        {
          if ( *(float *)(a2 + 40) > 2.0 )
          {
            if ( (*(_DWORD *)(v10 + 80) & 2) != 0 )
            {
              if ( *(float *)(a2 + 40) > 4.0 )
                *(_DWORD *)(a2 + 40) = 1082130432;
            }
            else if ( *(int *)(v10 + 68) <= 150 )
            {
              if ( *(int *)(v10 + 68) > 19 )
              {
                v6 = 3.0 - (long double)(*(_DWORD *)(v10 + 68) - 20) / 130.0;
                if ( *(float *)(a2 + 40) > (long double)v6 )
                  *(float *)(a2 + 40) = v6;
              }
              else if ( *(float *)(a2 + 40) > 3.0 )
              {
                *(_DWORD *)(a2 + 40) = 1077936128;
              }
            }
            else
            {
              *(_DWORD *)(a2 + 40) = 0x40000000;
            }
          }
        }
        else if ( *(float *)(a2 + 40) < 0.0099999998 && v5 )
        {
          *(_DWORD *)(a2 + 40) = 0;
        }
        else
        {
          *(_DWORD *)(a2 + 40) = 1036831949;
        }
        if ( bg_debugAnim[3] == 2 )
          Com_Printf("MoveSpeed: %s, %i, %4.4f : %1.4f\n", 92 * a3 + (unsigned __int8)&bgs);
      }
    }
    else
    {
      *(_DWORD *)(a2 + 40) = 1065353216;
      *(_DWORD *)(a2 + 44) = bg[1];
      *(_DWORD *)(a2 + 28) = *(_DWORD *)(a4 + 24);
      *(_DWORD *)(a2 + 32) = *(_DWORD *)(a4 + 28);
      *(_DWORD *)(a2 + 36) = *(_DWORD *)(a4 + 32);
    }
    result = a2;
    if ( *(_DWORD *)(a2 + 16) )
      result = trap_XAnimSetAnimRate(v9, *(_WORD *)(a2 + 16) & 0xFDFF, *(_DWORD *)(a2 + 40));
  }
  return result;
}
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 145F0: using guessed type _DWORD __cdecl trap_XAnimSetAnimRate(_DWORD, __int16, _DWORD);
// 15270: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 9B6C0: using guessed type int dword_9B6C0;

//----- (000197B0) --------------------------------------------------------
void __cdecl sub_197B0(int a1, _DWORD *a2)
{
  Scr_GetAnimsIndex(*(int *)((char *)&dword_9B6C0 + (_DWORD)&bgs));
  if ( a2[4] )
  {
    if ( trap_XAnimGetWeight(a1, a2[4] & 0xFDFF) == 0.0 )
    {
      a2[4] = 0;
      a2[5] = 0;
      a2[6] = 150;
    }
  }
}
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 142C0: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 9B6C0: using guessed type int dword_9B6C0;

//----- (00019842) --------------------------------------------------------
void __usercall sub_19842(long double a1@<st0>, float a2, float a3, float a4, float a5, int a6, int a7)
{
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  float v10; // [esp+0h] [ebp-28h]
  float v11; // [esp+0h] [ebp-28h]
  float v12; // [esp+0h] [ebp-28h]
  float v13; // [esp+18h] [ebp-10h]
  float v14; // [esp+18h] [ebp-10h]
  float v15; // [esp+1Ch] [ebp-Ch]
  float v16; // [esp+20h] [ebp-8h]
  float v17; // [esp+20h] [ebp-8h]
  float v18; // [esp+20h] [ebp-8h]

  if ( !*(_DWORD *)a7 )
  {
    AngleSubtract(*(float *)a6, a2);
    v16 = a1;
    a1 = a3;
    if ( v16 > (long double)a3 || (a1 = v16, -a3 > (long double)v16) )
      *(_DWORD *)a7 = 1;
  }
  if ( *(_DWORD *)a7 )
  {
    AngleSubtract(a2, *(float *)a6);
    v17 = a1;
    v13 = fabs(v17);
    v14 = v13 * 0.050000001;
    if ( v14 < 0.5 )
      v14 = 0.5;
    if ( v17 < 0.0 )
    {
      v7 = v17;
      if ( v17 >= 0.0 )
        goto LABEL_17;
      v15 = (long double)bg[2] * v14 * -a5;
      if ( v17 < (long double)v15 )
      {
        *(_DWORD *)a7 = 1;
      }
      else
      {
        v15 = v17;
        *(_DWORD *)a7 = 0;
      }
    }
    else
    {
      v15 = (long double)bg[2] * v14 * a5;
      if ( v15 < (long double)v17 )
      {
        *(_DWORD *)a7 = 1;
      }
      else
      {
        v15 = a1;
        *(_DWORD *)a7 = 0;
      }
    }
    v7 = *(float *)a6 + v15;
    v10 = v7;
    AngleMod(v10);
    *(float *)a6 = v7;
LABEL_17:
    AngleSubtract(a2, *(float *)a6);
    v18 = v7;
    if ( v18 <= (long double)a4 )
    {
      if ( -a4 > (long double)v18 )
      {
        v9 = a2 + a4;
        v12 = v9;
        AngleMod(v12);
        *(float *)a6 = v9;
      }
    }
    else
    {
      v8 = a2 - a4;
      v11 = v8;
      AngleMod(v11);
      *(float *)a6 = v8;
    }
  }
}

//----- (00019A3A) --------------------------------------------------------
void __usercall sub_19A3A(long double a1@<st0>, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+20h] [ebp-48h]
  float v6; // [esp+24h] [ebp-44h]
  float v7; // [esp+34h] [ebp-34h]
  float v8; // [esp+44h] [ebp-24h]
  float v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+5Ch] [ebp-Ch]

  GetLeanFraction(*(float *)(a3 + 996));
  v9 = *(float *)(a3 + 992);
  v5 = *(float *)(a3 + 1000);
  AngleMod(*(float *)(a3 + 1004));
  v6 = a1;
  if ( (*(_WORD *)(a2 + 8) & 0xC000) != 0 )
  {
    *(_DWORD *)(a3 + 948) = 1;
    *(_DWORD *)(a3 + 956) = 1;
    *(_DWORD *)(a3 + 900) = 1;
  }
  else if ( (sub_188A4(a3, 3, 0) & 0x30000) != 0 )
  {
    *(_DWORD *)(a3 + 948) = 1;
    *(_DWORD *)(a3 + 956) = 1;
    *(_DWORD *)(a3 + 900) = 1;
  }
  else if ( (sub_188A4(a3, 3, 0) & 6) != 0 )
  {
    if ( sub_188A4(a3, 6, 1) )
    {
      *(_DWORD *)(a3 + 948) = 1;
      *(_DWORD *)(a3 + 956) = 1;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 948) = 1;
    *(_DWORD *)(a3 + 956) = 1;
    *(_DWORD *)(a3 + 900) = 1;
  }
  v3 = v6 + v9;
  v8 = v3;
  if ( (*(_DWORD *)(a2 + 8) & 1) != 0 )
  {
    v8 = v6;
    sub_19842(v3, v6, 0.0, 90.0, bg_swingSpeed[2], a3 + 944, a3 + 948);
  }
  else if ( (sub_188A4(a3, 3, 0) & 0x30000) != 0 )
  {
    sub_19842(v3, v8, 0.0, 0.0, bg_swingSpeed[2], a3 + 944, a3 + 948);
  }
  else if ( (*(_DWORD *)(a2 + 8) & 0x40) != 0 )
  {
    sub_19842(v3, v6, 0.0, 90.0, bg_swingSpeed[2], a3 + 944, a3 + 948);
  }
  else if ( (*(_DWORD *)(a2 + 8) & 0x400) != 0 )
  {
    sub_19842(v3, v6, 0.0, 45.0, bg_swingSpeed[2], a3 + 944, a3 + 948);
  }
  else
  {
    if ( (*(_DWORD *)(a2 + 8) & 0x200) != 0 )
    {
      v7 = v6;
    }
    else
    {
      v3 = v9 * 0.30000001 + v6;
      v7 = v3;
    }
    sub_19842(v3, v7, 0.0, 90.0, bg_swingSpeed[2], a3 + 944, a3 + 948);
  }
  if ( (*(_DWORD *)(a2 + 8) & 1) != 0 )
    goto LABEL_22;
  if ( (*(_DWORD *)(a2 + 8) & 0x40) != 0 )
  {
    *(_DWORD *)(a3 + 900) = 0;
    v3 = v6 + v9;
    *(float *)(a3 + 896) = v3;
  }
  else if ( (bgs[23 * (*(_DWORD *)(a2 + 204) & 0xFFFFFDFF) + 20] & 0x30) != 0 )
  {
    *(_DWORD *)(a3 + 900) = 0;
    sub_19842(v3, v6, 0.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
  }
  else
  {
    if ( *(_DWORD *)(a3 + 900) )
    {
LABEL_22:
      sub_19842(v3, v8, 0.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
      goto LABEL_29;
    }
    sub_19842(v3, v8, 40.0, 150.0, bg_swingSpeed[2], a3 + 896, a3 + 900);
  }
LABEL_29:
  if ( (*(_WORD *)(a2 + 8) & 0xC000) != 0 )
  {
    *(float *)(a3 + 944) = v6;
    *(float *)(a3 + 896) = v6;
  }
  else if ( (sub_188A4(a3, 3, 0) & 0x30000) != 0 )
  {
    *(float *)(a3 + 944) = v6 + v9;
    v3 = v6 + v9;
    *(float *)(a3 + 896) = v3;
  }
  if ( (*(_DWORD *)(a2 + 8) & 1) != 0 || (*(_WORD *)(a2 + 8) & 0xC000) != 0 || (sub_188A4(a3, 3, 0) & 0x30000) != 0 )
  {
    sub_19842(v3, 0.0, 0.0, 45.0, 0.15000001, a3 + 952, a3 + 956);
  }
  else
  {
    if ( v5 <= 180.0 )
      v4 = v5 * 0.60000002;
    else
      v4 = (v5 + -360.0) * 0.60000002;
    v10 = v4;
    sub_19842(v4, v10, 0.0, 45.0, 0.15000001, a3 + 952, a3 + 956);
  }
}

//----- (00019FB4) --------------------------------------------------------
int __cdecl sub_19FB4(_DWORD *a1, int a2)
{
  int v2; // eax
  unsigned int v4; // [esp+10h] [ebp-8h]

  BG_UpdateConditionValue(a1[36], 0, a1[50], 1);
  v2 = BG_GetInfoForWeapon(a1[50]);
  BG_UpdateConditionValue(a1[36], 1, *(_DWORD *)(v2 + 116), 1);
  if ( (a1[2] & 0x200) != 0 )
    BG_UpdateConditionValue(a1[36], 7, 1, 1);
  else
    BG_UpdateConditionValue(a1[36], 7, 0, 1);
  if ( (a1[2] & 0xC000) != 0 )
    BG_UpdateConditionValue(a1[36], 2, 1, 1);
  else
    BG_UpdateConditionValue(a1[36], 2, 0, 1);
  BG_UpdateConditionValue(a1[36], 4, *(float *)(a2 + 1000) > 0.0, 1);
  if ( (a1[2] & 0x20) != 0 )
    BG_UpdateConditionValue(a1[36], 5, 1, 1);
  else
    BG_UpdateConditionValue(a1[36], 5, 0, 1);
  if ( (a1[2] & 0x400) != 0 )
    BG_UpdateConditionValue(a1[36], 6, 1, 1);
  else
    BG_UpdateConditionValue(a1[36], 6, 0, 1);
  v4 = a1[51] & 0xFFFFFDFF;
  if ( bgs[23 * v4 + 21] )
    BG_UpdateConditionValue(a1[36], 3, bgs[23 * v4 + 21], 0);
  if ( (bgs[23 * v4 + 20] & 0x10) != 0 )
    return BG_UpdateConditionValue(a1[36], 8, 1, 1);
  if ( (bgs[23 * v4 + 20] & 0x20) != 0 )
    return BG_UpdateConditionValue(a1[36], 8, 2, 1);
  return BG_UpdateConditionValue(a1[36], 8, 0, 1);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001A314) --------------------------------------------------------
int sub_1A314()
{
  return 0;
}

//----- (0001A31E) --------------------------------------------------------
int __cdecl sub_1A31E(int a1)
{
  return trap_XModelGet(a1);
}
// 14A70: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);

//----- (0001A341) --------------------------------------------------------
int __cdecl sub_1A341(int a1, unsigned __int16 a2, int a3, int a4)
{
  return trap_DObjCreate(a1, a2, a3, a4, 0);
}
// 13220: using guessed type _DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001A389) --------------------------------------------------------
void *__usercall sub_1A389@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5, void *s)
{
  void *result; // eax
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  float v11; // [esp+0h] [ebp-E8h]
  int i; // [esp+30h] [ebp-B8h]
  float v13; // [esp+34h] [ebp-B4h] BYREF
  float v14[2]; // [esp+38h] [ebp-B0h] BYREF
  float v15; // [esp+40h] [ebp-A8h] BYREF
  float v16; // [esp+44h] [ebp-A4h]
  float v17; // [esp+48h] [ebp-A0h]
  float v18; // [esp+50h] [ebp-98h] BYREF
  float v19; // [esp+54h] [ebp-94h]
  float v20; // [esp+58h] [ebp-90h]
  float v21; // [esp+6Ch] [ebp-7Ch]
  float v22; // [esp+70h] [ebp-78h]
  float v23; // [esp+74h] [ebp-74h]
  void *v24; // [esp+78h] [ebp-70h]
  float v25; // [esp+80h] [ebp-68h] BYREF
  float v26; // [esp+84h] [ebp-64h]
  float v27; // [esp+88h] [ebp-60h]
  float v28; // [esp+90h] [ebp-58h]
  float v29; // [esp+94h] [ebp-54h]
  float v30; // [esp+98h] [ebp-50h]
  float v31; // [esp+9Ch] [ebp-4Ch]
  float v32; // [esp+A0h] [ebp-48h]
  float v33; // [esp+A4h] [ebp-44h]
  float v34; // [esp+A8h] [ebp-40h]
  float v35; // [esp+ACh] [ebp-3Ch]
  float v36; // [esp+B0h] [ebp-38h]
  float v37; // [esp+B4h] [ebp-34h]
  float v38; // [esp+B8h] [ebp-30h]
  int v39; // [esp+BCh] [ebp-2Ch]
  float v40; // [esp+C0h] [ebp-28h]
  float v41; // [esp+C4h] [ebp-24h]
  float v42; // [esp+C8h] [ebp-20h]
  float v43; // [esp+CCh] [ebp-1Ch]
  int v44; // [esp+D0h] [ebp-18h]
  int v45; // [esp+D4h] [ebp-14h]

  if ( (*(_WORD *)(a3 + 8) & 0xC000) != 0 )
    return memset(s, 0, 0x60u);
  v14[1] = *(float *)(a3 + 144);
  v27 = 0.0;
  v26 = 0.0;
  v25 = 0.0;
  v20 = 0.0;
  v19 = 0.0;
  v18 = 0.0;
  v15 = *(float *)(a5 + 1000);
  v16 = *(float *)(a5 + 1004);
  v17 = *(float *)(a5 + 1008);
  v26 = *(float *)(a5 + 896);
  v19 = *(float *)(a5 + 944);
  if ( (sub_188A4(a5, 3, 0) & 0x30000) == 0 )
  {
    v18 = *(float *)(a5 + 952);
    if ( (*(_DWORD *)(a3 + 8) & 0x40) != 0 )
    {
      AngleNormalize180(v18);
      v18 = a1;
      if ( v18 <= 0.0 )
        a1 = v18 * 0.25;
      else
        a1 = v18 * 0.5;
      v18 = a1;
    }
  }
  AnglesSubtract(&v15, &v18, &v15);
  AnglesSubtract(&v18, &v25, &v18);
  v22 = 0.0;
  v23 = 0.0;
  v24 = *(void **)(a3 + 228);
  GetLeanFraction(*(float *)(a5 + 996));
  v21 = a1;
  v20 = v21 * 50.0 * 0.92500001;
  v17 = v20;
  v7 = -v21 * 2.5 + v23;
  v23 = v7;
  if ( (*(_DWORD *)(a3 + 8) & 1) == 0 )
  {
    AngleSubtract(v26, *(float *)(a5 + 1004));
    v26 = v7;
  }
  if ( (*(_DWORD *)(a3 + 8) & 0x40) != 0 )
  {
    if ( v21 != 0.0 )
      v17 = v17 * 0.5;
    v25 = v25 + *(float *)(a3 + 232);
    v11 = v19 * 3.141592653589793 / 180.0;
    sub_1B464(v11, v14, &v13);
    v22 = (1.0 - v13) * -24.0 + v22;
    v23 = v14[0] * -12.0 + v23;
    if ( v21 * v14[0] > 0.0 )
      v23 = -v21 * (1.0 - v13) * 16.0 + v23;
    v28 = 0.0;
    v29 = v20 * -1.2;
    v30 = v20 * 0.30000001;
    v8 = 0.0;
    if ( *(float *)(a3 + 232) != 0.0 || (v8 = 0.0, *(float *)(a3 + 236) != 0.0) )
    {
      AngleSubtract(*(float *)(a3 + 232), *(float *)(a3 + 236));
      v28 = v8 + v28;
    }
    v31 = 0.0;
    v32 = v19 * 0.1 - v20 * 0.2;
    v33 = v20 * 0.2;
    v34 = v18;
    v35 = v19 * 0.80000001 - v20 * -1.0;
    v36 = v20 * -0.2;
  }
  else
  {
    if ( v21 != 0.0 )
    {
      if ( (*(_DWORD *)(a3 + 8) & 0x20) != 0 )
      {
        if ( v21 <= 0.0 )
        {
          v20 = v20 * 1.25;
          v17 = v17 * 1.25;
        }
        else
        {
          v20 = v20 * 1.5;
          v17 = v17 * 1.5;
        }
      }
      else if ( v21 <= 0.0 )
      {
        v20 = v20 * 1.25;
        v17 = v17 * 1.25;
      }
      else
      {
        v20 = v20 * 0.80000001;
        v17 = v17 * 0.80000001;
      }
    }
    v27 = v21 * 50.0 * 0.075000003 + v27;
    v28 = v18 * 0.2;
    v29 = v19 * 0.40000001;
    v30 = v20 * 0.5;
    v9 = 0.0;
    if ( *(float *)(a3 + 232) != 0.0 || (v9 = 0.0, *(float *)(a3 + 236) != 0.0) )
    {
      AngleSubtract(*(float *)(a3 + 232), *(float *)(a3 + 236));
      v28 = v9 + v28;
    }
    v31 = v18 * 0.30000001;
    v32 = v19 * 0.40000001;
    v33 = v20 * 0.5;
    v34 = v18 * 0.5;
    v35 = v19 * 0.2;
    v36 = v20 * -0.60000002;
  }
  v37 = v15 * 0.30000001;
  v38 = v16 * 0.30000001;
  v39 = 0;
  v40 = v15 * 0.69999999;
  v41 = v16 * 0.69999999;
  v42 = v17 * -0.30000001;
  v45 = 0;
  v44 = 0;
  v43 = 0.0;
  v10 = 0.0;
  if ( *(float *)(a3 + 236) != 0.0 || (v10 = 0.0, *(float *)(a3 + 232) != 0.0) )
  {
    AngleSubtract(*(float *)(a3 + 236), *(float *)(a3 + 232));
    v43 = v10;
  }
  for ( i = 0; i <= 5; ++i )
  {
    *((float *)s + 3 * i) = *(&v28 + 3 * i);
    *((float *)s + 3 * i + 1) = *(&v29 + 3 * i);
    *((float *)s + 3 * i + 2) = *(&v30 + 3 * i);
  }
  *((float *)s + 18) = v25;
  *((float *)s + 19) = v26;
  *((float *)s + 20) = v27;
  *((float *)s + 21) = v22;
  *((float *)s + 22) = v23;
  result = v24;
  *((_DWORD *)s + 23) = v24;
  return result;
}
// 14A50: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (0001AB82) --------------------------------------------------------
int *__cdecl sub_1AB82(int a1, float a2, int a3)
{
  int *result; // eax
  int i; // [esp+4h] [ebp-Ch] BYREF
  float v5; // [esp+8h] [ebp-8h]

  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a1 + 4 * i) - *(float *)(a3 + 4 * i);
    if ( v5 <= (long double)a2 )
    {
      if ( -a2 <= (long double)v5 )
        *(_DWORD *)(a3 + 4 * i) = *(_DWORD *)(a1 + 4 * i);
      else
        *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) - a2;
    }
    else
    {
      *(float *)(a3 + 4 * i) = *(float *)(a3 + 4 * i) + a2;
    }
    result = &i;
  }
  return result;
}

//----- (0001AC62) --------------------------------------------------------
void __cdecl BG_LerpOffset(int a1, float a2, int a3)
{
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  v5 = *(float *)a1 - *(float *)a3;
  v6 = *(float *)(a1 + 4) - *(float *)(a3 + 4);
  v7 = *(float *)(a1 + 8) - *(float *)(a3 + 8);
  v3 = v5 * v5 + v6 * v6 + v7 * v7;
  if ( v3 != 0.0 )
  {
    Q_rsqrt(v3);
    v4 = 0.0 * a2;
    if ( v4 >= 1.0 )
    {
      *(_DWORD *)a3 = *(_DWORD *)a1;
      *(_DWORD *)(a3 + 4) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a1 + 8);
    }
    else
    {
      *(float *)a3 = v5 * v4 + *(float *)a3;
      *(float *)(a3 + 4) = v6 * v4 + *(float *)(a3 + 4);
      *(float *)(a3 + 8) = v7 * v4 + *(float *)(a3 + 8);
    }
  }
}

//----- (0001AD71) --------------------------------------------------------
int __usercall BG_Player_DoControllers@<eax>(long double a1@<st0>, int a2, int a3, int a4, int a5)
{
  float v6; // [esp+4h] [ebp-94h]
  _DWORD s[18]; // [esp+20h] [ebp-78h] BYREF
  int v8; // [esp+68h] [ebp-30h] BYREF
  int v9; // [esp+74h] [ebp-24h] BYREF
  float v10; // [esp+88h] [ebp-10h]
  int i; // [esp+8Ch] [ebp-Ch]

  sub_1A389(a1, a2, a3, a4, a5, s);
  v10 = (long double)bg[2] * 0.36000001;
  for ( i = 0; i <= 5; ++i )
  {
    sub_1AB82((int)&s[3 * i], v10, a5 + 12 * i + 1020);
    G_DObjSetControlTagAngles(a2, a4, *(char **)((char *)off_80310 + (_DWORD)&dword_0[i]), a5 + 12 * i + 1020);
  }
  sub_1AB82((int)&v8, v10, a5 + 1092);
  v6 = (long double)bg[2] * 0.1;
  BG_LerpOffset((int)&v9, v6, a5 + 1104);
  return G_DObjSetLocalTag(a2, a4, "tag_origin", a5 + 1104, a5 + 1092);
}
// 0: using guessed type int dword_0[];
// 14E80: using guessed type _DWORD __cdecl G_DObjSetLocalTag(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15070: using guessed type _DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD);
// 80310: using guessed type char *off_80310[6];

//----- (0001AED5) --------------------------------------------------------
unsigned int __usercall BG_PlayerAnimation@<eax>(long double a1@<st0>, int a2, _DWORD *a3, int *a4)
{
  int v5; // [esp+14h] [ebp-4h]

  sub_19A3A(a1, (int)a3, (int)a4);
  sub_19FB4(a3, (int)a4);
  v5 = a4[298];
  sub_197B0(v5, a4 + 224);
  sub_197B0(v5, a4 + 236);
  if ( a4[253] && (a4[240] & 0xFFFFFDFF) == 0 )
  {
    a4[253] = 0;
    a4[254] = 1;
  }
  sub_193FB(a4, (unsigned int)(a4 + 224), a3[51], (int)a3);
  return sub_193FB(a4, (unsigned int)(a4 + 236), a3[52], (int)a3);
}

//----- (0001AFC9) --------------------------------------------------------
int __cdecl BG_UpdatePlayerDObj(int a1, int *a2, int a3)
{
  int result; // eax
  int v4; // [esp+18h] [ebp-A0h]
  int v5; // [esp+1Ch] [ebp-9Ch]
  _DWORD v6[2]; // [esp+20h] [ebp-98h] BYREF
  __int16 v7; // [esp+28h] [ebp-90h]
  _DWORD v8[30]; // [esp+2Ch] [ebp-8Ch]
  int v9; // [esp+A4h] [ebp-14h]
  int i; // [esp+A8h] [ebp-10h]
  int v11; // [esp+ACh] [ebp-Ch]

  v4 = trap_DObjExists(a1);
  v11 = a2[50];
  if ( (a2[2] & 0xC000) != 0 )
    v11 = 0;
  if ( !*(_DWORD *)a3 || !*(_BYTE *)(a3 + 64) )
    return trap_SafeDObjFree(*a2, 1);
  if ( v4 )
  {
    if ( *(_DWORD *)(a3 + 1196) == v11 )
    {
      result = a3;
      if ( !*(_DWORD *)(a3 + 1016) )
        return result;
    }
    trap_SafeDObjFree(*a2, 0);
  }
  v9 = *(_DWORD *)(a3 + 1192);
  v7 = sub_1A314();
  v6[0] = sub_1A31E(a3 + 64);
  v6[1] = 0;
  v8[0] = 0;
  v5 = 1;
  for ( i = 0; i <= 5; ++i )
  {
    if ( *(_BYTE *)(a3 + (i << 6) + 128) )
    {
      LOWORD(v6[4 * v5 + 2]) = sub_1A314();
      v6[4 * v5] = sub_1A31E(a3 + (i << 6) + 128);
      v6[4 * v5 + 1] = a3 + (i << 6) + 512;
      v8[4 * v5++] = ((int)*(unsigned __int8 *)(a1 + 378) >> i) & 1;
    }
  }
  sub_1A341((int)v6, v5, v9, *a2);
  *(_DWORD *)(a3 + 1196) = v11;
  result = a3;
  *(_DWORD *)(a3 + 1016) = 0;
  return result;
}
// 12F20: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);
// 13A30: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);

//----- (0001B247) --------------------------------------------------------
int BG_FindAnims()
{
  Scr_FindAnim("multiplayer", "root", (char *)&dword_9B6DC + (_DWORD)bgs);
  Scr_FindAnim("multiplayer", "torso", (char *)&dword_9B6E0 + (_DWORD)bgs);
  Scr_FindAnim("multiplayer", "legs", (char *)&dword_9B6E4 + (_DWORD)bgs);
  return Scr_FindAnim("multiplayer", "turning", (char *)&dword_9B6E8 + (_DWORD)bgs);
}
// 14590: using guessed type _DWORD __cdecl Scr_FindAnim(_DWORD, _DWORD, _DWORD);
// 9B6DC: using guessed type int dword_9B6DC;
// 9B6E0: using guessed type int dword_9B6E0;
// 9B6E4: using guessed type int dword_9B6E4;
// 9B6E8: using guessed type int dword_9B6E8;

//----- (0001B2FF) --------------------------------------------------------
_DWORD *__userpurge sub_1B2FF@<eax>(_DWORD *a1, char a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h] BYREF

  Scr_FindAnimTree(&v4);
  if ( !v4 && a3 )
    Com_Error(1, byte_73E00, a2);
  *a1 = v4;
  return a1;
}
// 14550: using guessed type _DWORD __stdcall Scr_FindAnimTree(_DWORD);

//----- (0001B361) --------------------------------------------------------
int BG_FindAnimTrees()
{
  int result; // eax

  sub_1B2FF((int *)((char *)&dword_9B6D8 + (_DWORD)bgs), (char)"multiplayer", 1);
  *(int *)((char *)&dword_9B6C0 + (_DWORD)bgs) = *(int *)((char *)&dword_9B6D8 + (_DWORD)bgs);
  *(int *)((char *)&dword_9B6C4 + (_DWORD)bgs) = *(int *)((char *)&dword_9B6E0 + (_DWORD)bgs);
  *(int *)((char *)&dword_9B6C8 + (_DWORD)bgs) = *(int *)((char *)&dword_9B6E4 + (_DWORD)bgs);
  result = *(int *)((char *)&dword_9B6E8 + (_DWORD)bgs);
  *(int *)((char *)&dword_9B6CC + (_DWORD)bgs) = result;
  return result;
}
// 9B6C0: using guessed type int dword_9B6C0;
// 9B6C4: using guessed type int dword_9B6C4;
// 9B6C8: using guessed type int dword_9B6C8;
// 9B6CC: using guessed type int dword_9B6CC;
// 9B6D8: using guessed type int dword_9B6D8;
// 9B6E0: using guessed type int dword_9B6E0;
// 9B6E4: using guessed type int dword_9B6E4;
// 9B6E8: using guessed type int dword_9B6E8;

//----- (0001B401) --------------------------------------------------------
int *BG_LoadAnimTreeInstances()
{
  int *result; // eax
  _DWORD *v1; // esi
  int *v2; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch] BYREF

  result = *(int **)((char *)&dword_9B6D8 + (_DWORD)bgs);
  v2 = result;
  for ( i = 0; i <= 63; ++i )
  {
    v1 = (_DWORD *)((char *)&unk_9BB94 + (_DWORD)&bgs[300 * i]);
    *v1 = trap_XAnimCreateTree(v2);
    result = &i;
  }
  return result;
}
// 13B80: using guessed type _DWORD __cdecl trap_XAnimCreateTree(_DWORD);
// 9B6D8: using guessed type int dword_9B6D8;

//----- (0001B464) --------------------------------------------------------
float *__cdecl sub_1B464(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (0001B47C) --------------------------------------------------------
void sub_1B47C()
{
  ;
}

//----- (0001B480) --------------------------------------------------------
char *__cdecl BG_FindItemForWeapon(int a1)
{
  if ( a1 < 0 || a1 > BG_GetNumWeapons() )
    Com_Error(1, byte_74DC0, a1);
  return (char *)&bg_itemlist + 48 * a1;
}
// 138A0: using guessed type int BG_GetNumWeapons(void);

//----- (0001B4DE) --------------------------------------------------------
char *__cdecl BG_FindItem(int a1)
{
  int v1; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 1; i < bg_numItems; ++i )
  {
    if ( i > BG_GetNumWeapons() )
    {
      v4 = (_DWORD *)((char *)&bg_itemlist + 48 * i);
      if ( !Q_stricmp(v4[6], a1) || !Q_stricmp(*v4, a1) )
        return (char *)&bg_itemlist + 48 * i;
    }
    else
    {
      v1 = BG_GetInfoForWeapon(i);
      if ( !Q_stricmp(a1, *(_DWORD *)(v1 + 4)) )
        return (char *)&bg_itemlist + 48 * i;
    }
  }
  return 0;
}
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0001B5BC) --------------------------------------------------------
_BOOL4 __cdecl BG_PlayerTouchesItem(float *a1, int a2, int a3)
{
  float v5; // [esp+20h] [ebp-18h] BYREF
  float v6; // [esp+24h] [ebp-14h]
  float v7; // [esp+28h] [ebp-10h]

  BG_EvaluateTrajectory(a2 + 12, a3, &v5);
  return a1[5] - v5 <= 36.0
      && a1[5] - v5 >= -36.0
      && a1[6] - v6 <= 36.0
      && a1[6] - v6 >= -36.0
      && a1[7] - v7 <= 18.0
      && a1[7] - v7 >= -88.0;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (0001B68F) --------------------------------------------------------
_BOOL4 __cdecl BG_CanItemBeGrabbed(int a1, _DWORD *a2, int a3)
{
  char v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+8h] [ebp-10h]
  char *v7; // [esp+10h] [ebp-8h]

  if ( *(int *)(a1 + 140) <= 0 || *(_DWORD *)(a1 + 140) >= bg_numItems )
    Com_Error(1, byte_74E00, v4);
  v7 = (char *)&bg_itemlist + 48 * *(_DWORD *)(a1 + 140);
  if ( *(_DWORD *)(a1 + 144) != a2[43] )
  {
    v5 = *((_DWORD *)v7 + 8);
    if ( v5 != 1 )
    {
      if ( v5 )
      {
        if ( v5 == 2 )
        {
          if ( Com_BitCheck(a2 + 195, *((_DWORD *)v7 + 9)) )
          {
            if ( (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
              return 0;
          }
          else if ( !BG_WeaponIsClipOnly(*((_DWORD *)v7 + 9))
                 || (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
          {
            return 0;
          }
          return 1;
        }
        if ( v5 == 3 )
          return a2[61] < a2[63];
      }
      else
      {
        Com_Error(1, byte_74E29, 0);
      }
      return 0;
    }
    if ( Com_BitCheck(a2 + 195, *((_DWORD *)v7 + 9)) )
    {
      if ( (int)BG_GetMaxPickupableAmmo(a2, *((_DWORD *)v7 + 9)) <= 0 )
        return 0;
    }
    else if ( a3 )
    {
      return 0;
    }
    return 1;
  }
  return 0;
}
// 1B6D3: variable 'v4' is possibly undefined
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 15640: using guessed type _DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD);

//----- (0001B877) --------------------------------------------------------
int __cdecl BG_EvaluateTrajectory(int a1, int a2, float *a3)
{
  int result; // eax
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+2Ch] [ebp-2Ch]
  float v6; // [esp+30h] [ebp-28h]
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+48h] [ebp-10h]
  int v11; // [esp+48h] [ebp-10h]
  float v12; // [esp+4Ch] [ebp-Ch]
  float v13; // [esp+4Ch] [ebp-Ch]
  float v14; // [esp+4Ch] [ebp-Ch]
  float v15; // [esp+4Ch] [ebp-Ch]
  float v16; // [esp+4Ch] [ebp-Ch]
  float v17; // [esp+4Ch] [ebp-Ch]
  float v18; // [esp+4Ch] [ebp-Ch]
  float v19; // [esp+4Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
    case 8:
      *a3 = *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 16);
      result = *(_DWORD *)(a1 + 20);
      *((_DWORD *)a3 + 2) = result;
      break;
    case 2:
      v12 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v12 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v12 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v12 + *(float *)(a1 + 20);
      break;
    case 3:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v14 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      if ( v14 < 0.0 )
        v14 = 0.0;
      *a3 = *(float *)(a1 + 24) * v14 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v14 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v14 + *(float *)(a1 + 20);
      break;
    case 4:
      v13 = (long double)(a2 - *(_DWORD *)(a1 + 4)) / (long double)*(int *)(a1 + 8);
      v9 = sin(v13 * 3.141592653589793 + v13 * 3.141592653589793);
      *a3 = *(float *)(a1 + 24) * v9 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v9 + *(float *)(a1 + 16);
      result = a1;
      a3[2] = *(float *)(a1 + 32) * v9 + *(float *)(a1 + 20);
      break;
    case 5:
      v15 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v15 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v15 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v15 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v15 * 400.0 * v15;
      break;
    case 6:
      v16 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v16 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v16 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v16 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v16 * 120.00001 * v16;
      break;
    case 7:
      v17 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      *a3 = *(float *)(a1 + 24) * v17 + *(float *)(a1 + 12);
      a3[1] = *(float *)(a1 + 28) * v17 + *(float *)(a1 + 16);
      a3[2] = *(float *)(a1 + 32) * v17 + *(float *)(a1 + 20);
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v17 * 80.0;
      break;
    case 9:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v18 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v4 = sqrt(
             *(float *)(a1 + 24) * *(float *)(a1 + 24)
           + *(float *)(a1 + 28) * *(float *)(a1 + 28)
           + *(float *)(a1 + 32) * *(float *)(a1 + 32));
      v10 = v4 / ((long double)*(int *)(a1 + 8) * 0.001);
      VectorNormalize2(a1 + 24, a3);
      *a3 = v10 * 0.5 * v18 * v18 * *a3 + *(float *)(a1 + 12);
      a3[1] = v10 * 0.5 * v18 * v18 * a3[1] + *(float *)(a1 + 16);
      result = (int)(a3 + 2);
      a3[2] = v10 * 0.5 * v18 * v18 * a3[2] + *(float *)(a1 + 20);
      break;
    case 0xA:
      if ( a2 > *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8) )
        a2 = *(_DWORD *)(a1 + 4) + *(_DWORD *)(a1 + 8);
      v19 = (long double)(a2 - *(_DWORD *)(a1 + 4)) * 0.001;
      v5 = sqrt(
             *(float *)(a1 + 24) * *(float *)(a1 + 24)
           + *(float *)(a1 + 28) * *(float *)(a1 + 28)
           + *(float *)(a1 + 32) * *(float *)(a1 + 32));
      *(float *)&v11 = v5 / ((long double)*(int *)(a1 + 8) * 0.001);
      VectorNormalize2(a1 + 24, a3);
      v6 = *(float *)(a1 + 24) * v19 + *(float *)(a1 + 12);
      v7 = *(float *)(a1 + 28) * v19 + *(float *)(a1 + 16);
      v8 = *(float *)(a1 + 32) * v19 + *(float *)(a1 + 20);
      *a3 = -*(float *)&v11 * 0.5 * v19 * v19 * *a3 + v6;
      a3[1] = -*(float *)&v11 * 0.5 * v19 * v19 * a3[1] + v7;
      result = v11;
      a3[2] = -*(float *)&v11 * 0.5 * v19 * v19 * a3[2] + v8;
      break;
    default:
      result = Com_Error(1, byte_74E60, *(_DWORD *)(a1 + 4));
      break;
  }
  return result;
}
// 14C80: using guessed type _DWORD __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (0001BEA8) --------------------------------------------------------
int __cdecl BG_EvaluateTrajectoryDelta(float *a1, int a2, float *a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+18h] [ebp-10h]
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+1Ch] [ebp-Ch]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+1Ch] [ebp-Ch]
  float v10; // [esp+1Ch] [ebp-Ch]
  float v11; // [esp+1Ch] [ebp-Ch]

  switch ( *(_DWORD *)a1 )
  {
    case 0:
    case 1:
      result = 0;
      a3[2] = 0.0;
      a3[1] = 0.0;
      *a3 = 0.0;
      break;
    case 2:
      *a3 = a1[6];
      a3[1] = a1[7];
      result = *((_DWORD *)a1 + 8);
      *((_DWORD *)a3 + 2) = result;
      break;
    case 3:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        *a3 = a1[6];
        a3[1] = a1[7];
        result = *((_DWORD *)a1 + 8);
        *((_DWORD *)a3 + 2) = result;
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    case 4:
      v6 = (long double)(a2 - *((_DWORD *)a1 + 1)) / (long double)*((int *)a1 + 2);
      v4 = cos(v6 * 3.141592653589793 + v6 * 3.141592653589793);
      v5 = v4 * 0.5;
      *a3 = a1[6] * v5;
      a3[1] = a1[7] * v5;
      result = (int)a1;
      a3[2] = a1[8] * v5;
      break;
    case 5:
      v7 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v7 * 800.0;
      break;
    case 6:
      v8 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v8 * 240.00002;
      break;
    case 7:
      v9 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
      *a3 = a1[6];
      a3[1] = a1[7];
      a3[2] = a1[8];
      result = (int)(a3 + 2);
      a3[2] = a3[2] - v9 * 160.0;
      break;
    case 9:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        v10 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
        *a3 = v10 * v10 * a1[6];
        a3[1] = v10 * v10 * a1[7];
        result = (int)a1;
        a3[2] = v10 * v10 * a1[8];
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    case 0xA:
      if ( a2 <= *((_DWORD *)a1 + 1) + *((_DWORD *)a1 + 2) )
      {
        v11 = (long double)(a2 - *((_DWORD *)a1 + 1)) * 0.001;
        *a3 = a1[6] * v11;
        a3[1] = a1[7] * v11;
        result = (int)a1;
        a3[2] = a1[8] * v11;
      }
      else
      {
        result = 0;
        a3[2] = 0.0;
        a3[1] = 0.0;
        *a3 = 0.0;
      }
      break;
    default:
      result = Com_Error(1, byte_74EE0, *((_DWORD *)a1 + 1));
      break;
  }
  return result;
}

//----- (0001C27D) --------------------------------------------------------
int __cdecl BG_GetMarkDir(_DWORD *a1, float *a2, float *a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  v5 = 0.30000001;
  v4 = sqrt(*a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2]);
  if ( v4 >= 1.0 )
  {
    v6 = *a2;
    v7 = a2[1];
    v8 = a2[2];
  }
  else
  {
    v6 = 0.0;
    v7 = 0.0;
    v8 = 1.0;
  }
  LODWORD(v9) = *a1 ^ 0x80000000;
  LODWORD(v10) = a1[1] ^ 0x80000000;
  LODWORD(v11) = a1[2] ^ 0x80000000;
  VectorNormalize(&v9);
  if ( a2[2] > 0.80000001 )
    v5 = 0.69999999;
  while ( v5 > v9 * v6 + v10 * v7 + v11 * v8 )
  {
    v9 = v6 * 0.5 + v9;
    v10 = v7 * 0.5 + v10;
    v11 = v8 * 0.5 + v11;
    VectorNormalize(&v9);
  }
  *a3 = v9;
  a3[1] = v10;
  result = LODWORD(v11);
  a3[2] = v11;
  return result;
}
// 139D0: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);

//----- (0001C3FF) --------------------------------------------------------
int __cdecl BG_AddPredictableEventToPlayerstate(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax

  if ( a1 )
  {
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 132) & 3) + 136) = (unsigned __int8)a1;
    *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 132) & 3) + 152) = a2;
    result = a3;
    ++*(_DWORD *)(a3 + 132);
  }
  return result;
}

//----- (0001C449) --------------------------------------------------------
int __cdecl BG_PlayerStateToEntityState(int a1, int a2, int a3)
{
  long double v3; // fst7
  unsigned int v4; // edx
  unsigned int v5; // edx
  long double v6; // fst7
  long double v7; // fst7
  int result; // eax
  unsigned __int8 v9; // [esp+23h] [ebp-15h]
  int j; // [esp+24h] [ebp-14h]
  float v11; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  if ( (*(_DWORD *)(a1 + 12) & 0x30000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  *(_DWORD *)(a2 + 12) = 1;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 28);
  if ( a3 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 48) = 1;
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 200);
  if ( a3 )
  {
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  if ( *(int *)(a1 + 124) <= 128 )
    v3 = (long double)*(int *)(a1 + 124);
  else
    v3 = (long double)*(int *)(a1 + 124) - 256.0;
  *(float *)(a2 + 108) = v3;
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 172);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 128);
  if ( (*(_WORD *)(a1 + 128) & 0xC000) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 888);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFFFFFE;
  else
    v4 = *(_DWORD *)(a2 + 8) | 1;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x200;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFFFDFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 64);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    if ( *(_DWORD *)(a1 + 212) )
    {
      v11 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 212))
          / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
      if ( v11 >= 0.0 )
      {
        if ( v11 > 1.0 )
          v11 = 1.0;
      }
      else
      {
        v11 = 0.0;
      }
      if ( !*(_DWORD *)(a1 + 220) )
        v11 = 1.0 - v11;
    }
    else
    {
      v11 = 1.0;
    }
    v6 = *(float *)(a1 + 964) * v11;
    *(float *)(a2 + 228) = v6;
    AngleNormalize180(*(float *)(a1 + 968));
    v7 = v6 * v11;
    *(float *)(a2 + 232) = v7;
    AngleNormalize180(*(float *)(a1 + 972));
    *(float *)(a2 + 236) = v7 * v11;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    *(_DWORD *)(a2 + 236) = 0;
  }
  if ( *(_DWORD *)(a1 + 976) - *(_DWORD *)(a1 + 132) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 132) - *(_DWORD *)(a1 + 976) > 4 )
      *(_DWORD *)(a1 + 976) = *(_DWORD *)(a1 + 132) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 976))++ & 3) + 152);
  }
  for ( i = *(_DWORD *)(a1 + 168); i != *(_DWORD *)(a1 + 132); ++i )
  {
    v9 = *(_BYTE *)(a1 + 4 * (i & 3) + 136);
    G_PlayerEvent(*(_DWORD *)a2, v9);
    for ( j = 0; *((int *)pEventSingleClientList + j) > 0 && *((_DWORD *)pEventSingleClientList + j) != v9; ++j )
      ;
    if ( *((int *)pEventSingleClientList + j) < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v9;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 152);
    }
  }
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 176);
  result = *(unsigned __int16 *)(a1 + 84);
  *(_DWORD *)(a2 + 124) = result;
  return result;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 14C90: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 159F0: using guessed type _DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD);
// 8070C: using guessed type void *pEventSingleClientList;

//----- (0001C9C5) --------------------------------------------------------
int __cdecl BG_PlayerStateToEntityStateExtrapolate(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // edx
  unsigned int v5; // edx
  long double v6; // fst7
  long double v7; // fst7
  int result; // eax
  float v9; // [esp+20h] [ebp-18h]
  unsigned __int8 v10; // [esp+27h] [ebp-11h]
  int j; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  *(_DWORD *)(a2 + 12) = 3;
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 16) = a3;
  *(_DWORD *)(a2 + 20) = 50;
  *(_DWORD *)(a2 + 48) = 1;
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a2 + 68) = *(_DWORD *)(a1 + 200);
  *(float *)(a2 + 108) = (float)*(int *)(a1 + 124);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 128);
  if ( *(_DWORD *)(a1 + 976) - *(_DWORD *)(a1 + 132) >= 0 )
  {
    *(_DWORD *)(a2 + 160) = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 132) - *(_DWORD *)(a1 + 976) > 4 )
      *(_DWORD *)(a1 + 976) = *(_DWORD *)(a1 + 132) - 4;
    *(_DWORD *)(a2 + 160) = *(unsigned __int8 *)(a1 + 4 * ((*(_DWORD *)(a1 + 976))++ & 3) + 152);
  }
  if ( *(_DWORD *)(a1 + 168) - *(_DWORD *)(a1 + 132) > 0 )
    *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 132);
  for ( i = *(_DWORD *)(a1 + 168); i != *(_DWORD *)(a1 + 132); ++i )
  {
    v10 = *(_BYTE *)(a1 + 4 * (i & 3) + 136);
    G_PlayerEvent(*(_DWORD *)a2, v10);
    for ( j = 0; *((int *)pEventSingleClientList + j) > 0 && *((_DWORD *)pEventSingleClientList + j) != v10; ++j )
      ;
    if ( *((int *)pEventSingleClientList + j) < 0 )
    {
      *(_DWORD *)(a2 + 4 * (*(_DWORD *)(a2 + 164) & 3) + 168) = v10;
      *(_DWORD *)(a2 + 4 * ((*(_DWORD *)(a2 + 164))++ & 3) + 184) = *(unsigned __int8 *)(a1 + 4 * (i & 3) + 152);
    }
  }
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a1 + 132);
  *(_DWORD *)(a2 + 200) = *(unsigned __int8 *)(a1 + 176);
  *(_DWORD *)(a2 + 124) = *(unsigned __int16 *)(a1 + 84);
  if ( (*(_DWORD *)(a1 + 12) & 0x30000) != 0 )
    *(_DWORD *)(a2 + 4) = 1;
  else
    *(_DWORD *)(a2 + 4) = 7;
  if ( a4 )
  {
    *(float *)(a2 + 24) = (float)(int)*(float *)(a2 + 24);
    *(float *)(a2 + 28) = (float)(int)*(float *)(a2 + 28);
    *(float *)(a2 + 32) = (float)(int)*(float *)(a2 + 32);
    *(float *)(a2 + 60) = (float)(int)*(float *)(a2 + 60);
    *(float *)(a2 + 64) = (float)(int)*(float *)(a2 + 64);
    *(float *)(a2 + 68) = (float)(int)*(float *)(a2 + 68);
  }
  *(_DWORD *)(a2 + 204) = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a2 + 208) = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a1 + 172);
  if ( (*(_WORD *)(a1 + 128) & 0xC000) != 0 )
    *(_DWORD *)(a2 + 116) = *(_DWORD *)(a1 + 888);
  if ( *(int *)(a1 + 4) <= 5 )
    v4 = *(_DWORD *)(a2 + 8) & 0xFFFFFFFE;
  else
    v4 = *(_DWORD *)(a2 + 8) | 1;
  *(_DWORD *)(a2 + 8) = v4;
  if ( (*(_DWORD *)(a1 + 12) & 0x20) != 0 )
    v5 = *(_DWORD *)(a2 + 8) | 0x200;
  else
    v5 = *(_DWORD *)(a2 + 8) & 0xFFFFFDFF;
  *(_DWORD *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 212) = *(_DWORD *)(a1 + 64);
  if ( PM_GetEffectiveStance(a1) == 1 )
  {
    v9 = (long double)(*(_DWORD *)a1 - *(_DWORD *)(a1 + 212))
       / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
    if ( v9 >= 0.0 )
    {
      if ( v9 > 1.0 )
        v9 = 1.0;
    }
    else
    {
      v9 = 0.0;
    }
    if ( !*(_DWORD *)(a1 + 220) )
      v9 = 1.0 - v9;
    v6 = *(float *)(a1 + 964) * v9;
    *(float *)(a2 + 228) = v6;
    AngleNormalize180(*(float *)(a1 + 968));
    v7 = v6 * v9;
    *(float *)(a2 + 232) = v7;
    result = AngleNormalize180(*(float *)(a1 + 972));
    *(float *)(a2 + 236) = v7 * v9;
  }
  else
  {
    *(_DWORD *)(a2 + 228) = 0;
    *(_DWORD *)(a2 + 232) = 0;
    result = a2;
    *(_DWORD *)(a2 + 236) = 0;
  }
  return result;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 14C90: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 159F0: using guessed type _DWORD __cdecl G_PlayerEvent(_DWORD, _DWORD);
// 8070C: using guessed type void *pEventSingleClientList;

//----- (0001CF58) --------------------------------------------------------
int __cdecl BG_CheckProneValid(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, float a15)
{
  long double v15; // fst7
  long double v16; // fst7
  float v18; // [esp+0h] [ebp-148h]
  float v19; // [esp+0h] [ebp-148h]
  float v21; // [esp+30h] [ebp-118h]
  int v22; // [esp+34h] [ebp-114h]
  float v23; // [esp+38h] [ebp-110h]
  float v24; // [esp+40h] [ebp-108h]
  float v25; // [esp+44h] [ebp-104h]
  float v26; // [esp+48h] [ebp-100h]
  float v27; // [esp+4Ch] [ebp-FCh]
  int v28; // [esp+50h] [ebp-F8h] BYREF
  int v29; // [esp+54h] [ebp-F4h]
  float v30; // [esp+58h] [ebp-F0h]
  int v31; // [esp+60h] [ebp-E8h] BYREF
  int v32; // [esp+64h] [ebp-E4h]
  float v33; // [esp+68h] [ebp-E0h]
  int v34; // [esp+70h] [ebp-D8h] BYREF
  int v35; // [esp+74h] [ebp-D4h]
  float v36; // [esp+78h] [ebp-D0h]
  int v37[4]; // [esp+80h] [ebp-C8h] BYREF
  int v38[4]; // [esp+90h] [ebp-B8h] BYREF
  float v39; // [esp+A0h] [ebp-A8h] BYREF
  float v40; // [esp+A4h] [ebp-A4h]
  float v41; // [esp+A8h] [ebp-A0h]
  float v42; // [esp+B0h] [ebp-98h] BYREF
  float v43; // [esp+B4h] [ebp-94h]
  float v44; // [esp+B8h] [ebp-90h]
  float v45; // [esp+C0h] [ebp-88h] BYREF
  float v46; // [esp+C4h] [ebp-84h]
  float v47; // [esp+C8h] [ebp-80h]
  float v48; // [esp+D0h] [ebp-78h] BYREF
  float v49; // [esp+D4h] [ebp-74h]
  float v50; // [esp+D8h] [ebp-70h]
  float v51; // [esp+E0h] [ebp-68h] BYREF
  int v52; // [esp+E4h] [ebp-64h]
  float v53; // [esp+E8h] [ebp-60h]
  int v54; // [esp+F0h] [ebp-58h] BYREF
  int v55; // [esp+F4h] [ebp-54h]
  float v56; // [esp+F8h] [ebp-50h]
  float v57; // [esp+100h] [ebp-48h] BYREF
  int v58; // [esp+104h] [ebp-44h] BYREF
  int v59; // [esp+108h] [ebp-40h]
  float v60; // [esp+10Ch] [ebp-3Ch]
  float v61; // [esp+118h] [ebp-30h]
  char v62; // [esp+12Eh] [ebp-1Ah]
  int v63; // [esp+13Ch] [ebp-Ch]

  v22 = 0;
  LODWORD(v48) = a3 ^ 0x80000000;
  LODWORD(v49) = a3 ^ 0x80000000;
  v50 = 0.0;
  v48 = COERCE_FLOAT(a3 ^ 0x80000000) + *(float *)a2;
  v49 = COERCE_FLOAT(a3 ^ 0x80000000) + *(float *)(a2 + 4);
  v50 = *(float *)(a2 + 8) + 0.0;
  v45 = *(float *)&a3;
  v46 = *(float *)&a3;
  v47 = *(float *)&a4;
  v45 = *(float *)&a3 + *(float *)a2;
  v46 = *(float *)&a3 + *(float *)(a2 + 4);
  v47 = *(float *)&a4 + *(float *)(a2 + 8);
  if ( g_debugProneCheck[3] )
    G_DebugBox(&v48, &v45, &colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( a14 )
    v63 = 8519697;
  else
    v63 = 8454161;
  if ( !a9 )
  {
    LODWORD(v48) = a3 ^ 0x80000000;
    LODWORD(v49) = a3 ^ 0x80000000;
    v50 = 0.0;
    v45 = *(float *)&a3;
    v46 = *(float *)&a3;
    v47 = *(float *)&a4;
    v54 = *(int *)a2;
    v55 = *(int *)(a2 + 4);
    v56 = *(float *)(a2 + 8);
    v51 = *(float *)a2;
    v52 = *(int *)(a2 + 4);
    v53 = *(float *)(a2 + 8);
    v53 = v53 + 10.0;
    ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a13)(&v57, &v54, &v48, &v45, &v51, a1, v63);
    if ( v62 )
      return 0;
  }
  if ( a10 && a11 && *(float *)(a11 + 8) < 0.69999999 )
    return 0;
  v48 = -6.0;
  v49 = -6.0;
  v50 = -6.0;
  v45 = 6.0;
  v46 = 6.0;
  v47 = 6.0;
  v51 = 0.0;
  *(float *)&v52 = a5 - 180.0;
  v53 = 0.0;
  AngleVectors(&v51, &v39, v38, v37);
  v24 = *(float *)&a4 - 6.0;
  v54 = *(int *)a2;
  v55 = *(int *)(a2 + 4);
  v56 = *(float *)(a2 + 8);
  v56 = v56 + v24;
  v51 = (a15 - 6.0) * v39 + *(float *)&v54;
  *(float *)&v52 = (a15 - 6.0) * v40 + *(float *)&v55;
  v53 = (a15 - 6.0) * v41 + v56;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v54, 6.0, (int)v38, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v54, 6.0, (int)v37, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( v57 >= 1.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
    v23 = a15;
  }
  else
  {
    if ( !a10 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      return 0;
    }
    v22 = 1;
    v23 = (a15 - 6.0) * v57 + 6.0;
    if ( *(float *)&a3 + 2.0 > v23 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      return 0;
    }
    if ( v24 * 0.69999999 + 24.0 <= v23 )
    {
      if ( g_debugProneCheck[3] )
      {
LABEL_35:
        G_DebugLine(&v54, &v58, &colorYellow, g_debugProneCheckDepthCheck[3], 1);
        goto LABEL_44;
      }
    }
    else
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      v22 = 0;
      v53 = v53 + 22.0;
      v42 = v51 - *(float *)&v54;
      v43 = *(float *)&v52 - *(float *)&v55;
      v44 = v53 - v56;
      v25 = VectorNormalize2(&v42, &v39);
      ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(
        &v57,
        &v54,
        &v48,
        &v45,
        &v51,
        a1,
        v63);
      if ( v57 >= 1.0 )
      {
        if ( g_debugProneCheck[3] )
          G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
        v23 = a15;
      }
      else
      {
        v22 = 1;
        v23 = v57 * v25 + 6.0;
        if ( v24 * 0.69999999 + 24.0 > v23 )
        {
          if ( g_debugProneCheck[3] )
            G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
          return 0;
        }
        if ( g_debugProneCheck[3] )
          goto LABEL_35;
      }
    }
  }
LABEL_44:
  v28 = v58;
  v29 = v59;
  v30 = v60;
  *(float *)&v54 = v39 * 24.0 + *(float *)a2;
  *(float *)&v55 = v40 * 24.0 + *(float *)(a2 + 4);
  v56 = v41 * 24.0 + *(float *)(a2 + 8);
  v56 = v56 + v24;
  v51 = *(float *)&v54;
  v52 = v55;
  v53 = v56 - (*(float *)&a3 * 2.5 + v24 - 6.0);
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( v57 == 1.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_119;
  }
  if ( v61 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v31 = v58;
  v32 = v59;
  v33 = v60;
  if ( v22 )
  {
    v21 = (*(float *)&a3 * 2.5 + v24 - 6.0) * v57 + 6.0;
    if ( v21 * -0.75 > v23 - v21 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v28, &v31, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      goto LABEL_119;
    }
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v28, &v31, &colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
    v42 = *(float *)&v28 - *(float *)&v31;
    v43 = *(float *)&v29 - *(float *)&v32;
    v44 = v30 - v33;
    v42 = v39 * 6.0 + v42;
    v43 = v40 * 6.0 + v43;
    v44 = v41 * 6.0 + v44;
    v44 = v44 + 6.0;
    VectorNormalize(&v42);
    v51 = (a15 - 6.0 - 24.0) * v42 + *(float *)&v54;
    *(float *)&v52 = (a15 - 6.0 - 24.0) * v43 + *(float *)&v55;
    v53 = (a15 - 6.0 - 24.0) * v44 + v56;
    v51 = ((a15 - 6.0) * v39 + *(float *)a2 + v51) * 0.5;
    *(float *)&v52 = ((a15 - 6.0) * v40 + *(float *)(a2 + 4) + *(float *)&v52) * 0.5;
    ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
    if ( v57 < 1.0 )
    {
      if ( g_debugProneCheck[3] )
        G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
      v54 = v58;
      v55 = v59;
      v56 = v60 + 18.0;
      v53 = v53 + 18.0;
      ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(
        &v57,
        &v54,
        &v48,
        &v45,
        &v51,
        a1,
        v63);
      if ( v57 < 1.0 )
      {
        if ( !g_debugProneCheck[3] )
          goto LABEL_119;
LABEL_75:
        G_DebugLine(&v54, &v58, &colorRed, g_debugProneCheckDepthCheck[3], 1);
        goto LABEL_119;
      }
    }
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
    v28 = v58;
    v29 = v59;
    v30 = v60;
  }
  v54 = v28;
  v55 = v29;
  v56 = v30;
  v51 = *(float *)&v28;
  v52 = v29;
  v53 = v30 - (v30 - v33 + v30 - v33 + *(float *)&a3);
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( v57 == 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_119;
    goto LABEL_75;
  }
  if ( v61 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v28 = v58;
  v29 = v59;
  v30 = v60;
  v54 = *(int *)a2;
  v55 = *(int *)(a2 + 4);
  v56 = *(float *)(a2 + 8);
  v56 = v56 + v24;
  v51 = *(float *)a2;
  v52 = *(int *)(a2 + 4);
  v53 = *(float *)(a2 + 8);
  v53 = v53 - *(float *)&a3 * 1.5;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( v57 == 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_119;
    goto LABEL_75;
  }
  if ( v61 < 0.69999999 )
    return 0;
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v54, &v58, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  v34 = v58;
  v35 = v59;
  v36 = v60;
  v42 = *(float *)&v31 - *(float *)&v58;
  v43 = *(float *)&v32 - *(float *)&v59;
  v44 = v33 - v60;
  v27 = vectopitch(&v42);
  v42 = *(float *)&v28 - *(float *)&v31;
  v43 = *(float *)&v29 - *(float *)&v32;
  v44 = v30 - v33;
  v26 = vectopitch(&v42);
  AngleSubtract(v26, v27);
  if ( v26 < -50.0 || v26 > 70.0 )
  {
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v34, &v31, &colorMagenta, g_debugProneCheckDepthCheck[3], 1);
    if ( g_debugProneCheck[3] )
      G_DebugLine(&v31, &v28, &colorMagenta, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_119;
  }
  v48 = -0.0;
  v49 = -0.0;
  v50 = -0.0;
  v45 = 0.0;
  v46 = 0.0;
  v47 = 0.0;
  v54 = v34;
  v55 = v35;
  v56 = v36 + 5.0;
  v51 = *(float *)&v31;
  v52 = v32;
  v53 = v33 + 5.0;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( v57 < 1.0 )
  {
    if ( !g_debugProneCheck[3] )
      goto LABEL_119;
    goto LABEL_88;
  }
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v54, &v51, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  *(float *)&v54 = v51;
  v55 = v52;
  v56 = v53;
  v51 = *(float *)&v28;
  v52 = v29;
  v53 = v30 + 5.0;
  ((void (__cdecl *)(float *, int *, float *, float *, float *, int, int))a12)(&v57, &v54, &v48, &v45, &v51, a1, v63);
  if ( v57 < 1.0 )
  {
    if ( !g_debugProneCheck[3] )
    {
LABEL_119:
      if ( a10 )
        return 0;
      if ( a6 )
        *(_DWORD *)a6 = 0;
      if ( a7 )
        *(_DWORD *)a7 = 0;
      if ( a8 )
        *(_DWORD *)a8 = 0;
      return 1;
    }
LABEL_88:
    G_DebugLine(&v54, &v51, &colorRed, g_debugProneCheckDepthCheck[3], 1);
    goto LABEL_119;
  }
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v54, &v51, &colorGreen, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v34, 6.0, (int)v38, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v34, 6.0, (int)v37, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v31, 6.0, (int)v38, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v31, 6.0, (int)v37, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v28, 6.0, (int)v38, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugCircleEx((int)&v28, 6.0, (int)v37, (int)&colorMdCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v34, &v31, &colorCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( g_debugProneCheck[3] )
    G_DebugLine(&v31, &v28, &colorCyan, g_debugProneCheckDepthCheck[3], 1);
  if ( a6 )
    *(float *)a6 = v36 - *(float *)(a2 + 8) - 6.0;
  if ( a7 )
  {
    v42 = *(float *)&v34 - *(float *)&v31;
    v43 = *(float *)&v35 - *(float *)&v32;
    v44 = v36 - v33;
    v15 = vectopitch(&v42);
    v18 = v15;
    AngleNormalize180(v18);
    *(float *)a7 = v15;
  }
  if ( a8 )
  {
    v42 = *(float *)&v31 - *(float *)&v28;
    v43 = *(float *)&v32 - *(float *)&v29;
    v44 = v33 - v30;
    v16 = vectopitch(&v42);
    v19 = v16;
    AngleNormalize180(v19);
    *(float *)a8 = v16;
  }
  return 1;
}
// 13180: using guessed type long double __cdecl vectopitch(_DWORD);
// 139D0: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14C20: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 15300: using guessed type _DWORD __cdecl G_DebugBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001E6AD) --------------------------------------------------------
int __cdecl BG_CheckProne(int a1, int a2, int a3, int a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, float a15)
{
  return BG_CheckProneValid(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

//----- (0001E732) --------------------------------------------------------
void sub_1E732()
{
  ;
}

//----- (0001E738) --------------------------------------------------------
int __cdecl PM_trace(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax

  (*(void (__cdecl **)(int, int, int, int, int, int, int))(pm + 236))(a1, a2, a3, a4, a5, a6, a7);
  result = a1;
  if ( *(_BYTE *)(a1 + 47) )
  {
    result = *(_DWORD *)(a1 + 32) & 0x2000000;
    if ( result )
    {
      PM_AddTouchEnt(*(unsigned __int16 *)(a1 + 40));
      *(_DWORD *)(pm + 52) &= 0xFDFFFFFF;
      result = (*(int (__cdecl **)(int, int, int, int, int, int, unsigned int))(pm + 236))(
                 a1,
                 a2,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7 & 0xFDFFFFFF);
    }
  }
  return result;
}
// 14AB0: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);

//----- (0001E81E) --------------------------------------------------------
int __cdecl PM_AddEvent(int a1)
{
  return BG_AddPredictableEventToPlayerstate(a1, 0, *pm);
}
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (0001E857) --------------------------------------------------------
int __cdecl PM_AddTouchEnt(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-8h]

  if ( a1 != 1022 )
  {
    result = pm;
    if ( *(_DWORD *)(pm + 60) != 32 )
    {
      for ( i = 0; i < *(_DWORD *)(pm + 60); ++i )
      {
        result = *(_DWORD *)(pm + 4 * i + 64);
        if ( result == a1 )
          return result;
      }
      *(_DWORD *)(pm + 4 * *(_DWORD *)(pm + 60) + 64) = a1;
      result = pm;
      ++*(_DWORD *)(pm + 60);
    }
  }
  return result;
}

//----- (0001E8E5) --------------------------------------------------------
void __cdecl PM_ClipVelocity(int a1, int a2, int a3, float a4)
{
  int i; // [esp+0h] [ebp-14h]
  float v5; // [esp+4h] [ebp-10h]
  float v6; // [esp+8h] [ebp-Ch]
  float v7; // [esp+8h] [ebp-Ch]

  v6 = *(float *)a1 * *(float *)a2 + *(float *)(a1 + 4) * *(float *)(a2 + 4) + *(float *)(a1 + 8) * *(float *)(a2 + 8);
  if ( v6 >= 0.0 )
    v7 = v6 / a4;
  else
    v7 = v6 * a4;
  for ( i = 0; i <= 2; ++i )
  {
    v5 = *(float *)(a2 + 4 * i) * v7;
    *(float *)(a3 + 4 * i) = *(float *)(a1 + 4 * i) - v5;
  }
}

//----- (0001E9A5) --------------------------------------------------------
int __cdecl PM_GetEffectiveStance(_DWORD *a1)
{
  int v2; // [esp+0h] [ebp-4h]

  if ( a1[51] == a1[208] )
    v2 = 2;
  else
    v2 = a1[51] == a1[207];
  return v2;
}

//----- (0001E9F1) --------------------------------------------------------
long double sub_1E9F1()
{
  float v1; // [esp+0h] [ebp-8h]

  if ( *(int *)(*pm + 16) <= 1699 )
    v1 = (long double)*(int *)(*pm + 16) * 1.5 * 0.00058823527 + 1.0;
  else
    v1 = 2.5;
  return v1;
}

//----- (0001EA52) --------------------------------------------------------
long double sub_1EA52()
{
  float v1; // [esp+0h] [ebp-8h]

  if ( *(int *)(*pm + 16) <= 1699 )
    v1 = (long double)*(int *)(*pm + 16) * 1.5 * 0.00058823527 + 1.0;
  else
    v1 = 2.5;
  return v1;
}

//----- (0001EAB3) --------------------------------------------------------
float *sub_1EAB3()
{
  float *result; // eax
  float v1; // [esp+14h] [ebp-34h]
  float v2; // [esp+1Ch] [ebp-2Ch]
  float v3; // [esp+20h] [ebp-28h]
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+24h] [ebp-24h]
  float v6; // [esp+28h] [ebp-20h]
  float *v7; // [esp+2Ch] [ebp-1Ch]
  float v8; // [esp+38h] [ebp-10h]

  v7 = (float *)(*pm + 32);
  v8 = *(float *)(*pm + 40);
  if ( pml[11] )
    v8 = 0.0;
  v6 = sqrt(*v7 * *v7 + *(float *)(*pm + 36) * *(float *)(*pm + 36) + v8 * v8);
  if ( v6 >= 1.0 )
  {
    v2 = 0.0;
    if ( *(_BYTE *)(pm + 217) <= 1u && pml[11] && (pml[21] & 2) == 0 && (*(_DWORD *)(*pm + 12) & 0x200) == 0 )
    {
      if ( v6 >= 100.0 )
        v1 = v6;
      else
        v1 = 100.0;
      v3 = v1;
      if ( (*(_DWORD *)(*pm + 12) & 0x100) != 0 )
      {
        v3 = v1 * 0.30000001;
      }
      else if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 )
      {
        if ( *(int *)(*pm + 16) > 1800 )
        {
          *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
          *(_DWORD *)(*pm + 104) = 0;
        }
        else
        {
          v3 = sub_1E9F1() * v1;
        }
      }
      v2 = v3 * 5.5 * *(float *)&pml[9] + 0.0;
    }
    if ( *(_BYTE *)(pm + 217) )
      v2 = v6 * 1.0 * (long double)*(unsigned __int8 *)(pm + 217) * *(float *)&pml[9] + v2;
    if ( *(_DWORD *)(*pm + 4) == 4 )
      v2 = v6 * 5.0 * *(float *)&pml[9] + v2;
    v4 = v6 - v2;
    if ( v4 < 0.0 )
      v4 = 0.0;
    v5 = v4 / v6;
    *v7 = *v7 * v5;
    v7[1] = v7[1] * v5;
    result = v7 + 2;
    v7[2] = v7[2] * v5;
  }
  else
  {
    result = 0;
    v7[2] = 0.0;
    v7[1] = 0.0;
    *v7 = 0.0;
  }
  return result;
}

//----- (0001ED62) --------------------------------------------------------
void __cdecl sub_1ED62(int a1, float a2, float a3)
{
  float v3; // [esp+0h] [ebp-24h]
  float v4; // [esp+8h] [ebp-1Ch]
  float v5; // [esp+Ch] [ebp-18h]
  float v6; // [esp+10h] [ebp-14h]
  int i; // [esp+14h] [ebp-10h]

  v4 = *(float *)(*pm + 32) * *(float *)a1
     + *(float *)(*pm + 36) * *(float *)(a1 + 4)
     + *(float *)(*pm + 40) * *(float *)(a1 + 8);
  v6 = a2 - v4;
  if ( v6 > 0.0 )
  {
    if ( a2 >= 100.0 )
      v3 = a2;
    else
      v3 = 100.0;
    v5 = a3 * *(float *)&pml[9] * v3;
    if ( v5 > (long double)v6 )
      v5 = a2 - v4;
    if ( *(_DWORD *)(*pm + 84) != 1023 )
      v5 = 1.0 / *(float *)(*pm + 892) * v5;
    if ( v5 > (long double)v6 )
      v5 = a2 - v4;
    for ( i = 0; i <= 2; ++i )
      *(float *)(*pm + 4 * i + 32) = v5 * *(float *)(a1 + 4 * i) + *(float *)(*pm + 4 * i + 32);
  }
}

//----- (0001EEC9) --------------------------------------------------------
long double __cdecl sub_1EEC9(char *a1)
{
  int v2; // [esp+Ch] [ebp-2Ch]
  int v3; // [esp+10h] [ebp-28h]
  int v4; // [esp+14h] [ebp-24h]
  int v5; // [esp+18h] [ebp-20h]
  int v6; // [esp+1Ch] [ebp-1Ch]
  float v8; // [esp+28h] [ebp-10h]
  float v9; // [esp+28h] [ebp-10h]
  float v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  v6 = a1[20];
  if ( v6 < 0 )
    v6 = -v6;
  v11 = v6;
  v5 = a1[21];
  if ( v5 < 0 )
    v5 = -v5;
  if ( v5 > v6 )
  {
    v4 = a1[21];
    if ( v4 < 0 )
      v4 = -v4;
    v11 = v4;
  }
  v3 = a1[22];
  if ( v3 < 0 )
    v3 = -v3;
  if ( v3 > v11 )
  {
    v2 = a1[22];
    if ( v2 < 0 )
      v2 = -v2;
    v11 = v2;
  }
  if ( !v11 )
    return 0.0;
  v10 = sqrt((double)(a1[22] * a1[22] + a1[21] * a1[21] + a1[20] * a1[20]));
  v8 = (long double)*(int *)(*pm + 68) * (long double)v11 / (v10 * 127.0);
  if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 64) != 0.0 )
    v9 = v8 * *(float *)(*pm + 844);
  else
    v9 = v8 * *(float *)(*pm + 848);
  if ( *(_DWORD *)(*pm + 4) == 2 )
    v9 = v9 * 3.0;
  if ( *(_DWORD *)(*pm + 4) == 3 )
    v9 = v9 * 6.0;
  return v9;
}

//----- (0001F08B) --------------------------------------------------------
long double __cdecl sub_1F08B(_BYTE *a1)
{
  long double v1; // fst7
  float v3; // [esp+8h] [ebp-30h]
  float v5; // [esp+10h] [ebp-28h]
  float v6; // [esp+10h] [ebp-28h]
  int v7; // [esp+14h] [ebp-24h]
  float v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+18h] [ebp-20h]
  float v10; // [esp+20h] [ebp-18h]
  float v11; // [esp+24h] [ebp-14h]
  float v12; // [esp+28h] [ebp-10h]
  float v13; // [esp+28h] [ebp-10h]
  float v14; // [esp+2Ch] [ebp-Ch]

  if ( (char)a1[20] >= 0 )
    v1 = fabs((long double)(char)a1[20]);
  else
    v1 = fabs((long double)(char)a1[20] * *(float *)(*pm + 864));
  v11 = v1;
  v10 = fabs((long double)(char)a1[21] * *(float *)(*pm + 860));
  if ( v11 <= (long double)v10 )
    v3 = v10;
  else
    v3 = v1;
  if ( v3 == 0.0 )
    return 0.0;
  v14 = sqrt((double)((char)a1[21] * (char)a1[21] + (char)a1[20] * (char)a1[20]));
  v12 = (long double)*(int *)(*pm + 68) * v3 / (v14 * 127.0);
  if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 64) != 0.0 )
    v13 = v12 * *(float *)(*pm + 844);
  else
    v13 = v12 * *(float *)(*pm + 848);
  if ( *(_DWORD *)(*pm + 4) == 2 )
  {
    v13 = v13 * 3.0;
  }
  else if ( *(_DWORD *)(*pm + 4) == 3 )
  {
    v13 = v13 * 6.0;
  }
  else
  {
    v7 = PM_GetEffectiveStance(*pm);
    v8 = sub_2251C(*(_DWORD *)(*pm + 832), *(_DWORD *)(*pm + 828));
    if ( v8 == 0.0 )
    {
      v9 = sub_2251C(*(_DWORD *)(*pm + 828), *(_DWORD *)(*pm + 832));
      if ( v9 == 0.0 )
      {
        if ( v7 == 1 )
        {
          v13 = v13 * *(float *)(*pm + 852);
        }
        else if ( v7 == 2 )
        {
          v13 = v13 * *(float *)(*pm + 856);
        }
      }
      else
      {
        v13 = (*(float *)(*pm + 856) * v9 + (1.0 - v9) * *(float *)(*pm + 852)) * v13;
      }
    }
    else
    {
      v13 = (*(float *)(*pm + 852) * v8 + (1.0 - v8) * *(float *)(*pm + 856)) * v13;
    }
    if ( *(_BYTE *)(pm + 217) )
    {
      v5 = (long double)*(unsigned __int8 *)(pm + 217) / 3.0;
      v6 = 1.0 - (1.0 - 0.5) * v5;
      v13 = v13 * v6;
    }
  }
  if ( *(_DWORD *)(*pm + 176) && *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 176)) + 532) > 0.0 )
    v13 = v13 * *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(*pm + 176)) + 532);
  if ( (a1[5] & 4) != 0 )
    v13 = v13 * 0.40000001;
  return v13;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0001F48F) --------------------------------------------------------
int __usercall sub_1F48F@<eax>(long double a1@<st0>)
{
  int result; // eax
  long double v2; // fst7
  long double v3; // fst7
  long double v4; // fst7
  float v5; // [esp+0h] [ebp-68h]
  int v6; // [esp+10h] [ebp-58h]
  int v7; // [esp+14h] [ebp-54h]
  int v8; // [esp+18h] [ebp-50h]
  char v9[4]; // [esp+20h] [ebp-48h] BYREF
  float v10; // [esp+24h] [ebp-44h]
  int v11; // [esp+3Ch] [ebp-2Ch]
  float v12; // [esp+40h] [ebp-28h] BYREF
  float v13; // [esp+44h] [ebp-24h]
  float v14; // [esp+48h] [ebp-20h]
  float v15; // [esp+5Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*pm + 12) & 1) == 0 || (*(_WORD *)(*pm + 128) & 0xC000) != 0 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      v2 = vectoyaw(*pm + 88) + 180.0;
      v15 = v2;
      AngleDelta(v15, *(float *)(*pm + 196));
      v11 = (int)v2;
      v7 = (int)v2;
      if ( (int)v2 < 0 )
        v7 = -v7;
      if ( v7 > 90 )
      {
        if ( v11 <= 0 )
          v11 = -90;
        else
          v11 = 90;
      }
      result = (char)v11;
      *(_DWORD *)(*pm + 124) = (char)v11;
    }
    else
    {
      v12 = *(float *)(*pm + 20) - *(float *)&pml[27];
      v13 = *(float *)(*pm + 24) - *(float *)&pml[28];
      v14 = *(float *)(*pm + 28) - *(float *)&pml[29];
      if ( !*(_BYTE *)(pm + 24) && !*(_BYTE *)(pm + 25)
        || *(_DWORD *)(*pm + 84) == 1023
        || (v15 = sqrt(v12 * v12 + v13 * v13 + v14 * v14), v15 == 0.0)
        || v15 <= *(float *)&pml[9] * 5.0 )
      {
        result = *pm;
        *(_DWORD *)(*pm + 124) = 0;
      }
      else
      {
        v3 = VectorNormalize2(&v12, v9);
        vectoangles(v9, v9);
        AngleDelta(v10, *(float *)(*pm + 196));
        v11 = (int)v3;
        if ( *(char *)(pm + 24) < 0 )
        {
          v4 = (long double)v11 + 180.0;
          v5 = v4;
          AngleNormalize180(v5);
          v11 = (int)v4;
        }
        v6 = v11;
        if ( v11 < 0 )
          v6 = -v11;
        if ( v6 > 90 )
        {
          if ( v11 <= 0 )
            v11 = -90;
          else
            v11 = 90;
        }
        result = (char)v11;
        *(_DWORD *)(*pm + 124) = (char)v11;
      }
    }
  }
  else
  {
    AngleDelta(*(float *)(*pm + 872), *(float *)(*pm + 196));
    v11 = (int)a1;
    v8 = (int)a1;
    if ( (int)a1 < 0 )
      v8 = -v8;
    if ( v8 > 90 )
    {
      if ( v11 <= 0 )
        v11 = -90;
      else
        v11 = 90;
    }
    result = (char)v11;
    *(_DWORD *)(*pm + 124) = (char)v11;
  }
  return result;
}
// 12F80: using guessed type long double __cdecl vectoyaw(_DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0001F7D7) --------------------------------------------------------
int sub_1F7D7()
{
  int v1; // [esp+0h] [ebp-Ch]

  if ( (pml[21] & 0x2000) != 0 )
    v1 = 0;
  else
    v1 = (pml[21] & 0x1F00000) >> 20;
  return v1;
}

//----- (0001F82A) --------------------------------------------------------
int sub_1F82A()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    return 83;
  v2 = sub_1F7D7();
  if ( v2 )
    v1 = v2 + 70;
  else
    v1 = 0;
  return v1;
}

//----- (0001F882) --------------------------------------------------------
int __cdecl sub_1F882(float a1)
{
  int v1; // esi
  int result; // eax
  float v3; // [esp+Ch] [ebp-Ch]

  pml[12] = 0;
  pml[13] = 0;
  pml[11] = 0;
  *(_DWORD *)(*pm + 84) = 1023;
  v3 = (a1 + a1) * (long double)*(int *)(*pm + 60);
  if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 && *(int *)(*pm + 16) <= 1800 )
    v3 = v3 / sub_1EA52();
  v1 = *pm;
  *(float *)(v1 + 40) = sqrt(v3);
  *(_DWORD *)(*pm + 12) |= 0x2008u;
  *(_DWORD *)(*pm + 16) = 0;
  result = *(_DWORD *)(*pm + 28);
  *(_DWORD *)(*pm + 104) = result;
  return result;
}

//----- (0001F985) --------------------------------------------------------
int sub_1F985()
{
  int v0; // eax
  int v2; // [esp+1Ch] [ebp-3Ch]
  float v3; // [esp+20h] [ebp-38h] BYREF
  float v4; // [esp+24h] [ebp-34h]
  float v5; // [esp+28h] [ebp-30h]
  float v6; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+4Ch] [ebp-Ch]

  if ( *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 100) <= 499 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x800) != 0 )
    return 0;
  if ( PM_GetEffectiveStance(*pm) )
    return 0;
  if ( *(char *)(pm + 26) <= 9 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 8) != 0 )
  {
    *(_BYTE *)(pm + 26) = 0;
    v2 = 0;
  }
  else
  {
    sub_1F882(39.0);
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.75;
      v3 = *(float *)pml;
      v4 = *(float *)&pml[1];
      v5 = 0.0;
      VectorNormalize(&v3);
      if ( *(float *)(*pm + 88) * *(float *)pml
         + *(float *)(*pm + 92) * *(float *)&pml[1]
         + *(float *)(*pm + 96) * *(float *)&pml[2] >= 0.0 )
      {
        v6 = v3;
        v7 = v4;
        v8 = v5;
      }
      else
      {
        v9 = v3 * *(float *)(*pm + 88) + v4 * *(float *)(*pm + 92) + v5 * *(float *)(*pm + 96);
        v6 = v9 * -2.0 * *(float *)(*pm + 88) + v3;
        v7 = v9 * -2.0 * *(float *)(*pm + 92) + v4;
        v8 = v9 * -2.0 * *(float *)(*pm + 96) + v5;
        VectorNormalize(&v6);
      }
      *(float *)(*pm + 32) = v6 * 128.0;
      *(float *)(*pm + 36) = v7 * 128.0;
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
    }
    v0 = sub_1F82A();
    PM_AddEvent(v0);
    *(float *)(*pm + 984) = *(float *)(*pm + 984) + 64.0;
    if ( *(float *)(*pm + 984) > 255.0 )
      *(_DWORD *)(*pm + 984) = 1132396544;
    if ( *(char *)(pm + 24) < 0 )
      BG_AnimScriptEvent(*pm, 4, 0, 1);
    else
      BG_AnimScriptEvent(*pm, 3, 0, 1);
    v2 = 1;
  }
  return v2;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 139D0: using guessed type _DWORD __cdecl VectorNormalize(_DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0001FCF9) --------------------------------------------------------
int sub_1FCF9()
{
  float v1; // [esp+1Ch] [ebp-4Ch]
  int v2[7]; // [esp+20h] [ebp-48h] BYREF
  float v3; // [esp+3Ch] [ebp-2Ch]
  int v4; // [esp+40h] [ebp-28h]
  int v5; // [esp+44h] [ebp-24h]
  float v6; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  sub_1EAB3();
  v1 = sub_1EEC9((char *)(pm + 4));
  if ( v1 == 0.0 )
  {
    v4 = 0;
    v5 = 0;
    v6 = 0.0;
  }
  else
  {
    for ( i = 0; i <= 2; ++i )
      *((float *)&v4 + i) = v1 * *(float *)&pml[i] * (long double)*(char *)(pm + 24)
                          + v1 * *(float *)&pml[i + 3] * (long double)*(char *)(pm + 25);
    v6 = (long double)*(char *)(pm + 26) * v1 + v6;
  }
  if ( *(_DWORD *)(*pm + 68) )
  {
    v6 = v6 - (long double)(16 * (*(_BYTE *)(pm + 9) & 0x20));
    v6 = (long double)(16 * (*(_BYTE *)(pm + 9) & 0x10)) + v6;
  }
  v2[0] = v4;
  v2[1] = v5;
  *(float *)&v2[2] = v6;
  v3 = VectorNormalize(v2);
  sub_1ED62((int)v2, v3, 8.0);
  return PM_StepSlideMove(0);
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 15650: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (0001FE8D) --------------------------------------------------------
int sub_1FE8D()
{
  long double v0; // fst7
  int v2[10]; // [esp+10h] [ebp-78h] BYREF
  float v3; // [esp+38h] [ebp-50h]
  float v4; // [esp+3Ch] [ebp-4Ch]
  int v5[6]; // [esp+40h] [ebp-48h] BYREF
  float v6; // [esp+58h] [ebp-30h]
  float v7; // [esp+5Ch] [ebp-2Ch]
  float v8[7]; // [esp+60h] [ebp-28h]
  int i; // [esp+7Ch] [ebp-Ch]

  sub_1EAB3();
  v7 = (float)*(char *)(pm + 24);
  v6 = (float)*(char *)(pm + 25);
  v2[0] = *(_DWORD *)(pm + 4);
  v2[1] = *(_DWORD *)(pm + 8);
  v2[2] = *(_DWORD *)(pm + 12);
  v2[3] = *(_DWORD *)(pm + 16);
  v2[4] = *(_DWORD *)(pm + 20);
  v2[5] = *(_DWORD *)(pm + 24);
  v3 = sub_1EEC9((char *)v2);
  pml[2] = 0;
  pml[5] = 0;
  VectorNormalize(pml);
  VectorNormalize(&pml[3]);
  for ( i = 0; i <= 1; ++i )
    v8[i] = *(float *)&pml[i] * v7 + *(float *)&pml[i + 3] * v6;
  v8[2] = 0.0;
  *(float *)v5 = v8[0];
  *(float *)&v5[1] = v8[1];
  v5[2] = 0;
  v4 = VectorNormalize(v5);
  v0 = v4 * v3;
  v4 = v0;
  sub_1ED62((int)v5, v4, 1.0);
  if ( pml[12] )
    PM_ClipVelocity(*pm + 32, (int)&pml[18], *pm + 32, 1.001);
  PM_StepSlideMove(1);
  return sub_1F48F(v0);
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 15650: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (0002003D) --------------------------------------------------------
int sub_2003D()
{
  int result; // eax
  long double v1; // fst7
  int v2; // [esp+14h] [ebp-94h]
  float v3; // [esp+18h] [ebp-90h]
  float v4; // [esp+1Ch] [ebp-8Ch]
  int v5[10]; // [esp+20h] [ebp-88h] BYREF
  float v6; // [esp+48h] [ebp-60h]
  float v7; // [esp+4Ch] [ebp-5Ch]
  int v8[6]; // [esp+50h] [ebp-58h] BYREF
  float v9; // [esp+68h] [ebp-40h]
  float v10; // [esp+6Ch] [ebp-3Ch]
  float v11; // [esp+70h] [ebp-38h]
  float v12; // [esp+74h] [ebp-34h]
  float v13; // [esp+78h] [ebp-30h]
  float v14[7]; // [esp+80h] [ebp-28h]
  int i; // [esp+9Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 )
  {
    if ( *(int *)(*pm + 16) <= 1800 )
    {
      if ( !*(_DWORD *)(*pm + 16) )
      {
        if ( *(float *)(*pm + 104) + 18.0 <= *(float *)(*pm + 28) )
        {
          *(_DWORD *)(*pm + 16) = 1200;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.5;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.5;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.5;
        }
        else
        {
          *(_DWORD *)(*pm + 16) = 1800;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.64999998;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.64999998;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.64999998;
        }
      }
    }
    else
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*pm + 104) = 0;
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.64999998;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.64999998;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.64999998;
    }
  }
  if ( sub_1F985() )
  {
    sub_1FE8D();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*pm + 100) = result;
  }
  else
  {
    sub_1EAB3();
    v10 = (float)*(char *)(pm + 24);
    v9 = (float)*(char *)(pm + 25);
    v5[0] = *(_DWORD *)(pm + 4);
    v5[1] = *(_DWORD *)(pm + 8);
    v5[2] = *(_DWORD *)(pm + 12);
    v5[3] = *(_DWORD *)(pm + 16);
    v5[4] = *(_DWORD *)(pm + 20);
    v5[5] = *(_DWORD *)(pm + 24);
    v6 = sub_1F08B(v5);
    pml[2] = 0;
    pml[5] = 0;
    PM_ClipVelocity((int)pml, (int)&pml[18], (int)pml, 1.001);
    PM_ClipVelocity((int)&pml[3], (int)&pml[18], (int)&pml[3], 1.001);
    VectorNormalize(pml);
    VectorNormalize(&pml[3]);
    for ( i = 0; i <= 2; ++i )
      v14[i] = *(float *)&pml[i] * v10 + *(float *)&pml[i + 3] * v9;
    *(float *)v8 = v14[0];
    *(float *)&v8[1] = v14[1];
    *(float *)&v8[2] = v14[2];
    v7 = VectorNormalize(v8);
    v7 = v7 * v6;
    v2 = PM_GetEffectiveStance(*pm);
    if ( (pml[21] & 2) != 0 || (*(_DWORD *)(*pm + 12) & 0x200) != 0 )
    {
      v4 = pm_airaccelerate;
    }
    else if ( v2 == 1 )
    {
      v4 = pm_prone_accelerate;
    }
    else if ( v2 == 2 )
    {
      v4 = pm_ducked_accelerate;
    }
    else
    {
      v4 = pm_accelerate;
    }
    if ( (*(_DWORD *)(*pm + 12) & 0x100) != 0 )
      v4 = v4 * 0.25;
    sub_1ED62((int)v8, v7, v4);
    if ( (pml[21] & 2) != 0 || (*(_DWORD *)(*pm + 12) & 0x200) != 0 )
      *(float *)(*pm + 40) = *(float *)(*pm + 40) - (long double)*(int *)(*pm + 60) * *(float *)&pml[9];
    v3 = sqrt(
           *(float *)(*pm + 32) * *(float *)(*pm + 32)
         + *(float *)(*pm + 36) * *(float *)(*pm + 36)
         + *(float *)(*pm + 40) * *(float *)(*pm + 40));
    v11 = *(float *)(*pm + 32);
    v12 = *(float *)(*pm + 36);
    v13 = *(float *)(*pm + 40);
    PM_ClipVelocity(*pm + 32, (int)&pml[18], *pm + 32, 1.001);
    if ( *(float *)(*pm + 32) * v11 + *(float *)(*pm + 36) * v12 + *(float *)(*pm + 40) * v13 > 0.0 )
    {
      VectorNormalize(*pm + 32);
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * v3;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * v3;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * v3;
    }
    v1 = 0.0;
    if ( *(float *)(*pm + 32) != 0.0 || (v1 = 0.0, *(float *)(*pm + 36) != 0.0) )
      PM_StepSlideMove(0);
    result = sub_1F48F(v1);
  }
  return result;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 15650: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (00020707) --------------------------------------------------------
_DWORD *sub_20707()
{
  _DWORD *result; // eax
  int v1; // esi
  int v2; // ecx
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]

  result = pml;
  if ( pml[11] )
  {
    v3 = sqrt(
           *(float *)(*pm + 32) * *(float *)(*pm + 32)
         + *(float *)(*pm + 36) * *(float *)(*pm + 36)
         + *(float *)(*pm + 40) * *(float *)(*pm + 40));
    v4 = v3 - 20.0;
    if ( v4 > 0.0 )
    {
      VectorNormalize(*pm + 32);
      *(float *)(*pm + 32) = *(float *)(*pm + 32) * v4;
      *(float *)(*pm + 36) = *(float *)(*pm + 36) * v4;
      result = (_DWORD *)*pm;
      *(float *)(*pm + 40) = *(float *)(*pm + 40) * v4;
    }
    else
    {
      v1 = *pm;
      v2 = *pm;
      result = 0;
      *(_DWORD *)(*pm + 40) = 0;
      *(_DWORD *)(v2 + 36) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0002084C) --------------------------------------------------------
int sub_2084C()
{
  int result; // eax
  float v1; // [esp+10h] [ebp-68h]
  float v2; // [esp+18h] [ebp-60h]
  float v3; // [esp+1Ch] [ebp-5Ch]
  float v4; // [esp+1Ch] [ebp-5Ch]
  int v5[6]; // [esp+20h] [ebp-58h] BYREF
  float v6; // [esp+38h] [ebp-40h]
  float v7; // [esp+3Ch] [ebp-3Ch]
  float v8[2]; // [esp+40h] [ebp-38h]
  int v9; // [esp+48h] [ebp-30h]
  int i; // [esp+58h] [ebp-20h]
  float v11; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]
  float v15; // [esp+6Ch] [ebp-Ch]

  *(_DWORD *)(*pm + 204) = bg_viewheight_standing[3];
  *(_DWORD *)(*pm + 836) = bg_viewheight_standing[3];
  v15 = sqrt(
          *(float *)(*pm + 32) * *(float *)(*pm + 32)
        + *(float *)(*pm + 36) * *(float *)(*pm + 36)
        + *(float *)(*pm + 40) * *(float *)(*pm + 40));
  if ( v15 >= 1.0 )
  {
    v14 = 0.0;
    v13 = 5.5 * 1.5;
    if ( v15 >= 100.0 )
      v1 = v15;
    else
      v1 = 100.0;
    v12 = v1;
    v14 = v1 * v13 * *(float *)&pml[9] + v14;
    v11 = v15 - v14;
    if ( v11 < 0.0 )
      v11 = 0.0;
    v11 = v11 / v15;
    *(float *)(*pm + 32) = *(float *)(*pm + 32) * v11;
    *(float *)(*pm + 36) = *(float *)(*pm + 36) * v11;
    *(float *)(*pm + 40) = *(float *)(*pm + 40) * v11;
  }
  else
  {
    *(_DWORD *)(*pm + 32) = vec3_origin[0];
    *(_DWORD *)(*pm + 36) = vec3_origin[1];
    *(_DWORD *)(*pm + 40) = vec3_origin[2];
  }
  v2 = sub_1EEC9((char *)(pm + 4));
  v7 = (float)*(char *)(pm + 24);
  v6 = (float)*(char *)(pm + 25);
  for ( i = 0; i <= 2; ++i )
    v8[i] = *(float *)&pml[i] * v7 + *(float *)&pml[i + 3] * v6;
  *(float *)&v9 = (long double)*(char *)(pm + 26) + *(float *)&v9;
  *(float *)v5 = v8[0];
  *(float *)&v5[1] = v8[1];
  v5[2] = v9;
  v3 = VectorNormalize(v5);
  v4 = v3 * v2;
  sub_1ED62((int)v5, v4, 9.0);
  *(float *)(*pm + 20) = *(float *)(*pm + 32) * *(float *)&pml[9] + *(float *)(*pm + 20);
  *(float *)(*pm + 24) = *(float *)(*pm + 36) * *(float *)&pml[9] + *(float *)(*pm + 24);
  result = *pm;
  *(float *)(*pm + 28) = *(float *)(*pm + 40) * *(float *)&pml[9] + *(float *)(*pm + 28);
  return result;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (00020BAE) --------------------------------------------------------
int sub_20BAE()
{
  int v0; // ecx
  int result; // eax
  float v2; // [esp+1Ch] [ebp-8Ch]
  float v3[4]; // [esp+20h] [ebp-88h] BYREF
  int v4[4]; // [esp+30h] [ebp-78h] BYREF
  int i; // [esp+40h] [ebp-68h]
  float v6; // [esp+48h] [ebp-60h]
  float v7; // [esp+4Ch] [ebp-5Ch]
  int v8[6]; // [esp+50h] [ebp-58h] BYREF
  float v9; // [esp+68h] [ebp-40h]
  float v10; // [esp+6Ch] [ebp-3Ch]
  float v11[2]; // [esp+70h] [ebp-38h]
  int v12; // [esp+78h] [ebp-30h]
  float v13; // [esp+8Ch] [ebp-1Ch]
  float v14; // [esp+90h] [ebp-18h]
  float v15; // [esp+94h] [ebp-14h]
  float v16; // [esp+98h] [ebp-10h]
  float v17; // [esp+9Ch] [ebp-Ch]

  *(_DWORD *)(*pm + 204) = bg_viewheight_standing[3];
  *(_DWORD *)(*pm + 836) = bg_viewheight_standing[3];
  *(_BYTE *)(pm + 26) -= 127 * (*(_BYTE *)(pm + 9) & 0x20);
  *(_BYTE *)(pm + 26) += 127 * (*(_BYTE *)(pm + 9) & 0x10);
  if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
  {
    v17 = sqrt(
            *(float *)(*pm + 32) * *(float *)(*pm + 32)
          + *(float *)(*pm + 36) * *(float *)(*pm + 36)
          + *(float *)(*pm + 40) * *(float *)(*pm + 40));
  }
  else if ( (long double)*(char *)(pm + 26) == 0.0 )
  {
    v17 = 0.0;
  }
  else
  {
    v0 = *pm;
    *(_DWORD *)(*pm + 36) = 0;
    *(_DWORD *)(v0 + 32) = 0;
    v17 = 127.0;
    *(float *)(*pm + 40) = (float)*(char *)(pm + 26);
  }
  if ( v17 >= 1.0 )
  {
    v16 = 0.0;
    v15 = 5.5 * 1.5;
    if ( v17 >= 100.0 )
      v2 = v17;
    else
      v2 = 100.0;
    v14 = v2;
    v16 = v2 * v15 * *(float *)&pml[9] + v16;
    v13 = v17 - v16;
    if ( v13 < 0.0 )
      v13 = 0.0;
    v13 = v13 / v17;
    *(float *)(*pm + 32) = *(float *)(*pm + 32) * v13;
    *(float *)(*pm + 36) = *(float *)(*pm + 36) * v13;
    *(float *)(*pm + 40) = *(float *)(*pm + 40) * v13;
  }
  else
  {
    *(_DWORD *)(*pm + 32) = vec3_origin[0];
    *(_DWORD *)(*pm + 36) = vec3_origin[1];
    *(_DWORD *)(*pm + 40) = vec3_origin[2];
  }
  v6 = sub_1EEC9((char *)(pm + 4));
  v10 = (float)*(char *)(pm + 24);
  v9 = (float)*(char *)(pm + 25);
  v4[1] = 0;
  v4[0] = 0;
  v4[2] = 1065353216;
  CrossProduct(v4, &pml[3], v3);
  for ( i = 0; i <= 2; ++i )
    v11[i] = v3[i] * v10 + *(float *)&pml[i + 3] * v9;
  *(float *)&v12 = (long double)*(char *)(pm + 26) + (long double)*(char *)(pm + 26) + *(float *)&v12;
  *(float *)v8 = v11[0];
  *(float *)&v8[1] = v11[1];
  v8[2] = v12;
  v7 = VectorNormalize(v8);
  v7 = v7 * v6;
  sub_1ED62((int)v8, v7, 9.0);
  *(float *)(*pm + 20) = *(float *)(*pm + 32) * *(float *)&pml[9] + *(float *)(*pm + 20);
  *(float *)(*pm + 24) = *(float *)(*pm + 36) * *(float *)&pml[9] + *(float *)(*pm + 24);
  result = *pm;
  *(float *)(*pm + 28) = *(float *)(*pm + 40) * *(float *)&pml[9] + *(float *)(*pm + 28);
  return result;
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (0002105C) --------------------------------------------------------
int __cdecl sub_2105C(char a1)
{
  int v3; // [esp+10h] [ebp-8h]

  v3 = sub_1F7D7();
  if ( !v3 )
    return 0;
  if ( (a1 & 1) != 0 )
    return v3 + 47;
  if ( a1 >= 0 && *(float *)(*pm + 64) == 0.0 )
    return v3 + 1;
  return v3 + 24;
}

//----- (000210DE) --------------------------------------------------------
int sub_210DE()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_1F7D7();
  if ( v2 )
    v1 = v2 + 24;
  else
    v1 = 0;
  return v1;
}

//----- (00021109) --------------------------------------------------------
int sub_21109()
{
  int v1; // [esp+0h] [ebp-8h]
  int v2; // [esp+4h] [ebp-4h]

  v2 = sub_1F7D7();
  if ( v2 )
    v1 = v2 + 1;
  else
    v1 = 0;
  return v1;
}

//----- (00021132) --------------------------------------------------------
int sub_21132()
{
  return sub_1F7D7() + 93;
}

//----- (00021148) --------------------------------------------------------
int sub_21148()
{
  return sub_1F7D7() + 116;
}

//----- (0002115E) --------------------------------------------------------
void sub_2115E()
{
  long double v0; // fst6
  int v1; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  char v5; // [esp+4h] [ebp-74h]
  double v6; // [esp+4h] [ebp-74h]
  float v7; // [esp+1Ch] [ebp-5Ch]
  int v8; // [esp+24h] [ebp-54h]
  int v9; // [esp+38h] [ebp-40h]
  int v10; // [esp+3Ch] [ebp-3Ch]
  int v11; // [esp+3Ch] [ebp-3Ch]
  int v12; // [esp+40h] [ebp-38h]
  float v13; // [esp+44h] [ebp-34h]
  float v14; // [esp+48h] [ebp-30h]
  float v15; // [esp+54h] [ebp-24h]
  float v16; // [esp+58h] [ebp-20h]
  float v17; // [esp+60h] [ebp-18h]
  float v18; // [esp+64h] [ebp-14h]
  float v19; // [esp+68h] [ebp-10h]
  float v20; // [esp+6Ch] [ebp-Ch]

  if ( *(_BYTE *)(pm + 217) != 3 )
  {
    v18 = *(float *)&pml[29] - *(float *)(*pm + 28);
    v17 = *(float *)&pml[32];
    v7 = (float)*(int *)(*pm + 60);
    v15 = COERCE_FLOAT(LODWORD(v7) ^ 0x80000000) * 0.5;
    v14 = v17 * v17 - v15 * 4.0 * v18;
    if ( v14 >= 0.0 )
    {
      v16 = (-v17 - sqrt(v14)) / (v15 + v15);
      v20 = (v16 * COERCE_FLOAT(LODWORD(v7) ^ 0x80000000) + v17) * -1.0;
      v0 = (long double)*(int *)(*pm + 60);
      v19 = v20 * v20 / (v0 + v0);
      if ( *(_DWORD *)(pm + 56) )
      {
        v6 = v20;
        Com_Printf("landing vel: %.1f fall height: %.1f\n", SLOBYTE(v6));
      }
      if ( bg_fallDamageMinHeight[2] < (long double)bg_fallDamageMaxHeight[2] && bg_fallDamageMinHeight[2] >= 0.0 )
      {
        if ( bg_fallDamageMinHeight[2] >= (long double)v19 || (pml[21] & 1) != 0 || *(int *)(*pm + 4) > 5 )
        {
          v10 = 0;
        }
        else if ( v19 < (long double)bg_fallDamageMaxHeight[2] )
        {
          v11 = (int)((v19 - bg_fallDamageMinHeight[2]) / (bg_fallDamageMaxHeight[2] - bg_fallDamageMinHeight[2]) * 100.0);
          if ( v11 < 0 )
          {
            v8 = 0;
          }
          else
          {
            v8 = (int)((v19 - bg_fallDamageMinHeight[2])
                     / (bg_fallDamageMaxHeight[2] - bg_fallDamageMinHeight[2])
                     * 100.0);
            if ( v11 > 100 )
              v8 = 100;
          }
          v10 = v8;
        }
        else
        {
          v10 = 100;
        }
      }
      else
      {
        Com_Printf("bg_fallDamageMaxHeight and bg_fallDamageMinHeight have bad values\n", v5);
        v10 = 0;
      }
      if ( *(_BYTE *)(pm + 217) == 2 )
        v10 = (int)((long double)v10 * 0.5);
      if ( v19 > 12.0 )
        v12 = (int)((v19 - 12.0) / 26.0 * 4.0 + 4.0);
      else
        v12 = 0;
      if ( v12 > 24 )
        LOBYTE(v12) = 24;
      if ( v10 )
      {
        if ( !*(_DWORD *)(*pm + 108) )
          BG_AnimScriptEvent(*pm, 5, 0, 1);
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("falling damage: %i\n", v10);
        if ( v10 > 99 || (pml[21] & 2) != 0 )
        {
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.67000002;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.67000002;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.67000002;
        }
        else
        {
          v9 = 35 * v10 + 500;
          if ( v9 > 2000 )
            v9 = 2000;
          if ( v9 > 500 )
          {
            if ( v9 <= 1499 )
              v13 = 0.5 - ((long double)v9 - 500.0) / 1000.0 * 0.30000001;
            else
              v13 = 0.2;
          }
          else
          {
            v13 = 0.5;
          }
          if ( *(int *)(pm + 56) > 1 )
            Com_Printf("landing stun time: %i speed mult: %.2f\n", v9);
          *(_DWORD *)(*pm + 16) = v9;
          *(_DWORD *)(*pm + 12) |= 0x100u;
          *(float *)(*pm + 32) = *(float *)(*pm + 32) * v13;
          *(float *)(*pm + 36) = *(float *)(*pm + 36) * v13;
          *(float *)(*pm + 40) = *(float *)(*pm + 40) * v13;
        }
        v1 = sub_21148();
        BG_AddPredictableEventToPlayerstate(v1, v10, *pm);
      }
      else if ( v19 > 4.0 )
      {
        if ( v19 >= 8.0 )
        {
          if ( v19 >= 12.0 )
          {
            *(float *)(*pm + 32) = *(float *)(*pm + 32) * 0.67000002;
            *(float *)(*pm + 36) = *(float *)(*pm + 36) * 0.67000002;
            *(float *)(*pm + 40) = *(float *)(*pm + 40) * 0.67000002;
            v4 = sub_21132();
            BG_AddPredictableEventToPlayerstate(v4, v12, *pm);
          }
          else
          {
            v3 = sub_21109();
            PM_AddEvent(v3);
          }
        }
        else
        {
          v2 = sub_210DE();
          PM_AddEvent(v2);
        }
      }
    }
  }
}
// 212CA: variable 'v5' is possibly undefined
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021761) --------------------------------------------------------
int __cdecl sub_21761(int a1)
{
  float v3; // [esp+30h] [ebp-38h] BYREF
  float v4; // [esp+34h] [ebp-34h]
  float v5; // [esp+38h] [ebp-30h]
  unsigned int i; // [esp+4Ch] [ebp-1Ch]

  for ( i = 0; i <= 0x19; ++i )
  {
    v3 = *(float *)(*pm + 20) + flt_75820[3 * i];
    v4 = *(float *)(*pm + 24) + flt_75820[3 * i + 1];
    v5 = *(float *)(*pm + 28) + flt_75820[3 * i + 2];
    PM_trace(a1, &v3, pm + 192, pm + 204, &v3, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
    if ( !*(_BYTE *)(a1 + 47) )
    {
      *(float *)(*pm + 20) = v3;
      *(float *)(*pm + 24) = v4;
      *(float *)(*pm + 28) = v5;
      v3 = *(float *)(*pm + 20);
      v4 = *(float *)(*pm + 24);
      v5 = *(float *)(*pm + 28) - 1.0;
      PM_trace(a1, *pm + 20, pm + 192, pm + 204, &v3, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
      qmemcpy(&pml[14], (const void *)a1, 0x30u);
      *(_DWORD *)(*pm + 20) = *(_DWORD *)(a1 + 4);
      *(_DWORD *)(*pm + 24) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(*pm + 28) = *(_DWORD *)(a1 + 12);
      return 1;
    }
  }
  *(_DWORD *)(*pm + 84) = 1023;
  pml[12] = 0;
  pml[13] = 0;
  pml[11] = 0;
  *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
  *(_DWORD *)(*pm + 104) = 0;
  return 0;
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021A17) --------------------------------------------------------
_DWORD *sub_21A17()
{
  _DWORD *result; // eax
  int v1; // [esp+20h] [ebp-48h] BYREF
  int v2; // [esp+24h] [ebp-44h]
  float v3; // [esp+28h] [ebp-40h]
  float v4[14]; // [esp+30h] [ebp-38h] BYREF

  if ( *(_DWORD *)(*pm + 84) == 1023 )
  {
    v1 = *(_DWORD *)(*pm + 20);
    v2 = *(_DWORD *)(*pm + 24);
    v3 = *(float *)(*pm + 28);
    v3 = v3 - 1.0;
    (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, _DWORD))(pm + 236))(
      v4,
      *pm + 20,
      pm + 192,
      pm + 204,
      &v1,
      *(_DWORD *)(*pm + 172),
      *(_DWORD *)(pm + 52));
    pml[13] = 1.0 != v4[0];
  }
  else
  {
    if ( *(_DWORD *)(pm + 56) )
      Com_Printf("%i:lift\n", c_pmove);
    v1 = *(_DWORD *)(*pm + 20);
    v2 = *(_DWORD *)(*pm + 24);
    v3 = *(float *)(*pm + 28);
    v3 = v3 - 64.0;
    (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, _DWORD))(pm + 236))(
      v4,
      *pm + 20,
      pm + 192,
      pm + 204,
      &v1,
      *(_DWORD *)(*pm + 172),
      *(_DWORD *)(pm + 52));
    if ( v4[0] == 1.0 )
    {
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*pm, 4, 0, 1);
      else
        BG_AnimScriptEvent(*pm, 3, 0, 1);
      pml[13] = 0;
    }
    else
    {
      pml[13] = v4[0] < 0.015625;
    }
  }
  *(_DWORD *)(*pm + 84) = 1023;
  pml[12] = 0;
  result = pml;
  pml[11] = 0;
  return result;
}
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00021CCD) --------------------------------------------------------
_DWORD *sub_21CCD()
{
  int v0; // eax
  long double v1; // fst6
  _DWORD *result; // eax
  float v3[12]; // [esp+20h] [ebp-68h] BYREF
  int v4[4]; // [esp+50h] [ebp-38h] BYREF
  int v5[2]; // [esp+60h] [ebp-28h] BYREF
  float v6; // [esp+68h] [ebp-20h]

  v5[0] = *(_DWORD *)(*pm + 20);
  v5[1] = *(_DWORD *)(*pm + 24);
  v4[0] = *(_DWORD *)(*pm + 20);
  v4[1] = *(_DWORD *)(*pm + 24);
  if ( (*(_WORD *)(*pm + 128) & 0xC000) != 0 )
  {
    v6 = *(float *)(*pm + 28);
    v0 = *pm;
    v1 = 1.0;
  }
  else
  {
    v6 = *(float *)(*pm + 28) + 0.25;
    v0 = *pm;
    v1 = 0.25;
  }
  *(float *)&v4[2] = *(float *)(v0 + 28) - v1;
  PM_trace(v3, v5, pm + 192, pm + 204, v4, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
  qmemcpy(&pml[14], v3, 0x30u);
  if ( !BYTE2(v3[11]) || (result = (_DWORD *)sub_21761((int)v3)) != 0 )
  {
    if ( HIBYTE(v3[11]) )
    {
      v6 = *(float *)(*pm + 28) - 0.001;
      PM_trace(v3, v5, pm + 192, pm + 204, v4, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
      if ( HIBYTE(v3[11]) )
      {
        *(_DWORD *)(*pm + 84) = 1023;
        pml[12] = 0;
        pml[13] = 0;
        result = pml;
        pml[11] = 0;
        return result;
      }
      qmemcpy(&pml[14], v3, 0x30u);
    }
    if ( v3[0] == 1.0 )
    {
      result = sub_21A17();
    }
    else if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0
           || *(float *)(*pm + 40) <= 0.0
           || *(float *)(*pm + 32) * v3[4] + *(float *)(*pm + 36) * v3[5] + *(float *)(*pm + 40) * v3[6] <= 10.0 )
    {
      if ( v3[6] >= 0.69999999 )
      {
        pml[12] = 1;
        pml[13] = 1;
        pml[11] = 1;
        if ( *(_DWORD *)(*pm + 84) == 1023 )
        {
          if ( *(_DWORD *)(pm + 56) )
            Com_Printf("%i:Land\n", c_pmove);
          sub_2115E();
        }
        *(_DWORD *)(*pm + 84) = LOWORD(v3[10]);
        result = (_DWORD *)PM_AddTouchEnt(LOWORD(v3[10]));
      }
      else
      {
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("%i:steep\n", c_pmove);
        *(_DWORD *)(*pm + 84) = 1023;
        pml[12] = 1;
        pml[13] = 1;
        pml[11] = 0;
        *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
        result = (_DWORD *)*pm;
        *(_DWORD *)(*pm + 104) = 0;
      }
    }
    else
    {
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("%i:kickoff\n", c_pmove);
      if ( *(char *)(pm + 24) < 0 )
        BG_AnimScriptEvent(*pm, 4, 0, 0);
      else
        BG_AnimScriptEvent(*pm, 3, 0, 0);
      pml[13] = 0;
      *(_DWORD *)(*pm + 84) = 1023;
      pml[12] = 0;
      result = pml;
      pml[11] = 0;
    }
  }
  return result;
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14AB0: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002219F) --------------------------------------------------------
int sub_2219F()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-24h]
  int v2[2]; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+28h] [ebp-10h]

  *(_BYTE *)(pm + 217) = 0;
  *(_BYTE *)(pm + 216) = 0;
  v2[0] = *(_DWORD *)(*pm + 20);
  v2[1] = *(_DWORD *)(*pm + 24);
  v3 = *(float *)(*pm + 28) + *(float *)(*pm + 812) + 1.0;
  result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 248))(v2, *(_DWORD *)(*pm + 172), 32);
  if ( result )
  {
    v1 = (int)(*(float *)(*pm + 208) - *(float *)(*pm + 812));
    *(_BYTE *)(pm + 216) = result;
    *(_BYTE *)(pm + 217) = 1;
    v3 = *(float *)(*pm + 28) + *(float *)(*pm + 812) + (long double)(v1 / 2);
    result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 248))(v2, *(_DWORD *)(*pm + 172), 32);
    if ( result )
    {
      *(_BYTE *)(pm + 217) = 2;
      v3 = *(float *)(*pm + 28) + *(float *)(*pm + 812) + (long double)v1;
      result = (*(int (__cdecl **)(int *, _DWORD, int))(pm + 248))(v2, *(_DWORD *)(*pm + 172), 32);
      if ( result )
      {
        result = pm;
        *(_BYTE *)(pm + 217) = 3;
      }
    }
  }
  return result;
}

//----- (000223A6) --------------------------------------------------------
int __cdecl PM_GetViewHeightLerpTime(int a1, int a2, int a3)
{
  if ( a2 == *(_DWORD *)(a1 + 828) )
    return 400;
  if ( a2 != *(_DWORD *)(a1 + 832) )
    return 200;
  if ( a3 )
    return 200;
  return 400;
}

//----- (000223F5) --------------------------------------------------------
long double __cdecl sub_223F5(int a1, int a2, float *a3)
{
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  if ( a1 )
  {
    v6 = a2 + 12;
    v7 = 1;
    do
    {
      if ( a1 == *(_DWORD *)v6 )
      {
        *a3 = (float)*(int *)(v6 + 8);
        return *(float *)(v6 + 4);
      }
      if ( *(_DWORD *)v6 > a1 )
      {
        v5 = (long double)(a1 - *(_DWORD *)(a2 + 12 * v7 - 12))
           / (long double)(*(_DWORD *)v6 - *(_DWORD *)(a2 + 12 * v7 - 12));
        *a3 = (long double)*(int *)(a2 + 12 * v7 - 12 + 8)
            + (long double)(*(_DWORD *)(v6 + 8) - *(_DWORD *)(a2 + 12 * v7 - 12 + 8)) * v5;
        return (float)((*(float *)(v6 + 4) - *(float *)(a2 + 12 * v7 - 12 + 4)) * v5 + *(float *)(a2 + 12 * v7 - 12 + 4));
      }
      ++v7;
      v6 = a2 + 12 * v7;
    }
    while ( *(_DWORD *)v6 != -1 );
    *a3 = (float)*(int *)(a2 + 8);
    v4 = *(float *)(a2 + 4);
  }
  else
  {
    *a3 = (float)*(int *)(a2 + 8);
    v4 = *(float *)(a2 + 4);
  }
  return v4;
}

//----- (0002251C) --------------------------------------------------------
long double __cdecl sub_2251C(int a1, int a2)
{
  float v4; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(*pm + 212) )
    return 0.0;
  if ( a1 != -1
    && a2 != -1
    && (a2 != *(_DWORD *)(*pm + 216)
     || a2 == *(_DWORD *)(*pm + 832)
     && (a1 != *(_DWORD *)(*pm + 828) || *(_DWORD *)(*pm + 220))
     && (a1 != *(_DWORD *)(*pm + 836) || !*(_DWORD *)(*pm + 220))) )
  {
    return 0.0;
  }
  v4 = (long double)(*(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 212))
     / (long double)(int)PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 216), *(_DWORD *)(*pm + 220));
  if ( v4 < 0.0 )
    return 0.0;
  if ( v4 > 1.0 )
    v4 = 1.0;
  return v4;
}
// 14C90: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);

//----- (000226A6) --------------------------------------------------------
void sub_226A6()
{
  int v0; // esi
  int v1; // esi
  int v2; // esi
  float v3; // [esp+30h] [ebp-38h] BYREF
  float v4; // [esp+34h] [ebp-34h]
  float v5; // [esp+38h] [ebp-30h]
  int v6; // [esp+40h] [ebp-28h]
  int v7; // [esp+44h] [ebp-24h]
  int v8; // [esp+48h] [ebp-20h]
  float v9; // [esp+50h] [ebp-18h]
  float v10; // [esp+54h] [ebp-14h] BYREF
  int v11; // [esp+58h] [ebp-10h]
  int v12; // [esp+5Ch] [ebp-Ch]

  if ( *(_DWORD *)(*pm + 204) && *(float *)(*pm + 208) != 0.0 )
  {
    if ( *(float *)(*pm + 208) != (long double)*(int *)(*pm + 204) || *(_DWORD *)(*pm + 212) )
    {
      v12 = 0;
      if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 828)
        || *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 832)
        || *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 836) )
      {
        if ( *(_DWORD *)(*pm + 212) )
        {
          v11 = PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 216), *(_DWORD *)(*pm + 220));
          v12 = 100 * (*(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 212)) / v11;
          if ( v12 >= 0 )
          {
            if ( v12 > 100 )
              v12 = 100;
          }
          else
          {
            v12 = 0;
          }
          if ( v12 == 100 )
          {
            *(float *)(*pm + 208) = (float)*(int *)(*pm + 216);
            *(_DWORD *)(*pm + 212) = 0;
            *(_DWORD *)(*pm + 224) = 0;
          }
          else
          {
            if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 828) )
            {
              v0 = *pm;
              *(float *)(v0 + 208) = sub_223F5(v12, (int)&unk_815A0, &v10);
            }
            else if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 832) )
            {
              v1 = *pm;
              if ( *(_DWORD *)(*pm + 220) )
                *(float *)(v1 + 208) = sub_223F5(v12, (int)&unk_814A0, &v10);
              else
                *(float *)(v1 + 208) = sub_223F5(v12, (int)&unk_81680, &v10);
            }
            else
            {
              v2 = *pm;
              *(float *)(v2 + 208) = sub_223F5(v12, (int)&unk_81520, &v10);
            }
            if ( fabs(*(float *)(*pm + 224) - v10) > 0.05000000074505806 )
            {
              v6 = *(_DWORD *)(*pm + 32);
              v7 = *(_DWORD *)(*pm + 36);
              v8 = *(_DWORD *)(*pm + 40);
              v9 = v10 - *(float *)(*pm + 224);
              if ( *(_DWORD *)(*pm + 84) == 1023 )
                v9 = v9 * 0.5;
              v9 = v9 / *(float *)&pml[9];
              v3 = *(float *)pml;
              v4 = *(float *)&pml[1];
              v5 = 0.0;
              VectorNormalize(&v3);
              *(float *)(*pm + 32) = v3 * v9;
              *(float *)(*pm + 36) = v4 * v9;
              *(float *)(*pm + 40) = v5 * v9;
              PM_StepSlideMove(1);
              *(_DWORD *)(*pm + 32) = v6;
              *(_DWORD *)(*pm + 36) = v7;
              *(_DWORD *)(*pm + 40) = v8;
              *(float *)(*pm + 224) = v10;
            }
          }
        }
        if ( *(_DWORD *)(*pm + 212) )
        {
          if ( *(_DWORD *)(*pm + 204) != *(_DWORD *)(*pm + 216)
            && (*(_DWORD *)(*pm + 204) < *(_DWORD *)(*pm + 216) && !*(_DWORD *)(*pm + 220)
             || *(_DWORD *)(*pm + 204) > *(_DWORD *)(*pm + 216) && *(_DWORD *)(*pm + 220)) )
          {
            v12 = 100 - v12;
            *(_DWORD *)(*pm + 220) ^= 1u;
            if ( *(_DWORD *)(*pm + 220) )
            {
              if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 836) )
              {
                *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 832);
              }
              else if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 832) )
              {
                *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 828);
              }
            }
            else if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 828) )
            {
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 832);
            }
            else if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 832) )
            {
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 836);
            }
            if ( v12 == 100 )
            {
              *(float *)(*pm + 208) = (float)*(int *)(*pm + 216);
              *(_DWORD *)(*pm + 212) = 0;
              *(_DWORD *)(*pm + 224) = 0;
            }
            else
            {
              v11 = PM_GetViewHeightLerpTime(*pm, *(_DWORD *)(*pm + 216), *(_DWORD *)(*pm + 220));
              *(_DWORD *)(*pm + 212) = *(_DWORD *)(pm + 4) - (int)((long double)v12 * 0.0099999998 * (long double)v11);
              if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 828) )
              {
                sub_223F5(v12, (int)&unk_815A0, &v10);
              }
              else if ( *(_DWORD *)(*pm + 216) == *(_DWORD *)(*pm + 832) )
              {
                if ( *(_DWORD *)(*pm + 220) )
                  sub_223F5(v12, (int)&unk_814A0, &v10);
                else
                  sub_223F5(v12, (int)&unk_81680, &v10);
              }
              else
              {
                sub_223F5(v12, (int)&unk_81520, &v10);
              }
              *(float *)(*pm + 224) = v10;
            }
          }
        }
        else if ( *(float *)(*pm + 208) != (long double)*(int *)(*pm + 204) )
        {
          *(_DWORD *)(*pm + 212) = *(_DWORD *)(pm + 4);
          if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 828) )
          {
            *(_DWORD *)(*pm + 220) = 1;
            if ( *(float *)(*pm + 208) <= (long double)*(int *)(*pm + 832) )
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 828);
            else
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 832);
          }
          else if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 832) )
          {
            *(_DWORD *)(*pm + 220) = *(float *)(*pm + 208) > (long double)*(int *)(*pm + 204);
            *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 832);
          }
          else if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 836) )
          {
            *(_DWORD *)(*pm + 220) = 0;
            if ( (long double)*(int *)(*pm + 832) <= *(float *)(*pm + 208) )
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 836);
            else
              *(_DWORD *)(*pm + 216) = *(_DWORD *)(*pm + 832);
          }
        }
      }
      else
      {
        *(_DWORD *)(*pm + 212) = 0;
        if ( (long double)*(int *)(*pm + 204) <= *(float *)(*pm + 208) )
        {
          *(float *)(*pm + 208) = *(float *)(*pm + 208) - *(float *)&pml[9] * 180.0;
          if ( (long double)*(int *)(*pm + 204) >= *(float *)(*pm + 208) )
            *(float *)(*pm + 208) = (float)*(int *)(*pm + 204);
        }
        else
        {
          *(float *)(*pm + 208) = *(float *)&pml[9] * 180.0 + *(float *)(*pm + 208);
          if ( *(float *)(*pm + 208) >= (long double)*(int *)(*pm + 204) )
            *(float *)(*pm + 208) = (float)*(int *)(*pm + 204);
        }
      }
    }
  }
  else if ( *(_DWORD *)(*pm + 4) == 4 )
  {
    *(_DWORD *)(*pm + 208) = 0;
  }
  else
  {
    *(float *)(*pm + 208) = (float)*(int *)(*pm + 204);
  }
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 14C90: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);
// 15650: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);

//----- (000232C4) --------------------------------------------------------
void sub_232C4()
{
  int v0; // eax
  int v1; // edx
  unsigned int v2; // eax
  long double v3; // fst7
  int v4; // esi
  int v5; // [esp+40h] [ebp-88h] BYREF
  int v6; // [esp+44h] [ebp-84h]
  float v7; // [esp+48h] [ebp-80h]
  float v8; // [esp+5Ch] [ebp-6Ch]
  int v9[2]; // [esp+60h] [ebp-68h] BYREF
  float v10; // [esp+68h] [ebp-60h]
  int v11; // [esp+7Ch] [ebp-4Ch]
  float v12; // [esp+80h] [ebp-48h] BYREF
  int v13; // [esp+84h] [ebp-44h]
  int v14; // [esp+88h] [ebp-40h]
  float v15; // [esp+8Ch] [ebp-3Ch]
  int v16; // [esp+90h] [ebp-38h] BYREF
  char v17; // [esp+AEh] [ebp-1Ah]
  char v18; // [esp+AFh] [ebp-19h]
  _BOOL4 v19; // [esp+B8h] [ebp-10h]
  int v20; // [esp+BCh] [ebp-Ch]

  *(_DWORD *)(pm + 232) = 0;
  if ( *(_DWORD *)(*pm + 4) == 4 )
  {
    *(_DWORD *)(pm + 192) = -1056964608;
    *(_DWORD *)(pm + 196) = -1056964608;
    *(_DWORD *)(pm + 200) = -1056964608;
    *(_DWORD *)(pm + 204) = 1090519040;
    *(_DWORD *)(pm + 208) = 1090519040;
    *(_DWORD *)(pm + 212) = 1098907648;
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
    if ( (*(_BYTE *)(pm + 9) & 0x40) != 0 )
    {
      *(_BYTE *)(pm + 9) &= 0xBFu;
      BG_AddPredictableEventToPlayerstate(140, 0, *pm);
    }
    *(_DWORD *)(pm + 236) = *(_DWORD *)(pm + 244);
    *(_DWORD *)(*pm + 128) |= 0x10u;
    *(_DWORD *)(*pm + 204) = 0;
    *(_DWORD *)(*pm + 208) = 0;
    return;
  }
  v20 = *(_DWORD *)(*pm + 12) & 1;
  v19 = (*(_DWORD *)(*pm + 12) & 3) == 0;
  *(_DWORD *)(pm + 192) = *(_DWORD *)(*pm + 804);
  *(_DWORD *)(pm + 196) = *(_DWORD *)(*pm + 808);
  *(_DWORD *)(pm + 204) = *(_DWORD *)(*pm + 816);
  *(_DWORD *)(pm + 208) = *(_DWORD *)(*pm + 820);
  *(_DWORD *)(pm + 200) = *(_DWORD *)(*pm + 812);
  if ( *(int *)(*pm + 4) > 5 )
  {
    *(_DWORD *)(pm + 212) = *(_DWORD *)(*pm + 824);
    *(_DWORD *)(*pm + 204) = *(_DWORD *)(*pm + 840);
    if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
      *(_DWORD *)(pm + 236) = *(_DWORD *)(pm + 240);
    else
      *(_DWORD *)(pm + 236) = *(_DWORD *)(pm + 244);
    *(_DWORD *)(*pm + 128) |= 0x10u;
    sub_226A6();
    return;
  }
  if ( (*(_WORD *)(*pm + 128) & 0xC000) != 0 )
  {
    if ( (*(_DWORD *)(*pm + 128) & 0x4000) != 0 && *(__int16 *)(*pm + 128) >= 0 )
    {
      *(_DWORD *)(*pm + 12) |= 1u;
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
    }
    else if ( *(__int16 *)(*pm + 128) >= 0 || (*(_DWORD *)(*pm + 128) & 0x4000) != 0 )
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
    }
    else
    {
      *(_DWORD *)(*pm + 12) |= 2u;
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
    }
    goto LABEL_51;
  }
  if ( (*(_DWORD *)(*pm + 12) & 0x4000) == 0 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 && (*(_BYTE *)(pm + 9) & 0xC0) != 0 )
    {
      *(_BYTE *)(pm + 9) &= 0x3Fu;
      BG_AddPredictableEventToPlayerstate(140, 0, *pm);
    }
    if ( (*(_BYTE *)(pm + 9) & 0x40) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0
        || *(_DWORD *)(*pm + 84) != 1023
        && BG_CheckProne(
             *(_DWORD *)(*pm + 172),
             *pm + 20,
             *(_DWORD *)(pm + 204),
             1106247680,
             *(float *)(*pm + 196),
             *pm + 964,
             *pm + 968,
             *pm + 972,
             0,
             *(_DWORD *)(*pm + 84) != 1023,
             0,
             *(_DWORD *)(pm + 244),
             *(_DWORD *)(pm + 240),
             0,
             60.0) )
      {
        *(_DWORD *)(*pm + 12) |= 1u;
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
      }
      else if ( *(_DWORD *)(*pm + 84) != 1023 )
      {
        *(_DWORD *)(*pm + 12) |= 0x8000u;
        if ( (*(_BYTE *)(pm + 9) & 2) == 0 )
        {
          if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
            BG_AddPredictableEventToPlayerstate(141, 0, *pm);
          else
            BG_AddPredictableEventToPlayerstate(140, 0, *pm);
        }
      }
      goto LABEL_51;
    }
    if ( (*(_BYTE *)(pm + 9) & 0x80) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) == 0 )
      {
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_51;
      }
      *(_DWORD *)(pm + 212) = 1112014848;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 244))(
        &v12,
        *pm + 20,
        pm + 192,
        pm + 204,
        *pm + 20,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v17 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_51;
      }
      if ( (*(_BYTE *)(pm + 9) & 2) != 0 )
        goto LABEL_51;
    }
    else
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) == 0 )
      {
        if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
        {
          *(_DWORD *)(pm + 212) = *(_DWORD *)(*pm + 824);
          (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 244))(
            &v12,
            *pm + 20,
            pm + 192,
            pm + 204,
            *pm + 20,
            *(_DWORD *)(*pm + 172),
            *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
          if ( v17 )
          {
            if ( (*(_BYTE *)(pm + 9) & 2) == 0 )
              BG_AddPredictableEventToPlayerstate(141, 0, *pm);
          }
          else
          {
            *(_DWORD *)(*pm + 12) &= 0xFFFFFFFD;
          }
        }
        goto LABEL_51;
      }
      *(_DWORD *)(pm + 212) = *(_DWORD *)(*pm + 824);
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 244))(
        &v12,
        *pm + 20,
        pm + 192,
        pm + 204,
        *pm + 20,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v17 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFC;
        goto LABEL_51;
      }
      *(_DWORD *)(pm + 212) = 1112014848;
      (*(void (__cdecl **)(float *, int, int, int, int, _DWORD, unsigned int))(pm + 244))(
        &v12,
        *pm + 20,
        pm + 192,
        pm + 204,
        *pm + 20,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( !v17 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFFE;
        *(_DWORD *)(*pm + 12) |= 2u;
        goto LABEL_51;
      }
      if ( (*(_BYTE *)(pm + 9) & 2) != 0 )
        goto LABEL_51;
    }
    BG_AddPredictableEventToPlayerstate(142, 0, *pm);
  }
LABEL_51:
  if ( !*(_DWORD *)(*pm + 212) )
  {
    if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
    {
      if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 836) )
      {
        *(_DWORD *)(*pm + 204) = *(_DWORD *)(*pm + 832);
      }
      else
      {
        if ( g_debugProneCheck[3] == 2 )
          BG_CheckProne(
            *(_DWORD *)(*pm + 172),
            *pm + 20,
            *(_DWORD *)(pm + 204),
            1106247680,
            *(float *)(*pm + 196),
            0,
            0,
            0,
            0,
            *(_DWORD *)(*pm + 84) != 1023,
            0,
            *(_DWORD *)(pm + 244),
            *(_DWORD *)(pm + 240),
            0,
            60.0);
        if ( *(_DWORD *)(*pm + 204) != *(_DWORD *)(*pm + 828) )
        {
          *(_DWORD *)(*pm + 204) = *(_DWORD *)(*pm + 828);
          *(_DWORD *)(pm + 232) = 1;
          BG_PlayAnim(*pm, 0, 2, 0, 0, 1, 1);
          *(_DWORD *)(*pm + 12) |= 0x2000u;
          *(_DWORD *)(*pm + 16) = 1800;
        }
      }
    }
    else if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 828) )
    {
      *(_DWORD *)(*pm + 204) = *(_DWORD *)(*pm + 832);
      *(_DWORD *)(pm + 232) = 1;
      BG_PlayAnim(*pm, 0, 2, 0, 0, 1, 1);
    }
    else
    {
      if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
        v0 = *(_DWORD *)(*pm + 832);
      else
        v0 = *(_DWORD *)(*pm + 836);
      *(_DWORD *)(*pm + 204) = v0;
    }
  }
  sub_226A6();
  v11 = PM_GetEffectiveStance(*pm);
  if ( v11 == 1 )
  {
    *(_DWORD *)(pm + 212) = 1106247680;
    *(_DWORD *)(*pm + 128) |= 0x40u;
    *(_DWORD *)(*pm + 128) &= 0xFFFFFFDF;
  }
  else
  {
    if ( v11 == 2 )
    {
      *(_DWORD *)(pm + 212) = 1112014848;
      *(_DWORD *)(*pm + 128) |= 0x20u;
      v1 = *pm;
      v2 = *(_DWORD *)(*pm + 128) & 0xFFFFFFBF;
    }
    else
    {
      *(_DWORD *)(pm + 212) = *(_DWORD *)(*pm + 824);
      v1 = *pm;
      v2 = *(_DWORD *)(*pm + 128) & 0xFFFFFF9F;
    }
    *(_DWORD *)(v1 + 128) = v2;
  }
  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    *(_DWORD *)(pm + 236) = *(_DWORD *)(pm + 240);
    *(_DWORD *)(*pm + 128) |= 0x10u;
    if ( !v20 )
    {
      if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
        PM_ClearAimDownSightFlag();
      }
      v5 = *(_DWORD *)(*pm + 20);
      v6 = *(_DWORD *)(*pm + 24);
      v7 = *(float *)(*pm + 28);
      v7 = v7 + 10.0;
      (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, unsigned int))(pm + 240))(
        &v12,
        *pm + 20,
        pm + 192,
        pm + 204,
        &v5,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      v5 = v13;
      v6 = v14;
      v7 = v15;
      (*(void (__cdecl **)(float *, int *, int, int, int, _DWORD, unsigned int))(pm + 240))(
        &v12,
        &v5,
        pm + 192,
        pm + 204,
        *pm + 20,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      *(_DWORD *)(*pm + 20) = v13;
      *(_DWORD *)(*pm + 24) = v14;
      *(float *)(*pm + 28) = v15;
      *(_DWORD *)(*pm + 872) = *(_DWORD *)(*pm + 196);
      v9[0] = *(_DWORD *)(*pm + 20);
      v9[1] = *(_DWORD *)(*pm + 24);
      v10 = *(float *)(*pm + 28);
      v3 = v10 - 0.25;
      v10 = v3;
      (*(void (__cdecl **)(float *, int, int, int, int *, _DWORD, unsigned int))(pm + 240))(
        &v12,
        *pm + 20,
        pm + 192,
        pm + 204,
        v9,
        *(_DWORD *)(*pm + 172),
        *(_DWORD *)(pm + 52) & 0xFDFFFFFF);
      if ( v18 || (v3 = v12, v12 >= 1.0) )
      {
        *(_DWORD *)(*pm + 876) = 0;
      }
      else
      {
        v4 = *pm;
        PitchForYawOnNormal(*(float *)(*pm + 872), (int)&v16);
        *(float *)(v4 + 876) = v3;
      }
      AngleDelta(*(float *)(*pm + 876), *(float *)(*pm + 192));
      v8 = v3;
      if ( v8 >= -45.0 )
      {
        if ( v8 <= 45.0 )
          *(_DWORD *)(*pm + 880) = *(_DWORD *)(*pm + 876);
        else
          *(float *)(*pm + 880) = *(float *)(*pm + 192) + 45.0;
      }
      else
      {
        *(float *)(*pm + 880) = *(float *)(*pm + 192) - 45.0;
      }
    }
  }
  else
  {
    *(_DWORD *)(pm + 236) = *(_DWORD *)(pm + 244);
    *(_DWORD *)(*pm + 128) |= 0x10u;
  }
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 139B0: using guessed type _DWORD __cdecl BG_PlayAnim(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13FD0: using guessed type int PM_ClearAimDownSightFlag(void);

//----- (000246D3) --------------------------------------------------------
char __cdecl PM_FootstepEvent(char a1, char a2, int a3)
{
  char v3; // dl
  int v4; // eax
  int v5; // eax
  float v7[12]; // [esp+20h] [ebp-78h] BYREF
  float v8[4]; // [esp+50h] [ebp-48h] BYREF
  float v9; // [esp+60h] [ebp-38h] BYREF
  float v10; // [esp+64h] [ebp-34h]
  float v11; // [esp+68h] [ebp-30h]
  float v12; // [esp+70h] [ebp-28h] BYREF
  float v13; // [esp+74h] [ebp-24h]
  float v14; // [esp+78h] [ebp-20h]
  int v15; // [esp+84h] [ebp-14h]
  unsigned int v16; // [esp+88h] [ebp-10h]
  int v17; // [esp+8Ch] [ebp-Ch]

  v3 = (a2 + 64) ^ (a1 + 64);
  LOBYTE(v4) = v3 & 0x80;
  if ( v3 >= 0 )
    return v4;
  if ( *(_BYTE *)(pm + 217) )
  {
    if ( *(_BYTE *)(pm + 217) == 1 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
      {
LABEL_16:
        LOBYTE(v4) = PM_AddEvent(67);
        return v4;
      }
      if ( (*(_BYTE *)(*pm + 12) & 0x80) == 0 && *(float *)(*pm + 64) == 0.0 )
      {
LABEL_19:
        LOBYTE(v4) = PM_AddEvent(21);
        return v4;
      }
    }
    else
    {
      LOBYTE(v4) = pm;
      if ( *(_BYTE *)(pm + 217) != 2 )
        return v4;
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
        goto LABEL_16;
      if ( (*(_BYTE *)(*pm + 12) & 0x80) == 0 && *(float *)(*pm + 64) == 0.0 )
        goto LABEL_19;
    }
    LOBYTE(v4) = PM_AddEvent(44);
    return v4;
  }
  v4 = *pm;
  if ( *(_DWORD *)(*pm + 84) == 1023 )
  {
    if ( a3 )
    {
      v4 = *(_DWORD *)(*pm + 12) & 0x10;
      if ( v4 )
      {
        v12 = *(float *)(pm + 192);
        v13 = *(float *)(pm + 196);
        v12 = v12 + 6.0;
        v13 = v13 + 6.0;
        v14 = 8.0;
        v9 = *(float *)(pm + 204);
        v10 = *(float *)(pm + 208);
        v11 = *(float *)(pm + 212);
        v9 = v9 - 6.0;
        v10 = v10 - 6.0;
        if ( v11 < 8.0 )
          v11 = v14;
        v16 = *(_DWORD *)(pm + 52) & 0xFDFEFFFF;
        v15 = -1040711680;
        v8[0] = *(float *)(*pm + 88) * -31.0 + *(float *)(*pm + 20);
        v8[1] = *(float *)(*pm + 92) * -31.0 + *(float *)(*pm + 24);
        v8[2] = *(float *)(*pm + 96) * -31.0 + *(float *)(*pm + 28);
        PM_trace(v7, *pm + 20, &v12, &v9, v8, *(_DWORD *)(*pm + 172), v16);
        v17 = (LODWORD(v7[7]) & 0x1F00000) >> 20;
        if ( v7[0] == 1.0 || !v17 )
          v17 = 13;
        LOBYTE(v4) = PM_AddEvent(v17 + 1);
      }
    }
  }
  else if ( a3 )
  {
    v5 = sub_2105C(*(_DWORD *)(*pm + 12));
    LOBYTE(v4) = PM_AddEvent(v5);
  }
  return v4;
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00024A5A) --------------------------------------------------------
_BOOL4 PM_ShouldMakeFootsteps()
{
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(*pm + 12) & 0x80;
  v3 = PM_GetEffectiveStance(*pm);
  if ( v3 == 1 || v3 == 2 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x40) == 0 )
    return !v2;
  return !v2;
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);

//----- (00024AE8) --------------------------------------------------------
void sub_24AE8()
{
  int v0; // esi
  long double v1; // fst7
  long double v2; // fst6
  long double v3; // fst6
  int v4; // [esp+1Ch] [ebp-3Ch]
  float v5; // [esp+28h] [ebp-30h]
  int v6; // [esp+34h] [ebp-24h]
  int v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+38h] [ebp-20h]
  float v10; // [esp+3Ch] [ebp-1Ch]
  float v11; // [esp+3Ch] [ebp-1Ch]
  float v12; // [esp+3Ch] [ebp-1Ch]
  int v13; // [esp+40h] [ebp-18h]
  int v14; // [esp+44h] [ebp-14h]
  int v15; // [esp+48h] [ebp-10h]
  int v16; // [esp+48h] [ebp-10h]
  float v17; // [esp+4Ch] [ebp-Ch]
  float v18; // [esp+4Ch] [ebp-Ch]

  v6 = -1;
  if ( *(int *)(*pm + 4) <= 5 )
  {
    v0 = pm;
    *(float *)(v0 + 220) = sqrt(*(float *)(*pm + 32) * *(float *)(*pm + 32) + *(float *)(*pm + 36)
                                                                            * *(float *)(*pm + 36));
    if ( (*(_WORD *)(*pm + 128) & 0xC000) != 0 )
    {
      if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
      {
        BG_AnimScriptAnimation(*pm, 3, 3, 1);
        return;
      }
      if ( (*(_DWORD *)(*pm + 12) & 2) != 0 )
      {
        BG_AnimScriptAnimation(*pm, 3, 2, 1);
        return;
      }
      goto LABEL_33;
    }
    v13 = PM_GetEffectiveStance(*pm);
    if ( *(_DWORD *)(*pm + 84) != 1023 || *(_DWORD *)(*pm + 4) == 1 )
      goto LABEL_21;
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      if ( *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 100) < pm_ladderJumpTime )
        return;
      v5 = *(float *)(*pm + 40);
      v10 = 0.5 * 1.5 * 127.0;
      if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 64) != 0.0 )
        v17 = v5 / (v10 * *(float *)(*pm + 844)) * 0.34999999;
      else
        v17 = v5 / (v10 * *(float *)(*pm + 848)) * 0.44999999;
      if ( v5 < 0.0 )
        v6 = BG_AnimScriptAnimation(*pm, 3, 17, 1);
      else
        v6 = BG_AnimScriptAnimation(*pm, 3, 16, 1);
      v15 = *(_DWORD *)(*pm + 8);
      *(_DWORD *)(*pm + 8) = (unsigned __int8)(int)((long double)v15 + (long double)(int)pml[10] * v17);
      PM_FootstepEvent(v15, *(_DWORD *)(*pm + 8), 1);
    }
    if ( v13 != (*(_DWORD *)(*pm + 12) & 3) )
    {
LABEL_21:
      v4 = 0;
      if ( (*(_BYTE *)(*pm + 12) & 0x80) != 0 || *(float *)(*pm + 64) != 0.0 )
        v4 = 1;
      if ( *(float *)(pm + 220) < 10.0 || *(_DWORD *)(*pm + 4) == 1 )
      {
        if ( *(float *)(pm + 220) < 1.0 )
          *(_DWORD *)(*pm + 8) = 0;
        if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 828) )
        {
          v6 = BG_AnimScriptAnimation(*pm, 3, 3, 1);
        }
        else if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 832) )
        {
          v6 = BG_AnimScriptAnimation(*pm, 3, 2, 1);
        }
        if ( v6 < 0 )
        {
LABEL_33:
          BG_AnimScriptAnimation(*pm, 3, 1, 1);
          return;
        }
      }
      else
      {
        v11 = (float)*(int *)(*pm + 68);
        if ( *(_BYTE *)(pm + 24) )
        {
          if ( *(_BYTE *)(pm + 25) )
          {
            v11 = ((*(float *)(*pm + 860) - 1.0) * 0.75 + 1.0 + 1.0) * 0.5 * v11;
            if ( *(char *)(pm + 24) < 0 )
              v11 = (*(float *)(*pm + 864) + 1.0) * 0.5 * v11;
          }
          else if ( *(char *)(pm + 24) < 0 )
          {
            v11 = v11 * *(float *)(*pm + 864);
          }
          BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 8, 0, 1);
        }
        else if ( *(_BYTE *)(pm + 25) )
        {
          v11 = ((*(float *)(*pm + 860) - 1.0) * 0.75 + 1.0) * v11;
          if ( *(char *)(pm + 25) <= 0 )
            BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 8, 1, 1);
          else
            BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 8, 2, 1);
        }
        if ( v4 )
          v1 = v11 * *(float *)(*pm + 844);
        else
          v1 = v11 * *(float *)(*pm + 848);
        v12 = v1;
        v8 = sub_2251C(*(_DWORD *)(*pm + 832), *(_DWORD *)(*pm + 828));
        if ( v8 == 0.0 )
        {
          v9 = sub_2251C(*(_DWORD *)(*pm + 828), *(_DWORD *)(*pm + 832));
          if ( v9 == 0.0 )
          {
            if ( v13 == 1 )
            {
              v12 = v12 * *(float *)(*pm + 852);
            }
            else if ( v13 == 2 )
            {
              v12 = v12 * *(float *)(*pm + 856);
            }
          }
          else
          {
            v12 = (*(float *)(*pm + 856) * v9 + (1.0 - v9) * *(float *)(*pm + 852)) * v12;
          }
        }
        else
        {
          v12 = (*(float *)(*pm + 852) * v8 + (1.0 - v8) * *(float *)(*pm + 856)) * v12;
        }
        if ( v13 == 1 )
        {
          if ( v4 )
            v2 = 0.23999999;
          else
            v2 = 0.25;
          v18 = *(float *)(pm + 220) / v12 * v2;
          if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
            v7 = BG_AnimScriptAnimation(*pm, 3, 9, 1);
          else
            v7 = BG_AnimScriptAnimation(*pm, 3, 8, 1);
        }
        else if ( v13 == 2 )
        {
          if ( v4 )
            v3 = 0.315;
          else
            v3 = 0.34;
          v18 = *(float *)(pm + 220) / v12 * v3;
          if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
          {
            if ( v4 )
              v7 = BG_AnimScriptAnimation(*pm, 3, 7, 1);
            else
              v7 = BG_AnimScriptAnimation(*pm, 3, 13, 1);
          }
          else if ( v4 )
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 6, 1);
          }
          else
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 12, 1);
          }
        }
        else if ( (*(_DWORD *)(*pm + 12) & 0x40) != 0 )
        {
          if ( v4 )
          {
            v18 = *(float *)(pm + 220) / v12 * 0.32499999;
            v7 = BG_AnimScriptAnimation(*pm, 3, 5, 1);
          }
          else
          {
            v18 = *(float *)(pm + 220) / v12 * 0.36000001;
            v7 = BG_AnimScriptAnimation(*pm, 3, 11, 1);
          }
        }
        else if ( v4 )
        {
          v18 = *(float *)(pm + 220) / v12 * 0.30500001;
          v7 = BG_AnimScriptAnimation(*pm, 3, 4, 1);
        }
        else
        {
          v18 = *(float *)(pm + 220) / v12 * 0.33500001;
          v7 = BG_AnimScriptAnimation(*pm, 3, 10, 1);
        }
        v14 = PM_ShouldMakeFootsteps();
        v16 = *(_DWORD *)(*pm + 8);
        *(_DWORD *)(*pm + 8) = (unsigned __int8)(int)((long double)v16 + (long double)(int)pml[10] * v18);
        if ( *(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25) )
        {
          if ( v7 < 0 )
            BG_AnimScriptAnimation(*pm, 3, 1, 1);
          PM_FootstepEvent(v16, *(_DWORD *)(*pm + 8), v14);
        }
        else if ( *(float *)(pm + 220) <= 120.0 )
        {
          if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 828) )
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 3, 1);
          }
          else if ( *(_DWORD *)(*pm + 204) == *(_DWORD *)(*pm + 832) )
          {
            v7 = BG_AnimScriptAnimation(*pm, 3, 2, 1);
          }
          if ( v7 < 0 )
            goto LABEL_33;
        }
      }
    }
  }
}
// 13350: using guessed type _DWORD __cdecl PM_FootstepEvent(char, char, _DWORD);
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// 151D0: using guessed type _DWORD __cdecl BG_AnimScriptAnimation(_DWORD, _DWORD, _DWORD, _DWORD);
// 156E0: using guessed type int PM_ShouldMakeFootsteps(void);

//----- (00025816) --------------------------------------------------------
int sub_25816()
{
  int result; // eax
  float v1[2]; // [esp+30h] [ebp-68h] BYREF
  float v2; // [esp+38h] [ebp-60h]
  float v3[4]; // [esp+40h] [ebp-58h] BYREF
  char v4[56]; // [esp+50h] [ebp-48h] BYREF
  int v5; // [esp+88h] [ebp-10h]
  float v6; // [esp+8Ch] [ebp-Ch]

  if ( (long double)bg_foliagesnd_minspeed[3] <= *(float *)(pm + 220) )
  {
    v6 = (*(float *)(pm + 220) - (long double)bg_foliagesnd_minspeed[3])
       / (long double)(bg_foliagesnd_maxspeed[3] - bg_foliagesnd_minspeed[3]);
    if ( v6 > 1.0 )
      v6 = 1.0;
    v5 = (int)((long double)(bg_foliagesnd_fastinterval[3] - bg_foliagesnd_slowinterval[3]) * v6
             + (long double)bg_foliagesnd_slowinterval[3]);
    result = pm;
    if ( v5 + *(_DWORD *)(*pm + 56) < *(_DWORD *)(pm + 4) )
    {
      v3[0] = *(float *)(pm + 192) * 0.75;
      v3[1] = *(float *)(pm + 196) * 0.75;
      v3[2] = *(float *)(pm + 200) * 0.75;
      v1[0] = *(float *)(pm + 204) * 0.75;
      v1[1] = *(float *)(pm + 208) * 0.75;
      v2 = *(float *)(pm + 212) * 0.75;
      v2 = *(float *)(pm + 212) * 0.89999998;
      result = PM_trace(v4, *pm + 20, v3, v1, *pm + 20, *(_DWORD *)(*pm + 172), 2);
      if ( v4[47] )
      {
        PM_AddEvent(139);
        result = *(_DWORD *)(pm + 4);
        *(_DWORD *)(*pm + 56) = result;
      }
    }
  }
  else
  {
    result = pm;
    if ( bg_foliagesnd_resetinterval[3] + *(_DWORD *)(*pm + 56) < *(_DWORD *)(pm + 4) )
    {
      result = *pm;
      *(_DWORD *)(*pm + 56) = 0;
    }
  }
  return result;
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00025A7F) --------------------------------------------------------
_DWORD *sub_25A7F()
{
  _DWORD *result; // eax

  if ( !pml[33] && *(_BYTE *)(pm + 217) )
    PM_AddEvent(144);
  result = pml;
  if ( pml[33] )
  {
    result = (_DWORD *)pm;
    if ( !*(_BYTE *)(pm + 217) )
      result = (_DWORD *)PM_AddEvent(145);
  }
  return result;
}
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00025AEF) --------------------------------------------------------
int sub_25AEF()
{
  int result; // eax

  if ( *(_DWORD *)(*pm + 16) )
  {
    if ( pml[10] < *(_DWORD *)(*pm + 16) )
    {
      *(_DWORD *)(*pm + 16) -= pml[10];
    }
    else
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDCFF;
      *(_DWORD *)(*pm + 16) = 0;
    }
  }
  if ( *(int *)(*pm + 108) > 0 )
  {
    *(_DWORD *)(*pm + 108) -= pml[10];
    if ( *(int *)(*pm + 108) < 0 )
      *(_DWORD *)(*pm + 108) = 0;
  }
  result = *pm;
  if ( *(int *)(*pm + 116) > 0 )
  {
    *(_DWORD *)(*pm + 116) -= pml[10];
    result = *pm;
    if ( *(int *)(*pm + 116) < 0 )
    {
      result = *pm;
      *(_DWORD *)(*pm + 116) = 0;
    }
  }
  return result;
}

//----- (00025C2E) --------------------------------------------------------
void __cdecl PM_UpdateLean(int a1, int a2, void (__cdecl *a3)(float *, int *, int *, int *, int *, _DWORD, int))
{
  long double v3; // fst7
  float v4; // [esp+34h] [ebp-94h]
  float v5; // [esp+34h] [ebp-94h]
  float v6; // [esp+3Ch] [ebp-8Ch]
  float v7[14]; // [esp+40h] [ebp-88h] BYREF
  float v8; // [esp+78h] [ebp-50h]
  int v9; // [esp+7Ch] [ebp-4Ch]
  int v10[4]; // [esp+80h] [ebp-48h] BYREF
  int v11[4]; // [esp+90h] [ebp-38h] BYREF
  int v12[4]; // [esp+A0h] [ebp-28h] BYREF
  int v13; // [esp+B0h] [ebp-18h] BYREF
  int v14; // [esp+B4h] [ebp-14h]
  float v15; // [esp+B8h] [ebp-10h]

  v9 = 0;
  v8 = 0.0;
  if ( (*(_BYTE *)(a2 + 5) & 0x30) != 0
    && (*(_DWORD *)(a1 + 12) & 0x4000) == 0
    && *(int *)(a1 + 4) <= 5
    && (*(_DWORD *)(a1 + 84) != 1023 || *(_DWORD *)(a1 + 4) == 1) )
  {
    if ( (*(_BYTE *)(a2 + 5) & 0x10) != 0 )
      --v9;
    if ( (*(_BYTE *)(a2 + 5) & 0x20) != 0 )
      ++v9;
  }
  if ( (*(_WORD *)(a1 + 128) & 0xC000) != 0 )
    v9 = 0;
  if ( PM_GetEffectiveStance(a1) == 1 )
    v6 = 0.25;
  else
    v6 = 0.5;
  v8 = *(float *)(a1 + 64);
  if ( v9 )
  {
    if ( v9 <= 0 )
    {
      if ( v8 > -v6 )
        v8 = v8 - (long double)(int)pml[10] / 350.0 * v6;
      if ( -v6 > (long double)v8 )
        LODWORD(v8) = LODWORD(v6) ^ 0x80000000;
    }
    else
    {
      if ( v6 > (long double)v8 )
        v8 = (long double)(int)pml[10] / 350.0 * v6 + v8;
      if ( v8 > (long double)v6 )
        v8 = v6;
    }
  }
  else if ( v8 <= 0.0 )
  {
    if ( v8 < 0.0 )
    {
      v8 = (long double)(int)pml[10] / 280.0 * v6 + v8;
      if ( v8 > 0.0 )
        v8 = 0.0;
    }
  }
  else
  {
    v8 = v8 - (long double)(int)pml[10] / 280.0 * v6;
    if ( v8 < 0.0 )
      v8 = 0.0;
  }
  *(float *)(a1 + 64) = v8;
  if ( *(float *)(a1 + 64) != 0.0 )
  {
    v4 = (float)sub_28B8A(*(float *)(a1 + 64));
    v13 = *(_DWORD *)(a1 + 20);
    v14 = *(_DWORD *)(a1 + 24);
    v15 = *(float *)(a1 + 28);
    v3 = v15 + *(float *)(a1 + 208);
    v15 = v3;
    v12[0] = v13;
    v12[1] = v14;
    *(float *)&v12[2] = v15;
    AddLeanToPosition((int)v12, *(_DWORD *)(a1 + 196), v4, 16.0, 20.0);
    v11[0] = -1056964608;
    v11[1] = -1056964608;
    v11[2] = -1056964608;
    v10[0] = 1090519040;
    v10[1] = 1090519040;
    v10[2] = 1090519040;
    a3(v7, &v13, v11, v10, v12, *(_DWORD *)(a1 + 172), 42008593);
    UnGetLeanFraction(v7[0]);
    v5 = v3;
    if ( fabs(*(float *)(a1 + 64)) > v5 )
      *(float *)(a1 + 64) = (long double)sub_28B8A(*(float *)(a1 + 64)) * v5;
  }
}
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);

//----- (00025FF5) --------------------------------------------------------
int __usercall sub_25FF5@<eax>(long double a1@<st0>, int a2, float a3, int a4)
{
  long double v4; // fst7
  float v6; // [esp+0h] [ebp-58h]
  float v7; // [esp+40h] [ebp-18h]
  float v8; // [esp+44h] [ebp-14h]
  float v9; // [esp+48h] [ebp-10h]
  float v10; // [esp+4Ch] [ebp-Ch]
  float v11; // [esp+50h] [ebp-8h]

  AngleDelta(a3, *(float *)(a2 + 196));
  v11 = a1;
  v7 = fabs(v11);
  v9 = v7 / 240.0;
  v4 = a3 - (1.0 - v9) * v11;
  v6 = v4;
  AngleNormalize360Accurate(v6);
  v10 = v4;
  v8 = v9 * 45.0 + (1.0 - v9) * 60.0;
  return BG_CheckProne(
           *(_DWORD *)(a2 + 172),
           a2 + 20,
           *(_DWORD *)(a2 + 816),
           1106247680,
           v10,
           a2 + 964,
           a2 + 968,
           a2 + 972,
           1,
           *(_DWORD *)(a2 + 84) != 1023,
           0,
           a4,
           0,
           0,
           v8);
}

//----- (00026118) --------------------------------------------------------
int __usercall PM_UpdateViewAngles@<eax>(long double a1@<st0>, int a2, int a3, int a4)
{
  int result; // eax
  long double v5; // fst7
  long double v6; // fst6
  long double v7; // fst7
  long double v8; // fst6
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  float v12; // [esp+0h] [ebp-C8h]
  float v13; // [esp+0h] [ebp-C8h]
  float v14; // [esp+0h] [ebp-C8h]
  float v15; // [esp+0h] [ebp-C8h]
  float v16; // [esp+0h] [ebp-C8h]
  float v17; // [esp+0h] [ebp-C8h]
  float v18; // [esp+0h] [ebp-C8h]
  float v19; // [esp+8h] [ebp-C0h]
  float v20; // [esp+Ch] [ebp-BCh]
  float v21[4]; // [esp+50h] [ebp-78h] BYREF
  float v22[4]; // [esp+60h] [ebp-68h] BYREF
  int v23; // [esp+70h] [ebp-58h] BYREF
  float v24; // [esp+74h] [ebp-54h]
  float v25; // [esp+78h] [ebp-50h]
  float v26; // [esp+80h] [ebp-48h]
  float v27; // [esp+84h] [ebp-44h]
  float v28; // [esp+88h] [ebp-40h]
  int v29; // [esp+8Ch] [ebp-3Ch]
  float v30; // [esp+90h] [ebp-38h]
  float v31; // [esp+94h] [ebp-34h]
  _BOOL4 v32; // [esp+98h] [ebp-30h]
  int v33; // [esp+9Ch] [ebp-2Ch]
  float v34; // [esp+A0h] [ebp-28h]
  float v35; // [esp+A4h] [ebp-24h]
  int i; // [esp+A8h] [ebp-20h]
  __int16 v37; // [esp+AEh] [ebp-1Ah]

  result = a2;
  if ( *(_DWORD *)(a2 + 4) != 5 )
  {
    if ( *(int *)(a2 + 4) <= 5 )
    {
      v31 = *(float *)(a2 + 196);
      for ( i = 0; i <= 2; ++i )
      {
        v37 = *(_WORD *)(a2 + 4 * i + 72) + *(_WORD *)(a3 + 4 * i + 8);
        if ( !i )
        {
          if ( v37 <= 16000 )
          {
            if ( v37 < -16000 )
            {
              *(_DWORD *)(a2 + 4 * i + 72) = -16000 - *(_DWORD *)(a3 + 4 * i + 8);
              v37 = -16000;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 4 * i + 72) = 16000 - *(_DWORD *)(a3 + 4 * i + 8);
            v37 = 16000;
          }
        }
        a1 = (long double)v37 * 0.0054931641;
        *(float *)(a2 + 4 * i + 192) = a1;
      }
      v30 = *(float *)(a2 + 196);
      if ( (*(_DWORD *)(a2 + 12) & 0x10) != 0 && *(_DWORD *)(a2 + 84) == 1023 )
      {
        if ( bg_ladder_yawcap[3] )
        {
          v26 = vectoyaw(a2 + 88) + 180.0;
          AngleDelta(v26, *(float *)(a2 + 196));
          v35 = v26;
          if ( v26 > (long double)bg_ladder_yawcap[3] || (a1 = v35, (long double)-bg_ladder_yawcap[3] > v35) )
          {
            if ( v35 <= (long double)bg_ladder_yawcap[3] )
              v35 = (long double)bg_ladder_yawcap[3] + v35;
            else
              v35 = v35 - (long double)bg_ladder_yawcap[3];
            *(_DWORD *)(a2 + 76) += (unsigned __int16)(int)(v35 * 182.04445);
            if ( v35 <= 0.0 )
              a1 = (long double)bg_ladder_yawcap[3] + v26;
            else
              a1 = v26 - (long double)bg_ladder_yawcap[3];
            v12 = a1;
            AngleNormalize360Accurate(v12);
            *(float *)(a2 + 196) = a1;
          }
        }
      }
      if ( (*(_DWORD *)(a2 + 12) & 1) != 0 && (*(_WORD *)(a2 + 128) & 0xC000) == 0 )
      {
        if ( g_debugProneCheck[3] )
        {
          v23 = *(int *)(a2 + 20);
          v24 = *(float *)(a2 + 24);
          v25 = *(float *)(a2 + 28);
          v25 = (long double)*(int *)(a2 + 828) + v25;
          AngleVectors(a2 + 192, v21, 0, 0);
          v22[0] = v21[0] * 18.0 + *(float *)&v23;
          v22[1] = v21[1] * 18.0 + v24;
          v22[2] = v21[2] * 18.0 + v25;
          G_DebugLine(&v23, v22, &colorWhite, 1, 1);
          v20 = *(float *)(a2 + 872) + bg_prone_yawcap[2];
          a1 = *(float *)(a2 + 872) - bg_prone_yawcap[2];
          v19 = a1;
          G_DebugArc((int)&v23, 16.0, v19, v20, (int)&colorWhite, 1, 1);
        }
        v29 = 0;
        AngleDelta(*(float *)(a2 + 872), *(float *)(a2 + 196));
        v35 = a1;
        if ( v35 > (long double)(LODWORD(bg_prone_yawcap[3]) - 5)
          || (v5 = v35, (long double)(5 - LODWORD(bg_prone_yawcap[3])) > v35)
          || (*(_BYTE *)(a3 + 20) || *(_BYTE *)(a3 + 21)) && (v5 = 0.0, v35 != 0.0) )
        {
          v5 = fabs(v35);
          if ( *(float *)&pml[9] * 55.0 <= v5 )
          {
            if ( v35 <= 0.0 )
              v5 = *(float *)&pml[9] * 55.0 + *(float *)(a2 + 872);
            else
              v5 = *(float *)(a2 + 872) - *(float *)&pml[9] * 55.0;
            v34 = v5;
          }
          else
          {
            v34 = *(float *)(a2 + 196);
          }
          v32 = 1;
          while ( !sub_25FF5(v5, a2, v34, a4) )
          {
            if ( !v32 )
              goto LABEL_55;
            AngleDelta(*(float *)(a2 + 872), v34);
            v35 = v5;
            v6 = fabs(v35);
            v32 = v6 > 1.0;
            if ( v6 <= 1.0 )
            {
              v29 = 1;
            }
            else if ( v35 <= 0.0 )
            {
              v35 = -1.0;
            }
            else
            {
              v35 = 1.0;
            }
            v5 = v34 + v35;
            v13 = v5;
            AngleNormalize360Accurate(v13);
            v34 = v5;
          }
          v33 = BG_CheckProne(
                  *(_DWORD *)(a2 + 172),
                  a2 + 20,
                  *(_DWORD *)(a2 + 816),
                  1106247680,
                  *(float *)(a2 + 196),
                  0,
                  0,
                  0,
                  1,
                  *(_DWORD *)(a2 + 84) != 1023,
                  0,
                  a4,
                  0,
                  0,
                  45.0);
          if ( v33 )
          {
            v33 = BG_CheckProne(
                    *(_DWORD *)(a2 + 172),
                    a2 + 20,
                    *(_DWORD *)(a2 + 816),
                    1106247680,
                    v34,
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a2 + 84) != 1023,
                    0,
                    a4,
                    0,
                    0,
                    45.0);
            if ( v33 )
              *(float *)(a2 + 872) = v34;
          }
          if ( !v33 )
            v29 = 1;
        }
LABEL_55:
        AngleDelta(*(float *)(a2 + 872), *(float *)(a2 + 196));
        v35 = v5;
        v7 = 0.0;
        if ( v35 != 0.0 )
        {
          v34 = *(float *)(a2 + 872);
          v32 = 1;
          while ( 1 )
          {
            v33 = BG_CheckProne(
                    *(_DWORD *)(a2 + 172),
                    a2 + 20,
                    *(_DWORD *)(a2 + 816),
                    1106247680,
                    v34,
                    0,
                    0,
                    0,
                    1,
                    *(_DWORD *)(a2 + 84) != 1023,
                    0,
                    a4,
                    0,
                    0,
                    45.0);
            if ( v33 )
            {
              if ( sub_25FF5(v7, a2, v34, a4) )
                break;
            }
            if ( !v32 )
              goto LABEL_67;
            v8 = fabs(v35);
            v32 = v8 > 1.0;
            if ( v8 > 1.0 )
            {
              if ( v35 <= 0.0 )
                v35 = -1.0;
              else
                v35 = 1.0;
            }
            v29 = 1;
            *(_DWORD *)(a2 + 76) += (unsigned __int16)(int)(v35 * 182.04445);
            v7 = *(float *)(a2 + 196) + v35;
            v14 = v7;
            AngleNormalize360Accurate(v14);
            *(float *)(a2 + 196) = v7;
            AngleDelta(*(float *)(a2 + 872), *(float *)(a2 + 196));
            v35 = v7;
            if ( !v33 )
            {
              v7 = v34 + v35;
              v15 = v7;
              AngleNormalize360Accurate(v15);
              v34 = v7;
            }
          }
          *(float *)(a2 + 872) = v34;
        }
LABEL_67:
        if ( v35 > (long double)SLODWORD(bg_prone_yawcap[3])
          || (v9 = v35, (long double)-LODWORD(bg_prone_yawcap[3]) > v35) )
        {
          if ( v35 <= (long double)SLODWORD(bg_prone_yawcap[3]) )
            v35 = (long double)SLODWORD(bg_prone_yawcap[3]) + v35;
          else
            v35 = v35 - (long double)SLODWORD(bg_prone_yawcap[3]);
          *(_DWORD *)(a2 + 76) += (unsigned __int16)(int)(v35 * 182.04445);
          if ( v35 <= 0.0 )
            v9 = (long double)SLODWORD(bg_prone_yawcap[3]) + *(float *)(a2 + 872);
          else
            v9 = *(float *)(a2 + 872) - (long double)SLODWORD(bg_prone_yawcap[3]);
          v16 = v9;
          AngleNormalize360Accurate(v16);
          *(float *)(a2 + 196) = v9;
        }
        if ( v29 )
        {
          *(_DWORD *)(a2 + 12) |= 0x8000u;
          AngleDelta(v31, *(float *)(a2 + 196));
          v28 = v9;
          v9 = fabs(v28);
          if ( v9 <= 1.0 )
          {
            AngleDelta(v30, *(float *)(a2 + 196));
            v27 = v9;
            v9 = 0.0;
            if ( v28 * v27 > 0.0 )
            {
              v28 = v28 * 0.98000002;
              v10 = *(float *)(a2 + 196) + v28;
              v17 = v10;
              AngleNormalize360Accurate(v17);
              *(float *)(a2 + 196) = v10;
              v9 = v28 * 182.04445;
              *(_DWORD *)(a2 + 76) += (unsigned __int16)(int)v9;
            }
          }
        }
        AngleDelta(*(float *)(a2 + 880), *(float *)(a2 + 192));
        v35 = v9;
        if ( v35 > 45.0 || v35 < -45.0 )
        {
          if ( v35 <= 45.0 )
            v35 = v35 + 45.0;
          else
            v35 = v35 - 45.0;
          *(_DWORD *)(a2 + 72) += (unsigned __int16)(int)(v35 * 182.04445);
          if ( v35 <= 0.0 )
            v11 = *(float *)(a2 + 880) + 45.0;
          else
            v11 = *(float *)(a2 + 880) - 45.0;
          v18 = v11;
          AngleNormalize180Accurate(v18);
          *(float *)(a2 + 192) = v11;
        }
      }
      result = a2;
      if ( *(_DWORD *)(a2 + 4) != 3 )
      {
        result = a2;
        if ( *(_DWORD *)(a2 + 4) != 2 )
        {
          result = a2;
          if ( *(_DWORD *)(a2 + 4) != 4 )
            result = PM_UpdateLean(a2, a3, a4);
        }
      }
    }
    else
    {
      v37 = *(_WORD *)(a2 + 76) + *(_WORD *)(a3 + 12);
      if ( *(_DWORD *)(a2 + 248) == 999 )
        *(_DWORD *)(a2 + 248) = (int)((long double)v37 * 0.0054931641);
      result = PM_UpdateLean(a2, a3, a4);
    }
  }
  return result;
}
// 12F80: using guessed type long double __cdecl vectoyaw(_DWORD);
// 13550: using guessed type _DWORD __cdecl PM_UpdateLean(_DWORD, _DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14C20: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00026D80) --------------------------------------------------------
void __usercall PM_UpdatePronePitch(long double a1@<st0>)
{
  int v1; // eax
  long double v2; // fst7
  int v3; // esi
  int v4; // edi
  int v5; // esi
  int v6; // esi
  int v7; // edi
  long double v8; // fst7
  int v9; // esi
  int v10; // [esp+2Ch] [ebp-2Ch]
  int v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+44h] [ebp-14h]
  float v13; // [esp+44h] [ebp-14h]
  float v14; // [esp+48h] [ebp-10h]
  float v15; // [esp+48h] [ebp-10h]

  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    if ( *(_DWORD *)(*pm + 84) == 1023 )
    {
      v11 = *(_DWORD *)(pm + 240);
      v10 = *(_DWORD *)(pm + 244);
      if ( pml[12] )
        v1 = BG_CheckProne(
               *(_DWORD *)(*pm + 172),
               *pm + 20,
               *(_DWORD *)(*pm + 816),
               1106247680,
               *(float *)(*pm + 872),
               *pm + 964,
               *pm + 968,
               *pm + 972,
               1,
               *(_DWORD *)(*pm + 84) != 1023,
               (int)&pml[18],
               v10,
               v11,
               0,
               60.0);
      else
        v1 = BG_CheckProne(
               *(_DWORD *)(*pm + 172),
               *pm + 20,
               *(_DWORD *)(*pm + 816),
               1106247680,
               *(float *)(*pm + 872),
               *pm + 964,
               *pm + 968,
               *pm + 972,
               1,
               *(_DWORD *)(*pm + 84) != 1023,
               0,
               v10,
               v11,
               0,
               60.0);
      if ( !v1 )
      {
        BG_AddPredictableEventToPlayerstate(141, 0, *pm);
        *(_DWORD *)(*pm + 12) |= 0x8000u;
      }
    }
    else if ( pml[12] )
    {
      a1 = *(float *)&pml[20];
      if ( a1 < 0.69999999 )
        BG_AddPredictableEventToPlayerstate(141, 0, *pm);
    }
    if ( pml[12] )
    {
      PitchForYawOnNormal(*(float *)(*pm + 872), (int)&pml[18]);
      v14 = a1;
      AngleDelta(v14, *(float *)(*pm + 876));
    }
    else
    {
      AngleDelta(0.0, *(float *)(*pm + 876));
    }
    v12 = a1;
    v2 = 0.0;
    if ( v12 != 0.0 )
    {
      if ( sub_28B71(v12) <= *(float *)&pml[9] * 70.0 )
      {
        v2 = *(float *)(*pm + 876) + v12;
        *(float *)(*pm + 876) = v2;
      }
      else
      {
        v3 = *pm;
        v4 = *pm;
        v2 = (long double)sub_28B8A(v12) * (*(float *)&pml[9] * 70.0) + *(float *)(v4 + 876);
        *(float *)(v3 + 876) = v2;
      }
      v5 = *pm;
      AngleNormalize180Accurate(*(float *)(*pm + 876));
      *(float *)(v5 + 876) = v2;
    }
    if ( pml[12] )
    {
      PitchForYawOnNormal(*(float *)(*pm + 196), (int)&pml[18]);
      v15 = v2;
      AngleDelta(v15, *(float *)(*pm + 880));
    }
    else
    {
      AngleDelta(0.0, *(float *)(*pm + 880));
    }
    v13 = v2;
    if ( v13 != 0.0 )
    {
      if ( sub_28B71(v13) <= *(float *)&pml[9] * 70.0 )
      {
        v8 = *(float *)(*pm + 880) + v13;
        *(float *)(*pm + 880) = v8;
      }
      else
      {
        v6 = *pm;
        v7 = *pm;
        v8 = (long double)sub_28B8A(v13) * (*(float *)&pml[9] * 70.0) + *(float *)(v7 + 880);
        *(float *)(v6 + 880) = v8;
      }
      v9 = *pm;
      AngleNormalize180Accurate(*(float *)(*pm + 880));
      *(float *)(v9 + 880) = v8;
    }
  }
}
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (000271E1) --------------------------------------------------------
int PM_SetProneMovementOverride()
{
  int result; // eax

  result = *(_DWORD *)(*pm + 12) & 1;
  if ( result )
  {
    result = *(_DWORD *)(*pm + 12) | 0x400;
    *(_DWORD *)(*pm + 12) = result;
  }
  return result;
}

//----- (00027226) --------------------------------------------------------
char PM_UpdatePlayerWalkingFlag()
{
  int v0; // eax

  *(_DWORD *)(*pm + 12) &= 0xFFFFFF7F;
  v0 = *pm;
  if ( *(int *)(*pm + 4) <= 5 )
  {
    LOBYTE(v0) = *(_BYTE *)(pm + 8) & 0x10;
    if ( (_BYTE)v0 )
    {
      v0 = *(_DWORD *)(*pm + 12) & 1;
      if ( !v0 )
      {
        v0 = *(_DWORD *)(*pm + 12) & 0x20;
        if ( v0 )
        {
          v0 = *pm;
          if ( *(_DWORD *)(*pm + 180) != 5 )
          {
            v0 = *pm;
            if ( *(_DWORD *)(*pm + 180) != 7 )
            {
              v0 = *pm;
              if ( *(_DWORD *)(*pm + 180) != 9 )
              {
                v0 = *pm;
                if ( *(_DWORD *)(*pm + 180) != 8 )
                {
                  v0 = *pm;
                  if ( *(_DWORD *)(*pm + 180) != 6 )
                  {
                    v0 = *(_DWORD *)(*pm + 12) | 0x80;
                    *(_DWORD *)(*pm + 12) = v0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v0;
}

//----- (00027330) --------------------------------------------------------
void sub_27330()
{
  int v0; // [esp+20h] [ebp-88h]
  int v1; // [esp+28h] [ebp-80h]
  float v2; // [esp+2Ch] [ebp-7Ch]
  float v3[7]; // [esp+30h] [ebp-78h] BYREF
  int v4; // [esp+4Ch] [ebp-5Ch]
  float v5; // [esp+60h] [ebp-48h] BYREF
  float v6; // [esp+64h] [ebp-44h]
  float v7; // [esp+68h] [ebp-40h]
  float v8; // [esp+70h] [ebp-38h] BYREF
  float v9; // [esp+74h] [ebp-34h]
  float v10; // [esp+78h] [ebp-30h]
  float v11; // [esp+80h] [ebp-28h] BYREF
  float v12; // [esp+84h] [ebp-24h]
  float v13; // [esp+88h] [ebp-20h]
  float v14; // [esp+90h] [ebp-18h] BYREF
  float v15; // [esp+94h] [ebp-14h]
  float v16; // [esp+98h] [ebp-10h]

  if ( !*(_DWORD *)(*pm + 16) || (*(_DWORD *)(*pm + 12) & 0x300) == 0 )
  {
    if ( pml[11] )
      v2 = 8.0;
    else
      v2 = 30.0;
    v1 = (*(_DWORD *)(*pm + 12) >> 4) & 1;
    v0 = 0;
    if ( v1 && *(_DWORD *)(*pm + 84) == 1023 )
      v0 = 1;
    if ( v0 )
    {
      LODWORD(v11) = *(_DWORD *)(*pm + 88) ^ 0x80000000;
      LODWORD(v12) = *(_DWORD *)(*pm + 92) ^ 0x80000000;
      LODWORD(v13) = *(_DWORD *)(*pm + 96) ^ 0x80000000;
    }
    else
    {
      v11 = *(float *)pml;
      v12 = *(float *)&pml[1];
      v13 = 0.0;
      VectorNormalize(&v11);
    }
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
    if ( *(int *)(*pm + 4) > 5 )
    {
      *(_DWORD *)(*pm + 84) = 1023;
      pml[12] = 0;
      pml[13] = 0;
      pml[11] = 0;
      return;
    }
    if ( PM_GetEffectiveStance(*pm) != 1 && *(_DWORD *)(pm + 4) - *(_DWORD *)(*pm + 100) >= pm_ladderJumpTime )
    {
      v8 = *(float *)(pm + 192);
      v9 = *(float *)(pm + 196);
      v8 = v8 + 6.0;
      v9 = v9 + 6.0;
      v10 = 8.0;
      v5 = *(float *)(pm + 204);
      v6 = *(float *)(pm + 208);
      v7 = *(float *)(pm + 212);
      v5 = v5 - 6.0;
      v6 = v6 - 6.0;
      if ( v7 < 8.0 )
        v7 = v10;
      v14 = v11 * v2 + *(float *)(*pm + 20);
      v15 = v12 * v2 + *(float *)(*pm + 24);
      v16 = v13 * v2 + *(float *)(*pm + 28);
      PM_trace(v3, *pm + 20, &v8, &v5, &v14, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
      if ( v3[0] < 1.0 && (v4 & 8) != 0 && (!pml[11] || *(char *)(pm + 24) > 0) )
      {
        *(float *)(*pm + 88) = v3[4];
        *(float *)(*pm + 92) = v3[5];
        *(float *)(*pm + 96) = v3[6];
        if ( v1 )
        {
          *(_DWORD *)(*pm + 12) |= 0x10u;
          return;
        }
        LODWORD(v11) = *(_DWORD *)(*pm + 88) ^ 0x80000000;
        LODWORD(v12) = *(_DWORD *)(*pm + 92) ^ 0x80000000;
        LODWORD(v13) = *(_DWORD *)(*pm + 96) ^ 0x80000000;
        v14 = v11 * v2 + *(float *)(*pm + 20);
        v15 = v12 * v2 + *(float *)(*pm + 24);
        v16 = v13 * v2 + *(float *)(*pm + 28);
        PM_trace(v3, *pm + 20, &v8, &v5, &v14, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
        if ( v3[0] < 1.0 && (v4 & 8) != 0 )
        {
          *(_DWORD *)(*pm + 12) |= 0x10u;
          return;
        }
      }
      if ( v0 )
        BG_AnimScriptEvent(*pm, 3, 0, 1);
    }
  }
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00027846) --------------------------------------------------------
int PM_LadderMove()
{
  int result; // eax
  long double v1; // fst7
  int v2; // [esp+2Ch] [ebp-6Ch]
  int v3; // [esp+34h] [ebp-64h]
  float v4; // [esp+38h] [ebp-60h]
  float v5; // [esp+3Ch] [ebp-5Ch]
  float v6; // [esp+3Ch] [ebp-5Ch]
  float v7; // [esp+3Ch] [ebp-5Ch]
  float v8; // [esp+3Ch] [ebp-5Ch]
  float v9; // [esp+40h] [ebp-58h] BYREF
  float v10; // [esp+44h] [ebp-54h]
  float v11; // [esp+4Ch] [ebp-4Ch]
  char v12[16]; // [esp+50h] [ebp-48h] BYREF
  float v13; // [esp+60h] [ebp-38h] BYREF
  float v14; // [esp+64h] [ebp-34h]
  float v15; // [esp+68h] [ebp-30h]
  int v16[6]; // [esp+70h] [ebp-28h] BYREF
  float v17; // [esp+88h] [ebp-10h]
  float v18; // [esp+8Ch] [ebp-Ch]

  if ( sub_1F985() )
  {
    sub_1FE8D();
    result = *(_DWORD *)(pm + 4);
    *(_DWORD *)(*pm + 100) = result;
  }
  else
  {
    v11 = (*(float *)&pml[2] + 0.25) * 2.5;
    if ( v11 <= 1.0 )
    {
      if ( v11 < -1.0 )
        v11 = -1.0;
    }
    else
    {
      v11 = 1.0;
    }
    pml[2] = 0;
    VectorNormalize(pml);
    pml[5] = 0;
    VectorNormalize2(&pml[3], v12);
    ProjectPointOnPlane(&pml[3], v12, *pm + 88);
    v17 = sub_1EEC9((char *)(pm + 4));
    v15 = 0.0;
    v14 = 0.0;
    v13 = 0.0;
    if ( *(_BYTE *)(pm + 24) )
      v15 = 0.5 * v11 * v17 * (long double)*(char *)(pm + 24);
    if ( *(_BYTE *)(pm + 25) )
    {
      v13 = v17 * 0.2 * (long double)*(char *)(pm + 25) * *(float *)&pml[3] + v13;
      v14 = v17 * 0.2 * (long double)*(char *)(pm + 25) * *(float *)&pml[4] + v14;
      v15 = v17 * 0.2 * (long double)*(char *)(pm + 25) * *(float *)&pml[5] + v15;
    }
    v18 = VectorNormalize2(&v13, v16);
    sub_1ED62((int)v16, v18, 9.0);
    if ( !*(_BYTE *)(pm + 24) )
    {
      if ( *(float *)(*pm + 40) <= 0.0 )
      {
        *(float *)(*pm + 40) = (long double)*(int *)(*pm + 60) * *(float *)&pml[9] + *(float *)(*pm + 40);
        if ( *(float *)(*pm + 40) > 0.0 )
          *(_DWORD *)(*pm + 40) = 0;
      }
      else
      {
        *(float *)(*pm + 40) = *(float *)(*pm + 40) - (long double)*(int *)(*pm + 60) * *(float *)&pml[9];
        if ( *(float *)(*pm + 40) < 0.0 )
          *(_DWORD *)(*pm + 40) = 0;
      }
    }
    if ( !*(_BYTE *)(pm + 25) )
    {
      v9 = *(float *)&pml[3];
      v10 = *(float *)&pml[4];
      VectorNormalize2D(&v9);
      v5 = v9 * *(float *)(*pm + 32) + v10 * *(float *)(*pm + 36);
      if ( v5 != 0.0 )
      {
        *(float *)(*pm + 32) = -v5 * v9 + *(float *)(*pm + 32);
        *(float *)(*pm + 36) = -v5 * v10 + *(float *)(*pm + 36);
        v4 = v5 * *(float *)&pml[9] * 16.0;
        if ( fabs(v5) > fabs(v4) )
        {
          if ( fabs(v4) < 1.0 )
            v4 = (float)sub_28B8A(v4);
          v6 = v5 - v4;
          *(float *)(*pm + 32) = v9 * v6 + *(float *)(*pm + 32);
          *(float *)(*pm + 36) = v10 * v6 + *(float *)(*pm + 36);
        }
      }
    }
    if ( !pml[11] )
    {
      v7 = *(float *)(*pm + 88) * *(float *)(*pm + 32) + *(float *)(*pm + 92) * *(float *)(*pm + 36);
      *(float *)(*pm + 32) = -v7 * *(float *)(*pm + 88) + *(float *)(*pm + 32);
      *(float *)(*pm + 36) = -v7 * *(float *)(*pm + 92) + *(float *)(*pm + 36);
      if ( v15 <= 0.0 )
        v8 = -250.0;
      else
        v8 = -500.0;
      *(float *)(*pm + 32) = *(float *)(*pm + 88) * v8 + *(float *)(*pm + 32);
      *(float *)(*pm + 36) = *(float *)(*pm + 92) * v8 + *(float *)(*pm + 36);
    }
    PM_StepSlideMove(0);
    v1 = vectoyaw(*pm + 88) + 180.0;
    v17 = v1;
    AngleDelta(v17, *(float *)(*pm + 196));
    v3 = (int)v1;
    v2 = (int)v1;
    if ( (int)v1 < 0 )
      v2 = -v2;
    if ( v2 > 75 )
    {
      if ( v3 <= 0 )
        LOBYTE(v3) = -75;
      else
        LOBYTE(v3) = 75;
    }
    result = (char)v3;
    *(_DWORD *)(*pm + 124) = (char)v3;
  }
  return result;
}
// 12F80: using guessed type long double __cdecl vectoyaw(_DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13E10: using guessed type _DWORD __cdecl VectorNormalize2D(_DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 15650: using guessed type _DWORD __cdecl PM_StepSlideMove(_DWORD);
// 15710: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (00027EB7) --------------------------------------------------------
void __cdecl PmoveSingle(int a1)
{
  unsigned int v1; // eax
  float v2; // [esp+18h] [ebp-30h]
  float v3; // [esp+1Ch] [ebp-2Ch]
  float v4; // [esp+20h] [ebp-28h]
  float v5; // [esp+24h] [ebp-24h]
  float v6; // [esp+28h] [ebp-20h]
  int v7; // [esp+3Ch] [ebp-Ch]

  BG_AnimUpdatePlayerStateConditions(a1);
  pm = a1;
  ++c_pmove;
  *(_BYTE *)(a1 + 216) = 0;
  *(_BYTE *)(pm + 217) = 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x4000) != 0 )
  {
    *(_BYTE *)(a1 + 8) = 0;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  if ( (*(_BYTE *)(a1 + 8) & 2) != 0 )
  {
    *(_BYTE *)(a1 + 8) &= 0x12u;
    *(_BYTE *)(a1 + 9) &= 0xC2u;
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    *(_BYTE *)(a1 + 26) = 0;
  }
  *(_DWORD *)(*pm + 12) &= 0xFFFF7FFF;
  if ( *(int *)(*pm + 4) > 5 )
    *(_DWORD *)(pm + 52) &= 0xFDFFFFFF;
  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    if ( (*(_BYTE *)(pm + 24) == *(_BYTE *)(pm + 48)
       || fabs((long double)*(char *)(pm + 24)) <= fabs((long double)*(char *)(pm + 48)))
      && (*(_BYTE *)(pm + 25) == *(_BYTE *)(pm + 49)
       || fabs((long double)*(char *)(pm + 25)) <= fabs((long double)*(char *)(pm + 49))) )
    {
      if ( (*(_DWORD *)(*pm + 12) & 0x20) == 0
        && (!*(_DWORD *)(*pm + 180)
         || *(_DWORD *)(*pm + 180) == 1
         || *(_DWORD *)(*pm + 180) == 2
         || *(_DWORD *)(*pm + 180) == 5) )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
      }
    }
    else if ( PM_InteruptWeaponWithProneMove() )
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
      PM_ClearAimDownSightFlag();
    }
  }
  else
  {
    *(_DWORD *)(*pm + 12) &= 0xFFFFFBFF;
  }
  pml[34] = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 176));
  v7 = PM_GetEffectiveStance(*pm);
  if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 && v7 == 1 )
  {
    *(_BYTE *)(a1 + 24) = 0;
    *(_BYTE *)(a1 + 25) = 0;
  }
  if ( (*(_BYTE *)(pm + 8) & 2) != 0 )
    v1 = *(_DWORD *)(*pm + 128) | 0x40000;
  else
    v1 = *(_DWORD *)(*pm + 128) & 0xFFFBFFFF;
  *(_DWORD *)(*pm + 128) = v1;
  *(_DWORD *)(*pm + 128) &= 0xFFFFFBFF;
  if ( *(_DWORD *)(*pm + 4) != 5
    && (*(_DWORD *)(*pm + 12) & 0x800) == 0
    && (!*(_DWORD *)(*pm + 180) || *(_DWORD *)(*pm + 180) == 3)
    && PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 176))
    && (*(_BYTE *)(pm + 8) & 1) != 0 )
  {
    *(_DWORD *)(*pm + 128) |= 0x400u;
  }
  if ( *(int *)(*pm + 4) <= 5 && (*(_BYTE *)(pm + 8) & 1) == 0 )
    *(_DWORD *)(*pm + 12) &= 0xFFFFF7FF;
  memset(pml, 0, 0x8Cu);
  pml[10] = *(_DWORD *)(a1 + 4) - *(_DWORD *)*pm;
  if ( (int)pml[10] > 0 )
  {
    if ( (int)pml[10] > 200 )
      pml[10] = 200;
  }
  else
  {
    pml[10] = 1;
  }
  *(_DWORD *)*pm = *(_DWORD *)(a1 + 4);
  pml[27] = *(_DWORD *)(*pm + 20);
  pml[28] = *(_DWORD *)(*pm + 24);
  pml[29] = *(_DWORD *)(*pm + 28);
  pml[30] = *(_DWORD *)(*pm + 32);
  pml[31] = *(_DWORD *)(*pm + 36);
  pml[32] = *(_DWORD *)(*pm + 40);
  *(float *)&pml[9] = (long double)(int)pml[10] * 0.001;
  pml[34] = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 176));
  PM_AdjustAimSpreadScale();
  PM_UpdateViewAngles(*pm, pm + 4, *(_DWORD *)(pm + 244));
  AngleVectors(*pm + 192, pml, &pml[3], &pml[6]);
  if ( *(char *)(pm + 26) <= 9 )
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFF7;
  if ( *(char *)(pm + 24) >= 0 )
  {
    if ( *(char *)(pm + 24) > 0 || !*(_BYTE *)(pm + 24) && *(_BYTE *)(pm + 25) )
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFBF;
  }
  else
  {
    *(_DWORD *)(*pm + 12) |= 0x40u;
  }
  if ( *(int *)(*pm + 4) > 5 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
    *(_BYTE *)(pm + 26) = 0;
  }
  if ( v7 == 1 && (*(_DWORD *)(*pm + 12) & 0x400) != 0 )
  {
    *(_BYTE *)(pm + 24) = 0;
    *(_BYTE *)(pm + 25) = 0;
  }
  switch ( *(_DWORD *)(*pm + 4) )
  {
    case 1:
    case 7:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      *(_DWORD *)(*pm + 84) = 1023;
      pml[12] = 0;
      pml[13] = 0;
      pml[11] = 0;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_232C4();
      sub_25AEF();
      sub_24AE8();
      PM_Weapon();
      break;
    case 2:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_2084C();
      sub_25AEF();
      break;
    case 3:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_20BAE();
      sub_25AEF();
      break;
    case 4:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      PM_UpdateAimDownSightFlag();
      PM_UpdatePlayerWalkingFlag();
      sub_232C4();
      sub_1FCF9();
      sub_25AEF();
      break;
    case 5:
      *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
      break;
    default:
      if ( (*(_WORD *)(*pm + 128) & 0xC000) != 0 )
      {
        *(_DWORD *)(*pm + 12) &= 0xFFFFFFEF;
        *(_DWORD *)(*pm + 84) = 1023;
        pml[12] = 0;
        pml[13] = 0;
        pml[11] = 0;
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        sub_232C4();
        sub_25AEF();
        sub_24AE8();
      }
      else
      {
        sub_2219F();
        pml[33] = *(unsigned __int8 *)(a1 + 217);
        sub_232C4();
        sub_21CCD();
        PM_UpdateAimDownSightFlag();
        PM_UpdatePlayerWalkingFlag();
        PM_UpdatePronePitch();
        if ( *(_DWORD *)(*pm + 4) == 6 )
          sub_20707();
        sub_27330();
        sub_25AEF();
        if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
        {
          PM_LadderMove();
        }
        else if ( pml[11] )
        {
          sub_2003D();
        }
        else
        {
          sub_1FE8D();
        }
        sub_21CCD();
        sub_2219F();
        sub_24AE8();
        PM_Weapon();
        sub_25816();
        sub_25A7F();
        v4 = *(float *)(*pm + 20) - *(float *)&pml[27];
        v5 = *(float *)(*pm + 24) - *(float *)&pml[28];
        v6 = *(float *)(*pm + 28) - *(float *)&pml[29];
        v3 = (v4 * v4 + v5 * v5 + v6 * v6) / (*(float *)&pml[9] * *(float *)&pml[9]);
        v2 = *(float *)(*pm + 32) * *(float *)(*pm + 32)
           + *(float *)(*pm + 36) * *(float *)(*pm + 36)
           + *(float *)(*pm + 40) * *(float *)(*pm + 40);
        if ( v2 * 0.25 > v3 )
        {
          *(float *)(*pm + 32) = 1.0 / *(float *)&pml[9] * v4;
          *(float *)(*pm + 36) = 1.0 / *(float *)&pml[9] * v5;
          *(float *)(*pm + 40) = 1.0 / *(float *)&pml[9] * v6;
        }
        trap_SnapVector(*pm + 32);
      }
      break;
  }
}
// 12F90: using guessed type int PM_InteruptWeaponWithProneMove(void);
// 13030: using guessed type int PM_UpdatePlayerWalkingFlag(void);
// 13210: using guessed type _DWORD __cdecl PM_UpdateViewAngles(_DWORD, _DWORD, _DWORD);
// 13410: using guessed type _DWORD __cdecl BG_AnimUpdatePlayerStateConditions(_DWORD);
// 134A0: using guessed type _DWORD __cdecl PM_GetEffectiveStance(_DWORD);
// 13A70: using guessed type int PM_UpdateAimDownSightFlag(void);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13FD0: using guessed type int PM_ClearAimDownSightFlag(void);
// 14000: using guessed type int PM_Weapon(void);
// 14B70: using guessed type int PM_UpdatePronePitch(void);
// 14FF0: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 15290: using guessed type int PM_AdjustAimSpreadScale(void);
// 15890: using guessed type int PM_LadderMove(void);
// 15A10: using guessed type _DWORD __cdecl trap_SnapVector(_DWORD);

//----- (00028A02) --------------------------------------------------------
int __cdecl Pmove(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(a1 + 4);
  result = v3;
  if ( v3 >= **(_DWORD **)a1 )
  {
    if ( v3 > **(_DWORD **)a1 + 1000 )
      **(_DWORD **)a1 = v3 - 1000;
    pm = a1;
    *(_DWORD *)(a1 + 60) = 0;
    while ( 1 )
    {
      result = **(_DWORD **)a1;
      if ( result == v3 )
        break;
      v2 = v3 - **(_DWORD **)a1;
      if ( *(_DWORD *)(a1 + 224) )
      {
        if ( v2 > *(_DWORD *)(a1 + 228) )
          v2 = *(_DWORD *)(a1 + 228);
      }
      else if ( v2 > 66 )
      {
        v2 = 66;
      }
      *(_DWORD *)(a1 + 4) = **(_DWORD **)a1 + v2;
      PmoveSingle(a1);
      if ( (*(_DWORD *)(*(_DWORD *)a1 + 12) & 8) != 0 )
        *(_BYTE *)(a1 + 26) = 20;
    }
  }
  return result;
}
// 14490: using guessed type _DWORD __cdecl PmoveSingle(_DWORD);

//----- (00028AF6) --------------------------------------------------------
long double __cdecl BG_GetSpeed(int a1, int a2)
{
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+10h] [ebp-8h]

  if ( (*(_DWORD *)(a1 + 12) & 0x10) != 0 )
  {
    if ( a2 - *(_DWORD *)(a1 + 100) > 499 )
      v3 = *(float *)(a1 + 40);
    else
      v3 = 0.0;
  }
  else
  {
    v4 = sqrt(*(float *)(a1 + 32) * *(float *)(a1 + 32) + *(float *)(a1 + 36) * *(float *)(a1 + 36));
    v3 = v4;
  }
  return v3;
}

//----- (00028B71) --------------------------------------------------------
long double __cdecl sub_28B71(float a1)
{
  return (float)fabs(a1);
}

//----- (00028B8A) --------------------------------------------------------
int __cdecl sub_28B8A(float a1)
{
  return -2 * sub_28BB0(a1) + 1;
}

//----- (00028BB0) --------------------------------------------------------
_BOOL4 __cdecl sub_28BB0(float a1)
{
  return a1 < 0.0;
}

//----- (00028BD8) --------------------------------------------------------
void sub_28BD8()
{
  ;
}

//----- (00028BDC) --------------------------------------------------------
int __cdecl PM_VerifyPronePosition(_DWORD *a1, _DWORD *a2)
{
  int v4; // [esp+40h] [ebp-8h]

  if ( (*(_DWORD *)(*pm + 12) & 1) == 0 )
    return 1;
  v4 = BG_CheckProne(
         *(_DWORD *)(*pm + 172),
         *pm + 20,
         *(_DWORD *)(*pm + 816),
         1106247680,
         *(float *)(*pm + 872),
         *pm + 964,
         *pm + 968,
         *pm + 972,
         1,
         1,
         0,
         *(_DWORD *)(pm + 244),
         *(_DWORD *)(pm + 240),
         0,
         60.0);
  if ( !v4 )
  {
    *(_DWORD *)(*pm + 20) = *a1;
    *(_DWORD *)(*pm + 24) = a1[1];
    *(_DWORD *)(*pm + 28) = a1[2];
    *(_DWORD *)(*pm + 32) = *a2;
    *(_DWORD *)(*pm + 36) = a2[1];
    *(_DWORD *)(*pm + 40) = a2[2];
  }
  return v4;
}

//----- (00028D7D) --------------------------------------------------------
_BOOL4 __cdecl PM_SlideMove(int a1)
{
  int v1; // esi
  int v2; // ecx
  int v5; // [esp+40h] [ebp-138h] BYREF
  float v6; // [esp+44h] [ebp-134h]
  float v7; // [esp+48h] [ebp-130h]
  int v8; // [esp+50h] [ebp-128h] BYREF
  float v9; // [esp+54h] [ebp-124h]
  float v10; // [esp+58h] [ebp-120h]
  float v11; // [esp+68h] [ebp-110h]
  float v12; // [esp+6Ch] [ebp-10Ch]
  float v13[4]; // [esp+70h] [ebp-108h] BYREF
  float v14[4]; // [esp+80h] [ebp-F8h] BYREF
  int v15; // [esp+90h] [ebp-E8h]
  float v16; // [esp+94h] [ebp-E4h]
  float v17; // [esp+98h] [ebp-E0h]
  unsigned __int16 v18; // [esp+A8h] [ebp-D0h]
  char v19; // [esp+AEh] [ebp-CAh]
  int l; // [esp+B4h] [ebp-C4h]
  int k; // [esp+B8h] [ebp-C0h]
  int j; // [esp+BCh] [ebp-BCh]
  int v23; // [esp+C0h] [ebp-B8h] BYREF
  float v24; // [esp+C4h] [ebp-B4h]
  float v25; // [esp+C8h] [ebp-B0h]
  int v26; // [esp+D0h] [ebp-A8h]
  int v27; // [esp+D4h] [ebp-A4h]
  float v28; // [esp+D8h] [ebp-A0h]
  int v29[26]; // [esp+E0h] [ebp-98h] BYREF
  int v30; // [esp+148h] [ebp-30h]
  float v31; // [esp+14Ch] [ebp-2Ch]
  float v32; // [esp+150h] [ebp-28h] BYREF
  float v33; // [esp+154h] [ebp-24h]
  float v34; // [esp+158h] [ebp-20h]
  int v35; // [esp+168h] [ebp-10h]
  int i; // [esp+16Ch] [ebp-Ch]
  _DWORD v37[2]; // [esp+170h] [ebp-8h] BYREF

  v35 = 4;
  v26 = *(_DWORD *)(*pm + 32);
  v27 = *(_DWORD *)(*pm + 36);
  v28 = *(float *)(*pm + 40);
  if ( a1 )
  {
    v8 = *(int *)(*pm + 32);
    v9 = *(float *)(*pm + 36);
    v10 = *(float *)(*pm + 40) - (long double)*(int *)(*pm + 60) * *(float *)&pml[9];
    *(float *)(*pm + 40) = (*(float *)(*pm + 40) + v10) * 0.5;
    v28 = v10;
    if ( pml[12] )
      PM_ClipVelocity(*pm + 32, (int)&pml[18], *pm + 32, 1.001);
  }
  v12 = *(float *)&pml[9];
  if ( pml[12] )
  {
    v29[0] = pml[18];
    v29[1] = pml[19];
    v29[2] = pml[20];
    v30 = 1;
  }
  else
  {
    v30 = 0;
  }
  VectorNormalize2(*pm + 32, &v29[3 * v30++]);
  for ( i = 0; ; ++i )
  {
    if ( i >= v35 )
      goto LABEL_47;
    v13[0] = *(float *)(*pm + 32) * v12 + *(float *)(*pm + 20);
    v13[1] = *(float *)(*pm + 36) * v12 + *(float *)(*pm + 24);
    v13[2] = *(float *)(*pm + 40) * v12 + *(float *)(*pm + 28);
    PM_trace(v14, *pm + 20, pm + 192, pm + 204, v13, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
    if ( v19 )
    {
      *(_DWORD *)(*pm + 40) = 0;
      return 1;
    }
    if ( v14[0] > 0.0 )
    {
      *(float *)(*pm + 20) = v14[1];
      *(float *)(*pm + 24) = v14[2];
      *(float *)(*pm + 28) = v14[3];
    }
    if ( v14[0] == 1.0 )
    {
LABEL_47:
      if ( a1 )
      {
        *(float *)(*pm + 32) = *(float *)&v8;
        *(float *)(*pm + 36) = v9;
        *(float *)(*pm + 40) = v10;
      }
      if ( *(_DWORD *)(*pm + 16) )
      {
        *(_DWORD *)(*pm + 32) = v26;
        *(_DWORD *)(*pm + 36) = v27;
        *(float *)(*pm + 40) = v28;
      }
      return i != 0;
    }
    PM_AddTouchEnt(v18);
    v12 = v12 - v12 * v14[0];
    if ( v30 > 7 )
      break;
    for ( j = 0; j < v30; ++j )
    {
      if ( *(float *)&v15 * *(float *)&v29[3 * j] + v16 * *(float *)&v37[3 * j - 35] + v17 * *(float *)&v37[3 * j - 34] > 0.99900001 )
      {
        if ( *(int *)(pm + 56) > 1 )
          Com_Printf("%i:recollided with plane normal (%.2f, %.2f, %.2f)\n", c_pmove);
        *(float *)(*pm + 32) = *(float *)&v15 + *(float *)(*pm + 32);
        *(float *)(*pm + 36) = v16 + *(float *)(*pm + 36);
        *(float *)(*pm + 40) = v17 + *(float *)(*pm + 40);
        break;
      }
    }
    if ( j >= v30 )
    {
      v29[3 * v30] = v15;
      *(float *)&v37[3 * v30 - 35] = v16;
      *(float *)&v37[3 * v30++ - 34] = v17;
      for ( j = 0; j < v30; ++j )
      {
        v11 = *(float *)(*pm + 32) * *(float *)&v29[3 * j]
            + *(float *)(*pm + 36) * *(float *)&v37[3 * j - 35]
            + *(float *)(*pm + 40) * *(float *)&v37[3 * j - 34];
        if ( v11 < 0.1 )
        {
          if ( -v11 > (long double)*(float *)&pml[26] )
            pml[26] = LODWORD(v11) ^ 0x80000000;
          PM_ClipVelocity(*pm + 32, (int)&v29[3 * j], (int)&v23, 1.001);
          PM_ClipVelocity((int)&v8, (int)&v29[3 * j], (int)&v5, 1.001);
          for ( k = 0; k < v30; ++k )
          {
            if ( k != j
              && *(float *)&v23 * *(float *)&v29[3 * k]
               + v24 * *(float *)&v37[3 * k - 35]
               + v25 * *(float *)&v37[3 * k - 34] < 0.1 )
            {
              PM_ClipVelocity((int)&v23, (int)&v29[3 * k], (int)&v23, 1.001);
              PM_ClipVelocity((int)&v5, (int)&v29[3 * k], (int)&v5, 1.001);
              if ( *(float *)&v23 * *(float *)&v29[3 * j]
                 + v24 * *(float *)&v37[3 * j - 35]
                 + v25 * *(float *)&v37[3 * j - 34] < 0.0 )
              {
                CrossProduct(&v29[3 * j], &v29[3 * k], &v32);
                VectorNormalize(&v32);
                v31 = v32 * *(float *)(*pm + 32) + v33 * *(float *)(*pm + 36) + v34 * *(float *)(*pm + 40);
                *(float *)&v23 = v32 * v31;
                v24 = v33 * v31;
                v25 = v34 * v31;
                v31 = v32 * *(float *)&v8 + v33 * v9 + v34 * v10;
                *(float *)&v5 = v32 * v31;
                v6 = v33 * v31;
                v7 = v34 * v31;
                for ( l = 0; l < v30; ++l )
                {
                  if ( l != j
                    && l != k
                    && *(float *)&v23 * *(float *)&v29[3 * l]
                     + v24 * *(float *)&v37[3 * l - 35]
                     + v25 * *(float *)&v37[3 * l - 34] < 0.1 )
                  {
                    goto LABEL_41;
                  }
                }
              }
            }
          }
          *(float *)(*pm + 32) = *(float *)&v23;
          *(float *)(*pm + 36) = v24;
          *(float *)(*pm + 40) = v25;
          v8 = v5;
          v9 = v6;
          v10 = v7;
          break;
        }
      }
    }
  }
  if ( *(int *)(pm + 56) > 1 )
    Com_Printf("%i:MAX_CLIP_PLANES\n", c_pmove);
LABEL_41:
  v1 = *pm;
  v2 = *pm;
  *(_DWORD *)(*pm + 40) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  return 1;
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 14AB0: using guessed type _DWORD __cdecl PM_AddTouchEnt(_DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (00029942) --------------------------------------------------------
void __cdecl PM_StepSlideMove(int a1)
{
  float v1; // [esp+0h] [ebp-118h]
  float v2; // [esp+0h] [ebp-118h]
  int v3; // [esp+2Ch] [ebp-ECh]
  int v4; // [esp+30h] [ebp-E8h]
  float v5; // [esp+3Ch] [ebp-DCh]
  int v6; // [esp+40h] [ebp-D8h]
  float v7; // [esp+44h] [ebp-D4h]
  int v8; // [esp+48h] [ebp-D0h]
  int v9; // [esp+48h] [ebp-D0h]
  int v10; // [esp+48h] [ebp-D0h]
  int v11; // [esp+48h] [ebp-D0h]
  float v12; // [esp+50h] [ebp-C8h]
  float v13; // [esp+54h] [ebp-C4h]
  float v14; // [esp+54h] [ebp-C4h]
  int v15; // [esp+58h] [ebp-C0h]
  int v16; // [esp+5Ch] [ebp-BCh]
  float v17; // [esp+60h] [ebp-B8h]
  int v18; // [esp+64h] [ebp-B4h]
  float v19; // [esp+68h] [ebp-B0h]
  float v20; // [esp+70h] [ebp-A8h]
  float v21; // [esp+74h] [ebp-A4h]
  float v22; // [esp+78h] [ebp-A0h]
  float v23; // [esp+7Ch] [ebp-9Ch]
  int v24; // [esp+80h] [ebp-98h] BYREF
  int v25; // [esp+84h] [ebp-94h]
  float v26; // [esp+88h] [ebp-90h]
  float v27; // [esp+90h] [ebp-88h] BYREF
  float v28; // [esp+94h] [ebp-84h]
  float v29; // [esp+98h] [ebp-80h]
  float v30; // [esp+A0h] [ebp-78h] BYREF
  int v31; // [esp+A4h] [ebp-74h]
  int v32; // [esp+A8h] [ebp-70h]
  int v33; // [esp+ACh] [ebp-6Ch]
  _WORD v34[16]; // [esp+B0h] [ebp-68h] BYREF
  int v35; // [esp+D0h] [ebp-48h]
  int v36; // [esp+D4h] [ebp-44h]
  int v37; // [esp+D8h] [ebp-40h]
  float v38; // [esp+E0h] [ebp-38h]
  float v39; // [esp+E4h] [ebp-34h]
  float v40; // [esp+E8h] [ebp-30h]
  int v41; // [esp+F0h] [ebp-28h] BYREF
  int v42; // [esp+F4h] [ebp-24h]
  int v43; // [esp+F8h] [ebp-20h]
  float v44; // [esp+100h] [ebp-18h] BYREF
  float v45; // [esp+104h] [ebp-14h]
  float v46; // [esp+108h] [ebp-10h]

  v17 = 0.0;
  v15 = 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
  {
    v16 = 0;
    *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
    *(_DWORD *)(*pm + 104) = 0;
  }
  else if ( pml[12] )
  {
    v16 = 1;
  }
  else
  {
    v16 = 0;
    if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 && *(_DWORD *)(*pm + 16) )
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*pm + 104) = 0;
    }
  }
  v44 = *(float *)(*pm + 20);
  v45 = *(float *)(*pm + 24);
  v46 = *(float *)(*pm + 28);
  v41 = *(_DWORD *)(*pm + 32);
  v42 = *(_DWORD *)(*pm + 36);
  v43 = *(_DWORD *)(*pm + 40);
  v18 = PM_SlideMove(a1);
  if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
    v19 = 10.0;
  else
    v19 = 18.0;
  if ( *(_DWORD *)(*pm + 84) == 1023 )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x2000) != 0 && *(_DWORD *)(*pm + 16) )
    {
      *(_DWORD *)(*pm + 12) &= 0xFFFFDFFF;
      *(_DWORD *)(*pm + 104) = 0;
    }
    if ( v18 && (*(_DWORD *)(*pm + 12) & 0x2000) != 0 && *(float *)(*pm + 104) + 39.0 > v46 )
    {
      v19 = 18.0;
      if ( v46 + 18.0 > *(float *)(*pm + 104) + 39.0 )
      {
        v19 = *(float *)(*pm + 104) + 39.0 - v46;
        if ( v19 < 1.0 )
          return;
      }
      v15 = 1;
    }
    else if ( (*(_DWORD *)(*pm + 12) & 0x10) == 0 || *(float *)(*pm + 40) <= 0.0 )
    {
      return;
    }
  }
  v38 = *(float *)(*pm + 20);
  v39 = *(float *)(*pm + 24);
  v40 = *(float *)(*pm + 28);
  v35 = *(_DWORD *)(*pm + 32);
  v36 = *(_DWORD *)(*pm + 36);
  v37 = *(_DWORD *)(*pm + 40);
  v22 = v38 - v44;
  v23 = v39 - v45;
  if ( v18 )
  {
    v27 = v44;
    v28 = v45;
    v29 = v19 + 1.0 + v46;
    PM_trace(&v30, &v44, pm + 192, pm + 204, &v27, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
    v17 = (v19 + 1.0) * v30 - 1.0;
    if ( v17 >= 1.0 )
    {
      *(float *)(*pm + 20) = v27;
      *(float *)(*pm + 24) = v28;
      *(float *)(*pm + 28) = v46 + v17;
      *(_DWORD *)(*pm + 32) = v41;
      *(_DWORD *)(*pm + 36) = v42;
      *(_DWORD *)(*pm + 40) = v43;
      PM_SlideMove(a1);
    }
    else
    {
      if ( *(_DWORD *)(pm + 56) )
        Com_Printf("%i:not enough step room\n", c_pmove);
      v17 = 0.0;
    }
  }
  if ( v16 || v17 != 0.0 )
  {
    v24 = *(_DWORD *)(*pm + 20);
    v25 = *(_DWORD *)(*pm + 24);
    v26 = *(float *)(*pm + 28) - v17;
    if ( v16 )
      v26 = v26 - 9.0;
    PM_trace(&v30, *pm + 20, pm + 192, pm + 204, &v24, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
    if ( v34[12] <= 0x3Fu )
    {
      *(float *)(*pm + 20) = v38;
      *(float *)(*pm + 24) = v39;
      *(float *)(*pm + 28) = v40;
      *(_DWORD *)(*pm + 32) = v35;
      *(_DWORD *)(*pm + 36) = v36;
      *(_DWORD *)(*pm + 40) = v37;
      return;
    }
    if ( v30 >= 1.0 )
    {
      if ( v17 != 0.0 )
        *(float *)(*pm + 28) = *(float *)(*pm + 28) - v17;
    }
    else
    {
      *(_DWORD *)(*pm + 20) = v31;
      *(_DWORD *)(*pm + 24) = v32;
      *(_DWORD *)(*pm + 28) = v33;
      PM_ClipVelocity(*pm + 32, (int)v34, *pm + 32, 1.001);
    }
  }
  v20 = *(float *)(*pm + 20) - v44;
  v21 = *(float *)(*pm + 24) - v45;
  if ( v22 * *(float *)(*pm + 32) + v23 * *(float *)(*pm + 36) + 0.001 >= v20 * *(float *)(*pm + 32)
                                                                        + v21 * *(float *)(*pm + 36)
    || v15 && *(float *)(*pm + 28) >= *(float *)(*pm + 104) + 39.0 )
  {
    *(float *)(*pm + 20) = v38;
    *(float *)(*pm + 24) = v39;
    *(float *)(*pm + 28) = v40;
    *(_DWORD *)(*pm + 32) = v35;
    *(_DWORD *)(*pm + 36) = v36;
    *(_DWORD *)(*pm + 40) = v37;
    if ( *(int *)(pm + 56) > 1 )
    {
      if ( v15 )
        Com_Printf("%i:didn't use jump step results because it went too high\n", c_pmove);
      else
        Com_Printf("%i:didn't use step results\n", c_pmove);
    }
    if ( v16 )
    {
      v24 = *(_DWORD *)(*pm + 20);
      v25 = *(_DWORD *)(*pm + 24);
      v26 = *(float *)(*pm + 28);
      v26 = v26 - 9.0;
      PM_trace(&v30, *pm + 20, pm + 192, pm + 204, &v24, *(_DWORD *)(*pm + 172), *(_DWORD *)(pm + 52));
      if ( v30 < 1.0 )
      {
        *(_DWORD *)(*pm + 20) = v31;
        *(_DWORD *)(*pm + 24) = v32;
        *(_DWORD *)(*pm + 28) = v33;
        PM_ClipVelocity(*pm + 32, (int)v34, *pm + 32, 1.001);
        if ( *(int *)(pm + 56) > 1 )
          Com_Printf("%i:did down step after not using step results\n", c_pmove);
      }
    }
  }
  if ( v15 && *(float *)(*pm + 28) - v40 > 0.0 )
  {
    v13 = *(float *)(*pm + 104) + 39.0 - *(float *)(*pm + 28);
    if ( v13 >= 0.1 )
    {
      v12 = sqrt((v13 + v13) * (long double)*(int *)(*pm + 60));
      if ( *(float *)(*pm + 40) > (long double)v12 )
      {
        if ( *(_DWORD *)(pm + 56) )
          Com_Printf("%i:adjusted jump vel: %.1f -> %.1f\n", c_pmove);
        *(float *)(*pm + 40) = v12;
      }
    }
    else
    {
      *(_DWORD *)(*pm + 40) = 0;
    }
  }
  if ( v16 )
  {
    if ( *(int *)(*pm + 4) <= 5 )
    {
      if ( PM_VerifyPronePosition(&v44, &v41) )
      {
        if ( fabs(*(float *)(*pm + 28) - v40) > 0.5 )
        {
          v1 = *(float *)(*pm + 28) - v40;
          v8 = sub_2A7B1(v1);
          if ( v8 )
          {
            if ( *(_DWORD *)(pm + 56) )
            {
              if ( v15 )
                Com_Printf("%i:jump step %2i\n", c_pmove);
              else
                Com_Printf("%i:stepped %2i\n", c_pmove);
            }
            if ( v8 >= -16 )
            {
              if ( v8 > 24 )
                v8 = 24;
            }
            else
            {
              v8 = -16;
            }
            v9 = v8 + 128;
            BG_AddPredictableEventToPlayerstate(143, v9, *pm);
            v2 = *(float *)(*pm + 28) - v46;
            v14 = sub_2A7EF(v2);
            v7 = 1.0 - 0.80000001 + (1.0 - v14 / v19) * 0.80000001;
            *(float *)(*pm + 32) = *(float *)(*pm + 32) * v7;
            *(float *)(*pm + 36) = *(float *)(*pm + 36) * v7;
            *(float *)(*pm + 40) = *(float *)(*pm + 40) * v7;
            v10 = v9 - 128;
            v4 = v10;
            if ( v10 < 0 )
              v4 = -v10;
            if ( v4 > 3 && *(_DWORD *)(*pm + 84) != 1023 && PM_ShouldMakeFootsteps() )
            {
              v3 = v10;
              if ( v10 < 0 )
                v3 = -v10;
              v11 = v3 / 2;
              if ( v3 / 2 > 4 )
                v11 = 4;
              v5 = (long double)v11 * 1.25 + 7.0;
              v6 = *(_DWORD *)(*pm + 8);
              *(_DWORD *)(*pm + 8) = (unsigned __int8)(int)((long double)v6 + v5);
              PM_FootstepEvent(v6, *(_DWORD *)(*pm + 8), 1);
            }
          }
        }
      }
    }
  }
}
// 12EE0: using guessed type _DWORD __cdecl PM_trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13350: using guessed type _DWORD __cdecl PM_FootstepEvent(char, char, _DWORD);
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);
// 14620: using guessed type _DWORD __cdecl PM_SlideMove(_DWORD);
// 151A0: using guessed type _DWORD __cdecl PM_VerifyPronePosition(_DWORD, _DWORD);
// 156E0: using guessed type int PM_ShouldMakeFootsteps(void);

//----- (0002A7B1) --------------------------------------------------------
int __cdecl sub_2A7B1(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (0002A7EF) --------------------------------------------------------
long double __cdecl sub_2A7EF(float a1)
{
  return (float)fabs(a1);
}

//----- (0002A808) --------------------------------------------------------
void sub_2A808()
{
  ;
}

//----- (0002A80C) --------------------------------------------------------
int __cdecl BG_GetWeaponTypeName(int a1)
{
  return *(int *)((char *)off_81708 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// 81708: using guessed type char *off_81708[17];

//----- (0002A828) --------------------------------------------------------
int __cdecl sub_2A828(int a1, char *s1, int a3)
{
  int v5; // [esp+20h] [ebp-8h]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+20h] [ebp-8h]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+20h] [ebp-8h]
  int v10; // [esp+20h] [ebp-8h]

  switch ( a3 )
  {
    case 8:
      v5 = 0;
      break;
    case 9:
      v6 = 0;
      while ( 2 )
      {
        if ( v6 <= 7 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_81760 + (_DWORD)&dword_0[v6])) )
          {
            ++v6;
            continue;
          }
          *(_DWORD *)(a1 + 116) = v6;
        }
        break;
      }
      if ( v6 == 8 )
        Com_Error(1, byte_76C00, (char)s1);
      return 1;
    case 10:
      v7 = 0;
      while ( 2 )
      {
        if ( v7 <= 4 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_81714 + (_DWORD)&dword_0[v7])) )
          {
            ++v7;
            continue;
          }
          *(_DWORD *)(a1 + 552) = v7;
        }
        break;
      }
      if ( v7 == 5 )
        Com_Error(1, byte_76C40, (char)s1);
      return 1;
    case 11:
      v8 = 0;
      while ( 2 )
      {
        if ( v8 <= 5 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_81728 + (_DWORD)&dword_0[v8])) )
          {
            ++v8;
            continue;
          }
          *(_DWORD *)(a1 + 120) = v8;
        }
        break;
      }
      if ( v8 == 6 )
        Com_Error(1, byte_76C80, (char)s1);
      return 1;
    case 12:
      v9 = 0;
      while ( 2 )
      {
        if ( v9 <= 2 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_81740 + (_DWORD)&dword_0[v9])) )
          {
            ++v9;
            continue;
          }
          *(_DWORD *)(a1 + 128) = v9;
        }
        break;
      }
      if ( v9 == 3 )
        Com_Error(1, byte_76CC0, (char)s1);
      return 1;
    case 13:
      v10 = 0;
      while ( 2 )
      {
        if ( v10 <= 3 )
        {
          if ( strcasecmp(s1, *(const char **)((char *)off_81780 + (_DWORD)&dword_0[v10])) )
          {
            ++v10;
            continue;
          }
          *(_DWORD *)(a1 + 812) = v10;
        }
        break;
      }
      if ( v10 == 4 )
        Com_Error(1, byte_76D00, (char)s1);
      return 1;
    default:
      Com_Error(1, byte_76D2C, a3);
      return 0;
  }
  while ( 1 )
  {
    if ( v5 > 2 )
      goto LABEL_7;
    if ( !strcasecmp(s1, *(const char **)((char *)off_81708 + (_DWORD)&dword_0[v5])) )
      break;
    ++v5;
  }
  *(_DWORD *)(a1 + 112) = v5;
LABEL_7:
  if ( v5 == 3 )
    Com_Error(1, byte_76BC0, (char)s1);
  return 1;
}
// 0: using guessed type int dword_0[];
// 81708: using guessed type char *off_81708[17];
// 81714: using guessed type char *off_81714[14];
// 81728: using guessed type char *off_81728[9];
// 81740: using guessed type char *off_81740[3];
// 81760: using guessed type char *off_81760[12];
// 81780: using guessed type char *off_81780[4];

//----- (0002AB58) --------------------------------------------------------
char *__cdecl sub_2AB58(int a1, char *s)
{
  char *result; // eax
  size_t v3; // eax
  char *dest; // [esp+10h] [ebp-8h]

  if ( *s )
  {
    v3 = strlen(s);
    dest = (char *)trap_Hunk_AllocLowAlignInternal(v3 + 1, 1);
    strcpy(dest, s);
    result = dest;
    *(_DWORD *)a1 = dest;
  }
  else
  {
    result = (char *)dword_A5964;
    *(_DWORD *)a1 = dword_A5964;
  }
  return result;
}
// 14190: using guessed type _DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD);
// A5964: using guessed type int dword_A5964;

//----- (0002ABBE) --------------------------------------------------------
char *__cdecl sub_2ABBE(int a1, char *s)
{
  return sub_2AB58(a1, s);
}

//----- (0002ABD8) --------------------------------------------------------
_DWORD *__cdecl sub_2ABD8(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int i; // [esp+10h] [ebp-8h]

  v4 = (_DWORD *)trap_Hunk_AllocLowInternal(1072);
  *(_DWORD *)(dword_816E8 + 4 * a1) = v4;
  *v4 = a1;
  sub_2AB58((int)(v4 + 1), (char *)&unk_76D60);
  for ( i = 0; i < a3; ++i )
  {
    if ( !*(_DWORD *)(a2 + 8) )
      sub_2AB58((int)v4 + *(_DWORD *)(a2 + 4), (char *)&unk_76D60);
    a2 += 12;
  }
  return v4;
}
// 13990: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);
// 816E8: using guessed type int dword_816E8;

//----- (0002AC83) --------------------------------------------------------
int __cdecl sub_2AC83(int a1, int a2)
{
  int result; // eax
  size_t n; // [esp+20h] [ebp-2068h]
  int v4; // [esp+28h] [ebp-2060h] BYREF
  int v5; // [esp+2Ch] [ebp-205Ch]
  char s1[8192]; // [esp+30h] [ebp-2058h] BYREF
  char dest[72]; // [esp+2030h] [ebp-58h] BYREF
  int v8; // [esp+2078h] [ebp-10h]
  int i; // [esp+207Ch] [ebp-Ch]

  n = strlen("WEAPONFILE");
  dword_A5964 = trap_Hunk_AllocLowAlignInternal(1, 1);
  *(_BYTE *)dword_A5964 = 0;
  v5 = (int)sub_2ABD8(0, (int)&off_817A0, bg_iNumWeaponInfoFields);
  sub_2AB58(v5 + 4, "none");
  dword_816E4 = 0;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a2 )
      break;
    v5 = (int)sub_2ABD8(++dword_816E4, (int)&off_817A0, bg_iNumWeaponInfoFields);
    sprintf(dest, "%s/", bg_szWeaponsFolder[0]);
    strcat(dest, *(const char **)(a1 + 4 * i));
    Com_DPrintf("Parsing weapon file \"%s\"...\n", (char)dest);
    v8 = trap_FS_FOpenFile(dest, &v4, 0);
    if ( v8 <= 0 )
      Com_Error(1, byte_76DA0, (char)dest);
    trap_FS_Read(s1, n, v4);
    s1[n] = 0;
    if ( strncmp(s1, "WEAPONFILE", n) )
      Com_Error(1, byte_76DE0, (char)dest);
    if ( (int)(v8 - n) > 0x1FFF )
      Com_Error(1, byte_76E20, (char)dest);
    memset(s1, 0, sizeof(s1));
    trap_FS_Read(s1, v8 - n, v4);
    s1[v8 - n] = 0;
    trap_FS_FCloseFile(v4);
    if ( !Info_Validate(s1) )
      Com_Error(1, byte_76E60, (char)dest);
    sub_2AB58(v5 + 4, *(char **)(a1 + 4 * i));
    if ( !ParseConfigStringToStruct(
            v5,
            (int)&off_817A0,
            bg_iNumWeaponInfoFields,
            s1,
            14,
            (int)sub_2A828,
            (int)sub_2ABBE) )
      *(_DWORD *)(dword_816E8 + 4 * dword_816E4--) = 0;
  }
  return result;
}
// 13450: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 13B90: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 14190: using guessed type _DWORD __cdecl trap_Hunk_AllocLowAlignInternal(_DWORD, _DWORD);
// 15960: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;
// 81704: using guessed type char *bg_szWeaponsFolder[18];
// 817A0: using guessed type char *off_817A0;
// A5964: using guessed type int dword_A5964;

//----- (0002AFE4) --------------------------------------------------------
int sub_2AFE4()
{
  int result; // eax
  long double v1; // fst7
  long double v2; // fst7
  int v3; // [esp+8h] [ebp-Ch]
  int i; // [esp+Ch] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_816E4 )
      break;
    v3 = *(_DWORD *)(dword_816E8 + 4 * i);
    if ( *(int *)(v3 + 616) <= 0 )
      v1 = 1.0 / 300.0;
    else
      v1 = 1.0 / (long double)*(int *)(v3 + 616);
    *(float *)(v3 + 1064) = v1;
    if ( *(int *)(v3 + 620) <= 0 )
      v2 = 1.0 / 500.0;
    else
      v2 = 1.0 / (long double)*(int *)(v3 + 620);
    *(float *)(v3 + 1068) = v2;
  }
  return result;
}
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;

//----- (0002B0B5) --------------------------------------------------------
int BG_FillInWeaponItems()
{
  int result; // eax
  size_t v1; // eax
  _DWORD *v2; // [esp+14h] [ebp-14h]
  _DWORD *v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+18h] [ebp-10h]
  int v5; // [esp+18h] [ebp-10h]
  int j; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  v2 = (_DWORD *)((char *)&bg_itemlist + 48);
  for ( i = 1; i <= dword_816E4; ++i )
  {
    v3 = *(_DWORD **)(dword_816E8 + 4 * i);
    *v2 = v3[97];
    v2[1] = v3[35];
    v2[2] = v3[98];
    v2[3] = 0;
    v2[4] = v3[99];
    v2[5] = v3[101];
    v2[6] = v3[2];
    v2[7] = v3[102];
    v2[8] = 1;
    v2[9] = i;
    v2[10] = v3[104];
    v2[11] = v3[106];
    v2 += 12;
  }
  while ( 1 )
  {
    result = i;
    if ( i >= bg_numItems )
      return result;
    if ( v2[8] == 2 )
    {
      for ( j = 1; j <= dword_816E4; ++j )
      {
        v4 = *(_DWORD *)(dword_816E8 + 4 * j);
        v1 = strlen(*(const char **)(v4 + 4));
        if ( !Q_stricmpn(v2[6], *(_DWORD *)(v4 + 4), v1) )
        {
          v2[9] = j;
          v2[10] = *(_DWORD *)(v4 + 416);
          v2[11] = *(_DWORD *)(v4 + 424);
          break;
        }
      }
      if ( v2[9] == -1 )
      {
        Com_Printf("^3WARNING^7: Could not find weapon for ammo item %s\n", v2[6]);
        v5 = *(_DWORD *)(dword_816E8 + 4);
        v2[9] = 1;
        v2[10] = *(_DWORD *)(v5 + 416);
        v2[11] = *(_DWORD *)(v5 + 424);
      }
    }
    ++i;
    v2 += 12;
  }
}
// 14DA0: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;

//----- (0002B2C9) --------------------------------------------------------
int BG_SetupAmmoIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_816E4 )
      break;
    v3 = *(_DWORD **)(dword_816E8 + 4 * i);
    Q_strlwr(v3[103]);
    for ( j = 0; j < dword_A5520; ++j )
    {
      if ( !Q_stricmp(*(int *)((char *)&dword_A5320 + (_DWORD)&dword_0[j]), v3[103]) )
      {
        v3[104] = j;
        if ( *(int *)((char *)&dword_A5420 + (_DWORD)&dword_0[j]) != v3[107] && j )
        {
          for ( k = 1; k < i; ++k )
          {
            v1 = *(_DWORD *)(dword_816E8 + 4 * k);
            if ( !Q_stricmp(*(int *)((char *)&dword_A5320 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 412))
              && *(_DWORD *)(v1 + 428) == *(int *)((char *)&dword_A5420 + (_DWORD)&dword_0[j]) )
            {
              Com_Error(1, byte_76EE0, v3[103]);
            }
          }
        }
        break;
      }
    }
    if ( j == dword_A5520 )
    {
      *(int *)((char *)&dword_A5320 + (_DWORD)&dword_0[j]) = v3[103];
      *(int *)((char *)&dword_A5420 + (_DWORD)&dword_0[j]) = v3[107];
      v3[104] = j;
      ++dword_A5520;
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15AB0: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;
// A5320: using guessed type int dword_A5320;
// A5420: using guessed type int dword_A5420;
// A5520: using guessed type int dword_A5520;

//----- (0002B4A0) --------------------------------------------------------
int BG_SetupSharedAmmoIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_816E4 )
      break;
    v3 = *(_DWORD **)(dword_816E8 + 4 * i);
    v3[110] = -1;
    if ( *(_BYTE *)v3[109] )
    {
      Com_DPrintf("%s: %s\n", v3[1]);
      Q_strlwr(v3[109]);
      for ( j = 0; j < dword_A5740; ++j )
      {
        if ( !Q_stricmp(*(int *)((char *)&dword_A5540 + (_DWORD)&dword_0[j]), v3[109]) )
        {
          v3[110] = j;
          if ( *(int *)((char *)&dword_A5640 + (_DWORD)&dword_0[j]) != v3[111] && j )
          {
            for ( k = 1; k < i; ++k )
            {
              v1 = *(_DWORD *)(dword_816E8 + 4 * k);
              if ( !Q_stricmp(*(int *)((char *)&dword_A5540 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 436))
                && *(_DWORD *)(v1 + 444) == *(int *)((char *)&dword_A5640 + (_DWORD)&dword_0[j]) )
              {
                Com_Error(1, byte_76F40, v3[109]);
              }
            }
          }
          break;
        }
      }
      if ( j == dword_A5740 )
      {
        *(int *)((char *)&dword_A5540 + (_DWORD)&dword_0[j]) = v3[109];
        *(int *)((char *)&dword_A5640 + (_DWORD)&dword_0[j]) = v3[111];
        v3[110] = j;
        ++dword_A5740;
      }
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15AB0: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;
// A5540: using guessed type int dword_A5540;
// A5640: using guessed type int dword_A5640;
// A5740: using guessed type int dword_A5740;

//----- (0002B6BC) --------------------------------------------------------
int BG_SetupClipIndexes()
{
  int result; // eax
  int v1; // [esp+20h] [ebp-18h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v3; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_816E4 )
      break;
    v3 = *(_DWORD **)(dword_816E8 + 4 * i);
    Q_strlwr(v3[105]);
    for ( j = 0; j < dword_A5960; ++j )
    {
      if ( !Q_stricmp(*(int *)((char *)&dword_A5760 + (_DWORD)&dword_0[j]), v3[105]) )
      {
        v3[106] = j;
        if ( *(int *)((char *)&dword_A5860 + (_DWORD)&dword_0[j]) != v3[108] && j )
        {
          for ( k = 1; k < i; ++k )
          {
            v1 = *(_DWORD *)(dword_816E8 + 4 * k);
            if ( !Q_stricmp(*(int *)((char *)&dword_A5760 + (_DWORD)&dword_0[j]), *(_DWORD *)(v1 + 420))
              && *(_DWORD *)(v1 + 432) == *(int *)((char *)&dword_A5860 + (_DWORD)&dword_0[j]) )
            {
              Com_Error(1, byte_76FC0, v3[103]);
            }
          }
        }
        break;
      }
    }
    if ( j == dword_A5960 )
    {
      *(int *)((char *)&dword_A5760 + (_DWORD)&dword_0[j]) = v3[105];
      *(int *)((char *)&dword_A5860 + (_DWORD)&dword_0[j]) = v3[108];
      v3[106] = j;
      ++dword_A5960;
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15AB0: using guessed type _DWORD __cdecl Q_strlwr(_DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;
// A5760: using guessed type int dword_A5760;
// A5860: using guessed type int dword_A5860;
// A5960: using guessed type int dword_A5960;

//----- (0002B893) --------------------------------------------------------
int sub_2B893()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-18h]
  int k; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int l; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  for ( i = 1; i <= dword_816E4; ++i )
    *(_DWORD *)(*(_DWORD *)(dword_816E8 + 4 * i) + 776) = 0;
  for ( j = 1; ; ++j )
  {
    result = j;
    if ( j > dword_816E4 )
      break;
    v3 = *(_DWORD *)(dword_816E8 + 4 * j);
    if ( !*(_DWORD *)(v3 + 776) && **(_BYTE **)(v3 + 772) )
    {
      for ( k = *(_DWORD *)(dword_816E8 + 4 * j); !*(_DWORD *)(k + 776); k = *(_DWORD *)(dword_816E8 + 4 * l) )
      {
        for ( l = 1; l <= dword_816E4; ++l )
        {
          v1 = *(_DWORD *)(dword_816E8 + 4 * l);
          if ( !strcasecmp(*(const char **)(k + 772), *(const char **)(v1 + 4)) )
          {
            *(_DWORD *)(k + 776) = l;
            if ( *(_DWORD *)(k + 120) != *(_DWORD *)(v1 + 120) )
              Com_Error(1, byte_77020, *(_DWORD *)(k + 4));
            if ( *(_DWORD *)(k + 124) != *(_DWORD *)(v1 + 124) )
              Com_Error(1, byte_77080, *(_DWORD *)(k + 4));
            break;
          }
        }
        if ( !*(_DWORD *)(k + 776) )
          Com_Error(1, byte_770E0, *(_DWORD *)(k + 772));
      }
      if ( k != v3 )
        Com_Error(1, byte_77120, *(_DWORD *)(v3 + 4));
    }
  }
  return result;
}
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;

//----- (0002BAB8) --------------------------------------------------------
int sub_2BAB8()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i > dword_816E4 )
      break;
    v1 = *(_DWORD *)(dword_816E8 + 4 * i);
    if ( **(_BYTE **)(v1 + 1044) )
    {
      if ( !G_GetHintStringIndex(v1 + 1048, *(char **)(v1 + 1044)) )
        Com_Error(1, byte_77160, 32);
    }
  }
  return result;
}
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;

//----- (0002BB4E) --------------------------------------------------------
int __cdecl compare_weaponfile_names(_DWORD *a1, _DWORD *a2)
{
  return Q_stricmp(*a1, *a2);
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0002BB88) --------------------------------------------------------
int BG_SetupWeaponInfo()
{
  char v1; // [esp+4h] [ebp-3144h]
  char v2; // [esp+4h] [ebp-3144h]
  char v3; // [esp+4h] [ebp-3144h]
  char v4; // [esp+8h] [ebp-3140h]
  char dest[8204]; // [esp+10h] [ebp-3138h] BYREF
  char *v6; // [esp+201Ch] [ebp-112Ch]
  char v7[4104]; // [esp+2020h] [ebp-1128h] BYREF
  size_t v8; // [esp+3028h] [ebp-120h]
  int v9; // [esp+302Ch] [ebp-11Ch] BYREF
  int s[66]; // [esp+3030h] [ebp-118h] BYREF
  size_t nmemb; // [esp+3138h] [ebp-10h]
  int i; // [esp+313Ch] [ebp-Ch]

  Com_DPrintf("----------------------\n", v1);
  Com_DPrintf("Game: BG_SetupWeaponInfo\n", v2);
  dword_816E8 = trap_GetWeaponInfoMemory(256, &v9);
  if ( !dword_816E8 )
    Com_Error(1, byte_77200, v4);
  memset(&dword_A5320, 0, 0x100u);
  memset(&dword_A5420, 0, sizeof(dword_A5420));
  dword_A5320 = (int)"none";
  dword_A5520 = 1;
  memset(&dword_A5760, 0, 0x100u);
  memset(&dword_A5860, 0, sizeof(dword_A5860));
  dword_A5760 = (int)"none";
  dword_A5960 = 1;
  memset(s, 0, 0xFCu);
  if ( v9 )
  {
    dword_816E4 = 0;
    for ( i = 1; i <= 63 && *(_DWORD *)(dword_816E8 + 4 * i); ++i )
      ++dword_816E4;
  }
  else
  {
    nmemb = trap_FS_GetFileList(bg_szWeaponsFolder[0], &unk_76D60, v7, 4096);
    v6 = v7;
    if ( (int)nmemb <= 0 )
      Com_Error(1, byte_77240, (char)bg_szWeaponsFolder[0]);
    if ( (int)nmemb > 63 )
      Com_Error(1, byte_77260, 63);
    i = 0;
    while ( i < (int)nmemb && i <= 62 )
    {
      v8 = strlen(v6);
      Com_DPrintf("Getting weapon file \"%s/%s\" for parsing\n", (char)bg_szWeaponsFolder[0]);
      s[i++] = (int)v6;
      v6 += v8 + 1;
    }
    qsort(s, nmemb, 4u, (__compar_fn_t)compare_weaponfile_names);
    dest[0] = 0;
    for ( i = 0; i < (int)nmemb; ++i )
    {
      if ( i > 0 )
        strcat(dest, " ");
      strcat(dest, (const char *)s[i]);
    }
    trap_SetConfigstring(7, dest);
    sub_2AC83((int)s, nmemb);
  }
  sub_2AFE4();
  BG_SetupAmmoIndexes();
  BG_SetupSharedAmmoIndexes();
  BG_SetupClipIndexes();
  BG_FillInWeaponItems();
  sub_2B893();
  sub_2BAB8();
  return Com_DPrintf("----------------------\n", v3);
}
// 2BBA6: variable 'v1' is possibly undefined
// 2BBB4: variable 'v2' is possibly undefined
// 2BBEF: variable 'v4' is possibly undefined
// 2BEE1: variable 'v3' is possibly undefined
// 130C0: using guessed type int BG_SetupAmmoIndexes(void);
// 139F0: using guessed type int BG_FillInWeaponItems(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 140E0: using guessed type _DWORD __cdecl trap_GetWeaponInfoMemory(_DWORD, _DWORD);
// 14850: using guessed type int BG_SetupSharedAmmoIndexes(void);
// 14880: using guessed type _DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD);
// 14F30: using guessed type int BG_SetupClipIndexes(void);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;
// 81704: using guessed type char *bg_szWeaponsFolder[18];
// A5320: using guessed type int dword_A5320;
// A5420: using guessed type int dword_A5420;
// A5520: using guessed type int dword_A5520;
// A5760: using guessed type int dword_A5760;
// A5860: using guessed type int dword_A5860;
// A5960: using guessed type int dword_A5960;

//----- (0002BEEF) --------------------------------------------------------
int __cdecl BG_GetInfoForWeapon(int a1)
{
  return *(_DWORD *)(dword_816E8 + 4 * a1);
}
// 816E8: using guessed type int dword_816E8;

//----- (0002BF14) --------------------------------------------------------
int __cdecl BG_GetWeaponForInfo(int a1)
{
  return *(_DWORD *)a1;
}

//----- (0002BF1E) --------------------------------------------------------
int BG_GetNumWeapons()
{
  return dword_816E4;
}
// 816E4: using guessed type int dword_816E4;

//----- (0002BF36) --------------------------------------------------------
int BG_GetNumAmmoTypes()
{
  return dword_A5520;
}
// A5520: using guessed type int dword_A5520;

//----- (0002BF4E) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeMax(int a1)
{
  return *(int *)((char *)&dword_A5420 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A5420: using guessed type int dword_A5420;

//----- (0002BF6A) --------------------------------------------------------
int BG_GetNumAmmoClips()
{
  return dword_A5960;
}
// A5960: using guessed type int dword_A5960;

//----- (0002BF82) --------------------------------------------------------
int __cdecl BG_GetAmmoClipSize(int a1)
{
  return *(int *)((char *)&dword_A5860 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A5860: using guessed type int dword_A5860;

//----- (0002BF9E) --------------------------------------------------------
int __cdecl BG_GetSharedAmmoCapSize(int a1)
{
  return *(int *)((char *)&dword_A5640 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A5640: using guessed type int dword_A5640;

//----- (0002BFBA) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeName(int a1)
{
  return *(int *)((char *)&dword_A5320 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A5320: using guessed type int dword_A5320;

//----- (0002BFD6) --------------------------------------------------------
int __cdecl BG_GetAmmoClipName(int a1)
{
  return *(int *)((char *)&dword_A5760 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A5760: using guessed type int dword_A5760;

//----- (0002BFF2) --------------------------------------------------------
int __cdecl BG_GetAmmoTypeForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_A5520; ++i )
  {
    if ( !Q_stricmp(*(int *)((char *)&dword_A5320 + (_DWORD)&dword_0[i]), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo type \"%s\"\n", a1);
  return 0;
}
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// A5320: using guessed type int dword_A5320;
// A5520: using guessed type int dword_A5520;

//----- (0002C069) --------------------------------------------------------
int __cdecl BG_GetAmmoClipForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_A5960; ++i )
  {
    if ( !Q_stricmp(*(int *)((char *)&dword_A5760 + (_DWORD)&dword_0[i]), a1) )
      return i;
  }
  Com_DPrintf("Couldn't find ammo clip \"%s\"\n", a1);
  return 0;
}
// 0: using guessed type int dword_0[];
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// A5760: using guessed type int dword_A5760;
// A5960: using guessed type int dword_A5960;

//----- (0002C0E0) --------------------------------------------------------
int __cdecl BG_GetWeaponSlotForName(char *s1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 5; ++i )
  {
    if ( !strcasecmp(s1, *(const char **)((char *)off_81728 + (_DWORD)&dword_0[i])) )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 81728: using guessed type char *off_81728[9];

//----- (0002C13D) --------------------------------------------------------
int __cdecl BG_GetWeaponSlotNameForIndex(int a1)
{
  return *(int *)((char *)off_81728 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// 81728: using guessed type char *off_81728[9];

//----- (0002C159) --------------------------------------------------------
int __cdecl BG_GetWeaponIndexForName(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= dword_816E4; ++i )
  {
    if ( !Q_stricmp(a1, *(_DWORD *)(*(_DWORD *)(dword_816E8 + 4 * i) + 4)) )
      return (unsigned __int8)i;
  }
  Com_DPrintf("Couldn't find weapon \"%s\"\n", a1);
  return 0;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 816E4: using guessed type int dword_816E4;
// 816E8: using guessed type int dword_816E8;

//----- (0002C1DD) --------------------------------------------------------
int __cdecl BG_IsAimDownSightWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 716);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C206) --------------------------------------------------------
int __cdecl BG_GivePlayerWeapon(int a1, int a2)
{
  _DWORD *v4; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( Com_BitCheck(a1 + 780, a2) )
    return 0;
  v4 = (_DWORD *)BG_GetInfoForWeapon(a2);
  if ( v4[29] == 6 )
    return 0;
  if ( v4[29] == 7 )
    return 0;
  RegisterItem(a2, 1);
  Com_BitSet(a1 + 780, a2);
  Com_BitClear(a1 + 796, a2);
  v5 = v4[30];
  if ( v5 )
  {
    if ( v5 <= 2 )
    {
      if ( *(_BYTE *)(a1 + 789) )
      {
        if ( !*(_BYTE *)(a1 + 790) )
          *(_BYTE *)(a1 + 790) = a2;
      }
      else
      {
        *(_BYTE *)(a1 + 789) = a2;
      }
    }
    else if ( v5 <= 5 && !*(_BYTE *)(v5 + a1 + 788) )
    {
      *(_BYTE *)(v5 + a1 + 788) = a2;
    }
  }
  for ( i = v4[194]; i && !Com_BitCheck(a1 + 780, i); i = *(_DWORD *)(BG_GetInfoForWeapon(i) + 776) )
  {
    RegisterItem(i, 1);
    Com_BitSet(a1 + 780, i);
    Com_BitClear(a1 + 796, a2);
  }
  return 1;
}
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 149B0: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 159C0: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);

//----- (0002C3C9) --------------------------------------------------------
int __cdecl BG_TakePlayerWeapon(int a1, int a2)
{
  int v4; // [esp+14h] [ebp-14h]
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]
  int j; // [esp+20h] [ebp-8h]

  if ( !Com_BitCheck(a1 + 780, a2) )
    return 0;
  v5 = (_DWORD *)BG_GetInfoForWeapon(a2);
  v6 = BG_IsPlayerWeaponInSlot(a1, a2, 1);
  if ( v6 )
  {
    if ( v5[31] )
    {
      for ( i = 1; i <= dword_816E4; ++i )
      {
        v4 = BG_GetInfoForWeapon(a2);
        if ( *(_DWORD *)(v4 + 124)
          && *(_DWORD *)(v4 + 120) == v5[30]
          && Com_BitCheck(a1 + 780, i)
          && !BG_IsPlayerWeaponInSlot(a1, i, 1) )
        {
          *(_BYTE *)(v6 + a1 + 788) = i;
          break;
        }
      }
      if ( i > dword_816E4 )
        *(_BYTE *)(v6 + a1 + 788) = 0;
    }
    else
    {
      *(_BYTE *)(v6 + a1 + 788) = 0;
    }
  }
  Com_BitClear(a1 + 780, a2);
  for ( j = v5[194]; j && Com_BitCheck(a1 + 780, j); j = *(_DWORD *)(BG_GetInfoForWeapon(j) + 776) )
    Com_BitClear(a1 + 780, j);
  return 1;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 140C0: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 149B0: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 816E4: using guessed type int dword_816E4;

//----- (0002C583) --------------------------------------------------------
int __cdecl BG_SetPlayerWeaponForSlot(int a1, int a2, int a3)
{
  unsigned int v5; // [esp+10h] [ebp-8h]

  if ( Com_BitCheck(a1 + 780, a3) )
  {
    v5 = *(_DWORD *)(BG_GetInfoForWeapon(a3) + 120);
    if ( v5 )
    {
      if ( v5 <= 2 )
      {
        if ( a2 != 1 && a2 != 2 )
          return 0;
LABEL_13:
        *(_BYTE *)(a2 + a1 + 788) = a3;
        return 1;
      }
      if ( v5 <= 5 )
      {
        if ( a2 != v5 )
          return 0;
        goto LABEL_13;
      }
    }
    return 0;
  }
  return 0;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C636) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponInSlot(int a1, int a2, int a3)
{
  unsigned int v4; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( !Com_BitCheck(a1 + 780, a2) )
    return 0;
  v7 = a2;
  do
  {
    v6 = BG_GetInfoForWeapon(v7);
    v4 = *(_DWORD *)(v6 + 120);
    if ( !v4 )
      return 0;
    if ( v4 <= 2 )
    {
      if ( *(char *)(a1 + 789) == v7 )
        return 1;
      if ( *(char *)(a1 + 790) == v7 )
        return 2;
    }
    else
    {
      if ( v4 > 5 )
        return 0;
      if ( *(char *)(*(_DWORD *)(v6 + 120) + a1 + 788) == v7 )
        return *(_DWORD *)(v6 + 120);
    }
    if ( a3 && *(_DWORD *)(v6 + 776) )
      v7 = *(_DWORD *)(v6 + 776);
  }
  while ( v7 != a2 );
  return 0;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C738) --------------------------------------------------------
int __cdecl BG_GetEmptySlotForWeapon(int a1, int a2)
{
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 120);
  if ( !v4 )
    return 0;
  if ( v4 > 2 )
  {
    if ( v4 <= 5 && !*(_BYTE *)(v4 + a1 + 788) )
      return v4;
    return 0;
  }
  if ( !*(_BYTE *)(a1 + 789) )
    return 1;
  if ( *(_BYTE *)(a1 + 790) )
    return 0;
  return 2;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C7C8) --------------------------------------------------------
int __cdecl BG_GetStackSlotForWeapon(int a1, int a2, int a3)
{
  unsigned int v4; // [esp+8h] [ebp-10h]
  int v6; // [esp+10h] [ebp-8h]

  v6 = BG_GetInfoForWeapon(a2);
  if ( *(_DWORD *)(v6 + 124) )
  {
    v4 = *(_DWORD *)(v6 + 120);
    if ( v4 )
    {
      if ( v4 <= 2 )
      {
        if ( a3 == 1 || a3 == 2 )
        {
          if ( !*(_BYTE *)(a3 + a1 + 788) )
            return a3;
          if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a3 + a1 + 788)) + 124) )
            return a3;
        }
        if ( !*(_BYTE *)(a1 + 789) )
          return 1;
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a1 + 789)) + 124) )
          return 1;
        if ( !*(_BYTE *)(a1 + 790) )
          return 2;
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(a1 + 790)) + 124) )
          return 2;
      }
      else if ( v4 <= 5 )
      {
        if ( !*(_BYTE *)(*(_DWORD *)(v6 + 120) + a1 + 788) )
          return *(_DWORD *)(v6 + 120);
        if ( *(_DWORD *)(BG_GetInfoForWeapon(*(char *)(*(_DWORD *)(v6 + 120) + a1 + 788)) + 124) )
          return *(_DWORD *)(v6 + 120);
      }
    }
    return 0;
  }
  return 0;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C949) --------------------------------------------------------
int __cdecl BG_IsPlayerWeaponAnAlt(int a1, int a2)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = *(_DWORD *)(BG_GetInfoForWeapon(a1) + 776); i; i = *(_DWORD *)(BG_GetInfoForWeapon(i) + 776) )
  {
    if ( i == a2 )
      return 1;
    if ( i == a1 )
      return 0;
  }
  return 0;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002C9BF) --------------------------------------------------------
int __cdecl BG_GetMaxPickupableAmmo(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v7[64]; // [esp+10h] [ebp-228h] BYREF
  int s[66]; // [esp+110h] [ebp-128h] BYREF
  int v9; // [esp+218h] [ebp-20h]
  int v10; // [esp+21Ch] [ebp-1Ch]
  int v11; // [esp+220h] [ebp-18h]
  int v12; // [esp+224h] [ebp-14h]
  int v13; // [esp+228h] [ebp-10h]
  int i; // [esp+22Ch] [ebp-Ch]

  v10 = BG_AmmoForWeapon(a2);
  v9 = BG_ClipForWeapon(a2);
  memset(s, 0, 0x100u);
  memset(v7, 0, sizeof(v7));
  v13 = BG_GetInfoForWeapon(a2);
  if ( *(int *)(v13 + 440) < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
    {
      v4 = BG_GetAmmoClipSize(v9);
      v11 = v4 - *(_DWORD *)(a1 + 4 * v9 + 524);
    }
    else
    {
      v5 = BG_GetAmmoTypeMax(v10);
      v11 = v5 - *(_DWORD *)(a1 + 4 * v10 + 268);
    }
  }
  else
  {
    v11 = BG_GetSharedAmmoCapSize(*(_DWORD *)(v13 + 440));
    for ( i = 1; i <= dword_816E4; ++i )
    {
      if ( Com_BitCheck(a1 + 780, i) )
      {
        v12 = BG_GetInfoForWeapon(i);
        if ( *(_DWORD *)(v12 + 440) == *(_DWORD *)(v13 + 440) )
        {
          if ( BG_WeaponIsClipOnly(i) )
          {
            if ( !v7[BG_ClipForWeapon(i)] )
            {
              v7[BG_ClipForWeapon(i)] = 1;
              v2 = BG_ClipForWeapon(i);
              v11 -= *(_DWORD *)(a1 + 4 * v2 + 524);
            }
          }
          else if ( !s[BG_AmmoForWeapon(i)] )
          {
            s[BG_AmmoForWeapon(i)] = 1;
            v3 = BG_AmmoForWeapon(i);
            v11 -= *(_DWORD *)(a1 + 4 * v3 + 268);
          }
        }
      }
    }
  }
  return v11;
}
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 14D30: using guessed type _DWORD __cdecl BG_GetSharedAmmoCapSize(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 816E4: using guessed type int dword_816E4;

//----- (0002CBBD) --------------------------------------------------------
int __cdecl BG_GetTotalAmmoReserve(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v5[64]; // [esp+10h] [ebp-228h] BYREF
  int s[66]; // [esp+110h] [ebp-128h] BYREF
  int v7; // [esp+218h] [ebp-20h]
  int v8; // [esp+21Ch] [ebp-1Ch]
  int v9; // [esp+220h] [ebp-18h]
  int v10; // [esp+224h] [ebp-14h]
  int v11; // [esp+228h] [ebp-10h]
  int i; // [esp+22Ch] [ebp-Ch]

  v9 = 0;
  v8 = BG_AmmoForWeapon(a2);
  v7 = BG_ClipForWeapon(a2);
  memset(s, 0, 0x100u);
  memset(v5, 0, sizeof(v5));
  v11 = BG_GetInfoForWeapon(a2);
  if ( *(int *)(v11 + 440) < 0 )
  {
    if ( BG_WeaponIsClipOnly(a2) )
      v9 = *(_DWORD *)(a1 + 4 * v7 + 524);
    else
      v9 = *(_DWORD *)(a1 + 4 * v8 + 268);
  }
  else
  {
    for ( i = 1; i <= dword_816E4; ++i )
    {
      if ( Com_BitCheck(a1 + 780, i) )
      {
        v10 = BG_GetInfoForWeapon(i);
        if ( *(_DWORD *)(v10 + 440) == *(_DWORD *)(v11 + 440) )
        {
          if ( BG_WeaponIsClipOnly(i) )
          {
            if ( !v5[BG_ClipForWeapon(i)] )
            {
              v5[BG_ClipForWeapon(i)] = 1;
              v2 = BG_ClipForWeapon(i);
              v9 += *(_DWORD *)(a1 + 4 * v2 + 524);
            }
          }
          else if ( !s[BG_AmmoForWeapon(i)] )
          {
            s[BG_AmmoForWeapon(i)] = 1;
            v3 = BG_AmmoForWeapon(i);
            v9 += *(_DWORD *)(a1 + 4 * v3 + 268);
          }
        }
      }
    }
  }
  return v9;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 816E4: using guessed type int dword_816E4;

//----- (0002CD90) --------------------------------------------------------
long double __cdecl BG_GetMinSpreadForWeapon(int a1, int a2, int a3)
{
  long double v3; // fst7
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+18h] [ebp-10h]
  float *v7; // [esp+20h] [ebp-8h]

  v7 = (float *)BG_GetInfoForWeapon(a2);
  if ( (long double)*(int *)(a1 + 216) != *(float *)(a1 + 208) && *(_DWORD *)(a1 + 212) )
  {
    v6 = (long double)(a3 - *(_DWORD *)(a1 + 212))
       / (long double)(int)PM_GetViewHeightLerpTime(a1, *(_DWORD *)(a1 + 216), *(_DWORD *)(a1 + 220));
    if ( v6 >= 0.0 )
    {
      if ( v6 > 1.0 )
        v6 = 1.0;
    }
    else
    {
      v6 = 0.0;
    }
    if ( *(_DWORD *)(a1 + 216) == *(_DWORD *)(a1 + 828) )
    {
      v5 = (v7[145] - v7[144]) * v6 + v7[144];
    }
    else if ( *(_DWORD *)(a1 + 216) == *(_DWORD *)(a1 + 836) )
    {
      v5 = (v7[143] - v7[144]) * v6 + v7[144];
    }
    else
    {
      if ( *(_DWORD *)(a1 + 220) )
        v3 = (v7[144] - v7[143]) * v6 + v7[143];
      else
        v3 = (v7[144] - v7[145]) * v6 + v7[145];
      v5 = v3;
    }
  }
  else if ( (*(_DWORD *)(a1 + 12) & 1) != 0 )
  {
    v5 = v7[145];
  }
  else if ( (*(_DWORD *)(a1 + 12) & 2) != 0 )
  {
    v5 = v7[144];
  }
  else
  {
    v5 = v7[143];
  }
  return v5;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14C90: using guessed type _DWORD __cdecl PM_GetViewHeightLerpTime(_DWORD, _DWORD, _DWORD);

//----- (0002CF6C) --------------------------------------------------------
int PM_UpdateAimDownSightFlag()
{
  int result; // eax

  if ( *(int *)(*pm + 4) > 5
    || (*(_BYTE *)(pm + 8) & 0x10) == 0
    || !*(_DWORD *)(pml[34] + 716)
    || *(_DWORD *)(*pm + 180) == 2
    || *(_DWORD *)(*pm + 180) == 1
    || *(_DWORD *)(*pm + 180) == 10
    || *(_DWORD *)(*pm + 180) == 11
    || !pml[13] && *(_DWORD *)(*pm + 4) != 1 )
  {
    *(_DWORD *)(*pm + 12) &= 0xFFFFFFDF;
  }
  else if ( (*(_DWORD *)(*pm + 12) & 1) != 0 )
  {
    if ( (*(_BYTE *)(pm + 32) & 0x10) == 0 || !*(_BYTE *)(pm + 24) && !*(_BYTE *)(pm + 25) )
    {
      *(_DWORD *)(*pm + 12) |= 0x20u;
      *(_DWORD *)(*pm + 12) |= 0x400u;
    }
  }
  else
  {
    *(_DWORD *)(*pm + 12) |= 0x20u;
  }
  if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 )
    result = BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 7, 1, 1);
  else
    result = BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 7, 0, 1);
  return result;
}
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002D17A) --------------------------------------------------------
unsigned int PM_ClearAimDownSightFlag()
{
  unsigned int result; // eax

  result = *(_DWORD *)(*pm + 12) & 0xFFFFFFDF;
  *(_DWORD *)(*pm + 12) = result;
  return result;
}

//----- (0002D1A9) --------------------------------------------------------
void PM_UpdateAimDownSightLerp()
{
  long double v0; // fst7
  int v1; // [esp+0h] [ebp-8h]

  if ( *(_DWORD *)(pml[34] + 716) )
  {
    v1 = 0;
    if ( !*(_DWORD *)(pml[34] + 760)
      && *(_DWORD *)(*pm + 180) == 5
      && *(_DWORD *)(*pm + 44) - *(_DWORD *)(pml[34] + 992) > 0
      || *(_DWORD *)(pml[34] + 760)
      && (*(_DWORD *)(*pm + 180) == 5
       || *(_DWORD *)(*pm + 180) == 6
       || *(_DWORD *)(*pm + 180) == 7
       || *(_DWORD *)(*pm + 180) == 8
       || *(_DWORD *)(*pm + 180) == 9 && *(_DWORD *)(*pm + 44) - *(_DWORD *)(pml[34] + 992) > 0)
      || !*(_DWORD *)(pml[34] + 720) && *(_DWORD *)(*pm + 180) == 4 )
    {
      v1 = 0;
    }
    else if ( (*(_DWORD *)(*pm + 12) & 0x20) != 0 )
    {
      v1 = 1;
    }
    if ( *(_DWORD *)(pml[34] + 744) && *(_DWORD *)(*pm + 48) && *(_DWORD *)(*pm + 180) == 3 )
      v1 = 1;
    if ( v1 && *(float *)(*pm + 184) != 1.0 || !v1 && *(float *)(*pm + 184) != 0.0 )
    {
      if ( v1 )
        v0 = (long double)(int)pml[10] * *(float *)(pml[34] + 1064) + *(float *)(*pm + 184);
      else
        v0 = *(float *)(*pm + 184) - (long double)(int)pml[10] * *(float *)(pml[34] + 1068);
      *(float *)(*pm + 184) = v0;
      if ( *(float *)(*pm + 184) < 1.0 )
      {
        if ( *(float *)(*pm + 184) <= 0.0 )
          *(_DWORD *)(*pm + 184) = 0;
      }
      else
      {
        *(_DWORD *)(*pm + 184) = 1065353216;
      }
    }
  }
  else
  {
    *(_DWORD *)(*pm + 184) = 0;
  }
}

//----- (0002D4BC) --------------------------------------------------------
int PM_InteruptWeaponWithProneMove()
{
  if ( !*(_DWORD *)(*pm + 180)
    || *(_DWORD *)(*pm + 180) == 1
    || *(_DWORD *)(*pm + 180) == 2
    || *(_DWORD *)(*pm + 180) == 5
    || *(_DWORD *)(*pm + 180) == 7
    || *(_DWORD *)(*pm + 180) == 9
    || *(_DWORD *)(*pm + 180) == 8
    || *(_DWORD *)(*pm + 180) == 6 )
  {
    return 1;
  }
  if ( *(_DWORD *)(*pm + 180) == 3 || *(_DWORD *)(*pm + 180) == 11 )
    return 0;
  *(_DWORD *)(*pm + 44) = 0;
  *(_DWORD *)(*pm + 48) = 0;
  *(_DWORD *)(*pm + 180) = 0;
  sub_2DA19(0);
  return 1;
}

//----- (0002D5F8) --------------------------------------------------------
int __cdecl BG_ClipForWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 424);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002D621) --------------------------------------------------------
int __cdecl BG_AmmoForWeapon(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 416);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002D64A) --------------------------------------------------------
int __cdecl BG_WeaponIsClipOnly(int a1)
{
  return *(_DWORD *)(BG_GetInfoForWeapon(a1) + 736);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0002D673) --------------------------------------------------------
int __cdecl BG_WeaponAmmo(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]

  v3 = BG_AmmoForWeapon(a2);
  return *(_DWORD *)(a1 + 4 * v3 + 268) + *(_DWORD *)(a1 + 4 * BG_ClipForWeapon(a2) + 524);
}
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002D6C3) --------------------------------------------------------
int sub_2D6C3()
{
  int result; // eax
  int v1; // esi
  int v2; // esi
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  if ( *(_DWORD *)(*pm + 180) != 7 && *(_DWORD *)(*pm + 180) != 8 || (result = pml[34], *(_DWORD *)(result + 768)) )
  {
    v7 = BG_AmmoForWeapon(*(_DWORD *)(*pm + 176));
    v6 = BG_ClipForWeapon(*(_DWORD *)(*pm + 176));
    v5 = *(_DWORD *)(*pm + 4 * v7 + 268);
    v4 = *(_DWORD *)(*pm + 4 * v6 + 524);
    v3 = BG_GetAmmoClipSize(v6) - v4;
    if ( v3 > v5 )
      v3 = v5;
    if ( *(_DWORD *)(*pm + 180) == 7 || *(_DWORD *)(*pm + 180) == 8 )
    {
      v1 = pml[34];
      result = BG_GetAmmoClipSize(v6);
      if ( *(_DWORD *)(v1 + 768) < result )
      {
        result = v3;
        if ( v3 > *(_DWORD *)(pml[34] + 768) )
        {
          result = *(_DWORD *)(pml[34] + 768);
          v3 = result;
        }
      }
    }
    else
    {
      result = pml[34];
      if ( *(_DWORD *)(result + 764) )
      {
        v2 = pml[34];
        result = BG_GetAmmoClipSize(v6);
        if ( *(_DWORD *)(v2 + 764) < result )
        {
          result = v3;
          if ( v3 > *(_DWORD *)(pml[34] + 764) )
          {
            result = *(_DWORD *)(pml[34] + 764);
            v3 = result;
          }
        }
      }
    }
    if ( v3 )
    {
      *(_DWORD *)(*pm + 4 * v7 + 268) -= v3;
      result = *(_DWORD *)(*pm + 4 * v6 + 524) + v3;
      *(_DWORD *)(*pm + 4 * v6 + 524) = result;
    }
  }
  return result;
}
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002D8DB) --------------------------------------------------------
int __cdecl PM_WeaponUseAmmo(int a1, int a2)
{
  int v2; // edi
  int result; // eax

  v2 = BG_ClipForWeapon(a1);
  result = *(_DWORD *)(*pm + 4 * v2 + 524) - a2;
  *(_DWORD *)(*pm + 4 * v2 + 524) = result;
  return result;
}
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002D932) --------------------------------------------------------
int __cdecl PM_WeaponAmmoAvailable(int a1)
{
  return *(_DWORD *)(*pm + 4 * BG_ClipForWeapon(a1) + 524);
}
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002D96C) --------------------------------------------------------
_BOOL4 __cdecl PM_WeaponClipEmpty(int a1)
{
  int v1; // esi

  v1 = *pm;
  return *(_DWORD *)(v1 + 4 * BG_ClipForWeapon(a1) + 524) == 0;
}
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002D9B8) --------------------------------------------------------
int __cdecl sub_2D9B8(int a1)
{
  int result; // eax

  result = *pm;
  if ( *(int *)(*pm + 4) <= 5 )
  {
    result = pm;
    if ( *(_BYTE *)(pm + 10) )
    {
      result = a1 | *(_DWORD *)(*pm + 980) & 0x200 ^ 0x200;
      *(_DWORD *)(*pm + 980) = result;
    }
  }
  return result;
}

//----- (0002DA19) --------------------------------------------------------
unsigned int __cdecl sub_2DA19(int a1)
{
  unsigned int result; // eax

  result = pm;
  if ( *(_BYTE *)(pm + 10) )
  {
    result = *(_DWORD *)(*pm + 980) & 0xFFFFFDFF;
    if ( result != a1 )
      result = sub_2D9B8(a1);
  }
  return result;
}

//----- (0002DA68) --------------------------------------------------------
int sub_2DA68()
{
  int result; // eax

  sub_2DA19(0);
  result = *pm;
  *(_DWORD *)(*pm + 180) = 0;
  return result;
}

//----- (0002DAA0) --------------------------------------------------------
int __cdecl sub_2DAA0(int a1)
{
  if ( !*(_DWORD *)(pml[34] + 712) || !Com_BitCheck(*pm + 796, *(_DWORD *)(*pm + 176)) )
    return 0;
  if ( *(_DWORD *)(*pm + 180) != 4
    || !a1
    || (Com_BitClear(*pm + 796, *(_DWORD *)(*pm + 176)), PM_AddEvent(163), !*(_DWORD *)(*pm + 44)) )
  {
    if ( !*(_DWORD *)(*pm + 44)
      || *(_DWORD *)(*pm + 180) != 3
      && *(_DWORD *)(*pm + 180) != 4
      && *(_DWORD *)(*pm + 180) != 10
      && *(_DWORD *)(*pm + 180) != 11
      && !*(_DWORD *)(*pm + 48) )
    {
      if ( *(_DWORD *)(*pm + 180) == 4 )
      {
        sub_2DA68();
      }
      else if ( !*(_DWORD *)(*pm + 180) )
      {
        if ( *(float *)(*pm + 184) <= 0.75 )
          sub_2D9B8(4);
        else
          sub_2D9B8(7);
        *(_DWORD *)(*pm + 180) = 4;
        *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 472);
        if ( *(_DWORD *)(pml[34] + 476) && *(_DWORD *)(pml[34] + 476) < *(_DWORD *)(pml[34] + 472) )
          *(_DWORD *)(*pm + 48) = *(_DWORD *)(pml[34] + 476);
        else
          *(_DWORD *)(*pm + 48) = 1;
        PM_AddEvent(162);
      }
    }
    return 0;
  }
  return 1;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 149B0: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);

//----- (0002DD15) --------------------------------------------------------
int sub_2DD15()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(*pm + 180) == 7 || *(_DWORD *)(*pm + 180) == 8 )
  {
    if ( *(_DWORD *)(pml[34] + 504) )
    {
      if ( *(_DWORD *)(pml[34] + 504) >= *(_DWORD *)(pml[34] + 500) )
        v1 = *(_DWORD *)(pml[34] + 500);
      else
        v1 = *(_DWORD *)(pml[34] + 504);
    }
    else
    {
      v1 = 0;
    }
  }
  else
  {
    if ( *(_DWORD *)(*pm + 4 * BG_ClipForWeapon(*(_DWORD *)(*pm + 176)) + 524) || *(_DWORD *)(pml[34] + 112) )
      v1 = *(_DWORD *)(pml[34] + 488);
    else
      v1 = *(_DWORD *)(pml[34] + 492);
    if ( *(_DWORD *)(pml[34] + 496) && *(_DWORD *)(pml[34] + 496) < v1 )
      v1 = *(_DWORD *)(pml[34] + 496);
  }
  result = pml[34];
  if ( *(_DWORD *)(result + 712) && (result = Com_BitCheck(*pm + 796, *(_DWORD *)(*pm + 176))) != 0 )
  {
    if ( !v1 )
      v1 = *(_DWORD *)(*pm + 44);
    if ( *(_DWORD *)(pml[34] + 476) < v1 )
      v1 = *(_DWORD *)(pml[34] + 476);
    if ( !v1 )
      v1 = 1;
    result = v1;
    *(_DWORD *)(*pm + 48) = v1;
  }
  else if ( v1 )
  {
    result = v1;
    *(_DWORD *)(*pm + 48) = v1;
  }
  return result;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002DF40) --------------------------------------------------------
int sub_2DF40()
{
  if ( *(_DWORD *)(*pm + 4 * BG_ClipForWeapon(*(_DWORD *)(*pm + 176)) + 524) || *(_DWORD *)(pml[34] + 112) )
  {
    sub_2D9B8(11);
    *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 488);
    PM_AddEvent(151);
  }
  else
  {
    sub_2D9B8(12);
    *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 492);
    PM_AddEvent(152);
  }
  if ( *(_DWORD *)(*pm + 180) == 8 )
    *(_DWORD *)(*pm + 180) = 6;
  else
    *(_DWORD *)(*pm + 180) = 5;
  return sub_2DD15();
}
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002E04E) --------------------------------------------------------
int sub_2E04E()
{
  int result; // eax
  int v1; // esi

  if ( !*(_DWORD *)(*pm + 180) || *(_DWORD *)(*pm + 180) == 3 || (result = *pm, *(_DWORD *)(*pm + 180) == 4) )
  {
    result = *pm;
    if ( *(_DWORD *)(*pm + 176) )
    {
      v1 = *pm;
      result = BG_GetNumWeapons();
      if ( *(_DWORD *)(v1 + 176) <= result )
      {
        if ( !BG_WeaponIsClipOnly(*(_DWORD *)(*pm + 176)) )
          BG_AnimScriptEvent(*pm, 10, 0, 1);
        if ( *(_DWORD *)(pml[34] + 760) && *(_DWORD *)(pml[34] + 500) )
        {
          sub_2D9B8(13);
          *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 500);
          *(_DWORD *)(*pm + 180) = 7;
          PM_AddEvent(153);
          result = sub_2DD15();
        }
        else
        {
          result = sub_2DF40();
        }
      }
    }
  }
  return result;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002E19F) --------------------------------------------------------
void __cdecl sub_2E19F(int a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]

  if ( a2 >= 0 && a2 <= BG_GetNumWeapons() && (!a2 || Com_BitCheck(*pm + 780, a2)) && *(_DWORD *)(*pm + 180) != 2 )
  {
    *(_DWORD *)(*pm + 48) = 0;
    if ( a1 && Com_BitCheck(*pm + 780, a1) && *(int *)(*pm + 52) <= 0 )
    {
      v6 = (_DWORD *)BG_GetInfoForWeapon(a1);
      BG_GetInfoForWeapon(a2);
      v4 = 0;
      if ( a2 && a2 == v6[194] )
        v4 = 1;
      v7 = 1;
      if ( BG_WeaponIsClipOnly(a1) )
      {
        v2 = *pm;
        if ( !*(_DWORD *)(v2 + 4 * BG_ClipForWeapon(a1) + 524) )
          v7 = 0;
      }
      *(_DWORD *)(*pm + 52) = 0;
      if ( v4 )
      {
        PM_AddEvent(157);
        sub_2D9B8(15);
      }
      else if ( v7 )
      {
        PM_AddEvent(156);
        sub_2D9B8(9);
      }
      if ( !v4 )
        BG_AnimScriptEvent(*pm, 6, 0, 0);
      *(_DWORD *)(*pm + 180) = 2;
      PM_SetProneMovementOverride();
      if ( v4 )
        v3 = v6[130];
      else
        v3 = v6[128];
      *(_DWORD *)(*pm + 44) = v3;
      if ( v4 )
      {
        v5 = BG_IsPlayerWeaponInSlot(*pm, a1, 1);
        if ( v5 )
          BG_SetPlayerWeaponForSlot(*pm, v5, a2);
      }
    }
    else
    {
      *(_DWORD *)(*pm + 44) = 0;
      *(_DWORD *)(*pm + 180) = 2;
      *(_DWORD *)(*pm + 52) = 0;
      PM_SetProneMovementOverride();
    }
  }
}
// 12FF0: using guessed type int PM_SetProneMovementOverride(void);
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 140C0: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 15900: using guessed type _DWORD __cdecl BG_SetPlayerWeaponForSlot(_DWORD, _DWORD, _DWORD);

//----- (0002E43D) --------------------------------------------------------
int sub_2E43D()
{
  int v0; // eax
  int v1; // esi
  int v2; // esi
  int v3; // esi
  int v4; // eax
  int v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(*pm + 180) != 2 )
    return 0;
  if ( (*(_DWORD *)(*pm + 12) & 0x10) == 0
    && Com_BitCheck(*pm + 780, *(unsigned __int8 *)(pm + 10))
    && (*(_DWORD *)(*pm + 12) & 0x100000) == 0
    && Com_BitCheck(*pm + 780, *(unsigned __int8 *)(pm + 10)) )
  {
    v8 = *(unsigned __int8 *)(pm + 10);
    if ( v8 > BG_GetNumWeapons() )
      v8 = 0;
    v0 = Com_BitCheck(*pm + 780, v8);
  }
  else
  {
    v8 = 0;
    v0 = Com_BitCheck(*pm + 780, 0);
  }
  if ( !v0 )
    v8 = 0;
  v9 = *(_DWORD *)(*pm + 176);
  *(_DWORD *)(*pm + 176) = (unsigned __int8)v8;
  pml[34] = BG_GetInfoForWeapon(*(_DWORD *)(*pm + 176));
  if ( v9 == v8 )
  {
    *(_DWORD *)(*pm + 180) = 0;
    sub_2D9B8(0);
    v7 = 1;
  }
  else if ( v9 )
  {
    *(_DWORD *)(*pm + 180) = 1;
    PM_SetProneMovementOverride();
    v6 = 0;
    if ( v8 && v8 == *(_DWORD *)(BG_GetInfoForWeapon(v9) + 776) )
      v6 = 1;
    if ( v6 )
    {
      v2 = *pm;
      *(_DWORD *)(v2 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 524);
    }
    else
    {
      PM_AddEvent(155);
      v3 = *pm;
      *(_DWORD *)(v3 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 516);
    }
    BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 0, v8, 1);
    v4 = BG_GetInfoForWeapon(v8);
    BG_UpdateConditionValue(*(_DWORD *)(*pm + 172), 1, *(_DWORD *)(v4 + 116), 1);
    if ( v8 && v8 == *(_DWORD *)(BG_GetInfoForWeapon(v9) + 776) )
    {
      if ( *(float *)(*pm + 984) < 128.0 )
        *(_DWORD *)(*pm + 984) = 1124073472;
      sub_2D9B8(16);
    }
    else
    {
      BG_AnimScriptEvent(*pm, 7, 0, 0);
      *(_DWORD *)(*pm + 984) = 1132396544;
      sub_2D9B8(10);
    }
    v7 = 1;
  }
  else
  {
    *(_DWORD *)(*pm + 180) = 1;
    v1 = *pm;
    *(_DWORD *)(v1 + 44) = *(_DWORD *)(BG_GetInfoForWeapon(v8) + 516);
    *(_DWORD *)(*pm + 984) = 1132396544;
    sub_2D9B8(10);
    PM_SetProneMovementOverride();
    v7 = 1;
  }
  return v7;
}
// 12FF0: using guessed type int PM_SetProneMovementOverride(void);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 14A90: using guessed type _DWORD __cdecl BG_UpdateConditionValue(_DWORD, _DWORD, _DWORD, _DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0002E7F9) --------------------------------------------------------
int sub_2E7F9()
{
  if ( *(_DWORD *)(*pm + 180) != 1 )
    return 0;
  *(_DWORD *)(*pm + 180) = 0;
  sub_2D9B8(0);
  return 1;
}

//----- (0002E857) --------------------------------------------------------
int sub_2E857()
{
  int v0; // edi
  int v1; // esi
  int v4; // [esp+18h] [ebp-10h]

  v4 = BG_ClipForWeapon(*(_DWORD *)(*pm + 176));
  if ( !*(_DWORD *)(*pm + 4 * BG_AmmoForWeapon(*(_DWORD *)(*pm + 176)) + 268) )
    return 0;
  v0 = *pm;
  if ( *(_DWORD *)(v0 + 4 * v4 + 524) >= BG_GetAmmoClipSize(v4) )
    return 0;
  if ( !*(_DWORD *)(pml[34] + 756) )
    return 1;
  if ( *(_DWORD *)(pml[34] + 764) )
  {
    v1 = pml[34];
    if ( *(_DWORD *)(v1 + 764) < BG_GetAmmoClipSize(v4) )
      return BG_GetAmmoClipSize(v4) - *(_DWORD *)(*pm + 4 * v4 + 524) >= *(_DWORD *)(pml[34] + 764);
  }
  return !*(_DWORD *)(*pm + 4 * v4 + 524);
}
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002E9AB) --------------------------------------------------------
int sub_2E9AB()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]
  int v3; // [esp+10h] [ebp-8h]

  if ( !*(_DWORD *)(pml[34] + 712) || !Com_BitCheck(*pm + 796, *(_DWORD *)(*pm + 176)) )
    return sub_2D6C3();
  Com_BitClear(*pm + 796, *(_DWORD *)(*pm + 176));
  PM_AddEvent(163);
  if ( *(_DWORD *)(*pm + 180) != 7 && *(_DWORD *)(*pm + 180) != 8 || (result = pml[34], *(_DWORD *)(result + 504)) )
  {
    if ( *(_DWORD *)(*pm + 44) )
    {
      if ( *(_DWORD *)(*pm + 180) == 7 || *(_DWORD *)(*pm + 180) == 8 )
      {
        v2 = *(_DWORD *)(pml[34] + 504) >= *(_DWORD *)(pml[34] + 500) ? *(_DWORD *)(pml[34] + 500) : *(_DWORD *)(pml[34] + 504);
      }
      else
      {
        v2 = *(_DWORD *)(*pm + 4 * BG_ClipForWeapon(*(_DWORD *)(*pm + 176)) + 524) || *(_DWORD *)(pml[34] + 112) ? *(_DWORD *)(pml[34] + 488) : *(_DWORD *)(pml[34] + 492);
        if ( *(_DWORD *)(pml[34] + 496) && *(_DWORD *)(pml[34] + 496) < v2 )
          v2 = *(_DWORD *)(pml[34] + 496);
      }
      v1 = *(_DWORD *)(pml[34] + 476) >= v2 ? 1 : *(_DWORD *)(pml[34] + 476);
      v3 = v2 - v1;
      if ( v3 > 0 )
      {
        result = v3;
        *(_DWORD *)(*pm + 48) = v3;
        return result;
      }
    }
    return sub_2D6C3();
  }
  return result;
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 149B0: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002EC3D) --------------------------------------------------------
int __cdecl sub_2EC3D(int a1)
{
  int v1; // esi

  if ( *(_DWORD *)(*pm + 180) != 7 && *(_DWORD *)(*pm + 180) != 8 )
  {
    if ( *(_DWORD *)(*pm + 180) == 9 )
    {
      *(_DWORD *)(*pm + 180) = 0;
      sub_2D9B8(0);
    }
    else if ( *(_DWORD *)(*pm + 180) == 5 || *(_DWORD *)(*pm + 180) == 6 )
    {
      if ( a1 )
      {
        sub_2E9AB();
        if ( *(_DWORD *)(*pm + 44) )
          return 1;
      }
      if ( !*(_DWORD *)(*pm + 44) )
      {
        Com_BitClear(*pm + 796, *(_DWORD *)(*pm + 176));
        if ( *(_DWORD *)(pml[34] + 760) )
        {
          if ( *(_DWORD *)(*pm + 180) != 6 && sub_2E857() )
          {
            sub_2DF40();
            return 1;
          }
          if ( *(_DWORD *)(pml[34] + 508) )
          {
            *(_DWORD *)(*pm + 180) = 9;
            sub_2D9B8(14);
            *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 508);
            PM_AddEvent(154);
            return 1;
          }
        }
        *(_DWORD *)(*pm + 180) = 0;
        sub_2D9B8(0);
      }
      if ( a1 )
        return 1;
    }
    return 0;
  }
  if ( a1 )
    sub_2E9AB();
  if ( *(_DWORD *)(*pm + 44) )
    return 1;
  if ( *(_DWORD *)(*pm + 180) != 8 || (v1 = *pm, !*(_DWORD *)(v1 + 4 * BG_ClipForWeapon(*(_DWORD *)(*pm + 176)) + 524)) )
  {
    if ( sub_2E857() )
    {
      sub_2DF40();
      return 1;
    }
  }
  Com_BitClear(*pm + 796, *(_DWORD *)(*pm + 176));
  if ( *(_DWORD *)(pml[34] + 508) )
  {
    *(_DWORD *)(*pm + 180) = 9;
    sub_2D9B8(14);
    *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 508);
    PM_AddEvent(154);
    return 1;
  }
  *(_DWORD *)(*pm + 180) = 0;
  sub_2D9B8(0);
  return 0;
}
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 149B0: using guessed type _DWORD __cdecl Com_BitClear(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);

//----- (0002EF8B) --------------------------------------------------------
int sub_2EF8B()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-14h]
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  v3 = 0;
  v4 = *(_BYTE *)(pm + 9) & 8;
  if ( *(_DWORD *)(pml[34] + 760)
    && (*(_DWORD *)(*pm + 180) == 7 || *(_DWORD *)(*pm + 180) == 5)
    && (*(_BYTE *)(pm + 8) & 1) != 0
    && (*(_BYTE *)(pm + 32) & 1) == 0 )
  {
    if ( *(_DWORD *)(*pm + 180) == 7 )
    {
      *(_DWORD *)(*pm + 180) = 8;
    }
    else if ( *(_DWORD *)(*pm + 180) == 5 )
    {
      *(_DWORD *)(*pm + 180) = 6;
    }
  }
  if ( *(_DWORD *)(*pm + 180) > 0xBu )
  {
LABEL_15:
    v2 = BG_ClipForWeapon(*(_DWORD *)(*pm + 176));
    v1 = BG_AmmoForWeapon(*(_DWORD *)(*pm + 176));
    if ( v4 && sub_2E857() )
      v3 = 1;
    result = v2;
    if ( !*(_DWORD *)(*pm + 4 * v2 + 524) )
    {
      result = v1;
      if ( *(_DWORD *)(*pm + 4 * v1 + 268) )
      {
        result = *pm;
        if ( *(_DWORD *)(*pm + 180) != 3 )
        {
          result = *(_DWORD *)(*pm + 12) & 1;
          if ( !result || (result = pm, !*(_BYTE *)(pm + 24)) && (result = pm, !*(_BYTE *)(pm + 25)) )
            v3 = 1;
        }
      }
    }
    if ( v3 )
      result = sub_2E04E();
  }
  else
  {
    result = *(_DWORD *)(*pm + 180);
    switch ( result )
    {
      case 0:
      case 3:
      case 4:
        goto LABEL_15;
      case 1:
      case 2:
      case 10:
      case 11:
        return result;
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        result = pm;
        if ( *(_DWORD *)(pm + 232) )
        {
          result = BG_WeaponIsClipOnly(*(_DWORD *)(*pm + 176));
          if ( !result )
            result = BG_AnimScriptEvent(*pm, 10, 0, 1);
        }
        break;
    }
  }
  return result;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002F1D6) --------------------------------------------------------
int sub_2F1D6()
{
  int result; // eax
  int v1; // esi
  int v2; // esi

  result = BG_WeaponIsClipOnly(*(_DWORD *)(*pm + 176));
  if ( result )
  {
    v1 = *pm;
    result = BG_ClipForWeapon(*(_DWORD *)(*pm + 176));
    if ( !*(_DWORD *)(v1 + 4 * result + 524) )
    {
      v2 = *pm;
      result = BG_AmmoForWeapon(*(_DWORD *)(*pm + 176));
      if ( !*(_DWORD *)(v2 + 4 * result + 268) )
      {
        BG_TakePlayerWeapon(*pm, *(_DWORD *)(*pm + 176));
        result = PM_AddEvent(149);
      }
    }
  }
  return result;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002F29F) --------------------------------------------------------
void PM_AdjustAimSpreadScale()
{
  long double v0; // fst7
  float v1; // [esp+0h] [ebp-38h]
  float v2; // [esp+4h] [ebp-34h]
  float v3; // [esp+14h] [ebp-24h]
  float v4; // [esp+20h] [ebp-18h]
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]
  int j; // [esp+30h] [ebp-8h]

  v4 = *(float *)(pml[34] + 588);
  if ( v4 == 0.0 )
  {
    v7 = 0.0;
    v6 = 1.0;
  }
  else
  {
    if ( *(_DWORD *)(*pm + 84) != 1023 || *(_DWORD *)(*pm + 4) == 1 )
    {
      if ( (*(_DWORD *)(*pm + 128) & 0x40) != 0 )
      {
        v4 = v4 * *(float *)(pml[34] + 608);
      }
      else if ( (*(_DWORD *)(*pm + 128) & 0x20) != 0 )
      {
        v4 = v4 * *(float *)(pml[34] + 604);
      }
    }
    else
    {
      v4 = v4 * 0.5;
    }
    v6 = v4 * *(float *)&pml[9];
    if ( *(float *)(*pm + 184) == 1.0 )
    {
      v7 = 0.0;
    }
    else
    {
      v5 = 0.0;
      if ( *(float *)(pml[34] + 596) != 0.0 )
      {
        for ( i = 0; i <= 1; ++i )
        {
          v2 = (long double)*(int *)(pm + 4 * i + 36) * 0.0054931641;
          v0 = (long double)*(int *)(pm + 4 * i + 12) * 0.0054931641;
          v1 = v0;
          AngleSubtract(v1, v2);
          v3 = fabs(v0);
          v5 = v3 * 0.0099999998 * *(float *)(pml[34] + 596) / *(float *)&pml[9] + v5;
        }
      }
      if ( *(float *)(pml[34] + 600) != 0.0 && (*(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25)) )
        v5 = v5 + *(float *)(pml[34] + 600);
      if ( *(_DWORD *)(*pm + 84) == 1023 && *(_DWORD *)(*pm + 4) != 1 )
      {
        for ( j = 0; j <= 1; ++j )
          v5 = 0.0099999998 * 128.0 + v5;
      }
      v7 = v5 * *(float *)&pml[9];
    }
  }
  *(float *)(*pm + 984) = (v7 - v6) * 255.0 + *(float *)(*pm + 984);
  if ( *(float *)(*pm + 984) >= 0.0 )
  {
    if ( *(float *)(*pm + 984) > 255.0 )
      *(_DWORD *)(*pm + 984) = 1132396544;
  }
  else
  {
    *(_DWORD *)(*pm + 984) = 0;
  }
}

//----- (0002F5CE) --------------------------------------------------------
int sub_2F5CE()
{
  if ( *(_DWORD *)(*pm + 44) )
  {
    *(_DWORD *)(*pm + 44) -= pml[10];
    if ( *(int *)(*pm + 44) <= 0 )
    {
      if ( *(_DWORD *)(pml[34] + 708)
        && (*(_BYTE *)(pm + 8) & 1) != 0
        && *(_DWORD *)(*pm + 176) == *(unsigned __int8 *)(pm + 10)
        && PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 176)) )
      {
        *(_DWORD *)(*pm + 44) = 1;
        if ( *(_DWORD *)(*pm + 180) == 4 )
        {
          sub_2DA68();
        }
        else if ( *(_DWORD *)(*pm + 180) == 3
               || *(_DWORD *)(*pm + 180) == 4
               || *(_DWORD *)(*pm + 180) == 10
               || *(_DWORD *)(*pm + 180) == 11 )
        {
          sub_2DA19(0);
          *(_DWORD *)(*pm + 180) = 0;
        }
      }
      else
      {
        *(_DWORD *)(*pm + 44) = 0;
      }
    }
  }
  if ( !*(_DWORD *)(*pm + 48) )
    return 0;
  *(_DWORD *)(*pm + 48) -= pml[10];
  if ( *(int *)(*pm + 48) > 0 )
    return 0;
  *(_DWORD *)(*pm + 48) = 0;
  return 1;
}
// 14FF0: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);

//----- (0002F7BE) --------------------------------------------------------
void sub_2F7BE()
{
  if ( !*(_DWORD *)(*pm + 44)
    || *(_DWORD *)(*pm + 180) == 5
    || *(_DWORD *)(*pm + 180) == 7
    || *(_DWORD *)(*pm + 180) == 9
    || *(_DWORD *)(*pm + 180) == 8
    || *(_DWORD *)(*pm + 180) == 6
    || *(_DWORD *)(*pm + 180) == 4
    || *(_DWORD *)(*pm + 180) != 3
    && *(_DWORD *)(*pm + 180) != 4
    && *(_DWORD *)(*pm + 180) != 10
    && *(_DWORD *)(*pm + 180) != 11
    && !*(_DWORD *)(*pm + 48) )
  {
    if ( (*(_DWORD *)(*pm + 12) & 0x10) != 0 )
    {
      if ( !*(_DWORD *)(*pm + 176) )
        return;
LABEL_27:
      sub_2E19F(*(_DWORD *)(*pm + 176), 0);
      return;
    }
    if ( (*(_DWORD *)(*pm + 12) & 0x100000) != 0 )
    {
      if ( !*(_DWORD *)(*pm + 176) )
        return;
      goto LABEL_27;
    }
    if ( *(_DWORD *)(*pm + 176) != *(unsigned __int8 *)(pm + 10)
      && ((*(_DWORD *)(*pm + 12) & 0x4000) == 0 || !*(_DWORD *)(*pm + 176))
      && (!*(_BYTE *)(pm + 10) || Com_BitCheck(*pm + 780, *(unsigned __int8 *)(pm + 10))) )
    {
      sub_2E19F(*(_DWORD *)(*pm + 176), *(unsigned __int8 *)(pm + 10));
      return;
    }
    if ( *(_DWORD *)(*pm + 176) && !Com_BitCheck(*pm + 780, *(_DWORD *)(*pm + 176)) )
      goto LABEL_27;
  }
}
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);

//----- (0002FA94) --------------------------------------------------------
int __cdecl sub_2FA94(int a1)
{
  if ( (*(_BYTE *)(pm + 8) & 1) != 0 || a1 )
    return 0;
  if ( *(_DWORD *)(*pm + 180) == 3 )
    sub_2DA19(0);
  *(_DWORD *)(*pm + 180) = 0;
  return 1;
}

//----- (0002FB0A) --------------------------------------------------------
int __cdecl sub_2FB0A(int a1)
{
  if ( *(_DWORD *)(pml[34] + 112) == 1 )
  {
    if ( !a1 )
    {
      if ( PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 176)) )
      {
        *(_DWORD *)(*pm + 52) = *(_DWORD *)(pml[34] + 528);
        sub_2D9B8(17);
        PM_AddEvent(158);
      }
      *(_DWORD *)(*pm + 48) = *(_DWORD *)(pml[34] + 480);
      *(_DWORD *)(*pm + 44) = 0;
    }
  }
  else
  {
    *(_DWORD *)(*pm + 48) = *(_DWORD *)(pml[34] + 460);
    *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 468);
    if ( *(_DWORD *)(pml[34] + 744) )
      *(_DWORD *)(*pm + 48) = (int)((1.0 - *(float *)(*pm + 184)) * (1.0 / *(float *)(pml[34] + 1064)));
    BG_AnimScriptEvent(*pm, 2, 0, 1);
    if ( *(_DWORD *)(pml[34] + 712) )
      Com_BitSet(*pm + 796, *(_DWORD *)(*pm + 176));
  }
  *(_DWORD *)(*pm + 180) = 3;
  return PM_SetProneMovementOverride();
}
// 12FF0: using guessed type int PM_SetProneMovementOverride(void);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 14FF0: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 159C0: using guessed type _DWORD __cdecl Com_BitSet(_DWORD, _DWORD);

//----- (0002FCF2) --------------------------------------------------------
int sub_2FCF2()
{
  return 1;
}

//----- (0002FCFC) --------------------------------------------------------
int sub_2FCFC()
{
  int v0; // esi
  int v3; // [esp+10h] [ebp-18h]
  _BOOL4 v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+1Ch] [ebp-Ch]

  v3 = 1;
  v5 = sub_2FCF2();
  if ( v5 <= PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 176)) )
    return 1;
  v0 = *pm;
  v4 = v5 <= *(_DWORD *)(v0 + 4 * BG_AmmoForWeapon(*(_DWORD *)(*pm + 176)) + 268);
  if ( *(_DWORD *)(pml[34] + 112) == 1 )
    v3 = 0;
  if ( v3 && !v4 )
    PM_AddEvent(149);
  if ( v4 )
  {
    sub_2E04E();
  }
  else
  {
    sub_2DA19(0);
    *(_DWORD *)(*pm + 44) += 500;
  }
  return 0;
}
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 14FF0: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0002FE12) --------------------------------------------------------
int sub_2FE12()
{
  int result; // eax

  if ( *(float *)(*pm + 184) <= 0.75 )
  {
    if ( PM_WeaponClipEmpty(*(_DWORD *)(*pm + 176)) )
      result = sub_2D9B8(3);
    else
      result = sub_2D9B8(2);
  }
  else if ( PM_WeaponClipEmpty(*(_DWORD *)(*pm + 176)) )
  {
    result = sub_2D9B8(6);
  }
  else
  {
    result = sub_2D9B8(5);
  }
  return result;
}
// 13AD0: using guessed type _DWORD __cdecl PM_WeaponClipEmpty(_DWORD);

//----- (0002FEB0) --------------------------------------------------------
void sub_2FEB0()
{
  if ( *(float *)(*pm + 184) != 1.0 )
  {
    *(float *)(*pm + 984) = *(float *)(pml[34] + 592) * 255.0 + *(float *)(*pm + 984);
    if ( *(float *)(*pm + 984) > 255.0 )
      *(_DWORD *)(*pm + 984) = 1132396544;
  }
}

//----- (0002FF54) --------------------------------------------------------
int __cdecl sub_2FF54(int a1)
{
  int result; // eax
  int v2; // eax

  sub_2FB0A(a1);
  result = sub_2FCFC();
  if ( result )
  {
    result = *pm;
    if ( !*(_DWORD *)(*pm + 48) )
    {
      if ( PM_WeaponAmmoAvailable(*(_DWORD *)(*pm + 176)) != -1 && (*(_WORD *)(*pm + 128) & 0xC000) == 0 )
      {
        v2 = sub_2FCF2();
        PM_WeaponUseAmmo(*(_DWORD *)(*pm + 176), v2);
      }
      if ( *(_DWORD *)(pml[34] + 112) == 1 )
        *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 468);
      sub_2FE12();
      if ( PM_WeaponClipEmpty(*(_DWORD *)(*pm + 176)) )
        PM_AddEvent(161);
      else
        PM_AddEvent(159);
      sub_2FEB0();
      result = sub_2F1D6();
    }
  }
  return result;
}
// 135C0: using guessed type _DWORD __cdecl PM_WeaponUseAmmo(_DWORD, _DWORD);
// 13AD0: using guessed type _DWORD __cdecl PM_WeaponClipEmpty(_DWORD);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 14FF0: using guessed type _DWORD __cdecl PM_WeaponAmmoAvailable(_DWORD);

//----- (0003007E) --------------------------------------------------------
int sub_3007E()
{
  if ( *(_DWORD *)(*pm + 44) < *(_DWORD *)(pml[34] + 484) - *(_DWORD *)(pml[34] + 464) )
    *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 484) - *(_DWORD *)(pml[34] + 464);
  PM_AddEvent(165);
  *(_DWORD *)(*pm + 180) = 11;
  return PM_SetProneMovementOverride();
}
// 12FF0: using guessed type int PM_SetProneMovementOverride(void);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);

//----- (00030125) --------------------------------------------------------
int sub_30125()
{
  int v1; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(*pm + 180) == 10 )
  {
    sub_3007E();
    v1 = 1;
  }
  else if ( *(_DWORD *)(*pm + 180) == 11 )
  {
    sub_2DA19(0);
    *(_DWORD *)(*pm + 180) = 0;
    v1 = 1;
  }
  else
  {
    v1 = 0;
  }
  return v1;
}

//----- (000301A4) --------------------------------------------------------
int __cdecl sub_301A4(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  result = pml[34];
  if ( *(_DWORD *)(result + 452) )
  {
    if ( !a1 )
    {
      if ( !*(_DWORD *)(*pm + 48)
        || *(_DWORD *)(*pm + 180) == 5
        || *(_DWORD *)(*pm + 180) == 7
        || *(_DWORD *)(*pm + 180) == 9
        || *(_DWORD *)(*pm + 180) == 8
        || (result = *pm, *(_DWORD *)(*pm + 180) == 6) )
      {
        if ( (*(_BYTE *)(pm + 8) & 0x20) != 0 )
        {
          result = *(_DWORD *)(*pm + 12) & 0x1000;
          if ( !result )
          {
            *(_DWORD *)(*pm + 12) |= 0x1000u;
            result = *(_DWORD *)(*pm + 180);
            v2 = result;
            if ( result < 1 || result > 2 && (result -= 10, (unsigned int)(v2 - 10) > 1) )
            {
              BG_AnimScriptEvent(*pm, 13, 0, 1);
              sub_2D9B8(8);
              PM_AddEvent(164);
              if ( *(_DWORD *)(pml[34] + 464) )
              {
                *(_DWORD *)(*pm + 44) = *(_DWORD *)(pml[34] + 484);
                *(_DWORD *)(*pm + 48) = *(_DWORD *)(pml[34] + 464);
                *(_DWORD *)(*pm + 180) = 10;
                result = PM_SetProneMovementOverride();
              }
              else
              {
                result = sub_3007E();
              }
            }
          }
        }
        else
        {
          result = *(_DWORD *)(*pm + 12) & 0xFFFFEFFF;
          *(_DWORD *)(*pm + 12) = result;
        }
      }
    }
  }
  return result;
}
// 12FF0: using guessed type int PM_SetProneMovementOverride(void);
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000303AD) --------------------------------------------------------
int PM_Weapon()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-Ch]

  result = *(_DWORD *)(*pm + 12) & 0x800;
  if ( !result )
  {
    if ( *(int *)(*pm + 4) > 5 )
    {
      result = *pm;
      *(_DWORD *)(*pm + 176) = 0;
      return result;
    }
    result = *(_WORD *)(*pm + 128) & 0xC000;
    if ( !(_WORD)result )
    {
      if ( bg_debugWeaponState[3] && bg_debugWeaponState[3] != 2 )
        sub_306DD();
      if ( bg_debugWeaponAnim[3] && bg_debugWeaponAnim[3] != 2 )
        sub_3084B();
      PM_UpdateAimDownSightLerp();
      if ( *(_DWORD *)(pml[34] + 112) == 1 && *(int *)(*pm + 52) > 0 )
      {
        if ( *(_DWORD *)(pml[34] + 732) )
          *(_DWORD *)(*pm + 52) -= pml[10];
        if ( *(int *)(*pm + 52) <= 50 )
        {
          *(_DWORD *)(*pm + 52) = 50;
          PM_AddEvent(159);
          result = *pm;
          *(_DWORD *)(*pm + 44) = 1600;
          return result;
        }
        if ( (*(_BYTE *)(pm + 8) & 1) != 0 && *(_DWORD *)(*pm + 48) - pml[10] <= 0 )
          *(_DWORD *)(*pm + 48) = pml[10] + 1;
        if ( (*(_BYTE *)(pm + 8) & 1) == 0 && *(_DWORD *)(*pm + 48) - pml[10] <= 0 )
          BG_AnimScriptEvent(*pm, 2, 0, 1);
      }
      v1 = sub_2F5CE();
      sub_2F7BE();
      sub_2EF8B();
      sub_301A4(v1);
      result = sub_2DAA0(v1);
      if ( !result )
      {
        if ( (*(_DWORD *)(*pm + 12) & 1) != 0 && (*(_BYTE *)(pm + 24) || *(_BYTE *)(pm + 25))
          || *(_DWORD *)(*pm + 180) == 10
          || *(_DWORD *)(*pm + 180) == 11 )
        {
          *(_DWORD *)(*pm + 984) = 1132396544;
        }
        if ( v1 || (result = *pm, !*(_DWORD *)(*pm + 44)) && (result = *pm, !*(_DWORD *)(*pm + 48)) )
        {
          result = sub_2EC3D(v1);
          if ( !result )
          {
            result = sub_30125();
            if ( !result )
            {
              result = sub_2E43D();
              if ( !result )
              {
                result = sub_2E7F9();
                if ( !result )
                {
                  result = *pm;
                  if ( *(_DWORD *)(*pm + 176) )
                  {
                    result = sub_2FA94(v1);
                    if ( !result )
                      result = sub_2FF54(v1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 13F70: using guessed type _DWORD __cdecl PM_AddEvent(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 15A80: using guessed type int PM_UpdateAimDownSightLerp(void);

//----- (000306DD) --------------------------------------------------------
int sub_306DD()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(*pm + 180);
  result = dword_816EC;
  if ( dword_816EC != v3 )
  {
    Com_Printf(" %i %s_", *(_DWORD *)(pm + 4));
    dword_816EC = v3;
    Com_Printf("WEAP_STATE -- ", v1);
    switch ( v3 )
    {
      case 0:
        result = Com_Printf("WEAPON_READY\n", v2);
        break;
      case 1:
        result = Com_Printf("WEAPON_RAISING\n", v2);
        break;
      case 2:
        result = Com_Printf("WEAPON_DROPPING\n", v2);
        break;
      case 3:
        result = Com_Printf("WEAPON_FIRING\n", v2);
        break;
      case 4:
        result = Com_Printf("WEAPON_RECHAMBERING\n", v2);
        break;
      case 5:
        result = Com_Printf("WEAPON_RELOADING\n", v2);
        break;
      case 6:
        result = Com_Printf("WEAPON_RELOADING_INTERUPT\n", v2);
        break;
      case 7:
        result = Com_Printf("WEAPON_RELOAD_START\n", v2);
        break;
      case 8:
        result = Com_Printf("WEAPON_RELOAD_START_INTERUPT\n", v2);
        break;
      case 9:
        result = Com_Printf("WEAPON_RELOAD_END\n", v2);
        break;
      case 10:
        result = Com_Printf("WEAPON_MELEE_WINDUP\n", v2);
        break;
      case 11:
        result = Com_Printf("WEAPON_MELEE_RELAX\n", v2);
        break;
      default:
        result = Com_Printf("UNKNOWN\n", v2);
        break;
    }
  }
  return result;
}
// 3074B: variable 'v1' is possibly undefined
// 30774: variable 'v2' is possibly undefined
// 816EC: using guessed type int dword_816EC;

//----- (0003084B) --------------------------------------------------------
int sub_3084B()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-14h]
  char v2; // [esp+4h] [ebp-14h]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v3 = *(_DWORD *)(*pm + 980) & 0xFFFFFDFF;
  Com_Printf(" %i %s_", *(_DWORD *)(pm + 4));
  dword_816F0 = v3;
  Com_Printf("WEAP_ANIM -- ", v1);
  switch ( v3 & 0xFFFFFDFF )
  {
    case 0u:
      result = Com_Printf("WEAP_IDLE\n", v2);
      break;
    case 2u:
      result = Com_Printf("WEAP_ATTACK\n", v2);
      break;
    case 3u:
      result = Com_Printf("WEAP_ATTACK_LASTSHOT\n", v2);
      break;
    case 4u:
      result = Com_Printf("WEAP_RECHAMBER\n", v2);
      break;
    case 5u:
      result = Com_Printf("WEAP_ADS_ATTACK\n", v2);
      break;
    case 6u:
      result = Com_Printf("WEAP_ADS_ATTACK_LASTSHOT\n", v2);
      break;
    case 7u:
      result = Com_Printf("WEAP_ADS_RECHAMBER\n", v2);
      break;
    case 8u:
      result = Com_Printf("WEAP_MELEE_ATTACK\n", v2);
      break;
    case 9u:
      result = Com_Printf("WEAP_DROP\n", v2);
      break;
    case 0xAu:
      result = Com_Printf("WEAP_RAISE\n", v2);
      break;
    case 0xBu:
      result = Com_Printf("WEAP_RELOAD\n", v2);
      break;
    case 0xCu:
      result = Com_Printf("WEAP_RELOAD_EMPTY\n", v2);
      break;
    case 0xDu:
      result = Com_Printf("WEAP_RELOAD_START\n", v2);
      break;
    case 0xEu:
      result = Com_Printf("WEAP_RELOAD_END\n", v2);
      break;
    case 0xFu:
      result = Com_Printf("WEAP_ALTSWITCHFROM\n", v2);
      break;
    case 0x10u:
      result = Com_Printf("WEAP_ALTSWITCHTO\n", v2);
      break;
    default:
      result = Com_Printf("UNKNOWN\n", v2);
      break;
  }
  return result;
}
// 308AE: variable 'v1' is possibly undefined
// 308E2: variable 'v2' is possibly undefined
// 816F0: using guessed type int dword_816F0;

//----- (00030A05) --------------------------------------------------------
long double __cdecl BG_GetBobCycle(int a1)
{
  long double v1; // fst6

  v1 = (long double)*(unsigned __int8 *)(a1 + 8) / 255.0 * 3.141592653589793;
  return (float)(v1 + v1 + 6.283185307179586);
}

//----- (00030A54) --------------------------------------------------------
long double __cdecl BG_GetVerticalBobFactor(int a1, float a2, float a3, float a4)
{
  float *v4; // eax
  float v6; // [esp+8h] [ebp-10h]
  float v7; // [esp+8h] [ebp-10h]
  float v8; // [esp+8h] [ebp-10h]
  float v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 204) == *(_DWORD *)(a1 + 828) )
  {
    v11 = a3 * bg_bobAmplitudeProne[2];
  }
  else
  {
    if ( *(_DWORD *)(a1 + 204) == *(_DWORD *)(a1 + 832) )
      v4 = (float *)&bg_bobAmplitudeDucked;
    else
      v4 = (float *)&bg_bobAmplitudeStanding;
    v11 = a3 * v4[2];
  }
  if ( v11 > (long double)a4 )
    v11 = a4;
  v6 = sin(a2 + a2);
  v10 = sin(a2 * 4.0 + 1.570796326794897);
  v7 = v10 * 0.2 + v6;
  v8 = 0.75 * v7;
  return (float)(v8 * v11);
}

//----- (00030B37) --------------------------------------------------------
long double __cdecl BG_GetHorizontalBobFactor(int a1, float a2, float a3, float a4)
{
  float *v4; // eax
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+10h] [ebp-8h]

  if ( *(_DWORD *)(a1 + 204) == *(_DWORD *)(a1 + 828) )
  {
    v7 = a3 * bg_bobAmplitudeProne[2];
  }
  else
  {
    if ( *(_DWORD *)(a1 + 204) == *(_DWORD *)(a1 + 832) )
      v4 = (float *)&bg_bobAmplitudeDucked;
    else
      v4 = (float *)&bg_bobAmplitudeStanding;
    v7 = a3 * v4[2];
  }
  if ( v7 > (long double)a4 )
    v7 = a4;
  v6 = sin(a2);
  return v6 * v7;
}

//----- (00030BD3) --------------------------------------------------------
void __cdecl sub_30BD3(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+14h] [ebp-34h]
  float *v4; // [esp+18h] [ebp-30h]
  int v5; // [esp+1Ch] [ebp-2Ch]
  float v6; // [esp+20h] [ebp-28h]
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  float v9; // [esp+30h] [ebp-18h]
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]

  v5 = *(_DWORD *)a1;
  v4 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( (*(_DWORD *)(v5 + 128) & 0x40) != 0 )
  {
    v9 = v4[96];
  }
  else if ( (*(_DWORD *)(v5 + 128) & 0x20) != 0 )
  {
    v9 = v4[95];
  }
  else
  {
    v9 = v4[94];
  }
  if ( a1[1] <= (long double)v9 || *(_DWORD *)(v5 + 180) == 5 )
  {
    v8 = 0.0;
    v7 = 0.0;
    v6 = 0.0;
  }
  else
  {
    v11 = (a1[1] - v9) / ((long double)*(int *)(v5 + 68) - v9);
    if ( v11 >= 0.0 && v11 > 1.0 )
    {
      v3 = 1.0;
    }
    else if ( v11 >= 0.0 )
    {
      v3 = v11;
    }
    else
    {
      v3 = 0.0;
    }
    v11 = v3;
    if ( (*(_DWORD *)(v5 + 128) & 0x40) != 0 )
    {
      v6 = v4[84] * v11;
      v7 = v4[85] * v11;
      v8 = v4[86] * v11;
    }
    else
    {
      if ( (*(_DWORD *)(v5 + 128) & 0x20) != 0 )
      {
        v6 = v4[75] * v11;
        v7 = v4[76] * v11;
        v2 = v4[77] * v11;
      }
      else
      {
        v6 = v4[66] * v11;
        v7 = v4[67] * v11;
        v2 = v4[68] * v11;
      }
      v8 = v2;
    }
  }
  if ( *(float *)(v5 + 184) != 0.0 )
  {
    v10 = 1.0 - *(float *)(v5 + 184);
    v6 = v6 * v10;
    v7 = v7 * v10;
    v8 = v8 * v10;
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a1[i + 3] != *(&v6 + i) )
    {
      if ( *(float *)(v5 + 208) == (long double)*(int *)(v5 + 828) )
        v10 = (*(&v6 + i) - a1[i + 3]) * a1[2] * v4[93];
      else
        v10 = (*(&v6 + i) - a1[i + 3]) * a1[2] * v4[92];
      if ( *(&v6 + i) <= (long double)a1[i + 3] )
      {
        if ( v10 > a1[2] * -0.1 )
          v10 = a1[2] * -0.1;
        a1[i + 3] = a1[i + 3] + v10;
        if ( *(&v6 + i) > (long double)a1[i + 3] )
          a1[i + 3] = *(&v6 + i);
      }
      else
      {
        if ( a1[2] * 0.1 > v10 )
          v10 = a1[2] * 0.1;
        a1[i + 3] = a1[i + 3] + v10;
        if ( a1[i + 3] > (long double)*(&v6 + i) )
          a1[i + 3] = *(&v6 + i);
      }
    }
  }
  if ( *(float *)(v5 + 184) == 0.0 )
  {
    *a2 = *a2 + a1[3];
    a2[1] = a2[1] + a1[4];
    a2[2] = a2[2] + a1[5];
  }
  else if ( *(float *)(v5 + 184) < 0.5 )
  {
    v10 = 1.0 - (*(float *)(v5 + 184) + *(float *)(v5 + 184));
    *a2 = a1[3] * v10 + *a2;
    a2[1] = a1[4] * v10 + a2[1];
    a2[2] = a1[5] * v10 + a2[2];
  }
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00031063) --------------------------------------------------------
void __cdecl sub_31063(float *a1, float *a2)
{
  int v2; // [esp+8h] [ebp-10h]
  int v3; // [esp+Ch] [ebp-Ch]

  v3 = *(_DWORD *)a1;
  v2 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v3 + 176)) )
    *a2 = *(float *)(v3 + 184) * *(float *)(v2 + 848) + *a2;
  sub_30BD3(a1, a2);
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14740: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (000310DE) --------------------------------------------------------
float *__cdecl sub_310DE(float *a1, float *a2)
{
  float *result; // eax
  float *v3; // [esp+18h] [ebp-20h]
  int v4; // [esp+1Ch] [ebp-1Ch]
  float v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+28h] [ebp-10h]
  float v8; // [esp+2Ch] [ebp-Ch]
  float v9; // [esp+2Ch] [ebp-Ch]
  float v10; // [esp+2Ch] [ebp-Ch]

  v4 = *(_DWORD *)a1;
  v3 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v4 + 176)) )
  {
    v6 = (v3[156] - v3[157]) * *(float *)(v4 + 184) + v3[157];
  }
  else if ( v3[157] == 0.0 )
  {
    v6 = 80.0;
  }
  else
  {
    v6 = v3[157];
  }
  if ( (*(_DWORD *)(v4 + 128) & 0x40) != 0 )
  {
    v5 = v3[159];
  }
  else if ( (*(_DWORD *)(v4 + 128) & 0x20) != 0 )
  {
    v5 = v3[158];
  }
  else
  {
    v5 = 1.0;
  }
  if ( v5 != a1[6] )
  {
    if ( v5 <= (long double)a1[6] )
    {
      a1[6] = a1[6] - a1[2] * 0.5;
      if ( v5 > (long double)a1[6] )
        a1[6] = v5;
    }
    else
    {
      a1[6] = a1[2] * 0.5 + a1[6];
      if ( a1[6] > (long double)v5 )
        a1[6] = v5;
    }
  }
  v7 = v6 * a1[6];
  v8 = sin((long double)*((int *)a1 + 7) * 0.00050000002);
  a2[2] = v7 * v8 * 0.039999999 + a2[2];
  v9 = sin((long double)*((int *)a1 + 7) * 0.00069999998);
  a2[1] = v7 * v9 * 0.0099999998 + a2[1];
  v10 = sin((long double)*((int *)a1 + 7) * 0.001);
  result = a2;
  *a2 = v7 * v10 * 0.0099999998 + *a2;
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14740: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (00031312) --------------------------------------------------------
float *__cdecl sub_31312(float *a1, float *a2)
{
  long double v2; // fst6
  long double v3; // fst7
  long double v4; // fst7
  long double v5; // fst7
  float *result; // eax
  float v7; // [esp+1Ch] [ebp-3Ch]
  int v8; // [esp+24h] [ebp-34h]
  int v9; // [esp+28h] [ebp-30h]
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h]
  float v12; // [esp+34h] [ebp-24h]
  float v13; // [esp+38h] [ebp-20h]
  float v14; // [esp+44h] [ebp-14h]
  float v15; // [esp+44h] [ebp-14h]
  float v16; // [esp+44h] [ebp-14h]
  float v17; // [esp+48h] [ebp-10h]
  float v18; // [esp+48h] [ebp-10h]
  float v19; // [esp+4Ch] [ebp-Ch]

  v9 = *(_DWORD *)a1;
  v8 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  v2 = (long double)*(unsigned __int8 *)(v9 + 8) / 255.0 * 3.141592653589793;
  v10 = v2 + v2 + 6.283185307179586;
  v17 = v10 + 0.7853981633974483 + 6.283185307179586;
  v3 = a1[1] * 0.16;
  v14 = v3;
  BG_GetVerticalBobFactor(v9, v17, v14, 10.0);
  v4 = v3 * -1.0;
  v11 = v4;
  BG_GetHorizontalBobFactor(v9, v17, v14, 10.0);
  v12 = v4 * -1.0;
  v18 = v17 - 0.4712389167638204;
  v5 = v14 * 1.5;
  v15 = v5;
  BG_GetHorizontalBobFactor(v9, v18, v15, 10.0);
  if ( v5 >= 0.0 )
  {
    v7 = 0.0;
  }
  else
  {
    BG_GetHorizontalBobFactor(v9, v18, v15, 10.0);
    v7 = v5;
  }
  v13 = v7;
  v19 = *(float *)(v9 + 184);
  if ( v19 != 0.0 )
  {
    v16 = 1.0 - (1.0 - *(float *)(v8 + 564)) * v19;
    v11 = v11 * v16;
    v12 = v12 * v16;
    v13 = v7 * v16;
  }
  *a2 = *a2 + v11;
  a2[1] = a2[1] + v12;
  result = a2 + 2;
  a2[2] = a2[2] + v13;
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00031501) --------------------------------------------------------
void __cdecl sub_31501(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+0h] [ebp-28h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  float v6; // [esp+14h] [ebp-14h]
  float v7; // [esp+18h] [ebp-10h]
  float v8; // [esp+1Ch] [ebp-Ch]
  float v9; // [esp+20h] [ebp-8h]
  float v10; // [esp+20h] [ebp-8h]
  float v11; // [esp+20h] [ebp-8h]
  float v12; // [esp+20h] [ebp-8h]
  float v13; // [esp+20h] [ebp-8h]
  float v14; // [esp+20h] [ebp-8h]

  if ( *((_DWORD *)a1 + 8) )
  {
    v5 = *(_DWORD *)a1;
    v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
    v8 = *(float *)(v5 + 184) * 0.5 + 0.5;
    v7 = v8 * 100.0;
    v6 = v8 * 400.0;
    if ( *(float *)(v5 + 184) != 0.0 && *(_DWORD *)(v4 + 552) )
      v8 = (1.0 - *(float *)(v5 + 184) * 0.75) * v8;
    v9 = (float)(*((_DWORD *)a1 + 7) - *((_DWORD *)a1 + 8));
    if ( v7 <= (long double)v9 )
    {
      v12 = 1.0 - (v9 - v7) / v6;
      if ( v12 > 0.0 )
      {
        v2 = 1.0 - v12;
        v3 = v2;
        GetLeanFraction(v3);
        v13 = 1.0 - v2;
        v14 = v13 * v8;
        *a2 = v14 * a1[9] * 0.5 + *a2;
        a2[1] = a2[1] - v14 * a1[10];
        a2[2] = v14 * a1[10] * 0.5 + a2[2];
      }
    }
    else
    {
      v10 = v9 / v7;
      GetLeanFraction(v10);
      v11 = v10 * v8;
      *a2 = v11 * a1[9] * 0.5 + *a2;
      a2[1] = a2[1] - v11 * a1[10];
      a2[2] = v11 * a1[10] * 0.5 + a2[2];
    }
  }
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0003171A) --------------------------------------------------------
int __cdecl sub_3171A(int a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v9; // [esp+4h] [ebp-8h]

  v9 = 0;
  if ( fabs(*(float *)a1) >= 0.25 || fabs(*(float *)a2) >= 1.0 )
  {
    *(float *)a1 = *(float *)a2 * a3 + *(float *)a1;
    if ( *(float *)a1 <= (long double)a4 )
    {
      if ( -a4 > (long double)*(float *)a1 )
      {
        *(_DWORD *)a1 = LODWORD(a4) ^ 0x80000000;
        if ( *(float *)a2 < 0.0 )
          *(_DWORD *)a2 = 0;
      }
    }
    else
    {
      *(float *)a1 = a4;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a1 <= 0.0 )
    {
      if ( *(float *)a1 < 0.0 )
        *(float *)a2 = a5 * a3 + *(float *)a2;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a5 * a3;
    }
    *(float *)a2 = *(float *)a2 - *(float *)a2 * a7 * a3;
    if ( *(float *)a2 <= 0.0 )
    {
      *(float *)a2 = a8 * a3 + *(float *)a2;
      if ( *(float *)a2 > 0.0 )
        *(_DWORD *)a2 = 0;
    }
    else
    {
      *(float *)a2 = *(float *)a2 - a8 * a3;
      if ( *(float *)a2 < 0.0 )
        *(_DWORD *)a2 = 0;
    }
    if ( *(float *)a2 <= (long double)a6 )
    {
      if ( -a6 > (long double)*(float *)a2 )
        *(_DWORD *)a2 = LODWORD(a6) ^ 0x80000000;
    }
    else
    {
      *(float *)a2 = a6;
    }
  }
  else
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)a2 = 0;
    v9 = 1;
  }
  return v9;
}

//----- (00031940) --------------------------------------------------------
float *__cdecl sub_31940(float *a1, float *a2)
{
  float *result; // eax
  int v3; // eax
  float *v4; // [esp+2Ch] [ebp-2Ch]
  int v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h]
  float v7; // [esp+38h] [ebp-20h]
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h]
  int v11; // [esp+48h] [ebp-10h]
  int v12; // [esp+4Ch] [ebp-Ch]
  float v13; // [esp+50h] [ebp-8h]

  v5 = *(_DWORD *)a1;
  result = (float *)BG_IsAimDownSightWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( result )
  {
    v4 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(v5 + 176));
    v6 = *(float *)(v5 + 184);
    v10 = (v4[219] - v4[235]) * v6 + v4[235];
    v9 = (v4[220] - v4[236]) * v6 + v4[236];
    v8 = (v4[221] - v4[237]) * v6 + v4[237];
    v7 = (v4[222] - v4[238]) * v6 + v4[238];
    v13 = a1[2];
    while ( v13 > 0.0 )
    {
      if ( v13 <= 0.005 )
      {
        v12 = LODWORD(v13);
        v13 = 0.0;
        v3 = sub_3171A((int)(a1 + 11), (int)(a1 + 14), *(float *)&v12, v4[160], v10, v9, v8, v7);
      }
      else
      {
        v12 = 1000593162;
        v13 = v13 - 0.005;
        v3 = sub_3171A((int)(a1 + 11), (int)(a1 + 14), 0.0049999999, v4[160], v10, v9, v8, v7);
      }
      v11 = v3;
      if ( sub_3171A((int)(a1 + 12), (int)(a1 + 15), *(float *)&v12, v4[161], v10, v9, v8, v7) )
      {
        if ( v11 )
          break;
      }
    }
    *a2 = *a2 + a1[11];
    a2[1] = a2[1] + a1[12];
    result = a2 + 2;
    a2[2] = a2[2] + a1[13];
  }
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14740: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);

//----- (00031B66) --------------------------------------------------------
int __cdecl BG_CalculateWeaponAngles(float *a1, int a2)
{
  long double v2; // fst7
  int result; // eax
  float v4; // [esp+8h] [ebp-10h]

  v4 = *a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  v2 = 0.0;
  if ( *(float *)(LODWORD(v4) + 64) != 0.0 )
  {
    GetLeanFraction(*(float *)(LODWORD(v4) + 64));
    v2 = *(float *)(a2 + 8) - ((float)0.0 + (float)0.0);
    *(float *)(a2 + 8) = v2;
  }
  sub_31063(a1, (float *)a2);
  sub_310DE(a1, (float *)a2);
  sub_31312(a1, (float *)a2);
  sub_31501(a1, (float *)a2);
  sub_31940(a1, (float *)a2);
  AngleSubtract(*(float *)a2, a1[17]);
  *(float *)a2 = v2;
  AngleSubtract(*(float *)(a2 + 4), a1[18]);
  result = a2 + 4;
  *(float *)(a2 + 4) = v2;
  return result;
}

//----- (00031C7E) --------------------------------------------------------
void __cdecl sub_31C7E(float *a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+0h] [ebp-18h]
  int v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+Ch] [ebp-Ch]
  float v7; // [esp+10h] [ebp-8h]
  float v8; // [esp+10h] [ebp-8h]
  float v9; // [esp+10h] [ebp-8h]
  float v10; // [esp+10h] [ebp-8h]
  float v11; // [esp+10h] [ebp-8h]
  float v12; // [esp+10h] [ebp-8h]

  if ( *((_DWORD *)a1 + 1) )
  {
    v5 = *(_DWORD *)a1;
    v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
    v6 = 1.0 - *(float *)(v5 + 184) * 0.5;
    if ( *(float *)(v5 + 184) != 0.0 && *(_DWORD *)(v4 + 552) )
      v6 = (*(float *)(v5 + 184) * 0.5 + 1.0) * v6;
    v7 = (float)(*((_DWORD *)a1 + 2) - *((_DWORD *)a1 + 1));
    if ( v7 >= 100.0 )
    {
      v10 = 1.0 - (v7 - 100.0) / 400.0;
      if ( v10 > 0.0 )
      {
        v2 = 1.0 - v10;
        v3 = v2;
        GetLeanFraction(v3);
        v11 = 1.0 - v2;
        v12 = v11 * v6;
        *a2 = v12 * a1[3] + *a2;
        a2[2] = v12 * a1[4] + a2[2];
      }
    }
    else
    {
      v8 = v7 / 100.0;
      GetLeanFraction(v8);
      v9 = v8 * v6;
      *a2 = v9 * a1[3] + *a2;
      a2[2] = v9 * a1[4] + a2[2];
    }
  }
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00031E31) --------------------------------------------------------
void __cdecl sub_31E31(float *a1, float *a2)
{
  long double v2; // fst6
  long double v3; // fst7
  int v4; // [esp+20h] [ebp-18h]
  int v5; // [esp+24h] [ebp-14h]
  float v6; // [esp+28h] [ebp-10h]
  float v7; // [esp+2Ch] [ebp-Ch]
  float v8; // [esp+2Ch] [ebp-Ch]
  float v9; // [esp+30h] [ebp-8h]

  v5 = *(_DWORD *)a1;
  v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)a1 + 176));
  if ( (*(_WORD *)(v5 + 128) & 0xC000) == 0 && *(float *)(v5 + 184) != 0.0 && *(float *)(v4 + 568) != 0.0 )
  {
    v2 = (long double)*(unsigned __int8 *)(v5 + 8) / 255.0 * 3.141592653589793;
    v6 = v2 + v2 + 6.283185307179586;
    BG_GetVerticalBobFactor(v5, v6, a1[5], 45.0);
    v9 = *(float *)(v5 + 184) * *(float *)(v4 + 568) * v6;
    v3 = *a2 - v9;
    *a2 = v3;
    BG_GetHorizontalBobFactor(v5, v6, a1[5], 45.0);
    v7 = v3;
    v8 = *(float *)(v5 + 184) * *(float *)(v4 + 568) * v7;
    a2[1] = a2[1] - v8;
  }
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00031F8D) --------------------------------------------------------
void __cdecl BG_CalculateViewAngles(float *a1, int a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = 0;
  sub_31C7E(a1, (float *)a2);
  sub_31E31(a1, (float *)a2);
}

//----- (00031FE6) --------------------------------------------------------
long double __cdecl sub_31FE6(float a1, float a2, float a3, int a4)
{
  float v6; // [esp+4h] [ebp-Ch]
  float v7; // [esp+8h] [ebp-8h]

  v7 = a1 - a2;
  v6 = a3 * v7 * ((long double)a4 * 0.001);
  if ( fabs(v7) <= 0.001000000047497451 )
    return a1;
  if ( fabs(v6) <= fabs(v7) )
    return (float)(a2 + v6);
  return a1;
}

//----- (00032062) --------------------------------------------------------
int __cdecl BG_CalculateWeaponPosition_Sway(int a1, int a2, int a3, int a4, float a5, int a6)
{
  int result; // eax
  float v7; // [esp+1Ch] [ebp-6Ch]
  float v8; // [esp+1Ch] [ebp-6Ch]
  float v9; // [esp+1Ch] [ebp-6Ch]
  float v10; // [esp+1Ch] [ebp-6Ch]
  float v11; // [esp+2Ch] [ebp-5Ch]
  float v12; // [esp+30h] [ebp-58h]
  float v13; // [esp+34h] [ebp-54h]
  float v14; // [esp+38h] [ebp-50h]
  float v15; // [esp+38h] [ebp-50h]
  float v16; // [esp+3Ch] [ebp-4Ch]
  float v17; // [esp+3Ch] [ebp-4Ch]
  float v18; // [esp+40h] [ebp-48h]
  float v19; // [esp+40h] [ebp-48h]
  float v20; // [esp+44h] [ebp-44h]
  float v21; // [esp+44h] [ebp-44h]
  float v22; // [esp+48h] [ebp-40h]
  float v23; // [esp+4Ch] [ebp-3Ch]
  float v24; // [esp+54h] [ebp-34h]
  float v25; // [esp+58h] [ebp-30h]
  float v26; // [esp+60h] [ebp-28h] BYREF
  float v27; // [esp+64h] [ebp-24h]
  int v28; // [esp+7Ch] [ebp-Ch]

  v28 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 176));
  v13 = *(float *)(a1 + 184);
  if ( BG_IsAimDownSightWeapon(*(_DWORD *)(a1 + 176)) )
  {
    if ( v13 > 0.0 )
    {
      result = v28;
      if ( *(_DWORD *)(v28 + 552) )
        return result;
    }
    v23 = (*(float *)(v28 + 676) - *(float *)(v28 + 648)) * v13 + *(float *)(v28 + 648);
    v22 = (*(float *)(v28 + 680) - *(float *)(v28 + 652)) * v13 + *(float *)(v28 + 652);
    v20 = (*(float *)(v28 + 684) - *(float *)(v28 + 656)) * v13 + *(float *)(v28 + 656);
    v18 = (*(float *)(v28 + 688) - *(float *)(v28 + 660)) * v13 + *(float *)(v28 + 660);
    v16 = (*(float *)(v28 + 692) - *(float *)(v28 + 664)) * v13 + *(float *)(v28 + 664);
    v14 = (*(float *)(v28 + 696) - *(float *)(v28 + 668)) * v13 + *(float *)(v28 + 668);
  }
  else
  {
    v23 = *(float *)(v28 + 648);
    v22 = *(float *)(v28 + 652);
    v20 = *(float *)(v28 + 656);
    v18 = *(float *)(v28 + 660);
    v16 = *(float *)(v28 + 664);
    v14 = *(float *)(v28 + 668);
  }
  v21 = v20 * a5;
  v19 = v18 * a5;
  v17 = v16 * a5;
  v15 = v14 * a5;
  AnglesSubtract(a1 + 192, a2, &v26);
  if ( -v23 <= (long double)v26 )
  {
    if ( v26 <= (long double)v23 )
      v12 = v26;
    else
      v12 = v23;
  }
  else
  {
    LODWORD(v12) = LODWORD(v23) ^ 0x80000000;
  }
  v26 = v12;
  if ( -v23 <= (long double)v27 )
  {
    if ( v27 <= (long double)v23 )
      v11 = v27;
    else
      v11 = v23;
  }
  else
  {
    LODWORD(v11) = LODWORD(v23) ^ 0x80000000;
  }
  v27 = v11;
  v24 = v11 * v17;
  v25 = v26 * v15;
  v7 = sub_31FE6(v24, *(float *)(a3 + 4), v22, a6);
  *(float *)(a3 + 4) = v7;
  v8 = sub_31FE6(v25, *(float *)(a3 + 8), v22, a6);
  *(float *)(a3 + 8) = v8;
  v26 = v26 * v21;
  v27 = v27 * v19;
  while ( v26 - *(float *)a4 > 180.0 )
    v26 = v26 - 360.0;
  while ( v27 - *(float *)(a4 + 4) > 180.0 )
    v27 = v27 - 360.0;
  v9 = sub_31FE6(v26, *(float *)a4, v22, a6);
  *(float *)a4 = v9;
  v10 = sub_31FE6(v27, *(float *)(a4 + 4), v22, a6);
  *(float *)(a4 + 4) = v10;
  AngleNormalize180(*(float *)a4);
  *(float *)a4 = v10;
  AngleNormalize180(*(float *)(a4 + 4));
  *(float *)(a4 + 4) = v10;
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 196);
  result = *(_DWORD *)(a1 + 200);
  *(_DWORD *)(a2 + 8) = result;
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14740: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);
// 14A50: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (0003246C) --------------------------------------------------------
float *__cdecl BG_WeaponFireRecoil(int a1, float *a2, int a3)
{
  float *result; // eax
  float v4; // [esp+10h] [ebp-38h]
  float v5; // [esp+14h] [ebp-34h]
  float v6; // [esp+18h] [ebp-30h]
  float v7; // [esp+1Ch] [ebp-2Ch]
  float v8; // [esp+20h] [ebp-28h]
  float v9; // [esp+24h] [ebp-24h]
  float v10; // [esp+28h] [ebp-20h]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+34h] [ebp-14h]
  float v14; // [esp+34h] [ebp-14h]
  float v15; // [esp+38h] [ebp-10h]
  float v16; // [esp+38h] [ebp-10h]
  float *v17; // [esp+3Ch] [ebp-Ch]

  v17 = (float *)BG_GetInfoForWeapon(*(_DWORD *)(a1 + 176));
  v12 = *(float *)(a1 + 184);
  if ( v12 == 1.0 )
  {
    v11 = v17[224] - v17[223];
    v15 = (long double)rand() / 2147483600.0 * v11 + v17[223];
    v10 = v17[226] - v17[225];
    v13 = (long double)rand() / 2147483600.0 * v10 + v17[225];
  }
  else
  {
    v9 = v17[240] - v17[239];
    v15 = (long double)rand() / 2147483600.0 * v9 + v17[239];
    v8 = v17[242] - v17[241];
    v13 = (long double)rand() / 2147483600.0 * v8 + v17[241];
  }
  *(_DWORD *)a3 = LODWORD(v15) ^ 0x80000000;
  *(float *)(a3 + 4) = v13;
  *(float *)(a3 + 8) = *(float *)(a3 + 4) * -0.5;
  if ( v12 <= 0.0 )
  {
    v5 = v17[232] - v17[231];
    v16 = (long double)rand() / 2147483600.0 * v5 + v17[231];
    v4 = v17[234] - v17[233];
    v14 = (long double)rand() / 2147483600.0 * v4 + v17[233];
  }
  else
  {
    v7 = v17[216] - v17[215];
    v16 = (long double)rand() / 2147483600.0 * v7 + v17[215];
    v6 = v17[218] - v17[217];
    v14 = (long double)rand() / 2147483600.0 * v6 + v17[217];
  }
  *a2 = *a2 + v16;
  result = a2 + 1;
  a2[1] = a2[1] + v14;
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0003270C) --------------------------------------------------------
void sub_3270C()
{
  ;
}

//----- (00032710) --------------------------------------------------------
int __cdecl Q_rand(int a1)
{
  *(_DWORD *)a1 = 69069 * *(_DWORD *)a1 + 1;
  return *(_DWORD *)a1;
}

//----- (0003272B) --------------------------------------------------------
long double __cdecl Q_random(int a1)
{
  return (long double)(unsigned __int16)Q_rand(a1) / 65536.0;
}
// 13D00: using guessed type _DWORD __cdecl Q_rand(_DWORD);

//----- (00032763) --------------------------------------------------------
long double __cdecl Q_crandom(int a1)
{
  long double v1; // fst7

  v1 = Q_random(a1);
  return v1 - 0.5 + v1 - 0.5;
}
// 14F40: using guessed type double __cdecl Q_random(_DWORD);

//----- (00032790) --------------------------------------------------------
float *__cdecl gunrandom(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+14h] [ebp-14h] BYREF
  float v5; // [esp+18h] [ebp-10h] BYREF
  float v6; // [esp+1Ch] [ebp-Ch]
  float v7; // [esp+20h] [ebp-8h]

  v7 = (long double)rand() / 2147483600.0 * 360.0;
  v6 = (long double)rand() / 2147483600.0;
  v3 = v7 * 3.141592653589793 / 180.0;
  sub_381A6(v3, &v5, &v4);
  *a1 = v6 * v4;
  result = a2;
  *a2 = v6 * v5;
  return result;
}

//----- (0003281F) --------------------------------------------------------
long double __cdecl Q_rsqrt(float a1)
{
  float v3; // [esp+Ch] [ebp-Ch]

  v3 = a1 * 0.5;
  return (float)((1.5
                - v3 * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)) * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)))
               * COERCE_FLOAT(1597463007 - (SLODWORD(a1) >> 1)));
}

//----- (0003288E) --------------------------------------------------------
int __cdecl Q_log2(int a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    a1 >>= 1;
    if ( !a1 )
      break;
  }
  return i;
}

//----- (000328B3) --------------------------------------------------------
long double __cdecl Q_acos(float a1)
{
  float v3; // [esp+10h] [ebp-8h]

  v3 = acos(a1);
  if ( v3 > 3.141592653589793 )
    return 3.1415927;
  if ( v3 >= -3.141592653589793 )
    return v3;
  return 3.1415927;
}

//----- (0003291E) --------------------------------------------------------
int __cdecl ClampChar(int a1)
{
  if ( a1 < -128 )
    return -128;
  if ( a1 <= 127 )
    return (char)a1;
  return 127;
}

//----- (0003294E) --------------------------------------------------------
int __cdecl ClampShort(int a1)
{
  if ( a1 < -32768 )
    return -32768;
  if ( a1 <= 0x7FFF )
    return (__int16)a1;
  return 0x7FFF;
}

//----- (00032984) --------------------------------------------------------
int __cdecl DirToByte(float *a1)
{
  float v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+8h] [ebp-10h]
  unsigned __int8 v5; // [esp+Eh] [ebp-Ah]
  unsigned __int8 i; // [esp+Fh] [ebp-9h]

  if ( !a1 )
    return 0;
  v3 = 0.0;
  v5 = 0;
  for ( i = 0; i <= 0xA1u; ++i )
  {
    v4 = *a1 * bytedirs[3 * i] + a1[1] * bytedirs[3 * i + 1] + a1[2] * bytedirs[3 * i + 2];
    if ( v4 > (long double)v3 )
    {
      v3 = *a1 * bytedirs[3 * i] + a1[1] * bytedirs[3 * i + 1] + a1[2] * bytedirs[3 * i + 2];
      v5 = i;
    }
  }
  return v5;
}

//----- (00032A62) --------------------------------------------------------
int __cdecl ByteToDir(int a1, int a2)
{
  int result; // eax

  if ( a1 >= 0 && a1 <= 161 )
  {
    *(float *)a2 = bytedirs[3 * a1];
    *(float *)(a2 + 4) = bytedirs[3 * a1 + 1];
    result = LODWORD(bytedirs[3 * a1 + 2]);
    *(_DWORD *)(a2 + 8) = result;
  }
  else
  {
    *(_DWORD *)a2 = vec3_origin[0];
    *(_DWORD *)(a2 + 4) = vec3_origin[1];
    result = vec3_origin[2];
    *(_DWORD *)(a2 + 8) = result;
  }
  return result;
}

//----- (00032B14) --------------------------------------------------------
long double __cdecl DotProduct(float *a1, float *a2)
{
  return *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
}

//----- (00032B47) --------------------------------------------------------
float *__cdecl VectorSubtract(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  result = a1 + 2;
  a3[2] = a1[2] - a2[2];
  return result;
}

//----- (00032B8B) --------------------------------------------------------
float *__cdecl VectorAdd(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  result = a1 + 2;
  a3[2] = a1[2] + a2[2];
  return result;
}

//----- (00032BCF) --------------------------------------------------------
int __cdecl VectorCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (00032BFE) --------------------------------------------------------
int __cdecl VectorScale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  result = a1 + 8;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  return result;
}

//----- (00032C36) --------------------------------------------------------
int __cdecl VectorMA(int a1, float a2, int a3, int a4)
{
  int result; // eax

  *(float *)a4 = a2 * *(float *)a3 + *(float *)a1;
  *(float *)(a4 + 4) = a2 * *(float *)(a3 + 4) + *(float *)(a1 + 4);
  result = a3 + 8;
  *(float *)(a4 + 8) = a2 * *(float *)(a3 + 8) + *(float *)(a1 + 8);
  return result;
}

//----- (00032C89) --------------------------------------------------------
int __cdecl VectorCompareEpsilon(int a1, int a2)
{
  int i; // [esp+4h] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    if ( (*(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i)) * (*(float *)(a1 + 4 * i) - *(float *)(a2 + 4 * i)) > 0.0000010000001 )
      return 0;
  }
  return 1;
}

//----- (00032D1F) --------------------------------------------------------
long double __cdecl VectorLength(float *a1)
{
  return (float)sqrt(*a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2]);
}

//----- (00032D79) --------------------------------------------------------
long double __cdecl VectorDistance(float *a1, float *a2)
{
  float v4; // [esp+30h] [ebp-18h]
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  return (float)sqrt(v4 * v4 + v5 * v5 + v6 * v6);
}

//----- (00032DEE) --------------------------------------------------------
long double __cdecl VectorDistanceSquared(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  v5 = a2[2] - a1[2];
  return v3 * v3 + v4 * v4 + v5 * v5;
}

//----- (00032E3F) --------------------------------------------------------
long double __cdecl VectorDistance2D(float *a1, float *a2)
{
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  return (float)sqrt(v4 * v4 + v5 * v5);
}

//----- (00032E99) --------------------------------------------------------
long double __cdecl VectorDistanceSquared2D(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a2 - *a1;
  v4 = a2[1] - a1[1];
  return v3 * v3 + v4 * v4;
}

//----- (00032ECF) --------------------------------------------------------
float *__cdecl CrossProduct(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = a1[1] * a2[2] - a1[2] * a2[1];
  a3[1] = a1[2] * *a2 - *a1 * a2[2];
  result = a1 + 1;
  a3[2] = *a1 * a2[1] - a1[1] * *a2;
  return result;
}

//----- (00032F43) --------------------------------------------------------
_DWORD *__cdecl CrossProductUp(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a2 = a1[1];
  a2[1] = *a1 ^ 0x80000000;
  result = a2 + 2;
  a2[2] = 0;
  return result;
}

//----- (00032F73) --------------------------------------------------------
long double __cdecl VectorNormalize(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
  }
  return v4;
}

//----- (00033028) --------------------------------------------------------
long double __cdecl VectorNormalize2D(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
  }
  return v4;
}

//----- (000330B8) --------------------------------------------------------
long double __cdecl VectorNormalize4D(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]
  float v4; // [esp+20h] [ebp-8h]

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  v4 = sqrt(v3);
  if ( v4 != 0.0 )
  {
    v2 = 1.0 / v4;
    *a1 = *a1 * v2;
    a1[1] = a1[1] * v2;
    a1[2] = a1[2] * v2;
    a1[3] = a1[3] * v2;
  }
  return v4;
}

//----- (00033192) --------------------------------------------------------
float *__cdecl VectorNormalizeFast(float *a1)
{
  long double v1; // fst7
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+10h] [ebp-8h]

  v1 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v3 = v1;
  Q_rsqrt(v3);
  v4 = v1;
  *a1 = *a1 * v4;
  a1[1] = a1[1] * v4;
  result = a1 + 2;
  a1[2] = a1[2] * v4;
  return result;
}

//----- (00033216) --------------------------------------------------------
long double __cdecl VectorNormalize2(float *a1, float *a2)
{
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+1Ch] [ebp-Ch]

  v4 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2];
  v5 = sqrt(v4);
  if ( v5 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    v3 = 1.0 / v5;
    *a2 = *a1 * v3;
    a2[1] = a1[1] * v3;
    a2[2] = a1[2] * v3;
  }
  return v5;
}

//----- (000332EA) --------------------------------------------------------
unsigned int __cdecl VectorInverse(_DWORD *a1)
{
  unsigned int result; // eax

  *a1 ^= 0x80000000;
  a1[1] ^= 0x80000000;
  result = a1[2] ^ 0x80000000;
  a1[2] = result;
  return result;
}

//----- (00033328) --------------------------------------------------------
int __cdecl Vector4Scale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  result = a1 + 12;
  *(float *)(a3 + 12) = *(float *)(a1 + 12) * a2;
  return result;
}

//----- (00033373) --------------------------------------------------------
long double __cdecl VectorMax(float *a1)
{
  float v2; // [esp+0h] [ebp-Ch]
  float v3; // [esp+4h] [ebp-8h]

  if ( *a1 < (long double)a1[1] )
    v3 = a1[1];
  else
    v3 = *a1;
  if ( v3 < (long double)a1[2] )
    v2 = a1[2];
  else
    v2 = v3;
  return v2;
}

//----- (000333DA) --------------------------------------------------------
float *__cdecl VectorRotate(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (00033484) --------------------------------------------------------
int *__cdecl RotatePointAroundVector(int a1, int a2, int a3, float a4)
{
  int *result; // eax
  float v5; // [esp+1Ch] [ebp-13Ch]
  int v6; // [esp+20h] [ebp-138h] BYREF
  int v7; // [esp+24h] [ebp-134h]
  int v8; // [esp+28h] [ebp-130h]
  int v9[4]; // [esp+30h] [ebp-128h] BYREF
  int v10[7]; // [esp+40h] [ebp-118h] BYREF
  int i; // [esp+5Ch] [ebp-FCh] BYREF
  float v12[12]; // [esp+60h] [ebp-F8h] BYREF
  char v13[48]; // [esp+90h] [ebp-C8h] BYREF
  int s; // [esp+C0h] [ebp-98h] BYREF
  int v15[3]; // [esp+C4h] [ebp-94h] BYREF
  int v16; // [esp+D0h] [ebp-88h]
  int v17; // [esp+E0h] [ebp-78h]
  char dest[4]; // [esp+F0h] [ebp-68h] BYREF
  int v19; // [esp+F4h] [ebp-64h]
  int v20; // [esp+F8h] [ebp-60h]
  int v21; // [esp+FCh] [ebp-5Ch]
  int v22; // [esp+104h] [ebp-54h]
  int v23; // [esp+108h] [ebp-50h]
  int v24; // [esp+10Ch] [ebp-4Ch]
  int src; // [esp+120h] [ebp-38h] BYREF
  int v26; // [esp+124h] [ebp-34h]
  int v27; // [esp+128h] [ebp-30h]
  int v28; // [esp+12Ch] [ebp-2Ch]
  int v29; // [esp+130h] [ebp-28h]
  int v30; // [esp+134h] [ebp-24h]
  int v31; // [esp+138h] [ebp-20h]
  int v32; // [esp+13Ch] [ebp-1Ch]
  int v33; // [esp+140h] [ebp-18h]
  _DWORD v34[2]; // [esp+150h] [ebp-8h] BYREF

  v6 = *(_DWORD *)a2;
  v7 = *(_DWORD *)(a2 + 4);
  v8 = *(_DWORD *)(a2 + 8);
  PerpendicularVector(v10, a2);
  CrossProduct(v10, &v6, v9);
  src = v10[0];
  v28 = v10[1];
  v31 = v10[2];
  v26 = v9[0];
  v29 = v9[1];
  v32 = v9[2];
  v27 = v6;
  v30 = v7;
  v33 = v8;
  memcpy(dest, &src, 0x24u);
  v19 = v28;
  v20 = v31;
  v21 = v26;
  v22 = v32;
  v23 = v27;
  v24 = v30;
  memset(&s, 0, 0x24u);
  v17 = 1065353216;
  v16 = 1065353216;
  s = 1065353216;
  v5 = a4 * 3.141592653589793 / 180.0;
  sub_381A6(v5, (float *)v15, (float *)&s);
  v15[2] = v15[0] ^ 0x80000000;
  v16 = s;
  MatrixMultiply(&src, &s, v13);
  result = (int *)MatrixMultiply(v13, dest, v12);
  for ( i = 0; i <= 2; ++i )
  {
    *(float *)(a1 + 4 * i) = v12[3 * i] * *(float *)a3
                           + *(float *)&v34[3 * i - 59] * *(float *)(a3 + 4)
                           + *(float *)&v34[3 * i - 58] * *(float *)(a3 + 8);
    result = &i;
  }
  return result;
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 14060: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 159E0: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (000336FF) --------------------------------------------------------
int __cdecl RotateAroundDirection(int a1, float a2)
{
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  PerpendicularVector(a1 + 12, a1);
  if ( a2 != 0.0 )
  {
    v3[0] = *(_DWORD *)(a1 + 12);
    v3[1] = *(_DWORD *)(a1 + 16);
    v3[2] = *(_DWORD *)(a1 + 20);
    RotatePointAroundVector(a1 + 12, a1, (int)v3, a2);
  }
  return CrossProduct(a1, a1 + 12, a1 + 24);
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 159E0: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (000337A5) --------------------------------------------------------
int __cdecl MakeNormalVectors(float *a1, float *a2, int a3)
{
  float v4; // [esp+1Ch] [ebp-Ch]

  *((_DWORD *)a2 + 1) = *(_DWORD *)a1 ^ 0x80000000;
  a2[2] = a1[1];
  *a2 = a1[2];
  v4 = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  *a2 = -v4 * *a1 + *a2;
  a2[1] = -v4 * a1[1] + a2[1];
  a2[2] = -v4 * a1[2] + a2[2];
  VectorNormalize(a2);
  return CrossProduct(a2, a1, a3);
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (000338AB) --------------------------------------------------------
long double __cdecl vectoyaw(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
    return 0.0;
  v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
  if ( v2 < 0.0 )
    v2 = v2 + 360.0;
  return v2;
}

//----- (00033954) --------------------------------------------------------
long double __cdecl vectosignedyaw(float *a1)
{
  float v2; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
    v2 = 0.0;
  else
    v2 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
  return v2;
}

//----- (000339DD) --------------------------------------------------------
long double __cdecl vectopitch(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = 270.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
    if ( v2 < 0.0 )
      v2 = v2 + 360.0;
  }
  return v2;
}

//----- (00033ACD) --------------------------------------------------------
long double __cdecl vectosignedpitch(float *a1)
{
  float v2; // [esp+1Ch] [ebp-Ch]
  float v3; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      v2 = 90.0;
    else
      v2 = -90.0;
  }
  else
  {
    v3 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v2 = atan2(a1[2], v3) * -180.0 / 3.141592653589793;
  }
  return v2;
}

//----- (00033B9D) --------------------------------------------------------
int __cdecl vectoangles(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = 270.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    if ( v4 < 0.0 )
      v4 = v4 + 360.0;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
    if ( v3 < 0.0 )
      v3 = v3 + 360.0;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (00033CFC) --------------------------------------------------------
int __cdecl vectosignedangles(float *a1, int a2)
{
  int result; // eax
  float v3; // [esp+18h] [ebp-10h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  if ( a1[1] == 0.0 && *a1 == 0.0 )
  {
    v4 = 0.0;
    if ( a1[2] <= 0.0 )
      v3 = 90.0;
    else
      v3 = -90.0;
  }
  else
  {
    v4 = atan2(a1[1], *a1) * 180.0 / 3.141592653589793;
    v5 = sqrt(*a1 * *a1 + a1[1] * a1[1]);
    v3 = atan2(a1[2], v5) * -180.0 / 3.141592653589793;
  }
  *(float *)a2 = v3;
  *(float *)(a2 + 4) = v4;
  result = a2 + 8;
  *(_DWORD *)(a2 + 8) = 0;
  return result;
}

//----- (00033E18) --------------------------------------------------------
float *__cdecl AngleVectors(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+18h] [ebp-20h] BYREF
  float v6; // [esp+1Ch] [ebp-1Ch] BYREF
  float v7; // [esp+20h] [ebp-18h] BYREF
  float v8; // [esp+24h] [ebp-14h] BYREF
  float v9; // [esp+28h] [ebp-10h] BYREF
  float v10; // [esp+2Ch] [ebp-Ch] BYREF
  float v11; // [esp+30h] [ebp-8h]

  v11 = a1[1] * 0.0174532925199433;
  sub_381A6(v11, &v8, &v5);
  v11 = *a1 * 0.0174532925199433;
  result = sub_381A6(v11, &v9, &v6);
  if ( a2 )
  {
    *(float *)a2 = v6 * v5;
    *(float *)(a2 + 4) = v6 * v8;
    result = (float *)(LODWORD(v9) ^ 0x80000000);
    *(_DWORD *)(a2 + 8) = LODWORD(v9) ^ 0x80000000;
  }
  if ( a3 || a4 )
  {
    v11 = a1[2] * 0.0174532925199433;
    result = sub_381A6(v11, &v10, &v7);
    if ( a3 )
    {
      *a3 = v10 * -1.0 * v9 * v5 + v7 * -1.0 * -v8;
      a3[1] = v10 * -1.0 * v9 * v8 + v7 * -1.0 * v5;
      result = a3 + 2;
      a3[2] = v10 * -1.0 * v6;
    }
    if ( a4 )
    {
      *a4 = v7 * v9 * v5 + v10 * v8;
      a4[1] = v7 * v9 * v8 + -v10 * v5;
      result = a4 + 2;
      a4[2] = v7 * v6;
    }
  }
  return result;
}

//----- (00033FB1) --------------------------------------------------------
float *__cdecl YawVectors(float a1, int a2, int a3)
{
  float *result; // eax
  int v4; // [esp+18h] [ebp-10h] BYREF
  int v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h]

  v6 = a1 * 0.0174532925199433;
  result = sub_381A6(v6, (float *)&v5, (float *)&v4);
  if ( a2 )
  {
    *(_DWORD *)a2 = v4;
    *(_DWORD *)(a2 + 4) = v5;
    result = (float *)(a2 + 8);
    *(_DWORD *)(a2 + 8) = 0;
  }
  if ( a3 )
  {
    *(_DWORD *)a3 = v5;
    *(_DWORD *)(a3 + 4) = v4 ^ 0x80000000;
    result = (float *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = 0;
  }
  return result;
}

//----- (0003403F) --------------------------------------------------------
void __cdecl PerpendicularVector(int a1, int a2)
{
  int v2[5]; // [esp+20h] [ebp-28h] BYREF
  float v3; // [esp+34h] [ebp-14h]
  int i; // [esp+38h] [ebp-10h]
  int v5; // [esp+3Ch] [ebp-Ch]

  v3 = 1.0;
  v5 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v3 > fabs(*(float *)(a2 + 4 * i)) )
    {
      v3 = fabs(*(float *)(a2 + 4 * i));
      v5 = i;
    }
  }
  v2[2] = 0;
  v2[1] = 0;
  v2[0] = 0;
  v2[v5] = 1065353216;
  ProjectPointOnPlane(a1, v2, a2);
  VectorNormalize(a1);
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 15710: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (000340F4) --------------------------------------------------------
void __cdecl GetPerpendicularViewVector(float *a1, float *a2, float *a3, int a4)
{
  float v4[4]; // [esp+10h] [ebp-28h] BYREF
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  v5[0] = *a1 - *a2;
  v5[1] = a1[1] - a2[1];
  v5[2] = a1[2] - a2[2];
  VectorNormalize(v5);
  v4[0] = *a1 - *a3;
  v4[1] = a1[1] - a3[1];
  v4[2] = a1[2] - a3[2];
  VectorNormalize(v4);
  CrossProduct(v5, v4, a4);
  VectorNormalize(a4);
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (000341B2) --------------------------------------------------------
float *__cdecl ProjectPointOntoVector(float *a1, float *a2, float *a3, float *a4)
{
  float *result; // eax
  float v5; // [esp+10h] [ebp-28h] BYREF
  float v6; // [esp+14h] [ebp-24h]
  float v7; // [esp+18h] [ebp-20h]
  float v8; // [esp+20h] [ebp-18h]
  float v9; // [esp+24h] [ebp-14h]
  float v10; // [esp+28h] [ebp-10h]

  v8 = *a1 - *a2;
  v9 = a1[1] - a2[1];
  v10 = a1[2] - a2[2];
  v5 = *a3 - *a2;
  v6 = a3[1] - a2[1];
  v7 = a3[2] - a2[2];
  VectorNormalize(&v5);
  *a4 = (v8 * v5 + v9 * v6 + v10 * v7) * v5 + *a2;
  a4[1] = (v8 * v5 + v9 * v6 + v10 * v7) * v6 + a2[1];
  result = a2 + 2;
  a4[2] = (v8 * v5 + v9 * v6 + v10 * v7) * v7 + a2[2];
  return result;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (000342B8) --------------------------------------------------------
float *__cdecl MatrixMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  result = a1 + 8;
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  return result;
}

//----- (000344C4) --------------------------------------------------------
int __cdecl MatrixMultiplyEquals(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+4h] [ebp-24h]
  float v5; // [esp+8h] [ebp-20h]
  float v6; // [esp+Ch] [ebp-1Ch]
  float v7; // [esp+10h] [ebp-18h]
  float v8; // [esp+14h] [ebp-14h]

  v3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  v4 = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  v5 = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  v6 = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  v7 = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  v8 = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a2[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a2[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a2[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  *a2 = v3;
  a2[1] = v4;
  a2[2] = v5;
  a2[3] = v6;
  a2[4] = v7;
  result = LODWORD(v8);
  a2[5] = v8;
  return result;
}

//----- (000346F7) --------------------------------------------------------
float *__cdecl MatrixMultiply34(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9];
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10];
  a3[3] = *a1 * a2[3] + a1[1] * a2[7] + a1[2] * a2[11] + a1[3];
  a3[4] = a1[4] * *a2 + a1[5] * a2[4] + a1[6] * a2[8];
  a3[5] = a1[4] * a2[1] + a1[5] * a2[5] + a1[6] * a2[9];
  a3[6] = a1[4] * a2[2] + a1[5] * a2[6] + a1[6] * a2[10];
  a3[7] = a1[4] * a2[3] + a1[5] * a2[7] + a1[6] * a2[11] + a1[7];
  a3[8] = a1[8] * *a2 + a1[9] * a2[4] + a1[10] * a2[8];
  a3[9] = a1[8] * a2[1] + a1[9] * a2[5] + a1[10] * a2[9];
  a3[10] = a1[8] * a2[2] + a1[9] * a2[6] + a1[10] * a2[10];
  result = a1 + 11;
  a3[11] = a1[8] * a2[3] + a1[9] * a2[7] + a1[10] * a2[11] + a1[11];
  return result;
}

//----- (000349CC) --------------------------------------------------------
float *__cdecl MatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[3] * *a2 + a1[4] * a2[3] + a1[5] * a2[6];
  a3[6] = a1[6] * *a2 + a1[7] * a2[3] + a1[8] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[3] * a2[1] + a1[4] * a2[4] + a1[5] * a2[7];
  a3[7] = a1[6] * a2[1] + a1[7] * a2[4] + a1[8] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[3] * a2[2] + a1[4] * a2[5] + a1[5] * a2[8];
  a3[8] = a1[6] * a2[2] + a1[7] * a2[5] + a1[8] * a2[8];
  a3[9] = a1[9] * *a2 + a1[10] * a2[3] + a1[11] * a2[6] + a2[9];
  a3[10] = a1[9] * a2[1] + a1[10] * a2[4] + a1[11] * a2[7] + a2[10];
  result = a2 + 11;
  a3[11] = a1[9] * a2[2] + a1[10] * a2[5] + a1[11] * a2[8] + a2[11];
  return result;
}

//----- (00034CA1) --------------------------------------------------------
float *__cdecl DObjSkelMatrixMultiply43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[3] = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  a3[6] = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  a3[4] = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  a3[7] = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  a3[5] = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  a3[8] = a1[8] * a2[2] + a1[9] * a2[5] + a1[10] * a2[8];
  a3[9] = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  a3[10] = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  result = a2 + 11;
  a3[11] = a1[12] * a2[2] + a1[13] * a2[5] + a1[14] * a2[8] + a2[11];
  return result;
}

//----- (00034F34) --------------------------------------------------------
int __cdecl DObjSkel2MatrixMultiply43(float *a1, float *a2, int a3)
{
  int result; // eax

  *(float *)a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  *(float *)(a3 + 16) = a1[4] * *a2 + a1[5] * a2[3] + a1[6] * a2[6];
  *(float *)(a3 + 32) = a1[8] * *a2 + a1[9] * a2[3] + a1[10] * a2[6];
  *(float *)(a3 + 4) = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  *(float *)(a3 + 20) = a1[4] * a2[1] + a1[5] * a2[4] + a1[6] * a2[7];
  *(float *)(a3 + 36) = a1[8] * a2[1] + a1[9] * a2[4] + a1[10] * a2[7];
  *(float *)(a3 + 8) = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  *(float *)(a3 + 24) = a1[4] * a2[2] + a1[5] * a2[5] + a1[6] * a2[8];
  *(float *)(a3 + 40) = a1[8] * a2[2] + a1[9] * a2[5] + a1[10] * a2[8];
  *(_DWORD *)(a3 + 12) = 0;
  *(_DWORD *)(a3 + 28) = 0;
  *(_DWORD *)(a3 + 44) = 0;
  *(float *)(a3 + 48) = a1[12] * *a2 + a1[13] * a2[3] + a1[14] * a2[6] + a2[9];
  *(float *)(a3 + 52) = a1[12] * a2[1] + a1[13] * a2[4] + a1[14] * a2[7] + a2[10];
  *(float *)(a3 + 56) = a1[12] * a2[2] + a1[13] * a2[5] + a1[14] * a2[8] + a2[11];
  result = a3;
  *(_DWORD *)(a3 + 60) = 1065353216;
  return result;
}

//----- (000351D9) --------------------------------------------------------
int __cdecl MatrixTranspose(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[3];
  a2[2] = a1[6];
  a2[3] = a1[1];
  a2[4] = a1[4];
  a2[5] = a1[7];
  a2[6] = a1[2];
  a2[7] = a1[5];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (00035268) --------------------------------------------------------
float *__cdecl MatrixInverse(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+0h] [ebp-8h]

  v3 = (a1[8] * a1[4] - a1[7] * a1[5]) * *a1
     - (a1[8] * a1[1] - a1[7] * a1[2]) * a1[3]
     + (a1[5] * a1[1] - a1[4] * a1[2]) * a1[6];
  v4 = 1.0 / v3;
  *a2 = (a1[8] * a1[4] - a1[7] * a1[5]) * v4;
  a2[1] = -(a1[8] * a1[1] - a1[7] * a1[2]) * v4;
  a2[2] = (a1[5] * a1[1] - a1[4] * a1[2]) * v4;
  a2[3] = -(a1[8] * a1[3] - a1[6] * a1[5]) * v4;
  a2[4] = (a1[8] * *a1 - a1[6] * a1[2]) * v4;
  a2[5] = -(a1[5] * *a1 - a1[3] * a1[2]) * v4;
  a2[6] = (a1[7] * a1[3] - a1[6] * a1[4]) * v4;
  a2[7] = -(a1[7] * *a1 - a1[6] * a1[1]) * v4;
  result = a1 + 3;
  a2[8] = (a1[4] * *a1 - a1[3] * a1[1]) * v4;
  return result;
}

//----- (0003549C) --------------------------------------------------------
int __cdecl MatrixInverseOrthogonal43(float *a1, int a2)
{
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  MatrixTranspose(a1, a2);
  v3[0] = 0.0 - a1[9];
  v3[1] = *(float *)&vec3_origin[1] - a1[10];
  v3[2] = *(float *)&vec3_origin[2] - a1[11];
  return MatrixTransformVector(v3, a2, a2 + 36);
}
// 13AE0: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 145B0: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);

//----- (0003551D) --------------------------------------------------------
int *__cdecl MatrixInverse44(int a1, float *a2)
{
  int *result; // eax
  int i; // [esp+8h] [ebp-80h] BYREF
  float v4; // [esp+Ch] [ebp-7Ch]
  float v5; // [esp+10h] [ebp-78h]
  float v6; // [esp+14h] [ebp-74h]
  float v7; // [esp+18h] [ebp-70h]
  float v8; // [esp+1Ch] [ebp-6Ch]
  float v9; // [esp+20h] [ebp-68h]
  float v10; // [esp+24h] [ebp-64h]
  float v11; // [esp+28h] [ebp-60h]
  float v12; // [esp+2Ch] [ebp-5Ch]
  float v13; // [esp+30h] [ebp-58h]
  float v14; // [esp+34h] [ebp-54h]
  float v15; // [esp+38h] [ebp-50h]
  float v16; // [esp+3Ch] [ebp-4Ch]
  float v17; // [esp+40h] [ebp-48h]
  float v18; // [esp+44h] [ebp-44h]
  float v19; // [esp+48h] [ebp-40h]
  float v20; // [esp+4Ch] [ebp-3Ch]
  float v21; // [esp+50h] [ebp-38h]
  float v22; // [esp+54h] [ebp-34h]
  float v23; // [esp+58h] [ebp-30h]
  float v24; // [esp+5Ch] [ebp-2Ch]
  float v25; // [esp+60h] [ebp-28h]
  float v26; // [esp+64h] [ebp-24h]
  float v27; // [esp+68h] [ebp-20h]
  float v28; // [esp+6Ch] [ebp-1Ch]
  float v29; // [esp+70h] [ebp-18h]
  float v30; // [esp+74h] [ebp-14h]
  float v31; // [esp+78h] [ebp-10h]
  float v32; // [esp+7Ch] [ebp-Ch]

  for ( i = 0; i <= 3; ++i )
  {
    *(&v5 + i) = *(float *)(a1 + 16 * i);
    *(&v9 + i) = *(float *)(a1 + 16 * i + 4);
    *(&v13 + i) = *(float *)(a1 + 16 * i + 8);
    *(&v17 + i) = *(float *)(a1 + 16 * i + 12);
  }
  v21 = v15 * v20;
  v22 = v16 * v19;
  v23 = v14 * v20;
  v24 = v16 * v18;
  v25 = v14 * v19;
  v26 = v15 * v18;
  v27 = v13 * v20;
  v28 = v16 * v17;
  v29 = v13 * v19;
  v30 = v15 * v17;
  v31 = v13 * v18;
  v32 = v14 * v17;
  *a2 = v21 * v10 + v24 * v11 + v25 * v12;
  *a2 = *a2 - (v22 * v10 + v23 * v11 + v26 * v12);
  a2[1] = v22 * v9 + v27 * v11 + v30 * v12;
  a2[1] = a2[1] - (v21 * v9 + v28 * v11 + v29 * v12);
  a2[2] = v23 * v9 + v28 * v10 + v31 * v12;
  a2[2] = a2[2] - (v24 * v9 + v27 * v10 + v32 * v12);
  a2[3] = v26 * v9 + v29 * v10 + v32 * v11;
  a2[3] = a2[3] - (v25 * v9 + v30 * v10 + v31 * v11);
  a2[4] = v22 * v6 + v23 * v7 + v26 * v8;
  a2[4] = a2[4] - (v21 * v6 + v24 * v7 + v25 * v8);
  a2[5] = v21 * v5 + v28 * v7 + v29 * v8;
  a2[5] = a2[5] - (v22 * v5 + v27 * v7 + v30 * v8);
  a2[6] = v24 * v5 + v27 * v6 + v32 * v8;
  a2[6] = a2[6] - (v23 * v5 + v28 * v6 + v31 * v8);
  a2[7] = v25 * v5 + v30 * v6 + v31 * v7;
  a2[7] = a2[7] - (v26 * v5 + v29 * v6 + v32 * v7);
  v21 = v7 * v12;
  v22 = v8 * v11;
  v23 = v6 * v12;
  v24 = v8 * v10;
  v25 = v6 * v11;
  v26 = v7 * v10;
  v27 = v5 * v12;
  v28 = v8 * v9;
  v29 = v5 * v11;
  v30 = v7 * v9;
  v31 = v5 * v10;
  v32 = v6 * v9;
  a2[8] = v21 * v18 + v24 * v19 + v25 * v20;
  a2[8] = a2[8] - (v22 * v18 + v23 * v19 + v26 * v20);
  a2[9] = v22 * v17 + v27 * v19 + v30 * v20;
  a2[9] = a2[9] - (v21 * v17 + v28 * v19 + v29 * v20);
  a2[10] = v23 * v17 + v28 * v18 + v31 * v20;
  a2[10] = a2[10] - (v24 * v17 + v27 * v18 + v32 * v20);
  a2[11] = v26 * v17 + v29 * v18 + v32 * v19;
  a2[11] = a2[11] - (v25 * v17 + v30 * v18 + v31 * v19);
  a2[12] = v23 * v15 + v26 * v16 + v22 * v14;
  a2[12] = a2[12] - (v25 * v16 + v21 * v14 + v24 * v15);
  a2[13] = v29 * v16 + v21 * v13 + v28 * v15;
  a2[13] = a2[13] - (v27 * v15 + v30 * v16 + v22 * v13);
  a2[14] = v27 * v14 + v32 * v16 + v24 * v13;
  a2[14] = a2[14] - (v31 * v16 + v23 * v13 + v28 * v14);
  a2[15] = v31 * v15 + v25 * v13 + v30 * v14;
  a2[15] = a2[15] - (v29 * v14 + v32 * v15 + v26 * v13);
  result = (int *)(a2 + 3);
  v4 = v5 * *a2 + v6 * a2[1] + v7 * a2[2] + v8 * a2[3];
  v4 = 1.0 / v4;
  for ( i = 0; i <= 15; ++i )
  {
    a2[i] = a2[i] * v4;
    result = &i;
  }
  return result;
}

//----- (00035B47) --------------------------------------------------------
float *__cdecl MatrixTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7];
  result = a1 + 2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8];
  return result;
}

//----- (00035BF1) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[1] + a1[2] * a2[2];
  a3[1] = *a1 * a2[3] + a1[1] * a2[4] + a1[2] * a2[5];
  result = a1 + 2;
  a3[2] = *a1 * a2[6] + a1[1] * a2[7] + a1[2] * a2[8];
  return result;
}

//----- (00035C9B) --------------------------------------------------------
float *__cdecl MatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  a3[1] = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  result = a2 + 11;
  a3[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  return result;
}

//----- (00035D5D) --------------------------------------------------------
float *__cdecl DObjSkelMatrixTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * *a2 + a1[1] * a2[4] + a1[2] * a2[8] + a2[12];
  a3[1] = *a1 * a2[1] + a1[1] * a2[5] + a1[2] * a2[9] + a2[13];
  result = a2;
  a3[2] = *a1 * a2[2] + a1[1] * a2[6] + a1[2] * a2[10] + a2[14];
  return result;
}

//----- (00035E09) --------------------------------------------------------
float *__cdecl MatrixTransposeTransformVector43(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a1 - a2[9];
  v5 = a1[1] - a2[10];
  v6 = a1[2] - a2[11];
  *a3 = *a2 * v4 + a2[1] * v5 + a2[2] * v6;
  a3[1] = a2[3] * v4 + a2[4] * v5 + a2[5] * v6;
  result = a2 + 8;
  a3[2] = a2[6] * v4 + a2[7] * v5 + a2[8] * v6;
  return result;
}

//----- (00035EC8) --------------------------------------------------------
int __cdecl MatrixTransformVector43Equals(float *a1, float *a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-8h]
  float v4; // [esp+4h] [ebp-4h]

  v3 = *a1 * *a2 + a1[1] * a2[3] + a1[2] * a2[6] + a2[9];
  v4 = *a1 * a2[1] + a1[1] * a2[4] + a1[2] * a2[7] + a2[10];
  a1[2] = *a1 * a2[2] + a1[1] * a2[5] + a1[2] * a2[8] + a2[11];
  *a1 = v3;
  result = LODWORD(v4);
  a1[1] = v4;
  return result;
}

//----- (00035F99) --------------------------------------------------------
int __cdecl VectorAngleMultiply(int a1, float a2)
{
  int result; // eax
  float v3; // [esp+0h] [ebp-28h]
  float v4; // [esp+18h] [ebp-10h]
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6[2]; // [esp+20h] [ebp-8h] BYREF

  v3 = a2 * 0.0174532925199433;
  sub_381A6(v3, &v5, v6);
  v4 = *(float *)a1 * v6[0] - *(float *)(a1 + 4) * v5;
  *(float *)(a1 + 4) = *(float *)(a1 + 4) * v6[0] + *(float *)a1 * v5;
  result = LODWORD(v4);
  *(float *)a1 = v4;
  return result;
}

//----- (0003600F) --------------------------------------------------------
float *__cdecl QuatMultiply(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 * a2[3] + a1[3] * *a2 + a1[2] * a2[1] - a1[1] * a2[2];
  a3[1] = a1[1] * a2[3] - a1[2] * *a2 + a1[3] * a2[1] + *a1 * a2[2];
  a3[2] = a1[2] * a2[3] + a1[1] * *a2 - *a1 * a2[1] + a1[3] * a2[2];
  result = a1 + 2;
  a3[3] = a1[3] * a2[3] - *a1 * *a2 - a1[1] * a2[1] - a1[2] * a2[2];
  return result;
}

//----- (00036131) --------------------------------------------------------
unsigned int __cdecl QuatInverse(_DWORD *a1, unsigned int *a2)
{
  unsigned int result; // eax

  *a2 = *a1 ^ 0x80000000;
  a2[1] = a1[1] ^ 0x80000000;
  a2[2] = a1[2] ^ 0x80000000;
  result = a1[3];
  a2[3] = result;
  return result;
}

//----- (0003617F) --------------------------------------------------------
int __cdecl ConvertQuatToMat(int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-2Ch]
  float v3; // [esp+0h] [ebp-2Ch]
  float v4; // [esp+4h] [ebp-28h]
  float v5; // [esp+8h] [ebp-24h]
  float v6; // [esp+8h] [ebp-24h]
  float v7; // [esp+Ch] [ebp-20h]
  float v8; // [esp+10h] [ebp-1Ch]
  float v9; // [esp+14h] [ebp-18h]
  float v10; // [esp+14h] [ebp-18h]
  float v11; // [esp+18h] [ebp-14h]
  float v12; // [esp+1Ch] [ebp-10h]
  float v13; // [esp+20h] [ebp-Ch]
  float v14; // [esp+24h] [ebp-8h]
  float v15; // [esp+24h] [ebp-8h]

  v14 = *(float *)a1 * *(float *)a1;
  v9 = *(float *)(a1 + 4) * *(float *)(a1 + 4);
  v5 = *(float *)(a1 + 8) * *(float *)(a1 + 8);
  v2 = v14 + v9 + v5 + *(float *)(a1 + 12) * *(float *)(a1 + 12);
  if ( v2 == 0.0 )
  {
    *(_DWORD *)a1 = 1065353216;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 16) = 1065353216;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 28) = 0;
    result = a1 + 32;
    *(_DWORD *)(a1 + 32) = 1065353216;
  }
  else
  {
    v3 = 2.0 / v2;
    v15 = v14 * v3;
    v10 = v9 * v3;
    v6 = v5 * v3;
    *(float *)a1 = *(float *)a1 * v3;
    v13 = *(float *)a1 * *(float *)(a1 + 4);
    v12 = *(float *)a1 * *(float *)(a1 + 8);
    v11 = *(float *)a1 * *(float *)(a1 + 12);
    *(float *)(a1 + 4) = *(float *)(a1 + 4) * v3;
    v8 = *(float *)(a1 + 4) * *(float *)(a1 + 8);
    v7 = *(float *)(a1 + 4) * *(float *)(a1 + 12);
    v4 = *(float *)(a1 + 8) * *(float *)(a1 + 12) * v3;
    *(float *)a1 = 1.0 - (v10 + v6);
    *(float *)(a1 + 4) = v13 + v4;
    *(float *)(a1 + 8) = v12 - v7;
    *(float *)(a1 + 12) = v13 - v4;
    *(float *)(a1 + 16) = 1.0 - (v15 + v6);
    *(float *)(a1 + 20) = v8 + v11;
    *(float *)(a1 + 24) = v12 + v7;
    *(float *)(a1 + 28) = v8 - v11;
    result = a1 + 32;
    *(float *)(a1 + 32) = 1.0 - (v15 + v10);
  }
  return result;
}

//----- (000363B2) --------------------------------------------------------
long double __cdecl QuatEigenTrace(float *a1)
{
  float v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]
  float v6; // [esp+8h] [ebp-10h]
  float v7; // [esp+Ch] [ebp-Ch]
  float v8; // [esp+Ch] [ebp-Ch]
  float v9; // [esp+10h] [ebp-8h]
  float v10; // [esp+10h] [ebp-8h]

  v9 = *a1 * *a1;
  v7 = a1[1] * a1[1];
  v5 = a1[2] * a1[2];
  v3 = v9 + v7 + v5 + a1[3] * a1[3];
  if ( v3 == 0.0 )
    return 0.0;
  v4 = 1.0 / v3;
  v10 = v9 * v4;
  v8 = v7 * v4;
  v6 = v5 * v4;
  return (float)(v10 + v8 + v6);
}

//----- (00036472) --------------------------------------------------------
long double __cdecl AngleEigenTrace(float a1)
{
  double v3; // [esp+18h] [ebp-10h]

  v3 = sin(a1 * 0.0174532925199433);
  return (float)(v3 * v3);
}

//----- (000364B2) --------------------------------------------------------
void __cdecl QuatRatioEigenTrace(int a1, int a2)
{
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  QuatInverse(a2, v3);
  QuatMultiply(a1, v3, v2);
  QuatEigenTrace(v2);
}
// 13A50: using guessed type _DWORD __cdecl QuatInverse(_DWORD, _DWORD);
// 14040: using guessed type _DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD);
// 15090: using guessed type double __cdecl QuatEigenTrace(_DWORD);

//----- (00036500) --------------------------------------------------------
long double __cdecl RotationToYaw(float *a1)
{
  float v3; // [esp+1Ch] [ebp-Ch]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  v5 = *a1 * *a1;
  v3 = a1[1] * a1[1] + v5;
  v4 = 2.0 / v3;
  return (float)(atan2(*a1 * a1[1] * v4, 1.0 - v5 * v4) * 57.29577951308232);
}

//----- (00036587) --------------------------------------------------------
float *__cdecl PitchToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return sub_381A6(v3, (float *)(a2 + 4), (float *)(a2 + 12));
}

//----- (000365E1) --------------------------------------------------------
float *__cdecl YawToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return sub_381A6(v3, (float *)(a2 + 8), (float *)(a2 + 12));
}

//----- (0003663B) --------------------------------------------------------
float *__cdecl RollToQuaternion(float a1, int a2)
{
  float v3; // [esp+20h] [ebp+8h]

  v3 = a1 * 0.008726646259971648;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return sub_381A6(v3, (float *)a2, (float *)(a2 + 12));
}

//----- (00036695) --------------------------------------------------------
int __cdecl ColorBytes3(float a1, float a2, float a3)
{
  int v4; // [esp+8h] [ebp-8h]

  LOBYTE(v4) = (__int16)(a1 * 255.0);
  BYTE1(v4) = (__int16)(a2 * 255.0);
  BYTE2(v4) = (__int16)(a3 * 255.0);
  HIBYTE(v4) = -1;
  return v4;
}

//----- (00036714) --------------------------------------------------------
int __cdecl ColorBytes4(float a1, float a2, float a3, float a4)
{
  int v5; // [esp+8h] [ebp-8h]

  LOBYTE(v5) = (__int16)(a1 * 255.0);
  BYTE1(v5) = (__int16)(a2 * 255.0);
  BYTE2(v5) = (__int16)(a3 * 255.0);
  HIBYTE(v5) = (__int16)(a4 * 255.0);
  return v5;
}

//----- (000367AA) --------------------------------------------------------
long double __cdecl NormalizeColor(float *a1, float *a2)
{
  float v3; // [esp+4h] [ebp-Ch]

  v3 = *a1;
  if ( a1[1] > (long double)*a1 )
    v3 = a1[1];
  if ( a1[2] > (long double)v3 )
    v3 = a1[2];
  if ( v3 == 0.0 )
  {
    a2[2] = 0.0;
    a2[1] = 0.0;
    *a2 = 0.0;
  }
  else
  {
    *a2 = *a1 / v3;
    a2[1] = a1[1] / v3;
    a2[2] = a1[2] / v3;
  }
  return v3;
}

//----- (0003687D) --------------------------------------------------------
long double __cdecl AngleMod(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (000368D0) --------------------------------------------------------
long double __cdecl LerpAngle(float a1, int a2, float a3)
{
  int v4; // [esp+4h] [ebp-Ch]

  v4 = a2;
  if ( *(float *)&a2 - a1 > 180.0 )
    *(float *)&v4 = *(float *)&a2 - 360.0;
  if ( *(float *)&v4 - a1 < -180.0 )
    *(float *)&v4 = *(float *)&v4 + 360.0;
  return (float)((*(float *)&v4 - a1) * a3 + a1);
}

//----- (00036950) --------------------------------------------------------
long double __cdecl AngleSubtract(float a1, float a2)
{
  float i; // [esp+4h] [ebp-8h]

  for ( i = a1 - a2; i > 180.0; i = i - 360.0 )
    ;
  while ( i < -180.0 )
    i = i + 360.0;
  return i;
}

//----- (000369C1) --------------------------------------------------------
float *__usercall AnglesSubtract@<eax>(long double a1@<st0>, float *a2, float *a3, float *a4)
{
  float *result; // eax

  AngleSubtract(*a2, *a3);
  *a4 = a1;
  AngleSubtract(a2[1], a3[1]);
  a4[1] = a1;
  AngleSubtract(a2[2], a3[2]);
  result = a4 + 2;
  a4[2] = a1;
  return result;
}

//----- (00036A3C) --------------------------------------------------------
long double __cdecl AngleNormalize360(float a1)
{
  return (long double)(unsigned __int16)(int)(a1 * 182.04445) * 0.0054931641;
}

//----- (00036A8F) --------------------------------------------------------
long double __usercall AngleNormalize180@<st0>(long double a1@<st0>, float a2)
{
  float v3; // [esp+10h] [ebp-8h]

  AngleNormalize360(a2);
  v3 = a1;
  if ( v3 > 180.0 )
    v3 = v3 - 360.0;
  return v3;
}

//----- (00036AE0) --------------------------------------------------------
long double __cdecl AngleNormalize360Accurate(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  if ( a1 >= 0.0 )
  {
    if ( a1 < 360.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 >= 360.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 < 0.0 );
    v2 = a1;
  }
  return v2;
}

//----- (00036B75) --------------------------------------------------------
long double __cdecl AngleNormalize180Accurate(float a1)
{
  float v2; // [esp+0h] [ebp-8h]

  if ( a1 > -180.0 )
  {
    if ( a1 <= 180.0 )
    {
      v2 = a1;
    }
    else
    {
      do
        a1 = a1 - 360.0;
      while ( a1 > 180.0 );
      v2 = a1;
    }
  }
  else
  {
    do
      a1 = a1 + 360.0;
    while ( a1 <= -180.0 );
    v2 = a1;
  }
  return v2;
}

//----- (00036C0A) --------------------------------------------------------
int __cdecl AngleDelta(float a1, float a2)
{
  float v3; // [esp+0h] [ebp-8h]

  v3 = a1 - a2;
  return AngleNormalize180(v3);
}

//----- (00036C30) --------------------------------------------------------
long double __cdecl RadiusFromBounds(int a1, int a2)
{
  float v3; // [esp+2Ch] [ebp-3Ch]
  float v5; // [esp+38h] [ebp-30h]
  float v6; // [esp+3Ch] [ebp-2Ch]
  float v7; // [esp+40h] [ebp-28h]
  float v8; // [esp+44h] [ebp-24h]
  float v9; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  for ( i = 0; i <= 2; ++i )
  {
    v6 = fabs(*(float *)(a1 + 4 * i));
    v5 = fabs(*(float *)(a2 + 4 * i));
    if ( v6 <= (long double)v5 )
      v3 = v5;
    else
      v3 = v6;
    *(&v7 + i) = v3;
  }
  return (float)sqrt(v7 * v7 + v8 * v8 + v9 * v9);
}

//----- (00036CE1) --------------------------------------------------------
int __cdecl ClearBounds(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[2] = 1216348160;
  a1[1] = 1216348160;
  *a1 = 1216348160;
  result = -931135488;
  a2[2] = -931135488;
  a2[1] = -931135488;
  *a2 = -931135488;
  return result;
}

//----- (00036D2B) --------------------------------------------------------
void __cdecl AddPointToBounds(float *a1, float *a2, float *a3)
{
  if ( *a2 > (long double)*a1 )
    *a2 = *a1;
  if ( *a1 > (long double)*a3 )
    *a3 = *a1;
  if ( a2[1] > (long double)a1[1] )
    a2[1] = a1[1];
  if ( a1[1] > (long double)a3[1] )
    a3[1] = a1[1];
  if ( a2[2] > (long double)a1[2] )
    a2[2] = a1[2];
  if ( a1[2] > (long double)a3[2] )
    a3[2] = a1[2];
}

//----- (00036E14) --------------------------------------------------------
void __cdecl ExpandBounds(float *a1, float *a2, float *a3, float *a4)
{
  if ( *a3 > (long double)*a1 )
    *a3 = *a1;
  if ( *a2 > (long double)*a4 )
    *a4 = *a2;
  if ( a3[1] > (long double)a1[1] )
    a3[1] = a1[1];
  if ( a2[1] > (long double)a4[1] )
    a4[1] = a2[1];
  if ( a3[2] > (long double)a1[2] )
    a3[2] = a1[2];
  if ( a2[2] > (long double)a4[2] )
    a4[2] = a2[2];
}

//----- (00036EFD) --------------------------------------------------------
_DWORD *__cdecl AxisClear(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 1065353216;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 0;
  a1[4] = 1065353216;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  result = a1 + 8;
  a1[8] = 1065353216;
  return result;
}

//----- (00036F6B) --------------------------------------------------------
int __cdecl AxisCopy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  result = a1[8];
  a2[8] = result;
  return result;
}

//----- (00036FFA) --------------------------------------------------------
_DWORD *__cdecl AnglesToAxis(int a1, float *a2)
{
  _DWORD *result; // eax
  float v3[6]; // [esp+10h] [ebp-18h] BYREF

  AngleVectors(a1, a2, v3, a2 + 6);
  a2[3] = 0.0 - v3[0];
  a2[4] = *(float *)&vec3_origin[1] - v3[1];
  result = vec3_origin;
  a2[5] = *(float *)&vec3_origin[2] - v3[2];
  return result;
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00037070) --------------------------------------------------------
_DWORD *__cdecl YawToAxis(float a1, int a2)
{
  _DWORD *result; // eax
  int v3[6]; // [esp+10h] [ebp-18h] BYREF

  YawVectors(a1, a2, (int)v3);
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 1065353216;
  *(float *)(a2 + 12) = 0.0 - *(float *)v3;
  *(float *)(a2 + 16) = *(float *)&vec3_origin[1] - *(float *)&v3[1];
  result = vec3_origin;
  *(float *)(a2 + 20) = *(float *)&vec3_origin[2] - *(float *)&v3[2];
  return result;
}

//----- (00037100) --------------------------------------------------------
int __cdecl AxisToAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectoangles(a1, a2);
  v9 = *((float *)a1 + 3);
  v10 = *((float *)a1 + 4);
  v11 = *((float *)a1 + 5);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 14EB0: using guessed type double __cdecl vectosignedpitch(_DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (00037278) --------------------------------------------------------
int __cdecl Axis4ToAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectoangles(a1, a2);
  v9 = *((float *)a1 + 4);
  v10 = *((float *)a1 + 5);
  v11 = *((float *)a1 + 6);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 14EB0: using guessed type double __cdecl vectosignedpitch(_DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (000373F0) --------------------------------------------------------
int __cdecl AxisToSignedAngles(int *a1, int a2)
{
  int result; // eax
  float v3; // [esp+20h] [ebp-38h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  float v5; // [esp+30h] [ebp-28h]
  float v6; // [esp+34h] [ebp-24h] BYREF
  float v7; // [esp+38h] [ebp-20h] BYREF
  float v8; // [esp+3Ch] [ebp-1Ch]
  float v9; // [esp+40h] [ebp-18h] BYREF
  float v10; // [esp+44h] [ebp-14h]
  float v11; // [esp+48h] [ebp-10h]

  vectosignedangles(a1, a2);
  v9 = *((float *)a1 + 3);
  v10 = *((float *)a1 + 4);
  v11 = *((float *)a1 + 5);
  v8 = -*(float *)(a2 + 4) * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v5 = v6 * v9 - v7 * v10;
  v10 = v7 * v9 + v6 * v10;
  v8 = -*(float *)a2 * 3.141592653589793 / 180.0;
  sub_381A6(v8, &v7, &v6);
  v9 = v7 * v11 + v6 * v5;
  v11 = v6 * v11 - v7 * v5;
  v4 = vectosignedpitch(&v9);
  if ( v10 >= 0.0 )
  {
    result = a2 + 8;
    *(_DWORD *)(a2 + 8) = LODWORD(v4) ^ 0x80000000;
  }
  else
  {
    if ( v4 >= 0.0 )
      v3 = v4 + -180.0;
    else
      v3 = v4 + 180.0;
    result = a2 + 8;
    *(float *)(a2 + 8) = v3;
  }
  return result;
}
// 14B00: using guessed type _DWORD __cdecl vectosignedangles(_DWORD, _DWORD);
// 14EB0: using guessed type double __cdecl vectosignedpitch(_DWORD);

//----- (00037568) --------------------------------------------------------
int __cdecl PlaneFromPoints(float *a1, float *a2, float *a3, float *a4)
{
  float v6[4]; // [esp+20h] [ebp-28h] BYREF
  float v7[6]; // [esp+30h] [ebp-18h] BYREF

  v7[0] = *a3 - *a2;
  v7[1] = a3[1] - a2[1];
  v7[2] = a3[2] - a2[2];
  v6[0] = *a4 - *a2;
  v6[1] = a4[1] - a2[1];
  v6[2] = a4[2] - a2[2];
  CrossProduct(v6, v7, a1);
  if ( VectorNormalize(a1) == 0.0 )
    return 0;
  a1[3] = *a2 * *a1 + a2[1] * a1[1] + a2[2] * a1[2];
  return 1;
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (00037666) --------------------------------------------------------
float *__cdecl ProjectPointOnPlane(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+8h] [ebp-30h]
  float v5; // [esp+Ch] [ebp-2Ch]
  float v6; // [esp+10h] [ebp-28h]
  float v7; // [esp+14h] [ebp-24h]
  float v8; // [esp+18h] [ebp-20h]
  float v9; // [esp+2Ch] [ebp-Ch]

  v4 = *a3 * *a3 + a3[1] * a3[1] + a3[2] * a3[2];
  v5 = 1.0 / v4;
  v9 = (*a3 * *a2 + a3[1] * a2[1] + a3[2] * a2[2]) * v5;
  v6 = *a3 * v5;
  v7 = a3[1] * v5;
  v8 = a3[2] * v5;
  *a1 = *a2 - v9 * v6;
  a1[1] = a2[1] - v9 * v7;
  result = a2 + 2;
  a1[2] = a2[2] - v9 * v8;
  return result;
}

//----- (00037758) --------------------------------------------------------
int __cdecl SetPlaneSignbits(int a1)
{
  int result; // eax
  int i; // [esp+0h] [ebp-Ch]
  unsigned __int8 v3; // [esp+7h] [ebp-5h]

  v3 = 0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a1 + 4 * i) < 0.0 )
      v3 |= 1 << i;
  }
  result = v3;
  *(_BYTE *)(a1 + 17) = v3;
  return result;
}

//----- (000377BE) --------------------------------------------------------
_BOOL4 __cdecl BoxDistSqrdExceeds(int a1, int a2, int a3, float a4)
{
  float v5; // [esp+0h] [ebp-48h]
  float v6; // [esp+4h] [ebp-44h]
  float v7; // [esp+8h] [ebp-40h]
  float v8; // [esp+Ch] [ebp-3Ch]
  float v9[4]; // [esp+10h] [ebp-38h]
  float v10[7]; // [esp+20h] [ebp-28h]
  int i; // [esp+3Ch] [ebp-Ch]

  v10[0] = *(float *)a1 - *(float *)a3;
  v10[1] = *(float *)(a1 + 4) - *(float *)(a3 + 4);
  v10[2] = *(float *)(a1 + 8) - *(float *)(a3 + 8);
  v9[0] = *(float *)a2 - *(float *)a3;
  v9[1] = *(float *)(a2 + 4) - *(float *)(a3 + 4);
  v9[2] = *(float *)(a2 + 8) - *(float *)(a3 + 8);
  v8 = 0.0;
  for ( i = 0; i <= 2; ++i )
  {
    if ( v10[i] * v9[i] > 0.0 )
    {
      v7 = v10[i] * v10[i];
      v6 = v9[i] * v9[i];
      if ( v7 <= (long double)v6 )
        v5 = v8 + v7;
      else
        v5 = v8 + v6;
      v8 = v5;
    }
  }
  return v8 > (long double)a4;
}

//----- (000378D2) --------------------------------------------------------
_BYTE *__cdecl NormalToLatLong(float *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  unsigned __int8 v3; // [esp+23h] [ebp-5h]

  if ( *a1 == 0.0 && a1[1] == 0.0 )
  {
    if ( a1[2] <= 0.0 )
      *a2 = 0x80;
    else
      *a2 = 0;
    result = a2 + 1;
    a2[1] = 0;
  }
  else
  {
    v3 = (__int16)(atan2(a1[1], *a1) * 180.0 / 3.141592653589793 * 0.7083333134651184);
    *a2 = (__int16)(acos(a1[2]) * 180.0 / 3.141592653589793 * 0.7083333134651184);
    result = (_BYTE *)v3;
    a2[1] = v3;
  }
  return result;
}

//----- (00037A00) --------------------------------------------------------
int __cdecl Vec10Copy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  a2[2] = a1[2];
  a2[3] = a1[3];
  a2[4] = a1[4];
  a2[5] = a1[5];
  a2[6] = a1[6];
  a2[7] = a1[7];
  a2[8] = a1[8];
  result = a1[9];
  a2[9] = result;
  return result;
}

//----- (00037A9F) --------------------------------------------------------
long double __cdecl Q_rint(float a1)
{
  return (float)floor(a1 + 0.5);
}

//----- (00037AD6) --------------------------------------------------------
long double __cdecl ColorNormalize(float *a1, float *a2)
{
  float v3; // [esp+0h] [ebp-14h]
  float v4; // [esp+4h] [ebp-10h]
  float v5; // [esp+8h] [ebp-Ch]

  v5 = *a1;
  if ( a1[1] > (long double)*a1 )
    v5 = a1[1];
  if ( a1[2] > (long double)v5 )
    v5 = a1[2];
  if ( v5 == 0.0 )
  {
    a2[2] = 1.0;
    a2[1] = 1.0;
    *a2 = 1.0;
    v3 = 0.0;
  }
  else
  {
    v4 = 1.0 / v5;
    *a2 = *a1 * v4;
    a2[1] = a1[1] * v4;
    a2[2] = a1[2] * v4;
    v3 = v5;
  }
  return v3;
}

//----- (00037BBE) --------------------------------------------------------
int __cdecl VectorRotateAngles(int *a1, int a2, _DWORD *a3)
{
  int result; // eax
  double v4; // [esp+20h] [ebp-68h] BYREF
  double v5; // [esp+28h] [ebp-60h] BYREF
  double v6; // [esp+30h] [ebp-58h]
  int i; // [esp+3Ch] [ebp-4Ch]
  int v8; // [esp+40h] [ebp-48h]
  int v9[7]; // [esp+44h] [ebp-44h]
  int v10; // [esp+60h] [ebp-28h]
  int v11; // [esp+64h] [ebp-24h]
  int v12; // [esp+68h] [ebp-20h]
  int v13; // [esp+70h] [ebp-18h]
  int v14; // [esp+74h] [ebp-14h]
  int v15; // [esp+78h] [ebp-10h]

  v10 = *a1;
  v11 = a1[1];
  v12 = a1[2];
  v13 = v10;
  v14 = v11;
  v15 = v12;
  v8 = 1;
  v9[0] = 2;
  v9[1] = 2;
  v9[2] = 0;
  v9[3] = 0;
  v9[4] = 1;
  for ( i = 0; i <= 2; ++i )
  {
    if ( *(float *)(a2 + 4 * i) != 0.0 )
    {
      v6 = *(float *)(a2 + 4 * i) * 3.141592653589793 / 180.0;
      sub_381BE(v6, &v4, &v5);
      *((float *)&v13 + *(&v8 + 2 * i)) = *((float *)&v10 + *(&v8 + 2 * i)) * v5 - *((float *)&v10 + v9[2 * i]) * v4;
      *((float *)&v13 + v9[2 * i]) = *((float *)&v10 + *(&v8 + 2 * i)) * v4 + *((float *)&v10 + v9[2 * i]) * v5;
    }
    v10 = v13;
    v11 = v14;
    v12 = v15;
  }
  *a3 = v13;
  a3[1] = v14;
  result = v15;
  a3[2] = v15;
  return result;
}

//----- (00037D3D) --------------------------------------------------------
float *__cdecl VectorRotateAnglesAroundPoint(float *a1, int a2, float *a3, float *a4)
{
  float *result; // eax
  float v5[4]; // [esp+10h] [ebp-28h] BYREF
  float v6[6]; // [esp+20h] [ebp-18h] BYREF

  v6[0] = *a1 - *a3;
  v6[1] = a1[1] - a3[1];
  v6[2] = a1[2] - a3[2];
  VectorRotateAngles(v6, a2, v5);
  *a4 = v5[0] + *a3;
  a4[1] = v5[1] + a3[1];
  result = a3 + 2;
  a4[2] = v5[2] + a3[2];
  return result;
}
// 15510: using guessed type _DWORD __cdecl VectorRotateAngles(_DWORD, _DWORD, _DWORD);

//----- (00037DD4) --------------------------------------------------------
int __cdecl VectorPolar(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-10h] BYREF
  float v5; // [esp+1Ch] [ebp-Ch] BYREF
  float v6; // [esp+20h] [ebp-8h] BYREF
  float v7; // [esp+24h] [ebp-4h] BYREF

  sub_381A6(*(float *)&a3, &v7, &v6);
  sub_381A6(*(float *)&a3, &v5, &v4);
  *(float *)a1 = a2 * v6 * v4;
  *(float *)(a1 + 4) = a2 * v7 * v4;
  result = a1 + 8;
  *(float *)(a1 + 8) = a2 * v5;
  return result;
}

//----- (00037E3B) --------------------------------------------------------
void __cdecl VectorSnap(float *a1)
{
  *a1 = floor(*a1 + 0.5);
  a1[1] = floor(a1[1] + 0.5);
  a1[2] = floor(a1[2] + 0.5);
}

//----- (00037EAF) --------------------------------------------------------
float *__cdecl Vector5Add(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  a3[3] = a1[3] + a2[3];
  result = a1 + 4;
  a3[4] = a1[4] + a2[4];
  return result;
}

//----- (00037F23) --------------------------------------------------------
int __cdecl Vector5Scale(int a1, float a2, int a3)
{
  int result; // eax

  *(float *)a3 = *(float *)a1 * a2;
  *(float *)(a3 + 4) = *(float *)(a1 + 4) * a2;
  *(float *)(a3 + 8) = *(float *)(a1 + 8) * a2;
  *(float *)(a3 + 12) = *(float *)(a1 + 12) * a2;
  result = a1 + 16;
  *(float *)(a3 + 16) = *(float *)(a1 + 16) * a2;
  return result;
}

//----- (00037F81) --------------------------------------------------------
int __cdecl Vector53Copy(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *a1;
  a2[1] = a1[1];
  result = a1[2];
  a2[2] = result;
  return result;
}

//----- (00037FB0) --------------------------------------------------------
long double __cdecl RoundFloat(float a1, int a2)
{
  long double v2; // fst7
  double v5; // [esp+30h] [ebp-18h]
  double x[2]; // [esp+38h] [ebp-10h] BYREF

  x[0] = pow(10.0, (double)a2) * a1;
  v5 = modf(x[0], x);
  if ( v5 < 0.5 )
  {
    if ( v5 <= -0.5 )
      x[0] = x[0] + -1.0;
  }
  else
  {
    x[0] = x[0] + 1.0;
  }
  v2 = pow(0.1, (double)a2);
  return (float)(v2 * x[0]);
}

//----- (00038079) --------------------------------------------------------
void __cdecl PitchForYawOnNormal(float a1, int a2)
{
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  int v3[6]; // [esp+20h] [ebp-18h] BYREF

  YawVectors(a1, (int)v3, 0);
  ProjectPointOnPlane(v2, v3, a2);
  vectopitch(v2);
}
// 13180: using guessed type long double __cdecl vectopitch(_DWORD);
// 15710: using guessed type _DWORD __cdecl ProjectPointOnPlane(_DWORD, _DWORD, _DWORD);

//----- (000380CF) --------------------------------------------------------
int __cdecl Rand_Init(int a1)
{
  int result; // eax

  result = a1;
  dword_82B18 = a1;
  return result;
}
// 82B18: using guessed type int dword_82B18;

//----- (000380EA) --------------------------------------------------------
long double __cdecl flrand(float a1, float a2)
{
  float v3; // [esp+4h] [ebp-8h]

  dword_82B18 = 214013 * dword_82B18 + 2531011;
  v3 = (float)((unsigned int)dword_82B18 >> 17);
  return (float)((a2 - a1) * v3 / 32768.0 + a1);
}
// 82B18: using guessed type int dword_82B18;

//----- (00038153) --------------------------------------------------------
int __cdecl irand(int a1, int a2)
{
  dword_82B18 = 214013 * dword_82B18 + 2531011;
  return a1 + ((int)(((unsigned int)dword_82B18 >> 17) * (a2 - a1)) >> 15);
}
// 82B18: using guessed type int dword_82B18;

//----- (000381A6) --------------------------------------------------------
float *__cdecl sub_381A6(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (000381BE) --------------------------------------------------------
double *__cdecl sub_381BE(double a1, double *a2, double *a3)
{
  long double v3; // fst7
  double *result; // eax

  *a2 = sin(a1);
  v3 = cos(a1);
  result = a3;
  *a3 = v3;
  return result;
}

//----- (00038210) --------------------------------------------------------
void sub_38210()
{
  ;
}

//----- (00038214) --------------------------------------------------------
int __cdecl P_DamageFeedback(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+2Ch] [ebp-6Ch]
  float v3[15]; // [esp+30h] [ebp-68h] BYREF
  float v4; // [esp+6Ch] [ebp-2Ch]
  float v5[6]; // [esp+70h] [ebp-28h] BYREF
  int v6; // [esp+88h] [ebp-10h]
  int v7; // [esp+8Ch] [ebp-Ch]

  v7 = a1[87];
  result = v7;
  if ( *(int *)(v7 + 4) <= 5 )
  {
    result = *(_DWORD *)(v7 + 8732);
    v6 = result;
    if ( result > 0 )
    {
      result = v7;
      if ( *(int *)(v7 + 8524) > 0 )
      {
        v6 = 100 * v6 / *(_DWORD *)(v7 + 8524);
        if ( v6 > 127 )
          v6 = 127;
        *(float *)(v7 + 984) = (long double)v6 + *(float *)(v7 + 984);
        if ( *(float *)(v7 + 984) > 255.0 )
          *(_DWORD *)(v7 + 984) = 1132396544;
        v4 = (long double)v6 * 0.2;
        if ( v4 >= 5.0 )
        {
          if ( v4 > 90.0 )
            v4 = 90.0;
        }
        else
        {
          v4 = 5.0;
        }
        if ( *(_DWORD *)(v7 + 8748) )
        {
          *(_DWORD *)(v7 + 8824) = 0;
          *(_DWORD *)(v7 + 8828) = LODWORD(v4) ^ 0x80000000;
          *(_DWORD *)(v7 + 236) = 255;
          *(_DWORD *)(v7 + 232) = 255;
          *(_DWORD *)(v7 + 8748) = 0;
        }
        else
        {
          vectoangles(v7 + 8736, v5);
          AnglesToAxis(v7 + 192, v3);
          *(float *)(v7 + 8824) = -v4
                                * (*(float *)(v7 + 8736) * v3[3]
                                 + *(float *)(v7 + 8740) * v3[4]
                                 + *(float *)(v7 + 8744) * v3[5]);
          *(float *)(v7 + 8828) = (*(float *)(v7 + 8736) * v3[0]
                                 + *(float *)(v7 + 8740) * v3[1]
                                 + *(float *)(v7 + 8744) * v3[2])
                                * v4;
          *(_DWORD *)(v7 + 236) = (int)(v5[0] / 360.0 * 256.0);
          *(_DWORD *)(v7 + 232) = (int)(v5[1] / 360.0 * 256.0);
        }
        if ( level[122] > a1[139] && (a1[97] & 1) == 0 )
        {
          v2 = (int)((long double)*(int *)(v7 + 244) / (long double)*(int *)(v7 + 252) * 100.0);
          if ( v2 >= 0 )
          {
            if ( v2 > 100 )
              v2 = 100;
            G_AddEvent(a1, 187, v2);
          }
          else
          {
            G_AddEvent(a1, 187, 0);
          }
          a1[139] = level[122] + 700;
        }
        ++*(_DWORD *)(v7 + 228);
        *(_DWORD *)(v7 + 8820) = level[122] - 20;
        *(_DWORD *)(v7 + 240) = v6;
        result = v7;
        *(_DWORD *)(v7 + 8732) = 0;
      }
    }
  }
  return result;
}
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (00038562) --------------------------------------------------------
int __cdecl G_SetClientSound(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 132) = 0;
  return result;
}

//----- (00038574) --------------------------------------------------------
int __cdecl ClientImpacts(int a1, int a2)
{
  int result; // eax
  char *v3; // [esp+14h] [ebp-14h]
  int j; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= *(_DWORD *)(a2 + 60) )
      break;
    for ( j = 0; j < i && *(_DWORD *)(a2 + 4 * j + 64) != *(_DWORD *)(a2 + 4 * i + 64); ++j )
      ;
    if ( j == i )
    {
      v3 = (char *)&g_entities + 796 * *(_DWORD *)(a2 + 4 * i + 64);
      if ( Scr_IsSystemActive(1) )
      {
        Scr_AddEntity(v3);
        Scr_Notify(a1, scr_const[72], 1);
        Scr_AddEntity(a1);
        Scr_Notify(v3, scr_const[72], 1);
      }
      if ( *((_DWORD *)v3 + 133) )
        (*((void (__cdecl **)(char *, int, int))v3 + 133))(v3, a1, 1);
      if ( *(_DWORD *)(a1 + 532) )
        (*(void (__cdecl **)(int, char *, int))(a1 + 532))(a1, v3, 1);
    }
  }
  return result;
}
// 13D80: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000386CF) --------------------------------------------------------
int __cdecl G_TouchTriggers(int a1)
{
  int result; // eax
  float v2; // [esp+20h] [ebp-1048h] BYREF
  float v3; // [esp+24h] [ebp-1044h]
  float v4; // [esp+28h] [ebp-1040h]
  float v5; // [esp+30h] [ebp-1038h] BYREF
  float v6; // [esp+34h] [ebp-1034h]
  float v7; // [esp+38h] [ebp-1030h]
  int v8; // [esp+4Ch] [ebp-101Ch]
  int v9[1026]; // [esp+50h] [ebp-1018h] BYREF
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  result = a1;
  if ( *(_DWORD *)(a1 + 348) )
  {
    result = *(_DWORD *)(a1 + 348);
    if ( *(int *)(result + 4) <= 1 )
    {
      v5 = *(float *)(*(_DWORD *)(a1 + 348) + 20) - flt_82B1C;
      v6 = *(float *)(*(_DWORD *)(a1 + 348) + 24) - flt_82B20;
      v7 = *(float *)(*(_DWORD *)(a1 + 348) + 28) - flt_82B24;
      v2 = *(float *)(*(_DWORD *)(a1 + 348) + 20) + flt_82B1C;
      v3 = *(float *)(*(_DWORD *)(a1 + 348) + 24) + flt_82B20;
      v4 = *(float *)(*(_DWORD *)(a1 + 348) + 28) + flt_82B24;
      v10 = trap_EntitiesInBox(&v5, &v2, v9, 1024, 1079771144);
      v5 = *(float *)(*(_DWORD *)(a1 + 348) + 20) + *(float *)(a1 + 260);
      v6 = *(float *)(*(_DWORD *)(a1 + 348) + 24) + *(float *)(a1 + 264);
      v7 = *(float *)(*(_DWORD *)(a1 + 348) + 28) + *(float *)(a1 + 268);
      v2 = *(float *)(*(_DWORD *)(a1 + 348) + 20) + *(float *)(a1 + 272);
      v3 = *(float *)(*(_DWORD *)(a1 + 348) + 24) + *(float *)(a1 + 276);
      v4 = *(float *)(*(_DWORD *)(a1 + 348) + 28) + *(float *)(a1 + 280);
      for ( i = 0; ; ++i )
      {
        result = i;
        if ( i >= v10 )
          return result;
        v8 = (int)&g_entities + 796 * v9[i];
        if ( *(_DWORD *)(v8 + 532) || *(_DWORD *)(a1 + 532) )
        {
          if ( *(_DWORD *)(v8 + 4) == 3 )
          {
            if ( !BG_PlayerTouchesItem(*(_DWORD *)(a1 + 348), v8, level[122]) )
              continue;
          }
          else if ( !trap_EntityContact(&v5, &v2, v8) )
          {
            continue;
          }
          if ( Scr_IsSystemActive(1) )
          {
            Scr_AddEntity(a1);
            Scr_Notify(v8, scr_const[72], 1);
            Scr_AddEntity(v8);
            Scr_Notify(a1, scr_const[72], 1);
          }
          if ( *(_DWORD *)(v8 + 532) )
            (*(void (__cdecl **)(int, int, int))(v8 + 532))(v8, a1, 1);
        }
      }
    }
  }
  return result;
}
// 134E0: using guessed type _DWORD __cdecl BG_PlayerTouchesItem(_DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13A20: using guessed type _DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD);
// 13D80: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 82B1C: using guessed type float flt_82B1C;
// 82B20: using guessed type float flt_82B20;
// 82B24: using guessed type float flt_82B24;

//----- (000389EB) --------------------------------------------------------
int __cdecl SpectatorThink(_DWORD *a1, int *a2)
{
  int result; // eax
  int v3; // [esp+1Ch] [ebp-10Ch]
  int s[66]; // [esp+20h] [ebp-108h] BYREF

  v3 = a1[87];
  *(_DWORD *)(v3 + 8692) = *(_DWORD *)(v3 + 8688);
  *(_DWORD *)(v3 + 8688) = *(unsigned __int8 *)(v3 + 8432);
  *(_DWORD *)(v3 + 8704) = *(_DWORD *)(v3 + 8700);
  *(_DWORD *)(v3 + 8700) = *(unsigned __int8 *)(v3 + 8433);
  if ( *(int *)(v3 + 8400) < 0
    && G_ClientCanSpectateTeam(v3, 4)
    && *(int *)(v3 + 8668) >= 0
    && (*(_DWORD *)(v3 + 8688) & 0x10) != (*(_DWORD *)(v3 + 8692) & 0x10) )
  {
    StopFollowing(a1);
  }
  if ( (*(_DWORD *)(v3 + 8688) & 1) == 0 || (*(_DWORD *)(v3 + 8692) & 1) != 0 )
  {
    if ( (*(_DWORD *)(v3 + 8688) & 0x20) != 0 && (*(_DWORD *)(v3 + 8692) & 0x20) == 0 )
      Cmd_FollowCycle_f(a1, -1);
  }
  else
  {
    Cmd_FollowCycle_f(a1, 1);
  }
  result = *(_DWORD *)(v3 + 12) & 0x10000;
  if ( !result )
  {
    *(_DWORD *)(v3 + 4) = 4;
    if ( G_ClientCanSpectateTeam(v3, 4) )
      *(_DWORD *)(v3 + 68) = 400;
    else
      *(_DWORD *)(v3 + 68) = 0;
    memset(s, 0, 0xFCu);
    s[0] = v3;
    s[1] = *a2;
    s[2] = a2[1];
    s[3] = a2[2];
    s[4] = a2[3];
    s[5] = a2[4];
    s[6] = a2[5];
    s[13] = 8388625;
    s[59] = (int)trap_TraceCapsule;
    s[60] = (int)trap_TraceCapsule;
    s[61] = (int)trap_TraceCapsule;
    s[62] = (int)trap_PointContents;
    Pmove(s);
    a1[78] = *(_DWORD *)(v3 + 20);
    a1[79] = *(_DWORD *)(v3 + 24);
    a1[80] = *(_DWORD *)(v3 + 28);
    result = trap_UnlinkEntity(a1);
  }
  return result;
}
// 135D0: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 13BC0: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 13F80: using guessed type _DWORD __cdecl Pmove(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14E70: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);
// 67EC4: using guessed type int __cdecl trap_TraceCapsule(int, int, int, int, int, int, int);
// 681CE: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (00038C8C) --------------------------------------------------------
int __cdecl ClientInactivityTimer(int a1)
{
  if ( !g_inactivity[3] )
  {
    *(_DWORD *)(a1 + 8764) = level[122] + 60000;
    *(_DWORD *)(a1 + 8768) = 0;
    return 1;
  }
  if ( *(_BYTE *)(a1 + 8448) || *(_BYTE *)(a1 + 8449) || *(_BYTE *)(a1 + 8450) || (*(_BYTE *)(a1 + 8432) & 1) != 0 )
  {
    *(_DWORD *)(a1 + 8764) = level[122] + 1000 * g_inactivity[3];
    *(_DWORD *)(a1 + 8768) = 0;
    return 1;
  }
  if ( *(_DWORD *)(a1 + 8476) )
    return 1;
  if ( level[122] <= *(_DWORD *)(a1 + 8764) )
  {
    if ( level[122] > *(_DWORD *)(a1 + 8764) - 10000 && !*(_DWORD *)(a1 + 8768) )
    {
      *(_DWORD *)(a1 + 8768) = 1;
      trap_SendServerCommand(-559290757 * ((a1 - level[0]) >> 2), 0, "c \"GAME_INACTIVEDROPWARNING\"");
    }
    return 1;
  }
  trap_DropClient(-559290757 * ((a1 - level[0]) >> 2), "GAME_DROPPEDFORINACTIVITY");
  return 0;
}
// 14280: using guessed type _DWORD __cdecl trap_DropClient(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00038E10) --------------------------------------------------------
int __cdecl ClientIntermissionThink(int a1)
{
  int result; // eax
  int v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v2 + 8692) = *(_DWORD *)(v2 + 8688);
  *(_DWORD *)(v2 + 8688) = *(unsigned __int8 *)(v2 + 8432);
  *(_DWORD *)(v2 + 8704) = *(_DWORD *)(v2 + 8700);
  result = *(unsigned __int8 *)(v2 + 8433);
  *(_DWORD *)(v2 + 8700) = result;
  return result;
}

//----- (00038E6E) --------------------------------------------------------
_DWORD *__cdecl ClientEvents(_DWORD *a1, int a2)
{
  _DWORD *result; // eax
  float v3; // [esp+5Ch] [ebp-1Ch]
  float v4; // [esp+5Ch] [ebp-1Ch]
  int v5; // [esp+60h] [ebp-18h]
  int v6; // [esp+64h] [ebp-14h]
  int v7; // [esp+68h] [ebp-10h]
  int i; // [esp+6Ch] [ebp-Ch]

  v5 = a1[87];
  if ( a2 < *(_DWORD *)(v5 + 132) - 4 )
    a2 = *(_DWORD *)(v5 + 132) - 4;
  for ( i = a2; ; ++i )
  {
    result = (_DWORD *)i;
    if ( i >= *(_DWORD *)(v5 + 132) )
      break;
    v7 = *(_DWORD *)(v5 + 4 * (i & 3) + 136);
    v6 = *(_DWORD *)(v5 + 4 * (i & 3) + 152);
    if ( v7 <= 115 || v7 > 138 )
    {
      switch ( v7 )
      {
        case 159:
        case 160:
        case 161:
        case 168:
          FireWeapon(a1);
          break;
        case 165:
          FireWeaponMelee(a1);
          break;
        case 196:
          if ( *(_DWORD *)(a1[87] + 176) && Com_BitCheck(a1[87] + 780, *(_DWORD *)(a1[87] + 176)) )
            Drop_Weapon(a1, *(_DWORD *)(a1[87] + 176), "tag_weapon_right");
          break;
        default:
          continue;
      }
    }
    else
    {
      result = a1;
      if ( a1[1] != 1 )
        return result;
      if ( v6 <= 99 )
        v3 = (long double)v6 * 0.0099999998;
      else
        v3 = 1.1;
      if ( v3 != 0.0 )
      {
        v4 = (long double)*(int *)(v5 + 252) * v3;
        a1[139] = level[122] + 200;
        G_Damage(a1, 0, 0, 0, 0, (int)v4, 0, 21, 0);
      }
    }
  }
  return result;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13510: using guessed type _DWORD __cdecl FireWeaponMelee(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 14140: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 155F0: using guessed type _DWORD __cdecl FireWeapon(_DWORD);

//----- (000390A1) --------------------------------------------------------
int __cdecl G_SetClientContents(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8672) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8676) )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) = 0;
  }
  else
  {
    result = a1;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) == 1 )
      *(_DWORD *)(a1 + 284) = 0;
    else
      *(_DWORD *)(a1 + 284) = 0x2000000;
  }
  return result;
}

//----- (00039116) --------------------------------------------------------
int __cdecl ClientThink_real(int a1, int *a2)
{
  int result; // eax
  char v3[48]; // [esp+40h] [ebp-258h] BYREF
  char v4[48]; // [esp+70h] [ebp-228h] BYREF
  char v5[48]; // [esp+A0h] [ebp-1F8h] BYREF
  int v6; // [esp+D0h] [ebp-1C8h]
  float v7; // [esp+D4h] [ebp-1C4h]
  float v8; // [esp+D8h] [ebp-1C0h]
  int v9; // [esp+DCh] [ebp-1BCh]
  float v10[4]; // [esp+E0h] [ebp-1B8h] BYREF
  float v11; // [esp+F0h] [ebp-1A8h] BYREF
  float v12; // [esp+F4h] [ebp-1A4h]
  float v13; // [esp+F8h] [ebp-1A0h]
  int v14[3]; // [esp+100h] [ebp-198h] BYREF
  int v15; // [esp+10Ch] [ebp-18Ch]
  int v16; // [esp+110h] [ebp-188h]
  int v17; // [esp+114h] [ebp-184h]
  int v18; // [esp+118h] [ebp-180h]
  int v19; // [esp+11Ch] [ebp-17Ch]
  int v20; // [esp+120h] [ebp-178h]
  int v21; // [esp+124h] [ebp-174h]
  int v22; // [esp+128h] [ebp-170h]
  int v23; // [esp+12Ch] [ebp-16Ch]
  int v24; // [esp+130h] [ebp-168h]
  int v25; // [esp+134h] [ebp-164h]
  int v26; // [esp+138h] [ebp-160h]
  int v27; // [esp+13Ch] [ebp-15Ch]
  int v28; // [esp+140h] [ebp-158h]
  int v29; // [esp+144h] [ebp-154h]
  int v30; // [esp+148h] [ebp-150h]
  int v31; // [esp+14Ch] [ebp-14Ch]
  int v32[2]; // [esp+150h] [ebp-148h] BYREF
  int v33; // [esp+158h] [ebp-140h]
  int v34; // [esp+15Ch] [ebp-13Ch]
  int v35; // [esp+160h] [ebp-138h]
  int v36; // [esp+164h] [ebp-134h]
  int v37; // [esp+178h] [ebp-120h]
  int v38; // [esp+17Ch] [ebp-11Ch]
  int s[13]; // [esp+180h] [ebp-118h] BYREF
  int v40; // [esp+1B4h] [ebp-E4h]
  int v41; // [esp+1B8h] [ebp-E0h]
  int v42; // [esp+240h] [ebp-58h]
  int v43; // [esp+244h] [ebp-54h]
  int v44; // [esp+248h] [ebp-50h]
  int v45; // [esp+24Ch] [ebp-4Ch]
  int v46; // [esp+250h] [ebp-48h]
  int v47; // [esp+254h] [ebp-44h]
  char v48; // [esp+258h] [ebp-40h]
  char v49; // [esp+259h] [ebp-3Fh]
  int v50; // [esp+260h] [ebp-38h]
  int v51; // [esp+264h] [ebp-34h]
  int (__cdecl *v52)(int, int, int, int, int, int, int); // [esp+26Ch] [ebp-2Ch]
  int (__cdecl *v53)(int, int, int, int, int, int, int); // [esp+270h] [ebp-28h]
  int (__cdecl *v54)(int, int, int, int, int, int, int); // [esp+274h] [ebp-24h]
  int (__cdecl *v55)(int, int, int); // [esp+278h] [ebp-20h]
  int v56; // [esp+28Ch] [ebp-Ch]

  v56 = *(_DWORD *)(a1 + 348);
  result = v56;
  if ( *(_DWORD *)(v56 + 8424) == 2 )
  {
    if ( *a2 > level[122] + 200 )
      *a2 = level[122] + 200;
    if ( *a2 < level[122] - 1000 )
      *a2 = level[122] - 1000;
    v37 = *a2 - *(_DWORD *)v56;
    if ( v37 > 0 || (result = -280575753 * ((a1 - (int)&g_entities) >> 2), *(_DWORD *)(v56 + 172) != result) )
    {
      if ( v37 > 200 )
        v37 = 200;
      if ( pmove_msec[3] > 7 )
      {
        if ( pmove_msec[3] > 33 )
          trap_Cvar_Set("pmove_msec", "33");
      }
      else
      {
        trap_Cvar_Set("pmove_msec", &unk_77B44);
      }
      if ( pmove_fixed[3] || *(_DWORD *)(v56 + 8484) )
        *a2 = pmove_msec[3] * ((*a2 + pmove_msec[3] - 1) / pmove_msec[3]);
      if ( *(_DWORD *)(v56 + 8396) == 3 )
      {
        result = ClientIntermissionThink(a1);
      }
      else if ( *(_DWORD *)(v56 + 8396) == 2 )
      {
        result = SpectatorThink(a1, a2);
      }
      else
      {
        result = ClientInactivityTimer(v56);
        if ( result )
        {
          v38 = *(_DWORD *)(v56 + 132);
          memset(s, 0, 0xFCu);
          s[0] = v56;
          s[1] = *a2;
          s[2] = a2[1];
          s[3] = a2[2];
          s[4] = a2[3];
          s[5] = a2[4];
          s[6] = a2[5];
          s[7] = *(_DWORD *)(v56 + 8452);
          s[8] = *(_DWORD *)(v56 + 8456);
          s[9] = *(_DWORD *)(v56 + 8460);
          s[10] = *(_DWORD *)(v56 + 8464);
          s[11] = *(_DWORD *)(v56 + 8468);
          s[12] = *(_DWORD *)(v56 + 8472);
          if ( *(int *)(v56 + 4) <= 5 )
            v40 = 42008593;
          else
            v40 = 8454161;
          v52 = trap_TraceCapsule;
          v53 = trap_TraceCapsule;
          v54 = trap_TraceCapsule;
          v55 = trap_PointContents;
          v41 = g_debugMove[3];
          v50 = pmove_fixed[3] | *(_DWORD *)(v56 + 8484);
          v51 = pmove_msec[3];
          *(_DWORD *)(v56 + 8712) = *(_DWORD *)(v56 + 20);
          *(_DWORD *)(v56 + 8716) = *(_DWORD *)(v56 + 24);
          *(_DWORD *)(v56 + 8720) = *(_DWORD *)(v56 + 28);
          *(_DWORD *)(v56 + 8692) = *(_DWORD *)(v56 + 8688);
          *(_DWORD *)(v56 + 8688) = *(unsigned __int8 *)(v56 + 8432);
          *(_DWORD *)(v56 + 8696) = *(_DWORD *)(v56 + 8688) & ~*(_DWORD *)(v56 + 8692);
          *(_DWORD *)(v56 + 8704) = *(_DWORD *)(v56 + 8700);
          *(_DWORD *)(v56 + 8700) = *(unsigned __int8 *)(v56 + 8433);
          *(_DWORD *)(v56 + 8708) = *(_DWORD *)(v56 + 8700) & ~*(_DWORD *)(v56 + 8704);
          v32[0] = v56;
          v32[1] = *(_DWORD *)(v56 + 8820);
          v33 = level[122];
          v34 = *(_DWORD *)(v56 + 8828);
          v35 = *(_DWORD *)(v56 + 8824);
          *(float *)&v36 = BG_GetSpeed(v56, v33);
          BG_CalculateViewAngles(v32, v10);
          v11 = *(float *)(v56 + 192) + v10[0];
          v12 = *(float *)(v56 + 196) + v10[1];
          v13 = *(float *)(v56 + 200) + v10[2];
          v9 = BG_GetInfoForWeapon(*(_DWORD *)(v56 + 176));
          v6 = *(_DWORD *)(v56 + 992) + *(_DWORD *)(v56 + 996) - v33;
          if ( v6 <= 0 )
          {
            v7 = 1.0;
          }
          else
          {
            v8 = 1.0;
            if ( v6 <= 2999 )
              v8 = (long double)v6 / 3000.0;
            v8 = (3.0 - (v8 + v8)) * v8 * v8;
            v7 = (*(float *)(v9 + 672) - 1.0) * v8 + 1.0;
          }
          BG_CalculateWeaponPosition_Sway(v56, v56 + 8832, v56 + 8844, v56 + 8856, 1.0, v37);
          v14[0] = v32[0];
          v14[1] = v36;
          *(float *)&v14[2] = (long double)v37 * 0.001;
          v15 = *(_DWORD *)(v56 + 8868);
          v16 = *(_DWORD *)(v56 + 8872);
          v17 = *(_DWORD *)(v56 + 8876);
          v18 = *(_DWORD *)(v56 + 8880);
          v19 = v33;
          v20 = *(_DWORD *)(v56 + 8820);
          v21 = *(_DWORD *)(v56 + 8828);
          v22 = *(_DWORD *)(v56 + 8824);
          v23 = *(_DWORD *)(v56 + 8884);
          v24 = *(_DWORD *)(v56 + 8888);
          v25 = *(_DWORD *)(v56 + 8892);
          v26 = *(_DWORD *)(v56 + 8896);
          v27 = *(_DWORD *)(v56 + 8900);
          v28 = *(_DWORD *)(v56 + 8904);
          v29 = *(_DWORD *)(v56 + 8856);
          v30 = *(_DWORD *)(v56 + 8860);
          v31 = *(_DWORD *)(v56 + 8864);
          BG_CalculateWeaponAngles(v14, v10);
          if ( BG_IsAimDownSightWeapon(*(_DWORD *)(v14[0] + 176)) && *(float *)(v14[0] + 184) != 0.0 )
          {
            AnglesToAxis(v10, v5);
            AnglesToAxis(&v11, v4);
            MatrixMultiply(v5, v4, v3);
            AxisToAngles(v3, &v11);
          }
          *(_DWORD *)(v56 + 8868) = v15;
          *(_DWORD *)(v56 + 8872) = v16;
          *(_DWORD *)(v56 + 8876) = v17;
          *(_DWORD *)(v56 + 8880) = v18;
          *(_DWORD *)(v56 + 8884) = v23;
          *(_DWORD *)(v56 + 8888) = v24;
          *(_DWORD *)(v56 + 8892) = v25;
          *(_DWORD *)(v56 + 8896) = v26;
          *(_DWORD *)(v56 + 8900) = v27;
          *(_DWORD *)(v56 + 8904) = v28;
          *(float *)(v56 + 8724) = v11;
          *(float *)(v56 + 8728) = v12;
          Pmove(s);
          *(_DWORD *)(a1 + 224) = (*(_DWORD *)(*(_DWORD *)(a1 + 348) + 12) & 2) != 0;
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 132) != v38 )
          {
            *(_DWORD *)(a1 + 392) = level[122];
            *(_DWORD *)(a1 + 340) = level[122];
          }
          if ( g_smoothClients[3] )
            BG_PlayerStateToEntityStateExtrapolate(*(_DWORD *)(a1 + 348), a1, **(_DWORD **)(a1 + 348), 1);
          else
            BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 348), a1, 1);
          *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 24);
          *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 28);
          *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 260) = v42;
          *(_DWORD *)(a1 + 264) = v43;
          *(_DWORD *)(a1 + 268) = v44;
          *(_DWORD *)(a1 + 272) = v45;
          *(_DWORD *)(a1 + 276) = v46;
          *(_DWORD *)(a1 + 280) = v47;
          *(_BYTE *)(a1 + 372) = v49;
          *(_BYTE *)(a1 + 371) = v48;
          ClientEvents(a1, v38);
          trap_LinkEntity(a1);
          if ( !*(_DWORD *)(*(_DWORD *)(a1 + 348) + 8672) )
            G_TouchTriggers(a1);
          *(_DWORD *)(a1 + 312) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 20);
          *(_DWORD *)(a1 + 316) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 24);
          *(_DWORD *)(a1 + 320) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 28);
          *(_DWORD *)(a1 + 332) = 0;
          *(_DWORD *)(a1 + 328) = 0;
          *(_DWORD *)(a1 + 324) = 0;
          *(_DWORD *)(a1 + 328) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 196);
          ClientImpacts(a1, s);
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 132) != v38 )
            *(_DWORD *)(a1 + 392) = level[122];
          result = *(_DWORD *)(v56 + 8696) & 0x40;
          if ( result )
            result = Cmd_Activate_f(a1);
        }
      }
    }
  }
  return result;
}
// 13010: using guessed type _DWORD __cdecl ClientEvents(_DWORD, _DWORD);
// 131A0: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 132F0: using guessed type _DWORD __cdecl ClientInactivityTimer(_DWORD);
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13910: using guessed type _DWORD __cdecl SpectatorThink(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13F80: using guessed type _DWORD __cdecl Pmove(_DWORD);
// 14060: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 14160: using guessed type _DWORD __cdecl BG_CalculateWeaponAngles(_DWORD, _DWORD);
// 141E0: using guessed type _DWORD __cdecl BG_CalculateViewAngles(_DWORD, _DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14740: using guessed type _DWORD __cdecl BG_IsAimDownSightWeapon(_DWORD);
// 14980: using guessed type _DWORD __cdecl G_TouchTriggers(_DWORD);
// 14E60: using guessed type _DWORD __cdecl ClientIntermissionThink(_DWORD);
// 15080: using guessed type double __cdecl BG_GetSpeed(_DWORD, _DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 15590: using guessed type _DWORD __cdecl ClientImpacts(_DWORD, _DWORD);
// 156B0: using guessed type _DWORD __cdecl Cmd_Activate_f(_DWORD);
// 158F0: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 67EC4: using guessed type int __cdecl trap_TraceCapsule(int, int, int, int, int, int, int);
// 681CE: using guessed type int __cdecl trap_PointContents(int, int, int);

//----- (00039BB9) --------------------------------------------------------
_DWORD *__cdecl ClientThink(int a1)
{
  _DWORD *v1; // ecx
  _DWORD *result; // eax
  char *v3; // [esp+10h] [ebp-8h]

  v3 = (char *)&g_entities + 796 * a1;
  v1 = (_DWORD *)*((_DWORD *)v3 + 87);
  v1[2113] = v1[2107];
  v1[2114] = v1[2108];
  v1[2115] = v1[2109];
  v1[2116] = v1[2110];
  v1[2117] = v1[2111];
  v1[2118] = v1[2112];
  trap_GetUsercmd(a1, *((_DWORD *)v3 + 87) + 8428);
  *(_DWORD *)(*((_DWORD *)v3 + 87) + 8684) = level[122];
  result = g_synchronousClients;
  if ( !g_synchronousClients[3] )
    result = (_DWORD *)ClientThink_real(v3, *((_DWORD *)v3 + 87) + 8428);
  return result;
}
// 13940: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 14CB0: using guessed type _DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD);

//----- (00039CA2) --------------------------------------------------------
int __cdecl G_RunClient(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]

  if ( g_synchronousClients[3] )
  {
    *(_DWORD *)(a1[87] + 8428) = level[122];
    ClientThink_real(a1, a1[87] + 8428);
  }
  result = a1[87];
  if ( !*(_DWORD *)(result + 8672) )
  {
    if ( a1[187] )
    {
      if ( *(_DWORD *)(a1[87] + 8396) == 1 )
        v2 = 7;
      else
        v2 = 1;
      *(_DWORD *)(a1[87] + 4) = v2;
      G_SetFixedLink(a1, 2);
      G_SetOrigin(a1, a1 + 78);
      G_SetAngle(a1, a1 + 81);
      a1[3] = 1;
      a1[12] = 1;
      trap_LinkEntity(a1);
      *(_DWORD *)(a1[87] + 20) = a1[78];
      *(_DWORD *)(a1[87] + 24) = a1[79];
      result = a1[80];
      *(_DWORD *)(a1[87] + 28) = result;
    }
    else if ( *(_DWORD *)(a1[87] + 4) == 1 || (result = a1[87], *(_DWORD *)(result + 4) == 7) )
    {
      result = a1[87];
      --*(_DWORD *)(result + 4);
    }
  }
  return result;
}
// 13050: using guessed type _DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13940: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00039E28) --------------------------------------------------------
int __cdecl IntermissionClientEndFrame(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 348);
  *(_DWORD *)(a1 + 244) &= 0xFFFFFFFD;
  *(_DWORD *)(a1 + 244) |= 1u;
  *(_BYTE *)(a1 + 373) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  v2[3] &= 0xFFF1FFFF;
  v2[1] = 5;
  v2[32] &= 0xFFFBFFFF;
  v2[32] &= 0xFFFFFBFF;
  v2[47] = 0;
  result = a1;
  *(_DWORD *)(a1 + 4) = 7;
  return result;
}

//----- (00039EDD) --------------------------------------------------------
_DWORD *__cdecl SpectatorClientEndFrame(int a1)
{
  _DWORD *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // [esp+10h] [ebp-2168h]
  int *v4; // [esp+14h] [ebp-2164h]
  int *v5; // [esp+18h] [ebp-2160h]
  _DWORD *v6; // [esp+1Ch] [ebp-215Ch]
  char v7[4]; // [esp+20h] [ebp-2158h] BYREF
  int v8; // [esp+24h] [ebp-2154h]
  int v9; // [esp+80h] [ebp-20F8h] BYREF
  _DWORD v10[2101]; // [esp+84h] [ebp-20F4h] BYREF
  int v11; // [esp+2158h] [ebp-20h]
  unsigned int v12; // [esp+215Ch] [ebp-1Ch]

  v6 = *(_DWORD **)(a1 + 348);
  *(_DWORD *)(a1 + 244) &= 0xFFFFFFFD;
  *(_DWORD *)(a1 + 244) |= 1u;
  *(_BYTE *)(a1 + 373) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  v6[3] &= 0xFFFDFFFF;
  *(_DWORD *)(a1 + 4) = 7;
  v6[47] = 0;
  v6[2181] = 0;
  v6[2182] = 0;
  if ( (int)v6[2100] < 0 )
  {
LABEL_10:
    if ( (int)v6[2167] < 0 && !G_ClientCanSpectateTeam(v6, 4) )
      Cmd_FollowCycle_f(a1, 1);
    v11 = v6[2167];
    if ( v11 < 0 || !trap_GetArchivedClientInfo(v11, v6 + 2102, &v9, v7) || !G_ClientCanSpectateTeam(v6, v8) )
    {
      StopFollowing(a1);
      v6[3] &= 0xFFF7FFFF;
      if ( G_ClientCanSpectateTeam(v6, 2) || G_ClientCanSpectateTeam(v6, 1) || G_ClientCanSpectateTeam(v6, 0) )
      {
        result = v6;
        v6[3] |= 0x40000u;
      }
      else
      {
        result = v6;
        v6[3] &= 0xFFFBFFFF;
      }
      return result;
    }
  }
  else
  {
    v11 = v6[2100];
    v6[2167] = v11;
    while ( 1 )
    {
      if ( (int)v6[2102] < 0 )
        v6[2102] = 0;
      if ( trap_GetArchivedClientInfo(v6[2100], v6 + 2102, &v9, v7) && G_ClientCanSpectateTeam(v6, v8) )
        break;
      if ( !v6[2102] )
      {
        v6[2100] = -1;
        v6[2167] = -1;
        goto LABEL_10;
      }
      v6[2102] -= 50;
    }
  }
  v12 = v10[31] & 0xFFFDFFFF | v6[32] & 0x20000;
  v5 = v6;
  v4 = &v9;
  v3 = 8396;
  if ( ((unsigned __int8)v6 & 4) != 0 )
  {
    *v6 = v9;
    v5 = v6 + 1;
    v4 = v10;
    v3 = 8392;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  HudElem_UpdateClient(v6, *(_DWORD *)a1, 2);
  v6[32] = v12;
  v6[3] &= 0xFFFDFFFF;
  v6[3] |= 0x10000u;
  if ( (int)v6[2100] < 0 )
  {
    v6[3] |= 0x40000u;
    if ( G_ClientCanSpectateTeam(v6, 4) )
    {
      result = v6;
      v2 = v6[3] | 0x80000;
    }
    else
    {
      result = v6;
      v2 = v6[3] & 0xFFF7FFFF;
    }
    v6[3] = v2;
  }
  else
  {
    result = v6;
    v6[3] &= 0xFFF3FFFF;
  }
  return result;
}
// 135D0: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 13BC0: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 13C80: using guessed type _DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E70: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);
// 15200: using guessed type _DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD);

//----- (0003A36D) --------------------------------------------------------
int __cdecl G_ClientCanSpectateTeam(int a1, char a2)
{
  return ((unsigned __int8)(*(int *)(a1 + 8564) >> a2) ^ 1) & 1;
}

//----- (0003A387) --------------------------------------------------------
int __cdecl GetFollowPlayerState(int a1, _DWORD *a2)
{
  unsigned int v3; // [esp+14h] [ebp-24h]
  const void *v4; // [esp+18h] [ebp-20h]
  void *v5; // [esp+1Ch] [ebp-1Ch]
  _DWORD *v7; // [esp+24h] [ebp-14h]

  v7 = (_DWORD *)g_entities[199 * a1 + 87];
  if ( (v7[3] & 0x20000) == 0 )
    return 0;
  v5 = a2;
  v4 = (const void *)g_entities[199 * a1 + 87];
  v3 = 8396;
  if ( ((unsigned __int8)a2 & 4) != 0 )
  {
    *a2 = *v7;
    v5 = a2 + 1;
    v4 = v7 + 1;
    v3 = 8392;
  }
  qmemcpy(v5, v4, 4 * (v3 >> 2));
  memset(a2 + 362, 0, 0xD90u);
  return 1;
}

//----- (0003A449) --------------------------------------------------------
int __cdecl StuckInClient(int a1)
{
  long double v1; // fst6
  long double v2; // fst6
  float v4; // [esp+14h] [ebp-44h]
  float v5; // [esp+18h] [ebp-40h]
  float v7; // [esp+20h] [ebp-38h]
  float v8; // [esp+20h] [ebp-38h]
  float v9; // [esp+28h] [ebp-30h] BYREF
  float v10; // [esp+2Ch] [ebp-2Ch]
  float v11; // [esp+30h] [ebp-28h] BYREF
  float v12; // [esp+34h] [ebp-24h]
  _DWORD *v13; // [esp+3Ch] [ebp-1Ch]
  float v14; // [esp+40h] [ebp-18h]
  float v15; // [esp+44h] [ebp-14h]
  float v16; // [esp+48h] [ebp-10h]
  int v17; // [esp+4Ch] [ebp-Ch]

  if ( (*(_DWORD *)(*(_DWORD *)(a1 + 348) + 12) & 0x20000) == 0 )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) )
    return 0;
  if ( *(_DWORD *)(a1 + 284) != 0x2000000 && *(_DWORD *)(a1 + 284) != 0x4000000 )
    return 0;
  v13 = g_entities;
  v17 = 0;
  while ( 1 )
  {
    if ( v17 >= level[120] )
      return 0;
    if ( !*((_BYTE *)v13 + 356)
      || (*(_DWORD *)(v13[87] + 12) & 0x20000) == 0
      || *(_DWORD *)(v13[87] + 8396)
      || v13 == (_DWORD *)a1
      || !v13[87]
      || (int)v13[142] <= 0
      || v13[71] != 0x2000000 && v13[71] != 0x4000000
      || *((float *)v13 + 72) > (long double)*(float *)(a1 + 300)
      || *(float *)(a1 + 288) > (long double)*((float *)v13 + 75)
      || *((float *)v13 + 73) > (long double)*(float *)(a1 + 304)
      || *(float *)(a1 + 292) > (long double)*((float *)v13 + 76)
      || *((float *)v13 + 74) > (long double)*(float *)(a1 + 308)
      || *(float *)(a1 + 296) > (long double)*((float *)v13 + 77) )
    {
      goto LABEL_44;
    }
    if ( (*(_DWORD *)(a1 + 244) & 0x200) == 0 )
      break;
    if ( (v13[61] & 0x200) != 0 )
    {
      v11 = *((float *)v13 + 78) - *(float *)(a1 + 312);
      v12 = *((float *)v13 + 79) - *(float *)(a1 + 316);
      v16 = *(float *)(a1 + 272) + *((float *)v13 + 68);
      if ( v11 * v11 + v12 * v12 <= v16 * v16 )
        goto LABEL_34;
    }
    else
    {
      v11 = *((float *)v13 + 78) - *(float *)(a1 + 312);
      v12 = *((float *)v13 + 79) - *(float *)(a1 + 316);
      v9 = v11;
      v10 = v12;
      VectorNormalize2D(&v9);
      v11 = *(float *)(a1 + 272) * -1.0 * v9 + v11;
      v12 = *(float *)(a1 + 272) * -1.0 * v10 + v12;
      if ( fabs(v11) <= *((float *)v13 + 68) || fabs(v12) <= *((float *)v13 + 69) )
        goto LABEL_34;
    }
LABEL_44:
    ++v17;
    v13 += 199;
  }
  if ( (v13[61] & 0x200) != 0 )
  {
    v11 = *(float *)(a1 + 312) - *((float *)v13 + 78);
    v12 = *(float *)(a1 + 316) - *((float *)v13 + 79);
    v9 = v11;
    v10 = v12;
    VectorNormalize2D(&v9);
    v11 = *((float *)v13 + 68) * -1.0 * v9 + v11;
    v12 = *((float *)v13 + 68) * -1.0 * v10 + v12;
    if ( fabs(v11) > *(float *)(a1 + 272) && fabs(v12) > *(float *)(a1 + 276) )
      goto LABEL_44;
  }
LABEL_34:
  v11 = *((float *)v13 + 78) - *(float *)(a1 + 312);
  v12 = *((float *)v13 + 79) - *(float *)(a1 + 316);
  v1 = (long double)rand() / 2147483600.0;
  v11 = v1 + v1 - 1.0 + v11;
  v2 = (long double)rand() / 2147483600.0;
  v12 = v2 + v2 - 1.0 + v12;
  VectorNormalize2D(&v11);
  v7 = sqrt(*(float *)(v13[87] + 32) * *(float *)(v13[87] + 32) + *(float *)(v13[87] + 36) * *(float *)(v13[87] + 36));
  if ( v7 <= 0.0 )
    v5 = 0.0;
  else
    v5 = (float)*(int *)(v13[87] + 68);
  v14 = v5;
  v8 = sqrt(
         *(float *)(*(_DWORD *)(a1 + 348) + 32) * *(float *)(*(_DWORD *)(a1 + 348) + 32)
       + *(float *)(*(_DWORD *)(a1 + 348) + 36) * *(float *)(*(_DWORD *)(a1 + 348) + 36));
  if ( v8 <= 0.0 )
    v4 = 0.0;
  else
    v4 = (float)*(int *)(*(_DWORD *)(a1 + 348) + 68);
  v15 = v4;
  if ( v14 < 0.000099999997 && v15 < 0.000099999997 )
  {
    v14 = (float)*(int *)(v13[87] + 68);
    v15 = (float)*(int *)(*(_DWORD *)(a1 + 348) + 68);
  }
  *(float *)(v13[87] + 32) = v11 * v14;
  *(float *)(v13[87] + 36) = v12 * v14;
  *(_DWORD *)(v13[87] + 16) = 300;
  *(_DWORD *)(v13[87] + 12) |= 0x100u;
  *(float *)(*(_DWORD *)(a1 + 348) + 32) = -v15 * v11;
  *(float *)(*(_DWORD *)(a1 + 348) + 36) = -v15 * v12;
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 16) = 300;
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 12) |= 0x100u;
  return 1;
}
// 13E10: using guessed type _DWORD __cdecl VectorNormalize2D(_DWORD);

//----- (0003AACF) --------------------------------------------------------
int __cdecl sub_3AACF(int a1, int a2)
{
  return BG_Player_DoControllers(a1, a1, a2, (char *)&unk_9B6EC + 1200 * *(_DWORD *)(a1 + 144) + (_DWORD)bgs);
}
// 15250: using guessed type _DWORD __cdecl BG_Player_DoControllers(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003AB2A) --------------------------------------------------------
float *__cdecl ClientEndFrame(_DWORD *a1)
{
  float *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // edx
  int v4; // [esp+10h] [ebp-78h]
  int v5[4]; // [esp+20h] [ebp-68h] BYREF
  int v6[5]; // [esp+30h] [ebp-58h] BYREF
  float *v7; // [esp+44h] [ebp-44h]
  int v8; // [esp+48h] [ebp-40h]
  int i; // [esp+4Ch] [ebp-3Ch]
  char *src; // [esp+50h] [ebp-38h]
  char *s2; // [esp+54h] [ebp-34h]
  int v12; // [esp+58h] [ebp-30h]
  int v13; // [esp+5Ch] [ebp-2Ch]
  int v14[2]; // [esp+60h] [ebp-28h] BYREF
  float v15; // [esp+68h] [ebp-20h]

  v7 = (float *)a1[87];
  a1[138] = 0;
  v7[2098] = 0.0;
  result = v7;
  if ( *((_DWORD *)v7 + 2106) == 2 )
  {
    if ( *((_DWORD *)v7 + 2099) == 3 )
    {
      result = (float *)IntermissionClientEndFrame(a1);
    }
    else if ( *((_DWORD *)v7 + 2099) == 2 )
    {
      result = (float *)SpectatorClientEndFrame(a1);
    }
    else if ( *((_DWORD *)v7 + 43) == *a1 )
    {
      a1[61] |= 2u;
      a1[61] &= 0xFFFFFFFE;
      *((_BYTE *)a1 + 373) = 1;
      *((_DWORD *)v7 + 3) |= 0x20000u;
      *((_DWORD *)v7 + 3) &= 0xFFF3FFFF;
      v7[47] = v7[2140];
      G_SetClientContents(a1);
      v7[2197] = 0.0;
      if ( *((_DWORD *)v7 + 2204) <= level[122] )
        *((_DWORD *)v7 + 32) &= 0xFFF7FFFF;
      if ( *((_DWORD *)v7 + 2168) )
      {
        *((_DWORD *)v7 + 1) = 2;
      }
      else if ( *((_DWORD *)v7 + 2169) )
      {
        *((_DWORD *)v7 + 1) = 3;
      }
      else if ( *((_DWORD *)v7 + 2099) == 1 )
      {
        if ( a1[187] )
          v4 = 7;
        else
          v4 = 6;
        *((_DWORD *)v7 + 1) = v4;
        a1[61] |= 1u;
        a1[61] &= 0xFFFFFFFD;
        *((_BYTE *)a1 + 373) = 0;
      }
      else
      {
        *((_DWORD *)v7 + 1) = a1[187] != 0;
      }
      *((_DWORD *)v7 + 15) = (int)g_gravity[2];
      v7[17] = v7[2132];
      v7[2194] = v7[246] / 255.0;
      G_CheckForPreventFriendlyFire(a1);
      G_CheckForCursorHints(a1);
      P_DamageFeedback(a1);
      if ( level[122] - *((_DWORD *)v7 + 2171) <= 1000 )
        v2 = a1[2] & 0xFFFFEFFF;
      else
        v2 = a1[2] | 0x1000;
      a1[2] = v2;
      v7[61] = *((float *)a1 + 142);
      G_SetClientSound(a1);
      if ( g_smoothClients[3] )
        BG_PlayerStateToEntityStateExtrapolate(v7, a1, *(_DWORD *)v7, 1);
      else
        BG_PlayerStateToEntityState(v7, a1, 1);
      if ( (int)a1[142] > 0 && StuckInClient(a1) )
        a1[71] = 0x4000000;
      v14[0] = (int)v7[5];
      v14[1] = (int)v7[6];
      v15 = v7[7];
      v15 = v15 + v7[52];
      G_AddLean(a1, v14);
      *((_DWORD *)v7 + 240) = G_GetNonPVSFriendlyInfo(a1, v14, *((_DWORD *)v7 + 2203));
      if ( *((_DWORD *)v7 + 240) )
      {
        *((_DWORD *)v7 + 2203) = (_DWORD)v7[240] & 0x3F;
        if ( (g_entities[199 * *((_DWORD *)v7 + 2203) + 2] & 0x80000) != 0 )
          v3 = *((_DWORD *)v7 + 32) | 0x100000;
        else
          v3 = (_DWORD)v7[32] & 0xFFEFFFFF;
        *((_DWORD *)v7 + 32) = v3;
      }
      else
      {
        *((_DWORD *)v7 + 2203) = 1023;
      }
      result = (float *)a1;
      if ( a1[1] == 1 )
      {
        a1[138] = sub_3AACF;
        v12 = a1[36];
        v13 = (int)&unk_9B6EC + 1200 * v12 + (_DWORD)bgs;
        *(_DWORD *)(v13 + 992) = a1[27];
        *(_DWORD *)(v13 + 996) = a1[53];
        *(float *)(v13 + 1000) = v7[48];
        *(float *)(v13 + 1004) = v7[49];
        *(float *)(v13 + 1008) = v7[50];
        v8 = 0;
        s2 = (char *)G_ModelName(*((unsigned __int8 *)a1 + 377));
        *((_DWORD *)v7 + 2146) = *((unsigned __int8 *)a1 + 377);
        if ( strcmp((const char *)(v13 + 64), s2) )
        {
          v8 = 1;
          Q_strncpyz((char *)(v13 + 64), s2, 64);
        }
        for ( i = 0; i <= 5; ++i )
        {
          if ( *((_BYTE *)a1 + i + 756) )
          {
            s2 = (char *)G_ModelName(*((unsigned __int8 *)a1 + i + 756));
            LODWORD(v7[i + 2147]) = *((unsigned __int8 *)a1 + i + 756);
            if ( strcmp((const char *)(v13 + (i << 6) + 128), s2) )
            {
              v8 = 1;
              Q_strncpyz((char *)(v13 + (i << 6) + 128), s2, 64);
            }
            src = (char *)SL_ConvertToString(*((unsigned __int16 *)a1 + i + 381));
            LODWORD(v7[i + 2153]) = G_TagIndex(src);
            if ( strcmp((const char *)(v13 + (i << 6) + 512), src) )
            {
              v8 = 1;
              Q_strncpyz((char *)(v13 + (i << 6) + 512), src, 64);
            }
          }
          else
          {
            *(_BYTE *)(v13 + (i << 6) + 128) = 0;
            *(_BYTE *)(v13 + (i << 6) + 512) = 0;
            v7[i + 2147] = 0.0;
            v7[i + 2153] = 0.0;
          }
        }
        if ( v8 )
          G_SafeDObjFree(a1);
        BG_UpdatePlayerDObj(a1, a1, v13);
        BG_PlayerAnimation(a1, a1, v13);
        if ( ((_DWORD)v7[3] & 0x20000) != 0 && ((_WORD)v7[32] & 0xC000) != 0 )
          turret_think_client(level[1] + 796 * *((_DWORD *)v7 + 222));
        result = (float *)g_debugLocDamage;
        if ( g_debugLocDamage[3] )
        {
          result = (float *)trap_DObjExists(a1);
          if ( result )
          {
            G_DObjCalcPose(a1);
            result = (float *)trap_XModelDebugBoxes(a1);
          }
        }
      }
    }
    else
    {
      v6[0] = (int)v7[5];
      v6[1] = (int)v7[6];
      v6[2] = (int)v7[7];
      v5[0] = 0;
      v5[1] = (int)v7[49];
      v5[2] = 0;
      result = (float *)ClientSpawn(a1, v6, v5);
    }
  }
  return result;
}
// 12EF0: using guessed type _DWORD __cdecl turret_think_client(_DWORD);
// 134F0: using guessed type _DWORD __cdecl G_DObjCalcPose(_DWORD);
// 137F0: using guessed type _DWORD __cdecl G_CheckForCursorHints(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 13A30: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 13B10: using guessed type _DWORD __cdecl IntermissionClientEndFrame(_DWORD);
// 13D50: using guessed type _DWORD __cdecl G_SafeDObjFree(_DWORD);
// 14070: using guessed type _DWORD __cdecl trap_XModelDebugBoxes(_DWORD);
// 14210: using guessed type _DWORD __cdecl G_CheckForPreventFriendlyFire(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14630: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 14710: using guessed type _DWORD __cdecl G_SetClientContents(_DWORD);
// 14860: using guessed type _DWORD __cdecl StuckInClient(_DWORD);
// 149A0: using guessed type _DWORD __cdecl BG_UpdatePlayerDObj(_DWORD, _DWORD, _DWORD);
// 14A80: using guessed type _DWORD __cdecl SpectatorClientEndFrame(_DWORD);
// 14CE0: using guessed type _DWORD __cdecl G_SetClientSound(_DWORD);
// 14E90: using guessed type _DWORD __cdecl BG_PlayerAnimation(_DWORD, _DWORD, _DWORD);
// 150C0: using guessed type _DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD);
// 157F0: using guessed type _DWORD __cdecl G_GetNonPVSFriendlyInfo(_DWORD, _DWORD, _DWORD);
// 158F0: using guessed type _DWORD __cdecl BG_PlayerStateToEntityStateExtrapolate(_DWORD, _DWORD, _DWORD, _DWORD);
// 15920: using guessed type _DWORD __cdecl P_DamageFeedback(_DWORD);

//----- (0003B2E4) --------------------------------------------------------
int __cdecl G_PlayerEvent(int a1, int a2)
{
  int result; // eax
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  result = a2;
  if ( a2 >= 159 && (a2 <= 161 || a2 == 168) )
    result = BG_WeaponFireRecoil(g_entities[199 * a1 + 87], g_entities[199 * a1 + 87] + 8896, v3);
  return result;
}
// 13C40: using guessed type _DWORD __cdecl BG_WeaponFireRecoil(_DWORD, _DWORD, _DWORD);

//----- (0003B358) --------------------------------------------------------
void sub_3B358()
{
  ;
}

//----- (0003B35C) --------------------------------------------------------
int __cdecl sub_3B35C(int a1, int a2, _DWORD *a3)
{
  int v3; // eax

  v3 = va("player field %s is read-only\n", *a3);
  return Scr_Error(v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0003B393) --------------------------------------------------------
int __cdecl sub_3B393(int a1)
{
  char v1; // al
  int v2; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[4] )
  {
    *(_DWORD *)(a1 + 8580) = 1;
  }
  else if ( v4 == scr_const[2] )
  {
    *(_DWORD *)(a1 + 8580) = 2;
  }
  else if ( v4 == scr_const[62] )
  {
    *(_DWORD *)(a1 + 8580) = 3;
  }
  else if ( v4 == scr_const[124] )
  {
    *(_DWORD *)(a1 + 8580) = 0;
  }
  else
  {
    v1 = SL_ConvertToString(v4);
    v2 = va("'%s' is an illegal sessionteam string. Must be allies, axis, none, or spectator.", v1);
    Scr_Error(v2);
  }
  ClientUserinfoChanged(-559290757 * ((a1 - level[0]) >> 2));
  return CalculateRanks();
}
// 12FA0: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13340: using guessed type int CalculateRanks(void);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0003B486) --------------------------------------------------------
int __cdecl sub_3B486(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8580);
  switch ( result )
  {
    case 1:
      return Scr_AddConstString(scr_const[4]);
    case 0:
      return Scr_AddConstString(scr_const[124]);
    case 2:
      return Scr_AddConstString(scr_const[2]);
    case 3:
      result = Scr_AddConstString(scr_const[62]);
      break;
  }
  return result;
}
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (0003B515) --------------------------------------------------------
int __cdecl sub_3B515(int a1)
{
  char v1; // al
  int v2; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[129] )
  {
    *(_WORD *)(a1 + 8572) = 1;
  }
  else if ( v4 == scr_const[130] )
  {
    *(_WORD *)(a1 + 8572) = 2;
  }
  else if ( v4 == scr_const[124] )
  {
    *(_WORD *)(a1 + 8572) = 0;
  }
  else
  {
    v1 = SL_ConvertToString(v4);
    v2 = va("'%s' is an illegal sessionsquad string. Must be squad_alpha, squad_bravo, or none.", v1);
    Scr_Error(v2);
  }
  return ClientUserinfoChanged(-559290757 * ((a1 - level[0]) >> 2));
}
// 12FA0: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0003B5E4) --------------------------------------------------------
int __cdecl sub_3B5E4(int a1)
{
  int result; // eax

  result = *(unsigned __int16 *)(a1 + 8572);
  if ( result == 1 )
    return Scr_AddConstString(scr_const[129]);
  if ( *(unsigned __int16 *)(a1 + 8572) <= 1u )
    return Scr_AddConstString(scr_const[124]);
  if ( result == 2 )
    result = Scr_AddConstString(scr_const[130]);
  return result;
}
// 3B613: conditional instruction was optimized away because of '%var_8.4==0'
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (0003B668) --------------------------------------------------------
int __cdecl sub_3B668(int a1)
{
  int result; // eax
  char v2; // al
  int v3; // eax
  unsigned __int16 v4; // [esp+12h] [ebp-6h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[104] )
  {
    result = a1;
    *(_DWORD *)(a1 + 8396) = 0;
  }
  else if ( v4 == scr_const[125] )
  {
    result = a1;
    *(_DWORD *)(a1 + 8396) = 1;
  }
  else if ( v4 == scr_const[62] )
  {
    result = a1;
    *(_DWORD *)(a1 + 8396) = 2;
  }
  else if ( v4 == scr_const[91] )
  {
    result = a1;
    *(_DWORD *)(a1 + 8396) = 3;
  }
  else
  {
    v2 = SL_ConvertToString(v4);
    v3 = va("'%s' is an illegal sessionstate string. Must be playing, dead, spectator, or intermission.", v2);
    result = Scr_Error(v3);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0003B73E) --------------------------------------------------------
int __cdecl sub_3B73E(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 8396);
  switch ( result )
  {
    case 1:
      return Scr_AddConstString(scr_const[125]);
    case 0:
      return Scr_AddConstString(scr_const[104]);
    case 2:
      return Scr_AddConstString(scr_const[62]);
    case 3:
      result = Scr_AddConstString(scr_const[91]);
      break;
  }
  return result;
}
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (0003B7D3) --------------------------------------------------------
int __cdecl sub_3B7D3(_DWORD *a1)
{
  int result; // eax

  a1[2131] = Scr_GetInt(0);
  if ( (int)a1[2131] <= 0 )
    a1[2131] = 1;
  if ( a1[61] > a1[2131] )
    a1[61] = a1[2131];
  g_entities[370289053 * (((int)a1 - level[0]) >> 2) + 142] = a1[61];
  result = a1[2131];
  a1[63] = result;
  return result;
}
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0003B88E) --------------------------------------------------------
int __cdecl sub_3B88E(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 8528) = Scr_GetInt(0);
  if ( *(int *)(a1 + 8528) < 0 )
    *(_DWORD *)(a1 + 8528) = 0;
  result = a1;
  *(float *)&g_entities[370289053 * ((a1 - level[0]) >> 2) + 122] = (float)*(int *)(a1 + 8528);
  return result;
}
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0003B911) --------------------------------------------------------
int __cdecl sub_3B911(int a1)
{
  *(_DWORD *)(a1 + 8412) = Scr_GetInt(0);
  return CalculateRanks();
}
// 13340: using guessed type int CalculateRanks(void);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0003B949) --------------------------------------------------------
int __cdecl sub_3B949(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < -1 || v2 > 63 )
    Scr_Error("spectatorclient can only be set to -1, or a valid client number");
  result = v2;
  *(_DWORD *)(a1 + 8400) = v2;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0003B998) --------------------------------------------------------
int __cdecl sub_3B998(int a1)
{
  int result; // eax
  char v2; // [esp+Ch] [ebp-Ch]

  v2 = Scr_GetString(0);
  result = GScr_GetStatusIconIndex(v2);
  *(_DWORD *)(a1 + 8404) = result;
  return result;
}
// 14810: using guessed type _DWORD __cdecl GScr_GetStatusIconIndex(char);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0003B9D5) --------------------------------------------------------
int __cdecl sub_3B9D5(int a1)
{
  int result; // eax
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( !*(_DWORD *)(a1 + 8404) )
    return Scr_AddString(&unk_77D20);
  result = a1;
  if ( *(int *)(a1 + 8404) <= 8 )
  {
    trap_GetConfigstring(*(_DWORD *)(a1 + 8404) + 20, v2, 1024);
    result = Scr_AddString(v2);
  }
  return result;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0003BA4F) --------------------------------------------------------
int __cdecl sub_3BA4F(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+8h] [ebp-10h]
  char v3; // [esp+Ch] [ebp-Ch]

  v2 = &g_entities[370289053 * ((a1 - level[0]) >> 2)];
  v3 = Scr_GetString(0);
  result = GScr_GetHeadIconIndex(v3);
  v2[37] = result;
  return result;
}
// 12EC0: using guessed type _DWORD __cdecl GScr_GetHeadIconIndex(char);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0003BAB5) --------------------------------------------------------
_DWORD *__cdecl sub_3BAB5(int a1)
{
  _DWORD *result; // eax
  char v2[1036]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v3; // [esp+41Ch] [ebp-Ch]

  v3 = &g_entities[370289053 * ((a1 - level[0]) >> 2)];
  if ( !v3[37] )
    return (_DWORD *)Scr_AddString(&unk_77D20);
  result = v3;
  if ( (int)v3[37] <= 15 )
  {
    trap_GetConfigstring(v3[37] + 28, v2, 1024);
    result = (_DWORD *)Scr_AddString(v2);
  }
  return result;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0003BB58) --------------------------------------------------------
_DWORD *__cdecl sub_3BB58(int a1)
{
  _DWORD *result; // eax
  char v2; // al
  int v3; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v5; // [esp+12h] [ebp-6h]

  v4 = &g_entities[370289053 * ((a1 - level[0]) >> 2)];
  v5 = Scr_GetConstString(0);
  if ( v5 == scr_const[124] )
  {
    result = v4;
    v4[38] = 0;
  }
  else if ( v5 == scr_const[2] )
  {
    result = v4;
    v4[38] = 2;
  }
  else if ( v5 == scr_const[4] )
  {
    result = v4;
    v4[38] = 1;
  }
  else if ( v5 == scr_const[62] )
  {
    v2 = SL_ConvertToString(v5);
    v3 = va("'%s' is an illegal head icon team string. Must be none, allies, axis, or spectator.", v2);
    result = (_DWORD *)Scr_Error(v3);
  }
  else
  {
    result = v4;
    v4[38] = 3;
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0003BC51) --------------------------------------------------------
int __cdecl sub_3BC51(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]

  v2 = g_entities[370289053 * ((a1 - level[0]) >> 2) + 38];
  if ( v2 == 2 )
    return Scr_AddConstString(scr_const[2]);
  if ( v2 > 2 )
  {
    if ( v2 == 3 )
      return Scr_AddConstString(scr_const[62]);
  }
  else if ( v2 == 1 )
  {
    return Scr_AddConstString(scr_const[4]);
  }
  return Scr_AddConstString(scr_const[124]);
}
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (0003BD0B) --------------------------------------------------------
__int16 __cdecl sub_3BD0B(int a1)
{
  long double v1; // fst7
  __int16 result; // ax
  __int16 v3; // [esp+Eh] [ebp-Ah]

  v1 = Scr_GetFloat(0);
  result = v3 | 0xC00;
  *(_DWORD *)(a1 + 8408) = (int)(v1 * 1000.0);
  return result;
}
// 3BD3C: variable 'v3' is possibly undefined
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0003BD57) --------------------------------------------------------
int __cdecl sub_3BD57(int a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = (long double)*(int *)(a1 + 8408) * 0.001;
  return Scr_AddFloat(LODWORD(v2));
}
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0003BD88) --------------------------------------------------------
char **__cdecl GScr_AddFieldsForClient(unsigned __int16 a1)
{
  char **result; // eax
  unsigned int v2; // [esp+18h] [ebp-10h]
  char **i; // [esp+1Ch] [ebp-Ch]

  for ( i = &off_82B40; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    v2 = (unsigned int)i[2];
    if ( v2 <= 5 || v2 == 7 )
      Scr_AddClassField(
        a1,
        *i,
        (unsigned __int16)(-13107 * (((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_82B40 - 140134))) >> 2)) | 0xC000);
  }
  return result;
}
// 147A0: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// 82B40: using guessed type char *off_82B40;
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0003BE10) --------------------------------------------------------
int __cdecl Scr_SetClientField(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+10h] [ebp-8h]

  v3 = &(&off_82B40)[5 * a2];
  if ( v3[3] )
    result = ((int (__cdecl *)(int, int, char **))v3[3])(a1, a1, v3);
  else
    result = Scr_SetGenericField(a1, v3[2], v3[1]);
  return result;
}
// 14CF0: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// 82B40: using guessed type char *off_82B40;

//----- (0003BE8A) --------------------------------------------------------
int __cdecl Scr_GetClientField(int a1, int a2)
{
  int result; // eax
  char **v3; // [esp+10h] [ebp-8h]

  v3 = &(&off_82B40)[5 * a2];
  if ( v3[4] )
    result = ((int (__cdecl *)(int, int, char **))v3[4])(a1, a1, v3);
  else
    result = Scr_GetGenericField(a1, v3[2], v3[1]);
  return result;
}
// 14B40: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// 82B40: using guessed type char *off_82B40;

//----- (0003BF04) --------------------------------------------------------
void sub_3BF04()
{
  ;
}

//----- (0003BF08) --------------------------------------------------------
int __usercall SetClientViewAngle@<eax>(long double a1@<st0>, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  int result; // eax
  float v6; // [esp+0h] [ebp-48h]
  float v7; // [esp+0h] [ebp-48h]
  float v8; // [esp+1Ch] [ebp-2Ch]
  float v9; // [esp+1Ch] [ebp-2Ch]
  float v10; // [esp+1Ch] [ebp-2Ch]
  float v11; // [esp+1Ch] [ebp-2Ch]
  float v12; // [esp+1Ch] [ebp-2Ch]
  float v13; // [esp+1Ch] [ebp-2Ch]
  float v14; // [esp+20h] [ebp-28h]
  float v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int i; // [esp+3Ch] [ebp-Ch]

  v14 = *(float *)a3;
  v15 = *(float *)(a3 + 4);
  v16 = *(_DWORD *)(a3 + 8);
  if ( (*(_DWORD *)(*(_DWORD *)(a2 + 348) + 12) & 1) != 0 && (*(_WORD *)(*(_DWORD *)(a2 + 348) + 128) & 0xC000) == 0 )
  {
    AngleDelta(*(float *)(*(_DWORD *)(a2 + 348) + 872), v15);
    v8 = a1;
    AngleNormalize180(v8);
    v9 = a1;
    if ( v9 > 45.0 || (v3 = v9, v9 < -45.0) )
    {
      if ( v9 <= 45.0 )
        v10 = v9 + 45.0;
      else
        v10 = v9 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 348) + 76) += (unsigned __int16)(int)(v10 * 182.04445);
      if ( v10 <= 0.0 )
        v3 = *(float *)(*(_DWORD *)(a2 + 348) + 872) + 45.0;
      else
        v3 = *(float *)(*(_DWORD *)(a2 + 348) + 872) - 45.0;
      v6 = v3;
      AngleNormalize360(v6);
      v15 = v3;
    }
    AngleDelta(*(float *)(*(_DWORD *)(a2 + 348) + 880), v14);
    v11 = v3;
    AngleNormalize180(v11);
    v12 = v3;
    if ( v12 > 45.0 || v12 < -15.0 )
    {
      if ( v12 <= 45.0 )
        v13 = v12 + 15.0;
      else
        v13 = v12 - 45.0;
      *(_DWORD *)(*(_DWORD *)(a2 + 348) + 72) += (unsigned __int16)(int)(v13 * 182.04445);
      if ( v13 <= 0.0 )
        v4 = *(float *)(*(_DWORD *)(a2 + 348) + 880) + 15.0;
      else
        v4 = *(float *)(*(_DWORD *)(a2 + 348) + 880) - 45.0;
      v7 = v4;
      AngleNormalize180(v7);
      v14 = v4;
    }
  }
  for ( i = 0; i <= 2; ++i )
    *(_DWORD *)(*(_DWORD *)(a2 + 348) + 4 * i + 72) = (unsigned __int16)(int)(*(&v14 + i) * 182.04445)
                                                    - *(_DWORD *)(*(_DWORD *)(a2 + 348) + 4 * i + 8436);
  *(float *)(a2 + 324) = v14;
  *(float *)(a2 + 328) = v15;
  *(_DWORD *)(a2 + 332) = v16;
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 192) = *(_DWORD *)(a2 + 324);
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 196) = *(_DWORD *)(a2 + 328);
  result = *(_DWORD *)(a2 + 332);
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 200) = result;
  return result;
}

//----- (0003C29D) --------------------------------------------------------
int __cdecl sub_3C29D(char *a1, char *a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-18h]
  char *dest; // [esp+14h] [ebp-14h]
  char v6; // [esp+1Bh] [ebp-Dh]
  int v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]
  int v9; // [esp+38h] [ebp+10h]

  v9 = a3 - 1;
  v8 = 0;
  v7 = 0;
  dest = a2;
  *a2 = 0;
  v4 = 0;
  while ( 1 )
  {
    v6 = *a1++;
    if ( !v6 )
      break;
    if ( *dest || v6 != 32 )
    {
      if ( v6 == 94 )
      {
        if ( !*a1 )
          break;
        if ( (unsigned __int8)ColorIndex((unsigned __int8)*a1) )
        {
          if ( v8 > v9 - 2 )
            break;
          *a2 = 94;
          a2[1] = *a1++;
          a2 += 2;
          v8 += 2;
        }
        else
        {
          ++a1;
        }
      }
      else if ( v6 == 32 )
      {
        if ( ++v4 <= 3 )
          goto LABEL_15;
      }
      else
      {
        v4 = 0;
LABEL_15:
        if ( v8 > v9 - 1 )
          break;
        *a2++ = v6;
        ++v7;
        ++v8;
      }
    }
  }
  *a2 = 0;
  result = (int)dest;
  if ( !*dest || !v7 )
    result = Q_strncpyz(dest, "UnnamedPlayer", v9);
  return result;
}
// 13EB0: using guessed type _DWORD __cdecl ColorIndex(_DWORD);

//----- (0003C3E0) --------------------------------------------------------
int __cdecl ClientUserinfoChanged(int a1)
{
  int v1; // esi
  int v2; // esi
  const char *v3; // eax
  int result; // eax
  char *v5; // [esp+1Ch] [ebp-82Ch]
  char dest[1036]; // [esp+20h] [ebp-828h] BYREF
  int v7; // [esp+42Ch] [ebp-41Ch]
  char v8[1032]; // [esp+430h] [ebp-418h] BYREF
  char *nptr; // [esp+838h] [ebp-10h]
  _DWORD *v10; // [esp+83Ch] [ebp-Ch]

  v10 = &g_entities[199 * a1];
  v7 = v10[87];
  trap_GetUserinfo(a1, dest, 1024);
  if ( !Info_Validate(dest) )
    strcpy(dest, "\\name\\badinfo");
  v1 = v7;
  *(_DWORD *)(v1 + 8476) = trap_IsLocalClient(a1);
  nptr = (char *)Info_ValueForKey(dest, (int)"cg_predictItems");
  if ( atoi(nptr) )
    *(_DWORD *)(v7 + 8480) = 1;
  else
    *(_DWORD *)(v7 + 8480) = 0;
  if ( *(_DWORD *)(v7 + 8424) == 2 && level[132] )
  {
    nptr = (char *)Info_ValueForKey(dest, (int)"name");
    sub_3C29D(nptr, (char *)(v7 + 8488), 32);
  }
  else
  {
    Q_strncpyz(v8, (char *)(v7 + 8636), 1024);
    nptr = (char *)Info_ValueForKey(dest, (int)"name");
    sub_3C29D(nptr, (char *)(v7 + 8636), 32);
    Q_strncpyz((char *)(v7 + 8488), (char *)(v7 + 8636), 32);
  }
  v2 = v7;
  v3 = (const char *)Info_ValueForKey(dest, (int)"handicap");
  *(_DWORD *)(v2 + 8520) = atoi(v3);
  if ( *(int *)(v7 + 8520) <= 0 || *(int *)(v7 + 8520) > 100 )
    *(_DWORD *)(v7 + 8520) = 100;
  v5 = (char *)&unk_9B6EC + 1200 * a1 + (_DWORD)bgs;
  *((_DWORD *)v5 + 2) = a1;
  Q_strncpyz(v5 + 12, (char *)(v7 + 8636), 32);
  result = *(_DWORD *)(v7 + 8580);
  *((_DWORD *)v5 + 11) = result;
  return result;
}
// 14530: using guessed type _DWORD __cdecl trap_IsLocalClient(_DWORD);
// 152B0: using guessed type _DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD);

//----- (0003C680) --------------------------------------------------------
const char *__cdecl ClientConnect(int a1, __int16 a2)
{
  const char *v3; // [esp+10h] [ebp-428h]
  int v4; // [esp+14h] [ebp-424h]
  _DWORD *v5; // [esp+18h] [ebp-420h]
  _DWORD *v6; // [esp+1Ch] [ebp-41Ch]
  char v7[1028]; // [esp+20h] [ebp-418h] BYREF
  void *s; // [esp+424h] [ebp-14h]
  char *s2; // [esp+428h] [ebp-10h]
  __int16 v10; // [esp+42Eh] [ebp-Ah]

  v10 = a2;
  v6 = &g_entities[199 * a1];
  s = (void *)(level[0] + 8908 * a1);
  memset(s, 0, 0x22CCu);
  v5 = (_DWORD *)((char *)&unk_9B6EC + 1200 * a1 + (_DWORD)bgs);
  v4 = v5[298];
  memset(v5, 0, 0x4B0u);
  v5[298] = v4;
  *v5 = 1;
  v5[1] = 1;
  *((_DWORD *)s + 2106) = 1;
  *((_WORD *)s + 4210) = v10;
  *((_DWORD *)s + 2145) = 3;
  *((_DWORD *)s + 2099) = 2;
  *((_DWORD *)s + 2167) = -1;
  *((_DWORD *)s + 2100) = -1;
  *((_WORD *)s + 4286) = 0;
  G_InitGentity(v6);
  v6[133] = 0;
  v6[135] = 0;
  v6[87] = s;
  *((_DWORD *)s + 2144) = a1;
  *((_DWORD *)s + 43) = a1;
  *((_DWORD *)s + 32) = 16;
  v6[61] = 512;
  *((_DWORD *)s + 2138) = -1;
  *((_DWORD *)s + 2139) = -1;
  *((_DWORD *)s + 2132) = g_speed[3];
  ClientUserinfoChanged(a1);
  trap_GetUserinfo(a1, v7, 1024);
  if ( *((_DWORD *)s + 2119)
    || (s2 = (char *)Info_ValueForKey(v7, (int)"password"), !g_password[16])
    || !Q_stricmp(&g_password[16], "none")
    || !strcmp(&g_password[16], s2) )
  {
    Scr_PlayerConnect(v6);
    CalculateRanks();
    v3 = 0;
  }
  else
  {
    G_FreeEntity(v6);
    v3 = "GAME_INVALIDPASSWORD";
  }
  return v3;
}
// 12FA0: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 13340: using guessed type int CalculateRanks(void);
// 14470: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);
// 14CC0: using guessed type _DWORD __cdecl Scr_PlayerConnect(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 152B0: using guessed type _DWORD __cdecl trap_GetUserinfo(_DWORD, _DWORD, _DWORD);

//----- (0003C936) --------------------------------------------------------
int __cdecl ClientBegin(int a1)
{
  *(_DWORD *)(level[0] + 8908 * a1 + 8424) = 2;
  CalculateRanks();
  return Scr_Notify(&g_entities[199 * a1], scr_const[81], 0);
}
// 13340: using guessed type int CalculateRanks(void);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);

//----- (0003C9A8) --------------------------------------------------------
int __cdecl ClientSpawn(int a1, _DWORD *a2, int a3)
{
  unsigned int v4; // [esp+14h] [ebp-154h]
  int *v5; // [esp+18h] [ebp-150h]
  _DWORD *v6; // [esp+1Ch] [ebp-14Ch]
  unsigned int v7; // [esp+20h] [ebp-148h]
  int *v8; // [esp+24h] [ebp-144h]
  int *v9; // [esp+28h] [ebp-140h]
  int v10; // [esp+2Ch] [ebp-13Ch]
  int v11; // [esp+30h] [ebp-138h] BYREF
  _BYTE v12[272]; // [esp+34h] [ebp-134h] BYREF
  int v13; // [esp+144h] [ebp-24h]
  void *s; // [esp+148h] [ebp-20h]
  int v15; // [esp+14Ch] [ebp-1Ch]

  v15 = -280575753 * ((a1 - (int)g_entities) >> 2);
  s = *(void **)(a1 + 348);
  if ( (*((_DWORD *)s + 3) & 0x20000) != 0 && (*((_WORD *)s + 64) & 0xC000) != 0 )
    G_ClientStopUsingTurret(level[1] + 796 * *((_DWORD *)s + 222));
  G_EntUnlink(a1);
  if ( *(_DWORD *)(a1 + 240) )
    trap_UnlinkEntity(a1);
  *(_DWORD *)(a1 + 124) = 1023;
  Scr_SetString(a1 + 380, scr_const[49]);
  *(_DWORD *)(a1 + 408) = 42008593;
  *(_DWORD *)(a1 + 244) |= 1u;
  *(_BYTE *)(a1 + 373) = 0;
  G_SetClientContents(a1);
  *(_DWORD *)(a1 + 544) = player_die;
  *(_BYTE *)(a1 + 372) = 0;
  *(_BYTE *)(a1 + 371) = 0;
  *(_DWORD *)(a1 + 388) = 0x2000;
  *(_DWORD *)(a1 + 260) = playerMins[0];
  *(_DWORD *)(a1 + 264) = playerMins[1];
  *(_DWORD *)(a1 + 268) = playerMins[2];
  *(_DWORD *)(a1 + 272) = playerMaxs[0];
  *(_DWORD *)(a1 + 276) = playerMaxs[1];
  *(_DWORD *)(a1 + 280) = playerMaxs[2];
  v13 = *((_DWORD *)s + 32) & 0x20008;
  v9 = &v11;
  v8 = (int *)((char *)s + 8396);
  v7 = 272;
  if ( ((unsigned __int8)&v11 & 4) != 0 )
  {
    v11 = *v8;
    v9 = (int *)v12;
    v8 = (int *)((char *)s + 8400);
    v7 = 268;
  }
  qmemcpy(v9, v8, 4 * (v7 >> 2));
  v10 = *((_DWORD *)s + 66);
  memset(s, 0, 0x22CCu);
  v6 = (char *)s + 8396;
  v5 = &v11;
  v4 = 272;
  if ( (((_BYTE)s - 52) & 4) != 0 )
  {
    *v6++ = v11;
    v5 = (int *)v12;
    v4 = 268;
  }
  qmemcpy(v6, v5, 4 * (v4 >> 2));
  *((_DWORD *)s + 2167) = -1;
  *((_DWORD *)s + 66) = v10 + 1;
  *((_DWORD *)s + 63) = *((_DWORD *)s + 2131);
  *((_DWORD *)s + 32) = v13;
  *((_DWORD *)s + 32) |= 0x10u;
  *((_DWORD *)s + 2144) = v15;
  *((_DWORD *)s + 43) = v15;
  trap_GetUsercmd(-559290757 * (((int)s - level[0]) >> 2), (char *)s + 8428);
  *((_DWORD *)s + 32) ^= 8u;
  *((_DWORD *)s + 201) = *(_DWORD *)(a1 + 260);
  *((_DWORD *)s + 202) = *(_DWORD *)(a1 + 264);
  *((_DWORD *)s + 203) = *(_DWORD *)(a1 + 268);
  *((_DWORD *)s + 204) = *(_DWORD *)(a1 + 272);
  *((_DWORD *)s + 205) = *(_DWORD *)(a1 + 276);
  *((_DWORD *)s + 206) = *(_DWORD *)(a1 + 280);
  *((_DWORD *)s + 207) = bg_viewheight_prone[3];
  *((_DWORD *)s + 208) = bg_viewheight_crouched[3];
  *((_DWORD *)s + 209) = bg_viewheight_standing[3];
  *((_DWORD *)s + 210) = 8;
  *((_DWORD *)s + 51) = bg_viewheight_standing[3];
  *((float *)s + 52) = (float)(int)bg_viewheight_standing[3];
  *((_DWORD *)s + 53) = 0;
  *((_DWORD *)s + 56) = 0;
  *((_DWORD *)s + 211) = 1053609165;
  *((_DWORD *)s + 212) = 1065353216;
  *((_DWORD *)s + 213) = 1041865114;
  *((_DWORD *)s + 214) = 1059481190;
  *((_DWORD *)s + 215) = 1061997773;
  *((_DWORD *)s + 216) = 1060320051;
  *((_DWORD *)s + 217) = 1053609165;
  *((_DWORD *)s + 223) = 1065353216;
  G_SetOrigin(a1, a2);
  *((_DWORD *)s + 5) = *a2;
  *((_DWORD *)s + 6) = a2[1];
  *((_DWORD *)s + 7) = a2[2];
  *((_DWORD *)s + 3) |= 0x800u;
  SetClientViewAngle(a1, a3);
  *((_DWORD *)s + 2191) = level[122] + 1000 * g_inactivity[3];
  *((_DWORD *)s + 2174) = 0;
  *((_DWORD *)s + 2177) = 0;
  *((_DWORD *)s + 2107) = level[122];
  *(_DWORD *)s = level[122] - 100;
  ClientEndFrame(a1);
  ClientThink_real(a1, (char *)s + 8428);
  return BG_PlayerStateToEntityState(s, a1, 1);
}
// 13500: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);
// 13940: using guessed type _DWORD __cdecl ClientThink_real(_DWORD, _DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14710: using guessed type _DWORD __cdecl G_SetClientContents(_DWORD);
// 14B90: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 14CB0: using guessed type _DWORD __cdecl trap_GetUsercmd(_DWORD, _DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15760: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 15990: using guessed type _DWORD __cdecl ClientEndFrame(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);
// 46D56: using guessed type int __cdecl player_die(int, int, int, int, int, int, int, int);

//----- (0003CF5F) --------------------------------------------------------
int __cdecl ClientDisconnect(int a1)
{
  int v2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int j; // [esp+1Ch] [ebp-Ch]
  _DWORD *s; // [esp+20h] [ebp-8h]

  v2 = level[0] + 8908 * a1;
  s = &g_entities[199 * a1];
  Scr_AddString("disconnect");
  Scr_AddString("-1");
  Scr_Notify(s, scr_const[93], 2);
  for ( i = 0; i < level[120]; ++i )
  {
    if ( *(_DWORD *)(level[0] + 8908 * i + 8424)
      && *(_DWORD *)(level[0] + 8908 * i + 8396) == 2
      && *(_DWORD *)(level[0] + 8908 * i + 8668) == a1 )
    {
      StopFollowing(&g_entities[199 * i]);
    }
  }
  for ( j = 0; j < level[120]; ++j )
  {
    if ( *(_DWORD *)(level[0] + 8908 * j + 8424) && *(_DWORD *)(level[0] + 8908 * j + 8552) == a1 )
    {
      *(_DWORD *)(level[0] + 8908 * j + 8552) = -1;
      *(_DWORD *)(level[0] + 8908 * j + 8556) = 0;
      trap_SendServerCommand(j, 1, "m -2");
      break;
    }
  }
  HudElem_ClientDisconnect(s);
  Scr_PlayerDisconnect(s);
  G_FreeEntity(s);
  *(_DWORD *)(v2 + 8424) = 0;
  memset((void *)(v2 + 8576), 0, 0x5Cu);
  return CalculateRanks();
}
// 131C0: using guessed type _DWORD __cdecl Scr_PlayerDisconnect(_DWORD);
// 13340: using guessed type int CalculateRanks(void);
// 13BC0: using guessed type _DWORD __cdecl StopFollowing(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14F50: using guessed type _DWORD __cdecl HudElem_ClientDisconnect(_DWORD);

//----- (0003D193) --------------------------------------------------------
int G_SetPlayerSize()
{
  int result; // eax
  float v1; // [esp+0h] [ebp-8h]
  float v2; // [esp+0h] [ebp-8h]

  v1 = g_bounds_width[2] * -0.5;
  *(float *)&playerMins[1] = v1;
  *(float *)playerMins = v1;
  v2 = g_bounds_width[2] * 0.5;
  *(float *)&playerMaxs[1] = v2;
  *(float *)playerMaxs = v2;
  result = g_bounds_height_standing[2];
  playerMaxs[2] = result;
  return result;
}

//----- (0003D20D) --------------------------------------------------------
int __cdecl G_AddLean(int a1, int a2)
{
  return AddLeanToPosition(
           a2,
           *(_DWORD *)(*(_DWORD *)(a1 + 348) + 196),
           *(float *)(*(_DWORD *)(a1 + 348) + 64),
           16.0,
           20.0);
}

//----- (0003D263) --------------------------------------------------------
unsigned int __cdecl G_GetNonPVSFriendlyInfo(_DWORD *a1, float *a2, int a3)
{
  int v5; // [esp+30h] [ebp-38h]
  _DWORD *v6; // [esp+34h] [ebp-34h]
  float v7; // [esp+38h] [ebp-30h]
  float v8; // [esp+3Ch] [ebp-2Ch]
  float v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+44h] [ebp-24h]
  int v11; // [esp+48h] [ebp-20h]
  int v12; // [esp+4Ch] [ebp-1Ch]
  int i; // [esp+58h] [ebp-10h]
  int v14; // [esp+5Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1[87] + 8580);
  if ( !v5 || v5 == 3 )
    return 0;
  if ( a3 == 1023 )
    v14 = 0;
  else
    v14 = a3 + 1;
  for ( i = 0; ; ++i )
  {
    if ( i > 63 )
      return 0;
    v6 = &g_entities[199 * ((i + v14) % 64)];
    if ( *((_BYTE *)v6 + 356) )
    {
      if ( v6[87]
        && !*(_DWORD *)(v6[87] + 8396)
        && *(_DWORD *)(v6[87] + 8580) == v5
        && a1 != v6
        && !trap_InSnapshot(a2, *v6) )
      {
        break;
      }
    }
  }
  v9 = *((float *)v6 + 78) - *a2;
  v10 = *((float *)v6 + 79) - a2[1];
  v11 = (int)(v9 + 0.5);
  v12 = (int)(v10 + 0.5);
  v7 = 1.0;
  v8 = 1.0;
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v7 = -1022.0 / (long double)v11;
  }
  else
  {
    v7 = 1024.0 / (long double)v11;
  }
  if ( v12 <= 1024 )
  {
    if ( v12 < -1022 )
      v8 = -1022.0 / (long double)v12;
  }
  else
  {
    v8 = 1024.0 / (long double)v12;
  }
  if ( v7 < 1.0 || v8 < 1.0 )
  {
    if ( v8 <= (long double)v7 )
    {
      if ( v7 > (long double)v8 )
        v11 = (int)((long double)v11 * v8);
    }
    else
    {
      v12 = (int)((long double)v12 * v7);
    }
  }
  if ( v11 <= 1024 )
  {
    if ( v11 < -1022 )
      v11 = -1022;
  }
  else
  {
    v11 = 1024;
  }
  if ( v12 <= 1024 )
  {
    if ( v12 < -1022 )
      v12 = -1022;
  }
  else
  {
    v12 = 1024;
  }
  return ((*v6 & 0xFFFF803F | ((((unsigned __int16)((v11 + 2) / 4) + 255) & 0x1FF) << 6)) & 0xFF007FFF | ((((unsigned __int16)((v12 + 2) / 4) + 255) & 0x1FF) << 15)) & 0xFFFFFF | ((unsigned __int8)(int)(*((float *)v6 + 82) * 0.71111113) << 24);
}
// 14BF0: using guessed type _DWORD __cdecl trap_InSnapshot(_DWORD, _DWORD);

//----- (0003D5CC) --------------------------------------------------------
void sub_3D5CC()
{
  ;
}

//----- (0003D5D0) --------------------------------------------------------
int __cdecl PlayerCmd_giveWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+20h] [ebp-18h]
  int v6; // [esp+28h] [ebp-10h]
  char v7; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  v5 = Com_BitCheck(v4[87] + 780, v6);
  if ( !BG_GetEmptySlotForWeapon(v4[87], v6) )
    Scr_ParamError(0, "Can not give player weapon without having an empty weapon slot\n");
  BG_GivePlayerWeapon(v4[87], v6);
  v8 = BG_GetInfoForWeapon(v6);
  result = *(_DWORD *)(v8 + 408) - *(_DWORD *)(v4[87] + 4 * *(_DWORD *)(v8 + 416) + 268);
  if ( result > 0 )
    result = Add_Ammo(v4, v6, result, v5 == 0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 140B0: using guessed type _DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 144D0: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003D749) --------------------------------------------------------
int __cdecl PlayerCmd_takeWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int v4; // esi
  _DWORD *v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v8 = Scr_GetString(0);
  v7 = (unsigned __int8)BG_GetWeaponIndexForName(v8);
  v3 = v6[87];
  *(_DWORD *)(v3 + 4 * BG_AmmoForWeapon(v7) + 268) = 0;
  v4 = v6[87];
  *(_DWORD *)(v4 + 4 * BG_ClipForWeapon(v7) + 524) = 0;
  return BG_TakePlayerWeapon(v6[87], v7);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003D847) --------------------------------------------------------
int __cdecl PlayerCmd_takeAllWeapons(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // esi
  int v5; // esi
  _DWORD *v6; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  *(_DWORD *)(v6[87] + 176) = 0;
  for ( i = 1; ; ++i )
  {
    result = BG_GetNumWeapons();
    if ( i > result )
      break;
    v4 = v6[87];
    *(_DWORD *)(v4 + 4 * BG_AmmoForWeapon(i) + 268) = 0;
    v5 = v6[87];
    *(_DWORD *)(v5 + 4 * BG_ClipForWeapon(i) + 524) = 0;
    BG_TakePlayerWeapon(v6[87], i);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0003D952) --------------------------------------------------------
int __cdecl PlayerCmd_getCurrentWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(int *)(v4[87] + 176) <= 0 )
    return Scr_AddString("none");
  v5 = BG_GetInfoForWeapon(*(_DWORD *)(v4[87] + 176));
  return Scr_AddString(*(_DWORD *)(v5 + 4));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0003DA22) --------------------------------------------------------
int __cdecl PlayerCmd_hasWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  if ( Com_BitCheck(v4[87] + 780, v5) )
    result = Scr_AddBool(1);
  else
    result = Scr_AddBool(0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 150B0: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003DB03) --------------------------------------------------------
int __cdecl PlayerCmd_switchToWeapon(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  _DWORD *v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  char v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  if ( !Com_BitCheck(v5[87] + 780, v6) )
    return Scr_AddBool(0);
  v3 = va("a %i", v6);
  trap_SendServerCommand(-280575753 * (v5 - g_entities), 1, v3);
  return Scr_AddBool(1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 150B0: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003DC21) --------------------------------------------------------
int __cdecl PlayerCmd_giveStartAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[87] + 780, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    result = *(_DWORD *)(v7 + 408) - *(_DWORD *)(v4[87] + 4 * *(_DWORD *)(v7 + 416) + 268);
    if ( result > 0 )
      result = Add_Ammo(v4, v5, result, 0);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003DD44) --------------------------------------------------------
int __cdecl PlayerCmd_giveMaxAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  int v5; // [esp+18h] [ebp-10h]
  char v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[87] + 780, v5);
  if ( result )
  {
    v7 = BG_GetInfoForWeapon(v5);
    result = BG_GetAmmoTypeMax(*(_DWORD *)(v7 + 416)) - *(_DWORD *)(v4[87] + 4 * *(_DWORD *)(v7 + 416) + 268);
    if ( result > 0 )
      result = Add_Ammo(v4, v5, result, 0);
  }
  return result;
}
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003DE71) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionStartAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+18h] [ebp-10h]
  char v7; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetString(0);
  v6 = (unsigned __int8)BG_GetWeaponIndexForName(v7);
  if ( !Com_BitCheck(v4[87] + 780, v6) )
    return Scr_AddFloat(1065353216);
  v8 = BG_GetInfoForWeapon(v6);
  if ( *(int *)(v8 + 408) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(v4[87] + 4 * *(_DWORD *)(v8 + 416) + 268) <= 0 )
    return Scr_AddFloat(0);
  v5 = (long double)*(int *)(v4[87] + 4 * *(_DWORD *)(v8 + 416) + 268) / (long double)*(int *)(v8 + 408);
  return Scr_AddFloat(LODWORD(v5));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003DFCE) --------------------------------------------------------
int __cdecl PlayerCmd_getFractionMaxAmmo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  float v4; // [esp+Ch] [ebp-1Ch]
  _DWORD *v5; // [esp+10h] [ebp-18h]
  float v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  char v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v8 = Scr_GetString(0);
  v7 = (unsigned __int8)BG_GetWeaponIndexForName(v8);
  if ( !Com_BitCheck(v5[87] + 780, v7) )
    return Scr_AddFloat(1065353216);
  v9 = BG_GetInfoForWeapon(v7);
  if ( (int)BG_GetAmmoTypeMax(*(_DWORD *)(v9 + 416)) <= 0 )
    return Scr_AddFloat(1065353216);
  if ( *(int *)(v5[87] + 4 * *(_DWORD *)(v9 + 416) + 268) <= 0 )
    return Scr_AddFloat(0);
  v4 = (float)*(int *)(v5[87] + 4 * *(_DWORD *)(v9 + 416) + 268);
  v6 = v4 / (long double)(int)BG_GetAmmoTypeMax(*(_DWORD *)(v9 + 416));
  return Scr_AddFloat(LODWORD(v6));
}
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003E148) --------------------------------------------------------
int __cdecl sub_3E148(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  int v5[6]; // [esp+20h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v5);
  trap_UnlinkEntity(v4);
  *(_DWORD *)(v4[87] + 20) = v5[0];
  *(_DWORD *)(v4[87] + 24) = v5[1];
  *(_DWORD *)(v4[87] + 28) = v5[2];
  *(float *)(v4[87] + 28) = *(float *)(v4[87] + 28) + 1.0;
  *(_DWORD *)(v4[87] + 128) ^= 8u;
  BG_PlayerStateToEntityState(v4[87], v4, 1);
  v4[78] = *(_DWORD *)(v4[87] + 20);
  v4[79] = *(_DWORD *)(v4[87] + 24);
  v4[80] = *(_DWORD *)(v4[87] + 28);
  return trap_LinkEntity(v4);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (0003E2C4) --------------------------------------------------------
int __cdecl sub_3E2C4(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-1Ch]
  char v5[24]; // [esp+20h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v5);
  return SetClientViewAngle(v4, v5);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14B90: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);

//----- (0003E36F) --------------------------------------------------------
int __cdecl PlayerCmd_useButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[87] + 8688) & 0x40) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0003E425) --------------------------------------------------------
int __cdecl PlayerCmd_attackButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[87] + 8688) & 1) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0003E4DB) --------------------------------------------------------
int __cdecl PlayerCmd_meleeButtonPressed(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( (*(_DWORD *)(v4[87] + 8688) & 0x20) != 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0003E591) --------------------------------------------------------
int __cdecl PlayerCmd_isOnGround(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v4[87] + 84) == 1023 )
    result = Scr_AddInt(0);
  else
    result = Scr_AddInt(1);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0003E643) --------------------------------------------------------
int __cdecl PlayerCmd_pingPlayer(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  *(_DWORD *)(v4[87] + 128) |= 0x80000u;
  result = level[122] + 3000;
  *(_DWORD *)(v4[87] + 8816) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0003E70C) --------------------------------------------------------
int __cdecl sub_3E70C(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  char *s2; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  s2 = (char *)Scr_GetString(0);
  result = G_ModelIndex(s2);
  *(_DWORD *)(v4[87] + 8560) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0003E7C1) --------------------------------------------------------
int __cdecl sub_3E7C1(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5 = G_ModelName(*(_DWORD *)(v4[87] + 8560));
  return Scr_AddString(v5);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0003E86C) --------------------------------------------------------
int __cdecl sub_3E86C(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-10h]
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = (_DWORD *)Scr_GetEntity(0);
  result = (int)v5;
  if ( v5 != v6 )
  {
    if ( *(_DWORD *)(v6[87] + 8476) )
    {
      result = trap_SendServerCommand(-280575753 * (v5 - g_entities), 1, "m -4");
    }
    else
    {
      v4 = va("m %i", *v6);
      trap_SendServerCommand(-280575753 * (v5 - g_entities), 1, v4);
      *(_DWORD *)(v5[87] + 8552) = v6[36];
      result = level[122] + 20500;
      *(_DWORD *)(v5[87] + 8556) = result;
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0003E9CC) --------------------------------------------------------
int __cdecl sub_3E9CC(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  return Cmd_Score_f(v4);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13390: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);

//----- (0003EA5D) --------------------------------------------------------
int __cdecl sub_3EA5D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+Ch] [ebp-Ch]
  char v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v6 = Scr_GetString(0);
  v5 = (unsigned __int8)BG_GetWeaponIndexForName(v6);
  result = Com_BitCheck(v4[87] + 780, v5);
  if ( result )
  {
    *(_DWORD *)(v4[87] + 176) = v5;
    result = v4[87];
    *(_DWORD *)(result + 180) = 0;
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003EB49) --------------------------------------------------------
int __cdecl sub_3EB49(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  unsigned __int8 v3; // al
  int v4; // eax
  int result; // eax
  _DWORD *v6; // [esp+1Ch] [ebp-1Ch]
  int v7; // [esp+20h] [ebp-18h]
  int v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int v10; // [esp+2Ch] [ebp-Ch]
  int v11; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v11 = Scr_GetString(0);
  v3 = BG_GetWeaponIndexForName(v11);
  v10 = v3;
  if ( v3 )
  {
    if ( (unsigned int)Scr_GetNumParam() <= 1 )
    {
      v4 = Drop_Weapon(v6, v10, "tag_weapon_right");
    }
    else
    {
      v9 = Scr_GetString(1);
      v4 = Drop_Weapon(v6, v10, v9);
    }
    result = GScr_AddEntity(v4);
  }
  else
  {
    v7 = BG_FindItem(v11);
    if ( v7 )
    {
      v8 = Drop_Item((int)v6, v7, 0.0, 0);
      result = GScr_AddEntity(v8);
    }
    else
    {
      result = GScr_AddEntity(0);
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13AB0: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 14140: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 14970: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003EC84) --------------------------------------------------------
int __cdecl sub_3EC84(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // al
  char v5; // al
  unsigned __int16 v6; // ax
  _DWORD *v7; // eax
  _DWORD *v8; // eax
  _DWORD *v9; // [esp+30h] [ebp-98h]
  _DWORD *v10; // [esp+34h] [ebp-94h]
  int v11; // [esp+38h] [ebp-90h]
  float v12; // [esp+40h] [ebp-88h]
  float v13; // [esp+44h] [ebp-84h]
  float v14; // [esp+48h] [ebp-80h]
  float v15; // [esp+50h] [ebp-78h] BYREF
  float v16; // [esp+54h] [ebp-74h]
  float v17; // [esp+58h] [ebp-70h]
  float v18; // [esp+60h] [ebp-68h]
  int v19; // [esp+64h] [ebp-64h]
  int v20; // [esp+68h] [ebp-60h]
  int v21; // [esp+6Ch] [ebp-5Ch]
  int v22; // [esp+70h] [ebp-58h]
  int v23; // [esp+74h] [ebp-54h]
  int v24; // [esp+78h] [ebp-50h]
  char *v25; // [esp+7Ch] [ebp-4Ch]
  char v26[28]; // [esp+80h] [ebp-48h] BYREF
  char *v27; // [esp+9Ch] [ebp-2Ch]
  char v28[24]; // [esp+A0h] [ebp-28h] BYREF
  _DWORD *v29; // [esp+B8h] [ebp-10h]
  int v30; // [esp+BCh] [ebp-Ch]

  v30 = (int)&dword_C69C8 + (_DWORD)g_entities;
  v29 = (int *)((char *)&dword_C69C8 + (_DWORD)g_entities);
  v27 = 0;
  v25 = 0;
  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v9 = 0;
  }
  else
  {
    v9 = &g_entities[199 * a1];
    if ( !v9[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = Scr_GetInt(2);
  v24 = result;
  if ( result > 0 )
  {
    if ( Scr_GetType(0) && Scr_GetPointerType(0) == 13 )
      v30 = Scr_GetEntity(1);
    if ( Scr_GetType(1) && Scr_GetPointerType(1) == 13 )
      v29 = (_DWORD *)Scr_GetEntity(1);
    v23 = Scr_GetInt(3);
    v4 = Scr_GetString(4);
    v22 = G_IndexForMeansOfDeath(v4);
    v5 = Scr_GetString(5);
    v21 = (unsigned __int8)BG_GetWeaponIndexForName(v5);
    if ( Scr_GetType(6) )
    {
      Scr_GetVector(6, v26);
      v25 = v26;
    }
    if ( Scr_GetType(7) )
    {
      Scr_GetVector(7, v28);
      v27 = v28;
    }
    v6 = Scr_GetConstString(8);
    v20 = G_GetHitLocationIndexFromString(v6);
    if ( v27 )
    {
      VectorNormalize2(v27, &v15);
    }
    else
    {
      v17 = 0.0;
      v16 = 0.0;
      v15 = 0.0;
    }
    if ( (v9[97] & 8) != 0 || (v23 & 4) != 0 )
    {
      v19 = 0;
    }
    else
    {
      v18 = 0.30000001;
      if ( (*(_DWORD *)(v9[87] + 12) & 1) != 0 )
      {
        v18 = 0.02;
      }
      else if ( (*(_DWORD *)(v9[87] + 12) & 2) != 0 )
      {
        v18 = 0.15000001;
      }
      v19 = (int)((long double)v24 * v18);
      if ( v19 > 60 )
        v19 = 60;
      if ( v19 )
      {
        v12 = (long double)v19 * g_knockback[2] / 250.0 * v15;
        v13 = (long double)v19 * g_knockback[2] / 250.0 * v16;
        v14 = (long double)v19 * g_knockback[2] / 250.0 * v17;
        *(float *)(v9[87] + 32) = *(float *)(v9[87] + 32) + v12;
        *(float *)(v9[87] + 36) = *(float *)(v9[87] + 36) + v13;
        *(float *)(v9[87] + 40) = *(float *)(v9[87] + 40) + v14;
        if ( !*(_DWORD *)(v9[87] + 16) )
        {
          v11 = 2 * v19;
          if ( 2 * v19 <= 49 )
            v11 = 50;
          if ( v11 > 200 )
            v11 = 200;
          *(_DWORD *)(v9[87] + 16) = v11;
          *(_DWORD *)(v9[87] + 12) |= 0x200u;
        }
      }
    }
    result = v9[97] & 1;
    if ( !result )
    {
      if ( v21 && !*(_DWORD *)(BG_GetInfoForWeapon(v21) + 112) )
      {
        if ( *(_DWORD *)(BG_GetInfoForWeapon(v21) + 704) )
          v7 = (_DWORD *)G_TempEntity(v26, 174);
        else
          v7 = (_DWORD *)G_TempEntity(v26, 173);
        v10 = v7;
        v7[40] = (unsigned __int8)DirToByte(&v15);
        v10[54] = (unsigned __int8)DirToByte(&v15);
        v10[34] = 7;
        v10[29] = *v29;
        v10[61] |= 0x2000u;
        v10[62] = *(_DWORD *)(v9[87] + 172);
        if ( *(_DWORD *)(BG_GetInfoForWeapon(v21) + 704) )
          v8 = (_DWORD *)G_TempEntity(v26, 176);
        else
          v8 = (_DWORD *)G_TempEntity(v26, 175);
        v8[34] = 7;
        v8[29] = *v29;
        v8[36] = *(_DWORD *)(v9[87] + 172);
        v8[61] = 2048;
        v8[62] = *(_DWORD *)(v9[87] + 172);
      }
      *(_DWORD *)(v9[87] + 8732) += v24;
      if ( v27 )
      {
        *(float *)(v9[87] + 8736) = v15;
        *(float *)(v9[87] + 8740) = v16;
        *(float *)(v9[87] + 8744) = v17;
        *(_DWORD *)(v9[87] + 8748) = 0;
      }
      else
      {
        *(_DWORD *)(v9[87] + 8736) = v9[78];
        *(_DWORD *)(v9[87] + 8740) = v9[79];
        *(_DWORD *)(v9[87] + 8744) = v9[80];
        *(_DWORD *)(v9[87] + 8748) = 1;
      }
      v9[142] -= v24;
      Scr_AddEntity(v29);
      Scr_AddInt(v24);
      Scr_Notify(v9, scr_const[13], 2);
      if ( (int)v9[142] > 0 )
      {
        if ( v9[135] )
          ((void (__cdecl *)(_DWORD *, _DWORD *, int, char *, int, float *, int))v9[135])(
            v9,
            v29,
            v24,
            v25,
            v22,
            &v15,
            v20);
      }
      else
      {
        if ( (int)v9[142] < -999 )
          v9[142] = -999;
        v9[152] = v29;
        if ( v9[136] )
          ((void (__cdecl *)(_DWORD *, int, _DWORD *, int, int, int, float *, int))v9[136])(
            v9,
            v30,
            v29,
            v24,
            v22,
            v21,
            &v15,
            v20);
        result = (int)v9;
        if ( !*((_BYTE *)v9 + 356) )
          return result;
      }
      result = v9[142];
      *(_DWORD *)(v9[87] + 244) = result;
      return result;
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 136B0: using guessed type _DWORD __cdecl G_GetHitLocationIndexFromString(_DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15500: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// C69C8: using guessed type int dword_C69C8;

//----- (0003F4AC) --------------------------------------------------------
int __cdecl sub_3F4AC(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // edx
  _DWORD *v5; // [esp+20h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5[97] &= 0xFFFFFFFE;
  v3 = v5[87];
  v5[142] = 0;
  *(_DWORD *)(v3 + 244) = 0;
  return player_die(v5, v5, v5, 100000, 22, 0, 0, 0);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13E50: using guessed type _DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0003F5A8) --------------------------------------------------------
int __cdecl sub_3F5A8(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  char v7; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v6[87] + 8424) != 2 )
    return Scr_AddInt(0);
  v3 = Scr_GetString(0);
  v7 = GScr_GetScriptMenuIndex(v3);
  v4 = va("t %i", v7);
  trap_SendServerCommand(a1, 1, v4);
  return Scr_AddInt(1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15230: using guessed type _DWORD __cdecl GScr_GetScriptMenuIndex(char);

//----- (0003F69D) --------------------------------------------------------
int __cdecl sub_3F69D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  char v7; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( *(_DWORD *)(v6[87] + 8424) != 2 )
    return Scr_AddInt(0);
  v3 = Scr_GetString(0);
  v7 = GScr_GetScriptMenuIndex(v3);
  v4 = va("t %i 1", v7);
  trap_SendServerCommand(a1, 1, v4);
  return Scr_AddInt(1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15230: using guessed type _DWORD __cdecl GScr_GetScriptMenuIndex(char);

//----- (0003F792) --------------------------------------------------------
int __cdecl sub_3F792(int a1)
{
  return trap_SendServerCommand(a1, 1, "u");
}
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0003F7C7) --------------------------------------------------------
_BOOL4 __cdecl sub_3F7C7(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) != 0;
}

//----- (0003F7E2) --------------------------------------------------------
int __cdecl sub_3F7E2(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v4; // eax
  char v5; // al
  int v6; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a1];
    if ( !v7[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_3F7C7((int)v7) )
    return Scr_AddConstString(scr_const[124]);
  v10 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v10);
  v9 = BG_GetWeaponSlotForName(v4);
  if ( !v9 )
  {
    v5 = SL_ConvertToString(v10);
    v6 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v5);
    Scr_ParamError(0, v6);
  }
  if ( !*(_BYTE *)(v9 + v7[87] + 788) )
    return Scr_AddConstString(scr_const[124]);
  v8 = BG_GetInfoForWeapon(*(char *)(v9 + v7[87] + 788));
  return Scr_AddString(*(_DWORD *)(v8 + 4));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0003F93D) --------------------------------------------------------
int __cdecl sub_3F93D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  unsigned __int8 v6; // al
  int v7; // eax
  int v8; // eax
  int result; // eax
  _DWORD *v10; // [esp+10h] [ebp-28h]
  int v11; // [esp+14h] [ebp-24h]
  int v12; // [esp+18h] [ebp-20h]
  int v13; // [esp+1Ch] [ebp-1Ch]
  int v14; // [esp+20h] [ebp-18h]
  int v15; // [esp+28h] [ebp-10h]
  unsigned __int16 v16; // [esp+2Eh] [ebp-Ah]

  v11 = 0;
  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v10 = 0;
  }
  else
  {
    v10 = &g_entities[199 * a1];
    if ( !v10[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v16 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v16);
  v15 = BG_GetWeaponSlotForName(v3);
  if ( !v15 )
  {
    v4 = SL_ConvertToString(v16);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v13 = Scr_GetString(1);
  if ( Q_stricmp(v13, "none") )
  {
    v6 = BG_GetWeaponIndexForName(v13);
    v14 = v6;
    if ( !v6 )
    {
      v7 = va("Unknown weapon %s.", v13);
      Scr_ParamError(1, v7);
    }
    v12 = BG_GetInfoForWeapon(v14);
    if ( *(_DWORD *)(v12 + 120) != v15
      && (*(_DWORD *)(v12 + 120) != 1 && *(_DWORD *)(v12 + 120) != 2 || v15 != 1 && v15 != 2) )
    {
      BG_GetWeaponSlotNameForIndex(v15);
      BG_GetWeaponSlotNameForIndex(*(_DWORD *)(v12 + 120));
      v8 = va("Weapon %s goes in the %s weaponslot, not the %s weaponslot.", v13);
      Scr_ParamError(1, v8);
    }
  }
  else
  {
    v14 = 0;
  }
  result = *(char *)(v15 + v10[87] + 788);
  if ( *(_BYTE *)(v15 + v10[87] + 788) )
    result = BG_TakePlayerWeapon(v10[87], *(char *)(v15 + v10[87] + 788));
  if ( v14 )
  {
    if ( v15 == 2 && !*(_BYTE *)(v10[87] + 789) )
      v11 = 1;
    result = BG_GivePlayerWeapon(v10[87], v14);
    if ( v11 )
    {
      *(_BYTE *)(v10[87] + 790) = *(_BYTE *)(v10[87] + 789);
      result = v10[87];
      *(_BYTE *)(result + 789) = 0;
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 144D0: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 14D00: using guessed type _DWORD __cdecl BG_GetWeaponSlotNameForIndex(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0003FBC2) --------------------------------------------------------
int __cdecl sub_3FBC2(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char *v4; // eax
  char v5; // al
  int v6; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+18h] [ebp-10h]
  int v11; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v12; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a1];
    if ( !v7[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_3F7C7((int)v7) )
    return Scr_AddInt(0);
  v12 = Scr_GetConstString(0);
  v4 = (char *)SL_ConvertToString(v12);
  v11 = BG_GetWeaponSlotForName(v4);
  if ( !v11 )
  {
    v5 = SL_ConvertToString(v12);
    v6 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v5);
    Scr_ParamError(0, v6);
  }
  v10 = *(char *)(v11 + v7[87] + 788);
  if ( !*(_BYTE *)(v11 + v7[87] + 788) )
    return Scr_AddInt(0);
  if ( BG_WeaponIsClipOnly(v10) )
  {
    v8 = BG_ClipForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v7[87] + 4 * v8 + 524));
  }
  else
  {
    v9 = BG_AmmoForWeapon(v10);
    result = Scr_AddInt(*(_DWORD *)(v7[87] + 4 * v9 + 268));
  }
  return result;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0003FD52) --------------------------------------------------------
int __cdecl sub_3FD52(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+10h] [ebp-18h]
  int v10; // [esp+14h] [ebp-14h]
  int v11; // [esp+18h] [ebp-10h]
  int v12; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v13; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a1];
    if ( !v7[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v13 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v13);
  v12 = BG_GetWeaponSlotForName(v3);
  if ( !v12 )
  {
    v4 = SL_ConvertToString(v13);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v10 = Scr_GetInt(1);
  result = *(char *)(v12 + v7[87] + 788);
  v11 = result;
  if ( *(_BYTE *)(v12 + v7[87] + 788) )
  {
    if ( BG_WeaponIsClipOnly(result) )
    {
      result = BG_ClipForWeapon(v11);
      v8 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > BG_GetAmmoClipSize(result) )
            v10 = BG_GetAmmoClipSize(v8);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(v7[87] + 4 * v8 + 524) = v10;
      }
    }
    else
    {
      result = BG_AmmoForWeapon(v11);
      v9 = result;
      if ( result )
      {
        if ( v10 >= 0 )
        {
          if ( v10 > BG_GetAmmoTypeMax(result) )
            v10 = BG_GetAmmoTypeMax(v9);
        }
        else
        {
          v10 = 0;
        }
        result = v10;
        *(_DWORD *)(v7[87] + 4 * v9 + 268) = v10;
      }
    }
  }
  return result;
}
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0003FF2B) --------------------------------------------------------
int __cdecl sub_3FF2B(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  int v9; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v10; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a1];
    if ( !v7[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  if ( sub_3F7C7((int)v7) )
    goto LABEL_11;
  v10 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v10);
  v9 = BG_GetWeaponSlotForName(v3);
  if ( !v9 )
  {
    v4 = SL_ConvertToString(v10);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  if ( *(_BYTE *)(v9 + v7[87] + 788) && (v8 = BG_ClipForWeapon(*(char *)(v9 + v7[87] + 788))) != 0 )
    result = Scr_AddInt(*(_DWORD *)(v7[87] + 4 * v8 + 524));
  else
LABEL_11:
    result = Scr_AddInt(0);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00040095) --------------------------------------------------------
int __cdecl sub_40095(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char *v3; // eax
  char v4; // al
  int v5; // eax
  int result; // eax
  _DWORD *v7; // [esp+Ch] [ebp-1Ch]
  int v8; // [esp+10h] [ebp-18h]
  int v9; // [esp+14h] [ebp-14h]
  int v10; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v11; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a1];
    if ( !v7[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v11 = Scr_GetConstString(0);
  v3 = (char *)SL_ConvertToString(v11);
  v10 = BG_GetWeaponSlotForName(v3);
  if ( !v10 )
  {
    v4 = SL_ConvertToString(v11);
    v5 = va(
           "Unknown weaponslot name %s. Valid weaponslots are \"primary\", \"primaryb\", \"pistol\", \"grenade\", and \"smokegrenade\"",
           v4);
    Scr_ParamError(0, v5);
  }
  v9 = Scr_GetInt(1);
  if ( !*(_BYTE *)(v10 + v7[87] + 788) )
    return Scr_AddInt(0);
  result = BG_ClipForWeapon(*(char *)(v10 + v7[87] + 788));
  v8 = result;
  if ( result )
  {
    if ( v9 < 0 )
      v9 = 0;
    if ( v9 > BG_GetAmmoClipSize(result) )
      v9 = BG_GetAmmoClipSize(v8);
    result = v9;
    *(_DWORD *)(v7[87] + 4 * v8 + 524) = v9;
  }
  return result;
}
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00040208) --------------------------------------------------------
int __cdecl sub_40208(int a1)
{
  return Scr_MakeGameMessage(a1, (char)"f");
}
// 159A0: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (00040235) --------------------------------------------------------
int __cdecl sub_40235(int a1)
{
  return Scr_MakeGameMessage(a1, (char)"g");
}
// 159A0: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (00040262) --------------------------------------------------------
int __cdecl sub_40262(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  char v5[16]; // [esp+20h] [ebp-28h] BYREF
  char v6[24]; // [esp+30h] [ebp-18h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_GetVector(0, v6);
  Scr_GetVector(1, v5);
  return ClientSpawn(v4, v6, v5);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 150C0: using guessed type _DWORD __cdecl ClientSpawn(_DWORD, _DWORD, _DWORD);

//----- (00040327) --------------------------------------------------------
int __cdecl sub_40327(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int result; // eax
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v5[87];
  result = Scr_GetInt(0);
  *(_DWORD *)(v3 + 8532) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (000403CA) --------------------------------------------------------
int __cdecl sub_403CA(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 8) &= 0xFFFFF7FF;
  return result;
}

//----- (000403E1) --------------------------------------------------------
int __cdecl sub_403E1(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+8h] [ebp-10h]
  _DWORD *v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v5 = (_DWORD *)v4[87];
  v6 = G_SpawnPlayerClone();
  *(_DWORD *)(v6 + 144) = v5[43];
  *(_DWORD *)(v6 + 8) = v5[32] & 0xFFFFFFF7 | *(_DWORD *)(v6 + 8) & 8 | 0x800;
  G_SetOrigin(v6, v4 + 78);
  G_SetAngle(v6, v4 + 81);
  *(_DWORD *)(v6 + 12) = 5;
  *(_DWORD *)(v6 + 16) = level[122];
  *(_DWORD *)(v6 + 36) = v5[8];
  *(_DWORD *)(v6 + 40) = v5[9];
  *(_DWORD *)(v6 + 44) = v5[10];
  *(_DWORD *)(v6 + 4) = 2;
  *(_BYTE *)(v6 + 357) = 1;
  *(_DWORD *)(v6 + 124) = 1023;
  *(_DWORD *)(v6 + 244) = 512;
  *(_DWORD *)(v6 + 260) = v4[65];
  *(_DWORD *)(v6 + 264) = v4[66];
  *(_DWORD *)(v6 + 268) = v4[67];
  *(_DWORD *)(v6 + 272) = v4[68];
  *(_DWORD *)(v6 + 276) = v4[69];
  *(_DWORD *)(v6 + 280) = v4[70];
  *(_DWORD *)(v6 + 288) = v4[72];
  *(_DWORD *)(v6 + 292) = v4[73];
  *(_DWORD *)(v6 + 296) = v4[74];
  *(_DWORD *)(v6 + 300) = v4[75];
  *(_DWORD *)(v6 + 304) = v4[76];
  *(_DWORD *)(v6 + 308) = v4[77];
  *(_DWORD *)(v6 + 204) = v5[28];
  *(_DWORD *)(v6 + 208) = v5[30];
  *(_DWORD *)(v6 + 408) = 65537;
  trap_LinkEntity(v6);
  *(_DWORD *)(v6 + 516) = level[122] + 250;
  *(_DWORD *)(v6 + 520) = sub_403CA;
  return GScr_AddEntity(v6);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14970: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 15030: using guessed type int G_SpawnPlayerClone(void);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004068A) --------------------------------------------------------
int __cdecl sub_4068A(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  char v5[1024]; // [esp+20h] [ebp-828h] BYREF
  char v6[1032]; // [esp+420h] [ebp-428h] BYREF
  char *v7; // [esp+828h] [ebp-20h]
  char *s; // [esp+82Ch] [ebp-1Ch]
  char v9[4]; // [esp+830h] [ebp-18h]
  int v10; // [esp+834h] [ebp-14h]
  size_t v11; // [esp+838h] [ebp-10h]
  int v12; // [esp+83Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  *(_DWORD *)v9 = Scr_GetString(0);
  v10 = Scr_GetType(1);
  if ( v10 == 2 )
  {
    Scr_ConstructMessageString(1, v6, 1024, 4);
    s = v6;
  }
  else
  {
    s = (char *)Scr_GetString(1);
  }
  v11 = strlen(s);
  v7 = v5;
  memset(v5, 0, sizeof(v5));
  v12 = 0;
  while ( v12 <= 0x1FFF && s[v12] )
  {
    *v7 = Q_CleanCharacter(s[v12]);
    if ( *v7 == 34 )
      *v7 = 39;
    ++v12;
    ++v7;
  }
  v3 = va("v %s \"%s\"", v9[0]);
  return trap_SendServerCommand(a1, 1, v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13700: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0004083D) --------------------------------------------------------
int __cdecl sub_4083D(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int result; // eax
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v5[87];
  result = Scr_GetBool(0);
  *(_DWORD *)(v3 + 8680) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);

//----- (000408E0) --------------------------------------------------------
int __cdecl sub_408E0(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = *(_DWORD *)(v4[87] + 12) | 0x100000;
  *(_DWORD *)(v4[87] + 12) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00040983) --------------------------------------------------------
unsigned int __cdecl sub_40983(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  unsigned int result; // eax
  _DWORD *v4; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  result = *(_DWORD *)(v4[87] + 12) & 0xFFEFFFFF;
  *(_DWORD *)(v4[87] + 12) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00040A26) --------------------------------------------------------
int __cdecl sub_40A26(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax
  unsigned int v5; // [esp+20h] [ebp-18h]
  char v6; // [esp+30h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  v5 = Scr_GetNumParam();
  if ( v5 == 2 )
    goto LABEL_11;
  if ( v5 <= 2 )
  {
    if ( v5 != 1 )
      return Scr_Error(
               "USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
               "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
LABEL_12:
    v6 = Scr_GetString(0);
    v3 = va("r \"%s\" %g %g", v6);
    return trap_SendServerCommand(a1, 1, v3);
  }
  if ( v5 == 3 )
  {
    Scr_GetFloat(2);
LABEL_11:
    Scr_GetFloat(1);
    goto LABEL_12;
  }
  return Scr_Error(
           "USAGE: player setReverb(\"roomtype\", wetlevel = 0.5, fadetime = 1);\n"
           "wetlevel is a float from 0 (no effect) to 1 (full effect), fadetime is in sec and just modifies wetlevel\n");
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00040B55) --------------------------------------------------------
int __cdecl sub_40B55(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // esi
  int v4; // eax
  _DWORD *v6; // [esp+Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v6 = 0;
  }
  else
  {
    v6 = &g_entities[199 * a1];
    if ( !v6[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v3 = v6[87];
  v4 = Scr_GetEntity(0);
  return Scr_AddInt(*(_DWORD *)(v3 + 8808) == v4);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (00040C06) --------------------------------------------------------
int __cdecl sub_40C06(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  char v3; // al
  int v4; // eax
  char *s2; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  s2 = (char *)Scr_GetString(0);
  v3 = G_SoundAliasIndex(s2);
  v4 = va("s %i", v3);
  return trap_SendServerCommand(a1, 0, v4);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00040CD2) --------------------------------------------------------
int __cdecl sub_40CD2(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 0, &src);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00040DBD) --------------------------------------------------------
int __cdecl sub_40DBD(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 1, &src);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00040EA8) --------------------------------------------------------
int __cdecl sub_40EA8(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-40Ch]
  char src; // [esp+20h] [ebp-408h] BYREF
  _BYTE v6[3]; // [esp+21h] [ebp-407h] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( !v4[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  Scr_ConstructMessageString(0, v6, 1023, 5);
  src = 20;
  return G_Say((int)v4, 0, 3, &src);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00040F93) --------------------------------------------------------
int __cdecl sub_40F93(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // ecx
  int result; // eax
  _DWORD *v5; // [esp+14h] [ebp-14h]
  int v6; // [esp+1Ch] [ebp-Ch]
  __int16 v7; // [esp+22h] [ebp-6h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( !v5[87] )
    {
      v1 = va("entity %i is not a player", a1);
      Scr_Error(v1);
    }
  }
  v7 = Scr_GetConstString(0);
  v6 = 0;
  if ( v7 == scr_const[4] )
  {
    v6 = 2;
  }
  else if ( v7 == scr_const[2] )
  {
    v6 = 4;
  }
  else if ( v7 == scr_const[124] )
  {
    v6 = 1;
  }
  else if ( v7 == scr_const[128] )
  {
    v6 = 16;
  }
  else
  {
    Scr_ParamError(0, "team must be \"axis\", \"allies\", \"none\", or \"freelook\"");
  }
  if ( Scr_GetBool(1) )
  {
    v3 = v5[87];
    result = *(_DWORD *)(v3 + 8564) & ~v6;
  }
  else
  {
    v3 = v5[87];
    result = *(_DWORD *)(v3 + 8564) | v6;
  }
  *(_DWORD *)(v3 + 8564) = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0004110B) --------------------------------------------------------
int __cdecl sub_4110B(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int v3; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self getGuid()\n");
  v3 = trap_GetGuid(a1);
  return Scr_AddInt(v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13300: using guessed type _DWORD __cdecl trap_GetGuid(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (000411BB) --------------------------------------------------------
int __cdecl sub_411BB(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoDemoStart()\n");
  result = trap_Cvar_VariableIntegerValue("g_autodemo");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "C");
    result = Scr_AddInt(1);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15620: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00041295) --------------------------------------------------------
int __cdecl sub_41295(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoDemoStop()\n");
  result = trap_Cvar_VariableIntegerValue("g_autodemo");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "D");
    result = Scr_AddInt(1);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15620: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (0004136F) --------------------------------------------------------
int __cdecl sub_4136F(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
  }
  else if ( !g_entities[199 * a1 + 87] )
  {
    v1 = va("entity %i is not a player", a1);
    Scr_Error(v1);
  }
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: self autoScreenshot()\n");
  result = trap_Cvar_VariableIntegerValue("g_autoscreenshot");
  if ( result )
  {
    trap_SendServerCommand(a1, 1, "E");
    result = Scr_AddInt(1);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15620: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00041449) --------------------------------------------------------
int __cdecl Player_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0x35; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_82CA0 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_82CA0 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_82CA4 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 82CA0: using guessed type char *off_82CA0;
// 82CA4: using guessed type int (__cdecl *off_82CA4)(char);

//----- (000414C4) --------------------------------------------------------
void sub_414C4()
{
  ;
}

//----- (000414C8) --------------------------------------------------------
int __cdecl DeathmatchScoreboardMessage(int a1)
{
  int v1; // eax
  int v3; // [esp+24h] [ebp-9A4h]
  int v4; // [esp+2Ch] [ebp-99Ch]
  size_t v5; // [esp+34h] [ebp-994h]
  int i; // [esp+38h] [ebp-990h]
  int v7; // [esp+3Ch] [ebp-98Ch]
  char v8[1408]; // [esp+40h] [ebp-988h] BYREF
  char s[1032]; // [esp+5C0h] [ebp-408h] BYREF

  v8[0] = 0;
  v7 = 0;
  v4 = level[133];
  if ( v4 > 64 )
    v4 = 64;
  for ( i = 0; i < v4; ++i )
  {
    v3 = level[i + 134];
    if ( *(_DWORD *)(level[0] + 8908 * v3 + 8424) != 1 )
      trap_GetClientPing(v3);
    Com_sprintf(s, 0x400u, " %i %i %i %i %i", level[i + 134]);
    v5 = strlen(s);
    if ( (int)(v7 + v5) > 1024 )
      break;
    strcpy(&v8[v7], s);
    v7 += v5;
  }
  v1 = va("b %i %i %i%s", i);
  return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, v1);
}
// 13820: using guessed type _DWORD __cdecl trap_GetClientPing(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000416E2) --------------------------------------------------------
int __cdecl Cmd_Score_f(int a1)
{
  return DeathmatchScoreboardMessage(a1);
}
// 153B0: using guessed type _DWORD __cdecl DeathmatchScoreboardMessage(_DWORD);

//----- (00041705) --------------------------------------------------------
int __cdecl CheatsOk(int a1)
{
  int v1; // eax
  int v2; // eax
  char v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+10h] [ebp-8h]

  if ( g_cheats[3] )
  {
    if ( *(int *)(a1 + 568) > 0 )
    {
      v5 = 1;
    }
    else
    {
      v2 = va("e \"GAME_MUSTBEALIVECOMMAND\"", v4);
      trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
      v5 = 0;
    }
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"", v4);
    trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v1);
    v5 = 0;
  }
  return v5;
}
// 4172C: variable 'v4' is possibly undefined
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000417BD) --------------------------------------------------------
_BYTE *__cdecl ConcatArgs(int a1)
{
  char s[1024]; // [esp+10h] [ebp-418h] BYREF
  int v3; // [esp+410h] [ebp-18h]
  size_t n; // [esp+414h] [ebp-14h]
  int v5; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  v3 = 0;
  v5 = trap_Argc();
  for ( i = a1; i < v5; ++i )
  {
    trap_Argv(i, s, 1024);
    n = strlen(s);
    if ( (int)(v3 + n) > 1022 )
      break;
    memcpy(&byte_A5980[v3], s, n);
    v3 += n;
    if ( i != v5 - 1 )
      byte_A5980[v3++] = 32;
  }
  byte_A5980[v3] = 0;
  return byte_A5980;
}
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);

//----- (0004189C) --------------------------------------------------------
_BYTE *__cdecl SanitizeString(char *a1, _BYTE *a2)
{
  _BYTE *v2; // esi
  _BYTE *result; // eax
  int v4; // [esp+0h] [ebp-18h]

  while ( *a1 )
  {
    if ( *a1 == 27 )
    {
      a1 += 2;
    }
    else if ( *a1 > 31 )
    {
      v2 = a2;
      v4 = *a1++;
      ++a2;
      *v2 = tolower(v4);
    }
    else
    {
      ++a1;
    }
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (00041901) --------------------------------------------------------
int __cdecl ClientNumberFromString(int a1, char *nptr)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v6; // [esp+1Ch] [ebp-81Ch]
  char s1[1024]; // [esp+20h] [ebp-818h] BYREF
  char s2[1032]; // [esp+420h] [ebp-418h] BYREF
  char v9[4]; // [esp+828h] [ebp-10h]
  int v10; // [esp+82Ch] [ebp-Ch]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    SanitizeString(nptr, s2);
    *(_DWORD *)v9 = 0;
    v10 = level[0];
    while ( *(int *)v9 < level[120] )
    {
      if ( *(_DWORD *)(v10 + 8424) == 2 )
      {
        SanitizeString(v10 + 8636, s1);
        if ( !strcmp(s1, s2) )
          return *(_DWORD *)v9;
      }
      ++*(_DWORD *)v9;
      v10 += 8908;
    }
    v4 = va(aEGameUsernoton, (char)nptr);
    trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v4);
    v6 = -1;
  }
  else
  {
    *(_DWORD *)v9 = atoi(nptr);
    if ( *(int *)v9 >= 0 && *(int *)v9 < level[120] )
    {
      if ( *(_DWORD *)(level[0] + 8908 * *(_DWORD *)v9 + 8424) == 2 )
      {
        v6 = *(_DWORD *)v9;
      }
      else
      {
        v3 = va(aEGameClientnot_0, v9[0]);
        trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v3);
        v6 = -1;
      }
    }
    else
    {
      v2 = va(aEGameBadclient, v9[0]);
      trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
      v6 = -1;
    }
  }
  return v6;
}
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14950: using guessed type _DWORD __cdecl SanitizeString(_DWORD, _DWORD);

//----- (00041B0A) --------------------------------------------------------
void __cdecl G_setfog(char *s)
{
  char v1; // [esp+3Ch] [ebp-2Ch] BYREF
  char v2; // [esp+40h] [ebp-28h] BYREF
  char v3; // [esp+44h] [ebp-24h] BYREF
  char v4; // [esp+48h] [ebp-20h] BYREF
  float v5; // [esp+54h] [ebp-14h] BYREF
  float v6; // [esp+58h] [ebp-10h] BYREF
  float v7; // [esp+5Ch] [ebp-Ch] BYREF

  trap_SetConfigstring(12, s);
  level[2176] = 2139095039;
  level[2177] = 2139095039;
  if ( sscanf(s, "%f %f %f %f %f %f %f", &v7, &v6, &v5, &v2, &v3, &v4, &v1) == 7 && v5 >= 1.0 )
  {
    *(float *)&level[2176] = v6 - v7 + v7;
    *(float *)&level[2177] = *(float *)&level[2176] * *(float *)&level[2176];
  }
}
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (00041BF3) --------------------------------------------------------
int Cmd_Fogswitch_f()
{
  char *v0; // eax

  v0 = (char *)ConcatArgs(1);
  return G_setfog(v0);
}
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (00041C1F) --------------------------------------------------------
_DWORD *__cdecl Cmd_Give_f(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // [esp+18h] [ebp-20h]
  _DWORD *s; // [esp+1Ch] [ebp-1Ch]
  _BOOL4 v4; // [esp+20h] [ebp-18h]
  int i; // [esp+24h] [ebp-14h]
  int j; // [esp+24h] [ebp-14h]
  int k; // [esp+24h] [ebp-14h]
  _DWORD *v8; // [esp+28h] [ebp-10h]
  char *nptr; // [esp+2Ch] [ebp-Ch]
  _DWORD *v10; // [esp+30h] [ebp-8h]

  result = (_DWORD *)CheatsOk(a1);
  if ( result )
  {
    nptr = (char *)ConcatArgs(2);
    v2 = atoi(nptr);
    result = (_DWORD *)ConcatArgs(1);
    v10 = result;
    if ( result )
    {
      if ( *(_BYTE *)result )
      {
        if ( !(v4 = Q_stricmp(result, &unk_785E0) == 0) && Q_stricmpn(v10, "health", 6)
          || (!v2 ? (result = *(_DWORD **)(a1[87] + 252)) : (result = (_DWORD *)(a1[142] + v2)), a1[142] = result, v4) )
        {
          if ( !v4 && Q_stricmp(v10, "weapons") )
            goto LABEL_41;
          level[7] = 1;
          for ( i = 1; i <= BG_GetNumWeapons(); BG_GivePlayerWeapon(a1[87], i++) )
            ;
          result = level;
          level[7] = 0;
          if ( v4 )
          {
LABEL_41:
            if ( !v4 && Q_stricmpn(v10, "ammo", 4) )
              goto LABEL_27;
            if ( v2 )
            {
              result = (_DWORD *)a1[87];
              if ( result[44] )
                result = (_DWORD *)Add_Ammo(a1, *(_DWORD *)(a1[87] + 176), v2, 1);
            }
            else
            {
              for ( j = 1; ; ++j )
              {
                result = (_DWORD *)BG_GetNumWeapons();
                if ( j > (int)result )
                  break;
                if ( Com_BitCheck(a1[87] + 780, j) )
                  Add_Ammo(a1, j, 998, 1);
              }
            }
            if ( v4 )
            {
LABEL_27:
              result = (_DWORD *)Q_stricmpn(v10, "allammo", 7);
              if ( result )
                goto LABEL_40;
              if ( !v2 )
                goto LABEL_40;
              for ( k = 1; ; Add_Ammo(a1, k++, v2, 1) )
              {
                result = (_DWORD *)BG_GetNumWeapons();
                if ( k > (int)result )
                  break;
              }
              if ( v4 )
              {
LABEL_40:
                if ( !v4 )
                {
                  result = (_DWORD *)BG_FindItem(v10);
                  v8 = result;
                  if ( result )
                  {
                    level[7] = 1;
                    s = (_DWORD *)G_Spawn();
                    s[78] = a1[78];
                    s[79] = a1[79];
                    s[80] = a1[80];
                    G_SetConstString(s + 95, *v8);
                    G_SpawnItem(s, v8);
                    *((_BYTE *)s + 374) = 1;
                    Touch_Item(s, a1, 1);
                    *((_BYTE *)s + 374) = 0;
                    if ( *((_BYTE *)s + 356) )
                      G_FreeEntity(s);
                    result = level;
                    level[7] = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 12E70: using guessed type int G_Spawn(void);
// 13870: using guessed type _DWORD __cdecl G_SetConstString(_DWORD, _DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13960: using guessed type _DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13AB0: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 13D90: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 144D0: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 14DA0: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00041FCA) --------------------------------------------------------
int __cdecl Cmd_Take_f(int a1)
{
  int result; // eax
  int v2; // esi
  int v3; // esi
  int v4; // esi
  int v5; // eax
  int v6; // esi
  int v7; // edi
  int v8; // esi
  int v9; // esi
  int v10; // esi
  int v11; // esi
  int v12; // esi
  int v13; // esi
  int v14; // eax
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // esi
  int v19; // esi
  int v20; // [esp+18h] [ebp-30h]
  int v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+20h] [ebp-28h]
  int v23; // [esp+24h] [ebp-24h]
  int v24; // [esp+28h] [ebp-20h]
  _BOOL4 v25; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int v27; // [esp+30h] [ebp-18h]
  int j; // [esp+30h] [ebp-18h]
  int k; // [esp+30h] [ebp-18h]
  char *nptr; // [esp+34h] [ebp-14h]
  int v31; // [esp+38h] [ebp-10h]

  result = CheatsOk(a1);
  if ( result )
  {
    nptr = (char *)ConcatArgs(2);
    v24 = atoi(nptr);
    result = ConcatArgs(1);
    v31 = result;
    if ( result )
    {
      if ( *(_BYTE *)result )
      {
        v25 = Q_stricmp(result, &unk_785E0) == 0;
        if ( !v25 )
        {
          if ( Q_stricmpn(v31, "health", 6) )
            goto LABEL_18;
        }
        if ( v24 )
        {
          *(_DWORD *)(a1 + 568) -= v24;
          result = a1;
          if ( *(int *)(a1 + 568) <= 0 )
          {
            result = a1;
            *(_DWORD *)(a1 + 568) = 1;
          }
        }
        else
        {
          result = a1;
          *(_DWORD *)(a1 + 568) = 1;
        }
        if ( v25 )
        {
LABEL_18:
          if ( !v25 && Q_stricmp(v31, "weapons") )
            goto LABEL_29;
          for ( i = 1; i <= BG_GetNumWeapons(); ++i )
          {
            BG_TakePlayerWeapon(*(_DWORD *)(a1 + 348), i);
            v2 = *(_DWORD *)(a1 + 348);
            *(_DWORD *)(v2 + 4 * BG_AmmoForWeapon(i) + 268) = 0;
            v3 = *(_DWORD *)(a1 + 348);
            *(_DWORD *)(v3 + 4 * BG_ClipForWeapon(i) + 524) = 0;
          }
          result = *(_DWORD *)(a1 + 348);
          if ( *(_DWORD *)(result + 176) )
          {
            *(_DWORD *)(*(_DWORD *)(a1 + 348) + 176) = 0;
            result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, "a 0");
          }
          if ( v25 )
          {
LABEL_29:
            if ( !v25 && Q_stricmpn(v31, "ammo", 4) )
              goto LABEL_30;
            if ( v24 )
            {
              result = *(_DWORD *)(a1 + 348);
              if ( *(_DWORD *)(result + 176) )
              {
                v27 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 176);
                v4 = *(_DWORD *)(a1 + 348);
                v5 = BG_AmmoForWeapon(v27);
                *(_DWORD *)(v4 + 4 * v5 + 268) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v5 + 268) - v24;
                v6 = *(_DWORD *)(a1 + 348);
                result = BG_AmmoForWeapon(v27);
                if ( *(int *)(v6 + 4 * result + 268) < 0 )
                {
                  v23 = *(_DWORD *)(a1 + 348);
                  v7 = BG_ClipForWeapon(v27);
                  v22 = *(_DWORD *)(a1 + 348);
                  *(_DWORD *)(v23 + 4 * v7 + 524) = *(_DWORD *)(v22 + 4 * v7 + 524)
                                                  + *(_DWORD *)(v22 + 4 * BG_AmmoForWeapon(v27) + 268);
                  v8 = *(_DWORD *)(a1 + 348);
                  *(_DWORD *)(v8 + 4 * BG_AmmoForWeapon(v27) + 268) = 0;
                  v9 = *(_DWORD *)(a1 + 348);
                  result = BG_ClipForWeapon(v27);
                  if ( *(int *)(v9 + 4 * result + 524) < 0 )
                  {
                    v10 = *(_DWORD *)(a1 + 348);
                    result = BG_ClipForWeapon(v27);
                    *(_DWORD *)(v10 + 4 * result + 524) = 0;
                  }
                }
              }
            }
            else
            {
              for ( j = 1; ; *(_DWORD *)(v12 + 4 * BG_ClipForWeapon(j++) + 524) = 0 )
              {
                result = BG_GetNumWeapons();
                if ( j > result )
                  break;
                v11 = *(_DWORD *)(a1 + 348);
                *(_DWORD *)(v11 + 4 * BG_AmmoForWeapon(j) + 268) = 0;
                v12 = *(_DWORD *)(a1 + 348);
              }
            }
            if ( v25 )
            {
LABEL_30:
              result = Q_stricmpn(v31, "allammo", 7);
              if ( !result && v24 )
              {
                for ( k = 1; ; ++k )
                {
                  result = BG_GetNumWeapons();
                  if ( k > result )
                    break;
                  v13 = *(_DWORD *)(a1 + 348);
                  v14 = BG_AmmoForWeapon(k);
                  *(_DWORD *)(v13 + 4 * v14 + 268) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) - v24;
                  v15 = *(_DWORD *)(a1 + 348);
                  if ( *(int *)(v15 + 4 * BG_AmmoForWeapon(k) + 268) < 0 )
                  {
                    v21 = *(_DWORD *)(a1 + 348);
                    v16 = BG_ClipForWeapon(k);
                    v20 = *(_DWORD *)(a1 + 348);
                    *(_DWORD *)(v21 + 4 * v16 + 524) = *(_DWORD *)(v20 + 4 * v16 + 524)
                                                     + *(_DWORD *)(v20 + 4 * BG_AmmoForWeapon(k) + 268);
                    v17 = *(_DWORD *)(a1 + 348);
                    *(_DWORD *)(v17 + 4 * BG_AmmoForWeapon(k) + 268) = 0;
                    v18 = *(_DWORD *)(a1 + 348);
                    if ( *(int *)(v18 + 4 * BG_ClipForWeapon(k) + 524) < 0 )
                    {
                      v19 = *(_DWORD *)(a1 + 348);
                      *(_DWORD *)(v19 + 4 * BG_ClipForWeapon(k) + 524) = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 14DA0: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (000424E7) --------------------------------------------------------
int __cdecl Cmd_God_f(int a1)
{
  int result; // eax
  int v2; // eax

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 388) ^= 1u;
    if ( (*(_DWORD *)(a1 + 388) & 1) != 0 )
      v2 = va("e \"%s\"", (unsigned __int8)&aGameGodmodeon[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v2 = va("e \"%s\"", (unsigned __int8)&aGameGodmodeoff[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00042586) --------------------------------------------------------
int __cdecl Cmd_Notarget_f(int a1)
{
  int result; // eax
  int v2; // eax

  result = CheatsOk(a1);
  if ( result )
  {
    *(_DWORD *)(a1 + 388) ^= 2u;
    if ( (*(_DWORD *)(a1 + 388) & 2) != 0 )
      v2 = va("e \"%s\"", (unsigned __int8)&aGameNotargeton[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v2 = va("e \"%s\"", (unsigned __int8)&aGameNotargetof[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00042625) --------------------------------------------------------
int __cdecl Cmd_Noclip_f(int a1)
{
  int result; // eax
  int v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8672) )
      v3 = "GAME_NOCLIPOFF";
    else
      v3 = "GAME_NOCLIPON";
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8672) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8672) == 0;
    v2 = va("e \"%s\"", (char)v3);
    result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000426D9) --------------------------------------------------------
int __cdecl Cmd_UFO_f(int a1)
{
  int result; // eax
  int v2; // eax
  const char *v3; // [esp+10h] [ebp-8h]

  result = CheatsOk(a1);
  if ( result )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8676) )
      v3 = "GAME_UFOOFF";
    else
      v3 = "GAME_UFOON";
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8676) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8676) == 0;
    v2 = va("e \"%s\"", (char)v3);
    result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
  }
  return result;
}
// 142A0: using guessed type _DWORD __cdecl CheatsOk(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004278D) --------------------------------------------------------
int __cdecl Cmd_Kill_f(_DWORD *a1)
{
  int result; // eax
  int v2; // edx

  result = a1[87];
  if ( !*(_DWORD *)(result + 8396) )
  {
    a1[97] &= 0xFFFFFFFE;
    v2 = a1[87];
    a1[142] = 0;
    *(_DWORD *)(v2 + 244) = 0;
    result = player_die(a1, a1, a1, 100000, 22, 0, 0, 0);
  }
  return result;
}
// 13E50: using guessed type _DWORD __cdecl player_die(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004282F) --------------------------------------------------------
int __cdecl StopFollowing(int a1)
{
  int result; // eax
  char v2[4]; // [esp+20h] [ebp-B8h] BYREF
  float v3; // [esp+24h] [ebp-B4h]
  float v4; // [esp+28h] [ebp-B0h]
  float v5; // [esp+2Ch] [ebp-ACh]
  int v6[4]; // [esp+50h] [ebp-88h] BYREF
  int v7[4]; // [esp+60h] [ebp-78h] BYREF
  float v8; // [esp+70h] [ebp-68h] BYREF
  float v9; // [esp+74h] [ebp-64h]
  float v10; // [esp+78h] [ebp-60h]
  float v11[4]; // [esp+80h] [ebp-58h] BYREF
  float v12[4]; // [esp+90h] [ebp-48h] BYREF
  float v13; // [esp+A0h] [ebp-38h] BYREF
  float v14; // [esp+A4h] [ebp-34h]
  float v15; // [esp+A8h] [ebp-30h]
  int v16[7]; // [esp+B0h] [ebp-28h] BYREF
  int v17; // [esp+CCh] [ebp-Ch]

  v17 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v17 + 8400) = -1;
  *(_DWORD *)(v17 + 8668) = -1;
  result = *(_DWORD *)(v17 + 12) & 0x10000;
  if ( result )
  {
    v16[0] = *(_DWORD *)(v17 + 192);
    v16[1] = *(_DWORD *)(v17 + 196);
    v16[2] = *(_DWORD *)(v17 + 200);
    AngleVectors(v16, v12, 0, v11);
    *(float *)v16 = *(float *)v16 + 15.0;
    v13 = *(float *)(v17 + 20);
    v14 = *(float *)(v17 + 24);
    v15 = *(float *)(v17 + 28);
    v15 = v15 + *(float *)(v17 + 208);
    G_AddLean(a1, &v13);
    v8 = v12[0] * -40.0 + v13;
    v9 = v12[1] * -40.0 + v14;
    v10 = v12[2] * -40.0 + v15;
    v8 = v11[0] * 10.0 + v8;
    v9 = v11[1] * 10.0 + v9;
    v10 = v11[2] * 10.0 + v10;
    v7[0] = -1056964608;
    v7[1] = -1056964608;
    v7[2] = -1056964608;
    v6[0] = 1090519040;
    v6[1] = 1090519040;
    v6[2] = 1090519040;
    trap_TraceCapsule(v2, &v13, v7, v6, &v8, 1023, 8454161);
    v13 = v3;
    v14 = v4;
    v15 = v5;
    *(_DWORD *)(v17 + 172) = -280575753 * ((a1 - (int)g_entities) >> 2);
    *(_DWORD *)(v17 + 128) &= 0xFFFF3FFF;
    *(_DWORD *)(v17 + 884) = 0;
    *(_DWORD *)(v17 + 888) = 1023;
    *(_DWORD *)(v17 + 896) = 0;
    *(_DWORD *)(v17 + 12) &= 0xFFFEFFDF;
    *(_DWORD *)(v17 + 184) = 0;
    G_SetOrigin(a1, &v13);
    *(float *)(v17 + 20) = v13;
    *(float *)(v17 + 24) = v14;
    *(float *)(v17 + 28) = v15;
    SetClientViewAngle(a1, v16);
    *(_DWORD *)(v17 + 988) = 0;
    *(_DWORD *)(v17 + 992) = 0;
    result = v17;
    *(_DWORD *)(v17 + 996) = 0;
  }
  return result;
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14630: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 14B90: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00042AEF) --------------------------------------------------------
int __cdecl Cmd_FollowCycle_f(int a1, int a2)
{
  char v4[96]; // [esp+20h] [ebp-2148h] BYREF
  char v5[8408]; // [esp+80h] [ebp-20E8h] BYREF
  int v6; // [esp+2158h] [ebp-10h]
  int v7; // [esp+215Ch] [ebp-Ch]

  if ( a2 != 1 && a2 != -1 )
    G_Error("Cmd_FollowCycle_f: bad dir %i", a2);
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) != 2 )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 348) + 8400) >= 0 )
    return 0;
  v7 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8668);
  if ( v7 < 0 )
    v7 = 0;
  v6 = v7;
  do
  {
    v7 += a2;
    if ( v7 >= level[120] )
      v7 = 0;
    if ( v7 < 0 )
      v7 = level[120] - 1;
    if ( trap_GetArchivedClientInfo(v7, *(_DWORD *)(a1 + 348) + 8408, v5, v4)
      && G_ClientCanSpectateTeam(*(_DWORD *)(a1 + 348), v4[4]) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8668) = v7;
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) = 2;
      return 1;
    }
  }
  while ( v7 != v6 );
  return 0;
}
// 13C80: using guessed type _DWORD __cdecl trap_GetArchivedClientInfo(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E70: using guessed type _DWORD __cdecl G_ClientCanSpectateTeam(_DWORD, char);

//----- (00042C70) --------------------------------------------------------
_BOOL4 __cdecl G_IsPlaying(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) == 0;
}

//----- (00042C8B) --------------------------------------------------------
void __cdecl sub_42C8B(int a1, int a2, int a3)
{
  int v3; // eax

  if ( a2
    && *(_BYTE *)(a2 + 356)
    && *(_DWORD *)(a2 + 348)
    && *(_DWORD *)(*(_DWORD *)(a2 + 348) + 8424) == 2
    && (a3 != 1 || OnSameTeam(a1, a2))
    && (a3 != 3 || InSameSquad(a1, a2))
    && (g_deadChat[3] || G_IsPlaying(a1) || !G_IsPlaying(a2)) )
  {
    if ( a3 == 1 )
      v3 = va(aS_9, (unsigned __int8)&aI[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      v3 = va(aS_9, (unsigned __int8)&asc_786AC[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 0, v3);
  }
}
// 13880: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);
// 13EA0: using guessed type _DWORD __cdecl InSameSquad(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14680: using guessed type _DWORD __cdecl G_IsPlaying(_DWORD);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00042DC9) --------------------------------------------------------
int __cdecl G_Say(int a1, int a2, int a3, char *src)
{
  char v4; // al
  char v5; // al
  char v6; // al
  int result; // eax
  char v8; // [esp+Ch] [ebp-23Ch]
  int v9; // [esp+40h] [ebp-208h]
  void *v10; // [esp+44h] [ebp-204h]
  char v11[64]; // [esp+50h] [ebp-1F8h] BYREF
  char v12[160]; // [esp+90h] [ebp-1B8h] BYREF
  char s[64]; // [esp+130h] [ebp-118h] BYREF
  char v14[128]; // [esp+170h] [ebp-D8h] BYREF
  char dest[68]; // [esp+1F0h] [ebp-58h] BYREF
  int v16; // [esp+234h] [ebp-14h]
  int v17; // [esp+238h] [ebp-10h]
  int i; // [esp+23Ch] [ebp-Ch]

  if ( a3 != 1 || *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 1 || *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 2 )
  {
    if ( a3 == 3 && *(_WORD *)(*(_DWORD *)(a1 + 348) + 8572) != 1 && *(_WORD *)(*(_DWORD *)(a1 + 348) + 8572) != 2 )
      a3 = 1;
  }
  else
  {
    a3 = 0;
  }
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 348) + 8636), 64);
  Q_CleanStr(dest);
  v9 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580);
  if ( v9 == 1 )
  {
    v10 = &unk_786C0;
  }
  else if ( v9 == 2 )
  {
    v10 = &unk_786BD;
  }
  else
  {
    v10 = &unk_786C3;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 3 )
  {
    Com_sprintf(s, 0x40u, byte_786C4, v8);
  }
  else if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) )
  {
    Com_sprintf(s, 0x40u, byte_786D8, (char)v10);
  }
  else
  {
    Com_sprintf(s, 0x40u, byte_786E9, (char)v10);
  }
  if ( a3 == 1 )
  {
    v5 = trap_GetGuid(*(_DWORD *)a1);
    G_LogPrintf("sayteam;%d;%d;%s;%s\n", v5);
    if ( Team_GetLocationMsg(a1, v11, 0x40u) )
      Com_sprintf(v14, 0x80u, aS_6, (char)s);
    else
      Com_sprintf(v14, 0x80u, aS_5, (char)s);
    v16 = 53;
  }
  else
  {
    if ( a3 <= 1 )
      goto LABEL_23;
    if ( a3 == 2 )
    {
      if ( a2
        && *(_DWORD *)(a2 + 348)
        && *(_DWORD *)(*(_DWORD *)(a2 + 348) + 8580) == *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580)
        && Team_GetLocationMsg(a1, v11, 0x40u) )
      {
        Com_sprintf(v14, 0x80u, "%s[%s]%s (%s): ", (char)s);
      }
      else
      {
        Com_sprintf(v14, 0x80u, "%s[%s]%s: ", (char)s);
      }
      v16 = 51;
      goto LABEL_39;
    }
    if ( a3 == 3 )
    {
      v6 = trap_GetGuid(*(_DWORD *)a1);
      G_LogPrintf("saysquad;%d;%d;%s;%s\n", v6);
      if ( Team_GetLocationMsg(a1, v11, 0x40u) )
        Com_sprintf(v14, 0x80u, aS_8, (char)s);
      else
        Com_sprintf(v14, 0x80u, aS_7, (char)s);
      v16 = 53;
    }
    else
    {
LABEL_23:
      v4 = trap_GetGuid(*(_DWORD *)a1);
      G_LogPrintf("say;%d;%d;%s;%s\n", v4);
      Com_sprintf(v14, 0x80u, "%s%s%s: ", (char)s);
      v16 = 55;
    }
  }
LABEL_39:
  Q_strncpyz(v12, src, 150);
  if ( a2 )
    return sub_42C8B(a1, a2, a3, v16, v14, v12);
  if ( g_dedicated[3] )
    G_Printf("%s%s\n", (char)v14);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[120] )
      break;
    v17 = (int)&g_entities + 796 * i;
    sub_42C8B(a1, v17, a3, v16, v14, v12);
  }
  return result;
}
// 42F1D: variable 'v8' is possibly undefined
// 13300: using guessed type _DWORD __cdecl trap_GetGuid(_DWORD);
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 42C8B: using guessed type _DWORD __cdecl sub_42C8B(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000434B7) --------------------------------------------------------
int __cdecl sub_434B7(int a1, int a2, int a3)
{
  int result; // eax
  char *src; // [esp+10h] [ebp-8h]

  result = trap_Argc();
  if ( result > 1 || a3 )
  {
    if ( a3 )
      src = (char *)ConcatArgs(0);
    else
      src = (char *)ConcatArgs(1);
    result = G_Say(a1, 0, a2, src);
  }
  return result;
}
// 144A0: using guessed type int trap_Argc(void);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (00043528) --------------------------------------------------------
char *__cdecl sub_43528(_DWORD *a1)
{
  char *result; // eax
  char v2; // al
  char v3[64]; // [esp+20h] [ebp-498h] BYREF
  char dest[64]; // [esp+60h] [ebp-458h] BYREF
  char nptr[1028]; // [esp+A0h] [ebp-418h] BYREF
  char *src; // [esp+4A4h] [ebp-14h]
  int v7; // [esp+4A8h] [ebp-10h]
  int v8; // [esp+4ACh] [ebp-Ch]

  result = (char *)trap_Argc();
  if ( (int)result > 1 )
  {
    trap_Argv(1, nptr, 1024);
    result = (char *)atoi(nptr);
    v8 = (int)result;
    if ( (int)result >= 0 )
    {
      result = (char *)v8;
      if ( v8 < level[120] )
      {
        result = (char *)&g_entities + 796 * v8;
        v7 = (int)result;
        if ( result )
        {
          result = (char *)v7;
          if ( *(_BYTE *)(v7 + 356) )
          {
            result = (char *)v7;
            if ( *(_DWORD *)(v7 + 348) )
            {
              src = (char *)ConcatArgs(2);
              Q_strncpyz(dest, (char *)(a1[87] + 8636), 64);
              Q_CleanStr(dest);
              Q_strncpyz(v3, (char *)(*(_DWORD *)(v7 + 348) + 8636), 64);
              Q_CleanStr(v3);
              trap_GetGuid(*(_DWORD *)v7);
              v2 = trap_GetGuid(*a1);
              G_LogPrintf("tell;%d;%d;%s;%d;%d;%s;%s\n", v2);
              G_Say((int)a1, v7, 2, src);
              result = (char *)G_Say((int)a1, (int)a1, 2, src);
            }
          }
        }
      }
    }
  }
  return result;
}
// 13300: using guessed type _DWORD __cdecl trap_GetGuid(_DWORD);
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (00043704) --------------------------------------------------------
void __cdecl sub_43704(int a1, int a2, int a3)
{
  int v3; // eax
  const char *v4; // [esp+2Ch] [ebp-Ch]

  if ( a2
    && *(_BYTE *)(a2 + 356)
    && *(_DWORD *)(a2 + 348)
    && *(_DWORD *)(*(_DWORD *)(a2 + 348) + 8424) == 2
    && (a3 != 1 || OnSameTeam(a1, a2)) )
  {
    if ( a3 == 1 )
    {
      v4 = "k";
    }
    else if ( a3 == 2 )
    {
      v4 = "l";
    }
    else
    {
      v4 = "j";
    }
    v3 = va("%s %d %d %d %s %i %i %i", (char)v4);
    trap_SendServerCommand(-280575753 * ((a2 - (int)&g_entities) >> 2), 0, v3);
  }
}
// 13880: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0004385B) --------------------------------------------------------
void __cdecl G_Voice(_DWORD *a1, int a2, int a3)
{
  int i; // [esp+28h] [ebp-10h]

  a1[196] -= level[122] - a1[197];
  a1[197] = level[122];
  if ( (int)a1[196] < 0 )
    a1[196] = 0;
  if ( (int)a1[196] <= 29999 )
  {
    if ( g_voiceChatsAllowed[3] )
    {
      a1[196] += 34000 / g_voiceChatsAllowed[3];
      if ( a2 )
      {
        sub_43704((int)a1, a2, a3);
      }
      else
      {
        if ( g_dedicated[3] )
          G_Printf("voice: %s %s\n", a1[87] - 68);
        for ( i = 0; i < level[120]; ++i )
          sub_43704((int)a1, (int)&g_entities[199 * i], a3);
      }
    }
  }
  else
  {
    trap_SendServerCommand(-280575753 * (a1 - g_entities), 0, &unk_78840);
  }
}
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00043A08) --------------------------------------------------------
int __cdecl sub_43A08(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // [esp+20h] [ebp-8h]

  result = trap_Argc();
  if ( result > 1 || a3 )
  {
    if ( a3 )
      v5 = ConcatArgs(0);
    else
      v5 = ConcatArgs(1);
    result = G_Voice(a1, 0, a2, v5, a4);
  }
  return result;
}
// 13D60: using guessed type _DWORD __cdecl G_Voice(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);

//----- (00043A80) --------------------------------------------------------
_DWORD *__cdecl Cmd_GameCommand_f(int a1)
{
  _DWORD *result; // eax
  char nptr[1032]; // [esp+10h] [ebp-418h] BYREF
  unsigned int v3; // [esp+418h] [ebp-10h]
  int v4; // [esp+41Ch] [ebp-Ch]

  trap_Argv(1, nptr, 1024);
  v4 = atoi(nptr);
  trap_Argv(2, nptr, 1024);
  result = (_DWORD *)atoi(nptr);
  v3 = (unsigned int)result;
  if ( v4 >= 0 && v4 <= 63 && (v3 & 0x80000000) == 0 && v3 <= 6 )
  {
    result = &g_entities[199 * v4 + 88];
    if ( LOBYTE(g_entities[199 * v4 + 89]) )
    {
      G_Say(a1, (int)&g_entities[199 * v4], 2, *(char **)((char *)off_82E50 + (_DWORD)&dword_0[v3]));
      result = (_DWORD *)G_Say(a1, a1, 2, *(char **)((char *)off_82E50 + (_DWORD)&dword_0[v3]));
    }
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 82E50: using guessed type char *off_82E50[7];

//----- (00043B9E) --------------------------------------------------------
int __cdecl Cmd_Where_f(int a1)
{
  char v1; // al
  int v2; // eax

  v1 = vtos(a1 + 312);
  v2 = va(aE_0, v1);
  return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
}
// 13CD0: using guessed type _DWORD __cdecl vtos(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00043C00) --------------------------------------------------------
int __cdecl Cmd_CallVote_f(int a1)
{
  int result; // eax
  int v2; // eax
  char v3; // al
  char v4; // al
  char v5; // al
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  char v12; // [esp+Ch] [ebp-5BCh]
  char v13; // [esp+Ch] [ebp-5BCh]
  int v14; // [esp+38h] [ebp-590h]
  int i; // [esp+3Ch] [ebp-58Ch]
  char v16[16]; // [esp+40h] [ebp-588h] BYREF
  int v17; // [esp+50h] [ebp-578h] BYREF
  char v18[268]; // [esp+150h] [ebp-478h] BYREF
  int v19; // [esp+25Ch] [ebp-36Ch]
  char v20[256]; // [esp+260h] [ebp-368h] BYREF
  char dest[64]; // [esp+360h] [ebp-268h] BYREF
  char nptr[256]; // [esp+3A0h] [ebp-228h] BYREF
  char s[268]; // [esp+4A0h] [ebp-128h] BYREF
  int j; // [esp+5ACh] [ebp-1Ch]

  v19 = 0;
  if ( !g_allowVote[3] )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTINGNOTENABLED\"");
  if ( level[710] )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTEALREADYINPROGRESS\"");
  if ( *(int *)(*(_DWORD *)(a1 + 348) + 8540) > 2 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_MAXVOTESCALLED\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 3 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_NOSPECTATORCALLVOTE\"");
  trap_Argv(1, s, 256);
  trap_Argv(2, nptr, 256);
  if ( strchr(s, 59) || strchr(nptr, 59) )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDVOTESTRING\"");
  if ( Q_stricmp(s, "map_restart") )
  {
    if ( Q_stricmp(s, "map_rotate") )
    {
      if ( Q_stricmp(s, "typemap") )
      {
        if ( Q_stricmp(s, "map") )
        {
          if ( Q_stricmp(s, "g_gametype") )
          {
            if ( Q_stricmp(s, "kick") )
            {
              if ( Q_stricmp(s, "clientkick") )
              {
                if ( Q_stricmp(s, "tempBanUser") )
                {
                  if ( Q_stricmp(s, "tempBanClient") )
                  {
                    if ( Q_stricmp(s, "drawfriend") )
                    {
                      if ( Q_stricmp(s, "killcam") )
                      {
                        if ( Q_stricmp(s, "friendlyfire") )
                        {
                          trap_SendServerCommand(
                            -280575753 * ((a1 - (int)g_entities) >> 2),
                            0,
                            "e \"GAME_INVALIDVOTESTRING\"");
                          return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, &unk_78A40);
                        }
                        v19 = g_allowVoteFriendlyFire[3];
                      }
                      else
                      {
                        v19 = g_allowVoteKillCam[3];
                      }
                    }
                    else
                    {
                      v19 = g_allowVoteDrawFriend[3];
                    }
                  }
                  else
                  {
                    v19 = g_allowVoteTempBanClient[3];
                  }
                }
                else
                {
                  v19 = g_allowVoteTempBanUser[3];
                }
              }
              else
              {
                v19 = g_allowVoteClientKick[3];
              }
            }
            else
            {
              v19 = g_allowVoteKick[3];
            }
          }
          else
          {
            v19 = g_allowVoteGameType[3];
          }
        }
        else
        {
          v19 = g_allowVoteMap[3];
        }
      }
      else
      {
        v19 = g_allowVoteTypeMap[3];
      }
    }
    else
    {
      v19 = g_allowVoteMapRotate[3];
    }
  }
  else
  {
    v19 = g_allowVoteMapRestart[3];
  }
  if ( !v19 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTINGNOTENABLED\"");
  if ( level[711] )
  {
    level[711] = 0;
    v2 = va((char *)&off_78B49, 56);
    trap_SendConsoleCommand(2, v2);
  }
  if ( !Q_stricmp(s, "typemap") )
  {
    if ( !Scr_IsValidGameType(nptr) )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDGAMETYPE\"");
    if ( !Q_stricmp(nptr, (char *)&g_gametype + 16) )
      nptr[0] = 0;
    trap_Argv(3, v18, 256);
    if ( !trap_MapExists(v18) )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, &unk_78B80);
    trap_Cvar_Register(v16, "mapname", &unk_786C3, 68);
    if ( !Q_stricmp(v18, &v17) )
      v18[0] = 0;
    if ( !nptr[0] && !v18[0] )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_TYPEMAP_NOCHANGE\"");
    if ( v18[0] )
    {
      if ( nptr[0] )
        Com_sprintf((char *)&level[198], 0x400u, "g_gametype %s; map %s", (char)nptr);
      else
        Com_sprintf((char *)&level[198], 0x400u, "map %s", (char)v18);
      if ( nptr[0] )
      {
        v3 = Scr_GetGameTypeNameForScript(nptr);
        Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety_0, v3);
      }
      else
      {
        Com_sprintf((char *)&level[454], 0x400u, aGameVoteMap, (char)v18);
      }
    }
    else
    {
      Com_sprintf((char *)&level[198], 0x400u, "g_gametype %s; map_restart", (char)nptr);
      v4 = Scr_GetGameTypeNameForScript(nptr);
      Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety, v4);
    }
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "g_gametype") )
  {
    if ( !Scr_IsValidGameType(nptr) )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_INVALIDGAMETYPE\"");
    Com_sprintf((char *)&level[198], 0x400u, "%s %s; map_restart", (char)s);
    v5 = Scr_GetGameTypeNameForScript(nptr);
    Com_sprintf((char *)&level[454], 0x400u, aGameVoteGamety, v5);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map_restart") )
  {
    Com_sprintf((char *)&level[198], 0x400u, "%s", (char)s);
    Com_sprintf((char *)&level[454], 0x400u, "GAME_VOTE_MAPRESTART", v12);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map_rotate") )
  {
    Com_sprintf((char *)&level[198], 0x400u, "%s", (char)s);
    Com_sprintf((char *)&level[454], 0x400u, "GAME_VOTE_NEXTMAP", v13);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "map") )
  {
    if ( !trap_MapExists(nptr) )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, &unk_78B80);
    Com_sprintf((char *)&level[198], 0x400u, "%s %s", (char)s);
    Com_sprintf((char *)&level[454], 0x400u, aGameVoteMap, (char)nptr);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "kick")
    || !Q_stricmp(s, "clientkick")
    || !Q_stricmp(s, "tempBanUser")
    || !Q_stricmp(s, "tempBanClient") )
  {
    v14 = 64;
    if ( Q_stricmp(s, "kick") && Q_stricmp(s, "tempBanUser") )
    {
      v14 = atoi(nptr);
      if ( (v14 || !Q_stricmp(nptr, "0")) && v14 >= 0 && v14 <= 63 && *(_DWORD *)(level[0] + 8908 * v14 + 8424) == 2 )
      {
        Q_strncpyz(dest, (char *)(level[0] + 8908 * v14 + 8636), 64);
        Q_CleanStr(dest);
      }
      else
      {
        v14 = 64;
      }
    }
    else
    {
      for ( i = 0; i <= 63; ++i )
      {
        if ( *(_DWORD *)(level[0] + 8908 * i + 8424) == 2 )
        {
          Q_strncpyz(dest, (char *)(level[0] + 8908 * i + 8636), 64);
          Q_CleanStr(dest);
          if ( !Q_stricmp(dest, nptr) )
            v14 = i;
        }
      }
    }
    if ( v14 == 64 )
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_CLIENTNOTONSERVER\"");
    if ( s[0] == 116 || s[0] == 84 )
      Com_sprintf(
        (char *)&level[198],
        0x400u,
        "%s \"%d\"",
        (unsigned __int8)&aTempbanclient[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      Com_sprintf(
        (char *)&level[198],
        0x400u,
        "%s \"%d\"",
        (unsigned __int8)&aClientkick[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    Com_sprintf((char *)&level[454], 0x400u, aGameVoteKick, v14);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "drawfriend") )
  {
    if ( !Q_stricmp(nptr, "0") && !Q_stricmp(nptr, &unk_78CEB) )
    {
      v6 = va(aEPatch15VoteAr, (char)nptr);
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v6);
    }
    trap_Cvar_VariableStringBuffer("scr_drawfriend", v20, 256);
    if ( !Q_stricmp(nptr, v20) )
      return trap_SendServerCommand(
               -280575753 * ((a1 - (int)g_entities) >> 2),
               0,
               "e \"PATCH_1_5_DRAWFRIEND_NOCHANGE\"");
    Com_sprintf((char *)&level[198], 0x400u, "setdrawfriend %s", (char)nptr);
    if ( nptr[0] == 49 )
      Com_sprintf(
        (char *)&level[454],
        0x400u,
        aPatch15VoteDra,
        (unsigned __int8)&aMenuOn[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    else
      Com_sprintf(
        (char *)&level[454],
        0x400u,
        aPatch15VoteDra,
        (unsigned __int8)&aMenuOff[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    goto LABEL_129;
  }
  if ( !Q_stricmp(s, "killcam") )
  {
    trap_Cvar_VariableStringBuffer("scr_killcam", v20, 256);
    if ( Q_stricmp(nptr, "0") || Q_stricmp(nptr, &unk_78CEB) )
    {
      if ( !Q_stricmp(nptr, v20) )
        return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_KILLCAM_NOCHANGE\"");
      Com_sprintf((char *)&level[198], 0x400u, "setkillcam %s", (char)nptr);
      if ( nptr[0] == 49 )
        Com_sprintf(
          (char *)&level[454],
          0x400u,
          aPatch15VoteKil,
          (unsigned __int8)&aMenuOn[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      else
        Com_sprintf(
          (char *)&level[454],
          0x400u,
          aPatch15VoteKil,
          (unsigned __int8)&aMenuOff[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      goto LABEL_129;
    }
LABEL_110:
    v7 = va(aEPatch15VoteAr, (char)nptr);
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v7);
  }
  result = Q_stricmp(s, "friendlyfire");
  if ( result )
    return result;
  trap_Cvar_VariableStringBuffer("scr_friendlyfire", v20, 256);
  if ( !Q_stricmp(nptr, v20) )
    return trap_SendServerCommand(
             -280575753 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_FRIENDLYFIRE_NOCHANGE\"");
  if ( Q_stricmp(nptr, "0") )
  {
    if ( Q_stricmp(nptr, &unk_78CEB) )
    {
      if ( Q_stricmp(nptr, &unk_78E7F) )
      {
        if ( Q_stricmp(nptr, "3") )
          goto LABEL_110;
        Com_sprintf(
          (char *)&level[454],
          0x400u,
          aPatch15VoteFri,
          (unsigned __int8)&aMenuShared[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      }
      else
      {
        Com_sprintf(
          (char *)&level[454],
          0x400u,
          aPatch15VoteFri,
          (unsigned __int8)&aMenuReflect[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      }
    }
    else
    {
      Com_sprintf(
        (char *)&level[454],
        0x400u,
        aPatch15VoteFri,
        (unsigned __int8)&aMenuOn[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    }
  }
  else
  {
    Com_sprintf(
      (char *)&level[454],
      0x400u,
      aPatch15VoteFri,
      (unsigned __int8)&aMenuOff[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  }
  Com_sprintf((char *)&level[198], 0x400u, "setfriendlyfire %s", (char)nptr);
LABEL_129:
  v8 = va(aEGameCalledavo, *(_DWORD *)(a1 + 348) - 68);
  trap_SendServerCommand(-1, 0, v8);
  level[710] = trap_Milliseconds() + 30000;
  level[712] = 1;
  level[713] = 0;
  for ( j = 0; j < level[120]; ++j )
    *(_DWORD *)(level[0] + 8908 * j + 128) &= 0xFFFDFFFF;
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 128) |= 0x20000u;
  v9 = va("%i", 48);
  trap_SetConfigstring(15, v9);
  trap_SetConfigstring(16, &level[454]);
  v10 = va("%i", level[712]);
  trap_SetConfigstring(17, v10);
  v11 = va("%i", level[713]);
  return trap_SetConfigstring(18, v11);
}
// 4453A: variable 'v12' is possibly undefined
// 445B1: variable 'v13' is possibly undefined
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 133F0: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 13930: using guessed type int trap_Milliseconds(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 147D0: using guessed type _DWORD __cdecl Scr_IsValidGameType(_DWORD);
// 14920: using guessed type _DWORD __cdecl trap_MapExists(_DWORD);
// 149C0: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 14D90: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14EA0: using guessed type _DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD);
// 78B49: using guessed type void *off_78B49;
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (000450AA) --------------------------------------------------------
_DWORD *__cdecl Cmd_Vote_f(int a1)
{
  _DWORD *result; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  _DWORD *v5; // [esp+18h] [ebp-50h]
  int v6; // [esp+1Ch] [ebp-4Ch]
  char v7; // [esp+20h] [ebp-48h] BYREF
  char v8; // [esp+21h] [ebp-47h]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8556) <= level[122] )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8556) = -1;
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8552) = -1;
    if ( level[710] )
    {
      if ( (*(_DWORD *)(*(_DWORD *)(a1 + 348) + 128) & 0x20000) != 0 )
      {
        result = (_DWORD *)trap_SendServerCommand(
                             -280575753 * ((a1 - (int)g_entities) >> 2),
                             0,
                             "e \"GAME_VOTEALREADYCAST\"");
      }
      else if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 3 )
      {
        result = (_DWORD *)trap_SendServerCommand(
                             -280575753 * ((a1 - (int)g_entities) >> 2),
                             0,
                             "e \"GAME_NOSPECTATORVOTE\"");
      }
      else
      {
        trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"GAME_VOTECAST\"");
        *(_DWORD *)(*(_DWORD *)(a1 + 348) + 128) |= 0x20000u;
        trap_Argv(1, &v7, 64);
        if ( v7 == 121 || v8 == 89 || v8 == 49 )
        {
          v3 = va("%i", ++level[712]);
          result = (_DWORD *)trap_SetConfigstring(17, v3);
        }
        else
        {
          v4 = va("%i", ++level[713]);
          result = (_DWORD *)trap_SetConfigstring(18, v4);
        }
      }
    }
    else
    {
      result = (_DWORD *)trap_SendServerCommand(
                           -280575753 * ((a1 - (int)g_entities) >> 2),
                           0,
                           "e \"GAME_NOVOTEINPROGRESS\"");
    }
  }
  else
  {
    result = (_DWORD *)g_entities[199 * *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8552) + 87];
    v5 = result;
    if ( result )
    {
      result = (_DWORD *)g_entities[199 * *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8552) + 87];
      if ( v5[2106] == 2 )
      {
        if ( v5[2119] )
        {
          result = (_DWORD *)trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, "m -3");
        }
        else
        {
          *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8556) = -1;
          *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8552) = -1;
          trap_Argv(1, &v7, 64);
          if ( v7 == 121 || v8 == 89 || v8 == 49 )
          {
            ++v5[2137];
            v6 = g_complaintlimit[3] - v5[2137];
            if ( v6 > 0 || v5[2119] )
            {
              v2 = va(aE_1, v6);
              trap_SendServerCommand(v5[43], 0, v2);
              result = (_DWORD *)trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, "m -1");
            }
            else
            {
              trap_DropClient(-559290757 * (((int)v5 - level[0]) >> 2), "GAME_KICKEDFROMCOMPLAINTS");
              result = (_DWORD *)trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, "m -1");
            }
          }
          else
          {
            result = (_DWORD *)trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 1, "m -2");
          }
        }
      }
    }
  }
  return result;
}
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 14280: using guessed type _DWORD __cdecl trap_DropClient(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000454D0) --------------------------------------------------------
int __cdecl Cmd_SetViewpos_f(int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  char v4; // [esp+4h] [ebp-444h]
  int i; // [esp+1Ch] [ebp-42Ch]
  char nptr[1024]; // [esp+20h] [ebp-428h] BYREF
  int v7; // [esp+420h] [ebp-28h] BYREF
  float v8; // [esp+424h] [ebp-24h]
  int v9; // [esp+428h] [ebp-20h]
  float v10[6]; // [esp+430h] [ebp-18h] BYREF

  if ( g_cheats[3] )
  {
    if ( trap_Argc() == 5 )
    {
      v9 = 0;
      v8 = 0.0;
      v7 = 0;
      for ( i = 0; i <= 2; ++i )
      {
        trap_Argv(i + 1, nptr, 1024);
        v10[i] = atof(nptr);
      }
      trap_Argv(4, nptr, 1024);
      v8 = atof(nptr);
      result = TeleportPlayer(a1, v10, &v7);
    }
    else
    {
      v3 = va(aEGameUsage, v4);
      result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v3);
    }
  }
  else
  {
    v1 = va("e \"GAME_CHEATSNOTENABLED\"", v4);
    result = trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v1);
  }
  return result;
}
// 454FB: variable 'v4' is possibly undefined
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 147B0: using guessed type _DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD);

//----- (0004562B) --------------------------------------------------------
int __cdecl Cmd_Activate_f(int a1)
{
  char s[56]; // [esp+20h] [ebp-48h] BYREF
  int v4; // [esp+58h] [ebp-10h]
  _DWORD *v5; // [esp+5Ch] [ebp-Ch]

  v4 = 1;
  if ( !Scr_IsSystemActive(1) )
    return 0;
  if ( !*(_BYTE *)(a1 + 374) )
  {
    G_CheckForCursorHints(a1);
    if ( *(_WORD *)(*(_DWORD *)(a1 + 348) + 952) == 1023 )
      return 0;
    v5 = &g_entities[199 * *(unsigned __int16 *)(*(_DWORD *)(a1 + 348) + 952)];
    if ( *((_WORD *)v5 + 190) )
    {
      if ( *((_WORD *)v5 + 190) == scr_const[26] || *((_WORD *)v5 + 190) == scr_const[27] )
      {
        G_TryDoor(v5, a1, a1);
      }
      else if ( *((_WORD *)v5 + 190) == scr_const[74] )
      {
        Scr_AddEntity(a1);
        Scr_Notify(v5, scr_const[73], 1);
        ((void (__cdecl *)(_DWORD *, int, int))v5[134])(v5, a1, a1);
      }
      else
      {
        if ( v5[1] == 3 )
        {
          memset(s, 0, 0x30u);
          Scr_AddEntity(a1);
          Scr_Notify(v5, scr_const[72], 1);
          if ( !v5[133] )
            return 0;
          *((_BYTE *)v5 + 374) = 1;
          ((void (__cdecl *)(_DWORD *, int, _DWORD))v5[133])(v5, a1, 0);
          return v4;
        }
        if ( v5[1] == 11 )
        {
          if ( !G_IsTurretUsable(v5, a1) )
            return 0;
        }
        else
        {
          if ( *((_WORD *)v5 + 190) == scr_const[38] && !*((_BYTE *)v5 + 374) )
          {
            if ( infront(v5, a1) )
              return 0;
            if ( *(_DWORD *)(level[0] + 8908 * *(_DWORD *)(a1 + 144) + 52) )
              return 0;
            *((_BYTE *)v5 + 374) = 1;
            *(_BYTE *)(a1 + 374) = 1;
            v5[84] = *(_DWORD *)a1;
            v5[165] = v5[81];
            v5[166] = v5[82];
            v5[167] = v5[83];
            return v4;
          }
          if ( *((_WORD *)v5 + 190) != scr_const[57] )
          {
            if ( *((_WORD *)v5 + 190) == scr_const[115] && v5[150] != *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) )
              ++v5[142];
            return v4;
          }
          Scr_AddEntity(a1);
          Scr_Notify(v5, scr_const[73], 1);
          if ( !v5[134] )
            return 0;
        }
        ((void (__cdecl *)(_DWORD *, int, int))v5[134])(v5, a1, a1);
      }
    }
    return v4;
  }
  if ( (*(_WORD *)(*(_DWORD *)(a1 + 348) + 128) & 0xC000) != 0 )
    *(_BYTE *)(a1 + 374) = 2;
  else
    *(_BYTE *)(a1 + 374) = 0;
  return 1;
}
// 13040: using guessed type _DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD);
// 137F0: using guessed type _DWORD __cdecl G_CheckForCursorHints(_DWORD);
// 13D80: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14B30: using guessed type _DWORD __cdecl infront(_DWORD, _DWORD);
// 14BE0: using guessed type _DWORD __cdecl G_TryDoor(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00045A50) --------------------------------------------------------
_DWORD *Cmd_EntityCount_f()
{
  _DWORD *result; // eax

  result = g_cheats;
  if ( g_cheats[3] )
    result = (_DWORD *)G_Printf("entity count = %i\n", level[3]);
  return result;
}

//----- (00045A91) --------------------------------------------------------
int __cdecl Cmd_MatchTimeout_f(int a1)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // [esp+18h] [ebp-50h]
  int v9; // [esp+1Ch] [ebp-4Ch]
  char dest[72]; // [esp+20h] [ebp-48h] BYREF

  if ( g_timeoutsAllowed[3] <= 0 || g_timeoutLength[3] <= 0 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEOUT_NOTENABLED\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) || *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 3 )
    return trap_SendServerCommand(
             -280575753 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_MUSTBEPLAYING\"");
  if ( level[1493] || level[1495] )
    return trap_SendServerCommand(
             -280575753 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_ALREADYINPROGRESS\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 2 )
  {
    if ( level[1491] >= g_timeoutsAllowed[3] )
    {
      v2 = va(aEPatch15Timeou_5, (unsigned __int8)&aGameAllies[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v2);
    }
    if ( (int)level[1489] <= 0 )
    {
      v3 = va(aEPatch15Timeou_6, (unsigned __int8)&aGameAllies[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v3);
    }
    ++level[1491];
    level[1496] = 2;
    Com_sprintf(
      (char *)&level[1233],
      0x400u,
      aPatch15Timeout,
      (unsigned __int8)&aGameAllies[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v9 = level[1489];
    if ( v9 > g_timeoutLength[3] )
      v9 = g_timeoutLength[3];
    level[1493] = v9;
  }
  else
  {
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) != 1 )
      return trap_SendServerCommand(
               -280575753 * ((a1 - (int)g_entities) >> 2),
               0,
               "e \"PATCH_1_5_TIMEOUT_INVALIDGAMETYPE\"");
    if ( level[1492] >= g_timeoutsAllowed[3] )
    {
      v4 = va(aEPatch15Timeou_5, (unsigned __int8)&aGameAxis[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v4);
    }
    if ( (int)level[1490] <= 0 )
    {
      v5 = va(aEPatch15Timeou_6, (unsigned __int8)&aGameAxis[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, v5);
    }
    ++level[1492];
    level[1496] = 1;
    Com_sprintf(
      (char *)&level[1233],
      0x400u,
      aPatch15Timeout,
      (unsigned __int8)&aGameAxis[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v8 = level[1490];
    if ( v8 > g_timeoutLength[3] )
      v8 = g_timeoutLength[3];
    level[1493] = v8;
  }
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 348) + 8636), 64);
  Q_CleanStr(dest);
  trap_Cvar_Set("timescale", "0");
  level[1494] = trap_Milliseconds();
  v6 = va("%i", level[1493]);
  trap_SetConfigstring(1628, v6);
  trap_SetConfigstring(1629, &level[1233]);
  v7 = va(aEPatch15Timeou_7, (char)dest);
  return trap_SendServerCommand(-1, 0, v7);
}
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13930: using guessed type int trap_Milliseconds(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00045F42) --------------------------------------------------------
int __cdecl Cmd_MatchTimein_f(int a1)
{
  int v2; // eax
  int v3; // eax
  char v4; // [esp+Ch] [ebp-5Ch]
  char dest[88]; // [esp+10h] [ebp-58h] BYREF

  if ( g_timeoutsAllowed[3] <= 0 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEOUT_NOTENABLED\"");
  if ( !level[1493] )
    return trap_SendServerCommand(
             -280575753 * ((a1 - (int)g_entities) >> 2),
             0,
             "e \"PATCH_1_5_TIMEOUT_NONEINPROGRESS\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) || *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == 3 )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEIN_MUSTBEPLAYING\"");
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) != level[1496] )
    return trap_SendServerCommand(-280575753 * ((a1 - (int)g_entities) >> 2), 0, "e \"PATCH_1_5_TIMEIN_WRONGTEAM\"");
  Com_sprintf((char *)&level[1233], 0x400u, aPatch15Timeout_0, v4);
  Q_strncpyz(dest, (char *)(*(_DWORD *)(a1 + 348) + 8636), 64);
  Q_CleanStr(dest);
  level[1489] -= trap_Milliseconds() - level[1494];
  level[1493] = 0;
  level[1495] = g_timeoutRecovery[3] + trap_Milliseconds();
  v2 = va("%i", g_timeoutRecovery[3]);
  trap_SetConfigstring(1628, v2);
  trap_SetConfigstring(1629, &level[1233]);
  v3 = va(aEPatch15Timein_1, (char)dest);
  return trap_SendServerCommand(-1, 0, v3);
}
// 460A1: variable 'v4' is possibly undefined
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 13930: using guessed type int trap_Milliseconds(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000461EC) --------------------------------------------------------
int __cdecl Cmd_MenuResponse_f(int a1)
{
  int v1; // esi
  int result; // eax
  char dest[1024]; // [esp+10h] [ebp-C18h] BYREF
  char v4[1024]; // [esp+410h] [ebp-818h] BYREF
  char nptr[1036]; // [esp+810h] [ebp-418h] BYREF
  int v6; // [esp+C1Ch] [ebp-Ch]

  v6 = -1;
  if ( trap_Argc() == 4 )
  {
    trap_Argv(1, nptr, 1024);
    v1 = atoi(nptr);
    result = trap_Cvar_VariableIntegerValue("sv_serverId");
    if ( v1 != result )
      return result;
    trap_Argv(2, v4, 1024);
    v6 = atoi(v4);
    if ( v6 >= 0 && v6 <= 31 )
      trap_GetConfigstring(v6 + 1180, v4, 1024);
    trap_Argv(3, dest, 1024);
  }
  else
  {
    v4[0] = 0;
    strcpy(dest, "bad");
  }
  Scr_AddString(dest);
  Scr_AddString(v4);
  return Scr_Notify(a1, scr_const[93], 2);
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 15620: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (00046341) --------------------------------------------------------
char *__cdecl ClientCommand(int a1)
{
  char *result; // eax
  int v2; // eax
  char v3[1036]; // [esp+10h] [ebp-418h] BYREF
  char *v4; // [esp+41Ch] [ebp-Ch]

  v4 = (char *)&g_entities[199 * a1];
  result = v4;
  if ( *((_DWORD *)v4 + 87) )
  {
    trap_Argv(0, v3, 1024);
    if ( Q_stricmp(v3, "say") )
    {
      if ( Q_stricmp(v3, "say_team") )
      {
        if ( Q_stricmp(v3, "say_squad") )
        {
          if ( Q_stricmp(v3, "vsay") )
          {
            if ( Q_stricmp(v3, "vsay_team") )
            {
              if ( Q_stricmp(v3, "tell") )
              {
                if ( Q_stricmp(v3, "score") )
                {
                  result = (char *)*((_DWORD *)v4 + 87);
                  if ( *((_DWORD *)result + 1) != 5 )
                  {
                    if ( Q_stricmp(v3, "mr") )
                    {
                      if ( Q_stricmp(v3, "give") )
                      {
                        if ( Q_stricmp(v3, "take") )
                        {
                          if ( Q_stricmp(v3, "god") )
                          {
                            if ( Q_stricmp(v3, "notarget") )
                            {
                              if ( Q_stricmp(v3, "noclip") )
                              {
                                if ( Q_stricmp(v3, "ufo") )
                                {
                                  if ( Q_stricmp(v3, "kill") )
                                  {
                                    if ( Q_stricmp(v3, "follownext") )
                                    {
                                      if ( Q_stricmp(v3, "followprev") )
                                      {
                                        if ( Q_stricmp(v3, "where") )
                                        {
                                          if ( Q_stricmp(v3, "callvote") )
                                          {
                                            if ( Q_stricmp(v3, "vote") )
                                            {
                                              if ( Q_stricmp(v3, "gc") )
                                              {
                                                if ( Q_stricmp(v3, "setviewpos") )
                                                {
                                                  if ( Q_stricmp(v3, "entitycount") )
                                                  {
                                                    if ( Q_stricmp(v3, "matchtimeout") )
                                                    {
                                                      if ( Q_stricmp(v3, "matchtimein") )
                                                      {
                                                        v2 = va(aEGameUnknowncl, (char)v3);
                                                        result = (char *)trap_SendServerCommand(a1, 0, v2);
                                                      }
                                                      else
                                                      {
                                                        result = (char *)Cmd_MatchTimein_f(v4);
                                                      }
                                                    }
                                                    else
                                                    {
                                                      result = (char *)Cmd_MatchTimeout_f(v4);
                                                    }
                                                  }
                                                  else
                                                  {
                                                    result = (char *)Cmd_EntityCount_f(v4);
                                                  }
                                                }
                                                else
                                                {
                                                  result = (char *)Cmd_SetViewpos_f(v4);
                                                }
                                              }
                                              else
                                              {
                                                result = (char *)Cmd_GameCommand_f(v4);
                                              }
                                            }
                                            else
                                            {
                                              result = (char *)Cmd_Vote_f(v4);
                                            }
                                          }
                                          else
                                          {
                                            result = (char *)Cmd_CallVote_f(v4);
                                          }
                                        }
                                        else
                                        {
                                          result = (char *)Cmd_Where_f(v4);
                                        }
                                      }
                                      else
                                      {
                                        result = (char *)Cmd_FollowCycle_f(v4, -1);
                                      }
                                    }
                                    else
                                    {
                                      result = (char *)Cmd_FollowCycle_f(v4, 1);
                                    }
                                  }
                                  else
                                  {
                                    result = (char *)Cmd_Kill_f(v4);
                                  }
                                }
                                else
                                {
                                  result = (char *)Cmd_UFO_f(v4);
                                }
                              }
                              else
                              {
                                result = (char *)Cmd_Noclip_f(v4);
                              }
                            }
                            else
                            {
                              result = (char *)Cmd_Notarget_f(v4);
                            }
                          }
                          else
                          {
                            result = (char *)Cmd_God_f(v4);
                          }
                        }
                        else
                        {
                          result = (char *)Cmd_Take_f(v4);
                        }
                      }
                      else
                      {
                        result = (char *)Cmd_Give_f(v4);
                      }
                    }
                    else
                    {
                      result = (char *)Cmd_MenuResponse_f(v4);
                    }
                  }
                }
                else
                {
                  result = (char *)Cmd_Score_f(v4);
                }
              }
              else
              {
                result = sub_43528(v4);
              }
            }
            else
            {
              result = (char *)sub_43A08((int)v4, 1, 0, 0);
            }
          }
          else
          {
            result = (char *)sub_43A08((int)v4, 0, 0, 0);
          }
        }
        else
        {
          result = (char *)sub_434B7((int)v4, 3, 0);
        }
      }
      else
      {
        result = (char *)sub_434B7((int)v4, 1, 0);
      }
    }
    else
    {
      result = (char *)sub_434B7((int)v4, 0, 0);
    }
  }
  return result;
}
// 130F0: using guessed type _DWORD __cdecl Cmd_MatchTimeout_f(_DWORD);
// 13160: using guessed type _DWORD __cdecl Cmd_Where_f(_DWORD);
// 13390: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);
// 135D0: using guessed type _DWORD __cdecl Cmd_FollowCycle_f(_DWORD, char);
// 137C0: using guessed type _DWORD __cdecl Cmd_GameCommand_f(_DWORD);
// 137D0: using guessed type _DWORD __cdecl Cmd_CallVote_f(_DWORD);
// 13900: using guessed type _DWORD __cdecl Cmd_UFO_f(_DWORD);
// 13AC0: using guessed type _DWORD __cdecl Cmd_God_f(_DWORD);
// 13BA0: using guessed type _DWORD __cdecl Cmd_Kill_f(_DWORD);
// 13E80: using guessed type _DWORD __cdecl Cmd_Give_f(_DWORD);
// 13EC0: using guessed type _DWORD __cdecl Cmd_MatchTimein_f(_DWORD);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 14030: using guessed type _DWORD __cdecl Cmd_SetViewpos_f(_DWORD);
// 14120: using guessed type _DWORD __cdecl Cmd_Noclip_f(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14600: using guessed type _DWORD __cdecl Cmd_Notarget_f(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15190: using guessed type _DWORD __cdecl Cmd_Take_f(_DWORD);
// 154E0: using guessed type _DWORD __cdecl Cmd_MenuResponse_f(_DWORD);
// 15850: using guessed type int __cdecl Cmd_EntityCount_f(_DWORD);
// 15A30: using guessed type _DWORD __cdecl Cmd_Vote_f(_DWORD);

//----- (0004689D) --------------------------------------------------------
void sub_4689D()
{
  ;
}

//----- (000468A4) --------------------------------------------------------
char *__cdecl sub_468A4(char *dest, char *src)
{
  return strcpy(dest, src);
}

//----- (000468CE) --------------------------------------------------------
int G_ParseHitLocDmgTable()
{
  int v0; // esi
  int result; // eax
  int v2[61]; // [esp+20h] [ebp-2118h] BYREF
  size_t n; // [esp+114h] [ebp-2024h]
  char *s; // [esp+118h] [ebp-2020h]
  char v5[4]; // [esp+11Ch] [ebp-201Ch]
  char s1[8196]; // [esp+120h] [ebp-2018h] BYREF
  int v7; // [esp+2124h] [ebp-14h] BYREF
  int v8; // [esp+2128h] [ebp-10h]
  int i; // [esp+212Ch] [ebp-Ch]

  *(_DWORD *)v5 = "info/mp_lochit_dmgtable";
  s = "LOCDMGTABLE";
  n = strlen("LOCDMGTABLE");
  for ( i = 0; i <= 18; ++i )
  {
    g_fHitLocDamageMult[i] = 1065353216;
    v2[3 * i] = *(int *)((char *)off_82EA0 + (_DWORD)&dword_0[i]);
    v2[3 * i + 1] = 4 * i;
    v2[3 * i + 2] = 6;
    v0 = i;
    *(__int16 *)((char *)&word_A5D80 + (_DWORD)dword_0 + 2 * v0) = Scr_AllocString(
                                                                     *(char **)((char *)off_82EA0 + (_DWORD)&dword_0[i]),
                                                                     1);
  }
  g_fHitLocDamageMult[18] = 0;
  v8 = trap_FS_FOpenFile(*(_DWORD *)v5, &v7, 0);
  if ( v8 <= 0 )
    return Com_Error(1, byte_794C0, v5[0]);
  trap_FS_Read(s1, n, v7);
  s1[n] = 0;
  if ( strncmp(s1, s, n) )
    return Com_Error(1, byte_79500, v5[0]);
  if ( (int)(v8 - n) > 0x1FFF )
    return Com_Error(1, byte_79540, v5[0]);
  trap_FS_Read(s1, v8 - n, v7);
  s1[v8 - n] = 0;
  trap_FS_FCloseFile(v7);
  if ( !Info_Validate(s1) )
    return Com_Error(1, byte_79580, v5[0]);
  result = ParseConfigStringToStruct((int)g_fHitLocDamageMult, (int)v2, 19, s1, 0, 0, (int)sub_468A4);
  if ( !result )
    result = G_Error("Error parsing hitloc damage table %s\n", v5[0]);
  return result;
}
// 0: using guessed type int dword_0[];
// 13450: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 13B90: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 155B0: using guessed type _DWORD __cdecl Scr_AllocString(_DWORD, _DWORD);
// 15960: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);
// 82EA0: using guessed type char *off_82EA0[19];
// A5D80: using guessed type __int16 word_A5D80;

//----- (00046BAB) --------------------------------------------------------
void AddScore()
{
  ;
}

//----- (00046BB0) --------------------------------------------------------
void __cdecl LookAtKiller(int a1, float *a2, float *a3)
{
  int v3; // esi
  float v4; // [esp+30h] [ebp-18h] BYREF
  float v5; // [esp+34h] [ebp-14h]
  float v6; // [esp+38h] [ebp-10h]

  if ( !a3 || a3 == (float *)a1 )
  {
    if ( !a2 || a2 == (float *)a1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 248) = (int)*(float *)(a1 + 328);
      return;
    }
    v4 = a2[78] - *(float *)(a1 + 312);
    v5 = a2[79] - *(float *)(a1 + 316);
    v6 = a2[80] - *(float *)(a1 + 320);
  }
  else
  {
    v4 = a3[78] - *(float *)(a1 + 312);
    v5 = a3[79] - *(float *)(a1 + 316);
    v6 = a3[80] - *(float *)(a1 + 320);
  }
  v3 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v3 + 248) = (int)vectoyaw(&v4);
  vectoyaw(&v4);
}
// 12F80: using guessed type long double __cdecl vectoyaw(_DWORD);

//----- (00046CE2) --------------------------------------------------------
int __cdecl G_IndexForMeansOfDeath(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 24; ++i )
  {
    if ( !Q_stricmp(a1, modNames[i]) )
      return i;
  }
  Com_Printf("Unknown means of death string '%s'\n", a1);
  return 0;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 82F00: using guessed type char *modNames[25];

//----- (00046D56) --------------------------------------------------------
int __cdecl player_die(int a1, int a2, _DWORD *a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax
  long double v9; // fst6
  long double v10; // fst6
  _DWORD *v11; // [esp+2Ch] [ebp-3Ch]
  _DWORD *v12; // [esp+2Ch] [ebp-3Ch]
  int v13[2]; // [esp+30h] [ebp-38h] BYREF
  float v14; // [esp+38h] [ebp-30h]
  float v15; // [esp+40h] [ebp-28h] BYREF
  float v16; // [esp+44h] [ebp-24h]
  float v17; // [esp+48h] [ebp-20h]
  int i; // [esp+5Ch] [ebp-Ch]

  result = *(_DWORD *)(a1 + 348);
  if ( *(int *)(result + 4) <= 5 )
  {
    if ( a3[1] == 11 && a3[84] != 1023 )
      a3 = &g_entities[199 * a3[84]];
    Scr_AddEntity(a3);
    Scr_Notify(a1, scr_const[14], 1);
    if ( a6 )
    {
      if ( a3[87] )
      {
        if ( (*(_WORD *)(a3[87] + 128) & 0xC000) != 0 )
        {
          v11 = &g_entities[199 * a3[29]];
          if ( v11[1] == 11 )
            a6 = v11[50];
        }
      }
    }
    *(_DWORD *)(a1 + 608) = a3;
    if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 52) )
    {
      v9 = (long double)rand() / 2147483600.0;
      v15 = v9 + v9 - 1.0;
      v10 = (long double)rand() / 2147483600.0;
      v16 = v10 + v10 - 1.0;
      v17 = (long double)rand() / 2147483600.0;
      v15 = v15 * 160.0;
      v16 = v16 * 160.0;
      v17 = v17 * 160.0;
      v13[0] = *(_DWORD *)(a1 + 312);
      v13[1] = *(_DWORD *)(a1 + 316);
      v14 = *(float *)(a1 + 320);
      v14 = v14 + 40.0;
      fire_grenade(a1, v13, &v15, *(_DWORD *)(a1 + 200));
    }
    BG_AnimScriptEvent(*(_DWORD *)(a1 + 348), 1, 0, 1);
    G_AddEvent(a1, 189, 0);
    Scr_PlayerKilled(a1, a2, a3, a4, a5, a6, a7, a8);
    for ( i = 0; i < level[120]; ++i )
    {
      v12 = (_DWORD *)(level[0] + 8908 * i);
      if ( v12[2106] == 2 && v12[2099] == 2 && v12[2167] == *(_DWORD *)a1 )
        Cmd_Score_f(&g_entities[199 * i]);
    }
    *(_BYTE *)(a1 + 373) = 1;
    *(_DWORD *)(a1 + 284) = 0x4000000;
    *(_DWORD *)(a1 + 332) = 0;
    LookAtKiller(a1, a2, a3);
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 192) = *(_DWORD *)(a1 + 324);
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 196) = *(_DWORD *)(a1 + 328);
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 200) = *(_DWORD *)(a1 + 332);
    *(_DWORD *)(a1 + 132) = 0;
    trap_UnlinkEntity(a1);
    *(_DWORD *)(a1 + 280) = 1106247680;
    trap_LinkEntity(a1);
    *(_DWORD *)(a1 + 568) = 0;
    *(_DWORD *)(a1 + 544) = 0;
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 13390: using guessed type _DWORD __cdecl Cmd_Score_f(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14250: using guessed type _DWORD __cdecl LookAtKiller(_DWORD, _DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14DC0: using guessed type _DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15430: using guessed type _DWORD __cdecl BG_AnimScriptEvent(_DWORD, _DWORD, _DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 15970: using guessed type _DWORD __cdecl Scr_PlayerKilled(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00047115) --------------------------------------------------------
_DWORD *__cdecl G_DamageClient(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  _DWORD *result; // eax
  int v10; // [esp+54h] [ebp+1Ch]

  result = (_DWORD *)a1;
  if ( *(_BYTE *)(a1 + 373) )
  {
    result = *(_DWORD **)(a1 + 348);
    if ( !result[2168] )
    {
      result = *(_DWORD **)(a1 + 348);
      if ( !result[2169] )
      {
        result = *(_DWORD **)(a1 + 348);
        if ( result[2106] == 2 )
        {
          v10 = (int)((long double)a6 * *(float *)&g_fHitLocDamageMult[a9]);
          if ( a2 )
          {
            result = (_DWORD *)Scr_PlayerDamage(a1, a2, a3, v10, a7, a8, *(_DWORD *)(a2 + 200), a5, a4, a9);
          }
          else if ( a3 )
          {
            result = (_DWORD *)Scr_PlayerDamage(a1, 0, a3, v10, a7, a8, *(_DWORD *)(a3 + 200), a5, a4, a9);
          }
          else
          {
            result = (_DWORD *)Scr_PlayerDamage(a1, 0, 0, v10, a7, a8, 0, a5, a4, a9);
          }
        }
      }
    }
  }
  return result;
}
// 135F0: using guessed type _DWORD __cdecl Scr_PlayerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00047221) --------------------------------------------------------
int __cdecl G_Damage(int a1, char *a2, char *a3, int a4, _DWORD *a5, int a6, int a7, int a8, int a9)
{
  int result; // eax
  int v10[6]; // [esp+30h] [ebp-18h] BYREF

  if ( *(_DWORD *)(a1 + 348) )
    return G_DamageClient(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  result = a1;
  if ( *(_BYTE *)(a1 + 373) )
  {
    if ( !a2 )
      a2 = (char *)&dword_C69C8 + (_DWORD)g_entities;
    if ( !a3 )
      a3 = (char *)&dword_C69C8 + (_DWORD)g_entities;
    if ( *(_DWORD *)(a1 + 4) == 5 )
    {
      result = a1;
      if ( *(_DWORD *)(a1 + 536) )
      {
        result = a1;
        if ( !*(_BYTE *)(a1 + 376) )
        {
          Scr_AddEntity(a3);
          Scr_Notify(a1, scr_const[73], 1);
          result = (*(int (__cdecl **)(int, char *, char *))(a1 + 536))(a1, a2, a3);
        }
      }
    }
    else
    {
      VectorNormalize2(a4, v10);
      result = *(_DWORD *)(a1 + 388) & 1;
      if ( !result )
      {
        if ( a6 <= 0 )
          a6 = 1;
        if ( g_debugDamage[3] )
          G_Printf("target:%i health:%i damage:%i\n", *(_DWORD *)a1);
        *(_DWORD *)(a1 + 568) -= a6;
        Scr_AddEntity(a3);
        Scr_AddInt(a6);
        Scr_Notify(a1, scr_const[13], 2);
        if ( *(int *)(a1 + 568) > 0 )
        {
          result = a1;
          if ( *(_DWORD *)(a1 + 540) )
          {
            if ( a4 )
            {
              *(_DWORD *)(a1 + 648) = v10[0];
              *(_DWORD *)(a1 + 652) = v10[1];
              *(_DWORD *)(a1 + 656) = v10[2];
              *(_DWORD *)(a1 + 452) = *a5;
              *(_DWORD *)(a1 + 456) = a5[1];
              *(_DWORD *)(a1 + 460) = a5[2];
            }
            else
            {
              *(_DWORD *)(a1 + 656) = 0;
              *(_DWORD *)(a1 + 652) = 0;
              *(_DWORD *)(a1 + 648) = 0;
              *(_DWORD *)(a1 + 460) = 0;
              *(_DWORD *)(a1 + 456) = 0;
              *(_DWORD *)(a1 + 452) = 0;
            }
            result = (*(int (__cdecl **)(int, char *, int, _DWORD *, int, int *, int))(a1 + 540))(
                       a1,
                       a3,
                       a6,
                       a5,
                       a8,
                       v10,
                       a9);
          }
        }
        else
        {
          if ( *(int *)(a1 + 568) < -999 )
            *(_DWORD *)(a1 + 568) = -999;
          Scr_AddEntity(a3);
          Scr_Notify(a1, scr_const[14], 1);
          *(_DWORD *)(a1 + 608) = a3;
          result = a1;
          if ( *(_DWORD *)(a1 + 544) )
            result = (*(int (__cdecl **)(int, char *, char *, int, int, _DWORD, int *, int))(a1 + 544))(
                       a1,
                       a2,
                       a3,
                       a6,
                       a8,
                       *((_DWORD *)a2 + 50),
                       v10,
                       a9);
        }
      }
    }
  }
  return result;
}
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14700: using guessed type _DWORD __cdecl G_DamageClient(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// C69C8: using guessed type int dword_C69C8;

//----- (000475AB) --------------------------------------------------------
long double __cdecl CanDamage(float *a1, float *a2)
{
  float v3; // [esp+34h] [ebp-D4h]
  int v4; // [esp+38h] [ebp-D0h]
  float v5; // [esp+3Ch] [ebp-CCh]
  float v6; // [esp+40h] [ebp-C8h] BYREF
  float v7; // [esp+44h] [ebp-C4h]
  float v8; // [esp+48h] [ebp-C0h]
  unsigned int v9; // [esp+50h] [ebp-B8h]
  float v10; // [esp+54h] [ebp-B4h]
  float v11; // [esp+58h] [ebp-B0h]
  float v12; // [esp+60h] [ebp-A8h] BYREF
  float v13; // [esp+64h] [ebp-A4h]
  float v14; // [esp+68h] [ebp-A0h]
  int i; // [esp+7Ch] [ebp-8Ch]
  float v16[12]; // [esp+80h] [ebp-88h] BYREF
  float v17; // [esp+B0h] [ebp-58h] BYREF
  float v18; // [esp+B4h] [ebp-54h]
  float v19; // [esp+B8h] [ebp-50h]
  float v20; // [esp+BCh] [ebp-4Ch]
  float v21; // [esp+C0h] [ebp-48h]
  float v22; // [esp+C4h] [ebp-44h]
  float v23; // [esp+C8h] [ebp-40h]
  float v24; // [esp+CCh] [ebp-3Ch]
  float v25; // [esp+D0h] [ebp-38h]
  float v26; // [esp+D4h] [ebp-34h]
  float v27; // [esp+D8h] [ebp-30h]
  float v28; // [esp+DCh] [ebp-2Ch]
  float v29; // [esp+E0h] [ebp-28h]
  float v30; // [esp+E4h] [ebp-24h]
  float v31; // [esp+E8h] [ebp-20h]
  float v32; // [esp+FCh] [ebp-Ch]

  v32 = 15.0;
  if ( *((_DWORD *)a1 + 87) )
  {
    v6 = a1[78];
    v7 = a1[79];
    v8 = a1[80];
    v8 = v8 + *(float *)(*((_DWORD *)a1 + 87) + 208);
    G_AddLean(a1, &v6);
    v5 = (v8 - a1[80]) * 0.5;
    v12 = *a2 - a1[78];
    v13 = a2[1] - a1[79];
    v14 = 0.0;
    VectorNormalize(&v12);
    v9 = LODWORD(v13) ^ 0x80000000;
    v10 = v12;
    v11 = v14;
    v17 = v6 + a1[78];
    v18 = v7 + a1[79];
    v19 = v8 + a1[80];
    v17 = v17 * 0.5;
    v18 = v18 * 0.5;
    v19 = v19 * 0.5;
    v20 = COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) * v32 + v17;
    v21 = v12 * v32 + v18;
    v22 = v14 * v32 + v19;
    v22 = v22 + v5;
    v23 = v20;
    v24 = v21;
    v25 = v14 * v32 + v19;
    v25 = v25 - v5;
    v26 = -v32 * COERCE_FLOAT(LODWORD(v13) ^ 0x80000000) + v17;
    v27 = -v32 * v12 + v18;
    v28 = -v32 * v14 + v19;
    v28 = v28 + v5;
    v29 = v26;
    v30 = v27;
    v31 = -v32 * v14 + v19;
    v31 = v31 - v5;
    v4 = 0;
    for ( i = 0; i <= 4; ++i )
    {
      trap_LocationalTrace(v16, &v17 + 3 * i, a2, *(_DWORD *)a1, 41951377, &bulletPriorityMap);
      if ( v16[0] == 1.0 )
        ++v4;
    }
    if ( v4 )
    {
      if ( v4 <= 3 )
        v3 = (long double)v4 / 3.0;
      else
        v3 = 1.0;
    }
    else
    {
      v3 = 0.0;
    }
  }
  else
  {
    v17 = a1[72] + a1[75];
    v18 = a1[73] + a1[76];
    v19 = a1[74] + a1[77];
    v17 = v17 * 0.5;
    v18 = v18 * 0.5;
    v19 = v19 * 0.5;
    v22 = v19;
    v20 = v17 + v32;
    v21 = v18 + v32;
    v25 = v19;
    v23 = v20;
    v24 = v18 - v32;
    v28 = v19;
    v26 = v17 - v32;
    v27 = v21;
    v31 = v19;
    v29 = v26;
    v30 = v24;
    for ( i = 0; i <= 4; ++i )
    {
      trap_LocationalTrace(v16, &v17 + 3 * i, a2, *(_DWORD *)a1, 41951377, &bulletPriorityMap);
      if ( v16[0] == 1.0 )
        return 1.0;
    }
    v3 = 0.0;
  }
  return v3;
}
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 14630: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);

//----- (00047B0C) --------------------------------------------------------
int __cdecl G_RadiusDamage(int a1, int a2, int a3, float a4, float a5, float a6, int a7, int a8)
{
  float v10; // [esp+40h] [ebp-10D8h]
  float v11; // [esp+40h] [ebp-10D8h]
  float v12; // [esp+44h] [ebp-10D4h]
  float v13; // [esp+44h] [ebp-10D4h]
  float v14; // [esp+48h] [ebp-10D0h]
  float v15; // [esp+48h] [ebp-10D0h]
  float v16[12]; // [esp+50h] [ebp-10C8h] BYREF
  float v17; // [esp+80h] [ebp-1098h] BYREF
  float v18; // [esp+84h] [ebp-1094h]
  float v19; // [esp+88h] [ebp-1090h]
  float v20; // [esp+90h] [ebp-1088h]
  int v21; // [esp+94h] [ebp-1084h]
  int j; // [esp+98h] [ebp-1080h]
  int i; // [esp+9Ch] [ebp-107Ch]
  float v24; // [esp+A0h] [ebp-1078h] BYREF
  float v25; // [esp+A4h] [ebp-1074h]
  float v26; // [esp+A8h] [ebp-1070h]
  float v27; // [esp+B0h] [ebp-1068h]
  float v28; // [esp+B4h] [ebp-1064h]
  float v29; // [esp+B8h] [ebp-1060h]
  float v30[4]; // [esp+C0h] [ebp-1058h] BYREF
  float v31[7]; // [esp+D0h] [ebp-1048h] BYREF
  int v32; // [esp+ECh] [ebp-102Ch]
  int v33[1024]; // [esp+F0h] [ebp-1028h] BYREF
  float *v34; // [esp+10F0h] [ebp-28h]
  float v35; // [esp+10F4h] [ebp-24h]
  float v36; // [esp+10F8h] [ebp-20h]
  float v37; // [esp+10FCh] [ebp-1Ch]

  v21 = 0;
  if ( !a3 )
    return 0;
  if ( a6 < 1.0 )
    a6 = 1.0;
  v20 = a6 * 1.4142135;
  for ( i = 0; i <= 2; ++i )
  {
    v31[i] = *(float *)(a1 + 4 * i) - v20;
    v30[i] = *(float *)(a1 + 4 * i) + v20;
  }
  v32 = trap_EntitiesInBox(v31, v30, v33, 1024, -1);
  for ( j = 0; j < v32; ++j )
  {
    v34 = (float *)&g_entities[199 * v33[j]];
    if ( v34 != (float *)a7 && *((_BYTE *)v34 + 373) )
    {
      if ( *((_DWORD *)v34 + 64) )
      {
        for ( i = 0; i <= 2; ++i )
        {
          if ( v34[i + 72] <= (long double)*(float *)(a1 + 4 * i) )
          {
            if ( *(float *)(a1 + 4 * i) <= (long double)v34[i + 75] )
              *(&v27 + i) = 0.0;
            else
              *(&v27 + i) = *(float *)(a1 + 4 * i) - v34[i + 75];
          }
          else
          {
            *(&v27 + i) = v34[i + 72] - *(float *)(a1 + 4 * i);
          }
        }
      }
      else
      {
        v27 = v34[78] - *(float *)a1;
        v28 = v34[79] - *(float *)(a1 + 4);
        v29 = v34[80] - *(float *)(a1 + 8);
      }
      v36 = sqrt(v27 * v27 + v28 * v28 + v29 * v29);
      if ( v36 < (long double)a6 && (!*((_DWORD *)v34 + 87) || !level[2950]) )
      {
        v37 = (a4 - a5) * (1.0 - v36 / a6) + a5;
        v35 = CanDamage(v34, a1);
        if ( v35 <= 0.0 )
        {
          v10 = v34[72] + v34[75];
          v12 = v34[73] + v34[76];
          v14 = v34[74] + v34[77];
          v11 = v10 * 0.5;
          v13 = v12 * 0.5;
          v15 = v14 * 0.5;
          v17 = v11;
          v18 = v13;
          v19 = v15;
          trap_Trace(v16, a1, vec3_origin, vec3_origin, &v17, 1023, 17);
          if ( v16[0] < 1.0 )
          {
            v17 = v17 - *(float *)a1;
            v18 = v18 - *(float *)(a1 + 4);
            v19 = v19 - *(float *)(a1 + 8);
            v36 = sqrt(v17 * v17 + v18 * v18 + v19 * v19);
            if ( a6 * 0.2 > v36 )
            {
              if ( LogAccuracyHit(v34, a3) )
                v21 = 1;
              v24 = v34[78] - *(float *)a1;
              v25 = v34[79] - *(float *)(a1 + 4);
              v26 = v34[80] - *(float *)(a1 + 8);
              v26 = v26 + 24.0;
              G_Damage(v34, a2, a3, &v24, a1, (int)(v37 * 0.1), 1, a8, 0);
            }
          }
        }
        else
        {
          if ( LogAccuracyHit(v34, a3) )
            v21 = 1;
          v24 = v34[78] - *(float *)a1;
          v25 = v34[79] - *(float *)(a1 + 4);
          v26 = v34[80] - *(float *)(a1 + 8);
          v26 = v26 + 24.0;
          G_Damage(v34, a2, a3, &v24, a1, (int)(v37 * v35), 1, a8, 0);
        }
      }
    }
  }
  return v21;
}
// 130D0: using guessed type _DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD);
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 148D0: using guessed type double __cdecl CanDamage(_DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000481EA) --------------------------------------------------------
int __cdecl G_GetHitLocationString(int a1)
{
  return *(unsigned __int16 *)((char *)&word_A5D80 + (_DWORD)dword_0 + 2 * a1);
}
// 0: using guessed type int dword_0[];
// A5D80: using guessed type __int16 word_A5D80;

//----- (00048207) --------------------------------------------------------
int __cdecl G_GetHitLocationIndexFromString(__int16 a1)
{
  int i; // [esp+4h] [ebp-Ch]

  for ( i = 0; i <= 18; ++i )
  {
    if ( *(__int16 *)((char *)&word_A5D80 + (_DWORD)dword_0 + 2 * i) == a1 )
      return i;
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// A5D80: using guessed type __int16 word_A5D80;

//----- (0004825F) --------------------------------------------------------
void sub_4825F()
{
  ;
}

//----- (00048264) --------------------------------------------------------
int __cdecl G_DebugLine(int a1, int a2, int a3, int a4, int a5)
{
  return trap_AddDebugLine(a1, a2, a3, a4, a5);
}
// 14E50: using guessed type _DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000482A3) --------------------------------------------------------
int *__cdecl G_DebugBox(int a1, int a2, int a3, int a4, int a5)
{
  int *result; // eax
  float v6; // [esp+28h] [ebp-80h]
  float v7[26]; // [esp+30h] [ebp-78h] BYREF
  int i; // [esp+98h] [ebp-10h]
  int v9[3]; // [esp+9Ch] [ebp-Ch] BYREF

  for ( v9[0] = 0; v9[0] <= 7; ++v9[0] )
  {
    for ( i = 0; i <= 2; ++i )
    {
      if ( ((v9[0] >> i) & 1) != 0 )
        v6 = *(float *)(a2 + 4 * i);
      else
        v6 = *(float *)(a1 + 4 * i);
      v7[3 * v9[0] + i] = v6;
    }
    result = v9;
  }
  for ( v9[0] = 0; v9[0] <= 0xBu; ++v9[0] )
  {
    G_DebugLine(
      &v7[3 * *(int *)((char *)&dword_79800 + (_DWORD)&dword_0[2 * v9[0]])],
      &v7[3 * *(int *)((char *)&dword_79804 + (_DWORD)&dword_0[2 * v9[0]])],
      a3,
      a4,
      a5);
    result = v9;
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 14C20: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 79800: using guessed type int dword_79800;
// 79804: using guessed type int dword_79804;

//----- (000483A9) --------------------------------------------------------
int __cdecl G_DebugCircle(int a1, float a2, int a3, int a4, int a5, int a6)
{
  float v7; // [esp+24h] [ebp-24h]
  float v8; // [esp+28h] [ebp-20h]
  int v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  if ( a5 )
  {
    *(float *)&v9 = 0.0;
    v10 = 0.0;
    v11 = 1.0;
  }
  else
  {
    v7 = *(float *)(level[0] + 24);
    v8 = *(float *)(level[0] + 28) + *(float *)(level[0] + 208);
    *(float *)&v9 = *(float *)a1 - *(float *)(level[0] + 20);
    v10 = *(float *)(a1 + 4) - v7;
    v11 = *(float *)(a1 + 8) - v8;
  }
  return G_DebugCircleEx(a1, a2, (int)&v9, a3, a4, a6);
}

//----- (00048471) --------------------------------------------------------
unsigned int *__cdecl G_DebugCircleEx(int a1, float a2, int a3, int a4, int a5, int a6)
{
  unsigned int *result; // eax
  float v7; // [esp+2Ch] [ebp-10Ch] BYREF
  float v8[2]; // [esp+30h] [ebp-108h] BYREF
  float v9; // [esp+38h] [ebp-100h]
  unsigned int i; // [esp+3Ch] [ebp-FCh] BYREF
  float v11[4]; // [esp+40h] [ebp-F8h] BYREF
  float v12[4]; // [esp+50h] [ebp-E8h] BYREF
  char v13[216]; // [esp+60h] [ebp-D8h] BYREF

  VectorNormalize2(a3, v13);
  PerpendicularVector(v12, v13);
  result = (unsigned int *)CrossProduct(v13, v12, v11);
  for ( i = 0; i <= 0xF; ++i )
  {
    v9 = (long double)(int)i * 0.3926990816987241;
    sub_488F8(v9, v8, &v7);
    v8[0] = v8[0] * a2;
    v7 = v7 * a2;
    *(float *)&v13[12 * i + 16] = v11[0] * v8[0] + *(float *)a1;
    *(float *)&v13[12 * i + 20] = v11[1] * v8[0] + *(float *)(a1 + 4);
    *(float *)&v13[12 * i + 24] = v11[2] * v8[0] + *(float *)(a1 + 8);
    *(float *)&v13[12 * i + 16] = v12[0] * v7 + *(float *)&v13[12 * i + 16];
    *(float *)&v13[12 * i + 20] = v12[1] * v7 + *(float *)&v13[12 * i + 20];
    *(float *)&v13[12 * i + 24] = v12[2] * v7 + *(float *)&v13[12 * i + 24];
    result = &i;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    G_DebugLine(&v13[12 * i + 16], &v13[12 * (((_BYTE)i + 1) & 0xF) + 16], a4, a5, a6);
    result = &i;
  }
  return result;
}
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 14C20: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 159E0: using guessed type _DWORD __cdecl PerpendicularVector(_DWORD, _DWORD);

//----- (00048731) --------------------------------------------------------
void __cdecl G_DebugArc(int a1, float a2, float a3, float a4, int a5, int a6, int a7)
{
  float v7; // [esp+28h] [ebp-E0h] BYREF
  float v8[2]; // [esp+2Ch] [ebp-DCh] BYREF
  float v9; // [esp+34h] [ebp-D4h]
  float v10; // [esp+38h] [ebp-D0h]
  unsigned int i; // [esp+3Ch] [ebp-CCh]
  _DWORD v12[50]; // [esp+40h] [ebp-C8h] BYREF

  v10 = (a4 - a3) / 15.0;
  if ( v10 < 0.0 )
  {
    a3 = a3 - 360.0;
    v10 = (a4 - a3) / 15.0;
  }
  for ( i = 0; i <= 0xF; ++i )
  {
    v9 = ((long double)(int)i * v10 + a3) * 3.141592653589793 / 180.0;
    sub_488F8(v9, v8, &v7);
    *(float *)&v12[3 * i] = v7 * a2 + *(float *)a1;
    *(float *)&v12[3 * i + 1] = v8[0] * a2 + *(float *)(a1 + 4);
    v12[3 * i + 2] = *(_DWORD *)(a1 + 8);
  }
  for ( i = 0; i <= 0xE; ++i )
    G_DebugLine(&v12[3 * i], &v12[3 * i + 3], a5, a6, a7);
}
// 14C20: using guessed type _DWORD __cdecl G_DebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (000488F8) --------------------------------------------------------
float *__cdecl sub_488F8(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (00048910) --------------------------------------------------------
void sub_48910()
{
  ;
}

//----- (00048914) --------------------------------------------------------
_DWORD *__cdecl sub_48914(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[15] = 0;
  a1[16] = 0;
  a1[17] = 0;
  a1[18] = 0;
  a1[23] = 0;
  a1[24] = 0;
  a1[25] = 0;
  result = a1;
  a1[26] = 0;
  return result;
}

//----- (00048987) --------------------------------------------------------
_DWORD *__cdecl sub_48987(_DWORD *a1)
{
  *a1 = 1;
  a1[1] = 0;
  a1[2] = 0;
  a1[3] = 1065353216;
  a1[4] = 0;
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = -1;
  a1[8] = 0;
  a1[9] = 0;
  a1[10] = 0;
  a1[11] = 0;
  a1[27] = 0;
  a1[30] = 1;
  return sub_48914(a1);
}

//----- (00048A25) --------------------------------------------------------
char *__cdecl HudElem_Alloc(int a1, int a2)
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( !g_hudelems[31 * i] )
    {
      sub_48987(&g_hudelems[31 * i]);
      g_hudelems[31 * i + 28] = a1;
      g_hudelems[31 * i + 29] = a2;
      return (char *)&g_hudelems[31 * i];
    }
  }
  return 0;
}

//----- (00048AF9) --------------------------------------------------------
_DWORD *__cdecl HudElem_Free(_DWORD *a1)
{
  _DWORD *result; // eax

  Scr_FreeHudElem(a1);
  result = a1;
  *a1 = 0;
  return result;
}
// 138B0: using guessed type _DWORD __cdecl Scr_FreeHudElem(_DWORD);

//----- (00048B25) --------------------------------------------------------
unsigned int *__cdecl HudElem_ClientDisconnect(_DWORD *a1)
{
  unsigned int *result; // eax
  unsigned int i; // [esp+10h] [ebp-8h] BYREF

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( g_hudelems[31 * i] )
    {
      if ( g_hudelems[31 * i + 28] == *a1 )
        HudElem_Free(&g_hudelems[31 * i]);
    }
    result = &i;
  }
  return result;
}
// 15490: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (00048BB3) --------------------------------------------------------
void *HudElem_DestroyAll()
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 0x3FF; ++i )
  {
    if ( g_hudelems[31 * i] )
      HudElem_Free(&g_hudelems[31 * i]);
  }
  return memset(g_hudelems, 0, sizeof(g_hudelems));
}
// 15490: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (00048C3E) --------------------------------------------------------
int __cdecl sub_48C3E(int a1, _DWORD *a2, int a3, int a4)
{
  int result; // eax
  const char *v5; // eax
  char s[2056]; // [esp+10h] [ebp-818h] BYREF
  int v7; // [esp+818h] [ebp-10h]
  int i; // [esp+81Ch] [ebp-Ch]

  v7 = Scr_GetString(0);
  for ( i = 0; i < a4; ++i )
  {
    if ( !Q_stricmp(v7, *(_DWORD *)(a3 + 4 * i)) )
    {
      result = i;
      *(_DWORD *)(a2[1] + a1) = i;
      return result;
    }
  }
  sprintf(s, "\"%s\" is not a valid value for hudelem field \"%s\"\nShould be one of:", v7, *a2);
  for ( i = 0; i < a4; ++i )
  {
    v5 = (const char *)va(" %s", *(_DWORD *)(a3 + 4 * i));
    strncat(s, v5, 0x800u);
    s[2047] = 0;
  }
  return Scr_Error(s);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00048D49) --------------------------------------------------------
int __cdecl sub_48D49(int a1, int a2, int a3)
{
  return Scr_AddString(*(_DWORD *)(a3 + 4 * *(_DWORD *)(a1 + *(_DWORD *)(a2 + 4))));
}
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (00048D87) --------------------------------------------------------
int *__cdecl sub_48D87(int a1, int a2)
{
  int v2; // edx
  int *result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]

  s2 = (char *)Scr_GetIString(0);
  v2 = G_LocalizedStringIndex(s2);
  result = (int *)((char *)*(&off_82F80 + 5 * a2 + 1) + a1);
  *result = v2;
  return result;
}
// 13240: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// 82F80: using guessed type void *off_82F80;

//----- (00048DE2) --------------------------------------------------------
int __cdecl sub_48DE2(int a1, int a2)
{
  int result; // eax

  result = Scr_GetBool(0);
  *(_DWORD *)((char *)*(&off_82F80 + 5 * a2 + 1) + a1) = result;
  return result;
}
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 82F80: using guessed type void *off_82F80;

//----- (00048E35) --------------------------------------------------------
int __cdecl sub_48E35(_BYTE *a1)
{
  char v1; // al
  char v2; // al
  int result; // eax
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+20h] [ebp-28h]
  float v6; // [esp+28h] [ebp-20h]
  float v7; // [esp+30h] [ebp-18h] BYREF
  float v8; // [esp+34h] [ebp-14h]
  float v9; // [esp+38h] [ebp-10h]

  Scr_GetVector(0, &v7);
  if ( v7 <= 1.0 && v7 < 0.0 )
  {
    v1 = sub_4A2BA(0.0);
  }
  else if ( v7 <= 1.0 )
  {
    v6 = v7 * 255.0;
    v1 = sub_4A2BA(v6);
  }
  else
  {
    v1 = sub_4A2BA(255.0);
  }
  a1[28] = v1;
  if ( v8 <= 1.0 && v8 < 0.0 )
  {
    v2 = sub_4A2BA(0.0);
  }
  else if ( v8 <= 1.0 )
  {
    v5 = v8 * 255.0;
    v2 = sub_4A2BA(v5);
  }
  else
  {
    v2 = sub_4A2BA(255.0);
  }
  a1[29] = v2;
  if ( v9 <= 1.0 && v9 < 0.0 )
  {
    v4 = 0.0;
  }
  else if ( v9 <= 1.0 )
  {
    v4 = v9 * 255.0;
  }
  else
  {
    v4 = 255.0;
  }
  result = sub_4A2BA(v4);
  a1[30] = result;
  return result;
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (00048FB3) --------------------------------------------------------
int __cdecl sub_48FB3(unsigned __int8 *a1)
{
  float v2[6]; // [esp+10h] [ebp-18h] BYREF

  v2[0] = (long double)a1[28] * 0.0039215689;
  v2[1] = (long double)a1[29] * 0.0039215689;
  v2[2] = (long double)a1[30] * 0.0039215689;
  return Scr_AddVector(v2);
}
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (00049024) --------------------------------------------------------
int __cdecl sub_49024(int a1)
{
  int result; // eax
  float v2; // [esp+8h] [ebp-10h]
  float v3; // [esp+10h] [ebp-8h]

  v3 = Scr_GetFloat(0);
  if ( v3 <= 1.0 && v3 < 0.0 )
  {
    v2 = 0.0;
  }
  else if ( v3 <= 1.0 )
  {
    v2 = v3 * 255.0;
  }
  else
  {
    v2 = 255.0;
  }
  result = sub_4A2BA(v2);
  *(_BYTE *)(a1 + 31) = result;
  return result;
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (000490BC) --------------------------------------------------------
int __cdecl sub_490BC(int a1)
{
  float v2; // [esp+0h] [ebp-8h]

  v2 = (long double)*(unsigned __int8 *)(a1 + 31) * 0.0039215689;
  return Scr_AddFloat(LODWORD(v2));
}
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (000490F3) --------------------------------------------------------
int __cdecl sub_490F3(int a1)
{
  int v1; // eax
  int result; // eax
  double v3; // [esp+4h] [ebp-14h]
  float v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetFloat(0);
  if ( v4 <= 0.0 )
  {
    v3 = v4;
    v1 = va("font scale was %g; should be > 0", SLOBYTE(v3));
    Scr_Error(v1);
  }
  result = LODWORD(v4);
  *(float *)(a1 + 12) = v4;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00049152) --------------------------------------------------------
int __cdecl sub_49152(int a1, int a2)
{
  return sub_48C3E(a1, &off_82F80 + 5 * a2, (int)off_830F0, 3);
}
// 82F80: using guessed type void *off_82F80;
// 830F0: using guessed type char *off_830F0[6];

//----- (000491A4) --------------------------------------------------------
int __cdecl sub_491A4(int a1, int a2)
{
  return sub_48D49(a1, (int)(&off_82F80 + 5 * a2), (int)off_830F0);
}
// 82F80: using guessed type void *off_82F80;
// 830F0: using guessed type char *off_830F0[6];

//----- (000491F6) --------------------------------------------------------
int __cdecl sub_491F6(int a1, int a2)
{
  return sub_48C3E(a1, &off_82F80 + 5 * a2, (int)off_830FC, 3);
}
// 82F80: using guessed type void *off_82F80;
// 830FC: using guessed type char *off_830FC[3];

//----- (00049248) --------------------------------------------------------
int __cdecl sub_49248(int a1, int a2)
{
  return sub_48D49(a1, (int)(&off_82F80 + 5 * a2), (int)off_830FC);
}
// 82F80: using guessed type void *off_82F80;
// 830FC: using guessed type char *off_830FC[3];

//----- (0004929A) --------------------------------------------------------
int __cdecl sub_4929A(int a1, int a2)
{
  return sub_48C3E(a1, &off_82F80 + 5 * a2, (int)&off_83108, 3);
}
// 82F80: using guessed type void *off_82F80;
// 83108: using guessed type void *off_83108;

//----- (000492EC) --------------------------------------------------------
int __cdecl sub_492EC(int a1, int a2)
{
  return sub_48D49(a1, (int)(&off_82F80 + 5 * a2), (int)&off_83108);
}
// 82F80: using guessed type void *off_82F80;
// 83108: using guessed type void *off_83108;

//----- (0004933E) --------------------------------------------------------
int __cdecl Scr_GetHudElemField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  void **v4; // [esp+10h] [ebp-8h]

  v4 = &off_82F80 + 5 * a2;
  v3 = &g_hudelems[31 * a1];
  if ( v4[4] )
    result = ((int (__cdecl *)(_DWORD *, int))v4[4])(v3, a2);
  else
    result = Scr_GetGenericField(v3, v4[2], v4[1]);
  return result;
}
// 14B40: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// 82F80: using guessed type void *off_82F80;

//----- (000493CD) --------------------------------------------------------
int __cdecl Scr_SetHudElemField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  void **v4; // [esp+10h] [ebp-8h]

  v4 = &off_82F80 + 5 * a2;
  v3 = &g_hudelems[31 * a1];
  if ( v4[3] )
    result = ((int (__cdecl *)(_DWORD *, int))v4[3])(v3, a2);
  else
    result = Scr_SetGenericField(v3, v4[2], v4[1]);
  return result;
}
// 14CF0: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// 82F80: using guessed type void *off_82F80;

//----- (0004945C) --------------------------------------------------------
void **__cdecl Scr_FreeHudElemConstStrings(int a1)
{
  void **result; // eax
  void **i; // [esp+10h] [ebp-8h]

  for ( i = &off_82F80; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    if ( i[2] == (char *)dword_0 + 3 )
      Scr_SetString((char *)i[1] + a1, 0);
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 82F80: using guessed type void *off_82F80;

//----- (000494B1) --------------------------------------------------------
int GScr_NewHudElem()
{
  int v1; // [esp+10h] [ebp-8h]

  v1 = HudElem_Alloc(1023, 0);
  if ( !v1 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143B0: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 152C0: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);

//----- (000494FF) --------------------------------------------------------
int GScr_NewClientHudElem()
{
  _DWORD *v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v1 = (_DWORD *)Scr_GetEntity(0);
  if ( !v1[87] )
    Scr_ParamError(0, "not a client");
  v2 = HudElem_Alloc(*v1, 0);
  if ( !v2 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v2);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143B0: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 152C0: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);

//----- (0004957F) --------------------------------------------------------
int GScr_NewTeamHudElem()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  __int16 v4; // [esp+Eh] [ebp-Ah]
  int v5; // [esp+10h] [ebp-8h]

  v4 = Scr_GetConstString(0);
  if ( v4 == scr_const[2] )
  {
    v0 = HudElem_Alloc(1023, 2);
  }
  else if ( v4 == scr_const[4] )
  {
    v0 = HudElem_Alloc(1023, 1);
  }
  else if ( v4 == scr_const[62] )
  {
    v0 = HudElem_Alloc(1023, 3);
  }
  else
  {
    v1 = Scr_GetString(0);
    v2 = va("team \"%s\" should be \"allies\", \"axis\", or \"spectator\"", v1);
    Scr_ParamError(0, v2);
    v0 = HudElem_Alloc(1023, 0);
  }
  v5 = v0;
  if ( !v0 )
    Scr_Error("out of hudelems");
  return Scr_AddHudElem(v5);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143B0: using guessed type _DWORD __cdecl HudElem_Alloc(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152C0: using guessed type _DWORD __cdecl Scr_AddHudElem(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0004965C) --------------------------------------------------------
void **GScr_AddFieldsForHudElems()
{
  void **result; // eax
  unsigned int v1; // [esp+18h] [ebp-10h]
  unsigned __int16 v2; // [esp+1Eh] [ebp-Ah]
  void **i; // [esp+20h] [ebp-8h]

  v2 = g_scr_data[214];
  for ( i = &off_82F80; ; i += 5 )
  {
    result = i;
    if ( !*i )
      break;
    v1 = (unsigned int)i[2];
    if ( v1 <= 5 || v1 - 7 <= 1 )
      Scr_AddClassField(
        v2,
        *i,
        (unsigned __int16)(-13107 * (((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_82F80 - 140134))) >> 2)));
  }
  return result;
}
// 147A0: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// 82F80: using guessed type void *off_82F80;
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (000496EA) --------------------------------------------------------
int __cdecl sub_496EA(int a1)
{
  int result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]

  s2 = (char *)Scr_GetIString(0);
  sub_48914(&g_hudelems[31 * a1]);
  g_hudelems[31 * a1] = 1;
  result = G_LocalizedStringIndex(s2);
  g_hudelems[31 * a1 + 26] = result;
  return result;
}
// 13240: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);

//----- (00049773) --------------------------------------------------------
int __cdecl sub_49773(int a1)
{
  char *v1; // eax
  int v2; // eax
  int v3; // eax
  int result; // eax
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]
  int v8; // [esp+1Ch] [ebp-Ch]
  _DWORD *v9; // [esp+20h] [ebp-8h]

  v8 = Scr_GetNumParam();
  if ( v8 != 1 && v8 != 3 )
    Scr_Error("USAGE: <hudelem> setShader(\"shadername\"[, optional_width, optional_height]);");
  v9 = &g_hudelems[31 * a1];
  v1 = (char *)Scr_GetString(0);
  v5 = G_ShaderIndex(v1);
  if ( v8 == 1 )
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v7 = Scr_GetInt(1);
    if ( v7 < 0 )
    {
      v2 = va("width %i < 0", v7);
      Scr_ParamError(1, v2);
    }
    v6 = Scr_GetInt(2);
    if ( v6 < 0 )
    {
      v3 = va("height %i < 0", v6);
      Scr_ParamError(2, v3);
    }
  }
  sub_48914(v9);
  *v9 = 3;
  v9[14] = v5;
  v9[12] = v7;
  result = v6;
  v9[13] = v6;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00049899) --------------------------------------------------------
int __cdecl sub_49899(int a1, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int result; // eax
  float v6; // [esp+0h] [ebp-18h]
  double v7; // [esp+4h] [ebp-14h]
  int v8; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]

  if ( Scr_GetNumParam() != 1 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds);\n", a3);
    Scr_Error(v3);
  }
  v9 = &g_hudelems[31 * a1];
  v6 = Scr_GetFloat(0) * 1000.0;
  v8 = sub_4A2F8(v6);
  if ( v8 <= 0 && a2 != 5 )
  {
    v7 = (long double)v8 * 0.001;
    v4 = va("time %g should be > 0", SLOBYTE(v7));
    Scr_ParamError(0, v4);
  }
  sub_48914(v9);
  *v9 = a2;
  result = level[122] + v8;
  v9[23] = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00049974) --------------------------------------------------------
int __cdecl sub_49974(int a1, int a2, char a3)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  char *v6; // eax
  int v7; // eax
  int v8; // eax
  int result; // eax
  float v10; // [esp+0h] [ebp-38h]
  float v11; // [esp+0h] [ebp-38h]
  double v12; // [esp+4h] [ebp-34h]
  double v13; // [esp+4h] [ebp-34h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+1Ch] [ebp-1Ch]
  int v16; // [esp+20h] [ebp-18h]
  int v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  int v19; // [esp+2Ch] [ebp-Ch]
  _DWORD *v20; // [esp+30h] [ebp-8h]

  v19 = Scr_GetNumParam();
  if ( v19 != 3 && v19 != 5 )
  {
    v3 = va("USAGE: <hudelem> %s(time_in_seconds, total_clock_time_in_seconds, shadername[, width, height]);\n", a3);
    Scr_Error(v3);
  }
  v20 = &g_hudelems[31 * a1];
  v10 = Scr_GetFloat(0) * 1000.0;
  v18 = sub_4A2F8(v10);
  if ( v18 <= 0 && a2 != 9 )
  {
    v12 = (long double)v18 * 0.001;
    v4 = va("time %g should be > 0", SLOBYTE(v12));
    Scr_ParamError(0, v4);
  }
  v11 = Scr_GetFloat(1) * 1000.0;
  v17 = sub_4A2F8(v11);
  if ( v17 <= 0 )
  {
    v13 = (long double)v17 * 0.001;
    v5 = va("duration %g should be > 0", SLOBYTE(v13));
    Scr_ParamError(1, v5);
  }
  v6 = (char *)Scr_GetString(2);
  v16 = G_ShaderIndex(v6);
  if ( v19 == 3 )
  {
    v15 = 0;
    v14 = 0;
  }
  else
  {
    v15 = Scr_GetInt(3);
    if ( v15 < 0 )
    {
      v7 = va("width %i < 0", v15);
      Scr_ParamError(3, v7);
    }
    v14 = Scr_GetInt(4);
    if ( v14 < 0 )
    {
      v8 = va("height %i < 0", v14);
      Scr_ParamError(4, v8);
    }
  }
  sub_48914(v20);
  *v20 = a2;
  v20[23] = level[122] + v18;
  v20[24] = v17;
  v20[14] = v16;
  v20[12] = v15;
  result = v14;
  v20[13] = v14;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00049B70) --------------------------------------------------------
int __cdecl sub_49B70(int a1)
{
  return sub_49899(a1, 4, (char)"setTimer");
}

//----- (00049BA5) --------------------------------------------------------
int __cdecl sub_49BA5(int a1)
{
  return sub_49899(a1, 5, (char)"setTimerUp");
}

//----- (00049BDA) --------------------------------------------------------
int __cdecl sub_49BDA(int a1)
{
  return sub_49899(a1, 6, (char)"setTenthsTimer");
}

//----- (00049C0F) --------------------------------------------------------
int __cdecl sub_49C0F(int a1)
{
  return sub_49899(a1, 7, (char)"setTenthsTimerUp");
}

//----- (00049C44) --------------------------------------------------------
int __cdecl sub_49C44(int a1)
{
  return sub_49974(a1, 8, (char)"setClock");
}

//----- (00049C79) --------------------------------------------------------
int __cdecl sub_49C79(int a1)
{
  return sub_49974(a1, 9, (char)"setClockUp");
}

//----- (00049CAE) --------------------------------------------------------
int __cdecl sub_49CAE(int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetFloat(0);
  sub_48914(&g_hudelems[31 * a1]);
  g_hudelems[31 * a1] = 2;
  result = LODWORD(v2);
  *(float *)&g_hudelems[31 * a1 + 25] = v2;
  return result;
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00049D2D) --------------------------------------------------------
int __cdecl sub_49D2D(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = &g_hudelems[31 * a1];
  v7 = Scr_GetFloat(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v6 = v7;
      v2 = va("fade time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v7;
    v1 = va("fade time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8[9] = level[122];
  v4 = v7 * 1000.0;
  v8[10] = sub_4A2BA(v4);
  result = v8[7];
  v8[8] = result;
  return result;
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (00049E1B) --------------------------------------------------------
int __cdecl sub_49E1B(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+10h] [ebp-18h]
  int v8; // [esp+14h] [ebp-14h]
  float v9; // [esp+18h] [ebp-10h]
  _DWORD *v10; // [esp+1Ch] [ebp-Ch]

  v10 = &g_hudelems[31 * a1];
  if ( Scr_GetNumParam() != 3 )
    Scr_Error("hudelem scaleOverTime(time_in_seconds, new_width, new_height)");
  v9 = Scr_GetFloat(0);
  if ( v9 > 0.0 )
  {
    if ( v9 > 60.0 )
    {
      v6 = v9;
      v2 = va("scale time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v9;
    v1 = va("scale time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8 = Scr_GetInt(1);
  v7 = Scr_GetInt(2);
  v10[17] = level[122];
  v4 = v9 * 1000.0;
  v10[18] = sub_4A2BA(v4);
  v10[15] = v10[12];
  v10[16] = v10[13];
  v10[12] = v8;
  result = v7;
  v10[13] = v7;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00049F5D) --------------------------------------------------------
int __cdecl sub_49F5D(int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  float v4; // [esp+0h] [ebp-28h]
  double v5; // [esp+4h] [ebp-24h]
  double v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = &g_hudelems[31 * a1];
  v7 = Scr_GetFloat(0);
  if ( v7 > 0.0 )
  {
    if ( v7 > 60.0 )
    {
      v6 = v7;
      v2 = va("move time %g > 60", SLOBYTE(v6));
      Scr_ParamError(0, v2);
    }
  }
  else
  {
    v5 = v7;
    v1 = va("move time %g <= 0", SLOBYTE(v5));
    Scr_ParamError(0, v1);
  }
  v8[21] = level[122];
  v4 = v7 * 1000.0;
  v8[22] = sub_4A2BA(v4);
  v8[19] = v8[1];
  result = v8[2];
  v8[20] = result;
  return result;
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);

//----- (0004A057) --------------------------------------------------------
_DWORD *__cdecl sub_4A057(int a1)
{
  return sub_48987(&g_hudelems[31 * a1]);
}

//----- (0004A090) --------------------------------------------------------
int __cdecl sub_4A090(int a1)
{
  return HudElem_Free(&g_hudelems[31 * a1]);
}
// 15490: using guessed type _DWORD __cdecl HudElem_Free(_DWORD);

//----- (0004A0C9) --------------------------------------------------------
int __cdecl HudElem_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0xD; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_83080 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_83080 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_83084 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 83080: using guessed type char *off_83080;
// 83084: using guessed type int (__cdecl *off_83084)(int);

//----- (0004A144) --------------------------------------------------------
_DWORD *__cdecl HudElem_UpdateClient(_DWORD *a1, int a2, char a3)
{
  _DWORD *result; // eax
  _DWORD *v4; // [esp+18h] [ebp-20h] BYREF
  _DWORD *v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  unsigned int v8; // [esp+28h] [ebp-10h]

  if ( (a3 & 1) != 0 )
    memset(a1 + 1230, 0, 0xD90u);
  if ( (a3 & 2) != 0 )
    memset(a1 + 362, 0, 0xD90u);
  v7 = 0;
  v6 = 0;
  result = g_hudelems;
  v4 = g_hudelems;
  v8 = 0;
  while ( v8 <= 0x3FF )
  {
    if ( *v4 && (!v4[29] || v4[29] == a1[2145]) && (v4[28] == 1023 || v4[28] == a2) )
    {
      if ( v4[30] )
      {
        if ( (a3 & 1) != 0 )
        {
          v5 = &a1[28 * v7++ + 1230];
          if ( v7 <= 31 )
            goto LABEL_18;
        }
      }
      else if ( (a3 & 2) != 0 )
      {
        v5 = &a1[28 * v6++ + 362];
        if ( v6 <= 31 )
        {
LABEL_18:
          qmemcpy(v5, v4, 0x70u);
          goto LABEL_19;
        }
      }
    }
LABEL_19:
    ++v8;
    result = &v4;
    v4 += 31;
  }
  return result;
}

//----- (0004A2BA) --------------------------------------------------------
int __cdecl sub_4A2BA(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (0004A2F8) --------------------------------------------------------
int __cdecl sub_4A2F8(float a1)
{
  return (int)ceil(a1);
}

//----- (0004A336) --------------------------------------------------------
void sub_4A336()
{
  ;
}

//----- (0004A33C) --------------------------------------------------------
int __cdecl Fill_Clip(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+8h] [ebp-20h]
  int v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+18h] [ebp-10h]

  v4 = BG_AmmoForWeapon(a2);
  result = BG_ClipForWeapon(a2);
  v3 = result;
  if ( a2 > 0 )
  {
    result = BG_GetNumWeapons();
    if ( a2 <= result )
    {
      v6 = *(_DWORD *)(a1 + 4 * v3 + 524);
      v5 = BG_GetAmmoClipSize(v3) - v6;
      result = v5;
      if ( v5 > *(_DWORD *)(a1 + 4 * v4 + 268) )
      {
        result = *(_DWORD *)(a1 + 4 * v4 + 268);
        v5 = result;
      }
      if ( v5 )
      {
        *(_DWORD *)(a1 + 4 * v4 + 268) -= v5;
        result = *(_DWORD *)(a1 + 4 * v3 + 524) + v5;
        *(_DWORD *)(a1 + 4 * v3 + 524) = result;
      }
    }
  }
  return result;
}
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);

//----- (0004A419) --------------------------------------------------------
int __cdecl Add_Ammo(int a1, int a2, int a3, int a4)
{
  int v4; // edi
  int v5; // edi
  int v6; // edi
  int v7; // edi
  int v10; // [esp+18h] [ebp-20h]
  int v11; // [esp+1Ch] [ebp-1Ch]
  int v12; // [esp+20h] [ebp-18h]
  int v13; // [esp+24h] [ebp-14h]
  int v14; // [esp+28h] [ebp-10h]
  int v15; // [esp+48h] [ebp+10h]

  v14 = BG_AmmoForWeapon(a2);
  v13 = BG_ClipForWeapon(a2);
  v12 = 0;
  v11 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268);
  v10 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524);
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) = v11 + a3;
  if ( BG_WeaponIsClipOnly(a2) )
  {
    BG_GivePlayerWeapon(*(_DWORD *)(a1 + 348), a2);
    v12 = 1;
  }
  if ( a4 || v12 )
    Fill_Clip(*(_DWORD *)(a1 + 348), a2);
  if ( v12 )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) = 0;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 348);
    if ( *(_DWORD *)(v4 + 4 * v14 + 268) > BG_GetAmmoTypeMax(v14) )
    {
      v5 = *(_DWORD *)(a1 + 348);
      *(_DWORD *)(v5 + 4 * v14 + 268) = BG_GetAmmoTypeMax(v14);
    }
  }
  v6 = *(_DWORD *)(a1 + 348);
  if ( *(_DWORD *)(v6 + 4 * v13 + 524) > BG_GetAmmoClipSize(v13) )
  {
    v7 = *(_DWORD *)(a1 + 348);
    *(_DWORD *)(v7 + 4 * v13 + 524) = BG_GetAmmoClipSize(v13);
  }
  if ( *(int *)(BG_GetInfoForWeapon(a2) + 440) < 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268)
         - v11;
  v15 = BG_GetMaxPickupableAmmo(*(_DWORD *)(a1 + 348), a2);
  if ( v15 >= 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268)
         - v11;
  if ( !BG_WeaponIsClipOnly(a2) )
  {
    *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) += v15;
    if ( *(int *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) < 0 )
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268) = 0;
    return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268)
         - v11;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524) += v15;
  if ( *(int *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524) > 0 )
    return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524)
         - v10
         + *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v14 + 268)
         - v11;
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v13 + 524) = 0;
  BG_TakePlayerWeapon(*(_DWORD *)(a1 + 348), a2);
  return 0;
}
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 144D0: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 15630: using guessed type _DWORD __cdecl Fill_Clip(_DWORD, _DWORD);
// 15640: using guessed type _DWORD __cdecl BG_GetMaxPickupableAmmo(_DWORD, _DWORD);

//----- (0004A6F6) --------------------------------------------------------
int __cdecl sub_4A6F6(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax

  if ( *(_DWORD *)(a1 + 600) )
    v2 = Add_Ammo(a2, *(_DWORD *)(*(_DWORD *)(a1 + 672) + 36), *(_DWORD *)(a1 + 600), 0);
  else
    v2 = Add_Ammo(a2, *(_DWORD *)(*(_DWORD *)(a1 + 672) + 36), *(_DWORD *)(*(_DWORD *)(a1 + 672) + 28), 0);
  if ( !v2 )
    return 0;
  if ( BG_WeaponIsClipOnly(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36)) )
  {
    v3 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36));
    v4 = va(aFGamePickupCli, *(_DWORD *)(v3 + 8));
  }
  else
  {
    v5 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36));
    v4 = va(aFGamePickupAmm, *(_DWORD *)(v5 + 8));
  }
  trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 0, v4);
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[73], 1);
  return 40;
}
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0004A86B) --------------------------------------------------------
int __cdecl sub_4A86B(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // esi
  int v21; // eax
  float v23; // [esp+0h] [ebp-78h]
  char v24; // [esp+4h] [ebp-74h]
  char v25; // [esp+4h] [ebp-74h]
  int v26; // [esp+20h] [ebp-58h]
  float v27; // [esp+28h] [ebp-50h]
  int v28; // [esp+2Ch] [ebp-4Ch]
  int v29[5]; // [esp+30h] [ebp-48h] BYREF
  int v30; // [esp+44h] [ebp-34h]
  int v31; // [esp+48h] [ebp-30h]
  int i; // [esp+4Ch] [ebp-2Ch]
  int v33; // [esp+50h] [ebp-28h]
  _DWORD *v34; // [esp+54h] [ebp-24h]
  int v35; // [esp+58h] [ebp-20h]
  int v36; // [esp+5Ch] [ebp-1Ch]
  char v37[4]; // [esp+60h] [ebp-18h]
  int v38; // [esp+64h] [ebp-14h]
  int v39; // [esp+68h] [ebp-10h]
  int v40; // [esp+6Ch] [ebp-Ch]

  v38 = 0;
  v35 = 0;
  *(_DWORD *)v37 = *(_DWORD *)(a1[168] + 36);
  v34 = (_DWORD *)BG_GetInfoForWeapon(*(_DWORD *)v37);
  if ( (int)a1[150] >= 0 )
  {
    if ( !a1[150] )
    {
      i = v34[196];
      v33 = v34[195];
      if ( i < v33 )
      {
        i = v33;
        v33 = v34[196];
      }
      if ( i || v33 )
      {
        if ( i >= 0 )
        {
          if ( i == v33 )
            v26 = v33;
          else
            v26 = rand() % (i - v33) + v33;
          a1[150] = v26;
          if ( (int)a1[150] <= 0 )
            a1[150] = 0;
        }
        else
        {
          a1[150] = 0;
        }
      }
      else
      {
        v27 = ((long double)rand() / 2147483600.0 + 1.0) * 0.5;
        v4 = BG_ClipForWeapon(*(_DWORD *)v37);
        v23 = (long double)(BG_GetAmmoClipSize(v4) - 1) * v27;
        a1[150] = sub_4D844(v23) + 1;
      }
    }
    v5 = BG_AmmoForWeapon(*(_DWORD *)v37);
    if ( a1[150] > BG_GetAmmoTypeMax(v5) )
    {
      v6 = BG_AmmoForWeapon(*(_DWORD *)v37);
      a1[150] = BG_GetAmmoTypeMax(v6);
    }
    v40 = a1[150];
  }
  else
  {
    v40 = 0;
  }
  if ( (int)a1[181] >= 0 )
  {
    if ( !a1[181] )
    {
      if ( (int)a1[150] >= 0 )
      {
        v7 = BG_ClipForWeapon(*(_DWORD *)v37);
        a1[181] = BG_GetAmmoClipSize(v7);
        if ( a1[181] > a1[150] )
          a1[181] = a1[150];
        a1[150] -= a1[181];
        v40 = a1[150];
      }
      else
      {
        a1[181] = 0;
      }
    }
    v8 = BG_ClipForWeapon(*(_DWORD *)v37);
    if ( a1[181] > BG_GetAmmoClipSize(v8) )
    {
      v9 = BG_ClipForWeapon(*(_DWORD *)v37);
      a1[181] = BG_GetAmmoClipSize(v9);
    }
    v39 = a1[181];
  }
  else
  {
    v39 = 0;
  }
  v38 = Com_BitCheck(*(_DWORD *)(a2 + 348) + 780, *(_DWORD *)v37);
  if ( !v38 )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a2 + 348) + 176) )
    {
      if ( !Com_BitCheck(*(_DWORD *)(a2 + 348) + 780, *(_DWORD *)(*(_DWORD *)(a2 + 348) + 176)) )
        return 0;
      if ( !BG_IsPlayerWeaponInSlot(*(_DWORD *)(a2 + 348), *(_DWORD *)(*(_DWORD *)(a2 + 348) + 176), 1) )
      {
        v10 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 348) + 176));
        if ( !BG_GetStackSlotForWeapon(
                *(_DWORD *)(a2 + 348),
                *(_DWORD *)(*(_DWORD *)(a2 + 348) + 176),
                *(_DWORD *)(v10 + 120))
          && !BG_GetEmptySlotForWeapon(*(_DWORD *)(a2 + 348), *(_DWORD *)v37) )
        {
          Com_Printf(
            "WARNING: cannot swap out a debug weapon (can result from too many weapons given to the player)\n",
            v24);
          return 0;
        }
      }
    }
    if ( !BG_GetEmptySlotForWeapon(*(_DWORD *)(a2 + 348), *(_DWORD *)v37) )
    {
      v11 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 348) + 176));
      if ( !BG_GetStackSlotForWeapon(*(_DWORD *)(a2 + 348), *(_DWORD *)v37, *(_DWORD *)(v11 + 120)) )
      {
        if ( v34[30] == *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a2 + 348) + 176)) + 120) )
        {
          v35 = Drop_Weapon(a2, *(_DWORD *)(*(_DWORD *)(a2 + 348) + 176), 0);
        }
        else if ( v34[30] == 3 || v34[30] == 4 || v34[30] == 5 )
        {
          v35 = Drop_Weapon(a2, *(char *)(v34[30] + *(_DWORD *)(a2 + 348) + 788), 0);
        }
        else
        {
          for ( i = 1; i <= 2; ++i )
          {
            v33 = *(char *)(i + *(_DWORD *)(a2 + 348) + 788);
            v31 = BG_AmmoForWeapon(*(_DWORD *)v37);
            v30 = BG_ClipForWeapon(*(_DWORD *)v37);
            if ( !*(_DWORD *)(*(_DWORD *)(a2 + 348) + 4 * v31 + 268)
              && !*(_DWORD *)(*(_DWORD *)(a2 + 348) + 4 * v30 + 524) )
            {
              v35 = Drop_Weapon(a2, v33, 0);
              break;
            }
          }
          if ( i > 2 )
          {
            v12 = va("f \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", v25);
            trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 0, v12);
            return 0;
          }
        }
        if ( !v35 )
          return 0;
        v29[0] = a1[78];
        v29[1] = a1[79];
        v29[2] = a1[80];
        G_SetOrigin(v35, v29);
        G_SetAngle(v35, a1 + 81);
        trap_LinkEntity(v35);
      }
    }
    BG_GivePlayerWeapon(*(_DWORD *)(a2 + 348), *(_DWORD *)v37);
    if ( !a4 )
    {
      v13 = va("a %i", v37[0]);
      trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 1, v13);
    }
  }
  if ( v38 )
  {
    *a3 = 148;
    v40 += v39;
    v36 = Add_Ammo(a2, *(_DWORD *)v37, v40, 0);
    if ( v36 )
    {
      if ( BG_WeaponIsClipOnly(*(_DWORD *)v37) )
        v14 = va(aFGamePickupCli, v34[2]);
      else
        v14 = va(aFGamePickupAmm, v34[2]);
      trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 0, v14);
    }
    if ( v36 != v40 )
    {
      a1[150] -= v36;
      if ( (int)a1[150] <= 0 )
      {
        a1[181] += a1[150];
        a1[150] = -1;
        if ( (int)a1[181] <= 0 )
          a1[181] = -1;
      }
      if ( ((int)a1[150] > 0 || (int)a1[181] > 0) && g_weaponAmmoPools[3] )
        return 0;
    }
  }
  else
  {
    if ( v39 >= 0 )
    {
      v15 = BG_ClipForWeapon(*(_DWORD *)v37);
      v16 = BG_GetAmmoClipSize(v15);
      if ( v39 > v16 )
      {
        v17 = BG_ClipForWeapon(*(_DWORD *)v37);
        v18 = BG_GetAmmoClipSize(v17);
        v40 += v39 - v18;
        v19 = BG_ClipForWeapon(*(_DWORD *)v37);
        v39 = BG_GetAmmoClipSize(v19);
      }
      v20 = *(_DWORD *)(a2 + 348);
      v21 = BG_ClipForWeapon(*(_DWORD *)v37);
      *(_DWORD *)(v20 + 4 * v21 + 524) = v39;
    }
    Add_Ammo(a2, *(_DWORD *)v37, v40, v39 == -1);
  }
  if ( v35 )
    Scr_AddEntity(v35);
  else
    Scr_AddUndefined();
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[73], 2);
  if ( (a1[96] & 8) != 0 )
    v28 = g_weaponRespawn[3];
  else
    v28 = -1;
  return v28;
}
// 4AC2A: variable 'v24' is possibly undefined
// 4ADEC: variable 'v25' is possibly undefined
// 12F10: using guessed type _DWORD __cdecl BG_GetAmmoTypeMax(_DWORD);
// 12FC0: using guessed type _DWORD __cdecl BG_GetStackSlotForWeapon(_DWORD, _DWORD, _DWORD);
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 132B0: using guessed type _DWORD __cdecl BG_WeaponIsClipOnly(_DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 136F0: using guessed type int Scr_AddUndefined(void);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 140B0: using guessed type _DWORD __cdecl BG_GetEmptySlotForWeapon(_DWORD, _DWORD);
// 140C0: using guessed type _DWORD __cdecl BG_IsPlayerWeaponInSlot(_DWORD, _DWORD, _DWORD);
// 14140: using guessed type _DWORD __cdecl Drop_Weapon(_DWORD, _DWORD, _DWORD);
// 144D0: using guessed type _DWORD __cdecl BG_GivePlayerWeapon(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 14AF0: using guessed type _DWORD __cdecl Add_Ammo(_DWORD, _DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004B181) --------------------------------------------------------
int __cdecl Pickup_Health(int a1, int a2)
{
  int v2; // eax
  int v4; // [esp+1Ch] [ebp-1Ch]
  int v5; // [esp+1Ch] [ebp-1Ch]
  int v6; // [esp+20h] [ebp-18h]
  int v7; // [esp+24h] [ebp-14h]
  int v8; // [esp+28h] [ebp-10h]
  int v9; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 672) + 28) == 5 || *(_DWORD *)(*(_DWORD *)(a1 + 672) + 28) == 100 )
    v9 = 2 * *(_DWORD *)(*(_DWORD *)(a2 + 348) + 252);
  else
    v9 = *(_DWORD *)(*(_DWORD *)(a2 + 348) + 252);
  if ( *(_DWORD *)(a1 + 600) )
    v8 = *(_DWORD *)(a1 + 600);
  else
    v8 = *(_DWORD *)(*(_DWORD *)(a1 + 672) + 28);
  v7 = *(_DWORD *)(a2 + 568);
  *(_DWORD *)(a2 + 568) = v7
                        + (int)((long double)v8 * (long double)*(int *)(*(_DWORD *)(a2 + 348) + 252) * 0.0099999998);
  if ( *(_DWORD *)(a2 + 568) <= v9 )
  {
    v6 = (int)((long double)(100 * *(_DWORD *)(a2 + 568)) / (long double)*(int *)(*(_DWORD *)(a2 + 348) + 252));
    if ( v6 > 0 )
    {
      if ( v6 > 100 )
        v6 = 100;
    }
    else
    {
      v6 = 1;
    }
    v4 = (int)((long double)(100 * v7) / (long double)*(int *)(*(_DWORD *)(a2 + 348) + 252));
    if ( v4 <= 0 )
      v4 = 1;
    v5 = v8 + v4;
    if ( v5 > 100 )
      v5 = 100;
    if ( v6 != v5 )
      *(_DWORD *)(a2 + 568) = *(_DWORD *)(*(_DWORD *)(a2 + 348) + 252) * v5 / 100;
  }
  else
  {
    *(_DWORD *)(a2 + 568) = v9;
  }
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 244) = *(_DWORD *)(a2 + 568);
  v2 = va(aFGamePickupHea, v8);
  trap_SendServerCommand(-280575753 * ((a2 - (int)g_entities) >> 2), 0, v2);
  Scr_AddEntity(a2);
  Scr_Notify(a1, scr_const[73], 1);
  return -1;
}
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0004B3FB) --------------------------------------------------------
int __cdecl RespawnItem(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-24h]
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]
  int v7; // [esp+30h] [ebp+8h]

  if ( *(_WORD *)(a1 + 480) )
  {
    if ( !*(_DWORD *)(a1 + 620) )
      G_Error("RespawnItem: bad teammaster", v2);
    v6 = *(_DWORD *)(a1 + 620);
    v4 = 0;
    v7 = v6;
    while ( v7 )
    {
      v7 = *(_DWORD *)(v7 + 616);
      ++v4;
    }
    v3 = rand() % v4;
    v5 = 0;
    a1 = v6;
    while ( v5 < v3 )
    {
      a1 = *(_DWORD *)(a1 + 616);
      ++v5;
    }
  }
  *(_DWORD *)(a1 + 284) = 1081868296;
  *(_DWORD *)(a1 + 388) &= 0xFFFFEFFF;
  *(_DWORD *)(a1 + 244) &= 0xFFFFFFFE;
  trap_LinkEntity(a1);
  G_AddEvent(a1, 197, 0);
  result = a1;
  *(_DWORD *)(a1 + 516) = 0;
  return result;
}
// 4B433: variable 'v2' is possibly undefined
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0004B520) --------------------------------------------------------
int __cdecl Touch_Item_Auto(int a1, int a2, int a3)
{
  *(_BYTE *)(a1 + 374) = 1;
  return Touch_Item(a1, a2, a3);
}
// 13960: using guessed type _DWORD __cdecl Touch_Item(_DWORD, _DWORD, _DWORD);

//----- (0004B55B) --------------------------------------------------------
unsigned int __cdecl Touch_Item(int a1, _DWORD *a2, int a3)
{
  unsigned int result; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  char v10; // al
  char v11; // al
  long double v12; // fst6
  char v13; // [esp+4h] [ebp-84h]
  char dest[72]; // [esp+30h] [ebp-58h] BYREF
  int v15; // [esp+78h] [ebp-10h] BYREF
  int v16; // [esp+7Ch] [ebp-Ch]

  v15 = 146;
  result = a1;
  if ( *(_BYTE *)(a1 + 374) )
  {
    *(_BYTE *)(a1 + 374) = 0;
    result = (unsigned int)a2;
    if ( a2[87] )
    {
      result = (unsigned int)a2;
      if ( (int)a2[142] > 0 )
      {
        result = BG_CanItemBeGrabbed(a1, a2[87], a3);
        if ( result )
        {
          Q_strncpyz(dest, (char *)(a2[87] + 8636), 64);
          Q_CleanStr(dest);
          if ( *(_DWORD *)(*(_DWORD *)(a1 + 672) + 32) == 1 )
          {
            BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36));
            v10 = trap_GetGuid(*a2);
            G_LogPrintf("Weapon;%d;%d;%s;%s\n", v10);
          }
          else
          {
            v11 = trap_GetGuid(*a2);
            G_LogPrintf("Item;%d;%d;%s;%s\n", v11);
          }
          result = *(_DWORD *)(*(_DWORD *)(a1 + 672) + 32);
          if ( result == 2 )
          {
            result = sub_4A6F6(a1, (int)a2);
            v16 = result;
          }
          else if ( result > 2 )
          {
            if ( result != 3 )
              return result;
            result = Pickup_Health(a1, a2);
            v16 = result;
          }
          else
          {
            if ( result != 1 )
              return result;
            result = sub_4A86B((_DWORD *)a1, (int)a2, &v15, a3);
            v16 = result;
          }
          if ( v16 )
          {
            if ( *(_BYTE *)(a1 + 370) )
            {
              v15 = 147;
              G_PlaySoundAlias(a2, *(unsigned __int8 *)(a1 + 370));
            }
            if ( *(_DWORD *)(a2[87] + 8480) )
              G_AddPredictableEvent(a2, v15, *(_DWORD *)(a1 + 140));
            else
              G_AddEvent(a2, v15, *(_DWORD *)(a1 + 140));
            if ( *(float *)(a1 + 624) == -1.0 )
            {
              *(_DWORD *)(a1 + 388) |= 0x1000u;
              *(_DWORD *)(a1 + 8) |= 0x100u;
              *(_DWORD *)(a1 + 284) = 0;
              result = a1;
              *(_DWORD *)(a1 + 400) = 1;
            }
            else
            {
              if ( *(float *)(a1 + 624) != 0.0 )
                v16 = (int)*(float *)(a1 + 624);
              if ( *(float *)(a1 + 628) != 0.0 )
              {
                v12 = (long double)rand() / 2147483600.0;
                v16 += (int)((v12 + v12 - 1.0) * *(float *)(a1 + 628));
                if ( v16 <= 0 )
                  v16 = 1;
              }
              if ( (*(_DWORD *)(a1 + 388) & 0x10) != 0 )
                *(_DWORD *)(a1 + 396) = 1;
              *(_DWORD *)(a1 + 244) |= 1u;
              *(_DWORD *)(a1 + 388) |= 0x1000u;
              *(_DWORD *)(a1 + 284) = 0;
              if ( v16 > 0 )
              {
                *(_DWORD *)(a1 + 516) = level[122] + 1000 * v16;
                *(_DWORD *)(a1 + 520) = RespawnItem;
              }
              else
              {
                *(_DWORD *)(a1 + 516) = 0;
                *(_DWORD *)(a1 + 520) = 0;
              }
              if ( (*(_DWORD *)(a1 + 388) & 0x10) != 0 )
              {
                *(_DWORD *)(a1 + 520) = G_FreeEntity;
                *(_DWORD *)(a1 + 516) = level[122] + 100;
              }
              result = trap_LinkEntity(a1);
            }
          }
        }
        else if ( !a3 )
        {
          result = *(_DWORD *)(a1 + 144);
          if ( result != *a2 )
          {
            result = *(_DWORD *)(*(_DWORD *)(a1 + 672) + 32);
            if ( result == 1 )
            {
              if ( Com_BitCheck(a2[87] + 780, *(_DWORD *)(*(_DWORD *)(a1 + 672) + 36)) )
              {
                v4 = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36));
                v5 = va(aFGamePickupCan, *(_DWORD *)(v4 + 8));
                result = trap_SendServerCommand(-280575753 * (a2 - g_entities), 0, v5);
              }
              else
              {
                result = BG_GetInfoForWeapon(*(_DWORD *)(*(_DWORD *)(a1 + 672) + 36));
                if ( *(_DWORD *)(result + 120) <= 5u )
                {
                  result = *(_DWORD *)(result + 120);
                  switch ( result )
                  {
                    case 0u:
                      return result;
                    case 1u:
                    case 2u:
                      v6 = va("f \"GAME_CANT_GET_PRIMARY_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(-280575753 * (a2 - g_entities), 0, v6);
                      break;
                    case 3u:
                      v7 = va("f \"GAME_CANT_GET_PISTOL_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(-280575753 * (a2 - g_entities), 0, v7);
                      break;
                    case 4u:
                      v8 = va("f \"GAME_CANT_GET_GRENADE_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(-280575753 * (a2 - g_entities), 0, v8);
                      break;
                    case 5u:
                      v9 = va("f \"GAME_CANT_GET_SMOKER_WEAP_MESSAGE\"", v13);
                      result = trap_SendServerCommand(-280575753 * (a2 - g_entities), 0, v9);
                      break;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 4B6CF: variable 'v13' is possibly undefined
// 13300: using guessed type _DWORD __cdecl trap_GetGuid(_DWORD);
// 13310: using guessed type _DWORD __cdecl Q_CleanStr(_DWORD);
// 136D0: using guessed type _DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14010: using guessed type _DWORD __cdecl G_AddPredictableEvent(_DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 15680: using guessed type _DWORD __cdecl Pickup_Health(_DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0004BB94) --------------------------------------------------------
int sub_4BB94()
{
  int v2; // [esp+10h] [ebp-28h]
  int v3; // [esp+14h] [ebp-24h]
  int v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+18h] [ebp-20h]
  float v6; // [esp+1Ch] [ebp-1Ch]
  float v7; // [esp+20h] [ebp-18h]
  float v8; // [esp+24h] [ebp-14h]
  int v9; // [esp+28h] [ebp-10h]
  int j; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v9 = 0;
  v6 = -1.0;
  v2 = g_maxDroppedWeapons[3];
  if ( v2 > 0 )
  {
    if ( v2 > 32 )
      v2 = 32;
  }
  else
  {
    v2 = 1;
  }
  for ( i = 0; i < v2; ++i )
  {
    v4 = level[i + 2144];
    if ( !v4 )
      return i;
    v8 = 9.9999803e11;
    for ( j = 0; j < level[120]; ++j )
    {
      v3 = level[0] + 8908 * j;
      if ( *(_DWORD *)(v3 + 8424) == 2 && !*(_DWORD *)(v3 + 8396) )
      {
        v7 = VectorDistanceSquared(&g_entities[199 * j + 78], v4 + 312);
        if ( v8 > (long double)v7 )
          v8 = v7;
      }
    }
    if ( v8 > (long double)v6 )
    {
      v6 = v8;
      v9 = i;
    }
  }
  v5 = level[v9 + 2144];
  *(_DWORD *)(v5 + 520) = G_FreeEntity;
  *(_DWORD *)(v5 + 516) = level[122] + 1;
  return v9;
}
// 14F80: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0004BD26) --------------------------------------------------------
int __cdecl DroppedItemClearOwner(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 144) = 1022;
  return result;
}

//----- (0004BD38) --------------------------------------------------------
_DWORD *__cdecl LaunchItem(int a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *v5; // [esp+Ch] [ebp-Ch]

  RegisterItem(-1431655765 * ((a1 - (int)&bg_itemlist) >> 4), 1);
  v5 = (_DWORD *)G_Spawn();
  level[sub_4BB94() + 2144] = v5;
  v5[1] = 3;
  v5[35] = -1431655765 * ((a1 - (int)&bg_itemlist) >> 4);
  G_SetConstString(v5 + 95, *(_DWORD *)a1);
  v5[168] = a1;
  if ( *(_DWORD *)(a1 + 32) == 1 )
  {
    v5[65] = -1082130432;
    v5[66] = -1082130432;
    v5[67] = -1082130432;
    v5[68] = 1065353216;
    v5[69] = 1065353216;
    v5[70] = 1065353216;
  }
  else
  {
    v5[65] = -1082130432;
    v5[66] = -1082130432;
    v5[67] = 0;
    v5[68] = 1065353216;
    v5[69] = 1065353216;
    v5[70] = 0x40000000;
  }
  v5[61] |= 0x200u;
  v5[2] |= 0x10u;
  v5[71] = 1081868552;
  v5[102] = 129;
  v5[36] = a4;
  G_SetModel((int)v5, *(char **)(a1 + 8));
  G_DObjUpdate(v5);
  v5[133] = Touch_Item_Auto;
  G_SetOrigin(v5, a2);
  v5[3] = 5;
  v5[4] = level[122];
  v5[9] = *a3;
  v5[10] = a3[1];
  v5[11] = a3[2];
  v5[130] = DroppedItemClearOwner;
  v5[129] = level[122] + 1000;
  v5[97] = 16;
  trap_LinkEntity(v5);
  return v5;
}
// 12E70: using guessed type int G_Spawn(void);
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 13870: using guessed type _DWORD __cdecl G_SetConstString(_DWORD, _DWORD);
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004BF9C) --------------------------------------------------------
int __cdecl Drop_Item(int a1, int a2, float a3, int a4)
{
  long double v4; // fst6
  int v6[2]; // [esp+10h] [ebp-38h] BYREF
  float v7; // [esp+18h] [ebp-30h]
  int v8[4]; // [esp+20h] [ebp-28h] BYREF
  float v9; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+34h] [ebp-14h]
  float v11; // [esp+38h] [ebp-10h]

  v8[0] = *(_DWORD *)(a1 + 324);
  *(float *)&v8[1] = *(float *)(a1 + 328) + a3;
  v8[0] = 0;
  v8[2] = 0;
  if ( a4 )
  {
    v11 = 0.0;
    v10 = 0.0;
    v9 = 0.0;
  }
  else
  {
    AngleVectors(v8, &v9, 0, 0);
    v9 = v9 * 150.0;
    v10 = v10 * 150.0;
    v11 = v11 * 150.0;
    v4 = (long double)rand() / 2147483600.0;
    v11 = (v4 + v4 - 1.0) * 50.0 + 200.0 + v11;
  }
  v6[0] = *(_DWORD *)(a1 + 312);
  v6[1] = *(_DWORD *)(a1 + 316);
  v7 = *(float *)(a1 + 320);
  v7 = (*(float *)(a1 + 280) - *(float *)(a1 + 268)) * 0.5 + v7;
  return LaunchItem(a2, v6, &v9, *(_DWORD *)a1);
}
// 136A0: using guessed type _DWORD __cdecl LaunchItem(_DWORD, _DWORD, _DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004C0F6) --------------------------------------------------------
int __cdecl Drop_Weapon(int a1, int a2, int a3)
{
  long double v3; // fst6
  long double v4; // fst6
  long double v5; // fst6
  float v7; // [esp+0h] [ebp-118h]
  float v8; // [esp+0h] [ebp-118h]
  int v9; // [esp+30h] [ebp-E8h]
  int v10; // [esp+34h] [ebp-E4h]
  float v11; // [esp+38h] [ebp-E0h]
  int v12; // [esp+3Ch] [ebp-DCh]
  char v13[4]; // [esp+40h] [ebp-D8h] BYREF
  int v14; // [esp+44h] [ebp-D4h]
  int v15; // [esp+48h] [ebp-D0h]
  int v16; // [esp+4Ch] [ebp-CCh]
  float v17; // [esp+70h] [ebp-A8h] BYREF
  float v18; // [esp+74h] [ebp-A4h]
  float v19; // [esp+78h] [ebp-A0h]
  int v20[2]; // [esp+80h] [ebp-98h] BYREF
  float v21; // [esp+88h] [ebp-90h]
  char v22[48]; // [esp+90h] [ebp-88h] BYREF
  int v23; // [esp+C0h] [ebp-58h] BYREF
  float v24; // [esp+D0h] [ebp-48h]
  float v25; // [esp+D4h] [ebp-44h]
  float v26; // [esp+D8h] [ebp-40h]
  int v27; // [esp+ECh] [ebp-2Ch]
  int v28; // [esp+F0h] [ebp-28h]
  int v29; // [esp+F4h] [ebp-24h]
  int v30; // [esp+F8h] [ebp-20h]
  int v31; // [esp+FCh] [ebp-1Ch]
  int v32; // [esp+100h] [ebp-18h]
  int v33; // [esp+104h] [ebp-14h]
  int v34; // [esp+108h] [ebp-10h]
  int v35; // [esp+10Ch] [ebp-Ch]

  v30 = (int)&bg_itemlist + 48 * a2;
  if ( *(_DWORD *)(a1 + 348) && !Com_BitCheck(*(_DWORD *)(a1 + 348) + 780, a2)
    || (v33 = BG_AmmoForWeapon(a2), v32 = BG_ClipForWeapon(a2), *(_DWORD *)(BG_GetInfoForWeapon(a2) + 736))
    && !*(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v32 + 524) )
  {
    BG_TakePlayerWeapon(*(_DWORD *)(a1 + 348), a2);
    v12 = 0;
  }
  else
  {
    v31 = Drop_Item(a1, v30, 0.0, 0);
    if ( *(_DWORD *)(a1 + 348) )
    {
      v35 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v33 + 268);
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v33 + 268) = 0;
      v34 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v32 + 524);
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 4 * v32 + 524) = 0;
      BG_TakePlayerWeapon(*(_DWORD *)(a1 + 348), a2);
    }
    else
    {
      v28 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 784);
      v27 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 780);
      if ( v28 < v27 )
      {
        v28 = v27;
        v27 = *(_DWORD *)(BG_GetInfoForWeapon(a2) + 784);
      }
      if ( v28 || v27 )
      {
        if ( v28 >= 0 )
        {
          if ( v28 == v27 )
            v10 = v27;
          else
            v10 = rand() % (v28 - v27) + v27;
          v35 = v10;
          if ( v10 > 0 )
          {
            v29 = BG_GetAmmoClipSize(v32);
            if ( v29 )
              v9 = rand() % v29;
            else
              v9 = 0;
            v34 = v9;
            if ( v9 < v35 )
            {
              v35 -= v34;
            }
            else
            {
              v34 = v35;
              v35 = 0;
            }
          }
          else
          {
            v35 = 0;
            v34 = 0;
          }
        }
        else
        {
          v35 = 0;
          v34 = 0;
        }
      }
      else
      {
        v11 = ((long double)rand() / 2147483600.0 + 1.0) * 0.5;
        v7 = (long double)(BG_GetAmmoClipSize(v32) - 1) * v11;
        v35 = sub_4D844(v7) + 1;
        v8 = ((long double)rand() / 2147483600.0 * 0.5 + 0.25) * (long double)v35;
        v34 = sub_4D844(v8);
        v35 -= v34;
      }
    }
    *(_DWORD *)(v31 + 600) = v35;
    *(_DWORD *)(v31 + 724) = v34;
    if ( !*(_DWORD *)(v31 + 600) )
      *(_DWORD *)(v31 + 600) = -1;
    if ( !*(_DWORD *)(v31 + 724) )
      *(_DWORD *)(v31 + 724) = -1;
    if ( a3 )
    {
      if ( G_DObjGetWorldTagMatrix(a1, a3, v22) )
      {
        v17 = *(float *)(a1 + 260) + *(float *)(a1 + 272);
        v18 = *(float *)(a1 + 264) + *(float *)(a1 + 276);
        v19 = *(float *)(a1 + 268) + *(float *)(a1 + 280);
        v17 = v17 * 0.5;
        v18 = v18 * 0.5;
        v19 = v19 * 0.5;
        v17 = v17 + *(float *)(a1 + 312);
        v18 = v18 + *(float *)(a1 + 316);
        v19 = v19 + *(float *)(a1 + 320);
        trap_TraceCapsule(v13, &v17, v31 + 260, v31 + 272, &v23, *(_DWORD *)a1, 1041);
        *(_DWORD *)(v31 + 24) = v14;
        *(_DWORD *)(v31 + 28) = v15;
        *(_DWORD *)(v31 + 32) = v16;
        *(_DWORD *)(v31 + 312) = v14;
        *(_DWORD *)(v31 + 316) = v15;
        *(_DWORD *)(v31 + 320) = v16;
        *(_DWORD *)(v31 + 16) = level[122];
        Axis4ToAngles(v22, v20);
      }
      else
      {
        v20[0] = *(_DWORD *)(a1 + 324);
        v20[1] = *(_DWORD *)(a1 + 328);
        v21 = *(float *)(a1 + 332);
      }
      v21 = v21 + 90.0;
      G_SetAngle(v31, a1 + 324);
      v3 = (long double)rand() / 2147483600.0;
      v24 = (v3 + v3 - 1.0) * 50.0;
      v4 = (long double)rand() / 2147483600.0;
      v25 = (v4 + v4 - 1.0) * 40.0;
      v5 = (long double)rand() / 2147483600.0;
      v26 = (v5 + v5 - 1.0) * 60.0;
      *(_DWORD *)(v31 + 48) = 2;
      *(_DWORD *)(v31 + 52) = level[122];
      *(float *)(v31 + 72) = v24;
      *(float *)(v31 + 76) = v25;
      *(float *)(v31 + 80) = v26;
    }
    v12 = v31;
  }
  return v12;
}
// 13000: using guessed type _DWORD __cdecl BG_GetAmmoClipSize(_DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 144B0: using guessed type _DWORD __cdecl BG_TakePlayerWeapon(_DWORD, _DWORD);
// 14510: using guessed type _DWORD __cdecl Axis4ToAngles(_DWORD, _DWORD);
// 14A20: using guessed type _DWORD __cdecl BG_ClipForWeapon(_DWORD);
// 153A0: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 15600: using guessed type _DWORD __cdecl BG_AmmoForWeapon(_DWORD);
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004C79C) --------------------------------------------------------
int __cdecl Use_Item(int a1)
{
  return RespawnItem(a1);
}
// 14B10: using guessed type _DWORD __cdecl RespawnItem(_DWORD);

//----- (0004C7BF) --------------------------------------------------------
int __cdecl FinishSpawningItem(void *s)
{
  char v1; // al
  char v3[12]; // [esp+20h] [ebp-B8h] BYREF
  _BYTE v4[12]; // [esp+2Ch] [ebp-ACh] BYREF
  int v5[6]; // [esp+38h] [ebp-A0h] BYREF
  char v6[8]; // [esp+50h] [ebp-88h] BYREF
  float v7; // [esp+58h] [ebp-80h]
  int v8[2]; // [esp+60h] [ebp-78h] BYREF
  float v9; // [esp+68h] [ebp-70h]
  int v10; // [esp+70h] [ebp-68h] BYREF
  int v11; // [esp+74h] [ebp-64h]
  int v12; // [esp+78h] [ebp-60h]
  int v13; // [esp+80h] [ebp-58h] BYREF
  int v14; // [esp+84h] [ebp-54h]
  int v15; // [esp+88h] [ebp-50h]
  int v16; // [esp+90h] [ebp-48h] BYREF
  int v17; // [esp+94h] [ebp-44h]
  float v18; // [esp+98h] [ebp-40h]
  float v19; // [esp+A0h] [ebp-38h] BYREF
  _DWORD v20[9]; // [esp+A4h] [ebp-34h] BYREF
  unsigned __int16 v21; // [esp+C8h] [ebp-10h]
  char v22; // [esp+CFh] [ebp-9h]

  if ( (*((_DWORD *)s + 96) & 1) != 0 )
  {
    G_SetOrigin(s, (char *)s + 312);
  }
  else
  {
    if ( *(_DWORD *)(*((_DWORD *)s + 168) + 32) == 1 )
    {
      v13 = -1082130432;
      v14 = -1082130432;
      v15 = -1082130432;
      v10 = 1065353216;
      v11 = 1065353216;
      v12 = 1065353216;
    }
    else
    {
      v13 = -1082130432;
      v14 = -1082130432;
      v15 = 0;
      v10 = 1065353216;
      v11 = 1065353216;
      v12 = 0x40000000;
    }
    *((_DWORD *)s + 61) |= 0x200u;
    *((_DWORD *)s + 2) |= 0x10u;
    v16 = *((_DWORD *)s + 78);
    v17 = *((_DWORD *)s + 79);
    v18 = *((float *)s + 80) - 4096.0;
    trap_TraceCapsule(&v19, (char *)s + 312, &v13, &v10, &v16, *(_DWORD *)s, 1041);
    if ( v22 )
    {
      v8[0] = *((_DWORD *)s + 78);
      v8[1] = *((_DWORD *)s + 79);
      v9 = *((float *)s + 80);
      v9 = v9 - 15.0;
      v16 = *((_DWORD *)s + 78);
      v17 = *((_DWORD *)s + 79);
      v18 = *((float *)s + 80) - 4096.0;
      trap_TraceCapsule(&v19, v8, &v13, &v10, &v16, *(_DWORD *)s, 1041);
    }
    if ( v22 )
    {
      vtos((char *)s + 312);
      v1 = SL_ConvertToString(*((unsigned __int16 *)s + 190));
      G_Printf("FinishSpawningItem: %s startsolid at %s\n", v1);
      return G_FreeEntity(s);
    }
    *((_DWORD *)s + 31) = v21;
    G_SetOrigin(s, v20);
    if ( v19 < 1.0 )
    {
      v5[0] = v20[3];
      v5[1] = v20[4];
      v5[2] = v20[5];
      AngleVectors((char *)s + 324, v3, 0, 0);
      CrossProduct(v5, v3, v4);
      CrossProduct(v4, v5, v3);
      AxisToAngles(v3, v6);
      if ( bg_itemlist[12 * *((_DWORD *)s + 35) + 8] == 1 )
        v7 = v7 + 90.0;
      G_SetAngle(s, v6);
    }
  }
  return trap_LinkEntity(s);
}
// 131A0: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13CD0: using guessed type _DWORD __cdecl vtos(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004CB20) --------------------------------------------------------
_DWORD *ClearRegisteredItems()
{
  _DWORD *result; // eax

  memset(itemRegistered, 0, sizeof(itemRegistered));
  result = itemRegistered;
  itemRegistered[0] = 1;
  return result;
}

//----- (0004CB62) --------------------------------------------------------
int SaveRegisteredItems()
{
  char v1; // [esp+13h] [ebp-135h]
  char *v2; // [esp+14h] [ebp-134h]
  char v3; // [esp+1Bh] [ebp-12Dh]
  char *v4; // [esp+1Ch] [ebp-12Ch]
  int v5; // [esp+20h] [ebp-128h]
  int v6; // [esp+24h] [ebp-124h]
  int v7; // [esp+28h] [ebp-120h]
  int i; // [esp+2Ch] [ebp-11Ch]
  char v9[280]; // [esp+30h] [ebp-118h] BYREF

  level[2957] = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  for ( i = 0; i < bg_numItems; ++i )
  {
    if ( itemRegistered[i] )
      v6 += 1 << v5;
    if ( ++v5 == 4 )
    {
      v4 = &v9[v7++];
      if ( v6 > 9 )
        v3 = v6 + 87;
      else
        v3 = v6 + 48;
      *v4 = v3;
      v6 = 0;
      v5 = 0;
    }
  }
  if ( v5 )
  {
    v2 = &v9[v7++];
    if ( v6 > 9 )
      v1 = v6 + 87;
    else
      v1 = v6 + 48;
    *v2 = v1;
  }
  v9[v7] = 0;
  return trap_SetConfigstring(8, v9);
}
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (0004CD17) --------------------------------------------------------
_DWORD *__cdecl RegisterItem(int a1, int a2)
{
  _DWORD *result; // eax
  int v3; // eax
  int v4; // [esp+Ch] [ebp-Ch]
  const char *v5; // [esp+10h] [ebp-8h]
  int v6; // [esp+10h] [ebp-8h]

  result = (_DWORD *)a1;
  if ( !itemRegistered[a1] )
  {
    if ( !level[7] )
    {
      v5 = (const char *)bg_itemlist[12 * a1 + 6];
      if ( (!v5 || !*v5) && a1 <= BG_GetNumWeapons() )
        v5 = *(const char **)(BG_GetInfoForWeapon(a1) + 4);
      if ( !v5 || !*v5 )
        v5 = "<<unknown>>";
      v3 = va("game tried to register the item '%s' after initialization finished\n", (char)v5);
      Scr_Error(v3);
    }
    itemRegistered[a1] = 1;
    if ( bg_itemlist[12 * a1 + 8] == 1 )
    {
      v6 = a1;
      do
      {
        itemRegistered[v6] = 1;
        v4 = BG_GetInfoForWeapon(v6);
        G_ModelIndex(*(char **)(v4 + 392));
        G_ModelIndex(*(char **)(v4 + 808));
        result = *(_DWORD **)(v4 + 776);
        v6 = (int)result;
        if ( !result )
          break;
        result = *(_DWORD **)(v4 + 776);
      }
      while ( v6 != a1 );
    }
    else
    {
      if ( bg_itemlist[12 * a1 + 2] )
        G_ModelIndex((char *)bg_itemlist[12 * a1 + 2]);
      result = &bg_itemlist[12 * a1 + 3];
      if ( *result )
        result = (_DWORD *)G_ModelIndex((char *)bg_itemlist[12 * a1 + 3]);
    }
    if ( a2 )
    {
      result = level;
      level[2957] = 1;
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0004CEEF) --------------------------------------------------------
int __cdecl IsItemRegistered(int a1)
{
  return itemRegistered[a1];
}

//----- (0004CF0D) --------------------------------------------------------
int (__cdecl *__cdecl G_SpawnItem(int a1, int a2))(void *s)
{
  int (__cdecl *result)(void *); // eax
  char *s2; // [esp+Ch] [ebp-Ch] BYREF

  G_SpawnFloat("random", (int)"0", a1 + 628);
  G_SpawnFloat("wait", (int)"0", a1 + 624);
  RegisterItem(-1431655765 * ((a2 - (int)bg_itemlist) >> 4), 0);
  *(_DWORD *)(a1 + 672) = a2;
  G_SetModel(a1, *(char **)(a2 + 8));
  if ( G_SpawnString("noise", 0, (int)&s2) )
    *(_BYTE *)(a1 + 370) = G_SoundAliasIndex(s2);
  *(_DWORD *)(a1 + 404) = 0;
  if ( *(_DWORD *)(a2 + 32) == 1 )
  {
    *(_DWORD *)(a1 + 260) = -1082130432;
    *(_DWORD *)(a1 + 264) = -1082130432;
    *(_DWORD *)(a1 + 268) = -1082130432;
    *(_DWORD *)(a1 + 272) = 1065353216;
    *(_DWORD *)(a1 + 276) = 1065353216;
    *(_DWORD *)(a1 + 280) = 1065353216;
  }
  else
  {
    *(_DWORD *)(a1 + 260) = -1082130432;
    *(_DWORD *)(a1 + 264) = -1082130432;
    *(_DWORD *)(a1 + 268) = 0;
    *(_DWORD *)(a1 + 272) = 1065353216;
    *(_DWORD *)(a1 + 276) = 1065353216;
    *(_DWORD *)(a1 + 280) = 0x40000000;
  }
  *(_DWORD *)(a1 + 244) |= 0x200u;
  *(_DWORD *)(a1 + 8) |= 0x10u;
  *(_DWORD *)(a1 + 284) = 1081868552;
  *(_DWORD *)(a1 + 532) = Touch_Item_Auto;
  *(_DWORD *)(a1 + 4) = 3;
  *(_DWORD *)(a1 + 140) = -1431655765 * ((*(_DWORD *)(a1 + 672) - (int)bg_itemlist) >> 4);
  G_DObjUpdate(a1);
  *(_DWORD *)(a1 + 144) = 1022;
  *(_DWORD *)(a1 + 536) = Use_Item;
  *(_DWORD *)(a1 + 388) |= 0x2000u;
  if ( level[1498] )
  {
    G_SetAngle(a1, a1 + 324);
    *(_DWORD *)(a1 + 516) = level[122] + 200;
    result = FinishSpawningItem;
    *(_DWORD *)(a1 + 520) = FinishSpawningItem;
  }
  else
  {
    if ( (*(_DWORD *)(a1 + 384) & 1) == 0 )
    {
      *(_DWORD *)(a1 + 124) = 1023;
      if ( *(_DWORD *)(a2 + 32) == 1 )
        *(float *)(a1 + 332) = *(float *)(a1 + 332) + 90.0;
    }
    G_SetAngle(a1, a1 + 324);
    G_SetOrigin(a1, a1 + 312);
    result = (int (__cdecl *)(void *))trap_LinkEntity(a1);
  }
  return result;
}
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004D211) --------------------------------------------------------
int __cdecl G_BounceItem(int a1, int a2)
{
  int result; // eax
  char v3[8]; // [esp+30h] [ebp-78h] BYREF
  float v4; // [esp+38h] [ebp-70h]
  char v5[12]; // [esp+40h] [ebp-68h] BYREF
  _BYTE v6[12]; // [esp+4Ch] [ebp-5Ch] BYREF
  int v7[6]; // [esp+58h] [ebp-50h] BYREF
  int v8[5]; // [esp+70h] [ebp-38h] BYREF
  int v9; // [esp+84h] [ebp-24h]
  float v10; // [esp+88h] [ebp-20h]
  float v11; // [esp+8Ch] [ebp-1Ch]
  float v12; // [esp+90h] [ebp-18h] BYREF
  float v13; // [esp+94h] [ebp-14h]
  float v14; // [esp+98h] [ebp-10h]

  v9 = level[123] + (int)((long double)(level[122] - level[123]) * *(float *)a2);
  BG_EvaluateTrajectoryDelta(a1 + 12, v9, &v12);
  v11 = v12 * *(float *)(a2 + 16) + v13 * *(float *)(a2 + 20) + v14 * *(float *)(a2 + 24);
  *(float *)(a1 + 36) = v11 * -2.0 * *(float *)(a2 + 16) + v12;
  *(float *)(a1 + 40) = v11 * -2.0 * *(float *)(a2 + 20) + v13;
  *(float *)(a1 + 44) = v11 * -2.0 * *(float *)(a2 + 24) + v14;
  *(float *)(a1 + 36) = *(float *)(a1 + 36) * *(float *)(a1 + 404);
  *(float *)(a1 + 40) = *(float *)(a1 + 40) * *(float *)(a1 + 404);
  *(float *)(a1 + 44) = *(float *)(a1 + 44) * *(float *)(a1 + 404);
  if ( *(_BYTE *)(a2 + 47) )
  {
    *(_DWORD *)(a1 + 44) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    v8[0] = *(_DWORD *)(a1 + 312);
    v8[1] = *(_DWORD *)(a1 + 316);
    *(float *)&v8[2] = *(float *)(a1 + 320) - 128.0;
    if ( (*(_DWORD *)(a1 + 8) & 0x10) != 0 )
      trap_TraceCapsule(a2, a1 + 312, a1 + 260, a1 + 272, v8, *(_DWORD *)a1, 1041);
    else
      trap_Trace(a2, a1 + 312, a1 + 260, a1 + 272, v8, *(_DWORD *)a1, 1041);
  }
  if ( *(float *)(a2 + 24) <= 0.0 || *(float *)(a1 + 44) >= 40.0 )
  {
    *(float *)(a1 + 312) = *(float *)(a1 + 312) + *(float *)(a2 + 16);
    *(float *)(a1 + 316) = *(float *)(a1 + 316) + *(float *)(a2 + 20);
    *(float *)(a1 + 320) = *(float *)(a1 + 320) + *(float *)(a2 + 24);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
    result = level[122];
    *(_DWORD *)(a1 + 16) = result;
  }
  else
  {
    v10 = (long double)rand() / 2147483600.0 * 0.5 + 0.5;
    *(float *)(a2 + 12) = *(float *)(a2 + 12) + v10;
    G_SetOrigin(a1, a2 + 4);
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
    v7[0] = *(_DWORD *)(a2 + 16);
    v7[1] = *(_DWORD *)(a2 + 20);
    v7[2] = *(_DWORD *)(a2 + 24);
    AngleVectors(a1 + 324, v5, 0, 0);
    CrossProduct(v7, v5, v6);
    CrossProduct(v6, v7, v5);
    AxisToAngles(v5, v3);
    if ( bg_itemlist[12 * *(_DWORD *)(a1 + 140) + 8] == 1 )
      v4 = v4 + 90.0;
    G_SetAngle(a1, v3);
    result = trap_LinkEntity(a1);
  }
  return result;
}
// 131A0: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 13230: using guessed type _DWORD __cdecl CrossProduct(_DWORD, _DWORD, _DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15400: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0004D63D) --------------------------------------------------------
void __cdecl G_RunItem(void *s)
{
  int v1; // [esp+28h] [ebp-50h]
  int v2[11]; // [esp+30h] [ebp-48h] BYREF
  char v3; // [esp+5Fh] [ebp-19h]
  char v4[24]; // [esp+60h] [ebp-18h] BYREF

  if ( *((_DWORD *)s + 31) == 1023 && *((_DWORD *)s + 3) != 5 )
  {
    *((_DWORD *)s + 3) = 5;
    *((_DWORD *)s + 4) = level[122];
  }
  if ( *((_DWORD *)s + 3) && *((_DWORD *)s + 3) != 8 )
  {
    BG_EvaluateTrajectory((char *)s + 12, level[122], v4);
    if ( *((_DWORD *)s + 102) )
      v1 = *((_DWORD *)s + 102);
    else
      v1 = 1169;
    if ( (*((_DWORD *)s + 2) & 0x10) != 0 )
      trap_TraceCapsule(v2, (char *)s + 312, (char *)s + 260, (char *)s + 272, v4, *((_DWORD *)s + 84), v1);
    else
      trap_Trace(v2, (char *)s + 312, (char *)s + 260, (char *)s + 272, v4, *((_DWORD *)s + 84), v1);
    *((_DWORD *)s + 78) = v2[1];
    *((_DWORD *)s + 79) = v2[2];
    *((_DWORD *)s + 80) = v2[3];
    if ( v3 )
      v2[0] = 0;
    trap_LinkEntity(s);
    G_RunThink(s);
    if ( *((_BYTE *)s + 356) && *(float *)v2 != 1.0 )
    {
      if ( trap_PointContents((char *)s + 312, -1, 0x80000000) )
        G_FreeEntity(s);
      else
        G_BounceItem(s, v2);
    }
  }
  else
  {
    G_RunThink(s);
  }
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13CB0: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 142E0: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 153E0: using guessed type _DWORD __cdecl G_BounceItem(_DWORD, _DWORD);
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004D844) --------------------------------------------------------
int __cdecl sub_4D844(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (0004D882) --------------------------------------------------------
void sub_4D882()
{
  ;
}

//----- (0004D888) --------------------------------------------------------
int __cdecl vmMain(int a1, int a2, unsigned int seed, int a4, int a5)
{
  int v7; // [esp+20h] [ebp-8h]

  v7 = 0;
  switch ( a1 )
  {
    case 1:
      return 5;
    case 2:
      G_InitGame(a2, seed, a4, a5);
      return v7;
    case 3:
      G_ShutdownGame(a2);
      return v7;
    case 4:
      return ClientConnect(a2, (unsigned __int16)seed);
    case 5:
      ClientBegin(a2);
      return v7;
    case 6:
      ClientUserinfoChanged(a2);
      return v7;
    case 7:
      ClientDisconnect(a2);
      return v7;
    case 8:
      ClientCommand(a2);
      return v7;
    case 9:
      ClientThink(a2);
      return v7;
    case 10:
      return GetFollowPlayerState(a2, seed);
    case 11:
      G_UpdateCvars();
      return v7;
    case 12:
      G_RunFrame(a2);
      return v7;
    case 13:
      return ConsoleCommand();
    case 14:
      return Scr_FarHook(a2);
    case 15:
      G_DObjCalcPose(level[1] + 796 * a2);
      return v7;
    case 16:
      return a2 >= 0 && a2 <= BG_GetNumWeapons();
    case 17:
      level[2141] = a2;
      return v7;
    case 18:
      return level[2141];
    case 19:
      return level[0] + 8908 * a2 + 8576;
    case 20:
      return *(_DWORD *)(level[0] + 8908 * a2 + 8408);
    case 21:
      *(_DWORD *)(level[0] + 8908 * a2 + 8408) = seed;
      return v7;
    case 22:
      return *(_DWORD *)(level[0] + 8908 * a2 + 8412);
    case 23:
      return level[2177];
    default:
      return -1;
  }
}
// 12FA0: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 13080: using guessed type _DWORD __cdecl Scr_FarHook(_DWORD);
// 131E0: using guessed type int ConsoleCommand(void);
// 134F0: using guessed type _DWORD __cdecl G_DObjCalcPose(_DWORD);
// 138A0: using guessed type int BG_GetNumWeapons(void);
// 13EF0: using guessed type _DWORD __cdecl ClientDisconnect(_DWORD);
// 14080: using guessed type _DWORD __cdecl ClientThink(_DWORD);
// 147E0: using guessed type _DWORD __cdecl G_RunFrame(_DWORD);
// 147F0: using guessed type int G_UpdateCvars(void);
// 14830: using guessed type _DWORD __cdecl ClientBegin(_DWORD);
// 14A30: using guessed type _DWORD __cdecl ClientConnect(_DWORD, _DWORD);
// 14B20: using guessed type _DWORD __cdecl ClientCommand(_DWORD);
// 14D40: using guessed type int __cdecl G_ShutdownGame(_DWORD);
// 14D60: using guessed type _DWORD __cdecl GetFollowPlayerState(_DWORD, _DWORD);

//----- (0004DACC) --------------------------------------------------------
int G_Printf(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Printf(s);
}
// 13780: using guessed type _DWORD __cdecl trap_Printf(_DWORD);

//----- (0004DB1A) --------------------------------------------------------
_DWORD *G_DPrintf(char *format, ...)
{
  _DWORD *result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  result = g_developer;
  if ( g_developer[3] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    result = (_DWORD *)trap_Printf(s);
  }
  return result;
}
// 13780: using guessed type _DWORD __cdecl trap_Printf(_DWORD);

//----- (0004DB76) --------------------------------------------------------
int G_Error(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Error(s);
}
// 12FD0: using guessed type _DWORD __cdecl trap_Error(_DWORD);

//----- (0004DBC4) --------------------------------------------------------
int G_Error_Localized(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return trap_Error_Localized(s);
}
// 14F00: using guessed type _DWORD __cdecl trap_Error_Localized(_DWORD);

//----- (0004DC12) --------------------------------------------------------
int __cdecl sub_4DC12(int a1, int a2)
{
  return (int)(*(float *)(a1 + 4) - *(float *)(a2 + 4));
}

//----- (0004DC4D) --------------------------------------------------------
int __cdecl G_GetActivateEnt(int a1, void *base)
{
  char v3[48]; // [esp+20h] [ebp-1128h] BYREF
  float v4; // [esp+50h] [ebp-10F8h]
  float v5; // [esp+54h] [ebp-10F4h]
  float v6; // [esp+58h] [ebp-10F0h]
  int v7; // [esp+68h] [ebp-10E0h]
  float v8; // [esp+6Ch] [ebp-10DCh]
  int v9; // [esp+70h] [ebp-10D8h]
  float v10; // [esp+74h] [ebp-10D4h]
  int v11; // [esp+78h] [ebp-10D0h]
  float v12; // [esp+7Ch] [ebp-10CCh]
  float v13; // [esp+80h] [ebp-10C8h]
  size_t nmemb; // [esp+84h] [ebp-10C4h]
  int i; // [esp+88h] [ebp-10C0h]
  int v16; // [esp+8Ch] [ebp-10BCh]
  float v17; // [esp+90h] [ebp-10B8h] BYREF
  float v18; // [esp+94h] [ebp-10B4h]
  float v19; // [esp+98h] [ebp-10B0h]
  float v20; // [esp+A0h] [ebp-10A8h] BYREF
  float v21; // [esp+A4h] [ebp-10A4h]
  float v22; // [esp+A8h] [ebp-10A0h]
  float v23; // [esp+B0h] [ebp-1098h] BYREF
  float v24; // [esp+B4h] [ebp-1094h]
  float v25; // [esp+B8h] [ebp-1090h]
  float v26[4]; // [esp+C0h] [ebp-1088h] BYREF
  float v27[7]; // [esp+D0h] [ebp-1078h] BYREF
  float *v28; // [esp+ECh] [ebp-105Ch]
  int v29[1024]; // [esp+F0h] [ebp-1058h] BYREF
  float v30[7]; // [esp+10F0h] [ebp-58h] BYREF
  int v31; // [esp+110Ch] [ebp-3Ch]
  char v32[40]; // [esp+1110h] [ebp-38h] BYREF
  __int16 v33; // [esp+1138h] [ebp-10h]
  int v34; // [esp+1150h] [ebp+8h]

  v28 = 0;
  nmemb = 0;
  v13 = 0.75999999;
  v11 = 0;
  v31 = *(_DWORD *)(a1 + 348);
  AngleVectors(v31 + 192, v30, 0, 0);
  CalcMuzzlePoint(a1, &v23);
  v27[0] = v23 - 192.0;
  v27[1] = v24 - 192.0;
  v27[2] = v25 - 96.0;
  v26[0] = v23 + 192.0;
  v26[1] = v24 + 192.0;
  v26[2] = v25 + 96.0;
  v16 = trap_EntitiesInBox(v27, v26, v29, 1024, &unk_200000);
  for ( i = 0; i < v16; ++i )
  {
    v28 = (float *)&g_entities[199 * v29[i]];
    if ( (float *)a1 != v28 && (*((_DWORD *)v28 + 1) == 3 || ((_DWORD)v28[71] & 0x200000) != 0) )
    {
      v20 = v28[72] + v28[75];
      v21 = v28[73] + v28[76];
      v22 = v28[74] + v28[77];
      v20 = v20 * 0.5;
      v21 = v21 * 0.5;
      v22 = v22 * 0.5;
      v17 = v20 - v23;
      v18 = v21 - v24;
      v19 = v22 - v25;
      v12 = VectorNormalize(&v17);
      if ( v12 <= 128.0 )
      {
        v10 = v17 * v30[0] + v18 * v30[1] + v19 * v30[2];
        if ( v10 > 0.0 && v13 <= (long double)v10 )
        {
          v9 = 1132462080;
          v8 = 1.0 - (v10 - v13) / (1.0 - v13);
          *((float *)base + 2 * nmemb + 1) = v8 * 256.0;
          if ( *((_DWORD *)v28 + 1) == 3 && !BG_CanItemBeGrabbed(v28, *(_DWORD *)(a1 + 348), 0) )
          {
            *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + 10000.0;
            ++v11;
          }
          *((_DWORD *)base + 2 * nmemb) = v28;
          *((float *)base + 2 * nmemb + 1) = *((float *)base + 2 * nmemb + 1) + v12;
          ++nmemb;
        }
      }
    }
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_4DC12);
  nmemb -= v11;
  v7 = 0;
  for ( i = 0; i < (int)nmemb; ++i )
  {
    v34 = *((_DWORD *)base + 2 * i);
    v20 = *(float *)(v34 + 288) + *(float *)(v34 + 300);
    v21 = *(float *)(v34 + 292) + *(float *)(v34 + 304);
    v22 = *(float *)(v34 + 296) + *(float *)(v34 + 308);
    v20 = v20 * 0.5;
    v21 = v21 * 0.5;
    v22 = v22 * 0.5;
    if ( *(_DWORD *)(v34 + 4) == 11 && G_DObjGetWorldTagMatrix(v34, "tag_aim", v3) )
    {
      v20 = v4;
      v21 = v5;
      v22 = v6;
    }
    trap_Trace(v32, &v23, vec3_origin, vec3_origin, &v20, *(_DWORD *)(v31 + 172), 17);
    if ( v33 != 1022 )
      break;
    *((float *)base + 2 * i + 1) = *((float *)base + 2 * i + 1) + 100000.0;
    ++v7;
  }
  qsort(base, nmemb, 8u, (__compar_fn_t)sub_4DC12);
  return nmemb - v7;
}
// 13060: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 136D0: using guessed type _DWORD __cdecl BG_CanItemBeGrabbed(_DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 153A0: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0004E272) --------------------------------------------------------
int __cdecl G_CheckForCursorHints(int a1)
{
  int result; // eax
  int v2; // eax
  int v3; // [esp+10h] [ebp-2038h]
  int v4; // [esp+14h] [ebp-2034h]
  int i; // [esp+18h] [ebp-2030h]
  int v6; // [esp+1Ch] [ebp-202Ch]
  _DWORD base[2051]; // [esp+20h] [ebp-2028h] BYREF
  int v8; // [esp+202Ch] [ebp-1Ch]
  int v9; // [esp+2030h] [ebp-18h]
  int v10; // [esp+2034h] [ebp-14h]
  int v11; // [esp+2038h] [ebp-10h]
  int v12; // [esp+203Ch] [ebp-Ch]

  v12 = 0;
  v8 = *(_DWORD *)(a1 + 348);
  *(_DWORD *)(v8 + 900) = 0;
  *(_DWORD *)(v8 + 904) = 0;
  *(_WORD *)(v8 + 952) = 1023;
  result = a1;
  if ( *(int *)(a1 + 568) > 0 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 374) )
    {
      *(_DWORD *)(v8 + 900) = 0;
      v11 = 0;
      *(_DWORD *)(v8 + 904) = 0;
      v10 = 0;
      *(_DWORD *)(v8 + 908) = -1;
      v9 = -1;
      result = G_GetActivateEnt(a1, base);
      v6 = result;
      if ( result )
      {
        for ( i = 0; ; ++i )
        {
          result = i;
          if ( i >= v6 )
            return result;
          v12 = base[2 * i];
          *(_WORD *)(v8 + 952) = *(_WORD *)v12;
          if ( !v12 )
            goto LABEL_48;
          if ( *(_DWORD *)v12 == 1022 )
            break;
          if ( *(_DWORD *)(v12 + 348) )
            goto LABEL_48;
          if ( !*(_DWORD *)(v12 + 4) )
          {
            if ( *(_WORD *)(v12 + 380) == scr_const[74] )
            {
              v11 = *(_DWORD *)(v12 + 220);
              if ( *(_DWORD *)(v12 + 220) )
              {
                if ( *(_DWORD *)(v12 + 216) != 255 )
                  v9 = *(_DWORD *)(v12 + 216);
              }
            }
            goto LABEL_45;
          }
          if ( *(_DWORD *)(v12 + 4) != 11 )
          {
            if ( *(_DWORD *)(v12 + 4) == 3 )
            {
              v4 = *(_DWORD *)(v12 + 672);
              v3 = *(_DWORD *)(v4 + 32);
              if ( v3 == 1 )
              {
                if ( Com_BitCheck(*(_DWORD *)(a1 + 348) + 780, *(_DWORD *)(v4 + 36)) )
                  v2 = *(_DWORD *)(v4 + 36) + 73;
                else
                  v2 = *(_DWORD *)(v4 + 36) + 9;
                v11 = v2;
              }
              else if ( v3 )
              {
                if ( v3 == 2 )
                {
                  v11 = *(_DWORD *)(v4 + 36) + 73;
                }
                else if ( v3 == 3 )
                {
                  v11 = 7;
                }
              }
            }
            else if ( *(_DWORD *)(v12 + 4) == 5 )
            {
              if ( *(_WORD *)(v12 + 380) == scr_const[27] )
              {
                if ( *(_BYTE *)(v12 + 376) == 7 || *(_BYTE *)(v12 + 376) == 8 && *(char *)(v12 + 388) < 0 )
                {
                  v11 = 4;
                  if ( *(_DWORD *)(v12 + 688) )
                    v11 = 5;
                }
              }
              else if ( *(_WORD *)(v12 + 380) == scr_const[26]
                     && (!*(_BYTE *)(v12 + 376) || *(_BYTE *)(v12 + 376) == 1 && *(char *)(v12 + 388) < 0) )
              {
                v11 = 4;
                if ( *(_DWORD *)(v12 + 688) )
                  v11 = 5;
              }
            }
LABEL_45:
            if ( *(int *)(v12 + 220) > 0 && v11 )
              v11 = *(_DWORD *)(v12 + 220);
LABEL_48:
            *(_DWORD *)(v8 + 900) = v11;
            *(_DWORD *)(v8 + 904) = v10;
            *(_DWORD *)(v8 + 908) = v9;
            result = v8;
            if ( !*(_DWORD *)(v8 + 900) )
            {
              result = v8;
              *(_WORD *)(v8 + 952) = 1023;
            }
            return result;
          }
          if ( G_IsTurretUsable(v12, a1) )
          {
            v11 = 6;
            if ( **(_BYTE **)(BG_GetInfoForWeapon(*(_DWORD *)(v12 + 200)) + 1044) )
              v9 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(v12 + 200)) + 1048);
            goto LABEL_45;
          }
        }
        if ( (*(_DWORD *)(v8 + 940) & 8) != 0 && (*(_DWORD *)(v8 + 12) & 0x10) == 0 )
          v11 = 8;
        goto LABEL_48;
      }
    }
  }
  return result;
}
// 13040: using guessed type _DWORD __cdecl G_IsTurretUsable(_DWORD, _DWORD);
// 13A10: using guessed type _DWORD __cdecl Com_BitCheck(_DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0004E6C6) --------------------------------------------------------
_DWORD *__cdecl G_CheckForPreventFriendlyFire(_DWORD *a1)
{
  _DWORD *result; // eax
  void *v2; // [esp+2Ch] [ebp-9Ch]
  float v3[9]; // [esp+30h] [ebp-98h] BYREF
  float v4[7]; // [esp+54h] [ebp-74h] BYREF
  float v5[4]; // [esp+70h] [ebp-58h] BYREF
  char v6[40]; // [esp+80h] [ebp-48h] BYREF
  unsigned __int16 v7; // [esp+A8h] [ebp-20h]
  _DWORD *v8; // [esp+BCh] [ebp-Ch]

  *(_DWORD *)(a1[87] + 8808) = 0;
  result = a1;
  if ( !*((_BYTE *)a1 + 374) )
  {
    CalcMuzzlePoints(a1, v3);
    if ( *(_DWORD *)(a1[87] + 176) && *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1[87] + 176)) + 704) )
      v2 = &riflePriorityMap;
    else
      v2 = &bulletPriorityMap;
    v5[0] = v3[0] * 8192.0 + v4[0];
    v5[1] = v3[1] * 8192.0 + v4[1];
    v5[2] = v3[2] * 8192.0 + v4[2];
    result = (_DWORD *)trap_LocationalTrace(v6, v4, v5, *a1, 536870913, v2);
    if ( v7 <= 0x3FDu )
    {
      result = (_DWORD *)trap_LocationalTrace(v6, v4, v5, *a1, 578822145, v2);
      if ( v7 <= 0x3FDu )
      {
        v8 = &g_entities[199 * v7];
        result = (_DWORD *)*((unsigned __int16 *)v8 + 190);
        if ( (_WORD)result == scr_const[76] )
        {
          *(_DWORD *)(a1[87] + 8808) = v8;
          result = (_DWORD *)G_Trigger(v8, a1);
        }
      }
    }
  }
  return result;
}
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13EE0: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 14FA0: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);

//----- (0004E88A) --------------------------------------------------------
int G_FindTeams()
{
  int v1; // [esp+Ch] [ebp-1Ch]
  char v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  int v4; // [esp+18h] [ebp-10h]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  v2 = 0;
  v1 = 0;
  v4 = 1;
  v6 = &g_entities[199];
  while ( v4 < level[3] )
  {
    if ( *((_BYTE *)v6 + 356) && *((_WORD *)v6 + 240) && (v6[97] & 4) == 0 )
    {
      if ( *((_WORD *)v6 + 190) == scr_const[29] )
      {
        if ( (v6[96] & 8) == 0 )
          goto LABEL_18;
        v6[155] = v6;
      }
      ++v2;
      ++v1;
      v3 = v4 + 1;
      v5 = v6 + 199;
      while ( v3 < level[3] )
      {
        if ( *((_BYTE *)v5 + 356)
          && *((_WORD *)v5 + 240)
          && (v5[97] & 4) == 0
          && *((_WORD *)v6 + 240) == *((_WORD *)v5 + 240) )
        {
          ++v1;
          v5[154] = v6[154];
          v6[154] = v5;
          v5[155] = v6;
          v5[97] |= 4u;
          if ( *((_WORD *)v5 + 190) == scr_const[29] )
            trap_UnlinkEntity(v5);
        }
        ++v3;
        v5 += 199;
      }
    }
LABEL_18:
    ++v4;
    v6 += 199;
  }
  return G_Printf("%i teams with %i entities\n", v2);
}
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (0004EA6F) --------------------------------------------------------
int G_RegisterCvars()
{
  int result; // eax
  int (**v1)[72]; // [esp+1Ch] [ebp-Ch]
  int v2; // [esp+20h] [ebp-8h]

  v2 = 0;
  v1 = &gameCvarTable;
  while ( v2 < dword_83114 )
  {
    trap_Cvar_Register(*v1, v1[1], v1[2], v1[3]);
    if ( *v1 )
      v1[4] = (int (*)[72])(**v1)[1];
    ++v2;
    v1 += 6;
  }
  result = Scr_IsValidGameType((char *)&g_gametype + 16);
  if ( !result )
  {
    G_Printf("g_gametype %s is not a valid gametype, defaulting to dm\n", 112);
    trap_Cvar_Set("g_gametype", "dm");
    result = trap_Cvar_Update(&g_gametype);
  }
  return result;
}
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13C10: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 147D0: using guessed type _DWORD __cdecl Scr_IsValidGameType(_DWORD);
// 14D90: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 83114: using guessed type int dword_83114;
// 83120: using guessed type int (*gameCvarTable)[72];

//----- (0004EB48) --------------------------------------------------------
int G_UpdateCvars()
{
  int result; // eax
  int v1; // eax
  int (**i)[72]; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = 0;
  for ( i = &gameCvarTable; ; i += 6 )
  {
    result = v3;
    if ( v3 >= dword_83114 )
      break;
    if ( *i )
    {
      trap_Cvar_Update(*i);
      if ( i[4] != (int (*)[72])(**i)[1] )
      {
        i[4] = (int (*)[72])(**i)[1];
        if ( i[5] )
        {
          v1 = va(aEGameServer, (char)i[1]);
          trap_SendServerCommand(-1, 0, v1);
        }
      }
    }
    ++v3;
  }
  return result;
}
// 13C10: using guessed type _DWORD __cdecl trap_Cvar_Update(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 83114: using guessed type int dword_83114;
// 83120: using guessed type int (*gameCvarTable)[72];

//----- (0004EC08) --------------------------------------------------------
int G_SetUICvars()
{
  char v1[264]; // [esp+10h] [ebp-108h] BYREF

  trap_Cvar_VariableStringBuffer("g_allowvote", v1, 256);
  trap_Cvar_Set("ui_allowvote", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMapRestart", v1, 256);
  trap_Cvar_Set("ui_allowVoteMapRestart", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMapRotate", v1, 256);
  trap_Cvar_Set("ui_allowVoteMapRotate", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTypeMap", v1, 256);
  trap_Cvar_Set("ui_allowVoteTypeMap", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteMap", v1, 256);
  trap_Cvar_Set("ui_allowVoteMap", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteGameType", v1, 256);
  trap_Cvar_Set("ui_allowVoteGameType", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteKick", v1, 256);
  trap_Cvar_Set("ui_allowVoteKick", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteClientKick", v1, 256);
  trap_Cvar_Set("ui_allowVoteClientKick", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTempBanUser", v1, 256);
  trap_Cvar_Set("ui_allowVoteTempBanUser", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteTempBanClient", v1, 256);
  trap_Cvar_Set("ui_allowVoteTempBanClient", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteDrawFriend", v1, 256);
  trap_Cvar_Set("ui_allowVoteDrawFriend", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteKillCam", v1, 256);
  trap_Cvar_Set("ui_allowVoteKillCam", v1);
  trap_Cvar_VariableStringBuffer("g_allowVoteFriendlyFire", v1, 256);
  trap_Cvar_Set("ui_allowVoteFriendlyFire", v1);
  trap_Cvar_VariableStringBuffer("scr_drawfriend", v1, 256);
  trap_Cvar_Set("ui_drawfriend", v1);
  trap_Cvar_VariableStringBuffer("scr_friendlyfire", v1, 256);
  trap_Cvar_Set("ui_friendlyfire", v1);
  trap_Cvar_VariableStringBuffer("scr_killcam", v1, 256);
  trap_Cvar_Set("ui_killcam", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutsAllowed", v1, 256);
  trap_Cvar_Set("ui_timeoutsAllowed", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutBank", v1, 256);
  trap_Cvar_Set("ui_timeoutBank", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutLength", v1, 256);
  trap_Cvar_Set("ui_timeoutLength", v1);
  trap_Cvar_VariableStringBuffer("g_timeoutRecovery", v1, 256);
  return trap_Cvar_Set("ui_timeoutRecovery", v1);
}
// 133F0: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);

//----- (0004F086) --------------------------------------------------------
_DWORD *G_FreeEntities()
{
  _DWORD *result; // eax
  _BYTE *s; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  s = g_entities;
  for ( i = 0; i < level[3]; ++i )
  {
    if ( s[356] )
      G_FreeEntity(s);
    s += 796;
  }
  result = g_entities;
  if ( byte_C6B2C[(_DWORD)g_entities] )
    result = (_DWORD *)G_FreeEntity((char *)&dword_C69C8 + (_DWORD)g_entities);
  return result;
}
// C69C8: using guessed type int dword_C69C8;

//----- (0004F10A) --------------------------------------------------------
_DWORD *__cdecl G_InitGame(int a1, unsigned int seed, int a3, int a4)
{
  int v4; // eax
  _DWORD *result; // eax
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+4h] [ebp-834h]
  char v8; // [esp+4h] [ebp-834h]
  char v9; // [esp+4h] [ebp-834h]
  char v10[1024]; // [esp+20h] [ebp-818h] BYREF
  char s[1036]; // [esp+420h] [ebp-418h] BYREF
  int i; // [esp+82Ch] [ebp-Ch]

  Swap_Init();
  G_Printf("------- Game Initialization -------\n", v6);
  G_Printf("gamename: %s\n", (unsigned __int8)&aCallOfDuty[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  G_Printf("gamedate: %s\n", (unsigned __int8)&aNov152004[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  srand(seed);
  v4 = trap_Milliseconds();
  Rand_Init(v4);
  Scr_ParseGameTypeList();
  if ( !a3 || !a4 )
    G_RegisterCvars();
  G_ProcessIPBans();
  G_SetPlayerSize();
  memset(level, 0, 0x2E38u);
  memset(bg, 0, 0xCu);
  memset(bgs, 0, (size_t)&unk_AE2EC);
  level[7] = 1;
  level[122] = a1;
  level[125] = a1;
  level[1489] = g_timeoutBank[3];
  level[1490] = g_timeoutBank[3];
  *(int *)((char *)&dword_9B6D0 + (_DWORD)bgs) = (int)trap_Com_SoundAliasString;
  *(int *)((char *)&dword_9B6D4 + (_DWORD)bgs) = (int)G_AnimScriptSound;
  if ( g_log[16] )
  {
    if ( g_logSync[3] )
      trap_FS_FOpenFile(&g_log[16], &level[6], 3);
    else
      trap_FS_FOpenFile(&g_log[16], &level[6], 2);
    if ( level[6] )
    {
      trap_GetServerinfo(v10, 1024);
      G_LogPrintf("------------------------------------------------------------\n", v8);
      G_LogPrintf("InitGame: %s\n", (char)v10);
    }
    else
    {
      G_Printf("WARNING: Couldn't open logfile: %s\n", 176);
    }
  }
  else
  {
    G_Printf("Not logging to disk.\n", v7);
  }
  BG_SetupWeaponInfo();
  GScr_LoadScripts();
  GScr_LoadConsts();
  trap_GetConfigstring(20, s, 1024);
  Info_SetValueForKey(s, "winner", (int)"0");
  trap_SetConfigstring(20, s);
  memset(g_entities, 0, (size_t)&unk_C7000);
  level[1] = g_entities;
  level[120] = g_maxclients[3];
  memset(&g_clients, 0, (size_t)&unk_8B300);
  level[0] = &g_clients;
  for ( i = 0; i < level[120]; ++i )
    g_entities[199 * i + 87] = level[0] + 8908 * i;
  level[3] = 72;
  level[4] = 0;
  level[5] = 0;
  trap_LocateGameData(level[1], level[3], 796, level[0], 8908);
  G_ParseHitLocDmgTable();
  if ( !a3 )
    ClearRegisteredItems();
  G_InitTurrets();
  G_SpawnEntitiesFromString();
  G_FindTeams();
  G_SetUICvars();
  SaveRegisteredItems();
  G_setfog("0");
  G_InitObjectives();
  G_Printf("-----------------------------------\n", v9);
  Scr_InitSystem(1, level[122]);
  Scr_SetLoading(1);
  Scr_AllocGameVariable();
  Scr_LoadGameType();
  Scr_LoadLevel();
  Scr_StartupGameType();
  result = level;
  level[7] = 0;
  return result;
}
// 4F12D: variable 'v6' is possibly undefined
// 4F31F: variable 'v8' is possibly undefined
// 4F347: variable 'v7' is possibly undefined
// 4F510: variable 'v9' is possibly undefined
// 12ED0: using guessed type int G_SetUICvars(void);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13420: using guessed type int G_InitTurrets(void);
// 13450: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 13540: using guessed type int Scr_LoadLevel(void);
// 13580: using guessed type _DWORD __cdecl trap_GetServerinfo(_DWORD, _DWORD);
// 137E0: using guessed type int BG_SetupWeaponInfo(void);
// 13930: using guessed type int trap_Milliseconds(void);
// 13A60: using guessed type _DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13CE0: using guessed type int G_SetPlayerSize(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 13E90: using guessed type int G_FindTeams(void);
// 14090: using guessed type int G_ParseHitLocDmgTable(void);
// 14100: using guessed type int GScr_LoadScripts(void);
// 141C0: using guessed type _DWORD __cdecl Rand_Init(_DWORD);
// 14440: using guessed type int Scr_ParseGameTypeList(void);
// 14500: using guessed type int ClearRegisteredItems(void);
// 148E0: using guessed type int G_ProcessIPBans(void);
// 14A00: using guessed type _DWORD __cdecl Scr_SetLoading(_DWORD);
// 14A60: using guessed type int G_InitObjectives(void);
// 14C30: using guessed type int SaveRegisteredItems(void);
// 14DD0: using guessed type int Swap_Init(void);
// 15060: using guessed type int Scr_AllocGameVariable(void);
// 153D0: using guessed type int GScr_LoadConsts(void);
// 15410: using guessed type int Scr_StartupGameType(void);
// 154A0: using guessed type _DWORD __cdecl Scr_InitSystem(_DWORD, _DWORD);
// 15550: using guessed type int Scr_LoadGameType(void);
// 15560: using guessed type int G_SpawnEntitiesFromString(void);
// 156A0: using guessed type int G_RegisterCvars(void);
// 685BC: using guessed type int __cdecl trap_Com_SoundAliasString(int);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// 9B6D0: using guessed type int dword_9B6D0;
// 9B6D4: using guessed type int dword_9B6D4;

//----- (0004F567) --------------------------------------------------------
int __cdecl G_ShutdownGame(int a1)
{
  char v2; // [esp+4h] [ebp-4h]
  char v3; // [esp+4h] [ebp-4h]
  char v4; // [esp+4h] [ebp-4h]

  if ( a1 )
    G_Printf("==== RestartGame ====\n", v2);
  else
    G_Printf("==== ShutdownGame ====\n", v2);
  if ( level[6] )
  {
    if ( a1 )
      G_LogPrintf("RestartGame:\n", v3);
    else
      G_LogPrintf("ShutdownGame:\n", v3);
    G_LogPrintf("------------------------------------------------------------\n", v4);
    trap_FS_FCloseFile(level[6]);
  }
  G_FreeEntities();
  HudElem_DestroyAll();
  if ( Scr_IsSystemActive(1) )
  {
    if ( !level[2141] )
      trap_FreeClientScriptPers();
    Scr_FreeGameVariable(level[2141] == 0);
    Scr_ShutdownSystem(1);
  }
  GScr_FreeScripts();
  Scr_FreeScripts(1);
  return trap_FreeWeaponInfoMemory(0);
}
// 4F588: variable 'v2' is possibly undefined
// 4F5B8: variable 'v3' is possibly undefined
// 4F5D6: variable 'v4' is possibly undefined
// 12F50: using guessed type int GScr_FreeScripts(void);
// 13170: using guessed type _DWORD __cdecl Scr_FreeScripts(_DWORD);
// 13B90: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 13D80: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 142D0: using guessed type _DWORD __cdecl Scr_ShutdownSystem(_DWORD);
// 142F0: using guessed type int G_FreeEntities(void);
// 14D80: using guessed type int trap_FreeClientScriptPers(void);
// 15220: using guessed type int HudElem_DestroyAll(void);
// 15720: using guessed type _DWORD __cdecl trap_FreeWeaponInfoMemory(_DWORD);
// 159D0: using guessed type _DWORD __cdecl Scr_FreeGameVariable(_DWORD);

//----- (0004F664) --------------------------------------------------------
int Com_Error(int a1, char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+438h] [ebp+10h] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return G_Error("%s", (char)s);
}

//----- (0004F6BC) --------------------------------------------------------
int Com_Printf(char *format, ...)
{
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return G_Printf("%s", (char)s);
}

//----- (0004F714) --------------------------------------------------------
_DWORD *Com_DPrintf(char *format, ...)
{
  _DWORD *result; // eax
  char s[1036]; // [esp+10h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+41Ch] [ebp-Ch]
  va_list va; // [esp+434h] [ebp+Ch] BYREF

  va_start(va, format);
  result = g_developer;
  if ( g_developer[3] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    result = (_DWORD *)G_Printf("%s", (char)s);
  }
  return result;
}

//----- (0004F778) --------------------------------------------------------
_DWORD *SendScoreboardMessageToAllIntermissionClients()
{
  _DWORD *result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = level;
  if ( level[131] )
  {
    for ( i = 0; i < level[120]; ++i )
    {
      v1 = level[0] + 8908 * i;
      if ( *(_DWORD *)(v1 + 8424) == 2 && *(_DWORD *)(v1 + 4) == 5 )
        DeathmatchScoreboardMessage(&g_entities[199 * i]);
    }
    result = level;
    level[131] = 0;
  }
  return result;
}
// 153B0: using guessed type _DWORD __cdecl DeathmatchScoreboardMessage(_DWORD);

//----- (0004F818) --------------------------------------------------------
int __cdecl sub_4F818(_DWORD *a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-10h]
  _DWORD *v4; // [esp+4h] [ebp-Ch]
  _DWORD *v5; // [esp+8h] [ebp-8h]

  v5 = (_DWORD *)(level[0] + 8908 * *a1);
  v4 = (_DWORD *)(level[0] + 8908 * *a2);
  if ( v5[2106] == 1 )
    return 1;
  if ( v4[2106] == 1 )
    return -1;
  if ( v5[2145] == 3 && v4[2145] == 3 )
  {
    if ( v5 >= v4 )
      v3 = v5 > v4;
    else
      v3 = -1;
  }
  else if ( v5[2145] == 3 )
  {
    v3 = 1;
  }
  else if ( v4[2145] == 3 )
  {
    v3 = -1;
  }
  else if ( v5[2103] <= v4[2103] )
  {
    if ( v5[2103] >= v4[2103] )
    {
      if ( v5[2104] >= v4[2104] )
        v3 = v5[2104] > v4[2104];
      else
        v3 = -1;
    }
    else
    {
      v3 = 1;
    }
  }
  else
  {
    v3 = -1;
  }
  return v3;
}

//----- (0004F983) --------------------------------------------------------
_DWORD *CalculateRanks()
{
  _DWORD *result; // eax
  int i; // [esp+10h] [ebp-8h]

  level[133] = 0;
  level[714] = 0;
  for ( i = 0; i < level[120]; ++i )
  {
    if ( *(_DWORD *)(level[0] + 8908 * i + 8424) )
    {
      level[level[133]++ + 134] = i;
      if ( *(_DWORD *)(level[0] + 8908 * i + 8580) != 3 && *(_DWORD *)(level[0] + 8908 * i + 8424) == 2 )
        ++level[714];
    }
  }
  qsort(&level[134], level[133], 4u, (__compar_fn_t)sub_4F818);
  result = level;
  level[131] = 1;
  return result;
}

//----- (0004FAB5) --------------------------------------------------------
int ExitLevel()
{
  char v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  trap_SendConsoleCommand(2, "map_rotate\n");
  level[127] = 0;
  level[128] = 0;
  for ( i = 0; i < g_maxclients[3]; ++i )
  {
    v2 = level[0] + 8908 * i;
    if ( *(_DWORD *)(v2 + 8424) == 2 )
      *(_DWORD *)(v2 + 8412) = 0;
  }
  for ( j = 0; j < g_maxclients[3]; ++j )
  {
    if ( *(_DWORD *)(level[0] + 8908 * j + 8424) == 2 )
      *(_DWORD *)(level[0] + 8908 * j + 8424) = 1;
  }
  return G_LogPrintf("ExitLevel: executed\n", v1);
}
// 4FBAC: variable 'v1' is possibly undefined
// 149C0: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);

//----- (0004FBB7) --------------------------------------------------------
_DWORD *G_LogPrintf(char *format, ...)
{
  _DWORD *result; // eax
  size_t v2; // eax
  char s[1024]; // [esp+30h] [ebp-818h] BYREF
  char v4[1036]; // [esp+430h] [ebp-418h] BYREF
  __gnuc_va_list __varargs; // [esp+83Ch] [ebp-Ch]
  va_list va; // [esp+854h] [ebp+Ch] BYREF

  va_start(va, format);
  result = level;
  if ( level[6] )
  {
    va_copy(__varargs, va);
    vsprintf(s, format, va);
    Com_sprintf(v4, 0x400u, "%3i:%i%i %s", level[122] / 1000 / 60);
    v2 = strlen(v4);
    result = (_DWORD *)trap_FS_Write(v4, v2, level[6]);
  }
  return result;
}
// 157D0: using guessed type _DWORD __cdecl trap_FS_Write(_DWORD, _DWORD, _DWORD);

//----- (0004FD1B) --------------------------------------------------------
_DWORD *CheckVote()
{
  int v0; // eax
  _DWORD *result; // eax
  int v2; // [esp+Ch] [ebp-Ch]

  if ( level[711] )
  {
    if ( level[711] < trap_Milliseconds() )
    {
      level[711] = 0;
      v0 = va((char *)&off_7AD61, 56);
      trap_SendConsoleCommand(2, v0);
    }
  }
  result = level;
  if ( level[710] )
  {
    if ( trap_Milliseconds() - level[710] < 0 )
    {
      v2 = level[714] / 2 + 1;
      if ( level[712] >= v2 )
      {
        trap_SendServerCommand(-1, 0, "e \"GAME_VOTEPASSED\"");
        level[711] = trap_Milliseconds() + 3000;
LABEL_10:
        level[710] = 0;
        return (_DWORD *)trap_SetConfigstring(15, &unk_7A10A);
      }
      result = (_DWORD *)(level[714] - v2);
      if ( level[713] <= (int)result )
        return result;
    }
    trap_SendServerCommand(-1, 0, "e \"GAME_VOTEFAILED\"");
    goto LABEL_10;
  }
  return result;
}
// 13930: using guessed type int trap_Milliseconds(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 149C0: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 7AD61: using guessed type void *off_7AD61;

//----- (0004FEA8) --------------------------------------------------------
_DWORD *CheckMatchTimeout()
{
  _DWORD *result; // eax
  int v1; // esi
  int v2; // eax
  char v3; // [esp+Ch] [ebp-Ch]

  if ( level[1495] && level[1495] < trap_Milliseconds() )
  {
    level[1495] = 0;
    trap_SetConfigstring(1628, &unk_7A10A);
    result = (_DWORD *)trap_Cvar_Set("timescale", "1");
  }
  else
  {
    result = level;
    if ( level[1493] )
    {
      v1 = level[1493] + level[1494];
      result = (_DWORD *)trap_Milliseconds();
      if ( v1 <= (int)result )
      {
        Com_sprintf((char *)&level[1233], 0x400u, aPatch15Timeout_1, v3);
        if ( level[1496] == 2 )
          level[1489] -= level[1493];
        else
          level[1490] -= level[1493];
        level[1493] = 0;
        level[1495] = g_timeoutRecovery[3] + trap_Milliseconds();
        v2 = va("%i", g_timeoutRecovery[3]);
        trap_SetConfigstring(1628, v2);
        trap_SetConfigstring(1629, &level[1233]);
        result = (_DWORD *)trap_SendServerCommand(-1, 0, "e \"PATCH_1_5_TIMEOUT_EXPIRED\"");
      }
    }
  }
  return result;
}
// 4FF7B: variable 'v3' is possibly undefined
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13930: using guessed type int trap_Milliseconds(void);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00050078) --------------------------------------------------------
int G_UpdateObjectiveToClients()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // [esp+0h] [ebp-1Ch]
  int v3; // [esp+4h] [ebp-18h]
  _DWORD *v4; // [esp+8h] [ebp-14h]
  int j; // [esp+Ch] [ebp-10h]
  int v6; // [esp+10h] [ebp-Ch]
  int i; // [esp+14h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[120] )
      break;
    v6 = level[1] + 796 * i;
    if ( *(_BYTE *)(v6 + 356) )
    {
      v3 = *(_DWORD *)(v6 + 348);
      v2 = *(_DWORD *)(v3 + 8580);
      for ( j = 0; j <= 15; ++j )
      {
        v4 = &level[7 * j + 8];
        if ( *v4 && (!v4[5] || v4[5] == v2) )
        {
          v1 = (_DWORD *)(v3 + 28 * j + 992);
          v1[2] = *v4;
          v1[3] = v4[1];
          v1[4] = v4[2];
          v1[5] = v4[3];
          v1[6] = v4[4];
          v1[7] = v4[5];
          v1[8] = v4[6];
        }
        else
        {
          *(_DWORD *)(v3 + 28 * j + 1000) = 0;
        }
      }
    }
  }
  return result;
}

//----- (000501B8) --------------------------------------------------------
int G_UpdateHudElemsToClients()
{
  int result; // eax
  int v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= level[120] )
      break;
    v1 = level[1] + 796 * i;
    if ( *(_BYTE *)(v1 + 356) )
      HudElem_UpdateClient(*(_DWORD *)(v1 + 348), *(_DWORD *)v1, 3);
  }
  return result;
}
// 15200: using guessed type _DWORD __cdecl HudElem_UpdateClient(_DWORD, _DWORD, _DWORD);

//----- (00050236) --------------------------------------------------------
int __cdecl G_RunThink(int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  int v3; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)(a1 + 516);
  v3 = result;
  if ( result > 0 )
  {
    result = *(_DWORD *)(a1 + 516);
    if ( v3 <= level[122] )
    {
      *(_DWORD *)(a1 + 516) = 0;
      if ( !*(_DWORD *)(a1 + 520) )
        G_Error("NULL ent->think", v2);
      result = (*(int (__cdecl **)(int))(a1 + 520))(a1);
    }
  }
  return result;
}
// 50291: variable 'v2' is possibly undefined

//----- (000502AD) --------------------------------------------------------
int *DebugDumpAnims()
{
  int *result; // eax

  result = g_dumpAnims;
  if ( g_dumpAnims[3] >= 0 )
  {
    result = g_dumpAnims;
    if ( g_dumpAnims[3] <= 1023 )
      result = (int *)trap_DObjDisplayAnim(level[1] + 796 * g_dumpAnims[3]);
  }
  return result;
}
// 158C0: using guessed type _DWORD __cdecl trap_DObjDisplayAnim(_DWORD);

//----- (00050300) --------------------------------------------------------
int __cdecl G_XAnimUpdateEnt(int a1)
{
  int result; // eax

  while ( 1 )
  {
    result = a1;
    if ( !*(_BYTE *)(a1 + 356) )
      break;
    result = *(_DWORD *)(a1 + 388) & 0x4000;
    if ( result )
      break;
    result = G_DObjUpdateServerTime(a1, 1);
    if ( !result )
      break;
    Scr_RunCurrentThreads();
  }
  return result;
}
// 13020: using guessed type _DWORD __cdecl G_DObjUpdateServerTime(_DWORD, _DWORD);
// 14910: using guessed type int Scr_RunCurrentThreads(void);

//----- (00050357) --------------------------------------------------------
int G_XAnimUpdate()
{
  int result; // eax
  float v1; // [esp+4h] [ebp-14h]
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  v2 = g_entities;
  for ( i = 0; i < level[3]; ++i )
  {
    if ( *((_BYTE *)v2 + 356) )
    {
      v1 = (long double)(int)level[124] * 0.001;
      trap_DObjInitServerTime(v2, LODWORD(v1));
    }
    v2 += 199;
  }
  v3 = g_entities;
  for ( j = 0; ; ++j )
  {
    result = j;
    if ( j >= level[3] )
      break;
    G_XAnimUpdateEnt(v3);
    v3 += 199;
  }
  return result;
}
// 13F10: using guessed type _DWORD __cdecl trap_DObjInitServerTime(_DWORD, _DWORD);
// 14770: using guessed type _DWORD __cdecl G_XAnimUpdateEnt(_DWORD);

//----- (00050409) --------------------------------------------------------
void *__cdecl sub_50409(void *s)
{
  void *result; // eax
  unsigned int v2; // edx
  unsigned int v3; // edx

  result = (void *)*((_DWORD *)s + 103);
  if ( result != (void *)level[121] )
  {
    *((_DWORD *)s + 103) = level[121];
    if ( !*((_DWORD *)s + 87) )
    {
      if ( (*((_DWORD *)s + 97) & 0x1000) != 0 )
        v2 = *((_DWORD *)s + 2) | 0x100;
      else
        v2 = *((_DWORD *)s + 2) & 0xFFFFFEFF;
      *((_DWORD *)s + 2) = v2;
    }
    if ( level[122] - *((_DWORD *)s + 98) > 300 )
    {
      if ( *((_DWORD *)s + 99) )
        return (void *)G_FreeEntity(s);
      if ( *((_DWORD *)s + 100) )
      {
        *((_DWORD *)s + 100) = 0;
        trap_UnlinkEntity(s);
      }
    }
    v3 = (*((_DWORD *)s + 2) & 0x10) != 0 ? *((_DWORD *)s + 61) | 0x200 : *((_DWORD *)s + 61) & 0xFFFFFDFF;
    *((_DWORD *)s + 61) = v3;
    result = s;
    if ( !*((_DWORD *)s + 99) )
    {
      if ( *((_DWORD *)s + 1) == 4 )
        return (void *)G_RunMissile(s);
      if ( *((_DWORD *)s + 1) == 3 )
      {
        if ( *((_DWORD *)s + 187) )
        {
          G_GeneralLink(s);
          return (void *)G_RunThink(s);
        }
        return (void *)G_RunItem(s);
      }
      if ( *((_BYTE *)s + 357) )
        return (void *)G_RunItem(s);
      if ( *((_DWORD *)s + 1) == 5 || *((_DWORD *)s + 1) == 8 )
      {
        result = (void *)G_RunMover(s);
      }
      else if ( *((_DWORD *)s + 87) )
      {
        result = (void *)G_RunClient(s);
      }
      else
      {
        result = (void *)G_RunThink(s);
      }
    }
  }
  return result;
}
// 13B50: using guessed type _DWORD __cdecl G_RunMover(_DWORD);
// 142E0: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14A10: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);
// 15050: using guessed type _DWORD __cdecl G_RunClient(_DWORD);

//----- (000505F5) --------------------------------------------------------
int __cdecl G_RunFrame(int a1)
{
  unsigned __int16 *v1; // ecx
  int v2; // eax
  char s[1028]; // [esp+10h] [ebp-428h] BYREF
  int v5; // [esp+414h] [ebp-24h]
  unsigned __int16 *v6; // [esp+418h] [ebp-20h]
  char v7[5]; // [esp+41Fh] [ebp-19h]
  _DWORD *v8; // [esp+424h] [ebp-14h]
  void *v9; // [esp+428h] [ebp-10h]
  int v10[3]; // [esp+42Ch] [ebp-Ch]

  ++level[121];
  level[123] = level[122];
  level[122] = a1;
  level[124] = level[122] - level[123];
  bg[0] = level[122];
  bg[1] = level[122];
  bg[2] = level[124];
  G_UpdateCvars();
  memset(s, 0, 0x400u);
  v7[0] = 0;
  do
  {
    v7[4] = 0;
    *(_DWORD *)v7 = (unsigned __int8)(v7[0] + 1);
    for ( v10[0] = 0; v10[0] < level[2948]; ++v10[0] )
    {
      v6 = (unsigned __int16 *)&level[3 * v10[0] + 2180];
      v5 = *v6;
      v9 = &g_entities[199 * v5];
      if ( *((_DWORD *)v9 + 194) == *((_DWORD *)v6 + 1) )
      {
        v8 = &g_entities[199 * v6[1]];
        if ( v8[194] == *((_DWORD *)v6 + 2) )
        {
          if ( s[v5] == v7[0] )
          {
            *(_DWORD *)&v7[1] = 1;
            continue;
          }
          s[v5] = v7[0];
          Scr_AddEntity(v8);
          Scr_Notify(v9, scr_const[73], 1);
        }
      }
      --level[2948];
      --v10[0];
      v1 = v6;
      v2 = 3 * level[2948];
      *(_DWORD *)v6 = level[v2 + 2180];
      *((_DWORD *)v1 + 1) = level[v2 + 2181];
      *((_DWORD *)v1 + 2) = level[v2 + 2182];
    }
    Scr_RunCurrentThreads();
  }
  while ( *(_DWORD *)&v7[1] );
  level[2948] = 0;
  G_XAnimUpdate();
  Scr_SetTime(level[122]);
  if ( *(float *)&level[2952] != g_bounds_width[2] || *(float *)&level[2953] != *(float *)&g_bounds_height_standing[2] )
  {
    level[2952] = LODWORD(g_bounds_width[2]);
    level[2953] = g_bounds_height_standing[2];
    G_SetPlayerSize();
    v9 = g_entities;
    v10[0] = 0;
    while ( v10[0] <= 63 )
    {
      if ( *((_BYTE *)v9 + 356) )
      {
        *((_DWORD *)v9 + 65) = playerMins[0];
        *((_DWORD *)v9 + 66) = playerMins[1];
        *((_DWORD *)v9 + 67) = playerMins[2];
        *((_DWORD *)v9 + 68) = playerMaxs[0];
        *((_DWORD *)v9 + 69) = playerMaxs[1];
        *((_DWORD *)v9 + 70) = playerMaxs[2];
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 804) = *((_DWORD *)v9 + 65);
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 808) = *((_DWORD *)v9 + 66);
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 812) = *((_DWORD *)v9 + 67);
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 816) = *((_DWORD *)v9 + 68);
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 820) = *((_DWORD *)v9 + 69);
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 824) = *((_DWORD *)v9 + 70);
        trap_LinkEntity(v9);
      }
      ++v10[0];
      v9 = (char *)v9 + 796;
    }
  }
  if ( *(float *)&level[2954] != *(float *)&bg_viewheight_standing[2]
    || *(float *)&level[2955] != *(float *)&bg_viewheight_crouched[2]
    || *(float *)&level[2956] != *(float *)&bg_viewheight_prone[2] )
  {
    level[2954] = bg_viewheight_standing[2];
    level[2955] = bg_viewheight_crouched[2];
    level[2956] = bg_viewheight_prone[2];
    v9 = g_entities;
    v10[0] = 0;
    while ( v10[0] <= 63 )
    {
      if ( *((_BYTE *)v9 + 356) )
      {
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 828) = bg_viewheight_prone[3];
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 832) = bg_viewheight_crouched[3];
        *(_DWORD *)(*((_DWORD *)v9 + 87) + 836) = bg_viewheight_standing[3];
      }
      ++v10[0];
      v9 = (char *)v9 + 796;
    }
  }
  v9 = g_entities;
  v10[0] = 0;
  while ( v10[0] < level[3] )
  {
    if ( *((_BYTE *)v9 + 356) )
    {
      if ( *((_DWORD *)v9 + 187) )
        sub_50409(**((void ***)v9 + 187));
      sub_50409(v9);
    }
    ++v10[0];
    v9 = (char *)v9 + 796;
  }
  G_UpdateObjectiveToClients();
  G_UpdateHudElemsToClients();
  v9 = g_entities;
  v10[0] = 0;
  while ( v10[0] < level[120] )
  {
    if ( *((_BYTE *)v9 + 356) )
      ClientEndFrame(v9);
    ++v10[0];
    v9 = (char *)v9 + 796;
  }
  CheckTeamStatus();
  CheckVote();
  CheckMatchTimeout();
  SendScoreboardMessageToAllIntermissionClients();
  if ( g_listEntity[3] )
  {
    for ( v10[0] = 0; v10[0] <= 1023; ++v10[0] )
    {
      SL_ConvertToString(LOWORD(g_entities[199 * v10[0] + 95]));
      G_Printf("%4i: %s\n", v10[0]);
    }
    trap_Cvar_Set("g_listEntity", "0");
  }
  if ( level[2957] )
    SaveRegisteredItems();
  return DebugDumpAnims();
}
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13480: using guessed type int CheckVote(void);
// 139C0: using guessed type int CheckMatchTimeout(void);
// 13AA0: using guessed type int DebugDumpAnims(void);
// 13B20: using guessed type int G_UpdateHudElemsToClients(void);
// 13BE0: using guessed type int SendScoreboardMessageToAllIntermissionClients(void);
// 13CE0: using guessed type int G_SetPlayerSize(void);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14340: using guessed type int CheckTeamStatus(void);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14760: using guessed type int G_UpdateObjectiveToClients(void);
// 147F0: using guessed type int G_UpdateCvars(void);
// 14910: using guessed type int Scr_RunCurrentThreads(void);
// 14C30: using guessed type int SaveRegisteredItems(void);
// 14FD0: using guessed type int G_XAnimUpdate(void);
// 150D0: using guessed type _DWORD __cdecl Scr_SetTime(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15990: using guessed type _DWORD __cdecl ClientEndFrame(_DWORD);

//----- (00050C9E) --------------------------------------------------------
void sub_50C9E()
{
  ;
}

//----- (00050CA4) --------------------------------------------------------
int __cdecl SP_info_camp(int a1)
{
  return G_SetOrigin(a1, a1 + 312);
}
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00050CD3) --------------------------------------------------------
int __cdecl SP_info_null(void *s)
{
  return G_FreeEntity(s);
}

//----- (00050CF6) --------------------------------------------------------
int __cdecl SP_info_notnull(int a1)
{
  return G_SetOrigin(a1, a1 + 312);
}
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00050D25) --------------------------------------------------------
int __cdecl SP_light(void *s)
{
  return G_FreeEntity(s);
}

//----- (00050D48) --------------------------------------------------------
int __cdecl TeleportPlayer(_DWORD *a1, _DWORD *a2, int a3)
{
  int result; // eax
  int v4; // [esp+1Ch] [ebp-Ch]

  if ( !*(_DWORD *)(a1[87] + 8396) )
  {
    *(_DWORD *)(G_TempEntity(a1[87] + 20, 200) + 144) = a1[36];
    *(_DWORD *)(G_TempEntity(a2, 199) + 144) = a1[36];
  }
  v4 = a1[60];
  trap_UnlinkEntity(a1);
  *(_DWORD *)(a1[87] + 20) = *a2;
  *(_DWORD *)(a1[87] + 24) = a2[1];
  *(_DWORD *)(a1[87] + 28) = a2[2];
  *(float *)(a1[87] + 28) = *(float *)(a1[87] + 28) + 1.0;
  *(_DWORD *)(a1[87] + 128) ^= 8u;
  SetClientViewAngle(a1, a3);
  BG_PlayerStateToEntityState(a1[87], a1, 1);
  a1[78] = *(_DWORD *)(a1[87] + 20);
  a1[79] = *(_DWORD *)(a1[87] + 24);
  result = *(_DWORD *)(a1[87] + 28);
  a1[80] = result;
  if ( v4 )
    result = trap_LinkEntity(a1);
  return result;
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14B90: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00050FB2) --------------------------------------------------------
void SP_misc_teleporter_dest()
{
  ;
}

//----- (00050FB7) --------------------------------------------------------
int __cdecl SP_misc_model(void *s)
{
  return G_FreeEntity(s);
}

//----- (00050FDA) --------------------------------------------------------
int __cdecl use_corona(int a1)
{
  if ( *(_DWORD *)(a1 + 240) )
    return trap_UnlinkEntity(a1);
  *(_BYTE *)(a1 + 374) = 0;
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (00051020) --------------------------------------------------------
int __cdecl SP_corona(void *s)
{
  return G_FreeEntity(s);
}

//----- (00051043) --------------------------------------------------------
_BOOL4 G_IsInMatchTimeout()
{
  return level[124] == 0;
}

//----- (00051068) --------------------------------------------------------
int *G_InitTurrets()
{
  int *result; // eax
  int i; // [esp+0h] [ebp-8h] BYREF

  for ( i = 0; i <= 31; ++i )
  {
    dword_A5DC0[16 * i] = 0;
    result = &i;
  }
  return result;
}

//----- (000510A9) --------------------------------------------------------
int __cdecl sub_510A9(int a1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-B0h]
  float v5; // [esp+1Ch] [ebp-ACh]
  float v6[4]; // [esp+20h] [ebp-A8h] BYREF
  float v7[4]; // [esp+30h] [ebp-98h] BYREF
  char v8[48]; // [esp+40h] [ebp-88h] BYREF
  float v9; // [esp+70h] [ebp-58h]
  float v10; // [esp+74h] [ebp-54h]
  float v11; // [esp+78h] [ebp-50h]
  char v12[48]; // [esp+80h] [ebp-48h] BYREF
  float v13; // [esp+B0h] [ebp-18h]
  float v14; // [esp+B4h] [ebp-14h]
  float v15; // [esp+B8h] [ebp-10h]

  if ( G_DObjGetWorldTagMatrix(a1, "tag_flash", v12) )
  {
    if ( G_DObjGetWorldTagMatrix(a1, "tag_player", v8) )
    {
      v6[0] = *(float *)(a1 + 104) + *(float *)(a1 + 324);
      v6[1] = *(float *)(a1 + 108) + *(float *)(a1 + 328);
      v6[2] = 0.0;
      AngleVectors(v6, a3, a3 + 12, a3 + 24);
      *(_DWORD *)(a3 + 48) = *(_DWORD *)a3;
      *(_DWORD *)(a3 + 52) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a3 + 56) = *(_DWORD *)(a3 + 8);
      v7[0] = v13 - v9;
      v7[1] = v14 - v10;
      v7[2] = v15 - v11;
      v5 = VectorNormalize(v7);
      *(float *)(a3 + 36) = *(float *)a3 * v5 + v9;
      *(float *)(a3 + 40) = *(float *)(a3 + 4) * v5 + v10;
      *(float *)(a3 + 44) = *(float *)(a3 + 8) * v5 + v11;
      v4 = 1;
    }
    else
    {
      SL_ConvertToString(*(unsigned __int16 *)(a1 + 380));
      Com_Printf(
        "Couldn't find %s on turret (entity %d, classname '%s').\n",
        (unsigned __int8)&aTagPlayer[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      v4 = 0;
    }
  }
  else
  {
    SL_ConvertToString(*(unsigned __int16 *)(a1 + 380));
    Com_Printf(
      "Couldn't find %s on turret (entity %d, classname '%s').\n",
      (unsigned __int8)&aTagFlash[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    v4 = 0;
  }
  return v4;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 153A0: using guessed type _DWORD __cdecl G_DObjGetWorldTagMatrix(_DWORD, _DWORD, _DWORD);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (000512A2) --------------------------------------------------------
int __cdecl sub_512A2(int a1, char *a2, int a3)
{
  int result; // eax
  char *v4; // [esp+28h] [ebp-50h]
  int v5[15]; // [esp+30h] [ebp-48h] BYREF
  int v6; // [esp+6Ch] [ebp-Ch]

  if ( a2 == &byte_C6CE4[(_DWORD)g_entities] )
    v4 = (char *)&dword_C69C8 + (_DWORD)g_entities;
  else
    v4 = a2;
  result = sub_510A9(a1, (int)v4, (int)v5);
  if ( result )
  {
    v6 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    if ( *(_DWORD *)(v6 + 112) )
      Weapon_RocketLauncher_Fire(a1, 0.0, (int)v5);
    else
      Bullet_Fire((int)v4, 0.0, a3, (int)v5, a1);
    result = G_AddEvent(a1, 168, 0);
  }
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// C69C8: using guessed type int dword_C69C8;

//----- (00051389) --------------------------------------------------------
int __cdecl sub_51389(int a1, float *a2)
{
  int result; // eax
  char v3; // al
  char v4; // al
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  long double v8; // fst7
  long double v9; // fst7
  long double v10; // fst7
  long double v11; // fst7
  char v12; // [esp+4h] [ebp-1D4h]
  char v13; // [esp+4h] [ebp-1D4h]
  float v14; // [esp+8h] [ebp-1D0h]
  float v15; // [esp+8h] [ebp-1D0h]
  float v16; // [esp+8h] [ebp-1D0h]
  float v17; // [esp+8h] [ebp-1D0h]
  float v18; // [esp+2Ch] [ebp-1ACh]
  float v19; // [esp+30h] [ebp-1A8h]
  float v20; // [esp+34h] [ebp-1A4h]
  float v21; // [esp+38h] [ebp-1A0h]
  float v22; // [esp+3Ch] [ebp-19Ch]
  float v23; // [esp+40h] [ebp-198h]
  float v24; // [esp+44h] [ebp-194h]
  float v25; // [esp+4Ch] [ebp-18Ch]
  float v26; // [esp+4Ch] [ebp-18Ch]
  float v27; // [esp+4Ch] [ebp-18Ch]
  float v28; // [esp+4Ch] [ebp-18Ch]
  float v29; // [esp+4Ch] [ebp-18Ch]
  float v30; // [esp+4Ch] [ebp-18Ch]
  float v31; // [esp+4Ch] [ebp-18Ch]
  float v32[12]; // [esp+50h] [ebp-188h] BYREF
  int v33[4]; // [esp+80h] [ebp-158h] BYREF
  int v34[2]; // [esp+90h] [ebp-148h] BYREF
  int v35; // [esp+98h] [ebp-140h]
  float v36; // [esp+A0h] [ebp-138h]
  float v37; // [esp+A4h] [ebp-134h]
  float v38; // [esp+A8h] [ebp-130h]
  int v39; // [esp+B0h] [ebp-128h] BYREF
  int v40; // [esp+B4h] [ebp-124h] BYREF
  int v41; // [esp+B8h] [ebp-120h] BYREF
  int v42; // [esp+BCh] [ebp-11Ch]
  int v43; // [esp+C0h] [ebp-118h]
  int v44; // [esp+C4h] [ebp-114h]
  float *v46; // [esp+CCh] [ebp-10Ch]
  char v47[36]; // [esp+D0h] [ebp-108h] BYREF
  int v48; // [esp+F4h] [ebp-E4h]
  int v49; // [esp+F8h] [ebp-E0h]
  int v50; // [esp+FCh] [ebp-DCh]
  int v51[15]; // [esp+100h] [ebp-D8h] BYREF
  int v52; // [esp+13Ch] [ebp-9Ch]
  char v53[24]; // [esp+140h] [ebp-98h] BYREF
  float v54; // [esp+158h] [ebp-80h]
  float v55; // [esp+15Ch] [ebp-7Ch]
  float v56; // [esp+160h] [ebp-78h]
  float v57; // [esp+164h] [ebp-74h]
  float v58; // [esp+168h] [ebp-70h]
  float v59; // [esp+16Ch] [ebp-6Ch]
  int v60[2]; // [esp+170h] [ebp-68h] BYREF
  float v61; // [esp+178h] [ebp-60h]
  char v62[12]; // [esp+180h] [ebp-58h] BYREF
  float v63; // [esp+18Ch] [ebp-4Ch]
  float v64; // [esp+190h] [ebp-48h]
  float v65; // [esp+194h] [ebp-44h]
  float v66; // [esp+198h] [ebp-40h]
  float v67; // [esp+19Ch] [ebp-3Ch]
  float v68; // [esp+1A0h] [ebp-38h]
  float v69; // [esp+1A4h] [ebp-34h]
  float v70; // [esp+1A8h] [ebp-30h]
  int v71; // [esp+1ACh] [ebp-2Ch]
  int v72; // [esp+1B0h] [ebp-28h]
  int v73; // [esp+1B4h] [ebp-24h]
  int v74; // [esp+1B8h] [ebp-20h]
  int v75; // [esp+1BCh] [ebp-1Ch]
  int v76; // [esp+1C0h] [ebp-18h]
  int v77; // [esp+1C4h] [ebp-14h]
  int v78; // [esp+1C8h] [ebp-10h]
  int v79; // [esp+1CCh] [ebp-Ch]

  v78 = *(_DWORD *)(a1 + 144);
  v73 = (int)&unk_9B6EC + 1200 * v78 + (_DWORD)bgs;
  v72 = v73 + 896;
  result = v73 + 896;
  if ( *(_DWORD *)(v73 + 912) )
  {
    result = v72;
    if ( *(_DWORD *)(v72 + 20) )
    {
      result = *(_DWORD *)(*(_DWORD *)(v72 + 20) + 80) & 4;
      if ( result )
      {
        v46 = (float *)G_DObjGetLocalTagMatrix(a2, "tag_weapon");
        if ( !v46 )
          return Com_Printf("WARNING: aborting player positioning on turret since 'tag_weapon' does not exist\n", v12);
        v71 = BG_GetInfoForWeapon(*((_DWORD *)a2 + 50));
        v44 = *(_DWORD *)(v73 + 1192);
        v43 = *(int *)((char *)&dword_9B6C0 + (_DWORD)bgs);
        HIWORD(v42) = Scr_GetAnimsIndex(v43);
        LOWORD(v42) = *(_WORD *)(v72 + 16) & 0xFDFF;
        v70 = vectosignedyaw(v46);
        AnglesToAxis(a2 + 81, v53);
        v57 = a2[78];
        v58 = a2[79];
        v59 = a2[80];
        v36 = *(float *)(a1 + 312) - v57;
        v37 = *(float *)(a1 + 316) - v58;
        v38 = *(float *)(a1 + 320) - v59;
        *(float *)&v52 = v36 * v54 + v37 * v55 + v38 * v56;
        v69 = *(float *)&v52 - v46[14];
        trap_XAnimClearTreeGoalWeightsStrict(v44, v42, 0);
        v77 = trap_XAnimGetNumChildren(v42);
        v68 = 0.0;
        v67 = 0.0;
        v75 = 0;
        v40 = 0;
        if ( !v77 )
        {
          v3 = trap_XAnimGetAnimName(v42);
          Com_Error(1, byte_7AEE0, v3);
        }
        v79 = 0;
        do
        {
          trap_XAnimGetChildAt(&v39);
          trap_XAnimSetGoalWeight(v44, v39, 1065353216, 1065353216, 1065353216, 0, 0);
          v76 = trap_XAnimGetNumChildren(v39);
          if ( !v76 )
          {
            v4 = trap_XAnimGetAnimName(v39);
            Com_Error(1, byte_7AEE0, v4);
          }
          v65 = (long double)v76 * 0.5 - v70 / *(float *)(v71 + 1036);
          if ( v65 >= 0.0 )
          {
            if ( v65 >= (long double)(v76 - 1) )
              v65 = (float)(v76 - 1);
          }
          else
          {
            v65 = 0.0;
          }
          v74 = (int)v65;
          v65 = v65 - (long double)v74;
          trap_XAnimGetChildAt(&v41);
          v14 = 1.0 - v65;
          trap_XAnimSetGoalWeight(v44, v41, LODWORD(v14), 1065353216, 1065353216, 0, 0);
          if ( v65 != 0.0 )
          {
            trap_XAnimGetChildAt(&v40);
            trap_XAnimSetGoalWeight(v44, v40, LODWORD(v65), 1065353216, 1065353216, 0, 0);
          }
          trap_XAnimCalcAbsDelta(v44, v39, v62, v60);
          if ( v61 >= (long double)v69 )
            break;
          v68 = v61;
          v75 = v74;
          v67 = v65;
          ++v79;
        }
        while ( v79 < v77 );
        trap_XAnimClearTreeGoalWeightsStrict(v44, v42, 0);
        v5 = trap_XAnimGetWeight(v44, v41);
        v25 = fabs(v5 - (1.0 - v65));
        v64 = v25 * (1000.0 / (long double)(int)level[124]);
        if ( v64 <= 0.0 )
          v24 = 0.0;
        else
          v24 = 1.0 / v64;
        v15 = 1.0 - v65;
        trap_XAnimSetGoalWeight(v44, v41, LODWORD(v15), LODWORD(v24), 1065353216, 0, 0);
        if ( v65 != 0.0 )
        {
          v6 = trap_XAnimGetWeight(v44, v40);
          v26 = fabs(v6 - v65);
          v64 = v26 * (1000.0 / (long double)(int)level[124]);
          if ( v64 <= 0.0 )
          {
            ((void (__cdecl *)(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))trap_XAnimSetGoalWeight)(
              v44,
              v40,
              LODWORD(v65),
              0.0,
              1065353216,
              0,
              0);
          }
          else
          {
            v23 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v40, LODWORD(v65), LODWORD(v23), 1065353216, 0, 0);
          }
        }
        if ( v79 && v79 != v77 )
        {
          v63 = (v69 - v68) / (v61 - v68);
          v7 = trap_XAnimGetWeight(v44, v39);
          v28 = fabs(v7 - v63);
          v64 = v28 * (1000.0 / (long double)(int)level[124]);
          if ( v64 <= 0.0 )
          {
            trap_XAnimSetGoalWeight(v44, v39, LODWORD(v63), 0, 1065353216, 0, 0);
          }
          else
          {
            v21 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v39, LODWORD(v63), LODWORD(v21), 1065353216, 0, 0);
          }
          trap_XAnimGetChildAt(&v39);
          v8 = trap_XAnimGetWeight(v44, v39);
          v29 = fabs(v8 - (1.0 - v63));
          v64 = v29 * (1000.0 / (long double)(int)level[124]);
          if ( v64 <= 0.0 )
            v20 = 0.0;
          else
            v20 = 1.0 / v64;
          v16 = 1.0 - v63;
          trap_XAnimSetGoalWeight(v44, v39, LODWORD(v16), LODWORD(v20), 1065353216, 0, 0);
          trap_XAnimGetChildAt(&v41);
          v9 = trap_XAnimGetWeight(v44, v41);
          v30 = fabs(v9 - (1.0 - v67));
          v64 = v30 * (1000.0 / (long double)(int)level[124]);
          if ( v64 <= 0.0 )
            v19 = 0.0;
          else
            v19 = 1.0 / v64;
          v17 = 1.0 - v67;
          trap_XAnimSetGoalWeight(v44, v41, LODWORD(v17), LODWORD(v19), 1065353216, 0, 0);
          if ( v67 != 0.0 )
          {
            trap_XAnimGetChildAt(&v40);
            v10 = trap_XAnimGetWeight(v44, v40);
            v31 = fabs(v10 - v67);
            v64 = v31 * (1000.0 / (long double)(int)level[124]);
            if ( v64 <= 0.0 )
            {
              trap_XAnimSetGoalWeight(v44, v40, LODWORD(v67), 0, 1065353216, 0, 0);
            }
            else
            {
              v18 = 1.0 / v64;
              trap_XAnimSetGoalWeight(v44, v40, LODWORD(v67), LODWORD(v18), 1065353216, 0, 0);
            }
          }
        }
        else
        {
          if ( !G_DObjGetLocalTagMatrix(a2, "tag_aim") )
            return Com_Printf("WARNING: aborting player positioning on turret since 'tag_aim' does not exist\n", v13);
          v27 = fabs(trap_XAnimGetWeight(v44, v39) - 1.0);
          v64 = v27 * (1000.0 / (long double)(int)level[124]);
          if ( v64 <= 0.0 )
          {
            trap_XAnimSetGoalWeight(v44, v39, 1065353216, 0, 1065353216, 0, 0);
          }
          else
          {
            v22 = 1.0 / v64;
            trap_XAnimSetGoalWeight(v44, v39, 1065353216, LODWORD(v22), 1065353216, 0, 0);
          }
        }
        trap_XAnimCalcAbsDelta(v44, v42, v62, v60);
        VectorAngleMultiply((int)v60, v70);
        *(float *)&v51[9] = *(float *)v60 + v46[12];
        *(float *)&v51[10] = *(float *)&v60[1] + v46[13];
        v51[11] = v52;
        v11 = RotationToYaw(v62);
        v66 = v11 + v70;
        YawToAxis(v66, (int)v51);
        MatrixMultiply43(v51, v53, v47);
        *(_DWORD *)(*(_DWORD *)(a1 + 348) + 20) = v48;
        *(_DWORD *)(*(_DWORD *)(a1 + 348) + 24) = v49;
        *(_DWORD *)(*(_DWORD *)(a1 + 348) + 28) = v50;
        v34[0] = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 20);
        v34[1] = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 24);
        v35 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 28);
        v33[0] = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 20);
        v33[1] = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 24);
        v33[2] = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 28);
        v35 = *((_DWORD *)a2 + 80);
        trap_Trace(v32, v34, 0, 0, v33, *(_DWORD *)a1, 42008593);
        if ( v32[0] < 1.0 )
          *(float *)(*(_DWORD *)(a1 + 348) + 28) = v32[3];
        BG_PlayerStateToEntityState(*(_DWORD *)(a1 + 348), a1, 1);
        *(_DWORD *)(a1 + 312) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 20);
        *(_DWORD *)(a1 + 316) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 24);
        *(_DWORD *)(a1 + 320) = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 28);
        AxisToAngles(v47, a1 + 324);
        result = trap_LinkEntity(a1);
      }
    }
  }
  return result;
}
// 5142E: variable 'v12' is possibly undefined
// 51A38: variable 'v13' is possibly undefined
// 131A0: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 13810: using guessed type _DWORD __cdecl trap_XAnimClearTreeGoalWeightsStrict(_DWORD, __int16, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);
// 142C0: using guessed type long double __cdecl trap_XAnimGetWeight(_DWORD, __int16);
// 14360: using guessed type double __cdecl vectosignedyaw(_DWORD);
// 14420: using guessed type _DWORD __cdecl BG_PlayerStateToEntityState(_DWORD, _DWORD, _DWORD);
// 14570: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 14610: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 14960: using guessed type _DWORD __cdecl trap_XAnimGetAnimName(_DWORD);
// 149E0: using guessed type _DWORD __cdecl trap_XAnimGetNumChildren(_DWORD);
// 14FE0: using guessed type _DWORD __stdcall trap_XAnimGetChildAt(_DWORD);
// 15110: using guessed type _DWORD __cdecl trap_XAnimCalcAbsDelta(_DWORD, __int16, _DWORD, _DWORD);
// 15280: using guessed type double __cdecl RotationToYaw(_DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 157C0: using guessed type _DWORD __cdecl trap_XAnimSetGoalWeight(_DWORD, __int16, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 9B6C0: using guessed type int dword_9B6C0;

//----- (000520D3) --------------------------------------------------------
int __cdecl sub_520D3(int a1, int a2)
{
  int result; // eax
  float v3; // [esp+10h] [ebp-38h]
  float v4; // [esp+18h] [ebp-30h]
  float v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  int v7; // [esp+38h] [ebp-10h]
  int v8; // [esp+3Ch] [ebp-Ch]

  v8 = *(_DWORD *)(a1 + 352);
  v7 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 884) = 1;
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 888) = *(_DWORD *)a1;
  *(_DWORD *)(*(_DWORD *)(a2 + 348) + 896) = 0;
  AnglesSubtract(*(_DWORD *)(a2 + 348) + 192, a1 + 324, &v5);
  if ( *(float *)(v8 + 12) <= (long double)v5 )
  {
    if ( v5 <= (long double)*(float *)(v8 + 20) )
      v4 = v5;
    else
      v4 = *(float *)(v8 + 20);
  }
  else
  {
    v4 = *(float *)(v8 + 12);
  }
  *(float *)(a1 + 104) = v4;
  if ( *(float *)(v8 + 16) <= (long double)v6 )
  {
    if ( v6 <= (long double)*(float *)(v8 + 24) )
      v3 = v6;
    else
      v3 = *(float *)(v8 + 24);
  }
  else
  {
    v3 = *(float *)(v8 + 16);
  }
  *(float *)(a1 + 108) = v3;
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 212) = *(_DWORD *)(v8 + 20);
  *(_DWORD *)(a1 + 92) = *(_DWORD *)(v8 + 24);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(v8 + 12);
  *(_DWORD *)(a1 + 100) = *(_DWORD *)(v8 + 16);
  result = *(_DWORD *)(v8 + 4) & 0x800;
  if ( result )
  {
    *(_DWORD *)(v8 + 4) &= 0xFFFFF7FF;
    result = *(_DWORD *)(a1 + 8) ^ 8;
    *(_DWORD *)(a1 + 8) = result;
  }
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14A50: using guessed type _DWORD __cdecl AnglesSubtract(_DWORD, _DWORD, _DWORD);

//----- (0005227C) --------------------------------------------------------
int __cdecl sub_5227C(_DWORD *a1, int a2)
{
  int v2; // esi
  int result; // eax

  v2 = a1[88];
  *(_DWORD *)(v2 + 40) = 3 * *(_DWORD *)(BG_GetInfoForWeapon(a1[50]) + 468);
  result = a2;
  if ( *(_DWORD *)(a2 + 348) )
  {
    sub_512A2((int)a1, (char *)a2, a1[144]);
    result = *(_DWORD *)(a2 + 348);
    *(_DWORD *)(result + 884) = 2;
  }
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00052305) --------------------------------------------------------
int __cdecl sub_52305(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 352);
  result = G_IsInMatchTimeout();
  if ( !result )
  {
    sub_520D3(a1, a2);
    sub_51389(a2, (float *)a1);
    v3 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    *(_DWORD *)(*(_DWORD *)(a2 + 348) + 884) = 1;
    *(_DWORD *)(a1 + 8) &= 0xFFFFFBFF;
    *(_DWORD *)(v4 + 8) -= 50;
    result = v4;
    if ( *(int *)(v4 + 8) <= 0 )
    {
      *(_DWORD *)(v4 + 8) = 0;
      result = *(_DWORD *)(*(_DWORD *)(a2 + 348) + 8688) & 1;
      if ( result )
      {
        *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 468);
        sub_5227C((_DWORD *)a1, a2);
        result = *(_DWORD *)(a1 + 8) | 0x400;
        *(_DWORD *)(a1 + 8) = result;
      }
    }
  }
  return result;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 15770: using guessed type int G_IsInMatchTimeout(void);

//----- (000523FD) --------------------------------------------------------
int __cdecl sub_523FD(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD *)(a1 + 352);
  *(_DWORD *)(a1 + 132) = 0;
  result = v2;
  if ( *(int *)(v2 + 40) > 0 )
  {
    if ( (*(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(*(_DWORD *)(a1 + 352) + 60),
          *(_DWORD *)(v2 + 40) -= 50,
          *(int *)(v2 + 40) <= 0)
      && *(_BYTE *)(v2 + 61)
      || (result = G_IsInMatchTimeout()) != 0 )
    {
      *(_DWORD *)(a1 + 132) = 0;
      result = G_PlaySoundAlias(a1, *(unsigned __int8 *)(v2 + 61));
    }
  }
  return result;
}
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 15770: using guessed type int G_IsInMatchTimeout(void);

//----- (0005249C) --------------------------------------------------------
unsigned int __cdecl G_ClientStopUsingTurret(int a1)
{
  unsigned int result; // eax
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v2 = *(_DWORD **)(a1 + 352);
  v3 = &g_entities[199 * *(_DWORD *)(a1 + 336)];
  v2[10] = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( v2[9] != -1 )
  {
    if ( v2[9] == 2 )
    {
      G_AddEvent(v3, 142, 0);
    }
    else if ( v2[9] == 1 )
    {
      G_AddEvent(v3, 141, 0);
    }
    else
    {
      G_AddEvent(v3, 140, 0);
    }
    v2[9] = -1;
  }
  TeleportPlayer(v3, v2 + 11, v3 + 81);
  *(_DWORD *)(v3[87] + 128) &= 0xFFFF3FFF;
  *(_DWORD *)(v3[87] + 884) = 0;
  *(_DWORD *)(v3[87] + 888) = 1023;
  *((_BYTE *)v3 + 374) = 0;
  *(_DWORD *)(v3[87] + 896) = 0;
  v3[29] = 0;
  *(_BYTE *)(a1 + 374) = 0;
  *(_DWORD *)(a1 + 336) = 1023;
  result = v2[1] & 0xFFFFF7FF;
  v2[1] = result;
  return result;
}
// 147B0: using guessed type _DWORD __cdecl TeleportPlayer(_DWORD, _DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (00052626) --------------------------------------------------------
int __cdecl turret_think_client(int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = &g_entities[199 * *(_DWORD *)(a1 + 336)];
  if ( *((_BYTE *)v2 + 374) != 1 || *(_DWORD *)(v2[87] + 8396) )
    return G_ClientStopUsingTurret(a1);
  sub_52305(a1, (int)v2);
  return sub_523FD(a1);
}
// 13500: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);

//----- (000526A2) --------------------------------------------------------
int __cdecl sub_526A2(int a1, int a2, int a3)
{
  long double v3; // fst7
  long double v4; // fst7
  float v6; // [esp+1Ch] [ebp-2Ch]
  float v7; // [esp+20h] [ebp-28h]
  int v8; // [esp+24h] [ebp-24h]
  int v9; // [esp+28h] [ebp-20h]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  int v13; // [esp+34h] [ebp-14h]
  int i; // [esp+3Ch] [ebp-Ch]

  v9 = *(_DWORD *)(a1 + 352);
  v8 = 1;
  v7 = *(float *)(a1 + 104);
  v3 = v7 + *(float *)(a1 + 112);
  *(float *)(a1 + 104) = v3;
  if ( a3 )
  {
    v12 = *(float *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200)) + 1020);
    v13 = *(_DWORD *)(BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200)) + 1024);
  }
  else
  {
    v12 = 200.0;
    v13 = 1128792064;
  }
  if ( (*(_DWORD *)(v9 + 4) & 0x200) != 0 && (*(_DWORD *)(v9 + 4) & 0x100) != 0 )
  {
    v3 = v12;
    if ( v12 < 360.0 )
      v12 = 360.0;
  }
  for ( i = 0; i <= 1; ++i )
  {
    v4 = *(&v12 + i) * 0.050000001;
    *(&v12 + i) = v4;
    AngleSubtract(*(float *)(a2 + 4 * i), *(float *)(a1 + 4 * i + 104));
    v10 = v4;
    if ( v10 <= (long double)*(&v12 + i) )
    {
      if ( -*(&v12 + i) > (long double)v10 )
      {
        v8 = 0;
        LODWORD(v10) = *((_DWORD *)&v12 + i) ^ 0x80000000;
      }
    }
    else
    {
      v8 = 0;
      v10 = *(&v12 + i);
    }
    v3 = *(float *)(a1 + 4 * i + 104) + v10;
    *(float *)(a1 + 4 * i + 104) = v3;
  }
  v6 = *(float *)(a1 + 104);
  *(float *)(a1 + 112) = v6;
  if ( (*(_DWORD *)(v9 + 4) & 0x200) != 0 )
  {
    if ( (*(_DWORD *)(v9 + 4) & 0x400) != 0 )
    {
      v3 = *(float *)(a1 + 104);
      if ( *(float *)(v9 + 56) > v3 )
        goto LABEL_18;
      *(_DWORD *)(v9 + 4) &= 0xFFFFFEFF;
    }
    else
    {
      v3 = *(float *)(v9 + 56);
      if ( *(float *)(a1 + 104) > v3 )
      {
LABEL_18:
        AngleSubtract(*(float *)(v9 + 56), v7);
        goto LABEL_23;
      }
      *(_DWORD *)(v9 + 4) &= 0xFFFFFEFF;
    }
  }
  AngleSubtract(v6, v7);
LABEL_23:
  v11 = v3;
  if ( v11 <= (long double)v12 )
  {
    if ( -v12 > (long double)v11 )
    {
      v8 = 0;
      LODWORD(v11) = LODWORD(v12) ^ 0x80000000;
    }
  }
  else
  {
    v8 = 0;
    v11 = v12;
  }
  *(float *)(a1 + 104) = v7 + v11;
  *(float *)(a1 + 112) = *(float *)(a1 + 112) - *(float *)(a1 + 104);
  return v8;
}
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (00052951) --------------------------------------------------------
int __cdecl sub_52951(int a1, int a2)
{
  float v3; // [esp+1Ch] [ebp-1Ch]
  float v4[3]; // [esp+20h] [ebp-18h] BYREF
  int v5; // [esp+2Ch] [ebp-Ch]

  v5 = *(_DWORD *)(a1 + 352);
  if ( a2 )
    v3 = 0.0;
  else
    v3 = *(float *)(v5 + 28);
  v4[0] = v3;
  v4[1] = 0.0;
  return sub_526A2(a1, (int)v4, a2);
}

//----- (000529B5) --------------------------------------------------------
_DWORD *__cdecl turret_think(_DWORD *a1)
{
  _DWORD *result; // eax

  a1[129] = level[122] + 50;
  if ( a1[187] )
    G_GeneralLink(a1);
  result = &g_entities[199 * a1[84]];
  if ( !result[87] )
  {
    sub_523FD((int)a1);
    a1[2] &= 0xFFFFFBFF;
    result = (_DWORD *)sub_52951((int)a1, 0);
  }
  return result;
}
// 14A10: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);

//----- (00052A61) --------------------------------------------------------
float *__cdecl turret_think_init(_DWORD *a1)
{
  float *result; // eax
  int i; // [esp+2Ch] [ebp-FCh]
  float v3[12]; // [esp+30h] [ebp-F8h] BYREF
  char v4[16]; // [esp+60h] [ebp-C8h] BYREF
  char v5[16]; // [esp+70h] [ebp-B8h] BYREF
  float v6; // [esp+80h] [ebp-A8h] BYREF
  float v7; // [esp+84h] [ebp-A4h]
  float v8; // [esp+88h] [ebp-A0h]
  float v9[4]; // [esp+90h] [ebp-98h] BYREF
  float v10[4]; // [esp+A0h] [ebp-88h] BYREF
  char v11[48]; // [esp+B0h] [ebp-78h] BYREF
  char v12[36]; // [esp+E0h] [ebp-48h] BYREF
  int v13; // [esp+104h] [ebp-24h]
  int v14; // [esp+108h] [ebp-20h]
  int v15; // [esp+10Ch] [ebp-1Ch]
  float *v16; // [esp+110h] [ebp-18h]
  float *v17; // [esp+114h] [ebp-14h]
  int v18; // [esp+118h] [ebp-10h]
  int v19; // [esp+11Ch] [ebp-Ch]

  v19 = 30;
  v18 = a1[88];
  a1[130] = turret_think;
  a1[129] = level[122] + 50;
  result = (float *)G_DObjGetLocalTagMatrix(a1, "tag_aim");
  v17 = result;
  if ( result )
  {
    result = (float *)G_DObjGetLocalTagMatrix(a1, "tag_butt");
    v16 = result;
    if ( result )
    {
      AnglesToAxis(a1 + 81, v12);
      v13 = a1[78];
      v14 = a1[79];
      v15 = a1[80];
      v9[0] = v16[12] - v17[12];
      v9[1] = v16[13] - v17[13];
      v9[2] = v16[14] - v17[14];
      MatrixTransformVector43(v17 + 12, v12, v5);
      for ( i = 0; ; ++i )
      {
        result = (float *)i;
        if ( i > v19 )
          break;
        v10[0] = -90.0 / (long double)v19 * (long double)i;
        v10[1] = 0.0;
        v10[2] = 0.0;
        AnglesToAxis(v10, v11);
        MatrixTransformVector(v9, v11, &v6);
        v6 = v6 + v17[12];
        v7 = v7 + v17[13];
        v8 = v8 + v17[14];
        MatrixTransformVector43(&v6, v12, v4);
        trap_LocationalTrace(v3, v5, v4, *a1, 17, &bulletPriorityMap);
        if ( v3[0] < 1.0 )
        {
          result = (float *)LODWORD(v10[0]);
          *(float *)(v18 + 28) = v10[0];
          return result;
        }
      }
    }
  }
  return result;
}
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13AE0: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 14570: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 14930: using guessed type _DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00052CC9) --------------------------------------------------------
int __cdecl turret_controller(_DWORD *a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h] BYREF
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v4 = a1[27];
  v3 = a1[26];
  v5 = 0;
  G_DObjSetControlTagAngles(a1, a2, "tag_aim", &v3);
  G_DObjSetControlTagAngles(a1, a2, "tag_aim_animated", &v3);
  v3 = a1[28];
  v4 = 0;
  return G_DObjSetControlTagAngles(a1, a2, "tag_flash", &v3);
}
// 15070: using guessed type _DWORD __cdecl G_DObjSetControlTagAngles(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00052D73) --------------------------------------------------------
_BOOL4 __cdecl sub_52D73(int a1, int a2)
{
  long double v2; // fst7
  long double v3; // fst7
  float v5; // [esp+0h] [ebp-68h]
  float v6; // [esp+10h] [ebp-58h]
  float v7; // [esp+1Ch] [ebp-4Ch]
  float v8; // [esp+20h] [ebp-48h]
  float v9; // [esp+24h] [ebp-44h]
  float v10; // [esp+28h] [ebp-40h]
  float v11; // [esp+2Ch] [ebp-3Ch]
  int v12[4]; // [esp+30h] [ebp-38h] BYREF
  float v13; // [esp+40h] [ebp-28h] BYREF
  float v14; // [esp+44h] [ebp-24h]
  float v15; // [esp+48h] [ebp-20h]
  int v16; // [esp+5Ch] [ebp-Ch]

  v16 = *(_DWORD *)(a1 + 352);
  v11 = *(float *)(a1 + 328) + *(float *)(v16 + 16);
  v6 = sub_53AB3(*(float *)(v16 + 16));
  v10 = (sub_53AB3(*(float *)(v16 + 24)) + v6) * 0.5;
  v2 = v11 + v10;
  v5 = v2;
  AngleNormalize180(v5);
  v9 = v2;
  YawVectors(v9, (int)v12, 0);
  VectorNormalize(v12);
  v13 = *(float *)(a1 + 312) - *(float *)(a2 + 312);
  v14 = *(float *)(a1 + 316) - *(float *)(a2 + 316);
  v15 = 0.0;
  VectorNormalize(&v13);
  v3 = *(float *)v12 * v13 + *(float *)&v12[1] * v14 + *(float *)&v12[2] * v15;
  v8 = v3;
  Q_acos(v8);
  v7 = v3 * 180.0 / 3.141592653589793;
  return v7 <= (long double)v10;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (00052EBE) --------------------------------------------------------
int __cdecl G_FreeTurret(int a1)
{
  int result; // eax

  if ( g_entities[199 * *(_DWORD *)(a1 + 336) + 87] )
    G_ClientStopUsingTurret(a1);
  *(_BYTE *)(a1 + 374) = 0;
  **(_DWORD **)(a1 + 352) = 0;
  result = a1;
  *(_DWORD *)(a1 + 352) = 0;
  return result;
}
// 13500: using guessed type _DWORD __cdecl G_ClientStopUsingTurret(_DWORD);

//----- (00052F3B) --------------------------------------------------------
_BOOL4 __cdecl G_IsTurretUsable(int a1, int a2)
{
  if ( *(_BYTE *)(a1 + 374) || !*(_DWORD *)(a1 + 352) || !*(_BYTE *)(a1 + 373) )
    return 0;
  if ( !sub_52D73(a1, a2) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 348) + 52) )
    return 0;
  return *(_DWORD *)(*(_DWORD *)(a2 + 348) + 84) != 1023;
}

//----- (00052FCC) --------------------------------------------------------
int __usercall turret_use@<eax>(long double a1@<st0>, int a2, int a3)
{
  int v3; // edx
  unsigned int v4; // eax
  int i; // [esp+1Ch] [ebp-3Ch]
  float v7[7]; // [esp+20h] [ebp-38h] BYREF
  _DWORD *v8; // [esp+3Ch] [ebp-1Ch]

  v8 = *(_DWORD **)(a2 + 352);
  *(_BYTE *)(a3 + 374) = 1;
  *(_BYTE *)(a2 + 374) = 1;
  *(_DWORD *)(a2 + 336) = *(_DWORD *)a3;
  *(_DWORD *)(*(_DWORD *)(a3 + 348) + 884) = 1;
  *(_DWORD *)(*(_DWORD *)(a3 + 348) + 888) = *(_DWORD *)a2;
  v8[1] |= 0x800u;
  v8[11] = *(_DWORD *)(a3 + 312);
  v8[12] = *(_DWORD *)(a3 + 316);
  v8[13] = *(_DWORD *)(a3 + 320);
  *(_DWORD *)(a3 + 116) = *(_DWORD *)a2;
  if ( (*(_DWORD *)(*(_DWORD *)(a3 + 348) + 12) & 1) != 0 )
    v8[9] = 2;
  else
    v8[9] = (*(_DWORD *)(*(_DWORD *)(a3 + 348) + 12) & 2) != 0;
  if ( v8[8] == 2 )
  {
    *(_DWORD *)(*(_DWORD *)(a3 + 348) + 128) |= 0x4000u;
    *(_DWORD *)(*(_DWORD *)(a3 + 348) + 128) &= 0xFFFF7FFF;
  }
  else
  {
    if ( v8[8] == 1 )
    {
      *(_DWORD *)(*(_DWORD *)(a3 + 348) + 128) |= 0x8000u;
      v3 = *(_DWORD *)(a3 + 348);
      v4 = *(_DWORD *)(v3 + 128) & 0xFFFFBFFF;
    }
    else
    {
      v3 = *(_DWORD *)(a3 + 348);
      v4 = *(_DWORD *)(v3 + 128) | 0xC000;
    }
    *(_DWORD *)(v3 + 128) = v4;
  }
  *(_DWORD *)(a2 + 660) = *(_DWORD *)(a2 + 324);
  *(_DWORD *)(a2 + 664) = *(_DWORD *)(a2 + 328);
  *(_DWORD *)(a2 + 668) = *(_DWORD *)(a2 + 332);
  for ( i = 0; i <= 1; ++i )
  {
    AngleSubtract(*(float *)(*(_DWORD *)(a3 + 348) + 4 * i + 192), *(float *)(a2 + 4 * i + 324));
    *(float *)(a2 + 4 * i + 104) = a1;
    a1 = *(float *)&v8[i + 5];
    if ( *(float *)(a2 + 4 * i + 104) <= a1 )
    {
      a1 = *(float *)(a2 + 4 * i + 104);
      if ( *(float *)&v8[i + 3] > a1 )
        *(_DWORD *)(a2 + 4 * i + 104) = v8[i + 3];
    }
    else
    {
      *(_DWORD *)(a2 + 4 * i + 104) = v8[i + 5];
    }
  }
  v7[0] = *(float *)(a2 + 104) + *(float *)(a2 + 324);
  v7[1] = *(float *)(a2 + 108) + *(float *)(a2 + 328);
  v7[2] = 0.0;
  return SetClientViewAngle(a3, v7);
}
// 14B90: using guessed type _DWORD __cdecl SetClientViewAngle(_DWORD, _DWORD);

//----- (000532BE) --------------------------------------------------------
int __cdecl G_SpawnTurret(int a1, char a2)
{
  int v2; // eax
  int i; // [esp+14h] [ebp-14h]
  _DWORD *s; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]

  s = 0;
  for ( i = 0; i <= 31; ++i )
  {
    s = &dword_A5DC0[16 * i];
    if ( !*s )
      break;
  }
  if ( i == 32 )
    Com_Error(1, byte_7AFE0, 32);
  memset(s, 0, 0x40u);
  *(_DWORD *)(a1 + 352) = s;
  *s = 1;
  *(_DWORD *)(a1 + 200) = (unsigned __int8)BG_GetWeaponIndexForName(a2);
  if ( !*(_DWORD *)(a1 + 200) )
    Com_Error(1, byte_7B020, a2);
  v6 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
  if ( !level[7] && !IsItemRegistered(*(_DWORD *)(a1 + 200)) )
  {
    v2 = va("turret '%s' not precached", a2);
    Scr_Error(v2);
  }
  RegisterItem(*(_DWORD *)(a1 + 200), 1);
  s[2] = 0;
  s[8] = *(_DWORD *)(v6 + 128);
  s[9] = -1;
  s[10] = 0;
  if ( *(_DWORD *)(v6 + 160) && **(_BYTE **)(v6 + 160) )
    *((_BYTE *)s + 60) = G_SoundAliasIndex(*(char **)(v6 + 160));
  else
    *((_BYTE *)s + 60) = 0;
  if ( *(_DWORD *)(v6 + 164) && **(_BYTE **)(v6 + 164) )
    *((_BYTE *)s + 61) = G_SoundAliasIndex(*(char **)(v6 + 164));
  else
    *((_BYTE *)s + 61) = 0;
  if ( !G_SpawnFloat("rightarc", (int)&unk_7B064, (int)(s + 4)) )
    s[4] = *(_DWORD *)(v6 + 1004);
  *((float *)s + 4) = *((float *)s + 4) * -1.0;
  if ( *((float *)s + 4) > 0.0 )
    s[4] = 0;
  if ( !G_SpawnFloat("leftarc", (int)&unk_7B064, (int)(s + 6)) )
    s[6] = *(_DWORD *)(v6 + 1000);
  if ( *((float *)s + 6) < 0.0 )
    s[6] = 0;
  if ( !G_SpawnFloat("toparc", (int)&unk_7B064, (int)(s + 3)) )
    s[3] = *(_DWORD *)(v6 + 1008);
  *((float *)s + 3) = *((float *)s + 3) * -1.0;
  if ( *((float *)s + 3) > 0.0 )
    s[3] = 0;
  if ( !G_SpawnFloat("bottomarc", (int)&unk_7B064, (int)(s + 5)) )
    s[5] = *(_DWORD *)(v6 + 1012);
  if ( *((float *)s + 5) < 0.0 )
    s[5] = 0;
  s[7] = -1028390912;
  if ( !*(_DWORD *)(a1 + 568) )
    *(_DWORD *)(a1 + 568) = 100;
  if ( !G_SpawnInt("damage", (int)"0", a1 + 576) )
    *(_DWORD *)(a1 + 576) = *(_DWORD *)(v6 + 448);
  if ( *(int *)(a1 + 576) < 0 )
    *(_DWORD *)(a1 + 576) = 0;
  s[1] = 3;
  *(_DWORD *)(a1 + 408) = 1;
  *(_DWORD *)(a1 + 284) = &unk_200004;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 11;
  *(_DWORD *)(a1 + 388) |= 0x2000u;
  G_DObjUpdate(a1);
  *(_DWORD *)(a1 + 260) = -1040187392;
  *(_DWORD *)(a1 + 264) = -1040187392;
  *(_DWORD *)(a1 + 268) = 0;
  *(_DWORD *)(a1 + 272) = 1107296256;
  *(_DWORD *)(a1 + 276) = 1107296256;
  *(_DWORD *)(a1 + 280) = 1113587712;
  G_SetOrigin(a1, a1 + 312);
  G_SetAngle(a1, a1 + 324);
  *(_DWORD *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 520) = turret_think_init;
  *(_DWORD *)(a1 + 516) = level[122] + 100;
  *(_DWORD *)(a1 + 552) = turret_controller;
  *(_DWORD *)(a1 + 536) = turret_use;
  *(_DWORD *)(a1 + 48) = 3;
  *(_BYTE *)(a1 + 373) = 1;
  return trap_LinkEntity(a1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 13840: using guessed type _DWORD __cdecl IsItemRegistered(_DWORD);
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (000537F9) --------------------------------------------------------
int __cdecl SP_turret(int a1)
{
  char v2; // [esp+8h] [ebp-10h]
  char v3[4]; // [esp+10h] [ebp-8h] BYREF

  if ( !G_SpawnString("weaponinfo", (int)&unk_7B064, (int)v3) )
    Com_Error(1, byte_7B0C0, v2);
  return G_SpawnTurret(a1, v3[0]);
}
// 5383F: variable 'v2' is possibly undefined
// 15730: using guessed type _DWORD __cdecl G_SpawnTurret(_DWORD, char);

//----- (0005385C) --------------------------------------------------------
int __cdecl misc_spawner_think(int a1)
{
  int v1; // eax
  int result; // eax
  char v3; // al
  char v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+20h] [ebp-8h]

  v1 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 720));
  v5 = BG_FindItem(v1);
  result = Drop_Item(a1, v5, 0.0, 0);
  if ( !result )
  {
    G_Printf("-----> WARNING <-------\n", v4);
    v3 = vtos(a1 + 312);
    result = G_Printf("misc_spawner used at %s failed to drop!\n", v3);
  }
  return result;
}
// 538C6: variable 'v4' is possibly undefined
// 13AB0: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 13CD0: using guessed type _DWORD __cdecl vtos(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (000538F3) --------------------------------------------------------
int __cdecl misc_spawner_use(int a1)
{
  *(_DWORD *)(a1 + 520) = misc_spawner_think;
  *(_DWORD *)(a1 + 516) = level[122] + 100;
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0005393D) --------------------------------------------------------
int __cdecl SP_misc_spawner(int a1)
{
  char v1; // al
  int result; // eax
  char v3; // [esp+4h] [ebp-14h]

  if ( *(_WORD *)(a1 + 720) )
  {
    *(_DWORD *)(a1 + 536) = misc_spawner_use;
    result = trap_LinkEntity(a1);
  }
  else
  {
    G_Printf("-----> WARNING <-------\n", v3);
    v1 = vtos(a1 + 312);
    result = G_Printf("misc_spawner at loc %s has no spawnitem!\n", v1);
  }
  return result;
}
// 53965: variable 'v3' is possibly undefined
// 13CD0: using guessed type _DWORD __cdecl vtos(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000539AE) --------------------------------------------------------
float *__cdecl miscGunnerEnemyScan(int a1)
{
  float *result; // eax
  char v2[16]; // [esp+10h] [ebp-38h] BYREF
  float v3[7]; // [esp+20h] [ebp-28h] BYREF
  float *i; // [esp+3Ch] [ebp-Ch]

  for ( i = (float *)g_entities; ; i += 199 )
  {
    result = (float *)&g_entities[199 * level[120]];
    if ( i >= result )
      break;
    if ( *((_BYTE *)i + 356)
      && *((int *)i + 142) >= 0
      && VectorDistance(a1 + 312, i + 78) <= (long double)*(int *)(a1 + 632) )
    {
      v3[0] = i[78] - *(float *)(a1 + 312);
      v3[1] = i[79] - *(float *)(a1 + 316);
      v3[2] = i[80] - *(float *)(a1 + 320);
      vectoangles(v3, v2);
      result = i;
      *(_DWORD *)(a1 + 608) = i;
      return result;
    }
  }
  return result;
}
// 15270: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (00053AB3) --------------------------------------------------------
long double __cdecl sub_53AB3(float a1)
{
  return (float)fabs(a1);
}

//----- (00053ACC) --------------------------------------------------------
void sub_53ACC()
{
  ;
}

//----- (00053AD0) --------------------------------------------------------
void __cdecl G_MissileLandAngles(int a1, float *a2, int a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  long double v6; // fst7
  long double v7; // fst7
  float v8; // [esp+0h] [ebp-68h]
  float v9; // [esp+0h] [ebp-68h]
  float v10; // [esp+0h] [ebp-68h]
  float v11; // [esp+40h] [ebp-28h]
  float v12; // [esp+48h] [ebp-20h]
  int v13; // [esp+4Ch] [ebp-1Ch]

  v13 = level[123] + (int)((long double)(level[122] - level[123]) * *a2);
  BG_EvaluateTrajectory(a1 + 48, v13, a3);
  if ( a2[6] <= 0.1 )
  {
    if ( !a4 )
    {
      v7 = (long double)((rand() & 0x7F) - 63) + *(float *)(a1 + 72);
      v10 = v7;
      AngleNormalize360(v10);
      *(float *)(a1 + 72) = v7;
    }
  }
  else
  {
    PitchForYawOnNormal(*(float *)(a3 + 4), (int)(a2 + 4));
    v12 = 0.1;
    AngleSubtract(0.1, *(float *)a3);
    v4 = fabs((float)0.1);
    v11 = v4;
    if ( !a4 )
    {
      *(_DWORD *)(a1 + 60) = *(_DWORD *)a3;
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a3 + 4);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a1 + 52) = v13;
      if ( v11 >= 80.0 )
        v4 = ((long double)rand() / 2147483600.0 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72);
      else
        v4 = ((long double)rand() / 2147483600.0 * 0.30000001 + 0.85000002) * *(float *)(a1 + 72) * -1.0;
      *(float *)(a1 + 72) = v4;
    }
    AngleNormalize180(*(float *)a3);
    *(float *)a3 = v4;
    if ( a4 || v11 < 45.0 )
    {
      v5 = 90.0;
      if ( fabs(*(float *)a3) <= 90.0 )
      {
        AngleNormalize360(v12);
      }
      else
      {
        v5 = v12 + 180.0;
        v8 = v5;
        AngleNormalize360(v8);
      }
      *(float *)a3 = v5;
    }
    else
    {
      v6 = v11;
      if ( v11 >= 80.0 )
      {
        AngleNormalize360(*(float *)a3);
      }
      else
      {
        v6 = (float)0.1 * 0.25 + *(float *)a3;
        v9 = v6;
        AngleNormalize360(v9);
      }
      *(float *)a3 = v6;
    }
  }
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (00053D71) --------------------------------------------------------
_BOOL4 __cdecl G_BounceMissile(int a1, int a2)
{
  _BOOL4 v3; // [esp+14h] [ebp-54h]
  float v4; // [esp+20h] [ebp-48h]
  int v5; // [esp+24h] [ebp-44h]
  float v6; // [esp+2Ch] [ebp-3Ch]
  float v7; // [esp+2Ch] [ebp-3Ch]
  int v8[4]; // [esp+30h] [ebp-38h] BYREF
  float v9; // [esp+40h] [ebp-28h]
  float v10; // [esp+44h] [ebp-24h]
  float v11; // [esp+48h] [ebp-20h]
  float v12; // [esp+50h] [ebp-18h] BYREF
  float v13; // [esp+54h] [ebp-14h]
  float v14; // [esp+58h] [ebp-10h]

  v5 = trap_PointContents(a1 + 312, -1, 32);
  BG_EvaluateTrajectoryDelta(a1 + 12, level[123] + (int)((long double)(level[122] - level[123]) * *(float *)a2), &v12);
  v6 = v12 * *(float *)(a2 + 16) + v13 * *(float *)(a2 + 20) + v14 * *(float *)(a2 + 24);
  *(float *)(a1 + 36) = v6 * -2.0 * *(float *)(a2 + 16) + v12;
  *(float *)(a1 + 40) = v6 * -2.0 * *(float *)(a2 + 20) + v13;
  *(float *)(a1 + 44) = v6 * -2.0 * *(float *)(a2 + 24) + v14;
  if ( *(float *)(a2 + 24) > 0.7 )
    *(_DWORD *)(a1 + 124) = *(unsigned __int16 *)(a2 + 40);
  if ( (*(_DWORD *)(a1 + 8) & 0x2000000) != 0
    && (!v5 && (*(_DWORD *)(a2 + 32) & 0x2000000) == 0 ? (*(float *)(a1 + 36) = *(float *)(a1 + 36) * 0.5,
                                                          *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.5,
                                                          *(float *)(a1 + 44) = *(float *)(a1 + 44) * 0.5) : (*(float *)(a1 + 36) = *(float *)(a1 + 36) * 0.125, *(float *)(a1 + 40) = *(float *)(a1 + 40) * 0.125, *(float *)(a1 + 44) = *(float *)(a1 + 44) * 0.125),
        *(float *)(a2 + 24) > 0.7
     && (v4 = sqrt(
                *(float *)(a1 + 36) * *(float *)(a1 + 36)
              + *(float *)(a1 + 40) * *(float *)(a1 + 40)
              + *(float *)(a1 + 44) * *(float *)(a1 + 44)),
         v4 < 20.0)) )
  {
    G_SetOrigin(a1, a1 + 312);
    G_MissileLandAngles(a1, a2, v8, 1);
    G_SetAngle(a1, v8);
    v3 = 0;
  }
  else
  {
    v9 = *(float *)(a2 + 16) * 0.1;
    v10 = *(float *)(a2 + 20) * 0.1;
    v11 = *(float *)(a2 + 24) * 0.1;
    if ( v11 > 0.0 )
      v11 = 0.0;
    *(float *)(a1 + 312) = *(float *)(a1 + 312) + v9;
    *(float *)(a1 + 316) = *(float *)(a1 + 316) + v10;
    *(float *)(a1 + 320) = *(float *)(a1 + 320) + v11;
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 16) = level[122];
    G_MissileLandAngles(a1, a2, v8, 0);
    *(_DWORD *)(a1 + 60) = v8[0];
    *(_DWORD *)(a1 + 64) = v8[1];
    *(_DWORD *)(a1 + 68) = v8[2];
    *(_DWORD *)(a1 + 52) = level[122];
    if ( v5 )
    {
      v3 = 0;
    }
    else
    {
      v12 = *(float *)(a1 + 36) - v12;
      v13 = *(float *)(a1 + 40) - v13;
      v14 = *(float *)(a1 + 44) - v14;
      v7 = sqrt(v12 * v12 + v13 * v13 + v14 * v14);
      v3 = v7 > 100.0;
    }
  }
  return v3;
}
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13CB0: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 15400: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 15520: using guessed type _DWORD __cdecl G_MissileLandAngles(_DWORD, _DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (000541F3) --------------------------------------------------------
int __cdecl G_MissileImpact(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+4h] [ebp-74h]
  int v4; // [esp+8h] [ebp-70h]
  int v5; // [esp+8h] [ebp-70h]
  int v6; // [esp+Ch] [ebp-6Ch]
  float v7; // [esp+Ch] [ebp-6Ch]
  int v8; // [esp+10h] [ebp-68h]
  int v9; // [esp+10h] [ebp-68h]
  float v10; // [esp+10h] [ebp-68h]
  int v11; // [esp+14h] [ebp-64h]
  float v12; // [esp+14h] [ebp-64h]
  int v13; // [esp+1Ch] [ebp-5Ch]
  int v14; // [esp+38h] [ebp-40h]
  float v15; // [esp+44h] [ebp-34h]
  float v16; // [esp+50h] [ebp-28h] BYREF
  float v17; // [esp+54h] [ebp-24h]
  float v18; // [esp+58h] [ebp-20h]
  int v19; // [esp+68h] [ebp-10h]
  int v20; // [esp+6Ch] [ebp-Ch]

  v19 = 0;
  v20 = (int)&g_entities[199 * *(unsigned __int16 *)(a2 + 40)];
  if ( *(_BYTE *)(v20 + 373) || (*(_DWORD *)(a1 + 8) & 0x3000000) == 0 )
  {
    if ( *(_BYTE *)(v20 + 373) )
    {
      if ( !*(_DWORD *)(a1 + 576) )
        return G_BounceMissile(a1, a2);
      if ( LogAccuracyHit(v20, &g_entities[199 * *(_DWORD *)(a1 + 336)]) )
        v19 = 1;
      BG_EvaluateTrajectoryDelta(a1 + 12, level[122], &v16);
      v15 = sqrt(v16 * v16 + v17 * v17 + v18 * v18);
      if ( v15 == 0.0 )
        v18 = 1.0;
      v13 = *(_DWORD *)(a1 + 592);
      v11 = *(_DWORD *)(a1 + 576);
      v8 = a1 + 312;
      if ( *(_DWORD *)(a1 + 336) == 1023 )
        G_Damage(v20, a1, 0, &v16, v8, v11, 0, v13, 0);
      else
        G_Damage(v20, a1, &g_entities[199 * *(_DWORD *)(a1 + 336)], &v16, v8, v11, 0, v13, 0);
    }
    if ( *(_DWORD *)(a1 + 576) )
    {
      v9 = *(_DWORD *)(a1 + 592);
      v6 = *(_DWORD *)(a1 + 576);
      v4 = a2 + 4;
      v3 = a1 + 312;
      if ( *(_DWORD *)(a1 + 336) == 1023 )
        G_CheckHitTriggerDamage((char *)&dword_C69C8 + (_DWORD)g_entities, v3, v4, v6, v9);
      else
        G_CheckHitTriggerDamage(&g_entities[199 * *(_DWORD *)(a1 + 336)], v3, v4, v6, v9);
    }
    v14 = 0;
    if ( v19 || *(_WORD *)(a2 + 42) )
      v14 = 1;
    v5 = (unsigned __int8)DirToByte(a2 + 16);
    if ( v14 )
      G_AddEvent(a1, 180, v5);
    else
      G_AddEvent(a1, 179, v5);
    *(_DWORD *)(a1 + 136) = (*(_DWORD *)(a2 + 28) & 0x1F00000) >> 20;
    *(_DWORD *)(a1 + 396) = 1;
    *(_DWORD *)(a1 + 4) = 0;
    SnapVectorTowards(a2 + 4, a1 + 24);
    G_SetOrigin(a1, a2 + 4);
    if ( *(_DWORD *)(a1 + 580) )
    {
      v12 = (float)*(int *)(a1 + 588);
      v10 = (float)*(int *)(a1 + 584);
      v7 = (float)*(int *)(a1 + 580);
      G_RadiusDamage(a2 + 4, a1, *(_DWORD *)(a1 + 416), v7, v10, v12, v20, *(_DWORD *)(a1 + 596));
    }
    result = trap_LinkEntity(a1);
  }
  else
  {
    result = G_BounceMissile(a1, a2);
    if ( result )
    {
      result = a2;
      if ( !*(_BYTE *)(a2 + 47) )
      {
        result = *(unsigned __int16 *)(a1 + 380);
        if ( (_WORD)result != scr_const[122] )
        {
          if ( *(_WORD *)(a1 + 380) == scr_const[24] )
            result = G_AddEvent(a1, 194, 0);
          else
            result = G_AddEvent(a1, 177, (*(_DWORD *)(a2 + 28) & 0x1F00000) >> 20);
        }
      }
    }
  }
  return result;
}
// 130D0: using guessed type _DWORD __cdecl LogAccuracyHit(_DWORD, _DWORD);
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13E30: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 141A0: using guessed type _DWORD __cdecl G_BounceMissile(_DWORD, _DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 15010: using guessed type _DWORD __cdecl SnapVectorTowards(_DWORD, _DWORD);
// 15400: using guessed type _DWORD __cdecl BG_EvaluateTrajectoryDelta(_DWORD, _DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);
// C69C8: using guessed type int dword_C69C8;

//----- (00054617) --------------------------------------------------------
int __cdecl Concussive_think(int a1)
{
  int result; // eax

  if ( (long double)(int)level[122] > *(float *)(a1 + 636) )
    *(_DWORD *)(a1 + 520) = G_FreeEntity;
  result = a1;
  *(_DWORD *)(a1 + 516) = level[122] + 100;
  return result;
}

//----- (00054670) --------------------------------------------------------
_DWORD *__cdecl Concussive_fx(float *a1)
{
  float *v1; // eax
  float *v2; // edx
  _DWORD *result; // eax

  v1 = (float *)G_Spawn();
  v1[78] = *a1;
  v1[79] = a1[1];
  v1[80] = a1[2];
  *((_DWORD *)v1 + 130) = Concussive_think;
  *((_DWORD *)v1 + 129) = level[122] + 100;
  v2 = v1;
  result = level;
  v2[159] = (long double)(int)level[122] + 500.0;
  return result;
}
// 12E70: using guessed type int G_Spawn(void);

//----- (00054704) --------------------------------------------------------
int __cdecl G_ExplodeMissile(int a1)
{
  int result; // eax
  unsigned __int8 v2; // al
  float v3; // [esp+Ch] [ebp-9Ch]
  float v4; // [esp+10h] [ebp-98h]
  float v5; // [esp+14h] [ebp-94h]
  char v6[16]; // [esp+30h] [ebp-78h] BYREF
  _DWORD v7[10]; // [esp+40h] [ebp-68h] BYREF
  int v9; // [esp+6Ch] [ebp-3Ch]
  int v10[2]; // [esp+70h] [ebp-38h] BYREF
  float v11; // [esp+78h] [ebp-30h]
  float v12; // [esp+80h] [ebp-28h] BYREF
  float v13; // [esp+84h] [ebp-24h]
  float v14; // [esp+88h] [ebp-20h]
  int v15; // [esp+90h] [ebp-18h]
  int v16; // [esp+94h] [ebp-14h]
  int v17; // [esp+98h] [ebp-10h]

  BG_EvaluateTrajectory(a1 + 12, level[122], &v12);
  v12 = (float)(int)v12;
  v13 = (float)(int)v13;
  v14 = (float)(int)v14;
  G_SetOrigin(a1, &v12);
  v16 = 0;
  v15 = 0;
  v17 = 1065353216;
  v9 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) |= 0x100u;
  *(_DWORD *)(a1 + 388) |= 0x1000u;
  *(_DWORD *)(a1 + 244) |= 8u;
  if ( *(_WORD *)(a1 + 380) == scr_const[24] )
  {
    *(_DWORD *)(a1 + 396) = 1;
    result = trap_LinkEntity(a1);
  }
  else
  {
    v10[0] = *(_DWORD *)(a1 + 312);
    v10[1] = *(_DWORD *)(a1 + 316);
    v11 = *(float *)(a1 + 320);
    v11 = v11 - 16.0;
    trap_Trace(v6, a1 + 312, vec3_origin, vec3_origin, v10, *(_DWORD *)a1, 17);
    v2 = DirToByte(v7);
    G_AddEvent(a1, 178, v2);
    if ( trap_PointContents(a1 + 312, -1, 32) )
      *(_DWORD *)(a1 + 136) = 20;
    else
      *(_DWORD *)(a1 + 136) = (v7[3] & 0x1F00000) >> 20;
    *(_DWORD *)(a1 + 396) = 1;
    if ( *(_DWORD *)(a1 + 580) )
    {
      v5 = (float)*(int *)(a1 + 588);
      v4 = (float)*(int *)(a1 + 584);
      v3 = (float)*(int *)(a1 + 580);
      G_RadiusDamage(a1 + 312, a1, *(_DWORD *)(a1 + 416), v3, v4, v5, a1, *(_DWORD *)(a1 + 596));
    }
    trap_LinkEntity(a1);
    result = Concussive_fx(a1 + 312);
  }
  return result;
}
// 131D0: using guessed type _DWORD __cdecl Concussive_fx(_DWORD);
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13CB0: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (000549CB) --------------------------------------------------------
int __cdecl G_MissileDie(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( a2 != a1 )
  {
    *(_BYTE *)(a1 + 373) = 0;
    *(_DWORD *)(a1 + 520) = G_ExplodeMissile;
    result = level[122] + 10;
    *(_DWORD *)(a1 + 516) = result;
  }
  return result;
}

//----- (00054A18) --------------------------------------------------------
void __cdecl G_MissileTrace(int a1, float *a2, float *a3, int a4, int a5)
{
  float v5[6]; // [esp+20h] [ebp-18h] BYREF

  trap_LocationalTrace(a1, a2, a3, a4, a5, &bulletPriorityMap);
  if ( *(_BYTE *)(a1 + 47) )
  {
    *(_DWORD *)a1 = 0;
    v5[0] = *a2 - *a3;
    v5[1] = a2[1] - a3[1];
    v5[2] = a2[2] - a3[2];
    VectorNormalize2(v5, a1 + 16);
  }
}
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (00054ABD) --------------------------------------------------------
void *__cdecl G_RunMissile(void *s)
{
  void *result; // eax
  float v2; // [esp+24h] [ebp-C4h]
  int v3; // [esp+28h] [ebp-C0h]
  _DWORD *v4; // [esp+2Ch] [ebp-BCh]
  _DWORD *v5; // [esp+2Ch] [ebp-BCh]
  char v6[8]; // [esp+30h] [ebp-B8h] BYREF
  float v7; // [esp+38h] [ebp-B0h]
  int v8[4]; // [esp+40h] [ebp-A8h] BYREF
  float v9[12]; // [esp+50h] [ebp-98h] BYREF
  float v10[12]; // [esp+80h] [ebp-68h] BYREF
  float v11[4]; // [esp+B0h] [ebp-38h] BYREF
  float v12; // [esp+C0h] [ebp-28h] BYREF
  float v13; // [esp+C4h] [ebp-24h]
  float v14; // [esp+C8h] [ebp-20h]

  if ( !*((_DWORD *)s + 3) && *((_DWORD *)s + 31) != 1022 )
  {
    v12 = *((float *)s + 78);
    v13 = *((float *)s + 79);
    v14 = *((float *)s + 80);
    v14 = v14 - 1.5;
    G_MissileTrace(v10, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102));
    if ( v10[0] == 1.0 )
    {
      *((_DWORD *)s + 3) = 5;
      *((_DWORD *)s + 4) = level[122];
      *((_DWORD *)s + 5) = 0;
      *((_DWORD *)s + 6) = *((_DWORD *)s + 78);
      *((_DWORD *)s + 7) = *((_DWORD *)s + 79);
      *((_DWORD *)s + 8) = *((_DWORD *)s + 80);
      *((_DWORD *)s + 11) = 0;
      *((_DWORD *)s + 10) = 0;
      *((_DWORD *)s + 9) = 0;
    }
  }
  v8[0] = *((_DWORD *)s + 78);
  v8[1] = *((_DWORD *)s + 79);
  v8[2] = *((_DWORD *)s + 80);
  BG_EvaluateTrajectory((char *)s + 12, level[122], &v12);
  v11[0] = v12 - *((float *)s + 78);
  v11[1] = v13 - *((float *)s + 79);
  v11[2] = v14 - *((float *)s + 80);
  if ( VectorNormalize(v11) < 0.001 )
    return (void *)G_RunThink(s);
  if ( fabs(*((float *)s + 11)) <= 30.0 || trap_PointContents((char *)s + 312, -1, 32) )
    G_MissileTrace(v10, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102));
  else
    G_MissileTrace(v10, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102) | 0x20);
  if ( (LODWORD(v10[7]) & 0x1F00000) == 20971520 )
  {
    VectorNormalize2((char *)s + 36, v6);
    if ( v7 < 0.0 )
      v7 = v7 * -1.0;
    v4 = (_DWORD *)G_TempEntity((char *)s + 312, 173);
    v4[40] = (unsigned __int8)DirToByte(&v10[4]);
    v4[54] = (unsigned __int8)DirToByte(v6);
    v4[34] = (LODWORD(v10[7]) & 0x1F00000) >> 20;
    v4[29] = *(_DWORD *)s;
    G_MissileTrace(v10, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102));
  }
  if ( *((_DWORD *)s + 148) == 3 && (g_entities[199 * LOWORD(v10[10]) + 97] & 0x10000) != 0 )
  {
    v5 = &g_entities[199 * LOWORD(v10[10])];
    v3 = v5[71];
    v5[71] = 0;
    G_MissileTrace(v10, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102));
    v5[71] = v3;
  }
  *((float *)s + 78) = v10[1];
  *((float *)s + 79) = v10[2];
  *((float *)s + 80) = v10[3];
  if ( (*((_DWORD *)s + 2) & 0x3000000) != 0 && (v10[0] == 1.0 || v10[0] < 1.0 && v10[6] > 0.69999999) )
  {
    v12 = *((float *)s + 78);
    v13 = *((float *)s + 79);
    v14 = *((float *)s + 80);
    v14 = v14 - 1.5;
    G_MissileTrace(v9, (char *)s + 312, &v12, *((_DWORD *)s + 84), *((_DWORD *)s + 102));
    if ( v9[0] != 1.0 && LOWORD(v9[10]) == 1022 )
    {
      qmemcpy(v10, v9, sizeof(v10));
      *((float *)s + 8) = v10[3] + 1.5 - *((float *)s + 80) + *((float *)s + 8);
      *((float *)s + 78) = v10[1];
      *((float *)s + 79) = v10[2];
      *((float *)s + 80) = v10[3];
      *((float *)s + 80) = *((float *)s + 80) + 1.5;
    }
  }
  trap_LinkEntity(s);
  if ( *((_DWORD *)s + 148) == 3 )
    G_GrenadeTouchTriggerDamage(s, v8, (char *)s + 312, *((_DWORD *)s + 145), *((_DWORD *)s + 148));
  if ( v10[0] == 1.0 )
  {
    v2 = sqrt(
           *((float *)s + 9) * *((float *)s + 9)
         + *((float *)s + 10) * *((float *)s + 10)
         + *((float *)s + 11) * *((float *)s + 11));
    if ( v2 != 0.0 )
      *((_DWORD *)s + 31) = 1023;
    return (void *)G_RunThink(s);
  }
  if ( (LOBYTE(v10[7]) & 0x10) != 0 )
    return (void *)G_FreeEntity(s);
  G_MissileImpact(s, v10);
  result = s;
  if ( *((_DWORD *)s + 1) == 4 )
    return (void *)G_RunThink(s);
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13CB0: using guessed type _DWORD __cdecl trap_PointContents(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 142E0: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 14310: using guessed type _DWORD __cdecl G_MissileImpact(_DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);
// 14E30: using guessed type _DWORD __cdecl G_GrenadeTouchTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15120: using guessed type _DWORD __cdecl G_MissileTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0005518E) --------------------------------------------------------
int __cdecl DynaSink(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 284) = 0;
  if ( *(_DWORD *)(a1 + 468) >= level[122] )
  {
    *(float *)(a1 + 32) = *(float *)(a1 + 32) - 0.5;
    result = level[122] + 50;
  }
  else
  {
    *(_DWORD *)(a1 + 520) = G_FreeEntity;
    result = level[122] + 100;
  }
  *(_DWORD *)(a1 + 516) = result;
  return result;
}

//----- (00055226) --------------------------------------------------------
int __cdecl fire_grenade(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4)
{
  long double v4; // fst7
  long double v5; // fst7
  float v7; // [esp+0h] [ebp-28h]
  _DWORD *v8; // [esp+18h] [ebp-10h]
  int v9; // [esp+1Ch] [ebp-Ch]

  v9 = G_Spawn();
  if ( a1[87] && *(_DWORD *)(a1[87] + 52) )
    *(_DWORD *)(v9 + 516) = level[122] + *(_DWORD *)(a1[87] + 52);
  else
    *(_DWORD *)(v9 + 516) = level[122] + 2500;
  if ( a1[87] )
    *(_DWORD *)(a1[87] + 52) = 0;
  *(_DWORD *)(v9 + 520) = G_ExplodeMissile;
  *(_DWORD *)(v9 + 4) = 4;
  *(_DWORD *)(v9 + 244) = 136;
  *(_DWORD *)(v9 + 200) = a4;
  *(_DWORD *)(v9 + 336) = *a1;
  *(_DWORD *)(v9 + 416) = a1;
  v8 = (_DWORD *)BG_GetInfoForWeapon(a4);
  Scr_SetString(v9 + 380, scr_const[31]);
  *(_DWORD *)(v9 + 576) = v8[112];
  *(_DWORD *)(v9 + 580) = v8[198];
  *(_DWORD *)(v9 + 584) = v8[199];
  *(_DWORD *)(v9 + 588) = v8[197];
  *(_DWORD *)(v9 + 592) = 3;
  *(_DWORD *)(v9 + 596) = 4;
  *(_DWORD *)(v9 + 8) = 50331648;
  *(_DWORD *)(v9 + 408) = 41951377;
  *(_DWORD *)(v9 + 12) = 5;
  *(_DWORD *)(v9 + 16) = level[122];
  *(_DWORD *)(v9 + 24) = *a2;
  *(_DWORD *)(v9 + 28) = a2[1];
  *(_DWORD *)(v9 + 32) = a2[2];
  *(_DWORD *)(v9 + 36) = *a3;
  *(_DWORD *)(v9 + 40) = a3[1];
  *(_DWORD *)(v9 + 44) = a3[2];
  *(float *)(v9 + 36) = (float)(int)*(float *)(v9 + 36);
  *(float *)(v9 + 40) = (float)(int)*(float *)(v9 + 40);
  *(float *)(v9 + 44) = (float)(int)*(float *)(v9 + 44);
  *(_DWORD *)(v9 + 48) = 2;
  *(_DWORD *)(v9 + 52) = level[122];
  vectoangles(a3, v9 + 60);
  v4 = *(float *)(v9 + 60) - 120.0;
  v7 = v4;
  AngleNormalize360(v7);
  *(float *)(v9 + 60) = v4;
  flrand(-45.0, 45.0);
  v5 = v4 + 720.0;
  *(float *)(v9 + 72) = v5;
  *(_DWORD *)(v9 + 76) = 0;
  flrand(-45.0, 45.0);
  *(float *)(v9 + 80) = v5 + 360.0;
  *(_DWORD *)(v9 + 312) = *a2;
  *(_DWORD *)(v9 + 316) = a2[1];
  *(_DWORD *)(v9 + 320) = a2[2];
  *(_DWORD *)(v9 + 324) = *(_DWORD *)(v9 + 60);
  *(_DWORD *)(v9 + 328) = *(_DWORD *)(v9 + 64);
  *(_DWORD *)(v9 + 332) = *(_DWORD *)(v9 + 68);
  return v9;
}
// 12E70: using guessed type int G_Spawn(void);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (00055582) --------------------------------------------------------
int __cdecl fire_rocket(_DWORD *a1, _DWORD *a2, float *a3)
{
  _DWORD *v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  VectorNormalize(a3);
  v4 = (_DWORD *)BG_GetInfoForWeapon(a1[50]);
  v5 = G_Spawn();
  Scr_SetString(v5 + 380, scr_const[55]);
  *(_DWORD *)(v5 + 516) = level[122] + 30000;
  *(_DWORD *)(v5 + 520) = G_ExplodeMissile;
  *(_DWORD *)(v5 + 4) = 4;
  *(_DWORD *)(v5 + 8) |= 0x10000u;
  *(_DWORD *)(v5 + 244) = 136;
  *(_DWORD *)(v5 + 200) = a1[50];
  *(_DWORD *)(v5 + 336) = *a1;
  *(_DWORD *)(v5 + 416) = a1;
  *(_DWORD *)(v5 + 576) = v4[112];
  *(_DWORD *)(v5 + 580) = v4[198];
  *(_DWORD *)(v5 + 584) = v4[199];
  *(_DWORD *)(v5 + 588) = v4[197];
  *(_DWORD *)(v5 + 592) = 5;
  *(_DWORD *)(v5 + 596) = 6;
  *(_DWORD *)(v5 + 408) = 41951377;
  *(_DWORD *)(v5 + 12) = 2;
  *(_DWORD *)(v5 + 16) = level[122] - 50;
  *(_DWORD *)(v5 + 24) = *a2;
  *(_DWORD *)(v5 + 28) = a2[1];
  *(_DWORD *)(v5 + 32) = a2[2];
  *(float *)(v5 + 36) = (long double)(int)v4[200] * *a3;
  *(float *)(v5 + 40) = (long double)(int)v4[200] * a3[1];
  *(float *)(v5 + 44) = (long double)(int)v4[200] * a3[2];
  *(float *)(v5 + 36) = (float)(int)*(float *)(v5 + 36);
  *(float *)(v5 + 40) = (float)(int)*(float *)(v5 + 40);
  *(float *)(v5 + 44) = (float)(int)*(float *)(v5 + 44);
  *(_DWORD *)(v5 + 312) = *a2;
  *(_DWORD *)(v5 + 316) = a2[1];
  *(_DWORD *)(v5 + 320) = a2[2];
  vectoangles(v5 + 36, v5 + 324);
  G_SetAngle(v5, v5 + 324);
  return v5;
}
// 12E70: using guessed type int G_Spawn(void);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0005582E) --------------------------------------------------------
void sub_5582E()
{
  ;
}

//----- (00055834) --------------------------------------------------------
_DWORD *__cdecl G_TestEntityPosition(_DWORD *a1, int a2)
{
  _DWORD *v3; // [esp+28h] [ebp-40h]
  int v4; // [esp+2Ch] [ebp-3Ch]
  char v5[40]; // [esp+30h] [ebp-38h] BYREF
  unsigned __int16 v6; // [esp+58h] [ebp-10h]
  char v7; // [esp+5Fh] [ebp-9h]

  if ( a1[102] )
  {
    if ( a1[71] == 0x4000000 )
      return 0;
    v4 = a1[102];
  }
  else
  {
    v4 = 17;
  }
  if ( a1[1] == 4 )
    trap_Trace(v5, a2, a1 + 65, a1 + 68, a2, a1[84], v4);
  else
    trap_Trace(v5, a2, a1 + 65, a1 + 68, a2, *a1, v4);
  if ( v7 )
    v3 = &g_entities[199 * v6];
  else
    v3 = 0;
  return v3;
}
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00055943) --------------------------------------------------------
int __cdecl G_CreateRotationMatrix(int a1, int a2)
{
  AngleVectors(a1, a2, a2 + 12, a2 + 24);
  return VectorInverse(a2 + 12);
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14780: using guessed type _DWORD __cdecl VectorInverse(_DWORD);

//----- (0005598F) --------------------------------------------------------
int *__cdecl G_TransposeMatrix(int a1, int a2)
{
  int *result; // eax
  int j; // [esp+0h] [ebp-Ch]
  int i; // [esp+4h] [ebp-8h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    for ( j = 0; j <= 2; ++j )
      *(_DWORD *)(a2 + 4 * (j + 3 * i)) = *(_DWORD *)(a1 + 4 * (i + 3 * j));
    result = &i;
  }
  return result;
}

//----- (000559FA) --------------------------------------------------------
float *__cdecl G_RotatePoint(float *a1, float *a2)
{
  float *result; // eax
  float v3; // [esp+0h] [ebp-18h]
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  *a1 = *a2 * *a1 + a2[1] * v4 + a2[2] * v5;
  a1[1] = a2[3] * v3 + a2[4] * v4 + a2[5] * v5;
  result = a2 + 8;
  a1[2] = a2[6] * v3 + a2[7] * v4 + a2[8] * v5;
  return result;
}

//----- (00055AA1) --------------------------------------------------------
int __cdecl G_TryPushingEntity(int a1, int a2, float *a3, int a4)
{
  int v5; // [esp+14h] [ebp-E4h]
  float v6; // [esp+20h] [ebp-D8h] BYREF
  float v7; // [esp+24h] [ebp-D4h]
  float v8; // [esp+28h] [ebp-D0h]
  float v9; // [esp+38h] [ebp-C0h]
  float v10; // [esp+3Ch] [ebp-BCh]
  float v11; // [esp+40h] [ebp-B8h]
  float v12; // [esp+44h] [ebp-B4h]
  float v13; // [esp+48h] [ebp-B0h]
  float v14; // [esp+4Ch] [ebp-ACh]
  char v15[48]; // [esp+50h] [ebp-A8h] BYREF
  char v16[60]; // [esp+80h] [ebp-78h] BYREF
  int v17; // [esp+BCh] [ebp-3Ch]
  float v18; // [esp+C0h] [ebp-38h]
  float v19; // [esp+C4h] [ebp-34h]
  float v20; // [esp+C8h] [ebp-30h]
  float v21; // [esp+D0h] [ebp-28h] BYREF
  float v22; // [esp+D4h] [ebp-24h]
  float v23; // [esp+D8h] [ebp-20h]
  float v24; // [esp+E0h] [ebp-18h]
  float v25; // [esp+E4h] [ebp-14h]
  float v26; // [esp+E8h] [ebp-10h]

  if ( (*(_DWORD *)(a2 + 8) & 0x4000000) != 0 && *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
    return 0;
  v6 = *(float *)(a1 + 312) + *a3;
  v7 = *(float *)(a1 + 316) + a3[1];
  v8 = *(float *)(a1 + 320) + a3[2];
  G_CreateRotationMatrix(a4, v15);
  G_TransposeMatrix(v15, v16);
  v24 = v6 - *(float *)(a2 + 312);
  v25 = v7 - *(float *)(a2 + 316);
  v26 = v8 - *(float *)(a2 + 320);
  v21 = v24;
  v22 = v25;
  v23 = v26;
  G_RotatePoint(&v21, v16);
  v18 = v21 - v24;
  v19 = v22 - v25;
  v20 = v23 - v26;
  v6 = v6 + v18;
  v7 = v7 + v19;
  v8 = v8 + v20;
  v17 = G_TestEntityPosition(a1, &v6);
  if ( v17 )
  {
    if ( *(float *)(a1 + 272) / 2.0 <= 4.0 )
      goto LABEL_36;
    v24 = v6;
    v25 = v7;
    v26 = v8;
    v10 = 0.0;
LABEL_12:
    if ( *(float *)(a1 + 272) / 2.0 <= v10 )
    {
LABEL_36:
      v17 = G_TestEntityPosition(a1, a1 + 312);
      if ( v17 )
      {
        v5 = 0;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1023;
        v5 = 1;
      }
    }
    else
    {
      LODWORD(v9) = LODWORD(v10) ^ 0x80000000;
      while ( 1 )
      {
        if ( v10 < (long double)v9 )
        {
LABEL_35:
          v10 = v10 + 4.0;
          goto LABEL_12;
        }
        v14 = 4.0;
LABEL_16:
        if ( *(float *)(a1 + 272) / 2.0 > v14 )
          break;
        if ( v9 == 0.0 )
          goto LABEL_35;
        v9 = v10 + v10 + v9;
      }
      LODWORD(v13) = LODWORD(v14) ^ 0x80000000;
      while ( 1 )
      {
        if ( v14 < (long double)v13 )
        {
          v14 = v14 + 4.0;
          goto LABEL_16;
        }
        v12 = 4.0;
LABEL_20:
        if ( *(float *)(a1 + 272) / 2.0 > v12 )
          break;
        v13 = v14 + v14 + v13;
      }
      LODWORD(v11) = LODWORD(v12) ^ 0x80000000;
      while ( 1 )
      {
        if ( v12 < (long double)v11 )
        {
          v12 = v12 + 4.0;
          goto LABEL_20;
        }
        v18 = v13;
        v19 = v11;
        v20 = v9;
        v21 = v24 + v13;
        v22 = v25 + v11;
        v23 = v26 + v9;
        v17 = G_TestEntityPosition(a1, &v21);
        if ( !v17 )
          break;
        v11 = v12 + v12 + v11;
      }
      if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
        *(_DWORD *)(a1 + 124) = 1023;
      *(float *)(a1 + 312) = v21;
      *(float *)(a1 + 316) = v22;
      *(float *)(a1 + 320) = v23;
      *(float *)(a1 + 24) = v21;
      *(float *)(a1 + 28) = v22;
      *(float *)(a1 + 32) = v23;
      if ( *(_DWORD *)(a1 + 348) )
      {
        *(_DWORD *)(*(_DWORD *)(a1 + 348) + 76) += (unsigned __int16)(int)(*(float *)(a4 + 4) * 182.04445);
        *(float *)(*(_DWORD *)(a1 + 348) + 20) = v21;
        *(float *)(*(_DWORD *)(a1 + 348) + 24) = v22;
        *(float *)(*(_DWORD *)(a1 + 348) + 28) = v23;
      }
      dword_A65C0 += 32;
      v5 = 1;
    }
  }
  else
  {
    if ( *(_DWORD *)(a1 + 124) != *(_DWORD *)a2 )
      *(_DWORD *)(a1 + 124) = 1023;
    *(float *)(a1 + 312) = v6;
    *(float *)(a1 + 316) = v7;
    *(float *)(a1 + 320) = v8;
    *(float *)(a1 + 24) = v6;
    *(float *)(a1 + 28) = v7;
    *(float *)(a1 + 32) = v8;
    if ( *(_DWORD *)(a1 + 348) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 76) += (unsigned __int16)(int)(*(float *)(a4 + 4) * 182.04445);
      *(float *)(*(_DWORD *)(a1 + 348) + 20) = v6;
      *(float *)(*(_DWORD *)(a1 + 348) + 24) = v7;
      *(float *)(*(_DWORD *)(a1 + 348) + 28) = v8;
    }
    dword_A65C0 += 32;
    v5 = 1;
  }
  return v5;
}
// 13380: using guessed type _DWORD __cdecl G_TransposeMatrix(_DWORD, _DWORD);
// 13F30: using guessed type _DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD);
// 14540: using guessed type _DWORD __cdecl G_CreateRotationMatrix(_DWORD, _DWORD);
// 14900: using guessed type _DWORD __cdecl G_RotatePoint(_DWORD, _DWORD);
// A65C0: using guessed type int dword_A65C0;

//----- (000560D7) --------------------------------------------------------
int __cdecl sub_560D7(int a1, float *a2, float *a3, _DWORD *a4)
{
  float v6; // [esp+3Ch] [ebp-207Ch]
  float v7[4]; // [esp+40h] [ebp-2078h] BYREF
  float v8[6]; // [esp+50h] [ebp-2068h] BYREF
  int v9; // [esp+68h] [ebp-2050h]
  int v10; // [esp+6Ch] [ebp-204Ch]
  int v11[1024]; // [esp+70h] [ebp-2048h]
  int v12[1024]; // [esp+1070h] [ebp-1048h] BYREF
  float v13[4]; // [esp+2070h] [ebp-48h]
  float v14[5]; // [esp+2080h] [ebp-38h]
  _DWORD *v15; // [esp+2094h] [ebp-24h]
  int j; // [esp+2098h] [ebp-20h]
  int i; // [esp+209Ch] [ebp-1Ch]

  *a4 = 0;
  if ( *(float *)(a1 + 324) == 0.0
    && *(float *)(a1 + 328) == 0.0
    && *(float *)(a1 + 332) == 0.0
    && *a3 == 0.0
    && a3[1] == 0.0
    && a3[2] == 0.0 )
  {
    for ( i = 0; i <= 2; ++i )
    {
      v14[i] = *(float *)(a1 + 4 * i + 288) + a2[i];
      v13[i] = *(float *)(a1 + 4 * i + 300) + a2[i];
    }
    v8[0] = *(float *)(a1 + 288);
    v8[1] = *(float *)(a1 + 292);
    v8[2] = *(float *)(a1 + 296);
    v7[0] = *(float *)(a1 + 300);
    v7[1] = *(float *)(a1 + 304);
    v7[2] = *(float *)(a1 + 308);
  }
  else
  {
    v6 = RadiusFromBounds(a1 + 260, a1 + 272);
    for ( i = 0; i <= 2; ++i )
    {
      v14[i] = *(float *)(a1 + 4 * i + 312) - v6 + a2[i];
      v13[i] = *(float *)(a1 + 4 * i + 312) + v6 + a2[i];
      v8[i] = *(float *)(a1 + 4 * i + 312) - v6;
      v7[i] = *(float *)(a1 + 4 * i + 312) + v6;
    }
  }
  for ( i = 0; i <= 2; ++i )
  {
    if ( a2[i] <= 0.0 )
      v8[i] = v8[i] + a2[i];
    else
      v7[i] = v7[i] + a2[i];
  }
  trap_UnlinkEntity(a1);
  v10 = trap_EntitiesInBox(v8, v7, v12, 1024, 33554816);
  *(float *)(a1 + 312) = *(float *)(a1 + 312) + *a2;
  *(float *)(a1 + 316) = *(float *)(a1 + 316) + a2[1];
  *(float *)(a1 + 320) = *(float *)(a1 + 320) + a2[2];
  *(float *)(a1 + 324) = *(float *)(a1 + 324) + *a3;
  *(float *)(a1 + 328) = *(float *)(a1 + 328) + a3[1];
  *(float *)(a1 + 332) = *(float *)(a1 + 332) + a3[2];
  trap_LinkEntity(a1);
  v9 = 0;
  for ( j = 0; j < v10; ++j )
  {
    v15 = &g_entities[199 * v12[j]];
    if ( (v15[1] == 4 || v15[1] == 3 || v15[1] == 1 || *((_BYTE *)v15 + 357))
      && (v15[31] == *(_DWORD *)a1
       || *((float *)v15 + 72) < (long double)v13[0]
       && *((float *)v15 + 73) < (long double)v13[1]
       && *((float *)v15 + 74) < (long double)v13[2]
       && v14[0] < (long double)*((float *)v15 + 75)
       && v14[1] < (long double)*((float *)v15 + 76)
       && v14[2] < (long double)*((float *)v15 + 77)
       && G_TestEntityPosition(v15, v15 + 78) == a1) )
    {
      v11[v9++] = v12[j];
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[199 * v11[j]];
    trap_UnlinkEntity(v15);
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[199 * v11[j]];
    *(_DWORD *)dword_A65C0 = v15;
    *(_DWORD *)(dword_A65C0 + 4) = v15[78];
    *(_DWORD *)(dword_A65C0 + 8) = v15[79];
    *(_DWORD *)(dword_A65C0 + 12) = v15[80];
    *(float *)(dword_A65C0 + 28) = a3[1];
    if ( G_TryPushingEntity(v15, a1, a2, a3) || v15[1] == 3 )
    {
      trap_LinkEntity(v15);
    }
    else
    {
      if ( *(_DWORD *)(a1 + 12) != 4 && *(_DWORD *)(a1 + 48) != 4 )
      {
        *a4 = v15;
        return 0;
      }
      G_Damage(v15, a1, a1, 0, 0, 99999, 0, 19, 0);
    }
  }
  for ( j = 0; j < v9; ++j )
  {
    v15 = &g_entities[199 * v11[j]];
    trap_LinkEntity(v15);
  }
  return 1;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13C00: using guessed type _DWORD __cdecl G_TryPushingEntity(_DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13F30: using guessed type _DWORD __cdecl G_TestEntityPosition(_DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14FB0: using guessed type double __cdecl RadiusFromBounds(_DWORD, _DWORD);
// A65C0: using guessed type int dword_A65C0;

//----- (000567B5) --------------------------------------------------------
int __cdecl G_MoverTeam(int a1)
{
  int result; // eax
  unsigned int j; // [esp+18h] [ebp-70h]
  _DWORD *v3; // [esp+1Ch] [ebp-6Ch]
  float v4[4]; // [esp+20h] [ebp-68h] BYREF
  float v5[6]; // [esp+30h] [ebp-58h] BYREF
  int v6; // [esp+48h] [ebp-40h] BYREF
  int i; // [esp+4Ch] [ebp-3Ch]
  float v8[4]; // [esp+50h] [ebp-38h] BYREF
  float v9[10]; // [esp+60h] [ebp-28h] BYREF

  v6 = 0;
  dword_A65C0 = (int)&pushed;
  for ( i = a1; i; i = *(_DWORD *)(i + 616) )
  {
    BG_EvaluateTrajectory(i + 12, level[122], v5);
    BG_EvaluateTrajectory(i + 48, level[122], v4);
    v9[0] = v5[0] - *(float *)(i + 312);
    v9[1] = v5[1] - *(float *)(i + 316);
    v9[2] = v5[2] - *(float *)(i + 320);
    v8[0] = v4[0] - *(float *)(i + 324);
    v8[1] = v4[1] - *(float *)(i + 328);
    v8[2] = v4[2] - *(float *)(i + 332);
    if ( !sub_560D7(i, v9, v8, &v6) )
    {
      for ( j = dword_A65C0 - 32; j >= (unsigned int)&pushed; j -= 32 )
      {
        v3 = *(_DWORD **)j;
        v3[78] = *(_DWORD *)(j + 4);
        v3[79] = *(_DWORD *)(j + 8);
        v3[80] = *(_DWORD *)(j + 12);
        v3[6] = *(_DWORD *)(j + 4);
        v3[7] = *(_DWORD *)(j + 8);
        v3[8] = *(_DWORD *)(j + 12);
        if ( v3[87] )
        {
          *(_DWORD *)(v3[87] + 76) -= (unsigned __int16)(int)(*(float *)(j + 28) * 182.04445);
          *(_DWORD *)(v3[87] + 20) = *(_DWORD *)(j + 4);
          *(_DWORD *)(v3[87] + 24) = *(_DWORD *)(j + 8);
          *(_DWORD *)(v3[87] + 28) = *(_DWORD *)(j + 12);
        }
        trap_LinkEntity(v3);
      }
      for ( i = a1; i; i = *(_DWORD *)(i + 616) )
      {
        *(_DWORD *)(i + 16) += level[122] - level[123];
        *(_DWORD *)(i + 52) += level[122] - level[123];
        BG_EvaluateTrajectory(i + 12, level[122], i + 312);
        BG_EvaluateTrajectory(i + 48, level[122], i + 324);
        trap_LinkEntity(i);
      }
      result = a1;
      if ( *(_DWORD *)(a1 + 528) )
        result = (*(int (__cdecl **)(int, int))(a1 + 528))(a1, v6);
      return result;
    }
  }
  result = a1;
  for ( i = a1; i; i = result )
  {
    if ( *(_DWORD *)(i + 12) && level[122] >= *(_DWORD *)(i + 16) + *(_DWORD *)(i + 20) && *(_DWORD *)(i + 524) )
      (*(void (__cdecl **)(int))(i + 524))(i);
    if ( *(_DWORD *)(i + 48) && level[122] >= *(_DWORD *)(i + 52) + *(_DWORD *)(i + 56) && *(_DWORD *)(i + 524) )
      (*(void (__cdecl **)(int))(i + 524))(i);
    result = *(_DWORD *)(i + 616);
  }
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// A65C0: using guessed type int dword_A65C0;

//----- (00056B81) --------------------------------------------------------
int __cdecl G_RunMover(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 748) )
  {
    G_GeneralLink(a1);
    return G_RunThink(a1);
  }
  if ( (*(_DWORD *)(a1 + 388) & 4) == 0 )
  {
    if ( *(_DWORD *)(a1 + 12) || *(_DWORD *)(a1 + 48) )
      G_MoverTeam(a1);
    return G_RunThink(a1);
  }
  if ( *(_DWORD *)(a1 + 240) && *(_WORD *)(a1 + 380) == scr_const[29]
    || (result = a1, *(_DWORD *)(a1 + 240))
    && (result = *(unsigned __int16 *)(a1 + 380), (_WORD)result == scr_const[28]) )
  {
    result = trap_UnlinkEntity(a1);
  }
  return result;
}
// 142E0: using guessed type _DWORD __cdecl G_RunThink(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 14870: using guessed type _DWORD __cdecl G_MoverTeam(_DWORD);
// 14A10: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);

//----- (00056C4D) --------------------------------------------------------
int __cdecl SetMoverState(int a1, int a2, int a3)
{
  int v3; // eax
  int result; // eax
  int v5; // [esp+28h] [ebp-20h]
  float v6; // [esp+2Ch] [ebp-1Ch]
  float v7; // [esp+2Ch] [ebp-1Ch]
  float v8; // [esp+2Ch] [ebp-1Ch]
  float v9; // [esp+2Ch] [ebp-1Ch]
  float v10; // [esp+2Ch] [ebp-1Ch]
  float v11; // [esp+2Ch] [ebp-1Ch]
  float v12; // [esp+30h] [ebp-18h]
  float v13; // [esp+30h] [ebp-18h]
  float v14; // [esp+30h] [ebp-18h]
  float v15; // [esp+30h] [ebp-18h]
  float v16; // [esp+34h] [ebp-14h]
  float v17; // [esp+34h] [ebp-14h]
  float v18; // [esp+34h] [ebp-14h]
  float v19; // [esp+34h] [ebp-14h]
  float v20; // [esp+38h] [ebp-10h]
  float v21; // [esp+38h] [ebp-10h]
  float v22; // [esp+38h] [ebp-10h]
  float v23; // [esp+38h] [ebp-10h]

  v5 = *(_DWORD *)(a1 + 388) & 0x100;
  *(_BYTE *)(a1 + 376) = a2;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 52) = a3;
  switch ( a2 )
  {
    case 0:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 428);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 432);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 436);
      *(_DWORD *)(a1 + 12) = 0;
      *(_BYTE *)(a1 + 374) = 0;
      break;
    case 1:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 444);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 448);
      *(_DWORD *)(a1 + 12) = 0;
      break;
    case 2:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 456);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 12) = 0;
      break;
    case 3:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 428);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 432);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 436);
      v14 = *(float *)(a1 + 440) - *(float *)(a1 + 428);
      v18 = *(float *)(a1 + 444) - *(float *)(a1 + 432);
      v22 = *(float *)(a1 + 448) - *(float *)(a1 + 436);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 508);
      v8 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v14 * v8;
      *(float *)(a1 + 40) = v18 * v8;
      *(float *)(a1 + 44) = v22 * v8;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 4:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 444);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 448);
      v15 = *(float *)(a1 + 428) - *(float *)(a1 + 440);
      v19 = *(float *)(a1 + 432) - *(float *)(a1 + 444);
      v23 = *(float *)(a1 + 436) - *(float *)(a1 + 448);
      if ( *(float *)(a1 + 492) == 0.0 )
      {
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 508);
        v9 = 1000.0 / (long double)*(int *)(a1 + 20);
      }
      else
      {
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 512);
        v9 = 1000.0 / (long double)*(int *)(a1 + 512);
      }
      *(float *)(a1 + 36) = v15 * v9;
      *(float *)(a1 + 40) = v19 * v9;
      *(float *)(a1 + 44) = v23 * v9;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 5:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 440);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 444);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 448);
      v12 = *(float *)(a1 + 452) - *(float *)(a1 + 440);
      v16 = *(float *)(a1 + 456) - *(float *)(a1 + 444);
      v20 = *(float *)(a1 + 460) - *(float *)(a1 + 448);
      v6 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v12 * v6;
      *(float *)(a1 + 40) = v16 * v6;
      *(float *)(a1 + 44) = v20 * v6;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 6:
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 456);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 460);
      v13 = *(float *)(a1 + 440) - *(float *)(a1 + 452);
      v17 = *(float *)(a1 + 444) - *(float *)(a1 + 456);
      v21 = *(float *)(a1 + 448) - *(float *)(a1 + 460);
      v7 = 1000.0 / (long double)*(int *)(a1 + 20);
      *(float *)(a1 + 36) = v13 * v7;
      *(float *)(a1 + 40) = v17 * v7;
      *(float *)(a1 + 44) = v21 * v7;
      *(_DWORD *)(a1 + 12) = 3;
      break;
    case 7:
    case 8:
      *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 324);
      *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 328);
      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 332);
      *(_DWORD *)(a1 + 48) = 0;
      break;
    case 9:
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      *(_DWORD *)(a1 + 60) = 0;
      if ( v5 )
      {
        v10 = 500.0 / (long double)*(int *)(a1 + 508);
        v3 = 2 * *(_DWORD *)(a1 + 508);
      }
      else
      {
        v10 = 1000.0 / (long double)*(int *)(a1 + 508);
        v3 = *(_DWORD *)(a1 + 508);
      }
      *(_DWORD *)(a1 + 56) = v3;
      *(float *)(a1 + 72) = v10 * *(float *)(a1 + 472) * *(float *)(a1 + 648);
      *(float *)(a1 + 76) = v10 * *(float *)(a1 + 472) * *(float *)(a1 + 652);
      *(float *)(a1 + 80) = v10 * *(float *)(a1 + 472) * *(float *)(a1 + 656);
      *(_DWORD *)(a1 + 48) = 3;
      break;
    case 10:
      *(float *)(a1 + 60) = *(float *)(a1 + 648) * *(float *)(a1 + 472);
      *(float *)(a1 + 64) = *(float *)(a1 + 652) * *(float *)(a1 + 472);
      *(float *)(a1 + 68) = *(float *)(a1 + 656) * *(float *)(a1 + 472);
      v11 = 1000.0 / (long double)*(int *)(a1 + 508);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(a1 + 508);
      if ( v5 )
      {
        *(_DWORD *)(a1 + 56) *= 2;
        v11 = v11 * 0.5;
      }
      *(float *)(a1 + 72) = -v11 * *(float *)(a1 + 60);
      *(float *)(a1 + 76) = -v11 * *(float *)(a1 + 64);
      *(float *)(a1 + 80) = -v11 * *(float *)(a1 + 68);
      *(_DWORD *)(a1 + 48) = 3;
      *(_BYTE *)(a1 + 374) = 0;
      break;
    default:
      break;
  }
  BG_EvaluateTrajectory(a1 + 12, level[122], a1 + 312);
  if ( (*(_DWORD *)(a1 + 244) & 1) == 0 || (result = a1, *(_DWORD *)(a1 + 284)) )
    result = trap_LinkEntity(a1);
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0005731B) --------------------------------------------------------
int __cdecl MatchTeam(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = a1;
  for ( i = a1; i; i = result )
  {
    if ( (*(_DWORD *)(a1 + 388) & 0x100) != 0 )
      *(_DWORD *)(i + 388) |= 0x100u;
    SetMoverState(i, a2, a3);
    result = *(_DWORD *)(i + 616);
  }
  return result;
}
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00057392) --------------------------------------------------------
int __cdecl MatchTeamReverseAngleOnSlaves(int a1, int a2, int a3)
{
  int result; // eax
  int i; // [esp+10h] [ebp-8h]

  result = a1;
  for ( i = a1; i; i = result )
  {
    *(float *)(i + 472) = *(float *)(i + 472) * -1.0;
    if ( (*(_DWORD *)(a1 + 388) & 0x100) != 0 )
      *(_DWORD *)(i + 388) |= 0x100u;
    SetMoverState(i, a2, a3);
    result = *(_DWORD *)(i + 616);
  }
  return result;
}
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00057423) --------------------------------------------------------
int __cdecl ReturnToPos1(int a1)
{
  int result; // eax

  MatchTeam(a1, 4, level[122]);
  G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 360));
  *(_DWORD *)(a1 + 132) = 0;
  result = *(unsigned __int8 *)(a1 + 364);
  *(_DWORD *)(a1 + 132) = result;
  return result;
}
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (00057497) --------------------------------------------------------
int __cdecl ReturnToPos2(int a1)
{
  MatchTeam(a1, 6, level[122]);
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 362);
  return G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 364));
}
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (0005750B) --------------------------------------------------------
int __cdecl GotoPos3(int a1)
{
  MatchTeam(a1, 5, level[122]);
  *(_DWORD *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 362);
  return G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 363));
}
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (0005757F) --------------------------------------------------------
int __cdecl ReturnToPos1Rotate(int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = 0;
  MatchTeam(a1, 10, level[122]);
  v2 = G_Find(0, 380, scr_const[49]);
  if ( v2 )
    v3 = trap_InPVS(v2 + 312, a1 + 312);
  if ( v3 )
  {
    if ( (*(_DWORD *)(a1 + 388) & 0x100) != 0 )
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 368));
    else
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 360));
  }
  result = a1;
  *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 364);
  return result;
}
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 148B0: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 151B0: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (0005766A) --------------------------------------------------------
void __cdecl Reached_BinaryMover(int a1)
{
  char v1; // [esp+4h] [ebp-24h]
  int v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+1Ch] [ebp-Ch]
  int v4; // [esp+20h] [ebp-8h]

  v4 = 0;
  *(_DWORD *)(a1 + 132) = 0;
  if ( (*(_DWORD *)(a1 + 388) & 0x100) != 0 )
    v4 = 1;
  switch ( *(_BYTE *)(a1 + 376) )
  {
    case 3:
      SetMoverState(a1, 1, level[122]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 361));
      if ( !*(_DWORD *)(a1 + 612) )
        *(_DWORD *)(a1 + 612) = a1;
      if ( *(char *)(a1 + 388) >= 0 )
      {
        if ( *(float *)(a1 + 624) != -1000.0 )
        {
          *(_DWORD *)(a1 + 520) = ReturnToPos1;
          *(_DWORD *)(a1 + 516) = level[122] + (int)*(float *)(a1 + 624);
        }
      }
      else
      {
        *(_BYTE *)(a1 + 374) = 0;
        *(_DWORD *)(a1 + 520) = ReturnToPos1;
        *(_DWORD *)(a1 + 516) = 0;
      }
      return;
    case 4:
      SetMoverState(a1, 0, level[122]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 369));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 358));
      if ( *(_DWORD *)(a1 + 620) == a1 || !*(_DWORD *)(a1 + 620) )
        goto LABEL_19;
      break;
    case 9:
      SetMoverState(a1, 8, level[122]);
      if ( v4 )
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 367));
      else
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 361));
      if ( !*(_DWORD *)(a1 + 612) )
        *(_DWORD *)(a1 + 612) = a1;
      if ( *(char *)(a1 + 388) >= 0 )
      {
        if ( *(float *)(a1 + 624) != -1000.0 )
        {
          *(_DWORD *)(a1 + 520) = ReturnToPos1Rotate;
          *(_DWORD *)(a1 + 516) = level[122] + (int)*(float *)(a1 + 624);
        }
      }
      else
      {
        *(_BYTE *)(a1 + 374) = 0;
        *(_DWORD *)(a1 + 520) = ReturnToPos1Rotate;
        *(_DWORD *)(a1 + 516) = 0;
      }
      break;
    case 0xA:
      SetMoverState(a1, 7, level[122]);
      v3 = 0;
      v2 = G_Find(0, 380, scr_const[49]);
      if ( v2 )
        v3 = trap_InPVS(v2 + 312, a1 + 312);
      if ( v3 )
      {
        if ( v4 )
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 369));
        else
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 358));
      }
      *(_DWORD *)(a1 + 388) &= 0xFFFFFEFF;
      if ( *(_DWORD *)(a1 + 620) == a1 || !*(_DWORD *)(a1 + 620) )
      {
LABEL_19:
        trap_AdjustAreaPortalState(a1, 0);
        return;
      }
      break;
    default:
      G_Error("Reached_BinaryMover: bad moverState", v1);
      return;
  }
}
// 57AB9: variable 'v1' is possibly undefined
// 13670: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 148B0: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 151B0: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (00057AC4) --------------------------------------------------------
_BOOL4 __cdecl IsBinaryMoverBlocked(int a1, int a2, float *a3)
{
  float v5[7]; // [esp+20h] [ebp-68h] BYREF
  float v6; // [esp+3Ch] [ebp-4Ch]
  float v7; // [esp+40h] [ebp-48h] BYREF
  float v8; // [esp+44h] [ebp-44h]
  float v9; // [esp+48h] [ebp-40h]
  float v10; // [esp+50h] [ebp-38h]
  float v11; // [esp+54h] [ebp-34h]
  float v12; // [esp+58h] [ebp-30h]
  float v13; // [esp+60h] [ebp-28h] BYREF
  float v14; // [esp+64h] [ebp-24h]
  float v15; // [esp+68h] [ebp-20h]
  float v16[6]; // [esp+70h] [ebp-18h] BYREF

  if ( *(_WORD *)(a1 + 380) != scr_const[27] )
    return 0;
  if ( (*(_DWORD *)(a1 + 384) & 0x20) != 0 )
    return 0;
  v10 = *(float *)(a1 + 288) + *(float *)(a1 + 300);
  v11 = *(float *)(a1 + 292) + *(float *)(a1 + 304);
  v12 = *(float *)(a1 + 296) + *(float *)(a1 + 308);
  v10 = v10 * 0.5;
  v11 = v11 * 0.5;
  v12 = v12 * 0.5;
  v16[0] = v10 - *(float *)(a1 + 312);
  v16[1] = v11 - *(float *)(a1 + 316);
  v16[2] = v12 - *(float *)(a1 + 320);
  vectoangles(v16, &v13);
  if ( *(float *)(a1 + 652) == 0.0 )
  {
    if ( *(float *)(a1 + 648) == 0.0 )
    {
      if ( *(float *)(a1 + 656) != 0.0 )
        v15 = v15 + *(float *)(a1 + 472);
    }
    else
    {
      v13 = v13 + *(float *)(a1 + 472);
    }
  }
  else
  {
    v14 = v14 + *(float *)(a1 + 472);
  }
  AngleVectors(&v13, v5, 0, 0);
  v7 = a3[78] - v10;
  v8 = a3[79] - v11;
  v9 = a3[80] - v12;
  VectorNormalize(&v7);
  v6 = v7 * v5[0] + v8 * v5[1] + v9 * v5[2];
  return v6 >= 0.0;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (00057CEA) --------------------------------------------------------
void __cdecl Use_BinaryMover(int a1, int a2, int a3)
{
  int v3; // [esp+18h] [ebp-10h]
  int v4; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  v5 = 0;
  v4 = 0;
  v3 = 0;
  if ( (*(_DWORD *)(a1 + 388) & 0x100) != 0 )
    v5 = 1;
  if ( (int)level[122] <= 4000 )
    v3 = 1;
  if ( (*(_DWORD *)(a1 + 388) & 4) != 0 )
  {
    if ( v5 )
      *(_DWORD *)(*(_DWORD *)(a1 + 620) + 388) |= 0x100u;
    Use_BinaryMover(*(_DWORD *)(a1 + 620), a2, a3);
    return;
  }
  if ( !*(_BYTE *)(a1 + 376) || *(_BYTE *)(a1 + 376) == 7 )
    v4 = IsBinaryMoverBlocked(a1, a2, a3);
  if ( !v4 )
  {
    *(_DWORD *)(a1 + 612) = a3;
    if ( *(_DWORD *)(a1 + 420)
      && *(float *)(*(_DWORD *)(a1 + 420) + 624) == -1.0
      && *(_DWORD *)(*(_DWORD *)(a1 + 420) + 600) == 1 )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 420) + 600) = 0;
      return;
    }
    switch ( *(_BYTE *)(a1 + 376) )
    {
      case 0:
        MatchTeam(a1, 3, level[122] + 50);
        if ( !v3 )
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 359));
        *(_DWORD *)(a1 + 132) = 0;
        if ( !v3 )
          *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 363);
        if ( *(_DWORD *)(a1 + 620) == a1 || !*(_DWORD *)(a1 + 620) )
          goto LABEL_43;
        return;
      case 7:
        MatchTeam(a1, 9, level[122] + 50);
        if ( !v3 )
        {
          if ( v5 )
            G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 366));
          else
            G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 359));
        }
        *(_DWORD *)(a1 + 132) = 0;
        if ( !v3 )
          *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 363);
        if ( *(_DWORD *)(a1 + 620) == a1 || !*(_DWORD *)(a1 + 620) )
          goto LABEL_43;
        return;
      case 1:
        if ( *(char *)(a1 + 388) >= 0 )
        {
          if ( *(float *)(a1 + 624) != -1000.0 )
            *(_DWORD *)(a1 + 516) = level[122] + (int)*(float *)(a1 + 624);
        }
        else
        {
          *(_DWORD *)(a1 + 516) = level[122] + 50;
        }
        return;
      case 8:
        if ( *(char *)(a1 + 388) >= 0 )
          *(_DWORD *)(a1 + 516) = level[122] + (int)*(float *)(a1 + 624);
        else
          *(_DWORD *)(a1 + 516) = level[122] + 50;
        return;
      case 4:
        Blocked_Door(a1, 0);
        if ( v3 )
          return;
        goto LABEL_55;
      case 3:
        Blocked_Door(a1, 0);
        if ( v3 )
          return;
        break;
      case 0xA:
        Blocked_DoorRotate(a1, 0);
        if ( v3 )
          return;
LABEL_55:
        G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 359));
        return;
      case 9:
        Blocked_DoorRotate(a1, 0);
        if ( v3 )
          return;
        if ( v5 )
        {
          G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 368));
          return;
        }
        break;
      default:
        return;
    }
    G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 360));
    return;
  }
  MatchTeamReverseAngleOnSlaves(a1, 9, level[122] + 50);
  if ( !v3 )
  {
    if ( v5 )
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 366));
    else
      G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 359));
  }
  *(_DWORD *)(a1 + 132) = 0;
  if ( !v3 )
    *(_DWORD *)(a1 + 132) = *(unsigned __int8 *)(a1 + 363);
  if ( *(_DWORD *)(a1 + 620) == a1 || !*(_DWORD *)(a1 + 620) )
LABEL_43:
    trap_AdjustAreaPortalState(a1, 1);
}
// 57E72: conditional instruction was optimized away because of '%var_10.4==1'
// 13670: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 13C70: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 13F90: using guessed type _DWORD __cdecl MatchTeamReverseAngleOnSlaves(_DWORD, _DWORD, _DWORD);
// 146E0: using guessed type _DWORD __cdecl IsBinaryMoverBlocked(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (000582EA) --------------------------------------------------------
void __cdecl InitMover(int a1)
{
  int v1; // eax
  int v2; // [esp+24h] [ebp-54h]
  int v3; // [esp+28h] [ebp-50h]
  int v4; // [esp+2Ch] [ebp-4Ch]
  int v5; // [esp+30h] [ebp-48h]
  char *s2; // [esp+34h] [ebp-44h] BYREF
  int v7; // [esp+38h] [ebp-40h]
  int v8; // [esp+3Ch] [ebp-3Ch]
  int v9[6]; // [esp+40h] [ebp-38h] BYREF
  int v10; // [esp+58h] [ebp-20h] BYREF
  float v11; // [esp+5Ch] [ebp-1Ch]
  float v12; // [esp+60h] [ebp-18h]
  float v13; // [esp+64h] [ebp-14h]
  float v14; // [esp+68h] [ebp-10h]

  if ( G_SpawnString("noise", (int)&unk_7B318, (int)&s2) )
    *(_DWORD *)(a1 + 132) = (unsigned __int8)G_SoundAliasIndex(s2);
  v8 = G_SpawnFloat("light", (int)&unk_7B318, (int)&v10);
  v7 = G_SpawnVector("color", (int)"1 1 1", (int)v9);
  if ( v8 || v7 )
  {
    v5 = (int)(*(float *)v9 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v9[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v9[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(*(float *)&v10 / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    *(_DWORD *)(a1 + 128) = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  if ( *(_WORD *)(a1 + 380) == scr_const[28] )
  {
    *(_DWORD *)(a1 + 536) = Use_Func_Rotate;
    *(_DWORD *)(a1 + 524) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 536) = Use_BinaryMover;
    *(_DWORD *)(a1 + 524) = Reached_BinaryMover;
  }
  *(_BYTE *)(a1 + 376) = 0;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 428);
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 436);
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 428);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 432);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 436);
  v12 = *(float *)(a1 + 440) - *(float *)(a1 + 428);
  v13 = *(float *)(a1 + 444) - *(float *)(a1 + 432);
  v14 = *(float *)(a1 + 448) - *(float *)(a1 + 436);
  v11 = sqrt(v12 * v12 + v13 * v13 + v14 * v14);
  if ( *(float *)(a1 + 488) == 0.0 )
    *(_DWORD *)(a1 + 488) = 1120403456;
  *(_DWORD *)(a1 + 20) = (int)(v11 * 1000.0 / *(float *)(a1 + 488));
  if ( *(int *)(a1 + 20) <= 0 )
    *(_DWORD *)(a1 + 20) = 1;
  v1 = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a1 + 508) = v1;
  *(_DWORD *)(a1 + 512) = v1;
  if ( *(float *)(a1 + 492) != 0.0 )
  {
    *(_DWORD *)(a1 + 512) = (int)(v11 * 1000.0 / *(float *)(a1 + 492));
    if ( *(int *)(a1 + 512) <= 0 )
      *(_DWORD *)(a1 + 512) = 1;
  }
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 59B5C: using guessed type int __cdecl Use_Func_Rotate(int);

//----- (0005867C) --------------------------------------------------------
int __cdecl InitMoverRotate(int a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8[7]; // [esp+30h] [ebp-28h] BYREF
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v7 = G_SpawnFloat("light", (int)&unk_7B318, (int)v9);
  v6 = G_SpawnVector("color", (int)"1 1 1", (int)v8);
  if ( v7 || v6 )
  {
    v5 = (int)(*(float *)v8 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v8[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v8[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(v9[0] / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    *(_DWORD *)(a1 + 128) = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  *(_DWORD *)(a1 + 536) = Use_BinaryMover;
  if ( (*(_DWORD *)(a1 + 384) & 0x40) == 0 )
    *(_DWORD *)(a1 + 524) = Reached_BinaryMover;
  *(_BYTE *)(a1 + 376) = 7;
  *(_DWORD *)(a1 + 244) = 128;
  *(_DWORD *)(a1 + 4) = 5;
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  if ( *(float *)(a1 + 488) == 0.0 )
    *(_DWORD *)(a1 + 488) = 1120403456;
  *(_DWORD *)(a1 + 56) = (int)*(float *)(a1 + 488);
  if ( *(int *)(a1 + 56) <= 0 )
    *(_DWORD *)(a1 + 56) = 1;
  result = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 512) = result;
  *(_DWORD *)(a1 + 508) = result;
  return result;
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000588B5) --------------------------------------------------------
int __cdecl Blocked_Door(int a1, void *s)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]

  if ( s )
  {
    if ( !*((_DWORD *)s + 87) )
    {
      G_TempEntity((char *)s + 312, 198);
      return G_FreeEntity(s);
    }
    if ( *(_DWORD *)(a1 + 576) )
      G_Damage(s, a1, a1, 0, 0, *(_DWORD *)(a1 + 576), 0, 19, 0);
  }
  result = *(_DWORD *)(a1 + 384) & 4;
  if ( !result )
  {
    result = a1;
    for ( i = a1; i; i = result )
    {
      v3 = level[122] - (*(_DWORD *)(i + 20) - (level[122] - *(_DWORD *)(i + 16)));
      if ( *(_BYTE *)(i + 376) == 3 )
        SetMoverState(i, 4, v3);
      else
        SetMoverState(i, 3, v3);
      trap_LinkEntity(i);
      result = *(_DWORD *)(i + 616);
    }
  }
  return result;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00058A1E) --------------------------------------------------------
int __cdecl Blocked_DoorRotate(int a1, void *s)
{
  int result; // eax
  int v3; // [esp+24h] [ebp-14h]
  int i; // [esp+28h] [ebp-10h]

  if ( s )
  {
    if ( !*((_DWORD *)s + 87) )
    {
      G_TempEntity((char *)s + 312, 198);
      return G_FreeEntity(s);
    }
    if ( *((int *)s + 142) <= 0 )
      G_Damage(s, a1, a1, 0, 0, 99999, 0, 19, 0);
    if ( *(_DWORD *)(a1 + 576) )
      G_Damage(s, a1, a1, 0, 0, *(_DWORD *)(a1 + 576), 0, 19, 0);
  }
  result = a1;
  for ( i = a1; i; i = result )
  {
    v3 = level[122] - (*(_DWORD *)(i + 56) - (level[122] - *(_DWORD *)(i + 52)));
    if ( *(_BYTE *)(i + 376) == 9 )
      SetMoverState(i, 10, v3);
    else
      SetMoverState(i, 9, v3);
    trap_LinkEntity(i);
    result = *(_DWORD *)(i + 616);
  }
  return result;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00058BC7) --------------------------------------------------------
int __cdecl Touch_DoorTrigger(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 416);
  if ( !*(_DWORD *)(result + 688) )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(a1 + 416) + 376)
      || *(_BYTE *)(*(_DWORD *)(a1 + 416) + 376) == 7
      || (result = *(_DWORD *)(a1 + 416), *(_BYTE *)(result + 376) == 10) )
    {
      result = Use_BinaryMover(*(_DWORD *)(a1 + 416), a1, a2);
    }
  }
  return result;
}
// 13C70: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);

//----- (00058C48) --------------------------------------------------------
int __cdecl sub_58C48(int a1)
{
  int v2; // [esp+18h] [ebp-40h]
  int j; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h] BYREF
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+30h] [ebp-28h] BYREF
  int v8; // [esp+34h] [ebp-24h]
  int v9; // [esp+38h] [ebp-20h]
  int i; // [esp+4Ch] [ebp-Ch]

  for ( i = a1; i; i = *(_DWORD *)(i + 616) )
    *(_BYTE *)(i + 373) = 1;
  v7 = *(_DWORD *)(a1 + 288);
  v8 = *(_DWORD *)(a1 + 292);
  v9 = *(_DWORD *)(a1 + 296);
  v4 = *(_DWORD *)(a1 + 300);
  v5 = *(_DWORD *)(a1 + 304);
  v6 = *(_DWORD *)(a1 + 308);
  for ( i = *(_DWORD *)(a1 + 616); i; i = *(_DWORD *)(i + 616) )
  {
    AddPointToBounds(i + 288, &v7, &v4);
    AddPointToBounds(i + 300, &v7, &v4);
  }
  v2 = 0;
  for ( j = 1; j <= 2; ++j )
  {
    if ( *((float *)&v4 + v2) - *((float *)&v7 + v2) > *((float *)&v4 + j) - *((float *)&v7 + j) )
      v2 = j;
  }
  *((float *)&v4 + v2) = *((float *)&v4 + v2) + 120.0;
  *((float *)&v7 + v2) = *((float *)&v7 + v2) - 120.0;
  i = G_Spawn();
  *(_DWORD *)(i + 260) = v7;
  *(_DWORD *)(i + 264) = v8;
  *(_DWORD *)(i + 268) = v9;
  *(_DWORD *)(i + 272) = v4;
  *(_DWORD *)(i + 276) = v5;
  *(_DWORD *)(i + 280) = v6;
  *(_DWORD *)(i + 416) = a1;
  *(_DWORD *)(i + 284) = 0x40000000;
  *(_DWORD *)(i + 532) = Touch_DoorTrigger;
  trap_LinkEntity(i);
  MatchTeam(a1, *(unsigned __int8 *)(a1 + 376), level[122]);
  return i;
}
// 12E70: using guessed type int G_Spawn(void);
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14C40: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);

//----- (00058E4F) --------------------------------------------------------
int __cdecl Think_SpawnNewDoorTrigger(int a1)
{
  return sub_58C48(a1);
}

//----- (00058E62) --------------------------------------------------------
int __cdecl sub_58E62(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 520) = ReturnToPos1Rotate;
  *(float *)(a1 + 328) = *(float *)(a1 + 328) + *(float *)(a1 + 472);
  SetMoverState(a1, 8, level[122]);
  if ( *(_DWORD *)(a1 + 620) == a1 || (result = a1, !*(_DWORD *)(a1 + 620)) )
    result = trap_AdjustAreaPortalState(a1, 1);
  return result;
}
// 13670: using guessed type _DWORD __cdecl trap_AdjustAreaPortalState(_DWORD, _DWORD);
// 14F60: using guessed type _DWORD __cdecl SetMoverState(_DWORD, _DWORD, _DWORD);

//----- (00058EF4) --------------------------------------------------------
int __cdecl Think_SpawnNewAutoDoorTrigger(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 384) & 1;
  if ( result )
    result = sub_58E62(a1);
  return result;
}

//----- (00058F17) --------------------------------------------------------
int __cdecl Think_MatchTeam(int a1)
{
  return MatchTeam(a1, *(unsigned __int8 *)(a1 + 376), level[122]);
}
// 13D30: using guessed type _DWORD __cdecl MatchTeam(_DWORD, _DWORD, _DWORD);

//----- (00058F58) --------------------------------------------------------
int __cdecl finishSpawningKeyedMover(int a1)
{
  int result; // eax
  int (__cdecl *v2)(int); // eax
  int i; // [esp+0h] [ebp-8h]

  *(_DWORD *)(a1 + 516) = level[122] + 100;
  result = *(_DWORD *)(a1 + 388) & 4;
  if ( !result )
  {
    if ( *(_BYTE *)(a1 + 373) )
    {
      *(_DWORD *)(a1 + 520) = Think_MatchTeam;
    }
    else if ( *(_WORD *)(a1 + 380) == scr_const[27] )
    {
      *(_DWORD *)(a1 + 520) = Think_SpawnNewAutoDoorTrigger;
    }
    else
    {
      if ( (*(_DWORD *)(a1 + 384) & 8) != 0 )
        v2 = Think_SpawnNewDoorTrigger;
      else
        v2 = Think_MatchTeam;
      *(_DWORD *)(a1 + 520) = v2;
    }
    result = a1;
    for ( i = a1; i; i = result )
    {
      if ( i != a1 )
        *(_DWORD *)(i + 688) = *(_DWORD *)(a1 + 688);
      result = *(_DWORD *)(i + 616);
    }
  }
  return result;
}

//----- (00059048) --------------------------------------------------------
int __cdecl Door_reverse_sounds(_BYTE *a1)
{
  int result; // eax
  char v2; // [esp+0h] [ebp-4h]
  char v3; // [esp+0h] [ebp-4h]
  char v4; // [esp+0h] [ebp-4h]
  char v5; // [esp+0h] [ebp-4h]
  unsigned __int8 v6; // [esp+0h] [ebp-4h]

  v2 = a1[359];
  a1[359] = a1[360];
  a1[360] = v2;
  v3 = a1[358];
  a1[358] = a1[361];
  a1[361] = v3;
  v4 = a1[363];
  a1[363] = a1[364];
  a1[364] = v4;
  v5 = a1[366];
  a1[366] = a1[368];
  a1[368] = v5;
  v6 = a1[367];
  a1[367] = a1[369];
  result = v6;
  a1[369] = v6;
  return result;
}

//----- (00059131) --------------------------------------------------------
int __cdecl DoorSetSounds(_BYTE *a1)
{
  int result; // eax

  a1[359] = G_SoundAliasIndex("door_opening");
  a1[361] = G_SoundAliasIndex("door_open_end");
  a1[360] = G_SoundAliasIndex("door_closing");
  a1[358] = G_SoundAliasIndex("door_close_end");
  a1[363] = G_SoundAliasIndex("door_open_loop");
  a1[364] = G_SoundAliasIndex("door_close_loop");
  a1[365] = G_SoundAliasIndex("door_locked");
  a1[366] = G_SoundAliasIndex("door_opening_quiet");
  a1[367] = G_SoundAliasIndex("door_open_quiet_end");
  a1[368] = G_SoundAliasIndex("door_closing_quiet");
  result = G_SoundAliasIndex("door_close_quiet_end");
  a1[369] = result;
  return result;
}

//----- (00059248) --------------------------------------------------------
int __cdecl G_TryDoor(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // [esp+10h] [ebp-8h]

  v4 = *(_DWORD *)(a1 + 388) & 0x100;
  result = a1;
  if ( !*(_DWORD *)(a1 + 48) )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 12) )
    {
      result = a1;
      if ( !*(_BYTE *)(a1 + 374) )
      {
        if ( *(_DWORD *)(a1 + 688) )
        {
          result = G_PlaySoundAlias(a1, *(unsigned __int8 *)(a1 + 365));
        }
        else
        {
          Scr_AddEntity(a3);
          Scr_Notify(a1, scr_const[73], 1);
          if ( *(_DWORD *)(a1 + 620) && *(_WORD *)(a1 + 480) && a1 != *(_DWORD *)(a1 + 620) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 620) + 374) = 1;
            if ( v4 )
              *(_DWORD *)(*(_DWORD *)(a1 + 620) + 388) |= 0x100u;
            result = Use_BinaryMover(*(_DWORD *)(a1 + 620), a3, a3);
          }
          else
          {
            *(_BYTE *)(a1 + 374) = 1;
            if ( v4 )
              *(_DWORD *)(a1 + 388) |= 0x100u;
            result = Use_BinaryMover(a1, a3, a3);
          }
        }
      }
    }
  }
  return result;
}
// 13C70: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000593BD) --------------------------------------------------------
int (__cdecl *__cdecl SP_func_door(int a1))(int a1)
{
  int (__cdecl *result)(int); // eax
  int v2; // [esp+18h] [ebp-60h] BYREF
  int v3; // [esp+1Ch] [ebp-5Ch]
  int v4; // [esp+20h] [ebp-58h]
  int v5; // [esp+24h] [ebp-54h]
  int v6; // [esp+28h] [ebp-50h]
  int v7; // [esp+38h] [ebp-40h] BYREF
  int v8; // [esp+3Ch] [ebp-3Ch] BYREF
  float v9; // [esp+40h] [ebp-38h]
  float v10; // [esp+44h] [ebp-34h]
  float v11; // [esp+48h] [ebp-30h]
  float v12; // [esp+5Ch] [ebp-1Ch]
  float v13; // [esp+60h] [ebp-18h]
  float v14; // [esp+64h] [ebp-14h]
  float v15; // [esp+68h] [ebp-10h]

  DoorSetSounds(a1);
  *(_DWORD *)(a1 + 528) = Blocked_Door;
  if ( *(float *)(a1 + 488) == 0.0 )
    *(_DWORD *)(a1 + 488) = 1137180672;
  if ( *(float *)(a1 + 624) == 0.0 )
    *(_DWORD *)(a1 + 624) = 0x40000000;
  *(float *)(a1 + 624) = *(float *)(a1 + 624) * 1000.0;
  if ( G_SpawnInt("key", (int)&unk_7B200, (int)&v7) )
    *(_DWORD *)(a1 + 688) = 1;
  else
    *(_DWORD *)(a1 + 688) = 0;
  G_SpawnFloat("lip", (int)"8", (int)&v8);
  G_SpawnInt("dmg", (int)"2", a1 + 576);
  *(_DWORD *)(a1 + 428) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 432) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 436) = *(_DWORD *)(a1 + 320);
  trap_SetBrushModel(a1);
  G_SetMovedir(a1 + 324, a1 + 496);
  v13 = fabs(*(float *)(a1 + 496));
  v14 = fabs(*(float *)(a1 + 500));
  v15 = fabs(*(float *)(a1 + 504));
  v9 = *(float *)(a1 + 272) - *(float *)(a1 + 260);
  v10 = *(float *)(a1 + 276) - *(float *)(a1 + 264);
  v11 = *(float *)(a1 + 280) - *(float *)(a1 + 268);
  v12 = v13 * v9 + v14 * v10 + v15 * v11 - *(float *)&v8;
  *(float *)(a1 + 440) = *(float *)(a1 + 496) * v12 + *(float *)(a1 + 428);
  *(float *)(a1 + 444) = *(float *)(a1 + 500) * v12 + *(float *)(a1 + 432);
  *(float *)(a1 + 448) = *(float *)(a1 + 504) * v12 + *(float *)(a1 + 436);
  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
  {
    v4 = *(_DWORD *)(a1 + 440);
    v5 = *(_DWORD *)(a1 + 444);
    v6 = *(_DWORD *)(a1 + 448);
    *(_DWORD *)(a1 + 440) = *(_DWORD *)(a1 + 312);
    *(_DWORD *)(a1 + 444) = *(_DWORD *)(a1 + 316);
    *(_DWORD *)(a1 + 448) = *(_DWORD *)(a1 + 320);
    *(_DWORD *)(a1 + 428) = v4;
    *(_DWORD *)(a1 + 432) = v5;
    *(_DWORD *)(a1 + 436) = v6;
    if ( *(float *)(a1 + 492) != 0.0 )
    {
      v3 = *(_DWORD *)(a1 + 488);
      *(_DWORD *)(a1 + 488) = *(_DWORD *)(a1 + 492);
      *(_DWORD *)(a1 + 492) = v3;
    }
    Door_reverse_sounds(a1);
  }
  if ( (*(_DWORD *)(a1 + 384) & 2) != 0 )
    *(_DWORD *)(a1 + 388) |= 0x80u;
  InitMover(a1);
  if ( (*(_DWORD *)(a1 + 388) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v2);
    if ( v2 )
      *(_BYTE *)(a1 + 373) = 1;
  }
  *(_DWORD *)(a1 + 516) = level[122] + 100;
  result = finishSpawningKeyedMover;
  *(_DWORD *)(a1 + 520) = finishSpawningKeyedMover;
  return result;
}
// 140D0: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 14F10: using guessed type _DWORD __cdecl DoorSetSounds(_DWORD);
// 15000: using guessed type _DWORD __cdecl G_SetMovedir(_DWORD, _DWORD);
// 15460: using guessed type _DWORD __cdecl Door_reverse_sounds(_DWORD);

//----- (000597A3) --------------------------------------------------------
int __cdecl Use_Static(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 240) )
    result = trap_UnlinkEntity(a1);
  else
    result = trap_LinkEntity(a1);
  return result;
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);

//----- (000597DF) --------------------------------------------------------
void __cdecl Static_Pain(int a1)
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+4h] [ebp-24h]
  float v3; // [esp+8h] [ebp-20h]
  float v4; // [esp+Ch] [ebp-1Ch]
  int v5; // [esp+10h] [ebp-18h]
  int v6; // [esp+14h] [ebp-14h]
  int v7; // [esp+18h] [ebp-10h]

  if ( (*(_DWORD *)(a1 + 384) & 4) != 0 )
  {
    v4 = (float)(int)level[122];
    v3 = *(float *)(a1 + 624) + *(float *)(a1 + 636);
    if ( v4 > (long double)(rand() % 1000) + v3 + 500.0 )
    {
      *(float *)(a1 + 624) = (float)(int)level[122];
      v5 = *(_DWORD *)(a1 + 312);
      v6 = *(_DWORD *)(a1 + 316);
      v7 = *(_DWORD *)(a1 + 320);
      *(_DWORD *)(a1 + 312) = *(_DWORD *)(a1 + 452);
      *(_DWORD *)(a1 + 316) = *(_DWORD *)(a1 + 456);
      *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 460);
      *(_DWORD *)(a1 + 312) = v5;
      *(_DWORD *)(a1 + 316) = v6;
      *(_DWORD *)(a1 + 320) = v7;
    }
  }
  else
  {
    v2 = (float)(int)level[122];
    v1 = *(float *)(a1 + 624) + *(float *)(a1 + 636);
    if ( v2 > (long double)(rand() % 1000) + v1 + 500.0 )
      *(float *)(a1 + 624) = (float)(int)level[122];
  }
}

//----- (0005998A) --------------------------------------------------------
int __cdecl SP_func_leaky(_DWORD *a1)
{
  int result; // eax

  trap_SetBrushModel(a1);
  trap_LinkEntity(a1);
  a1[3] = 0;
  a1[6] = a1[78];
  a1[7] = a1[79];
  result = a1[80];
  a1[8] = result;
  return result;
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (000599EF) --------------------------------------------------------
int __cdecl SP_func_static(int a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h] BYREF

  trap_SetBrushModel(a1);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 536) = Use_Static;
  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
    trap_UnlinkEntity(a1);
  if ( (*(_DWORD *)(a1 + 388) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v2);
    if ( v2 )
      *(_BYTE *)(a1 + 373) = 1;
  }
  if ( (*(_DWORD *)(a1 + 384) & 2) != 0 || (result = *(_DWORD *)(a1 + 384) & 4) != 0 )
  {
    *(_DWORD *)(a1 + 540) = Static_Pain;
    if ( *(float *)(a1 + 636) == 0.0 )
      *(_DWORD *)(a1 + 636) = 1148846080;
    else
      *(float *)(a1 + 636) = *(float *)(a1 + 636) * 1000.0;
    *(_BYTE *)(a1 + 373) = 1;
    *(_DWORD *)(a1 + 568) = 9999;
    result = a1;
    if ( !*(_DWORD *)(a1 + 600) )
    {
      result = a1;
      *(_DWORD *)(a1 + 600) = 4;
    }
  }
  return result;
}
// 140D0: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (00059B5C) --------------------------------------------------------
int __cdecl Use_Func_Rotate(_DWORD *a1)
{
  if ( (a1[96] & 4) != 0 )
  {
    a1[20] = a1[122];
  }
  else if ( (a1[96] & 8) != 0 )
  {
    a1[18] = a1[122];
  }
  else
  {
    a1[19] = a1[122];
  }
  if ( (a1[96] & 2) != 0 )
    a1[97] &= 0xFFFFFFFB;
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00059BF5) --------------------------------------------------------
int __cdecl SP_func_rotating(float *a1)
{
  if ( a1[122] == 0.0 )
    a1[122] = 100.0;
  *((_DWORD *)a1 + 12) = 2;
  if ( ((_DWORD)a1[96] & 1) != 0 )
  {
    if ( ((_DWORD)a1[96] & 4) != 0 )
    {
      a1[20] = a1[122];
    }
    else if ( ((_DWORD)a1[96] & 8) != 0 )
    {
      a1[18] = a1[122];
    }
    else
    {
      a1[19] = a1[122];
    }
  }
  if ( !*((_DWORD *)a1 + 144) )
    *((_DWORD *)a1 + 144) = 2;
  trap_SetBrushModel(a1);
  InitMover(a1);
  a1[6] = a1[78];
  a1[7] = a1[79];
  a1[8] = a1[80];
  if ( ((_DWORD)a1[96] & 2) == 0 )
    return trap_LinkEntity(a1);
  *((_DWORD *)a1 + 97) |= 4u;
  return trap_UnlinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 140D0: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (00059D3A) --------------------------------------------------------
int __cdecl SP_func_bobbing(int a1)
{
  int result; // eax
  int v2; // [esp+1Ch] [ebp-Ch] BYREF
  int v3; // [esp+20h] [ebp-8h] BYREF

  G_SpawnFloat("speed", (int)&unk_7B438, a1 + 488);
  G_SpawnFloat("height", (int)"32", (int)&v3);
  G_SpawnInt("dmg", (int)"2", a1 + 576);
  G_SpawnFloat("phase", (int)"0", (int)&v2);
  trap_SetBrushModel(a1);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 20) = (int)(*(float *)(a1 + 488) * 1000.0);
  *(_DWORD *)(a1 + 16) = (int)((long double)*(int *)(a1 + 20) * *(float *)&v2);
  *(_DWORD *)(a1 + 12) = 4;
  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
  {
    result = v3;
    *(_DWORD *)(a1 + 36) = v3;
  }
  else
  {
    result = v3;
    if ( (*(_DWORD *)(a1 + 384) & 2) != 0 )
      *(_DWORD *)(a1 + 40) = v3;
    else
      *(_DWORD *)(a1 + 44) = v3;
  }
  return result;
}
// 140D0: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (00059EA5) --------------------------------------------------------
int __cdecl SP_func_pendulum(int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+18h] [ebp-10h] BYREF
  float v5; // [esp+1Ch] [ebp-Ch]
  float v6; // [esp+20h] [ebp-8h]

  G_SpawnFloat("speed", (int)&unk_7B454, (int)&v3);
  G_SpawnInt("dmg", (int)"2", a1 + 576);
  G_SpawnFloat("phase", (int)"0", (int)&v4);
  trap_SetBrushModel(a1);
  v5 = fabs(*(float *)(a1 + 268));
  if ( v5 < 8.0 )
    v5 = 8.0;
  v2 = sqrt(g_gravity[2] / (v5 * 3.0));
  v6 = v2 * 0.1591549430918953;
  *(_DWORD *)(a1 + 20) = (int)(1000.0 / v6);
  InitMover(a1);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a1 + 328);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a1 + 332);
  *(_DWORD *)(a1 + 56) = (int)(1000.0 / v6);
  *(_DWORD *)(a1 + 52) = (int)((long double)*(int *)(a1 + 56) * *(float *)&v4);
  *(_DWORD *)(a1 + 48) = 4;
  result = v3;
  *(_DWORD *)(a1 + 80) = v3;
  return result;
}
// 140D0: using guessed type _DWORD __cdecl InitMover(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (0005A055) --------------------------------------------------------
int (__cdecl *__cdecl SP_func_door_rotating(int a1))(int, void *s)
{
  int (__cdecl *result)(int, void *); // eax
  char v2; // [esp+4h] [ebp-24h]
  int v3; // [esp+14h] [ebp-14h] BYREF
  float v4; // [esp+18h] [ebp-10h]
  int v5[3]; // [esp+1Ch] [ebp-Ch] BYREF

  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
    *(_DWORD *)(a1 + 384) |= 2u;
  *(_DWORD *)(a1 + 384) &= 0xFFFFFFBF;
  DoorSetSounds(a1);
  if ( *(float *)(a1 + 488) == 0.0 )
    *(_DWORD *)(a1 + 488) = 1148846080;
  if ( *(float *)(a1 + 472) == 0.0 )
    *(_DWORD *)(a1 + 472) = 1119092736;
  if ( (*(_DWORD *)(a1 + 384) & 0x10) != 0 )
    *(float *)(a1 + 472) = *(float *)(a1 + 472) * -1.0;
  if ( (*(_DWORD *)(a1 + 384) & 2) != 0 )
    *(_DWORD *)(a1 + 388) |= 0x80u;
  if ( G_SpawnInt("key", (int)&unk_7B200, (int)v5) )
    *(_DWORD *)(a1 + 688) = 1;
  else
    *(_DWORD *)(a1 + 688) = 0;
  *(_DWORD *)(a1 + 656) = 0;
  *(_DWORD *)(a1 + 652) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  if ( (*(_DWORD *)(a1 + 384) & 0xC) == 12 )
  {
    *(_DWORD *)(a1 + 652) = 1065353216;
  }
  else if ( (*(_DWORD *)(a1 + 384) & 4) != 0 )
  {
    *(_DWORD *)(a1 + 656) = 1065353216;
  }
  else if ( (*(_DWORD *)(a1 + 384) & 8) != 0 )
  {
    *(_DWORD *)(a1 + 648) = 1065353216;
  }
  else
  {
    *(_DWORD *)(a1 + 652) = 1065353216;
  }
  v4 = sqrt(
         *(float *)(a1 + 648) * *(float *)(a1 + 648)
       + *(float *)(a1 + 652) * *(float *)(a1 + 652)
       + *(float *)(a1 + 656) * *(float *)(a1 + 656));
  if ( v4 > 1.0 )
  {
    G_Error(
      "Too many axis marked in func_door_rotating entity.  Only choose one axis of rotation. (defaulting to standard door rotation)",
      v2);
    *(_DWORD *)(a1 + 656) = 0;
    *(_DWORD *)(a1 + 652) = 0;
    *(_DWORD *)(a1 + 648) = 0;
    *(_DWORD *)(a1 + 652) = 1065353216;
  }
  if ( *(float *)(a1 + 624) == 0.0 )
    *(_DWORD *)(a1 + 624) = 0x40000000;
  *(float *)(a1 + 624) = *(float *)(a1 + 624) * 1000.0;
  trap_SetBrushModel(a1);
  InitMoverRotate(a1);
  if ( (*(_DWORD *)(a1 + 388) & 4) == 0 )
  {
    G_SpawnInt("health", (int)"0", (int)&v3);
    if ( v3 )
      *(_BYTE *)(a1 + 373) = 1;
  }
  *(_DWORD *)(a1 + 516) = level[122] + 100;
  *(_DWORD *)(a1 + 520) = finishSpawningKeyedMover;
  result = Blocked_DoorRotate;
  *(_DWORD *)(a1 + 528) = Blocked_DoorRotate;
  return result;
}
// 5A286: variable 'v2' is possibly undefined
// 13470: using guessed type _DWORD __cdecl InitMoverRotate(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 14F10: using guessed type _DWORD __cdecl DoorSetSounds(_DWORD);

//----- (0005A38E) --------------------------------------------------------
void __cdecl use_trigger_use(int a1, int a2)
{
  unsigned int v2; // edx

  if ( (long double)(int)level[122] > *(float *)(a1 + 624) )
  {
    *(float *)(a1 + 624) = (long double)(int)level[122] + *(float *)(a1 + 636);
    if ( !*(_DWORD *)(a2 + 348) )
    {
      if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
        v2 = *(_DWORD *)(a1 + 384) & 0xFFFFFFFE;
      else
        v2 = *(_DWORD *)(a1 + 384) | 1;
      *(_DWORD *)(a1 + 384) = v2;
    }
  }
}

//----- (0005A432) --------------------------------------------------------
int __cdecl trigger_use(int a1)
{
  int result; // eax
  char s2[1032]; // [esp+10h] [ebp-418h] BYREF
  char *s1; // [esp+418h] [ebp-10h] BYREF
  unsigned int i; // [esp+41Ch] [ebp-Ch] BYREF

  trap_SetBrushModel(a1);
  trap_LinkEntity(a1);
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 284) = &unk_200000;
  *(_DWORD *)(a1 + 244) = 1;
  *(float *)(a1 + 636) = *(float *)(a1 + 636) * 1000.0;
  *(_DWORD *)(a1 + 536) = use_trigger_use;
  *(_DWORD *)(a1 + 220) = 2;
  if ( G_SpawnString("cursorhint", (int)&unk_7B200, (int)&s1) )
  {
    if ( Q_strcasecmp(s1, "HINT_INHERIT") )
    {
      for ( i = 1; i <= 0xA; ++i )
      {
        if ( !Q_strcasecmp(s1, *(&hintStrings + i)) )
        {
          *(_DWORD *)(a1 + 220) = i;
          break;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 220) = -1;
    }
  }
  *(_DWORD *)(a1 + 216) = 255;
  result = G_SpawnString("hintstring", (int)&unk_7B200, (int)&s1);
  if ( result )
  {
    for ( i = 0; (int)i <= 31; ++i )
    {
      trap_GetConfigstring(i + 1212, s2, 1024);
      if ( !s2[0] )
      {
        trap_SetConfigstring(i + 1212, s1);
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      if ( !strcmp(s1, s2) )
      {
        result = (unsigned __int8)i;
        *(_DWORD *)(a1 + 216) = (unsigned __int8)i;
        break;
      }
      result = (int)&i;
    }
    if ( i == 32 )
      result = Com_Error(1, byte_7B540, 32);
  }
  return result;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 154C0: using guessed type _DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD);
// 83C00: using guessed type void *hintStrings;

//----- (0005A668) --------------------------------------------------------
int __cdecl G_Activate(int a1, int a2)
{
  int result; // eax

  result = a1;
  if ( !*(_DWORD *)(a1 + 48) )
  {
    result = a1;
    if ( !*(_DWORD *)(a1 + 12) )
    {
      result = a1;
      if ( !*(_BYTE *)(a1 + 374) )
      {
        result = a1;
        if ( !*(_DWORD *)(a1 + 688) )
        {
          if ( *(_DWORD *)(a1 + 620) && *(_WORD *)(a1 + 480) && a1 != *(_DWORD *)(a1 + 620) )
          {
            *(_BYTE *)(*(_DWORD *)(a1 + 620) + 374) = 1;
            result = Use_BinaryMover(*(_DWORD *)(a1 + 620), a2, a2);
          }
          else
          {
            *(_BYTE *)(a1 + 374) = 1;
            result = Use_BinaryMover(a1, a2, a2);
          }
        }
      }
    }
  }
  return result;
}
// 13C70: using guessed type _DWORD __cdecl Use_BinaryMover(_DWORD, _DWORD, _DWORD);

//----- (0005A75B) --------------------------------------------------------
void sub_5A75B()
{
  ;
}

//----- (0005A760) --------------------------------------------------------
int __cdecl GScr_AllocString(int a1)
{
  return (unsigned __int16)Scr_AllocString(a1, 1);
}
// 155B0: using guessed type _DWORD __cdecl Scr_AllocString(_DWORD, _DWORD);

//----- (0005A78E) --------------------------------------------------------
int GScr_LoadConsts()
{
  int result; // eax

  scr_const[0] = GScr_AllocString("active");
  scr_const[1] = GScr_AllocString("air strike");
  scr_const[2] = GScr_AllocString("allies");
  scr_const[3] = GScr_AllocString("animdone");
  scr_const[4] = GScr_AllocString("axis");
  scr_const[5] = GScr_AllocString("bodyque");
  scr_const[6] = GScr_AllocString("combat");
  scr_const[7] = GScr_AllocString("connected");
  scr_const[8] = GScr_AllocString("connecting");
  scr_const[9] = GScr_AllocString("count");
  scr_const[11] = GScr_AllocString("crouch");
  scr_const[12] = GScr_AllocString("crowbar");
  scr_const[10] = GScr_AllocString("current");
  scr_const[13] = GScr_AllocString("damage");
  scr_const[14] = GScr_AllocString("death");
  scr_const[15] = GScr_AllocString("disconnected");
  scr_const[16] = GScr_AllocString("dlight");
  scr_const[17] = GScr_AllocString("done");
  scr_const[18] = GScr_AllocString("empty");
  scr_const[19] = GScr_AllocString("enemy");
  scr_const[20] = GScr_AllocString("enemyhidden");
  scr_const[21] = GScr_AllocString("enemyvisible");
  scr_const[22] = GScr_AllocString("entity");
  scr_const[23] = GScr_AllocString("failed");
  scr_const[24] = GScr_AllocString("flamebarrel");
  scr_const[25] = GScr_AllocString("fraction");
  scr_const[26] = GScr_AllocString("func_door");
  scr_const[27] = GScr_AllocString("func_door_rotating");
  scr_const[28] = GScr_AllocString("func_rotating");
  scr_const[29] = GScr_AllocString("func_tramcar");
  scr_const[30] = GScr_AllocString("goal");
  scr_const[31] = GScr_AllocString("grenade");
  scr_const[32] = GScr_AllocString("info_notnull");
  scr_const[33] = GScr_AllocString("invisible");
  scr_const[34] = GScr_AllocString("key1");
  scr_const[35] = GScr_AllocString("key2");
  scr_const[36] = GScr_AllocString("killanimscript");
  scr_const[37] = GScr_AllocString("left");
  scr_const[38] = GScr_AllocString("misc_flak");
  scr_const[39] = GScr_AllocString("misc_mg42");
  scr_const[40] = GScr_AllocString("misc_tagemitter");
  scr_const[41] = GScr_AllocString("mortar");
  scr_const[42] = GScr_AllocString("movedone");
  scr_const[43] = GScr_AllocString("noclass");
  scr_const[44] = GScr_AllocString("noenemy");
  scr_const[45] = GScr_AllocString("noncombat");
  scr_const[46] = GScr_AllocString("normal");
  scr_const[47] = GScr_AllocString("pistol");
  scr_const[48] = GScr_AllocString("plane_waypoint");
  scr_const[49] = GScr_AllocString("player");
  scr_const[50] = GScr_AllocString("position");
  scr_const[51] = GScr_AllocString("primary");
  scr_const[52] = GScr_AllocString("primaryb");
  scr_const[53] = GScr_AllocString("prone");
  scr_const[54] = GScr_AllocString("right");
  scr_const[55] = GScr_AllocString("rocket");
  scr_const[56] = GScr_AllocString("rotatedone");
  scr_const[57] = GScr_AllocString("script_brushmodel");
  scr_const[58] = GScr_AllocString("script_model");
  scr_const[59] = GScr_AllocString("script_origin");
  scr_const[60] = GScr_AllocString("scriptcamera");
  scr_const[61] = GScr_AllocString("spawned");
  scr_const[62] = GScr_AllocString("spectator");
  scr_const[63] = GScr_AllocString("stand");
  scr_const[64] = GScr_AllocString("surfacetype");
  scr_const[65] = GScr_AllocString("tag_engine1");
  scr_const[66] = GScr_AllocString("tag_engine2");
  scr_const[67] = GScr_AllocString("target_location");
  scr_const[68] = GScr_AllocString("target_script_trigger");
  scr_const[69] = GScr_AllocString("tempEntity");
  scr_const[70] = GScr_AllocString("muzzleEntity");
  scr_const[71] = GScr_AllocString("smokegrenade");
  scr_const[72] = GScr_AllocString("touch");
  scr_const[73] = GScr_AllocString("trigger");
  scr_const[74] = GScr_AllocString("trigger_use");
  scr_const[75] = GScr_AllocString("trigger_damage");
  scr_const[76] = GScr_AllocString("trigger_lookat");
  scr_const[77] = GScr_AllocString("truck_cam");
  scr_const[79] = GScr_AllocString("xmodel/airborne");
  scr_const[80] = GScr_AllocString("xmodel/wehrmacht");
  scr_const[78] = GScr_AllocString("worldspawn");
  scr_const[81] = GScr_AllocString("begin");
  scr_const[82] = GScr_AllocString("dynamite");
  scr_const[83] = GScr_AllocString("explosive_indicator");
  scr_const[84] = GScr_AllocString("flamechunk");
  scr_const[85] = GScr_AllocString("follow");
  scr_const[86] = GScr_AllocString("free");
  scr_const[87] = GScr_AllocString("freed");
  scr_const[88] = GScr_AllocString("func_leaky");
  scr_const[89] = GScr_AllocString("info_player_checkpoint");
  scr_const[90] = GScr_AllocString("initialize");
  scr_const[91] = GScr_AllocString("intermission");
  scr_const[92] = GScr_AllocString("item_stamina_brandy");
  scr_const[93] = GScr_AllocString("menuresponse");
  scr_const[94] = GScr_AllocString("misc_gunner_gun");
  scr_const[95] = GScr_AllocString("misc_gunner_ring");
  scr_const[96] = GScr_AllocString("mp_info_player_deathmatch");
  scr_const[97] = GScr_AllocString("mp_info_player_intermission");
  scr_const[98] = GScr_AllocString("mp_team_alliedplayer_respawn");
  scr_const[99] = GScr_AllocString("mp_team_alliedplayer_start");
  scr_const[100] = GScr_AllocString("mp_team_axisplayer_respawn");
  scr_const[101] = GScr_AllocString("mp_team_axisplayer_start");
  scr_const[102] = GScr_AllocString("nail");
  scr_const[103] = GScr_AllocString("not");
  scr_const[104] = GScr_AllocString("playing");
  scr_const[105] = GScr_AllocString("prox_mine");
  scr_const[106] = GScr_AllocString("reset");
  scr_const[107] = GScr_AllocString("script_mover");
  scr_const[108] = GScr_AllocString("script_multiplayer");
  scr_const[109] = GScr_AllocString("spear");
  scr_const[110] = GScr_AllocString("tag_hand");
  scr_const[111] = GScr_AllocString("tag_rider");
  scr_const[112] = GScr_AllocString("tag_ring");
  scr_const[113] = GScr_AllocString("team_CTF_blueflag");
  scr_const[114] = GScr_AllocString("team_CTF_redflag");
  scr_const[115] = GScr_AllocString("team_WOLF_checkpoint");
  scr_const[116] = GScr_AllocString("team_WOLF_objective");
  scr_const[117] = GScr_AllocString("trigger_aidoor");
  scr_const[118] = GScr_AllocString("trigger_flagonly");
  scr_const[119] = GScr_AllocString("trigger_multiple");
  scr_const[120] = GScr_AllocString("trigger_objective_info");
  scr_const[121] = GScr_AllocString("waiting_for_players");
  scr_const[122] = GScr_AllocString("WP");
  scr_const[123] = GScr_AllocString("zombiespit");
  scr_const[124] = GScr_AllocString("none");
  scr_const[125] = GScr_AllocString("dead");
  scr_const[126] = GScr_AllocString("auto_change");
  scr_const[127] = GScr_AllocString("manual_change");
  scr_const[128] = GScr_AllocString("freelook");
  scr_const[129] = GScr_AllocString("squad_alpha");
  result = GScr_AllocString("squad_bravo");
  scr_const[130] = result;
  return result;
}
// 15610: using guessed type _DWORD __cdecl GScr_AllocString(_DWORD);

//----- (0005B4B8) --------------------------------------------------------
_WORD *Scr_LoadLevel()
{
  _WORD *result; // eax
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  result = g_scr_data;
  if ( *(_DWORD *)g_scr_data )
  {
    v1 = Scr_ExecThread(*(_DWORD *)g_scr_data, 0);
    result = (_WORD *)Scr_FreeThread(v1);
  }
  return result;
}
// 155D0: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (0005B505) --------------------------------------------------------
int __cdecl sub_5B505(int a1, int a2, int a3)
{
  int v4; // [esp+10h] [ebp-8h]

  if ( !Scr_LoadScript(a1) && a3 )
    G_Error("Could not find script '%s'", a1);
  v4 = Scr_GetFunctionHandle(a1, a2);
  if ( !v4 && a3 )
    G_Error("Could not find label '%s' in script '%s'", a2);
  return v4;
}
// 13BF0: using guessed type _DWORD __cdecl Scr_LoadScript(_DWORD);
// 14EE0: using guessed type _DWORD __cdecl Scr_GetFunctionHandle(_DWORD, _DWORD);

//----- (0005B587) --------------------------------------------------------
int GScr_LoadGameTypeScript()
{
  int result; // eax
  char s[72]; // [esp+10h] [ebp-48h] BYREF

  Com_sprintf(s, 0x40u, "maps/mp/gametypes/%s", (char)&g_gametype + 16);
  *(_DWORD *)&g_scr_data[4] = sub_5B505((int)s, (int)"main", 1);
  *(_DWORD *)&g_scr_data[6] = sub_5B505((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_StartGameType", 1);
  *(_DWORD *)&g_scr_data[8] = sub_5B505((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerConnect", 1);
  *(_DWORD *)&g_scr_data[10] = sub_5B505(
                                 (int)"maps/mp/gametypes/_callbacksetup",
                                 (int)"CodeCallback_PlayerDisconnect",
                                 1);
  *(_DWORD *)&g_scr_data[12] = sub_5B505((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerDamage", 1);
  result = sub_5B505((int)"maps/mp/gametypes/_callbacksetup", (int)"CodeCallback_PlayerKilled", 1);
  *(_DWORD *)&g_scr_data[14] = result;
  return result;
}

//----- (0005B6BE) --------------------------------------------------------
int sub_5B6BE()
{
  int result; // eax
  char v1[16]; // [esp+10h] [ebp-158h] BYREF
  int v2; // [esp+20h] [ebp-148h] BYREF
  char s[72]; // [esp+120h] [ebp-48h] BYREF

  trap_Cvar_Register(v1, "mapname", &unk_7BCAE, 68);
  Com_sprintf(s, 0x40u, "maps/mp/%s", (char)&v2);
  result = sub_5B505((int)s, (int)"main", 0);
  *(_DWORD *)g_scr_data = result;
  return result;
}
// 14D90: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0005B757) --------------------------------------------------------
int sub_5B757()
{
  unsigned int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 1; ++i )
    *(_DWORD *)&g_scr_data[4 * i + 212] = *(char **)((char *)off_83C2C + (_DWORD)&dword_0[i]);
  Scr_SetClassMap(&g_scr_data[210], 2);
  GScr_AddFieldsForEntity();
  GScr_AddFieldsForHudElems();
  return GScr_AddFieldsForRadiant();
}
// 0: using guessed type int dword_0[];
// 12E40: using guessed type int GScr_AddFieldsForHudElems(void);
// 13660: using guessed type int GScr_AddFieldsForEntity(void);
// 14260: using guessed type int GScr_AddFieldsForRadiant(void);
// 14460: using guessed type _DWORD __cdecl Scr_SetClassMap(_DWORD, _DWORD);
// 83C2C: using guessed type char *off_83C2C[2];

//----- (0005B7CA) --------------------------------------------------------
int __cdecl sub_5B7CA(int a1)
{
  return trap_Hunk_AllocLowInternal(a1);
}
// 13990: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);

//----- (0005B7ED) --------------------------------------------------------
int GScr_LoadScripts()
{
  int v1; // [esp+1Ch] [ebp-900Ch] BYREF
  char v2[36872]; // [esp+20h] [ebp-9008h] BYREF

  v1 = 0;
  Scr_BeginLoadScripts();
  GScr_LoadGameTypeScript();
  sub_5B6BE();
  sub_5B757();
  Scr_EndLoadScripts();
  BG_FindAnims();
  BG_AnimParseAnimScript(bgs, v2, &v1);
  Scr_PrecacheAnimTrees(sub_5B7CA);
  BG_FindAnimTrees();
  Scr_EndLoadAnimTrees();
  BG_FinalizePlayerAnims();
  return BG_LoadAnimTreeInstances();
}
// 133A0: using guessed type int Scr_BeginLoadScripts(void);
// 13560: using guessed type int BG_LoadAnimTreeInstances(void);
// 13650: using guessed type int Scr_EndLoadAnimTrees(void);
// 137A0: using guessed type _DWORD __cdecl BG_AnimParseAnimScript(_DWORD, _DWORD, _DWORD);
// 13860: using guessed type int GScr_LoadGameTypeScript(void);
// 138C0: using guessed type int BG_FinalizePlayerAnims(void);
// 14750: using guessed type int BG_FindAnimTrees(void);
// 14C00: using guessed type int BG_FindAnims(void);
// 14D70: using guessed type _DWORD __cdecl Scr_PrecacheAnimTrees(_DWORD);
// 15980: using guessed type int Scr_EndLoadScripts(void);

//----- (0005B877) --------------------------------------------------------
int GScr_FreeScripts()
{
  return Scr_RemoveClassMap();
}
// 133D0: using guessed type int Scr_RemoveClassMap(void);

//----- (0005B894) --------------------------------------------------------
_DWORD *__cdecl sub_5B894(unsigned int a1)
{
  if ( a1 <= 0x3FF )
    return &g_entities[199 * a1];
  Scr_ObjectError("not an entity");
  return 0;
}
// 145A0: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);

//----- (0005B8E6) --------------------------------------------------------
_DWORD *__cdecl sub_5B8E6(unsigned int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+30h] [ebp-8h]

  v3 = sub_5B894(a1);
  if ( !v3[87] )
  {
    if ( *((_WORD *)v3 + 239) )
      SL_ConvertToString(*((unsigned __int16 *)v3 + 239));
    SL_ConvertToString(*((unsigned __int16 *)v3 + 190));
    v1 = va("only valid on players; called on entity %i at %.0f %.0f %.0f classname %s targetname %s\n", a1);
    Scr_Error(v1);
  }
  return v3;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0005B9AD) --------------------------------------------------------
_DWORD *sub_5B9AD()
{
  _DWORD *result; // eax
  char v1; // al
  char *i; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  result = g_NoScriptSpam;
  if ( !g_NoScriptSpam[3] )
  {
    v3 = Scr_GetNumParam();
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( (int)i >= v3 )
        break;
      v1 = Scr_GetDebugString(i);
      Com_Printf("%s", v1);
    }
  }
  return result;
}
// 13CA0: using guessed type _DWORD __cdecl Scr_GetDebugString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005BA10) --------------------------------------------------------
_DWORD *sub_5BA10()
{
  _DWORD *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  result = g_NoScriptSpam;
  if ( !g_NoScriptSpam[3] )
  {
    sub_5B9AD();
    result = (_DWORD *)Com_Printf("\n", v1);
  }
  return result;
}
// 5BA3E: variable 'v1' is possibly undefined

//----- (0005BA49) --------------------------------------------------------
int __cdecl Scr_LocalizationError(int a1, char *format)
{
  char v3; // [esp+8h] [ebp-10h]

  return Com_Error(7, format, v3);
}
// 5BA69: variable 'v3' is possibly undefined

//----- (0005BA74) --------------------------------------------------------
int *__cdecl Scr_ConstructMessageString(int a1, _BYTE *a2, int a3, int a4)
{
  int *result; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  char *v9; // eax
  int v10; // eax
  int v11; // [esp+14h] [ebp-34h]
  int v12; // [esp+14h] [ebp-34h]
  _BYTE *v13; // [esp+18h] [ebp-30h]
  const char *v14; // [esp+1Ch] [ebp-2Ch]
  int v15; // [esp+20h] [ebp-28h]
  char *s; // [esp+24h] [ebp-24h]
  int v17; // [esp+28h] [ebp-20h]
  int v18; // [esp+2Ch] [ebp-1Ch]
  signed int v19; // [esp+30h] [ebp-18h]
  int v20; // [esp+34h] [ebp-14h] BYREF
  int v21; // [esp+38h] [ebp-10h]
  int i; // [esp+3Ch] [ebp-Ch]
  int j; // [esp+40h] [ebp-8h]

  v15 = 1;
  switch ( a4 )
  {
    case 0:
      v14 = "Game Message";
      break;
    case 1:
      v14 = "Cvar Value";
      break;
    case 2:
      v14 = "Hint String";
      break;
    case 3:
      v14 = "Announcement String";
      break;
    case 4:
      v14 = "Client Cvar Value";
      break;
    case 5:
      v14 = "Client Chat Message";
      break;
    default:
      v14 = "BAD";
      break;
  }
  v20 = 0;
  *a2 = 0;
  v21 = Scr_GetNumParam();
  for ( i = a1; ; ++i )
  {
    result = (int *)i;
    if ( i >= v21 )
      break;
    v18 = Scr_GetType(i);
    v17 = 0;
    if ( v18 == 2 )
    {
      s = (char *)Scr_GetIString(i);
      v19 = strlen(s);
      for ( j = 0; j < v19; ++j )
      {
        if ( (*(_WORD *)(_ctype_b + 2 * s[j]) & 8) == 0 && s[j] != 95 )
        {
          v5 = va(
                 "Illegal localized string reference: %s (must contain only alpha-numeric characters and underscores",
                 (char)s);
          Scr_ParamError(i, v5);
        }
      }
      if ( v20 )
        v17 = 1;
      if ( v17 + v20 + v19 >= a3 )
      {
        v6 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v6);
      }
      if ( v17 )
      {
        a2[v20] = 20;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 1;
    }
    else if ( v18 == 7 && Scr_GetPointerType(i) == 13 )
    {
      v11 = Scr_GetEntity(i);
      if ( !*(_DWORD *)(v11 + 348) )
        Scr_ParamError(i, "Entity is not a player");
      s = (char *)va("%s^7", *(_DWORD *)(v11 + 348) - 68);
      v19 = strlen(s);
      if ( v15 )
        v17 = 1;
      if ( v17 + v20 + v19 >= a3 )
      {
        v7 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v7);
      }
      if ( v17 )
      {
        a2[v20] = 21;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 0;
    }
    else
    {
      v12 = 0;
      s = (char *)Scr_GetString(i);
      v19 = strlen(s);
      for ( j = 0; j < v19; ++j )
      {
        if ( s[j] == 20 || s[j] == 21 || s[j] == 22 )
        {
          v8 = va("bad escape character (%i) present in string", s[j]);
          Scr_ParamError(i, v8);
        }
        if ( (*(_WORD *)(_ctype_b + 2 * s[j]) & 0x400) != 0 )
        {
          if ( !v12 && g_languagewarnings[3] )
          {
            if ( g_languagewarningsaserrors[3] )
            {
              v9 = (char *)va("non-localized %s strings are not allowed to have letters in them: \"%s\"", (char)v14);
              Scr_LocalizationError(i, v9);
            }
            else
            {
              Com_Printf(
                "^3WARNING: Non-localized %s string is not allowed to have letters in it. Must be changed over to a local"
                "ized string: \"%s\"\n",
                (char)v14);
            }
          }
          v12 = 1;
        }
      }
      if ( v12 )
      {
        if ( v20 )
          v17 = 1;
      }
      else if ( v15 )
      {
        v17 = 1;
      }
      if ( v17 + v20 + v19 >= a3 )
      {
        v10 = va("%s is too long. Max length is %i\n", (char)v14);
        Scr_ParamError(i, v10);
      }
      if ( v12 )
      {
        if ( v17 )
        {
          a2[v20] = 20;
          a2[v20 + 1] = 0;
          v20 += v17;
        }
      }
      else if ( v17 )
      {
        a2[v20] = 21;
        a2[v20 + 1] = 0;
        v20 += v17;
      }
      v15 = 0;
    }
    v13 = &a2[v20];
    for ( j = 0; j < v19; ++j )
    {
      if ( s[j] && (unsigned __int8)s[j] <= 0x1Fu || (unsigned __int8)s[j] > 0x7Eu )
        v13[j] = 46;
      else
        v13[j] = s[j];
    }
    v13[j] = 0;
    v20 += v19;
  }
  if ( v15 )
  {
    a2[v20] = 21;
    a2[v20 + 1] = 0;
    result = &v20;
    ++v20;
  }
  return result;
}
// 5BF80: returning address of temporary local variable '%var_14'
// 13240: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 2EFB88: using guessed type int _ctype_b;

//----- (0005BF8B) --------------------------------------------------------
int __cdecl Scr_MakeGameMessage(int a1, char a2)
{
  int v2; // eax
  char v4[1032]; // [esp+10h] [ebp-408h] BYREF

  Scr_ConstructMessageString(0, v4, 1024, 0);
  v2 = va("%s \"%s\"", a2);
  return trap_SendServerCommand(a1, 0, v2);
}
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (0005C005) --------------------------------------------------------
int sub_5C005()
{
  return Scr_MakeGameMessage(-1, (char)"f");
}
// 159A0: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (0005C033) --------------------------------------------------------
int sub_5C033()
{
  return Scr_MakeGameMessage(-1, (char)"g");
}
// 159A0: using guessed type _DWORD __cdecl Scr_MakeGameMessage(_DWORD, char);

//----- (0005C061) --------------------------------------------------------
int sub_5C061()
{
  unsigned int v1; // [esp+18h] [ebp-50h]
  float v2; // [esp+1Ch] [ebp-4Ch]
  int v3[4]; // [esp+20h] [ebp-48h] BYREF
  int v4; // [esp+30h] [ebp-38h] BYREF
  int v5; // [esp+34h] [ebp-34h]
  int v6; // [esp+38h] [ebp-30h]
  float v7; // [esp+3Ch] [ebp-2Ch]
  int v8; // [esp+4Ch] [ebp-1Ch]
  char v9[24]; // [esp+50h] [ebp-18h] BYREF

  v2 = 1.0;
  v4 = 1065353216;
  v5 = 1065353216;
  v6 = 1065353216;
  v7 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 == 3 )
    goto LABEL_8;
  if ( v1 > 3 )
  {
    if ( v1 == 4 )
    {
LABEL_7:
      v7 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, v3);
      v4 = v3[0];
      v5 = v3[1];
      v6 = v3[2];
      goto LABEL_9;
    }
LABEL_6:
    v2 = Scr_GetFloat(4);
    goto LABEL_7;
  }
  if ( v1 != 2 )
    goto LABEL_6;
LABEL_9:
  v8 = Scr_GetString(1);
  Scr_GetVector(0, v9);
  return trap_AddDebugString(v9, &v4, LODWORD(v2), v8);
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14BD0: using guessed type _DWORD __cdecl trap_AddDebugString(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005C143) --------------------------------------------------------
int sub_5C143()
{
  unsigned int v1; // [esp+28h] [ebp-50h]
  int v2; // [esp+2Ch] [ebp-4Ch]
  int v3[4]; // [esp+30h] [ebp-48h] BYREF
  int v4; // [esp+40h] [ebp-38h] BYREF
  int v5; // [esp+44h] [ebp-34h]
  int v6; // [esp+48h] [ebp-30h]
  float v7; // [esp+4Ch] [ebp-2Ch]
  char v8[16]; // [esp+50h] [ebp-28h] BYREF
  char v9[24]; // [esp+60h] [ebp-18h] BYREF

  v2 = 0;
  v4 = 1065353216;
  v5 = 1065353216;
  v6 = 1065353216;
  v7 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 == 3 )
    goto LABEL_8;
  if ( v1 > 3 )
  {
    if ( v1 == 4 )
    {
LABEL_7:
      v7 = Scr_GetFloat(3);
LABEL_8:
      Scr_GetVector(2, v3);
      v4 = v3[0];
      v5 = v3[1];
      v6 = v3[2];
      goto LABEL_9;
    }
LABEL_6:
    v2 = Scr_GetInt(4);
    goto LABEL_7;
  }
  if ( v1 != 2 )
    goto LABEL_6;
LABEL_9:
  Scr_GetVector(1, v8);
  Scr_GetVector(0, v9);
  return trap_AddDebugLine(v9, v8, &v4, v2, 0);
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14E50: using guessed type _DWORD __cdecl trap_AddDebugLine(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005C231) --------------------------------------------------------
void sub_5C231()
{
  ;
}

//----- (0005C236) --------------------------------------------------------
int sub_5C236()
{
  int v1; // [esp+10h] [ebp-8h]
  int v2; // [esp+10h] [ebp-8h]

  v1 = Scr_GetType(0);
  if ( v1 != 7 )
    return Scr_AddInt(v1 != 0);
  v2 = Scr_GetPointerType(0);
  return Scr_AddInt(v2 <= 15);
}
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (0005C298) --------------------------------------------------------
int sub_5C298()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && *(int *)(Scr_GetEntity(0) + 568) > 0 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (0005C323) --------------------------------------------------------
int sub_5C323()
{
  char v1[1036]; // [esp+10h] [ebp-418h] BYREF
  int v2; // [esp+41Ch] [ebp-Ch]

  v2 = Scr_GetString(0);
  trap_Cvar_VariableStringBuffer(v2, v1, 1024);
  return Scr_AddString(v1);
}
// 133F0: using guessed type _DWORD __cdecl trap_Cvar_VariableStringBuffer(_DWORD, _DWORD, _DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005C37B) --------------------------------------------------------
int sub_5C37B()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetString(0);
  v0 = trap_Cvar_VariableIntegerValue(v2);
  return Scr_AddInt(v0);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15620: using guessed type _DWORD __cdecl trap_Cvar_VariableIntegerValue(_DWORD);

//----- (0005C3B5) --------------------------------------------------------
int sub_5C3B5()
{
  float v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetString(0);
  v1 = trap_Cvar_VariableValue(v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 153C0: using guessed type long double __cdecl trap_Cvar_VariableValue(_DWORD);

//----- (0005C3EF) --------------------------------------------------------
int sub_5C3EF()
{
  size_t v0; // eax
  int v2; // [esp+20h] [ebp-828h]
  char *s; // [esp+28h] [ebp-820h]
  int v4; // [esp+2Ch] [ebp-81Ch]
  char v5[1024]; // [esp+30h] [ebp-818h] BYREF
  char v6[1024]; // [esp+430h] [ebp-418h] BYREF
  char *v7; // [esp+830h] [ebp-18h]
  int v8; // [esp+834h] [ebp-14h]
  size_t v9; // [esp+838h] [ebp-10h]
  int v10; // [esp+83Ch] [ebp-Ch]

  v4 = Scr_GetString(0);
  v8 = Scr_GetType(1);
  if ( v8 == 2 )
  {
    Scr_ConstructMessageString(1, v6, 1024, 1);
    s = v6;
    v0 = strlen(v6);
  }
  else
  {
    s = (char *)Scr_GetString(1);
    v0 = strlen(s);
  }
  v9 = v0;
  v7 = v5;
  memset(v5, 0, sizeof(v5));
  v10 = 0;
  while ( v10 <= 0x1FFF && s[v10] )
  {
    *v7 = Q_CleanCharacter(s[v10]);
    if ( *v7 == 34 )
      *v7 = 39;
    ++v10;
    ++v7;
  }
  v2 = 0;
  if ( (unsigned int)Scr_GetNumParam() > 2 && Scr_GetBool(2) )
    v2 = 1;
  if ( v2 )
    trap_Cvar_Register(0, v4, s, 12288);
  else
    trap_Cvar_Register(0, v4, s, 4096);
  return trap_Cvar_Set(v4, s);
}
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13700: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 14D90: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005C5A2) --------------------------------------------------------
int sub_5C5A2()
{
  return Scr_AddInt(level[122]);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005C5CE) --------------------------------------------------------
_DWORD *sub_5C5CE()
{
  _DWORD *result; // eax

  result = (_DWORD *)Scr_GetInt(0);
  if ( (unsigned int)result <= 0x3FF )
  {
    result = sub_5B894((unsigned int)result);
    if ( *((_BYTE *)result + 356) )
      result = (_DWORD *)Scr_AddEntity(result);
  }
  return result;
}
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0005C627) --------------------------------------------------------
int sub_5C627()
{
  unsigned __int8 v0; // al
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char v4; // [esp+4h] [ebp-14h]
  _BYTE *v5; // [esp+10h] [ebp-8h]

  v5 = (_BYTE *)Scr_GetString(0);
  v0 = BG_GetWeaponIndexForName((char)v5);
  if ( v0 )
  {
    v3 = BG_GetInfoForWeapon(v0);
    result = Scr_AddString(*(_DWORD *)(v3 + 392));
  }
  else
  {
    if ( *v5 )
    {
      if ( Q_stricmp(v5, "none") )
      {
        v1 = (char *)va("unknown weapon '%s' in getWeaponModel\n", (char)v5);
        Com_Printf(v1, v4);
      }
    }
    result = Scr_AddString(&unk_7BCAE);
  }
  return result;
}
// 5C698: variable 'v4' is possibly undefined
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0005C6CC) --------------------------------------------------------
int sub_5C6CC()
{
  unsigned __int8 v0; // al
  char *v1; // eax
  int result; // eax
  int v3; // eax
  char *v4; // eax
  char v5; // [esp+4h] [ebp-14h]
  char v6; // [esp+4h] [ebp-14h]
  int v7; // [esp+8h] [ebp-10h]
  int v8; // [esp+Ch] [ebp-Ch]
  _BYTE *v9; // [esp+10h] [ebp-8h]

  v9 = (_BYTE *)Scr_GetString(0);
  v0 = BG_GetWeaponIndexForName((char)v9);
  v8 = v0;
  if ( v0 )
  {
    v7 = v0;
    do
    {
      if ( **(_BYTE **)(BG_GetInfoForWeapon(v7) + 388) )
      {
        v3 = BG_GetInfoForWeapon(v7);
        return Scr_AddString(*(_DWORD *)(v3 + 388));
      }
      v7 = *(_DWORD *)(BG_GetInfoForWeapon(v7) + 776);
    }
    while ( v7 && v7 != v8 );
    v4 = (char *)va("^3WARNING^7: no Radiant name found for weapon '%s' in getWeaponClassname\n", (char)v9);
    Com_Printf(v4, v6);
    result = Scr_AddUndefined();
  }
  else
  {
    if ( *v9 )
    {
      if ( Q_stricmp(v9, "none") )
      {
        v1 = (char *)va("unknown weapon '%s' in getWeaponClassname\n", (char)v9);
        Com_Printf(v1, v5);
      }
    }
    result = Scr_AddUndefined();
  }
  return result;
}
// 5C73D: variable 'v5' is possibly undefined
// 5C7BA: variable 'v6' is possibly undefined
// 136F0: using guessed type int Scr_AddUndefined(void);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0005C7CA) --------------------------------------------------------
int sub_5C7CA()
{
  float v1; // [esp+0h] [ebp-18h]
  int v2; // [esp+10h] [ebp-8h] BYREF

  Scr_GetAnim(&v2);
  if ( !trap_XAnimIsPrimitive(v2) )
    Scr_ParamError(0, "non-primitive animation has no concept of length");
  v1 = trap_XAnimGetLengthSeconds(v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14ED0: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 15480: using guessed type long double __cdecl trap_XAnimGetLengthSeconds(_DWORD);
// 15740: using guessed type _DWORD __cdecl trap_XAnimIsPrimitive(_DWORD);

//----- (0005C837) --------------------------------------------------------
int sub_5C837()
{
  int v0; // eax
  unsigned __int16 v2; // [esp+Eh] [ebp-Ah]
  int v3; // [esp+10h] [ebp-8h] BYREF

  Scr_GetAnim(&v3);
  v2 = Scr_GetConstString(1);
  v0 = trap_XAnimNotetrackExists(v3, v2);
  return Scr_AddBool(v0);
}
// 14E40: using guessed type _DWORD __cdecl trap_XAnimNotetrackExists(_DWORD, _DWORD);
// 14ED0: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 150B0: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0005C897) --------------------------------------------------------
int sub_5C897()
{
  float *v1; // [esp+1Ch] [ebp-1Ch]
  float v2; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+24h] [ebp-14h]
  float v4; // [esp+28h] [ebp-10h]

  v1 = (float *)Scr_GetEntity(0);
  v2 = v1[72] + v1[75];
  v3 = v1[73] + v1[76];
  v4 = v1[74] + v1[77];
  v2 = v2 * 0.5;
  v3 = v3 * 0.5;
  v4 = v4 * 0.5;
  return Scr_AddVector(&v2);
}
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005C932) --------------------------------------------------------
int sub_5C932()
{
  char v1; // al
  int v2; // eax
  int v3; // [esp+18h] [ebp-30h]
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  int v5[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v6; // [esp+3Eh] [ebp-Ah]

  v6 = Scr_GetConstString(0);
  Scr_GetVector(1, v5);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v3 = 0;
  else
    v3 = Scr_GetInt(2);
  v4 = (_DWORD *)G_Spawn();
  Scr_SetString(v4 + 95, v6);
  v4[78] = v5[0];
  v4[79] = v5[1];
  v4[80] = v5[2];
  v4[96] = v3;
  if ( G_CallSpawnEntity(v4) )
    return Scr_AddEntity(v4);
  v1 = SL_ConvertToString(v6);
  v2 = va("unable to spawn \"%s\" entity", v1);
  return Scr_Error(v2);
}
// 12E70: using guessed type int G_Spawn(void);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 159B0: using guessed type _DWORD __cdecl G_CallSpawnEntity(_DWORD);

//----- (0005CA21) --------------------------------------------------------
int sub_5CA21()
{
  char v1; // [esp+18h] [ebp-30h]
  _DWORD *v2; // [esp+1Ch] [ebp-2Ch]
  int v3[7]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v4; // [esp+3Eh] [ebp-Ah]

  v4 = Scr_GetConstString(0);
  Scr_GetVector(1, v3);
  v1 = Scr_GetString(2);
  v2 = (_DWORD *)G_Spawn();
  Scr_SetString(v2 + 95, v4);
  v2[78] = v3[0];
  v2[79] = v3[1];
  v2[80] = v3[2];
  G_SpawnTurret(v2, v1);
  return Scr_AddEntity(v2);
}
// 12E70: using guessed type int G_Spawn(void);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15730: using guessed type _DWORD __cdecl G_SpawnTurret(_DWORD, char);

//----- (0005CACC) --------------------------------------------------------
int sub_5CACC()
{
  int result; // eax
  char v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetString(0);
  if ( !level[7] )
    Scr_Error("precacheTurret must be called before any wait statements in the level script\n");
  result = (unsigned __int8)BG_GetWeaponIndexForName(v1);
  if ( (_BYTE)result )
    result = RegisterItem((unsigned __int8)result, 1);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0005CB37) --------------------------------------------------------
int __cdecl sub_5CB37(unsigned int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // [esp+1Ch] [ebp-1Ch]
  void *v4; // [esp+20h] [ebp-18h]
  char *s2; // [esp+2Ch] [ebp-Ch]
  _DWORD *v6; // [esp+30h] [ebp-8h]

  v6 = sub_5B894(a1);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v4 = &unk_7BCAE;
  else
    v4 = (void *)Scr_GetString(1);
  if ( (unsigned int)Scr_GetNumParam() <= 2 )
    v3 = 0;
  else
    v3 = Scr_GetBool(2);
  if ( G_EntDetach((int)v6, s2, (int)v4) )
  {
    v1 = va("model '%s' already attached to tag '%s'", (char)s2);
    Scr_Error(v1);
  }
  result = G_EntAttach((int)v6, s2, (int)v4, v3);
  if ( !result )
    result = Scr_Error("maximum attached models exceeded");
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005CC31) --------------------------------------------------------
int __cdecl sub_5CC31(unsigned int a1)
{
  int result; // eax
  char v2; // al
  int v3; // eax
  char v4; // [esp+4h] [ebp-24h]
  void *v5; // [esp+Ch] [ebp-1Ch]
  int i; // [esp+10h] [ebp-18h]
  char *s2; // [esp+18h] [ebp-10h]
  _DWORD *v8; // [esp+1Ch] [ebp-Ch]

  v8 = sub_5B894(a1);
  s2 = (char *)Scr_GetString(0);
  if ( (unsigned int)Scr_GetNumParam() <= 1 )
    v5 = &unk_7BCAE;
  else
    v5 = (void *)Scr_GetString(1);
  result = G_EntDetach((int)v8, s2, (int)v5);
  if ( !result )
  {
    Com_Printf("Current attachments:\n", v4);
    for ( i = 0; i <= 5; ++i )
    {
      if ( *((_BYTE *)v8 + i + 756) )
      {
        if ( *((_WORD *)v8 + i + 381) )
        {
          SL_ConvertToString(*((unsigned __int16 *)v8 + i + 381));
          v2 = G_ModelName(*((unsigned __int8 *)v8 + i + 756));
          Com_Printf("model: '%s', tag: '%s'\n", v2);
        }
      }
    }
    v3 = va("failed to detach model '%s' from tag '%s'", (char)s2);
    result = Scr_Error(v3);
  }
  return result;
}
// 5CCB6: variable 'v4' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005CD67) --------------------------------------------------------
int __cdecl sub_5CD67(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  return G_EntDetachAll(v2);
}
// 13100: using guessed type _DWORD __cdecl G_EntDetachAll(_DWORD);

//----- (0005CD98) --------------------------------------------------------
int __cdecl sub_5CD98(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  for ( i = 0; i <= 5 && *((_BYTE *)v2 + i + 756); ++i )
    ;
  return Scr_AddInt(i);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005CDF2) --------------------------------------------------------
int __cdecl sub_5CDF2(unsigned int a1)
{
  int v1; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  unsigned int v4; // [esp+10h] [ebp-8h]

  v3 = sub_5B894(a1);
  v4 = Scr_GetInt(0);
  if ( v4 > 5 || !*((_BYTE *)v3 + v4 + 756) )
    Scr_ParamError(0, "bad index");
  v1 = G_ModelName(*((unsigned __int8 *)v3 + v4 + 756));
  return Scr_AddString(v1);
}
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (0005CE73) --------------------------------------------------------
int __cdecl sub_5CE73(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 5 || !*((_BYTE *)v2 + v3 + 756) )
    Scr_ParamError(0, "bad index");
  return Scr_AddConstString(*((unsigned __int16 *)v2 + v3 + 381));
}
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005CEEB) --------------------------------------------------------
int __cdecl sub_5CEEB(unsigned int a1)
{
  _DWORD *v2; // [esp+Ch] [ebp-Ch]
  unsigned int v3; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  v3 = Scr_GetInt(0);
  if ( v3 > 5 || !*((_BYTE *)v2 + v3 + 756) )
    Scr_ParamError(0, "bad index");
  return Scr_AddBool(((int)*((unsigned __int8 *)v2 + 378) >> v3) & 1);
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 150B0: using guessed type _DWORD __cdecl Scr_AddBool(_DWORD);

//----- (0005CF68) --------------------------------------------------------
int __cdecl sub_5CF68(unsigned int a1)
{
  char v1; // al
  int v2; // eax
  int result; // eax
  char v4; // al
  int v5; // eax
  int v6; // eax
  void *v7; // [esp+2Ch] [ebp-3Ch]
  char v8[16]; // [esp+30h] [ebp-38h] BYREF
  char v9[16]; // [esp+40h] [ebp-28h] BYREF
  int v10; // [esp+50h] [ebp-18h]
  char v11[4]; // [esp+54h] [ebp-14h]
  int v12; // [esp+58h] [ebp-10h]
  _DWORD *v13; // [esp+5Ch] [ebp-Ch]

  v13 = sub_5B894(a1);
  if ( Scr_GetType(0) != 7 || Scr_GetPointerType(0) != 13 )
    Scr_ParamError(0, "not an entity");
  if ( (v13[97] & 0x2000) == 0 )
  {
    v1 = SL_ConvertToString(*((unsigned __int16 *)v13 + 190));
    v2 = va("entity (classname: '%s') does not currently support linkTo", v1);
    Scr_ObjectError(v2);
  }
  v12 = Scr_GetEntity(0);
  v10 = Scr_GetNumParam();
  if ( v10 <= 1 )
    v7 = &unk_7BCAE;
  else
    v7 = (void *)Scr_GetString(1);
  *(_DWORD *)v11 = v7;
  if ( v10 > 2 )
  {
    Scr_GetVector(2, v9);
    Scr_GetVector(3, v8);
    result = G_EntLinkToWithOffset(v13, v12, *(_DWORD *)v11, v9, v8);
    if ( result )
      return result;
  }
  else
  {
    result = G_EntLinkTo(v13, v12, *(_DWORD *)v11);
    if ( result )
      return result;
  }
  if ( !trap_DObjExists(v12) )
  {
    if ( !*(_BYTE *)(v12 + 377) )
      Scr_Error("failed to link entity since parent has no model");
    v4 = G_ModelName(*(unsigned __int8 *)(v12 + 377));
    v5 = va("failed to link entity since parent model '%s' is invalid", v4);
    Scr_Error(v5);
  }
  if ( **(_BYTE **)v11 )
  {
    if ( (int)trap_DObjGetBoneIndex(v12, *(_DWORD *)v11) < 0 )
    {
      trap_DObjDumpInfo(v12);
      G_ModelName(*(unsigned __int8 *)(v12 + 377));
      v6 = va("failed to link entity since tag '%s' does not exist in parent model '%s'", v11[0]);
      Scr_Error(v6);
    }
  }
  return Scr_Error("failed to link entity due to link cycle");
}
// 12F00: using guessed type _DWORD __cdecl G_EntLinkTo(_DWORD, _DWORD, _DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 13A30: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13C60: using guessed type _DWORD __cdecl G_EntLinkToWithOffset(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 145A0: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152A0: using guessed type _DWORD __cdecl trap_DObjDumpInfo(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0005D180) --------------------------------------------------------
int __cdecl sub_5D180(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  return G_EntUnlink(v2);
}
// 15760: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (0005D1B1) --------------------------------------------------------
int __cdecl sub_5D1B1(unsigned int a1)
{
  const char *v1; // eax
  char v2; // al
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+10h] [ebp-8h]

  v5 = sub_5B894(a1);
  if ( (v5[97] & 0x2000) != 0 )
    Scr_ObjectError("entity already has linkTo enabled");
  if ( v5[1]
    || *((_BYTE *)v5 + 357)
    || (v5[129] || v5[130])
    && (v1 = (const char *)SL_ConvertToString(*((unsigned __int16 *)v5 + 190)), strcasecmp(v1, "trigger_multiple")) )
  {
    v2 = SL_ConvertToString(*((unsigned __int16 *)v5 + 190));
    v3 = va("entity (classname: '%s') does not currently support enableLinkTo", v2);
    Scr_ObjectError(v3);
  }
  v5[129] = level[122];
  v5[130] = Think_GeneralLink;
  result = v5[97] | 0x2000;
  v5[97] = result;
  return result;
}
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 145A0: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// 6C53D: using guessed type int __cdecl Think_GeneralLink(int);

//----- (0005D2B9) --------------------------------------------------------
int __cdecl sub_5D2B9(unsigned int a1)
{
  int v2[7]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v3; // [esp+2Ch] [ebp-Ch]

  v3 = sub_5B894(a1);
  v2[0] = v3[78];
  v2[1] = v3[79];
  v2[2] = v3[80];
  return Scr_AddVector(v2);
}
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005D30E) --------------------------------------------------------
int __cdecl sub_5D30E(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( !v2[87] )
    return Scr_Error("GetStance is only defined for players.");
  if ( (*(_DWORD *)(v2[87] + 12) & 1) != 0 )
    return Scr_AddConstString(scr_const[53]);
  if ( (*(_DWORD *)(v2[87] + 12) & 2) != 0 )
    return Scr_AddConstString(scr_const[11]);
  return Scr_AddConstString(scr_const[63]);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);

//----- (0005D3B0) --------------------------------------------------------
int __cdecl sub_5D3B0(unsigned int a1)
{
  int v2[7]; // [esp+10h] [ebp-28h] BYREF
  float *v3; // [esp+2Ch] [ebp-Ch]

  v3 = (float *)sub_5B894(a1);
  v2[0] = (int)v3[78];
  v2[1] = (int)v3[79];
  *(float *)&v2[2] = v3[80] + 40.0;
  return Scr_AddVector(v2);
}
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005D413) --------------------------------------------------------
int __cdecl sub_5D413(unsigned int a1)
{
  int result; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_5B894(a1);
  v2 = Scr_GetEntity(0);
  Scr_AddEntity(v2);
  Scr_Notify(v3, scr_const[73], 1);
  result = (int)v3;
  if ( v3[134] )
    result = ((int (__cdecl *)(_DWORD *, int, int))v3[134])(v3, v2, v2);
  return result;
}
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0005D4A2) --------------------------------------------------------
int __cdecl sub_5D4A2(unsigned int a1)
{
  int result; // eax
  float v2; // [esp+10h] [ebp-68h]
  float v3; // [esp+14h] [ebp-64h]
  float v4; // [esp+18h] [ebp-60h]
  float v5; // [esp+20h] [ebp-58h]
  float v6; // [esp+24h] [ebp-54h]
  float v7; // [esp+28h] [ebp-50h]
  int v8; // [esp+3Ch] [ebp-3Ch]
  float v9; // [esp+40h] [ebp-38h] BYREF
  float v10; // [esp+44h] [ebp-34h]
  float v11; // [esp+48h] [ebp-30h]
  float v12; // [esp+50h] [ebp-28h] BYREF
  float v13; // [esp+54h] [ebp-24h]
  float v14; // [esp+58h] [ebp-20h]
  float *v15; // [esp+68h] [ebp-10h]
  float *v16; // [esp+6Ch] [ebp-Ch]

  v8 = 0;
  v16 = (float *)sub_5B894(a1);
  if ( *((_DWORD *)v16 + 64) )
  {
    v16 = (float *)Scr_GetEntity(0);
    v15 = (float *)sub_5B894(a1);
  }
  else
  {
    v15 = (float *)Scr_GetEntity(0);
  }
  v12 = v16[78] + v16[65];
  v13 = v16[79] + v16[66];
  v14 = v16[80] + v16[67];
  v9 = v16[78] + v16[68];
  v10 = v16[79] + v16[69];
  v11 = v16[80] + v16[70];
  if ( *((_DWORD *)v16 + 64) && *((_DWORD *)v15 + 64) )
  {
    v2 = v15[78] + v15[68];
    if ( v2 > (long double)v12
      || (v3 = v15[79] + v15[69], v3 > (long double)v13)
      || (v4 = v15[80] + v15[70], v4 > (long double)v14)
      || (v5 = v15[78] + v15[65], v9 > (long double)v5)
      || (v6 = v15[79] + v15[66], v10 > (long double)v6)
      || (v7 = v15[80] + v15[67], v11 > (long double)v7) )
    {
      v8 = 1;
    }
  }
  else if ( ((_DWORD)v16[61] & 0x200) != 0 )
  {
    if ( trap_EntityContactCapsule(&v12, &v9, v15) )
      v8 = 1;
  }
  else if ( trap_EntityContact(&v12, &v9, v15) )
  {
    v8 = 1;
  }
  if ( v8 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13A20: using guessed type _DWORD __cdecl trap_EntityContact(_DWORD, _DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 147C0: using guessed type _DWORD __cdecl trap_EntityContactCapsule(_DWORD, _DWORD, _DWORD);

//----- (0005D6FA) --------------------------------------------------------
_DWORD *__cdecl sub_5D6FA(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( *((_WORD *)v2 + 190) == scr_const[27]
    || (result = (_DWORD *)*((unsigned __int16 *)v2 + 190), (_WORD)result == scr_const[26]) )
  {
    result = v2;
    v2[172] = 1;
  }
  return result;
}

//----- (0005D75B) --------------------------------------------------------
_DWORD *__cdecl sub_5D75B(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( *((_WORD *)v2 + 190) == scr_const[27]
    || (result = (_DWORD *)*((unsigned __int16 *)v2 + 190), (_WORD)result == scr_const[26]) )
  {
    result = v2;
    v2[172] = 0;
  }
  return result;
}

//----- (0005D7BC) --------------------------------------------------------
int __cdecl sub_5D7BC(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( (*((_WORD *)v2 + 190) == scr_const[27] || *((_WORD *)v2 + 190) == scr_const[26]) && v2[172] )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005D836) --------------------------------------------------------
int __cdecl sub_5D836(unsigned int a1)
{
  int v2; // [esp+8h] [ebp-10h]
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v4; // [esp+10h] [ebp-8h]

  v4 = sub_5B894(a1);
  s2 = (char *)Scr_GetString(0);
  v2 = (unsigned __int8)G_SoundAliasIndex(s2);
  v4[63] = level[122] + 300;
  return G_PlaySoundAlias(v4, v2);
}
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005D8A9) --------------------------------------------------------
int __cdecl sub_5D8A9(unsigned int a1)
{
  int result; // eax
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_5B894(a1);
  s2 = (char *)Scr_GetString(0);
  LOBYTE(result) = G_SoundAliasIndex(s2);
  v3[63] = -1;
  result = (unsigned __int8)result;
  v3[33] = (unsigned __int8)result;
  return result;
}
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005D908) --------------------------------------------------------
_DWORD *__cdecl sub_5D908(unsigned int a1)
{
  _DWORD *result; // eax

  result = sub_5B894(a1);
  result[63] = level[122] + 300;
  result[33] = 0;
  return result;
}

//----- (0005D955) --------------------------------------------------------
int __cdecl sub_5D955(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( v2[87] )
    Scr_Error("Cannot delete a client entity");
  Scr_AddEntity(v2);
  Scr_Notify(v2, scr_const[14], 1);
  trap_UnlinkEntity(v2);
  v2[134] = 0;
  v2[133] = 0;
  v2[130] = G_FreeEntity;
  result = level[122] + 100;
  v2[129] = result;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0005DA0D) --------------------------------------------------------
int __cdecl sub_5DA0D(unsigned int a1)
{
  char *s2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_5B894(a1);
  s2 = (char *)Scr_GetString(0);
  G_SetModel((int)v3, s2);
  G_DObjUpdate(v3);
  return trap_LinkEntity(v3);
}
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005DA6A) --------------------------------------------------------
int __cdecl sub_5DA6A(unsigned int a1)
{
  int result; // eax
  float v2; // [esp+0h] [ebp-18h]
  float v3; // [esp+0h] [ebp-18h]
  _DWORD *v4; // [esp+10h] [ebp-8h]

  v4 = sub_5B894(a1);
  if ( v4[87] )
  {
    if ( v4[142] )
    {
      v2 = (long double)(int)v4[142] / (long double)*(int *)(v4[87] + 8524);
      result = Scr_AddFloat(LODWORD(v2));
    }
    else
    {
      result = Scr_AddFloat(0);
    }
  }
  else
  {
    v3 = (float)(int)v4[142];
    result = Scr_AddFloat(LODWORD(v3));
  }
  return result;
}
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005DAEB) --------------------------------------------------------
int __cdecl sub_5DAEB(unsigned int a1)
{
  int result; // eax
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+6h] [ebp-12h]
  int v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  _DWORD *v6; // [esp+10h] [ebp-8h]

  v6 = sub_5B894(a1);
  v5 = Scr_GetFloat(0);
  if ( v5 > 1.0 )
    v5 = 1.0;
  if ( v6[87] )
  {
    v2 = v3;
    v4 = (int)((long double)*(int *)(v6[87] + 8524) * v5);
  }
  else
  {
    v2 = v3;
    if ( v6[143] )
      v4 = (int)((long double)(int)v6[143] * v5);
    else
      v4 = (int)v5;
  }
  if ( v4 <= 0 )
    return Com_Printf("ERROR: Cannot setnormalhealth to 0 or below.\n", v2);
  result = v4;
  v6[142] = v4;
  return result;
}
// 5DB5E: variable 'v3' is possibly undefined
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (0005DBE2) --------------------------------------------------------
unsigned int __cdecl ScrCmd_Show(unsigned int a1)
{
  _DWORD *v1; // edx
  unsigned int result; // eax

  v1 = sub_5B894(a1);
  result = v1[97] & 0xFFFFEFFF;
  v1[97] = result;
  return result;
}

//----- (0005DC0F) --------------------------------------------------------
int __cdecl ScrCmd_Hide(unsigned int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_5B894(a1);
  result = v1[97] | 0x1000;
  v1[97] = result;
  return result;
}

//----- (0005DC3C) --------------------------------------------------------
int __cdecl sub_5DC3C(unsigned int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]

  v3 = sub_5B894(a1);
  v2 = Scr_GetInt(0);
  Scr_AddInt(v3[71]);
  v3[71] = v2;
  return trap_LinkEntity(v3);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005DC99) --------------------------------------------------------
_DWORD *__cdecl sub_5DC99(unsigned int a1)
{
  _DWORD *result; // eax
  int v2; // eax
  char v3; // [esp+4h] [ebp-14h]
  char v4; // [esp+4h] [ebp-14h]
  int v5; // [esp+8h] [ebp-10h]
  _DWORD *v6; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]
  int j; // [esp+10h] [ebp-8h]

  v6 = sub_5B894(a1);
  v5 = Scr_GetString(0);
  if ( *((_WORD *)v6 + 190) != scr_const[74] || Q_strcasecmp(v5, "HINT_INHERIT") )
  {
    for ( i = 1; i <= 137 && *(&hintStrings + i); ++i )
    {
      if ( !Q_strcasecmp(v5, *(&hintStrings + i)) )
      {
        result = (_DWORD *)i;
        v6[55] = i;
        return result;
      }
    }
    Com_Printf("List of valid hint type strings\n", v3);
    if ( *((_WORD *)v6 + 190) == scr_const[74] )
      Com_Printf("HINT_INHERIT (for trigger_use entities only)\n", v4);
    for ( j = 1; j <= 137 && *(&hintStrings + j); ++j )
      Com_Printf((char *)&off_7C54E, (char)*(&hintStrings + j));
    v2 = va("%s is not a valid hint type. See above for list of valid hint types\n", v5);
    result = (_DWORD *)Scr_Error(v2);
  }
  else
  {
    result = v6;
    v6[55] = -1;
  }
  return result;
}
// 5DD6D: variable 'v3' is possibly undefined
// 5DD94: variable 'v4' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 154C0: using guessed type _DWORD __cdecl Q_strcasecmp(_DWORD, _DWORD);
// 7C54E: using guessed type void *off_7C54E;
// 83C00: using guessed type void *hintStrings;

//----- (0005DE02) --------------------------------------------------------
int __cdecl G_GetHintStringIndex(int a1, char *s1)
{
  char s2[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1212, s2, 1024);
    if ( !s2[0] )
    {
      trap_SetConfigstring(i + 1212, s1);
      *(_DWORD *)a1 = i;
      return 1;
    }
    if ( !strcmp(s1, s2) )
    {
      *(_DWORD *)a1 = i;
      return 1;
    }
  }
  *(_DWORD *)a1 = -1;
  return 0;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);

//----- (0005DED8) --------------------------------------------------------
_DWORD *__cdecl sub_5DED8(unsigned int a1)
{
  int v1; // eax
  _DWORD *result; // eax
  int v3; // eax
  char s1[1028]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v5; // [esp+414h] [ebp-14h]
  int v6; // [esp+418h] [ebp-10h]
  int v7[3]; // [esp+41Ch] [ebp-Ch] BYREF

  v5 = sub_5B894(a1);
  if ( *((_WORD *)v5 + 190) != scr_const[74] )
    Scr_Error("The setHintString command only works on trigger_use entities.\n");
  v6 = Scr_GetType(0);
  if ( v6 != 1 || (v1 = Scr_GetString(0), Q_stricmp(v1, &unk_7BCAE)) )
  {
    Scr_ConstructMessageString(0, s1, 1024, 2);
    if ( !G_GetHintStringIndex((int)v7, s1) )
    {
      v3 = va("Too many different hintstring values. Max allowed is %i different strings", 32);
      Scr_Error(v3);
    }
    result = (_DWORD *)LOBYTE(v7[0]);
    v5[54] = LOBYTE(v7[0]);
  }
  else
  {
    result = v5;
    v5[54] = 255;
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005DFDB) --------------------------------------------------------
int __cdecl sub_5DFDB(unsigned int a1)
{
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  return Scr_AddInt(*v2);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005E00E) --------------------------------------------------------
_DWORD *__cdecl GScr_EnableGrenadeTouchDamage(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( *((_WORD *)v2 + 190) != scr_const[75] )
    Scr_Error("Currently on supported on damage triggers");
  result = v2;
  v2[97] |= 0x8000u;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0005E073) --------------------------------------------------------
_DWORD *__cdecl GScr_DisableGrenadeTouchDamage(unsigned int a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B894(a1);
  if ( *((_WORD *)v2 + 190) != scr_const[75] )
    Scr_Error("Currently on supported on damage triggers");
  result = v2;
  v2[97] &= 0xFFFF7FFF;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0005E0D8) --------------------------------------------------------
unsigned int __cdecl GScr_EnableGrenadeBounce(unsigned int a1)
{
  _DWORD *v1; // edx
  unsigned int result; // eax

  v1 = sub_5B894(a1);
  result = v1[97] & 0xFFFEFFFF;
  v1[97] = result;
  return result;
}

//----- (0005E105) --------------------------------------------------------
int __cdecl GScr_DisableGrenadeBounce(unsigned int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = sub_5B894(a1);
  result = v1[97] | 0x10000;
  v1[97] = result;
  return result;
}

//----- (0005E132) --------------------------------------------------------
int *G_InitObjectives()
{
  int *result; // eax
  int i; // [esp+10h] [ebp-8h] BYREF

  for ( i = 0; i <= 15; ++i )
  {
    sub_5E279(&level[7 * i + 8]);
    result = &i;
  }
  return result;
}

//----- (0005E185) --------------------------------------------------------
int __cdecl ObjectiveStateIndexFromString(_DWORD *a1, __int16 a2)
{
  if ( a2 == scr_const[18] )
  {
    *a1 = 0;
    return 1;
  }
  if ( a2 == scr_const[33] )
  {
    *a1 = 2;
    return 1;
  }
  if ( a2 == scr_const[10] )
  {
    *a1 = 4;
    return 1;
  }
  *a1 = 0;
  return 0;
}

//----- (0005E211) --------------------------------------------------------
int __cdecl sub_5E211(int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-8h]

  result = a1;
  if ( *(_DWORD *)(a1 + 16) != 1023 )
  {
    v2 = &g_entities[199 * *(_DWORD *)(a1 + 16)];
    if ( *((_BYTE *)v2 + 356) )
      v2[61] &= 0xFFFFFFEF;
    result = a1;
    *(_DWORD *)(a1 + 16) = 1023;
  }
  return result;
}

//----- (0005E279) --------------------------------------------------------
_DWORD *__cdecl sub_5E279(_DWORD *a1)
{
  _DWORD *result; // eax

  *a1 = 0;
  a1[3] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[4] = 1023;
  a1[5] = 0;
  result = a1;
  a1[6] = 0;
  return result;
}

//----- (0005E2CC) --------------------------------------------------------
int __cdecl sub_5E2CC(int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  char *s2; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  s2 = (char *)Scr_GetString(a2);
  for ( i = 0; s2[i]; ++i )
  {
    if ( s2[i] <= 31 || s2[i] == 127 )
    {
      v2 = va("Illegal character '%c'(ascii %i) in objective icon name: %s\n", s2[i]);
      Scr_ParamError(3, v2);
    }
  }
  if ( i > 63 )
  {
    v3 = va("Objective icon name is too long (> %i): %s\n", 63);
    Scr_ParamError(3, v3);
  }
  result = G_ShaderIndex(s2);
  *(_DWORD *)(a1 + 24) = result;
  return result;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005E3AA) --------------------------------------------------------
float *sub_5E3AA()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  float *result; // eax
  int v4; // [esp+20h] [ebp-18h] BYREF
  unsigned __int16 v5; // [esp+26h] [ebp-12h]
  float *v6; // [esp+28h] [ebp-10h]
  char v7[4]; // [esp+2Ch] [ebp-Ch]
  int v8; // [esp+30h] [ebp-8h]

  v8 = Scr_GetNumParam();
  if ( v8 <= 1 )
    Scr_Error(
      "objective_add needs at least the first two parameters out of its parameter list of: index state [string] [position]\n");
  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(int *)v7 < 0 || *(int *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v7[0]);
    Scr_ParamError(0, v0);
  }
  v6 = (float *)&level[7 * *(_DWORD *)v7 + 8];
  sub_5E211((int)v6);
  v5 = Scr_GetConstString(1);
  if ( !ObjectiveStateIndexFromString(&v4, v5) )
  {
    v1 = SL_ConvertToString(v5);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, v2);
  }
  *(_DWORD *)v6 = v4;
  if ( v8 > 2 )
  {
    Scr_GetVector(2, v6 + 1);
    v6[1] = (float)(int)v6[1];
    v6[2] = (float)(int)v6[2];
    v6[3] = (float)(int)v6[3];
    *((_DWORD *)v6 + 4) = 1023;
    if ( v8 > 3 )
      sub_5E2CC((int)v6, 3);
  }
  result = v6;
  v6[5] = 0.0;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 155E0: using guessed type _DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD);

//----- (0005E56C) --------------------------------------------------------
_DWORD *sub_5E56C()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2);
    Scr_ParamError(0, v0);
  }
  sub_5E211((int)&level[7 * v2 + 8]);
  return sub_5E279(&level[7 * v2 + 8]);
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005E618) --------------------------------------------------------
int sub_5E618()
{
  int v0; // eax
  char v1; // al
  int v2; // eax
  int result; // eax
  unsigned __int16 v4; // [esp+16h] [ebp-12h]
  int v5; // [esp+18h] [ebp-10h] BYREF
  _DWORD *v6; // [esp+1Ch] [ebp-Ch]
  char v7[4]; // [esp+20h] [ebp-8h]

  *(_DWORD *)v7 = Scr_GetInt(0);
  if ( *(int *)v7 < 0 || *(int *)v7 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v7[0]);
    Scr_ParamError(0, v0);
  }
  v6 = &level[7 * *(_DWORD *)v7 + 8];
  v4 = Scr_GetConstString(1);
  if ( !ObjectiveStateIndexFromString(&v5, v4) )
  {
    v1 = Scr_GetString(1);
    v2 = va("Illegal objective state \"%s\". Valid states are \"empty\", \"invisible\", \"current\"\n", v1);
    Scr_ParamError(1, v2);
  }
  result = v5;
  *v6 = v5;
  if ( !v5 || v5 == 2 )
    result = sub_5E211((int)v6);
  return result;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 155E0: using guessed type _DWORD __cdecl ObjectiveStateIndexFromString(_DWORD, _DWORD);

//----- (0005E710) --------------------------------------------------------
int sub_5E710()
{
  int v0; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 < 0 || v2 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v2);
    Scr_ParamError(0, v0);
  }
  return sub_5E2CC((int)&level[7 * v2 + 8], 1);
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005E79F) --------------------------------------------------------
int sub_5E79F()
{
  int v0; // eax
  int result; // eax
  float *v2; // [esp+1Ch] [ebp-Ch]
  int v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetInt(0);
  if ( v3 < 0 || v3 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3);
    Scr_ParamError(0, v0);
  }
  v2 = (float *)&level[7 * v3 + 8];
  sub_5E211((int)v2);
  Scr_GetVector(1, v2 + 1);
  v2[1] = (float)(int)v2[1];
  v2[2] = (float)(int)v2[2];
  result = (int)v2[3];
  v2[3] = (float)result;
  return result;
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005E8B1) --------------------------------------------------------
int sub_5E8B1()
{
  int v0; // eax
  int result; // eax
  int *v2; // [esp+18h] [ebp-10h]
  int v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetInt(0);
  if ( v3 < 0 || v3 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v3);
    Scr_ParamError(0, v0);
  }
  sub_5E211((int)&level[7 * v3 + 8]);
  v2 = (int *)Scr_GetEntity(1);
  v2[61] |= 0x10u;
  result = *v2;
  level[7 * v3 + 12] = *v2;
  return result;
}
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005E96D) --------------------------------------------------------
char *sub_5E96D()
{
  char *result; // eax
  int v1; // eax
  int s[16]; // [esp+10h] [ebp-58h] BYREF
  _DWORD *v3; // [esp+50h] [ebp-18h]
  char v4[4]; // [esp+54h] [ebp-14h] BYREF
  char *v5; // [esp+58h] [ebp-10h]
  char *i; // [esp+5Ch] [ebp-Ch]

  v5 = (char *)Scr_GetNumParam();
  memset(s, 0, sizeof(s));
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( (int)i >= (int)v5 )
      break;
    *(_DWORD *)v4 = Scr_GetInt(i);
    if ( *(int *)v4 < 0 || *(int *)v4 > 15 )
    {
      v1 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v4[0]);
      Scr_ParamError(i, v1);
    }
    s[*(_DWORD *)v4] = 1;
  }
  *(_DWORD *)v4 = 0;
  while ( *(int *)v4 <= 15 )
  {
    v3 = &level[7 * *(_DWORD *)v4 + 8];
    if ( s[*(_DWORD *)v4] )
    {
      *v3 = 4;
    }
    else if ( *v3 == 4 )
    {
      *v3 = 1;
    }
    result = v4;
    ++*(_DWORD *)v4;
  }
  return result;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005EA6F) --------------------------------------------------------
_DWORD *sub_5EA6F()
{
  int v0; // eax
  _DWORD *result; // eax
  char v2; // al
  int v3; // eax
  unsigned __int16 v4; // [esp+1Ah] [ebp-Eh]
  _DWORD *v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v6 = Scr_GetInt(0);
  if ( v6 < 0 || v6 > 15 )
  {
    v0 = va("index %i is an illegal objective index. Valid indexes are 0 to %i\n", v6);
    Scr_ParamError(0, v0);
  }
  v5 = &level[7 * v6 + 8];
  v4 = Scr_GetConstString(1);
  if ( v4 == scr_const[2] )
  {
    result = &level[7 * v6 + 8];
    v5[5] = 2;
  }
  else if ( v4 == scr_const[4] )
  {
    result = &level[7 * v6 + 8];
    v5[5] = 1;
  }
  else if ( v4 == scr_const[124] )
  {
    result = &level[7 * v6 + 8];
    v5[5] = 0;
  }
  else
  {
    v2 = SL_ConvertToString(v4);
    v3 = va("Illegal team string '%s'. Must be allies, axis, or none.", v2);
    result = (_DWORD *)Scr_ParamError(1, v3);
  }
  return result;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (0005EB86) --------------------------------------------------------
int sub_5EB86()
{
  char v1; // [esp+4h] [ebp-434h]
  char *s; // [esp+1Ch] [ebp-41Ch]
  char dest[1024]; // [esp+20h] [ebp-418h] BYREF
  size_t v4; // [esp+420h] [ebp-18h]
  int v5; // [esp+424h] [ebp-14h]
  int v6; // [esp+428h] [ebp-10h]
  int i; // [esp+42Ch] [ebp-Ch]

  dest[0] = 0;
  v5 = 0;
  v6 = Scr_GetNumParam();
  for ( i = 0; i < v6; ++i )
  {
    s = (char *)Scr_GetString(i);
    v4 = strlen(s);
    if ( (int)(v5 + v4) > 1023 )
      break;
    strcat(dest, s);
    v5 += v4;
  }
  return G_LogPrintf(dest, v1);
}
// 5EC21: variable 'v1' is possibly undefined
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005EC2F) --------------------------------------------------------
int sub_5EC2F()
{
  return Scr_AddInt(1022);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005EC53) --------------------------------------------------------
int sub_5EC53()
{
  int result; // eax
  _DWORD *v1; // [esp+Ch] [ebp-1Ch]
  int v2; // [esp+10h] [ebp-18h]
  int v3; // [esp+14h] [ebp-14h]
  char v4; // [esp+18h] [ebp-10h]
  char v5; // [esp+1Ch] [ebp-Ch]
  _DWORD *v6; // [esp+20h] [ebp-8h]

  v5 = Scr_GetString(2);
  v3 = (unsigned __int8)BG_GetWeaponIndexForName(v5);
  v4 = Scr_GetString(3);
  v2 = G_IndexForMeansOfDeath(v4);
  v6 = (_DWORD *)Scr_GetEntity(0);
  v1 = (_DWORD *)G_TempEntity(vec3_origin, 201);
  v1[29] = *v6;
  if ( Scr_GetType(1) == 7 && Scr_GetPointerType(1) == 13 )
    v1[30] = *(_DWORD *)Scr_GetEntity(1);
  else
    v1[30] = 1022;
  v1[61] = 8;
  if ( v2 == 7 || v2 == 8 || v2 == 22 || v2 == 21 || v2 == 19 || v2 == 16 || v2 == 17 )
  {
    result = v2 | 0x80;
    v1[40] = v2 | 0x80;
  }
  else
  {
    result = v3;
    v1[40] = v3;
  }
  return result;
}
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 15500: using guessed type _DWORD __cdecl G_IndexForMeansOfDeath(char);
// 15690: using guessed type _DWORD __cdecl BG_GetWeaponIndexForName(char);

//----- (0005ED7B) --------------------------------------------------------
int sub_5ED7B()
{
  float v1; // [esp+20h] [ebp-1058h] BYREF
  float v2; // [esp+24h] [ebp-1054h]
  float v3; // [esp+28h] [ebp-1050h]
  float v4[4]; // [esp+30h] [ebp-1048h] BYREF
  float v5[7]; // [esp+40h] [ebp-1038h] BYREF
  _DWORD *v6; // [esp+5Ch] [ebp-101Ch]
  int v7[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v8; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  Scr_GetVector(0, &v1);
  v5[0] = v1 + *(float *)playerMins;
  v5[1] = v2 + *(float *)&playerMins[1];
  v5[2] = v3 + *(float *)&playerMins[2];
  v4[0] = v1 + *(float *)playerMaxs;
  v4[1] = v2 + *(float *)&playerMaxs[1];
  v4[2] = v3 + *(float *)&playerMaxs[2];
  v8 = trap_EntitiesInBox(v5, v4, v7, 1024, 0x2000000);
  for ( i = 0; i < v8; ++i )
  {
    v6 = &g_entities[199 * v7[i]];
    if ( v6[87] && *(int *)(v6[87] + 4) <= 5 )
      return Scr_AddInt(1);
  }
  return Scr_AddInt(0);
}
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005EED3) --------------------------------------------------------
int sub_5EED3()
{
  return Scr_AddInt(level[125]);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);

//----- (0005EEFF) --------------------------------------------------------
int sub_5EEFF()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1180, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the menu '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1180, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 32 )
  {
    v1 = va("Too many menus precached. Max allowed menus is %i", 32);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 1180, *(_DWORD *)v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005F015) --------------------------------------------------------
int __cdecl GScr_GetScriptMenuIndex(int a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  for ( i = 0; i <= 31; ++i )
  {
    trap_GetConfigstring(i + 1180, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i;
  }
  v1 = va("Menu '%s' was not precached\n", a1);
  Scr_Error(v1);
  return 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0005F0BC) --------------------------------------------------------
int sub_5F0BC()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 7; ++i )
  {
    trap_GetConfigstring(i + 21, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the player status icon '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 7; ++i )
  {
    trap_GetConfigstring(i + 21, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 8 )
  {
    v1 = va("Too many player status icons precached. Max allowed is %i", 8);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 21, *(_DWORD *)v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005F1CC) --------------------------------------------------------
int __cdecl GScr_GetStatusIconIndex(_BYTE *a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 7; ++i )
  {
    trap_GetConfigstring(i + 21, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i + 1;
  }
  v1 = va("Status icon '%s' was not precached\n", (char)a1);
  Scr_Error(v1);
  return 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0005F289) --------------------------------------------------------
int sub_5F289()
{
  int v1; // eax
  char v2[1032]; // [esp+10h] [ebp-418h] BYREF
  char v3[4]; // [esp+418h] [ebp-10h]
  int i; // [esp+41Ch] [ebp-Ch]

  *(_DWORD *)v3 = Scr_GetString(0);
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 29, v2, 1024);
    if ( !Q_stricmp(v2, *(_DWORD *)v3) )
      return Com_DPrintf("Script tried to precache the player head icon '%s' more than once\n", v3[0]);
  }
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 29, v2, 1024);
    if ( !v2[0] )
      break;
  }
  if ( i == 15 )
  {
    v1 = va("Too many player head icons precached. Max allowed is %i", 15);
    Scr_Error(v1);
  }
  return trap_SetConfigstring(i + 29, *(_DWORD *)v3);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005F399) --------------------------------------------------------
int __cdecl GScr_GetHeadIconIndex(_BYTE *a1)
{
  int v1; // eax
  char v4[1036]; // [esp+20h] [ebp-418h] BYREF
  int i; // [esp+42Ch] [ebp-Ch]

  if ( !*a1 )
    return 0;
  for ( i = 0; i <= 14; ++i )
  {
    trap_GetConfigstring(i + 29, v4, 1024);
    if ( !Q_stricmp(v4, a1) )
      return i + 1;
  }
  v1 = va("Head icon '%s' was not precached\n", (char)a1);
  Scr_Error(v1);
  return 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0005F456) --------------------------------------------------------
int sub_5F456()
{
  int v0; // eax
  int result; // eax
  float v2[7]; // [esp+20h] [ebp-88h] BYREF
  int v3; // [esp+3Ch] [ebp-6Ch]
  float v4; // [esp+40h] [ebp-68h] BYREF
  int v5; // [esp+44h] [ebp-64h] BYREF
  _DWORD v6[6]; // [esp+50h] [ebp-58h] BYREF
  unsigned __int16 v7; // [esp+68h] [ebp-40h]
  int v8; // [esp+70h] [ebp-38h]
  int v9; // [esp+74h] [ebp-34h]
  int *v10; // [esp+78h] [ebp-30h]
  float v12[4]; // [esp+80h] [ebp-28h] BYREF
  float v13[6]; // [esp+90h] [ebp-18h] BYREF

  v10 = 0;
  v9 = 1023;
  v8 = 41951281;
  Scr_GetVector(0, v13);
  Scr_GetVector(1, v12);
  if ( !Scr_GetBool(2) )
    v8 &= 0xFDFFFFFF;
  if ( Scr_GetType(3) == 7 && Scr_GetPointerType(3) == 13 )
  {
    v10 = (int *)Scr_GetEntity(3);
    v9 = *v10;
  }
  trap_LocationalTrace(&v4, v13, v12, v9, v8, &bulletPriorityMap);
  Scr_MakeArray();
  Scr_AddFloat(LODWORD(v4));
  Scr_AddArrayStringIndexed(scr_const[25]);
  Scr_AddVector(&v5);
  Scr_AddArrayStringIndexed(scr_const[50]);
  if ( v7 == 1023 || v7 == 1022 )
    Scr_AddUndefined();
  else
    Scr_AddEntity(&g_entities[199 * v7]);
  Scr_AddArrayStringIndexed(scr_const[22]);
  if ( v4 >= 1.0 )
  {
    v2[0] = v12[0] - v13[0];
    v2[1] = v12[1] - v13[1];
    v2[2] = v12[2] - v13[2];
    VectorNormalize(v2);
    Scr_AddVector(v2);
    Scr_AddArrayStringIndexed(scr_const[46]);
    Scr_AddConstString(scr_const[124]);
    result = Scr_AddArrayStringIndexed(scr_const[64]);
  }
  else
  {
    Scr_AddVector(v6);
    Scr_AddArrayStringIndexed(scr_const[46]);
    v3 = (v6[3] & 0x1F00000) >> 20;
    v0 = trap_SurfaceTypeToName(v3);
    Scr_AddString(v0);
    result = Scr_AddArrayStringIndexed(scr_const[64]);
  }
  return result;
}
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 136F0: using guessed type int Scr_AddUndefined(void);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14EC0: using guessed type _DWORD __cdecl Scr_AddArrayStringIndexed(_DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15440: using guessed type _DWORD __cdecl trap_SurfaceTypeToName(_DWORD);
// 15700: using guessed type int Scr_MakeArray(void);

//----- (0005F6A8) --------------------------------------------------------
int sub_5F6A8()
{
  int result; // eax
  int v1; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( v2 > 0 )
  {
    v1 = irand(0, v2);
    result = Scr_AddInt(v1);
  }
  else
  {
    Com_Printf("RandomInt parm: %d  ", v2);
    result = Scr_Error("RandomInt parm must be positive integer.\n");
  }
  return result;
}
// 12EB0: using guessed type _DWORD __cdecl irand(_DWORD, _DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005F715) --------------------------------------------------------
int sub_5F715()
{
  float v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetFloat(0);
  flrand(0.0, v1);
  return Scr_AddFloat(LODWORD(v1));
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005F757) --------------------------------------------------------
int sub_5F757()
{
  int v0; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  v3 = Scr_GetInt(0);
  v2 = Scr_GetInt(1);
  if ( v2 <= v3 )
  {
    Com_Printf("RandomIntRange parms: %d %d ", v3);
    Scr_Error("RandomIntRange range must be positive integer.\n");
  }
  v0 = irand(v3, v2);
  return Scr_AddInt(v0);
}
// 12EB0: using guessed type _DWORD __cdecl irand(_DWORD, _DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (0005F7D9) --------------------------------------------------------
int sub_5F7D9()
{
  long double v0; // fst7
  float v2; // [esp+0h] [ebp-28h]
  double v3; // [esp+4h] [ebp-24h]
  float v4; // [esp+1Ch] [ebp-Ch]
  float v5; // [esp+20h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  v4 = Scr_GetFloat(1);
  v0 = v4;
  if ( v5 >= (long double)v4 )
  {
    v0 = v5;
    v3 = v5;
    Com_Printf("Scr_RandomFloatRange parms: %d %d ", SLOBYTE(v3));
    Scr_Error("Scr_RandomFloatRange range must be positive float.\n");
  }
  flrand(v5, v4);
  v2 = v0;
  return Scr_AddFloat(LODWORD(v2));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005F862) --------------------------------------------------------
int sub_5F862()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = sin(v0 * 3.141592653589793 / 180.0);
  return Scr_AddFloat(LODWORD(v2));
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005F8AC) --------------------------------------------------------
int sub_5F8AC()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = cos(v0 * 3.141592653589793 / 180.0);
  return Scr_AddFloat(LODWORD(v2));
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005F8F6) --------------------------------------------------------
int sub_5F8F6()
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+18h] [ebp-10h]
  float v3; // [esp+1Ch] [ebp-Ch] BYREF
  float v4[2]; // [esp+20h] [ebp-8h] BYREF

  v2 = Scr_GetFloat(0) * 3.141592653589793 / 180.0;
  sub_62FDB(v2, v4, &v3);
  if ( v3 == 0.0 )
    Scr_Error("divide by 0");
  v1 = v4[0] / v3;
  return Scr_AddFloat(LODWORD(v1));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005F978) --------------------------------------------------------
int sub_5F978()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-14h]
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  if ( v5 < -1.0 || v5 > 1.0 )
  {
    v2 = v5;
    v0 = va("%g out of range", SLOBYTE(v2));
    Scr_Error(v0);
  }
  v3 = asin(v5);
  v4 = v3 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v4));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FA0F) --------------------------------------------------------
int sub_5FA0F()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-14h]
  float v3; // [esp+Ch] [ebp-Ch]
  float v4; // [esp+Ch] [ebp-Ch]
  float v5; // [esp+10h] [ebp-8h]

  v5 = Scr_GetFloat(0);
  if ( v5 < -1.0 || v5 > 1.0 )
  {
    v2 = v5;
    v0 = va("%g out of range", SLOBYTE(v2));
    Scr_Error(v0);
  }
  v3 = acos(v5);
  v4 = v3 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v4));
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FAA6) --------------------------------------------------------
int sub_5FAA6()
{
  long double v0; // fst7
  float v2; // [esp+10h] [ebp-8h]
  float v3; // [esp+10h] [ebp-8h]

  v0 = Scr_GetFloat(0);
  v2 = atan(v0);
  v3 = v2 * 180.0 / 3.141592653589793;
  return Scr_AddFloat(LODWORD(v3));
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FAF6) --------------------------------------------------------
int sub_5FAF6()
{
  float v1; // [esp+0h] [ebp-38h]
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = VectorDistance(v3, v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 15270: using guessed type long double __cdecl VectorDistance(_DWORD, _DWORD);

//----- (0005FB4E) --------------------------------------------------------
int sub_5FB4E()
{
  float v1; // [esp+0h] [ebp-38h]
  char v2[16]; // [esp+10h] [ebp-28h] BYREF
  char v3[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = VectorDistanceSquared(v3, v2);
  return Scr_AddFloat(LODWORD(v1));
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14F80: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0005FBA6) --------------------------------------------------------
int sub_5FBA6()
{
  float v1; // [esp+1Ch] [ebp-1Ch]
  float v2; // [esp+20h] [ebp-18h] BYREF
  float v3; // [esp+24h] [ebp-14h]
  float v4; // [esp+28h] [ebp-10h]

  Scr_GetVector(0, &v2);
  v1 = sqrt(v2 * v2 + v3 * v3 + v4 * v4);
  return Scr_AddFloat(LODWORD(v1));
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FBFD) --------------------------------------------------------
int sub_5FBFD()
{
  float v1; // [esp+0h] [ebp-28h]
  float v2; // [esp+10h] [ebp-18h] BYREF
  float v3; // [esp+14h] [ebp-14h]
  float v4; // [esp+18h] [ebp-10h]

  Scr_GetVector(0, &v2);
  v1 = v2 * v2 + v3 * v3 + v4 * v4;
  return Scr_AddFloat(LODWORD(v1));
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FC46) --------------------------------------------------------
int sub_5FC46()
{
  float v1; // [esp+18h] [ebp-40h]
  float v2; // [esp+1Ch] [ebp-3Ch]
  char v3[16]; // [esp+20h] [ebp-38h] BYREF
  char v4[16]; // [esp+30h] [ebp-28h] BYREF
  char v5[24]; // [esp+40h] [ebp-18h] BYREF

  Scr_GetVector(0, v5);
  Scr_GetVector(1, v4);
  Scr_GetVector(2, v3);
  v2 = VectorDistanceSquared(v4, v5);
  v1 = VectorDistanceSquared(v3, v5);
  return Scr_AddInt(v1 > (long double)v2);
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14F80: using guessed type double __cdecl VectorDistanceSquared(_DWORD, _DWORD);

//----- (0005FCDC) --------------------------------------------------------
int sub_5FCDC()
{
  float v1; // [esp+0h] [ebp-38h]
  float v2[4]; // [esp+10h] [ebp-28h] BYREF
  float v3[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v3);
  Scr_GetVector(1, v2);
  v1 = v3[0] * v2[0] + v3[1] * v2[1] + v3[2] * v2[2];
  return Scr_AddFloat(LODWORD(v1));
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);

//----- (0005FD38) --------------------------------------------------------
int sub_5FD38()
{
  int v1[4]; // [esp+10h] [ebp-28h] BYREF
  int v2[6]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  v1[0] = v2[0];
  v1[1] = v2[1];
  v1[2] = v2[2];
  VectorNormalize(v1);
  return Scr_AddVector(v1);
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005FD8D) --------------------------------------------------------
int sub_5FD8D()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  vectoangles(v2, v1);
  return Scr_AddVector(v1);
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 15800: using guessed type _DWORD __cdecl vectoangles(_DWORD, _DWORD);

//----- (0005FDD5) --------------------------------------------------------
int sub_5FDD5()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, 0, v1);
  return Scr_AddVector(v1);
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005FE2D) --------------------------------------------------------
int sub_5FE2D()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, 0, v1, 0);
  return Scr_AddVector(v1);
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005FE85) --------------------------------------------------------
int sub_5FE85()
{
  char v1[16]; // [esp+10h] [ebp-28h] BYREF
  char v2[24]; // [esp+20h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  AngleVectors(v2, v1, 0, 0);
  return Scr_AddVector(v1);
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (0005FEDD) --------------------------------------------------------
int sub_5FEDD()
{
  char v0; // al
  int v1; // eax

  v0 = Scr_GetString(0);
  v1 = va("o %s", v0);
  return trap_SendServerCommand(-1, 1, v1);
}
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0005FF2B) --------------------------------------------------------
int sub_5FF2B()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  v6 = Scr_GetNumParam();
  if ( v6 )
  {
    if ( v6 != 1 )
    {
      v0 = va("USAGE: musicStop([fadetime]);\n", v5);
      return Scr_Error(v0);
    }
    v4 = Scr_GetFloat(0) * 1000.0;
    v7 = sub_62F9D(v4);
  }
  else
  {
    v7 = 0;
  }
  if ( v7 < 0 )
  {
    v2 = va("musicStop: fade time must be >= 0\n", v5);
    Scr_Error(v2);
  }
  v3 = va("p %i", v7);
  return trap_SendServerCommand(-1, 1, v3);
}
// 5FF86: variable 'v5' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0005FFE4) --------------------------------------------------------
int sub_5FFE4()
{
  int v0; // eax
  double v2; // [esp+4h] [ebp-24h]
  float v3; // [esp+20h] [ebp-8h]

  v3 = Scr_GetFloat(0);
  if ( (unsigned int)Scr_GetNumParam() > 1 )
    Scr_GetFloat(1);
  v2 = v3;
  v0 = va("q %f %i\n", SLOBYTE(v2));
  return trap_SendServerCommand(-1, 1, v0);
}
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0006007E) --------------------------------------------------------
int sub_6007E()
{
  char *v0; // eax

  if ( !level[7] )
    Scr_Error("precacheModel must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ModelIndex(v0);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000600C4) --------------------------------------------------------
int sub_600C4()
{
  char *v0; // eax

  if ( !level[7] )
    Scr_Error("precacheShellShock must be called before any wait statements in the gametype or level script\n");
  v0 = (char *)Scr_GetString(0);
  return G_ShellShockIndex(v0);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006010A) --------------------------------------------------------
int sub_6010A()
{
  int v0; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  int v3; // [esp+10h] [ebp-8h]

  if ( !level[7] )
    Scr_Error("precacheItem must be called before any wait statements in the gametype or level script\n");
  v3 = Scr_GetString(0);
  v2 = BG_FindItem(v3);
  if ( !v2 )
  {
    v0 = va("unknown item '%s'", v3);
    Scr_ParamError(0, v0);
  }
  return RegisterItem(-1431655765 * ((v2 - (int)bg_itemlist) >> 4), 1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13790: using guessed type _DWORD __cdecl RegisterItem(_DWORD, _DWORD);
// 13AB0: using guessed type _DWORD __cdecl BG_FindItem(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000601AE) --------------------------------------------------------
int sub_601AE()
{
  char *s2; // [esp+10h] [ebp-8h]

  if ( !level[7] )
    Scr_Error("precacheShader must be called before any wait statements in the gametype or level script\n");
  s2 = (char *)Scr_GetString(0);
  if ( !*s2 )
    Scr_ParamError(0, "Shader name string is empty");
  return G_ShaderIndex(s2);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (00060218) --------------------------------------------------------
char *sub_60218()
{
  char *result; // eax

  if ( !level[7] )
    Scr_Error("precacheString must be called before any wait statements in the gametype or level script\n");
  result = (char *)Scr_GetIString(0);
  if ( *result )
    result = (char *)G_LocalizedStringIndex(result);
  return result;
}
// 13240: using guessed type _DWORD __cdecl Scr_GetIString(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0006026C) --------------------------------------------------------
int sub_6026C()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  int v4; // eax
  float v5; // [esp+0h] [ebp-28h]
  char v6; // [esp+4h] [ebp-24h]
  int v7; // [esp+18h] [ebp-10h]
  _BYTE *v8; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]

  v9 = 0;
  v7 = Scr_GetNumParam();
  if ( v7 != 1 )
  {
    if ( v7 != 2 )
    {
      v0 = va("USAGE: ambientPlay(alias_name, <fadetime>);\n", v6);
      return Scr_Error(v0);
    }
    v5 = Scr_GetFloat(1) * 1000.0;
    v9 = sub_62F9D(v5);
  }
  v8 = (_BYTE *)Scr_GetString(0);
  if ( !*v8 )
  {
    v2 = va("ambientPlay: alias name cannot be the empty string... use stop or fade version\n", v6);
    Scr_Error(v2);
  }
  if ( v9 < 0 )
  {
    v3 = va("ambientPlay: fade time must be >= 0\n", v6);
    Scr_Error(v3);
  }
  v4 = va("n\\%s\\t\\%i", (char)v8);
  return trap_SetConfigstring(3, v4);
}
// 602DD: variable 'v6' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00060364) --------------------------------------------------------
int sub_60364()
{
  int v0; // eax
  int v2; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-18h]
  char v5; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  v6 = Scr_GetNumParam();
  if ( v6 )
  {
    if ( v6 != 1 )
    {
      v0 = va("USAGE: ambientStop(<fadetime>);\n", v5);
      return Scr_Error(v0);
    }
    v4 = Scr_GetFloat(0) * 1000.0;
    v7 = sub_62F9D(v4);
  }
  else
  {
    v7 = 0;
  }
  if ( v7 < 0 )
  {
    v2 = va("ambientStop: fade time must be >= 0\n", v5);
    Scr_Error(v2);
  }
  v3 = va("t\\%i", LOBYTE(level[122]) + v7);
  return trap_SetConfigstring(3, v3);
}
// 603BF: variable 'v5' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00060421) --------------------------------------------------------
int sub_60421()
{
  char v1[28]; // [esp+20h] [ebp-88h] BYREF
  int v2; // [esp+3Ch] [ebp-6Ch]
  int v3; // [esp+5Ch] [ebp-4Ch]
  int v4[4]; // [esp+60h] [ebp-48h] BYREF
  int v5; // [esp+70h] [ebp-38h] BYREF
  int v6; // [esp+74h] [ebp-34h]
  float v7; // [esp+78h] [ebp-30h]
  int v8[4]; // [esp+80h] [ebp-28h] BYREF
  int v9[6]; // [esp+90h] [ebp-18h] BYREF

  Scr_GetVector(0, v9);
  v5 = v9[0];
  v6 = v9[1];
  v7 = *(float *)&v9[2] + 1.0;
  v3 = G_TempEntity(&v5, 178);
  v8[0] = 0;
  v8[1] = 0;
  v8[2] = 1065353216;
  *(_DWORD *)(v3 + 160) = (unsigned __int8)DirToByte(v8);
  v4[0] = v5;
  v4[1] = v6;
  *(float *)&v4[2] = v7 - 17.0;
  trap_Trace(v1, &v5, vec3_origin, vec3_origin, v4, 1023, 17);
  *(_DWORD *)(v3 + 136) = (v2 & 0x1F00000) >> 20;
  return Concussive_fx(&v5);
}
// 131D0: using guessed type _DWORD __cdecl Concussive_fx(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00060538) --------------------------------------------------------
_DWORD *sub_60538()
{
  _DWORD *result; // eax
  float v1; // [esp+24h] [ebp-24h]
  float v2; // [esp+28h] [ebp-20h]
  float v3; // [esp+2Ch] [ebp-1Ch]
  int v4[6]; // [esp+30h] [ebp-18h] BYREF

  Scr_GetVector(0, v4);
  v3 = Scr_GetFloat(1);
  v2 = Scr_GetFloat(2);
  v1 = Scr_GetFloat(3);
  level[2950] = level[2951];
  G_RadiusDamage((int)v4, 0, (int)&dword_C69C8 + (_DWORD)g_entities, v2, v1, v3, 0, 24);
  result = level;
  level[2950] = 0;
  return result;
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// C69C8: using guessed type int dword_C69C8;

//----- (00060600) --------------------------------------------------------
int sub_60600()
{
  int result; // eax

  result = Scr_GetBool(0);
  level[2951] = result;
  return result;
}
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);

//----- (00060632) --------------------------------------------------------
int sub_60632()
{
  int v1; // [esp+24h] [ebp-34h]
  float v2; // [esp+28h] [ebp-30h]
  float v3; // [esp+2Ch] [ebp-2Ch]
  char v4[16]; // [esp+30h] [ebp-28h] BYREF
  char v5[12]; // [esp+40h] [ebp-18h] BYREF
  int v6; // [esp+4Ch] [ebp-Ch] BYREF

  v3 = 0.0;
  v2 = 1.0;
  v1 = Scr_GetNumParam();
  if ( v1 != 1 )
  {
    if ( v1 != 2 )
    {
      v2 = Scr_GetFloat(2);
      if ( v2 < 0.0 || v2 > 1.0 )
        Scr_ParamError(2, "end time must be between 0 and 1");
    }
    v3 = Scr_GetFloat(1);
    if ( v3 < 0.0 || v3 > 1.0 )
      Scr_ParamError(1, "start time must be between 0 and 1");
  }
  Scr_GetAnim(&v6);
  trap_XAnimGetRelDelta(v6, v5, v4, LODWORD(v3), LODWORD(v2));
  return Scr_AddVector(v4);
}
// 134C0: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14ED0: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00060751) --------------------------------------------------------
int sub_60751()
{
  float v1; // [esp+0h] [ebp-58h]
  int v2; // [esp+24h] [ebp-34h]
  float v3; // [esp+28h] [ebp-30h]
  float v4; // [esp+2Ch] [ebp-2Ch]
  char v5[16]; // [esp+30h] [ebp-28h] BYREF
  char v6[12]; // [esp+40h] [ebp-18h] BYREF
  int v7; // [esp+4Ch] [ebp-Ch] BYREF

  v4 = 0.0;
  v3 = 1.0;
  v2 = Scr_GetNumParam();
  if ( v2 != 1 )
  {
    if ( v2 != 2 )
    {
      v3 = Scr_GetFloat(2);
      if ( v3 < 0.0 || v3 > 1.0 )
        Scr_ParamError(2, "end time must be between 0 and 1");
    }
    v4 = Scr_GetFloat(1);
    if ( v4 < 0.0 || v4 > 1.0 )
      Scr_ParamError(1, "start time must be between 0 and 1");
  }
  Scr_GetAnim(&v7);
  trap_XAnimGetRelDelta(v7, v6, v5, LODWORD(v4), LODWORD(v3));
  v1 = RotationToYaw(v6);
  return Scr_AddFloat(LODWORD(v1));
}
// 134C0: using guessed type _DWORD __cdecl trap_XAnimGetRelDelta(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14ED0: using guessed type _DWORD __stdcall Scr_GetAnim(_DWORD);
// 15280: using guessed type double __cdecl RotationToYaw(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00060878) --------------------------------------------------------
int sub_60878()
{
  char *s2; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  s2 = (char *)Scr_GetString(0);
  v2 = G_EffectIndex(s2);
  if ( !v2 && !level[7] )
    Scr_Error(
      "loadFx must be called before any wait statements in the gametype or level script, or on an already loaded effect\n");
  return Scr_AddInt(v2);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000608D8) --------------------------------------------------------
int sub_608D8()
{
  int v0; // eax
  int v1; // esi
  int result; // eax
  char dest[1024]; // [esp+10h] [ebp-438h] BYREF
  char v4[16]; // [esp+410h] [ebp-38h] BYREF
  char v5[24]; // [esp+420h] [ebp-28h] BYREF
  int v6; // [esp+438h] [ebp-10h]
  int v7; // [esp+43Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 1 || (unsigned int)Scr_GetNumParam() > 3 )
    Scr_Error("USAGE: playFx <effect id from loadFx> <vector position of effect> <optional forward vector>");
  v6 = Scr_GetInt(0);
  Scr_GetVector(1, v5);
  if ( Scr_GetNumParam() == 3 )
  {
    Scr_GetVector(2, v4);
    if ( VectorNormalize(v4) == 0.0 )
    {
      if ( v6 )
        trap_GetConfigstring(v6 + 780, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v0 = va("playFx called with (0 0 0) forward direction (effect = %s)\n", (char)dest);
      Scr_Error(v0);
    }
    v7 = G_TempEntity(v5, 192);
    *(_DWORD *)(v7 + 160) = (unsigned __int8)v6;
    v1 = v7;
    result = (unsigned __int8)DirToByte(v4);
    *(_DWORD *)(v1 + 216) = (unsigned __int8)result;
  }
  else
  {
    v7 = G_TempEntity(v5, 191);
    result = (unsigned __int8)v6;
    *(_DWORD *)(v7 + 160) = (unsigned __int8)v6;
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00060A3E) --------------------------------------------------------
int sub_60A3E()
{
  int v0; // eax
  int v1; // eax
  char *v2; // eax
  char *s; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  int v7; // [esp+20h] [ebp-8h]

  if ( Scr_GetNumParam() != 3 )
    Scr_Error("USAGE: playFxOnTag <effect id from loadFx> <entity> <tag name>");
  v7 = Scr_GetInt(0);
  if ( v7 <= 0 || v7 > 63 )
  {
    v0 = va("effect id %i is invalid\n", v7);
    Scr_ParamError(0, v0);
  }
  v5 = Scr_GetEntity(1);
  if ( !*(_BYTE *)(v5 + 377) )
    Scr_ParamError(1, "cannot play fx on entity with no model");
  s = (char *)Scr_GetString(2);
  if ( strchr(s, 34) )
    Scr_ParamError(2, "cannot use \" characters in tag names\n");
  if ( (int)trap_DObjGetBoneIndex(v5, s) < 0 )
  {
    trap_DObjDumpInfo(v5);
    G_ModelName(*(unsigned __int8 *)(v5 + 377));
    v1 = va("tag '%s' does not exist on entity with model '%s'", (char)s);
    Scr_ParamError(2, v1);
  }
  v2 = (char *)va("%02d%s", v7);
  v6 = G_FindConfigstringIndex(v2, 844, 256, 1, 0);
  return G_AddEvent(v5, 193, v6);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152A0: using guessed type _DWORD __cdecl trap_DObjDumpInfo(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (00060BDA) --------------------------------------------------------
int sub_60BDA()
{
  int v0; // eax
  float v2; // [esp+0h] [ebp-468h]
  int v3; // [esp+1Ch] [ebp-44Ch]
  char dest[1032]; // [esp+20h] [ebp-448h] BYREF
  int v5; // [esp+428h] [ebp-40h]
  float v6; // [esp+42Ch] [ebp-3Ch]
  int v7; // [esp+430h] [ebp-38h] BYREF
  int v8; // [esp+434h] [ebp-34h]
  int v9; // [esp+438h] [ebp-30h]
  char v10[24]; // [esp+440h] [ebp-28h] BYREF
  int v11; // [esp+458h] [ebp-10h]
  int v12; // [esp+45Ch] [ebp-Ch]

  if ( (unsigned int)Scr_GetNumParam() <= 2 || (unsigned int)Scr_GetNumParam() > 5 )
    Scr_Error(
      "USAGE: playLoopedFx <effect id from loadFx> <repeat delay> <vector position of effect> <optional cull distance (0 "
      "= never cull)> <optional forward vector>");
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0.0;
  v11 = Scr_GetInt(0);
  v3 = Scr_GetNumParam();
  if ( v3 == 4 )
    goto LABEL_11;
  if ( v3 == 5 )
  {
    Scr_GetVector(4, &v7);
    if ( VectorNormalize(&v7) == 0.0 )
    {
      if ( v11 )
        trap_GetConfigstring(v11 + 780, dest, 1024);
      else
        strcpy(dest, "not successfully loaded");
      v0 = va("playLoopedFx called with (0 0 0) forward direction (effect = %s)\n", (char)dest);
      Scr_Error(v0);
    }
LABEL_11:
    v6 = Scr_GetFloat(3);
  }
  Scr_GetVector(2, v10);
  v2 = Scr_GetFloat(1) * 1000.0;
  v5 = sub_62F9D(v2);
  v12 = G_Spawn();
  *(_DWORD *)(v12 + 4) = 10;
  *(_DWORD *)(v12 + 244) |= 8u;
  *(_DWORD *)(v12 + 216) = (unsigned __int8)v11;
  G_SetOrigin(v12, v10);
  *(_DWORD *)(v12 + 92) = v7;
  *(_DWORD *)(v12 + 96) = v8;
  *(_DWORD *)(v12 + 100) = v9;
  *(float *)(v12 + 104) = v6;
  *(float *)(v12 + 108) = (float)v5;
  trap_LinkEntity(v12);
  return Scr_AddEntity(v12);
}
// 12E70: using guessed type int G_Spawn(void);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00060DC4) --------------------------------------------------------
int __cdecl sub_60DC4(char a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  char *v12; // eax
  double v14; // [esp+4h] [ebp-44h]

  if ( a2 < 0.0 )
  {
    v8 = va("%s: near distance must be >= 0", a1);
    Scr_Error(v8);
  }
  if ( a2 >= (long double)a3 )
  {
    v9 = va("%s: near distance must be less than far distance", a1);
    Scr_Error(v9);
  }
  if ( a5 < 0.0 || a5 > 1.0 || a6 < 0.0 || a6 > 1.0 || a7 < 0.0 || a7 > 1.0 )
  {
    v10 = va("%s: red/green/blue color components must be in the range [0, 1]", a1);
    Scr_Error(v10);
  }
  if ( a8 < 0.0 )
  {
    v11 = va("%s: transition time must be >= 0 seconds", a1);
    Scr_Error(v11);
  }
  v14 = a2;
  v12 = (char *)va("%g %g %g %g %g %g %.0f", SLOBYTE(v14));
  return G_setfog(v12);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00060F3A) --------------------------------------------------------
int sub_60F3A()
{
  float v1; // [esp+2Ch] [ebp-1Ch]
  float v2; // [esp+30h] [ebp-18h]
  float v3; // [esp+34h] [ebp-14h]
  float v4; // [esp+38h] [ebp-10h]
  float v5; // [esp+3Ch] [ebp-Ch]
  float v6; // [esp+40h] [ebp-8h]

  if ( Scr_GetNumParam() != 6 )
    Scr_Error("USAGE: setCullFog(near distance, far distance, red, green, blue, transition time);\n");
  v6 = Scr_GetFloat(0);
  v5 = Scr_GetFloat(1);
  v4 = Scr_GetFloat(2);
  v3 = Scr_GetFloat(3);
  v2 = Scr_GetFloat(4);
  v1 = Scr_GetFloat(5);
  return sub_60DC4(
           (unsigned __int8)&aSetcullfog[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_,
           v6,
           v5,
           1.0,
           v4,
           v3,
           v2,
           v1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00061004) --------------------------------------------------------
int sub_61004()
{
  float v1; // [esp+20h] [ebp-18h]
  float v2; // [esp+24h] [ebp-14h]
  float v3; // [esp+28h] [ebp-10h]
  float v4; // [esp+2Ch] [ebp-Ch]
  float v5; // [esp+30h] [ebp-8h]

  if ( Scr_GetNumParam() != 5 )
    Scr_Error(
      "USAGE: setExpFog(density, red, green, blue, transition time);\n"
      "Density must be greater than 0 and less than 1, and typically less than .001.  For example, .0002 means the fog ge"
      "ts .02%% more dense for every 1 unit of distance (about 1%% thicker every 50 units of distance)\n");
  v5 = Scr_GetFloat(0);
  v4 = Scr_GetFloat(1);
  v3 = Scr_GetFloat(2);
  v2 = Scr_GetFloat(3);
  v1 = Scr_GetFloat(4);
  if ( v5 <= 0.0 || v5 >= 1.0 )
    Scr_Error("setExpFog: distance must be greater than 0 and less than 1");
  return sub_60DC4(
           (unsigned __int8)&aSetexpfog[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_,
           0.0,
           1.0,
           v5,
           v4,
           v3,
           v2,
           v1);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (000610F2) --------------------------------------------------------
int sub_610F2()
{
  int result; // eax

  if ( Scr_GetType(0) == 7 && Scr_GetPointerType(0) == 13 && *(_DWORD *)(Scr_GetEntity(0) + 348) )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143F0: using guessed type _DWORD __cdecl Scr_GetPointerType(_DWORD);

//----- (00061161) --------------------------------------------------------
int sub_61161()
{
  int result; // eax
  int v1; // [esp+10h] [ebp-8h]

  v1 = Scr_GetInt(0);
  if ( v1 >= 0 && v1 <= 63 )
    result = Scr_AddInt(1);
  else
    result = Scr_AddInt(0);
  return result;
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (000611B0) --------------------------------------------------------
int sub_611B0()
{
  int v0; // eax
  int result; // eax
  char s[1032]; // [esp+20h] [ebp-418h] BYREF
  int v3; // [esp+428h] [ebp-10h]
  char v4[4]; // [esp+42Ch] [ebp-Ch]

  *(_DWORD *)v4 = *(_DWORD *)Scr_GetEntity(0) + 1;
  trap_GetConfigstring(20, s, 1024);
  v3 = va("%i", v4[0]);
  v0 = Info_ValueForKey(s, (int)"winner");
  result = Q_stricmp(v0, v3);
  if ( result )
  {
    Info_SetValueForKey(s, "winner", v3);
    result = trap_SetConfigstring(20, s);
  }
  return result;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00061286) --------------------------------------------------------
int sub_61286()
{
  char v0; // al
  int v1; // eax
  int result; // eax
  int v3; // eax
  char s[1028]; // [esp+10h] [ebp-418h] BYREF
  int v5; // [esp+414h] [ebp-14h]
  char v6[4]; // [esp+418h] [ebp-10h]
  unsigned __int16 v7; // [esp+41Eh] [ebp-Ah]

  v7 = Scr_GetConstString(0);
  if ( v7 == scr_const[2] )
  {
    *(_DWORD *)v6 = -2;
  }
  else if ( v7 == scr_const[4] )
  {
    *(_DWORD *)v6 = -1;
  }
  else
  {
    if ( v7 != scr_const[124] )
    {
      v0 = SL_ConvertToString(v7);
      v1 = va("Illegal team string '%s'. Must be allies, axis, or none.", v0);
      return Scr_ParamError(0, v1);
    }
    *(_DWORD *)v6 = 0;
  }
  trap_GetConfigstring(20, s, 1024);
  v5 = va("%i", v6[0]);
  v3 = Info_ValueForKey(s, (int)"winner");
  result = Q_stricmp(v3, v5);
  if ( result )
  {
    Info_SetValueForKey(s, "winner", v5);
    result = trap_SetConfigstring(20, s);
  }
  return result;
}
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000613CF) --------------------------------------------------------
int sub_613CF()
{
  int v0; // eax
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  Scr_ConstructMessageString(0, v2, 1024, 3);
  v0 = va("c \"%s\" 2", (char)v2);
  return trap_SendServerCommand(-1, 0, v0);
}
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (00061443) --------------------------------------------------------
int sub_61443()
{
  int v0; // eax
  char v2[1036]; // [esp+10h] [ebp-418h] BYREF
  _DWORD *v3; // [esp+41Ch] [ebp-Ch]

  v3 = (_DWORD *)Scr_GetEntity(0);
  Scr_ConstructMessageString(1, v2, 1024, 3);
  v0 = va("c \"%s\" 2", (char)v2);
  return trap_SendServerCommand(*v3, 0, v0);
}
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);

//----- (000614C7) --------------------------------------------------------
int sub_614C7()
{
  char v0; // al
  int v1; // eax
  int result; // eax
  unsigned __int16 v3; // [esp+12h] [ebp-6h]

  v3 = Scr_GetConstString(0);
  if ( v3 != scr_const[2] && v3 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v3);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  if ( v3 == scr_const[2] )
    result = Scr_AddInt(level[128]);
  else
    result = Scr_AddInt(level[127]);
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00061570) --------------------------------------------------------
_DWORD *sub_61570()
{
  char v0; // al
  int v1; // eax
  int v2; // eax
  int v3; // eax
  _DWORD *result; // eax
  int v5; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v6; // [esp+12h] [ebp-6h]

  v6 = Scr_GetConstString(0);
  if ( v6 != scr_const[2] && v6 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v6);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  v5 = Scr_GetInt(1);
  if ( v6 == scr_const[2] )
  {
    level[128] = v5;
    v2 = va("%i", level[128]);
    trap_SetConfigstring(6, v2);
  }
  else
  {
    level[127] = v5;
    v3 = va("%i", level[127]);
    trap_SetConfigstring(5, v3);
  }
  result = level;
  level[131] = 1;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00061689) --------------------------------------------------------
_DWORD *sub_61689()
{
  _DWORD *result; // eax
  __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_GetConstString(0);
  if ( v1 == scr_const[126] )
  {
    result = level;
    level[132] = 0;
  }
  else if ( v1 == scr_const[127] )
  {
    result = level;
    level[132] = 1;
  }
  else
  {
    result = (_DWORD *)Scr_Error("Unknown mode");
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00061709) --------------------------------------------------------
int sub_61709()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-3Ch]
  char dest[44]; // [esp+20h] [ebp-38h] BYREF
  int i; // [esp+4Ch] [ebp-Ch]

  if ( !level[132] )
    Scr_Error("Only works in [manual_change] mode");
  v1 = 0;
  for ( i = level[0]; ; i += 8908 )
  {
    result = v1;
    if ( v1 >= level[120] )
      break;
    if ( *(_DWORD *)(i + 8424) == 2 )
    {
      if ( strcmp((const char *)(i + 8636), (const char *)(i + 8488)) )
      {
        Q_strncpyz(dest, (char *)(i + 8636), 32);
        Q_strncpyz((char *)(i + 8636), (char *)(i + 8488), 32);
        ClientUserinfoChanged(v1);
      }
    }
    ++v1;
  }
  return result;
}
// 12FA0: using guessed type _DWORD __cdecl ClientUserinfoChanged(_DWORD);
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (000617F7) --------------------------------------------------------
int sub_617F7()
{
  char v0; // al
  int v1; // eax
  _DWORD *v3; // [esp+10h] [ebp-18h]
  int i; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]
  int v6; // [esp+1Ch] [ebp-Ch]
  unsigned __int16 v7; // [esp+22h] [ebp-6h]

  v7 = Scr_GetConstString(0);
  if ( v7 != scr_const[2] && v7 != scr_const[4] )
  {
    v0 = SL_ConvertToString(v7);
    v1 = va("Illegal team string '%s'. Must be allies, or axis.", v0);
    Scr_Error(v1);
  }
  if ( v7 == scr_const[2] )
    v5 = 2;
  else
    v5 = 1;
  v6 = 0;
  for ( i = 0; i < g_maxclients[3]; ++i )
  {
    v3 = &g_entities[199 * i];
    if ( *((_BYTE *)v3 + 356) && *(_DWORD *)(v3[87] + 8580) == v5 && (int)v3[142] > 0 )
      ++v6;
  }
  return Scr_AddInt(v6);
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (000618FC) --------------------------------------------------------
int GScr_GetNumParts()
{
  int v0; // eax
  int v1; // eax
  int v3; // [esp+10h] [ebp-8h]

  v0 = Scr_GetString(0);
  v3 = trap_XModelGet(v0);
  v1 = trap_XModelNumBones(v3);
  return Scr_AddInt(v1);
}
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14990: using guessed type _DWORD __cdecl trap_XModelNumBones(_DWORD);
// 14A70: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (0006193E) --------------------------------------------------------
int GScr_GetPartName()
{
  int v0; // eax
  int v1; // eax
  unsigned __int16 v3; // [esp+16h] [ebp-12h]
  unsigned int v4; // [esp+18h] [ebp-10h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]
  int v6; // [esp+20h] [ebp-8h]

  v0 = Scr_GetString(0);
  v6 = trap_XModelGet(v0);
  v5 = Scr_GetInt(1);
  v4 = trap_XModelNumBones(v6);
  if ( v5 >= v4 )
  {
    v1 = va("index out of range (0 - %d)", v4 - 1);
    Scr_ParamError(1, v1);
  }
  v3 = *(_WORD *)(trap_XModelGetBoneNames(v6) + 2 * v5);
  if ( !v3 )
    Scr_ParamError(0, "bad model");
  return Scr_AddConstString(v3);
}
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 14990: using guessed type _DWORD __cdecl trap_XModelNumBones(_DWORD);
// 14A70: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 156F0: using guessed type _DWORD __cdecl trap_XModelGetBoneNames(_DWORD);

//----- (000619F9) --------------------------------------------------------
int sub_619F9()
{
  int result; // eax
  float v1; // [esp+0h] [ebp-48h]
  float v2; // [esp+1Ch] [ebp-2Ch]
  char v3[20]; // [esp+20h] [ebp-28h] BYREF
  int v4; // [esp+34h] [ebp-14h]
  float v5; // [esp+38h] [ebp-10h]
  int v6; // [esp+3Ch] [ebp-Ch]

  v5 = Scr_GetFloat(0);
  v1 = Scr_GetFloat(1) * 1000.0;
  v4 = sub_62F9D(v1);
  Scr_GetVector(2, v3);
  v2 = Scr_GetFloat(3);
  v6 = G_TempEntity(v3, 195);
  *(float *)(v6 + 104) = v5;
  *(_DWORD *)(v6 + 84) = v4;
  result = LODWORD(v2);
  *(float *)(v6 + 108) = v2;
  return result;
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (00061A92) --------------------------------------------------------
int __cdecl sub_61A92(unsigned int a1)
{
  int v1; // eax
  int result; // eax
  int v3; // eax
  float v4; // [esp+0h] [ebp-428h]
  double v5; // [esp+4h] [ebp-424h]
  char s1[1024]; // [esp+10h] [ebp-418h] BYREF
  char *s2; // [esp+410h] [ebp-18h]
  int v8; // [esp+414h] [ebp-14h]
  int i; // [esp+418h] [ebp-10h]
  _DWORD *v10; // [esp+41Ch] [ebp-Ch]

  v10 = sub_5B8E6(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error("USAGE: <player> shellshock(<shellshockname>, <duration>)\n");
  s2 = (char *)Scr_GetString(0);
  for ( i = 1; ; ++i )
  {
    if ( i > 15 )
    {
      v3 = va("shellshock '%s' was not precached\n", (char)s2);
      return Scr_Error(v3);
    }
    trap_GetConfigstring(i + 1100, s1, 1024);
    if ( !strcasecmp(s1, s2) )
      break;
  }
  v4 = Scr_GetFloat(1) * 1000.0;
  v8 = sub_62F9D(v4);
  if ( v8 < 0 || v8 > 60000 )
  {
    v5 = (long double)v8 * 0.001;
    v1 = va("duration %g should be >= 0 and <= 60", SLOBYTE(v5));
    Scr_ParamError(1, v1);
  }
  *(_DWORD *)(v10[87] + 988) = i;
  *(_DWORD *)(v10[87] + 992) = level[122];
  result = v8;
  *(_DWORD *)(v10[87] + 996) = v8;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 133E0: using guessed type _DWORD __cdecl trap_GetConfigstring(_DWORD, _DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00061BFB) --------------------------------------------------------
int __cdecl sub_61BFB(unsigned int a1)
{
  int result; // eax
  _DWORD *v2; // [esp+10h] [ebp-8h]

  v2 = sub_5B8E6(a1);
  if ( Scr_GetNumParam() )
    Scr_Error("USAGE: <player> stopshellshock()\n");
  *(_DWORD *)(v2[87] + 988) = 0;
  *(_DWORD *)(v2[87] + 992) = 0;
  result = v2[87];
  *(_DWORD *)(result + 996) = 0;
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00061C71) --------------------------------------------------------
int __cdecl sub_61C71(unsigned int a1)
{
  int v1; // esi
  int v2; // eax
  int result; // eax
  double v4; // [esp+4h] [ebp-34h]
  float v5[7]; // [esp+10h] [ebp-28h] BYREF
  _DWORD *v6; // [esp+2Ch] [ebp-Ch]

  v6 = sub_5B8E6(a1);
  if ( Scr_GetNumParam() != 2 )
    Scr_Error("USAGE: <player> viewkick <force 0-127> <source position>\n");
  v1 = v6[87];
  *(_DWORD *)(v1 + 8732) = (v6[143] * Scr_GetInt(0) + 50) / 100;
  if ( *(int *)(v6[87] + 8732) < 0 )
  {
    v4 = Scr_GetFloat(0);
    v2 = va("viewkick: damage %g < 0\n", SLOBYTE(v4));
    Scr_Error(v2);
  }
  Scr_GetVector(1, v5);
  *(float *)(v6[87] + 8736) = *(float *)(v6[87] + 20) - v5[0];
  *(float *)(v6[87] + 8740) = *(float *)(v6[87] + 24) - v5[1];
  result = v6[87];
  *(float *)(result + 8744) = *(float *)(result + 28) - v5[2];
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00061D95) --------------------------------------------------------
int __cdecl sub_61D95(unsigned int a1)
{
  char v2[48]; // [esp+10h] [ebp-68h] BYREF
  float v3; // [esp+40h] [ebp-38h] BYREF
  float v4; // [esp+44h] [ebp-34h]
  float v5; // [esp+48h] [ebp-30h]
  char v6[28]; // [esp+50h] [ebp-28h] BYREF
  float *v7; // [esp+6Ch] [ebp-Ch]

  v7 = (float *)sub_5B894(a1);
  Scr_GetVector(0, v6);
  AnglesToAxis(v7 + 81, v2);
  MatrixTransformVector(v6, v2, &v3);
  v3 = v3 + v7[78];
  v4 = v4 + v7[79];
  v5 = v5 + v7[80];
  return Scr_AddVector(&v3);
}
// 13AE0: using guessed type _DWORD __cdecl MatrixTransformVector(_DWORD, _DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (00061E36) --------------------------------------------------------
void __cdecl sub_61E36(unsigned int a1)
{
  float v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = sub_5B894(a1)[88];
  if ( !v2 )
    Scr_Error("entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 16) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 16) > 0.0 )
    *(_DWORD *)(v2 + 16) = 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00061EBC) --------------------------------------------------------
void __cdecl sub_61EBC(unsigned int a1)
{
  int v1; // [esp+8h] [ebp-10h]

  v1 = sub_5B894(a1)[88];
  if ( !v1 )
    Scr_Error("entity is not a turret");
  *(float *)(v1 + 24) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 24) < 0.0 )
    *(_DWORD *)(v1 + 24) = 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00061F35) --------------------------------------------------------
void __cdecl sub_61F35(unsigned int a1)
{
  float v1; // [esp+4h] [ebp-14h]
  int v2; // [esp+8h] [ebp-10h]

  v2 = sub_5B894(a1)[88];
  if ( !v2 )
    Scr_Error("entity is not a turret");
  v1 = Scr_GetFloat(0);
  *(_DWORD *)(v2 + 12) = LODWORD(v1) ^ 0x80000000;
  if ( *(float *)(v2 + 12) > 0.0 )
    *(_DWORD *)(v2 + 12) = 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00061FBB) --------------------------------------------------------
void __cdecl sub_61FBB(unsigned int a1)
{
  int v1; // [esp+8h] [ebp-10h]

  v1 = sub_5B894(a1)[88];
  if ( !v1 )
    Scr_Error("entity is not a turret");
  *(float *)(v1 + 20) = Scr_GetFloat(0);
  if ( *(float *)(v1 + 20) < 0.0 )
    *(_DWORD *)(v1 + 20) = 0;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00062034) --------------------------------------------------------
int __cdecl sub_62034(unsigned int a1)
{
  int v2; // [esp+30h] [ebp-68h] BYREF
  int v3; // [esp+34h] [ebp-64h]
  float v4; // [esp+38h] [ebp-60h]
  int v5; // [esp+40h] [ebp-58h] BYREF
  int v6; // [esp+44h] [ebp-54h]
  float v7; // [esp+48h] [ebp-50h]
  char v8[4]; // [esp+50h] [ebp-48h] BYREF
  int v9; // [esp+54h] [ebp-44h] BYREF
  int v10; // [esp+58h] [ebp-40h]
  float v11; // [esp+5Ch] [ebp-3Ch]
  unsigned __int16 v12; // [esp+78h] [ebp-20h]
  char v13; // [esp+7Eh] [ebp-1Ah]
  float *v14; // [esp+8Ch] [ebp-Ch]

  v14 = (float *)sub_5B894(a1);
  v5 = *((_DWORD *)v14 + 78);
  v6 = *((_DWORD *)v14 + 79);
  v7 = v14[80];
  v2 = *((_DWORD *)v14 + 78);
  v3 = *((_DWORD *)v14 + 79);
  v4 = v14[80];
  v4 = v4 + 128.0;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v2, *(_DWORD *)v14, 42008593);
  v5 = v9;
  v6 = v10;
  v7 = v11;
  v2 = v9;
  v3 = v10;
  v4 = v11 - 262144.0;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v2, *(_DWORD *)v14, 42008593);
  *((_DWORD *)v14 + 31) = v12;
  v5 = v9;
  v6 = v10;
  v7 = v11;
  trap_TraceCapsule(v8, &v5, playerMins, playerMaxs, &v5, *(_DWORD *)v14, 42008593);
  if ( v13 )
    Com_Printf("WARNING: Spawn point entity %i is in solid at (%i, %i, %i)\n", *(_DWORD *)v14);
  return G_SetOrigin(v14, &v9);
}
// 15670: using guessed type _DWORD __cdecl trap_TraceCapsule(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00062238) --------------------------------------------------------
int sub_62238()
{
  if ( level[2949] )
  {
    if ( level[2949] == 1 )
      Scr_Error("map_restart already called");
    else
      Scr_Error("exitlevel already called");
  }
  level[2949] = 1;
  level[2141] = 0;
  if ( Scr_GetNumParam() )
    level[2141] = Scr_GetInt(0);
  return trap_SendConsoleCommand(2, "map_restart\n");
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 149C0: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (000622E6) --------------------------------------------------------
int sub_622E6()
{
  if ( level[2949] )
  {
    if ( level[2949] == 1 )
      Scr_Error("map_restart already called");
    else
      Scr_Error("exitlevel already called");
  }
  level[2949] = 2;
  level[2141] = 0;
  if ( Scr_GetNumParam() )
    level[2141] = Scr_GetInt(0);
  return ExitLevel();
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 135B0: using guessed type int ExitLevel(void);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (00062383) --------------------------------------------------------
int sub_62383()
{
  int result; // eax

  result = trap_AddTestClient();
  if ( result )
    result = Scr_AddEntity(result);
  return result;
}
// 13750: using guessed type int trap_AddTestClient(void);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (000623B4) --------------------------------------------------------
int sub_623B4()
{
  size_t v0; // eax
  char *s; // [esp+18h] [ebp-820h]
  int v3; // [esp+1Ch] [ebp-81Ch]
  char v4[1024]; // [esp+20h] [ebp-818h] BYREF
  char v5[1024]; // [esp+420h] [ebp-418h] BYREF
  char *v6; // [esp+820h] [ebp-18h]
  int v7; // [esp+824h] [ebp-14h]
  size_t v8; // [esp+828h] [ebp-10h]
  int v9; // [esp+82Ch] [ebp-Ch]

  v3 = Scr_GetString(0);
  v7 = Scr_GetType(1);
  if ( v7 == 2 )
  {
    Scr_ConstructMessageString(1, v5, 1024, 1);
    s = v5;
    v0 = strlen(v5);
  }
  else
  {
    s = (char *)Scr_GetString(1);
    v0 = strlen(s);
  }
  v8 = v0;
  v6 = v4;
  memset(v4, 0, sizeof(v4));
  v9 = 0;
  while ( v9 <= 0x1FFF && s[v9] )
  {
    *v6 = Q_CleanCharacter(s[v9]);
    if ( *v6 == 34 )
      *v6 = 39;
    ++v9;
    ++v6;
  }
  return trap_Cvar_Register(0, v3, s, 2048);
}
// 13700: using guessed type _DWORD __cdecl Q_CleanCharacter(_DWORD);
// 13730: using guessed type _DWORD __cdecl Scr_ConstructMessageString(_DWORD, _DWORD, _DWORD, _DWORD);
// 137B0: using guessed type _DWORD __cdecl Scr_GetType(_DWORD);
// 14D90: using guessed type _DWORD __cdecl trap_Cvar_Register(_DWORD, _DWORD, _DWORD, _DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);

//----- (000624F4) --------------------------------------------------------
int sub_624F4()
{
  int v0; // eax

  v0 = Scr_GetBool(0);
  return trap_SetArchive(v0);
}
// 142B0: using guessed type _DWORD __cdecl Scr_GetBool(_DWORD);
// 14D50: using guessed type _DWORD __cdecl trap_SetArchive(_DWORD);

//----- (00062520) --------------------------------------------------------
void Scr_Prof_Begin()
{
  ;
}

//----- (00062525) --------------------------------------------------------
void Scr_Prof_End()
{
  ;
}

//----- (0006252A) --------------------------------------------------------
char *__cdecl Scr_GetFunction(char **a1, _DWORD *a2)
{
  char *s1; // [esp+18h] [ebp-10h]
  unsigned int i; // [esp+1Ch] [ebp-Ch]

  s1 = *a1;
  for ( i = 0; i <= 0x6D; ++i )
  {
    if ( !strcmp(s1, (&functions)[3 * i]) )
    {
      *a1 = (&functions)[3 * i];
      *a2 = (&functions)[3 * i + 2];
      return (&functions)[3 * i + 1];
    }
  }
  return 0;
}
// 83C40: using guessed type char *functions;

//----- (000625EA) --------------------------------------------------------
int __cdecl sub_625EA(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0x2B; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_84180 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_84180 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_84184 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 84180: using guessed type char *off_84180;
// 84184: using guessed type int (__cdecl *off_84184)(int);

//----- (00062665) --------------------------------------------------------
int __cdecl Scr_GetMethod(char **a1, _DWORD *a2)
{
  int v3; // [esp+Ch] [ebp-Ch]
  int v4; // [esp+Ch] [ebp-Ch]
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  *a2 = 0;
  v6 = Player_GetMethod(a1);
  v3 = ScriptEnt_GetMethod(a1);
  if ( !v6 )
    v6 = v3;
  v4 = sub_625EA(a1);
  if ( !v6 )
    v6 = v4;
  v5 = HudElem_GetMethod(a1);
  if ( !v6 )
    v6 = v5;
  return v6;
}
// 13B60: using guessed type _DWORD __cdecl HudElem_GetMethod(_DWORD);
// 151E0: using guessed type _DWORD __cdecl Player_GetMethod(_DWORD);
// 15750: using guessed type _DWORD __cdecl ScriptEnt_GetMethod(_DWORD);

//----- (000626E5) --------------------------------------------------------
int __cdecl Scr_SetOrigin(int a1)
{
  int result; // eax
  char v2[24]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  G_SetOrigin(a1, v2);
  result = a1;
  if ( *(_DWORD *)(a1 + 240) )
    result = trap_LinkEntity(a1);
  return result;
}
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00062739) --------------------------------------------------------
int __cdecl Scr_SetAngles(int a1)
{
  char v2[24]; // [esp+10h] [ebp-18h] BYREF

  Scr_GetVector(0, v2);
  return G_SetAngle(a1, v2);
}
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);

//----- (00062776) --------------------------------------------------------
int __cdecl Scr_SetHealth(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  v2 = Scr_GetInt(0);
  if ( a1[87] )
  {
    a1[142] = v2;
    result = v2;
    *(_DWORD *)(a1[87] + 244) = v2;
  }
  else
  {
    a1[143] = v2;
    result = v2;
    a1[142] = v2;
  }
  return result;
}
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);

//----- (000627E1) --------------------------------------------------------
int __cdecl GScr_AddVector(int a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddVector(a1);
  else
    result = Scr_AddUndefined();
  return result;
}
// 136F0: using guessed type int Scr_AddUndefined(void);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);

//----- (00062811) --------------------------------------------------------
int __cdecl GScr_AddEntity(int a1)
{
  int result; // eax

  if ( a1 )
    result = Scr_AddEntity(a1);
  else
    result = Scr_AddUndefined();
  return result;
}
// 136F0: using guessed type int Scr_AddUndefined(void);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (00062841) --------------------------------------------------------
int Scr_ParseGameTypeList()
{
  _DWORD *v0; // esi
  size_t v1; // eax
  int v2; // eax
  char v3; // al
  char v4; // al
  _BYTE **v5; // esi
  size_t v6; // eax
  int result; // eax
  int v8; // [esp+18h] [ebp-1430h] BYREF
  _BYTE **v9; // [esp+1Ch] [ebp-142Ch]
  char *src; // [esp+20h] [ebp-1428h]
  char *v11; // [esp+24h] [ebp-1424h] BYREF
  size_t v12; // [esp+28h] [ebp-1420h]
  int v13; // [esp+2Ch] [ebp-141Ch]
  int v14; // [esp+30h] [ebp-1418h]
  int v15; // [esp+34h] [ebp-1414h]
  int i; // [esp+38h] [ebp-1410h]
  char *s; // [esp+3Ch] [ebp-140Ch]
  char v18[1024]; // [esp+40h] [ebp-1408h] BYREF
  char v19[4104]; // [esp+440h] [ebp-1008h] BYREF

  v14 = 0;
  memset(&g_scr_data[18], 0, 0x180u);
  v13 = trap_FS_GetFileList("maps/mp/gametypes", "gsc", v19, 4096);
  s = v19;
  for ( i = 0; i < v13; ++i )
  {
    v9 = (_BYTE **)&g_scr_data[6 * v14 + 18];
    v12 = strlen(s);
    if ( *s == 95 )
    {
      s += v12 + 1;
    }
    else
    {
      if ( !Q_stricmp(&s[v12 - 4], ".gsc") )
        s[v12 - 4] = 0;
      if ( v14 == 32 )
      {
        G_Printf("Too many game type scripts found! Only loading the first %i\n", 31);
        break;
      }
      v0 = v9;
      v1 = strlen(s);
      *v0 = trap_Hunk_AllocLowInternal(v1);
      strcpy(*v9, s);
      sub_62FF3(*v9);
      v2 = va("maps/mp/gametypes/%s.txt", (char)s);
      v15 = trap_FS_FOpenFile(v2, &v8, 0);
      if ( v15 > 0 && v15 <= 1023 )
      {
        memset(v18, 0, sizeof(v18));
        trap_FS_Read(v18, v15, v8);
        v11 = v18;
        src = (char *)Com_Parse(&v11);
        v5 = v9;
        v6 = strlen(src);
        v5[1] = (_BYTE *)trap_Hunk_AllocLowInternal(v6);
        strcpy(v9[1], src);
        src = (char *)Com_Parse(&v11);
        v9[2] = (_BYTE *)(src && !Q_stricmp(src, "team"));
      }
      else
      {
        if ( v15 > 0 )
        {
          v4 = va("maps/mp/gametypes/%s.txt", (char)s);
          Com_Printf("WARNING: GameType description file %s is too big to load.\n", v4);
        }
        else
        {
          v3 = va("maps/mp/gametypes/%s.txt", (char)s);
          Com_Printf("WARNING: Could not load GameType description file %s for gametype %s\n", v3);
        }
        v9[1] = *v9;
        v9[2] = 0;
      }
      if ( v15 > 0 )
        trap_FS_FCloseFile(v8);
      ++v14;
      s += v12 + 1;
    }
  }
  result = v14;
  *(_DWORD *)&g_scr_data[16] = v14;
  return result;
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 13450: using guessed type _DWORD __cdecl trap_FS_FOpenFile(_DWORD, _DWORD, _DWORD);
// 13990: using guessed type _DWORD __cdecl trap_Hunk_AllocLowInternal(_DWORD);
// 13B90: using guessed type _DWORD __cdecl trap_FS_FCloseFile(_DWORD);
// 14880: using guessed type _DWORD __cdecl trap_FS_GetFileList(_DWORD, _DWORD, _DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 15960: using guessed type _DWORD __cdecl trap_FS_Read(_DWORD, _DWORD, _DWORD);

//----- (00062C03) --------------------------------------------------------
int __cdecl Scr_GetGameTypeNameForScript(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < *(_DWORD *)&g_scr_data[16]; ++i )
  {
    if ( !Q_stricmp(*(_DWORD *)&g_scr_data[6 * i + 18], a1) )
      return *(_DWORD *)&g_scr_data[6 * i + 20];
  }
  return 0;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (00062C8D) --------------------------------------------------------
_BOOL4 __cdecl Scr_IsValidGameType(int a1)
{
  return Scr_GetGameTypeNameForScript(a1) != 0;
}
// 14EA0: using guessed type _DWORD __cdecl Scr_GetGameTypeNameForScript(_DWORD);

//----- (00062CC7) --------------------------------------------------------
int Scr_LoadGameType()
{
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_ExecThread(*(_DWORD *)&g_scr_data[4], 0);
  return Scr_FreeThread(v1);
}
// 155D0: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (00062D08) --------------------------------------------------------
int Scr_StartupGameType()
{
  unsigned __int16 v1; // [esp+12h] [ebp-6h]

  v1 = Scr_ExecThread(*(_DWORD *)&g_scr_data[6], 0);
  return Scr_FreeThread(v1);
}
// 155D0: using guessed type _DWORD __cdecl Scr_ExecThread(_DWORD, _DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (00062D49) --------------------------------------------------------
int __cdecl Scr_PlayerConnect(int a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]

  v2 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[8], 0);
  return Scr_FreeThread(v2);
}
// 14660: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (00062D91) --------------------------------------------------------
int __cdecl Scr_PlayerDisconnect(int a1)
{
  unsigned __int16 v2; // [esp+12h] [ebp-6h]

  v2 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[10], 0);
  return Scr_FreeThread(v2);
}
// 14660: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);

//----- (00062DD9) --------------------------------------------------------
int __cdecl Scr_PlayerDamage(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  unsigned __int16 v10; // ax
  int v11; // eax
  unsigned __int16 v13; // [esp+12h] [ebp-6h]

  v10 = G_GetHitLocationString(a10);
  Scr_AddConstString(v10);
  GScr_AddVector(a9);
  GScr_AddVector(a8);
  v11 = BG_GetInfoForWeapon(a7);
  Scr_AddString(*(_DWORD *)(v11 + 4));
  if ( a6 >= 0 && (unsigned int)a6 <= 0x18 )
    Scr_AddString(modNames[a6]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a5);
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v13 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[12], 9);
  return Scr_FreeThread(v13);
}
// 13400: using guessed type _DWORD __cdecl GScr_AddVector(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 13FB0: using guessed type _DWORD __cdecl G_GetHitLocationString(_DWORD);
// 14660: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 14970: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);
// 82F00: using guessed type char *modNames[25];

//----- (00062EC1) --------------------------------------------------------
int __cdecl Scr_PlayerKilled(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  unsigned __int16 v8; // ax
  int v9; // eax
  unsigned __int16 v11; // [esp+12h] [ebp-6h]

  v8 = G_GetHitLocationString(a8);
  Scr_AddConstString(v8);
  GScr_AddVector(a7);
  v9 = BG_GetInfoForWeapon(a6);
  Scr_AddString(*(_DWORD *)(v9 + 4));
  if ( a5 >= 0 && (unsigned int)a5 <= 0x18 )
    Scr_AddString(modNames[a5]);
  else
    Scr_AddString("badMOD");
  Scr_AddInt(a4);
  GScr_AddEntity(a3);
  GScr_AddEntity(a2);
  v11 = Scr_ExecEntThread(a1, *(_DWORD *)&g_scr_data[14], 7);
  return Scr_FreeThread(v11);
}
// 13400: using guessed type _DWORD __cdecl GScr_AddVector(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 13FB0: using guessed type _DWORD __cdecl G_GetHitLocationString(_DWORD);
// 14660: using guessed type _DWORD __cdecl Scr_ExecEntThread(_DWORD, _DWORD, _DWORD);
// 14970: using guessed type _DWORD __cdecl GScr_AddEntity(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 158E0: using guessed type _DWORD __cdecl Scr_FreeThread(_DWORD);
// 82F00: using guessed type char *modNames[25];

//----- (00062F93) --------------------------------------------------------
int Scr_LoadRead()
{
  return 0;
}

//----- (00062F9D) --------------------------------------------------------
int __cdecl sub_62F9D(float a1)
{
  return (int)(a1 + 0.5);
}

//----- (00062FDB) --------------------------------------------------------
float *__cdecl sub_62FDB(float a1, float *a2, float *a3)
{
  float *result; // eax

  result = a2;
  *a3 = cos(a1);
  *a2 = sin(a1);
  return result;
}

//----- (00062FF3) --------------------------------------------------------
_BYTE *__cdecl sub_62FF3(_BYTE *a1)
{
  if ( !a1 )
    return 0;
  while ( *a1 )
  {
    *a1 = tolower((char)*a1);
    ++a1;
  }
  return a1;
}

//----- (00063047) --------------------------------------------------------
void sub_63047()
{
  ;
}

//----- (0006304C) --------------------------------------------------------
int __cdecl sub_6304C(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8)
{
  float v10; // [esp+20h] [ebp-28h] BYREF
  float v11; // [esp+24h] [ebp-24h]
  float v12; // [esp+28h] [ebp-20h]
  float v13; // [esp+3Ch] [ebp-Ch]

  if ( *(_DWORD *)a1 == 9 && a4 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    v10 = *(float *)a7 - *(float *)a6;
    v11 = *(float *)(a7 + 4) - *(float *)(a6 + 4);
    v12 = *(float *)(a7 + 8) - *(float *)(a6 + 8);
    v13 = 1000.0 / (long double)*(int *)(a1 + 8);
    *(float *)(a1 + 24) = v10 * v13;
    *(float *)(a1 + 28) = v11 * v13;
    *(float *)(a1 + 32) = v12 * v13;
    *(_DWORD *)a1 = 3;
    return 0;
  }
  if ( (*(_DWORD *)a1 == 9 && a4 <= 0.0 || *(_DWORD *)a1 == 3) && a5 > 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(a5 * 1000.0);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a7;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a7 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a7 + 8);
    v10 = *(float *)a8 - *(float *)a7;
    v11 = *(float *)(a8 + 4) - *(float *)(a7 + 4);
    v12 = *(float *)(a8 + 8) - *(float *)(a7 + 8);
    VectorNormalize(&v10);
    v10 = v10 * a3;
    v11 = v11 * a3;
    v12 = v12 * a3;
    *(float *)(a1 + 24) = v10;
    *(float *)(a1 + 28) = v11;
    *(float *)(a1 + 32) = v12;
    *(_DWORD *)a1 = 10;
    return 0;
  }
  if ( *(_DWORD *)a1 == 5 )
  {
    BG_EvaluateTrajectory(a1, level[122], a1 + 12);
  }
  else
  {
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a8;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a8 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a8 + 8);
  }
  *(_DWORD *)(a1 + 4) = level[122];
  *(_DWORD *)a1 = 0;
  return 1;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);

//----- (000632FC) --------------------------------------------------------
_DWORD *__usercall Reached_ScriptMover@<eax>(long double a1@<st0>, int a2)
{
  _DWORD *result; // eax
  int v3; // [esp+2Ch] [ebp-Ch]
  int v4; // [esp+2Ch] [ebp-Ch]

  if ( *(_DWORD *)(a2 + 12) )
  {
    if ( *(_DWORD *)(a2 + 20) + *(_DWORD *)(a2 + 16) <= level[122] )
    {
      v3 = sub_6304C(
             a2 + 12,
             a2 + 312,
             *(float *)(a2 + 488),
             *(float *)(a2 + 624),
             *(float *)(a2 + 636),
             a2 + 428,
             a2 + 440,
             a2 + 452);
      BG_EvaluateTrajectory(a2 + 12, level[122], a2 + 312);
      trap_LinkEntity(a2);
      if ( v3 )
        Scr_Notify(a2, scr_const[42], 0);
    }
  }
  result = (_DWORD *)a2;
  if ( *(_DWORD *)(a2 + 48) )
  {
    result = level;
    if ( *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 52) <= level[122] )
    {
      v4 = sub_6304C(
             a2 + 48,
             a2 + 324,
             *(float *)(a2 + 492),
             *(float *)(a2 + 472),
             *(float *)(a2 + 628),
             a2 + 496,
             a2 + 648,
             a2 + 660);
      BG_EvaluateTrajectory(a2 + 48, level[122], a2 + 324);
      result = (_DWORD *)trap_LinkEntity(a2);
      if ( v4 )
      {
        AngleNormalize180(*(float *)(a2 + 324));
        *(float *)(a2 + 324) = a1;
        AngleNormalize360(*(float *)(a2 + 328));
        *(float *)(a2 + 328) = a1;
        AngleNormalize180(*(float *)(a2 + 332));
        *(float *)(a2 + 332) = a1;
        result = (_DWORD *)Scr_Notify(a2, scr_const[56], 0);
      }
    }
  }
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);

//----- (00063546) --------------------------------------------------------
int __cdecl sub_63546(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  float v13; // [esp+20h] [ebp-38h] BYREF
  float v14; // [esp+24h] [ebp-34h]
  float v15; // [esp+28h] [ebp-30h]
  float v16; // [esp+30h] [ebp-28h] BYREF
  float v17; // [esp+34h] [ebp-24h]
  float v18; // [esp+38h] [ebp-20h]
  float v19; // [esp+48h] [ebp-10h]
  float v20; // [esp+4Ch] [ebp-Ch]

  v16 = *(float *)a2 - *(float *)a6;
  v17 = *(float *)(a2 + 4) - *(float *)(a6 + 4);
  v18 = *(float *)(a2 + 8) - *(float *)(a6 + 8);
  if ( *(_DWORD *)a1 )
    BG_EvaluateTrajectory(a1, level[122], a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    *(_DWORD *)a12 = *(_DWORD *)a2;
    *(_DWORD *)(a12 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a12 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    v19 = 1000.0 / (long double)*(int *)(a1 + 8);
    *(float *)(a1 + 24) = v16 * v19;
    *(float *)(a1 + 28) = v17 * v19;
    *(float *)(a1 + 32) = v18 * v19;
    *(_DWORD *)a1 = 3;
    result = BG_EvaluateTrajectory(a1, level[122], a6);
  }
  else
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    v20 = sqrt(v16 * v16 + v17 * v17 + v18 * v18);
    *(float *)a7 = (v20 + v20) / (a3 + a3 - a4 - a5);
    VectorNormalize2(&v16, &v13);
    v13 = v13 * *(float *)a7;
    v14 = v14 * *(float *)a7;
    v15 = v15 * *(float *)a7;
    if ( a4 == 0.0 )
    {
      *(_DWORD *)a10 = *(_DWORD *)a6;
      *(_DWORD *)(a10 + 4) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a10 + 8) = *(_DWORD *)(a6 + 8);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = level[122];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a9 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(float *)(a1 + 24) = v13;
        *(float *)(a1 + 28) = v14;
        *(float *)(a1 + 32) = v15;
        *(_DWORD *)a1 = 10;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = level[122];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a8 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        v16 = v13 * *(float *)a8;
        v17 = v14 * *(float *)a8;
        v18 = v15 * *(float *)a8;
        v19 = 1000.0 / (long double)*(int *)(a1 + 8);
        *(float *)(a1 + 24) = v16 * v19;
        *(float *)(a1 + 28) = v17 * v19;
        *(float *)(a1 + 32) = v18 * v19;
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[122];
      *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
      *(float *)(a1 + 24) = v13;
      *(float *)(a1 + 28) = v14;
      *(float *)(a1 + 32) = v15;
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[122] + *(_DWORD *)(a1 + 8), a10);
    }
    *(float *)a11 = v13 * *(float *)a8 + *(float *)a10;
    *(float *)(a11 + 4) = v14 * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 8) = v15 * *(float *)a8 + *(float *)(a10 + 8);
    *(_DWORD *)a12 = *(_DWORD *)a2;
    *(_DWORD *)(a12 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a12 + 8) = *(_DWORD *)(a2 + 8);
    result = BG_EvaluateTrajectory(a1, level[122], a6);
  }
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 14C80: using guessed type long double __cdecl VectorNormalize2(_DWORD, _DWORD);

//----- (00063A5E) --------------------------------------------------------
int __cdecl sub_63A5E(int a1, int a2, float a3, float a4, float a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int result; // eax
  int v13[2]; // [esp+20h] [ebp-48h] BYREF
  int v14; // [esp+28h] [ebp-40h]
  int v15; // [esp+2Ch] [ebp-3Ch]
  int v16; // [esp+30h] [ebp-38h]
  int v17; // [esp+34h] [ebp-34h]
  int v18; // [esp+38h] [ebp-30h]
  int v19; // [esp+3Ch] [ebp-2Ch]
  int v20; // [esp+40h] [ebp-28h]

  if ( *(_DWORD *)a1 )
    BG_EvaluateTrajectory(a1, level[122], a6);
  if ( a4 == 0.0 && a5 == 0.0 )
  {
    *(_DWORD *)(a1 + 4) = level[122];
    *(_DWORD *)(a1 + 8) = (int)(a3 * 1000.0);
    *(float *)a8 = a3;
    *(_DWORD *)a9 = 0;
    *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)a1 = 3;
    BG_EvaluateTrajectory(a1, level[122], a6);
    result = BG_EvaluateTrajectory(a1, level[122] + *(_DWORD *)(a1 + 8), a12);
  }
  else
  {
    *(float *)a8 = a3 - a4 - a5;
    *(float *)a9 = a5;
    *(float *)a7 = sqrt(
                     *(float *)a2 * *(float *)a2
                   + *(float *)(a2 + 4) * *(float *)(a2 + 4)
                   + *(float *)(a2 + 8) * *(float *)(a2 + 8));
    if ( a4 == 0.0 )
    {
      *(_DWORD *)a10 = *(_DWORD *)a6;
      *(_DWORD *)(a10 + 4) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a10 + 8) = *(_DWORD *)(a6 + 8);
      if ( *(float *)a8 == 0.0 )
      {
        *(_DWORD *)(a1 + 4) = level[122];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a9 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)a1 = 10;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = level[122];
        *(_DWORD *)(a1 + 8) = (int)(*(float *)a8 * 1000.0);
        *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
        *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
        *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
        *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
        *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)a1 = 3;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 4) = level[122];
      *(_DWORD *)(a1 + 8) = (int)(a4 * 1000.0);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)a6;
      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a6 + 4);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a6 + 8);
      *(_DWORD *)(a1 + 24) = *(_DWORD *)a2;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)a1 = 9;
      BG_EvaluateTrajectory(a1, level[122] + *(_DWORD *)(a1 + 8), a10);
    }
    *(float *)a11 = *(float *)a2 * *(float *)a8 + *(float *)a10;
    *(float *)(a11 + 4) = *(float *)(a2 + 4) * *(float *)a8 + *(float *)(a10 + 4);
    *(float *)(a11 + 8) = *(float *)(a2 + 8) * *(float *)a8 + *(float *)(a10 + 8);
    if ( *(float *)a9 == 0.0 )
    {
      *(_DWORD *)a12 = *(_DWORD *)a11;
      *(_DWORD *)(a12 + 4) = *(_DWORD *)(a11 + 4);
      *(_DWORD *)(a12 + 8) = *(_DWORD *)(a11 + 8);
    }
    else
    {
      v13[0] = 10;
      v13[1] = level[122];
      v14 = (int)(*(float *)a9 * 1000.0);
      v15 = *(_DWORD *)a11;
      v16 = *(_DWORD *)(a11 + 4);
      v17 = *(_DWORD *)(a11 + 8);
      v18 = *(_DWORD *)a2;
      v19 = *(_DWORD *)(a2 + 4);
      v20 = *(_DWORD *)(a2 + 8);
      BG_EvaluateTrajectory(v13, level[122] + v14, a12);
    }
    result = BG_EvaluateTrajectory(a1, level[122], a6);
  }
  return result;
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);

//----- (00063FAE) --------------------------------------------------------
int __cdecl sub_63FAE(int a1, int a2, float a3, float a4, float a5)
{
  sub_63546(a1 + 12, a2, a3, a4, a5, a1 + 312, a1 + 488, a1 + 624, a1 + 636, a1 + 428, a1 + 440, a1 + 452);
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (0006404F) --------------------------------------------------------
int __cdecl sub_6404F(int a1, int a2, float a3)
{
  *(_DWORD *)(a1 + 16) = level[122];
  *(_DWORD *)(a1 + 20) = (int)(a3 * 1000.0);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a1 + 312);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a1 + 316);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a1 + 320);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 12) = 5;
  BG_EvaluateTrajectory(a1 + 12, level[122], a1 + 312);
  return trap_LinkEntity(a1);
}
// 13330: using guessed type _DWORD __cdecl BG_EvaluateTrajectory(_DWORD, _DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00064137) --------------------------------------------------------
int __cdecl sub_64137(int a1, int a2, float a3, float a4, float a5)
{
  sub_63546(a1 + 48, a2, a3, a4, a5, a1 + 324, a1 + 492, a1 + 472, a1 + 628, a1 + 496, a1 + 648, a1 + 660);
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (000641D8) --------------------------------------------------------
int __cdecl sub_641D8(int a1, int a2, float a3, float a4, float a5)
{
  sub_63A5E(a1 + 48, a2, a3, a4, a5, a1 + 324, a1 + 492, a1 + 472, a1 + 628, a1 + 496, a1 + 648, a1 + 660);
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);

//----- (00064279) --------------------------------------------------------
int __cdecl InitScriptMover(_DWORD *a1)
{
  int result; // eax
  int v2; // [esp+18h] [ebp-40h]
  int v3; // [esp+1Ch] [ebp-3Ch]
  int v4; // [esp+20h] [ebp-38h]
  int v5; // [esp+24h] [ebp-34h]
  int v6; // [esp+28h] [ebp-30h]
  int v7; // [esp+2Ch] [ebp-2Ch]
  int v8[7]; // [esp+30h] [ebp-28h] BYREF
  float v9[3]; // [esp+4Ch] [ebp-Ch] BYREF

  v7 = G_SpawnFloat("light", (int)&unk_7E31C, (int)v9);
  v6 = G_SpawnVector("color", (int)"1 1 1", (int)v8);
  if ( v7 || v6 )
  {
    v5 = (int)(*(float *)v8 * 255.0);
    if ( v5 > 255 )
      v5 = 255;
    v4 = (int)(*(float *)&v8[1] * 255.0);
    if ( v4 > 255 )
      v4 = 255;
    v3 = (int)(*(float *)&v8[2] * 255.0);
    if ( v3 > 255 )
      v3 = 255;
    v2 = (int)(v9[0] / 4.0);
    if ( v2 > 255 )
      v2 = 255;
    a1[32] = (v3 << 16) | v5 | (v4 << 8) | (v2 << 24);
  }
  a1[131] = Reached_ScriptMover;
  a1[61] = 128;
  a1[1] = 8;
  a1[6] = a1[78];
  a1[7] = a1[79];
  a1[8] = a1[80];
  a1[3] = 0;
  a1[15] = a1[81];
  a1[16] = a1[82];
  a1[17] = a1[83];
  a1[12] = 0;
  result = a1[97] | 0x2000;
  a1[97] = result;
  return result;
}

//----- (00064454) --------------------------------------------------------
int __cdecl SP_script_brushmodel(int a1)
{
  trap_SetBrushModel(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 284) = 1;
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 15450: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (0006449A) --------------------------------------------------------
int __cdecl SP_script_model(int a1)
{
  G_DObjUpdate(a1);
  InitScriptMover(a1);
  *(_DWORD *)(a1 + 244) |= 4u;
  *(_DWORD *)(a1 + 284) = 8320;
  return trap_LinkEntity(a1);
}
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15450: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (000644F5) --------------------------------------------------------
_DWORD *__cdecl SP_script_origin(_DWORD *a1)
{
  _DWORD *result; // eax

  InitScriptMover(a1);
  a1[71] = 0;
  trap_LinkEntity(a1);
  result = a1;
  if ( a1[32] )
    a1[2] |= 0x100u;
  else
    a1[61] |= 1u;
  return result;
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15450: using guessed type _DWORD __cdecl InitScriptMover(_DWORD);

//----- (00064565) --------------------------------------------------------
void __cdecl ScriptEntCmdGetCommandTimes(float *a1, float *a2, float *a3)
{
  int v3; // [esp+10h] [ebp-8h]

  *a1 = Scr_GetFloat(1);
  if ( *a1 <= 0.0 )
    Scr_ParamError(1, "total time must be positive");
  v3 = Scr_GetNumParam();
  if ( v3 <= 2 )
  {
    *a2 = 0.0;
    *a3 = 0.0;
  }
  else
  {
    *a2 = Scr_GetFloat(2);
    if ( *a2 < 0.0 )
      Scr_ParamError(2, "accel time must be nonnegative");
    if ( v3 <= 3 )
    {
      *a3 = 0.0;
    }
    else
    {
      *a3 = Scr_GetFloat(3);
      if ( *a3 < 0.0 )
        Scr_ParamError(3, "decel time must be nonnegative");
    }
  }
  if ( *a2 + *a3 > (long double)*a1 )
    Scr_Error("accel time plus decel time is greater than total time");
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);

//----- (0006468D) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveTo(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[5]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+44h] [ebp-14h] BYREF
  float v7; // [esp+48h] [ebp-10h] BYREF
  float v8[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( *((_WORD *)v4 + 190) != scr_const[57]
      && *((_WORD *)v4 + 190) != scr_const[58]
      && *((_WORD *)v4 + 190) != scr_const[59] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[97] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    ScriptEntCmdGetCommandTimes(v8, &v7, &v6);
    result = sub_63FAE((int)v4, (int)v5, v8[0], v7, v6);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13DC0: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (000647AE) --------------------------------------------------------
int __cdecl ScriptEntCmd_GravityMove(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+1Ch] [ebp-2Ch]
  int v5[7]; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+3Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( *((_WORD *)v4 + 190) != scr_const[57]
      && *((_WORD *)v4 + 190) != scr_const[58]
      && *((_WORD *)v4 + 190) != scr_const[59] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[97] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    v6 = Scr_GetFloat(1);
    result = sub_6404F((int)v4, (int)v5, v6);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (000648B7) --------------------------------------------------------
int __cdecl ScriptEnt_MoveAxis(unsigned int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+2Ch] [ebp-2Ch]
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+40h] [ebp-18h] BYREF
  float v8; // [esp+44h] [ebp-14h] BYREF
  float v9; // [esp+48h] [ebp-10h] BYREF
  float v10; // [esp+4Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error(v3);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( *((_WORD *)v5 + 190) != scr_const[57]
      && *((_WORD *)v5 + 190) != scr_const[58]
      && *((_WORD *)v5 + 190) != scr_const[59] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v2);
    }
  }
  result = v5[97] & 4;
  if ( !result )
  {
    v10 = Scr_GetFloat(0);
    ScriptEntCmdGetCommandTimes(&v9, &v8, &v7);
    v6[0] = v5[78];
    v6[1] = v5[79];
    v6[2] = v5[80];
    *(float *)&v6[a2] = *(float *)&v6[a2] + v10;
    result = sub_63FAE((int)v5, (int)v6, v9, v8, v7);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13DC0: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00064A0C) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveX(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 0);
}
// 14F70: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00064A37) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveY(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 1);
}
// 14F70: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00064A62) --------------------------------------------------------
int __cdecl ScriptEntCmd_MoveZ(unsigned int a1)
{
  return ScriptEnt_MoveAxis(a1, 2);
}
// 14F70: using guessed type _DWORD __cdecl ScriptEnt_MoveAxis(unsigned int, _DWORD);

//----- (00064A8D) --------------------------------------------------------
int __usercall ScriptEntCmd_RotateTo@<eax>(long double a1@<st0>, unsigned int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  int v5; // edi
  int v6; // esi
  _DWORD *v7; // [esp+2Ch] [ebp-4Ch]
  float v8[4]; // [esp+30h] [ebp-48h] BYREF
  float v9[4]; // [esp+40h] [ebp-38h] BYREF
  float v10; // [esp+50h] [ebp-28h] BYREF
  float v11; // [esp+54h] [ebp-24h] BYREF
  float v12; // [esp+58h] [ebp-20h] BYREF
  int i; // [esp+5Ch] [ebp-1Ch]

  if ( a2 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a2);
    Scr_Error(v3);
    v7 = 0;
  }
  else
  {
    v7 = &g_entities[199 * a2];
    if ( *((_WORD *)v7 + 190) != scr_const[57]
      && *((_WORD *)v7 + 190) != scr_const[58]
      && *((_WORD *)v7 + 190) != scr_const[59] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a2);
      Scr_Error(v2);
    }
  }
  result = v7[97] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v9);
    ScriptEntCmdGetCommandTimes(&v12, &v11, &v10);
    for ( i = 0; i <= 2; ++i )
    {
      v5 = i;
      v6 = i;
      AngleSubtract(v9[i], *(float *)&v7[i + 81]);
      a1 = a1 + *(float *)&v7[v6 + 81];
      v8[v5] = a1;
    }
    result = sub_64137((int)v7, (int)v8, v12, v11, v10);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13DC0: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (00064C07) --------------------------------------------------------
int __cdecl ScriptEnt_RotateAxis(unsigned int a1, int a2)
{
  int v2; // eax
  int v3; // eax
  int result; // eax
  _DWORD *v5; // [esp+2Ch] [ebp-2Ch]
  int v6[4]; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+40h] [ebp-18h] BYREF
  float v8; // [esp+44h] [ebp-14h] BYREF
  float v9; // [esp+48h] [ebp-10h] BYREF
  float v10; // [esp+4Ch] [ebp-Ch]

  if ( a1 > 0x3FF )
  {
    v3 = va("%i is not a valid entity number", a1);
    Scr_Error(v3);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( *((_WORD *)v5 + 190) != scr_const[57]
      && *((_WORD *)v5 + 190) != scr_const[58]
      && *((_WORD *)v5 + 190) != scr_const[59] )
    {
      v2 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v2);
    }
  }
  result = v5[97] & 4;
  if ( !result )
  {
    v10 = Scr_GetFloat(0);
    ScriptEntCmdGetCommandTimes(&v9, &v8, &v7);
    v6[0] = v5[81];
    v6[1] = v5[82];
    v6[2] = v5[83];
    *(float *)&v6[a2] = *(float *)&v6[a2] + v10;
    result = sub_64137((int)v5, (int)v6, v9, v8, v7);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13DC0: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);

//----- (00064D5C) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotatePitch(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 0);
}
// 15340: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00064D87) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateYaw(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 1);
}
// 15340: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00064DB2) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateRoll(unsigned int a1)
{
  return ScriptEnt_RotateAxis(a1, 2);
}
// 15340: using guessed type _DWORD __cdecl ScriptEnt_RotateAxis(unsigned int, _DWORD);

//----- (00064DDD) --------------------------------------------------------
int __cdecl ScriptEntCmd_RotateVelocity(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  _DWORD *v4; // [esp+2Ch] [ebp-2Ch]
  int v5[5]; // [esp+30h] [ebp-28h] BYREF
  float v6; // [esp+44h] [ebp-14h] BYREF
  float v7; // [esp+48h] [ebp-10h] BYREF
  float v8[3]; // [esp+4Ch] [ebp-Ch] BYREF

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v4 = 0;
  }
  else
  {
    v4 = &g_entities[199 * a1];
    if ( *((_WORD *)v4 + 190) != scr_const[57]
      && *((_WORD *)v4 + 190) != scr_const[58]
      && *((_WORD *)v4 + 190) != scr_const[59] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  result = v4[97] & 4;
  if ( !result )
  {
    Scr_GetVector(0, v5);
    ScriptEntCmdGetCommandTimes(v8, &v7, &v6);
    result = sub_641D8((int)v4, (int)v5, v8[0], v7, v6);
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 13DC0: using guessed type _DWORD __cdecl ScriptEntCmdGetCommandTimes(_DWORD, _DWORD, _DWORD);

//----- (00064EFE) --------------------------------------------------------
int __cdecl ScriptEntCmd_Solid(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // [esp+4h] [ebp-14h]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( *((_WORD *)v5 + 190) != scr_const[57]
      && *((_WORD *)v5 + 190) != scr_const[58]
      && *((_WORD *)v5 + 190) != scr_const[59] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  if ( *((_WORD *)v5 + 190) == scr_const[59] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity", v4);
  if ( *((_WORD *)v5 + 190) == scr_const[58] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity", v4);
  result = (int)v5;
  v5[71] = 1;
  return result;
}
// 64FD3: variable 'v4' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00065013) --------------------------------------------------------
int __cdecl ScriptEntCmd_NotSolid(unsigned int a1)
{
  int v1; // eax
  int v2; // eax
  int result; // eax
  char v4; // [esp+4h] [ebp-14h]
  _DWORD *v5; // [esp+10h] [ebp-8h]

  if ( a1 > 0x3FF )
  {
    v2 = va("%i is not a valid entity number", a1);
    Scr_Error(v2);
    v5 = 0;
  }
  else
  {
    v5 = &g_entities[199 * a1];
    if ( *((_WORD *)v5 + 190) != scr_const[57]
      && *((_WORD *)v5 + 190) != scr_const[58]
      && *((_WORD *)v5 + 190) != scr_const[59] )
    {
      v1 = va("entity %i is not a script_brushmodel, script_model, or script_origin", a1);
      Scr_Error(v1);
    }
  }
  if ( *((_WORD *)v5 + 190) == scr_const[59] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_origin entity", v4);
  if ( *((_WORD *)v5 + 190) == scr_const[58] )
    return G_DPrintf("cannot use the solid/notsolid commands on a script_model entity", v4);
  result = (int)v5;
  v5[71] = 0;
  return result;
}
// 650E8: variable 'v4' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (00065128) --------------------------------------------------------
int __cdecl ScriptEnt_GetMethod(char **a1)
{
  char *s1; // [esp+Ch] [ebp-Ch]
  unsigned int i; // [esp+10h] [ebp-8h]

  s1 = *a1;
  for ( i = 0; i <= 0xB; ++i )
  {
    if ( !strcmp(s1, *(const char **)((char *)&off_842E0 + (_DWORD)&dword_0[2 * i])) )
    {
      *a1 = *(char **)((char *)&off_842E0 + (_DWORD)&dword_0[2 * i]);
      return *(int *)((char *)&off_842E4 + (_DWORD)&dword_0[2 * i]);
    }
  }
  return 0;
}
// 0: using guessed type int dword_0[];
// 842E0: using guessed type char *off_842E0;
// 842E4: using guessed type int (__cdecl *off_842E4)(char);

//----- (000651A3) --------------------------------------------------------
void sub_651A3()
{
  ;
}

//----- (000651A8) --------------------------------------------------------
int __cdecl G_SpawnString(char *s1, int a2, int a3)
{
  int i; // [esp+10h] [ebp-8h]

  if ( !level[1498] )
    *(_DWORD *)a3 = a2;
  for ( i = 0; i < level[1499]; ++i )
  {
    if ( !strcmp(s1, (const char *)level[2 * i + 1500]) )
    {
      *(_DWORD *)a3 = level[2 * i + 1501];
      return 1;
    }
  }
  *(_DWORD *)a3 = a2;
  return 0;
}

//----- (0006524B) --------------------------------------------------------
int __cdecl G_SpawnFloat(char *s1, int a2, int a3)
{
  int v4; // [esp+18h] [ebp-10h]
  char *nptr; // [esp+1Ch] [ebp-Ch] BYREF

  v4 = G_SpawnString(s1, a2, (int)&nptr);
  *(float *)a3 = atof(nptr);
  return v4;
}

//----- (00065294) --------------------------------------------------------
int __cdecl G_SpawnInt(char *s1, int a2, int a3)
{
  int v4; // [esp+Ch] [ebp-Ch]
  char *nptr; // [esp+10h] [ebp-8h] BYREF

  v4 = G_SpawnString(s1, a2, (int)&nptr);
  *(_DWORD *)a3 = atoi(nptr);
  return v4;
}

//----- (000652DD) --------------------------------------------------------
int __cdecl G_SpawnVector(char *s1, int a2, int a3)
{
  int v4; // [esp+1Ch] [ebp-Ch]
  char *s; // [esp+20h] [ebp-8h] BYREF

  v4 = G_SpawnString(s1, a2, (int)&s);
  sscanf(s, "%f %f %f", a3, a3 + 4, a3 + 8);
  return v4;
}

//----- (00065344) --------------------------------------------------------
int sub_65344()
{
  return Scr_Error("Tried to set a read only entity field");
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);

//----- (0006536A) --------------------------------------------------------
int __cdecl sub_6536A(int a1, int a2)
{
  char *v2; // eax
  char v4; // [esp+8h] [ebp-20h]
  char v5[4]; // [esp+20h] [ebp-8h] BYREF

  if ( level[1498] )
  {
    G_SpawnString("classname", (int)&unk_7E825, (int)v5);
    v4 = dword_A65C4;
    v2 = (char *)va(byte_7E840, v5[0]);
    Com_Error(1, v2, v4);
  }
  return Scr_ObjectError(a2);
}
// 145A0: using guessed type _DWORD __cdecl Scr_ObjectError(_DWORD);
// A65C4: using guessed type int dword_A65C4;
// A65C8: using guessed type int dword_A65C8;

//----- (000653FB) --------------------------------------------------------
int __cdecl sub_653FB(int a1, char *nptr, int a3)
{
  int result; // eax
  int v4; // eax
  float v5; // [esp+18h] [ebp-10h]
  unsigned __int16 v6; // [esp+1Eh] [ebp-Ah]
  int v7; // [esp+20h] [ebp-8h] BYREF

  result = Scr_FindField(a1, &v7);
  v6 = result;
  if ( (_WORD)result )
  {
    result = v7;
    if ( v7 == 4 )
    {
      v5 = atof(nptr);
      Scr_AddFloat(LODWORD(v5));
      return GScr_SetDynamicEntityField(a3, v6);
    }
    if ( v7 <= 4 )
    {
      if ( v7 != 1 )
        return result;
      Scr_AddString(nptr);
      return GScr_SetDynamicEntityField(a3, v6);
    }
    if ( v7 == 5 )
    {
      v4 = atoi(nptr);
      Scr_AddInt(v4);
      return GScr_SetDynamicEntityField(a3, v6);
    }
  }
  return result;
}
// 13A40: using guessed type _DWORD __cdecl GScr_SetDynamicEntityField(_DWORD, _DWORD);
// 13BB0: using guessed type _DWORD __cdecl Scr_FindField(_DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);

//----- (000654A2) --------------------------------------------------------
void __cdecl sub_654A2(int a1, char *s, int a3)
{
  float *v3; // esi
  int v4; // [esp+30h] [ebp-28h] BYREF
  int v5; // [esp+34h] [ebp-24h] BYREF
  int v6; // [esp+38h] [ebp-20h] BYREF
  int v7; // [esp+48h] [ebp-10h]
  char **i; // [esp+4Ch] [ebp-Ch]

  dword_A65C4 = a1;
  dword_A65C8 = (int)s;
  for ( i = &off_84340; ; i += 4 )
  {
    if ( !*i )
    {
      sub_653FB(a1, s, a3);
      return;
    }
    if ( !Q_stricmp(*i, a1) )
      break;
  }
  v7 = a3;
  switch ( (unsigned int)i[2] )
  {
    case 0u:
      *(_DWORD *)&i[1][v7] = atoi(s);
      break;
    case 1u:
      v3 = (float *)&i[1][v7];
      *v3 = atof(s);
      break;
    case 3u:
      Scr_SetString(&i[1][v7], 0);
      *(_WORD *)&i[1][v7] = G_NewString(s);
      break;
    case 4u:
      sscanf(s, "%f %f %f", &v4, &v5, &v6);
      *(_DWORD *)&i[1][v7] = v4;
      *(_DWORD *)&i[1][v7 + 4] = v5;
      *(_DWORD *)&i[1][v7 + 8] = v6;
      break;
    case 8u:
      if ( *s == 42 )
        *(_DWORD *)(a3 + 140) = (unsigned __int16)atoi(s + 1);
      else
        *(_BYTE *)(a3 + 377) = G_ModelIndex(s);
      break;
    default:
      return;
  }
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 84340: using guessed type char *off_84340;
// A65C4: using guessed type int dword_A65C4;
// A65C8: using guessed type int dword_A65C8;

//----- (00065669) --------------------------------------------------------
int __cdecl sub_65669(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < level[1499]; ++i )
    sub_654A2(level[2 * i + 1500], (char *)level[2 * i + 1501], a1);
  G_SetOrigin(a1, a1 + 312);
  return G_SetAngle(a1, a1 + 324);
}
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (00065703) --------------------------------------------------------
char **__cdecl G_DuplicateEntityFields(int a1, int a2)
{
  char **result; // eax
  char **i; // [esp+20h] [ebp-8h]

  for ( i = &off_84340; ; i += 4 )
  {
    result = i;
    if ( !*i )
      break;
    switch ( (unsigned int)i[2] )
    {
      case 0u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 1u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        break;
      case 3u:
        Scr_SetString(&i[1][a1], *(unsigned __int16 *)&i[1][a2]);
        break;
      case 4u:
        *(_DWORD *)&i[1][a1] = *(_DWORD *)&i[1][a2];
        *(_DWORD *)&i[1][a1 + 4] = *(_DWORD *)&i[1][a2 + 4];
        *(_DWORD *)&i[1][a1 + 8] = *(_DWORD *)&i[1][a2 + 8];
        break;
      case 8u:
        i[1][a1] = i[1][a2];
        break;
      default:
        continue;
    }
  }
  return result;
}
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 84340: using guessed type char *off_84340;

//----- (00065834) --------------------------------------------------------
int __cdecl G_DuplicateScriptFields(_DWORD *a1, _DWORD *a2)
{
  return Scr_CopyEntityNum(*a2, *a1, 0);
}
// 15810: using guessed type _DWORD __cdecl Scr_CopyEntityNum(_DWORD, _DWORD, _DWORD);

//----- (0006586A) --------------------------------------------------------
int G_CallSpawn()
{
  char v1; // [esp+4h] [ebp-24h]
  char *s2; // [esp+14h] [ebp-14h] BYREF
  int v3; // [esp+18h] [ebp-10h]
  const char **i; // [esp+1Ch] [ebp-Ch]
  char **j; // [esp+20h] [ebp-8h]

  G_SpawnString("classname", (int)&unk_7E825, (int)&s2);
  if ( !s2 )
    return G_Printf("G_CallSpawn: NULL classname\n", v1);
  for ( i = (const char **)&bg_itemlist[12]; *i; i += 12 )
  {
    if ( !strcmp(*i, s2) )
    {
      v3 = G_Spawn();
      sub_65669(v3);
      return G_SpawnItem(v3, i);
    }
  }
  for ( j = &spawns; *j; j += 2 )
  {
    if ( !strcmp(*j, s2) )
    {
      v3 = G_Spawn();
      sub_65669(v3);
      return ((int (__cdecl *)(int))j[1])(v3);
    }
  }
  v3 = G_Spawn();
  return sub_65669(v3);
}
// 658AA: variable 'v1' is possibly undefined
// 12E70: using guessed type int G_Spawn(void);
// 13D90: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 84580: using guessed type char *spawns;

//----- (00065980) --------------------------------------------------------
int __cdecl G_CallSpawnEntity(int a1)
{
  char v1; // al
  char v3; // [esp+4h] [ebp-24h]
  int v4; // [esp+14h] [ebp-14h]
  char *s2; // [esp+18h] [ebp-10h]
  const char **i; // [esp+1Ch] [ebp-Ch]
  char **j; // [esp+20h] [ebp-8h]

  if ( *(_WORD *)(a1 + 380) )
  {
    s2 = (char *)SL_ConvertToString(*(unsigned __int16 *)(a1 + 380));
    for ( i = (const char **)&bg_itemlist[12]; *i; i += 12 )
    {
      if ( !strcmp(*i, s2) )
      {
        G_SpawnItem(a1, i);
        return 1;
      }
    }
    for ( j = &spawns; *j; j += 2 )
    {
      if ( !strcmp(*j, s2) )
      {
        ((void (__cdecl *)(int))j[1])(a1);
        return 1;
      }
    }
    v1 = SL_ConvertToString(*(unsigned __int16 *)(a1 + 380));
    G_Printf("%s doesn't have a spawn function\n", v1);
    v4 = 0;
  }
  else
  {
    G_Printf("G_CallSpawnEntity: NULL classname\n", v3);
    v4 = 0;
  }
  return v4;
}
// 659A8: variable 'v3' is possibly undefined
// 13D90: using guessed type _DWORD __cdecl G_SpawnItem(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 84580: using guessed type char *spawns;

//----- (00065A9D) --------------------------------------------------------
int __cdecl G_NewString(char *s)
{
  signed int v2; // [esp+14h] [ebp-10014h]
  signed int i; // [esp+18h] [ebp-10010h]
  char *v4; // [esp+1Ch] [ebp-1000Ch]
  char v5[65544]; // [esp+20h] [ebp-10008h] BYREF

  v2 = strlen(s) + 1;
  if ( v2 > (unsigned int)&stru_10000 )
    G_Error("G_NewString: len = %i > %i\n", v2);
  v4 = v5;
  for ( i = 0; i < v2; ++i )
  {
    if ( s[i] == 92 && i < v2 - 1 )
    {
      if ( s[++i] == 110 )
        *v4 = 10;
      else
        *v4 = 92;
      ++v4;
    }
    else
    {
      *v4++ = s[i];
    }
  }
  return (unsigned __int16)SL_GetString(v5, 0);
}
// 10000: using guessed type Elf32_Rel stru_10000;
// 13D10: using guessed type _DWORD __cdecl SL_GetString(_DWORD, _DWORD);

//----- (00065BBF) --------------------------------------------------------
int GScr_AddFieldsForEntity()
{
  unsigned int v1; // [esp+18h] [ebp-10h]
  unsigned __int16 v2; // [esp+1Eh] [ebp-Ah]
  char **i; // [esp+20h] [ebp-8h]

  v2 = g_scr_data[210];
  for ( i = &off_84340; *i; i += 4 )
  {
    v1 = (unsigned int)i[2];
    if ( v1 <= 5 || v1 - 7 <= 1 )
      Scr_AddClassField(
        v2,
        *i,
        (unsigned __int16)(((char *)i - ((char *)&GLOBAL_OFFSET_TABLE_ + (_DWORD)(&off_84340 - 140134))) >> 4));
  }
  return GScr_AddFieldsForClient(v2);
}
// 147A0: using guessed type _DWORD __cdecl Scr_AddClassField(_DWORD, _DWORD, _DWORD);
// 14DB0: using guessed type _DWORD __cdecl GScr_AddFieldsForClient(_DWORD);
// 84340: using guessed type char *off_84340;
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (00065C53) --------------------------------------------------------
int GScr_AddFieldsForRadiant()
{
  return Scr_AddFields("radiant", ".txt");
}
// 12EA0: using guessed type _DWORD __cdecl Scr_AddFields(_DWORD, _DWORD);

//----- (00065C83) --------------------------------------------------------
int __cdecl Scr_SetEntityField(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+Ch] [ebp-Ch]
  char **v4; // [esp+10h] [ebp-8h]

  v3 = &g_entities[199 * a1];
  if ( (a2 & 0xC000) == 49152 )
  {
    if ( !v3[87] )
      sub_6536A((int)v3, (int)"field must be applied to a player");
    result = Scr_SetClientField(v3[87], a2 & 0xFFFF3FFF);
  }
  else
  {
    v4 = &(&off_84340)[4 * a2];
    if ( v4[3] )
      result = ((int (__cdecl *)(_DWORD *, int))v4[3])(v3, a2);
    else
      result = Scr_SetGenericField(v3, v4[2], v4[1]);
  }
  return result;
}
// 14CD0: using guessed type _DWORD __cdecl Scr_SetClientField(_DWORD, _DWORD);
// 14CF0: using guessed type _DWORD __cdecl Scr_SetGenericField(_DWORD, _DWORD, _DWORD);
// 84340: using guessed type char *off_84340;

//----- (00065D52) --------------------------------------------------------
int __cdecl Scr_SetGenericField(int a1, int a2, int a3)
{
  int result; // eax
  unsigned __int16 v4; // ax
  long double v5; // fst7
  int v6; // [esp+10h] [ebp-18h] BYREF
  int v7; // [esp+14h] [ebp-14h]
  int v8; // [esp+18h] [ebp-10h]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_GetInt(0);
      *(_DWORD *)(a1 + a3) = result;
      break;
    case 1:
      v5 = Scr_GetFloat(0);
      result = a1 + a3;
      *(float *)(a1 + a3) = v5;
      break;
    case 3:
      v4 = Scr_GetConstString(0);
      result = Scr_SetString(a1 + a3, v4);
      break;
    case 4:
      Scr_GetVector(0, &v6);
      *(_DWORD *)(a3 + a1) = v6;
      *(_DWORD *)(a1 + a3 + 4) = v7;
      result = v8;
      *(_DWORD *)(a1 + a3 + 8) = v8;
      break;
    case 5:
      result = Scr_GetEntity(0);
      *(_DWORD *)(a3 + a1) = result;
      break;
    case 6:
      Scr_GetVector(0, &v6);
      result = v7;
      *(_DWORD *)(a3 + a1) = v7;
      break;
    default:
      return result;
  }
  return result;
}
// 13890: using guessed type _DWORD __cdecl Scr_GetEntity(_DWORD);
// 13C30: using guessed type _DWORD __cdecl Scr_GetVector(_DWORD, _DWORD);
// 141D0: using guessed type long double __cdecl Scr_GetFloat(_DWORD);
// 143E0: using guessed type _DWORD __cdecl Scr_GetInt(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);

//----- (00065E4F) --------------------------------------------------------
int __cdecl Scr_SetObjectField(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( !a1 )
    return Scr_SetEntityField(a2, a3);
  if ( a1 == 1 )
    result = Scr_SetHudElemField(a2, a3);
  return result;
}
// 14330: using guessed type _DWORD __cdecl Scr_SetEntityField(_DWORD, _DWORD);
// 14E00: using guessed type _DWORD __cdecl Scr_SetHudElemField(_DWORD, _DWORD);

//----- (00065EA1) --------------------------------------------------------
int __cdecl Scr_GetEntityField(int a1, int a2)
{
  _DWORD *v3; // [esp+Ch] [ebp-Ch]

  v3 = &g_entities[199 * a1];
  if ( (a2 & 0xC000) != 49152 )
    return Scr_GetGenericField(v3, (&off_84340)[4 * a2 + 2], (&off_84340)[4 * a2 + 1]);
  if ( !v3[87] )
    sub_6536A((int)v3, (int)"field must be applied to a player");
  return Scr_GetClientField(v3[87], a2 & 0xFFFF3FFF);
}
// 146D0: using guessed type _DWORD __cdecl Scr_GetClientField(_DWORD, _DWORD);
// 14B40: using guessed type _DWORD __cdecl Scr_GetGenericField(_DWORD, _DWORD, _DWORD);
// 84340: using guessed type char *off_84340;

//----- (00065F50) --------------------------------------------------------
int __cdecl Scr_GetGenericField(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // eax
  unsigned __int16 v5; // [esp+1Eh] [ebp-2Ah]
  int v6[6]; // [esp+20h] [ebp-28h] BYREF
  unsigned __int16 v7; // [esp+3Ah] [ebp-Eh]
  int v8; // [esp+3Ch] [ebp-Ch]

  result = a2;
  switch ( a2 )
  {
    case 0:
      result = Scr_AddInt(*(_DWORD *)(a1 + a3));
      break;
    case 1:
      result = Scr_AddFloat(*(_DWORD *)(a1 + a3));
      break;
    case 2:
      v8 = a1 + a3;
      result = Scr_AddString(a1 + a3);
      break;
    case 3:
      result = *(unsigned __int16 *)(a1 + a3);
      v7 = *(_WORD *)(a1 + a3);
      if ( v7 )
        result = Scr_AddConstString(v7);
      break;
    case 4:
      result = Scr_AddVector(a1 + a3);
      break;
    case 5:
      result = a1 + a3;
      if ( *(_DWORD *)(a1 + a3) )
        result = Scr_AddEntity(*(_DWORD *)(a1 + a3));
      break;
    case 6:
      v6[0] = 0;
      v6[1] = *(_DWORD *)(a1 + a3);
      v6[2] = 0;
      result = Scr_AddVector(v6);
      break;
    case 7:
      result = *(unsigned __int16 *)(a1 + a3);
      v5 = *(_WORD *)(a1 + a3);
      if ( v5 )
        result = Scr_AddObject(v5);
      break;
    case 8:
      v4 = G_ModelName(*(unsigned __int8 *)(a1 + a3));
      result = Scr_AddString(v4);
      break;
    default:
      return result;
  }
  return result;
}
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 139E0: using guessed type _DWORD __cdecl Scr_AddConstString(_DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14270: using guessed type _DWORD __cdecl Scr_AddFloat(_DWORD);
// 14CA0: using guessed type _DWORD __cdecl Scr_AddString(_DWORD);
// 14FC0: using guessed type _DWORD __cdecl Scr_AddVector(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 155A0: using guessed type _DWORD __cdecl Scr_AddObject(_DWORD);

//----- (0006607D) --------------------------------------------------------
int __cdecl Scr_GetObjectField(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( !a1 )
    return Scr_GetEntityField(a2, a3);
  if ( a1 == 1 )
    result = Scr_GetHudElemField(a2, a3);
  return result;
}
// 133C0: using guessed type _DWORD __cdecl Scr_GetEntityField(_DWORD, _DWORD);
// 15170: using guessed type _DWORD __cdecl Scr_GetHudElemField(_DWORD, _DWORD);

//----- (000660CF) --------------------------------------------------------
int *__cdecl Scr_FreeEntityConstStrings(int a1)
{
  int *result; // eax
  int v2[2]; // [esp+8h] [ebp-10h] BYREF
  char **i; // [esp+10h] [ebp-8h]

  for ( i = &off_84340; ; i += 4 )
  {
    result = (int *)i;
    if ( !*i )
      break;
    if ( i[2] == (_BYTE *)dword_0 + 3 )
    {
      v2[1] = a1;
      Scr_SetString(&i[1][a1], 0);
    }
  }
  for ( v2[0] = 0; v2[0] <= 5; ++v2[0] )
  {
    *(_BYTE *)(v2[0] + a1 + 756) = 0;
    Scr_SetString(a1 + 2 * v2[0] + 762, 0);
    result = v2;
  }
  return result;
}
// 0: using guessed type int dword_0[];
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 84340: using guessed type char *off_84340;

//----- (0006616C) --------------------------------------------------------
int __cdecl Scr_FreeEntity(_DWORD *a1)
{
  Scr_FreeEntityConstStrings(a1);
  return Scr_FreeEntityNum(*a1, 0);
}
// 130A0: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 14AC0: using guessed type _DWORD __cdecl Scr_FreeEntityConstStrings(_DWORD);

//----- (000661A4) --------------------------------------------------------
int __cdecl Scr_AddEntity(_DWORD *a1)
{
  return Scr_AddEntityNum(*a1, 0);
}
// 14350: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);

//----- (000661D1) --------------------------------------------------------
_DWORD *__cdecl Scr_GetEntity(int a1)
{
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetEntityNum(a1, &v3);
  if ( !v3 && v4 <= 0x3FF )
    return &g_entities[199 * v4];
  Scr_ParamError(a1, "not an entity");
  return 0;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 15840: using guessed type _DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD);

//----- (00066245) --------------------------------------------------------
int __cdecl Scr_FreeHudElem(int a1)
{
  Scr_FreeHudElemConstStrings(a1);
  return Scr_FreeEntityNum(-1108378657 * ((a1 - (int)g_hudelems) >> 2), 1);
}
// 130A0: using guessed type _DWORD __cdecl Scr_FreeEntityNum(_DWORD, _DWORD);
// 13630: using guessed type _DWORD __cdecl Scr_FreeHudElemConstStrings(_DWORD);

//----- (0006628C) --------------------------------------------------------
int __cdecl Scr_AddHudElem(int a1)
{
  return Scr_AddEntityNum(-1108378657 * ((a1 - (int)g_hudelems) >> 2), 1);
}
// 14350: using guessed type _DWORD __cdecl Scr_AddEntityNum(_DWORD, _DWORD);

//----- (000662C8) --------------------------------------------------------
_DWORD *__cdecl Scr_GetHudElem(int a1)
{
  int v3; // [esp+Ch] [ebp-Ch] BYREF
  unsigned int v4; // [esp+10h] [ebp-8h]

  v4 = Scr_GetEntityNum(a1, &v3);
  if ( v3 == 1 && v4 <= 0x3FF )
    return &g_hudelems[31 * v4];
  Scr_ParamError(a1, "not a hudelem");
  return 0;
}
// 14370: using guessed type _DWORD __cdecl Scr_ParamError(_DWORD, _DWORD);
// 15840: using guessed type _DWORD __cdecl Scr_GetEntityNum(_DWORD, _DWORD);

//----- (00066342) --------------------------------------------------------
int __cdecl Scr_ExecEntThread(_DWORD *a1, int a2, int a3)
{
  return (unsigned __int16)Scr_ExecEntThreadNum(*a1, 0, a2, a3);
}
// 15AA0: using guessed type _DWORD __cdecl Scr_ExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00066380) --------------------------------------------------------
int __cdecl Scr_AddExecEntThread(_DWORD *a1, int a2, int a3)
{
  return Scr_AddExecEntThreadNum(*a1, 0, a2, a3);
}
// 15210: using guessed type _DWORD __cdecl Scr_AddExecEntThreadNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000663BB) --------------------------------------------------------
int __cdecl Scr_Notify(_DWORD *a1, unsigned __int16 a2, int a3)
{
  return Scr_NotifyNum(*a1, 0, a2, a3);
}
// 13FE0: using guessed type _DWORD __cdecl Scr_NotifyNum(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (000663FE) --------------------------------------------------------
int Scr_GetEnt()
{
  int result; // eax
  int v1; // [esp+14h] [ebp-24h]
  _DWORD *v2; // [esp+18h] [ebp-20h]
  int v3; // [esp+1Ch] [ebp-1Ch]
  __int16 v4; // [esp+20h] [ebp-18h]
  __int16 v5; // [esp+22h] [ebp-16h]
  int v6; // [esp+24h] [ebp-14h]
  _DWORD *i; // [esp+2Ch] [ebp-Ch]

  v4 = Scr_GetConstString(0);
  v6 = Scr_GetString(1);
  result = Scr_GetOffset((unsigned __int16)g_scr_data[210], v6);
  v3 = result;
  if ( result >= 0 )
  {
    result = (int)&(&off_84340)[4 * result];
    if ( *(_DWORD *)(result + 8) == 3 )
    {
      v2 = 0;
      v1 = 0;
      for ( i = g_entities; ; i += 199 )
      {
        result = v1;
        if ( v1 >= level[3] )
          break;
        if ( *((_BYTE *)i + 356) )
        {
          v5 = *(_WORD *)&(&off_84340)[4 * v3 + 1][(_DWORD)i];
          if ( v5 )
          {
            if ( v5 == v4 )
            {
              if ( v2 )
                Scr_Error("getent used with more than one entity");
              v2 = i;
            }
          }
        }
        ++v1;
      }
      if ( v2 )
        result = Scr_AddEntity(v2);
    }
  }
  return result;
}
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15660: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// 84340: using guessed type char *off_84340;

//----- (0006651B) --------------------------------------------------------
int Scr_GetEntArray()
{
  int result; // eax
  int v1; // [esp+8h] [ebp-20h]
  int v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+Ch] [ebp-1Ch]
  __int16 v4; // [esp+10h] [ebp-18h]
  __int16 v5; // [esp+12h] [ebp-16h]
  int v6; // [esp+14h] [ebp-14h]
  _DWORD *j; // [esp+1Ch] [ebp-Ch]
  _DWORD *i; // [esp+1Ch] [ebp-Ch]

  if ( Scr_GetNumParam() )
  {
    v4 = Scr_GetConstString(0);
    v6 = Scr_GetString(1);
    result = Scr_GetOffset((unsigned __int16)g_scr_data[210], v6);
    v3 = result;
    if ( result >= 0 )
    {
      result = (int)&(&off_84340)[4 * result];
      if ( *(_DWORD *)(result + 8) == 3 )
      {
        Scr_MakeArray();
        v2 = 0;
        for ( i = g_entities; ; i += 199 )
        {
          result = v2;
          if ( v2 >= level[3] )
            break;
          if ( *((_BYTE *)i + 356) )
          {
            v5 = *(_WORD *)&(&off_84340)[4 * v3 + 1][(_DWORD)i];
            if ( v5 )
            {
              if ( v5 == v4 )
              {
                Scr_AddEntity(i);
                Scr_AddArray();
              }
            }
          }
          ++v2;
        }
      }
    }
  }
  else
  {
    Scr_MakeArray();
    v1 = 0;
    for ( j = g_entities; ; j += 199 )
    {
      result = v1;
      if ( v1 >= level[3] )
        break;
      if ( *((_BYTE *)j + 356) )
      {
        Scr_AddEntity(j);
        Scr_AddArray();
      }
      ++v1;
    }
  }
  return result;
}
// 13CC0: using guessed type int Scr_AddArray(void);
// 14E20: using guessed type _DWORD __cdecl Scr_GetString(_DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);
// 152F0: using guessed type int Scr_GetNumParam(void);
// 15420: using guessed type _DWORD __cdecl Scr_GetConstString(_DWORD);
// 15660: using guessed type _DWORD __cdecl Scr_GetOffset(_DWORD, _DWORD);
// 15700: using guessed type int Scr_MakeArray(void);
// 84340: using guessed type char *off_84340;

//----- (00066677) --------------------------------------------------------
int __cdecl GScr_SetDynamicEntityField(_DWORD *a1, unsigned __int16 a2)
{
  return Scr_SetDynamicEntityField(*a1, 0, a2);
}
// 144C0: using guessed type _DWORD __cdecl Scr_SetDynamicEntityField(_DWORD, _DWORD, _DWORD);

//----- (000666B3) --------------------------------------------------------
int G_SpawnGEntityFromSpawnVars()
{
  return G_CallSpawn();
}
// 13B30: using guessed type int G_CallSpawn(void);

//----- (000666D0) --------------------------------------------------------
char *__cdecl G_AddSpawnVarToken(char *s)
{
  char v2; // [esp+4h] [ebp-14h]
  char *dest; // [esp+Ch] [ebp-Ch]
  size_t v4; // [esp+10h] [ebp-8h]

  v4 = strlen(s);
  if ( (int)(level[1628] + v4 + 1) > 2048 )
    G_Error("G_AddSpawnVarToken: MAX_SPAWN_VARS", v2);
  dest = (char *)&level[1629] + level[1628];
  memcpy(dest, s, v4 + 1);
  level[1628] += v4 + 1;
  return dest;
}
// 66710: variable 'v2' is possibly undefined

//----- (0006676F) --------------------------------------------------------
int G_ParseSpawnVars()
{
  int v0; // esi
  int v1; // esi
  char v3; // [esp+4h] [ebp-834h]
  char v4; // [esp+4h] [ebp-834h]
  char v6[1024]; // [esp+20h] [ebp-818h] BYREF
  char s[1048]; // [esp+420h] [ebp-418h] BYREF

  level[1499] = 0;
  level[1628] = 0;
  if ( !trap_GetEntityToken(v6, 1024) )
    return 0;
  if ( v6[0] != 123 )
    G_Error("G_ParseSpawnVars: found %s when expecting {", (char)v6);
  while ( 1 )
  {
    if ( !trap_GetEntityToken(s, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace", v3);
    if ( s[0] == 125 )
      break;
    if ( !trap_GetEntityToken(v6, 1024) )
      G_Error("G_ParseSpawnVars: EOF without closing brace", v4);
    if ( v6[0] == 125 )
      G_Error("G_ParseSpawnVars: closing brace without data", v4);
    if ( level[1499] == 64 )
      G_Error("G_ParseSpawnVars: MAX_SPAWN_VARS", v4);
    v0 = level[1499];
    level[2 * v0 + 1500] = G_AddSpawnVarToken(s);
    v1 = level[1499];
    level[2 * v1 + 1501] = G_AddSpawnVarToken(v6);
    ++level[1499];
  }
  return 1;
}
// 66814: variable 'v3' is possibly undefined
// 6684A: variable 'v4' is possibly undefined
// 13710: using guessed type _DWORD __cdecl trap_GetEntityToken(_DWORD, _DWORD);

//----- (000668FD) --------------------------------------------------------
_DWORD *SP_worldspawn()
{
  int v0; // eax
  int v1; // eax
  _DWORD *result; // eax
  char v3; // [esp+4h] [ebp-14h]
  char *nptr[3]; // [esp+Ch] [ebp-Ch] BYREF

  G_SpawnString("classname", (int)&unk_7E825, (int)nptr);
  if ( Q_stricmp(nptr[0], "worldspawn") )
    G_Error("SP_worldspawn: The first entity isn't 'worldspawn'", v3);
  trap_SetConfigstring(2, "cod");
  v0 = va("%i", level[125]);
  trap_SetConfigstring(13, v0);
  G_SpawnString("ambienttrack", (int)&unk_7E825, (int)nptr);
  if ( *nptr[0] )
  {
    v1 = va("n\\%s", (char)nptr[0]);
    trap_SetConfigstring(3, v1);
  }
  else
  {
    trap_SetConfigstring(3, &unk_7E825);
  }
  G_SpawnString("message", (int)&unk_7E825, (int)nptr);
  trap_SetConfigstring(4, nptr[0]);
  trap_SetConfigstring(14, (char *)&g_motd + 16);
  G_SpawnString("gravity", (int)"800", (int)nptr);
  trap_Cvar_Set("g_gravity", nptr[0]);
  G_SpawnString("northyaw", (int)&unk_7E825, (int)nptr);
  if ( *nptr[0] )
    trap_SetConfigstring(11, nptr[0]);
  else
    trap_SetConfigstring(11, "0");
  G_SpawnString("spawnflags", (int)"0", (int)nptr);
  *(int *)((char *)&dword_C6B48 + (_DWORD)g_entities) = atoi(nptr[0]);
  *(int *)((char *)&dword_C6B20 + (_DWORD)g_entities) = *(int *)((char *)&dword_C6B48 + (_DWORD)g_entities);
  *(int *)((char *)&dword_C69C8 + (_DWORD)g_entities) = 1022;
  Scr_SetString((char *)&unk_C6B44 + (_DWORD)g_entities, scr_const[78]);
  result = g_entities;
  byte_C6B2C[(_DWORD)g_entities] = 1;
  return result;
}
// 66951: variable 'v3' is possibly undefined
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// C69C8: using guessed type int dword_C69C8;
// C6B20: using guessed type int dword_C6B20;
// C6B48: using guessed type int dword_C6B48;

//----- (00066B66) --------------------------------------------------------
_DWORD *G_SpawnEntitiesFromString()
{
  _DWORD *result; // eax
  char v1; // [esp+4h] [ebp-4h]

  level[1498] = 1;
  level[1499] = 0;
  if ( !G_ParseSpawnVars() )
    G_Error("SpawnEntities: no entities", v1);
  SP_worldspawn();
  while ( G_ParseSpawnVars() )
    G_SpawnGEntityFromSpawnVars();
  result = level;
  level[1498] = 0;
  return result;
}
// 66BAA: variable 'v1' is possibly undefined
// 13F20: using guessed type int SP_worldspawn(void);
// 14050: using guessed type int G_ParseSpawnVars(void);
// 15160: using guessed type int G_SpawnGEntityFromSpawnVars(void);

//----- (00066BDC) --------------------------------------------------------
void sub_66BDC()
{
  ;
}

//----- (00066BE0) --------------------------------------------------------
int __cdecl sub_66BE0(char *a1, _DWORD *a2)
{
  _BYTE *v2; // esi
  int v5; // [esp+20h] [ebp-98h] BYREF
  int v6; // [esp+24h] [ebp-94h] BYREF
  int v7; // [esp+28h] [ebp-90h]
  int i; // [esp+2Ch] [ebp-8Ch]
  char nptr[136]; // [esp+30h] [ebp-88h] BYREF

  for ( i = 0; i <= 3; ++i )
  {
    *((_BYTE *)&v6 + i) = 0;
    *((_BYTE *)&v5 + i) = 0;
  }
  for ( i = 0; i <= 3; ++i )
  {
    if ( *a1 <= 47 || *a1 > 57 )
    {
      G_Printf("Bad filter address: %s\n", (char)a1);
      return 0;
    }
    v7 = 0;
    while ( *a1 > 47 && *a1 <= 57 )
      nptr[v7++] = *a1++;
    nptr[v7] = 0;
    v2 = (char *)&v6 + i;
    *v2 = atoi(nptr);
    if ( *((_BYTE *)&v6 + i) )
      *((_BYTE *)&v5 + i) = -1;
    if ( !*a1 )
      break;
    ++a1;
  }
  *a2 = v5;
  a2[1] = v6;
  return 1;
}

//----- (00066D58) --------------------------------------------------------
int sub_66D58()
{
  size_t v0; // edi
  size_t v1; // eax
  char s[1032]; // [esp+20h] [ebp-428h] BYREF
  int i; // [esp+428h] [ebp-20h]
  int v5; // [esp+42Ch] [ebp-1Ch]

  s[0] = 0;
  for ( i = 0; i < dword_A85E0; ++i )
  {
    if ( *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]) != -1 )
    {
      v5 = *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]);
      v0 = 1024 - strlen(s);
      v1 = strlen(s);
      Com_sprintf(&s[v1], v0, "%i.%i.%i.%i ", v5);
    }
  }
  return trap_Cvar_Set("g_banIPs", s);
}
// 0: using guessed type int dword_0[];
// 13440: using guessed type _DWORD __cdecl trap_Cvar_Set(_DWORD, _DWORD);
// A65E4: using guessed type int dword_A65E4;
// A85E0: using guessed type int dword_A85E0;

//----- (00066E3C) --------------------------------------------------------
_BOOL4 __cdecl G_FilterPacket(char *a1)
{
  int v4; // [esp+8h] [ebp-10h] BYREF
  int v5; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  i = 0;
  while ( *a1 && i <= 3 )
  {
    *((_BYTE *)&v4 + i) = 0;
    while ( *a1 > 47 && *a1 <= 57 )
      *((_BYTE *)&v4 + i) = *a1++ + 10 * *((_BYTE *)&v4 + i) - 48;
    if ( !*a1 || *a1 == 58 )
      break;
    ++i;
    ++a1;
  }
  v5 = v4;
  for ( i = 0; i < dword_A85E0; ++i )
  {
    if ( (*(int *)((_BYTE *)&dword_A65E0 + (_DWORD)&dword_0[2 * i]) & v5) == *(int *)((char *)&dword_A65E4
                                                                                    + (_DWORD)&dword_0[2 * i]) )
      return g_filterBan[3] != 0;
  }
  return g_filterBan[3] == 0;
}
// 0: using guessed type int dword_0[];
// A65E0: using guessed type int dword_A65E0;
// A65E4: using guessed type int dword_A65E4;
// A85E0: using guessed type int dword_A85E0;

//----- (00066F3C) --------------------------------------------------------
int __cdecl sub_66F3C(char *a1)
{
  char v2; // [esp+4h] [ebp-14h]
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i < dword_A85E0 && *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]) != -1; ++i )
    ;
  if ( i == dword_A85E0 )
  {
    if ( dword_A85E0 == 1024 )
      return G_Printf("IP filter list is full\n", v2);
    ++dword_A85E0;
  }
  if ( !sub_66BE0(a1, &dword_A65E0[2 * i]) )
    *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]) = -1;
  return sub_66D58();
}
// 66F98: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0[];
// A65E0: using guessed type int dword_A65E0[];
// A65E4: using guessed type int dword_A65E4;
// A85E0: using guessed type int dword_A85E0;

//----- (00066FE3) --------------------------------------------------------
char *G_ProcessIPBans()
{
  char *result; // eax
  char dest[1032]; // [esp+10h] [ebp-418h] BYREF
  char *i; // [esp+418h] [ebp-10h]
  char *s; // [esp+41Ch] [ebp-Ch]

  dword_A85E0 = 0;
  Q_strncpyz(dest, &g_banIPs[16], 1024);
  s = &g_banIPs[16];
  for ( i = &g_banIPs[16]; ; i = s )
  {
    result = i;
    if ( !*i )
      break;
    result = strchr(s, 32);
    s = result;
    if ( !result )
      break;
    while ( *s == 32 )
      *s++ = 0;
    if ( *i )
      sub_66F3C(i);
  }
  return result;
}
// A85E0: using guessed type int dword_A85E0;

//----- (00067098) --------------------------------------------------------
int Svcmd_AddIP_f()
{
  char v1; // [esp+4h] [ebp-414h]
  char v2[1032]; // [esp+10h] [ebp-408h] BYREF

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  addip <ip-mask>\n", v1);
  trap_Argv(1, v2, 1024);
  return sub_66F3C(v2);
}
// 670C0: variable 'v1' is possibly undefined
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);

//----- (000670FC) --------------------------------------------------------
int Svcmd_RemoveIP_f()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-424h]
  char v2; // [esp+4h] [ebp-424h]
  char v3[1028]; // [esp+10h] [ebp-418h] BYREF
  int i; // [esp+414h] [ebp-14h]
  char v5[4]; // [esp+418h] [ebp-10h] BYREF
  int v6; // [esp+41Ch] [ebp-Ch]

  if ( trap_Argc() <= 1 )
    return G_Printf("Usage:  sv removeip <ip-mask>\n", v1);
  trap_Argv(1, v3, 1024);
  result = sub_66BE0(v3, v5);
  if ( result )
  {
    for ( i = 0; i < dword_A85E0; ++i )
    {
      if ( *(int *)((char *)dword_A65E0 + (_DWORD)&dword_0[2 * i]) == *(_DWORD *)v5
        && *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]) == v6 )
      {
        *(int *)((char *)&dword_A65E4 + (_DWORD)&dword_0[2 * i]) = -1;
        G_Printf("Removed.\n", v2);
        return sub_66D58();
      }
    }
    result = G_Printf("Didn't find %s.\n", (char)v3);
  }
  return result;
}
// 67124: variable 'v1' is possibly undefined
// 671B0: variable 'v2' is possibly undefined
// 0: using guessed type int dword_0[];
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 144A0: using guessed type int trap_Argc(void);
// A65E0: using guessed type int dword_A65E0[];
// A65E4: using guessed type int dword_A65E4;
// A85E0: using guessed type int dword_A85E0;

//----- (000671E4) --------------------------------------------------------
int Svcmd_EntityList_f()
{
  int result; // eax
  char v1; // al
  char v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+4h] [ebp-14h]
  _DWORD *v4; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  v4 = &g_entities[199];
  for ( i = 1; ; ++i )
  {
    result = i;
    if ( i >= level[3] )
      break;
    if ( *((_BYTE *)v4 + 356) )
    {
      G_Printf("%3i:", i);
      switch ( v4[1] )
      {
        case 0:
          G_Printf("ET_GENERAL          ", v2);
          break;
        case 1:
          G_Printf("ET_PLAYER           ", v2);
          break;
        case 3:
          G_Printf("ET_ITEM             ", v2);
          break;
        case 4:
          G_Printf("ET_MISSILE          ", v2);
          break;
        case 5:
          G_Printf("ET_MOVER            ", v2);
          break;
        case 6:
          G_Printf("ET_PORTAL           ", v2);
          break;
        case 7:
          G_Printf("ET_INVISIBLE        ", v2);
          break;
        case 8:
          G_Printf("ET_SCRIPTMOVER      ", v2);
          break;
        default:
          G_Printf("%3i                 ", v4[1]);
          break;
      }
      if ( *((_WORD *)v4 + 190) )
      {
        v1 = SL_ConvertToString(*((unsigned __int16 *)v4 + 190));
        G_Printf("%s", v1);
      }
      G_Printf("\n", v3);
    }
    v4 += 199;
  }
  return result;
}
// 67275: variable 'v2' is possibly undefined
// 67341: variable 'v3' is possibly undefined
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (0006735F) --------------------------------------------------------
int __cdecl ClientForString(char *nptr)
{
  int v2; // [esp+14h] [ebp-14h]
  int v3; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v5; // [esp+20h] [ebp-8h]

  if ( *nptr <= 47 || *nptr > 57 )
  {
    for ( i = 0; i < level[120]; ++i )
    {
      v5 = level[0] + 8908 * i;
      if ( *(_DWORD *)(v5 + 8424) && !Q_stricmp(v5 + 8636, nptr) )
        return v5;
    }
    G_Printf("User %s is not on the server\n", (char)nptr);
    v2 = 0;
  }
  else
  {
    v3 = atoi(nptr);
    if ( v3 >= 0 && v3 < level[120] )
    {
      if ( *(_DWORD *)(level[0] + 8908 * v3 + 8424) )
      {
        v2 = level[0] + 8908 * v3;
      }
      else
      {
        G_Printf("Client %i is not connected\n", v3);
        v2 = 0;
      }
    }
    else
    {
      Com_Printf("Bad client slot: %i\n", v3);
      v2 = 0;
    }
  }
  return v2;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (000674A8) --------------------------------------------------------
int ConsoleCommand()
{
  char v0; // al
  int v1; // eax
  int v3; // [esp+1Ch] [ebp-40Ch]
  char v4[1032]; // [esp+20h] [ebp-408h] BYREF

  trap_Argv(0, v4, 1024);
  if ( Q_stricmp(v4, "entitylist") )
  {
    if ( Q_stricmp(v4, "addip") )
    {
      if ( Q_stricmp(v4, "removeip") )
      {
        if ( Q_stricmp(v4, "listip") )
        {
          if ( !g_dedicated[3] || Q_stricmp(v4, "say") )
          {
            v3 = 0;
          }
          else
          {
            v0 = ConcatArgs(1);
            v1 = va(aEGameServer_0, v0);
            trap_SendServerCommand(-1, 0, v1);
            v3 = 1;
          }
        }
        else
        {
          trap_SendConsoleCommand(1, "g_banIPs\n");
          v3 = 1;
        }
      }
      else
      {
        Svcmd_RemoveIP_f();
        v3 = 1;
      }
    }
    else
    {
      Svcmd_AddIP_f();
      v3 = 1;
    }
  }
  else
  {
    Svcmd_EntityList_f();
    v3 = 1;
  }
  return v3;
}
// 13850: using guessed type int Svcmd_RemoveIP_f(void);
// 14020: using guessed type _DWORD __cdecl trap_Argv(_DWORD, _DWORD, _DWORD);
// 14410: using guessed type int Svcmd_AddIP_f(void);
// 14520: using guessed type _DWORD __cdecl trap_SendServerCommand(_DWORD, _DWORD, _DWORD);
// 149C0: using guessed type _DWORD __cdecl trap_SendConsoleCommand(_DWORD, _DWORD);
// 14BC0: using guessed type int Svcmd_EntityList_f(void);
// 14D10: using guessed type _DWORD __cdecl ConcatArgs(_DWORD);
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006762C) --------------------------------------------------------
void sub_6762C()
{
  ;
}

//----- (00067630) --------------------------------------------------------
int __cdecl dllEntry(int a1)
{
  int result; // eax

  result = a1;
  dword_84660 = a1;
  return result;
}
// 84660: using guessed type int dword_84660;

//----- (0006764B) --------------------------------------------------------
long double __cdecl sub_6764B(float a1)
{
  return a1;
}

//----- (00067662) --------------------------------------------------------
int __cdecl PASSFLOAT(int a1)
{
  return a1;
}

//----- (00067673) --------------------------------------------------------
int __cdecl trap_Printf(int a1)
{
  return dword_84660(0, a1);
}
// 84660: invalid function type has been ignored
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000676A1) --------------------------------------------------------
int __cdecl trap_Error(int a1)
{
  return dword_84660(1, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000676CF) --------------------------------------------------------
int __cdecl trap_Error_Localized(int a1)
{
  return dword_84660(2, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000676FD) --------------------------------------------------------
int trap_Milliseconds()
{
  return ((int (__cdecl *)(int))dword_84660)(3);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067724) --------------------------------------------------------
int trap_Argc()
{
  return ((int (__cdecl *)(int))dword_84660)(10);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006774B) --------------------------------------------------------
int __cdecl trap_Argv(int a1)
{
  return dword_84660(11, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067787) --------------------------------------------------------
int __cdecl trap_Hunk_AllocInternal(int a1)
{
  return dword_84660(12, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000677B5) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowInternal(int a1)
{
  return dword_84660(13, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000677E3) --------------------------------------------------------
int __cdecl trap_Hunk_AllocAlignInternal(int a1)
{
  return dword_84660(14, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067818) --------------------------------------------------------
int __cdecl trap_Hunk_AllocLowAlignInternal(int a1)
{
  return dword_84660(15, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006784D) --------------------------------------------------------
int __cdecl trap_Hunk_AllocateTempMemoryInternal(int a1)
{
  return dword_84660(16, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006787B) --------------------------------------------------------
int __cdecl trap_Hunk_FreeTempMemoryInternal(int a1)
{
  return dword_84660(17, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000678A9) --------------------------------------------------------
int __cdecl trap_FS_FOpenFile(int a1)
{
  return dword_84660(18, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000678E5) --------------------------------------------------------
int __cdecl trap_FS_Read(int a1)
{
  return dword_84660(19, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067921) --------------------------------------------------------
int __cdecl trap_FS_Write(int a1)
{
  return dword_84660(20, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006795D) --------------------------------------------------------
int __cdecl trap_FS_Rename(int a1)
{
  return dword_84660(21, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067992) --------------------------------------------------------
int __cdecl trap_FS_FCloseFile(int a1)
{
  return dword_84660(22, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000679C0) --------------------------------------------------------
int __cdecl trap_FS_GetFileList(int a1)
{
  return dword_84660(59, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067A03) --------------------------------------------------------
int __cdecl trap_MapExists(int a1)
{
  return dword_84660(60, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067A31) --------------------------------------------------------
int __cdecl trap_SendConsoleCommand(int a1)
{
  return dword_84660(23, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067A66) --------------------------------------------------------
int __cdecl trap_Cvar_Register(int a1)
{
  return dword_84660(4, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067AA9) --------------------------------------------------------
int __cdecl trap_Cvar_Update(int a1)
{
  return dword_84660(5, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067AD7) --------------------------------------------------------
int __cdecl trap_Cvar_Set(int a1)
{
  return dword_84660(6, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067B0C) --------------------------------------------------------
int __cdecl trap_Cvar_VariableIntegerValue(int a1)
{
  return dword_84660(7, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067B3A) --------------------------------------------------------
long double __cdecl trap_Cvar_VariableValue(int a1)
{
  float v2; // [esp+10h] [ebp-8h]

  dword_84660(8, a1);
  return v2;
}
// 67B6F: variable 'v2' is possibly undefined
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067B78) --------------------------------------------------------
int __cdecl trap_Cvar_VariableStringBuffer(int a1)
{
  return dword_84660(9, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067BB4) --------------------------------------------------------
int __cdecl trap_LocateGameData(int a1)
{
  return dword_84660(24, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067BFE) --------------------------------------------------------
int __cdecl trap_GetGuid(int a1)
{
  return dword_84660(25, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067C2C) --------------------------------------------------------
int __cdecl trap_DropClient(int a1)
{
  return dword_84660(26, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067C61) --------------------------------------------------------
int __cdecl trap_SendServerCommand(int a1)
{
  return dword_84660(27, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067C9D) --------------------------------------------------------
int __cdecl trap_SetConfigstring(int a1)
{
  return dword_84660(28, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067CD2) --------------------------------------------------------
int __cdecl trap_GetConfigstring(int a1)
{
  return dword_84660(29, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067D0E) --------------------------------------------------------
int __cdecl trap_GetConfigstringConst(int a1)
{
  return dword_84660(30, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067D3C) --------------------------------------------------------
int __cdecl trap_IsLocalClient(int a1)
{
  return dword_84660(31, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067D6A) --------------------------------------------------------
int __cdecl trap_GetClientPing(int a1)
{
  return dword_84660(32, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067D98) --------------------------------------------------------
int __cdecl trap_GetUserinfo(int a1)
{
  return dword_84660(33, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067DD4) --------------------------------------------------------
int __cdecl trap_SetUserinfo(int a1)
{
  return dword_84660(34, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067E09) --------------------------------------------------------
int __cdecl trap_GetServerinfo(int a1)
{
  return dword_84660(35, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067E3E) --------------------------------------------------------
int __cdecl trap_SetBrushModel(int a1)
{
  return dword_84660(36, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067E6C) --------------------------------------------------------
int __cdecl trap_Trace(int a1)
{
  return dword_84660(37, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067EC4) --------------------------------------------------------
int __cdecl trap_TraceCapsule(int a1)
{
  return dword_84660(38, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067F1C) --------------------------------------------------------
int __cdecl trap_SightTrace(int a1)
{
  return dword_84660(39, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067F7B) --------------------------------------------------------
int __cdecl trap_SightTraceCapsule(int a1)
{
  return dword_84660(40, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00067FDA) --------------------------------------------------------
int __cdecl trap_SightTraceToEntity(int a1)
{
  return dword_84660(41, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006802B) --------------------------------------------------------
int __cdecl trap_CM_BoxTrace(int a1)
{
  return dword_84660(42, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068083) --------------------------------------------------------
int __cdecl trap_CM_CapsuleTrace(int a1)
{
  return dword_84660(43, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000680DB) --------------------------------------------------------
int __cdecl trap_CM_BoxSightTrace(int a1)
{
  return dword_84660(44, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006812C) --------------------------------------------------------
int __cdecl trap_CM_CapsuleSightTrace(int a1)
{
  return dword_84660(45, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006817D) --------------------------------------------------------
int __cdecl trap_LocationalTrace(int a1)
{
  return dword_84660(46, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000681CE) --------------------------------------------------------
int __cdecl trap_PointContents(int a1)
{
  return dword_84660(47, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006820A) --------------------------------------------------------
int __cdecl trap_InPVS(int a1)
{
  return dword_84660(48, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006823F) --------------------------------------------------------
int __cdecl trap_InPVSIgnorePortals(int a1)
{
  return dword_84660(49, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068274) --------------------------------------------------------
int __cdecl trap_InSnapshot(int a1)
{
  return dword_84660(50, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000682A9) --------------------------------------------------------
int __cdecl trap_AdjustAreaPortalState(int a1)
{
  return dword_84660(51, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000682DE) --------------------------------------------------------
int __cdecl trap_AreasConnected(int a1)
{
  return dword_84660(52, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068313) --------------------------------------------------------
int __cdecl trap_LinkEntity(int a1)
{
  return dword_84660(53, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068341) --------------------------------------------------------
int __cdecl trap_UnlinkEntity(int a1)
{
  return dword_84660(54, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006836F) --------------------------------------------------------
int __cdecl trap_EntitiesInBox(int a1)
{
  return dword_84660(55, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000683B9) --------------------------------------------------------
int __cdecl trap_EntityContact(int a1)
{
  return dword_84660(56, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000683F5) --------------------------------------------------------
int __cdecl trap_EntityContactCapsule(int a1)
{
  return dword_84660(63, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068431) --------------------------------------------------------
int __cdecl trap_GetUsercmd(int a1)
{
  return dword_84660(57, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068466) --------------------------------------------------------
int __cdecl trap_GetEntityToken(int a1)
{
  return dword_84660(58, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006849B) --------------------------------------------------------
int __cdecl trap_AddDebugString(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, int, int, int))dword_84660)(71, a1, a2, v4, a4);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000684E8) --------------------------------------------------------
int __cdecl trap_AddDebugLine(int a1)
{
  return dword_84660(72, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068532) --------------------------------------------------------
int __cdecl trap_SetArchive(int a1)
{
  return dword_84660(73, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068560) --------------------------------------------------------
int __cdecl trap_RealTime(int a1)
{
  return dword_84660(61, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006858E) --------------------------------------------------------
int __cdecl trap_SnapVector(int a1)
{
  return dword_84660(62, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000685BC) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasString(int a1)
{
  return dword_84660(64, a1);
}
// 685BC: using guessed type int __cdecl trap_Com_SoundAliasString(int);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000685EA) --------------------------------------------------------
int __cdecl trap_Com_PickSoundAlias(int a1)
{
  return dword_84660(65, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068618) --------------------------------------------------------
int __cdecl trap_Com_SoundAliasIndex(int a1)
{
  return dword_84660(66, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068646) --------------------------------------------------------
int __cdecl trap_SurfaceTypeFromName(int a1)
{
  return dword_84660(67, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068674) --------------------------------------------------------
int __cdecl trap_SurfaceTypeToName(int a1)
{
  return dword_84660(68, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000686A2) --------------------------------------------------------
int __cdecl trap_Z_MallocInternal(int a1)
{
  return dword_84660(74, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000686D0) --------------------------------------------------------
int __cdecl trap_Z_FreeInternal(int a1)
{
  return dword_84660(75, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000686FE) --------------------------------------------------------
int trap_AddTestClient()
{
  int v1; // [esp+Ch] [ebp-Ch]
  int v2; // [esp+10h] [ebp-8h]

  v2 = ((int (__cdecl *)(int))dword_84660)(69);
  if ( v2 < 0 )
    v1 = 0;
  else
    v1 = 796 * v2 + level[1];
  return v1;
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068751) --------------------------------------------------------
int __cdecl trap_GetArchivedClientInfo(int a1)
{
  return dword_84660(70, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068794) --------------------------------------------------------
int __cdecl trap_XAnimCreateTree(int a1)
{
  return dword_84660(76, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000687C2) --------------------------------------------------------
int __cdecl trap_XAnimCreateSmallTree(int a1)
{
  return dword_84660(77, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000687F0) --------------------------------------------------------
int __cdecl trap_XAnimFreeSmallTree(int a1)
{
  return dword_84660(78, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006881E) --------------------------------------------------------
int __cdecl trap_XModelExists(int a1)
{
  return dword_84660(79, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006884C) --------------------------------------------------------
int __cdecl trap_XModelGet(int a1)
{
  return dword_84660(80, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006887A) --------------------------------------------------------
int __cdecl trap_DObjCreate(int a1)
{
  return dword_84660(81, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000688D4) --------------------------------------------------------
int __cdecl trap_SafeDObjFree(int a1)
{
  return dword_84660(83, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068909) --------------------------------------------------------
int __cdecl trap_DObjExists(_DWORD *a1)
{
  return dword_84660(82, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068939) --------------------------------------------------------
int __cdecl trap_XAnimGetAnims(int a1)
{
  return dword_84660(84, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068967) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetRoot@<eax>(_DWORD *a1, int a2)
{
  int v2; // eax
  int v4; // [esp+Ch] [ebp-Ch]

  LOWORD(v4) = 0;
  v2 = trap_XAnimGetAnims(a2);
  HIWORD(v4) = Scr_GetAnimsIndex(v2);
  *a1 = v4;
  return a1;
}
// 130B0: using guessed type _DWORD __cdecl trap_XAnimGetAnims(_DWORD);
// 13F50: using guessed type _DWORD __cdecl Scr_GetAnimsIndex(_DWORD);

//----- (000689AA) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeights(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_84660)(86, a1, a2, v3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000689EF) --------------------------------------------------------
int __cdecl trap_XAnimClearGoalWeight(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_84660)(87, a1, a2, v3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068A34) --------------------------------------------------------
int __cdecl trap_XAnimClearTreeGoalWeightsStrict(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_84660)(88, a1, a2, v3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068A79) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_84660)(89, a1, a2, v9, v8, v7, a6, a7);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068AFC) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeightKnobAll(int a1, unsigned __int16 a2, unsigned __int16 a3, int a4, int a5, int a6, unsigned __int16 a7, int a8)
{
  int v8; // edi
  int v9; // esi
  int v10; // eax

  v8 = PASSFLOAT(a6);
  v9 = PASSFLOAT(a5);
  v10 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, int, _DWORD, _DWORD, int, int, int, _DWORD, int))dword_84660)(
           90,
           a1,
           a2,
           a3,
           v10,
           v9,
           v8,
           a7,
           a8);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068B87) --------------------------------------------------------
int __cdecl trap_XAnimSetAnimRate(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_84660)(91, a1, a2, v3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068BCC) --------------------------------------------------------
int __cdecl trap_XAnimSetTime(int a1, unsigned __int16 a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int))dword_84660)(92, a1, a2, v3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068C11) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeightKnob(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_84660)(93, a1, a2, v9, v8, v7, a6, a7);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068C94) --------------------------------------------------------
int __cdecl trap_XAnimClearTree(int a1)
{
  return dword_84660(94, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068CC2) --------------------------------------------------------
int __cdecl trap_XAnimHasTime(int a1)
{
  return dword_84660(95, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068CF9) --------------------------------------------------------
int __cdecl trap_XAnimIsPrimitive(int a1)
{
  return dword_84660(96, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068D30) --------------------------------------------------------
int __cdecl trap_XAnimGetLength(int a1)
{
  return dword_84660(97, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068D6D) --------------------------------------------------------
long double __cdecl trap_XAnimGetLengthSeconds(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_84660(98, HIWORD(a1)));
  return (float)sub_6764B(v1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068DB8) --------------------------------------------------------
int __cdecl trap_XAnimSetCompleteGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_84660)(99, a1, a2, v9, v8, v7, a6, a7);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068E3B) --------------------------------------------------------
int __cdecl trap_XAnimSetGoalWeight(int a1, unsigned __int16 a2, int a3, int a4, int a5, unsigned __int16 a6, int a7)
{
  int v7; // edi
  int v8; // esi
  int v9; // eax

  v7 = PASSFLOAT(a5);
  v8 = PASSFLOAT(a4);
  v9 = PASSFLOAT(a3);
  return ((int (__cdecl *)(int, int, _DWORD, int, int, int, _DWORD, int))dword_84660)(100, a1, a2, v9, v8, v7, a6, a7);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068EBE) --------------------------------------------------------
int __cdecl trap_XAnimCalcAbsDelta(int a1)
{
  return dword_84660(101, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068F02) --------------------------------------------------------
int __cdecl trap_XAnimCalcDelta(int a1)
{
  return dword_84660(102, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068F4D) --------------------------------------------------------
int __cdecl trap_XAnimGetRelDelta(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi
  int v6; // eax

  v5 = PASSFLOAT(a5);
  v6 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, _DWORD, _DWORD, int, int, int, int))dword_84660)(
           103,
           HIWORD(a1),
           (unsigned __int16)a1,
           a2,
           a3,
           v6,
           v5);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00068FB4) --------------------------------------------------------
int __cdecl trap_XAnimGetAbsDelta(int a1, int a2, int a3, int a4)
{
  int v4; // eax

  v4 = PASSFLOAT(a4);
  return ((int (__cdecl *)(int, _DWORD, _DWORD, int, int, int))dword_84660)(
           104,
           HIWORD(a1),
           (unsigned __int16)a1,
           a2,
           a3,
           v4);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069008) --------------------------------------------------------
int __cdecl trap_XAnimIsLooped(int a1)
{
  return dword_84660(105, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006903F) --------------------------------------------------------
int __cdecl trap_XAnimNotetrackExists(int a1)
{
  return dword_84660(106, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069085) --------------------------------------------------------
long double __cdecl trap_XAnimGetTime(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_84660(107, a1));
  return (float)sub_6764B(v1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000690CF) --------------------------------------------------------
long double __cdecl trap_XAnimGetWeight(int a1)
{
  float v1; // eax

  v1 = COERCE_FLOAT(dword_84660(108, a1));
  return (float)sub_6764B(v1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069119) --------------------------------------------------------
int __cdecl trap_DObjDumpInfo(_DWORD *a1)
{
  return dword_84660(109, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069149) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBone(_DWORD *a1)
{
  return dword_84660(110, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069180) --------------------------------------------------------
int __cdecl trap_DObjCreateSkelForBones(_DWORD *a1)
{
  return dword_84660(111, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000691B7) --------------------------------------------------------
int __cdecl trap_DObjUpdateServerTime(_DWORD *a1, int a2, int a3)
{
  int v3; // eax

  v3 = PASSFLOAT(a2);
  return ((int (__cdecl *)(int, _DWORD, int, int))dword_84660)(112, *a1, v3, a3);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000691FF) --------------------------------------------------------
int __cdecl trap_DObjInitServerTime(_DWORD *a1, int a2)
{
  int v2; // eax

  v2 = PASSFLOAT(a2);
  return ((int (__cdecl *)(int, _DWORD, int))dword_84660)(113, *a1, v2);
}
// 146F0: using guessed type _DWORD __cdecl PASSFLOAT(_DWORD);
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006923E) --------------------------------------------------------
int __cdecl trap_DObjGetHierarchyBits(_DWORD *a1)
{
  return dword_84660(114, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006927C) --------------------------------------------------------
int __cdecl trap_DObjCalcAnim(_DWORD *a1)
{
  return dword_84660(115, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000692B3) --------------------------------------------------------
int __cdecl trap_DObjCalcSkel(_DWORD *a1)
{
  return dword_84660(116, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000692EA) --------------------------------------------------------
int __cdecl trap_XAnimLoadAnimTree(int a1)
{
  return dword_84660(117, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069318) --------------------------------------------------------
int __cdecl trap_XAnimSaveAnimTree(int a1)
{
  return dword_84660(118, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069346) --------------------------------------------------------
int __cdecl trap_XAnimCloneAnimTree(int a1)
{
  return dword_84660(119, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006937B) --------------------------------------------------------
int __cdecl trap_DObjNumBones(_DWORD *a1)
{
  return dword_84660(120, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000693AB) --------------------------------------------------------
int __cdecl trap_DObjGetBoneIndex(_DWORD *a1)
{
  return dword_84660(121, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000693E2) --------------------------------------------------------
int __cdecl trap_DObjGetMatrixArray(_DWORD *a1)
{
  return dword_84660(122, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069412) --------------------------------------------------------
int __cdecl trap_DObjDisplayAnim(_DWORD *a1)
{
  return dword_84660(123, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069442) --------------------------------------------------------
int __cdecl trap_XAnimHasFinished(int a1)
{
  return dword_84660(124, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069478) --------------------------------------------------------
int __cdecl trap_XAnimGetNumChildren(int a1)
{
  return dword_84660(125, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000694AF) --------------------------------------------------------
_DWORD *__userpurge trap_XAnimGetChildAt@<eax>(_DWORD *a1, int a2)
{
  LOWORD(a2) = dword_84660(126, HIWORD(a2));
  *a1 = a2;
  return a1;
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000694FF) --------------------------------------------------------
int __cdecl trap_XModelNumBones(int a1)
{
  return dword_84660(127, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006952D) --------------------------------------------------------
int __cdecl trap_XModelGetBoneNames(int a1)
{
  return dword_84660(128, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006955B) --------------------------------------------------------
int __cdecl trap_DObjGetRotTransArray(_DWORD *a1)
{
  return dword_84660(129, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006958B) --------------------------------------------------------
int __cdecl trap_DObjSetRotTransIndex(_DWORD *a1)
{
  return dword_84660(130, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000695C9) --------------------------------------------------------
int __cdecl trap_DObjSetControlRotTransIndex(_DWORD *a1)
{
  return dword_84660(131, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069607) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimName(int a1)
{
  return dword_84660(132, HIWORD(a1));
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006963E) --------------------------------------------------------
int __cdecl trap_DObjGetTree(_DWORD *a1)
{
  return dword_84660(133, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006966E) --------------------------------------------------------
int __cdecl trap_XAnimGetAnimTreeSize(int a1)
{
  return dword_84660(134, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006969C) --------------------------------------------------------
int __cdecl trap_XModelDebugBoxes(_DWORD *a1)
{
  return dword_84660(135, *a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (000696CC) --------------------------------------------------------
int __cdecl trap_GetWeaponInfoMemory(int a1)
{
  return dword_84660(136, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069701) --------------------------------------------------------
int __cdecl trap_FreeWeaponInfoMemory(int a1)
{
  return dword_84660(137, a1);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006972F) --------------------------------------------------------
int trap_FreeClientScriptPers()
{
  return ((int (__cdecl *)(int))dword_84660)(138);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (00069756) --------------------------------------------------------
int trap_ResetEntityParsePoint()
{
  return ((int (__cdecl *)(int))dword_84660)(139);
}
// 84660: using guessed type int (__cdecl *dword_84660)(_DWORD, _DWORD);

//----- (0006977D) --------------------------------------------------------
void sub_6977D()
{
  ;
}

//----- (00069784) --------------------------------------------------------
_DWORD *target_location_linkup()
{
  _DWORD *result; // eax
  int v1; // eax
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *v3; // [esp+10h] [ebp-8h]
  _DWORD *v5; // [esp+20h] [ebp+8h]

  result = level;
  if ( !level[2142] )
  {
    level[2142] = 1;
    level[2143] = 0;
    trap_SetConfigstring(44, "unknown");
    v3 = 0;
    v5 = g_entities;
    v2 = 1;
    while ( 1 )
    {
      result = v3;
      if ( (int)v3 >= level[3] )
        break;
      if ( *((_WORD *)v5 + 190) == scr_const[67] )
      {
        v5[142] = v2;
        v1 = SL_ConvertToString(*((unsigned __int16 *)v5 + 232));
        trap_SetConfigstring(v2 + 44, v1);
        ++v2;
        v5[105] = level[2143];
        level[2143] = v5;
      }
      v3 = (_DWORD *)((char *)v3 + 1);
      v5 += 199;
    }
  }
  return result;
}
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);

//----- (00069893) --------------------------------------------------------
int __cdecl SP_target_location(int a1)
{
  Scr_SetString(a1 + 380, scr_const[67]);
  *(_DWORD *)(a1 + 520) = target_location_linkup;
  *(_DWORD *)(a1 + 516) = level[122] + 200;
  return G_SetOrigin(a1, a1 + 312);
}
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006990C) --------------------------------------------------------
void sub_6990C()
{
  ;
}

//----- (00069910) --------------------------------------------------------
_BOOL4 __cdecl OnSameTeam(int a1, int a2)
{
  if ( !*(_DWORD *)(a1 + 348) || !*(_DWORD *)(a2 + 348) )
    return 0;
  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) )
    return *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) == *(_DWORD *)(*(_DWORD *)(a2 + 348) + 8580);
  return 0;
}

//----- (00069987) --------------------------------------------------------
_BOOL4 __cdecl InSameSquad(int a1, int a2)
{
  if ( !OnSameTeam(a1, a2) )
    return 0;
  if ( *(_WORD *)(*(_DWORD *)(a1 + 348) + 8572) )
    return *(_WORD *)(*(_DWORD *)(a1 + 348) + 8572) == *(_WORD *)(*(_DWORD *)(a2 + 348) + 8572);
  return 0;
}
// 13880: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);

//----- (00069A0F) --------------------------------------------------------
int __cdecl Team_GetLocation(int *a1)
{
  float v2; // [esp+10h] [ebp-28h] BYREF
  float v3; // [esp+14h] [ebp-24h]
  float v4; // [esp+18h] [ebp-20h]
  float v5; // [esp+20h] [ebp-18h]
  float v6; // [esp+24h] [ebp-14h]
  int v7; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  v7 = 0;
  v6 = 201326590.0;
  v2 = *((float *)a1 + 78);
  v3 = *((float *)a1 + 79);
  v4 = *((float *)a1 + 80);
  for ( i = level[2143]; i; i = *(_DWORD *)(i + 420) )
  {
    v5 = (v2 - *(float *)(i + 312)) * (v2 - *(float *)(i + 312))
       + (v3 - *(float *)(i + 316)) * (v3 - *(float *)(i + 316))
       + (v4 - *(float *)(i + 320)) * (v4 - *(float *)(i + 320));
    if ( v5 <= (long double)v6 )
    {
      if ( trap_InPVS(&v2, i + 312) )
      {
        v6 = v5;
        v7 = i;
      }
    }
  }
  return v7;
}
// 148B0: using guessed type _DWORD __cdecl trap_InPVS(_DWORD, _DWORD);

//----- (00069B14) --------------------------------------------------------
int __cdecl Team_GetLocationMsg(int a1, char *s, size_t maxlen)
{
  char v3; // al
  int v6; // [esp+20h] [ebp-8h]

  v6 = Team_GetLocation(a1);
  if ( !v6 )
    return 0;
  if ( *(_DWORD *)(v6 + 600) )
  {
    if ( *(int *)(v6 + 600) < 0 )
      *(_DWORD *)(v6 + 600) = 0;
    if ( *(int *)(v6 + 600) > 7 )
      *(_DWORD *)(v6 + 600) = 7;
    SL_ConvertToString(*(unsigned __int16 *)(v6 + 464));
    Com_sprintf(s, maxlen, byte_7EE43, 94);
  }
  else
  {
    v3 = SL_ConvertToString(*(unsigned __int16 *)(v6 + 464));
    Com_sprintf(s, maxlen, byte_7EE4F, v3);
  }
  return 1;
}
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15A00: using guessed type _DWORD __cdecl Team_GetLocation(_DWORD);

//----- (00069C12) --------------------------------------------------------
int __cdecl TeamplayInfoMessage(int a1)
{
  int result; // eax
  float v2[9]; // [esp+30h] [ebp-B8h] BYREF
  float v3; // [esp+54h] [ebp-94h]
  float v4; // [esp+58h] [ebp-90h]
  float v5; // [esp+5Ch] [ebp-8Ch]
  char v6[40]; // [esp+70h] [ebp-78h] BYREF
  unsigned __int16 v7; // [esp+98h] [ebp-50h]
  float v8; // [esp+A0h] [ebp-48h] BYREF
  float v9; // [esp+A4h] [ebp-44h]
  float v10; // [esp+A8h] [ebp-40h]
  float v11; // [esp+B0h] [ebp-38h] BYREF
  float v12; // [esp+B4h] [ebp-34h]
  float v13; // [esp+B8h] [ebp-30h]
  float v14[6]; // [esp+C0h] [ebp-28h] BYREF
  int v15; // [esp+D8h] [ebp-10h]
  int v16; // [esp+DCh] [ebp-Ch]

  if ( *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8396) )
  {
    AngleVectors(*(_DWORD *)(a1 + 348) + 192, v14, 0, 0);
    CalcMuzzlePoint(a1, &v11);
    if ( *(float *)(*(_DWORD *)(a1 + 348) + 208) < 8.0 )
      v13 = 8.0 - *(float *)(*(_DWORD *)(a1 + 348) + 208) + v13;
    v8 = v14[0] * 8192.0 + v11;
    v9 = v14[1] * 8192.0 + v12;
    v10 = v14[2] * 8192.0 + v13;
  }
  else
  {
    if ( !*(_DWORD *)(*(_DWORD *)(a1 + 348) + 8580) )
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 348) + 256) = -1;
      result = *(_DWORD *)(a1 + 348);
      *(_DWORD *)(result + 260) = 0;
      return result;
    }
    CalcMuzzlePoints(a1, v2);
    v8 = v2[0] * 8192.0 + v3;
    v9 = v2[1] * 8192.0 + v4;
    v10 = v2[2] * 8192.0 + v5;
    v11 = v3;
    v12 = v4;
    v13 = v5;
  }
  trap_Trace(v6, &v11, vec3_origin, vec3_origin, &v8, *(_DWORD *)(*(_DWORD *)(a1 + 348) + 172), 33554433);
  v16 = v7;
  if ( v7 <= 0x3Fu
    && g_entities[199 * v16 + 87]
    && (!G_IsPlaying(a1) || LOWORD(g_entities[199 * v16 + 120]) == *(_WORD *)(a1 + 480)) )
  {
    v15 = g_entities[199 * v16 + 142];
  }
  else
  {
    v16 = -1;
    v15 = 0;
  }
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 256) = v16;
  result = v15;
  *(_DWORD *)(*(_DWORD *)(a1 + 348) + 260) = v15;
  return result;
}
// 13060: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14680: using guessed type _DWORD __cdecl G_IsPlaying(_DWORD);
// 14FA0: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);
// 156C0: using guessed type _DWORD __cdecl trap_Trace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (00069EB3) --------------------------------------------------------
int CheckTeamStatus()
{
  int result; // eax
  _DWORD *v1; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = level[122] - level[130];
  if ( result > 0 )
  {
    level[130] = level[122];
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= g_maxclients[3] )
        break;
      v1 = &g_entities[199 * i];
      if ( *((_BYTE *)v1 + 356) )
      {
        if ( (*(_DWORD *)(v1[87] + 12) & 0x10000) == 0 )
          TeamplayInfoMessage(v1);
      }
    }
  }
  return result;
}
// 143A0: using guessed type _DWORD __cdecl TeamplayInfoMessage(_DWORD);

//----- (00069F61) --------------------------------------------------------
void sub_69F61()
{
  ;
}

//----- (00069F68) --------------------------------------------------------
int __cdecl G_Trigger(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // [esp+10h] [ebp-8h]

  result = Scr_IsSystemActive(1);
  if ( result )
  {
    if ( level[2948] == 256 )
    {
      Scr_AddEntity(a2);
      result = Scr_Notify(a1, scr_const[73], 1);
    }
    else
    {
      v3 = &level[3 * level[2948]++ + 2180];
      *(_WORD *)v3 = *(_WORD *)a1;
      *((_WORD *)v3 + 1) = *(_WORD *)a2;
      v3[1] = *(_DWORD *)(a1 + 776);
      result = *(_DWORD *)(a2 + 776);
      v3[2] = result;
    }
  }
  return result;
}
// 13D80: using guessed type _DWORD __cdecl Scr_IsSystemActive(_DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006A046) --------------------------------------------------------
int __cdecl InitTrigger(int a1)
{
  int result; // eax

  if ( *(float *)(a1 + 324) != 0.0
    || *(float *)(a1 + 328) != *(float *)&vec3_origin[1]
    || *(float *)(a1 + 332) != *(float *)&vec3_origin[2] )
  {
    G_SetMovedir(a1 + 324, a1 + 496);
  }
  trap_SetBrushModel(a1);
  *(_DWORD *)(a1 + 284) = 1079771144;
  *(_DWORD *)(a1 + 244) = 1;
  result = *(_DWORD *)(a1 + 8) | 2;
  *(_DWORD *)(a1 + 8) = result;
  return result;
}
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);
// 15000: using guessed type _DWORD __cdecl G_SetMovedir(_DWORD, _DWORD);

//----- (0006A106) --------------------------------------------------------
int __cdecl InitSentientTrigger(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 284) = 0;
  if ( (*(_DWORD *)(a1 + 384) & 8) == 0 )
    *(_DWORD *)(a1 + 284) |= 0x40000000u;
  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 )
    *(_DWORD *)(a1 + 284) |= 0x40000u;
  if ( (*(_DWORD *)(a1 + 384) & 2) != 0 )
    *(_DWORD *)(a1 + 284) |= 0x80000u;
  result = *(_DWORD *)(a1 + 384) & 4;
  if ( result )
  {
    result = a1;
    *(_DWORD *)(a1 + 284) |= 0x100000u;
  }
  return result;
}

//----- (0006A1B8) --------------------------------------------------------
int __cdecl multi_wait(int a1)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 516) = 0;
  return result;
}

//----- (0006A1CA) --------------------------------------------------------
int (__cdecl *__cdecl multi_trigger(int a1, int a2))(int)
{
  int (__cdecl *result)(int); // eax
  long double v3; // fst6

  *(_DWORD *)(a1 + 612) = a2;
  result = Think_GeneralLink;
  if ( *(int (__cdecl **)(int))(a1 + 520) != Think_GeneralLink )
  {
    result = (int (__cdecl *)(int))a1;
    if ( !*(_DWORD *)(a1 + 516) )
    {
      if ( *(float *)(a1 + 624) <= 0.0 )
      {
        *(_DWORD *)(a1 + 532) = 0;
        *(_DWORD *)(a1 + 516) = level[122] + 100;
        result = (int (__cdecl *)(int))G_FreeEntity;
        *(_DWORD *)(a1 + 520) = G_FreeEntity;
      }
      else
      {
        *(_DWORD *)(a1 + 520) = multi_wait;
        v3 = (long double)rand() / 2147483600.0;
        result = (int (__cdecl *)(int))(level[122]
                                      + (int)(((v3 + v3 - 1.0) * *(float *)(a1 + 628) + *(float *)(a1 + 624)) * 1000.0));
        *(_DWORD *)(a1 + 516) = result;
      }
    }
  }
  return result;
}
// 6C53D: using guessed type int __cdecl Think_GeneralLink(int);

//----- (0006A2F2) --------------------------------------------------------
int __cdecl Use_Multi(int a1, int a2, int a3)
{
  return multi_trigger(a1, a3);
}
// 14230: using guessed type _DWORD __cdecl multi_trigger(_DWORD, _DWORD);

//----- (0006A31C) --------------------------------------------------------
int __cdecl Touch_Multi(int a1, int a2)
{
  G_Trigger(a1, a2);
  return multi_trigger(a1, a2);
}
// 13EE0: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 14230: using guessed type _DWORD __cdecl multi_trigger(_DWORD, _DWORD);

//----- (0006A358) --------------------------------------------------------
int __cdecl SP_trigger_multiple(int a1)
{
  char v2; // [esp+4h] [ebp-14h]

  G_SpawnFloat("wait", (int)&unk_7EE70, a1 + 624);
  G_SpawnFloat("random", (int)"0", a1 + 628);
  if ( *(float *)(a1 + 628) >= (long double)*(float *)(a1 + 624) && *(float *)(a1 + 624) >= 0.0 )
  {
    *(float *)(a1 + 628) = *(float *)(a1 + 624) - 100.0;
    G_Printf("trigger_multiple has random >= wait\n", v2);
  }
  *(_DWORD *)(a1 + 532) = Touch_Multi;
  *(_DWORD *)(a1 + 536) = Use_Multi;
  InitTrigger(a1);
  InitSentientTrigger(a1);
  return trap_LinkEntity(a1);
}
// 6A40C: variable 'v2' is possibly undefined
// 13680: using guessed type _DWORD __cdecl InitSentientTrigger(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DF0: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (0006A456) --------------------------------------------------------
int __cdecl hurt_touch(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a2;
  if ( *(_BYTE *)(a2 + 373) )
  {
    result = *(_DWORD *)(a1 + 468);
    if ( result <= level[122] )
    {
      G_Trigger(a1, a2);
      if ( (*(_DWORD *)(a1 + 384) & 0x10) != 0 )
        v3 = level[122] + 1000;
      else
        v3 = level[122] + 100;
      *(_DWORD *)(a1 + 468) = v3;
      if ( (*(_DWORD *)(a1 + 384) & 4) == 0 )
        G_PlaySoundAliasAtPoint(a2 + 312, *(unsigned __int8 *)(a1 + 370));
      if ( (*(_DWORD *)(a1 + 384) & 8) != 0 )
        G_Damage(a2, a1, a1, 0, 0, *(_DWORD *)(a1 + 576), 16, 23, 0);
      else
        G_Damage(a2, a1, a1, 0, 0, *(_DWORD *)(a1 + 576), 0, 23, 0);
      result = *(_DWORD *)(a1 + 384) & 0x20;
      if ( result )
      {
        result = a1;
        *(_DWORD *)(a1 + 532) = 0;
      }
    }
  }
  return result;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13EE0: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 14320: using guessed type _DWORD __cdecl G_PlaySoundAliasAtPoint(_DWORD, _DWORD);

//----- (0006A5AA) --------------------------------------------------------
void __cdecl hurt_think(void *s)
{
  *((_DWORD *)s + 129) = level[122] + 100;
  if ( (long double)(int)level[122] > *((float *)s + 156) )
    G_FreeEntity(s);
}

//----- (0006A605) --------------------------------------------------------
void __cdecl hurt_use(int a1)
{
  if ( *(_DWORD *)(a1 + 532) )
    *(_DWORD *)(a1 + 532) = 0;
  else
    *(_DWORD *)(a1 + 532) = hurt_touch;
  if ( *(float *)(a1 + 636) != 0.0 )
  {
    *(_DWORD *)(a1 + 516) = level[122] + 50;
    *(_DWORD *)(a1 + 520) = hurt_think;
    *(float *)(a1 + 624) = (long double)(int)level[122] + *(float *)(a1 + 636) * 1000.0;
  }
}

//----- (0006A6AC) --------------------------------------------------------
int __cdecl SP_trigger_hurt(int a1)
{
  int result; // eax
  float v2; // [esp+14h] [ebp-14h]
  char *s2; // [esp+18h] [ebp-10h] BYREF
  char *nptr; // [esp+1Ch] [ebp-Ch] BYREF

  InitTrigger(a1);
  G_SpawnString("sound", (int)"world_hurt_me", (int)&s2);
  *(_BYTE *)(a1 + 370) = G_SoundAliasIndex(s2);
  if ( !*(_DWORD *)(a1 + 576) )
    *(_DWORD *)(a1 + 576) = 5;
  *(_DWORD *)(a1 + 284) = 1079771144;
  *(_DWORD *)(a1 + 536) = hurt_use;
  if ( (*(_DWORD *)(a1 + 384) & 1) == 0 )
    *(_DWORD *)(a1 + 532) = hurt_touch;
  G_SpawnString("life", (int)"0", (int)&nptr);
  v2 = atof(nptr);
  result = LODWORD(v2);
  *(float *)(a1 + 636) = v2;
  return result;
}
// 13DF0: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (0006A791) --------------------------------------------------------
int __cdecl SP_trigger_once(_DWORD *a1)
{
  a1[156] = -1082130432;
  a1[133] = Touch_Multi;
  a1[134] = Use_Multi;
  InitTrigger(a1);
  InitSentientTrigger(a1);
  return trap_LinkEntity(a1);
}
// 13680: using guessed type _DWORD __cdecl InitSentientTrigger(_DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DF0: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (0006A7F5) --------------------------------------------------------
int __cdecl Respond_trigger_damage(int a1, int a2)
{
  int v3; // [esp+8h] [ebp-8h]

  if ( (*(_DWORD *)(a1 + 384) & 1) != 0 && a2 == 1 )
    return 0;
  if ( (*(_DWORD *)(a1 + 384) & 2) != 0 && a2 == 2 )
    return 0;
  if ( (*(_DWORD *)(a1 + 384) & 4) != 0 && (unsigned int)(a2 - 3) <= 3 )
    return 0;
  if ( (*(_DWORD *)(a1 + 384) & 8) == 0 )
  {
LABEL_13:
    if ( (*(_DWORD *)(a1 + 384) & 0x10) != 0 )
    {
      if ( a2 == 6 )
        return 0;
      if ( a2 <= 6 )
      {
        if ( a2 != 4 )
          goto LABEL_21;
        return 0;
      }
      if ( a2 == 10 || a2 == 14 )
        return 0;
    }
LABEL_21:
    if ( (*(_DWORD *)(a1 + 384) & 0x20) != 0 && a2 == 7 )
      return 0;
    if ( (*(_DWORD *)(a1 + 384) & 0x40) != 0 && a2 == 18 )
      return 0;
    if ( (*(_DWORD *)(a1 + 384) & 0x100) == 0 )
      return 1;
    switch ( a2 )
    {
      case 0:
      case 11:
      case 12:
      case 16:
      case 17:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
        v3 = 0;
        break;
      default:
        return 1;
    }
    return v3;
  }
  switch ( a2 )
  {
    case 3:
    case 4:
    case 5:
    case 6:
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
    case 24:
      v3 = 0;
      break;
    default:
      goto LABEL_13;
  }
  return v3;
}

//----- (0006A973) --------------------------------------------------------
int (__cdecl *__cdecl Activate_trigger_damage(int a1, int a2, int (__cdecl *a3)(int), int a4))(int)
{
  int (__cdecl *result)(int); // eax
  long double v5; // fst6

  if ( !*(_DWORD *)(a1 + 516) || (result = Think_GeneralLink, *(int (__cdecl **)(int))(a1 + 520) == Think_GeneralLink) )
  {
    if ( *(int *)(a1 + 688) <= 0 || (result = a3, (int)a3 >= *(_DWORD *)(a1 + 688)) )
    {
      result = (int (__cdecl *)(int))Respond_trigger_damage(a1, a4);
      if ( result )
      {
        if ( !*(_DWORD *)(a1 + 600)
          || (result = (int (__cdecl *)(int))a1, 32000 - *(_DWORD *)(a1 + 568) >= *(_DWORD *)(a1 + 600)) )
        {
          *(_DWORD *)(a1 + 612) = a2;
          if ( a4 != -1 )
            G_Trigger(a1, *(_DWORD *)(a1 + 612));
          if ( *(int (__cdecl **)(int))(a1 + 520) != Think_GeneralLink )
          {
            if ( *(float *)(a1 + 624) <= 0.0 )
            {
              *(_DWORD *)(a1 + 532) = 0;
              *(_DWORD *)(a1 + 516) = level[122] + 100;
              *(_DWORD *)(a1 + 520) = G_FreeEntity;
            }
            else
            {
              *(_DWORD *)(a1 + 520) = multi_wait;
              v5 = (long double)rand() / 2147483600.0;
              *(_DWORD *)(a1 + 516) = level[122]
                                    + (int)(((v5 + v5 - 1.0) * *(float *)(a1 + 628) + *(float *)(a1 + 624)) * 1000.0);
            }
          }
          result = (int (__cdecl *)(int))a1;
          *(_DWORD *)(a1 + 568) = 32000;
        }
      }
    }
  }
  return result;
}
// 132C0: using guessed type _DWORD __cdecl Respond_trigger_damage(_DWORD, _DWORD);
// 13EE0: using guessed type _DWORD __cdecl G_Trigger(_DWORD, _DWORD);
// 6C53D: using guessed type int __cdecl Think_GeneralLink(int);

//----- (0006AB3C) --------------------------------------------------------
int __cdecl Use_trigger_damage(int a1, int a2)
{
  return Activate_trigger_damage(a1, a2, *(_DWORD *)(a1 + 600) + 1, -1);
}
// 13E40: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006AB7C) --------------------------------------------------------
int __cdecl Pain_trigger_damage(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  Activate_trigger_damage(a1, a2, a3, a5);
  result = a1;
  if ( !*(_DWORD *)(a1 + 600) )
  {
    result = a1;
    *(_DWORD *)(a1 + 568) = 32000;
  }
  return result;
}
// 13E40: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006ABCD) --------------------------------------------------------
int __cdecl Die_trigger_damage(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax

  Activate_trigger_damage(a1, a3, a4, a5);
  result = a1;
  if ( !*(_DWORD *)(a1 + 600) )
  {
    result = a1;
    *(_DWORD *)(a1 + 568) = 32000;
  }
  return result;
}
// 13E40: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006AC1E) --------------------------------------------------------
int __cdecl SP_trigger_damage(int a1)
{
  char v2; // [esp+4h] [ebp-14h]

  G_SpawnFloat("wait", (int)&unk_7EE70, a1 + 624);
  G_SpawnFloat("random", (int)"0", a1 + 628);
  if ( *(float *)(a1 + 628) >= (long double)*(float *)(a1 + 624) && *(float *)(a1 + 624) >= 0.0 )
  {
    *(float *)(a1 + 628) = *(float *)(a1 + 624) - 100.0;
    G_Printf("trigger_damage has random >= wait\n", v2);
  }
  G_SpawnInt("accumulate", (int)"0", a1 + 600);
  G_SpawnInt("threshold", (int)"0", a1 + 688);
  *(_DWORD *)(a1 + 568) = 32000;
  *(_BYTE *)(a1 + 373) = 1;
  *(_DWORD *)(a1 + 536) = Use_trigger_damage;
  *(_DWORD *)(a1 + 540) = Pain_trigger_damage;
  *(_DWORD *)(a1 + 544) = Die_trigger_damage;
  InitTrigger(a1);
  return trap_LinkEntity(a1);
}
// 6ACD2: variable 'v2' is possibly undefined
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 13DF0: using guessed type _DWORD __cdecl InitTrigger(_DWORD);

//----- (0006AD7F) --------------------------------------------------------
int __cdecl G_CheckHitTriggerDamage(int a1, int *a2, int a3, int a4, int a5)
{
  int result; // eax
  _DWORD *v6; // [esp+2Ch] [ebp-105Ch]
  int v7[4]; // [esp+50h] [ebp-1038h] BYREF
  int v8[4]; // [esp+60h] [ebp-1028h] BYREF
  int v9[1026]; // [esp+70h] [ebp-1018h] BYREF
  int v10; // [esp+1078h] [ebp-10h]
  int i; // [esp+107Ch] [ebp-Ch]

  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v7[0] = *a2;
  v7[1] = a2[1];
  v7[2] = a2[2];
  AddPointToBounds(a3, v8, v7);
  v10 = trap_EntitiesInBox(v8, v7, v9, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = &g_entities[199 * v9[i]];
    if ( *((_WORD *)v6 + 190) == scr_const[75] && trap_SightTraceToEntity(a2, vec3_origin, vec3_origin, a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, scr_const[13], 2);
      Activate_trigger_damage(v6, a1, a4, a5);
      if ( !v6[150] )
        v6[142] = 32000;
    }
  }
  return result;
}
// 12F40: using guessed type _DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 13E40: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14C40: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006B00E) --------------------------------------------------------
int __cdecl G_GrenadeTouchTriggerDamage(int a1, int *a2, int a3, int a4, int a5)
{
  int result; // eax
  _DWORD *v6; // [esp+2Ch] [ebp-103Ch]
  int v7[4]; // [esp+30h] [ebp-1038h] BYREF
  int v8[4]; // [esp+40h] [ebp-1028h] BYREF
  int v9[1026]; // [esp+50h] [ebp-1018h] BYREF
  int v10; // [esp+1058h] [ebp-10h]
  int i; // [esp+105Ch] [ebp-Ch]

  v8[0] = *a2;
  v8[1] = a2[1];
  v8[2] = a2[2];
  v7[0] = *a2;
  v7[1] = a2[1];
  v7[2] = a2[2];
  AddPointToBounds(a3, v8, v7);
  v10 = trap_EntitiesInBox(v8, v7, v9, 1024, 0x400000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v10 )
      break;
    v6 = &g_entities[199 * v9[i]];
    if ( *((_WORD *)v6 + 190) == scr_const[75]
      && *((__int16 *)v6 + 194) < 0
      && trap_SightTraceToEntity(a2, vec3_origin, vec3_origin, a3, *v6, -1) )
    {
      Scr_AddEntity(a1);
      Scr_AddInt(a4);
      Scr_Notify(v6, scr_const[13], 2);
      Activate_trigger_damage(v6, a1, a4, a5);
      if ( !v6[150] )
        v6[142] = 32000;
    }
  }
  return result;
}
// 12F40: using guessed type _DWORD __cdecl trap_SightTraceToEntity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13DE0: using guessed type _DWORD __cdecl Scr_Notify(_DWORD, _DWORD, _DWORD);
// 13E40: using guessed type _DWORD __cdecl Activate_trigger_damage(_DWORD, _DWORD, _DWORD, _DWORD);
// 13ED0: using guessed type _DWORD __cdecl Scr_AddInt(_DWORD);
// 14C40: using guessed type _DWORD __cdecl AddPointToBounds(_DWORD, _DWORD, _DWORD);
// 15180: using guessed type _DWORD __cdecl Scr_AddEntity(_DWORD);

//----- (0006B207) --------------------------------------------------------
int __cdecl explosive_indicator_think(_DWORD *a1)
{
  int result; // eax
  _DWORD *v2; // [esp+0h] [ebp-8h]

  v2 = &g_entities[199 * a1[84]];
  if ( *((_BYTE *)v2 + 356) && *((_WORD *)v2 + 190) == scr_const[120] )
  {
    result = (int)a1;
    a1[129] = level[122] + 100;
  }
  else
  {
    a1[130] = G_FreeEntity;
    result = level[122] + 100;
    a1[129] = result;
  }
  return result;
}

//----- (0006B2A3) --------------------------------------------------------
int __cdecl SP_trigger_lookat(_DWORD *a1)
{
  trap_SetBrushModel(a1);
  a1[71] = 0x20000000;
  a1[61] = 1;
  a1[2] |= 2u;
  return trap_LinkEntity(a1);
}
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 145C0: using guessed type _DWORD __cdecl trap_SetBrushModel(_DWORD);

//----- (0006B2FA) --------------------------------------------------------
void sub_6B2FA()
{
  ;
}

//----- (0006B300) --------------------------------------------------------
int __cdecl G_FindConfigstringIndex(char *s2, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  char v7; // [esp+4h] [ebp-24h]
  int v8; // [esp+18h] [ebp-10h]
  char *s1; // [esp+1Ch] [ebp-Ch]
  int i; // [esp+20h] [ebp-8h]

  if ( !s2 || !*s2 )
    return 0;
  for ( i = 1; i < a3; ++i )
  {
    s1 = (char *)trap_GetConfigstringConst(a2 + i);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( a4 )
  {
    if ( i == a3 )
      G_Error("G_FindConfigstringIndex: overflow", v7);
    trap_SetConfigstring(a2 + i, s2);
    v8 = i;
  }
  else
  {
    if ( a5 )
    {
      v5 = va("%s \"%s\" not precached", a5);
      Scr_Error(v5);
    }
    v8 = 0;
  }
  return v8;
}
// 6B3C7: variable 'v7' is possibly undefined
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14560: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);

//----- (0006B3F0) --------------------------------------------------------
int __cdecl G_LocalizedStringIndex(char *s2)
{
  int v2; // [esp+20h] [ebp-8h]

  if ( *s2 )
    v2 = G_FindConfigstringIndex(
           s2,
           1244,
           256,
           level[7],
           (unsigned __int8)&aLocalizedStrin[-560536] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  else
    v2 = 0;
  return v2;
}
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;

//----- (0006B451) --------------------------------------------------------
int __cdecl G_ShaderIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 1500, 128, level[7], (char)"shader");
}

//----- (0006B49B) --------------------------------------------------------
int __cdecl G_ModelIndex(char *s2)
{
  int v1; // eax
  char v3; // [esp+4h] [ebp-24h]
  char *s1; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]

  if ( !*s2 )
    return 0;
  for ( i = 1; i <= 255; ++i )
  {
    s1 = (char *)trap_GetConfigstringConst(i + 268);
    if ( !*s1 )
      break;
    if ( !strcasecmp(s1, s2) )
      return i;
  }
  if ( !level[7] )
  {
    v1 = va("model '%s' not precached", (char)s2);
    Scr_Error(v1);
  }
  if ( i == 256 )
    G_Error("G_ModelIndex: overflow", v3);
  *(int *)((char *)&dword_A8940 + (_DWORD)&dword_0[i]) = trap_XModelGet(s2);
  trap_SetConfigstring(i + 268, s2);
  return i;
}
// 6B551: variable 'v3' is possibly undefined
// 0: using guessed type int dword_0[];
// 132E0: using guessed type _DWORD __cdecl Scr_Error(_DWORD);
// 13D70: using guessed type _DWORD __cdecl trap_SetConfigstring(_DWORD, _DWORD);
// 14560: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);
// 14A70: using guessed type _DWORD __cdecl trap_XModelGet(_DWORD);
// A8940: using guessed type int dword_A8940;

//----- (0006B592) --------------------------------------------------------
int __cdecl sub_6B592(int a1)
{
  return *(int *)((char *)&dword_A8940 + (_DWORD)&dword_0[a1]);
}
// 0: using guessed type int dword_0[];
// A8940: using guessed type int dword_A8940;

//----- (0006B5AE) --------------------------------------------------------
int __cdecl G_ModelName(int a1)
{
  return trap_GetConfigstringConst(a1 + 268);
}
// 14560: using guessed type _DWORD __cdecl trap_GetConfigstringConst(_DWORD);

//----- (0006B5D6) --------------------------------------------------------
int __cdecl G_TagIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 108, 32, 1, 0);
}

//----- (0006B619) --------------------------------------------------------
int __cdecl G_EffectIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 780, 64, level[7], (char)"effect");
}

//----- (0006B663) --------------------------------------------------------
int __cdecl G_ShellShockIndex(char *s2)
{
  return G_FindConfigstringIndex(s2, 1100, 16, 1, 0);
}

//----- (0006B6A6) --------------------------------------------------------
int __cdecl G_SoundAliasIndex(char *s2)
{
  return (unsigned __int8)G_FindConfigstringIndex(s2, 524, 256, 1, 0);
}

//----- (0006B6EC) --------------------------------------------------------
int __cdecl G_GetGameId(_DWORD *a1)
{
  return (unsigned __int16)Scr_GetEntityId(*a1, 0);
}
// 14580: using guessed type _DWORD __cdecl Scr_GetEntityId(_DWORD, _DWORD);

//----- (0006B71C) --------------------------------------------------------
int __cdecl G_DObjUpdate(int a1)
{
  int result; // eax
  int i; // [esp+28h] [ebp-A0h]
  int v3; // [esp+2Ch] [ebp-9Ch]
  _DWORD v4[2]; // [esp+30h] [ebp-98h] BYREF
  __int16 v5[2]; // [esp+38h] [ebp-90h]
  _DWORD v6[30]; // [esp+3Ch] [ebp-8Ch]
  unsigned __int16 v7; // [esp+B6h] [ebp-12h]
  int v8; // [esp+B8h] [ebp-10h]
  int v9; // [esp+BCh] [ebp-Ch]

  result = a1;
  if ( !*(_DWORD *)(a1 + 348) )
  {
    G_SafeDObjFree(a1);
    v9 = *(unsigned __int8 *)(a1 + 377);
    if ( v9 )
    {
      v7 = G_GetGameId(a1);
      v8 = sub_6B592(v9);
      v4[0] = v8;
      v4[1] = 0;
      v5[0] = -(__int16)v9;
      v6[0] = 0;
      v3 = 1;
      if ( !*(_DWORD *)(a1 + 4) || *(_DWORD *)(a1 + 4) == 8 || *(_DWORD *)(a1 + 4) == 11 )
        *(_DWORD *)(a1 + 140) = v9;
      for ( i = 0; i <= 5; ++i )
      {
        v9 = *(unsigned __int8 *)(i + a1 + 756);
        if ( v9 )
        {
          v4[4 * v3] = sub_6B592(v9);
          v4[4 * v3 + 1] = SL_ConvertToString(*(unsigned __int16 *)(a1 + 2 * i + 762));
          v5[8 * v3] = -(__int16)v9;
          v6[4 * v3++] = ((int)*(unsigned __int8 *)(a1 + 378) >> i) & 1;
        }
      }
      trap_DObjCreate(v4, (unsigned __int16)v3, 0, *(_DWORD *)a1, v7);
      result = G_UpdateTagInfoOfChildren(a1, 1);
    }
    else
    {
      result = G_UpdateTagInfoOfChildren(a1, 0);
    }
  }
  return result;
}
// 13220: using guessed type _DWORD __cdecl trap_DObjCreate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13760: using guessed type _DWORD __cdecl G_UpdateTagInfoOfChildren(_DWORD, _DWORD);
// 13D50: using guessed type _DWORD __cdecl G_SafeDObjFree(_DWORD);
// 141B0: using guessed type _DWORD __cdecl G_GetGameId(_DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 6B71C: using guessed type __int16 anonymous_0[2];

//----- (0006B972) --------------------------------------------------------
int __cdecl G_SetModel(int a1, char *s2)
{
  int result; // eax
  unsigned __int8 v3; // [esp+10h] [ebp-8h]

  if ( *s2 )
  {
    v3 = G_ModelIndex(s2);
    result = v3;
    *(_BYTE *)(a1 + 377) = v3;
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 377) = 0;
  }
  return result;
}

//----- (0006B9B9) --------------------------------------------------------
int __cdecl G_EntAttach(int a1, char *s2, int a3, int a4)
{
  int i; // [esp+18h] [ebp-10h]

  for ( i = 0; ; ++i )
  {
    if ( i > 5 )
      return 0;
    if ( !*(_BYTE *)(i + a1 + 756) )
      break;
  }
  *(_BYTE *)(i + a1 + 756) = G_ModelIndex(s2);
  *(_WORD *)(a1 + 2 * i + 762) = SL_GetLowercaseString(a3, 0);
  if ( a4 )
    *(_BYTE *)(a1 + 378) |= 1 << i;
  G_DObjUpdate(a1);
  return 1;
}
// 134B0: using guessed type _DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD);
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);

//----- (0006BA87) --------------------------------------------------------
int __cdecl G_EntDetach(int a1, char *s2, int a3)
{
  const char *v3; // eax
  char v4; // al
  __int16 v7; // [esp+1Ah] [ebp-Eh]
  int i; // [esp+1Ch] [ebp-Ch]

  v7 = SL_FindLowercaseString(a3);
  if ( !v7 )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i > 5 )
      return 0;
    if ( *(_WORD *)(a1 + 2 * i + 762) == v7 )
    {
      v3 = (const char *)G_ModelName(*(unsigned __int8 *)(i + a1 + 756));
      if ( !strcasecmp(v3, s2) )
        break;
    }
  }
  *(_BYTE *)(i + a1 + 756) = 0;
  Scr_SetString(a1 + 2 * i + 762, 0);
  while ( i <= 4 )
  {
    *(_BYTE *)(i + a1 + 756) = *(_BYTE *)(i + a1 + 757);
    *(_WORD *)(a1 + 2 * i + 762) = *(_WORD *)(a1 + 2 * i + 764);
    if ( (((int)*(unsigned __int8 *)(a1 + 378) >> (i + 1)) & 1) != 0 )
      v4 = *(_BYTE *)(a1 + 378) | (1 << i);
    else
      v4 = *(_BYTE *)(a1 + 378) & ~(unsigned __int8)(1 << i);
    *(_BYTE *)(a1 + 378) = v4;
    ++i;
  }
  *(_BYTE *)(i + a1 + 756) = 0;
  *(_WORD *)(a1 + 2 * i + 762) = 0;
  *(_BYTE *)(a1 + 378) &= ~(unsigned __int8)(1 << i);
  G_DObjUpdate(a1);
  return 1;
}
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 13980: using guessed type _DWORD __cdecl G_ModelName(_DWORD);
// 13FA0: using guessed type _DWORD __cdecl SL_FindLowercaseString(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0006BC55) --------------------------------------------------------
int __cdecl G_EntDetachAll(int a1)
{
  int i; // [esp+10h] [ebp-8h]

  for ( i = 0; i <= 5; ++i )
  {
    *(_BYTE *)(i + a1 + 756) = 0;
    Scr_SetString(a1 + 2 * i + 762, 0);
  }
  *(_BYTE *)(a1 + 378) = 0;
  return G_DObjUpdate(a1);
}
// 138E0: using guessed type _DWORD __cdecl G_DObjUpdate(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0006BCC4) --------------------------------------------------------
int __cdecl sub_6BCC4(int a1, int a2, _BYTE *a3)
{
  __int16 v4; // [esp+Eh] [ebp-1Ah]
  int v6; // [esp+18h] [ebp-10h]
  int i; // [esp+1Ch] [ebp-Ch]
  int v8; // [esp+20h] [ebp-8h]

  G_EntUnlink(a1);
  if ( *a3 )
  {
    if ( !trap_DObjExists(a2) )
      return 0;
    v6 = trap_DObjGetBoneIndex(a2, a3);
    if ( v6 < 0 )
      return 0;
  }
  else
  {
    v6 = -1;
  }
  for ( i = a2; ; i = **(_DWORD **)(i + 748) )
  {
    if ( i == a1 )
      return 0;
    if ( !*(_DWORD *)(i + 748) )
      break;
  }
  v8 = MT_Alloc(112, 16);
  *(_DWORD *)v8 = a2;
  if ( *a3 )
    v4 = SL_GetLowercaseString(a3, 0);
  else
    v4 = 0;
  *(_WORD *)(v8 + 8) = v4;
  *(_DWORD *)(v8 + 4) = *(_DWORD *)(a2 + 752);
  *(_DWORD *)(v8 + 12) = v6;
  memset((void *)(v8 + 16), 0, 0x30u);
  *(_DWORD *)(a2 + 752) = a1;
  *(_DWORD *)(a1 + 748) = v8;
  memset((void *)(v8 + 64), 0, 0x30u);
  return 1;
}
// 134B0: using guessed type _DWORD __cdecl SL_GetLowercaseString(_DWORD, _DWORD);
// 13A30: using guessed type _DWORD __cdecl trap_DObjExists(_DWORD);
// 155C0: using guessed type _DWORD __cdecl MT_Alloc(_DWORD, _DWORD);
// 15760: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006BE3D) --------------------------------------------------------
int __cdecl G_EntLinkTo(int a1, int a2, _BYTE *a3)
{
  if ( !sub_6BCC4(a1, a2, a3) )
    return 0;
  G_CalcTagAxis(a1, 0);
  return 1;
}
// 13370: using guessed type _DWORD __cdecl G_CalcTagAxis(_DWORD, _DWORD);

//----- (0006BE98) --------------------------------------------------------
int __cdecl G_EntLinkToWithOffset(int a1, int a2, _BYTE *a3, _DWORD *a4, int a5)
{
  _DWORD *v7; // [esp+10h] [ebp-8h]

  if ( !sub_6BCC4(a1, a2, a3) )
    return 0;
  v7 = *(_DWORD **)(a1 + 748);
  AnglesToAxis(a5, v7 + 4);
  v7[13] = *a4;
  v7[14] = a4[1];
  v7[15] = a4[2];
  return 1;
}
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0006BF28) --------------------------------------------------------
_DWORD *__cdecl G_EntUnlink(int a1)
{
  _DWORD *result; // eax
  int v2; // [esp+14h] [ebp-14h]
  int i; // [esp+18h] [ebp-10h]
  _DWORD *v4; // [esp+20h] [ebp-8h]

  result = *(_DWORD **)(a1 + 748);
  v4 = result;
  if ( result )
  {
    G_SetOrigin(a1, a1 + 312);
    G_SetAngle(a1, a1 + 324);
    v2 = 0;
    for ( i = *(_DWORD *)(*v4 + 752); i != a1; i = *(_DWORD *)(*(_DWORD *)(i + 748) + 4) )
      v2 = i;
    if ( v2 )
      *(_DWORD *)(*(_DWORD *)(v2 + 748) + 4) = v4[1];
    else
      *(_DWORD *)(*v4 + 752) = v4[1];
    *(_DWORD *)(a1 + 748) = 0;
    Scr_SetString(v4 + 2, 0);
    result = (_DWORD *)MT_Free(v4, 112);
  }
  return result;
}
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13740: using guessed type _DWORD __cdecl MT_Free(_DWORD, _DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006C020) --------------------------------------------------------
int __cdecl G_EntIsLinkedTo(int a1, int a2)
{
  int v3; // [esp+0h] [ebp-8h]
  _DWORD *v4; // [esp+4h] [ebp-4h]

  v4 = *(_DWORD **)(a1 + 748);
  v3 = 0;
  if ( v4 && *v4 == a2 )
    v3 = 1;
  return v3;
}

//----- (0006C055) --------------------------------------------------------
int __cdecl G_UpdateTagInfo(int a1, int a2)
{
  int v2; // eax
  int result; // eax
  int v4; // [esp+Ch] [ebp-Ch]

  v4 = *(_DWORD *)(a1 + 748);
  if ( *(_WORD *)(v4 + 8) )
  {
    if ( !a2
      || (v2 = SL_ConvertToString(*(unsigned __int16 *)(v4 + 8)),
          *(_DWORD *)(v4 + 12) = trap_DObjGetBoneIndex(*(_DWORD *)v4, v2),
          result = v4,
          *(int *)(v4 + 12) < 0) )
    {
      result = G_EntUnlink(a1);
    }
  }
  else
  {
    result = *(_DWORD *)(a1 + 748);
    *(_DWORD *)(v4 + 12) = -1;
  }
  return result;
}
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 15760: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006C0D3) --------------------------------------------------------
int __cdecl G_UpdateTagInfoOfChildren(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+Ch] [ebp-Ch]
  int i; // [esp+10h] [ebp-8h]

  result = *(_DWORD *)(a1 + 752);
  for ( i = result; i; i = v3 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(i + 748) + 4);
    G_UpdateTagInfo(i, a2);
    result = v3;
  }
  return result;
}
// 151F0: using guessed type _DWORD __cdecl G_UpdateTagInfo(_DWORD, _DWORD);

//----- (0006C128) --------------------------------------------------------
int __cdecl G_CalcTagParentAxis(int a1, _DWORD *a2)
{
  int result; // eax
  int v3; // [esp+1Ch] [ebp-4Ch]
  char v4[36]; // [esp+20h] [ebp-48h] BYREF
  int v5; // [esp+44h] [ebp-24h]
  int v6; // [esp+48h] [ebp-20h]
  int v7; // [esp+4Ch] [ebp-1Ch]
  _DWORD *v8; // [esp+58h] [ebp-10h]
  int *v9; // [esp+5Ch] [ebp-Ch]

  v9 = *(int **)(a1 + 748);
  v8 = (_DWORD *)*v9;
  if ( v9[3] < 0 )
  {
    AnglesToAxis(v8 + 81, a2);
    a2[9] = v8[78];
    a2[10] = v8[79];
    result = v8[80];
    a2[11] = result;
  }
  else
  {
    AnglesToAxis(v8 + 81, v4);
    v5 = v8[78];
    v6 = v8[79];
    v7 = v8[80];
    G_DObjCalcBone(v8, v9[3]);
    v3 = trap_DObjGetMatrixArray(v8);
    result = DObjSkelMatrixMultiply43(v3 + (v9[3] << 6), v4, a2);
  }
  return result;
}
// 13090: using guessed type _DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD);
// 13620: using guessed type _DWORD __cdecl DObjSkelMatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 148F0: using guessed type _DWORD __cdecl trap_DObjGetMatrixArray(_DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0006C22D) --------------------------------------------------------
int __cdecl G_CalcTagParentRelAxis(int a1, int a2)
{
  int v3; // [esp+1Ch] [ebp-3Ch]
  char v4[56]; // [esp+20h] [ebp-38h] BYREF

  v3 = *(_DWORD *)(a1 + 748);
  G_CalcTagParentAxis(a1, v4);
  return MatrixMultiply43(v3 + 64, v4, a2);
}
// 14150: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 14610: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);

//----- (0006C27F) --------------------------------------------------------
int __cdecl G_CalcTagAxis(_DWORD *a1, int a2)
{
  int result; // eax
  char v3[48]; // [esp+10h] [ebp-A8h] BYREF
  char v4[48]; // [esp+40h] [ebp-78h] BYREF
  char v5[36]; // [esp+70h] [ebp-48h] BYREF
  int v6; // [esp+94h] [ebp-24h]
  int v7; // [esp+98h] [ebp-20h]
  int v8; // [esp+9Ch] [ebp-1Ch]
  int v9; // [esp+ACh] [ebp-Ch]

  G_CalcTagParentAxis(a1, v4);
  AnglesToAxis(a1 + 81, v5);
  v9 = a1[187];
  if ( a2 )
  {
    MatrixTranspose(v4, v3);
    result = MatrixMultiply(v5, v3, v9 + 16);
  }
  else
  {
    MatrixInverseOrthogonal43(v4, v3);
    v6 = a1[78];
    v7 = a1[79];
    v8 = a1[80];
    result = MatrixMultiply43(v5, v3, v9 + 16);
  }
  return result;
}
// 12FE0: using guessed type _DWORD __cdecl MatrixInverseOrthogonal43(_DWORD, _DWORD);
// 14060: using guessed type _DWORD __cdecl MatrixMultiply(_DWORD, _DWORD, _DWORD);
// 14150: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 145B0: using guessed type _DWORD __cdecl MatrixTranspose(_DWORD, _DWORD);
// 14610: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0006C366) --------------------------------------------------------
void __cdecl G_SetFixedLink(int a1, int a2)
{
  char v2[48]; // [esp+20h] [ebp-78h] BYREF
  char v3[36]; // [esp+50h] [ebp-48h] BYREF
  int v4; // [esp+74h] [ebp-24h] BYREF
  int v5; // [esp+78h] [ebp-20h]
  int v6; // [esp+7Ch] [ebp-1Ch]
  int v7; // [esp+8Ch] [ebp-Ch]

  G_CalcTagParentAxis(a1, v2);
  v7 = *(_DWORD *)(a1 + 748);
  if ( a2 == 1 )
  {
    MatrixMultiply43(v7 + 16, v2, v3);
    *(_DWORD *)(a1 + 312) = v4;
    *(_DWORD *)(a1 + 316) = v5;
    *(_DWORD *)(a1 + 320) = v6;
    *(float *)(a1 + 328) = vectoyaw(v3);
  }
  else if ( a2 > 1 )
  {
    if ( a2 == 2 )
    {
      MatrixTransformVector43(v7 + 52, v2, &v4);
      *(_DWORD *)(a1 + 312) = v4;
      *(_DWORD *)(a1 + 316) = v5;
      *(_DWORD *)(a1 + 320) = v6;
    }
  }
  else if ( !a2 )
  {
    MatrixMultiply43(v7 + 16, v2, v3);
    *(_DWORD *)(a1 + 312) = v4;
    *(_DWORD *)(a1 + 316) = v5;
    *(_DWORD *)(a1 + 320) = v6;
    AxisToAngles(v3, a1 + 324);
  }
}
// 12F80: using guessed type long double __cdecl vectoyaw(_DWORD);
// 131A0: using guessed type _DWORD __cdecl AxisToAngles(_DWORD, _DWORD);
// 14150: using guessed type _DWORD __cdecl G_CalcTagParentAxis(_DWORD, _DWORD);
// 14610: using guessed type _DWORD __cdecl MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 14930: using guessed type _DWORD __cdecl MatrixTransformVector43(_DWORD, _DWORD, _DWORD);

//----- (0006C4C5) --------------------------------------------------------
int __cdecl G_GeneralLink(int a1)
{
  G_SetFixedLink(a1, 0);
  G_SetOrigin(a1, a1 + 312);
  G_SetAngle(a1, a1 + 324);
  *(_DWORD *)(a1 + 12) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  return trap_LinkEntity(a1);
}
// 13050: using guessed type _DWORD __cdecl G_SetFixedLink(_DWORD, _DWORD);
// 133B0: using guessed type _DWORD __cdecl G_SetAngle(_DWORD, _DWORD);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006C53D) --------------------------------------------------------
int __cdecl Think_GeneralLink(int a1)
{
  int result; // eax

  *(_DWORD *)(a1 + 516) = level[122] + 50;
  result = a1;
  if ( *(_DWORD *)(a1 + 748) )
    result = G_GeneralLink(a1);
  return result;
}
// 14A10: using guessed type _DWORD __cdecl G_GeneralLink(_DWORD);
// 6C53D: using guessed type int __cdecl Think_GeneralLink(int);

//----- (0006C584) --------------------------------------------------------
int __cdecl G_SafeDObjFree(_DWORD *a1)
{
  return trap_SafeDObjFree(*a1, 0);
}
// 12F20: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);

//----- (0006C5B1) --------------------------------------------------------
int __cdecl G_DObjUpdateServerTime(int a1, int a2)
{
  float v3; // [esp+4h] [ebp-14h]

  v3 = (long double)(int)level[124] * 0.001;
  return trap_DObjUpdateServerTime(a1, LODWORD(v3), a2);
}
// 145D0: using guessed type _DWORD __cdecl trap_DObjUpdateServerTime(_DWORD, _DWORD, _DWORD);

//----- (0006C5F3) --------------------------------------------------------
int __cdecl sub_6C5F3(int a1, _DWORD *a2, float *a3, int a4)
{
  int result; // eax
  char v5[16]; // [esp+10h] [ebp-58h] BYREF
  int v6[4]; // [esp+20h] [ebp-48h] BYREF
  int v7[4]; // [esp+30h] [ebp-38h] BYREF
  int v8[7]; // [esp+40h] [ebp-28h] BYREF
  _DWORD *v9; // [esp+5Ch] [ebp-Ch]

  v9 = (_DWORD *)(32 * a4 + trap_DObjGetRotTransArray(a1));
  YawToQuaternion(a3[1], (int)v8);
  PitchToQuaternion(*a3, (int)v6);
  RollToQuaternion(a3[2], (int)v7);
  QuatMultiply(v6, v8, v5);
  QuatMultiply(v7, v5, v9);
  v9[4] = 0;
  v9[5] = *a2;
  v9[6] = a2[1];
  result = a2[2];
  v9[7] = result;
  return result;
}
// 14040: using guessed type _DWORD __cdecl QuatMultiply(_DWORD, _DWORD, _DWORD);
// 14820: using guessed type _DWORD __cdecl trap_DObjGetRotTransArray(_DWORD);

//----- (0006C6C9) --------------------------------------------------------
int __cdecl G_DObjSetLocalTag(int a1, int a2, int a3, _DWORD *a4, float *a5)
{
  int v7; // [esp+20h] [ebp-8h]

  v7 = trap_DObjGetBoneIndex(a1, a3);
  if ( v7 < 0 )
    return 0;
  if ( !trap_DObjSetRotTransIndex(a1, a2, v7) )
    return 0;
  sub_6C5F3(a1, a4, a5, v7);
  return 1;
}
// 15540: using guessed type _DWORD __cdecl trap_DObjSetRotTransIndex(_DWORD, _DWORD, _DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006C755) --------------------------------------------------------
int __cdecl G_DObjSetControlTagAngles(int a1, int a2, int a3, float *a4)
{
  int v6; // [esp+20h] [ebp-8h]

  v6 = trap_DObjGetBoneIndex(a1, a3);
  if ( v6 < 0 )
    return 0;
  if ( !trap_DObjSetControlRotTransIndex(a1, a2, v6) )
    return 0;
  sub_6C5F3(a1, vec3_origin, a4, v6);
  return 1;
}
// 154D0: using guessed type _DWORD __cdecl trap_DObjSetControlRotTransIndex(_DWORD, _DWORD, _DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006C7E4) --------------------------------------------------------
int __cdecl G_DObjCalcPose(int a1)
{
  int result; // eax
  char s[24]; // [esp+10h] [ebp-18h] BYREF

  memset(s, 255, 0x10u);
  result = trap_DObjCreateSkelForBones(a1, s);
  if ( !result )
  {
    trap_DObjCalcAnim(a1, s);
    if ( *(_DWORD *)(a1 + 552) )
      (*(void (__cdecl **)(int, char *))(a1 + 552))(a1, s);
    result = trap_DObjCalcSkel(a1, s);
  }
  return result;
}
// 12E50: using guessed type _DWORD __cdecl trap_DObjCreateSkelForBones(_DWORD, _DWORD);
// 13F40: using guessed type _DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD);
// 15940: using guessed type _DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD);

//----- (0006C877) --------------------------------------------------------
int __cdecl G_DObjCalcBone(int a1, int a2)
{
  int result; // eax
  char v3[24]; // [esp+10h] [ebp-18h] BYREF

  result = trap_DObjCreateSkelForBone(a1, a2);
  if ( !result )
  {
    trap_DObjGetHierarchyBits(a1, a2, v3);
    trap_DObjCalcAnim(a1, v3);
    if ( *(_DWORD *)(a1 + 552) )
      (*(void (__cdecl **)(int, char *))(a1 + 552))(a1, v3);
    result = trap_DObjCalcSkel(a1, v3);
  }
  return result;
}
// 13DD0: using guessed type _DWORD __cdecl trap_DObjCreateSkelForBone(_DWORD, _DWORD);
// 13F40: using guessed type _DWORD __cdecl trap_DObjCalcSkel(_DWORD, _DWORD);
// 15940: using guessed type _DWORD __cdecl trap_DObjCalcAnim(_DWORD, _DWORD);
// 15950: using guessed type _DWORD __cdecl trap_DObjGetHierarchyBits(_DWORD, _DWORD, _DWORD);

//----- (0006C908) --------------------------------------------------------
int __cdecl G_DObjGetLocalTagMatrix(int a1, int a2)
{
  int v4; // [esp+Ch] [ebp-Ch]

  v4 = trap_DObjGetBoneIndex(a1, a2);
  if ( v4 < 0 )
    return 0;
  G_DObjCalcBone(a1, v4);
  return trap_DObjGetMatrixArray(a1) + (v4 << 6);
}
// 13090: using guessed type _DWORD __cdecl G_DObjCalcBone(_DWORD, _DWORD);
// 148F0: using guessed type _DWORD __cdecl trap_DObjGetMatrixArray(_DWORD);
// 15930: using guessed type _DWORD __cdecl trap_DObjGetBoneIndex(_DWORD, _DWORD);

//----- (0006C973) --------------------------------------------------------
int __cdecl G_DObjGetWorldTagMatrix(_DWORD *a1, int a2, int a3)
{
  char v5[36]; // [esp+20h] [ebp-48h] BYREF
  int v6; // [esp+44h] [ebp-24h]
  int v7; // [esp+48h] [ebp-20h]
  int v8; // [esp+4Ch] [ebp-1Ch]
  int v9; // [esp+5Ch] [ebp-Ch]

  v9 = G_DObjGetLocalTagMatrix(a1, a2);
  if ( !v9 )
    return 0;
  AnglesToAxis(a1 + 81, v5);
  v6 = a1[78];
  v7 = a1[79];
  v8 = a1[80];
  DObjSkel2MatrixMultiply43(v9, v5, a3);
  return 1;
}
// 13AF0: using guessed type _DWORD __cdecl DObjSkel2MatrixMultiply43(_DWORD, _DWORD, _DWORD);
// 14570: using guessed type _DWORD __cdecl G_DObjGetLocalTagMatrix(_DWORD, _DWORD);
// 15390: using guessed type _DWORD __cdecl AnglesToAxis(_DWORD, _DWORD);

//----- (0006CA0D) --------------------------------------------------------
_DWORD *__cdecl G_Find(int a1, int a2, __int16 a3)
{
  __int16 v5; // [esp+4h] [ebp-8h]
  _DWORD *v6; // [esp+14h] [ebp+8h]

  if ( a1 )
    v6 = (_DWORD *)(a1 + 796);
  else
    v6 = g_entities;
  while ( v6 < &g_entities[199 * level[3]] )
  {
    if ( *((_BYTE *)v6 + 356) )
    {
      v5 = *(_WORD *)((char *)v6 + a2);
      if ( v5 )
      {
        if ( v5 == a3 )
          return v6;
      }
    }
    v6 += 199;
  }
  return 0;
}

//----- (0006CAAE) --------------------------------------------------------
_DWORD *__cdecl G_FindStr(int a1, int a2, int a3)
{
  int v5; // [esp+10h] [ebp-8h]
  _DWORD *v6; // [esp+20h] [ebp+8h]

  if ( a1 )
    v6 = (_DWORD *)(a1 + 796);
  else
    v6 = g_entities;
  while ( v6 < &g_entities[199 * level[3]] )
  {
    if ( *((_BYTE *)v6 + 356) )
    {
      v5 = *(_DWORD *)((char *)v6 + a2);
      if ( v5 )
      {
        if ( !Q_stricmp(v5, a3) )
          return v6;
      }
    }
    v6 += 199;
  }
  return 0;
}
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);

//----- (0006CB52) --------------------------------------------------------
int __cdecl G_PickTarget(unsigned __int16 a1)
{
  char v1; // al
  int v4[33]; // [esp+30h] [ebp-98h]
  int v5; // [esp+B4h] [ebp-14h]
  int v6; // [esp+B8h] [ebp-10h]
  unsigned __int16 v7; // [esp+BEh] [ebp-Ah]

  v7 = a1;
  v6 = 0;
  v5 = 0;
  if ( !a1 )
    return 0;
  do
  {
    v6 = G_Find(v6, 478, v7);
    if ( !v6 )
      break;
    v4[v5++] = v6;
  }
  while ( v5 != 32 );
  if ( v5 )
    return v4[rand() % v5];
  v1 = SL_ConvertToString(v7);
  G_Printf("G_PickTarget: target %s not found\n", v1);
  return 0;
}
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 151B0: using guessed type _DWORD __cdecl G_Find(_DWORD, _DWORD, _DWORD);

//----- (0006CC3A) --------------------------------------------------------
char *__cdecl vtos(float *a1)
{
  char *s; // [esp+20h] [ebp-8h]

  s = (char *)&unk_A8620 + 32 * dword_A8600;
  dword_A8600 = ((_BYTE)dword_A8600 + 1) & 7;
  Com_sprintf(s, 0x20u, "(%i %i %i)", (int)*a1);
  return s;
}
// A8600: using guessed type int dword_A8600;

//----- (0006CCDA) --------------------------------------------------------
char *__cdecl vtosf(float *a1)
{
  double v2; // [esp+Ch] [ebp-2Ch]
  char *s; // [esp+30h] [ebp-8h]

  s = (char *)&unk_A8740 + 64 * dword_A8720;
  dword_A8720 = ((_BYTE)dword_A8720 + 1) & 7;
  v2 = *a1;
  Com_sprintf(s, 0x40u, "(%f %f %f)", SLOBYTE(v2));
  return s;
}
// A8720: using guessed type int dword_A8720;

//----- (0006CD59) --------------------------------------------------------
int __cdecl G_SetMovedir(float *a1, _DWORD *a2)
{
  int result; // eax

  if ( *a1 == flt_84664 && a1[1] == flt_84668 && a1[2] == flt_8466C )
  {
    *a2 = dword_84670;
    a2[1] = dword_84674;
    a2[2] = dword_84678;
  }
  else if ( *a1 == flt_8467C && a1[1] == flt_84680 && a1[2] == flt_84684 )
  {
    *a2 = dword_84688;
    a2[1] = dword_8468C;
    a2[2] = dword_84690;
  }
  else
  {
    AngleVectors(a1, a2, 0, 0);
  }
  result = 0;
  a1[2] = 0.0;
  a1[1] = 0.0;
  *a1 = 0.0;
  return result;
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 84664: using guessed type float flt_84664;
// 84668: using guessed type float flt_84668;
// 8466C: using guessed type float flt_8466C;
// 84670: using guessed type int dword_84670;
// 84674: using guessed type int dword_84674;
// 84678: using guessed type int dword_84678;
// 8467C: using guessed type float flt_8467C;
// 84680: using guessed type float flt_84680;
// 84684: using guessed type float flt_84684;
// 84688: using guessed type int dword_84688;
// 8468C: using guessed type int dword_8468C;
// 84690: using guessed type int dword_84690;

//----- (0006CEA1) --------------------------------------------------------
int __cdecl G_InitGentity(int a1)
{
  int result; // eax

  *(_BYTE *)(a1 + 356) = 1;
  Scr_SetString(a1 + 380, scr_const[43]);
  *(_DWORD *)a1 = -280575753 * ((a1 - (int)g_entities) >> 2);
  *(_DWORD *)(a1 + 336) = 1023;
  *(_DWORD *)(a1 + 392) = 0;
  result = a1;
  *(_DWORD *)(a1 + 396) = 0;
  return result;
}
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0006CF21) --------------------------------------------------------
int G_Spawn()
{
  char v1; // [esp+4h] [ebp-34h]
  int v2; // [esp+2Ch] [ebp-Ch]
  int i; // [esp+30h] [ebp-8h]

  v2 = level[4];
  if ( v2 )
  {
    level[4] = *(_DWORD *)(level[4] + 780);
    if ( !level[4] )
      level[5] = 0;
    *(_DWORD *)(v2 + 780) = 0;
  }
  else
  {
    if ( level[3] == 1022 )
    {
      for ( i = 0; i < level[3]; ++i )
      {
        if ( LOWORD(g_entities[199 * i + 95]) )
          SL_ConvertToString(LOWORD(g_entities[199 * i + 95]));
        G_Printf("%4i: '%s', origin: %f %f %f\n", i);
      }
      G_Error("G_Spawn: no free entities", v1);
    }
    v2 = level[1] + 796 * level[3]++;
    trap_LocateGameData(level[1], level[3], 796, level[0], 8908);
  }
  G_InitGentity(v2);
  return v2;
}
// 6D046: variable 'v1' is possibly undefined
// 13A60: using guessed type _DWORD __cdecl trap_LocateGameData(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 143D0: using guessed type _DWORD __cdecl SL_ConvertToString(_DWORD);
// 14470: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);

//----- (0006D0FD) --------------------------------------------------------
_DWORD *G_SpawnPlayerClone()
{
  int v1; // [esp+8h] [ebp-10h]
  int v2; // [esp+Ch] [ebp-Ch]
  _DWORD *s; // [esp+10h] [ebp-8h]

  s = (_DWORD *)(level[1] + 796 * level[2179] + 50944);
  v1 = level[2179] + 1;
  level[2179] = v1 / 8;
  level[2179] = v1 - 8 * level[2179];
  v2 = s[2] & 8 ^ 8;
  if ( *((_BYTE *)s + 356) )
    G_FreeEntity(s);
  G_InitGentity(s);
  s[2] = v2;
  return s;
}
// 14470: using guessed type _DWORD __cdecl G_InitGentity(_DWORD);

//----- (0006D1CC) --------------------------------------------------------
int *__cdecl G_FreeEntityRefs(int *a1)
{
  int *result; // eax
  int v2; // [esp+0h] [ebp-14h]
  int v3; // [esp+4h] [ebp-10h]
  int i; // [esp+8h] [ebp-Ch] BYREF
  _DWORD *v5; // [esp+Ch] [ebp-8h]

  v3 = *a1;
  for ( i = 0; ; ++i )
  {
    result = (int *)i;
    if ( i >= level[3] )
      break;
    v5 = &g_entities[199 * i];
    if ( *((_BYTE *)v5 + 356) )
    {
      if ( (int *)v5[104] == a1 )
        v5[104] = 0;
      if ( v5[84] == v3 )
      {
        v5[84] = 1023;
        if ( v5[1] == 11 )
          *((_BYTE *)v5 + 374) = 0;
      }
      if ( v5[31] == v3 )
        v5[31] = 1023;
    }
  }
  for ( i = 0; i <= 63; ++i )
  {
    v5 = &g_entities[199 * i];
    if ( *((_BYTE *)v5 + 356) )
    {
      v2 = v5[87];
      if ( *(int **)(v2 + 8808) == a1 )
        *(_DWORD *)(v2 + 8808) = 0;
    }
    result = &i;
  }
  for ( i = 0; i <= 31; ++i )
  {
    if ( (int *)level[i + 2144] == a1 )
      level[i + 2144] = 0;
    result = &i;
  }
  return result;
}

//----- (0006D332) --------------------------------------------------------
int __cdecl G_FreeEntity(void *s)
{
  int result; // eax
  int v2; // [esp+10h] [ebp-8h]

  G_EntUnlink(s);
  while ( *((_DWORD *)s + 188) )
    G_EntUnlink(*((_DWORD *)s + 188));
  trap_UnlinkEntity(s);
  trap_SafeDObjFree(*(_DWORD *)s, 1);
  G_FreeEntityRefs(s);
  if ( *((_DWORD *)s + 88) )
    G_FreeTurret(s);
  Scr_FreeEntity(s);
  v2 = *((_DWORD *)s + 194);
  memset(s, 0, 0x31Cu);
  if ( -280575753 * (((int)s - level[1]) >> 2) > 71 )
  {
    if ( level[5] )
      *(_DWORD *)(level[5] + 780) = s;
    else
      level[4] = s;
    level[5] = s;
    *(_DWORD *)(level[5] + 780) = 0;
  }
  result = v2 + 1;
  *((_DWORD *)s + 194) = v2 + 1;
  return result;
}
// 12F20: using guessed type _DWORD __cdecl trap_SafeDObjFree(_DWORD, _DWORD);
// 13A90: using guessed type _DWORD __cdecl G_FreeTurret(_DWORD);
// 14180: using guessed type _DWORD __cdecl Scr_FreeEntity(_DWORD);
// 14480: using guessed type _DWORD __cdecl trap_UnlinkEntity(_DWORD);
// 148A0: using guessed type _DWORD __cdecl G_FreeEntityRefs(_DWORD);
// 15760: using guessed type _DWORD __cdecl G_EntUnlink(_DWORD);

//----- (0006D45E) --------------------------------------------------------
_DWORD *__cdecl G_TempEntity(int *a1, int a2)
{
  float v3; // [esp+20h] [ebp-28h] BYREF
  float v4; // [esp+24h] [ebp-24h]
  float v5; // [esp+28h] [ebp-20h]
  _DWORD *v6; // [esp+3Ch] [ebp-Ch]

  v6 = (_DWORD *)G_Spawn();
  v6[1] = a2 + 12;
  Scr_SetString(v6 + 95, scr_const[69]);
  v6[98] = level[122];
  v6[85] = level[122];
  v6[99] = 1;
  v3 = *(float *)a1;
  v4 = *((float *)a1 + 1);
  v5 = *((float *)a1 + 2);
  v3 = (float)(int)v3;
  v4 = (float)(int)v4;
  v5 = (float)(int)v5;
  G_SetOrigin(v6, &v3);
  trap_LinkEntity(v6);
  return v6;
}
// 12E70: using guessed type int G_Spawn(void);
// 13D40: using guessed type _DWORD __cdecl trap_LinkEntity(_DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);
// 15A40: using guessed type _DWORD __cdecl G_SetOrigin(_DWORD, _DWORD);

//----- (0006D57D) --------------------------------------------------------
int __cdecl G_KillBox(int a1)
{
  int result; // eax
  float v2[4]; // [esp+30h] [ebp-1048h] BYREF
  float v3[7]; // [esp+40h] [ebp-1038h] BYREF
  _DWORD *v4; // [esp+5Ch] [ebp-101Ch]
  int v5[1026]; // [esp+60h] [ebp-1018h] BYREF
  int v6; // [esp+1068h] [ebp-10h]
  int i; // [esp+106Ch] [ebp-Ch]

  v3[0] = *(float *)(*(_DWORD *)(a1 + 348) + 20) + *(float *)(a1 + 260);
  v3[1] = *(float *)(*(_DWORD *)(a1 + 348) + 24) + *(float *)(a1 + 264);
  v3[2] = *(float *)(*(_DWORD *)(a1 + 348) + 28) + *(float *)(a1 + 268);
  v2[0] = *(float *)(*(_DWORD *)(a1 + 348) + 20) + *(float *)(a1 + 272);
  v2[1] = *(float *)(*(_DWORD *)(a1 + 348) + 24) + *(float *)(a1 + 276);
  v2[2] = *(float *)(*(_DWORD *)(a1 + 348) + 28) + *(float *)(a1 + 280);
  v6 = trap_EntitiesInBox(v3, v2, v5, 1024, 0x2000000);
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= v6 )
      break;
    v4 = &g_entities[199 * v5[i]];
    if ( v4[87] )
    {
      if ( v4[60] )
        G_Damage(v4, a1, a1, 0, 0, 100000, 16, 20, 0);
    }
  }
  return result;
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13950: using guessed type _DWORD __cdecl trap_EntitiesInBox(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006D71E) --------------------------------------------------------
int __cdecl G_AddPredictableEvent(int a1, int a2, char a3)
{
  int result; // eax

  result = a1;
  if ( *(_DWORD *)(a1 + 348) )
    result = BG_AddPredictableEventToPlayerstate(a2, a3, *(_DWORD *)(a1 + 348));
  return result;
}
// 13690: using guessed type _DWORD __cdecl BG_AddPredictableEventToPlayerstate(_DWORD, char, _DWORD);

//----- (0006D763) --------------------------------------------------------
int __cdecl G_AddEvent(_DWORD *a1, int a2, int a3)
{
  int result; // eax

  if ( a1[87] )
  {
    *(_DWORD *)(a1[87] + 4 * (*(_DWORD *)(a1[87] + 132) & 3) + 136) = a2;
    *(_DWORD *)(a1[87] + 4 * ((*(_DWORD *)(a1[87] + 132))++ & 3) + 152) = a3;
  }
  else
  {
    a1[(a1[41] & 3) + 42] = a2;
    a1[(a1[41]++ & 3) + 46] = a3;
  }
  a1[98] = level[122];
  result = level[122];
  a1[85] = result;
  return result;
}

//----- (0006D841) --------------------------------------------------------
int __cdecl G_PlaySoundAliasAtPoint(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = a2;
  if ( (_BYTE)a2 )
  {
    v3 = G_TempEntity(a1, 172);
    result = (unsigned __int8)a2;
    *(_DWORD *)(v3 + 160) = (unsigned __int8)a2;
  }
  return result;
}
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006D888) --------------------------------------------------------
int __cdecl G_PlaySoundAlias(int a1, int a2)
{
  int result; // eax

  result = a2;
  if ( (_BYTE)a2 )
    result = G_AddEvent(a1, 172, (unsigned __int8)a2);
  return result;
}
// 158D0: using guessed type _DWORD __cdecl G_AddEvent(_DWORD, _DWORD, _DWORD);

//----- (0006D8C7) --------------------------------------------------------
int __cdecl G_AnimScriptSound(int a1, char *s2)
{
  unsigned __int8 v2; // al

  v2 = G_SoundAliasIndex(s2);
  return G_PlaySoundAlias(&g_entities[199 * a1], v2);
}
// 14AD0: using guessed type _DWORD __cdecl G_PlaySoundAlias(_DWORD, _DWORD);

//----- (0006D90C) --------------------------------------------------------
int __cdecl G_SetOrigin(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[6] = *a2;
  a1[7] = a2[1];
  a1[8] = a2[2];
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  a1[11] = 0;
  a1[10] = 0;
  a1[9] = 0;
  a1[78] = *a2;
  a1[79] = a2[1];
  result = a2[2];
  a1[80] = result;
  return result;
}

//----- (0006D9AD) --------------------------------------------------------
int __cdecl G_SetAngle(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  a1[15] = *a2;
  a1[16] = a2[1];
  a1[17] = a2[2];
  a1[12] = 0;
  a1[13] = 0;
  a1[14] = 0;
  a1[20] = 0;
  a1[19] = 0;
  a1[18] = 0;
  a1[81] = *a2;
  a1[82] = a2[1];
  result = a2[2];
  a1[83] = result;
  return result;
}

//----- (0006DA4E) --------------------------------------------------------
_BOOL4 __cdecl infront(float *a1, float *a2)
{
  float v3[7]; // [esp+20h] [ebp-38h] BYREF
  float v4; // [esp+3Ch] [ebp-1Ch]
  float v5; // [esp+40h] [ebp-18h] BYREF
  float v6; // [esp+44h] [ebp-14h]
  float v7; // [esp+48h] [ebp-10h]

  AngleVectors(a1 + 81, v3, 0, 0);
  v5 = a2[78] - a1[78];
  v6 = a2[79] - a1[79];
  v7 = a2[80] - a1[80];
  VectorNormalize(&v5);
  v4 = v5 * v3[0] + v6 * v3[1] + v7 * v3[2];
  return v4 > 0.0;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006DB19) --------------------------------------------------------
int DebugLine()
{
  return 0;
}

//----- (0006DB23) --------------------------------------------------------
_WORD *__cdecl G_SetConstString(_WORD *a1, int a2)
{
  __int16 v2; // dx
  _WORD *result; // eax

  Scr_SetString(a1, 0);
  v2 = SL_GetString(a2, 0);
  result = a1;
  *a1 = v2;
  return result;
}
// 13D10: using guessed type _DWORD __cdecl SL_GetString(_DWORD, _DWORD);
// 150F0: using guessed type _DWORD __cdecl Scr_SetString(_DWORD, _DWORD);

//----- (0006DB69) --------------------------------------------------------
void sub_6DB69()
{
  ;
}

//----- (0006DB70) --------------------------------------------------------
void __cdecl Weapon_Melee(_DWORD *a1, float *a2)
{
  int v2; // esi
  int v3; // eax
  float v4[4]; // [esp+30h] [ebp-58h] BYREF
  int v5; // [esp+40h] [ebp-48h]
  int v6; // [esp+44h] [ebp-44h]
  int v7; // [esp+48h] [ebp-40h]
  _DWORD *v8; // [esp+4Ch] [ebp-3Ch]
  float v9; // [esp+50h] [ebp-38h] BYREF
  _BYTE v10[12]; // [esp+54h] [ebp-34h] BYREF
  _BYTE v11[24]; // [esp+60h] [ebp-28h] BYREF
  unsigned __int16 v12; // [esp+78h] [ebp-10h]
  unsigned __int16 v13; // [esp+7Ch] [ebp-Ch]

  v5 = 7;
  v4[0] = *a2 * 64.0 + a2[9];
  v4[1] = a2[1] * 64.0 + a2[10];
  v4[2] = a2[2] * 64.0 + a2[11];
  trap_LocationalTrace(&v9, a2 + 9, v4, *a1, 41951281, &bulletPriorityMap);
  v6 = *(_DWORD *)(BG_GetInfoForWeapon(a1[50]) + 452);
  G_CheckHitTriggerDamage(a1, a2 + 9, v10, v6, v5);
  if ( (v11[12] & 0x10) == 0 && v9 != 1.0 )
  {
    v8 = &g_entities[199 * v12];
    if ( v8[87] )
      v7 = G_TempEntity(v10, 166);
    else
      v7 = G_TempEntity(v10, 167);
    *(_DWORD *)(v7 + 116) = v12;
    v2 = v7;
    *(_DWORD *)(v2 + 160) = (unsigned __int8)DirToByte(v11);
    *(_DWORD *)(v7 + 200) = a1[50];
    if ( v12 != 1022 )
    {
      if ( *((_BYTE *)v8 + 373) )
      {
        v3 = rand();
        G_Damage(v8, a1, a1, a2, v10, v6 + v3 % 5, 0, v5, v13);
      }
    }
  }
}
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 13E30: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006DD91) --------------------------------------------------------
int *__cdecl SnapVectorTowards(int a1, int a2)
{
  int v2; // esi
  int *result; // eax
  int i; // [esp+18h] [ebp-10h] BYREF

  for ( i = 0; i <= 2; ++i )
  {
    v2 = 4 * i;
    if ( *(float *)(a1 + 4 * i) < (long double)*(float *)(a2 + 4 * i) )
      *(float *)(a1 + v2) = ceil(*(float *)(a1 + 4 * i));
    else
      *(float *)(a1 + v2) = floor(*(float *)(a1 + 4 * i));
    result = &i;
  }
  return result;
}

//----- (0006DE44) --------------------------------------------------------
int __cdecl Bullet_Endpos(float a1, int a2, int a3)
{
  int result; // eax
  float v4; // [esp+10h] [ebp-18h]
  float v5; // [esp+14h] [ebp-14h]
  float v6; // [esp+1Ch] [ebp-Ch] BYREF
  float v7[2]; // [esp+20h] [ebp-8h] BYREF

  v4 = tan(a1 * 3.141592653589793 / 180.0);
  v5 = v4 * 8192.0;
  gunrandom(v7, &v6);
  v7[0] = v7[0] * v5;
  v6 = v6 * v5;
  *(float *)a2 = *(float *)a3 * 8192.0 + *(float *)(a3 + 36);
  *(float *)(a2 + 4) = *(float *)(a3 + 4) * 8192.0 + *(float *)(a3 + 40);
  *(float *)(a2 + 8) = *(float *)(a3 + 8) * 8192.0 + *(float *)(a3 + 44);
  *(float *)a2 = *(float *)(a3 + 12) * v7[0] + *(float *)a2;
  *(float *)(a2 + 4) = *(float *)(a3 + 16) * v7[0] + *(float *)(a2 + 4);
  *(float *)(a2 + 8) = *(float *)(a3 + 20) * v7[0] + *(float *)(a2 + 8);
  *(float *)a2 = *(float *)(a3 + 24) * v6 + *(float *)a2;
  *(float *)(a2 + 4) = *(float *)(a3 + 28) * v6 + *(float *)(a2 + 4);
  result = a3;
  *(float *)(a2 + 8) = *(float *)(a3 + 32) * v6 + *(float *)(a2 + 8);
  return result;
}
// 14300: using guessed type _DWORD __cdecl gunrandom(_DWORD, _DWORD);

//----- (0006DF8B) --------------------------------------------------------
int __cdecl Bullet_Fire(int a1, float a2, int a3, int a4, int a5)
{
  int v6[6]; // [esp+20h] [ebp-18h] BYREF

  Bullet_Endpos(a2, (int)v6, a4);
  return Bullet_Fire_Extended(a5, a1, a4 + 36, v6, a3, 0, a4, a5);
}
// 131B0: using guessed type _DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006DFFC) --------------------------------------------------------
int __cdecl Bullet_Fire_Extended(_DWORD *a1, _DWORD *a2, float *a3, float *a4, int a5, int a6, int a7, _DWORD *a8)
{
  int result; // eax
  int v9; // eax
  int v10; // esi
  char v11; // [esp+4h] [ebp-D4h]
  float v12; // [esp+3Ch] [ebp-9Ch]
  float v13; // [esp+40h] [ebp-98h]
  float v14; // [esp+50h] [ebp-88h] BYREF
  float v15; // [esp+54h] [ebp-84h]
  float v16; // [esp+58h] [ebp-80h]
  float v17; // [esp+60h] [ebp-78h] BYREF
  float v18; // [esp+64h] [ebp-74h]
  float v19; // [esp+68h] [ebp-70h]
  int v20; // [esp+78h] [ebp-60h]
  float v21; // [esp+7Ch] [ebp-5Ch]
  float v22; // [esp+80h] [ebp-58h] BYREF
  float v23; // [esp+84h] [ebp-54h]
  float v24; // [esp+88h] [ebp-50h]
  int v25; // [esp+90h] [ebp-48h]
  int v26; // [esp+94h] [ebp-44h]
  float *v27; // [esp+98h] [ebp-40h]
  int v28; // [esp+9Ch] [ebp-3Ch]
  char v29[4]; // [esp+A0h] [ebp-38h] BYREF
  float v30; // [esp+A4h] [ebp-34h] BYREF
  float v31; // [esp+A8h] [ebp-30h]
  float v32; // [esp+ACh] [ebp-2Ch]
  float v33; // [esp+B0h] [ebp-28h] BYREF
  float v34; // [esp+B4h] [ebp-24h]
  float v35; // [esp+B8h] [ebp-20h]
  int v36; // [esp+BCh] [ebp-1Ch]
  int v37; // [esp+C0h] [ebp-18h]
  unsigned __int16 v38; // [esp+C8h] [ebp-10h]
  unsigned __int16 v39; // [esp+CCh] [ebp-Ch]

  v26 = 0;
  if ( a6 > 12 )
    return Com_DPrintf("Bullet_Fire_Extended: Too many resursions, bullet aborted\n", v11);
  if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 704) )
  {
    v25 = 2;
    v26 = 32;
  }
  else
  {
    v25 = 1;
  }
  if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 704) )
    trap_LocationalTrace(v29, a3, a4, *a1, 41951281, &riflePriorityMap);
  else
    trap_LocationalTrace(v29, a3, a4, *a1, 41951281, &bulletPriorityMap);
  if ( (g_debugBullets[3] & 1) != 0 )
  {
    v28 = G_TempEntity(a3, 185);
    *(float *)(v28 + 92) = v30;
    *(float *)(v28 + 96) = v31;
    *(float *)(v28 + 100) = v32;
    *(_DWORD *)(v28 + 120) = *a2;
  }
  G_CheckHitTriggerDamage(a2, a3, &v30, a5, v25);
  v27 = (float *)&g_entities[199 * v38];
  if ( g_debugBullets[3] <= -2 )
  {
    v17 = v27[78];
    v18 = v27[79];
    v19 = v27[80];
    v14 = v27[78];
    v15 = v27[79];
    v16 = v27[80];
    v17 = v17 + v27[65];
    v18 = v18 + v27[66];
    v19 = v19 + v27[67];
    v14 = v14 + v27[68];
    v15 = v15 + v27[69];
    v16 = v16 + v27[70];
    v20 = G_TempEntity(&v17, 185);
    *(float *)(v20 + 92) = v14;
    *(float *)(v20 + 96) = v15;
    *(float *)(v20 + 100) = v16;
    *(_DWORD *)(v20 + 220) = 2;
  }
  v22 = *a4 - *a3;
  v23 = a4[1] - a3[1];
  v24 = a4[2] - a3[2];
  VectorNormalize(&v22);
  v21 = (v22 * v33 + v23 * v34 + v24 * v35) * -2.0;
  v22 = v33 * v21 + v22;
  v23 = v34 * v21 + v23;
  v24 = v35 * v21 + v24;
  if ( (v36 & 4) == 0 && !*((_DWORD *)v27 + 87) )
  {
    if ( *(_DWORD *)(*(_DWORD *)(a7 + 60) + 704) )
      v9 = G_TempEntity(&v30, 174);
    else
      v9 = G_TempEntity(&v30, 173);
    v28 = v9;
    *(_DWORD *)(v9 + 160) = (unsigned __int8)DirToByte(&v33);
    v10 = v28;
    *(_DWORD *)(v10 + 216) = (unsigned __int8)DirToByte(&v22);
    *(_DWORD *)(v28 + 136) = (v36 & 0x1F00000) >> 20;
    *(_DWORD *)(v28 + 116) = *a8;
  }
  if ( (v37 & 0x10) != 0 )
  {
    v14 = *a4 - *a3;
    v15 = a4[1] - a3[1];
    v16 = a4[2] - a3[2];
    VectorNormalize(&v14);
    v12 = v33 * v14 + v34 * v15 + v35 * v16;
    if ( COERCE_FLOAT(LODWORD(v12) ^ 0x80000000) < 0.125 )
      v13 = 0.0;
    else
      v13 = 0.25 / (float)-(float)(v33 * v14 + v34 * v15 + v35 * v16);
    v21 = v13;
    *a3 = v14 * v13 + v30;
    a3[1] = v15 * v21 + v31;
    a3[2] = v16 * v21 + v32;
    result = Bullet_Fire_Extended(a1, a2, a3, a4, a5, a6 + 1, a7, a8);
  }
  else
  {
    result = (int)v27;
    if ( *((_BYTE *)v27 + 373) )
    {
      G_Damage(v27, a2, a2, a7, &v30, a5, v26, v25, v39);
      result = (int)v27;
      if ( *((_DWORD *)v27 + 87) )
      {
        result = v26 & 0x20;
        if ( (v26 & 0x20) != 0 )
        {
          result = a5 / 2;
          if ( a5 / 2 > 0 )
            result = Bullet_Fire_Extended(v27, a2, &v30, a4, a5 / 2, a6 + 1, a7, a8);
        }
      }
    }
  }
  return result;
}
// 6E028: variable 'v11' is possibly undefined
// 131B0: using guessed type _DWORD __cdecl Bullet_Fire_Extended(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13290: using guessed type _DWORD __cdecl G_Damage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 13360: using guessed type _DWORD __cdecl trap_LocationalTrace(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 13E30: using guessed type _DWORD __cdecl G_CheckHitTriggerDamage(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 14220: using guessed type _DWORD __cdecl DirToByte(_DWORD);
// 15350: using guessed type _DWORD __cdecl G_TempEntity(_DWORD, _DWORD);

//----- (0006E5A6) --------------------------------------------------------
float *__cdecl weapon_grenadelauncher_fire(int a1, int a2, int a3)
{
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+24h] [ebp-24h]
  float v7; // [esp+28h] [ebp-20h]
  float *v8; // [esp+3Ch] [ebp-Ch]

  v5 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 800) * *(float *)a3;
  v6 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 800) * *(float *)(a3 + 4);
  v7 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 800) * *(float *)(a3 + 8);
  v7 = (long double)*(int *)(*(_DWORD *)(a3 + 60) + 804) + v7;
  v8 = (float *)fire_grenade(a1, a3 + 36, &v5, a2);
  VectorNormalize(&v5);
  v4 = *(float *)(*(_DWORD *)(a1 + 348) + 32) * v5
     + *(float *)(*(_DWORD *)(a1 + 348) + 36) * v6
     + *(float *)(*(_DWORD *)(a1 + 348) + 40) * v7;
  v8[9] = v5 * v4 + v8[9];
  v8[10] = v6 * v4 + v8[10];
  v8[11] = v7 * v4 + v8[11];
  return v8;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 14DC0: using guessed type _DWORD __cdecl fire_grenade(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006E6BC) --------------------------------------------------------
int __cdecl Weapon_RocketLauncher_Fire(int a1, float a2, int a3)
{
  int result; // eax
  float v4; // [esp+18h] [ebp-40h]
  int v5[4]; // [esp+20h] [ebp-38h] BYREF
  float v6; // [esp+30h] [ebp-28h] BYREF
  float v7; // [esp+34h] [ebp-24h]
  float v8; // [esp+38h] [ebp-20h]
  float v9; // [esp+40h] [ebp-18h]
  float v10; // [esp+44h] [ebp-14h] BYREF
  float v11; // [esp+48h] [ebp-10h] BYREF
  float v12; // [esp+4Ch] [ebp-Ch]

  v12 = 16.0;
  v4 = tan(a2 * 3.141592653589793 / 180.0);
  v9 = v4 * 16.0;
  gunrandom(&v11, &v10);
  v11 = v11 * v9;
  v10 = v10 * v9;
  v6 = *(float *)a3 * v12;
  v7 = *(float *)(a3 + 4) * v12;
  v8 = *(float *)(a3 + 8) * v12;
  v6 = *(float *)(a3 + 12) * v11 + v6;
  v7 = *(float *)(a3 + 16) * v11 + v7;
  v8 = *(float *)(a3 + 20) * v11 + v8;
  v6 = *(float *)(a3 + 24) * v10 + v6;
  v7 = *(float *)(a3 + 28) * v10 + v7;
  v8 = *(float *)(a3 + 32) * v10 + v8;
  VectorNormalize(&v6);
  v5[0] = *(_DWORD *)(a3 + 36);
  v5[1] = *(_DWORD *)(a3 + 40);
  v5[2] = *(_DWORD *)(a3 + 44);
  fire_rocket(a1, v5, &v6);
  result = a1;
  if ( *(_DWORD *)(a1 + 348) )
  {
    *(float *)(*(_DWORD *)(a1 + 348) + 32) = *(float *)a3 * -64.0 + *(float *)(*(_DWORD *)(a1 + 348) + 32);
    *(float *)(*(_DWORD *)(a1 + 348) + 36) = *(float *)(a3 + 4) * -64.0 + *(float *)(*(_DWORD *)(a1 + 348) + 36);
    result = a3;
    *(float *)(*(_DWORD *)(a1 + 348) + 40) = *(float *)(a3 + 8) * -64.0 + *(float *)(*(_DWORD *)(a1 + 348) + 40);
  }
  return result;
}
// 139D0: using guessed type long double __cdecl VectorNormalize(_DWORD);
// 14300: using guessed type _DWORD __cdecl gunrandom(_DWORD, _DWORD);
// 14BA0: using guessed type _DWORD __cdecl fire_rocket(_DWORD, _DWORD, _DWORD);

//----- (0006E876) --------------------------------------------------------
_BOOL4 __cdecl LogAccuracyHit(int a1, int a2)
{
  if ( !*(_BYTE *)(a1 + 373) )
    return 0;
  if ( a1 == a2 )
    return 0;
  if ( !*(_DWORD *)(a1 + 348) )
    return 0;
  if ( !*(_DWORD *)(a2 + 348) )
    return 0;
  if ( *(int *)(*(_DWORD *)(a1 + 348) + 4) <= 5 )
    return OnSameTeam(a1, a2) == 0;
  return 0;
}
// 13880: using guessed type _DWORD __cdecl OnSameTeam(_DWORD, _DWORD);

//----- (0006E91F) --------------------------------------------------------
void __cdecl CalcMuzzlePoint(int a1, float *a2)
{
  long double v2; // fst7
  float v3; // [esp+18h] [ebp-30h]
  float v4; // [esp+1Ch] [ebp-2Ch]
  float v5[6]; // [esp+20h] [ebp-28h] BYREF
  float v6; // [esp+38h] [ebp-10h]
  float v7; // [esp+3Ch] [ebp-Ch]

  *a2 = *(float *)(*(_DWORD *)(a1 + 348) + 20);
  a2[1] = *(float *)(*(_DWORD *)(a1 + 348) + 24);
  a2[2] = *(float *)(*(_DWORD *)(a1 + 348) + 28);
  a2[2] = a2[2] + *(float *)(*(_DWORD *)(a1 + 348) + 208);
  if ( (*(_WORD *)(*(_DWORD *)(a1 + 348) + 128) & 0xC000) == 0 )
  {
    v4 = BG_GetBobCycle(*(_DWORD *)(a1 + 348));
    v3 = BG_GetSpeed(*(_DWORD *)(a1 + 348), level[122]);
    BG_GetVerticalBobFactor(*(_DWORD *)(a1 + 348), v4, v3, bg_bobMax[2]);
    v7 = v3;
    v2 = a2[2] + v3;
    a2[2] = v2;
    BG_GetHorizontalBobFactor(*(_DWORD *)(a1 + 348), v4, v3, bg_bobMax[2]);
    v6 = v2;
    AngleVectors(*(_DWORD *)(a1 + 348) + 192, 0, v5, 0);
    *a2 = v5[0] * v6 + *a2;
    a2[1] = v5[1] * v6 + a2[1];
    a2[2] = v5[2] * v6 + a2[2];
    G_AddLean(a1, a2);
    if ( *(float *)(*(_DWORD *)(a1 + 348) + 28) + 8.0 > a2[2] )
      a2[2] = *(float *)(*(_DWORD *)(a1 + 348) + 28) + 8.0;
  }
}
// 13270: using guessed type double __cdecl BG_GetBobCycle(_DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 14630: using guessed type _DWORD __cdecl G_AddLean(_DWORD, _DWORD);
// 15080: using guessed type double __cdecl BG_GetSpeed(_DWORD, _DWORD);

//----- (0006EB1D) --------------------------------------------------------
int __cdecl CalcMuzzlePoints(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-18h] BYREF
  int v4; // [esp+14h] [ebp-14h]
  int v5; // [esp+18h] [ebp-10h]

  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 192);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 196);
  v5 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 200);
  v3 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8724);
  v4 = *(_DWORD *)(*(_DWORD *)(a1 + 348) + 8728);
  AngleVectors(&v3, a2, a2 + 12, a2 + 24);
  return CalcMuzzlePoint(a1, a2 + 36);
}
// 13060: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0006EBCA) --------------------------------------------------------
int __cdecl FireWeapon(int a1)
{
  int result; // eax
  float v2; // [esp+2Ch] [ebp-5Ch]
  int v3[15]; // [esp+30h] [ebp-58h] BYREF
  int v4; // [esp+6Ch] [ebp-1Ch]
  float v5; // [esp+78h] [ebp-10h]
  float v6; // [esp+7Ch] [ebp-Ch]

  if ( (*(_WORD *)(*(_DWORD *)(a1 + 348) + 128) & 0xC000) == 0 || (result = a1, !*(_BYTE *)(a1 + 374)) )
  {
    v4 = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    CalcMuzzlePoints(a1, v3);
    v6 = *(float *)(*(_DWORD *)(a1 + 348) + 8776);
    if ( *(float *)(*(_DWORD *)(a1 + 348) + 184) == 1.0 )
    {
      v5 = (*(float *)(v4 + 584) - *(float *)(v4 + 920)) * v6 + *(float *)(v4 + 920);
    }
    else
    {
      v2 = BG_GetMinSpreadForWeapon(*(_DWORD *)(a1 + 348), *(_DWORD *)(a1 + 200), level[122]);
      v5 = (*(float *)(v4 + 584) - v2) * v6 + v2;
    }
    if ( *(_DWORD *)(v4 + 112) )
    {
      if ( *(_DWORD *)(v4 + 112) == 1 )
      {
        result = weapon_grenadelauncher_fire(a1, *(_DWORD *)(a1 + 200), v3);
      }
      else if ( *(_DWORD *)(v4 + 112) == 2 )
      {
        result = Weapon_RocketLauncher_Fire(a1, v5, (int)v3);
      }
      else
      {
        result = G_Error("Unknown weapon type %i for %s\n", *(_DWORD *)(v4 + 112));
      }
    }
    else
    {
      result = Bullet_Fire(a1, v5, *(_DWORD *)(v4 + 448), (int)v3, a1);
    }
  }
  return result;
}
// 12E80: using guessed type double __cdecl BG_GetMinSpreadForWeapon(_DWORD, _DWORD, _DWORD);
// 12FB0: using guessed type _DWORD __cdecl weapon_grenadelauncher_fire(_DWORD, _DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);
// 14FA0: using guessed type _DWORD __cdecl CalcMuzzlePoints(_DWORD, _DWORD);

//----- (0006ED84) --------------------------------------------------------
int __cdecl FireWeaponMelee(int a1)
{
  int result; // eax
  char v2[12]; // [esp+10h] [ebp-48h] BYREF
  int v3; // [esp+1Ch] [ebp-3Ch] BYREF
  int v4; // [esp+28h] [ebp-30h] BYREF
  _DWORD v5[9]; // [esp+34h] [ebp-24h] BYREF

  if ( (*(_WORD *)(*(_DWORD *)(a1 + 348) + 128) & 0xC000) == 0 || (result = a1, !*(_BYTE *)(a1 + 374)) )
  {
    v5[6] = BG_GetInfoForWeapon(*(_DWORD *)(a1 + 200));
    AngleVectors(*(_DWORD *)(a1 + 348) + 192, v2, &v3, &v4);
    CalcMuzzlePoint(a1, v5);
    result = Weapon_Melee(a1, v2);
  }
  return result;
}
// 13060: using guessed type _DWORD __cdecl CalcMuzzlePoint(_DWORD, _DWORD);
// 13070: using guessed type _DWORD __cdecl Weapon_Melee(_DWORD, _DWORD);
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);
// 13C90: using guessed type _DWORD __cdecl BG_GetInfoForWeapon(_DWORD);

//----- (0006EE32) --------------------------------------------------------
void sub_6EE32()
{
  ;
}

//----- (0006EE38) --------------------------------------------------------
int __cdecl Com_BeginParseSession(char *src)
{
  char v2; // [esp+8h] [ebp-10h]

  if ( dword_A9140 == 15 )
    Com_Error(0, byte_7F260, v2);
  ++dword_A9140;
  off_88C9C = (char *)&unk_846A0 + 1116 * dword_A9140;
  *((_DWORD *)off_88C9C + 256) = 1;
  *((_DWORD *)off_88C9C + 257) = 0;
  *((_DWORD *)off_88C9C + 258) = 1;
  *((_DWORD *)off_88C9C + 259) = 0;
  return Q_strncpyz((char *)off_88C9C + 1052, src, 64);
}
// 6EE64: variable 'v2' is possibly undefined
// 88C9C: using guessed type void *off_88C9C;
// A9140: using guessed type int dword_A9140;

//----- (0006EEF3) --------------------------------------------------------
char *Com_EndParseSession()
{
  char *result; // eax
  char v1; // [esp+8h] [ebp-10h]

  if ( !dword_A9140 )
    Com_Error(0, byte_7F2A0, v1);
  --dword_A9140;
  result = (char *)&unk_846A0 + 1116 * dword_A9140;
  off_88C9C = result;
  return result;
}
// 6EF1F: variable 'v1' is possibly undefined
// 88C9C: using guessed type void *off_88C9C;
// A9140: using guessed type int dword_A9140;

//----- (0006EF4C) --------------------------------------------------------
void *Com_ResetParseSessions()
{
  void *result; // eax

  dword_A9140 = 0;
  result = &unk_846A0;
  off_88C9C = &unk_846A0;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;
// A9140: using guessed type int dword_A9140;

//----- (0006EF84) --------------------------------------------------------
int __cdecl Com_SetSpaceDelimited(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_88C9C + 258) = a1;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006EFA5) --------------------------------------------------------
int __cdecl Com_SetCSV(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_88C9C + 259) = a1;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006EFC6) --------------------------------------------------------
int __cdecl Com_SetParseNegativeNumbers(int a1)
{
  int result; // eax

  result = a1;
  *((_DWORD *)off_88C9C + 260) = a1;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006EFE7) --------------------------------------------------------
int Com_GetCurrentParseLine()
{
  return *((_DWORD *)off_88C9C + 256);
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F005) --------------------------------------------------------
int Com_ScriptError(char *format, ...)
{
  char s[32012]; // [esp+20h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D2Ch] [ebp-Ch]
  va_list va; // [esp+7D44h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return Com_Error(1, byte_7F2C8, (_BYTE)off_88C9C + 28);
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F084) --------------------------------------------------------
int Com_ScriptWarning(char *format, ...)
{
  char s[32012]; // [esp+10h] [ebp-7D18h] BYREF
  __gnuc_va_list __varargs; // [esp+7D1Ch] [ebp-Ch]
  va_list va; // [esp+7D34h] [ebp+Ch] BYREF

  va_start(va, format);
  va_copy(__varargs, va);
  vsprintf(s, format, va);
  return Com_Printf("File %s, line %i: %s", (_BYTE)off_88C9C + 28);
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F0FB) --------------------------------------------------------
int Com_UngetToken()
{
  int result; // eax
  char v1; // [esp+4h] [ebp-4h]

  if ( *((_DWORD *)off_88C9C + 257) )
    Com_ScriptError("UngetToken called twice", v1);
  *((_DWORD *)off_88C9C + 257) = 1;
  result = dword_A9148;
  dword_A9144 = dword_A9148;
  return result;
}
// 6F125: variable 'v1' is possibly undefined
// 88C9C: using guessed type void *off_88C9C;
// A9144: using guessed type int dword_A9144;
// A9148: using guessed type int dword_A9148;

//----- (0006F14C) --------------------------------------------------------
int __cdecl Com_ParseSetMark(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *a2 = *((_DWORD *)off_88C9C + 256);
  a2[1] = *a1;
  a2[2] = *((_DWORD *)off_88C9C + 257);
  a2[3] = *((_DWORD *)off_88C9C + 261);
  result = *((_DWORD *)off_88C9C + 262);
  a2[4] = result;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F1B0) --------------------------------------------------------
int __cdecl Com_ParseReturnToMark(_DWORD *a1, _DWORD *a2)
{
  int result; // eax

  *((_DWORD *)off_88C9C + 256) = *a2;
  *a1 = a2[1];
  *((_DWORD *)off_88C9C + 257) = a2[2];
  *((_DWORD *)off_88C9C + 261) = a2[3];
  result = a2[4];
  *((_DWORD *)off_88C9C + 262) = result;
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F214) --------------------------------------------------------
_BYTE *__cdecl sub_6F214(_BYTE *a1, _DWORD *a2)
{
  int v4; // [esp+4h] [ebp-8h]

  while ( 1 )
  {
    v4 = (char)*a1;
    if ( v4 > 32 )
      break;
    if ( !*a1 )
      return 0;
    if ( v4 == 10 )
    {
      ++*((_DWORD *)off_88C9C + 256);
      *a2 = 1;
    }
    ++a1;
  }
  return a1;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006F278) --------------------------------------------------------
int __cdecl Com_Compress(_BYTE *a1)
{
  int v2; // [esp+4h] [ebp-10h]
  char v3; // [esp+Bh] [ebp-9h]
  _BYTE *v4; // [esp+Ch] [ebp-8h]
  char *v5; // [esp+10h] [ebp-4h]

  v2 = 0;
  v4 = a1;
  v5 = a1;
  if ( a1 )
  {
    while ( 1 )
    {
      v3 = *v5;
      if ( !*v5 )
        break;
      if ( v3 == 13 || v3 == 10 )
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
      else if ( v3 == 47 && v5[1] == 47 )
      {
        while ( *v5 && *v5 != 10 )
          ++v5;
      }
      else if ( v3 == 47 && v5[1] == 42 )
      {
        while ( *v5 && (*v5 != 42 || v5[1] != 47) )
        {
          if ( *v5 == 10 )
          {
            *v4++ = 10;
            ++v2;
          }
          ++v5;
        }
        if ( *v5 )
          v5 += 2;
      }
      else
      {
        *v4++ = v3;
        ++v2;
        ++v5;
      }
    }
  }
  *v4 = 0;
  return v2;
}
// 6F378: conditional instruction was optimized away because of '%var_14.4==0'

//----- (0006F3B4) --------------------------------------------------------
int Com_GetLastTokenPos()
{
  return dword_A9144;
}
// A9144: using guessed type int dword_A9144;

//----- (0006F3CC) --------------------------------------------------------
void *__cdecl sub_6F3CC(_BYTE **a1, int a2)
{
  _BYTE *v4; // [esp+4h] [ebp-Ch]
  _BYTE *i; // [esp+4h] [ebp-Ch]
  int v6; // [esp+8h] [ebp-8h]

  v4 = *a1;
  v6 = 0;
  *(_BYTE *)off_88C9C = 0;
  if ( a2 )
  {
    while ( *v4 == 13 || *v4 == 10 )
      ++v4;
  }
  else if ( *v4 == 13 || *v4 == 10 )
  {
    return off_88C9C;
  }
  dword_A9148 = dword_A9144;
  dword_A9144 = (int)v4;
  while ( *v4 && *v4 != 44 && *v4 != 10 )
  {
    if ( *v4 == 13 )
    {
      ++v4;
    }
    else if ( *v4 == 34 )
    {
      for ( i = v4 + 1; ; i += 2 )
      {
        while ( *i != 34 )
        {
          if ( v6 <= 1022 )
            *((_BYTE *)off_88C9C + v6++) = *i;
          ++i;
        }
        if ( i[1] != 34 )
          break;
        if ( v6 <= 1022 )
          *((_BYTE *)off_88C9C + v6++) = 34;
      }
      v4 = i + 1;
    }
    else
    {
      if ( v6 <= 1022 )
        *((_BYTE *)off_88C9C + v6++) = *v4;
      ++v4;
    }
  }
  if ( *v4 )
  {
    if ( *v4 != 10 )
      ++v4;
    *a1 = v4;
  }
  else
  {
    *a1 = 0;
  }
  *((_BYTE *)off_88C9C + v6) = 0;
  return off_88C9C;
}
// 88C9C: using guessed type void *off_88C9C;
// A9144: using guessed type int dword_A9144;
// A9148: using guessed type int dword_A9148;

//----- (0006F55E) --------------------------------------------------------
void *__cdecl sub_6F55E(char **a1, int a2)
{
  char v3; // [esp+8h] [ebp-30h]
  void *v4; // [esp+14h] [ebp-24h]
  signed int j; // [esp+18h] [ebp-20h]
  signed int n; // [esp+1Ch] [ebp-1Ch]
  const char **i; // [esp+20h] [ebp-18h]
  char *v8; // [esp+24h] [ebp-14h]
  char *v9; // [esp+24h] [ebp-14h]
  int v10; // [esp+28h] [ebp-10h] BYREF
  int v11; // [esp+2Ch] [ebp-Ch]
  char v12; // [esp+33h] [ebp-5h]

  v12 = 0;
  v10 = 0;
  if ( !a1 )
    Com_Error(0, byte_7F30B, v3);
  v8 = *a1;
  v11 = 0;
  *(_BYTE *)off_88C9C = 0;
  if ( v8 )
  {
    *((_DWORD *)off_88C9C + 261) = *((_DWORD *)off_88C9C + 256);
    *((_DWORD *)off_88C9C + 262) = *a1;
    if ( *((_DWORD *)off_88C9C + 259) )
    {
      v4 = sub_6F3CC(a1, a2);
    }
    else
    {
      while ( 1 )
      {
        while ( 1 )
        {
          v8 = sub_6F214(v8, &v10);
          if ( !v8 )
          {
            *a1 = 0;
            return off_88C9C;
          }
          if ( v10 && !a2 )
          {
            *a1 = v8;
            return off_88C9C;
          }
          v12 = *v8;
          if ( v12 != 47 || v8[1] != 47 )
            break;
          while ( *v8 && *v8 != 10 )
            ++v8;
        }
        if ( v12 != 47 || v8[1] != 42 )
          break;
        while ( *v8 && (*v8 != 42 || v8[1] != 47) )
        {
          if ( *v8 == 10 )
            ++*((_DWORD *)off_88C9C + 256);
          ++v8;
        }
        if ( *v8 )
          v8 += 2;
      }
      dword_A9148 = dword_A9144;
      dword_A9144 = (int)v8;
      if ( v12 == 34 )
      {
        v9 = v8 + 1;
        while ( 1 )
        {
          v12 = *v9++;
          if ( v12 == 92 && *v9 == 34 )
          {
            v12 = *v9++;
          }
          else
          {
            if ( v12 == 34 || !v12 )
            {
              *((_BYTE *)off_88C9C + v11) = 0;
              *a1 = v9;
              return off_88C9C;
            }
            if ( *v9 == 10 )
              ++*((_DWORD *)off_88C9C + 256);
          }
          if ( v11 <= 1022 )
            *((_BYTE *)off_88C9C + v11++) = v12;
        }
      }
      if ( *((_DWORD *)off_88C9C + 258) )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_88C9C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 32 );
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_88C9C + v11) = 0;
        *a1 = v8;
        v4 = off_88C9C;
      }
      else if ( v12 > 47 && v12 <= 57
             || *((_DWORD *)off_88C9C + 260) && v12 == 45 && v8[1] > 47 && v8[1] <= 57
             || v12 == 46 && v8[1] > 47 && v8[1] <= 57 )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_88C9C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 47 && v12 <= 57 || v12 == 46 );
        if ( v12 == 101 || v12 == 69 )
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_88C9C + v11++) = v12;
          v12 = *++v8;
          if ( v12 == 45 || v12 == 43 )
          {
            if ( v11 <= 1022 )
              *((_BYTE *)off_88C9C + v11++) = v12;
            v12 = *++v8;
          }
          do
          {
            if ( v11 <= 1022 )
              *((_BYTE *)off_88C9C + v11++) = v12;
            v12 = *++v8;
          }
          while ( v12 > 47 && v12 <= 57 );
        }
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_88C9C + v11) = 0;
        *a1 = v8;
        v4 = off_88C9C;
      }
      else if ( v12 > 96 && v12 <= 122 || v12 > 64 && v12 <= 90 || v12 == 95 || v12 == 47 || v12 == 92 )
      {
        do
        {
          if ( v11 <= 1022 )
            *((_BYTE *)off_88C9C + v11++) = v12;
          v12 = *++v8;
        }
        while ( v12 > 96 && v12 <= 122
             || v12 > 64 && v12 <= 90
             || v12 == 95
             || v12 > 47 && v12 <= 57
             || v12 == 47
             || v12 == 92
             || v12 == 58
             || v12 == 46 );
        if ( v11 == 1024 )
          v11 = 0;
        *((_BYTE *)off_88C9C + v11) = 0;
        *a1 = v8;
        v4 = off_88C9C;
      }
      else
      {
        for ( i = (const char **)&off_88C60; ; ++i )
        {
          if ( !*i )
          {
            *(_BYTE *)off_88C9C = *v8;
            *((_BYTE *)off_88C9C + 1) = 0;
            *a1 = v8 + 1;
            return off_88C9C;
          }
          n = strlen(*i);
          for ( j = 0; j < n && v8[j] == (*i)[j]; ++j )
            ;
          if ( j == n )
            break;
        }
        memcpy(off_88C9C, *i, n);
        *((_BYTE *)off_88C9C + n) = 0;
        *a1 = &v8[n];
        v4 = off_88C9C;
      }
    }
  }
  else
  {
    *a1 = 0;
    v4 = off_88C9C;
  }
  return v4;
}
// 6F592: variable 'v3' is possibly undefined
// 88C60: using guessed type void *off_88C60;
// 88C9C: using guessed type void *off_88C9C;
// A9144: using guessed type int dword_A9144;
// A9148: using guessed type int dword_A9148;

//----- (0006FB5C) --------------------------------------------------------
void *__cdecl Com_Parse(char **a1)
{
  if ( *((_DWORD *)off_88C9C + 257) )
  {
    *((_DWORD *)off_88C9C + 257) = 0;
    *a1 = (char *)*((_DWORD *)off_88C9C + 262);
    *((_DWORD *)off_88C9C + 256) = *((_DWORD *)off_88C9C + 261);
  }
  return sub_6F55E(a1, 1);
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006FBCF) --------------------------------------------------------
void *__cdecl Com_ParseOnLine(char **a1)
{
  if ( !*((_DWORD *)off_88C9C + 257) )
    return sub_6F55E(a1, 0);
  *((_DWORD *)off_88C9C + 257) = 0;
  if ( *((_DWORD *)off_88C9C + 258) )
  {
    *a1 = (char *)*((_DWORD *)off_88C9C + 262);
    *((_DWORD *)off_88C9C + 256) = *((_DWORD *)off_88C9C + 261);
    return sub_6F55E(a1, 0);
  }
  return off_88C9C;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006FC62) --------------------------------------------------------
int __cdecl Com_MatchToken(int a1, char *s2, int a3)
{
  int result; // eax
  char *s1; // [esp+10h] [ebp-8h]

  s1 = (char *)Com_Parse(a1);
  result = strcmp(s1, s2);
  if ( result )
  {
    if ( a3 )
      result = Com_ScriptWarning("MatchToken: %s != %s", (char)s1);
    else
      result = Com_ScriptError("MatchToken: %s != %s", (char)s1);
  }
  return result;
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (0006FCDE) --------------------------------------------------------
int __cdecl Com_SkipBracedSection(_DWORD *a1, int a2)
{
  int v3; // [esp+8h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-Ch]
  _BYTE *v5; // [esp+10h] [ebp-8h]

  v3 = 0;
  v4 = 0;
  do
  {
    v5 = (_BYTE *)Com_Parse(a1);
    if ( !v5[1] )
    {
      if ( *v5 == 123 )
      {
        if ( v4 == a2 )
          v3 = 1;
        else
          ++v4;
      }
      else if ( *v5 == 125 )
      {
        --v4;
      }
    }
  }
  while ( v4 && *a1 );
  return v3;
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (0006FD59) --------------------------------------------------------
_BYTE *__cdecl Com_SkipRestOfLine(_DWORD *a1)
{
  _BYTE *result; // eax
  int v2; // [esp+0h] [ebp-Ch]
  _BYTE *v3; // [esp+4h] [ebp-8h]

  result = (_BYTE *)*a1;
  v3 = (_BYTE *)*a1;
  if ( *a1 )
  {
    while ( 1 )
    {
      v2 = (char)*v3;
      if ( !*v3 )
        break;
      ++v3;
      if ( v2 == 10 )
      {
        ++*((_DWORD *)off_88C9C + 256);
        break;
      }
    }
    result = v3;
    *a1 = v3;
  }
  return result;
}
// 88C9C: using guessed type void *off_88C9C;

//----- (0006FDB3) --------------------------------------------------------
char *__cdecl Com_ParseRestOfLine(int a1)
{
  char *src; // [esp+10h] [ebp-8h]

  for ( byte_A8D40 = 0; ; Q_strcat(&byte_A8D40, 1024, src) )
  {
    src = (char *)Com_ParseOnLine(a1);
    if ( !*src )
      break;
    if ( byte_A8D40 )
      Q_strcat(&byte_A8D40, 1024, " ");
  }
  return &byte_A8D40;
}
// 15830: using guessed type _DWORD __cdecl Com_ParseOnLine(_DWORD);
// A8D40: using guessed type char byte_A8D40;

//----- (0006FE38) --------------------------------------------------------
long double __cdecl Com_ParseFloat(int a1)
{
  char *nptr; // [esp+10h] [ebp-8h]

  nptr = (char *)Com_Parse(a1);
  if ( !*nptr )
    return 0.0;
  return (float)atof(nptr);
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (0006FE88) --------------------------------------------------------
int __cdecl Com_ParseInt(int a1)
{
  int v2; // [esp+Ch] [ebp-Ch]
  char *nptr; // [esp+10h] [ebp-8h]

  nptr = (char *)Com_Parse(a1);
  if ( *nptr )
    v2 = atoi(nptr);
  else
    v2 = 0;
  return v2;
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);

//----- (0006FED0) --------------------------------------------------------
int __cdecl Com_Parse1DMatrix(int a1, int a2, int a3)
{
  int i; // [esp+14h] [ebp-14h]
  char *nptr; // [esp+18h] [ebp-10h]

  Com_MatchToken(a1, (char *)&off_7F344, 0);
  for ( i = 0; i < a2; ++i )
  {
    nptr = (char *)Com_Parse(a1);
    *(float *)(a3 + 4 * i) = atof(nptr);
  }
  return Com_MatchToken(a1, (char *)&off_7F344 + 2, 0);
}
// 130E0: using guessed type _DWORD __cdecl Com_Parse(_DWORD);
// 7F344: using guessed type void *off_7F344;

//----- (0006FF67) --------------------------------------------------------
int __cdecl Com_Parse2DMatrix(int a1, int a2, int a3, int a4)
{
  int i; // [esp+10h] [ebp-8h]

  Com_MatchToken(a1, (char *)&off_7F344, 0);
  for ( i = 0; i < a2; ++i )
    Com_Parse1DMatrix(a1, a3, a4 + 4 * a3 * i);
  return Com_MatchToken(a1, (char *)&off_7F344 + 2, 0);
}
// 136C0: using guessed type _DWORD __cdecl Com_Parse1DMatrix(_DWORD, _DWORD, _DWORD);
// 7F344: using guessed type void *off_7F344;

//----- (0006FFF4) --------------------------------------------------------
int __cdecl Com_Parse3DMatrix(int a1, int a2, int a3, int a4, int a5)
{
  int i; // [esp+10h] [ebp-8h]

  Com_MatchToken(a1, (char *)&off_7F344, 0);
  for ( i = 0; i < a2; ++i )
    Com_Parse2DMatrix(a1, a3, a4, a5 + 4 * a3 * a4 * i);
  return Com_MatchToken(a1, (char *)&off_7F344 + 2, 0);
}
// 15860: using guessed type _DWORD __cdecl Com_Parse2DMatrix(_DWORD, _DWORD, _DWORD, _DWORD);
// 7F344: using guessed type void *off_7F344;

//----- (0007008C) --------------------------------------------------------
void sub_7008C()
{
  ;
}

//----- (00070090) --------------------------------------------------------
int __cdecl ColorIndex(char a1)
{
  int v2; // [esp+0h] [ebp-8h]

  if ( (unsigned __int8)(a1 - 48) > 9u )
    v2 = 7;
  else
    v2 = (unsigned __int8)(a1 - 48);
  return v2;
}

//----- (000700C0) --------------------------------------------------------
long double __cdecl Com_Clamp(float a1, float a2, float a3)
{
  if ( a1 > (long double)a3 )
    return a1;
  if ( a3 <= (long double)a2 )
    return a3;
  return a2;
}

//----- (00070101) --------------------------------------------------------
_BYTE *__cdecl Com_SkipPath(_BYTE *a1)
{
  _BYTE *v2; // [esp+0h] [ebp-4h]

  v2 = a1;
  while ( *a1 )
  {
    if ( *a1 == 47 )
      v2 = a1 + 1;
    ++a1;
  }
  return v2;
}

//----- (00070130) --------------------------------------------------------
_BYTE *__cdecl Com_StripExtension(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax

  while ( *a1 && *a1 != 46 )
    *a2++ = *a1++;
  result = a2;
  *a2 = 0;
  return result;
}

//----- (00070165) --------------------------------------------------------
_BYTE *__cdecl Com_StripFilename(char *s, char *dest)
{
  int v2; // eax
  _BYTE *result; // eax

  v2 = strlen(s);
  Q_strncpyz(dest, s, v2);
  result = (_BYTE *)Com_SkipPath(dest);
  *result = 0;
  return result;
}
// 13970: using guessed type _DWORD __cdecl Com_SkipPath(_DWORD);

//----- (000701B2) --------------------------------------------------------
char *__cdecl Com_DefaultExtension(char *s, size_t maxlen)
{
  char *result; // eax
  char *i; // [esp+2Ch] [ebp-4Ch]
  char dest[72]; // [esp+30h] [ebp-48h] BYREF

  for ( i = &s[strlen(s) - 1]; *i != 47 && i != s; --i )
  {
    result = i;
    if ( *i == 46 )
      return result;
  }
  Q_strncpyz(dest, s, 64);
  return (char *)Com_sprintf(s, maxlen, "%s%s", (char)dest);
}

//----- (00070243) --------------------------------------------------------
int __cdecl Com_BitCheck(int a1, int a2)
{
  return (*(int *)(a1 + 4 * (a2 >> 5)) >> (a2 & 0x1F)) & 1;
}

//----- (00070266) --------------------------------------------------------
int __cdecl Com_BitSet(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) | (1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (000702AA) --------------------------------------------------------
int __cdecl Com_BitClear(int a1, int a2)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4 * (a2 >> 5)) & ~(1 << (a2 & 0x1F));
  *(_DWORD *)(a1 + 4 * (a2 >> 5)) = result;
  return result;
}

//----- (000702E8) --------------------------------------------------------
int __cdecl BigShort(__int16 a1)
{
  return (__int16)dword_BCBE0(a1);
}
// BCBE0: using guessed type int (__cdecl *dword_BCBE0)(_DWORD);

//----- (00070317) --------------------------------------------------------
int __cdecl BigLong(int a1)
{
  return dword_BCBE8(a1);
}
// BCBE8: using guessed type int (__cdecl *dword_BCBE8)(_DWORD);

//----- (0007033D) --------------------------------------------------------
int __userpurge BigLong64@<eax>(int a1, int a2, int a3)
{
  dword_BCBF0(a1, a2, a3);
  return a1;
}
// BCBF0: using guessed type int (__cdecl *dword_BCBF0)(_DWORD, _DWORD, _DWORD);

//----- (00070386) --------------------------------------------------------
int __userpurge LittleLong64@<eax>(int a1, int a2, int a3)
{
  dword_BCBF4(a1, a2, a3);
  return a1;
}
// BCBF4: using guessed type int (__cdecl *dword_BCBF4)(_DWORD, _DWORD, _DWORD);

//----- (000703CF) --------------------------------------------------------
int __cdecl BigFloat(int a1)
{
  return dword_BCBF8(a1);
}
// BCBF8: using guessed type int (__cdecl *dword_BCBF8)(_DWORD);

//----- (000703F5) --------------------------------------------------------
int __cdecl ShortSwap(__int16 a1)
{
  return (__int16)(((unsigned __int8)a1 << 8) + HIBYTE(a1));
}

//----- (0007042C) --------------------------------------------------------
int __cdecl ShortNoSwap(__int16 a1)
{
  return a1;
}

//----- (0007043F) --------------------------------------------------------
int __cdecl LongSwap(int a1)
{
  return HIBYTE(a1) + (BYTE2(a1) << 8) + (BYTE1(a1) << 16) + ((unsigned __int8)a1 << 24);
}

//----- (0007049B) --------------------------------------------------------
int __cdecl LongNoSwap(int a1)
{
  return a1;
}

//----- (000704A3) --------------------------------------------------------
_DWORD *__userpurge Long64Swap@<eax>(_DWORD *a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch]

  LOBYTE(v4) = HIBYTE(a3);
  BYTE1(v4) = BYTE2(a3);
  BYTE2(v4) = BYTE1(a3);
  HIBYTE(v4) = a3;
  LOBYTE(v5) = HIBYTE(a2);
  BYTE1(v5) = BYTE2(a2);
  BYTE2(v5) = BYTE1(a2);
  HIBYTE(v5) = a2;
  *a1 = v4;
  a1[1] = v5;
  return a1;
}

//----- (00070501) --------------------------------------------------------
_DWORD *__userpurge Long64NoSwap@<eax>(_DWORD *a1, int a2, int a3)
{
  _DWORD *result; // eax

  result = a1;
  *a1 = a2;
  a1[1] = a3;
  return result;
}

//----- (00070525) --------------------------------------------------------
long double __cdecl FloatSwap(int a1)
{
  float v2; // [esp+4h] [ebp-8h]

  LOBYTE(v2) = HIBYTE(a1);
  BYTE1(v2) = BYTE2(a1);
  BYTE2(v2) = BYTE1(a1);
  HIBYTE(v2) = a1;
  return v2;
}

//----- (00070558) --------------------------------------------------------
long double __cdecl FloatNoSwap(float a1)
{
  return a1;
}

//----- (00070569) --------------------------------------------------------
long double (__cdecl *Swap_Init())(float a1)
{
  long double (__cdecl *result)(float); // eax

  dword_BCBE0 = (int (__cdecl *)(_DWORD))ShortSwap;
  dword_BCBE4 = (int)ShortNoSwap;
  dword_BCBE8 = LongSwap;
  dword_BCBEC = (int)LongNoSwap;
  dword_BCBF0 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))Long64Swap;
  dword_BCBF4 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))Long64NoSwap;
  dword_BCBF8 = (int (__cdecl *)(_DWORD))FloatSwap;
  result = FloatNoSwap;
  dword_BCBFC = (int)FloatNoSwap;
  return result;
}
// BCBE0: using guessed type int (__cdecl *dword_BCBE0)(_DWORD);
// BCBE4: using guessed type int dword_BCBE4;
// BCBE8: using guessed type int (__cdecl *dword_BCBE8)(_DWORD);
// BCBEC: using guessed type int dword_BCBEC;
// BCBF0: using guessed type int (__cdecl *dword_BCBF0)(_DWORD, _DWORD, _DWORD);
// BCBF4: using guessed type int (__cdecl *dword_BCBF4)(_DWORD, _DWORD, _DWORD);
// BCBF8: using guessed type int (__cdecl *dword_BCBF8)(_DWORD);
// BCBFC: using guessed type int dword_BCBFC;

//----- (00070652) --------------------------------------------------------
_BOOL4 __cdecl Q_isprint(int a1)
{
  return a1 > 31 && a1 <= 126;
}

//----- (00070679) --------------------------------------------------------
_BOOL4 __cdecl Q_islower(int a1)
{
  return a1 > 96 && a1 <= 122;
}

//----- (000706A0) --------------------------------------------------------
_BOOL4 __cdecl Q_isupper(int a1)
{
  return a1 > 64 && a1 <= 90;
}

//----- (000706C7) --------------------------------------------------------
_BOOL4 __cdecl Q_isalpha(int a1)
{
  return a1 > 96 && a1 <= 122 || a1 > 64 && a1 <= 90;
}

//----- (000706FC) --------------------------------------------------------
_BOOL4 __cdecl Q_isnumeric(int a1)
{
  return a1 > 47 && a1 <= 57;
}

//----- (00070723) --------------------------------------------------------
_BOOL4 __cdecl Q_isalphanumeric(int a1)
{
  return Q_isalpha(a1) || Q_isnumeric(a1);
}
// 13C50: using guessed type _DWORD __cdecl Q_isnumeric(_DWORD);
// 13DA0: using guessed type _DWORD __cdecl Q_isalpha(_DWORD);

//----- (0007076E) --------------------------------------------------------
_BOOL4 __cdecl Q_isforfilename(int a1)
{
  return (Q_isalphanumeric(a1) || a1 == 95 || a1 == 45) && a1 != 32;
}
// 12F30: using guessed type _DWORD __cdecl Q_isalphanumeric(_DWORD);

//----- (000707BC) --------------------------------------------------------
_BYTE *__cdecl Q_strrchr(_BYTE *a1, char a2)
{
  _BYTE *v3; // [esp+0h] [ebp-Ch]

  v3 = 0;
  while ( *a1 )
  {
    if ( *a1 == a2 )
      v3 = a1;
    ++a1;
  }
  if ( !a2 )
    v3 = a1;
  return v3;
}

//----- (00070809) --------------------------------------------------------
char *__cdecl Q_strncpyz(char *dest, char *src, int a3)
{
  char *result; // eax

  strncpy(dest, src, a3 - 1);
  result = &dest[a3 - 1];
  *result = 0;
  return result;
}

//----- (00070845) --------------------------------------------------------
int __cdecl Q_stricmpn(char *a1, char *a2, int a3)
{
  int v4; // [esp+4h] [ebp-14h]
  int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
    {
      if ( Q_islower(v7) )
        v7 -= 32;
      if ( Q_islower(v6) )
        v6 -= 32;
      if ( v7 != v6 )
        break;
    }
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}
// 14200: using guessed type _DWORD __cdecl Q_islower(_DWORD);

//----- (000708FA) --------------------------------------------------------
int __cdecl Q_strncmp(char *a1, char *a2, int a3)
{
  int v4; // [esp+0h] [ebp-10h]
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    v7 = *a1++;
    v6 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v7 != v6 )
      break;
    if ( !v7 )
      return 0;
  }
  if ( v7 >= v6 )
    v4 = 1;
  else
    v4 = -1;
  return v4;
}

//----- (00070969) --------------------------------------------------------
int __cdecl Q_stricmp(int a1, int a2)
{
  int v3; // [esp+10h] [ebp-8h]

  if ( a1 && a2 )
    v3 = Q_stricmpn(a1, a2, 99999);
  else
    v3 = -1;
  return v3;
}
// 14DA0: using guessed type _DWORD __cdecl Q_stricmpn(_DWORD, _DWORD, _DWORD);

//----- (000709B6) --------------------------------------------------------
_BYTE *__cdecl Q_strlwr(_BYTE *a1)
{
  _BYTE *i; // [esp+Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
    *i = tolower((char)*i);
  return a1;
}

//----- (000709FD) --------------------------------------------------------
_BYTE *__cdecl Q_strupr(_BYTE *a1)
{
  _BYTE *i; // [esp+Ch] [ebp-Ch]

  for ( i = a1; *i; ++i )
    *i = toupper((char)*i);
  return a1;
}

//----- (00070A44) --------------------------------------------------------
int __cdecl Q_strcat(char *s, int a2, char *src)
{
  char v4; // [esp+8h] [ebp-10h]
  int v5; // [esp+10h] [ebp-8h]

  v5 = strlen(s);
  if ( v5 >= a2 )
    Com_Error(0, byte_7F495, v4);
  return Q_strncpyz(&s[v5], src, a2 - v5);
}
// 70A7D: variable 'v4' is possibly undefined

//----- (00070AA9) --------------------------------------------------------
int __cdecl Q_DrawStrlen(_BYTE *a1)
{
  int v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  while ( *a1 )
  {
    if ( a1 && *a1 == 94 && a1[1] && a1[1] != 94 && (char)a1[1] > 47 && (char)a1[1] <= 57 )
    {
      a1 += 2;
    }
    else
    {
      ++v2;
      ++a1;
    }
  }
  return v2;
}

//----- (00070B11) --------------------------------------------------------
char *__cdecl Q_CleanStr(char *a1)
{
  char v2; // [esp+3h] [ebp-9h]
  char *v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = a1;
  v4 = a1;
  while ( 1 )
  {
    v2 = *v3;
    if ( !*v3 )
      break;
    if ( v3 && *v3 == 94 && v3[1] && v3[1] != 94 && v3[1] > 47 && v3[1] <= 57 )
    {
      ++v3;
    }
    else if ( v2 > 31 && v2 != 127 )
    {
      *v4++ = v2;
    }
    ++v3;
  }
  *v4 = 0;
  return a1;
}

//----- (00070B99) --------------------------------------------------------
int __cdecl Q_CleanCharacter(char a1)
{
  if ( (unsigned __int8)a1 == 146 )
    return 39;
  if ( a1 >= 0 )
    return a1;
  return 46;
}

//----- (00070BD9) --------------------------------------------------------
int Com_sprintf(char *s, size_t maxlen, char *format, ...)
{
  int result; // eax
  va_list va; // [esp+3Ch] [ebp+14h] BYREF

  va_start(va, format);
  result = vsnprintf(s, maxlen, format, va);
  s[maxlen - 1] = 0;
  return result;
}

//----- (00070C27) --------------------------------------------------------
int __cdecl Q_strncasecmp(char *a1, char *a2, int a3)
{
  int v5; // [esp+Ch] [ebp-Ch]
  int v6; // [esp+10h] [ebp-8h]

  do
  {
    v6 = *a1++;
    v5 = *a2++;
    if ( --a3 == -1 )
      return 0;
    if ( v6 != v5 )
    {
      if ( Q_islower(v6) )
        v6 -= 32;
      if ( Q_islower(v5) )
        v5 -= 32;
      if ( v6 != v5 )
        return -1;
    }
  }
  while ( v6 );
  return 0;
}
// 14200: using guessed type _DWORD __cdecl Q_islower(_DWORD);

//----- (00070CC1) --------------------------------------------------------
int __cdecl Q_strcasecmp(int a1, int a2)
{
  return Q_strncasecmp(a1, a2, 99999);
}
// 13FF0: using guessed type _DWORD __cdecl Q_strncasecmp(_DWORD, _DWORD, _DWORD);

//----- (00070CF3) --------------------------------------------------------
char *va(char *format, ...)
{
  char v2; // [esp+8h] [ebp-20h]
  int v3; // [esp+18h] [ebp-10h]
  char *dest; // [esp+1Ch] [ebp-Ch]
  va_list v5; // [esp+34h] [ebp+Ch] BYREF

  va_start(v5, format);
  v3 = vsnprintf(byte_A91E0, 0x7D00u, format, v5);
  byte_B0EDF = 0;
  if ( v3 < 0 || v3 > 31999 )
    Com_Error(1, byte_7F4C0, v2);
  if ( v3 + dword_88CA0 > 31998 )
    dword_88CA0 = 0;
  dest = (char *)&unk_B0EE0 + dword_88CA0;
  memcpy((char *)&unk_B0EE0 + dword_88CA0, byte_A91E0, v3 + 1);
  dword_88CA0 += v3 + 1;
  return dest;
}
// 70D5B: variable 'v2' is possibly undefined
// 88CA0: using guessed type int dword_88CA0;
// B0EDF: using guessed type char byte_B0EDF;

//----- (00070DBF) --------------------------------------------------------
_DWORD *__cdecl tv(int a1, int a2, int a3)
{
  _DWORD *v4; // [esp+0h] [ebp-8h]

  v4 = (_DWORD *)((char *)&unk_A9180 + 12 * dword_A9160);
  dword_A9160 = ((_BYTE)dword_A9160 + 1) & 7;
  *v4 = a1;
  v4[1] = a2;
  v4[2] = a3;
  return v4;
}
// A9160: using guessed type int dword_A9160;

//----- (00070E26) --------------------------------------------------------
char *__cdecl Info_ValueForKey(char *s, int a2)
{
  char v3; // [esp+8h] [ebp-2020h]
  char *v5; // [esp+1Ch] [ebp-200Ch]
  _BYTE *v6; // [esp+1Ch] [ebp-200Ch]
  char v7[8200]; // [esp+20h] [ebp-2008h] BYREF
  char *sa; // [esp+2030h] [ebp+8h]

  if ( !s || !a2 )
    return (char *)&unk_7F4EE;
  if ( strlen(s) > 0x1FFF )
    Com_Error(1, byte_7F500, v3);
  dword_88CA4 ^= 1u;
  if ( *s == 92 )
    ++s;
  while ( 1 )
  {
    v5 = v7;
    while ( *s != 92 )
    {
      if ( !*s )
        return (char *)&unk_7F4EE;
      *v5++ = *s++;
    }
    *v5 = 0;
    sa = s + 1;
    v6 = (char *)&unk_B8BE0 + 0x2000 * dword_88CA4;
    while ( *sa != 92 && *sa )
      *v6++ = *sa++;
    *v6 = 0;
    if ( !Q_stricmp(a2, v7) )
      return (char *)&unk_B8BE0 + 0x2000 * dword_88CA4;
    if ( !*sa )
      break;
    s = sa + 1;
  }
  return (char *)&unk_7F4EE;
}
// 70E7B: variable 'v3' is possibly undefined
// 14DF0: using guessed type _DWORD __cdecl Q_stricmp(_DWORD, _DWORD);
// 88CA4: using guessed type int dword_88CA4;

//----- (00070F9E) --------------------------------------------------------
_BYTE *__cdecl Info_NextPair(_BYTE **a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // [esp+0h] [ebp-8h]
  _BYTE *v5; // [esp+0h] [ebp-8h]
  _BYTE *v6; // [esp+4h] [ebp-4h]
  _BYTE *v7; // [esp+4h] [ebp-4h]

  v4 = *a1;
  if ( **a1 == 92 )
    ++v4;
  *a2 = 0;
  *a3 = 0;
  v6 = a2;
  while ( *v4 != 92 )
  {
    if ( !*v4 )
    {
      *v6 = 0;
      result = v4;
      *a1 = v4;
      return result;
    }
    *v6++ = *v4++;
  }
  *v6 = 0;
  v5 = v4 + 1;
  v7 = a3;
  while ( *v5 != 92 && *v5 )
    *v7++ = *v5++;
  *v7 = 0;
  result = v5;
  *a1 = v5;
  return result;
}

//----- (00071052) --------------------------------------------------------
char *__cdecl Info_RemoveKey(char *s, char *s1)
{
  char *result; // eax
  char v3; // [esp+8h] [ebp-830h]
  char *v4; // [esp+1Ch] [ebp-81Ch]
  char *v5; // [esp+1Ch] [ebp-81Ch]
  char v6; // [esp+20h] [ebp-818h] BYREF
  char s2[1036]; // [esp+420h] [ebp-418h] BYREF
  char *dest; // [esp+82Ch] [ebp-Ch]

  if ( strlen(s) > 0x3FF )
    Com_Error(1, byte_7F540, v3);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v4 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      ++s;
      v5 = &v6;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v5++ = *s++;
      }
      *v5 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}
// 7108A: variable 'v3' is possibly undefined

//----- (00071199) --------------------------------------------------------
char *__cdecl Info_RemoveKey_Big(char *s, char *s1)
{
  char *result; // eax
  char v3; // [esp+8h] [ebp-4030h]
  char *v4; // [esp+1Ch] [ebp-401Ch]
  char *v5; // [esp+1Ch] [ebp-401Ch]
  char v6; // [esp+20h] [ebp-4018h] BYREF
  char s2[8204]; // [esp+2020h] [ebp-2018h] BYREF
  char *dest; // [esp+402Ch] [ebp-Ch]

  if ( strlen(s) > 0x1FFF )
    Com_Error(1, byte_7F580, v3);
  result = strchr(s1, 92);
  if ( !result )
  {
    while ( 1 )
    {
      dest = s;
      if ( *s == 92 )
        ++s;
      v4 = s2;
      while ( *s != 92 )
      {
        result = s;
        if ( !*s )
          return result;
        *v4++ = *s++;
      }
      *v4 = 0;
      ++s;
      v5 = &v6;
      while ( *s != 92 && *s )
      {
        result = s;
        if ( !*s )
          return result;
        *v5++ = *s++;
      }
      *v5 = 0;
      if ( !strcmp(s1, s2) )
        break;
      result = s;
      if ( !*s )
        return result;
    }
    result = strcpy(dest, s);
  }
  return result;
}
// 711D1: variable 'v3' is possibly undefined

//----- (000712E0) --------------------------------------------------------
_BOOL4 __cdecl Info_Validate(char *s)
{
  _BOOL4 v2; // [esp+10h] [ebp-8h]

  if ( strchr(s, 34) )
    v2 = 0;
  else
    v2 = strchr(s, 59) == 0;
  return v2;
}

//----- (00071342) --------------------------------------------------------
char *__cdecl Info_SetValueForKey(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // esi
  char v5; // [esp+4h] [ebp-834h]
  char v6; // [esp+4h] [ebp-834h]
  char v7; // [esp+23h] [ebp-815h]
  int v8; // [esp+28h] [ebp-810h]
  int i; // [esp+2Ch] [ebp-80Ch]
  char v10[1024]; // [esp+30h] [ebp-808h] BYREF
  char src[1032]; // [esp+430h] [ebp-408h] BYREF

  if ( strlen(s) > 0x3FF )
    return (char *)Com_Printf(byte_7F5C0, v5);
  v8 = 0;
  for ( i = 0; i <= 1022; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf(byte_7F600, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf(byte_7F640, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf(byte_7F680, (char)s1);
  result = (char *)Info_RemoveKey(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x400u, "\\%s\\%s", (char)s1) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x400 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf(byte_7F720, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf(byte_7F6C0, v6);
    }
  }
  return result;
}
// 71373: variable 'v5' is possibly undefined
// 71520: variable 'v6' is possibly undefined

//----- (00071590) --------------------------------------------------------
char *__cdecl Info_SetValueForKey_Big(char *s, char *s1, int a3)
{
  char *result; // eax
  size_t v4; // esi
  char v5; // [esp+4h] [ebp-4034h]
  char v6; // [esp+4h] [ebp-4034h]
  char v7; // [esp+23h] [ebp-4015h]
  int v8; // [esp+28h] [ebp-4010h]
  int i; // [esp+2Ch] [ebp-400Ch]
  char v10[8192]; // [esp+30h] [ebp-4008h] BYREF
  char src[8200]; // [esp+2030h] [ebp-2008h] BYREF

  if ( strlen(s) > 0x1FFF )
    return (char *)Com_Printf(byte_7F5C0, v5);
  v8 = 0;
  for ( i = 0; i <= 8190; ++i )
  {
    v7 = *(_BYTE *)(a3 + i);
    if ( !v7 )
      break;
    if ( v7 != 92 && v7 != 59 && v7 != 34 )
      v10[v8++] = v7;
  }
  v10[v8] = 0;
  if ( strchr(s1, 92) )
    return (char *)Com_Printf(byte_7F600, (char)s1);
  if ( strchr(s1, 59) )
    return (char *)Com_Printf(byte_7F640, (char)s1);
  if ( strchr(s1, 34) )
    return (char *)Com_Printf(byte_7F680, (char)s1);
  result = (char *)Info_RemoveKey_Big(s, s1);
  if ( v10[0] )
  {
    if ( Com_sprintf(src, 0x2000u, "\\%s\\%s", (char)s1) > 0 )
    {
      v4 = strlen(src);
      if ( strlen(s) + v4 <= 0x2000 )
        result = strcat(s, src);
      else
        result = (char *)Com_Printf(byte_7F780, (char)s1);
    }
    else
    {
      result = (char *)Com_Printf(byte_7F6C0, v6);
    }
  }
  return result;
}
// 715C1: variable 'v5' is possibly undefined
// 7176E: variable 'v6' is possibly undefined

//----- (000717DE) --------------------------------------------------------
_BOOL4 __cdecl ParseConfigStringToStruct(int a1, int a2, int a3, char *s, int a5, int a6, int a7)
{
  _DWORD *v7; // esi
  float *v8; // esi
  _DWORD *v9; // esi
  float v12; // [esp+20h] [ebp-18h]
  char *nptr; // [esp+28h] [ebp-10h]
  int i; // [esp+2Ch] [ebp-Ch]

  for ( i = 0; i < a3; ++i )
  {
    nptr = (char *)Info_ValueForKey(s, *(_DWORD *)a2);
    if ( *nptr )
    {
      if ( *(int *)(a2 + 8) > 7 )
      {
        if ( a5 <= 0 || *(_DWORD *)(a2 + 8) >= a5 )
        {
          Com_Error(1, byte_7F7C8, *(_DWORD *)(a2 + 8));
        }
        else if ( !((int (__cdecl *)(int, char *, _DWORD))a6)(a1, nptr, *(_DWORD *)(a2 + 8)) )
        {
          return 0;
        }
      }
      else
      {
        switch ( *(_DWORD *)(a2 + 8) )
        {
          case 0:
            ((void (__cdecl *)(int, char *))a7)(a1 + *(_DWORD *)(a2 + 4), nptr);
            break;
          case 1:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 1024);
            break;
          case 2:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 64);
            break;
          case 3:
            Q_strncpyz((char *)(a1 + *(_DWORD *)(a2 + 4)), nptr, 256);
            break;
          case 4:
            *(_DWORD *)(a1 + *(_DWORD *)(a2 + 4)) = atoi(nptr);
            break;
          case 5:
            v7 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            *v7 = atoi(nptr) != 0;
            break;
          case 6:
            v8 = (float *)(*(_DWORD *)(a2 + 4) + a1);
            *v8 = atof(nptr);
            break;
          case 7:
            v9 = (_DWORD *)(*(_DWORD *)(a2 + 4) + a1);
            v12 = atof(nptr);
            *v9 = (int)(v12 * 1000.0);
            break;
          default:
            break;
        }
      }
    }
    a2 += 12;
  }
  return i == a3;
}

//----- (00071A17) --------------------------------------------------------
long double __cdecl GetLeanFraction(float a1)
{
  return (2.0 - sub_71E69(a1)) * a1;
}

//----- (00071A45) --------------------------------------------------------
long double __cdecl UnGetLeanFraction(float a1)
{
  float v2; // [esp+10h] [ebp-8h]

  v2 = sqrt(1.0 - a1);
  return 1.0 - v2;
}

//----- (00071A7C) --------------------------------------------------------
void __cdecl AddLeanToPosition(int a1, int a2, float a3, float a4, float a5)
{
  int v5[4]; // [esp+10h] [ebp-38h] BYREF
  float v6[7]; // [esp+20h] [ebp-28h] BYREF
  float v7; // [esp+3Ch] [ebp-Ch]

  if ( a3 != 0.0 )
  {
    GetLeanFraction(a3);
    v7 = 0.0;
    v5[0] = 0;
    v5[1] = a2;
    *(float *)&v5[2] = (float)0.0 * a4;
    AngleVectors(v5, 0, v6, 0);
    v7 = v7 * a5;
    *(float *)a1 = v6[0] * v7 + *(float *)a1;
    *(float *)(a1 + 4) = v6[1] * v7 + *(float *)(a1 + 4);
    *(float *)(a1 + 8) = v6[2] * v7 + *(float *)(a1 + 8);
  }
}
// 13B00: using guessed type _DWORD __cdecl AngleVectors(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00071B3E) --------------------------------------------------------
float *__cdecl OrientationPosToWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + *a1 + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a1[1] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a1[2] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (00071BEC) --------------------------------------------------------
float *__cdecl OrientationDirToWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[6] + a2[2] * a1[9];
  a3[1] = *a2 * a1[4] + a2[1] * a1[7] + a2[2] * a1[10];
  result = a2 + 2;
  a3[2] = *a2 * a1[5] + a2[1] * a1[8] + a2[2] * a1[11];
  return result;
}

//----- (00071C87) --------------------------------------------------------
float *__cdecl OrientationPosFromWorldPos(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float v4; // [esp+0h] [ebp-18h]
  float v5; // [esp+4h] [ebp-14h]
  float v6; // [esp+8h] [ebp-10h]

  v4 = *a2 - *a1;
  v5 = a2[1] - a1[1];
  v6 = a2[2] - a1[2];
  *a3 = v4 * a1[3] + v5 * a1[4] + v6 * a1[5];
  a3[1] = v4 * a1[6] + v5 * a1[7] + v6 * a1[8];
  result = a1;
  a3[2] = v4 * a1[9] + v5 * a1[10] + v6 * a1[11];
  return result;
}

//----- (00071D30) --------------------------------------------------------
float *__cdecl OrientationDirFromWorldDir(float *a1, float *a2, float *a3)
{
  float *result; // eax

  *a3 = *a2 * a1[3] + a2[1] * a1[4] + a2[2] * a1[5];
  a3[1] = *a2 * a1[6] + a2[1] * a1[7] + a2[2] * a1[8];
  result = a2 + 2;
  a3[2] = *a2 * a1[9] + a2[1] * a1[10] + a2[2] * a1[11];
  return result;
}

//----- (00071DCB) --------------------------------------------------------
int Q_GetDecimalDelimiter()
{
  return 46;
}

//----- (00071DD5) --------------------------------------------------------
int __cdecl Q_LocalizedFloatToString(float a1, char *s, int a3, int a4, int a5)
{
  int result; // eax
  unsigned __int8 v6; // [esp+1Fh] [ebp-9h]
  unsigned int i; // [esp+20h] [ebp-8h]

  snprintf(s, a3 - 1, "%.*f", a4, a1);
  s[a3 - 1] = 0;
  result = Q_GetDecimalDelimiter(a5);
  v6 = result;
  if ( (_BYTE)result != 46 )
  {
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      if ( s[i] == 46 )
      {
        result = v6;
        s[i] = v6;
        return result;
      }
    }
  }
  return result;
}
// 15370: using guessed type int __cdecl Q_GetDecimalDelimiter(_DWORD);

//----- (00071E69) --------------------------------------------------------
long double __cdecl sub_71E69(float a1)
{
  return (float)fabs(a1);
}

//----- (00071E82) --------------------------------------------------------
void sub_71E82()
{
  ;
}

//----- (00071E88) --------------------------------------------------------
int __cdecl Scr_GetBool(int a1)
{
  return dword_BCC00(a1);
}
// BCC00: using guessed type int (__cdecl *dword_BCC00)(_DWORD);

//----- (00071EAE) --------------------------------------------------------
int __cdecl Scr_GetInt(int a1)
{
  return dword_BCC04(a1);
}
// BCC04: using guessed type int (__cdecl *dword_BCC04)(_DWORD);

//----- (00071ED4) --------------------------------------------------------
int __userpurge Scr_GetAnim@<eax>(int a1, int a2, int a3)
{
  dword_BCC08(a1, a2, a3);
  return a1;
}
// BCC08: using guessed type int (__cdecl *dword_BCC08)(_DWORD, _DWORD, _DWORD);

//----- (00071F11) --------------------------------------------------------
int __userpurge Scr_GetAnimTree@<eax>(int a1, int a2)
{
  dword_BCC0C(a1, a2);
  return a1;
}
// BCC0C: using guessed type int (__cdecl *dword_BCC0C)(_DWORD, _DWORD);

//----- (00071F47) --------------------------------------------------------
int __cdecl Scr_GetFloat(int a1)
{
  return dword_BCC10(a1);
}
// BCC10: using guessed type int (__cdecl *dword_BCC10)(_DWORD);

//----- (00071F6D) --------------------------------------------------------
int __cdecl Scr_GetString(int a1)
{
  return dword_BCC14(a1);
}
// BCC14: using guessed type int (__cdecl *dword_BCC14)(_DWORD);

//----- (00071F93) --------------------------------------------------------
int __cdecl Scr_GetConstString(int a1)
{
  return (unsigned __int16)dword_BCC18(a1);
}
// BCC18: using guessed type int (__cdecl *dword_BCC18)(_DWORD);

//----- (00071FBC) --------------------------------------------------------
int __cdecl Scr_GetDebugString(int a1)
{
  return dword_BCC1C(a1);
}
// BCC1C: using guessed type int (__cdecl *dword_BCC1C)(_DWORD);

//----- (00071FE2) --------------------------------------------------------
int __cdecl Scr_GetIString(int a1)
{
  return dword_BCC20(a1);
}
// BCC20: using guessed type int (__cdecl *dword_BCC20)(_DWORD);

//----- (00072008) --------------------------------------------------------
int __cdecl Scr_GetConstIString(int a1)
{
  return (unsigned __int16)dword_BCC24(a1);
}
// BCC24: using guessed type int (__cdecl *dword_BCC24)(_DWORD);

//----- (00072031) --------------------------------------------------------
int __cdecl Scr_GetVector(int a1, int a2)
{
  return dword_BCC28(a1, a2);
}
// BCC28: using guessed type int (__cdecl *dword_BCC28)(_DWORD, _DWORD);

//----- (0007205E) --------------------------------------------------------
int __cdecl Scr_GetFunc(int a1)
{
  return dword_BCC2C(a1);
}
// BCC2C: using guessed type int (__cdecl *dword_BCC2C)(_DWORD);

//----- (00072084) --------------------------------------------------------
int __cdecl Scr_GetEntityNum(int a1, int a2)
{
  return dword_BCC38(a1, a2);
}
// BCC38: using guessed type int (__cdecl *dword_BCC38)(_DWORD, _DWORD);

//----- (000720B1) --------------------------------------------------------
int __cdecl Scr_GetType(int a1)
{
  return dword_BCC30(a1);
}
// BCC30: using guessed type int (__cdecl *dword_BCC30)(_DWORD);

//----- (000720D7) --------------------------------------------------------
int __cdecl Scr_GetPointerType(int a1)
{
  return dword_BCC34(a1);
}
// BCC34: using guessed type int (__cdecl *dword_BCC34)(_DWORD);

//----- (000720FD) --------------------------------------------------------
int Scr_GetNumParam()
{
  return dword_BCC3C();
}
// BCC3C: using guessed type int (*dword_BCC3C)(void);

//----- (0007211D) --------------------------------------------------------
int __cdecl Scr_AddBool(int a1)
{
  return dword_BCC40(a1);
}
// BCC40: using guessed type int (__cdecl *dword_BCC40)(_DWORD);

//----- (00072143) --------------------------------------------------------
int __cdecl Scr_AddInt(int a1)
{
  return dword_BCC44(a1);
}
// BCC44: using guessed type int (__cdecl *dword_BCC44)(_DWORD);

//----- (00072169) --------------------------------------------------------
int __cdecl Scr_AddFloat(int a1)
{
  return dword_BCC48(a1);
}
// BCC48: using guessed type int (__cdecl *dword_BCC48)(_DWORD);

//----- (0007218F) --------------------------------------------------------
int __cdecl Scr_AddAnim(int a1)
{
  return dword_BCC4C(a1);
}
// BCC4C: using guessed type int (__cdecl *dword_BCC4C)(_DWORD);

//----- (000721B5) --------------------------------------------------------
int Scr_AddUndefined()
{
  return dword_BCC50();
}
// BCC50: using guessed type int (*dword_BCC50)(void);

//----- (000721D5) --------------------------------------------------------
int __cdecl Scr_AddEntityNum(int a1, int a2)
{
  return dword_BCC54(a1, a2);
}
// BCC54: using guessed type int (__cdecl *dword_BCC54)(_DWORD, _DWORD);

//----- (00072202) --------------------------------------------------------
int Scr_AddStruct()
{
  return dword_BCC58();
}
// BCC58: using guessed type int (*dword_BCC58)(void);

//----- (00072222) --------------------------------------------------------
int __cdecl Scr_AddString(int a1)
{
  return dword_BCC5C(a1);
}
// BCC5C: using guessed type int (__cdecl *dword_BCC5C)(_DWORD);

//----- (00072248) --------------------------------------------------------
int __cdecl Scr_AddIString(int a1)
{
  return dword_BCC60(a1);
}
// BCC60: using guessed type int (__cdecl *dword_BCC60)(_DWORD);

//----- (0007226E) --------------------------------------------------------
int __cdecl Scr_AddConstString(unsigned __int16 a1)
{
  return dword_BCC64(a1);
}
// BCC64: using guessed type int (__cdecl *dword_BCC64)(_DWORD);

//----- (0007229C) --------------------------------------------------------
int __cdecl Scr_AddVector(int a1)
{
  return dword_BCC68(a1);
}
// BCC68: using guessed type int (__cdecl *dword_BCC68)(_DWORD);

//----- (000722C2) --------------------------------------------------------
int __cdecl Scr_AddObject(unsigned __int16 a1)
{
  return dword_BCC6C(a1);
}
// BCC6C: using guessed type int (__cdecl *dword_BCC6C)(_DWORD);

//----- (000722F0) --------------------------------------------------------
int Scr_MakeArray()
{
  return dword_BCC78();
}
// BCC78: using guessed type int (*dword_BCC78)(void);

//----- (00072310) --------------------------------------------------------
int Scr_AddArray()
{
  return dword_BCC70();
}
// BCC70: using guessed type int (*dword_BCC70)(void);

//----- (00072330) --------------------------------------------------------
int __cdecl Scr_AddArrayStringIndexed(unsigned __int16 a1)
{
  return dword_BCC74(a1);
}
// BCC74: using guessed type int (__cdecl *dword_BCC74)(_DWORD);

//----- (0007235E) --------------------------------------------------------
int __cdecl Scr_Error(int a1)
{
  return dword_BCCB4(a1);
}
// BCCB4: using guessed type int (__cdecl *dword_BCCB4)(_DWORD);

//----- (00072384) --------------------------------------------------------
int __cdecl Scr_ErrorWithDialogMessage(int a1, int a2)
{
  return dword_BCCB8(a1, a2);
}
// BCCB8: using guessed type int (__cdecl *dword_BCCB8)(_DWORD, _DWORD);

//----- (000723B1) --------------------------------------------------------
int __cdecl Scr_ParamError(int a1, int a2)
{
  return dword_BCCBC(a1, a2);
}
// BCCBC: using guessed type int (__cdecl *dword_BCCBC)(_DWORD, _DWORD);

//----- (000723DE) --------------------------------------------------------
int __cdecl Scr_ObjectError(int a1)
{
  return dword_BCCC0(a1);
}
// BCCC0: using guessed type int (__cdecl *dword_BCCC0)(_DWORD);

//----- (00072404) --------------------------------------------------------
int __cdecl Scr_SetDynamicEntityField(int a1, int a2, unsigned __int16 a3)
{
  return dword_BCCC4(a1, a2, a3);
}
// BCCC4: using guessed type int (__cdecl *dword_BCCC4)(_DWORD, _DWORD, _DWORD);

//----- (00072440) --------------------------------------------------------
int __cdecl Scr_FreeEntityNum(int a1, int a2)
{
  return dword_BCCC8(a1, a2);
}
// BCCC8: using guessed type int (__cdecl *dword_BCCC8)(_DWORD, _DWORD);

//----- (0007246D) --------------------------------------------------------
int __cdecl Scr_GetEntityId(int a1, int a2)
{
  return (unsigned __int16)dword_BCCCC(a1, a2);
}
// BCCCC: using guessed type int (__cdecl *dword_BCCCC)(_DWORD, _DWORD);

//----- (0007249D) --------------------------------------------------------
int __cdecl Scr_SetClassMap(int a1, int a2)
{
  return dword_BCCD0(a1, a2);
}
// BCCD0: using guessed type int (__cdecl *dword_BCCD0)(_DWORD, _DWORD);

//----- (000724CA) --------------------------------------------------------
int Scr_RemoveClassMap()
{
  return dword_BCCD4();
}
// BCCD4: using guessed type int (*dword_BCCD4)(void);

//----- (000724EA) --------------------------------------------------------
int __cdecl Scr_AddClassField(unsigned __int16 a1, int a2, unsigned __int16 a3)
{
  return dword_BCCE0(a1, a2, a3);
}
// BCCE0: using guessed type int (__cdecl *dword_BCCE0)(_DWORD, _DWORD, _DWORD);

//----- (0007252E) --------------------------------------------------------
int __cdecl Scr_AddFields(int a1, int a2)
{
  return dword_BCCE4(a1, a2);
}
// BCCE4: using guessed type int (__cdecl *dword_BCCE4)(_DWORD, _DWORD);

//----- (0007255B) --------------------------------------------------------
int __cdecl Scr_FindField(int a1, int a2)
{
  return (unsigned __int16)dword_BCCE8(a1, a2);
}
// BCCE8: using guessed type int (__cdecl *dword_BCCE8)(_DWORD, _DWORD);

//----- (0007258B) --------------------------------------------------------
int __cdecl Scr_GetOffset(unsigned __int16 a1, int a2)
{
  return dword_BCCEC(a1, a2);
}
// BCCEC: using guessed type int (__cdecl *dword_BCCEC)(_DWORD, _DWORD);

//----- (000725C0) --------------------------------------------------------
int __cdecl Scr_CopyEntityNum(int a1, int a2, int a3)
{
  return dword_BCCF0(a1, a2, a3);
}
// BCCF0: using guessed type int (__cdecl *dword_BCCF0)(_DWORD, _DWORD, _DWORD);

//----- (000725F4) --------------------------------------------------------
int __cdecl Scr_Init(int a1, int a2, int a3)
{
  return dword_BCCF4(a1, a2, a3);
}
// BCCF4: using guessed type int (__cdecl *dword_BCCF4)(_DWORD, _DWORD, _DWORD);

//----- (00072628) --------------------------------------------------------
int Scr_Shutdown()
{
  return dword_BCCF8();
}
// BCCF8: using guessed type int (*dword_BCCF8)(void);

//----- (00072648) --------------------------------------------------------
int Scr_Abort()
{
  return dword_BCCFC();
}
// BCCFC: using guessed type int (*dword_BCCFC)(void);

//----- (00072668) --------------------------------------------------------
int __cdecl Scr_SetLoading(int a1)
{
  return dword_BCD00(a1);
}
// BCD00: using guessed type int (__cdecl *dword_BCD00)(_DWORD);

//----- (0007268E) --------------------------------------------------------
int Scr_AllocGameVariable()
{
  return dword_BCD08();
}
// BCD08: using guessed type int (*dword_BCD08)(void);

//----- (000726AE) --------------------------------------------------------
int __cdecl Scr_InitSystem(int a1, int a2)
{
  return dword_BCD04(a1, a2);
}
// BCD04: using guessed type int (__cdecl *dword_BCD04)(_DWORD, _DWORD);

//----- (000726DB) --------------------------------------------------------
int __cdecl Scr_GetChecksum(int a1)
{
  return dword_BCD0C(a1);
}
// BCD0C: using guessed type int (__cdecl *dword_BCD0C)(_DWORD);

//----- (00072701) --------------------------------------------------------
int Scr_HasSourceFiles()
{
  return dword_BCD10();
}
// BCD10: using guessed type int (*dword_BCD10)(void);

//----- (00072721) --------------------------------------------------------
int __cdecl Scr_SaveSource(int a1)
{
  return dword_BCD14(a1);
}
// BCD14: using guessed type int (__cdecl *dword_BCD14)(_DWORD);

//----- (00072747) --------------------------------------------------------
int __cdecl Scr_LoadSource(int a1)
{
  return dword_BCD18(a1);
}
// BCD18: using guessed type int (__cdecl *dword_BCD18)(_DWORD);

//----- (0007276D) --------------------------------------------------------
int __cdecl Scr_SkipSource(int a1)
{
  return dword_BCD1C(a1);
}
// BCD1C: using guessed type int (__cdecl *dword_BCD1C)(_DWORD);

//----- (00072793) --------------------------------------------------------
int __cdecl Scr_SavePre(int a1)
{
  return dword_BCD20(a1);
}
// BCD20: using guessed type int (__cdecl *dword_BCD20)(_DWORD);

//----- (000727B9) --------------------------------------------------------
int __cdecl Scr_SavePost(int a1)
{
  return dword_BCD24(a1);
}
// BCD24: using guessed type int (__cdecl *dword_BCD24)(_DWORD);

//----- (000727DF) --------------------------------------------------------
int Scr_SaveShutdown()
{
  return dword_BCD28();
}
// BCD28: using guessed type int (*dword_BCD28)(void);

//----- (000727FF) --------------------------------------------------------
int __cdecl Scr_LoadPre(int a1, int a2)
{
  return dword_BCD30(a1, a2);
}
// BCD30: using guessed type int (__cdecl *dword_BCD30)(_DWORD, _DWORD);

//----- (0007282C) --------------------------------------------------------
int Scr_LoadShutdown()
{
  return dword_BCD34();
}
// BCD34: using guessed type int (*dword_BCD34)(void);

//----- (0007284C) --------------------------------------------------------
int __cdecl Scr_LoadScript(int a1)
{
  return dword_BCD3C(a1);
}
// BCD3C: using guessed type int (__cdecl *dword_BCD3C)(_DWORD);

//----- (00072872) --------------------------------------------------------
int __userpurge Scr_FindAnimTree@<eax>(int a1, int a2)
{
  dword_BCD40(a1, a2);
  return a1;
}
// BCD40: using guessed type int (__cdecl *dword_BCD40)(_DWORD, _DWORD);

//----- (000728A8) --------------------------------------------------------
int __cdecl Scr_FindAnim(int a1, int a2, int a3)
{
  return dword_BCD44(a1, a2, a3);
}
// BCD44: using guessed type int (__cdecl *dword_BCD44)(_DWORD, _DWORD, _DWORD);

//----- (000728DC) --------------------------------------------------------
int __cdecl Scr_GetFunctionHandle(int a1, int a2)
{
  return dword_BCD48(a1, a2);
}
// BCD48: using guessed type int (__cdecl *dword_BCD48)(_DWORD, _DWORD);

//----- (00072909) --------------------------------------------------------
int Scr_BeginLoadScripts()
{
  return dword_BCC7C();
}
// BCC7C: using guessed type int (*dword_BCC7C)(void);

//----- (00072929) --------------------------------------------------------
int Scr_BeginLoadAnimTrees()
{
  return dword_BCC80();
}
// BCC80: using guessed type int (*dword_BCC80)(void);

//----- (00072949) --------------------------------------------------------
int Scr_EndLoadScripts()
{
  return dword_BCC84();
}
// BCC84: using guessed type int (*dword_BCC84)(void);

//----- (00072969) --------------------------------------------------------
int Scr_EndLoadAnimTrees()
{
  return dword_BCC88();
}
// BCC88: using guessed type int (*dword_BCC88)(void);

//----- (00072989) --------------------------------------------------------
int __cdecl Scr_PrecacheAnimTrees(int a1)
{
  return dword_BCC8C(a1);
}
// BCC8C: using guessed type int (__cdecl *dword_BCC8C)(_DWORD);

//----- (000729AF) --------------------------------------------------------
int __cdecl Scr_FreeScripts(unsigned __int8 a1)
{
  return dword_BCC90(a1);
}
// BCC90: using guessed type int (__cdecl *dword_BCC90)(_DWORD);

//----- (000729DC) --------------------------------------------------------
int __cdecl Scr_FreeGameVariable(int a1)
{
  return dword_BCC94(a1);
}
// BCC94: using guessed type int (__cdecl *dword_BCC94)(_DWORD);

//----- (00072A02) --------------------------------------------------------
int __cdecl Scr_ShutdownSystem(unsigned __int8 a1)
{
  return dword_BCC98(a1);
}
// BCC98: using guessed type int (__cdecl *dword_BCC98)(_DWORD);

//----- (00072A2F) --------------------------------------------------------
int __cdecl Scr_IsSystemActive(unsigned __int8 a1)
{
  return dword_BCC9C(a1);
}
// BCC9C: using guessed type int (__cdecl *dword_BCC9C)(_DWORD);

//----- (00072A5C) --------------------------------------------------------
int __cdecl Scr_ExecThread(int a1, int a2)
{
  return (unsigned __int16)dword_BCCA8(a1, a2);
}
// BCCA8: using guessed type int (__cdecl *dword_BCCA8)(_DWORD, _DWORD);

//----- (00072A8C) --------------------------------------------------------
int __cdecl Scr_ExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return (unsigned __int16)dword_BCCAC(a1, a2, a3, a4);
}
// BCCAC: using guessed type int (__cdecl *dword_BCCAC)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00072ACA) --------------------------------------------------------
int __cdecl Scr_AddExecThread(int a1, int a2)
{
  return dword_BCCA0(a1, a2);
}
// BCCA0: using guessed type int (__cdecl *dword_BCCA0)(_DWORD, _DWORD);

//----- (00072AF7) --------------------------------------------------------
int __cdecl Scr_AddExecEntThreadNum(int a1, int a2, int a3, int a4)
{
  return dword_BCCA4(a1, a2, a3, a4);
}
// BCCA4: using guessed type int (__cdecl *dword_BCCA4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00072B32) --------------------------------------------------------
int __cdecl Scr_IsThreadAlive(unsigned __int16 a1)
{
  return dword_BCCB0(a1);
}
// BCCB0: using guessed type int (__cdecl *dword_BCCB0)(_DWORD);

//----- (00072B60) --------------------------------------------------------
int __cdecl Scr_FreeThread(unsigned __int16 a1)
{
  return dword_BCD4C(a1);
}
// BCD4C: using guessed type int (__cdecl *dword_BCD4C)(_DWORD);

//----- (00072B8E) --------------------------------------------------------
int __cdecl Scr_ConvertThreadToSave(unsigned __int16 a1)
{
  return (unsigned __int16)dword_BCD50(a1);
}
// BCD50: using guessed type int (__cdecl *dword_BCD50)(_DWORD);

//----- (00072BBF) --------------------------------------------------------
int __cdecl Scr_ConvertThreadFromLoad(unsigned __int16 a1)
{
  return (unsigned __int16)dword_BCD54(a1);
}
// BCD54: using guessed type int (__cdecl *dword_BCD54)(_DWORD);

//----- (00072BF0) --------------------------------------------------------
int __cdecl Scr_SetString(int a1, unsigned __int16 a2)
{
  return dword_BCD58(a1, a2);
}
// BCD58: using guessed type int (__cdecl *dword_BCD58)(_DWORD, _DWORD);

//----- (00072C25) --------------------------------------------------------
int __cdecl Scr_AllocString(int a1, int a2)
{
  return (unsigned __int16)dword_BCD5C(a1, a2);
}
// BCD5C: using guessed type int (__cdecl *dword_BCD5C)(_DWORD, _DWORD);

//----- (00072C55) --------------------------------------------------------
int __cdecl Scr_SetTime(int a1)
{
  return dword_BCD7C(a1);
}
// BCD7C: using guessed type int (__cdecl *dword_BCD7C)(_DWORD);

//----- (00072C7B) --------------------------------------------------------
int Scr_RunCurrentThreads()
{
  return dword_BCD80();
}
// BCD80: using guessed type int (*dword_BCD80)(void);

//----- (00072C9B) --------------------------------------------------------
int Scr_ResetTimeout()
{
  return dword_BCD84();
}
// BCD84: using guessed type int (*dword_BCD84)(void);

//----- (00072CBB) --------------------------------------------------------
int __cdecl Scr_NotifyNum(int a1, int a2, unsigned __int16 a3, int a4)
{
  return dword_BCD60(a1, a2, a3, a4);
}
// BCD60: using guessed type int (__cdecl *dword_BCD60)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (00072CFE) --------------------------------------------------------
int __cdecl SL_ConvertToString(unsigned __int16 a1)
{
  return dword_BCD68(a1);
}
// BCD68: using guessed type int (__cdecl *dword_BCD68)(_DWORD);

//----- (00072D2C) --------------------------------------------------------
int __cdecl SL_GetString(int a1, unsigned __int8 a2)
{
  return (unsigned __int16)dword_BCD6C(a1, a2);
}
// BCD6C: using guessed type int (__cdecl *dword_BCD6C)(_DWORD, _DWORD);

//----- (00072D63) --------------------------------------------------------
int __cdecl SL_GetLowercaseString(int a1, unsigned __int8 a2)
{
  return (unsigned __int16)dword_BCD70(a1, a2);
}
// BCD70: using guessed type int (__cdecl *dword_BCD70)(_DWORD, _DWORD);

//----- (00072D9A) --------------------------------------------------------
int __cdecl SL_FindLowercaseString(int a1)
{
  return (unsigned __int16)dword_BCD74(a1);
}
// BCD74: using guessed type int (__cdecl *dword_BCD74)(_DWORD);

//----- (00072DC3) --------------------------------------------------------
int __cdecl Scr_NotifyId(unsigned __int16 a1, unsigned __int16 a2, int a3)
{
  return dword_BCD64(a1, a2, a3);
}
// BCD64: using guessed type int (__cdecl *dword_BCD64)(_DWORD, _DWORD, _DWORD);

//----- (00072E07) --------------------------------------------------------
int __cdecl Scr_CreateCanonicalFilename(int a1)
{
  return (unsigned __int16)dword_BCD78(a1);
}
// BCD78: using guessed type int (__cdecl *dword_BCD78)(_DWORD);

//----- (00072E30) --------------------------------------------------------
int __cdecl Scr_GetAnimsIndex(int a1)
{
  return dword_BCD88(a1);
}
// BCD88: using guessed type int (__cdecl *dword_BCD88)(_DWORD);

//----- (00072E56) --------------------------------------------------------
int __cdecl Scr_GetAnims(int a1)
{
  return dword_BCD8C(a1);
}
// BCD8C: using guessed type int (__cdecl *dword_BCD8C)(_DWORD);

//----- (00072E7C) --------------------------------------------------------
int __cdecl MT_Alloc(int a1, int a2)
{
  return dword_BCD90(a1, a2);
}
// BCD90: using guessed type int (__cdecl *dword_BCD90)(_DWORD, _DWORD);

//----- (00072EA9) --------------------------------------------------------
int __cdecl MT_Free(int a1, int a2)
{
  return dword_BCD94(a1, a2);
}
// BCD94: using guessed type int (__cdecl *dword_BCD94)(_DWORD, _DWORD);

//----- (00072ED6) --------------------------------------------------------
int *__cdecl Scr_FarHook(int (__cdecl **a1)(_DWORD))
{
  unsigned int v2; // [esp+0h] [ebp-18h]
  const void *v3; // [esp+4h] [ebp-14h]
  int (__cdecl **v4)(_DWORD); // [esp+8h] [ebp-10h]

  if ( a1 )
  {
    v4 = &dword_BCC00;
    v3 = a1;
    v2 = 408;
    if ( (((unsigned __int8)(&dword_BCC00 - 140134) + (unsigned __int8)&GLOBAL_OFFSET_TABLE_) & 4) != 0 )
    {
      dword_BCC00 = *a1;
      v4 = &dword_BCC00 + 1;
      v3 = a1 + 1;
      v2 = 404;
    }
    qmemcpy(v4, v3, 4 * (v2 >> 2));
  }
  dword_BCD98 = (int)Scr_GetFunction;
  dword_BCD9C = (int)Scr_GetMethod;
  dword_BCDA0 = (int)Scr_SetObjectField;
  dword_BCDA4 = (int)Scr_GetObjectField;
  dword_BCDA8 = (int)Scr_LoadRead;
  return &dword_BCD98;
}
// 88D98: using guessed type Elf32_Dyn *GLOBAL_OFFSET_TABLE_;
// BCC00: using guessed type int (__cdecl *dword_BCC00)(_DWORD);
// BCD98: using guessed type int dword_BCD98;
// BCD9C: using guessed type int dword_BCD9C;
// BCDA0: using guessed type int dword_BCDA0;
// BCDA4: using guessed type int dword_BCDA4;
// BCDA8: using guessed type int dword_BCDA8;

//----- (00072F7F) --------------------------------------------------------
void sub_72F7F()
{
  ;
}

//----- (00072F90) --------------------------------------------------------
void (*sub_72F90())(void)
{
  void (**v0)(void); // esi
  void (*result)(void); // eax

  v0 = (void (**)(void))(&dword_88D88 - 1);
  result = (void (*)(void))*(&dword_88D88 - 1);
  if ( result != (void (*)(void))-1 )
  {
    do
    {
      --v0;
      result();
      result = *v0;
    }
    while ( *v0 != (void (*)(void))-1 );
  }
  return result;
}
// 88D88: using guessed type int dword_88D88;

//----- (00072FD0) --------------------------------------------------------
void sub_72FD0()
{
  ;
}

//----- (00072FD4) --------------------------------------------------------
int term_proc()
{
  return start();
}

// nfuncs=2208 queued=1455 decompiled=1455 lumina nreq=0 worse=0 better=0
// ALL OK, 1455 function(s) have been successfully decompiled
